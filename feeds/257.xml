<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MadPlay's MadLife.</title>
    <description>공부하는 개발자의 이야기를 담고 있습니다.</description>
    <link>https://madplay.github.io/</link>
    <atom:link href="https://madplay.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 12 May 2019 15:51:35 +0000</pubDate>
    <lastBuildDate>Sun, 12 May 2019 15:51:35 +0000</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>자바 스트림 정리 - 5. 주의할 점</title>
        <description>


  목차



  자바 스트림 정리 - 1. 소개와 스트림 생성 (링크)
  자바 스트림 정리 - 2. 중간 연산 (링크)
  자바 스트림 정리 - 3. 결과 구하기 (링크)
  자바 스트림 정리 - 4. 예제 (링크)
  자바 스트림 정리 - 5. 주의할 점





  무조건 스트림이 좋을까?


지금까지 스트림을 생성하는 방법과 필요에 맞게 가공하는 중간 연산(Intermediate Operations) 그리고
원하는 결과를 구하는 단말 연산(Terminal Operations)에 대해서 알아보았고 스트림을 활용하는 여러 가지 예제도 살펴보았습니다.

이전보다 더 간결한 코드를 얻게 되었고 비교적 최신 기술을 적용했기 때문에 스트림 API를 활용하는 것이 더 좋아 보일 수 있습니다.
하지만 경우에 따라서 다를 수 있고 오히려 성능이 더 좋지 않을 수 있습니다.

이번 포스팅에서는 스트림 API를 사용할 때 주의할 부분과 적용할 때 고민해보면 좋을 포인트를 정리해봅시다.




  스트림 재사용


흔하게 접할 수 있는 실수 하나는 스트림을 재사용하는 것입니다.
스트림을 컬렉션처럼 사용했다가 적지않게 겪은 것 같습니다.

// 문자열 스트림 생성
Stream&amp;lt;String&amp;gt; langNames = Stream.of(&quot;Java&quot;, &quot;C++&quot;, &quot;Python&quot;, &quot;Ruby&quot;);

// 스트림 내 모든 요소 출력
langNames.forEach(System.out::println);

// &quot;Java&quot; 만 제외한 스트림을 다시 생성... Exception이 발생한다.
Stream&amp;lt;String&amp;gt; filtered = langNames.filter(lang -&amp;gt; !lang.equals(&quot;Java&quot;));
filtered.forEach(System.out::println);


위 코드를 실행하면 IllegalStateException이 발생합니다.

java.lang.IllegalStateException: stream has already been operated upon or closed

스트림은 오직 한 번만 소비될 수 있기 때문에 사용한 이후에 다시 사용하는 경우 에러를 발생시킬 수 있습니다.




  스트림은 무조건 좋다


기존의 배열이나 컬렉션을 반복하는 for-loop 문장을 스트림의 foreach로 변경하는 경우도 많습니다.
하지만 성능을 비교해보면 무조건적으로 스트림이라고 성능적으로 빠른 것은 아닙니다.

10만개의 랜덤값이 들어있는 배열에서 가장 큰 값을 찾는 코드가 있습니다. 첫 번째는 기본 for-loop를 이용하여 찾고
두 번째 방법으로 Stream을 이용해서, 마지막으로 병렬 수행이 가능한 Parallel Stream으로 수행했을 때의
수행 속도 차이를 비교해봅시다.

// new Random().nextInt로 초기화된 배열로 가정
int[] intArray;

// Case 1: for-loop
int maxValue1 = Integer.MIN_VALUE;
for (int i = 0; i &amp;lt; intArray.length; i++) {
    if (intArray[i] &amp;gt; maxValue) {
        maxValue1 = intArray[i];
    }
}

// Case 2: Stream
int maxValue2 = Arrays.stream(intArray)
    .reduce(Integer.MIN_VALUE, Math::max);

// Case 3: Parallel Stream
int maxValue3 = Arrays.stream(intArray).parallel()
    .reduce(Integer.MIN_VALUE, Math::max);    


측정 시간은 각 Case에 수행 전과 후에 System.nanoTime()로 측정했으며,
TimeUnit 클래스를 사용하여 밀리초 단위로 변환했습니다.

// nanoseconds to milliseconds
TimeUnit.MILLISECONDS.convert((endTime - startTime), TimeUnit.NANOSECONDS)


출력 결과는 어떻게 나올까요? 기본 for-loop를 사용했을 때 가장 빠릅니다.

for-loop: 8ms
Stream: 123ms
Parallel Stream: 15ms


관련 참고자료를 인용하면, 단순 for-loop의 경우 오버헤드가 없는 단순한 인덱스 기반 메모리 접근이기 때문에
Stream을 사용했을 때보다 더 빠르다고 합니다. (“It is an index-based memory access with no overhead whatsoever.”)

또, 컴파일러의 관점에서 오랫동안 유지해온 for-loop의 경우 최적화를 할 수 있으나 반대로 비교적 최근에 도입된 스트림의 경우 
for-loop와 같은 정교한 최적화를 수행하지 않습니다.

따라서 모든 for-loop를 Stream을 이용해 변경하는 것은 어떻게보면 오히려 성능을 더 떨어뜨릴 수 있습니다.




  가독성


소제목은 ‘가독성(readability)’ 이지만 스트림을 사용하면서 주의해야 한다기보다는 조금 고민해볼만한 부분이라고 할 수 있습니다.
특히 다른 사람들과 같이 개발을 진행할 때 말이지요. 코드 리뷰를 하다보면 “코드가 라인 수가 줄어들었고 가독성이 좋아졌다.” 라고
하지만 이는 어떻게 보면 팀원 모두가 스트림 API 사용에 익숙해야 하는 조건이 필요합니다.

개인적으로도 Java 8 버전 이상의 코드 스타일이 익숙하지 않아서 리뷰에 어려움이 있었던 적이…

문자열이 들어있는 배열에서 특정 문자열을 찾고 출력하는 코드는 아래와 같이 두 가지 방법으로 작성할 수 있습니다.

// array
String[] languages = {&quot;Java&quot;, &quot;C&quot;, &quot;Python&quot;, &quot;Ruby&quot;, &quot;C++&quot;, &quot;Kotlin&quot;};
        
// for-loop
String result = &quot;&quot;;
for (String language : languages) {
    if (language.equals(&quot;Java&quot;)) {
        result = language;
        break;
    }
}
if(result != null &amp;amp;&amp;amp; result != &quot;&quot;) {
    System.out.println(result);
}

// Stream
Arrays.stream(languages)
        .filter(lang -&amp;gt; lang.equals(&quot;Java&quot;))
        .findFirst().ifPresent(System.out::println);


자바8의 스트림을 이용하여 여러 if 조건문과 결과를 담는 부수적인 변수 할당도 사라졌습니다.
짧고 간결한 코드가 되는 것에는 전적으로 공감할 수 있습니다. 메서드의 네이밍도 명확하기 때문에 이해하기도 쉽습니다.
물론 이부분은 앞서 말한 것처럼 스트림 API에 익숙해야하며 개인차이가 있을 수도 있습니다.




  무한 스트림


기존에 생성된 배열이나 컬렉션을 통해서 스트림을 생성하는 경우에는 이슈가 없을 수 있으나, 특정 조건에 따라서
스트림을 생성하는 경우에는 무한 스트림(Infinite Streams)이 생성될 수 있습니다. 심지어 요소 개수에 제한을 걸었음에도 불구하고요.

Stream.iterate(0, i -&amp;gt; (i + 1) % 2)
        .distinct()
        .limit(10)
        .forEach(System.out::println);
System.out.println(&quot;코드 실행 종료&quot;);


위 코드의 각 라인을 설명하면 아래와 같습니다.


  iterate: 2로 나머지 연산을 했으므로 0과 1을 반복적으로 생성합니다.
  distinct: 각각 단일 0과 1을 유지합니다.
  limit: 10개의 스트림 크기 제한이 생깁니다.
  forEach: 생성된 스트림 요소를 모두 출력합니다.


위 코드에서  distinct 연산자는 스트림을 생성하는 iterate 메서드에서 0과 1만 생성된다는 것을 알지 못합니다.
따라서 요소의 개수를 10개로 제한하는 limit 연산에 도달할 수 없습니다.

그러므로 이어지는 forEach를 이용한 요소 출력도 진행되지 않으며, 모든 코드가 종료된 것을 출력하는 문장도
수행되지 않습니다. 코드는 종료되지 않고 계속 리소스를 차지하게 됩니다.

물론 distinct와 limit의 순서를 바꾸면 정상적으로 수행됩니다.
생성될 스트림의 요소에 개수 제한을 걸고 그 이후에 중복을 제거하면 되지요.

Stream.iterate(0, i -&amp;gt; (i + 1) % 2)
        .limit(10)
        .distinct()
        .forEach(System.out::println);
System.out.println(&quot;코드 실행 종료&quot;);

// 0
// 1
// 코드 실행 종료





  변수 접근


스트림을 이용하면서 람다(lambda) 또는 메서드 참조(method references)를 사용하는 경우에는 지역 변수(local variables)에
접근할 수 없습니다.

int sumForLambda = 0;
for (int i = 0; i &amp;lt; 5; i++) {
    // it works!
    sumForLambda += i;
}

int sumForloop = 0;
IntStream.range(0, 5).forEach(i -&amp;gt; {
    // compile error
    sumForloop += i;
}); 


그리고 스트림의 파이프라인에서 연결된 각 단계의 값들에 접근할 수 없습니다.
peek 메서드로 연산 사이의 결과를 확인하고 싶지만 불가능합니다.

Arrays.stream(array)
        .filter(first -&amp;gt; first % 2 == 0)
        .filter(second -&amp;gt; second &amp;gt; 3)
        .peek(value -&amp;gt; {
            // compile error, can't access second filter's variable
            int printValue = value + second;
            System.out.println(printValue);
        })
        .sum();


참고로 peek 메서드의 경우 스트림의 결과를 구하는 단말 연산(Terminal Operations)이 실행되지 않으면
메서드 자체가 실행되지 않습니다. 위의 예제에서는 sum 메서드가 단말 연산으로 실행되었습니다.




  스트림의 동작 순서


스트림을 사용할 때는 동작 방식을 이해할 필요가 있습니다. 아래와 같이 3개의 요소를 가진 배열로 스트림 연산을 수행하는
코드가 있습니다. 그리고 연결된 각 메서드마다 출력문으로 메서드가 실행되었는지 확인합니다.

Arrays.stream(new String[]{&quot;c&quot;, &quot;python&quot;, &quot;java&quot;})
        .filter(word -&amp;gt; {
            System.out.println(&quot;Call filter method: &quot; + word);
            return word.length() &amp;gt; 3;
        })
        .map(word -&amp;gt; {
            System.out.println(&quot;Call map method: &quot; + word);
            return word.substring(0, 3);
        }).findFirst();


결과는 어떻게 나올까요? 3개의 요소에 대해서 메서드를 수행하므로 각각 3번의 호출이 이뤄질 것 같지만,
출력 결과는 그렇지 않습니다.

Call filter method: c
Call filter method: python
Call map method: python


위 결과를 통해서 스트림의 동작 방식을 유추할 수 있는데요. 
스트림 내의 모든 요소가 중간 연산인 filter 메서드를 수행하는 것이 아니라 요소 하나씩 모든 파이프라인을 수행합니다.

따라서 조금 더 자세히 살펴보면 아래와 같이 단계적으로 수행됩니다.


  배열의 첫 번째 요소 “c”
    
      filter 메서드가 실행되지만 length가 3보다 크지 않으므로 다음으로 진행되지는 않음
      “Call filter method: c” 출력
    
  
  배열의 두 번째 요소 “python”
    
      filter 메서드가 실행되며 length가 3보다 크므로 다음으로 진행됨
      “Call filter method: python” 출력
      map 메서드에서 substring 메서드를 수행합니다.
      “Call map method: python” 출력
      마지막 연산인 findFirst가 수행됩니다.
    
  
  조건에 맞는 하나의 결과를 찾았기 때문에 다음 요소인 “java”에 대해 연산을 수행하지 않습니다.
    
      최종 결과는 “pyth” 입니다.
    
  





  성능 개선


이러한 특성을 잘 이용하면 스트림의 성능을 조금 더 개선할 수 있습니다. 아래와 같이 배열의 모든 문자열 요소를
대문자로 변환하는 코드가 있습니다. 그리고 수행된 결과에서 2개를 생략하여 리스트로 만듭니다.

Arrays.stream(new String[]{&quot;c&quot;, &quot;python&quot;, &quot;java&quot;})
        .map(word -&amp;gt; {
            System.out.println(&quot;Call map method: &quot; + word);
            return word.toUpperCase();
        })
        .skip(2)
        .collect(Collectors.toList());

// Call map method: c
// Call map method: python
// Call map method: java


map 메서드가 총 3번 호출되는 것을 알 수 있습니다. 여기서 메서드의 실행 순서를 변경하면 어떻게 될까요?

Arrays.stream(new String[]{&quot;c&quot;, &quot;python&quot;, &quot;java&quot;})
        .skip(2)
        .map(word -&amp;gt; {
            System.out.println(&quot;Call map method: &quot; + word);
            return word.toUpperCase();
        })
        .collect(Collectors.toList());

// Call map method: java


물론 filter 메서드와 같은 특정 조건을 추가해서 사용할 때는 skip 메서드의 위치에 따라서 결과가
달라질 수 있으므로 주의해야 합니다.

List&amp;lt;String&amp;gt; list = Arrays.stream(new String[]{&quot;abc&quot;, &quot;abcd&quot;, &quot;abcde&quot;, &quot;abcdef&quot;})
        .filter(word -&amp;gt; word.length() &amp;gt; 3)
        .map(word -&amp;gt; word.toUpperCase())
        .skip(2)
        .collect(Collectors.toList());
        
// ABCDEF 
list.forEach(System.out::println);

List&amp;lt;String&amp;gt; list2 = Arrays.stream(new String[]{&quot;abc&quot;, &quot;abcd&quot;, &quot;abcde&quot;, &quot;abcdef&quot;})
        .skip(2)
        .filter(word -&amp;gt; word.length() &amp;gt; 3)
        .map(word -&amp;gt; word.toUpperCase())
        .collect(Collectors.toList());
        
// ABCDE
// ABCDEF 
list2.forEach(System.out::println);





  참고 자료



  How fast are the Java 8 streams? - Angelika Langer
  10 Subtle Mistakes When Using the Streams API

</description>
        <pubDate>Mon, 11 Feb 2019 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/mistakes-when-using-java-streams</link>
        <guid isPermaLink="true">https://madplay.github.io/post/mistakes-when-using-java-streams</guid>
        
        <category>java</category>
        
        <category>stream</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>자바 스트림 정리 - 4. 스트림 예제</title>
        <description>


  목차



  자바 스트림 정리 - 1. 소개와 스트림 생성 (링크)
  자바 스트림 정리 - 2. 중간 연산 (링크)
  자바 스트림 정리 - 3. 결과 구하기 (링크)
  자바 스트림 정리 - 4. 예제
  자바 스트림 정리 - 5. 주의할 점 (링크)





  스트림 API 예제


이번 포스팅에서는 스트림 API를 사용하는 여러 가지 예제들을 살펴봅니다.
예제에서 사용하는 Person 클래스는 아래와 같이 미리 작성되있음을 가정합니다.

class Person {
    private String name;
    private int age;
    private String phoneNumber;

    public Person(String name, int age, String phoneNumber) {
        this.name = name;
        this.age = age;
        this.phoneNumber = phoneNumber;
    }
    
    // getter, setter 생략
}





  List&amp;lt;V&amp;gt; to Map&amp;lt;K, V&amp;gt;


List 형태를 Map 형태로 바꿔봅시다. List&amp;lt;V&amp;gt; 형태와 같이 특정 오브젝트 타입의 리스트를
오브젝트의 한 필드를 키로 하는 Map&amp;lt;K, V&amp;gt; 형태로 변경합니다.

List&amp;lt;Person&amp;gt; personList = new ArrayList&amp;lt;&amp;gt;();
personList.add(new Person(&quot;짱구&quot;, 23, &quot;010-1234-1234&quot;));
personList.add(new Person(&quot;유리&quot;, 24, &quot;010-2341-2341&quot;));
personList.add(new Person(&quot;철수&quot;, 29, &quot;010-3412-3412&quot;));
personList.add(new Person(&quot;맹구&quot;, 25, null));

// Function.identity는 t -&amp;gt; t, 항상 입력된 인자(자신)를 반환합니다.
Map&amp;lt;String, Person&amp;gt; personMap = personList.stream()
        .collect(Collectors.toMap(Person::getName, Function.identity()));


처음 스트림 API를 접했을 때 위와 같은 축약형 코드가 난해했던 경험이 있는데요.
아래와 같이 람다표현식이나 메서드 참조를 모두 풀어서 이해한 적도 있던 것 같습니다.

Map&amp;lt;String, Person&amp;gt; personMap = personList.stream()
        .collect(Collectors.toMap(new Function&amp;lt;Person, String&amp;gt;() {
            @Override
            public String apply(Person person) {
                return person.getName();
            }
        }, new Function&amp;lt;Person, Person&amp;gt;() {
            @Override
            public Person apply(Person person) {
                return person;
            }
        }));


추가적으로 filter 메서드를 사용하면 특정 조건에 일치한 형태만 골라낼 수 있습니다.

Map&amp;lt;String, Person&amp;gt; personMap = personList.stream()
        .filter(person -&amp;gt; person.getAge() &amp;gt; 24) // 25살 이상만 골라낸다.
        .collect(Collectors.toMap(Person::getName, Function.identity()));


한편 Collectors.toMap 메서드를 수행할 때 하나의 키에 매핑되는 값이 2개 이상인 경우
IllegalStateException 예외가 발생합니다. 이럴 때는 BinaryOperator를 사용하여 아래와 같이 저장할 값을 선택할 수 있습니다.

Map&amp;lt;Integer, Person&amp;gt; personMap = personList.stream()
        .collect(Collectors.toMap(
                o -&amp;gt; o.getAge(),
                Function.identity(),
                (oldValue, newValue) -&amp;gt; newValue)); // 중복되는 경우 새 값으로 넣는다.


아니면 중복 키(duplicatekey)를 허용할 수도 있는데요. Collectors.groupingBy 메서드를 사용하여 조금 다른 형태로
중복키를 허용한 리스트 형태로 담을 수도 있습니다.

// List 형태로 담는다.
Map&amp;lt;Integer, List&amp;lt;Person&amp;gt;&amp;gt; duplicatedMap = personList.stream()
        .collect(Collectors.groupingBy(Person::getAge));





  스트림 내에서 null 제외하기


위에서 살펴본 filter 메서드를 적절하게 사용하면 스트림 내의 null 값을 제외시킬 수 있습니다.

Stream&amp;lt;String&amp;gt; stream = Stream.of(&quot;철수&quot;, &quot;훈이&quot;, null, &quot;유리&quot;, null);
List&amp;lt;String&amp;gt; filteredList = stream.filter(Objects::nonNull)
        .collect(Collectors.toList());        





  조건에 일치한 요소 찾기


filter 메서드와 findFirst 메서드로 조건에 일치한 가장 첫 요소를 찾을 수 있습니다.

List&amp;lt;Person&amp;gt; personList = new ArrayList&amp;lt;&amp;gt;();
personList.add(new Person(&quot;짱구&quot;, 23, &quot;010-1234-1234&quot;));
personList.add(new Person(&quot;유리&quot;, 24, &quot;010-2341-2341&quot;));
personList.add(new Person(&quot;맹구&quot;, 23, &quot;010-3412-3412&quot;));

// 짱구
Person person = personList.stream()
        .filter(p -&amp;gt; p.getAge() == 23)
        .findFirst().get();


findFirst 메서드 대신에 findAny 메서드도 가능합니다.
단, 일반 스트림에서는 동일한 요소(짱구)가 결과로 나오지만 병렬 스트림에서는 매 실해마다 다를 수 있습니다.
순서에 상관없이 조건에 충족한 요소를 찾고 싶을 때 findAny 메서드가 효과적일 수 있습니다.

// 짱구 또는 맹구
Person person = personList.parallelStream()
        .filter(p -&amp;gt; p.getAge() == 23)
        .findAny().get();





  스트림 정렬하기


스트림을 주어진 조건으로 정렬할 수 있습니다. 예를 들어 나이(age) 값을 기준으로 오름차순 정렬을 한다면,

List&amp;lt;Person&amp;gt; personList = new ArrayList&amp;lt;&amp;gt;();
personList.add(new Person(&quot;짱구&quot;, 25, &quot;010-1234-1234&quot;));
personList.add(new Person(&quot;유리&quot;, 24, &quot;010-2341-2341&quot;));
personList.add(new Person(&quot;맹구&quot;, 23, &quot;010-3412-3412&quot;));
personList.add(new Person(&quot;훈이&quot;, 26, &quot;010-4123-4123&quot;));

// 맹구, 유리, 짱구, 훈이
personList.stream()
        .sorted(Comparator.comparing(Person::getAge))
        .forEach(p -&amp;gt; System.out.println(p.getName()));


Comparator.comparing 메서드에 reversed 메서드를 추가하면 역순으로도 정렬할 수 있습니다.
내부를 살펴보면 자바8 버전에서 추가된 Collections.reverseOrder를 사용하여 역순으로 정렬합니다.

// 훈이, 짱구, 유리, 맹구
personList.stream()
        .sorted(Comparator.comparing(Person::getAge).reversed())
        .forEach(p -&amp;gt; System.out.println(p.getName()));





  reduce로 결과 구하기


reduce 메서드로 스트림을 하나의 결과로 연산할 수 있습니다.
예를 들어 아래와 같이 숫자로 구성된 리스트 내의 요소를 모두 더해 합계(sum)를 구할 수 있습니다.

List&amp;lt;Integer&amp;gt; list = List.of(5, 4, 2, 1, 6, 7, 8, 3);
        
// 36
Integer result = list.stream()
        .reduce(0, (value1, value2) -&amp;gt; value1 + value2);


박싱 비용을 줄이기 위한 IntStream처럼 기본형에 특화된 스트림으로도 처리할 수 있습니다.
primitive type인 int 형태로 반환됩니다.

// 36
int intResult = list.stream()
        // 또는 .mapToInt(x -&amp;gt; x).sum();
        .mapToInt(Integer::intValue).sum();


아래와 같이 “Swift 라는 문자열보다 길고 리스트 중에서 가장 긴 문자열” 이라는
특정 조건을 만족한 것만 추출할 수도 있습니다.

List&amp;lt;String&amp;gt; list = List.of(&quot;Java&quot;, &quot;C++&quot;, &quot;Python&quot;, &quot;Ruby&quot;);

// Python
String result = list.stream()
        .reduce(&quot;Swift&quot;, (val1, val2) -&amp;gt;
                val1.length() &amp;gt;= val2.length() ? val1 : val2);





  단일 컬렉션 만들기


2차원 배열과 같은 요소를 flatmap 메서드를 사용하여 중첩 구조를 제거하고 단일 컬렉션으로 만들 수 있습니다.

String[][] names = new String[][]{
        {&quot;짱구&quot;, &quot;철수&quot;}, {&quot;훈이&quot;, &quot;맹구&quot;}
};

// 리스트로
List&amp;lt;String&amp;gt; list = Arrays.stream(names)
        .flatMap(Stream::of)
        .collect(Collectors.toList());
        
// 1차원 배열로
String[] flattedNames = Arrays.stream(names)
        .flatMap(Stream::of).toArray(String[]::new);





  이어서


스트림 API를 이용한 여러가지 예제에 대해서 알아보았습니다. 
이어지는 포스팅에서는 스트림 API를 사용하면서 주의할 점에 대해서 알아봅니다.


  
자바 스트림 정리 - 5. 주의할 점 (링크)

</description>
        <pubDate>Sat, 09 Feb 2019 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/java-streams-examples</link>
        <guid isPermaLink="true">https://madplay.github.io/post/java-streams-examples</guid>
        
        <category>java</category>
        
        <category>stream</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>자바 스트림 정리 - 3. 결과 구하기</title>
        <description>


  목차



  자바 스트림 정리 - 1. 소개와 스트림 생성 (링크)
  자바 스트림 정리 - 2. 중간 연산 (링크)
  자바 스트림 정리 - 3. 결과 구하기
  자바 스트림 정리 - 4. 예제 (링크)
  자바 스트림 정리 - 5. 주의할 점 (링크)





  스트림 종료 연산


이제 마지막으로 가공한 스트림을 결과로 만들어내는 단말 연산(Terminal Operations)입니다.
다양한 형태로 결과 값을 구할 수 있습니다. 어떤 연산이 있는지 알아봅시다.




  순회(iterate)


forEach 메서드를 사용하여 스트림을 순회할 수 있습니다.

List&amp;lt;Integer&amp;gt; list = List.of(3, 2, 1, 5, 7);
list.stream().forEach(System.out::println);


다만 forEach 메서드는 병렬 스트림을 사용했을 때 순서를 보장할 수 없습니다. 따라서 스트림을 순서대로 순회하고 싶은 경우
forEachOrdered 메서드를 사용해야 합니다.

List&amp;lt;Integer&amp;gt; list = List.of(3, 1, 2);

// 매 실행마다 출력 결과가 동일하지 않다.
list.parallelStream().forEach(System.out::println);

// 매 실행마다 동일한 출력 결과
list.parallelStream().forEachOrdered(System.out::println);





  결과 합치기(reduce)


reduce 연산을 이용해 모든 스트림 요소를 처리하여 결과를 구할 수 있습니다.
이 메서드는 아래와 같이 세 가지 형태로 오버로딩(overloading)되어 있습니다.

// 형태1
Optional&amp;lt;T&amp;gt; reduce(BinaryOperator&amp;lt;T&amp;gt; accumulator); 

// 형태2
T reduce(T identity, BinaryOperator&amp;lt;T&amp;gt; accumulator);

//형태3
&amp;lt;U&amp;gt; U reduce(U identity, BiFunction&amp;lt;U, ? super T, U&amp;gt; accumulator,
            BinaryOperator&amp;lt;U&amp;gt; combiner);


먼저 인자가 하나만 있는 형태입니다. 인자로는 BinaryOperator를 사용하는데
이는 두 개의 같은 타입 요소를 인자로 받아 동일한 타입의 결과를 반환하는 함수형 인터페이스를 사용합니다.

List&amp;lt;Integer&amp;gt; list = List.of(1, 2, 3);
Optional&amp;lt;Integer&amp;gt; result = list.stream().reduce((a, b) -&amp;gt; a + b); // 6
// list.stream().reduce(Integer::sum);


다음으로 두 개의 인자를 받는 형태는 항등값과 BinaryOperator를 받습니다.
아래와 같이 초기값을 줄 수도 있습니다.

List&amp;lt;Integer&amp;gt; list = List.of(1, 2, 3);
Integer result = list.stream().reduce(1, Integer::sum);

// 7
System.out.println(result);


마지막으로 세 개의 인자를 받는 형태입니다. 항등값, BiFunction, BinaryOperator를 받습니다.
값을 누적하는 연산의 경우 병렬 연산의 결과를 결합해야 하는데, 여기서 세 번째 인자가 그 역할을 합니다.
그러니까 병렬 처리를 하는 경우에 각자 다른 스레드의 결과를 합쳐줍니다.

List&amp;lt;Integer&amp;gt; list = List.of(3, 7, 9);
Integer result = list.parallelStream()
        .reduce(1, Integer::sum, (a, b) -&amp;gt; {
            System.out.println(&quot;in combiner&quot;);
            return a + b;
        });

System.out.println(result);
// 출력 결과
// in combiner a:8 b:10
// in combiner a:4 b:18
// 22


일반 스트림에서는 combiner가 수행되지 않으므로 결과값도 다릅니다. 즉 병렬 스트림에서만 동작합니다.
초기값 1에 스트림의 요소 값을 더한 값을 계산합니다. (1+3=4, 1+9=10, 1+7=8) 그리고 다음 과정에서 combiner 연산에서는
여러 스레드에서 나누어 연산한 값을 합칩니다. (8+10=18, 4+18=22)




  계산하기: 최솟값, 총합, 평균 등


스트림 API에서 값을 구하는 연산을 이용하면 간단하게 최솟값 또는 최댓값을 구할 수 있습니다.

// Optional을 리턴한다.
OptionalDouble min = DoubleStream.of(4.1, 3.4, -1.3, 3.9, -5.7).min();
min.ifPresent(System.out::println);

// 5
int max = IntStream.of(2, 4, 5, 3).max().getAsInt();


요소의 개수를 구할 수 있습니다.

// 결과 4
long count = IntStream.of(2, 4, 1, 3).count()


요소의 총합을 구하거나 평균을 구할 수 있습니다.
다만 기본형에 특화된 IntStream, LongStream, DoubleStream 에만 기본적으로 메서드가 제공됩니다.

// 결과 7.1
double sum = DoubleStream.of(3.1, 2.6, 1.4).sum();

// // Optional을 반환한다.
OptionalDouble average = IntStream.of(3, 2, 1).average();

// 결과 2.0
average.ifPresent(System.out::println);





  결과 모으기(Collect)


스트림을 List, Set 그리고 Map과 같은 다른 형태의 결과로 변환해줍니다.
아래와 같은 클래스가 있다고 가정하고 여러 가지 collect 연산을 진행해봅시다.

class Food {
    public Food(String name, int cal) {
        this.name = name;
        this.cal = cal;
    }

    private String name;
    private int cal;
    
    @Override
    public String toString() {
        return String.format(&quot;name: %s, cal: %s&quot;, name, cal);
    }

    // getter, setter 생략
}

List&amp;lt;Food&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
list.add(new Food(&quot;burger&quot;, 520));
list.add(new Food(&quot;chips&quot;, 230));
list.add(new Food(&quot;coke&quot;, 143));
list.add(new Food(&quot;soda&quot;, 143));





  Collectors.toList: 작업 결과를 리스트로 반환


List&amp;lt;String&amp;gt; nameList = list.stream()
        .map(Food::getName) // name 얻기
        .collect(Collectors.toList()); // list로 수집





  숫자값의 합, 평균 등 구하기


스트림 내 요소들의 합, 평균 등을 구할 수 있습니다.

// name 길이의 합 구하기
Integer summingName = list.stream()
        .collect(Collectors.summingInt(s -&amp;gt; s.getName().length()));
    
// mapToInt 메서드로 칼로리(cal) 합 구하기
int sum = list.stream().mapToInt(Food::getCal).sum();

// 평균 구하기: averagingInt
Double averageInt = list.stream()
        .collect(Collectors.averagingInt(Food::getCal));

// 평균 구하기: averagingDouble
Double averageDouble = list.stream()
        .collect(Collectors.averagingDouble(Food::getCal));


위에서 살펴본 값들은 summarizingInt와 같은 통계를 얻을 수 있는 메서드를 이용하면
한번에 그 정보를 담을 수 있습니다.

IntSummaryStatistics summaryStatistics = list.stream()
        .collect(Collectors.summarizingInt(Food::getCal));

summaryStatistics.getAverage(); // 평균
summaryStatistics.getCount(); // 개수
summaryStatistics.getMax(); // 최댓값
summaryStatistics.getMin(); // 최솟값
summaryStatistics.getSum(); // 합계





  스트림 연산 결과를 하나의 문자열로 만들기


스트림의 연산 결과를 하나의 문자열로 합칠 수 있습니다. 3개의 오버로딩된 메서드를 제공하며 아래와 같이
여러 가지 방법으로 사용할 수 있습니다.

// without arguments
String defaultJoining = list.stream()
        .map(Food::getName).collect(Collectors.joining());

// burgerchipscokesoda
System.out.println(defaultJoining);


구분자(delimiter)를 인자로 받아서 처리할 수 있습니다. 이어지는 문자열 사이에 위치하게 됩니다.

// delimiter
String delimiterJoining = list.stream()
        .map(Food::getName).collect(Collectors.joining(&quot;,&quot;));

// burger,chips,coke,soda
System.out.println(delimiterJoining);


구분자와 prefix, suffix를 같이 사용할 수 있습니다. 결과의 맨 앞과 맨 뒤에 붙일 문자를 지정합니다.

// delimiter, prefix, suffix
String combineJoining = list.stream()
        .map(Food::getName).collect(Collectors.joining(&quot;,&quot;, &quot;[&quot;, &quot;]&quot;));

// [burger,chips,coke,soda]
System.out.println(combineJoining);





  특정 조건으로 그룹 짓기


스트림 내의 요소들을 주어진 조건에 맞추어 그룹핑(Grouping)할 수 있습니다.

// 칼로리(cal)로 그룹 만들기
Map&amp;lt;Integer, List&amp;lt;Food&amp;gt;&amp;gt; calMap = list.stream()
        .collect(Collectors.groupingBy(Food::getCal));

// { 230=[name: chips, cal: 230],
//   520=[name: burger, cal: 520],
//   143=[name: coke, cal: 143, name: soda, cal: 143]}
System.out.println(calMap);





  참, 거짓으로 그룹 짓기


partitioningBy는 인자로 Predicate 함수형 인터페이스를 받습니다.
Predicate는 인자를 받아서 참 또는 거짓을 반환하기 때문에 boolean 값으로 그룹핑합니다.

// 200 칼로리가 넘는 지로 구분
Map&amp;lt;Boolean, List&amp;lt;Food&amp;gt;&amp;gt; partitionMap = list.stream()
        .collect(Collectors.partitioningBy(o -&amp;gt; o.getCal() &amp;gt; 200));

// { false=[name: coke, cal: 143, name: soda, cal: 143],
//   true=[name: burger, cal: 520, name: chips, cal: 230]}
System.out.println(partitionMap);





  Map으로 결과 모으기


음식의 칼로리(cal)를 key, 이름을 value 값으로 맵을 생성해봅시다.
아래와 같이 Collectors.toMap 메서드를 사용해서 쉽게 구현할 수 있습니다.

// Exception 발생!
Map&amp;lt;Integer, String&amp;gt; map = list.stream()
        .collect(Collectors.toMap(
                o -&amp;gt; o.getCal(),
                o -&amp;gt; o.getName()
        ));
System.out.println(map);


다만 위 메서드를 수행하면 아래와 같은 오류를 볼 수 있습니다.
java.lang.IllegalStateException: Duplicate key 143 (attempted merging values coke and soda)

키에 값이 2개 이상 존재하게 되는 경우 컬렉터는 IllegalStateException을 던집니다.
따라서 키가 중복되는 예외 상황을 해결하기 위해 BinaryOperator 인자를 추가할 수 있습니다.

// 동일한 키가 있는 경우 새 값으로 대체한다.
Map&amp;lt;Integer, String&amp;gt; map = list.stream()
        .collect(Collectors.toMap(
                o -&amp;gt; o.getCal(),
                o -&amp;gt; o.getName(),
                (oldValue, newValue) -&amp;gt; newValue));

// {230=chips, 520=burger, 143=soda}
System.out.println(map);





  collect 후에 연산 추가하기


collectingAndThen 메서드를 이용하면 특정 타입의 형태로 수집(collect)한 이후에
추가 연산을 진행할 수 있습니다.

// 칼로리(cal)가 가장 높은 객체 반환
Food food = list.stream()
        .collect(Collectors.collectingAndThen(
                Collectors.maxBy(Comparator.comparing(Food::getCal)),
                (Optional&amp;lt;Food&amp;gt; o) -&amp;gt; o.orElse(null)));

// name: burger, cal: 520
System.out.println(food);





  직접 Collector를 만들기


그 밖의 로직을 위해서 직접 Collector를 만들어서 사용할 수 있습니다.

// 직접 collector 생
Collector&amp;lt;Food, StringJoiner, String&amp;gt; foodNameCollector = Collector.of(
        () -&amp;gt; new StringJoiner(&quot; | &quot;), // supplier: collector 생성
        (a, b) -&amp;gt; a.add(b.getName()), // accumulator: 두 값을 가지고 계산
        (a, b) -&amp;gt; a.merge(b), // combiner: 계산 결과 수집(합치기)
        StringJoiner::toString); // finisher
        
//만들 컬렉터를 스트림에 적용
String foodNames = list.stream().collect(foodNameCollector);

// burger | chips | coke | soda
System.out.println(foodNames);





  조건 체크(Matching)


Predicate 조건식을 인자로 받아서 해당 조건을 만족하는 요소가 있는지 체크할 수 있습니다.


  하나라도 만족하는가? (anyMatch)


// 300 칼로리가 넘는 것이 하나라도 있는가?
boolean anyMatch = list.stream()
        .anyMatch(food -&amp;gt; food.getCal() &amp;gt; 300);



  모두 조건을 만족하는가? (allMatch)


// 모두 100 칼로리가 넘는가?
boolean allMatch = list.stream()
        .allMatch(food -&amp;gt; food.getCal() &amp;gt; 100);



  모두 조건을 만족하지 않는가? (noneMatch)


// 모두 1000 칼로리가 넘지 않는가?
boolean noneMatch = list.stream()
        .noneMatch(food -&amp;gt; food.getCal() &amp;lt; 1000);





  이어서


여러 가지 연산을 적용한 스트림으로부터 원하는 결과를 얻는 방법을 알아보았습니다. 
이어지는 포스팅에서는 스트림 API를 사용하는 여러가지 예제에 대해서 알아봅니다.


  
자바 스트림 정리 - 4. 스트림 예제 (링크)

</description>
        <pubDate>Wed, 06 Feb 2019 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/java-streams-terminal-operations</link>
        <guid isPermaLink="true">https://madplay.github.io/post/java-streams-terminal-operations</guid>
        
        <category>java</category>
        
        <category>stream</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>자바 스트림 정리 - 2. 중간 연산</title>
        <description>


  목차



  자바 스트림 정리 - 1. 소개와 스트림 생성 (링크)
  자바 스트림 정리 - 2. 중간 연산
  자바 스트림 정리 - 3. 결과 구하기 (링크)
  자바 스트림 정리 - 4. 예제 (링크)
  자바 스트림 정리 - 5. 주의할 점 (링크)





  중간 연산


이제 생성된 스트림을 필터링하거나 원하는 형태에 알맞게 가공하는 연산에 대해서 알아볼 차례입니다.
중간 연산의 특징은 반환 값으로 다른 스트림을 반환하기 때문에 이어서 호출하는 메서드 체이닝이 가능합니다.
그리고 모든 중간 연산을 합친 다음에 합쳐진 연산을 마지막으로 한 번에 처리합니다. 예제 코드로 살펴봅시다.

List&amp;lt;String&amp;gt; list = List.of(&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;abcd&quot;);

List&amp;lt;String&amp;gt; result = list.stream()
        .filter(x -&amp;gt; { // 중간 연산 1
            System.out.println(x + &quot; in filter method&quot;);
            return x.length() &amp;gt;= 1;
        }).map(x -&amp;gt; { // 중간 연산 2
            System.out.println(x + &quot; in map method&quot;);
            return x.toUpperCase();
        }).limit(2) // 중간 연산 3
        .collect(Collectors.toList()); // 나중에 살펴볼 단말 연산

System.out.println(result);
// a in filter method
// a in map method
// ab in filter method
// ab in map method
// [A, AB]


위의 코드에서 filter 조건으로 설정한 문자열의 길이가 1과 같거나 큰 기준에 해당하는 문자열이 4개가 있음에도
limit 연산의 조건으로 처음 2개만 선택됩니다. 그리고 filter와 map 연산은 마치 한 과정처럼 합쳐서 진행되었고요.

이제 중간 연산(Intermediate Operations)에는 어떠한 것들이 있는지 알아봅시다.




  filter 메서드로 필터링


filter 메서드로 스트림 내 요소들을 조건에 맞게 필터링할 수 있습니다. 메서드의 인자인 Predicate&amp;lt;T&amp;gt; 인터페이스는
test 라는 추상 메서드를 정의하는데, 이는 제네릭 형식의 객체를 인수로 받아 boolean 값을 반환합니다.

List&amp;lt;String&amp;gt; list = List.of(&quot;kim&quot;, &quot;taeng&quot;);
list.stream().filter(s -&amp;gt; s.length() == 5);
// &quot;taeng&quot;

// without lambda expression
list.stream().filter(new Predicate&amp;lt;String&amp;gt;() {
    @Override
    public boolean test(String s) {
        return s.length() == 5;
    }
});





  map 메서드로 특정 형태로 변환


map 메서드를 사용하여 스트림 내 요소를 원하는 특정 형태로 변환할 수 있습니다.

List&amp;lt;String&amp;gt; list = List.of(&quot;mad&quot;, &quot;play&quot;);
list.stream().map(s -&amp;gt; s.toLowerCase());
// &quot;MAD&quot;, &quot;PLAY&quot;

// without lambda expression
list.stream().map(new Function&amp;lt;String, String&amp;gt;() {
    @Override
    public String apply(String s) {
        return s.toLowerCase();
    }
});





  기본 타입에 특화된 스트림으로 변환


박싱(Boxing) 비용을 피할 수 있도록 기본 데이터 타입에 특화된 스트림으로 변환할 수 있습니다.
mapToInt, mapToLong, mapToDouble 메서드를 사용하면 각각 IntStream, LongStream,
DoubleStream 으로 변환할 수 있습니다.

// IntStream 예
List&amp;lt;String&amp;gt; list = List.of(&quot;0&quot;, &quot;1&quot;);
IntStream intStream = list.stream()
        .mapToInt(value -&amp;gt; Integer.parseInt(value));
intStream.forEach(System.out::println);
// 숫자 0, 1 출력

// without lambda expression
list.stream().mapToInt(new ToIntFunction&amp;lt;String&amp;gt;() {
    @Override
    public int applyAsInt(String value) {
        return Integer.parseInt(value);
    }
});





  flatmap 메서드로 단일 스트림 변환


flatmap 메서드는 중첩된 구조를 한 단계 없애고 단일 원소 스트림으로 만들어줍니다.

List&amp;lt;String&amp;gt; list1 = List.of(&quot;mad&quot;, &quot;play&quot;);
List&amp;lt;String&amp;gt; list2 = List.of(&quot;kim&quot;, &quot;taeng&quot;);
List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; combinedList = List.of(list1, list2);

List&amp;lt;String&amp;gt; streamByList = combinedList.stream()
        .flatMap(list -&amp;gt; list.stream())
        .collect(Collectors.toList());

// mad, play, kim, taeng
System.out.println(streamByList);

// 2차원 배열
String[][] arrs = new String[][]{
        {&quot;mad&quot;, &quot;play&quot;}, {&quot;kim&quot;, &quot;taeng&quot;}
};

List&amp;lt;String&amp;gt; streamByArr = Arrays.stream(arrs)
        .flatMap(arr -&amp;gt; Arrays.stream(arr))
        .collect(Collectors.toList());
        
// mad, play, kim, taeng
System.out.println(streamByArr);





  distinct 메서드로 중복 제거


distinct 메서드는 스트림 내의 요소의 중복을 제거합니다. 기본형 타입의 경우 값(value)으로 비교하지만
객체의 경우 Object.equals 메서드로 비교합니다.

// 예시를 위한 클래스 정의
class Foo {
    private String bar;
    public Foo(String bar) {
        this.bar = bar;
    }
    
    public String toString() {
        return &quot;bar: &quot; + bar;
    }
}

public void someMethod() {
    IntStream stream = Arrays.stream(
            new int[]{1, 2, 2, 3, 3});

    // 1, 2, 3
    stream.distinct()
            .forEach(System.out::println);

    Foo foo1 = new Foo(&quot;123&quot;);
    Foo foo2 = new Foo(&quot;123&quot;);
    List&amp;lt;Foo&amp;gt; list = List.of(foo1, foo2, foo1);
    
    // bar: 123
    // bar: 123
    list.stream().distinct()
        .forEach(System.out::println);
}





  sorted 메서드로 정렬하기


sorted 메서드를 이용하여 스트림 내 요소를 정렬할 수 있습니다.

// 1, 2, 3
List.of(1, 2, 3).stream()
    .sorted();

// 3, 2, 1
List.of(1, 2, 3).stream()
    .sorted(Comparator.reverseOrder());


다만 IntStream, DoubleStream, LongStream과 같은 기본형 특화 스트림의 경우
sorted 메서드에 인자를 넘길 수 없습니다. 따라서 boxed 메서드를 이용해 객체 스트림으로 변환 후 사용해야 합니다.


// 2, 1, 0
IntStream.range(0, 3)
        .boxed() // boxing
        .sorted(Comparator.reverseOrder());
        





  peek 메서드로 각각의 요소에 연산 수행하기


peek 메서드는 스트림 내의 각각의 요소를 대상으로 특정 연산을 수행하게 합니다.
원본 스트림에서 요소를 소모하지 않기 때문에 중간 연산 사이의 결과를 확인할 때 유용합니다.
주의할 점은 peek 연산은 단말 연산이 수행되지 않으면 실행조차 되지 않습니다.

List&amp;lt;Integer&amp;gt; otherList = new ArrayList&amp;lt;&amp;gt;();
List.of(1, 2, 3).stream()
        .limit(2)
        .peek(i -&amp;gt; {
            // 실제로는 사용하면 안된다.
            otherList.add(i);
        })
        .forEach(System.out::println);

// 1, 2
System.out.println(otherList);

// 단말 연산인 forEach가 없으면 otherList는 비어있다.  





  limit 메서드로 개수 제한하기


limit 메서드를 사용하면 스트림 내의 요소 개수를 제한할 수 있습니다.

List&amp;lt;String&amp;gt; list = List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).stream()
        .limit(2).collect(Collectors.toList());

// a, b
System.out.println(list);





  skip 메서드로 특정 요소 생략하기


skip 메서드를 사용하면 스트림 내의 첫 번째 요소부터 인자로 전달된 개수 만큼의 요소를 제외한
나머지 요소로 구성된 새로운 스트림을 리턴합니다.

List&amp;lt;String&amp;gt; list = Arrays.stream(new String[]{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;})
        .skip(2).collect(Collectors.toList());

// c
System.out.println(list);





  boxed 메서드로 객체 스트림으로 변환하기


IntStream, LongStream, DoubleStream과 같은 기본 타입에 특화된 스트림을
일반 스트림으로 변환할 수 있습니다.

IntStream intStream = IntStream.range(0, 3);

// 객체 타입의 일반 스트림으로 변환
Stream&amp;lt;Integer&amp;gt; boxedStream = intStream.boxed();







  이어서


스트림 내 요소를 알맞게 변환하거나 특정 조건에 맞게 요소를 필터링 하는 방법에 대해서 알아보았습니다.
이어지는 포스팅에서는 가공한 스트림을 통해 결과 값을 구할 수 있는 단말 연산(Terminal Operations)에 대해서 알아봅니다.


  
자바 스트림 정리 - 3. 결과 구하기 (링크)

</description>
        <pubDate>Tue, 05 Feb 2019 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/java-streams-intermediate-operations</link>
        <guid isPermaLink="true">https://madplay.github.io/post/java-streams-intermediate-operations</guid>
        
        <category>java</category>
        
        <category>stream</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>자바 스트림 정리 - 1. 소개와 스트림 생성</title>
        <description>


  목차



  자바 스트림 정리 - 1. 소개와 스트림 생성
  자바 스트림 정리 - 2. 중간 연산 (링크)
  자바 스트림 정리 - 3. 결과 구하기 (링크)
  자바 스트림 정리 - 4. 예제 (링크)
  자바 스트림 정리 - 5. 주의할 점 (링크)





  스트림이란?


스트림(Stream)은 자바 8에서 추가된 기능으로 함수형 인터페이스인 람다(lambda)를 활용할 수 있는 기술입니다. 
예전에는 배열이나 컬렉션을 반복문을 순회하면서 요소를 하나씩 꺼내 여러가지 코드를(예를 들어 if 조건문 등) 섞어서 작성했다면
스트림과 람다를 이용하여 코드의 양을 대폭 줄이고 조금 더 간결하게 코드를 작성할 수 있습니다.

또한 스트림을 이용하면 멀티 스레드 환경에 필요한 코드를 작성하지 않고도 데이터를 병렬로 처리할 수 있습니다.
그러니까 스레드를 이용하여 많은 데이터들을 빠르게 처리할 수 있지요. 기존의 반복문을 사용한다면 synchronized와 같은
병렬성을 위한 동기화 코드를 관리해야 합니다.

스트림은 크게 3가지 단계로 동작합니다.
컬렉션이나 배열 등으로부터 스트림을 생성하는 작업(Stream Source), 스트림을 필터링하거나 요소를 알맞게 변환하는 
중간 연산(Intermediate Operations), 마지막으로 최종적인 결과를 도출하는 단말 연산(Terminal Operations)으로 나뉩니다.




  컬렉션(Collection)으로 생성


기본적으로 컬렉션 구현 클래스의 stream 메서드를 이용하여 스트림을 생성할 수 있습니다.

// of 메서드는 자바 9부터 지원
List&amp;lt;String&amp;gt; list = List.of(&quot;mad&quot;, &quot;play&quot;);
Stream&amp;lt;String&amp;gt; stream = list.stream();





  배열(Array)로 생성


Arrays.stream 메서드를 사용하여 배열로 스트림을 생성할 수 있습니다.

String[] arr = new String[]{&quot;mad&quot;, &quot;play&quot;};
Stream&amp;lt;String&amp;gt; stream = Arrays.stream(arr);

// 0번 인덱스만 선택(closed range)
Stream&amp;lt;String&amp;gt; specificStream = Arrays.stream(arr, 0, 1);

// &quot;mad&quot; 출력
specificStream.forEach(System.out::println);





  병렬 스트림 생성


위의 컬렉션과 배열을 생성할 때 사용한 stream 메서드 대신에 parallelStream 메서드를 호출하면 병렬 스트림을
생성할 수 있습니다. 각각의 스레드에서 작업을 처리할 수 있도록 스트림 요소를 여러 청크(chunk)로 분할합니다.

List&amp;lt;String&amp;gt; list = List.of(&quot;mad&quot;, &quot;play&quot;, &quot;...&quot;);
Stream&amp;lt;String&amp;gt; stream = list.parallelStream();





  기본 타입에 특화된 스트림 생성


오토 박싱과 언박싱의 비효율적인 측면을 줄이기 위해 기본 타입에 특화된 스트림을 사용할 수 있습니다.
자바에서는 기본적으로 IntStream, LongStream, DoubleStream이 제공됩니다.

// 0, 1, 2
IntStream intStream = IntStream.range(0, 3);

// 0, 1, 2, 3
IntStream closedIntStream = IntStream.rangeClosed(0, 3);

// 0, 1, 2
LongStream longStream = LongStream.range(0, 3);

// 0.0, 0.3
DoubleStream doubleStream = DoubleStream.of(0, 3);


난수와 같이 랜덤하게 스트림을 생성할 수 있습니다. 다만 무한대로 생성되므로 limit와 같은 제한 메서드를 사용하여
무한 스트림이 생성되지 않도록 해야 합니다.

// 난수로 스트림 생성, 3개 제한
IntStream intStream = new Random().ints().limit(3);

// 난수로 스트림 생성, 3개 제한
DoubleStream doubles = new Random().doubles(3);





  파일(Files)로 생성


java.nio.Files 클래스를 이용하여 스트림을 생성할 수 있습니다. list 메서드은 path 스트림을,
lines 메서드는 파일 내의 각 라인을 문자열 스트림으로 생성합니다.

Path path = Paths.get(&quot;~&quot;);
Stream&amp;lt;Path&amp;gt; list = Files.list(path);

Path filePath = Paths.get(&quot;~.txt&quot;);
Stream&amp;lt;String&amp;gt; lines = Files.lines(path);





  BufferedReader의 lines()로 생성


java.io.BufferedReader 클래스의 lines 메서드로도 문자열 스트림을 생성할 수 있습니다.

// try-catch-resources
try (BufferedReader br = new BufferedReader(new FileReader(&quot;test.txt&quot;))) {
    Stream&amp;lt;String&amp;gt; stream = br.lines();
    // do something
} catch (Exception e) {
    // exception handling
}





  Pattern으로 스트림 생성


Stream&amp;lt;String&amp;gt; stream = Pattern.compile(&quot;,&quot;)
    .splitAsStream(&quot;mad,play&quot;);
stream.forEach(System.out::println);
// mad
// play





  Stream.builder() 로 생성


Stream.builder 메서드를 이용하여 스트림을 생성할 수 있습니다. 메서드 체이닝의 마지막으로 build 메서드를
호출하면 스트림을 얻을 수 있습니다.

// 참고) Stream.builder 메서드 명세
// public static&amp;lt;T&amp;gt; Builder&amp;lt;T&amp;gt; builder() {
//     return new Streams.StreamBuilderImpl&amp;lt;&amp;gt;();
// }

Stream&amp;lt;String&amp;gt; stream = Stream.&amp;lt;String&amp;gt;builder()
    .add(&quot;mad&quot;).add(&quot;play&quot;).build();





  Stream.iterate() 로 생성


iterate 메서드를 이용하면 초기값과 람다를 인수로 받아 스트림을 생성할 수 있습니다.
요청할 때마다 값을 생산할 수 있으며 무한 스트림을 만들기 때문에 limit 메서드로 크기를 제한해야 합니다.

// 0, 1, 2
Stream&amp;lt;Integer&amp;gt; stream = Stream.iterate(0, x -&amp;gt; x + 1).limit(3);





  Stream.generate() 로 생성


generate 메서드는 위에서 살펴본 iterate 메서드와 다르게 생산된 각 값을 연속적으로 생산하지 않으며
인자가 없고 리턴값만 있는 Supplier&amp;lt;T&amp;gt;를 인수로 받습니다. 역시나 무한 스트림을 만들기 때문에 크기 제한이 필요합니다.

// 1, 1, 1
Stream&amp;lt;Integer&amp;gt; stream = Stream.generate(() -&amp;gt; 1).limit(3);

// 난수 3개 저장
Stream&amp;lt;Double&amp;gt; randomStream = Stream.generate(Math::random).limit(3);





  Stream.concat() 으로 스트림을 연결하여 생성


Stream.concat 메서드를 사용하면 두 개의 스트림을 연결하여 새로운 스트림을 생성할 수 있습니다.

List&amp;lt;String&amp;gt; list1 = List.of(&quot;mad&quot;, &quot;play&quot;);
List&amp;lt;String&amp;gt; list2 = List.of(&quot;mad&quot;, &quot;life&quot;);
Stream&amp;lt;String&amp;gt; stream = Stream.concat(list1.stream(), list2.stream());
// mad, play, mad, life





  비어있는 스트림 생성


Stream.empty() 메서드로 비어있는 스트림을 생성할 수 있습니다. 요소가 존재하지 않을 때 null과 같이
유효성 검사에서 사용할 수 있습니다.

// 빈 스트림 생성
Stream&amp;lt;Object&amp;gt; empty = Stream.empty();





  이어서


여러 가지 방법으로 스트림을 생성하는 방법에 대해 알아보았습니다.
이어지는 포스팅에서는 만들어진 스트림을 알맞은 형태로 가공하거나 필요한 값들만 필터링할 수 있는
중간 연산(Intermediate Operations)에 대해서 알아봅니다.


  
자바 스트림 정리 - 2. 중간 연산 (링크)

</description>
        <pubDate>Mon, 04 Feb 2019 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/introduction-to-java-streams</link>
        <guid isPermaLink="true">https://madplay.github.io/post/introduction-to-java-streams</guid>
        
        <category>java</category>
        
        <category>stream</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>이펙티브 자바 17: 변경 가능성을 최소화하라</title>
        <description>


  불변 클래스


불변이라는 개념을 클래스에 적용하려면 그 클래스 정보로 생성된 인스턴스의 내부 값들은 생성된 후에는
수정할 수 없어야 합니다. 그러니까 불변 인스턴스의 정보는 객체가 소멸되기 전까지 달라져서는 안됩니다.

클래스로 불변으로 설계하는 데는 여러 가지 장점이 따릅니다. 오류가 생길 가능성도 적고 훨씬 안전합니다.




  불변 클래스를 만드는 규칙



  객체의 상태를 변경하는 메서드를 제공하지 않는다.
    
      예를 들면 수정자(setter) 메서드처럼 멤버의 필드도 수정해서는 안됩니다.
    
  
  클래스를 확장할 수 없도록 한다.
    
      하위 클래스에서의 의도치 않은 객체의 상태를 변경을 막아야 합니다.
    
  
  모든 필드를 final로 선언한다.
    
      코드 작성자의 의도를 명확하게 드러낼 수 있는 방법
      멀티 스레드 환경에서도 문제없이 동작하게 보장하는 데도 필요합니다.
    
  
  모든 필드를 private으로 선언한다.
    
      클라이언트에서 직접 멤버에 접근하여 수정하는 일을 막아줍니다.
    
  
  자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
    
      클래스에서 가변 객체를 참조하는 필드가 하나라도 있으면 클라이언트에서 그 객체의 참조를 얻지 못하도록 해야 합니다.
      접근자 메서드가 그 필드를 그대로 반환해서도 안됩니다.
      이펙티브 자바 50: 적시에 방어적 복사본을 만들라(링크)
    
  





  불변 클래스의 장점과 단점


아래와 같은 불변 클래스가 있다고 가정해봅시다. 상속을 막기 위하여 final class로 선언하였고
모든 멤버 필드에도 final을 적용하였습니다.

/**
 * @author madplay
 */
public final class Complex {

    private final double realNumber; // 실수부
    private final double imaginaryNumber; // 허수부

    public Complex(double realNumber, double imaginaryNumber) {
        this.realNumber = realNumber;
        this.imaginaryNumber = imaginaryNumber;
    }

    /**
     * 덧셈 연산
     */
    public Complex plus(Complex c) {
        return new Complex(realNumber + c.realNumber, imaginaryNumber + c.imaginaryNumber);
    }
}


불변한 객체는 단순합니다. 생성된 시점부터 소멸되는 시점까지 상태가 동일합니다. 근본적으로 스레드 안전하므로
별도로 동기화 작업을 할 필요도 없습니다. 또한 자유롭게 불변 객체를 공유할 수 있으며 불변 객체끼리는 내부 데이터를 공유할 수 있습니다.

예로 BigInteger 클래스를 살펴보면 부호(sign)와 크기(magnitude)를 각각의 필드로 표현합니다. 크기는 같고
부호만 반대로 표현하는 negate 메서드를 보면 새로운 BigInteger를 생성하는데, 아래와 같이 가변인 배열을 복사하지 않고
원본 인스턴스와 공유하여 사용합니다.

// 코드 일부
public class BigInteger extends Number implements Comparable&amp;lt;BigInteger&amp;gt; {
    final int signum;
    final int[] mag;
    
    // ...코드 생략 
    
    public BigInteger negate() {
        return new BigInteger(this.mag, -this.signum);
    }
}


그리고 불변 객체는 그 자체만으로 실패 원자을 제공합니다. 그러니까 예외가 발생한 이후에도 그 객체는 여전히 동일한 상태를 보장합니다.

하지만 단점도 있습니다. 값이 다르면 반드시 독립된 객체로 만들어야 합니다. 이를 해결하기 위해서 가변동반 클래스를 제공합니다.
예를들어 불변인 String 클래스의 가변 동반 클래스로 StringBuilder 가 있습니다.

그리고 참고 서적에는 없는 내용입니다만 Jackson과 같은 라이브러리를 사용하기 위해서는 기본 생성자가 필요합니다.
아래의 코드는 실행 중에 예외가 발생합니다.

import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.IOException;

class TestObj {
    private final String hello;

    public TestObj(String hello) {
        this.hello = hello;
    }

    public String getHello() {
        return hello;
    }
}

public class TestClass {
    public void someMethod() throws IOException {
        String s = &quot;{\&quot;hello\&quot;:\&quot;hi\&quot;}&quot;;

        // jackson.databind.exc.MismatchedInputException:
        // Cannot construct instance of `TestObj` (although at least one Creator exists):
        // cannot deserialize from Object value ... 생략
        TestObj complex = new ObjectMapper().readValue(s, TestObj.class);
        System.out.println(complex.getHello());
    }

    // main 메서드 생략
}





  불변 클래스를 만드는 또 다른 방법


생성자 대신에 정적 팩터리를 이용하여 불변 클래스를 만들 수 있습니다.

/**
 * @author Kimtaeng
 */
public class Complex {
    // 클래스에 final이 없다.

    private final double realNumber; // 실수부
    private final double imaginaryNumber; // 허수부

    // 생성자가 private
    private Complex(double realNumber, double imaginaryNumber) {
        this.realNumber = realNumber;
        this.imaginaryNumber = imaginaryNumber;
    }

    public static Complex valueOf(double re, double im) {
        return new Complex(re, im);
    }

    // ...생략
}


생성자가 private이므로 클라이언트에서 바라본 이 불변 객체는 사실상 final 입니다.
다른 패키지에서는 이 클래스를 확장하는 것조차 불가능합니다. 이러한 정적 팩터리 방식은 다수의 구현 클래스를 활용한
유연성을 제공하고 객체 캐싱과 같은 기능을 추가하여 성능을 끌어올릴 수도 있습니다.




  정리해보면


접근자 메서드(getter)가 있다고 무조건 수정자 메서드(setter)를 만들어야 하는 것은 아닙니다. 꼭 필요한 경우가 아니라면
클래스는 불변(immutable)이어야 합니다. 그로 인해 얻는 장점이 많으며 꼭 단점을 뽑자면 특정 상황에서의 잠재적 성능 저하뿐입니다.

불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이는 것이 좋습니다. 객체가 가질 수 있는 상태의 개수가
줄어드는 것은 그 객체를 예측하기가 쉬워지고 오류가 발생할 가능성도 줄어들게 됩니다. 그리고 다른 합당한 이유가 없다면
불변을 유지하기 위해서 모든 멤버 필드는 private final 이어야 합니다.

해당 내용은 Effective Java 3th Edition을 기반으로 작성되었습니다.
</description>
        <pubDate>Sat, 02 Feb 2019 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/minimize-mutability</link>
        <guid isPermaLink="true">https://madplay.github.io/post/minimize-mutability</guid>
        
        <category>java</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>이펙티브 자바 82: 스레드 안전성 수준을 문서화하라</title>
        <description>


  API 문서에 synchronized 가 보인다?


Java API 문서에 synchronized 키워드가 보이는 메서드는 스레드에 안전하다고 말할 수 있습니다.
하지만 몇 가지 측면에서는 이는 틀린 얘기일 수 있습니다. 스레드 안전성에도 어느 정도의 수준인지 나뉘므로
멀티 스레드 환경에서도 안전하게 사용하려면 지원하는 스레드 안전성 수준을 명시해야 합니다.




  스레드 안전성


스레드의 안전성 수준을 높은 순서대로 보면 아래와 같습니다.


  불변(immutable)
    
      해당 클래스의 인스턴스는 마치 상수와도 같아서 외부 동기화도 필요 없습니다.
      예를 들면 String, Long, BigInteger
    
  
  무조건적인 스레드 안전(unconditionally thread-safe)
    
      해당 클래스의 인스턴스는 수정될 수 있지만 내부에서도 충실히 동기화하여 별도의 외부 동기화없이 동시에 사용해도 안전합니다.
      예를 들면 AtomicLong, ConcurrentHashMap
    
  
  조건부 스레드 안전(conditionally thread-safe)
    
      무조건적인 스레드 안전성과 같지만 일부 메서드는 동시에 사용하려면 외부 동기화가 필요합니다.
      Collections.synchronized 래퍼 메서드가 반환한 컬렉션
    
  
  스레드 안전하지 않음(not thread-safe)
    
      해당 클래스의 인스턴스는 수정될 수 있으며 동시에 사용하려면 각각의 메서드 호출을 클라이언트가 선택한 외부 동기화 로직으로
감싸야 한다.
      예를 들면 ArrayList, HashMap
    
  
  스레드 적대적(thread-hostile)
    
      외부 동기화로 감싸더라도 멀티스레드 환경에서 안전하지 않습니다.
      이러한 클래스는 동시성을 고려하지 않고 만들다보면 우연히 만들어집니다.
    
  





  동기화에 대한 문서화


조건부 스레드 안전한 클래스는 주의하여 문서화해야 합니다. 어떠한 순서로 호출할 때 외부 동기화 로직이 필요한지
그리고 그 순서대로 호출하려면 어떤 락 혹은 락을 얻어야만 하는지 알려주어야 합니다.

예를 들면 Collections.synchronizedMap의 API의 문서에는 아래와 같이 명시되어 있습니다.

/**
 * It is imperative that the user manually synchronize on the returned
 * map when iterating over any of its collection views
 * 반환된 맵의 콜렉션 뷰를 순회할 때 반드시 그 맵으로 수동 동기화하라
 * 
 *  Map m = Collections.synchronizedMap(new HashMap());
 *      ...
 *  Set s = m.keySet();  // Needn't be in synchronized block
 *      ...
 *  synchronized (m) {  // Synchronizing on m, not s!
 *      Iterator i = s.iterator(); // Must be in synchronized block
 *      while (i.hasNext())
 *          foo(i.next());
 *  }
 */


반환 타입만으로 명확히 알 수 없는 정적 팩토리 메서드라면 위의 예시 코멘트처럼 자신이 반환하는 객체에 대한
스레드 안전성을 문서화해야 합니다.




  외부에 공개된 Lock


외부에 공개된 락(Lock)을 사용하면 유연한 코드를 만들 수 있지만 그만한 대가가 따릅니다.
클라이언트가 공개된 락을 가지고 놓지 않는 서비스 거부 공격(denial-of-service attack)을 수행할 수 있습니다.
(참고로 synchronized 메서드도 공개된 락에 속함) 그렇기 때문에 아래와 같은 비공개 락 객체를 사용해야 합니다.

// 비공개 락 객체, final 선언!
private final Object lock = new Object();

public void someMethod() {
    synchronized(lock) {
        // do something
    }
}


여기서 lock 멤버를 final로 선언한 이유는 우연히라도 락 객체가 교체되는 상황을 방지하기 위함입니다.
일반적인 락이든 java.util.concurrent.locks 패키지에서 가져온 락이든 동일합니다.
이러한 방법은 클라이언트 또는 이를 상속하는 하위 클래스에서 동기화 로직을 깨뜨리는 것을 예방할 수 있습니다.

해당 내용은 Effective Java 3th Edition을 기반으로 작성되었습니다.
</description>
        <pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/document-thread-safety</link>
        <guid isPermaLink="true">https://madplay.github.io/post/document-thread-safety</guid>
        
        <category>java</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>이펙티브 자바 74: 메서드가 던지는 모든 예외를 문서화하라</title>
        <description>


  메서드가 던지는 예외


메서드가 던지는 예외(Exception)는 그 메서드를 올바르게 사용하도록 하는 중요한 정보가 됩니다.
따라서 각 메서드가 던지는 예외는 왠만하면 문서화를 해야하며 이에 충분한 시간을 투자해야 합니다.

여기서 개발자가 만날 수 있는 오류(Error)와 예외(Exception)에 대한 구분이 필요합니다.
오류의 경우는 시스템적으로 정상적이지 않은 상황을 말합니다. 개발자가 개발하는 애플리케이션 레벨이 아닌
더 낮은(low) 시스템 레벨에서 발생하기 때문에 개발자가 미리 예측하여 처리하기가 어렵습니다.

반면에 예외(Exception)의 경우는 개발자가 구현한 로직의 코드에서 발생할 수 있습니다.
그러니까 개발자가 이를 예측하고 미리 대응할 수 있지요. 즉 개발자가 직접 처리할 수 있기때문에
예외를 구분하고 그에 따른 처리 방법을 명확히하는 것이 중요합니다.




  그러면 어떻게 문서화할까?


검사 예외(checked exception)의 경우는 항상 따로 하나씩 선언하고 각 예외가 발생하는 상황을 javadoc의
@throws 태그를 사용하여 정확하게 문서화해야 합니다.

/**
 * blah blah...
 *
 * @param fileName
 * @throws IOException
 */
public void someMethod(String fileName) {
    try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {
    } catch (IOException e) {
        // exception handling
    }
}


검사 예외의 경우도 공통적인 상위 클래스 하나로 퉁쳐서 선언하는 것은 좋지 않습니다. 예를 들어서 Exception을 던진다는
것을 말하는데 이런 경우에는 코드를 사용하는 입장에서 대처해야 하는 예외에 대한 힌트를 주지 않는 것과 같습니다.
하지만 예외적으로 main 메서드에서는 괜찮습니다. 오직 JVM(Java Virtual Machine)만이 호출할 수 있는 메서드이기 때문이지요.

비검사 예외(unchecked exception)의 경우도 문서화를 진행하면 좋습니다. 일반적으로 프로그래밍 오류를 뜻하는데 발생할 수 있는
오류를 명시하면 자연스럽게 해당 오류가 발생하지 않도록 개발할 수 있습니다.

아래 예제에서 보이는 숫자 리터럴의 언더스코어(_)에 관해서는 아래 링크를 참고하세요. 
(링크: 자바의 숫자 표현과 언더스코어)

/**
 * blah blah...
 *
 * @param divisor
 * @throws ArithmeticException
 *     Exception may occur when divisor is zero    
 */
public int someMethod(int divisor) {
    try {
        // 피제수(dividend)
        int dividend = 2_147_483_647;

        // 몫(quotient)
        int quotient = dividend / divisor;
        return quotient;

    } catch (ArithmeticException e) {
        // divisor(제수)가 0인 경우
    }
} 


하지만 참고 서적에서는 비검사 예외는 메서드의 throws 선언 에는 넣지 않는 것을 권장합니다.
javadoc 유틸리티에서는 메서드 선언의 throws 절에 등장하고 메서드 주석의 @throws 태그에도 명시된 예외와
@throws 태그에만 명시된 예외를 시각적으로 구분하기 때문입니다.

/**
 * blah blah...
 *
 * @param divisor
 * @throws ArithmeticException
 *     Exception may occur when divisor is zero    
 */
public int someMethod(int divisor) throws ArithmeticException {
    // throws 선언에는 제외하는 것을 권장한다.
}


비검사 예외가 현실적으로 모두 문서화가 안될 때도 있습니다. 클래스를 수정하면서 새로운 비검사 예외(unchecked exception)을 던져도
호환성이 유지되기 때문인데요. 예를 들어서 외부 클래스를 사용하는 메서드가 있을 때, 그 외부 클래스가 다른 예외를 던지도록 수정된다면
아무 수정도 하지 않은 기존 메서드는 javadoc 문서에 언급되지도 않은 새로운 예외를 던지게 될 것입니다.

특정 클래스에 대부분의 메서드가 같은 이유로 모두 동일한 예외를 던진다면 그 예외에 대한 설명을 클래스에 추가해도 좋습니다.
실제로 구현해보면 아래와 같은 모습과 같겠네요.

/**
 * blah... blah...
 *
 * @throws NullPointerException
 *     All methods throw an exception if the argument is null.
 */
public class TestClass {

    /**
     * @param paramObj
     */
    public void someMethod1(Object paramObj) {
        if(paramObj == null) {
            throw new NullPointerException();
        }
        // ...
    }

    /**
     * @param paramObj
     */
    public void someMethod2(Object paramObj) {
        if(paramObj == null) {
            throw new NullPointerException();
        }
        // ...
    }
}


해당 내용은 Effective Java 3th Edition을 기반으로 작성되었습니다.
</description>
        <pubDate>Fri, 25 Jan 2019 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/document-all-exceptions-thrown-by-each-method</link>
        <guid isPermaLink="true">https://madplay.github.io/post/document-all-exceptions-thrown-by-each-method</guid>
        
        <category>java</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>자바의 숫자 표현과 언더스코어(_)</title>
        <description>


  자바에서의 숫자 표현


자바 언어에서의 숫자 표현은 다른 언어들과 특별히 다른 것은 없습니다.
물론 실수형 데이터의 표현에서 명시적인 float형임을 선언하기 위해 2.4F와 같이 suffix를 추가하는 것과
정수형의 표현에서도 기본 int 타입보다 더 넓은 범위의 정수 표현을 위해 정수값 뒤에 L 이라는 접미사(suffix)를 추가하는 것을
제외하면 말이지요.

public class TestClass {
    public void someMethod() {
        // int: -2147483648 ~ 2147483647

        // compile error: integer number to large
        long value1 = 2147483648;

        // Okay!
        long value2 = 2147483648L;
    }
}


정수형 int의 기본 데이터 범위는 -2147483648 ~ 2147483647 입니다. 해당 값을 넘게되면 오버 플로우가 발생하게 되지요.
참고로 long의 경우는 -9223372036854775808 ~ 9223372036854775807 입니다.

그런데 위의 코드에서 int 형의 최댓값보다 1이 더 큰 정수를 long 타입 변수에 담았으나 컴파일 오류가 발생합니다.
변수는 long 타입이지만 변수에 대입되는 숫자 리터럴이 여전히 int 타입이기 때문이지요. 따라서 두 번째 경우처럼 suffix를 추가하여
long형 타입인 것을 명시적으로 선언해주어야 합니다.




  너무 큰 숫자가 읽기 힘들다


자바7 버전부터는 숫자를 사용할 때 _ 기호인 언더스코어(또는 언더바)를 사용할 수 있습니다.
흔히 은행에서 금액을 표기할 때 볼 수 있는 세자리 콤마와 같은 형태로 사용할 수 있지요.

public void someMethod() {
    // 훨씬 더 읽기 편한 것 같다.
    long valueWithUnderscore = 2_147_483_648L;
}


하지만 언더스코어를 아무 곳에서나 쓸 수 없습니다. 무조건 숫자 사이에만 위치할 수 있습니다.
예시로 몇가지 살펴보면 아래와 같습니다.

public void someMethod() {
    long value1 = 2_147_483_648L; // 2147483648
    System.out.println(value1);

    int value2 = 3_2; // 32
    System.out.println(value2);

    int value3 = 2____4; // 24
    System.out.println(value3);

    long value4 = 2_222_L; // Error! 숫자 사이에만 가능

    float value5 = _24F; // Error! 변수로 인식됩니다.
}


참고로 언더스코어가 가장 앞에 등장하는 경우 변수의 이름으로 인식될 수 있습니다. 그리고 앞서 소개드린 것처럼 
자바7 버전부터 사용이 가능합니다. 혼동될 수도 있겠지만 이전보다 큰 수를 읽기에는 더 편한 것 같습니다.


Oracle Java Docs: Underscores in Numeric Literals(참고링크)

</description>
        <pubDate>Wed, 23 Jan 2019 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/underscores-in-numeric-literals</link>
        <guid isPermaLink="true">https://madplay.github.io/post/underscores-in-numeric-literals</guid>
        
        <category>java</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>이펙티브 자바 66: 네이티브 메서드는 신중히 사용하라</title>
        <description>


  네이티브 메서드


네이티브 메서드(Native Method)는 C, C++와 같은 네이티브 프로그래밍 언어로 작성한 메서드를 말합니다.
그리고 자바 프로그램에서 네이티브 메서드를 호출하는 기술을 JNI(Java Native Interface)라고 합니다.

public class HelloJNITest
    static {
        // Native Library 로드(Unix는 libhello.so, Windows는 hello.dll)
        System.loadLibrary(&quot;hello&quot;);
    }
    
    // 네이티브 메서드 선언, 구현 코드는 C, C++언어 기반
    private native void sayHi();
    
    public static void main(String[] args) {
        // 인스턴스 생성, 네이티브 메서드 호출
        new HelloJNITest().sayHello();
    
    }
}





  네이티브 메서드의 사용


첫 번째로 레지스트리나 파일 락(Lock)과 같은 플랫폼에 특화된 기능을 사용할 수 있습니다.
하지만 자바 버전이 올라가면서 필요성이 줄어들고 있습니다. 특히 Java 9 에서는 Process API가 추가되어
OS 프로세스도 접근할 수 있습니다. 하지만 대체할만한 자바 라이브러리가 없다면 네이티브 라이브러리를 사용해야 합니다.

두 번째로 네이티브 코드로 작성된 기존 라이브러리를 사용할 때 사용해야 합니다.

마지막으로 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성할 수 있습니다.
하지만 대부분 성능 개선 목적으로 네이티브 메서드 사용을 권장하지는 않습니다. 예를 들어 java.math가 처음 추가된
JDK 1.1의 BigInteger 클래스는 C언어로 작성된 라이브러리에 의존했지만 JDK 1.3 버전부터 순수 자바로 구현되었고
보다 더 세심한 튜닝을 통해 원래의 네이티브 구현보다 더 빨라졌습니다.




  네이티브 메서드의 단점


안전하지 않습니다. 네이티브 메서드를 사용하는 애플리케이션도 메모리 훼손 오류로부터 안전하지 않습니다.

(참고 링크: 이펙티브 자바 50: 적시에 방어적 복사본을 만들라)

자바보다 플랫폼 종속성이 높고 이식성도 낮으며 디버깅하기도 어렵습니다. 성능적인 측면으로는 오히려 속도가 더 느릴 수 있으며
가비지 컬렉터가 네이티브 메모리는 자동 회수하지 못하며 심지어 추적할 수도 없습니다.
자바 코드와 네이티브 메서드와의 호출 사이에서 비용도 발생하며 이를 잇는 코드를 작성하는 것도 귀찮은 작업이며 가독성도 떨어집니다.

따라서 Low 레벨 자원이나 네이티브 라이브러리를 반드시 사용해야만 하는 경우가 아니라면 네이티브 코드는 권장되지 않습니다.
사용하더라도 최소한만 사용하고 테스트를 철저히 해야 합니다.

해당 내용은 Effective Java 3th Edition을 기반으로 작성되었습니다.
</description>
        <pubDate>Mon, 21 Jan 2019 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/use-native-methods-judiciously</link>
        <guid isPermaLink="true">https://madplay.github.io/post/use-native-methods-judiciously</guid>
        
        <category>java</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>static 변수에 autowired 설정하려면 어떻게 해야 할까?</title>
        <description>


  코드 예시


스프링 프레임워크에서 정적(static) 멤버에 @autowired 어노테이션으로
빈을 주입하는 방법을 알아봅시다. 먼저 아래와 같은 코드가 있다고 가정합시다.

// import 생략

@Component
class Something {
    public void sayHi() {
        System.out.println(&quot;Hi&quot;);
    }
}

class Someone {
    // 사용하고 싶다...
    @Autowired
    public static SomeObject someObject;

    public static void say() {
        someObject.sayHi();
    }
}

// 설정 생략
public class InjectionTest {

    @Test
    public void method() {
        // NullPointerException 발생
        Someone.say();
    }
}


위 코드를 실행하면 NullPointerException이 발생합니다. 이유는 Someone 클래스에서
@Autowired 되었을 것이라고 예상한 Something 객체가 Someone 클래스가 로드된 이후에 생성되기 때문에
Someone 클래스가 로드된 당시에는 Something 객체는 존재하지 않습니다.

그리고 핵심은 @Autowired는 스프링 프레임워크에 의해서 관리되어야 빈 주입을 해줄 수 있지만
현재 Someone클래스는 그렇지 않습니다. 물론 관리 대상이라고 하더라도 클래스 로더에 의해 인스턴스화될 때
스프링 라이브러리(컨텍스트)는 아직 로드되지 않아 정상적인 주입이 불가능합니다.




  해결하기


위에서 살펴본 것처럼 우선적으로 스프링 프레임워크가 관리할 수 있도록 설정해줍시다.

// ...생략

@Component
class Someone {
    // ...
}


그리고 Someone 클래스의 객체가 생성될 때 주입받을 객체를 가져와 할당합니다. 클래스 생성자(Constructor) 또는
수정자(Setter) 메서드를 이용할 수 있고 @PostConstruct 어노테이션을 사용할 수도 있습니다.

// ...생략

@Component
class Someone {
    public static SomeObject someObject;

    // 방법1) setter 메서드를 사용한다.
    @Autowired
    public void setSomeObject(SomeObject someObject) {
        this.someObject = someObject;
    }
    
    // 방법2) 생성자를 이용한다.
    @Autowired
    private Someone(SomeObject someObject) {
        this.someObject = someObject;
    }

    public static void say() {
        someObject.sayHi();
    }
}


// ...생략

@Component
class Someone {
    @Autowired
    private SomeObject beanObject;
    public static SomeObject someObject;
    
    @PostConstruct
    private void initialize() {
        this.someObject = beanObject;
    }

    public static void say() {
        someObject.sayHi();
    }
}

</description>
        <pubDate>Sat, 19 Jan 2019 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/spring-framework-static-field-injection</link>
        <guid isPermaLink="true">https://madplay.github.io/post/spring-framework-static-field-injection</guid>
        
        <category>spring</category>
        
        <category>framework</category>
        
        
        <category>Spring</category>
        
      </item>
    
      <item>
        <title>이펙티브 자바 58: 전통적인 for 문보다는 for-each 문을 사용하라</title>
        <description>


  배열과 컬렉션 순회


보통 배열과 컬렉션의 요소를 탐색할 때 아래와 같이 사용합니다.

// some list
List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

// 컬렉션을 순회하는 방법 - for loop
for (Iterator&amp;lt;String&amp;gt; iterator = list.iterator(); iterator.hasNext(); ) {
    String element = iterator.next();
    // do something
}

// 컬렉션을 순회하는 방법 - while loop
Iterator&amp;lt;String&amp;gt; iterator = list.iterator();
while (iterator.hasNext()) {
    String element = iterator.next();
    // do something
}

// 배열을 순회하는 방법
String[] arr = new String[]{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};
for (int index = 0; index &amp;lt; arr.length; index++) {
    String element = arr[index];
    // do something
}


위 코드를 보면 반복자(iterator)나 인덱스 탐색을 위한 변수들은 코드를 지저분하게 만들 수 있고
실제로 필요한 원소(element)를 얻기 위한 부수적인 코드일 뿐입니다. 혹시라도 잘못된 변수 사용으로 인해
예상치 못한 오류가 발생할 수 있습니다.




  for-each


실제로 필요한 것은 컬렉션 또는 배열의 원소(element)이므로 대부분 for-each문을 사용하면 좋습니다.
for-each 문은 향상된 for 문(enhanced for statement)이라는 정식 명칭을 가지고 있으며
반복자와 인덱스 변수를 사용하지 않아 코드가 깔끔하고 잘못된 변수 사용으로 오류가 발생할 일도 없습니다.

// 기존의 for loop
for (int index = 0; index &amp;lt; arr.length; index++) {
    String element = arr[index];
    // do something
}

// for each
for (String element : arr) {
    // do something
}


여기서 콜론(:)은 “안의(in)” 라고 읽습니다. 위 코드는 “arr 배열 안의 각 원소 element” 라고 읽으면 되겠네요.
한편 컬렉션을 중첩하여 2중으로 순회해야 한다면 for-each 문의 장점은 더 커집니다.

// 2중 for each
for (Suit suit : suits) {
    for (Rank rank : ranks) {
        deck.add(new Card(suit, rank));
    }
}





  for-each를 사용할 수 없는 상황


아쉽게도 for-each 문장을 사용할 수 없는 상황이 있습니다.

필터링: Filtering, 컬렉션을 순회하면서 선택된 엘리먼트를 제거해야 한다면 아래와 같이 반복자(iterator)를 명시적으로
사용해야만 합니다. remove 메서드를 호출해야 하기 때문인데요.

foreach 문장을 사용하여 리스트 자체를 수정하게 되는 경우에는 ConcurrentModificationException이 발생할 겁니다.
기본적으로 리스트는 순회중인 상태에서 자기 자신에 대한 삭제와 같은 변경을 할 수 없게 되어 있습니다.
따라서 Iterator를 사용해야 합니다.

// some list
List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;);

for (Iterator&amp;lt;String&amp;gt; iterator = list.iterator(); iterator.hasNext(); ) {
    String element = iterator.next();
    if(element.equals(&quot;a&quot;)) {
        iterator.remove();
    }
    // do something
}


하지만 Java 8 부터는 Collection의 removeIf 메서드를 이용하여 컬렉션을 명시적으로 순회하지 않아도 됩니다.

// Lambda
list.removeIf(s -&amp;gt; s.equals(&quot;a&quot;));

// 위 코드를 풀어서 표현하면,
list.removeIf(new Predicate&amp;lt;String&amp;gt;() {
    @Override
    public boolean test(String s) {
        return s.equals(&quot;a&quot;);
    }
});


변형: Transforming, 그리고 순회하면서 그 원소의 값 일부나 전체를 변경해야 한다면 반복자 혹은 배열의 인덱스를 사용해야 합니다.

// some array
String[] arr = new String[]{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};

// index를 사용할 수 밖에 없다.
for (int index = 0; index &amp;lt; arr.length; index++) {
    String s = arr[index];
    if(s.equals(&quot;a&quot;)) {
        arr[index] = &quot;d&quot;;
    }
}


병렬 순회: Parallel iteration, 마지막으로 여러 개의 컬렉션을 병렬적으로 순회해야 한다면 각각의 반복자와 인덱스 변수를
사용하여 엄격하고 명시적으로 제어해야 합니다. 그렇지 않으면 아래와 같은 문제가 발생할 수 있습니다.

enum Suit {
    CLUB, DIAMOND, HEART, SPADE
}

enum Rank {
    ACE, DEUCE, THREE, FOUR, 
    // ... 생략 
    QUEEN, KING
}

List&amp;lt;Card&amp;gt; deck = new ArrayList&amp;lt;&amp;gt;();
List&amp;lt;Suit&amp;gt; suits = Arrays.asList(Suit.values());
List&amp;lt;Rank&amp;gt; ranks = Arrays.asList(Rank.values());
for (Iterator&amp;lt;Suit&amp;gt; i = suits.iterator(); i.hasNext(); ) {
    for (Iterator&amp;lt;Rank&amp;gt; j = ranks.iterator(); j.hasNext(); ) {
        // next 메서드가 숫자(suit) 하나당 불려야 하는데
        // 카드(Rank) 하나당 불리고 있다.
        deck.add(new Card(i.next(), j.next()));
    }
} 


반복자의 next 메서드가 Suit를 탐색하는 루프 1회마다 불려야 하는데, Rank를 탐색하는 루프가 수행될 때마다
불리고 있어서 결국 모든 숫자(Suit)를 탐색하게 되어 NoSuchElementException이 발생하게 됩니다.

위에서 살펴본 상황에 속하게 될 경우 일반적인 for 문을 사용해야 합니다. for-each 문은 컬렉션과 배열은 물론
Iterable 인터페이스를 구현한 객체라면 무엇이든 순회할 수 있습니다.

해당 내용은 Effective Java 3th Edition을 기반으로 작성되었습니다.
</description>
        <pubDate>Tue, 15 Jan 2019 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/prefer-foreach-loops-to-traditional-for-loops</link>
        <guid isPermaLink="true">https://madplay.github.io/post/prefer-foreach-loops-to-traditional-for-loops</guid>
        
        <category>java</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>이펙티브 자바 8: FINALIZER와 CLEANER 사용을 피하라</title>
        <description>


  객체 소멸자


자바에서는 2가지의 객체 소멸자를 제공합니다. 바로 최상위 오브젝트 클래스에 포함된 finalize 메서드와
Java 9에서 추가된 java.lang.ref 패키지에 포함된 Cleaner 클래스입니다.

두 가지 모두 JVM(Java Virtual Machine)에서 Garbage Collection이 수행될 때 실행되는 구문입니다.
그런데 finalize 메서드는 Java 9에서 Deprecated 되었는데요. 새롭게 추가된 Cleaner의 경우에도
사용을 권장하지 않습니다. 그 이유를 하나씩 살펴봅시다.

참고: Finalize 메서드(링크)




  사용을 지양해야 하는 이유


실행 시점을 보장할 수 없습니다. 자바에서 꽤 오랫동안 유지되어온 finalize 메서드와 마찬가지로
Cleaner 의 경우도 사용했을 때 언제 실행될 지 시점을 보장할 수 없습니다.

실행 조차 안될 수 있습니다. 즉시 실행이 안되는 것을 감안한다고 하더라도 프로그램이 비정상 종료된다는 등의 이유로
실행조차 안될 수 있습니다. 그렇기 때문에 특정 시점 또는 반드시 실행되어야 한다는 것을 기대하고 사용해서는 안됩니다.

역효과를 불러올 수 있습니다. Unreachable 상태의 객체를 가비지 컬렉션할 때 기본적으로 finalizer가 호출되지만
그렇다고 가비지 컬렉션이 즉시 수행되는 것은 아닙니다. finalizer queue에 삽입되어 순차적으로 수행됩니다.
그렇기 때문에 finalize 메서드 실행이 느린 경우 인스턴스의 소멸이 느려지는 것이므로 OutOfMemory와 같은 오류를
발생시킬 수 있습니다.

실행이 느립니다. AutoClosable을 구현(implements)한 객체를 만들고 try-catch-resource로 자원을 반납하는데
12ns가 소요되는 반면에 finalizer를 사용한 가비지 컬렉션의 수행 시간은 550ns가 소요됩니다.

보안에 취약합니다. 위에서 살펴본 것처럼 finalize 메서드의 실행 시간이 오래 걸리도록 만들면 전반적인 시스템 장애를
불러올 수 있습니다. 메서드를 재정의(override)하여 악의적으로 정상 실행을 방해할 수 있기 때문에 final 키워드를 붙여서
상속하지 못하도록 막아야 합니다.




  그럼 왜 사용할까?


가비지 컬렉터(Garbage Collector)가 회수하지 못하는 네이티브(native) 자원의 정리에 사용합니다. 자바 객체가 아니므로
가비지 컬렉터가 관리하는 대상이 아니기 때문입니다. finalizer를 명시적으로 호출함으로 자원을 회수할 수 있습니다.

그리고 이펙티브 자바 서적을 참고하면, finalizer는 개발자가 객체의 close를 명시적으로 호출하지 않은 경우에
사용한다고 합니다. 개인적으로 finalize를 직접 호출하는 것과 close를 안하는 것 중 굳이 고르자면 어느 것이 조금 더
나은 방법일지 궁금하기도 합니다.

finalizer 기능이 필요한 경우에는 AutoCloseable 인터페이스를 구현하여
try-catch-resource를 사용하거나 close 메서드를 구현하여 호출하도록 하면 됩니다.

해당 내용은 Effective Java 3th Edition을 기반으로 작성되었습니다.
</description>
        <pubDate>Fri, 11 Jan 2019 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/avoid-finalizers-and-cleaners</link>
        <guid isPermaLink="true">https://madplay.github.io/post/avoid-finalizers-and-cleaners</guid>
        
        <category>java</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>톰캣 멀티 인스턴스(Multiple Tomcat Instances)</title>
        <description>


  톰캣(Tomcat)


여러 개의 톰캣을 띄우기 전에 먼저 톰캣의 구조에 대해서 알아봅시다.
톰캣은 크게 엔진(Engine)과 인스턴스(Instance)로 구분하여 나눌 수 있습니다.
8.0.38 버전 기준으로 디렉터리 구조를 보면 아래와 같은데요.

$ tree -L 1
.
├── LICENSE
├── NOTICE
├── RELEASE-NOTES
├── RUNNING.txt
├── bin # 명령어 스크립트들이 있는 디렉터리
├── conf # 설정 파일 디렉터리
├── lib # 라이브러리 디렉터리
├── logs # 로그 디렉터리
├── temp # 임시 파일 디렉터리 
├── webapps # 웹 애플리케이션 deploy 디렉터리
└── work # .class로 컴파일된 디렉터리


톰캣의 엔진에 해당하는 모듈 부분은 bin, lib 이고 인스턴스에 해당하는 부분은
conf, logs, temp, work, webapps 으로 구분할 수 있습니다.

여기서 톰캣 엔진은 실제로 자바 애플리케이션을 실행하는 역할을 합니다. 그러니까 톰캣 인스턴스를
실행하는 역할을 한다는 것이지요. 자바 프로그램이 실행되는 것이므로 Java Virtual Machine이 실행될 것이고
이번에 진행할 여러 개의 톰캣을 띄운다는 것, 그러니까 멀티 인스턴스를 구성한다는 것은 여러 개의 톰캣 JVM을 구동한다는 것입니다.




  톰캣 실행과 환경변수


톰캣 인스턴스를 구동시키는 bin 디렉터리의 startup.sh 스크립트의 코드를 살펴보면 catalina.sh 스크립트를
실행하도록 구성되어 있습니다. 아래와 같이 말이지요.

$ vi startup.sh

EXECUTABLE=catalina.sh
# ... 생략
exec &quot;$PRGDIR&quot;/&quot;$EXECUTABLE&quot; start &quot;$@&quot;


catalina.sh에서는 실제 톰캣 인스턴스를 구동하는 코드를 확인할 수 있는데요. 실행 해보면 톰캣 구동에 참조하는
환경변수 내용들을 확인할 수 있습니다. (아래는 Mac OS 기준으로 수행했습니다)

$ ./catalina.sh start

Using CATALINA_BASE:   /Users/madplay/Desktop/apache-tomcat-8.0.38
Using CATALINA_HOME:   /Users/madplay/Desktop/apache-tomcat-8.0.38
Using CATALINA_TMPDIR: /Users/madplay/Desktop/apache-tomcat-8.0.38/temp
Using JRE_HOME:        /Library/Java/JavaVirtualMachines/jdk1.8.0_73.jdk/Contents/Home
Using CLASSPATH:       /Users/madplay/Desktop/apache-tomcat-8.0.38/bin/bootstrap.jar:/Users/madplay/Desktop/apache-tomcat-8.0.38/bin/tomcat-juli.jar
Tomcat started.


각각의 독립적인 톰캣 인스턴스를 띄우기 위해서는 톰캣 인스턴스의 경로를 갖는 CATALINA_BASE와 톰캣 엔진의 경로인
TOMCAT_HOME의 값을 설정해주어야 합니다.




  톰캣 여러개 띄우기


먼저 톰캣을 다운로드받아 압축 해제합니다. 다운받은 1개의 톰캣 디렉터리를 복사하여 총 3개를 준비하면 됩니다.
앞서 설명한 것처럼 엔진 역할을 담당하는 부분은 lib와 bin 이므로 모든 톰캣 디렉터리에 있을 필요가 없습니다.
더불어 각각의 톰캣 인스턴스 디렉터리에는 인스턴스를 구성하기 위한 디렉터리만 있으면 되고요.

전체 디렉터리 구조를 살펴보면 아래와 같습니다.

$ tree -L 2
.
├── tomcat1
│   ├── conf
│   ├── logs
│   ├── temp
│   ├── webapps
│   └── work
├── tomcat2
│   ├── conf
│   ├── logs
│   ├── temp
│   ├── webapps
│   └── work
└── tomcat_main
    ├── bin
    └── lib


각각의 톰캣 인스턴스가 다른 포트를 사용하여 구동되어야 하기때문에 server.xml의 정보가 수정되어야 합니다.

&amp;lt;!-- conf 디렉터리 내의 server.xml --&amp;gt;
&amp;lt;Server port=&quot;8006&quot; shutdown=&quot;SHUTDOWN&quot;&amp;gt;
    &amp;lt;!-- 다른 부분은 생략하며 해당 포트로의 HTTP 연결만을 가정 --&amp;gt;
    &amp;lt;Connector port=&quot;18081&quot; protocol=&quot;HTTP/1.1&quot;
            connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&amp;gt;
&amp;lt;/Server&amp;gt;


위의 포트 부분을 tomcat1과 tomcat2를 다르게 설정해주면 됩니다. ROOT 요소가 되는 &amp;lt;Server&amp;gt;의 shutdown 포트번호도
서로 다르게 지정해야 합니다.

이제 톰캣 인스턴스를 구동시킬 스크립트를 작성하면 됩니다. 이름은 임의로 startup.sh로 지정하며
tomcat1, 2의 디렉터리에 각각 작성하면 됩니다.

#!/bin/sh

# tomcat instance 경로 - 각 인스턴스에 맞게 경로 수정
export CATALINA_BASE=/Users/madplay/Desktop/multitomcat/tomcat1

# tomcat engine 경로
export TOMCAT_HOME=/Users/madplay/Desktop/multitomcat/tomcat_main 

# 각 톰캣 인스턴스마다 사용하는 jdk가 다를 경우
#export JAVA_HOME=${자바 경로}

cd $TOMCAT_HOME/bin
./startup.sh


인스턴스를 종료하는 스크립트의 경우 먼저 작성한 startup.sh 스크립트에서 가장 마지막 부분만 실행 대상 스크립트를
./shutdown.sh로 변경하면 됩니다. 각 인스턴스에 생성하는 위 스크립트의 경우 이름을 임의로 지정해도 됩니다.
다만 톰캣 엔진에서의 bin 디렉터리 내의 스크립트는 수정하지 않고 그대로 사용하면 됩니다.
</description>
        <pubDate>Thu, 10 Jan 2019 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/multiple-tomcat-instances</link>
        <guid isPermaLink="true">https://madplay.github.io/post/multiple-tomcat-instances</guid>
        
        <category>apache</category>
        
        <category>tomcat</category>
        
        
        <category>Knowledge</category>
        
      </item>
    
      <item>
        <title>이펙티브 자바 31: 한정적 와일드카드를 사용해 API 유연성을 높이라</title>
        <description>


  제네릭은 불공변



이펙티브 자바 28: 배열보다는 리스트를 사용하라(링크)에서 살펴본 것처럼 매개변수화 타입은 불공변(invariant) 입니다.
예를 들어 Type1과 Type2가 있을 때, List&amp;lt;Type1&amp;gt;은 List&amp;lt;Type2&amp;gt;의 하위 타입 또는 상위 타입이라는 관계가 성립될 수 없습니다.

List&amp;lt;Object&amp;gt;에는 어떠한 객체도 넣을 수 있지만 List&amp;lt;String&amp;gt;에는 문자열만 넣는 것을 보면
List&amp;lt;String&amp;gt;이 List&amp;lt;Object&amp;gt;의 기능을 제대로 수행하지 못하므로 하위 타입이라고 말할 수 없습니다.

혹시나 자바의 제네릭에 대해서 전혀 모르신다면 아래 링크를 참조하여 보고 오셔도 좋을 것 같습니다.

링크: 자바 제네릭(Java Generic)




  생산자(Producer)와 와일드카드


Stack 클래스의 public API로 매개변수의 모든 원소를 넣는 메서드를 추가한다고 가정해봅시다.

// 매개변수의 원소들을 스택에 넣는 메서드를 추가한다.
public void pushAll(Iterable&amp;lt;E&amp;gt; src) {
    for (E e : src) {
        push(e);
    }
}


컴파일은 정상적으로 수행되지만 아래와 같이 Number 타입으로 선언된 Stack 객체의 메서드에
Integer 타입의 매개변수를 전달하면 컴파일 오류가 발생합니다. Integer는 Number의 하위 타입이니 정상적으로 잘 동작할 것만 같지만
incompatible types... Iterable&amp;lt;Integer&amp;gt; cannot be converted to Iterable&amp;lt;Number&amp;gt;와 같은 오류가 발생합니다.

import java.util.Arrays;

/**
 * 아이템29 소스코드 참고
 */
class Stack&amp;lt;E&amp;gt; {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(E e) {
        ensureCapacity();
        elements[size++] = e;
    }

    private void ensureCapacity() {
        if (elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }

    // ... 중간 소스코드 생략

    // 매개변수의 원소들을 스택에 넣는 메서드를 추가한다.
    public void pushAll(Iterable&amp;lt;E&amp;gt; src) {
        for (E e : src) {
            push(e);
        }
    }
}

class Item28Test {
    public static void main(String[] args) {
        Stack&amp;lt;Number&amp;gt; numberStack = new Stack&amp;lt;&amp;gt;();
        Iterable&amp;lt;Integer&amp;gt; integers = Arrays.asList(
                Integer.valueOf(1), Integer.valueOf(2));

        // incompatible types...
        numberStack.pushAll(integers);
    }
}


앞서 언급한 것처럼 제네릭의 매개변수화 타입은 불공변이기 때문에 상위-하위 자료형의 관계가 없습니다.
이러한 문제를 해결하려면 한정적 와일드카드(bounded wildcard) 자료형을 사용하면 됩니다.
Integer 클래스는 Number를 상속한 구현체 이므로 아래와 같이 매개변수 부분에 선언합니다.

// class Integer extends Number ...
public void pushAll(Iterable&amp;lt;? extends E&amp;gt; src) {
    for (E e : src) {
        push(e);
    }
}


위의 선언을 해석하면 매개변수는 E의 Iterable이 아니라 E의 하위 타입의 Iterable 이라는 뜻입니다.
Number 클래스를 상속하는 Integer, Long, Double 등의 타입 요소를 가질 수 있게 됩니다.



직접 정의한 Stack 클래스는 push(E) 메서드를 통해서만 요소를 추가할 수 있습니다.
따라서 타입 안전성은 확인되지만 elements 배열은 런타임 시에 E[]가 아닌 Object[]가 됩니다.
역시나 이부분도 런타임 시에 제네릭 타입이 소거되기 때문이지요.




  소비자(Consumer)와 와일드카드


그럼 이번에는 Stack 인스턴스의 모든 원소를 매개변수로 받은 컬렉션으로 모두 옮기는 popAll 메서드를 작성해봅시다.

import java.util.Arrays;
import java.util.Collection;
import java.util.EmptyStackException;

/**
 * Effect Java 29 소스코드 참고
 */
class Stack&amp;lt;E&amp;gt; {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(E e) {
        ensureCapacity();
        elements[size++] = e;
    }

    private void ensureCapacity() {
        if (elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public E pop() {
        if (size == 0)
            throw new EmptyStackException();

        // push에서 E 타입만 허용하므로 이 형변환은 안전하다.
        @SuppressWarnings(&quot;unchecked&quot;) E result =
                (E) elements[--size];

        elements[size] = null; // 다 쓴 참조 해제
        return result;
    }


    // 매개변수의 원소들을 스택에 넣는 메서드를 추가한다.
    public void pushAll(Iterable&amp;lt;? extends E&amp;gt; src) {
        for (E e : src) {
            push(e);
        }
    }

    // 모든 원소를 매개변수로 전달받은 컬렉션에 옮긴다.
    public void popAll(Collection&amp;lt;E&amp;gt; dst) {
        while(!isEmpty()) {
            dst.add(pop());
        }
    }
}

class Item28Test {
    public static void main(String[] args) {
        Stack&amp;lt;Number&amp;gt; numberStack = new Stack&amp;lt;&amp;gt;();
        Collection&amp;lt;Object&amp;gt; objects = Arrays.asList(new Object());
        
        // incompatible types...
        numberStack.popAll(objects);
    }
}


처음 pushAll 메서드를 정의했을 때와 유사한 오류가 발생합니다. Collection의 요소 타입과 Stack의 요소 타입이
일치하면 오류는 발생하지 않으나, 위에서 작성한 예제처럼 타입이 일치하지 않으면 컴파일 에러가 발생합니다.

Number 클래스는 최상위 Object 클래스를 상속하지만 역시나 제네릭의 매개변수화 타입은 불공변이기 때문에 상속이란 관계가
무의미합니다. 동일하게 와일드카드 타입을 사용하면 해결할 수 있는데, popAll 메서드의 매개변수 타입은
E의 컬렉션이 아니라 E의 상위 타입인 Collection이라고 선언합니다.

// E의 상위 타입의 Collection이어야 한다.
public void popAll(Collection&amp;lt;? super E&amp;gt; dst) {
    while(!isEmpty()) {
        dst.add(pop());
    }
}


모든 타입은 자기 자신의 상위 타입이므로 Collection&amp;lt;? super Number&amp;gt;선언은 Collection&amp;lt;Number&amp;gt;을 비롯하여
Collection&amp;lt;Object&amp;gt; 타입의 매개변수가 전달되어도 오류가 발생하지 않습니다.






  PECS


예제로 살펴본 것처럼 코드의 유연성을 높이려면 적절한 와일드카드 타입을 사용해야 합니다.
앞에서 생산자(Producer)와 와일드카드, 소비자(Consumer)와 와일드카드를 살펴본 것처럼 상황에 따라서 어떠한 와일드카드 타입을
써야하는지 기억이 나지 않는다면 PECS를 기억하면 됩니다.

Producer-Extends-Consumer-Super… 이렇게 한 글자씩 떼서 PECS

그러니까 메서드의 매개변수 타입이 생산자를 나타내면 &amp;lt;? extends T&amp;gt;를 사용하고
소비자의 역할을 한다면 &amp;lt;? super T&amp;gt;를 사용하면 됩니다.

혹시나 생산자와 소비자의 개념이 아직 명확하게 이해가 안되었다면...

글 초반에 살펴본 pushAll 메서드를 살펴보면 매개변수 src은 stack이 사용할 인스턴스를 생산하므로
생산자(Producer) 역할입니다. 따라서 메서드의 매개변수에는 extends가 선언되었고요.

// class Integer extends Number ...
public void pushAll(Iterable&amp;lt;? extends E&amp;gt; src) {
    for (E e : src) {
        push(e);
    }
}


반대로 popAll 메서드의 dst 매개변수는 stack의 원소들을 모두 소비하므로 소비자(Consumer) 입니다.
따라서 메서드의 매개변수 영역에는 super 가 선언되었고요.

// E의 상위 타입의 Collection이어야 한다.
public void popAll(Collection&amp;lt;? super E&amp;gt; dst) {
    while(!isEmpty()) {
        dst.add(pop());
    }
}





  Advanced


메서드의 리턴값에는 와일드카드 타입을 사용하면 안됩니다. 메서드를 사용하는 클라이언트 코드에서도
메서드 반환 값으로 와일드카드 자료형을 써야하기 때문입니다.

두 개의 Set 컬렉션을 매개변수로 받아서 합치는(union)하는 메서드의 경우에도 아래와 같이
Producer의 역할을 하므로 extends를 사용하여 처리합니다.
하지만 메서드를 사용하는 main 메서드를 보면 와일드카드 타입을 전혀 신경쓰지 않아도 됩니다.

public class Union {
    public static &amp;lt;E&amp;gt; Set&amp;lt;E&amp;gt; union(Set&amp;lt;? extends E&amp;gt; s1, Set&amp;lt;? extends E&amp;gt; s2) {
        Set&amp;lt;E&amp;gt; result = new HashSet&amp;lt;&amp;gt;(s1);
        result.addAll(s2);
        return result;
    }

    public static void main(String[] args) {
        // Set.of 메서드는 java 9 이상부터 지원
        Set&amp;lt;Double&amp;gt; doubleSet = Set.of(1.0, 2.1);
        Set&amp;lt;Integer&amp;gt; integerSet = Set.of(1, 2);
        Set&amp;lt;Number&amp;gt; unionSet = union(doubleSet, integerSet);
    }
}


위 코드는 Java 9 버전으로 컴파일하였으나 만일 Java 8 이전 버전을 사용한다면 컴파일러가 타입을 올바르게
추론하지 못하므로 명시적으로 타입 인수를 지정해야 정상 컴파일이 됩니다.

public class Union {
    public static &amp;lt;E&amp;gt; Set&amp;lt;E&amp;gt; union(Set&amp;lt;? extends E&amp;gt; s1, Set&amp;lt;? extends E&amp;gt; s2) {
        Set&amp;lt;E&amp;gt; result = new HashSet&amp;lt;&amp;gt;(s1);
        result.addAll(s2);
        return result;
    }

    public static void main(String[] args) {
        // java 7 버전으로 컴파일
        Set&amp;lt;Double&amp;gt; doubleSet = new HashSet&amp;lt;&amp;gt;(Arrays.asList(1.0, 2.1));
        Set&amp;lt;Integer&amp;gt; integerSet = new HashSet&amp;lt;&amp;gt;(Arrays.asList(1, 2));
        Set&amp;lt;Number&amp;gt; unionSet = Union.&amp;lt;Number&amp;gt;union(doubleSet, integerSet);
    }
}


재귀적 타입 한정(Recursive Type Bound)을 사용한 메서드를 살펴봅시다.

class RecursiveTypeBound {
    public static &amp;lt;E extends Comparable&amp;lt;E&amp;gt;&amp;gt; E max(Collection&amp;lt;E&amp;gt; collection) {
        if (collection.isEmpty()) {
            // Exception Handling
        }

        E result = null;
        for (E e : collection) {
            if (result == null || e.compareTo(result) &amp;gt; 0) {
                result = Objects.requireNonNull(e);
            }
        }
        return result;
    }
}

class Item28Test {
    public static void main(String[] args) {
        List&amp;lt;Integer&amp;gt; integerList = Arrays.asList(1, 3, 2);
        System.out.println(RecursiveTypeBound.max(integerList));
    }
}


이 메서드에도 PECS 공식에 맞추어 와일드카드를 적용해봅시다. 먼저 매개변수는 foreach 루프에서 E 인스턴스를 생산하는
Producer 이므로 매개변수 선언 부분은 Collection&amp;lt;? extends E&amp;gt;가 되어야 합니다. 한편 Comparable 은
E 인스턴스를 소비하는 소비자이므로 super가 적용됩니다. 따라서 아래와 같이 PECS 공식을 2번 적용한 형태로 변경되어야 합니다.

// 변경 전
public static &amp;lt;E extends Comparable&amp;lt;E&amp;gt;&amp;gt; E max(Collection&amp;lt;E&amp;gt; collection)

// 변경 후(PECS 공식 2번 적용)
public static &amp;lt;E extends Comparable&amp;lt;? super E&amp;gt;&amp;gt; E max(Collection&amp;lt;? extends E&amp;gt; collection)


복잡하지만 위와 같은 방식은 Comparable을 예로 들었을 때, Comparable을 직접 구현하지 않고
직접 구현한 다른 클래스를 확장한 타입을 지원할 때 필요합니다.

예를 들어서 Java 5 부터 지원한 ScheduledFuture 인터페이스의 구현 코드를 살펴보면 아래와 같습니다.
Delayed의 하위 인터페이스이며 Delayed인터페이스는 Comparable&amp;lt;Delayed&amp;gt;를 확장했습니다.
반면에 ScheduledFuture 인터페이스는 Comparable&amp;lt;ScheduledFuture&amp;gt;를 확장(extends)하지 않았습니다.

// ScheduledFuture interface
public interface ScheduledFuture&amp;lt;V&amp;gt; extends Delayed, Future&amp;lt;V&amp;gt; {
    // ... 
}

// Delayed interface
public interface Delayed extends Comparable&amp;lt;Delayed&amp;gt; {
    // ...
}

// Comrable interface
public interface Comparable&amp;lt;T&amp;gt; {
    // ...
}


PECS 공식을 적용하지 않은 max 예제 메서드에서는 아래와 같은 코드가 동작하지 않을겁니다.

class RecursiveTypeBound {
    public static &amp;lt;E extends Comparable&amp;lt;E&amp;gt;&amp;gt; E max(Collection&amp;lt;E&amp;gt; collection) {
        // ...
    }
}

class Item28Test {
    public static void main(String[] args) {
        List&amp;lt;ScheduledFuture&amp;lt;?&amp;gt;&amp;gt; scheduledFutureList = ...
        
        // incompatible types...
        RecursiveTypeBound.max(scheduledFutureList);
    }
}


끝으로 타입 매개변수와 와일드카드 사이에 공통되는 부분으로 인해 점검해볼 부분입니다.

class swapTest {
    // 방법1) 비한정적 타입 매개변수
    public static &amp;lt;E&amp;gt; void typeArgSwap(List&amp;lt;E&amp;gt; list, int i, int j) {
        list.set(i, list.set(j, list.get(i)));
    }

    // 방법2) 비한정적 와일드카드
    public static void wildcardSwap(List&amp;lt;?&amp;gt; list, int i, int j) {
        wildcardSwapHelper(list, i, j);
    }

    // 방법2-1) 와일드카드 형에는 null외에 어떤 값도 넣을 수 없다.
    // 방법1과 메서드 시그니처(이름과 파라미터)가 동일하다.
    private static &amp;lt;E&amp;gt; void wildcardSwapHelper(List&amp;lt;E&amp;gt; list, int i, int j) {
        list.set(i, list.set(j, list.get(i)));
    }
}


바깥에서 호출 가능한 public API라면 간단하게 두 번째 방식을 사용하면 타입 매개변수에 대해 신경쓰지 않아도 되므로
더 편리하지만 리스트의 타입이 와일드카드 형태인 List&amp;lt;?&amp;gt;에는 null 외에는 어떤 값도 넣을 수 없는 문제가 있습니다.


“이펙티브 자바 26: 로 타입은 쓰지 말라” 링크의 하단 부분 참고

따라서 와일드 카드 타입의 실제 타입을 알기 위하여 제네릭 메서드(위 코드에서 wildcardSwapHelper)의 도움이 필요합니다. 
이 메서드는 매개변수로 넘어오는 리스트가 List&amp;lt;E&amp;gt;에서 꺼낸 값의 타입이 항상 E 임을 알고 있으며 이는 리스트에 넣어도
타입 안전함을 알고 있습니다. 물론 와일드카드 메서드를 지원하기 위하여 추가적인 메서드가 작성되었지만 클라이언트의 입장에서는
타입 매개변수에 신경쓰지 않는 메서드를 사용할 수 있게 됩니다.

해당 내용은 Effective Java 3th Edition을 기반으로 작성되었습니다.
</description>
        <pubDate>Mon, 07 Jan 2019 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/use-bounded-wildcards-to-increase-api-flexibility</link>
        <guid isPermaLink="true">https://madplay.github.io/post/use-bounded-wildcards-to-increase-api-flexibility</guid>
        
        <category>java</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>이펙티브 자바 50: 적시에 방어적 복사본을 만들라</title>
        <description>
  자바는 안전하다?


네이티브(Native) 메서드를 사용하지 않아서 C, C++ 언어에서의 버퍼 오버런, 배열 오버런, 와일드 포인터 같은
메모리 충돌 오류에서 안전합니다. 하지만 우리가 만든 클래스를 사용하는 클라이언트는 어떻게든 불변을 깨뜨린다고
가정하고 방어적인 프로그래밍을 해야 한다.




  불변식을 지키지 못한 클래스


자바에서 제공하는 Date 클래스는 가변이기 때문에 쉽게 불변식을 깨뜨릴 수 있습니다.


참고링크: Java Date와 Time 클래스를 사용하면 안되는 이유


import java.util.Date;

class Period {
    private final Date start;
    private final Date end;

    public Period(Date start, Date end) {
        if(start.compareTo(end) &amp;gt; 0) {
            throw new IllegalArgumentException(start + &quot; after &quot; + end);
        }
        this.start = start;
        this.end = end;
    }
    public Date start() { return start; }
    public Date end() { return end; }
    // ... 생략
}

class Item50Test {
    public void someMethod() {
        Date start = new Date();
        Date end = new Date();
        Period period = new Period(start, end);

        // deprecated method
        // period의 내부를 수정했다.
        end().setMonth(3);
    }

    public static void main(String[] args) {
        Item50Test main = new Item50Test();
        main.someMethod();
    }
}   


Date 클래스의 대부분 메서드는 Deprecated 되었으므로 사용하면 안됩니다.
Java 8부터 제공되는 LocalDateTime과 같은 클래스를 사용하는 것을 권장합니다.

참고링크: Java 8 날짜와 시간 계산

외부의 공격으로부터 인스턴스의 내부를 보호하려면 생성자에서 받은 가변 매개변수를 방어적으로 복사해야 합니다.
위에서 살펴본 코드의 생성자를 아래와 같이 변경해봅시다.

// 그 외 코드는 동일합니다.
public Period(Date start, Date end) {
    this.start = new Date(start.getTime());
    this.end = new Date(end.getTime());

    // 유효성 검사 전에 복사해야 한다. 
    if(start.compareTo(end) &amp;gt; 0) {
        throw new IllegalArgumentException(start + &quot; after &quot; + end);
    }
}


매개변수의 유효성을 검사하기 전에 복사본을 만들어야 합니다. 멀티 스레드(Multi-Thread) 환경을 가정했을 때
원본 객체의 유효성을 검사한 후에 복사본을 만드는 찰나의 순간에 다른 스레드가 원본 객체를 수정할 가능성이 있기 때문입니다.
이와 같은 공격을 검사시점 / 사용시점(time-of-check / time-of-use) 공격이라 하고 줄여서 TOCTOU 공격이라고 합니다.

clone 메서드는 매개변수가 final 클래스가 아니어서 상속이 가능한 타입이라면 사용해선 안됩니다.
위의 예제를 예를 들면 생성자에서 매개변수로 넘어온 Date 객체를 clone 메서드를 통해 복사를 할 수도 있으나
Date 클래스를 상속한 클래스가 재정의하여 하위 클래스의 인스턴스를 반환할 수도 있기 때문입니다.

한편 생성자를 수정하여 매개변수에 대한 공격은 막아냈으나, 아직도 접근자(getter) 메서드가 내부의 가변 정보 Date를 반환하기 때문에
직접적인 공격이 가능합니다.

public void someMethod() {
    Date start = new Date();
    Date end = new Date();
    Period period = new Period(start, end);

    // deprecated method
    // period의 내부를 또 수정했다.
    period.end().setMonth(3);
}  


이번 공격을 막으려면 단순히 접근자(getter) 메서드가 가변 필드의 방어적 복사본으로 반환하면 됩니다.

class Period {
    private final Date start;
    private final Date end;

    public Period(Date start, Date end) {
        this.start = new Date(start.getTime());
        this.end = new Date(end.getTime());

        if(start.compareTo(end) &amp;gt; 0) {
            throw new IllegalArgumentException(start + &quot; after &quot; + end);
        }
    }
    public Date start() { 
        return new Date(start.getTime());
    }
    public Date end() { 
        return new Date(end.getTime());
    }
    // ... 생략
}


생성자에서와 다르게 접근자 메서드에서는 clone 메서드를 사용해도 됩니다. Date 객체가 반환될 것임이 확실하기 때문입니다.




  정리해보면


클래스가 클라이언트로부터 받거나 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 합니다.
하지만 항상 사용 가능한 상황이 아닐 수 있습니다. 방어적 복사는 성능 저하가 있을 수 있고 같은 패키지에 속하는 등의 이유로
클라이언트가 객체의 상태를 변경하지 않는 것이 확실하다면 방어적 복사본을 만들지 않아도 됩니다.

다른 패키지에서 사용한다고 해서 방어적 복사를 항상해야 하는 것도 아닙니다. 메서드 또는 생성자의 매개변수로 넘기는 행위
자체의 의미가 그 객체의 제어권을 넘긴다는 의미이기도 합니다. 물론 메서드를 호출한 클라이언트는 해당 객체를 더 이상 직접
수정해서는 안되겠지요. 호출하는 쪽에서 내부 요소를 수정하지 않는다는 보장이 있다면 방어적 복사를 생략할 수도 있습니다.

해당 내용은 Effective Java 3th Edition을 기반으로 작성되었습니다.
</description>
        <pubDate>Fri, 04 Jan 2019 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/make-defensive-copies-when-needed</link>
        <guid isPermaLink="true">https://madplay.github.io/post/make-defensive-copies-when-needed</guid>
        
        <category>java</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>Node.js 설치와 예제</title>
        <description>


  Node.js 설치하기


Node.js를 사용하려면 먼저 설치해야 합니다.
Mac 환경 기준으로 설치는 Node.js 공식 다운로드 페이지(링크)를 통해서
간단하게 설치할 수 있습니다.

하지만 직접 설치해서 사용해보았을 때 여러 버전을 용이하게 테스트를 하기 위해서는 Node Version Manager(nvm)를
사용하여 설치하고 관리하는 것이 더 편했던 것 같습니다.

nvm은 아래와 같이 설치하면 됩니다.

$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash
# 또는 wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash


설치된 이후에는 쉘을 껐다가 다시 실행하거나 아래와 같이 source 명령어를 통해 적용합니다.
# 터미널을 다시 실행하거나 아래 명령어 입력
$ source ~/.bash_profile


정상적으로 설치가 되었는지 nvm --version 명령어를 입력해봅시다.
# nvm 버전 출력
$ nvm --version
0.34.0


혹시나 nvm: command not found 과 같이 명령어를 찾을 수 없다면 ~/.bash_profile 파일을 열어봅시다.
그리고 아래와 같은 내용이 있는지 확인합니다.

$ sudo vi ~/.bash_profile


# ...생략
export NVM_DIR=&quot;${XDG_CONFIG_HOME/:-$HOME/.}nvm&quot;
[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;amp;&amp;amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm


위 내용이 없다면 추가하면 됩니다. 그런데 이글을 작성하려고 기존 제 노트북이 기존에 설치된 nvm과 nodejs를 삭제하고 설치해보니
macOS mojave 버전 기준으로 .bashrc에 환경변수가 적용되더군요.

잠깐 다른 얘기를 해보면 .bashrc는 이미 로그인이 된 상태에서 새롭게 터미널이 실행될 때마다 로드되고
.bash_profile의 경우는 시스템에 로그인될 때 로드됩니다. 그리고 사용자의 개별 설정 코드들이 들어갑니다.
따라서 위에 환경 변수 관련 내용들은 이미 설치된 자바와 파이썬 관련 설정들과 함께 관리하기 위해서 bash_profile로 옮겼습니다.

그럼 이제 앞서 설치한 nvm을 이용해서 Node.js를 설치하면 됩니다.
공식 다운로드 사이트를 보아도 알 수 있지만 제공되는 버전은 LTS(Long Term Supported)와 Stable(또는 Current)로 구분됩니다.



LTS(Long Term Supported) 버전은 짝수 번호대의 버전으로 장기적으로 안정적이고 신뢰도 높은 지원이 보장되는 버전이라고 보면 됩니다.
Stable(또는 Current) 버전의 경우는 홀수 번호대로 구성됩니다. 최신 기능을 제공하며 기존 기능의 개선에 초점이 맞춘 버전으로
업데이트와 기능 변경이 자주 발생할 수 있습니다. 따라서 실무에서 서버 운영을 위해서는 LTS 버전을 설치하고 간단한 개발 또는 
자체 테스트에는 Stable 버전을 설치하는 것이 적절할 것 같습니다.

# 설치할 수 있는 버전 목록 보기(엄청 많습니다)
$ nvm ls-remote

# 특정 버전 설치하기
nvm install v10.15.0





  Node.js 예제 작성하기


노드 설치도 끝났으므로 이제 간단한 예제를 진행해봅시다. 혹시나 여러 버전의 노드를 설치했다면
아래와 같은 명령어로 자신이 사용할 버전을 선택할 수 있습니다.

# nvm use 버전명
$ nvm use v11.8.0

# node.js 버전 확인하기
$ node -v
v11.8.0


언어를 배울 때의 가장 첫 단계라고 할 수 있는 Hello World 를 웹 서버를 통해 출력해봅시다.
텍스트 편집기 또는 터미널을 열어서 helloworld.js 파일을 생성하고 아래와 같이 입력합니다.

var http = require('http');

http.createServer(function (request, response) {
    response.writeHead(200, {'Content-Type': 'text/plain'});
    response.end('Hello World\n');
}).listen(8000);

console.log('Server running at http://localhost:8000/');


실행은 간단히 node helloworld.js 로 진행하면 됩니다.
$ node test.js 
Server running at http://localhost:8000/


위 예제의 결과는 인터넷 브라우저를 주소창에 http://localhost:8000를 입력하여 “Hello World” 가 출력되는 것으로
확인할 수 있습니다. 서버를 종료하려면 Ctrl + C 를 입력하면 됩니다.

간단히 예제 코드에 대해서 살펴보면 우선 nodejs에서 기본적으로 모듈을 로드하여 사용할 때는 require() 라는 함수를 이용합니다.
코드의 첫 번째 줄에서 http 모듈을 불러오고 createServer 함수를 이용해 서버 인스턴스를 생성했습니다.

그리고 서버 인스턴스의 listen 함수를 통해 서버 시작과 사용자의 8000포트로의 요청을 받도록 기다리고
사용자의 요청이 오면 response 객체로 요청에 대한 응답을 하게 됩니다.

간단한 코드이지만 동작 원리에 대한 더 자세한 설명은 이어지는 글에서 다룰 예정입니다.
</description>
        <pubDate>Wed, 02 Jan 2019 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/nodejs-install-osx</link>
        <guid isPermaLink="true">https://madplay.github.io/post/nodejs-install-osx</guid>
        
        <category>nodejs</category>
        
        
        <category>Nodejs</category>
        
      </item>
    
      <item>
        <title>처음 접하는 Node.js</title>
        <description>


  Node.js?


Node.js는 2009년 라이언 달(Ryan Dahl)이 처음 발표한 구글의 V8 Javascript 엔진을 기반으로 만들어진 서버 플랫폼입니다. 
라이언 달이 플리커(Flickr)라는 온라인 사진 공유 커뮤니티를 사용하면서 파일이 어느만큼 업로드되었는지 알기 위해서
서버에 쿼리를 전송해야 한다는 점에서 조금 더 쉬운 방법을 찾다가 고안했다고 합니다.

Java 언어가 주를 이룬 서버 개발 환경을 탈피하여 자바스크립트(Javascript)로 서버 개발을 할 수 있기 때문에
프론트 개발자들도 서버 영역에 조금 더 쉽게 접근할 수 있게 되었습니다.

그렇지만 개인적 의견으로는 무작정 쉽지는 않은 것 같습니다. 물론 개발자의 능숙도에 따라서 얘기가 달라질 수 있겠습니다만
직접 노드로 간단하게 서버 개발을 해보았을 때 nodejs의 특징들을 잘 이해하지 못하여 적지않은 어려움을 겪었던 것 같습니다.




  Node.js의 특징과 강점


우선 Node.js는 Javascript 기반 입니다. 따라서 프론트엔드와 백엔드 개발을 같은 언어로 개발할 수 있습니다.
덕분에 프론트엔드 개발자의 입장에서는 Javascript를 사용하여 더 낮은 진입 장벽을 바탕으로 서버 개발 기술을 더 빠르게 활용할 수 있습니다.

싱글 스레드(Single Thread) 기반 비동기 I/O 처리를 진행합니다.
하나의 스레드가 요청을 받으면 처리를 하고 파일, DB 접근 또는 네트워크 처리가 필요한 경우에는 
I/O 요청을 보내놓고 자신의 작업을 진행합니다. 그리고 이후에 보냈던 요청이 완료되면 이벤트를 받아서 처리하는 이벤트 기반 방식을 사용합니다.

그런데 이벤트 기반(Event Driven), 비동기(Asynchronous)란 말은 무엇일까?

쉽게 이해하기 위해서 은행에 갔다고 가정해봅시다. 우리는 은행에서 수도 요금도 내야하고 적금 금액도 내고
자산 투자를 위해 펀드 가입을 해야 하는 일이 생겼습니다. (물론 요즘은 직접 은행에 가지 않고 핸드폰으로 가능하지만…)

시간적인 여유가 있다면 단순하게 수도 요금 정산, 적금 입금, 펀드 관련 창구를 순차적으로 방문해도 됩니다.
창구에 이미 고객이 있다면 그 사람이 일을 끝낼 때까지 기다려야 합니다. (기존의 서버 동작 방식)

하지만 조금 더 기다리지 않고 더 빠르게 할 수도 있습니다. 각 창구의 대기 순서표를 뽑아서 기다리다가
내 차례가 오면 대기 순서표를 가지고 은행 업무를 보면 됩니다. 수도 요금 정산을 하다가 적금 창구에서
호출이 오면 그 창구로 옮겨 다니면서 또 업무를 보면 됩니다. (Node.js의 처리 방식)

다른 예시로 월급날 자동이체를 생각할 수도 있겠습니다. 월급날이 되어서 통장에 월급이 입금되면(이벤트 발생) 수도 요금 정산,
적금 계좌 입금 등을 내도록 수행(작업 수행, 콜백 함수 실행)하는 것입니다.

사실 기존의 서버 방식에서는 나 자신을 여러 개로 복제(스레드 생성)하여 처리하지만 해야하는 일이 많아질수록
더 많은 스레드가 생성되는 부분이 있습니다.




  구조와 특징


nodejs의 내부 구조(Architecture)를 살펴보면 아래 그림과 같습니다. 상위 레벨은 자바스크립트로 되어있고 하위 레벨은 C, C++로 되어있습니다.
관련된 사이트들을 찾다가보니 libev 가 보이는데 v0.9.0 버전에서 종속성이 제거되었다고 합니다. 
(관련링크: Stack overflow)



nodejs는 V8 Engine 위에서 동작합니다. 이 자바스크립트 엔진은 구글이 개발한 Chrome 브라우저에서 사용하기 위해 만들었는데요.
자바스크립트를 빠른 속도로 해석하여 인식할 수 있는 코드로 변환합니다. 따라서 Node.js는 Chrome에 적용되는 최신 트렌드와
성능 향상을 빠르게 적용할 수 있습니다. 구글이 문을 닫지 않는 한 V8 Engine은 꾸준히 개발되고 업그레이드 되겠지요.
추가적으로 V8 Engine의 경우 오픈 소스(링크: V8 Engine Github)로 공개되어 있습니다.

그리고 JSON 포맷에 안성맞춤 입니다. 자바스크립트 언어가 자체적으로 JSON을 지원하기 때문에 JSON 형태의 포맷을 처리할 때 배우 편리합니다.
특히나 데이터 저장소가 MongoDB라면 더 말할 것도 없을 것 같습니다. ORM(Object-Relational Mapping)이나 객체와 JSON 사이의 변환 없이도
간편하게 처리할 수 있습니다.

앞서 싱글스레드 기반 비동기 I/O 라고 얘기했지만 nodejs라고 무조건 싱글 스레드만 사용하는 것은 아닙니다.
싱글스레드 기반의 이벤트 루프(Event Loop)가 요청을 처리하는데, 일부 I/O 요청에 대해서는 스레드 풀의 여러 워커(Worker)들은
멀티 스레드(Multi Thread) 방식으로 동작합니다. 그래야 이벤트 루프 스레드가 블록킹되지 않기 때문이지요.




  마치며


자바만 사용해본 입장에서 Node.js을 짧고 간단하게 살펴보았습니다.
짧게 경험해보았지만 노드로 서버를 구성하는데 걱정했던 만큼 오래 걸리지 않았던 것 같습니다.
특히나 사용하는 데이터의 포맷이 JSON과 같은 형태였을 때 자바보다 더 짧고 간결한 로직을 작성할 수 있다는 점이 매력적이었습니다.

이어지는 글에서 Node.js를 직접 설치해보고 언어를 배울 때의 가장 기본이라고 할 수 있는 Hello World를 출력해보겠습니다.

링크: Mac OSX에 Nodejs 설치하고 예제 따라해보기(클릭!)

이 포스트는 아래의 링크들을 참고하여 직접 작성하였습니다.


  What exactly is Node.js?
  Which is correct Node.js architecture?
  Understanding Node.js Event-Driven Architecture

</description>
        <pubDate>Sun, 30 Dec 2018 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/introduction-to-nodejs</link>
        <guid isPermaLink="true">https://madplay.github.io/post/introduction-to-nodejs</guid>
        
        <category>nodejs</category>
        
        
        <category>Nodejs</category>
        
      </item>
    
      <item>
        <title>자바 직렬화와 SerialVersionUID</title>
        <description>


  자바 직렬화란 무엇일까?


지난 포스팅에서는 자바 직렬화란 무엇인지, 직렬화를 하는 방법과 반대로 역직렬화 하는 방법에 대해서 알아보았습니다.

  링크: 자바 직렬화(Java Serialize)


이번 포스팅에서는 SerialVersionUID와 같은 직렬화에 대한 조금 상세한 내용에 대해서 알아봅시다.




  SerialVersionUID


직렬화와 역직렬화를 얘기할 때 빼놓을 수 없는 것이 SerialVersionUID(이하 SUID) 입니다. 직렬화를 할 때 SUID 선언이 없다면
내부에서 자동으로 유니크한 번호를 생성하여 관리하게 됩니다. 이 SUID는 직렬화와 역직렬화 과정에서 값이 서로 맞는지 확인 후에
처리를 하기 때문에 이 값이 맞지 않다면 InvalidClassException 예외가 발생합니다.

자바의 직렬화 스펙을 
Oracle Docs(링크)를 통해 살펴보면 SUID 값은 필수가 아니며 선언되어 있지 않으면 클래스의 기본 해시값을 사용한다고 합니다.

따라서 직접 SUID를 명시하지 않아도 내부에서 자동으로 값이 추가되며 이 값들은 클래스의 이름, 생성자 등과 같이
클래스의 구조를 이용해서 생성합니다. 앞선 예제에서도 직렬화 가능한 클래스(Article)를 선언할 때 SUID 값을 생략했지만
내부적으로 정보가 생성되어 있음을 유추할 수 있습니다.

실제로 그러한지 예제로 확인해봅시다. 클래스의 구조 정보를 이용하여 SUID를 생성하므로 직렬화 시점의 클래스 구조와
역직렬화 시점의 클래스의 구조를 바꿔보면 확인할 수 있을 것 같습니다. 물론 오류가 발생하겠지만요.

먼저 기존과 동일한 Article 클래스를 준비하고 이 클래스의 인스턴스를 직렬화합니다.
그리고 바이트 배열로 생성된 데이터를 Base64로 인코딩한 문자열을 콘솔 출력합니다.

class Article implements Serializable {
    private String title;
    private String pressName;
    private String reporterName;

    public Article(String title, String pressName, String reporterName) {
        this.title = title;
        this.pressName = pressName;
        this.reporterName = reporterName;
    }

    @Override
    public String toString() {
        return String.format(&quot;title = %s, pressName = %s, reporterName = %s&quot;,
                title, pressName, reporterName);
    }
}

public class Main {
    public String serializeMethod() {
        Article article = new Article(&quot;직렬화는 무엇인가&quot;, &quot;김탱일보&quot;, &quot;김탱&quot;);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();

        // 아래와 같은 try 구문은 java 9 버전부터 지원합니다.
        try (bos; ObjectOutputStream oos = new ObjectOutputStream(bos)) {
            oos.writeObject(article);
        } catch (Exception e) {
            // ...Exception Handling
        }
        return Base64.getEncoder().encodeToString(baos.toByteArray());
    }

    public static void main(String[] args) {
        Main main = new Main();
        String serializedString = main.serializeMethod();
        System.out.println(serializedString);
    }
}


출력된 결과는 아래와 같이 Base64로 인코딩되어 ASCII 영역 문자로만 이루어진 문자열 데이터일 것입니다.

// 인코딩된 문자열
rO0ABXNyAAdBcnRpY2xlXrUf2Yf... 생략


그럼 이 상태에서 Article 클래스에 멤버 변수를 추가해봅시다. 추가한 후에는 위에서 얻은 직렬화 데이터를 통해서
바로 역직렬화를 진행하면 됩니다.

class Article implements Serializable {
    private String title;
    private String pressName;
    private String reporterName;
    
    // 새로운 멤버 추가
    private String phoneNumber;
    
    // ... 이하 생략
}


역직렬화를 진행하면 바로 예외가 발생함을 알 수 있습니다.

java.io.InvalidClassException: Article;
    local class incompatible: stream classdesc serialVersionUID = 6824395829496368166,
    local class serialVersionUID = 1162379196231584967


예제를 통해서 Article 클래스 에서는 SUID를 선언한 적이 없으나 오류 메시지처럼 자동으로
선언됨을 알 수 있습니다. 그리고 클래스의 구조가 변경되었을 때 오류가 발생한다는 것도 알게 되었고요.

그러면 어떻게 하지? SUID를 관리라도 해야하나?




  SUID 관리


자바에서는 SUID를 개발자가 선언하고 관리하는 방식을 권장합니다. 예제에서 사용한 Article 클래스에
SerialVersionUID 를 직접 선언해봅시다.

class Article implements Serializable {
    // 간단한 예를 들기위해 간단한 값으로 선언합니다.
    private static final long serialVersionUID = 1L;

    private String title;
    private String pressName;
    private String reporterName;

    // ... 이하 생략
} 


SUID를 추가한 후에 직렬화하여 출력된 값은 아래와 같습니다.

// 인코딩된 문자열
rO0ABXNyAAdBcnRpY2xlAAAAAAAAAAECAA... 생략


Article 클래스에 멤버를 추가한 뒤 출력된 문자열 값으로 다시 역직렬화를 해봅시다.
SUID 값이 선언되면 직렬화 클래스의 멤버가 추가되더라도 역직렬화 과정에서 오류는 발생하지 않습니다.

사실 이러한 관점에서 직렬화를 사용할 때는 자주 변경될 소지가 있는 클래스의 객체는 사용하지 않는 것이
좋다고 생각할 수 있을 것 같습니다. 프레임워크 또는 라이브러리에서 제공하는 클래스의 객체도 버전업을 통해
SerialVersionUID가 변경될 경우가 있으므로 예상하지 못한 오류가 발생할 수 있습니다.

직렬화를 사용할 때 오류가 발생하거나 주의해야 하는 경우를 정리해보면


  멤버 변수를 추가할 때
    
      SUID 값이 선언되면 멤버 변수가 추가하더라도 오류는 발생하지 않습니다.
      재구성되는 클래스에 스트림에 없는 필드가 있으면 객체의 해당 필드가 기본값(예를 들어 null)으로 초기화됩니다.
    
  
  멤버 변수가 삭제될 때
    
      멤버 변수를 추가하는 것과 동일하게 오류는 발생하지 않으나
    
  
  멤버 변수의 이름이 바뀔 때
    
      멤버 변수의 이름이 바뀌게되면 역직렬화 오류는 발생하지 않으나 값이 할당되지 않습니다.
    
  
  멤버 변수의 타입이 바뀔 때
    
      기존 멤버 변수의 타입이 변경되면 역직렬화 과정에서 ClassCastException이 발생할 수 있습니다.
      int 타입을 double 타입 등으로 바꾸는 primitive Type 간의 변경에서도 동일합니다.
    
  
  접근 지정자의 변경
    
      public, protected 등과 같은 접근 지정자의 변경은 직렬화에 영향을 주지 않습니다.
    
  
  static과 transient
    
      static 멤버를 직렬화 후 non-static 멤버로 변경하게 되는 경우 직렬화된 값은 무시됩니다.
      transient 키워드는 직렬화 대상에서 제외하는 선언이므로 역직렬화 시에 transient 선언을 제외하더라도
값은 채워지지 않습니다.
    
  





  데이터의 크기


클래스의 정보를 기반으로 수행하는 자바 직렬화는 다른 포맷에 비해 상대적으로 용량이 큰 이슈가 있습니다.
앞서 진행했던 예제에서의 객체를 직렬화한 데이터와 객체를 JSON 포맷으로 변경한 것을 비교해보면

public void compareFormatSize(String serializedString) {
    byte[] decodedData = Base64.getDecoder().decode(serializedString);
    System.out.println(&quot;decodedData size (Byte) : &quot; + decodedData.length);
    ByteArrayInputStream bis = new ByteArrayInputStream(decodedData);

    try (bis; ObjectInputStream ois = new ObjectInputStream(bis)) {
        Object object = ois.readObject();
        Article article = (Article) object;

        // jackson의 객체 -&amp;gt; 문자열 변환 메서드를 사용하려면 getter 메서드가 정의되어야 합니다.
        String jsonString = new ObjectMapper().writeValueAsString(article);
        System.out.println(&quot;print using json format : &quot;+ jsonString);
        System.out.println(&quot;json string size (Byte) : &quot; + jsonString.getBytes().length);
    } catch (Exception e) {
        // ... Exception Handling
    }
}

// 출력 결과
// decodedData size (Byte) : 146
// print using json format : {&quot;title&quot;:&quot;직렬화는 무엇인가&quot;,&quot;pressName&quot;:&quot;김탱일보&quot;,&quot;reporterName&quot;:&quot;김탱&quot;}
// json string size (Byte) : 88


간단한 클래스임에도 불구하고 JSON 데이터와 크기 차이가 꽤 발생합니다.
작은 크기의 데이터만 입력되는 서비스라면 큰 이슈가 없겠으나 트래픽에 따라 데이터가 급증하는 서비스라면
고민을 해봐야할 것 같습니다.

그럼 애초부터 JSON을 사용하면 될 것인데, 왜 자바 직렬화를 사용할까요?




  JSON vs 자바 직렬화


JSON은 사용하기 쉽고 자바 스크립트에서 거의 그대로 해석된다고 볼 수 있을 정도로 설계된 포맷입니다.

{
    title: &quot;직렬화는 무엇인가&quot;,
    pressName: &quot;김탱일보&quot;,
    reporterName: &quot;김탱&quot;
}


JSON을 비롯하여 엑셀 파일을 추출할 때 등에서 흔히 볼 수 있는 콤마로 구분되는 CSV 포맷은 사용된 시스템의 특성과
상관없이 데이터를 주고 받을 때 사용됩니다. 이러한 관점에서 보면 자바 직렬화는 “자바 시스템 간의 데이터를
주고 받기 위함이다.” 라고 생각할 수 있습니다.

앞선 예제에서도 살펴본 것처럼 데이터의 타입에 대한 고민마저 하지 않아도 직렬화가 가능하며 역직렬화를 통해서
그 객체를 바로 사용할 수 있습니다. 목적에 맞게 사용하는 것이 맞다고 볼 수도 있겠지만 정답은 없는 것 같습니다.
개인적으로는 JSON 포맷 형태의 데이터를 다루는데 편했으니까요.

물론 실무에서도 자바 직렬화된 객체를 MySQL DB에 저장해두고 꺼내쓰는 방법을 보았으나
최근에는 JSON 데이터를 더 애용하는 것 같습니다. 특히나 MySQL 5.7 버전에서는 JSON 형태의 타입을
적절하게 사용할 수 있도록 기능을 제공합니다. 몽고(Mongo DB)와 같은 저장소를 사용한다면 고민할 필요도 없겠지요.




  정리해보면


직렬화는 모든 클래스에 적용되는 것은 아닙니다. Serializable 인터페이스를 구현하는 클래스만 가능하며
클래스의 멤버 변수로 선언된 클래스의 경우도 동일합니다.

SerialVersionUID 라는 유니크한 값은 명시하지 않으면 직렬화 시에 자동 생성되지만 직접 관리하는 것을 권장합니다.
그리고 역직렬화(Deserialization) 과정에서 예외가 생길 수 있다는 점을 반드시 생각해야 합니다.

데이터의 용량 등의 이슈가 있을 수 있으므로 JSON과 같은 다른 포맷을 사용하는 방법도 있으며
자주 변경될 소지가 있는 클래스에 자바 직렬화를 사용하면 숨어있는 위험 요소가 생길 수 있습니다.
</description>
        <pubDate>Fri, 28 Dec 2018 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/java-serialization-advanced</link>
        <guid isPermaLink="true">https://madplay.github.io/post/java-serialization-advanced</guid>
        
        <category>java</category>
        
        <category>serialize</category>
        
        <category>deserialize</category>
        
        <category>suid</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>자바 직렬화(Java Serialize)</title>
        <description>


  자바 직렬화


자바 객체나 데이터를 내 자바 프로그램에서 사용하다가 나중에 다시 꺼내 쓴다거나 네트워크, 스트림 등을 통해서
다른 자바 시스템 간에 서로 데이터를 주고 받는 방법을 고민해 본 적이 있다면 자바 직렬화(Java Serialization)가
도움을 줄 수 있습니다.

자바 직렬화는 외부의 다른 자바 시스템에서도 사용할 수 있도록 자바 객체(Object) 또는 데이터를 Byte 형태로 데이터를
변환하는 기술을 말합니다. 이러한 문맥에서 직렬화(Serialization)라는 것은 여러 차원(Dimension)의 데이터를 다른 곳에
보내기 적절하도록 일차원의 흐름으로 만들어 다른 컴퓨터 환경에서도 나중에 재구성할 수 있는 포맷으로 변환하는 것을 말합니다.
이러한 직렬화라는 기본 개념에 자바(Java) 라는 구체적인 특성이 지정되는 것이지요.




  직렬화 해보기


자바 직렬화를 하는 방법은 간단합니다. 하지만 직렬화(Serialize)를 하기 위한 조건 이 있는데요.
객체를 직렬화하기 위해 직렬화가 가능한 클래스 를 먼저 만드는 것입니다. 바로 Serializable 인터페이스를 구현해서 말이지요.

/**
 * 직렬화 가능한 클래스로 만들기 위해
 * java.io.Serializable 인터페이스를 구현한다.
 */
class Article implements Serializable {
    private String title;
    private String pressName;
    private String reporterName;

    public Article(String title, String pressName, String reporterName) {
        this.title = title;
        this.pressName = pressName;
        this.reporterName = reporterName;
    }
    
    // 차후 역직렬화에서 정상적으로 멤버 필드가 복원되었는지 값 확인을 위해! 
    @Override public String toString() {
        return String.format(&quot;title = %s, pressName = %s, reporterName = %s&quot;,
                title, pressName, reporterName);
    }

    // getter 생략
} 


보통은 위 코드처럼 java.io.Serializable 인터페이스를 구현(implements)하면 직렬화가 가능한 클래스가 됩니다.
물론 구현하지 않아도 직렬화가 되는 경우가 있습니다. 예를 들어 직렬화 가능한 클래스를 상속한 클래스도 직렬화가 가능한
클래스가 됩니다.

직렬화가 가능한 클래스가 준비되었다면 객체를 직렬화 해봅시다. 객체 직렬화에는 java.io.ObjectOutputStream이 사용됩니다.

// 직렬화 클래스인 Article은 위의 코드와 동일합니다.
public class Main {
    public String serializeMethod() {
        Article article = new Article(&quot;직렬화는 무엇인가&quot;, &quot;김탱일보&quot;, &quot;김탱&quot;);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        
        // 아래와 같은 try 구문은 java 9 버전부터 지원합니다.
        try (bos; ObjectOutputStream oos = new ObjectOutputStream(bos)) {
            oos.writeObject(article);
        } catch (Exception e) {
            // ...Exception Handling
        }
        
        // 바이트 배열로 생성된 데이터를 정상 출력하기 위해 base64 인코딩 
        return Base64.getEncoder().encodeToString(bos.toByteArray());
    }

    public static void main(String[] args) {
        Main main = new Main();
        String serializedString = main.serializeMethod();
        
        // rO0ABXNyAAdBcn... 와 같은 인코딩된 문자열 출력 
        System.out.println(serializedString);
    }
}


위의 코드에서는 직렬화 가능한 클래스(Article)의 인스턴스를 생성하고 이를 OutputStream에 출력하였습니다.
그리고 결과값인 바이트 배열 데이터의 결과를 정상적으로 확인하기 위해 base64 인코딩하여 콘솔 출력을 하였고요.

main 메서드에 출력한 결과는 개발자가 알아보기 힘든 인코딩된 문자열입니다만(인코딩하지 않으면 더 힘들지만)
이 값을 이용하여 다시 역직렬화(Deserialization)하면 처음 선언한 객체를 얻을 수 있습니다.




  직렬화를 할 때


만일 객체를 직렬화할 때 특정 멤버를 제외하고 싶다면 멤버 변수에 transient 키워드를 입력하면 됩니다.
아래와 같이 특정 필드에 직렬화를 제외하도록 선언하면 역직렬화를 하더라도 해당 값은 제외됩니다.

// 기자 이름은 직렬화를 제외한다.
class Article implements Serializable {
    private String title;
    private String pressName;
    private transient String reporterName;

    // 이하 위의 예제와 동일합니다.
}


한편 직렬화가 가능한 클래스 내부에 다른 클래스의 객체를 멤버 변수로 가지고 있는 경우에는
해당 클래스도 자바 직렬화가 가능하도록 Serializable 인터페이스를 구현하고 있어야 합니다.

class Article implements Serializable {
    private String title;
    private String pressName;
    private String reporterName;

    // java.time.LocalDateTime 클래스는 Serializable을 구현하고 있다.
    private LocalDateTime articleTime;
    
    // 개발자가 직접 만든 클래스. Serializable 구현을 명시해야만 가능하다.
    private DetailInfo detailInfo;
}


위의 예제에서 java.time.LocalDateTime 클래스의 경우 클래스 선언부에 Serializable 인터페이스를
구현하고 있음을 확인할 수 있습니다. 하지만 개발자가 직접 만들었거나 자바에서 직접 제공하는 클래스의 경우
Serializable 인터페이스를 구현하고 있지 않다면 직렬화가 불가능합니다.




  역직렬화


직렬화가 가능한 클래스의 인스턴스를 직렬화하였다면 이번에는 반대로 다시 객체로 만드는
역직렬화(Deserialization)를 해봅시다. 역직렬화에는 ObjectInputStream을 사용합니다.

public class Main {
    // 직렬화 메서드(serializeMethod)는 위와 동일합니다.

    public Article deserializeMethod(String serializedString) {
        // 앞선 직렬화에서 Base64 인코딩하였으므로 다시 디코딩한다.
        byte[] decodedData = Base64.getDecoder().decode(serializedString);
        ByteArrayInputStream bis = new ByteArrayInputStream(decodedData);
        try (bis; ObjectInputStream ois = new ObjectInputStream(bis)) {
            Object object = ois.readObject();
            return (Article) object;
        } catch (Exception e) {
            // ... Exception Handling
        }
        return null;
    }

    public static void main(String[] args) {
        Main main = new Main();
        String serializedString = main.serializeMethod();
        Article article = main.deserializeMethod(serializedString);
        
        // title = 직렬화는 무엇인가, pressName = 김탱일보, reporterName = 김탱
        System.out.println(article);
    }
}


역직렬화를 할 때는 직렬화된 객체의 클래스가 반드시 클래스 패스(Class Path)에 존재해야 하며 import된 상태여야 합니다.

그리고 위의 예제에서는 직렬화된 데이터를 바로 이용하였지만  FileOutputStream 등을 사용하여
파일 출력을 한 후 그 파일을 다시 읽어 원래의 객체로 되돌릴 수도 있습니다.




  이어서


이번 포스팅에서는 자바 직렬화란 무엇인지, 직렬화하는 방법과 반대로 역직렬화하는 방법에 대해서 알아보았습니다.
이어지는 글에서 자바 직렬화를 사용할 때 빼먹을 수 없는 SerialVersionUID 과 같은 조금 더 상세한 내용에 대해서 살펴봅니다.

  링크: 자바 직렬화와 SerialVersionUID

</description>
        <pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/java-serialization</link>
        <guid isPermaLink="true">https://madplay.github.io/post/java-serialization</guid>
        
        <category>java</category>
        
        <category>serialize</category>
        
        <category>deserialize</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>이펙티브 자바 42: 익명 클래스보다는 람다를 사용하라</title>
        <description>


  함수 객체


자바에서 함수 타입을 표현할 때 추상 메서드를 하나만 담은 인터페이스(또는 추상 클래스)를 사용하곤 했습니다.
이러한 인터페이스의 인스턴스를 함수 객체(function Object)라고 하여 특정 함수나 동작을 나타내는 데 썼습니다.




  익명 클래스(Anonymous Class)


JDK 1.1 버전부터는 함수 객체를 만들 때 익명 클래스(Anonymous Class)를 주로 사용했습니다.
하지만 익명 클래스 방식은 코드가 너무 길기 때문에 자바는 함수형 프로그래밍(Functional Programming)에 적합하지 않아 보입니다.

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List&amp;lt;String&amp;gt; words = Arrays.asList(&quot;kim&quot;, &quot;taeng&quot;, &quot;mad&quot;, &quot;play&quot;);

        Collections.sort(words, new Comparator&amp;lt;String&amp;gt;() {
            public int compare(String s1, String s2) {
                return Integer.compare(s1.length(), s2.length());
            }
        });
    }
}





  람다(lambda)


JDK 1.8 버전 부터는 추상 메서드 하나 짜리 인터페이스, 즉 함수형 인터페이스를 말하는데
그 인터페이스의 인스턴스를 람다식(lambda expression, 짧게 람다)라고 사용해 만들 수 있게 되었습니다.
위의 익명 클래스로 구현한 정렬을 람다를 사용하면 아래와 같이 구현할 수 있습니다.

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List&amp;lt;String&amp;gt; words = Arrays.asList(&quot;kim&quot;, &quot;taeng&quot;, &quot;mad&quot;, &quot;play&quot;);

        Collections.sort(words,
                (s1, s2) -&amp;gt; Integer.compare(s1.length(), s2.length()));
    }
}


여기서 람다의 타입은 (Comparator&amp;lt;String&amp;gt;)이고 매개변수 (s1, s2)의 타입은 String이며
그리고 반환값의 타입은 int 입니다. 하지만 컴파일러가 코드의 문맥을 살펴 타입을 추론했기 때문에
코드 상에는 이 타입들이 명시되어 있지 않습니다. 타입을 명시해야 코드가 명확할 때를 제외하고는
람다의 모든 매개변수 타입은 생략하고 상황에 따라 컴파일러가 타입을 결정하지 못하여 오류가 발생할 때는
해당 타입을 명시하면 됩니다.

한편 컴파일러가 타입을 추론하는 데 필요한 타입 정보 대부분을 제네릭에서 얻습니다. 그래서 이 정보를
제공하지 않으면 컴파일러는 람다의 타입 추론을 할 수 없게 되어 개발자가 일일이 명시해야 합니다.

위의 코드는 아래처럼 조금 더 간략해질 수 있습니다.

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List&amp;lt;String&amp;gt; words = Arrays.asList(&quot;kim&quot;, &quot;taeng&quot;, &quot;mad&quot;, &quot;play&quot;);
        Collections.sort(words, Comparator.comparingInt(String::length));
    }
}


조금 더 나아가 JDK 1.8 버전 이상을 사용하게 되면 List 인터페이스에 추가된
sort 메서드를 사용할 수 있습니다.

import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List&amp;lt;String&amp;gt; words = Arrays.asList(&quot;kim&quot;, &quot;taeng&quot;, &quot;mad&quot;, &quot;play&quot;);
        words.sort(Comparator.comparingInt(String::length));
    }
}


그리고 
이펙티브 자바 34: INT 상수 대신 열거 타입을 사용하라(링크)
 에서 살펴본 enum을 예로 들어 조금 더 간결하고 깔끔하게 만들 수 있습니다. 우선 기존 코드를 보면 아래와 같습니다.

enum Operation {
    PLUS(&quot;+&quot;) { 
        public double apply(double x, double y) { return x + y; }
    },
    MINUS(&quot;-&quot;) {
        public double apply(double x, double y) { return x - y; }
    },
    TIMES(&quot;*&quot;) {
        public double apply(double x, double y) { return x * y; }
    },
    DIVIDE(&quot;/&quot;) {
        public double apply(double x, double y) { return x * y; }
    };
    
    private final String symbol;
   
    Operation(String symbol) { this.symbol = symbol; }
    
    @Override public String toString() { return symbol; } 
    public abstract double apply(double x, double y);
}


여기서 람다를 이용하면 열거 타입의 인스턴스 필드를 이용하는 방식으로 상수별로 다르게 동작하는 코드를
쉽게 구현이 가능합니다.

import java.util.function.DoubleBinaryOperator;

enum Operation {
    PLUS(&quot;+&quot;, (x, y) -&amp;gt; x + y),
    MINUS(&quot;-&quot;, (x, y) -&amp;gt; x - y),
    TIMES(&quot;*&quot;, (x, y) -&amp;gt; x * y),
    DIVIDE(&quot;/&quot;, (x, y) -&amp;gt; x / y);

    private final String symbol;
    private final DoubleBinaryOperator op;

    Operation(String symbol, DoubleBinaryOperator op) {
        this.symbol = symbol;
        this.op = op;
    }

    @Override
    public String toString() { return symbol; }

    public double apply(double x, double y) {
        return op.applyAsDouble(x, y);
    }
}

public class Main {
    public static void main(String[] args) {
        // 사용은 아래와 같이
        Operation.PLUS.apply(2, 3);
    }
}


DoubleBinaryOperator는 java.util.function 패키지에 있는 Double 타입 인수 2개를 받아
Double 타입 결과를 반환해주는 인터페이스입니다.




  람다의 한계


하지만 람다를 사용하기에 적절하지 못한 경우도 있습니다. 람다는 이름도 없고 메서드나 클래스와 다르게 문서화도 할 수 없습니다.
그래서 코드 자체로 동작이 명확하게 설명되지 않거나 코드 라인 수가 많아지면 사용하는 것을 고려해야 합니다.
람다가 길거나 읽기 어렵다면 오히려 쓰지 않는 방향으로 리팩토링 하는 것을 권장합니다.

그리고 추상 클래스의 인스턴스를 만들 때 람다를 사용할 수 없습니다. 이럴 때는 익명 클래스를 사용해야 합니다.

abstract class Hello {
    public void sayHello() {
        System.out.println(&quot;Hello!&quot;);
    }
}

public class Main {
    public static void main(String[] args) {
        // 이건 원래 안돼요~
        // Hello hello = new Hello();

        Hello instance1 = new Hello() {
            private String msg = &quot;Hi&quot;;
            @Override public void sayHello() {
                System.out.println(msg);
            }
        };

        Hello instance2 = new Hello() {
            private String msg = &quot;Hola&quot;;
            @Override public void sayHello() {
                System.out.println(msg);
            }
        };

        // Hi!
        instance1.sayHello();

        // Hola!
        instance2.sayHello();

        // false
        System.out.println(instance1 == instance2);
    }
}


또한 자기 자신 참조가 안됩니다. this 키워드는 바깥 인스턴스를 가리킵니다. 반면에 익명 클래스에서 this는
익명 클래스의 인스턴스 자신을 가리킵니다. 아래의 예제 코드를 보면 결과값을 알 수 있습니다.

import java.util.Arrays;
import java.util.List;


class Anonymous {
    public void say() {}
}

public class Main {
    public void someMethod() {
        List&amp;lt;Anonymous&amp;gt; list = Arrays.asList(new Anonymous());

        Anonymous anonymous = new Anonymous() {
            @Override
            public void say() {
                System.out.println(&quot;this instanceof Anonymous : &quot; + (this instanceof Anonymous));
            }
        };
        
        // this instanceof Anonymous : true
        anonymous.say();

        // this instanceof Main : true
        list.forEach(o -&amp;gt; System.out.println(&quot;this instanceof Main : &quot; + (this instanceof Main)));
    }

    public static void main(String[] args) {
        new Main().someMethod();
    }
}


람다도 익명 클래스와 동일하게 직렬화(Serialization) 형태가 구현별(가령 가상 머신 별로)로 다를 수 있으므로 주의해야 합니다.
Comparator처럼 직렬화해야만 하는 함수 객체가 있다면 private 정적 중첩 클래스의 인스턴스를 사용하면 됩니다.

참고 링크: 자바 직렬화(Serialization)

해당 내용은 Effective Java 3th Edition을 기반으로 작성되었습니다.
</description>
        <pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/prefer-lambdas-to-anonymous-classes</link>
        <guid isPermaLink="true">https://madplay.github.io/post/prefer-lambdas-to-anonymous-classes</guid>
        
        <category>java</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>자바에서 제네릭의 장점과 사용할 때 주의할 점</title>
        <description>


  제네릭은 무엇일까?


지난 포스팅에서는 자바에서 제네릭은 무엇인지, 클래스와 인터페이스 그리고 메서드에는 어떻게 제네릭을 적용하는 지에 대해서 알아보았습니다.

  링크: 자바 제네릭(Java Generic)


이번 포스팅에서는 자바에서 제네릭이 왜 좋은지, 사용할 때 주의할 점은 없는 지 살펴봅니다.




  제네릭이 왜 좋을까?


우선 컴파일 타임에 타입을 체크하기 때문에 객체 자체의 타입 안전성을 높일 수 있습니다.
개발자가 의도하지 않은 타입의 객체가 저장되는 것을 방지할 수 있고 저장한 객체를 다시 가져올 때 기존 타입과
다른 타입으로 캐스팅되어 발생하는 오류(ClassCastException)를 줄일 수 있습니다.

형 변환(Type Casting)의 번거로움을 줄일 수 있습니다. 아래의 코드를 볼까요?
제네릭없이 최상위 객체 Object를 사용한다면 아래와 같이 코드를 작성할 수 있습니다.

class MadPlay {
    private Object obj;

    public MadPlay(Object obj) { this.obj = obj; }
    public Object getObj() { return obj; }
}

class GenericTester {
    public void executeMethod() {
        MadPlay instance1 = new MadPlay(new String(&quot;Hello&quot;));
        MadPlay instance2 = new MadPlay(new Integer(123));
        MadPlay instance3 = new MadPlay(new Character('a'));

        String obj1 = (String) instance1.getObj();
        Integer obj2 = (Integer) instance2.getObj();
        Character obj3 = (Character) instance3.getObj();
    }
}


하지만 여기서 제네릭을 사용하면 타입 캐스팅을 하지 않아도 됩니다. 변환하여 사용할 객체의 타입을 사전에 명시하므로서
타입 캐스팅의 수고를 줄일 수 있습니다.

class GenericMadPlay&amp;lt;T&amp;gt; {
    private T obj;

    public GenericMadPlay(T obj) { this.obj = obj; }
    public T getObj() { return obj; }
}

class GenericTester {
    public void executeMethod() {
        GenericMadPlay&amp;lt;String&amp;gt; genericInstance1 = new GenericMadPlay&amp;lt;&amp;gt;(&quot;Hello&quot;);
        GenericMadPlay&amp;lt;Integer&amp;gt; genericInstance2 = new GenericMadPlay&amp;lt;&amp;gt;(123);
        GenericMadPlay&amp;lt;Character&amp;gt; genericInstance3 = new GenericMadPlay&amp;lt;&amp;gt;('a');

        String genericObj1 = genericInstance1.getObj();
        Integer genericObj2 = genericInstance2.getObj();
        Character genericObj3 = genericInstance3.getObj();
    }
}


타입을 지정하지 않으면 최상위 Object 객체 타입으로 정의되므로 다양한 종류의 타입을 다뤄야하는 메서드의 매개변수에
Object 타입을 사용하고(첫 번째 예제 코드에서의 생성자) 그로 인한 타입 캐스팅이 불가피했지만
두 번째 코드를 보면 알 수 있듯이 제네릭을 사용하면 원하는 타입을 사전에 지정하기만 하면 됩니다.

끝으로 이번 글에서 타입 매개변수의 이름을 T로 지정했으나, 사실 아무 이름이나 가능합니다.
MadPlay&amp;lt;Kimtaeng&amp;gt; 이런식도 가능하지요. 하지만 아래와 같이 컨벤션(Convention)이 있습니다. 다른 개발자가 보았을 때
조금 더 쉽게 이해할 수 있도록 지키는 것이 좋을 것 같습니다.


  E(Element) : 요소, 예를 들어 List&amp;lt;E&amp;gt;
  K(Key) : 키, 예를 들어 Map&amp;lt;K, V&amp;gt;
  N(Number) : 숫자
  T(Type) : 타입
  V(Value) : 리턴 값 또는 매핑된 값
  S, U, V : 2번째, 3번째 그리고 4번째에 선언된 타입





  제네릭 사용시 주의할 점은?


제네릭은 클래스와 인터페이스만 적용되기 때문에 자바 기본 타입(Primitive Type)은 사용할 수 없습니다.
(관련 링크 : 자바의 데이터 타입)

public void someMethod() {
    List&amp;lt;int&amp;gt; intList = new List&amp;lt;&amp;gt;(); // 기본 타입 int는 사용 불가
    List&amp;lt;Integer&amp;gt; integerList = new List&amp;lt;&amp;gt;(); // Okay!
}


또한 제네릭 타입을 사용하여 객체를 생성하는 것은 불가능합니다. 즉, 제네릭 타입의 객체는 생성이 불가능합니다.

public void someMethod() {
    // Type parameter 'T' cannot be instantiated directly
    T t = new T();
    return t;
}


그리고 제네릭에서는 배열에 대한 제한을 두고 있습니다. 제네릭 클래스 또는 인터페이스 타입의 배열을 선언할 수 없습니다.
하지만 제네릭 타입의 배열 선언은 허용됩니다.

public void someMethod() {
    // generic array creation
    // (자바 8이전) Cannot create a generic array of MadPlay&amp;lt;Integer&amp;gt;
    MadPlay&amp;lt;Integer&amp;gt;[] arr1 = new MadPlay&amp;lt;&amp;gt;[10];
    
    MadPlay&amp;lt;Integer&amp;gt;[] arr2 = new MadPlay[10]; // Okay!
}

</description>
        <pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/java-generic-advanced</link>
        <guid isPermaLink="true">https://madplay.github.io/post/java-generic-advanced</guid>
        
        <category>java</category>
        
        <category>generic</category>
        
        <category>generic-class</category>
        
        <category>generic-interface</category>
        
        <category>generic-method</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>이펙티브 자바 4: 인스턴스화를 막으려거든 private 생성자를 사용하라</title>
        <description>


  모든 클래스들이 인스턴스화가 필요한 것은 아니다.


정적 메서드와 필드만을 담은 클래스는 쓸모 있습니다.
java.lang.Math, java.util.Array 처럼 기본 타입 값이나 배열에 관련된 메서드들을 모을 수 있고
java.util.Collections 처럼 특정 인터페이스 구현 객체를 생성해주는 메서드를 모아놓을 수도 있습니다.

final 클래스와 관련한 메서드를 모을 때도 마찬가지입니다. 이를 상속하여 하위 클래스에 메서드를 넣는 것이
불가능하기 때문입니다. 애초에 상속이 안되기도 하지요.




  인스턴스화를 막으려면?


아래와 같은 유틸리티성 클래스가 있다고 가정해봅시다. 인스턴스화가 필요하지 않다고 판단하여 아래와 같이
생성자를 정의하지 않았습니다. 클래스 내부에는 정적 메서드만 있고 클래스의 이름도 유틸리티 기능을 강조하기 위해
Utility 라고 정의했습니다.

public class DateUtility {
    private static String FULL_DATE_FORMAT = &quot;yyyy-MM-dd HH:mm:ss.SSS&quot;;

    // 생성자 없음

    public static String convertDateToString(Date date) {
        return new SimpleDateFormat(FULL_DATE_FORMAT).format(date);
    }
}


하지만 컴파일러는 생성자를 명시하지 않는 경우에 기본 생성자를 자동으로 만듭니다. 그리고 유틸성 클래스로
이름을 지었지만 다른 누군가는 인스턴스화를 할지도 모릅니다.

public void someMethod() {
    // 이렇게 사용하길 기대했으나!
    DateUtility.convertDateToString(new Date());
    
    // 누군가는 이렇게 사용할 수도
    DateUtility dateUtility = new DateUtility();
    String formattedToday = dateUtility.convertDateToString(new Date());
}


추상 클래스로 정의하는 것으로는 인스턴스화를 막을 수 없습니다. 클래스를 상속해서 하위 클래스를
인스턴스화할 수 있기 때문입니다.

abstract class DateUtility {
    // ...생략
}

class SubDateUtility extends DateUtility {
    // ...생략
}

public class PrivateConstructorTest {
    public static void main(String[] args) {
        // abstract 클래스는 인스턴스화 불가
        // DateUtility dateUtility = new DateUtility();

        // Okay!
        SubDateUtility subDateUtility = new SubDateUtility();
    }
}


그러면 어떻게 해야할까요? 방법은 간단합니다. private 생성자를 추가하면 됩니다.

class DateUtility {
    private DateUtility() {
        /**
         * 클래스 내부에서도 호출이 안되도록 막는다.
         */
        throw new AssertionError();
    }

    // 생략
}

public class PrivateConstructorTest {
    public static void main(String[] args) {
        // DateUtility() has private access in DateUtility
        DateUtility dateUtility = new DateUtility();
    }
}


private 생성자 내부에서 Assertion Error를 던지는 이유는 행여나 클래스 내부에서 실수로라도
생성자를 호출하는 것을 막기 위함입니다. 위 코드처럼 외부에 공개된 생성자가 없는 경우 상속도 불가능합니다.

참고 서적의 내용에서 조금 더 추가하면, 인자가 다른 public 생성자가 존재하고 서브 클래스에서
이와 매핑되는 생성자를 선언한다면 기본 생성자가 private 일지라도 상속이 가능합니다.

class DateUtility {
    private DateUtility() {
        throw new AssertionError();
    }

    public DateUtility(int val) {
        //
    }
}

class SubDateUtility extends DateUtility {
    public SubDateUtility(int val) {
        // 상위 클래스와 매핑되는 생성자 필요
        super(val);
    }
}


해당 내용은 Effective Java 3th Edition을 기반으로 작성되었습니다.
</description>
        <pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/enforce-noninstantiability-with-private-constructor</link>
        <guid isPermaLink="true">https://madplay.github.io/post/enforce-noninstantiability-with-private-constructor</guid>
        
        <category>java</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>자바 제네릭(Java Generic)</title>
        <description>


  제네릭


자바의 제네릭(Generic)이란 Java 5에 추가된 스펙입니다. 다양한 타입을 다룰 수 있는 메서드 또는 컬렉션 클래스를
컴파일 타임에 타입 체크(Type Check)할 수가 있어 특정 타입에 얽매이지 않고 개발을 할 수 있도록 도움을 줍니다.
쉽게 말하면 특정 클래스 내부에서 사용할 타입을 인스턴스를 생성할 시점에 확정 짓는 것이라고 말할 수 있겠네요.

여러 방면으로 많은 도움을 주지만 개인적으로는 자바를 공부할 때 어렵다는 느낌을 주는… 그 중에서도 손에 꼽는 내용인 것 같습니다.
그래서 이번 글에서는 자바의 제네릭과 제네릭 클래스, 제네릭 메서드 등에서 사용하는 방법 그리고 장점에 대해서 정리합니다.




  제네릭 클래스


제네릭 클래스를 선언하는 방법은 기존의 클래스나 인터페이스를 선언하는 방법과 매우 유사합니다.
다른 점이라면 타입 매개변수 T를 선언한다는 것인데요. 코드로 확인해보면 아래와 같습니다.

class MadPlay&amp;lt;T&amp;gt; {
    private T val; // 멤버 변수 val의 타입은 T 이다.

    public T getVal() {
        // T 타입의 값 val을 반환한다.
        return val;
    }

    public void setVal(T val) {
        // T 타입의 값을 멤버 변수 val에 대입한다.
        this.val = val;
    }
}


생각보다 간단합니다. 이어서 제네릭 클래스의 레퍼런스 변수를 선언할 때는 아래와 같이 타입 매개변수에
구체적인 타입을 명시하면 됩니다.

public void someMethod() {
    MadPlay&amp;lt;String&amp;gt; stringObject;
    MadPlay&amp;lt;Integer&amp;gt; integerObject;
}


이제 구체화(Specialization)를 해야합니다. 이는 제네릭 타입을 가진 제네릭 클래스에 구체적인 타입을 대입하여
구체적인 행위를 할 수 있는 객체를 생성하는 과정을 말합니다. 그렇다면, 제네릭 클래스를 이용하여 객체를 생성해봅시다.

public void someMethod() {
    MadPlay&amp;lt;String&amp;gt; stringObject = new MadPlay&amp;lt;&amp;gt;();
    stringObject.setVal(&quot;Hello, MadPlay!&quot;);

    // Hello, MadPlay! 출력
    System.out.println(stringObject.getVal());

    MadPlay&amp;lt;Integer&amp;gt; integerObject = new MadPlay&amp;lt;&amp;gt;();
    integerObject.setVal(29);
    
    // 29 출력
    System.out.println(integerObject.getVal());
}


위 코드에서 String 타입으로 구체화된 객체 stringObject의 모습을 그림으로 보면 아래와 같습니다.






  제네릭 인터페이스


인터페이스에도 제네릭을 적용할 수 있습니다. 제네릭 인터페이스를 선언하고 이를 구현하는 제네릭 클래스는
아래와 같이 작성할 수 있습니다.

interface MadLife&amp;lt;T&amp;gt; {
    void addElement(T t, int index);
    T getElement(int index);
}

class MadPlay&amp;lt;T&amp;gt; implements MadLife&amp;lt;T&amp;gt; {
    private T[] array;

    public MadPlay() {
        array = (T[]) new Object[10];
    }

    @Override public void addElement(T element, int index) {
        array[index] = element;
    }

    @Override public T getElement(int index) {
        return array[index];
    }
}

public class GenericTest {
    public static void main(String[] args) {
        MadPlay&amp;lt;String&amp;gt; strObject = new MadPlay&amp;lt;&amp;gt;();
        strObject.addElement(&quot;Hello&quot;, 0);
        strObject.getElement(0);
        
        // 컴파일 시점 오류! String으로 이미 구체화된 상태이므로
        strObject.addElement(1, 1);
    }
}


참고로 우리가 String 정렬을 할 때 사용하는 compareTo와 같은 메서드는 Comparable 인터페이스의 추상 메서드인데요.
이 Comparable 인터페이스의 코드를 보면 아래와 같이 제네릭으로 구현되어 있습니다. 따라서 이를 implements 하는 타입은
값 비교를 통한 정렬을 간편하게 사용할 수 있지요.

public interface Comparable&amp;lt;T&amp;gt; {
    // ... 생략
    public int compareTo(T o);
}





  제네릭 메서드


메서드 단위에만 제네릭을 적용할 수 있습니다.

class MadPlay {
    public static &amp;lt;T&amp;gt; void arrayToStack(T[] arr, Stack&amp;lt;T&amp;gt; stack) {
        // 만일 위 2개의 타입이 다르면 컴파일 오류
        for (T element : arr) {
            stack.push(element);
        }
        // 사실 아래 방법을ㅎ
        stack.addAll(Arrays.asList(arr));
    }
}

public class GenericTest {
    public static void main(String[] args) {
        String[] array = new String[10];
        Stack&amp;lt;String&amp;gt; stack = new Stack&amp;lt;&amp;gt;();

        // 타입 매개변수 T를 String 으로 유추
        MadPlay.arrayToStack(array, stack);
    }
}





  이어서


이번 포스팅에서는 자바에서 제공되는 제네릭은 무엇인지 그리고 제네릭을 이용한 제네릭 클래스, 제네릭 인터페이스
그리고 제네릭 메서드를 만드는 방법에 대해서 알아보았습니다.

이어지는 포스팅에서 제네릭을 사용하면 좋은 점과 사용할 때 주의할 점에 대해서 알아보겠습니다.

  링크: 자바에서 제네릭의 장점과 사용할 때 주의할 점

</description>
        <pubDate>Thu, 13 Dec 2018 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/java-generic</link>
        <guid isPermaLink="true">https://madplay.github.io/post/java-generic</guid>
        
        <category>java</category>
        
        <category>generic</category>
        
        <category>generic-class</category>
        
        <category>generic-interface</category>
        
        <category>generic-method</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>Java 8 날짜와 시간 계산</title>
        <description>


  java.time 패키지


JDK 1.8 버전에서 java.time 패키지에 LocalDateTime과 타임존 개념까지 포함할 수 있는 ZonedDateTime가 
추가되었습니다. 따라서 이전보다 안전하고 편하게 날짜를 계산할 수 있습니다.

타임존에 관한 부분은 이어지는 글에서 다룰 예정입니다.




  날짜 가져오기


LocalDate 클래스는 년, 월, 일 정보만을 가지며 LocalTime은 시, 분, 초 정보만을 가집니다.
그리고 LocalDateTime 클래스는 이름으로부터 유추되는 것처럼 두 개의 클래스가 각각 갖는 정보를 모두 가지고 있습니다.

// 오늘 날짜, 2018-12-11
LocalDate nowDate = LocalDate.now();

// 2018년 12월 11일, 2018-12-11
LocalDate ofDate = LocalDate.of(2018, 12, 11);

// 바로 지금, 2018-12-11T13:12:11
LocalDateTime nowDateTime = LocalDateTime.now();

// 2018년 12월 11일 15시 23분 32초, 2018-12-11T15:23:32
LocalDateTime ofDateTime = LocalDateTime.of(2018, 12, 11, 15, 23, 32);





  특정 날짜/시간 가져오기



  오늘 자정(0시 0분 0초) 가져온 후 문자열 변환

// 오늘 날짜의 자정(midnight)
DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);
String date = LocalDate.now().atStartOfDay().format(formatter); // 2018-12-12 00:00:00.000



  내일 날짜 가져오기


// 2018년 12월 11일 15시 23분 32초, 2018-12-11T15:23:32
LocalDateTime ofDateTime = LocalDateTime.of(2018, 12, 11, 15, 23, 32);

// 2018년 12월 12일 15시 23분 32초, 2018-12-12T15:23:32
LocalDateTime tomorrow = ofDateTime.plusDays(1);



  내일 날짜의 마지막 시간 가져오기

// 2018년 12월 12일 23시 59분 59초
// 정확히는~ 23:59:59.999999999
LocalDateTime.now().plusDays(1).with(LocalTime.MAX);



  정오(오전 12시)

// 오늘 날짜의 정오(오전 12시)
LocalDateTime.now().with(LocalTime.NOON);





  날짜 변환하기



  
    날짜 정보를 문자열로 변환하거나 Date와 같은 구 버전의 날짜 클래스를 java 8 클래스로 변환할 수 있습니다.
  
  
    java.util.Date to java.time.LocalDateTime
  

// java.util.Date to java.time.LocalDateTime
LocalDateTime.ofInstant(new Date().toInstant(), ZoneId.systemDefault());



  java.time.LocalDate to java.time.LocalDateTime

// java.time.LocalDate to java.time.LocalDateTime
// 오늘 날짜, 15시 23분 30초
LocalDate.now().atTime(15, 23, 30);

// 오늘 날짜, 자정(0시)
LocalDate.now().atStartOfDay();



  java.time.LocalDateTime to java.lang.String

// java.time.LocalDateTime to java.lang.String
// 2018-12-11 13:53:21.121
LocalDateTime.now()
    .format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;));



  java.time.LocalDateTime to java.lang.String

// java.time.LocalDate to java.lang.String
// 2018-12-11
LocalDate.now().format(DateTimeFormatter.ISO_DATE);



  java.lang.String to java.time.LocalDateTime

// java.lang.String to java.time.LocalDateTime
// 2018-12-11T13:43:21.222
LocalDateTime.parse(&quot;2018-12-11 13:43:21.221&quot;,
    DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;));       



  java.lang.String to java.time.LocalDate

// java.lang.String to java.time.LocalDate 
// 2018-12-11
LocalDate.parse(&quot;2018-12-11&quot;);





  요일 다루기


가장 가까운 요일, N 번째 요일 등을 간단한 코드로 가져올 수 있습니다.


  오는 일요일(가장 가까운 다음 일요일)

// 12월 11일 기준, 오는 일요일은 12월 16일
LocalDateTime.now().with(TemporalAdjusters.next(DayOfWeek.SUNDAY))



  2018년 12월의 4번째 일요일

// 2018년 12월 기준, 네 번째 일요일은 23일
LocalDate.of(2018, 12, 11).with(TemporalAdjusters.dayOfWeekInMonth(4, DayOfWeek.SUNDAY));



  2018년 12월의 첫 번째 일요일

// 2018년 12월 기준, 첫 번째 일요일은 2일
LocalDate.of(2018, 12, 11).with(TemporalAdjusters.firstInMonth(DayOfWeek.SUNDAY));





  언어별 표기 출력


굉장히 신기했던 것 중 하나인데… 언어별로 월이나 요일 표기도 가능합니다.

// 한국어 표기
Month.FEBRUARY.getDisplayName(TextStyle.FULL, Locale.KOREAN); // 2월
Month.FEBRUARY.getDisplayName(TextStyle.NARROW, Locale.KOREAN); // 2월
Month.FEBRUARY.getDisplayName(TextStyle.SHORT, Locale.KOREAN); // 2월

DayOfWeek.SUNDAY.getDisplayName(TextStyle.FULL, Locale.KOREAN); // 일요일
DayOfWeek.SUNDAY.getDisplayName(TextStyle.SHORT, Locale.KOREAN); // 일
DayOfWeek.SUNDAY.getDisplayName(TextStyle.NARROW, Locale.KOREAN); // 일

// 영어 표기
Month.FEBRUARY.getDisplayName(TextStyle.FULL, Locale.ENGLISH); // February
Month.FEBRUARY.getDisplayName(TextStyle.SHORT, Locale.ENGLISH); // Feb
Month.FEBRUARY.getDisplayName(TextStyle.NARROW, Locale.ENGLISH); // F

DayOfWeek.SUNDAY.getDisplayName(TextStyle.FULL, Locale.ENGLISH); // Sunday
DayOfWeek.SUNDAY.getDisplayName(TextStyle.SHORT, Locale.ENGLISH); // Sun
DayOfWeek.SUNDAY.getDisplayName(TextStyle.NARROW, Locale.ENGLISH); // S

</description>
        <pubDate>Tue, 11 Dec 2018 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/java8-date-and-time</link>
        <guid isPermaLink="true">https://madplay.github.io/post/java8-date-and-time</guid>
        
        <category>java</category>
        
        <category>date</category>
        
        <category>자바날짜계산</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>Java Date와 Time 클래스를 사용하면 안되는 이유</title>
        <description>


  자바의 Date API


자바에서는 기본적으로 날짜와 시간을 계산하는 많은 클래스를 제공합니다. 오랫동안 제공된 JDK 1.0의 java.util.Date와
JDK 1.1 이후의 java.util.Calendar 클래스를 비롯해서 JDK 8부터 제공되기 시작한 java.time 패키지에는
ZonedDateTime과 LocalDateTime 등 조금 더 개선된 날짜와 시간 관련 클래스를 제공합니다.

하지만 Date와 Calendar 클래스에는 생각보다 많은 문제점이 있습니다. 이를 알아봅시다.




  그래도 사용해보기


기본적으로 제공되어서 그런지 Date와 Calendar 클래스를 많이 이용했던 것 같습니다. 하지만 자바 버전업이 되면서 Date 클래스의
많은 메서드가 Deprecate 되었습니다. 그래도 기존 방식을 이용하여 오늘 날짜를 포맷에 맞추어 출력하는 코드는 아래와 같습니다.

import java.text.SimpleDateFormat;
import java.util.Date;

public class JavaDateTest {
    public static void main(String[] args) {
        Calendar cal = Calendar.getInstance();
        Date date = cal.getTime();
        String dateString = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(date);
        // 2018-12-09
        System.out.println(dateString);

        // 1일 더한다.
        cal.add(Calendar.DATE, 1);
        date = cal.getTime();
        dateString = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(date);

        // 2018-12-10
        System.out.println(dateString);
    }
}


간단하긴 합니다. Date를 반환하는 메서드가 getTime인 모호함으로 반환 타입 예측이 불가능하다는 것만 빼면 말이지요.




  애매한 상수의 이용


메서드의 이름으로 반환 타입을 예측하지 못하는 것처럼 개발자가 혼란을 일으킬 수 있는 부분은 생각보다 많습니다.

우선 위의 코드에서 본 것처럼 1일을 더하기 위한 날짜 연산은 컴파일 시점에서 오류를 확인할 수 없습니다.

예를 들어 아래와 같이 기대한 입력과 다른 입력을 주어도 확인할 방법이 없습니다.

Calendar cal = Calendar.getInstance();

// 월요일 하루를 더하자는 걸까?
cal.add(Calendar.MONDAY, 1);





  월(Month) 계산


그리고 참 혼동스러운 월(Month) 지정이 있습니다. Calendar 클래스의 월 표기를 위한 상수 값을 확인해보면
아래와 같습니다.

/**
 * Value of the {@link #MONTH} field indicating the
 * first month of the year in the Gregorian and Julian calendars.
 */
public final static int JANUARY = 0;

/**
 * Value of the {@link #MONTH} field indicating the
 * second month of the year in the Gregorian and Julian calendars.
 */
public final static int FEBRUARY = 1;

/**
 * Value of the {@link #MONTH} field indicating the
 * third month of the year in the Gregorian and Julian calendars.
 */
public final static int MARCH = 2;


그러니까 2월을 지정하려면 월(Month) 값에서 1을 빼야하는 것이지요. 상수를 사용하지 않는다면 아래와 같이 가독성을 위해
-1을 일부러 쓰는 것도 나쁘지 않을 것 같습니다만… 혼란스럽습니다.




  심지어 하위 클래스에도…


그런데 이러한 문제가 있는 클래스를 상속한 클래스도 있습니다. java.sql.TimeStamp 클래스인데요.
java.util.Date 클래스에 나노 초 단위 필드를 더한 클래스입니다. equals 메서드 재정의를 어긴 것인데,
자세한 내용은 아래 링크를 참조하시기 바랍니다.


이펙티브 자바 10: equals는 일반 규약을 지켜 재정의하라(링크)




  불변이 아니다


Calendar cal = Calendar.getInstance();
cal.set(Calendar.MONTH, 2 - 1);


위 코드에서 볼 수 있듯이 자바의 기본 날짜 관련 클래스는 불변(immutable) 객체가 아닙니다.
Date나 Calendar 객체가 다른 코드에서도 공유하여 사용한다면 한 쪽에서 변경한 날짜값이 다른 부분에 영향을 줄 수 있습니다.

한편 날짜 단위 계산처럼 Date 클래스만으로 수행이 깔끔하게 되지 않아 Calendar 객체를 생성하고
그 객체에서 Date 객체를 생성하고 있습니다. 어떻게 보면 기본적으로 제공하는 클래스보다 Apache Commons 라이브러리의
DateUtils를 사용하는 것이 더 나을지도 모르겠습니다.




  그럼 어떻게 해야할까?


다행히도 JDK 8 부터는 보다 안전하고 간편한 날짜 관련 클래스가 제공됩니다.

“ 이어지는 글 : Java 8 날짜와 시간 계산(링크) “ 에서 예제를 통해 사용법을 알아봅시다.

</description>
        <pubDate>Sun, 09 Dec 2018 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/reasons-why-javas-date-and-calendar-was-bad</link>
        <guid isPermaLink="true">https://madplay.github.io/post/reasons-why-javas-date-and-calendar-was-bad</guid>
        
        <category>java</category>
        
        <category>date</category>
        
        <category>calendar</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>이펙티브 자바 28: 배열보다는 리스트를 사용하라</title>
        <description>


  배열과 제네릭 타입의 차이


첫 번째로 배열은 공변(covariant)입니다. 예를들어 Sub가 Super의 하위 타입이라면
배열 Sub[]는 배열 Super[]의 하위 타입이 된다고 할 수 있습니다.
이를 공변이라고 합니다. 즉 함께 변한다는 뜻이지요.

반면에 제네릭은 불공변(invariant) 입니다. List&amp;lt;Sub&amp;gt;는 List&amp;lt;Super&amp;gt;의 하위 타입도 아니고
상위 타입도 되지 않습니다.

단순 비교만으로는 제네릭에 문제가 있다고 생각하지만, 사실 문제가 있는 건 배열입니다.
Long 타입용 저장소에 String 타입을 넣을 수는 없습니다. 아래의 코드처럼 배열에서는
코드가 실행되는 런타임 시점에서야 오류가 발생함을 알 수 있지만 리스트의 경우 컴파일 시점에 오류를 확인할 수 있습니다.

Object[] objectArray = new Long[1];
// ArrayStoreException 발생
objectArray[0] = &quot;Kimtaeng&quot;;

// 아예 컴파일 오류
List&amp;lt;Object&amp;gt; objectList = new ArrayList&amp;lt;Long&amp;gt;();
objectList.add(&quot;Kimtaeng&quot;);


다음으로 제네릭과 다르게 배열은 실체화(reify) 됩니다. 런타임에도 자신이 담기로 한 원소의 타입을
인지하게 확인함을 말합니다. 위의 코드에서 ArrayStoreException이 발생한 것도 그 이유입니다.

하지만 제네릭은 타입 정보가 런타임 시점에 소거(erasure)됩니다. 원소 타입을 컴파일 시점에만 검사하기 때문에
런타임 시점에는 알 수 없습니다. 타입 정보가 소거된 로 타입(Raw type)의 경우 제네릭이 지원되기 전의 레거시 코드와
제네릭 타입을 함께 사용할 수 있도록 해줍니다. 

(참고 링크 - 이펙티브 자바 26: 로 타입은 사용하지 말라)


이처럼 결국 배열과 제네릭은 친해지기 어려운 관계입니다. 배열은 아래와 같이 제네릭 타입, 매개변수화 타입,
타입 매개변수로 사용할 수 없습니다.

// 배열은 아래와 같이 사용하면 오류가 발생한다.
new List&amp;lt;E&amp;gt;[]; // 제네릭 타입
new List&amp;lt;String&amp;gt;[]; // 매개변수화 타입
new E[]; // 타입 매개변수





  왜 제네릭 배열을 생성 못하게 막았을까?


타입 안전성이 보장되지 않기 때문입니다. 제네릭 배열의 생성을 허용한다면 컴파일러가 자동으로 생성한 형변환 코드에서
런타임 시점의 ClassCastException이 발생할 수 있습니다. 런타임 시점의 형변환 예외가 발생하는 것을 막겠다는
제네릭의 취지에 맞지 않습니다. 아래 예시의 (1) 번처럼 제네릭 배열이 생성된다고 가정해봅시다.

List&amp;lt;String&amp;gt;[] stringLists = new List&amp;lt;String&amp;gt;[1]; // (1) 
List&amp;lt;Integer&amp;gt; intList = List.of(42);              // (2)
Object[] objects = stringLists;                   // (3)
objects[0] = intList;                             // (4)
String s = stringLists[0].get(0);                 // (5)



  (2) 번은 원소가 하나인 List를 생성합니다. 참고로 List.of 메서드는 JDK 9부터 사용할 수 있습니다.
  (3) 번은 (1)번 과정에서 생성된다고 가정한 제네릭 배열을 Object[]에 할당합니다.
배열은 공변(Covariant)이므로 아무런 문제가 없습니다.
  (4) 번은 (2)에서 생성한 List&amp;lt;Integer&amp;gt;의 인스턴스를 Object 배열의 첫 원소로 저장합니다.
제네릭은 런타임 시점에서 타입이 사라지므로 List&amp;lt;Integer&amp;gt;은 List가 되고 List&amp;lt;Integer&amp;gt;[]는 List[]가 됩니다.
따라서 ArrayStoreException이 발생하지 않습니다.
  문제되는 부분은 (5) 번입니다. List&amp;lt;String&amp;gt; 인스턴스만 담겠다고 선언한 stringLists 배열에
다른 타입의 인스턴스가 담겨있는데 첫 원소를 꺼내려고 합니다. 그리고 이를 String으로 형변환하는데, 이 원소는
Integer 타입이므로 런타임에 ClassCastException 이 발생합니다.


따라서 이러한 일을 방지하려면 제네릭 배열이 생성되지 않도록 (1) 번 과정에서 컴파일 오류가 발생해야 합니다.




  실체화 불가 타입


E, List&amp;lt;E&amp;gt;, List&amp;lt;String&amp;gt; 같은 타입을 실체화 불가 타입(non-reifiable type)이라 합니다.
제네릭 소거로 인해 실체화되지 않아서 런타임 시점에 컴파일타임보다 타입 정보를 적게 가지는 타입을 말합니다.

(참조 링크 - Oracle Docs: Non-Reifiable Types)

소거로 인해 매개변수화 타입 가운데 실체화될 수 있는 타입은 List&amp;lt;?&amp;gt;와 Map&amp;lt;?,?&amp;gt; 같은 비한정적 와일드카드 타입뿐입니다.




  배열로 형변환시 오류가 발생한다면


배열로 형변환할 때 제네릭 배열 생성 오류나 비검사 형변환 경고가 뜨는 경우
대부분은 배열인 E[] 대신에 컬렉션인 List&amp;lt;E&amp;gt;를 사용하면 해결됩니다.

public class Chooser {
    private final Object[] choiceArray;
    
    public Chooser(Collection choices) {
        this.choiceArray = choices.toArray();
    }
    
    // 이 메서드를 사용하는 곳에서는 매번 형변환이 필요하다.
    // 형변환 오류의 가능성이 있다.
    public Object choose() {
        Random rnd = ThreadLocalRandom.current();
        return choiceArray[rnd.nextInt(choiceArray.length)];
    }
}


위 코드를 제네릭을 사용하여 아래와 같이 변경할 수 있습니다.

public class Chooser&amp;lt;T&amp;gt; {
    private final T[] choiceArray;

    public Chooser(Collection&amp;lt;T&amp;gt; choices) {
        // 오류 발생 incompatible types: java.lang.Object[] cannot be converted to T[]
        this.choiceArray = choices.toArray();
    }

    // choose 메소드는 동일하다.
}


incompatible types 오류는 아래와 같이 코드를 변경하면 해결됩니다.

// Object 배열을 T 배열로 형변환하면 된다.
this.choiceArray = (T[]) choices.toArray();


컴파일 오류는 사라졌지만 Unchecked Cast 경고가 발생합니다. 타입 매개변수 T가 어떤 타입인지 알 수 없으니 형변환이
런타임에도 안전한지 보장할 수가 없다는 메시지입니다. 제네릭은 런타임에는 타입 정보가 소거되므로 무슨 타입인지 알 수 없습니다.
Unchecked Cast과 같은 비검사 형변환 경고를 제거하려면 배열 대신 리스트를 사용하면 됩니다.

class Chooser&amp;lt;T&amp;gt; {
    private final List&amp;lt;T&amp;gt; choiceList;

    public Chooser(Collection&amp;lt;T&amp;gt; choices) {
        this.choiceList = new ArrayList&amp;lt;&amp;gt;(choices);
    }

    public T choose() {
        Random rnd = ThreadLocalRandom.current();
        return choiceList.get(rnd.nextInt(choiceList.size()));
    }
}


정리해보면 배열은 공변이고 실체화되는 반면, 제네릭은 불공변이고 타입 정보가 소거됩니다.
따라서 배열은 런타임에는 타입 안전하지만 컴파일타임에는 안전하지 않습니다. 제네릭은 그 반대로 적용됩니다.

해당 내용은 Effective Java 3th Edition을 기반으로 작성되었습니다.
</description>
        <pubDate>Fri, 07 Dec 2018 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/prefer-lists-to-arrays</link>
        <guid isPermaLink="true">https://madplay.github.io/post/prefer-lists-to-arrays</guid>
        
        <category>java</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>var, let, const 변수의 차이점은 무엇일까?</title>
        <description>
  var, let, const


ES5까지는 변수를 선언할 때는 아래와 같이 코드를 작성했습니다.

var foo = '1';
var foo = '2';


물론 var 선언 없이도 변수 선언이 가능하지만 전역 객체의 특성을 갖게되어
다른 곳에서 동일한 이름으로 변수를 네이밍했을 때 이슈가 있을 수 있습니다.
그리고 위 코드에서 볼 수 있는 것처럼 중복 선언도 허용됩니다. 동일 이름으로 2번 선언해도 아무런 문제가 되지 않습니다.

한편 ECMAScript 2015(ES6)에서는 변수 선언에 사용할 수 있는 let과 const 키워드가 추가되었는데요.
각 선언마다 어떻게 다른지 하나씩 살펴봅시다.




  스코프


스코프(Scope)의 차이를 먼저 알아볼까 합니다. var 변수는 기본적으로 Function Scope를 가집니다.
이와 다르게 let과 const는 Block Scope를 가집니다. 조금 더 정확하게 아래 코드로 살펴봅시다.

var foo = 1;

function fuc() {
    var foo = 2;
    console.log('foo in function : ' + foo);
}

if(true) {
    var foo = 3;
}

func();
console.log('foo : ' + foo);

// 출력 결과
// foo in function : 2
// foo : 3


var의 경우 변수를 블록으로 감싸더라도 유효 범위가 함수(function)이기 때문에 if블록 내에서
값이 재할당됩니다. 반면에 let은 어떨까요?

let foo = 1;

function func() {
    let foo = 2;
    console.log('foo in function : ' + foo);
}

if(true) {
    let foo = 3;
}

func();
console.log('foo : ' + foo);

// 출력 결과
// foo in function : 2
// foo : 1


let은 Block Scope이므로 블록내에서 재선언하는 경우 새로운 변수로 인식합니다.
그러니까 블록 내에서만 유효하게 되지요.




  재선언, 재할당


var는 상당히 유연합니다. 동일한 변수 이름으로 다시 선언해도 아무런 문제가 되지 않습니다.
상단에서 선언한 변수를 잊고 다시 선언한 경우에 문제가 발생할 수 있습니다.

var foo = 'a';
console.log(foo); // 'a'
foo = 'b';
console.log(foo); // 'b'

// 만일 이 사이에 여러 라인의 코드가 있다면..!? 
var foo = 'c';
console.log(foo); // 'c'


let은 조금 다릅니다. 동일한 변수 이름으로 재선언하는 경우 에러를 발생합니다.

let foo = 'a';
console.log(foo); // 'a'
foo = 'b';
console.log(foo); // 'b'

// 동일한 변수 이름으로 재선언하는 경우에 에러가 발생한다.
let foo = 'c'; // Uncaught SyntaxError: Identifier 'foo' has already been declared


const도 마찬가지입니다. 하지만 조금 다른 부분도 있습니다. const는 상수이기 때문에
값도 다시 할당할 수 없습니다.

const foo = 'a';
console.log(foo); // 'a'
foo = 'b'; // VM456:1 Uncaught TypeError: Assignment to constant variable.

// let과 동일하게 변수를 재선언한다면 오류가 발생한다.
const foo = 'c'; // Uncaught SyntaxError: Identifier 'foo' has already been declared





  호이스팅


호이스팅(hoisting)은 개인적으로 코드를 읽기 난해하게 만들 수 있다고 봅니다. 끌어올리다라는 뜻을 가진 호이스팅은
아래와 같은 코드로 설명할 수 있습니다.

console.log(foo); // undefined
var foo = 'a';
console.log(foo); // 'a'


위의 자바스크립트 코드는 아무런 오류없이 동작합니다. 호이스팅을 통해 var 키워드가 다시 해석되기 때문인데요.
실제 값 할당을 제외하고 선언만 올려지게 되며 위에서 작성한 실제 코드는 아래와 같이 변경됩니다.

var foo; // 선언을 위로 끌어올린다.
console.log(foo);
var foo = 'a';
console.log(foo);


조금 더 살펴볼까요? 첫 번째 예제와 같이 for loop에 선언한 var 변수도 루프 밖에서 사용이 가능합니다.
역시나 호이스팅(hoisting) 되었기 때문입니다.

for(var count = 1; count &amp;lt;= 3; count++) {
    console.log('count : ' + count);
}
console.log('Finished : ' + count);
// 결과 출력
// count : 1
// count : 2
// count : 3
// Finished : 4


반면에 let은 다릅니다. 미리 선언되지 않으면 오류가 발생합니다.

console.log(foo);
// Uncaught SyntaxError: Identifier 'foo' has already been declared
let foo = 'a';
console.log(foo);





  정리하면?


스코프(Scope) 관점으로 보면 var는 Function Scope이다. 따라서 함수 블록으로 스코프가 생성되고
반면에 let과 const는 Block Scope이므로 지정한 블록으로 스코프가 유효합니다.

그리고 var 변수는 호이스팅(hoisting)이 일어나는 반면에 let과 const는 호이스팅이 일어나지 않는다.
선언하기 전에 변수를 사용하게 되는 경우에 오류가 발생합니다.

마지막으로 const는 상수이므로 값을 재할당하는 경우에 오류가 발생합니다.
</description>
        <pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/javascript-difference-between-var-let-and-const</link>
        <guid isPermaLink="true">https://madplay.github.io/post/javascript-difference-between-var-let-and-const</guid>
        
        <category>javascript</category>
        
        <category>variable</category>
        
        <category>scope</category>
        
        
        <category>Script</category>
        
      </item>
    
      <item>
        <title>이펙티브 자바 34: INT 상수 대신 열거 타입을 사용하라</title>
        <description>


  자바에서 상수 선언


자바 언어의 열거 타입(enum type)은 Java 1.5에 등장했습니다. 그 버전에서 상수 선언은 아래와 같이 했지요.

public static final int APPLE_FUJI = 0; // 부사?
public static final int APPLE_PIPPIN = 1; // ..!?
public static final int APPLE_GRANNY_SMITH = 2; // 풋사과..?

public static final int ORANGE_NAVEL = 0; // 귤인가...
public static final int ORANGE_TEMPLE = 1; // 귤인듯...
public static final int ORANGE_BLOOD = 2; // 붉은색 오렌지?


위와 방식을 정수 열거 패턴(int enum pattern)이라고 하는데, 보기만해도 단점이 많아 보입니다.
먼저 타입 안전성을 보장하기가 어렵습니다. 예를 들어서 오렌지를 건네야 하는 메서드에 사과를 보낸다면 어떻게 될까요?
동등 연산자(==)로 비교해도 아무런 경고없이 동작하게 되겠지요.

그리고 표현 방식이 참 애매합니다. 사과용 상수와 오렌지용 상수의 이름 충돌을 방지하기 위해 접두사(prefix)를 사용했습니다.
마지막으로 이를 문자열로 출력하기도 다소 까다로운 점이 있습니다.

그렇다면 열거 타입(enum type)을 사용하면 어떻게 될까요?




  열거 타입의 등장


열거 타입의 등장으로 아래와 같이 간편하게 사용할 수 있습니다.


public enum Apple { FUJI, PIPPIN, GRANNY_SMITH }
public enum Orange { NAVEL, TEMPLE, BLOOD }


그렇다면 열거 타입에는 어떠한 장점들이 있을까요?


  자바의 열거 타입은 완전한 형태의 클래스라고 볼 수 있습니다.
  열거 타입은 밖에서 접근할 수 있는 생성자를 제공하지 않으므로 사실상 final 이라고 볼 수 있습니다.
  인스턴스들은 오직 하나만 존재합니다.
  열거 타입은 컴파일 타임에서의 타입 안전성을 제공합니다.
    
      예를 들어 위의 예제에서 Apple 열거 타입을 매개변수로 받는 메서드를 선언했다면, 건네받은 참조는
Apple의 세 가지 값 중 하나임이 확실합니다. 다른 타입의 값을 넘기려 하면 컴파일 오류가 발생합니다.
    
  
  열거 타입의 toString 메서드는 출력하기에 적합한 문자열을 제공합니다.
  임의의 메서드나 필드를 추가할 수 있고 임의의 인터페이스를 구현하게 할 수 있습니다.





  열거 타입의 예시



  아래와 같이 태양계의 여덞 행성에 대한 열거 타입을 만드는 것도 그리 어렵지 않습니다.

enum Planet {
    MERCURY(3.302e+23, 2.439e6),
    VENUS(4.869e+24, 6.052e6),
    EARTH(5.975e+24, 6.378e6);
    // ...
    
    private final double mass; // 질량
    private final double radius; // 반지름
    private final double surfaceGravity; // 표면중력
    
    private static final double G = 6.67300E-11;
    
    // 생성자
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
        surfaceGravity = G * mass / (radius * radius);
    }
    
    public double mass() { return mass; }
    public double radius() { return radius; }
    public double surfaceGravity() { return surfaceGravity; }
    
    public double surfaceWeight(double mass) {
        return mass * surfaceGravity; // F = ma
    }
}


열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 됩니다.
한편 열거 타입은 근본적으로 불변이므로 모든 필드는 final 이어야 합니다. 열거 타입은 자신 안에 정의된
상수들의 값을 배열에 담아 반환하는 정적 메서드 values 를 제공합니다.

public class EffectiveJava34 {
     public static void main(String []args){
         double earthWeight = Double.parseDouble(&quot;150&quot;);
         double mass = earthWeight / Planet.EARTH.surfaceGravity();
  
        // 모든 enum 요소를 탐색할 수 있다.       
         for(Planet p : Planet.values()) {
            System.out.printf(&quot;%s에서의 무게는 %f이다.%n&quot;, p, p.surfaceWeight(mass));
        }
     }
} 





  상수가 더 다양한 기능을 제공하길 원한다면?


예를 들어 사칙연산 계산기의 연산 종류를 열거 타입으로 선언하고, 실제 연산까지 열거 타입 상수가 직접 수행하게 된다면 어떨까요?

enum Operation {
    PLUS, MINUS, TIMES, DIVIDE;
    
    public double apply(double x, double y) {
        switch(this) {
            case PLUS: return x + y;
            case MINUS: return x - y;
            case TIMES: return x * y;
            case DIVIDE: return x / y;
        }
        throw new AssertionError(&quot;알 수 없는 연산: &quot; + this);
    }
}


위 코드는 정상적으로 실행되나 그리 적절한 코드라고 보기는 어렵습니다.
마지막에 선언된 throw 문은 실제로 실행될 경우가 적지만 기술적으로는 도달할 수 있습니다.
그리고 깨지기 쉬운 코드인데요. 예컨대 새로운 상수를 추가하면 해당 case 문장도 추가해야 합니다.

그렇다면 상수에서 알맞게 재정의하는 방법을 쓰는 것은 어떨까요?




  상수별 메서드 구현


상수별 메서드 구현(constant-specific method implementation)은 상수에서 자신에 맞게 재정의하는 것을 말합니다.

enum Operation {
    PLUS { 
        public double apply(double x, double y) {
            return x + y;
        }
    },
    MINUS {
        public double apply(double x, double y) {
            return x - y;
        }
    }
    // ...
    public abstract double apply(double x, double y);
}


apply 메서드가 상수 선언 바로 밑에 있으니 새로운 상수를 추가할 때도 apply 메서드를 항상 재정의해야 한다는
사실을 까먹기 어렵습니다. 그리고 apply 메서드가 추상 메서드이므로 재정의하지 않았다면 컴파일 오류도 알려줍니다.

상수별 메서드 구현을 상수별 데이터와 결합할 수도 있습니다. 예를 들어 아래와 같이 Operation의 toString을
재정의하여 해당 연산을 뜻하는 기호를 반환하도록 해봅시다.

public class EffectiveJava34 {
    public static void main(String []args){
        double x = Double.parseDouble(&quot;2&quot;);
        double y = Double.parseDouble(&quot;3&quot;);
        for (Operation op : Operation.values()) {
            System.out.printf(&quot;%f %s %f = %f%n&quot;, x, op, y, op.apply(x, y));
        }
         
    }
}

enum Operation {
    PLUS(&quot;+&quot;) { 
        public double apply(double x, double y) {
            return x + y;
        }
    },
    MINUS(&quot;-&quot;) {
        public double apply(double x, double y) {
            return x - y;
        }
    },
    TIMES(&quot;*&quot;) {
        public double apply(double x, double y) {
            return x * y;
        }
    },
    DIVIDE(&quot;/&quot;) {
        public double apply(double x, double y) {
            return x * y;
        }
    };
    
    private final String symbol;
    
    Operation(String symbol) {
        this.symbol = symbol;
    }
    
    @Override
    public String toString() {
        return symbol;
    }
    
    public abstract double apply(double x, double y);
}

// 출력
2.000000 + 3.000000 = 5.000000
2.000000 - 3.000000 = -1.000000
2.000000 * 3.000000 = 6.000000
2.000000 / 3.000000 = 6.000000



열거 타입에는 상수 이름을 입력받아 그 이름에 해당하는 상수를 반환해주는 valueOf(String) 메서드가
자동 생성됩니다. 열거 타입의 toString 메서드를 재정의했다면, toString이 반환하는 문자열을 해당 열거 타입 상수로
변환해주는 fromString 메서드도 고려해볼 수 있습니다.

private static final Map&amp;lt;String, Operation&amp;gt; stringToEnum =
		Stream.of(values()).collect(Collectors.toMap(Object::toString, e -&amp;gt; e));

/*
 * 가끔 안 읽혀서... 풀어보면ㅎ
private static final Map&amp;lt;String, Operation&amp;gt; stringToEnum =
    Stream.of(values()).collect(Collectors.toMap(new Function&amp;lt;Operation, String&amp;gt;() {
        @Override
        public String apply(Operation o) {
            return o.toString();
        }
    }, new Function&amp;lt;Operation, Operation&amp;gt;() {
        @Override
        public Operation apply(Operation o) {
            return o;
        }
    }));
*/
public static Optional&amp;lt;Operation&amp;gt; fromString(String symbol) {
    return Optional.ofNullable(stringToEnum.get(symbol));
}


그런데, 이런 상수별 메서드에도 단점은 있습니다. 열거 타입 상수끼리 코드를 공유하기가 어려운 점인데요.
예를 들어서 살펴봅시다.

enum PayrollDay {
	MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,
	SATURDAY, SUNDAY;

	private static final int MINS_PER_SHIFT = 8 * 60; // 하루 8시간

	int pay(int minutesWorked, int payRate) {
		int basePay = minutesWorked * payRate;

		int overtimePay;
		switch(this) {
			case SATURDAY: case SUNDAY: // 주말
				overtimePay = basePay / 2;
				break;
			default: // 주중
				if (minutesWorked &amp;lt;= MINS_PER_SHIFT) {
					overtimePay = 0	;
				} else {
					overtimePay = (minutesWorked - MINS_PER_SHIFT) * payRate / 2;
				}
		}
		return basePay + overtimePay;
	}
}


휴가와 같이 새로운 값을 열거 타입에 추가하려면 그 값을 처리하는 case 문을 넣어야 합니다.
그렇지 않으면 휴가 기간에 일해도 평일과 똑같은 임금을 받게 되겠죠… 그럼 어떻게 해야 할까요?




  전략 열거 타입 패턴


안전성과 유연함을 고려한다면 전략 열거 타입 패턴을 고려해볼 수 있습니다. switch 문이나 상수별 메서드 구현이
필요 없어지지요. 새로운 상수를 추가할 때마다 잔업수당 전략을 선택하도록 하는 것입니다.

enum PayrollDay {
	MONDAY(), TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,
	SATURDAY(PayType.WEEKEND), SUNDAY(PayType.WEEKEND);

	private final PayType payType;

	PayrollDay() {
		this(PayType.WEEKDAY);
	}

	PayrollDay(PayType payType) {
		this.payType = payType;
	}

	enum PayType {
		WEEKDAY {
			int overtimePay(int minsWorked, int payRate) {
				int overtimePay;
				if (minsWorked &amp;lt;= MINS_PER_SHIFT) {
					overtimePay = 0;
				} else {
					overtimePay = (minsWorked - MINS_PER_SHIFT) * payRate / 2;
				}
				return overtimePay;
			}
		},
		WEEKEND {
			int overtimePay(int minsWorked, int payRate) {
				return minsWorked * payRate / 2;
			}
		};

		abstract int overtimePay(int mins, int payRate);

		private static final int MINS_PER_SHIFT = 8 * 60; // 하루 8시간

		int pay(int minutesWorked, int payRate) {
			int basePay = minutesWorked * payRate;
			return basePay + overtimePay(minutesWorked, payRate);
		}
	}
}





  그래서 정리해보면


열거 타입은 확실히 정수 상수보다 효율적입니다. 읽기도 쉽고 강력합니다. 물론 메서드도 쓸 수 있고요.
필요한 원소를 컴파일 타임에 모두다 알 수 있는 상수의 집합이라면 열거 타입을 강력히 추천합니다.
바이너리 수준에서 호환되도록 설계되었기 때문에 열거 타입에 정의된 상수 개수가 영원히 고정 불변일 필요도 없습니다.

해당 내용은 Effective Java 3th Edition을 기반으로 작성되었습니다.
</description>
        <pubDate>Sun, 02 Dec 2018 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/use-enums-instead-of-int-constants</link>
        <guid isPermaLink="true">https://madplay.github.io/post/use-enums-instead-of-int-constants</guid>
        
        <category>java</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>서버 사이드 렌더링과 클라이언트 사이드 렌더링</title>
        <description>


  렌더링


렌더링(Rendering)은 요청을 받은 웹 페이지의 내용을 화면에 그려주는 것을 말합니다.
어느 쪽에서 리소스를 해석하고 그려주느냐에 따라서 서버 사이드 렌더링(Server Side Rendering)과
클라이언트 사이드 렌더링(Client Side Rendering)으로 나눌 수 있습니다.

조금 더 자세히 각각의 렌더링에 대해서 살펴봅시다.




  서버 사이드 렌더링


기존의 보편적인 웹 애플리케이션의 렌더링 방식입니다. 사용자가 웹 페이지에 접속하면 서버에 해당 페이지를 요청하고
서버에서는 HTML과 같은 리소스를 해석하고 렌더링하여 사용자에게 보여줍니다.



이처럼 서버 사이드 렌더링은 요청시마다 새로고침이 발생하며 새로운 페이지를 서버에 매번 요청하게 됩니다.
예를 들자면 마치 새로운 옷을 입고 싶을 때마다 백화점에 가서 옷을 구매하는 것이지요.

한편 모바일 환경이 대중화되고 그에 따라 제공되어지는 정보량이 많아지면서 기존의 방식과
다른 모바일에 최적화된 서비스가 필요해졌습니다. 그래서 등장한 방식이 SPA(Single Page Application)입니다.




  Single Page Application


SPA(Single Page Application)은 브라우저가 로드된 이후에 페이지 전체를 서버에 요청하는 것이 아니라
최초에 페이지 전체를 불러온 후에는 데이터만 필요에 맞게 변경하여 사용하는 웹 애플리케이션을 말합니다.



서버 사이드 렌더링처럼 또 다른 웹페이지를 보고 싶을 때마다 서버에 새로운 페이지 요청을 하는 것이 아니라
최초 요청에 대해서만 서버 측에서 제공하고 이후의 페이지 또는 데이터 변경에 대해서는 클라이언트 측의 스크립트를 이용해
렌더링하게 됩니다. 이를 클라이언트 사이드 렌더링(Client Side Rendering) 이라고 합니다.

예를 들자면 백화점에 한 번만 방문하여 조금 더 오랜 시간동안 필요한 옷(리소스)들을 고른 후에 옷장에 넣어둡니다.
이후에 새로운 옷이 필요하면 백화점(서버)에 가지 않고 옷장에서 꺼내 입으면 되지요.

이 방식은 기존 보편적인 방식인 서버 사이드 렌더링과 다르게 페이지 요청마다 새로고침이 일어나지 않으며 서버측의 트래픽을 감소시킵니다.
또한 사용자 입장에서는 더 쾌적한 인터랙션(interaction)을 경험할 수 있습니다. 서버의 역할은 단순하게 스크립트에 이용할 데이터만 내려주면 되고
페이지를 그리는 역할은 클라이언트가 스크립트를 통해 수행하게 됩니다.




  그럼 어느게 더 좋은가?


각 렌더링 방식의 특성에 대해서 비교해보면 장단점을 정리할 수 있습니다.

서버 사이드 렌더링의 경우 서버 측에서 뷰(View)를 렌더링하여 가져오기 때문에 첫 로딩 속도가 상대적으로 빠릅니다.
페이지에서 자바스크립트를 사용한다면 그에 필요한 스크립트 파일들이 모두 로드된 후에 실행되므로 아무런 인터렉션이 반응하지 않지만
페이지를 보고 있는 사용자 입장에서는 로딩이 빠르다고 볼 수 있습니다.

반대로 클라이언트 사이드 렌더링의 경우 서버 측이 아닌 페이지 구성을 위한 HTML, 자바스크립트 파일 등을 로드한 후에 브라우저에서 렌더링을
시작하므로 서버 사이드 렌더링보다 상대적으로 초기 로딩 속도는 오래 걸립니다. 하지만 그 이후에는 서버로부터 페이지를 다시 요청하지 않기때문에
더 빠른 인터렉션을 기대할 수 있습니다.

보안적인 측면도 생각할 수 있습니다. 세션(Session)으로 사용자 정보를 관리하는 서버 사이드 렌더링과 다르게
클라이언트 사이드 렌더링은 항상 클라이언트 측에 저장되는 쿠키(Cookie)를 이용하게 됩니다.

검색 엔진 최적화에 대해서도 고려해야 합니다. 웹 상에는 컨텐츠를 수집하는 다양한 봇(bot)과 웹 크롤러(Web Crawler)가 있습니다.
자신이 운영하는 페이지가 정상적으로 수집되어야 한다면 클라이언트 사이드 렌더링 방식은 치명적일 수 있는데요.
대다수의 수집 봇들이 자바스크립트를 실행하지 못하기 때문입니다. 렌더링된 페이지(HTML)에 대해서만 컨텐츠를 수집하기 때문에
클라이언트 사이드 렌더링을 사용하는 페이지를 빈 페이지로 인식할 수 있습니다.

다행히도 구글 크롤러의 경우 &amp;lt;script&amp;gt; 태그를 만나면 웹 브라우저같이 실제로 코드를 실행, DOM을 조작합니다.
구글 웹마스터 도구를 사용한다면 URL을 입력해서 구글 크롤러가 방문했을 때의 실제 페이지 모습을 확인할 수 있지요.

끝으로 많이 혼동된 부분이었던… 클라이언트 사이드 렌더링은 무조건 Single Page Application이 아니라
SPA가 클라이언트 사이드 렌더링을 사용한다는 것과 기존의 전통적인 웹 페이지 방식이 서버 사이드 렌더링을 사용한다는 것!

해당 내용은

Adam Zerner - Client-side rendering vs. server-side rendering
을 참고하여 작성하였습니다.
</description>
        <pubDate>Mon, 26 Nov 2018 00:00:00 +0000</pubDate>
        <link>https://madplay.github.io/post/server-side-rendering-vs-client-side-rendering</link>
        <guid isPermaLink="true">https://madplay.github.io/post/server-side-rendering-vs-client-side-rendering</guid>
        
        <category>serverside</category>
        
        <category>clientside</category>
        
        <category>rendering</category>
        
        <category>SPA</category>
        
        
        <category>Knowledge</category>
        
      </item>
    
  </channel>
</rss>
