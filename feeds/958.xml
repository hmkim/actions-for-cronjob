<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	
xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
>

<channel>
	<title>KYU.IO 🌾</title>
	<atom:link href="https://kyu.io/ko/feed/" rel="self" type="application/rss+xml" />
	<link>https://kyu.io</link>
	<description>frontend javascript developer @nhn_ent • write sometimes • code everyday • dream always</description>
	<lastBuildDate>Tue, 25 Sep 2018 08:40:12 +0000</lastBuildDate>
	<language>ko-KR</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://i2.wp.com/kyu.io/wp-content/uploads/2018/04/icon1.png?fit=32%2C32&#038;ssl=1</url>
	<title>KYU.IO 🌾</title>
	<link>https://kyu.io</link>
	<width>32</width>
	<height>32</height>
</image> 
<site xmlns="com-wordpress:feed-additions:1">138652211</site>	<item>
		<title>넷플릭스 성능 케이스스터디</title>
		<link>https://kyu.io/ko/%eb%84%b7%ed%94%8c%eb%a6%ad%ec%8a%a4-%ec%84%b1%eb%8a%a5-%ec%bc%80%ec%9d%b4%ec%8a%a4%ec%8a%a4%ed%84%b0%eb%94%94/#utm_source=rss&#038;utm_medium=rss&#038;utm_campaign=%25eb%2584%25b7%25ed%2594%258c%25eb%25a6%25ad%25ec%258a%25a4-%25ec%2584%25b1%25eb%258a%25a5-%25ec%25bc%2580%25ec%259d%25b4%25ec%258a%25a4%25ec%258a%25a4%25ed%2584%25b0%25eb%2594%2594</link>
				<comments>https://kyu.io/ko/%eb%84%b7%ed%94%8c%eb%a6%ad%ec%8a%a4-%ec%84%b1%eb%8a%a5-%ec%bc%80%ec%9d%b4%ec%8a%a4%ec%8a%a4%ed%84%b0%eb%94%94/#respond</comments>
				<pubDate>Thu, 22 Nov 2018 12:39:04 +0000</pubDate>
		<dc:creator><![CDATA[kyuwoo.choi]]></dc:creator>
				<category><![CDATA[번역]]></category>
		<category><![CDATA[프로그래시브 웹 앱]]></category>
		<category><![CDATA[자바스크립트]]></category>
		<category><![CDATA[전체]]></category>
		<category><![CDATA[리엑트]]></category>
		<category><![CDATA[서버 사이드 랜더링]]></category>
		<category><![CDATA[성능]]></category>
		<category><![CDATA[웹팩]]></category>
		<category><![CDATA[prefetching]]></category>
		<category><![CDATA[PWA]]></category>
		<category><![CDATA[Time-to-Interactive]]></category>

		<guid isPermaLink="false">https://kyu.io/?p=779</guid>
				<description><![CDATA[<p>웹 성능 개선에 왕도는 없다. 간단한 정적 페이지들은 최소한의 자바스크립트만 포함하도록 서버 렌더링할 수 있다. 신중하게 사용된 라이브러리들의 가치는 페이지가 복잡할때 빛을 발한다.</p>
<p>The post <a rel="nofollow" href="https://kyu.io/ko/%eb%84%b7%ed%94%8c%eb%a6%ad%ec%8a%a4-%ec%84%b1%eb%8a%a5-%ec%bc%80%ec%9d%b4%ec%8a%a4%ec%8a%a4%ed%84%b0%eb%94%94/">넷플릭스 성능 케이스스터디</a> appeared first on <a rel="nofollow" href="https://kyu.io/ko">KYU.IO 🌾</a>.</p>
]]></description>
								<content:encoded><![CDATA[
<blockquote class="wp-block-quote"><p>원문 :&nbsp;<a href="https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9">https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9</a></p></blockquote>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2><a href="https://github.com/nhnent/fe.javascript/wiki/%23184:-%EB%84%B7%ED%94%8C%EB%A6%AD%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4%EC%8A%A4%ED%84%B0%EB%94%94#netflixcom-%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%86%B1-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90%EC%84%9C-time-to-interactive-%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0"></a>Netflix.com 데스크톱 브라우저에서 Time-To-Interactive 개선하기</h2>



<p><strong>tl;dr: 웹 성능 개선에 왕도는 없다. 간단한 정적 페이지들은 최소한의 자바스크립트만 포함하도록 서버 렌더링할 수 있다. 신중하게 사용된 라이브러리들의 가치는 페이지가 복잡할때 빛을 발한다.</strong></p>



<p><a href="https://netflix.com/">Netflix</a>는 아주 유명한 비디오 스트리밍 서비스이다. 2016년 글로벌 출시 이후신규 가입자들이 많이 늘어났다. 이들은 모바일 페이지에서 회원 가입을 하거나 비디오 스트리밍에 적합하지 않은 환경에서도 접속했다.</p>



<p>개발자 팀은 Netflix.com 회원가입 과정에 사용되는 자바스크립트를 최적화 하고 프리패치(prefetch) 기술을 적용했다. 그 덕에 모바일과 데스크톱 사용자 모두에게 더 나은 사용자 경험을 제공할 수 있었다.</p>



<ul><li><strong>로딩 시간과 Time-to-Interactive가 50% 감소(Netflix.com의 데스크톱 홈페이지)</strong></li><li><strong>React와 클라이언트 측 라이브러리들을 순수(vanilla) 자바스크립트로 변경하여, 자바스크립트 번들 크기 200kB 감소. React는 서버 측에서 여전히 쓰임.</strong></li><li><strong>HTML, CSS, 자바스크립트(React)를 미리 다운로드하여(prefetch), 다른 페이지들의&nbsp;<a href="https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive">Time-to-Interactive</a>&nbsp;30% 감소</strong></li></ul>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2><a href="https://github.com/nhnent/fe.javascript/wiki/%23184:-%EB%84%B7%ED%94%8C%EB%A6%AD%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4%EC%8A%A4%ED%84%B0%EB%94%94#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EB%8D%94-%EC%A0%81%EA%B2%8C-%EB%A7%8C%EB%93%A4%EC%96%B4-time-to-interactive-%EC%A4%84%EC%9D%B4%EA%B8%B0"></a>자바스크립트를 더 적게 만들어 Time-to-Interactive 줄이기</h2>



<p>Netflix 개발자들은 사용자들이 가입하거나 로그인하는(로그인 정보가 없을 시 보이는) 홈페이지의 성능을 최적화했다.</p>



<blockquote class="wp-block-quote"><p>역자주: 이후 표현을 해치지 않는 범위에서&nbsp;<em>logged-out homepage</em>를&nbsp;<em>홈페이지</em>로 줄여 쓰겠다.</p></blockquote>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/02af9b513c5d2f13f301156fc75a8cc1d5cf6471/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a545f624a61506d6e42374d75793156773637434271672e706e67" alt=""/><figcaption><em>새로운 사용자 혹은 로그인하지 않은 사용자를 위한 Netflix.com 홈페이지</em></figcaption></figure>



<p>이 페이지는 초기 300kB의 자바스크립트를 포함하고 있었다. React 그리고 Lodash처럼 유틸리티 같은 클라이언트 코드가 일부 있었고, React의 상태를 초기화(hydrate)하기 위한 데이터가 일부 있었다.</p>



<p>Netflix의 모든 웹페이지는 서버에서 React로 렌더링한 HTML이 전달되며, 이후 클라이언트 측 애플리케이션이 보내진다. 그렇기에 개발의 일관성을 위해 새로 개편될 홈페이지의 구조를 동일하게 유지하는 것이 중요했다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/010deaa6fccc9b34ad8af7c76489f96321d05cfc/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a4c61694d2d654257486e4c6c6f4f7076624d676777772e706e67" alt=""/><figcaption><em>일례로 홈페이지의 탭들은 React를 사용해 만들어진 컴포넌트이다</em></figcaption></figure>



<p>크롬의 개발자 도구와 Lighthouse에서 3G 연결을 시뮬레이션했더니, 홈페이지 로드에 7초가 걸렸다. 단순한 랜딩 페이지일 뿐인데 너무 긴 시간이 걸린다. 이로써 개선될 여지가 확인되었다. 몇 가지 성능 감사 도구를 사용했더니 클라이언트에서 사용할 자바스크립트의&nbsp;<a href="https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4">비용</a>이 매우 높았다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/af9e6700b6d4458869115812fe7c6c13be582bb5/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a396c47545879656978567337503163424c3170374e412e706e67" alt=""/><figcaption><em>최적화 이전의 Netflix.com를 느린 3G 환경으로 제한한 크롬 개발자 도구</em></figcaption></figure>



<p>브라우저의 자바스크립트를 비활성화한 상태로 사이트의 어떤 요소가 동작하는지 살펴보는 방법으로, 홈페이지가 동작하는 데 정말 React가 필요한지 확인할 수 있었다.</p>



<p>이 페이지 요소 대부분은 기본적인 HTML이었기에, 자바스크립트 클릭 처리나 class를 추가하는 일 따위의 나머지 요소들은 순수 자바스크립트로 대체할 수 있었다. 또한 원래 React로 만들었던 언어 전환 기능은 300줄도 되지 않는 순수 자바스크립트로 다시 만들었다.</p>



<p>순수 자바스크립트로 전환한 전체 컴포넌트 리스트는 다음과 같다.</p>



<ul><li>기본적인 상호작용 (홈페이지 중간의 탭들)</li><li>언어 전환 기능</li><li>쿠키 배너 (미국 이외의 방문자 대상)</li><li>분석을 위한 클라이언트 측 로깅</li><li>성능 측정과 로깅</li><li>광고 속성 픽셀 부트스트랩 코드 (보안상 iFrame에서 샌드박스 처리됨)</li></ul>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/4f8ca02d03e1913ee59df8620fb266aaa344480b/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a7742675359755a6d6a6247503334424a6952534554772e6a706567" alt=""/></figure>



<p>React의 자체 용량은 45kB에 불과했지만, React, 몇몇 라이브러리, 그리고 이를 사용하는 앱 코드를 클라이언트에서 제거했더니 모두 200kB가 넘는 자바스크립트가 줄어들었다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/4e8f31f84f02d0cfeb790dba4d7e4b666e64f04b/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a7a643951545642744e32786d725a39347334545959412e6a706567" alt=""/></figure>



<p><em>클라이언트에서 React, Lodash 등의 라이브러리 삭제 전/후 페이로드 비교</em></p>



<p><a href="https://developers.google.com/web/fundamentals/performance/speed-tools/#lab_data">실험실</a>&nbsp;환경에서는&nbsp;<a href="https://developers.google.com/web/tools/lighthouse/">Lighthouse</a>(<a href="https://www.webpagetest.org/lighthouse.php?test=180822_M4_a5899bc8928b958d06902161c15b2c86&amp;run=2">추적 데이터</a>)를 사용해 사용자들이 Netflix 홈페이지를 빠르게 사용(Time-to-Interactive)할 수 있음을 확인할 수 있었다. 데스크톱 TTI는 3.5초 미만.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/d64a1690d5f5ccffac52e0573c7c54450692659d/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a78766945545a683449444b785435785f6b32753863672e706e67" alt=""/><figcaption><em>Time-to-Interactive 최적화한 이후 Lighthouse 보고서</em></figcaption></figure>



<p>그렇다면 실제 환경에서는?&nbsp;<a href="https://developers.google.com/web/tools/chrome-user-experience-report/">Chrome User Experience report</a>를 보면 97%의 데스크톱 Netflix 사용자들에게&nbsp;<a href="https://developers.google.com/web/updates/2018/05/first-input-delay">첫 입력 지연(First Input Delay)</a>이&nbsp;<a href="https://bigquery.cloud.google.com/savedquery/920398604589:1692b8e0bdc94d4883437d8712cbb83a">빠르다</a>는 것을 확인할 수 있다. 첫 입력 지연이란 사용자가 첫 동작을 시작한 순간부터 브라우저가 그 동작에 응답한 순간까지를 뜻한다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/aa8a89e9517488a88d8b7564f5f574a48cc6cd96/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a47786b6c356c6979632d744937576837555474446c512e706e67" alt=""/><figcaption><em>첫 입력 지연(FID)은 사용자가 페이지에서 느끼는 상호작용 지연을 측정한다.</em></figcaption></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2><a href="https://github.com/nhnent/fe.javascript/wiki/%23184:-%EB%84%B7%ED%94%8C%EB%A6%AD%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4%EC%8A%A4%ED%84%B0%EB%94%94#%EC%9D%B4%EC%96%B4%EC%A7%80%EB%8A%94-%ED%8E%98%EC%9D%B4%EC%A7%80%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-react-%EB%AF%B8%EB%A6%AC-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0"></a>이어지는 페이지에서 사용되는 React 미리 가져오기</h2>



<p>홈페이지를 방문할 성능을 더욱 개선하기 위해, 사용자들이 랜딩 페이지에서 보내는 시간을 그들이 방문할만한 페이지의 리소스를&nbsp;<strong>미리 가져오도록(prefetch)</strong>&nbsp;활용했다.</p>



<p>이는 브라우저 API인&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Link_prefetching_FAQ">&lt;link rel=prefetch&gt;</a>&nbsp;그리고 XHR 를 사용해 미리 가져오는 2가지 방법을 통해 가능했다.</p>



<p>브라우저에 포함된 이 API는 페이지의 head 태그 안에 간단한 link 태그로 되어있다. 이것은 브라우저에 그 리소스(HTML, 자바스크립트, CSS, 이미지 같은)가 미리 가져올 수 있는 것이라 알려주지만, 브라우저가 실제로 그 리소스를 미리 가져온다고 보장할 수는 없다. 또한 완벽히 지원하지 않는&nbsp;<a href="https://caniuse.com/#feat=link-rel-prefetch">다른 브라우저들</a>도 있다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/6467218cd997b7fcfade77be0646228b4a2acfc2/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a544176395f6a5a47716d582d61544a773551447452412e6a706567" alt=""/><figcaption><em>미리 가져오는 방법 비교</em></figcaption></figure>



<p>그에 반해 XHR로 미리 가져오는 방법은 수년간 브라우저의 표준이었고, 브라우저가 리소스를 캐시 하도록 했을 때 95%의 성공확률을 보였다. XHR로 미리 가져오는 방법을 HTML 문서에 사용할 수는 없지만, Netflix는 이어지는 페이지의 자바스크립트와 CSS를 미리 가져오는 데 사용했다.</p>



<p>주의: Netflix의 HTTP 응답 설정은 HTML을 XHR로 캐싱하지 못하도록 하고 있다(두 번째 페이지의 HTML에 no-cache 적용). Link를 사용한 미리 가져오는 방법은 HTML에서 동작하기 때문에 예상대로 동작했다. no-cache가 특정 포인트까지는 막는다고 하더라도 말이다.</p>



<pre class="wp-block-preformatted">// 새로운 XHR 요청 생성
const xhrRequest = new XMLHttpRequest();

// 리소스르 미리 가져오기 위해 요청 열기
xhrRequest.open('GET', '../bundle.js', true);

// 뿅!
xhrRequest.send();</pre>



<p>브라우저에 포함된 API(link)와 XHR를 사용해 HTML, CSS, 그리고 자바스크립트를 미리 가져왔더니, Time-to-Interactive 가 30% 줄었다. 이 구현방식은 자바스크립트를 재작성할 필요도 없었고, 홈페이지의 성능에 나쁜 영향을 주지도 않았다. 그러니 이는 아주 적은 위험으로 페이지 성능을 최적화하는 귀중한 도구라 하겠다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/6a7c00ea46bb7e30490ee0c2dde7e1af277e1ab5/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a7975736d6f5742626868667844457630334f575054512e6a706567" alt=""/></figure>



<p>미리 가져오기를 구현한 후, 크롬 개발자도구로 리소스의 캐시 적중과 페이지의 Time-to-Interactive 매트릭을 분석하여 향상 점들을 살펴봤다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2><a href="https://github.com/nhnent/fe.javascript/wiki/%23184:-%EB%84%B7%ED%94%8C%EB%A6%AD%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4%EC%8A%A4%ED%84%B0%EB%94%94#%EB%84%B7%ED%94%8C%EB%A6%AD%EC%8A%A4%EC%9D%98-%ED%99%88%ED%8E%98%EC%9D%B4%EC%A7%80---%EC%B5%9C%EC%A0%81%ED%99%94-%EC%9A%94%EC%95%BD"></a>넷플릭스의 홈페이지 &#8211; 최적화 요약</h2>



<p>리소르를 미리 가져오고 홈페이지의 클라이언트 코드를 최적화하여, 가입 과정의 Time-to-Interactive 매트릭스를 크게 개선 할 수 있었다. 브라우저에 포함된 API(link)와 XHR을 이용해 곧 방문할 페이지들을 미리 가져옴으로써, Time-to-Interactive를 30% 감소 시킬 수 있었다. 이는 가입 절차 single-page 앱에 사용되는 부트스트래핑 코드를 포함한 두 번째 페이지를 위한 일이었다.</p>



<p>Netflix팀의 코드 최적화는 React가 유용한 라이브러리이기는 하지만, 모든 문제에 대한 만능 해결책은 아니라는 점을 보여주었다. 첫 랜딩 페이지의 클라이언트 코드에서 React를 제거하여, Time-to-Interactive가 50% 넘게 개선되었다. 클라이언트의 Time-to-Interactive를 줄였더니 사용자들이 가입 버튼을 더 많이 누르게 되었고, 이는 코드 최적화가 더 나은 사용자 경험을 이끈다는 것을 의미한다.</p>



<p>Netflix는 홈페이지에서 React를 사용하지 않지만, 이후 페이지를 위해 미리 다운로드 한다. 이는 이후 가입 프로세스 single-page React 애플리케이션의 디딤돌이 될 수 있었다.</p>



<p>이 최적화에 대한 보다 자세한 내용은 Tony Edwards의 훌륭한 연설을 보시라.</p>



<figure class="wp-block-image"><a href="https://www.youtube.com/watch?v=V8oTJ8OZ5S0&amp;feature=youtu.be"><img src="https://i0.wp.com/user-images.githubusercontent.com/1215767/48669183-51f24180-eb42-11e8-894c-07defb2fdb1c.png?w=720&#038;ssl=1" alt="image.png" data-recalc-dims="1"/></a></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2><a href="https://github.com/nhnent/fe.javascript/wiki/%23184:-%EB%84%B7%ED%94%8C%EB%A6%AD%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4%EC%8A%A4%ED%84%B0%EB%94%94#%EA%B2%B0%EB%A1%A0"></a>결론</h2>



<p>Netflix는 자바스크립트의 비용을 주의 깊게 살펴, Time-to-Interactive를 개선 할 기회를 발견했다. 여러분의 사이트에 개선의 여지가 있는지 알아보려면&nbsp;<a href="https://developers.google.com/web/fundamentals/performance/speed-tools/">성능 도구들</a>을 사용해보자.</p>



<p>Netflix가 내린 절충안은 React로 랜딩 페이지를 서버에서 렌더링하고, 그사이 React와 이후 가입 절차 코드를 미리 가져오기로 한 것이다. 이는 첫 로딩 성능뿐 아니라 single-page로서 훨씬 커다란 자바스크립트 번들을 포함한 가입 절차를 로딩하는 시간도 최적화했다.</p>



<p>여러분 사이트의 흐름에도 순수 자바스크립트를 활용할 수 있는지 고민해보자. 반드시 라이브러리를 사용해야 한다면 방문자가 필요로 하는 코드만 다운로드 시키려 노력하자. 미리 다운로드 시키는 방법 등은 이후 페이지의 로딩 시간을 개선하는데 도움이 된다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3><a href="https://github.com/nhnent/fe.javascript/wiki/%23184:-%EB%84%B7%ED%94%8C%EB%A6%AD%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4%EC%8A%A4%ED%84%B0%EB%94%94#%EC%B6%94%EA%B0%80-%EC%82%AC%ED%95%AD"></a>추가 사항</h3>



<ul><li><a href="https://preactjs.com/">Preact</a>&nbsp;사용도 고려했었지만, 상호작용이 적은 간단한 페이지 흐름에선 순수 자바스크립트를 사용하는 것이 나은 선택이었다.</li><li>정적 자원 캐싱을 위한&nbsp;<a href="https://developers.google.com/web/fundamentals/primers/service-workers/">Service Workers</a>를 시험해보았지만, 그때는 Safari가 지원하지 않았었다. 지금은 지원하므로 다시 시도해보고 있다. 멤버들이 사용하는 페이지보다도 가입 절차 페이지는 더 넓은 구형 브라우저를 지원해야 한다. 많은 사용자는 오래된 브라우저에서 가입하고, 모바일 앱이나 TV를 사용해 시청한다.</li><li>랜딩 페이지는 꽤 동적이다. 가입 흐름 중에서 랜딩 페이지는 가장 많은 A/B 테스트를 거친 페이지다. 랜딩 페이지의 메시지, 이미지는 머신러닝 모델에 따라 사용자의 위치나 기기 유형등의 여러 요인을 사용하여 커스터마이징 된다. 거의 200개국을 지원하는데, 이러한 파생마다 다른 지역, 법률, 그리고 가치 전달을 위한 도전이 있다. A/B 테스트에 대한 이야기는 Ryan Burgess의&nbsp;<a href="https://www.youtube.com/watch?v=TmhJN6rdm28">더 나은 사용자 경험을 위한 테스팅(Testing Into A Better User Experience)</a>을 보자.</li></ul>



<p><em>리뷰와 이바지 해준 Netflix UI 엔지니어들,&nbsp;<a href="https://twitter.com/tedwards947">Tony Edwards</a>,&nbsp;<a href="https://twitter.com/burgessdryan">Ryan Burgess</a>,&nbsp;<a href="https://twitter.com/holtbt?lang=en">Brian Holt</a>,&nbsp;<a href="https://twitter.com/JemYoung?lang=en">Jem Young</a>,&nbsp;<a href="https://twitter.com/kristoferbaxter">Kristofer Baxter</a>&nbsp;(Google),&nbsp;<a href="https://twitter.com/stubbornella">Nicole Sullivan</a>&nbsp;(Chrome) and&nbsp;<a href="https://twitter.com/hdjirdeh">Houssein Djirdeh</a>&nbsp;(Chrome) 에 감사의 말을 전한다.</em></p>
<p>The post <a rel="nofollow" href="https://kyu.io/ko/%eb%84%b7%ed%94%8c%eb%a6%ad%ec%8a%a4-%ec%84%b1%eb%8a%a5-%ec%bc%80%ec%9d%b4%ec%8a%a4%ec%8a%a4%ed%84%b0%eb%94%94/">넷플릭스 성능 케이스스터디</a> appeared first on <a rel="nofollow" href="https://kyu.io/ko">KYU.IO 🌾</a>.</p>
]]></content:encoded>
							<wfw:commentRss>https://kyu.io/ko/%eb%84%b7%ed%94%8c%eb%a6%ad%ec%8a%a4-%ec%84%b1%eb%8a%a5-%ec%bc%80%ec%9d%b4%ec%8a%a4%ec%8a%a4%ed%84%b0%eb%94%94/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">779</post-id>	</item>
		<item>
		<title>Pinterest 프로그래시브 웹 앱 성능 케이스 스터디</title>
		<link>https://kyu.io/ko/pinterest-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9-%ec%95%b1-%ec%84%b1%eb%8a%a5-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94/#utm_source=rss&#038;utm_medium=rss&#038;utm_campaign=pinterest-%25ed%2594%2584%25eb%25a1%259c%25ea%25b7%25b8%25eb%259e%2598%25ec%258b%259c%25eb%25b8%258c-%25ec%259b%25b9-%25ec%2595%25b1-%25ec%2584%25b1%25eb%258a%25a5-%25ec%25bc%2580%25ec%259d%25b4%25ec%258a%25a4-%25ec%258a%25a4%25ed%2584%25b0%25eb%2594%2594</link>
				<comments>https://kyu.io/ko/pinterest-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9-%ec%95%b1-%ec%84%b1%eb%8a%a5-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94/#respond</comments>
				<pubDate>Sat, 03 Nov 2018 19:54:03 +0000</pubDate>
		<dc:creator><![CDATA[kyuwoo.choi]]></dc:creator>
				<category><![CDATA[번역]]></category>
		<category><![CDATA[프로그래시브 웹 앱]]></category>
		<category><![CDATA[자바스크립트]]></category>
		<category><![CDATA[전체]]></category>
		<category><![CDATA[리덕스]]></category>
		<category><![CDATA[리엑트]]></category>
		<category><![CDATA[서비스 워커]]></category>
		<category><![CDATA[성능]]></category>
		<category><![CDATA[성능 예산]]></category>
		<category><![CDATA[웹팩]]></category>
		<category><![CDATA[코드 분할]]></category>
		<category><![CDATA[PWA]]></category>

		<guid isPermaLink="false">https://kyu.io/?p=762</guid>
				<description><![CDATA[<p>Pinterest가 모바일 하드웨어에서도 빠르게 로드될 수 있도록 자바스크립트를 가볍게 하고, 네트워크 탄력성을 가질 수 있도록 서비스 워커(Service Worker)를 도입한 것에 대해 다룬다.</p>
<p>The post <a rel="nofollow" href="https://kyu.io/ko/pinterest-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9-%ec%95%b1-%ec%84%b1%eb%8a%a5-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94/">Pinterest 프로그래시브 웹 앱 성능 케이스 스터디</a> appeared first on <a rel="nofollow" href="https://kyu.io/ko">KYU.IO 🌾</a>.</p>
]]></description>
								<content:encoded><![CDATA[
<blockquote class="wp-block-quote"><p>원글:&nbsp;<a href="https://medium.com/dev-channel/a-pinterest-progressive-web-app-performance-case-study-3bd6ed2e6154">https://medium.com/dev-channel/a-pinterest-progressive-web-app-performance-case-study-3bd6ed2e6154</a></p></blockquote>



<p>Pinterest는 새로이&nbsp;<a href="https://developers.google.com/web/progressive-web-apps/">Progressive Web App</a>을 출시했다. 이 글은 Pinterest가 모바일 하드웨어에서도 빠르게 로드될 수 있도록 자바스크립트를 가볍게 하고, 네트워크 탄력성을 가질 수 있도록 서비스 워커(Service Worker)를 도입한 것에 대해 다루겠다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/a4f97b4e6298848d1fac3955a3875e1da0991bf3/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313030302f312a376d55784667354b755964656e475a487032334d74412e706e67" alt=""/><figcaption><em>Pinterest의 새로운 모바일 사이트를 확인하고 싶다면 휴대폰으로&nbsp;<a href="https://pinterest.com/">https://pinterest.com</a>를 확인하자.</em></figcaption></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2><a href="https://github.com/nhnent/fe.javascript/wiki/%23177-:-Pinterest-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EC%8B%9C%EB%B8%8C-%EC%9B%B9-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%84%B0%EB%94%94#%EC%99%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EC%8B%9C%EB%B8%8C-%EC%9B%B9-%EC%95%B1%EC%9D%B8%EA%B0%80"></a>왜 프로그래시브 웹 앱인가?</h2>



<p>Pinterest는 해외 시장의 성장에 초점을 맞추었고, 모바일 웹을 만들면서 PWA를 시작했다.</p>



<p>사이트에 로그인하지 않은 사용자의 패턴을 분석해본 결과, Pinterest의 오래되고 느린 사이트는 1%만이 가입, 로그인하거나 모바일 앱 인스톨을 하고 있다는 점을 알게 되었다. 이 전환율을 개선할 잠재력은 어마어마했고, PWA에 투자하게 되었다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3><a href="https://github.com/nhnent/fe.javascript/wiki/%23177-:-Pinterest-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EC%8B%9C%EB%B8%8C-%EC%9B%B9-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%84%B0%EB%94%94#3%EB%8B%AC%EC%95%88%EC%97%90-pwa%EB%A7%8C%EB%93%A4%EC%96%B4-%EB%82%B4%EB%B3%B4%EB%82%B4%EA%B8%B0"></a>3달안에 PWA만들어 내보내기</h3>



<p>Pinterest는&nbsp;<strong>3달간</strong>&nbsp;React, Redux, 그리고 Webpack을 사용하여 새로운 모바일 웹 사이트로 재구성했다. 새로 단장한 모바일 웹 사이트는 몇몇 핵심적인 사업 수치를 긍정적으로 개선했다.</p>



<p>기존 모바일 웹 사이트에 비교해 사용자는&nbsp;<strong>40%</strong>&nbsp;오래 머물렀고, 이로 인한 광고 수익은&nbsp;<strong>44%</strong>&nbsp;증가했으며, 핵심 관여도(core engagement)는&nbsp;<strong>60%</strong>&nbsp;증가했다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/4798e2c43d26b24fbdd7bd51b052141403ac8e57/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313030302f312a52674e4d4d7476656775395a694234584562475479672e706e67" alt=""/></figure>



<p>성능도 여러 측면 개선되었다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2><a href="https://github.com/nhnent/fe.javascript/wiki/%23177-:-Pinterest-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EC%8B%9C%EB%B8%8C-%EC%9B%B9-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%84%B0%EB%94%94#%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-3g-%EB%AA%A8%EB%B0%94%EC%9D%BC-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%EC%97%90%EC%84%9C-%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EB%A1%9C%EB%94%A9%ED%95%98%EA%B8%B0"></a>일반적인 3G 모바일 하드웨어에서 빠르게 로딩하기</h2>



<p>Pinterest의 이전 모바일 웹 사이트는 하나의 둔탁한 덩어리로 되어있었는데, 여기에는 Pin 페이지들이&nbsp;<a href="https://medium.com/dev-channel/the-cost-of-javascript-84009f51e99e">얼마나 빠르게 로드되어 동작될 수 있을지를 결정할</a>&nbsp;CPU를 잡아먹는 거대한 자바스크립트 번들들이 포함되어있었다.</p>



<p>방문자들은 종종 어떤 UI도 동작하지 않는 페이지를&nbsp;<strong>23초</strong>간 기다려야 했다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/0ea153eaab661a0f337735e5f4e386b9393e3295/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313030302f312a6e4751614967704a5f457941565269726653323271672e706e67" alt=""/><figcaption><em>Pinterest의 기존 모바일 사이트를 사용하기 위해서는 23초가 걸렸다. 2.5MB(메인 번들 ~1.5MB, 레이지 로딩하는 1MB) 자바스크립트를 다운로드 시켰는데, 메인 스레드가 이를 파싱하고 컴파일을 마쳐 화면이 동작하기 까지는 수 초의 시간이 필요했다.﻿</em></figcaption></figure>



<p>자바스크립트를 자르고 수백 KB를 깎아내어 핵심 번들의 크기를 650KB에서 150KB로 줄였을 뿐 아니라, 주요 성능 지표도 개선했다.&nbsp;<a href="https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint">첫 의미 있는 페인트(First Meaningful Paint)</a>는 4.2초를 1.8초로, 화면이&nbsp;<a href="https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive">동작하기까지 걸리는 시간(Time To Interactive)</a>은 23초를 5.6초로 줄였다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/f00d690f5b39dcc51dc007dbeaa71b792713e89e/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313030302f312a39765550425159786d344c4576694b3074384e7039512e706e67" alt=""/></figure>



<p>일반적인 3G 안드로이드 기준이며, 재방문 시에는 이보다 훨씬 빠르다.</p>



<p>Service Worker를 사용해 자바스크립트, CSS, 그리고 정적 UI 에셋들을 캐싱하여, 재방문 시 동작하기까지 걸리는 시간을 3.9초까지 떨어뜨릴 수 있었다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/c6848218e1ca05000b74fa579e0adeae1e439456/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313030302f312a4e554947625a63504a516b4749683132313872794b772e706e67" alt=""/></figure>



<p>Pinterest가 비록 iOS &amp; Android 앱을 출시했지만, 네이티브 앱과 동일한 중요 홈 피드 페이지를 낮은 다운로드 비용(150KB 이하로 미니파이되고 압축되었다)으로 웹에서도 제공할 수 있게 되었다. 이는 동일한 페이지를 제공하는데 안드로이드에서 9.6MB, iOS에서 56MB가 필요한 것과 비교하면 확실히 눈에 띈다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/1a5bf87e54accd1a69fe437fe4e6637e6feb3b5d/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313030302f312a436f43384f61364a6a41354b5658326c4e6b746431512e706e67" alt=""/></figure>



<p>물론 이는 공평한 비교가 될 수는 없다. PWA는 새로운 경로가 요청됨에 따라 코드를 로드하고, 이 추가적인 코드 비용은 애플리케이션을 사용함에 따라 증가한다. 추가적으로 발생한 데이터 비용은 여전히 앱을 다운로드하는 것보다는 작다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/cfcb3c13a85abb3f37ec92ff1bb051c6b92aa3e3/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a5557326b3545586a45673548537868385775337651412e706e67" alt=""/><figcaption><em>파이어폭스, 엣지, 사파리 모바일에서의 Pinterest 프로그래시브 웹 앱</em></figcaption></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2><a href="https://github.com/nhnent/fe.javascript/wiki/%23177-:-Pinterest-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EC%8B%9C%EB%B8%8C-%EC%9B%B9-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%84%B0%EB%94%94#%EA%B2%BD%EB%A1%9C-%EA%B8%B0%EB%B0%98-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%B6%84%ED%95%A0"></a>경로 기반 자바스크립트 분할</h2>



<p><strong>방문자가 선제적으로 필요한 코드만 로드</strong>하도록 하면 동작하기까지 걸리는 시간을 줄일 수 있다. 이는&nbsp;<strong>네트워크 전송과 자바스크립트 파싱/컴파일 시간</strong>을 줄인다. 핵심 리소스가 아닌 것들은 필요에 따라 나중에 로드(lazy load) 할 수 있다.</p>



<p>수 메가 바이트의 자바스크립트 번들을 3가지 카테고리 Webpack 조각들(chunk)로 쪼갰더니 꽤 괜찮았다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/3e84170a823b0ab1024af349fc06f967983da6e6/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313030302f312a357672396d7a646e5449695753334e374778627878412e706e67" alt=""/></figure>



<ul><li><strong>vendor</strong>조각은 벤더 코드 조각(외부에서 가져온 라이브러리들: react, redux, react-router 등) 포함한다. ~ 73KB</li><li><strong>entry</strong>조각은 앱을 그리는데 필요한(예를 들면 공통 라이브러리, 페이지의 골격, redux store) 대부분의 코드를 포함한다. ~ 72KB</li><li><strong>async</strong>경로 조각은 각각의 경로에 속한 코드를 포함한다. ~ 13-18KB</li></ul>



<p>위의 결과를 아래의 네트워크 디버깅 도구로 확인하자. 필요한 코드를 점진적으로 제공하는 방식으로의 전환은 거대한 번들 덩어리들이 필요치 않음을 잘 보여준다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/47abc330ef63a624c816ef670887063d0a90572f/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f302a567575653948773269486b4f7435506d2e" alt=""/><figcaption>장기 캐싱을 위해, 각 파일 이름 마다 파일 내용에 따른 해시를 사용하기도 한다.&nbsp;</figcaption></figure>



<p>벤더 번들(vendor bundle)은 Webpack의&nbsp;<a href="https://webpack.js.org/plugins/commons-chunk-plugin/">CommonsChunkPlugin</a>를 사용해 아래처럼 각자 캐쉬 될 수 있는 조각으로 나눈다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler"><div class="wp-block-embed__wrapper">
View the code on <a href="https://gist.github.com/zackargyle/03bf9415585e74a090b6d6c43c104a79">Gist</a>.
</div></figure>



<p><a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/docs/guides/code-splitting.md">코드 분할(code-splitting)</a>을 추가하기 위해&nbsp;<a href="https://github.com/ReactTraining/react-router">React Router</a>도 사용한다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler"><div class="wp-block-embed__wrapper">
View the code on <a href="https://gist.github.com/zackargyle/5d91614739a12c5d5e77c5ebfb29de2c">Gist</a>.
</div></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2><a href="https://github.com/nhnent/fe.javascript/wiki/%23177-:-Pinterest-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EC%8B%9C%EB%B8%8C-%EC%9B%B9-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%84%B0%EB%94%94#%EB%8C%80%EC%83%81-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90-%EB%A7%9E%EB%8A%94-%ED%8A%B8%EB%9E%9C%EC%8A%A4%ED%8C%8C%EC%9D%BC%EB%A7%8C-%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%B4-babel-preset-env-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0"></a>대상 브라우저에 맞는 트랜스파일만 하기 위해 babel-preset-env 사용하기</h2>



<p>Pinterest는 레거시 브라우저는 지원하지 않기에,&nbsp;<a href="http://2ality.com/2017/02/babel-preset-env.html">babel-preset-env</a>을 사용하여 최신 브라우저에서 지원되지 않는 ES2015+ 문법만을 트랜스파일 한다. 최신 브라우저의 마지막 2개 버전 지원을 목표로 하며, .babelrc 설정은 아래와 같다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler"><div class="wp-block-embed__wrapper">
View the code on <a href="https://gist.github.com/addyosmani/8ab162aa3df26ab9cd25ea035c7eddc0">Gist</a>.
</div></figure>



<p>조건에 따라 폴리필(polyfill)을 제공할 수 있도록 조금 더 최적화할 여지가 남아있다.(예를 들면&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl">Internationalization API</a>는 사파리 대상으로만 제공한다든지.) 물론 추후 개선될 것으로 계획되어 있다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3><a href="https://github.com/nhnent/fe.javascript/wiki/%23177-:-Pinterest-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EC%8B%9C%EB%B8%8C-%EC%9B%B9-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%84%B0%EB%94%94#webpack-bundle-analyzer%EB%A5%BC-%EC%8D%A8%EC%84%9C-%EA%B0%9C%EC%84%A0%EC%A0%90-%EC%B0%BE%EC%95%84%EB%82%B4%EA%B8%B0"></a>Webpack Bundle Analyzer를 써서 개선점 찾아내기</h3>



<p><a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">Webpack Bundle Analyzer</a>는 방문자에게 보내는 코드에 무엇들이 들어있는지 파악하기 정말 좋은 도구이다.</p>



<p>아래는 Pinterest의 초기 빌드 결과인데, 많은 수의 보라, 분홍, 파란색 블록들이 보인다. 이 블록들은 경로에 따라 지연 로드(lazy load) 되는&nbsp;<strong>비동기 코드 조각</strong>들이다. Webpack Bundle Analyzer는 이들 코드 조각들이&nbsp;<strong>중복된 코드</strong>를 포함하고 있음을 보여준다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/2b68b6be0647971d5b071359dfa121f18e3c152d/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313030302f312a776a5071524f3772777a37636b516353615f354174512e706e67" alt=""/></figure>



<p>Webpack Bundle Analyzer를 사용하면 문제가 되는 이 코드 조각들의 비율을 확인할 수 있다.</p>



<p>Pinterest는 이 중복 코드를 보고 나서 결정을 내릴 수 있었다.&nbsp;<strong>중복 코드들을 비동기 코드 조각에서 메인 코드 조각으로 옮기기로. 이 결과로, 초기에 필요한 코드 조각은 20% 증가했지만, 지연 로드 되는 코드 조각들은 최대 90%까지 줄였다!</strong></p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/94719bcbeb396cb6774b94079fba63df5dabb183/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313030302f312a7a633251586a43433257453459664c584a734b7942512e706e67" alt=""/></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2><a href="https://github.com/nhnent/fe.javascript/wiki/%23177-:-Pinterest-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EC%8B%9C%EB%B8%8C-%EC%9B%B9-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%84%B0%EB%94%94#%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%B5%9C%EC%A0%81%ED%99%94"></a>이미지 최적화</h2>



<p>Pinterest에서 지연 로드되는 콘텐츠의 대부분은&nbsp;<a href="https://masonry.desandro.com/">Masonry</a>&nbsp;Grid가 처리한다. Masonry Grid는 가상화를 통해 뷰포트 안에 있는 내용만 로드하는 기능을 가지고 있다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/f184807b848aaa826d0219b2e6524ff6b8c6515b/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313030302f312a33516330617246776c31776c4d4771616252576531512e706e67" alt=""/></figure>



<p>Pinterest는 PWA에 이미지를 점진적(Progressive)으로 로딩하는 기술 또한 사용한다. 각 Pin마다 많이 쓰이는 색상으로 placeholder를 만든다. Pin 이미지는&nbsp;<a href="https://images.guide/#jpeg-compression-modes">Progressive JPEGs</a>로 제공되는데, 매 스캔마다 이미지가 뚜렷해진다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/95a7bcc6043f1fd69a8f010325ed4d0b179c8ecd/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313030302f312a733535657334424252327457354f4a5a4e6734536d672e706e67" alt=""/></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2><a href="https://github.com/nhnent/fe.javascript/wiki/%23177-:-Pinterest-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EC%8B%9C%EB%B8%8C-%EC%9B%B9-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%84%B0%EB%94%94#react%EC%9D%98-%EC%84%B1%EB%8A%A5-%EB%AC%B8%EC%A0%9C"></a>React의 성능 문제</h2>



<p><a href="https://masonry.desandro.com/">Masonry</a>&nbsp;grid를 React와 사용하면서 성능 문제가 나타났다.&nbsp;<strong>Pin 같은 거대한 컴포넌트들을 올리고 내리는 일은 꽤 느렸다.</strong>&nbsp;아래서 보듯 Pin은 꽤 복잡한 컴포넌트다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/ae4f9bb11539188ee3a654bdc512388ef59833bb/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313030302f312a6c6437354e3479766d6c416b526b4e4d367361476f772e706e67" alt=""/></figure>



<p>Pinterest를 개발할 당시 React 15.5.4를 사용하고 있었지만,&nbsp;<a href="https://reactjs.org/blog/2017/09/26/react-v16.0.html">React 16</a>&nbsp;(Fiber)가 컴포넌트를 DOM에서 제거하는 성능이 개선되길 기대했다. React 16을 기다리는 동안은&nbsp;<strong>그리드를 가상화하여</strong>&nbsp;컴포넌트 제거에 걸리는 시간을 개선했다.</p>



<p>초기 Pin들을 빠르게 계산하고 그려내기 위해 DOM에 추가될 Pin들의 수를 제한하기도 했다. 하지만 이는 전체적으로 기기의 CPU가 할 일이 더 많다는 뜻이기도 하다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2><a href="https://github.com/nhnent/fe.javascript/wiki/%23177-:-Pinterest-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EC%8B%9C%EB%B8%8C-%EC%9B%B9-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%84%B0%EB%94%94#%EA%B2%BD%EB%A1%9C-%EC%A0%84%ED%99%98"></a>경로 전환</h2>



<p>체감 성능을 올리기 위해 경로와 상관없이 선택된 내비게이션 바의 아이콘을 먼저 업데이트한다. 경로를 전환하면서 생기는 네트워크로 인한 느린 느낌을 없애줄 수 있다. 방문자는 데이터가 도착할 때까지 기다릴 필요 없이 빠르게 업데이트된 UI를 볼 수 있다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/460854c5e370d7c3a06a120945861cb64cabcef5/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313030302f312a4b7961393734314d38736e67352d76617a5f2d6d65772e706e67" alt=""/></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2><a href="https://github.com/nhnent/fe.javascript/wiki/%23177-:-Pinterest-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EC%8B%9C%EB%B8%8C-%EC%9B%B9-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%84%B0%EB%94%94#redux%EB%A5%BC-%EC%8D%A8%EB%B3%B4%EB%8B%88"></a>Redux를 써보니</h2>



<p>Pinterest는 모든 API 데이터를 스키마에 따라 깊이가 있는 JSON을 정규화(normalize) 해주는&nbsp;<a href="https://github.com/paularmstrong/normalizr">normalizr</a>를 사용한다. Redux DevTools를 사용하면 아래처럼 보인다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/840584bbb8ae9770c94e70e5f52cb0aa17b64064/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a4b78496a6c5049664a7a754750444f666a50713263412e706e67" alt=""/></figure>



<p>이 방식은 역 정규화(정규화했던 데이터를 되돌리는 일: denormalization)가 느리기 때문에, 결국 이 일을 memoization 해주는&nbsp;<a href="https://github.com/reactjs/reselect">reselect</a>를 쓸 수밖에 없다는 단점이 있다. 또한 대규모의 재-랜더링을 막기 위해, 항상 가능한 말단의 데이터 단위로 처리했다.</p>



<p>예를 들면, 이 grid 아이템 리스트는 단지 Pin 아이디들이며, Pin 컴포넌트는 자체적 역 정규화한다. 어떠한 하나의 Pin이 변경되더라도, 전체 그리드를 새로이 랜더링 할 필요는 없다. 이 때문에 아주 많은 Redux subscriber가 생겨나긴 하지만, 딱히 눈에 보일만한 성능 문제를 야기하지는 않는다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2><a href="https://github.com/nhnent/fe.javascript/wiki/%23177-:-Pinterest-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EC%8B%9C%EB%B8%8C-%EC%9B%B9-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%84%B0%EB%94%94#service-worker%EB%A1%9C-%EC%97%90%EC%85%8B-%EC%BA%90%EC%8B%B1%ED%95%98%EA%B8%B0"></a>Service Worker로 에셋 캐싱하기</h2>



<p>Pinterest는 Service Worker들을 생성하고 관리하기 위해 Workbox 라이브러리들을 사용한다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler"><div class="wp-block-embed__wrapper">
View the code on <a href="https://gist.github.com/zackargyle/acb95e3a138c850e476cc9a769096990">Gist</a>.
</div></figure>



<p>cache-first 전략을 사용해 모든 JavaScript, CSS 번들을 캐싱 한다. application shell을 사용하여 사용자 인터페이스 또한 캐싱 한다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/64ccb6317413675f28239ea6f3521fad8419d0a7/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a64666f685268475a7048584e7a5a51644a76615244512e706e67" alt=""/><figcaption><em><strong>cache-first</strong>설정은, 요청이 캐시 되어 있으면 그것을 응답으로 한다. 캐시에 없는 경우 네트워크에서 리소스를 가져오려 시도한다. 네트워크 요청이 성공했다면 캐시를 업데이트한다. Service Worker의 캐싱 전략에 대해 더 알고 싶다면&nbsp;<a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/">Jake Archibald’s Offline Cookbook</a>를 읽자.</em></figcaption></figure>



<p>application shell이 로드하는 초기 번들(webpack runtime, 벤더 코드 조각들, 초기에 필요한 코드 조각들) 또한 선재 캐싱 한다.</p>



<p>Pinterest는 다국어 지원을 하는 세계적인 사이트인 만큼, 지역별로 번들을 미리 캐싱 하기 위해&nbsp;<strong>지역 단위 Service Worker 설정</strong>을 만든다. 최상위 비동기 경로 번들을 미리 캐싱 하기 위해 webpack named chunk 역시 사용한다.</p>



<p>이 작업은 여러차례 작은 단위로 적용되었다.</p>



<ul><li>Pinterest의 첫 번째 Service Worker는 단지&nbsp;<strong>요청에 따른 지연 로드 스크립트만 실시간 캐싱</strong>&nbsp;할 뿐이었다. 이는&nbsp;<a href="https://v8project.blogspot.com/2015/07/code-caching.html">V8’s code caching</a>으로 반복적인 화면을 빠르게 로드하기 위해서이다. Service Worker가 있는 Cache Storage에서 제공되는 스크립트들은 쉽게 코드 캐싱에 등록될 수 있다. 이 리소스들이 반복적인 화면에서 쓰인다는 것을 브라우저가 알아챌 가능성이 높기 때문이다.&nbsp;</li><li>다음으로&nbsp;<strong>벤더 코드 조각과 초기 코드 조각들을 선재 캐싱</strong>&nbsp;했다.</li><li>그리고&nbsp;<strong>가장 자주 방문되는 경로를 선재 캐싱</strong>&nbsp;했다.(홈페이지, pin 페이지, 검색 페이지 처럼)</li><li>마지막으로 지역별 번들을 캐싱 할 수 있도록&nbsp;<strong>각 지역에 맞는 Service Worker를 생성</strong>&nbsp;했다. 이는 로딩 성능을 위해서뿐만 아니라, 대부분의 방분자에게 기본적인 오프라인 렌더링을 지원하기 위해 중요한 일이다.</li></ul>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler"><div class="wp-block-embed__wrapper">
View the code on <a href="https://gist.github.com/zackargyle/8d716b8438c678dfa79123a586284c4b">Gist</a>.
</div></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2><a href="https://github.com/nhnent/fe.javascript/wiki/%23177-:-Pinterest-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EC%8B%9C%EB%B8%8C-%EC%9B%B9-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%84%B0%EB%94%94#application-shell%EC%97%90-%EB%8F%84%EC%A0%84"></a>Application Shell에 도전</h2>



<p>application shell을 구현하는 일은 좀 까다로웠다. 데스크톱이 주류를 이루는 시기에 케이블 연결을 통해 얼마나 데이터를 보낼 수 있는지 추정한 것 때문에, 초기 페이로드는 사용자 실험 그룹, 사용자 정보, 문맥 정보 따위의 별로 중요하지 않은 많은 정보들을 포함하느라 거대했다.</p>



<p>&#8220;이것들을 application shell에 캐싱 해야 하나? 아니면 이것들을 가져오기 위한 렌더링이 이루어지기 전까지 네트워크 요청을 차단하는 성능 제한을 감수해야 하나?&#8221;라는 고민을 해야만 했다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/616336ee3aba5c9a35ce5418cb4b9e297bfde380/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313030302f312a536f5f64484e5a4b6d66726250546b4377626e6734672e706e67" alt=""/></figure>



<p>방문자가 로그아웃할 때나 사용자 정보를 업데이트할 때처럼 app shell을 무효화할 시점에 관리가 필요하지만, Pinterest는 이 정보를 application shell에 캐싱 하기로 결정했다. 매 요청과 응답에&nbsp;<code>appVersion</code>을 추가해, 만약 app version이 변경되면 Service Worker를 등록 해지시키고, 새로운 Service Worker를 등록한다. 새로운 Service Worker를 등록하면, 경로 변경 시 전체 페이지를 새로 로드한다.</p>



<p>이 정보를 application shell에 추가하는 일은 좀 까다로웠지만, 렌더링을 막는 요청은 피하는 쪽이 좋다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2><a href="https://github.com/nhnent/fe.javascript/wiki/%23177-:-Pinterest-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EC%8B%9C%EB%B8%8C-%EC%9B%B9-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%84%B0%EB%94%94#lighthouse%EB%A1%9C-%EA%B0%90%EC%82%AC-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0"></a>Lighthouse로 감사 실행하기</h2>



<p>Pinterest는 성능 개선이 제 궤도에 이르고 있는지 검증하기 위해 한 차례씩&nbsp;<a href="https://github.com/GoogleChrome/lighthouse/">Lighthouse</a>를 썼다. 이는 Time to Consistently Interactive 같은 수치를 지속적으로 모니터링하기 유용한 도구다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/08c3e953d6209b508337e3f60509db636e3e61e7/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313030302f312a4c7a6557584976724c575439626c6e326d63706563512e706e67" alt=""/></figure>



<p>이듬해엔 Lighthouse를 페이지가 여전히 빠르게 로드되는지 회귀(regression) 방식으로 검증할 수 있길 기대하고 있다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2><a href="https://github.com/nhnent/fe.javascript/wiki/%23177-:-Pinterest-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EC%8B%9C%EB%B8%8C-%EC%9B%B9-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EC%BC%80%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%84%B0%EB%94%94#%EC%9D%B4%ED%9B%84%EC%97%94"></a>이후엔</h2>



<p>Pinterest just deployed support for Web Push notifications and have also been working on the unauthenticated (logged-out) experience for their PWA.</p>



<p>Pinterest는 최근 Web Push notification 기능을 배포했다. 또한 로그인하지 않는 경우도 PWA를 적용하는 작업을 하고 있다.</p>



<figure class="wp-block-image"><img src="https://camo.githubusercontent.com/83c3efc25b09df4693f9c035ce0fd49b14409015/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313030302f312a30356162336842684f664a6467735f44424d46624d672e706e67" alt=""/></figure>



<p>핵심적인 번들을 미리 로드하고 첫 방문 시 로드되는 JavaScript 중 안 쓰이는 코드를 줄이기 위해&nbsp;<a href="https://developers.google.com/web/fundamentals/performance/resource-prioritization">&lt;link rel=preload&gt;</a>&nbsp;도입을 검토하고 있다. 향후 있을 이들의 멋진 성능 개선 작업을 기대하시라!</p>



<p><em>Pinterest의 프로그래시브 웹 앱을 배포하고 이 글의 자료를 제공해준 Zack Argyle, YenWei Liu, Luna Ruan, Victoria Kwong, Imad Elyafi, Langtian Lang, Becky Stoneman 그리고 Ben Finkel에게 축하의 말을 전한다. 이 글을 리뷰해준 <a href="https://medium.com/@jeffposnick">Jeffrey Posnick</a> 와 <a href="https://medium.com/@_zouhir">Zouhir</a>는 고마워요.</em></p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>
<p>The post <a rel="nofollow" href="https://kyu.io/ko/pinterest-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9-%ec%95%b1-%ec%84%b1%eb%8a%a5-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94/">Pinterest 프로그래시브 웹 앱 성능 케이스 스터디</a> appeared first on <a rel="nofollow" href="https://kyu.io/ko">KYU.IO 🌾</a>.</p>
]]></content:encoded>
							<wfw:commentRss>https://kyu.io/ko/pinterest-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9-%ec%95%b1-%ec%84%b1%eb%8a%a5-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">762</post-id>	</item>
		<item>
		<title>Tinder의 프로그래시브 웹 앱 성능 케이스 스터디</title>
		<link>https://kyu.io/ko/tinder%ec%9d%98-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9-%ec%95%b1-%ec%84%b1%eb%8a%a5-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94/#utm_source=rss&#038;utm_medium=rss&#038;utm_campaign=tinder%25ec%259d%2598-%25ed%2594%2584%25eb%25a1%259c%25ea%25b7%25b8%25eb%259e%2598%25ec%258b%259c%25eb%25b8%258c-%25ec%259b%25b9-%25ec%2595%25b1-%25ec%2584%25b1%25eb%258a%25a5-%25ec%25bc%2580%25ec%259d%25b4%25ec%258a%25a4-%25ec%258a%25a4%25ed%2584%25b0%25eb%2594%2594</link>
				<comments>https://kyu.io/ko/tinder%ec%9d%98-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9-%ec%95%b1-%ec%84%b1%eb%8a%a5-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94/#respond</comments>
				<pubDate>Mon, 24 Sep 2018 12:40:53 +0000</pubDate>
		<dc:creator><![CDATA[kyuwoo.choi]]></dc:creator>
				<category><![CDATA[번역]]></category>
		<category><![CDATA[프로그래시브 웹 앱]]></category>
		<category><![CDATA[전체]]></category>
		<category><![CDATA[CSS]]></category>
		<category><![CDATA[성능]]></category>
		<category><![CDATA[성능 예산]]></category>
		<category><![CDATA[웹팩]]></category>
		<category><![CDATA[코드 분할]]></category>
		<category><![CDATA[PWA]]></category>

		<guid isPermaLink="false">https://kyu.io/?p=678</guid>
				<description><![CDATA[<p>Tinder는 최근 웹 앱을 출시했다. (swiped right: 아이폰의 밀어서 잠금 해제와, Tinder 앱에서 우측으로 밀어 마음에 드는 상대를 확인하는 것을 연상시키는 여러 가지 의도를 포함했다). Tinder Online은 새로운 반응형 프로그래시브 웹 앱(Progressive Web App)으로, 데스크탑과 모바일의 모든 사용자는 자바스크립트 성능 최적화, 네트워크 회복성을 위한 서비스 워커(Service Worker) 그리고 채팅 참여를 도울 푸시 알림(Push Notifications)이 주는 이점을 누리게 되었다. 오늘은 Tinder가 웹 성능에 대해 배운 것들 알아보자.</p>
<p>The post <a rel="nofollow" href="https://kyu.io/ko/tinder%ec%9d%98-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9-%ec%95%b1-%ec%84%b1%eb%8a%a5-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94/">Tinder의 프로그래시브 웹 앱 성능 케이스 스터디</a> appeared first on <a rel="nofollow" href="https://kyu.io/ko">KYU.IO 🌾</a>.</p>
]]></description>
								<content:encoded><![CDATA[
<blockquote class="wp-block-quote"><p>원글: https://medium.com/@addyosmani/a-tinder-progressive-web-app-performance-case-study-78919d98ece0</p></blockquote>



<p>Tinder는 최근 웹 앱을 출시했다. (swiped right: 아이폰의 밀어서 잠금 해제와, Tinder 앱에서 우측으로 밀어 마음에 드는 상대를 확인하는 것을 연상시키는 여러 가지 의도를 포함했다). <a href="https://tinder.com/">Tinder Online</a>은 새로운 반응형 <a href="https://developers.google.com/web/progressive-web-apps/">프로그래시브 웹 앱(Progressive Web App)</a>으로, 데스크탑과 모바일의 모든 사용자는 <a href="https://medium.com/dev-channel/the-cost-of-javascript-84009f51e99e">자바스크립트 성능 최적화</a>, 네트워크 회복성을 위한 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/">서비스 워커(Service Worker)</a> 그리고 채팅 참여를 도울 <a href="https://developers.google.com/web/fundamentals/push-notifications/">푸시 알림(Push Notifications)</a>이 주는 이점을 누리게 되었다. 오늘은 Tinder가 웹 성능에 대해 배운 것들 알아보자.</p>



<figure class="wp-block-image"><img src="https://i0.wp.com/cdn-images-1.medium.com/max/1000/1*1HmfQhMAQL8kukiNtMZRjA.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>프로그래시브 웹 앱으로의 여정</h3>



<p>Tinder Online은 새로운 시장(웹)에 진출하기 위해 시작되었고, 다른 플랫폼의 Tinder V1과 같은 수준의 사용자 경험을 전달하려 노력했다.</p>



<p><strong>UI를 <a href="https://reactjs.com/">React</a>로, <a href="https://redux.js.org/">Redux</a> 를 상태 관리로, 사용하는데 필요한 최소 기능(MVP)을 구현하는 데 3개월이 걸렸다.</strong> 데이터가 비싸거나 부족한 사람들이 10%의 데이터만으로 Tinder의 주요 기능을 사용할 수 있는 PWA가 이러한 노력으로 만들어졌다.</p>



<figure class="wp-block-image"><img src="https://i0.wp.com/cdn-images-1.medium.com/max/1000/1*cqYbI-L0zukfYS0ZAwUtqA.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/><figcaption>Tinder Online vs 네이티브 앱 데이터 소모 비교. 이것은 동등하게 비교할 수 있는 것이 아님을 말해두겠다. PWA는 새로운 경로가 요청될 때마다 드를 로드하며, 데이터 소모는 애플리케이션의 라이프사이클에 따라 데이터는 분할상환으로 증가된다. 그러나 이어지는 경로 전환에도 여전히 app 다운로드만큼 데이터 소모가 일어나지는 않는다.</figcaption></figure>



<p>상대를 선택하고 메세지를 보낸 횟수, 서비스에 머무른 시간만 봐도 PWA가 네이티브 앱보다 나아졌다는 것을 알 수 있다.</p>



<ul><li>사용자는 네이티브 앱보다 웹에서 이성을 더 많이 선택한다.</li><li>사용자는 네이티브 앱보다 웹에서 메시지를 더 많이 보낸다.</li><li>사용자는 네이티브 앱에서만큼 웹에서도 구매한다.</li><li>사용자는 네이티브 앱보다 웹에서 프로파일을 더 여러 번 수정한다.</li><li>네이티브 앱보다 웹의 세션 타임이 더 길다. (사용자가 더 오래 머문다.)<br/></li></ul>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>성능</h3>



<p>Tinder Online의 모바일 사용자들은 보통 다음과 같은 기기를 사용하고 있다.</p>



<ul>
	<li>Apple iPhone &amp; iPad</li>
	<li>Samsung Galaxy S8</li>
	<li>Samsung Galaxy S7</li>
	<li>Motorola Moto G4</li>
</ul>



<p>사용자 대부분이 4G로 접속한다는 것을 <a href="https://developers.google.com/web/tools/chrome-user-experience-report/">Chrome User Experience report</a> (CrUX)를 사용해 알아냈다.</p>



<figure class="wp-block-image"><img src="https://i2.wp.com/cdn-images-1.medium.com/max/1000/1*gO4n3kBs5Zy1eAkMQqxx7w.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/><figcaption><em>참고: Rick Viscomi는 최근 <a href="https://calendar.perfplanet.com/2017/finding-your-competitive-edge-with-the-chrome-user-experience-report/">PerfPlanet</a> 에선 CrUX를 다뤘고, 유명한 100만 개 사이트의 CrUX를 시각화한 <a href="https://calendar.perfplanet.com/2017/introducing-ruxt-visualizing-real-user-experience-data-for-1-2-million-websites/">rUXt</a>를 인도 출신 Parameshwaran가 소개했다.</em></figcaption></figure>



<p><a href="https://www.webpagetest.org/result/171224_ZB_13cef955385ddc4cae8847f451db8403/">WebPageTest</a>와 <a href="https://github.com/GoogleChrome/lighthouse/">Lighthouse</a> (Galaxy S7 / 4G 설정으로)로 테스트한 결과, <a href="https://developers.google.com/web/tools/lighthouse/audits/consistently-interactive">Consistently Interactive</a>(버튼을 누른다거나, 내용을 갱신하는 등 사용자 입력을 부드럽게 처리할 수 있게 된 시점)가 <strong>5초 이내</strong>였다.</p>



<div class="wp-block-image"><figure class="aligncenter"><img src="https://i0.wp.com/cdn-images-1.medium.com/max/1000/1*e-EHgbBBNXyuce8Z836Sgg.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure></div>



<p>물론 아래에서 보듯 CPU가 더욱 제한적인 <a href="https://www.webpagetest.org/lighthouse.php?test=171224_NP_f7a489992a86a83b892bf4b4da42819d&amp;run=3">평범한 핸드폰</a>(Moto G4 같은)에서는 이를 향상할 수 있는 <strong>여지가 많이 남아있다.</strong></p>



<figure class="wp-block-image"><img src="https://i1.wp.com/cdn-images-1.medium.com/max/1000/1*VJ3ZbSQtIjxsIW8Feuiejw.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure>



<p>Tinder는 최적화를 열심히 하고 있기 때문에, 웹 성능 개선 소식을 곧 들을 수 있길 기대하고 있다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>성능 최적화</h3>



<p>Tinder는 Page Load, Consistently Interactive를 개선하는데 다양한 기술을 사용했다. Tinder는 경로 기반 코드 분할(route-based code-splitting)을 구현, 성능 예산(performance budgets)과 장기 에셋 캐싱(long-term asset caching)을 도입했다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>경로 기반 코드 분할</h3>



<p>Tinder는 초기에 큰 한 덩어리의 자바스크립트 번들을 배포했고, 이는 Consistently Interactive 시간을 늦추는 결과를 가져왔다. 이 번들들은 핵심 사용자 경험에 즉시 필요치 않은 코드들을 포함하고 있었기 때문에 <a href="https://webpack.js.org/guides/code-splitting/">코드 분할(code-splitting)</a>로 쪼갤 수 있었다. <strong>일반적으로 사용자에게 먼저 필요한 코드만 담고, 나머지는 필요에 따라 지연 로딩(lazy-load)하는 방식은 유용하다.</strong></p>



<p>Tinder는 코드 분할과 지연 로딩을 위해 <a href="https://reacttraining.com/react-router/">React Router</a> 그리고 <a href="https://github.com/thejameskyle/react-loadable">React Loadable</a>을 활용했다. 모든 경로와 렌더링 정보를 모아서 설정으로 만들었고, 이는 최상위 레벨에서 코드 분할을 간단히 구현할 방법이 되었다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3><strong>요약하면</strong></h3>



<p>React Loadable은 James Kyle이 컴포넌트 중심으로 React에서 <strong>코드 분할</strong>을 쉽게 할 수 있도록 만든 작은 라이브러리이다. <strong>Loadable</strong>은 higher-order 컴포넌트(컴포넌트를 만드는 함수)로, 이것으로 컴포넌트 레벨에서 번들을 쉽게 <strong>분할</strong>할 수 있다.</p>



<p>&#8220;A&#8221;, &#8220;B&#8221; 두 개의 컴포넌트가 있다고 하자. 코드 분할 이전, 메인 번들은 A, B 그리고 기타의 것들까지 모두 가지고 있었다. A, B 모두 당장에 필요치는 않기 때문에 이는 비효율적인 방법이다.</p>



<figure class="wp-block-image"><img src="https://i2.wp.com/cdn-images-1.medium.com/max/1000/1*DoTby4l_-A3TNdiUSZ0LmA.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure>



<p>코드 분할을 한 이후, A, B 컴포넌트는 필요할 때 로드된다. Tinder는 이를 위해 React Loadable, <a href="https://webpack.js.org/guides/code-splitting/#dynamic-imports">dynamic import()</a>, 그리고 <a href="https://medium.com/faceyspacey/how-to-use-webpacks-new-magic-comment-feature-with-react-universal-component-ssr-a38fd3e296a">웹팩의 magic comment 문법</a> (분할된 조각에 이름을 부여하기 위해)을 아래처럼 설정했다.</p>



<figure class="wp-block-image"><img src="https://i1.wp.com/cdn-images-1.medium.com/max/1000/1*aPY-1uGEvPV1dNKrrD8z4Q.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure>



<p>공통으로 여러 경로에서 사용되는 &#8220;vendor&#8221; 라이브러리(외부에서 가져온) 조각은 오랫동안 캐시될 수 있도록, 웹팩의 <a href="https://webpack.js.org/plugins/commons-chunk-plugin/"><strong>CommonsChunkPlugin</strong></a>를 사용하여 하나로 만들었다.</p>



<figure class="wp-block-image"><img src="https://i1.wp.com/cdn-images-1.medium.com/max/1000/1*R-kXPcn937BNoFXLukPJPg.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure>



<p>그리고, 다음 페이지에서 쓰일 수 있는 리소스를 미리 로드하기 위해 컨트롤 컴포넌트에서 <a href="https://github.com/thejameskyle/react-loadable#loadablecomponentpreload">React Loadable의 preload 지원</a>을 사용했다.</p>



<figure class="wp-block-image"><img src="https://i1.wp.com/cdn-images-1.medium.com/max/1000/1*G2JvbNCsm4eBXbGgyW6OmA.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure>



<p>또한, <a href="https://developers.google.com/web/fundamentals/primers/service-workers/">Service Workers</a>를 사용해서 경로에 해당하는 모든 번들을 미리 캐시 했고, 사용자들이 확실히 방문하게 되는 경로는 코드 분할 없이 메인 번들에 담았다. 물론 UglifyJS를 이용한 자바스크립트 압축 같은 보편적인 최적화 방법들 역시 활용했다.</p>



<pre class="wp-block-code"><code>new webpack.optimize.UglifyJsPlugin({
      parallel: true,
      compress: {
        warnings: false,
        screw_ie8: true
      },
      sourceMap: SHOULD_SOURCEMAP
    }),</code></pre>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h4>효과</h4>



<p>경로 기반 코드 분할을 도입하여 메인 번들 크기가 166KB에서 101KB로 줄었고, DCL(Dom Content Loaded)이 5.46s에서 4.69s로 좋아졌다.</p>



<figure class="wp-block-image"><img src="https://i1.wp.com/cdn-images-1.medium.com/max/1000/1*1Tt8bnnkyIi8aEw0BjRgMw.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>장기 에셋 캐싱(Long-term asset caching)</h3>



<p>[chunkhash]를 이용하여 각 파일에 cache-buster를 추가하면, 웹팩이 만드는 정적 리소스의 <a href="https://webpack.js.org/guides/caching/">장기 에셋 캐싱</a>을 더 확실히 할 수 있다.</p>



<figure class="wp-block-image"><img src="https://i0.wp.com/cdn-images-1.medium.com/max/1000/1*nofQB3Q-8IUo9f1Eipd0xw.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure>



<p>Tinder는 많은 오픈소스(vendor) 라이브러리를 사용하고있다. 이 라이브러리들이 변경되면 원래의 [chunkhash]가 변경되고 캐시를 새로 해야한다. 이를 해결하여 캐싱을 개선 하기 위해 <a href="https://gist.github.com/tinder-rhsiao/89cd682c34d1e1307111b091801e6fe5%5D%28https://gist.github.com/tinder-rhsiao/89cd682c34d1e1307111b091801e6fe5">외부 라이브러리 화이트리스트</a>를 정의하고 메인 번들에서 잘라냈다. 두 개의 번들 크기는 대략 160KB가 되었다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>나중에 쓰일 리소스 미리 로딩(preload)</h3>



<p>복습하자면 <a href="https://developers.google.com/web/fundamentals/performance/resource-prioritization">&lt;link rel=preload></a>는 브라우저가 꼭 필요하지만 지금 당장 사용하지 않을 리소스를 미리 로드하게 해주는 서술형 명령(declarative instruction) 이다. single-page application에서 미리 로드할 이 리소스는 종종 자바스크립트 번들이 되기도 한다.</p>



<figure class="wp-block-image"><img src="https://i2.wp.com/cdn-images-1.medium.com/max/800/1*CaObLc_tGJvnllyV3CGD5w.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure>



<p>Tinder는 핵심 경험에 중요한 자바스크립트/웹팩 번들을 미리 로드하도록 했다. 이 작업은 로드에 걸리는 시간을 1초 줄였고, first paint를 1000ms에서 500ms 정도로 줄여주었다.</p>



<figure class="wp-block-image"><img src="https://i2.wp.com/cdn-images-1.medium.com/max/1000/1*AtzElAKy_pCvRjZN__YSsQ.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>성능 예산(Performance budgets)</h3>



<p>Tinder는 성능 목표 달성을 위해 성능 예산을 도입하였다. Alex Russell이 “<a href="https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/">Can you afford it?: real-world performance budgets</a>”에서 언급했듯, 느린 3G 연결을 가진 성능이 낮은 모바일 하드웨어를 고려하면 예산은 한정적이다.</p>



<p>Tinder는 first interactive, consistently interactive를 빠르게 하려고 메인 번들과 vendor 번들을 155KB 이하, 비동기적으로 지연 로드되는(lazy load) 번들들은 55KB 이하, 그 외의 번들들은 35KB 이하, CSS는 20KB로 제한했다.</p>



<figure class="wp-block-image"><img src="https://i0.wp.com/cdn-images-1.medium.com/max/1000/1*OgDLsMxsy6IO79NmjQtcng.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>웹팩 번들 분석</h3>



<p><a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">Webpack Bundle Analyzer</a>를 사용하면 자바스크립트 번들의 의존성 그래프(dependency graph)를 살펴보고, 그중에 쉽게 최적화 가능한 것이 있는지 찾을 수 있다</p>



<figure class="wp-block-image"><img src="https://i0.wp.com/cdn-images-1.medium.com/max/800/1*qsiUA0G50a4p3y2e4p7CyA.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure>



<p>Tinder는 최적화 가능한 영역을 찾기 위해 Webpack Bundle Analyzer를 다음과 같이 사용한다.</p>



<ul><li><strong>Polyfills</strong>: 최신 브라우저뿐만 아니라 IE11, 안드로이드 4.4까지도 지원하고 있다. <strong>Polyfill과 변환된 코드를 최소화하기 위해, <a href="https://github.com/babel/babel-preset-env">babel-preset-env</a>와 <a href="https://github.com/zloirock/core-js">core-js</a>를 사용한다.</strong></li><li><strong>라이브러리 다이어트</strong>: <a href="https://github.com/localForage/localForage">localForage</a> 사용을 IndexedDB를 직접 사용하는 것으로 대체했다.</li><li><strong>코드 분할</strong>: first paint, first interactive에 필요하지 않은 컴포넌트들을 메인 번들에서 잘라냈다.</li><li><strong>코드 재사용</strong>: 세 군데 이상에서 쓰이는 코드 조각을 추상화하여 비동기 공통 번들을 만들었다.</li><li><strong>CSS</strong>: 핵심 번들에서 <a href="https://www.smashingmagazine.com/2015/08/understanding-critical-css/">중요 CSS</a> 분리. (서버 사이드 렌더링으로 처리해서 제공)<br/></li></ul>



<figure class="wp-block-image"><img src="https://i0.wp.com/cdn-images-1.medium.com/max/800/1*ZL3i2BRHo8Sq_dv1NyA8Dw.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure>



<p>번들을 분석하는 일은 웹팩의 <a href="https://github.com/lodash/lodash-webpack-plugin">Lodash Module Replacement Plugin</a>을 활용케 했다. 이 플러그인은 <a href="https://github.com/lodash/lodash-webpack-plugin#feature-sets">feature set</a>을 동일한, 비슷한, 혹은 아무 동작 하지 않는 것(<a href="https://lodash.com/docs/4.17.4#noop">noop</a>)으로 바꾸어 Lodash 빌드를 작게 만든다.</p>



<figure class="wp-block-image"><img src="https://i1.wp.com/cdn-images-1.medium.com/max/1000/1*of2Mv5ypTySRpTZQZVRj7A.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure>



<p>웹팩에 Webpack Bundle Analyzer를 설정할 수 있으며, Tinder의 설정은 아래와 같다.</p>



<pre class="wp-block-code"><code>plugins: [
      new BundleAnalyzerPlugin({
        analyzerMode: 'server',
        analyzerPort: 8888,
        reportFilename: 'report.html',
        openAnalyzer: true,
        generateStatsFile: false,
        statsFilename: 'stats.json',
        statsOptions: null
      })</code></pre>



<p>메인 번들에 남아있는 대부분의 자바스크립트는 Redux Reducer, Saga Register 구조를 변경하지 않고는 잘라내기 힘든 것들이다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>CSS 전략</h3>



<p>Tinder는 재사용성 높은 CSS를 만들기 위해 <a href="https://acss.io/">Atomic CSS</a>를 사용하고 있다. 이 atomic CSS는 모두 초기 페인트 때 인라인 되고, 나머지 몇몇은 스타일시트(애니메이션이나 <a href="http://www.cssmojo.com/css-reset_versus_css-starter/">base/reset 스타일</a>을 포함한)로 로드된다. 중요 스타일은 압축하여 최대 20KB 크기이고, 최근 에는 11KB 이하로 줄었다.</p>



<p>Tinder는 어떠한 변경 점이 생겼는지 추적하기 위해 매번 배포 때마다 <a href="http://cssstats.com/stats?url=https%253A%252F%252Ftinder.com&amp;ua=Browser%2520Default%0A">CSS stats</a>와 Google Analytics를 사용한다. Atomic CSS를 사용하기 전 평균 페이지 로드 시간은 6.75초 이하였고, 이후에는 5.75초로 떨어졌다.</p>



<figure class="wp-block-image"><img src="https://i2.wp.com/cdn-images-1.medium.com/max/1000/1*Uv_at6Xs7QYHZJ0iy8c7GQ.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure>



<p>Tinder는 또한 <a href="http://caniuse.com/">Can I Use</a>를 기초로 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix">vendor prefix</a>를 자동으로 붙여주는 PostCSS <a href="https://twitter.com/autoprefixer">Autoprefixer plugin</a>도 사용한다. 설정은 아래를 참고.</p>



<pre class="wp-block-code"><code>new webpack.LoaderOptionsPlugin({
    options: {
    context: paths.basePath,
    output: { path: './' },
    minimize: true,
    postcss: [
        autoprefixer({
        browsers: [
            'last 2 versions',
            'not ie &lt; 11',
            'Safari >= 8'
        ]
        })
      ]
    }
}),</code></pre>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>실시간 성능</h3>



<h4>매우 중요한 일이 아닌 것은 requestIdleCallback() 으로 미루기</h4>



<p>정말 중요한 것이 아닌 것들을 idle time으로 미루어 실시간 성능을 높이기 위해 <a href="https://developers.google.com/web/updates/2015/08/using-requestidlecallback">requestIdleCallback()</a>을 사용한다.</p>



<pre class="wp-block-code"><code>requestIdleCallback(myNonEssentialWork);</code></pre>



<p>여기에는 계기 신호등 같은 일이 포함된다. 또한 밀어서 잠금 해제(swiping)하는 도중 paint count를 줄이기 위해 HTML composite layer들을 간단하게 했다. </p>



<p><strong>밀어서 잠금 해제 하는 동안 requestIdleCallback()을 계기 신호등에 사용했더니</strong></p>



<p>사용 이전에는..</p>



<figure class="wp-block-image"><img src="https://i0.wp.com/cdn-images-1.medium.com/max/800/1*oHJ8IjCs7AKdCrt9b28ZPw.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure>



<p>사용 이후에는..</p>



<figure class="wp-block-image"><img src="https://i2.wp.com/cdn-images-1.medium.com/max/800/1*UTQuSSp7MGMY06mwYtQmaw.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>의존성 업데이트</h3>



<p><br/></p>



<p>이전 버전의 웹팩은 모듈을 번들링할 때 개별적인 함수 클로저(closure)로 감쌌었다. 감싸고 있는 함수들은 브라우저에서 실행을 느리게 만들었다. <a href="https://medium.com/webpack/webpack-3-official-release-15fd2dd8f07b">웹팩 3</a>는 &#8220;scope hoisting&#8221; 기능을 가지고 있는데, 이것은 모든 모듈을 하나의 클로저에 묶어 브라우저에서 더 빠르게 실행될 수 있도록 한다. 아래처럼 Module Concatenation plugin을 사용하면 된다.</p>



<pre class="wp-block-code"><code>new webpack.optimize.ModuleConcatenationPlugin()</code></pre>



<p><strong>웹팩 3의 scope hoisting은 Tinder의 초기 vendor 번들 자바스크립트 파싱 시간을 8% 줄여주었다.</strong></p>



<p><strong>리엑트 16</strong></p>



<p>리엑트 16은 이전 버전과 비교하면 <a href="https://reactjs.org/blog/2017/09/26/react-v16.0.html#reduced-file-size">리엑트 번들 크기 감소를 축소</a> 해주었다. 롤업(Rollup)을 사용해 패키징하고, 사용하지 않는 코드를 삭제하여 이러한 향상을 가져왔다.</p>



<p><strong>Tinder는 리엑트 15에서 리엑트 16으로 업데이트 하면서 압축(gzipped)한 vendor 번들 크기를 7% 줄였다.</strong></p>



<p>react + react-dom의 압축 크기는 ~50KB에서 ~<strong>35KB</strong>로 줄었다. 리엑트 16 번들 크기를 줄이는 데 중요한 역할을 한 <a href="https://twitter.com/dan_abramov">Dan Abramov</a>, <a href="https://twitter.com/trueadm">Dominic Gannaway</a> 그리고 <a href="https://twitter.com/natehunzaker">Nate Hunzaker</a>에게 감사한다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>네트워크 탄력(resilience)과 오프라인 에셋 캐싱을 위한 Workbox</h3>



<p>메인, vendor, manifest 번들과 CSS 같은 주요 정적 에셋과 <a href="https://developers.google.com/web/fundamentals/architecture/app-shell">Application Shell</a>을 캐시 하기 위해 <a href="https://developers.google.com/web/tools/workbox/get-started/webpack">Workbox Webpack plugin</a>을 사용했다. 이것으로 재방문하는 사용자들에게 네트워크 탄력성과 더 빠른 웹 앱을 제공할 수 있게 되었다.</p>



<figure class="wp-block-image"><img src="https://i2.wp.com/cdn-images-1.medium.com/max/1000/1*yXpAzyA1ODPk2OSOTA6Lhg.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>기회</h3>



<p>또 다른 bundle analysis tool인 <a href="https://www.npmjs.com/package/source-map-explorer">source-map-explorer</a>를 사용하여 Tinder의 번들을 파보면 아직도 번들 크기를 줄일 수 있는 여지가 있다. 로그인 이전에 페이스북 사진, 알림, 메시지, 캡챠(captcha)가 로드되는데, 이것을 주요 경로(critical path)에서 제거하면 메인 번들 크기를 20%까지 줄일 수 있다.</p>



<figure class="wp-block-image"><img src="https://i1.wp.com/cdn-images-1.medium.com/max/1000/1*G1nq7BNZPEo2mFr_my5zjA.png?w=720&#038;ssl=1" alt="" data-recalc-dims="1"/></figure>



<p>200KB 크기의 페이스북 SDK 스크립트가 주요 경로에 포함되어있다. 이 스크립트를 제거하면(나중에 필요할 때 지연 로드 하면 된다), 초기 로딩 시간을 1초 깎아낼 수 있다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>결론</h3>



<p>Tinder는 여전히 Progressive Web App 작업을 진행 중이지만, 이 작업으로 벌써 결실을 보기 시작했다. Tinder.com을 계속 지켜보며 진전 사항을 확인하자.</p>



<p><em>Tinder Online을 런칭하고 이 글을 작성하는 재료가 된 Roderick Hsiao, Jordan Banafsheha, 그리고 Erik Hellenbrand에게 감사와 축하를 전한다. 이 글을 리뷰해준 Cheney Tsai 에게도 감사를 전한다.</em></p>



<p><strong>더 읽을거리</strong></p>



<ul>
	<li><a href="https://medium.com/dev-channel/a-pinterest-progressive-web-app-performance-case-study-3bd6ed2e6154">A Pinterest PWA performance case study</a></li>
	<li><a href="https://medium.com/dev-channel/treebo-a-react-and-preact-progressive-web-app-performance-case-study-5e4f450d5299">A Treebo React &amp; Preact performance case study</a></li>
	<li><a href="https://medium.com/@paularmstrong/twitter-lite-and-high-performance-react-progressive-web-apps-at-scale-d28a00e780a3">Twitter Lite and high-performance PWAs at scale</a></li>
</ul>



<p>이 글은 <a href="https://calendar.perfplanet.com/2017/a-tinder-progressive-web-app-performance-case-study/">Performance Planet</a>와 함께 교차 게재 했다. 만약 당신이 리엑트 초보자라면 <a href="https://goo.gl/G1WGxU">초보자를 위한 리엑트</a>를 추천하겠다.</p>
<p>The post <a rel="nofollow" href="https://kyu.io/ko/tinder%ec%9d%98-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9-%ec%95%b1-%ec%84%b1%eb%8a%a5-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94/">Tinder의 프로그래시브 웹 앱 성능 케이스 스터디</a> appeared first on <a rel="nofollow" href="https://kyu.io/ko">KYU.IO 🌾</a>.</p>
]]></content:encoded>
							<wfw:commentRss>https://kyu.io/ko/tinder%ec%9d%98-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9-%ec%95%b1-%ec%84%b1%eb%8a%a5-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">678</post-id>	</item>
		<item>
		<title>러스트 (그리고 모든 언어)에서 웹어셈블리를 더 좋게만들기</title>
		<link>https://kyu.io/ko/%eb%9f%ac%ec%8a%a4%ed%8a%b8-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%eb%aa%a8%eb%93%a0-%ec%96%b8%ec%96%b4%ec%97%90%ec%84%9c-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%a5%bc-%eb%8d%94-%ec%a2%8b%ea%b2%8c/#utm_source=rss&#038;utm_medium=rss&#038;utm_campaign=%25eb%259f%25ac%25ec%258a%25a4%25ed%258a%25b8-%25ea%25b7%25b8%25eb%25a6%25ac%25ea%25b3%25a0-%25eb%25aa%25a8%25eb%2593%25a0-%25ec%2596%25b8%25ec%2596%25b4%25ec%2597%2590%25ec%2584%259c-%25ec%259b%25b9%25ec%2596%25b4%25ec%2585%2588%25eb%25b8%2594%25eb%25a6%25ac%25eb%25a5%25bc-%25eb%258d%2594-%25ec%25a2%258b%25ea%25b2%258c</link>
				<comments>https://kyu.io/ko/%eb%9f%ac%ec%8a%a4%ed%8a%b8-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%eb%aa%a8%eb%93%a0-%ec%96%b8%ec%96%b4%ec%97%90%ec%84%9c-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%a5%bc-%eb%8d%94-%ec%a2%8b%ea%b2%8c/#respond</comments>
				<pubDate>Mon, 04 Jun 2018 10:44:16 +0000</pubDate>
		<dc:creator><![CDATA[kyuwoo.choi]]></dc:creator>
				<category><![CDATA[러스트]]></category>
		<category><![CDATA[번역]]></category>
		<category><![CDATA[웹어셈블리]]></category>
		<category><![CDATA[자바스크립트]]></category>
		<category><![CDATA[전체]]></category>
		<category><![CDATA[WASM]]></category>

		<guid isPermaLink="false">https://kyu.io/?p=506</guid>
				<description><![CDATA[<p>2018년 웹 언어를 목표로하는 러스트 커뮤니티는 이를 위해 다양한 노력을 하고있다.<br />
그리고 이를 실현시키기 위해 러스트로 작성한 웹 어셈블리 도구들을 만들고 있다.<br />
자바스크립트와 오브젝트를 주고 받고, npm 모듈로 패키징 할 수 있으며, ES 모듈과의 호환까지.<br />
wasm-bindgen, wasm-pack 이 어떤 원리로 무슨 일을 해주고 있는지 알아본다.<br />
그리고 이러한 노력들은 러스트 이외의 언어까지 지원할 수 있는 가능성을 넓혀주고 있다.</p>
<p>The post <a rel="nofollow" href="https://kyu.io/ko/%eb%9f%ac%ec%8a%a4%ed%8a%b8-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%eb%aa%a8%eb%93%a0-%ec%96%b8%ec%96%b4%ec%97%90%ec%84%9c-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%a5%bc-%eb%8d%94-%ec%a2%8b%ea%b2%8c/">러스트 (그리고 모든 언어)에서 웹어셈블리를 더 좋게만들기</a> appeared first on <a rel="nofollow" href="https://kyu.io/ko">KYU.IO 🌾</a>.</p>
]]></description>
								<content:encoded><![CDATA[
<p>러스트(Rust) 커뮤니티의 2018년 최대 목표는 웹 언어가 되는 것이다. 웹 어셈블리(WebAssembly)를 타깃으로 러스트는 자바스크립트처럼 웹에서 실행될 수 있다. 그런데 이것이 무엇을 뜻하는 걸까? 러스트가 자바스크립트를 대체하려는 걸까?</p>



<p>그 대답은 아니오이다. 우리는 러스트 웹 어셈블리 앱들이 완전히 러스트만으로 작성될 것이라고 생각하지 않는다. 사실, 우리는 대다수의 애플리케이션은 여전히 자바스크립트로 작성될 것이라 생각한다. 러스트 웹 어셈블리 애플리케이션조차 말이다.</p>



<p>왜냐하면 거의 모든 상황에서 자바스크립트를 선택하는 것이 좋기 때문이다. 자바스크립트는 빠르고 쉽게 실행시킬 수 있다. 게다가, 다양한 문제들을 믿을 수 없이 혁신적인 방식으로 문제를 해결해온 자바스크립트 개발자들의 생생한 생태계가 있다.</p>



<figure class="wp-block-image aligncenter"><img data-attachment-id="516" data-permalink="https://kyu.io/ko/%eb%9f%ac%ec%8a%a4%ed%8a%b8-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%eb%aa%a8%eb%93%a0-%ec%96%b8%ec%96%b4%ec%97%90%ec%84%9c-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%a5%bc-%eb%8d%94-%ec%a2%8b%ea%b2%8c/01_rust_loves_js-500x201-1/" data-orig-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/06/01_rust_loves_js-500x201-1.png?fit=500%2C201&amp;ssl=1" data-orig-size="500,201" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="01_rust_loves_js-500&#215;201-1" data-image-description="" data-medium-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/06/01_rust_loves_js-500x201-1.png?fit=300%2C121&amp;ssl=1" data-large-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/06/01_rust_loves_js-500x201-1.png?fit=500%2C201&amp;ssl=1" src="https://i1.wp.com/kyu.io/wp-content/uploads/2018/06/01_rust_loves_js-500x201-1.png?w=720&#038;ssl=1" alt="" class="wp-image-516" srcset="https://i1.wp.com/kyu.io/wp-content/uploads/2018/06/01_rust_loves_js-500x201-1.png?w=500&amp;ssl=1 500w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/06/01_rust_loves_js-500x201-1.png?resize=300%2C121&amp;ssl=1 300w" sizes="(max-width: 500px) 100vw, 500px" data-recalc-dims="1" /></figure>



<p>하지만 종종 러스트 + 웹 어셈블리는 애플리케이션의 어떤 작업을 위한 올바른 도구가 될 수 있다. 소스 맵을 파싱 한다거나, 엠버(Ember)가 DOM의 변경사항을 찾는 일처럼 말이다.</p>



<p>그렇기에 러스트 + 웹 어셈블리가 나아가야 할 길은 러스트를 웹 어셈블리로 컴파일 하는 데서 멈추지 않는다. 우리는 웹 어셈블리가 자바스크립트 생태계에 잘 어울리도록 해야 한다. 웹 개발자들은 웹 어셈블리를 자바스크립트인 것 마냥 사용할 수 있어야 한다.</p>



<p>하지만 아직 웹 어셈블리는 거기까지 준비되지 않았다. 이것을 실현시키기 위해, 우리는 간편하게 웹 어셈블리를 로드시키고, 자바스크립트와 연동시킬 도구를 만들어야 한다. 이 일은 러스트를 위한 일이지만, 웹 어셈블리를 타깃으로 하는 다른 언어들을 위한 것이기도 하다.</p>



<figure class="wp-block-image aligncenter"><img data-attachment-id="521" data-permalink="https://kyu.io/ko/%eb%9f%ac%ec%8a%a4%ed%8a%b8-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%eb%aa%a8%eb%93%a0-%ec%96%b8%ec%96%b4%ec%97%90%ec%84%9c-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%a5%bc-%eb%8d%94-%ec%a2%8b%ea%b2%8c/02_pipeline-500x127/" data-orig-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/02_pipeline-500x127.png?fit=500%2C127&amp;ssl=1" data-orig-size="500,127" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="02_pipeline-500&#215;127" data-image-description="" data-medium-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/02_pipeline-500x127.png?fit=300%2C76&amp;ssl=1" data-large-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/02_pipeline-500x127.png?fit=500%2C127&amp;ssl=1" src="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/02_pipeline-500x127.png?resize=500%2C127&#038;ssl=1" alt="" class="wp-image-521" srcset="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/02_pipeline-500x127.png?resize=500%2C127&amp;ssl=1 500w, https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/02_pipeline-500x127.png?resize=300%2C76&amp;ssl=1 300w" sizes="(max-width: 500px) 100vw, 500px" data-recalc-dims="1" /></figure>



<p>우리는  웹 어셈블리의 어떤 사용성을 손봐야 할까? 여기 몇 가지를 적었다.</p>



<ol>
	<li>어떻게 해야 웹 어셈블리와 자바스크립트 사이에 쉽게 오브젝트를 주고받을 수 있을까?</li>
	<li>어떻게 이 패키지를 npm에 등록할 수 있을까?</li>
	<li>어떻게 개발자들이 번들러와 브라우저를 가리지 않고 쉽게 자바스크립트와 WASM 패키지를 합칠 수 있을까?</li>
</ol>



<p>그보다 먼저, 무엇을 우리는 러스트에서 실현시키고 있는가?</p>



<p>러스트는 자바스크립트 함수를 호출할 수 있게 된다. 자바스크립트도 러스트 함수를 호출할 수 있게 된다. 러스트는 alert 같은 호스트 플랫폼의 함수를 호출할 수 있게 된다. 러스트 크레이트(crate)들은 npm 패키지들을 의존성(dependency)으로 가질 수 있게 된다.  그리고 이 모든 것들을 통해, 러스트와 자바스크립트는 양쪽의 입장에서 적절한 방법으로 오브젝트를 주고받을 수 있어진다.</p>



<figure class="wp-block-image aligncenter"><img data-attachment-id="530" data-permalink="https://kyu.io/ko/%eb%9f%ac%ec%8a%a4%ed%8a%b8-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%eb%aa%a8%eb%93%a0-%ec%96%b8%ec%96%b4%ec%97%90%ec%84%9c-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%a5%bc-%eb%8d%94-%ec%a2%8b%ea%b2%8c/03_crate_graph-500x346/" data-orig-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/03_crate_graph-500x346.png?fit=500%2C346&amp;ssl=1" data-orig-size="500,346" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="03_crate_graph-500&#215;346" data-image-description="" data-medium-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/03_crate_graph-500x346.png?fit=300%2C208&amp;ssl=1" data-large-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/03_crate_graph-500x346.png?fit=500%2C346&amp;ssl=1" src="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/03_crate_graph-500x346.png?resize=500%2C346&#038;ssl=1" alt="" class="wp-image-530" srcset="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/03_crate_graph-500x346.png?resize=500%2C346&amp;ssl=1 500w, https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/03_crate_graph-500x346.png?resize=300%2C208&amp;ssl=1 300w" sizes="(max-width: 500px) 100vw, 500px" data-recalc-dims="1" /></figure>



<p>바로 그것이 우리가 러스트에서 실현 중인 것이다. 이제 우리가 도전 중인 웹 어셈블리의 사용성을 보자.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>Q. 어떻게 해야 웹 어셈블리와 자바스크립트 사이에 쉽게 오브젝트를 주고받을 수 있을까?</h2>



<p>A. wasm-bindgen</p>



<p>웹 어셈블리를 사용할 때 가장 어려운 부분 중 하나는 함수에 다양한 값을 넣고 받아오는 일이다. 왜냐하면 웹 어셈블리는 현재 오로지 정수와 실수 두 가지 타입만을 가지고 있기 때문이다.</p>



<p>이것은 당신이 그저 웹 어셈블리 함수에 문자열을 던져 실행시킬 수 없다는 뜻이다. 몇 가지 과정을 밟아야만 한다.</p>



<p>1. 자바스크립트 쪽에서, 문자열을 숫자들로 인코드 (TextEncoder 같은 것을 사용해서)</p>



<figure class="wp-block-image aligncenter"><img data-attachment-id="536" data-permalink="https://kyu.io/ko/%eb%9f%ac%ec%8a%a4%ed%8a%b8-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%eb%aa%a8%eb%93%a0-%ec%96%b8%ec%96%b4%ec%97%90%ec%84%9c-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%a5%bc-%eb%8d%94-%ec%a2%8b%ea%b2%8c/04_wasm_bindgen_01-500x204/" data-orig-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_01-500x204.png?fit=500%2C204&amp;ssl=1" data-orig-size="500,204" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="04_wasm_bindgen_01-500&#215;204" data-image-description="" data-medium-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_01-500x204.png?fit=300%2C122&amp;ssl=1" data-large-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_01-500x204.png?fit=500%2C204&amp;ssl=1" src="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_01-500x204.png?resize=500%2C204&#038;ssl=1" alt="" class="wp-image-536" srcset="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_01-500x204.png?resize=500%2C204&amp;ssl=1 500w, https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_01-500x204.png?resize=300%2C122&amp;ssl=1 300w" sizes="(max-width: 500px) 100vw, 500px" data-recalc-dims="1" /></figure>



<p>2. 그 숫자들을 웹 어셈블리의 메모리에 (기본적으로 숫자 배열 하나로) 로드.</p>



<figure class="wp-block-image aligncenter"><img data-attachment-id="537" data-permalink="https://kyu.io/ko/%eb%9f%ac%ec%8a%a4%ed%8a%b8-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%eb%aa%a8%eb%93%a0-%ec%96%b8%ec%96%b4%ec%97%90%ec%84%9c-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%a5%bc-%eb%8d%94-%ec%a2%8b%ea%b2%8c/04_wasm_bindgen_02-500x295/" data-orig-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_02-500x295.png?fit=500%2C295&amp;ssl=1" data-orig-size="500,295" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="04_wasm_bindgen_02-500&#215;295" data-image-description="" data-medium-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_02-500x295.png?fit=300%2C177&amp;ssl=1" data-large-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_02-500x295.png?fit=500%2C295&amp;ssl=1" src="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_02-500x295.png?resize=500%2C295&#038;ssl=1" alt="" class="wp-image-537" srcset="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_02-500x295.png?resize=500%2C295&amp;ssl=1 500w, https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_02-500x295.png?resize=300%2C177&amp;ssl=1 300w" sizes="(max-width: 500px) 100vw, 500px" data-recalc-dims="1" /></figure>



<p>3. 문자열의 첫 글자에 해당하는 배열의 인덱스를 웹 어셈블리 함수에 전달.</p>



<figure class="wp-block-image aligncenter"><img data-attachment-id="538" data-permalink="https://kyu.io/ko/%eb%9f%ac%ec%8a%a4%ed%8a%b8-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%eb%aa%a8%eb%93%a0-%ec%96%b8%ec%96%b4%ec%97%90%ec%84%9c-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%a5%bc-%eb%8d%94-%ec%a2%8b%ea%b2%8c/04_wasm_bindgen_03-500x295/" data-orig-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_03-500x295.png?fit=500%2C295&amp;ssl=1" data-orig-size="500,295" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="04_wasm_bindgen_03-500&#215;295" data-image-description="" data-medium-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_03-500x295.png?fit=300%2C177&amp;ssl=1" data-large-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_03-500x295.png?fit=500%2C295&amp;ssl=1" src="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_03-500x295.png?resize=500%2C295&#038;ssl=1" alt="" class="wp-image-538" srcset="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_03-500x295.png?resize=500%2C295&amp;ssl=1 500w, https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_03-500x295.png?resize=300%2C177&amp;ssl=1 300w" sizes="(max-width: 500px) 100vw, 500px" data-recalc-dims="1" /></figure>



<p>4. 웹 어셈블리 쪽에서는 숫자들을 가져오기 위해 그 정수를 포인터로 사용.</p>



<figure class="wp-block-image aligncenter"><img data-attachment-id="539" data-permalink="https://kyu.io/ko/%eb%9f%ac%ec%8a%a4%ed%8a%b8-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%eb%aa%a8%eb%93%a0-%ec%96%b8%ec%96%b4%ec%97%90%ec%84%9c-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%a5%bc-%eb%8d%94-%ec%a2%8b%ea%b2%8c/04_wasm_bindgen_04-500x295/" data-orig-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_04-500x295.png?fit=500%2C295&amp;ssl=1" data-orig-size="500,295" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="04_wasm_bindgen_04-500&#215;295" data-image-description="" data-medium-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_04-500x295.png?fit=300%2C177&amp;ssl=1" data-large-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_04-500x295.png?fit=500%2C295&amp;ssl=1" src="https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_04-500x295.png?resize=500%2C295&#038;ssl=1" alt="" class="wp-image-539" srcset="https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_04-500x295.png?resize=500%2C295&amp;ssl=1 500w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/04_wasm_bindgen_04-500x295.png?resize=300%2C177&amp;ssl=1 300w" sizes="(max-width: 500px) 100vw, 500px" data-recalc-dims="1" /></figure>



<p>이것으로 여기까지가 문자열을 처리하는데 필요한 일들이다. 만약 여러분이 더 복잡한 타입을 주고받기 위해서는 더 복잡한 과정이 필요하다.</p>



<p>여러분이 웹 어셈블리 코드를 많이 사용하다 보면, 아마도 이러한 연동에 필요한 코드들을 라이브러리로 추상화하게 될 것이다. 하지만 당신이 애초에 이러한 연동에 필요한 코드를 작성하지 않아도 된다면, 그리고 만일 당신이 복잡한 값들을 그저 언어의 경계를 가로질러 던지는 것만으로 알아서 동작할 수 있다면 좋지 않을까?</p>



<p>그것이 wasm-bindgen이 하는 일이다. 러스트 코드에 몇몇 annotation을 추가하면, wasm-bindgen은 자동으로 양쪽에서 복잡한 타입을 처리하는 코드를 만들어 줄 것이다.</p>



<figure class="wp-block-image"><img data-attachment-id="540" data-permalink="https://kyu.io/ko/%eb%9f%ac%ec%8a%a4%ed%8a%b8-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%eb%aa%a8%eb%93%a0-%ec%96%b8%ec%96%b4%ec%97%90%ec%84%9c-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%a5%bc-%eb%8d%94-%ec%a2%8b%ea%b2%8c/05_wasm_bindgen_2/" data-orig-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/05_wasm_bindgen_2.png?fit=4633%2C2415&amp;ssl=1" data-orig-size="4633,2415" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="05_wasm_bindgen_2" data-image-description="" data-medium-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/05_wasm_bindgen_2.png?fit=300%2C156&amp;ssl=1" data-large-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/05_wasm_bindgen_2.png?fit=720%2C375&amp;ssl=1" src="https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/05_wasm_bindgen_2.png?w=720&#038;ssl=1" alt="" class="wp-image-540" srcset="https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/05_wasm_bindgen_2.png?w=4633&amp;ssl=1 4633w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/05_wasm_bindgen_2.png?resize=300%2C156&amp;ssl=1 300w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/05_wasm_bindgen_2.png?resize=1024%2C534&amp;ssl=1 1024w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/05_wasm_bindgen_2.png?resize=720%2C375&amp;ssl=1 720w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/05_wasm_bindgen_2.png?w=1440&amp;ssl=1 1440w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/05_wasm_bindgen_2.png?w=2160&amp;ssl=1 2160w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<p>이는 자바스크립트 함수들이 원하는 데이터 타입이 무엇이든 러스트에서 호출한다는 뜻이다:</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/690a049205e22a50620b1d168eada264">Gist</a>.
</figure>



<p>&#8230; 혹은 자바스크립트에서 러스트의 구조체(struct)들을 자바스크립트의 클래스(class)들처럼 사용한다거나:</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/ee1a34f022726ab9cb96fde2b798a281">Gist</a>.
</figure>



<p>&#8230; 그리고 기타 등등.</p>



<p>내부적으로 wasm-bindgen은 언어 독립적으로 디자인 되었다. 이는 즉, 이 도구가 안정화되면 C/C++ 같은 다른 언어 구문을 지원하도록 확장할 수 있다는 뜻이다.</p>



<p>Alex Crichton이 몇 주 이내에 wasm-bindgen에 대한 글을 쓸 예정이니 찾아보기 바란다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>Q. npm에 올리기 위해 어떻게 패키지를 만드나?</h2>



<p>A. wasm-pack</p>



<p>일단 할 일들을 마치고 나면, 우리는 몇몇 개의 파일을 손에 쥐고 있을 것이다. 컴파일된 웹 어셈블리 파일이 있고, 의존성과 <code>wasm-bindgen</code>이 생성한 자바스크립트 파일들이 있다. 우리는 이것들 모두를 패키지 할 수 있는 방법이 필요하다. 게다가, npm 의존성이 있다면 그것들을 <code>package.json</code> manifest 파일에도 추가해야 한다.</p>



<figure class="wp-block-image aligncenter"><img data-attachment-id="559" data-permalink="https://kyu.io/ko/%eb%9f%ac%ec%8a%a4%ed%8a%b8-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%eb%aa%a8%eb%93%a0-%ec%96%b8%ec%96%b4%ec%97%90%ec%84%9c-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%a5%bc-%eb%8d%94-%ec%a2%8b%ea%b2%8c/06_wasm_pack/" data-orig-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/06_wasm_pack.png?fit=2856%2C1445&amp;ssl=1" data-orig-size="2856,1445" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="06_wasm_pack" data-image-description="" data-medium-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/06_wasm_pack.png?fit=300%2C152&amp;ssl=1" data-large-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/06_wasm_pack.png?fit=720%2C364&amp;ssl=1" src="https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/06_wasm_pack.png?w=720&#038;ssl=1" alt="" class="wp-image-559" srcset="https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/06_wasm_pack.png?w=2856&amp;ssl=1 2856w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/06_wasm_pack.png?resize=300%2C152&amp;ssl=1 300w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/06_wasm_pack.png?resize=1024%2C518&amp;ssl=1 1024w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/06_wasm_pack.png?resize=720%2C364&amp;ssl=1 720w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/06_wasm_pack.png?w=1440&amp;ssl=1 1440w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/06/06_wasm_pack.png?w=2160&amp;ssl=1 2160w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<p>이 역시 자동으로 해결되면 좋을 것이다. 그리고 그것이 바로 <code>wasm-pack</code>의 역할이다. 이것은 컴파일 된 웹 어셈블리 파일을 npm 패키지로 만들어주는 만능 도구 같은 것이다.</p>



<p><code>wasm-pack</code>은 여러분 대신 <code>wasm-bindgen</code>을 실행한다. 그리고 그 모든 파일들을 패키지로 만들어 준다. 먼저 <code>package.json</code>을 생성하고, 러스트 코드를 참조해 npm 의존성을 추가한다. 그 이후 여러분은 <code>npm publish</code>만 하면 된다.</p>



<p>다시 한번 말하자면, 이 도구는 언어 독립적인 기반을 가지고 있다. 그렇기에 우리는 이것이 여러 언어 생태계를 지원할 것으로 기대한다.</p>



<p>Ashley Williams가 다음 달에 <code>wasm-pack</code>의 더 많은 것에 대해 쓸 것이다. 그러니 그것도 참조하시라.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>Q. 어떻게 개발자들이 번들러, Node 혹은 브라우저를 가리지 않고 쉽게 자바스크립트와 WASM 패키지를 합칠 수 있을까?</h2>



<p>A. ES modules</p>



<p>자 이제 우리는 우리 WebAssembly를 npm에 등록했다. 이제 이 웹 어셈블리를 어떻게 자바스크립트 애플리케이션에서 쉽게 사용될 수 있도록 만들까?</p>



<p>웹 어셈블리 패키지를 의존성으로써 쉽게. 그러니&#8230; 자바스크립트의 의존성 그래프에 포함되도록 말이다.</p>



<figure class="wp-block-image aligncenter"><img data-attachment-id="560" data-permalink="https://kyu.io/ko/%eb%9f%ac%ec%8a%a4%ed%8a%b8-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%eb%aa%a8%eb%93%a0-%ec%96%b8%ec%96%b4%ec%97%90%ec%84%9c-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%a5%bc-%eb%8d%94-%ec%a2%8b%ea%b2%8c/02_js_wasm_graph-500x392/" data-orig-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/02_js_wasm_graph-500x392.png?fit=500%2C392&amp;ssl=1" data-orig-size="500,392" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="02_js_wasm_graph-500&#215;392" data-image-description="" data-medium-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/02_js_wasm_graph-500x392.png?fit=300%2C235&amp;ssl=1" data-large-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/02_js_wasm_graph-500x392.png?fit=500%2C392&amp;ssl=1" src="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/02_js_wasm_graph-500x392.png?resize=500%2C392&#038;ssl=1" alt="" class="wp-image-560" srcset="https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/02_js_wasm_graph-500x392.png?resize=500%2C392&amp;ssl=1 500w, https://i2.wp.com/kyu.io/wp-content/uploads/2018/06/02_js_wasm_graph-500x392.png?resize=300%2C235&amp;ssl=1 300w" sizes="(max-width: 500px) 100vw, 500px" data-recalc-dims="1" /></figure>



<p>현재, 웹 어셈블리는 모듈을 생성하기 위한 명령형(imperative) 자바스크립트 API 가 있다. 당신은 모든 과정을 위한 코드를 작성해야 한다. 파일을 읽어 오는 것에서부터 의존성을 만들어 내는 것까지. 이것은 어려운 일이다.</p>



<p>하지만 이제는 브라우저가 네이티브 모듈을 지원하기에, 선언적(declarative) API를 사용할 수 있다. 특히 우린 ES 모듈 API를 사용할 수 있다. 이것을 사용하면 ES 모듈을 사용하듯 웹 어셈블리 모듈 사용이 쉽게 된다.</p>



<figure class="wp-block-image"><img data-attachment-id="561" data-permalink="https://kyu.io/ko/%eb%9f%ac%ec%8a%a4%ed%8a%b8-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%eb%aa%a8%eb%93%a0-%ec%96%b8%ec%96%b4%ec%97%90%ec%84%9c-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%a5%bc-%eb%8d%94-%ec%a2%8b%ea%b2%8c/08_import_2-500x27/" data-orig-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/06/08_import_2-500x27.png?fit=500%2C27&amp;ssl=1" data-orig-size="500,27" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="08_import_2-500&#215;27" data-image-description="" data-medium-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/06/08_import_2-500x27.png?fit=300%2C16&amp;ssl=1" data-large-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/06/08_import_2-500x27.png?fit=500%2C27&amp;ssl=1" src="https://i1.wp.com/kyu.io/wp-content/uploads/2018/06/08_import_2-500x27.png?resize=500%2C27&#038;ssl=1" alt="" class="wp-image-561" srcset="https://i1.wp.com/kyu.io/wp-content/uploads/2018/06/08_import_2-500x27.png?resize=500%2C27&amp;ssl=1 500w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/06/08_import_2-500x27.png?resize=300%2C16&amp;ssl=1 300w" sizes="(max-width: 500px) 100vw, 500px" data-recalc-dims="1" /></figure>



<p>우린 이것을 표준화 하기 위해 TC39 그리고 웹 어셈블리 커뮤니티와 같이 일하고 있다.</p>



<p>그러나 우리가 ES 모듈 지원을 표준으로 할 필요는 없다. Node와 브라우저가 ES 모듈을 지원한다 해도, 개발자들은 여전히 번들러를 사용하고 싶을 것이다. 번들러는 모듈 파일들을 위한 네트워크 횟수를 줄여주기 때문이다. 이는 당신의 코드를 다운로드하는데 걸리는 시간이 적게 걸린다는 뜻이다.</p>



<p>번들러들은 여러 개의 파일에 흩어져 있는 모듈들을 하나의 파일로 묶고, 이것들을 로드하기 위해 상단에 약간의 런타임을 추가한다.</p>



<figure class="wp-block-image aligncenter"><img data-attachment-id="562" data-permalink="https://kyu.io/ko/%eb%9f%ac%ec%8a%a4%ed%8a%b8-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%eb%aa%a8%eb%93%a0-%ec%96%b8%ec%96%b4%ec%97%90%ec%84%9c-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%a5%bc-%eb%8d%94-%ec%a2%8b%ea%b2%8c/18_bundle_graph_02-500x296/" data-orig-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/06/18_bundle_graph_02-500x296.png?fit=500%2C296&amp;ssl=1" data-orig-size="500,296" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="18_bundle_graph_02-500&#215;296" data-image-description="" data-medium-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/06/18_bundle_graph_02-500x296.png?fit=300%2C178&amp;ssl=1" data-large-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/06/18_bundle_graph_02-500x296.png?fit=500%2C296&amp;ssl=1" src="https://i1.wp.com/kyu.io/wp-content/uploads/2018/06/18_bundle_graph_02-500x296.png?resize=500%2C296&#038;ssl=1" alt="" class="wp-image-562" srcset="https://i1.wp.com/kyu.io/wp-content/uploads/2018/06/18_bundle_graph_02-500x296.png?resize=500%2C296&amp;ssl=1 500w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/06/18_bundle_graph_02-500x296.png?resize=300%2C178&amp;ssl=1 300w" sizes="(max-width: 500px) 100vw, 500px" data-recalc-dims="1" /></figure>



<p>최소한 얼마간은, 번들러가 모듈들을 만들기 위해서는 여전히 그 자바스크립트 API를 사용해야 한다. 그러나 사용자들은 ES 모듈 문법으로 작성할 것이고, 그들은 그것들이 ES 모듈처럼 동작하리라 기대할 것이다. 우리는 번들러가 ES 모듈을 에뮬레이트 하기 쉽도록 웹 어셈블리에 기능을 추가해야 한다.</p>



<p>나는 ES 모듈을 웹 어셈블리 스펙에 연동하려는 노력에 대해 더 써보려 한다. 또한 앞으로 몇 달간 번들러와 번들러의 웹 어셈블리 지원을 위해 몰두할 예정이다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>결론</h2>



<p>러스트가 웹 언어로써 유용해지기 위해서는 자바스크립트 생태계와 잘 어울려야 한다. 그러기 위해서 우리는 몇 가지 할 일이 있고, 다행히도 그 일은 다른 언어에게도 도움이 될 것이다. 모든 언어에서 웹 어셈블리를 더 나아지게 만들고 싶은가? 우리 일을 도우시라. 우리도 당신이 이 일을 시작할 수 있도록 기꺼이 도울 테니. <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2><a href="http://code-cartoons.com/">Lin Clark</a>은</h2>



<p>Lin은 Mozilla Developer Relations 팀의 엔지니어이다. 그녀는 자바스크립트, 웹 어셈블리, 러스트 그리고 Servo를 다루며, 코드 카툰도 그린다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>
<p>The post <a rel="nofollow" href="https://kyu.io/ko/%eb%9f%ac%ec%8a%a4%ed%8a%b8-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%eb%aa%a8%eb%93%a0-%ec%96%b8%ec%96%b4%ec%97%90%ec%84%9c-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%a5%bc-%eb%8d%94-%ec%a2%8b%ea%b2%8c/">러스트 (그리고 모든 언어)에서 웹어셈블리를 더 좋게만들기</a> appeared first on <a rel="nofollow" href="https://kyu.io/ko">KYU.IO 🌾</a>.</p>
]]></content:encoded>
							<wfw:commentRss>https://kyu.io/ko/%eb%9f%ac%ec%8a%a4%ed%8a%b8-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%eb%aa%a8%eb%93%a0-%ec%96%b8%ec%96%b4%ec%97%90%ec%84%9c-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%a5%bc-%eb%8d%94-%ec%a2%8b%ea%b2%8c/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">506</post-id>	</item>
		<item>
		<title>프로그래시브 웹앱 성능에 대한 리엑트, 프리엑트 케이스 스터디 : Treebo</title>
		<link>https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/#utm_source=rss&#038;utm_medium=rss&#038;utm_campaign=%25ed%2594%2584%25eb%25a1%259c%25ea%25b7%25b8%25eb%259e%2598%25ec%258b%259c%25eb%25b8%258c-%25ec%259b%25b9%25ec%2595%25b1-%25ec%2584%25b1%25eb%258a%25a5%25ec%2597%2590-%25eb%258c%2580%25ed%2595%259c-%25ec%25bc%2580%25ec%259d%25b4%25ec%258a%25a4-%25ec%258a%25a4%25ed%2584%25b0%25eb%2594%2594-treebo</link>
				<comments>https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/#respond</comments>
				<pubDate>Wed, 30 May 2018 15:05:32 +0000</pubDate>
		<dc:creator><![CDATA[kyuwoo.choi]]></dc:creator>
				<category><![CDATA[번역]]></category>
		<category><![CDATA[프로그래시브 웹 앱]]></category>
		<category><![CDATA[자바스크립트]]></category>
		<category><![CDATA[전체]]></category>
		<category><![CDATA[리엑트]]></category>
		<category><![CDATA[서버 사이드 랜더링]]></category>
		<category><![CDATA[성능]]></category>
		<category><![CDATA[프리엑트]]></category>
		<category><![CDATA[웹팩]]></category>
		<category><![CDATA[코드 분할]]></category>
		<category><![CDATA[PWA]]></category>

		<guid isPermaLink="false">https://kyu.io/?p=448</guid>
				<description><![CDATA[<p>프론트엔드 리엑트 성능 케이스 스터디. Treebo는 장고로 만들어져 있던 기존 모바일 사이트의 성능을 개선하며 얻은 경험을 케이스 스터디로 공유한다. 프로그래시브 웹 앱의 성능 감사 포인트로 First Meaningful Paint, First Interactive, Consistenly Interactive 등을 기준으로, 서버사이드 렌더링, 코드 분할, HTML 스트리밍, 스타일 인라이닝 등의 적용이 어떻게 영향을 미치는지 알아본다.</p>
<p>The post <a rel="nofollow" href="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/">프로그래시브 웹앱 성능에 대한 리엑트, 프리엑트 케이스 스터디 : Treebo</a> appeared first on <a rel="nofollow" href="https://kyu.io/ko">KYU.IO 🌾</a>.</p>
]]></description>
								<content:encoded><![CDATA[
<ul>
	<li><strong><em>원글:</em></strong> <a href="https://medium.com/dev-channel/treebo-a-react-and-preact-progressive-web-app-performance-case-study-5e4f450d5299">https://medium.com/dev-channel/treebo-a-react-and-preact-progressive-web-app-performance-case-study-5e4f450d5299</a></li>
	<li><strong><em>원저자:</em></strong><em> Treebo: </em><a href="https://twitter.com/__lakshya"><em>Lakshya Ranganath</em></a><em>, Chrome: </em><a href="https://twitter.com/addyosmani"><em>Addy Osmani</em></a></li>
	<li><em><strong><em>번역:</em></strong><a href="https://twitter.com/kyuwoo_choi"><em>최규우</em></a></em>
	</li>
	<li><em><em><strong><em>역자 주:</em></strong>
		</em>
		</em>
	</li>
	<li><em><em><strong><em>&#8211; 이 번역 글은 원저자 중 하나인 <a href="https://twitter.com/addyosmani"><em>Addy Osmani</em></a><em>의 허락을 받아 게시했다.</em><br/> <em>&#8211; 직역이 어색한 경우 부득이 의역 또는 원문을 사용하였다.</em><br/> <em>&#8211; 또한 원문에서는 문어체로 사용되었으나 first-paint, time-to-interactive등 중요한 값을 이야기 하는 경우는 번역하지 않고 이탤릭으로 표현하였다.</em> </em>
		</strong>
		</em>
		</em>
	</li>
</ul>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<p>트리보(Treebo) 200억 달러의 가치를 지닌 여행 산업 부문에서 활동 중인, 인도의 가성비 좋은 호텔 체인이다. 트리보는 <a href="https://www.treebo.com/blog/google-io-2017-features-treebos-progressive-web-app/">최근</a> 새로운 PWA(Progressive Web App) 모바일 사이트를 배포했다. 처음에는 <a href="http://reactjs.com/">React</a>를 사용했지만, 나중에 production에서 <a href="http://preactjs.com/">Preact</a>로 바꿨다.</p>



<p>새로운 사이트는 이전의 모바일 사이트에 비해 <em>time-to-first-paint</em>이 70% 이상, <a href="https://github.com/WPO-Foundation/webpagetest/blob/master/docs/Metrics/TimeToInteractive.md"><em>time-to-interactive</em></a>는 31% 향상 되었다. 그리고 일반적인 고객이 사용하는 3G망에서 4초 이내에 로드되는 것을 확인했다. 새로운 웹 사이트는 WebPageTest의 slow 3G 에뮬레이션에서 5초 이내에 <em>interactive</em> 가능했다.</p>



<figure class="wp-block-image"><img data-attachment-id="455" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-result/" data-orig-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-result.png?fit=1000%2C342&amp;ssl=1" data-orig-size="1000,342" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-result" data-image-description="" data-medium-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-result.png?fit=300%2C103&amp;ssl=1" data-large-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-result.png?fit=720%2C246&amp;ssl=1" src="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-result.png?w=720&#038;ssl=1" alt="" class="wp-image-455" srcset="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-result.png?w=1000&amp;ssl=1 1000w, https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-result.png?resize=300%2C103&amp;ssl=1 300w, https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-result.png?resize=720%2C246&amp;ssl=1 720w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<p>React에서 Preact로 전환하는 것만으로 <em>time-to-interactive</em>가 15% 향상되었다. Treebo.com에 접속해서 직접 경험해 볼 수 있다, 하지만 오늘은 이 PWA를 성공시킨 기술 여행을 같이 떠나보기로 하자.</p>



<figure class="wp-block-image"><img data-attachment-id="456" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-treebo-app/" data-orig-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-treebo-app.png?fit=800%2C451&amp;ssl=1" data-orig-size="800,451" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-treebo-app" data-image-description="" data-medium-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-treebo-app.png?fit=300%2C169&amp;ssl=1" data-large-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-treebo-app.png?fit=720%2C406&amp;ssl=1" src="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-treebo-app.png?w=720&#038;ssl=1" alt="" class="wp-image-456" srcset="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-treebo-app.png?w=800&amp;ssl=1 800w, https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-treebo-app.png?resize=300%2C169&amp;ssl=1 300w, https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-treebo-app.png?resize=720%2C406&amp;ssl=1 720w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>성능개선 여행</h2>



<h3>이전 모바일 사이트</h3>



<p>트리보의 이전 모바일 사이트는 하나의(monolithic) Django 셋업으로 구동되었다. 사용자는 매 페이지 전환마다 서버의 응답을 기다려야 했다. 이 기존 셋업에서 <em>first-paint-time</em>은 1.5초, <em>first-meaningful-paint-time</em>이 5.9초, 그리고<em>first-interactive</em>는 6.5초가 걸렸었다.</p>



<figure class="wp-block-image"><img data-attachment-id="457" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-before/" data-orig-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-before.png?fit=1860%2C596&amp;ssl=1" data-orig-size="1860,596" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-before" data-image-description="" data-medium-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-before.png?fit=300%2C96&amp;ssl=1" data-large-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-before.png?fit=720%2C231&amp;ssl=1" src="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-before.png?w=720&#038;ssl=1" alt="" class="wp-image-457" srcset="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-before.png?w=1860&amp;ssl=1 1860w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-before.png?resize=300%2C96&amp;ssl=1 300w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-before.png?resize=1024%2C328&amp;ssl=1 1024w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-before.png?resize=720%2C231&amp;ssl=1 720w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-before.png?w=1440&amp;ssl=1 1440w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>기본적인 Single Page React app</h3>



<p>트리보는 첫 시작으로 React와 <a href="https://webpack.js.org/">Webpack</a>을 간단히 설정하여, 기존 웹사이트를 Single Page Application으로 다시 만들었다. 아래 코드는 실제 사용되었던 코드이다. 이 코드는 javascript와 CSS 번들을 한 덩어리씩 만들어 낸다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/lakshyaranganath/d809f1d8fb7c5702b875435599d78d68">Gist</a>.
</figure>



<p>이 설정으로 <em>first-paint</em> 4.8초, <em>first-interactive</em> 5.6초, 그리고 중요한 헤더 이미지가 그려지기 까지는 대략 7.2초가 걸리는 것을 경험했다.</p>



<figure class="wp-block-image"><img data-attachment-id="458" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-spa/" data-orig-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-spa.png?fit=1860%2C596&amp;ssl=1" data-orig-size="1860,596" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-spa" data-image-description="" data-medium-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-spa.png?fit=300%2C96&amp;ssl=1" data-large-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-spa.png?fit=720%2C231&amp;ssl=1" src="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-spa.png?w=720&#038;ssl=1" alt="" class="wp-image-458" srcset="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-spa.png?w=1860&amp;ssl=1 1860w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-spa.png?resize=300%2C96&amp;ssl=1 300w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-spa.png?resize=1024%2C328&amp;ssl=1 1024w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-spa.png?resize=720%2C231&amp;ssl=1 720w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-spa.png?w=1440&amp;ssl=1 1440w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>Server-side Rendering(SSR)</h3>



<p>다음으로 <em>first-paint</em>를 살짝 최적화하기 위해 서버 측 렌더링(SSR)을 시도했다. 잊지 말아야 할 것은 서버 사이드 렌더링은 공짜가 아니고, 무언가 하나를 희생해서 하나를 최적화하는 일이라는 점이다.</p>



<blockquote class="wp-block-quote">
	<p><a href="https://css-tricks.com/server-side-react-rendering/"><em>서버 사이드 렌더링</em></a><em>을 사용하면 서버는 응답으로 렌더링 된 페이지의 HTML을 준다. 그러므로 브라우저는 모든 javascript가 다운로드되어 실행될 때까지 기다리지 않고 렌더링을 시작할 수 있다.</em></p>
</blockquote>



<p>트리보는 React의 <code>renderToString()</code> 을 사용하여 컴포넌트를 HTML 문자열로 렌더링하고, 응용 프로그램의 초깃값을 설정했다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/lakshyaranganath/f4d08e0391e015ee295a53ff3ccabafe">Gist</a>.
</figure>



<p>이번 케이스에서 서버 SSR을 통해 <em>first-paint-time</em>이 1.1초, <em>first-meaningful-paint-time</em>은 2.4초로 줄었다. 이 향상은 사용자 입장에서 페이지가 얼마나 빠르게 준비되었는지 체감하고, 페이지 내용을 읽을 수 있는지를 말한다. SEO도 약간 나아졌다. 그러나 <em>time-to-interactive</em>에 상당히 부정적인 영향을 미치게 되었다.</p>



<figure class="wp-block-image"><img data-attachment-id="459" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-ssr/" data-orig-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-ssr.png?fit=2000%2C984&amp;ssl=1" data-orig-size="2000,984" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-ssr" data-image-description="" data-medium-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-ssr.png?fit=300%2C148&amp;ssl=1" data-large-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-ssr.png?fit=720%2C354&amp;ssl=1" src="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-ssr.png?w=720&#038;ssl=1" alt="" class="wp-image-459" srcset="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-ssr.png?w=2000&amp;ssl=1 2000w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-ssr.png?resize=300%2C148&amp;ssl=1 300w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-ssr.png?resize=1024%2C504&amp;ssl=1 1024w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-ssr.png?resize=720%2C354&amp;ssl=1 720w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-ssr.png?w=1440&amp;ssl=1 1440w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<p>사용자가 콘텐츠를 볼 수는 있지만, javascript가 부팅되는 동안 메인 스레드가 묶여 멈추게 된 것이다.</p>



<p>SSR을 사용하면 브라우저가 이전보다 훨씬 더 많은 HTML을 가져와 처리해야 한다. 그 다음 여전히 javascript를 가져오고, 파싱/컴파일하고 실행해야 한다. 뭐 결과적으로 더 많은 일을 하게 된 셈이다.</p>



<p>이 결과는 <em>first-interative</em>가 6.6초에 발생하여, 퇴보했다는 뜻이다.</p>



<p>SSR은 또한 성능이 낮은 기기에서 메인 스레드를 잠금으로써 TTI(Time-to-interactive)를 늦추기도 한다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>Code-splitting(코드 분할) &amp; route-based chunking(경로 기반 나누기)</h3>



<p>그다음으로 트리보는 <em>time-to-interactive</em> 수치를 낮추기 위해 route-based chunking을 하기로 했다.</p>



<blockquote class="wp-block-quote">
	<p><a href="https://gist.github.com/addyosmani/44678d476b8843fd981ff8011d389724"><em>Route-based chunking</em></a><em>은 경로의 코드를 필요에 따라 로드 할 수 있는 “덩어리(chunk)”로 </em><a href="https://webpack.js.org/guides/code-splitting/"><em>Code-splitting</em></a><em>하여, 경로에 따라 필요한 최소한의 코드만 제공하기 위함이다. 이렇게 하면 그것들이 사용된 세부 수준에 가깝게 가공된 리소스를 제공할 수 있다.</em></p>
</blockquote>



<p>여기서 트리보는 vendor dependencies, Webpack 런타임 메니페스트, 그리고 경로의 소스를 개별 chunk로 나누었다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/lakshyaranganath/bc4a63c13173a1908c764c67e1fb8df2">Gist</a>.
</figure>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/lakshyaranganath/563e6bda38f4f5b6293ceb32f38c85a2">Gist</a>.
</figure>



<p>이 작업은 <em>time-to-first-interactive</em>를 4.8초까지 낮춰 주었다. 어썸!</p>



<p>이 작업의 유일한 단점은 현재 경로의 javascript 다운로드가 초기 번들 실행이 완료된 후에야 시작한다는 것이었다. 이것이 최선이라 할 수는 없겠다.</p>



<p>그러나 일단은 긍정적인 결과다. route-based code-splitting과 그 결과를 놓고, 트리보는 조금 더 손을 봤다. chunk들을 비동기적으로 로드하기 위해서 <code>getComponent()</code>에서 Webpack <code>import()</code>를 호출하도록 React Router를 선언했다.</p>



<figure class="wp-block-image"><img data-attachment-id="460" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-code-splitting/" data-orig-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-code-splitting.png?fit=1860%2C752&amp;ssl=1" data-orig-size="1860,752" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-code-splitting" data-image-description="" data-medium-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-code-splitting.png?fit=300%2C121&amp;ssl=1" data-large-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-code-splitting.png?fit=720%2C291&amp;ssl=1" src="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-code-splitting.png?w=720&#038;ssl=1" alt="" class="wp-image-460" srcset="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-code-splitting.png?w=1860&amp;ssl=1 1860w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-code-splitting.png?resize=300%2C121&amp;ssl=1 300w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-code-splitting.png?resize=1024%2C414&amp;ssl=1 1024w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-code-splitting.png?resize=720%2C291&amp;ssl=1 720w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-code-splitting.png?w=1440&amp;ssl=1 1440w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>The PRPL 성능 패턴</h3>



<p>Route-based chunking은 보다 섬세한 배포와 캐싱을 위한 지능적 빌드로의 큰 한 걸음이다. 트리보는 이러한 빌드를 위한 영감을 얻고자 <a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/">PRPL 패턴</a>을 살펴봤다.</p>



<blockquote class="wp-block-quote">
	<p><em>PRPL은 앱이 배포되고 실행되는 성능에 중점을 두고 PWA를 구조화하고 제공하는 패턴이다.</em></p>
</blockquote>



<p>PRPL은 다음의 약자이다 :</p>



<ul>
	<li>Push: 초기 URL 경로에 대한 중요한 리소스를 푸시.</li>
	<li>Render: 초기 경로 렌더.</li>
	<li>Pre-cache: 앞의 경로를 미리 캐시.</li>
	<li>Lazy-load: 지연된 로딩과 요청에 따라 경로 생성.</li>
</ul>



<figure class="wp-block-image"><img data-attachment-id="461" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-prpl/" data-orig-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-prpl.png?fit=1000%2C415&amp;ssl=1" data-orig-size="1000,415" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-prpl" data-image-description="" data-medium-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-prpl.png?fit=300%2C125&amp;ssl=1" data-large-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-prpl.png?fit=720%2C299&amp;ssl=1" src="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-prpl.png?w=720&#038;ssl=1" alt="" class="wp-image-461" srcset="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-prpl.png?w=1000&amp;ssl=1 1000w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-prpl.png?resize=300%2C125&amp;ssl=1 300w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-prpl.png?resize=720%2C299&amp;ssl=1 720w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<p>“푸시 (Push)”패턴은 HTTP/2-서버/브라우저를 대상으로 하는 빌드는 번들링 하지 않기를 권장한다.(unbundled bulid) 이는 브라우저가 빠르게 <em>first-paint</em>하면서도 캐시를 최적화하기 위함이다. 이러한 리소스의 전달은 <code>&lt;link rel="preload"></code> 또는 <a href="https://developers.google.com/web/fundamentals/performance/http2/#server-push">HTTP/2 Push</a>를 통해 효율적으로 시작할 수 있다.</p>



<p>트리보는 <code>&lt;link rel="preload"/></code>를 사용하여 미리 현재 경로의 chunk를 미리 로드하기로 했다. 이것은 <em>first-interactive-time</em>을 줄이는데 영향을 미친다. 왜냐하면 초기 번들들이 실행된 이후, Webpack이 현재 경로의 chunk를 서버에서 가져오려 할 때면 이미 캐시에 있을 것이기 때문이다. 이 작업으로 시간이 조금 줄어들었고 <em>first-interactive</em>는 4.6초가 되었다.</p>



<figure class="wp-block-image"><img data-attachment-id="462" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-preload/" data-orig-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-preload.png?fit=1860%2C1020&amp;ssl=1" data-orig-size="1860,1020" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-preload" data-image-description="" data-medium-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-preload.png?fit=300%2C165&amp;ssl=1" data-large-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-preload.png?fit=720%2C395&amp;ssl=1" src="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-preload.png?w=720&#038;ssl=1" alt="" class="wp-image-462" srcset="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-preload.png?w=1860&amp;ssl=1 1860w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-preload.png?resize=300%2C165&amp;ssl=1 300w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-preload.png?resize=1024%2C562&amp;ssl=1 1024w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-preload.png?resize=720%2C395&amp;ssl=1 720w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-preload.png?w=1440&amp;ssl=1 1440w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<p>Preload의 한가지 단점은 크로스 브라우징이 되지 않는다는 것이다. 이제 Safari Tech Preview에는 링크 rel preload가 구현되었다. 올해 중에는 안착되었으면 좋겠다. 그리고 파이어폭스 역시 적용을 준비하고 있다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>HTML 스트리밍</h3>



<blockquote class="wp-block-quote">
	<p><code><em>renderToString()</em></code><em>을 사용하기 까다로운 점이 있는데, 이것이 동기적으로 실행되며, 서버 사이드 렌더링에서 성능 병목 현상이 될 수 있다는 것이다. 서버는 전체 HTML이 만들어질 때까지 응답을 보내지 않을 것이다. 대신, 웹 서버가 콘텐츠를 스트리밍 해주면 브라우저는 전체 응답이 완료되기 전에 페이지를 렌더링 할 수 있다. </em><a href="https://github.com/aickin/react-dom-stream"><em>react-dom-stream</em></a><em> 같은 프로젝트가 도움이 될 수 있다.</em></p>
</blockquote>



<p>체감 성능을 개선하고 점진적으로 렌더링 하는 느낌을 앱에 도입하기 위해 트리보는 HTML 스트리밍을 고려했다. 이들은 link rel preload 태그들을 담은 head 태그를 스트림 한다. 이는 CSS와 javascript를 일찍이 preload 하기 위해서다. 그런 다음 서버 사이드 렌더링을 수행하고 그 나머지를 브라우저로 보낸다.</p>



<p>이러한 이점으로 자원들의 다운로드가 초기에 시작되어, <em>first-paint</em>는 0.9초, <em>first-interactive</em>는 4.4초로 빨라졌다. 이제 이 앱의 consistently-<em>interactive</em>는 4.9/5초 정도가 되었다.</p>



<figure class="wp-block-image"><img data-attachment-id="463" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-html-streaming/" data-orig-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-html-streaming.png?fit=1860%2C1020&amp;ssl=1" data-orig-size="1860,1020" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-html-streaming" data-image-description="" data-medium-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-html-streaming.png?fit=300%2C165&amp;ssl=1" data-large-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-html-streaming.png?fit=720%2C395&amp;ssl=1" src="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-html-streaming.png?w=720&#038;ssl=1" alt="" class="wp-image-463" srcset="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-html-streaming.png?w=1860&amp;ssl=1 1860w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-html-streaming.png?resize=300%2C165&amp;ssl=1 300w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-html-streaming.png?resize=1024%2C562&amp;ssl=1 1024w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-html-streaming.png?resize=720%2C395&amp;ssl=1 720w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-html-streaming.png?w=1440&amp;ssl=1 1440w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<p>여기서 단점은 클라이언트와 서버 간 어느 정도 긴 시간 연결을 열어 두었기 때문에, 만약 대기 시간이 길어지게 되면 문제가 발생할 수 있다는 것이다. 트리보는 HTML 스트리밍을 하기 위해, <code>&lt;head></code>에 early chunk를 넣었다. 그다음에 메인 콘텐츠와 late chunk를 넣었다. 이 모든 것들은 그 페이지에 삽입된다. 아래와 같이 말이다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/lakshyaranganath/33142b2eae0806210ecead567dceab75">Gist</a>.
</figure>



<p>사실상, early chunk의 모든 스크립트 태그는 <code>rel=preload</code> 속성을 가진다. late chunk에는 서버에서 렌더링 된 html이 들어가며, 이외에도 상태를 포함하고 있거나 로드되어 실행될 javascript 같은 것들이 포함된다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>중요 경로 CSS 인라이닝(critical path
	<g class="gr_ gr_3 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="3" data-gr-id="3">css</g> inlining)</h3>



<blockquote class="wp-block-quote">
	<p><em>CSS 스타일 시트는 렌더링을 멈출 수 있다. 브라우저가 스타일 시트를 요청, 수신, 다운로드 및 파싱 할 때까지는 페이지가 비어있는 채로 방치될 수 있다. 브라우저가 처리해야 하는 CSS의 양을 줄이고, 페이지에 </em><a href="https://jonassebastianohlsson.com/criticalpathcssgenerator/#what-is"><em>critical path styles</em></a><em>를 인라인(HTML에 하드코딩) 하면, HTTP 요청이 제거되고, 페이지를 더 빨리 렌더링 할 수 있다.</em></p>
</blockquote>



<p>트리보는 현재 경로의 critical path CSS를 인라인하고, 나머지 CSS는 <a href="https://github.com/filamentgroup/loadCSS">loadCSS</a>를 사용하여 DOMContentLoaded에서 비동기적으로 로드했다.</p>



<p>렌더링을 멈추는 critical path link 태그를 제거하고, 주요 CSS만 몇 줄가량 인라인 하여, <em>first-paint-time</em>은 약 0.4초로 개선되었다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/lakshyaranganath/f7410178545720e260898de3b5054276">Gist</a>.
</figure>



<p>그리고 이번에는 인라인 한 스타일을 다운로드/파싱 하느라 걸리는 시간이 늘었다는 단점이 생겼다. javascript가 실행되기 전에 걸리는 시간의 증가로 <em>first-interactive</em>시간이 4.6초가 조금 넘게 되었다.</p>



<figure class="wp-block-image"><img data-attachment-id="464" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-css-inlining/" data-orig-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-css-inlining.png?fit=1860%2C1020&amp;ssl=1" data-orig-size="1860,1020" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-css-inlining" data-image-description="" data-medium-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-css-inlining.png?fit=300%2C165&amp;ssl=1" data-large-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-css-inlining.png?fit=720%2C395&amp;ssl=1" src="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-css-inlining.png?w=720&#038;ssl=1" alt="" class="wp-image-464" srcset="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-css-inlining.png?w=1860&amp;ssl=1 1860w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-css-inlining.png?resize=300%2C165&amp;ssl=1 300w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-css-inlining.png?resize=1024%2C562&amp;ssl=1 1024w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-css-inlining.png?resize=720%2C395&amp;ssl=1 720w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-css-inlining.png?w=1440&amp;ssl=1 1440w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>정적 자원 오프라인 캐싱</h3>



<blockquote class="wp-block-quote">
	<p><a href="https://developers.google.com/web/fundamentals/getting-started/primers/service-workers"><em>Service Worker</em></a><em>는 프로그래밍 가능한 네트워크 프락시로서 페이지의 네트워크 요청 처리 방법을 제어할 수 있다.</em></p>
</blockquote>



<p>트리보는 커스텀 오프라인 페이지과 정적 자원(static assets)의 <em>Service Worker</em>캐싱 기능을 추가했다. 트리보가 리소스 캐싱과 Service Worker를 등록하기 위해 <a href="https://www.npmjs.com/package/sw-precache-webpack-plugin">sw-precache-webpack-plugin</a>을 어떻게 사용했는지 아래에서 확인해 보자.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/lakshyaranganath/fb2b569631a5c6d5585951ae516302ea">Gist</a>.
</figure>



<figure class="wp-block-image"><img data-attachment-id="465" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-service-worker/" data-orig-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-service-worker.png?fit=1000%2C550&amp;ssl=1" data-orig-size="1000,550" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-service-worker" data-image-description="" data-medium-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-service-worker.png?fit=300%2C165&amp;ssl=1" data-large-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-service-worker.png?fit=720%2C396&amp;ssl=1" src="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-service-worker.png?w=720&#038;ssl=1" alt="" class="wp-image-465" srcset="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-service-worker.png?w=1000&amp;ssl=1 1000w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-service-worker.png?resize=300%2C165&amp;ssl=1 300w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-service-worker.png?resize=720%2C396&amp;ssl=1 720w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<p>CSS 및 JavaScript 번들과 같은 정적 자원 캐싱은 사용자 재 방문 시 페이지가 매번 네트워크를 사용하지 않고 디스크 캐시에서 로드 될 때 (거의) 즉시 로드된다는 것을 의미한다. 캐싱 헤더를 열심히 등록해 놓으면 디스크 캐시 적중률에 비례하는 효과를 가질 수 있지만, 오로지 Service Worker만이 오프라인 기능을 제공할 수 있다.</p>



<figure class="wp-block-image"><img data-attachment-id="466" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-service-worker-2/" data-orig-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-service-worker-2.png?fit=800%2C531&amp;ssl=1" data-orig-size="800,531" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-service-worker-2" data-image-description="" data-medium-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-service-worker-2.png?fit=300%2C199&amp;ssl=1" data-large-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-service-worker-2.png?fit=720%2C478&amp;ssl=1" src="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-service-worker-2.png?w=720&#038;ssl=1" alt="" class="wp-image-466" srcset="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-service-worker-2.png?w=800&amp;ssl=1 800w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-service-worker-2.png?resize=300%2C199&amp;ssl=1 300w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-service-worker-2.png?resize=720%2C478&amp;ssl=1 720w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<p>Service Worker에서 Cache API를 사용하여, javascript를 캐싱하면 (<a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201">JavaScript Start-up Performance</a>에서 다루었 듯) 스크립트를 V8의 코드 캐시에 초기 등록하는 좋은 효과가 있으므로, 재 방문 시 시작하는 데 약간의 시간 이득을 볼 수 있다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>React에서 Preact로 전환</h3>



<p>Preact는 React ES2015 API에 상응하는 3kb 용량의 대체 라이브러리이다. Preact는 React 호환 레이어를 통해 React 에코 시스템에서 동작하면서도 높은 성능을 제공하기 위해 만들어졌다.</p>



<p>Preact는 React의 Synthetic Event와 PropType validation을 제거하여 작은 용량만을 가진다. 또한 아래의 특징도 가지고 있다.</p>



<ul>
	<li>Virtual DOM을 직접 DOM에 diff</li>
	<li>for, class 같은 props 허용</li>
	<li>render에 props, state 전달</li>
	<li>표준 브라우저 이벤트 사용</li>
	<li>완전한 비동기 렌더링 지원</li>
	<li>기본적으로 subtree invalidation</li>
</ul>



<p>많은 PWA에서 React -> Preact로 전환을 통해, JS 번들 크기가 작아지고 응용 프로그램의 초기 javascript 부팅 시간이 단축됨을 경험했다. Lyft, Uber 및 Housing.com과 같은 최근의 PWA는 모두 production에서 Preact를 사용한다.</p>



<p>참고 : 작업은 React로 하면서도, Preact로 배포하고자 하는가? 이상적으로는 개발자, 시험 및 테스트 빌드에 preact 와 preact-compat을 사용해야 한다. 초기에 호환성 버그를 발견할 수 있기 때문이다. 만약 Webpack production 빌드에서만 preact 와 preact-compat를 사용하고자 하는 경우(Enzyme을 사용하는 경우라던가) 서버에 배포하기 전에 모든 것이 제대로 작동하는지 철저히 테스트해야 한다.</p>



<p>트리보의 경우 React에서 Preact로의 전환은 vendor bundle 크기를 140kb에서 100kb로 줄여 주었다.(압축한 사이즈 기준이며, 이후에도 용량은 압축한 상태를 기준으로 하겠다) 이것은 트리보가 대상으로 하는 모바일 하드웨어에서 <em>first-interactive time</em>을 4.6 초에서 3.9초로 줄이는 효과다.</p>



<figure class="wp-block-image"><img data-attachment-id="467" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-preact/" data-orig-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-preact.png?fit=1860%2C1020&amp;ssl=1" data-orig-size="1860,1020" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-preact" data-image-description="" data-medium-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-preact.png?fit=300%2C165&amp;ssl=1" data-large-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-preact.png?fit=720%2C395&amp;ssl=1" src="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-preact.png?w=720&#038;ssl=1" alt="" class="wp-image-467" srcset="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-preact.png?w=1860&amp;ssl=1 1860w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-preact.png?resize=300%2C165&amp;ssl=1 300w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-preact.png?resize=1024%2C562&amp;ssl=1 1024w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-preact.png?resize=720%2C395&amp;ssl=1 720w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-preact.png?w=1440&amp;ssl=1 1440w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<p>Webpack config에서 react와 react-dom의 alias로 <a href="https://github.com/developit/preact-compat">preact-compat</a>를 설정하여 같은 일을 할 수 있다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/lakshyaranganath/3a435a65e8a78957c97a27e9589ef38a">Gist</a>.
</figure>



<p>이 접근 방식의 단점은 트리보의 경우 Preact가 React의 생태계(플러그인들)와 동일하게 작동하도록 몇 가지 workaround를 해야 했다는 것이다.</p>



<p>React를 사용하려 한다면, 대부분(95%)의 경우 Preact를 사용할 수 있다. 나머지 5% 정도는 edge case를 해결하기 위해 버그를 신고해야 할지도 모른다.</p>



<p><em>참고 : WebPageTest는 현재 인도에서 직접 실제 Moto G4를 테스트할 수 있는 방법을 제공하지 않으므로 “Mumbai — EC2 — Chrome — Emulated Motorola G (gen 4) — 3GSlow — Mobile”설정에서 성능 테스트를 수행했다. 이 내용을 보고 싶다면 </em><a href="https://gist.github.com/addyosmani/d2fc259e1f1d19b64ae0fcbdfac025a2"><em>여기</em></a><em>를 참조하자.</em></p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h4>스켈레톤 스크린</h4>



<blockquote class="wp-block-quote">
	<p><em>“스켈레톤 스크린은 기본적으로 정보가 점차 로드되는 페이지의 빈 버전이다.” — “A skeleton screen is essentially a blank version of a page into which information is gradually loaded.”</em></p><cite><em>Luke Wroblewski</em></cite></blockquote>



<figure class="wp-block-image"><img data-attachment-id="468" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-skeleton/" data-orig-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-skeleton.png?fit=800%2C482&amp;ssl=1" data-orig-size="800,482" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-skeleton" data-image-description="" data-medium-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-skeleton.png?fit=300%2C181&amp;ssl=1" data-large-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-skeleton.png?fit=720%2C434&amp;ssl=1" src="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-skeleton.png?w=720&#038;ssl=1" alt="" class="wp-image-468" srcset="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-skeleton.png?w=800&amp;ssl=1 800w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-skeleton.png?resize=300%2C181&amp;ssl=1 300w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-skeleton.png?resize=720%2C434&amp;ssl=1 720w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<p>트리보는 preview enhanced components(각 컴포넌트의 스켈레톤 스크린 같은)를 사용하여 골격 화면을 구현한다. 이 접근법은 기본적으로 작은 구성 요소(텍스트, 이미지 등)가 미리보기를 표현할 수 있도록 개선하여, 컴포넌트에 필요한 원본 데이터가 없으면 대신 컴포넌트의 미리보기 버전이 표시되도록 했다.</p>



<p>예를 들어, 위의 목록 항목에서 호텔 이름, 도시 이름, 가격 등을 보면 <code>&lt;Text /></code>와 같은 타이포그래피 구성 요소를 사용하여 구현되어 있다. 그리고 추가적으로 미리 보기 기능을 위한 preview와 previewStyle 프로퍼티를 가지게 되었다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/addyosmani/fb053d71edcf002ccb88a278a2fec306">Gist</a>.
</figure>



<p>기본적으로 <code>hotel.name</code>이 존재하지 않으면 컴포넌트는 배경을 previewStyle로 전달된 크기의 회색으로 변경하고 다른 스타일은 그대로 적용한다. (previewStyle이 전달되지 않으면 너비는 기본적으로 100%가 된다).</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/lakshyaranganath/41a92ed1059756aed91dfe4afe42d60a">Gist</a>.
</figure>



<p>트리보는 미리 보기 모드로 전환하는 로직이 실제로 표시된 데이터와는 관계없기 때문에 이러한 접근 방식을 선호한다. “Incl. of all taxes” 부분을 살펴보면, 이는 정적 텍스트이므로 시작과 동시에 표시될 수 있지만, API가 호출되는 동안 가격이 보이지 않으므로 사용자에게 혼란스러워 보일 수 있다.</p>



<p>그러므로 정적 텍스트 “Incl. of all taxes”가 프리뷰로 보일지 여부는 다른 UI와 함께 가격 데이터가 로드 되었는지를 기준으로 한다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/addyosmani/65d5f5932241ba68473a55c09707a00e">Gist</a>.
</figure>



<p>이렇게하면 가격이 로드되는 동안 미리 보기 UI가 표시되고 API가 성공하면 모든 데이터를 볼 수 있다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>Webpack-bundle-analyzer</h2>



<p>이쯤에서 트리보는 손쉽게 최적화할 수 있는 것들이 무엇이 있는지 번들 분석을 해보고 싶었다.</p>



<p>참고 : 모바일에서 React와 같은 라이브러리를 사용한다면, 가져오는 vendor libraries에 대해 부지런히 조사해야 한다. 그렇게 하지 않으면 성능에 부정적인 영향을 미칠 수 있으니 말이다. 주어진 경로가 필요한 것만 로드하도록 vendor libraries를 더 잘 잘라보자.</p>



<p>트리보는 각 경로의 chunk에 포함된 모듈을 모니터링하고 번들의 크기를 추적하기 위해 <a href="https://www.npmjs.com/package/webpack-bundle-analyzer">webpack-bundle-analyzer</a>를 사용했다. 또한 moment.js 로케일 정보를 제거하고 깊은 곳에 있는 dependency library를 재사용하는 등 번들 사이즈를 줄이기 위해 이 도구를 사용했다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>webpack으로 moment.js 최적화하기</h3>



<p>트리보는 날짜 처리를 위해 moment.js에 많이 의존한다. moment.js를 가져 와서 Webpack과 함께 번들하면 번들은 디폴트로 모든 moment.js와 ~61.95kb의 로케일을 포함한다. 이렇게 하면 최종 vendor 번들 크기가 심각하게 커지게 된다.</p>



<figure class="wp-block-image"><img data-attachment-id="469" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-webpack-1/" data-orig-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-webpack-1.png?fit=800%2C793&amp;ssl=1" data-orig-size="800,793" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-webpack-1" data-image-description="" data-medium-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-webpack-1.png?fit=300%2C297&amp;ssl=1" data-large-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-webpack-1.png?fit=720%2C714&amp;ssl=1" src="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-webpack-1.png?w=720&#038;ssl=1" alt="" class="wp-image-469" srcset="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-webpack-1.png?w=800&amp;ssl=1 800w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-webpack-1.png?resize=150%2C150&amp;ssl=1 150w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-webpack-1.png?resize=300%2C297&amp;ssl=1 300w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-webpack-1.png?resize=720%2C714&amp;ssl=1 720w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<p>moment.js의 크기를 최적화하기 위해 사용할 수 있는
	<g class="gr_ gr_4 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="4" data-gr-id="4">webpack</g> 플러그인은 <a href="https://github.com/jmblog/how-to-optimize-momentjs-with-webpack">두 가지</a>가
	<g class="gr_ gr_5 gr-alert gr_gramm gr_inline_cards gr_run_anim Style multiReplace" id="5" data-gr-id="5">있다 :</g> <a href="https://webpack.js.org/plugins/ignore-plugin/">IgnorePlugin</a>, <a href="https://webpack.js.org/plugins/context-replacement-plugin/">ContextReplacementPlugin</a></p>



<p>트리보는 로케일 정보가 필요 없었기 때문에 IgnorePlugin으로 모든 로케일 파일을 제거하기로 했다.</p>



<p>new webpack.IgnorePlugin(/^./locale$/, /moment$/)</p>



<p>로케일이 제거되고, moment.js 압축한 번들 크기가 ~16.48kb로 떨어졌다.</p>



<figure class="wp-block-image"><img data-attachment-id="470" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-webpack-2/" data-orig-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-webpack-2.png?fit=800%2C967&amp;ssl=1" data-orig-size="800,967" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-webpack-2" data-image-description="" data-medium-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-webpack-2.png?fit=248%2C300&amp;ssl=1" data-large-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-webpack-2.png?fit=720%2C870&amp;ssl=1" src="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-webpack-2.png?w=720&#038;ssl=1" alt="" class="wp-image-470" srcset="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-webpack-2.png?w=800&amp;ssl=1 800w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-webpack-2.png?resize=248%2C300&amp;ssl=1 248w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-webpack-2.png?resize=720%2C870&amp;ssl=1 720w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<p>moment.js 로케일을 제거하는 효과로 가장 큰 개선점은 vendor 번들 크기가 ~179kb에서 ~119kb로 떨어졌다는 것이다. vendor 번들은 제일 먼저 로드되는 모듈이다. 이 중요한 번들에서 작지 않은 60kb가 줄어든 것이다. 이 모든 것이 <em>first-interaction-time</em>을 크게 줄여준다. <a href="https://github.com/jmblog/how-to-optimize-momentjs-with-webpack">여기</a>서 moment.js 최적화에 대해 더 자세히 읽어보자.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>기존의 깊은 곳에 있는 dependencies 재사용</h3>



<p>트리보는 초기에 “qs”모듈을 사용하여 쿼리 문자열 작업을 하고 있었다. 트리보는
	<g class="gr_ gr_4 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="4" data-gr-id="4">webpack</g>-bundle-analyzer를 사용하여 “react-router”에는 “history”모듈이 포함되어 있으며, 이 모듈에는 “query-string”모듈이 포함되어 있음을 찾아냈다.</p>



<figure class="wp-block-image aligncenter"><img data-attachment-id="471" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-dependency/" data-orig-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-dependency.png?fit=522%2C458&amp;ssl=1" data-orig-size="522,458" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-dependency" data-image-description="" data-medium-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-dependency.png?fit=300%2C263&amp;ssl=1" data-large-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-dependency.png?fit=522%2C458&amp;ssl=1" src="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-dependency.png?w=720&#038;ssl=1" alt="" class="wp-image-471" srcset="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-dependency.png?w=522&amp;ssl=1 522w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-dependency.png?resize=300%2C263&amp;ssl=1 300w" sizes="(max-width: 522px) 100vw, 522px" data-recalc-dims="1" /></figure>



<p>동일한 작업을 수행하는 두 개의 다른 모듈이 있었기 때문에, “qs”를 “history”모듈에 포함된 “query-string”(명시적으로 설치하여)을 사용하도록 소스 코드를 변경했다. 이제 번들에서 2.72kb(qs 모듈 크기)가 추가적으로 줄어들게 되었다.</p>



<p>트리보는 훌륭한 오픈 소스 시민 중 하나다. 그들은 많은 오픈 소스 소프트웨어를 사용해왔다. 그 답례로, 그들은 Webpack config 대부분을 오픈 소스로 공개했을 뿐 아니라, 그들이 production 환경에서 사용하고 있는 많은 설정을 포함하는 boilerplate를 공개했다. 요기에서 둘러보도록 하자 : <a href="https://github.com/lakshyaranganath/pwa">https://github.com/lakshyaranganath/pwa</a></p>



<figure class="wp-block-image"><img data-attachment-id="472" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-boilerplate/" data-orig-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-boilerplate.jpg?fit=800%2C442&amp;ssl=1" data-orig-size="800,442" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-boilerplate" data-image-description="" data-medium-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-boilerplate.jpg?fit=300%2C166&amp;ssl=1" data-large-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-boilerplate.jpg?fit=720%2C398&amp;ssl=1" src="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-boilerplate.jpg?w=720&#038;ssl=1" alt="" class="wp-image-472" srcset="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-boilerplate.jpg?w=800&amp;ssl=1 800w, https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-boilerplate.jpg?resize=300%2C166&amp;ssl=1 300w, https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-boilerplate.jpg?resize=720%2C398&amp;ssl=1 720w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<p>그들은 또한 공개한 오픈소스를 최신 정보로 유지하려고 노력하고 있다. 그 소스들이 업데이트 됨에 따라 당신은 또 다른 PWA 구현의 참조로서 활용할 수 있다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>결론과 미래</h2>



<p>트리보는 세상에 완벽한 응용 프로그램은 없다는 것을 알고 있기에, 사용자에게 제공되는 경험을 향상시키기 위해 많은 방법을 적극적으로 모색하고 있다. 그중 일부는 다음과 같다.</p>



<h3>이미지 lazy loading</h3>



<p>몇몇 분들은 network waterfall graph를 보고, 이미 웹 사이트 이미지 다운로드가 JS 다운로드와 대역폭을 두고 경쟁하고 있다는 것을 알아챘을 것이다.</p>



<figure class="wp-block-image"><img data-attachment-id="473" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-lazy-loading/" data-orig-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-lazy-loading.png?fit=1600%2C581&amp;ssl=1" data-orig-size="1600,581" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-lazy-loading" data-image-description="" data-medium-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-lazy-loading.png?fit=300%2C109&amp;ssl=1" data-large-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-lazy-loading.png?fit=720%2C262&amp;ssl=1" src="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-lazy-loading.png?w=720&#038;ssl=1" alt="" class="wp-image-473" srcset="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-lazy-loading.png?w=1600&amp;ssl=1 1600w, https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-lazy-loading.png?resize=300%2C109&amp;ssl=1 300w, https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-lazy-loading.png?resize=1024%2C372&amp;ssl=1 1024w, https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-lazy-loading.png?resize=720%2C261&amp;ssl=1 720w, https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-lazy-loading.png?w=1440&amp;ssl=1 1440w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<p>이미지 다운로드는 브라우저가 img 태그를 파싱 하자마자 트리거 되므로 JS 다운로드 중에 대역폭을 공유한다. 간단한 해결 방법은 이미지가 사용자의 뷰포트에 들어올 때만 이미지를 lazy load 하는 것으로, <em>time to interactive</em>이 크게 개선될 것이다.</p>



<p>Lighthouse는 오프 스크린 이미지 감사에서 이러한 문제를 잘 찾아준다.</p>



<figure class="wp-block-image aligncenter"><img data-attachment-id="474" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-lighthouse/" data-orig-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-lighthouse.png?fit=800%2C364&amp;ssl=1" data-orig-size="800,364" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-lighthouse" data-image-description="" data-medium-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-lighthouse.png?fit=300%2C137&amp;ssl=1" data-large-file="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-lighthouse.png?fit=720%2C328&amp;ssl=1" src="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-lighthouse.png?w=720&#038;ssl=1" alt="" class="wp-image-474" srcset="https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-lighthouse.png?w=800&amp;ssl=1 800w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-lighthouse.png?resize=300%2C137&amp;ssl=1 300w, https://i1.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-lighthouse.png?resize=720%2C328&amp;ssl=1 720w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>Dual Importing</h3>



<p>트리보는 또한 나머지 부분들의 CSS(critical CSS를 인라인 하고 남은)를 비동기로 로드하지만, 앱 덩치가 커지면서 장기적으로는 사용자에게 노출되지도 않는다는 것을 알아챘다. 더 많은 기능과 경로는 더 많은 CSS를 필요로 하고, 쓰이지 않는 그 모두를 다운로드하면 대역폭을 많이 낭비하게 된다.</p>



<p><a href="https://github.com/filamentgroup/loadCSS">LoadCSS</a>와 <a href="https://github.com/faceyspacey/babel-plugin-dual-import">babel-plugin-dual-import</a>를 결합한 접근법으로, javascript chunk에 따라 CSS chunk를 병렬로 다운로드하기 위해 <code>import(‘chunkpath’)</code>에서 특별 제작한 <code>importCss('chunkname')</code>를 명시적으로 호출한다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/lakshyaranganath/834e4e3efdba3766770849f688a275a8">Gist</a>.
</figure>



<p>이 새로운 접근 방식을 사용하면, 모든 CSS가 DOMContentLoaded에 다운로드되는 이전 방식과 달리 두 개의 병렬 비동기 요청(JS 요청 하나, CSS 요청 하나)이 경로가 바뀔 때 발생한다. 사용자가 경로에 방문할 때 꼭 필요한 CSS만 다운로드하기 때문에 효과적이다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>A/B 테스트</h3>



<p>트리보는 서버와 클라이언트 렌더링 동안 사용자 필요에 따라 변형된 것을 다운로드 시켜주기 위해 서버 사이드 렌더링과 code splitting에서 AB 테스트 방식을 구현하고 있다. (트리보는 자신들이 이것을 어떻게 해결하고 있는지 블로그 내용을 계속 게시할 것이다).</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>Eager Loading</h3>



<p>트리보는 초기 페이지 로드시 앱의 모든 split chuck를 항상 로드하는 방식을 바꾸고 싶어 한다. 중요한 리소스 다운로드할 때 대역폭 경합을 피할 수 있을 테니 말이다. 또한 Service Worker로 캐싱 하지 않아 재방문시 발생하는 대역폭은, 특별히 모바일 사용자에게 귀중한 대역폭의 낭비이다. 만약 Consistently Interactive와 같은 지표를 트래보가 얼마나 잘 수행하고 있는지 살펴보면 여전히 개선의 여지가 많이 있다.</p>



<figure class="wp-block-image"><img data-attachment-id="475" data-permalink="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/performance-case-study-eager-loading/" data-orig-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-eager-loading.png?fit=800%2C133&amp;ssl=1" data-orig-size="800,133" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="performance-case-study-eager-loading" data-image-description="" data-medium-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-eager-loading.png?fit=300%2C50&amp;ssl=1" data-large-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-eager-loading.png?fit=720%2C120&amp;ssl=1" src="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-eager-loading.png?w=720&#038;ssl=1" alt="" class="wp-image-475" srcset="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-eager-loading.png?w=800&amp;ssl=1 800w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-eager-loading.png?resize=300%2C50&amp;ssl=1 300w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/performance-case-study-eager-loading.png?resize=720%2C120&amp;ssl=1 720w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" /></figure>



<p>이것들은 트리보가 개선을 위해 실험하고 있는 영역이다. 하나의 예는 버튼의 ripple 애니메이션 동안 다음 경로의 chunk를 eager load 하는 것이다. Treebo를 클릭하면 webpack <a href="https://webpack.js.org/guides/code-splitting/#dynamic-imports">dynamic import()</a>가 다음 경로의 chunk 항목을 호출하고, 그동안 setTimeout으로 경로 전환을 지연한다. 트리보는 또한 다음 경로의 chunk가 느린 3g 네트워크에서 주어진 400ms 타임아웃 내에 충분히 다운로드될 수 있도록 충분히 작게 만드는 노력을 하고 있다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>마치며</h2>



<p>이 글을 쓰는 동안 재미있었다. 물론 더 많은 일이 있겠지만, 트래보의 성능개선 이야기가 여러분께 재미있었으면 좋겠다. <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /> 트위터에서 @addyosmani 와 @__lakshya(언더 스코어 2개 맞다)로 우리를 찾을 수 있으니 여러분의 생각을 들려주었으면 좋겠다.</p>
<p>The post <a rel="nofollow" href="https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/">프로그래시브 웹앱 성능에 대한 리엑트, 프리엑트 케이스 스터디 : Treebo</a> appeared first on <a rel="nofollow" href="https://kyu.io/ko">KYU.IO 🌾</a>.</p>
]]></content:encoded>
							<wfw:commentRss>https://kyu.io/ko/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%ec%8b%9c%eb%b8%8c-%ec%9b%b9%ec%95%b1-%ec%84%b1%eb%8a%a5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%84%b0%eb%94%94-treebo/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">448</post-id>	</item>
		<item>
		<title>웹 컴포넌트(5) — lit-html로 리엑트처럼 코딩하기</title>
		<link>https://kyu.io/ko/%ec%9b%b9-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b85%e2%80%8a-%e2%80%8alit-html%eb%a1%9c-%eb%a6%ac%ec%97%91%ed%8a%b8%ec%b2%98%eb%9f%bc-%ec%bd%94%eb%94%a9%ed%95%98%ea%b8%b0/#utm_source=rss&#038;utm_medium=rss&#038;utm_campaign=%25ec%259b%25b9-%25ec%25bb%25b4%25ed%258f%25ac%25eb%2584%258c%25ed%258a%25b85%25e2%2580%258a-%25e2%2580%258alit-html%25eb%25a1%259c-%25eb%25a6%25ac%25ec%2597%2591%25ed%258a%25b8%25ec%25b2%2598%25eb%259f%25bc-%25ec%25bd%2594%25eb%2594%25a9%25ed%2595%2598%25ea%25b8%25b0</link>
				<comments>https://kyu.io/ko/%ec%9b%b9-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b85%e2%80%8a-%e2%80%8alit-html%eb%a1%9c-%eb%a6%ac%ec%97%91%ed%8a%b8%ec%b2%98%eb%9f%bc-%ec%bd%94%eb%94%a9%ed%95%98%ea%b8%b0/#comments</comments>
				<pubDate>Wed, 30 May 2018 15:03:31 +0000</pubDate>
		<dc:creator><![CDATA[kyuwoo.choi]]></dc:creator>
				<category><![CDATA[웹 컴포넌트]]></category>
		<category><![CDATA[자바스크립트]]></category>
		<category><![CDATA[전체]]></category>
		<category><![CDATA[리엑트]]></category>
		<category><![CDATA[템플릿 리터럴]]></category>
		<category><![CDATA[쉐도우 돔]]></category>
		<category><![CDATA[커스텀 엘리먼트]]></category>
		<category><![CDATA[lit-html]]></category>
		<category><![CDATA[UseThePlatform]]></category>

		<guid isPermaLink="false">https://kyu.io/?p=434</guid>
				<description><![CDATA[<p>커스텀 엘리먼트와 쉐도우 돔 그리고 lit-html을 사용하여 웹 컴포넌트 TODO앱을 만들어 본다. 이 방식으로 여러분은 익숙한 리엑트와 같은 방식으로 웹 컴포넌트 앱을 작성할 수 있다. lit-html은 단지 25kb를 차지할 뿐이며, 모든 코드는 #useThePlatform의 모토를 따라 브라우저 표준을 따른다.</p>
<p>The post <a rel="nofollow" href="https://kyu.io/ko/%ec%9b%b9-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b85%e2%80%8a-%e2%80%8alit-html%eb%a1%9c-%eb%a6%ac%ec%97%91%ed%8a%b8%ec%b2%98%eb%9f%bc-%ec%bd%94%eb%94%a9%ed%95%98%ea%b8%b0/">웹 컴포넌트(5) — lit-html로 리엑트처럼 코딩하기</a> appeared first on <a rel="nofollow" href="https://kyu.io/ko">KYU.IO 🌾</a>.</p>
]]></description>
								<content:encoded><![CDATA[
<ul>
	<li><a href="https://kyu.io/ko/%ec%9b%b9-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b81-keep-calm-and-usetheplatform/">웹 컴포넌트(1) — Keep calm and #UseThePlatform</a></li>
	<li><a href="https://kyu.io/ko/%ec%9b%b9-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b82-%ec%bb%a4%ec%8a%a4%ed%85%80-%ec%97%98%eb%a6%ac%eb%a8%bc%ed%8a%b8/">웹 컴포넌트(2) — 커스텀 엘리먼트</a></li>
	<li><a href="https://kyu.io/ko/%ec%9b%b9-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b83%e2%80%8a-%e2%80%8a%ec%89%90%eb%8f%84%ec%9a%b0-%eb%8f%94shadow-dom/">웹 컴포넌트(3) — 쉐도우 돔(#SHADOW DOM)</a></li>
	<li><a href="https://kyu.io/ko/%ec%9b%b9-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b84%e2%80%8a-%e2%80%8atemplate-element-html-imports/">웹 컴포넌트(4) — 템플릿 엘리먼트(TEMPLATE ELEMENT)와 HTML IMPORTS</a><br/></li>
</ul>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<p>이번 글은 웹 컴포넌트 소개 연재 5번째로 웹 컴포넌트를 react처럼 코딩하기를 해보겠다. 사용하는 예제 전체 코드는 <a href="https://github.com/kyuwoo-choi/todo-web-components">Todo Web Components</a>에서 참조할 수 있다. 이 예제를 통해 지난 연재에서 알아보았던 커스텀 엘리먼트, 쉐도우 돔 그리고 <a href="https://github.com/PolymerLabs/lit-html">lit-HTML</a>을 사용하여 웹 컴포넌트 애플리케이션을 어떻게 만들 수 있는지 확인해보자.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>웹 컴포넌트 TODO APP</h2>



<p>글을 읽기 전에 아래의 링크에서 예제 페이지를 열어두고 시작하자.</p>



<ul>
	<li><a href="https://github.com/kyuwoo-choi/todo-web-components"><em>Todo Web Components 앱 저장소</em></a></li>
	<li><em>﻿<a href="https://kyuwoo-choi.github.io/todo-web-components/"><em>Todo Web Components 앱 데모</em></a>
		</em>
	</li>
</ul>



<p>이번 글에서 사용하는 <a href="https://github.com/kyuwoo-choi/todo-web-components">Todo Web Components</a> 예제는 <a href="http://todomvc.com/">TodoMVC</a>를 따라 만들었다. <a href="http://todomvc.com/">TodoMVC</a>는 수 많은 프론트엔드 프레임워크 중에 선택을 해야 하는 개발자를 돕기 위해 만들어졌다. 이곳에서 같은 TODO 앱을 각 프레임워크를 이용하여 어떻게 구현할 수 있는지, 예제들을 확인하여 비교해 볼 수 있다. <a href="http://todomvc.com/">TodoMVC</a> 예제는 어떠한 프레임워크의 강점을 보여주기 위해 지나치게 간략화되고 편중된 예제가 아니라, 어느 정도 실제 애플리케이션을 구성하는 것과 같이 구성되어 있으므로 객관적으로 비교해 볼 수 있는 장점이 있다. 위의 이유로 예제 코드가 이번 설명에서 필요한 것보다 다소 길다. 그러므로 이번 글에서는 전체 코드가 아닌 일부 코드들만 떼어 설명하도록 하겠다. 또한, 이 예제는 준비가 되면 <a href="http://todomvc.com/">TodoMVC</a>에 제출할 예정이므로, 여러분이 코드 리뷰를 겸해주어도 좋겠다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>프로젝트 구조</h3>



<p>이 프로젝트는 지난 연재에서 알아보았던 커스텀 엘리먼트, 쉐도우 돔 그리고 lit-HTML을 사용하고 있다. 커스텀 엘리먼트를 사용하기 위해서는 ES6 Class 문법이 필수이다. 더 많은 브라우저를 지원하기 위해서 babel을 통해 ES5 문법으로 src에 있는 소스 파일들을 트랜스파일링 하며, 그 툴링은 webpack을 통해 dist에 저장하고 있다. 프로젝트 디렉터리 구조는 아래와 같다.</p>



<ul>
	<li><em>src</em>: 소스 파일들</li>
	<li><em>components</em>: 커스텀 엘리먼트들</li>
	<li><em>todoApp.js</em>: 애플리케이션 메인 커스텀 엘리먼트</li>
	<li><em>todoInput.js</em>: 상단 TODO 아이템 입력창</li>
	<li><em>todoItem.js</em>: 입력된 하나의 TODO</li>
	<li><em>todoList.js</em>: todoItem들을 리스트 형태로 보여줌</li>
	<li><em>todoToolbar</em>: 하단 툴바. 남은 TODO 개수, 상태에 따른 TODO 아이템 노출 토글 버튼들</li>
	<li><em>libs</em>: 이외의 소스들</li>
	<li><em>actions.js</em>: redux-zero 액션들. TODO 앱에서 사용되어 상태를 업데이트 할 수 있는 액션들이 정의</li>
	<li><em>litRender.js</em>: lit-HTML 컴포넌트 헬퍼. 커스텀 엘리먼트에서 <code>invalidate</code>를 호출하면 화면 업데이트를 스케줄</li>
	<li><em>store.js</em>: redux-zero 스토어, 기본값 설정</li>
	<li><em>index.js</em>: index</li>
	<li><em>index.html</em>: index HTML</li>
	<li><em>webpack.config.js</em>: 웹팩 설정</li>
	<li><em>package.json</em>: 패키지 설정과 스크립트</li>
</ul>



<figure class="wp-block-image"><img data-attachment-id="442" data-permalink="https://kyu.io/ko/%ec%9b%b9-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b85%e2%80%8a-%e2%80%8alit-html%eb%a1%9c-%eb%a6%ac%ec%97%91%ed%8a%b8%ec%b2%98%eb%9f%bc-%ec%bd%94%eb%94%a9%ed%95%98%ea%b8%b0/webcomponents_todo_app_components/" data-orig-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/webcomponents_todo_app_components.png?fit=800%2C470&amp;ssl=1" data-orig-size="800,470" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="webcomponents_todo_app_components" data-image-description="" data-medium-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/webcomponents_todo_app_components.png?fit=300%2C176&amp;ssl=1" data-large-file="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/webcomponents_todo_app_components.png?fit=720%2C423&amp;ssl=1" src="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/webcomponents_todo_app_components.png?w=720&#038;ssl=1" alt="" class="wp-image-442" srcset="https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/webcomponents_todo_app_components.png?w=800&amp;ssl=1 800w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/webcomponents_todo_app_components.png?resize=300%2C176&amp;ssl=1 300w, https://i0.wp.com/kyu.io/wp-content/uploads/2018/05/webcomponents_todo_app_components.png?resize=720%2C423&amp;ssl=1 720w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" />
	<figcaption>컴포넌트 구조</figcaption>
</figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>프로젝트 사용</h2>



<p>이번 글을 따라가는데 반드시 로컬에서 이 프로젝트를 실행해야 하는 것은 아니므로, 원치 않는 독자는 이 섹션을 넘어가도 무방하다. 위에서 알려준 <a href="https://github.com/kyuwoo-choi/todo-web-components">Todo Web Components 앱 저장소</a>와 <a href="https://github.com/kyuwoo-choi/todo-web-components">데모 페이지</a>만 참조해도 충분하다.</p>



<p>로컬에서 확인하고자 한다면 우선 git 커맨드로 <a href="https://github.com/kyuwoo-choi/todo-web-components">Todo Web Components 앱 저장소</a>에서 전체 프로젝트를 가져오자.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/8697da5a0ff3df2e8811e935594a9ee8">Gist</a>.
</figure>



<p>그다음 <code>yarn</code> 커맨드로 필요한 디펜던시 패키지들을 설치한다. <code>yarn</code>이 설치되어 있지 않다면 물론 <code>npm</code>을 사용하여도 무방하다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/8697da5a0ff3df2e8811e935594a9ee8">Gist</a>.
</figure>



<p>이제 필요한 준비가 끝났으므로 <em>package.json</em>에 정의된 <code>serve</code> 스크립트를 실행하여 브라우저로 확인해보자. <a href="http://localhost:8080/">http://localhost:8080/</a></p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/8697da5a0ff3df2e8811e935594a9ee8">Gist</a>.
</figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>index.html: 커스텀 엘리먼트 사용</h2>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/d67a9d540c3276e9d90a56a9b15b46d6">Gist</a>.
</figure>



<p><code>&lt;head></code>에는 트랜스파일 된 <em>TodoApp.js</em>파일 그리고 두 개의 웹 컴포넌트 폴리필 <em>custom-elements-es5-adapter.js</em>, <em>webcomponents-sd-ce.js</em> 스크립트가 포함되었다. 현재 크롬과 사파리 브라우저에서는 폴리필 없이 확인할 수 있으며, 두 폴리필을 사용하면 파이어폭스, 엣지, IE11도 지원할 수 있다.</p>



<p><a href="https://github.com/WebComponents/webcomponentsjs">웹 컴포넌트 폴리필</a> 중 이 프로젝트에서는 쉡도우 돔(Shadow DOM), 커스텀 엘리먼트(Custom Elements)를 사용하므로, <em>webcomponents-sd-ce.js</em>를 선택했다. (폴리필 파일 이름에 포함된 <code>sd</code>, <code>ce</code>는 <code>Shadow DOM</code>, <code>Custom Elements</code>의 약자이다) 또한 커스텀 엘리먼트가 필요로 하는 ES6문법을 ES5문법으로 트랜스파일하고 있으므로 <em>custom-elements-es5-adapter.js</em>가 필요하다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/9825446004ae15123a00a0e965c29b39">Gist</a>.
</figure>



<p><code>﻿&lt;body></code>는 간략히 <code>&lt;todo-app></code>태그를 포함하고 있다. 이 태그는 <em>TodoApp.js</em>에 포함된 커스텀 엘리먼트가 정의하고 있다. 이처럼 커스텀 엘리먼트를 사용하는 입장에서는 자바스크립트 파일과 태그를 하나를 사용하는 것뿐으로 매우 편리하다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>todoApp.js: 애플리케이션 컴포넌트</h2>



<p><em>todoApp.js</em>는 <em>src/components</em>에서 찾을 수 있으며, 위 <em>index.html</em>에서 사용한 <code>&lt;todo-app></code>태그를 커스텀 엘리먼트로 정의한다. 더불어 하나의 애플리케이션으로서 필요한 API도 제공하고 있다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>imports</h3>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/8f904e487847da5bcaa7621a62f36900">Gist</a>.
</figure>



<p>코드 상단에서 필요한 디펜던시들을 가져온다. html렌더링에 필요한 lit-HTML과 이것을 커스텀 엘리먼트에서 편하게 사용하기 위해 정의한 <code>LitRender</code>믹스인 헬퍼. 애플리케이션 상태와 액션을 관리하기 위한 Redux-Zero(Redux 미니미라고 생각하면 된다) <code>store</code>와 <code>add</code>, <code>toggle</code>같은 액션들. 마지막으로 애플리케이션의 컴포넌트를 구성하는 <code>todoInput</code>, <code>todoToolbar</code>, <code>todoList</code>를 가져온다.</p>



<p><code>import './todoInput'</code>의 문법이 의문스러운 독자도 있을 것이라 본다. 이것은 가져온 모듈을 저장하지 않고 모듈을 로드만 위한 방법이다. <code>import TodoInput from './todoInput'</code>도 올바른 사용법이지만, 코드에서 <code>TodoInput</code>을 사용하지 않는 경우 웹팩이 Tree Shaking으로 디펜던시를 제거해 버린다. 이를 피하기 위한 문법이며, 딱히 컴포넌트 클래스들을 직접 사용하지도 않으므로 현재의 형태가 되었다고 이해하면 되겠다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>커스텀 엘리먼트 클래스</h3>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/84e8be91972a162b0fc2b8e7afa81d66">Gist</a>.
</figure>



<p>ES6 class문법으로 <code>TodoApp</code> 커스텀 엘리먼트를 정의한다. 이 클래스는 <code>HTMLElement</code>과 <code>LitRender</code>믹스인을 확장한다. <code>constructor</code>에서는 쉐도우 돔을 <code>open</code>모드로 이 커스텀 엘리먼트에 생성한다. 마지막으로 <code>invalidate()</code>를 하고 있는데, 이는 <code>LitRender</code>에 정의된 함수로 이 컴포넌트를 렌더링 하도록 해준다.<code>LitRender</code>와 <code>invalidate</code>에 대해서는 이후 더 자세히 알아보고, 여기서는 직관적으로 <code>invalidate</code>의 효용만 떠올리면 충분하다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>커스텀 엘리먼트 API</h3>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/ba17d324fe5450f2221568510d406fa9">Gist</a>.
</figure>



<p>API를 정의한다. <a href="https://github.com/kyuwoo-choi/todo-web-components">데모 페이지</a> 혹은 로컬 서버 <a href="http://localhost:8080%EC%97%90/">http://localhost:8080에</a> 접속해서 API를 사용해보자.<code>document.querySelector('todo-app').add('hello')</code>, <code>document.querySelector('todo-app').length</code> 의 커맨드로 사용할 수 있다. 편하지 않은가?! 우리는 커스텀 엘리먼트 클래스에 함수를 정의해 주는 것으로 이처럼 직관적인 API를 제공해 줄 수 있다.</p>



<figure class="wp-block-image aligncenter"><img data-attachment-id="443" data-permalink="https://kyu.io/ko/%ec%9b%b9-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b85%e2%80%8a-%e2%80%8alit-html%eb%a1%9c-%eb%a6%ac%ec%97%91%ed%8a%b8%ec%b2%98%eb%9f%bc-%ec%bd%94%eb%94%a9%ed%95%98%ea%b8%b0/webcomponents_todo_app_api/" data-orig-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/webcomponents_todo_app_api.png?fit=800%2C660&amp;ssl=1" data-orig-size="800,660" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="webcomponents_todo_app_api" data-image-description="" data-medium-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/webcomponents_todo_app_api.png?fit=300%2C248&amp;ssl=1" data-large-file="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/webcomponents_todo_app_api.png?fit=720%2C594&amp;ssl=1" src="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/webcomponents_todo_app_api.png?w=720&#038;ssl=1" alt="" class="wp-image-443" srcset="https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/webcomponents_todo_app_api.png?w=800&amp;ssl=1 800w, https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/webcomponents_todo_app_api.png?resize=300%2C248&amp;ssl=1 300w, https://i2.wp.com/kyu.io/wp-content/uploads/2018/05/webcomponents_todo_app_api.png?resize=720%2C594&amp;ssl=1 720w" sizes="(max-width: 720px) 100vw, 720px" data-recalc-dims="1" />
	<figcaption>엘리먼트가 직접 API를 제공한다.</figcaption>
</figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>HTML 렌더링</h3>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/6c7c164dbef558ef6c7e75de89bde91f">Gist</a>.
</figure>



<p><code>﻿render</code> 함수는 위의 <code>invalidate</code>와 쌍을 이루는 함수로 <code>LitRender</code>를 통해 호출된다. 이 함수가 호출되면 lit-HTML의 <code>html</code> Template Literal 함수를 사용해 이 커스텀 엘리먼트의 하위 엘리먼트를 렌더링한다. 오오! 제법 React 같은 모양새가 되었지 않은가?</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>커스텀 엘리먼트 등록</h3>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/c3efd07c93ca2e0f6a88e285f5f39b2f">Gist</a>.
</figure>



<p>마지막으로 커스텀 엘리먼트를 정의한 클래스를 <code>todo-app</code>태그로 정의한다. 커스텀 엘리먼트를 작성할 때 <code>todo-app</code>처럼 태그 이름은 반드시 <code>-</code>를 하나 이상 포함해야 함을 기억하자. 브라우저는 HTML을 파싱하다 <code>-</code>를 포함한 태그를 만나면 이것이 커스텀 엘리먼트로 쓰일 수 있다는 것을 알아채 처리할 수 있다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>litRender.js</h2>



<p><em>litRender.js</em>는 <em>src/libs</em> 밑에서 찾을 수 있으며, 이 애플리케이션의 각 컴포넌트들의 렌더링을 돕는다. 각 컴포넌트들은 <code>class SomeComponent extends LitRender(HTMLElement)</code>의 형식으로 <code>litRender</code>를 믹스인 확장하여 사용한다. 한번에 여러번 내용이 업데이트되는 경우 매번 렌더링 하지 않고, 모았다가 한번에 렌더링 하는 것으로 성능 향상에 도움 주기 위한 코드이다. 이것을 확장하는 컴포넌트에서 <code>this.invalidate</code>를 호출하면 컴포넌트에 정의된 <code>render</code> 함수의 호출이 예약된다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/b00b1117a8a7d4b0251c465d33d215e0">Gist</a>.
</figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>컴포넌트들: todoList.js, todoItem.js, todoInput.js, todoToolbar.js</h2>



<p>Todo 애플리케이션을 구성하는 개별 컴포넌트들을 정의한다. <em>todoApp.js</em> 코드를 보면 <code>&lt;todo-list></code>, <code>&lt;todo-toolbar></code>등의 형태로 사용하는 것을 확인할 수 있다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>connectedCallback / disconnectedCallback</h3>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/1d59476e5b4423d9e213548cbb540c4a">Gist</a>.
</figure>



<p><code>TodoApp</code>에서는 사용되지 않았던 <code>connectedCallback</code>, <code>disconnectedCallback</code>이 보인다. 이 함수들은 커스텀 엘리먼트 콜백으로 이 엘리먼트가 DOM에 <em>attach</em>, <em>detach</em>될 때 호출된다. 따라서 이 콜백 함수들이 DOM 이벤트 핸들러를 할당/해제하는데 최적의 장소이다. 만약 적절히 핸들러를 해제해주지 않으면 메모리 누수를 경험할 수 있으니 잊지 말자.</p>



<p><code>onClick</code> 핸들러는 조건에 따라 <code>toggle</code>, <code>remove</code> Redux 액션을 수행하고 있다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>render / html</h3>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/6cae381c7a11551dff9e101c23241a3c">Gist</a>.
</figure>



<p><code>render</code>함수가 조금 복잡졌다. lit-HTML <code>html</code> 템플릿 리터럴 함수는 템플릿 리터럴을 인자로 받아 HTMLTemplateElement를 포함하는 오브젝트 TemplateResult를 반환한다. <code>${something}</code>에는 변수나 상수표현 이외에도 TemplateResult, Promise, Array, Iterables 등을 지원한다. 여러 방식을 조합하여 자유롭게 템플릿을 구성하면 된다. 위의 코드에서도 템플릿이 복잡해 보이지 않게 <code>&lt;style></code>, <code>&lt;input></code>등을 분리한 후, <code>html</code> 템플릿 리터럴을 중복하여 사용하고 있다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h3>객체의 전달</h3>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/bb329cfce5373fa09b5a553fd98b149f">Gist</a>.
</figure>



<p>lit-HTML의 확장기능을 사용하면 <code>html`&lt;todo-item todo=${todo}>&lt;/todo-item>`</code>처럼 다른 커스텀 엘리먼트에 <code>object</code>를 전달할 수 있다. Attribute는 <code>html`&lt;todo-item name$=${someText}>&lt;/todo-item>`</code>로 이름 뒤에 <code>$</code>를 붙이면 된다. 받아오는 <code>object</code>를 사용하는 <em>todoItems.js</em>에서는 평범하게 <code>this.todo</code>로 접근하면 된다. 이 코드에서는 <em>getter</em>를 만들어서 값이 할당되면 자동으로 <code>invalidate</code>를 호출하여 커스텀 엘리먼트가 업데이트 되도록 했다. 여기서 한가지 짚고 넘어갈 점은 lit-HTML의 작동방식이 충분히 성능을 고려해 만들어 졌다는 것이다. 이것은 템플릿 리터럴로 전달된 값을 기억하고 있다가, 전달된 값이 다를 경우에만 컴포넌트를 업데이트한다. 데모에서 이 코드가 동작하는 것을 확인해보면 추가/삭제/변경된 아이템만 업데이트되는 것을 확인할 수 있다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>store.js, actions.js</h2>



<p><a href="https://github.com/concretesolutions/redux-zero">Redux-Zero</a>의 <em>store</em>, <em>action</em>들을 정의한다. 여러분께 이미 익숙할 리덕스(Redux)가 간략해진 모양이며, 웹 컴포넌트 설명글의 범위를 벗어나므로 이 부분의 설명은 생략하겠다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/bfb5ac43847e0adcfa95b28397045814">Gist</a>.
</figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>#UseThePlatform 프레임워크 없이도 React처럼 코딩</h2>



<p>여기까지 TODO 애플리케이션을 커스텀 엘리먼트, 쉐도우 돔과 lit-HTML을 사용하여 우리에게 익숙한 React처럼 작성한 코드를 가볍게 설명했다. 이 방법은 단순히 React를 흉내 내는 것이 목적이 아니다. 우리가 우리에게 익숙한 방법으로 접근할 수 있으면서도, 프레임워크를 요구하지 않는다. 단지 2kb가 채 안되는 lit-HTML 라이브러리만 하나 사용하고 있다. 이것이 우리에게 주는 장점은 뚜렷하다.</p>



<ol>
	<li>프레임워크 다운로드 시간이 없으므로 페이지가 가볍고 빠르다.</li>
	<li>직관적인 DOM Integration. <code>document.querySelector('todo-app').add('hello')</code> 같은 직관적인 방법을 제공해주는 프레임워크는 없다.</li>
	<li>완벽히 표준 ECMAScript코드이므로, 프레임워크 유행을 타지 않고 오래 유지보수 가능한 코드를 만든다. 불과 2, 3년 전 가장 인기 있던 Angular의 위상을 생각해보자.</li>
	<li>프레임워크와 무관하므로 오히려 어떤 프레임워크와도 같이 쓰일 수 있다.</li>
	<li>프레임워크는 선택이지만 프론트엔드 개발자로서 DOM과 ECMAScript는 기본이다. 진입 장벽이 낮고, 어떤 프론트엔드 개발자도 이해할 수 있는 코드이다.</li>
</ol>



<p>이 같은 장점에 이끌려 이 연재글을 벌써 5번째 쓰고 있다. 물론 프레임워크가 제공해주는 편리함이나, 브라우저 지원 등을 생각해보면 아쉬운 점들이 없지 않다. lit-HTML 역시 조금 더 다듬어져야 할 필요가 있다. 이 예제 또한 lit-HTML이 정리되어 이 예제를 업데이트할 수 있기를 기다리고 있다. 그러나 이 장점들은 충분히 살린다면, 적당한 시기(아마도 IE10 이하를 집어던져도 되는 때)에, 공통 컴포넌트나 오픈소스를 개발하는 곳에서는 충분히 그 장점을 발휘할 수 있을 때가 오리라 믿는다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>마치며</h2>



<p><a href="https://www.youtube.com/watch?v=Io6JjgckHbg&amp;t=1506s">Chrome Dev Summit 2017 — lit-HTML</a> 영상을 본 후, 여기서 소개된 대로 lit-HTML 그리고, 웹 컴포넌트 자체가 얼마나 빠른 성능을 보여줄 지 궁금했다. 기왕이면 이전 글에서 약속한 대로 예제도 만들어야 하니 <a href="https://github.com/developit/preact-perf">todo preact benchmark</a>에 추가하여 성능 비교를 해보려 했다. 테스트 결과는 너무 빠르다. 다만 너무 빨라 스스로 의문이 생겨 조금 더 알아본 결과, <a href="https://vuejs.org/perf/">Vue.js TodoMVC Benchmark</a>를 찾았다. 필자 역시 이 의견처럼 프레임워크 벤치마크가 의미 없다는 것에 동의하기 때문에 벤치마크 결과를 따로 만들지는 않았고, 이 프로젝트만 <a href="http://todomvc.com/">TodoMVC</a>에 제출할 예정이다. 그러나 표준 스크립트만으로 동작하는 이 방식이 충분히 빠를수 밖에 없다는 것을 독자 여러분들도 잘 아시리라 생각한다. 개인적으로 #UseThePlatform의 가치, 웹 컴포넌트의 비전에 거는 기대가 크기에 이 글을 읽는 독자가 한명이라도 더 동의해서 주변에 웹 컴포넌트 개발을 하는 환경을 볼 수 있으면 좋겠다는 바람이다. 이 글을 끝으로 웹 컴포넌트 연재를 마친다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>참조</h2>



<ul>
	<li><a href="https://github.com/kyuwoo-choi/todo-web-components">Todo Web Components</a></li>
	<li><a href="https://kyuwoo-choi.github.io/todo-web-components/">Todo Web Components — Demo</a></li>
	<li><a href="https://github.com/PolymerLabs/lit-html">lit-html</a></li>
	<li><a href="http://todomvc.com/">TodoMVC</a></li>
	<li><a href="https://github.com/developit/preact-perf">todo preact benchmark</a></li>
	<li><a href="https://vuejs.org/perf/">Vue.js TodoMVC Benchmark</a></li>
	<li><a href="https://www.youtube.com/watch?v=Io6JjgckHbg&amp;t=1506s">Chrome Dev Summit 2017 — lit-HTML</a></li>
	<li><a href="https://developers.google.com/web/fundamentals/web-components/best-practices">Custom Element Best Practices</a></li>
</ul>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>
<p>The post <a rel="nofollow" href="https://kyu.io/ko/%ec%9b%b9-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b85%e2%80%8a-%e2%80%8alit-html%eb%a1%9c-%eb%a6%ac%ec%97%91%ed%8a%b8%ec%b2%98%eb%9f%bc-%ec%bd%94%eb%94%a9%ed%95%98%ea%b8%b0/">웹 컴포넌트(5) — lit-html로 리엑트처럼 코딩하기</a> appeared first on <a rel="nofollow" href="https://kyu.io/ko">KYU.IO 🌾</a>.</p>
]]></content:encoded>
							<wfw:commentRss>https://kyu.io/ko/%ec%9b%b9-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b85%e2%80%8a-%e2%80%8alit-html%eb%a1%9c-%eb%a6%ac%ec%97%91%ed%8a%b8%ec%b2%98%eb%9f%bc-%ec%bd%94%eb%94%a9%ed%95%98%ea%b8%b0/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">434</post-id>	</item>
		<item>
		<title>웹 컴포넌트(4) — 템플릿 엘리먼트(Template Element)와 HTML Imports</title>
		<link>https://kyu.io/ko/%ec%9b%b9-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b84%e2%80%8a-%e2%80%8atemplate-element-html-imports/#utm_source=rss&#038;utm_medium=rss&#038;utm_campaign=%25ec%259b%25b9-%25ec%25bb%25b4%25ed%258f%25ac%25eb%2584%258c%25ed%258a%25b84%25e2%2580%258a-%25e2%2580%258atemplate-element-html-imports</link>
				<comments>https://kyu.io/ko/%ec%9b%b9-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b84%e2%80%8a-%e2%80%8atemplate-element-html-imports/#comments</comments>
				<pubDate>Wed, 30 May 2018 15:02:05 +0000</pubDate>
		<dc:creator><![CDATA[kyuwoo.choi]]></dc:creator>
				<category><![CDATA[웹 컴포넌트]]></category>
		<category><![CDATA[자바스크립트]]></category>
		<category><![CDATA[전체]]></category>
		<category><![CDATA[HTML Import]]></category>
		<category><![CDATA[템플릿 리터럴]]></category>
		<category><![CDATA[템플릿 엘리먼트]]></category>
		<category><![CDATA[lit-html]]></category>
		<category><![CDATA[UseThePlatform]]></category>

		<guid isPermaLink="false">https://kyu.io/?p=416</guid>
				<description><![CDATA[<p>웹 컴포넌트의 표준으로서 템플릿 엘리먼트(Template Element)와 HTML Import가 필요한 이유, 그리고 이 두 표준이 어려움을 겪고 있는 사연. 이에 새로이 대두되고 있는 ES6 템플릿 리터럴을 이용한 솔루션을 소개한다. 이 이야기를 자바스크립트에서 HTML 템플릿의 변화로 이야기한다.</p>
<p>The post <a rel="nofollow" href="https://kyu.io/ko/%ec%9b%b9-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b84%e2%80%8a-%e2%80%8atemplate-element-html-imports/">웹 컴포넌트(4) — 템플릿 엘리먼트(Template Element)와 HTML Imports</a> appeared first on <a rel="nofollow" href="https://kyu.io/ko">KYU.IO 🌾</a>.</p>
]]></description>
								<content:encoded><![CDATA[
<ul>
	<li><a href="https://kyu.io/ko/%ec%9b%b9-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b81-keep-calm-and-usetheplatform/">웹 컴포넌트(1) — Keep calm and #UseThePlatform</a></li>
	<li><a href="https://kyu.io/ko/%ec%9b%b9-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b82-%ec%bb%a4%ec%8a%a4%ed%85%80-%ec%97%98%eb%a6%ac%eb%a8%bc%ed%8a%b8/">웹 컴포넌트(2) — 커스텀 엘리먼트</a></li>
	<li><a href="https://kyu.io/ko/%ec%9b%b9-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b83%e2%80%8a-%e2%80%8a%ec%89%90%eb%8f%84%ec%9a%b0-%eb%8f%94shadow-dom/">웹 컴포넌트(3) — 쉐도우 돔(#SHADOW DOM)</a>﻿<a href="https://kyu.io/ko/%ec%9b%b9-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b84%e2%80%8a-%e2%80%8atemplate-element-html-imports/"></a></li>
	<li><a href="https://kyu.io/ko/%ec%9b%b9-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b85%e2%80%8a-%e2%80%8alit-html%eb%a1%9c-%eb%a6%ac%ec%97%91%ed%8a%b8%ec%b2%98%eb%9f%bc-%ec%bd%94%eb%94%a9%ed%95%98%ea%b8%b0/">웹 컴포넌트(5) — LIT-HTML로 리엑트처럼 코딩하기</a></li>
</ul>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<p>이번 글은 웹 컴포넌트 소개 연재 4번째로 템플릿 엘리먼트(Template Element)와 HTML Imports에 대한 글이다. 서두에 밝히자면, 이 두 표준의 흐름은 웹 컴포넌트 개발에서 제외될 것으로 보인다. 따라서 두 표준을 자세히 알아보기보다는 이것들이 웹 컴포넌트로써 사용되게 된 배경과 한계점, 그리고 Polymer Summit 2017에서 나온 현재의 동향을 이야기로 풀어보았다. 직접 실습할 내용도 없으니 가볍게 이야기 읽듯 따라가 보자.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>고전적인 템플릿</h2>



<p>자바스크립트에서 HTML 엘리먼트를 만드는 일은 일반적이다. 고민 없이 엘리먼트를 하나 만들어서 body에 붙여보자. <code>document.createElement</code>, <code>appnedChild</code> 두 개의 함수 실행으로 간단히 할 수 있다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/2bdd6fe49aca233eb9d13307e20399dd">Gist</a>.
</figure>



<p>그러나 복잡한 DOM을 구성할 때 이런 방식을 적용하면 코드는 너무 길어져 버리고, DOM 구조를 파악하기도 괴롭다. 유지보수 하기도 힘들어지므로 이렇게 쓰고 싶지는 않다. 복잡한 템플릿을 작성할 때에는 <code>innerHTML</code>을 사용하는 것이 편하다. 아래의 코드는 더욱 직관적이면서 유지보수 가능한 형태로 보인다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/ea5120e80d28e395642dda54d9b24be2">Gist</a>.
</figure>



<p>그러나 이 방법도 리스트처럼 반복적인 엘리먼트를 생성해야 하거나, 조건에 따라 템플릿이 바뀌어야 하는 경우 등의 다양한 요구사항을 해결하기에는 부족하다. 더불어 내부의 엘리먼트에 접근하기 위해서는 <code>querySelector</code>를 사용해야하는 점도 불편하다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>템플릿 엔진들</h2>



<p>문자열의 간단한 조합에서 해결할 수 없는 Loop, If 등의 요구사항들을 해결하기 위해 템플릿 엔진들이 사용되기 시작했다. <em>Mustache</em>, <em>Handlebars</em> 등 템플릿 엔진들은 비슷한 목적으로 쓰이면서도 각자의 개성을 가지고 있다. 유명한 <em>Vue.js</em>, <em>Angular</em>, <em>Polymer(과거)</em> 들도 카테고리에 속한다 할 수 있다. 이 템플릿 엔진 방식은 여전히 많은 상황에서 유용하게 사용되고 있다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/a6b59c220906ee894d11f654d50c64b0">Gist</a>.
</figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>JSX + Virtual DOM</h2>



<p>프론트엔드 개발이 컴포넌트화 되면서, 컴포넌트들이 그리는 여러 개의 템플릿들을 효율적으로 처리해주는 리엑트(React: JSX + Virtual DOM)가 인기를 얻었다. JSX는 ESCAScript의 확장으로 스크립트 내부에 직접 템플릿을 작성할 수 있게 해주며, Virtual DOM은 주어진 상태에 따라 DOM의 일부분만 업데이트 해주는 역할을 한다. 템플릿 관점에서 보자면, 리엑트는 상태에 따라 템플릿을 컴포넌트 단위로 업데이트 해주는 일을 한다고 할 수 있다. JSX + Virtual DOM은 현재 가장 인기있는 템플릿 처리 방식이라 말할 수 있다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/ddb517065f3c8d3af3840d1dd795b494">Gist</a>.
</figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>템플릿 엘리먼트</h2>



<p>드디어 템플릿 엘리먼트(Template Element)의 이야기 이다. 템플릿 엔진들은 유용하지만 문자열로 처리되기에 어쩔 수 없는 문제점들을 내포한다. <em>XSS</em> 공격에 노출될 위험이 있으며, <code>innerHTML</code>의 사용이 강제된다. DOM API들을 템플릿에 사용할 수 없다는 것들이다. 이러한 문제들을 해결하기 위해 템플릿의 문자열 처리를 지양하고 엘리먼트로 처리하는 방법으로 템플릿 엘리먼트가 표준으로 만들어 졌다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/82534ff0d937a0a5cc9b8fa9b9319b60">Gist</a>.
</figure>



<p>템플릿 엘리먼트는 자바스크립트 코드로 많은 양의 코드를 적지 않아도 되고, 조건에 따라 DOM의 변경도 가능하다. 이러한 변경은 강력한 DOM API들을 그대로 사용할 수 있어 편리하다. 템플릿 엘리먼트는 DOM에 한 번 정의되면 필요할 때마다 복사하여 붙여넣기 때문에 성능도 훌륭하다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>템플릿 엘리먼트 + 웹 컴포넌트</h2>



<p>이러한 장점들으로 템플릿 엘리먼트는 웹 컴포넌트를 구성하는 표준이 되었다. 템플릿 엘리먼트는 스크립트와 스타일도 포함할 수 있다. 스크립트와 스타일은 템플릿에 있을때는 적용되지 않지만, 복사되어 Document에 붙을 때에 적용된다. 쉐도우 돔(Shadow DOM)과 시너지를 일으켜 웹 컴포넌트의 템플릿 기능을 수행하는 데 충분한 장점이라 할 수 있다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/4c37f7f2a30d4b0f4a40ae7ab311c55f">Gist</a>.
</figure>



<p>그러나, 템플릿 엘리먼트는 템플릿이 HTML로 작성되어야 한다는 것이 오히려 단점이 되기도 한다. 컴포넌트의 컨트롤러에 해당하는 자바스크립트와 템플릿 뷰에 해당하는 HTML이 분리되어야 한다는 점이다. 컴포넌트와 모듈이 정확히 동의어라고 할 수는 없지만, 모듈로서 분리되어 재사용 될 수 있어야 의미가 있다. 그런데 템플릿 엘리먼트와 커스텀 엘리먼트(Custom Elements)를 컴포넌트로 구성하려면 HTML, JS 두 개의 파일이 필요하다. 이 방식은 웹 컴포넌트를 모듈로 만들기에 큰 걸림돌이다.</p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>구원자 HTML Imports</h2>



<p>이제 HTML Imports가 역할을 할 때가 되었다. HTML Imports는 스크립트 기반의 CommonJS, RequireJS와는 달리 HTML 기반의 의존성 해결사 역할을 한다. HTML에서 HTML을 읽어와 붙여주기에 아래처럼 깔끔한 처리도 가능하다. HTML Imports의 문법은 스타일을 연결하는 것과 유사하지만 스크립트, 스타일, HTML 엘리먼트들의 의존성을 한 번에 해결해 주는 강력한 방법이다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/be21971d09995addfb699fa13946ff6b">Gist</a>.
</figure>



<p>HTML Imports는 HTML과 자바스크립트 두 개의 의존성을 해결해야만 하는 숙명의 웹 컴포넌트의 구원자이다. 이를 적용하여 웹 컴포넌트를 구성하면 아래의 모습이 된다. 이전 시간까지 알아보았던 모든 웹 컴포넌트 표준들(Custom Elements, Shadow DOM, Template Element, HTML Imports)을 모두 조합해보자. 아래 보이는 HTML로 컴포넌트를 구성하는 모습은 모양과 처리 방법은 다르나 Polymer와 Vue.js에서도 비슷한 모습이다.</p>



<figure class="wp-block-embed is-type-rich is-provider-embed-handler">
	View the code on <a href="https://gist.github.com/kyuwoo-choi/59352c9e7e25fdc35741d08fec77f6a4">Gist</a>.
</figure>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>Firefox는 HTML Imports를 싫어해</h2>



<p>구글을 필두로 한 웹 컴포넌트 그룹은 위의 모양으로 커스텀 엘리먼트(Custom Elements), 쉐도우 돔(Shadow DOM), 템플릿 엘리먼트(Template Element), HTML Imports 4개의 표준을 웹 컴포넌트 표준이라 정했다. 이후 템플릿 엘리먼트는 가장 먼저 안정화 되었고 IE를 제외한 모든 브라우저에서 네이티브로 지원한다. 커스텀 엘리먼트와 쉐도우 돔은 구현에 있어 몇 가지 의견을 수렴하면서 v1 스펙이 정의되어, IE를 제외한 브라우저에서 이미 지원되고 있거나 개발 중이다. 그런데 HTML Imports에서 문제가 생겼다. Firefox가 HTML Imports를 지원하지 않겠다고 선언한 것을 시작으로 다른 브라우저들도 구현에 나서지 않고 있기 때문이다.</p>



<blockquote class="wp-block-quote">
	<p><em>Mozilla will not ship an implementation of HTML Imports. We expect that once JavaScript modules — a feature derived from JavaScript libraries written by the developer community — is shipped, the way we look at this problem wi