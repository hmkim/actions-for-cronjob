<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
    xmlns:content="http://purl.org/rss/1.0/modules/content/"
    xmlns:wfw="http://wellformedweb.org/CommentAPI/"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
    xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
>

<channel>
    <title><![CDATA[Nolboo's Blog]]></title>
    <atom:link href="http://nolboo.kim/feed.xml" rel="self" type="application/rss+xml" />
    <link href="http://nolboo.kim/" />
    <description><![CDATA[]]></description>
    <lastBuildDate>Wed, 06 Feb 2019 04:39:10 +0000</lastBuildDate>
    <language>en-US</language>
    <generator uri="http://octopress.org/">Octopress</generator>

    
        <item>
            <title><![CDATA[임베디드 테스트]]></title>
            <link>http://nolboo.kim/blog/2018/02/18/test/</link>
            <pubDate>Sun, 18 Feb 2018 00:00:00 +0000</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"n0lb00", "github"=>"nolboo"}]]></dc:creator>
        
            <category><![CDATA[blog]]></category>
        
        
            <category><![CDATA[vi]]></category>
        
            <category><![CDATA[vim]]></category>
        
            <category><![CDATA[tip]]></category>
        
            <guid>http://nolboo.kim/blog/2018/02/18/test/</guid>
            <description>
                <![CDATA[




]]>
            </description>
            <content:encoded>
                <![CDATA[<div style=" background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAMUExURczMzPf399fX1+bm5mzY9AMAAADiSURBVDjLvZXbEsMgCES5/P8/t9FuRVCRmU73JWlzosgSIIZURCjo/ad+EQJJB4Hv8BFt+IDpQoCx1wjOSBFhh2XssxEIYn3ulI/6MNReE07UIWJEv8UEOWDS88LY97kqyTliJKKtuYBbruAyVh5wOHiXmpi5we58Ek028czwyuQdLKPG1Bkb4NnM+VeAnfHqn1k4+GPT6uGQcvu2h2OVuIf/gWUFyy8OWEpdyZSa3aVCqpVoVvzZZ2VTnn2wU8qzVjDDetO90GSy9mVLqtgYSy231MxrY6I2gGqjrTY0L8fxCxfCBbhWrsYYAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;"></div>

<hr />

<div style=" background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAMUExURczMzPf399fX1+bm5mzY9AMAAADiSURBVDjLvZXbEsMgCES5/P8/t9FuRVCRmU73JWlzosgSIIZURCjo/ad+EQJJB4Hv8BFt+IDpQoCx1wjOSBFhh2XssxEIYn3ulI/6MNReE07UIWJEv8UEOWDS88LY97kqyTliJKKtuYBbruAyVh5wOHiXmpi5we58Ek028czwyuQdLKPG1Bkb4NnM+VeAnfHqn1k4+GPT6uGQcvu2h2OVuIf/gWUFyy8OWEpdyZSa3aVCqpVoVvzZZ2VTnn2wU8qzVjDDetO90GSy9mVLqtgYSy231MxrY6I2gGqjrTY0L8fxCxfCBbhWrsYYAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;"></div>
]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[모든 앱에서 Vim을 사용하는 법 - QuickCursorKM과 vim-anywhere]]></title>
            <link>http://nolboo.kim/blog/2018/02/17/vim-anywhere/</link>
            <pubDate>Sat, 17 Feb 2018 00:00:00 +0000</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"n0lb00", "github"=>"nolboo"}]]></dc:creator>
        
            <category><![CDATA[blog]]></category>
        
        
            <category><![CDATA[vi]]></category>
        
            <category><![CDATA[vim]]></category>
        
            <category><![CDATA[tip]]></category>
        
            <guid>http://nolboo.kim/blog/2018/02/17/vim-anywhere/</guid>
            <description>
                <![CDATA[Vim에 익숙해진다는 것은 먼저 Vim의 키바인딩에 익숙해지는 것이다. 이 때부터 다른 텍스트 에디터의 키 바인딩을 옵션에서 Vim 키 바인딩으로 바꾸고, 옵션으로 제공하지 않는 에디터는 플러그인을 찾아서라도 키 바인딩을 바꾼게 된다. 더 나아가 웹브라우저는 물론 다른 모든 앱에서 Vim 키 바인딩을 사용하고 싶은 욕구가 넘치게 된다(적어도 필자는). 키보드 마에스트로 매크로 QuickCursorKM...]]>
            </description>
            <content:encoded>
                <![CDATA[<p><img src="/images/posts/vim.jpg" alt="Vim 3D" /></p>

<p>Vim에 익숙해진다는 것은 먼저 Vim의 키바인딩에 익숙해지는 것이다. 이 때부터 다른 텍스트 에디터의 키 바인딩을 옵션에서 Vim 키 바인딩으로 바꾸고, 옵션으로 제공하지 않는 에디터는 플러그인을 찾아서라도 키 바인딩을 바꾼게 된다. 더 나아가 웹브라우저는 물론 다른 모든 앱에서 Vim 키 바인딩을 사용하고 싶은 욕구가 넘치게 된다(적어도 필자는).</p>

<h2 id="키보드-마에스트로-매크로-quickcursorkm">키보드 마에스트로 매크로 QuickCursorKM</h2>

<p>거의 모든 앱에서 Vim을 사용하는 방법으로 이제까지 사용하고 있는 것은 키보드 마에스트로에서 <a href="https://github.com/chauncey-garrett/keyboard-maestro-quickcursorkm">keyboard-maestro-quickcursorkm</a>를 사용하는 것이다.</p>

<p>매크로 저자가 여러 에디터를 선호하는지 꽤 많은 에디터를 선택할 수 있지만, Vim을 가장 많이 사용하는 필자는 Vim만의 단축키를 별도로 지정해서 사용하고 있다.</p>

<p>단축키를 누르면 현재 앱의 에디터에서 모든 텍스트를 선택해서 <code class="highlighter-rouge">.quickcursor_km.txt</code>에 저장하고 MacVim을 불러온다. 텍스트를 편집한 후에 MacVim을 종료하면 이전 앱의 에디터로 전체 텍스트를 붙여넣는다.</p>

<p>물론 앱의 에디터에서 일부 선택해서 그 부분만 편집할 수도 있다.</p>

<h3 id="단점">단점</h3>

<ul>
  <li>MacVim을 종료해야 매크로의 나머지 부분이 제대로 동작한다.</li>
  <li>원래 에디터가 MacVim의 이전 앱이어야 한다. 다른 앱으로 전환한 적이 있다면 다시 편집하던 앱으로 전환한 후 MacVim으로 다시 돌아가 종료해야 한다.</li>
</ul>

<h2 id="vim-anywhere">vim-anywhere</h2>

<p>나랑 같은 Vim 중독 증후군(?)이 있는 사람이 스크립트를 이용하는 <a href="https://github.com/cknadler/vim-anywhere">vim-anywhere</a>를 만들어서 공개한 것을 발견하였다.</p>

<p>동작하는 방식은 QuickCursorKM보다 간결하다. 지정한 단축키로 호출하면 임시 버퍼를 열고, 창을 닫으면 편집하던 버퍼의 내용을 클립 보드에 복사하고 이전 앱으로 다시 돌아간다. 편집한 텍스트를 붙여넣으면 끝! 간결해서 오히려 QuickCursorKM의 단점을 확실히 커버한다.</p>

<p>리눅스에서도 사용</p>

<h3 id="설치">설치</h3>

<p>MacVim을 설치해야 한다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew install macvim
curl <span class="nt">-fsSL</span> https://raw.github.com/cknadler/vim-anywhere/master/install | bash
</code></pre></div></div>

<p>OSX에서 vim-anywhere를 호출하는 키보드 단축키는 스크립트로 지정할 수 없다. 단, 설치 스크립트가 자동으로 시스템 환경설정&gt;키보드&gt;단축키를 연다.</p>

<p><img src="https://raw.githubusercontent.com/cknadler/vim-anywhere/master/assets/shortcut.png" alt="키보드 단축키" /></p>

<p><code class="highlighter-rouge">일반&gt;VimAnyWhere&gt;단축키 추가</code> 버튼을 클릭한 후 원하는 단축키를 지정한다. <code class="highlighter-rouge">Cmd+Ctrl+V</code>를 권장하고 있다.</p>

<p>참고로 업데이트는,</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/.vim-anywhere/update
</code></pre></div></div>

<p>삭제는,</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/.vim-anywhere/uninstall
</code></pre></div></div>

<p>시스템을 종료하기 전까지 제공하는 임시 history를 보고 싶다면,</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> /tmp/vim-anywhere
</code></pre></div></div>

<p>최근에 편집하뎐 파일을 다시 열려면,</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim <span class="k">$(</span> <span class="nb">ls</span> /tmp/vim-anywhere | sort <span class="nt">-r</span> | head <span class="nt">-n</span> 1 <span class="k">)</span>
</code></pre></div></div>

<p>즐빔!</p>

]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[Vim을 모든 앱에서 사용하는 법]]></title>
            <link>http://nolboo.kim/blog/2017/09/14/vim-write-autosave/</link>
            <pubDate>Thu, 14 Sep 2017 00:00:00 +0000</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"n0lb00", "github"=>"nolboo"}]]></dc:creator>
        
            <category><![CDATA[blog]]></category>
        
        
            <category><![CDATA[vi]]></category>
        
            <category><![CDATA[vim]]></category>
        
            <category><![CDATA[write]]></category>
        
            <category><![CDATA[save]]></category>
        
            <category><![CDATA[tip]]></category>
        
            <guid>http://nolboo.kim/blog/2017/09/14/vim-write-autosave/</guid>
            <description>
                <![CDATA[Vim에 익숙해진다는 것은 먼저 Vim의 키바인딩에 익숙해지는 것이다. 이 때부터 다른 텍스트 에디터의 키 바인딩을 옵션에서 Vim 키 바인딩으로 바꾸고, 옵션으로 제공하지 않는 에디터는 플러그인을 찾아서라도 키 바인딩을 바꾼게 된다. 더 나아가 웹브라우저는 물론 다른 모든 앱에서 Vim 키 바인딩을 사용하고 싶은 욕구가 넘치게 된다(적어도 필자는). 키보드 마에스트로 매크로 QuickCursorKM...]]>
            </description>
            <content:encoded>
                <![CDATA[<p><img src="/images/posts/vim.jpg" alt="Vim 3D" /></p>

<p>Vim에 익숙해진다는 것은 먼저 Vim의 키바인딩에 익숙해지는 것이다. 이 때부터 다른 텍스트 에디터의 키 바인딩을 옵션에서 Vim 키 바인딩으로 바꾸고, 옵션으로 제공하지 않는 에디터는 플러그인을 찾아서라도 키 바인딩을 바꾼게 된다. 더 나아가 웹브라우저는 물론 다른 모든 앱에서 Vim 키 바인딩을 사용하고 싶은 욕구가 넘치게 된다(적어도 필자는).</p>

<h2 id="키보드-마에스트로-매크로-quickcursorkm">키보드 마에스트로 매크로 QuickCursorKM</h2>

<p>거의 모든 앱에서 Vim을 사용하는 방법으로 이제까지 사용하고 있는 것은 키보드 마에스트로에서 <a href="https://github.com/chauncey-garrett/keyboard-maestro-quickcursorkm">keyboard-maestro-quickcursorkm</a>를 사용하는 것이다.</p>

<p>매크로 저자가 여러 에디터를 선호하는지 꽤 많은 에디터를 선택할 수 있지만, Vim을 가장 많이 사용하는 필자는 Vim만의 단축키를 별도로 지정해서 사용하고 있다.</p>

<p>단축키를 누르면 현재 앱의 에디터에서 모든 텍스트를 선택해서 <code class="highlighter-rouge">.quickcursor_km.txt</code>에 저장하고 MacVim을 불러온다. 텍스트를 편집한 후에 MacVim을 종료하면 이전 앱의 에디터로 전체 텍스트를 붙여넣는다.</p>

<p>물론 앱의 에디터에서 일부 선택해서 그 부분만 편집할 수도 있다.</p>

<h3 id="단점">단점</h3>

<ul>
  <li>MacVim을 종료해야 매크로의 나머지 부분이 제대로 동작한다.</li>
  <li>원래 에디터가 MacVim의 이전 앱이어야 한다. 다른 앱으로 전환한 적이 있다면 다시 편집하던 앱으로 전환한 후 MacVim으로 다시 돌아가 종료해야 한다.</li>
</ul>

<h2 id="vim-anywhere">vim-anywhere</h2>

<p>나랑 같은 Vim 중독 증후군(?)이 있는 사람이 스크립트를 이용하는 <a href="https://github.com/cknadler/vim-anywhere">vim-anywhere</a>를 만들어서 공개한 것을 발견하였다.</p>

<p>동작하는 방식은 QuickCursorKM보다 간결하다. 지정한 단축키로 호출하면 임시 버퍼를 열고, 창을 닫으면 편집하던 버퍼의 내용을 클립 보드에 복사하고 이전 앱으로 다시 돌아간다. 편집한 텍스트를 붙여넣으면 끝! 간결해서 오히려 QuickCursorKM의 단점을 확실히 커버한다.</p>

<p>리눅스에서도 사용</p>

<h3 id="설치">설치</h3>

<p>MacVim을 설치해야 한다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew install macvim
curl <span class="nt">-fsSL</span> https://raw.github.com/cknadler/vim-anywhere/master/install | bash
</code></pre></div></div>

<p>OSX에서 vim-anywhere를 호출하는 키보드 단축키는 스크립트로 지정할 수 없다. 단, 설치 스크립트가 자동으로 시스템 환경설정&gt;키보드&gt;단축키를 연다.</p>

<p><img src="https://raw.githubusercontent.com/cknadler/vim-anywhere/master/assets/shortcut.png" alt="키보드 단축키" /></p>

<p><code class="highlighter-rouge">일반&gt;VimAnyWhere&gt;단축키 추가</code> 버튼을 클릭한 후 원하는 단축키를 지정한다. <code class="highlighter-rouge">Cmd+Ctrl+V</code>를 권장하고 있다.</p>

<p>참고로 업데이트는,</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/.vim-anywhere/update
</code></pre></div></div>

<p>삭제는,</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/.vim-anywhere/uninstall
</code></pre></div></div>

<p>시스템을 종료하기 전까지 제공하는 임시 history를 보고 싶다면,</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> /tmp/vim-anywhere
</code></pre></div></div>

<p>최근에 편집하뎐 파일을 다시 열려면,</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim <span class="k">$(</span> <span class="nb">ls</span> /tmp/vim-anywhere | sort <span class="nt">-r</span> | head <span class="nt">-n</span> 1 <span class="k">)</span>
</code></pre></div></div>

<p>즐빔!</p>

]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[2017년 개정 한글 맞춤법 문장 부호 요약]]></title>
            <link>http://nolboo.kim/blog/2017/08/26/han-punctuation/</link>
            <pubDate>Sat, 26 Aug 2017 00:00:00 +0000</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"n0lb00", "github"=>"nolboo"}]]></dc:creator>
        
            <category><![CDATA[blog]]></category>
        
        
            <category><![CDATA[hangul]]></category>
        
            <category><![CDATA[puctuation]]></category>
        
            <guid>http://nolboo.kim/blog/2017/08/26/han-punctuation/</guid>
            <description>
                <![CDATA[2017년 개정된 한글 맞춤법의 부록에 있는 문장 부호의 정의는 다음과 같다. “문장 부호는 글에서 문장의 구조를 드러내거나 글쓴이의 의도를 전달하기 위하여 사용하는 부호이다.” 한글 맞춤법에 수록된 문장 부호는 24개가 있다. 다음은 내 맘대로 구분한 것이다. 문장의 끝에 오는 마침표(.), 물음표(?), 느낌표(!) 어구 사이의 관계를 나타내는 쉼표(,), 가운뎃점(ㆍ), 쌍점(:), 빗금(/) 어구를...]]>
            </description>
            <content:encoded>
                <![CDATA[<p>2017년 개정된 한글 맞춤법의 부록에 있는 문장 부호의 정의는 다음과 같다.</p>

<blockquote>
  <p>“문장 부호는 글에서 문장의 구조를 드러내거나 글쓴이의 의도를 전달하기 위하여 사용하는 부호이다.”</p>
</blockquote>

<p>한글 맞춤법에 수록된 문장 부호는 24개가 있다. 다음은 내 맘대로 구분한 것이다.</p>

<ul>
  <li>문장의 끝에 오는 마침표(.), 물음표(?), 느낌표(!)</li>
  <li>어구 사이의 관계를 나타내는 쉼표(,), 가운뎃점(ㆍ), 쌍점(:), 빗금(/)</li>
  <li>어구를 쌍으로 감싸는 큰따옴표(“”), 작은따옴표(‘’), 소괄호(()), 중괄호({}), 대괄호([]), 겹낫표(『』)와 겹화살괄호(≪≫), 홑낫표(「」)와 홑화살괄호(&lt;&gt;)</li>
  <li>어구를 나누어주거나 강조 또는 생략하는 줄표(―), 붙임표(-), 물결표(~), 드러냄표( ˙ )와 밑줄( _ ), 숨김표(○, ×), 빠짐표(□), 줄임표(……)</li>
</ul>

<p>대부분은 일상에서 자주 사용하지만, 시대가 흐름에 따라 개정되기 때문에 명칭과 사용법 중 헷갈리는 부분이 있어서 2017년 개정안으로 살펴보았다.</p>

<p>여기서는 부록으로 나온 문장 부호만을 요약한다. 보통 글을 쓸 때도 많이 사용하지만, 정규식과 텍스트 개체와 관련한 글이나 요약을 할 때 나 자신도 명칭도 제대로 사용하지 못하고 있고, 관련 책이나 인터넷 글을 볼 때도 정확한 용어인지 판별하기 힘들 때가 많아 2017년 개정안을 중심으로 요약 정리해 보았다.</p>

<p>전체 원문은 2017. 3. 28.에 문화체육관광부 고시 제2017-12호 <a href="http://www.korean.go.kr/front/etcData/etcDataView.do?mn_id=46&amp;etc_seq=540&amp;pageIndex=1">한글 맞춤법 - 국립국어원</a>을 참조하기 바란다.  HWP 첨부 파일을 혐오한다면 <a href="http://www.korean.go.kr/front/page/pageView.do?page_id=P000192&amp;mn_id=30">이 링크</a>에서 볼 수도 있다.</p>

<h2 id="마침표--">마침표( . )</h2>

<p>(1) 문장의 끝. 인용한 문장 끝에서는 뺄 수도 있다.</p>

<ul>
  <li>그는 “지금 바로 떠나자.”라고 말하며 서둘러 짐을 챙겼다.</li>
  <li>그는 “지금 바로 떠나자”라고 말하며 서둘러 짐을 챙겼다.</li>
</ul>

<p>명사형이나 명사로 끝나는 문장에도 쓰지만, 뺄 수도 있다.</p>

<ul>
  <li>목적을 이루기 위하여 몸과 마음을 다하여 애를 씀.</li>
  <li>신입 사원 모집을 위한 기업 설명회 개최.</li>
  <li>내일 오전까지 보고서를 제출할 것</li>
</ul>

<p><mark>제목, 표어에는 쓰지 않는다.</mark></p>

<p>(2) 아라비아 숫자만으로 연월일을 표시할 때와 특정일의 월과 일 숫자 사이</p>

<ul>
  <li>1919. 3. 1.</li>
  <li>3.1 운동</li>
</ul>

<p>(3) 장, 절, 항 등을 표시</p>

<ul>
  <li>가. 인명</li>
  <li>1. 연구 목적</li>
</ul>

<h2 id="물음표">물음표(?)</h2>

<p>(1) 의문문이나 의문을 나타내는 어구의 끝</p>

<p>여러 물음이 이어질 때는 맨 끝에만 쓰고, 각 물음이 독립적이면 매번 쓴다.</p>

<ul>
  <li>너는 중학생이냐, 고등학생이냐?</li>
  <li>너는 여기에 언제 왔니? 어디서 왔니? 무엇하러 왔니?</li>
</ul>

<p>의문의 정도가 약할 때는 마침표를 쓸 수도 있다.</p>

<ul>
  <li>도대체 이 일을 어쩐단 말이냐.</li>
  <li>이것이 과연 내가 찾던 행복일까.</li>
</ul>

<p><mark>제목, 표어에는 쓰지 않는다.</mark></p>

<p>(2) 의심, 빈정거림 등을 표시할 때, 또는 적절한 말을 쓰기 어려울 때 소괄호 안에 쓴다.</p>

<ul>
  <li>우리와 의견을 같이할 사람은 최 선생(?) 정도인 것 같다.</li>
</ul>

<p>(3) 모르거나 불확실한 내용임을 나타낼 때</p>

<ul>
  <li>최치원(857～?)은 통일 신라 말기에 이름을 떨쳤던 학자이자 문장가이다.</li>
  <li>조선 시대의 시인 강백(1690?～1777?)의 자는 자청이고, 호는 우곡이다.</li>
</ul>

<h2 id="느낌표">느낌표(!)</h2>

<p>(1) 감탄문이나 감탄사의 끝</p>

<p>감탄의 정도가 약할 때는 느낌표 대신 쉼표나 마침표를 쓸 수 있다.</p>

<ul>
  <li>어, 벌써 끝났네.</li>
</ul>

<p>(2) 특별히 강한 느낌을 나타내는 어구와 문장</p>

<ul>
  <li>청춘! 이는 듣기만 하여도 가슴이 설레는 말이다.</li>
</ul>

<p>(3) 물음의 말로 놀람이나 항의의 뜻</p>

<ul>
  <li>이게 누구야!</li>
  <li>내가 왜 나빠!</li>
</ul>

<p>(4) 감정을 넣어 대답하거나 다른 사람을 부를 때</p>

<h2 id="쉼표--">쉼표( , )</h2>

<p>(1) 같은 자격의 어구를 열거할 때. 다만, 쉼표 없이도 열거되는 사항임이 쉽게 드러날 때는 쓰지 않을 수 있다.</p>

<ul>
  <li>아버지 어머니께서 함께 오셨어요.</li>
  <li>네 돈 내 돈 다 합쳐 보아야 만 원도 안 되겠다.</li>
</ul>

<p>줄임표 앞에는 쓰지 않는다.</p>

<ul>
  <li>광역시: 광주, 대구, 대전……</li>
</ul>

<p>(2) 짝을 지어 구별할 때</p>

<ul>
  <li>닭과 지네, 개와 고양이는 상극이다.</li>
</ul>

<p>(3) 이웃하는 수를 개략적으로 나타낼 때</p>

<ul>
  <li>5, 6세기</li>
</ul>

<p>(4) 열거의 순서를 나타내는 어구 다음에</p>

<ul>
  <li>첫째, 몸이 튼튼해야 한다.</li>
  <li>마지막으로, 무엇보다 마음이 편해야 한다.</li>
</ul>

<p>(5) 문장의 연결 관계를 분명히 하고자 할 때 절과 절 사이에</p>

<ul>
  <li>콩 심은 데 콩 나고, 팥 심은 데 팥 난다.</li>
  <li>저는 신뢰와 정직을 생명과 같이 여기고 살아온바, 이번 비리 사건과는 무관하다는 점을 분명히 밝힙니다.</li>
  <li>떡국은 설날의 대표적인 음식인데, 이걸 먹어야 비로소 나이도 한 살 더 먹는다고 한다.</li>
</ul>

<p>(6) 같은 말이 되풀이되는 것을 피할 때</p>

<ul>
  <li>여름에는 바다에서, 겨울에는 산에서 휴가를 즐겼다.</li>
</ul>

<p>(7) 부르거나 대답하는 말 뒤</p>

<ul>
  <li>지은아, 이리 좀 와 봐.</li>
  <li>네, 지금 가겠습니다.</li>
</ul>

<p>(8) ‘곧’, ‘다시 말해’ 등과 같은 어구로 다시 설명할 때</p>

<ul>
  <li>책의 서문, 곧 머리말에는 책을 지은 목적이 드러나 있다.</li>
  <li>원만한 인간관계는 말과 관련한 예의, 즉 언어 예절을 갖추는 것에서 시작된다.</li>
  <li>호준이 어머니, 다시 말해 나의 누님은 올해로 결혼한 지 20년이 된다.</li>
  <li>나에게도 작은 소망, 이를테면 나만의 정원을 가졌으면 하는 소망이 있어.</li>
</ul>

<p>(9) 문장 앞부분에서 조사 없이 쓰인 제시어나 주제어의 뒤</p>

<ul>
  <li>돈, 돈이 인생의 전부이더냐?</li>
  <li>지금 네가 여기 있다는 것, 그것만으로도 나는 충분히 행복해.</li>
  <li>저 친구, 저러다가 큰일 한번 내겠어.</li>
  <li>그 사실, 넌 알고 있었지?</li>
</ul>

<p>(10) 같은 의미의 어구가 반복될 때</p>

<ul>
  <li>그의 애국심, 몸을 사리지 않고 국가를 위해 헌신한 정신을 우리는 본받아야 한다.</li>
</ul>

<p>(11) 도치문</p>

<ul>
  <li>이리 오세요, 어머님.</li>
  <li>다시 보자, 한강수야.</li>
</ul>

<p>(12) 다음 말과 직접적인 관계에 있지 않음을 나타낼 때</p>

<ul>
  <li>갑돌이는, 울면서 떠나는 갑순이를 배웅했다.</li>
  <li>철원과, 대관령을 중심으로 한 강원도 산간 지대에 예년보다 일찍 첫눈이 내렸습니다.</li>
</ul>

<p>(13) 중간에 끼어든 어구의 앞뒤. 줄표를 쓸 수도 있다. 단, 어구에 쉼표가 들어 있을 때는 줄표를 쓴다.</p>

<ul>
  <li>나는, 솔직히 말하면, 그 말이 별로 탐탁지 않아.</li>
  <li>영호는 미소를 띠고, 속으로는 화가 치밀어 올라 잠시라도 견딜 수 없을 만큼 괴로웠지만, 그들을 맞았다.</li>
  <li>영호는 미소를 띠고 ― 속으로는 화가 치밀어 올라 잠시라도 견딜 수 없을 만큼 괴로웠지만 ― 그들을 맞았다.</li>
  <li>이건 내 것이니까 ― 아니, 내가 처음 발견한 것이니까 ― 절대로 양보할 수 없다.</li>
</ul>

<p>(14) 끊어 읽는 곳</p>

<ul>
  <li>이 전투는 바로 우리가, 우리만이, 승리로 이끌 수 있다.</li>
</ul>

<p>(15) 더듬는 말</p>

<ul>
  <li>선생님, 부, 부정행위라니요? 그런 건 새, 생각조차 하지 않았습니다.</li>
</ul>

<h2 id="가운뎃점ㆍ">가운뎃점(ㆍ)</h2>

<p>(1) 열거할 어구들을 일정한 기준으로 묶어서 나타낼 때
(2) 짝을 이루는 어구들 사이에 쓴다. 쉼표를 쓸 수도 있다.
(3) 공통 성분을 줄여서 하나의 어구로 묶을 때 쓴다. 쉼표를 쓸 수 있다.</p>

<h2 id="쌍점--">쌍점( : )</h2>

<p>(1) 표제 다음에 해당 항목을 들거나 설명을 붙일 때</p>

<ul>
  <li>문방사우: 종이, 붓, 먹, 벼루</li>
  <li>일시: 2014년 10월 9일 10시</li>
  <li>흔하진 않지만 두 자로 된 성씨도 있다.(예: 남궁, 선우, 황보)</li>
</ul>

<p>(2) 희곡 등에서 대화 내용을 제시할 때 말하는 이와 말한 내용 사이</p>

<ul>
  <li>아들: 아버지, 제발 제 말씀 좀 들어 보세요.</li>
</ul>

<p>(3) 시와 분, 장과 절 등을 구별</p>

<ul>
  <li>오전 10:20(오전 10시 20분)</li>
  <li>두시언해 6:15(두시언해 제6권 제15장)</li>
</ul>

<p>(4) 의존명사 ‘대’</p>

<ul>
  <li>65:60(65 대 60)</li>
  <li>청군:백군(청군 대 백군)</li>
</ul>

<p><mark>쌍점의 앞은 붙여 쓰고 뒤는 띄어 쓴다. 다만, (3)과 (4)에서는 쌍점의 앞뒤를 붙여 쓴다.</mark></p>

<h2 id="빗금--">빗금( / )</h2>

<p>(1) 대비되는 두 개 이상의 어구를 묶어 나타낼 때</p>

<ul>
  <li>먹이다/먹히다</li>
  <li>금메달/은메달/동메달</li>
</ul>

<p>(2) 기준 단위당 수량을 표시할 때</p>

<ul>
  <li>100미터/초</li>
  <li>1,000원/개</li>
</ul>

<p>(3) 시의 행이 바뀌는 부분. 다만, 연이 바뀜을 나타낼 때는 두 번 겹쳐 쓴다.</p>

<ul>
  <li>산에 / 산에 / 피는 꽃은 / 저만치 혼자서 피어 있네</li>
  <li>산에는 꽃 피네 / 꽃이 피네 / 갈 봄 여름 없이 / 꽃이 피네 // 산에 / 산에 / 피는 꽃은 / 저만치 혼자서 피어 있네</li>
</ul>

<p>빗금의 앞뒤는 (1)과 (2)에서는 붙여 쓰며, (3)에서는 띄어 쓸 수도 있다. 단, (1)에서 어구가 두 어절 이상인 경우에는 빗금의 앞뒤를 띄어 쓸 수 있다.</p>

<h2 id="큰따옴표-">큰따옴표(“ “)</h2>

<p>(1) 직접 대화</p>

<ul>
  <li>“어머니, 제가 가겠어요.”</li>
</ul>

<p>(2) 직접 인용</p>

<ul>
  <li>나는 “어, 광훈이 아니냐?” 하는 소리에 깜짝 놀랐다.</li>
</ul>

<h2 id="작은따옴표-">작은따옴표(‘ ‘)</h2>

<p>(1) 인용한 말 안에서 인용한 말</p>

<ul>
  <li>그는 “여러분! ‘시작이 반이다.’라는 말 들어 보셨죠?”라고 말하며 강연을 시작했다.</li>
</ul>

<p>(2) 마음속으로 한 말</p>

<ul>
  <li>나는 ‘일이 다 틀렸나 보군.’ 하고 생각하였다.</li>
</ul>

<h2 id="소괄호--">소괄호((  ))</h2>

<p>(1) 주석이나 보충적인 내용</p>

<ul>
  <li>니체(독일의 철학자)의 말을 빌리면 다음과 같다.</li>
  <li>
    <ol>
      <li>
        <ol>
          <li>19.(금)</li>
        </ol>
      </li>
    </ol>
  </li>
</ul>

<p>(2) 우리말 표기와 원어 표기</p>

<ul>
  <li>기호(嗜好), 커피(coffee), 에티켓(étiquette)</li>
</ul>

<p>(3) 생략할 수 있는 요소</p>

<ul>
  <li>광개토(대)왕은 고구려의 전성기를 이끌었던 임금이다.</li>
</ul>

<p>(4) 희곡 등 대화를 적은 글에서 동작이나 분위기, 상태</p>

<ul>
  <li>현우: (가쁜 숨을 내쉬며) 왜 이렇게 빨리 뛰어?</li>
  <li>“관찰한 것을 쓰는 것이 습관이 되었죠. 그러다 보니, 상상력이 생겼나 봐요.” (웃음)</li>
</ul>

<p>(5) 내용이 들어갈 자리</p>

<ul>
  <li>우리나라의 수도는 (     )이다.</li>
</ul>

<p>(6) 항목의 순서나 종류를 나타내는 숫자나 문자</p>

<ul>
  <li>사람의 인격은 (1) 용모, (2) 언어, (3) 행동, (4) 덕성 등으로 표현된다.</li>
  <li>(가) 동해, (나) 서해, (다) 남해</li>
</ul>

<h2 id="중괄호--">중괄호({  })</h2>

<p>(1) 같은 범주에 속하는 여러 요소를 세로로 묶어서 보일 때
(2) 열거된 항목 중 어느 하나가 선택될 수 있음</p>

<ul>
  <li>아이들이 모두 학교{에, 로, 까지} 갔어요.</li>
</ul>

<h2 id="대괄호--">대괄호([  ])</h2>

<p>(1) 괄호 안에 또 괄호를 쓸 필요가 있을 때 바깥쪽의 괄호</p>

<ul>
  <li>어린이날이 새로 제정되었을 당시에는 어린이들에게 경어를 쓰라고 하였다.[윤석중 전집(1988), 70쪽 참조]</li>
  <li>이번 회의에는 두 명[이혜정(실장), 박철용(과장)]만 빼고 모두 참석했습니다.</li>
</ul>

<p>(2) 고유어에 대응하는 한자어</p>

<ul>
  <li>나이[年歲]</li>
  <li>낱말[單語]</li>
</ul>

<p>(3) 이해를 돕기 위한 설명이나 논평</p>

<ul>
  <li>그것[한글]은 이처럼 정보화 시대에 알맞은 과학적인 문자이다.</li>
  <li>신경준의 ≪여암전서≫에 “삼각산은 산이 모두 돌 봉우리인데, 그 으뜸 봉우리를 구름 위에 솟아 있다고 백운(白雲)이라 하며 [이하 생략]”</li>
  <li>그런 일은 결코 있을 수 없다.[원문에는 ‘업다’임.]</li>
</ul>

<h2 id="겹낫표--와-겹화살괄호--">겹낫표(『  』)와 겹화살괄호(≪  ≫)</h2>

<p>책의 제목이나 신문 이름 등을 나타낼 때 쓴다. <mark>큰따옴표로 대신할 수 있다.</mark></p>

<ul>
  <li>우리나라 최초의 민간 신문은 1896년에 창간된 “독립신문”이다.</li>
  <li>윤동주의 유고 시집인 “하늘과 바람과 별과 시”에는 31편의 시가 실려 있다.</li>
</ul>

<h2 id="홑낫표--와-홑화살괄호--">홑낫표(「  」)와 홑화살괄호(&lt;  &gt;)</h2>

<p>소제목, 그림이나 노래와 같은 예술 작품의 제목, 상호, 법률, 규정 등을 나타낼 때 쓴다. <mark>작은따옴표로 대신할 수 있다.</mark></p>

<ul>
  <li>사무실 밖에 ‘해와 달’이라고 쓴 간판을 달았다.</li>
  <li>‘한강’은 사진집 “아름다운 땅”에 실린 작품이다.</li>
</ul>

<h2 id="줄표">줄표(―)</h2>

<p>제목 다음에 표시하는 부제의 앞뒤. 뒤에 오는 줄표는 생략할 수 있다. 줄표의 앞뒤를 붙여쓸 수도 있다.</p>

<ul>
  <li>이번 토론회의 제목은 ‘역사 바로잡기 ― 근대의 설정 ―’이다.</li>
  <li>이번 토론회의 제목은 ‘역사 바로잡기 ― 근대의 설정’이다.</li>
  <li>이번 토론회의 제목은 ‘역사 바로잡기―근대의 설정’이다.</li>
</ul>

<h2 id="붙임표-">붙임표(-)</h2>

<p>(1) 차례대로 이어지는 내용을 하나로 묶어 열거할 때</p>

<ul>
  <li>멀리뛰기는 도움닫기-도약-공중 자세-착지의 순서로 이루어진다.</li>
  <li>김 과장은 기획-실무-홍보까지 직접 발로 뛰었다.</li>
</ul>

<p>(2) 두 개 이상의 어구가 밀접한 관련이 있음</p>

<ul>
  <li>드디어 서울-북경의 항로가 열렸다.</li>
  <li>원-달러 환율</li>
</ul>

<h2 id="물결표">물결표(~)</h2>

<p>기간이나 거리 또는 범위. 붙임표로 대신할 수 있다.</p>

<ul>
  <li>9월 15일～9월 25일</li>
  <li>서울～천안 정도는 출퇴근이 가능하다.</li>
  <li>9월 15일-9월 25일</li>
  <li>서울-천안 정도는 출퇴근이 가능하다.</li>
</ul>

<h2 id="드러냄표--와-밑줄-_-">드러냄표( ˙ )와 밑줄( _ )</h2>

<p>문장 내용 중에서 주의가 미쳐야 할 곳이나 중요한 부분을 특별히 드러내 보일 때. <mark>작은따옴표로 대신할 수 있다.</mark></p>

<ul>
  <li>중요한 것은 ‘왜 사느냐’가 아니라 ‘어떻게 사느냐’이다.</li>
  <li>다음 보기에서 명사가 ‘아닌’ 것은?</li>
</ul>

<h2 id="숨김표-">숨김표(○, ×)</h2>

<p>(1) 금기어나 비속어. 글자의 수만큼 쓴다.</p>

<ul>
  <li>배운 사람 입에서 어찌 ○○○란 말이 나올 수 있느냐?</li>
  <li>그 말을 듣는 순간 ×××란 말이 목구멍까지 치밀었다.</li>
</ul>

<p>(2) 비밀을 유지해야 하거나 밝힐 수 없는 사항</p>

<ul>
  <li>1차 시험 합격자는 김○영, 이○준, 박○순 등 모두 3명이다.</li>
</ul>

<h2 id="빠짐표">빠짐표(□)</h2>

<p>(1) 옛 비문이나 문헌 등에서 글자가 분명하지 않을 때 글자의 수만큼</p>

<ul>
  <li>大師爲法主□□賴之大□薦</li>
</ul>

<p>(2) 글자가 들어가야 할 자리</p>

<ul>
  <li>훈민정음의 초성 중에서 아음(牙音)은 □□□의 석 자다.</li>
</ul>

<h2 id="줄임표">줄임표(……)</h2>

<p>(1) 할 말을 줄였을 때
(2) 말이 없음을 나타낼 때
(3) 문장이나 글의 일부를 생략할 때</p>

<ul>
  <li>‘고유’라는 말은 문자 그대로 본디부터 있었다는 뜻은 아닙니다. …… 같은 역사적 환경에서 공동의 집단생활을 영위해 오는 동안 공동으로 발견된, 사물에 대한 공동의 사고방식을 우리는 한국의 고유 사상이라 부를 수 있다는 것입니다.</li>
</ul>

<p>(4) 머뭇거림을 보일 때 쓴다.</p>

<ul>
  <li>“우리는 모두…… 그러니까…… 예외 없이 눈물만…… 흘렸다.”</li>
</ul>

<p><mark>여섯 점을 찍는 대신 세 점을 찍을 수도 있다.</mark></p>

<ul>
  <li>“어디 나하고 한번…” 하고 민수가 나섰다.</li>
</ul>

<p>줄임표는 앞말에 붙여 쓴다. 다만, (3)에서는 줄임표의 앞뒤를 띄어 쓴다.</p>

<h2 id="맺음말">맺음말</h2>

<ul>
  <li>대체로 일상에서 사용하는 것과 그리 다르지 않다고 생각하지만, 정확히 알게 된 것 같다.</li>
  <li>겹낫표(『』)와 겹화살괄호(≪≫), 홑낫표(「」)와 홑화살괄호(&lt;&gt;)는 거의 사용하지 않았는데, 각각 큰따옴표와 작은따옴표로 대신할 수 있어 앞으로 사용하지 않을 것 같다. 다만, 화살괄호라는 용어는 자주 사용할 것 같다. 물결표(~)도 인식하기 쉬운 용어인 것 같다.</li>
  <li>줄표(―), 붙임표(-)가 있다는 것은 알았지만, 앱에서 지원하지 않는 경우가 있어 실제로 구분할 수 있을까?</li>
  <li>드러냄표(˙), 숨김표(○, ×), 빠짐표(□)도 사용 빈도가 극히 낮을 것 같다.</li>
  <li>줄임표(……)는 세 개만 쓰기로 마음먹었다. 여섯 개는 너무 많다.</li>
  <li>자판에 있으면서 정규식과 텍스트 개체에 많이 사용되는 <code class="highlighter-rouge">^</code>(caret), <code class="highlighter-rouge">`</code>(backtick), <code class="highlighter-rouge">\</code>(backslash), <code class="highlighter-rouge">|</code>(bar) 정도는 한글이 아니더라도 표준 번역어라도 정하면 좋겠다.</li>
</ul>

<h2 id="추가-링크">추가 링크</h2>

<ul>
  <li><a href="https://ko.wikipedia.org/wiki/%EB%AC%B8%EC%9E%A5_%EB%B6%80%ED%98%B8">문장 부호 - 위키백과, 우리 모두의 백과사전</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Punctuation">Punctuation - Wikipedia</a></li>
  <li><a href="http://www.urimal.kr/urimal/intro/coverage.jsp?mode=view&amp;article_no=559">2014년 보도 자료와 그림표 - 컴퓨터로 글쓰는 시대에 맞춰… 한글맞춤법 문장부호 26년만에 개정)</a> - 아래 표에서 틀린 것을 찾으세요^^</li>
</ul>

<p><img src="/images/posts/han-punctuation.jpg" alt="" /></p>
]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[MailChimp의 실리콘밸리스럽지 않은 이야기 하일라이트]]></title>
            <link>http://nolboo.kim/blog/2017/08/15/mailchimp-story/</link>
            <pubDate>Tue, 15 Aug 2017 00:00:00 +0000</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"n0lb00", "github"=>"nolboo"}]]></dc:creator>
        
            <category><![CDATA[blog]]></category>
        
        
            <category><![CDATA[highlight]]></category>
        
            <category><![CDATA[mailchimp]]></category>
        
            <category><![CDATA[startup]]></category>
        
            <guid>http://nolboo.kim/blog/2017/08/15/mailchimp-story/</guid>
            <description>
                <![CDATA[원번역글: MailChimp의 “실리콘밸리스럽지 않은” 이야기 TLDR: 스타트업이 처음부터 매출에 대한 압박을 받는다면 돈을 버는 데 익숙해지게 된다. “투자를 받으면 창업 초기 단계에서부터 나쁜 습관을 갖게 될 수 있다는 문제가 있다. 만약 당신이 스타트업 기업가이고 충분한 자금을 갖고 있다면, 그만큼 돈을 쓰는 데 익숙해지게 된다. 하지만 반대로 처음부터 매출에 대한 압박을...]]>
            </description>
            <content:encoded>
                <![CDATA[<p>원번역글: <a href="https://medium.com/@imhoyeol/mailchimp%EC%9D%98-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%EC%8A%A4%EB%9F%BD%EC%A7%80-%EC%95%8A%EC%9D%80-%EC%9D%B4%EC%95%BC%EA%B8%B0-d7caf8f1e92c">MailChimp의 “실리콘밸리스럽지 않은” 이야기</a></p>

<p>TLDR: <mark>스타트업이 처음부터 매출에 대한 압박을 받는다면 돈을 버는 데 익숙해지게 된다.</mark></p>

<blockquote>
  <p>“투자를 받으면 창업 초기 단계에서부터 나쁜 습관을 갖게 될 수 있다는 문제가 있다. 만약 당신이 스타트업 기업가이고 충분한 자금을 갖고 있다면, 그만큼 돈을 쓰는 데 익숙해지게 된다. 하지만 반대로 처음부터 매출에 대한 압박을 받는다면 돈을 버는 데 익숙해지게 된다. 돈을 버는 데 익숙해지는 것이야말로 초기 단계의 스타트업에게 꼭 필요한 것이고, 투자자의 자본에 기대지 않고 스스로 살아남기 위해 훨씬 더 필요한 습관이다.””</p>
</blockquote>

<blockquote>
  <p>Chesnut은 “우리처럼 할 수 있다는 것을 스타트업들에게 증명해보이는 것, 그것이 우리 사업의 전부이다”라고 말한다.”</p>
</blockquote>

<blockquote>
  <p>2000년 말, 고객 중 일부가 마케팅 이메일을 보내는 일을 의뢰하기 시작했다. Chesnut은 온라인 연하장 사업을 하다가 실패한 적이 있었는데, 그 때 사용하던 오래된 이메일 코드를 재활용할 수 있겠다는 생각이 들었다. 오래된 연하장 중 하나에 침팬지 그림이 있었는데, 거기서 이름을 따와 새로운 이메일 서비스의 이름을 ChimpMail로 하려고 했다. 그런데 도메인 주소가 이미 사용 중이었다. 그렇게 MailChimp가 탄생했다.”</p>
</blockquote>

<blockquote>
  <p>“중소규모의 회사를 이해하는 투자자를 지금까지 만난 적이 없다”고 Chesnut은 말한다. 벤처투자자들은 항상 MailChimp가 “대기업” — 수천명의 직원을 고용하고 있고, 어쩌면 엄청난 수익을 가져다 줄 그런 큰 회사들 — 을 위한 서비스를 제공하기를 원했다고 한다.”</p>
</blockquote>

<blockquote>
  <p>“모두가 우리에게 ‘지금 금광 위에 앉아있는 거나 다름없다. 만약 사업 방향을 대기업 대상으로 전환하면, 엄청난 성공을 거둘 수 있다’고 말한다. 하지만 우리 내면의 무언가는 그것이 좋은 방향이 아니라고 항상 말한다.””</p>
</blockquote>

]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[3 버킷 글쓰기 시스템 - 5권의 책과 1000여개의 블로그 글을 쓴 시스템]]></title>
            <link>http://nolboo.kim/blog/2017/04/14/3-bucket-writing-system/</link>
            <pubDate>Fri, 14 Apr 2017 00:00:00 +0000</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"n0lb00", "github"=>"nolboo"}]]></dc:creator>
        
            <category><![CDATA[blog]]></category>
        
        
            <category><![CDATA[writing]]></category>
        
            <category><![CDATA[system]]></category>
        
            <category><![CDATA[workflow]]></category>
        
            <category><![CDATA[tip]]></category>
        
            <guid>http://nolboo.kim/blog/2017/04/14/3-bucket-writing-system/</guid>
            <description>
                <![CDATA[Bucket #1: Ideas Bucket #2: Drafts Bucket #3: Edits Putting it together 요즘 글쓰기에 시간을 많이 들이고 있는데 글쓰기 속도가 예전 같지 않아서 끙끙대고 있었다. 여기에서 소개하고 있는 방법은 글쓰기를 시도해본 사람이라면 대부분 사용하고 있는 시스템 같다. 적어도 정보를 저장하고 메모하고 그걸 모아서 하나의 글로 작성하는 프로세스는 그리 새로운 것이...]]>
            </description>
            <content:encoded>
                <![CDATA[<ol id="markdown-toc">
  <li><a href="#bucket-1-ideas" id="markdown-toc-bucket-1-ideas">Bucket #1: Ideas</a></li>
  <li><a href="#bucket-2-drafts" id="markdown-toc-bucket-2-drafts">Bucket #2: Drafts</a></li>
  <li><a href="#bucket-3-edits" id="markdown-toc-bucket-3-edits">Bucket #3: Edits</a></li>
  <li><a href="#putting-it-together" id="markdown-toc-putting-it-together">Putting it together</a></li>
</ol>

<p>요즘 글쓰기에 시간을 많이 들이고 있는데 글쓰기 속도가 예전 같지 않아서 끙끙대고 있었다. 여기에서 소개하고 있는 방법은 글쓰기를 시도해본 사람이라면 대부분 사용하고 있는 시스템 같다. 적어도 정보를 저장하고 메모하고 그걸 모아서 하나의 글로 작성하는 프로세스는 그리 새로운 것이 아니다. 문제는 쓰려는 분량이 많아지고 종류가 많아지면 그 기본 프로세스가 깨지는 것 같다. 아직도 훈련이 확실히 되지 않는 것 같아서 나를 다잡을 겸해서 핵심만 번역했으니 관심이 있으신 분은 원문을 읽어보세요.</p>

<p>원문 : <a href="https://medium.com/the-mission/the-system-i-used-to-write-5-books-and-over-1-000-blog-posts-5872451d7461">The System I Used to Write 5 Books and Over 1,000 Blog Posts</a></p>

<p>하루에 500단어 쓰기 하다가 작가 장애(Writer’s Block)에 걸렸다.</p>

<p>맨날 커서만 째려보면서 시간을 보내다 자신만 탓했다.</p>

<p>모든 작가가 이것과 싸우고 있다. 쓰기가 하나의 작업이라는 미신을 믿기 때문이다. 앉은 자리에서 훌륭한 아이디어를 내고 500~1000단어를 쓰고, 편집해서 블로그에 포스팅한다는 것은 사실 웃기는 목표이다.</p>

<p>생각(아이디어), 창작, 편집의 세 가지 분리된 행동으로 나누었다. 세 가지 목표보다는 한 가지 목표를 가졌을 때 더 생산적이고 집중할 수 있다.</p>

<p>작가 장애에서 벗어났다.</p>

<p>분하게도 결론은 시스템이었다. 내가 아는 모든 작가는 일이 되게 하는 일종의 시스템을 가지고 있다.</p>

<p>시스템이 복잡할 필요 없다. 작동해야만 한다. 내 친구 팀 그랄은 ‘시스템은 매번 예측할 수 있는 결과를 얻는 것을 하는 방법이라고 한다. 매일 열쇠를 같은 장소에 놔두는 일과 같다.</p>

<p>아래가 내 시스템이다. 3 버킷 시스템(Three-Bucket System)이라고 부른다. 내가 글을 써내는 방법이다.</p>

<h2 id="bucket-1-ideas">Bucket #1: Ideas</h2>

<p>Drafts 앱(에버노트와 싱크)을 사용해서 아이디어를 수집한다.</p>

<p>하나의 장소에 아이디어를 수집해야 한다.</p>

<h2 id="bucket-2-drafts">Bucket #2: Drafts</h2>

<p>첫 버킷에서 아이디어를 뽑아 쓰기 시작한다. 보통 한 세션에 500단어 정도 쓴다. 슬 것에 대해 생각하지 않아도 되기 때문에 쓰기 시작하기 쉬워졌다.</p>

<p>수집한 아이디어가 나를 자극하는 역할을 하지만, 글쓰기 연습은 아니다. 일이다. 출판 의도 없는 글을 쓰지 않는다. 내 친구가 ‘의도를 가진 글쓰기’라고 부르는 것이다. 가장 좋은 습관은 공개적으로 하는 것이며, 가장 좋은 글쓰기는 출판하려는 내용이다.</p>

<p>아이디어에 대해 500단어 정도를 쓰면, 책을 쓸 때는 스크리브너의 draft로 저장하고 블로그 포스트는 Byword에 저장한다.</p>

<p>이 시스템의 핵심은 될수록 적게 생각하고 다음 작업을 해나가는 것이다.</p>

<h2 id="bucket-3-edits">Bucket #3: Edits</h2>

<p>마지막으로 반쯤 완성된 초안 중 하나를 뽑아 편집한다.</p>

<p>이 시점에서 완벽하지는 않지만 적어도 90% 완료된다. 블로그 게시를 위해 일정을 계획하거나 “Finished pieces”이라는 폴더에 집어넣는다.</p>

<p>이것은 세계가 볼 수 있는 글쓰기 조각이다. 다음 단계는 편집자 또는 출판자와 공유하거나 블로그에 게시한다. 다시 말하지만, 나는 재미로 쓰지 않는다. 모두 목적이 있다.</p>

<p>전문가는 항상 출판을 목적으로 청중을 위해 글을 쓴다. 그보다 더 작은 것이면 최선의 결과가 아닐 수 있다.</p>

<h2 id="putting-it-together">Putting it together</h2>

<p>실제로 작동하는 법이다. 일단 시작하면 시스템을 완전히 가동하는 데 2일이 걸릴 것이다.</p>

<ol>
  <li>Collect Ideas</li>
</ol>

<p>오늘 하루의 나머지 시간에 자신에게 생각나는 아이디어를 노트나 앱으로 수집한다. 나중에 편하게 다시 볼 수 있게 한다. 5개 아이디어를 생각해보고 문장이나 문구를 적는다. 아이디어를 저장하기에 충분하다.</p>

<ol>
  <li>Write and Save</li>
</ol>

<p>내일 (아침에, 또는 자신에 맞는 시간에) 글을 쓸 시간이 되면, 그 아이디어 중 하나를 첫 번째 버킷에서 꺼낸다.</p>

<p>나는 어떤 아이디어가 내게 말을 하고, 심지어 나를 부르며, 그 목소리에 귀를 기울이려고 한다. 그러나 때로는, 나는 그냥 하나를 고른다. 보통 나를 가장 흥분시키거나 마감 시간인 것을 선택한다.</p>

<p>작업이 끝나면 “drafts” 폴더에 넣고 저장한다. 그럼 오늘은 일한 것이다.</p>

<ol>
  <li>Edit and Publish</li>
</ol>

<p>그다음 날 어제의 초안으로 돌아가 편집한다. 그런 다음 버킷 3으로 옮기거나 블로그 또는 어디나 공개한다. 그런 다음 버킷 1로 이동하여 새로운 아이디어를 뽑아 다시 글쓰기를 시작한다.</p>

<p>매일 이렇게 하면 글쓰기 주제가 절대 떨어지지 않을 것이다. 편집하고 출판할 것이 떨어지는 일이 절대로 없을 것이다. 작가 장애는 다시는 없을 것이다.</p>

<p>글쓰기는 하나가 아니다. 그것은 세 개이다.</p>

]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[소프트웨어 세계화 후기]]></title>
            <link>http://nolboo.kim/blog/2017/03/20/software-globalization/</link>
            <pubDate>Mon, 20 Mar 2017 00:00:00 +0000</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"n0lb00", "github"=>"nolboo"}]]></dc:creator>
        
            <category><![CDATA[blog]]></category>
        
        
            <category><![CDATA[software]]></category>
        
            <category><![CDATA[globalization]]></category>
        
            <category><![CDATA[book]]></category>
        
            <category><![CDATA[review]]></category>
        
            <guid>http://nolboo.kim/blog/2017/03/20/software-globalization/</guid>
            <description>
                <![CDATA[소프트웨어 세계화 - 리디북스 소프트웨어를 만드는 사람들은 자신의 소프트웨어가 더 많은 사용자가 사용하길 원할 것이다. 이럴 때 세계화는 필수 프로세스로 생각이 들지만, 주위에서 세계화를 시도해 본 개발자도 그리 많지 않고, 제대로 된 프로세스를 경험한 개발자는 극히 소수인 것 같다. 이 책은 세계화 프로젝트를 마이크로소프트에서 10년 이상 경험한 저자가 자신의 경험과...]]>
            </description>
            <content:encoded>
                <![CDATA[<p><img src="/images/posts/software-global.jpg" alt="소프트웨어 세계화 표지" />
<a href="https://ridibooks.com/v2/Detail?id=443000414&amp;_s=ins&amp;_q=%25EC%2586%258C%25ED%2594%2584%25ED%258A%25B8%25EC%259B%25A8%25EC%2596%25B4%2520%25EC%2584%25B8%25EA%25B3%2584">소프트웨어 세계화 - 리디북스</a></p>

<p>소프트웨어를 만드는 사람들은 자신의 소프트웨어가 더 많은 사용자가 사용하길 원할 것이다. 이럴 때 세계화는 필수 프로세스로 생각이 들지만, 주위에서 세계화를 시도해 본 개발자도 그리 많지 않고, 제대로 된 프로세스를 경험한 개발자는 극히 소수인 것 같다. 이 책은 세계화 프로젝트를 마이크로소프트에서 10년 이상 경험한 저자가 자신의 경험과 지식을 펼쳐놓은 책이다.</p>

<blockquote>

  <p>소프트웨어에 국적은 없다.
세계를 누비는 소프트웨어, 어떻게 기획하고 만들 것인가?</p>

</blockquote>

<p>책 소개 페이지의 처음 두 문장이다. 책의 핵심 내용은 세계화, 국제화, 현지화의 개념 정립과 각 단계별 워크플로우 및 관련 기술 및 도구의 소개이다.</p>

<p>세계화, 국제화, 현지화는 각각 globalization, internationalization, localization을 한국어로 옮긴 것이다. 제품을 세계화하는 것은 제품을 국제화하고 현지화하는 것을 포함하고, 국제화는 여러 지역과 언어권에서 제품을 사용할 수 있도록 기능을 구현하는 것이고, 현지화는 UI나 다양한 리소스를 현지에 맞게 바꿔주는 것으로 설명하고 있다.</p>

<p>2014년 Common Sense Advisory의 10개국(주로 비영어권) 3,002명을 대상으로 한 설문 조사에서 75%가 모국어로 된 사이트에서 제품을 구매하길 원하며, 30%는 영어 사이트에서 물건을 절대 구매하지 않고, 30%는 거의 구매하지 않는다고 한다. 60%의 사용자가 영어 사이트에 알레르기를 일으키고 있다. 현지 언어 UI에 대해서는 70% 이상이 동의하거나 강하게 동의하고 있고, 특히 일본, 중국, 러시아는 90% 이상이 원하고 있다. 세계화는 중요한 일임이 틀림없다!</p>

<p>세계화의 범위가 매우 넓고, 전략적이고 추상적인 개념이 많아 2장까지는 조금 지루한 느낌이 있다. 김 개발 나 팀장의 일화를 이 부분에서 더 자세하고 박진감 있게 펼쳤으면 흥미롭게 읽을 수 있었을 거라는 주제넘은 생각을 해보았다.(박 전문도 가끔 나와서 전문적인 조언을 해주고..)</p>

<p>3장 유니코드 부분에서 자세한 설명이 들어가면서 조금씩 흥미로워지고, 뒤로 갈수록 구체적인 내용이 나와 한 번에 죽 읽을 수 있었다.</p>

<p>군데군데 에어비엔비, 트위터, 마이크로소프트, 구글의 사례도 언급되고 있고, 페이스북이 좋아요 버튼에 엄지손가락이 사라지게 된 이유도 설명하고 있다.(아랍권에서는 경멸의 뜻이란다)</p>

<p>ICU, 수도 문자열에 대한 것은 매우 유용했으며, 현지화 시스템과 번역 메모리 소개도 유익했다. 책에서 소개된 표준, 라이브러리, 팁, 툴을 모르고서는 세계화 프로젝트를 진행하는 것이 불가능해 보인다. 다만 번역에 필요한 업체와 소프트웨어 툴에 대한 설명이 자세하지 않은 것이 아쉬웠다.</p>

<p>단축키(shortcut)와 가속키(accelerator) 용어는 알고 있던 것과 달랐다. 물론 영어 용어를 그대로 옮기면 책의 용어가 맞겠지만 나라면 메뉴키와 단축키로 번역하고 싶다.</p>

<p>유용한 참고 링크를 본문 중에 숏링크로 제공하고 있어 추가 정보를 습득할 수 있도록 안내하고 있다.</p>

<p>마지막 국제화 및 현지화 실습은 개발자에게 직접 도움이 되는 코드 실습을 실려 있다. 직접 해보진 못했다.</p>

<p>국내에서 세계화라는 것을 그렇게 쉽게 경험할 수 없으므로, 각 단계마다 규모나 예산에 맞게 추천하는 실제 모델이 있었으면… 아니면 스타트업만의 케이스라도 구체적인 도구와 효율적인 비용을 대강이라도 명시했으면 더욱 큰 도움이 되지 않았을까 하는 아쉬움도 있다.</p>

<p>다 읽고 난 소감은 한마디로 “소프트웨어에 국적은 있다.”이다. 말장난 같아서 죄송;;  까다로워진 각 나라의 소비자에게 어필하기 위해서는 본격적인 세계화는 그렇게 만만한 작업이 아닌 것 같다는 생각이 든다.</p>

<h2 id="한국-소프트웨어-세계화-연구원">한국 소프트웨어 세계화 연구원</h2>

<p>소프트웨어 세계화로 검색해보니 <a href="http://www.ksgra.com/koreaMain/main.do">한국소프트웨어세계화연구원</a>이란 곳이 있다. 2015년 재무제표를 보니 기존에 연간 100억 이상 유입되던 자금도 끊겼고, 자본 잠식도 거의 다 된 상태이다. 물론 이 책에서 말하는 세계화와는 다르게 해외진출 소프트웨어 기업을 지원하는 것이 주요 사업으로 보인다. 적어도 이 책이 주는 정보가 이 기관의 역할보다 클 것으로 생각된다.</p>

<p>이 기관을 언급하는 이유는 책을 읽으면서 되도록 검색을 곁들이는 편인데, 이 기관의 사이트를 전부 뒤져봐도 세계화는커녕 도움이 될만한 정보는 하나도 없기에 다른 분들도 시간 낭비하지 마시길 바라는 마음으로 언급한다. 예산이 어디서 유입되는지 정확히 모르기 때문에 세금 낭비는 잘 모르겠다.</p>

<h2 id="저자-직접-강연">저자 직접 강연</h2>

<p>마지막으로 출간 기념으로 저자가 직접 강연한 것이 있어 링크한다.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/Ree-Fk7kmYM" frameborder="0" allowfullscreen=""></iframe>

<iframe src="//www.slideshare.net/slideshow/embed_code/key/1eHSkII7fSwoPK" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen=""> </iframe>
<div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/MiraPark5/ss-61071492" title="세계에서 통하는 소프트웨어 만들기 " target="_blank">세계에서 통하는 소프트웨어 만들기 </a> </strong> from <strong><a target="_blank" href="//www.slideshare.net/MiraPark5">Mira Park</a></strong> </div>

<h2 id="독서-계기">독서 계기</h2>

<p>한빛미디어에서 독자 리뷰 이벤트를 하기에 관심있던 세계화에 대한 도서가 포함되어 있어 신청했더니 덜컥 당첨되었다. 책을 받고 3주 이내에 리뷰를 올려달라고 했는데 다른 일로 까맣게 잊고 있어서 한 달도 넘었다는 것을 재촉 메일을 받고 알았다. 부랴부랴 읽고 올렸다. 늦어서 죄송합니다~</p>
]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[vi를 진정으로 이해해라]]></title>
            <link>http://nolboo.kim/blog/2017/03/05/grok-vi/</link>
            <pubDate>Sun, 05 Mar 2017 00:00:00 +0000</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"n0lb00", "github"=>"nolboo"}]]></dc:creator>
        
            <category><![CDATA[blog]]></category>
        
        
            <category><![CDATA[stackoverflow]]></category>
        
            <category><![CDATA[vi]]></category>
        
            <category><![CDATA[vim]]></category>
        
            <category><![CDATA[advanced]]></category>
        
            <category><![CDATA[tip]]></category>
        
            <guid>http://nolboo.kim/blog/2017/03/05/grok-vi/</guid>
            <description>
                <![CDATA[A sampling of more advanced tricks: A sobering thought 추가링크 원문 : Your problem with Vim is that you don’t grok vi 소스코드를 편집하는 프로그래머는 전체 라인, 여러 라인 및 코드 블록에서 작업하기를 원한다. 그러나 yy는 텍스트를 익명 복사 버퍼(vi에서는 “레지스터”라고 한다)로 복사하는 많은 방법 중 하나다. vi의 “Zen”은 일종의...]]>
            </description>
            <content:encoded>
                <![CDATA[<p><img src="/images/posts/vim.jpg" alt="Vim 3D" /></p>

<ol id="markdown-toc">
  <li><a href="#a-sampling-of-more-advanced-tricks" id="markdown-toc-a-sampling-of-more-advanced-tricks">A sampling of more advanced tricks:</a></li>
  <li><a href="#a-sobering-thought" id="markdown-toc-a-sobering-thought">A sobering thought</a>    <ol>
      <li><a href="#추가링크" id="markdown-toc-추가링크">추가링크</a></li>
    </ol>
  </li>
</ol>

<p>원문 : <a href="http://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim/1220118#1220118">Your problem with Vim is that you don’t grok vi</a></p>

<p>소스코드를 편집하는 프로그래머는 전체 라인, 여러 라인 및 코드 블록에서 작업하기를 원한다. 그러나 <code class="highlighter-rouge">yy</code>는 텍스트를 익명 복사 버퍼(vi에서는 “레지스터”라고 한다)로 복사하는 많은 방법 중 하나다.</p>

<p>vi의 “Zen”은 일종의 언어를 말하는 것이다. 초기 y는 동사(verb)다. yy 명령문(statement)은 y_와 동의어입니다. y는 일반적인 조작이므로 입력하기가 쉽도록 반복한다.</p>

<p>Vim의 선은 언어를 말하는 것이다. 첫 번째 <code class="highlighter-rouge">y</code>는 동사다. <code class="highlighter-rouge">yy</code> 명령문은 <code class="highlighter-rouge">y_</code>의 동의어다. 널리 쓰이기 때문에 타이핑하기 쉽게 <code class="highlighter-rouge">y</code>를 두 번 반복한다.</p>

<p>이것은 <code class="highlighter-rouge">dd</code> <code class="highlighter-rouge">P</code> (현재 행을 삭제하고 사본을 도로 붙여넣기; 추가 효과로 사본을 익명 레지스터에 남겨두기)로 표현할 수도 있다. <code class="highlighter-rouge">y</code>와 <code class="highlighter-rouge">d</code> “동사(verbs)”는 움직임을 “대상(subject)”으로 사용한다. 그러므로 <code class="highlighter-rouge">yW</code>는 “여기서(커서 위치)부터 현재/다음 큰 단어(WORD)의 끝까지 복사하고, <code class="highlighter-rouge">y'a</code>는 “여기에서 ‘a’ 마크가 포함된 줄까지 복사한다.”</p>

<p>vi에는 26 “마크”와 26 “레지스터”가 있다. 마크는 <code class="highlighter-rouge">m</code> 명령으로 커서의 위치를 설정한다. 각 마크는 소문자 하나로 지정된다. 따라서 <code class="highlighter-rouge">ma</code>는 ‘a’ 마크를 현재 위치로 설정하고 <code class="highlighter-rouge">mz</code>는 ‘z’ 마크를 설정한다. <code class="highlighter-rouge">'</code>(작은따옴표) 명령을 사용하여 마크가 있는 라인으로 이동할 수 있다. <code class="highlighter-rouge">'a</code>는 ‘a’ 마크가 있는 라인의 처음으로 이동한다. <code class="highlighter-rouge">`</code> (backquote) 명령으로 마크의 정확한 위치로 이동할 수 있다. 따라서 <code class="highlighter-rouge">`z</code>는 ‘z’ 마크의 정확한 위치로 바로 이동한다.</p>

<p>이들은 “이동”이기 때문에 다른 “명령문”의 대상으로 사용할 수도 있다.</p>

<p>텍스트를 원하는 대로 선택해서 잘라내는 방법의 하나는 마크하는 것이다 (보통 ‘a’를 첫 번째 마크, ‘z’를 다음 마크, ‘b’는 다른 마크로, ‘e’를 또 다른 마크로 사용한다). 또 다른 (vi를 사용하는 15년 동안 4개 이상의 마크를 사용한 것은 기억나지 않는다; 사용자들은 문맥을 방해하지 않도록 마크와 레지스터를 매크로에서 사용하는 자신만의 규칙을 만든다) 그런 다음 원하는 텍스트의 다른 쪽 끝으로 이동한다: 다른 끝에서 시작할 수 있다, 중요하지 않다. <code class="highlighter-rouge">d`a</code>로 잘라내거나 <code class="highlighter-rouge">y`a</code>로 복사할 수 있다. 전체 프로세스가 5개의 키 입력이다. (“입력” 모드에서 시작하면 <code class="highlighter-rouge">&lt;Esc&gt;</code>로 명령 모드를 나가야 하므로 6이다) 잘라내거나 복사한 다음 복사본을 붙여넣는 것은 단일 키 입력이다: <code class="highlighter-rouge">p</code>.</p>

<p>이것이 텍스트를 잘라내거나 복사하는 하나의 방법이다. 그러나 많은 방법의 하나이다. 커서를 움직이거나 마크하지 않고도 텍스트의 범위를 더 간결하게 설명할 수 있다. 예를 들어 텍스트의 단락 안에서 단락의 처음이나 끝까지 각각 <code class="highlighter-rouge">{</code>와 <code class="highlighter-rouge">}</code>로 이동할 수 있다. 텍스트의 단락을 옮기려면 <code class="highlighter-rouge">{</code> <code class="highlighter-rouge">d}</code> (3 키 입력)으로 잘라낸다. 이미 단락의 첫 줄 또는 마지막 줄에 있을 때는 간단히 <code class="highlighter-rouge">d}</code> 또는 <code class="highlighter-rouge">d{</code>를 사용할 수 있다.</p>

<p>“단락” 개념은 보통 직관적으로 그럴듯한 것을 기본으로 한다. 평문뿐만 아니라 코드에서도 종종 동작한다.</p>

<p>원하는 텍스트의 한쪽 끝 또는 다른 끝을 마크하는 패턴(정규식)을 안다. 앞으로 또는 뒤로 검색하는 것은 vi에서 이동이다. 따라서 “명령문”에서 “대상”으로 사용할 수 있다. <code class="highlighter-rouge">d/foo</code>로 현재 줄에서 “foo” 문자열을 포함하는 다음 줄까지 잘라낼 수 있다. <code class="highlighter-rouge">y?bar</code>로 현재 줄에서 “bar” 문자열을 포함하는 가장 가까운 (이전) 줄까지 복사할 수 있다. 전체 라인을 원하지 않는다면 검색 이동을 (명령문으로) 여전히 사용하고, 마크를 지정하고 이전에 설명한 <code class="highlighter-rouge">`x</code> 명령을 사용할 수 있다.</p>

<p>“동사” 및 “대상” 말고도 vi는 “목적어(objects)”(용어의 문법적 의미로)도 있다. 지금까지 익명 레지스터의 사용만 설명했다. 그러나 <code class="highlighter-rouge">"</code>(이중 따옴표 수정자)를 접두사로 하는(prefixing) “목적어” 참조를 26개의 “이름(named)” 레지스터도 사용할 수 있다. <code class="highlighter-rouge">"add</code>로 <code class="highlighter-rouge">a</code> 레지스터에 현재 줄을 잘라내거나, <code class="highlighter-rouge">"by/foo</code>로 현재부터 “foo”가 포함된 다음 줄까지 텍스트를 ‘b’ 레지스터로 복사할 수 있다. 레지스터에서 붙여넣으려면 같은 수정자를 앞에 붙이면 된다: <code class="highlighter-rouge">"ap</code>는 ‘a’ 레지스터의 내용을 커서 뒤에 붙여넣고 <code class="highlighter-rouge">"bP</code>는 현재 줄 앞에 ‘b’ 레지스터의 내용을 붙여넣는다.</p>

<p>“접두어(prefixes)”라는 개념은 텍스트 조작 “언어”에 “형용사(adjectives)”와 “부사(adverbs)”와 문법적으로 비슷한 것을 추가한다. 대부분의 명령(동사)과 동작(상황에 따라 동사 또는 목적어)은 숫자 접두사를 사용할 수도 있다. <code class="highlighter-rouge">3J</code>는 “다음 3줄을 합침”을 의미하고 <code class="highlighter-rouge">d5}</code>는 “현재 줄에서 밑으로 5번째 단락의 끝까지 삭제”를 뜻한다.</p>

<p>이것은 모두 중급 레벨 vi이다. Vim에만 국한되는 것은 아니며, 배우려고만 하면 훨씬 높은 중급 기술이 있다. 텍스트 조작 언어가 에디터의 “기본” 언어를 사용하여 작업 대부분을 쉽게 수행할 수 있도록 매우 간결하고 표현력이 풍부하므로, 이러한 중급 개념을 숙달하면 매크로를 작성할 필요가 거의 없음을 알 수 있다.</p>

<h2 id="a-sampling-of-more-advanced-tricks">A sampling of more advanced tricks:</h2>

<p>많은 <code class="highlighter-rouge">:</code> 명령이 있지만, 특히 <code class="highlighter-rouge">:% s/foo/bar/g</code> 전역 대체(substitution) 기술이 있다. (이것은 중급은 아니다. 그러나 다른 <code class="highlighter-rouge">:</code> 명령은 그럴 수 있다) 역사적으로 전체 <code class="highlighter-rouge">:</code> 명령 집합은 vi의 이전 버전인 ed(line editor)와 나중에 나온 ex(extended line editor) 유틸리티에서 상속되었다. 실제로 vi는 ex의 시각적 인터페이스(visual interface)이기 때문에 그렇게 이름 지었다.</p>

<p><code class="highlighter-rouge">:</code> 명령은 보통 텍스트의 라인에 걸쳐 동작한다. ed와 ex는 터미널 화면이 흔하지 않고 많은 터미널이 “텔레 타입”(TTY) 장치였던 시대에 작성되었다. 따라서 텍스트의 인쇄본에서 작업하는 것이 일반적이었고 매우 간결한 인터페이스를 통해 명령어를 사용하였다. (일반적인 연결 속도는 초당 110 baud 또는 대략 초당 11문자였다 - 빠른 타이피스트보다 느리다; 정체(lags. 렉 먹는 것)은 다중 사용자 인터랙티브 세션에서는 일반적이었다; 또한 종이로 보존하려는 약간의 동기가 있었다)</p>

<p>그래서 대부분의 <code class="highlighter-rouge">:</code> 명령어의 문법은 명령 뒤에 주소와 주소 범위(줄 번호)를 포함한다. <code class="highlighter-rouge">:127,215 s/foo/bar</code>는 127과 215 사이의 줄에서 처음 만나는 “foo”를 “bar로 대치한다. 현재 줄은 <code class="highlighter-rouge">.</code>, 마지막 줄은 <code class="highlighter-rouge">$</code>로 약어를 쓸 수도 있다. 현재 줄의 뒤로는 <code class="highlighter-rouge">+</code>, 앞으로는 <code class="highlighter-rouge">-</code>를 상대적인 파생(offset) 접두어로 사용할 수 있다. 그래서 <code class="highlighter-rouge">:.,$j</code>는 현재 줄부터 마지막 줄까지 모두 한 줄로 합친다”를 뜻한다. <code class="highlighter-rouge">:%</code>는 (모든 줄) <code class="highlighter-rouge">:1,$</code>와 같다.</p>

<p><code class="highlighter-rouge">:... g</code>와 <code class="highlighter-rouge">:... v</code> 명령은 대단히 강력하다. <code class="highlighter-rouge">:... g</code>는 패턴에 매칭되는 모든 줄에 후속 명령을 “전역적으로(globally)” 적용하는 접두어이고, <code class="highlighter-rouge">:... v</code>(conVerse(반대))는 패턴에 일치하지 않는 모든 줄에 적용한다. 다른 ex 명령처럼 이것들은 주소/범위 참조를 접두할 수 있다. <code class="highlighter-rouge">:.,+21g/foo/d</code>는 “현재 줄부터 다음 21줄에 걸쳐 “foo”를 포함하는 모든 줄을 지우는 것”을 뜻하고, <code class="highlighter-rouge">:.,$v/bar/d</code>는 “현재 줄부터 파일의 끝까지 “bar”를 포함하지 않는 모든 줄을 지우는 것”을 뜻한다.</p>

<p>유닉스 명령어 <strong>grep</strong>이 ex 명령에서 실제로 영감을 받았다는 것은 흥미롭다. ex 명령 <code class="highlighter-rouge">:g/re/p</code>(grep)은 “정규식(regular expression)” (re)를 포함하는 줄을 “전역적으로(globally)” “인쇄(print)”하는 법을 문자화한 것이다. ed와 ex가 사용될 때 <code class="highlighter-rouge">:p</code> 명령은 첫 번째로 배우는 것 중 하나였고 파일을 편집할 때 자주 사용되는 첫 번째 명령이었다. 현재 내용(보통 <code class="highlighter-rouge">:.,+25p</code>와 같이 사용하여 한 번에 한 페이지 전체)을 인쇄하는 방법이었다.</p>

<p><code class="highlighter-rouge">:% g/.../d</code> 혹은 (reVerse/conVerse 짝인) <code class="highlighter-rouge">:% v/.../d</code>이 가장 일반적인 사용 패턴이다. 기억할만한 다른 ex 명령 짝도 있다.</p>

<p>줄을 근처로 옮길(move) 때 <code class="highlighter-rouge">m</code>을, 줄을 합칠(join) 때 <code class="highlighter-rouge">j</code>를 사용할 수 있다. 예로 목록에서 매칭되는(또는 반대로(conversely) 매칭되지 않는) 모든 것을 지우지 않고 분리하길 원하면 <code class="highlighter-rouge">:% g/foo/m$</code>와 같이 사용할 수 있다. 모든 “foo”(를 포함하는) 줄은 파일의 끝으로 옮겨질 것이다. (scratch(낙서) 공간으로 파일의 끝을 사용하는 다른 팁도 알아둬라) 목록에서 빼낸 모든 “foo” 줄은 상대적인 순서로 된다.(<code class="highlighter-rouge">1G!GGmap!Ggrep</code> <code class="highlighter-rouge">foo&lt;ENTER&gt;1G:1,'a g/foo'/d</code> (파일 끝으로 파일을 복사하고, <code class="highlighter-rouge">grep</code>으로 필터링하고, 나머지 모든 헤드 부분을 지우기)를 실행하는 것과 같다)</p>

<p>줄을 합치기 위해 합치려는 모든 줄에서 패턴을 찾을 수 있다. (예로, 글 머리 기호 목록에서 “^*“보다 “^ “로 시작하는 모든 줄) 그럴 때는 (일치하는 모든 줄에서 한줄 올리고 합치도록) <code class="highlighter-rouge">:% g/^   /-1j</code>을 사용한다. (부언하면: 글머리 기호 줄을 찾아 다음 줄을 합치는 것은 두 가지 이유로 동작하지 않는다… 하나의 글머리 기호 줄은 다른 것과 합칠 수 있다. 이어지는 모든 줄에 글머리 기호 줄을 합치지 않을 것이다; 쌍으로 인접하는 것에만 동작한다.)</p>

<p><code class="highlighter-rouge">s</code>(substitute)를 <code class="highlighter-rouge">g</code>와 <code class="highlighter-rouge">v</code> (global/converse-global) 명령과 사용할 수 있음은 물론이다. 보통 그럴 필요가 없다. 그러나 다른 패턴과 일치하는 줄에만 대체하려고 하는 경우를 생각해보자. 종종 복잡한 패턴을 사용할 수 있고, 변경을 원하지 않는 줄 부분을 보존하기 위해 역참조를 사용한다. 그러나, 대체에서 일치하는 부분을 분리하는 것이 더 쉬울 것이다: <code class="highlighter-rouge">:% g/foo/s/bar/zzz/g</code> – “foo”를 포함하는 모든 줄에서 모든 “bar”를 “zzz”로 대치. (<code class="highlighter-rouge">:% s/\(.*foo.*\)bar\(.*\)/\1zzz\2/g</code>와 같은 것은 같은 줄에 “foo”가 먼저 오는 “bar”의 사례에만 동작할 것이다; 이미 매우 꼴사납다. 그리고 “bar”가 “foo”보다 앞서는 모든 경우를 잡기 위해 더 망가져야 할 것이다)</p>

<p>주요점은 <code class="highlighter-rouge">ex</code> 명령어 세트에 <code class="highlighter-rouge">p</code>, <code class="highlighter-rouge">s</code>, <code class="highlighter-rouge">d</code>보다 더 많은 것이 있다는 것이다.</p>

<p><code class="highlighter-rouge">:</code> 주소도 마크를 참조할 수 있다. 그래서 ‘a’와 ‘b’ 마크 사이의 줄에서 foo 문자열을 포함하는 모든 줄을 합치려면 <code class="highlighter-rouge">:'a,'bg/foo/j</code>를 사용할 수 있다. (그렇다, 앞의 <code class="highlighter-rouge">ex</code> 명령 예제의 모든 경우에서 이러한 종류의 주소 표현을 접두해서 파일의 줄 서브셋을 한정할 수 있다)</p>

<p>나도 지난 15년간 몇 번 정도 사용했다. 그러나, 올바른 주문을 생각할 시간이 있다면 훨씬 효과적으로 수행될, 반복적이고 인터렉티브하게 일을 한다.</p>

<p>또 다른 매우 유용한 vi 혹은 ex 명령은 다른 파일의 내용을 읽어오는(read) <code class="highlighter-rouge">:r</code>이다. <code class="highlighter-rouge">:r foo</code>는 현재 줄에 “foo”라는 파일의 내용을 삽입한다.</p>

<p><code class="highlighter-rouge">:r!</code>은 더욱 강력하다. 이것은 명령의 결과를 읽는다. vi 세션을 일시적으로 정지하고, 명령을 수행하고, 임시 파일에 출력을 리다이렉트하고, vi 세션을 다시 실행하여 임시 파일에서 내용을 읽어오는 것과 같다.</p>

<p><code class="highlighter-rouge">!</code>(bang)과 <code class="highlighter-rouge">:... !</code>(ex bang) 명령은 훨씬 더 강력하다. 이것도 외부 명령을 실행하고 현재 텍스트 안으로 결과를 읽어온다. 그러나, 특정 명령으로 텍스트의 선택을 필터링할 수도 있다! <code class="highlighter-rouge">1G!Gsort</code>(<code class="highlighter-rouge">G</code>는 vi의 “goto” 명령이다; 기본적으로는 파일의 마지막 줄로 간다, 그러나 1(첫 번째 줄)과 같이 줄 넘버를 접두할 수 있다)을 사용하여 파일의 모든 줄을 정렬할 수 있다. ex 버전인 <code class="highlighter-rouge">:1,$!sort</code>와 같다. 작가들이 종종 사용한다! Unix <strong>fmt</strong> 또는 <strong>fold</strong> 유틸리티를 사용하여 텍스트의 “줄 바꿈(word wrapping)” 또는 다시 포맷한다. 일반적인 매크로는 <code class="highlighter-rouge">{!}fmt</code>(현재 단락을 다시 포맷)이다. 프로그래머는 <strong>들여쓰기(indent)</strong> 또는 다른 코드 리포매팅 도구를 사용하여 코드를 실행하거나 코드 일부만 실행하기도 한다.</p>

<p><code class="highlighter-rouge">:r!</code> 그리고 <code class="highlighter-rouge">!</code> 명령을 사용하는 것은 외부 유틸리티나 필터를 에디터의 확장(extension)으로 취급할 수 있음을 의미한다. 데이터베이스에서 데이터를 가져오는 스크립트와 사용하거나 웹 사이트에서 데이터를 가져오는 <strong>wget</strong>, <strong>lynx</strong> 명령이나 원격 시스템에서 데이터를 가져오는 <strong>ssh</strong> 명령과 함께 가끔 사용한다.</p>

<p>또 다른 유용한 ex 명령은 <code class="highlighter-rouge">:so</code>(<code class="highlighter-rouge">:source</code>의 준말)이다. 이것은 파일 내용을 일련의 명령으로 읽는다. 보통 vi를 시작하면 암시적으로 <code class="highlighter-rouge">~/.exinitrc</code> 파일에서 <code class="highlighter-rouge">:source</code>를 실행한다. (그리고 Vim은 보통 <code class="highlighter-rouge">~/.vimrc</code> 파일을 사용한다) 이 기능을 사용하면 새로운 매크로 세트, 약어 및 에디터 설정을 읽어 들여(sourcing) 에디터 프로필을 변경할 수 있다. 파일에 따라 적용하는 ex 편집 명령의 시퀀스를 저장하는 트릭으로 사용할 수도 있다.</p>

<p>예를 들어 <strong>wc</strong>로 파일을 실행하는 일곱 줄의 파일 (36자)을 가지고 있고, 파일의 맨 위에 단어 개수 데이터를 C 스타일 주석으로 삽입하려 한다. <code class="highlighter-rouge">vim + 'so mymacro.ex' ./mytarget</code>과 같은 명령을 사용하여 “매크로”를 파일에 적용할 수 있다.</p>

<p>(vi와 Vim의 <code class="highlighter-rouge">+</code> 명령행 옵션은 보통 주어진 행 번호에서 편집 세션을 시작하는 데 사용한다. 그러나 <code class="highlighter-rouge">+</code>에 “source” 같이 유효한 ex 명령/표현식이 뒤따를 수 있다는 사실은 거의 알려지지 않았다; 간단한 예로 다음 스크립트가 있다: <code class="highlighter-rouge">vi +'/foo/d|wq!' ~/.ssh/known_hosts</code>는 SSH known hosts 파일에서 비대화식으로 항목을 제거하고 서버 집합을 다시 이미징한다)</p>

<p>대개 Perl, AWK, <strong>sed</strong>(ed 명령에서 실제 영감을 얻은 유틸리티인 <strong>grep</strong>과 같은)를 사용하여 “매크로”를 작성하기가 훨씬 쉽다.</p>

<p><code class="highlighter-rouge">@</code> 명령은 아마도 가장 모호한 vi 명령일 것이다. 10년 가까이 고급 시스템 관리 교육 과정을 가끔 가르치면서 사용해본 사람을 거의 만나지 못했다. <code class="highlighter-rouge">@</code>은 레지스터 내용을 vi나 ex 명령인 것처럼 실행합니다.
예 : <code class="highlighter-rouge">:r!locate ...</code>를 사용하여 시스템에서 파일을 찾고 이름을 문서로 읽어 들인다. 그리고 관심 있는 파일에 대한 전체 경로만 남겨둔 채 불필요한 것은 지운다. 경로의 구성마다 <code class="highlighter-rouge">&lt;Tab&gt;</code> 완성하는 것보다 낫다(탭 완성을 지원하지 않는 vi가 있는 머신을 만날 때는 더욱 힘들다): 다음을 사용한다.</p>

<ol>
  <li><code class="highlighter-rouge">0i:r</code> (현재 줄을 유효한 <code class="highlighter-rouge">:r</code> 명령으로 만든다)</li>
  <li><code class="highlighter-rouge">cdd</code> (“c” 레지스터에 그 줄을 잘라내고)</li>
  <li><code class="highlighter-rouge">@c</code>로 명령을 실행한다.</li>
</ol>

<p>단지 10개의 키 입력이다. (그리고 <code class="highlighter-rouge">"cdd</code> <code class="highlighter-rouge">@c</code>는 효과적으로 핑거(손이 기억하는) 매크로이다. 그래서 보통 6글자의 단어처럼 빠르게 타이핑할 수 있다)</p>

<h2 id="a-sobering-thought">A sobering thought</h2>

<p>vi 파워의 표면만 훑었다. 여기에 설명한 것은 vim의 이름이 된 “improvements”의 일부분도 아니다! 여기서 설명한 모든 내용은 20, 30년 전의 vi에서도 동작한다.</p>

<p>내가 사용한 것보다 훨씬 많은 vi 파워를 사용해온 사람들이 있다.</p>

<h3 id="추가링크">추가링크</h3>

<ul>
  <li><a href="https://nolboo.kim/practical-vim/">Practical Vim 2판 정리 페이지</a></li>
  <li><a href="https://nolboo.kim/blog/2016/11/15/vim-for-beginner/">완전 초보를 위한 Vim</a></li>
</ul>

]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[Vim을 시작하는 법]]></title>
            <link>http://nolboo.kim/blog/2017/02/24/getting-started-with-vim/</link>
            <pubDate>Fri, 24 Feb 2017 00:00:00 +0000</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"n0lb00", "github"=>"nolboo"}]]></dc:creator>
        
            <category><![CDATA[blog]]></category>
        
        
            <category><![CDATA[practical]]></category>
        
            <category><![CDATA[vim]]></category>
        
            <category><![CDATA[beginner]]></category>
        
            <guid>http://nolboo.kim/blog/2017/02/24/getting-started-with-vim/</guid>
            <description>
                <![CDATA[vimtutor Vim has no shortcuts Vim plugins fugitive.vim tpope plugins Practical Vim Again, how do I get into Vim? 추가링크 원문 : Getting started with Vim 이 글의 목표는 불안과 좌절 없이 Vim을 시작하기위한 길을 제안하는 것이며,각 주제의 세부 사항에 대해 설명하지 않을 것이다. 훌륭한 자료가 있으며 각 섹션의 끝...]]>
            </description>
            <content:encoded>
                <![CDATA[<p><img src="/images/posts/vim.jpg" alt="Vim 3D" /></p>

<ol id="markdown-toc">
  <li><a href="#vimtutor" id="markdown-toc-vimtutor">vimtutor</a></li>
  <li><a href="#vim-has-no-shortcuts" id="markdown-toc-vim-has-no-shortcuts">Vim has no shortcuts</a></li>
  <li><a href="#vim-plugins" id="markdown-toc-vim-plugins">Vim plugins</a>    <ol>
      <li><a href="#fugitivevim" id="markdown-toc-fugitivevim">fugitive.vim</a></li>
      <li><a href="#tpope-plugins" id="markdown-toc-tpope-plugins">tpope plugins</a></li>
    </ol>
  </li>
  <li><a href="#practical-vim" id="markdown-toc-practical-vim">Practical Vim</a></li>
  <li><a href="#again-how-do-i-get-into-vim" id="markdown-toc-again-how-do-i-get-into-vim">Again, how do I get into Vim?</a>    <ol>
      <li><a href="#추가링크" id="markdown-toc-추가링크">추가링크</a></li>
    </ol>
  </li>
</ol>

<p>원문 : <a href="http://lucapette.me/getting-started-with-vim">Getting started with Vim</a></p>

<p>이 글의 목표는 불안과 좌절 없이 Vim을 시작하기위한 길을 제안하는 것이며,각 주제의 세부 사항에 대해 설명하지 않을 것이다. 훌륭한 자료가 있으며 각 섹션의 끝 부분에 링크할 것이다.</p>

<h2 id="vimtutor">vimtutor</h2>

<p>Vim에는 멋진 튜토리얼이 있다. 이미 기본을 알고 있다고 생각하더라도 튜토리얼에서 시작하는 것이 좋다. 25-30 분이 걸리고 한방에 끝내는 것이 좋다. 시스템에 Vim이 있으면 <code class="highlighter-rouge">vimtutor</code>를 입력하고 바로 시작할 수 있다. 이 튜토리얼는 모든 기본 명령과 개념을 가르쳐 주도록 고안되었다. Vim은 다양한 <a href="https://en.wikibooks.org/wiki/Learning_the_vi_Editor/Vim/Modes">모드</a>를 가진 <a href="http://unix.stackexchange.com/questions/57705/modeless-vs-modal-editors#57708">모달 편집기</a>이다. 이 특성이 새로울 것이고 튜토리얼은 천천히 진행될 것이다.</p>

<h2 id="vim-has-no-shortcuts">Vim has no shortcuts</h2>

<p>다음 단계는 Vim을 매일 사용하는 것이다. 그러나 Vim에서의 텍스트 편집이 어색하고 외울 것이 많고 대부분의 명령이 기억하기 쉽지 않기 때문에 쉬운 목표는 아니다. 이러한 이유로 “Vim way”에 대한 이해를 공유하고 싶다. 이 접근법을 통해 Vim을 좀 더 친숙하게 만들 수 있다고 확신한다.</p>

<p>대학에서 C 프로그래밍 및 운영 체제에 대한 랩 수업에서 Vim을 만났다. 압도적이었다. Vim을 전혀 이해하지 못했고, 교수님도 우호적이거나 도움이 되지 않다. <code class="highlighter-rouge">dd</code>, <code class="highlighter-rouge">yy</code>, <code class="highlighter-rouge">A</code>와 같은 모든 것들은 도대체 왜  Vim을 사용하는지 의아하게 만들었다. 어떻게 모든 단축키를 기억할 수 있을까? 모든 종류의 단축키가 있는 IDE에 쓰기도 했지만, 그것들은 기억하기 쉬웠다. 또한, 잊어 버렸을 때는 직관적인 레이블이 있는 메뉴가 있었다. Vim 명령은 기억하기 쉽지 않았고 이 문제는 몇 주 동안 나를 괴롭혔다. Vim에 겁먹었고 결국 IDE로 돌아갔다.</p>

<p>충격적인 경험이 있은지 2년 후에 Vim을 다시 사용해 보았다. 그 때는 Perl과 Ruby를 사용하고 있었고 IDE는 터미널 중심의 워크플로우에 맞지 않았다. 그러던 어느 날 나는 <a href="http://vimdoc.sourceforge.net/htmldoc/motion.html#object-select">텍스트 개체</a>를 만났다. 전환점이 되었다. 요즘에는 텍스트 개체가 다른 편집기로 코드를 편집 할 수 없는 이유다. 텍스트의 범위를 설명 할 수 있다. 몇 가지 예다:</p>

<ul>
  <li>A word(단어)</li>
  <li>A sentence(문장)</li>
  <li>A paragraph(단락)</li>
  <li>A HTML tag(태그)</li>
  <li>A function(함수)</li>
</ul>

<p>Vim에는 텍스트 삭제 명령, 붙여 넣기 명령 등의 명령이 있다. 명령을 텍스트 개체와 결합하여 텍스트 편집용 강력한 작은 언어를 얻을 수 있다. 다음과 같이 말할 수 있다:</p>

<ul>
  <li>다음 세 단어 제거하기(Remove the next three words)</li>
  <li>이 단락 복사하기(Copy this paragraph)</li>
  <li>이 HTML 태그의 내용을 변경하기(Change the content of this HTML tag)</li>
</ul>

<p>Vim에 단축키가 없다고 말하는 이유다. 이렇게 설명하고 싶다:</p>

<blockquote>
  <p>Vim은 작은 사용자 인터페이스를 가진 텍스트 편집을 위한 작은 언어다.</p>
</blockquote>

<p>작은 사용자 인터페이스가 편집기(editor)다. 이 관점에서 보면 깨달을 수 있습니다. 표준 라이브러리를 배우는 대신 언어가 작동하는 방법을 배우는 데 집중할 수 있다. “Vim way”로 텍스트를 편집하는 것에 집중할 수 있다. 이 방법으로 Vim에 접근하는 것 더 쉽고 학습 곡선이 더 점진적이라고 생각한다.</p>

<p>시작했을 때 누군가 설명해주기를 바랐던 Vim의 또 다른 측면은 일반 모드에 초점을 맞추는 것이다. Vim에는 여러 모드가 있지만 이름 때문에 두드러지는 모드이다. 이 모드에서 Vim을 사용하는 것이 보통(normal)이므로 “일반(normal)” 모드라고 한다. 대부분의 편집은 이 모드에서 수행한다: 텍스트를 이동하거나 붙여넣거나 삭제할 수 있다. 모두 일반 모드에서 한다. Vim이 작은 언어라는 생각과 텍스트 개체와 일반 모드에서의 초점을 결합할 수 있다.</p>

<blockquote>
  <p>Vim은 텍스트 개체를 통해 텍스트를 조작하는 일반 모드가 있다.</p>
</blockquote>

<p>링크:</p>

<ul>
  <li><a href="http://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/">Vim Text Objects: The Definitive Guide</a>, <a href="https://nolboo.kim/blog/2016/10/13/vim-text-objects-definitive-guide/">Vim 텍스트 개체: 궁극의 가이드</a></li>
  <li><a href="http://vimdoc.sourceforge.net/htmldoc/motion.html#object-select">:h text-objects</a></li>
  <li><a href="http://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim/1220118#1220118">Your problem with Vim is that you don’t grok vi.</a></li>
</ul>

<h2 id="vim-plugins">Vim plugins</h2>

<p>Vim에 필요한 모든 것이 있지 않지만 생태계에서 방법을 찾는 것이 까다로울 수 있다. 같은 문제를 해결하려는 많은 플러그인이 있으며 하나를 꼭집어 선택하기도 까다롭다. 예전에 Vim을 <a href="http://lucapette.me/vim-for-rails-developers-lazy-modern-configuration">설정하는</a> 방법에 관해 썼다. 그러나 오늘 같은 기사를 쓴다면 플러그인 관리에 더 집중할 것이다: 더 쉬워졌다. <a href="https://github.com/VundleVim/Vundle.vim">Vundle.vim</a>을 사용하고 있고, 행복하다. Vundle도 사용하라고 제안한다. 플러그인 설치, 업데이트 및 제거를 수행 할 수있는 몇 가지 간단한 명령이 있으므로 아무 것도 기억하지 않아도된다. 단순성이 핵심이다. 많은 플러그인을 가지고 놀 수 있기 때문에 플러그인을 추가하거나 제거하는 것이 쉽다.</p>

<p>사람마다 워크플로우가 매우 다르므로 “놓칠 수없는 100 개의 Vim 플러그인” 목록을 열거하지는 않을 것이다. 그러나 시작할 수 있게 최소한의 도움을 주려고 한다.</p>

<h3 id="fugitivevim">fugitive.vim</h3>

<p><a href="https://github.com/tpope/vim-fugitive">fugitive.vim</a>은 git과 관련하여 완벽한 동반자다. 저자의 말:</p>

<blockquote>
  <p>거짓말하지 않겠다; fugitive.vim은 사상 최고의 Git 래퍼(wrapper)다.</p>
</blockquote>

<p>대담한 주장처럼 들릴지 모르겠지만, 나는 그렇게 생각하지 않는다. 이 플러그인은 정말 멋지고 유쾌한 기능을 가지고 있다. 사용법을 배우는 가장 좋은 방법은 좋은 <a href="http://vimcasts.org/blog/2011/05/the-fugitive-series/">스크린 캐스트</a>를 보는 것이다.</p>

<h3 id="tpope-plugins">tpope plugins</h3>

<p><a href="https://github.com/tpope">tpope</a>는 fugitive.vim의 저자일뿐만 아니라, 믿을 수 없을 정도로 긴 목록의 필수 플러그인을 만들고 관리한다. 제 제안은 저장소 목록을 훑어보면서 필요한 모든 플러그인을 사용해보라는 것이다. 하나 골라야한다면, 그것은 <a href="https://github.com/tpope/vim-surround">surround.vim</a>이다. 코드 편집은 종종 “주변(surroundings)”을 다루는 것을 뜻한다: 괄호, 대괄호, 따옴표 등. Surround.vim은 이런 걸 다루는 데 엄청난 도움이 된다.</p>

<p>링크:</p>

<ul>
  <li><a href="http://vimawesome.com/">Vim Awesome</a></li>
</ul>

<h2 id="practical-vim">Practical Vim</h2>

<p><a href="https://twitter.com/nelstrom">Drew Neil</a>은 <a href="https://pragprog.com/book/dnvim/practical-vim">Practical Vim</a>을 썼다. Vim 지식을 심화하고자하는 사람에게 완벽한 책이다. 매일 Vim을 사용하는 것에 익숙해지면 이 책을 추천한다. 훌륭한 팁 모음이며 학습 경로를 빠르게 한다. 더 좋은 자료를 상상할 수 없다. “Practical Vim”을 읽기 <em>전</em> 과 <em>후</em> 가 있다고 생각한다.</p>

<p>Drew Neil은 <a href="http://vimcasts.org/">vimcasts</a>에서 꽤 많은 스크린 캐스트를 올려놨고, 그것들도 추천한다. Drew의 설명은 명확하고 따라하기 쉽다.</p>

<h2 id="again-how-do-i-get-into-vim">Again, how do I get into Vim?</h2>

<p>제안하는 단계는 다음과 같다:</p>

<ul>
  <li>튜터(Vimtutor)를 끝낸다.</li>
  <li>Vim way로 텍스트에 관해 생각한다.</li>
  <li>플러그인 생태계를 배운다.</li>
  <li>베스트 책을 읽고 저자의 모든 스크린 캐스트 본다.</li>
</ul>

<p>Happy editing!</p>

<h3 id="추가링크">추가링크</h3>

<ul>
  <li><a href="https://nolboo.kim/practical-vim/">Practical Vim 2판 정리 페이지</a></li>
  <li><a href="https://nolboo.kim/blog/2016/11/15/vim-for-beginner/">완전 초보를 위한 Vim</a></li>
</ul>

]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[Practical Vim 팁 요약 시리즈 - Macros]]></title>
            <link>http://nolboo.kim/blog/2017/02/10/practical-vim/</link>
            <pubDate>Fri, 10 Feb 2017 00:00:00 +0000</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"n0lb00", "github"=>"nolboo"}]]></dc:creator>
        
            <category><![CDATA[blog]]></category>
        
        
            <category><![CDATA[practical]]></category>
        
            <category><![CDATA[vim]]></category>
        
            <category><![CDATA[tip]]></category>
        
            <category><![CDATA[beginner]]></category>
        
            <category><![CDATA[advance]]></category>
        
            <guid>http://nolboo.kim/blog/2017/02/10/practical-vim/</guid>
            <description>
                <![CDATA[CHAPTER 11. Macros Tip 65. Record and Execute a Macro Capture a Sequence of Commands by Recording a Macro Play Back a Sequence of Commands by Executing a Macro Execute the Macro in Series Execute the Macro in Parallel Tip 66. Normalize, Strike, Abort Normalize the Cursor Position Strike Your...]]>
            </description>
            <content:encoded>
                <![CDATA[<p><img src="/images/posts/vim.jpg" alt="Vim 3D" /></p>

<ol id="markdown-toc">
  <li><a href="#chapter-11-macros" id="markdown-toc-chapter-11-macros">CHAPTER 11. Macros</a>    <ol>
      <li><a href="#tip-65-record-and-execute-a-macro" id="markdown-toc-tip-65-record-and-execute-a-macro">Tip 65. Record and Execute a Macro</a>        <ol>
          <li><a href="#capture-a-sequence-of-commands-by-recording-a-macro" id="markdown-toc-capture-a-sequence-of-commands-by-recording-a-macro">Capture a Sequence of Commands by Recording a Macro</a></li>
          <li><a href="#play-back-a-sequence-of-commands-by-executing-a-macro" id="markdown-toc-play-back-a-sequence-of-commands-by-executing-a-macro">Play Back a Sequence of Commands by Executing a Macro</a>            <ol>
              <li><a href="#execute-the-macro-in-series" id="markdown-toc-execute-the-macro-in-series">Execute the Macro in Series</a></li>
              <li><a href="#execute-the-macro-in-parallel" id="markdown-toc-execute-the-macro-in-parallel">Execute the Macro in Parallel</a></li>
            </ol>
          </li>
        </ol>
      </li>
      <li><a href="#tip-66-normalize-strike-abort" id="markdown-toc-tip-66-normalize-strike-abort">Tip 66. Normalize, Strike, Abort</a>        <ol>
          <li><a href="#normalize-the-cursor-position" id="markdown-toc-normalize-the-cursor-position">Normalize the Cursor Position</a></li>
          <li><a href="#strike-your-target-with-a-repeatable-motion" id="markdown-toc-strike-your-target-with-a-repeatable-motion">Strike Your Target with a Repeatable Motion</a></li>
          <li><a href="#abort-when-a-motion-fails" id="markdown-toc-abort-when-a-motion-fails">Abort When a Motion Fails</a></li>
        </ol>
      </li>
      <li><a href="#tip-67-play-back-with-a-count" id="markdown-toc-tip-67-play-back-with-a-count">Tip 67. Play Back with a Count</a></li>
      <li><a href="#tip-68-repeat-a-change-on-contiguous-lines" id="markdown-toc-tip-68-repeat-a-change-on-contiguous-lines">Tip 68. Repeat a Change on Contiguous Lines</a>        <ol>
          <li><a href="#record-one-unit-of-work" id="markdown-toc-record-one-unit-of-work">Record One Unit of Work</a></li>
          <li><a href="#execute-macro-in-series" id="markdown-toc-execute-macro-in-series">Execute Macro in Series</a></li>
          <li><a href="#execute-macro-in-parallel" id="markdown-toc-execute-macro-in-parallel">Execute Macro in Parallel</a></li>
          <li><a href="#deciding-series-or-parallel" id="markdown-toc-deciding-series-or-parallel">Deciding: Series or Parallel</a></li>
        </ol>
      </li>
      <li><a href="#tip-69-append-commands-to-a-macro" id="markdown-toc-tip-69-append-commands-to-a-macro">Tip 69. Append Commands to a Macro</a></li>
      <li><a href="#tip-72-edit-the-contents-of-a-macro" id="markdown-toc-tip-72-edit-the-contents-of-a-macro">Tip 72. Edit the Contents of a Macro</a>        <ol>
          <li><a href="#the-problem-nonstandard-formatting" id="markdown-toc-the-problem-nonstandard-formatting">The Problem: Nonstandard Formatting</a></li>
          <li><a href="#paste-the-macro-into-a-document" id="markdown-toc-paste-the-macro-into-a-document">Paste the Macro into a Document</a></li>
          <li><a href="#keyboard-codes-in-macros" id="markdown-toc-keyboard-codes-in-macros">Keyboard Codes in Macros</a></li>
          <li><a href="#edit-the-text" id="markdown-toc-edit-the-text">Edit the Text</a></li>
          <li><a href="#yank-the-macro-from-the-document-back-into-a-register" id="markdown-toc-yank-the-macro-from-the-document-back-into-a-register">Yank the Macro from the Document Back into a Register</a></li>
        </ol>
      </li>
      <li><a href="#시리즈-포스트를-한-장의-페이지로도-정리합니다" id="markdown-toc-시리즈-포스트를-한-장의-페이지로도-정리합니다">시리즈 포스트를 한 장의 페이지로도 정리합니다.</a></li>
    </ol>
  </li>
</ol>

<h2 id="chapter-11-macros">CHAPTER 11. Macros</h2>

<p>Vim 매크로를 사용하면 레지스터에 원하는 만큼의 키 스트로크를 기록한 다음 다시 재생할 수 있다.</p>

<p>매크로는 일련의 행이나 문단, 파일 전체에서 반복해서 실행할 때 이상적으로 사용할 수 있다. 매크로는 일련의 파일에서 실행하 거나 병렬로 호출할 수 있다. 일련의 목표에 매크로를 실행하는 두 가지 방법이 있다. 일련의 작업을 반복 실행하거나 여러 번 병렬로 실행할 수 있다.</p>

<p>일련의 명령을 기록하다 보면 실수할 때도 있다. 실수한 것을 버릴 필요는 없다. 기존 매크로의 끝에 쉽게 명령을 추가할 수 있다. 더 많이 수정하려면 매크로를 문서에 붙여넣어 명령을 편집한 다음에 다시 레지스터로 복사해서 사용할 수 있다.</p>

<h3 id="tip-65-record-and-execute-a-macro">Tip 65. Record and Execute a Macro</h3>

<h4 id="capture-a-sequence-of-commands-by-recording-a-macro">Capture a Sequence of Commands by Recording a Macro</h4>

<p><code class="highlighter-rouge">q</code> 키는 ‘기록’과 ‘정지’ 버튼 모두로 동작한다. 키 입력의 기록을 시작하려면, <code class="highlighter-rouge">q{reister}</code>를 입력한다. register는 매크로가 저장되는 레지스터의 주소이다. 제대로 했다면 상태 줄에 ‘기록중(recording)’이라는 단어가 표시된다. 실행하는 모든 명령은 기록을 멈추기 위해 <code class="highlighter-rouge">q</code>를 다시 누를 때까지 캡처된다.</p>

<p><img src="/images/posts/record_play_macro.gif" alt="매크로 저장과 재생" /></p>

<p><code class="highlighter-rouge">qa</code>로 <code class="highlighter-rouge">레지스터 a</code>에 매크로 기록을 시작한다. 첫 번째 행에서 두 가지를 변경한다: 세미콜론을 끝에 넣고 앞에 var를 추가했다. <code class="highlighter-rouge">q</code>를 눌러 매크로 기록을 끝낸다(:h q).</p>

<p>레지스터의 내용을 보려면 다음과 같이 한다.</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">reg</span> <span class="k">a</span>
<span class="p">---</span> Registers <span class="p">---</span>
<span class="c">"a   A;^[Ivar ^[</span>
</code></pre></div></div>

<p>읽는 것이 쉽지 않지만, 앞서 입력한 명령의 순서는 알 수 있을 것이다. <code class="highlighter-rouge">^[</code> 기호는 <code class="highlighter-rouge">&lt;Esc&gt;</code> 키이다.</p>

<h4 id="play-back-a-sequence-of-commands-by-executing-a-macro">Play Back a Sequence of Commands by Executing a Macro</h4>

<p><code class="highlighter-rouge">@{register}</code> 명령은 특정 레지스터의 내용을 실행한다(:h @). 가장 마지막에 실행한 매크로를 반복하려면 <code class="highlighter-rouge">@@</code>를 사용할 수도 있다.</p>

<p>피상적으로 이것은 Dot Formula와 닮았다. 그것은 하나의 키 입력(j)으로 움직이고 두 개의 키(@a)로 행동한다. 나쁘진 않지만 개선의 여지가 있다.</p>

<p>매크로를 여러 번 실행하기위한 두 가지 기법이 있다. 설정은 각 기술마다 약간씩 다르지만 더 중요한 것은 오류가 발생할 때 다르게 반응한다는 것이다. 크리스마스 트리 라이트와의 비교를 통해 차이점을 설명한다.</p>

<p>싸구려 파티 조명을 구입하면 직렬로 연결될 가능성이 있다. 전구 하나가 날아가면 모두 나가 버린다. 프리미엄 세트를 구입하면 병렬 연결이 가능해진다. 그것은 어떤 전구가 꺼져도, 나머지는 영향받지 않음을 뜻한다.</p>

<p>매크로를 여러 번 실행하는 두 가지 기술을 구별하기 위해 전자 분야의 직렬(in series)과 병렬(in parallel)을 빌렸다. 매크로를 직렬로 실행하는 기술은 약하다. 병렬로 실행하는 기술은 보다 안정적이다.</p>

<h5 id="execute-the-macro-in-series">Execute the Macro in Series</h5>

<p>매크로 기록은 하나의 단위 작업을 하도록 로봇을 프로그래밍하는 것과 같다. 마지막 단계로 로봇이 컨베이어 벨트를 움직여 다음 항목을 손에 닿도록 지시한다. 이러한 방식으로, 우리는 하나의 로봇이 유사한 아이템에 대해 일련의 반복 작업을 수행하게 할 수 있다.</p>

<p>이런 접근법은 예상치 않은 일이 일어나면 경보를 울리고 작업을 중단하는 결과를 낳는다. 컨베이어 벨트 위의 항목을 여전히 조작할 필요가 있을 때도 작업이 중지된다.</p>

<h5 id="execute-the-macro-in-parallel">Execute the Macro in Parallel</h5>

<p>매크로를 병렬로 실행하면 마치 컨베이어 벨트가 전혀 필요없는 것처럼 보인다. 대신, 우리는 같은 단순한 작업을 하도록 프로그래밍된 로봇 집단을 배치한다. 각자에게 할 일이 하나씩 주어집니다. 각 로봇은 하나의 일만 주어진다. 성공하면 아주 좋다. 실패해도 상관없다.</p>

<p>내부적으로 Vim은 두 기술 중 어떤 것을 사용하더라도 매크로를 순차적으로 실행한다. 병렬이라는 용어는 병렬 회로의 견고함을 유추하기 위한 것이다. Vim이 여러 변경 사항을 동시에 실행한다는 것은 아니다.</p>

<h3 id="tip-66-normalize-strike-abort">Tip 66. Normalize, Strike, Abort</h3>

<p>매크로를 실행하면 Vim은 일련의 저장된 키 입력을 맹목적으로 반복한다. 조심하지 않으면 매크로를 재생할 때의 결과가 예상과 다를 수 있다. 그러나 더 유연한 매크로를 만들어 각 상황에 맞는 작업을 수행할 수 있다.</p>

<p>황금률은 매크로를 기록 할 때 모든 명령이 반복 가능한지 확인하는 것이다.</p>

<h4 id="normalize-the-cursor-position">Normalize the Cursor Position</h4>

<p>매크로 기록을 시작하자마자 다음 질문을 한다: 어디에 있고, 어디에서 왔으며, 어디로 가고 있나? 어떤 일을 하기 전에, 다음 명령이 기대한대로 작동할 수 있도록 커서가 놓여 있는지 확인한다.</p>

<p>이는 커서를 다음 검색 일치(<code class="highlighter-rouge">n</code>) 또는 현재 행의 시작(<code class="highlighter-rouge">0</code>) 또는 현재 파일의 첫 번째 행으로 이동시키는 것(<code class="highlighter-rouge">gg</code>)을 말하는 것일 수 있다. 항상 원점에서 시작하면 매번 올바른 대상을 쉽게 공략할 수 있다.</p>

<h4 id="strike-your-target-with-a-repeatable-motion">Strike Your Target with a Repeatable Motion</h4>

<p>Vim은 텍스트 파일을 돌아다니는 모션 명령이 많다. 제대로 사용해야 한다.</p>

<p>계속 <code class="highlighter-rouge">l</code> 키만 두들기는 것 같은 일은 하지 말아야 한다. Vim은 맹목적으로 키 입력을 실행한다는 것을 기억한다. 오른쪽으로 10 문자 이동하면 매크로를 기록할 때 필요한 위치로 이동할 수 있지만 나중에 다시 재생할 때는? 다른 맥락에서, 커서를 오른쪽으로 10 칸 움직이면 마크가 넘어가버리거나 미치지 못할 수 있다.</p>

<p><code class="highlighter-rouge">w</code>, <code class="highlighter-rouge">b</code>, <code class="highlighter-rouge">e</code> 및 <code class="highlighter-rouge">ge</code>와 같은 단어 단위 동작은 문자 단위 <code class="highlighter-rouge">h</code> 및 <code class="highlighter-rouge">l</code> 동작보다 유연하다. 모션 <code class="highlighter-rouge">0</code> 다음 <code class="highlighter-rouge">e</code>가 기록되면 매크로를 실행할 때마다 일관된 결과를 기대할 수 있다. 커서가 현재 행의 첫 번째 단어의 마지막 문자로 위치한다. 단어의 문자 개수에 관계없이 한 단어 이상 포함된 행에서는 문제가 되지 않는다.</p>

<p>검색을 사용해 이동하고, 텍스트 개체를 사용한다. 최대한 유연하고 반복 가능한 매크로를 만들기위한 Vim의 모션을 적극적으로 활용한다. 잊지 않는다: 매크로를 기록할 때 마우스 사용은 금지!</p>

<h4 id="abort-when-a-motion-fails">Abort When a Motion Fails</h4>

<p>모션이 실패할 수 있다. 예를 들어 커서가 파일의 첫 번째 행에 있으면 <code class="highlighter-rouge">k</code> 명령은 아무 것도 하지 않는다. 커서가 파일의 마지막 줄에 있을 때도 마찬가지이다. 기본적으로 동작이 실패하면 Vim에서 경고음을 울린다. ‘visualbell’ 설정으로 음소거를 할 수 있다(:h ‘visualbell’).</p>

<p>매크로가 실행되는 동안 모션이 실패하면 Vim은 나머지 매크로를 중단한다. 이것은 버그가 아니라 기능이라고 생각한다. 매크로를 현재 상황에서 실행해야하는지 여부에 대한 간단한 테스트로 모션을 사용할 수 있다.</p>

<p>이 예제를 고려해보자: 먼저 패턴을 검색한다. 문서에 10 개의 패턴일치가 있다고 가정해보자. 마지막 검색을 반복하는 <code class="highlighter-rouge">n</code> 명령으로 매크로 기록을 시작한다. 일치 항목에 커서가 이동하면 텍스트를 약간 변경하고 매크로 기록을 끝낸다. 편집을 하고나면 이 텍스트 영역은 더 이상 검색 패턴과 일치하지 않는다. 이제 문서에는 9 개의 일치 항목만 있다.</p>

<p>매크로를 실행하면 다음 매치로 건너 뛰고 동일한 변경을 한다. 이제 문서에는 8 개의 일치 항목만 있다. 일치 항목이 남아 있지 않을 때까지 매크로를 반복해서 실행한다. 이제 매크로를 실행하려고하면 더 이상 일치가 없으므로 <code class="highlighter-rouge">n</code> 명령이 실패한다. 매크로는 중단된다.</p>

<p>매크로가 <code class="highlighter-rouge">a 레지스터</code>에 저장되었다고 가정해보자. <code class="highlighter-rouge">@a</code>를 10 번 실행하는 대신 앞에 숫자를 붙인다: <code class="highlighter-rouge">10@a</code>. 이 기술의 장점은 매크로를 몇 번이나 실행하는지에 대해 신경쓰지 않을 수 있다는 것이다. 숫자에 신경쓰지 마라. 중요치 않다! <code class="highlighter-rouge">100@a</code> 나 <code class="highlighter-rouge">1000@a</code>를 실행할 수 있고, 같은 결과가 나온다.</p>

<h3 id="tip-67-play-back-with-a-count">Tip 67. Play Back with a Count</h3>

<p>Dot Formula가 작은 횟수의 반복에서 효율적인 편집 전략이 될 수 있지만, 숫자와 같이 실행할 수는 없다. 단순한 일회용 매크로를 기록하고 카운트로 다시 재생함으로써 이 한계를 넘을 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x = "("+a+","+b+","+c+","+d+","+e+")";
</code></pre></div></div>

<p>Dot Formula를 배울 때와 같이 이 예제를 해결할 수 있지만, 실행 횟수를 사용할 수 없을까? 이 명령을 가장 간단하게 매크로로 전환하는 방법은 <code class="highlighter-rouge">qq;.q</code> 명령이다. <code class="highlighter-rouge">qq</code>는 이 후 입력을 <code class="highlighter-rouge">q 레지스터</code>에 기록한다. 이제 <code class="highlighter-rouge">;.</code>을 입력하고 마지막으로 <code class="highlighter-rouge">q</code>로 기록을 종료한다. 이제 숫자와 함께 매크로를 실행한다: <code class="highlighter-rouge">11@q</code>.<code class="highlighter-rouge">;.</code>를 11번 실행한다.</p>

<p><img src="/images/posts/make-dot-formular-into-macro.gif" alt="점 공식을 매크로로" /></p>

<p><code class="highlighter-rouge">;</code> 명령은 <code class="highlighter-rouge">f+</code> 검색을 반복한다. 커서가 행의 마지막 <code class="highlighter-rouge">+</code> 문자 <em>뒤로</em> 오면 <code class="highlighter-rouge">;</code> 모션이 실패하고 매크로는 정지한다.</p>

<p>여기서는 매크로를 10 번 실행하려고 한다. 그러나 우리가 11 번 다시 실행해도, 마지막 실행은 중단 될 것이다. 즉, 매크로가 10 이상으로 호출되기만 하면 작업을 완료할 수 있다.</p>

<p>매크로를 실행해야하는 정확한 횟수를 계산하고 싶은 사람은 없을 것이다. 일을 끝내기에 충분하다고 생각하는 횟수를 주면 된다. 나는 타이핑하기 쉽기 때문에 <code class="highlighter-rouge">22</code>를 자주 사용한다. 키보드에서 <code class="highlighter-rouge">@</code> 및 <code class="highlighter-rouge">2</code> 문자는 같은 버튼이다.</p>

<h3 id="tip-68-repeat-a-change-on-contiguous-lines">Tip 68. Repeat a Change on Contiguous Lines</h3>

<p><em>매크로를 기록한 후 각 행에서 재생하는 것으로 여러 행에서 같은 변경을 반복할 수 있다. 매크로를 실행하는 두 가지 방법이 있다: 직렬 또는 병렬</em></p>

<h4 id="record-one-unit-of-work">Record One Unit of Work</h4>

<p>먼저 첫 행에서 모든 변경을 기록한다.</p>

<p><img src="/images/posts/macro_included_motion.gif" alt="모션이 포함된 매크로" /></p>

<p>모션의 사용에 주목하라. <code class="highlighter-rouge">0</code> 명령으로 행의 가장 앞으로 이동하는 것으로 시작한다. 항상 같은 위치에서 시작하여 반복할 수 있는 매크로를 작성한다.</p>

<p>다음 모션은 <code class="highlighter-rouge">f.</code>이다. <code class="highlighter-rouge">l</code> 명령으로 한칸만 이동해도 되지만 두 개의 키입을 사용한 것은 반복 가능성 때문이다. 예제에서는 1 행부터 4 행까지만 있다. 그러나 숫자가 두 자리 이상일 때를 가정하면?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. one
2. two
...
10. ten
11. eleven
</code></pre></div></div>

<p>9 번째 행까지는 <code class="highlighter-rouge">0l</code> 명령을 사용할 수 있다. 하지만 10 번째 행부터는 목표에 미치지 못한다. 반면 <code class="highlighter-rouge">f.</code>는 모든 행에서 동작하고, 세 자리 이상까지도 계속 동작한다.</p>

<p><code class="highlighter-rouge">f.</code> 모션은 안전 장치도 추가한다. 현재 행에서 <code class="highlighter-rouge">.</code> 문자를 못찾는다면 오류를 발생시키고 매크로 실행이 중단된다.</p>

<h4 id="execute-macro-in-series">Execute Macro in Series</h4>

<p>매크로를 실행하려면 <code class="highlighter-rouge">@a</code>를 입력할 수 있다. <code class="highlighter-rouge">@a</code> 명령을 3 번 실행할 수 있지만, <code class="highlighter-rouge">3@a</code>가 더 빠르다.</p>

<p>이번엔 주석을 포함한다고 가정하자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. one
2. two
// break up the monotony
3. three
4. four
</code></pre></div></div>

<p>매크로는 주석이 있는 3 번째 행에서 멈춘다.</p>

<h4 id="execute-macro-in-parallel">Execute Macro in Parallel</h4>

<p>매크로를 처음부터 다시 작성한다. 마지막 <code class="highlighter-rouge">j</code> 명령을 생략한다.</p>

<p><img src="/images/posts/macro_in_parallel.gif" alt="병렬 매크로" /></p>

<p>선택 영역의 각 행에서 매크로를 실행하기 위해 <code class="highlighter-rouge">:normal @a</code> 명령을 사용한다.</p>

<p>앞에서는 <code class="highlighter-rouge">5@a</code> 명령으로 매크로를 직렬로 5 번 반복했다. 3 번째 반복에서 매크로가 중지하였다. 이번에는 병렬로 5번 반복했다. 각 행마다 매크로의 호출은 다른 매크로와 독립적이다. 따라서 3 번째 반복에서 실패한 것은 다른 것에 영향을 주지 않는다.</p>

<h4 id="deciding-series-or-parallel">Deciding: Series or Parallel</h4>

<p>여러 항목에서 병렬로 실행하는 것은  더욱 강력하다. 그러나 매크로를 실행할 때 오류가 발생할 때 알람을 울리길 원할 수 있다. 직렬로 실행하면 오류가 언제 어디에서 발생하는지 명확히 알 수 있다.</p>

<h3 id="tip-69-append-commands-to-a-macro">Tip 69. Append Commands to a Macro</h3>

<p>매크로를 기록할 때 중요한 단계를 놓치는 경우가 있다. 모든 것을 처음부터 다시 기록할 필요가 없다. 대신 기존 매크로 끝에 명령을 추가할 수 있다.</p>

<p>먼저 레지스터 a에 등록된 매크로를 확인한다.</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">reg</span> <span class="k">a</span>
<span class="c">"a 0f.r)w~</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">qa</code>를 입력하면 <code class="highlighter-rouge">a 레지스터</code>를 덮어쓰게 되지만, <code class="highlighter-rouge">qA</code>를 입력하면 <code class="highlighter-rouge">a 레지스터</code>의 기존 내용에 <em>추가할 것이다</em>.</p>

<h3 id="tip-72-edit-the-contents-of-a-macro">Tip 72. Edit the Contents of a Macro</h3>

<h4 id="the-problem-nonstandard-formatting">The Problem: Nonstandard Formatting</h4>

<p>Tip. 68의 상황으로 돌아간다. <code class="highlighter-rouge">레지스터 a</code>에 매크로가 저장되어 있다. 이제 양식이 살짝 어긋난 아래의 문서를 확인한다.</p>

<p>macros/mixed-lines.txt</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. One
2. Two
3. three
4. four
</code></pre></div></div>

<p><code class="highlighter-rouge">~</code> 명령 대신에 <code class="highlighter-rouge">vU</code> 명령을 사용해 매크로를 업데이트해보자. 이 명령은 현재 커서가 위치한 글자를 대문자로 변환한다(:h v_U).</p>

<h4 id="paste-the-macro-into-a-document">Paste the Macro into a Document</h4>

<p><code class="highlighter-rouge">레지스터 a</code>에 저장된 매크로를 변경하려면 플레인 텍스트로 편집할 수 있도록 문서에 붙여넣어야 한다.</p>

<p>먼저 <code class="highlighter-rouge">G</code>를 눌러 문서의 끝으로 이동한다. 이제 <code class="highlighter-rouge">레지스터 a</code>의 내용을 새 행에 붙여넣는다. 가장 간단한 방법은 <code class="highlighter-rouge">:put</code> 명령을 사용하는 방법이다.</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">put</span> <span class="k">a</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">"ap</code> 명령을 사용하지 않았다. <code class="highlighter-rouge">p</code> 명령은 <em>현재 행의 커서 다음에</em> 레지스터의 내용을 붙여 넣는다. 반면에 <code class="highlighter-rouge">:put</code> 명령은 항상 <em>현재 행의 아래에</em> 붙여 넣는다.</p>

<blockquote>

  <h4 id="keyboard-codes-in-macros">Keyboard Codes in Macros</h4>

  <p>이 예제에서는 상대적으로 단순한 레지스터를 이용했다. 이 방법은 큰 매크로를 편집할 때 사용하면 문서가 쉽게 지저분해진다. ‘Tip 70. 파일 묶음을 대상으로 작업 처리하기’에서 녹화한 매크로를 보면 그런 문제를 확인할 수 있다.</p>

  <div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span>rega
<span class="p">---</span> Registers <span class="p">---</span>
<span class="c">"a      Omoul&lt;80&gt;kb&lt;80&gt;kbdule Rank^[j&gt;GGoend^[</span>
</code></pre></div>  </div>

  <p>조금 이상하지 않은가? 우선 <code class="highlighter-rouge">^[</code> 기호가 여러 번 나온다. <code class="highlighter-rouge">&lt;Esc&gt;</code>나 <code class="highlighter-rouge">&lt;C-[&gt;</code> 어느 것을 누르던지 이스케이프 키를 표현하는 Vim의 방법이다.</p>

  <p><code class="highlighter-rouge">&lt;80&gt;kb</code>는 백스페이스 키이다. 키입력을 익혀라. 이 매크로를 기록 할 때 “moul”을 입력하여 시작했습니다. 실수를 알고 나서 백스페이스 키를 두 번 누른 다음 “dule”이라는 단어를 입력했다.</p>

  <p>이 행동은 실제 결과가 아닙니다. 이러한 키 입력을 재생하면 Vim은 내 실수를 재현하고 수정한다. 최종 결과는 똑같다. 그러나 그것은 레지스터를 읽기 어렵고 편집하기 까다로워 진다.</p>

</blockquote>

<h4 id="edit-the-text">Edit the Text</h4>

<p>이제 매크로를 플레인 텍스트로 편집할 수 있다.</p>

<h4 id="yank-the-macro-from-the-document-back-into-a-register">Yank the Macro from the Document Back into a Register</h4>

<p>명령을 원하는 순서로 수정했다면 이 내용을 다시 레지스터로 붙여넣을 수 있다. 가장 간단한 방법은 <code class="highlighter-rouge">"add</code> (또는 <code class="highlighter-rouge">:d a</code>)를 실행하는 것이지만, 나중에 문제가 발생할 수 있다. <code class="highlighter-rouge">dd</code> 명령은 줄 단위 삭제를 수행한다. 레지스터에 <code class="highlighter-rouge">^J</code> 꼬리가 생긴다.</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">reg</span> <span class="k">a</span>
<span class="m">0</span><span class="k">f</span><span class="p">.</span><span class="k">r</span><span class="p">)</span>wvUj^J
</code></pre></div></div>

<p>이 문자는 줄바꿈을 의미한다. 대부분의 상황에서 중요하지 않지만, 때때로 이 줄바꿈 꼬리은 매크로의 의미를 바꿀 수 있다. 예방 차원에서, 문자 단위 복사(yank)를 사용하여 문서에서 다시 레지스터로 가져오는 것이 더 안전한 방법이다.</p>

<p><code class="highlighter-rouge">0</code> 명령 다음에 <code class="highlighter-rouge">"ay$</code>를 실행하여 개행을 제외한 모든 문자를 복사한다. 모든 내용을 <code class="highlighter-rouge">a</code> 레지스터에 저장한 후, <code class="highlighter-rouge">dd</code>로 문서의 행을 삭제한다.</p>

<p>Vim의 레지스터는 더 이상 단순한 텍스트 문자열의 보관함이 아니기에 Vim 스크립트를 사용하여 프로그래밍 방식으로 조작할 수도 있다. 예를 들어, <code class="highlighter-rouge">substitute()</code> 함수(이것은 <code class="highlighter-rouge">:subsititute</code> 명령과 다르다. :h substitute())를 사용하여 앞서 작성한 매크로와 동일한 작업을 다음과 같이 처리할 수 있다.</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">let</span> @<span class="k">a</span><span class="p">=</span>substitute<span class="p">(</span>@<span class="k">a</span><span class="p">,</span> <span class="s1">'\~'</span><span class="p">,</span> <span class="s1">'vU'</span><span class="p">,</span> <span class="s1">'g'</span><span class="p">)</span>
</code></pre></div></div>

<p>이 접근 방식이 흥미롭게 느껴진다면 <code class="highlighter-rouge">:h function-list</code>에서 더 자세히 살펴보자.</p>

<h3 id="시리즈-포스트를-한-장의-페이지로도-정리합니다">시리즈 포스트를 한 장의 페이지로도 정리합니다.</h3>

<ul>
  <li><a href="https://nolboo.kim/practical-vim/">Practical Vim 2판 정리 페이지</a></li>
</ul>

]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[Practical Vim 팁 요약 시리즈 - Register II]]></title>
            <link>http://nolboo.kim/blog/2017/02/07/practical-vim/</link>
            <pubDate>Tue, 07 Feb 2017 00:00:00 +0000</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"n0lb00", "github"=>"nolboo"}]]></dc:creator>
        
            <category><![CDATA[blog]]></category>
        
        
            <category><![CDATA[practical]]></category>
        
            <category><![CDATA[vim]]></category>
        
            <category><![CDATA[tip]]></category>
        
            <category><![CDATA[beginner]]></category>
        
            <category><![CDATA[advance]]></category>
        
            <guid>http://nolboo.kim/blog/2017/02/07/practical-vim/</guid>
            <description>
                <![CDATA[The System Clipboard (“+) and Selection (“*) Registers The Expression Register (“=) More Registers Tip 62. Replace a Visual Selection with a Register Swap Two Words Tip 63. Paste from a Register Pasting Character-wise Regions Pasting Line-Wise Regions Tip 64. Interact with the System Clipboard Locating the System Paste Command...]]>
            </description>
            <content:encoded>
                <![CDATA[<p><img src="/images/posts/vim.jpg" alt="Vim 3D" /></p>

<ol id="markdown-toc">
  <li><a href="#the-system-clipboard--and-selection--registers" id="markdown-toc-the-system-clipboard--and-selection--registers">The System Clipboard (“+) and Selection (“*) Registers</a></li>
  <li><a href="#the-expression-register-" id="markdown-toc-the-expression-register-">The Expression Register (“=)</a></li>
  <li><a href="#more-registers" id="markdown-toc-more-registers">More Registers</a></li>
  <li><a href="#tip-62-replace-a-visual-selection-with-a-register" id="markdown-toc-tip-62-replace-a-visual-selection-with-a-register">Tip 62. Replace a Visual Selection with a Register</a>    <ol>
      <li><a href="#swap-two-words" id="markdown-toc-swap-two-words">Swap Two Words</a></li>
    </ol>
  </li>
  <li><a href="#tip-63-paste-from-a-register" id="markdown-toc-tip-63-paste-from-a-register">Tip 63. Paste from a Register</a>    <ol>
      <li><a href="#pasting-character-wise-regions" id="markdown-toc-pasting-character-wise-regions">Pasting Character-wise Regions</a></li>
      <li><a href="#pasting-line-wise-regions" id="markdown-toc-pasting-line-wise-regions">Pasting Line-Wise Regions</a></li>
    </ol>
  </li>
  <li><a href="#tip-64-interact-with-the-system-clipboard" id="markdown-toc-tip-64-interact-with-the-system-clipboard">Tip 64. Interact with the System Clipboard</a>    <ol>
      <li><a href="#locating-the-system-paste-command" id="markdown-toc-locating-the-system-paste-command">Locating the System Paste Command</a></li>
      <li><a href="#using-the-system-paste-command-in-insert-mode" id="markdown-toc-using-the-system-paste-command-in-insert-mode">Using the System Paste Command in Insert Mode</a></li>
      <li><a href="#avoid-toggling-paste-by-putting-from-the-plus-register" id="markdown-toc-avoid-toggling-paste-by-putting-from-the-plus-register">Avoid Toggling ‘paste’ by Putting from the Plus Register</a></li>
    </ol>
  </li>
  <li><a href="#시리즈-포스트를-한-장의-페이지로도-정리합니다" id="markdown-toc-시리즈-포스트를-한-장의-페이지로도-정리합니다">시리즈 포스트를 한 장의 페이지로도 정리합니다.</a></li>
</ol>

<h4 id="the-system-clipboard--and-selection--registers">The System Clipboard (“+) and Selection (“*) Registers</h4>

<p>지금까지 다룬 모든 레지스터는 Vim 내부에서 사용하는 레지스터이다. Vim에서 복사한 텍스트를 외부 프로그램에 붙여넣으려면(또는 그 반대) 시스템 클립보드를 사용해야 한다.</p>

<p>Vim의 플러스 레지스터는 시스템 클립보드를 참조하며 <code class="highlighter-rouge">+</code> 기호로 사용할 수 있다(:h quote+).</p>

<p>외부 애플리케이션에서 복사하거나 잘라낸 텍스트를 Vim에서 사용하려면 <code class="highlighter-rouge">"+p</code> 명령으로 붙여넣을 수 있다. (또는 입력 모드에서 <code class="highlighter-rouge">&lt;Ctrl-r&gt;+</code> 명령을 사용) 반대로 Vim의 복사 또는 삭제 명령 앞에 <code class="highlighter-rouge">"+</code>를 붙이면 그 텍스트를 시스템 클립 보드에 저장되어 다른 애플리케이션에서 쉽게 붙여넣을 수 있다.</p>

<p>X11 윈도우 시스템에는 원시(primary) 클립보드라고 하는 다른 종류의 클립 보드가 있다. 이 클립보드는 가장 최근에 선택한 내용을 저장하며 마우스 가운데 버튼을 (만약 있다면) 눌러 붙여넣을 수 있다. Vim에서는 인용별(quotestar) 레지스터가 이 원시 클립보드와 연결되어 있으며 <code class="highlighter-rouge">*</code> 기호로 참조할 수 있다(:h quotestar).</p>

<p>윈도와 맥 OS X에는 원시 클립보드가 없기 때문에 <code class="highlighter-rouge">"+</code>,<code class="highlighter-rouge">"*</code> 레지스터는 둘 다 시스템 클립보드를 참조한다.</p>

<h4 id="the-expression-register-">The Expression Register (“=)</h4>

<p>Vim의 레지스터는 단순히 텍스트 블록을 저장하는 보관함이라고 생각할 수 있지만, <code class="highlighter-rouge">=</code> 기호로 참조하는 표현식 레지스터는 예외이다(:h quote=). 표현식 레지스터를 사용하면 Vim은 명령행 모드로 전환되고 <code class="highlighter-rouge">=</code> 프롬프트에 보여준다. Vim 스크립트 표현식을 입력한 다음에 <code class="highlighter-rouge">&lt;CR&gt;</code>을 눌러 스크립트를 실행할 수 있다. 표현식이 문자열(또는 쉽게 문자열로 강제 변환될 수 있는 값)을 반환하면 Vim은 그 결과를 사용한다.</p>

<h4 id="more-registers">More Registers</h4>

<p>제거하기 명령 또는 복사하기 명령을 사용해서 이름 레지스터, 무명 레지스터, 복사 레지스터의 내용을 명시적으로 설정할 수 있다. Vim은 암시적으로 값이 설정된 레지스터도 제공한다. 전체적으로 읽기전용 레지스터로 알려져 있다(:h quote.).</p>

<table>
  <thead>
    <tr>
      <th>Register</th>
      <th>Contents</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>”%</td>
      <td>Name of the current file</td>
    </tr>
    <tr>
      <td>”#</td>
      <td>Name of the alternate file</td>
    </tr>
    <tr>
      <td>”.</td>
      <td>Last inserted text</td>
    </tr>
    <tr>
      <td>”:</td>
      <td>Last Ex command</td>
    </tr>
    <tr>
      <td>”/</td>
      <td>Last search pattern</td>
    </tr>
  </tbody>
</table>

<p>기술적으론 <code class="highlighter-rouge">"/</code> 레지스터는 읽기 전용이 아니며, <code class="highlighter-rouge">:let</code> 명령을 사용하여 명시적으로 검색 패턴을 저장할 수 있다(:h quote/). 하지만 편의상 이 표에 포함한다.</p>

<h3 id="tip-62-replace-a-visual-selection-with-a-register">Tip 62. Replace a Visual Selection with a Register</h3>

<p>비주얼 모드에서 붙여넣기 명령을 사용하는 경우에 독특한 특징이 있다.</p>

<p>비주얼 모드에서 <code class="highlighter-rouge">p</code> 명령을 사용하면 특정 레지스터에 있는 내용으로 <em>선택한 영역을 대체한다</em>(:h v_p). 이 기능을 Tip.60의 “악! 복사한 내용을 날렸다” 문제를 해결할 때 사용할 수 있다.</p>

<p><code class="highlighter-rouge">copy_and_paste/collection.js</code></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">collection</span> <span class="o">=</span> <span class="nx">getCollection</span><span class="p">();</span>
<span class="nx">process</span><span class="p">(</span><span class="nx">somethingInTheWay</span><span class="p">,</span> <span class="nx">target</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">yiw</code>를 입력해서 collection 단어를 무명 레지스터에 복사한다. 이제 <code class="highlighter-rouge">jww</code>로 복사한 단어를 넣을 위치인 somethungIhTheWay로 커서를 이동한다. <code class="highlighter-rouge">ve</code> 명령으로 somethungIhTheWay을 선택한다.
<code class="highlighter-rouge">p</code>를 눌러 선택 영역을 무명 레지스터에 있는 내용으로 대체한다.</p>

<p>이 해결책은 내가 가장 선호하는 방법이다. 삭제 단계가 없으므로 무명 레지스터를 사용하여 yank 및 put 작업을 수행 할 수 있다. 대신 삭제 및 붙여넣는 작업을 선택 영역을 대체하는 하나의 단계로 결합한다.</p>

<p>이 기법의 부가적인 효과를 이해하는 것도 중요하다. <code class="highlighter-rouge">u</code>를 눌러서 마지막 변경을 취소해보자. 이제 <code class="highlighter-rouge">gv</code>를 눌러서 마지막 선택 영역을 다시 선택하고 <code class="highlighter-rouge">p</code>를 입력한다. 무슨 일이 일어났는가? 아무 일도 일어나지 않았다!</p>

<p>이 작업을 다시 실행할 때는 <code class="highlighter-rouge">"0p</code> 명령을 사용해서 복사 레지스터의 내용으로 선택 영역을 대체해야 한다. 처음 <code class="highlighter-rouge">p</code> 명령을 사용했을 때는 무명 레지스터에 원하는 텍스트가 있었다. 두 번째에는 <code class="highlighter-rouge">p</code> 명령으로 지워진 문자열이 무명 레지스터에 덮어 쓰인다.</p>

<p>이 기능이 얼마나 이상한지는 표준 잘라내기, 복사하기, 붙여넣기 모델의 API와 비교해보면 더 명확하다. 이 API는 <code class="highlighter-rouge">setClipboard()</code>와 <code class="highlighter-rouge">getClipboard()</code>라는 메소드가 있다. 잘라내기와 복사하기 동작은 둘 다 <code class="highlighter-rouge">setClipboard()</code>를 호출하고 붙여넣기 동작은 <code class="highlighter-rouge">getClipboard()</code>를 호출한다. 비주얼 모드에서 <code class="highlighter-rouge">p</code> 명령을 사용하면 두 메소드를 동시에 사용한다: 무명 레지스터의 내용을 <em>가져오고</em>, 무명 레지스터의 내용을 <em>설정한다</em>. 즉, 무명 레지스터에서 붙여넣을 내용을 가져온 다음, 제거한 내용을 다시 무명 레지스터에 입력한다.</p>

<p>이 기능은 문서의 선택 영역과 레지스터에 있는 텍스트가 <em>서로의 위치를 맞바꾼다고</em> 생각할 수 있다. 이 특징이 하나의 기능일까, 아니면 버그일까? 각자의 판단에 맡긴다.</p>

<h4 id="swap-two-words">Swap Two Words</h4>

<p>이 부분은 실제 쓸 일이 없다. 저자도 그냥 두 단어를 <code class="highlighter-rouge">c3w</code>로 전부 지우고 다시 쓰는 게 빠르다고 함.(놀부)</p>

<h3 id="tip-63-paste-from-a-register">Tip 63. Paste from a Register</h3>

<p><em>일반 모드에서 붙여넣기 명령은 어떤 텍스트를 붙여넣는가에 따라서 다르게 동작할 수 있다. 행 단위 또는 문자 단위인지에 따라 다른 전략을 채택하는 것이 도움이 될 수 있다.</em></p>

<p><code class="highlighter-rouge">p</code> 명령은 커서 다음에 레지스터에 있는 텍스트를 붙여넣는다(:h p). 대문자 <code class="highlighter-rouge">P</code> 명령은 커서 앞에 붙여넣는다.</p>

<p>행 단위 복사나 삭제 동작(<code class="highlighter-rouge">dd</code>, <code class="highlighter-rouge">yy</code>, <code class="highlighter-rouge">dap</code> 등)은 행 단위 레지스터를 만들고, 문자 단위 복사나 삭제 동작(<code class="highlighter-rouge">x</code>, <code class="highlighter-rouge">diw</code>, <code class="highlighter-rouge">das</code> 등)은 문자 단위 레지스터를 만든다. 보통 <code class="highlighter-rouge">p</code> 명령의 출력 결과는 상당히 직관적으로 동작한다(:h linewise-register).</p>

<h4 id="pasting-character-wise-regions">Pasting Character-wise Regions</h4>

<p><code class="highlighter-rouge">p</code>와 <code class="highlighter-rouge">P</code>를 사용해야 하는 상황을 직관적으로 판단하기가 쉽지 않다. 실제로 잘못 입력하는 경우가 많아 <code class="highlighter-rouge">puP</code> 또는 <code class="highlighter-rouge">Pup</code>를 실제 체득하고 있다.</p>

<p>문자 단위로 선택할 필요가 없다. 일반 모드 <code class="highlighter-rouge">p</code>와 <code class="highlighter-rouge">P</code> 명령보다는 입력 모드에서 <code class="highlighter-rouge">&lt;Ctrl-r&gt;{register}</code> 명령으로 붙여 넣는 것을 자주 이용한다. 이 기법을 사용하면 레지스터에 있는 텍스트를 항상 커서 앞에 붙여넣는다. 마치 입력 모드에서 계속 타자하는 것과 같은 느낌이다.</p>

<p>입력 모드에서 <code class="highlighter-rouge">&lt;Ctrl-r&gt;"</code>로 무명 레지스터의 내용을 넣을 수 있고, <code class="highlighter-rouge">&lt;Ctrl-r&gt;0</code>로 복사 레지스터의 내용을 넣을 수 있다.</p>

<p><img src="/images/posts/Copy_word_and_replace_word_I_Mode.gif" alt="단어 복사하고 입력 모드에서 대체하기" /></p>

<p><code class="highlighter-rouge">ciw</code> 명령을 사용하면 부수적인 혜택도 있다. 이제부터 <code class="highlighter-rouge">.</code> 명령이 현재 단어를 “collection”으로 대체한다.</p>

<h4 id="pasting-line-wise-regions">Pasting Line-Wise Regions</h4>

<p>행 단위 레지스터를 붙여넣으면 <code class="highlighter-rouge">p</code>는 현재 행 아래에, <code class="highlighter-rouge">P</code>는 현재 행 위에 텍스트를 붙여넣는다. 단어 단위 동작에 비해서 더 직관적이다.
<code class="highlighter-rouge">gp</code>와 <code class="highlighter-rouge">gP</code> 명령도 기억해둘만 하다. <code class="highlighter-rouge">p</code>, <code class="highlighter-rouge">P</code> 명령처럼 현재 행의 위 또는 아래에 텍스트를 붙여넣지만, 커서가 붙여넣은 텍스트의 시작 대신 끝에 위치한다. <code class="highlighter-rouge">gP</code> 명령은 특히 여러 행을 복사할 때 유용하다.</p>

<p><img src="/images/posts/Copy_code_block_Paste.gif" alt="코드 블럭 복사하고 붙여넣기" /></p>

<p>복사한 텍스트를 템플릿처럼 사용해서 표의 셀 내용만 원하는 대로 변경할 수 있다.</p>

<h3 id="tip-64-interact-with-the-system-clipboard">Tip 64. Interact with the System Clipboard</h3>

<p><em>Vim의 내장된 put 명령 외에도 가끔 시스템  붙여넣기(paste) 기능을 사용할 때가 있다. 그러나 이것을 사용하면 터미널에서 Vim을 실행할 때 예기치 않은 결과가 발생할 수 있다. 시스템 붙여넣기 명령을 사용하기 전에 ‘paste’ 옵션을 활성 상태로 하면 이러한 문제를 피할 수 있다.</em></p>

<p>다음과 같이 vim을 터미널에서 구동해보자.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>vim <span class="nt">-u</span> NONE <span class="nt">-N</span>
</code></pre></div></div>

<p>시스템 클립보드를 붙여넣을 때 문제가 발생하는 경우는 대부분 ‘autoindent’ 설정이 활성 상태이기 때문이다. 이 현상을 관찰하기 위해 다음처럼 설정을 활성한다.</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">set</span> autoindent
</code></pre></div></div>

<p>이제 다음 코드를 시스템 클립보드로 복사한다.</p>

<p><code class="highlighter-rouge">copy_and_paste/fizz.rb</code></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span>
  <span class="k">if</span> <span class="n">n</span><span class="o">%</span><span class="mi">5</span><span class="o">==</span><span class="mi">0</span>
    <span class="nb">puts</span> <span class="s2">"fizz"</span>
  <span class="k">else</span>
    <span class="nb">puts</span> <span class="n">n</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="locating-the-system-paste-command">Locating the System Paste Command</h4>

<p>시스템 붙여넣기 명령을 사용하려면 자신의 시스템에 맞는 단축키를 사용해야 한다. OS X는 시스템 붙여넣기를 <code class="highlighter-rouge">Cmd-v</code>로 실행할 수 있다. 터미널이나 MacVim에서 사용하면 시스템 클립보드의 내용을 삽입한다.</p>

<p>리눅스와 윈도에서는 그리 깔끔하지 않다. 시스템 붙여넣기의 표준 키는 보통 <code class="highlighter-rouge">Ctrl-v</code>이다. 일반 모드에서 비주얼-블록 모드로 전환하고, 입력 모드에서는 문자를 문자 그대로 추가하거나 숫자 코드로 입력한다.</p>

<p>Linux의 터미널 에뮬레이터 중에는 시스템 클립보드에서 붙여넣는 동작을 하도록 수정된 버전의 <code class="highlighter-rouge">Ctrl-v</code>를 지원하기도 한다. 그러나, 몰라도 걱정하지 말자. 이 팁의 마지막에 나오는 <code class="highlighter-rouge">"*</code> 레지스터를 사용하는 대안이 있다.</p>

<h4 id="using-the-system-paste-command-in-insert-mode">Using the System Paste Command in Insert Mode</h4>

<p>입력 모드로 전환하고 시스템 붙여넣기 명령을 사용하면 이상한 결과가 나타난다. 들여쓰기가 잘못된다. 입력 모드에서 시스템 붙여넣기 명령을 사용하면, 각각의 문자를 손으로 직접 입력한 것처럼 처리된다. ‘autoindent’ 설정이 켜져 있으면 새 행을 시작할 때마다 이전 행과 동일한 계층의 들여쓰기로 열을 맞춘다. 그러나 클립보드에 있는 코드는 이미 들여쓰기가 있는 코드이기 때문에 자동 들여쓰기에 더해진다. 그래서 결과에서 매번 줄이 오른쪽으로 점점 더 쏠린다.</p>

<p>GVim은 클립 보드에서 텍스트를 붙여 넣을 때 구분할 수 있고 그에 따라 동작을 조정할 수 있지만 Vim이 터미널 내부에서 실행될 때이 정보는 사용할 수 없습니다.</p>

<p>GVim은 클립보드에서 텍스트을 붙여넣는 것을 식별하고 그에 따라 처리하지만, 터미널에서 실행되는 Vim은 이 정보를 사용할 수 없다. ‘paste’ 옵셔능로 Vim에게 시스템 붙여넣기를 사용한다고 수동으로 경고할 수 있다. ‘paste’ 옵션을 켜면 Vim은 모든 입력 단축키, 축약을 끄고, ‘autoindent’을 포함한 붙여넣기 옵션들을 재설정한다.(:h ‘paste’). 이것으로 놀라지 않고 안전하게 붙여넣을 수 있다.</p>

<p>시스템 붙여넣기 명령을 완료하면 ‘paste’ 옵션을 다시 꺼야 한다. 일반 모드로 돌아와 Ex 명령 <code class="highlighter-rouge">:set paste!</code>를 실행해야 한다. 입력 모드에서 벗어나지 않고 이 옵션을 쉽게 전환하는 방법은 없을까?</p>

<p>‘paste’ 옵션이 활성 상태이면 입력 모드의 커스텀 단축키를 사용할 수 없다. 대신 ‘pastetoggle’ 옵션에 키를 배정할 수 있다(:h ‘pastetoggle’).</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">set</span> pastetoggle<span class="p">=&lt;</span>f5<span class="p">&gt;</span>
</code></pre></div></div>

<p>명령행을 실행하면 <code class="highlighter-rouge">&lt;f5&gt;</code>으로 붙여넣기 옵션을 전환할 수 있다. 입력 모드와 일반 모드 모두에서 동작한다. 단축키가 유용하다고 생각하면 <code class="highlighter-rouge">vimrc</code>에 추가한다.</p>

<h4 id="avoid-toggling-paste-by-putting-from-the-plus-register">Avoid Toggling ‘paste’ by Putting from the Plus Register</h4>

<p>시스템 클립보드가 통합된 Vim을 사용하고 있다면 ‘paste’ 옵션을 사용하지 않을 수 있다. 일반 모드 <code class="highlighter-rouge">"+p</code> 명령은 시스템 클립보드를 반영하는 플러스 레지스터의 내용을 붙여넣는다. 이 명령은 클립보드에 있는 들여쓰기를 그대로 지키기 때문에 아무 문제없이 클립보드의 내용을 붙여넣을 수 있다. ‘paste’와 ‘autoindent’ 옵션을 고민할 필요가 없다.</p>

<h3 id="시리즈-포스트를-한-장의-페이지로도-정리합니다">시리즈 포스트를 한 장의 페이지로도 정리합니다.</h3>

<ul>
  <li><a href="https://nolboo.kim/practical-vim/">Practical Vim 2판 정리 페이지</a></li>
</ul>

]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[Practical Vim 팁 요약 시리즈 - Register]]></title>
            <link>http://nolboo.kim/blog/2017/02/05/practical-vim/</link>
            <pubDate>Sun, 05 Feb 2017 00:00:00 +0000</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"n0lb00", "github"=>"nolboo"}]]></dc:creator>
        
            <category><![CDATA[blog]]></category>
        
        
            <category><![CDATA[practical]]></category>
        
            <category><![CDATA[vim]]></category>
        
            <category><![CDATA[tip]]></category>
        
            <category><![CDATA[beginner]]></category>
        
            <category><![CDATA[advance]]></category>
        
            <guid>http://nolboo.kim/blog/2017/02/05/practical-vim/</guid>
            <description>
                <![CDATA[Part IV. Registers CHAPTER 10. Copy and Paste Tip 60. Delete, Yank, and Put with Vim’s Unnamed Register Transposing Characters Transposing Lines Duplicating Lines Oops! I Clobbered My Yank Tip 61. Grok Vim’s Registers Addressing a Register Vim’s Terminology Versus the World The Unnamed Register (“”) The Yank Register (“0)...]]>
            </description>
            <content:encoded>
                <![CDATA[<p><img src="/images/posts/vim.jpg" alt="Vim 3D" /></p>

<ol id="markdown-toc">
  <li><a href="#part-iv-registers" id="markdown-toc-part-iv-registers">Part IV. Registers</a></li>
  <li><a href="#chapter-10-copy-and-paste" id="markdown-toc-chapter-10-copy-and-paste">CHAPTER 10. Copy and Paste</a>    <ol>
      <li><a href="#tip-60-delete-yank-and-put-with-vims-unnamed-register" id="markdown-toc-tip-60-delete-yank-and-put-with-vims-unnamed-register">Tip 60. Delete, Yank, and Put with Vim’s Unnamed Register</a>        <ol>
          <li><a href="#transposing-characters" id="markdown-toc-transposing-characters">Transposing Characters</a></li>
          <li><a href="#transposing-lines" id="markdown-toc-transposing-lines">Transposing Lines</a></li>
          <li><a href="#duplicating-lines" id="markdown-toc-duplicating-lines">Duplicating Lines</a></li>
          <li><a href="#oops-i-clobbered-my-yank" id="markdown-toc-oops-i-clobbered-my-yank">Oops! I Clobbered My Yank</a></li>
        </ol>
      </li>
      <li><a href="#tip-61-grok-vims-registers" id="markdown-toc-tip-61-grok-vims-registers">Tip 61. Grok Vim’s Registers</a>        <ol>
          <li><a href="#addressing-a-register" id="markdown-toc-addressing-a-register">Addressing a Register</a></li>
          <li><a href="#vims-terminology-versus-the-world" id="markdown-toc-vims-terminology-versus-the-world">Vim’s Terminology Versus the World</a></li>
          <li><a href="#the-unnamed-register-" id="markdown-toc-the-unnamed-register-">The Unnamed Register (“”)</a></li>
          <li><a href="#the-yank-register-0" id="markdown-toc-the-yank-register-0">The Yank Register (“0)</a></li>
          <li><a href="#the-named-registers-az" id="markdown-toc-the-named-registers-az">The Named Registers (“a–”z)</a></li>
          <li><a href="#the-black-hole-register-_" id="markdown-toc-the-black-hole-register-_">The Black Hole Register (“_)</a></li>
        </ol>
      </li>
      <li><a href="#시리즈-포스트를-한-장의-페이지로도-정리합니다" id="markdown-toc-시리즈-포스트를-한-장의-페이지로도-정리합니다">시리즈 포스트를 한 장의 페이지로도 정리합니다.</a></li>
    </ol>
  </li>
</ol>

<h2 id="part-iv-registers">Part IV. Registers</h2>

<p>Vim의 레지스터는 단순히 텍스트를 담는 보관함이다. 클립보드처럼 텍스트를 자르고, 복사하고 붙여 넣을 수 있으며, 일련의 키 입력을 저장하여 하나의 매크로로 기록할 수 있다.</p>

<h2 id="chapter-10-copy-and-paste">CHAPTER 10. Copy and Paste</h2>

<h3 id="tip-60-delete-yank-and-put-with-vims-unnamed-register">Tip 60. Delete, Yank, and Put with Vim’s Unnamed Register</h3>

<p>보통 잘라내기, 복사하기, 붙여넣기에 대해 이야기할 때는 클립보드에 텍스트를 넣는 것을 이야기한다. 하지만 Vim에서는 클립보드 대신에 <em>레지스터</em> 를 사용한다.</p>

<h4 id="transposing-characters">Transposing Characters</h4>

<p>오타를 내는 최대 이유는 문자 두 개의 순서가 바뀌는 것이다. Vim에서는 이런 실수를 쉽게 고칠 수 있다.</p>

<p><img src="/images/posts/Transposing_Charaters.gif" alt="두 글자 바꾸기" /></p>

<p><code class="highlighter-rouge">F␣</code> 명령으로 바꾸길 원하는 두 문자의 처음으로 이동한다. <code class="highlighter-rouge">x</code> 명령으로 커서 밑의 문자를 잘라내서 무명 레스트로 복사한다. <code class="highlighter-rouge">p</code> 명령으로 커서 다음에 무명 레지스터의 내용을 붙여넣는다. 함께 사용하면 <code class="highlighter-rouge">xp</code> 명령은 “다음 두 문자 서로 바꾸기”로 생각할 수 있다.</p>

<h4 id="transposing-lines">Transposing Lines</h4>

<p><img src="/images/posts/Transpoing_Lines.gif" alt="두 줄 바꾸기" /></p>

<p><code class="highlighter-rouge">x</code> 명령으로 현재 문자를 잘라내는 대신 <code class="highlighter-rouge">dd</code> 명령으로 줄을 잘라낼 수 있다. 이번에는 <code class="highlighter-rouge">p</code> 명령은 줄 단위로 텍스트를 다루어야 한다는 것을 안다. 현재 줄 아래에 무명 레지스터 내용을 붙여넣는다.</p>

<p><code class="highlighter-rouge">ddp</code>는 :현재 줄과 다음 줄의 순서를 서로 바꾸기”로 생각할 수 있다.</p>

<h4 id="duplicating-lines">Duplicating Lines</h4>

<p><code class="highlighter-rouge">yyp</code>는 줄 단위 복사하고 붙여넣기 기능으로 동작하고 줄 단위로 복제하는 데 유용하다.</p>

<h4 id="oops-i-clobbered-my-yank">Oops! I Clobbered My Yank</h4>

<p><code class="highlighter-rouge">copy_and_paste/collection.js</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">collection</span> <span class="o">=</span> <span class="nx">getCollection</span><span class="p">();</span>
<span class="nx">process</span><span class="p">(</span><span class="nx">somethingInTheWay</span><span class="p">,</span> <span class="nx">target</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">yiw</code> 를 입력해서 <code class="highlighter-rouge">collection</code>을 무명 레지스터에 복사한다. 이제 <code class="highlighter-rouge">jww</code>로 복사한 단어를 넣을 위치인 <code class="highlighter-rouge">somethungIhTheWay</code>로 이동한다. <code class="highlighter-rouge">diw</code> 명령으로 <code class="highlighter-rouge">somethungIhTheWay</code>를 지운다. <code class="highlighter-rouge">P</code>를 눌러 무명 레지스터에 있는 내용을 커서 앞에 붙여넣는다. 하지만 <code class="highlighter-rouge">collection</code>이 아니라 <code class="highlighter-rouge">somethungIhTheWay</code>가 나타난다.</p>

<p><code class="highlighter-rouge">diw</code> 명령은 단어를 단순히 지우기만 하는 게 아니라 지운 단어를 무명 레지스터에 복사하기도 한다. 익숙한 표현으로는 <code class="highlighter-rouge">diw</code>는 단어를 잘라낸다(<em>cut</em> the word).</p>

<p>이 문제를 해결하려면 Vim 레지스터가 어떻게 동작하는지 더 깊이 이해해야 한다.</p>

<h3 id="tip-61-grok-vims-registers">Tip 61. Grok Vim’s Registers</h3>

<p>보통 잘라하기(cut), 복사하기(copy), 붙여넣기(paste)는 한 개의 클립보드와 동작하지만, Vim에는 여러 레지스터가 있다.</p>

<h4 id="addressing-a-register">Addressing a Register</h4>

<p>Vim의 지우기(cut), 복사하기(yank), 넣기(pu) 명령을 사용할 때 명령 앞에 <code class="highlighter-rouge">"{register}</code>를 붙이면 어느 레지스터를 사용할지 지정할 수 있다. 레지스터를 지정하지 않으면 무명 레지스터를 사용한다.</p>

<blockquote>

  <h4 id="vims-terminology-versus-the-world">Vim’s Terminology Versus the World</h4>

  <p>잘라내기(cut), 복사하기(copy), 붙여넣기(paste)는 대부분의 데스크탑 운영 체제와 소프트웨어 프로그램에서 보편적으로 사용할 수 있다. Vim에서도 제공되지만, 용어가 다르다: 제거하기(delete), 복사하기(yank), 붙여넣기(put)</p>

  <p>Vim의 붙여넣기(put) 명령은 일반적인 붙여넣기(paste)와 동일하게 동작한다. 다행히 두 단어 모두 <em>p</em> 문자로 시작하기 때문에 어느 용어를 사용해도 된다.</p>

  <p>Vim의 복사하기(yank) 명령은 일반적인 복사하기(copy)처럼 동작하는데, 역사적인 이유가 있다. <code class="highlighter-rouge">c</code> 명령이 이미 교체하기(change) 동작에 배정되어 있어 복사하기(copy)를 대체할 이름을 찾아야 했다. <code class="highlighter-rouge">y</code> 키가 있어서 복사하기 동작이 yank 명령이 되었다.</p>

  <p>Vim의 제거하기(delete) 명령은 표준 잘라내기(cut) 동작과 같다. 이 명령은 특정 텍스트를 레지스터에 저장한 다음 문서에서 제거한다.</p>

  <p>실제 제거하기(delete) 기능은 Vim에 없을까? Vim에는 블랙 홀이라 부르는 특별한 레지스터가 있다. 이 레지스터는 아무 것도 반환하지 않는다. 블랙 홀 레지스터는 <code class="highlighter-rouge">_</code> 기호로 참조할 수 있다(:h quote_). <code class="highlighter-rouge">"_d{motin}</code>으로 진짜로 제거(delete)할 수 있다.</p>

</blockquote>

<p>현재 단어를 <code class="highlighter-rouge">a</code> 레지스터에 복사하려면 <code class="highlighter-rouge">"ayiw</code>를 입력하면 된다. 현재 행을 레지스터 <code class="highlighter-rouge">b</code>에 잘라내려면 <code class="highlighter-rouge">"bdd</code>라고 입력한다. 레지스터 <code class="highlighter-rouge">a</code>에 저장한 단어를 문서에 붙여넣으려면 <code class="highlighter-rouge">"ap</code> 명령을, 레지스터 <code class="highlighter-rouge">b</code>에 저장한 행을 붙여넣으려면 <code class="highlighter-rouge">"bp</code> 명령을 사용한다.</p>

<p>일반 모드 명령뿐 아니라, Ex 명령으로도 사용할 수 있다. 현재 행을 잘라내서 <code class="highlighter-rouge">c</code> 레지스터에 저장하 려면 <code class="highlighter-rouge">:delete c</code>를 실행하면 된다. 현재 행 밑에 붙여 넣으려면 <code class="highlighter-rouge">:put c</code>를 입력한다. 일반 모드 명령에 비해서 거창하게 느껴질 수 있지만 Vim 스크립트에서 다른 Ex 명령과 함께 조합하면 유용하다.</p>

<h4 id="the-unnamed-register-">The Unnamed Register (“”)</h4>

<p>레지스터를 지정하지 않으면, Vim은 무명 레지스터를 사용한다. 이 무명 레지스터는 “ 기호로 참조할 수 있다(:h quote_quote). 이 레지스터를 명시적으로 참조하려면 두 개의 큰 따옴표를 사용해야한다. 예를 들면, <code class="highlighter-rouge">""p</code>는 <code class="highlighter-rouge">p</code>와 같다.</p>

<p><code class="highlighter-rouge">x</code>, <code class="highlighter-rouge">s</code>, <code class="highlighter-rouge">d{motion}</code>, <code class="highlighter-rouge">c{motion}</code>, <code class="highlighter-rouge">y{motion}</code> 명령(대문자 명령도 같다)은 모두 무명 레지스터를 사용한다. 명령 앞에 <code class="highlighter-rouge">"{register}</code>를 붙이면 해당 레지스터를 사용하지만, 무명 레지스터를 기본 값이다. 무명 레지스터의 내용을 쉽게 덮어쓸 수 있으니, 주의해야 한다.</p>

<p>사실 Vim이 선택한 용어는 적절하지 않다. <code class="highlighter-rouge">x</code>와 <code class="highlighter-rouge">d{motion}</code> 명령은 일반적으로 “지우기(delete)” 명령이라고 하는데 잘못된 명칭이다. “잘라내기(cut)” 명령으로 생각하는 게 더 낫다. 무명 레지스터는 종종 우리가 기대하는 텍스트를 가지고 있지 않다. 그러나 다행히도 복사하기(yank) 레지스터는 더 신뢰할 수 있다.</p>

<h4 id="the-yank-register-0">The Yank Register (“0)</h4>

<p><code class="highlighter-rouge">y{motion}</code> 명령을 사용하면 선택한 텍스트가 무명 레지스터 뿐만 아니라 복사하기 레지스터에도 저장한다. 복사하기 레지스터는 <code class="highlighter-rouge">0</code> 기호로 참조할 수 있다(:h quote0).</p>

<p>레지스터 이름처럼 이 레지스터는 <code class="highlighter-rouge">y{motion}</code> 명령을 사용했을 때만 저장한다. 다시 말해서 <code class="highlighter-rouge">x</code>, <code class="highlighter-rouge">s</code>, <code class="highlighter-rouge">c{motion}</code>, <code class="highlighter-rouge">d{motion}</code> 명령은 저장하지 않는다. 텍스트를 복사하면, 다른 텍스트를 복사해서 명시적으로 덮어 쓸 때까지 레지스터 <code class="highlighter-rouge">0</code>에 계속 보관된다. 무명 레지 스터는 쉽게 날아가지만 복사하기 레지스터는 신뢰할 수 있다.</p>

<p>앞에서의 문제를 해결하기 위해 복사하기 레지스터를 사용할 수 있다.</p>

<p><img src="/images/posts/Copy_word_and_replace_word.gif" alt="단어 복사하고 단어 대체하기" /></p>

<p>아직도 <code class="highlighter-rouge">diw</code> 명령은 무명 레지스터를 덮어쓰지만, 복사하기 레지스터는 건드리지 않는다. <code class="highlighter-rouge">"OP</code> 명령으로 복사하기 레지스터에서 안전하게 붙여넣을 수 있다. 원하는 대로 동작했다.</p>

<p>무명 레지스터와 잘라내기 레지스터의 내용을 확인하면, 어떤 본문을 제거하고 복사 했는지 확인할 수 있다:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">reg</span> "<span class="m">0</span>
<span class="p">---</span> Registers <span class="p">---</span>
<span class="c">""  somethingInTheWay</span>
<span class="c">"0  collection</span>
</code></pre></div></div>

<h4 id="the-named-registers-az">The Named Registers (“a–”z)</h4>

<p>Vim에서는 알파벳 모든 문자에 해당하는 이름(named) 레지스터를 제공한다(:h quote_alpha). 26 조각의 텍스트를 잘라내기(<code class="highlighter-rouge">"ad{motion}</code>), 복사하기(<code class="highlighter-rouge">"ay{motion}</code>), 붙여넣기(<code class="highlighter-rouge">"ap</code>)할 수 있다는 것을 말한다.</p>

<p>이름 레지스터를 사용하려면 추가적인 키 입력이 있어야 하니 간단한 상황에서는 복사하기 레지스터(“0)가 더 낫다. 이름 레지스터는 하나 이상의 텍스트 조각을 여러 위치에서 붙여넣기를 원할 때 아주 유용하다.</p>

<p>이름 레지스터를 소문자로 참조하면 지정된 레지스터를 덮어쓰지만, 대문자로 참조하면 지정한 레지스터에 추가한다.</p>

<h4 id="the-black-hole-register-_">The Black Hole Register (“_)</h4>

<p>블랙홀 레지스터는 아무 내용도 반환하지 않는다. 이 레지스터는 밑줄 기호로 참조한다(:h quote_). <code class="highlighter-rouge">"_d{motion}</code> 명령을 실행하면 Vim은 복사본을 하나도 저장하지 않고 지정한 텍스트를 제거한다. 이 기능은 무명 레지스터의 내용을 덮어쓰지 않고 텍스트를 지우고 싶을 때 유용할 수 있다.</p>

<h3 id="시리즈-포스트를-한-장의-페이지로도-정리합니다">시리즈 포스트를 한 장의 페이지로도 정리합니다.</h3>

<ul>
  <li><a href="https://nolboo.kim/practical-vim/">Practical Vim 2판 정리 페이지</a></li>
</ul>

]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[Practical Vim 팁 요약 시리즈 - find and netrw]]></title>
            <link>http://nolboo.kim/blog/2017/02/04/practical-vim/</link>
            <pubDate>Sat, 04 Feb 2017 00:00:00 +0000</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"n0lb00", "github"=>"nolboo"}]]></dc:creator>
        
            <category><![CDATA[blog]]></category>
        
        
            <category><![CDATA[practical]]></category>
        
            <category><![CDATA[vim]]></category>
        
            <category><![CDATA[tip]]></category>
        
            <category><![CDATA[beginner]]></category>
        
            <category><![CDATA[advance]]></category>
        
            <guid>http://nolboo.kim/blog/2017/02/04/practical-vim/</guid>
            <description>
                <![CDATA[Chapter 7. Open Files and Save Them to Disk Tip 42. Open a File by Its Filepath Using ‘:edit’ Open a File Relative to the Current Working Directory Open a File Relative to the Active File Directory Easy Expansion of the Active File Directory Tip 43. Open a File by...]]>
            </description>
            <content:encoded>
                <![CDATA[<p><img src="/images/posts/vim.jpg" alt="Vim 3D" /></p>

<ol id="markdown-toc">
  <li><a href="#chapter-7-open-files-and-save-them-to-disk" id="markdown-toc-chapter-7-open-files-and-save-them-to-disk">Chapter 7. Open Files and Save Them to Disk</a>    <ol>
      <li><a href="#tip-42-open-a-file-by-its-filepath-using-edit" id="markdown-toc-tip-42-open-a-file-by-its-filepath-using-edit">Tip 42. Open a File by Its Filepath Using ‘:edit’</a>        <ol>
          <li><a href="#open-a-file-relative-to-the-current-working-directory" id="markdown-toc-open-a-file-relative-to-the-current-working-directory">Open a File Relative to the Current Working Directory</a></li>
          <li><a href="#open-a-file-relative-to-the-active-file-directory" id="markdown-toc-open-a-file-relative-to-the-active-file-directory">Open a File Relative to the Active File Directory</a></li>
          <li><a href="#easy-expansion-of-the-active-file-directory" id="markdown-toc-easy-expansion-of-the-active-file-directory">Easy Expansion of the Active File Directory</a></li>
        </ol>
      </li>
      <li><a href="#tip-43-open-a-file-by-its-filename-using-find" id="markdown-toc-tip-43-open-a-file-by-its-filename-using-find">Tip 43. Open a File by Its Filename Using ‘:find’</a>        <ol>
          <li><a href="#configure-the-path" id="markdown-toc-configure-the-path">Configure the ‘path’</a></li>
          <li><a href="#smart-path-management-with-railsvim" id="markdown-toc-smart-path-management-with-railsvim">Smart Path Management with rails.vim</a></li>
          <li><a href="#use-find-to-look-up-files-by-name" id="markdown-toc-use-find-to-look-up-files-by-name">Use ‘:find’ to Look up Files by Name</a></li>
        </ol>
      </li>
      <li><a href="#tip-44-explore-the-file-system-with-netrw" id="markdown-toc-tip-44-explore-the-file-system-with-netrw">Tip 44. Explore the File System with netrw</a>        <ol>
          <li><a href="#preparation" id="markdown-toc-preparation">Preparation</a></li>
          <li><a href="#meet-netrwvims-native-file-explorer" id="markdown-toc-meet-netrwvims-native-file-explorer">Meet netrw—Vim’s Native File Explorer</a></li>
          <li><a href="#opening-the-file-explorer" id="markdown-toc-opening-the-file-explorer">Opening the File Explorer</a></li>
          <li><a href="#working-with-split-windows" id="markdown-toc-working-with-split-windows">Working with Split Windows</a></li>
          <li><a href="#doing-more-with-netrw" id="markdown-toc-doing-more-with-netrw">Doing More with netrw</a></li>
        </ol>
      </li>
      <li><a href="#tip-45-save-files-to-nonexistent-directories" id="markdown-toc-tip-45-save-files-to-nonexistent-directories">Tip 45. Save Files to Nonexistent Directories</a></li>
      <li><a href="#tip-46-save-a-file-as-the-super-user" id="markdown-toc-tip-46-save-a-file-as-the-super-user">Tip 46. Save a File as the Super User</a></li>
      <li><a href="#시리즈-포스트를-한-장의-페이지로도-정리합니다" id="markdown-toc-시리즈-포스트를-한-장의-페이지로도-정리합니다">시리즈 포스트를 한 장의 페이지로도 정리합니다.</a></li>
    </ol>
  </li>
</ol>

<h2 id="chapter-7-open-files-and-save-them-to-disk">Chapter 7. Open Files and Save Them to Disk</h2>

<h3 id="tip-42-open-a-file-by-its-filepath-using-edit">Tip 42. Open a File by Its Filepath Using ‘:edit’</h3>

<p>:edit 명령과 파일의 절대 경로와 상대 경로를 사용하여 파일을 열 수 있다. <code class="highlighter-rouge">files/mvc</code> 폴더로 이동하여 vim을 실행한다.</p>

<h4 id="open-a-file-relative-to-the-current-working-directory">Open a File Relative to the Current Working Directory</h4>

<p>Vim에서는 bash 및 다른 셸과 마찬가지로 작업 디렉토리라는 개념이 있다. Vim은 시작될 때 쉘과 동일한 작업 디렉토리를 채택한다. <code class="highlighter-rouge">:pwd</code> Ex 명령(print working directory)으로 확인할 수 있다.</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">pwd</span>
<span class="sr">/Users/</span>drew<span class="sr">/practical-vim/</span>code<span class="sr">/files/</span>mvc
</code></pre></div></div>

<p><code class="highlighter-rouge">:edit {file}</code> 명령은 작업 디렉토리에 상대 경로로 파일을 열 수 있다. <code class="highlighter-rouge">lib/framework.js</code> 파일을 열려면:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span>edit lib/framework<span class="p">.</span>js
</code></pre></div></div>

<p><code class="highlighter-rouge">app/controllers/Navigation.js</code> 파일을 열려면 <code class="highlighter-rouge">:edit a&lt;Tab&gt;c&lt;Tab&gt;N&lt;Tab&gt;</code>으로 탭 키로 자동완성할 수 있다.</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span>edit app<span class="sr">/controllers/</span>Navigation<span class="p">.</span>js
</code></pre></div></div>

<h4 id="open-a-file-relative-to-the-active-file-directory">Open a File Relative to the Active File Directory</h4>

<p>현재 활성 버퍼와 같은 디렉토리에 있는 파일을 열 때, 현재 버퍼에 열린 파일의 경로를 기준으로 삼는다면 이상적일 것이다.</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span>edit %<span class="p">&lt;</span>Tab<span class="p">&gt;</span>
</code></pre></div></div>

<p>% 기호는 활성 버퍼의 파일 경로를 뜻하는 준말이다.(:h cmdline-special). <code class="highlighter-rouge">&lt;Tab&gt;</code> 키를 누르면 활성 버퍼의 파일 경로가 나타난다. 원하는 것은 아니지만 가까워졌다.</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span>edit %<span class="p">:</span><span class="k">h</span><span class="p">&lt;</span>Tab<span class="p">&gt;</span>
</code></pre></div></div>

<p>:h 수정자는 파일 경로에서 파일명을 제거한다(:h ::h).</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span>edit app<span class="sr">/controllers/</span>
</code></pre></div></div>

<p>이제 <code class="highlighter-rouge">Main.js</code>를 입력하여(탭 키로 자동완성하자) 파일을 연다. 전체적으로 다음 키만 입력했다:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span>edit %<span class="p">:</span><span class="k">h</span><span class="p">&lt;</span>Tab<span class="p">&gt;</span>M<span class="p">&lt;</span>Tab<span class="p">&gt;&lt;</span>Tab<span class="p">&gt;</span>
</code></pre></div></div>

<p>%:h 확장은 아주 유용하기 때문에 맵핑을 만들자.</p>

<blockquote>

  <h4 id="easy-expansion-of-the-active-file-directory">Easy Expansion of the Active File Directory</h4>

  <p><code class="highlighter-rouge">vimrc</code> file에 다음을 넣는다:</p>

  <p><code class="highlighter-rouge">cnoremap &lt;expr&gt; %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'</code></p>

  <p>이제 : 명령행 프롬프트에서 <code class="highlighter-rouge">%%</code>를 입력하면 <code class="highlighter-rouge">%:h&lt;Tab&gt;</code>을 입력한 것과 같이 활성 버퍼의 경로로 확장한다. <code class="highlighter-rouge">:edit</code> 뿐만아니라 <code class="highlighter-rouge">:write</code>, <code class="highlighter-rouge">:saveas</code>, <code class="highlighter-rouge">:read</code>와 같은 다른 Ex 명령에서도 사용할 수 있다</p>

  <p><a href="http://vimcasts.org/episodes/the-edit-command/">The :edit command</a></p>

</blockquote>

<h3 id="tip-43-open-a-file-by-its-filename-using-find">Tip 43. Open a File by Its Filename Using ‘:find’</h3>

<p><code class="highlighter-rouge">:find</code> 명령으로 경로 전체를 입력하지 않고 파일명만으로 파일을 열 수 있다. 이 기능을 사용하기 위해서는 먼저 <code class="highlighter-rouge">path</code>를 설정해야 한다.</p>

<p><code class="highlighter-rouge">:find</code> 명령을 지금 사용하면 경로에서 <code class="highlighter-rouge">Main.js</code> 파일을 찾을 수 없다고 한다:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span>find Main<span class="p">.</span>js
E345<span class="p">:</span> Can'<span class="k">t</span> find <span class="k">file</span> <span class="s2">"Main.js"</span> <span class="k">in</span> path
</code></pre></div></div>

<h4 id="configure-the-path">Configure the ‘path’</h4>

<p><code class="highlighter-rouge">path</code> 옵션으로 <code class="highlighter-rouge">:find</code> 명령을 사용할 때, Vim이 검색할 디렉토리 집합을 지정할 수 있다.(:h ‘path’). app의 서브 디렉토리를 추가하려면:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">set</span> path<span class="p">+=</span>app/**
</code></pre></div></div>

<p><code class="highlighter-rouge">**</code> 와일드카드는 <code class="highlighter-rouge">app/</code> 아래에 있는 모든 서브 디렉터리이다. ‘path’ 설정의 문맥에 따라 <code class="highlighter-rouge">*</code>와 <code class="highlighter-rouge">**</code>의 처리 방식이 약간 다르ㄴ다.(:h file-searching). 와일드카드는 셸이 처리하는 것이 아니고 Vim이 처리한다.</p>

<blockquote>

  <h4 id="smart-path-management-with-railsvim">Smart Path Management with rails.vim</h4>

  <p><a href="https://github.com/tpope/vim-rails">tpope/vim-rails: rails.vim</a>는 레일즈 프로젝트를 쉽게 탐색할 수 있게 하는 플러그인이다. 일반적인 레일즈 프로젝트에서 볼 수 있는 모든 디렉토리를 자동으로 <code class="highlighter-rouge">path</code>를 설정한다. <code class="highlighter-rouge">path</code>를 설정할 필요없이 <code class="highlighter-rouge">:find</code> 명령을 사용할 수 있다.</p>

  <p>여기서 그치는 것이 아니라, <code class="highlighter-rouge">:Rcontroller</code>, <code class="highlighter-rouge">:Rmodel</code>, <code class="highlighter-rouge">:Rview</code>과 같은 편리한 명령도 제공한다. <code class="highlighter-rouge">:find</code>의 특화된 버전이다, scoping its search to the corresponding directory.</p>

</blockquote>

<h4 id="use-find-to-look-up-files-by-name">Use ‘:find’ to Look up Files by Name</h4>

<p>이제 ‘path’를 설정했기 때문에 파일명만 입력하면 디렉터리 안의 파일을 열 수 있다.</p>

<p><code class="highlighter-rouge">app/controllers/Navigation.js</code> 파일을 열려면:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span>find Navigation<span class="p">.</span>js
</code></pre></div></div>

<p>탭 키로 눌러 파일명을 자동완성할 수 있다. <code class="highlighter-rouge">find nav&lt;Tab&gt;</code>을 입력하고 엔터 키를 누르면 된다.</p>

<p>같은 이름을 가진 파일이 여러 개라면 탭 키를 누를 때마다 전체 경로와 파일명을 보여준다. 탭 키로 전체 파일 경로로 확장하지 않고 엔터 키를 누르면 처음 일치 파일을 연다.</p>

<p>‘wildmode’ 설정을 기본값 <code class="highlighter-rouge">full</code>에서 변경하면 탭-완성 동작이 조금 다를 수 있다.</p>

<h3 id="tip-44-explore-the-file-system-with-netrw">Tip 44. Explore the File System with netrw</h3>

<p>Vim에 포함되어 있는 netrw 플러그인을 이용하여 파일 시스템을 탐색할 수 있다.</p>

<h4 id="preparation">Preparation</h4>

<p>Vim의 핵심 소스 코드에 포함되어 있지는 않지만 netrw라는 플러그인에서 제공하는 기능이다. 이 플러그인은 Vim과 함께 표준으로 제공하기 때문에 플러그인을 사용하도록 설정만 하면 아무것도 설치할 필요가 없다. <code class="highlighter-rouge">vimrc</code> 파일에 다음 설정만 추가하면 된다:</p>

<p><code class="highlighter-rouge">essential.vim</code></p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">set</span> nocompatible
<span class="k">filetype</span> plugin <span class="k">on</span>
</code></pre></div></div>

<h4 id="meet-netrwvims-native-file-explorer">Meet netrw—Vim’s Native File Explorer</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>code/file/mvc
<span class="nv">$ </span><span class="nb">ls
</span>app app.js index.html lib
<span class="nv">$ </span>vim <span class="nb">.</span>
</code></pre></div></div>

<p>일반 Vim 버퍼이지만 파일 내용이 아니라 디렉토리의 내용을 보여준다. <code class="highlighter-rouge">k</code>와 <code class="highlighter-rouge">j</code> 키로 위아래로 이동할 수 있다. 디렉토리에서 <code class="highlighter-rouge">&lt;CR&gt;</code> 키를 누르면 그 디렉토리 내용을, 파일이면 현재 창의 버퍼로 불러온다. 부모 디렉터리로 이동하려면 <code class="highlighter-rouge">-</code>를 누르거나, 또는 .. 항목으로 이동해서 <code class="highlighter-rouge">&lt;CR&gt;</code>을 누른다.</p>

<p><code class="highlighter-rouge">j</code>와 <code class="highlighter-rouge">k</code> 키 이외에 일반 Vim 버퍼에서 사용할 수 있는 모든 모션을 사용할 수 있다. 예를 들면, <code class="highlighter-rouge">index.html</code> 파일을 열고 싶다면 /html<code class="highlighter-rouge">&lt;CR&gt;</code>로 검색하여 원하는 파일명 위로 이동할 수 있다.</p>

<h4 id="opening-the-file-explorer">Opening the File Explorer</h4>

<p><code class="highlighter-rouge">:edit {path}</code> 명령으로 파일 탐색 창을 열 수 있다. <code class="highlighter-rouge">.</code> 기호는 현재 작업 디렉토리이며, <code class="highlighter-rouge">:edit .</code> 명령은 프로젝트 루트를 파일 탐색기로 열 수 있다.</p>

<p>현재 파일의 경로를 파일 탐색기로 열려면 <code class="highlighter-rouge">:edit %:h</code> 명령을 사용한다. netrw 플러그인은 <code class="highlighter-rouge">:Explore</code>라는 더 편한 명령을 제공한다(:h :Explore).</p>

<p><code class="highlighter-rouge">:edit .</code> 대신 <code class="highlighter-rouge">:e.</code>의 단축 명령도 사용할 수 있다. <code class="highlighter-rouge">.</code> 앞에 빈칸이 필요없다. <code class="highlighter-rouge">:Explore</code>는 <code class="highlighter-rouge">:E</code>로 사용할 수 있다.(안되는데?)</p>

<p>netrw은 <code class="highlighter-rouge">:Sexplore</code>와 <code class="highlighter-rouge">:Vexplore</code> 명령도 있다. 각각 창을 수평이나 수직으로 나누고 파일 탐색기를 연다.</p>

<h4 id="working-with-split-windows">Working with Split Windows</h4>

<p>텍스트 에디터의 기본 GUI는 사이드 바에 <em>project drawer</em> 라는 파일 탐색기를 표시한다. 이런 인터페이스에 익숙하다면 Vim 의 <code class="highlighter-rouge">:E</code>와 <code class="highlighter-rouge">:e</code>이 현재 창의 내용을 파일 탐색기로 <em>대체하는 것이</em> 이상할 수 있다. 분할 창에서도 잘 동작한다. 파일 탐색기를 열었다가 다시 원래 버퍼로 돌아가고 싶다면 <code class="highlighter-rouge">&lt;Ctrl-^&gt;</code> 명령을 누른다.</p>

<p>Vim의 창은 두 가지 모드를 있다고 말할 수 있다. 파일 모드와 디렉터리 모드. 이것은 분할 창 인터페이스와 완벽하게 작동하지만, project drawer 개념과 실제로 들어맞지는 않는다.</p>

<h4 id="doing-more-with-netrw">Doing More with netrw</h4>

<p>netrw 플러그인으로 파일 탐색만 할 수 있는 것은 아니다. 새 파일이나(:h netrw-%) 디렉토리를(:h netrw-d) 만들고, 파일명을 바꾸거나(:h netrw-rename), 지운다(:h netrw-del). <a href="http://vimcasts.org/episodes/the-file-explorer/">The file explorer</a></p>

<p>netrw 이름에서 보이는 킬러 기능은 손대지 않았다: netrw는 네트워크의 파일을 읽고 쓸 수 있다. 시스템에서 사용할 수 있는 <code class="highlighter-rouge">scp</code>, <code class="highlighter-rouge">ftp</code>, <code class="highlighter-rouge">curl</code>, <code class="highlighter-rouge">wget</code>을 포함한 많은 프로토콜을 사용할 수 있다.(:h netrw-ref)</p>

<h3 id="tip-45-save-files-to-nonexistent-directories">Tip 45. Save Files to Nonexistent Directories</h3>

<p><code class="highlighter-rouge">:edit {file}</code> 명령은 이미 존재하는 파일을 여는 것이 가장 일반적이다. 파일의 경로가 일치하지 않으면, Vim은 새 빈 버퍼를 만든다. <code class="highlighter-rouge">&lt;Ctrl-g&gt;</code>를 누르면 “new file”로 표시된다(:h ctrl-G). <code class="highlighter-rouge">:write</code> 명령을 실행하면 Vim은 현재 버퍼 내용을 지정한 파일 경로의 새 파일에 쓰려고 한다.</p>

<p><code class="highlighter-rouge">:edit {file}</code>을 실행할 때, 존재하지 않는 디렉터리를 파일 경로를 지정하면, 조금 이상할 것이다.</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span>edit madeup<span class="sr">/dir/</span>doesnotexist<span class="p">.</span>yet
<span class="p">:</span>write
<span class="c">"madeup/dir/doesnotexist.yet" E212: Can't open file for writing</span>
</code></pre></div></div>

<p>madeup/dir 디렉토리가 존재하지 않는다. Vim은 새 버퍼를 만들려고 하지만, 디렉터리가 존재하지 않으면 “new DIRECTORY”로 표시한다. 외부 mkdir 프로그램을 호출하여 이 상황을 해결할 수 있다.</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:!</span>mkdir <span class="p">-</span><span class="k">p</span> %<span class="p">:</span><span class="k">h</span>
<span class="p">:</span>write
</code></pre></div></div>

<p><code class="highlighter-rouge">-p</code> 플래그는 mkdir 명령에서 중간 디렉토리를 만드는 옵션이다.</p>

<h3 id="tip-46-save-a-file-as-the-super-user">Tip 46. Save a File as the Super User</h3>

<p>파일의 변경 사항을 저장하기 위해 관리자 권한(sudo)이 필요한 경우가 있다. Vim을 다시 시작하지 않고 sudo 셸 명령을 사용할 수 있다.</p>

<p>이 팁은 GVim에서 동작하지 않을 수 있고 윈도에서 동작하지 않는다. 유닉스 터미널에서 Vim을 실행했을 때 동작하는 시나리오이다.</p>

<p><code class="highlighter-rouge">/etc/hosts</code> 파일로 설명한다. 이 파일은 root가 소유자이나, 우리는 “drew”라는 사용자명으로 로그인하였기 때문에 이 파일을 읽을 수 있는 권한만 갖고 있다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-al</span> /etc/ | <span class="nb">grep </span>hosts
<span class="nt">-rw-r--r--</span>  1   root    wheel       634 6   Apr 15:59 hosts
<span class="nv">$ </span>whoami
drew
<span class="nv">$ </span>vim /etc/hosts
</code></pre></div></div>

<p><code class="highlighter-rouge">&lt;Ctrl-g&gt;</code>로 파일 상태를 확인하면 <code class="highlighter-rouge">[readonly]</code>으로 표시된다. 파일을 변경하면 “W10: Warning: Changing a readonly file.” 메시지를 보여주지만 상관없이 변경할 수 있다. 그러나, 저장하지 못할 것이다.</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span>write
E45<span class="p">:</span> <span class="s1">'readonly'</span> <span class="k">option</span> <span class="k">is</span> <span class="k">set</span> <span class="p">(</span>add <span class="p">!</span> <span class="k">to</span> override<span class="p">)</span>
</code></pre></div></div>

<p>메시지가 안내하는 대로 명령 끝에 뱅(!) 기호를 붙여서 다시 실행한다. 뱅 기호는 “이번에는 실행한다!”로 읽을 수 있다.</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span>write<span class="p">!</span>
<span class="c">"/etc/hosts" E212: Can't open file for writing</span>
</code></pre></div></div>

<p>여기에서 문제는 <code class="highlighter-rouge">/etc/hosts</code> 파일을 쓸 권한이 없다는 점이다. root가 소유하고 있고 사용자 drew Vim을 실행했다는 것을 기억하라. 해결책은 다음 이상하게 보이는 명령이다:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">w</span> <span class="p">!</span>sudo tee % <span class="p">&gt;</span> <span class="sr">/dev/</span>null
Password<span class="p">:</span>
W12<span class="p">:</span> Warning<span class="p">:</span> File <span class="s2">"hosts"</span> has changed and the buffer was
changed <span class="k">in</span> Vim <span class="k">as</span> well
<span class="p">[</span>O<span class="p">]</span><span class="k">k</span><span class="p">,</span> <span class="p">(</span>L<span class="p">)</span>oad File<span class="p">,</span> Load <span class="p">(</span>A<span class="p">)</span><span class="k">ll</span><span class="p">,</span> <span class="p">(</span>I<span class="p">)</span>gnore All<span class="p">:</span>
</code></pre></div></div>

<p>이 명령을 입력하면 두 자기를 더 요구한다. 먼저 drew의 비밀번호를 입력해야 한다. 그 후 Vim은 파일이 변경되었다는 점을 경고하고 선택 메뉴를 제시한다. 일단 <code class="highlighter-rouge">l</code>을 눌러 파일을 다시 버퍼로 불러오는 것을 권한다.</p>

<p>어떤 원리로 동작할까? <code class="highlighter-rouge">:write !{cmd}</code> 명령은 버퍼 내용을 <code class="highlighter-rouge">{cmd}</code>로 호출한 외부 프로그램의 표준 입력으로 전송한다(:h :write_c). Vim은 여전히 drew 사용자 권한으로 사용하고 있지만 외부 프로세스는 관리자 권한으로 실행하도록 요청할 수 있다. 여기에서는 <code class="highlighter-rouge">/etc/hosts</code> 파일을 작성할 수 있도록 sudo 권한으로 유틸리티 <code class="highlighter-rouge">tee</code>를 실행했다.</p>

<p>Vim의 명령행에서 <code class="highlighter-rouge">%</code> 기호는 특별한 의미로 사용한다. 이 기호는 현재 버퍼의 경로를 의미한다(:h :_%). 여기에서는 <code class="highlighter-rouge">/etc/hosts</code>이다. 그래서 최종적으로 <code class="highlighter-rouge">tee /etc/hosts &gt; / dev/null</code> 명령을 실행한다. 이 명령은 버퍼 내용을 표준 입력으로 받아서 <code class="highlighter-rouge">/etc/hosts</code> 파일의 내용을 덮어쓴다.</p>

<p>외부 프로그램이 파일을 변경하면 Vim은 그 변경을 감지한다. 즉, 지금 상황 에서는 버퍼를 생성할 때의 파일 내용과 실제 파일 내용이 일치하지 않는 것을 감지했기 때문에 Vim이 현재 버퍼의 변경 내역을 유지할지, 아니면 디스크의 파일을 불러올지 물어보게 된다. 이 예제에서는 파일과 버퍼의 내용이 같다.</p>

<h3 id="시리즈-포스트를-한-장의-페이지로도-정리합니다">시리즈 포스트를 한 장의 페이지로도 정리합니다.</h3>

<ul>
  <li><a href="https://nolboo.kim/practical-vim/">Practical Vim 2판 정리 페이지</a></li>
</ul>

]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[Practical Vim 팁 요약 시리즈 - grep and vimgrep]]></title>
            <link>http://nolboo.kim/blog/2017/01/16/practical-vim/</link>
            <pubDate>Mon, 16 Jan 2017 00:00:00 +0000</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"n0lb00", "github"=>"nolboo"}]]></dc:creator>
        
            <category><![CDATA[blog]]></category>
        
        
            <category><![CDATA[practical]]></category>
        
            <category><![CDATA[vim]]></category>
        
            <category><![CDATA[tip]]></category>
        
            <category><![CDATA[beginner]]></category>
        
            <category><![CDATA[advance]]></category>
        
            <guid>http://nolboo.kim/blog/2017/01/16/practical-vim/</guid>
            <description>
                <![CDATA[CHAPTER 18. Search Project-Wide with grep, vimgrep, and Others Tip 109. Call grep Without Leaving Vim Using grep from the Command Line Calling grep from Inside Vim Tip 110. Customize the grep Program Vim’s Default grep Settings Make :grep Call ack Alternative grep Plugins Make ack Jump to Line and...]]>
            </description>
            <content:encoded>
                <![CDATA[<p><img src="/images/posts/vim.jpg" alt="Vim 3D" /></p>

<ol id="markdown-toc">
  <li><a href="#chapter-18-search-project-wide-with-grep-vimgrep-and-others" id="markdown-toc-chapter-18-search-project-wide-with-grep-vimgrep-and-others">CHAPTER 18. Search Project-Wide with grep, vimgrep, and Others</a>    <ol>
      <li><a href="#tip-109-call-grep-without-leaving-vim" id="markdown-toc-tip-109-call-grep-without-leaving-vim">Tip 109. Call grep Without Leaving Vim</a>        <ol>
          <li><a href="#using-grep-from-the-command-line" id="markdown-toc-using-grep-from-the-command-line">Using grep from the Command Line</a></li>
          <li><a href="#calling-grep-from-inside-vim" id="markdown-toc-calling-grep-from-inside-vim">Calling grep from Inside Vim</a></li>
        </ol>
      </li>
      <li><a href="#tip-110-customize-the-grep-program" id="markdown-toc-tip-110-customize-the-grep-program">Tip 110. Customize the grep Program</a>        <ol>
          <li><a href="#vims-default-grep-settings" id="markdown-toc-vims-default-grep-settings">Vim’s Default grep Settings</a></li>
          <li><a href="#make-grep-call-ack" id="markdown-toc-make-grep-call-ack">Make <code class="highlighter-rouge">:grep</code> Call ack</a></li>
          <li><a href="#alternative-grep-plugins" id="markdown-toc-alternative-grep-plugins">Alternative grep Plugins</a></li>
          <li><a href="#make-ack-jump-to-line-and-column" id="markdown-toc-make-ack-jump-to-line-and-column">Make ack Jump to Line and Column</a></li>
        </ol>
      </li>
      <li><a href="#tip-111-grep-with-vims-internal-search-engine" id="markdown-toc-tip-111-grep-with-vims-internal-search-engine">Tip 111. Grep with Vim’s Internal Search Engine</a>        <ol>
          <li><a href="#specifying-which-files-to-look-inside" id="markdown-toc-specifying-which-files-to-look-inside">Specifying Which Files to Look Inside</a></li>
          <li><a href="#search-in-file-then-search-in-project" id="markdown-toc-search-in-file-then-search-in-project">Search in File, Then Search in Project</a></li>
          <li><a href="#search-history-and-vimgrep" id="markdown-toc-search-history-and-vimgrep">Search History and :vimgrep</a></li>
        </ol>
      </li>
    </ol>
  </li>
  <li><a href="#역자-요약" id="markdown-toc-역자-요약">역자 요약</a>    <ol>
      <li><a href="#시리즈-포스트를-한-장의-페이지로도-정리합니다" id="markdown-toc-시리즈-포스트를-한-장의-페이지로도-정리합니다">시리즈 포스트를 한 장의 페이지로도 정리합니다.</a></li>
    </ol>
  </li>
</ol>

<h2 id="chapter-18-search-project-wide-with-grep-vimgrep-and-others">CHAPTER 18. Search Project-Wide with grep, vimgrep, and Others</h2>

<p>Vim의 검색 명령은 파일 내의 모든 패턴을 찾는 데 탁월하다. 그러나 전체 프로젝트에서 일치하는 항목을 찾으려면 어떻게 해야 할까? 많은 파일을 살펴봐야 한다. 전통적으로 이것은 유닉스 검색 전용 도구 인 grep의 영역이다.</p>

<p>편집기를 떠나지 않고도 외부 프로그램을 호출할 수 있는 <code class="highlighter-rouge">:grep</code> 명령을 살펴본다. 이 명령은 기본적으로 grep을 호출하지만, <code class="highlighter-rouge">ack</code>와 같은 다른 검색 전용 프로그램을 사용하도록 설정할 수 있다.</p>

<p>외부 프로그램을 사용할 때의 한 가지 단점은 정규식 구문이 대부분의 Vim 검색에 사용되는 구문과 호환되지 않을 수 있다. <code class="highlighter-rouge">:vimgrep</code> 명령을 사용하면 Vim의 기본 검색 엔진을 사용하여 여러 파일의 패턴을 찾을 수 있다. <code class="highlighter-rouge">vimgrep</code>은 전용 프로그램만큼 빠르지 않다.</p>

<h3 id="tip-109-call-grep-without-leaving-vim">Tip 109. Call grep Without Leaving Vim</h3>

<p><code class="highlighter-rouge">:grep</code> 명령은 외부의 <code class="highlighter-rouge">grep</code> (또는 grep 같은) 프로그램을 사용할 수 있는 래퍼(wrapper)처럼 동작한다. 이 래퍼를 사용하여 Vim을 벗어나지 않고 여러 파일에 걸쳐 <code class="highlighter-rouge">grep</code> 패턴 검색을 할 수 있고, 퀵픽스 목록을 사용하여 검색 결과를 오갈 수 있다.</p>

<h4 id="using-grep-from-the-command-line">Using grep from the Command Line</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-n</span> <span class="o">{</span>text<span class="o">}</span> <span class="k">*</span>
</code></pre></div></div>

<p>기본적으로 <code class="highlighter-rouge">grep</code>은 일치하는 행의 내용과 파일명을 한 줄로 보여준다. <code class="highlighter-rouge">-n</code> 플래그는 <code class="highlighter-rouge">grep</code>에게 출력에 행 번호를 표시한다.</p>

<p>검색 결과 항목을 표처럼 다룰 수 있다. 결과 목록의 각 항목에서 파일을 열 수 있고, 행 번호를 지정할 수 있다. goldrush.txt의 9행을 열고 싶다면:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>vim contain-result.txt +9
</code></pre></div></div>

<h4 id="calling-grep-from-inside-vim">Calling grep from Inside Vim</h4>

<p><code class="highlighter-rouge">:grep</code> 명령은 외부 <code class="highlighter-rouge">grep</code> 프로그램의 레퍼(wrapper)이다(:h :grep). 셸에서 <code class="highlighter-rouge">grep</code>을 실행하는 대신에 Vim에서 직접 실행할 수 있다.</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">grep</span> <span class="p">{</span>text<span class="p">}</span> *
</code></pre></div></div>

<p>Vim이 <code class="highlighter-rouge">grep -n {text} *</code>을 셸에서 실행한다. Vim은 <code class="highlighter-rouge">grep</code> 검색 결과를 해석해서 퀵픽스 목록으로 만든다. <code class="highlighter-rouge">:cnext</code>, <code class="highlighter-rouge">:cprev</code> 명령으로 결과를 탐색할 수 있으며 모든 기능을 사용할 수 있다.</p>

<p>Vim은 자동으로 <code class="highlighter-rouge">-n</code> 플래그를 추가해서 grep 결과에 행 번호도 출력한다. 퀵픽스 목록을 탐색할 때, 일치하는 각 행으로 바로 이동할 수 있는 이유이다.</p>

<p>대소문자를 구분하지 않으려면 <code class="highlighter-rouge">-i</code> 플래그를 사용한다.</p>

<h3 id="tip-110-customize-the-grep-program">Tip 110. Customize the grep Program</h3>

<p><code class="highlighter-rouge">:grep</code> 명령은 외부 <code class="highlighter-rouge">grep</code> 프로그램을 실행하기 위한 래퍼이다. Vim이 이 명령을 처리하는 방법을 ‘grepprg’와 ‘grepformat’ 설정을 수정하여 변경할 수 있다.</p>

<h4 id="vims-default-grep-settings">Vim’s Default grep Settings</h4>

<p>‘grepprg’ 설정은 <code class="highlighter-rouge">:grep</code> 명령을 실행할 때 셸에서 실행하는 명령을 지정한다(:h ‘grepprg’). ‘grepformat’ 설정은 Vim이 <code class="highlighter-rouge">:grep</code> 명령의 출력 결과를 해석하는 방법을 지장한다(:h ‘grepformat’). Unix 시스템에서는 기본 값이 다음과 같다:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">grepprg</span><span class="o">=</span><span class="s2">"grep -n </span><span class="nv">$*</span><span class="s2"> /dev/null"</span>
<span class="nv">grepformat</span><span class="o">=</span><span class="s2">"%f:%l:%m,%f:%l%m,%f %l%m"</span>
</code></pre></div></div>

<p>‘grepprg’ 설정에서는 $* 기호를 플레이스홀더로 사용하는데 <code class="highlighter-rouge">:grep</code> 명령의 인자가 위치하는 곳을 뜻한다.
‘grepformat’ 설정은 <code class="highlighter-rouge">:grep</code>이 반환하는 결과 메시지의 구조를 토큰으로 작성한 문자열이다. ‘grepformat’ 문자열에서 사용되는 특수 토큰은 ‘errorformat’에 사용 된 것과 같다.</p>

<p>이제 <code class="highlighter-rouge">%f:%l %m</code> 기본 형식을 사용한 grep 결과를 확인한다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>department-store.txt:1:Waldo is beside the boot counter.
goldrush.txt:6:Waldo is studying his clipboard.
goldrush.txt:9:The penny farthing is 10 paces ahead of Waldo.
</code></pre></div></div>

<p>각 레코드에서, <code class="highlighter-rouge">%f</code>가 파일명(department-store.txt나 goldrush.txt)에 해당하고, <code class="highlighter-rouge">%l</code>은 행 번호, <code class="highlighter-rouge">%m</code>은 행의 일치하는 문자열이다.</p>

<p>‘grepformat’ 문자열은 쉼표로 구분된 여러 형식을 포함할 수 있다. 기본 일치는 <code class="highlighter-rouge">%f:%l %m</code> 또는 <code class="highlighter-rouge">%f %l%m</code>이다. Vim은 <code class="highlighter-rouge">:grep</code> 출력과 일치하는 첫 번째 형식을 사용한다.</p>

<h4 id="make-grep-call-ack">Make <code class="highlighter-rouge">:grep</code> Call ack</h4>

<p><code class="highlighter-rouge">ack</code>는 grep 대용이고 특히 개발자를 대상으로 한다.(http://betterthangrep.com)</p>

<p>먼저 ack를 설치해야 한다. 우분투에서:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>apt-get install ack-grep
<span class="nv">$ </span><span class="nb">sudo </span>ln <span class="nt">-s</span> /usr/bin/ack-grep /usr/local/bin/ack
</code></pre></div></div>

<p>첫 명령은 프로그램을 설치하고 <code class="highlighter-rouge">ack-grep</code> 명령을 사용할 수 있게 한다. 두 번째 명령은 <code class="highlighter-rouge">ack</code>로 호출할 수 있도록 심볼릭링크를 생성한다.</p>

<p>OS X에서는 Homebrew로 설치할 수 있다:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>brew install ack
</code></pre></div></div>

<p>이제 ‘grepprg’와 ‘grepformat’ 설정을 변경해서 <code class="highlighter-rouge">:grep</code>이 <code class="highlighter-rouge">ack</code>를 사용하도록 설정 한다. <code class="highlighter-rouge">ack</code>에서는 파일명을 한 줄로 출력하고, 행 번호와 일치하는 행의 내용이 뒤따른다:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ack Waldo <span class="k">*</span>
department-store.txt
1:Waldo is beside the boot counter.

goldrush.txt
6:Waldo is studying his clipboard.
9:The penny farthing is 10 paces ahead of Waldo.
</code></pre></div></div>

<p><code class="highlighter-rouge">--nogroup</code> 스위치와 함께 <code class="highlighter-rouge">ack</code>를 실행하면 <code class="highlighter-rouge">grep -n</code>의 결과처럼 출력을 쉽게 변경할 수 있다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ack <span class="nt">--nogroup</span> Waldo <span class="k">*</span>
department-store.txt:1:Waldo is beside the boot counter.
goldrush.txt:6:Waldo is studying his clipboard.
goldrush.txt:9:The penny farthing is 10 paces ahead of Waldo.
</code></pre></div></div>

<p>이 출력은 <code class="highlighter-rouge">grep -n</code>의 형식과 일치한다. Vim의 기본 ‘grepformat’ 설정은 변경할 필요 없다. ‘grepprg’만 다음처럼 변경한다:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">set</span> grepprg<span class="p">=</span>ack\ <span class="p">--</span>nogroup\ $*
</code></pre></div></div>

<blockquote>

  <h4 id="alternative-grep-plugins">Alternative grep Plugins</h4>

  <p>Vim에서는 외부 프로그램을 사용해서 여러 파일의 본문을 쉽게 검색할 수 있다. 단순히 ‘grepprg’와 ‘grepfotmat’ 설정을 변경한 다음에 <code class="highlighter-rouge">:grep</code> 명령을 사용하면 끝이다. 그 결과는 퀵픽스 목록에서 확인할 수 있다. 어떤 프로그램을 호출하는지에 상관없이 사용할 수 있기 때문에 거의 이상적인 인터페이스이다.</p>

  <p>그러나 중요한 차이가 있다. <code class="highlighter-rouge">grep</code>은 POSIX 정규표현식을 사용하나 <code class="highlighter-rouge">ack</code>는 펄의 정규표현식을 사용한다. <code class="highlighter-rouge">:grep</code> 명령을 사용하여 <code class="highlighter-rouge">ack</code>를 호출하면 이 차이 때문에 제대로 호출되지 않는다. <code class="highlighter-rouge">:Ack</code>라는 명령을 직접 만들어서 이름처럼 <code class="highlighter-rouge">ack</code>를 호출하는 것은 어떨까?</p>

  <p>이런 접근 방법으로 개발된 <code class="highlighter-rouge">Ack.vim</code> 플러그인이 있다.<a href="https://github.com/mileszs/ack.vim">mileszs/ack.vim: Vim plugin for the Perl module / CLI script ‘ack’</a> 또한, <code class="highlighter-rouge">git-grep</code>을 사용할 수 있도록 <code class="highlighter-rouge">:Ggrep</code> 명령을 제공하는 <code class="highlighter-rouge">fugitive.vim</code> 플러그인도 있다.<a href="https://github.com/tpope/vim-fugitive">tpope/vim-fugitive: fugitive.vim: a Git wrapper so awesome, it should be illegal</a></p>

  <p>이렇게 여러 플러그인을 설치할 수 있고, <code class="highlighter-rouge">:grep</code> 명령을 대체하는 방식보다 각 플러그인의 커스텀 명령을 만들어 서로 충돌없이 공존할 수 있다.</p>

</blockquote>

<h4 id="make-ack-jump-to-line-and-column">Make ack Jump to Line and Column</h4>

<p>그러나 <code class="highlighter-rouge">ack</code>는 또 다른 기법을 소매 속에 숨기고 있다. <code class="highlighter-rouge">--column</code> 옵션과 함께 실행하면 <code class="highlighter-rouge">ack</code>는 일치하는 행과 <em>열 번호</em> 를 출력한 다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ack <span class="nt">--nogroup</span> <span class="nt">--column</span> Waldo <span class="k">*</span>
department-store.txt:1:1:Waldo is beside the boot counter.
goldrush.txt:6:1:Waldo is studying his clipboard.
goldrush.txt:9:41:The penny farthing is 10 paces ahead of Waldo.
</code></pre></div></div>

<p>‘grepformat’이 추가 정보를 추출할 수 있도록 설정하면 일치하는 행으로 이동하는 것뿐만 아니라 일치하는 정확한 위치로 이동할 수 있다. 다음 설정으로 쉽게 된다:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">set</span> grepprg<span class="p">=</span>ack\ <span class="p">--</span>nogroup\ <span class="p">--</span>column\ $*
<span class="p">:</span><span class="k">set</span> grepformat<span class="p">=</span>%<span class="k">f</span><span class="p">:</span>%<span class="k">l</span><span class="p">:</span>%<span class="k">c</span><span class="p">:</span>%<span class="k">m</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">%c</code> 항목이 일치하는 열 번호이다.</p>

<h3 id="tip-111-grep-with-vims-internal-search-engine">Tip 111. Grep with Vim’s Internal Search Engine</h3>

<p><code class="highlighter-rouge">:vimgrep</code> 명령으로 Vim의 내장 정규표현식 엔진을 사용해서 여러 파일을 검색할 수 있다.</p>

<p><code class="highlighter-rouge">grep/quotes</code> 폴더에서 각 파일은 단어 “going”을 하나 이상 포함하고 있다. <code class="highlighter-rouge">:vimgrep</code> 명령을 사용하여 이 단어를 어떤 파일이 포함하고 있는지 찾으려면:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">vimgrep</span> <span class="sr">/going/</span> clock<span class="p">.</span>txt tough<span class="p">.</span>txt where<span class="p">.</span>txt
<span class="p">(</span><span class="m">1</span> of <span class="m">3</span><span class="p">):</span> Don'<span class="k">t</span> watch the clock; <span class="k">do</span> what it does<span class="p">.</span> Keep going<span class="p">.</span>
<span class="p">:</span>cnext
<span class="p">(</span><span class="m">2</span> of <span class="m">3</span><span class="p">):</span> When the going gets tough<span class="p">,</span> the tough get going<span class="p">.</span>
<span class="p">:</span>cnext
<span class="p">(</span><span class="m">3</span> of <span class="m">3</span><span class="p">):</span> If you don'<span class="k">t</span> know where you are going<span class="p">,</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">:vimgrep</code> 명령은 일치한 항목을 각각 한 줄씩 퀵픽스 목록을 만든다. <code class="highlighter-rouge">:cnext</code>, <code class="highlighter-rouge">:cprev</code>와 같은 명령을 사용해서 결과를 탐색한다.</p>

<p><code class="highlighter-rouge">tough.txt</code> 파일은 “going”이 두 번 나타난다. 하지만 <code class="highlighter-rouge">:vimgrep</code> 명령은 첫 일치하는 것만 고려한다. 모든 항목을 찾으려면 <code class="highlighter-rouge">g</code> 플래그를 패턴 뒤에 추가한다.</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">vim</span> <span class="sr">/going/</span><span class="k">g</span> clock<span class="p">.</span>txt tough<span class="p">.</span>txt where<span class="p">.</span>txt
<span class="p">(</span><span class="m">1</span> of <span class="m">4</span><span class="p">):</span> Don'<span class="k">t</span> watch the clock; <span class="k">do</span> what it does<span class="p">.</span> Keep going<span class="p">.</span>
</code></pre></div></div>

<p>이번에는 “going” 단어가 나타나는 모든 항목이 퀵픽스 목록에 포함한다. <code class="highlighter-rouge">:substitute</code> 명령이 동작하는 방식이 기억날 것이다: 기본적으로는 행에서 첫 번째 일치하는 항목에 대해서만 치환을 수행한다. <code class="highlighter-rouge">g</code> 플래그를 제공했을 때 주어진 행에서 일치하는 모든 것에 대해 수행한다. 필자는 <code class="highlighter-rouge">:substitute</code>나 <code class="highlighter-rouge">:vimgrep</code> 명령을 사용 할 때 거의 항상 <code class="highlighter-rouge">g</code> 플래그를 넣어서 사용한다.</p>

<h4 id="specifying-which-files-to-look-inside">Specifying Which Files to Look Inside</h4>

<p>다음은 <code class="highlighter-rouge">:vimgrep</code> 명령 형식이다(:h :vimgrep).</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">vim</span><span class="p">[</span><span class="k">grep</span><span class="p">][!]</span> <span class="sr">/{pattern}/</span><span class="p">[</span><span class="k">g</span><span class="p">][</span><span class="k">j</span><span class="p">]</span> <span class="p">{</span><span class="k">file</span><span class="p">}</span> <span class="p">...</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">{file}</code> 인자는 빈칸으로 남겨둘 수 없다. 이 인자에는 파일명이나 와일드카드, 역따옴표 표현식, 그리고 이 모든 것을 조합할 수도 있다. 인자 목록을 불러올 때 사용할 수 있던 그 기법을 여기에서도 사용할 수 있다.</p>

<p>와일드카드를 사용해서 동일한 검색을 수행할 수 있다:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">vim</span> <span class="sr">/going/</span><span class="k">g</span> *<span class="p">.</span>txt
</code></pre></div></div>

<p><code class="highlighter-rouge">*</code>과 <code class="highlighter-rouge">**</code> 와일드카드를 사용한 것처럼 인자 목록에 있는 파일을 모두 열기 위해서 <code class="highlighter-rouge">##</code> 기호를 사용할 수 있다(:h cmdline-special). 이 기호를 사용하면 조금 다른 방식으로도 작업을 진행할 수 있다. 먼저 인자 목록에 검사할 파일을 불러온다. 그런 다음 인수 목록의 각 파일에 대해 <code class="highlighter-rouge">:vimgrep</code>을 실행한다.</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span>args *<span class="p">.</span>txt
<span class="p">:</span><span class="k">vim</span> <span class="sr">/going/</span><span class="k">g</span> ##
<span class="p">(</span><span class="m">1</span> of <span class="m">4</span><span class="p">):</span> Don'<span class="k">t</span> watch the clock; <span class="k">do</span> what it does<span class="p">.</span> Keep going<span class="p">.</span>
</code></pre></div></div>

<p>Ex 명령 두 개로 분리해서 실행하기 때문에 더 일하는 것 같지만 <code class="highlighter-rouge">:vimgrep</code>을 사용할 때는 이 방식을 종종 선호한다. 어느 파일을 검색하고 싶은가, 그리고 어떤 패턴을 검색하고 싶은가로 분리해서 생각할 수 있기 때문이다. 인자 목록으로 파일을 불러 온 후에 <code class="highlighter-rouge">:vimgrep</code> 명령을 사용하고 싶은 만큼 반복할 수도 있다.</p>

<h4 id="search-in-file-then-search-in-project">Search in File, Then Search in Project</h4>

<p><code class="highlighter-rouge">:vimgrep</code>에 패턴 필드를 비워두면 현재 검색 패턴을 다시 사용할 수 있다. <code class="highlighter-rouge">:substitute</code> 명령과 <code class="highlighter-rouge">:global</code> 명령에서도 같은 트릭을 사용할 수 있다. 이 방법은 여러 파일에 걸쳐 정규표현식을 사용할 때 유용하다. 현재 파일에서 정규표현식을 조합하고 적합한 정규표현식을 작성할 때까지 반복한다. 패턴 결과가 마음에 들 때 <code class="highlighter-rouge">:vimgrep</code> 명령을 사용한다. 다음은 “don’t”와 “Don’t” 모두 일치하는 정규표현식을 현재 파일 내에서 검색한 후 <code class="highlighter-rouge">:vimgrep</code>을 사용한다:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/<span class="p">[</span>Dd<span class="p">]</span><span class="k">on</span>'<span class="k">t</span>
<span class="p">:</span><span class="k">vim</span> <span class="sr">//</span><span class="k">g</span> *<span class="p">.</span>txt
<span class="p">(</span><span class="m">1</span> of <span class="m">2</span><span class="p">):</span> Don'<span class="k">t</span> watch the clock; <span class="k">do</span> what it does<span class="p">.</span> Keep going<span class="p">.</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">:vimgrep</code>의 가장 큰 장점은 Vim의 검색 명령과 같은 패턴을 사용할 수 있다는 것이다. 검색 패턴을 사용한 후에 같은 검색 패턴으로 <code class="highlighter-rouge">:grep</code>으로 프로젝트 기준 검색을 수행하려면 먼저 POSIX 정규표현식으로 번역해야 한다. 간단한 정규표현식은 오래 걸리지 않겠지만, 복잡한 정규표현식은 하고 싶지 않을 것이다.</p>

<h4 id="search-history-and-vimgrep">Search History and :vimgrep</h4>

<p>인자 목록에서 현재 검색 패턴과 일치하는 파일이 얼마나 있는지 확인하기 위해 다음 명령을 사용할 수 있다:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">vim</span> <span class="sr">//</span><span class="k">g</span> ##
</code></pre></div></div>

<p>주의 깊게 봐야 하는 부분은 항상 인자 목록(##)과 검색 히스토리의 현재 정보를 사용한다는 것이다. 만약 이 명령을 나중에 반복하면 인자 목록과 검색 히스토리에 따라서 다르게 동작할 것이다.</p>

<p>그 대신에 <code class="highlighter-rouge">&lt;Ctrl-r&gt;/</code>로 검색 필드를 현재 패턴의 값으로 채울 수 있다. 검색 결과는 어느 쪽이든 같지만 명령 히스토리는 다르다.</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">vim</span> <span class="sr">/&lt;Ctrl-r&gt;/</span>/<span class="k">g</span> ##
</code></pre></div></div>

<p><code class="highlighter-rouge">:vimgrep</code> 명령을 다시 사용하더라도 패턴이 명령 히스토리에 포함되어 있기 때문에 더 유용할 것이다.</p>

<h2 id="역자-요약">역자 요약</h2>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">gr</span> <span class="p">-</span><span class="k">i</span> <span class="p">{</span>text<span class="p">}</span> *     " 외부 <span class="k">grep</span> 실행

/<span class="p">{</span>pattern<span class="p">}</span>          " 원하는 검색 패턴을 찾은 후
<span class="p">:</span><span class="k">vim</span> <span class="sr">//</span><span class="k">g</span> *          " vimgrep으로 검색
</code></pre></div></div>

<h3 id="시리즈-포스트를-한-장의-페이지로도-정리합니다">시리즈 포스트를 한 장의 페이지로도 정리합니다.</h3>

<ul>
  <li><a href="https://nolboo.kim/practical-vim/">Practical Vim 2판 정리 페이지</a></li>
</ul>

]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[Practical Vim 팁 요약 시리즈 - Jumps and Marks]]></title>
            <link>http://nolboo.kim/blog/2017/01/15/practical-vim/</link>
            <pubDate>Sun, 15 Jan 2017 00:00:00 +0000</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"n0lb00", "github"=>"nolboo"}]]></dc:creator>
        
            <category><![CDATA[blog]]></category>
        
        
            <category><![CDATA[practical]]></category>
        
            <category><![CDATA[vim]]></category>
        
            <category><![CDATA[tip]]></category>
        
            <category><![CDATA[beginner]]></category>
        
            <category><![CDATA[advance]]></category>
        
            <guid>http://nolboo.kim/blog/2017/01/15/practical-vim/</guid>
            <description>
                <![CDATA[CHAPTER 9.Navigate Between Files with Jumps Tip 56. Traverse the Jump List Beware of Mapping the Tab Key Tip 57. Traverse the Change List Marks for the Last Change 시리즈 포스트를 한 장의 페이지로도 정리합니다. 프랙티컬 Vim 2판을 정리하는 페이지이며 내 편한대로 발췌하고 보충하기 때문에 원본을 반드시 참조하세요. Vim은 다른...]]>
            </description>
            <content:encoded>
                <![CDATA[<p><img src="/images/posts/vim.jpg" alt="Vim 3D" /></p>

<ol id="markdown-toc">
  <li><a href="#chapter-9navigate-between-files-with-jumps" id="markdown-toc-chapter-9navigate-between-files-with-jumps">CHAPTER 9.Navigate Between Files with Jumps</a>    <ol>
      <li><a href="#tip-56-traverse-the-jump-list" id="markdown-toc-tip-56-traverse-the-jump-list">Tip 56. Traverse the Jump List</a>        <ol>
          <li><a href="#beware-of-mapping-the-tab-key" id="markdown-toc-beware-of-mapping-the-tab-key">Beware of Mapping the Tab Key</a></li>
        </ol>
      </li>
      <li><a href="#tip-57-traverse-the-change-list" id="markdown-toc-tip-57-traverse-the-change-list">Tip 57. Traverse the Change List</a>        <ol>
          <li><a href="#marks-for-the-last-change" id="markdown-toc-marks-for-the-last-change">Marks for the Last Change</a></li>
        </ol>
      </li>
      <li><a href="#시리즈-포스트를-한-장의-페이지로도-정리합니다" id="markdown-toc-시리즈-포스트를-한-장의-페이지로도-정리합니다">시리즈 포스트를 한 장의 페이지로도 정리합니다.</a></li>
    </ol>
  </li>
</ol>

<ul>
  <li><strong>프랙티컬 Vim 2판을 정리하는 페이지이며 내 편한대로 발췌하고 보충하기 때문에 원본을 반드시 참조하세요</strong>.</li>
  <li>Vim은 다른 텍스트 에디터와 다르게 여러 모드를 가진다. Normal/Insert/Visual Mode의 세 가지가 주요 모드인데, 번역이 일관성이 없다. 대체로  Normal Mode는 <strong>일반</strong>/명령 모드, Insert Mode는 <strong>입력</strong>/편집 모드, Visual Mode는 <strong>비주얼</strong>/선택 모드, 일반 모드에서 <code class="highlighter-rouge">:</code>로 진입하는 모드는 <strong>명령행</strong>/ex/명령어 모드 등으로 번역되는데, 이 글에서는 앞의 굵은 글씨의 모드로 사용한다.</li>
</ul>

<h2 id="chapter-9navigate-between-files-with-jumps">CHAPTER 9.Navigate Between Files with Jumps</h2>

<p>점프(jump)는 모션과 비슷하지만 다른 파일 사이를 이동할 수 있다.</p>

<h3 id="tip-56-traverse-the-jump-list">Tip 56. Traverse the Jump List</h3>

<p>Vim은 점프할 때 이동 전과 후의 위치를 모두 저장하고, 그 발자취를 알 수 있는 명령을 제공한다.</p>

<p>웹 브라우저에서는 뒤로 버튼으로 이전에 방문했던 페이지로 이동할 수 있다. Vim은 비슷한 기능을 하는 점프 목록(jump list)이 있다. <code class="highlighter-rouge">&lt;Ctrl-o&gt;</code> 명령이 뒤로 버튼과 같으며 <code class="highlighter-rouge">&lt;Ctrl-i&gt;</code> 명령은 앞으로 버튼과 같다. 이 명령으로 점프 목록을 오갈수 있다.</p>

<p>모션은 파일 안에서 이동할 때 사용하고, 점프는 파일 사이를 이동할 때 사용한다.(모션 중 점프로 구분되는 일부 모션이 있지만)</p>

<p>점프 목록을 보려면:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="k">jumps</span>
<span class="k">jump</span> line <span class="k">col</span> <span class="k">file</span>/text
   <span class="m">4</span>   <span class="m">12</span>   <span class="m">2</span> <span class="p">&lt;</span>recipe id<span class="p">=</span><span class="s2">"sec.jump.list"</span><span class="p">&gt;</span>
   <span class="m">3</span>  <span class="m">114</span>   <span class="m">2</span> <span class="p">&lt;</span>recipe id<span class="p">=</span><span class="s2">"sec.change.list"</span><span class="p">&gt;</span>
   <span class="m">2</span>  <span class="m">169</span>   <span class="m">2</span> <span class="p">&lt;</span>recipe id<span class="p">=</span><span class="s2">"sec.gf"</span><span class="p">&gt;</span>
   <span class="m">1</span>  <span class="m">290</span>   <span class="m">2</span> <span class="p">&lt;</span>recipe id<span class="p">=</span><span class="s2">"sec.global.marks"</span><span class="p">&gt;</span>
<span class="p">&gt;</span>
Press Enter or type command <span class="k">to</span> continue
</code></pre></div></div>

<p>현재 창에서 파일을 변경하는 명령은 모두 점프 명령이라고 말할 수 있다. Vim은 점프 명령을 실행하 기 전과 후의 위치를 점프 목록에 기록한다. <code class="highlighter-rouge">:edit</code> 명령으로 새 파일을 열었다면 두 파일을 <code class="highlighter-rouge">&lt;Ctrl-o&gt;</code>와 <code class="highlighter-rouge">&lt;Ctrl-i&gt;</code> 명령으로 오갈 수 있다.</p>

<p><code class="highlighter-rouge">[count]G</code>로 특정 행으로 바로 이동하는 것은 점프이지만 한 행씩 이동하는 것은 점프가 아니다. 문장 단위 및 단락 단위의 모션은 점프이지만 문자와 단어의 모션은 점프가 아니다. 일반적으로 장거리 모션은 점프로 분류될 수 있지만 단거리 모션은 그냥 모션이다.</p>

<p>점프로 처리되는 명령을 정리한다:</p>

<table>
  <thead>
    <tr>
      <th>Command</th>
      <th>Effect</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[count]G</td>
      <td>Jump to line number</td>
    </tr>
    <tr>
      <td>/pattern<code class="highlighter-rouge">&lt;CR&gt;</code>/?pattern<code class="highlighter-rouge">&lt;CR&gt;</code>/n/N</td>
      <td>Jump to next/previous occurrence of pattern</td>
    </tr>
    <tr>
      <td>%</td>
      <td>Jump to matching parenthesis</td>
    </tr>
    <tr>
      <td>( / )</td>
      <td>Jump to start of previous/next sentence</td>
    </tr>
    <tr>
      <td>{ / }</td>
      <td>Jump to start of previous/next paragraph</td>
    </tr>
    <tr>
      <td>H / M / L</td>
      <td>Jump to top/middle/bottom of screen</td>
    </tr>
    <tr>
      <td>gf</td>
      <td>Jump to file name under the cursor</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">&lt;Ctrl-]&gt;</code></td>
      <td>Jump to definition of keyword under the cursor</td>
    </tr>
    <tr>
      <td>‘{mark} / `{mark}</td>
      <td>Jump to a mark</td>
    </tr>
  </tbody>
</table>

<p><code class="highlighter-rouge">&lt;Ctrl-o&gt;</code>와 <code class="highlighter-rouge">&lt;Ctrl-i&gt;</code> 명령 자체는 모션으로 처리되지 않는다. 비주얼 모드에서 선택 영역을 확장하거나 동작-대기 모드에서 이 명령을 사용할 수 없다는 뜻이다.</p>

<p>Vim은 여러 점프 목록을 동시에 관리 한다. 실은 각 창마다 각 점프 목록이 있다. 창 분할이나 다중 탭 페이지를 사용하고 있다면 <code class="highlighter-rouge">&lt;Ctrl-o&gt;</code>와 <code class="highlighter-rouge">&lt;Ctrl-i&gt;</code> 명령은 항상 활성 창의 점프 목록을 따라 이동한다.</p>

<blockquote>

  <h4 id="beware-of-mapping-the-tab-key">Beware of Mapping the Tab Key</h4>

  <p>입력 모드에서 <code class="highlighter-rouge">&lt;Ctrl-i&gt;</code>는 <code class="highlighter-rouge">&lt;Tab&gt;</code>을 입력하는 것과 같다. Vim이 <code class="highlighter-rouge">&lt;Ctrl-i&gt;</code>와 <code class="highlighter-rouge">&lt;Tab&gt;</code>을 같은 것으로 보기 때문이다.</p>

  <p><code class="highlighter-rouge">&lt;Tab&gt;</code> 키의 매핑을 변경하면, <code class="highlighter-rouge">&lt;Ctrl-i&gt;</code>를 누를 때도 변경된 매핑을 실행한다.(반대도 마찬가지다) 그러므로 <code class="highlighter-rouge">&lt;Tab&gt;</code>을 다른  기능으로 변경할 때는 점프 목록을 이동하는 <code class="highlighter-rouge">&lt;Ctrl-i&gt;</code>를 포기할 만큼 중요한지 고려해야 한다. 한 방향으로만 이동하는 것은 그다지 유용하지 않기 때문이다.</p>

</blockquote>

<h3 id="tip-57-traverse-the-change-list">Tip 57. Traverse the Change List</h3>

<p>작업을 취소하는 명령과 취소한 작업을 다시 되돌리는 명령을 실행하면 최근에 변경한 위치로 이동하는 부차적인 효과도 생긴다. 실행 취소 명령은 최근 변경 위치로 돌아가고 싶은 경우에도 유용하다. <code class="highlighter-rouge">u&lt;Ctrl-r&gt;</code>은 일종의 해킹이다.</p>

<p>Vim은 편집 세션 중에 각 버퍼에 대한 수정 목록을 관리한다. 이 것을 변경 목록(change list)이라고 한다.(:h changelist) <code class="highlighter-rouge">:changes</code> 명령으로 내용을 볼 수 있다.</p>

<p><code class="highlighter-rouge">g;</code>와 <code class="highlighter-rouge">g,</code> 명령으로 변경 목록에서 앞 뒤로 이동할 수 있다. <code class="highlighter-rouge">;</code>와 <code class="highlighter-rouge">,</code> 명령이 <code class="highlighter-rouge">f{char}</code> 명령을 반복하거나 역반복할 수 있다는 것을 생각하면 기억하기 쉬울 것이다.</p>

<p>문서에서 최근 변경으로 되돌아 가려면 <code class="highlighter-rouge">g;</code>를 입력한다. <code class="highlighter-rouge">u&lt;Ctrl-r&gt;</code>을 입력해도 결과는 같지만, 문서에 일시적인 변경을 만든다.</p>

<h4 id="marks-for-the-last-change">Marks for the Last Change</h4>

<p>Vim은 변경 목록을 보완하기 위해서 마크를 자동으로 생성한다. <code class="highlighter-rouge">`.</code> 마크는 항상 마지막 변경의 위치를 참조한다.(:h <code class="highlighter-rouge">`.</code>) <code class="highlighter-rouge">`^</code> 마크는 입력 모드를 종료한 마지막 위치를 기록한다.</p>

<p>대부분의 시나리오에서 <code class="highlighter-rouge">`.</code> 마크로 이동하면 <code class="highlighter-rouge">g;</code> 명령과 효과가 같다. 하지만 <code class="highlighter-rouge">`.</code> 마크가 마지막 변화의 위치만을 저장하는 것과 달리 변경 목록은 여러 위치를 저장한다. <code class="highlighter-rouge">g;</code>를 반복 입력할 때마다 변경 목록에 저장된 위치를 순서대로 이동할 수 있다. 반면 <code class="highlighter-rouge">`.</code>는 변경 목록에서 가장 마지막 위치로만 이동한다.</p>

<p><code class="highlighter-rouge">`^</code> 마크는 마지막 <em>변경_과는 살짝 다른, 마지막 _입력</em> 위치를 참조한다. 입력 모드를 벗어나서 문서를 스크롤한 후 <code class="highlighter-rouge">gi</code>를 입력하여 벗어난 곳으로 빠르게 갈 수 있다. <code class="highlighter-rouge">`^</code>는 한 번의 움직임으로 커서 위치를 복원하고 입력 모드로 전환한다.</p>

<p>Vim은 변경 목록을 버퍼를 기준으로 관리한다. 대조적으로, 점프 목록은 창을 기준으로 만든다.</p>

<h3 id="시리즈-포스트를-한-장의-페이지로도-정리합니다">시리즈 포스트를 한 장의 페이지로도 정리합니다.</h3>

<ul>
  <li><a href="https://nolboo.kim/practical-vim/">Practical Vim 2판 정리 페이지</a></li>
</ul>

]]>
            </content:encoded>
        </item>
    

</channel>

</rss>