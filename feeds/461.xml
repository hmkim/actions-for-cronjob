<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet href="http://rss.egloos.com/style/blog.xsl" type="text/xsl" media="screen"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel>
	<title>까먹지말자!</title>
	<link>http://kwon37xi.egloos.com</link>
	<description>권남, 코드로 말하다.</description>
	<language>ko</language>
	<pubDate>Sun, 27 Nov 2016 05:55:28 GMT</pubDate>
	<generator>Egloos</generator>
	<image>
		<title>까먹지말자!</title>
		<url>http://pds11.egloos.com/logo/200810/14/15/b0046915.jpg</url>
		<link>http://kwon37xi.egloos.com</link>
		<width>80</width>
		<height>80</height>
		<description>권남, 코드로 말하다.</description>
	</image>
  	<item>
		<title><![CDATA[ Github 2015년말~2016년말 매일매일 코딩 기록 ]]> </title>
		<link>http://kwon37xi.egloos.com/7281853</link>
		<guid>http://kwon37xi.egloos.com/7281853</guid>
		<description>
			<![CDATA[ 
  2015년 말에 어쩌다보니10여일간 거의 연속으로 코딩을 한 적이 있다.<br />
그래서 시작한 김에 1년간 해볼까? 하고 계속 진행했다. <a href="https://github.com/kwon37xi" target="_blank">나의 Github</a>.<br />
<br />
<div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://thumbnail.egloos.net/500x0/http://pds27.egloos.com/pds/201611/27/15/b0046915_583a63b24c6da.png" width="500" height="125.836680054" onclick="Control.Modal.openDialog(this, event, 'http://pds27.egloos.com/pds/201611/27/15/b0046915_583a63b24c6da.png', 747, 188);" /></div><br />
<br />
위는 2015년 11월말부터 2016년 11월 26일까지의 기록이다. 휴가기간에도 노트북을 들고가서 쉬는시간에 짬을내어 무엇인가를 코딩해서 올렸다.<br />
10월달에 회식자리에서 집에갔더니 12시가 넘어서 딱 한 번 빼먹었다.<br />
<br />
1년간 회고를 해보자면,<br />
<br />
좋은 점은 꾸준한 학습에 나름 많은 도움이 됐다. 무언가를 하루도 거르지 않고 할 수 있다는 그 자체가 사실 큰 의미를 주고, 나도 할 수 있다는 자신감으로 다가온다.<br />
<br />
하지만 문제가 있다.<br />
공부가 제일 쉬웠어요. - 사실 공부가 제일 쉽다. 올 1년을 제외한 그 전의 <a href="https://github.com/kwon37xi" target="_blank">나의 Github</a> 활동은 세상에 없던 것들을 만드는데 많이 할애 되었었으나, 매일 매일 코딩을 시작한 뒤에는 Github이 거의 남의 것을 학습하고 그 것을 기록하는 용도로 변형 되었다. 매일매일 코드를 남기는데는 이게 훨씬 편하다. 스스로 생각하고 창조하다보면 시간이 너무 많이 가고 실제 코딩량은 현저히 줄게 된다.<br />
<br />
나 정도 경력자가 되면 공부도 공부지만 창조를 해야한다. 내가 블로그에 글을 쓰면서도 언제부터인가 원칙으로 삼는 것이 있는데, 바로 남의 것을 번역하거나 정리해서 전달하지 말고, 혹은 현재 트렌드를 소개하는 식의 글을 지양하고 나만의 무언가를 글로 남기자는 것이다(그 때문에 글쓰는 양이 현저히 줄어들었다).<br />
<br />
2017년에도 계속해서 할 수 있는 데까지 매일매일 코딩을 하겠지만, 휴가 기간은 이제 편히 쉬는데 집중하고, 또한 학습 코딩 비중을 낮추고 비록 허접하더라도 세상에 없는 나만의 무엇인가를 만드는데 집중할 수 있도록 노력해야겠다.<br />
<br/><br/>tag : <a href="/tag/programming" rel="tag">programming</a>,&nbsp;<a href="/tag/github" rel="tag">github</a>			 ]]> 
		</description>
		<category>프로그래밍</category>
		<category>programming</category>
		<category>github</category>

		<comments>http://kwon37xi.egloos.com/7281853#comments</comments>
		<pubDate>Sun, 27 Nov 2016 04:49:45 GMT</pubDate>
		<dc:creator>권남</dc:creator>
	</item>
	<item>
		<title><![CDATA[ FindBugs 적용 후 흔히 발생하는 버그 패턴들 ]]> </title>
		<link>http://kwon37xi.egloos.com/7243139</link>
		<guid>http://kwon37xi.egloos.com/7243139</guid>
		<description>
			<![CDATA[ 
  회사의 모든 프로젝트는 <a href="http://findbugs.sourceforge.net/" target="_blank">FindBugs</a> 지표 수집을 하게 돼 있는데 이를 <a href="http://www.sonarqube.org/" target="_blank">SonarQube</a>를 통해 프로젝트 건강성 지표로만 삼고 있었다(findbugs, jacoco code coverage, checkstyle, pmd 등을 수집한다).<br />
하지만 지표는 참조일뿐 강제가 아니고, 바쁘면 바쁘다는 핑계로 무시하게 마련이다.<br />
<br />
그러다가 팀원들과 팀 프로젝트에서 <a href="http://findbugs.sourceforge.net/" target="_blank">FindBugs</a> 의 버그 탐지를 단순 지표가 아닌 build 실패로 간주하도록 (빌드가 실패하면 당연히 배포 불가이다) 하기로 논의하여 결정하고 적용했더니 매주 1~2건씩은 배포 전에 버그를 탐지해 막아주고 있다(물론 이 버그들은 코드 Coverage 100%의 테스트를 했다면 발생하지 않았겠지만 그건 다음에...).<br />
물론 Build 행위는 <a href="https://jenkins.io/" target="_blank">Jenkins</a> + <a href="http://kwon37xi.egloos.com/4747016" target="_blank">Gradle</a> 조합으로 이뤄지며 <a href="https://wiki.jenkins-ci.org/display/JENKINS/FindBugs+Plugin" target="_blank">Jenkins의 FindBugs 플러그인</a>으로 FindBugs 의 버그가 탐지되면 빌드 실패로 간주하고 배포를 불가능하게 설정하였다.<br />
<br />
FindBugs는 가급적 단순 지표가 아닌 <b>실제 배포 가능 여부를 가늠하는 도구로써 버그 탐지시에는 실질적으로 컴파일이 안 된 것과 마찬가지로 취급하는 것이 좋겠다</b>.<br />
<br />
지금까지 내가 본 흔히 나오는 버그 패턴은 다음과 같다(컴파일은 되지만 100% 버그이므로 따라하면 안됨!!).<br />
<br />
<b>1. null 체크해놓고 그 객체 호출하기(보통은 logging 시에 실수로 호출함)</b><br />
<blockquote class="src">if (a == null) {<br />
 ....<br />
&nbsp;&nbsp;&nbsp; log.debug("a.something {}", a.getSomething()); // 로깅 코드에서 null pointer exception이 발생해서 로그도 안남고 에러가 남.<br />
}<br />
</blockquote><br />
<br />
<b>2. 서로 다른 타입간의 equals 호출</b><br />
<blockquote class="src">Integer a = ..;<br />
Long b = ..;<br />
if (a.equals(b)) { // 언제나 false<br />
 ... <br />
}<br />
</blockquote><br />
<br />
또한 흔한게 enum 과 String 비교.<br />
<blockquote class="src">String enumValue = "..";<br />
if (SomeEnum.ENUMVALUE.equals(enumValue)) { // 언제나 false<br />
 ... <br />
}<br />
</blockquote><br />
<br />
enum은 아예 <code>equals()</code>를 사용하지 말고 <code>==</code> 비교를 하는 게 낫다.<br />
<br />
<b>3. 숫자 Wrapper 객체 동일성  <code>==</code> 비교</b><br />
<blockquote class="src">Integer a = new Integer(1);<br />
Integer b = new Integer(1);<br />
if (a == b) { ... } // false이다.<br />
</blockquote><br />
<br />
Wrapper 객체는 <code>equals()</code> 로 비교해야 한다.<br />
<br />
<b>4. List/Map 등 컬렉션에서 엉뚱한 객체로 get 하기</b><br />
안타깝게도 <code>List.indexOf()와 Map.get()</code>은 인자로 지정된 Generic Type을 받는게 아니라 Object를 받는다. 이로 인해 버그가 발생한다(이렇게 한 이유가 있겠지...).<br />
<blockquote class="src">List&lt;Integer&gt; integers = ...;<br />
Long someLongValue = 1L;<br />
<br />
// Integer 1 값이 리스트에 있어도 올바로 판단 못함<br />
if (integers.indexOf(someLongValue) &gt;= 0) { // false이다.<br />
...<br />
}<br />
</blockquote><br />
<br />
<code>Map.get()</code>도 마찬가지이다. 특히 이 경우의 버그가 많이 발생한다.<br />
<blockquote class="src">Map&lt;Integer,String&gt;&nbsp;map&nbsp;=&nbsp;new&nbsp;HashMap&lt;&gt;();<br />
map.put(<strong>1</strong>,&nbsp;"하나");<br />
map.put(2,&nbsp;"둘");<br />
<br />
System.out.println(map.get(<strong>1L</strong>));&nbsp;//&nbsp;null<br />
</blockquote><br />
<br />
예제에서는 단순화하려고 값을 직접 넣었지만 대부분은 메소드 파라미터로 받았기 때문에 코드의 호출부에서는 파라미터의 타입이 눈에 안 띄어서 버그여부를 인지하기가 쉽지 않다.<br />
<br />
위에서 보다시피<strong>가장 많은 버그는 메소드의 인자가 Object 일 때 발생</strong>한다(<code>equals, List.indexOf, Map.get</code>). 컴파일 에러가 안나기 때문이다.<br />
<br />
FindBugs 가 정착이 다 되면, 이후에는 다음과 같은 것도 해볼까 생각중.<br />
<ol><li><a href="https://wiki.jenkins-ci.org/display/JENKINS/JaCoCo+Plugin" target="_blank">Jenkins JaCoCo Plugin</a> 을 통해 현 시점의 코드 커버리지를 임계치로 설정하고 임계치보다 떨어지면 빌드 실패하게, 그리고 1주일에 1%씩 임계치 증가시키키(아무튼 최소한 커버리지를 떨어뜨리지는 못하게)<br />
</li><li><a href="https://wiki.jenkins-ci.org/display/JENKINS/Checkstyle+Plugin" target="_blank">Jenkins Checkstyle</a> 과 <a href="https://wiki.jenkins-ci.org/display/JENKINS/PMD+Plugin" target="_blank">Jenkins PMD</a> 적용하고 임계치를 서서히 증가시키기</li></ol><p>위 툴들은 우리회사에서는 이미 SonarQube를 통해 지표 수집은 다 하고 있는 것들이다. 거기에 강제성을 부여하는 것만 더 하고 싶은 것.</p><p><br />
</p><p>마지막으로.. <font size="4"><b>FindBugs가 버그를 찾아줬으니 버그가 없다는 착각 따위는 하지 말 것. 결국은 열심히 단위 테스트를 해야 한다.</b></font>.</p><p><font size="4"><b>단점 : 빌드 시간이 너무 길어져서 배포 시간이 증가했다... ㅜㅜ</b></font><br />
</p><br/><br/>tag : <a href="/tag/programming" rel="tag">programming</a>,&nbsp;<a href="/tag/java" rel="tag">java</a>,&nbsp;<a href="/tag/findbugs" rel="tag">findbugs</a>			 ]]> 
		</description>
		<category>프로그래밍</category>
		<category>programming</category>
		<category>java</category>
		<category>findbugs</category>

		<comments>http://kwon37xi.egloos.com/7243139#comments</comments>
		<pubDate>Thu, 14 Jul 2016 15:23:54 GMT</pubDate>
		<dc:creator>권남</dc:creator>
	</item>
	<item>
		<title><![CDATA[ 동적 Native SQL 생성 어떻게 할까 - 순수 Java 코드로 생성하기 ]]> </title>
		<link>http://kwon37xi.egloos.com/7092965</link>
		<guid>http://kwon37xi.egloos.com/7092965</guid>
		<description>
			<![CDATA[ 
  앞서 <a href="http://kwon37xi.egloos.com/7048211" target="_blank">Freemarker Dynamic QL&nbsp;Builder</a>에 이어, <span style="color:#ff0000;"><strong>순수 Java 코드</strong></span>로 동적 Native SQL/JPQL/HQL을 생성하는 방법에 대한 고민의 결과를 이제서야 공유한다.<br />
<br />
나는 어쩔 수 없이 동적 NativeSQL을 작성해야하는 상황에서라도 MyBatis/iBatis나 Freemarker 같은 외부 템플릿을 사용하는 것을 좋아하지 않는 편이다.<br />
<br />
일단 로직이 없는 정적 SQL의 경우 템플릿을 사용할 이유가 없고, 로직이 존재하는 SQL은 템플릿에서 처리 할 수 없는 로직이 분명히 존재하기 때문에 템플릿과  Java 코드간의 로직 분할이 발생하게 되고 이로인해 로직을 수정해야 할 때 둘 중 한 곳을 간과하여 버그를 만들기 쉬워진다. 또한 Code Coverage 측정이 안 되어 코드에 대한 확신감도 떨어진다.<br />
<br />
MyBatis를 사용한다 해도 가급적 <a href="http://mybatis.org/mybatis-3/ko/statement-builders.html" target="_blank">SQL Builder 클래스</a>를 통해 Java 기반으로 쿼리를 생성하라고 권하고 싶다(물론 이 경우 DBA와의 협업이 어려워지는데, 솔직히  코드 작성하면서 DBA에게 MyBatis XML 얼마나 보여주는지 생각해보면 거의 없을 것이다).<br />
<br />
다음과 같은 순서로 살펴본다.<br />
<br />
<ol><li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html" target="_blank">java.util.StringBuilder</a>를 사용하는 기본적인 방법을 알아보고,</li><li>StringBuilder 기반으로 <a href="https://github.com/kwon37xi/string-builder-ql-params" target="_blank">string-builder-ql-params</a>를 통해 좀 더 쉽게 하는 방법</li><li>아예 StringBuilder를 개선한 <a href="https://github.com/kwon37xi/underscore-builder" target="_blank">UnderscoreStringBuilder</a>라는 것을 통해 처리하는 방법</li><br />
</ol><br />
3번은 사족같은 것이고, 2번까지만 봐도 도움이 많이 될 것 같다.<br />
<br />
<h2>1. StringBuilder로 동적 SQL만들기</h2><br />
<a href="http://kwon37xi.egloos.com/7048211" target="_blank">지난 글</a>에서 말했듯이 동적 SQL 생성의 핵심은 동적으로 쿼리 문자열을 만드는데 있는 것이 아니라 그렇게 만들어진 쿼리에 파라미터를 바인딩(binding)하는 것에 있다.<br />
<br />
동적 문자열 생성은 StringBuilder 만으로도 충분하다. 여기에 보태어 <strong>순서대로 쿼리 파라미터 객체를 저장할 <code>List&lt;Object&gt; params</code> 객체</strong>가 있으면 된다. 아래와 같은 형태가 될 것이다.<br />
<br />
먼저 아래와 같은 데이터 객체들이 존재한다고 하자.<br />
<blockquote class="src">User&nbsp;user&nbsp;=&nbsp;new&nbsp;User();<br />
// User.COLUMNS<br />
public static final String[] COLUMNS = new String[]{"user_id", "name", "email", "birthday", "mobile_phone", "home_phone", "address", "zip_code"};<br />
<br />
user.setUserId(10001L);<br />
user.setName("UnderscoreQlParams");<br />
user.setBirthday(new&nbsp;SimpleDateFormat("yyyy/MM/dd").parse("2015/12/11"));<br />
user.setEmail("someone@email.com");<br />
<br />
List&lt;String&gt;&nbsp;zipCodes&nbsp;&nbsp;=&nbsp;Arrays.asList("12345",&nbsp;"56789",&nbsp;"58391");<br />
</blockquote><br />
이제 이를 가지고 쿼리를 생성하면,<br />
<blockquote class="src">import&nbsp;static&nbsp;org.apache.commons.lang3.StringUtils.isNotEmpty;<br />
import&nbsp;static&nbsp;org.apache.commons.lang3.StringUtils.join;<br />
<br />
StringBuilder&nbsp;sb&nbsp;=&nbsp;new&nbsp;StringBuilder();<br />
<span style="color:#ff0000;"><strong>List&lt;Object&gt;&nbsp;params&nbsp;=&nbsp;new&nbsp;ArrayList&lt;Object&gt;();</strong></span><br />
sb<br />
&nbsp;&nbsp;.append("SELECT&nbsp;")<br />
&nbsp;&nbsp;.append(join(User.COLUMNS,&nbsp;",&nbsp;"))<br />
&nbsp;&nbsp;.append("\n")<br />
&nbsp;&nbsp;.append("FROM&nbsp;users&nbsp;as&nbsp;u\n");<br />
<br />
<strong>sb.append("WHERE&nbsp;1&nbsp;=&nbsp;1");&nbsp;//&nbsp;BUG!!&nbsp;no&nbsp;spaces.</strong><br />
if&nbsp;(user.getUserId()&nbsp;!=&nbsp;null)&nbsp;{<br />
&nbsp;&nbsp;sb.append("AND&nbsp;user_id&nbsp;=&nbsp;?&nbsp;\n");<br />
&nbsp;&nbsp;<span style="color:#ff0000;"><strong>params.add(user.getUserId());</strong></span><br />
}<br />
if&nbsp;(isNotEmpty(user.getName()))&nbsp;{<br />
&nbsp;&nbsp;sb.append("AND&nbsp;name&nbsp;=&nbsp;?&nbsp;\n");<br />
&nbsp;&nbsp;params.add(user.getName());<br />
}<br />
if&nbsp;(user.getBirthday()&nbsp;!=&nbsp;null)&nbsp;{<br />
&nbsp;&nbsp;sb.append("AND&nbsp;birthday&nbsp;=&nbsp;?&nbsp;\n");<br />
&nbsp;&nbsp;params.add(user.getBirthday());<br />
}<br />
// IN Parameter 생성<br />
<strong>if&nbsp;(CollectionUtils.isNotEmpty(zipCodes))&nbsp;{<br />
&nbsp;&nbsp;List&lt;String&gt;&nbsp;inParams&nbsp;=&nbsp;new&nbsp;ArrayList&lt;String&gt;(zipCodes.size());<br />
&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;zipCodes.size();&nbsp;i++)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;inParams.add("?");<br />
&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;sb.append(String.format("AND&nbsp;zip_code&nbsp;IN&nbsp;(%s)",&nbsp;StringUtils.join(inPar",")));<br />
&nbsp;&nbsp;params.addAll(zipCodes);</strong><br />
}<br />
<br />
sb.append("LIMIT&nbsp;10");<br />
</blockquote><br />
<br />
List 하나만 추가해도 그런대로 괜찮은 동적 SQL 생성이 가능해진다. <code>sb.toString()</code>으로 동적으로 생성된 SQL문자열을 가져다가 <code>params</code>에 저장된 각 파라미터 객체를 <code>PreparedStatement.setObject(index, value)</code>(index는 1부터시작)로 저장만 해주면된다. 지금까지 문자열을 더해가며(<code>+</code>) 작업했다면 위 방식으로만 해도 어느정도 괜찮아 진다.<br />
<br />
하지만 위에서 굵은 글씨체로 된 부분을 보면 뭔가 문제가 있음을 알 수 있다.<br />
<br />
<ol><li>Java Code 사이에서 SQL의 가독성이 떨어지다보니 공백 추가를 잠시 잊을 경우 곧바로 잘못된 SQL을 생성하게 된다. 위 쿼리의 경우 조건에 따라 <code>WHERE 1 = 1AND user_id = ?</code> 이렇게 공백없이 붙어버린 잘못된 쿼리가 생성된다.</li><li><code>WHERE</code> 조건에 대해 언제 AND, OR가 올지 몰라 <code>1 = 1</code>로 방어해줘야 한다. 하지만 대부분의 DB는 최적화가 잘 돼서 이로인한 성능저하는 없다고한다. 따라서 이 문제는 사실상 무시해도 된다.</li><li><code>IN</code>조건의 파라미터를 생성하는 것이 굉장히 복잡하다.</li></ol><br />
이제 여기서 첫번째와 두번째 문제는 마지막에 알아보고, 세번째 문제를 해결해보자.<br />
그리고 IN 조건절의 경우 Java 8에서 좀 더 간결하게 만들 수도 있는데, 그에 대해서는 논외로한다.<br />
<br />
<h2>2. StringBuilder 기반으로 <a href="https://github.com/kwon37xi/string-builder-ql-params" target="_blank">string-builder-ql-params</a>를 통해 좀 더 쉽게 하는 방법</h2><br />
위 코드의 <code>List&lt;Object&gt; params</code>에 파라미터를 추가하고 더불어 <code>IN</code> 조건절의 문자열과 파라미터 추가를 좀 더 쉽게 할 수 있는 도우미 클래스를 만들면 쉽게 해결 가능하다. <a href="https://github.com/kwon37xi/string-builder-ql-params" target="_blank">string-builder-ql-params</a>라는 프로젝트에 만들어서 Maven Repository에 올려두었는데, 이 프로젝트 전체를 사용할 필요까진 없고 그냥 <a href="https://github.com/kwon37xi/string-builder-ql-params/blob/master/src/main/java/kr/pe/kwonnam/dynamicql/stringbuilderqlparams/DynamicQlParams.java" target="_blank">DynamicQlParams.java</a>클래스 한개만 복사해 자기 프로젝트에 넣고 사용해도 된다.<br />
<code>DynamicQlParams</code>는 그 안에 파라미터 List객체와 <code>param(Object param)</code>, <code>inParams(Iterable|Object[])</code>, <code>bindParameters(PreparedStatement)</code>,<code>getParameters()</code>등이 있다.<br />
<br />
이 클래스와 <code>StringBuilder</code>를 조합하면 다음과 같이 된다.<br />
<br />
<blockquote class="src">import&nbsp;org.apache.commons.collections4.CollectionUtils;<br />
import&nbsp;org.apache.commons.lang3.StringUtils;<br />
import&nbsp;static&nbsp;java.lang.String.format;<br />
<br />
StringBuilder&nbsp;builder&nbsp;=&nbsp;new&nbsp;StringBuilder();<br />
DynamicQlParams&nbsp;dqp&nbsp;=&nbsp;new&nbsp;DynamicQlParams();<br />
<br />
builder<br />
&nbsp;&nbsp;.append("SELECT&nbsp;")<br />
&nbsp;&nbsp;.append(StringUtils.join(User.COLUMNS,&nbsp;",&nbsp;")).append("\n")<br />
&nbsp;&nbsp;.append("FROM&nbsp;users&nbsp;as&nbsp;u\n")<br />
&nbsp;&nbsp;.append("WHERE&nbsp;1&nbsp;=&nbsp;1\n");<br />
<br />
if&nbsp;(user.getUserId()&nbsp;!=&nbsp;null)&nbsp;{<br />
&nbsp;&nbsp;<strong>builder.append(format("AND&nbsp;user_id&nbsp;=&nbsp;%s&nbsp;%n",&nbsp;dqp.param(user.getUserId())));</strong><br />
}<br />
if&nbsp;(StringUtils.isNotEmpty(user.getName()))&nbsp;{<br />
&nbsp;&nbsp;builder.append(format("AND&nbsp;name&nbsp;=&nbsp;%s&nbsp;%n",&nbsp;dqp.param(user.getName())));<br />
}<br />
if&nbsp;(user.getBirthday()&nbsp;!=&nbsp;null)&nbsp;{<br />
&nbsp;&nbsp;builder.append(format("AND&nbsp;birthday&nbsp;=&nbsp;%s&nbsp;%n",&nbsp;dqp.param(user.getBirthday())));<br />
}<br />
if&nbsp;(CollectionUtils.isNotEmpty(zipCodes))&nbsp;{<br />
&nbsp;&nbsp;<strong>builder.append(format("AND&nbsp;zip_code&nbsp;in&nbsp;(%s)&nbsp;%n",dqp.inParams(zipCodes)));</strong><br />
}<br />
<br />
builder.append("LIMIT&nbsp;").append(dqp.param(10));<br />
<br />
PreparedStatement&nbsp;preparedStatement&nbsp;=&nbsp;conn.prepareStatement(builder.toString());<br />
<strong>dqp.bindParameters(preparedStatement);</strong>&nbsp;//&nbsp;bind&nbsp;parameters&nbsp;to&nbsp;preparedStatement<br />
</blockquote><br />
<br />
<code>DynamicQlParams</code>와 <code>String.format</code>을 조합했더니 좀 더 가독성 좋고 편리하게 동적 SQL을 생성하게 되었다.<br />
이것 말고도 <a href="https://github.com/kwon37xi/string-builder-ql-params/blob/master/src/main/java/kr/pe/kwonnam/dynamicql/stringbuilderqlparams/DynamicNamedQlParams.java" target="_blank">DynamicNamedQlParams</a>도 만들었다. Spring JDBCTempalte과 JPQL, HQL은 Named Parameter를 지원하기 때문이 이를 사용할 수도 있다.<br />
하지만 Named Parameter는 그 자체가 정적 SQL에서 편리한 파라미터 바인딩을 위한 것이지 동적 SQL에서는 불필요한 기능으로 보인다.<br />
<br />
여기서도 사실 구문 사이사이의 공백을 하나라도 잊어버렸을 때의 잘못된 SQL을 생성하는 문제는 해결이 안된 상태이다. 그리고 가독성도 조금만 더 높였으면 좋겠다.<br />
<br />
<h3>3.  StringBuilder를 개선한 <a href="https://github.com/kwon37xi/underscore-builder" target="_blank">UnderscoreStringBuilder</a>를 사용해보기</h3><br />
사실 내가 보기엔 나처럼 정말 어쩌다가 한 두번 동적 NativeSQL을 생성하는 사람은 2번째 방법만 사용해도 괜찮아 보인다. 그래도 학습삼아 좀 오버를 해보았다. 아예 StringBuilder를 대체하는 <a href="https://github.com/kwon37xi/underscore-builder" target="_blank">UnderscoreStringBuilder</a>라는 것을 만들고 거기에 동적 Native SQL생성시 StringBuilder가 가진 단점들들 커버해 줄 수 있는 기능을 넣은 것이다.<br />
아래와 같이 의존성을 추가하고 살펴보도록 하자.<br />
<blockquote class="src">compile&nbsp;'"kr.pe.kwonnam.underscorebuilder:underscore-ql-params:0.1"<br />
</blockquote><br />
<br />
이 프로젝트는 딱 두 개의 핵심 클래스로 이뤄진다. <code>StringBuilder</code>를 대체하는 <a href="https://github.com/kwon37xi/underscore-builder/blob/master/underscore-string-builder/src/main/java/kr/pe/kwonnam/underscore/stringbuilder/UnderscoreStringBuilder.java" target="_blank">UnderscoreStringBuilder</a>와, 2번에서 <code>DynamicQlParams</code>의 역할을 하는 <a href="https://github.com/kwon37xi/underscore-builder/blob/master/underscore-ql-params/src/main/java/kr/pe/kwonnam/underscore/qlparams/UnderscoreQlParams.java" target="_blank">UnderscoreQlParams</a> 클래스이다.<br />
<br />
<code>StringBuilder.append()</code> 역할을 하는 <code>UnderscoreStringBuilder</code>의 핵심 메소드는 <code>__</code> 그 중에서도 아래 메소드 이다.<br />
<blockquote class="src">UnderscoreStringBuilder.__(boolean&nbsp;appendable,&nbsp;A&nbsp;appendee,<br />
&nbsp;&nbsp;&nbsp;UnderscoreTransformer&lt;A&gt;&nbsp;transformer,&nbsp;UnderscoreTransformer&lt;?&nbsp;super&nbsp;CharSequence&gt;...&nbsp;extraTransformers)<br />
</blockquote><br />
왜 이름이 <code><strong>Underscore</strong>StringBuilder</code>인지 알 것 같다. <code>append()</code>보다는 가독성이 좋을 것 같아서 이렇게 했는데, 실제로 그런지는 잘 모르겠다.<br />
<br />
이 메소드에서 <code>appendable,transformer,extraTransformers</code>는 모두 생략가능하다.<br />
<ul><li><code>appendable</code> : <code>appendee</code>를 추가할지 여부</li><li><code>appendee</code> : 문자열에 추가할 객체. 내부적으로 <code>StringBuilder.append()</code> 호출함.</li><li><code>transformer,extraTransformers</code> : <code>appendee</code>를 추가하기 전에 변환 작업을 한다. 지정된 transformer의 순서대로 연달아 변환한다.</li></ul><br />
<br />
<code>UnderscoreQlParams</code>는 여기서 동적 쿼리 생성으로 변환하는 <code>transformer</code> 객체를 생성하고 상태를 저장하는 역할을 한다. 일단 <code>UnderscoreQlParams</code>없이 순수 문자열 기반으로 쿼리를 생성하면 다음과 같은 형태가 된다.<br />
<blockquote class="src"><strong>import static kr.pe.kwonnam.underscore.stringbuilder.UnderscoreStringBuilderTransformers.*;</strong><br />
import static kr.pe.kwonnam.underscore.stringbuilder.transformers.trim.TrimOpts.trimOpts;<br />
import static org.apache.commons.lang3.StringUtils.isNotEmpty;<br />
<br />
UnderscoreStringBuilder&nbsp;=&nbsp;usb&nbsp;=&nbsp;new&nbsp;UnderscoreStringBuilder();<br />
final&nbsp;SimpleDateFormat&nbsp;sdf&nbsp;=&nbsp;new&nbsp;SimpleDateFormat("yyyy-MM-dd&nbsp;HH:mm:ss");<br />
usb<br />
&nbsp;&nbsp;&nbsp;&nbsp;.__("SELECT&nbsp;").<strong>suffixNewLine()</strong><br />
&nbsp;&nbsp;&nbsp;&nbsp;.__(",&nbsp;",&nbsp;join(User.COLUMNS))<br />
&nbsp;&nbsp;&nbsp;&nbsp;.__("FROM&nbsp;users&nbsp;as&nbsp;u")<br />
&nbsp;&nbsp;&nbsp;&nbsp;.sub(user&nbsp;!=&nbsp;null,&nbsp;new&nbsp;UnderscoreSubBuild()&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;subbuild(UnderscoreStringBuilder&nbsp;underscoreSubBuilder)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;underscoreSubBuilder.<strong>prefix("\n&nbsp;&nbsp;&nbsp;&nbsp;"</strong>)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.__(user.getUserId()&nbsp;!=&nbsp;null,&nbsp;<strong>"AND&nbsp;user_id&nbsp;=&nbsp;%d",&nbsp;format(user.getUserId())</strong>)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.__(isNotEmpty(user.getName()),&nbsp;"AND&nbsp;name&nbsp;=&nbsp;'%s'",&nbsp;format(user.getName()))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.__(user.getBirthday()&nbsp;!=&nbsp;null,&nbsp;"AND&nbsp;birthday&nbsp;=&nbsp;'%s'",&nbsp;format(sdf.format(user.getBirthday())))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.__(CollectionUtils.isNotEmpty(zipCodes),&nbsp;<strong>",&nbsp;",&nbsp;join(zipCodes),&nbsp;wrap("AND&nbsp;zip_code&nbsp;in&nbsp;(",&nbsp;")")</strong>);<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;trim(trimOpts().prefix("WHERE&nbsp;").prefixOverrides("AND&nbsp;",&nbsp;"OR&nbsp;")))<br />
&nbsp;&nbsp;&nbsp;&nbsp;.__("LIMIT&nbsp;10");<br />
</blockquote><br />
<br />
<code>UnderscoreStringBuilderTransformers</code>는 각종 <code>UnderscoreTransformer</code> 객체를 쉽게 생성해주는 static method가 있는 클래스이다. 미리 준비한 transformer들은 <code>format, dateFormat, join, wrap, multiply, trim</code>등이다.<br />
위 코드는 파라미터 바인딩이 필요없는 일반 SQL 문자열을 생성한 것이고, 진짜 목표인 <code>?</code> 혹은 <code>?1,?2,...</code> 기반의 PreparedStatement 지원 동적 SQL을 생성해보면 다음과 같은 형태가 된다.<br />
<blockquote class="src">import static kr.pe.kwonnam.underscore.stringbuilder.UnderscoreStringBuilderTransformers.join;<br />
import static kr.pe.kwonnam.underscore.stringbuilder.UnderscoreStringBuilderTransformers.trim;<br />
import static kr.pe.kwonnam.underscore.stringbuilder.transformers.trim.TrimOpts.trimOpts;<br />
import static org.apache.commons.lang3.StringUtils.isNotEmpty;<br />
<br />
UnderscoreStringBuilder&nbsp;usb&nbsp;=&nbsp;new&nbsp;UnderscoreStringBuilder();<br />
UnderscoreQlParams&nbsp;qlParams&nbsp;=&nbsp;new&nbsp;UnderscoreQlParams();<br />
usb<br />
&nbsp;&nbsp;&nbsp;&nbsp;.__("SELECT&nbsp;")<strong>.suffixNewLine()</strong><br />
&nbsp;&nbsp;&nbsp;&nbsp;.__(<strong>",&nbsp;",&nbsp;join(User.COLUMNS)</strong>)<br />
&nbsp;&nbsp;&nbsp;&nbsp;.__("FROM&nbsp;users&nbsp;as&nbsp;u")<br />
&nbsp;&nbsp;&nbsp;&nbsp;<strong>.sub(user&nbsp;!=&nbsp;null,&nbsp;new&nbsp;UnderscoreSubBuild()</strong>&nbsp;{ // user != null일 때만 아래 블럭이 실행되고 문자열과 파라미터 추가됨.<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;subbuild(UnderscoreStringBuilder&nbsp;underscoreSubBuilder)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;underscoreSubBuilder.<strong>prefix("\n&nbsp;&nbsp;&nbsp;")</strong><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.__(user.getUserId()&nbsp;!=&nbsp;null,<strong>&nbsp;"AND&nbsp;user_id&nbsp;=&nbsp;%s",&nbsp;qlParams.params(user.getUserId())</strong>)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.__(isNotEmpty(user.getName()),&nbsp;"AND&nbsp;name&nbsp;=&nbsp;%s",&nbsp;qlParams.params(user.getName()))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.__(user.getBirthday()&nbsp;!=&nbsp;null,&nbsp;"AND&nbsp;birthday&nbsp;=&nbsp;%s",&nbsp;qlParams.params(user.getBirthday()))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.__(CollectionUtils.isNotEmpty(zipCodes),&nbsp;<strong>"AND&nbsp;zip_code&nbsp;in&nbsp;(%s)",&nbsp;qlParams.inParams(zipCodes)</strong>);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;trim(trimOpts().prefix("WHERE&nbsp;").prefixOverrides("AND&nbsp;",&nbsp;"OR&nbsp;")))<br />
&nbsp;&nbsp;&nbsp;&nbsp;.__("LIMIT&nbsp;%s",&nbsp;qlParams.params(10));<br />
<br />
log.info("UnderscoreStringBuilder with UnderscoreQlParams : {}", <strong>usb.toString()</strong>); // 생성된 SQL<br />
log.info("Query Parameters : {}", <strong>qlParams.getQueryParameters()</strong>); // 바인딩할 Parameters<br />
</blockquote><br />
<br />
<code>params, inParams</code>는 내부적으로 <code>String.format</code>을 호출한다. 따라서 앞에 추가할 문자열도 포맷팅 문자열로 만들어줘야 한다. 간단하다. <span style="color:#ff0000;"><strong>파라미터 바인딩 물음표가 들어갈 부분을 <code>%s</code>로 해주기만 하면 된다</strong></span>.<br />
<br />
<code>UnderscoreStringBuilder.prefix()|suffix()</code>는 <code>prefixOff()|suffixOff()</code>가 호출될 때까지 모든 문자열 덧붙이기 할 때마다 지정된 문자열을 앞/뒤에 붙여준다. 이를 통해 공백을 까먹어서 생기는 문제를 해소해준다.<br />
그리고 <code>trim transformer</code>를 통해 MyBatis <code>&lt;trim&gt;</code>와 동일한 효과를 낼 수 있게 하였다.<br />
<code>sub</code> 부분은 Java 8 Lambda를 사용하면 좀 더 간결해진다.<br />
<br />
지금까지 생성된 쿼리를 보여준 적이 없는데, log 출력 내용은 다음과 같다.<br />
<br />
<blockquote class="src">UnderscoreStringBuilder&nbsp;with&nbsp;UnderscoreQlParams&nbsp;:&nbsp;SELECT&nbsp;user_id,&nbsp;name,&nbsp;email,&nbsp;birthday,&nbsp;mobile_phone,&nbsp;home_phone,&nbsp;address,&nbsp;zip_code<br />
FROM&nbsp;users&nbsp;as&nbsp;u<br />
WHERE&nbsp;user_id&nbsp;=&nbsp;?<br />
&nbsp;&nbsp;&nbsp;AND&nbsp;name&nbsp;=&nbsp;?<br />
&nbsp;&nbsp;&nbsp;AND&nbsp;birthday&nbsp;=&nbsp;?<br />
&nbsp;&nbsp;&nbsp;AND&nbsp;zip_code&nbsp;in&nbsp;(?,&nbsp;?,&nbsp;?)<br />
LIMIT&nbsp;?<br />
<br />
Query&nbsp;Parameters&nbsp;:&nbsp;[10001,&nbsp;UnderscoreQlParams,&nbsp;Fri&nbsp;Dec&nbsp;11&nbsp;00:00:00&nbsp;KST&nbsp;2015,&nbsp;12345,&nbsp;56789,&nbsp;58391,&nbsp;10]<br />
</blockquote><br />
<br />
코드를 보면 맨 위에서 도출했던 세가지 문제가 일단은 다 해결된 것을 볼 수 있다.<br />
<br />
JPQL/HQL의 <code>?1, ?2, ..</code> 형태로 쿼리를 생성하고자 한다면 <code>UnderscoreQlParams.withPositionalIndex()</code>를 사용하면 된다.<br />
<br />
사실 다 만들어놓고 보니 굳이 이렇게까지 해야하나 싶긴한데, 만드는 과정 자체가 학습이 많이 되어서 만족한다.<br />
<br/><br/>tag : <a href="/tag/java" rel="tag">java</a>,&nbsp;<a href="/tag/sql" rel="tag">sql</a>,&nbsp;<a href="/tag/query" rel="tag">query</a>,&nbsp;<a href="/tag/jpql" rel="tag">jpql</a>,&nbsp;<a href="/tag/hql" rel="tag">hql</a>,&nbsp;<a href="/tag/native" rel="tag">native</a>,&nbsp;<a href="/tag/dynamic" rel="tag">dynamic</a>			 ]]> 
		</description>
		<category>프로그래밍</category>
		<category>java</category>
		<category>sql</category>
		<category>query</category>
		<category>jpql</category>
		<category>hql</category>
		<category>native</category>
		<category>dynamic</category>

		<comments>http://kwon37xi.egloos.com/7092965#comments</comments>
		<pubDate>Sat, 02 Jan 2016 07:07:00 GMT</pubDate>
		<dc:creator>권남</dc:creator>
	</item>
	<item>
		<title><![CDATA[ 동적 Native SQL 생성 어떻게 할까 - Freemarker Dynamic QL Builder ]]> </title>
		<link>http://kwon37xi.egloos.com/7048211</link>
		<guid>http://kwon37xi.egloos.com/7048211</guid>
		<description>
			<![CDATA[ 
  나는 ORM 그중에서 JPA/<a href="http://hibernate.org/" target="_blank">Hibernate</a>를 주로 사용하는 사람이다.<br />
<br />
작년 이맘때쯤 꽤 오래된 DB 구조에 iBatis로 만들어진 프로젝트를 JPA로 전환하는 작업을 했는데, 그 와중에 딱 한 개의 쿼리가 도저히 Native SQL을 사용하지 않으면 안되는데, 게다가 매우 동적이라 WHERE 조건문이 10여개 이상의 값의 상태에 따라 달라지게 구성되었다.<br />
<br />
이 상황에서는 딱히 방법이 없어 문자열 조합으로 동적 Native SQL을 생성해서 JPA의 Native Query 기능으로 해결했다(JPA/Hibernate는 쿼리 실행은 Native SQL로 해도 그 결과를 JPA Entity로 받을 수 있다).<br />
나 같은 경우에는 Native SQL로 실행하더라도 가급적 Entity로 결과를 받도록 하며, 그럴 펼요가 없는 경우의 쿼리는 그냥 Spring JdbcTemplate 같은 것을 사용한다.<br />
<br />
이 프로젝트를 겪으면서 수 많은 종류의 쿼리 중에서 Native SQL은 단 한 개만 필요했다(호출량은 별개의 문제이다). 많은 사람들이 Legacy DB에 ORM을 적용하면 Native SQL을 사용할 일이 엄청 많을 것이라고 지레 짐작하는데 실제로 해보면 별로 그렇지 않다. <strong>현재까지 우리 회사에서 진행된 프로젝트들을 보면 Native SQL이 필요한 경우는 1% 미만</strong>이거나 아예 Native SQL을 사용하지 않는 프로젝트도 있는 것으로 보인다.<br />
<br />
어쨌든, 매우 동적인 Native SQL이 필요한 상황이 온다고 했을 때, iBatis/MyBatis 없이 현재 있는 솔루션(보통은 JPA/Hibernate와 Spring 기반 프로젝트의 경우 Spring JdbcTemplate이 기본으로 갖춰져 있다)으로 처리하고자 할 때 최대 방해요소는 문자열 연결로 난잡하기 짝이 없는 SQL을 생성해야 하는 것이다.<br />
<br />
비록 확률은 적더라 이 문제를 근본적으로 해결하고, 혹여나 Legacy DB를 JPA/Hibernate로 전환하는 작업을 하는 사람들의 불안을 좀 없애줄 수 있는 방안을 1년 전부터 두가지 정도 구상했고 그 중 2번째 안을 무려 1년만에 먼저 구현했다(실제 핵심 logic 구현은 이틀 정도 밖에 안 걸리는 거였다.... 귀차니즘을 극복해야해..).<br />
<br />
바로 <a href="http://freemarker.incubator.apache.org/" target="_blank">Freemarker</a>로 동적 SQL을 생성하는 것이다. Freemarker는 특정 포맷에 치우치지 않은 Java의 초강력 범용 문자열 템플릿 처리 엔진이다. MyBatis나 iBatis와는 비할바 없이 강력한 템플릿 기능을 지원한다. 동적으로 SQL 문자열 생성하는데 이보다 더 좋은게 있을까? 그리고 MyBatis가 갖는 장점-DBA와 협업할 때 파일 전달이 편하다는 점도 함께 이를 선택하게 하는데 작용했다.<br />
<br />
<br />
이를 사용하여 <a href="https://github.com/kwon37xi/freemarker-dynamic-ql-builder" target="_blank">Freemarker Dynamic QL Builder</a>라는 것을 만들었다.<br />
<ul><li><a href="https://github.com/kwon37xi/freemarker-dynamic-ql-builder" target="_blank">Freemarker Dynamic QL Builder</a></li><li><a href="https://github.com/kwon37xi/freemarker-dynamic-ql-builder/wiki/GettingStarted_KO">Freemarker Dynamic QL Builder 시작하기</a> : 그냥 이 문서로 점프해서 보는 것이..</li></ul>이를 통해 다음과 같은 QL 템플릿(<code>'users/select.ql.ftl'</code>)을 만들고<br />
<br />
<blockquote class="src">SELECT&nbsp;*<br />
FROM&nbsp;somewhere<br />
<b>&lt;@ql.where&gt;</b><br />
&nbsp;&nbsp;&nbsp;&nbsp;&lt;#if&nbsp;user.name?has_content&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;<font color="#ff0000"><b>${param(user.name)}</b></font><br />
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/#if&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&lt;#if&nbsp;user.birthyear&nbsp;gt&nbsp;0&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;AND&nbsp;birthyear&nbsp;=&nbsp;<font color="#ff0000"><b>${param(user.birthyear)}</b></font><br />
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/#if&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&lt;#if&nbsp;user.employeeType??&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;AND&nbsp;employeeType&nbsp;=&nbsp;<b><font color="#ff0000">${param(user.employeeType,&nbsp;'enumToName')}</font></b><br />
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/#if&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&lt;#list&nbsp;userIds!&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;AND&nbsp;userId&nbsp;IN&nbsp;(&lt;#items&nbsp;as&nbsp;userId&gt;<font color="#ff0000"><b>${param(userId)}</b></font>&lt;#sep&gt;,&lt;/#sep&gt;&lt;/#items&gt;)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/#list&gt;<br />
<b>&lt;/@ql.where&gt;</b><br />
<br />
ORDER&nbsp;BY&nbsp;userId<br />
LIMIT&nbsp;10</blockquote><br />
<br />
파라미터가 될 객체들을 넘겨서 실행해보면(iBatis/MyBatis 사용자들은 <strong>FreemarkerDynamicQlBuilder</strong>를 쿼리를 실행만 안하는 <code>SqlMapClient</code>라고 생각해보자)<br />
<blockquote class="src">FreemarkerDynamicQlBuilder&nbsp;dynamicQlBuilder&nbsp;=&nbsp;....;<br />
<br />
User&nbsp;user&nbsp;=&nbsp;new&nbsp;User();<br />
user.setName("");&nbsp;//&nbsp;empty&nbsp;on&nbsp;purpose<br />
user.setBirthyear(2015);<br />
user.setEmployeeType(EmployeeType.FULLTIME);<br />
<br />
Map&lt;String,Object&gt;&nbsp;dataModel&nbsp;=&nbsp;new&nbsp;HashMap&lt;String,Object&gt;();<br />
dataModel.put("user",&nbsp;user);<br />
dataModel.put("userIds",&nbsp;new&nbsp;int[]{100,&nbsp;200,&nbsp;300});<br />
<br />
<b>DynamicQuery&nbsp;dynamicQuery&nbsp;= dynamicQlBuilder.buildQuery("users/select",&nbsp;dataModel);</b><br />
//&nbsp;dynamicQuery&nbsp;에&nbsp;생성된&nbsp;QL과&nbsp;파라미터&nbsp;목록이&nbsp;들어&nbsp;있다.<br />
</blockquote><br />
<br />
여기서 dynamicQuery 객체를 살펴보면 아래와 같은 프라퍼티들이 생성돼 있다.<br />
<blockquote class="src">dynamicQuery.<strong>getQueryString()</strong><br />
==&gt;&nbsp;String<br />
<strong>"SELECT&nbsp;*<br />
FROM&nbsp;somewhere<br />
WHERE&nbsp;birthyear&nbsp;=&nbsp;?<br />
&nbsp;&nbsp;&nbsp;&nbsp;AND&nbsp;employeeType&nbsp;=&nbsp;?<br />
&nbsp;&nbsp;&nbsp;&nbsp;AND&nbsp;userId&nbsp;IN&nbsp;(?,?,?)<br />
ORDER&nbsp;BY&nbsp;userId<br />
LIMIT&nbsp;10"</strong><br />
<br />
dynamicQuery.<strong>getParameters()</strong><br />
==&gt;&nbsp;<strong>List&lt;Object&gt;&nbsp;:&nbsp;[2015,&nbsp;FULLTIME,&nbsp;100,&nbsp;200,&nbsp;300]</strong>&nbsp;<br />
<br />
dynamicQuery.<strong>getQueryParameterArray()</strong><br />
==&gt;&nbsp;<strong>Object[]&nbsp;:&nbsp;[2015,&nbsp;FULLTIME,&nbsp;100,&nbsp;200,&nbsp;300]</strong>&nbsp;<br />
</blockquote><br />
<br />
이 결과를 보면 동적으로 SQL을 생성해줄 뿐만 아니라, PreparedStatement 파라미터 바인딩에 필요한 값들을 리스트와 배열로 순서대로 저장해서 넘겨주는 것을 볼 수 있다.<br />
이렇게 생성된 SQL과 파라미터는 다음과 같이 PreparedStatement로 실행하거나 Spring JdbcTemplate, <a href="http://jdbi.org/" target="_blank">JDBI</a>, JPA, Hibernate 등의 JDBC 실행/객체 매핑 프레임워크를 통해 실행하면 된다.<br />
<blockquote class="src">PreparedStatement&nbsp;psmt&nbsp;=&nbsp;connection.prepareStatement(dynamicQuery.getQueryString());<br />
dynamicQuery.<b>bindParameters(psmt);</b><br />
<br />
ResultSet&nbsp;rs&nbsp;=&nbsp;psmt.executeQuery();<br />
// 쿼리 결과 처리<br />
</blockquote><br />
<br />
<strong><span style="font-size:130%;">${param(변수)}</span></strong><br />
Freemarker 템플릿을 보고 한 방에 눈치채신 분들도 있을 것 같은데, 동적인 쿼리 생성의 핵심은 문자열이 동적으로 생기는 것에 있는 것이 아니라는 점이다. 그렇게 동적으로 생성된 문자열 중 PreparedStatement 파라미터로 지정되어야 할 위치는 물음표(?)로 대체하고, 해당 물음표에 들어갈 실제 쿼리 파라미터를 순서대로 모아주는 것이 진짜 핵심이다.<br />
<br />
그리고 그 핵심적인 역할을 하는 것이 바로 <strong>${param(변수)}</strong>라는 이 프리마커 메소드의 역할이다. 이 메소드를 호출하면 그 부분은 물음표(?)로 문자열이 바뀌고 거기 지정한 변수는 순서대로 List에 저장되어 마지막에 전체 파라미터 List를 순서대로 얻을 수 있게 되는 것이다.<br />
사실상 내가 구현한 것의 핵심은 이 ParamMethod 클래스 하나가 다이고, 나머지는 모두 부차적인 것들이라고 봐도 된다.<br />
<br />
<strong><span style="font-size:130%;">&lt;@ql.trim&gt;,&nbsp;&lt;@ql.when&gt;,&nbsp;&lt;@ql.set&gt;</span></strong><br />
MyBatis에 있는 템플릿 지시자들 중 SQL <code>WHERE, SET</code> 생성에 도움을 주는 <code>&lt;trim&gt;,&lt;where&gt;,&lt;set&gt;</code> 을 흉내낸 Freemarker 지시자를 만들었다. <code>&lt;foreach&gt;</code>는 프리마커가 이미 문법적으로 더 깔끔하게 지원하기 때문에 제외했다.<br />
<br />
<strong><span style="font-size:130%;">ParameterConverter</span></strong><br />
Legacy iBatis 프로젝트를 JPA로 전환하면서 나를 제일 당황케 한 것은 마로 매핑 객체에 있는 <strong>String의 향연</strong>이다.<br />
Legacy DB의 컬럼들 중 많은 것들이 boolean을 문자열 "Y"/"N"으로 표현하고 날짜는 "20151126" 형태의 문자열로 돼 있다.<br />
enum을 넣을 수 있지만, iBatis가 enum을 자동으로 문자열로 안바꾸는지 대부분 enum없이 그냥 일반 String으로 필드가 지정돼 있다. 이로 인해 문서를 보기 전에는 도대체 해당 필드에 유효한 값이 무엇인지 알수가 없다. 이런 특징으로 인해 코드의 아주 많은 부분이 문자열을 boolean, Date, enum 등의 타입으로 변환하고 또 역변환하는 것들로 채워져 있었다. 물론 변환시의 오류처리도 꼼꼼하게 하지 않으면...<br />
<br />
JPA/Hibernate 는 Custom Type Converting 기능이 있기 때문에 여러 종류의 Java 객체를 DB 컬럼에 자유롭게 매핑할 수 있다. 그래서 Entity 객체가 올바른 Java 타입의 필드들로 자연스럽게 활용 가능하다.<br />
<br />
올바른 Java 타입을 쉽게 사용하려면 동적 SQL을 생성했다 하더라도 거기에 파라미터로 바인딩되는 Java 객체를 DB Column에 맞게 변환해줄 필요가 있다. 이러한 역할을 하는 ParameterConverter라는 개념을 만들어서 이 문제를 넘어가게 했다. 이를 사용하면 Java Date 객체를 문자열로 변경해서 파라미터로 저장 한다던가 boolean을 "Y"/"N" 혹은 "T"/"F" 같은 것으로, 그 외에 JodaTime 같은 것으로 생성한 날짜 객체를 java.sql.Date 로 변환한다던가하는 일을 할 수 있게 된다.<br />
위 FTL에서 <code>${param(user.employeeType, <strong>'enumToName'</strong>)}</code> 이 부분이 파라미터 컨버터로 enum을 문자열로 변환한 것이다.<br />
<br />
자세한 것은 문서를 참조하면 된다.<br />
<br />
<strong><span style="font-size:130%;">QL Builder?</span></strong><br />
왜 SQL Builder가 아니고 <strong>QL</strong> Builder일까?<br />
SQL뿐만 아니라 JPQL(JPA), HQL(Hibernate)도 생성 가능하기 때문이다. JPQL의 <code>?1, ?2, ...</code> 형태의 Positional Parameter 생성에 대해서는 문서를 참조한다.<br />
<br />
<strong><span style="font-size:130%;">주의점</span></strong><br />
앞서 Freemarker가 매우 강력하다고 했는데, 사실 나는 그런 이유로(그리고 기타 다른 몇가지 이유로) Freemarker를 HTML 템플릿 엔진으로는 사용하지 않는다.<br />
<br />
프로그래밍 언어 코드가 아닌 특히 서버 프로그래머가 아닌 사람들과 함께 소통해야 하는 영역에 과도한 로직은 Unit Test 등도 사실상 불가능하게 만들고  유지보수성을 현저히 떨어뜨리게 된다.<br />
<br />
따라서 Freemarker가 아무리 강력해도 지나치게 로직을 많이 사용하지는 않는 것이 좋다.<br />
<br />
그에 반해 Freemarker의 include 같은 기능을 통해 column 목록 같은 반복되는 데이터를 따로 빼서 저장해놓고 include 하는식으로 개발하는 것도 가능하니 활용처를 찾아보는 것도 좋을 것 같다.<br />
<br />
마지막으로, 이것을 만든 이유는 자유롭게 Native SQL을 사용하기 위해서가 아니다. 단순히 MyBatis의 1:1 대체재로 이를 사용하는 것은 좋지 않다고 본다. <strong>가급적 ORM을 사용하고 ORM의 보완책으로 어쩔 수 없을 때만 사용하길 바란다.</strong><br />
<br />
조만간 원래 구상했던 1안도 구현해야겠다.<br />
<br />
- <a href="https://github.com/kwon37xi/freemarker-dynamic-ql-builder" target="_blank">Freemarker Dynamic QL Builder</a><br />
- <a href="https://github.com/kwon37xi/freemarker-dynamic-ql-builder/wiki/GettingStarted_KO">Freemarker Dynamic QL Builder 시작하기</a><br />
<br />
원래 구상했던 1안 - <a href="http://kwon37xi.egloos.com/7092965" target="_blank">동적 Native SQL 생성 어떻게 할까 - 순수 Java 코드로 생성하기</a><br/><br/>tag : <a href="/tag/java" rel="tag">java</a>,&nbsp;<a href="/tag/freemarker" rel="tag">freemarker</a>,&nbsp;<a href="/tag/sql" rel="tag">sql</a>,&nbsp;<a href="/tag/query" rel="tag">query</a>,&nbsp;<a href="/tag/mybatis" rel="tag">mybatis</a>,&nbsp;<a href="/tag/ibatis" rel="tag">ibatis</a>,&nbsp;<a href="/tag/jpa" rel="tag">jpa</a>,&nbsp;<a href="/tag/hibernate" rel="tag">hibernate</a>,&nbsp;<a href="/tag/spring" rel="tag">spring</a>,&nbsp;<a href="/tag/jdbctemplate" rel="tag">jdbctemplate</a>			 ]]> 
		</description>
		<category>프로그래밍</category>
		<category>java</category>
		<category>freemarker</category>
		<category>sql</category>
		<category>query</category>
		<category>mybatis</category>
		<category>ibatis</category>
		<category>jpa</category>
		<category>hibernate</category>
		<category>spring</category>
		<category>jdbctemplate</category>

		<comments>http://kwon37xi.egloos.com/7048211#comments</comments>
		<pubDate>Thu, 26 Nov 2015 15:44:11 GMT</pubDate>
		<dc:creator>권남</dc:creator>
	</item>
	<item>
		<title><![CDATA[ Java 에서 DataBase Replication Master/Slave (write/read) 분기 처리하기 ]]> </title>
		<link>http://kwon37xi.egloos.com/5364167</link>
		<guid>http://kwon37xi.egloos.com/5364167</guid>
		<description>
			<![CDATA[ 
  대규모 서비스 개발시에 가장 기본적으로 하는 튜닝은 바로 데이터베이스에서 Write와 Read DB를 Replication(리플리케이션)하고 쓰기 작업은 Master(Write)로 보내고 읽기 작업은 Slave(Read)로 보내어 부하를 분산 시키는 것이다.<br />
<br />
특히 대부분의 서비스는 읽기가 압도적으로 많기 때문에&nbsp; Slave는 여러 대를 두어 읽기 부하를 분산 시킨다.<br />
그런데 또 하나 기억해야 할 것이 Replication은 비록 짧더라도 시차를 두고 이루어 지는 것이다.<br />
따라서 <b>정합성이 굉장히 중요한 데이터는 비록 읽기 작업이라 하더라도 Slave에서 읽지 않고 Master에서 읽어야만 하는 경우도 있다.</b><br />
<br />
그렇다면 Java 애플리케이션은 어떻게 Master/Slave로 가는 쿼리를 분기 처리해야 하는 것일까?<br />
<br />
가장 쉽게 생각나는 방법은 커넥션 풀(Connection Pool, DataSource)을 master와 slave용으로 따로 만들고 쿼리를 만들 때 비록 같은 쿼리라도 서로 다른 DS를 바라보는 두 벌의 쿼리를 만들어주는 방식이다.<br />
즉, 프로그래머가 계속해서 두 개의 데이터 소스를 인지해가며 코드를 작성하는 방식이다.<br />
<br />
물론 이 방법을 추천하고 싶어서 글을 쓰는 것은 아니다. 이 방법은 버리자.<br />
<br />
내가 아는 바 저렇게 하지 않고 자연스럽게 Master/Slave 분기처리를 하는 4 가지 정도의 방법이 있는데, 그 중에 실제로 소개하고 싶은 것은 3, 4 번째이다. 시간 없으면 3, 4번을 읽기를 바란다.<br />
<br />
<strong><span style="font-size:130%;">1. DB Proxy 서버를 이용한다.</span></strong><br />
<br />
<a target="_blank" href="http://dev.mysql.com/doc/mysql-proxy/en/">MySQL Proxy</a>이나 <a target="_blank" href="https://mariadb.com/products/mariadb-maxscale">MaxScale</a> 같은 프록시 서버를 사용하는 방법이 있다(MySql 외에도 다른 데이터베이스도 Proxy 서버가 있다). 이런 프록시 서버들은 쿼리를 분석하여 select는 slave로 그 외의 업데이트는 master로 자동으로 보내준다. 문제는 select 더라도 master로 보낼 때 인데, 프록시 서버 자체에 스크립트 언어로 분기 처리를 해주는 것이 있다.<br />
보통은 PHP 같은 동적 언어 계통에서 많이 사용하는 방법 같다.<br />
일단 나는 프록시를 이런 분기 처리 용도로 사용해 본 적이 없어서 뭐라 말하기 힘들고, 분기 처리를 애플리케이션 단에서 조정하지 않고 관련 로직이 애플리케이션과 Proxy 서버로 분산 되는 문제가 있을 것으로 보여서 배재한다.<br />
<br />
3, 4 번은 순수 Java 코드로 분기 처리하는 방법을 소개하는 것이다.<br />
<br />
<strong><span style="font-size:130%;">◆ 2, 3, 4를 가기 전에 알아보는 Java의 특징</span></strong><br />
<br />
Java의 JDBC 커넥션 객체에는 <a target="_blank" href="http://docs.oracle.com/javase/7/docs/api/java/sql/Connection.html#setReadOnly%28boolean%29">Connection.setReadOnly(true|false)</a> 라는 메소드가 존재한다.<br />
즉, Java 의 JDBC 에는 Read/Write를 분기할 수 있는 단초가 이미 들어있는 것이다.<br />
<br />
현재 Java의 주류 프레임워크인 <a target="_blank" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/transaction.html">Spring Framework을 사용하여 트랜잭션을 관리</a>하면 <b><code>@Transactional(readOnly=true|false)</code></b>를 통해 현재 트랜잭션의 readOnly 상태를 설정할 수 있으며, 이 <b>Spring의 트랜잭션 설정은 연쇄적으로 커넥션 객체의 <code>setReadOnly</code>메소드를 호출</b>하기도 한다.<br />
바로 이 점이 Java 애플리케이션에서 외부 Proxy 서버에 의존하지 않고 애플리케이션 코드를 통해 Master/Slave 분기 처리를 할 수 있는 단초가 된다.<br />
<br />
앞으로보게 될 2, 3, 4번 해결책은 Spring 사용시 다음과 같은 방식만으로 Master/Slave 분기를 할 수 있게 해준다.<br />
<blockquote class="src">@Transactional(<strong>readOnly&nbsp;=&nbsp;true</strong>)<br />
public&nbsp;User&nbsp;findByIdRead(Integer&nbsp;id)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;userRepository.findById(id);<br />
}<br />
<br />
@Transactional(<strong>readOnly&nbsp;=&nbsp;false</strong>)<br />
public&nbsp;User&nbsp;findByIdWrite(Integer&nbsp;id)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;userRepository.findById(id);<br />
}</blockquote><br />
위에서 볼 때 두 메소드는 동일한 repository의 메소드를 호출하지만 서로 다른 DB를 자연스럽게 보게 되는 것이다.<br />
위 코드는 다소 인위적인 것이다. 서비스는 보통 여러 개의 리포지토리 메소드를 한 트랜잭션으로 묶기 때문이다.<br />
<br />
아래에서 소개할 2, 3, 4 번은 프로그래머 입장에서 봤을 때 데이터소스는 신경쓰지 않고 <b>오로지 Transaction의 속성 만을 신경 써가며 작성</b>하는 방법이다. 즉, 프로그래머는 실제 설정은 두 개로 되어 있더라도 <b>데이터소스가 한 개뿐이라고 생각하고 코드를 짜면 </b>된다. 또한&nbsp; Hibernate나 MyBatis 등의 <b>영속 계층 프레임워크도 데이터소스가 2개라는 사실은 전혀 인지하지 않고 하나의 데이터소스로 간주하고 설정</b>을 하게 된다.<br />
<br />
Connection의 readOnly는 <strong>기본 설정값이 false</strong>이다.<br />
<br />
<strong><span style="font-size:130%;">2. MySQL Replication JDBC Driver 사용하기</span></strong><br />
<br />
<a target="_blank" href="http://kwonnam.pe.kr/wiki/database/mysql/jdbc#replication_jdbc_driver">MySQL에는 Replication JDBC 드라이버</a>가 존재한다. 이를 이용하면 <code>Connection.setReadOnly(true|false)</code> 호출만으로 Master/Slave 분기 처리가 된다.<br />
<br />
실전 환경에서 사용해보았는데, 몇 가지 문제가 발생했다. 하지만 모두 해결 가능했으며, 크게 치명적인 문제는 아니었다.<br />
<br />
그래도 가능하면 3, 4번 해결책을 사용하는 것이 좋겠다.<br />
<br />
왜냐면, 이 방식은 MySQL 외에는 적용되지 않는다. Replication JDBC 드라이버를 제공해주는 DB는 그리 많지 않다(사실 나는 MySQL 밖에 못봤다).<br />
그리고 굳이 더 나은 방식이 있는데 안 좋은 방식을 사용할 필요는 없기 때문이다.<br />
<br />
<strong><span style="font-size:130%;">3. Spring LazyConnectionDataSourceProxy + AbstractRoutingDataSource</span></strong><br />
<br />
Spring에 있는 <a target="_blank" href="http://kwonnam.pe.kr/wiki/springframework/abstractroutingdatasource">AbstractRoutingDataSource</a> 는 여러개의 데이터소스를 하나로 묶고 자동으로 분기처리를 해주는 Spring 기본 클래스이다. 많은 사람들이 Master/Slave 분기 처리를 할 때 이것을 사용해 스프링의 현재 트랜잭션 속성을 읽어오는 <a target="_blank" href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/support/TransactionSynchronizationManager.html">TransactionSynchronizationManager</a>와 조합하여 분기처리 하려고 시도하는데 이건 실패다(<a href="http://stackoverflow.com/" target="_blank">http://stackoverflow.com/</a>에 보면 이거 왜 안되냐는 질문이 좀 있다).<br />
<br />
<a target="_blank" href="https://github.com/kwon37xi/replication-datasource/blob/master/src/test/java/kr/pe/kwonnam/replicationdatasource/routingdatasource/ReplicationRoutingDataSource.java">ReplicationRoutingDataSource.java</a>에 그 구현이 있는데, 너무도 간단하다.<br />
<blockquote class="src">public&nbsp;class&nbsp;ReplicationRoutingDataSource&nbsp;extends&nbsp;AbstractRoutingDataSource&nbsp;{<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;@Override<br />
&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;Object&nbsp;determineCurrentLookupKey()&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;dataSourceType&nbsp;=<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>TransactionSynchronizationManager.isCurrentTransactionReadOnly()</strong>&nbsp;?&nbsp;"read"&nbsp;:&nbsp;"write";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;dataSourceType;<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
}</blockquote><br />
왜 안되냐면, <a target="_blank" href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/support/TransactionSynchronizationManager.html">TransactionSynchronizationManager</a> 가 비록 <code>@Transactional</code>로 선언된 현재 쓰레드의 트랜잭션 상태를 읽어오는게 가능하더라도 동기화(synchronation)시점과 Connection 객체를 가져오는 시점에 문제가 있기 때문이다.<br />
<br />
Spring은 <code>@Transactional</code>을 만나면 다음 순서로 일을 처리한다.<br />
<br />
<strong>TransactionManager 선별 -&gt; DataSource에서 Connection 획득 -&gt; Transaction 동기화(Synchronization)</strong><br />
<br />
여기서 보면 트랜잭션 동기화를 마친 뒤에 <a target="_blank" href="https://github.com/kwon37xi/replication-datasource/blob/master/src/test/java/kr/pe/kwonnam/replicationdatasource/routingdatasource/ReplicationRoutingDataSource.java">ReplicationRoutingDataSource.java</a>에서 커넥션을 획득해야만 이게 올바로 동작하는데 그 순서가 뒤바뀌어 있기 때문이다.<br />
나는 여기까지 보고 포기하고 바로 4번 방식을 구현하였는데, 우리팀의 이은호님이 아주 심플한 아이디어로 이 문제를 해결 했다. 코드 한 줄 없이!<br />
<br />
뭐냐면 저 <b><a target="_blank" href="https://github.com/kwon37xi/replication-datasource/blob/master/src/test/java/kr/pe/kwonnam/replicationdatasource/routingdatasource/ReplicationRoutingDataSource.java">ReplicationRoutingDataSource.java</a>를 <a target="_blank" href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/datasource/LazyConnectionDataSourceProxy.html">LazyConnectionDataSoruceProxy</a>로 감싸주기만 하면</b> 되는 것이다.<br />
<br />
원래 <a target="_blank" href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/datasource/LazyConnectionDataSourceProxy.html">LazyConnectionDataSoruceProxy</a>는 실질적인 쿼리 실행 여부와 상관없이 트랜잭션이 걸리면 무조건 Connection 객체를 확보하는 Spring의 단점을 보완하여 트랜잭션 시작시에 Connection Proxy 객체를 리턴하고 실제로 쿼리가 발생할 때 데이터소스에서 <code>getConnection()</code>을 호출하는 역할을 하는 것이다.<br />
<br />
이걸 적용하면 작동 순서가 이렇게 된다.<br />
<br />
<strong>TransactionManager 선별 -&gt; LazyConnectionDataSourceProxy에서 Connection Proxy 객체 획득 -&gt; Transaction 동기화(Synchronization) -&gt; 실제 쿼리 호출시에 <code>ReplicationRoutingDataSource.getConnection()/determineCurrentLookupKey()</code> 호출</strong><br />
<br />
이렇게 하여 깔끔하게 Spring의 트랜잭션과 어울리는 Replication Routing DataSource가 만들어지게 된다.<br />
실제 설정은 다음과 같이 된다. 좀 더 자세한 것은 <a href="https://github.com/kwon37xi/replication-datasource/blob/master/src/test/java/kr/pe/kwonnam/replicationdatasource/config/WithRoutingDataSourceConfig.java" target="_blank">WithRoutingDataSourceConfig.java</a>를 보자.<br />
<blockquote class="src">@Bean&nbsp;public&nbsp;DataSource&nbsp;writeDataSource()&nbsp;{&nbsp;return&nbsp;쓰기&nbsp;DataSource;&nbsp;}<br />
<br />
@Bean&nbsp;public&nbsp;DataSource&nbsp;readDataSource()&nbsp;{&nbsp;return&nbsp;읽기&nbsp;DataSource;&nbsp;}<br />
<br />
@Bean<br />
public&nbsp;DataSource&nbsp;routingDataSource(DataSource&nbsp;writeDataSource,&nbsp;DataSource&nbsp;readDataSource)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;ReplicationRoutingDataSource&nbsp;routingDataSource&nbsp;=&nbsp;new&nbsp;ReplicationRoutingDataSource();<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;Object,&nbsp;Object&gt;&nbsp;dataSourceMap&nbsp;=&nbsp;new&nbsp;HashMap&lt;Object,&nbsp;Object&gt;();<br />
&nbsp;&nbsp;&nbsp;&nbsp;dataSourceMap.put("write",&nbsp;writeDataSource);<br />
&nbsp;&nbsp;&nbsp;&nbsp;dataSourceMap.put("read",&nbsp;readDataSource);<br />
&nbsp;&nbsp;&nbsp;&nbsp;routingDataSource.setTargetDataSources(dataSourceMap);<br />
&nbsp;&nbsp;&nbsp;&nbsp;routingDataSource.setDefaultTargetDataSource(writeDataSource);<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;routingDataSource;<br />
}<br />
<br />
@Bean<br />
public&nbsp;DataSource&nbsp;<span style="color:#ff6666;"><strong>dataSource</strong></span>(DataSource&nbsp;routingDataSource)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;LazyConnectionDataSourceProxy(routingDataSource);<br />
}</blockquote><br />
<br />
<code>TransactionManager</code>나 영속 계층 프레임워크는 <strong><code>dataSource</code></strong> 이것만 바라보게 해야한다. <code>writeDataSource, readDatasource, routingDataSource</code>는 설정 속에만 존재할 뿐 영속 계층 프레임워크들에게는 그 존재를 모르게 해야한다.<br />
<br />
<strong><span style="font-size:130%;">4. LazyReplicationConnectionDataSourceProxy - Spring이 아니어도!</span></strong><br />
<br />
3번 방식은 단점이 하나 있는데, Spring을 사용하지 않고 프로그램을 짤 때는 사용할 수 없다는 것이다.<br />
현재 Java 계의 산업 표준인 Spring이긴 하지만 어찌 모두다 Spring만 사용하리오.<br />
그런데, 내가 이걸 만든 것은 Spring을 안 사용할 때 대비한 것은 아니고, 3번에 대한 아이디어가 없었기 때문이다... ^^;<br />
<br />
Spring의 <a target="_blank" href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/datasource/LazyConnectionDataSourceProxy.html">LazyConnectionDataSoruceProxy</a>의 코드를 보면서 이 클래스는 하나의 DataSource로만 프록시를 하지만 이를 write/read 두개의 데이터소스를 받아서 프록싱 하도록 수정하였다.<br />
전체 코드는 <strong><a href="https://github.com/kwon37xi/replication-datasource/blob/master/src/main/java/kr/pe/kwonnam/replicationdatasource/LazyReplicationConnectionDataSourceProxy.java" target="_blank">LazyReplicationConnectionDataSourceProxy.java</a></strong>에 있다.<br />
<strong>클래스 단 한 개라서, 필요하면 그냥 소스를 복사해서 자기 프로젝트에 넣고 사용</strong>하면 된다.<br />
<br />
실제 코드를 Spring의 것과 비교해 보면 거의 차이가 안 난다.<br />
<br />
이 클래스는 기본적으로 Spring의 <a target="_blank" href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/datasource/LazyConnectionDataSourceProxy.html">LazyConnectionDataSoruceProxy</a> 완전히 동일하게 작동하지만 <code>setReadOnly(true|false)</code>로 지정된 값에 따라 두 데이터소스 중에 적합한 곳으로 분기하여 실제 커넥션을 획득하여 리턴한다.<br />
Spring 프로젝트에서의 설정은 다음과 같은 형태가 된다.<br />
<blockquote class="src">@Bean&nbsp;public&nbsp;DataSource&nbsp;writeDataSource()&nbsp;{&nbsp;return&nbsp;쓰기&nbsp;DataSource;&nbsp;}<br />
<br />
@Bean&nbsp;public&nbsp;DataSource&nbsp;readDataSource()&nbsp;{&nbsp;return&nbsp;읽기&nbsp;DataSource;&nbsp;}<br />
<br />
@Bean<br />
public&nbsp;DataSource&nbsp;<span style="color:#ff6666;"><strong>dataSource</strong></span>(DataSource&nbsp;writeDataSource,&nbsp;DataSource&nbsp;readDataSource)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;<span style="color:#ff6666;">LazyReplicationConnectionDataSourceProxy(writeDataSource,&nbsp;readDataSource)</span>;<br />
}</blockquote><br />
설정이 무척 간단해졌다.<br />
<br />
<code>TransactionManager</code>나 영속 계층 프레임워크는 <strong><code>dataSource</code></strong> 이것만 바라보게 해야한다. <code>writeDataSource, readDatasource</code>는 설정 속에만 존재할 뿐 영속 계층 프레임워크들에게는 그 존재를 모르게 해야한다.<br />
<br />
앞서 말했듯이 이 코드는 전혀 Spring에 의존적이지 않으면서 Java의 표준 API를 따르고 있다.<br />
따라서 Spring의 <code>@Transactional</code>과 함께 사용해도 되고, 아니면 그냥 일반 Java 코드에서 아래처럼 <code>Connection.setReadOnly(true|false)</code>를 호출하여 사용하면 된다.<br />
<blockquote class="src">Connection&nbsp;connection&nbsp;=&nbsp;dataSource.getConnection();<br />
connection.setReadOnly(false);<br />
//&nbsp;쓰기&nbsp;DB관련&nbsp;작업<br />
connection.close();<br />
<br />
//<span style="color:#ff0000;"><strong>&nbsp;절대&nbsp;앞서&nbsp;획득한&nbsp;커넥션을&nbsp;재사용하지&nbsp;말&nbsp;것</strong></span><br />
<br />
Connection&nbsp;connection&nbsp;=&nbsp;dataSource.getConnection();<br />
connection.setReadOnly(true);<br />
//&nbsp;읽기&nbsp;DB관련&nbsp;작업<br />
connection.close();<br />
</blockquote><br />
<br />
<strong><span style="font-size:130%;">◆ 결론 및 주의할 점</span></strong><br />
<br />
&nbsp;1. Spring을 사용한다면 3번 LazyConnectionDataSourceProxy + AbstractRoutingDataSource 방식을 권장한다.<br />
&nbsp;2. Spring을 사용하지 않는다면 4번 <a href="https://github.com/kwon37xi/replication-datasource/blob/master/src/main/java/kr/pe/kwonnam/replicationdatasource/LazyReplicationConnectionDataSourceProxy.java" target="_blank">LazyReplicationConnectionDataSourceProxy.java</a> 소스를 복사하여 사용한다. 이는 한가지 예외를 제외하고는 Spring 과도 잘 작동한다.<br />
&nbsp;3. 4번 <a href="https://github.com/kwon37xi/replication-datasource/blob/master/src/main/java/kr/pe/kwonnam/replicationdatasource/LazyReplicationConnectionDataSourceProxy.java" target="_blank">LazyReplicationConnectionDataSourceProxy.java</a>는 <strong>Spring 4.0.x 이하 + JPA 조합으로 사용할 경우 작동하지 않는다</strong>. 이유는 일종의 Spring JPA TransactionManager의 의도적 <code>setReadOnly</code> 회피 때문인데 4.1 부터는 JPA에서도 <code>setReadOnly</code>를 올바르게 호출해줘서 괜찮다.<br />
&nbsp;4. <span style="color:#ff0000;"><strong>절대로 한번 읽어들인 커넥션을 readOnly 설정을 바꿔서 재활용하면 안된다. 일단 실제 커넥션을 획득하면 중간에 속성을 바꿔도 다른 커넥션을 새로 맺지 않는다.</strong></span> Spring은 propagation이 <code><b>REQUIRES_NEW</b></code>일 경우 비록 동일 DataSource에서 커넥션을 가져오더라도 새로운 커넥션을 맺기 때문에 아무 문제 없이 작동한다. 하지만 propagation이 <code>REQUIRED</code>일 경우에는 새로운 트랜잭션을 생성하지도 않고 새로운 설정을 적용하지도 않으므로 주의해야 한다.<br />
&nbsp;5. 이에 관한 모든 소스와 Spring의 Transaction에서의 예제를 모두 만들어서 올려 두었다. <a href="https://github.com/kwon37xi/replication-datasource" target="_blank">replication-datasource</a> 프로젝트를 보면되며 그 중에서도 <a href="https://github.com/kwon37xi/replication-datasource/blob/master/src/test/java/kr/pe/kwonnam/replicationdatasource/AbstractReplicationDataSourceIntegrationTest.java" target="_blank">AbstractReplicationDataSourceIntegrationTest.java</a>가 3, 4번 모두에 대한 Spring Transaction 테스트이다.<br />
<br />
PS&gt;<br />
일반적으로 Slave는 여러대로 구성한다. 그렇다면 Slave DB 정보를 여러개 받아서 부하 분산 처리하게 수정하고 싶은 욕구를 느낄 듯 한데, 그러지 말길 권한다.<br />
<strong>실제 데이터베이스의 물리적 정보를 애플리케이션에 넣게 되면 여러 서버들 중 한 대가 고장났을 경우 애플리케이션이 그대로 죽어버린다.</strong> 동종의 물리적 데이터베이스에 대한 Load Balancing 은 애플리케이션에서 하지 말고 중간에 L4, L7, LVS, Proxy Server 등의 계층을 두어서 중앙 집중 조정하게 해야한다. 여기서는 단지 부하 분산만 할 뿐 조건에 따른 분기 처리는 하지 않는다.<br />
사정상 이런 분기 처리가 힘들면 <a href="http://dev.mysql.com/doc/connector-j/en/connector-j-usagenotes-j2ee-concepts-managing-load-balanced-connections.html" target="_blank">MySQL의 경우에는 JDBC에서 Load Blanace</a>를 지원하니 알아보도록 한다.<br />
그래도 replication-datasource에 다중 Slave의 부하 분산 기능을 넣고 싶다면 일부 서버가 죽었을 때의 처리에 대해 매우 깊이 고민해야 한다.<br />
<br />
마지막으로, 4번 방법은 실전에서 사용해본 적 없다!<br/><br/>tag : <a href="/tag/java" rel="tag">java</a>,&nbsp;<a href="/tag/db" rel="tag">db</a>,&nbsp;<a href="/tag/jdbc" rel="tag">jdbc</a>,&nbsp;<a href="/tag/spring" rel="tag">spring</a>,&nbsp;<a href="/tag/springframework" rel="tag">springframework</a>,&nbsp;<a href="/tag/datasource" rel="tag">datasource</a>,&nbsp;<a href="/tag/master" rel="tag">master</a>,&nbsp;<a href="/tag/slave" rel="tag">slave</a>,&nbsp;<a href="/tag/write" rel="tag">write</a>,&nbsp;<a href="/tag/read" rel="tag">read</a>,&nbsp;<a href="/tag/split" rel="tag">split</a>,&nbsp;<a href="/tag/connectionpool" rel="tag">connectionpool</a>			 ]]> 
		</description>
		<category>프로그래밍</category>
		<category>java</category>
		<category>db</category>
		<category>jdbc</category>
		<category>spring</category>
		<category>springframework</category>
		<category>datasource</category>
		<category>master</category>
		<category>slave</category>
		<category>write</category>
		<category>read</category>
		<category>split</category>
		<category>connectionpool</category>

		<comments>http://kwon37xi.egloos.com/5364167#comments</comments>
		<pubDate>Sun, 11 Jan 2015 12:16:55 GMT</pubDate>
		<dc:creator>권남</dc:creator>
	</item>
	<item>
		<title><![CDATA[ 새로운 것을 배워야 좋은 프로그래머인가요? ]]> </title>
		<link>http://kwon37xi.egloos.com/5232876</link>
		<guid>http://kwon37xi.egloos.com/5232876</guid>
		<description>
			<![CDATA[ 
  어떤 분이 힘들다고 푸념하면서 <a target="_blank" href="http://kwon37xi.egloos.com/4747016#14631990.01">새로운 것을 배워야만 좋은 프로그래머인거냐고 질문</a>을 올렸길래 답을 달았다.<br />
<br />
일단은 아래와 같이 답을 달았다.<br />
<quote><strong>항상 새로운 것을 배우는 것은 훌륭한 프로그래머가 아닙니다.(그렇다고 나쁘다는 뜻도 아닙니다. 단지 새로운 것을 배운다는 것 자체가 훌륭한 프로그래머의 정의는 아니다 라는 의미입니다.)<br />
<br />
현재 개발을 하면서 어떤 문제가 반복적인 노가다성 작업인지, 인간의 실수를 유발하는 작업인지를 잘 살피고 그 문제를 해결하기 위해 공부하고 해결책을 제시하는 것은 훌륭한 프로그래머입니다.<br />
<br />
다른 사람들의 반복 적이고 인간이 하기에는 오류가 많은 것을 자동화해주는 "프로그래머"라는 직업에 종사하면서 자기 자신이 겪고 있는 문제조차 공부하기 싫어 외면한다는 것은 좋은 프로그래머가 아닙니다.</strong></quote><br />
<br />
내가 생각하는 좋은 프로그래머는 (특히 서비스 개발쪽에 종사하는 - 주로 웹,모바일 서비스등) 새로운 것을 추구하는 사람이 아니라 주어진 문제에서 발생하는 최적해를 찾아내는 사람이다. 최신 기술이 중요한게 아니라 최적 기술이 더 중요하며 그 와중에도 반복적이고 오류를 발생시키는 문제가 있을 때에는 과감히 새로운 기술을 도입도 할 수 있어야하고, 비록 낡은 기술이라도 현재 상태의 최적해라면 그리고 팀에 의해 정해진 규칙이고 그 규칙이 별다른 문제가 없다면 묵묵히 따를 수도 있어야 한다.<br />
<br />
최신 기술만 추구하는 사람들은 보통 서비스는 제대로 만들지도 못하면서 자기 회사 서비스를 자기 개인 코드 연습장처럼 사용하여 서비스 전체를 아예 오픈도 못해보거나 실제 론칭 후에 발생하는 문제들을 해결하지 못해(너무 신기술이라 폭넓게 검증된 적이 없는 불완전한 상태이고, 기술을 도입시킨 본인도 해당 기술에 대해 제대로 이해를 못한 상태라서) 손을 놔버리는 모습을 보일 때도 있고,<br />
공부하려들지 않는 개발자들은 어떻게 어떻게 꾸역꾸역 서비스를 유지하지만 근본적인 문제를 해결하지 못하고 외면하면서 문제의 크기를 계속 키워서 시스템 전체를 손댈 수 없는 지경의 위험에 빠뜨리는 것을 본다.<br />
<br />
이 둘 간의 균형을 어떻게 유지할 것인가?<br />
<br/><br/>tag : <a href="/tag/프로그래머" rel="tag">프로그래머</a>			 ]]> 
		</description>
		<category>프로그래밍</category>
		<category>프로그래머</category>

		<comments>http://kwon37xi.egloos.com/5232876#comments</comments>
		<pubDate>Sun, 07 Dec 2014 05:23:03 GMT</pubDate>
		<dc:creator>권남</dc:creator>
	</item>
	<item>
		<title><![CDATA[ Spring ChainedTransactionManager 어떻게 사용해야 하나? ]]> </title>
		<link>http://kwon37xi.egloos.com/4886947</link>
		<guid>http://kwon37xi.egloos.com/4886947</guid>
		<description>
			<![CDATA[ 
  Spring Data Commons 1.6에는 <a target="_blank" href="http://docs.spring.io/spring-data/commons/docs/1.6.2.RELEASE/api/org/springframework/data/transaction/ChainedTransactionManager.html">ChainedTransactionManager</a>라는 것이 추가 돼 있다<br />
<br />
하나의 애플리케이션에서 여러 데이터베이스에 접근할 때 <code>@Transactional</code> 애노테이션을 통해 트랜잭션을 잡아줄 때 여러 데이터소스(DataSource)의 트랜잭션 매니저(Transaction Manager)를 따로따로 지정해서 작업해야 한다.<br />
사실 그렇게까지 어려운 일은 아니지만 확실히 복잡도가 높아지긴 한다. 그래서 편리하게 사용하라고 나온 것이 <a target="_blank" href="http://docs.spring.io/spring-data/commons/docs/1.6.2.RELEASE/api/org/springframework/data/transaction/ChainedTransactionManager.html">ChainedTransactionManager</a>이다.<br />
이는 여러 트랜잭션 매니저를 인자로 받아 <code>@Transactional</code>에 기본 트랜잭션 매니저로 등록시켜두면, <strong>트랜잭션이 시작될 때 지정된 모든 트랜잭션 매니저의 트랜잭션을 동시에 시작시키고 메소드 종료시에 동시에 커밋(commit) 혹을 롤백(rollback)을 수행</strong>한다.<br />
<br />
javadoc 문서에 보면 <q>The configured instances will start transactions in the order given and commit/rollback in reverse order, which means the PlatformTransactionManager most likely to break the transaction should be the last in the list configured. A PlatformTransactionManager throwing an exception during commit will automatically cause the remaining transaction managers to roll back instead of committing.</q>라고 나온다.<br />
즉, <ul><li>지정된 순서대로 트랜잭션이 실행되고,</li><li>지정된 역순으로 트랜잭션이 종료된다.</li><li>다시말해, 에러를 내기 쉬운 트랜잭션을 마지막에 지정해서 트랜잭션 종료 작업이 최초로 호출되도록 해야한다</li></ul><br />
왜냐면, 에러를 낼 가능성이 높은 트랜잭션이 최초로 롤백이 돼야 그 뒤의 다른 트랜잭션도 따라서 롤백 되기 때문이다. ChainedTransactionManager는 단지 트랜잭션 시작과 종료를 동시에 해줄 뿐이지 Two Phase Commit을 지원하는게 아니라서 이미 다른 트랜잭션이 커밋된 상황에서 하나의 트랜잭션이 롤백 됐다고 해서 이미 커밋된 것들이 다시 롤백되지는 않는다. 따라서 <strong>가장 위험한 요소를 최초로 커밋/롤백 시도</strong>하도록 해야 한다.<br />
<br />
그런데 문제가 여기서 끝나지 않는다.<br />
<br />
Spring의 PlatformTransactionManager는 기본적으로 트랜잭션이 시작될 때 Connection을 확보한다. 여기서 실제로 해당 Connection의 사용여부는 중요하지 않다. <strong>그냥 무조건 Connection을 확보</strong>한다.<br />
<br />
ChainedTransactionManager가 firstTransactionManager와 secondTransactionManager를 묶은 상태일때, ServiceA가 firstTransactionManager의 데이터소스만 사용하는 작업을 하더라도 secondTransactionManager의 데이터소스의 커넥션까지 함께 물고 들어가게 된다.<br />
<br />
이 상황이 되면 실제로 <b>secondTransactionManager는 아무 하는 일도 없이 커넥션 고갈 상태에 빠질 수 있다.</b> 게다가 secondTransactionManager에 참여하는 데이터소스의 최대 커넥션 갯수가 firstTransactionManager의 커넥션 갯수보다 더 적은 상황이라면 사태는 더욱 심각해진다.<br />
<br />
따라서 최종적으로 봤을 때 <strong>ChainedTransactionManager에 참여하는 모든 DataSource의 최대 커넥션 갯수는 동일하게 맞춰주는 것이 좋다.</strong><br />
<br />
또한, Spring은 <a href="http://docs.spring.io/spring/docs/3.2.9.RELEASE/javadoc-api/org/springframework/jdbc/datasource/LazyConnectionDataSourceProxy.html" target="_blank">LazyConnectionDataSourceProxy</a>라는 것을 제공해주고 있다.<br />
이를 사용하면 트랜잭션 매니저에 의해 커넥션이 호출되더라도 <strong>실제로 커넥션이 사용되기 전까지 원본 데이터소스에 커넥션 요청을 미룸으로써 불필요한 커넥션 생성 요청을 방지</strong>해준다. 따라서 CTM 으로 묶여있는 데이터소스들이 사용도 안되는 커넥션 요청으로 커넥션 고갈을 겪는 문제를 완화시켜준다.<br />
<br />
LazyConnectionDataSourceProxy는 ORM 사용시 캐시 히트율이 높아서 ReadOnly 트랜잭션은 시작했으나 정작 DB에 한번도 액세스하지 않는 상황이 될 때도 매우 유용하다.<br />
<br />
위 사항은 직접 테스트를 해보았다.<br />
<br />
<a href="https://github.com/kwon37xi/ChainedTransactionManagerTest" target="_blank">ChainedTransactionManagerTest</a>에서 테스트 코드와 결과를 볼 수 있다.<br />
<br />
<b><font size="4">추가 - Chained 트랜잭션 범위내에서 그에 포함되는 Chained 트랜잭션 매니저나 단독 트랜잭션 매니저의 실행<br />
</font></b><br />
ChainedTransactionManager와 그 하위 ChainedTransactionManager 혹은 단독 트랜잭션 매니저의 동기화에 대한 테스트 결과,<br />
상위에 ChainedTransactionManager로 트랜잭션이 걸리고 그 하위의 메소드에 상위 매니저에 포함되는 트랜잭션매니저로 트랜잭션이 걸려 있으면 상위 트랜잭션 매니저와 동기화 된 상태임을 확인하였다.<br />
			 ]]> 
		</description>
		<category>프로그래밍</category>

		<comments>http://kwon37xi.egloos.com/4886947#comments</comments>
		<pubDate>Sat, 12 Jul 2014 09:13:54 GMT</pubDate>
		<dc:creator>권남</dc:creator>
	</item>
	<item>
		<title><![CDATA[ Xubuntu 14.04 설치기 ]]> </title>
		<link>http://kwon37xi.egloos.com/4876381</link>
		<guid>http://kwon37xi.egloos.com/4876381</guid>
		<description>
			<![CDATA[ 
  요즘은 리눅스 그 중에서도 특히 <a target="_blank" href="http://www.ubuntu.com/">Ubuntu</a>를 설치하는 일이 워낙 쉽다보니 딱히 설치기 같은 것을 언제부터인가 안 썼었다.<br />
그리고 나는 정확히 말하면 Ubuntu가 아닌 <a target="_blank" href="http://xubuntu.org/">Xubuntu</a> 혹은 <a target="_blank" href="http://www.linuxmint.com/">Mint MATE</a>를 더 선호하는 사람이다. 간결하고 익숙하기 때문이다(결론은 나이들어서 변화가 귀찮다).<br />
<br />
이번에 Xubuntu 14.04 LTS 가 출시되면서 회사 개발용 PC를 밀면서 Xubuntu로 갔는데, 설치 자체는 편했지만 몇가지 버그가 괴롭혔다. Ubuntu Unity버전에 비해 사용자가 적다보니 Xubuntu에 대한 버그 리포팅이나 해결책이 별로 안 나와있는 상황이라 삽질이 좀 있었다.<br />
<br />
그래서 간략히 설치기의 링크를 걸고, 그 중 주의해야할 버그들을 공유한다.<br />
<br />
<a target="_blank" href="http://kwonnam.pe.kr/wiki/linux/ubuntu/14.04">Xubuntu 14.04 설치기</a> 에서 기본적인 것은 읽어 보도록 하고,<br />
부딪힌 버그와 해결책은 다음과 같다.<br />
<br />
<strong><big>1. 지속적인 Apport 경고창 - 부팅시마다 알지도 못하는 경고창이 뜬다.</big></strong><br />
<blockquote class="src"># 먼저 /var/crash 의 파일들을 삭제한다. 여기 있는 파일들이 부팅시 에러메시지로 나오는 것이다.<br />
sudo rm /var/crash/*<br />
sudo vi /etc/default/apport<br />
# enabled=1 -> 0 으로변경<br />
 <br />
# apport restart 혹은 재부팅<br />
sudo restart apport<br />
</blockquote><br />
<br />
<strong><big>2. 나눔 고딕 글꼴 상단 잘림 문제</big></strong> -&gt; <a href="https://github.com/igxactly/config-fonthinting-nanum">https://github.com/igxactly/config-fonthinting-nanum</a><br />
<br />
<strong><big>3. 한글 입력기 나비 Nabi 설치시 화면 왼쪽 위(좌상단) 클릭 안됨.</big></strong><br />
이 문제가 나를 가장 많이 골치아프게 한 것인데, 처음에는 무엇 때문인지도 몰랐다. 이상하게 화면 좌상단의 일부분이 전혀 클릭이 안되는 현상이 발생한다. 그렇다고 거기에 뭐가 있는것 같지도 않았는데....<br />
제어판 -> 창관리자 기능향상 설정에서 <strong>합성(Composite) 기능</strong>을 끄면 갑자기 나비의 팔렛트가 해당 위치에 떡하니 나타난다. 이것이 클릭을 막고 있는데, 합성이 켜져 있을 경우 안보이는 것이었다.<br />
팔렛트 숨기기를 아무리 해도 안 없어진다. 나비의 버그로 보인다. 결국 UIM으로 갈아탔다. iBus는 Shift-Space 사용시에 미묘한 타이밍 흐트러트림이 발생해서 싫어한다.<br />
(이 현상 때문에 굳이 합성 기능을 꺼둘 필요는 없다)<br />
<br />
<strong><big>4. XFCE 창관리자(XFWM)의 단축키 변경 안 되는 버그</big></strong><br />
리눅스에는 보통 두 종류의 키보다 단축키 조합이 있는데 하나는 창관리자(Window Manager)용으로 창(window)과 작업공간을 제어하는 단축키가 있고 일반 애플리케이션을 호출하는 단축키가 지정가능하다.<br />
그런데 창관리자용 단축키를 변경했는데 적용이 안되는 현상이 발생했다.<br />
이는 창관리자 단축키 설정시에 과거 설정과 신규 설정이 동시에 설정파일에 입력되면서 나타나는 버그이다. 결국 과거 설정을 설정 파일에서 지워줘야 한다.<br />
<strong><code>~/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-keyboard-shortcuts.xml</code></strong>이게 설정파일인데 잘보면 동일한 역할에 대한 설정이 두 번씩 나오는 것을 볼 수 있다. 그 중에서 자기가 원치 않는 것을 삭제해버리고 XFCE를 재시작 하면 된다.<br />
<br />
<strong><big>새로운 기능</big></strong> - <a href="http://smdavis.us/2014/04/15/14-features-of-xubuntu-14-04/">Xubuntu 14.04 new features</a><br />
합성(Composite) 기능이 켜진 상태에서 Alt 키를 누른 상태로 마우스 휠을 움직이면 화면이 확대된다. 원래 안됐었나? 관심이 너무 없었네.<br />
<iframe width="560" height="315" src="//www.youtube.com/embed/y8GvTbgkMd4" frameborder="0" allowfullscreen="allowfullscreen"></iframe><br />
<br />
웬만하면 이번에는 6개월 후에도 계속 이 버전을 유지하면서 PPA로 주요 애플리케이션만 업그레이드 하는 전략을 취해 봐야겠다. 그게 안되면 이번에 LTS 기반으로 2년간 가기로 정한 Linux Mint MATE 로 가서 장기간 써야겠다.			 ]]> 
		</description>
		<category>리눅스/Unix 이야기</category>

		<comments>http://kwon37xi.egloos.com/4876381#comments</comments>
		<pubDate>Tue, 20 May 2014 14:41:06 GMT</pubDate>
		<dc:creator>권남</dc:creator>
	</item>
	<item>
		<title><![CDATA[ JDBC SQL 구문에 클라이언트 정보 남기기 ]]> </title>
		<link>http://kwon37xi.egloos.com/4860051</link>
		<guid>http://kwon37xi.egloos.com/4860051</guid>
		<description>
			<![CDATA[ 
  DB 서버가 한 대 있고, 해당 서버에 접속해서 쿼리를 날리는 Java 웹 애플리케이션이 여러 개라고 해보자.<br />
커머스 업체라고 했을 때 사용자 화면 애플리케이션, 상품 정보 관리 애플리케이션, 정산 애플리케이션 등이 별도로 존재하며 어떤 특정 DB에 모두 동시에 접속하는 경우가 발생한다는 것은 쉽게 예상할 수 있을 것이다.<br />
<br />
DB 서버의 로그를 보니 Slow Query가 남아 있는데, 도대체 이 Slow Query를 호출한 애플리케이션이 무엇인지 어떻게 하면 빠르게 판단할 수 있을까?<br />
<br />
제일 쉬운 방법은 SQL 구문에 주석으로 각 클라이언트(애플리케이션)의 정보를 남기는 것이다.<br />
SQL은 <strong>/* 이런 저런 내용 */</strong> 형태로 주석을 남기는 것을 지원한다.<br />
<br />
Java 6/JDBC 4 Spec에서 바로 이러한 Client Info를 남길 수 있는 기법을 지원한다(<a title="" href="http://docs.oracle.com/javase/6/docs/api/java/sql/Connection.html#setClientInfo%28java.lang.String,%20java.lang.String%29" target="_blank">Connection#setClientInfo</a>). 나는 현재 MySQL만 사용하고 있지만 다른 많은 DB들도 이를 구현하고 있으리라 예상한다.<br />
<br />
더 아래에서는 Hibernate 사용시 Interceptor를 통해 더 쉽게 처리하는 방법도 간단히 소개한다.<br />
<br />
<span style="font-size:170%;"><strong>JDBC 4 Client Info</strong></span><br />
<a title="" href="http://dev.mysql.com/doc/relnotes/connector-j/en/news-5-1-0.html" target="_blank">MySQL의 경우 5.1.10 버전</a>부터 JDBC 4의 Client Info 스펙을 구현하고 있다. (단, <strong>MySQL Replication Driver는 아직도(2014년 3월) 이를 구현하지 못하고 있다.</strong>)<br />
<br />
이 스펙을 구현한다고 해서 모든 JDBC 드라이버가 SQL의 주석으로 Client 정보를 남기는 것은 아니다. 하지만 MySQL은 <a title="" href="http://www.docjar.com/html/api/com/mysql/jdbc/JDBC4CommentClientInfoProvider.java.html" target="_blank">JDBC4CommentClientInfoProvider</a>를 Client Info 처리의 기본 구현체로 지정하고 있으면 이것이 바로 주석으로 정보를 남기는 역할을 한다. 이 구현체는 <code>clientInfoProvider</code> JDBC URL 파라미터를 통해 원하는 것으로 바꾸는 것이 가능하다.<br />
<br />
일단은 아주 생짜 JDBC로 어떻게 작동하는지 코드로 보여주면 다음과 같다.<br />
<blockquote class="src">//&nbsp;예외처리는&nbsp;모두&nbsp;무시했음.&nbsp;모범적인&nbsp;코드&nbsp;예가&nbsp;아니므로&nbsp;실전에서&nbsp;따라하지&nbsp;말&nbsp;것.<br />
Class.forName("com.mysql.jdbc.Driver");<br />
<br />
Connection&nbsp;connection&nbsp;=&nbsp;DriverManager.getConnection("jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;user=root&amp;password=root");<br />
<br />
InetAddress&nbsp;localhost&nbsp;=&nbsp;InetAddress.getLocalHost();<br />
<br />
<strong>connection.setClientInfo("ApplicationName",&nbsp;"JDBC4&nbsp;Test&nbsp;Application");<br />
connection.setClientInfo("ClientHostname",&nbsp;localhost.getHostName());<br />
connection.setClientInfo("ClientAddress",&nbsp;localhost.getHostAddress());</strong><br />
<br />
Statement&nbsp;statement&nbsp;=&nbsp;connection.createStatement();<br />
ResultSet&nbsp;resultSet&nbsp;=&nbsp;statement.executeQuery("select&nbsp;1");<br />
</blockquote><br />
<br />
위 코드를 실행하면 MySQL의 쿼리 로그에 다음과 같이 찍히게 된다. 즉, DBA가 Slow Query를 발견했다면 즉시 어느 애플리케이션의 어느 서버에서 온 쿼리인지 인지할 수 있다.<br />
<blockquote class="src"><strong>	/* ApplicationName=JDBC4 Test Application, ClientHostname=kwon37xi-dev, ClientAddress=127.0.1.1 */ </strong>select 1<br />
</blockquote><br />
<br />
하지만 현대 애플리케이션에서 Connection을 매번 직접 생성하여 값을 설정하는 일은 하지 않는다. 특히 Spring을 사용한다면 Connection 객체는 사실상 구경도 할 필요가 없고, 할 수는 있더라도 안하는게 더 좋다.<br />
<br />
<a title="" href="http://jolbox.com/" target="_blank">BoneCP 커넥션 풀</a>은 <a title="" href="https://github.com/wwadge/bonecp/blob/master/bonecp/src/main/java/com/jolbox/bonecp/BoneCPConfig.java" target="_blank">BoneCPConfig.java</a> 설정에서 <code>setClientInfo</code> 메소드를 통해 미리 클라이언트 정보를 <code>Properties</code> 객체로 넣어둘 수 있는 기능을 지원하고 있다. 따라서 커넥션 풀 설정시 한 번만 해주면 모든 Connection에 대해 Client Info가 전달된다.<br />
<br />
<span style="font-size:170%;"><strong>Hibernate Interceptor</strong></span><br />
Hibernate를 사용하는 경우(JPA를 통해서든 직접이든) <a title="" href="https://github.com/hibernate/hibernate-orm/blob/master/hibernate-core/src/main/java/org/hibernate/Interceptor.java" target="_blank">Interceptor</a> 인터페이스 중에서 <code><strong>onPrepareStatement</strong></code> 메소드 구현을 통해서 위와 같은 일을 하는게 가능하다.<br />
이 경우 좀 더 유리한데, 왜냐하면 이 인터셉터 구현체는 모든 쿼리 요청마다 매번 호출되기 때문이다. 따라서 모든 쿼리 호출시 호출 당시의 정보(접속 URL, 호출한 클래스와 메소드 정보) 등도 함께 넣는게 가능하다.<br />
<br />
<code>onPrepareStatement</code>는 특별히 키/값 쌍을 넣거나 하는 것이 아니라 DB에 전송하기 전의 SQL 구문을 직접 편집하는 것이므로 SQL 주석을 개발자가 직접 만들어 넣어주면 된다.<br />
<br />
실제 구현은 <code>EmptyInterceptor</code>를 상속하여 다른 것은 무시하고 <code>onPrepareStatement</code>만 구현하는 것이 좋다.<br />
<br />
JPA 사용시 <code><strong>hibernate.ejb.interceptor</strong></code>로 Interceptor 구현 클래스의 FQCN을 지정해주면 된다.<br />
<br />
워낙 쉬워 코드 예를 들지는 않겠지만 한가지 팁을 주면, Spring MVC 사용시 Spring MVC Interceptor를 통해 현재 URL정보와 컨트롤러 클래스/메소드 정보를 수집해두고 이를 ThreadLocal을 통해서 Hibernate Interceptor에 전달하여 SQL 구문에 URL과 컨트롤러 클래스/메소드 정보까지 집어넣는 것이 가능해진다. SQL 구문을 보고나서 오류 발생 URL을 즉시 알 수 있어서 오류 대응 능력이 조금 높아질 것이다. 단, SQL 구문이 길어짐으로써 생기는 다른 단점들은 감안해야 한다.<br />
<br />
그리고 마지막으로, <span style="color:#ff0000;"><strong>사용자가 직접 입력하거나 변조할 수 있는 정보를 Client Info로 절대로 넣지말라. 굳이 넣어야 겠다면 이 또한 <a title="" href="http://en.wikipedia.org/wiki/SQL_injection" target="_blank">SQL Injection</a>의 하나로 공격 대상이 될 수 있으므로 철저히 검증해서 넣도록 주의해야 한다.</strong></span><br />
<br />
<br/><br/>tag : <a href="/tag/java" rel="tag">java</a>,&nbsp;<a href="/tag/jdbc" rel="tag">jdbc</a>,&nbsp;<a href="/tag/mysql" rel="tag">mysql</a>,&nbsp;<a href="/tag/client" rel="tag">client</a>,&nbsp;<a href="/tag/hibernate" rel="tag">hibernate</a>,&nbsp;<a href="/tag/interceptor" rel="tag">interceptor</a>			 ]]> 
		</description>
		<category>프로그래밍</category>
		<category>java</category>
		<category>jdbc</category>
		<category>mysql</category>
		<category>client</category>
		<category>hibernate</category>
		<category>interceptor</category>

		<comments>http://kwon37xi.egloos.com/4860051#comments</comments>
		<pubDate>Sat, 08 Mar 2014 07:59:11 GMT</pubDate>
		<dc:creator>권남</dc:creator>
	</item>
	<item>
		<title><![CDATA[ Spring JavaConfig냐 XML 설정이냐 ]]> </title>
		<link>http://kwon37xi.egloos.com/4853063</link>
		<guid>http://kwon37xi.egloos.com/4853063</guid>
		<description>
			<![CDATA[ 
  Spring 설정을 할 때 JavaConfig를 사용하는 것이 좋을까 XML 설정을 하는 것이 좋을까?<br />
흔히 JavaConfig를 사용하자고 하는 말하는 사람들은 <strong>Java로 작성하면 정적 언어 특징 덕분에 작성 중 컴파일을 통해 에러를 쉽게 찾고 리팩토링도 안전하게 할 수 있어서</strong> 실수 위험이 줄어들기 때문에 XML보다는 Java가 더 낫다고 말한다.<br />
<br />
그럼 아래의 XML 설정과 JavaConfig 설정을 살펴보자.(참고로 나는 이제 Commons DBCP를 더이상 사용하지 않는다. <a title="" href="http://jolbox.com/" target="_blank">BoneCP</a>를 주로 사용하려고 한다.)<br />
<blockquote class="src">&lt;bean&nbsp;id="datasource"<br />
&nbsp;class="org.apache.commons.dbcp.BasicDataSource"<br />
&nbsp;&nbsp;&nbsp;&nbsp;p:driverClassName="${jdbc.driverClassName}"&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;p:url="${jdbc.url}"<br />
&nbsp;&nbsp;&nbsp;&nbsp;p:username="${jdbc.username}"&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;p:password="${jdbc.password}"<br />
&nbsp;&nbsp;&nbsp;&nbsp;p:maxActive="${jdbc.maxActive}"<br />
&nbsp;&nbsp;&nbsp;&nbsp;p:maxWait="${jdbc.maxWait}"<br />
&nbsp;&nbsp;&nbsp;&nbsp;p:validationQuery="${jdbc.validationQuery}"<br />
&nbsp;&nbsp;&nbsp;&nbsp;p:testWhileIdle="${jdbc.testWhileIdle}"<br />
&nbsp;&nbsp;&nbsp;&nbsp;p:timeBetweenEvictionRunsMillis="${jdbc.timeBetweenEvictionRunsMillims}"/&gt;<br />
</blockquote><br />
<blockquote class="src">@Value("${jdbc.driverClassName}")<br />
private&nbsp;String&nbsp;driverClassName;<br />
<br />
@Value("${jdbc.url}")<br />
private&nbsp;String&nbsp;url;<br />
<br />
//&nbsp;..&nbsp;너무&nbsp;길어&nbsp;생략<br />
<br />
@Bean<br />
public&nbsp;DataSource&nbsp;datasource()&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;BasicDataSource&nbsp;datasource&nbsp;=&nbsp;new&nbsp;BasicDataSource();<br />
&nbsp;&nbsp;&nbsp;&nbsp;datasource.setDriverClassName(driverClassName);<br />
&nbsp;&nbsp;&nbsp;&nbsp;datasource.setUrl(url);<br />
&nbsp;&nbsp;&nbsp;&nbsp;datasource.setUsername(username);<br />
&nbsp;&nbsp;&nbsp;&nbsp;datasource.setPassword(password);<br />
&nbsp;&nbsp;&nbsp;&nbsp;datasource.setMaxActive(maxActive);<br />
&nbsp;&nbsp;&nbsp;&nbsp;datasource.setMaxWait(maxWait);<br />
&nbsp;&nbsp;&nbsp;&nbsp;datasource.setValidationQuery(validationQuery);<br />
&nbsp;&nbsp;&nbsp;&nbsp;datasource.setTestWhileIdle(testWhileIdle);<br />
&nbsp;&nbsp;&nbsp;&nbsp;datasource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;datasource;<br />
}<br />
</blockquote><br />
<br />
어떤게 가독성이 높고 합리적이라 생각되는가? 내가 보기엔 XML이 훨씬 가독성이 높고 합리적으로 보인다. 또한 과연 우리가 BasicDataSource 클래스를 클래스로 직접 참조하거나 리팩토링할 가능성은? 여기서는 Java의 정적인 특징이 아무 의미가 없다.<br />
<br />
나도 안다. 이게 좀 극단적인 예라는 것을. 문제는 Spring으로 설정을 하다보면 실제로 설정 XML로 빼는 것들은 보통 개발자가 직접 만든 코드보다는 저런 인프라성 객체 생성일 경우가 더 많다는 점이다.<br />
<br />
그렇다면 나는 JavaConfig에 반대하는가? 그렇지 않다.<br />
다만 JavaConfig라고 부르기보다는 CodeConfig라고 불렀으면 좋겠다는 점이다.<br />
<br />
최근에 나는 <a target="_blank" href="http://www.gradle.org/">Gradle</a>을 사용하여 XML이 아닌 <a title="" href="http://groovy.codehaus.org/" target="_blank">Groovy</a> 코드로 빌드를 설정한다. 또한 로깅 프레임워크도 <a title="" href="http://logback.qos.ch/" target="_blank">Logback</a>을 사용하며, 이 설정도 XML이 아닌 Groovy로 하고 있다.<br />
Groovy든 Java든 언어를 떠나서, 코드로 하는 설정의 특징을 살펴보자.<br />
<ul><li>코드는 그룹지어 클래스 혹은 메소드로 이름을 지어 분리가 가능하다.</li><li>코드는 중복을 그룹지어 중복이 아닌 것은 인자로 받고 중복 부분은 클래스 혹은 메소드로 만들 수 있다.</li><li>코드는 상황에 따른 대응을 더욱 쉽게 할 수 있다.</li></ul><br />
코드 기반 설정의 장점은 위 특징들에 있는 것이지 "정적"성에 있는 것이 아니다.<br />
<br />
예를들어 위의 BasicDataSource 생성의 경우 나라면 아래와 같이 Factory를 만들어 중복이 되는 <strong>"jdbc.*"</strong>부분을 인자로 내려보내어 한번에 처리하게 할 것이다. BasicDataSourceFactory 내부에서는 Spring의 <a title="" href="http://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/core/env/Environment.html" target="_blank">Environment</a> 객체를 주입 받아서 "jdbc.driverClassName", "jdbc.url" 등의 값을 자동으로 가져다가 BasicDataSource 객체를 구성한다.우리는 수십개의 DataSource 객체를 생성해야 하는데, 각각의 DataSource를 다음과 같은 코드로 줄였다.<br />
<blockquote class="src">@Bean<br />
public&nbsp;BasicDataSourceFactory&nbsp;datasource()&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;BasicDataSourceFactory("jdbc");<br />
}<br />
</blockquote><br />
<br />
저렇게 중복을 제거하지 않더라도 단지 그루핑을 해서 메소드로 빼는 것만으로도 가치가 있다.<br />
<br />
ᅟweb.xml은 그 XML의 향연이 볼 때마다 사람을 정신 못차리게 만드는 힘이 있는데, Servlet 3.0부터 Java 코드로 web.xml을 대체할 수 있게 하고 있다.<br />
이때도 리스너 하나, 필터하나, 서블릿 하나 등을 그냥 Java 코드로 나열하지 말고 그룹지어 메소드로 뺀 뒤에 해당 메소드를 호출하는 형태로 만들면 가독성이 확연히 높아지게 된다.<br />
<br />
현재 우리 팀에서 관리하고 있는 Logback 설정에서 가장 많이 중복되는 것은 <a title="" href="http://logback.qos.ch/manual/appenders.html#RollingFileAppender" target="_blank">RollingFileAppender</a> 이다. 이 중에서도 일별 Rolling이 가장 많이 쓰인다. 이 어펜더는 다양한 옵션을 가지는데 대부분 패턴이 유사하다. 그래서 공통적인 사항을 메소드로 뽑고서 사실 가장 간결할 때는 다음 수준으로 호출해도 되게 만들었다.<br />
<blockquote class="src">dailyRollingAppender(name:&nbsp;'somelog',&nbsp;file:&nbsp;'/logs/some.log')<br />
</blockquote><br />
<br />
상황에 따른 유연한 대응력도 코드 기반이 줄 수 있는 커다란 장점 중에 하나이다. 일반적으로 설정은 Profile별 분할은 하더라도 모든 개발자들이 똑같이 사용하는 것이 보통이다. 즉, Development 프로필의 설정이 모든 개발자들에게 동일하다는 점이다.<br />
하지만 로깅을 예로 들면 어떤 개발자는 특정 부분의 로그를 더 자세히 찍고 싶을 때도 있을 것이다. 이때 development 프로필의 로깅 설정을 바꿨다가 실수로 저장소에 Push해서 다른 개발자들로부터의 원성을 사본 경험이 다들 있을 것이다.<br />
이런 경우에도 개발자가 시스템 프라퍼티 세팅으로 자신만의 로그 설정파일을 임시로 사용하게 해주는 등의 처리가 코드를 통한 설정을 사용하면 쉽게 가능하다.(실제로 이렇게 만들었다).<br />
<br />
이러한 유연성은 Profile에 따라 달라지는 무언가를 만들 때도 비슷하게 적용된다.<br />
<br />
내가 보기엔 설정이라는 것이 앞으로는 설정 키/값을 가진 파일을 제외하고는 코드 기반으로 바뀌게 될 것으로 보인다. 이미 많은 부분들이 그렇게 바뀌었고. 개인적인 바람이라면 키/값 설정 파일도 XML이나 Java의 Properties 파일을 벗어나서 YML이 됐으면 좋겠다.<br />
가끔 Spring 설정을 JavaConfig로 바꾸자는 주장을 보면 그 논리가 Java의 정적인 특성에 치우쳐져 있는 경우가 많다. 이는 맨 위에서 보여줬던 예제만으로도 쉽게 반대에 부딪히게 된다.<br />
코드 기반 설정의 장점을 충분히 활용할 수 있도록 하자.<br />
<br />
Spring의 Java Config 사용시 주의할 점<br />
<ul><li>@PostConstruct 혹은 여러 *Aware 인터페이스를 구현한 Bean의 경우에 직접 생성 후 주입하지 말고 독립 Bean으로 생성한 뒤에 주입 받아서 다른 Bean에 주입할 것</li><li><a title="" href="http://kwonnam.pe.kr/wiki/springframework/javaconfig" target="_blank">정리중인 Java Config 주의할 점들</a></li><li><a href="http://toby.epril.com/?p=1179" target="_blank">스프링 3.1 (5) @Enable*을 이용한 설정 재활용 기법 세미나 동영상 & 자료</a>와 <a href="http://whiteship.me/?p=13438" target="_blank">[Spring 3.1 @Enable] 1. @Configuration 상속을 사용한 확장 방법</a> 이 글 시리즈를 읽고 Enable을 만드는 법을 익히면 더욱 간결한 JavaConfig 구성이 가능하다.</li></ul>			 ]]> 
		</description>
		<category>프로그래밍</category>

		<comments>http://kwon37xi.egloos.com/4853063#comments</comments>
		<pubDate>Sun, 26 Jan 2014 09:16:34 GMT</pubDate>
		<dc:creator>권남</dc:creator>
	</item>
</channel>
</rss>
