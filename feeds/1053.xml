<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by 홍창남(Hong, Chang Nam) on Medium]]></title>
        <description><![CDATA[Stories by 홍창남(Hong, Chang Nam) on Medium]]></description>
        <link>https://medium.com/@codenamehong?source=rss-edb730e696fe------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*-IDujvHP6YFICIQSeujYVQ.jpeg</url>
            <title>Stories by 홍창남(Hong, Chang Nam) on Medium</title>
            <link>https://medium.com/@codenamehong?source=rss-edb730e696fe------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 03:23:41 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@codenamehong" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[2018 회고]]></title>
            <link>https://medium.com/@codenamehong/2018-%ED%9A%8C%EA%B3%A0-251260d44719?source=rss-edb730e696fe------2</link>
            <guid isPermaLink="false">https://medium.com/p/251260d44719</guid>
            <category><![CDATA[retrospectives]]></category>
            <category><![CDATA[programming]]></category>
            <dc:creator><![CDATA[홍창남(Hong, Chang Nam)]]></dc:creator>
            <pubDate>Mon, 28 Jan 2019 17:50:22 GMT</pubDate>
            <atom:updated>2019-01-28T17:50:22.951Z</atom:updated>
            <content:encoded><![CDATA[<p>이 회고는 2018년 한 해에 배운 것들을 중심으로 작성되었습니다.</p><h3>잘 배웠다 🧐</h3><h4>1. THTiledImageView</h4><p>2018년이 되었을 때 하고 있던 작업은 앱 프로젝트가 아니라, 오픈소스 프로젝트였다. 당시 D2에서 진행하는 대학생 오픈소스 대회에 참가하였는데, 그 때 제출한 프로젝트가 THTiledImageView이다. THTiledImageView는 용량이 큰 고화질 이미지(4K, 8K, 10K)를 빠르게 로딩하면서, 이미지에 마커 방식으로 지도처럼 여러 콘텐츠를 랜더링하는 기능을 지원하는 뷰어이다.</p><p><a href="https://github.com/TileImageTeamiOS/THStorytellingView">TileImageTeamiOS/THStorytellingView</a></p><p>여기서 구현한 기능중 이미지 타일링과 관련된 것은 아래 글에 열심히 써두었다. 😀</p><p><a href="https://hcn1519.github.io/articles/2018-03/tileImage">이미지 타일링을 통한 고해상도 이미지 로딩</a></p><p><strong>아쉬운 점 😂</strong></p><p>지금 생각해보면, 참 쓰기 어려운 오픈소스를 만들었다는 생각이 든다. 오픈소스는 쓰기 쉬운 것이 큰 장점 중 하나인데, THTiledImageView는 준비물이 많다. 이미지 타일링이란 것이 애초에 필요한 것이 많지만, 좀 더 쉽게 사용하게 만들 수 없었을까 하는 아쉬움이 남는다.</p><h4>2. GlassNavigationBar</h4><p>THTiledImageView 프로젝트를 진행하면서 모듈화에 관심이 생겼다. 이 시기에 나는 베이글이라는 앱을 만들고 있었다. 그런데 앱에 기능이 하나씩 추가 될 수록 viewController는 계속 커졌다. 내가 짠 코드임에도 불구하고 코드가 한 눈에 들어오지 않았다. 그래서 하나 둘 코드를 떼어내는 작업을 시도하였다. 그리고 viewController로부터 떼어내야 하는 대상 중 하나로 선택한 것이 navigationController이다.</p><p>아니 이미 UINavigationController와 UIViewController는 떼어져 있는데 무슨 말을 하는 것인지 싶을 수 있다. 이는 앱의 기능과 관련이 있다. 당시에 화면을 구성하면서 스크롤에 따라서 네비게이션바의 투명도가 적절히 조절되어야 하는 기능을 구현해야 했다. 이걸 어느정도 구현하고 나니 스크롤 state를 저장하는 변수들이 viewController에 매우 많이 생겨 있었다. 이 모든 값들은 viewController의 scrollViewDelegate에서 투명도 조정용으로 사용되고 있었다.</p><p>그래서 이를 viewController에서 대부분 제거한 GlassNavigationBar를 만들었다.</p><p><a href="https://github.com/hcn1519/GlassNavigationBar">hcn1519/GlassNavigationBar</a></p><p>GlassNavigationBar는 내 개인 레포에 만들어진 첫 오픈소스이다. 그래서 THTiledImageView 프로젝트 진행시 배웠던 TravisCI도 적용하고, README도 엄청 열심히 썼다. 개선할 점이 여전히 많았지만, 완성 후 앱에 적용 후 잘 동작할 때 뿌듯했다.</p><p><strong>아쉬운 점 😂</strong></p><p>상속 구조. GlassNavigationBar는 UINavigationController를 상속하여 기능을 구현하였다. 이는 다른 awesome ios에서 구현된 네비게이션 관련 라이브러리들이 이런 방식을 주로 사용해서 나도 이를 참고했다. 그런데 알다시피 Swift는 멀티 상속을 지원하지 않는다. 그래서 다른 네비게이션 라이브러리들과 함께 사용할 수 없다.😔 상속 자체가 나쁜 것은 아니다. 다만, 상속은 정말 강력한 커플링을 유발하기 때문에 신중히 선택해야 한다. 근데 그러지 못 했다.</p><p>한편, 이걸 프로토콜로 떼어 보려고 시도 해보았다. 그런데 이렇게 하면 viewController에 또다시 매우 많은 scroll state 관리 및 디자인 관련 값들이 property로 들어가야 했다. protocol extension의 default 값으로 넣기에도 애매해 보이는 것들이 엄청 많았다. 초기 디자인을 좀 더 고민했으면 더 좋은 오픈소스를 만들 수 있었을 것 같은데 그러지 못 해서 아쉽다. 손쉬운 오픈소스를 만드는 것은 참 어렵다.</p><h4>3. Protocol과 DIP</h4><p>protocol은 내가 2018년 한 해 가장 열심히 알아보고 사용한 것 중 하나다. delegate은 처음 앱을 출시했던 시절부터 썼지만, 이해가 잘 안 되던 것 중 하나다. UIKit, Foundation 등 애플의 핵심 iOS 구조가 delegate 패턴을 중심으로 구현되어 있기 때문에 delegate은 반드시 자유자재로 쓸 수 있어야 한다고 생각했다. 그리고 2018년이 끝나는 시점에서 delegate은 편하게 사용할 수 있게 된 것 같다.(물론 delegate 을 언제 어떻게 사용해야 좋은지에 대한 고민은 남아있다.)</p><p>다음으로는 protocol을 타입으로 적극적으로 사용하려고 시도하였다. Protocol Oriented Programming이라는 주제를 이해하기 위해 protocol을 타입으로 열심히 사용했다. 그래서 아래와 같은 코드들이 작성한 코드들에 많이 있다.</p><pre>// 타입에 있는 것들은 모두 protocol이다.</pre><pre>var dataSource: (MessagesDataSource &amp; ChatData &amp; ChatUpdate &amp; ChatEditable &amp; ChatterEditable) = ChatDataSource()</pre><pre>var request: (HasFictionTitle &amp; HasGenre &amp; HasImageURL &amp; HasNickname &amp; HasSysnopsis &amp; HasFanfic)?</pre><p>그리고 이런 방식이 나중에서야 OOP에서 핵심 원칙으로 언급되는 SOLID의 DIP(Dependency Inversion Principle)를 구현하는 방식 중 하나라는 것을 알게 되었다.</p><p><a href="https://clean-swift.com/dependency-inversion-a-little-swifty-architecture/">Dependency Inversion - A Little Swifty Architecture - Clean Swift</a></p><p>아쉬운 점 😂</p><p>Generic과 결합해서 protocol을 사용하면 중복되는 코드도 줄일 수 있다고 생각이 든다. 그런데.. Generic 타입을 사용하는 것은 아직도 익숙하지가 않다. 또, Swift 프로젝트를 좀 더 많이 참고했다면, 좀 더 Swift스러운 코드들을 작성하는 것을 수월하게 할 수 있지 않았을까 싶은데 그러지는 못 했다.</p><h4>4. 측정</h4><p>상반기에는 새로운 제품을 만들면서 배웠다면, 하반기에는 여기에 더불어 성능을 측정하는 것을 많이 했다. “어떤 때는 속도를 높이기 위해, 어떤 때는 메모리를 좀 더 적게 사용하기 위해, 어떤 때는 사용자의 스토리지를 적게 사용하기 위해” 등의 이유로 앱의 지표들을 측정했다. 앱 지표 측정에는 주로 Instrument를 활용했고, 메모리, 시간, 쓰레드 사용 패턴 등이 주요한 측정의 대상이 되었다. 이러한 측정에 관심이 생겨서 2018년에 메모리 측정과 관련한 WWDC 세션을 reference로 삼고자 정리도 해보았다.</p><p><a href="https://hcn1519.github.io/articles/2018-09/wwdc2018session416">iOS Memory Footprint 분석 방법</a></p><p><strong>개선이 필요해요 🤔</strong></p><p>사실 성능 측정을 해보았다고 얘기하지만, 제대로 하지 못 한 부분도 많다. 예를 들면 성능 측정에 있어서 측정하고자 하는 것 이외의 것을 통제하는 것이 정말 어렵다. 이 말은 통제 자체를 잘 하기 어렵다는 것뿐만 아니라, 통제의 기준을 잘 설정하는 것도 포함한다. 이런 부분은 2019년에도 개선해야 하는 부분이다.</p><h4>5. 미디어</h4><p>성능 측정을 하게 된 배경에는 이미지와 영상을 다루는 프로젝트가 있다. 여름에 기회가 되어 영상 앱과 비슷하게 동작하는 앱을 만드는 프로젝트를 진행하였다. 프로젝트는 대략적으로 설명하자면, 화면을 녹화하고 여기서 프레임을 추출하여 화면을 재생하고 이를 파일로 저장하는 것이다.</p><p>이미지와 영상만 다루는 프로젝트는 처음 해보았는데, 정말 이래저래 삽질을 많이 했다. 녹화 아웃풋도 처음에는 NSTimer와AVCapturePhotoOutput을 사용하는 방식으로 구현했다가, AVCaptureMovieFileOutput 을 사용하는 방식으로 변경 하였고, 최종 export 파일도 gif였다가, mov 로 변경하고 그랬다. 이 과정에서 위에서 언급했던 성능 측정을 했고, 코드를 수정하는 과정을 거쳤다.</p><h4>6. react-native</h4><p>2018년 가을 즈음부터는 현재까지 react-native를 하고 있다. 좀 더 정확히는 react-native로 새로운 앱을 만드는 것이 아니라, 기존에 존재하는 네이티브 앱에 react-native를 적용하는 작업을 배우고 적용하고 있다. react-native는 런타임에서 javascript를 실행하여 native view(UIView, UIScrollView 등)를 그리는 굉장히 독특한 라이브러리이다.</p><p>일반적으로 서버와 통신하는 네이티브 앱을 만든다고 하면 앱은 클라이언트로서 json 데이터를 서버로부터 다운로드 받고, 이를 디바이스에 그린다. 이 때 json 데이터에 따라 서로 다른 방식의 표현을 할 수 있지만, 레이아웃에 대한 분기 처리는 한정적이다. 그런데 react-native는 레이아웃을 그리는 javascript 코드 자체도 런타임에서 다운로드 받고 적용하는 방식을 사용할 수 있다. 그래서 데이터만 바뀌는 수준이 아니라 레이아웃도 코드 배포에 따라 바꿀 수 있다. 심지어는 기존 앱을 완전히 다른 앱으로 바꿀 수도 있다.(물론, 앱스토어 리젝과 같은 여러가지 제약 사항은 존재한다.)</p><p>react-native는 여러가지 면에서 놀랍다. 어떨 때는 생각보다 성능이 너무 잘 나와서 놀랍고, 어떨 때는 정말 별로라서 놀랍다. 아마 한동안은 react-native를 계속 할 것 같다. react-native는 런타임에서 무언가 바뀌는 것을 좋아하지 않는 swift의 영향으로 런타임에 변하는 것에 대한 부정적인 인식이 있던 나에게 새로운 시야를 제공하고 있다. react-native는 네이티브쪽 코드가 전부 Objective-C와 C++로 작성되어 있다. 이런 코드를 좀 더 자세히 들여다보고, 좀 더 react-native를 이해하는 것이 2019년의 큰 목표 중 하나다.</p><h3>블로그 통계 📈</h3><p>블로그 통계를 회고를 쓰면서 처음으로 제대로 보게 되었다. 기존에는 블로그에 붙여둔 GA로 간단한 월간 통계정도만 확인하고 있었는데, 연간 회고를 쓰다보니 연간 통계를 처음 살펴보게 되었다.</p><h4>2018년</h4><ul><li><strong>13,017</strong> 명의 사용자가 <strong>21,761</strong>번 블로그를 방문했다.</li><li>1년 간 <strong>14</strong>개의 글을 작성했다.</li></ul><h4>2017년</h4><ul><li><strong>4,478 </strong>명의 사용자가 <strong>7,531</strong>번 블로그를 방문했다.</li><li>1년 간 <strong>34</strong>개의 글을 작성했다.</li></ul><p>블로그 방문자 수는 1년 동안 <strong>190%</strong> 증가하였다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*saUUc2UXCKl7eiJioPGqdw.png" /></figure><p>수치는 좋아졌는데.. 2018년 글은 전체 글 중 15등이 최고이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*UD6jQ99C6PzUuAxWqGzAQg.png" /></figure><p>이 부분에 대해서 몇 가지 이유를 생각해볼 수 있는 부분이 있다.</p><ul><li>2017년 대비 2018년에는 작성한 글이 적다.</li></ul><p>사실 이 부분은 2017년보다 2018년에 더 바빠졌다 이상의 이유가 있다. 개인적으로 블로그를 쓸 때, 다른 블로그에서 쉽게 알 수 없는 부분까지 정리하고 싶은 욕구가 있다. 그런데 이런 부분이 내용이 심화될 수록 점점 찾기가 어려워졌다. 그래서 이를 찾고 직접 테스트 프로젝트를 만들어서 실험해보는 시간이 기존보다 길어지다보니 2018년에는 써놓은 draft는 많지만, 발행된 글은 적어졌다.</p><ul><li>블로그 방문자 수치는 바로 나타나지 않는다.</li></ul><p>내 블로그가 많은 사람들이 구독하는 블로그가 아니기 때문에..(구독도 RSS로 밖에 못 한다.) 블로그 방문자 수치는 1~2달 사이에도 잘 높아지지 않는다. 그럼 홍보를 해야하는데.. 그러지도 않았다. 정성들여서 열심히 쓴 글을 블로그에 올리는 것이기 때문에 당연히 많이 공유되었으면 하는 마음은 항상 가지고 있다. 홍보에 대해서는 좀 더 고민해봐야겠다.</p><p>한편, 블로그의 방문 수가 사실 많이 증가한 것도 사실이지만, 애초에 절대 수가 적은 것도 부정할 수 없다.(일간 만 단위도 쉽게 찍는 분들이 많이 보인다..) 하지만, 블로그를 쓰는 목적은 방문자가 많아져서 유명해지는 것보다 내 스스로 배운 것을 정리하고, 나중에 필요할 때 레퍼런스로 보는 용도가 더 크다.(API별 boilerplate 코드 빠르게 쓰기, 영어 문서를 두 번 읽는 시간 줄이기 등) 이런 의미에서 블로그가 참 의미 있고, 소중하다.</p><p>그리고 소소하지만, 처음 오프라인에서 뵙는 분들 중에 내 블로그를 알고 있는 사람을 2018년에 처음 만났다.️😀 추가로 전혀 모르는 분이 내 블로그 글을 공유 해주는 경우도 보게 되었다.😁 이런 분들을 볼 때는 정말 기분이 좋아진다. 2019년에도 블로그를 열심히 써야겠다.</p><h4>새로운 글 쓰기 방식의 도입 — github issue 도입</h4><p>최근에 새로운 글쓰기 방식을 도입했다. github issue에 draft를 작성하고, 다 쓴 경우에만 블로그에 옮겨서 쓰는 방식이다. 요즘 핫하다는 Notion도 써보았는데 개인적으로 github에 쓰는 방식이 더 편하다. Notion은 메모용으로 쓰려고 한다. 다음은 github issue로 글을 쓰는 방식에 대한 간략한 방법에 대한 설명이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*WC6Iu799LWE1iZad_0ToRw.png" /></figure><ul><li>두 방식 모두 마크다운을 사용하기 때문에 Copy&amp;Paste가 매우 용이하다.</li><li>이슈에 이미지를 올리면 바로 이미지 링크가 생성되어 별도로 이미지 호스팅을 할 필요가 없어진다.(매우 좋다)</li><li>슬랙을 연동시켜서 어디서든 preview를 확인하기 매우 좋다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*GvqRwFy_0NLe02SqTVor-Q.png" /></figure><p>요즘 쓰고 있는데 편해서 한 번 소개해보았다. 🤓</p><h3>회고에 대한 후기</h3><p>회고를 다쓰고 보니 참 오래 걸렸다. 쓰다보니 2019년 1월이 다 끝나간다. 나의 기술적인 성장에 대해서 리뷰하고 싶은 부분이 많았다. 그리고 나중에 이 글을 보고 이 땐 이런 것을 했구나 기억도 하고 싶었다. 2019년에 무엇을 할지도 쓸까 고민했지만, 2018년에 뭐했는지 생각하느라 힘을 다 썼다. 다만, 스스로 생각하고 있는 부분은 있기 때문에 하나씩 해나가면서 공유하려고 한다. 2018년 고생했다~ 👏</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=251260d44719" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[우아한 테크캠프 1기에 참여했습니다]]></title>
            <link>https://medium.com/@codenamehong/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC%EC%BA%A0%ED%94%84-1%EA%B8%B0%EC%97%90-%EC%B0%B8%EC%97%AC%ED%96%88%EC%8A%B5%EB%8B%88%EB%8B%A4-a11337512772?source=rss-edb730e696fe------2</link>
            <guid isPermaLink="false">https://medium.com/p/a11337512772</guid>
            <category><![CDATA[woowatechcamp]]></category>
            <category><![CDATA[internships]]></category>
            <dc:creator><![CDATA[홍창남(Hong, Chang Nam)]]></dc:creator>
            <pubDate>Sat, 02 Sep 2017 08:14:27 GMT</pubDate>
            <atom:updated>2017-09-02T08:14:27.572Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*OLEF8IZpgDm9Mx-3pQqK0g.png" /></figure><p>이번 여름 2달동안 배달의 민족 서비스를 운영하는 우아한 형제들에서 진행하는 우아한 테크캠프에 인턴으로 참여했습니다. 이 프로그램이 2기도 진행되길 기대하며 후기를 써봅니다.</p><h4>인턴을 하면 어떤 것을 얻고 싶나요?</h4><p>어떤 회사에 인턴으로 지원을 할 때 지원자 혹은 구직자의 입장에서 얻고 싶은 것은 성장, 실무 경험, 취업 기회 등 참 많습니다. 하지만 모든 회사가 지원자가 원하는 것을 주지는 않습니다. 그래서 지원자 입장에서는 나를 뽑는 회사가 어떤 생각을 가지고 인턴을 뽑는지 아는 것이 많은 도움이 됩니다.</p><p>우아한 테크캠프의 모집글은 아래 링크에서 확인해볼 수 있습니다.</p><p><a href="http://woowabros.github.io/woowabros/2017/05/15/woowa_techcamp.html">[모집] 우아한테크캠프 참가자를 모집합니다. - 우아한형제들 기술 블로그</a></p><p>위의 모집글을 처음 읽었을 때 우아한 형제들에서 테크캠프에 대해 많은 고민을 했다는 것이 느껴졌습니다. 물론 저는 이 고민이 구체적으로 어떤 것인지까지는 명확하게 알지 못합니다. 그래도 테크캠프를 진행하시는 분들이 인턴으로 참여하는 사람들을 제대로 키워보고, 함께 성장하고 싶은 마음이 많이 느껴졌습니다.</p><p>다시 인턴을 하면 얻고 싶은 것이 무엇인가에 대한 주제로 돌아가자면, 저는 성장하고 싶었습니다. 저는 기존에 경력직 개발자분들이 리드하는 팀에서 일해 본 경험이 거의 없습니다. 그러다보니 코딩 실력 자체뿐만 아니라, 좋은 협업이 어떤 것인지 아는 것들에 있어서 한계를 느끼고 있었습니다. 그래서 인턴을 한다면 현직자분들과 코드 리뷰를 하거나 좋은 개발 방법론, 협업론들에 대해서 익히고 싶었습니다.</p><p>우아한 테크 캠프가 2기도 진행된다면, 저는 저와 비슷한 고민을 하고 있는 분들에게 이 프로그램을 추천하고 싶습니다. 위에서 얘기한것들을 배우고 적용해볼 수 있는 것이 바로 우아한 테크캠프이기 때문입니다.</p><h4>테크캠프에서 어떤 것을 했나요?</h4><p>테크캠프에서는 많은 것들을 합니다. iOS 개발, 웹 프론트 개발의 트랙으로 나뉘어서 4주 동안 교육을 받고, 나머지 4주에는 iOS 2명, 웹 프론트 2명으로 팀을 꾸려서 프로젝트를 진행합니다. 이 때 교육은 (질문하면 다 알 것 같은) 코드 스쿼드의 마스터님들이 진행하여 각 파트별로 필수적으로 알아야 하는 것들에 대해 짝 코딩 실습 중심으로 교육을 받습니다. 그리고 중간중간에 협업에 필요한 git 혹은 백엔드용 AWS 지식, 데이터베이스 등에 대해서도 배웁니다.</p><p>저 같은 경우에는 iOS 개발 파트로 참여를 하였는데, 이 때 기본적인 Swift 문법 지식부터, tableView, collectionView 등을 만드는 View와 관련된 것들, NotificationCenter, Closure를 활용한 비동기 통신, App LifeCycle과 같은 iOS의 OS적인 측면에 대한 것들까지 익힐 수 있었습니다. 물론 이런 것들을 하나하나 세세하게 모든 지식을 알려주는 것은 아니고, 짚고 넘어가면서 자세한 사항은 스스로 공부할 수 있도록 환경을 만들어 주는데,(마스터님들이 알아서 찾아보라고 합니다 하하 😧) 저는 이와 같은 교육 방식이 스스로 성장할 수 있는 개발자가 되기 위해 더 많은 도움이 되는 방식이라고 생각합니다.</p><p>그리고 교육 기간 이후의 4주 동안에는 배운 것들을 바탕으로 프로젝트를 진행합니다. 이 때 그냥 프로젝트를 시작하는 것은 아니고, 협업을 위해 필요한 스크럼, 스프린트, 그라운드 룰과 같은 것들에 대해 배우고 프로젝트를 진행합니다. 또한 프로젝트는 매주 스프린트 기반으로 진행되어 월요일에 주간목표를 설정하고 금요일에 주중에 달성한 것들을 데모하고 회고하는 형태로 진행됩니다. 그리고 최종 프로젝트 데모날에는 다수의 현직자분들이 초대되어 인턴들이 만든 앱을 체험하는 자리를 갖습니다.</p><p>위의 것들은 교육과 프로젝트에 관한 것이고, 우아한 형제들과 관련된 것들도 많이 경험할 수 있습니다. 금요일마다 분야별 이사님들의 강의도 듣고, 팀마다 지정된 멘토님과의 만남도 진행되고, 매달 2~3번씩 우아한 형제들 개발자분들과 개발자 런치에도 참여하고, 피플팀 주관 행사에도 참여하고.. 등등 우아한 형제들이 어떤 회사인지 뿐만 아니라, 경력직분들로부터 많은 조언들을 들을 수 있는 자리가 많이 마련되어 있어 너무너무 좋았습니다.😀</p><p>무엇보다도 가장 좋았던 것은 나와 비슷한 일을 하는 동료 개발자 친구들을 많이 만나게 되었다는 점입니다. 함께 인턴으로 참여하는 친구들이 다들 열정이 넘쳐서 자극도 많이 받았고, 긍정적인 에너지를 나눠 가질 수 있었던 것이 참 좋았습니다.🍺</p><h4>생각보다 끝나서 아쉬운 것들이 많지는 않은데, 테크 캠프는 끝나서 아쉽습니다.</h4><p>2달동안 월요일을 제외한 날에 9시에 출근하는 것은 아침잠이 많은 저에게 쉬운 일은 아니었습니다. 하지만 회사에 가면 알고 싶었던 것을 배울 수 있고, 이것을 같이 고민하는 동료 친구들이 있어서 하루하루가 즐거웠습니다. 그래서 2달이 지나서 테크캠프가 끝난 지금은 캠프가 짧아서 아쉬운 생각이 듭니다. 그렇다고 하더라도 이게 끝은 아니라는 생각과, “2달 전 나보다 성장했어?” 라는 질문에 (작은 목소리로) “응”이라고 대답할 수 있는 스스로를 보고 즐거운 작별이라는 생각도 듭니다.😀</p><p>저에게 좋은 경험을 준 우아한 형제들, 코드스쿼드, 그리고 함께 참여했던 동기들에게 감사의 마음을 전하며, 이 후기를 마칩니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a11337512772" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[OOP — Class와 Object]]></title>
            <link>https://medium.com/@codenamehong/oop-class%EC%99%80-object-5c31f187ceed?source=rss-edb730e696fe------2</link>
            <guid isPermaLink="false">https://medium.com/p/5c31f187ceed</guid>
            <category><![CDATA[java]]></category>
            <category><![CDATA[object-oriented-design]]></category>
            <dc:creator><![CDATA[홍창남(Hong, Chang Nam)]]></dc:creator>
            <pubDate>Mon, 06 Mar 2017 16:42:22 GMT</pubDate>
            <atom:updated>2017-03-06T16:51:21.360Z</atom:updated>
            <content:encoded><![CDATA[<p>Class는 하나의 <strong>데이터 타입</strong> 입니다. 즉, Class는 배열처럼 하나의 데이터를 저장하는 공간인 것이죠. Object는 Class에서 생성되는 하나의 <strong>데이터</strong> 입니다. 조금 더 자세하게 알아보기 위해 Class와 Object에 대한 추가적인 자료를 덧붙입니다.</p><ol><li>Object는 <strong>상태</strong> 와 <strong>행동</strong> 을 지니고 있습니다. 예를 들어 개의 경우 색깔, 이름, 종 등의 <strong>상태</strong> 를 꼬리 흔들기, 짖기, 먹기 등의 <strong>행동</strong> 을 가지고 있습니다.(Instance와 Object는 <strong>거의</strong> 동의어로 사용됩니다.)</li><li>Class는 해당 유형의 Object가 지원하는 <strong>상태</strong>와 <strong>행동</strong> 을 설명하는 템플릿입니다.</li></ol><p>출처: Java tutorialspoint — Class and Object</p><p><a href="https://www.tutorialspoint.com/java/java_object_classes.html">https://www.tutorialspoint.com/java/java_object_classes.html</a></p><p>예제를 통해서 조금 더 자세히 알아보겠습니다.</p><pre>class Location{<br>  // 멤버변수<br>  private double latitude;<br>  private double longitude;<br>  // constructor<br>  public Location(double latitude, double longitude){<br>    this.latitude = latitude;<br>    this.longitude = longitude;<br>  }<br>  // 메소드<br>  public double address(){<br>    return latitude * longitude;<br>  }<br>}<br>public class Main {<br>  public static void main(String[] args){<br>  // object 생성<br>  Location myPlace = new Location(38, 129);<br>  }<br>}</pre><p>위의 예제는 <strong>Location</strong>이라는 <strong>Class</strong> 를 보여주고 있습니다. Location Class는 Location의 속성을 지닌 Object들이 어떤 속성을 지닐 수 있는지를 설명해줍니다. 여기서는 latitude, longitude(위도, 경도)의 멤버변수와 address 메소드를 Location Object가 지닐 수 있는 것을 Class가 보여주고 있습니다.</p><p>위에서 실제 Object는</p><pre>Location myPlace = new Location(38, 129);</pre><p>다음을 통해서 생성됩니다. 생성된 <strong>myPlace</strong> 는 Location Class에서 서술된 속성을 지니고 있습니다. Object 생성은 객체 생성, 인스턴스 생성으로 부르기도 합니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5c31f187ceed" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Swift Optional (2)]]></title>
            <link>https://medium.com/@codenamehong/swift-optional-2-2b64d0350eb0?source=rss-edb730e696fe------2</link>
            <guid isPermaLink="false">https://medium.com/p/2b64d0350eb0</guid>
            <category><![CDATA[swift-3]]></category>
            <category><![CDATA[swift]]></category>
            <dc:creator><![CDATA[홍창남(Hong, Chang Nam)]]></dc:creator>
            <pubDate>Mon, 27 Feb 2017 02:44:02 GMT</pubDate>
            <atom:updated>2017-02-27T02:44:02.319Z</atom:updated>
            <content:encoded><![CDATA[<p>이 글을 읽기 전에 Optional에 대한 기본 개념을 모르시는 분들은 아래 글을 먼저 읽어 주세요. 여기서는 기본적인 Optional 개념을 안다는 전제하에 Optional Chaining에 대해서만 서술합니다.</p><p><a href="https://medium.com/@codenamehong/swift-optional-1-54ae4d37ee09">Swift Optional (1)</a></p><h4>Optional Chaining 개념</h4><p>Apple에서 설명하고 있는 Optional Chaining의 정의는 다음과 같습니다.</p><blockquote>Optional chaining is a process for querying and calling properties, methods, and subscripts on an optional that might currently be nil. … Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is nil.<br> Optional Chaining이라는 것은 속성, 메소드, subscripts에 대해 질의하고, 호출하는 하나의 프로세스입니다. … 여려 개의 query가 묶여서 나타날 수 있고, 전체 연결은 하나라도 nil이라면 실패합니다.(nil 반환)</blockquote><p>일단은 감만 잡고, 아래에서 설명을 본 뒤 다시 한 번 봐보시는 것을 추천합니다.</p><pre>class Person {<br> var residence: Residence?<br>}<br>class Residence {<br> var numberOfRooms = 1<br>}<br>let john = Person()</pre><p>다음과 같은 2개의 클래스 <strong>Person</strong>과 <strong>Residence</strong>를 정의하겠습니다. 그리고 <strong>john</strong>이라는 인스턴스를 생성하였습니다. 이 때 <strong>john.residence!.numberOfRooms</strong>는 어떤 값을 가질까요? 표현이 다소 어색한가요? 하지만 이런 표현은 Swift에서 자주 쓰입니다.<br>1. <strong>john</strong>은 <strong>Person</strong> class로 선언 되었으므로 <strong>residence</strong> 변수를 가지고, 해당 변수는 <strong>Residence?</strong>형입니다.<br>2. <strong>Residence</strong> class는 <strong>numberOfRooms</strong> property를 지니고 있으므로 <strong>john</strong>부터 시작하여 <strong>numberOfRooms</strong>까지의 <strong>쿼리</strong>는 오류가 아닙니다.</p><p>하지만, 해당 코드의 결과는 에러입니다. 왜냐하면, <strong>residence</strong> 변수는 <strong>Residence?</strong>형인데, 아직 값이 없기 때문입니다.</p><pre>print(john.residence!.numberOfRooms)<br># error</pre><pre>john.residence = Residence()<br>print(john.residence!.numberOfRooms)<br># 1</pre><p>이처럼 <strong>!</strong>를 활용하여 Optional 값을 받아오는 것을 <strong>Forced unwrapping</strong>이라고 합니다. <strong>Forced unwrapping</strong>은 쉽게 에러를 낼 수 있기 때문에 항상 값이 있다고 보장할 수 있는 경우에만 사용하는 것이 권장됩니다. 그런데 <strong>Optional Chaining</strong>은 이러한 상황에서 좀 더 안전하게(nil이 안 나오도록) 코드를 짤 수 있게 해줍니다.</p><pre>if let roomCount = john.residence?.numberOfRooms {<br>  print(“residence에 값이 있습니다. 값 : \(roomCount)”)<br>} else {<br>  print(“residence is nil”)<br>}<br># residence is nil 출력</pre><p>위의 코드를 보시면 unwrap과 다르게 <strong>?</strong>(<strong>john.residence?.numberOfRooms</strong>)를 사용하는 것을 볼 수 있습니다. 이 때, <strong>if let roomCount = john.residence?.numberOfRooms</strong>은 해당 chain에(<strong>residence?</strong>와 <strong>numberOfRooms</strong>) 값이 있는지 없는지를 체크하고, <strong>하나라도</strong> 없으면 false를 반환합니다.</p><p>정리하자면,</p><blockquote>Optional Chaining은 Optional 값이 하나라도 포함되어 있는 질의의 연결(chain)을 처리하는 프로세스입니다.</blockquote><h4>Optional Chaining Drill Down</h4><p>Optional Chaining의 유용함은 복잡하게 얽혀 있는 여러 모델들의 값을 drill down하여 (있는 경우에만) 가져올 수 있게 해주고, 값이 없는 경우 값을 설정할 수 있도록 해주는 것에 있습니다. 값을 있는 경우에 가져오는 예제는 앞서 서술한 예시를 통해 나타납니다.</p><pre>if let roomCount = john.residence?.numberOfRooms {<br>  print(“residence에 값이 있습니다. 값 : \(roomCount)”)<br>} else {<br>  print(“residence is nil”)<br>}<br># residence is nil 출력</pre><p>위의 예제를 조금 변형해서 <strong>numberOfRooms</strong>의 값이 없는 경우 값을 설정할 수도 있습니다.</p><pre>let john = Person()<br>john.residence = Residence</pre><pre>if let roomCount = john.residence?.numberOfRooms {<br>  john.residence?.numberOfRooms = 3<br>}<br>print(john.residence!.numberOfRooms)<br># 3 출력</pre><p>유의할 점은 Optional chaining에 속한 값은 항상 Optional 값만을 반환한다는 것입니다. 즉,<strong> john.residence!.numberOfRooms</strong>은 <strong>Int</strong>형을 반환하는 것이 아니라, <strong>Int?</strong>형을 반환합니다. 또한, Optional 변수가 여러개 연결되어 있어도 그 값은 Optional이 중첩되는 것이 아니라, 그냥 Optional입니다. 예를 들어 <strong>john.residence?.place?</strong>(place를 String? 타입으로 가정합니다.)는 <strong>Optional(Optional(값))</strong>이 아니고, 항상(설령 Optional chain이 더 길어져도) <strong>Optional(값)</strong>의 형태를 유지합니다.</p><h4>더 볼만한 추가 자료</h4><ul><li><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID245">The Swift Programming Language (Swift 3.0.1): Optional Chaining</a></li><li><a href="http://rshankar.com/optional-bindings-in-swift/">Optional binding and Optional Chaining</a></li></ul><blockquote>참고 자료 : Apple Inc. The Swift Programming Language (Swift 3.0.1)</blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2b64d0350eb0" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Swift Optional (1)]]></title>
            <link>https://medium.com/@codenamehong/swift-optional-1-54ae4d37ee09?source=rss-edb730e696fe------2</link>
            <guid isPermaLink="false">https://medium.com/p/54ae4d37ee09</guid>
            <category><![CDATA[swift-3]]></category>
            <category><![CDATA[swift]]></category>
            <dc:creator><![CDATA[홍창남(Hong, Chang Nam)]]></dc:creator>
            <pubDate>Fri, 24 Feb 2017 19:02:17 GMT</pubDate>
            <atom:updated>2017-02-24T19:02:17.345Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/950/1*-Cxf8qykb0SmZxGjFfr0HQ.jpeg" /></figure><h4>Optionals 기본 개념</h4><p>Swift는 안전한 코딩을 할 수 있게 해주는 언어라고 알려져 있습니다. 그리고 이 안전성의 기본 바탕에 있는 중요한 요소 중 하나가 바로 Optional이라는 개념입니다. Optional은 Type casting이나 nil value 체크 등에 있어서 중요한 역할을 합니다. 이 포스팅에서는 Optional의 기본적인 의미에 대해서 알아보겠습니다.</p><p>Optional은 ‘?’을 통해 표현되는데, 그 의미는 다음과 같습니다.</p><blockquote><strong>이 변수에는 값이 들어갈 수도 있고, 아닐 수도 있어(nil)”</strong></blockquote><p>즉, nil을 표현하기 위한 수단으로 ?(물음표)를 사용한다는 것인데, 이 ?가 어떤식으로 적용이 될까요? 가장 기본적인 형태는 다음과 같습니다.</p><pre>let myFirstOptionalVar: Int?</pre><p>위처럼 변수의 타입의 뒤에 ?를 붙여주면 해당 변수는 Optional이 됩니다. Swift에서는 기본적으로 변수 선언시 nil 값이 들어가는 것을 허용하지 않습니다. 런타임 에러를 뿜는 것이 아니라, 아예 컴파일 에러를 내버립니다. 그러므로 아래에서 첫 번째 줄의 코드는 에러이고, 두 번째 줄은 Optional type(String?)으로 선언했으므로 에러가 아닙니다.</p><pre>var optionalString: String = nil<br>var optionalString: String? = nil</pre><p>다음 예시의 경우, String을 Int로 캐스팅하는 경우입니다.</p><pre>let possibleNumber = “123”<br>let convertedNumber = Int(possibleNumber)</pre><pre>print(convertedNumber)<br>// 출력 결과 : Optional(123)</pre><p>여기서 “123”은 String이기 때문에, Int(possibleNumber) 초기화에 실패합니다. 이 경우 바로 에러가 나와야한다고 생각하실 수 있지만, Swift는 이 경우 convertedNumber를 <strong>Optional Int형(Int?)</strong>으로 선언합니다.(Int가 아닙니다.)</p><h4>nil</h4><p>Swift에서 <strong>nil</strong>은 optional 변수 이외에서 사용할 수 없습니다. 그런데 iOS 개발을 할 경우 상당히 많은 부분에서 nil을 사용합니다. 그러므로 optional에 대해서 잘 알아두셔야 합니다. 또한 nil값은 따로 초기화하지 않아도 기본으로 설정됩니다.</p><pre>var optionalString: String?<br>var optionalString2: String? = nil<br>// 두 값 모두 nil</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/947/1*2VzLX3aLImVgLbrPLcUgPA.jpeg" /><figcaption>0과 nil의 차이?</figcaption></figure><p>다만 유의할 점은 Swift의 <strong>nil</strong>은 다른 언어에서 pointer가 존재하지 않는 값을 가리키는 것과는 다릅니다. Swift의 <strong>nil</strong>은 <strong>value가 없는 것</strong>을 의미합니다. 주소값 비교와 value값 비교정도로 이해하면 될 것 같습니다.</p><h4>Wrapping</h4><p>Optional에 대해 보다보면, 많은 곳에서 <strong>Wrapping</strong>이라는 개념이 나옵니다. Optional 타입은 기본적으로 wrap되어 있는 상태입니다. 즉, Optional로 선언된 변수들은 값이 있는 것인지, nil인 것인지 wrap되어 있어서 모르는 상태입니다. 그렇기 때문에(컴파일러 입장에서는 변수가 nil일 수도 있기 때문에) wrap된 상태에서는 설령 <strong>변수에 value값이 있다고 하더라도 바로 value가 출력되지 않습니다.(Swift 3.0에서 반영된 사항입니다.) </strong>아래 예제를 보시면,</p><pre>var optionalString: String? = “Hello”<br>print(optionalString)<br>// 출력 결과: Optional(“Hello”)</pre><p>이 경우, optionalString이 nil일 수도 있기 때문에, 결과값 “Hello”가 출력되지 않고, <strong>Optional(“Hello”)</strong> 가 콘솔창에 출력됩니다.</p><h4>Forced Unwrapping</h4><p>앞선 예제에서처럼 출력 결과가 <strong>Optional(“Hello”)</strong>처럼 나오는 것은 대부분의 경우 원하는 출력값이 아닙니다. 이 때 올바른 출력을 위해 사용하는 것이 <strong>!(exclamation mark)</strong>, 즉 느낌표입니다. 즉, optional로 선언했지만, <strong>무조건 변수가 있는 상황이 보장된 경우</strong> 느낌표(!)를 쓰면 우리가 원하는 Hello을 출력할 수 있습니다.</p><pre>var optionalString: String? = “Hello”<br>print(optionalString!)<br>// 출력 결과: Hello</pre><p>변수명 뒤의 느낌표는 Optional을 <strong>unwrap</strong>합니다. Optional은 <strong>unwrap</strong>된 상태에서만 값을 제대로 출력할 수 있습니다. 느낌표를 활용한 다른 예제를 살펴보겠습니다.</p><pre>let value1: String? = nil<br>let value2: String! = nil // 여기서는 에러가 아닙니다.</pre><pre>print(value) // nil 출력<br>print(value2) // error</pre><p>이 경우, value1과 value2는 모두 Optional 타입입니다. 다만 value1은 아직 wrap되어 있는 상태이므로 print에서 문제가 되지 않습니다. 다만 값이 있다면 <strong>Optional(값)</strong>형태로 출력이 될 것입니다. 다음으로 value2의 경우, 느낌표에 의해 Optional 값이 자동으로 unwrap됩니다. unwrap된 상태에서 값을 출력하면 런타임 에러가 발생합니다. 그러므로 일반적으로 위처럼 value2가 unwrap된 상태로 print하도록 놔두기보다는 if를 통해 값이 nil인 경우를 체크하고 출력을 합니다.</p><pre>let value2: String! = nil<br>if value2 != nil {<br>  print(value2)<br>}</pre><p>이번에는 헷갈릴 수 있는 예제를 봐보겠습니다.</p><pre>class Square {<br>  var sideLength: Double</pre><pre>  init(sideLength: Double){<br>    self.sideLength = sideLength<br>  }<br>}<br>// 클래스를 Optional 타입(?)으로 선언<br>// sideLength1도 Optional 타입(?)으로 선언<br>// 값 출력시 !를 쓰면 정상 출력<br>let optionalSquare1: Square? = Square(sideLength: 2.5)<br>let sideLength1 = optionalSquare1?.sideLength</pre><pre>// 클래스를 Optional 타입(?)으로 선언<br>// sideLength2를 Optional 타입(!)으로 선언<br>// 값은 unwrap 상태이므로 !가 없어도 출력(있으면 !를 2번 쓰므로 에러)<br>let optionalSquare2: Square? = Square(sideLength: 2.5)<br>let sideLength2 = optionalSquare2!.sideLength</pre><pre>// sideLength3를 Optional 타입(!)으로 선언<br>// 이를 Implicitly Unwrapped Optional이라고 부릅니다.<br>// 클래스와 sideLength3 모두 unwrap 상태이므로 !가 없어도 출력(있으면 !를 2번 쓰므로 에러)<br>let optionalSquare3: Square! = Square(sideLength: 2.5)<br>let sideLength3 = optionalSquare3!.sideLength</pre><pre>print(optionalSquare1) // Optional(Square)<br>print(optionalSquare2) // Optional(Square)<br>print(optionalSquare3) // Square<br>print(sideLength1) // Optional(2.5)<br>print(sideLength2) // 2.5<br>print(sideLength3) // 2.5<br>print(sideLength1!) // 2.5<br>print(sideLength2!) // error<br>print(sideLength3!) // error<br></pre><p>위 예제는 아래 링크에서 확인할 수 있습니다.</p><p><a href="http://stackoverflow.com/questions/24034483/what-is-an-unwrapped-value-in-swift">What is an &quot;unwrapped value&quot; in Swift?</a></p><h3>Optional Binding</h3><p>Optional Binding은 Optional 타입으로 선언된 변수에 값이 있는지 없는지를 확인할 수 있도록 해주는 기능입니다. Optional Binding을 사용하면 <strong>느낌표 없이</strong> Optional 타입의 변수 값을 출력할 수 있어서 좀 더 안전한 형태로 값을 얻을 수 있습니다. 기본적인 형태는 다음과 같습니다.</p><pre>if let 변수명 = Optional 변수 {<br> // 임시 변수에 Optional 변수의 value값이 할당됩니다.<br>}</pre><p>Optional Binding은 조금 독특한 <em>if let </em>형태의 조건문입니다. 무슨 의미인지 알기 위해 예제를 살펴 보겠습니다.</p><pre>// Optional type으로 선언한 myNumber<br>let myNumber: Int? = 1234</pre><pre>if let actualNumber = myNumber {<br> print(“\(myNumber)은 실제로 \(actualNumber)입니다.”)<br>} else {<br> print(“\(myNumber)는 변환될 수 없습니다.”)<br>}<br>// 출력 결과 : Optional(1234)은 실제로 1234입니다.</pre><pre>print(actualNumber) // error</pre><p>위의 예에서는 <strong>myNumber</strong>가 Optional 타입으로 선언되어 있습니다. 원래는 이 <strong>myNumber</strong>값을 출력하기 위해서는 !를 사용해야합니다. 하지만, Optional Binding은 먼저 이 <strong>myNumber</strong>의 값이 있는 경우와 없는 경우로 나누고, 값이 있는 경우를 <em>if let </em>조건문<em> </em>안에 넣을 수 있습니다. 여기서는 <strong>actualNumber</strong>에 <strong>myNumber</strong>의 값을 할당하고, 값이 있다면 <strong>actualNumber</strong>에 이를 넘겨주어 바로 실제 값으로 사용할 수 있도록 해줍니다. 추가적으로 <strong>actualNumber</strong>는 if문 안에서만 할당되는 로컬 변수입니다. if 밖에서는 <strong>actualNumber</strong>를 사용할 수 없습니다. 또한,</p><pre>if let firstNumber = Int(“4”), let secondNumber = Int(“42”), firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 {<br> print(“\(firstNumber) &lt; \(secondNumber) &lt; 100”)<br>}<br>// 출력 결과: 4 &lt; 42 &lt; 100</pre><p>위의 경우처럼 Optional value가 nil인지 여부와 함께 boolean 결과를 콤마로 연결해서 사용할 수도 있습니다.</p><p>저는 개인적으로 Optional Binding이 굉장히 유용한 기능이라고 생각합니다. 왜냐하면, Optional Binding이 코드를 짤 때 정말 많이 하는 “nil 체크 + nil이 아닌 경우에 새로 변수 만들기”를 1줄로 동시에 할 수 있도록 해주기 때문입니다. 실제로 상당히 많이 쓰이므로 잘 알아두시는 것이 좋습니다.</p><blockquote>Optional Binding은 Optional type의 변수에 대한 nil 체크와 로컬변수에 이 값을 할당하는 두 가지 기능을 가지고 있습니다.</blockquote><blockquote>참고 서적 및 자료 : The swift Programming Language(3.0.1), stackoverflow(what is an unwrapped value in swift)</blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=54ae4d37ee09" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Swift underscore(_)]]></title>
            <link>https://medium.com/@codenamehong/swift-underscore-90dcbec5072f?source=rss-edb730e696fe------2</link>
            <guid isPermaLink="false">https://medium.com/p/90dcbec5072f</guid>
            <category><![CDATA[swift]]></category>
            <category><![CDATA[swift-3]]></category>
            <dc:creator><![CDATA[홍창남(Hong, Chang Nam)]]></dc:creator>
            <pubDate>Thu, 23 Feb 2017 16:17:25 GMT</pubDate>
            <atom:updated>2017-02-23T16:20:17.706Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/950/1*-Cxf8qykb0SmZxGjFfr0HQ.jpeg" /></figure><h3>함수에서의 _ (underscore)</h3><p>Swift에서 함수를 보다보면 정체불명의 <strong>_</strong> 가 있습니다. 이 <strong>_</strong> 가 의미하는 것은 무엇일까요? 먼저 일반적인 함수 선언을 봐보겠습니다.</p><pre>func greet(person: String, day: String) -&gt; String {<br> return “Hello \(person), today is \(day).”<br>}<br>greet(person: “Bob”, day: “Tuesday”)</pre><p>위의 예제에서는 간단한 함수<em> </em><strong>greet</strong>이 선언되어 있습니다. 별 문제 없어 보입니다.(실제로 별 문제 없습니다.) 다음은 <strong>_</strong> 이 있는 함수를 봐보겠습니다.</p><pre>func greet(name person: String, _ day: String) -&gt; String {<br> return “Hello \(person), today is \(day).”<br>}</pre><pre>greet(“John”, on: “Wednesday”)<br></pre><p>동일한 함수 <strong>greet</strong>를 작성했는데 이번에는 <strong>_</strong> 이 있습니다. 물론 이 함수도 정상 작동합니다. 둘 사이의 차이는 무엇일까요? 눈썰미가 좋은 분들은 이미 보셨겠지만, 함수 호출에서 그 차이가 있습니다.</p><pre><br>greet(person: “Bob”, day: “Tuesday”)<br>greet(name: “John”, “Wednesday”)<br></pre><p>뭔가 다르다!</p><p>네, Swift에서는 함수를 호출할 때, 함수로 전달하는 인자(argument)의 라벨이 있어야 합니다. 즉, <strong>person: “Bob”</strong> 에서 person 부분이 있어야 한다는 것입니다. 그렇다면 <strong>person</strong> 과 <strong>day</strong> 라벨은 어디서 온 것일까요? 바로 함수 선언시 argument의 이름입니다.</p><p>Swift는 함수의 argument 앞에 특정 라벨을 붙일 것을 요구합니다. argument의 이름을 붙인다고 생각하면 쉬울 것 같습니다. 다만, 따로 라벨을 쓰지 않으면 default값으로 함수 선언시 사용한 argument를 라벨로 사용합니다.</p><p>그렇다면 두 번째 함수 호출은 어떻게 된 것일까요? 먼저 <strong>name:</strong> 부분은 argument 작성시 <strong>name person: String</strong> 부분에서 따로 라벨을 설정해준 것을 확인할 수 있습니다. 자 그 다음은 _ 입니다. 보이시나요? greet 함수 호출시 파라미터 앞에 라벨이 없습니다. 네, _ 는 이처럼 argument에 라벨을 따로 붙이고 싶지 않을 때 사용합니다. 정리하자면,</p><blockquote>Swift는 함수 호출시 넘기는 파라미터 앞에 라벨을 생략하기 위해 _ 를 사용한다.</blockquote><pre><br>func iGotIt(_ understand: String, _ argument: String, _ label: String) -&gt; String {<br> return “Are \(understand) \(argument) \(label)?”<br>}</pre><pre>print(iGotIt(“you”, “understand”, “label”))<br></pre><p>마지막 예제처럼 기이하게 함수를 호출해도 무슨 말인지 이해하시겠죠?</p><h4>참고 자료</h4><p><a href="http://stackoverflow.com/questions/30876068/what-is-in-swift-telling-me">What is _: in Swift telling me?</a></p><h3>for loop에서의 _ (underscore)</h3><p>이 _ 는 for loop에서도 종종 발견됩니다.</p><pre><br>for _ in 0..&lt;4 {<br> print(“hello”)<br>}<br>for index in 0..&lt;4 {<br> print(“hello \(index)”)<br>}<br></pre><p>위의 _ 는 for loop에서 인덱스를 할당하지 않겠다는 의미로 사용됩니다.</p><blockquote>내용 출처 : The swift Programming Language(3.0.1), stackoverflow(what is in swift telling me)</blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=90dcbec5072f" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[한국 OCW는.. 한국에서는 오프라인 강의부터 어떻게 해봐야되지 않나 싶어요.]]></title>
            <link>https://medium.com/@codenamehong/%ED%95%9C%EA%B5%AD-ocw%EB%8A%94-%ED%95%9C%EA%B5%AD%EC%97%90%EC%84%9C%EB%8A%94-%EC%98%A4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B0%95%EC%9D%98%EB%B6%80%ED%84%B0-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EB%B4%90%EC%95%BC%EB%90%98%EC%A7%80-%EC%95%8A%EB%82%98-%EC%8B%B6%EC%96%B4%EC%9A%94-d9670758cf45?source=rss-edb730e696fe------2</link>
            <guid isPermaLink="false">https://medium.com/p/d9670758cf45</guid>
            <dc:creator><![CDATA[홍창남(Hong, Chang Nam)]]></dc:creator>
            <pubDate>Sun, 01 Jan 2017 13:20:41 GMT</pubDate>
            <atom:updated>2017-01-01T13:20:41.170Z</atom:updated>
            <content:encoded><![CDATA[<p>한국 OCW는.. 한국에서는 오프라인 강의부터 어떻게 해봐야되지 않나 싶어요. 상대평가로 성적 가르기에 기반한 수업을 진행하다 보니, 과제도 성적 가르기 쉬운 방향으로만 만들어지고, 시험도 그렇고..</p><p>이번 학기에 우리나라에서 DataBase로 유명한 컴공과 교수님 수업을 들었는데, 강의로 배우는 건 없고 알아서 책 보고 공부해야되고, 과제랑 시험도 족보 암기로 결판이 나는걸 보면 참..</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d9670758cf45" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Coursera 강의를 듣고 있습니다.]]></title>
            <link>https://medium.com/@codenamehong/coursera-%EA%B0%95%EC%9D%98%EB%A5%BC-%EB%93%A3%EA%B3%A0-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4-2c434bacb0d4?source=rss-edb730e696fe------2</link>
            <guid isPermaLink="false">https://medium.com/p/2c434bacb0d4</guid>
            <category><![CDATA[algorithms]]></category>
            <category><![CDATA[coursera]]></category>
            <dc:creator><![CDATA[홍창남(Hong, Chang Nam)]]></dc:creator>
            <pubDate>Sun, 01 Jan 2017 07:53:20 GMT</pubDate>
            <atom:updated>2017-01-01T07:55:20.579Z</atom:updated>
            <content:encoded><![CDATA[<p>이번에 처음으로 Coursera에서 강의를 수강하고 있습니다. 제가 수강하고 있는 강의는 UC San Diego의 알고리즘 강의인데요. Coursera의 카탈로그를 살펴보면 알고리즘 강의는 Stanford와 UC San Diego의 강의가 있습니다. 이름만 보면 무조건 Stanford 강의를 듣는게 맞아 보이지만, 저는 UC San Diego 강의가 6개 코스로 이뤄져 있어(Stanford는 4개) 좀 더 깊이 배울 수 있지 않을까 싶어서 이 강의를 선택했습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*7CGK0J-G_cSnSOmXSXfPSg.png" /></figure><h3>Certificate?</h3><p>그리고 과감하게 $ 79인 certificate를 등록했습니다. certificate가 나중에 커리어 스펙으로 쓰일 수 있는지에 대해서는 검색을 좀 하다보니 <strong>“아니다, 그렇지만 쓰일 수도 있다&quot;</strong>라고 나오더군요. 이게 무슨 말인지 싶어서 좀 더 자세히 살펴 보니,</p><ol><li>Coursera의 certificate를 공식적으로 인정해주는 기관은 거의 없다, 하지만 최근 스타트업 같은 곳에서 일정 부분 인정해주는 추세가 나타나고 있다.</li><li>Coursera의 certificate를 가지고 있을 정도면, 그만큼 자연스레 내공이 쌓여서 실력으로 증명할 수 있다.</li></ol><p>정도로 요약되는 것 같습니다. 사실 인강이라는 것이 대리로 문제를 풀면 쉽게 인증이 되다보니 certificate 자체의 인증에는 한계가 있는 것 같습니다. 저는 인증 자체보다는, <strong>제한 시간 내에 강의를 충실히 듣게 만드는 용</strong>으로 돈을 지불한 이유가 커서 사실 크게 문제가 없었습니다.</p><h3>강의의 질</h3><p>제가 Coursera의 강의를 겨우 1개를 듣었지만, 지금까지의 느낀점은</p><blockquote>영어만 가능하다면, Coursera의 강의는 학부 수준을 대체할만큼 <strong>정말 좋습니다.</strong></blockquote><ol><li>영어만 가능하다면?</li></ol><p>저같은 경우 강의를 들을 때나 퀴즈를 풀 때, 영어 때문에 다소 답답함을 느낄 때가 꽤 있습니다. 제 경우를 예로 들자면, 알고리즘 증명 같은 것을 할 때, 수학적인 용어나 증명을 하면 1번 듣고서는 이해가 안 되는 경우가 많습니다. 특히, 수학을 영어로 배워본 적이 전무해서 이게 더 어렵게 느껴지는 경우가 있는 것 같습니다. 퀴즈의 경우에도 해석을 이상하게 해서 틀리는 경우가 종종 있네요..</p><p>2. 강의가 학부 수준을 대체할만 하다.</p><p>저번 학기에 현재 다니고 있는 학교에서 들은 “자료구조” 수업과 이번에 듣고 있는 Coursera의 “Algorithm toobox” 수업을 비교해서 설명해보도록 하겠습니다.</p><h4>학교의 “자료구조 수업”</h4><ol><li>오프라인 강의</li><li>수업은 매주 2번 1시간 15분씩 진행됩니다.(3학점)</li><li>수업은 대부분 수도 코드로 진행되고, 이름에 맞게 자료구조의 기본인 연결리스트, matrix부터 그래프의 DFS, BFS까지 다룹니다.</li><li>과제에 사용하는 언어는 채점 때문에 보통 1개로 정해집니다. 대부분 C인데, 이번에 저는 Java로 들었습니다.</li><li>과제는 3개가 있었고, 과제당 1~3문제씩 풀어야 합니다. 아는 사람과 같이 수강하지 않는 경우 학생간의 인터랙션은 거의 없습니다.</li></ol><h4>Coursera의 Algorithm toolbox</h4><ol><li>온라인 강의</li><li>매주 강의는 5~10분짜리 강의가 약 10~ 15개 정도 제공됩니다.(1시간 반~ 2시간 반 수준)</li><li>수업은 대부분 수도 코드로 진행되고, Data Structure를 배우기 전 왜 알고리즘을 알아야 하는가에 대해 배웁니다.</li><li>과제에 사용하는 언어는 거의 제한이 없습니다. C, C++, Java, Python을 기본으로 Ruby, Haskell, Scala까지 지원합니다.</li><li>과제가 매주 있습니다. 과제당 7문제 정도를 풀어야 pass가 됩니다. discussion에서 수강생들과 토론을 할 수 있습니다만, 실시간으로 활성화되어 있지는 않습니다. 그냥 막힐 때 힌트를 보는 수준으로만 활용 가능합니다.</li></ol><p>어떤가요? 제가 학부 수업과 Coursera 강의의 가장 큰 차이로 본 것은 2가지 입니다. 첫 번째는 강의가 온/오프라인인지 여부와 두 번째는 과제 시스템과 과제의 질입니다. 오프라인 강의는 역시 현장성으로 인해 큰 강점을 지닙니다. 오프라인 강의는 강의자와 직접적으로 교류하고 있다는 기분을 강하게 들게 하여 수업에 대한 몰입도를 크게 높여줍니다. 하지만, 저는 온라인 강의에 크게 거부감이 없다면, Coursera의 강의가 정말 좋다고 얘기하고 싶습니다.</p><h4>Coursera의 과제 시스템과 과제</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*TR9yWBn4_4x8jyKwJ49bdw.png" /></figure><p>먼저 Coursera의 과제 시스템은 깔끔합니다. 알고리즘 문제 풀이 사이트 같은 곳들에서 사용하는 컴파일러를 사용하여, 자동 채점이 진행됩니다. 문제가 많으면 최대 30분까지 채점이 걸리기도 합니다.</p><p>그리고 제가 가장 놀랐던 것은 과제의 질입니다. 제가 받은 과제는 총 7문제를 푸는 과제입니다. 수업에서 배운 기본적인 내용을 묻는 문제가 4문제, 더 생각해보아야 하는 문제(advanced)가 3문제입니다. 과제 pass의 경우 3문제만 풀어도 pass가 됩니다.</p><p>그런데 놀라웠던 것은 과제의 문제들 간의 짜임새가 훌륭했다는 점입니다. 먼저 기본 문제는 수업 내용에 매우 충실합니다. 바꿔 말하면 수업을 이해하지 못 했다면, 풀지 못 합니다. 그리고 advanced 문제는 advanced답게 기본 문제를 풀지 않았다면 건드리지 못 하는 난이도로 만들어놨습니다. 또한 advanced문제간에도 난이도 차이가 있어서 5번을 풀지 못 했다면 6번과 7번은 안 풀리도록 만들어 놨습니다. 문제들 간의 난이도와 내용 이해면에서의 긴밀한 연결이 있는 것이죠.</p><p>사실 무엇보다도 좋은 것은 Coursera의 강의에 성적 반영이 없다는 점입니다. 매번 학점 경쟁하면서 살다가 질 좋은 수업을 적당한 강제성 안에서 듣다보니 알고리즘 공부에 큰 재미를 느끼게 되네요. 그리고 관련 내용을 Github 블로그에서 정리하면서 수업을 듣고 있습니다. 관심 있으시면 한 번 둘러봐주세요~</p><p><a href="http://hcn1519.github.io/articles/2016-12/stress_testing">Stress Testing에 대하여</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2c434bacb0d4" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Go to brunch in korea]]></title>
            <link>https://medium.com/@codenamehong/go-to-brunch-in-korea-87dfa5e9e75c?source=rss-edb730e696fe------2</link>
            <guid isPermaLink="false">https://medium.com/p/87dfa5e9e75c</guid>
            <category><![CDATA[media]]></category>
            <category><![CDATA[brunch]]></category>
            <dc:creator><![CDATA[홍창남(Hong, Chang Nam)]]></dc:creator>
            <pubDate>Thu, 01 Sep 2016 01:48:51 GMT</pubDate>
            <atom:updated>2016-09-01T01:48:51.067Z</atom:updated>
            <content:encoded><![CDATA[<p>Go to brunch in korea</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=87dfa5e9e75c" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[아 이것 때문에 워드프레스로… 안정적인 서비스는 참 힘듭니다.. ㅠㅠ]]></title>
            <link>https://medium.com/@codenamehong/%EC%95%84-%EC%9D%B4%EA%B2%83-%EB%95%8C%EB%AC%B8%EC%97%90-%EC%9B%8C%EB%93%9C%ED%94%84%EB%A0%88%EC%8A%A4%EB%A1%9C-%EC%95%88%EC%A0%95%EC%A0%81%EC%9D%B8-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%8A%94-%EC%B0%B8-%ED%9E%98%EB%93%AD%EB%8B%88%EB%8B%A4-%E3%85%A0%E3%85%A0-317b62e48860?source=rss-edb730e696fe------2</link>
            <guid isPermaLink="false">https://medium.com/p/317b62e48860</guid>
            <dc:creator><![CDATA[홍창남(Hong, Chang Nam)]]></dc:creator>
            <pubDate>Fri, 19 Feb 2016 15:51:24 GMT</pubDate>
            <atom:updated>2016-02-19T15:51:24.853Z</atom:updated>
            <content:encoded><![CDATA[<p>아 이것 때문에 워드프레스로… 안정적인 서비스는 참 힘듭니다.. ㅠㅠ</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=317b62e48860" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>