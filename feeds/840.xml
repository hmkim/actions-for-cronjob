<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jello's development blog</title>
    <description>Jello의 개발 블로그</description>
    <link>http://guswnsxodlf.github.io/</link>
    <atom:link href="http://guswnsxodlf.github.io/feed.xml" rel="self" type="application/rss+xml"/>
      <pubDate>Sun, 04 Mar 2018 14:44:09 +0000</pubDate>
    <lastBuildDate>Sun, 04 Mar 2018 14:44:09 +0000</lastBuildDate>
    <generator>Jekyll v3.6.2</generator>
    
      <item>
        <title>import 경로 길이를 줄여보자</title>
        <description>&lt;p&gt;Webpack을 사용하여 싱글 페이지 어플리케이션을 만들다 보면 필연적으로 다른 폴더의 모듈을 가져와야 한다. 이 때 우리는 &lt;code&gt;../../../../../components/hello&lt;/code&gt; 같이 엄청난 &lt;code&gt;../&lt;/code&gt;을 쓰게 되는데, 사소한 부분이지만 상당히 불필요하고, 자주 있는 일은 아니지만 디렉토리 구조를 변경하면 같이 변경해줘야 하고, 또 미관상(?) 좋지 않은 것 같아서 이를 해결할 수 있는 방법을 소개하려고 한다.&lt;/p&gt;

&lt;h2 id=&quot;webpack&quot;&gt;Webpack&lt;/h2&gt;

&lt;p&gt;다음 예제를 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;module.exports = {
  ...
  resolve: {
  	...
  	alias: {
	  Utilities: path.resolve(__dirname, 'src/utilities/'),
	  Templates: path.resolve(__dirname, 'src/templates/'),
	  '@': path.resolve(__dirname, 'src/')
  	}
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위처럼 Webpack의 설정 파일의 &lt;code&gt;resolve.alias&lt;/code&gt;에 이름과 경로를 넣어주면 build할 때 Key의 이름을 해달 key에 매칭된 path로 바꿔서 build 해준다. 예를 들어서,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;import main from '../../../main';
import Utility from '../../../utilities/utility';
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이런 식이었던 경로를,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;import main from '@/main';
import Utility from 'Utilities/utility';
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 깔끔하게 바꿀 수 있다.&lt;/p&gt;

&lt;p&gt;자세한 사용법은 &lt;a href=&quot;https://webpack.js.org/configuration/resolve/#resolve-alias&quot;&gt;공식 문서&lt;/a&gt;를 참고하자.&lt;/p&gt;

&lt;p&gt;하지만 이렇게 Webpack에서 편리하게 하다 보면, 하나의 의문점이 생긴다. 바로 테스트 코드가 있는 디렉토리이다. 테스트 코드는 Webpack이 아닌 테스트 패키지가 실행하므로 위와 같은 설정이 적용되지 않는다. 따라서 테스트 파일도 위와 같이 사용하려면, 테스트 패키지의 설정 파일도 별도로 설정해주어야 한다. React의 테스트에 많이 쓰이는 프레임워크인 Jest를 예로 소개하도록 하겠다.&lt;/p&gt;

&lt;h2 id=&quot;jest&quot;&gt;Jest&lt;/h2&gt;

&lt;p&gt;Jest의 설정은 package.json의 jest에서 할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;jest&quot;: {
  &quot;moduleNameMapper&quot;: {
	&quot;@(.*)$&quot;: &quot;&amp;lt;rootDir&amp;gt;/src/$1&quot;,
	&quot;^vue$&quot;: &quot;vue/dist/vue.common.js&quot;
  },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jest의 경우에는 &lt;code&gt;jest.modulNameMapper&lt;/code&gt;에 세팅하면 된다. Key에는 정규표현식이 들어가고, 테스트를 실행하면 정규표현식에 매칭된 path를 설정한 경로로 바꿔서 import 해준다. 정규 표현식의 괄호가 순서대로 각 &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, … 이고,  프로젝트의 루트 디렉토리를 사용하고 싶을 때에는 &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt;을 사용하면 된다.&lt;/p&gt;

&lt;p&gt;자세한 사용법은 &lt;a href=&quot;https://facebook.github.io/jest/docs/en/configuration.html#modulenamemapper-object-string-string&quot;&gt;공식 문서&lt;/a&gt;를 참고하자.&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://guswnsxodlf.github.io/path-alias-in-webpack-and-jest</link>
        <guid isPermaLink="true">http://guswnsxodlf.github.io/path-alias-in-webpack-and-jest</guid>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>Reselect를 이용하여 React와 Redux 최적화하기</title>
        <description>&lt;p&gt;React와 Redux를 같이 사용하면 서로의 관심사를 분리할 수 있는 좋은 조합이 된다. 하지만 어플리케이션이 복잡해질수록 설계를 제대로 해주지 않으면 성능은 떨어지기 마련이다. React에서 가장 시간이 오래 걸리는 작업 중 하나는 바로 렌더링 싸이클이다. 컴포넌트의 State나 Props가 변경되면 렌더링 싸이클이 시작된다. 이 싸이클이 불필요하게 깊숙하게 들어가는 것을 방지하기 위해서 &lt;strong&gt;ShouldComponentUpdate&lt;/strong&gt;와 &lt;strong&gt;Immutable&lt;/strong&gt; 등 여러 최적화 방법이 제안되었다. 이 글에서는 또 다른 최적화 방법 중 하나인 Reselect를 소개해보려고 한다.&lt;/p&gt;

&lt;h3 id=&quot;느린-컴포넌트&quot;&gt;느린 컴포넌트&lt;/h3&gt;

&lt;p&gt;다음 예제를 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;import React from 'react';
import { connect } from 'react-redux';
import { List } from 'Immutable';

const mapStateToProps = (state) =&amp;gt; {
	// 페이지 색
	const color = state.UIReducer.get('color');

	// 아이템 합계 계산
	const items = state.itemReducer.get('items', List());
	const totalPrice = items.reduce((acc, i) =&amp;gt; {
		return acc + (i.get('price', 0) * i.get('quantity', 0));
	});
	
	// 태스크 계산
	const tasks = state.taskReducer.get('tasks', List());
	const totalWorkingTime = tasks.reduce((acc, i) =&amp;gt; {
		return acc + (i.get('workingTime', 0));
	});

	return {
		color,
		items,
		tasks,
		totalPrice,
		totalWorkingTime,
	};
};

class SomeComponent extends React.Component {
	render() {
		...
	}
}

export default connect(mapStateToProps)(SomeComponent);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 예제는 현재 페이지의 색을 얻어오고, 아이템과 태스크를 Store로부터 얻어와서 합계를 계산한 뒤에, connect로 SomeComponent라는 컴포넌트에 그 정보를 주입시켜주는 코드이다. &lt;code&gt;items&lt;/code&gt;와 &lt;code&gt;tasks&lt;/code&gt;의 개수가 적다면 웬만큼 빠르게 동작할 것이다. 하지만 몇 천개, 몇 만개라면 상황은 달라진다.&lt;/p&gt;

&lt;p&gt;언뜻 보면 잘 짜여진 코드처럼 보이지만, 만약 페이지의 색이 변경된다면 props에서 변경이 일어날 것이고, mapStateToProps 함수가 실행되어 &lt;strong&gt;페이지의 색을 다시 가져오는 것은 물론 그것과는 전혀 상관이 없는 totalPrice와 totalWorkingTime를 다시 계산할 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;reselect&quot;&gt;Reselect&lt;/h1&gt;

&lt;p&gt;Reselect의 memoized selector를 사용하면 위의 문제를 개선할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;import { createSelector } from 'reselect';

export const getColor = (state) =&amp;gt; state.UIReducer.get('color');

export const getItems = (state) =&amp;gt; state.itemReducer.get('items');

export const getTotalPriceWithItems = createSelector(
	[ getItems ],
	(items) =&amp;gt; (
		items.reduce((acc, i) =&amp;gt; {
			return acc + (i.get('price', 0) * i.get('quantity', 0));
		});
	)
);

export const getTasks = (state) =&amp;gt; state.taskReducer.get('tasks');

export const getTotalWorkingTimeWithTasks = createSelector(
	[ getTasks ],
	(tasks) =&amp;gt; (
		tasks.reduce((acc, i) =&amp;gt; {
			return acc + (i.get('workingTime', 0));
		});
	)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;컴포넌트는 이렇게 바꾼다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;import React from 'react';
import { connect } from 'react-redux';
import { List } from 'Immutable';

import * as selectors from '../selectors';

const mapStateToProps = (state) =&amp;gt; ({
	color: selectors.getColor(state),
	items: selectors.getItems(state),
	tasks: selectors.getTasks(state),
	totalPrice: selectors.getTotalPriceWithItems(state),
	totalWorkingTime: selctors.getTotalWorkingTimeWithTasks(state),
});

class SomeComponent extends React.Component {
	render() {
		...
	}
}

export default connect(mapStateToProps)(SomeComponent);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reselect의 createSelector를 이용하여 첫 파라미터에는 간단하게 State로부터 아이템 혹은 태스크를 가져오는 함수를, 마지막 파라미터에는 이들을 변수로 받아 합계를 계산해서 돌려주는 코드를 작성했다. &lt;strong&gt;여기서 Reselect는 첫 번째 파라미터의 배열 안에 있는 함수들이 반환하는 값이 이전과 같으면 마지막 파라미터로 준 함수를 실행하지 않는다. 따라서 &lt;code&gt;color&lt;/code&gt;가 바뀐다고 해서 이전과 같은 상태인 item의 가격의 합이나 task의 시간의 합을 계산하지 않는다는 뜻이다.&lt;/strong&gt; 수 천, 수 만개의 데이터가 item이나 task에 있다고 하더라도 색을 바꾼다고 해서 시간이 그리 오래 걸리지는 않을 것이다.&lt;/p&gt;

&lt;p&gt;어플리케이션 개발 초기에 이런 최적화를 하면 후에 어플리케이션이 복잡해지더라도 쓸만한 성능을 낼 수 있다. 또한 컴포넌트와 주입될 데이터를 셀렉터로 분리해놓으면 테스트가 용이해진다는 장점이 있다.&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://guswnsxodlf.github.io/optimize-react-component-using-reselect</link>
        <guid isPermaLink="true">http://guswnsxodlf.github.io/optimize-react-component-using-reselect</guid>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>Javascript ES6의 클래스, 프로토타입 1</title>
        <description>&lt;p&gt;Javascript는 &lt;strong&gt;프로토타입 기반의 객체지향 언어&lt;/strong&gt;이다. 프로토타입 기반 언어는 클래스를 사용하지 않고, 프로토타입 체인과 클로저로 상속, 캡슐화 등을 구현할 수 있다. 그러나 클래스에 익숙한 개발자들에게 프로토타입 기반 객체 사용은 어렵고 익숙하지 않을 수 있기 때문에 ES6에서 클래스 문법이 등장했다.&lt;/p&gt;

&lt;p&gt;ES6의 클래스는 기존의 프로토타입보다 익숙한 문법을 사용한다. 알아둬야 할 것은 ES6의 클래스가 이전의 프로토타입 기반 프로그래밍과는 다른 모델을 사용하고 있는 것이 아니고, 그저 프로토타입의 &lt;strong&gt;Syntatic sugar&lt;/strong&gt;일 뿐이라는 것이다. 따라서 결국 javascript의 클래스도 함수이다.&lt;/p&gt;

&lt;p&gt;이 글에서는 javascript의 프로토타입 기반의 문법이 ES6의 클래스 문법으로 바뀌면서 생긴 새로운 개념(?)을 설명해보겠다.&lt;/p&gt;

&lt;h1 id=&quot;정의&quot;&gt;정의&lt;/h1&gt;

&lt;h3 id=&quot;es5&quot;&gt;ES5&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var Person = (function () {
  // Constructor
  function Person(name) {
    this._name = name;
  }

  // method
  Person.prototype.sayHi = function () {
    console.log('Hi! ' + this._name);
  };

  // return constructor
  return Person;
}());

var me = new Person('Lee');
me.sayHi(); // Hi! Lee.

console.log(me instanceof Person); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;프로토타입 문법으로 객체를 정의할 때에는 함수(객체)를 만든 뒤에 그 함수의 이름으로 생성자를 만들고, 프로토타입을 설정하고, 객체의 생성자를 변수에 담았다. &lt;code&gt;sayHi&lt;/code&gt; 함수를 하나만 만들어 객체의 인스턴스들이 재활용하기 위해서 프로토타입 안에 정의해 주었다.&lt;/p&gt;

&lt;h3 id=&quot;es6&quot;&gt;ES6&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class Person {
  constructor(name) {
    this._name = name;
  }

  sayHi() {
    console.log(`Hi! ${this._name}`);
  }
}

const me = new Person('Lee');
me.sayHi(); // Hi! Lee

console.log(me instanceof Person); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;클래스 문법에는 constructor라는 생성자 메소드가 있고, 프로토타입 안에 설정되었던 &lt;code&gt;sayHi&lt;/code&gt; 함수는 그냥 클래스의 scope에 정의되었다.&lt;/p&gt;

&lt;h1 id=&quot;인스턴스-생성&quot;&gt;인스턴스 생성&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class Foo {}
const foo = Foo(); // TypeError: Class constructor Foo cannot be invoked without 'new'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;클래스를 &lt;code&gt;new&lt;/code&gt; 키워드 없이 생성하려 할 경우 에러가 난다.&lt;/p&gt;

&lt;p&gt;하지만 프로토 타입의 경우 에러는 나지 않지만 문법 오류가 발생하게 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Person(name) {
    this._name = name;
}

var me = Person('Lee');
// console.log(me._name) // TypeError: Cannot read property '_name' of undefined
console.log(_name); // Lee
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Person&lt;/code&gt;을 함수로 여기고, this에 전역 객체인 window가 바인딩되어 &lt;code&gt;me._name&lt;/code&gt;는 아예 정의되지 않게 된다. 대신에 전역 객체의 &lt;code&gt;_name&lt;/code&gt;이 정의가 된다.&lt;/p&gt;

&lt;h1 id=&quot;생성자-constructor&quot;&gt;생성자 (constructor)&lt;/h1&gt;

&lt;h3 id=&quot;es5-1&quot;&gt;ES5&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Foo(num) {
   this.num = num;
}

console.log(new Foo(1)); // Foo { num: 1 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;프로토타입 문법은 객체로 사용할 함수가 생성자가 된다.&lt;/p&gt;

&lt;h3 id=&quot;es6-1&quot;&gt;ES6&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class Bar {
  constructor(num) {
    this.num = num;
  }
}

console.log(new Bar(1)); // Bar { num: 1 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;클래스 문법은 constructor라는 생성자 메소드를 제공한다. 생성자 메소드는 생략하면 &lt;code&gt;constructor() {}&lt;/code&gt;를 포함한 것과 동일하게 동작하지만 객체의 생성과 동시에 초기화는 할 수 없다.&lt;/p&gt;

&lt;h1 id=&quot;멤버-변수&quot;&gt;멤버 변수&lt;/h1&gt;

&lt;p&gt;클래스 바디에는 메소드만을 포함할 수 있다. 클래스 바디에 멤버 변수를 선언하면 SyntaxError가 발생한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class Foo {
  let name = ''; // SyntaxError
  
  constructor() {
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 멤버 변수의 선언과 초기화는 반드시 constructor 내부에서 해야 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class Foo {
  constructor(name) {
    this.name = name; // OK
  }
}

const foo = new Foo('Lee');
console.log(foo.name); // Lee
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;constructor 내부에서 선언한 멤버 변수 name은 this(클래스의 인스턴스)에 바인딩되어 있으므로 언제나 &lt;code&gt;public&lt;/code&gt;이다. ES6 class는 private, public, protected 키워드와 같은 접근 제한자를 지원하지 않는다.&lt;/p&gt;

&lt;h1 id=&quot;게터getter-세터setter&quot;&gt;게터(getter), 세터(setter)&lt;/h1&gt;

&lt;h2 id=&quot;게터getter&quot;&gt;게터(getter)&lt;/h2&gt;

&lt;p&gt;getter는 어떤 프로퍼티에 접근할 때마다 프로퍼티를 조작하는 행위가 필요할 때 사용한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;class Foo {
  constructor(arr = []) {
    this._arr = arr;
  }

  // getter: firstElem은 프로퍼티 이름과 같이 사용된다.
  // getter는 반드시 무언가를 반환하여야 한다.
  get firstElem() {
    if (this._arr.length === 0) { return null; }
    return this._arr[0];
  }
}

const foo = new Foo([1, 2]);
// 프로퍼티 firstElem에 접근하면 getter가 호출된다.
console.log(foo.firstElem); // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;세터setter&quot;&gt;세터(setter)&lt;/h2&gt;

&lt;p&gt;setter는 어떤 프로퍼티에 값을 할당할 때마다 프로퍼티를 조작하는 행위가 필요할 때 사용한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;class Foo {
  constructor(arr = []) {
    this._arr = arr;
  }

  // getter: firstElem은 프로퍼티 이름과 같이 사용된다.
  // getter는 반드시 무언가를 반환하여야 한다.
  get firstElem() {
    if (this._arr.length === 0) { return null; }
    return this._arr[0];
  }

  // setter: firstElem은 프로퍼티 이름과 같이 사용된다.
  set firstElem(elem) {
    // ...this._arr은 this._arr를 개별 요소로 분리한다
    this._arr = [elem, ...this._arr];
  }
}

const foo = new Foo([1, 2]);

// 프로퍼티 lastElem에 값을 할당하면 setter가 호출된다.
foo.firstElem = 100;

console.log(foo.firstElem); // 100
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;정적static-메소드&quot;&gt;정적(static) 메소드&lt;/h1&gt;

&lt;h3 id=&quot;es5-2&quot;&gt;ES5&lt;/h3&gt;

&lt;p&gt;Javascript에서는 프로토타입이 아닌 그 객체에 직접 정의함으로써 정적 메소드를 만들 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var Foo = (function () {
  function Foo(prop) {
    this.prop = prop;
  }
  Foo.staticMethod = function () {
    return 'staticMethod';
  };
  Foo.prototype.prototypeMethod = function () {
    return 'prototypeMethod';
  };
  return Foo;
}());

var foo = new Foo(123);

console.log(Foo.staticMethod());
console.log(foo.staticMethod()); // Uncaught TypeError: foo.staticMethod is not a function
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;es6-2&quot;&gt;ES6&lt;/h3&gt;

&lt;p&gt;ES6 에서는 static 키워드로 클래스의 정적 메소드를 정의할 수 있다. 정적 메소드는 클래스의 인스턴스화 없이 호출하며, 클래스의 인스턴스에서 호출할 수 없다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;class Foo {
  constructor(prop) {
    this.prop = prop;      
  }
  static staticMethod() {
    return 'staticMethod';
  }
  prototypeMethod() {
    return 'prototypeMethod';
  }
}

const foo = new Foo(123);

console.log(Foo.staticMethod());
console.log(foo.staticMethod()); // Uncaught TypeError: foo.staticMethod is not a function
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;참고자료&quot;&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://poiemaweb.com/es6-class&quot;&gt;http://poiemaweb.com/es6-class&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 16 Jul 2017 00:00:00 +0000</pubDate>
        <link>http://guswnsxodlf.github.io/javascript-class-and-prototype-1</link>
        <guid isPermaLink="true">http://guswnsxodlf.github.io/javascript-class-and-prototype-1</guid>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>Javascript 코드 컨벤션 자동화</title>
        <description>&lt;p&gt;두 명 이상의 개발자가 협업을 할 때에 코드 컨벤션이 맞지 않아서 불필요한 수정을 해야 하고 가독성이 떨어지는 경우가 있다. 이를 해결하기 위해서 언어별로 규칙들이 나와있어서 개발자에게 그 컨벤션을 따르도록 하는 경우도 있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/typicode/husky&quot;&gt;Husky&lt;/a&gt;, &lt;a href=&quot;https://github.com/okonet/lint-staged&quot;&gt;Lint-staged&lt;/a&gt;, &lt;a href=&quot;https://github.com/prettier/prettier&quot;&gt;Prettier&lt;/a&gt;를 이용하여 javascript 코드 컨벤션을 자동화하는 방법을 알아보자.&lt;/p&gt;

&lt;p&gt;설치는 다음과 같이 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install husky lint-staged prettier --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;husky&quot;&gt;Husky&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;깃 훅을 편하게 작성할 수 있게 도와주는 도구&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;package.json &amp;gt; scripts&lt;/strong&gt;에 다음과 같이 설정해주면 커밋과 푸시 전에 할 작업을 설정할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;{
  &quot;scripts&quot;: {
    &quot;precommit&quot;: &quot;npm test&quot;,
    &quot;prepush&quot;: &quot;npm test&quot;,
    &quot;...&quot;: &quot;...&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;lint-staged&quot;&gt;Lint-staged&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;staged된 파일들을 lint 해주는 도구&lt;/strong&gt;이다. Husky와 같이 쓰면 staged된 파일들에 대해서 특정 작업을 수행할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;{
  &quot;scripts&quot;: {
    &quot;precommit&quot;: &quot;lint-staged&quot;
  },
  &quot;lint-staged&quot;: {
    &quot;*.js&quot;: [&quot;eslint --fix&quot;, &quot;git add&quot;]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;커밋하기 전에 모든 js파일에 대해서 lint를 수행하도록 설정했다.&lt;/p&gt;

&lt;h1 id=&quot;prettier&quot;&gt;Prettier&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;코드 컨벤션을 고쳐주는 도구&lt;/strong&gt;이다. es2017을 포함해서 JSX, typescript, flow를 지원하고, 심지어 CSS, LESS, SCSS 까지 지원한다.&lt;/p&gt;

&lt;p&gt;예를 들어서 너무 긴 다음과 같은 코드를,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음과 같이 짧게 줄여준다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;foo(
  reallyLongArg(),
  omgSoManyParameters(),
  IShouldRefactorThis(),
  isThereSeriouslyAnotherOne()
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이는 prettier의 극히 일부 기능 중 하나이고, 더 많은 기능이 있다.&lt;/p&gt;

&lt;p&gt;다음과 같이 실행한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;prettier [opts] [filename ...]

prettier --single-quote --trailing-comma es5 --write &quot;{app,__{tests,mocks}__}/**/*.js&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;옵션들은 &lt;a href=&quot;https://github.com/prettier/prettier#options&quot;&gt;여기&lt;/a&gt;에서 찾아볼 수 있다.&lt;/p&gt;

&lt;p&gt;Husky, Lint-staged에 이 Prettier를 끼얹으면 비로소 코드 컨벤션을 자동화해줘서 git에 깔끔한 코드를 올려주는 &lt;strong&gt;완성체&lt;/strong&gt;가 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;{
  &quot;scripts&quot;: {
    &quot;precommit&quot;: &quot;lint-staged&quot;
  },
  &quot;lint-staged&quot;: {
    &quot;*.js&quot;: [
      &quot;prettier --write --trailing-comma es5 --single-quote true --tab-width 4&quot;,
      &quot;git add&quot;
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;커밋 전에 staged된 모든 js파일을 대상으로 콤마를 찍어주고, 홑따옴표를 사용하고, 탭의 길이가 4로 수정되도록 설정했다.&lt;/p&gt;

</description>
        <pubDate>Tue, 27 Jun 2017 00:00:00 +0000</pubDate>
        <link>http://guswnsxodlf.github.io/auto-js-code-convention</link>
        <guid isPermaLink="true">http://guswnsxodlf.github.io/auto-js-code-convention</guid>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>Redux의 ducks패턴에 대해서</title>
        <description>&lt;h1 id=&quot;ducks-pattern&quot;&gt;Ducks pattern&lt;/h1&gt;
&lt;p&gt;Redux를 사용하는 어플리케이션을 구축하다 보면 기능별로 여러 개의 액션 타입과, 액션, 리듀서 한 세트를 만들어야 한다. 이들은 관습적으로 여러 개의 폴더로 나누어져서, 하나의 기능을 수정할 때는 이 기능과 관련된 여러 개의 파일을 수정해야 하는 일이 생긴다. 여기서 불편함을 느껴 나온 것이 &lt;a href=&quot;https://github.com/JisuPark/ducks-modular-redux&quot;&gt;Ducks 구조&lt;/a&gt;이다.&lt;/p&gt;

&lt;h2 id=&quot;example&quot;&gt;Example&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// widgets.js

// Actions
const LOAD   = 'my-app/widgets/LOAD';
const CREATE = 'my-app/widgets/CREATE';
const UPDATE = 'my-app/widgets/UPDATE';
const REMOVE = 'my-app/widgets/REMOVE';

// Reducer
export default function reducer(state = {}, action = {}) {
  switch (action.type) {
    // do reducer stuff
    default: return state;
  }
}

// Action 생성자
export function loadWidgets() {
  return { type: LOAD };
}

export function createWidget(widget) {
  return { type: CREATE, widget };
}

export function updateWidget(widget) {
  return { type: UPDATE, widget };
}

export function removeWidget(widget) {
  return { type: REMOVE, widget };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;rules-of-duck-pattern&quot;&gt;rules of Duck pattern&lt;/h2&gt;
&lt;p&gt;Ducks 구조에는 몇 가지 규칙이 있다.&lt;/p&gt;

&lt;p&gt;하나의 모듈은…&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;항상&lt;/strong&gt; &lt;code&gt;reducer()&lt;/code&gt;란 이름의 함수를 &lt;code&gt;export default&lt;/code&gt; 해야한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;항상&lt;/strong&gt; 모듈의 action 생성자들을 함수형태로 &lt;code&gt;export&lt;/code&gt; 해야한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;항상&lt;/strong&gt; &lt;code&gt;npm-module-or-app/reducer/ACTION_TYPE&lt;/code&gt; 형태의 action 타입을 가져야한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;어쩌면&lt;/strong&gt; action 타입들을 &lt;code&gt;UPPER_SNAKE_CASE&lt;/code&gt;로 &lt;code&gt;export&lt;/code&gt; 할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;Ducks 구조가 관습적인 구조와 비교하여 가지는 차이점은, 구조 중심이 아니라 기능(모듈) 중심으로 파일을 나눈다는 것이다. 이 구조가 가지는 장점은, 단일 기능을 작성할 때나 바뀌었을 때에 하나의 파일만 다루면 되므로 좀 더 직관적인 코드 작성이 가능하다는 것이다. (&lt;a href=&quot;https://github.com/erikras/react-redux-universal-hot-example/commit/3fdf194683abb7c40f3cb7969fd1f8aa6a4f9c57&quot;&gt;코드가 직관적이고 읽기 쉽게 변했다.&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/investtools/extensible-duck&quot;&gt;extensible-duck&lt;/a&gt;, &lt;a href=&quot;https://github.com/PlatziDev/redux-duck&quot;&gt;redux-duck&lt;/a&gt; 같은 구현체가 있으니 사용해보면 괜찮을 것 같다.&lt;/p&gt;

</description>
        <pubDate>Wed, 21 Jun 2017 00:00:00 +0000</pubDate>
        <link>http://guswnsxodlf.github.io/redux-ducks-pattern</link>
        <guid isPermaLink="true">http://guswnsxodlf.github.io/redux-ducks-pattern</guid>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>책 [객체지향의 사실과 오해]</title>
        <description>&lt;figure&gt;
   &lt;img src=&quot;/media/img/essence-of-object-orientation-01.jpg&quot; /&gt;
   &lt;figcaption&gt;객체지향의 사실과 오해&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;친구가 추천해줘서 읽어보았다. 책이 그렇게 두껍지 않고, 글자 크기도 다른 전공책보다 상대적으로 커서 금방 읽겠지 하고 천천히 읽다가 거의 한 달만에 겨우 끝냈다. 코드보다는 개념 위주이고, UML과 이해를 돕는 삽화가 많아서 지루하지 않게 읽을 수 있었다. 깊게 배운 적은 없지만, 내가 지금까지 배워왔던 객체지향의 설계 방법과 원리를 깨고 새롭고 강력한 패러다임을 가르쳐준 책이다.&lt;/p&gt;

&lt;p&gt;객체지향 하면 많은 사람들이 클래스를 제일 먼저 떠올릴 것이다. 실제로 많은 책이나 강의가 클래스가 가장 중요한 개념이라고 가르치고 있고, 객체지향 언어를 처음 입문할 때에 절차지향과 다르게 배우는 것이 바로 클래스라는 개념이기 때문이다. 나도 이 책을 읽기 전에 그랬고, 읽고 나서인 지금도 여전히 객체지향 하면 클래스부터 떠오른다. 하지만 정말 객체지향이 의미하는 것이 무엇인지는 알게 되었다. 클래스는 그저 객체지향을 실현시킬 수 있게 도와주는, 객체의 정보를 명시해놓은, 객체를 찍어내는 도구에 불과하다. 클래스를 쓰기만 한다고 해서 객체지향이 아니고, 클래스를 쓰지 않는 언어(Javascript)에도 객체지향을 적용할 수 있다.&lt;/p&gt;

&lt;p&gt;이 책에서는 시스템을 설계할 때에 &lt;strong&gt;책임 주도 설계(Responsibility-Driven Design)&lt;/strong&gt;라는 방법론을 소개하고 있다. 모든 것은 책임과 협력에 따라 설계되어야만 한다는 것이다. &lt;em&gt;객체지향 시스템에서 객체는 고립된 존재가 아니며, 시스템의 더 큰 목표를 달성하기 위해 다른 객체와 협력하는 사회적인 존재다 (객체지향의 사실과 오해, 131).&lt;/em&gt; &lt;strong&gt;결국 객체지향은 시스템이 사용자의 궁극적인 목표를 달성할 수 있도록 책임을 분배한 후, 각 객체에게 물려주어 협력함으로써 그 목적을 이루도록 하는 구조로 설계되어야 한다.&lt;/strong&gt; 이렇게 되면 시스템은 기능 변경에 대응하기 쉬워지고 확장성있게 설계될 수 있다.&lt;/p&gt;

&lt;p&gt;객체는 무조건(다른 객체와 협력해서라도) 다른 객체 혹은 사용자로부터 명령받은 역할을 수행해야 하는데, 이를 수행하는 방법에 대해서는 자율성을 보장받고 은닉되어야 한다(캡슐화). 즉, &lt;strong&gt;각 객체의 내부적인 프로세스가 시스템 전체의 프로세스에 독립적이어야 한다는 말이다.&lt;/strong&gt; 어떤 객체가 동일한 메시지를 받을 수 있는 다른 객체로 대체되어도 전체 시스템에는 영향을 주지 않는 구조가 되어야 한다.&lt;/p&gt;

&lt;p&gt;객체를 설계할 때에는 그 객체가 가지고 있어야 하는 상태(변수)가 아닌 외부적으로 어떤 행동을 해야하는지(역할, 메소드)부터 생각해야 한다. 객체가 어떤 행동을 해야할지 정해지지 않았는데 객체가 무엇을 알아야 하는지부터 정한다는 것은 비효율적이고 잘못된 설계를 초래할 수 있다.&lt;/p&gt;

&lt;p&gt;개인적으로 CS관련 지식이 부족하다고 생각하고 있는데, 부족한 부분 중 일부분을 채워준 것 같아서 만족스러웠다. 요즘에 개발자의 기본 소양이라고 할 수 있는 이러한 지식들이나 알고리즘 등의 필요성에 대해서 말이 많은데, 더 크게 성장하기 위해서는 이런 것들이 뒷받침되어야한다고 생각한다.&lt;/p&gt;
</description>
        <pubDate>Sun, 11 Jun 2017 00:00:00 +0000</pubDate>
        <link>http://guswnsxodlf.github.io/essence-of-object-orientation</link>
        <guid isPermaLink="true">http://guswnsxodlf.github.io/essence-of-object-orientation</guid>
        
        
        <category>Review</category>
        
      </item>
    
      <item>
        <title>유용한 AMP 컴포넌트 소개</title>
        <description>&lt;p&gt;웹 어플리케이션을 개발할 때에 로딩 시간은 중요한 부분을 차지한다. 이를 서비스할 때에 로딩 시간이 길어지면 사용자들은 기다리지 않고 바로 이탈해버리기 때문이다. 실제로 한 대형 이커머스 서비스를 조사한 결과, 웹 페이지의 이탈율이 초당 2.7%씩 증가하고, 15초가 넘어서면 50%까지 도달하게 된다. 이처럼 로딩 시간은 상당히 중요한 이슈인데, 구글은 모바일 페이지 로딩 시간을 획기적으로 단축시킬 수 있는 &lt;a href=&quot;https://www.ampproject.org/&quot;&gt;AMP(Accelerated Mobile Pages) 프로젝트&lt;/a&gt;를 진행하고 있기도 하다. 실제로 페이스북이나 구글에서 AMP를 이용해 만들어진 페이지를 들어가보면 웹 로딩이 아니라 네이티브로 만들어진 것처럼 로딩 시간은 거의 느껴지지 않고 빠르게 렌더링된다.&lt;/p&gt;

&lt;p&gt;이 AMP 페이지를 개발하는 데에는 &lt;strong&gt;제약&lt;/strong&gt;이 따른다. CSS는 무조건 헤더에 선언해야 하고, &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;로 가져오는 것도 안된다. inline으로 태그에 스타일을 주는 것도 안된다. Javascript 또한 외부에서 가져오는 것은 AMP에서 제공하는 컴포넌트만 가능하며, 이외의 소스는 가져올 수 없다. 또한 &lt;code&gt;&amp;lt;amp-img&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;amp-video&amp;gt;&lt;/code&gt; 같은 &lt;a href=&quot;https://www.ampproject.org/ko/docs/reference/components&quot;&gt;전용 태그&lt;/a&gt;를 사용한다. 이외에도 크고 작은 제약 사항이 많이 있다.&lt;/p&gt;

&lt;p&gt;그렇다고 AMP를 개발할 때 순수 javascript만을 사용해야 하는 것은 아니다. 물론 정적인 페이지를 빠르게 로딩하기 위해 나온 프로젝트지만 이미지 슬라이더, 모달(lightbox) 등 나쁘지 않은 컴포넌트들을 제공하고 있다. &lt;del&gt;사실 이것도 제공하지 않으면 아무도 AMP를 안 쓸 것 같다.&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;amp-img&amp;gt;&lt;/code&gt;나 &lt;code&gt;&amp;lt;amp-video&amp;gt;&lt;/code&gt;도 컴포넌트의 일종인데, 기존 태그들과 쓰임새가 비슷하여 생략하고 몇 가지 유용한 컴포넌트를 소개해보려고 한다.&lt;/p&gt;

&lt;h2 id=&quot;amp-accordion&quot;&gt;amp-accordion&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://ampbyexample.com/components/amp-accordion/&quot;&gt;문서&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;누르면 아래에 내용이 보이는 컴포넌트.&lt;/strong&gt; 헤더에 다음을 추가함으로써 사용할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;lt;script async custom-element=&quot;amp-accordion&quot; src=&quot;https://cdn.ampproject.org/v0/amp-accordion-0.1.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;amp-accordion&amp;gt;&lt;/code&gt; 태그를 이용하면 아래와 같이 간편하게 accordion을 만들 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;amp-accordion&amp;gt;
  &amp;lt;section expanded&amp;gt;
    &amp;lt;h4&amp;gt;Section 1&amp;lt;/h4&amp;gt;
    &amp;lt;p&amp;gt;Bunch of awesome content.&amp;lt;/p&amp;gt;
  &amp;lt;/section&amp;gt;
  &amp;lt;section&amp;gt;
    &amp;lt;h4&amp;gt;Section 2&amp;lt;/h4&amp;gt;
    &amp;lt;div&amp;gt;Bunch of even more awesome content. This time in a
      &amp;lt;code&amp;gt;&amp;amp;lt;div&amp;amp;gt;&amp;lt;/code&amp;gt;.&amp;lt;/div&amp;gt;
  &amp;lt;/section&amp;gt;
  &amp;lt;section&amp;gt;
    &amp;lt;h4&amp;gt;Section 3&amp;lt;/h4&amp;gt;
    &amp;lt;figure&amp;gt;
      &amp;lt;amp-img src=&quot;/img/amp.jpg&quot;
        width=&quot;1080&quot;
        height=&quot;610&quot;
        layout=&quot;responsive&quot;
        alt=&quot;an image&quot;&amp;gt;&amp;lt;/amp-img&amp;gt;
      &amp;lt;figcaption&amp;gt;Images work as well.&amp;lt;/figcaption&amp;gt;
    &amp;lt;/figure&amp;gt;
  &amp;lt;/section&amp;gt;
&amp;lt;/amp-accordion&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;figure&gt;
   &lt;img src=&quot;/media/img/useful-amp-components-01.png&quot; /&gt;
   &lt;figcaption&gt;Section 1을 누른 모습&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;Section 1&lt;/code&gt;을 누르니 아래에 그에 따른 내용이 나오는 것을 확인할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;amp-image-lightbox&quot;&gt;amp-image-lightbox&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://ampbyexample.com/components/amp-image-lightbox/&quot;&gt;문서&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이미지를 클릭 혹은 탭하면 화면에 가득 차며 크게 볼 수 있는 컴포넌트.&lt;/strong&gt; 헤더에 다음을 추가해서 사용할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;lt;script async custom-element=&quot;amp-accordion&quot; src=&quot;https://cdn.ampproject.org/v0/amp-image-lightbox-0.1.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래와 같이 lightbox를 위한 태그를 추가하고, &lt;code&gt;&amp;lt;amp-img&amp;gt;&lt;/code&gt; 태그에 &lt;code&gt;on=[lightbox id]&lt;/code&gt;와 &lt;code&gt;tabindex=&quot;0&quot;&lt;/code&gt;를 추가하면 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;amp-image-lightbox id=&quot;lightbox1&quot;
  layout=&quot;nodisplay&quot;&amp;gt;&amp;lt;/amp-image-lightbox&amp;gt;

&amp;lt;amp-img on=&quot;tap:lightbox1&quot;
  role=&quot;button&quot;
  tabindex=&quot;0&quot;
  src=&quot;/img/Hovawart.jpg&quot;
  alt=&quot;Picture of a dog&quot;
  title=&quot;Picture of a dog, view in lightbox&quot;
  layout=&quot;responsive&quot;
  width=&quot;600&quot;
  height=&quot;400&quot;&amp;gt;&amp;lt;/amp-img&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;figure&gt;
   &lt;img src=&quot;/media/img/useful-amp-components-02.png&quot; /&gt;
   &lt;figcaption&gt;사진을 누르면 확대된다&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;amp-carousel&quot;&gt;amp-carousel&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://ampbyexample.com/components/amp-carousel/&quot;&gt;문서&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;간단한 이미지 슬라이더.&lt;/strong&gt; 헤더에 다음을 추가해서 사용할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;lt;script async custom-element=&quot;amp-accordion&quot; src=&quot;https://cdn.ampproject.org/v0/amp-carousel-0.1.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;amp-carousel&amp;gt;&lt;/code&gt;태그 안에 이미지 태그를 넣어주면 간단히 구현할 수 있다. &lt;strong&gt;이미지 태그에 &lt;code&gt;amp-image-lightbox&lt;/code&gt;를 적용하는 것도 가능하다.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;amp-carousel height=&quot;300&quot;
  layout=&quot;fixed-height&quot;
  type=&quot;carousel&quot;&amp;gt;
  &amp;lt;amp-img src=&quot;/img/image1.jpg&quot;
    width=&quot;400&quot;
    height=&quot;300&quot;
    alt=&quot;a sample image&quot;&amp;gt;&amp;lt;/amp-img&amp;gt;
  &amp;lt;amp-img src=&quot;/img/image2.jpg&quot;
    width=&quot;400&quot;
    height=&quot;300&quot;
    alt=&quot;another sample image&quot;&amp;gt;&amp;lt;/amp-img&amp;gt;
  &amp;lt;amp-img src=&quot;/img/image3.jpg&quot;
    width=&quot;400&quot;
    height=&quot;300&quot;
    alt=&quot;and another sample image&quot;&amp;gt;&amp;lt;/amp-img&amp;gt;
&amp;lt;/amp-carousel&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;figure&gt;
   &lt;img src=&quot;/media/img/useful-amp-components-03.png&quot; /&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;amp-pixel&quot;&gt;amp-pixel&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://ampbyexample.com/components/amp-pixel/&quot;&gt;문서&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;페이지뷰 카운트를 할 때에 유용한 컴포넌트.&lt;/strong&gt; 로드될 때마다 해당 URL로 GET 요청을 보낸다. AMP js에 내장되어있어 따로 가져올 필요가 없다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;amp-pixel&amp;gt;&lt;/code&gt; 태그에 작성한 url으로 GET 요청을 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;amp-pixel src=&quot;https://ampbyexample.com/tracker/foo&quot;
  layout=&quot;nodisplay&quot;&amp;gt;&amp;lt;/amp-pixel&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;amp-var-substitutions&lt;/code&gt;를 이용해서 다음과 같이 url에 파라미터로 변수를 넣을 수 있다고 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;amp-pixel src=&quot;https://ampbyexample.com/tracker/foo?redirectTime=REDIRECT_TIME&amp;amp;sourceHost=SOURCE_HOSTNAME&amp;amp;viewer=VIEWER&quot;
  layout=&quot;nodisplay&quot;&amp;gt;&amp;lt;/amp-pixel&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 외에도 &lt;a href=&quot;https://ampbyexample.com/&quot;&gt;AMP Example&lt;/a&gt;에 더 많은 컴포넌트와 그에 따른 예제들이 나와있으므로 AMP 페이지를 개발할 때 찾아보면 좋을 듯하다.&lt;/p&gt;
</description>
        <pubDate>Mon, 29 May 2017 00:00:00 +0000</pubDate>
        <link>http://guswnsxodlf.github.io/useful-amp-components</link>
        <guid isPermaLink="true">http://guswnsxodlf.github.io/useful-amp-components</guid>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>React DOM diff 알고리즘</title>
        <description>&lt;p&gt;React를 사용할 때, &lt;code&gt;render()&lt;/code&gt;함수는 react의 새로운 엘리먼트를 반환한다. state나 prop이 바뀌어서 &lt;code&gt;render()&lt;/code&gt;단계에서 다시 새로운 엘리먼트를 반환한다. 여기서 새롭게 렌더링이 될 때, react는 &lt;strong&gt;DOM diff 알고리즘&lt;/strong&gt;을 이용해 효율적으로 UI를 업데이트한다.&lt;/p&gt;

&lt;p&gt;일반적으로 사용되는 트리를 다른 트리로 바꾸는 알고리즘은 &lt;strong&gt;O(n&lt;sup&gt;3&lt;/sup&gt;)&lt;/strong&gt;의 알고리즘을 가지고 있어서, react는 그들만의 휴리스틱한 알고리즘을 만들었다. 이 알고리즘의 시간복잡도는 &lt;strong&gt;O(n)&lt;/strong&gt;이다.&lt;/p&gt;

&lt;h1 id=&quot;dom-diff-알고리즘&quot;&gt;Dom diff 알고리즘&lt;/h1&gt;

&lt;h2 id=&quot;다른-타입의-요소일-때&quot;&gt;다른 타입의 요소일 때&lt;/h2&gt;

&lt;p&gt;렌더링된 DOM 트리가 전의 것과 비교해서 다른 타입의 요소일 때에, 전의 것은 없어지고 새로운 것을 완전히 새롭게 렌더링한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 전 --&amp;gt;
&amp;lt;div&amp;gt;
  &amp;lt;Counter /&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;!-- 후 --&amp;gt;
&amp;lt;span&amp;gt;
  &amp;lt;Counter /&amp;gt;
&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예를 들어, 위의 경우에는 &lt;code&gt;div&lt;/code&gt;와 &lt;code&gt;span&lt;/code&gt;이 다른 타입이므로 &lt;code&gt;Counter&lt;/code&gt;는 언마운트되고, 새로운 &lt;code&gt;Counter&lt;/code&gt;가 마운트된다.&lt;/p&gt;

&lt;h2 id=&quot;같은-타입의-dom-엘리먼트일-때&quot;&gt;같은 타입의 DOM 엘리먼트일 때&lt;/h2&gt;

&lt;p&gt;바뀐 요소가 같은 타임의 DOM 엘리먼트(&lt;code&gt;div&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;img&lt;/code&gt; 등)일 때에는 react가 그 엘리먼트의 property의 바뀐 부분만 감지하여 변경한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;
&amp;lt;!-- 전 --&amp;gt;
&amp;lt;div className=&quot;before&quot; title=&quot;stuff&quot; /&amp;gt;

&amp;lt;!-- 후 --&amp;gt;
&amp;lt;div className=&quot;after&quot; title=&quot;stuff&quot; /&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같은 경우에 react는 div의 className만 변경된 것을 감지하고, 전체를 바꾸지 않고 className만 변경한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 전 --&amp;gt;
&amp;lt;div style= /&amp;gt;

&amp;lt;!-- 후 --&amp;gt;
&amp;lt;div style= /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같이 style의 &lt;code&gt;color&lt;/code&gt;만 바뀐 경우에 react는 &lt;code&gt;fontWeight&lt;/code&gt;를 포함한 style의 전체를 바꾸지 않고, &lt;code&gt;color&lt;/code&gt;만 변경한다.&lt;/p&gt;

&lt;h2 id=&quot;같은-타입의-컴포넌트-엘리먼트일-때&quot;&gt;같은 타입의 컴포넌트 엘리먼트일 때&lt;/h2&gt;

&lt;h3 id=&quot;자식-엘리먼트-순회&quot;&gt;자식 엘리먼트 순회&lt;/h3&gt;

&lt;p&gt;React는 자식 엘리먼트를 순회하면서 차이가 있을 때마다 변경한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 전 --&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;first&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;second&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;

&amp;lt;!-- 후 --&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;first&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;second&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;third&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예를 들어 엘리먼트 트리의 변화가 위와 같을 때에, react는 첫번째 &lt;code&gt;&amp;lt;li&amp;gt;first&amp;lt;/li&amp;gt;&lt;/code&gt;를 비교하고, 두번째 &lt;code&gt;&amp;lt;li&amp;gt;second&amp;lt;/li&amp;gt;&lt;/code&gt;를 비교하고, &lt;strong&gt;세번째에서 &lt;code&gt;&amp;lt;li&amp;gt;third&amp;lt;/li&amp;gt;&lt;/code&gt;를 삽입할 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;하지만 다음 예제를 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 전 --&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;first&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;second&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;

&amp;lt;!-- 후 --&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;Something&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;first&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;second&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같이 자식의 첫 번째에 새로운 엘리먼트가 삽입된 경우에 react는 모든 자식 엘리먼트들을 변경함으로써 낮은 퍼포먼스를 보이게 될 것이다.&lt;/p&gt;

&lt;h3 id=&quot;key&quot;&gt;Key&lt;/h3&gt;

&lt;p&gt;위와 같은 문제를 해결하기 위해서 react는 &lt;code&gt;key&lt;/code&gt; 어트리뷰트를 지원한다. React는 &lt;code&gt;key&lt;/code&gt;를 통해서 엘리먼트들을 비교한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 전 --&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li key=&quot;1&quot;&amp;gt;first&amp;lt;/li&amp;gt;
  &amp;lt;li key=&quot;2&quot;&amp;gt;second&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;

&amp;lt;!-- 후 --&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li key=&quot;0&quot;&amp;gt;Something&amp;lt;/li&amp;gt;
  &amp;lt;li key=&quot;1&quot;&amp;gt;first&amp;lt;/li&amp;gt;
  &amp;lt;li key=&quot;2&quot;&amp;gt;second&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같이 &lt;code&gt;key&lt;/code&gt;를 심어주면 react는 &lt;code&gt;&amp;lt;li key=&quot;0&quot;&amp;gt;Something&amp;lt;/li&amp;gt;&lt;/code&gt;가 새롭게 추가된 엘리먼트임을 인식할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;key&lt;/code&gt;는 부모 엘리먼트 안에서만 유일하면 된다 (전역에서 유일할 필요는 없다). 안정적이지 못한 값(Math.random() 등)을 사용하면 성능이 저하될 수 있다.&lt;/p&gt;
</description>
        <pubDate>Mon, 15 May 2017 00:00:00 +0000</pubDate>
        <link>http://guswnsxodlf.github.io/react-diff-algorithm</link>
        <guid isPermaLink="true">http://guswnsxodlf.github.io/react-diff-algorithm</guid>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>React 컴포넌트 라이프사이클</title>
        <description>&lt;p&gt;React에는 컴포넌트가 생성되거나, 리렌더링 전후에 실행되는 라이프사이클 메소드가 있다. 이 함수들을 사용하여 각 이벤트가 일어날 때에 유용하게 사용할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;react-lifecycle-methods-sequence&quot;&gt;React lifecycle methods sequence&lt;/h2&gt;

&lt;p&gt;컴포넌트를 생성할 때에는 다음과 같은 순서로 메소드가 실행된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;constructor&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;componentWillMount&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;render&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;componentDidMount&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;컴포넌트를 제거할 때에는 다음 메소드만 실행된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;componentWillUnmount&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;컴포넌트의 state가 변경될 때(setState)에는 다음과 같은 순서로 메소드가 실행된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;shouldComponentUpdate&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;componentWillUpdate&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;render&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;componentDidUpdate&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;컴포넌트의 props가 변경될 때에는 다음과 같은 순서로 메소드가 실행된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;componentWillReceiveProps&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;[state가 변경될 때와 같음]&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;lifecycle-methods&quot;&gt;Lifecycle methods&lt;/h2&gt;

&lt;h4 id=&quot;contructorprops&quot;&gt;Contructor(props)&lt;/h4&gt;

&lt;p&gt;생성될 때 전달받은 props가 매개변수로 전달된다. constructor를 이용하여 props를 가공해 초기 state를 설정하기 편리하다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;constructor(props) {
  // React.Component 클래스로부터 상속받을 경우
  super(props);
  
  this.state = {
    color: props.initialColor
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;componentwillreceivepropsnextprops&quot;&gt;componentWillReceiveProps(nextProps)&lt;/h3&gt;

&lt;p&gt;컴포넌트가 새로운 props를 받기 전에 실행되는 메소드다. 새롭게 넘어온 props를 매개변수로 받는다.&lt;/p&gt;

&lt;h3 id=&quot;shouldcomponentupdatenextprops-nextstate&quot;&gt;shouldComponentUpdate(nextProps, nextState)&lt;/h3&gt;

&lt;p&gt;가장 눈여겨봐야 할 메소드. 컴포넌트를 업데이트하기 전에 업데이트 여부를 결정하기 위해 실행된다. 새롭게 넘어온 props와 state를 매개변수로 받는다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;리턴값(true나 false)에 따라서 리렌더링의 여부가 결정된다.&lt;/strong&gt; 기본값은 true라서 불필요한 렌더링이 일어나는 컴포넌트는 작성해주면 퍼포먼스를 최적화할 수 있다. forceUpdate로 업데이트를 강제해주면 이 함수는 실행되지 않는다. 또한 false를 반환한다면 다음 순서인 componentWillUpdate, render, componentDidUpdate 메소드는 실행되지 않는다.&lt;/p&gt;

&lt;p&gt;React.Component를 상속받은 React.PureComponent를 사용하면 이 메소드는 props와 state를 얕은 비교(shallow comparison)를 하여 이전값과 이후값이 일치했을 때에 false를 반환하여 리렌더링을 막을 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;componentwillupdatenextprops-nextstate&quot;&gt;componentWillUpdate(nextProps, nextState)&lt;/h3&gt;

&lt;p&gt;컴포넌트가 업데이트되기 직전에 실행되는 메소드. shouldComponentUpdate과 같이 다음 props와 state를 매개변수로 받는다.&lt;/p&gt;

&lt;h3 id=&quot;componentdidupdateprevprops-prevstate&quot;&gt;componentDidUpdate(prevProps, prevState)&lt;/h3&gt;

&lt;p&gt;컴포넌트가 업데이트된 직후에 실행되는 메소드. 업데이트되기 전의 props와 state를 매개변수로 받는다.&lt;/p&gt;
</description>
        <pubDate>Sat, 13 May 2017 00:00:00 +0000</pubDate>
        <link>http://guswnsxodlf.github.io/react-component-lifecycle</link>
        <guid isPermaLink="true">http://guswnsxodlf.github.io/react-component-lifecycle</guid>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>webpack을 이용한 react 어플리케이션 코드 스플릿</title>
        <description>&lt;p&gt;웹 어플리케이션을 개발할 때에 로딩 시간은 중요한 부분을 차지한다. 이를 서비스할 때에 로딩 시간이 길어지면 사용자들은 기다리지 않고 바로 이탈해버리기 때문이다. 실제로 한 대형 이커머스 서비스를 조사한 결과, 웹 페이지의 이탈율이 초당 2.7%씩 증가하고, 15초가 넘어서면 50%까지 도달하게 된다. 이처럼 로딩 시간은 상당히 중요한 이슈인데, 구글은 모바일 페이지 로딩 시간을 획기적으로 단축시킬 수 있는 &lt;a href=&quot;https://www.ampproject.org/&quot;&gt;AMP(Accelerated Mobile Pages) 프로젝트&lt;/a&gt;를 진행하고 있기도 하다. 실제로 페이스북이나 구글에서 AMP를 이용해 만들어진 페이지를 들어가보면 웹 로딩이 아니라 네이티브로 만들어진 것처럼 로딩 시간은 거의 느껴지지 않고 빠르게 렌더링된다.&lt;/p&gt;

&lt;p&gt;이 로딩 시간은 &lt;strong&gt;SPA(Single Page Application)&lt;/strong&gt;에게는 약점이 될 수 있다. 한 번에 모든 데이터를 로딩한 뒤에서야 빠른 속도를 보여주기 때문이다. 따라서 초기 로딩 시간은 여러 개의 페이지를 가진 어플리케이션보다 느릴 수밖에 없는데, webpack은 이를 보완하여 초기 로딩에는 처음 보여질 화면에 필요한 컴포넌트만 로드하고, 라우팅을 할 때에 새롭게 바뀔 페이지에 필요한 컴포넌트를 로딩하게 할 수 있다.&lt;/p&gt;

&lt;p&gt;비결은 webpack에 동적 로딩을 가능하게 하는 기능이 있기 때문이다. (&lt;a href=&quot;https://webpack.js.org/guides/code-splitting-async/&quot;&gt;Webpack Code Splitting&lt;/a&gt;) 문서를 보면 여러 가지 방법이 나와 있는데, 여기서는 의존성이 가장 적은 &lt;code&gt;require.ensure()&lt;/code&gt;를 사용하겠다 (현재는 &lt;code&gt;import()&lt;/code&gt;를 쓰라고 권장하고 있다).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;require.ensure()&lt;/code&gt;의 구문은 다음과 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;require.ensure([디펜던시], function(require) {
    require(불러올 모듈 경로);
}, 나눠질 파일명);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;디펜던시는 보통 비워두고 (있는 경우를 보지 못했다), 다음 인자로 줄 함수 안에 불러올 모듈을 require 해주면 된다. 그렇게 하면 webpack이 bundling을 하는 과정에서 이를 인식하고, 파일을 나눠주는듯 하다.&lt;/p&gt;

&lt;p&gt;이 구문이 어디에 들어가야 하냐면, 바로 react-router의 &lt;code&gt;getComponent&lt;/code&gt; property이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;lt;Router history={history}&amp;gt;
    &amp;lt;IndexRoute getComponent={(loc, cb) =&amp;gt; {
        require.ensure([], (require) =&amp;gt; { cb(null, require('./containers/Home.js').default); }, 'Home');
    }}/&amp;gt;
    &amp;lt;Route path=&quot;list&quot; getComponent={(loc, cb) =&amp;gt; {
        require.ensure([], (require) =&amp;gt; { cb(null, require('./containers/List.js').default); }, 'List');
    }} onEnter={requireAuth}/&amp;gt;
    &amp;lt;Route path=&quot;login&quot; getComponent={(loc, cb) =&amp;gt; {
        require.ensure([], (require) =&amp;gt; { cb(null, require('./containers/Login.js').default); }, 'Login');
    }} onEnter={requireAnonymous}/&amp;gt;
    &amp;lt;Route path=&quot;register&quot; getComponent={(loc, cb) =&amp;gt; {
        require.ensure([], (require) =&amp;gt; { cb(null, require('./containers/Register.js').default); }, 'Register');
    }} onEnter={requireAnonymous}/&amp;gt;
&amp;lt;/Router&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;대부분 &lt;code&gt;component&lt;/code&gt; property를 사용하고 있을텐데, &lt;code&gt;getComponent&lt;/code&gt;는 함수를 값으로 받기 때문에 좀 더 동적인 설정이 가능한 것 같다. 여기서 &lt;code&gt;getComponent&lt;/code&gt;에 들어갈 함수가 반복되어서, 반복되는 함수를 생성해주는 creator 함수를 따로 만들어서 인자로 줘 봤지만, 말을 듣지 않았다. Webpack이 코드를 모두 돌려보고 파일을 나눠주지 않기 때문에 어쩌면 당연한 결과였을지도 모른다.&lt;/p&gt;

&lt;p&gt;다음으로 설정해야 할 것은 &lt;code&gt;webpack.config.js&lt;/code&gt; 파일이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;module.exports = {
    entry: {
        app: path.join(__dirname, '../app/src/routes.js')
    },
    output: {
        filename: '[name].[chunkhash].js',
        // chunkFilename을 지정해준다.
        chunkFilename: '[name].[chunkhash].js',
        path: path.join(__dirname, '../app/dist'),
    },
    module: {
        rules: [
            ...
        ]
    },
    plugins: [
        ...
    ]
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output의 &lt;code&gt;chunkFilename&lt;/code&gt;을 위와 같이 지정해주면 아래와 같이 파일이 생성된다.&lt;/p&gt;
&lt;figure&gt;
   &lt;img src=&quot;/media/img/react-code-split-using-webpack-01.png&quot; /&gt;
   &lt;figcaption&gt;[name].[chunkhash].js에 따라 생성&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;chunkhash를 사용하는 이유는, 웹 브라우저가 파일명으로 캐싱을 하게 되는데, 코드 업데이트를 할 경우에 캐싱으로 인해 변경사항이 반영되지 않을 수 있다. 따라서 해시코드를 바꿔줌으로써 bundling을 할 때마다 다른 해시코드가 파일에 붙여지게 되고, 캐싱되지 않은 새로운 파일을 불러올 수 있게 하는 것이다.&lt;/p&gt;

&lt;p&gt;이렇게 코드 스플릿을 함으로써 SPA의 초기 로딩 시간을 단축시킬 수 있다. 이 밖에도 uglify를 하거나, 모듈, 비즈니스 로직을 vendor.js, app.js로 나누어서 로드하는 등 webpack을 이용한 여러 최적화 방법이 있다.&lt;/p&gt;
</description>
        <pubDate>Sun, 07 May 2017 00:00:00 +0000</pubDate>
        <link>http://guswnsxodlf.github.io/react-code-split-using-webpack</link>
        <guid isPermaLink="true">http://guswnsxodlf.github.io/react-code-split-using-webpack</guid>
        
        
        <category>Javascript</category>
        
      </item>
    
  </channel>
</rss>
