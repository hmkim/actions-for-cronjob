<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" media="screen" href="/~d/styles/rss2full.xsl"?><?xml-stylesheet type="text/css" media="screen" href="http://feeds.feedburner.com/~d/styles/itemcontent.css"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>YoungJin Shin</title>
    <description>미세 먼지 하나 없는 새파란 하늘에 햇살 좋은 날, 배터지게 점심 먹고 아메리카노를 한손에 집어 들고, 송도 센팍을 한가롭게 노다니며 사는 인생과 발리에서 서핑이나 하다가 심심하면 웹서핑이나 하다가, 그래도 심심하면 코딩이나 하는 인생 그 사이 어디쯤인가에서 방황하는 한 인간.</description>
    <link>http://www.jiniya.net/ng/</link>
    
    <pubDate>Wed, 28 Nov 2018 19:20:16 +0900</pubDate>
    <lastBuildDate>Wed, 28 Nov 2018 19:20:16 +0900</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="self" type="application/rss+xml" href="http://feeds.feedburner.com/codewiz" /><feedburner:info xmlns:feedburner="http://rssnamespace.org/feedburner/ext/1.0" uri="codewiz" /><atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="hub" href="http://pubsubhubbub.appspot.com/" /><feedburner:emailServiceId xmlns:feedburner="http://rssnamespace.org/feedburner/ext/1.0">codewiz</feedburner:emailServiceId><feedburner:feedburnerHostname xmlns:feedburner="http://rssnamespace.org/feedburner/ext/1.0">https://feedburner.google.com</feedburner:feedburnerHostname><item>
        <title>[일상스케치] 책임진다는 말...</title>
        <description>&lt;div class="paragraph"&gt;
&lt;p&gt;오래전 일이다. 먹고 살기 힘들어 인건비 따먹기 SI 사업을 하던 때였다. 당연한 얘기지만 SI 사업에는 적은 리소스를 투입하고 최고의 효과를 얻어야 하던 시절이기도 했다. 그래야 시간이 생기고 그래야 우리 솔루션도 돌 볼 수 있기 때문이다. 그 당시 과제의 한 모듈을 담당했던 개발자가 자꾸 직접 구현해서 될 일이 아닌 것을 직접 구현하려고 했다. 문자열 인코딩을 처리해야 하는 모듈이었다. 문자열 인코딩만 본다면 개발자가 직접 구현해도 될 것 같지만 온갖 코드페이지를 다 처리해야 했기에 또 그렇게 간단하진 않은 모듈이었다. 그래서 왠만하면 오픈소스를 쓰라고 검토해서 알려주었다. 다소 C++ 중2병 환자가 만든 소스 코드 같아 보였지만 코드 내부를 봤을 때 온갖 코드페이지를 잘 처리할 수 있을 만큼 충분히 복잡하게 만들어져 있었다. 안타깝게도 문제의 개발자는 온몸으로 거부했다. 스스로 직접 구현할 수 있고, 그 소스는 너무 복잡하다고 했다. 그러고 덧붙였다. 잘못되면 책임지겠다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;뭐 뻔한 결말이지만 그 친구가 만든 코드가 잘 되지도 책임을 지지도 못했다. 직접 만든 코드는 우리가 실시한 간단한 테스트는 통과 했지만 의뢰한 업체의 온갖 테스트에는 속속 문제가 발생했다. 러시아어에서 비롯된 문제는 온갖 if문을 달아가며 언어 하나가 나올 때마다 땜빵을 해봤지만 잘 되지 않았다. 결국 처음부터 그 오픈소스 코드를 가져다 쓰는 코드로 바꾸고서야 문제가 해결됐다. 하지 않아도 될 고생을 한 것도 화가 났지만, 우리에게 천금같았던 시간을 낭비했다는 데 더 많은 울화가 치밀었다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;책임진다는 말을 우리는 너무 쉽게 하는 경향이 있다. 아마도 그 직원은 두 가지 의미에서 책임진다는 말을 했을 가능성이 높다. 1) 책임지고 그만두겠다. 2) 잘못되면 내가 그 돈을 메꾸겠다. 대체로 1번의 의도로 말하는 경향이 많지만 그건 그 어떤 것에 대한 책임도 되지 않는다. 회사 입장에서 책임이란 말은 그저 문제가 없는 상태로 일이 잘 처리되는 것 외에는 어떠한 방법도 없기 때문이다. 그런 맥락에서 2번도 해법은 아니다. 금전적 손실은 메꿀 수 있겠지만 일을 맡긴 업체와의 관계는 보상이 불가능하니 말이다. 사실 돈을 메꾼다는 것도 불가능한 상황이긴 했다. 그 친구가 숨도 안 쉬고 5년을 일해도 메꿀 수 없는 규모였다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;시간이 많이 흘렀다. 이 어리고 서툴렀던 시절의 추억담이 종종 떠오른다. 그 친구 입장에 내가 서 있다는 생각이 들어서다. "방향이 틀리면 속력은 아무런 의미가 없다"라는 간디의 말도 다시금 생각나는 요즘이다. 아주 사소한 나의 잘못된 생각 하나에 시간과 속력이 더해져 우리는 완전 엉뚱한 장소에 도착해 버렸다. 이제는 내가 잘못 생각한 일들을 책임지고 바로 잡아야 하는 시간인 것 같다는 느낌. 사실 앞서도 말했지만 책임진다는 건 그 어떤 형태로도 불가능하다. 그 말을 꺼낸 순간 우리는 책임질 수 없는 상황에 도달한 경우가 더 많이 때문이다. 그럼에도 최선을 다해야 한다. 그게 그나마 나의 잘못을 조기에 알려준 현명한 사람들에 대한 예의일테니까&amp;#8230;&amp;#8203; 머리가 나쁘면 손발이 고생이고, 똥인지 된장인지 먹어봐야 안다.&lt;/p&gt;
&lt;/div&gt;
&lt;style&gt;

.video-container
{
	position: relative;
	padding-bottom: 56.25%;
	padding-top: 35px;
	height: 0;
	overflow: hidden;
}

.video-container iframe
{
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
}

&lt;/style&gt;

&lt;div class="video-container"&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/bo_efYhYU2A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;</description>
        <pubDate>Thu, 08 Nov 2018 19:55:33 +0900</pubDate>
        <link>http://www.jiniya.net/ng/2018/11/take-responsibility</link>
        <guid isPermaLink="true">http://www.jiniya.net/ng/2018/11/take-responsibility</guid>
        
        
        <category>asciidoc</category>
        
      </item>
    
      <item>
        <title>[플밍노트] 재현 가능한 빌드, 재현 가능한 시드</title>
        <description>&lt;div class="sect2"&gt;
&lt;h3 id="0"&gt;#0&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;최근에 덤프 파일 심볼이 맞지 않는 문제가 있었다. wow64 프로세스 덤프를 뜬 건데 .reload를 해봐도 심지어 다운로드 받은 심볼을 지우고 다시 받아도, windbg를 업그레이드 해봐도 소용 없었다. 항간에 windows 10 rs4에서 심볼이 잘 안 맞춰진다는 이야기도 있어서 그런건가 싶어서 포풍 검색을 해봤지만 뾰족한 수가 없었다. 증상은 심플했는데 wow64 프로세스임에도 ntdll이 하나만 있었고, 로드된 dll 목록의 타임스탬프가 invalid라고 나왔다. 그리고 ntdll의 함수를 디스어셈블 하면 이상한 코드들이 나왔다. 여튼 그런 증상&amp;#8230;&amp;#8203; 그렇게 퇴근 시간은 다가오고 오늘의 일을 내일로 미루고 퇴근을 했다&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="1"&gt;#1&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;다음날. 덤프를 다시 열어서 방망이 깎는 노인이 그랬듯 출력되는 메시지를 한줄 한줄 꼼꼼히 쳐다 보았다. 그랬더니 이상한 점이 보였다. 덤프를 열면 통상적으로 운영체제 버전이 표기되는데 64비트 운영체제가 아니라 32비트 운영체제로 나오는 것이었다. 순간, 많은 정황을 고려해 보았을 때 덤프를 64비트 PC에서 32비트 덤프 생성 도구로 덤프를 뜬 것이 아닐까라는 생각이 들었다. 덤프를 생성한 직원에게 물어보자 그렇게 생성했다고 하길래 64비트로 다시 생성해 달라고 했다. 새롭게 만들어진 덤프은 기다렸다는 듯이 잘 동작했다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="2"&gt;#2&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;뭐 이 즈음에는 대체로 내가 원한 모든 문제는 다 해결이 되었지만 그럼에도 불구하고 찜찜한 점이 하나 있었는데, 그건 여전히 dll들의 타임스탬프가 invalid라고 나오는 문제였다. 다른 모든 것은 기대한대로 동작했지만 타임스탬프 값은 여전히 오리무중&amp;#8230;&amp;#8203; 다시 포풍 검색을 했다. 나에게 항상 해답을 주시는 &lt;a href="https://blogs.msdn.microsoft.com/oldnewthing/20180103-00/?p=97705"&gt;레이몬드 첸 횽님께서&lt;/a&gt; 벌써 올해 1월에 관련 질문에 대한 답을 올려 놓으셨다. 이렇게 바지런 하시니 몸둘 바를&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;해당 글을 통해 알게 된 썰은 이렇다. 윈도우 10부터 재현 가능한 빌드(reproducible builds)로 방향을 정했고, 그 정책의 일환으로 타임스탬프를 타임스탬프가 아닌 해시 값으로 변경했다는 것이다. 재현 가능한 빌드라는 건 한 마디로 정리하면 동일 소스 코드로 컴파일을 하면 동일 바이너리가 생성된다는 것을 보장한다는 개념이다. 즉, 니가 소스 코드를 한 줄도 안 고쳤다면 넌 어디에서건 다시 컴파일해도 동일한 바이너리를 가지게 된다는 의미다. 이렇게 하는 이유는 당연히 버그에 보다 빠르게 대응하기 위함이겠거니&amp;#8230;&amp;#8203; 내지는 높으신 분의 개취&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="3"&gt;#3&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;여기까지 오자 몇 해 전 우리에게 혁신적인 개념을 소개했던 직원의 아이디어에 대한 이름을 이제야 붙이 수 있게 되었다. 그 이름은 다름아닌 재현 가능한 시드(reproducible seed) 정도가 되겠다. 적어도 4-5년은 거슬러 올라가야 하는 이야기다. 우리는 당시 아주 난해한 버그를 마주하고 있었다. 100번 정도에 한 번씩 게임이 시작 시점에 크래시가 나는 문제였다. 지금에 비하면 아주 단촐했던 테스트 인력을 가지고 있던 당시로써는 문제를 발견해 낸 것만 해도 대단한 것이었다. 하지만 그 문제를 해결하는 것은 발견하는 것 이상의 노력이 필요했다. 재현을 하려면 100번을 실행해야 했기 때문이다. 어쨌든 그 당시 테스트 인력의 도움으로 어렵사리 덤프를 확보했다. 하지만 아무도 문제를 찾지 못했다. 딱 미제(미해결 과제)가 되기 좋은 사안이었는데 어디선가 혜성같이 등장한 구원 투수가 마법같이 문제의 원인을 알아냈다. 랜덤이 문제였다. 랜덤 결과가 특정 값이 될 경우 메모리가 오버래핑되는 문제가 있었던 것이다. 그 확률이 1/100정도 됐던 모양이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;그때 그 덤프에서 문제를 찾은 직원은 우리가 업무 특성상 랜덤을 많이 사용한다면 재현 가능한 시드 시스템을 도입해야 한다는 것을 주창했다. 그 메커니즘은 재현 가능한 빌드와 동일한데 시작 시에 랜덤 시드를 지정하면 프로그램 전체가 그 시드에 동기화되어서 동작하는 것을 보장하는 것을 의미한다. 이렇게 말하면 어려운데 그냥 쉽게 코드로 말하면 전역 의사 난수 시스템을 사용하고 시작 시에 시드를 고정할 수 있는 방법을 제공해야 하는 것을 말한다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;이렇게 할 경우 어쩌다 한 번 크래시 났을 때, 시드를 알고 있다면 그 다음에는 굳이 100번 실행할 필요가 없다. 해당 시드를 넣고 실행하면 동일한 실행 결과를 보장하기 때문이다. 랜덤이 문제라면 똑같이 문제가 발생할 것이다. 즉, 버그를 찾기가 엄청 쉬워지는 장점이 있다. 여기에 플러스 퍼징 테스트를 하기가 아주 쉬워진다. 그 시드 값만 순차적으로 증가시켜 가면서 쭉 실행을 시키면 문제가 있는지 없는지 손쉽게 찾을 수 있으니 말이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;찾아낸 것도 대단하지만 그런 문제를 두 번 다시 겪지 않기 위해서 재현 가능한 시드라는 것을 주창했다는 것 또한 더 대단한 일이 아닐 수 없다 하겠다. 하지만 현실은 언제나 바쁘기에 그의 의견은 아직도 구현되진 못했다. 조선 최고의 천재라 일컬어지는 율곡 이이 선생의 십만양병설이 떠오르는 시점이 아닐 수 없다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;윈도우 10도 재현 가능한 빌드를 사용하는 마당에 오래 전 그 직원이 주창했던 아이디어를 반성하는 의미에서 구현해야 겠다는 생각이 든다. 구슬이 서 말이라도 꿰어야 보배고, 아이디어가 아무리 많아도 구현이 없으면 공허한 메아리일 뿐이니 말이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="4"&gt;#4&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;다시 다음날. 반성하는 의미에서 우리가 사용하는 랜덤의 호출 경로를 추적하는 작업을 해 보았다. 그러다보니 이 문제가 생각보다 쉽지 않다는 것을 알게 되었고, 똑같은 짓을 몇 년 전에도 했다는 사실을 알게 되었다. 메멘토 같은 상황&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;전말은 이렇다. 일반적으로 사용하는 rand 함수는 시드를 가지고 있고 멀티스레드 환경에 최적화하기 위해서 해당 시드를 스레드 로컬 스토리지에 저장한다. 이 말은 이걸 전역으로 한 번 초기화 한다고 해서 해당 값에 바인딩된 rand를 호출하는 모든 상황에 적용되는 것은 아니라는 것을 의미한다. 즉, 제대로 돌아가게 만들기 위해서는 모든 스레드의 시작 시점에 해당 시드로 초기화를 하는 루틴을 삽입해야 한다는 것을 의미한다. 응당 그게 쉽지 않으니 달리 생각할 수 있는 방법은 의사 랜덤 생성 함수를 새롭게 만드는 방법을 생각해 볼 수 있다. 이렇게 구현할 경우 스레드 안정성을 보장하기 위해서는 락을 쓰거나 락리스한 방법으로 좁혀진다. 그런데 랜덤 값 하나 만들겠다고 락을 쓰는 것은 뭐 빈대잡겠다고 초가삼간 태우는 격이니 결국은 락리스한 랜덤으로 방법은 더 좁혀진다. 그럼 그런 것을 내가 직접 만들 수는 없으니 구글에 검색을 하게 된다. 그렇게 나온 결과물을 쳐다 보고 있으면 그런 결론에 도달한다. 아~ 다른 일부터 해야겠구나&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        <pubDate>Mon, 23 Jul 2018 19:55:33 +0900</pubDate>
        <link>http://www.jiniya.net/ng/2018/07/reproducible-builds</link>
        <guid isPermaLink="true">http://www.jiniya.net/ng/2018/07/reproducible-builds</guid>
        
        
        <category>asciidoc</category>
        
      </item>
    
      <item>
        <title>[일상스케치] 송도 지열군 스튜디오 돌상 사진 촬영기</title>
        <description>&lt;div class="paragraph"&gt;
&lt;p&gt;송도(인천)는 살기에 정말 거의 단점이 없는 동네인데 그 중에도 특히 최고의 강점 중에 하나가 거의 모든 인프라가 굉장히 잘 갖춰져 있다는 점이다. 홈플러스, 오네스타, 현대 프리미엄 아울렛, 트리플 스트리트로 이어지는 몰들의 향연에 한 번 빠지면 도대체 여긴 어딘가 싶다. 특히나 평일에는 사람도 많이 없어서 정말 좋다. 돈많은 아줌마가 살기에는 정말이지 최고의 동네라 할 수 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;스튜디오도 그렇다. 네이버 검색 결과 송도 내에 스튜디오가 몇 개 있는 것으로 보였다. 그 중에서 다른 블로그를 보다 보니 지열군 스튜디오 사진이 괜찮고, 집과도 가까워서 장모님 칠순 가족 사진을 지열군에서 찍기로 했다. 가족 사진 찍으니 서비스 컷을 두 컷 주신다고 하셔서 한 컷을 애들 돌상 촬영을 해봤다. 첫째 애도 돌잔치는 집에서 하고 사진은 분당에 있는 스튜디오에서 전통 돌상 사진으로 찍었었다. 왠지 돌은 전통이 더 어울리는 듯한 느낌이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;첫째 아이 사진을 강남, 이태원, 마포, 분당 등지에서 찍어 봤는데 대부분의 스튜디오가 굉장히 열악하기 그지 없었다. 네비를 찍고 가도 찾기 어려운 건 기본이고, 주차 공간은 거의 제로에 가까워서 근처에 불법 주차를 해야 하는 경우가 대부분이었다. 그렇지 않은 경우는 발렛을 제공해 주기는 했는데 이 경우에는 발렛비를 별도로 내야 했다. 건물도 일반 가정집을 개조한 경우가 많아서 사진 촬영을 하다 보면 아래 위층을 왔다 갔다 해야 하는 경우가 많아서 아직 잘 걷지 못하는 애들을 데리고 사진을 찍기란 여간 어려운 일이 아니었다. 찍다가 부모도, 아이도 파김치가 되는 건 일상적인 풍경&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;하.지.만. 지열군 스튜디오는 이런 모든 불편함이 없었다. 일단 아파트형 공장 같은 건물의 한 호실에 모든 스튜디오가 갖춰져 있어서 계단 사용할 일이 없다. 애들 안고 이동을 하지 않아도 된다는 의미다. 인테리어도 요즘 새로 한 것 같아서 상당히 깔끔하다. 특히 창가쪽 벽면 전체에 인테리어 형태의 쇼파가 쫙 붙어있는데 정말 좋았다. 앉아서 쉬기도 좋고, 애들 뭔가 뒷정리 해줄때도 상당히 유용했다. 아파트형 공장 같은 건물이기 때문에 주차 문제는 애시당초 없다. 게다가 무려 300만원에 달하는 디트로네를 타 볼 수 있다. 물론 사장님께서 허락해 주셔야 하는데 애들이 칭얼 거리면 사장님께서 흔쾌이 탈 수 있도록 배려해 주셨다. 우리도 두바퀴를 탔는데 첫째가 참 좋아했다. 집에 있는 30만원짜리 싸구려 아우디 전동차와는 뭔가 격이 다른 느낌 ㅋㅋㅋ~ 이런 모든 장점을 가진 스튜디오가 무려 우리 집에서 5분 거리. 이러니 송도를 사랑하지 않을 수 없다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;아직 정신 못차리는 애들이 둘이나 있기에 사진 촬영은 정말 쉽지 않았음에도 인내심을 가지고 촬영을 잘 해 주셨다. 특히 돌상 찍을 때는 애들 컨디션이 나락 상태였음에도 최선을 다해서 찍어 주셔서 고마울 따름이었다. 전통 돌상 촬영은 사실 별반 특별할 것이 없다. 돌상 아이템이 얼마나 잘 갖춰져 있느냐와 때깔 좋은 한복이 얼마나 갖춰져 있느냐의 승부인데, 사장님 말씀으로는 새로 시작하는 세트라 특별히 신경써서 고급 한복을 많이 가져다 놓을 예정이라고 했다. 그리고 요즘 시작하는 세트니 당연히 색감이나 이런 것들이 오래된 스튜디오에 있는 한복보다 곱다. 실제로 서비스 컷으로 찍은 한복 때깔이 첫애 때 분당서 돈 주고 촬영한 한복보다 훨씬 더 고급져 보였다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;전통 돌상 촬영의 다른 한 부분은 세트 장이 얼마나 다양하게 꾸며져 있느냐가 있는데 지열군 스튜디오는 아직까지는 일반 돌상이 전부다. 전통 가옥으로 된 스튜디오 장은 없다. 하지만 아.마.도. 돌상 촬영을 하게 되는 경우에는 일반 스튜디오에서 다른 사진을 함께 찍을 수 있을 것으로 추정된다. 그리고 중요한 가격 정보는 와이프가 모두 얘기해서 알 길이 없다. 아마 친절하신 사장님 마인드를 봐서는 가격도 많이 착할 것으로 예상된다. 어쨌든 송도나 송도 근처 인천에 계신 분들이라면 애들 사진 찍기에 강추할만한 스튜디오다. 서울에서 오기에도 괜찮다. 위에서 언급한 홈플러스, 오네스타, 현대 프리미엄 아울렛, 트리플 스트리트 바로 옆이기 때문에 사진 찍고 몰에 가서 쇼핑도 하고, 맛난 것도 먹고, 애들 데리고 놀기도 좋다. 애들 사진은 가급적 인터넷에 안 올리는 것이 좋다고 생각하지만 사진이 넘나 잘나와서 몇 장 올려본다. 어서어서 무럭 무럭 자라라. 얘들아&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="imageblock"&gt;
&lt;img src="/ng/assets/posts/70th/b1.jpg" alt="b1"&gt;

&lt;div class="title"&gt;Figure 1. 둘째, 사장님 포스, 잘 찍고 있지? ㅋ&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="imageblock"&gt;
&lt;img src="/ng/assets/posts/70th/b2.jpg" alt="b2"&gt;

&lt;div class="title"&gt;Figure 2. 첫째랑, 둘째랑 함께, 어서어서 무럭 무럭 자라길&amp;#8230;&amp;#8203;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="imageblock"&gt;
&lt;img src="/ng/assets/posts/70th/b3.jpg" alt="b3"&gt;

&lt;div class="title"&gt;Figure 3. 첫째 짬컷, 이러니 딸바보 안 될래야 안 될 방법이 없다&amp;#8230;&amp;#8203;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;아, 지열군 스튜디오를 처음 방문한다면 주차장 찾는데 조금 난항을 겪을 수 있다. 네비가 알려주는 곳에 주차장 입구가 없기 때문이다. 정확한 주차장은 아래 위치에 있다. 워낙 건물이 길어서 모르면 다소 헤맬 수 있다. 아래 그림의 빨간 부분이 주차장 입구다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="imageblock"&gt;
&lt;img src="/ng/assets/posts/70th/map.png" alt="map"&gt;

&lt;div class="title"&gt;Figure 4. 빨간데가 주차장 입구다.&lt;/div&gt;
&lt;/div&gt;</description>
        <pubDate>Mon, 14 May 2018 19:55:33 +0900</pubDate>
        <link>http://www.jiniya.net/ng/2018/05/one-year</link>
        <guid isPermaLink="true">http://www.jiniya.net/ng/2018/05/one-year</guid>
        
        
        <category>asciidoc</category>
        
      </item>
    
      <item>
        <title>[일상스케치] 완벽한 회사...</title>
        <description>&lt;div class="paragraph"&gt;
&lt;p&gt;설 연휴에 SBS 스페셜 다큐를 한 편 봤다. "검색 말고 사색, 고독연습"이라는 제목의 다큐였다. 제목 그대로 현대인들은 너무나 고독한 시간이 없고, 스스로 생각을 안 하고 산다는 그런 내용이다. 그리고 고독한 시간 속에서 진정한 내면의 문제를 해결할 수 있다는 아주 교훈적인 내용의 다큐. 뻔한 이야기긴 한데 내가 감탄한 부분은 다른데 있었다. 그건 다름 아닌 해당 내용과 같이 소개된 회사였다. 아래 멘트로 소개되는 회사. 특히 소프트웨어 회사라 어떤 회사인지 더 궁금하기도 했다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;건설 설계 소프트웨어 분야 세계 1위, 무스펙, 무징벌, 무상대평가, 무정년, 이른바 4무 경영, 5성급 호텔 쉐프가 매일 아침, 점심, 저녁 제공, 1인당 연간 식비만 1천만원 이상 지출, 회사에서 운영하는 20일의 자아성찰 프로그램 (제주도에서 20일간 묵으며 자아 성찰을 하는 프로그램, 유급)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;몇몇 인상 깊었던 대표의 멘트, "제 인생으로 온 사람들이잖아요. 모두 행복했으면 좋겠습니다.", "개나리는 개나리대로, 진달래는 진달래대로 각자 자신의 꽃을 아름답게 피울 수 있도록 만들어 주는 회사가 됐으면 좋겠습니다." (대충 기억나는 대로 적은 거라 다를 수도 있음)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;당연한 얘기지만 다큐에서는 회사명이 직접 거론되지는 않았다. 오늘 궁금해서 검색해보니 금방 나온다. 판교에 있는 마이다스아이티라는 회사. &lt;a href="https://kreditjob.com/company/059fac2b8cb41ad377349994df59f6e967f285b0"&gt;궁금해서 한 번 찾아봤다.&lt;/a&gt; 세상에 완벽한 회사는 존재하지 않는다. 양쪽의 입장 사이에는 너무나 극명한 차이가 있기 때문인 것 같다. 서로 약간씩 물러나 상대의 입장을 이해하기란 여간 쉬운 일이 아닌 것 같다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;몇 해 전 구글 코리아에서 제법 오래 근무하다 그만 둔 형이 한 이야기가 떠올랐다. 입사할 때 그 회사는 정말 좋은 회사였는데, 그만둘 때에는 그런 장점들이 많이 퇴색해진 것 같다고. 그리고 이어서 떠오르는 최근에 이슈가 된 &lt;a href="http://www.yonhapnews.co.kr/bulletin/2018/02/07/0200000000AKR20180207059700091.HTML"&gt;페이스북에서 CEO 개인에 관한 여론을 조사하는 직원을 고용했다던 기사&lt;/a&gt;가 생각나기도 했다. 아이언맨으로 칭송되는 엘론 머스크의 테슬라와 스페이스엑스도 말도 안 되게 높은 업무 강도로 유명하다는 이야기도 자주 들린다. 아마존 대표 베조스의 막말은 언급하면 입 아픈 정도.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;회사는 회사고, 나는 나다. 직원들에게는 그저 다니는 회사가 블랙 회사가 아니면 만족하고 다닐 법 하다는 이야기를, 대표님들에게는 그저 일 적게 시키고 돈 많이 주면 그게 좋은 회사라는 이야기를 해주고 싶다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;엄마가 늘 하시던 말씀이 생각나는 시점. 물 좋고, 정자 좋은 곳은 세상에 없단다&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;</description>
        <pubDate>Mon, 19 Feb 2018 19:55:33 +0900</pubDate>
        <link>http://www.jiniya.net/ng/2018/02/perfect-company</link>
        <guid isPermaLink="true">http://www.jiniya.net/ng/2018/02/perfect-company</guid>
        
        
        <category>asciidoc</category>
        
      </item>
    
      <item>
        <title>[일상스케치] 트레이드 오프</title>
        <description>&lt;div class="paragraph"&gt;
&lt;p&gt;전산학에서 배운 개념 중에서 일상에 가장 쓸모 있는 개념이 있다면 바로 트레이드 오프다. 트레이드 오프는 간단히 말하면 두가지를 동시에 추구하기란 쉽지 않다는 개념이다. 속도를 빠르게 하려면 공간을 더 써야 하고, 공간을 줄이려면 속도를 희생해야 한다는 것과 같이 두 가지 목표를 동시에 추구하기가 쉽지 않은 문제에 쓰인다. 즉, 하나를 선택하면 다른 하나는 일정 부분 포기해야 함을 의미한다. 물론 고상한 전산학까지 가지 않아도 초중등 교과서에도 이 내용이 나온다. 두마리 토끼를 잡지 못한다는 이야기다. 트레이드 오프는 그것보다는 조금 더 확장된 개념이긴 하다. 두마리 토끼를 잡을 수 없다고 한다면 한 마리만 잡을 수 있다는 이야기처럼 들리지만 트레이드 오프는 반반을 추구할 수도 있기 때문이다. 더 내려가서 초등학교 때에도 이 개념을 배우긴 한다. 사탕 항아리에 아이가 사탕을 꺼내려고 손을 넣고 있다. 사탕을 집고 있어서 손이 나오지 않는다. 아이가 사탕을 적당히 포기해야 손을 뺄 수 있다는 이야기가 그것이다. 그렇게 인생 전반에 걸쳐서 우리는 트레이드 오프란 개념을 배운다. 그만큼 중요한 개념이기 때문일 수도 있고, 그만큼 사람들이 쉽게 잊어버리는 내용이기 때문일지도 모르겠다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;인생은 B(Birth)와 D(Death)사이의 C(Choice)라고 얘기한 철학자의 말처럼 인생은 선택의 연속이고, 그 선택이란 것이 결국은 트레이드 오프를 조율하는 과정이다. 연봉을 많이 주는 회사에 입사하면 돈은 더 벌 수 있겠지만 개인 시간은 더 많이 희생할 수 밖에 없다. 작은 회사에 다니면 보다 많은 사사로운 자유로움은 누릴 수 있겠지만 어디 가서 이야기할 때 그 회사를 아는 사람이 없을 수 있다. 아이를 놓으면 아이가 커 가는 것을 지켜 보는 기쁨은 누릴 수 있겠지만 자신의 인생 중 중요한 시간 대부분을 아이를 위해서 희생해야 한다. 유명해지면 많은 사람들이 알아보기 때문에 좋겠지만 그 사람의 사생활은 없어진다. 인생 전반에서 우리를 향해 달려오는 많은 일들이 사실은 트레이드 오프적인 성격의 것들이고 우리는 그 사이에서 어떤 것을 얼만큼 추구할지 결정해야 한다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;사람들이 가장 많이 잊어버리는 내용 중 하나는 바로 항아리에서 손을 못 빼고 있는 아이처럼 그런 종류의 많은 문제들이 트레이드 오프적인 성격의 것이라는 것을 인지하지 못한다는 사실이다. 아이를 놓고 기르면서도 그 전과 같은 평범한 일상을 누릴 수 있다고 생각한다거나, 연봉을 많이 주는 회사에 들어가도 일은 조금 해도 된다고 생각한다거나, 유명한 연예인이 되어도 그 전과 같은 사소한 일상을 누릴 수 있을 것이라고 생각한다. 현실은 그렇지 않은데 말이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;예전에 친구의 죽음으로 충격을 받은 모 프로그래머가 만든 게임이 생각난다. 그 게임은 간단하다. 시작은 직사각형 모양의 왼쪽 상단에서 한다. 한번에 우리는 네 방향 중 한 칸만큼 움직일 수 있다. 우리가 게임 내에서 움직일 수 있는 최대 횟수는 정해져 있다. 그 프로그래머가 말하고 싶었던 것이 바로 트레이드 오프다. 우리가 오른쪽으로 많이 움직인다면 상대적으로 위나 아래, 왼쪽으로는 적게 움직일 수 밖에 없다. 우리는 그 제한된 횟수 내에서 우리가 선택한만큼 경험하게 되고 죽음을 맞이하게 된다는 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;세상 모든 것을 다 가질 순 없다. 하나를 더 많이 가지기 위해서는 다른 하나는 그만큼 포기해야 한다. 보통 사람들이 무엇을 더 가질지는 잘 선택하지만 무엇을 포기할지는 망설이는 경우가 많다. 하지만 중요한 것은 무엇을 더 가질지 보다는 무엇을 포기해도 되는지를 먼저 정하는 것이다. 그래야 비로소 어떤 방향으로 가야 하는지가 명확해지기 때문이다. 당신은 오늘 무엇을 트레이드 오프 하고 있는가? 또 무엇을 얻고, 무엇을 포기했는가?&lt;/p&gt;
&lt;/div&gt;</description>
        <pubDate>Fri, 26 Jan 2018 00:55:33 +0900</pubDate>
        <link>http://www.jiniya.net/ng/2018/01/trade-off</link>
        <guid isPermaLink="true">http://www.jiniya.net/ng/2018/01/trade-off</guid>
        
        
        <category>asciidoc</category>
        
      </item>
    
      <item>
        <title>[치토스] 서피스 프로 LTE</title>
        <description>&lt;style&gt;

.video-container
{
	position: relative;
	padding-bottom: 56.25%;
	padding-top: 35px;
	height: 0;
	overflow: hidden;
}

.video-container iframe
{
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
}

&lt;/style&gt;

&lt;div class="video-container"&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/X8Z91UjM9PM" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;그러하다. 하드웨어 명가 MS가 드디어 완벽한 껍데기를 만들었다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;팬리스, i5, LTE가 달린 서피스. 내가 원하는 바로 그것. 지름신 강림&amp;#8230;&amp;#8203; ㅋㅋㅋ&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;지금 사용하는게 서피스 프로4 M3 버전인데, 지금껏 써 온 그 어떤 노트북보다 만족한다&amp;#8230;&amp;#8203;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;쓰면서 딱 불편한게 M3의 약한 파워, 태더링의 불편함&amp;#8230;&amp;#8203; 그런데 이 모든 문제점을 해결한 버전이 나온 것이다&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;12월 출시라는데 한국도 제발 출시해주길&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;이런 거 들고 발리가서 서핑하면서 코딩하면 한 2천배쯤 생산성이 향상될 거 같은 느낌적인 느낌&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;</description>
        <pubDate>Wed, 08 Nov 2017 21:55:33 +0900</pubDate>
        <link>http://www.jiniya.net/ng/2017/11/surface-pro-lte</link>
        <guid isPermaLink="true">http://www.jiniya.net/ng/2017/11/surface-pro-lte</guid>
        
        
        <category>asciidoc</category>
        
      </item>
    
      <item>
        <title>[시스템] 윈도우 x64 호출 규약 리뷰</title>
        <description>&lt;div class="paragraph"&gt;
&lt;p&gt;윈도우 x64 호출 규약은 굉장히 심플하다. 파라미터가 첫번째부터 rcx, rdx, r8d, r9d를 통해서 전달되고 그 다음 추가 파라미터는 스택을 통해 전달된다. 스택 정리는 호출한 쪽에서 수행한다. 그런데 여기서 한 가지 주의해야 할 것이 홈 공간이다. 홈 공간이란 파라미터가 레지스터를 통해서 전송되더라도 그걸 저장하기 위한 스택 공간을 호출하는 쪽에서 제공해야 한다는 것을 의미한다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;

&lt;pre&gt;void Func1(int param1);&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;위 코드를 보자. 위의 파라미터 전송 설명대로라면 Func1(3)은 아래와 같이 호출하면 될 거 같다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;

&lt;pre&gt;mov rcx, 3
call Func1&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;하지만 그렇지 않다. 홈 공간이 필요하기 때문이다. 그래서 아래와 같이 값을 저장하지는 않더라도 공간은 확보해 주어야 한다. sub rsp, 8을 통해서 Func1이 param1 저장을 위해서 사용할 공간을 확보한 후에 호출해야 한다. 이게 홈 공간이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;

&lt;pre&gt;sub rsp, 8
mov rcx, 3
call Func1
add rsp, 8&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;조금 복잡하게 파라미터가 5개인 함수를 살펴보자.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;

&lt;pre&gt;void Func2(int p1, int p2, int p3, int p4, int p5);&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Func2(1, 2, 3, 4, 5)를 호출한다고 생각해보자. 그러면 아래와 같이 호출하면 된다. push 5를 통해서 스택에 마지막 값을 기록한다. 이후 앞에 4개의 값을 기록할 공간을 확보한 후, rcx, rdx, r8d, r9d에 변수를 지정하고 Func2를 호출하면 된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;

&lt;pre&gt;push 5
sub rsp, 32
mov rcx, 1
mov rdx, 2
mov r8d, 3
mov r9d, 4
call Func2
add rsp, 40&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;실제로 컴파일러는 매 함수 호출마다 이렇게 스택을 조작하지는 않는다. 여유 있는 스택 공간을 함수 도입부에 확보해놓고 지속적으로 사용한다. 어쨌든 우리가 기억해야 할 사항은 이것이다. 앞에 4개는 레지스터로 뒤에꺼는 스택으로, 그리고 파라미터 개수만큼 스택 공간은 항상 확보해 주어야 한다는 점이다. 호출 규약에 관한 더 자세한 내용은 &lt;a href="http://www.jiniya.net/lecture/maso/theartofcalling.pdf"&gt;호출의 예술&lt;/a&gt;을 참고하자.&lt;/p&gt;
&lt;/div&gt;</description>
        <pubDate>Tue, 07 Nov 2017 21:55:33 +0900</pubDate>
        <link>http://www.jiniya.net/ng/2017/11/x64-calling-convention</link>
        <guid isPermaLink="true">http://www.jiniya.net/ng/2017/11/x64-calling-convention</guid>
        
        
        <category>asciidoc</category>
        
      </item>
    
      <item>
        <title>[파이썬] 주차를 알고 싶을 땐 isocalendar</title>
        <description>&lt;div class="paragraph"&gt;
&lt;p&gt;일주일씩 묶어서 통계를 내고 싶을 때가 있다. 그런데 이게 날짜를 기준으로 하기도 애매하고 위크데이를 기준으로 해도 영 뭔가 계산하기가 쉽지 않다. 이럴 때 isocalendar를 사용하면 편리하다. 해당 날짜가 1년의 몇 번째 주차인지 반환해 준다. 사용법은 아래와 같이 심플하다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;

&lt;pre&gt;Python 3.5.2 (v3.5.2:4def2a2901a5, Jun 25 2016, 22:18:55) [MSC v.1900 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
&amp;gt;&amp;gt;&amp;gt; import datetime
&amp;gt;&amp;gt;&amp;gt; n = datetime.datetime.now()
&amp;gt;&amp;gt;&amp;gt; n.isocalendar()
(2017, 45, 1)
&amp;gt;&amp;gt;&amp;gt; n = datetime.datetime(2017, 11, 5)
&amp;gt;&amp;gt;&amp;gt; n.isocalendar()
(2017, 44, 7)
&amp;gt;&amp;gt;&amp;gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;isocalendar의 반환 값은 튜플인데 차례대로 ISO 연도, ISO 주차, ISO 요일 번호다. 오늘이 벌써 올해 45주차라뉘&amp;#8230;&amp;#8203; 일년이 52주라 그랬던거 같은데 이렇게 또 일년이 흘러가려고 하나보다. 여튼 이렇게 일주일 단위로 묶은 통계를 낼 때에는 isocalendar가 참 편리하다.&lt;/p&gt;
&lt;/div&gt;</description>
        <pubDate>Sun, 05 Nov 2017 21:55:33 +0900</pubDate>
        <link>http://www.jiniya.net/ng/2017/11/isocalendar</link>
        <guid isPermaLink="true">http://www.jiniya.net/ng/2017/11/isocalendar</guid>
        
        
        <category>asciidoc</category>
        
      </item>
    
      <item>
        <title>[C++] 정규 표현식</title>
        <description>&lt;div class="paragraph"&gt;
&lt;p&gt;C++11부터 정규 표현식이 표준 라이브러리에 포함됐다. 문자열 다루기 힘든 C++에서 이런게 되다니 정말 기가 찰 노릇이다. 구슬이 서말이라도 꿰어야 보배이듯이 표준 라이브러리에 있어도 사용법을 모른다면 의미가 없다. 간략하게 사례별로 어떻게 사용하는지 살펴보도록 하자. 일단 코드를 먼저 보고,&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;

&lt;pre&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;regex&amp;gt;

int main()
{
	std::string s = "123";
	std::regex number("[0-9]+");

	if(std::regex_match(s, number))
	{
		printf("number\n");
	}
	else
	{
		printf("not number\n");
	}

	return 0;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;정규 표현식을 이용해서 문자열이 숫자인지 아닌지를 판단하는 프로그램을 만들어 본 것이다. s의 값을 변경해가면서 출력 값을 체크해보면 대략 어떻게 쓰는 것인지 알 수 있다. std::regex_match 함수를 사용하면 특정 문자열이 정규 표현식에 부합하는지 아닌지를 체크할 수 있다는 사실을 알면 되겠다. 한 가지 주의해야 할 점은 std::regex_match 함수의 경우 재귀 호출을 사용한다는 점이다. 따라서 정규 표현식에 따라서 문자열이 길면 스택 오버플로로 크래시가 발생할 수 있다. Visual Studio 2015에서는 이러한 문제점을 없애기 위해서 재귀 호출의 최대 깊이를 상수로 지정할 수 있도록 되어 있다. regex를 포함하기 전 _REGEX_MAX_STACK_COUNT를 특정 값으로 선언해 주면 된다. 기본적으로 64비트는 600, 32비트는 1000으로 설정돼 있다. 그 크기를 늘려주면 더 긴 문자열도 오류 없이 매치할 수 있다. 물론 너무 높게 설정하면 스택 오버플로로 크래시가 발생할 수 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;

&lt;pre&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;regex&amp;gt;

int main()
{
	std::string s = "123 456 789";
	std::regex number("[0-9]+");

	std::sregex_iterator it(s.begin(), s.end(), number);
	std::sregex_iterator end;

	while(it != end)
	{
		std::smatch m = *it;

		printf("%s\n", m.str(0).c_str());

		++it;
	}

	return 0;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;위 예제는 특정 문자열에서 정규 표현식에 부합하는 요소만 추출해서 출력하는 예를 보여주고 있다. std::sregex_iterator를 사용해서 부합하는 요소만 열거할 수 있고, std::smatch 객체를 이용하면 부합한 내용이 무엇인지 출력할 수 있다. 위 프로그램의 출력 결과는 123, 456, 789가 된다. std::smatch의 str 함수의 첫번째 파라미터로 넘어간 숫자가 애매한데 그건 매치한 대상 중에 어떤 것을 출력할지를 결정한다. 위 예에서는 매치 대상이 별도로 구분되어 있지 않기 때문에 0번 밖에는 없다. 아래 예제를 살펴보자.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;

&lt;pre&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;regex&amp;gt;

int main()
{
	std::string s = "123 456 789";
	std::regex number("([0-9])([0-9])([0-9])");

	std::sregex_iterator it(s.begin(), s.end(), number);
	std::sregex_iterator end;

	while(it != end)
	{
		std::smatch m = *it;

		printf("%s\n", m.str(1).c_str());

		++it;
	}

	return 0;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;위 프로그램의 출력 결과는 1, 4, 7이 된다. 정규 표현식이 ([0-9])([0-9])([0-9]) 이와 같이 구성되어 있기 때문에 123이 이 표현식에 매치되면 std::smatch의 str 함수의 0번은 123을, 1번은 1을 2번은 2를, 3번은 3을 나타낸다. 그렇다면 정규 표현식 전체를 괄호로 한 번 더 묶으면 어떻게 될까? "(([0-9])([0-9])([0-9]))" 이렇게 말이다. 이러면 0은 123을 1도 123을 2는 1을, 3은 2를, 4는 3을 반환한다.&lt;/p&gt;
&lt;/div&gt;</description>
        <pubDate>Wed, 01 Nov 2017 21:55:33 +0900</pubDate>
        <link>http://www.jiniya.net/ng/2017/11/regex</link>
        <guid isPermaLink="true">http://www.jiniya.net/ng/2017/11/regex</guid>
        
        
        <category>asciidoc</category>
        
      </item>
    
      <item>
        <title>[일상스케치] 봇 트레이딩 체험기...</title>
        <description>&lt;div class="paragraph"&gt;
&lt;p&gt;어쩌다 올초에 비트코인에 투자를 했다. 처음에 재미삼아 1비트를 사봤는데 계속 떨어져서 물타기를 하다가 금액이 커져서 그냥 냅두게 됐었다. 그게 4, 5월 엄청 폭등하는 바람에 수익을 좀 봤다. 이런 사실을 아는 출판사 다니는 친구 녀석이 자기 회사에서 주식 자동매매 책이 잘 팔린다고 암호화폐 자동매매 책을 써 볼 생각이 없냐는 제안을 했다. 그렇게 어쩌다보니 봇 거래를 해보게 됐다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;사실 전업 프로그래머 입장에서 투자 전략이야 천차만별이지만 시스템 트레이딩 코드를 만드는 건 너무 쉽다. 게다가 포인터를 다뤄야 하는 C/C++도 아니고 파이썬이면 충분하기 때문에 뻥 좀 보태서 한 시간이면 봇을 만들 수 있다. 요는 코딩이 어려운 건 아니고 전략이 어렵다는 의미다. 어쨌든 30분 정도 REST API를 훓어보고 봇으로 거래를 해보게 됐다. 당연한 얘기지만 된다. 거기에 내가 생각한 한 가지 아이디어를 넣어서 거래를 해보게 했더니 수익이 발생하는게 아닌가? 긴 추석 연휴 기간 동안 봇을 조금 다듬었다. 그렇게 25일이 됐고 봇이 나에게 월급을 줘야 하는 시점에 봇의 성적표는 다음과 같다. 각각 날짜, 비트코인봇 수익, 비트코인봇 거래회수, 이더리움봇 수익, 이더리움봇 거래회수, 토탈 수익, 토탈 거래회수, 누적 수익이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="imageblock"&gt;
&lt;img src="/ng/assets/posts/bot-trading/bot_result.png" alt="bot result"&gt;

&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;생각보다 많을 수도 있고, 적을 수도 있는데 나는 이 봇의 이름을 최저임금봇이라 명명했다. 시급 만원 정도를 추종하도록 설계됐다. 물론 시장 상황이 좋으면 더 벌기도 하고, 나쁘면 덜 벌기도 하는데 대략 그 정도 수준에서 24시간 돌면서 거래를 한다. 재미난 건 상수 값 몇 개 바꾸면 저 단위가 10배가 될 수도 있다는 점이다. 물론 내가 쪽빡찰 확률은 100배가 되겠지만 말이다. 여기까지만 쓰면 단순 자랑질 이상도 이하도 아닐 것이다. 그래서 트레이딩 봇을 만들면서 알게된 점 몇 가지를 정리해 본다. 분명 이런 시스템을 만드려는 금융 쪽 종사자가 아닌 프로그래머가 있다면 도움이 되리라 확신한다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="삼위일체"&gt;삼위일체&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;처음에 봇을 만들고 가동시키자 봇이 엉뚱한 실수를 계속 했다. 분명 50원에 샀으면 100원에 팔라고 코딩을 해놨는데 계속 40원에 팔면서 수익을 내고 있다고 착각하고 있는 것이었다. 나같은 프로페셔널한 프로그래머가 if문 따위를 잘못 코딩할리도 없는데 말이다. 부랴부랴 Ctrl + C를 눌러서 봇을 껐지만 제법 손실이 난 후였다. 이 버그 아닌 버그를 찾는데 가장 많은 시간이 들었는데 원인은 다름아닌 트랜잭션에 있었다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;내가 상상한 퐌타지한 세계는 그랬다. 거래소에서 나에게 제공하는 모든 데이터는 수직 동기화가 되어 있을 줄 알았다. 즉 그 사이게 시간 차가 존재할 줄 몰랐다는 의미다. 하지만 현실 세계는 그렇지 않았다. KRW 잔고가 먼저 반영되기도 하고, BTC 잔고가 그 다음에 움직이기도 하고, 거래 트랜잭션 데이터는 몇 십초가 있다가 확정되기도 했다. 즉 이 사이에는 어느 정도 시간적인 불일치가 있었다. 이걸 한쪽 데이터만 보고 판단해서 거래를 하면 나처럼 낭패를 볼 수 밖에 없다. 검산을 해야 한다. KRW 잔고와 BTC 잔고와 거래 내역이 모두 일치하는 삼위일체의 상태에 있을 때에 수익을 계산하고 베팅을 해야 한다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="부동소수점"&gt;부동소수점?&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;이 오류가 정확하게 부동소수점 때문인지 아니면 내 계산 방식 때문인지는 모르겠지만 위 삼위일체 검산 로직을 추가해도 정확하게 데이터가 일치하지 않았다. 나는 그냥 편하게 부동소수점 때문이라고 판단했는데 1사토시 근처에서 오류가 있는 경우가 많았다. 그래서 그냥 0.00000001 정도의 차이는 동일하다고 간주했다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="하락장을-고려해야-한다"&gt;하락장을 고려해야 한다&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;상승만 한다면 바보 같은 봇들도 모두 수익을 낼 수 있다. 그리고 어렵게 봇을 만들 필요도 없다. 사두고 장기 보유하면 되기 때문이다. 하지만 시장은 항상 그렇듯이 오르기도 하고 내리기도 한다. 암호화폐 시장은 그 변동성이 더 크다. 그래서 봇 거래가 수익을 내기 좋은 환경이기도 하다. 어쨌든 하락장을 고려해야 한다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;처음 만든 봇은 그저 오른다는 가정하에 만들었고 시장 상황이 계속 올라서 참 쉬웠다. 그러다 하락장이 왔는데 봇은 어쩔줄을 몰라 했다. 출구전략이 필요했다. 그런데 이론적으로 주구장창 하락한다면 일반 거래로 수익을 얻을 방법은 없다. 여기서 일반 거래란 공매도 같은 장치가 없음을 의미한다. 따라서 출구 전략은 단순할 수 밖에 없다. 더 사서 물타기를 할지 아니면 손절을 할지를 판단하는게 전부다. 여러가지 전략이 있을 수 있는데 나도 5가지 정도의 전략을 테스트 해보았다. 갈수록 산수에서 수학으로 가는 내용들이 도입됐고 코드도 복잡해졌다. 그런데 아니러니 하게도 수익률은 두번째 방법이 가장 좋았다. 그래서 그냥 그걸로 적용해 두었다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="인간은-개입하지-말지어다"&gt;인간은 개입하지 말지어다&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;위에서 말한 하락장에서 봇의 손실이 제법 커졌다. 사람은 당연히 불안해질 수 밖에 없다. 봇은 사지도 팔지도 못하고 있었다. 그러다 코인 가격이 반등되어 적당한 가격이 왔다. 봇은 아직 팔 때가 아니라서 거래를 하고 있지 않았다. 사람인 나는 조급해질 수 밖에 없었다. 봇이 사들인 코인의 대부분을 이 시점에 손절해 버렸다. 봇은 회복할 수 없는 타격을 입었다. 봇은 내가 저지른 만행을 복구할 수가 없는 지경이 됐다. 결국 나는 봇의 수익률 추종치를 리밸런싱할 수 밖에 없었다. 이게 비트코인 봇인데 원래 비트코인 봇이 이더리움 봇 보다는 수익률이 월등했는데 이 당시의 내 개입으로 인해서 구려졌다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;봇이 어쩔 줄 몰라 하면 봇을 고쳐서 대응하면 된다. 절대 수동 트레이드로 개입할 필요가 없다. 왜냐하면 내가 느끼는 감성적인 수치와 봇이 정확하게 계산한 수치 사이에는 항상 간극이 존재할 수 밖에 없기 때문이다. 감정적인 대응의 결과는 손실 밖에 없다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="거래-수수료-트레이프오프"&gt;거래 수수료 트레이프오프&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;봇 트레이딩의 가장 큰 리스크는 다름 아닌 거래 수수료다. 봇이라서 엄청나게 많은 회수의 거래를 하는데 그때마다 수수료가 발생하기 때문이다. 상당수는 거래 볼륨으로 커버가 가능한데 대부분의 거래소가 거래 볼륨이 커질 수록 수수료가 낮아지도록 책정되어 있기 때문이다. 거래소에 따라서 일정 수준을 넘어서면 수수료 없이 거래하는 것도 가능하다. 그런데 문제는 그 수수료가 한 가지가 아니라 두 가지란 점에 있다. 모든 거래소 시스템이 비슷한 방식의 수수료를 책정하고 있는데 일명 메이커, 테이커 비용이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;시장에 유동성을 공급하는 거래에는 메이커, 유동성을 없애는 거래에는 테이커 비용을 물린다. 이게 거의 수수료가 없는 쪽은 메이커 비용이고, 테이커 비용은 수수료가 높다. 테이커 비용에 물리게 되면 사실상 단타 매매로 수익을 내기가 굉장히 어려워진다. 문제는 이 테이커 비용을 최대한 덜 내게 하는 방법인데 이게 쉽지가 않다. 그런 API가 존재하면 좋겠지만 거래소 수익 때문인지 그런 API를 제공하지 않는다. 내가 주문을 낼 때에는 멀쩡한 메이커 주문이었는데 그게 거래소 트랜잭션 시스템에서 직렬화 되면서 테이커 비용을 물게 되는 경우가 왕왕있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;당연한 얘기겠지만 되도록 이 테이커 비용을 피하면서 거래를 성사시키는 것이 중요하다. 그런데 문제가 그렇게 간단하지는 않은 것이 거래를 성립시키려면 테이커 비용을 무는 쪽으로 다가 가야 하기 때문이다. 즉, 이 사이에는 트레이드 오프가 있다. 거래를 잘 성립하게 만들다보면 테이커 비용을 무는 경우가 많고, 그렇다고 완전 회피하려면 유동성만 공급할 뿐 거래가 성사되지 않기 때문이다. 즉, 최대한 원활하게 거래를 성립시키면서 테이커 비용은 최대한 피하는 그런 방법을 만드는 것이 중요하다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="두려움을-넘어서"&gt;두려움을 넘어서&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;이 모든 봇 거래의 가장 큰 어려움은 두려움이다. 이 단순한 봇도 내 전재산의 무시 못할 수준의 금액을 가지고 도박을 한다. 내가 자는 동안에 위에서 말한 삼위일체 문제 같은게 발생한다면 거지되는 것이다. 그 두려움이 처음 3일 정도는 있었던 것 같다. 이제는 어느 정도 봇을 믿게 됐다. 특히 내가 한 수동 거래가 병신짓으로 판명난 이후에는 봇을 더 신뢰하게 됐다. 어쨌든 자신이 만든 버그가 현실 세계에서 어떻게 발현될 수 있는지 확인해 보고 싶은 프로그래머라면 도전해 볼 만한 영역인 것 같다. 물론 수익은 덤이다. 재미삼아 시작했는데 결과가 나쁘지 않아 누적 수익이 0이 될 때까지는 봇 실험을 계속해 볼 생각이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        <pubDate>Wed, 25 Oct 2017 21:55:33 +0900</pubDate>
        <link>http://www.jiniya.net/ng/2017/10/bot-trading</link>
        <guid isPermaLink="true">http://www.jiniya.net/ng/2017/10/bot-trading</guid>
        
        
        <category>asciidoc</category>
        
      </item>
    
  </channel>
</rss>
