<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>woniper</title>
<link>https://blog.woniper.net/</link>
<description>작동하는 그리고 깔끔한 코드</description>
<language>ko</language>
<pubDate>Mon, 13 May 2019 20:03:48 +0900</pubDate>
<generator>TISTORY</generator>
<managingEditor>woniper</managingEditor>
<image>
<title>woniper</title>
<url>http://cfile24.uf.tistory.com/image/271FB948555663EB2FB6E7</url>
<link>https://blog.woniper.net</link>
<description>작동하는 그리고 깔끔한 코드</description>
</image>
<item>
<title>Spring-MVC 읽기 #6. DispatcherServlet - @Controller는 어떻게 실행될까?</title>
<link>https://blog.woniper.net/369</link>
<description>&lt;p&gt;Spring-MVC로 웹 애플리케이션을 개발하면 아래와 같은 Controller를 만든다. &lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Controller
public class HelloController {
    @GetMapping(&quot;/hello&quot;)
    public String hello() {
        return &quot;hello Spring~&quot;;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;어떻게 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Controller.html&quot;&gt;@Controller&lt;/a&gt; 선언 만으로 메소드가 실행되고, Controller 실행 전/후로 전처리, 후처리 가능한 Interceptor가 동작할까? 뿐만 아니라, 파일 업로드, View 반환 등 Spring-MVC에서 제공되는 여러 가지 기능들은 어떻게 실행될까?&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://blog.woniper.net/368&quot;&gt;Spring-MVC 읽기 #5. AbstractDispatcherServletInitializer와 AbstractAnnotationConfigDispatcherServletInitializer&lt;/a&gt; 에서 봤던 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/DispatcherServlet.html&quot;&gt;DispatcherServlet&lt;/a&gt;에 의해 동작된다. 이 번 글은 Spring-MVC의 핵심이라 할 수 있는 DispatcherServlet 클래스 코드를 살펴볼 것이다.&lt;/p&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;DispatcherServlet&lt;/h2&gt;

&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99BF303F5C3D1F292A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;DispatcherServletDiagram.png&quot; height=&quot;589&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;DispatcherServlet의 Hierarchy를 보자. 위 이미지에 빨간색 박스를 누르면 DispatcherServlet의 상위 클래스를 볼 수 있다. &lt;/p&gt;&lt;p&gt;Spring-MVC는 Servlet 스펙을 기반으로 만들어진 프레임워크다. 때문에 당연히(?) &lt;a href=&quot;https://docs.oracle.com/javaee/7/api/javax/servlet/Servlet.html&quot;&gt;Servlet&lt;/a&gt; interface를 구현하고 있다. 앞선 글에서 WAS를 자세히 설명하지 않았지만, 우리가 만든 웹 애플리케이션을 구동하고 실행하는 건 알고 있다. 그리고 WAS의 종류 중 하나인 Tomcat을 기준으로 설명했고, Tomcat은 Servlet 웹 애플리케이션을 실행한다.&lt;/p&gt;&lt;p&gt;HTTP를 요청하면, Tomcat은 이 Servlet 인터페이스를 실행한다.&lt;/p&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;Servlet#service&lt;/h2&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public interface Servlet {

    public void init(ServletConfig config) throws ServletException;

    public ServletConfig getServletConfig();

     /**
     * Called by the servlet container to allow the servlet to respond to 
     * a request.
     *
     * &amp;lt;p&amp;gt;This method is only called after the servlet's &amp;lt;code&amp;gt;init()&amp;lt;/code&amp;gt;
     * method has completed successfully.
     * 
     * &amp;lt;p&amp;gt;  The status code of the response always should be set for a servlet 
     * that throws or sends an error.
     *
     * 
     * &amp;lt;p&amp;gt;Servlets typically run inside multithreaded servlet containers
     * that can handle multiple requests concurrently. Developers must 
     * be aware to synchronize access to any shared resources such as files,
     * network connections, and as well as the servlet's class and instance 
     * variables. 
     * More information on multithreaded programming in Java is available in 
     * &amp;lt;a href=&quot;http://java.sun.com/Series/Tutorial/java/threads/multithreaded.html&quot;&amp;gt;
     * the Java tutorial on multi-threaded programming&amp;lt;/a&amp;gt;.
     *
     *
     * @param req   the &amp;lt;code&amp;gt;ServletRequest&amp;lt;/code&amp;gt; object that contains
     *          the client's request
     *
     * @param res   the &amp;lt;code&amp;gt;ServletResponse&amp;lt;/code&amp;gt; object that contains
     *          the servlet's response
     *
     * @exception ServletException  if an exception occurs that interferes
     *                  with the servlet's normal operation 
     *
     * @exception IOException       if an input or output exception occurs
     *
     */
    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException;
    
    public String getServletInfo();

    public void destroy();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Servlet 인터페이스는 몇 가지 선언 메소드가 있다. &lt;code&gt;Servlet#service&lt;/code&gt; 메소드의 주석을 보면 &lt;code&gt;Servlet 컨테이너에 의해 호출되어 서블릿이 요청에 응답할 수 있게 합니다.&lt;/code&gt; 라고 설명한다. 여기서 &lt;code&gt;요청&lt;/code&gt;과 &lt;code&gt;응답&lt;/code&gt;이 무엇을 의미할까? 바로 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP/Messages&quot;&gt;HTTP request, response&lt;/a&gt;를 의미한다. Servlet#service 메소드의 파라미터인 &lt;a href=&quot;https://docs.oracle.com/javaee/7/api/javax/servlet/ServletRequest.html&quot;&gt;ServletRequest&lt;/a&gt;와 &lt;a href=&quot;https://docs.oracle.com/javaee/7/api/javax/servlet/ServletResponse.html&quot;&gt;ServletResponse&lt;/a&gt;를 봐도 Servlet#service 메소드가 어떤 의미를 하는지 추측할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;GenericServlet#service&lt;/h2&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public abstract class GenericServlet implements Servlet, ServletConfig, java.io.Serializable {
    public abstract void service(ServletRequest req, ServletResponse res) throws ServletException, IOException;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Servlet 인터페이스의 구현체인 &lt;a href=&quot;https://docs.oracle.com/javaee/7/api/javax/servlet/GenericServlet.html&quot;&gt;GenericServlet&lt;/a&gt; 클래스의 &lt;code&gt;service&lt;/code&gt; 메소드는 abstract로 선언되어있다. 즉 GenericServlet의 하위 클래스가 구현하고 있다는 의미다.&lt;/p&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;HttpServlet#service&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html&quot;&gt;HttpServlet&lt;/a&gt; 클래스는 오버 로딩된 두 개의 service 메소드가 존재한다. &lt;code&gt;ServletRequest와 ServletResponse&lt;/code&gt;를 파라미터로 받는 service 메소드를 보자.&lt;/p&gt;

&lt;h3 id=&quot;toc_4&quot;&gt;HttpServlet.service(ServletRequest, ServletResponse)&lt;/h3&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public abstract class HttpServlet extends GenericServlet {

    @Override
    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
        HttpServletRequest  request;
        HttpServletResponse response;
        
        if (!(req instanceof HttpServletRequest &amp;amp;&amp;amp;
                res instanceof HttpServletResponse)) {
            throw new ServletException(&quot;non-HTTP request or response&quot;);
        }

        request = (HttpServletRequest) req;
        response = (HttpServletResponse) res;

        service(request, response);
   }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;ServletRequest를 &lt;a href=&quot;https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html&quot;&gt;HttpServletRequest&lt;/a&gt;로 ServletResponse를 &lt;a href=&quot;https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletResponse.html&quot;&gt;HttpServletResponse&lt;/a&gt;로 형 변환한다.&lt;/li&gt;
&lt;li&gt;HttpServlet.service(HttpServletRequest, HttpServletResponse) 메소드를 호출한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;toc_5&quot;&gt;HttpServlet.service(HttpServletRequest, HttpServletResponse)&lt;/h3&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String method = req.getMethod();

    if (method.equals(METHOD_GET)) {
        long lastModified = getLastModified(req);
        if (lastModified == -1) {
            // servlet doesn't support if-modified-since, no reason
            // to go through further expensive logic
            doGet(req, resp);
        } else {
            long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);
            if (ifModifiedSince &amp;lt; lastModified) {
                // If the servlet mod time is later, call doGet()
                // Round down to the nearest second for a proper compare
                // A ifModifiedSince of -1 will always be less
                maybeSetLastModified(resp, lastModified);
                doGet(req, resp);
            } else {
                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
            }
        }

    } else if (method.equals(METHOD_HEAD)) {
        long lastModified = getLastModified(req);
        maybeSetLastModified(resp, lastModified);
        doHead(req, resp);

    } else if (method.equals(METHOD_POST)) {
        doPost(req, resp);
        
    } else if (method.equals(METHOD_PUT)) {
        doPut(req, resp);
        
    } else if (method.equals(METHOD_DELETE)) {
        doDelete(req, resp);
        
    } else if (method.equals(METHOD_OPTIONS)) {
        doOptions(req,resp);
        
    } else if (method.equals(METHOD_TRACE)) {
        doTrace(req,resp);
        
    } else {
        //
        // Note that this means NO servlet supports whatever
        // method was requested, anywhere on this server.
        //

        String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);
        Object[] errArgs = new Object[1];
        errArgs[0] = method;
        errMsg = MessageFormat.format(errMsg, errArgs);
        
        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;HTTP method를 구한다. (req.getMethod() 메소드)&lt;/li&gt;
&lt;li&gt;HTTP method에 맞게 &lt;code&gt;do{method}&lt;/code&gt; 메소드(doGet, doPost 등)를 호출한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;HttpServlet#doGet 메소드를 기준으로 코드를 살펴보자.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String protocol = req.getProtocol();
    String msg = lStrings.getString(&quot;http.method_get_not_supported&quot;);
    if (protocol.endsWith(&quot;1.1&quot;)) {
        resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);
    } else {
        resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;HttpServlet#doGet 메소드는 protocol을 구해 HttpServletResponse#sendError 메소드를 호출한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이상하다. 이게 끝일까? 단순히 sendError 메소드를 호출하고 doGet 메소드는 종료된다.&lt;/p&gt;

&lt;h2 id=&quot;toc_6&quot;&gt;org.springframework.web.servlet.FrameworkServlet#doGet&lt;/h2&gt;

&lt;p&gt;HttpServlet 클래스의 하위 클래스인 &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/FrameworkServlet.html&quot;&gt;FrameworkServlet&lt;/a&gt; 클래스도 &lt;code&gt;doGet&lt;/code&gt; 메소드와 같은 HTTP method를 처리할 수 있는 메소드가 존재한다. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;HttpServlet#service 메소드는 HttpServlet#doGet 메소드를 호출하는 게 아니라, FrameworkServlet#doGet 메소드를 호출한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;FrameworkServlet 클래스에서 한 가지 주의 깊게 볼 것이 있다. FrameworkServlet부터는 Spring-MVC에서 구현한 클래스다. FrameworkServlet은 &lt;code&gt;org.springframework.web.servlet&lt;/code&gt; 패키지에 존재한다. 이 클래스부터 하위 클래스는 Spring의 구현체다.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public abstract class FrameworkServlet extends HttpServletBean implements ApplicationContextAware {
    @Override
    protected final void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        processRequest(request, response);
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;FrameworkServlet#processRequest 메소드를 호출한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_7&quot;&gt;FrameworkServlet#processRequest&lt;/h3&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    long startTime = System.currentTimeMillis();
    Throwable failureCause = null;

    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();
    LocaleContext localeContext = buildLocaleContext(request);

    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();
    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);

    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());

    initContextHolders(request, localeContext, requestAttributes);

    try {
        doService(request, response);
    }
    catch (ServletException | IOException ex) {
        failureCause = ex;
        throw ex;
    }
    catch (Throwable ex) {
        failureCause = ex;
        throw new NestedServletException(&quot;Request processing failed&quot;, ex);
    }

    finally {
        resetContextHolders(request, previousLocaleContext, previousAttributes);
        if (requestAttributes != null) {
            requestAttributes.requestCompleted();
        }
        logResult(request, response, failureCause, asyncManager);
        publishRequestHandledEvent(request, response, startTime, failureCause);
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;현재 HTTP request의 Locale을 구한다. (LocaleContextHolder.getLocaleContext() 메소드)&lt;/li&gt;
&lt;li&gt;HTTP request의 속성(session, request, response)을 담고 있는 ServletRequestAttributes 클래스를 생성한다.&lt;/li&gt;
&lt;li&gt;현재 요청된 정보(request, locale, requuest 속성 등)를 ThreadLocal에 담는다. (initContextHolders(request, localeContext, requestAttributes) 메소드)&lt;/li&gt;
&lt;li&gt;FrameworkServlet#doService 메소드를 호출한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;toc_8&quot;&gt;FrameworkServlet#doService&lt;/h3&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;protected abstract void doService(HttpServletRequest request, HttpServletResponse response) throws Exception;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;FrameworkServlet#doService 메소드는 abstract 메소드다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;toc_9&quot;&gt;DispatcherServlet#doService&lt;/h2&gt;

&lt;p&gt;FrameworkServlet의 하위 클래스인 DispatcherServlet이 &lt;code&gt;doService&lt;/code&gt; 메소드를 구현하고 있다.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public class DispatcherServlet extends FrameworkServlet {
    @Override
    protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {
        logRequest(request);

        Map&amp;lt;String, Object&amp;gt; attributesSnapshot = null;
        if (WebUtils.isIncludeRequest(request)) {
            attributesSnapshot = new HashMap&amp;lt;&amp;gt;();
            Enumeration&amp;lt;?&amp;gt; attrNames = request.getAttributeNames();
            while (attrNames.hasMoreElements()) {
                String attrName = (String) attrNames.nextElement();
                if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {
                    attributesSnapshot.put(attrName, request.getAttribute(attrName));
                }
            }
        }

        request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());
        request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);
        request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);
        request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());

        if (this.flashMapManager != null) {
            FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);
            if (inputFlashMap != null) {
                request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));
            }
            request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());
            request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);
        }

        try {
            doDispatch(request, response);
        }
        finally {
            if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
                // Restore the original attribute snapshot, in case of an include.
                if (attributesSnapshot != null) {
                    restoreAttributesAfterInclude(request, attributesSnapshot);
                }
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;HTTP 요청 log를 찍는다. (logRequest(request) 메소드)&lt;/li&gt;
&lt;li&gt;attributesSnapshot에 HTTP reqeust 속성을 보관(snapshot)한다.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;WebApplicationContext, LocaleResolver, ThemeResolver, ThemeSource를 HTTP reuqest 속성에 담는다.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());
request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);
request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);
request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;FlashMap에 속성을 저장한다. (this.flashMapManager.retrieveAndUpdate(request, response) 메소드)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FlashMap은 HTTP 요청, 응답 생명주기에도 살아있고, View가 렌더링 된 후에 삭제된다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DispatcherServlet#doDispatch(request, response) 메소드 호출&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;toc_10&quot;&gt;DispatcherServlet#doDispatcher&lt;/h3&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    boolean multipartRequestParsed = false;

    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

    try {
        ModelAndView mv = null;
        Exception dispatchException = null;

        try {
            processedRequest = checkMultipart(request);
            multipartRequestParsed = (processedRequest != request);

            // Determine handler for the current request.
            mappedHandler = getHandler(processedRequest);
            if (mappedHandler == null) {
                noHandlerFound(processedRequest, response);
                return;
            }

            // Determine handler adapter for the current request.
            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

            // Process last-modified header, if supported by the handler.
            String method = request.getMethod();
            boolean isGet = &quot;GET&quot;.equals(method);
            if (isGet || &quot;HEAD&quot;.equals(method)) {
                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;amp;&amp;amp; isGet) {
                    return;
                }
            }

            if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                return;
            }

            // Actually invoke the handler.
            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

            if (asyncManager.isConcurrentHandlingStarted()) {
                return;
            }

            applyDefaultViewName(processedRequest, mv);
            mappedHandler.applyPostHandle(processedRequest, response, mv);
        }
        catch (Exception ex) {
            dispatchException = ex;
        }
        catch (Throwable err) {
            // As of 4.3, we're processing Errors thrown from handler methods as well,
            // making them available for @ExceptionHandler methods and other scenarios.
            dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err);
        }
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    }
    catch (Exception ex) {
        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
    }
    catch (Throwable err) {
        triggerAfterCompletion(processedRequest, response, mappedHandler,
                new NestedServletException(&quot;Handler processing failed&quot;, err));
    }
    finally {
        if (asyncManager.isConcurrentHandlingStarted()) {
            // Instead of postHandle and afterCompletion
            if (mappedHandler != null) {
                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
            }
        }
        else {
            // Clean up any resources used by a multipart request.
            if (multipartRequestParsed) {
                cleanupMultipart(processedRequest);
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;DispatcherServlet은 여러 가지 Resolver와 클래스를 이용해 요청을 처리한다. 때문에 이 글에서 모두 설명하기는 어렵고 대략적인 것만 설명할 예정이다. 자세한 설명은 다음 글에서 여러 가지 Resolver를 하나씩 살펴볼 예정이다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Multipart&lt;/code&gt; 요청 인지 체크한다. (DispatcherServlet#checkMultipart(request) 메소드)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HTTP 요청에 해당하는&lt;/code&gt; &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/HandlerExecutionChain.html&quot;&gt;HandlerExecutionChain&lt;/a&gt;을 구한다. (DispatcherServlet#getHandler(processedRequest) 메소드)

&lt;ul&gt;
&lt;li&gt;URL을 기준으로 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/HandlerMapping.html&quot;&gt;HandlerMapping&lt;/a&gt;을 찾는다.&lt;/li&gt;
&lt;li&gt;HandlerExecutionChain은 HandlerMapping에 의해 생성된다.&lt;/li&gt;
&lt;li&gt;HandlerExecutionChain은 Interceptor List를 포함하고 있다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;HandlerExecutionChain이 null이면 &lt;code&gt;HTTP Status 404를 response&lt;/code&gt; 한다. (DispatcherServlet#noHandlerFound(processedRequest, response) 메소드)

&lt;ul&gt;
&lt;li&gt;개발하며 자주 보게 되는 404 not found error를 이 메소드에서 실행한다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Controller를 실행하기 위해 &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/HandlerAdapter.html&quot;&gt;HandlerAdapter&lt;/a&gt;를 구한다.(DispatcherServlet#getHandlerAdapter(mappedHandler.getHandler()) 메소드)

&lt;ul&gt;
&lt;li&gt;HandlerAdapter는 우리가 작성한 Controller를 실행하는 역할을 한다.&lt;/li&gt;
&lt;li&gt;HandlerMapping은 URL을 기준으로 어떤 Handler로 매핑할지 결정한다면, HandlerAdapter는 결정된 Handler를 실행한다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/HandlerInterceptor.html&quot;&gt;HandlerInterceptor&lt;/a&gt;로 전처리(Interceptor#preHandle)를 실행한다. (mappedHandler.applyPreHandle(processedRequest, response) 메소드)&lt;/li&gt;
&lt;li&gt;HandlerAdapter#handle 메소드를 호출해 실제 로직(Controller)을 실행한 후 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/ModelAndView.html&quot;&gt;ModelAndView&lt;/a&gt;를 생성한다. (mv = ha.handle(processedRequest, response, mappedHandler.getHandler()) 메소드)&lt;/li&gt;
&lt;li&gt;Interceptor로 후처리(Interceptor#postHandle)를 실행한다. (mappedHandler.applyPostHandle(processedRequest, response, mv) 메소드)&lt;/li&gt;
&lt;li&gt;View를 렌더링 하거나, Exception을 핸들링한다. (processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException) 메소드)

&lt;ul&gt;
&lt;li&gt;View 렌더링은 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/ViewResolver.html&quot;&gt;ViewResolver&lt;/a&gt;가 담당한다.&lt;/li&gt;
&lt;li&gt;Exception 핸들링은 &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/HandlerExceptionResolver.html&quot;&gt;HandlerExceptionResolver&lt;/a&gt;가 담당한다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;toc_11&quot;&gt;DispatcherServlet#doDispatcher에서 알아야 할 것.&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Multipart (파일 업로드)를 처리하는 MultipartResolver&lt;/li&gt;
&lt;li&gt;Controller 실행에 필요한 HandlerMapping, HandlerAdapter 그리고 ModelAndView&lt;/li&gt;
&lt;li&gt;View 렌더링 또는 Exception 핸들링에 필요한 ViewResolver와 HandlerExceptionResolver&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;toc_12&quot;&gt;책 추천&lt;/h3&gt;

&lt;p&gt;이 글에서 설명한 DispatcherServlet에 대한 자세한 설명을 다룬 책이 있다.
&lt;a href=&quot;http://www.yes24.com/24/Goods/11043166?Acode=101&quot;&gt;스프링 MVC 프로그래밍&lt;/a&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/369&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>Spring</category>
<category>spring-mvc</category>
<category>spring-webmvc</category>
<author>woniper</author>
<guid>https://blog.woniper.net/369</guid>
<comments>https://blog.woniper.net/369#entry369comment</comments>
<pubDate>Tue, 15 Jan 2019 08:46:26 +0900</pubDate>
</item>
<item>
<title>Spring-MVC 읽기 #5. AbstractDispatcherServletInitializer와 AbstractAnnotationConfigDispatcherServletInitializer</title>
<link>https://blog.woniper.net/368</link>
<description>&lt;p&gt;이번 글은 &lt;code&gt;AbstractContextLoaderInitializer&lt;/code&gt; 클래스의 하위 클래스인 &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/support/AbstractDispatcherServletInitializer.html&quot;&gt;AbstractDispatcherServletInitializer&lt;/a&gt; 클래스와 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/support/AbstractAnnotationConfigDispatcherServletInitializer.html&quot;&gt;AbstractAnnotationConfigDispatcherServletInitializer&lt;/a&gt; 클래스를 살펴볼 것이다.&lt;/p&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;AbstractDispatcherServletInitializer&lt;/h2&gt;

&lt;p&gt;AbstractContextLoaderInitializer 클래스는 ContextLoader를 통해 root WebApplicationContext를 생성하고, 초기화(refresh)한다는 걸 이해했다. 마찬가지로 AbstractDispatcherServletInitializer 클래스는 DispatcherServlet을 생성하고 초기화한다.&lt;/p&gt;

&lt;h3 id=&quot;toc_1&quot;&gt;AbstractDispatcherServletInitializer#registerDispatcherServlet&lt;/h3&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Override
public void onStartup(ServletContext servletContext) throws ServletException {
    super.onStartup(servletContext);
    registerDispatcherServlet(servletContext);
}

protected void registerDispatcherServlet(ServletContext servletContext) {
    String servletName = getServletName();
    Assert.hasLength(servletName, &amp;quot;getServletName() must not return null or empty&amp;quot;);

    WebApplicationContext servletAppContext = createServletApplicationContext();
    Assert.notNull(servletAppContext, &amp;quot;createServletApplicationContext() must not return null&amp;quot;);

    FrameworkServlet dispatcherServlet = createDispatcherServlet(servletAppContext);
    Assert.notNull(dispatcherServlet, &amp;quot;createDispatcherServlet(WebApplicationContext) must not return null&amp;quot;);
    dispatcherServlet.setContextInitializers(getServletApplicationContextInitializers());

    ServletRegistration.Dynamic registration = servletContext.addServlet(servletName, dispatcherServlet);
    if (registration == null) {
        throw new IllegalStateException(&amp;quot;Failed to register servlet with name &amp;#39;&amp;quot; + servletName + &amp;quot;&amp;#39;. &amp;quot; +
                &amp;quot;Check if there is another servlet registered under the same name.&amp;quot;);
    }

    registration.setLoadOnStartup(1);
    registration.addMapping(getServletMappings());
    registration.setAsyncSupported(isAsyncSupported());

    Filter[] filters = getServletFilters();
    if (!ObjectUtils.isEmpty(filters)) {
        for (Filter filter : filters) {
            registerServletFilter(servletContext, filter);
        }
    }

    customizeRegistration(registration);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;onStartup 메소드는 registerDispatcherServlet 메소드를 호출한다.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;WebApplicationContext를 생성(createServletApplicationContext) 한 후 FrameworkServlet을 생성(createDispatcherServlet(servletAppContext))한다.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;protected FrameworkServlet createDispatcherServlet(WebApplicationContext servletAppContext) {
    return new DispatcherServlet(servletAppContext);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;createDispatcherServlet 메소드는 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/DispatcherServlet.html&quot;&gt;DispatcherServlet&lt;/a&gt; 생성한다. WebApplicationContext을 생성자 주입한다.&lt;/li&gt;
&lt;li&gt;DispatcherServlet은 FrontController 역할을 하며, Spring-MVC에서 가장 중요한 클래스라 이해하고 넘어가자. 자세한 설명은 다음 글에서.&lt;/li&gt;
&lt;li&gt;FrameworkServlet은 DispatcherServlet의 상위 클래스다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;AbstractAnnotationConfigDispatcherServletInitializer&lt;/h2&gt;

&lt;p&gt;AbstractDispatcherServletInitializer 클래스의 하위 클래스인 AbstractAnnotationConfigDispatcherServletInitializer는 AbstractContextLoaderInitializer 클래스에서 생성되는 root WebApplicationContext의 구현체인 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/context/support/AnnotationConfigWebApplicationContext.html&quot;&gt;AnnotationConfigWebApplicationContext&lt;/a&gt;를 생성한다.&lt;/p&gt;

&lt;h3 id=&quot;toc_3&quot;&gt;AbstractAnnotationConfigDispatcherServletInitializer#createRootApplicationContext&lt;/h3&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Override
@Nullable
protected WebApplicationContext createRootApplicationContext() {
    Class&amp;lt;?&amp;gt;[] configClasses = getRootConfigClasses();
    if (!ObjectUtils.isEmpty(configClasses)) {
        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
        context.register(configClasses);
        return context;
    }
    else {
        return null;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;WebApplicationContext의 구현체인 AnnotationConfigWebApplicationContext 클래스를 return 한다.&lt;/li&gt;
&lt;li&gt;설정 클래스를 등록한다. (AnnotationConfigWebApplicationContext#register 메소드)

&lt;ul&gt;
&lt;li&gt;AnnotationConfigWebApplicationContext는 @Annotation을 이용해 설정 가능한 ApplicationContext의 구현체다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;toc_4&quot;&gt;마무리&lt;/h2&gt;

&lt;p&gt;이 글에서 설명하는 클래스는 2가지 중요한 일을 한다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;DispatcherServlet을 생성한다.&lt;/li&gt;
&lt;li&gt;WebApplicationContext의 구현체인 AnnotationConfigWebApplicationContext를 생성한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.woniper.net/366&quot;&gt;Spring-MVC의 시작&lt;/a&gt; 부터 현재 글까지 다시 한번 정리해보자.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;WAS는 ServletContainerInitializer를 실행한다.&lt;/li&gt;
&lt;li&gt;ServletContainerInitializer의 구현체인 SpringServletContainerInitializer는 WebApplicationInitializer를 실행한다.&lt;/li&gt;
&lt;li&gt;WebApplicationInitializer는 아래와 같은 세 개의 구현체가 있다.

&lt;ul&gt;
&lt;li&gt;AbstractContextLoaderInitializer는 ContextLoader를 이용해 WebApplicationContext를 초기화한다.&lt;/li&gt;
&lt;li&gt;AbstractDispatcherServletInitializer는 DispatcherServlet을 생성하고 초기화한다.&lt;/li&gt;
&lt;li&gt;AbstractAnnotationConfigDispatcherServletInitializer는 AnnotationConfigWebApplicationContext를 생성한다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;다음 글은 Spring-MVC의 핵심이라 할 수 있는 DispatcherServlet을 볼 예정이다.&lt;/p&gt;
&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/368&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>Spring</category>
<category>spring-mvc</category>
<category>spring-webmvc</category>
<author>woniper</author>
<guid>https://blog.woniper.net/368</guid>
<comments>https://blog.woniper.net/368#entry368comment</comments>
<pubDate>Tue, 08 Jan 2019 07:41:34 +0900</pubDate>
</item>
<item>
<title>Spring-MVC 읽기 #4. AbstractContextLoaderInitializer</title>
<link>https://blog.woniper.net/367</link>
<description>&lt;p&gt;이전 글에서 WebApplicationInitializer 구조에 대해 봤다. 이번 글은 WebApplicationInitializer 구현체 중 하나인 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/context/AbstractContextLoaderInitializer.html&quot;&gt;AbstractContextLoaderInitializer&lt;/a&gt; 클래스에 대해 이야기해볼 예정이다.&lt;/p&gt;&lt;p&gt;코드를 보자.&lt;/p&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;AbstractContextLoaderInitializer&lt;/h2&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public abstract class AbstractContextLoaderInitializer implements WebApplicationInitializer {

    /** Logger available to subclasses. */
    protected final Log logger = LogFactory.getLog(getClass());

    @Override
    public void onStartup(ServletContext servletContext) throws ServletException {
        registerContextLoaderListener(servletContext);
    }

    protected void registerContextLoaderListener(ServletContext servletContext) {
        WebApplicationContext rootAppContext = createRootApplicationContext();
        if (rootAppContext != null) {
            ContextLoaderListener listener = new ContextLoaderListener(rootAppContext);
            listener.setContextInitializers(getRootApplicationContextInitializers());
            servletContext.addListener(listener);
        }
        else {
            logger.debug(&quot;No ContextLoaderListener registered, as &quot; +
                    &quot;createRootApplicationContext() did not return an application context&quot;);
        }
    }
    
    @Nullable
    protected abstract WebApplicationContext createRootApplicationContext();

    @Nullable
    protected ApplicationContextInitializer&amp;lt;?&amp;gt;[] getRootApplicationContextInitializers() {
        return null;
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;ServletContext에 &lt;code&gt;ContextLoaderListener&lt;/code&gt;를 등록한다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;라고 주석에 쓰여 있다. 그리고 이 클래스는 Spring 버전 3.2에 만들어졌고, 클래스 작성을 &lt;code&gt;Arjen Poutsma, Chris Beams, Juergen Hoeller&lt;/code&gt; 라는 개발자들이 작성했다. 오픈소스를 보며 유명 개발자가 작성한 코드를 보는 것 또한 하나의 재미다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;AbstractContextLoaderInitializer#registerContextLoaderListener 메소드는 &lt;code&gt;ContextLoaderListener&lt;/code&gt;를 생성한다.&lt;/li&gt;
&lt;li&gt;ContextLoaderListener에 ApplicationContextInitializer&amp;lt;?&amp;gt;[]를 주입(&lt;code&gt;ContextLoaderListener#setContextInitializers&lt;/code&gt; 메소드)한다.

&lt;ul&gt;
&lt;li&gt;AbstractContextLoaderInitializer#getRootApplicationContextInitializers 메소드는 &lt;code&gt;null&lt;/code&gt;을 반환한다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ServletContext에 ContextLoaderListener를 추가(&lt;code&gt;ServletContext#addListener&lt;/code&gt; 메소드)한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;ContextLoaderListener&lt;/h2&gt;

&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/992EB63A5C296BC405&quot; filemime=&quot;image/jpeg&quot; filename=&quot;ContextLoaderListener.png&quot; height=&quot;137&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/context/ContextLoaderListener.html&quot;&gt;ContextLoaderListener&lt;/a&gt; 클래스는 &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/ContextLoader.html&quot;&gt;ContextLoader&lt;/a&gt;를 상속(extends)하고, &lt;a href=&quot;https://docs.oracle.com/javaee/7/api/javax/servlet/ServletContextListener.html&quot;&gt;ServletContextListener&lt;/a&gt;를 구현(implements)하고 있다.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public class ContextLoaderListener extends ContextLoader implements ServletContextListener {

    public ContextLoaderListener() {
    }

    public ContextLoaderListener(WebApplicationContext context) {
        super(context);
    }

    /**
     * Initialize the root web application context.
     */
    @Override
    public void contextInitialized(ServletContextEvent event) {
        initWebApplicationContext(event.getServletContext());
    }

    /**
     * Close the root web application context.
     */
    @Override
    public void contextDestroyed(ServletContextEvent event) {
        closeWebApplicationContext(event.getServletContext());
        ContextCleanupListener.cleanupAttributes(event.getServletContext());
    }

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;ContextLoaderListener#contextInitialized 메소드는 ServletContextListener 인터페이스의 구현 메소드다.&lt;/li&gt;
&lt;li&gt;ContextLoaderListener#contextInitialized 메소드의 이름과 주석을 보니 &lt;code&gt;root Web ApplicationContext 초기화&lt;/code&gt; 하는 메소드이다.&lt;/li&gt;
&lt;li&gt;ContextLoaderListener#contextInitialized 메소드는 &lt;code&gt;ContextLoader#initWebApplicationContext&lt;/code&gt; 메소드를 호출한다.&lt;/li&gt;
&lt;li&gt;ContextLoaderListener#contextDestroyed 메소드는 ServletContextListener 인터페이스의 구현 메소드다.&lt;/li&gt;
&lt;li&gt;ContextLoaderListener#contextDestroyed 메소드의 이름과 주석을 보니 &lt;code&gt;root Web ApplicationContext를 종료&lt;/code&gt;하는 메소드이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;아직 자세한 코드를 보지 못해 추정만 할 뿐이다. 두 개의 메소드 중 &lt;code&gt;contextInitialized&lt;/code&gt; 메소드만 한번 살펴보자.&lt;/p&gt;

&lt;h3 id=&quot;toc_2&quot;&gt;ContextLoader#initWebApplicationContext&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ContextLoader#initWebApplicationContext&lt;/code&gt; 메소드는 ContextLoaderListener 클래스의 부모 클래스인 ContextLoader가 포함하고 있다. 중요한 행동이라고 생각되는 부분을 제외한 나머지 코드는 &lt;code&gt;중략&lt;/code&gt;한다.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public WebApplicationContext initWebApplicationContext(ServletContext servletContext) {
    // ... 중략 ...

    try {
        if (this.context == null) {
            this.context = createWebApplicationContext(servletContext);
        }
        if (this.context instanceof ConfigurableWebApplicationContext) {
            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;
            if (!cwac.isActive()) {
                if (cwac.getParent() == null) {
                    ApplicationContext parent = loadParentContext(servletContext);
                    cwac.setParent(parent);
                }
                configureAndRefreshWebApplicationContext(cwac, servletContext);
            }
        }
        
        // ... 중략 ...

        return this.context;
    }
    catch (RuntimeException | Error ex) {
        logger.error(&quot;Context initialization failed&quot;, ex);
        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);
        throw ex;
    }
}  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;context(WebApplicationContext)가 null이면, WebApplicationContext를 생성(&lt;code&gt;ContextLoader#createWebApplicationContext&lt;/code&gt; 메소드) 한다.

&lt;ul&gt;
&lt;li&gt;ContextLoader는 AbstractContextLoaderInitializer에서 WebApplicationContext를 생성자로 주입했기 때문에 null이 아니다.&lt;/li&gt;
&lt;li&gt;AbstractContextLoaderInitializer#registerContextLoaderListener 메소드를 다시 보자.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;부모 WebApplicationContext(&lt;code&gt;cwac.getParent&lt;/code&gt; 메소드)가 null이면, 부모 WebApplicationContext을 load(&lt;code&gt;loadParentContext&lt;/code&gt; 메소드) 후 주입(&lt;code&gt;cwac.setParent&lt;/code&gt; 메소드) 한다.&lt;/li&gt;
&lt;li&gt;WebApplicationContext에 설정(configure)과 초기화(refresh)를 한다. (&lt;code&gt;configureAndRefreshWebApplicationContext&lt;/code&gt; 메소드)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;toc_3&quot;&gt;ContextLoader#configureAndRefreshWebApplicationContext&lt;/h3&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {
    // ... 중략 ...

    ConfigurableEnvironment env = wac.getEnvironment();
    if (env instanceof ConfigurableWebEnvironment) {
        ((ConfigurableWebEnvironment) env).initPropertySources(sc, null);
    }

    customizeContext(sc, wac);
    wac.refresh();
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;Environment를 WebApplicationContext에 초기화(&lt;code&gt;((ConfigurableWebEnvironment) env).initPropertySources(sc, null)&lt;/code&gt;) 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WebApplicationContext#refresh&lt;/code&gt; 메소드를 호출한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;WebApplicationContext가 자주 등장한다. 이전 글에서도 말했다시피 ApplicationContext 설명은 &lt;a href=&quot;http://blog.woniper.net/338?category=699184&quot;&gt;이 글&lt;/a&gt;을 참고하자.&lt;/p&gt;

&lt;h2 id=&quot;toc_4&quot;&gt;그런데 ServletContextListener#contextInitialized 메소드는 어디서 실행될까?&lt;/h2&gt;

&lt;p&gt;ContextLoaderListener가 결국 &lt;code&gt;WebApplicationContext#refresh&lt;/code&gt;를 하는 건 알았다. 그런데 초기화하기 위한 &lt;code&gt;ServletContextListener#contextInitialized&lt;/code&gt; 메소드는 어디서 누가 실행하는 걸까? 결론부터 말하자면, WAS(Web Application Server)가 실행한다. 나는 Tomcat을 기준으로 코드를 봤는데, Tomcat 코드까지 코드를 분석하는 건 너무 시간이 오래 걸릴 거 같고 아주 좋은 분석 글이 있어 자세한 설명은 &lt;a href=&quot;https://medium.com/chequer/tomcat-spring-bootstrapping-sequence-2%ED%8E%B8-spring-e19705529132&quot;&gt;Tomcat &amp;amp; Spring Bootstrapping Sequence — 2편 Spring&lt;/a&gt; 글로 대신하고, 나는 이 글을 토대로 대략적인 설명만 해야겠다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ContextLoaderListener#registerContextLoaderListener 메소드를 다시 보면 &lt;code&gt;servletContext.addListener(listener);&lt;/code&gt; 이런 코드가 있다. 이 코드는 ServletContext에 ContextLoaderListener 클래스를 추가(add) 하는 메소드다.&lt;/li&gt;
&lt;li&gt;ServletContext는 인터페이스다.&lt;/li&gt;
&lt;li&gt;Tomcat에 ServletContext 인터페이스의 구현체인 &lt;a href=&quot;https://tomcat.apache.org/tomcat-8.0-doc/api/org/apache/catalina/core/ApplicationContext.html&quot;&gt;ApplicationContext&lt;/a&gt;라는 클래스가 있다.

&lt;ul&gt;
&lt;li&gt;Spring의 ApplicationContext가 아니다.&lt;/li&gt;
&lt;li&gt;Tomcat의 ApplicationContext다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ApplicationContext#addListener&lt;/code&gt; 메소드를 보면 ServletContextListener 객체를 &lt;a href=&quot;&quot;&gt;StandardContext&lt;/a&gt; 클래스의 &lt;code&gt;addApplicationLifecycleListener&lt;/code&gt; 메소드로 추가한다. 

&lt;ul&gt;
&lt;li&gt;ContextLoaderListener는 ServletContextListener 구현체다.&lt;/li&gt;
&lt;li&gt;그러므로 &lt;code&gt;StandardContext#addApplicationLifecycleListener&lt;/code&gt; 메소드로 ContextLoaderListener 추가가 가능하다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/chequer/tomcat-spring-bootstrapping-sequence-2%ED%8E%B8-spring-e19705529132&quot;&gt;Tomcat &amp;amp; Spring Bootstrapping Sequence — 2편 Spring&lt;/a&gt; 글에 따르면, Tomcat의 라이프사이클에 의해 &lt;code&gt;StandardContext#startInternal&lt;/code&gt; 메소드가 호출된다고 한다.

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;StandardContext#startInternal&lt;/code&gt; 메소드는 &lt;a href=&quot;http://blog.woniper.net/366&quot;&gt;Spring-MVC 읽기 #3. Spring-MVC의 시작&lt;/a&gt; 글에서 봤던 &lt;code&gt;onStartup&lt;/code&gt; 메소드를 호출한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StandardContext#startInternal&lt;/code&gt; 메소드는 &lt;code&gt;StandardContext#listenerStart&lt;/code&gt; 메소드를 호출한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StandardContext#listenerStart&lt;/code&gt; 메소드는 &lt;code&gt;ServletContextListener#contextInitialized&lt;/code&gt; 메소드를 호출한다. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServletContextListener#contextInitialized&lt;/code&gt; 메소드는 root Web ApplicationContext를 &lt;code&gt;초기화(refresh)&lt;/code&gt; 한다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;toc_5&quot;&gt;마무리&lt;/h2&gt;

&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9939743A5C296BD305&quot; filemime=&quot;image/jpeg&quot; filename=&quot;AbstractContextLoaderInitializerDiagram.png&quot; height=&quot;364&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;마지막 Tomcat에서 &lt;code&gt;ServletContextListener#contextInitialized&lt;/code&gt; 메소드를 호출하는 부분을 자세히 설명하지 않아 이해하기 조금 어려울 수 있지만, 이해가 안 되면 &lt;a href=&quot;https://medium.com/chequer/tomcat-spring-bootstrapping-sequence-2%ED%8E%B8-spring-e19705529132&quot;&gt;Tomcat &amp;amp; Spring Bootstrapping Sequence — 2편 Spring&lt;/a&gt;을 읽고 다시 읽어보면 좀 더 이해가 잘될 거라 생각한다. 그래도 이해 안 가면 댓글 ㄱ&lt;/p&gt;&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/367&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>Spring</category>
<category>spring-mvc</category>
<category>spring-webmvc</category>
<author>woniper</author>
<guid>https://blog.woniper.net/367</guid>
<comments>https://blog.woniper.net/367#entry367comment</comments>
<pubDate>Mon, 31 Dec 2018 10:08:17 +0900</pubDate>
</item>
<item>
<title>Spring-MVC 읽기 #3. Spring-MVC의 시작</title>
<link>https://blog.woniper.net/366</link>
<description>&lt;h4 id=&quot;toc_0&quot;&gt;주의) 저도 처음 코드를 읽으며 작성하는 글이기 때문에 어렵게 전달되거나, 틀린 부분은 언제든 피드백을 해주세요.&lt;/h4&gt;

&lt;p&gt;이번 글은 Spring-MVC의 &lt;code&gt;시작&lt;/code&gt;에 대해 알아볼 것이다.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public static void main(String... args) {}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;java 개발자라면 위 코드는 익숙하다. java에서 main 메소드는 애플리케이션의 최초 시작점이다. 그런데 Spring-MVC로 개발한 웹 애플리케이션을 war로 빌드 후 Web Application Server(이하 WAS)로 실행하는 경우엔 main 메소드가 최초 시작점이 아닌 것을 알 수 있다. WAS 실행이 최초 시작점이라고 볼 수도 있겠다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Spring Boot를 사용하면 main 메소드가 최초 시작점이다. 이 글은 Spring Boot를 이야기하고자 하는 게 아니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;ServletContainerInitializer&lt;/h2&gt;

&lt;p&gt;그렇다면 WAS는 어떻게 내가 만든 웹 애플리케이션을 실행할까?
바로 &lt;a href=&quot;https://tomcat.apache.org/tomcat-8.0-doc/servletapi/javax/servlet/ServletContainerInitializer.html&quot;&gt;ServletContainerInitializer&lt;/a&gt;을 실행한다. 이 인터페이스는 Spring-MVC에 정의된 인터페이스가 아니다. servlet 3.0에 정의된 인터페이스다.&lt;/p&gt;&lt;p&gt;이 인터페이스는 단순하다.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public interface ServletContainerInitializer {
    void onStartup(Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; c, ServletContext ctx) throws ServletException;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;onStartup 메소드가 하나가 존재한다.&lt;/p&gt;

&lt;h3 id=&quot;toc_2&quot;&gt;그렇다면 나는 어떻게 WAS가 ServletContainerInitializer를 실행하는 걸 알았을까?&lt;/h3&gt;

&lt;p&gt;onStartup 이라는 메소드명이 왠지 시작하게 생겨서 일까? 당연히 아니다. 오픈소스 코드를 좀 더 쉽게 읽기 위해서는 &lt;code&gt;시작점&lt;/code&gt;이 어딘지부터 찾아보는 게 좋다. 아마 한 번씩 궁금했을 텐데(나만 그런가??) Spring으로 만든 웹 애플리케이션은 어떻게 실행될까?&lt;/p&gt;&lt;p&gt;그럼 시작점이 ServletContainerInitializer이라는 건 어떻게 알았을까? 구글링!
구글 없이 개발할 수 있을까? 나는 자신 없다. 모르면 구글에 물어보자. ServletContainerInitializer 인터페이스의 역할을 찾아보기 위해 검색 결과의 글을 참고하자.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://toby.epril.com/?p=1205&quot;&gt;스프링 3.1 (8) web.xml 없는 스프링 개발&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/chequer/tomcat-spring-bootstrapping-sequence-2%ED%8E%B8-spring-e19705529132&quot;&gt;Tomcat &amp;amp; Spring Bootstrapping Sequence — 2편 Spring&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_3&quot;&gt;ServletContainerInitializer의 구조&lt;/h3&gt;

&lt;p&gt;그럼 내가 궁금했던 게 해결됐다. 일단 ServletContainerInitializer가 실행되는 건 알았는데 인터페이스뿐이다. 내가 보고 싶은 건 구현체의 코드가 보고 싶을 뿐이다. intellij의 기능을 이용해 하위 클래스 구조를 찾아보자.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/992D0A4B5C1F234E13&quot; filemime=&quot;image/jpeg&quot; filename=&quot;ServletContainerInitializer.png&quot; height=&quot;220&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;ServletContainerInitializer의 구현체를 찾아보니 몇 개의 클래스들이 보인다. 구현체들이 많은데 어떻게 하나씩 다 볼 수 있을까? 그럴 수 없다. 내가 보고 싶은 구현체는 단지 Spring 웹 애플리케이션을 실행하는 구현체가 보고 싶을 뿐이다. 하위 클래스를 살펴보니 Spring 클래스가 하나 눈에 띈다. 바로 &lt;code&gt;SpringServletContainerInitializer&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;br /&gt;&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;하위 클래스가 너무 많아 어떤 클래스부터 봐야 할 지 모르겠다면, 문서나 주석을 읽어보자. Spring은 문서뿐 아니라 주석도 친절히 작성되어 있다. 코드를 읽어보지 않아도 클래스가 어떤 책임을 갖고 있는지 알 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;toc_4&quot;&gt;SpringServletContainerInitializer&lt;/h2&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@HandlesTypes(WebApplicationInitializer.class)
public class SpringServletContainerInitializer implements ServletContainerInitializer {

    @Override
    public void onStartup(@Nullable Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; webAppInitializerClasses, ServletContext servletContext)
            throws ServletException {

        List&amp;lt;WebApplicationInitializer&amp;gt; initializers = new LinkedList&amp;lt;&amp;gt;();

        if (webAppInitializerClasses != null) {
            for (Class&amp;lt;?&amp;gt; waiClass : webAppInitializerClasses) {
                if (!waiClass.isInterface() &amp;amp;&amp;amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;amp;&amp;amp;
                        WebApplicationInitializer.class.isAssignableFrom(waiClass)) {
                    try {
                        initializers.add((WebApplicationInitializer)
                                ReflectionUtils.accessibleConstructor(waiClass).newInstance());
                    }
                    catch (Throwable ex) {
                        throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex);
                    }
                }
            }
        }

        if (initializers.isEmpty()) {
            servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;);
            return;
        }

        servletContext.log(initializers.size() + &quot; Spring WebApplicationInitializers detected on classpath&quot;);
        AnnotationAwareOrderComparator.sort(initializers);
        for (WebApplicationInitializer initializer : initializers) {
            initializer.onStartup(servletContext);
        }
    }

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;파라미터로 받은 &lt;code&gt;Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;&lt;/code&gt; 을 반복해서 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/WebApplicationInitializer.html&quot;&gt;WebApplicationInitializer&lt;/a&gt;로 생성(newInstance)해 &lt;code&gt;initializers list&lt;/code&gt;에 담는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;initializers list&lt;/code&gt;를 정렬해 &lt;code&gt;WebApplicationInitializer#onStartup&lt;/code&gt; 메소드를 실행한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;전체적인 구조를 먼저 파악하기 위해 &lt;code&gt;WebApplicationInitializer&lt;/code&gt;가 어떤 역할을 하는 인터페이스인지부터 찾아보자.&lt;/p&gt;

&lt;h3 id=&quot;toc_5&quot;&gt;WebApplicationInitializer&lt;/h3&gt;

&lt;p&gt;다시 인터페이스가 등장했다. 구현체를 다시 살펴보자.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/993CE5475C1F238B0E&quot; filemime=&quot;image/jpeg&quot; filename=&quot;WebApplicationInitializer.png&quot; height=&quot;188&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Spring5에 Reactive가 추가됐다. 나는 Reactive를 당장 볼 생각은 없다. &lt;/p&gt;&lt;p&gt;내가 봐야 할 클래스는 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/context/AbstractContextLoaderInitializer.html&quot;&gt;AbstractContextLoaderInitializer&lt;/a&gt;와 그 아래 클래스들이다. 그런데 prefix로 &lt;code&gt;My&lt;/code&gt;가 붙은 클래스는 뭘까? 코드를 따라가 보니 테스트 코드에서 사용될 mock 클래스다. 테스트 코드에 사용된 mock 클래스를 읽어볼 필요가 있을까? 좋은 방법이다. 테스트 코드를 살펴보는 건 매우 좋은 방법이다. 실행을 해봐도 좋고, 내가 추가로 테스트 코드를 작성해보며 클래스를 학습해 봐도 좋다.&lt;/p&gt;

&lt;h3 id=&quot;toc_6&quot;&gt;AbstractContextLoaderInitializer&lt;/h3&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public abstract class AbstractContextLoaderInitializer implements WebApplicationInitializer {

    protected final Log logger = LogFactory.getLog(getClass());

    @Override
    public void onStartup(ServletContext servletContext) throws ServletException {
        registerContextLoaderListener(servletContext);
    }

    protected void registerContextLoaderListener(ServletContext servletContext) {
        WebApplicationContext rootAppContext = createRootApplicationContext();
        if (rootAppContext != null) {
            ContextLoaderListener listener = new ContextLoaderListener(rootAppContext);
            listener.setContextInitializers(getRootApplicationContextInitializers());
            servletContext.addListener(listener);
        }
        else {
            logger.debug(&quot;No ContextLoaderListener registered, as &quot; +
                    &quot;createRootApplicationContext() did not return an application context&quot;);
        }
    }

    @Nullable
    protected abstract WebApplicationContext createRootApplicationContext();

    @Nullable
    protected ApplicationContextInitializer&amp;lt;?&amp;gt;[] getRootApplicationContextInitializers() {
        return null;
    }

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;AbstractContextLoaderInitializer&lt;/code&gt; 클래스는 추상 클래스다.&lt;/li&gt;
&lt;li&gt;onStartup 메소드는 &lt;code&gt;registerContextLoaderListener&lt;/code&gt; 메소드를 호출한다.&lt;/li&gt;
&lt;li&gt;registerContextLoaderListener 메소드는 &lt;code&gt;WebApplicationContext(rootAppContext)&lt;/code&gt;를 생성한다. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;ContextLoaderListener&lt;/code&gt;를 생성해 &lt;code&gt;setContextInitializers&lt;/code&gt; 메소드를 호출한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServletContext#addListene&lt;/code&gt; 메소드에 &lt;code&gt;ContextLoaderListener&lt;/code&gt;를 추가한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ContextLoaderListener가 무엇인지는 나중으로 미루고, &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/context/WebApplicationContext.html&quot;&gt;WebApplicationContext&lt;/a&gt;를 생성하는 &lt;code&gt;createRootApplicationContext&lt;/code&gt; 메소드를 먼저 보자. WebApplicationContext 인터페이스의 구현체를 살펴보자. 그런데 WebApplicationContext를 생성하는  &lt;code&gt;createRootApplicationContext&lt;/code&gt; 메소드는 추상 메소드다. 그렇다면 하위 클래스에서 &lt;code&gt;createRootApplicationContext&lt;/code&gt; 메소드를 정의하고 있지 않을까?&lt;/p&gt;

&lt;h3 id=&quot;toc_7&quot;&gt;AbstractDispatcherServletInitializer&lt;/h3&gt;

&lt;p&gt;구조를 살펴봤을 때 AbstractContextLoaderInitializer의 하위 클래스는 &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/support/AbstractDispatcherServletInitializer.html&quot;&gt;AbstractDispatcherServletInitializer&lt;/a&gt; 클래스다. 이 클래스 역시 이름을 보니 추상 클래스인 거 같다.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public abstract class AbstractDispatcherServletInitializer extends AbstractContextLoaderInitializer {

    public static final String DEFAULT_SERVLET_NAME = &quot;dispatcher&quot;;


    @Override
    public void onStartup(ServletContext servletContext) throws ServletException {
        super.onStartup(servletContext);
        registerDispatcherServlet(servletContext);
    }
    
    protected void registerDispatcherServlet(ServletContext servletContext) {
        String servletName = getServletName();
        Assert.hasLength(servletName, &quot;getServletName() must not return null or empty&quot;);

        WebApplicationContext servletAppContext = createServletApplicationContext();
        Assert.notNull(servletAppContext, &quot;createServletApplicationContext() must not return null&quot;);

        FrameworkServlet dispatcherServlet = createDispatcherServlet(servletAppContext);
        Assert.notNull(dispatcherServlet, &quot;createDispatcherServlet(WebApplicationContext) must not return null&quot;);
        dispatcherServlet.setContextInitializers(getServletApplicationContextInitializers());

        ServletRegistration.Dynamic registration = servletContext.addServlet(servletName, dispatcherServlet);
        if (registration == null) {
            throw new IllegalStateException(&quot;Failed to register servlet with name '&quot; + servletName + &quot;'. &quot; +
                    &quot;Check if there is another servlet registered under the same name.&quot;);
        }

        registration.setLoadOnStartup(1);
        registration.addMapping(getServletMappings());
        registration.setAsyncSupported(isAsyncSupported());

        Filter[] filters = getServletFilters();
        if (!ObjectUtils.isEmpty(filters)) {
            for (Filter filter : filters) {
                registerServletFilter(servletContext, filter);
            }
        }

        customizeRegistration(registration);
    }

    protected abstract WebApplicationContext createServletApplicationContext();

    protected FrameworkServlet createDispatcherServlet(WebApplicationContext servletAppContext) {
        return new DispatcherServlet(servletAppContext);
    }

    // ... 중략 ...

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;onStartup&lt;/code&gt; 메소드는 &lt;code&gt;registerDispatcherServlet&lt;/code&gt; 메소드를 호출한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AbstractDispatcherServletInitializer&lt;/code&gt; 클래스 역시 &lt;code&gt;createRootApplicationContext&lt;/code&gt; 메소드를 재정의하고 있지 않다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;registerDispatcherServlet&lt;/code&gt; 메소드를 보니 중간에 &lt;code&gt;createServletApplicationContext&lt;/code&gt;와 &lt;code&gt;createDispatcherServlet&lt;/code&gt; 메소드를 호출한다. ApplicationContext와 DispatcherServlet을 생성하는 메소드인 거 같다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;createServletApplicationContext&lt;/code&gt; 메소드는 추상 메소드다.&lt;/li&gt;
&lt;li&gt;다시 &lt;code&gt;createServletApplicationContext&lt;/code&gt;와 &lt;code&gt;createRootApplicationContext&lt;/code&gt;의 구현 메소드를 찾아보자. &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;toc_8&quot;&gt;AbstractAnnotationConfigDispatcherServletInitializer&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;createServletApplicationContext&lt;/code&gt;와 &lt;code&gt;createRootApplicationContext&lt;/code&gt; 메소드 구현체를 찾기 위해 &lt;code&gt;AbstractDispatcherServletInitializer&lt;/code&gt; 클래스의 하위 클래스인 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/support/AbstractAnnotationConfigDispatcherServletInitializer.html&quot;&gt;AbstractAnnotationConfigDispatcherServletInitializer&lt;/a&gt;를 봐야 한다. &lt;code&gt;WebApplicationInitializer&lt;/code&gt; 인터페이스의 마지막 구현체다.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public abstract class AbstractAnnotationConfigDispatcherServletInitializer
        extends AbstractDispatcherServletInitializer {

    @Override
    @Nullable
    protected WebApplicationContext createRootApplicationContext() {
        Class&amp;lt;?&amp;gt;[] configClasses = getRootConfigClasses();
        if (!ObjectUtils.isEmpty(configClasses)) {
            AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
            context.register(configClasses);
            return context;
        }
        else {
            return null;
        }
    }

    @Override
    protected WebApplicationContext createServletApplicationContext() {
        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
        Class&amp;lt;?&amp;gt;[] configClasses = getServletConfigClasses();
        if (!ObjectUtils.isEmpty(configClasses)) {
            context.register(configClasses);
        }
        return context;
    }

    @Nullable
    protected abstract Class&amp;lt;?&amp;gt;[] getRootConfigClasses();

    @Nullable
    protected abstract Class&amp;lt;?&amp;gt;[] getServletConfigClasses();

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;AbstractAnnotationConfigDispatcherServletInitializer&lt;/code&gt; 클래스에서 &lt;code&gt;createServletApplicationContext&lt;/code&gt;와 &lt;code&gt;createRootApplicationContext&lt;/code&gt; 메소드를 구현하고 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;createServletApplicationContext&lt;/code&gt;와 &lt;code&gt;createRootApplicationContext&lt;/code&gt; 메소드 모두 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/context/support/AnnotationConfigWebApplicationContext.html&quot;&gt;AnnotationConfigWebApplicationContext&lt;/a&gt; 클래스를 생성한다.&lt;/li&gt;
&lt;li&gt;두개의 &lt;code&gt;ApplicationContext&lt;/code&gt;를 생성하는 것을 알 수 있다. 하나의 애플리케이션에 ApplicationContext를 1개 이상 생성이 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AnnotationConfigWebApplicationContext#register&lt;/code&gt; 메소드를 호출해 애플리케이션의 Bean을 초기화한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 클래스를 이해하기 위해서는 Spring의 &lt;code&gt;BeanFactory&lt;/code&gt;와 &lt;code&gt;ApplicationContext&lt;/code&gt;를 이해해야 하는데, 이 글에서는 설명하지 않고 &lt;a href=&quot;http://blog.woniper.net/338?category=699184&quot;&gt;여기&lt;/a&gt;를 참고하자.&lt;/p&gt;

&lt;h3 id=&quot;toc_9&quot;&gt;Abstract Class&lt;/h3&gt;

&lt;p&gt;지금까지 살펴본 &lt;code&gt;SpringServletContainerInitializer&lt;/code&gt; 구현체는 모두 추상 클래스다. 다시 &lt;code&gt;SpringServletContainerInitializer&lt;/code&gt;로 돌아가서 &lt;code&gt;onStartup&lt;/code&gt; 메소드를 다시 보자.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Override
    public void onStartup(@Nullable Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; webAppInitializerClasses, ServletContext servletContext)
            throws ServletException {

        List&amp;lt;WebApplicationInitializer&amp;gt; initializers = new LinkedList&amp;lt;&amp;gt;();

        if (webAppInitializerClasses != null) {
            for (Class&amp;lt;?&amp;gt; waiClass : webAppInitializerClasses) {
                if (!waiClass.isInterface() &amp;amp;&amp;amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;amp;&amp;amp;
                        WebApplicationInitializer.class.isAssignableFrom(waiClass)) {
                    try {
                        initializers.add((WebApplicationInitializer)
                                ReflectionUtils.accessibleConstructor(waiClass).newInstance());
                    }
                    catch (Throwable ex) {
                        throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex);
                    }
                }
            }
        }

        // ... 중략 ...
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;webAppInitializerClasses&lt;/code&gt;를 반복해서 &lt;code&gt;WebApplicationInitializer&lt;/code&gt;를 생성한다.&lt;/li&gt;
&lt;li&gt;그런데 &lt;code&gt;WebApplicationInitializer&lt;/code&gt;를 생성하기 위한 조건이 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if (!waiClass.isInterface() &amp;amp;&amp;amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;amp;&amp;amp; WebApplicationInitializer.class.isAssignableFrom(waiClass))&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;waiClass&lt;/code&gt;가 인터페이스가 아니고, 추상 클래스도 아닌 경우에만 &lt;code&gt;WebApplicationInitializer&lt;/code&gt;를 생성한다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;지금까지 본 하위 클래스는 모두 &lt;code&gt;추상 클래스&lt;/code&gt;다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;toc_10&quot;&gt;JavaConfig로 WEB 애플리케이션 설정&lt;/h2&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public class WebConfig extends AbstractAnnotationConfigDispatcherServletInitializer {

    @Override
    protected Class&amp;lt;?&amp;gt;[] getRootConfigClasses() {
        return new Class[] { AppConfig.class };
    }

    @Override
    protected Class&amp;lt;?&amp;gt;[] getServletConfigClasses() {
        return new Class[] { WebConfig.class };
    }

    @Override
    protected String[] getServletMappings() {
        return new String[] { &quot;/*&quot; };
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;WebConfig&lt;/code&gt; 클래스는 JavaConfig를 사용해 웹 애플리케이션을 설정한 클래스다. Spring에서 제공되는 클래스가 아닌 내가 작성한 코드다. 아마 JavaConfig를 사용해본 개발자라면 익숙한 코드일 텐데, &lt;code&gt;AbstractAnnotationConfigDispatcherServletInitializer&lt;/code&gt; 클래스를 상속하고 있다. (또는 WebApplicationInitializer 인터페이스를 구현해도 된다.)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;SpringServletContainerInitializer#onStartup&lt;/code&gt; 메소드에서 &lt;code&gt;WebApplicationInitializer&lt;/code&gt; 생성하기 위한 조건은 인터페이스가 아니고, 추상 클래스도 아니다. 일반 클래스다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WebConfig&lt;/code&gt; 클래스는 일반 클래스다.&lt;/li&gt;
&lt;li&gt;때문에 &lt;code&gt;SpringServletContainerInitializer#onStartup&lt;/code&gt; 메소드에서 생성되는 &lt;code&gt;WebApplicationInitializer&lt;/code&gt;의 대상은 &lt;code&gt;WebConfig&lt;/code&gt;이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;toc_11&quot;&gt;요약&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Spring-MVC에서 서블릿 기반의 웹 애플리케이션 설정을 담당하는 구현체는 &lt;code&gt;ServletContainerInitializer&lt;/code&gt; 인터페이스를 구현한 &lt;code&gt;SpringServletContainerInitializer&lt;/code&gt; 클래스다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SpringServletContainerInitializer#onStartup&lt;/code&gt; 메소드는 &lt;code&gt;WebApplicationInitializer&lt;/code&gt; 인터페이스를 상속한 (인터페이스, 추상 클래스가 아닌)일반 클래스를 생성한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WebApplicationInitializer&lt;/code&gt; 인터페이스의 구현체는 &lt;code&gt;AbstractContextLoaderInitializer, AbstractDispatcherServletInitializer, AbstractAnnotationConfigDispatcherServletInitializer&lt;/code&gt; 추상 클래스다.&lt;/li&gt;
&lt;li&gt;웹 애플리케이션 설정을 위해 &lt;code&gt;WebApplicationInitializer&lt;/code&gt; 인터페이스를 상속한 &lt;code&gt;JavaConfig(WebConfig)&lt;/code&gt; 클래스를 만들어야 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SpringServletContainerInitializer#onStartup&lt;/code&gt; 메소드에서 생성되는 &lt;code&gt;WebApplicationInitializer&lt;/code&gt; 인터페이스의 구현체는 우리가 만든 &lt;code&gt;WebConfig&lt;/code&gt; 구현체로 생성된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;toc_12&quot;&gt;tips&lt;/h2&gt;

&lt;h3 id=&quot;toc_13&quot;&gt;오픈소스. 어떻게 읽을까?&lt;/h3&gt;

&lt;p&gt;앞서 &lt;code&gt;시작점&lt;/code&gt;부터 읽는 게 좀 더 쉽게 읽는 방법이라고 했다. 더 쉽게 읽기 위한 또 다른 방법이 있다. 바로 궁금한 것부터 찾아보는 것이다. 예를 들면, &lt;code&gt;Spring-MVC는 @Controller 애노테이션이 설정된 클래스를 어떻게 찾아서 실행할까?&lt;/code&gt;로 시작하는 것이다. 오랜시간 유지돼 온 오픈소스는 그만큼 코드 양도 방대하기 때문에 코드를 보는 자신만의 기준 없이 무턱대고 읽기 시작하면 구조를 파악하기 힘들다.&lt;/p&gt;&lt;p&gt;이건 내가 제시하는 방법이고, 읽다 보면 자신만의 읽는 방법과 요령이 생긴다.&lt;/p&gt;

&lt;h3 id=&quot;toc_14&quot;&gt;intellij Diagram&lt;/h3&gt;

&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/993E04435C1F23DB17&quot; filemime=&quot;image/jpeg&quot; filename=&quot;ServletContainerInitializer-Diagram.png&quot; height=&quot;392&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;intellij는 module, class 단위로 Diagram 기능을 이용해 의존성을 한눈에 볼 수 있다. 위 다이어그램은 앞서 살펴본 인터페이스와 구현체들의 의존 관계다.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/997F584A5C1F240312&quot; filemime=&quot;image/jpeg&quot; filename=&quot;diagram1.png&quot; height=&quot;420&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;Diagram을 보고 싶은 클래스에서 오른쪽 마우스 클릭 &amp;gt; Diagram 선택&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;text-align: center;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99C9434A5C1F24030E&quot; filemime=&quot;image/jpeg&quot; filename=&quot;diagram2.png&quot; height=&quot;283&quot; style=&quot;text-align: center;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그럼 이렇게 클래스 Diagram이 그려진다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;text-align: center;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/997FFA4A5C1F240411&quot; filemime=&quot;image/jpeg&quot; filename=&quot;diagram3.png&quot; height=&quot;502&quot; style=&quot;text-align: center;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;WebApplicationInitializer와 AbstractContextLoaderInitializer의 의존 관계를 보기 위해 클래스를 추가한다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;오른쪽 마우스 클릭 &amp;gt; Add Class to Diagram...&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;text-align: center;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/993B0C4A5C1F240514&quot; filemime=&quot;image/jpeg&quot; filename=&quot;diagram4.png&quot; height=&quot;450&quot; style=&quot;text-align: center;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;끝!&lt;/p&gt;

&lt;h2 id=&quot;toc_15&quot;&gt;마무리&lt;/h2&gt;

&lt;p&gt;인터페이스부터 인터페이스의 구현체를 찾아가며 구조만 살펴봤다. 몇 가지 선수 지식이 필요하고, 약간은 추상적인 설명이 많았다. 아직까진 모든 코드를 이해하지 못하더라도 대략적인 구조만 이해해도 좋다. 다음 글에서는 &lt;code&gt;AbstractContextLoaderInitializer, AbstractDispatcherServletInitializer, AbstractAnnotationConfigDispatcherServletInitializer&lt;/code&gt;를 하나씩 자세히 읽어볼 예정이다.&lt;/p&gt;&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/366&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>Spring</category>
<category>spring-mvc</category>
<category>spring-webmvc</category>
<author>woniper</author>
<guid>https://blog.woniper.net/366</guid>
<comments>https://blog.woniper.net/366#entry366comment</comments>
<pubDate>Sun, 23 Dec 2018 15:00:46 +0900</pubDate>
</item>
<item>
<title>Spring-MVC 읽기 #2. 빌드</title>
<link>https://blog.woniper.net/365</link>
<description>&lt;p&gt;Spring-MVC는 &lt;a href=&quot;https://spring.io/projects/spring-framework&quot;&gt;Spring Framework&lt;/a&gt;의 feature 중 하나다. 때문에 코드를 보기 위해서는 &lt;a href=&quot;https://github.com/spring-projects/spring-framework&quot;&gt;Sprig Framework github 코드&lt;/a&gt;를 clone 해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;clone &amp;amp; build&lt;/h2&gt;

&lt;h3 id=&quot;toc_1&quot;&gt;github repository clone&lt;/h3&gt;

&lt;p&gt;참고 : &lt;a href=&quot;https://github.com/spring-projects/spring-framework/wiki/Build-from-Source&quot;&gt;Build from Source&lt;/a&gt;&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;$ git clone https://github.com/spring-projects/spring-framework.git&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;toc_2&quot;&gt;build&lt;/h3&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;$ cd spring-framework
$ ./gradlew build&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;프로젝트 크기가 커서 빌드가 오래 걸린다.&lt;/p&gt;

&lt;h3 id=&quot;toc_3&quot;&gt;test spring-webmvc module&lt;/h3&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;$ ./gradlew -a :spring-webmvc:test&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;코드를 clone 받아 빌드 후 spring-webmvc 모듈을 test 한다. 위 과정이 문제없다면, 이제 코드를 살펴볼 준비가 된 것이다.&lt;/p&gt;

&lt;h2 id=&quot;toc_4&quot;&gt;import into intellij&lt;/h2&gt;

&lt;p&gt;참고 : &lt;a href=&quot;https://github.com/spring-projects/spring-framework/blob/master/import-into-idea.md&quot;&gt;import-into-idea&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;toc_5&quot;&gt;pre compile&lt;/h3&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;$ ./gradlew :spring-oxm:compileTestJava&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;intellij에 import 전에 spring-oxm module을 먼저 컴파일한다.&lt;/p&gt;

&lt;h3 id=&quot;toc_6&quot;&gt;import&lt;/h3&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9968D0435C197D7B1E&quot; filemime=&quot;image/jpeg&quot; filename=&quot;import1.png&quot; height=&quot;146&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;text-align: start;&quot;&gt;File &amp;gt; New &amp;gt; Project from Existing Sources &amp;gt; spring-framework/build.gradle 선택&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;text-align: center;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/996798435C197D7C1F&quot; filemime=&quot;image/jpeg&quot; filename=&quot;import2.png&quot; height=&quot;429&quot; style=&quot;text-align: center;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;spring-framework/build.gradle 선택&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;text-align: center;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/996AC1435C197D7D1F&quot; filemime=&quot;image/jpeg&quot; filename=&quot;import3.png&quot; height=&quot;592&quot; style=&quot;text-align: center;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Use auto-import 체크 후 OK&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:312px;text-align: center; width: 312px; height: 583px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/996A09435C197D7E1F&quot; filemime=&quot;image/jpeg&quot; filename=&quot;import4.png&quot; height=&quot;583&quot; style=&quot;text-align: center; width: 312px; height: 583px;&quot; width=&quot;312&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;spring-framework에 포함된 여러 module이 보인다. 그중 spring-webmvc가 바로 Spring-MVC module이다.&lt;/p&gt;

&lt;h2 id=&quot;toc_7&quot;&gt;spring-web, spring-webmvc&lt;/h2&gt;

&lt;p&gt;우리가 이제부터 살펴봐야 할 코드는 spring-mvc와 spring-webmvc다. spring-webmvc/build.gradle 에 dependencies를 보면 여러 module에 의존한다.
&lt;br /&gt;&lt;/p&gt;&lt;p&gt;spring-webmvc는 spring-web module을 기반으로 spring으로 web 개발에 필요한 여러 가지 기능을 제공한다. 대표적으로 우리가 사용해봤거나, 알고 있는 또는 앞으로 알아갈 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/ViewResolver.html&quot;&gt;ViewResolver&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/ThemeResolver.html&quot;&gt;ThemeResolver&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/resource/ResourceResolver.html&quot;&gt;ResourceResolver&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/LocaleResolver.html&quot;&gt;LocaleResolver&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/HandlerMapping.html&quot;&gt;HandlerMapping&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/HandlerAdapter.html&quot;&gt;HandlerAdapter&lt;/a&gt; 등이 spring-webmvc에 해당된다.
&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그리고 spring-webmvc의 핵심이라고 볼 수 있는 FrontController 역할을 하는 &lt;a href=&quot;https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-servlet&quot;&gt;DispatcherServlet&lt;/a&gt;이 있다.&lt;/p&gt;&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/365&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>Spring</category>
<category>spring-mvc</category>
<category>spring-webmvc</category>
<author>woniper</author>
<guid>https://blog.woniper.net/365</guid>
<comments>https://blog.woniper.net/365#entry365comment</comments>
<pubDate>Wed, 19 Dec 2018 08:09:12 +0900</pubDate>
</item>
<item>
<title>Spring-MVC 읽기 #1. 나는 왜 오픈소스를 읽을까?</title>
<link>https://blog.woniper.net/364</link>
<description>&lt;h3 id=&quot;toc_0&quot;&gt;코드! 쓰기 말고 읽기.&lt;/h3&gt;

&lt;p&gt;오픈소스에 &lt;code&gt;기여&lt;/code&gt;는 못하더라도 &lt;code&gt;읽기&lt;/code&gt;는 가능하다. 예전에 어떤 컨퍼런스에서 &lt;a href=&quot;https://www.slideshare.net/realbeast/ss-29017589/34&quot;&gt;진성주 님&lt;/a&gt;이 이런 말을 했던 게 기억난다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;시인이 되고 싶은 사람은 다른 사람들의 시를,&lt;/p&gt;

&lt;p&gt;화가가 되고 싶은 사람은 다른 사람의 그림을,&lt;/p&gt;

&lt;p&gt;가수가 되고 싶은 사람은 다른 사람의 노래를&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;개발자인 우리도 다른 사람의 코드를 읽고 배울 필요가 있다. 어쩌면 우리는 일을 하다 보면 코드를 작성하는 시간보다 남의 코드를 읽는 시간이 더 많을지도 모른다.&lt;/p&gt;

&lt;p&gt;어느 날 SLiPP 스터디에서 &lt;a href=&quot;https://www.slipp.net/wiki/display/SLS/Spring+Core&quot;&gt;Spring Core&lt;/a&gt; 스터디를 하게 됐다. 이 스터디는 이론적으로만 알고 있던 Spring Context의 코드를 읽기 위한 스터디였다. 결과론적인 이야기일 수 있지만, 나는 이 스터디를 통해 개발자로서 많은 부분이 변했다고 생각한다. &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;첫 번째&lt;/strong&gt;는 코드 읽는 게 두렵지 않다. 처음 Spring 코드를 읽기 위해서 몇 번의 시도를 했지만 모두 실패했다. 너무 어려웠기 때문이다. 처음 코드를 읽을 때 수많은 interface와 구현체들이 나를 맞이했다. 구조를 파악하고 이해하기 어려웠다. 하지만, 그 벽을 넘고 나니 새로운 코드 읽는 게 두렵지 않았다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;두 번째&lt;/strong&gt;는 코드 읽는 속도가 빨라진다. 앞서 말했듯이 우리는 일하면서 코드 읽는 일이 많다. 새로운 코드를 이해하고 읽는 게 두렵지 않고 빨리 읽을 수 있게 된 거 같다. 자신감을 얻게 되는 건 덤.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;세 번째&lt;/strong&gt;는 좋은 사례를 찾게 된다. 나는 OOP 설계나 디자인 패턴은 책으로 이해하고 응용하기엔 많은 부족함이 있다고 생각한다. 그래서 오픈소스를 통해 OOP 설계나 디자인 패턴이 어떻게 적용되었는지 좋은 사례를 찾고 이해할 수 있었다. &lt;/p&gt;

&lt;p&gt;하지만 첫 번째 변화에서 말했듯이 오픈소스를 분석하는 벽을 넘기란 어렵다. 오랜 시간 유지보수 되고 발전해온 오픈소스를 읽는 건 쉽지 않다. 그래서 이 글은 &lt;a href=&quot;https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html&quot;&gt;Spring-MVC&lt;/a&gt;의 코드를 읽고 정리하며 어떻게 읽고, 어떻게 배울 수 있는지 정리하는 글이 될 거 같다. 잘할 수 있을지는 모르겠다. &lt;/p&gt;

&lt;p&gt;앞으로 쓰게될 글을 이해하기 위해서는 아래와 같은 선수 지식이 필요하다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Java 문법을 이해하는데 문제가 없다.&lt;/li&gt;
&lt;li&gt;HTTP를 이해하고 있다.&lt;/li&gt;
&lt;li&gt;Spring MVC를 사용해 웹개발을 해봤다.&lt;/li&gt;
&lt;li&gt;Tomcat을 사용해봤다. (아니여도 큰 문제는 없다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_1&quot;&gt;오픈소스 분석에 대한 참고 글&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.facebook.com/218158748272233/posts/%EC%86%8C%EC%8A%A4%EC%BD%94%EB%93%9C-%EB%B6%84%EC%84%9D%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A1%B0%EC%96%B8-%EC%9E%85%EB%8B%88%EB%8B%A4-%EA%B7%9C%EB%AA%A8%EC%9E%88%EB%8A%94-%EC%86%8C%EC%8A%A4%EC%9D%98-%EB%B6%84%EC%84%9D%EC%9D%84-%EC%83%88%ED%95%B4%EC%9D%98-%EB%AA%A9%ED%91%9C%EB%A1%9C-%EC%9E%A1%EA%B3%A0-%EC%9E%88%EB%8A%94-%EC%95%BC%EC%8B%AC%EA%B0%80-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EC%9D%BC%EB%8F%85%EC%9D%84-%EA%B6%8C%ED%95%A9%EB%8B%88%EB%8B%A4/758498224238280/&quot;&gt;곽중선님의 오픈소스 분석 가이드(페이스북)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.popit.kr/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EC%BD%94%EB%93%9C-%EB%B6%84%EC%84%9D-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%98%EB%82%98/&quot;&gt;오픈소스: 코드 분석 어떻게 하나?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/kthcorp/h3-2012-15042338&quot;&gt;오픈소스로 개발실력 쌓기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://okky.kr/article/408595&quot;&gt;작은 오픈소스 프로그램을 분석해서 실력을 쌓아 나간 사례&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/364&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<author>woniper</author>
<guid>https://blog.woniper.net/364</guid>
<comments>https://blog.woniper.net/364#entry364comment</comments>
<pubDate>Tue, 18 Dec 2018 21:22:15 +0900</pubDate>
</item>
<item>
<title>실행 중인 Spring Boot pid 파일 생성</title>
<link>https://blog.woniper.net/363</link>
<description>&lt;p&gt;토이 프로젝트를 서버에 배포한 후 기존에 실행되던 spring boot 애플리케이션을 죽이고(kill) 재실행하기 위해 pid를 이용했다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;애플리케이션 배포&lt;/li&gt;
&lt;li&gt;기존 실행되던 애플리케이션 종료&lt;/li&gt;
&lt;li&gt;배포된 애플리케이션 실행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;무식한 방법으로 기존에 실행하던 애플리케이션을 죽이기로 했다. kill 하기 위해서 pid(process id)가 필요했다. 그래서 Spring boot 애플리케이션 실행 시 실행된 애플리케이션의 pid를 생성하는 방법을 찾아봤다. 쉽다.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public static void main(String[] args) {
    SpringApplicationBuilder builder = new SpringApplicationBuilder(BookUPApplication.class);
    builder.build().addListeners(new ApplicationPidFileWriter(&amp;quot;./bin/shutdown.pid&amp;quot;));
    builder.run();
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;아마 spring boot를 사용하면 대부분 main method를 통해서 embedded WAS를 실행할 것이다. 이때 &lt;code&gt;ApplicationPidFileWriter&lt;/code&gt; 클래스를 사용해 pid를 생성해주면 된다. pid가 기록된 파일 경로만 지정해주면 끝.&lt;/p&gt;
&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/363&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>ApplicationPidFileWriter</category>
<category>spring boot</category>
<category>spring pid</category>
<author>woniper</author>
<guid>https://blog.woniper.net/363</guid>
<comments>https://blog.woniper.net/363#entry363comment</comments>
<pubDate>Sat, 22 Sep 2018 10:22:46 +0900</pubDate>
</item>
<item>
<title>java inner class</title>
<link>https://blog.woniper.net/362</link>
<description>&lt;p&gt;개발 하다 보면 가끔 inner class를 사용하는 경우가 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;outer class에서만 사용하는 경우&lt;/li&gt;
&lt;li&gt;outer class에만 멤버 변수로 선언되어 있고, 외부에서 생성할 수 있어야 하는 경우&lt;/li&gt;
&lt;li&gt;책임을 분리하고 싶지만, 외부로 노출하지(사용하지) 못해야 하는 경우 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;나는 대략 위와 같은 기준으로 inner class를 만들어 사용한다. inner class는 &lt;code&gt;non static inner class&lt;/code&gt;와 &lt;code&gt;static inner class&lt;/code&gt;로 나뉜다. 그 외 메소드에서 선언되는 &lt;code&gt;local class(지역 클래스)&lt;/code&gt;와 &lt;code&gt;anonymous inner class(익명 클래스)&lt;/code&gt;도 있다. 이 글은 non static inner class와 static inner class만 설명한다.&lt;/p&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;non static inner class&lt;/h2&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;class Outer {

    private String name;

    Outer(String name) {
        this.name = name;
    }

    void print() {
        new NonStaticInner(this.name).print();
    }

    String getName() {
        return name;
    }

    class NonStaticInner {
        private String name;

        NonStaticInner(String name) {
            this.name = name;
        }

        void print() {
            System.out.println(&amp;quot;outer1 : &amp;quot; + Outer.this.name);
            System.out.println(&amp;quot;outer2 : &amp;quot; + Outer.this.getName());
            System.out.println(&amp;quot;NonStaticInner : &amp;quot; + this.name);
        }
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 Outer class 내부에 선언되고, static keyword가 없는 class를 non static inner class라 한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Outer class 는 NonStaticInner class의 &lt;code&gt;private 필드&lt;/code&gt;에 접근할 수 있다.&lt;/li&gt;
&lt;li&gt;NonStaticInner class는 &lt;code&gt;Outer.this&lt;/code&gt;를 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_1&quot;&gt;테스트 코드&lt;/h3&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Test
public void print() {
    Outer outer = new Outer(&amp;quot;test name&amp;quot;);
    Outer.NonStaticInner nonStaticInner = outer.new NonStaticInner(outer.getName());
    Outer.NonStaticInner nonStaticInner1 = new Outer.NonStaticInner(outer.getName()); // 컴파일 에러
    nonStaticInner.print();
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Outer class를 생성하지 않으면, non static inner class는 생성할 수 없다. &lt;code&gt;outer.new NonStaticInner();&lt;/code&gt;와 같이 생성한다.&lt;/p&gt;

&lt;p&gt;non static inner class는 Outer class에 종속적이라는 의미로 볼 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;static inner class&lt;/h2&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;class Outer {

    private String name;

    Outer(String name) {
        this.name = name;
    }

    void print() {
        new StaticInner(this.name).print();
    }

    String getName() {
        return name;
    }

    static class StaticInner {
        private String name;

        StaticInner(String name) {
            this.name = name;
        }

        void print() {
            System.out.println(&amp;quot;outer&amp;quot; + Outer.this.name); // 컴파일 에러
            System.out.println(&amp;quot;StaticInner : &amp;quot; + this.name);
        }
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 static keyword가 붙은 class를 static inner class라 한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Outer class 는 StaticInner class의 &lt;code&gt;private 필드&lt;/code&gt;에 접근할 수 있다.&lt;/li&gt;
&lt;li&gt;StaticInner class는 &lt;code&gt;Outer.this&lt;/code&gt;를 사용할 수 없다. (컴파일 에러)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_3&quot;&gt;테스트 코드&lt;/h3&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Test
public void print() {
    Outer outer = new Outer(&amp;quot;test name&amp;quot;);
    Outer.StaticInner staticInner = new Outer.StaticInner(outer.getName());
    Outer.StaticInner staticInner1 = outer.new StaticInner(outer.getName()); // 컴파일 에러
    staticInner.print();
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;non static inner class와 다르게 &lt;code&gt;outer.new&lt;/code&gt; 키워드는 사용하지 못한다. Outer class를 생성하듯, StaticInner class도 생성이 가능하다. static inner class는 Outer class에 종속적이지 않다는 의미로 볼 수 있다. &lt;/p&gt;

&lt;h3 id=&quot;toc_4&quot;&gt;실제 사용 예시&lt;/h3&gt;

&lt;p&gt;java collection에 &lt;code&gt;java.util.LinkedList&lt;/code&gt; class 내부에는 &lt;code&gt;Node&lt;/code&gt;라는 static class가 존재한다.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;private static class Node&amp;lt;E&amp;gt; {
    E item;
    Node&amp;lt;E&amp;gt; next;
    Node&amp;lt;E&amp;gt; prev;

    Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;LinkedList를 이해한다면, &lt;code&gt;Node&lt;/code&gt; class가 어떤 역할인지 감이 올 것이다. 설명은 생략한다!&lt;/p&gt;
&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/362&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>java inner class</category>
<category>non static inner class</category>
<category>static inner class</category>
<author>woniper</author>
<guid>https://blog.woniper.net/362</guid>
<comments>https://blog.woniper.net/362#entry362comment</comments>
<pubDate>Tue, 18 Sep 2018 08:13:01 +0900</pubDate>
</item>
<item>
<title>CompletableFuture 비동기 처리로 성능 개선하기</title>
<link>https://blog.woniper.net/361</link>
<description>&lt;p&gt;이 글은 CompletableFuture API를 설명하는 글은 아니다. CompletableFuture로 어떻게 성능을 개선했는지에 대한 경험 글이다.&lt;/p&gt;

&lt;p&gt;개인 프로젝트로 &lt;a href=&quot;http://bookup.woniper.net&quot;&gt;bookup&lt;/a&gt; 이란 웹 애플리케이션을 개발하고 있다.
원하는 도서가 오프라인 서점에 재고가 있는지 검색하는 서비스다. 오프라인 서점마다 Open API가 없어, html 크롤링으로 개발했다. 그런데 개발하며 문제가 생겼다. 바로 오프라인 서점의 수가 많아질 수록 성능이 느려진다는 것이다. 재고 조회 순서는 아래와 같다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ISBN(도서 고유값) 값을 구하기 위해 네이버 Open API를 통해 ISBN 값을 얻는다. (API 요청)&lt;/li&gt;
&lt;li&gt;ISBN으로 오프라인 서점에 해당 도서의 재고를 &lt;code&gt;순서대로&lt;/code&gt; 크롤링한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;왜 성능이 느릴까? 이유는 여러 http 요청을 동기(Synchronous)로 처리 하기 때문이다. 지원되는 오프라인 서점은 총 3개 (교보문고, 알라딘, 반디앤루니스)다. ISBN으로 각 서점에 요청을 할 때 하나씩 요청한다.&lt;/p&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;동기 처리&lt;/h2&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public Book getBook(String isbn) {
    Book aladinBook = aladinBookCrawler.findByIsbn(isbn);
    List&amp;lt;BookStore&amp;gt; bookStores = mapToBookStore(isbn, kyoboBookRestTemplate.findByIsbn(isbn));
    aladinBook.merge(bookStores);

    return aladinBook;
}

private List&amp;lt;BookStore&amp;gt; mapToBookStore(String isbn, Optional&amp;lt;KyoboBookStore&amp;gt; kyoboBookStore) {
    if (StringUtils.isEmpty(isbn) || !kyoboBookStore.isPresent())
        return null;

    return kyoboBookStore.get().getItems().stream()
            .filter(x -&amp;gt; x.getAmount() &amp;gt; 0)
            .map(x -&amp;gt; new BookStore(x.getStoreName(), kyoboProperties.createUrl(x.getStoreId(), isbn)))
            .collect(Collectors.toList());

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;동기로 처리하면 3개의 서점을 순서대로 크롤링한다.
예를 들어 각 서점 조회 응답(response) 시간이 1초라면, 총 3초가 걸린다. API가 3초면 꽤 긴 시간이다.&lt;/p&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;비동기 처리&lt;/h2&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public Book getBook(String isbn) {
    CompletableFuture&amp;lt;Book&amp;gt; bookFuture =
            CompletableFuture.supplyAsync(() -&amp;gt; mapBook(naverBookRestTemplate.findByIsbn(isbn)))
            .thenApplyAsync(x -&amp;gt; x.merge(getBookStores(isbn)));

    return FutureUtils.getFutureItem(bookFuture)
            .orElseThrow(() -&amp;gt; new NotFoundBookException(isbn));
}

private List&amp;lt;BookStore&amp;gt; getBookStores(String isbn) {
    List&amp;lt;BookStore&amp;gt; bookStores = new ArrayList&amp;lt;&amp;gt;();

    bookStoreFinders.stream()
            .map(x -&amp;gt; CompletableFuture.supplyAsync(() -&amp;gt; x.findByIsbn(isbn)))
            .collect(Collectors.toList())
            .forEach(x -&amp;gt; bookStores.addAll(FutureUtils.getFutureItem(x).orElse(Collections.emptyList())));

    return bookStores;

}

private Book mapBook(NaverBook.Item item) {
    return new Book(item.getTitle(), item.getDescription());
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;네이버 API로 ISBN을 얻은 후 해당 도서를 보유한 오프라인 서점을 찾기 위해 &lt;code&gt;CompletableFuture&lt;/code&gt;로 서점 조회를 비동기로 처리한다.
예를 들어 각 서점 조회 응답(response) 시간이 1초라면, 동기는 3초가 걸렸지만, 비동기는 약 1초가 걸린다. 1초도 꽤 긴시간이지만, 3초보단 훨씬 좋은 응답 시간이다. 하지만 마음에 드는 성능은 아니다. 크롤링으로 처리하다보니 성능상 많은 제약이 있다.&lt;/p&gt;

&lt;p&gt;해당 소스는 &lt;a href=&quot;https://github.com/woniper/bookup/commit/9b85967f3052e4ea31a0680a34e580f1d17b3390&quot;&gt;여기서&lt;/a&gt; 확인&lt;/p&gt;&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/361&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>CompletableFuture</category>
<author>woniper</author>
<guid>https://blog.woniper.net/361</guid>
<comments>https://blog.woniper.net/361#entry361comment</comments>
<pubDate>Sat, 08 Sep 2018 15:20:33 +0900</pubDate>
</item>
<item>
<title>intellij SQL keyword 자동 uppercase</title>
<link>https://blog.woniper.net/360</link>
<description>&lt;p&gt;나는 최대한 intellij를 이용해 모든 개발을 끝내려고 노력한다.
개발을 하다 보면 실제 native query를 실행해 해야&amp;nbsp;경우도 있고, terminal을 사용해야&amp;nbsp;하는 경우, http request 요청 등을 하기 위해&amp;nbsp;intellij 외에 필요한 tool이 필요하다, intellij는 이런 기능을&amp;nbsp;대부분 지원한다. 특히 자주 사용하는 기능은&amp;nbsp;Database이다.&lt;/p&gt;

&lt;p&gt;그런데 언제부턴가 버전업을 한 후에 SQL keyword 가 대문자로 자동완성 되던 것이 소문자로만 나왔다. 큰 문제는 없지만, 그동안 사용하던 대문자로 나오는 게 좋았다.&lt;/p&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;변경&lt;/h2&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;Preferences &amp;gt; Editor &amp;gt; Code Style &amp;gt; SQL &amp;gt; General &amp;gt; Word Case &amp;gt; keywords &amp;gt; To upper 로 변경&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;끝.&lt;/p&gt;&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/360&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>개발환경</category>
<category>IntelliJ</category>
<author>woniper</author>
<guid>https://blog.woniper.net/360</guid>
<comments>https://blog.woniper.net/360#entry360comment</comments>
<pubDate>Sat, 26 May 2018 13:19:16 +0900</pubDate>
</item>
<item>
<title>Spring Data JPA 같은 이름, 다른 type인 2개의 @Entity인 경우 주의 사항</title>
<link>https://blog.woniper.net/359</link>
<description>&lt;h2 id=&quot;toc_0&quot;&gt;가정&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;하나의 project에 의미가 다른 2개의 &lt;code&gt;Event&lt;/code&gt;라는 &lt;code&gt;@Entity&lt;/code&gt;가 필요하다.&lt;/li&gt;
&lt;li&gt;당연히 package 경로는 다르다.

&lt;ul&gt;
&lt;li&gt;하나는 &lt;code&gt;net.woniper.data.jpa.event1.Event&lt;/code&gt; (이하 event1)&lt;/li&gt;
&lt;li&gt;하나는 &lt;code&gt;net.woniper.data.jpa.event2.Event&lt;/code&gt; (이하 event2)&lt;/li&gt;
&lt;li&gt;package만 다르며, 클래스 명은 같다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;각각의 Event는 Repository가 존재한다.

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;net.woniper.data.jpa.event1.EventRepository&lt;/code&gt; (이하 eventRepository1)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;net.woniper.data.jpa.event2.EventRepository&lt;/code&gt; (이하 eventRepository2)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;예제 코드&lt;/h2&gt;

&lt;h4 id=&quot;toc_2&quot;&gt;net.woniper.data.jpa.event1.Event&lt;/h4&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;package net.woniper.data.jpa.event1;

@Entity
@Table(name = &quot;event1&quot;)
@NoArgsConstructor
@ToString
public class Event {

    @Id
    @GeneratedValue
    private Long id;

    private String name;

    public Event(String name) {
        this.name = name;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;toc_3&quot;&gt;net.woniper.data.jpa.event1.EventRepository&lt;/h4&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;package net.woniper.data.jpa.event1;

public interface EventRepository extends CrudRepository&amp;lt;Event, Long&amp;gt; {

    List&amp;lt;Event&amp;gt; findByOrderByNameDesc();
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;toc_4&quot;&gt;net.woniper.data.jpa.event2.Event&lt;/h4&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;package net.woniper.data.jpa.event2;

@Entity
@Table(name = &quot;event2&quot;)
@NoArgsConstructor
@ToString
public class Event {

    @Id
    @GeneratedValue
    private Long id;

    private String name;

    public Event(String name) {
        this.name = name;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;toc_5&quot;&gt;net.woniper.data.jpa.event2.EventRepository&lt;/h4&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;package net.woniper.data.jpa.event2;

public interface EventRepository extends CrudRepository&amp;lt;Event, Long&amp;gt; {}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;위 예제는 package 경로만 다를 뿐 eventRepository1에 &lt;code&gt;findByOrderByNameDesc&lt;/code&gt; 메소드를 제외하고 클래스명, 코드 모두 같다.&lt;/p&gt;

&lt;h2 id=&quot;toc_6&quot;&gt;문제1&lt;/h2&gt;

&lt;p&gt;예제를 작성한 후 먼저 application을 실행하면 처음 맞이하는 문제가 있다.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'net.woniper.data.jpa.event1.EventRepository' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;EventRepository&lt;/code&gt;는 &lt;code&gt;Bean&lt;/code&gt;으로 등록되는 시점에 bean name을 EventRepository의 camel case인 &lt;code&gt;eventRepository&lt;/code&gt;로 bean name이 등록된다. 그런데 EventRepository 라는 이름의 Bean 대상이 2개이기 때문에 충돌이 난다.&lt;/p&gt;

&lt;h4 id=&quot;toc_7&quot;&gt;해결 방법&lt;/h4&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;package net.woniper.data.jpa.event2;

@Repository(&quot;event2Repository&quot;)
public interface EventRepository extends CrudRepository&amp;lt;Event, Long&amp;gt; {

    List&amp;lt;Event&amp;gt; findByOrderByNameDesc();
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;eventRepository2에 bean name을 &lt;code&gt;event2Repository&lt;/code&gt;로 설정했다. 문제 해결!&lt;/p&gt;

&lt;h2 id=&quot;toc_8&quot;&gt;문제2&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;net.woniper.data.jpa.event1.EventRepository.findByOrderByNameDesc&lt;/code&gt; 메소드 호출 후 실행되는 쿼리를 보자.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;select event0_.id as id1_1_, event0_.name as name2_1_ from event2 event0_ order by event0_.name desc&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;JPA에 의해 생성/실행된 쿼리기 때문에 alias가 조금 보기 힘들지만, 잘 보면 조회한 테이블은 &lt;code&gt;event1&lt;/code&gt;인데, 실행된 쿼리의 테이블이 &lt;code&gt;event2&lt;/code&gt; 테이블이다. 어떻게 된걸까?&lt;/p&gt;

&lt;h4 id=&quot;toc_9&quot;&gt;해결 방법&lt;/h4&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Entity(name = &quot;event1&quot;)
@Table(name = &quot;event1&quot;)
public class Event {}

@Entity(name = &quot;event2&quot;)
@Table(name = &quot;event2&quot;)
public class Event {}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;@Entity의 name 속성을 정의하자. @Entity#name 속성은 default로 클래스 명으로 설정된다. 패키지 명까지 포함되는 게 아니라 클래스 명으로만 name 속성이 기본 정의되기 때문에 문제가 된다. 왜 문제가 되는걸까?&lt;/p&gt;

&lt;h4 id=&quot;toc_10&quot;&gt;JPA의 쿼리 생성/조회&lt;/h4&gt;

&lt;p&gt;JPA는 자동으로 쿼리를 만들어준다. 심지어 Spring Data JPA는 &lt;a href=&quot;https://docs.spring.io/spring-data/jpa/docs/2.1.0.M3/reference/html/#repositories.query-methods.details&quot;&gt;QueryMethod&lt;/a&gt;라는 기능을 사용해 메소드만으로 쿼리를 만들 수 있는데, 자동으로 쿼리를 생성할때 테이블명을 @Entity#name 속성으로 생성한다. 아래와 같이 말이다.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;SELECT * FROM {#entityName} x;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;이 내용에 대해서는 &lt;a href=&quot;https://docs.spring.io/spring-data/jpa/docs/2.1.0.M3/reference/html/#jpa.query.spel-expressions&quot;&gt;Spring Data JPA 문서&lt;/a&gt;를 참고하자.&lt;/p&gt;&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/359&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>Hibernate</category>
<category>JPA</category>
<category>ORM</category>
<category>Spring</category>
<category>Spring Data JPA</category>
<author>woniper</author>
<guid>https://blog.woniper.net/359</guid>
<comments>https://blog.woniper.net/359#entry359comment</comments>
<pubDate>Thu, 24 May 2018 12:30:00 +0900</pubDate>
</item>
<item>
<title>Spring Batch의 동작 코드 #Step 생성과 실행</title>
<link>https://blog.woniper.net/358</link>
<description>&lt;p&gt;&lt;a href=&quot;http://blog.woniper.net/357&quot;&gt;Spring Batch의 동작 코드 #Job 생성과 실행&lt;/a&gt; 글에서 Job이 어떻게 생성, 실행되는지 코드를 보며 확인했다.&lt;/p&gt;&lt;p&gt;이 글은 Job이 어떻게 Step List를 실행하는지 코드를 보며 확인해 볼 것이다.&lt;/p&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;SimpleJob.doExecute&lt;/h2&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Override
protected void doExecute(JobExecution execution) throws JobInterruptedException, JobRestartException,
StartLimitExceededException {

    StepExecution stepExecution = null;
    for (Step step : steps) {
        stepExecution = handleStep(step, execution);
        if (stepExecution.getStatus() != BatchStatus.COMPLETED) {
            //
            // Terminate the job if a step fails
            //
            break;
        }
    }

    //
    // Update the job status to be the same as the last step
    //
    if (stepExecution != null) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Upgrading JobExecution status: &quot; + stepExecution);
        }
        execution.upgradeStatus(stepExecution.getStatus());
        execution.setExitStatus(stepExecution.getExitStatus());
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;SimpleJob에 대해서는 앞글에서 간단히 설명했다. &lt;code&gt;doExecute&lt;/code&gt; 메소드를 다시 설명하는 이유는 바로 이 메소드에서 Step List를 실행하기 때문이다. 정확히는 &lt;code&gt;stepExecution = handleStep(step, execution);&lt;/code&gt; 이 코드가 Step을 실행한다.&lt;/p&gt;

&lt;h4 id=&quot;toc_1&quot;&gt;AbstractJob.handleStep&lt;/h4&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;protected final StepExecution handleStep(Step step, JobExecution execution)
        throws JobInterruptedException, JobRestartException,
        StartLimitExceededException {
    return stepHandler.handleStep(step, execution);

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;StepHandler.handleStep 메소드의 arguments로 &lt;code&gt;Step&lt;/code&gt;과 &lt;code&gt;JobExecution&lt;/code&gt; 객체를 넘긴다.&lt;/p&gt;&lt;p&gt;그런데 뭔가 익숙해 보이는 &lt;code&gt;StepExecution&lt;/code&gt; 객체가 보인다. Job을 실행하는데 필요했던 &lt;code&gt;JobExecution&lt;/code&gt; 객체와 이름이 비슷해보인다.&lt;/p&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;SimpleStepHanldler.handleStep&lt;/h2&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Override
public StepExecution handleStep(Step step, JobExecution execution) throws JobInterruptedException,
JobRestartException, StartLimitExceededException {
    if (execution.isStopping()) {
        throw new JobInterruptedException(&quot;JobExecution interrupted.&quot;);
    }

    JobInstance jobInstance = execution.getJobInstance();

    StepExecution lastStepExecution = jobRepository.getLastStepExecution(jobInstance, step.getName());
    if (stepExecutionPartOfExistingJobExecution(execution, lastStepExecution)) {
        // If the last execution of this step was in the same job, it's
        // probably intentional so we want to run it again...
        logger.info(String.format(&quot;Duplicate step [%s] detected in execution of job=[%s]. &quot;
                + &quot;If either step fails, both will be executed again on restart.&quot;, step.getName(), jobInstance
                .getJobName()));
        lastStepExecution = null;
    }
    StepExecution currentStepExecution = lastStepExecution;

    if (shouldStart(lastStepExecution, execution, step)) {

        currentStepExecution = execution.createStepExecution(step.getName());

        boolean isRestart = (lastStepExecution != null &amp;amp;&amp;amp; !lastStepExecution.getStatus().equals(
                BatchStatus.COMPLETED));

        if (isRestart) {
            currentStepExecution.setExecutionContext(lastStepExecution.getExecutionContext());

            if(lastStepExecution.getExecutionContext().containsKey(&quot;batch.executed&quot;)) {
                currentStepExecution.getExecutionContext().remove(&quot;batch.executed&quot;);
            }
        }
        else {
            currentStepExecution.setExecutionContext(new ExecutionContext(executionContext));
        }

        jobRepository.add(currentStepExecution);

        logger.info(&quot;Executing step: [&quot; + step.getName() + &quot;]&quot;);
        try {
            step.execute(currentStepExecution);
            currentStepExecution.getExecutionContext().put(&quot;batch.executed&quot;, true);
        }
        catch (JobInterruptedException e) {
            // Ensure that the job gets the message that it is stopping
            // and can pass it on to other steps that are executing
            // concurrently.
            execution.setStatus(BatchStatus.STOPPING);
            throw e;
        }

        jobRepository.updateExecutionContext(execution);

        if (currentStepExecution.getStatus() == BatchStatus.STOPPING
                || currentStepExecution.getStatus() == BatchStatus.STOPPED) {
            // Ensure that the job gets the message that it is stopping
            execution.setStatus(BatchStatus.STOPPING);
            throw new JobInterruptedException(&quot;Job interrupted by step execution&quot;);
        }

    }

    return currentStepExecution;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;이 객체를 반환하는 &lt;code&gt;handleStep&lt;/code&gt; 메소드는 &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;StepExecution 생성&lt;/li&gt;
&lt;li&gt;Step 실행 : step.execute(currentStepExecution);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Job과 마찬가지로 Step을 실행하는데 필요한 &lt;code&gt;StepExecution&lt;/code&gt; 객체를 만들고 &lt;code&gt;Step&lt;/code&gt;을 실행한다. 그럼 Step의 실행되는 코드를 확인해보자.&lt;/p&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;StepBuilderFactory&lt;/h2&gt;

&lt;p&gt;StepBuilderFactory를 이용해 Step을 생성한 코드만 다시 보자.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Autowired
private StepBuilderFactory stepBuilderFactory;
    
@Bean
public Step step() {
    return stepBuilderFactory.get(&quot;simple-step&quot;)
            .&amp;lt;String, StringWrapper&amp;gt;chunk(10)
            .reader(itemReader())
            .processor(itemProcess())
            .writer(itemWriter())
            .build();
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;toc_4&quot;&gt;StepBuilderFactory.get&lt;/h4&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public StepBuilder get(String name) {
    StepBuilder builder = new StepBuilder(name).repository(jobRepository).transactionManager(
            transactionManager);
    return builder;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;예제에서 Step을 생성하기 위해 &lt;code&gt;StepBuilderFactory&lt;/code&gt;를 사용했다. &lt;code&gt;get&lt;/code&gt; 메소드를 보면 &lt;code&gt;StepBuilder&lt;/code&gt; 객체를 생성해 반환한다.&lt;/p&gt;

&lt;h4 id=&quot;toc_5&quot;&gt;StepBuilder.chunk&lt;/h4&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public &amp;lt;I, O&amp;gt; SimpleStepBuilder&amp;lt;I, O&amp;gt; chunk(CompletionPolicy completionPolicy) {
    return new SimpleStepBuilder&amp;lt;I, O&amp;gt;(this).chunk(completionPolicy);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;chunk&lt;/code&gt; 메소드는 &lt;code&gt;SimpleStepBuilder&lt;/code&gt;를 반환한다.&lt;/p&gt;

&lt;h4 id=&quot;toc_6&quot;&gt;SimpleStepBuilder.build&lt;/h4&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public SimpleStepBuilder&amp;lt;I, O&amp;gt; reader(ItemReader&amp;lt;? extends I&amp;gt; reader) {
    this.reader = reader;
    return this;
}
    
public SimpleStepBuilder&amp;lt;I, O&amp;gt; writer(ItemWriter&amp;lt;? super O&amp;gt; writer) {
    this.writer = writer;
    return this;
}
    
public SimpleStepBuilder&amp;lt;I, O&amp;gt; processor(ItemProcessor&amp;lt;? super I, ? extends O&amp;gt; processor) {
    this.processor = processor;
    return this;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;SimpleStepBuilder&lt;/code&gt;의 &lt;code&gt;reader, processor, writer&lt;/code&gt; 메소드는 어떤 객체를 반환하는지 확인하니 &lt;code&gt;자기 자신(return this;)&lt;/code&gt;을 반환한다. &lt;code&gt;build&lt;/code&gt; 메소드를 보자.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Override
public TaskletStep build() {

    registerStepListenerAsItemListener();
    registerAsStreamsAndListeners(reader, processor, writer);
    return super.build();
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;TaskletStep&lt;/code&gt; 객체를 반환한다. 즉, &lt;code&gt;SimpleStepHandler.handleStep&lt;/code&gt;에서 실행한 &lt;code&gt;Step interface&lt;/code&gt;의 구현체는 &lt;code&gt;TaskletStep&lt;/code&gt;이다. &lt;code&gt;TaskletStep&lt;/code&gt;의 &lt;code&gt;execute&lt;/code&gt; 메소드를 보자.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9972194C5AF15F1505&quot; filemime=&quot;image/jpeg&quot; filename=&quot;step-hierarchy.png&quot; height=&quot;311&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;예제에서 만든 Step이 &lt;code&gt;TaskletStep&lt;/code&gt;을 반환하는 것 뿐이지, Step interface를 구현한 여러 종류에 구현체 들이 존재한다. 이건 나중에 나중에 알아보도록...&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;toc_7&quot;&gt;TaskletStep.execute&lt;/h2&gt;

&lt;p&gt;예상했겠지만, TaskletStep은 &lt;code&gt;AbstractStep&lt;/code&gt;을 상속받고 있다. 이 구조 또한 Job과 거의 비슷하다.&lt;/p&gt;

&lt;h4 id=&quot;toc_8&quot;&gt;AbstractStep.execute&lt;/h4&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Override
public final void execute(StepExecution stepExecution) throws JobInterruptedException,
UnexpectedJobExecutionException {

    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Executing: id=&quot; + stepExecution.getId());
    }
    stepExecution.setStartTime(new Date());
    stepExecution.setStatus(BatchStatus.STARTED);
    getJobRepository().update(stepExecution);

    // Start with a default value that will be trumped by anything
    ExitStatus exitStatus = ExitStatus.EXECUTING;

    doExecutionRegistration(stepExecution);

    try {
        getCompositeListener().beforeStep(stepExecution);
        open(stepExecution.getExecutionContext());

        try {
            doExecute(stepExecution);
        }
        catch (RepeatException e) {
            throw e.getCause();
        }
        exitStatus = ExitStatus.COMPLETED.and(stepExecution.getExitStatus());

        // Check if someone is trying to stop us
        if (stepExecution.isTerminateOnly()) {
            throw new JobInterruptedException(&quot;JobExecution interrupted.&quot;);
        }

        // Need to upgrade here not set, in case the execution was stopped
        stepExecution.upgradeStatus(BatchStatus.COMPLETED);
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Step execution success: id=&quot; + stepExecution.getId());
        }
    }
    catch (Throwable e) {
        stepExecution.upgradeStatus(determineBatchStatus(e));
        exitStatus = exitStatus.and(getDefaultExitStatusForFailure(e));
        stepExecution.addFailureException(e);
        if (stepExecution.getStatus() == BatchStatus.STOPPED) {
            logger.info(String.format(&quot;Encountered interruption executing step %s in job %s : %s&quot;, name, stepExecution.getJobExecution().getJobInstance().getJobName(), e.getMessage()));
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Full exception&quot;, e);
            }
        }
        else {
            logger.error(String.format(&quot;Encountered an error executing step %s in job %s&quot;, name, stepExecution.getJobExecution().getJobInstance().getJobName()), e);
        }
    }
    finally {

        try {
            // Update the step execution to the latest known value so the
            // listeners can act on it
            exitStatus = exitStatus.and(stepExecution.getExitStatus());
            stepExecution.setExitStatus(exitStatus);
            exitStatus = exitStatus.and(getCompositeListener().afterStep(stepExecution));
        }
        catch (Exception e) {
            logger.error(String.format(&quot;Exception in afterStep callback in step %s in job %s&quot;, name, stepExecution.getJobExecution().getJobInstance().getJobName()), e);
        }

        try {
            getJobRepository().updateExecutionContext(stepExecution);
        }
        catch (Exception e) {
            stepExecution.setStatus(BatchStatus.UNKNOWN);
            exitStatus = exitStatus.and(ExitStatus.UNKNOWN);
            stepExecution.addFailureException(e);
            logger.error(String.format(&quot;Encountered an error saving batch meta data for step %s in job %s. &quot;
                    + &quot;This job is now in an unknown state and should not be restarted.&quot;, name, stepExecution.getJobExecution().getJobInstance().getJobName()), e);
        }

        stepExecution.setEndTime(new Date());
        stepExecution.setExitStatus(exitStatus);

        try {
            getJobRepository().update(stepExecution);
        }
        catch (Exception e) {
            stepExecution.setStatus(BatchStatus.UNKNOWN);
            stepExecution.setExitStatus(exitStatus.and(ExitStatus.UNKNOWN));
            stepExecution.addFailureException(e);
            logger.error(String.format(&quot;Encountered an error saving batch meta data for step %s in job %s. &quot;
                    + &quot;This job is now in an unknown state and should not be restarted.&quot;, name, stepExecution.getJobExecution().getJobInstance().getJobName()), e);
        }

        try {
            close(stepExecution.getExecutionContext());
        }
        catch (Exception e) {
            logger.error(String.format(&quot;Exception while closing step execution resources in step %s in job %s&quot;, name, stepExecution.getJobExecution().getJobInstance().getJobName()), e);
            stepExecution.addFailureException(e);
        }

        doExecutionRelease();

        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Step execution complete: &quot; + stepExecution.getSummary());
        }
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
Step 또한 &lt;code&gt;StepListener&lt;/code&gt;가 존재한다. 이를 실행하는 코드

&lt;ul&gt;
&lt;li&gt;전처리 : getCompositeListener().beforeStep(stepExecution);&lt;/li&gt;
&lt;li&gt;후처리 : getCompositeListener().afterStep(stepExecution)&lt;/li&gt;
&lt;li style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/991751455AF15F2B38&quot; filemime=&quot;image/jpeg&quot; filename=&quot;stepListener-hierarchy.png&quot; height=&quot;321&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;
&lt;/ul&gt;
&lt;li&gt;&lt;code&gt;execute&lt;/code&gt; 메소드에서 추상 메소드인 &lt;code&gt;doExecute&lt;/code&gt; 메소드를 실행한다.&lt;/li&gt;
&lt;li&gt;Step의 여러 상태를 관리, 변경한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;toc_9&quot;&gt;TaskletStep.doExecute&lt;/h4&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Override
protected void doExecute(StepExecution stepExecution) throws Exception {
    stepExecution.getExecutionContext().put(TASKLET_TYPE_KEY, tasklet.getClass().getName());
    stepExecution.getExecutionContext().put(STEP_TYPE_KEY, this.getClass().getName());

    stream.update(stepExecution.getExecutionContext());
    getJobRepository().updateExecutionContext(stepExecution);

    // Shared semaphore per step execution, so other step executions can run
    // in parallel without needing the lock
    final Semaphore semaphore = createSemaphore();

    stepOperations.iterate(new StepContextRepeatCallback(stepExecution) {

        @Override
        public RepeatStatus doInChunkContext(RepeatContext repeatContext, ChunkContext chunkContext)
                throws Exception {

            StepExecution stepExecution = chunkContext.getStepContext().getStepExecution();

            // Before starting a new transaction, check for
            // interruption.
            interruptionPolicy.checkInterrupted(stepExecution);

            RepeatStatus result;
            try {
                result = new TransactionTemplate(transactionManager, transactionAttribute)
                .execute(new ChunkTransactionCallback(chunkContext, semaphore));
            }
            catch (UncheckedTransactionException e) {
                // Allow checked exceptions to be thrown inside callback
                throw (Exception) e.getCause();
            }

            chunkListener.afterChunk(chunkContext);

            // Check for interruption after transaction as well, so that
            // the interrupted exception is correctly propagated up to
            // caller
            interruptionPolicy.checkInterrupted(stepExecution);

            return result;
        }

    });

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;ItemReader, ItemProcessor, ItemWriter 실행 : stream.update(stepExecution.getExecutionContext());&lt;/li&gt;
&lt;li&gt;하나의 트랜잭션에서 chunk의 크기만큼 처리하기 위해 &lt;code&gt;java.util.Semaphore&lt;/code&gt; 사용 : final Semaphore semaphore = createSemaphore();&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/358&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>batch</category>
<category>Spring Batch</category>
<category>spring batch 코드</category>
<category>코드 리뷰</category>
<author>woniper</author>
<guid>https://blog.woniper.net/358</guid>
<comments>https://blog.woniper.net/358#entry358comment</comments>
<pubDate>Tue, 08 May 2018 19:25:00 +0900</pubDate>
</item>
<item>
<title>Spring Batch의 동작 코드 #Job 생성과 실행</title>
<link>https://blog.woniper.net/357</link>
<description>&lt;p&gt;&lt;a href=&quot;http://blog.woniper.net/356&quot;&gt;누구나 아는 Spring Batch 기본 개념&lt;/a&gt;에서 Spring Batch Domain에 대해 간단히 알아보았다. 이번 글에선 기본 개념에 정리한 여러 클래스가 서로 어떤 의존성을 가지며, 어떻게 동작하는지 코드를 살펴볼 것이다. 모든 코드를 다 볼 수 없기에 이번 글은 Job이 어떻게 생성되고 실행되는지 살펴본다.&lt;/p&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;Sample&lt;/h2&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Configuration
public class SimpleConfiguration {

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Bean
    public Job job() {
        return jobBuilderFactory.get(&quot;simple-job&quot;)
                .start(step())
                .build();
    }

    @Bean
    public Step step() {
        return stepBuilderFactory.get(&quot;simple-step&quot;)
                .&amp;lt;String, StringWrapper&amp;gt;chunk(10)
                .reader(itemReader())
                .processor(itemProcess())
                .writer(itemWriter())
                .build();
    }

    private ItemReader&amp;lt;String&amp;gt; itemReader() {
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

        for (int i = 0; i &amp;lt; 100; i++) {
            list.add(&quot;test&quot; + i);
        }

        return new ListItemReader(list);
    }

    private ItemProcessor&amp;lt;String, StringWrapper&amp;gt; itemProcess() {
        return StringWrapper::new;
    }

    private ItemWriter&amp;lt;StringWrapper&amp;gt; itemWriter() {
        return System.out::println;
    }

    private class StringWrapper {
        private String value;

        StringWrapper(String value) {
            this.value = value;
        }

        public String getValue() {
            return value;
        }

        @Override
        public String toString() {
            return String.format(&quot;i'm %s&quot;, getValue());
        }
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;위 예제는 아주 단순한 batch다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Job은 하나의 Step을 갖고 있으며, &lt;/li&gt;
&lt;li&gt;Step의 ItemReader는 ArrayList에 100개의 &lt;code&gt;String value&lt;/code&gt;를 담고 있다. (읽기)&lt;/li&gt;
&lt;li&gt;ItemProcessor는 ItemReader에서 반환된 String List를 &lt;code&gt;StringWrapper&lt;/code&gt; 클래스로 wrapping 한다. (가공)&lt;/li&gt;
&lt;li&gt;ItemWriter는 ItemProcessor를 통해 StringWrapper로 반환된 List를 &lt;code&gt;System.out.println&lt;/code&gt;으로 로그를 찍는다. (쓰기)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;toc_1&quot;&gt;실행&lt;/h4&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Configuration
@EnableBatchProcessing
public class JobRunnerConfiguration {

    @Bean
    public JobLauncherTestUtils utils() throws Exception {
        return new JobLauncherTestUtils();
    }

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Batch를 실행하기 위한 &lt;code&gt;JobLauncherTestUtils&lt;/code&gt;를 Bean으로 등록&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = { SimpleConfiguration.class, JobRunnerConfiguration.class})
public class SimpleConfigurationTests {

    @Autowired
    private JobLauncherTestUtils jobLauncherTestUtils;

    @Test
    public void testLaunchJob() throws Exception {
        jobLauncherTestUtils.launchJob();
    }
    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SimpleConfiguration, JobRunnerConfiguration&lt;/code&gt;을 &lt;code&gt;@Contextconfiguration&lt;/code&gt;을 이용해 테스트에 필요한 Config Bean으로 등록&lt;/li&gt;
&lt;li&gt;Bean으로 등록된 &lt;code&gt;JobLauncherTestUtils&lt;/code&gt;를 주입(@Autowired) 받아 Batch Job(SimpleConfiguration)을 실행&lt;/li&gt;
&lt;li&gt;이때 JobLauncherTestUtils은 &lt;code&gt;SimpleJobLauncher&lt;/code&gt;를 이용해 Batch Job을 실행&lt;/li&gt;
&lt;li&gt;SimpleConfiguration 예제의 &lt;code&gt;JobBuilderFactory, StepBuilderFactory&lt;/code&gt;의 자세한 설명은 생략한다. Job과 Step을 생성하는 객체라고 생각하면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;SimpleJobLauncher&lt;/h2&gt;

&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9949C44E5AEBB83909&quot; filemime=&quot;image/jpeg&quot; filename=&quot;simple-batch-diagram.png&quot; height=&quot;396&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;최대한 간단하게 diagram을 그리려 노력했다. 위 예제를 기준으로 Spring Batch가 내부적으로 어떻게 동작하는지 살펴보자.&lt;/p&gt;&lt;p&gt;일단 예제에서 JobLauncherTestUtils가 &lt;code&gt;SimpleJobLauncher&lt;/code&gt;를 통해 Job을 실행한다고 설명했다. 실제로 어떻게 실행하는지 코드를 보자.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Override
public JobExecution run(final Job job, final JobParameters jobParameters)
        throws JobExecutionAlreadyRunningException, JobRestartException, JobInstanceAlreadyCompleteException,
        JobParametersInvalidException {

    Assert.notNull(job, &quot;The Job must not be null.&quot;);
    Assert.notNull(jobParameters, &quot;The JobParameters must not be null.&quot;);

    final JobExecution jobExecution;
    JobExecution lastExecution = jobRepository.getLastJobExecution(job.getName(), jobParameters);
    if (lastExecution != null) {
    
        // 재실행 가능한 Job 인지 체크
        if (!job.isRestartable()) {
            throw new JobRestartException(&quot;JobInstance already exists and is not restartable&quot;);
        }
        /*
         * validate here if it has stepExecutions that are UNKNOWN, STARTING, STARTED and STOPPING
         * retrieve the previous execution and check
         */
        for (StepExecution execution : lastExecution.getStepExecutions()) {
            BatchStatus status = execution.getStatus();
            if (status.isRunning() || status == BatchStatus.STOPPING) {
                throw new JobExecutionAlreadyRunningException(&quot;A job execution for this job is already running: &quot;
                        + lastExecution);
            } else if (status == BatchStatus.UNKNOWN) {
                throw new JobRestartException(
                        &quot;Cannot restart step [&quot; + execution.getStepName() + &quot;] from UNKNOWN status. &quot;
                            + &quot;The last execution ended with a failure that could not be rolled back, &quot;
                            + &quot;so it may be dangerous to proceed. Manual intervention is probably necessary.&quot;);
            }
        }
    }

    job.getJobParametersValidator().validate(jobParameters);

    jobExecution = jobRepository.createJobExecution(job.getName(), jobParameters);

    try {
        taskExecutor.execute(new Runnable() {

            @Override
            public void run() {
                try {
                    logger.info(&quot;Job: [&quot; + job + &quot;] launched with the following parameters: [&quot; + jobParameters
                            + &quot;]&quot;);
                    job.execute(jobExecution);
                    logger.info(&quot;Job: [&quot; + job + &quot;] completed with the following parameters: [&quot; + jobParameters
                            + &quot;] and the following status: [&quot; + jobExecution.getStatus() + &quot;]&quot;);
                }
                catch (Throwable t) {
                    logger.info(&quot;Job: [&quot; + job
                            + &quot;] failed unexpectedly and fatally with the following parameters: [&quot; + jobParameters
                            + &quot;]&quot;, t);
                    rethrow(t);
                }
            }

            private void rethrow(Throwable t) {
                if (t instanceof RuntimeException) {
                    throw (RuntimeException) t;
                }
                else if (t instanceof Error) {
                    throw (Error) t;
                }
                throw new IllegalStateException(t);
            }
        });
    }
    catch (TaskRejectedException e) {
        jobExecution.upgradeStatus(BatchStatus.FAILED);
        if (jobExecution.getExitStatus().equals(ExitStatus.UNKNOWN)) {
            jobExecution.setExitStatus(ExitStatus.FAILED.addExitDescription(e));
        }
        jobRepository.update(jobExecution);
    }

    return jobExecution;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;JobExecution 반환&lt;/li&gt;
&lt;li&gt;JobRepository로 JobExecution 조회 및 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;run 메소드는 Job 객체와 JobParamter 객체를 받아 &lt;code&gt;JobRepository&lt;/code&gt;를 이용해 JobExecution을 조회(getLastJobExecution) 및 생성(createJobExecution)한다.&lt;/p&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;SimpleJobRepository.createJobExecution&lt;/h2&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Override
public JobExecution createJobExecution(String jobName, JobParameters jobParameters)
        throws JobExecutionAlreadyRunningException, JobRestartException, JobInstanceAlreadyCompleteException {

    Assert.notNull(jobName, &quot;Job name must not be null.&quot;);
    Assert.notNull(jobParameters, &quot;JobParameters must not be null.&quot;);

    JobInstance jobInstance = jobInstanceDao.getJobInstance(jobName, jobParameters);
    ExecutionContext executionContext;

    if (jobInstance != null) {

        List&amp;lt;JobExecution&amp;gt; executions = jobExecutionDao.findJobExecutions(jobInstance);

        for (JobExecution execution : executions) {
            if (execution.isRunning() || execution.isStopping()) {
                throw new JobExecutionAlreadyRunningException(&quot;A job execution for this job is already running: &quot;
                        + jobInstance);
            }
            BatchStatus status = execution.getStatus();
            if (status == BatchStatus.UNKNOWN) {
                throw new JobRestartException(&quot;Cannot restart job from UNKNOWN status. &quot;
                        + &quot;The last execution ended with a failure that could not be rolled back, &quot;
                        + &quot;so it may be dangerous to proceed. Manual intervention is probably necessary.&quot;);
            }
            if (execution.getJobParameters().getParameters().size() &amp;gt; 0 &amp;amp;&amp;amp; (status == BatchStatus.COMPLETED || status == BatchStatus.ABANDONED)) {
                throw new JobInstanceAlreadyCompleteException(
                        &quot;A job instance already exists and is complete for parameters=&quot; + jobParameters
                        + &quot;.  If you want to run this job again, change the parameters.&quot;);
            }
        }
        executionContext = ecDao.getExecutionContext(jobExecutionDao.getLastJobExecution(jobInstance));
    }
    else {
        jobInstance = jobInstanceDao.createJobInstance(jobName, jobParameters);
        executionContext = new ExecutionContext();
    }

    JobExecution jobExecution = new JobExecution(jobInstance, jobParameters, null);
    jobExecution.setExecutionContext(executionContext);
    jobExecution.setLastUpdated(new Date(System.currentTimeMillis()));

    jobExecutionDao.saveJobExecution(jobExecution);
    ecDao.saveExecutionContext(jobExecution);

    return jobExecution;

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;SimpleJobRepository는 JobRepository interface의 구현체.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;JobInstance를 조회&lt;/li&gt;
&lt;li&gt;JobInstance가 null이 아니라면, 실행 가능한 Job인지 체크 후 &lt;code&gt;JobExecution&lt;/code&gt;을 조회(ecDao.getExecutionContext)&lt;/li&gt;
&lt;li&gt;JobInstance가 null이라면, JobInstance와 &lt;code&gt;ExecutionContext&lt;/code&gt;를 &lt;code&gt;생성&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;마지막으로 JobExecution을 &lt;code&gt;저장&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 코드에서 몇가지 객체가 눈에 들어온다.&lt;/p&gt;

&lt;h4 id=&quot;toc_4&quot;&gt;JobExecution&lt;/h4&gt;

&lt;p&gt;앞 글에서 JobExecution에 대해 설명했다. Job이 한번 실행될 때 생성되는 객체다. 이 객체는 Job이 실행되는 데 위해 필요한 아래와 같은 객체를 담고 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JobParamter : Job을 실행하기 위해 필요한 paramter&lt;/li&gt;
&lt;li&gt;JobInstance : JobExecution을 조회하기 위한 id, name&lt;/li&gt;
&lt;li&gt;Collection&lt;stepexecution&gt; : Job이 포함하고 있는 실행 가능한 StepExecution List&lt;/stepexecution&gt;&lt;/li&gt;
&lt;li&gt;Job 실행 생성, 시작, 종료, 수정 시간&lt;/li&gt;
&lt;li&gt;그 외 여러 객체&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;private final JobParameters jobParameters;
private JobInstance jobInstance;
private volatile Collection&amp;lt;StepExecution&amp;gt; stepExecutions = Collections.synchronizedSet(new LinkedHashSet&amp;lt;&amp;gt;());
private volatile BatchStatus status = BatchStatus.STARTING;
private volatile Date startTime = null;
private volatile Date createTime = new Date(System.currentTimeMillis());
private volatile Date endTime = null;
private volatile Date lastUpdated = null;
private volatile ExitStatus exitStatus = ExitStatus.UNKNOWN;
private volatile ExecutionContext executionContext = new ExecutionContext();
private transient volatile List&amp;lt;Throwable&amp;gt; failureExceptions = new CopyOnWriteArrayList&amp;lt;&amp;gt;();
private final String jobConfigurationName;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;JobExecution에 멤버 변수로 선언된 객체들.&lt;/p&gt;

&lt;h4 id=&quot;toc_5&quot;&gt;ExecutionContext&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;ExecutionContext&lt;/code&gt; 객체는 Job이 실행되는 동안 필요한 데이터를 메모리(Map)에 저장하고 관리하는 객체다. 실제로 이 객체를 살펴보면 Map을 통해 데이터를 저장, 조회한다.&lt;/p&gt;&lt;p&gt;ExecutionContext의 생명 주기는 Job이 실행되는 동안 사용된다.&lt;/p&gt;

&lt;h2 id=&quot;toc_6&quot;&gt;job.execute(jobExecution);&lt;/h2&gt;

&lt;p&gt;다시 &lt;code&gt;SimpleJobLauncher&lt;/code&gt; 코드로 돌아가 보자. job.execute 메소드가 바로 Job을 실행하는 부분이다. JobRepository를 통해 생성된 &lt;code&gt;JobExecution&lt;/code&gt;을 argument로 넘긴다. 즉, JobExecution은 Job을 실행하는 데 필요한 객체다.&lt;/p&gt;

&lt;h4 id=&quot;toc_7&quot;&gt;AbstractJob.execute&lt;/h4&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Override
public final void execute(JobExecution execution) {

    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Job execution starting: &quot; + execution);
    }

    // 1. ThreadLocal에 현재 실행될 Job 등록
    JobSynchronizationManager.register(execution);

    try {

        // 2. 실행 가능한 Job인지 JobParameter 검증
        jobParametersValidator.validate(execution.getJobParameters());

        if (execution.getStatus() != BatchStatus.STOPPING) {

            // 3. 시작 시간 등록
            execution.setStartTime(new Date());
            // 4. Batch 상태를 시작으로 변경
            updateStatus(execution, BatchStatus.STARTED);

            // 5. JobExecutionListener.beforeJob 실행 (전 처리)
            listener.beforeJob(execution);

            try {
                // 6. job 구현체 실행
                doExecute(execution);
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Job execution complete: &quot; + execution);
                }
            } catch (RepeatException e) {
                throw e.getCause();
            }
        } else {

            // The job was already stopped before we even got this far. Deal
            // with it in the same way as any other interruption.
            execution.setStatus(BatchStatus.STOPPED);
            execution.setExitStatus(ExitStatus.COMPLETED);
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Job execution was stopped: &quot; + execution);
            }

        }

    } catch (JobInterruptedException e) {
        logger.info(&quot;Encountered interruption executing job: &quot;
                + e.getMessage());
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Full exception&quot;, e);
        }
        execution.setExitStatus(getDefaultExitStatusForFailure(e, execution));
        execution.setStatus(BatchStatus.max(BatchStatus.STOPPED, e.getStatus()));
        execution.addFailureException(e);
    } catch (Throwable t) {
        logger.error(&quot;Encountered fatal error executing job&quot;, t);
        execution.setExitStatus(getDefaultExitStatusForFailure(t, execution));
        execution.setStatus(BatchStatus.FAILED);
        execution.addFailureException(t);
    } finally {
        try {
            if (execution.getStatus().isLessThanOrEqualTo(BatchStatus.STOPPED)
                    &amp;amp;&amp;amp; execution.getStepExecutions().isEmpty()) {
                ExitStatus exitStatus = execution.getExitStatus();
                ExitStatus newExitStatus =
                        ExitStatus.NOOP.addExitDescription(&quot;All steps already completed or no steps configured for this job.&quot;);
                execution.setExitStatus(exitStatus.and(newExitStatus));
            }

            execution.setEndTime(new Date());

            try {
                // 7. JobExecutionListener.afterJob 실행 (후 처리)
                listener.afterJob(execution);
            } catch (Exception e) {
                logger.error(&quot;Exception encountered in afterStep callback&quot;, e);
            }

            jobRepository.update(execution);
        } finally {
            JobSynchronizationManager.release();
        }

    }

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;코드가 길고 복잡하지만, 주석을 보면 그렇게 복잡한 로직은 아니다.&lt;/p&gt;

&lt;h4 id=&quot;toc_8&quot;&gt;5. JobExecutionListener.beforeJob 실행&lt;/h4&gt;

&lt;p&gt;Job이 실행되기 전처리, 후처리 가능한 JobExecutionListener가 있다. 이 정도만 알고 넘어가자.&lt;/p&gt;

&lt;h4 id=&quot;toc_9&quot;&gt;6. job 구현체 실행&lt;/h4&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;abstract protected void doExecute(JobExecution execution) throws JobExecutionException;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;AbstractJob은 이름과 같이 추상 클래스다. &lt;code&gt;AbstractJob.doExecute&lt;/code&gt; 메소드는 추상 메소드다. 이를 상속받아 구현된 Job 객체가 doExecution을 구현하고 있을 것이다. 그럼 이 예제에서 AbstractJob을 구현한 구현 객체는 무엇일까?&lt;/p&gt;

&lt;h2 id=&quot;toc_10&quot;&gt;SimpleJob.doExecute&lt;/h2&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Override
protected void doExecute(JobExecution execution) throws JobInterruptedException, JobRestartException,
StartLimitExceededException {

    StepExecution stepExecution = null;
    for (Step step : steps) {
        stepExecution = handleStep(step, execution);
        if (stepExecution.getStatus() != BatchStatus.COMPLETED) {
            //
            // Terminate the job if a step fails
            //
            break;
        }
    }

    //
    // Update the job status to be the same as the last step
    //
    if (stepExecution != null) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Upgrading JobExecution status: &quot; + stepExecution);
        }
        execution.upgradeStatus(stepExecution.getStatus());
        execution.setExitStatus(stepExecution.getExitStatus());
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;SimpleJob&lt;/code&gt;이 바로 AbstractJob을 구현한 구현체다. doExecute 메소드는 Step List를 실행한다. &lt;/p&gt;&lt;p&gt;Step이 실행되는 과정은 다음 포스팅에.&lt;/p&gt;&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/357&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>batch</category>
<category>Spring Batch</category>
<category>spring batch 코드</category>
<category>코드 리뷰</category>
<author>woniper</author>
<guid>https://blog.woniper.net/357</guid>
<comments>https://blog.woniper.net/357#entry357comment</comments>
<pubDate>Fri, 04 May 2018 12:30:00 +0900</pubDate>
</item>
<item>
<title>누구나 아는 Spring Batch 기본 개념</title>
<link>https://blog.woniper.net/356</link>
<description>&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;Spring Batch를 사용해본 개발자라면 이 포스팅은 볼 필요 없다. Spring Batch의 기본 개념 (레퍼런스 문서에서는 domain이라고 표현한..)을 내&amp;nbsp;나름대로 정리하는 글이다. 이 글은 Spring Batch가 무엇인지, 왜 사용하는지 설명하지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;기본 개념&lt;/h2&gt;

&lt;p&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:738px;text-align: center;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99E54D385AE6E8CD08&quot; filemime=&quot;image/jpeg&quot; filename=&quot;spring-batch-reference-model.png&quot; height=&quot;294&quot; style=&quot;text-align: center;&quot; width=&quot;738&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Job : Batch에서 실행 가능한 실행 단위.&lt;/li&gt;
&lt;li&gt;JobLauncher : Job을 실행하는 책임이 있다. JobRepository를 통해 Job, Step, Item* 등을 생성하고 조립.&lt;/li&gt;
&lt;li&gt;JobRepository : DB 또는 어딘가에 저장된 Job, Step 등을 조회(select) 또는 생성(insert), 수정(update).&lt;/li&gt;
&lt;li&gt;Step : Job은 1개 이상의 Step을 포함(1:N)할 수 있고, 하나의 큰 실행 단위가 Job이라면 Step은 Job의 통제를 받으며 Job 안에서 실행 가능한 Job보다 작은 실행 단위.&lt;/li&gt;
&lt;li&gt;ItemReader : 하나의 Step은 0~1개의 ItemReader를 포함하며, 데이터를 어디선가 (DB, file, memory 등) 조회하는 역할.&lt;/li&gt;
&lt;li&gt;ItemProcessor : 하나의 Step은 0~1개의 ItemProcessor를 포함하며, ItemReader를 통해 조회한 데이터를 중간에서 &lt;code&gt;가공&lt;/code&gt;하는 역할.&lt;/li&gt;
&lt;li&gt;ItemWriter : 하나의 Step은 0~1개의 ItemWriter를 포함하며, ItemProcessor를 통해 가공된 데이터를 Write하는 역할. 이름이 Writer 지만, 쓰기만 가능한 건 아니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;toc_1&quot;&gt;Step, Item* 은 한 묶음&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;ItemReader&lt;/code&gt;, &lt;code&gt;ItemProcessor&lt;/code&gt;, &lt;code&gt;ItemWriter&lt;/code&gt;는 &lt;code&gt;Step&lt;/code&gt;에 포함되며, 하나의 묶음이다. Item* 객체가 Step에 반드시 모두 포함되지 않아도 되지만, Batch는 &lt;code&gt;읽고&lt;/code&gt;, &lt;code&gt;가공하고&lt;/code&gt;, &lt;code&gt;쓰고&lt;/code&gt;를 기본 동작으로 작동한다.&lt;/p&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;좀 더 자세한 Job&lt;/h2&gt;

&lt;p&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;text-align: center;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/992F57385AE6E8CD30&quot; filemime=&quot;image/jpeg&quot; filename=&quot;job-diagram.png&quot; height=&quot;768&quot; style=&quot;text-align: center;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&quot;toc_3&quot;&gt;Job&lt;/h4&gt;

&lt;p&gt;Job은 여러 개의 Step을 포함하고 있는 객체일 뿐이다. (레퍼런스에는 steps의 컨테이너(container)라고 표현)
Job의 구현체인 &lt;code&gt;SimpleJob&lt;/code&gt; 필드는 실제로 아래와 같다.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;private List&amp;lt;Step&amp;gt; steps = new ArrayList&amp;lt;Step&amp;gt;();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Step List가 선언되어 있는걸 확인할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;toc_4&quot;&gt;JobInstance&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;JobRepository&lt;/code&gt;를 통해 &lt;code&gt;조회&lt;/code&gt; 또는 &lt;code&gt;생성&lt;/code&gt; 되며, Job의 논리적인 실행 단위 객체다. 단순히 job의 &lt;code&gt;name&lt;/code&gt;과 &lt;code&gt;id&lt;/code&gt;를 필드로 선언되어 있을 뿐이다.&lt;/p&gt;

&lt;h4 id=&quot;toc_5&quot;&gt;JobExecution&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;JobRepository&lt;/code&gt;를 통해 &lt;code&gt;조회&lt;/code&gt; 또는 &lt;code&gt;생성&lt;/code&gt; 되며, Batch가 Job을 한번 실행할 때마다 생성된다. Job 실행 시 필요한 정보를 아래와 같이 담고있고, 현재 실행되고 있는 Batch의 상태를 &lt;code&gt;BatchStatus&lt;/code&gt;에 담고 있다.&lt;/p&gt;&lt;p&gt;자세한 속성 정보는 &lt;a href=&quot;https://docs.spring.io/spring-batch/trunk/reference/htmlsingle/#domainJobExecution&quot;&gt;여기&lt;/a&gt;를 보자.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;private final JobParameters jobParameters;
private JobInstance jobInstance;
private volatile Collection&amp;lt;StepExecution&amp;gt; stepExecutions = Collections.synchronizedSet(new LinkedHashSet&amp;lt;&amp;gt;());
private volatile BatchStatus status = BatchStatus.STARTING;
private volatile Date startTime = null;
private volatile Date createTime = new Date(System.currentTimeMillis());
private volatile Date endTime = null;
private volatile Date lastUpdated = null;
private volatile ExitStatus exitStatus = ExitStatus.UNKNOWN;
private volatile ExecutionContext executionContext = new ExecutionContext();
private transient volatile List&amp;lt;Throwable&amp;gt; failureExceptions = new CopyOnWriteArrayList&amp;lt;&amp;gt;();
private final String jobConfigurationName;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;toc_6&quot;&gt;JobParameter&lt;/h4&gt;

&lt;p&gt;Job을 실행하는데 필요한 &lt;code&gt;parameter&lt;/code&gt; 정보를 &lt;code&gt;key, value&lt;/code&gt; 형태로 담고있다. &lt;/p&gt;

&lt;h4 id=&quot;toc_7&quot;&gt;JobRepository(SimpleRepository)&lt;/h4&gt;

&lt;p&gt;설명을 위해 JobRepository interface의 구현체인 SimpleRepository를 diagram에 포함했다.
SimpleJobRepository는 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html&quot;&gt;JdbcTemplate&lt;/a&gt;을 통해&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JobInstance&lt;/li&gt;
&lt;li&gt;JobExecution&lt;/li&gt;
&lt;li&gt;JobExecutionParameter&lt;/li&gt;
&lt;li&gt;StepExecution&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;등을 저장하고 조회한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Spring Batch에서 기본 구현체들은 대부분 Simple* prefix name을 사용한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;toc_8&quot;&gt;좀 더 자세한 Step&lt;/h2&gt;

&lt;p&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;text-align: center;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9917E4385AE6E8CE04&quot; filemime=&quot;image/jpeg&quot; filename=&quot;step-diagram.png&quot; height=&quot;296&quot; style=&quot;text-align: center;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&quot;toc_9&quot;&gt;Step&lt;/h4&gt;

&lt;p&gt;하나의 Job은 여러 개의 Step을 포함할 수 있다. Step은 말 그대로 단계를 정의할 수 있는 객체이며, 이 Step에서 실제 Batch Job을 처리하는 작업의 일부 또는 전체를 수행한다. Job이 여러 개의 Step을 포함할 수 있다는 의미는 여러 가지 단계를 거쳐 Batch Job을 처리할 수 있다는 의미다.
위에 설명했지만, Step은 ItemReader, ItemProcessor, ItemWriter를 포함한다.&lt;/p&gt;

&lt;h4 id=&quot;toc_10&quot;&gt;StepExecution&lt;/h4&gt;

&lt;p&gt;JobExecution는 Job의 상태와 Job을 실행하기 위한 속성을 포함하고 있었다면, StepExecution은 Step의 상태와 Step을 실행하기 위한 속성을 포함하고 있다. StepExecution도 마찬가지로 속성 정보를 자세히 설명한 &lt;a href=&quot;https://docs.spring.io/spring-batch/trunk/reference/htmlsingle/#domainStepExecution&quot;&gt;문서&lt;/a&gt;를 보자.&lt;/p&gt;

&lt;h4 id=&quot;toc_11&quot;&gt;StepBuilder, SimpleStepBuilder&lt;/h4&gt;

&lt;p&gt;Step을 생성하기 위한 클래스다. Step을 생성하는데 필요한 &lt;code&gt;Item*&lt;/code&gt;과 그 외 여러 가지 속성들을 주입해 생성한다.&lt;/p&gt;

&lt;h4 id=&quot;toc_12&quot;&gt;ItemReader&lt;/h4&gt;

&lt;p&gt;Step에 포함되며, 데이터 &lt;code&gt;읽기&lt;/code&gt;를 책임진다.&lt;/p&gt;

&lt;h4 id=&quot;toc_13&quot;&gt;ItemProcessor&lt;/h4&gt;

&lt;p&gt;Step에 포함되며, ItemReader로 읽은 데이터를 &lt;code&gt;가공&lt;/code&gt;한다.&lt;/p&gt;

&lt;h4 id=&quot;toc_14&quot;&gt;ItemWriter&lt;/h4&gt;

&lt;p&gt;Step에 포함되며, ItemReader로 읽고, ItemProcessor로 가공된 후 ItemWriter로 전달돼 &lt;code&gt;쓰여&lt;/code&gt;진다. 여기서 &lt;code&gt;쓰기&lt;/code&gt;는 단순히 데이터를 저장(insert)하는 역할 뿐 아니라 &lt;code&gt;읽고&lt;/code&gt;, &lt;code&gt;가공&lt;/code&gt;된 데이터의 후처리를 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;toc_15&quot;&gt;참고&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-batch/trunk/reference/htmlsingle/#domain&quot;&gt;The Domain Language of Batch&lt;/a&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/356&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>batch</category>
<category>Spring</category>
<category>Spring Batch</category>
<category>spring batch domain</category>
<category>spring batch 개념</category>
<author>woniper</author>
<guid>https://blog.woniper.net/356</guid>
<comments>https://blog.woniper.net/356#entry356comment</comments>
<pubDate>Mon, 30 Apr 2018 19:00:10 +0900</pubDate>
</item>
<item>
<title>꾸준함을 유지하는 방법</title>
<link>https://blog.woniper.net/355</link>
<description>&lt;p&gt;나는 원래 이런 사람이었다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;잠이 많다.&lt;/li&gt;
&lt;li&gt;움직이기 싫어한다.&lt;/li&gt;
&lt;li&gt;귀차니즘 폭발&lt;/li&gt;
&lt;li&gt;해야할 일을 미룬다.&lt;/li&gt;
&lt;li&gt;새로운 일에 쉽게 흥미가 생기고, 쉽게 그만둔다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;웨이트 트레이닝을 시작하다.&lt;/h2&gt;

&lt;p&gt;이런 나를 바꾸고 싶었다. 2016년 12월 07일 나는 웨이트 트레이닝을 시작했다. 웨이트를 해본적이 없었던 나는 PT를 했다. 지금 생각하면 좋은 PT 선생님을 만나 운동뿐 아니라 안 좋은 습관을 많이 개선한 거 같다.
그 당시 4개월간 &lt;code&gt;40kg&lt;/code&gt;을 감량했고(지금은 대박 요요ㅋㅋ) 운동하는 습관이 생겼다. 그 당시 주변 사람들이 왜 이렇게 갑자기 살을 독하게 빼냐는 질문에 나는 항상 &lt;code&gt;특별한 이유는 없다&lt;/code&gt;라고 했었다. 결과론적인 말이지만, 지금 생각해보면 나는 게으른 나를 바꾸고 싶었는지도 모르겠다.&lt;/p&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;현재의 꾸준함.&lt;/h2&gt;

&lt;p&gt;사실 현재도 그렇게 거창한 일을 할 수 있게 된 건 아니다. 다만 사소하지만, 무엇이든 꾸준히 하는 나로 바뀌었다.&lt;/p&gt;

&lt;h4 id=&quot;toc_2&quot;&gt;평일은 항상 아침 5시에 일어난다.&lt;/h4&gt;

&lt;p&gt;출/퇴근 시간이 길다. 그렇기 때문에 항상 첫차를 탄다. 차도 덜 막히고, 일찍 출근해 무언가 할 수 있는 시간이 생긴다. 처음엔 정말 힘들었다. 하지만 왜 힘든지 고민한 결과 충분히 잠을 못잤기 때문이다. 나는 잠을 몇 시간 정도 자야 적당한지 간단히 실험한 결과 적정 시간은 약 6시간 30분. 그 후로 일찍 자고 일찍 일어난다. 매주 수, 목은 항상 힘든 날이지만 5시에 일어나는 걸 지킨다. 이상하게 금요일은 하나도 힘들지 않은 걸 보면 수, 목이 힘든 이유는 심리적인 게 강한 거 같다.&lt;/p&gt;

&lt;h4 id=&quot;toc_3&quot;&gt;약 1시간 30분 정도의 출/퇴근길에 짧게는 20분, 길게는 1시간가량 책을 읽는다.&lt;/h4&gt;

&lt;p&gt;책을 읽으면 집중을 잘 못 하고, 다른 생각하게 되고, 어느새 딴짓을 했다. 그래서 &lt;a href=&quot;https://namu.wiki/w/%EB%BD%80%EB%AA%A8%EB%8F%84%EB%A1%9C&quot;&gt;뽀모도로&lt;/a&gt;를 활용하기로 했다. (&lt;a href=&quot;https://itunes.apple.com/kr/app/be-focused-pro-focus-timer/id961632517?mt=12&quot;&gt;Be Focused Pro&lt;/a&gt; 추천)
  처음엔 너무 피곤해 버스 안에서 책을 읽기 힘들었기 때문에 책을 읽지 않고 버스에서 자지 않는 연습을 했다. 그 후 뽀모도로를 이용해 20분간 책을 읽고 그다음 40분, 컨디션 좋으면 60분간 읽었다. 너무 피곤한 날은 딱 20분만 읽고 그냥 잠을 자기도 한다.&lt;/p&gt;

&lt;h4 id=&quot;toc_4&quot;&gt;회사 근처 헬스장에서 매주 &lt;code&gt;월, 수, 금&lt;/code&gt; 빠지지 않고 운동한다.&lt;/h4&gt;

&lt;p&gt;회사 근처에 괜찮은 헬스장을 찾았다. 3개월 등록할까 하다 아까워서라도 꾸준히 다니기 위해 1년을 등록했다. 원래 다이어트를 빡쎄게 하는 시기에는 주 6일 운동했는데, 출퇴근 거리도 멀고 운동을 그만두고 다시 시작한 지 얼마 되지 않아 체력이 아직 안 올라와서 주 3일 프로그램을 만들어서 운동한다. 출/퇴근 시간을 이용해 책 읽는 시간을 천천히 늘렸듯이 웨이트 트레이닝도 시간을 두고 조금씩 올릴 예정이다. (휴식도 훈련이다.)
  주 3회 운동 프로그램은 &lt;code&gt;stronglift&lt;/code&gt; 일반 웨이팅 트레이너가 가르쳐주는 바디빌딩식 프로그램과는 조금 다르다. 힘을 키우기 적당한 프로그램이다. 3대 운동 500kg 찍고 바디빌딩 프로그램을 잠시 바꿀 예정이다.&lt;/p&gt;

&lt;h4 id=&quot;toc_5&quot;&gt;매일 23시 전에 취침한다.&lt;/h4&gt;

&lt;p&gt;아침 5시에 일어나면 자연스럽게 23시 전에는 잔다. 보통은 22시 30분쯤 잔다. 가끔 커피를 많이 마신 날은 잠이 안 와 23시가 넘어가기도하는데, 23시가 넘어 잔 날 다음날은 더 피곤하다. 그래서 23시 전에는 최대한 자려고 노력하고 그 시간이 넘어가면 불안하다.&lt;/p&gt;

&lt;h4 id=&quot;toc_6&quot;&gt;해야할 일을 기록하고 미리미리한다.&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://itunes.apple.com/kr/app/things-3/id904280696?mt=12&quot;&gt;things&lt;/a&gt;라는 앱을 이용해 할일을 정리하고 미리하려 노력한다. &lt;a href=&quot;http://blog.woniper.net/349&quot;&gt;TV가 나를 프로그래밍한다고?&lt;/a&gt; 글에 나는 TV를 보며 할 일을 자주 미뤘다는 걸 알 수 있는데 요즘은 미리미리 하는 습관을 길렀다. 한가지 부작용은 미리미리 안 하면 스트레스를 받는다는 것.&lt;/p&gt;

&lt;h4 id=&quot;toc_7&quot;&gt;새로운 일은 보수적으로 시작하고, 하던 일은 꾸준히 한다.&lt;/h4&gt;

&lt;p&gt;지금도 그렇지만, 워낙 새로운 일에 흥미를 잘 느끼는 성격이었다. &lt;code&gt;things&lt;/code&gt;에 나중에 하려고 등록만 해놓고 지금 하는 일에 집중하려 노력한다. 가끔 딴 길로 샐 때도 있지만.
  현재는 spring batch 레퍼런스 문서도 읽고 코드를 살펴보는 중이다. 빠르진 않지만, 꾸준히 하는 게 중요하다고 생각한다.&lt;/p&gt;

&lt;h2 id=&quot;toc_8&quot;&gt;미래의 꾸준함.&lt;/h2&gt;

&lt;p&gt;이렇게 매주 똑같은 시간, 똑같은 일상을 보내면 가끔 지루하고 힘들기도 하다. 그럴 때면 저녁에 맛있는 걸 먹거나, 와이프와 공원 산책하며 스트레스를 풀곤 한다. 나는 항상 마음이 조급했다. 앞서간 남들을 따라가기 바빴고, 그들을 쫓아가며 스트레스받기 바빴다. 지금은 그러지 않으려 노력한다. 나에게 맞는 속도를 유지하며, 조금은 느리더라도 포기하지 않고 꾸준히 하는 게 더 빠르다는걸 깨달았다. 앞으로도 꾸준함을 지키기 위해 노력해야겠다.&lt;/p&gt;
&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/355&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>이야기</category>
<category>꾸준함</category>
<category>꾸준함을 유지하는 방법</category>
<author>woniper</author>
<guid>https://blog.woniper.net/355</guid>
<comments>https://blog.woniper.net/355#entry355comment</comments>
<pubDate>Thu, 26 Apr 2018 11:49:59 +0900</pubDate>
</item>
<item>
<title>mac os에서 intellij 완전 제거 / 백업 하기</title>
<link>https://blog.woniper.net/354</link>
<description>&lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;https://confluence.jetbrains.com/display/IDEADEV/IDEA+2018.1+EAP&quot;&gt;intellij 2018.1 EAP&lt;/a&gt; 버전을 설치한 후 고난이 시작되었다. spring application server를 실행만 하면 5분에 한번씩 5분간 mac이 hang 걸렸다. 키보드도 트랙패드도 먹통이다. 그래서 백업 후 완전 초기화를 했다. 이를 정리하는 포스팅이다.&lt;/p&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;백업&lt;/h2&gt;

&lt;p&gt;OS 마다 intellij 설치 경로가 다르다. &lt;a href=&quot;https://confluence.jetbrains.com/display/IDEADEV/IDEA+2018.1+EAP&quot;&gt;여기&lt;/a&gt;를 참고하자.&lt;/p&gt;

&lt;h4 id=&quot;toc_1&quot;&gt;맥 기준으로 백업 대상 디렉토리 경로&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;plugins path : ~/Library/Application Support/&lt;PRODUCT&gt;&lt;VERSION&gt;&lt;/li&gt;
&lt;li&gt;config path : ~/Library/Preferences/&lt;PRODUCT&gt;&lt;VERSION&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;두 경로를 다른 경로로 백업한다. config path에 저장되어 있는 설정 정보는 &lt;code&gt;intellij &amp;gt; file &amp;gt; Export Settings...&lt;/code&gt;로 대신 백업 가능하다. 하지만 라이센스 정보도 함께 백업해야 했기 때문에 &lt;code&gt;config path&lt;/code&gt;의 하위 파일 모두 백업했다. 참고로 &lt;code&gt;config path/idea.key&lt;/code&gt; 파일이 라이센스 정보가 담겨있는 파일이다. (노출되면 안됨)&lt;/p&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;완전 제거&lt;/h2&gt;

&lt;p&gt;mac os에서 흔적도 없이 지우기 위해 &lt;a href=&quot;http://freemacsoft.net/appcleaner/&quot;&gt;AppCleaner&lt;/a&gt;를 사용했다.
사용 방법은 쉽기 때문에 따로 설명하지 않겠다. mac os에서 앱을 깔끔하게 지우기에는 이 앱이 가장 편리해보인다.&lt;/p&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;재 설치&lt;/h2&gt;

&lt;p&gt;EAP 버전이 아닌 정식 버전을 다시 설치했더니 문제는 사라졌다. 젠장.. 아까운 내 시간..&lt;/p&gt;
&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/354&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>개발환경</category>
<category>IntelliJ</category>
<category>intellij backup</category>
<category>intellij 백업</category>
<category>intellij 삭제</category>
<category>intellij 제거</category>
<author>woniper</author>
<guid>https://blog.woniper.net/354</guid>
<comments>https://blog.woniper.net/354#entry354comment</comments>
<pubDate>Mon, 23 Apr 2018 19:27:27 +0900</pubDate>
</item>
<item>
<title>intellij, gradle에서 generated sourceSet 설정</title>
<link>https://blog.woniper.net/353</link>
<description>&lt;p&gt;jooq나 querydsl 같은 프레임워크는 typesafe를 지원하기 위해 class를 생성하는데, 생성하기 위해서 maven 또는 gardle 설정이 필요하다.
이번 포스팅에서는 gradle을 기준으로 생성된 class를 sourceSet으로 등록하는 방법을 기록해두기 위함이다.&lt;/p&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;build.gradle&lt;/h2&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;/**
* intellij 관련 plugin 추가
*/
apply plugin: &amp;#39;idea&amp;#39;

ext {
        // 생성된 class 경로
        generatedJavaSourceDir = &amp;quot;src/generated/java&amp;quot;
}

/**
* sourceSet에 generated add
*/
sourceSets {
    generated {
        java.srcDir generatedJavaSourceDir
    }
}

/**
* 보통 src/main/java에 생성된 class는 generated class에 의존한다.
* 이를 위한 의존관계 설정
*/
compileJava {
    source += sourceSets.generated.java
}

/**
* intellij에 생성된 class가 sourceSet으로 인식되기 위한 설정
*/
idea {
    module {
        sourceDirs += sourceSets.generated.java.srcDirs
        generatedSourceDirs += sourceSets.generated.java.srcDirs
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/353&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>개발환경</category>
<author>woniper</author>
<guid>https://blog.woniper.net/353</guid>
<comments>https://blog.woniper.net/353#entry353comment</comments>
<pubDate>Thu, 01 Feb 2018 11:38:08 +0900</pubDate>
</item>
<item>
<title>mac에서 visual studio code를 git commit editor로 설정하기</title>
<link>https://blog.woniper.net/352</link>
<description>&lt;p&gt;&lt;a href=&quot;https://justhackem.wordpress.com/2018/01/30/writing-git-commit-messages-using-vscode/&quot;&gt;Visual Studio Code를 사용해 Git 커밋 메시지 작성하기
&lt;/a&gt;라는 글을 보고 visual studio code를 git editor로 설정하기로 했다. 간단하지만, 기록을 남기기 위해서 블로깅한다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio Code Download&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Visual Studio Code (이하 VSC) 경로 확인

&lt;ul&gt;
&lt;li&gt;mac 환경에서는 보통 &lt;code&gt;/Volumes/HD/Applications/&lt;/code&gt; 디렉토리 하위에 설치될 것이다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$ git config --global core.editor &amp;quot;/Volumes/HD/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code --wait&amp;quot;&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;위 경로는 예시일뿐 2번에서 경로를 확인 후 &lt;code&gt;$git config&lt;/code&gt; 명령을 입력한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/Volumes/HD/Applications/Visual\ Studio\ Code.app&lt;/code&gt;까지만 입력해도 된다고 생각하겠지만 그렇지 않다. &lt;code&gt;/Volumes/HD/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code --wait&lt;/code&gt; 까지 모두 입력해야한다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;50/72 규칙을 적용하기 위해 VSC 설정을 해야한다.

&lt;ul&gt;
&lt;li&gt;VSC 실행&lt;/li&gt;
&lt;li&gt;Code &amp;gt; 기본 설정 &amp;gt; 설정 (단축키 command + ,)&lt;/li&gt;
&lt;li&gt;아래 설정 코드를 입력&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;{
&amp;quot;[git-commit]&amp;quot;: {
    &amp;quot;editor.fontFamily&amp;quot;: &amp;quot;D2Coding&amp;quot;,
    &amp;quot;editor.rulers&amp;quot;: [
        50,
        72
    ]
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/352&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>개발환경</category>
<author>woniper</author>
<guid>https://blog.woniper.net/352</guid>
<comments>https://blog.woniper.net/352#entry352comment</comments>
<pubDate>Wed, 31 Jan 2018 22:22:11 +0900</pubDate>
</item>
<item>
<title>소프트스킬</title>
<link>https://blog.woniper.net/351</link>
<description>&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:271px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9979543359E535F229&quot; filemime=&quot;image/jpeg&quot; filename=&quot;66449912.jpg&quot; height=&quot;400&quot; width=&quot;271&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;적지 않은 분량의 책이지만 이렇게까지 오래 읽은 책은 아닌데, 게으름 때문에 오랫동안 읽은 책이다.
개발자로서 자신을 어떻게 브랜딩하고, 건강관리, 자산관리 등 개발자로 살아가며 어쩌면 개발자가 아니어도 삶을 살아가며 도움될 만한 많은 것들을 제시하고 생각하게 한다.
  책을 읽으며 저자가 부러운 점은 33세에 은퇴를 했다는 것이다. 피치 못한 은퇴가 아닌 부동산 + 여러 가지 소득으로 회사에 다니지 않아도 불로소득이 마련되기 때문이다. 나도 나름대로 개발을 좋아하고 잘하려고 노력하는데, 좋아하는 일을 회사에서 하는 것과 내가 좋아하는 일은 구분이 필요하기도 하고 회사에서 일하다 보면 하기 싫은 일도 해야 되기 마련이다.
저자는 은퇴를 일을 아예 그만두는 게 아니라, 자신이 하고 싶은 일을 자유롭게 하는 거라고 한다. 나도 그런 날이 오면 좋겠다.&lt;/p&gt;&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/351&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>책소개</category>
<author>woniper</author>
<guid>https://blog.woniper.net/351</guid>
<comments>https://blog.woniper.net/351#entry351comment</comments>
<pubDate>Tue, 17 Oct 2017 07:54:10 +0900</pubDate>
</item>
<item>
<title>AbstractList.add(E)는 쓸 수 없어!</title>
<link>https://blog.woniper.net/350</link>
<description>&lt;p&gt;개발 중에 &lt;code&gt;list.addAll(T);&lt;/code&gt; 와 같은 코드 작성할 일이 있었다.
하지만 계속 &lt;code&gt;java.lang.UnsupportedOperationException&lt;/code&gt; 에러가 나는 게 아닌가?
결론부터 말하자면 생각 없이 &lt;code&gt;Collections.emptyList();&lt;/code&gt;로 초기화했기 때문이다.&lt;/p&gt;

&lt;h1 id=&quot;toc_0&quot;&gt;java.lang.UnsupportedOperationException&lt;/h1&gt;

&lt;p&gt;java &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html&quot;&gt;문서&lt;/a&gt;에는 이 Exception을 이렇게 설명한다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;요청한 오퍼레이션이 지원되지 않는 경우 Exception 발생&lt;/li&gt;
&lt;li&gt;UnsupportedOperationException는 Java Collection Framework에 Exception 클래스다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;그럼 Java Collection Framework를 사용하는 경우 비정상 요청을 한 경우 throw 되는 것인가??&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;toc_1&quot;&gt;Collections.emptyList()&lt;/h1&gt;

&lt;p&gt;아래 코드는 emptyList 메소드다. 단순히 EMPTY_LIST라는 멤버 변수를 반환 하는데, 주석에 &lt;code&gt;immutable한 empty list를 반환&lt;/code&gt; 한다고 쓰여있다.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;/**
 * Returns an empty list (immutable).  This list is serializable.
 *
 * &amp;lt;p&amp;gt;This example illustrates the type-safe way to obtain an empty list:
 * &amp;lt;pre&amp;gt;
 *     List&amp;amp;lt;String&amp;amp;gt; s = Collections.emptyList();
 * &amp;lt;/pre&amp;gt;
 *
 * @implNote
 * Implementations of this method need not create a separate &amp;lt;tt&amp;gt;List&amp;lt;/tt&amp;gt;
 * object for each call.   Using this method is likely to have comparable
 * cost to using the like-named field.  (Unlike this method, the field does
 * not provide type safety.)
 *
 * @param &amp;lt;T&amp;gt; type of elements, if there were any, in the list
 * @return an empty immutable list
 *
 * @see #EMPTY_LIST
 * @since 1.5
 */
@SuppressWarnings(&quot;unchecked&quot;)
public static final &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; emptyList() {
    return (List&amp;lt;T&amp;gt;) EMPTY_LIST;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;EMPTY_LIST 멤버 변수는
&lt;code&gt;public static final List EMPTY_LIST = new EmptyList&amp;lt;&amp;gt;();&lt;/code&gt; EmptyList 클래스라는 놈으로 초기화하고 있다.&lt;/p&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;EmptyList&lt;/h2&gt;

&lt;p&gt;아래 코드가 바로 EmptyList 클래스다. &lt;code&gt;ArrayList&lt;/code&gt;와 마찬가지로 &lt;code&gt;AbstractList&lt;/code&gt;를 상속하고 있다. &lt;code&gt;add()&lt;/code&gt;와 &lt;code&gt;addAll()&lt;/code&gt; 메소드가 없는 것을 확인할 수 있다. 왜냐하면, immutable 한 list니까!&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;/**
 * @serial include
 */
private static class EmptyList&amp;lt;E&amp;gt;
    extends AbstractList&amp;lt;E&amp;gt;
    implements RandomAccess, Serializable {
    private static final long serialVersionUID = 8842843931221139166L;

    public Iterator&amp;lt;E&amp;gt; iterator() {
        return emptyIterator();
    }
    public ListIterator&amp;lt;E&amp;gt; listIterator() {
        return emptyListIterator();
    }

    public int size() {return 0;}
    public boolean isEmpty() {return true;}

    public boolean contains(Object obj) {return false;}
    public boolean containsAll(Collection&amp;lt;?&amp;gt; c) { return c.isEmpty(); }

    public Object[] toArray() { return new Object[0]; }

    public &amp;lt;T&amp;gt; T[] toArray(T[] a) {
        if (a.length &amp;gt; 0)
            a[0] = null;
        return a;
    }

    public E get(int index) {
        throw new IndexOutOfBoundsException(&quot;Index: &quot;+index);
    }

    public boolean equals(Object o) {
        return (o instanceof List) &amp;amp;&amp;amp; ((List&amp;lt;?&amp;gt;)o).isEmpty();
    }

    public int hashCode() { return 1; }

    @Override
    public boolean removeIf(Predicate&amp;lt;? super E&amp;gt; filter) {
        Objects.requireNonNull(filter);
        return false;
    }
    @Override
    public void replaceAll(UnaryOperator&amp;lt;E&amp;gt; operator) {
        Objects.requireNonNull(operator);
    }
    @Override
    public void sort(Comparator&amp;lt;? super E&amp;gt; c) {
    }

    // Override default methods in Collection
    @Override
    public void forEach(Consumer&amp;lt;? super E&amp;gt; action) {
        Objects.requireNonNull(action);
    }

    @Override
    public Spliterator&amp;lt;E&amp;gt; spliterator() { return Spliterators.emptySpliterator(); }

    // Preserves singleton property
    private Object readResolve() {
        return EMPTY_LIST;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;하지만 EMPTY_LIST.addAll() 호출이 가능하다.&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Collections.emptyList();&lt;/code&gt; 메소드로 생성한 List는 &lt;code&gt;ArrayList&lt;/code&gt;가 아니다. &lt;code&gt;AbstractList&lt;/code&gt;라는 같은 부모를 바라보고 있지만, 주석에서 설명하듯 EMPTY_LIST는 immutable한 list이기 때문에 &lt;code&gt;add()&lt;/code&gt;, &lt;code&gt;addAll()&lt;/code&gt; 메소드는 &lt;code&gt;AbstractList&lt;/code&gt;에 메소드가 호출된다.&lt;/p&gt;

&lt;h2 id=&quot;toc_4&quot;&gt;AbstractList.add(), addAll()&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;addAll()&lt;/code&gt; 메소드는 결국 아래 보이는 &lt;code&gt;add(int, E)&lt;/code&gt; 메소드를 호출하는데, 여기서 바로 &lt;code&gt;UnsupportedOperationException&lt;/code&gt;를 던진다.&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;/**
 * {@inheritDoc}
 *
 * &amp;lt;p&amp;gt;This implementation always throws an
 * {@code UnsupportedOperationException}.
 *
 * @throws UnsupportedOperationException {@inheritDoc}
 * @throws ClassCastException            {@inheritDoc}
 * @throws NullPointerException          {@inheritDoc}
 * @throws IllegalArgumentException      {@inheritDoc}
 * @throws IndexOutOfBoundsException     {@inheritDoc}
 */
public void add(int index, E element) {
    throw new UnsupportedOperationException();
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;toc_5&quot;&gt;Collections.emptyList() 만 그럴까?&lt;/h1&gt;

&lt;p&gt;아마 &lt;code&gt;Arrays.asList(T...)&lt;/code&gt; 메소드도 많이 사용할 것이다. 이 메소드 또한 &lt;code&gt;add(E)&lt;/code&gt; 메소드를 사용할 수 없다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9997F03359B084B91F&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2017-09-07 오전 8.25.45.png&quot; height=&quot;819&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;toc_6&quot;&gt;테스트&lt;/h1&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;public class CollectionTests {

    @Test(expected = UnsupportedOperationException.class)
    public void testArraysAdd() throws Exception {
        Collection&amp;lt;String&amp;gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
        list.add(&quot;d&quot;);
        fail();
    }

    @Test(expected = UnsupportedOperationException.class)
    public void testEmptyListAdd() throws Exception {
        Collection&amp;lt;String&amp;gt; list = Collections.EMPTY_LIST;
        list.add(&quot;a&quot;);
        fail();
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;toc_7&quot;&gt;결론&lt;/h1&gt;

&lt;p&gt;생각하고 쓰자.&lt;/p&gt;&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/350&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>java UnsupportedOperationException</category>
<category>list UnsupportedOperationException</category>
<category>UnsupportedOperationException</category>
<author>woniper</author>
<guid>https://blog.woniper.net/350</guid>
<comments>https://blog.woniper.net/350#entry350comment</comments>
<pubDate>Thu, 07 Sep 2017 08:30:15 +0900</pubDate>
</item>
<item>
<title>TV가 나를 프로그래밍한다고?</title>
<link>https://blog.woniper.net/349</link>
<description>&lt;p&gt;&amp;nbsp;&amp;nbsp; 약 3년 전쯤 스타트업 회사에 입사하면서 나 스스로 약속한 게 한가지 있다.&lt;/p&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;TV 보지 않기&lt;/h2&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp; 보통 회사에 다니면 하루 일정 프레임은 비슷할 거 같다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;아침에 일어나 출근 준비를 한다.&lt;/li&gt;
&lt;li&gt;회사에 출근한다.&lt;/li&gt;
&lt;li&gt;일한다.&lt;/li&gt;
&lt;li&gt;퇴근한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp; 나는 TV 보는 것을 좋아했다. 정확히는 습관적으로 봤다고 하는 게 맞을 거 같다.
아침에 일어나자마자 TV를 켜고 출근 준비를 한다. 퇴근 후 아무 생각 없이 TV를 켠다. 주말은 어떨까? 약속 없이 집에만 있는 날은 정말 일어나서 잠들기 전까지 TV를 끌 생각이 없었다. 볼 게 없어도 켜놓았다.&lt;/p&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;무엇보다 TV가 먼저&lt;/h2&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp; 이렇게 종일 TV를 켜 놓으건 문제가 있었다. 할 일이 있어도 하지 않고 누워서 TV만 본다. 예를 들면 오늘은 카페 가서 어떤 공부를 하기로 다짐하고 TV를 본다. TV를 보며 &lt;code&gt;아 공부해야 되는데&lt;/code&gt;라며 걱정만 한다. 해야 된다고 걱정만 하고 하지 않는 내 모습이 너무 한심했다.&lt;/p&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;유선 케이블 차단&lt;/h2&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp; 물리적으로 TV를 보지 않는 환경을 만들기 위해서 TV 유선 케이블과 전원을 빼버렸다. 처음엔 습관적으로 리모컨에 손이 갔지만, 익숙해 질수록 장점이 많았다.&lt;/p&gt;

&lt;h3 id=&quot;toc_3&quot;&gt;온전히 내 시간&lt;/h3&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp; TV를 보던 시간이 그대로 내 시간이었다. 물론 TV를 보는 시간도 내 시간이었지만, 나에게 투자할 시간이 생겼다. 자연스럽게 책 읽는 시간이 늘었고, 카페 가서 공부하는 시간도 늘었다.&lt;/p&gt;

&lt;h3 id=&quot;toc_4&quot;&gt;스스로 생각하기&lt;/h3&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp; 스스로 생각하고, 고민하는 시간이 늘었다. &lt;a href=&quot;http://www.yes24.com/24/goods/23161141?scode=029&quot;&gt;소프트 스킬&lt;/a&gt;이라는 책에 이런 문장이 나온다. &lt;code&gt;TV는 말 그대로 당신을 프로그래밍한다.&lt;/code&gt; TV 프로그램이 나에게 어떤 악영향을 미치는지는 잘 모르겠지만, 확실한 건 TV는 눈으로 보고 뇌에 (좋지 않은) 데이터를 입력하는 행위인데, TV를 보지 않고 스스로 생각하고 고민하는 시간이 생긴 건 확실하다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;좋지 않은 생각과 고민은?(ㅋㅋ)  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;toc_5&quot;&gt;youtube&lt;/h3&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp; 부작용이 하나 있다. 다른 매체를 통해 동영상을 보기 시작했다. 요즘은 youtube를 많이 본다. 이것도 TV처럼 중독이 되기 때문에 관심 있는 채널을 구독해 필요한 동영상을 본다. 부작용이라고 표현했지만, TV 프로그램보다 훨씬 유익하고 도움 되는 동영상이 많다. 나의 예로 운동을 배우기 위한 수단 이기도 하다.  &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;과하면 youtube도 악.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;toc_6&quot;&gt;시간 활용하기&lt;/h2&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp; 사실 TV를 보지 않겠다고 다짐한 가장 큰 이유는 공부할 시간을 확보하기 위해서다. TV 보는 시간만 줄였는데 많은 시간이 생겼다. 하지만 문제는 나 스스로 그 시간을 &lt;code&gt;잘&lt;/code&gt; 활용하는 방법은 다른 이야기다. 나름대로 공부할 시간과 휴식 시간을 잘 배분해서 활용하려 노력하지만 아직까지 잘 안되는건 사실이다. 나는 기계가 아니기 때문에 기계 처럼 1분 1초를 정확히 내가 원하는 일에 쓰기는 쉽지 않았다. 그래도 확실한건 나에게 줄 수 있는 물리적인 시간이 많이 생겼다.&lt;/p&gt;&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/349&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>이야기</category>
<author>woniper</author>
<guid>https://blog.woniper.net/349</guid>
<comments>https://blog.woniper.net/349#entry349comment</comments>
<pubDate>Thu, 24 Aug 2017 07:22:49 +0900</pubDate>
</item>
<item>
<title>객체지향의 사실과 오해</title>
<link>https://blog.woniper.net/348</link>
<description>&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:292px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/2660A04A5952D61B18&quot; filemime=&quot;image/jpeg&quot; filename=&quot;51040273.jpg&quot; height=&quot;400&quot; width=&quot;292&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;객체지향은 어떻게 공부해야 할까? &lt;br /&gt;
항상 고민이다. 객체지향 관련 책도 별로 없을뿐더러, 연습 방법이 명확하지 않다. 디자인 패턴이나, SOLID 원칙 같은 패턴을 이해해도 실제 코드에 적용하기 쉽지 않다. 개인적으로 여전히 이 문제는 해결되지 않았지만, 객체지향에 대한 시각과 어떻게 객체지향 설계 연습을 할 수 있을지 길을 열어주는 책이다.&lt;br /&gt;
&amp;nbsp;&amp;nbsp;우리는&amp;nbsp;흔히 객체지향 언어 기본서를 보며 객체지향 문법(?)에 대해 배운다. 예를 들면 상속, 인터페이스, 다형성 등. 그런데 이런 기본서에는 객체지향 이야기를 하며&amp;nbsp;실세계의 모든 것을 객체로 바라본다고 이야기한다. 틀린 말은 아니지만, 좀 더 정확히 객체지향을 다른 관점에서 바라볼 필요가 있다는 것을 제시하고 다양한 시각으로 객체지향에 관해서 설명하고 생각하게 한다.
분량도 그렇게 많지 않고, 객체지향 언어를 사용해본 개발자라면 쉽게 읽을 수 있다.&lt;/p&gt;&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/348&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>책소개</category>
<category>객체지향</category>
<category>객체지향의 사실과 오해</category>
<author>woniper</author>
<guid>https://blog.woniper.net/348</guid>
<comments>https://blog.woniper.net/348#entry348comment</comments>
<pubDate>Wed, 28 Jun 2017 07:06:13 +0900</pubDate>
</item>
<item>
<title>Spring Data REST #3 내부 동작</title>
<link>https://blog.woniper.net/347</link>
<description>&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/ssusere4d67c/booting-spring-data-rest&quot;&gt;발표자료 Booting Spring Data REST&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/woniper/todolist-spring-data-rest&quot;&gt;Spring Data REST 예제&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://blog.woniper.net/345&quot;&gt;Spring Data REST #1 Introduction&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://blog.woniper.net/346&quot;&gt;Spring Data REST #2 동작 원리&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://woniperstory.tistory.com/admin/entry/post&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Spring Data REST #3 내부 동작&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;정말 Repository Interface로만 API가 동작할까?  당연히 Repository Interface만 있다고 해서 API가 동작하는 건 아니다. &lt;br /&gt;
&amp;nbsp;&amp;nbsp;우리가 Spring MVC를 사용해서 Controller를 만들어서 API를 만들듯이, Spring Data REST에는 이미 만들어진 Controller가 존재한다. 차이점이 있다면, 기존에 만들던 Controller와는 조금 다른 Spring Data REST만의 Controller를 만든다.&lt;/p&gt;

&lt;h1 id=&quot;toc_0&quot;&gt;@RepositoryRestController&lt;/h1&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;아마도 Spring MVC를 최근까지 사용해본 개발자라면 Controller를 만들기 위해서 &lt;code&gt;@Controller&lt;/code&gt; 또는 &lt;code&gt;@RestController&lt;/code&gt; 애노테이션을 사용해서 Controller를 만들었을 것이다.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;Spring Data REST에서는 &lt;code&gt;@RepositoryRestController&lt;/code&gt; 애노테이션을 제공한다. 기존 Controller 역할을 하는 애노테이션과 차이점이 있다면, &lt;code&gt;@RepositoryRestController&lt;/code&gt;는 Repository interface에서 제공되는 API를 확장하기 위한 Controller라고 말하고 싶다.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;사실 Spring MVC Controller(@Controller, @RestController)와 Spring Data REST Controller(@RepositoryRestController)는 동일하게 동작한다.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;http://blog.woniper.net/346&quot;&gt;Spring Data REST #2 동작 원리&lt;/a&gt;에서 설명했지만, Spring Data REST는 Spring MVC + Spring Data가 결합된 프로젝트다. 결국 &lt;code&gt;@RepositoryRestController&lt;/code&gt;도 Spring MVC에 의해 동작한다는 것이다.&lt;/p&gt;

&lt;h1 id=&quot;toc_1&quot;&gt;Spring MVC Architecture&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;@RepositoryRestController&lt;/code&gt;도 동일하게 동작한다는 것을 이해하기 위해서 먼저 Spring MVC가 Controller를 어떻게 찾아 실행하는지 알아야 한다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/23087C395944C01B12&quot; filemime=&quot;image/jpeg&quot; filename=&quot;그림1.png&quot; height=&quot;488&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/DispatcherServlet.html&quot;&gt;DispatcherServlet&lt;/a&gt;&lt;/h2&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    boolean multipartRequestParsed = false;

    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

    try {
        ModelAndView mv = null;
        Exception dispatchException = null;

        try {
            // 생략...
            mappedHandler = getHandler(processedRequest);
            if (mappedHandler == null || mappedHandler.getHandler() == null) {
                noHandlerFound(processedRequest, response);
                return;
            }

            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

            // 생략...

            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

            // 생략...
        }
        catch (Exception ex) {
            dispatchException = ex;
        }
        catch (Throwable err) {
            // 생략...
        }
            // 생략...
    }
    catch (Exception ex) {
            // 생략...
    }
    catch (Throwable err) {
            // 생략...
    }
    finally {
            // 생략...
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/DispatcherServlet.html&quot;&gt;DispatcherServlet&lt;/a&gt;의 일부 코드인 doDispatch 메소드이며, DispatcherServlet은 J2EE 패턴 중 하나인 &lt;a href=&quot;http://www.oracle.com/technetwork/java/frontcontroller-135648.html&quot;&gt;FrontController&lt;/a&gt; 패턴의 구현체다.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;이 코드에서 설명하고자 하는 부분은 바로 &lt;code&gt;HandlerMapping&lt;/code&gt;, &lt;code&gt;HandlerAdapter&lt;/code&gt;다.
&lt;code&gt;getHandler&lt;/code&gt; 메소드를 호출해 &lt;code&gt;HandlerExecutionChain&lt;/code&gt; 객체를 받고, &lt;code&gt;getHandlerAdapter&lt;/code&gt; 메소드를 호출해 &lt;code&gt;HandlerAdapter&lt;/code&gt; 객체를 받는다.&lt;/p&gt;

&lt;h3 id=&quot;toc_3&quot;&gt;&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/HandlerMapping.html&quot;&gt;HandlerMapping&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;HandlerMapping&lt;/code&gt; 클래스는 우리가 만든 Controller(@Controller, @RestController, @RepositoryRestController)를 찾는 역할을한다.
Spring MVC 3.1 버전 이후로 기본 HandlerMapping 구현체는 &lt;code&gt;RequestMappingHandlerMapping&lt;/code&gt;이 기본 HandlerMapping으로 설정된다.&lt;/p&gt;

&lt;h3 id=&quot;toc_4&quot;&gt;&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/HandlerAdapter.html&quot;&gt;HandlerAdapter&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;HandlerAdapter&lt;/code&gt; 클래스는 &lt;code&gt;HandlerMapping&lt;/code&gt;으로 찾은 Controller를 실행하는 역할을 한다.
Spring MVC 3.1 버전 이후로 기본 HandlerAdapter 구현체는 &lt;code&gt;RequestMappingHandlerAdapter&lt;/code&gt;이 기본 HandlerMapping으로 설정된다.&lt;/p&gt;

&lt;h3 id=&quot;toc_5&quot;&gt;&lt;a href=&quot;http://docs.spring.io/spring-data/rest/docs/current/api/org/springframework/data/rest/webmvc/RepositoryRestHandlerMapping.html&quot;&gt;RepositoryRestHandlerMapping&lt;/a&gt;, &lt;a href=&quot;http://docs.spring.io/spring-data/rest/docs/current/api/org/springframework/data/rest/webmvc/RepositoryRestHandlerAdapter.html&quot;&gt;RepositoryRestHandlerAdapter&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;Spring Data REST에서 HandlerMapping의 구현체는 &lt;code&gt;RepositoryRestHandlerMapping&lt;/code&gt;이며, HandlerAdapter 구현체는 &lt;code&gt;RepositoryRestHandlerAdapter&lt;/code&gt;다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/255461355944C03924&quot; filemime=&quot;image/jpeg&quot; filename=&quot;그림3.png&quot; height=&quot;308&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그렇다면, 지금까지 설명한 이 구현체들은 어떻게 Controller를 찾을까?&lt;/p&gt;

&lt;h4 id=&quot;toc_6&quot;&gt;RequestMappingHandlerMapping.isHandler 메소드&lt;/h4&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Override
protected boolean isHandler(Class&amp;lt;?&amp;gt; beanType) {
    return (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||
            AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;toc_7&quot;&gt;RepositoryRestHandlerMapping.isHandler 메소드&lt;/h4&gt;

&lt;div&gt;&lt;pre&gt;&lt;code class=&quot;language-none&quot;&gt;@Override
protected boolean isHandler(Class&amp;lt;?&amp;gt; beanType) {
    return AnnotationUtils.findAnnotation(beanType, RepositoryRestController.class) != null;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;HandlerMapping 구현체의 isHandler 메소드는 요청 URL에 해당하는 Controller가 있는지 체크하기 위한 메소드다. 많이 보던 애노테이션 아닌가? 애노테이션 설명은 생략하겠다.&lt;/p&gt;&lt;p&gt;그런데, 궁금한점이 있다. Spring Data REST를 사용하면 기존에 사용하던 Spring MVC의 Controller는 사용하지 못할까? 답은 아니다. 당연히 사용가능하다. 그 이유는 바로 &lt;code&gt;DispatcherServlet&lt;/code&gt;은 HandlerMapping과 HandlerAdapter를 List(&lt;code&gt;List&amp;lt;HandlerMapping&amp;gt;&lt;/code&gt;, &lt;code&gt;List&amp;lt;HandlerAdapter&amp;gt;&lt;/code&gt;)로 포함하고 있다. 때문에 요청한 URL에 해당하는 HandlerMapping을 찾아 HandlerAdapter에 전달한다.&lt;/p&gt;&lt;p&gt;여기까지가 @RepositoryRestController를 찾아 동작할 수 있었던 이유다.&lt;/p&gt;

&lt;h2 id=&quot;toc_8&quot;&gt;Repository*Controller&lt;/h2&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;진짜 우리가 궁금한건 어떻게 Controller를 찾는게 아니였다. Reository interface만으로 API가 동작할 수 있었던 이유가 궁금했던 것이다.
눈치 챘겠지만, Repository interface가 API로 동작 가능하도록 이미 만들어진 @RepositoryRestController가 있다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/24619E475944C0A40E&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2017-06-17 오후 2.39.27.png&quot; height=&quot;132&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;다양한 @RepositoryRestController 구현체들이 존재한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-data/rest/docs/current/api/org/springframework/data/rest/webmvc/RepositoryController.html&quot;&gt;RepositoryController&lt;/a&gt; : &lt;q&gt;/&lt;/q&gt; URL 실행&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;RepositoryEntityController&lt;/a&gt; : &lt;q&gt;/{repository}&lt;/q&gt; URL 실행&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;RepositoryPropertyReferenceController&lt;/a&gt; : &lt;q&gt;/{repository}/{id}/{property}&lt;/q&gt; URL 실행&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;RepositorySearchController&lt;/a&gt; : &lt;q&gt;/{repository}/search/{search}&lt;/q&gt; URL 실행&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;크게 4개 Controller가 이미 구현되어 있다.&lt;/p&gt;

&lt;h1 id=&quot;toc_9&quot;&gt;마무리&lt;/h1&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;기본 사용방법 부터 구조까지 자세히 설명하고 싶었는데, 잘 설명하지 못한거 같다. 아직 Spring Data REST를 깊게 이해하지 못한걸지도 모르겠다. 좀 더 공부하며 어디에, 어떻게 적용하면 좋을지 고민해봐야겠다.
&amp;nbsp;&amp;nbsp;추가로 궁금한 부분 질문 또는 토론이 필요하다면 언제든지 환영합니다.&lt;/p&gt;&lt;div style=&quot;text-align:center;margin:10px 0 10px 0;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;
    google_ad_client = &quot;ca-pub-3042864878921693&quot;;
    google_ad_slot = &quot;1345938561&quot;;
    google_ad_width = 336;
    google_ad_height = 280;
&lt;/script&gt;
&lt;!-- tistory_pc --&gt;
&lt;script type=&quot;text/javascript&quot;
src=&quot;//pagead2.googlesyndication.com/pagead/show_ads.js&quot;&gt;
&lt;/script&gt;&lt;/div&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- tistory1 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-3042864878921693&quot;
     data-ad-slot=&quot;7392472166&quot;
     data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.woniper.net/347&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>Spring Data</category>
<category>Spring Data REST</category>
<author>woniper</author>
<guid>https://blog.woniper.net/347</guid>
<comments>https://blog.woniper.net/347#entry347comment</comments>
<pubDate>Sat, 17 Jun 2017 14:42:31 +0900</pubDate>
</item>
<item>
<title>Spring Data REST #2 동작 원리</title>
<link>https://blog.woniper.net/346</link>
<description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/ssusere4d67c/booting-spring-data-rest&quot;&gt;발표자료 Booting Spring Data REST&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/woniper/todolist-spring-data-rest&quot;&gt;Spring Data REST 예제&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.woniper.net/345&quot;&gt;Spring Data REST #1 Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.woniper.net/346&quot;&gt;Spring Data REST #2 동작 원리&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://woniperstory.tistory.com/admin/entry/post&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Spring Data REST #3 내부 동작&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- 

* [Spring Data REST #3 여러 가지 기능]()
* [Spring Data REST #4 Security]()
* [Spring Data REST #5 Customizing]()
* [Spring Data REST #6 소스를 까보자!]()
--&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;http://blog.woniper.net/345&quot;&gt;Introduction&lt;/a&gt;에서 Spring D