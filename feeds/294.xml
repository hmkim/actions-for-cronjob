<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by 남정현 on Medium]]></title>
        <description><![CDATA[Stories by 남정현 on Medium]]></description>
        <link>https://medium.com/@rkttu?source=rss-421917445ce9------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*6pqm8FG3wVckCsjdptvgCg.jpeg</url>
            <title>Stories by 남정현 on Medium</title>
            <link>https://medium.com/@rkttu?source=rss-421917445ce9------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Sun, 12 May 2019 18:17:07 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@rkttu" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[C#으로 만드는 네이티브 DLL]]></title>
            <link>https://medium.com/rkttu/build-native-dll-with-csharp-293c79a41fb4?source=rss-421917445ce9------2</link>
            <guid isPermaLink="false">https://medium.com/p/293c79a41fb4</guid>
            <category><![CDATA[corert]]></category>
            <category><![CDATA[dotnet]]></category>
            <category><![CDATA[native]]></category>
            <category><![CDATA[csharp]]></category>
            <category><![CDATA[dll]]></category>
            <dc:creator><![CDATA[남정현]]></dc:creator>
            <pubDate>Sun, 10 Feb 2019 07:20:09 GMT</pubDate>
            <atom:updated>2019-02-10T07:20:09.687Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*k_jCXucLMo4RRi2c.jpg" /><figcaption>이미지 출처: <a href="http://scandinavianlibrary.org/">http://scandinavianlibrary.org/</a></figcaption></figure><p>C#과 .NET 기술은 계속해서 발전해나가고 있습니다. 여러가지 기술들이 있을 수 있겠지만, 저 개인적으로는 C#을 처음 접한 이후로 지금까지 중요하게 생각하는 것이 상호 연동 기술에 관한 것입니다.</p><p>.NET Core는 예전의 .NET Framework와는 달리 처음부터 Windows, Linux, macOS에 대해 x86, x64, 그리고 ARM32, ARM64까지 폭넓은 아키텍처와 OS를 공식적인 지원 대상으로 정하여 개발을 계속 이어나가고 있습니다. 그 덕분에 더 이상 C#은 Windows 전용이라는 틀은 확실한 옛말이 되어가고 있습니다.</p><p>그리고 많은 사람들에게 알려진것처럼 .NET Core 3.0은 이전의 .NET Framework의 주요 기능이었던 Windows Forms와 Windows Presentation Foundation 까지 이어받게되어 완전한 프로그래밍 프레임워크로 거듭나고 있습니다.</p><h3>Ahead-of-Time에 대하여</h3><p>이와 같은 보편적인 의미에서의 상호 연동만이 아니라, 더 작고 특이한 주제인 Ahead-of-Time (이하 AOT)에 대한 기술도 같이 개발이 진행되고 있습니다.</p><p>이제까지 .NET은 Java와 마찬가지로 Just-in-Time (이하 JIT) 방식으로 실행될 때 최고의 성능을 낼 수 있도록 개발되어왔습니다. 대체로 JIT 방식으로 실행할 때 .NET 입장에서 다른 언어를 바라볼 때의 접근은 쉽습니다. 그러나 그 반대로의 접근은 매우 많은 비효율이 따릅니다.</p><p>예를 들어, .NET과 아무런 관련이 없는 Rust 같은 프로그래밍 언어에서 리눅스나 macOS에서 Mono나 .NET Framework의 지원 없이는 .NET이 만든 DLL을 가져다 쓸 방법이 없습니다. 물론 양쪽 프레임워크 모두 C/C++ SDK를 이용하여 CLR을 초기화할 수 있으며, 이 방식을 택하는 경우 .NET 기술만을 사용할 때와는 달리 더 넓은 기술적 선택이 가능합니다. 그러나 당연하게도 많은 오버헤드를 수반합니다.</p><p>그 외에도, 단순히 CLR을 초기화한데서 끝나는 것이 아니라 성능을 최대한 이끌어내기 위해서는 NGEN (Native Image Generation) 등의 작업을 선행하여 Cold Boot로 인한 시간 손해를 사전에 만회해야 하며, 필요한 DLL 등이 있다면 빠짐없이 모두 찾아주어야 할 것입니다. 이 정도면 생각만해도 꽤 골치아픈 작업임에 틀림 없습니다.</p><p>그런데 만약 이 모든 작업을 한 번에 미리 처리해둘 수 있다면 어떨까요? 런타임 중에 확장성을 고려하여 동적인 기능을 사용하는 아키텍처가 아니라면 꽤 훌륭한 접근이 될 것입니다. 덤으로, 이렇게 만들어지는 DLL을 사용하는 주체는 .NET Core에 대해 아무런 정보가 없다고 하더라도 필요한 초기화 작업을 자동으로 대행해준다면 더할 나위 없이 이상적일 것입니다.</p><p>참고로 이런 일을 해주는 도구는 .NET Framework 시절에도 Code Obfuscation이나 Application Virtualization의 명목으로 수많은 상용 도구들이 존재했었습니다. 그러나 당연히 Windows OS에만 국한되는 기술이었고, 대개는 Microsoft가 직접 보증하는 기술이 아니었으며, 지속적인 라이선스 갱신을 필요로 하는 비싼 기술들이었습니다.</p><p>오늘 아티클에서 다루려고 하는 것은 방금 이야기한 것을 포함하지 않으며 온전히 .NET Core 기반의 애플리케이션을 어떻게 Native Application으로 만들 수 있는가에 대한 이야기만을 다룹니다.</p><h3>오늘의 실습을 위한 배경 지식, rundll32</h3><p>그래서 이번 아티클에서는 네이티브 DLL을 만들어봅니다. 그것도 Windows OS와 직접 소통하는 네이티브 DLL을 C#으로 만들어 보는 것입니다. 이렇게 만든 DLL은 다른 컴퓨터로 복사해서 얼마든지 실행해볼 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/359/1*FP14HDixqU_DUlRphGPmDg.png" /><figcaption><a href="https://telcontar.net/store/archive/CrashGallery/">https://telcontar.net/store/archive/CrashGallery/</a></figcaption></figure><p>기억 속의 rundll32.exe는 왜 인지는 모르겠지만 위와 같은 시스템 오류 대화 상자에서 종종 등장하던 불친절한 느낌의 프로그램 파일 이름이었습니다. 도대체 뭐에 쓰이는 프로그램이길래 저렇게 나타나는걸까요?</p><p>이미지의 출처에도 나와있듯, 조이스틱을 연결하고 조이스틱 설정 제어판 애플릿을 들어갔더니 저런 오류가 나타났다고 했습니다. 즉, Windows 10에새 새로 도입된 설정 앱 이전까지 정말 많이 쓰였던 제어판의 설정 애플릿 프로그램 (CPL) 파일이나 하드웨어 드라이버 따위를 설치하기 위하여 사용되던 내장 플러그인 아키텍처에서 중요한 역할을 수행하는 모듈이 바로 rundll32.exe입니다.</p><p>그런데 rundll32.exe는 DLL 안에 무슨 함수가 어떻게 들어있는지 알아내고 저렇게 찾아내는걸까요? 궁금해서 조금 찾아보니 친절하게도 아래 링크와 같은 Knowledge Base 문서가 있었습니다.</p><p><a href="https://support.microsoft.com/en-us/help/164787/info-windows-rundll-and-rundll32-interface">https://support.microsoft.com/en-us/help/164787/info-windows-rundll-and-rundll32-interface</a></p><p>원리는 매우 단순합니다. 아래와 같이 생긴 함수들이 외부로 Export 되어있다는 것을 전제로 하는 것입니다.</p><pre>// Non-Unicode 버전<br>void CALLBACK<br>  EntryPoint(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);</pre><pre>// Unicode 버전<br>void CALLBACK<br>  EntryPointW(HWND hwnd, HINSTANCE hinst, LPWSTR lpszCmdLine, int nCmdShow);</pre><p>위의 함수 원형을 분석해보면, CALLBACK 매크로는 __stdcall Calling Convention을 사용하도록 되어있습니다. 그리고 각 매개 변수는 다음과 같은 의미를 가지고 있습니다.</p><p>참고로 Windows NT 기반의 OS는 함수 이름뒤에 W 접미사를 붙여서 유니코드 버전의 함수를 먼저 찾도록 설계되어있습니다. 실패하는 경우 비 유니코드 버전의 함수를 대신 사용합니다. 이에 따라 lpszCmdLine 파라미터의 타입도 달라지게 됩니다. 바꿔 말하면, 항상 유니코드 버전의 함수를 먼저 찾는다고 보시면 되겠습니다.</p><pre>hwnd: 부모 창 핸들<br>hinst: DLL 파일에 대한 HINSTANCE 핸들<br>lpszCmdLine: rundll32.exe로 전달된 인자들 (유니코드 버전이면 LPWSTR, 아니면 LPSTR 타입이 됨)<br>nCmdShow = CreateProcess 함수로 전달된 nCmdShow 인자값</pre><p>그러면 위의 함수가 불리도록 하려면 rundll32.exe를 어떻게 이용하면 될까요? 다음과 같은 형태가 됩니다.</p><pre>%windir%\system32\rundll32.exe &lt;dllname&gt;,&lt;entrypoint&gt; &lt;optional arguments&gt;</pre><p>dllname 부분에는 DLL 파일의 전체 경로를, entrypoint 부분에는 실행하려는 함수의 이름 (단, W 접미사 제외)을 지정합니다. 그 다음은 lpszcmdLine 파라미터로 전달하고 싶은 내용을 자유롭게 기술합니다.</p><h3>빌드 환경 준비</h3><p>우선 .NET Core 2.0 SDK를 시스템에 설치해야 합니다. Windows OS용 DLL을 만드려는 것이므로 Windows용 SDK를 설치하도록 합니다. 아래 웹 사이트에서 다운로드할 수 있습니다.</p><p><a href="https://dotnet.microsoft.com/download">Download .NET (Linux, macOS, and Windows)</a></p><p>그 다음 새 클래스 라이브러리 프로젝트를 만듭니다.</p><pre>dotnet new classlib -n rundll-sample<br>cd /d rundll-sample</pre><p>새로 만든 프로젝트에서 CoreRT를 사용할 수 있도록 Nuget 패키지를 추가합니다. 지금 추가하려는 Nuget 패키지는 아직 공식적으로 릴리스된 패키지가 아니며 별도의 사설 리포지터리에서 운영되고 있어서 따로 저장소를 추가해야 합니다.</p><pre>dotnet new nuget</pre><p>위의 명령으로 만들어진 nuget.config 파일을 열어 아래와 같이 내용을 수정합니다.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;configuration&gt;<br> &lt;packageSources&gt;<br>    &lt;!--To inherit the global NuGet package sources remove the &lt;clear/&gt; line below --&gt;<br>    &lt;clear /&gt;<br>    &lt;add key=&quot;dotnet-core&quot; value=&quot;<a href="https://dotnet.myget.org/F/dotnet-core/api/v3/index.json">https://dotnet.myget.org/F/dotnet-core/api/v3/index.json</a>&quot; /&gt;<br>    &lt;add key=&quot;nuget.org&quot; value=&quot;<a href="https://api.nuget.org/v3/index.json">https://api.nuget.org/v3/index.json</a>&quot; protocolVersion=&quot;3&quot; /&gt;<br> &lt;/packageSources&gt;<br>&lt;/configuration&gt;</pre><p>그리고 아래의 명령을 실행합니다.</p><pre>dotnet add package Microsoft.DotNet.ILCompiler -v 1.0.0-alpha-*</pre><p>이제 CoreRT의 Native Library Export 기능을 사용하기 위해서는 Foreign Function Interface (이하 FFI)를 정의해야 합니다. 이러한 종류의 인프라는 본디 Base Class Library (BCL)에 포함되어있어야 하지만, CoreRT의 Native Library 관련 기능이 최근에서야 개발되고 있기 때문에 아쉽게도 표준 .NET 스펙에 들어있지는 않습니다.</p><p>FFI 역할을 하는 클래스는 System.Runtime.InteropServices 네임스페이스를 가지고 있어야하며, 클래스의 이름은 NativeCallableAttribute 으로 약속되어있습니다. 그래서 별도의 복잡한 설정을 추가하지 않더라도 아래의 코드 파일만 프로젝트에 포함하고 있어도 됩니다.</p><pre>namespace System.Runtime.InteropServices<br>{<br>    [AttributeUsage(AttributeTargets.Method)]<br>    public sealed class NativeCallableAttribute : Attribute<br>    {<br>        public string EntryPoint;<br>        public CallingConvention CallingConvention;<br>        public NativeCallableAttribute() { }<br>    }<br>}</pre><h3>코드 작성 및 테스트</h3><p>이제 위의 어트리뷰트를 사용하는 네이티브 함수를 하나 만들것입니다. 스캐폴딩 과정에서 만들어진 Class1.cs 파일을 열어 다음과 같이 코드를 작성합니다. 외부 DLL 함수를 가져올 때와 마찬가지로 함수를 내보낼 때에도 Static 함수로 정의되어있어야 합니다. (Interop 목적의 함수는 this 포인터를 받는 것을 고려하지 않기 때문입니다.)</p><pre>using System;<br>using System.Runtime.InteropServices;</pre><pre>namespace rundll_sample {<br>    public static class Lib {<br>        [DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;MessageBoxW&quot;, ExactSpelling = true, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi)]<br>        public static extern int MessageBox(<br>            IntPtr hWnd,<br>            string lpText,<br>            string lpCaption,<br>            [MarshalAs(UnmanagedType.U4)] int uType);</pre><pre>[NativeCallable(EntryPoint = &quot;ShowMessage&quot;, CallingConvention = CallingConvention.StdCall)]<br>        public static void ShowMessageNonUnicode(IntPtr hwnd, IntPtr hinst, IntPtr lpszCmdLine, int nCmdShow) {<br>            var arguments = Marshal.PtrToStringAnsi(lpszCmdLine);<br>            MessageBox(hwnd, $&quot;Passed Argument (Non Unicode) - {arguments}&quot;, &quot;Hello, World! from CoreRT&quot;, 0);<br>        }</pre><pre>[NativeCallable(EntryPoint = &quot;ShowMessageW&quot;, CallingConvention = CallingConvention.StdCall)]<br>        public static void ShowMessageUnicode(IntPtr hwnd, IntPtr hinst, IntPtr lpszCmdLine, int nCmdShow) {<br>            var arguments = Marshal.PtrToStringUni(lpszCmdLine);<br>            MessageBox(hwnd, $&quot;Passed Argument (Unicode) - {arguments}&quot;, &quot;Hello, World! from CoreRT&quot;, 0);            <br>        }<br>    }<br>}</pre><p>앞에서 이야기한대로 유니코드 버전의 함수인 ShowMessageW 함수와 비 유니코드 버전의 함수인 ShowMessage 함수를 만들었습니다. lpszCmdLine 은 포인터로 값이 넘어오게되며, 포인터 주소에서 문자열을 어떻게 읽을지에 대해서는 Marshal 클래스의 PtrToString 함수를 사용합니다.</p><p>유니코드 버전의 함수에서는 LPWSTR 타입의 lpszCmdLine 파라미터가 넘어오게되므로 PtrToStringUni 함수를 사용하며, 비 유니코드 버전의 경우 LPSTR 타입이 사용되므로 PtrToStringAnsi 함수를 사용하여 System::String 인스턴스를 생성하게 됩니다.</p><p>여기서 lpszCmdLine 에 할당되는 메모리는 .NET Core 측이 아닌 호출자 측에서 관리하는 메모리로 여기서는 읽기만 하면 됩니다.</p><p>이제 이렇게 호출이 발생한 함수의 기능을 구현하기 위하여 Win32 API인 MessageBoxW 함수를 사용하려고 합니다. 여기서는DllImportAttribute 클래스를 사용하여 DLL을 Lazy Loading을 사용하게 됩니다. 이렇게하여 rundll32.exe로 전달된 매개 변수를 메시지 박스에 표시하게 됩니다.</p><p>위의 내용을 이제 네이티브 DLL을 만들어 테스트하는 함수를 만들어보겠습니다. build.cmd 라는 파일을 다음과 같이 만들고 실행해봅니다.</p><pre><a href="http://twitter.com/echo">@echo</a> off<br>pushd &quot;%~dp0&quot;</pre><pre>dotnet publish /p:NativeLib=Shared -r win-x64 -c Release<br>%windir%\system32\rundll32.exe .\bin\Release\netstandard2.0\win-x64\publish\rundll-sample.dll,ShowMessage 안녕</pre><pre>:exit<br>popd<br><a href="http://twitter.com/echo">@echo</a> on</pre><p>최초 실행 시에는 IL Compiler 패키지를 받아오는 과정에서 시간이 오래 소요될 수 있고, 첫 Static Link 시도 때에도 시간이 많이 필요할 수 있습니다. 정상적으로 명령이 실행되면 아래 그림과 같이 유니코드 버전의 함수가 정상적으로 실행되는 것을 볼 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/220/1*k3iijjQr8-wgp0DgD47Pow.png" /></figure><p>NT 버전의 rundll32.exe는 ShowMessage라는 인자를 지정했을 때 자동으로 유니코드 버전의 함수를 찾기 위하여 W 접미사를 붙인다는 스펙이 있었는데, 그대로 동작하는 것을 볼 수 있습니다.</p><p>만들어진 DLL 파일의 크기를 확인해보기 위하여 폴더창으로 열어보면 4MB 내외의 단일 DLL 파일이 만들어진 것을 볼 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/786/1*NQ8RMkdLUgfvJOKs9qHjgg.png" /><figcaption>생성된 DLL 파일의 크기가 4MB 내외인 것을 볼 수 있습니다.</figcaption></figure><p>이제 네이티브 라이브러리가 의도한대로 잘 만들어졌는지 확인해보겠습니다. 저는 Dependency Walker라는 유틸리티를 사용하여 확인해보려고 합니다.</p><p>이 유틸리티는 구 버전의 Windows SDK 또는 Visual Studio에 기본 탑재되어있던 유틸리티였으며, DLL들이 참조하는 함수들의 관계를 시각적으로 보여줍니다.</p><p>설치를 위하여 Chocolatey Package Manager를 사용합니다. Chocolatey Package Manager의 설치와 사용은 <a href="https://chocolatey.org/install">https://chocolatey.org/install</a> 을 참고하세요.</p><pre>choco install dependencywalker -y</pre><p>그 다음 만들어진 DLL 파일을 열기 위하여 프로젝트 디렉터리 아래의 .\bin\Release\netstandard2.0\win-x64\publish\rundll-sample.dll 파일을 Dependency Walker로 열어보겠습니다. 처음에는 시스템 DLL 간의 관계 파악에 드는 시간이 긴 편이므로 기다립니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/946/1*13wYW57UNnydi3pWljlE7A.png" /><figcaption>Dependency Walker로 DLL 파일을 열어본 모습</figcaption></figure><p>위의 화면에 나타난것처럼 Export 영역에 ShowMessage 와 ShowMessageW 함수가 노출된 것을 볼 수 있습니다. 반면 Import 영역에는 DllImportAttribute 로 참조한 내역이 표시되지는 않습니다. 이는 Win32 API인 LoadLibrary 함수를 사용하여 Lazy DLL Loading을 사용한 것과 비슷한 것입니다.</p><h3>노트</h3><p>앞의 dotnet publish 명령에서는 Shared 라이브러리로 만드는 기능을 예로 들었는데, C/C++ 컴파일러나 Rust 컴파일러등에서 이용할 목적으로 정적 라이브러리로 컴파일하는 기능도 있습니다.</p><pre>dotnet publish /t:LinkNative /p:NativeLib=Static -c Release -r win-x64</pre><p>이렇게 만들어진 .lib 파일을 Linker 등에 추가하고, 적절한 C/C++ 헤더를 정의하여 사용할 수 있습니다. 관련된 내용은 <a href="https://medium.com/@chyyran/calling-c-natively-from-rust-1f92c506289d">https://medium.com/@chyyran/calling-c-natively-from-rust-1f92c506289d</a> 의 내용을 참고하시기 바랍니다.</p><h3>제약 사항</h3><p>CoreRT는 아직 개발 중인 기술입니다. 그리고 실용적인 애플리케이션을 만들기 위해서는 UI 프레임워크를 포함해야 하지만, Windows Forms와 Windows Presentation Framework를 실행하기 위해 필요한 기능이 아직 제대로 작동하지 않습니다. 예를 들면 다음과 같은 이슈가 있습니다.</p><ul><li><a href="https://github.com/dotnet/corert/issues/4219">COM Interop Guidance · Issue #4219 · dotnet/corert</a></li><li><a href="https://github.com/dotnet/corert/issues/6359">Does IL compiler support .NET Core 3.0 WinForms? · Issue #6359 · dotnet/corert</a></li></ul><p>그리고 리눅스에서는 Shared Library를 만들어 사용하는 것에 제한이 있으며 해결이 필요한 이슈입니다.</p><p><a href="https://github.com/dotnet/corert/issues/4988">Fix building Ubuntu shared libraries · Issue #4988 · dotnet/corert</a></p><p>하지만 계속해서 활발하게 개발이 이루어지고 있으므로 첫 프리뷰 버전이 출시될 무렵에는 본격적인 사용을 검토해볼 수 있을 것 같습니다.</p><h3>더 읽어볼 내용</h3><ul><li>Calling C# natively from Rust — <a href="https://medium.com/@chyyran/calling-c-natively-from-rust-1f92c506289d">https://medium.com/@chyyran/calling-c-natively-from-rust-1f92c506289d</a></li><li>CoreRT Native Library Sample — <a href="https://github.com/dotnet/corert/tree/master/samples/NativeLibrary">https://github.com/dotnet/corert/tree/master/samples/NativeLibrary</a></li><li>Optimizing programs targeting CoreRT — <a href="https://github.com/dotnet/corert/blob/master/Documentation/using-corert/optimizing-corert.md">https://github.com/dotnet/corert/blob/master/Documentation/using-corert/optimizing-corert.md</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=293c79a41fb4" width="1" height="1"><hr><p><a href="https://medium.com/rkttu/build-native-dll-with-csharp-293c79a41fb4">C#으로 만드는 네이티브 DLL</a> was originally published in <a href="https://medium.com/rkttu">남정현의 블로그</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[예. 맞습니다. 이 글을 작성한 것의 목적은 코드 수정을 최소화하면서 컨테이너화를 할 수 있는 방법을 보이기 위함이었기 때문에, 말씀하신것처럼 새로 만드는 애플리케이션이 처음부터…]]></title>
            <link>https://medium.com/@rkttu/%EC%98%88-%EB%A7%9E%EC%8A%B5%EB%8B%88%EB%8B%A4-%EC%9D%B4-%EA%B8%80%EC%9D%84-%EC%9E%91%EC%84%B1%ED%95%9C-%EA%B2%83%EC%9D%98-%EB%AA%A9%EC%A0%81%EC%9D%80-%EC%BD%94%EB%93%9C-%EC%88%98%EC%A0%95%EC%9D%84-%EC%B5%9C%EC%86%8C%ED%99%94%ED%95%98%EB%A9%B4%EC%84%9C-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%ED%99%94%EB%A5%BC-%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%84-%EB%B3%B4%EC%9D%B4%EA%B8%B0-%EC%9C%84%ED%95%A8%EC%9D%B4%EC%97%88%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%97%90-%EB%A7%90%EC%94%80%ED%95%98%EC%8B%A0%EA%B2%83%EC%B2%98%EB%9F%BC-%EC%83%88%EB%A1%9C-%EB%A7%8C%EB%93%9C%EB%8A%94-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%B4-%EC%B2%98%EC%9D%8C%EB%B6%80%ED%84%B0-d0e08ab74758?source=rss-421917445ce9------2</link>
            <guid isPermaLink="false">https://medium.com/p/d0e08ab74758</guid>
            <dc:creator><![CDATA[남정현]]></dc:creator>
            <pubDate>Wed, 28 Nov 2018 11:44:12 GMT</pubDate>
            <atom:updated>2018-11-28T11:44:12.005Z</atom:updated>
            <content:encoded><![CDATA[<p>예. 맞습니다. 이 글을 작성한 것의 목적은 코드 수정을 최소화하면서 컨테이너화를 할 수 있는 방법을 보이기 위함이었기 때문에, 말씀하신것처럼 새로 만드는 애플리케이션이 처음부터 컨테이너화될 것을 염두에 둔다면, 서비스로 만들어 힘들게 돌아갈 필요가 없습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d0e08ab74758" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Windows Service를 컨테이너로 옮기기]]></title>
            <link>https://medium.com/rkttu/move-windows-service-to-container-74043491f9ff?source=rss-421917445ce9------2</link>
            <guid isPermaLink="false">https://medium.com/p/74043491f9ff</guid>
            <category><![CDATA[services]]></category>
            <category><![CDATA[containerization]]></category>
            <category><![CDATA[docker]]></category>
            <category><![CDATA[windows]]></category>
            <category><![CDATA[containers]]></category>
            <dc:creator><![CDATA[남정현]]></dc:creator>
            <pubDate>Tue, 27 Nov 2018 11:46:25 GMT</pubDate>
            <atom:updated>2018-11-27T11:46:25.258Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/620/0*Tklya9sc7zQcmHHI.jpg" /><figcaption>Windows, Docker, Container</figcaption></figure><p>독립적인 서버에서 실행되던 애플리케이션을 컨테이너로 옮기는 작업은 매우 많은 고민을 필요로 합니다. 이 때의 고민들은 아키텍처 측면에서의 고민도 있겠지만, 실질적인 문제를 포함하는 경우도 있습니다.</p><p>이번에 소개하려는 내용은 컨테이너로 옮기기 까다로운 유형에 해당하는 Windows Service 타입의 서버 애플리케이션을 옮기는 방법입니다. 콘솔이나 RDP 등을 통한 사용자의 상호작용을 필요로 하지 않는 서버의 경우 오늘 소개하는 내용을 통하여 쉽게 컨테이너로 서버를 패키징할 수 있을 것입니다.</p><h3>준비하기</h3><p>Windows Serer 2016에 이어서 차기 LTSC 버전의 서버 운영 체제로 Windows Server 2019가 출시되었습니다. 여기에 맞추어 이번 글에서는 Windows Server 2019 (1809)를 기준으로 내용을 설명하며, Windows 10 2018년 10월 업데이트 (17763 빌드)를 설치한 상태에서 테스트해보실 수 있는 내용입니다.</p><p>그리고 빠른 실습을 위하여 Windows Container Base Image를 미리 다운로드받아두시는 것을 추천합니다. 이미지 파일의 크기가 매우 크기 때문에, 별도 요금이 발생하지 않는 Wi-Fi 등을 이용하여 다운로드하시는 것이 좋습니다. 다음과 같이 명령을 실행합니다.</p><pre>docker pull mcr.microsoft.com/windows/servercore:1809</pre><h3>서비스를 컨테이너화하는 방법</h3><p>서버 응용프로그램을 컨테이너화하는 것은 보통 단독으로 실행되는 프로그램을 기준으로 합니다. 리눅스 및 유닉스 환경에서는 거의 모든 응용프로그램들이 그 즉시 다른 도우미 프로그램을 경유하지 않고 실행되므로 컨테이너화를 하는데 큰 고민을 할 것이 없습니다.</p><p>반면 Windows의 경우 서비스 제어 관리자 (Service Control Manager, 이하 SCM)에 의하여 백그라운드 서비스를 다루게 됩니다. 그리고 SCM이 인식할 수 있는 서비스는 통상적인 응용프로그램들과는 동작 방식이 다릅니다. 컨테이너화를 하는데 있어서 허들이 되는 부분은 즉 SCM이라고 할 수 있습니다.</p><p>Windows 서비스를 컨테이너화한다는 것은, 컨테이너화할 서비스가 정상적으로 시작되어 SCM에 의하여 종료를 맞이할 때까지 컨테이너가 계속 실행되어야 함을 뜻합니다. 하지만 컨테이너 런타임은 SCM의 실행 상태를 고려하지 않고, 또한 SCM을 고려한다는 것은 플랫폼에 지나치게 종속적인 일입니다.</p><p>이 문제를 해결하기 위하여 Microsoft에서는 IIS용으로 ServiceMonitor 라는 오픈 소스 유틸리티를 공개하였습니다. 하지만 IIS만이 아니라 SCM에 의하여 제어할 수 있는 서비스에는 모두 적용할 수 있습니다.</p><p><a href="https://github.com/Microsoft/IIS.ServiceMonitor">Microsoft/IIS.ServiceMonitor</a></p><p>위의 리포지터리에서 제공하는 릴리스된 버전의 ServiceMonitor 유틸리티를 Docker로 이미지를 빌드하는 도중에 추가하여 ENTRYPOINT로 지정하면 손쉽게 활용할 수 있습니다.</p><h3>실제 Dockerfile 예시 살펴보기</h3><p>이번 글에서의 관심사는 순수하게 ServiceMonitor의 활용에 관한 것이므로 저는 Windows 운영 체제에 이미 포함되어있는 예제 TCP 서비스를 컨테이너화하는 것으로 시나리오를 잡았습니다.</p><p>예제 TCP 서비스를 활성화하기 위한 제반 사항을 포함하는 SKU는 Windows Server Core이므로, 해당 이미지를 기본 이미지로 사용하고, PowerShell 명령어를 자주 써야 하므로 기본 Shell을 PowerShell로 변경하기 위하여 Dockerfile의 첫 시작은 다음과 같이 만들었습니다.</p><pre>FROM mcr.microsoft.com/windows/servercore:1809<br>SHELL [&quot;powershell&quot;, &quot;-Command&quot;, &quot;$ErrorActionPreference = &#39;Stop&#39;; $ProgressPreference = &#39;Continue&#39;; $verbosePreference=&#39;Continue&#39;;&quot;]</pre><p>앞에서 이야기한 ServiceMonitor를 미리 빌드한 버전을 다음과 같이 루트 디렉터리 (C:\)에 추가합니다.</p><pre>ADD <a href="https://dotnetbinaries.blob.core.windows.net/servicemonitor/2.0.1.3/ServiceMonitor.exe">https://dotnetbinaries.blob.core.windows.net/servicemonitor/2.0.1.3/ServiceMonitor.exe</a> /</pre><p>예제 TCP 서비스를 Windows 부가 기능에서 찾아 활성화하고, 서비스를 시작 상태로 변경하는 PowerShell 명령을 다음과 같이 추가합니다.</p><pre>RUN Enable-WindowsOptionalFeature -Online -FeatureName SimpleTCP<br>RUN Start-Service -ServiceName SimpTcp</pre><p>Echo (7/tcp), Discard (9/tcp), Daytime (13/tcp), QotD (17/tcp), chargen (19/tcp)가 SimpTcp 서비스로 인하여 한 번에 시작됩니다. 컨테이너 외부에서 이들 서비스에 접속할 수 있도록 설정합니다.</p><pre># Echo<br>EXPOSE 7</pre><pre># Discard<br>EXPOSE 9</pre><pre># Daytime<br>EXPOSE 13</pre><pre># Quote of the Day (QOTD)<br>EXPOSE 17</pre><pre># Character Generator (chargen)<br>EXPOSE 19</pre><p>그리고 SimpTcp 서비스가 실행되는 동안 컨테이너가 종료되지 않도록 ServiceMonitor가 SimpTcp 서비스를 바라보도록 ENTRYPOINT 설정을 다음과 같이 추가합니다.</p><pre>ENTRYPOINT C:\ServiceMonitor SimpTcp</pre><p>지금까지 만든 Dockerfile은 다음과 같습니다.</p><pre>FROM mcr.microsoft.com/windows/servercore:1809<br>SHELL [&quot;powershell&quot;, &quot;-Command&quot;, &quot;$ErrorActionPreference = &#39;Stop&#39;; $ProgressPreference = &#39;Continue&#39;; $verbosePreference=&#39;Continue&#39;;&quot;]</pre><pre>ADD <a href="https://dotnetbinaries.blob.core.windows.net/servicemonitor/2.0.1.3/ServiceMonitor.exe">https://dotnetbinaries.blob.core.windows.net/servicemonitor/2.0.1.3/ServiceMonitor.exe</a> /</pre><pre>RUN Enable-WindowsOptionalFeature -Online -FeatureName SimpleTCP<br>RUN Start-Service -ServiceName SimpTcp</pre><pre># Echo<br>EXPOSE 7</pre><pre># Discard<br>EXPOSE 9</pre><pre># Daytime<br>EXPOSE 13</pre><pre># Quote of the Day (QOTD)<br>EXPOSE 17</pre><pre># Character Generator (chargen)<br>EXPOSE 19</pre><pre>ENTRYPOINT C:\ServiceMonitor SimpTcp</pre><h3>컨테이너 이미지 빌드 및 테스트</h3><p>컨테이너 이미지를 빌드하기 위하여 Dockerfile이 있는 디렉터리에서 다음과 같이 명령어를 실행합니다.</p><pre>docker build -t simpletcp:latest .</pre><p>그 후, 다음과 같이 컨테이너를 실행합니다.</p><pre>docker run --rm -d -p 7:7 -p 9:9 -p 13:13 -p 17:17 -p 19:19 --name=simpletcp simpletcp:latest .</pre><p>컨테이너가 정상적으로 계속 실행되는지 확인한 후에, 13, 17, 19번 포트 중 하나를 골라서 telnet 명령으로 접속해봅니다.</p><pre>telnet localhost 13<br>telnet localhost 17<br>telnet localhost 19</pre><p>각각에 해당되는 서비스가 정상 작동하는 모습을 볼 수 있습니다.</p><p>참고로 telnet 유틸리티는 기본으로 설치되지 않으므로 호스트 PC에서 관리자 권한으로 아래 명령을 실행하여 해당 기능을 설치해야 합니다.</p><pre>Install-WindowsFeature Telnet-Client</pre><h3>더 생각해볼 것</h3><p>일단 컨테이너화된 Windows 서비스가 잘 작동하는 것을 볼 수 있었습니다. 하지만 stdout으로 로그를 내보내는 기능이 없어 동작 상태를 즉시 파악할 수 없는 문제가 있습니다.</p><p>ServiceMonitor는 IIS를 컨테이너화할 목적으로 만들어진 제한된 목적의 도우미 유틸리티입니다.</p><p>그러나 최소한의 기능만 제공하면서도 오픈 소스로 공개되어있어서 여러분의 입맛대로 기능을 커스터마이징할 수 있습니다. 약간의 기능 개선을 적용하면 서비스의 동작 상태를 ServiceMonitor로 하여금 stdout에 표시하게 하는 등의 개발을 좀 더 진행하는 것을 고려해볼 수도 있습니다.</p><p>또는 fluentd 등의 솔루션을 이용하여 파일로 기록되는 로그를 중앙으로 계속해서 올려보내는 전략을 생각해 볼 수도 있겠습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=74043491f9ff" width="1" height="1"><hr><p><a href="https://medium.com/rkttu/move-windows-service-to-container-74043491f9ff">Windows Service를 컨테이너로 옮기기</a> was originally published in <a href="https://medium.com/rkttu">남정현의 블로그</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Windows Forms 애플리케이션의 High DPI 지원 구현]]></title>
            <link>https://medium.com/rkttu/windows-forms-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%98-high-dpi-%EC%A7%80%EC%9B%90-%EA%B5%AC%ED%98%84-5cebe6bb8765?source=rss-421917445ce9------2</link>
            <guid isPermaLink="false">https://medium.com/p/5cebe6bb8765</guid>
            <category><![CDATA[feature-control]]></category>
            <category><![CDATA[windows-forms]]></category>
            <category><![CDATA[csharp]]></category>
            <category><![CDATA[high-dpi]]></category>
            <category><![CDATA[dpi]]></category>
            <dc:creator><![CDATA[남정현]]></dc:creator>
            <pubDate>Sat, 13 Oct 2018 05:42:17 GMT</pubDate>
            <atom:updated>2018-10-14T10:51:29.346Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*7SH7mgrgeAvV0o_T.png" /><figcaption>High DPI 지원을 추가한 YouTubeBrowserApp / <a href="https://github.com/rkttu/YouTubeBrowserApp">https://github.com/rkttu/YouTubeBrowserApp</a></figcaption></figure><p>개인적인 필요에 의하여, 그리고 macOS의 <a href="https://itunes.apple.com/us/app/deskapp-for-youtube/id1180531112">DeskApp for YouTube</a>에 영감을 받아서 만든 <a href="https://github.com/rkttu/YouTubeBrowserApp">YouTubeBrowserApp</a>을 개선하면서 새롭게 알게 된 내용을 아티클로 정리해보았습니다.</p><p>짤막하게 광고를 하나 하면, YouTubeBrowserApp은 웹 브라우저 세션들과 겹치지 않는 독립적인 창에 YouTube 웹 사이트를 띄워주는 매우 단순한 프로그램이지만, YouTube 플레이어의 자체 반복 재생 기능이나 풍부한 여러 기능 덕에 유용하게 비디오나 음악을 시청할 수 있게 해줍니다. 많이 애용해 주시면 감사하겠습니다. :-)</p><p>기존의 Windows Forms 기반 애플리케이션에서 사용하는 여러 기능에 High DPI 지원을 추가하면서 겪을 수 있는 문제들의 개선에 도움을 줄 수 있는 내용들을 정리해보았습니다.</p><h3>Internet Explorer Feature Control</h3><p>.NET Framework 4.7.x까지 포함된 Windows Forms의 웹 브라우저 컨트롤은 Internet Explorer (Trident) 엔진을 기반으로 웹 페이지를 렌더링합니다. 최신 웹 기술을 사용할 수 없는 제약 사항이 있음에도 다른 적절한 선택지를 찾을 수 없어 부득이하게 여기서 머무를 수 밖에 없는 안타까운 문제가 있습니다.</p><p>그래서 시스템에 설치된 실제 Internet Explorer와 근접한 기능을 제공하기 위하여 Internet Explorer Feature Control이라는 특수 기능을 이용하는 경우가 많습니다. 그런데 이 기능은 레지스트리 키를 추가해야 하는 방식이라 권한 상승을 적용해야만 사용할 수 있는 것으로 인지되는 경우가 많습니다. 저도 최근까지는 그렇게 알고 있었습니다.</p><blockquote>하지만 다행히 HKLM 영역이 아닌 HKCU 영역에 Feature Control 관련 레지스트리 키를 추가해도 제대로 처리가 된다는 것을 알게 되었습니다.</blockquote><p>그리고 흔히 SOFTWARE\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_BROWSER_EMULATION 키에 값을 추가하여 Internet Explorer 11의 렌더링 방식을 따르도록 수정을 하곤 합니다. FEATURE_BROWSER_EMULATION 키 외에, 여러 가지 세부적인 설정을 조절할 수 있도록 많은 옵션을 제공하고 있는데, High DPI에 관련된 설정은 FEATURE_96DPI_PIXEL 키를 사용하는 것입니다.</p><p>참고로 키의 이름만 다를 뿐 레지스트리 항목의 형태는 동일하기 때문에, 아래와 같은 도우미 메서드를 하나 정의하면 쉽게 설정을 변경할 수 있습니다.</p><pre>private static void SetWebViewFeature(string featureName, object value) {<br>  var targetPath = $@&quot;SOFTWARE\Microsoft\Internet Explorer\Main\FeatureControl\{featureName}&quot;;<br>  var execFileName = Path.GetFileName(Process.GetCurrentProcess().MainModule.FileName);<br>  var subKey = Registry.CurrentUser.OpenSubKey(targetPath, true);</pre><pre>  if (subKey == null) subKey = Registry.CurrentUser.CreateSubKey(targetPath);</pre><pre>  using (subKey) {<br>    subKey.SetValue(execFileName, value);<br>  }<br>}</pre><p>그리고 Main 메서드에 다음과 같이 도우미 메서드를 호출하면 쉽게 적용됩니다.</p><pre>// Internet Explorer 11의 렌더링 방식 사용<br>SetWebViewFeature(&quot;FEATURE_BROWSER_EMULATION&quot;, 11000);</pre><pre>// High DPI 지원 활성화<br>SetWebViewFeature(&quot;FEATURE_96DPI_PIXEL&quot;, 1);</pre><p>그 외에 사용 가능한 Feature Control 레지스트리 키들의 목록은 아래 웹 페이지를 참고합니다. (2018.10 현재 docs.microsoft.com으로 마이그레이션되지 않은 페이지만 남아있습니다. 추후 링크가 업데이트될 수 있습니다.)</p><p><a href="https://msdn.microsoft.com/en-us/ie/ee330720(v=vs.94)">Internet Feature Control Keys (Internet Explorer)</a></p><h3>High DPI를 지원한다는 것을 명시하기 위한 다양한 수단</h3><p>웹 상에서 해당 Windows Forms 애플리케이션이 High DPI를 지원한다는 것을 명시하는 다양한 방법들이 기재되어있습니다. 다음은 제가 찾은 방법들을 정리한 것입니다.</p><h4>Application.EnableVisualStyles 메서드</h4><p>예전에 Windows XP (Whistler) 부터 도입되었던 시각적 테마 (흔히 Luna 테마라고 말하는 그것)를 응용프로그램에 추가할 수 있도록 제공된 메서드인데, High DPI 지원에도 관련이 있습니다. 다만 호출 순서에 민감한 측면이 있어서, Main 메서드의 제일 첫 줄에 등장하는 것이 좋다는 조언이 있습니다.</p><pre>Application.EnableVisualStyles();<br>Application.SetCompatibleTextRenderingDefault(false);<br>Application.OleRequired();</pre><h4>SetProcessDpiAwareness P/Invoke 메서드</h4><p>.NET Framework의 버전과 관계없이 DPI 지원을 직접 지정할 수 있도록 제공되는 Windows API입니다. 다음과 같이 선언할 수 있습니다.</p><pre>public enum PROCESS_DPI_AWARENESS : int {<br>  PROCESS_DPI_UNAWARE,<br>  PROCESS_SYSTEM_DPI_AWARE,<br>  PROCESS_PER_MONITOR_DPI_AWARE<br>}</pre><pre>[DllImport(&quot;shcore.dll&quot;, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.None, EntryPoint = &quot;SetProcessDpiAwareness&quot;)]<br>[return: MarshalAs(UnmanagedType.U4)]<br>public static extern int SetProcessDpiAwareness(PROCESS_DPI_AWARENESS value);</pre><p>그리고 실제로 사용할 때에는 Main 메서드에 다음과 같이 호출을 추가합니다.</p><pre>SetProcessDpiAwareness(PROCESS_DPI_AWARENESS.PROCESS_PER_MONITOR_DPI_AWARE);</pre><h4>응용프로그램 매니페스트 설정</h4><p>지원되는 OS의 버전을 app.manifest 파일 (C# 프로젝트에서 같이 만들 수 있는 템플릿에 응용프로그램 매니페스트라는 것이 있습니다.)에 기재하고 DPI Awareness 설정을 역시 추가할 수 있습니다.</p><p>&lt;assembly&gt; 태그 아래의 레벨에 다음의 항목을 추가하여 우선 Windows 10에 대한 지원을 명시합니다. (등장 순서는 무관합니다.)</p><pre>&lt;compatibility xmlns=&quot;urn:schemas-microsoft-com:compatibility.v1&quot;&gt;<br>  &lt;application&gt;<br>    &lt;!-- 필요에 따라 다른 OS의 GUID를 열거할 수 있습니다. <a href="https://docs.microsoft.com/en-us/windows/desktop/sbscs/application-manifests">https://docs.microsoft.com/en-us/windows/desktop/sbscs/application-manifests</a> 문서를 참고하세요. --&gt;<br>    &lt;supportedOS Id=&quot;{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}&quot; /<br>  &lt;/application&gt;<br>&lt;/compatibility&gt;</pre><p>그리고 역시 &lt;assembly&gt; 태그 아래의 레벨에 다음의 항목을 추가하여 DPI Awareness 지원 여부를 명시합니다. (등장 순서는 무관합니다.)</p><pre>&lt;application xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;<br>  &lt;windowsSettings&gt;<br>    &lt;dpiAware xmlns=&quot;http://schemas.microsoft.com/SMI/2005/WindowsSettings&quot;&gt;true&lt;/dpiAware&gt;<br>  &lt;/windowsSettings&gt;<br>&lt;/application&gt;</pre><h3>Form 자체의 설정</h3><p>위의 설정들을 추가한 후, 실제로 UI를 표시하는 Form에서는 다음의 설정을 추가로 지정합니다.</p><ul><li>AutoScaleMode는 Dpi로 변경하고, 작업하는 동안 Visual Studio의 High DPI 지원을 끄는 옵션을 사용합니다. (Visual Studio 2017 15.8 업데이트부터 제공되는 기능입니다.)</li><li>Windows Forms의 스케일링 옵션으로 키워지는 글꼴은 시스템 글꼴과 차이가 날 뿐더러 보기 좋지 않습니다. 시스템 기본 글꼴을 사용한다면 Load 이벤트 처리기의 첫 줄에 다음의 코드를 넣으면 시각적 차이를 줄일 수 있습니다. (<a href="https://www.medo64.com/2014/01/scaling-toolstrip-with-dpi/">https://www.medo64.com/2014/01/scaling-toolstrip-with-dpi/ 에서 인용했습니다.</a>)<br>this.Font = SystemFonts.MessageBoxFont;</li><li>ToolStrip의 경우 Auto Scaling을 적용할 경우 특히 화면에서 깨짐이 심하게 발생하고 훨씬 보기에 좋지 않습니다. 우선 Load 이벤트 처리기에 다음의 코드를 추가해야 하며, 이미지/아이콘을 사용하고 있다면 그래픽 디자이너와 협업하여 지원하려는 최대 DPI를 고려한 고해상도 이미지/아이콘으로 원본을 교체하도록 합니다. (<a href="https://www.medo64.com/2014/01/scaling-toolstrip-with-dpi/">https://www.medo64.com/2014/01/scaling-toolstrip-with-dpi/ 에서 인용했습니다.</a>)</li></ul><pre>using (var graphics = CreateGraphics()) {<br>  var scale = Math.Max(graphics.DpiX, graphics.DpiY) / 96d;<br>  var newScale = (int)Math.Floor(scale * 100) / 50 * 50 / 100d;</pre><pre>  if (newScale &gt; 1) {<br>    var newWidth = (int)(yourToolStrip.ImageScalingSize.Width * newScale);<br>    var newHeight = (int)(yourToolStrip.ImageScalingSize.Height * newScale);<br>    yourToolStrip.ImageScalingSize = new Size(newWidth, newHeight);<br>    yourToolStrip.AutoSize = false;<br>  }<br>}</pre><h3>마무리</h3><p>Windows Forms의 High DPI 개선 지원은 추후 .NET Core 3.0과 .NET Framework 4.8에 포함될 새로운 버전의 Windows Forms 컨트롤에서 크게 개선될 가능성이 있습니다. 하지만 새 버전의 프레임워크를 배포하는 것이 생각보다 간단한 문제가 아니기 때문에, 오늘 소개해드린 내용을 바탕으로 문제 해결을 시도해보시는 것을 권해드립니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5cebe6bb8765" width="1" height="1"><hr><p><a href="https://medium.com/rkttu/windows-forms-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%98-high-dpi-%EC%A7%80%EC%9B%90-%EA%B5%AC%ED%98%84-5cebe6bb8765">Windows Forms 애플리케이션의 High DPI 지원 구현</a> was originally published in <a href="https://medium.com/rkttu">남정현의 블로그</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[저 글을 쓴 이후로 내용이 바뀌었나봅니다.]]></title>
            <link>https://medium.com/@rkttu/%EC%A0%80-%EA%B8%80%EC%9D%84-%EC%93%B4-%EC%9D%B4%ED%9B%84%EB%A1%9C-%EB%82%B4%EC%9A%A9%EC%9D%B4-%EB%B0%94%EB%80%8C%EC%97%88%EB%82%98%EB%B4%85%EB%8B%88%EB%8B%A4-12f7f62cdde1?source=rss-421917445ce9------2</link>
            <guid isPermaLink="false">https://medium.com/p/12f7f62cdde1</guid>
            <dc:creator><![CDATA[남정현]]></dc:creator>
            <pubDate>Wed, 03 Oct 2018 06:38:07 GMT</pubDate>
            <atom:updated>2018-10-03T06:38:07.779Z</atom:updated>
            <content:encoded><![CDATA[<p>저 글을 쓴 이후로 내용이 바뀌었나봅니다. 정확히 저 버전 구간대의 docker만이 WSL인지를 따지지 않고 실행할 수 있었고, 말씀하신대로 18.x 버전대는 파일 시스템 타입을 확인하기 때문에 실행 전 검사에서 통과가 되지 않습니다. (글을 작성할 당시에도 이미 그러했었고요.)</p><p>혹시 Docker 17.x 버전대를 수동으로 설치할 수 있는 방법이 있는지 따로 찾아봐야 할 것 같습니다.</p><p>그리고 저 글에서 이야기한것은 호기심 차원에서 발굴한 내용이고, 실제로 지장 없이 사용하시려면 결국 별도의 VM을 만들어서 쓰시는 것이 더 바람직할 것 같습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=12f7f62cdde1" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Blazor와 React의 조합 — JavaScript Interop]]></title>
            <link>https://medium.com/rkttu/blazor%EC%99%80-react%EC%9D%98-%EC%A1%B0%ED%95%A9-javascript-interop-a2599bcd6563?source=rss-421917445ce9------2</link>
            <guid isPermaLink="false">https://medium.com/p/a2599bcd6563</guid>
            <category><![CDATA[react]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[webpack]]></category>
            <category><![CDATA[blazor]]></category>
            <category><![CDATA[csharp]]></category>
            <dc:creator><![CDATA[남정현]]></dc:creator>
            <pubDate>Tue, 25 Sep 2018 17:33:15 GMT</pubDate>
            <atom:updated>2018-10-09T07:24:57.626Z</atom:updated>
            <content:encoded><![CDATA[<p>C# 프로그래밍 언어 하나로 프론트엔드를 쓸 수 있다는 사실에 많은 사람들의 주목을 받고, 매우 뜨거운 환영을 받고 있는 Blazor가 약 두 달간의 개발을 거쳐 이 글을 쓰는 시점인 2018년 9월 26일에 0.6.0 Preview 1을 오랫만에 업데이트했습니다.</p><p>새 소식을 들으니 지난번 0.5.1 버전을 사용해보면서 들었던 궁금증이 다시 떠올랐습니다.</p><blockquote>Blazor에서는 오로지 C#만을 사용해서 프론트엔드 코딩을 해야 할까?</blockquote><p>Blazor는 컴포넌트 내부에서 별도의 &lt;script&gt; 태그를 사용하는 것을 권장하지 않고 있고, 실제로 모든 코드를 C#으로만 작성하도록 강제하고 있습니다. 우리가 아는 대다수의 프론트엔드 코드는 ECMA Script를 기반으로 작동하는데 비해 너무 동떨어진 면이 있고, 이것이 아직 Blazor가 Experimental Framework 라는 것을 잘 보여주는 부분이기도 합니다.</p><p>앞으로 어떻게 개선이 될지는 모르겠습니다. 하지만 큰 결정을 새로 하지 않는 이상 현재의 구도에는 변화가 없을 것 같다는 예상은 어느정도 해볼 수 있습니다. 그래서인지 JavaScript Interop에 관한 여지를 미리부터 넣어두고 있는듯 합니다. 오늘은 이 부분을 어떻게 활용할 수 있는지에 대한 인사이트를 공유하려고 합니다.</p><h3>React를 같이 사용하기 위한 준비</h3><p>앞에서 이야기한대로 Razor는 cshtml 컴포넌트에 다른 &lt;script&gt; 태그를 포함하는 것을 권장하지 않습니다. 실제로, Visual Studio에서는 다음과 같은 빌드 경고를 미리 표시해줍니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/672/1*C6Jnc6Lcu_ihr7RQFTrA3Q.png" /><figcaption>script 태그를 사용하려면 index.html 로 옮기라고 합니다.</figcaption></figure><p>그래서 이 지침에 따라 솔루션 탐색기의 wwwroot 폴더 아래의 index.html 파일을 아래와 같이 수정하여 React 라이브러리에 대한 참조 &lt;head&gt; 태그에 추가했습니다. 그리고 scripts/reacttest.js 파일을 새로 만들어서 같이 추가했습니다.</p><pre>&lt;script src=&quot;https://unpkg.com/react@15/dist/react.js&quot;&gt;&lt;/script&gt;<br>&lt;script src=&quot;https://unpkg.com/react-dom@15/dist/react-dom.js&quot;&gt;&lt;/script&gt;<br>&lt;script src=&quot;scripts/reacttest.js&quot;&gt;&lt;/script&gt;</pre><p>저는 Web Pack을 사용하진 않습니다. 그래서 편의상 unpkg.com 에서 미리 제공하는 캐시된 버전의 미리 빌드된 React 라이브러리를 참조하여 사용할 것입니다.</p><h3>JavaScript Interop 코드 준비하기</h3><p>scripts/reacttest.js 파일의 내용은 다음과 같습니다. window.reacttest 라는 프로퍼티에 함수를 대입하였고, target이 React가 그려낼 컴포넌트를 추가할 Root Element가 됩니다.</p><pre>window.reacttest = function (target) {<br>  class Greetings extends React.Component {<br>    render() {<br>      return React.createElement(&#39;h1&#39;, null, &#39;Greetings, &#39; + this.props.name + &#39;!&#39;);<br>    }<br>  }<br>  ReactDOM.render(<br>    React.createElement(Greetings, { name: &#39;Chris&#39; }),<br>    target<br>  );<br>}</pre><p>빠르게 파악하신 분도 계시겠지만, React에 관한 코드는 온전히 scripts/reacttest.js 에 모두 담았습니다. index.html 파일을 거쳐서 추가해야 하는 점이 불편한 부분이고 앞으로 개선될 여지가 있을 것 같습니다만, 이렇게 추가되는 코드는 Blazor와는 무관하며, Blazor가 얼마든지 불러다 쓸 수 있습니다.</p><p>그러면 위의 코드를 Blazor 컴포넌트에서 불러다 쓰게 하려면 어떻게 해야 할까요? Extension 메서드를 하나 정의해보겠습니다.</p><pre>public static Task ReactTest(this ElementRef elementRef)<br>{<br>  return JSRuntime.Current.InvokeAsync&lt;object&gt;(&quot;window.reacttest&quot;, elementRef);<br>}</pre><p>ElementRef 라는 타입은 Browser로부터 전달받은 DOM Element Object에 대한 불투명한 참조 (형식을 알 수 없는 참조)입니다. 뒤에서 다시 사용하겠지만, React가 컴포넌트를 그릴 Element를 Blazor에서 받아서 앞의 scripts/reacttest.js 측으로 전달하기 위하여 이 도우미 메서드를 사용하는 것입니다.</p><h3>실제 Interop 코드 작성하고 테스트해보기</h3><p>이제 Index.cshtml 파일을 열어서 React와 연결해보겠습니다.</p><pre>&lt;div ref=&quot;reacttest&quot;&gt;&lt;/div&gt;</pre><p>위와 같이 ref 어트리뷰트에 이름을 지정합니다. id 어트리뷰트 대신 ref 어트리뷰트를 사용하여 Blazor에서 해당 DOM Element를 찾을 수 있게 해주는 것입니다.</p><p>그리고 ref 어트리뷰트 안에 지정했던 이름과 동일한 ElementRef 타입의 멤버 변수를 @functions 절 안에 아래와 같이 추가합니다.</p><pre>@functions {<br>  ElementRef reacttest;<br>}</pre><p>그 다음, OnAfterRenderAsync 메서드를 재정의하여, reacttest 변수에 덧붙여지는 확장 메서드인 ReactTest (앞에서 만든 메서드)를 호출하는 코드를 추가합니다. Task 타입의 인스턴스를 반환하는 확정 메서드였으므로 await 키워드를 사용하여 호출하고, 재정의하는 메서드 자체는 async 키워드로 표기합니다.</p><pre>@functions {<br>  ElementRef reacttest;</pre><pre>  protected override async Task OnAfterRenderAsync()<br>  {<br>    await reacttest.ReactTest();<br>    await base.OnAfterRenderAsync();<br>  }<br>}</pre><p>실행해보면 다음과 같이 React 컴포넌트가 div 태그 아래에 잘 렌더링된 것을 볼 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*VDhJDft_aMxIrTZj1BDiEw.png" /><figcaption>Blazor와 React의 동시 사용 예시</figcaption></figure><p>이와 같은 방법으로 Blazor와 기존 JavaScript/ECMA Script 애플리케이션을 공존시킬 수 있다는 것을 확인할 수 있었습니다.</p><h3>고민거리</h3><p>Blazor는 React나 VueJS 등의 UI 프레임워크가 동작하는 기반과는 완전히 분리된 독립적인 웹 어셈블리 기반의 런타임을 사용합니다. 처음부터 완전히 새로 만드는 프론트엔드 UI에서 JavaScript 상호 운용성을 이용하여 얼마나 어떤 부분을 재사용하는 것이 좋을지에 대한 방향성을 잡는 것은 아마 무척 어려운 고민이 될 것 같습니다.</p><p>오늘 아티클은 Blazor를 메인으로 사용하는 상황에서 React를 상호운용성 기능으로 가져와 사용하는 방법을 보여드린 것이지만, 다른 형태의 상호운용 시나리오에 대한 피드백을 공유하고 토론해보는 것도 무척 유용할 것 같습니다.</p><p>아울러 Blazor에 관한 전문적인 내용을 공유하고 토론할 수 있는 Facebook 그룹을 열었습니다. <a href="https://www.facebook.com/groups/krblazor/">https://www.facebook.com/groups/krblazor/</a> 에 방문해주셔서 토론을 발제해주신다면 매우 유익할 것 같습니다. :-)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a2599bcd6563" width="1" height="1"><hr><p><a href="https://medium.com/rkttu/blazor%EC%99%80-react%EC%9D%98-%EC%A1%B0%ED%95%A9-javascript-interop-a2599bcd6563">Blazor와 React의 조합 — JavaScript Interop</a> was originally published in <a href="https://medium.com/rkttu">남정현의 블로그</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[미리 체험해보는 .NET Core 3.0의 Windows Forms와 WPF 지원]]></title>
            <link>https://medium.com/rkttu/%EB%AF%B8%EB%A6%AC-%EC%B2%B4%ED%97%98%ED%95%B4%EB%B3%B4%EB%8A%94-net-core-3-0%EC%9D%98-windows-forms%EC%99%80-wpf-%EC%A7%80%EC%9B%90-ed2d6b4b50b0?source=rss-421917445ce9------2</link>
            <guid isPermaLink="false">https://medium.com/p/ed2d6b4b50b0</guid>
            <category><![CDATA[net-core]]></category>
            <category><![CDATA[windows-forms]]></category>
            <category><![CDATA[wpf]]></category>
            <category><![CDATA[windows]]></category>
            <category><![CDATA[csharp]]></category>
            <dc:creator><![CDATA[남정현]]></dc:creator>
            <pubDate>Thu, 20 Sep 2018 15:41:11 GMT</pubDate>
            <atom:updated>2018-09-23T10:34:45.873Z</atom:updated>
            <content:encoded><![CDATA[<p>지난 5월, BUILD 2018 행사에서 아주 파격적인 .NET Core 3.0에 대한 로드맵을 발표했었습니다. Windows 운영 체제에 국한되는 것이긴 하나, Windows Forms와 Windows Presentation Foundation (이하 WPF) 애플리케이션을 .NET Core에서 실행할 수 있도록 만들겠다는 소식이었습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*EaK5GIbvrAZ11yuH.png" /><figcaption><a href="https://blogs.msdn.microsoft.com/dotnet/2018/05/07/net-core-3-and-support-for-windows-desktop-applications/">Visualizing .NET Core 3</a></figcaption></figure><p>한 동안 잊고 있었다가, 현재 어느 정도까지 진행이 되었는지 궁금해져서 문득 찾아보았습니다. (2018년 9월 21일)</p><ul><li>.NET Core SDK 3.0 Alpha 버전을 설치할 수 있도록 공개되었습니다.</li><li>Windows Forms 프로젝트, WPF 프로젝트 템플릿을 dotnet new 명령어로 만들 수 있습니다.</li><li>Windows Forms 프로젝트는 dotnet 명령어로 빌드하고 실행할 수 있습니다.</li><li>WPF는 아직 msbuild 명령어로 빌드해야 합니다.</li></ul><p>체감할 수 있는 수준까지 개발이 이루어진 것 같아서, 어떻게 하면 새 버전을 받아서 테스트해볼 수 있는지 방법을 정리한 글을 써보게 되었습니다.</p><h3>.NET Core SDK 3.0 설치</h3><p>.NET Core SDK 3.0은 현재 Daily Build로 게시되고 있습니다. 아래 주소에서 Future Release 의 .NET Core 3.0 SDK 링크를 클릭합니다.</p><p><a href="https://github.com/dotnet/core/blob/master/daily-builds.md">https://github.com/dotnet/core/blob/master/daily-builds.md</a></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*EwlcJ7qUXt9wjQccBtXFsg.png" /></figure><p>그러면 각 플랫폼 별로 패키지 다운로드 링크가 걸린 테이블을 볼 수 있습니다. Windows x64 버전을 다운로드하여 설치를 진행하면 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*sC4dz4NQlA9PW2bQXu970w.png" /></figure><p>설치가 끝난 후에, dotnet --version명령어를 실행하면 버전이 3.0으로 업데이트된 것을 볼 수 있습니다. 그리고, dotnet new 명령어를 실행하면 아래 그림과 같이 winform, wpf 템플릿이 새로 추가된 것을 볼 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/958/1*UpVTkxORt7v-rLw0aNSgUQ.png" /></figure><h3>Windows Forms 테스트해보기</h3><p>시험삼아 새 Windows Forms 프로젝트를 만들어보겠습니다. dotnet new winform -n WinFormTest 와 같이 명령어를 입력하면 다음과 같이 코드가 만들어지는 것을 볼 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*OiikndRj0gdP4MxhhpIafQ.png" /></figure><p>그리고 dotnet run 명령으로 실행해보면 Windows Forms 샘플 애플리케이션이 제대로 실행되는 것을 볼 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/469/1*PKZlI77cPIemkYOEDsa_sQ.png" /></figure><p>코드의 내용은 특별할 것이 없어서 건너뛰겠습니다.</p><h3>WPF 테스트해보기</h3><p>WPF도 Windows Forms와 같은 방법으로 새 프로젝트를 만들 수 있습니다. dotnet new wpf -n WpfTest 와 같이 새 프로젝트를 만들면 됩니다. 그러나 아직 개발이 완료되지 않아서, .NET Core의 빌드 엔진으로는 프로젝트를 빌드할 수 없으며, Visual Studio 2017의 msbuild를 대신 사용해야 합니다. (하지만 .NET Core용으로 DLL은 제대로 나옵니다.)</p><p>Visual Studio 2017을 설치하고나면 아래 그림과 같이 VS라는 키워드를 넣고 검색했을 때 VS 2017에 대한 명령 프롬프트 바로 가기들이 보입니다. x64 아키텍처를 지원하는 명령 프롬프트를 실행하고, 앞에서 만든 프로젝트 디렉터리로 이동하여 msbuild 명령만 실행하면 빌드가 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/843/1*Q13BZXQYfDwF3U4zhHj4RQ.png" /></figure><p>이렇게 빌드를 한 다음에 실행을 할 때에도 dotnet run 명령은 사용할 수 없으며, 만들어진 DLL 파일을 직접 실행해야 합니다. dotnet bin\Debug\netcoreapp3.0\WpfTest.dll 과 같이 실행합니다. 그러면 아래 그림과 같이 역시 WPF 애플리케이션이 잘 실행되는 것을 볼 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/786/1*Nv1NYmwLsALZuC7w4KHhXw.png" /></figure><h3>더 나아가서</h3><p>.NET Core의 Build Engine을 쓸 수 있는 Windows Forms를 가지고 Self Contained EXE 파일을 만들어보겠습니다.</p><p>우리가 아는 실행 가능한 EXE 파일을 포함하는 애플리케이션으로 내보내는 것은 dotnet publish -r win-x64 또는 dotnet publish -r win-x86 명령을 통해서 내보낼 수 있습니다. 실행하고나면 bin\Debug\netcoreapp3.0\win-x64\publish 와 같이 디렉터리가 만들어지며, 이 디렉터리에 실행에 필요한 모든 파일들이 EXE 파일과 함께 들어가게 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*vHaioOJ0g-UmjesRce0vXw.png" /></figure><p>안타깝게도 Self Contained 방식으로 publish를 했기 때문에 패키지의 크기가 무척 큽니다. (약 80MB 내외) 하지만 현재 개발 중인 CoreRT가 완성되면, 최종적으로 프로그램의 실행에 필요한 코드만을 포함하는 단일 EXE 파일로 만드는 기능이 제공되어 우리가 원하는 네이티브 애플리케이션 개발을 완성할 수 있게 됩니다.</p><p><em>업데이트: 현재 버전 (2018년 9월 23일 기준)의 CoreRT는 COM Interop을 사용하는 코드를 제대로 처리하지 못합니다. 이 부분에 대한 개발이 현재 이루어지고 있으며, 완료된 이후에 Windows Forms 애플리케이션을 CoreRT로 패키징하는 것이 가능할 것으로 보입니다. (</em><a href="https://github.com/dotnet/corert/issues/6359"><em>https://github.com/dotnet/corert/issues/6359</em></a><em> 참조)</em></p><h3>마무리</h3><p>.NET Core 3.0을 이용하여 Windows Forms와 WPF에 새로운 생명을 불어넣을 수 있을 뿐 아니라 ASP.NET Core, EF Core, ML.NET까지 모두 한 자리에서 사용해볼 수 있게 된다면 무척이나 매력적인 기술이 될 것 같습니다.</p><p>그 뿐만 아니라, CoreRT와 Blazor 등 기대되는 새로운 기술들이 계속해서 준비되어가고 있으니 선물 상자를 열어보는 기분으로 하나씩 살펴보면 어떨까 싶습니다. :-)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ed2d6b4b50b0" width="1" height="1"><hr><p><a href="https://medium.com/rkttu/%EB%AF%B8%EB%A6%AC-%EC%B2%B4%ED%97%98%ED%95%B4%EB%B3%B4%EB%8A%94-net-core-3-0%EC%9D%98-windows-forms%EC%99%80-wpf-%EC%A7%80%EC%9B%90-ed2d6b4b50b0">미리 체험해보는 .NET Core 3.0의 Windows Forms와 WPF 지원</a> was originally published in <a href="https://medium.com/rkttu">남정현의 블로그</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[High DPI를 포기하지 않고 Windows Forms 디자이너를 Visual Studio에서 개발하는 방법]]></title>
            <link>https://medium.com/rkttu/high-dpi%EB%A5%BC-%ED%8F%AC%EA%B8%B0%ED%95%98%EC%A7%80-%EC%95%8A%EA%B3%A0-windows-forms-%EB%94%94%EC%9E%90%EC%9D%B4%EB%84%88%EB%A5%BC-visual-studio%EC%97%90%EC%84%9C-%EA%B0%9C%EB%B0%9C%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-10b05cb61942?source=rss-421917445ce9------2</link>
            <guid isPermaLink="false">https://medium.com/p/10b05cb61942</guid>
            <category><![CDATA[visual-studi]]></category>
            <category><![CDATA[high-dpi]]></category>
            <category><![CDATA[dpi]]></category>
            <category><![CDATA[windows]]></category>
            <category><![CDATA[windows-forms]]></category>
            <dc:creator><![CDATA[남정현]]></dc:creator>
            <pubDate>Sun, 16 Sep 2018 14:58:03 GMT</pubDate>
            <atom:updated>2018-09-16T14:58:03.038Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/512/1*hWLJy7X2sEtfkSU1cIV8ig.jpeg" /><figcaption>비단 이런 상황에서만 쓰이는 짤방은 아니지만… 그냥 가져와봤습니다.</figcaption></figure><p>일전에 아래의 글을 공유했던 적이 있었습니다.</p><p><a href="https://medium.com/rkttu/windows-forms-high-dpi-%EB%8C%80%EC%9D%91-66cec12fa2f2">Windows Forms High DPI 대응</a></p><p>기본적으로 Windows Forms의 디자이너는 High DPI를 제대로 지원하지 못하며, 이 때문에 High DPI 상태에서 디자이너로 뭔가를 그리게 되면, 모든 픽셀 단위가 여전히 96 DPI일 때를 기준으로 계산되어 모양이 잘못 그려지는 문제가 있습니다.</p><p>하지만 이 문제를 해결하기 위하여 계산기를 두드려가며 맞춘다거나, 억지로 DPI를 96 DPI로 내려서 눈을 혹사시키거나 하는 것은 너무나 무리한 일입니다.</p><p>다행히 이 부분에 대한 업데이트가 Visual Studio 2017 15.8 업데이트 이후부터 개선되어 새롭게 적용되었습니다. 15.8 버전부터는 High DPI 상태로 Visual Studio에서 Windows Forms 디자이너를 열면 아래 그림과 같이 안내문이 표시됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*wqKAF-b589nBv-By.png" /></figure><p>DPI를 억지로 바꾸려고 하지 말고, 단순히 Visual Studio를 DPI 비 인식 모드로 재시작하는 링크만 클릭하면, Visual Studio만 단독으로 96 DPI로 다운스케일링한 상태에서 현재 프로젝트를 그대로 다시 열어줍니다. 물론 이렇게 작업하다가 원래대로 돌아가는 것도 가능합니다.</p><p>그런데 이 기능이 제대로 작동하지 않는 경우도 있습니다. 만약 아래의 레지스트리 키가 이미 만들어져있는 경우, Visual Studio가 아니라 Windows OS에 의해서 DPI 설정이 강제로 조정되기 때문에, 위의 UI를 이용하여 스위칭하는 기능이 가로막히게 됩니다.</p><pre>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\devenv.exe</pre><p>위의 키를 삭제하고, Visual Studio를 다시 시작하면 정상적으로 기능이 작동하게 됩니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=10b05cb61942" width="1" height="1"><hr><p><a href="https://medium.com/rkttu/high-dpi%EB%A5%BC-%ED%8F%AC%EA%B8%B0%ED%95%98%EC%A7%80-%EC%95%8A%EA%B3%A0-windows-forms-%EB%94%94%EC%9E%90%EC%9D%B4%EB%84%88%EB%A5%BC-visual-studio%EC%97%90%EC%84%9C-%EA%B0%9C%EB%B0%9C%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-10b05cb61942">High DPI를 포기하지 않고 Windows Forms 디자이너를 Visual Studio에서 개발하는 방법</a> was originally published in <a href="https://medium.com/rkttu">남정현의 블로그</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[새 Medium Publication을 만들었습니다.]]></title>
            <link>https://medium.com/@rkttu/%EC%83%88-medium-publication%EC%9D%84-%EB%A7%8C%EB%93%A4%EC%97%88%EC%8A%B5%EB%8B%88%EB%8B%A4-60c1de181a50?source=rss-421917445ce9------2</link>
            <guid isPermaLink="false">https://medium.com/p/60c1de181a50</guid>
            <category><![CDATA[rkttu]]></category>
            <category><![CDATA[medium]]></category>
            <dc:creator><![CDATA[남정현]]></dc:creator>
            <pubDate>Sun, 16 Sep 2018 05:32:51 GMT</pubDate>
            <atom:updated>2018-09-16T05:32:51.121Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*eNEmNNch2ePOc-Wi7Id4uQ.jpeg" /></figure><p>이제까지는 Medium에 올린 글을 제 개인 타임라인에 게시했었습니다. 앞으로는 아래 주소로 접속하시면 좀 더 편하게 글을 읽으실 수 있으니 많이 방문해주세요. 또한 rkttu.com 주소가 Medium Publication을 가리키도록 변경되었습니다.</p><p><a href="https://medium.com/rkttu">https://medium.com/rkttu</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=60c1de181a50" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Windows에 있는 JDK를 WSL에서 사용할 수는 있습니다.]]></title>
            <link>https://medium.com/@rkttu/windows%EC%97%90-%EC%9E%88%EB%8A%94-jdk%EB%A5%BC-wsl%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98%EB%8A%94-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4-33c71cb045ba?source=rss-421917445ce9------2</link>
            <guid isPermaLink="false">https://medium.com/p/33c71cb045ba</guid>
            <dc:creator><![CDATA[남정현]]></dc:creator>
            <pubDate>Sat, 15 Sep 2018 14:38:08 GMT</pubDate>
            <atom:updated>2018-09-15T14:38:08.877Z</atom:updated>
            <content:encoded><![CDATA[<p>Windows에 있는 JDK를 WSL에서 사용할 수는 있습니다. 하지만 Windows JDK는 OpenJDK가 아닌 Oracle JDK를 사용하시는 것이므로, 어떤 버전의 JDK를 사용하고자 하시는 것인지 정확히 인지한 후 선택하시는 것이 필요합니다.</p><p>Windows에 설치된 JDK를 호출하려면 WSL 입장에서는 /mnt/c/Program\ Files/Java/jdk.../bin/javac.exe 와 같이 Full Path를 지정하여 호출할 수 있습니다. 별도로 WSL에서 Windows Interoperability 설정을 해제하지 않았으면 실행이 될 것입니다.</p><p>하지만 이렇게 복잡한 호출 방법을 사용해야 하는 것이 어떤 상황인지 궁금합니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=33c71cb045ba" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>