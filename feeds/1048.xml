<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-05-14T10:46:57+00:00</updated><id>/feed.xml</id><title type="html">hackerwins blog</title><subtitle>Done is better than perfect.</subtitle><author><name>hackerwins</name><email>susukang98@gmail.com</email></author><entry><title type="html">아는만큼 Search tree</title><link href="/2019-05-10/search-tree" rel="alternate" type="text/html" title="아는만큼 Search tree" /><published>2019-05-10T08:08:00+00:00</published><updated>2019-05-10T08:08:00+00:00</updated><id>/2019-05-10/search-tree</id><content type="html" xml:base="/2019-05-10/search-tree">&lt;p&gt;회사 일을 하면서 자료구조를 구현할 기회는 별로 없었다. 하지만 최근에 데이터 타입 기반 동기화 플랫폼을 개발하면서 운 좋게도 일부 자료구조를 직접 구현해야만 했다. 나중에 잊어버리는 것보다는 짧은 지식이라도 적는게 나은 것 같아서 아는 만큼이라도 기록하기로 했다. 이 글은 마지막에 있는 링크들을 참고해서 정리했다.&lt;/p&gt;

&lt;h1 id=&quot;binary-search-tree&quot;&gt;Binary search tree&lt;/h1&gt;

&lt;p&gt;Binary search tree(이하 BST)는 Binary tree 형식의 자료 구조이다. BST에서 노드의 왼쪽 하위 트리(subtree)의 모든 노드의 Key는 현재 노드의 Key보다 작아야 하고 오른쪽 하위 트리의 노드의 Key는 현재 노드의 Key보다 커야 한다. BST는 Key를 정렬된 순서로 유지하므로 조회 및 기타 작업에서 Binary search을 활용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binary_search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binary_search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binary_search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;BST는 n개의 아이템에서 평균 O(log n), 최악에는 O(n) 시간 복잡도로 특정 아이템을 찾을 수 있다. 또 inorder traversal를 이용하면 BST에서 순서대로 아이템을 순회할 수 있다. 유독 Depth-first search(DFS)중 inorder traversal만 “iterative로 inorder traversal을 구현하시오.” 같은 문제로 코딩 인터뷰에 더 등장하는 것 같다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;inorder_traversal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;inorder_traversal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;inorder_traversal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;BST의 성능은 트리의 균형(balance)와 밀접한 관련이 있다. 균형이 깨져서 한쪽으로 길어지면(skewed), Binary search을 이용하더라도 시간 복잡도가 선형 시간(linear time)에 가까워진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2019-05-10-search-tree/bst.png&quot; alt=&quot;bst.png&quot; style=&quot;width:30%&quot; /&gt;
&lt;sup&gt;출처: Robert Sedgewick and Kevin Wayne: Algorithms FOURTH EDITION. Pearson Education, 2011&lt;/sup&gt;&lt;/p&gt;

&lt;h1 id=&quot;weight-속성의-search-tree&quot;&gt;Weight 속성의 Search tree&lt;/h1&gt;

&lt;p&gt;Key가 아닌 Weight 속성을 사용해서 Search tree를 구성하면 특정 index를 log(n)으로 찾을 수 있는 리스트 형 자료구조를 구현할 수 있다. Weight 속성을 이용한 BST의 get은 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasLeft&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getLeftWeight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getLeft&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasRight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getLeftWeight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getLeftWeight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getRight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getLeftWeight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;삽입 시 Shift가 일어나지 않으므로 Array보다 삽입/삭제가 빠르고 Linked list보다 index 기반 조회가 빠르다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The following relative performance statistics are indicative of this class:
              get  add  insert  iterate  remove
 TreeList       3    5       1       2       1
 ArrayList      1    1      40       1      40
 LinkedList  5800    1     350       2     325
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;sup&gt;출처: &lt;a href=&quot;https://commons.apache.org/proper/commons-collections/apidocs/org/apache/commons/collections4/list/TreeList.html&quot;&gt;apache/commons/collections4/list/TreeList.html&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h1 id=&quot;self-balancing-bst&quot;&gt;Self-balancing BST&lt;/h1&gt;

&lt;p&gt;BST의 균형 문제를 해결한 Self-balancing BST가 있는데, 수정 시 자동으로 균형을 유지한다.&lt;/p&gt;

&lt;h2 id=&quot;bst-rotation&quot;&gt;BST rotation&lt;/h2&gt;

&lt;p&gt;보통 Self-balancing BST는 각자 전략에 맞춰서 판단한 뒤 회전을 이용해서 균형을 유지한다. BST의 간단한 회전의 예는 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2019-05-10-search-tree/tree-rotation.gif&quot; alt=&quot;tree-rotation.gif&quot; /&gt;
&lt;sup&gt;출처: &lt;a href=&quot;https://en.wikipedia.org/wiki/Tree_rotation&quot;&gt;https://en.wikipedia.org/wiki/Tree_rotation&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h2 id=&quot;avl-tree&quot;&gt;AVL tree&lt;/h2&gt;

&lt;p&gt;AVL tree는 노드의 좌측 하위 트리의 높이(height)와 우측 하위 트리의 높이가 트리의 높이의 차이가 1 이하를 유지한다. AVL tree에서는 수정으로 높이 차이가 1보다 커지면 회전을 이용해서 높이 차이를 1 이하로 유지한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2019-05-10-search-tree/avl.gif&quot; alt=&quot;avl.gif&quot; /&gt;
&lt;sup&gt;출처: &lt;a href=&quot;https://en.wikipedia.org/wiki/AVL_tree&quot;&gt;https://en.wikipedia.org/wiki/AVL_tree&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;AVL tree는 HackerRank의 연습문제, &lt;a href=&quot;https://www.hackerrank.com/challenges/self-balancing-tree/problem&quot;&gt;Self Balancing Tree&lt;/a&gt;를 풀다가 구현했다.&lt;/p&gt;

&lt;h2 id=&quot;splay-tree&quot;&gt;Splay tree&lt;/h2&gt;

&lt;p&gt;Splay tree는 Splaying이라 부르는 특정 형식의 회전을 이용해서 접근한 노드를 루트로 올리면서 균형을 유지한다. 접근한 노드를 루트로 올리는 Splaying이 다른 동작의 기반 Operation이고 Join과 Split을 구현하기가 쉽다. 자주 접근한 노드가 루트 근처에 있으므로 Cache를 구현하는 데 유용하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2019-05-10-search-tree/splay.gif&quot; alt=&quot;splay.gif&quot; style=&quot;width:50%&quot; /&gt;
&lt;sup&gt;출처: &lt;a href=&quot;https://brilliant.org/wiki/splay-tree/&quot;&gt;https://brilliant.org/wiki/splay-tree/&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;텍스트 에디터의 동시편집을 위한 RGATreeSplit의 identifier 자료구조를 만드는 데 사용했다. Atom의 동시편집을 위한 모듈인 Teletype-CRDT도 RGATreeSplit을 기반으로 구현되어 있는데, &lt;a href=&quot;https://github.com/atom/teletype-crdt/blob/master/lib/splay-tree.js&quot;&gt;Splay tree&lt;/a&gt;를 사용한 것을 참고했다.&lt;/p&gt;

&lt;h2 id=&quot;treap&quot;&gt;Treap&lt;/h2&gt;

&lt;p&gt;Treap은 Tree와 Heap의 합성어로 균형 유지에 Random priority를 이용한다. Treap의 구조는 Heap 순서로 정렬되어야한다는 요구 사항에 따라 결정된다. 새로운 노드 생성시 Random priority를 할당하고 일반 BST처럼 삽입한 뒤 회전을 이용해서 부모 자식사이에 priority 순서를 맞춘다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2019-05-10-search-tree/treap.gif&quot; alt=&quot;treap.gif&quot; style=&quot;width:80%&quot; /&gt;
&lt;sup&gt;출처: &lt;a href=&quot;http://faculty.cs.niu.edu/~freedman/340/340notes/340treap.htm&quot;&gt;340treap.htm&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Treap은 HackerRank의 연습문제, &lt;a href=&quot;https://www.hackerrank.com/challenges/array-and-simple-queries/problem&quot;&gt;Array and simple queries&lt;/a&gt;를 풀면서 Discussions 탭의 대화를 참고해서 구현했다.&lt;/p&gt;

&lt;h2 id=&quot;b-tree&quot;&gt;B-tree&lt;/h2&gt;

&lt;p&gt;B-tree는 2-3 tree와 2-3-4 tree 등의 일반화 트리다. 예를 들어 2-3-4 tree는 order가 4인 B-tree이다. B-tree는 BST는 아니다. 2-3 tree는 자식이 2개 또는 3개만 있을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2019-05-10-search-tree/btree.svg&quot; alt=&quot;btree.svg&quot; style=&quot;width:70%&quot; /&gt;
&lt;sup&gt;출처: &lt;a href=&quot;https://infolab.usc.edu/csci585/Spring2010/den_ar/indexing.pdf&quot;&gt;indexing.pdf&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;B-tree 디자인은 컴퓨터의 Memory hierarchy와 관련 있다. 컴퓨터를 CPU ↔ Cache ↔ Disk로 추상화한다면 Cache에 있는 데이터 접근 속도는 빠르지만, Disk에 있는 데이터 접근 속도는 느리다. 따라서 트리가 Cache가 아닌 Disk에 있다면 I/O 수를 줄이는 게 성능에 유리하다. B-tree는 한 노드가 다수의 자식 노드를 갖고 있으므로(보통 order가 100 이상) Disk I/O 수가 BST보다 작고 블록 스토리지에 유리하다.&lt;/p&gt;

&lt;h2 id=&quot;red-black-tree&quot;&gt;Red-black tree&lt;/h2&gt;

&lt;p&gt;BST 형식이면서 B-tree의 특징을 취한 트리가 Red-black tree(이하 RB tree)이다. RB tree의 Red link를 수평으로 펼치면 2-3 tree에 대응된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2019-05-10-search-tree/23tree-rbtree.png&quot; alt=&quot;23tree-rbtree.png&quot; style=&quot;width:70%&quot; /&gt;
&lt;sup&gt;출처: Robert Sedgewick and Kevin Wayne: Algorithms FOURTH EDITION. Pearson Education, 2011&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;RB tree는 노드에 Red 혹은 Black을 표현하는 1bit 플래그가 추가된다. RB tree는 AVL tree와 비교하면 엄격한 균형을 유지하지는 않으므로 검색은 조금 느릴 수 있지만, 수정은 더 빠르다.&lt;/p&gt;

&lt;p&gt;Left-leaning red-black tree(이하 LLRB tree)는 세 가지 아이디어를 더해서 RB tree보다 구현하기 쉽게 디자인되어 있다. 자바스크립트에는 자바의 SortedMap처럼 내장 SortedMap이 없어서 구현이 필요했다. 일반 RB tree의 구현은 복잡해서 망설였는데, Firebase JS SDK에서 LLRB tree로 &lt;a href=&quot;https://github.com/firebase/firebase-js-sdk/blob/6b53e0058483c9002d2fe56119f86fc9fb96b56c/packages/database/src/core/util/SortedMap.ts&quot;&gt;SortedMap&lt;/a&gt;을 구현한 것을 참고했다.&lt;/p&gt;

&lt;h2 id=&quot;btree&quot;&gt;B+tree&lt;/h2&gt;

&lt;p&gt;B+tree는 B-tree와 달리 Leaf 노드를 제외한 노드에는 Key만 있고 Leaf 노드에 Key와 Value가 있다. 그리고 Leaf 노드는 Linked list처럼 서로 연결되어 있다. B+tree는 데이터베이스의 Index를 구현하는 데 자주 사용된다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2019-05-10-search-tree/b+tree.png&quot; alt=&quot;b+tree.png&quot; style=&quot;width:70%&quot; /&gt;
&lt;sup&gt;출처: &lt;a href=&quot;https://en.wikipedia.org/wiki/B%2B_tree&quot;&gt;https://en.wikipedia.org/wiki/B%2B_tree&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;B+tree의 Leaf 노드가 연결되어 있어서 JSON-like CRDT의 Array를 구현하는 데 활용했다. 하지만 트리를 디스크에 올려놓고 사용하진 않으므로 RB tree로 변경을 고민하고 있다.&lt;/p&gt;

&lt;h1 id=&quot;마무리&quot;&gt;마무리&lt;/h1&gt;

&lt;p&gt;코딩 인터뷰에서 Search tree 문제를 만나서 당황했던 적도 있다. 지금도 풀라고 하면 못풀 것 같다. 하지만 일하면서 자료구조를 구현해서 사용하는 경험은 즐거웠다. 앞으로도 이런 기회가 있었으면 좋겠다.&lt;/p&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Search_tree&quot;&gt;/wiki/Search_tree&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Tree_rotation&quot;&gt;/wiki/Tree_rotation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_tree&quot;&gt;/wiki/Binary_search_tree&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Treap&quot;&gt;/wiki/Treap&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Splay_tree&quot;&gt;/wiki/Splay_tree&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/B-tree&quot;&gt;/wiki/B-tree&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Left-leaning_red%E2%80%93black_tree&quot;&gt;/wiki/Left-leaning_red–black_tree&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_hierarchy&quot;&gt;/wiki/Memory_hierarchy&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/B%2B_tree&quot;&gt;/wiki/B%2B_tree&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://algs4.cs.princeton.edu/home/&quot;&gt;https://algs4.cs.princeton.edu/home/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.hackerrank.com/challenges/self-balancing-tree/problem&quot;&gt;hackerrank.com/self-balancing-tree&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.hackerrank.com/challenges/array-and-simple-queries/problem&quot;&gt;hackerrank.com/array-and-simple-queries&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/firebase/firebase-js-sdk&quot;&gt;github.com/firebase/firebase-js-sdk&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/atom/teletype-crdt&quot;&gt;github.com/atom/teletype-crdt&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=TOb1tuEZ2X4&quot;&gt;www.youtube.com/watch?v=TOb1tuEZ2X4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>hackerwins</name><email>susukang98@gmail.com</email></author><category term="data-structure" /><summary type="html">회사 일을 하면서 자료구조를 구현할 기회는 별로 없었다. 하지만 최근에 데이터 타입 기반 동기화 플랫폼을 개발하면서 운 좋게도 일부 자료구조를 직접 구현해야만 했다. 나중에 잊어버리는 것보다는 짧은 지식이라도 적는게 나은 것 같아서 아는 만큼이라도 기록하기로 했다. 이 글은 마지막에 있는 링크들을 참고해서 정리했다.</summary></entry><entry><title type="html">부수면 안되는 장난감</title><link href="/2019-05-02/toy-project" rel="alternate" type="text/html" title="부수면 안되는 장난감" /><published>2019-05-02T12:12:00+00:00</published><updated>2019-05-02T12:12:00+00:00</updated><id>/2019-05-02/toy-project</id><content type="html" xml:base="/2019-05-02/toy-project">&lt;p&gt;책 “프로그래머의 길, 멘토에게 묻다.”의 “부숴도 괜찮은 장난감”에서는 프로그래밍을 효과적으로 학습하기 위해서 개인 프로젝트를 시작하라 조언한다. 프로젝트의 결과물은 언제든 부술 수 있는 장난감 같은 프로그램이기 때문에 기능을 쉽게 추가하고 구조를 마음대로 변경할 수 있는 놀이터가 생긴 셈이다. 다들 장난감 프로젝트를 시작할 때에는 너무 거창한 계획을 세우기보다는 당장 내가 필요한 작은 프로그램을 만들라고 조언한다.&lt;/p&gt;

&lt;p&gt;2013년에 부숴도 좋은 장난감을 시작하려고 Summernote라는 개인 프로젝트를 시작했다. 당시 다니던 회사는 안식년 제도가 있었고 마침 안식 휴가 중이어서 작업하는 데 부담이 없었다. 그 후에 Summernote는 다른 사람들도 관심을 받게 되고 좋은 개발자들의 참여로 사용자도 꽤 있는 오픈소스로 성장했다.&lt;/p&gt;

&lt;p&gt;하지만 인기를 얻으면서 문제의 난이도가 올라갔다. 2015년 초에는 한 사용자로부터 자신의 회사 프로젝트에 사용한 Summernote에서 발생한 버그로 고객이 자신을 고소하려고 한다는 메일을 받은 일도 있었다. 회사 끝나고 부랴부랴 집에 가서 밤늦게까지 고쳤던 기억이 있다. 회사에서 일하고 집에서도 일하는 기분이었다. Summernote를 진행하는 건 힘들기도 했고 더 하고 싶지 않은 마음도 종종 들었지만, 주변에 좋은 분들이 함께 해주셔서 지금까지 유지됐다. Summernote는 더는 장난감도 아니고 놀이터도 아니었다.&lt;/p&gt;

&lt;p&gt;그 후에 장난감 같은 프로젝트를 다시 시작하고 싶어서 몇 번 시도했으나, 좀처럼 진행할 수 없었다. 거창한 목표를 세우고, 몇 주 코딩하다 중단하기를 반복했다. 당시에는 알지 못했지만, 내 문제의 원인은 프로젝트에 대한 기대치가 높은 점이었다. 당장 필요한 작은 프로그램을 만드는 마음이 없었다.&lt;/p&gt;

&lt;p&gt;올봄에 부숴도 좋은 장난감을 만드는 마음으로 프로젝트를 생각해보다가 “한글 맞춤법 검사기”를 시작했다. 난 맞춤법을 종종 틀렸고 Grammarly를 사용하면서 한글도 지원되면 좋겠다고 생각했다. 맞춤법 스트레스에 소셜미디어에 긴 글을 올리지는 못했는데, 지금은 비교적 편하게 올리고 있다.&lt;/p&gt;

&lt;p&gt;현재 무료로 맞춤법 검사기를 제공하는 웹 사이트들은 대부분 HTTP 기반으로 동작한다. 회사 게시판에서 이 무료 맞춤법 검사 사이트 중 하나를 추천하는 글을 읽었다. HTTP는 보안에 취약하다. 공개하면 안 되는 중요한 글에 HTTP 기반 API를 사용하는 건 무엇인가 잘못된 것 같았다. “한글 맞춤법 검사기”도 HTTP 기반 사람인 API를 사용하기 때문에, Grammarly처럼 모든 입력창에 활성화 시키진 않았다. 내장 맞춤법 검사기를 구현하고 보안이 중요한 메일 등 다른 입력창에서도 사용할 수 있게 할 계획이다.&lt;/p&gt;

&lt;p&gt;아직 사용자는 많지 않지만, 작업할 때 즐겁고 만족스럽다. 개인 프로젝트는 내가 즐겁고 만족하면 된 거다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://book.naver.com/bookdb/book_detail.nhn?bid=6332442&quot;&gt;프로그래머의 길, 멘토에게 묻다.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://summernote.org/&quot;&gt;https://summernote.org&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.grammarly.com/&quot;&gt;https://www.grammarly.com/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/cdaobjknnljdidejlgjlmmkfjaglnfll&quot;&gt;한글 맞춤법 검사기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>hackerwins</name><email>susukang98@gmail.com</email></author><category term="toy-project" /><summary type="html">책 “프로그래머의 길, 멘토에게 묻다.”의 “부숴도 괜찮은 장난감”에서는 프로그래밍을 효과적으로 학습하기 위해서 개인 프로젝트를 시작하라 조언한다. 프로젝트의 결과물은 언제든 부술 수 있는 장난감 같은 프로그램이기 때문에 기능을 쉽게 추가하고 구조를 마음대로 변경할 수 있는 놀이터가 생긴 셈이다. 다들 장난감 프로젝트를 시작할 때에는 너무 거창한 계획을 세우기보다는 당장 내가 필요한 작은 프로그램을 만들라고 조언한다.</summary></entry><entry><title type="html">Google Docs 같은 실시간 협업 에디터를 만드는 방법</title><link href="/2019-04-16/co-editor" rel="alternate" type="text/html" title="Google Docs 같은 실시간 협업 에디터를 만드는 방법" /><published>2019-04-16T23:18:00+00:00</published><updated>2019-04-16T23:18:00+00:00</updated><id>/2019-04-16/co-editor</id><content type="html" xml:base="/2019-04-16/co-editor">&lt;h2 id=&quot;실시간-협업-애플리케이션&quot;&gt;실시간 협업 애플리케이션&lt;/h2&gt;

&lt;p&gt;이제는 실시간 협업 애플리케이션이 많은 사용자에게 익숙하다. 대표적인 예로는 Google Docs가 있다. Google Docs는 동시에 여러 명의 사용자가 문서 하나를 수정할 수 있다. 각자 수정하는 문서를 메일로 서로 주고받고 취합할 필요가 없으니 매우 편리하다. 다수의 사람이 동시에 편집해도 결과적으로 문서의 내용은 같아진다. 이런 특징을 Convergence(수렴)라고 부른다.&lt;/p&gt;

&lt;h3 id=&quot;실시간-협업-애플리케이션의-구조-optimistic-replication&quot;&gt;실시간 협업 애플리케이션의 구조 (Optimistic replication)&lt;/h3&gt;

&lt;p&gt;Google Docs와 같은 실시간 협업 애플리케이션의 구조는 Git과 유사하다. 우리는 Git을 사용할 때, 먼저 Local 저장소에 작업한 변경사항을 Commit하고 시간이 흐른 뒤 어느 정도 작업이 완료되면 다른 동료에게 작업한 내용을 공유하기 위해서 Commit을 Remote 저장소에 Push한다. 하지만 Git에서는 Remote 저장소에 먼저 추가된 또 다른 Commit이 있을 때, 해당 브렌치를 Pull한 뒤 Merge conflict가 발생하면 이를 손으로 직접 해결한다.&lt;/p&gt;

&lt;p&gt;이런 스타일의 복제 전략을 취한 시스템을 Optimistic replication system이라고 부르는데, Optimistic replication은 복제본의 내용이 잠시 달라지는 것을 허용하는 복제 전략이다. Optimistic replication system의 구조는 아래와 같은 그림으로 표현할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[사용자 A] -&amp;gt; [사용자 A의 복제본] &amp;lt;- (Operations) -&amp;gt; [사용자 B의 복제본] &amp;lt;- [사용자 B]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사용자 A는 로컬에서 복제본(Replica)을 먼저 직접 편집하고 같은 문서를 열고 있는 사용자 B의 복제본과 동기화하기 위해서 나중에 로컬 변경사항(Operation)을 전송한다.&lt;/p&gt;

&lt;p&gt;Google Docs에서는 백그라운드에서 이런 종류의 변경사항을 지속해서 전송한다. (5G나 Google Stadia를 보면 미래에는 모르겠지만) 여기에서는 네트워크 지연시간을 고려해야 하는데, 사용자가 편집할 때 변경사항을 전송하고 응답받은 뒤 문서를 업데이트해서 화면에 그리면 사용자는 느리다고 느낄 것이다. 그래서 Google Docs에서는 사용자가 텍스트를 타이핑하면 즉시 변경사항을 로컬 메모리에 있는 복제본에 먼저 반영한 뒤 화면에 표현하고 이후에 비동기적으로 변경사항을 원격지의 복제본에 반영한다. 이 구조 때문에 편집하고 있는 화면에 변경사항이 지연 없이 바로 반영된다.&lt;/p&gt;

&lt;h3 id=&quot;실시간-협업-애플리케이션의-동작-방식-eventual-consistency&quot;&gt;실시간 협업 애플리케이션의 동작 방식 (Eventual consistency)&lt;/h3&gt;

&lt;p&gt;이렇게 한 노드가 다른 노드의 편집과 상관없이 독립적으로 먼저 로컬 데이터를 수정하고 나중에 원격지에 다른 노드와 데이터를 동기화한다면, 동시성 문제를 생각해야 한다. 특히 한 노드가 시스템의 다른 노드와 단절되는 네트워크 파티션이 발생하거나 오프라인 상태에서는 이 문제는 더 분명히 드러난다. 사용자는 메모리에 저장된 문서의 로컬 복제본을 계속해서 편집하고 있지만, 인터넷 연결이 끊어져서 변경사항을 다른 사용자에게 전송할 수 없게 된다. 이 상황에는 우선 로컬 복제본을 계속해서 편집하고 사용자의 화면에 반영해서 프로그램이 잘 동작하는 것처럼 보이게 하고 나중에 네트워크가 복구되면 로컬에 쌓아둔 변경사항을 원격지의 다른 사용자에게 전송한다. 이럴 때도 각자 수정하고 있는 문서가 충돌 없이 병합되어야 한다.&lt;/p&gt;

&lt;p&gt;협업 텍스트 에디터의 예를 들면 아래와 같은 상황을 생각해볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;초기상태: &quot;안녕.&quot;

~~ 네트워크 단절 ~~

사용자 A: &quot;안녕 Summernote.&quot;
사용자 B: &quot;안녕. (^_^)&quot;

~~ 네트워크 복구 ~~

결과상태: &quot;안녕 Summernote. (^_^)&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Git에서는 이런 상황에 Merge Conflict가 발생해서 수동으로 충돌을 수정해야 하지만 Google Docs에서는 충돌을 해결하는 팝업 같은 게 나오지는 않는다. Google Docs가 이 충돌을 자동으로 해결하기 때문에 여러 사용자가 하나의 문서를 실시간으로 함께 편집할 수 있다.&lt;/p&gt;

&lt;p&gt;위 예제를 자세히 살펴보면, 사용자 A는 “안녕”과 “.” 사이에 “Summernote”라는 텍스트를 입력했고 사용자 B는 “.” 뒤에 “ (^_^)”를 입력했는데, 결과적으로 데이터가 같아진다. 특정 시점에는 내용이 서로 달랐지만, 결과적으로 같아지는 이런 스타일의 Consistency Model을 Eventual consistency라고 부른다. 동기화 시에 두 사용자의 텍스트 삽입 의도가 모두 반영되어 있으므로 결과상태가 적절해 보인다.&lt;/p&gt;

&lt;p&gt;분산 시스템에는 Consul, Zookeeper 같은 애플리케이션에서 사용하는 노드 간에 합의를 위한 Paxos, Raft 같은 Consensus 알고리즘도 있는데, 겉보기에는 협업 애플리케이션과 구조가 유사해 보이지만 해결하고 있는 문제는 매우 다르다. 네트워크 파티션 상황에 Consensus 알고리즘이 하나가 선택되고 나머지가 취소되어 버려지는 반면에, 협업 애플리케이션의 알고리즘은 여러 사용자의 의도를 모두 반영하면서 병합(Merge)한다.&lt;/p&gt;

&lt;h3 id=&quot;operation-디자인하기&quot;&gt;Operation 디자인하기&lt;/h3&gt;

&lt;p&gt;우리가 개발하고 있는 애플리케이션은 데이터를 Counter, Text, Set, Hashtable, JSON등 다양한 데이터타입으로 표현한다. 먼저 가장 간단한 카운터를 대상으로 변경사항인 Operation을 디자인해보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;초기상태: 1

~~ 네트워크 단절 ~~

사용자 A: 1 (+1) = 2 // Increase(1)
사용자 B: 1 (+2) = 3 // Increase(2)

~~ 네트워크 복구 ~~

기대하는 결과상태: 1 (+1) (+2) = 4
사용자 A: 2 (+2) = 4 // 사용자 B의 Increase(2) 반영
사용자 B: 3 (+1) = 4 // 사용자 A의 Increase(1) 반영
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 예제를 자세히 살펴보면, 사용자 A는 초기상태 1에 1을 더해서 2가 되었고 사용자 B는 1에 2을 더해서 3라는 결과를 화면에서 보았다. 이 상황을 동기화했을 때, 2나 3으로 끝내지 않고 두 사용자의 Increment 의도를 모두 반영해서 4이라는 결과상태로 마무리하는 것이 적절해 보인다.&lt;/p&gt;

&lt;h3 id=&quot;operation을-디자인할-때-고려할-것-convergence-문제&quot;&gt;Operation을 디자인할 때 고려할 것 (Convergence 문제)&lt;/h3&gt;

&lt;p&gt;이렇게 충돌을 자동으로 해결하는 시스템을 디자인할 때, 조금 더 생각해볼 문제가 있는데, 다시 텍스트 예제로 돌아가보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;초기상태: &quot;안녕.&quot;

~~ 네트워크 단절 ~~

사용자 A: &quot;안녕 Summernote.&quot; // Insert(2, &quot; Summernote.&quot;)
사용자 B: &quot;안녕. (^_^)&quot;  // Insert(3, &quot; (^_^)&quot;)

~~ 네트워크 복구 ~~

기대한 결과상태: &quot;안녕 Summernote. (^_^)&quot;
사용자 A: &quot;안녕  (^_^)Summernote.&quot; // 사용자 B의 Operation Insert(3, &quot; (^_^)&quot;) 반영
사용자 B: &quot;안녕 Summernote. (^_^)&quot;  // 사용자 A의 Operation Insert(2, &quot;Summernote.&quot;) 반영
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 예제에서는 Integer Index를 이용해서 Insert Operation을 디자인 했는데, 사용자 A와 사용자 B가 네트워크가 복구한 뒤에 각자의 변경사항을 반영한 결과가 서로 달라질 수 있는 경우를 볼 수 있다. Increase Operation 경우 교환 법칙(commutative property)을 만족하지만, 위에 디자인한 Insert Operation은 만족하지 않는다. 이런 경우 문서의 상태가 갈라져서(divergence) 전체 문서를 주고 받지 않는 이상 다시는 동기화할 수 없게 된다.&lt;/p&gt;

&lt;h3 id=&quot;convergence수렴-문제를-해결하는-방법들&quot;&gt;Convergence(수렴) 문제를 해결하는 방법들&lt;/h3&gt;

&lt;p&gt;지금까지 실시간 협업 애플리케이션의 구조와 이런 시스템을 디자인할 때 해결해야 하는 문제에 대해 알아봤다. 이런 수렴 문제를 해결할 수 있는 알고리즘의 큰 분류에는 OT(Operational Transformation)와 CRDT(Conflict-free replicated data type)가 있다. 사실 OT의 한 알고리즘이 Google Docs 내부에 사용된다. 수렴 문제를 해결하는 알고리즘을 설계하는 것은 어려운 일인데, 일부 OT 알고리즘은 논문 발표 이후에 수렴을 만족하지 못한다는 것이 알려지기도 했다.&lt;/p&gt;

&lt;p&gt;그리고 이 수렴 문제를 데이터 타입에 추상화해서 간단히 한 CRDT가 있다. CRDT 위키백과에서 다양한 데이터타입들, 카운터 타입인 G-Counter, PN-Counter, 셋 타입인 G-Set, 2P-Set, 리스트 타입인 RGA등 다양한 데이터타입을 볼 수 있다. CRDT도 특징에 따라 Operation-based CRDTs와 State-based CRDTs로 나뉘는데, 이 중 Operation-based CRDT는 교환 법칙의 특성을 활용해서 Concurrent 수정의 Operation의 경우 순서가 뒤바뀌어서 실행되어도 동일한 결과 상태가 나오도록 하는 전략을 취한다.&lt;/p&gt;

&lt;p&gt;다음 챕터에는 실시간 협업 에디터를 구현할 수 있는 RGATreeSplit에 대해 알아보는데, 이 데이터타입은 Operation-based CRDTs의 한 종류이다.&lt;/p&gt;

&lt;h2 id=&quot;실시간-협업-에디터를-구현할-수-있는-데이터-타입&quot;&gt;실시간 협업 에디터를 구현할 수 있는 데이터 타입&lt;/h2&gt;

&lt;p&gt;먼저 텍스트 에디터의 텍스트를 표현할 수 있는 RGA에 대해서 알아보자.&lt;/p&gt;

&lt;h3 id=&quot;linkedlist&quot;&gt;LinkedList&lt;/h3&gt;

&lt;p&gt;동작 원리를 간단히 알아보기 위해서 텍스트를 문자(Character)를 원소로 가진 연결형 리스트라고 생각해보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[&quot;안&quot;] -&amp;gt; [&quot;녕&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;“안녕”이라는 문자열을 예로들면 위와 같은 리스트라고 생각해 볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;초기상태: [&quot;안&quot;] -&amp;gt; [&quot;녕&quot;]

~~ 네트워크 단절 ~~

사용자 A: [&quot;안&quot;] -&amp;gt; [&quot;녕&quot;] -&amp;gt; [&quot;.&quot;]
사용자 B: [&quot;방&quot;] -&amp;gt; [&quot;갑&quot;] -&amp;gt; [&quot;안&quot;] -&amp;gt; [&quot;녕&quot;]

~~ 네트워크 복구 ~~

결과상태: [&quot;방&quot;] -&amp;gt; [&quot;갑&quot;] -&amp;gt; [&quot;안&quot;] -&amp;gt; [&quot;녕&quot;] -&amp;gt; [&quot;.&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 같은 편집의 경우 커서를 서로 다른 위치에 두고 사용자 A는 “안녕” 뒤에 “.”를 입력했고 사용자 B는 “안녕” 앞에 “방갑”을 입력했기 때문에 결과상태에 문제가 없다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;초기상태: [&quot;안&quot;] -&amp;gt; [&quot;녕&quot;]

~~ 네트워크 단절 ~~

사용자 A: [&quot;안&quot;] -&amp;gt; [&quot;녕&quot;] -&amp;gt; [&quot;.&quot;]
사용자 B: [&quot;안&quot;] -&amp;gt; [&quot;녕&quot;] -&amp;gt; [&quot;!&quot;]

~~ 네트워크 복구 ~~

결과상태: [&quot;안&quot;] -&amp;gt; [&quot;녕&quot;] -&amp;gt; [&quot;.&quot;] -&amp;gt; [&quot;!&quot;] // [&quot;.&quot;]와 [&quot;!&quot;]의 순서를 결정해야 함
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 두 번째 예제의 경우 같은 위치인 &lt;code class=&quot;highlighter-rouge&quot;&gt;[&quot;녕&quot;]&lt;/code&gt; 뒤에 사용자 A, B가 값을 입력한다면 사용자 A의 &lt;code class=&quot;highlighter-rouge&quot;&gt;[&quot;.&quot;]&lt;/code&gt;와 사용자 B의 &lt;code class=&quot;highlighter-rouge&quot;&gt;[&quot;!&quot;]&lt;/code&gt;의 순서를 결정해야 한다. 그래서 순서를 결정할 수 있는 장치가 필요하다. 이를 RGA에서는 분산 시스템에서 사용하는 논리시계를 이용해서 처리했다.&lt;/p&gt;

&lt;h3 id=&quot;logical-clock&quot;&gt;Logical Clock&lt;/h3&gt;

&lt;p&gt;분산 시스템에서 각 노드의 시계를 정확하게 똑같이 동기화하는 건 매우 어려운 문제이다. 특정 시간을 노드에 전송해서 동기화하려고 해도 이 전송에 지연시간이 발생하고 각각이 정확히 얼마나 걸릴지 모르기 때문이다. 또 물리 시계를 정확하게 똑같이 동기화 할 수 있다고 하더라도 동일한 시간에 발생한 이벤트의 순서를 결정해야 했다. 분산 시스템에는 이런 문제를 해결할 수 있는 Lamport clock과 같은 논리시계가 있는데, 시스템 내에 발생한 이벤트들을 시스템 내부 전체에서 유일한 순서(Total order)를 정의할 수 있다.&lt;/p&gt;

&lt;p&gt;여기에서는 대표적인 논리시계인 Lamport clock을 활용해서 이벤트의 순서를 정하는 방법에 대해 알아본다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2019-04-17-co-editor/image02.png&quot; alt=&quot;image02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;출처: “멀티 디바이스 동기화 플랫폼과 분산시스템의 기초” - 노현걸&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;가장 우측 그림은 노드 1, 2가 있을 때, 발생할 수 있는 이벤트의 예를 보여준다. 가장 좌측 그림의 실선은 인과(Casual) 관계, 점선은 Concurrent 관계를 표현했다. 가운데 그림은 이 이벤트 들의 Total Order를 보여준다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Clock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clockA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Clock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clockB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compare&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clockA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;timestamp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clockB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;timestamp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clockA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nodeId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clockB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nodeId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;논리 시계인 Clock이 timestamp와 nodeId를 갖고 있다고 가정하면 분산 시스템 내에서 발생한 전체 이벤트의 순서를 위 함수로 알아낼 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;rga-linkedlist--logical-clock&quot;&gt;RGA: LinkedList + Logical Clock&lt;/h3&gt;

&lt;p&gt;이런 논리 시계를 도입 했다고 가정하면 이전 데이터를 다음과 같이 표현할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;반영 전: [&quot;안&quot;] -&amp;gt; [&quot;녕&quot;]
반영 후: [T1-A: &quot;안&quot;] -&amp;gt; [T2-A: &quot;녕&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;요소(Element)에 값 외에 논리 시계가 추가되었는데, 이 논리 시계는 요소를 삽입한 논리적 시간을 나타낸다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;초기상태: [T1-A: &quot;안&quot;] -&amp;gt; [T2-A: &quot;녕&quot;]

~~ 네트워크 단절 ~~

사용자 A: [T1-A:&quot;안&quot;] -&amp;gt; [T2-A:&quot;녕&quot;] -&amp;gt; [T3-A:&quot;.&quot;]
사용자 B: [T1-A:&quot;안&quot;] -&amp;gt; [T2-A:&quot;녕&quot;] -&amp;gt; [T3-B:&quot;!&quot;]

~~ 네트워크 복구 ~~

결과상태: [T1-A:&quot;안&quot;] -&amp;gt; [T2-A:&quot;녕&quot;] -&amp;gt; [T3-A:&quot;.&quot;] -&amp;gt; [T3-B:&quot;!&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;같은 위치인 &lt;code class=&quot;highlighter-rouge&quot;&gt;[&quot;녕&quot;]&lt;/code&gt; 뒤에 사용자 A, B가 값을 입력했지만, 사용자 A의 &lt;code class=&quot;highlighter-rouge&quot;&gt;[&quot;.&quot;]&lt;/code&gt;와 사용자 B의 &lt;code class=&quot;highlighter-rouge&quot;&gt;[&quot;!&quot;]&lt;/code&gt;의 순서를 비교했을 때, 논리시계를 사용하므로 순서를 정할 수 있는데, 여기서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;T3-A&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;T3-B&lt;/code&gt;보다 앞선다고 가정하고 결과상태처럼 둘의 순서를 결정할 수 있다. 위 예제처럼 CRDT는 데이터를 표현하는 값외에 논리시계나 삭제를 표시하는 Tombstone과 같은 메타(Meta)가 더 포함된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;초기상태: [T1-A: &quot;안&quot;] -&amp;gt; [T2-A: &quot;녕&quot;]

~~ 네트워크 단절 ~~

사용자 A: [T1-A:&quot;안&quot;] -&amp;gt; [T2-A:&quot;녕&quot;] -&amp;gt; [T3-A:&quot;.&quot;] // InsertAfter(T3-A, T2-A, &quot;.&quot;)
사용자 B: [T1-A:&quot;안&quot;] -&amp;gt; [T2-A:&quot;녕&quot;] -&amp;gt; [T3-B:&quot;!&quot;] // InsertAfter(T3-B, T2-A, &quot;!&quot;)

~~ 네트워크 복구 ~~

기대한 결과상태: [T1-A:&quot;안&quot;] -&amp;gt; [T2-A:&quot;녕&quot;] -&amp;gt; [T3-A:&quot;.&quot;] -&amp;gt; [T3-B:&quot;!&quot;]
사용자 A: [T1-A:&quot;안&quot;] -&amp;gt; [T2-A:&quot;녕&quot;] -&amp;gt; [T3-A:&quot;.&quot;] -&amp;gt; [T3-B:&quot;!&quot;] // 사용자 B의 Operation InsertAfter(T3-B, T2-A, &quot;!&quot;) 반영
사용자 B: [T1-A:&quot;안&quot;] -&amp;gt; [T2-A:&quot;녕&quot;] -&amp;gt; [T3-A:&quot;.&quot;] -&amp;gt; [T3-B:&quot;!&quot;] // 사용자 A의 Operation InsertAfter(T3-A, T2-A, &quot;.&quot;) 반영
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;RGA는 요소의 ID로 논리 시계를 사용하는 리스트형 자료 구조라 생각할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;rgatreesplit&quot;&gt;RGATreeSplit&lt;/h3&gt;

&lt;p&gt;지금까지 알아본 RGA를 Text로 사용할 때 성능을 개선할 수 있는 포인트가 더 있는데, 로컬 실행 복잡도나 공간 복잡도를 개선한 버전이 RGATreeSplit이다. RGATreeSplit은 Apache commons에 있는 TreeList처럼 LinkedList 대신 Tree 구조를 도입해서 로컬 실행시간을 개선하고 각 요소에 문자가 아닌 문자열을 보관해서 공간을 작게 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2019-04-17-co-editor/image01.png&quot; alt=&quot;image01&quot; /&gt;
&lt;sup&gt;출처: rgasplit-group2016-11.pdf&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;좌측 Upstream은 Local에서 편집 실행시간, 우측 Downstream은 Remote에서 편집 실행시간을 뜻한다. Execution time이 낮을 수록 성능이 좋다.&lt;/p&gt;

&lt;h2 id=&quot;마무리&quot;&gt;마무리&lt;/h2&gt;

&lt;p&gt;지금까지 Google Docs와 같은 실시간 협업 애플리케이션의 구조에 대해 간략히 살펴보고 실시간 협업 에디터를 구현하는데, 사용할 수 있는 CRDT 데이터타입인 RGATreeSplit에 대해 알아봤다.&lt;/p&gt;

&lt;p&gt;CRDT는 협업 애플리케이션 뿐 아니라 지역적으로 떨어진 IDC 간에 DB를 Master-Master로 운영하는 Geo Distribution DB 시스템에도 활용된다(Redis Enterprise, Azure Cosmos DB).&lt;/p&gt;

&lt;p&gt;CRDT는 Facebook 규모의 Like Counter라든지 캐시등 다양한 형식으로도 활용할 수 있어 보인다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Optimistic_replication&quot;&gt;wiki/Optimistic_replication&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://raft.github.io/&quot;&gt;raft.github.io&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Lamport_timestamps&quot;&gt;wiki/Lamport_timestamps&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type&quot;&gt;wiki/Conflict-free_replicated_data_type&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://commons.apache.org/proper/commons-collections/apidocs/org/apache/commons/collections4/list/TreeList.html&quot;&gt;TreeList.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://csl.skku.edu/papers/jpdc11.pdf&quot;&gt;jpdc11.pdf&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pages.lip6.fr/Marc.Shapiro/papers/rgasplit-group2016-11.pdf&quot;&gt;rgasplit-group2016-11.pdf&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/ko-kr/azure/cosmos-db/how-to-multi-master&quot;&gt;https://docs.microsoft.com/ko-kr/azure/cosmos-db/how-to-multi-master&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://redislabs.com/redis-enterprise/&quot;&gt;https://redislabs.com/redis-enterprise/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>hackerwins</name><email>susukang98@gmail.com</email></author><category term="crdt" /><category term="editor" /><summary type="html">실시간 협업 애플리케이션</summary></entry><entry><title type="html">OpSets 요약</title><link href="/2018-11-08/opsets" rel="alternate" type="text/html" title="OpSets 요약" /><published>2018-11-08T01:33:00+00:00</published><updated>2018-11-08T01:33:00+00:00</updated><id>/2018-11-08/opsets</id><content type="html" xml:base="/2018-11-08/opsets">&lt;blockquote&gt;
  &lt;p&gt;“OpSets: Sequential Specifications for Replicated Datatypes (Extended Version).” 읽으면서 정리한 내용&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;요약&quot;&gt;요약&lt;/h2&gt;

&lt;p&gt;이 논문은 분산 시스템에서 최종적인 일관성(eventual consistency)의 복제 데이터타입(replicated datatype)을 구현한 프레임워크인 OpSets를 제안한다. 또 이런 유형의 데이터타입(CRDT)을 구현하는 알고리즘을 기계적으로 검증한다. 이는 간단하지만 표현력이 뛰어나므로 맵(map), 세트(set), 리스트(list), 텍스트(text), 그래프(graph), 트리(tree) 및 레지스터(register)를 비롯한 다양한 추상 데이터타입을 간단히 적용할 수 있다. 또 데이터타입을 복잡한 데이터 구조를 구성할 수 있다. 복제 알고리즘을 분석하기 위한 OpSet의 기능을 알아보기 위해, 이전부터 간과되었지만 협업 텍스트 편집에서 중요한 정확성(correctness property)에 대해 살펴본다. 정확성을 만족시키지 않는 알고리즘은 텍스트 공동편집시 의도하지 않은 글자가 삽입되는 현상이 나타난다. OpSets를 사용해서 정확성을 정의하고 기존 복제 알고리즘들이 정확성을 충족시키는지 확인한다. 또한 새로운 복제 된 데이터타입을 개발하는 데 OpSets를 사용하는 방법에 대해서 알아본다. 기존에는 잠금장치(Lock)를 사용하지 않고 구현하기 어려웠던 트리에서 원자적 이동 Operation에 대해 알아본다. 이 논문은 이전의 비공식 접근 방식의 모호함을 없애고 추론 오류를 배제하기 위해서 Isabelle/HOL 증명 도구를 사용해서 OpSets를 공식화하고 주요 주장의 정확성에 대해서 기계적으로 증명한다.&lt;/p&gt;

&lt;h2 id=&quot;1-도입&quot;&gt;1. 도입&lt;/h2&gt;

&lt;p&gt;공통적인 분산 시스템의 요구 사항은 여러 노드가 공유 데이터에 동시에 접근하고 조작하는 것이다. 예를 들어, 노트북을 사용하는 기자의 공유 텍스트 문서 작업부터 공통 데이터베이스를 조작하는 웹 서버들이 있다. 이때 공유 데이터가 일정한 일관성을 보장하도록 하는 것이 중요하다. 예를 들어 serializability 또는 linearizability와 같은 강력한 일관성 모델(strong consistency models)은 실제로 복제되고 동시에 실행되는 경우에도 시스템이 연속적으로 실행되는 단일 노드처럼 작동한다. 이 모델의 단점은 모든 동작이나 트랜잭션이 완료되기 전에 네트워크 통신을 기다려야 한다는 것이다. 따라서 일관성이 강한 시스템에서는 노드가 오프라인이거나 다른 노드들과 단절된 상태(network partition)에서 작업을 진행할 수 없다.&lt;/p&gt;

&lt;p&gt;반면에 최종적인 일관성은 각 참여자가 오프라인 상태에서 공유 데이터 구조의 로컬 복사본(replica)을 수정할 수 있지만 그 정의가 빈약하다. “공유 상태에 대한 새로운 업데이트가 없으면 모든 노드의 데이터는 결국 동일하다”에서 “새로운 업데이트가 없으면”이라는 전제는 공유 상태가 지속적으로 수정되면 (예를들어 시스템이 절대로 정지되지 않는 경우) 참이 될 수 없다. 또한 최종적인 일관성의 정의에는 최종 상태가 적합한지 여부를 명시하지 않았다.&lt;/p&gt;

&lt;p&gt;CRDT는 최근 몇 년 동안 주목을 받아온 복제된 상태의 추상화이다. CRDT의 주요 정확성(correctness property)은 수렴(convergence)이다. “두 개의 복제본이 동일한 업데이트들을 적용 할 때, 동일한 복제본이 다른 순서로 업데이트를 적용하더라도 동일한 상태로 수렴한다. 이는 최종적인 일관성보다 단단하지만, 수렴 상태가 정확히 무엇인지를 정의하지는 않았다.&lt;/p&gt;

&lt;p&gt;이 논문은 복제 된 데이터 형식적 의미론(Formal semantics)을 정의하고 동시에 데이터에 접근하거나 조작하기 위한 알고리즘에 대한 새로운 접근 방식, Operation Sets(OpSets for short)를 제안한다. OpSets은 일부 업데이트들이 적용된 후 복제본의 허용된 상태를 정확하게 정의하는 실행 가능한 스팩이다. 이 논문의 공헌은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2절에서는 동시 편집 데이터 구조의 일관성에 대한 지정 및 추론을 위한 간단한 추상화 OpSet을 소개한다.&lt;/li&gt;
  &lt;li&gt;3절과 5절에서는 OpSet의 다양한 추상 데이터타입(맵, 세트, 리스트, 텍스트, 그래프, 트리 및 레지스터)를 소개하며, 이 스펙이 간단하고 정확하다는 점에 대해 알아본다.&lt;/li&gt;
  &lt;li&gt;4절에서는 OpSet를 사용하여 기존 알고리즘을 추론하는 방법을 알아본다. 이 분야의 선행 연구에서 간과 되어온 협업 텍스트 편집을 위해 중요한 정확성(correctness property)에 대해 살펴본다. 이 논문 저자는 OpSet 스펙이 정확성을 올바르게 정의한 첫 번째라고 주장한다. 텍스트 편집 CRDT에서 정확성을 만족시키지 못하는 몇 가지 다른 사례들을 살펴본다.&lt;/li&gt;
  &lt;li&gt;5절에서는 OpSet를 사용하여 새로운 복제 된 데이터타입을 개발하는 방법에 대해 알아본다. 특히 트리 CRDT에서 원자 이동 Operation을 정의하는 방법을 소개한다. 이 작업은 트리 내의 새 위치로 하위 트리를 이동하거나 맵에서 키의 이름을 바꾸거나 리스트에서 항목의 순서를 변경하는 데 사용할 수 있다. OpSets 접근 방식은 그 동안 잠금장치(Lock) 없이 구현할 수 없던 작업을 간단하게 정의할 수 있다.&lt;/li&gt;
  &lt;li&gt;Isabelle/HOL 증명 도구를 사용하여 OpSets를 공식화하고 이 논문의 주요 주장의 정확성에 대한 기계화 된 증명을 산출한다. 특히 공동 텍스트 편집의 최근 스펙인 Attiya 보다 더 엄격하게 입증한다. 기계화 된 교정을 사용함으로써 이전의 비공식적 인 접근 방법의 모호성 없이 텍스트 수정에서 발생할 수있는 추론 오류를 배제한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-opsets-접근방식&quot;&gt;2. OpSets 접근방식&lt;/h2&gt;

&lt;p&gt;OpSets 접근방식은 복제 된 데이터 시스템의 일관성을 설명하기 위한 간단한 추상화이다. 이 절에서는 일반적인 접근 방식에 대해 알아보고 3절, 5절에서 구체적인 데이터 구조와 스펙을 설명한다.&lt;/p&gt;

&lt;h3 id=&quot;21-시스템-모델&quot;&gt;2.1 시스템 모델&lt;/h3&gt;

&lt;p&gt;대상 시스템은 네트워크에 연결된 노드 세트으로 구성된다. 각 노드는 관계형 데이터베이스(row를 갖은 테이블), 텍스트 문서(문자 시퀀스), 벡터 그래프 문서(그래프 개체의 레코드 트리), 파일 시스템(디렉토리, 파일의 트리) 등의 데이터에 접근한다.&lt;/p&gt;

&lt;p&gt;새 노드는 언제든지 추가 할 수 있으며 사전에 노드 세트을 알 필요는 없다. 노드는 모바일 장치와 같이 일시적으로 다른 노드와 통신 할 수 없다고 가정한다. 노드는 오프라인에서도 언제든지 공유 데이터(shared data)에 접근할 수 있어야한다. 따라서 각 노드는 공유 데이터의 로컬 사본(copy)을 가지며, 다른 노드와의 통신 또는 조정을 기다리지 않고 공유 데이터를 읽고 수정할 수 있다.&lt;/p&gt;

&lt;p&gt;노드가 공유 데이터를 수정하면 변경 사항을 Operation으로 기록한다. 예를 들어, 텍스트 문서의 특정 위치에 삽입을 Operation으로 표현한다. 각 노드는 로컬에 Operation의 세트, OpSet을 관리한다. 노드가 공유 데이터를 변경하면 OpSet에 해당 Operation을 추가하고 Operation이 포함된 메시지를 다른 노드에 전송한다. 노드가 다른 노드에서 메시지를 수신 하면, 해당 메시지의 Operation이 수신자의 로컬 OpSet에 추가된다. Operation은 전체 과정에서 변경되지 않는다(Immutable).&lt;/p&gt;

&lt;p&gt;네트워크의 신뢰성에 대해서는 아무런 가정을 하지 않는다. 메시지는 손실(lost)되거나 중복(duplicate)되거나 임의 순서(reordered)로 전달 될 수 있다. 실제 네트워크의 특성을 반영하여 가능한 경우 손실 된 메시지를 재전송한다고 가정하지만 (예 : TCP 사용) 네트워크 또는 노드 오류로 인해 메시지가 영구적으로 손실 될 수 있다. 각 노드의 OpSet은 단조롭게(monotonically) 증가하는 Operation 세트이므로 두 통신 노드는 표준 조합 연산자 ∪(Union)을 사용하여 OpSets를 병합 할 수 있다. OpSets의 합집합은 교환 법칙(commutative), 결합 법칙(associative), 멱등 법칙(idempotent)이 적용 되므로 통신중인 노드가 동일한 OpSet 내용으로 수렴(converge)된다.&lt;/p&gt;

&lt;p&gt;각 Operation은 고유 ID를 갖고 있으며, 모든 노드는 다른 노드와 통신하지 않고 새 ID의 생성이 가능하며 Operation ID는 전체 시스템에서 순서를 매길 수 있다고 가정한다(total ordering). 램포트 시계(Lamport timestamp)를 ID로 사용하면 이 요구 사항을 쉽게 충족시킬 수 있다. 램포트 시계는 다음과 같이 (counter, nodeID)로 구성된 쌍이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;counter는 정수(integer)다. Operation ID 생성시, 로컬 OpSet의 기존 Operation ID 중 최대값을 하나 증가시켜서 할당한다.&lt;/li&gt;
  &lt;li&gt;nodeID는 ID를 생성하는 노드를 고유하게 식별하는 문자열이다(예: UUID).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서로 다른 노드가 동일한 카운터 값을 갖는 ID가 생성될 수도 있지만, 각 노드는 엄격하게 단조롭게 증가하는 카운터 값으로 ID를 생성하므로 ID는 전역적으로 고유하다(nodeID가 고유하므로). Operation ID에 대한 전체 순서는 다음과 같이 정의한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image6.png&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;22-opset-해석하기&quot;&gt;2.2 OpSet 해석하기&lt;/h3&gt;

&lt;p&gt;대부분의 Operation 기반 CRDT는 노드의 로컬 상태가 Operation에 의해 어떻게 조작되는지를 기술하지만 이 논문은 복제된 데이터 타입을 다른 방식으로 설명한다.&lt;/p&gt;

&lt;p&gt;OpSets 접근 방식은 공유 데이터 구조가 직접 조작되지 않는다. 대신 OpSet &lt;code class=&quot;highlighter-rouge&quot;&gt;O&lt;/code&gt;를 해석 함수&lt;code class=&quot;highlighter-rouge&quot;&gt;[-]&lt;/code&gt;를 사용해서 공유 데이터의 현재 상태인 &lt;code class=&quot;highlighter-rouge&quot;&gt;[O]&lt;/code&gt;를 반환한다. 해석 함수(interpretation function)는 순수 함수, 즉 결정적(deterministic)이고, 부수효과가 없으므로(no side effect), 그 결과는 O에만 의존한다. 시스템의 모든 노드는 동일한 해석 함수를 사용한다.&lt;/p&gt;

&lt;p&gt;결과적으로 두 노드가 동일한 OpSet &lt;code class=&quot;highlighter-rouge&quot;&gt;O&lt;/code&gt;에 대해서 공유 데이터의 &lt;code class=&quot;highlighter-rouge&quot;&gt;[O]&lt;/code&gt;에 대한 값도 동일하다. 이 구성은 최종적인 일관성(eventual consistency)을 보장한다. 두 노드가 동일한 OpSet으로 수렴하므로 OpSet에서 결정적으로 파생 된 모든 데이터도 수렴한다(convergence).&lt;/p&gt;

&lt;p&gt;원칙적으로 결정적 함수(deterministic function)는 해석 함수로 사용될 수 있다. 그러나 CRDT의 의미론(semantics)을 정의 할 때(3절과 5절 참조) 한 번에 하나의 Operation을 해석하도록 &lt;code class=&quot;highlighter-rouge&quot;&gt;[-]&lt;/code&gt;를 분리하는 것(specialize)이 유용했다.&lt;/p&gt;

&lt;p&gt;OpSet &lt;code class=&quot;highlighter-rouge&quot;&gt;O&lt;/code&gt;는 페어&lt;code class=&quot;highlighter-rouge&quot;&gt;(id, op)&lt;/code&gt;의 세트이다. 여기서 id는 고유 한 Operation 식별자이고 op는 발생한 수정 내용의 설명이다. 2.1절에서 설명한 것처럼 식별자는 전체 순서가 보장된다고 가정한다. 임의의 OpSet에 대해서 모든 Operation들은 Operation ID에 의한 오름차순 순서가 있음을 알 수 있다. 해석 함수를 하나씩 적용할 때 각 Operation의 의미론을 정의할 수 있다.&lt;/p&gt;

&lt;p&gt;형식적으로 OpSet O의 해석 함수 &lt;code class=&quot;highlighter-rouge&quot;&gt;[O]&lt;/code&gt;는 다음과 같이 정의 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image17.png&quot; alt=&quot;image17&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서, &lt;code class=&quot;highlighter-rouge&quot;&gt;interp[S, (id, op)]&lt;/code&gt;는 상태 S의 Operation &lt;code class=&quot;highlighter-rouge&quot;&gt;(id, op)&lt;/code&gt; 해석이고, InitialState는 복제 데이터 타입의 최소 상태(예를 들어, 빈 트리 또는 빈 리스트)이다. 즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt;가 id보다 작은 식별자를 가진 모든 Operation을 해석 한 결과라면, &lt;code class=&quot;highlighter-rouge&quot;&gt;interp[S, (id, op)]&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;(id, op)&lt;/code&gt;가 추가 된 OpSet의 해석이다. 예를 들어, &lt;code class=&quot;highlighter-rouge&quot;&gt;id1 &amp;lt;id2 &amp;lt;id3&lt;/code&gt; 인 경우 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image4.png&quot; alt=&quot;image4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;OpSet의 Operation 순서가 고유하므로, 해석 &lt;code class=&quot;highlighter-rouge&quot;&gt;interp[S(id, op)]&lt;/code&gt;가 결정적이라면 OpSet 해석 함수 &lt;code class=&quot;highlighter-rouge&quot;&gt;[-]&lt;/code&gt;도 결정적이다.&lt;/p&gt;

&lt;h3 id=&quot;23-잘못된-순서로out-of-order-메시지-수신하기&quot;&gt;2.3 잘못된 순서로(out of order) 메시지 수신하기&lt;/h3&gt;

&lt;p&gt;많은 컴퓨팅 시스템들은 Operation들을 전체 순서로 추가하고 그 순서대로 실행 한다는 규칙을 기반으로 한다. 예를 들어, 직렬화 트랜잭션(serializable transactions)과 상태 머신 복제(state machine replication)는 이 접근법을 따른다. 그러나 2.2절에서 설명한 OpSet 해석은 대부분의 시스템보다 약한 순서 개념(weaker notion of ordering)을 사용한다는 점을 주목하자.&lt;/p&gt;

&lt;p&gt;직렬화 트랜잭션 이나 상태 머신 복제에서 트랜잭션/Operation의 특정 상태에서 실행한 결과는 내구성(durable)이 있어야 한다. 따라서, 특정 트랜잭션 Ti를 실행하기 전에, 시스템은 Ti보다 낮은 ID를 갖는 보류중인 트랜잭션 이 없는지 확인해야 한다(Ti보다 먼저 실행 되야함). 그렇지 않으면 이후 ID가 낮은 트랜잭션이 도착하면 Ti가 실행 된 상태가 무효화되기 때문이다. 그러나 이 전제 조건을 보장하는 것은 비용이 많이 든다. 6.1절에서 살펴보지만 적어도 노드 쿼럼과의 통신이 필요하다. ID가 램포트 시간이면 모든 단일 노드와의 통신이 필요하다. 많은 노드가 오프라인인 경우에는 시스템은 어떤 트랜잭션도 실행할 수 없다.
반대로 2.1절의 시스템 모델은 모든 노드가 오프라인 일 때도 노드가 항상 공유 데이터를 읽고 수정할 수 있다. 또한 네트워크에서 순서 보장을 가정하지 않는다. 특정 노드의 OpSet O에 특정 Operation &lt;code class=&quot;highlighter-rouge&quot;&gt;(id1, op1) ∈ O&lt;/code&gt;를 만족할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;(id2, op2)&lt;/code&gt;를 포함하는 메시지를 수신 할 수 있는데, 여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;id2 &amp;lt;id1&lt;/code&gt; 즉, 나중에 도착한 Operation을 OpSet 해석 &lt;code class=&quot;highlighter-rouge&quot;&gt;[O]&lt;/code&gt;의 기존 Operation &lt;code class=&quot;highlighter-rouge&quot;&gt;(id1, op1)&lt;/code&gt;보다 먼저 적용하는 것이 필요할 수 있다.&lt;/p&gt;

&lt;p&gt;OpSet 모델에서 이러한 비 순차적 인 Operation의 전달은 문제가 되지 않는다. Operation의 수신 순서는 OpSet O에는 아무런 영향을 미치지 않으며, 해석 함수가 순수하고 부수효과가 없다고 가정하기 때문에 해석 작업은 새로운 Operation이 O에 추가 될 때마다 항상 다시 계산된다(&lt;strong&gt;XXX: 실제품에 사용이 가능할까?&lt;/strong&gt;). 해석 함수는 일련의 Operation을 해석 할 때 예상되는 결과를 정의하는 실행 가능 스펙이다. 이 방식으로 복제 된 데이터타입을 구현하면 두 가지 중요한 이점이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다른 CRDT 알고리즘 정의와 다르게 해석 함수 &lt;code class=&quot;highlighter-rouge&quot;&gt;interp[S(id, op)]&lt;/code&gt;는 다른 Operation과 관련하여 commute할 필요가 없다. 어떤 순수한 함수도 사용할 수 있다. 이는 3절과 5절에서 볼 수 있듯이 Operation 해석을 기술하는 일이 훨씬 간단해진다.&lt;/li&gt;
  &lt;li&gt;기술한 각 데이터타입의 구현의 존재를 스펙 자체로 보장 할 수 있다. 이는 구현할 수 없는 공리적 명세와는 달리, 공리적 설명을 만족시키는 구현이 존재 함을 입증하기 위해 추가 작업이 필요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;노드가 잠재적으로 동일한 하위 Operation 세트을 반복적으로 적용하기 때문에 순수 OpSet 해설은 실제 구현보다 성능이 저하 될 수 있다. 따라서 OpSet 기반 스펙을 만족하고 CRDT의 효율적인 (그리고 아마도 가장 복잡한) 알고리즘의 구현은 4절에서 알아본다.&lt;/p&gt;

&lt;p&gt;OpSet 모델을 기반으로 실용적인 JavaScript CRDT 구현체를 개발했고 몇 가지 장점을 발견했다. 예를 들어, 문서의 모든 편집 버전이 해석이므로 문서의 편집 내역을 쉽게 검사 할 수 있다. 특정 작업의 하위 세트 또한, OpSets를 사용하면 누락 된 Operation이 이전에 단절된 노드의 OpSets에 재전송되어 추가 될 수 있으므로 네트워크 파티션, 장애로부터 복구 할 수 있는 간단한 메커니즘을 제공한다. 하지만 이 구현의 세부 사항은 이 논문의 범위를 벗어난다.&lt;/p&gt;

&lt;h2 id=&quot;3-리스트-맵-레지스터-그래프-정의하기&quot;&gt;3. 리스트, 맵, 레지스터, 그래프 정의하기&lt;/h2&gt;

&lt;p&gt;3장에서는 일반적 데이터구조(예: 사용자 지정 키와 값의 맵), 리스트(값의 선형 순서)과 같은 예제 의미를 정의하여 OpSets를 구체적으로 구현한다. 맵 데이터 타입은 세트도 표현할 수 있다(키를 세트의 구성원으로 사용하고 값을 무시). 리스트 데이터 유형은 텍스트로 표현할 수 있다(각 문자를 리스트 요소에 매핑). 리스트와 맵 모두 값은 기본형 데이터(숫자, 문자열)나 다른 맵 또는 리스트에 대한 참조 이다. 이러한 참조를 사용하여 객체 지향 프로그래밍 언어에서 처럼 임의의 객체 그래프를 구성 할 수 있다. 5장에서는 이 객체 그래프를 트리로 제한하는 방법을 알아본다.&lt;/p&gt;

&lt;p&gt;맵의 키와 리스트의 요소는 다중 값 레지스터(multi-value register)로 처리한다. 즉, 동일한 맵 키 또는 리스트 요소에 여러 값이 동시에 할당되는 경우, 쓰여지는 모든 값을 유지한다. 이 때문에, 맵 키 또는 리스트 요소를 읽어는 일은, 유저가 명시적으로 병합할 수 있도록 복수의 값을 반환할 수 있다. 맵 키 또는 리스트 요소에 새 값을 할당하면 이전의 모든 값(casually preceding value)을 덮어 쓴다. last-writer-wins(동시에 작성된 값 중 하나를 승자로 선택)와 같은 레지스터 동작을 쉽게 정의 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;31-operation-생성하기&quot;&gt;3.1 Operation 생성하기&lt;/h3&gt;

&lt;p&gt;일반적 데이터 구조의 OpSet에는 다음과 같이 6가지 유형의 Operation이 포함된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(id, MakeMap)&lt;/code&gt;은 id로 식별되는 비어있는 새 맵 객체를 만든다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(id, MakeList)&lt;/code&gt;는 id로 식별되는 비어있는 새 리스트 객체를 만든다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(id, MakeVal(val))&lt;/code&gt;는 id로 식별되는 기본형 값 val(i.g.: 숫자, 문자열 또는 boolean)을 할당한다. 이 Operation은 값을 감싸는데 사용하며 값으로 기본형 혹은 맵 또는 리스트에 대한 참조로 갖는다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(id, InsertAfter(ref))&lt;/code&gt;는 id로 식별되는 새 요소를 만들어서 리스트에 삽입한다. ref가 MakeList Operation의 ID 인 경우, 새로운 요소가 리스트의 head에 삽입된다. 혹은 ref는 기존 리스트 요소의 ID(예: InsertAfter Operation)이어야 하며, 이 경우 새 리스트 요소는 참조한 요소 바로 다음에 삽입된다. InsertAfter Operation에서는 값을 새 요소에 할당하지 않고 이는 Assign Operation에 의해 수행된다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(id, Assign(obj, key, val, prev))&lt;/code&gt;는 맵의 키에 새로운 값을 할당한다(obj가 이전 MakeMap Operation의 ID 인 경우) 또는 list 요소(obj가 MakeList Operation). 맵 할당의 경우 key는 업데이트 할 사용자 지정 키이며 문자열 또는 정수와 같은 기본 값이 된다. 리스트의 경우, key는 갱신 할 리스트 요소의 ID(즉, 이전의 InsertAfter Operation의 ID)이다. val은 값의 ID이며 MakeMap, MakeList 또는 MakeVal Operation을 식별 할 수 있다. prev는 동일한 객체의 동일한 키에 대한 이전 Assign Operation 들의 ID 세트이며 현재 Operation으로 덮어 쓴다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(id, Remove(obj, key, prev))&lt;/code&gt;는 맵에서 키-값 쌍을 제거하거나 리스트에서 요소를 제거한다. 할당과 마찬가지로 obj는 업데이트한 객체를 생성 한 이전 MakeMap 또는 MakeList Operation의 ID이며 key는 제거할 키 또는 리스트 요소를 식별한다. prev는 동일한 객체의 동일한 키에 대한 이전 Assign Operation의 ID 세트이며 현재 Operation에 의해 제거된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 Operation 생성의 의사 코드는 부록 A에 있다.&lt;/p&gt;

&lt;h3 id=&quot;32-operation-해석하기&quot;&gt;3.2 Operation 해석하기&lt;/h3&gt;

&lt;p&gt;2.2절에서 주어진 순차적 OpSet 해석을 사용한다. map 및 list 데이터 구조의 현재 상태를 인코딩하기 위해 관계 페어(E, L)를 사용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요소 관계 &lt;code class=&quot;highlighter-rouge&quot;&gt;E ⊆ (ID × ID × (ID ∪ Key) × ID)&lt;/code&gt;: 맵 키와 리스트 요소에 현재 할당 된 값을 포함하는 4-튜플 세트. &lt;code class=&quot;highlighter-rouge&quot;&gt;(id, obj, key, val) ∈ E&lt;/code&gt;이면 id를 가진 Assign Operation은 obj를 가진 객체를 업데이트하여 val 값을 map key 또는 list element key에 할당한다. Obj가 리스트 오브젝트를 참조하면, key는 리스트 관계 L에있는 요소의 ID이다(아래 참조). Obj 객체를 참조하는 경우 문자열이나 정수와 같은 기본형을 키로 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;리스트 관계 &lt;code class=&quot;highlighter-rouge&quot;&gt;L ⊆ (ID × (ID ∪ {⊥}))&lt;/code&gt;: 리스트 요소의 순서를 나타내는 페어의 세트이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;(prev, next) ∈ L&lt;/code&gt;이라면, prev를 갖는 리스트 요소 바로 다음에 ID가 next 인 요소가 뒤따라 온다. &lt;code class=&quot;highlighter-rouge&quot;&gt;(last, ⊥) ∈ L&lt;/code&gt;을 사용하여 리스트 요소에 마지막임을 알 수 있다. head는 리스트 obj의 첫 번째 요소이고 (obj는 리스트를 생성 한 MakeList Operation의 ID) &lt;code class=&quot;highlighter-rouge&quot;&gt;(obj, head) ∈ L&lt;/code&gt;을 가진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;초기에는 두 관계가 비어 있다. 즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;[∅] = InitialState = (∅, ∅)&lt;/code&gt;이다. 그리고 다음과 같이 여섯 가지 Operation 유형의 해석을 정의한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image10.png&quot; alt=&quot;image10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Assign, Remove의 해석은 &lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt;만 업데이트하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;은 변경하지 않는다. 반대로 InsertAfter와 MakeList의 해석은 &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;만 업데이트 한다. Assign, Remove 해석은 튜플을 인과 관계로 이전 Assign(prev의 ID가 ID로 표시되는 튜플)에서 제거하지만 동시 할당의 튜플은 변경하지 않는데 이는 다중 값 레지스터의 동작이다. last-writer-wins 레지스터가 필요한 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;id’ ∈/ prev&lt;/code&gt; 조건을 &lt;code class=&quot;highlighter-rouge&quot;&gt;obj’ != obj ∨ key’ != key&lt;/code&gt;로 변경하면 동일한 객체 ID와 키를 가진 기존 튜플을 제거 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image2.png&quot; alt=&quot;image2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;InsertAfter의 해석은 그림 1 에서처럼 링크 된 목록에 삽입하는 것과 유사하다.
예를 들어, &lt;code class=&quot;highlighter-rouge&quot;&gt;(id, InsertAfter(ref))&lt;/code&gt;를 해석하기 위해서, &lt;code class=&quot;highlighter-rouge&quot;&gt;(ref, next) ∈ L&lt;/code&gt;가 주어지면, &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;에서 페어 &lt;code class=&quot;highlighter-rouge&quot;&gt;(ref, next)&lt;/code&gt;을 제거하고 페어 &lt;code class=&quot;highlighter-rouge&quot;&gt;(ref, id)&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;(id, next)&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;에 추가한다. 따라서 새 리스트 요소 id가 ref와 next 사이에 삽입된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;은 축소되지 않으며 InsertAfter Operation을 해석하면 커진다. 리스트의 요소가 Remove Operation에 의해 제거되면 요소 관계 &lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt;의 리스트 요소에서 값은 제거되지만 요소는 tombstone(삭제 표시)으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;에 남아 있기 때문에 동시에 발생한 InsertAfter Operation에서 여전히 해당 값을 찾을 수 있다. 따라서 사용자의 관점에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt; 요소 관계에 적어도 하나의 연관된 값이 있으면 리스트 요소만 존재한다. 연관된 값이 없는 모든 리스트 요소는 무시되어야한다.&lt;/p&gt;

&lt;h3 id=&quot;4-텍스트-편집-병합하기&quot;&gt;4. 텍스트 편집 병합하기&lt;/h3&gt;

&lt;p&gt;3장에서 설명한 데이터타입은 광범위한 애플리케이션에 사용할 수 있다. 예를 들어 리스트 데이터 타입을 사용하여 협업 텍스트 편집기를 구현할 수 있다. 텍스트를 개별 문자 리스트로 처리하고 모든 편집을 리스트에 삽입 또는 삭제 Operation의 순서로 표현한다.&lt;/p&gt;

&lt;p&gt;협업 텍스트 편집 문제는 OT와 CRDT라는 두 가지 주요 접근법으로 연구되었다. 6장에서 알아본다. 이제 협업 텍스트 편집에 대해 이전 작업에서 고려하지 않은 시나리오에 대해 알아본다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image7.png&quot; alt=&quot;image7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 2의 예제에서는 두 명의 사용자가 초기 상태가 “Hello!”라는 텍스트 문서를 동시에 편집하고 있다. 왼쪽 사용자가 “Hello Alice!”로 변경하고 오른쪽 사용자는 문서를 “Hello Charlie!”로 변경한다. 동시 편집 내용이 병합되면 알고리즘에 따라 “Alice”와 “Charlie”의 두 삽입이 문자별로 임의로 인터리빙(interleaving)되면 뜻이 모호한 문자가 된다. 동시 삽입이 단 하나의 단어가 아니라 전체 단락이나 섹션이라면 문제는 더욱 심각한데, 사용자의 삽입을 인터리빙하면 대부분 이해할 수 없는 텍스트가 남아서 다시 작성해야 한다. 그림 2의 병합은 정상 동작은 아니지만 이런 인터리빙 삽입을 제외하는 협업 텍스트 편집의 공식 스펙은 없다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image18.png&quot; alt=&quot;image18&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정리 1. Attiya et al.의 협업 텍스트 Astrong 스펙은 그림 2의 결과가 된다. 즉, 동시 삽입을 동일한 위치에 인터리빙하는 알고리즘은 Astrong 스펙을 만족시킨다. 또한 텍스트 편집 CRDT 알고리즘 인 Logoot 및 LSEQ도 이 결과가 반영된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image8.png&quot; alt=&quot;image8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;증명. 각 문자를 전체 정렬한 식별자 공간(total ordered identifier space)에서 위치를 할당하는 아이디어에 기반한 각각의 정의에서 식별자의 순서가 문서의 문자 순서와 일치한다. 새로운 문자가 삽입되면 이전 문자와 후속 문자의 식별자 사이에 있는 식별자가 할당된다. 그러나 동일한 전임-후임 요소의 Operation을 가진 동시 삽입이 수행 될 때 이러한 삽입은 임의로 정렬된다. 따라서 동일한 전임-후임 요소 내에서 반복되는 삽입은 임의로 인터리빙 될 수 있다.&lt;/p&gt;

&lt;p&gt;또한 Logoot와 LSEQ의 오픈 소스 구현을 사용하여 테스트를 수행했을 때 이러한 인터리빙이 실제로 발생하는 것을 관찰했다.&lt;/p&gt;

&lt;p&gt;더 나은 방법은 특정 사용자의 모든 삽입을 연속 시퀀스로 유지해서 문자를 인터리빙하지 않고 병합하는 것이다. 이 조건에서는 그림 2의 예가 “Hello Alice Charlie!”또는 “Hello Charlie Alice!”라는 두 가지 병합된 결과가 된다. 이 두 결과 간의 선택은 임의적이다. 한 사용자의 삽입이 다른 것보다 먼저 오기 위한 사전 요구 사항이 없기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image9.png&quot; alt=&quot;image9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정리 2. 3절의 리스트 스펙은 동시 삽입의 인터리빙을 허용하지 않는다. 즉, 한 사용자가 문자 시퀀스 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;x1, x2,. . . , xn&amp;gt;&lt;/code&gt; 삽입하고 다른 사용자는 동시에 문자 시퀀스 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;y1, y2,. . . , ym&amp;gt;&lt;/code&gt;을 같은 위치에 삽입한 경우 병합 문서에는 문자 시퀀스 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;x1, x2,. . . , xn, y1, y2,. . . , ym&amp;gt;&lt;/code&gt; 또는 문자 시퀀스 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;y1, y2 ,. . . , ym, x1, x2,. . . , xn&amp;gt;&lt;/code&gt; 의 결과가 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image5.png&quot; alt=&quot;image5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;증명. Isabelle/HOL 증명 도구를 사용하여 리스트 스펙과 정리 2를 형식화했다. 형식 증명 구현은 부록 C.3에 요약했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image11.png&quot; alt=&quot;image11&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 3은 인터리빙의 제거 이유를 설명한 그림 2와 유사한 편집 시나리오지만 “Alice”와 “Charlie”의 삽입은 각각 “Al”과 “Ch”로 단축했다. 이 예제에는 여섯 가지 가능한 방법으로 정렬 할 수 있는 네 가지 삽입 Operation( “A”, “l”, “C”, “h”)이 있다. 그러나 6가지 동작의 결과는 ChAl 또는 AlCh 두 가지 결과 만 가능하며 CAhl 또는 AChl과 같은 인터리빙은 발생하지 않는다.&lt;/p&gt;

&lt;p&gt;실제로 최종 결과는 각각 “A”와 “C”를 삽입하는 Operation의 상대적 순서에만 의존한다. 다른 모든 Operation은 결과에 영향을 미치지 않고 재정렬 될 수 있다. 따라서 삽입 된 문자열이 2자보다 길더라도 상대 순서는 첫 번째 문자의 ID에만 의존한다. 나머지 문자도 초기 문자 뒤에 온다.&lt;/p&gt;

&lt;p&gt;4가지 Operation의 결과는 6가지 문자 순서만 있고 4가지 문자 순서는 없는데, 식별자에 대한 램포트 시계 정렬은 인과 관계 순서의 선형 확장이기 때문이다(2.1 절에 설명한). 이 예에서는 텍스트가 왼쪽에서 오른쪽으로 입력된다고 가정한다(즉, “A”는 항상 “l”앞에 삽입되고 “C”는 “h”앞에 삽입). 이것은 “l”을 삽입하는 Operation의 ID가 “A”삽입보다 크고, “h”삽입이 “C”삽입보다 커야 함을 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image13.png&quot; alt=&quot;image13&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정리 3의 OpSet 리스트 스펙은 Attiya et al의 Astrong 스펙보다 엄격하다. 즉, 3절에 주어진 리스트 스펙을 만족시키는 알고리즘도 Astrong을 만족하지만 그 반대는 성립하지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image15.png&quot; alt=&quot;image15&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Astrong 스펙을 Isabelle/HOL로 형식화하고 3절의 리스트 스펙을 실행할 때마다 Astrong의 모든 조건을 충족한다는 기계적으로 검증 된 증거를 제시한다. 공식 증명 구현은 부록 C.5에 요약했다. 스펙이 엄격하고 강하다는 사실은 정리 1과 2를 따른다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image16.png&quot; alt=&quot;image16&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정리 4 : RGA 알고리즘은 이 논문에서 소개한 OpSet리스트 명세를 만족시키는 반면, Logoot와 LSEQ는 그렇지 않다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image14.png&quot; alt=&quot;image14&quot; /&gt;&lt;/p&gt;

&lt;p&gt;증명. 부록 C.4에서 설명한대로 RGA가 우리의 명세를 만족 시킨다는 것을 증명하기 위해 Isabelle/HOL을 사용한다. Isabelle/HOL의 RGA 구현은 이전 연구의 형식화를 기반으로한다. Logoot와 LSEQ가 스펙을 만족시키지 못한다는 사실은 정리 1과 2를 따른다.&lt;/p&gt;

&lt;h2 id=&quot;5-복제-된-트리-데이터타입&quot;&gt;5. 복제 된 트리 데이터타입&lt;/h2&gt;

&lt;p&gt;3장에서는 복제 된 객체 그래프 데이터타입의 OpSet 사양을 제시했는데, 모든 맵 또는 리스트 객체는 고유 한 ID(즉, 객체를 만든 MakeMap 혹은 MakeList Operation의 ID)를 가지며 객체는 이 ID를 사용하여 서로를 참조 했다.&lt;/p&gt;

&lt;p&gt;이제 이 모델을 기반으로 객체 그래프가 항상 트리가 되도록 제한하는 방법을 알아보자. 트리는 모든 vertex가 정확히 하나의 parent(root 제외)를 갖고 parent 관계에 사이클이 없는 그래프이다. 트리 데이터타입은 많은 애플리케이션에서 유용하다. 예를 들어, 파일 시스템(디렉토리 및 파일로 구성)과 XML 또는 JSON 문서가 트리이다. 이 트리의 branch 노드는 맵 또는 리스트 일 수 있으며 리프 노드는 기본형 값(MakeVal Operation로 래핑 됨)이다.&lt;/p&gt;

&lt;h3 id=&quot;51-move-operation-문제&quot;&gt;5.1 Move Operation 문제&lt;/h3&gt;

&lt;p&gt;트리 데이터를 사용하는 애플리케이션에서 종종 필요한 작업중 하나는 트리 내의 새 위치로 하위 트리를 이동하는 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일 시스템에서 디렉토리 이름 변경은 디렉토리 노드를 이전 이름에서 새 이름으로 이동하는 것으로 표현할 수 있다. 마찬가지로 디렉토리를 새 경로로 이동하기도 한다.&lt;/li&gt;
  &lt;li&gt;벡터 그래픽 애플리케이션에서 여러 객체를 논리 단위로 그룹화하는데, 그룹을 나타내는 새 branch 노드를 만든 다음 개별 객체를 해당 그룹 노드의 하위 노드로 이동하여 표현한다.&lt;/li&gt;
  &lt;li&gt;To-do list 애플리케이션에서 사용자는 리스트의 순서를 사용하여 우선 순위를 나타내며 항목을 drag&amp;amp;drop으로 순서를 변경한다. 항목 재정렬은 항목을 리스트 내의 새로운 위치로 이동하는 것과 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이전 위치의 하위 트리를 삭제하고 새 위치에서 다시 작성하여 Move Operation을 기본적(naively)으로 표현할 수 있다. 그러나 두 명의 사용자가 이 프로세스를 동시에 수행하는 경우 결과 트리에는 이동 된 하위 트리에 두번 복제 된다. 이는 위에 제공된 모든 애플리케이션에서 바람직하지 않다. 따라서 동시 이동의 경우 중복 객체를 생성하지 않는 Atomic Move Operation이 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image3.png&quot; alt=&quot;image3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 4에 좀 더 미묘한 충돌을 표현는데, B를 A의 하위 항목으로 이동하고 동시에 A를 B의 하위 항목으로 이동한다. CRDT가 이 상황을 감지하지 못하면 그림 4 (a)와 같이 병합 결과처럼 상호 참조가 발생한다. 이 결과는 더 이상 트리가 아니다. 그러한 충돌하는 Move Operation을 다루는 것은 어려운 문제이며, 트리 CRDT의 기존 구현들은 이 문제에 대한 적절한 해결책을 찾지 못했다.&lt;/p&gt;

&lt;p&gt;XML과 JSON 데이터에 대한 여러 CRDT 트리 데이터타입이 제안되었지만, 누구도 Move Operation을 정의하지 않았다. Tao et al.은 충돌하는 브랜치 노드(디렉토리)가 복제되고 리프 노드(파일)가 여러 브랜치 노드에서 참조 될 수 있는 CRDT 기반의 복제 된 파일 시스템을 구현하여 그림 4(b)와 같은 동시 동작을 해결했다. 따라서 엄격하게는 Tao 데이터 구조는 DAG(Directed acyclic graph)이며 트리가 아니다.&lt;/p&gt;

&lt;p&gt;Najafzadeh는 또한 CRDT 기반의 복제 된 파일 시스템을 구현했지만 다른 접근 방법을 선택했다. Move Operation은 시작 전에 전역 잠금(Lock)을 획득해야 하며 충돌하는 동시 Move Operation이 처음에는 발생할 수 없도록 보장해야한다. 이러한 보수적 인 접근 방식은 Move 충돌을 배제하지만, 일부 Operation의 경우 매우 일관된 동기화가 필요하기 때문에 엄밀하게는 CRDT가 아니다.&lt;/p&gt;

&lt;h3 id=&quot;52-원자-이동-가능한-트리tree-with-atomic-moves&quot;&gt;5.2 원자 이동 가능한 트리(Tree with Atomic Moves)&lt;/h3&gt;

&lt;p&gt;이제 자유롭게 원자 이동이 가능한 트리 CRDT를 정의하고 OpSets 접근 방식의 장점에 대해 알아보자. 이 트리는 그림 4의 a, b 상황과 같은 트리 구조에 위반 없고 동시 이동으로 트리가 복제되는 일이 발생하지 않는다. 또한 잠금 장치(Lock) 이나 전역 동기화가 필요없다.&lt;/p&gt;

&lt;p&gt;OpSet에서 충돌하는 Move Operation이 발생하면, 그 중 하나를 선택하고 적용한 뒤 다른 작업은 무시한다. 따라서 그림 4에서, 두 개의 상반되는 이동 동작의 병합 된 결과는 (c) 또는 (d) 중 하나이다. 두 사용자가 동일한 항목을 다른 위치로 동시에 이동하면 큰 ID로 Move Operation이 항목의 최종 위치를 결정한다. 그러나 비 충돌 상황에서는 모든 동시 Move Operation이 적용된다.&lt;/p&gt;

&lt;p&gt;트리를 3장에 명시된 제한된 형태의 객체 그래프를 정의한다. 먼저 지정된 루트 객체가 필요한데, 다른 모든 Operation ID보다 (2.1절에서 소개한 전체 식별자 순서 중) 작은 Operation ID의 루트가 있다고 가정한다. 그리고 임의의 OpSet O를 트리로 정의한다면 루트 노드가 리스트나 맵인지에 따라 &lt;code class=&quot;highlighter-rouge&quot;&gt;(root, MakeList) ∈ O&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;(root, MakeMap) ∈ O&lt;/code&gt;를 만족한다. x의 값 중 하나가 y를 참조할 경우, 객체 x를 객체 y의 부모로 정의한다. 조상(ancestor) 관계는 요소 관계 &lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt;를 사용하여 정의한 부모 관계의 이행적 폐쇄(Transitive Closure)이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image12.png&quot; alt=&quot;image12&quot; /&gt;&lt;/p&gt;

&lt;p&gt;루트가 Parent가 없고 모든 루트가 아닌 노드가 하나의 Parent를 가지며 조상 관계에 사이클이없는 경우 객체 그래프는 트리이다. 이 트리 불변조건(invariant)을 만족하기 위해서 3.2절의 Operation 해석을 재정의한다. 실제로, Assign의 해석만 재정의하고 나머지 다섯 가지 Operation의 해석은 변경하지 않아도 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image1.png&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 정의는 3.2절과 두 가지 차이점이 있다. 첫째, val이 부모 obj의 조상인 경우, Operation이 적용되지 않는데, 해당 Operation로 Tree에 순환 참조가 발생하기 때문이다. 둘째, 동일한 값 val을 참조하는 E의 기존 튜플이 제거되어 모든 루트가 아닌 노드가 정확히 하나의 부모를 가져야한다는 불변조건이 유지된다. 이 Assign Operation의 해석은 val이 트리의 기존 객체의 ID 일 때, 원자 이동을 수행하는데, 기존의 위치로부터 obj 내의 key를 변경한다. val이 기존 트리에 존재하지 않으면(방금 생성된 경우), Operation은 일반적인 Assign과 동일하게 동작한다.&lt;/p&gt;

&lt;h2 id=&quot;6-관련-작업&quot;&gt;6. 관련 작업&lt;/h2&gt;

&lt;h3 id=&quot;61-operation의-순차적-해석&quot;&gt;6.1 Operation의 순차적 해석&lt;/h3&gt;

&lt;p&gt;Operation의 전체 순서를 정하고 이를 순서대로 실행한다는 일반적 방식은 여러 컴퓨팅 영역에서 활용되었다. 예를 들어, 복제에 대한 상태 머신 접근법(state machine approach to replication), 데이터 모델링에 대한 이벤트 소싱 접근법(event sourcing approach to data modelling), 크래시 복구를 위한 로그 미리 쓰기(write-ahead logs for crash recovery), 직렬화 트랜잭션(serializable transaction) 그리고 확장 가능한 멀티 코어 데이터 구조(scalable multi core data structures)가 있다. OpSet 시스템은 (데이터가 복제되고 분산 되어 있다는) 피상적 유사성이 있지만 중요한 차이점을 갖고 있다.&lt;/p&gt;

&lt;p&gt;2.3절에서 알아본 것처럼, 많은 시스템은 특정 Operation이 실행 된 후 모든 후속 Operation이 전체 순서(total order)를 보장하며 실행되어야 한다는 제약에 의존한다. 즉, Operation 시퀀스는 append-only 로그이므로 새 Operation을 기존 Operation보다 먼저 삽입 할 필요가 없었다. 이것은 분산 시스템에서 분산 된 컨센서스(consensus)를 해결하는 것과 같은 원자적 브로드캐스트(혹은 total order 브로드캐스트) 프로토콜을 필요로 한다. 이런 유형의 프로토콜은 진행을 위해서 노드들의 쿼럼과 통신이 필요하고 완전한 비동기 상태에서는 진행할 수 없다.&lt;/p&gt;

&lt;p&gt;대조적으로, 2.2절의 순차 OpSet 해석은 임의의 순서로 OpSet에 Operation을 추가 할 수 있고 조정(coordination)없이 Operation ID를 할당하므로 원자적 브로드캐스트가 필요 없다. 이 방식의 시스템은 흔하지 않다. 가장 밀접하게 관련된 이전 연구는 타임 스탬프 순서에서 결정적으로 임시 트랜잭션을 실행한 Bayou system과 Burckhardt의 표준 충돌 해결 방법이다. OpSet 접근방식과 유사한 이 시스템들은 작은 ID로 새로운 Operation을 수신 할 때, 더 큰 ID를 가진 Operation의 실행 취소하고 다시 적용한다.&lt;/p&gt;

&lt;p&gt;이 논문의 기여(contribution)는 OpSet 접근 방식을 이용해서 리스트와 트리 같이 복잡한 복제 된 데이터 구조를 정의, 추론하고 이전 보다 일반적으로 공식화하는 것이다. RGA가 OpSet 기반 스펙을 충족하고 그림 2에서 설명한 인터리빙 예외가 없음을 증명했다.&lt;/p&gt;

&lt;p&gt;Baquero et a과 Grishchenko는 Operation 간의 인과 관계를 포착하기 위해 Operation의 부분 순서 로그를 CRDT로 표현할 것을 제안했다. OpSet 접근 방식은 식별자에 대한 전체 순서(total order)를 부분 순서(partial order)의 선형 확장으로 정의하는 변형으로 볼 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;62-복제-데이터타입의-정의와-검증&quot;&gt;6.2 복제 데이터타입의 정의와 검증&lt;/h3&gt;

&lt;p&gt;공유 데이터 구조를 공동 편집하는 알고리즘은 Operational Transformation, CRDT에서 약 30 년간 활발히 연구 되었지만 알고리즘의 정확한 일관성(exact consistency property)이 다소 불명확 했다. 예를 들어, Sun et al은 표현한 세 가지 바람직한 성질, 즉 수렴(convergence), 인과 관계 보전(causality preservation), 의도 보존(intention preservation)을 비공식적 표현했다. 처음 두 속성의 정의가 명확하지는 않지만 “의도 보존”의 정의는 더 많은 해석의 여지가 있었다.&lt;/p&gt;

&lt;p&gt;(생략…)&lt;/p&gt;

&lt;h3 id=&quot;63-협업-가능한-트리-데이터타입&quot;&gt;6.3 협업 가능한 트리 데이터타입&lt;/h3&gt;

&lt;p&gt;그 동안 트리 데이터 구조의 공동 편집을 위해서 여러 CRDT와 OT 알고리즘이 제안되었지만 대부분의 경우 노드의 삽입, 삭제만 고려하고 이동 Operation은 지원하지 않았다.&lt;/p&gt;

&lt;p&gt;5장에서 설명한 것처럼 트리에서 새 위치로 특정 트리를 이동하는 Operation을 지원하면 추가로 처리해야 할 충돌이 발생한다. Ahmed Nacer et al은 구체적인 알고리즘을 제시하지 않았고 이러한 충돌을 처리하는 방법을 조사했다. Tao et al은 이동 Operation 처리중 충돌 발생시 동일한 객체가 둘 이상의 위치에 나타날 수 있도록할 것을 제안했는데, 이는 엄격하게는 DAG이며 트리가 아니다.&lt;/p&gt;

&lt;p&gt;Najafzadeh는 이동 Operation의 전제 조건이 안정적이지 않기 때문에 동시 이동 Operation을 CRDT로 안전하게 구현할 수 없다고 주장했다. Najafzadeh는 잠금장치를 사용하여 전역으로 이동 Operation을 동기화하여 그림 4와 같은 예외를 처리했지만 일부 Operation이 strong consistency 동기화가 필요하기 때문에 해당 데이터타입은 CRDT가 아니다.&lt;/p&gt;

&lt;p&gt;5장에 명시한 이동은 완전 비동기 트리 CRDT의 첫 번째 정의이고 Najafzadeh가 주장한 명백한 모순을 회피했다. Operation을 생성하는 시점에 전제 조건 &lt;code class=&quot;highlighter-rouge&quot;&gt;(val, obj) !∈ ancestor(E)&lt;/code&gt;를 평가하는 대신에 결정적 순서로 모든 Operation을 적용한다.&lt;/p&gt;

&lt;h2 id=&quot;7-결론&quot;&gt;7. 결론&lt;/h2&gt;

&lt;p&gt;이 논문은 복제 된 데이터타입의 의미론을 명시하기 위한 간단하지만 강력한 Operation Sets(OpSets)를 제안했다. OpSets 모델에서 다양하고 공통적으로 복제 가능한 데이터타입을 명시하고 Isabelle/HOL을 사용하여 형식적으로 그 속성을 추론했다. OpSets를 사용하여 기존 협업 텍스트 편집 알고리즘에서 발생하는 인터리빙 예외를 확인했고 RGA 알고리즘이 OpSets 리스트 스펙을 충족 시키는 것을 입증했다. 마지막으로 OpSet 모델을 사용하여 새로운 복제 알고리즘을 개발하는 방법에 대해 알아봤고 트리 CRDT에서 원자적 이동 Operation에 대한 스펙을 제안했다.&lt;/p&gt;

&lt;p&gt;OpSets는 일부 업데이트들이 적용된 후 복제본의 허용 상태를 정확하게 정의한 실행 가능한 스펙이다. 이 문서에서는 순차적인 OpSet 해석을 사용했다. Operation은 ID의 엄격한 오름차순으로 적용되는 이는 수렴(convergence)을 쉽게 보장하고 CRDT의 스펙, 불변조건에 대한 추론을 단순화하므로 매우 유용하다. 이와 반대로 이전 CRDT를 정의한 전통적인 접근법은 Operation이 교환법칙(commutative)을 만족해야했고 복잡성 높았다. RGA가 OpSets 리스트 스펙을 만족함을 증명할 때, 순차적 명세와 교환 적 구현 사이의 일치성을 입증했다. 이는 향후 작업을 위해서 다른 데이터타입에 대한 이 가설을 더 자세히 살펴 볼때 유용할 것이다. 특히, 5장에서는 분산 P2P 파일 시스템을 구현할 수 있으며 교환법칙을 만족한 이동 Operation을 갖는 트리 CRDT를 제안했다.&lt;/p&gt;

&lt;p&gt;이 논문에서는 순차적인 OpSet 해석에 초점을 맞추었지만, 특정 결정적(deterministic) 함수를 해석 함수 &lt;code class=&quot;highlighter-rouge&quot;&gt;[-]&lt;/code&gt;로 사용될 수 있다는 점을 주목하자. 특히 해석 함수를 데이터베이스의 쿼리로 생각해본다면 OpSet을 공유 데이터에 대한 모든 변경 사항을 처리하는 데이터베이스로 볼 수 있다. 결과로 생성 된 데이터타입은 데이터베이스의 materialized view에 해당된다. OpSet O에 새로운 Operation이 추가되면 &lt;code class=&quot;highlighter-rouge&quot;&gt;[O]&lt;/code&gt;에 해당하는 변화를 계산하는 것은 최적화 된 알고리즘이 개발 된 materialized view의 관리 문제이다. 이러한 기술을 복제 된 데이터타입에 적용 할 수 있으며 효율적인 CRDT 구현을 OpSet 기반 스펙에서 파생시킬 수 있다고 생각한다.&lt;/p&gt;

&lt;p&gt;(Appendix 생략…)&lt;/p&gt;

&lt;h2 id=&quot;원본-논문-링크&quot;&gt;원본 논문 링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1805.04263&quot;&gt;OpSets: Sequential Specifications for Replicated Datatypes (Extended Version).&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>hackerwins</name><email>susukang98@gmail.com</email></author><category term="crdt" /><category term="paper" /><summary type="html">“OpSets: Sequential Specifications for Replicated Datatypes (Extended Version).” 읽으면서 정리한 내용</summary></entry><entry><title type="html">A Conflict-Free Replicated JSON Datatype 요약</title><link href="/2018-10-26/a-conflict-free-replicated-json-datatype" rel="alternate" type="text/html" title="A Conflict-Free Replicated JSON Datatype 요약" /><published>2018-10-26T04:14:00+00:00</published><updated>2018-10-26T04:14:00+00:00</updated><id>/2018-10-26/a-conflict-free-replicated-json-datatype</id><content type="html" xml:base="/2018-10-26/a-conflict-free-replicated-json-datatype">&lt;blockquote&gt;
  &lt;p&gt;“A Conflict-Free Replicated JSON Datatype” 읽으면서 정리한 내용&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;요약&quot;&gt;요약&lt;/h2&gt;

&lt;p&gt;일반적으로 다양한 애플리케이션은 자신의 모델을 범용적인(general-purpose) 형식으로 모델링한다. 이 모델의 단일 복제본을 순차적으로 수정할 때에는 문제없지만, 여러 디바이스 로컬 저장소에서 각각 동시에 수정한다면, 어떤 값이 남아있어야 하는지 알기 어렵다. 이 논문은 CRDT를 이용해서 동시 수정으로 발생하는 충돌(conflict)를 자동으로 해결하는 JSON 자료구조를 제안한다. 이 자료구조에 적용된 알고리즘은 클라이언트에서 병합을 처리하고 모바일이나 열악한 네트워크 환경에도 적용 가능하다.&lt;/p&gt;

&lt;h2 id=&quot;1-도입&quot;&gt;1. 도입&lt;/h2&gt;

&lt;p&gt;모바일 사용자는 오프라인시에도 계속해서 앱 사용이 가능하고 네트워크가 복구 될 때, 사용자의 다른 장비와 자동으로 동기화 되길 원한다. 이러한 종류의 앱은 캘린더, 주소록, 메모장, 할일 목록, 패스워드 등이있다. 또 협업 도구들은 여러 사용자가 문서 수정의 지연(delay)이 작은 환경에서 동시에 동일한 문서를 수정하는 기능을 필요로 한다.&lt;/p&gt;

&lt;p&gt;이러한 애플리케이션은 보통 로컬에서 직접 수정가능 하도록 각각의 디바이스에 애플리케이션의 상태를 저장한다(optimistic replication). 종래의 접근 방식은 네트워크 환경이 열악한 경우 사용 불가능했다. 네트워크의 상태에 무관하게 애플리케이션이 항상 동작해야하는 경우, 서로 다른 장치에서 임의의 수정을 실행할 수 있어야 하며, 수정 결과로 발생하는 충돌을 해결할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;가장 간단한 방법은 “last writer wins” 정책과 같이 충돌 발생시 특정 수정을 버려서 해결하는 것이지만 데이터 손실이 발생하므로 이러한 접근 방식이 적절하지 못할 때가 있다. 다른 대안으로 사용자가 수동으로 충돌을 해결하게 하는 방법이 있지만, 귀찮고 에러가 발생하기 쉬운 문제가 있다.&lt;/p&gt;

&lt;p&gt;최근 애플리케이션들은 이 문제를 임기응변(ad-hoc)적이거나 애플리케이션 마다 자신들의 상황에 맞게 해결한다. 이 논문은 범용적인 JSON 데이터 모델로 표현 가능하고 정보 유실없이 동시 수정이 가능한 데이터타입을 제안한다. 이 접근 방식은 JSON 데이터타입에 대한 동시 수정을 자동으로 병합한다. 충돌 업데이트를 기록하기 위한 일반 메커니즘(multi-value register)를 제안한다. 이 메커니즘은 프로그램적으로 남아있는 충돌을 해결하는 일관된 기반을 제공한다.&lt;/p&gt;

&lt;h3 id=&quot;11-json-data-model&quot;&gt;1.1 JSON Data Model&lt;/h3&gt;

&lt;p&gt;JSON은 인기있는 범용 데이터 인코딩 포맷으로 다양한 데이터베이스나 웹서비스에서 사용한다. JSON에 추가로 스키마를 지정해서 제약할 수 있지만, 이 논문에서는 스키마가 없는 경우만 고려했다.&lt;/p&gt;

&lt;p&gt;JSON 문서는 다음과 같이 두 형식의 브랜치(branch) 노드를 포함한 트리다.
Map: 순서가 지정되지 않고 문자열 키로 찾을 수 있는 자식을 갖고 있는 노드. 논문에서는 키를 불변형, 값을 가변형으로 취급한다.
List: 애플리케이션에서 지정한 순서의 자식을 갖고 있는 노드. 가변적이다.&lt;/p&gt;

&lt;p&gt;브랜치 노드의 자식은 브랜치 노드 혹은 말단 노드(leaf)이다. 트리의 말단에는 기본 타입의 값(primitive value, [string, number, boolean, null])이 위치한다. 이 논문에서는 말단 노드의 값을 불변형으로 취급하고 해당 말단 노드를 수정시에 새로운 값으로 등록한다.&lt;/p&gt;

&lt;p&gt;이 모델은 애플리케이션의 다양한 상태를 표현하는데 충분하다. 예를들어 텍스트 문서는 단일 문자의 리스트로 표현할 수 있다. 3.1 절에서는 더 복잡한 JSON으로 애플리케이션의 data를 모델링하는 예제를 살펴본다.&lt;/p&gt;

&lt;h3 id=&quot;12-복제replication와-충돌-해결conflict-resolution&quot;&gt;1.2 복제(replication)와 충돌 해결(conflict resolution)&lt;/h3&gt;

&lt;p&gt;이 논문은 JSON 문서의 본제본(replica)을 여러 디바이스에 갖고 자신의 복제본을 먼저 수정하고 비동기적으로 원격 복제본에 반영하는 시스템을 대상으로 한다(optimistic replication).&lt;/p&gt;

&lt;p&gt;이 논문에서 필요로 하는 네트워크 환경은 하나의 복제본의 수정사항을 다른 모든 원격 복제본에 전달하는 네트워크를 필요로 한다. 네트워크는 임의적으로 지연되거나 순서가 뒤집히거나 중복 메시지가 발생할 수 있음을 가정한다.&lt;/p&gt;

&lt;p&gt;이 논문이 다루는 범위는 클라이언트 측에 있고 메시지를 처리하거나 변환하는 서버가 필요 없으므로 P2P 네트워크에서도 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;4절에서는 서로 다른 디바이스에서 동시에 JSON 문서를 편집할 때 발생하는 충돌을 어떻게 해결하는지 다룬다. 이 논문의 디자인은 3가지 원칙을 기반으로 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자료구조의 모든 복제본은 자동으로 동일한 상태로 수렴한다.&lt;/li&gt;
  &lt;li&gt;사용자의 입력은 동시 수정으로 인해 유실되지 않는다.&lt;/li&gt;
  &lt;li&gt;업데이트의 모든 조합의 순열들은 동일한 상태로 수렴한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;13-이-논문의-공헌-내용&quot;&gt;1.3 이 논문의 공헌 내용&lt;/h3&gt;

&lt;p&gt;이 논문이 공헌한 점은 JSON 자료구조의 동시 수정 발생시 자동으로 충돌을 해결하는 알고리즘을 정의한 것이다. 이전에도 리스트, 맵, 레지스터와 같은 자료형이 개별적으로 제안되었으나 이 논문은 각각의 자료구조를 통합하고 어떤 네트워크 토폴로지에 사용할 수 있도록 했다.&lt;/p&gt;

&lt;p&gt;맵과 리스트의 중첩 자료구조를 구성하면 트리의 서로 다른 레벨을 동시에 수정하는 것이 가능하기 때문에 단일 자료구조에서 발생하지 않는 문제가 발생한다. 이 문제들은 3.1 절에서 다룬다. 중첩 데이터 구조는 많은 애플리케이션의 중요한 요구사항이다.&lt;/p&gt;

&lt;h2 id=&quot;2-관련-작업&quot;&gt;2. 관련 작업&lt;/h2&gt;

&lt;h3 id=&quot;21-operation-transformation&quot;&gt;2.1 Operation Transformation&lt;/h3&gt;

&lt;p&gt;OT 기반 알고리즘은 동시편집 애플리케이션에서 오랫동안 사용되었다. 이 애플리케이션들은 대부분 문자열을 원소로하는 단일 리스트를 문서로 다루며 충첩 트리 자료구조를 지원하지 않는다. XML 문서를 편집하기 위해서 OT를 일반화한 일부 알고리즘은 충첩 리스트를 다뤘으나 이 논문이 다루는 충첩 맵을 다루지는 않았다. 또 OT 알고리즘은 동시에 발생하는 오퍼레이션의 수가 증가하면 급격히 성능이 저하된다.&lt;/p&gt;

&lt;p&gt;대다수의 OT 기반의 협업 시스템(Google Docs, Etherpad, Novell Vibe, Apache Wave)은 오퍼레이션의 순서를 결정하기 위한 단일 서버를 필요로 하는데, 이 디자인 개념은 Jupiter 시스템에서 왔다. 이 접근 방식은 변환 함수를 단순화하고 오류 발생을 줄이지만 P2P에서 사용할 수 없었다.&lt;/p&gt;

&lt;p&gt;협업 작업에 사용할 많은 보안 메시징 프로토콜은 각각의 수신자가 메시지를 동일한 순서로 볼 수 없을지도 모른다. Atomic broadcast 프로토콜을 사용하면 서버 없이도 오퍼레이션의 전체 순서를 보장할 수 있지만, 합의(consensus) 프로토콜과 마찬가지로 쿼럼에 각 노드들이 접근가능할 때에만 안전하게 처리한다. 이 P2P 시스템에서의 모바일 디바이스는 자주 오프라인이 되고 atomic broadcast는 쿼럼에 접근하기 위해서 문제가 발생해서 사용하기 어려울 것이다. 쿼럼 없이 이를 처리할 수 있는 방식은 causal ordering 이다.&lt;/p&gt;

&lt;p&gt;Google Realtime API는 임의의 중첩 리스트와 맵을 OT로 구현했고 Google Docs처럼 서버를 필요로 한다. 자세한 알고리즘은 아직 발표되지 않았다.&lt;/p&gt;

&lt;h3 id=&quot;22-crdt&quot;&gt;2.2 CRDT&lt;/h3&gt;

&lt;p&gt;CRDT는 동시 편집을 지원하는 자료구조로 동시 수정의 수렴을 보장하며 데이터타입에 메타데이타를 추가해서 생성시 오퍼레이션이 교환법칙(commutative)이 가능하도록 한다. 이 논문은 CRDT JSON 데이터타입을 다룬다.&lt;/p&gt;

&lt;p&gt;CRDT를 기반으로한 레지스터(register), 카운터(counter), 맵, 셋(sets)은 Riak과 같이 다양한 출시된 시스템에서 사용된다. 순서 리스트의 알고리즘은 WOOT, RGA, Treedoc, Logoot, LSEQ등 여러가지가 제안되었지만 모두 기본형 값을 사용하고 값으로 다른 CRDT를 갖는 충첩을 지원하지는 않았다.&lt;/p&gt;

&lt;p&gt;충첩 CRDT에 대한 연구는 최근에 진행되었다. Riak은 맵안에 카운터와 레지스터, 맵의 중첩이 가능했다. (생략…) 이 연구들 모두 리스트를 중첩하지는 않았지만, 이 논문에서 사용하는 의미체계의 기초가 된다. (생략…)
레지스터, 맵, 리스트들이 수년간 개별적으로 연구되었고 이 논문은 JSON 유사한 구조의 임의의 중첩 CRDT를 제안한다.&lt;/p&gt;

&lt;h3 id=&quot;23-다른-접근-방법&quot;&gt;2.3 다른 접근 방법&lt;/h3&gt;

&lt;p&gt;복제된 데이터 시스템은 동시 수정과 충돌을 해결해야 하지만, 기존에는 이 문제를 각 애플리케이션 마다 임기응변으로 해결했다. 예를 들어, Dynamo와 CouchDB는 여러 값이 같은 키에 동시에 쓰여지면 데이터베이스는 이러한 모든 값을 보존하고 충돌 해결을 애플리케이션에서 처리하도록 한다.(생략…)&lt;/p&gt;

&lt;p&gt;충돌 해결에 자주 사용하는 또 다른 접근법은 LWW(last writer wins)로, 여러 동시 수정 중 하나를 “승자”로 선택하고 다른 기록을 삭제한다. LWW는 Apache Cassandra에서 사용된다. 동시 수정으로 인해 사용자 입력이 손실되는 단점이 있다.&lt;/p&gt;

&lt;p&gt;트리 구조에 대한 동시 편집을 해결하는 것은 파일 동기화 분야에서 연구되었다. 마지막으로 Bayou에서는  오프라인 노드가 일시적으로 트랜잭션을 실행하고 다음 온라인 상태 일 때 이를 확인하는데 동일한 일련 순서로 트랜잭션을 실행하는 모든 서버에 의존이 있고 트랜잭션이 전제 조건에 따라 성공했는지 여부를 결정한다. Bayou는 직렬화가 필요하고 CRDT를 사용하여 표현할 수 없는 유일성 제약 조건과 같은 전역 불변량을 표현할 수 있다는 장점이 있다. Bayou의 단점은 애플리케이션이 명시적으로 처리해야하는 임시 트랜잭션이 롤백 될 수 있다는 점이고 CRDT는 하나의 복제본에서 수행 된 작업이 실패하지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;3-자료구조-구성&quot;&gt;3. 자료구조 구성&lt;/h2&gt;

&lt;h3 id=&quot;31-동시-편집-예&quot;&gt;3.1 동시 편집 예&lt;/h3&gt;

&lt;p&gt;JSON 자료구조를 순차적으로 편집하는 의미론은 잘 알려져 있으며, 플랫한 맵 또는 리스트의 동시 편집은 기존 논문에서 철저히 조사되었다. 그러나 JSON CRDT에서 동시성과 중첩 된 데이터 구조 간의 상호 작용으로 인해 문제가 발생한다.&lt;/p&gt;

&lt;p&gt;다음 예제는 JSON 문서가 동시에 수정 될 때 발생할 수있는 몇 가지 상황을 보여 주며, 이 논문에서 제시한 알고리즘에 의해 처리되는 방법에 대해 알아본다. 예제에서는 p와 q라는 두 개의 복제본을 가정한다.복제본의 로컬 상태는 박스에 그렸고 로컬 상태의 수정 내용은 레이블이 있는 실선 화살표로 표시한다. 시간은 아래로 흐른다. 복제본은 로컬 상태만 변경하기 때문에 복제본 간에 변경에 대해서만 통신한다. 네트워크 통신은 점선 화살표로 표현했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image1.png&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 1에서는 키가 “key”이고 값이 “A”을 갖은 문서에서 리플리카 p는 값을 “B”로 설정하고 리플리카 q는 동시에 “C”로 설정한다. 이후 네트워크 통신을 통해 편집 내용을 받으면 충돌을 감지한다. 문자열 “B”와 “C”를 의미있게 병합 할 수 없기 때문에 시스템은 동시에 발생한 두 업데이트를 보존해야 한다. 이 데이터 유형은 다중 값 레지스터(multi-value register)로 불린다. 복제본은 레지스터에 단일 값만 할당 할 수 있지만 읽기시에 동시에 쓰인 값의 집합이 반환된다.&lt;/p&gt;

&lt;p&gt;다중 값 레지스터는 충돌 해결을 실제로 수행하지 않으므로 인상적인 CRDT는 아니다. 이 논문에서는 자동 병합 함수가 정의되지 않은 기본형에만 이 방식을 취한다. 하지만 다른 CRDT는 이를 처리한다(예 : 카운터 CRDT 또는 공동 편집에 사용하는 정렬된 리스트 CRDT).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image18.png&quot; alt=&quot;image18&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 2에서는 JSON 트리에서 다양한 레벨에서의 동시 편집의 예를 표현했다. 여기서 리플리카 p는 colors 맵에 “red”를 추가하고 동시에 리플리카 q는 colors 맵을 지운 다음 “green”을 추가한다. 빈 맵을 할당하는 대신, q는 colors 맵의 키를 제거한 다음 해당 키에 새 값을 할당한다. 이 예제의 어려움은 트리의 하위 레벨에서 “red”를 추가하는 것과 동시에 트리의 상위 레벨에서 colors 맵이 제거된다는 점이다.&lt;/p&gt;

&lt;p&gt;레벨간 충돌을 처리하는 방법중 하나는 트리의 상위에서 발생한 편집이 항상 해당 하위 트리에서 발생한 동시 편집을 무시하는 것이다. 이 경우, “red”의 추가는 상위 삭제(blanking-out)에 의해 무시되기 때문에 버린다. 그러나 이러한 동작은 동시 수정으로 인해 사용자 입력을 잃지 않아야 한다는 초기 요구 사항을 위반한다. 따라서 논문에서는 그림 2와 같이 모든 변경 사항을 보존하는 병합 의미론을 정의했다. “blue”는 최종 맵에서 제거되어야 하며 “빨간색”과 “녹색”은 명시 적으로 추가 되었기 때문에 맵에 추가되어야 한다. 이 동작은 Riak 의 CRDT 맵의 동작과 일치한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image15.png&quot; alt=&quot;image15&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 3은 동일한 키의 리스트에서 발생하는 문제점을 표현했다. 두 개의 복제본이 동시에 동일한 키에 값을 삽입했을 때, p와 q는 각각 독립적으로 동일한 맵에 “grocery”키로 리스트를 만들고 리스트에 항목을 추가한다. 그림 1의 경우, 동일한 맵 키에 대한 동시 할당은 애플리케이션에 의해 해결했지만, 그림 3에서 두 값은 리스트에서 자동으로 병합한다. 각 복제본에 삽입 된 항목의 순서와 인접성을 보존하므로 병합 결과에서 “eggs”뒤에 “ham”이 있고 “milk”뒤에 “flour”가 추가된다. 어떤 복제본의 항목이 병합 된 결과에서 처음으로 나타 나야하는지에 대한 정보는 없으므로 “eggs, ham, milk, flour”와 “milk, flour, eggs, ham”중 하나가 선택된다. 단, 모든 복제본은 동일한 순서로 병합된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image10.png&quot; alt=&quot;image10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 4는 문서를 문자 리스트로 처리해서 협업 텍스트 편집기를 구현하는 방법을 표현했다. 병합 된 결과에  모든 변경 사항이 보존된다. “a”앞에 “y”가 삽입, “x”와 “z”는 “a”와 “c”사이에 삽입 “b”는 삭제됨.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image13.png&quot; alt=&quot;image13&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 5는 그림 3처럼 두 개의 복제본이 동시에 동일한 맵 키를 삽입 했지만 다른 타입을 값으로 할당하는 문제를 표현했다. p는 중첩 맵을 삽입했고 q는 리스트를 삽입했다. 이러한 데이터 유형은 의미있게 병합할 수 없으므로 두 값을 별도로 보존한다. 이 논문은 맵의 각 키에 map, list, register 값에 대한 타입 주석(mapT, listT, regT)을 태깅해서 각 유형이 별도의 네임 스페이스를 유지하도록 했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image14.png&quot; alt=&quot;image14&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로, 그림 6은 모든 사용자 입력을 보존하는 원칙의 한계를 표현했다. p가 항목을 리스트에서 제거하는 동시에 q는 항목을 완료로 표시한다. 변경 사항이 병합되면 맵 키 “done”이 참인 제목이 없는 값이 남는다. 이 동작은 그림 2에서는 정상 동작하지만 여기에서는 오류를 범한다. 이 경우, 동시 갱신 중 하나를 버리고 작업 항목에 “제목”및 “완료” 필드가 있는 내재적 스키마를 보존하는 것이 더 바람직하다.&lt;/p&gt;

&lt;h3 id=&quot;32-json-vs-xml&quot;&gt;3.2 JSON vs XML&lt;/h3&gt;

&lt;p&gt;JSON의 일반적인 대안은 XML로 협업 편집은 이전에 연구되었다. XML과 JSON의 트리 구조는 매우 유사하지만 중요한 차이가 있다.&lt;/p&gt;

&lt;p&gt;JSON에는 임의의 맵과 리스트를 중첩 할 수 있는 구조를 갖고 있다. 반면 XML은 자식으로는 리스트를 갖고 attribute는 맵을 갖지만 중첩 구조를 허용하지 않는다. 따라서 XML은 리스트는 값으로 맵을 지원하지만 맵은 값으로 리스트를 지원하지 않는다. 따라서 XML은 JSON보다 표현력이 부족하다. 그림 3과 5의 시나리오는 XML에서 구현할 수 없다. 일부 애플리케이션은 XML 문서의 하위 attribute에 맵과 유사한 의미를 첨부하지만 이 구조는 XML 자체의 특성은 아다. 동일한 키를 가진 자식이 여러 개 동시에 생성되는 경우 기존 알고리즘은 그림 3과 같이 병합하지 않고 동일한 키를 가진 중복 자식을 만들어야한다.&lt;/p&gt;

&lt;h3 id=&quot;33-문서-편집-api&quot;&gt;3.3 문서 편집 API&lt;/h3&gt;

&lt;p&gt;협업 가능한 데이터 구조에 대한 의미(semantics)를 정의하기 위해 먼저 모든 복제본에서 로컬에 실행하며 해당 복제본을 쿼리하고 수정할 수 있는 간단한 명령 언어(command language)를 그림 7처럼 정의한다. 읽기 쿼리를 수행하면 부작용(side effect)이 없지만 문서를 수정하면 부작용이 발생하는 작업이 생성된다. 이러한 작업은 문서의 로컬 복사본에 즉시 적용되며 다른 복제본에 비동기(asynchronous)로 브로드 캐스팅 큐에 추가된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image4.png&quot; alt=&quot;image4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;명령 언어의 구문(syntax)은 그림 7에 있다. 완전한 프로그래밍 언어가 아니라 문서 상태를 쿼리하고 수정하는 API이다. 애플리케이션은 사용자 입력을 받아 API에 일련의 명령(무한한)을 발행한다. API는 일관된 병합 의미를 정의 할 수 있도록 많은 프로그래밍 언어에서 발견되는 JSON 라이브러리와 약간 다르다.&lt;/p&gt;

&lt;p&gt;먼저 공식적인 의미를 부여하기 전에 언어를 비공식적으로 설명한다. 표현식 구조 EXPR은 문서의 위치를 ​​식별하는 커서를 구성하는 데 사용된다. 표현식(expression)은 JSON 문서 트리의 루트를 식별하는 특수 토큰 doc 또는 let 명령에서 이전에 정의 된 변수 x로 시작한다. 이 표현식은 왼쪽에서 오른쪽으로 트리가 잎을 향해 잎을 향해 이동할 때 커서가 취하는 경로를 정의한다. 연산자 .get (key)는 맵에서 키를 선택하고 .idx (n)은 정렬 된 순서의 n 번째 요소를 선택한다.&lt;/p&gt;

&lt;p&gt;또한 EXPR은 문서의 상태 질의가 가능하다. keys는 현재 커서에서 맵의 키들을 반환하고, values는 현재 커서의 다중 값 레지스터의 내용을 반환한다. 명령 CMD는 로컬 변수(let)의 값을 설정하거나 네트워크 통신 (yield)을 수행해서 문서를 수정한다. 문서는 리스트에 요소를 삽입하여 레지스터(연산자 : =는 레지스터 값을 할당)에 쓰거나 (insertAfter는 커서로 식별 된 기존 요소 다음에 새 요소를 배치) 또는 리스트 또는 맵에서 요소를 삭제할 수 있다(delete는 커서로 식별 된 요소를 삭제).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image3.png&quot; alt=&quot;image3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 8은 쇼핑리스트를 표현하는 새로운 문서를 구성하는 명령들의 예다. 먼저 문서는 빈 맵 리터럴 인 {}로 설정되고 그 맵 내의 키 “shopping”은 빈 리스트 []로 설정한다. 세 번째 행은 “shopping”키로 이동하여 리스트의 헤드(head)를 선택하여 커서를 head라는 변수에 할당한다. 리스트 요소 “eggs”가 리스트의 헤드에 삽입된다. 5 행에서 변수 egg는 리스트 요소 “eggs”를 가리키는 커서로 할당된다. 그런 다음 헤드에 “cheese”, “eggs”뒤에 “milk”라는 두 가지 요소가 삽입된다. 커서 eggs는 색인에 의해서가 아니라 ID에 의해 리스트 요소를 식별한다. “cheese” 삽입 후 요소 “eggs”은 index 1에서 2로 변경되지만 “milk”는 “eggs” 다음에 삽입된다. 나중에 보게 되겠지만, 이 기능은 동시 수정이있을 때 바람직한 의미를 얻기 위해 유용하다(Cursor).&lt;/p&gt;

&lt;h2 id=&quot;4-형식-의미론formal-semantics&quot;&gt;4. 형식 의미론(Formal Semantics)&lt;/h2&gt;

&lt;p&gt;이어서 3절에서 알아본 동시 의미론을 성취하는 방법을 형식적으로 설명한다. 리플리카 p의 상태는 유한 부분 함수(finite partial function) 인 Ap에 의해 설명된다. 명령 언어의 평가 규칙은 로컬 상태 Ap를 검사하고 수정하며 Aq(다른 리플리카 q는 p와 다름)와 의존성이 없다. 복제본 간의 유일한 통신은 yield 명령을 평가할 때 발생하는데, 이는 나중에 알아본다. 지금은 단일 복제본 p의 명령 실행에 대해 집중적으로 알아본다.&lt;/p&gt;

&lt;h3 id=&quot;41-표현식-평가expression-evaluation&quot;&gt;4.1 표현식 평가(Expression Evaluation)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image19.png&quot; alt=&quot;image19&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 9는 명령 언어에서 EXPR 표현식을 평가하는 규칙이며 로컬 복제본 상태 Ap의 컨텍스트에서 평가된다. EXEC 규칙은 명령이 순차적으로 실행된다는 가정을 공식화했다. LET 규칙은 프로그램이 로컬 상태에 추가한 로컬 변수를 정의하도록 한다(표기법 Ap [x → cur]은 Ap와 동일하지만 Ap(x) = cur을 제외한 부분 함수를 나타냄). VAR 규칙은 애플리케이션이 이전에 정의한 변수의 값을 검색 할 수 있게한다.&lt;/p&gt;

&lt;p&gt;이어지는 규칙은 표현식이 커서로 평가되는 방법을 표현했다. 이는 문서 트리의 루트에서 일부 브랜치 또는 리프 노드까지의 경로를 나타내며 JSON 문서의 특정 위치를 모호하지 않게 식별한다. 커서는 변경 불가능한 키와 식별자로만 구성되므로 네트워크를 통해 다른 복제본으로 보낼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image12.png&quot; alt=&quot;image12&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, id (1)이 이 리스트를 삽입 한 작업의 고유 식별자라고 가정 할 때, cursor(mapT(doc), listT( “shopping”), id1)는 그림 8의 리스트 요소 “eggs”를 나타내는 커서이다. 요소 (4.2.1절에서 이 식별자들에 대해 알아본다). 커서는 로컬 복제본 상태 구조 Ap를 통해 경로로 해석되며 왼쪽에서 오른쪽으로 순서로 루트의 doc 맵에서 시작해서 listT 타입의 “shopping” 항목을 탐색하고 ID가 1인 식별자인 리스트 요소로 끝난다. 일반적으로, 커서(&amp;lt;k1, …, kn-1&amp;gt;, kn)는 키 k1,. . . , kn-1과 항상 존재하는 최종키(kn)으로 구성된다. kn은 벡터의 마지막 요소인데, 벡터의 다른 요소에는 traversal 되는 분기 노드의 데이터 유형으로 mapT 또는 listT 태그가 지정되는 반면 데이터 유형이 태깅되지 않는다는 점이 다르다.&lt;/p&gt;

&lt;p&gt;그림 9의 DOC 규칙은 특수 원자 doc를 사용하여 문서의 루트를 참조하는 가장 간단한 커서(hi, doc)를 정의한다. GET 규칙은 커서로 맵의 특정 키로 이동한다. 예를 들어, doc.get( “shopping”) 표현식은 DOC 및 GET 규칙을 적용하여 cursor(&amp;lt;mapT(doc)&amp;gt;, “shopping”)로 평가된다. doc.get(…) 표현식은 doc가 mapT 유형임을 암시적으로 나타낸다.&lt;/p&gt;

&lt;p&gt;규칙 IDX1…5는 .idx(n)표현식을 평가하여 커서를 리스트의 특정 요소로 이동시키는 방법을 정의한다. IDX1은 리스트의 헤드를 나타내는 커서를 구성하고 이어지는 규칙에 위임해서 리스트를 검사한다. IDX2는 커서의 키 벡터에 따라 로컬 상태를 재귀적으로 찾아낸다. 키 벡터가 비어있을 때 컨텍스트 ctx는 문제의 리스트를 저장하는 Ap의 하위 트리이며 규칙 IDX3, 4, 5는 원하는 요소가 발견 될 때까지 해당 리스트에 반복 수행한다. IDX5는 인덱스가 0에 도달하면 반복문을 종료하고 IDX3은 다음 요소로 이동하여 인덱스를 감소 시키며 IDX4는 삭제 됨으로 표시된 리스트 요소를 건너뛴다. 이 구조는 링크드리스트과 유사하다(각 리스트 요소는 고유 한 식별자 k와 k 다음에 오는 요소의 ID를 구하는 next(k) 부분 함수를 갖음).&lt;/p&gt;

&lt;p&gt;삭제된 요소는 링크드 리스트 구조에서 제거되지 않지만 삭제 된 것으로 표시하는데(tombstone) 이를 위해
요소에 대한 존재 여부를 알 수 있는 pres(k)를 유지한다. 리스트 요소가 삭제되면 pres 집합에서 제거해서 삭제로 표시한다. 그러나 리스트 요소를 참조하는 일은 동시 작업으로 인해 pres 세트가 다시 비어 있지 않게 될 수 있다(그림 2 및 6의 상황을 초래). 규칙 IDX4는 색인을 감소시키지 않고(즉, 리스트 요소로 계산하지 않음) 다음 요소로 이동한다.&lt;/p&gt;

&lt;p&gt;KEYS1, 2, 3 규칙은 애플리케이션이 맵에서 키 집합을 검사 할 수있게 한다. 이 집합은 로컬 상태를 검사하고 현재 상태 집합이 비어있는 키를 제외하여 결정된다(키가 삭제되었음을 나타냄). 마지막으로, VAL1,2,3 규칙은 IDX 규칙과 유사한 재귀적 규칙 구조를 사용하여 애플리케이션이 특정 커서 위치에서 레지스터의 내용을 읽을 수 있게한다. 레지스터는 로컬 상태의 regT 유형 주석을 사용하여 표현된다. 복제본은 레지스터에 단일 값만 할당 할 수 있지만 여러 개의 복제본이 동시에 값을 할당하면 레지스터에 여러 값이 포함될 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;42-오퍼레이션-생성하기&quot;&gt;4.2 오퍼레이션 생성하기&lt;/h3&gt;

&lt;p&gt;오퍼레이션(Operation)은 문서의 상태를 명령(command)으로 변경하면 발생하는 변환(mutation)을 표현한다. 이 논문의 의미론에서, 명령은 로컬 복제 상태 Ap를 직접 수정하지 않고 오퍼레이션만 생성 한 뒤 즉시 Ap에 적용되고 동일한 오퍼레이션이 다른 복제본에도 비동기적으로 브로드캐스팅된다.&lt;/p&gt;

&lt;h3 id=&quot;421-램포트-시계lamport-timestamp&quot;&gt;4.2.1 램포트 시계(Lamport timestamp)&lt;/h3&gt;

&lt;p&gt;모든 오퍼레이션에는 로컬 상태와 커서에서 사용되는 고유 한 식별자(unique identifier)가 제공된다. 요소가 리스트에 삽입되거나 값이 레지스터에 할당 될 때마다 새 리스트 요소 또는 레지스터 값은 이를 생성한 작업의 식별자로 구분된다. 복제본 간의 동기 조정을 필요로하지 않고 전역적으로 고유한 작업 식별자를 생성하기 위해 램포트 시계를 사용한다. 램포트 시계는 Pair(c, p)이며, 여기서 p ∈ ReplicaID는 편집이 이루어진 복제본의 유일한 식별자 (예 : 공개 키의 해시)이고 c ∈ N은 저장된 카운터로 각 복제본에서 모든 작업에 대해 증가한다. 각 복제본은 엄격하게 단조(monotonically) 증가하는 카운터 값 c의 시퀀스를 생성하므로 Pair (c, p)는 고유하다. 복제본이 로컬에 저장된 카운터 값보다 큰 카운터 값 c를 갖는 연산을 수신하면 로컬 카운터는 수신 받은 카운터의 값으로 증가한다. 이렇게하면 o1가 o2보다 먼저 발생하는 경우(즉, o2를 생성 한 복제본이 o2가 생성되기 전에 o1을 받고 처리 한 경우) o2가 o1보다 큰 카운터 값을 가져야한다. 동시 작업만 동일한 카운터 값을 가질 수 있다. 램포트 시계로 오퍼레이션에 대해 전체 정렬을 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image9.png&quot; alt=&quot;image9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한 작업이 다른 작업보다 먼저 발생하면 이 순서는 인과 관계와 일치한다(이전 작업의 timestamp가 더 낮음). 두 작업이 동시에 수행되는 경우 &amp;lt; 에 따른 순서는 임의적(arbitrary)이지만 결정적(deterministic)이다. 이 정렬 속성은 정렬 된 리스트의 의미론 정의에 중요하다.&lt;/p&gt;

&lt;h3 id=&quot;422-오퍼레이션-구조&quot;&gt;4.2.2 오퍼레이션 구조&lt;/h3&gt;

&lt;p&gt;오퍼레이션은 튜플로 id는 오퍼레이션을 식별하는 램포트 시계, cur는 변경의 문서 내의 위치를 ​​나타내는 커서, mut는 지정된 위치의 변환, deps는 인과 관계가 의존된 오퍼레이션의 집합이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image8.png&quot; alt=&quot;image8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;o2가 replica p에 의해 생성 된 경우, o2의 인과 관계는 o2가 생성 된 시점에 이미 p에 적용된 모든 연산이다. 이 논문에서, 모든 인과 관계의 램포트 시계 집합으로 deps를 정의한다. 실제 구현에서는 이 집합이 비실용적으로 커지므로 인과 관계의 간략한 표현이 대신 사용된다(예 : 버전 벡터, 상태 벡터 또는 점선 버전 벡터). 그러나 의미론에서 모호성을 피하기 위해 의존성을 간단한 오퍼레이션 ID 세트로 설명한다. 인과 관계 종속성의 목적은 오퍼레이션에 부분적 순서를 부여하는 것이다. 오퍼레이션은 “이전에 발생한 모든 작업”이 적용된 후에 만 ​​적용될 수 있다. 특히 특정 복제본에서 생성된 작업 시퀀스가 ​​다른 모든 복제본에서 동일한 순서로 적용된다는 의미이다. 동시 작업(즉, 어느 방향으로도 인과 관계가없는 경우)은 임의의 순서로 적용 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;423-오퍼레이션-의미론semantics-of-generating-operations&quot;&gt;4.2.3 오퍼레이션 의미론(Semantics of Generating Operations)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image6.png&quot; alt=&quot;image6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MAKE-ASSIGN, MAKE-INSERT 및 MAKE-DELETE 규칙은 명령이 문서를 어떻게 변경시키는 지 정의한다. 셋 모두 MAKE-OP 규칙에 위임하여 작업을 생성하고 문서에 반영한다. MAKE-OP는 복제본 p에 적용된 모든 작업 ID 집합인 Ap(ops)의 기존 카운터보다 1만큼 큰 카운터 값을 선택하여 새로운 램포트 시계를 생성한다. MAKE-OP는 위에 설명 된 양식의 op() 튜플을 구성하고 APPLY-LOCAL 규칙에 위임하여 작업을 처리한다. APPLY-LOCAL은 다음 세 가지 작업을 수행한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;오퍼레이션을 평가하고 수정된 로컬 상태 Ap’를 생성&lt;/li&gt;
  &lt;li&gt;생성된 오퍼레이션 대기열 Ap(queue)에 오퍼레이션을 추가&lt;/li&gt;
  &lt;li&gt;해당 ID를 처리 된 연산 집합 Ap(ops)에 추가.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(Burckhardt et al.에서 영감을 받은) yield 명령은 다른 복제본과의 작업 송수신 및 원격 복제본의 작업 적용하는 네트워크 통신을 수행한다. APPLY-REMOTE, SEND, RECV 및 YIELD 규칙은 yield의 의미를 정의한다.&lt;/p&gt;

&lt;p&gt;이러한 규칙 모두 네트워크의 비동기성을 모델링인 yield를 평가하는데 사용하기 때문에 비결정적(nondeterministic)이다. 하나의 복제본에서 보내는 메시지는 임의의 차후 시점에 다른 복제본에 도착하며, 메시지 순서의 보장은 없다. 네트워크에서 SEND 규칙은 APPLY-LOCAL에의해 Ap(queue)에 배치된 모든 작업을 가져 와서 송신 버퍼 Ap(send)에 추가한다. 따라서 RECV 규칙은 복제본 q의 전송 버퍼에서 작업을 수행하여 복제본 p의 수신 버퍼 Ap(recv)에 추가한다. 이것은 하나 이상의 복제본을 포함하는 유일한 규칙이며 모든 네트워크 통신에 적용 가능하다.&lt;/p&gt;

&lt;p&gt;수신 버퍼 Ap(recv)에 오퍼레이션이 추가되면 APPLY-REMOTE 규칙을 적용할 수 있다. 작업이 아직 처리되지 않았고 해당 인과 관계가 충족된다는 전제하에 APPLY-REMOTE는 APPLY-LOCAL과 같은 방식으로 오퍼레이션을 적용하고 ID를 처리 된 작업 집합 Ap(ops)에 추가한다. 실제 문서 수정은 다음 절에서 알아본다.&lt;/p&gt;

&lt;h3 id=&quot;43-오퍼레이션-적용하기&quot;&gt;4.3 오퍼레이션 적용하기&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image7.png&quot; alt=&quot;image7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 11은 오퍼레이션 op를 컨텍스트 ctx에 적용하여 업데이트 된 컨텍스트 ctx0을 생성하는 규칙을 나타낸다. 컨텍스트는 초기에 복제 상태 Ap이지만, 규칙들이 재귀적으로 반영될 때 상태의 서브 트리를 참조하기도 한다. 이 규칙들은 APPLY-LOCAL 및 APPLY-REMOTE가 문서의 상태 업데이트를 수행하는 데 사용된다.&lt;/p&gt;

&lt;p&gt;오퍼레이션 커서의 키 벡터가 비어 있지 않으면 먼저 DESCEND 규칙이 적용된다. 키에 설명한 경로를 따라 문서 트리를 재귀적으로 따라간다. 트리 노드가 로컬 복제본 상태에 이미 존재하면 CHILD-GET가 이를 찾는다. 그렇지 않으면 CHILD-MAP과 CHILD-LIST가 각각 빈 맵 또는 리스트를 생성한다.&lt;/p&gt;

&lt;p&gt;또한 DESCEND 규칙은 커서에 의해 기술 된 경로를 따라 각 트리 노드에서 ADD-ID1, 2를 호출하고, pres(k)에 오퍼레이션 ID를 추가하여 서브 트리가 이 오퍼레이션에 의해 만들어진 변환을 포함함을 나타낸다.&lt;/p&gt;

&lt;p&gt;그림 11의 나머지 규칙은 커서에 있는 키의 벡터가 비어있는 경우에 적용된다. 이는 변환이 적용되는 트리 노드의 컨텍스트로 내려갈 때 적용된다. ASSIGN 규칙은 레지스터에 기본형 값을 할당하는 것을 처리하고, EMPTY-MAP은 값이 빈 맵 리터럴 {}, EMPTY-LIST가 빈리스트 []의 할당을 처리한다. 이러한 세 가지 할당 규칙은 유사한 구조를 갖는다. 먼저 커서에서 이전 값을 지우고(다음 절에서 설명), 오퍼레이션 ID를 현재 pres 집합에 추가 한 다음 마지막으로 새 값을 로컬 상태 트리에 통합한다.&lt;/p&gt;

&lt;p&gt;INSERT1,2 규칙은 순서가 지정된 리스트에 새 요소의 삽입을 처리한다. 이 경우 커서는 list 요소 prev를 참조하고 새 요소는 리스트의 해당 위치 다음에 삽입된다. INSERT1은 링크드 리스트 구조를 조작하여 삽입을 수행한다. INSERT2는 동일한 위치에 리스트 요소를 동시에 삽입하는 다중 복제본의 경우를 처리하고 램포트 시계의 순서 관계를 사용하여 일관되게 삽입 지점을 결정한다. 논문의 삽입 처리에 대한 접근법은 RGA 알고리즘에 기반을 두고있다. 이 규칙은 모든 복제본이 동일한 상태로 수렴된다는 것을 보여준다.&lt;/p&gt;

&lt;h3 id=&quot;431-이전-상태-정리하기&quot;&gt;4.3.1 이전 상태 정리하기&lt;/h3&gt;

&lt;p&gt;할당 및 삭제 작업은 그림 2와 같이 동시에 이전 상태(덮어 쓰거나 삭제 된 값)가 지워지는 동시 수정이 손실되지 않도록 해야한다. 이 지우기 프로세스를 처리하는 규칙은 그림 12에 있다. 무언가를 지우는 효과는 동시 작업의 영향을 받지 않은 채로 현재 작업의 원인이되는 작업을 취소하여 빈 상태로 다시 설정하는 것이다.&lt;/p&gt;

&lt;p&gt;삭제 연산은 커서가 가리키는 리스트의 요소나 맵의 키에서 삭제한다. DELETE 규칙은 CLEAR-ELEM에 위임하여 이 오퍼레이션을 평가한다. 차례대로 CLEAR-ELEM은 mapT, listT 또는 regT 유형인지 여부에 관계없이 CLEAR-ANY를 사용하여 지정된 키가 있는 데이터를 지우고 중첩된 작업 ID를 포함하도록 현재 상태를 업데이트하고 deps의 기존 오퍼레이션들을 제거한다.&lt;/p&gt;

&lt;p&gt;CLEAR-ANY은 해당 키가 ctx에 나타나면 CLEAR-MAP1, CLEAR-LIST1 및 CLEAR-REG로 처리하고 키가 없는 경우 CLEAR-NONE(아무 것도 수행하지 않음)으로 처리한다.&lt;/p&gt;

&lt;p&gt;ASSIGN 규칙에 정의한 것 처럼 레지스터는 오퍼레이션 ID에서 값의 맵핑을 관리한다. CLEAR-REG는 deps에 나타나는 모든 오퍼레이션 ID(즉, 삭제 작업보다 먼저 발생 함)를 삭제하지만 deps에 표시되지 않는 모든 오퍼레이션 ID(삭제 작업과 동시에 발생하는 할당 오퍼레이션)를 유지하여 레지스터를 업데이트한다.
맵과 리스트 지우기도 비슷한 접근 방식을 취한다. 각 요소는 clearElem을 사용하여 재귀적으로 지워지고 pres 집합은 deps를 제외하도록 업데이트된다. 따라서, 정리 오퍼레이션 이전에 변경이 발생하는 모든 리스트 요소 또는 맵 항목은 빈 존재 세트로 끝날 것이므로 삭제 된 것으로 간주된다. 지우기 오퍼레이션과 동시에 수행되는 오퍼레이션을 포함하는 맵 또는 리스트 요소는 보존된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image16.png&quot; alt=&quot;image16&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;44-수렴convergence&quot;&gt;4.4 수렴(Convergence)&lt;/h3&gt;

&lt;p&gt;1.2 절에서 설명한 핵심 요구 사항처럼 CRDT의 모든 복제본은 자동으로 동일한 상태로 수렴되어야한다. 이제 이 개념을 공식화하고 그림 9~12의 규칙이 이 요구 사항을 충족함에 대해 알아본다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image11.png&quot; alt=&quot;image11&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정의 1 (유효한 실행). 유효한 실행은 일련의 복제본 {p1,. . . , pk}에서 생성한 오퍼레이션 집합으로 각 오퍼레이션은 걸리지(stuck) 않고 명령 시퀀스 &amp;lt;cmd1; … ;cmd n&amp;gt;를 축소(reduce)한다.&lt;/p&gt;

&lt;p&gt;축소(reduction)는 모든 전제 조건이 충족되는 규칙의 적용이 없으면 걸리게 된다. 예를 들어, idx(n)가 리스트의 끝을 지나 반복문 수행하면, 그림 9의 IDX3, 4 규칙은 멈추는데, 이는 n이 리스트의 삭제되지 않은 요소의 수보다 크면 발생한다. 실제 구현에서는 런타임 오류가 발생한다. 멈추지 않는 실행에 대해 유효한 실행을 제한함으로써 오퍼레이션이 실제로 존재하는 리스트 요소만 참조하도록 한다.&lt;/p&gt;

&lt;p&gt;yield 명령을 호출하지 않기 때문에(또는 yield의 비결정적 실행이 RECV 규칙을 적용하지 않기 때문에) 실행이 네트워크 통신을 절대로 수행하지 않는 것이 유효하다. 축소가 멈추는 지 여부를 결정하기 위해 복제본의 로컬 상태만 필요로 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image17.png&quot; alt=&quot;image17&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정의 2 (히스토리). 히스토리(history)는 APPLY-LOCAL 및 APPLY-REMOTE 규칙을 적용하여 특정 복제본 p에 적용된 순서대로 일련의 작업이다.&lt;/p&gt;

&lt;p&gt;평가 규칙은 주어진 복제본에서 한 번에 하나의 오퍼레이션을 순차적으로 적용하므로 순서가 잘 정의된다. 2개의 복제본 p, q가 동일한 오퍼레이션 집합을 적용한다고 할지라도, 즉 Ap(ops) = Aq(ops)인 경우, 그들은 상이한 순서로 임의의 동시 오퍼레이션을 적용 할 수 있다. APPLY-REMOTE의 전제 op.deps ⊆ Ap(ops)로 인해, 히스토리는 인과 관계와 일치한다. 오퍼레이션에 인과 관계가 있는 경우, 히스토리의 종속성 이후 특정 위치에 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image2.png&quot; alt=&quot;image2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정의 3 (문서 상태). 복제본 p의 문서 상태는 문서를 포함한 Ap의 하위 트리이다(Ap(mapT(doc)) 또는 Ap (listT(doc)) 또는 Ap(regT(doc))).&lt;/p&gt;

&lt;p&gt;Ap는 let으로 정의한 변수를 포함하는데, 이는 하나의 복제본에 대해 로컬이며 복제 된 상태의 일부가 아니다. 문서 상태의 정의는 이러한 변수를 제외한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image5.png&quot; alt=&quot;image5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정리. 유효한 실행에 참여한 두 개의 복제본 p와 q에 대해 Ap (ops) = Aq (ops)이면 p와 q는 동일한 문서 상태를 갖는다.&lt;/p&gt;

&lt;p&gt;이 정리는 부록에서 증명한다. 이것은 수렴의 안전성을 공식화한다. 두 개의 복제본이 동일한 순서의 오퍼레이션을 다른 순서로 처리 한 경우 동일한 상태로 수렴한다. 활성 속성(aliveness)과 함께, 모든 복제본이 결국 모든 오퍼레이션을 처리하므로 원하는 수렴 개념을 얻는디. 모든 복제본은 결국 동일한 상태로 끝난다.&lt;/p&gt;

&lt;p&gt;활성 속성은 충분히 자주 yeild를 호출하는 복제본의 가정과 공정하게 선택되는 yeild에 대한 모든 비결정적 규칙에 따라 달라진다. 이 논문에서 활성 속성을 공식화하지 않지만, 일반적으로 네트워크 중단은 유한한 기간이기 때문에 실제로는 적용될 수 있다고 주장한다.&lt;/p&gt;

&lt;h2 id=&quot;5-결론-향후-작업&quot;&gt;5. 결론, 향후 작업&lt;/h2&gt;

&lt;p&gt;이 논문에서는 JSON 데이터 모델을 사용하여 리스트, 맵 및 레지스터의 중첩 CRDT를 작성하는 방법을 설명했다. 임의로 중첩 된 리스트, 맵을 지원하며 복제본이 네트워크 통신을 기다리지 않고 데이터를 임의로 변경할 수 있다. 복제본은 비동기적 조작의 형태로 다른 복제본에 변형을 전송한다. 동시 오퍼레이션은 교환 가능(commutative)하므로 애플리케이션 별 충돌 해결 로직이 없어도 복제본이 동일한 상태로 수렴 된다.&lt;/p&gt;

&lt;p&gt;이 논문은 JSON CRDT의 형식 의미론에 중점을 두고 수학적 모델로 표현했다. 우리는 알고리즘의 실제 구현을 위해 작업 중이며 후속 작업에서 성능 특성을 보고 할 예정이다.&lt;/p&gt;

&lt;p&gt;동시 수정으로 인해 입력을 잃지 않는 원칙은 처음에는 합리적이라고 판단되었지만 그림 6에서 볼 수 있듯이 순차 프로그램에 익숙한 애플리케이션 프로그래머에게는 문제(suprising) 상태가 되기도 한다. 애플리케이션 프로그래머의 기대치를 이해하고 동시에 수정하는 경우에는 데이터 구조를 설계하기 위해서는 더 많은 작업이 필요하다. 더 복잡한 애플리케이션을 지원하려면 스키마 언어가 필요할 것이다. 스키마 언어는 숫자가 레지스터가 아닌 카운터로 취급 되어야한다는 의미와 같은 의미론적 주석이 필요할 수도 있다.&lt;/p&gt;

&lt;p&gt;이 논문에서 정의 된 CRDT는 삽입, 삭제 및 할당 작업을 지원한다. 이 외에도 이동 오퍼레이션(순서가 지정된 목록에서 요소의 순서를 변경하거나 문서의 한 위치에서 다른 위치로 하위 트리를 이동) 및 실행/취소 오퍼레이션을 지원하는 것이 유용할 것이다. 또한 데이터 구조의 무한한 확장을 막기 위해 쓰레기 수집(garbage collection, tombstone 제거)이 필요하다.&lt;/p&gt;

&lt;p&gt;향후 작업에서 이러한 누락 된 기능을 해결할 계획이다.&lt;/p&gt;

&lt;p&gt;(Appendix 생략… 어려워서…)&lt;/p&gt;

&lt;h2 id=&quot;원문-논문-링크&quot;&gt;원문 논문 링크&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1608.03960.pdf&quot;&gt;A Conflict-Free Replicated JSON Datatype.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>hackerwins</name><email>susukang98@gmail.com</email></author><category term="crdt" /><category term="paper" /><summary type="html">“A Conflict-Free Replicated JSON Datatype” 읽으면서 정리한 내용</summary></entry><entry><title type="html">High Responsiveness for Group Editing CRDTs 요약</title><link href="/2018-09-14/high-responsiveness-for-group-editing-crdts" rel="alternate" type="text/html" title="High Responsiveness for Group Editing CRDTs 요약" /><published>2018-09-14T01:00:00+00:00</published><updated>2018-09-14T01:00:00+00:00</updated><id>/2018-09-14/high-responsiveness-for-group-editing-crdts</id><content type="html" xml:base="/2018-09-14/high-responsiveness-for-group-editing-crdts">&lt;blockquote&gt;
  &lt;p&gt;“High Responsiveness for Group Editing CRDTs.” 읽으면서 정리한 내용&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;요약&quot;&gt;요약&lt;/h2&gt;

&lt;p&gt;공동 편집에는 빠른 응답성을 위해서 OT, CRDT와 같은 Optimistic Replication 알고리즘이 사용되고 있음.
보통 CRDT가 downstream(원격) 오퍼레이션을 처리할 때 빠름(CRDT: 지수 시간, OT: 제곱 시간). 하지만 CRDT는 upstream(로컬) 오퍼레이션 처리시 선형 시간 복잡도라서 응답성이 느림&lt;/p&gt;

&lt;p&gt;이 논문은 CRDT의 앞 부분에 “identifier data structure”라는 보조 데이터 타입을 제공해서 upstream 오퍼레이션 처리를 개선하는 방법을 제안함. identifier data structure는 동기화나 복제를 필요로 하지 않음.&lt;/p&gt;

&lt;p&gt;identifier data structure를 블록 단위 저장 접근 방식과 함께 사용하면 upstream 실행을 상당히 개선할 수 있음(무시해도 되는 정도의 메모리, 네트워크, downstream 실행 시간이 추가됨).&lt;/p&gt;

&lt;h2 id=&quot;1-도입&quot;&gt;1. 도입&lt;/h2&gt;

&lt;h3 id=&quot;optimistic-replication&quot;&gt;Optimistic Replication&lt;/h3&gt;

&lt;p&gt;공동 편집에는 응답성이 매우 중요하므로 네트워크 지연이나 문서의 락에 영향을 받지 않도록 모든 유저는 자신의 디바이스에 편집하는 문서의 리플리카를 갖고 있는데, 이를 Optimistic Replication이라 부른다.
사용자의 편집 오퍼레이션은 로컬 리플리카에 먼저 반영되고 원격에 있는 다른 사용자의 리플리카에 전송된다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;upstream 실행: 로컬 오퍼레이션을 처리&lt;/li&gt;
  &lt;li&gt;downstream 실행: 다른 사용자가 전송한 원격 오퍼레이션을 처리, 임의의 동시 편집도 해결 해야함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ot&quot;&gt;OT&lt;/h3&gt;

&lt;p&gt;OT는 upstream의 빠른 응답성으로 공동 편집에 사용되었지만, 각 리플리카의 히스토리를 재정렬하고 오퍼레이션을 변환해야 하므로 downstream의 처리 속도가 특히 분산 환경에서 매우 느림(O(N^2k), N: 오퍼레이션의 수, k: 리플리카 수).&lt;/p&gt;

&lt;h3 id=&quot;crdt&quot;&gt;CRDT&lt;/h3&gt;

&lt;p&gt;이를 해결하기 위해서 CRDT가 도입되었고 교환 법칙(commutative)의 오퍼레이션을 사용해서 downstream 실행시 리플리카의 일관성을 위해서 오퍼레이션을 별도로 변환하거나 정렬할 필요가 없다.
하지만 보통 CRDT 유형의 알고리즘은 upstream 처리시에 고유한 identifier를 생성하거나 조회되어야 하므로 upstream 처리가 느린 경향이 있다.&lt;/p&gt;

&lt;h3 id=&quot;block-wise-approach&quot;&gt;Block-wise approach&lt;/h3&gt;

&lt;p&gt;이를 개선하는 첫 제안은 문자를 하나하나 저장하지 않고 블록 단위로 저장하는 것이었는데, 고유한 identifier를 갖는 요소들이 줄어드므로 선형적인 처리시 유리했고 각 요소가 고유한 identifier와 같이 메타데이터를 갖고 있었으므로 메모리도 작게 사용했다. 하지만 블록으로 연결했다고 하지만 여전히 선형 시간의 복잡도를 갖고 있다.&lt;/p&gt;

&lt;h3 id=&quot;identifier-data-structure&quot;&gt;Identifier data structure&lt;/h3&gt;

&lt;p&gt;이 논문은 upstream 처리 시간을 상당히 개선할 수 있으며 대부분의 CRDT 알고리즘에 적용할 수 있는 Identifier data structure를 제안하는데, 이는 각 피어(peer)가 자신의 독립적인 구조를 갖고 있으므로 동기화 할 필요가 없고 동시성 이슈를 고려할 필요가 없다. Identifier data structure를 도입하면 본래의 알고리즘에 비해서 네트워크, 메모리 그리고 downstream 처리에 약간의 간접 비용이 있지만 무시할 정도다.&lt;/p&gt;

&lt;h2 id=&quot;2-배경-관련-crdt들&quot;&gt;2. 배경, 관련 CRDT들&lt;/h2&gt;

&lt;h3 id=&quot;231--woot&quot;&gt;2.3.1  WOOT&lt;/h3&gt;

&lt;p&gt;WOOT에서 identifier는 피어의 아이디와 삽입시 좌우측의 두 앨리먼트에 대한 링크로 구성된다. 결정론적 알고리즘으로 동일한 구역에서 요소들이 동일한 순서를 갖지만, 매우 복잡하고 처리 비용이 크다. 각 요소의 위치가 이웃 요소와 관계에 의해 결정되므로 완전히 삭제하기가 어려워서 tombstone을 사용한다. WOOT의 최적화 버전이 제안되었지만, downstream 처리 속도만 개선되었다.&lt;/p&gt;

&lt;h3 id=&quot;232-treedoc&quot;&gt;2.3.2 TreeDoc&lt;/h3&gt;

&lt;p&gt;요소의 비균형 이진 탐색트리로 요소의 identifier는 트리에서의 Path이다. 이진탐색이 가능하지만, 트리가 비균형이므로 문서의 끝에 계속해서 텍스트를 입력할 경우, 균형이 깨져서 고비용이 발생한다. 모든 피어에서 트리의 모양이 동일하며, 균형을 맞추려면 모든 피어를 동기화 해야하므로 균형을 잡는 것은 불가능하다. tombstone을 사용하지만, 특정 조건에서 제거가 가능하다.&lt;/p&gt;

&lt;h3 id=&quot;233-logoot&quot;&gt;2.3.3 Logoot&lt;/h3&gt;

&lt;p&gt;어휘 순서를 사용해서 문서의 요소의 순서를 잡는다. identifier는 3개의 정수형 튜플(1: 우선순위, 2: Upstream 피어 ID, 3: Upstream 논리 시계)의 리스트다. identifier는 배열에 저장되며, 새로운 요소 삽입을 위해서는 배열의 shift가 발생한다. (생략)&lt;/p&gt;

&lt;h3 id=&quot;234-logootsplit&quot;&gt;2.3.4 LogootSplit&lt;/h3&gt;

&lt;p&gt;Logoot의 블록버전 (생략)&lt;/p&gt;

&lt;h3 id=&quot;235-rga&quot;&gt;2.3.5 RGA&lt;/h3&gt;

&lt;p&gt;RGA는 문서에서 모든 요소는 특정 요소 뒤에 추가된다는 점을 이용한다. RGA 자료구조는 링크드 리스트로 각 요소는 내용과 다음 요소의 링크, tombstone으로 구성된다. identifier는 피어 ID, sum(삽입중 upstream 벡터 시계의 합)으로 구성된다. identifier의 순서는 피어 ID와 sum으로 판단된다.&lt;/p&gt;

&lt;h3 id=&quot;24-요약&quot;&gt;2.4 요약&lt;/h3&gt;

&lt;p&gt;빠른 반응성을 위해서 upstream에서 로그 시간 복잡도가 필요하지만, 이전 알고리즘은 이를 제공하지 못했다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OT는 TTF tombstone&lt;/li&gt;
  &lt;li&gt;RGA와 WOOT는 tombstone&lt;/li&gt;
  &lt;li&gt;Logoot는 자체 배열을 shift해야 했으며, LogootSplit은 identifier를 관리해야 함&lt;/li&gt;
  &lt;li&gt;Treedoc은 불균형 트리를 탐색해야 함&lt;/li&gt;
  &lt;li&gt;Block 접근방식은 블록 크기에 의존적&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사용성에 직결되는 upstream 실행시간은 매우 중요했다. RGA는 downstream 실행이 매우 우수했다.&lt;/p&gt;

&lt;h2 id=&quot;3-identifier-자료구조&quot;&gt;3. Identifier 자료구조&lt;/h2&gt;

&lt;p&gt;이 논문에서는 각 피어마다 본 알고리즘에 영향도가 작은 Identifier 자료구조를 제안한다. upstream 실행시간을 로그시간으로 수행한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/fe21ad0c-b50e-11e8-90df-507ecf589d46&quot; alt=&quot;screen shot 2018-09-07 at 2 27 56 pm&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스텝 1: 사용자 액션&lt;/li&gt;
  &lt;li&gt;스텝 2: 사용자의 액션으로부터 Identifier 자료구조를 사용해서 Node를 조회&lt;/li&gt;
  &lt;li&gt;스텝 3-5: 본 알고리즘과 동일한 복제 과정&lt;/li&gt;
  &lt;li&gt;스텝 6-7: 원격 오퍼레이션을 받아서 로컬 Identifier 자료구조를 업데이트&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;idNode는 Node를 참조를 갖고 있고 반대로 Node는 idNode의 참조를 갖고 있다.&lt;/p&gt;

&lt;h3 id=&quot;31-crdt-identifier를-조회하기&quot;&gt;3.1 CRDT identifier를 조회하기&lt;/h3&gt;

&lt;p&gt;RGA와 WOOT, LogooSplit에서 문서의 노드를 조회할 때 시작작 노드부터 찾는 위치의 노드를 만날때 까지 선형탐색 한다(O(N)).&lt;/p&gt;

&lt;p&gt;Identifier 자료구조는 사용자의 수정 위치를 입력받아서 CRDT identifier를 빠르게 찾는 역할을 한다. Identifier가 순서를 갖고 있다면, Identifier 자료구조는 스킵 리스트와 같은 SortedMap이거나 혹은 weighted binary tree가 될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/10a1c958-b50f-11e8-8df6-283fcd58f2b2&quot; alt=&quot;screen shot 2018-09-10 at 9 13 35 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;RGA에 identifier 자료구조(weighted tree)를 적용할 경우&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;idNode: 레퍼런스(left child, right child, parent)와 weight(하위 트리의 전체 크기), RGA 노드의 참조&lt;/li&gt;
  &lt;li&gt;RGA Node: 기본 (identifier, 내용, next 레퍼런스, tombstone)에 idNode의 참조 추가&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/1fe8bebc-b50f-11e8-898d-d41ef1e3d80f&quot; alt=&quot;screen shot 2018-09-10 at 9 23 01 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사용자의 위치(pos)로 부터 특정 Node를 찾을 때, weight를 비교하면서 identifier를 검색&lt;/p&gt;

&lt;h3 id=&quot;32-downstream-에서-identifier-자료구조-업데이트하기&quot;&gt;3.2 downstream 에서 identifier 자료구조 업데이트하기&lt;/h3&gt;

&lt;p&gt;RGA에서 삽입 오퍼레이션에는 대상 노드의 identifier와 새로운 값이 포함되어 있다. 이 논문에서는 downstream에서 RGA의 기본 알고리즘으로 대상 노드가 찾아진 뒤에 identifier 자료구조를 업데이트 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/2c41abd8-b50f-11e8-8d4c-508c65dc57ad&quot; alt=&quot;screen shot 2018-09-10 at 9 38 08 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Identifier 자료구조는 tombstone 노드를 포함하지 않으므로 deletion에는 아무처리를 하지 않고 insertion의 경우 아래와 같은 로직을 수행한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;(XXX: 삭제시에도 대상 idNode를 삭제하고 weight를 업데이트 해야한다).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/38e1c12a-b50f-11e8-9473-421d9ffc3083&quot; alt=&quot;screen shot 2018-09-10 at 9 51 54 am&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;33-identifier-자료구조-logoot에-적용&quot;&gt;3.3 identifier 자료구조 Logoot에 적용&lt;/h3&gt;
&lt;p&gt;(생략)&lt;/p&gt;

&lt;h2 id=&quot;4-rgatreesplit-rga--블록화--identifier-자료구조&quot;&gt;4. RGATreeSplit: RGA + 블록화 + identifier 자료구조&lt;/h2&gt;

&lt;p&gt;논문에서는 RGA가 downstream 실행에 가장 효율적인 알고리즘이고 블록 알고리즘을 적용하면, upstream과 downstream 실행을 모두 개선하므로 identifier 자료구조를 포함한 RGATreeSplit을 제안함.&lt;/p&gt;

&lt;h3 id=&quot;41-block-wise-rga-rga--블록화&quot;&gt;4.1 block-wise RGA: RGA + 블록화&lt;/h3&gt;

&lt;p&gt;이 논문에서는 block-wise RGA에는 “W. Yu. A string-wise CRDT for group editing.”에서 제안한 split과 offset 개념을 추가했다.&lt;/p&gt;

&lt;p&gt;각 노드는 다음 속성을 갖고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;content: 메모리 효율을 위해서 tombstone화 되면, 제거 될 수 있다.&lt;/li&gt;
  &lt;li&gt;identifier: 기존 RGA identifier&lt;/li&gt;
  &lt;li&gt;nextLink: 기존 RGA의 다음 노드의 참조&lt;/li&gt;
  &lt;li&gt;offset: 사용자가 삽입한 본 위치&lt;/li&gt;
  &lt;li&gt;splitLink: split시에 다음 노드의 참조&lt;/li&gt;
  &lt;li&gt;length: 본문의 크기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;offset x에 있는 노드를 pos로 split하면, 첫 노드의 offset은 x, 두 번째 노드의 offset은 x + pos&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/46c07a70-b50f-11e8-8165-7658b7743483&quot; alt=&quot;screen shot 2018-09-10 at 10 07 34 am&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;리플리카 1에서 사용자가 “ABCDEF” 삽입, identifier 는 [[1, 0], 0]&lt;/li&gt;
  &lt;li&gt;리플리카 2에서 “ABCDEF”를 전달받고 사용자가 “XY”를 pos 3에 추가, identifier 는 [[2, 1], 0]
 “ABCDEF” 블록은 “ABC”, identifier [[1, 0], 0]와 “DEF”, identifier [[1, 0], 3]로 쪼개짐&lt;/li&gt;
  &lt;li&gt;리플리카 2에서 “56789”를 마지막에 삽입 identifier는 [[2, 2], 0]&lt;/li&gt;
  &lt;li&gt;리플리카 2에서 “78” 삭제 “56789” 블록은 (“56” identifier [[2,2],0])과 (tombstone, identifier [[2, 2], 2])그리고 (“9” identifier [[2, 2], 4])로 쪼개짐.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;FINDOFFSET: identifier와 offset을 입력받아서 특정 node를 찾는 함수&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/508ff13e-b50f-11e8-9f91-3d5ebd6e3b84&quot; alt=&quot;screen shot 2018-09-10 at 10 23 17 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;splitLink는 identifier와 offset을 기준으로 특정 노드를 찾을 때, 성능을 위해 사용함.&lt;/p&gt;

&lt;h3 id=&quot;42-rgatreesplit의-identifier-자료구조&quot;&gt;4.2 RGATreeSplit의 identifier 자료구조&lt;/h3&gt;

&lt;p&gt;기본적으로 3절과 비슷하지만, 몇 가지 차이가 있음&lt;/p&gt;

&lt;p&gt;첫째. Identifier 자료구조와 findPosInIdentifierTree 함수의 weight에 블록 content의 크기를 반영한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/5b4de342-b50f-11e8-890b-ed6046b935e7&quot; alt=&quot;screen shot 2018-09-10 at 10 31 21 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;둘째. 오퍼레이션 반영시에 대상 노드를 분할해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/6855f8c2-b50f-11e8-83c1-2a30ab65a931&quot; alt=&quot;screen shot 2018-09-10 at 1 37 57 pm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;삽입 오퍼레이션은 3개(2개: 기존 노드 split, 1개: 새로운 노드)의 새로운 블록을 만들어야한다. 간단한 방법은 기존 노드를 새로운 노드의 값으로 치환하고 새로운 노드 좌측(insertBefore))과 우측(insertAfter)에 2개의 split 노드를 삽입하는 방법이다.&lt;/p&gt;

&lt;h2 id=&quot;5-평가와-실험&quot;&gt;5. 평가와 실험&lt;/h2&gt;
&lt;h3 id=&quot;51-구현&quot;&gt;5.1 구현&lt;/h3&gt;

&lt;p&gt;3절의 identifier 자료구조로 Binary weighted tree를 도입하는 경우 balanced 혹은 unbalanced(주기적 balance)의 두가지 구현 방식이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RGA, Logoot: TreeList(AVL 기반), 단순한 구현위해 downstream에도 별도 hashtable 없이 TreeList로 찾음&lt;/li&gt;
  &lt;li&gt;RGATreeSplit: weighted unbalanced binary tree(주기적으로 리밸런싱 수행), 리밸런싱 처리도중 응답성이 떨어질 수 있으므로 사용자가 편집을 잠시 쉬는 동안 실행 권장(실험용 구현이라 그냥 이렇게 함…)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;52-실험&quot;&gt;5.2 실험&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;노드: Intel Xeon X3440 processors (2.53GHz), 16GB of RAM, Wheezy-x64-big-1.0 operating systems on Debian. 싱글 쓰레드.&lt;/li&gt;
  &lt;li&gt;입력: 사용자 수정 오퍼레이션을 무작위로 생성했으며, 모든 알고리즘에 대해 동일한 세트 사용&lt;/li&gt;
  &lt;li&gt;오퍼레이션의 수와 순서가 서로 다른 여섯 개의 실험(5000, 10000, 15000, 20000, 30000 및 40000개)
    &lt;h3 id=&quot;53-싱글-엘리먼트-시리즈&quot;&gt;5.3 싱글 엘리먼트 시리즈&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/72babc58-b50f-11e8-9eab-45bf8b0457ce&quot; alt=&quot;screen shot 2018-09-10 at 3 03 25 pm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/7a1e946a-b50f-11e8-8ad9-3d8723fcf8a5&quot; alt=&quot;screen shot 2018-09-10 at 3 03 49 pm&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;입력 오퍼레이션 특징: 한 요소에만 영향을 주는 수정&lt;/li&gt;
  &lt;li&gt;RGA와 RGASplit 성능이 비슷, RGATreeList와 RGATreeSplit도 성능이 비슷&lt;/li&gt;
  &lt;li&gt;예상한 대로 identifier 자료구조를 사용한 경우 upstream에서 매우 성능이 빨라짐&lt;/li&gt;
  &lt;li&gt;downstream에서 identifier 자료구조 + RGA는 성능이 소폭 하락(identifier 자료구조 업데이트 해야 하므로)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;54-블록-시리즈-수정&quot;&gt;5.4 블록 시리즈 수정&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/8538104c-b50f-11e8-867e-423ebea739ac&quot; alt=&quot;screen shot 2018-09-10 at 2 05 38 pm&quot; /&gt;
&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/8d6678bc-b50f-11e8-8c69-5bec9f3f5764&quot; alt=&quot;screen shot 2018-09-10 at 3 12 39 pm&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;입력 오퍼레이션 특징: 80% 한 요소 수정과 20% 블록 수정, 블록의 평균 길이 20개&lt;/li&gt;
  &lt;li&gt;블록 기반 알고리즘이 기본 알고리즘보다 upstream과 downstream 모두에서 성능이 향상되었지만 빠른 응답을 위해 충분하지 않음&lt;/li&gt;
  &lt;li&gt;RGASplit은 시간이 지남에 따라 성능이 저하 됨.&lt;/li&gt;
  &lt;li&gt;LogootSplitAVL, TreeDoc은 원래의 RGA 알고리즘보다 다운 스트림 성능이 떨어짐&lt;/li&gt;
  &lt;li&gt;RGATreeSplit은 전반적인 성능이 가장 좋음&lt;/li&gt;
  &lt;li&gt;LogootTree는 RGATreeSplit보다 성능이 떨어지지만 블록 관리가 없어도 LogootSplitAVL과 유사한 성능 보임&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-결론&quot;&gt;6. 결론&lt;/h2&gt;

&lt;p&gt;이 논문에서는 CRDT 알고리즘의 응답성을 향상 시키기 위해서 블록 단위 알고리즘과 log 시간 복잡도를 위한 추가 identifier 자료구조를 제안한다. 특히, 사용자의 수정 사항을 반영하는 upstream 을 크게 개선되므로 체감 속도를 크게 향상된다.&lt;/p&gt;

&lt;h2 id=&quot;원본-논문-링크&quot;&gt;원본 논문 링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://pages.lip6.fr/Marc.Shapiro/papers/rgasplit-group2016-11.pdf&quot;&gt;High Responsiveness for Group Editing CRDTs.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>hackerwins</name><email>susukang98@gmail.com</email></author><category term="crdt" /><category term="paper" /><summary type="html">“High Responsiveness for Group Editing CRDTs.” 읽으면서 정리한 내용</summary></entry><entry><title type="html">썸머노트 이야기</title><link href="/2015-12-19/summernote-story" rel="alternate" type="text/html" title="썸머노트 이야기" /><published>2015-12-19T11:00:00+00:00</published><updated>2015-12-19T11:00:00+00:00</updated><id>/2015-12-19/summernote-story</id><content type="html" xml:base="/2015-12-19/summernote-story">&lt;p&gt;1Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-01.jpg&quot; alt=&quot;summernote-story-01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;안녕하세요. 썸머노트를 개발하고 있는 홍영택이라고 합니다. 반갑습니다.
오늘은 제가 개발하고 있는 썸머노트를 소개하고 오픈소스 프로젝트에 대해 간단하게 이야기하려고 합니다.&lt;/p&gt;

&lt;p&gt;2Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-02.jpg&quot; alt=&quot;summernote-story-02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;썸머노트는 부트스트랩 위에서 돌아가는 WYSIWYG 에디터입니다. WYSIWYG 에디터는 카페나 블로그에서 글을 편집하는 편집기입니다.
라이브러리 파일을 페이지에 추가하고 코드 한 줄만 입력하면 에디터를 생성할 수 있습니다. 홈페이지에서 간단히 보여드릴께요.&lt;/p&gt;

&lt;p&gt;3Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-03.jpg&quot; alt=&quot;summernote-story-03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;썸머노트는 2013년 4월부터 개발했고요. 지금까지 2년반이 넘는 시간동안 꾸준히 작은 패치들을 이어가면서, 릴리즈를 해오고 있습니다.&lt;/p&gt;

&lt;p&gt;4Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-04.jpg&quot; alt=&quot;summernote-story-04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다양한 분들이 썸머노트를 사용해 주시고 계시고요. IE8을 제대로 지원 못해서 인지 아직은 국내보다는 해외에서 인기가 많은 편입니다.&lt;/p&gt;

&lt;p&gt;5Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-05.jpg&quot; alt=&quot;summernote-story-05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;썸머노트는 사실 부트스트랩 묻어 간거 같습니다. 부트스트랩이라는 큰 바람을 등에 지고 있어서 쉽게 인기를 얻었습니다. 사용자들은 많은 페이지를 부트스트랩으로 만들었고 부트스트랩을 사용하는 사용자들은 에디터가 필요할 때 썸머노트를 사용했습니다.&lt;/p&gt;

&lt;p&gt;6Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-06.jpg&quot; alt=&quot;summernote-story-06&quot; /&gt;&lt;/p&gt;

&lt;p&gt;간단히 썸머노트와 관련된 숫자를 보여드릴께요.&lt;/p&gt;

&lt;p&gt;7Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-07.jpg&quot; alt=&quot;summernote-story-07&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2년 반동안 37번의 릴리즈를 했고요&lt;/p&gt;

&lt;p&gt;8Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-08.jpg&quot; alt=&quot;summernote-story-08&quot; /&gt;&lt;/p&gt;

&lt;p&gt;깃헙에는 107개의 관련 리파지토리가 있습니다.&lt;/p&gt;

&lt;p&gt;9Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-09.jpg&quot; alt=&quot;summernote-story-09&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지금까지 122명의 누적 컨트리뷰터들이 있고요&lt;/p&gt;

&lt;p&gt;10Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-10.jpg&quot; alt=&quot;summernote-story-10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;깃허브에서 371번째로 인기가 많은 자바스크립트 프로젝트입니다.&lt;/p&gt;

&lt;p&gt;11Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-11.jpg&quot; alt=&quot;summernote-story-11&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스택오버플로우에서는 604개의 관련 질문들이 검색되고 있습니다.&lt;/p&gt;

&lt;p&gt;12Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-12.jpg&quot; alt=&quot;summernote-story-12&quot; /&gt;&lt;/p&gt;

&lt;p&gt;현재 저희의 상태는 아이언맨의 마크1에서 마크2로 가는 시점인 것 같습니다. 현재 썸머노트는 v0.7.0을 보름전에 릴리즈했는데요. v1.0.0을 찍는 시점에 마크 2의 모습을 보여줄 수 있을 것 같습니다.&lt;/p&gt;

&lt;p&gt;13Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-13.jpg&quot; alt=&quot;summernote-story-13&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이어서는 왜 썸머노트를 개발할 때, 오픈소스를 선택했는지 말씀드리고 싶습니다.&lt;/p&gt;

&lt;p&gt;14Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-14.jpg&quot; alt=&quot;summernote-story-14&quot; /&gt;&lt;/p&gt;

&lt;p&gt;썸머노트를 개발한 2013년 4월에는 네이버오피스라는 프로젝트를 전 회사에서 4년정도 개발했었는데요. 그 시기쯤 이직 준비를 하면서 그 동안 개발 했던 편집기를 더 못만들것 같다는 생각을 했습니다. 간단한 편집기 개발을 오픈소스로 시작하면, 회사와 상관없이 오래동안 꾸준히 할수 있을 거라고 생각했습니다. 그리고 다행히도 그 생각은 맞았던거 같습니다.&lt;/p&gt;

&lt;p&gt;15Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-15.jpg&quot; alt=&quot;summernote-story-15&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오픈소스 프로젝트를 하면서 좋은 개발자들을 만나보고 싶었습니다. 2013년까지 커뮤니티같은 외부 활동은 전혀 하지 않고 회사에서 일만하는 조용한 개발자였는데요. 뭔가 비슷한 관심사를 갖고 있는 개발자들을 만나보고 싶었고요. 좋은 개발자들을 만나서 개발을 배우고 싶었습니다. 꾸준히 하다보니 2년 반이 지난후에 썸머노트 팀을 꾸리게 되었습니다.&lt;/p&gt;

&lt;p&gt;16Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-16.jpg&quot; alt=&quot;summernote-story-16&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어쩌면 작은 기여라도 할수 있지 않을까? 하는 마음도 있었습니다. 개발자로 살면서 남들이 만든 코드를 많이 사용하고 있었는데, 나도 다른 개발자에게 기여할 수 있지 않을까 했었습니다. 현재는 운좋게도 다른 분들이 조금씩 사용하는 기쁜 경험을 하게 되었습니다.&lt;/p&gt;

&lt;p&gt;17Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-17.jpg&quot; alt=&quot;summernote-story-17&quot; /&gt;&lt;/p&gt;

&lt;p&gt;썸머노트를 운영하며 겪게된 3가지 에피소드 소개드릴께요.&lt;/p&gt;

&lt;p&gt;18Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-18.jpg&quot; alt=&quot;summernote-story-18&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2년전쯤 썸머노트의 첫번째 버전을 막 개발하고 여러 채널들을 돌아다니며, 썸머노트를 홍보했었는데요. reddit이라는 사이트에서 다른 개발자 분이 Y키가 눌러지지 않는다는 제보를 주셨습니다. 그분의 키보드가 고장났나 라는 생각을 잠깐 했다가 Y키를 눌러도 Y 문자가 입력되지 않는 걸 알게되었습니다. 이 댓글이 제가 사용자에게 받은 첫 버그 리포트 였습니다.&lt;/p&gt;

&lt;p&gt;19Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-19.jpg&quot; alt=&quot;summernote-story-19&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그 분은 이슈 게시판에 리포트했고 외부 PR를 날려서 누군가가 수정하고 있었습니다. lqez라는 아이디를 사용하는 한국 분이었고 전 이 풀 리퀘스트를 병합했었습니다. 배포한 에디터의 Y키가 눌러지지 않는 바보 같은 상황이었는데, 어떤 분이 나타나서 돕고 있었습니다. 어디서 이런 상황을 많이 본거 같았는데…&lt;/p&gt;

&lt;p&gt;20Page&lt;/p&gt;

&lt;hr /&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/fW8amMCVAJQ&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;이 분은 First follower 였습니다. 잠시 영상 보고 갈께요.&lt;/p&gt;

&lt;p&gt;21Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-21.jpg&quot; alt=&quot;summernote-story-21&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두 번째 에피소드는 영어에 대한 이야기 입니다. 외국 개발자들과 함께 쓰고 싶어서 되도록 썸머노트는 커밋과 주석 문서들을 영어로 작성했습니다.  그런데 한국분이 얼마전에 이슈를 한국어로 올렸는데, 까칠한 구글러 출신 아저씨가 영어로 쓰라고 말했습니다. 아까 말씀드린 퍼스트 팔로워 lqez님은 이 질문을 영어로 번역해서 다시 올렸고요.&lt;/p&gt;

&lt;p&gt;22Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-22.jpg&quot; alt=&quot;summernote-story-22&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저 또한 영어를 정말 못합니다. 초창기에는 지금보다 더 못해서 정말 엄지척만 날렸습니다. 질문에 댓글도 못다는 경우가 많았습니다.  지금도 잘하는 건 아니지만 노력은 열심히 하고 있습니다. 회사출근 전 아침에 영어 학원을 다니고 있고요. 점심에 영어선생님께 회화 수업을 받고 있습니다. 그래도 결국 구글 번역기 돌려서 질문하고 답변하고 있습니다. 그래도 이전보다는 나아진거 같아서 뿌듯합니다.&lt;/p&gt;

&lt;p&gt;23Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-23.jpg&quot; alt=&quot;summernote-story-23&quot; /&gt;&lt;/p&gt;

&lt;p&gt;올해 8월에 썸머노트가 해커뉴스에 랭크된 적이 있었습니다. 저도 몰랐는데, 전직장에서 같이 일하던 친구가 알려줘서 알게 되었습니다. 그 뒤로 몇달 뒤에 스타가 1000개 넘게 증가하고 트위터등의 여러 채널을 통해 퍼지는 경험을 했습니다. 이때 이슈도 많이 쌓였습니다.&lt;/p&gt;

&lt;p&gt;24Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-24.jpg&quot; alt=&quot;summernote-story-24&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그날 깃허브 트랜딩 리포트를 보니 자바스크립트 2위에 올랐었고요. 살다보면 이렇게 운좋은 날도 있는 것 같습니다.&lt;/p&gt;

&lt;p&gt;25Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-25.jpg&quot; alt=&quot;summernote-story-25&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이어서 오픈소스 프로젝트를 어떻게 시작하면 좋을지 이야기 해볼께요.&lt;/p&gt;

&lt;p&gt;26Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-26.jpg&quot; alt=&quot;summernote-story-26&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 주제를 찾아야 합니다. 다른 사람들이나 내가 필요한 것부터 시작하는게 좋다고 생각합니다. 혹시 그런게 생각 나지 않는다면, 그냥 만들고 싶은 것을 만드는 것도 좋습니다. 모든 걸 다 만들 필요는 없다고 생각합니다. 작더라도 가치가 있으면, 좋은 프로젝트라고 생각합니다.&lt;/p&gt;

&lt;p&gt;27Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-27.jpg&quot; alt=&quot;summernote-story-27&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오픈소스는 회사 일처럼 강제성이 있는 건 아니라서 완성하는게 어렵습니다. 이 단계에는 깔끔하지는 않더라도 돌아하게 만드는 게 중요하다고 생각합니다.&lt;/p&gt;

&lt;p&gt;28Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-28.jpg&quot; alt=&quot;summernote-story-28&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그냥 소스를 공개한다고 오픈소스는 아닌 것 같습니다. 깃허브에 좋은 프로젝트가 많은데, 설명을 하지 않아서 그냥 소스코드만 공개되어 있는 경우를 종종 봤습니다. 구현한 서비스나 라이브러리를 누군가와 같이 쓰게되고 공유하게 될때, 더 많은 가치가 생긴다고 생각합니다. 내가 만든 제품이나 서비스는 무엇인지 설명하고 왜 만들었는지도 설명하면 좋습니다. 썸머노트의 경우에는 에디터를 어떻게 설치하고 어떻게 기능을 사용하는지 설명했습니다. 새로운 버전을 릴리즈할 때 마다 Twitter나 Facebook를 통해서 소식을 알렸고 주요 기능들은 예제 파일을 만들었습니다.&lt;/p&gt;

&lt;p&gt;29Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-29.jpg&quot; alt=&quot;summernote-story-29&quot; /&gt;&lt;/p&gt;

&lt;p&gt;초기 아이디어를 구현하는데에는 개인이 빠른 경우도 있습니다. 토론할 시간에 자신이 생각한 아이디어를 그대로 구현할 수도 있습니다. 하지만 결국 오래 하려면, 혼자하는 건 어려운 일인 것 같습니다. 저 같은 경우는 운이 좋게 프로젝트를 할 수록 좋은 분들을 만날 수 있는 기회가 생겼습니다. 저보다 더 훌륭한 분들과 함께 썸머노트를 만들고 있는 것 같습니다.&lt;/p&gt;

&lt;p&gt;30Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-30.jpg&quot; alt=&quot;summernote-story-30&quot; /&gt;&lt;/p&gt;

&lt;p&gt;특별히 신경을 쓰지 않으면 코드와 제품은 복잡도가 증가해서 점점 엉망이 됩니다. 새로운 기능을 추가할 때마다 버그는 계속 생기고 이전에 해결하지 않은 코드들이 나중에 발목을 잡습니다. 정원을 가꾸 듯이 제품과 코드도 지속적으로 관리하고 정리해야 계속쓸 수 있는 코드 제품이 됩니다. 썸머노트 개발중에 큰 변화가 있는 경우에는 코드를 지속적으로 개선하려고 노력했습니다.&lt;/p&gt;

&lt;p&gt;31Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-31.jpg&quot; alt=&quot;summernote-story-31&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사용자와 얘기하고 새로운 기능을 추가하고 버그를 계속 고치고 제품의 품질을 올리는 것 등등 사실 제가 썸머노트를 개발하면 경험한 건 제품을 만드는 일이었습니다. 결국 오픈소스는 제품에 대해 알리고 소통하는 하나의 좋은 방법 중 하나라는 생각합니다.&lt;/p&gt;

&lt;p&gt;32Page&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2015-12-19-summernote-story/summernote-story-32.jpg&quot; alt=&quot;summernote-story-32&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 좋아하는 문구인데요. 안도 다다오의 물건만들기에 대한 문구로 발표를 끝마치겠습니다.&lt;/p&gt;</content><author><name>hackerwins</name><email>susukang98@gmail.com</email></author><category term="toy-project" /><category term="editor" /><category term="summernote" /><summary type="html">1Page</summary></entry><entry><title type="html">스프레드시트 셀 참조 처리하기</title><link href="/2013-04-25/spreadsheet-cell-reference" rel="alternate" type="text/html" title="스프레드시트 셀 참조 처리하기" /><published>2013-04-25T00:00:00+00:00</published><updated>2013-04-25T00:00:00+00:00</updated><id>/2013-04-25/spreadsheet-cell-reference</id><content type="html" xml:base="/2013-04-25/spreadsheet-cell-reference">&lt;h1 id=&quot;스프레드시트&quot;&gt;스프레드시트&lt;/h1&gt;

&lt;p&gt;스프레드시트는 유용한 애플리케이션이다. 스프레드시트를 이용해서 단순한 수식을 계산하거나 가계부처럼 숫자 형태의 데이터를 정리할 때 유용하다. 전에 운이 좋게 스프레드시트 개발에 참여하면서 몇 가지 알고리즘을 알게되었다. 그 중에 수식 평가기를 개발을 했던 일이 재미있었는데, 잊어버리지 않기 위해 기록한다.&lt;/p&gt;

&lt;h1 id=&quot;셀-참조cell-reference&quot;&gt;셀 참조(Cell reference)&lt;/h1&gt;

&lt;p&gt;스프레드시트의 셀에 등호(&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;)를 입력해서 수식(Formula)을 추가할 수 있다. 이 수식에는 함수(Function)나 다른 셀 참조(Cell reference)가 포함될 수 있다. 예를 들면 &lt;code class=&quot;highlighter-rouge&quot;&gt;A1&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;10&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;A2&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;20&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;A3&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;30&lt;/code&gt;이라는 숫자를 입력하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;B3&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;=sum(a1:a3)&lt;/code&gt;할 수 있는데, 이를 그림으로 표현하면 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2013-04-25-spreadsheet-cell-reference/simple-reference.png&quot; alt=&quot;simple-reference.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사용자가 마지막 &lt;code class=&quot;highlighter-rouge&quot;&gt;B3&lt;/code&gt; 셀의 입력을 완료하면 스프레드시트는 수식을 평가해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;60&lt;/code&gt;이라는 값을 &lt;code class=&quot;highlighter-rouge&quot;&gt;B3&lt;/code&gt; 셀에 표시한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;B3&lt;/code&gt; 셀의 수식 &lt;code class=&quot;highlighter-rouge&quot;&gt;sum(a1:a3)&lt;/code&gt;을 평가하기 전에 &lt;code class=&quot;highlighter-rouge&quot;&gt;B3&lt;/code&gt;셀이 참조하고 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;A1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;A2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;A3&lt;/code&gt;의 값이 먼저 평가 되어야 한다.&lt;/p&gt;

&lt;p&gt;셀 참조의 구조는 얼핏 보기에는 트리처럼 보이지만 사실 각 셀이 노드인 Directed acyclic graph(이하 DAG)이다. DAG은 순환(cycle)이 없는 유한 방향 그래프(finite directed graph)이다.&lt;/p&gt;

&lt;p&gt;조금 더 복잡한 셀 참조의 예는 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2013-04-25-spreadsheet-cell-reference/complex-reference.png&quot; alt=&quot;complex-reference.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;수식에 순환 참조가 포함되면, DAG이 아니므로 다음 그림과 같은 수식을 입력하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;#REF!&lt;/code&gt;와 같은 경고 메시지가 셀에 표시된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2013-04-25-spreadsheet-cell-reference/circular-reference.png&quot; alt=&quot;circular-reference.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 순환 참조가 있는 그래프를 별도의 처리 없이 Depth-first search(이하 DFS)로 탐색하면 무한 루프에 빠진다.&lt;/p&gt;

&lt;h1 id=&quot;수식-평가기-구현시-셀-참조-처리하기&quot;&gt;수식 평가기 구현시 셀 참조 처리하기&lt;/h1&gt;

&lt;p&gt;수식 평가기(Formula evaluator)를 구현할 때, DAG의 특징이 이용된다. 모든 DAG은 적어도 하나의 Topological order(위상 순서)가 있다. 이 순서는 특정 알고리즘을 사용해서 선형 시간에 구할 수 있다. Topological order는 셀 평가 순서와 일치한다.&lt;/p&gt;

&lt;p&gt;수식 평가기의 동작은 다음과 같이 처리했다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;셀 의존 테이블(&lt;code class=&quot;highlighter-rouge&quot;&gt;dependantMap&lt;/code&gt;)을 만든다.&lt;/li&gt;
  &lt;li&gt;셀 의존 테이블을 입력 받아 계산 체인(&lt;code class=&quot;highlighter-rouge&quot;&gt;calcChain&lt;/code&gt;, Topological order)를 만든다.&lt;/li&gt;
  &lt;li&gt;계산 체인(&lt;code class=&quot;highlighter-rouge&quot;&gt;calcChain&lt;/code&gt;)의 순서대로 셀을 평가한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2013-04-25-spreadsheet-cell-reference/complex-reference-change.png&quot; alt=&quot;complex-reference-change.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;의존 테이블은 특정 셀을 참조하는 셀 리스트를 값으로 갖는다. 위 그림에 표현 예제의 셀 의존 테이블은 다음과 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;셀&lt;/th&gt;
      &lt;th&gt;참조하는 셀&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;A2&lt;/td&gt;
      &lt;td&gt;[D1, B3]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;A3&lt;/td&gt;
      &lt;td&gt;[B3, C1]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;B3&lt;/td&gt;
      &lt;td&gt;[D1, C1]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;B4&lt;/td&gt;
      &lt;td&gt;[C1, C2]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;C1&lt;/td&gt;
      &lt;td&gt;[D1, C2]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이어서 의존 테이블과 변경된 셀의 목록을 입력 받아서 계산 체인을 만든다. 구현한 수식 평가기는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search&quot;&gt;DFS&lt;/a&gt;를 이용했다. 이전 예제에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;C1&lt;/code&gt;의 수식을 &lt;code class=&quot;highlighter-rouge&quot;&gt;A2+B3+B4&lt;/code&gt;로 변경 했다고 가정하면, &lt;code class=&quot;highlighter-rouge&quot;&gt;C1&lt;/code&gt;의 값을 평가하기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;C1&lt;/code&gt;에 직접 연결된 &lt;code class=&quot;highlighter-rouge&quot;&gt;A2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B3&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B4&lt;/code&gt;의 값이 필요하다. 하지만 이번 변경(계산)에서는 이들이 변경되지 않았으므로 이미 평가되어 있다고 가정한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;C1&lt;/code&gt;의 값이 변경된 뒤에 평가 해야할 셀들은 &lt;code class=&quot;highlighter-rouge&quot;&gt;D1&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;C2&lt;/code&gt;다. 따라서 &lt;code class=&quot;highlighter-rouge&quot;&gt;C1&lt;/code&gt;의 계산 체인은 &lt;code class=&quot;highlighter-rouge&quot;&gt;[D1, C2]&lt;/code&gt;가 된다. &lt;code class=&quot;highlighter-rouge&quot;&gt;D1&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;C2&lt;/code&gt;는 서로 의존 관계가 아니므로 순서는 상관 없다.&lt;/p&gt;

&lt;p&gt;코드는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Build calculation chain.
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;buildCalcChain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dependantMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;changedCells&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calcChain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitMap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sets&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newHashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sets&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newHashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;calcChain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;changedCells&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calcChain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dependantMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calcChain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calcChain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dependantMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calcChain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CircularReferenceException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visitMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;visitMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dependantMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;containsKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dependants&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dependantMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dependant&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dependants&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dependantMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calcChain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dependant&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;calcChain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마지막으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;calcChain&lt;/code&gt;을 따라 순서대로 Cell을 평가하고 결과 값을 화면에 표시한다.&lt;/p&gt;

&lt;h1 id=&quot;마무리&quot;&gt;마무리&lt;/h1&gt;

&lt;p&gt;스프레드시트를 개발한 일은 시간이 많이 지났지만, 아직도 생각난다. 또 이런 재미있는 개발을 했으면 좋겠다.&lt;/p&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Directed_acyclic_graph&quot;&gt;/wiki/Directed_acyclic_graph&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Topological_sorting&quot;&gt;/wiki/Topological_sorting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>hackerwins</name><email>susukang98@gmail.com</email></author><category term="spreadsheet" /><category term="formula" /><category term="data-structure" /><summary type="html">스프레드시트</summary></entry></feed>