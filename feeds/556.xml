<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by HyeonSeok Yang on Medium]]></title>
        <description><![CDATA[Stories by HyeonSeok Yang on Medium]]></description>
        <link>https://medium.com/@FourwingsY?source=rss-68cc49c8335f------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*l3oY1jwa9ShpfBnkyK17mQ.jpeg</url>
            <title>Stories by HyeonSeok Yang on Medium</title>
            <link>https://medium.com/@FourwingsY?source=rss-68cc49c8335f------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Tue, 14 May 2019 10:08:22 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@FourwingsY" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[React와 Typescript의 미묘한 불일치]]></title>
            <link>https://medium.com/@FourwingsY/react%EC%99%80-typescript%EC%9D%98-%EB%AF%B8%EB%AC%98%ED%95%9C-%EB%B6%88%EC%9D%BC%EC%B9%98-b8f0e2bfe05d?source=rss-68cc49c8335f------2</link>
            <guid isPermaLink="false">https://medium.com/p/b8f0e2bfe05d</guid>
            <category><![CDATA[typescript]]></category>
            <category><![CDATA[react]]></category>
            <dc:creator><![CDATA[HyeonSeok Yang]]></dc:creator>
            <pubDate>Mon, 02 Apr 2018 14:46:27 GMT</pubDate>
            <atom:updated>2018-10-28T10:00:14.513Z</atom:updated>
            <content:encoded><![CDATA[<p>리액트는 타입스크립트로 짜인 코드가 아니다. 이것은 타입스크립트와 리액트를 동시에 사용하려고 할 때, 특히 타입스크립트를 제대로 써 보고자 할 때 걸림돌로 작용한다.</p><p>리액트와 같이 타입스크립트로 짜여지지 않은 프로젝트를 위해, 타입스크립트 커뮤니티에서는 DefinitelyTyped라는 프로젝트를 운영하고 있다. 이 프로젝트는 마치 다른 언어의 인터페이스 파일처럼, 타입스크립트로 작성되지 않은 프로젝트의 인터페이스를 커뮤니티에서 제작하여 배포하는 프로젝트이다. 이것은 타입스크립트가 Flow에 대비해서 가지는 가장 큰 장점-커뮤니티 유지보수로 업데이트가 되므로, 라이브러리 제작자에게 기대지 않아도 되며, 커뮤니티의 크기만큼 지원되는 라이브러리가 많다-이지만, 실제 구현과는 다르게 인풋 아웃풋만을 체크할 수 있다는 점에서 정의의 어려움과 실제 동작과의 불일치가 종종 발생한다.</p><p>리액트 역시, 타입을 정의하기 힘든 — 전체 프로젝트가 아닌 expored된 함수/객체 타이핑만으로는 나타내기 어려운 — 자바스크립트 동작들이 있고, 불완전한 타입 정의를 가지고 있다. 그 중에서도 컴포넌트의 타입에 제네릭으로 정의된 Props는 이 문제의 중심이다. 여기에 타입스크립트를 제대로 활용해보고자 strictNullCheck 옵션을 켜고 나면, 재앙이 펼쳐진다. 이 글에서는 내가 겪은 재앙의 몇몇 단면을 소개하려고 한다.</p><h3>HOC with Props injection</h3><p><strong>(Updated) 이 문제는 HOC를 쓰지 않고 새로 발표된 </strong><a href="https://reactjs.org/docs/hooks-intro.html"><strong>hooks</strong></a><strong>을 사용한다면 해결될 수 있을것으로 보인다. 단 class component대신 function component를 사용해야 한다는 문제가 있다.</strong></p><p>다음과 같은 HOC를 생각해보자.</p><pre>function withFoo&lt;P&gt;(WrappedComponent: ComponentType&lt;P&gt;) {<br>  return class extends Component&lt;P&gt; {<br>    ...<br>    render() {<br>      return &lt;WrappedComponent foo=&quot;foo_bar&quot; {...this.props} /&gt;;<br>    }<br>  }<br>}</pre><p>withFoo함수는 ComponentType(ComponentClass | SFC)를 인자로 받아, 해당 컴포넌트에 foo라는 props를 추가하여 렌더링하는 어떤 HOC이다. 이 코드의 문제점은 무엇일까?</p><p>첫째로, withFoo에 전달되는 컴포넌트가 foo라는 props를 받을 수 있어야 한다는 점이다. 물론, 이 함수를 사용하는 개발자가 이 정도를 빼먹었을 리는 없다. 다만 제네릭 타입은 조금 고쳐져야 하겠다.</p><pre>function withFoo&lt;P<strong> extends { foo?: string }</strong>&gt;(WrappedComponent: ComponentType&lt;P&gt;) {<br>  return class extends Component&lt;P&gt; {<br>    ...<br>    render() {<br>      return &lt;WrappedComponent foo=&quot;foo_bar&quot; {...this.props} /&gt;;<br>    }<br>  }<br>}</pre><p>두 번째 문제는 이 HOC를 사용할 때 나타난다.</p><pre>interface SomeProps {<br>  foo: string<br>}<br>class SomeComponent extends Component&lt;SomeProps&gt; {<br>  render() {<br>    return &lt;span&gt;{this.props.foo.split(&#39;_&#39;)[0]}&lt;/span&gt;<br>  }<br>}</pre><pre>const WrappedComponent = withFoo(SomeComponent)</pre><pre>// 여기까지는 문제가 없다.</pre><pre>class OuterComponent extends Component {<br>  render() {<br>    return (<br>      &lt;<strong>WrappedComponent</strong> /&gt;<br>    )<br>  }<br>}</pre><p>&lt;WrappedComponent /&gt;를 렌더링하는 시점에, SomeComponent의 props.foo가 옵셔널하지 않기 때문에, foo라는 props를 꼭 넣어달라는 에러가 발생한다.</p><p>이 문제를 처음 접하는 개발자라면 SomeComponent는 foo가 꼭 있어야 올바른 상황이라고 생각할 테지만, HOC를 통해 만들어진 WrappedComponent는 foo를 주입받으므로, 옵셔널하게 처리해도 괜찮아 보인다고 생각할 수 있다. 그렇다면 SomeProps의 foo를 옵셔널한 타입으로 변경하는게 쉬운 해결책으로 보인다.</p><pre>interface SomeProps {<br>  foo<strong>?</strong>: string<br>}</pre><p>좋다. 에러가 사라졌다. 모든것이 완벽하다.</p><h4>과연?</h4><p>하지만 strictNullCheck 옵션을 켠 순간, 모든것이 무너지기 시작한다. 아래와 같은 에러가 나타날 것이기 때문이다.</p><pre>class SomeComponent extends Component&lt;SomeProps&gt; {<br>  render() {<br>    return &lt;span&gt;{<strong>this.props.foo</strong>.split(&#39;_&#39;)[0]}&lt;/span&gt;<br>                             <em>foo is possibly &#39;undefined&#39;</em><br>  }<br>}</pre><p>이 에러를 처리하기 위한 두 가지 방법이 있다.</p><p>가장 쉽게 해결할 수 있는 방법은 foo가 undefined가 아닐 거라고 — 그렇게 내가 확신한다고 — 타입스크립트 컴파일러에게 알려주는 방법이다.</p><pre>&lt;span&gt;{this.props.<strong>foo!</strong>.split(&#39;_&#39;)[0]}&lt;/span&gt;</pre><p>만약, withFoo라는 HOC가 프로젝트 여기저기 위치한다면, withFoo를 사용하는 모든 컴포넌트를 찾아가 이 느낌표를 붙여주는 작업을 해야 한다. 좀 더 나은 방법을 알아보자.</p><p>문제의 핵심은, foo가 내부에서는 <strong>required</strong> props이지만, HOC를 통해 만들어진 컴포넌트는 withFoo를 통해 값이 주입되고 있기에 foo를 <strong>optional</strong> props로 여겨주길 원한다는 점이다. 그래서 HOC를 제공하는 라이브러리들은 다음과 같이 처리한다.</p><pre>interface InjectedProps {<br>  foo: string<br>}<br>function withFoo&lt;P extends InjectedProps&gt;(<br>  WrappedComponent: React.ComponentType&lt;P&gt;<br>) {<br>  class WrappingComponent extends Component&lt;P&gt; {<br>    render() {<br>      return &lt;WrappedComponent foo=&quot;foo_bar&quot; {...this.props} /&gt;<br>    }<br>  }<br>  <strong>type ExposedProps = Omit&lt;P, keyof InjectedProps&gt; &amp; Partial&lt;InjectedProps&gt;</strong><br>  return (WrappingComponent<strong> as any</strong>)<strong> as ComponentType&lt;ExposedProps&gt;</strong><br>}</pre><p>WrappedComponent의 Props 중 InjectedProps에 해당하는 항목을 지운 뒤, Partial 타입을 사용해 옵셔널한 항목으로 다시 주입하여 이 WrappingComponent의 타입이라고 눈속임 — 타입을 완전히 재정의 — 을 한다. 이 눈속임을 위해 as any as Type 같은 타입-무시가 잠시 이뤄지지만, 대체로 잘 동작한다.</p><h3>static defaultProps</h3><p><strong>(Updated) 이 문제는 Typescript 3.0이 출시되면서 해결이 되었다.</strong></p><p>역시, HOC에 의한 Props 주입과 마찬가지로, 외부와 내부의 Props 인터페이스 차이가 발생하여 생기는 문제다. 다만 차이가 있다면 HOC는 내가 짠, 혹은 남이 짠 코드 — 라이브러리 — 에 의해 벌어지는 문제이지만, defaultProps는 리액트가 직접 설정해주는 항목이라는 점이다.</p><p><em>(Deprecated) 사실 이 문제는 타입 정의의 레거시에 해당하는 — 변경시 대혼란이 예상되기 때문에 쉽게 변경하지 못하는— 문제인데, Component의 타입 정의에 defaultProps가 포함되지 않았기 때문에 생긴 문제다. 만약 defaultProps 타입 역시 컴포넌트의 타입으로 포함시키려고 한다면, ComponentClass의 제네릭 타입이 Props, State 뿐만이 아닌 DefaultProps까지 셋으로 늘어나게 된다. 이 부분을 변경하기 위해서는… 아마도 React v17.0 정도는 나와야 하지 않을까… 하는 짐작을 하고 있다.</em></p><p>defaultProps의 문제 역시 HOC와 동일하지만 다시 한번 설명하자면</p><pre>interface Props {<br>  <strong>foo</strong>: number<br>  <strong>bar</strong>: string<br>}<br>class MyComponent extends Component&lt;Props&gt; {<br>  static defaultProps = {<br>    foo: 1,<br>    bar: &#39;string&#39;<br>  }<br>  render() {...}<br>}</pre><pre>// in other render()<br>&lt;div&gt;<br>  &lt;MyComponent /&gt;                    // <strong>TS error</strong><br>  &lt;MyComponent foo={3} bar=&quot;test&quot; /&gt; // ok<br>&lt;/div&gt;</pre><p>이렇게 해도 에러</p><pre>interface Props {<br>  <strong>foo?</strong>: number<br>  <strong>bar?</strong>: string<br>}<br>class MyComponent extends Component&lt;Props&gt; {<br>  static defaultProps = {<br>    foo: 1,<br>    bar: &#39;string&#39;<br>  }<br>  render() {<br>    const { foo, bar } = this.props<br>    return (<br>      &lt;span&gt;{foo + 1} / {bar}&lt;/span&gt;<br>            <strong>&#39;foo&#39; is possibly &#39;undefined&#39;</strong><br>    )<br>  }<br>}</pre><p>저렇게 해도 에러.</p><p>결국, 개발자는 HOC와 비슷한 문제에 부딛히게 된다. 하지만 HOC는 인풋-컴포넌트와 아웃풋-컴포넌트의 타입을 다르게 정의하여 해결할 수 있었다면, 이번 문제에서는 <strong>컴포넌트가 하나 뿐</strong>이라는 점이 중요한 차이를 유발한다.</p><p>현재 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11640">일년 반째 논의가 진행중인 이슈</a>에서는 다음과 같은 해결책이 제시되었다.</p><ol><li>컴포넌트를 export할 때 타입 정의를 덮어쓰기. HOC에서 했던 것과 같은 방식이지만, HOC의 인풋-아웃풋이 아닌, 컴포넌트의 정의-Export 사이에서 이뤄지는 것이다.</li><li>static defaultProps를 사용하지 않고,<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11640#issuecomment-345447306"> HoC로 직접 defaultProps의 동작을 흉내내기.</a> HOC로는 그래도 해결할 수 있으니까, 관점을 달리 본 것이다.</li><li>혹은, <a href="https://levelup.gitconnected.com/ultimate-react-component-patterns-with-typescript-2-8-82990c516935#2321">HoC로 Props 타입과 static 값을 덮어쓰기.</a></li></ol><p>더 나은, 깔끔한 해결책을 원한다면 기다려보는 수밖에 없다. 얼마나 걸릴진 모른다.</p><h3>React.cloneElement with Props</h3><h4>안타깝지만 이 문제는 답이 없다.</h4><p>Props를 다루는 코드가 Component나 HOC가 아니라 리액트 코어 레벨에서 동작하기 때문에, 이 코드에는 앞서 논의한 문제를 회피했던 것 처럼 타입 정의를 덮어쓸만한 틈이 없다.</p><p>아래와 같은 Buttons 컴포넌트를 작성했다고 생각해보자. common이라는 props를 모든 child element에게 주입해주는 역할이다.</p><pre>class Buttons extends Component&lt;ButtonsProps&gt; {<br>  render() {<br>    const { common, children } = this.props<br>    return this.props.children.map(child =&gt; <br>      React.cloneElement(child, { common })<br>    )<br>  }<br>}<br>class Button extends Component&lt;ButtonProps&gt; {<br>  render() {<br>    const { name, <strong>common</strong> }= this.props<br>    return ...<br>  }<br>}</pre><pre>&lt;Buttons common=&quot;checkbox&quot;&gt;<br>  <strong>&lt;Button</strong> name=&quot;test&quot; /&gt;                  // <strong>error</strong>: no props common<br>  &lt;Button name=&quot;test2&quot; common=&quot;Hello&quot; /&gt;  // but run as &quot;checkbox&quot;<br>&lt;Buttons /&gt;</pre><p>이때 JSX로 선언된 &lt;Button /&gt;에서 common이라는 props가 Buttons에 의해 주입된다는 사실을 타입으로 명시하려고 아무리 노력해도 defaultProps와 같은 문제에 부딛히게 된다.</p><p>이 문제에 대해 내가 제안할 수 있는 해결책은 다음과 같다.</p><ol><li>이 모든 문제를 잊고, strictNullCheck 옵션을 끈다.</li><li>cloneElement를 사용하지 않는 방식으로 컴포넌트를 다시 작성한다.</li></ol><h3>번외: Context</h3><p>리액트의 Context는 prop-types에 절대적으로 의존하고 있기 때문에 리액트의 d.ts에서는 다루지 않고 있으며, 다룰 수 없다.</p><p>하지만 16.3의 새로운 ContextAPI 하에서는 훨씬 더 깔끔하게 Context의 타입을 처리할 수 있을 것이다. 이건 조금 더 사용해보고 다른 글에서 이야기해보도록 하자.</p><p>이상 React와 Typescript의 미묘한 불일치를 읽어주셔서 감사하다. 그렇다고 내가 타입스크립트 사용을 포기했나- 하면 그렇지는 않다. 한 프로젝트는 이 역경을 거친 후 strictNullCheck 옵션을 켜둔 채 개발하고 있으며, 다른 대형 프로젝트는 strictNullCheck 옵션을 끈 채로 개발하고 있다. 부디 이 글이 strictNullCheck에 고통받는 타입스크립트 개발자들에게 도움이 되었길.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b8f0e2bfe05d" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[자바스크립트에 타입 입히기]]></title>
            <link>https://medium.com/@FourwingsY/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90-%ED%83%80%EC%9E%85-%EC%9E%85%ED%9E%88%EA%B8%B0-9c7b7bb82b30?source=rss-68cc49c8335f------2</link>
            <guid isPermaLink="false">https://medium.com/p/9c7b7bb82b30</guid>
            <category><![CDATA[flowtype]]></category>
            <category><![CDATA[typescript]]></category>
            <dc:creator><![CDATA[HyeonSeok Yang]]></dc:creator>
            <pubDate>Sat, 10 Feb 2018 10:09:13 GMT</pubDate>
            <atom:updated>2018-02-10T17:18:59.470Z</atom:updated>
            <content:encoded><![CDATA[<p>Typescript 승</p><p>자바스크립트의 타입 없는 자유로움에서 비롯된 여러 버그들을 마주치다 보면, 정적 타입이 있는 언어들이 부러워질 때가 가끔 있다. 그런 우리 자바스크립트 개발자에겐 <a href="https://flow.org/">Flow</a>와 <a href="https://www.typescriptlang.org/">Typescript</a>가 있다. 그래서 하나씩 시도해보았다. 해보지 않고는 제대로 느끼지 못하기 때문에.</p><p>참고) 아래 내용은 러프한 회고로 되어있으므로, 도움이 되는 이야기를 원한다면 스크롤을 내려 결론 부분만 확인하길 추천.</p><h4>Flow 시도해보기</h4><p>처음엔 Flow를 시도해보았다. 타입스크립트가 ‘언어&#39;의 포지션을 취하고 있는 것도 부담스러웠고, 단순한 몇몇 표시만으로 타입 있는 언어와 비슷한 효과를 누릴 수 있다는 사실이 긍정적으로 보였다.</p><p>일단 시도를 해 봤다. (사실 지난 1년간 네번쯤 시도해봤다. 세번의 설정 실패 끝에 네 번째 도전에 돌아가는 설정을 잡은 거다..) 전체 프로젝트 중에서 재사용 가능하도록 분리된 컴포넌트 몇몇만 타입을 입혀봤다. 그럭저럭 괜찮아보였다. 조금씩 조금씩 바꾸어가며 전체 프로젝트에 Flow를 적용했다.</p><p>몇가지 문제가 보였다. 문제 아닌 문제로 파일 앞에 // @flow 를 붙이는 행위와 타입을 불러오는 import type {...} 이 귀찮았다.</p><p>두번째로, ImmutableJS와 상성이 잘 안 맞았다. ImmutableJS가 내부에 어떤 데이터가 들어있는지를 꽁꽁 싸매고 있었기 때문에, 어떤 Immutable.Map 객체에 ‘user’라는 키가 들어있는지, 없는지 타입 체크를 할 수가 없었다. 때문에 get, getIn 함수를 사용할 때에는, 항상 not set value를 설정해주어야 했다. 게다가 babel-plugin-extensible-destructing 을 사용해 immutable 객체를 일반 object처럼 destructing해서 사용하기 위해서는 꼼수가 필요했다.</p><pre>// Immutable.Map이면서도 destruct 가능한 척<br>type User = Immutable.Map &amp; {<br>  userId: number,<br>  ...,<br>}</pre><p>마지막으로 조금 느렸다. 주 사용 IDE로 웹스톰을 사용하고 있었는데, 웹스톰의 Flow는 타입 체크용 서버를 뒤에서 돌리고 있었고, 이 서버의 동작이 느린건지 코딩을 느리게 했다. 웹스톰 2017.3 버전부터였던가, 이런 부분이 개선되어서 더이상 버벅이고 코딩에 방해가 될 정도는 아니었지만, 코드의 변화를 감지하고 에러를 표시해주는 데에는 여전히 딜레이가 있었다.</p><h4>Typescript 시도해보기</h4><p>Flow의 마지막 문제가 해결된 것으로, 그냥 이쯤에서 정착해볼까 하던 차에, 친한 개발자가 타입스크립트가 꽤 괜찮다고 추천을 하기에 타입스크립트로도 시도해보기로 했다. Flow 타입을 적용했던 것과 같은 순서로, 일단 설정을 잡아두고, 파일 하나씩 // @flow를 떼어내고, .ts, .tsx 파일로 변경해보기 시작했다.</p><p>첫 인상은 괜찮았다. Flow와 타입 정의도 비슷해서 변경해야 할 지점도 많지 않았고, 동작도 비슷했다. 타입스크립트 컴파일러가 트랜스파일링을 맡을 테니, 이렇게만 진행된다면 Babel 없는 프로젝트를 해 볼수 있겠다는 생각도 들었다. 한 번 그렇게 해보자-는 생각으로 편하게 쓰던 Babel 플러그인 몇몇과 작별을 고했다.</p><p>여전히 Immutable과의 불협화음은 계속해서 났다. Flow에서 통하던 꼼수도 더이상 통하지 않던 데다가, redux를 배우고 적용하면서 Immutable이 없더라도 Immutable한 코드를 짜는 습관이 들었다고 생각했고, 타입스크립트가 타입 체크까지 해 줄텐데 내가 왜 이걸 유지하고 있지- 라는 생각이 들어 Immutable을 버렸다. 복잡한 객체의 일부분만 변경하고자 할 때 조금 아쉬울 때가 있지만, 지금도 가끔 떠오르는 아쉬움을 참으며 코딩하고 있다.</p><p>DefinitelyTyped는 축복이었다. 거의 모든 라이브러리에 대한 타입을 제공했다. <a href="https://github.com/moment/luxon">luxon</a>이 공개되고 며칠 지나지 않아 DefinitelyTyped에 luxon의 타입 정의가 올라왔다. Flow보다 훨씬 낫다고 느낀 부분이었다. 하지만 가끔, 라이브러리의 타입 정의를 들여다보며 내가 뭘 잘못 넣었나 고민하게 되는 일도 생겼다.</p><p>styled-components와 같은 라이브러리는 template literal을 아주 잘 활용하는데, 타입스크립트에서 이 template literal을 함수로 사용할 때에 대한 타입 지원이 되지 않아 타입 사용에 문제가 있을 때가 있었다. 물론 여러 사람들이 이를 극복해낼 방법을 이리저리 찾아냈고, 그런 방식을 사용하고 있긴 하지만, 타입스크립트의 직접적인 지원이 있다면 훨씬 매끄러운 해결책이 나올텐데 싶어 아쉽다.</p><p>TSlint는 감점 요인이다. ESLint에 비해 문서도 빈약하고, 옵션도 빈약하다. 게다가 unused variable을 확인하기 위해서는 타입 체크(타입 표시는 used variable로 판별되지 않기 때문에…)옵션을 켜야 하는데, 이 경우 lint가 (느낌상)20배 가량 느려진다. 때문에 이런 옵션들은 1–2주에 한번 확인하고 처리하는 방식으로 일하게 되었다.</p><p>TS로의 변환이 충분히 진행되고 다른 도구를 사용하려고 했더니 Babel Plugin이 필요해졌다. TS는 충분한 역할을 제공하고 있었지만, Babel의 플러그인 생태계는 이미 너무 컸고 피할 수 없었다. 프로젝트에 다시 Babel을 넣었다. TS 컴파일러의 역할 일부를 바벨에게 넘기면서 plugin 일부를 포함시켰다. Babel 7의 typescript preset이 잘 돌아간다고는 하던 것 같던데, 조만간 시도해볼까 한다.</p><h3>결론</h3><p>Flow나 Typescript나, 모두 Typed code를 작성하는데 충분한 도움을 제공한다. 어떤 도구를 쓰더라도, 다른 도구로 옮겨가는 데에 약간의 노가다 이외의 큰 문제는 없을 정도로 문법도 비슷하다. 타입을 사용하고 싶다면, 길게 고민하지 않고 둘 중 아무 것이든 시도해보는게 좋다.</p><ol><li>간편하게 시작하기엔 Flow가 좋지만, 라이브러리의 타입까지 다 들고와 확인하기엔 Typescript가 좋더라. 이 점에서 Typescript가 낫다고 본다.</li><li>타입을 막상 적용해보면, 잘 돌아가는 코드였지만 타입 상으로는 문제 있는 코드가 발견되기도 한다. 이런걸 확인할 때마다 타입 도입하길 잘 했다는 생각이 든다.</li><li>타입을 사용하다 보면, 결국 내가 사용하는 외부 라이브러리들의 타입 정보 역시 들여다볼 수 밖에 없다. React의 Node, Element, Component와 ComponentType의 차이를 알게 된다.</li><li>타입 정의가 제대로 되지 않아 답답함을 느끼게 된다면, 당신은 결국 해당 라이브러리의 index.js.flow 혹은 index.d.ts, 또는 DefinitelyTyped 프로젝트에 기여를 하고 있을 것이다.</li><li>가끔 코드보다 타입 선언을 어떻게 해야 할 지 더 깊은 고민을 하게 될 때가 있다. 당장은 낭비처럼 느껴질 때도 있지만, 잘 선언한 타입 하나가 많은 버그를 막는다. 맘에 드는 해답이 나올 때까지 고민해보되, 이슈도 잘 찾아보자. 아직 이슈가 열려있다면, 고민은 멈추는게 낫다.</li><li>타입스크립트를 사용하더라도, Babel은 빼놓을 수 없는 JS 개발의 핵심이 되어버린 듯 하다.</li><li>Immutable과 같은 내부 정보를 모두 감춰버리는 도구는 타입을 사용하는 코드와는 전혀 조화롭지 못하다.</li></ol><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9c7b7bb82b30" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[redux + redux-saga 로 Async 다루기]]></title>
            <link>https://medium.com/@FourwingsY/redux-redux-saga-%EB%A1%9C-async-%EB%8B%A4%EB%A3%A8%EA%B8%B0-b7b9a9110356?source=rss-68cc49c8335f------2</link>
            <guid isPermaLink="false">https://medium.com/p/b7b9a9110356</guid>
            <category><![CDATA[async]]></category>
            <category><![CDATA[redux]]></category>
            <category><![CDATA[redux-saga]]></category>
            <dc:creator><![CDATA[HyeonSeok Yang]]></dc:creator>
            <pubDate>Fri, 09 Feb 2018 08:36:38 GMT</pubDate>
            <atom:updated>2018-02-11T08:35:45.772Z</atom:updated>
            <content:encoded><![CDATA[<p>이제 아는 사람은 다 알고 쓰는 사람은 다 쓰는 그것들</p><p>Redux를 쓰기로 결정한 후 구조를 어떻게 잡을지 고민하다가, <a href="https://github.com/erikras/ducks-modular-redux">ducks</a> pattern을 보고 이 구조를 따라가기로 했다. 이 패턴의 포인트는 string으로 선언된 Action type이 알고보면 대부분 action creator와 reducer에서만 쓰일텐데, 굳이 파일을 쪼개어 import/export하는 작업을 해야 하냐는 관점이다. 실제로 connect된 컴포넌트에서도 액션 크리에이터를 사용해 액션을 생성하지, 액션의 타입을 직접 알 필요는 없다. 때문에 Ducks 패턴을 사용한 모듈들을 무척 단순하게 작성할 수 있었다.</p><p>하지만 지금은 이 패턴을 더이상 쓰고 있지 않다. 모듈 하나 하나의 크기가 꽤 커져서, 코드를 한눈에 보기 어려워졌기 때문이다. ducks 모듈은 액션, 액션 크리에이터, 리듀서, 사가로 나누어졌고, index.ts 파일에서 import/export되었다. 모듈의 크기가 커진 데에 가장 큰 이유는 async한 액션을 다루기 시작하면서 액션과 사가가 단순하지 않아졌기 때문이다.</p><p>아마도 최근에 작업한 코드라, 모든게 머릿속에 남아있어 당연한 것처럼 넘어가버린 설명이 있을 수도 있다. (이래서 글은 좀 묵혀뒀다가 써야 한다) 댓글을 남겨주시면 조금 더 친절한 설명을 하도록 노력해보겠다.</p><h4>Async Action 처리하기</h4><p>첫째로, 액션 자체가 조금 복잡해졌다. Async한 액션을 요청 보냄, 성공, 실패로 구분하기 위해서이다.</p><pre>function makeAsyncActions(actionName) {<br>  const prefix = actionName<br>  return keyMirror(prefix, {<br>    INDEX: null,<br>    REQUEST: null,<br>    SUCCESS: null,<br>    FAIL: null,<br>  })<br>}</pre><pre>export const actionTypes = {<br>  FETCH_NOTICES: makeAsyncActions(&#39;app/notices/FETCH_NOTICES&#39;),<br>  NORMAL_ACTION: &#39;app/example/NORMAL_ACTION&#39;,<br>}</pre><p>이렇게 작성해두면, 추후에 액션 타입을 지정할 때 FETCH_NOTICES.INDEX , FETCH_NOTICES.REQUEST , FETCH_NOTICES.SUCCESS , FETCH_NOTICES.FAIL 로 타입을 지정할 수 있다.</p><p>두번째로, 이런 액션을 처리하기 위한 액션 크리에이터도 조금 복잡해진다. AsyncAction의 규칙에 대응되는 액션 크리에이터를 만들기 위해서이다.</p><pre>function makeActionCreator(actionType) {<br>  return payload =&gt; ({ type: actionType, payload })<br>}</pre><pre>function <strong>makeAsyncActionCreator</strong>(actions) {<br>  let actionCreator = makeActionCreator(actions.INDEX)<br>  actionCreator.request = makeActionCreator(actions.REQUEST)<br>  actionCreator.success = makeActionCreator(actions.SUCCESS)<br>  actionCreator.fail = makeActionCreator(actions.FAIL)<br>  return actionCreator<br>}</pre><pre>export const fetchNotices = <br>  <strong>makeAsyncActionCreator</strong>(actionTypes.FETCH_NOTICES)<br>export const normalAction = <br>  makeActionCreator(actionTypes.NORMAL_ACTION)</pre><p>이렇게 만들어진 fetchNotices는 다음과 같은 코드로 실행된다.</p><pre>fetchNotices(payload)         // { type: FETCH_NOTICES.INDEX }<br>fetchNotices.request(payload) // { type: FETCH_NOTICES.REQUEST }<br>fetchNotices.success(payload) // { type: FETCH_NOTICES.SUCCESS }<br>fetchNotices.fail(payload)    // { type: FETCH_NOTICES.FAIL }</pre><p>Async한 Action의 명명 규칙을 넘어 일정한 형태로 자리잡게 되면, 조금 아래에서 설명할, 반복되는 코드를 추출하는데에 꽤 도움이 된다.</p><p>이런 액션을 처리하는 Saga를 보자. INDEX로 된 액션을 take하고, REQUEST, SUCCESS, FAIL 액션을 put하는 형태이다.</p><pre>export function* fetchNoticesSaga(action) {<br>  yield put(fetchNotices.request())<br>  try {<br>    const notices = yield call(NoticesAPI.create, action.payload)<br>    yield put(fetchNotices.success({ notices }))<br>  } catch (error) {<br>    yield put(fetchNotices.fail({ error }))<br>  }<br>}</pre><pre>export function* watcher() {<br>  yield all([<br>    takeLatest(actionTypes.FETCH_NOTICES.INDEX, fetchNoticesSaga)<br>  ])<br>}</pre><p>API 호출 패턴은 앱의 여러 부분에 걸쳐 계속 반복되었기에 apiSaga로 뽑아냈으며, 세션 에러와 같은 공통 에러를 잡아내기 위해 에러 핸들러를 더했다.</p><pre>function* apiSaga(api, asyncAction, options) {<br>  yield put(asyncAction.request())<br>  try {<br>    const payload = options &amp;&amp; options.apiPayload<br>    const result = yield call(api, payload)<br>    yield put(asyncAction.success({ result }))<br>  } catch (error) {<br>    const failAction = asyncAction.fail({ error })<br>    yield call(errorHandler, failAction)<br>    yield put(failAction)<br>  }<br>}</pre><pre>export function* fetchNoticesSaga(action) {<br>  yield call(apiSaga, NoticesAPI.getNotices, fetchNotices, {<br>    apiPayload: action.payload,<br>  })<br>}</pre><h4>Async한 액션이 발생하는 팝업</h4><p>팝업은 이후 팝업 관리에 대해 적는 글에서 자세히 다룰 예정이지만, 여기에서도 조금 같이 다뤄볼까 한다. 기존 팝업 구조는 <a href="https://medium.com/@FourwingsY/%ED%8C%9D%EC%97%85%EC%99%80-%EB%A9%94%EC%8B%9C%EC%A7%80-with-react-afd1923797d8">1년 전쯤 썼던 글</a>에서와 같이 컴포넌트에서 팝업을 지정하여 열고 있었다. 달라진 점이 있다면, openPopup 액션이 App의 컨텍스트 안에 존재해, context를 통해 어디서든 팝업을 열 수 있었다는 것.</p><pre>onClick = () =&gt; {<br>  this.context.openPopup(POPUP.POST_EDIT, { postId })<br>}</pre><p>Flux에서는 컴포넌트가 로직을 들고 있는 방식으로 코드가 구성되어 컴포넌트가 팝업을 여는 코드가 어색하지 않았지만, 리덕스와 사가를 사용하게 되면서 이런 코드는 사가에서 처리하는게 맞겠다는 생각이 들었다.</p><pre>// at Component<br>onClick = () =&gt; {<br>  this.props.openPostEditPopup({ postId })<br>}</pre><pre>// at Saga<br>function* openPostEditPopupSaga(action) {<br>  const { postId } = action.payload<br>  const popupId = POPUP.POST_EDIT<br>  yield put(openPopup({ id: popupId, props: { postId } }))<br>}</pre><p>이런 방식으로 변경하면서, 팝업에서 수행되는 어떠한 기능 — 이 경우에는 포스트 수정 요청을 보내는 — 이 성공했는지, 실패했는지, 아니면 그냥 아무것도 하지 않고 유저가 팝업을 닫아버렸는지 같은 상황을 알아야 했다. 이전에는 그러한 행동들을 열린 팝업 <em>컴포넌트</em>에서 해결했었지만, 이젠 그러한 로직들도 사가로 옮기는 것이 적절하다고 보았기 때문이다. 그러니까 이 사가는 팝업을 열고 끝나는 것이 아니라, 팝업을 열고 팝업에서 일어나는 액션을 관찰해야 한다.</p><pre>function* openPostEditPopupSaga(action) {<br>  const { postId } = action.payload<br>  const popupId = POPUP.POST_EDIT<br>  yield put(openPopup({ id: popupId, props: { postId } }))<br>  yield fork(<strong>watchAsyncActionPopupSaga</strong>, actionTypes.POST_UPDATE, popupId)<br>}</pre><p>사실 관찰이 필요한 팝업이란건, 팝업의 확인 버튼을 눌렀을 때, 내부에서 어떠한 AsyncAction이 일어나는 팝업을 말한다. 그렇지 않다면, 확인 버튼이란 것이 닫기 버튼과 별다른 차이가 없는 것이다. 다행히도 이 프로젝트에서는 하나의 팝업에서 두가지 이상의 일을 하는 팝업이 없었으므로, 아래와 같은 사가를 만들어 대응했다.</p><pre>export function* watchAsyncActionPopupSaga(asyncActionType, popupId) {<br>  // watch request action<br>  const watchAsyncAction = yield fork(<br>    watchAsyncActionSaga,<br>    asyncActionType,<br>    popupId<br>  )</pre><pre>  // if async action success or user close popup,<br>  const { success } = yield race({<br>    success: take(asyncActionType.SUCCESS),<br>    close: take(popupActionTypes.CLOSE),<br>  })</pre><pre>  // then stop watching<br>  yield cancel(watchAsyncAction)</pre><pre>  // on success, auto-close popup<br>  if (success) {<br>    yield put(closePopup({ id: popupId }))<br>  }<br>}</pre><pre>// when request start: set isLoading = true, <br>// and request end: set isLoading = false<br>function* watchAsyncActionSaga(asyncActionType, popupId) {<br>  while (true) {<br>    yield take(asyncActionType.REQUEST)<br>    yield put(updatePopup({ id: popupId, props: { isLoading: true } }))<br>    yield race({<br>      success: take(asyncActionType.SUCCESS),<br>      fail: take(asyncActionType.FAIL),<br>    })<br>    yield put(updatePopup({ id: popupId, props: { isLoading: false } }))<br>  }<br>}</pre><p>위 코드에서 설정한 isLoading 값은 팝업에서 props로 받아간 뒤, 확인 버튼에 loading indicator를 보여주느냐 마느냐를 구분하는데에 사용했다.</p><p>이렇게 Saga에 API 호출과 결과값 처리에 관련된 모든 동작과, 팝업 및 팝업에서 일어나는 일을 감지하고 변화를 일으키는 동작을 옮기고 나니 대부분의 컴포넌트가 꽤 말끔해졌다. 더이상 복잡한 로직을 담지 않고 렌더링을 하거나, 액션을 dispatch하는 일 밖에 하지 않는다. 이정도까지 바꿔놓고 나니, ‘아 이게 Redux구나’ 하는 생각이 든다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b7b9a9110356" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[최근 사용중인 기술 스택에 대하여 (intro)]]></title>
            <link>https://medium.com/@FourwingsY/%EC%B5%9C%EA%B7%BC-%EC%82%AC%EC%9A%A9%EC%A4%91%EC%9D%B8-%EA%B8%B0%EC%88%A0-%EC%8A%A4%ED%83%9D%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-intro-e7380f6ac1c3?source=rss-68cc49c8335f------2</link>
            <guid isPermaLink="false">https://medium.com/p/e7380f6ac1c3</guid>
            <category><![CDATA[react]]></category>
            <category><![CDATA[redux]]></category>
            <dc:creator><![CDATA[HyeonSeok Yang]]></dc:creator>
            <pubDate>Thu, 08 Feb 2018 06:38:16 GMT</pubDate>
            <atom:updated>2018-02-10T17:20:20.823Z</atom:updated>
            <content:encoded><![CDATA[<p>이전까지의 내 글들을 보았다면 알겠지만, 나는 이제까지 React + Flux(with flux/utils 를 사용하여 개발하고 있었다. 끊임없이 ‘아… 리덕스 공부하고 써봐야 하는데…’라고 생각은 했지만 기존의 거대한 프로젝트를 뜯어고치는 게 너무나 부담스러웠다. 그러다 2017년 7월, 기존 프로젝트의 곁다리로 나온 새로운 프로젝트를 작게 시작하게 되었고, 아 여기엔 리덕스를 꼭 적용해야겠다- 라고 생각했다.</p><p>그렇게 리덕스를 적용하던 과정에서, 신기술에 대한 욕구가 폭발하여 온갖 써보고싶었던 도구들을 다 집어넣게 되었으며, 이에 대한 이야기를 조금씩 해보려고 한다.</p><ol><li><a href="https://medium.com/@FourwingsY/b7b9a9110356">redux + redux-saga 로 Async 다루기</a></li><li><a href="https://medium.com/@FourwingsY/9c7b7bb82b30">자바스크립트에 타입 입히기</a></li></ol><p>아직 쓰지 않은 주제 목록</p><ol><li>PostCSS -&gt; styled-components</li><li>Popup과 React.Portal</li><li>react-boilerplate</li><li>Code splitting</li></ol><p>몇몇 글은 작년에 썼던 글의 리마스터드 버전이 될 것 같다.</p><p>조만간 이 목록에 모두 링크가 걸리길 바라며.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e7380f6ac1c3" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GraphQL Articles]]></title>
            <link>https://medium.com/@FourwingsY/graphql-articles-345eb427148?source=rss-68cc49c8335f------2</link>
            <guid isPermaLink="false">https://medium.com/p/345eb427148</guid>
            <category><![CDATA[graphql]]></category>
            <dc:creator><![CDATA[HyeonSeok Yang]]></dc:creator>
            <pubDate>Sat, 16 Sep 2017 05:48:45 GMT</pubDate>
            <atom:updated>2017-09-16T14:23:11.537Z</atom:updated>
            <content:encoded><![CDATA[<p>최근에 찾아 읽은 GraphQL 구현 관련된 글들을 모아봤습니다.</p><h4>GraphQL Field Guide to Auth (Jan 19, 2016)</h4><p><a href="https://medium.com/front-end-developers/graphql-field-guide-to-auth-ead84f657ab">GraphQL Field Guide to Auth</a></p><h4>Your first GraphQL component (Jan 29, 2017)</h4><p><a href="https://medium.com/front-end-developers/your-first-graphql-component-ad018e22972c">Your first GraphQL component</a></p><h4>File uploads with GraphQL and apollo (Aug 22, 2016)</h4><p><a href="https://medium.com/@danielbuechele/file-uploads-with-graphql-and-apollo-5502bbf3941e">File uploads with GraphQL and apollo</a></p><h4>Designing GraphQL Mutations (Mar 29, 2017)</h4><p><a href="https://dev-blog.apollodata.com/designing-graphql-mutations-e09de826ed97">Designing GraphQL Mutations</a></p><p>괜찮은 GraphQL 아티클을 댓글로 소개해주시면 추가하겠습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=345eb427148" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[저도 Optional Chaining 도입하려고 시도했었는데,]]></title>
            <link>https://medium.com/@FourwingsY/%EC%A0%80%EB%8F%84-optional-chaining-%EB%8F%84%EC%9E%85%ED%95%98%EB%A0%A4%EA%B3%A0-%EC%8B%9C%EB%8F%84%ED%96%88%EC%97%88%EB%8A%94%EB%8D%B0-7665e63c3450?source=rss-68cc49c8335f------2</link>
            <guid isPermaLink="false">https://medium.com/p/7665e63c3450</guid>
            <dc:creator><![CDATA[HyeonSeok Yang]]></dc:creator>
            <pubDate>Wed, 06 Sep 2017 04:30:59 GMT</pubDate>
            <atom:updated>2017-09-06T04:30:59.015Z</atom:updated>
            <content:encoded><![CDATA[<p>저도 Optional Chaining 도입하려고 시도했었는데,</p><p>아직 babel-eslint의 지원이 없어 eslint 에러가 나는 것으로 기억합니다. 혹시 어떻게 해결하셨나요?</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7665e63c3450" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GraphQL을 오해하다]]></title>
            <link>https://medium.com/@FourwingsY/graphql%EC%9D%84-%EC%98%A4%ED%95%B4%ED%95%98%EB%8B%A4-3216f404134?source=rss-68cc49c8335f------2</link>
            <guid isPermaLink="false">https://medium.com/p/3216f404134</guid>
            <category><![CDATA[dataloader]]></category>
            <category><![CDATA[graphql]]></category>
            <dc:creator><![CDATA[HyeonSeok Yang]]></dc:creator>
            <pubDate>Sun, 04 Jun 2017 07:53:40 GMT</pubDate>
            <atom:updated>2018-04-05T16:40:39.921Z</atom:updated>
            <content:encoded><![CDATA[<p>이번엔 GraphQL을 처음 접한 순간부터, 토이 프로젝트(서버)를 만드는 동안 내가 겪었던 착오와 오해, 햇갈렸던 개념들을 복습해보고자 한다. GraphQL이 대체 뭔가 하는 질문에 대해서는 <a href="https://medium.freecodecamp.com/so-whats-this-graphql-thing-i-keep-hearing-about-baf4d36c20cf">다른 글</a>을 보길 바란다. GraphQL을 전혀 모르는 상태에서 이 글을 본 다면 큰 도움이 되진 않을 것 같다.</p><h3>Specification</h3><h4>GraphQL은 라이브러리다?</h4><p>GraphQL이 무엇인지 알게 되는데에도 한참이 걸렸다. 나의 첫 오해는 GraphQL이 무언가 기능을 하는 라이브러리 같은 도구일 것이라는 착각이었다. 알고보니 GraphQL은 REST같은 API 디자인에 관한 새로운 관점의 스펙이었다. 어떤 언어를 사용하건 GraphQL의 구현체 — 마치 Flux에 여러가지 구현체가 존재하듯 — 를 사용하여 GraphQL 스펙에 맞는 코드를 짜야 한다. 가장 기본적으로 사용할 수 있는 구현체로는 Reference Implementation이라는 <a href="https://github.com/graphql/graphql-js">graphql-js</a> 가 있었다. 하나의 언어(특히 자바스크립트)에 여러 가지 구현체가 존재하기도 한다. 찾아보니 꽤 많은 언어에 GraphQL 구현체가 이미 존재했다.</p><h4>기존 엔드포인트에 GraphQL을 적용할 수 있다?</h4><p>기존 REST로 구현된 API는 GET /contents, POST /contents, DELETE /contents/:contentsId, GET /posts, DELETE /posts/:postId 같은 방식으로 개발되어 있었고, 이 구조를 비슷하게 유지하면서도 GraphQL로 바꿀 수 있을 거라고 생각했다. 물론 그렇게 하는 것이 불가능한 것은 아니다. 하지만 GraphQL은 <strong>단일 엔드포인트를 권장</strong>하고 있었다. 모든 요청을 /graphql 한 곳에서 처리하는 것이다. REST가 URL과 Resource를 매칭시키는 개념적 모델을 사용했기 때문에 수많은 엔드포인트를 사용했다면, GraphQL의 개념적 모델은 모든 리소스가 그래프처럼 서로 연결되어있기 때문에 URL을 분리할 필요가 없다. 서버는 리소스를 가져오는 명령어(Query), 혹은 어떤 리소스를 변경하기 위한 명령어(Mutation)만 제공하면 된다. GraphQL에서 필요로 하는 엔드포인트는 Query Language 입력을 받기 위한 하나의 창구로 충분하다. <strong>GraphQL의 핵심은, 리소스를 url이 아니라 Query를 통해 표현하는 것이다.</strong></p><p>그렇다면 다른 관점에서, 기존에 사용하던 REST와 GraphQL을 같이 사용할 수는 없을까? 아주 간단하다. 기존 REST API는 그대로 놔두고, /graphql 엔드포인트만 새로 만들면 된다.</p><h3>Implementation</h3><h4>GraphQL은 MySQL과 어울리지 않는다?</h4><p>GraphQL에서는 MySQL과 같은 DB에서 성능의 중요한 키가 되는 JOIN명령어를 거의 사용하지 않기 때문에 성능상의 이득을 얻을 수 없을 것이고, 때문에 RDB와 GraphQL은 어울리지 않을거라고 예상했었다. 차라리 MongoDB같은 NoSQL DB가 GraphQL과 더 어울리는게 아닐까?</p><p>사실 GraphQL과 RDB의 관계는 나쁘지 않다. DB에서의 테이블과 같은 표현이 결국 GraphQL의 엔티티로 그대로 매칭될 수 있기 때문이다.</p><p>GraphQL의 장점은 클라이언트의 요청에 따라 데이터를 더 가져오거나 가져오지 않거나가 결정된다는 점이다. 서버 개발자가 결정하는 것은 엔티티 사이의 관계, 그리고 그 관계에 따라 데이터를 어떻게 가져올 지 뿐이다(같은 댓글 목록을 가져오더라도, post.comments와 user.comments, comments.comments일 때를 각각 구현한다). 만약 REST API에서 같은 리소스를 표현하면서도 성능상의 문제로 JOIN을 많이 하는 API와 덜 하는 API를 나눠서 구현했었다면, GraphQL을 사용한 경우 이런 고민을 서버에서는 더이상 하지 않게 된다. 클라이언트가 각자 자신의 상황에 맞게 (데스크톱/모바일 등) 적절한 Depth로 요청을 끊어서 처리할 수 있게 되었기 때문이다.</p><p>성능에 대한 고려가 깊어질 정도의 요청은 GraphQL로 따지자면 요청하는 데이터의 Depth가 깊다는 것이 될 것이다. 이러한 요청을 피하기 위해서 대개 쿼리의 maxDepth를 설정하여 요청을 제한하는 방식을 주로 구현하여 적용하는 듯 하다.</p><p>또한, 각각의 클라이언트에서 자신이 원하는 정도까지의 Depth를 요청하고, 이 요청에 따라 서버의 처리가 달라지는 유연한 구조를 가지고 있기 때문에, Recursive한 구조의 데이터를 다루기가 매우 쉬워진다. (ex. 이 글을 쓴 작가의 최근 포스트리스트 컴포넌트에서 보여줄 작가 정보: post.auther.posts[0].author.name이라던가) 이와 관련해서는 아래 DataLoader에서 조금 더 다루고 있다.</p><p>물론, GraphQL을 사용하면서도 JOIN을 사용하고자 하는 여러 사람들이 있었고, 여기에 대한 해결책으로 <a href="https://github.com/stems/join-monster">join-monster</a> 와 같은 라이브러리가 등장하기 시작했다. 이에 대해서는 아직 제대로 찾아보진 못했지만, 비슷한 고민을 했다면 한 번 들여다보기 바란다.</p><p>첨언하자면, GraphQL의 설계에는 서로 다른 종류/위치의 데이터 소스에 접근해야 하는 경우에 대한 고민도 들어있다. MySQL, MongoDB, redis를 동시에 사용하는 경우에도 GraphQL은 요청에 따라 필요한 데이터 소스에만 접근하도록 동작한다.</p><h4>Schema를 정의하는 두 가지 방법</h4><p>GraphQL 사이트를 보면, schema 정의, 혹은 타입 정의 같은 것들이 나온다.</p><pre>type Character {<br>  name: String!<br>  appearsIn: [Episode]!<br>}</pre><pre>type Query {<br>  hero(episode: Episode): Character<br>  droid(id: ID!): Droid<br>}</pre><p>GraphQL이 단순한 스펙에서 벗어나 API 서버의 인터페이스로 동작하기 위해서는 이러한 타입 정의 뿐만이 아니라, 이러한 타입의 데이터를 어떻게 가져올 지가 동시에 정의되어야 한다. 때문에 graphql-js에서는 다음과 같은 방식으로 스키마를 정의한다.</p><pre>var schema = new GraphQLSchema({<br>  query: new GraphQLObjectType({<br>    name: &#39;Character&#39;,<br>    fields: {<br>      name: {<br>        type: GraphQLString,<br>        resolve() {<br>          return &#39;name&#39;;<br>        }<br>      },<br>      appearsIn: {<br>        type: GraphQLList(Episode),<br>        resolve() {<br>          return [];<br>        }<br>      }<br>    }<br>  })<br>})</pre><p>GraphQL의 원형 스펙과는 많은 부분 달라 보이지만, 각 필드에 대한 정보를 한 눈에 볼 수 있고, 어떤 언어로 표현하더라도 일정한 형태를 보일 수 있다. graphql-js가 레퍼런스 코드이기 때문인지, 대다수 타 언어 GraphQL 라이브러리들이 이런 형식으로 구현되어 있다.</p><p><a href="http://dev.apollodata.com/tools/graphql-tools/generate-schema.html">graphql-tools</a>는 기존의 깔끔한 타입 선언을 포기하지 않고 코딩할 수 있도록 도와준다.</p><pre>// define type by raw string<br>const Comment = `<br>  type Comment {<br>    id: Int!<br>    message: String<br>    author: String<br>  }<br>`;</pre><pre>// Somehow get data from DB<br>const CommentResolver = () =&gt; { }</pre><pre>export const schema = makeExecutableSchema({<br>  Comment,<br>  CommentResolver,<br>});</pre><p>개인적으로는 GraphQL의 원본 스키마가 살아있는 나중에 소개한 방식을 더 선호한다.</p><h4>DataLoader의 역할</h4><p><a href="https://github.com/facebook/dataloader">DataLoader</a>는 GraphQL을 사용하다 보면 일어나기 쉬운 1+N 문제를 1+1으로 변환시켜주는 자바스크립트 라이브러리다. 자바스크립트에서 이벤트 루프가 돌아가는 한 사이클동안 들어온 id 기반 요청을 모아 배치로 처리한 후 값을 되돌려주는 방식으로 문제를 해결한다. GraphQL의 성능을 위해서는 필수적으로 사용해야 하는 라이브러리이다.</p><p>캐싱 기능 역시 내장하고 있지만, 이에 대한 설명을 제대로 읽지 않으면 오해하기가 쉬운데, 여기서의 캐싱은 <a href="https://github.com/facebook/dataloader#caching-per-request"><strong>하나의 클라이언트 요청이 처리되는 동안</strong></a> 일어나는 여러번의 DB 요청 사이의 중복을 줄이는 방식의 캐싱이다. 그러니까, 깊이가 깊은 리소스의 Graph를 요청한 경우, 동일한 노드를 여러번 참조하게 될 수도 있다. 예를 들자면 포스트 — 코멘트 — 유저 — 포스트 — 코멘트 — 유저 와 같은 recursive한 6depth짜리 요청이 들어온 경우, 세 번째 depth의 유저 노드들과 여섯 번째 depth의 유저 노드들 사이에 중복이 있을 가능성이 농후하다. 이런 경우, 단일 요청이 처리되는 동안만 캐싱을 하여 Node의 중복 방문에 대한 캐싱 기능을 한다. DataLoader의 <a href="https://github.com/facebook/dataloader">Readme.md</a> 에서도 Redis나 Memcache와는 전혀 다른 용도라는 점을 강조하고 있다.</p><p>물론, 이 정도로 깊은 요청이 필요하다는 것 부터가 좋은 설계가 아니다.</p><h3>Mutation</h3><p>GraphQL의 mutation은 REST의 GET이 아닌 모든 변화를 일으키는 요청을 포함한다. Mutation을 구현할 때엔 두 가지 어려움을 겪었었다.</p><h4>input type !== (output) type</h4><p>만약 새로운 게시물을 등록한다고 하면, 이 포스트를 등록하기 위해서는 저자가 누구인지, 어떤 게시판에 올리는 지와 같은 정보를 함께 전달해야 한다. 하지만 이때의 정보는 저자에 대한 모든 정보가 아닌 저자의 id만 전달해도 충분하다. 쿼리(GET)할 때 사용되는 포스트라는 타입에서 저자 노드에 대한 엣지가 존재하는 것과 비교하면 같은 Post여도 같은 타입이 아니란 걸 알 수 있다. 따라서 GraphQL에는 input 타입이 별도로 존재하며, input 타입을 output으로 사용할 수 없도록 제약이 걸려 있다.</p><h4>Content-Type: “application/graphql” ?</h4><p>GraphQL은 기본적으로 Content-Type: “application/json” 을 사용한다. <a href="http://graphql.org/learn/serving-over-http/#post-request">문서</a>에 의하면 Content-Type: “application/graphql” 역시 사용 가능하다. 하지만 두 요청 사이에는 큰 차이점이 있다는 점을 미처 읽지 못하고 사용했다가 낭패를 본 경험이 있다.</p><p>Content-Type: “application/json” 의 경우, request body는 다음 형식을 따라야 한다.</p><pre>{<br>  &quot;query&quot;: &quot;...&quot;,<br>  &quot;operationName&quot;: &quot;...&quot;,<br>  &quot;variables&quot;: { &quot;myVariable&quot;: &quot;someValue&quot;, ... }<br>}</pre><p>Content-Type: “application/graphql” 은, Mutation이 아닌 Query 요청을 위한 축약형 body를 사용할 수 있게 해 준다. application/json을 사용했다면, query 필드 내부에 존재했어야 할 텍스트를 그대로 사용하는 셈이다.</p><pre>{<br>  human(id: &quot;1000&quot;) {<br>    name<br>    height(unit: FOOT)<br>  }<br>}</pre><p>이 차이점 때문에, 대부분의 (variables를 사용하게 되는) Mutation 요청에서 Content-Type: “application/graphql” 을 사용하는 것은 귀찮은 일이 된다. variable을 사용하면 GraphQL이 할 일을, 직접 string template을 사용하여 mutation query를 만들어내야 하기 때문이다. 때문에 많은 개발자들이 요청에 따라 각각 Content-Type을 설정하는 작업을 하기 보다는, Content-Type을 application/json으로 통일하여 사용하게 될 것이라고 생각한다.</p><p>이상으로, GraphQL을 사용하면서 겪었던 수많은 문제들 중 인상깊게 기억에 남은 몇몇 단편적인 기억들을 정리하는 것을 마친다. 사실은, GraphQL에 대한 소개글을 적고 싶었으나, <em>아 이런 이야기도 하고 싶은데, 흐름을 해치는 것 같아</em> 라는 생각때문에 자꾸만 글이 막혔었다. 이제 그런 잡생각들을 모두 쏟아냈으니, GraphQL을 소개하는 글을 다시 적을 수 있을까 싶으면서도, 글 서두에 링크로 걸어둔 글이 너무 잘 되어있어 굳이 내가 더 부족한 글을 생산해내는 것이 의미가 있을까 하는 고민도 든다.</p><p>이 글이 GraphQL을 이제 막 써보고 있는 사람들에게 도움이 되었으면 좋겠다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3216f404134" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Do we need Redux? (Part 2)]]></title>
            <link>https://medium.com/@FourwingsY/do-we-need-redux-part-2-c9227e5b315f?source=rss-68cc49c8335f------2</link>
            <guid isPermaLink="false">https://medium.com/p/c9227e5b315f</guid>
            <category><![CDATA[react]]></category>
            <category><![CDATA[flux]]></category>
            <category><![CDATA[redux]]></category>
            <dc:creator><![CDATA[HyeonSeok Yang]]></dc:creator>
            <pubDate>Fri, 28 Apr 2017 13:31:50 GMT</pubDate>
            <atom:updated>2017-04-28T13:31:50.410Z</atom:updated>
            <content:encoded><![CDATA[<p><a href="https://medium.com/@FourwingsY/do-we-need-redux-ebabf8d2740e">Part 1</a>에서는 Flux에서 Redux로 갈 때의 장점이 무엇인지, 어떤 방식으로 동작하기에 그런 장점을 얻는지에 대해 알아보았다. 이번 글은 Flux의 구조를 유지하면서도 큰 변화 없이 Redux의 장점-주로 테스트 가능성-을 얻어오기 위한 코드의 변화에 대해 서술하려고 한다.</p><blockquote>좋다. 현재 코드의 기능을 건드리지 않으면서, 코드 구조만 조금씩 건드리는 방식으로 리덕스의 함수형 구조로 적당히 옮겨가 그 장점 중 일부를 얻어낼 수 있을 것 같다.</blockquote><blockquote>- Part 1 마무리 부분</blockquote><p>아차, 이제 전/후 코드를 비교할텐데, 그 사이에 뜯어고친게 한둘이 아니라 직전/직후 코드를 가져오는 데에 어려움이 있었다. 바뀐 변수명이나 데이터 구조는 잠시 넘어가주시고, Container, Store, Actions가 어떻게 연결되었는지에 더 관심을 가지고 살펴봐주시면 감사하겠다.</p><h3>Store</h3><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/2a1927cf46f875c8ed1de2f633cbce98/href">https://medium.com/media/2a1927cf46f875c8ed1de2f633cbce98/href</a></iframe><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/afee4ea3a5670ae5130bfebb223e479f/href">https://medium.com/media/afee4ea3a5670ae5130bfebb223e479f/href</a></iframe><p>변경 후, 여전히 flux-utils의 Dispatcher와 ReduceStore를 사용하고 있지만, 그 내부의 로직이 단순하게 밖으로 옮겨졌다. 만약 지금의 코드를 Redux 기반으로 옮겨가려고 한다면 마지막 몇 줄만 고치면 될 정도이다.</p><p>한편, reducer가 분리되어 reducer를 테스트할 수 있게 되었다. 기존 코드에서는 스토어 로직을 테스트하려면 Action을 만들고 Dispatcher에 태워 스토어가 어떻게 변경되었는지 확인했어야 했다면, 이젠 리듀서만 테스트하면 된다.</p><p>이제서야 Dan Abramov 아저씨가 2015년 Redux에 대해 발표했던 <a href="https://www.youtube.com/watch?v=xsSnOQynTHs">이 영상</a>과 비슷한 형태를 갖춰가기 시작했다.</p><h3>Container</h3><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/cb63f41bb988891362f3b6d87f737fa2/href">https://medium.com/media/cb63f41bb988891362f3b6d87f737fa2/href</a></iframe><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9b7d1da3daac32afd264080dccea5dce/href">https://medium.com/media/9b7d1da3daac32afd264080dccea5dce/href</a></iframe><p>Container 테스트의 가장 큰 걸림돌이었던 getStores와 calculateState 함수를 컨테이너 바깥으로 걷어냈다. 덕분에 스토어에 연결되지 않은 컨테이너 컴포넌트만을 테스트 시에 뽑아, 테스트를 진행할 수 있게 되었다. 동작할 땐 컨테이너이지만, 테스트할 때엔 Presentational component가 되는 셈이다.</p><p>여기에서 중요한 부분은 스토어와 액션의 의존성을 제거한 inject함수인데, 형태를 만들어내는 데에 <a href="https://github.com/reactjs/react-redux">React-redux</a>의 아이디어를 많이 참고했다. 이 코드를 보자.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/1ab03aec505422d3c8a239ff92b2cc64/href">https://medium.com/media/1ab03aec505422d3c8a239ff92b2cc64/href</a></iframe><p>이 코드는 결국 Flux 위에서 react-redux를 흉내내기 위한 코드로, 결국 Flux Container 코드에 기반하고 있다. 만약 Redux로 완전히 넘어가게 된다면, 이 함수 대신 react-redux의 connect함수로 갈아탈 수 있을 것이다.</p><h3>Actions</h3><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/896209dc439df38126722698b8350a62/href">https://medium.com/media/896209dc439df38126722698b8350a62/href</a></iframe><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/7ce9b6c2799fcfd56f2d38189ea32437/href">https://medium.com/media/7ce9b6c2799fcfd56f2d38189ea32437/href</a></iframe><p>Ajax와 dispatch를 분리해서 구현하겠다는 생각으로 API와 Actions를 구분했다. async/await의 도움으로 코드가 더 깔끔해지기도 했다. redux-saga의 방식처럼 await/async를 generator/yield 패턴으로 바꾸고 나면 액션 자체도 더 편하게 테스트를 할 수 있을 거라고 알고 있지만, 아직 코드 내에 generator를 사용한 부분이 없어 쉽게 도입하지는 못하고 있다. 어쩌면 다른 코드가 전부 Redux 베이스로 변경된 이후에 Saga를 도입하는 것이 더 빠를 수 있겠다는 생각도 든다.</p><h4>마무리</h4><p>코드가 많고 정작 별 내용은 없지만, 아직도 나처럼 flux를 사용하고 있는 사람이나 팀이 있다면(없겠지만) 좋은 참고가 될 수 있을 거라고 생각한다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c9227e5b315f" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[webpack + PostCSS 설정하기]]></title>
            <link>https://medium.com/@FourwingsY/webpack-postcss-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0-34f9c486093a?source=rss-68cc49c8335f------2</link>
            <guid isPermaLink="false">https://medium.com/p/34f9c486093a</guid>
            <category><![CDATA[webpack]]></category>
            <category><![CDATA[postcss]]></category>
            <dc:creator><![CDATA[HyeonSeok Yang]]></dc:creator>
            <pubDate>Sun, 09 Apr 2017 06:51:30 GMT</pubDate>
            <atom:updated>2017-10-30T07:37:31.918Z</atom:updated>
            <content:encoded><![CDATA[<p>PostCSS에 대한 소개는 <a href="https://medium.com/@FourwingsY/postcss-%EC%86%8C%EA%B0%9C-727310aa6505">앞선 글</a>에서 진행했으니, 이제 설정 방법을 알아보자.</p><h4>설치</h4><pre>npm install postcss poscss-loader --save-dev</pre><h4>웹팩 설정</h4><pre>module: {<br> rules: [<br>  {<br>   test: /\.p?css$/, // 순수한 CSS 파일과 구분하고 싶다면 pcss를 사용해도 좋다. 대개 그냥 .css 확장자를 사용한다.<br>   use: [<br>    {loader: &quot;style-loader&quot;},<br>    {loader: &quot;css-loader&quot;, options: {sourceMaps: <strong>true</strong>}},<br>    {loader: &quot;postcss-loader&quot;}<br>   ],<br>  }<br> ]<br>},</pre><h4>PostCSS 설정</h4><p>프로젝트 root에 postcss.config.js 파일을 만든다.</p><pre>module.exports = (ctx) =&gt; ({<br> parser: &#39;postcss-scss&#39;, // 파서 옵션을 설정하고 싶다면 여기에서<br> plugins: [<br>  require(&#39;postcss-import&#39;)({<br>    path: [&#39;app/assets/&#39;]<br>  }),<br>  ... // 사용하고자 하는 플러그인들을 하나씩 적어넣는다.<br> ]<br>})</pre><p>혹은 Object 형식을 사용할 수도 있다.</p><pre>module.exports = (ctx) =&gt; ({<br> plugins: {<br>  &#39;postcss-import&#39;: {<br>    path: [&#39;app/assets/&#39;]<br>  },<br>  ... // 사용하고자 하는 플러그인들을 하나씩 적어넣는다.<br> ]<br>})</pre><p>PostCSS의 유일한 단점이 여기에서 드러나는데, 플러그인들을 하나씩 끼워서 설정해야 하기 때문에, 플러그인의 적용 순서가 매우 중요하다. 만약 순서를 잘못 설정했다면, 일부 기능이 동작하지 않을 수도 있다. 대부분의 경우 Readme.md에 <em>이런 플러그인들 뒤에 설정하세요</em> 라고 설명하고 있으니 이 점만 주의하자.</p><p>자세한 설정 방법은 <a href="https://github.com/michael-ciniawsky/postcss-load-config">postcss-load-config</a> 에 나와있으니, 여기를 참고하자.</p><h4>Entry point 설정</h4><p>CSS 파일들이 따로 분리되어있다면, JS의 entry point(index.js나 app.js 같은 파일을 사용하고 있을 것이다)에 import &#39;/somewhere/index.css&#39; 로 웹팩이 같이 빌드할 수 있도록 안내해주자. 만약 컴포넌트별로 CSS를 따로 관리하고 있다면, 해당 컴포넌트에 import &#39;./thisComponent.css&#39; 를 설정해주면 JS 번들링 시에 함께 CSS번들링이 진행된다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=34f9c486093a" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[PostCSS 소개]]></title>
            <link>https://medium.com/@FourwingsY/postcss-%EC%86%8C%EA%B0%9C-727310aa6505?source=rss-68cc49c8335f------2</link>
            <guid isPermaLink="false">https://medium.com/p/727310aa6505</guid>
            <category><![CDATA[postcss]]></category>
            <dc:creator><![CDATA[HyeonSeok Yang]]></dc:creator>
            <pubDate>Sat, 08 Apr 2017 14:19:56 GMT</pubDate>
            <atom:updated>2017-09-12T07:58:53.896Z</atom:updated>
            <content:encoded><![CDATA[<p>JS로 Transcompile되는 CoffeeScript나 TypeScript같이, CSS를 편하게 작성하기 위한 새로운 문법 역시 지속적으로 제시되어왔다. Sass가 있었고, less, stylus도 있다. 그중 가장 최근에 등장한 PostCSS를 알아보자.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/400/1*7q30vXddVe0jTgNCrV-gSw.png" /><figcaption>누군가는 (해리포터와) 죽음의 성물을 누군가는 일루미나티를 떠올렸다는 PostCSS 로고</figcaption></figure><h4>PostCSS란 무엇인가</h4><blockquote>PostCSS는 JS 플러그인을 사용하여 CSS를 변환시키는 툴입니다. 이런 플러그인을 사용하여 lint, 변수, mixin을 사용하거나, 인라인 이미지 또는 미래의 CSS 문법을 사용할 수 있습니다. (<a href="https://github.com/postcss/postcss">링크</a>)</blockquote><p>이 문장을 주의깊게 살펴봐야 한다. <em>PostCSS를 사용하여</em>가 아니라 <strong>플러그인을 사용하여</strong>라고 표현했다. 다시 한 번 위키피디아를 들여다보자.</p><blockquote>PostCSS는 자바스크립트 기반의 플러그인을 사용하여 CSS 기능을 자동화하는 <strong>소프트웨어 개발 도구</strong>입니다. (<a href="https://en.wikipedia.org/wiki/PostCSS">링크</a>)</blockquote><p>Sass나 less는 “CSS로 변환되는 <strong>스타일 시트 언어”</strong>라고 표현하는 것과 확연한 차이점이 있다.</p><p>그렇다. PostCSS는 언어가 아니다. 도구일 뿐이다.</p><p>비유하자면, CSS 전용 Gulp라고 하겠다. 아니, Babel에 더 가까울지도?</p><h4>PostCSS로 무엇을 할 수 있는가?</h4><p>질문이 잘못되었다. PostCSS <strong>플러그인으로</strong> 무엇을 할 수 있는가? 라고 질문해야 옳다. PostCSS 자체는 아무 일도 하지 않는다. 다만 다양한 플러그인과, 플러그인을 추가할 수 있는 환경을 제공할 뿐이다. 그러니까 PostCSS로 무엇을 할 수 있는지 알고 싶다면, 질문을 다음과 같이 바꿔보자.</p><h4>PostCSS 플러그인에는 어떤 것들이 있는가?</h4><p><a href="https://github.com/postcss/postcss/blob/master/docs/plugins.md">PostCSS 플러그인 리스트</a>에는 270여개에 달하는 플러그인들이 소개되어있다. 이 중 내가 사용중인 몇몇 플러그인을 소개해보자면-</p><ul><li><a href="https://github.com/postcss/autoprefixer">autoprefixer</a> -webkit- 등의 prefix 없이 스타일을 지정할 수 있게 도와준다.</li></ul><pre>a {<br>    display: flex;<br>}</pre><pre>/* result */<br>a {<br>    display: -webkit-box;<br>    display: -webkit-flex;<br>    display: -ms-flexbox;<br>    display: flex<br>}</pre><ul><li><a href="https://github.com/postcss/postcss-color-function">postcss-color-function</a> <a href="https://drafts.csswg.org/css-color/#modifying-colors">(참고)</a> color modifier를 사용할 수 있게 해준다.</li></ul><pre>a {<br>  color: color(red lightness(+10%));<br>}</pre><pre>/* result */<br>a {<br>  color: rgb(255, 51, 51);<br>}</pre><ul><li><a href="https://github.com/postcss/postcss-custom-properties">postcss-custom-properties</a> (<a href="https://www.w3.org/TR/css-variables/">참고</a>) CSS에서 변수를 사용할 수 있게 해 준다.</li><li>Sass 형식의 변수 선언을 원한다면, <a href="https://github.com/postcss/postcss-simple-vars">postcss-simple-vars</a> 를 사용하자.</li></ul><pre>:root {<br>  --color: red;<br>}<br><br>div {<br>  color: var(--color);<br>}</pre><pre>/* result */<br>div {<br>  color: red;<br>}</pre><ul><li>postcss-apply (<a href="http://tabatkins.github.io/specs/css-apply-rule/">참고</a>) postcss-custom-properties의 확장, deprecated 될 예정이다.</li></ul><pre>:root {<br>  --link: {<br>    color: pink;<br>    text-decoration: underline;<br>    cursor: pointer;<br>  }<br>}</pre><pre>a.move {<br>  @apply --link;<br>}</pre><pre>/* result */<br>a.move {<br>  color: pink;<br>  text-decoration: underline;<br>  cursor: pointer;<br>}</pre><ul><li><a href="https://github.com/postcss/postcss-import">postcss-import</a> (<a href="https://www.w3.org/TR/CSS22/cascade.html#at-import">참고</a>) CSS @import 룰을 사용할 수 있게 해 준다.</li></ul><pre>/* foo.css */<br>.foo {<br>  width: 100px;<br>}<br>/* bar.css */<br>.bar {<br>  height: 20px;<br>}</pre><pre>/* index.css */<br>@import &quot;foo.css&quot;;<br>@import &quot;bar.css&quot;;</pre><pre>/* result of index.css */<br>.foo {<br>  width: 100px;<br>}<br>.bar {<br>  height: 20px;<br>}</pre><ul><li><a href="https://github.com/jonathantneal/postcss-nesting">postcss-nesting</a> (<a href="http://tabatkins.github.io/specs/css-nesting/">참고</a>) nesting 문법을 사용할 수 있게 해 준다.</li></ul><pre>a, b {<br>  color: red;<br>  &amp; c, &amp; d {<br>    color: white;<br>  }<br>  &amp;:hover {<br>    color: black;<br>  }<br>  @nest div &gt; &amp; {<br>    color: blue;<br>  }<br>}</pre><pre>/* result */<br>a, b {<br>  color: red;<br>}<br>a c, a d, b c, b d {<br>  color: white;<br>}<br>a:hover, b:hover {<br>  color: black;<br>}<br>div &gt; a, div &gt; b {<br>  color: blue;<br>}</pre><ul><li><a href="https://github.com/antyakushev/postcss-for">postcss-for</a> CSS 내에서 for 문을 사용할 수 있게 해 준다.</li></ul><pre>@for $i from 1 to 3 {<br>    .icon-$(i) { background-position: 0 calc($(i) * 20px); }<br>}</pre><pre>/* result */<br>.icon-1 { background-position: 0 calc(1 * 20px); }<br>.icon-2 { background-position: 0 calc(2 * 20px); }<br>.icon-3 { background-position: 0 calc(3 * 20px); }</pre><ul><li><a href="https://github.com/borodean/postcss-assets">postcss-assets</a> url() 내에 들어가는 파일의 경로를 편리하게 작성하거나, 이미지의 사이즈를 측정하고 가져올 수 있게 도와준다.</li></ul><pre>/* with loadPath settings */<br>body {<br>  background: resolve(&#39;bg.png&#39;);<br>}<br>.warn {<br>  width: width(&#39;warn.png&#39;); /* calculate image size */<br>  background: resolve(&#39;warn.png&#39;);<br>}</pre><pre>/* result */<br>body {<br>  background: url(&#39;/images/bg.png&#39;);<br>}<br>.warn {<br>  width: 320px;<br>  background: url(&#39;/images/template/warn.png&#39;);<br>}</pre><p>이 외에도 Grid 레이아웃을 을 쉽게 작성하거나, 편리한 문법을 제공하거나, 웹사이트에 <a href="https://github.com/juanfran/postcss-trolling">트롤</a>짓을 할 수도 있다.</p><p>그러니까, CSS 문법을 (브라우저에서 동작 가능한 CSS로 변환시킬 수 있는 범위 내에서) 입맛에 맞게 확장시킬 수 있다. 당신이 원하는 만큼!</p><p>하지만 경험적으로 볼 때, PostCSS 및 플러그인 개발자들의 공통된 마인드는 <strong>앞으로 표준이 될 CSS 문법을 확장/지원하는 CSS계의 Babel</strong>의 역할을 하고자 한다는 느낌이 들었다. 때문에 Sass같은 문법의 변형을 지원하는 플러그인도 적고, standard가 될 가능성이 사라진 기능이라면 플러그인이 deprecated되기도 한다.</p><h4>지금 쓰는 Sass나 less에서 옮겨가기 힘들 것 같아요</h4><p>그 문법 그대로 사용하면서 PostCSS 플러그인을 추가해 쓸 수도 있다. PostCSS의 파서 옵션에서 해당 문법의 파서를 사용하면 된다. 안타깝게도 stylus 파서는 없지만, 비슷한 문법을 제공하는 <a href="https://github.com/postcss/sugarss">SugarSS</a> 파서가 있다.</p><h4>설정이 복잡할 것 같아요</h4><p>특정 의도를 가지고 플러그인들을 모아둔 플러그인들이 있다. <a href="http://cssnext.io/">cssnext</a>는 (간단하게 말하자면) babel-esnext같은 플러그인이고, <a href="https://github.com/jonathantneal/precss">PreCSS</a>는 Sass-like 마크업을 지원하기 위한 플러그인 모음이다.</p><h4>아직 뭐가 뭔지 모르겠어요</h4><p><a href="http://cssnext.io/playground/">cssnext playground</a>에서 좌우 문법을 비교해보자. 어떤 일들이 가능한 지에 대한 느낌이 올 것이다. 더 많은 플러그인들이 존재한다는 사실을 잊지 말자.</p><h4>그래서 어떻게 설치하는거죠</h4><p>그건 <a href="https://medium.com/@FourwingsY/webpack-postcss-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0-34f9c486093a">여기</a>에.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=727310aa6505" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>