<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[yangroro]]></title><description><![CDATA[Developer who ❤️ to create]]></description><link>https://heechan.me</link><generator>RSS for Node</generator><lastBuildDate>Sun, 27 May 2018 05:50:08 GMT</lastBuildDate><item><title><![CDATA[Docker Compose로 멀티 컨테이너 Docker 어플리케이션 만들기]]></title><description><![CDATA[Docker 어플리케이션을 Docker Compose로 정의해 파일로 관리할 수 있게 하고 손쉽게 멀티 컨테이너 어플리케이션으로 만들어보자]]></description><link>https://heechan.me/posts/how-to-use-docker-compose/</link><guid isPermaLink="false">https://heechan.me/posts/how-to-use-docker-compose/</guid><pubDate>Sun, 27 May 2018 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/docker-compose-24ae150e7b2b17a62701bda7ca132c75-0011e.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 960px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 40%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsSAAALEgHS3X78AAABWklEQVQY03VQy07CUBDttxoXbnSja1cuNNEYXYASoyiKIaUW0rRQpC0CBS2ktbxKKCgv5Sk1SlEstF4BE23CycmduZk5MzkDGf+h6/p4rIOkWn+KcCkEp3xMzJgDyKQEAEmv2zly064AT7DZY5jESWpanSueLaxUF07otTPSfyPQQplKlq4T8vrm/rs6AFVt/NM1Gs/GQEkxTYbCQjpHReM0G4/fJZZ2nVesSLN8IMJTtxmrE7fY7FJLYWpKsNzFim2s2PI/dELVHiQ/lnMFWZJLmXyBE8QX5VWSCpqmVeoNMsqjgdiOxb5ygG4g4Xy90R/pJUWtvX0APvc/IZON4fDL5SWT91kEIy+JGKCXCC7uuZYtHqXdNDmH9F8AO+CvqgMHjNkcsNtLbFsvEA++az0lfMGUmJrcBIgNEKeE/p4avI1mm4lynJg/PEexYGQV5bdgRlVVY9JtwjeYqqQPMfmk9AAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;docker-compose&quot;
        title=&quot;&quot;
        src=&quot;/static/docker-compose-24ae150e7b2b17a62701bda7ca132c75-c83f1.png&quot;
        srcset=&quot;/static/docker-compose-24ae150e7b2b17a62701bda7ca132c75-569e3.png 240w,
/static/docker-compose-24ae150e7b2b17a62701bda7ca132c75-93400.png 480w,
/static/docker-compose-24ae150e7b2b17a62701bda7ca132c75-c83f1.png 960w,
/static/docker-compose-24ae150e7b2b17a62701bda7ca132c75-0011e.png 1000w&quot;
        sizes=&quot;(max-width: 960px) 100vw, 960px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt; 지난번 &lt;a href=&quot;https://heechan.me/posts/how-to-use-docker/&quot;&gt;글(Docker 사용방법 둘러보기)&lt;/a&gt;에서 간단한 URL 기반의 조회수 어플리케이션을 Node JS와 Redis로 만들었다. 지난 글에서 Node JS 어플리케이션을 실행시키기 위해서 다음과 같은 명령어를 사용해야 했다. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;docker run -p 8080:8080 --env REDIS_URL=redis://heechan-macbook-13.local mydocker:latest&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;사용할 포트를 정의하고 환경변수를 넣었는데 겨우 2가지 조건이 설정된 간단한 어플리케이션을 사용하기 위해서 위 명령어를 쳐야한다고 생각해보자. 거기에 그걸 팀원과 공유해야한다면? 변경 사항이 생길때마다 지옥에 빠질 것이다.&lt;/p&gt;
&lt;p&gt; Docker는 이에 대한 답도 제시해놨다. 바로 &lt;a href=&quot;https://docs.docker.com/compose/&quot;&gt;Docker Compose&lt;/a&gt;이다. 이번에도 내가 좋아하는 정의를 찾아보면 Docker Compose 소개 페이지에서는 이렇게 얘기하고 있다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a tool for defining and running multi-container Docker applications&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; Docker compose는 Docker 어플리케이션을 정의하고 멀티 컨테이너 어플리케이션을 실행시키기 위한 도구이다. Docker compose를 이용하면 앞서 소개한 Docker 실행환경등에 대한 정의를 파일로 만들어 관리하고 여러개의 컨테이너를 1번의 명령으로 실행 시킬 수 있다. Mac 환경에서 Docker for Mac이나 Docker Toolbox를 사용한다면 이 2개를 설치할때 함께 설치되었으니 따로 설치할 필요는 없고 바로 사용할 수 있다.&lt;/p&gt;
&lt;h2&gt;이제 docker-compose.yml을 작성해보자&lt;/h2&gt;
&lt;p&gt;Docker Compose 정의는 YAML 파일 형식으로 작성하는데 기본 파일명은 docker-compose.yml이다. 이제 이 파일로 지난 글에서 만들었던 조회수 어플리케이션을 정의해보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-yaml&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;# 사용할 Docker compose 문법의 버전을 정의한다. &lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;# 특정 버전 이상에서만 사용할 수 있는 옵션이나 &lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;# deprecated되는 옵션들이 있기 때문에 필요한 버전을 잘 정의해야 한다.&lt;/span&gt;
&lt;span class=&quot;token key atrule&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;3&quot;&lt;/span&gt;
&lt;span class=&quot;token key atrule&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;# 실행할 컨테이너 이름을 정의한다. &lt;/span&gt;
  &lt;span class=&quot;token key atrule&quot;&gt;view-counter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;# 사용할 이미지 이름과 태그를 정의한다. &lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;# 빌드시에 여기에 명시한 이미지 이름과 태그가 빌드된 이미지에 붙게 된다.&lt;/span&gt;
    &lt;span class=&quot;token key atrule&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; view&lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt;counter&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;latest
    &lt;span class=&quot;token comment&quot;&gt;# 빌드 옵션을 지정한다.&lt;/span&gt;
    &lt;span class=&quot;token key atrule&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;# Build시에 현재 디렉토리를 사용한다는 내용이다.&lt;/span&gt;
      &lt;span class=&quot;token key atrule&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; .
    &lt;span class=&quot;token comment&quot;&gt;# 호스트 포트와 컨테이너 포트를 어떻게 연결할지 정의한다.&lt;/span&gt;
    &lt;span class=&quot;token key atrule&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;8080:8080&quot;&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;# 환경변수 리스트를 정의한다. &lt;/span&gt;
    &lt;span class=&quot;token key atrule&quot;&gt;environment&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;token key atrule&quot;&gt;REDIS_URL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;redis://heechan-macbook-13.local&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;이 docker-compose.yml에는  &lt;code class=&quot;language-text&quot;&gt;docker build . -t view-counter:latest&lt;/code&gt; 이미지 빌드 명령어와  &lt;code class=&quot;language-text&quot;&gt;docker run -p 8080:8080 --env REDIS_URL=redis://heechan-macbook-13.local mydocker:latest&lt;/code&gt;  컨테이너 실행 명령어를 사용할때 사용한 옵션들을 정의했다. (물론 컨테이너 이름을 지정하는 등 약간의 차이는 존재한다.) 이제 docker-compose로 컨테이너를 실행시켜보자. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;$ docker-compose up
Creating network &lt;span class=&quot;token string&quot;&gt;&quot;docker-compose-example_default&quot;&lt;/span&gt; with the default driver
Building view-counter
Step 1/9 &lt;span class=&quot;token keyword&quot;&gt;:&lt;/span&gt; FROM node:9.11
9.11: Pulling from library/node
3d77ce4481b1: Pull complete
534514c83d69: Pull complete
d562b1c3ac3f: Pull complete
4b85e68dc01d: Pull complete
f6a66c5de9db: Pull complete
7a4e7d9a081d: Pull complete
b623744d592a: Pull complete
37e16127669d: Pull complete
Digest: sha256:ca805c44369c53ece95248beace81ba627fd0b13c0e75cfe7f6694144c60bc7c
Status: Downloaded newer image &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; node:9.11
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; d42348c94e97
Step 2/9 &lt;span class=&quot;token keyword&quot;&gt;:&lt;/span&gt; ENV REDIS_URL&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;redis://heechan.local&quot;&lt;/span&gt;
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; Running &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; 1d47e07dd858
Removing intermediate container 1d47e07dd858
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; 97873862a2c2
Step 3/9 &lt;span class=&quot;token keyword&quot;&gt;:&lt;/span&gt; WORKDIR app
Removing intermediate container f4d6da10a2a7
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; 9d566502d25f
Step 4/9 &lt;span class=&quot;token keyword&quot;&gt;:&lt;/span&gt; COPY ./package.json package.json
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; 989202879c2f
Step 5/9 &lt;span class=&quot;token keyword&quot;&gt;:&lt;/span&gt; COPY ./yarn.lock yarn.lock
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; ae1b730d2179
Step 6/9 &lt;span class=&quot;token keyword&quot;&gt;:&lt;/span&gt; RUN yarn &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt;
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; Running &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; d7c22755be27
yarn &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; v1.5.1
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;1/4&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; Resolving packages&lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;.
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;2/4&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; Fetching packages&lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;.
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;3/4&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; Linking dependencies&lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;.
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;4/4&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; Building fresh packages&lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;.
Done &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; 0.45s.
Removing intermediate container d7c22755be27
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; 0649e06d0e84
Step 7/9 &lt;span class=&quot;token keyword&quot;&gt;:&lt;/span&gt; COPY ./index.js index.js
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; c11158de8600
Step 8/9 &lt;span class=&quot;token keyword&quot;&gt;:&lt;/span&gt; ENTRYPOINT &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;node&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; Running &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; a08a20e99393
Removing intermediate container a08a20e99393
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; 619244769f5e
Step 9/9 &lt;span class=&quot;token keyword&quot;&gt;:&lt;/span&gt; CMD &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;index.js&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; Running &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; 6759e16c9114
Removing intermediate container 6759e16c9114
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; 16b2a157cffc
Successfully built 16b2a157cffc
Successfully tagged view-counter:latest
WARNING: Image &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;service&lt;/span&gt; view-counter was built because it did not already exist. To rebuild this image you must use &lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;docker-compose build&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;&lt;/span&gt; or &lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;docker-compose up --build&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;.&lt;/span&gt;
Creating docker-compose-example_view-counter_1 &lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;. &lt;span class=&quot;token keyword&quot;&gt;done&lt;/span&gt;
Attaching to docker-compose-example_view-counter_1
view-counter_1  &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; start server
view-counter_1  &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; start to connect redis: redis://heechan-macbook-13.local&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;docker-compose up&lt;/code&gt; 으로 컨테이너를 실행시켰다. &lt;code class=&quot;language-text&quot;&gt;docker-compose.yml&lt;/code&gt;에 정의된 이미지가 없거나 &lt;code class=&quot;language-text&quot;&gt;--build&lt;/code&gt; 옵션을 사용한 경우 &lt;code class=&quot;language-text&quot;&gt;build&lt;/code&gt; 항목을 참조하여 이미지를 빌드하여 사용한다. 이제 매번 명령어를 사용하여 docker 실행 환경을 정의할 필요가 없어졌다. &lt;/p&gt;
&lt;h2&gt;Redis도 컨테이너로 사용하기&lt;/h2&gt;
&lt;p&gt;작성한 &lt;code class=&quot;language-text&quot;&gt;docker-compose.yml&lt;/code&gt;에 Redis 컨테이너를 추가해보자. 이제 호스트 머신에 설치된 Redis를 사용하는 대신에 컨테이너 레디스를 사용할 것이다. &lt;a href=&quot;https://hub.docker.com/_/redis/&quot;&gt;Redis 이미지&lt;/a&gt;는 Docker Hub에 올라가 있으니 그것을 사용한다. Docker Hub를 보면 redis 설정을 위한 다양한 옵션들이 있으니 기본 설정이 아닌 다른 설정을 사용하고자 한다면 Docker Hub를 참조하여 옵션을 설정하면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-yaml&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;&lt;span class=&quot;token key atrule&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;3&quot;&lt;/span&gt;
&lt;span class=&quot;token key atrule&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;token key atrule&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token key atrule&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; docker&lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt;example&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;latest
    &lt;span class=&quot;token key atrule&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;token key atrule&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; .
    &lt;span class=&quot;token key atrule&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;8080:8080&quot;&lt;/span&gt;
    &lt;span class=&quot;token key atrule&quot;&gt;links&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt; redis
    &lt;span class=&quot;token key atrule&quot;&gt;environment&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;token key atrule&quot;&gt;REDIS_URL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;redis://redis&quot;&lt;/span&gt;
  &lt;span class=&quot;token key atrule&quot;&gt;redis&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;# hostname을 정의한다. 따로 작성하지 않으면 service 이름과 같은 이름을 사용한다.&lt;/span&gt;
    &lt;span class=&quot;token key atrule&quot;&gt;hostname&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; redis
    &lt;span class=&quot;token key atrule&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; redis&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;latest&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;이제 다시 &lt;code class=&quot;language-text&quot;&gt;docker-compose up&lt;/code&gt;을 해보자. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ docker-compose up
Creating network &lt;span class=&quot;token string&quot;&gt;&quot;docker-compose-example_default&quot;&lt;/span&gt; with the default driver
Creating docker-compose-example_redis_1        &lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;. &lt;span class=&quot;token keyword&quot;&gt;done&lt;/span&gt;
Creating docker-compose-example_view-counter_1 &lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;. &lt;span class=&quot;token keyword&quot;&gt;done&lt;/span&gt;
Attaching to docker-compose-example_redis_1, docker-compose-example_view-counter_1
redis_1         &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; 1:C 20 May 07:26:15.378 &lt;span class=&quot;token comment&quot;&gt;# oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo&lt;/span&gt;
redis_1         &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; 1:C 20 May 07:26:15.378 &lt;span class=&quot;token comment&quot;&gt;# Redis version=4.0.9, bits=64, commit=00000000, modified=0, pid=1, just started&lt;/span&gt;
redis_1         &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; 1:M 20 May 07:26:15.380 * Ready to accept connections
view-counter_1  &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; start server
view-counter_1  &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; start to connect redis: redis://redis&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt; 아주 손쉽게 로컬에 있는 Redis 대신에 Redis 컨테이너를 띄웠다. 이제 호스트에 Redis를 깔지 않고도 이 어플리케이션에서 Redis를 사용할 수 있게 되었다. &lt;/p&gt;
&lt;h2&gt;Docker Compose로 할 수 있는 일&lt;/h2&gt;
&lt;p&gt;위에서 소개한 기능들은 Docker Compose의 기능중 아주 기본적인 기능 몇가지만을 소개했다. 이 외에도 Docker Compose로 아주 다양한 일을 할 수 있는데 이는 &lt;a href=&quot;https://docs.docker.com/compose/compose-file/#service-configuration-reference&quot;&gt;Docker Compose compose-file&lt;/a&gt;항목을 천천히 읽어 보는 것을 추천한다. 그리고 작성한 Docker Compose를 이용해서 다른 서비스에도 응용 가능하다. 대표적인 예로 들 수 있는 것이 AWS의 &lt;a href=&quot;https://aws.amazon.com/ecs/&quot;&gt;Elastic Container Service&lt;/a&gt;이다. ECS에서는 컨테이너 어플리케이션을 배포하기 위해서 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-taskdefinition.html&quot;&gt;ECS Task Definition&lt;/a&gt;이라는 것을 작성해야 한다. ECS Task Definition은 &lt;code class=&quot;language-text&quot;&gt;docker-compose.yml&lt;/code&gt;처럼 어플리케이션의 설정등을 정의하는 파일인데 이것을 &lt;code class=&quot;language-text&quot;&gt;docker-compose.yml&lt;/code&gt;을 이용하여 생성하는 기능을 제공한다. 물론 모든 기능이 1대1로 사용 가능한 것은 아니지만 AWS와 로컬 개발환경에서 거의 같은 설정을 이용 가능하다는 장점이 있다.&lt;/p&gt;
&lt;p&gt;다음 글에서는 AWS ECS를 통해 이렇게 작성한 컨테이너 어플리케이션을 배포 하는 것을 다뤄보겠다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[Docker 사용 방법 둘러보기]]></title><description><![CDATA[Docker의 기본적인 사용 방법을 둘러보고 내 어플리케이션을 Dockerize 해보자]]></description><link>https://heechan.me/posts/how-to-use-docker/</link><guid isPermaLink="false">https://heechan.me/posts/how-to-use-docker/</guid><pubDate>Mon, 14 May 2018 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;최근 Docker를 적극적으로 쓰게 되면서 정리한 내용을 공유해본다. 깊은 내용까지 들어가지는 않고 Docker를 사용하기 위해서 간단하게 둘러보는 글이다. &lt;/p&gt;
&lt;h1&gt;Docker가 뭔가요?&lt;/h1&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/docker-86de559821c6f80bbfa88048559bcb40-82eb5.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 323px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 84.21052631578947%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAARlAAAEZQAGA43XUAAADgUlEQVQ4y4VUa2xMQRS+d+/eO3OrKCEi8UPEDwSJhAgtwg8Rr3pEPCKCEMpuq+1SRIs+0FL6Qne7Hm33VlGPqDYIbdp4thVU0YSqeKYeJR4l1b3jm3tXdyXETb49M2fOfHO+M2dWEP7yWaeu+2OuRBX3JNuqnWRr1X55lTvI8G0oFZXNFyzS9FgzJvZ0wAa7JiiOs+Z43UmRxF+R5OU5xDpvexe4LPLagqE0/SEjqXeYYivsFXgY/KJi8wiyvcjvlEFokMWcEn/7SEKFi+ys+0iSbjSTlFuvSPJNnSTfaJXCFlmN2OiSvoif5Y+v9BOS+ApBiSwSTSnnhkBiOAJqaeYTRnbUMZJ2l5GUGkaSrn+DkqVQNAglWE1zXzMkM9HYl3JLwMEBpInXZd9JCfTASxDVttM9DV5k6SVp97wg1smOmg568BUnLlcijy1Tj35mkNyG7N8oUcdD/TWMK7P4JI/CYgPd+4jXq4Puuc9o6h2d7q7XSepd7tPpvkZGdt5+AVyhOc8YTav/jAOK5ZXOEH92Wy6bddlYblfzvzLV/b5dzXurA8ya16pTFx+/Y5TD9dbLrXqcceJGYeDo7p2J+crGiSy+2x5Ns5oYOfzJawFRN3eLvrr0sd79yAed5L3jpDp1v/+pHv7opdnNTIkpmWHcdPZTqxxxRPRLRg9NYcxsg8Rr1SGFX1jv3OYfg/Nf/Bymve4IAgl1f2hXD7V2cAV0/3OGJGKM+Kwmybo00+RxnDF7kH89HSeMLIW5mQPmOCsb61va2HfG2JxqxmhBGwsCVNwqLqsRCYTz0OBqJkpTIjt7WQjQbtgVRTXmfKWz64qCq3ZXZYPmrnpwfmBG7QkxvipVdZyeIdBgoxtUV4v/lUQVm4+Dk6LL0emahIlViCiQesedkoTFZaLwj68PSoOukOWIoxa+BxABPpbQk1Lg8xsARAduhmJL52uKLFqI9dnC/z4E9VXsng2w+cAm2aYNh80Gxpvrnij4AE8KfJOAMfx1wPK4RGAYMBYqtxkJ4ccJzAQSZLunDDYdGAeiDNgMBG6GHYnSbIe9CWRhbQJsJbAbuARUALsQO4ITliCgC+xk4CI/1Zd5EgIuw07zZboeY35gskFo0+qQuQPzeEOdTev3+58mDBOQarnIMATjtZDHN64BegBu+KDCswXoj7WZmC+Bfz6g8dJgvgAIxZrwC8Llv8J+30UBAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;docker 아주 귀엽다&quot;
        title=&quot;&quot;
        src=&quot;/static/docker-86de559821c6f80bbfa88048559bcb40-82eb5.png&quot;
        srcset=&quot;/static/docker-86de559821c6f80bbfa88048559bcb40-ef522.png 240w,
/static/docker-86de559821c6f80bbfa88048559bcb40-82eb5.png 323w&quot;
        sizes=&quot;(max-width: 323px) 100vw, 323px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;우리의 친구 위키피디아를 찾아보자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Docker&lt;/strong&gt; is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Computer_program&quot;&gt;computer program&lt;/a&gt; that performs &lt;a href=&quot;https://en.wikipedia.org/wiki/Operating-system-level_virtualization&quot;&gt;operating-system-level virtualization&lt;/a&gt; also known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Operating-system-level_virtualization&quot;&gt;containerization&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Docker_(software)&quot;&gt;- Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;위키피디아에서는 Docker를 컨테이너라고 알려진 OS 수준 가상화를 제공하는 프로그램이라고 정의하고 있다. 가상화하면 VM인데 컨테이너는 또 뭘까? 우리가 아는 컨테이너는 화물선에 실리는 화물 컨테이너뿐인데 말이다. 컨테이너 가상화도 화물 컨테이너처럼 규격화되고 추상화해줘서 Host 머신과 상관없이 구동할 수 있게 해주는 프로그램이다.&lt;/p&gt;
&lt;h1&gt;Docker를 왜 쓰나요?&lt;/h1&gt;
&lt;h3&gt;재사용&lt;/h3&gt;
&lt;p&gt;Docker를 사용하는 환경에 관계없이 같은 이미지를 이용해 컨테이너를 어디서든 실행 가능하다. 내 노트북 위의 개발 환경, CI의 테스트, 스테이징 서버, 실 서비스 환경에서 같은 Docker 이미지를 사용해 같은 컨테이너를 실행한다는 것이다. Docker 없이 실 서버에 바로 배포를 하는 경우 의존성이 있는 소프트웨어의 로컬 환경과 개발 환경 간의 버전 차이, 설정 차이 등이 발생할 수 있는데 이 부분을 최소화할 수 있다. 이는 테스트 환경에선 만나지 못했는데 실 서비스 환경에서 문제를 만날 확률을 줄여준다.&lt;/p&gt;
&lt;h3&gt;격리&lt;/h3&gt;
&lt;p&gt;Docker 컨테이너는 Host OS의 커널을 공유하지만 실행 영역을 공유하지 않기 때문에 Host OS의 응용프로그램이나 다른 컨테이너의 영향을 받지 않고 각 컨테이너가 독립적으로 동작한다.&lt;/p&gt;
&lt;h3&gt;Docker Hub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://hub.docker.com&quot;&gt;https://hub.docker.com&lt;/a&gt; github처럼 Docker 이미지를 공유할 수 있는 서비스다. 이곳에서 이미 만들어진 Docker 이미지를 pull해서 사용할 수 있다.  굉장히 다양한 소프트웨어의 Docker 이미지를 사용할 수 있다. github에 Dockerfile이 공개되어있는 오픈소스의 경우 대부분 Docker Hub에서 찾을 수 있다.&lt;/p&gt;
&lt;h3&gt;CI/CD&lt;/h3&gt;
&lt;p&gt;Docker 컨테이너는 사실상의 표준이다. 현재 Travis, Jenkins, Gitlab CI, Circle CI 등 다양한 CI/CD 툴에서 Docker를 지원한다. 이런 다양한 Managed CI/CD 시스템중 하나를 사용한다면 복잡한 설정 없이 Docker를 바로 사용할 수 있다. &lt;/p&gt;
&lt;h1&gt;그래서 그 좋은 Docker는 어떻게 쓰는 거죠?&lt;/h1&gt;
&lt;p&gt;시작하기 전에 몇가지 개념을 짚고 넘어가자. 먼저 도커 이미지, 컨테이너가 있다. 이미지는 docker build 커맨드를 통해서 만들어진 스냅샷이다. 그리고 컨테이너는 이미지를 통해 만들어진 인스턴스이다. OOP에서 Class와 객체와 같은 개념이라고 생각하면 편하게 이해할 수 있다.&lt;/p&gt;
&lt;p&gt; &lt;code class=&quot;language-text&quot;&gt;Hello World&lt;/code&gt;를 찍어보자.(&lt;a href=&quot;https://www.docker.com/community-edition#/download&quot;&gt;Docker 설치&lt;/a&gt;는 되어있다고 가정한다.) &lt;code class=&quot;language-text&quot;&gt;docker run docker:latest echo &amp;quot;Hello World&amp;quot;&lt;/code&gt;를 입력하면 아래와 같은 화면이 나온다. 아래 Hello world 명령어를 보면서 Docker 명령어를 뜯어보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;$ docker run docker:latest echo &amp;quot;Hello World&amp;quot;
Unable to find image &amp;#39;docker:latest&amp;#39; locally
latest: Pulling from library/docker
ff3a5c916c92: Pull complete
1a649ea86bca: Pull complete
ce35f4d5f86a: Pull complete
e6fece0477c1: Pull complete
550c91598bd2: Pull complete
7ff0c6a709f7: Pull complete
Digest: sha256:8879659d45d4b2115f9b67ec18ca29712ad79dff889763e7b8d3377d4373968b
Status: Downloaded newer image for docker:latest
Hello World&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;이 커맨드는 Docker라는 이미지의 latest 버전 이미지를 사용하여 &lt;code class=&quot;language-text&quot;&gt;echo &amp;quot;Hello world&amp;quot;&lt;/code&gt;라는 명령어를 실행하라는 커맨드다. 한 부분씩 뜯어보면 순서대로 Docker 컨테이너를 실행하라는 &lt;code class=&quot;language-text&quot;&gt;run&lt;/code&gt; 커맨드 어떤 이미지를 사용할지 명시하는 부분  &lt;code class=&quot;language-text&quot;&gt;docker:latest&lt;/code&gt; 이미지 이름:태그명 어떤 명령어를 사용할지 명시하는 &lt;code class=&quot;language-text&quot;&gt;echo &amp;quot;Hello World&amp;quot;&lt;/code&gt;실행할 명령어 이렇게 구성되어 있다.&lt;/p&gt;
&lt;h1&gt;제 어플리케이션을 어떻게 Docker 이미지로 만들죠?&lt;/h1&gt;
&lt;p&gt;먼저 어떤 어플리케이션을 만들지 시나리오를 정해보자. 아래 요구사항의 간단한 조회수 어플리케이션을 만들고 Docker 이미지로 만들어보자.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;특정 URL로 들어오는 조회 수를 저장&lt;/li&gt;
&lt;li&gt;해당 URL로 접속이 들어올 때마다 조회수를 1씩 증가&lt;/li&gt;
&lt;li&gt;페이지에 대한 응답으로는 조회수를 응답&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;조회 수를 저장할 데이터베이스로는 Redis를 사용하고 패키지 관리는 yarn을 사용했다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;# redis-server install
# mac에서 redis server install하기
$ brew install redis 

# 데비안에서 redis server install
$ sudo apt-get install redis-server -y

# yarn 패키지 초기화 및 redis javascript 클라이언트 설치
$ yarn init
$ yarn add redis&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;index.js&lt;/code&gt; 파일을 작성해보자. 간단히 내용을 설명하면 &lt;code class=&quot;language-text&quot;&gt;REDIS_URL&lt;/code&gt;이라는 환경 변수에서 Redis 접속 URL을 받아 URL 기반의 redis key로 조회 수를 count하고 반환하는 어플리케이션이다. 개선해야 할 문제가 몇 가지 있지만 간단한 예제로써 바라보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;start server&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; http &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;http&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; redis &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;redis&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; redisUrl &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; process&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;env&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;REDIS_URL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;start to connect redis: &apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; redisUrl&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; client &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; redis&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createClient&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    url&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; redisUrl
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
http&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createServer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;req&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;writeHead&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;application/json&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    client&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;incr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;req&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;url&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;error&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; viewCount &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; value&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; response &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;viewCount&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; viewCount &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;stringify&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;response&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;8080&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;이제 조회 수 Node js 어플리케이션을 돌려볼 시간이다. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;redis-server&lt;/code&gt; 명령어로 foreground에서 Redis 서버를 띄운다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;REDIS_URL=&amp;#39;redis://localhost&amp;#39; node index.js&lt;/code&gt; 명령어로 어플리케이션을 실행시킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;http://localhost:8080/1&lt;/code&gt;로 접속해본다. 혹은 &lt;code class=&quot;language-text&quot;&gt;curl http://localhost:8080/1&lt;/code&gt; 명령어를 실행시킨다. 아래와 같은 값이 반환될 것이다. 여러번 실행하면 실행할 때마다 viewCount 값이 올라가는 것을 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-json&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;&quot;viewCount&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이제 만들었던 어플리케이션을 돌아보자. 먼저 로컬에 Redis를 설치했다. 만약에 구동할 서버와 Redis 버전 등이 다르다면 다르게 동작할 가능성을 배제할 수 없다. 만약에 어떤 레거시 프로젝트에서는 Redis 1.2버전을 요구하고 이번에 새로 시작하는 프로젝트에서는 최신 버전인 4.0.9 버전을 요구한다면? 프로젝트마다 Redis 버전을 맞춰주는 수고를 해야 할 것이다. 이런 문제를 수월하게 해결하기 위해서 Docker를 활용해보자.&lt;/p&gt;
&lt;p&gt;Dockerfile을 작성해보자. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-dockerfile&quot;&gt;&lt;code class=&quot;language-dockerfile&quot;&gt;FROM node:9.11

ENV REDIS_URL=&amp;quot;redis://redis&amp;quot;
WORKDIR app
COPY ./package.json package.json
COPY ./yarn.lock yarn.lock
RUN yarn install
COPY ./index.js index.js
ENTRYPOINT [&amp;quot;node&amp;quot;]
CMD [&amp;quot;index.js&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;FROM&lt;/code&gt;은 어떤 base Image를 사용할지 정의하는 부분이다. 이 예제에서는 node 9.11버전의 &lt;a href=&quot;https://hub.docker.com/_/node/&quot;&gt;Docker Image&lt;/a&gt;를 사용한다. 이는 node 사용을 위해서 최소한의 패키지만 설치된 리눅스와 node 9.11 버전이 설치되어 있는 이미지이다. 위에서 언급한 대로 기본 설정은 Docker hub에서 가져온다. Docker hub private이나 ECR 등의 Private Registry에서 가져올 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;ENV&lt;/code&gt;는 환경변수를 정의한다. REDIS_URL이라는 환경변수를 정의하고 기본값으로 &lt;code class=&quot;language-text&quot;&gt;redis://redis&lt;/code&gt;를 넣는다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;WORKDIR&lt;/code&gt;은 앞으로 실행할 커맨드들의 디렉터리를 명시한다. 아래 커맨드들은 /app 디렉터리에서 실행된다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;COPY&lt;/code&gt;는 호스트에 있는 파일을 복사한다. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;RUN&lt;/code&gt; 은 커맨드를 실행한다. 복사한 &lt;code class=&quot;language-text&quot;&gt;package.json, yarn.lock&lt;/code&gt; 을 이용하여 node 패키지를 설치한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;ENTRYPOINT&lt;/code&gt;는 컨테이너가 시작했을 때 실행될 명령을 정의한다. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;CMD&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;docker run&lt;/code&gt; 실행 시 기본 명령을 설정하거나, &lt;code class=&quot;language-text&quot;&gt;ENTRYPOINT&lt;/code&gt;의 기본 인자를 설정할 때 사용한다. 이 경우에는 &lt;code class=&quot;language-text&quot;&gt;ENTRYPOINT&lt;/code&gt;가 있기 때문에 기본 인자를 설정하는데 사용됐다.&lt;/p&gt;
&lt;p&gt;이제 작성한 Dockerfile로 Docker Image를 빌드하고 컨테이너를 만들어보자!&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ docker build &lt;span class=&quot;token keyword&quot;&gt;.&lt;/span&gt; -t mydocker:latest
Sending build context to Docker daemon  393.7kB
Step 1/9 &lt;span class=&quot;token keyword&quot;&gt;:&lt;/span&gt; FROM node:9.11
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; aa3e171e4e95
Step 2/9 &lt;span class=&quot;token keyword&quot;&gt;:&lt;/span&gt; ENV REDIS_URL&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;redis://heechan.local&quot;&lt;/span&gt;
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; Running &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; e0f1070d2b1d
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; 4a4b78af15d7
Step 3/9 &lt;span class=&quot;token keyword&quot;&gt;:&lt;/span&gt; WORKDIR app
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; 4df475788243
Step 4/9 &lt;span class=&quot;token keyword&quot;&gt;:&lt;/span&gt; COPY ./package.json package.json
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; a6c91ba46484
Step 5/9 &lt;span class=&quot;token keyword&quot;&gt;:&lt;/span&gt; COPY ./yarn.lock yarn.lock
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; 57d5e7322edd
Step 6/9 &lt;span class=&quot;token keyword&quot;&gt;:&lt;/span&gt; RUN yarn &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt;
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; Running &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; 9394ffb17054
yarn &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; v1.5.1
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;1/4&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; Resolving packages&lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;.
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;2/4&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; Fetching packages&lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;.
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;3/4&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; Linking dependencies&lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;.
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;4/4&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; Building fresh packages&lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;.
Done &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; 0.58s.
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; 57f3bc6b13a2
Step 7/9 &lt;span class=&quot;token keyword&quot;&gt;:&lt;/span&gt; COPY ./index.js index.js
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; 861e3f8f5cd8
Step 8/9 &lt;span class=&quot;token keyword&quot;&gt;:&lt;/span&gt; ENTRYPOINT &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;node&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; Running &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; 5db0339737d2
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; c94f66c0a4a9
Step 9/9 &lt;span class=&quot;token keyword&quot;&gt;:&lt;/span&gt; CMD &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;index.js&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; Running &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; dd01fe57901b
 ---&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; d2edde90a736
Successfully built d2edde90a736
Successfully tagged mydocker:latest&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;docker image ls&lt;/code&gt;명령어를 사용해보면 latest 태그가 붙은 mydocker라는 이미지가 생성되어 있을 것이다.&lt;/p&gt;
&lt;p&gt;이제 이 docker image로 컨테이너를 생성해보자. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;$ docker run -p 8080:8080 --env REDIS_URL=redis://heechan-macbook-13.local mydocker:latest&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;-p 옵션으로 localhost의 8080포트와 컨테이너의 8080포트를 바인딩 했고 REDIS_URL 환경 변수로 호스트 머신의 Redis 주소를 넘겼다.(redis-server 실행 시에 &lt;code class=&quot;language-text&quot;&gt;--protected-mode no&lt;/code&gt; 옵션을 줘야 합니다.) &lt;/p&gt;
&lt;p&gt;이제 &lt;code class=&quot;language-text&quot;&gt;docker container ls&lt;/code&gt; 명령을 사용하면 실행 중인 컨테이너를 확인할 수 있다. &lt;code class=&quot;language-text&quot;&gt;docker container stop 컨테이너 ID&lt;/code&gt; 명령어를 사용하면 컨테이너를 종료할 수도 있다. &lt;/p&gt;
&lt;p&gt;원래 이번 글에서 docker compose를 사용해보는 것까지 쓰려고 했지만 내용이 길어져 &lt;a href=&quot;/posts/how-to-use-docker-compose/&quot;&gt;다음 글&lt;/a&gt;에서 다루려고 한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[PHPDBG를 이용해서 PHPUnit Code Coverage 커버리지 측정 시간 단축하기]]></title><description><![CDATA[phpunit-code-coverage로 인해 느려진 테스트 실행 시간을 단축해보자]]></description><link>https://heechan.me/posts/shorten-phpunit-code-coverage-excution-time/</link><guid isPermaLink="false">https://heechan.me/posts/shorten-phpunit-code-coverage-excution-time/</guid><pubDate>Sat, 05 May 2018 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;8percent의 &lt;a href=&quot;https://brunch.co.kr/@leehosung/43&quot;&gt;코드 커버리지 80% 넘긴 썰(8percent)&lt;/a&gt; 이 글을 읽고 나서 오픈소스도 아닌 회사 프로젝트가 코드 커버리지 80%를 넘겼다는 이야기와 함께 &lt;code class=&quot;language-text&quot;&gt;어떻게 코드 커버리지를 80%에 도달하게 되었는가?&lt;/code&gt; 라는 과정이 인상적이었다. 그래서 코드 커버리지 측정을 도입했고 그 과정에서 있었던 작은 삽질을 소개하고자 한다. &lt;/p&gt;
&lt;h2&gt;코드 커버리지 측정&lt;/h2&gt;
&lt;p&gt;기존 테스팅 프레임워크로는 PHPUnit을 사용 중이었으므로 &lt;a href=&quot;https://phpunit.de/manual/6.5/en/code-coverage-analysis.html&quot;&gt;PHPUnit에서 권장&lt;/a&gt;하는 &lt;a href=&quot;https://github.com/sebastianbergmann/php-code-coverage&quot;&gt;php-code-coverage&lt;/a&gt;를 사용하였다. (php-code-coverage는 xdebug에 의존성이 있다. 즉 테스트가 돌아가는 환경에 xdebug도 필요하다.)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ composer install --require-dev phpunit/php-code-coverage&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;이제 기존에 PHPUnit 테스트를 가지고 있는 프로젝트에서 테스트 커버리지와 함께 테스팅을 돌려보자. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;$ vendor/bin/phpunit --coverage-text --coverage-html
PHPUnit 6.5.6 by Sebastian Bergmann and contributors.

.................SSSSSS........................................  63 / 180 ( 35%)
....................................S.......................... 126 / 180 ( 70%)
......................................................          180 / 180 (100%)

Time: 9.24 minutes, Memory: 60.00MB

Generating code coverage report in HTML format ... done&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;이제 커버리지 측정 완료… 그런데 전체 테스트 시간이 기존 2~3분에서 약 9분으로 증가했다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://media.giphy.com/media/3oEjHZ02R5YhUNFcjK/giphy.gif&quot; alt=&quot;이래선 사용할 수가 없다&quot;&gt;&lt;/p&gt;
&lt;h2&gt;원인! 원인을 찾자!&lt;/h2&gt;
&lt;p&gt;커버리지 측정을 하고 리포트를 생성하는 일이 그렇게까지 오래 걸리는 일인가?라는 질문을 가지고 알아본 결과 나만 그런 것이 아니었다. 다른 사람들이 제시한 해결책으로 phpdbg를 사용하는 방법이 있었다. &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hackernoon.com/generating-code-coverage-with-phpunite-and-phpdbg-4d20347ffb45&quot;&gt;phpunit과 phpdbg로 커버리지 리포트 생성하기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;내 사례와 같이 phpunit-code-coverage 사용 이후 테스트 속도가 매우 느려졌고 Xdebug 대신 phpdbg를 사용하여 속도를 개선했다는 내용이다. 글에서는 phpdbg를 사용할 때와 Xdebug를 사용할 때 코드 커버리지 리포트가 완전히 같지 않다는 문제를 소개하지만 작은 오차이고 오차없는 코드 커버리지 수치를 얻는게 목적이 아니기 때문에 phpdbg를 사용했다.&lt;/p&gt;
&lt;p&gt;brew를 이용해서 맥에서 php와 함께 phpdbg를 설치 할 수 있다. (우분투의 경우 저장소에서 제공한다. &lt;a href=&quot;https://packages.ubuntu.com/xenial/amd64/php7.0-phpdbg&quot;&gt;ubuntu package&lt;/a&gt;)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ brew install php70 --with-phpdbg&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;사용하는 phpdbg 옵션을 간단히 설명하면 -q는 phpdbg 배너 출력을 하지 않게 하고 -rr 옵션은 실행 후에 phpdbg를 종료시키는 옵션이다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ phpdbg -qrr vendor/bin/phpunit --coverage-text --coverage-html=coverage
PHPUnit 6.5.7 by Sebastian Bergmann and contributors.

..................SSSSSS.......................................  63 / 166 ( 37%)
............................................................... 126 / 166 ( 75%)
........................................                        166 / 166 (100%)

Time: 3.48 minutes, Memory: 1306.00MB

Generating code coverage report in HTML format ... done&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;테스트 시간이 종래의 9분에서 3분 30초 정도로 줄어들었다. 그런데 메모리 사용량이 증가했다! 사실 이 화면을 보기 전에 PHP memory exhausted error가 발생해서 메모리 사용량 제한을 증가시켜줘야 했다. 추가로 조사해보니 phpdbg를 사용하는 경우 테스트에서 &lt;code class=&quot;language-text&quot;&gt;Tester\CodeCoverage\Collector::flush()&lt;/code&gt;를 호출해 직접 메모리를 비워줘야 한다고 한다. &lt;/p&gt;
&lt;h2&gt;더 빠르게&lt;/h2&gt;
&lt;p&gt;커버리지 측정을 도입하면서 전체 테스팅과 CI에 소요되는 전체 시간을 줄이기 위한 몇 가지 노력을 더 했고 이를 소개한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;패키지 설치 스크립트 최소화&lt;/p&gt;
&lt;p&gt;이건 PHPUnit에 관련된 것은 아닌 것이지만 CI를 사용하고 있다면 한번 살펴보면 좋을 부분이다. 기존에 CI에서 php docker 이미지에 추가로 사용하고 있는 패키지를 설치하는 과정이 있었는데 이걸 미리 해둔 &lt;a href=&quot;https://hub.docker.com/r/ridibooks/store-php-test/&quot;&gt;docker hub에 image&lt;/a&gt;를 빌드해서 올렸다. 이로써 매 테스트마다 패키지를 설치하느라 소요되는 시간이 없어졌다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;느린 Test 찾아내기&lt;/p&gt;
&lt;p&gt;전체 테스트 과정에서 실행하는데 오래 걸리는 테스트를 찾아냈다. 이는 &lt;a href=&quot;https://github.com/johnkary/phpunit-speedtrap&quot;&gt;phpunit-speedtrap&lt;/a&gt;이라는 라이브러리를 사용하여 느린 테스트를 찾았다. 이를 이용해서 과도하게 오래 걸리는 테스트를 찾아내고 최적화하거나 불필요한 것들을 없앴다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Parallel Testing&lt;/p&gt;
&lt;p&gt;기본적으로 PHPUnit은 테스트를 순차 실행한다. 순차 실행으로 생기는 속도 저하를 병렬 실행을 통해 개선할 수 있게 도와주는 extension도 존재한다. 몇 가지 extension이 있지만 &lt;a href=&quot;https://phpunit.de/extensions.html&quot;&gt;phpunit extension 페이지&lt;/a&gt;에서 소개한 &lt;a href=&quot;https://github.com/paratestphp/paratest&quot;&gt;paratest&lt;/a&gt;를 사용했다. &lt;del&gt;(그리고 내가 &lt;a href=&quot;https://github.com/paratestphp/paratest/pull/308&quot;&gt;기여&lt;/a&gt;도 했다)&lt;/del&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;결론&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://media.giphy.com/media/3NtY188QaxDdC/giphy.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;코드 커버리지 리포트를 얻었고 전체 CI 시간은 종전보다 더 빨라졌다. 커버리지 측정을 적용하면서 느려진 부분은 phpdbg로 실행 시간을 단축하고 그 외에 &lt;code class=&quot;language-text&quot;&gt;패키지 설치 스크립트 최소화&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;느린 Test 찾아내기&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Parallel Testing&lt;/code&gt; 등을 도입해 전체 CI 시간을 기존보다 약간 단축하는데 성공했다.&lt;/p&gt;
&lt;h3&gt;TL; DR&lt;/h3&gt;
&lt;p&gt;php-code-coverage사용시 속도가 너무 느리다면 phpdbg 사용을 시도해볼만 하다.&lt;/p&gt;</content:encoded></item></channel></rss>