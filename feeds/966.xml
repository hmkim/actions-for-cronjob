<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" media="screen" href="/~d/styles/atom10full.xsl"?><?xml-stylesheet type="text/css" media="screen" href="http://feeds.feedburner.com/~d/styles/itemcontent.css"?><feed xmlns="http://www.w3.org/2005/Atom" xmlns:feedburner="http://rssnamespace.org/feedburner/ext/1.0">
  <title>leafbird.github.io/devnote</title>
  
  
  
  <link href="http://leafbird.github.io/devnote/" />
  <updated>2018-11-12T14:27:21.365Z</updated>
  <id>http://leafbird.github.io/devnote/</id>
  
  <author>
    <name>leafbird</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="self" type="application/atom+xml" href="http://feeds.feedburner.com/florist_devnote" /><feedburner:info uri="florist_devnote" /><atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="hub" href="http://pubsubhubbub.appspot.com/" /><entry>
    <title>테크니컬 리더십: 시작하기</title>
    <link href="http://feedproxy.google.com/~r/florist_devnote/~3/G1fKMCddJOU/" />
    <id>http://leafbird.github.io/devnote/2018/11/테크니컬-리더십-시작하기/</id>
    <published>2018-11-12T14:05:29.000Z</published>
    <updated>2018-11-12T14:27:21.365Z</updated>
    
    <content type="html">&lt;p&gt;예전에 트위터 하다가 읽었던 글인데, 개인적으로 마음에 들어서 부족하게나마 번역해 보았습니다.&lt;br&gt;원문은 슬랙 개발 블로그의 &lt;a href="https://slack.engineering/technical-leadership-getting-started-e5161b1bf85c" target="_blank" rel="external"&gt;Technical Leadership: Getting Started&lt;/a&gt;라는 글입니다.&lt;br&gt;번역에 크게 자신이 없으니 부담이 없으신 분들은 원문을 보셔요. &lt;/p&gt;
&lt;img src="/devnote/2018/11/테크니컬-리더십-시작하기/00.png" alt="개발 실무자의 리더십은 스스로를 리딩하는 것에서 시작한다" title="개발 실무자의 리더십은 스스로를 리딩하는 것에서 시작한다"&gt;
&lt;h2 id="테크니컬-리더십-시작하기"&gt;&lt;a href="#테크니컬-리더십-시작하기" class="headerlink" title="테크니컬 리더십: 시작하기"&gt;&lt;/a&gt;테크니컬 리더십: 시작하기&lt;/h2&gt;&lt;p&gt;내가 소프트웨어 엔지니어가 되기 전에는 이 직업에서 가장 중요한 점은 코딩이라고 생각했다. 그것은 잘못된 생각이었고, 소프트웨어 공학의 가장 중요한(그리고 가장 어려운)점은 다른 사람들과 원만하게 잘 협력하는 것이다. &lt;/p&gt;
&lt;p&gt;나는 “관리자는 되지 않을거야!”라고 스스로에게 말해왔고, “그렇게 하면, 내 모든 에너지를 개발에만 집중시킬 수 있을거야!” 라고 생각했다. 내 이후의 경력도 기술 지향적인 실무자 위주로만 관리해 간다면 이 어려운 대인관계를 어느 정도 무시할 수 있을 거라고 생각했다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;빨리 가려거든 혼자 가고, 멀리 가려거든 함께 가라.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;내가 업무에서 대인관계를 소홀히 여기던 때 의아하게 생각했던 점은 “왜 사람들은 나의 의견을 들어주지 않지?” 하는 점이었다. 이는 슬랙(Slack)의 플랫폼 팀에서 처음 작업을 시작했을 때 특히 그러했다. 나는 슬랙의 API가 토큰을 사용하고 있는 점을 변경하여 보안을 강화하고, 제품 개발팀 전체에 걸쳐 일관된 개발 과정을 유지하도록 개선하고 싶었다. 그러나 몇 달 동안, 나의 제안이 많은 이들의 시간을 보다 가치있게 활용할 수 있는 방법이라고 PM이나 팀원들을 설득하는 것은 불가능했다.&lt;/p&gt;
&lt;p&gt;이후로도 몇 차례 나의 의견은 받아들여지지 않고, 같은 팀 수석 엔지니어들의 의견이 채택되는 것을 지켜보면서 내게 무언가 빠진 요소가 있다는 것을 알게 되었는데, 그것은 바로 ‘리더십’이었다. 나는 매일같이 키보드에만 코를 박고 있으면 안되는 것이었다. 내가 성장하기를 원한다면, 다른 사람들이 나와 동등한 수준으로 기여할 수 있도록 도움을 주어야 했던 것이다. 나는 리더십을 통해 나의 영향력을 키워야 할 필요가 있었다. &lt;/p&gt;
&lt;p&gt;이 글을 통해 필자 스스로가 리더십에 대해 배운 점과, 개발자 리더십의 절차(Path)에 대해 이야기해 보고자 한다. &lt;/p&gt;
&lt;h2 id="자기-자신을-리딩하기"&gt;&lt;a href="#자기-자신을-리딩하기" class="headerlink" title="자기 자신을 리딩하기"&gt;&lt;/a&gt;자기 자신을 리딩하기&lt;/h2&gt;&lt;p&gt;슬랙의 엔지니어로 지내면서, 나는 관리(management)와 리더십(leadership)이 어떻게 다른지 이해하게 되었다. &lt;/p&gt;
&lt;p&gt;관리자(manager)는 자신의 보고서에 대한 책임이 있다. 관리자들은 코칭과 구조화를 통해 좋은 팀을 구축하는 것에 중점을 둔다. 또한 팀의 성장을 위해 성과를 관리한다. &lt;/p&gt;
&lt;p&gt;관리자(manager)는 종종 리더(leader)를 겸임하지만, 리딩은 사실 다른 누구라도 할 수 있는 별개의 것이다. 리딩은 권위에 의존하는 무언가가 아니라, 다른 사람에게 미치는 영향력에 대한 것이다. 리딩은 비전에 대해 소통하고, 비전을 실현하기 위해 다른 이들에게 힘을 실어주는 것이다.&lt;/p&gt;
&lt;p&gt;당신은 다른 이들을 리드하기 전에, 먼저 당신 자신을 리드할 수 있어야 한다. 자신을 리딩하는 것은 타인을 리드하거나, 조직을 리드하기 전에 반드시 먼저 선행되어야 한다. 자신을 리딩한다는 개념은 다양한 분야와 기업에서 정리한 여러 리더십의 정의들에서 찾아볼 수 있다. &lt;/p&gt;
&lt;p&gt;자기 자신을 리딩하는 것은 그 사람의 우수한 역량과 밀접한 관련이 있다. 모범적인 자세를 통해 드러나는 리더십은 타인에게 자극을 주는 가장 강력한 방법이기 때문이다. 자신을 리딩한다는 말은 늘 최선을 다해서 개인의 업무를 수행하고, 스스로가 만들어내는 결과물의 품질에 대해 책임을 지는 것을 의미한다. &lt;/p&gt;
&lt;p&gt;자기 자신에게 성공적인 리더십을 발휘하기 위한 다섯하기 요소는 방향 맞추기, 전문가 되기, 공유하기, 일관되게 실행하기, 효과적인 의사소통하기 이다. &lt;/p&gt;
&lt;h2 id="방향-맞추기-Finding-Alignment"&gt;&lt;a href="#방향-맞추기-Finding-Alignment" class="headerlink" title="방향 맞추기(Finding Alignment)"&gt;&lt;/a&gt;방향 맞추기(Finding Alignment)&lt;/h2&gt;&lt;img src="/devnote/2018/11/테크니컬-리더십-시작하기/01.jpg" alt="“Surya Namaskara” by Indian Navy licensed under Creative Commons." title="“Surya Namaskara” by Indian Navy licensed under Creative Commons."&gt;
&lt;p&gt;직장에서 우수함을 나타내려면 먼저, 팀을 이해해야 하고, 회사를 이해해야 한다. &lt;/p&gt;
&lt;p&gt;‘원칙’이란 어떤 행동이 바람직한지, 혹은 바람직하지 않은지를 안내하는 회사의 규범을 말한다. 대개는 이런 원칙들이 명확하게 규정되지 않은 경우도 많은데, 이런 숨은 원칙을 잘 찾아내는 것 역시 개인의 몫이다. 이 원칙들은 당신의 나침반과도 같다. 원칙들은 당신이 회사의 목표와 가치에 맞는 결정을 내리는데 큰 도움을 줄 것이다. &lt;/p&gt;
&lt;p&gt;슬랙에서의 예를 들어보면, 우리는 슬랙의 사용자들에게 매우 뛰어난 사용 경험을 제공하고 있다는 믿음이 있다. 어떤 고객이 슬랙의 핵심 기능 중의 하나가 망가졌다는 제보를 한다면, 나에게는 그 즉시 내가 하고 있던 일을 모두 멈추고 현상을 확인해 즉시 문제를 해결하는 것이 가장 중요하다. 하지만 다른 회사에서는 내가 하던 일을 내팽개치는 것이 완전히 잘못된 판단이 될 수도 있는 것이다. &lt;/p&gt;
&lt;p&gt;대부분의 결정은 여러가지 가치를 두고 다각도로 고민하면서 내려져야 한다. 오늘은 그동안 쌓아둔 기술 부채를 해결하는데 시간을 쓸 것인가? 아니면 좀 더 미루고 내일의 작업을 위한 기반작업을 할 것인가? 버그를 잡는 것, 툴을 만드는 것, 새로운 기능을 개발하는 것이 더 중요하진 않은가? 직장에서 할애할 수 있는 총 시간과 에너지의 양은 제한되어 있다. 회사가 중요하게 생각하는 것과 개인이 노력을 기울이는 방향을 동일하게 맞출 때 당신의 기여도는 가장 최대의 효율을 발휘할 것이다. &lt;/p&gt;
&lt;p&gt;방향성 맞추기는 단지 회사가 당신에게 바라는 일을 수행하는 것만을 뜻하지 않는다. 여러분들은 리더로서 여러가지 문제를 직면하고, 이를 해결하기 위한 (숨어있는) 솔루션을 제시할 숱한 기회들을 마주하게 될 것이다. 하지만 그 때마다 다른 동료들에게 이것이 왜 문제이며, 왜 이를 해결하기 위해 에너지를 써야 하는가를 납득시키기 위해서는 먼저 회사가 무엇을 중요하게 생각하는지를 이해하고 다른사람에게 잘 설명할 수 있어야 한다. &lt;/p&gt;
&lt;h2 id="전문가-되기-Become-an-Expert"&gt;&lt;a href="#전문가-되기-Become-an-Expert" class="headerlink" title="전문가 되기(Become an Expert)"&gt;&lt;/a&gt;전문가 되기(Become an Expert)&lt;/h2&gt;&lt;p&gt;전문가가 되는 것은 개인 스킬을 연마하는 것에 관한 이야기다. 잠재력을 가진 상태라는 것이 하나의 좋은 자질일 순 있겠지만, 그걸로는 충분하지 않다. 리더는 실제로 뛰어난 전문가(export)여야 한다. 콜로라도 대학의 앤더스 에릭슨 교수에 따르면, 전문가가 되기 위해서는 평균 10년 이상 &lt;a href="https://hbr.org/2007/07/the-making-of-an-expert" target="_blank" rel="external"&gt;높은 수준의 의식적인 노력을 10,000시간 이상 기울여야 한다&lt;/a&gt;고 말한다.&lt;/p&gt;
&lt;p&gt;사람들은 종종 내가 오페라를 불렀던 경험이 소프트웨어 공학 경력에 도움이 되는지를 묻곤한다. 맞다! 음악을 통해서 나는 스스로의 마음가짐을 발전시킬 수 있었다. 아리아를 연습할 때면 가장 자신 없는 파트를 제일 자신있는 파트만큼의 자연 스러운 소리가 나올 때까지 몇시간이고 반복해서 연습했다. 소프트웨어 공학도 이것과 똑같다. 우리는 자신이 취약한 부분을 개발하는데 더욱 많은 시간을 투자해야 한다.&lt;/p&gt;
&lt;p&gt;숙련을 쌓는 방법에 지름길이란 없다. 다만 꾸준하고 의식적인 노력으로 개발시키는 것 뿐이다. 내 자신에게(그리고 당신 주변의 사람들에게) 질문을 던져보자: 내가 가장 크게 성장할 수 있는 분야는 무엇인가? 전문가가 되기 위해서 나는 어떤 스킬을 개발해야 하는가?&lt;/p&gt;
&lt;p&gt;당신이 개발하기 원하는 많은 스킬들이 있을 수 있지만, 노력을 기울이기 전에 먼저 다음의 질문을 던져보기를 권장한다: 그 스킬은 회사가 추구하는 방향에 부합하는가? 그 스킬은 나의 개인적인 목표에도 부합하는가?&lt;/p&gt;
&lt;p&gt;‘아직 아무것도 이룬 것이 없다’는 생각만 하고 있을 게 아니라 매일 꾸준히 지식과 스킬을 체득하고자 노력하는 과정이 필요하다. 누구나 태어날 때부터 전문가였던 사람은 없다. &lt;/p&gt;
&lt;h2 id="공유하기-Share"&gt;&lt;a href="#공유하기-Share" class="headerlink" title="공유하기(Share)"&gt;&lt;/a&gt;공유하기(Share)&lt;/h2&gt;&lt;p&gt;자기 자신을 리딩하는 과정이 지나면, 다른 사람을 리드할 기회가 주어지고, 당신의 동료들이 최고의 성과를 내도록 역할을 부여하게 된다. 이를 성공적으로 수행하기 위해서는 먼저 지식을 공유해야 한다. &lt;/p&gt;
&lt;p&gt;스킬을 습득하기 위해 많은 개인 시간을 소비한 후라면 선뜻 지식을 공유하는 것이 쉽지 않을 수도 있다. 특별한 전문성을 혼자만 “소유”하고 싶은 것은 본능적인 생각이다. 전문 지식은 체득 과정의 노력이 보이지 않을 땐 마치 마술처럼 느껴질 수도 있다. 당신은 혼자만의 마법을 비밀 상자에 숨겨놓고 외딴 곳에 보관하고 있다가 필요할 때만 꺼내서 사용하고 싶어할 수 있다. 다른 사람들은 그걸 어떻게 하는지 모르기 때문에, 당신만의 전문성은 여전히 마법을 유지하게 될 것이다. &lt;/p&gt;
&lt;p&gt;하지만 바로 이 부분이 핵심이다. 당신의 노하우를 혼자만 알고 있으면 동료들은 당신에게 의존하게 되고, 결국 동료들의 성장을 방해하는 셈이 된다. 당신 스스로도 새로운 일을 배우는 것을 불안하다고 여기게 되어, 자신의 성장마저 방해하는 셈이 된다. 당신은 동료들이 팀에 기여하는 것을 막고 있으며, 팀을 아주 적극적으로 망치고 있는 셈이다. &lt;/p&gt;
&lt;p&gt;나도 내가 가진 정보를 혼자만 유지하곤 했는데, 일부러 숨기고자 해서 그랬다기 보다는 이것이 유익한 정보인지 깨닫지 못했던 경우였다. 예를 들어, 나의 프로젝트에서는 업무의 진행을 방해하는 일반적인 문제점들에 대해 탐구하고 정리해왔다: 킥오프, 최종 마일스톤, 회귀 없는 릴리즈 같은 것들(역주: 예시의 내용들이 무엇을 말하는지는 잘 모르겠습니다). 나는 주위 동료들도 함께 성공했으면 하는 마음에 내가 유지하던 정보들 중 다른 팀들과 공유할 수 있는 기술들을 분류하기 시작했다. 사실 내 프로젝트만 잘 돌아가면 상관 없는 일이었지만.. 그것은 추가 확장이 없는 x1배의 영향력이다. 허나 이런 정보들은 모든 팀들에게 적용 가능한 것들이었고, 이것은 xN 배의 영향력을 발휘하게 된다.&lt;/p&gt;
&lt;p&gt;지식을 숨기는 대신 공유하라. 멘토링이나 페어 프로그래밍 같은 1:1 방식도 좋고, 프레젠테이션이나 문서화 같은 1:N 방식도 좋다. 당신이 배운 사실을 다른 사람들에게도 가르쳐라. 그럼 다른 사람들은 다시 그 다음 사람들을 가르칠 것이다. 당신은 다시 배우고자 하는 그 다음 스킬로 자유롭게 이동할 수 있다. 지식이란 마르지 않는 샘이다. 아무리 배워도 항상 더 많이 남아있다. &lt;/p&gt;
&lt;img src="/devnote/2018/11/테크니컬-리더십-시작하기/02.jpeg" alt="by Nguyen Hung Vu licensed under Creative Commons." title="by Nguyen Hung Vu licensed under Creative Commons."&gt;
&lt;h2 id="일관되게-실행하기-Execute-Consistently"&gt;&lt;a href="#일관되게-실행하기-Execute-Consistently" class="headerlink" title="일관되게 실행하기(Execute Consistently)"&gt;&lt;/a&gt;일관되게 실행하기(Execute Consistently)&lt;/h2&gt;&lt;p&gt;일전에 나의 관리자와 나눴던 대화가 기억난다. 나는 관리자에게 최근의 프로젝트에서 내가 매우 뛰어난 성과를 기록했다고 말하고, 내가 언제쯤 승진할 수 있느냐고 질문했다. 그는 현명하게 대답했다: “당신은 이번과 같은 좋은 성과를 일관되고 꾸준하게 달성할 수 있음을 증명해야 합니다.”&lt;/p&gt;
&lt;p&gt;일관성. 그것은 일시적인 운과 리더십의 차이를 말해준다.&lt;/p&gt;
&lt;p&gt;당신이 어느 한가지 일을 딱 한 번 잘해냈다는 것은 별로 중요하지 않다. 정말 중요한 것은 당신이 그 일을 다시, 또 다시, 그리고 또 다시 잘 해낼 수 있는가 하는 것이다. &lt;/p&gt;
&lt;p&gt;일관성 있는 실행력을 갖기 위해서는, 다양한 규모와 유형의 여러가지 프로젝트를 해봐야 할 것이다. 작은 규모, 큰 규모, 복합적인 기능, 사용자 친화적 UX, 백엔드 솔루션 등등. 이러한 경험들에서 당신은 다양한 도전 과제를 마주하고 해결 방안들을 개발하게 된다. 당신의 약점이 무엇인지를 드러내주고 당신이 스킬을 연마하도록 도울것이다.&lt;/p&gt;
&lt;p&gt;당신의 관리자에게, 당신이 익히려고 하는 기술들을 미리 공유하라. 앞으로 맡게 될 프로젝트를 주시하고 그 중에 자신이 흥미가 가는 부분이 무엇이며 왜 그렇게 생각하는지를 관리자에게 미리 알려라. 당신이 지금 프로젝트를 진행중이라면, 작업하는 동안 나는 어떤 스킬을 선정해 발전시켜갈 것인가에 대해 생각하라. 이것은 직장에서의 시간을 최대의 효율로 활용하는데 큰 도움을 줄 것이다. &lt;/p&gt;
&lt;p&gt;때로는 당신이 크게 열정을 느끼지 못하지만 팀의 임무에는 중요한(mission-critical)일에 배정이 될 때도 있다. 당신은 이 또한 잘 해낼 수 있음을 증명해야 한다. &lt;/p&gt;
&lt;p&gt;일관되게 실행하는 것은 개인의 브랜드를 개발시키고 동료들에게 신뢰를 쌓을 수 있는 방법이다. 신뢰감을 형성하고 키우는 데에는 많은 시간과 경험이 필요하다. 하룻밤 만에 만들어지지 않는다. 한 번 신뢰를 얻었다 하더라도 지속적인 노력이 뒤따라야만 이를 오래도록 유지할 수 있다. &lt;/p&gt;
&lt;h2 id="효과적인-의사소통하기-Communicate-Effectively"&gt;&lt;a href="#효과적인-의사소통하기-Communicate-Effectively" class="headerlink" title="효과적인 의사소통하기(Communicate Effectively)"&gt;&lt;/a&gt;효과적인 의사소통하기(Communicate Effectively)&lt;/h2&gt;&lt;p&gt;“왜 사람들이 내 말을 들어주지 않는거야?” 하고 궁금해 한 적이 있는가?&lt;/p&gt;
&lt;p&gt;나는 신입일 때 여러 차례 위와 같은 질문을 하곤 했다. 그러던 어느날 문득 내가 성장의 준비가 되었을 즈음에, 사장님이 중요한 단서를 주었다: 나는 동료들에게 부정적인 성향으로 인식되고 있었다는 점이다. 처음엔 그 피드백을 듣고 기분이 상했다. 하지만 이것이 나의 경력에서 중요한 전환점이 되었다. 그 후로 나는 ‘목소리’ 코치와 함께 일하게 되었고, 효과적인 커뮤니케이션의 중요한 비밀을 깨닫게 되었다. 그것은 경청(listening)이다.&lt;/p&gt;
&lt;p&gt;경청이란 단순히 정보를 받아들이는 것이 아니다. 경청은 정보와 함께 그것의 맥락을 모두 합쳐 하나의 덩어리로 합성하는 것이다. 경청은 상대방의 의견이 어디에서 왔는지를 이해하고, 더 깊은 이해를 얻기 위해 명확한 질문을 던지는 것을 말한다. 이 합성의 듣기는 효과적인 커뮤니케이션의 가장 기본임과 동시에, 당신이 말하고자 하는 아이디어에도 엄청난 힘을 실어준다 - 믿거나 말거나.&lt;/p&gt;
&lt;div class="twitter-wrapper"&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;a href="https://twitter.com/sarahmei/status/862584755849539584" target="_blank" rel="external"&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;script async defer src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;blockquote&gt;
&lt;p&gt;레벨이 올라감에 따라 관리자 트랙과 엔지니어 트랙에게는 모두 동일한 의사소통 기술이 요구됩니다. 각 트랙의 진정한 능력자들이 서로 다른 트랙의 능력자를 존재할 수 있게 만듭니다. - Sarah Mei&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;효과적인 의사소통의 또 다른 측면은 적절한 맥락으로 반복하는 것이다. 사람들이 왜 내 말에 귀기울이지 않는지 몰랐을 때의 나는 했던 말을 다시 반복해야 할 때면 화를 내면서 말했다. &lt;/p&gt;
&lt;p&gt;나중에서야 효과적인 의사소통의 고수들을 관찰하기 시작했다. 그들은 다방면으로 정보를 노출한다. 적절한 시간 간격을 두고 반복적으로 정보를 전달하고, 듣는 사람이 누군가에 따라 그에 맞는 다양한 세부 정보들을 제공한다.&lt;/p&gt;
&lt;p&gt;정보를 듣고 종합하고, 효과적으로 공유하는 방법을 익히는 것은 직급에서 오는 권위에 의존하지 않고 사람들에게 영향을 미치는 기본적 기술이다. 모두가 하나의 비전을 바라하도록 사람들을 모으기 위해서는 이러한 영향력이 필요하다.&lt;/p&gt;
&lt;p&gt;. . . &lt;/p&gt;
&lt;p&gt;소프트웨어 엔지니어로 일을 시작할 때, 왜 나의 아이디어가 회사에서-그리고 업계에서-잘 받아들여지지 않는 것인가를 궁금해했다. 그러던 중 컴퓨터만 골똘히 들여다보던 시선을 잠시 벗어나, 주변의 훌륭한 동료들을 만나보게 되면서 깨달았다. 내가 생각하는 방향성을 다른 사람들이 함께 공감하고, 실현하기 위해 같이 노력하도록 동기부여할 수 있다면 훨씬 더 큰 영향력을 미칠 수 있다는 것을.&lt;/p&gt;
&lt;p&gt;리더십에 관해서는 배워야 할 것이 많고, 필자 개인적으로는 더 많은 것들을 배워야 한다. 리더급 개발자가 되고자 한다면, 먼저 자기 자신을 리딩하는 것부터 시작하기를 권한다. 이 외에 당신이 찾아낸 리더십에 대해 내게도 알려주길 바란다!&lt;/p&gt;
&lt;img src="http://feeds.feedburner.com/~r/florist_devnote/~4/G1fKMCddJOU" height="1" width="1" alt=""/&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;예전에 트위터 하다가 읽었던 글인데, 개인적으로 마음에 들어서 부족하게나마 번역해 보았습니다.&lt;br&gt;원문은 슬랙 개발 블로그의 &lt;a href="https://slack.engineering/technical-leadership-getting-st
    
    </summary>
    
    
      <category term="리더십" scheme="http://leafbird.github.io/devnote/tags/%EB%A6%AC%EB%8D%94%EC%8B%AD/" />
    
  <feedburner:origLink>http://leafbird.github.io/devnote/2018/11/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%A6%AC%EB%8D%94%EC%8B%AD-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/</feedburner:origLink></entry>
  
  <entry>
    <title>C++ 코드 정리 자동화 - 3. pch 사이즈 확인, #include 순서정리</title>
    <link href="http://feedproxy.google.com/~r/florist_devnote/~3/FRx0mzP5YJY/" />
    <id>http://leafbird.github.io/devnote/2014/09/cleanup-cpp-project-3rd/</id>
    <published>2014-09-30T06:17:15.000Z</published>
    <updated>2017-08-18T13:57:56.723Z</updated>
    
    <content type="html">&lt;h2 id="pch-파일-사이즈"&gt;&lt;a href="#pch-파일-사이즈" class="headerlink" title="pch 파일 사이즈"&gt;&lt;/a&gt;pch 파일 사이즈&lt;/h2&gt;&lt;p&gt;팀에서 만지는 코드에서는, 290Mb에 육박하는 pch파일을 본 적이 있다(…) 그 땐 코드를 정리하면서 pch 사이즈 변화를 자주 확인해봐야 했는데, 탐색기나 커맨드 창에서 매번 사이즈를 조회하기가 불편했던 기억이 있어서 pch 사이즈 확인하는 걸 만들어봤다.&lt;/p&gt;
&lt;p&gt;MSBuild로 단일 cpp 파일을 컴파일하면 이런 메시지가 나오는데,&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\bin\amd64\CL.exe /c /ID:\Dev\uni\External\ /ID:\Dev\uni\Test\ /ID:\Dev\uni\ /Zi /nologo /W4 /WX /sdl /Od /D WIN32 /D _DEBUG /D _CONSOLE /D _LIB /D _UNICODE /D UNICODE /Gm /EHsc /RTC1 /MDd /GS /fp:precise /Zc:wchar_t /Zc:forScope /Yc&amp;quot;stdafx.h&amp;quot; /Fp&amp;quot;x64\Debug\unittest.pch&amp;quot; /Fo&amp;quot;x64\Debug\\&amp;quot; /Fd&amp;quot;x64\Debug\vc120.pdb&amp;quot; /Gd /TP /errorReport:queue stdafx.cpp&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;여기 &lt;code&gt;cl.exe&lt;/code&gt;로 들어가는 인자 중에 &lt;code&gt;/Fp&amp;quot;x64\Debug\unittest.pch&amp;quot;&lt;/code&gt; 요 부분에 pch 경로가 있음. 그러니까 결국 툴에서 pch사이즈를 구하려면&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;프로젝트 리빌드하고&lt;/li&gt;
&lt;li&gt;pch 생성 헤더를 cl.exe로 컴파일하면서 /Fp 스위치를 읽어 경로 파악.&lt;/li&gt;
&lt;li&gt;위에서 새로 생성된 pch파일의 사이즈를 확인.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;… 해주면 된다.&lt;/p&gt;
&lt;h2 id="include-순서-자동-정렬"&gt;&lt;a href="#include-순서-자동-정렬" class="headerlink" title="#include 순서 자동 정렬"&gt;&lt;/a&gt;#include 순서 자동 정렬&lt;/h2&gt;&lt;p&gt;구글의 C++ 스타일 가이드 문서 중에 &lt;a href="http://jongwook.github.io/google-styleguide/trunk/cppguide.xml#include%EC%9D%98_%EC%9D%B4%EB%A6%84%EA%B3%BC_%EC%88%9C%EC%84%9C" target="_blank" rel="external"&gt;include 의 이름과 순서&lt;/a&gt; 항목에 보면 헤더 인클루드에 몇가지 카테고리와 순서를 정해 두었는데, &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;주된 목적이 dir2/foo2.h에 있는 것들을 구현하거나 테스트하기 위한 dir/foo.cc나 dir/foo_test.cc에서 include를 아래처럼 순서에 따라 배열하라.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;dir2/foo2.h (아래 설명 참조).&lt;/li&gt;
&lt;li&gt;C 시스템 파일&lt;/li&gt;
&lt;li&gt;C++ 시스템 파일&lt;/li&gt;
&lt;li&gt;다른 라이브러리의 .h 파일&lt;/li&gt;
&lt;li&gt;현재 프로젝트의 .h 파일&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;팀에서 정한 컨벤션도 이 규칙을 그대로 따라야 해서.. 매번 코딩할 때마다 인클루드 순서에 신경쓰기 싫어서 자동화 처리를 작성. 더불어 경로 없이 파일명만 적은 경우나 상대경로를 사용한 인클루드도 지정된 path를 모두 적어주도록 컨버팅하는 처리도 만듦. 만드는 과정이야 대단한 건 없다. sln, vcxproj파일 파싱하는 것은 만들어 두었으니, 그냥 스트링 처리만 좀 더 해주면 금방 만들어진다. 툴로 sorting하고나면 아래처럼 만들어줌.&lt;/p&gt;
&lt;figure class="highlight cpp"&gt;&lt;figcaption&gt;&lt;span&gt;TestCode.cpp&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;div class="line"&gt;1&lt;/div&gt;&lt;div class="line"&gt;2&lt;/div&gt;&lt;div class="line"&gt;3&lt;/div&gt;&lt;div class="line"&gt;4&lt;/div&gt;&lt;div class="line"&gt;5&lt;/div&gt;&lt;div class="line"&gt;6&lt;/div&gt;&lt;div class="line"&gt;7&lt;/div&gt;&lt;div class="line"&gt;8&lt;/div&gt;&lt;div class="line"&gt;9&lt;/div&gt;&lt;div class="line"&gt;10&lt;/div&gt;&lt;div class="line"&gt;11&lt;/div&gt;&lt;div class="line"&gt;12&lt;/div&gt;&lt;div class="line"&gt;13&lt;/div&gt;&lt;div class="line"&gt;14&lt;/div&gt;&lt;div class="line"&gt;15&lt;/div&gt;&lt;div class="line"&gt;16&lt;/div&gt;&lt;div class="line"&gt;17&lt;/div&gt;&lt;div class="line"&gt;18&lt;/div&gt;&lt;div class="line"&gt;19&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;div class="line"&gt;&lt;span class="meta"&gt;#&lt;span class="meta-keyword"&gt;include&lt;/span&gt; &lt;span class="meta-string"&gt;"stdafx.h"&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="meta"&gt;#&lt;span class="meta-keyword"&gt;include&lt;/span&gt; &lt;span class="meta-string"&gt;"TestAsset/ProjRoot/TestCode.h"&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="comment"&gt;// system headers&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="meta"&gt;#&lt;span class="meta-keyword"&gt;include&lt;/span&gt; &lt;span class="meta-string"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="comment"&gt;// other project's headers&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="meta"&gt;#&lt;span class="meta-keyword"&gt;include&lt;/span&gt; &lt;span class="meta-string"&gt;"TestAsset/OuterProject.h"&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="meta"&gt;#&lt;span class="meta-keyword"&gt;include&lt;/span&gt; &lt;span class="meta-string"&gt;"TestAsset/OuterProjectX.h"&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="comment"&gt;// inner project's headers&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="meta"&gt;#&lt;span class="meta-keyword"&gt;include&lt;/span&gt; &lt;span class="meta-string"&gt;"TestAsset/ProjRoot/InterProject.h"&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="meta"&gt;#&lt;span class="meta-keyword"&gt;include&lt;/span&gt; &lt;span class="meta-string"&gt;"TestAsset/ProjRoot/InterProjectA.h"&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="meta"&gt;#&lt;span class="meta-keyword"&gt;include&lt;/span&gt; &lt;span class="meta-string"&gt;"TestAsset/ProjRoot/InterProjectB.h"&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="meta"&gt;#&lt;span class="meta-keyword"&gt;include&lt;/span&gt; &lt;span class="meta-string"&gt;"TestAsset/ProjRoot/InterProjectC.h"&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="function"&gt;&lt;span class="keyword"&gt;void&lt;/span&gt; &lt;span class="title"&gt;main&lt;/span&gt;&lt;span class="params"&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class="line"&gt;  &lt;span class="keyword"&gt;return&lt;/span&gt;;&lt;/div&gt;&lt;div class="line"&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id="epilog"&gt;&lt;a href="#epilog" class="headerlink" title="epilog"&gt;&lt;/a&gt;epilog&lt;/h2&gt;&lt;p&gt;대충 이정도 돌아가는 툴을 만들어서 개인 pc에 셋팅해둔 jenkins에 물려놓고 사용중. 원래는 필요없는 include찾아주는 기능만 만들려다가 include sorting 기능은 그냥 한 번 추가나 해볼까 싶어 넣은건데, 아주 편하다. 코딩할 땐 순서 상관 없이 상대경로로 대충 넣어놓고 툴을 돌리면 컨벤션에 맞게 예쁘게 수정해준다.&lt;/p&gt;
&lt;p&gt;불필요 인클루드를 찾는 동작은 회사 코드 기준으로 컨텐츠 코드 전체 검색시 50분 정도 걸리는 듯. 이건 매일 새벽에 jenkins가 한 번씩 돌려놓게 해놓고, 매일 아침에 출근해서 확인한다.&lt;/p&gt;
&lt;p&gt;pch사이즈는 baseline 구축을 생각하고 만들어 본건데.. (박일, &lt;a href="http://www.slideshare.net/parkpd/in-ndc2010" target="_blank" rel="external"&gt;사례로 살펴보는 디버깅&lt;/a&gt; 참고) baseline을 만들려면 지표들을 좀 더 모아야 하고, db도 붙여야 하니 이건 제대로 만들려면 시간이 필요할 것 같다(..라고 쓰고 ‘더이상 업데이트 되지 않는다’ 라고 읽는다.)&lt;/p&gt;
&lt;h3 id="그리고-C"&gt;&lt;a href="#그리고-C" class="headerlink" title="그리고 C#."&gt;&lt;/a&gt;그리고 C#.&lt;/h3&gt;&lt;p&gt;C#은 재미있다. 이번에 툴 만들때도 한참 빠져들어서 재미있게 만들었다. Attribute를 달아서 xml 파일을 자동으로 로딩하는 처리를 만들어 보았는데, cpp에서 하기 힘든 깔끔한 이런 가능성들이 마음에 든다. 규모 큰 프로젝트는 안해봐서 모르겠지만 개인적으로 가지고 놀기에는 제일 맘에 듬. 디버깅 하기 좋고 코드 짜기도 좋고.&lt;/p&gt;
&lt;h3 id="Visual-Stuio-Online"&gt;&lt;a href="#Visual-Stuio-Online" class="headerlink" title="Visual Stuio Online"&gt;&lt;/a&gt;Visual Stuio Online&lt;/h3&gt;&lt;p&gt;코드 관리를 &lt;a href="http://www.visualstudio.com/en-us/products/what-is-visual-studio-online-vs.aspx" target="_blank" rel="external"&gt;visual studio online&lt;/a&gt;에서 해봤다. 비공개 코드는 주로 개인 Nas나 bitbucket에 올려놓는데, VS IDE에서 링크가 있길래 한 번 눌러봤다가 한 번 써봄.&lt;br&gt;bitbucket보다 좀 더 많은 기능이 있다. 빌드나 단위테스트를 돌려볼 수 있고(하지만 유료), backlog, splint관리용 보드가 좀 더 디테일하다. 개인 코딩 말고 팀을 꾸려서 작업을 한다면 한 번 제대로 사용해 보는 것을 고려해 볼 순 있겠으나… 왠지 그냥 마음이 안간다. 나같으면 그냥 github 유료 결제해서 쓸 거 같애 ‘ㅅ’)&lt;/p&gt;
&lt;p&gt;이제 이건 고마하고 다음 toy project로 넘어가야지.&lt;/p&gt;
&lt;img src="http://feeds.feedburner.com/~r/florist_devnote/~4/FRx0mzP5YJY" height="1" width="1" alt=""/&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id="pch-파일-사이즈"&gt;&lt;a href="#pch-파일-사이즈" class="headerlink" title="pch 파일 사이즈"&gt;&lt;/a&gt;pch 파일 사이즈&lt;/h2&gt;&lt;p&gt;팀에서 만지는 코드에서는, 290Mb에 육박하는 pch파일을 본 적이
    
    </summary>
    
    
      <category term="c++" scheme="http://leafbird.github.io/devnote/tags/c/" />
    
  <feedburner:origLink>http://leafbird.github.io/devnote/2014/09/cleanup-cpp-project-3rd/</feedburner:origLink></entry>
  
  <entry>
    <title>C++ 코드 정리 자동화 - 2. 불필요한 #include 찾기 下</title>
    <link href="http://feedproxy.google.com/~r/florist_devnote/~3/S-tfACcGhjw/" />
    <id>http://leafbird.github.io/devnote/2014/09/cleanup-cpp-project-2nd/</id>
    <published>2014-09-17T11:30:24.000Z</published>
    <updated>2017-08-21T12:50:14.260Z</updated>
    
    <content type="html">&lt;p&gt;이전 포스트 ‘&lt;a href="/devnote/2014/09/claenup-cpp-project-1st/" title="C++ 코드 정리 자동화 - 1. 불필요한 #include 찾기 上"&gt;C++ 코드 정리 자동화 - 1. 불필요한 #include 찾기 上&lt;/a&gt;‘ 에서 이어진다.&lt;/p&gt;
&lt;h2 id="지워도-되는-인클루드를-찾아냈다"&gt;&lt;a href="#지워도-되는-인클루드를-찾아냈다" class="headerlink" title="지워도 되는 인클루드를 찾아냈다"&gt;&lt;/a&gt;지워도 되는 인클루드를 찾아냈다&lt;/h2&gt;&lt;p&gt;개별 파일 하나씩을 컴파일 할 수 있다면 이제 모든 인클루드를 하나씩 삭제하면서 컴파일 가능 여부를 확인해보면 된다. 이 부분은 간단한 file seeking과 string 처리 작업일 뿐이니 굳이 부연 설명은 필요 없다. 카페에서 여유롭게 음악을 들으며 즐겁게 툴을 만들자. 뚝딱뚝딱.&lt;/p&gt;
&lt;p&gt;이정도 하고 나니 이제 vcxproj파일 경로를 주면 해당 프로젝트에 들어있는 소스코드에서 불필요한 인클루드를 색출해 위치정보를 출력해주는 물건이 만들어졌다.&lt;/p&gt;
&lt;figure class="highlight plain"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;div class="line"&gt;1&lt;/div&gt;&lt;div class="line"&gt;2&lt;/div&gt;&lt;div class="line"&gt;3&lt;/div&gt;&lt;div class="line"&gt;4&lt;/div&gt;&lt;div class="line"&gt;5&lt;/div&gt;&lt;div class="line"&gt;6&lt;/div&gt;&lt;div class="line"&gt;7&lt;/div&gt;&lt;div class="line"&gt;8&lt;/div&gt;&lt;div class="line"&gt;9&lt;/div&gt;&lt;div class="line"&gt;10&lt;/div&gt;&lt;div class="line"&gt;11&lt;/div&gt;&lt;div class="line"&gt;12&lt;/div&gt;&lt;div class="line"&gt;13&lt;/div&gt;&lt;div class="line"&gt;14&lt;/div&gt;&lt;div class="line"&gt;15&lt;/div&gt;&lt;div class="line"&gt;16&lt;/div&gt;&lt;div class="line"&gt;17&lt;/div&gt;&lt;div class="line"&gt;18&lt;/div&gt;&lt;div class="line"&gt;19&lt;/div&gt;&lt;div class="line"&gt;20&lt;/div&gt;&lt;div class="line"&gt;21&lt;/div&gt;&lt;div class="line"&gt;22&lt;/div&gt;&lt;div class="line"&gt;23&lt;/div&gt;&lt;div class="line"&gt;24&lt;/div&gt;&lt;div class="line"&gt;25&lt;/div&gt;&lt;div class="line"&gt;26&lt;/div&gt;&lt;div class="line"&gt;27&lt;/div&gt;&lt;div class="line"&gt;28&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;div class="line"&gt;작업 대상으로 1개의 프로젝트가 입력 되었습니다.&lt;/div&gt;&lt;div class="line"&gt;-------------------------------------------------&lt;/div&gt;&lt;div class="line"&gt;Service : 프로젝트 정리.&lt;/div&gt;&lt;div class="line"&gt;Service : PCH 생성.&lt;/div&gt;&lt;div class="line"&gt;컴파일 : stdafx.cpp ... 성공. 걸린 시간 : 1.04초&lt;/div&gt;&lt;div class="line"&gt;Client.cpp의 인클루드를 검사합니다.&lt;/div&gt;&lt;div class="line"&gt; - process #1 Client.cpp (1/2) ... X&lt;/div&gt;&lt;div class="line"&gt; - process #1 Client.cpp (2/2) ... X&lt;/div&gt;&lt;div class="line"&gt;ClientAcceptor.cpp의 인클루드를 검사합니다.&lt;/div&gt;&lt;div class="line"&gt; - process #1 ClientAcceptor.cpp (1/2) ... 컴파일 가능!&lt;/div&gt;&lt;div class="line"&gt; - process #1 ClientAcceptor.cpp (2/2) ... X&lt;/div&gt;&lt;div class="line"&gt;ClientConnection.cpp의 인클루드를 검사합니다.&lt;/div&gt;&lt;div class="line"&gt; - process #1 ClientConnection.cpp (1/3) ... X&lt;/div&gt;&lt;div class="line"&gt; - process #1 ClientConnection.cpp (2/3) ... X&lt;/div&gt;&lt;div class="line"&gt; - process #1 ClientConnection.cpp (3/3) ... X&lt;/div&gt;&lt;div class="line"&gt;Start.cpp의 인클루드를 검사합니다.&lt;/div&gt;&lt;div class="line"&gt; - process #1 Start.cpp (1/4) ... X&lt;/div&gt;&lt;div class="line"&gt; - process #1 Start.cpp (2/4) ... X&lt;/div&gt;&lt;div class="line"&gt; - process #1 Start.cpp (3/4) ... X&lt;/div&gt;&lt;div class="line"&gt; - process #1 Start.cpp (4/4) ... X&lt;/div&gt;&lt;div class="line"&gt;ThreadEntry.cpp의 인클루드를 검사합니다.&lt;/div&gt;&lt;div class="line"&gt; - process #1 ThreadEntry.cpp (1/1) ... X&lt;/div&gt;&lt;div class="line"&gt;-------------------------------------------------&lt;/div&gt;&lt;div class="line"&gt;Project : Service 모두 1개의 인클루드가 불필요한 것으로 의심됩니다.&lt;/div&gt;&lt;div class="line"&gt;D:\Dev\uni\World\Service\ClientAcceptor.cpp&lt;/div&gt;&lt;div class="line"&gt; - 2 line : #include &amp;quot;World/Service/Client.h&amp;quot;&lt;/div&gt;&lt;div class="line"&gt;&lt;/div&gt;&lt;div class="line"&gt;총 소요 시간 : 13.289 sec&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;이 정도 만들어서 회사에서 만들고 있는 프로젝트에 조금 돌려 보았는데, &lt;strong&gt;덕분에 꽤나 많은 불필요 인클루드를 색출해 내었다.&lt;/strong&gt; 회사 프로젝트는 덩치가 제법 크고, 아직 서비스 중이지 않은 코드여서 용감무쌍한 리팩토링이 자주 일어나기 때문에 관리가 잘 안되는 파일이 제법 있더라. 아무튼 덕을 톡톡히 보았다.&lt;/p&gt;
&lt;h2 id="튜닝-솔루션-단위로-검사할-수-있게-만들자"&gt;&lt;a href="#튜닝-솔루션-단위로-검사할-수-있게-만들자" class="headerlink" title="튜닝 : 솔루션 단위로 검사할 수 있게 만들자"&gt;&lt;/a&gt;튜닝 : 솔루션 단위로 검사할 수 있게 만들자&lt;/h2&gt;&lt;p&gt;프로젝트 파일 단위로 어느 정도 돌아가니까, 솔루션 파일 단위로도 돌릴수 있게 확장했다. sln 파일을 파싱해서 프로젝트 리스트만 얻어오면 끝나는 일이다. &lt;/p&gt;
&lt;p&gt;하지만 sln 파일은 vcxproj 파일처럼 쉽게 파싱할 수는 없다. 이녀석은 xml 포맷이 아니라, 자체적인 포맷을 가지고 있다. 사실 sln 파일을 파싱해 본 게 이번이 처음이 아닌데, 예전에는 lua를 써서 직접 노가다 파싱을 했더니 별로 재미도 없고 잘 돌아가지도 않고 코딩하는 재미도 별로 없더라. &lt;/p&gt;
&lt;figure class="highlight plain"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;div class="line"&gt;1&lt;/div&gt;&lt;div class="line"&gt;2&lt;/div&gt;&lt;div class="line"&gt;3&lt;/div&gt;&lt;div class="line"&gt;4&lt;/div&gt;&lt;div class="line"&gt;5&lt;/div&gt;&lt;div class="line"&gt;6&lt;/div&gt;&lt;div class="line"&gt;7&lt;/div&gt;&lt;div class="line"&gt;8&lt;/div&gt;&lt;div class="line"&gt;9&lt;/div&gt;&lt;div class="line"&gt;10&lt;/div&gt;&lt;div class="line"&gt;11&lt;/div&gt;&lt;div class="line"&gt;12&lt;/div&gt;&lt;div class="line"&gt;13&lt;/div&gt;&lt;div class="line"&gt;14&lt;/div&gt;&lt;div class="line"&gt;15&lt;/div&gt;&lt;div class="line"&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;div class="line"&gt; // 솔루션 파일은 이렇게 생겼다. 왜죠...&lt;/div&gt;&lt;div class="line"&gt;&lt;/div&gt;&lt;div class="line"&gt;Microsoft Visual Studio Solution File, Format Version 12.00&lt;/div&gt;&lt;div class="line"&gt;# Visual Studio 2013&lt;/div&gt;&lt;div class="line"&gt;VisualStudioVersion = 12.0.30723.0&lt;/div&gt;&lt;div class="line"&gt;MinimumVisualStudioVersion = 10.0.40219.1&lt;/div&gt;&lt;div class="line"&gt;... 중략 ...&lt;/div&gt;&lt;div class="line"&gt;Project(&amp;quot;&amp;#123;2150E333-8FDC-42A3-9474-1A3956D46DE8&amp;#125;&amp;quot;) = &amp;quot;External&amp;quot;, &amp;quot;External&amp;quot;, &amp;quot;&amp;#123;F95C61E3-AF95-4CA9-8837-A203762B2B29&amp;#125;&amp;quot;&lt;/div&gt;&lt;div class="line"&gt;EndProject&lt;/div&gt;&lt;div class="line"&gt;Project(&amp;quot;&amp;#123;8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942&amp;#125;&amp;quot;) = &amp;quot;gtest&amp;quot;, &amp;quot;External\gtest\gtest.vcxproj&amp;quot;, &amp;quot;&amp;#123;C7A81BFC-6E28-4859-A8B5-2FEA80E012B2&amp;#125;&amp;quot;&lt;/div&gt;&lt;div class="line"&gt;EndProject&lt;/div&gt;&lt;div class="line"&gt;Project(&amp;quot;&amp;#123;2150E333-8FDC-42A3-9474-1A3956D46DE8&amp;#125;&amp;quot;) = &amp;quot;Test&amp;quot;, &amp;quot;Test&amp;quot;, &amp;quot;&amp;#123;042F2157-2118-44AA-8BB9-8B5DD01FA3A9&amp;#125;&amp;quot;&lt;/div&gt;&lt;div class="line"&gt;EndProject&lt;/div&gt;&lt;div class="line"&gt;Project(&amp;quot;&amp;#123;8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942&amp;#125;&amp;quot;) = &amp;quot;unittest&amp;quot;, &amp;quot;Test\unittest.vcxproj&amp;quot;, &amp;quot;&amp;#123;24A57754-D332-4575-AEBF-2AFCBC0A7E4B&amp;#125;&amp;quot;&lt;/div&gt;&lt;div class="line"&gt;EndProject&lt;/div&gt;&lt;div class="line"&gt;... 후략 ...&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;C#으로 sln 파일을 파싱해주는 적당히 괜찮은 코드가 인터넷 어딘가에 돌아다닌다. &lt;a href="http://stackoverflow.com/questions/707107/library-for-parsing-visual-studio-solution-files" target="_blank" rel="external"&gt;이곳&lt;/a&gt;에 있는 놈을 가져다 붙였다. build configuration 같은 걸 얻어올 순 없지만 프로젝트 리스트 얻는 데에는 충분하다.&lt;/p&gt;
&lt;h2 id="튜닝-느리다-멀티-스레드로-돌리자"&gt;&lt;a href="#튜닝-느리다-멀티-스레드로-돌리자" class="headerlink" title="튜닝 : 느리다. 멀티 스레드로 돌리자"&gt;&lt;/a&gt;튜닝 : 느리다. 멀티 스레드로 돌리자&lt;/h2&gt;&lt;p&gt;한때는 툴을 만들때 lua도 써보고 python도 써봤지만 요즘은 C#만 쓰게된다. 디버깅 하기도 편하고, &lt;strong&gt;특히 멀티스레딩으로 돌리기가 너무 편하다.&lt;/strong&gt; TPL, Concurrent Collection조금 갖다 끄적거리면 금방 병렬처리된다.&lt;/p&gt;
&lt;p&gt;특히나 이런 식으로 병렬성이 좋은 툴은 훨씬 빠르게 돌릴 수 있게 된다. 커맨드 라인 인자로 &lt;code&gt;--multi-thread&lt;/code&gt;를 주면 주요 작업을 &lt;code&gt;Parallel.ForEach&lt;/code&gt;로 돌리도록 처리했다. 다만 멀티스레드로 돌리면 파일로 남기는 로그가 엉망이 되기 때문에… 단일 스레드로도 돌 수 있도록 남겨둠. &lt;/p&gt;
&lt;p&gt;이번엔 병렬처리할 때 thread-safe한 container가 필요했는데, &lt;a href="http://msdn.microsoft.com/ko-kr/library/system.collections.concurrent.aspx" target="_blank" rel="external"&gt;System.Collections.Concurrent&lt;/a&gt;에 가면 queue, stack, dictionary등 종류별로 잔뜩 들어있으니 적당한 놈으로 바로 갖다 쓰면 된다. 편하다 C#. 네이티브 코더는 그냥 웁니다 ㅠㅠ…&lt;/p&gt;
&lt;p&gt;지금 내가 가진 개인 코드 중에는 덩치큰 cpp 프로젝트가 없어서, 조그만 솔루션 하나 시험삼아 돌려봤다.&lt;/p&gt;
&lt;img src="/devnote/images/140917_00.PNG" class="center"&gt;
&lt;p&gt;87초 걸리던 것이 24초로 빨리짐. 대충 4배 가량 빨라졌다. 내일 회사에서 대빵 큰 프로젝트에 한 번 돌려봐야지. 생각하니 기대된다.&lt;/p&gt;
&lt;h2 id="More-Improvement-불필요한-전방선언-forward-declaration-색출"&gt;&lt;a href="#More-Improvement-불필요한-전방선언-forward-declaration-색출" class="headerlink" title="More Improvement : 불필요한 전방선언(forward declaration) 색출."&gt;&lt;/a&gt;More Improvement : 불필요한 전방선언(forward declaration) 색출.&lt;/h2&gt;&lt;p&gt;툴을 좀 더 확장할 수 있을거 같다. 클래스와 구조체 전방선언을 써놓고 지우지 않아서 찌꺼기가 된 부분을 이것으로 찾아낼 수 있을 것 같다. 이건 파일을 일일이 컴파일 하지 않아도 되니까 훨씬 빠르게 가능할 듯.&lt;/p&gt;
&lt;p&gt;전방선언 확인 작업도 따지고 보면 단순 string 처리니까… 시간될 때 카페에 가서 찬찬히 코딩하다보면 금방 짤 수 있겠지. cpp 파일을 write하는 작업도 없어서 read만 하면 되기 때문에 아마 병렬성도 훨씬 더 좋을 것이다.  &lt;/p&gt;
&lt;img src="http://feeds.feedburner.com/~r/florist_devnote/~4/S-tfACcGhjw" height="1" width="1" alt=""/&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;이전 포스트 ‘&lt;a href="/devnote/2014/09/claenup-cpp-project-1st/" title="C++ 코드 정리 자동화 - 1. 불필요한 #include 찾기 上"&gt;C++ 코드 정리 자동화 - 1. 불필요한 #includ
    
    </summary>
    
    
      <category term="c++" scheme="http://leafbird.github.io/devnote/tags/c/" />
    
  <feedburner:origLink>http://leafbird.github.io/devnote/2014/09/cleanup-cpp-project-2nd/</feedburner:origLink></entry>
  
  <entry>
    <title>C++ 코드 정리 자동화 - 1. 불필요한 #include 찾기 上</title>
    <link href="http://feedproxy.google.com/~r/florist_devnote/~3/-60JsN40CvM/" />
    <id>http://leafbird.github.io/devnote/2014/09/claenup-cpp-project-1st/</id>
    <published>2014-09-12T11:26:14.000Z</published>
    <updated>2017-08-18T13:54:10.551Z</updated>
    
    <content type="html">&lt;h2 id="지워도-되는-헤더-인클루드를-색출하고-싶다"&gt;&lt;a href="#지워도-되는-헤더-인클루드를-색출하고-싶다" class="headerlink" title="지워도 되는 헤더 인클루드를 색출하고 싶다"&gt;&lt;/a&gt;지워도 되는 헤더 인클루드를 색출하고 싶다&lt;/h2&gt;&lt;p&gt;매우 느리게 찔끔찔끔 진행하는 토이 프로젝트가 있는데, 오늘 처음으로 무언가 그럴싸한 아웃풋이 나오게 되어 스냅샷을 하는 느낌으로 간단히 포스팅.&lt;/p&gt;
&lt;p&gt;cpp 프로젝트 규모가 점점 커지게 되면 빌드 시간 때문에 많은 고통을 겪는다. 이때문에 &lt;a href="https://www.incredibuild.com/" target="_blank" rel="external"&gt;increadi build&lt;/a&gt; 같은 분산 빌드 솔루션도 쓰는거고 &lt;a href="http://www.slideshare.net/devcatpublications/ndc2010-unity-build" target="_blank" rel="external"&gt;unity build&lt;/a&gt; 같은 꼼수도 사용하게 되는거다. &lt;/p&gt;
&lt;p&gt;하지만 저런 솔루션들을 사용하기 이전에, 코드를 정리하는 것이 먼저 선행될 필요가 있다. cpp는 특성상 작업하다보면 소스파일에 불필요한 헤더파일의 #include가 남게되고, 이것들이 불필요한 dependency를 만들어내면서 늘어지는 빌드 시간을 무시할 수 없기 때문이다. &lt;/p&gt;
&lt;p&gt;그런데 문제는 그렇게 생긴 불필요 인클루드 구문이 무엇인지를 골라내기가 힘들다는 점이다. 프로젝트 규모가 커질수록 더욱 힘들다. c#같은 경우 불필요 using 구문을 아예 visual studio IDE가 자체적으로 정리해주기까지 하지만, cpp는 색출조차 힘들다 보니 이런 기능을 제공하는 3rd party tool도 없어 보인다. &lt;a href="http://www.wholetomato.com/downloads/spaghettiDownload.asp" target="_blank" rel="external"&gt;Whole Tomato의 Spaghetti&lt;/a&gt; 처럼 인클루드간의 관계를 그래프로 보여주는 툴은 몇 번 본 적 있다. 조낸 멋지게 그래프까지 보여주었지만 정작 불필요한 놈이 무언지 콕 짚어주는 녀석은 없음. 참으로 척박한 현실이다. &lt;/p&gt;
&lt;p&gt;그래서 한 번 직접 만들어보기로 했다. &lt;/p&gt;
&lt;h2 id="프로젝트-내의-cpp-파일을-개별-컴파일-하기"&gt;&lt;a href="#프로젝트-내의-cpp-파일을-개별-컴파일-하기" class="headerlink" title="프로젝트 내의 cpp 파일을 개별 컴파일 하기"&gt;&lt;/a&gt;프로젝트 내의 cpp 파일을 개별 컴파일 하기&lt;/h2&gt;&lt;p&gt;일단은 만들려는 툴에서, 입력으로 받은 vc 프로젝트에 포함된 cpp 파일을 개별로 컴파일 할 수 있어야 한다.&lt;br&gt;그렇게 되면 cpp 파일마다 돌면서 코드 안에 있는 #include를 직접 하나씩 제거해보면서 컴파일이 성공하는지를 확인할거다. 그러면 불필요할 것이라 예상되는 #include의 후보를 만들 수 있다. &lt;/p&gt;
&lt;p&gt;무식한 방법이다. cpu를 많이 먹을거고 시간도 오래 걸릴거다. 하지만 저렇게라도 알 수 있다면 새벽에 실행해서 리포트 뽑아놓도록 CI에 물려놓으면 그만이다.&lt;/p&gt;
&lt;p&gt;무식하기도 하지만 또한 불완전한 방법이기도 하다. 위의 동작으로 불필요 #include 후보 리스트를 만들었다고 해도,&lt;br&gt; 헤더파일 끼리의 상호 참조관계, 내부 포함 관계등이 여러 복잡한 상황을 연출하기 때문에&lt;br&gt;후보로 지목된 헤더가 실은 필요한 녀석일 수도 있다. &lt;/p&gt;
&lt;p&gt;하지만 일단은 후보 리스트 색출까지 먼저 진행해 보기로 한다.&lt;br&gt;사실 정말 확실한 불필요 #include가 색출 가능하다면 tool이 아예 코드를 코치는 것까지 자동으로 처리해 줄 수도 있을 것 같지만… 일단 나중에 생각하기로.&lt;/p&gt;
&lt;p&gt;프로젝트에 포함된 cpp 파일의 리스트를 구하는 것은 일도 아니다. vcxproj파일은 xml 형태로 되어 있으므로, &lt;code&gt;/Project/ItemGroup/ClCompile&lt;/code&gt; 경로의 xml element를 얻어와 파일 경로를 읽어내면 끝이다. &lt;/p&gt;
&lt;p&gt;그다음은 이 파일을 각각 컴파일 할 수 있어야 하는데… 이것은 생각보다 만만치가 않다. &lt;code&gt;cl.exe&lt;/code&gt;를 실행해서 컴파일 하면 되지만, &lt;code&gt;cl.exe&lt;/code&gt;의 커맨드라인 옵션으로 들어가야 하는 인자가 엄청나게 많고, 이 옵션을 vcxproj 파일에서 일일이 파싱하고 다시 조합하기란 상당히 귀찮고 짜증나는 작업이다. &lt;/p&gt;
&lt;p&gt;이 귀찮은 작업을 MSBuild에 맡겨버릴 수 있다. MSBuild에 &lt;code&gt;/t:BuildCompile&lt;/code&gt; 옵션과 &lt;code&gt;/p:SelectedFiles=xxx&lt;/code&gt;을 쓰면 vcxproj를 알아서 파싱해서 cl.exe의 커맨드라인 인자를 직접 만들어준다. &lt;/p&gt;
&lt;p&gt;이렇게 해서 일단 프로젝트 파일에 있는 cpp를 개별 컴파일 하는 것까지 성공.&lt;/p&gt;
&lt;img src="/devnote/images/140912_00.png" class="center"&gt;
&lt;p&gt;여기까지 하고 나니 cpp 파일당 컴파일 시간까지 덤으로 얻게 됨.&lt;br&gt;앗싸.&lt;/p&gt;
&lt;img src="http://feeds.feedburner.com/~r/florist_devnote/~4/-60JsN40CvM" height="1" width="1" alt=""/&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id="지워도-되는-헤더-인클루드를-색출하고-싶다"&gt;&lt;a href="#지워도-되는-헤더-인클루드를-색출하고-싶다" class="headerlink" title="지워도 되는 헤더 인클루드를 색출하고 싶다"&gt;&lt;/a&gt;지워도 되는 헤더 인클루드를 색
    
    </summary>
    
    
      <category term="c++" scheme="http://leafbird.github.io/devnote/tags/c/" />
    
  <feedburner:origLink>http://leafbird.github.io/devnote/2014/09/claenup-cpp-project-1st/</feedburner:origLink></entry>
  
  <entry>
    <title>Yoda Notation</title>
    <link href="http://feedproxy.google.com/~r/florist_devnote/~3/FbE282SbnG0/" />
    <id>http://leafbird.github.io/devnote/2014/08/yoda-notation/</id>
    <published>2014-08-19T08:08:44.000Z</published>
    <updated>2017-08-21T12:51:34.576Z</updated>
    
    <content type="html">&lt;img src="/devnote/images/yoda1.jpg" class="center"&gt;
&lt;p&gt;지난번에 &lt;a href="/devnote/2014/07/google-c-plus-plus-style-guide/" title="google c++ style guide"&gt;google c++ style guide&lt;/a&gt; 에 대해서 한참 수다를 떨었는데,&lt;br&gt;요즘에도 비슷한 주제의 책을 읽고 있습니다. 임백준씨가 번역하신 &lt;a href="http://www.yes24.com/24/goods/6692314?scode=032&amp;amp;OzSrank=1" target="_blank" rel="external"&gt;‘읽기 좋은 코드가 좋은 코드다’&lt;/a&gt; 인데요,&lt;br&gt; 이것도 가볍게 읽을 수 있는 내용이어서 빌드 시간 중간에 띄엄띄엄 읽고 있어요.  &lt;/p&gt;
&lt;p&gt;이 책을 읽다가 ‘Yoda Notation’이란 표현을 처음 접했습니다. 표현이 재미있어서 블로그에 한 번 적어봅니다. 구글링해보면 &lt;a href="http://en.wikipedia.org/wiki/Yoda_conditions" target="_blank" rel="external"&gt;Yoda Conditions&lt;/a&gt; 라고도 부르는 것 같네요. 프로그램 코드 상에서 조건문에 값 비교 구문을 적을 때 변수와 상수의 위치를 바꾸어 적는 것을 말합니다. &lt;/p&gt;
&lt;figure class="highlight cpp"&gt;&lt;figcaption&gt;&lt;span&gt;May the force be with you.&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;div class="line"&gt;1&lt;/div&gt;&lt;div class="line"&gt;2&lt;/div&gt;&lt;div class="line"&gt;3&lt;/div&gt;&lt;div class="line"&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;div class="line"&gt;&lt;span class="keyword"&gt;int&lt;/span&gt; val = &lt;span class="number"&gt;20&lt;/span&gt;;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="keyword"&gt;if&lt;/span&gt;(&lt;span class="number"&gt;20&lt;/span&gt; == val) &amp;#123; &lt;span class="comment"&gt;// &amp;lt;- yoda notation here.&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;  ...&lt;/div&gt;&lt;div class="line"&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt; 
&lt;p&gt;조건문을 &lt;code&gt;val == 20&lt;/code&gt;으로 적는 것이 일반적인 언어 어순과 같아서 읽기가 좋지만&lt;br&gt;프로그래머의 실수로 &lt;code&gt;val = 20&lt;/code&gt;과 같이 잘못된 코드가 만들어지고 컴파일 에러 없이 그대로 실행되는 것을 막기 위해서&lt;br&gt;일부러 변수와 상수의 위치를 서로 바꾸는 거죠. &lt;/p&gt;
&lt;p&gt;요다는 영화 스타워즈에서 영문권 사람들도 이해하기 어려울 정도로 꼬인 문법의 말을 사용합니다. 이를 빗대어 위와 같은 조건문 표기 방식을 Yoda Notation이라고 부르는군요. 재미있는 네이밍입니다 :)&lt;/p&gt;
&lt;p&gt;책에서는 요즘의 컴파일러들이 조건절 내에서의 할당에 대해 경고를 내주기 때문에, 요다 표기법은 ‘점차 불필요한 과거의 일이 되어가고 있다’ 고 말합니다.&lt;br&gt;저도 쉽게 읽히지 않는 이상한 순서 때문에 요다 표기법을 안 좋아하는데,&lt;br&gt;책에서도 저랑 같은 생각을 이야기 하고 있어서 반갑네요. 이 뿐만 아니라 이 책은 전반적으로 소스코드의 스타일에 대해 많은 부분 공감가는 방식들을 다수 소개하고 있습니다.&lt;/p&gt;
&lt;p&gt;예전에 함께 작업했던 어떤 프로그래머분이, 제가 올린 코드를 리뷰하고 나서 제가 추가한 코드의 조건절을 모두 요다 표기법으로 바꾸었던 적이 있습니다. 그거 참… 별 거 아닌데 기분이 나쁘더군요. 그 뒤로 요다 표기법이 싫어졌는지도 모르겠습니다. 하지만 어쨌든 이젠 옛날 이야기가 되어가고 있는겁니다. Visual Studio 2012 기준으로 /W4(경고 수준 4) 설정에 /WX(경고를 오류로 처리) 설정을 더하면 &lt;a href="http://msdn.microsoft.com/ko-kr/library/7hw7c1he.aspx" target="_blank" rel="external"&gt;C4706 경고&lt;/a&gt;의 발생으로 인해 컴파일 시점에서 코딩 실수를 미리 잡아낼 수 있습니다. &lt;/p&gt;
&lt;p&gt;에, 그러니까 내가 하고 싶었던 말은, &lt;strong&gt;이제 이런 거 필요 없다&lt;/strong&gt; 이겁니다 :)&lt;/p&gt;
&lt;img src="http://feeds.feedburner.com/~r/florist_devnote/~4/FbE282SbnG0" height="1" width="1" alt=""/&gt;</content>
    
    <summary type="html">
    
      &lt;img src="/devnote/images/yoda1.jpg" class="center"&gt;
&lt;p&gt;지난번에 &lt;a href="/devnote/2014/07/google-c-plus-plus-style-guide/" title="google c++ st
    
    </summary>
    
    
      <category term="c++" scheme="http://leafbird.github.io/devnote/tags/c/" />
    
      <category term="coding convention" scheme="http://leafbird.github.io/devnote/tags/coding-convention/" />
    
  <feedburner:origLink>http://leafbird.github.io/devnote/2014/08/yoda-notation/</feedburner:origLink></entry>
  
  <entry>
    <title>Octopress Tips on windows</title>
    <link href="http://feedproxy.google.com/~r/florist_devnote/~3/LCNDAQY8OOA/" />
    <id>http://leafbird.github.io/devnote/2014/07/octopress-tips-on-windows/</id>
    <published>2014-07-21T07:44:48.000Z</published>
    <updated>2017-08-21T13:22:18.336Z</updated>
    
    <content type="html">&lt;p&gt;개인적으로 Octopress를 윈도우에서 사용하도록 구성하면서 도움이 되었던 팁들을 몇가지 정리해 보려고 합니다.&lt;br&gt;앞으로 계속 사용해 가면서 추가적인 팁이 생길 때에도 이 포스팅에 업데이트 할 생각이예요. &lt;/p&gt;
&lt;h2 id="윈도우-실행-Windows-R-창에서-블로그-패스로-바로-이동-하기"&gt;&lt;a href="#윈도우-실행-Windows-R-창에서-블로그-패스로-바로-이동-하기" class="headerlink" title="윈도우 실행 (Windows + R) 창에서 블로그 패스로 바로 이동 하기"&gt;&lt;/a&gt;윈도우 실행 (Windows + R) 창에서 블로그 패스로 바로 이동 하기&lt;/h2&gt;&lt;img src="/devnote/images/140721_00.png" class="center"&gt;
&lt;p&gt;이거야 뭐… 환경변수에 블로그 경로를 넣어주면 된다. 이렇게 하면 실행 창에 &lt;code&gt;%변수이름%&lt;/code&gt;만 입력하면 바로 탐색기를 열 수 있다.&lt;br&gt;환경 변수 설정을 해주는 PowerShell 스크립트를 만들어서 블로그 폴더의 루트에 놔두면 경로를 옮기거나 depot을 새로 받아도 편하게 셋팅할 수 있다. &lt;/p&gt;
&lt;figure class="highlight powershell"&gt;&lt;figcaption&gt;&lt;span&gt;ps_register_path.ps1&lt;/span&gt;&lt;a href="https://github.com/leafbird/devnote/blob/master/ps_register_path.ps1" target="_blank" rel="external"&gt;code from github&lt;/a&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;div class="line"&gt;1&lt;/div&gt;&lt;div class="line"&gt;2&lt;/div&gt;&lt;div class="line"&gt;3&lt;/div&gt;&lt;div class="line"&gt;4&lt;/div&gt;&lt;div class="line"&gt;5&lt;/div&gt;&lt;div class="line"&gt;6&lt;/div&gt;&lt;div class="line"&gt;7&lt;/div&gt;&lt;div class="line"&gt;8&lt;/div&gt;&lt;div class="line"&gt;9&lt;/div&gt;&lt;div class="line"&gt;10&lt;/div&gt;&lt;div class="line"&gt;11&lt;/div&gt;&lt;div class="line"&gt;12&lt;/div&gt;&lt;div class="line"&gt;13&lt;/div&gt;&lt;div class="line"&gt;14&lt;/div&gt;&lt;div class="line"&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;div class="line"&gt;&lt;span class="comment"&gt;# 현재 스크립트의 실행 경로를 얻는다.&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="variable"&gt;$blog_path&lt;/span&gt; = (&lt;span class="built_in"&gt;Get-Item&lt;/span&gt; -Path &lt;span class="string"&gt;".\"&lt;/span&gt; -Verbose).FullName&lt;/div&gt;&lt;div class="line"&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="comment"&gt;# 경로 확인&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="string"&gt;"blog path : &lt;span class="variable"&gt;$blog_path&lt;/span&gt;"&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="comment"&gt;# 실행 경로를 환경변수에 등록(유저 레벨)&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;[Environment]::SetEnvironmentVariable(&lt;span class="string"&gt;"blogpath"&lt;/span&gt;, &lt;span class="variable"&gt;$blog_path&lt;/span&gt;, &lt;span class="string"&gt;"User"&lt;/span&gt;)&lt;/div&gt;&lt;div class="line"&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="comment"&gt;# output result&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="string"&gt;"Environment Variable update. &amp;#123;0&amp;#125; = &amp;#123;1&amp;#125;"&lt;/span&gt; -f &lt;span class="string"&gt;"blogpath"&lt;/span&gt;, &lt;span class="variable"&gt;$blog_path&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="comment"&gt;# pause&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="built_in"&gt;Write-Host&lt;/span&gt; &lt;span class="string"&gt;"Press any key to continue ..."&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="variable"&gt;$x&lt;/span&gt; = &lt;span class="variable"&gt;$host&lt;/span&gt;.UI.RawUI.ReadKey(&lt;span class="string"&gt;"NoEcho,IncludeKeyDown"&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id="blogpath-이외에-자주-접근하는-경로는-바로가기를-만든다"&gt;&lt;a href="#blogpath-이외에-자주-접근하는-경로는-바로가기를-만든다" class="headerlink" title="%blogpath% 이외에 자주 접근하는 경로는 바로가기를 만든다"&gt;&lt;/a&gt;%blogpath% 이외에 자주 접근하는 경로는 바로가기를 만든다&lt;/h2&gt;&lt;img src="/devnote/images/140721_01.PNG" class="center"&gt;
&lt;p&gt;octopress를 쓰면서 커맨드를 실행하는 주된 경로는 root path다. 이외에도 첨부파일 경로나 글 본문을 저장하는 &lt;code&gt;./source/_posts&lt;/code&gt; 등이 흔히 쓰이는데, 이런 경로에 대한 .lnk 파일을 만들어두면 훨씬 편하다.&lt;br&gt;위 스샷처럼 바로가기를 만들어두고 &lt;code&gt;po&lt;/code&gt;정도 타이핑하고 엔터하면 &lt;code&gt;./source/_posts&lt;/code&gt;로 이동한다.&lt;/p&gt;
&lt;p&gt;나는 탐색기를 주로 이용하고자 이렇게 했지만 cmd창에서 바로가기 하고 싶다면 symbolic link를 만들면 될거다. &lt;/p&gt;
&lt;p&gt;웹페이지 바로가기도 만들어 두면 편하게 이동 가능. (웹 바로가기는 .url 확장자. 브라우저 주소창에서 슥 끌어다 놓으면 생김)&lt;/p&gt;
&lt;h2 id="자주-쓰는-동작들은-스크립트로-자동화한다"&gt;&lt;a href="#자주-쓰는-동작들은-스크립트로-자동화한다" class="headerlink" title="자주 쓰는 동작들은 스크립트로 자동화한다"&gt;&lt;/a&gt;자주 쓰는 동작들은 스크립트로 자동화한다&lt;/h2&gt;&lt;img src="/devnote/images/140721_02.PNG" class="center"&gt;
&lt;p&gt;&lt;strong&gt;Note : 이 항목이 이 포스팅의 핵심 입니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Octopress를 쓰면서 마음에 드는 점 중에 하나인데, 마음만 먹으면 조작 과정을 내맘대로 스크립팅할 수 있다는 점이다.&lt;br&gt;처음 octopress를 이용하려면 갖가지 명령어들을 일일이 숙지하고 사용하기가 불편한 것이 사실이지만,&lt;br&gt;batch파일과 PowerShell을 통해서 얼마든지 내 입맛대로 자동화 할 수 있다.&lt;br&gt;PowerShell을 한 번 다뤄보고 싶었지만 딱히 기회가 없었는데 이참에 다뤄보게 되어 재미있었다.&lt;br&gt;지금은 몇 개 안되긴 하지만 개인적으로 만들어 사용중인 스크립트들은 &lt;a href="http://github.com/leafbird/devnote/" target="_blank" rel="external"&gt;http://github.com/leafbird/devnote/&lt;/a&gt; 에서 확인할 수 있다. &lt;/p&gt;
&lt;p&gt;예제로 한 가지만 살펴보자.&lt;/p&gt;
&lt;h3 id="자동화-예시-새글-작성을-간편하게"&gt;&lt;a href="#자동화-예시-새글-작성을-간편하게" class="headerlink" title="자동화 예시 : 새글 작성을 간편하게"&gt;&lt;/a&gt;자동화 예시 : 새글 작성을 간편하게&lt;/h3&gt;&lt;p&gt;ocotpress에서 새 글을 적으려면 아래의 순서대로 실행해야 한다. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;blog path로 이동.&lt;/li&gt;
&lt;li&gt;cmd창 오픈&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rake new_post[&amp;#39;포스팅 제목&amp;#39;]&lt;/code&gt; 명령 실행&lt;/li&gt;
&lt;li&gt;&lt;code&gt;./source/_posts&lt;/code&gt;로 이동&lt;/li&gt;
&lt;li&gt;자동으로 생성된 .markdown 파일을 찾아서 오픈&lt;/li&gt;
&lt;li&gt;글 작성 시작&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 절차를 아래처럼 PowerShell로 스크립팅한다.&lt;/p&gt;
&lt;figure class="highlight powershell"&gt;&lt;figcaption&gt;&lt;span&gt;ps_rake_new_post.ps1&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;div class="line"&gt;1&lt;/div&gt;&lt;div class="line"&gt;2&lt;/div&gt;&lt;div class="line"&gt;3&lt;/div&gt;&lt;div class="line"&gt;4&lt;/div&gt;&lt;div class="line"&gt;5&lt;/div&gt;&lt;div class="line"&gt;6&lt;/div&gt;&lt;div class="line"&gt;7&lt;/div&gt;&lt;div class="line"&gt;8&lt;/div&gt;&lt;div class="line"&gt;9&lt;/div&gt;&lt;div class="line"&gt;10&lt;/div&gt;&lt;div class="line"&gt;11&lt;/div&gt;&lt;div class="line"&gt;12&lt;/div&gt;&lt;div class="line"&gt;13&lt;/div&gt;&lt;div class="line"&gt;14&lt;/div&gt;&lt;div class="line"&gt;15&lt;/div&gt;&lt;div class="line"&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;div class="line"&gt;&lt;span class="comment"&gt;# 환경변수 BLOG_PATH에 설정된 블로그 root 경로로 이동&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;cd &lt;span class="variable"&gt;$env:blogpath&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="comment"&gt;#input으로 새 글의 제목을 받는다. &lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="variable"&gt;$title&lt;/span&gt; = &lt;span class="built_in"&gt;Read-Host&lt;/span&gt; &lt;span class="string"&gt;'Enter Title'&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="comment"&gt;# 실행 : rake new_post['제목']&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="variable"&gt;$argument&lt;/span&gt; = [string]::Format(&lt;span class="string"&gt;"new_post[&amp;#123;0&amp;#125;]"&lt;/span&gt;, &lt;span class="variable"&gt;$title&lt;/span&gt;)&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="variable"&gt;$out&lt;/span&gt; = rake.bat &lt;span class="variable"&gt;$argument&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="comment"&gt;# 생성된 파일의 이름과 경로를 추출한다.&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="variable"&gt;$out&lt;/span&gt; = &lt;span class="variable"&gt;$out&lt;/span&gt;.Replace(&lt;span class="string"&gt;"Creating new post: "&lt;/span&gt;, &lt;span class="string"&gt;""&lt;/span&gt;)&lt;/div&gt;&lt;div class="line"&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="comment"&gt;# 생성된 파일을 gvim으로 오픈!&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="variable"&gt;$new_file_path&lt;/span&gt; = [System.IO.Path]::Combine(&lt;span class="variable"&gt;$PSScriptRoot&lt;/span&gt;, &lt;span class="variable"&gt;$out&lt;/span&gt;)&lt;/div&gt;&lt;div class="line"&gt;gvim.exe &lt;span class="variable"&gt;$new_file_path&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;커맨드 창에 &lt;code&gt;PowerShell ./ps_rake_new_post.ps1&lt;/code&gt; 입력하는 것도 귀찮으니 이것도 batch파일로 만들자.&lt;/p&gt;
&lt;figure class="highlight bat"&gt;&lt;figcaption&gt;&lt;span&gt;02_ps_rake_new_post.bat&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;div class="line"&gt;1&lt;/div&gt;&lt;div class="line"&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;div class="line"&gt;@&lt;span class="built_in"&gt;echo&lt;/span&gt; off&lt;/div&gt;&lt;div class="line"&gt;powershell ./ps_rake_new_post.ps1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;이제 이 batch를 실행해서 새 글 제목을 입력하면 에디터까지 자동으로 열린다. &lt;/p&gt;
&lt;h2 id="git-conflict-여러-머신에서-하나의-블로그에-번갈아-포스팅-하는-경우"&gt;&lt;a href="#git-conflict-여러-머신에서-하나의-블로그에-번갈아-포스팅-하는-경우" class="headerlink" title="git conflict : 여러 머신에서 하나의 블로그에 번갈아 포스팅 하는 경우"&gt;&lt;/a&gt;git conflict : 여러 머신에서 하나의 블로그에 번갈아 포스팅 하는 경우&lt;/h2&gt;&lt;p&gt;git을 사용할 때 불편한 점 중의 하나가 머지(merge)다. 여러 머신을 사용할 경우엔 다른 곳에서 수정했던 사항을 미리 pull 받고 난 후 작업해야 하는데, 이걸 혹시나 깜박 잊고 새 글을 써서 generate했다면 conflict 대 참사가 일어난다. &lt;/p&gt;
&lt;p&gt;blog root경로는 보통의 git repository를 사용하는 것과 유사하기 때문에 큰 문제가 없는데 &lt;code&gt;_deploy&lt;/code&gt;폴더가 문제다. 이 폴더는 블로그 엔진이 generate한 블로그 리소스를 배포하기 위해 사용하는데, 실제로는 &lt;code&gt;gh-pages&lt;/code&gt; 브랜치의 clone이기 때문이다. 그래서 서로 다른 여러 개의 depot clone을 가지고 블로깅을 할 땐 blog root와 함께 &lt;code&gt;_deploy&lt;/code&gt;도 함께 &lt;code&gt;git pull&lt;/code&gt; 해주어야 문제가 없다. &lt;/p&gt;
&lt;p&gt;하지만 &lt;code&gt;_deploy&lt;/code&gt;폴더는 굳이 동기화까지 받을 필요는 없다. 어차피 블로그 엔진이 배포하는 과정에서 새로 만들기 때문이다.&lt;br&gt;어떻게 활용하든 상관없지만 만약 &lt;code&gt;_deploy&lt;/code&gt;폴더가 충돌이나서 html파일을 한땀 한땀 머지해야 하는 상황이 되었다면 주저없이 삭제해 버리고 새로 만들자.&lt;/p&gt;
&lt;figure class="highlight plain"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;div class="line"&gt;1&lt;/div&gt;&lt;div class="line"&gt;2&lt;/div&gt;&lt;div class="line"&gt;3&lt;/div&gt;&lt;div class="line"&gt;4&lt;/div&gt;&lt;div class="line"&gt;5&lt;/div&gt;&lt;div class="line"&gt;6&lt;/div&gt;&lt;div class="line"&gt;7&lt;/div&gt;&lt;div class="line"&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;div class="line"&gt;cd %blogpath%&lt;/div&gt;&lt;div class="line"&gt;rmdir /s /q _deploy&lt;/div&gt;&lt;div class="line"&gt;mkdir _deploy&lt;/div&gt;&lt;div class="line"&gt;cd _deploy&lt;/div&gt;&lt;div class="line"&gt;git init&lt;/div&gt;&lt;div class="line"&gt;git remote add origin https://....&lt;/div&gt;&lt;div class="line"&gt;git pull&lt;/div&gt;&lt;div class="line"&gt;git check --track origin/gh-pages&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;img src="http://feeds.feedburner.com/~r/florist_devnote/~4/LCNDAQY8OOA" height="1" width="1" alt=""/&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;개인적으로 Octopress를 윈도우에서 사용하도록 구성하면서 도움이 되었던 팁들을 몇가지 정리해 보려고 합니다.&lt;br&gt;앞으로 계속 사용해 가면서 추가적인 팁이 생길 때에도 이 포스팅에 업데이트 할 생각이예요. &lt;/p&gt;
&lt;h2 id="윈도우-실행
    
    </summary>
    
    
      <category term="octopress" scheme="http://leafbird.github.io/devnote/tags/octopress/" />
    
      <category term="windows" scheme="http://leafbird.github.io/devnote/tags/windows/" />
    
  <feedburner:origLink>http://leafbird.github.io/devnote/2014/07/octopress-tips-on-windows/</feedburner:origLink></entry>
  
  <entry>
    <title>google c++ style guide</title>
    <link href="http://feedproxy.google.com/~r/florist_devnote/~3/BBpXgf37nX0/" />
    <id>http://leafbird.github.io/devnote/2014/07/google-c-plus-plus-style-guide/</id>
    <published>2014-07-19T02:12:37.000Z</published>
    <updated>2017-08-21T13:25:42.455Z</updated>
    
    <content type="html">&lt;p&gt;지금 참여중인 프로젝트에서 얼마전에 코딩 컨벤션을 통일하는 작업이 있었습니다.&lt;br&gt;본격적으로 컨벤션을 통일하고 이제 한 서너달? 정도 지난 것 같네요. &lt;/p&gt;
&lt;p&gt;처음에는 팀원 대다수가 많이 혼란스러워 했지만 이제 어느 정도 시간이 지나고 나니 팀 내 프로그래머 모두가&lt;br&gt;거의 유사한 스타일의 코드를 작성하게 됐습니다. 이렇게 되니 전보다 코드 가독성이 좋아지고 협업을 할 때 이런 저런 많은 도움이 됩니다. &lt;/p&gt;
&lt;p&gt;사실 컨벤션이 통일되면 좋다는 것은 아주 상식적인 말입니다만, 개개인이 선호하는 스타일이 다 다르기 때문에 통일을 하기가 쉽지 않다는 것이 문제입니다. 팀에서도 그동안 몇 차례 시도 했었지만 잘 안되었다가, 이번에서야 겨우 성공했어요. &lt;/p&gt;
&lt;p&gt;이번에 컨벤션의 통일을 성공한 주된 요인 중의 하나는 구글 내부에서 사용하는 컨벤션을 정리해서 공개한 &lt;a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml" target="_blank" rel="external"&gt;구글 C++ 스타일 가이드&lt;/a&gt;라고 볼 수 있습니다. 이 문서의 내용을 가져와 몇 가지 사항만 프로젝트에 맞게 조정하여 적용 하였지요. 구글 컨벤션의 코드들은 처음 볼 땐 좀 낮설었지만 적응하고 나니 이젠 괜찮군요. &lt;/p&gt;
&lt;p&gt;팀에 도입하는 과정에서, 팀 내 능력자분들께서 원문을 &lt;a href="http://jongwook.github.io/google-styleguide/trunk/cppguide.xml" target="_blank" rel="external"&gt;한글로 깔끔하게 번역 &amp;amp; 정리&lt;/a&gt;해 주셨습니다.&lt;br&gt;&lt;a href="https://www.google.co.kr/search?q=google+c%2B%2B+style+guide+%EB%B2%88%EC%97%AD&amp;amp;oq=gooel+c%2B%2B+st&amp;amp;aqs=chrome.2.69i57j0l5.5908j0j4&amp;amp;sourceid=chrome&amp;amp;es_sm=93&amp;amp;ie=UTF-8" target="_blank" rel="external"&gt;구글에서 검색해보니&lt;/a&gt; 오래전에 번역되다가 말았던 문서들은 몇 개 보이는데 이번에 팀 내에서 번역한 문서는 아직 공유가 널리 안 된 것 같아서 다시 한 번 소개도 할 겸 포스팅 합니다. - 이 글의 목적입니다.&lt;/p&gt;
&lt;p&gt;일단 간단한 샘플을 한 번 볼까요? (제가 구글 컨벤션을 100% 체득(?)한 상황은 아니지만, 대략적으로 분위기만 한 번 둘러보죠.)&lt;/p&gt;
&lt;figure class="highlight cpp"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;div class="line"&gt;1&lt;/div&gt;&lt;div class="line"&gt;2&lt;/div&gt;&lt;div class="line"&gt;3&lt;/div&gt;&lt;div class="line"&gt;4&lt;/div&gt;&lt;div class="line"&gt;5&lt;/div&gt;&lt;div class="line"&gt;6&lt;/div&gt;&lt;div class="line"&gt;7&lt;/div&gt;&lt;div class="line"&gt;8&lt;/div&gt;&lt;div class="line"&gt;9&lt;/div&gt;&lt;div class="line"&gt;10&lt;/div&gt;&lt;div class="line"&gt;11&lt;/div&gt;&lt;div class="line"&gt;12&lt;/div&gt;&lt;div class="line"&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;div class="line"&gt;&lt;span class="class"&gt;&lt;span class="keyword"&gt;class&lt;/span&gt; &lt;span class="title"&gt;Test&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt; &lt;span class="keyword"&gt;public&lt;/span&gt;:&lt;/div&gt;&lt;div class="line"&gt;  Test();&lt;/div&gt;&lt;div class="line"&gt;  &lt;span class="keyword"&gt;virtual&lt;/span&gt; ~Test();&lt;/div&gt;&lt;div class="line"&gt;&lt;/div&gt;&lt;div class="line"&gt;  &lt;span class="function"&gt;&lt;span class="keyword"&gt;int&lt;/span&gt; &lt;span class="title"&gt;some_value&lt;/span&gt;&lt;span class="params"&gt;()&lt;/span&gt; &lt;span class="keyword"&gt;const&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class="line"&gt;  &lt;span class="function"&gt;&lt;span class="keyword"&gt;void&lt;/span&gt; &lt;span class="title"&gt;set_some_value&lt;/span&gt;&lt;span class="params"&gt;(&lt;span class="keyword"&gt;const&lt;/span&gt; &lt;span class="keyword"&gt;int&lt;/span&gt; val)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class="line"&gt;    some_value_ = val;      &lt;span class="comment"&gt;// 간단한 예제이니 inline으로 짜봅니다.&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;  &amp;#125;&lt;/div&gt;&lt;div class="line"&gt;&lt;/div&gt;&lt;div class="line"&gt; &lt;span class="keyword"&gt;private&lt;/span&gt;:&lt;/div&gt;&lt;div class="line"&gt;  &lt;span class="keyword"&gt;int&lt;/span&gt; some_value_;&lt;/div&gt;&lt;div class="line"&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;구글 컨벤션의 아주 일부 규칙들이 몇 개 적용된 클래스 선언입니다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;opening brace을 아랫줄로 내리지 않고 바로 붙여쓰는 것이나, &lt;/li&gt;
&lt;li&gt;들여쓰기는 스페이스 2칸.&lt;/li&gt;
&lt;li&gt;클래스의 멤버변수는 c스타일처럼 &lt;code&gt;_&lt;/code&gt;로 연결된 소문자 단어를 사용하고 &lt;code&gt;_&lt;/code&gt;를 끝에 붙인다는 점&lt;/li&gt;
&lt;li&gt;getter는 멤버 변수의 이름과 같게, &lt;/li&gt;
&lt;li&gt;setter는 &lt;code&gt;set_변수명()&lt;/code&gt;의 규칙을 지닌다. &lt;/li&gt;
&lt;li&gt;클래스 접근 권한 지정자(public, private)는 스페이스 1칸 들여쓰기.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;…정도가 보이네요. (변수명 선언 방식이 헝가리안 표기가 아니예요!)&lt;/p&gt;
&lt;p&gt;구글 컨벤션을 따르는 코드의 예제는 breakpad, protobuf같은 구글의 오픈소스 프로젝트에서 볼 수 있습니다. 구글 코드 이외에도 몇몇 오픈소스들을 보면 구글 컨벤션의 영향을 받은듯한 코드들이 제법 보입니다. 얼마전에 잠시 가지고 놀았던 &lt;a href="https://github.com/msgpack/msgpack-c" target="_blank" rel="external"&gt;msgpack&lt;/a&gt;도 어느정도 구글 컨벤션의 영향을 받은 듯한 모양새를 가지고 있더군요. &lt;/p&gt;
&lt;p&gt;구글 컨벤션은 위의 예제에서 보이는 단순한 들여쓰기, 줄바꿈 같은 형식 이야기 말고도 디자인 철학과 관련된 규약들이 많이 있어서, 평소 생각하지 못했던 여러가지 이슈들을 상기시켜줍니다. 문서 내용을 읽는 것만 해도 자신의 코딩 스타일에 대해 많은 점검(?)을 할 수 있어요.&lt;/p&gt;
&lt;p&gt;개인적으로는 팀에서 정해진 룰 때문에 먼저 좀 겪어보게 되었는데 나쁘지 않더군요. 아직까지 마음에 안 드는 조항들도 몇 가지 있지만, 앞으로는 팀 코드가 아닌 개인 작업을 할 때에도 구글 컨벤션을 지켜 코딩해볼 생각입니다. &lt;/p&gt;
&lt;h2 id="다시-한-번-링크"&gt;&lt;a href="#다시-한-번-링크" class="headerlink" title="다시 한 번 링크 :"&gt;&lt;/a&gt;다시 한 번 링크 :&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;원문 : &lt;a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml" target="_blank" rel="external"&gt;http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;번역문 : &lt;a href="http://jongwook.github.io/google-styleguide/trunk/cppguide.xml" target="_blank" rel="external"&gt;http://jongwook.github.io/google-styleguide/trunk/cppguide.xml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="본격-컨벤션-적용을-위한-팁"&gt;&lt;a href="#본격-컨벤션-적용을-위한-팁" class="headerlink" title="본격 컨벤션 적용을 위한 팁 :"&gt;&lt;/a&gt;본격 컨벤션 적용을 위한 팁 :&lt;/h2&gt;&lt;h3 id="vs2013의-서식-설정-옵션-활용"&gt;&lt;a href="#vs2013의-서식-설정-옵션-활용" class="headerlink" title="vs2013의 서식 설정 옵션 활용"&gt;&lt;/a&gt;vs2013의 서식 설정 옵션 활용&lt;/h3&gt;&lt;p&gt;visual studio를 이용해 윈도우에서 개발하는 환경일 경우, IDE로 vs2013을 사용하면 많은 도움이 됩니다. 빌드는 예전 버전으로 하더라도 IDE만 vs2013을 사용할 수 있습니다. 2013에는 IDE의 자동 formatting 방식을 직접 설정할 수 있어요.&lt;/p&gt;
&lt;img src="/devnote/images/140719_00.png" class="center"&gt;
&lt;p&gt;게다가 vs2013 Update 2를 설치하면 설정 가능한 옵션이 좀 더 늘어납니다! Update 3는 아직 안나왔지만 나오면 설정이 더 늘어날지도!!&lt;/p&gt;
&lt;h3 id="포맷팅을-자동으로-고쳐주는-AStyle-활용"&gt;&lt;a href="#포맷팅을-자동으로-고쳐주는-AStyle-활용" class="headerlink" title="포맷팅을 자동으로 고쳐주는 AStyle 활용"&gt;&lt;/a&gt;포맷팅을 자동으로 고쳐주는 AStyle 활용&lt;/h3&gt;&lt;p&gt;&lt;a href="http://astyle.sourceforge.net/" target="_blank" rel="external"&gt;AStyle&lt;/a&gt;이란 멋진 프로그램이 있어요. 포맷팅을 자동으로 고쳐주는 프로그램인데, 오픈소스로 되어있어 직접 수정 &amp;amp; 활용할 수 있습니다. 이걸 perforce 클라이언트인 p4v.exe pending changelist 창에서 일괄 적용하게 설정할 수도 있고, vs 플러그인으로 만들어서 코딩 중에도 실행해 볼 수 있어요. 포맷팅을 알아서 고쳐주니까 코딩중에는 들여쓰기가 어떻고 빈 칸이 어떤지 일일이 신경 쓸 필요 없으니 아주 편리합니다 -_-)b 강추예요.&lt;/p&gt;
&lt;img src="http://feeds.feedburner.com/~r/florist_devnote/~4/BBpXgf37nX0" height="1" width="1" alt=""/&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;지금 참여중인 프로젝트에서 얼마전에 코딩 컨벤션을 통일하는 작업이 있었습니다.&lt;br&gt;본격적으로 컨벤션을 통일하고 이제 한 서너달? 정도 지난 것 같네요. &lt;/p&gt;
&lt;p&gt;처음에는 팀원 대다수가 많이 혼란스러워 했지만 이제 어느 정도 시간이 지나고 
    
    </summary>
    
    
      <category term="c++" scheme="http://leafbird.github.io/devnote/tags/c/" />
    
      <category term="coding convention" scheme="http://leafbird.github.io/devnote/tags/coding-convention/" />
    
  <feedburner:origLink>http://leafbird.github.io/devnote/2014/07/google-c-plus-plus-style-guide/</feedburner:origLink></entry>
  
  <entry>
    <title>벤츠타는 프로그래머</title>
    <link href="http://feedproxy.google.com/~r/florist_devnote/~3/rJfhb0sAFvw/" />
    <id>http://leafbird.github.io/devnote/2014/07/the-benz-programmer/</id>
    <published>2014-07-16T11:20:38.000Z</published>
    <updated>2017-08-21T13:26:06.762Z</updated>
    
    <content type="html">&lt;img src="/devnote/images/140708_00.png" class="center" width="300"&gt;
&lt;p&gt;요 며칠간 이 책을 읽었습니다. 회사 도서관에 갔다가 제목이 끌려서 한 번 읽어봤어요.&lt;br&gt;누가 정한건지 모르겠지만 책 제목 참 멋지게 지었습니다. 주변에서 제가 이 책 읽는 것 보면 모두들 제목에 대해 관심을 보이더군요 ㅎ&lt;/p&gt;
&lt;p&gt;진로를 고민중인 학생이나 일을 시작한지 얼마 되지 않는 신입 개발자들을 주 대상으로 삼은 책입니다. 다소 주관적이긴 하지만 선배 개발자 입장에서 들려주는 이런 저런 이야기들이 적혀 있어요.&lt;br&gt;저자는 자기관리를 잘 하는 분이신 듯 합니다. 구체적인 개인 목표를 세우고 달성을 위해 노력하는 점이라든지, 꾸준한 자기계발에 관심을 두는 점 같은 좋은 습관을 많이 만들어두신 것 같네요. &lt;/p&gt;
&lt;p&gt;저는 작업 도중에 빌드 걸어놓고 잠깐씩 기다리는 동안에 주로 읽었습니다.&lt;br&gt;빌드시간에 조금 난이도가 있는 기술서적을 읽을 때는, 내용을 좀 따라가려다 보면 빌드가 끝나서 흐름이 끊기고, 이게 계속 반복되다보니 책에 제대로 집중할 수가 없었습니다.&lt;br&gt;그래서 빌드시간에 책읽는 것은 거의 포기를 하고 있었는데, 이런 책은 부담없이 읽을 수 있어서 빌드 중에 읽어도 괜찮더군요.&lt;br&gt;그래서 앞으로는 빌드하는 중에 이런 가벼운 책들 읽으면 되겠구나 하는 생각을 해봤습니다.&lt;/p&gt;
&lt;p&gt;저는 책을 읽다가 조금 엉뚱한 구절에 눈길이 확 쏠렸는데, &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;…결혼하고 아이들이 생긴 이후에는 집에서 어떤 일을 한다는 게 쉽지 않았다. 그래서 집중해서 집필하거나 공모전 참가 준비를 할 때는 주말마다 본가로 달려갔다. 본가에서는 식사 시간 이외에는 누구도 방해하는 사람이 없어서 원하는 일에 집중할 수 있었기 때문이다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 부분입니다. 저도 아이가 생긴 후에는 개인 시간을 내기가 쉽지 않아서 적잖이 고민을 하고 있는데, 주말마다 본가에 가서 혼자만의 시간을 가질 수 있었다는 저 이야기는 정말 부럽기 짝이 없네요 ㅜㅠ…&lt;/p&gt;
&lt;img src="/devnote/images/140716_00.jpg" class="center"&gt;
&lt;p&gt;저는 집에 아이가 생기고 한동안은 개인 시간은 아예 포기하고 지냈습니다. 주말마다 즐겁게 참여하던 스터디도 못 나가게 되었고, 집에서 컴퓨터 앞에 앉아 코딩을 하는 것은 거의 꿈도 꾸질 못했어요. &lt;/p&gt;
&lt;p&gt;이제는 아이도 어느 정도 자랐고 하니 조금씩 개인 시간을 확보하고 다시 자기관리에 신경을 좀 써야겠다고 다짐했습니다. 이런 다짐을 한 것에는 최근에 이 책을 읽었던 것도 어느 정도 영향이 있었겠지요. 벤츠 타는 것도 난 바라지 않아요. 그냥 원하는 만큼 양껏 코딩하고 놀 수 있게만 됐으면 좋겠네요 ;ㅁ;)…&lt;/p&gt;
&lt;img src="http://feeds.feedburner.com/~r/florist_devnote/~4/rJfhb0sAFvw" height="1" width="1" alt=""/&gt;</content>
    
    <summary type="html">
    
      &lt;img src="/devnote/images/140708_00.png" class="center" width="300"&gt;
&lt;p&gt;요 며칠간 이 책을 읽었습니다. 회사 도서관에 갔다가 제목이 끌려서 한 번 읽어봤어요.&lt;br&gt;누가 정한건지 모르겠지만 책 
    
    </summary>
    
    
      <category term="book" scheme="http://leafbird.github.io/devnote/tags/book/" />
    
  <feedburner:origLink>http://leafbird.github.io/devnote/2014/07/the-benz-programmer/</feedburner:origLink></entry>
  
  <entry>
    <title>move to octopress!</title>
    <link href="http://feedproxy.google.com/~r/florist_devnote/~3/ygrHJrjzsNM/" />
    <id>http://leafbird.github.io/devnote/2014/07/move-to-octopress/</id>
    <published>2014-07-13T15:24:24.000Z</published>
    <updated>2017-08-18T12:27:20.974Z</updated>
    
    <content type="html">&lt;p&gt;기존에 티스토리에서 운영 중이던 &lt;a href="http://devnote.tistory.com" target="_blank" rel="external"&gt;프로그래밍 관련 블로그(devnote.tistory.com)&lt;/a&gt;를 Octopress로 이사합니다. 사실 운영이라고 말하기도 뭣할 만큼 오랫동안 방치되어 있었는데, 다시금 분위기를 쇄신하고자 환경을 바꿔볼까 합니다. &lt;/p&gt;
&lt;p&gt;기존 블로그를 feedburner 주소로 구독중이었다면 새로운 블로그로 자동으로 넘어갑니다. 하지만 티스토리 기본 rss 주소를 사용중이었다면, 이참에 feed-burner로 갈아타 주세요 ‘ㅁ’)/&lt;/p&gt;
&lt;p&gt;feed burder address : &lt;a href="http://feeds.feedburner.com/florist_devnote" target="_blank" rel="external"&gt;http://feeds.feedburner.com/florist_devnote&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Octopress는 기존과는 다른 형태의 static engine이라서 호감이 갑니다. 맘에 드는 점을 몇가지만 꼽아보면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vim으로 글을 적을 수 있다는 것&lt;/li&gt;
&lt;li&gt;본문 글이 로컬에 text(markdown)파일로 남는 다는 점&lt;/li&gt;
&lt;li&gt;블로그 주소에 github.io를 쓴다는 것&lt;/li&gt;
&lt;li&gt;기본적으로 큰 글씨를 사용하는 시원한 테마들.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;… 등입니다. markdown으로 글을 적게 된다면 &lt;a href="http://pad.haroopress.com/user.html" target="_blank" rel="external"&gt;하루패드&lt;/a&gt;를 사용해야 겠다고 생각했었는데, vim으로 적는게 더 느낌이 좋네요 :) vim을 무척 잘 쓰는 편은 못되지만, octopress덕에 git이나 vim을 자주 접하게 되면 좀 더 익숙해 지는 계기가 될테니 그런 점도 마음에 듭니다. &lt;/p&gt;
&lt;p&gt;그 외 나머지 추가 기능이나 설정 같은 건 아직 제대로 모르는 상태이지만, 하루 이틀 미루다보면 너무 늘어져 버릴 것 같아서 우선 이사 공표(?)부터 내지릅니다. &lt;/p&gt;
&lt;p&gt;집에 애가 생기고 난 후 부터는 개인 시간이 많이 줄어들면서 블로그에도 소홀해지게 되었는데, 앞으로는 굳이 테크니컬한 내용의 글이 아니더라도 개발에 관련된 소소한 글들도 올릴 생각입니다. 이를테면 기계식 키보드에 대한 이야기라던가… 하는 것도요. (글쓰기 연습을 위해서라도 무엇이든 꾸준히 글을 좀 적어야 겠다는 개인적인 욕망(?) 때문입니다.)&lt;/p&gt;
&lt;p&gt;앞으로 여러가지 글들 종종 올리겠습니다.&lt;/p&gt;
&lt;img src="http://feeds.feedburner.com/~r/florist_devnote/~4/ygrHJrjzsNM" height="1" width="1" alt=""/&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;기존에 티스토리에서 운영 중이던 &lt;a href="http://devnote.tistory.com" target="_blank" rel="external"&gt;프로그래밍 관련 블로그(devnote.tistory.com)&lt;/a&gt;를 Octopress로 이
    
    </summary>
    
    
      <category term="octopress" scheme="http://leafbird.github.io/devnote/tags/octopress/" />
    
  <feedburner:origLink>http://leafbird.github.io/devnote/2014/07/move-to-octopress/</feedburner:origLink></entry>
  
  <entry>
    <title>octopress on windows</title>
    <link href="http://feedproxy.google.com/~r/florist_devnote/~3/hCfM86TLBbo/" />
    <id>http://leafbird.github.io/devnote/2013/12/octopress-on-windows/</id>
    <published>2013-12-30T14:06:15.000Z</published>
    <updated>2017-08-18T14:22:10.438Z</updated>
    
    <content type="html">&lt;img src="/devnote/images/octopress.jpeg" class="center"&gt;
&lt;p&gt;octopress도 대게는 ruby가 기본 설치된 mac에서 많이들 사용하는 듯 하다. 검색해보면 대부분 OS X를 기준으로 한 셋팅법이다. 윈도우에서 사용하는 것도 많이 어렵진 않지만 &lt;strong&gt;한글 인코딩 때문에 많이 헤맸음 ㅜㅠ&lt;/strong&gt;…&lt;/p&gt;
&lt;p&gt;일단 기본적으로 아래 두 개의 글을 참고해 설치했는데,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://stb.techelex.com/setup-octopress-on-windows7/" target="_blank" rel="external"&gt;http://stb.techelex.com/setup-octopress-on-windows7/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://chulhankim.github.io/blog/2013/07/31/octopress-and-github.html" target="_blank" rel="external"&gt;http://chulhankim.github.io/blog/2013/07/31/octopress-and-github.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ruby는 생소한 언어이기도 하고 링크가 사라지면 다시 헤맬수도 있으니 간략하게 다시 정리.&lt;/p&gt;
&lt;h1 id="Ruby-설치"&gt;&lt;a href="#Ruby-설치" class="headerlink" title="Ruby 설치"&gt;&lt;/a&gt;Ruby 설치&lt;/h1&gt;&lt;p&gt;일단 윈도우에는 Ruby가 없기 때문에 먼저 설치를 해야 한다.&lt;br&gt;&lt;a href="http://rubyinstaller.org/downloads/" target="_blank" rel="external"&gt;다운로드 페이지&lt;/a&gt;에서 Ruby와 DevKit을 다운받는다.&lt;br&gt;내가 사용한 버전은 Ruby 2.0.0-p353 (x64)와 DevKit-mingw64-64-4.7.2-20130224-1432-sfx.exe&lt;/p&gt;
&lt;p&gt;DevKit을 사용하기 전에 install 과정이 필요하다. 이 단계를 실행하기 전에 ruby의 bin 폴더가 path에 잡혀 있는 것이 좋다. 그러면 DevKit 초기화 과정에서 ruby의 경로를 알아서 감지하므로, config.yml을 수정할 필요가 없다. &lt;/p&gt;
&lt;figure class="highlight bash"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;div class="line"&gt;1&lt;/div&gt;&lt;div class="line"&gt;2&lt;/div&gt;&lt;div class="line"&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;div class="line"&gt;&lt;span class="built_in"&gt;cd&lt;/span&gt; C:/RubyDevKit&lt;/div&gt;&lt;div class="line"&gt;ruby dk.rb init &lt;span class="comment"&gt;# 이 때 config.yml이 생김. 이 전에 ruby bin을 path에 넣자.&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;ruby dk.rb install&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id="python-설치"&gt;&lt;a href="#python-설치" class="headerlink" title="python 설치"&gt;&lt;/a&gt;python 설치&lt;/h1&gt;&lt;p&gt;python은 없어도 상관없다. 하지만 syntax highlighting을 하려거든 python이 필요하다. 이것도 OS X는 기본 설치되어 있어서 크게 이슈가 없는듯. 나는 한참 써보다가 알았는데, 나중에 python을 설치하면 &lt;a href="https://github.com/imathis/octopress/issues/262" target="_blank" rel="external"&gt;뭔가 더 해주어야 하는 것 같아 귀찮다&lt;/a&gt;. 그냥 처음부터 python을 설치해놓고 path에 python이 포함되도록 해두는게 좋겠다. &lt;/p&gt;
&lt;h1 id="Octopress-받기"&gt;&lt;a href="#Octopress-받기" class="headerlink" title="Octopress 받기"&gt;&lt;/a&gt;Octopress 받기&lt;/h1&gt;&lt;figure class="highlight bash"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;div class="line"&gt;1&lt;/div&gt;&lt;div class="line"&gt;2&lt;/div&gt;&lt;div class="line"&gt;3&lt;/div&gt;&lt;div class="line"&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;div class="line"&gt;&lt;span class="built_in"&gt;cd&lt;/span&gt; c:/github&lt;/div&gt;&lt;div class="line"&gt;git &lt;span class="built_in"&gt;clone&lt;/span&gt; git://github.com/imathis/octopress.git octopress &lt;/div&gt;&lt;div class="line"&gt;&lt;span class="built_in"&gt;cd&lt;/span&gt; octopress      &lt;span class="comment"&gt;#replace octopress with username.github.com  &lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;ruby --version  &lt;span class="comment"&gt;# Should report Ruby 1.9.3&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ruby 패키지들 (dependencies) 설치:&lt;/p&gt;
&lt;figure class="highlight bash"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;div class="line"&gt;1&lt;/div&gt;&lt;div class="line"&gt;2&lt;/div&gt;&lt;div class="line"&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;div class="line"&gt;&lt;span class="built_in"&gt;cd&lt;/span&gt; c:/github/octopress       &lt;span class="comment"&gt;#replace octopress with username.github.com&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;gem install bundler&lt;/div&gt;&lt;div class="line"&gt;bundle install&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;octporess의 기본 테마 설치:&lt;/p&gt;
&lt;figure class="highlight bash"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;div class="line"&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;div class="line"&gt;$ rake install&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;이부분에서 말을 안들을 수가 있는데, 뭔가 모듈의 버전이 맞지 않는 문제다.&lt;/p&gt;
&lt;figure class="highlight bash"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;div class="line"&gt;1&lt;/div&gt;&lt;div class="line"&gt;2&lt;/div&gt;&lt;div class="line"&gt;3&lt;/div&gt;&lt;div class="line"&gt;4&lt;/div&gt;&lt;div class="line"&gt;5&lt;/div&gt;&lt;div class="line"&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;div class="line"&gt;D:\Blog\DevNote&amp;gt;rake install&lt;/div&gt;&lt;div class="line"&gt;rake aborted!&lt;/div&gt;&lt;div class="line"&gt;You have already activated rake 0.9.6, but your Gemfile requires rake 0.9.2.2. P&lt;/div&gt;&lt;div class="line"&gt;repending `bundle &lt;span class="built_in"&gt;exec&lt;/span&gt;` to your &lt;span class="built_in"&gt;command&lt;/span&gt; may solve this.&lt;/div&gt;&lt;div class="line"&gt;D:/Blog/DevNote/Rakefile:2:&lt;span class="keyword"&gt;in&lt;/span&gt; `&amp;lt;top (required)&amp;gt;&lt;span class="string"&gt;'&lt;/span&gt;&lt;/div&gt;&lt;div class="line"&gt;&lt;span class="string"&gt;(See full trace by running task with --trace)&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;이 때 &lt;code&gt;bundle update rake&lt;/code&gt; 해주면 해결. &lt;a href="http://stackoverflow.com/questions/6080040/you-have-already-activated-rake-0-9-0-but-your-gemfile-requires-rake-0-8-7" target="_blank" rel="external"&gt;다음 글을 참고했다.&lt;/a&gt;&lt;/p&gt;
&lt;figure class="highlight bash"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;div class="line"&gt;1&lt;/div&gt;&lt;div class="line"&gt;2&lt;/div&gt;&lt;div class="line"&gt;3&lt;/div&gt;&lt;div class="line"&gt;4&lt;/div&gt;&lt;div class="line"&gt;5&lt;/div&gt;&lt;div class="line"&gt;6&lt;/div&gt;&lt;div class="line"&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;div class="line"&gt;D:\Blog\DevNote&amp;gt;bundle update rake&lt;/div&gt;&lt;div class="line"&gt;Fetching gem metadata from https://rubygems.org/.......&lt;/div&gt;&lt;div class="line"&gt;Fetching additional metadata from https://rubygems.org/..&lt;/div&gt;&lt;div class="line"&gt;Resolving dependencies...&lt;/div&gt;&lt;div class="line"&gt;Using rake (0.9.6)&lt;/div&gt;&lt;div class="line"&gt;...(중략)...&lt;/div&gt;&lt;div class="line"&gt;Your bundle is updated!&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id="Octopress를-Github-Pages용으로-설정"&gt;&lt;a href="#Octopress를-Github-Pages용으로-설정" class="headerlink" title="Octopress를 Github Pages용으로 설정"&gt;&lt;/a&gt;Octopress를 Github Pages용으로 설정&lt;/h1&gt;&lt;figure class="highlight bash"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;div class="line"&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;div class="line"&gt;$ rake setup_github_pages&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Github Pages는 계정 페이지와 프로젝트 페이지로 나뉜다.&lt;br&gt;각각의 경우에 따라 수동설정을 해주어야 하는데(이 부분은 두 번째 글에 잘 설명되어 있다.), 프로젝트 페이지의 경우가 조금 더 손댈 곳이 많다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;계정 페이지 설정인 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;_config.yml&lt;/code&gt;에서 url, title, subtitle, author 정도만 수정해주면 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트 페이지 설정의 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;먼저 &lt;code&gt;git remote&lt;/code&gt; 추가.&lt;/p&gt;
&lt;figure class="highlight bash"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;div class="line"&gt;1&lt;/div&gt;&lt;div class="line"&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;div class="line"&gt;$ git remote add origin `https://github.com/username/projectname.git&lt;/div&gt;&lt;div class="line"&gt;$ git config branch.master.remote origin&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;_config.yml, config.rb, Rakefile&lt;/code&gt; 을 열어서 &lt;code&gt;/github&lt;/code&gt;라고 된 부분을 repository 명으로 수정.&lt;/p&gt;
&lt;h1 id="한글-인코딩-문제-해결"&gt;&lt;a href="#한글-인코딩-문제-해결" class="headerlink" title="한글 인코딩 문제 해결"&gt;&lt;/a&gt;한글 인코딩 문제 해결&lt;/h1&gt;&lt;p&gt;이제 부푼 꿈을 안고 첫 포스팅을 만들어보면 잘 동작한다.&lt;br&gt;하지만.. 한글을 사용하면 다시 인코딩 관련 에러를 만나게 된다.&lt;br&gt;&lt;strong&gt;여기서 엄청난 시간을 소모&lt;/strong&gt;했는데, octopress 안에서 해결을 보려고 하니 힘들다. ruby는 한 번도 안써봐서 코드 보기도 힘들고 ㅡㅠ…&lt;br&gt;&lt;a href="http://www.qstata.com/blog/2013/06/20/rake-generate-utf-8-errors-on-windows/" target="_blank" rel="external"&gt;검색해보면&lt;/a&gt; jekyll 코드 일부를 직접 수정하는 방법도 있는데,&lt;br&gt;그것보다 cmd창의 코드 페이지를 변경해주면 간단하게 해결된다. &lt;/p&gt;
&lt;figure class="highlight bash"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;div class="line"&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;div class="line"&gt;chcp 65001 &lt;span class="comment"&gt;# 다시 되돌리려면 chcp 949&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;rake generate&lt;/code&gt;를 하거나 &lt;code&gt;rake preview&lt;/code&gt;를 하기 전에, 코드페이지를 항상 변경해주고 실행한다. batch파일을 미리 만들어두니 편하다.&lt;/p&gt;
&lt;p&gt;markdown 문법은 &lt;a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet" target="_blank" rel="external"&gt;검색하면&lt;/a&gt; 어렵지 않게 찾을 수 있다. &lt;/p&gt;
&lt;h1 id="블로그-내부-링크-만들기"&gt;&lt;a href="#블로그-내부-링크-만들기" class="headerlink" title="블로그 내부 링크 만들기"&gt;&lt;/a&gt;블로그 내부 링크 만들기&lt;/h1&gt;&lt;p&gt;기본으로 제공되는 기능이 없는듯? 플러그인 폴더에 아래 파일 하나 넣어주어야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/michael-groble/jekyll/blob/master/lib/jekyll/tags/post_url.rb" target="_blank" rel="external"&gt;https://github.com/michael-groble/jekyll/blob/master/lib/jekyll/tags/post_url.rb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://kqueue.org/blog/2012/01/05/hello-world/#internal-post-linking" target="_blank" rel="external"&gt;여기&lt;/a&gt; 에서 참고했다. 아래 문법을 사용한다.&lt;/p&gt;
&lt;figure class="highlight plain"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;div class="line"&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;div class="line"&gt;[link to this post](&amp;#123;% post_url 2012-01-05-hello-world %&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;eof.&lt;/p&gt;
&lt;img src="http://feeds.feedburner.com/~r/florist_devnote/~4/hCfM86TLBbo" height="1" width="1" alt=""/&gt;</content>
    
    <summary type="html">
    
      &lt;img src="/devnote/images/octopress.jpeg" class="center"&gt;
&lt;p&gt;octopress도 대게는 ruby가 기본 설치된 mac에서 많이들 사용하는 듯 하다. 검색해보면 대부분 OS X를 기준으로 한 셋팅법이다. 
    
    </summary>
    
    
      <category term="octopress" scheme="http://leafbird.github.io/devnote/tags/octopress/" />
    
      <category term="windows" scheme="http://leafbird.github.io/devnote/tags/windows/" />
    
      <category term="encoding" scheme="http://leafbird.github.io/devnote/tags/encoding/" />
    
  <feedburner:origLink>http://leafbird.github.io/devnote/2013/12/octopress-on-windows/</feedburner:origLink></entry>
  
</feed>
