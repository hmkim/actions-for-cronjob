<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://sangyun-han.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="http://sangyun-han.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2019-04-16T14:07:43+00:00</updated><id>http://sangyun-han.github.io/feed.xml</id><title type="html">Hello World</title><subtitle>I'm Sangyun Han.</subtitle><author><name>Sangyun Han</name><email>sangyun628@gmail.com</email></author><entry><title type="html">Open Source</title><link href="http://sangyun-han.github.io/blog/2018/08/15/open_source/" rel="alternate" type="text/html" title="Open Source" /><published>2018-08-15T00:00:00+00:00</published><updated>2018-08-15T00:00:00+00:00</updated><id>http://sangyun-han.github.io/blog/2018/08/15/open_source</id><content type="html" xml:base="http://sangyun-han.github.io/blog/2018/08/15/open_source/">&lt;h1 id=&quot;heading-open-source란&quot;&gt;Open Source란?&lt;/h1&gt;

&lt;h2 id=&quot;heading-정의&quot;&gt;정의&lt;/h2&gt;
&lt;p&gt;소스코드에 대한 접근, 자유로운 재배포, 파생 저작물의 작성, 제한 없는 사용 등을 허용하는 라이선스와 함께 배포되는 소프트웨어.&lt;/p&gt;

&lt;p&gt;오픈소스의 핵심 정의 요소 중 하나는 라이선스이며, 오픈소스는 이들의 라이선스의 요구사항을 반드시 만족시켜야 한다.&lt;/p&gt;

&lt;h2 id=&quot;heading-특징&quot;&gt;특징&lt;/h2&gt;
&lt;p&gt;오픈소스와 기존 소프트웨어와 설계부터 뚜렷하게 구분된다. 설계, 개발, 테스트, 유지보수 등의 단계들은 같지만 오픈소스 커뮤니티는 구현, 테스트, 지원에 훨씬 많은 시간과 노력을 들이고 사용자 요건이나 설계 사양에는 비교적 덜 집중한다. 독점 프로젝트들은 코드를 작성하기도 전에 기획이나 시장 분석, 내부 승인 등의 과정으로 몇 달이 소요될 수 있다. 그러나 오픈소스 프로젝트는 어느 한 사람이 코드 일부를 작성하고 그것을 온라인에 올리면, 바로 시작될 수 있다.&lt;/p&gt;

&lt;p&gt;기술과 혁신의 과정과 그 성과를 민주화할 수 있는 것이 오픈소스이다.&lt;/p&gt;

&lt;h2 id=&quot;heading-사례&quot;&gt;사례&lt;/h2&gt;
&lt;p&gt;IBM은 가장 먼저 오픈소스 기여 체계를 갖춘 기업 중 하나이다. 원래 하드웨어 중심의 사업 모델에서 소프트웨어 산업으로 전환하면서 오픈소스 기여 활동을 시작했다. 현재에도 가장 많은 커미터를 보유한 기업으로 알려져 있다. 그들은 오픈소스 소프트웨어와 프로세스를 수용하는 데 그치지 않고 자신들의 지적 재산을 독점 소유함으로써 이윤을 얻는 대신에, 품질을 향상시키고 성장을 촉진하는 철학을 받아들였다. 오픈소스 덕분에 혁신의 속도를 높이고 막대한 비용 부담을 덜 수 있었다.&lt;/p&gt;

&lt;h2 id=&quot;heading-의의&quot;&gt;의의&lt;/h2&gt;
&lt;h3 id=&quot;heading-기여의-의의&quot;&gt;기여의 의의&lt;/h3&gt;
&lt;p&gt;과거에는 수많은 기업들이 오픈소스를 저작권료를 지불하지 않고 부족한 기술을 확보할 수 있는 수단 정도로만 여기고 단순한 활용에만 그치는 경우가 많았다. 그러나 공유와 협력을 기반으로 빠르게 확산되는 오픈소스의 위력을 실감하면서 오픈소스 활용 패러다임은 변화하고 있다. 많은 기업들이 오픈소스 기여를 통해 개발 및 유지/보수 비용을 절감하고, 타 기업 또는 외부 개바자와의 협력 개발을 추진하고 있다. 그리고 최근에는 오픈소스를 기반으로 해당 기술분야의 주도권 확보 경쟁에 나서고 있다. 소프트웨어 기술 분야의 주도권을 확보하기 위한 수단으로 오픈소스 기여는 더 이상 선택이 아니라 필수에 가깝다.&lt;/p&gt;

&lt;h2 id=&quot;heading-나의-생각&quot;&gt;나의 생각&lt;/h2&gt;

&lt;p&gt;오픈소스는 세상을 바꿀 수 있는 새로운 공유 패러다임이라고 생각한다. 앞으로 어떤 집단이나 사회가 더 빠른 속력으로 발전하느냐는 누가 더 지식의 공유를 제대로 했는가에 달렸다고 생각한다. 지식 공유는 한 사람이 쌓은 탑에 다른 사람이 올라가 더 높이 벽돌을 쌓고, 또 다른 사람이 그 위에 벽돌을 올리는 것인데 이것이 바로 오픈소스의 힘이자 핵심 가치이다. 전 세계의 그 누구도 혼자서 탑을 쌓아서는 경쟁력을 확보할 수 없으며 한쪽으로 치우쳐 결국 무너지게 될 것이다. 특히나 IT 분야는 다양하고 빠르게 발전하기 때문에 공개와 공유를 통해 지속적인 방향 수정과 성장동력을 얻어야 한다고 생각한다.&lt;/p&gt;

&lt;p&gt;다수의 동등계층 생산으로 형성된 오픈소스를 통해 기존의 것을 바탕으로 더 나은 것을 만들고 접근성을 낮춰 누구나 사용하고, 다시 부족한 것을 기여하거나 새로운 프로젝트로 분화해가면서 선순환이 이뤄진다. 오픈소스는 누구나 자신의 아이디어를 제시하고 실체화할 수 있도록 도와주는 인프라 같은 역할을 하고 있으며 이로써 진정한 정보와 기술의 민주화를 가져와 세상을 이롭게 발전시킬 수 있다.&lt;/p&gt;</content><author><name>Sangyun Han</name><email>sangyun628@gmail.com</email></author><category term="opensource" /><summary type="html">Open Source란? 정의 소스코드에 대한 접근, 자유로운 재배포, 파생 저작물의 작성, 제한 없는 사용 등을 허용하는 라이선스와 함께 배포되는 소프트웨어. 오픈소스의 핵심 정의 요소 중 하나는 라이선스이며, 오픈소스는 이들의 라이선스의 요구사항을 반드시 만족시켜야 한다. 특징 오픈소스와 기존 소프트웨어와 설계부터 뚜렷하게 구분된다. 설계, 개발, 테스트, 유지보수 등의 단계들은 같지만 오픈소스 커뮤니티는 구현, 테스트, 지원에 훨씬 많은 시간과 노력을 들이고 사용자 요건이나 설계 사양에는 비교적 덜 집중한다. 독점 프로젝트들은 코드를 작성하기도 전에 기획이나 시장 분석, 내부 승인 등의 과정으로 몇 달이 소요될 수 있다. 그러나 오픈소스 프로젝트는 어느 한 사람이 코드 일부를 작성하고 그것을 온라인에 올리면, 바로 시작될 수 있다. 기술과 혁신의 과정과 그 성과를 민주화할 수 있는 것이 오픈소스이다. 사례 IBM은 가장 먼저 오픈소스 기여 체계를 갖춘 기업 중 하나이다. 원래 하드웨어 중심의 사업 모델에서 소프트웨어 산업으로 전환하면서 오픈소스 기여 활동을 시작했다. 현재에도 가장 많은 커미터를 보유한 기업으로 알려져 있다. 그들은 오픈소스 소프트웨어와 프로세스를 수용하는 데 그치지 않고 자신들의 지적 재산을 독점 소유함으로써 이윤을 얻는 대신에, 품질을 향상시키고 성장을 촉진하는 철학을 받아들였다. 오픈소스 덕분에 혁신의 속도를 높이고 막대한 비용 부담을 덜 수 있었다. 의의 기여의 의의 과거에는 수많은 기업들이 오픈소스를 저작권료를 지불하지 않고 부족한 기술을 확보할 수 있는 수단 정도로만 여기고 단순한 활용에만 그치는 경우가 많았다. 그러나 공유와 협력을 기반으로 빠르게 확산되는 오픈소스의 위력을 실감하면서 오픈소스 활용 패러다임은 변화하고 있다. 많은 기업들이 오픈소스 기여를 통해 개발 및 유지/보수 비용을 절감하고, 타 기업 또는 외부 개바자와의 협력 개발을 추진하고 있다. 그리고 최근에는 오픈소스를 기반으로 해당 기술분야의 주도권 확보 경쟁에 나서고 있다. 소프트웨어 기술 분야의 주도권을 확보하기 위한 수단으로 오픈소스 기여는 더 이상 선택이 아니라 필수에 가깝다. 나의 생각 오픈소스는 세상을 바꿀 수 있는 새로운 공유 패러다임이라고 생각한다. 앞으로 어떤 집단이나 사회가 더 빠른 속력으로 발전하느냐는 누가 더 지식의 공유를 제대로 했는가에 달렸다고 생각한다. 지식 공유는 한 사람이 쌓은 탑에 다른 사람이 올라가 더 높이 벽돌을 쌓고, 또 다른 사람이 그 위에 벽돌을 올리는 것인데 이것이 바로 오픈소스의 힘이자 핵심 가치이다. 전 세계의 그 누구도 혼자서 탑을 쌓아서는 경쟁력을 확보할 수 없으며 한쪽으로 치우쳐 결국 무너지게 될 것이다. 특히나 IT 분야는 다양하고 빠르게 발전하기 때문에 공개와 공유를 통해 지속적인 방향 수정과 성장동력을 얻어야 한다고 생각한다. 다수의 동등계층 생산으로 형성된 오픈소스를 통해 기존의 것을 바탕으로 더 나은 것을 만들고 접근성을 낮춰 누구나 사용하고, 다시 부족한 것을 기여하거나 새로운 프로젝트로 분화해가면서 선순환이 이뤄진다. 오픈소스는 누구나 자신의 아이디어를 제시하고 실체화할 수 있도록 도와주는 인프라 같은 역할을 하고 있으며 이로써 진정한 정보와 기술의 민주화를 가져와 세상을 이롭게 발전시킬 수 있다.</summary></entry><entry><title type="html">Remarkable Open Source Projects</title><link href="http://sangyun-han.github.io/blog/2018/08/08/open_source_project/" rel="alternate" type="text/html" title="Remarkable Open Source Projects" /><published>2018-08-08T00:00:00+00:00</published><updated>2018-08-08T00:00:00+00:00</updated><id>http://sangyun-han.github.io/blog/2018/08/08/open_source_project</id><content type="html" xml:base="http://sangyun-han.github.io/blog/2018/08/08/open_source_project/">&lt;h1 id=&quot;heading-remarkable-open-source-project&quot;&gt;Remarkable Open Source Project&lt;/h1&gt;

&lt;h2 id=&quot;heading-network&quot;&gt;Network&lt;/h2&gt;
&lt;h3 id=&quot;heading-sdn&quot;&gt;SDN&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://onosproject.org/&quot;&gt;ONOS(Open Network Operating System)&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;A distributed SDN controller.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OpenDaylight&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://mininet.org/&quot;&gt;Mininet&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;Mininet creates a realistic virtual network, running real kernel, switch and application code, on a single machine (VM, cloud or native), in seconds, with a single command.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;loxigen&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ovx.onlab.us/&quot;&gt;OpenVirteX&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;OpenVirteX(OVX) is a network hypervisor that can create multiple virtual and programmable networks on top of a single physical infrastructure.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;heading-framework&quot;&gt;Framework&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Netty&lt;/li&gt;
  &lt;li&gt;MINA&lt;/li&gt;
  &lt;li&gt;Vert.X&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;heading-distributed-system&quot;&gt;Distributed System&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://hazelcast.org/&quot;&gt;Hazelcast&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://atomix.io/&quot;&gt;Atomix&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;A reactive java framework for building fault-tolerance distributed system&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Zookeeper&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://coreos.com/etcd/&quot;&gt;etcd&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;etcd is a distributed key-value store that provides a reliable way to store data across a cluster of machines.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://coreos.com/&quot;&gt;CoreOS&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;CoreOS is open source lightweight operating system based on the Linux kernel and designed for providing infrastructure to clustered deployments, while focusing on automation, ease of application deployment, security, reliability and scalability.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;heading-monitoring&quot;&gt;Monitoring&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://prometheus.io/&quot;&gt;Graphite&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://prometheus.io/&quot;&gt;Prometheus&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://opentsdb.net&quot;&gt;OpenTSDB&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blueflood.io/&quot;&gt;BlueFlood&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/google/cadvisor&quot;&gt;cAdvisor&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;cAdvisor (Container Advisor) provides container users an understanding of the resource usage and performance characteristics of their running containers. It is a running daemon that collects, aggregates, processes, and exports information about running containers.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/firehol/netdata&quot;&gt;netdata&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;netdata is a system for distributed real-time performance, health monitoring, and visualization.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;heading-unclassified&quot;&gt;Unclassified&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;OpenConfig&lt;/li&gt;
  &lt;li&gt;gNMI&lt;/li&gt;
  &lt;li&gt;scapy&lt;/li&gt;
  &lt;li&gt;Docker&lt;/li&gt;
  &lt;li&gt;OpenBTS&lt;/li&gt;
  &lt;li&gt;Karaf&lt;/li&gt;
  &lt;li&gt;Kafka&lt;/li&gt;
  &lt;li&gt;OpenStack&lt;/li&gt;
  &lt;li&gt;Mesos&lt;/li&gt;
  &lt;li&gt;gRPC&lt;/li&gt;
  &lt;li&gt;Ceph&lt;/li&gt;
  &lt;li&gt;Project Calico&lt;/li&gt;
  &lt;li&gt;RIFT.IO(RIFT.ware)&lt;/li&gt;
  &lt;li&gt;Vizceral&lt;/li&gt;
  &lt;li&gt;uftrace&lt;/li&gt;
  &lt;li&gt;OpenWhisk&lt;/li&gt;
  &lt;li&gt;OpenFaas&lt;/li&gt;
  &lt;li&gt;FD.io - VPP&lt;/li&gt;
  &lt;li&gt;Cilium&lt;/li&gt;
  &lt;li&gt;Skydive-project&lt;/li&gt;
  &lt;li&gt;Seesaw&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Sangyun Han</name><email>sangyun628@gmail.com</email></author><category term="opensource" /><summary type="html">Remarkable Open Source Project Network SDN ONOS(Open Network Operating System) A distributed SDN controller. OpenDaylight Mininet Mininet creates a realistic virtual network, running real kernel, switch and application code, on a single machine (VM, cloud or native), in seconds, with a single command. loxigen OpenVirteX OpenVirteX(OVX) is a network hypervisor that can create multiple virtual and programmable networks on top of a single physical infrastructure. Framework Netty MINA Vert.X Distributed System Hazelcast Atomix A reactive java framework for building fault-tolerance distributed system Zookeeper etcd etcd is a distributed key-value store that provides a reliable way to store data across a cluster of machines. CoreOS CoreOS is open source lightweight operating system based on the Linux kernel and designed for providing infrastructure to clustered deployments, while focusing on automation, ease of application deployment, security, reliability and scalability. Monitoring Graphite Prometheus OpenTSDB BlueFlood cAdvisor cAdvisor (Container Advisor) provides container users an understanding of the resource usage and performance characteristics of their running containers. It is a running daemon that collects, aggregates, processes, and exports information about running containers. netdata netdata is a system for distributed real-time performance, health monitoring, and visualization. Unclassified OpenConfig gNMI scapy Docker OpenBTS Karaf Kafka OpenStack Mesos gRPC Ceph Project Calico RIFT.IO(RIFT.ware) Vizceral uftrace OpenWhisk OpenFaas FD.io - VPP Cilium Skydive-project Seesaw</summary></entry><entry><title type="html">[Golang] 특징과 장점</title><link href="http://sangyun-han.github.io/blog/2018/06/30/Golang/" rel="alternate" type="text/html" title="[Golang] 특징과 장점" /><published>2018-06-30T00:00:00+00:00</published><updated>2018-06-30T00:00:00+00:00</updated><id>http://sangyun-han.github.io/blog/2018/06/30/Golang</id><content type="html" xml:base="http://sangyun-han.github.io/blog/2018/06/30/Golang/">&lt;h1 id=&quot;heading-go언어golang&quot;&gt;Go언어(Golang)&lt;/h1&gt;

&lt;p&gt;Go언어를 단순하게 표현하면 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Simplicity&lt;/li&gt;
  &lt;li&gt;Pragmatism&lt;/li&gt;
  &lt;li&gt;Concurrency&lt;/li&gt;
  &lt;li&gt;Scalability&lt;/li&gt;
  &lt;li&gt;Compile Language&lt;/li&gt;
  &lt;li&gt;Cross Platform&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Not the feature of Go&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;No classes&lt;/li&gt;
  &lt;li&gt;No inheritance&lt;/li&gt;
  &lt;li&gt;No constructors&lt;/li&gt;
  &lt;li&gt;No final&lt;/li&gt;
  &lt;li&gt;No exceptions&lt;/li&gt;
  &lt;li&gt;No annotations&lt;/li&gt;
  &lt;li&gt;No user-defined generics&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Go언어는 2009년에 구글이 만든 프로그래밍 언어다. Go언어는 데니스 리치와 함께 유닉스와 C언어를 개발한 켄 톰슨 외 컴퓨터 과학계에서 저명한 롭 파이크, 로버트 그리즈머에 의해 설계 및 개발되었다. &quot;40년 동안의 프로그래밍 언어에 대한 연구를 던져버린 유일한 언어&quot;라는 평가를 받고 있다.&lt;/p&gt;

&lt;p&gt;Go라는 이름으로 검색하기 힘들다면 golang(go language) 또는 외국에서 많이 부르는 gopher라고 검색하면 편하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;빠른 개발속도&lt;/li&gt;
  &lt;li&gt;모듈화를 위한 의존성&lt;/li&gt;
  &lt;li&gt;정적타입이지만 동적타입 언어의 속성도 가진 언어&lt;/li&gt;
  &lt;li&gt;Garbage Collection with no VM&lt;/li&gt;
  &lt;li&gt;쉬운 병렬처리&lt;/li&gt;
  &lt;li&gt;빠른 컴파일 속도&lt;/li&gt;
  &lt;li&gt;소스코드 UTF-8&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;heading-simplicity&quot;&gt;Simplicity&lt;/h3&gt;
&lt;p&gt;프로그래밍 언어에서는 기본적으로 사용되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt; 등과 같은 키워드들이 정의되어 있다. Go언어는 25개의 키워드만으로 프로그래밍이 가능하며, 이는 자바의 절반에 해당하는 수준이다. 무조건 키워드가 적다고 간단하고 배우기 쉬운 언어는 아니지만 일단 키워드가 적으면 문법 익히는 것이 빨라지며 복잡도가 떨어질 수 있다.&lt;/p&gt;

&lt;p&gt;또한 가비지 컬렉터가 있어 C와 C++과 달리 메모리 관리를 신경쓰지 않아도 된다. 메모리를 직접 할당하고 해제하는 작업이 없음에도 C와 C++처럼 포인터가 존재한다. 이 부분도 Go언어의 흥미로운 점 중 하나이다.&lt;/p&gt;

&lt;h3 id=&quot;heading-클라우드와-친한-언어&quot;&gt;클라우드와 친한 언어&lt;/h3&gt;
&lt;p&gt;단순함과 병렬성 등의 특징으로 인해 클라우드 환경, 그리고 최근 주목받고 있는 마이크로 서비스 아키텍처에 적절한 프로그래밍 언어로 평가받고 있다.&lt;/p&gt;

&lt;h3 id=&quot;heading-컴파일-언어&quot;&gt;컴파일 언어&lt;/h3&gt;
&lt;p&gt;컴파일 언어지만 컴파일러의 컴파일 속도가 매우 빨라서 인터프리터 언어처럼 사용할 수 있다. 예를 들어 특정 코드를 짜놓고 &lt;code class=&quot;highlighter-rouge&quot;&gt;go run&lt;/code&gt;으로 돌리면 마치 파이썬을 사용하는 것처럼 빠르고 간편하게 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;자바나 C#처럼 특정 환경에서만 돌아가는 바이트코드를 생성하는 방식이 아닌 C, C++처럼 완전한 네이티브 바이너리 실행파일을 만들어 낸다. 따라서 가상머신도 필요 없어서 실행환경이 간단하며, 실행파일 내에 라이브러리를 포함하여 배포가 쉽다.&lt;/p&gt;

&lt;p&gt;단, 바이너리 컴파일러이기 때문에 서로 다른 플랫폼을 타겟으로 배포해야 할 경우 환경변수인 GOOS와 GOARCH 등을 재설정한 후 컴파일해서 여러 개의 배포한을 만들어야 한다.&lt;/p&gt;

&lt;h3 id=&quot;heading-goroutine&quot;&gt;Goroutine&lt;/h3&gt;
&lt;p&gt;Go는 Goroutine이라는 언어 차원에서 동시성과 병렬성을 지원한다. Goroutine은 멀티쓰레드 매커니즘의 경량 쓰레드 방식이며 자체적인 스케줄러에 의해 관리되기 때문에 OS에서 관리하는 쓰레드보다 더 가볍고 높은 성능을 보장한다. 자바의 쓰레드의 경우 1MB의 메모리가 필요하지만 go는 2KB의 스택 공간만 필요하다. Context switching 비용 또한 고루틴이 더 적다. 쓰레드는 blocking될 경우 다른 쓰레드가 그 자리를 스케줄링한다. 이렇게 바뀌는 과정에서 모든 레지스터들을 저장 및 복구해야 한다. 쓰레드는 16개의 범용 레지스터, PC, SP, segment 레지스터, 16개의 XMM 레지스터 등 많은 것들을 저장 및 복구해야 하지만 Goroutine은 3개의 레지스터(PC, SP, DX)만 저장 및 복구하면 된다.&lt;/p&gt;

&lt;p&gt;Goroutine은 일급 객체(First Class)로 정수나 실수와 같은 데이터 타입과 동급으로 취급된다.&lt;/p&gt;

&lt;p&gt;비동기 메커니즘을 제공한다. Go의 병행 처리 방식은 Communicating Sequential Processes(CSP) 방식에 근간을 두고 있어서 메모리를 공유하는 것이 아니라 메시지를 전달하는 방식으로 동기화가 된다. 각각의 고루틴은 병렬로 동작하며 메시지 채널을 통해 값을 주고 받는다. 고루틴을 사용하면 이벤트 처리, 병렬 프로그래밍 등이 훨씬 간단해진다. 단, 병렬화된 고루틴의 동기화 문제는 프로그래머가 다뤄야 하며 동기화를 무시할 경우 프로그램이 비정상 종료될 수도 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;goroutine은 OS 쓰레드보다 훨씬 가볍게 비동기 concurrent 처리를 구현하기 위해 만든 것으로, 기본적으로 Go 런타임이 자체 관리한다. Go 런타임 상에서 관리되는 작업단위인 여러 goroutine들은 종종 하나의 OS쓰레드 1개로도 실행되곤 한다. 즉, goroutine들은 OS쓰레드와 1:1 대응되지 않고, multiplexing으로 훨씬 적은 OS쓰레드를 사용한다. 메모리 측면에서도 OS쓰레드가 1메가바이트의 스택을 갖는 반면, goroutine은 이보다 훨씬 작은 몇 킬로바이트의 스택을 갖는다. 필요시 동적으로 증가할 수도 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;heading-가비지-컬렉터&quot;&gt;가비지 컬렉터&lt;/h3&gt;
&lt;p&gt;자바와 같이 주로 가상머신 위에서 실행되는 언어들은 별도의 플랫폼 위에서 인스턴스의 할당 및 해제 작업을 해줌으로써 메모리를 관리하는 가비지 컬렉터가 존재한다. Go도 역시 가비지 컬렉터가 있지만 실행파일 내에 내장되어 있어 별도의 가상머신이나 플랫폼이 필요하지 않다.&lt;/p&gt;

&lt;h3 id=&quot;heading-패키지&quot;&gt;패키지&lt;/h3&gt;
&lt;p&gt;Go는 언어 자체적으로 python의 pip나 java의 maven와 같은 온라인 상의 패키지나 의존성을 관리해주는 기능이 내장되어 있다. 소스코드 내에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;import&lt;/code&gt; 키워드를 통해 github와 같은 인터넷 저장소의 주소를 지정해서 가져올 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;heading-참고자료-및-요약&quot;&gt;참고자료 및 요약&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=5NsUPbdKOF8&quot;&gt;[NDC] golang으로 네트워크 프로그래밍 하기&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Go언어는 병렬 프로그래밍과 네트워크 프로그래밍에 특화되어 있다.&lt;/li&gt;
  &lt;li&gt;Go는 C언어가 진화된 것으로 C++과는 다르다.&lt;/li&gt;
  &lt;li&gt;고루틴은 stateless에서는 아주 좋지만 statefull에서는 한계가 있다.&lt;/li&gt;
  &lt;li&gt;대규모 분산 게임 서버에는 Front Server(클라이언트와 서버 간의 패킷 전달)는 stateless에 가깝고, 컨텐츠 로직이 없으므로 Go언어를 사용하면 아주 좋다.&lt;/li&gt;
  &lt;li&gt;메모리 자동 관리
    &lt;ul&gt;
      &lt;li&gt;VM이 아니다!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;네트워크 프로그래밍&lt;/li&gt;
  &lt;li&gt;병렬 프로그래밍&lt;/li&gt;
  &lt;li&gt;goroutine&lt;/li&gt;
  &lt;li&gt;크로스 플랫폼 개발이 쉽다&lt;/li&gt;
  &lt;li&gt;네트워크에서 IOCP 지원&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Sangyun Han</name><email>sangyun628@gmail.com</email></author><category term="golang" /><summary type="html">Go언어(Golang) Go언어를 단순하게 표현하면 아래와 같다. Simplicity Pragmatism Concurrency Scalability Compile Language Cross Platform Not the feature of Go No classes No inheritance No constructors No final No exceptions No annotations No user-defined generics Go언어는 2009년에 구글이 만든 프로그래밍 언어다. Go언어는 데니스 리치와 함께 유닉스와 C언어를 개발한 켄 톰슨 외 컴퓨터 과학계에서 저명한 롭 파이크, 로버트 그리즈머에 의해 설계 및 개발되었다. &quot;40년 동안의 프로그래밍 언어에 대한 연구를 던져버린 유일한 언어&quot;라는 평가를 받고 있다. Go라는 이름으로 검색하기 힘들다면 golang(go language) 또는 외국에서 많이 부르는 gopher라고 검색하면 편하다. 빠른 개발속도 모듈화를 위한 의존성 정적타입이지만 동적타입 언어의 속성도 가진 언어 Garbage Collection with no VM 쉬운 병렬처리 빠른 컴파일 속도 소스코드 UTF-8 Simplicity 프로그래밍 언어에서는 기본적으로 사용되는 if, switch 등과 같은 키워드들이 정의되어 있다. Go언어는 25개의 키워드만으로 프로그래밍이 가능하며, 이는 자바의 절반에 해당하는 수준이다. 무조건 키워드가 적다고 간단하고 배우기 쉬운 언어는 아니지만 일단 키워드가 적으면 문법 익히는 것이 빨라지며 복잡도가 떨어질 수 있다. 또한 가비지 컬렉터가 있어 C와 C++과 달리 메모리 관리를 신경쓰지 않아도 된다. 메모리를 직접 할당하고 해제하는 작업이 없음에도 C와 C++처럼 포인터가 존재한다. 이 부분도 Go언어의 흥미로운 점 중 하나이다. 클라우드와 친한 언어 단순함과 병렬성 등의 특징으로 인해 클라우드 환경, 그리고 최근 주목받고 있는 마이크로 서비스 아키텍처에 적절한 프로그래밍 언어로 평가받고 있다. 컴파일 언어 컴파일 언어지만 컴파일러의 컴파일 속도가 매우 빨라서 인터프리터 언어처럼 사용할 수 있다. 예를 들어 특정 코드를 짜놓고 go run으로 돌리면 마치 파이썬을 사용하는 것처럼 빠르고 간편하게 사용할 수 있다. 자바나 C#처럼 특정 환경에서만 돌아가는 바이트코드를 생성하는 방식이 아닌 C, C++처럼 완전한 네이티브 바이너리 실행파일을 만들어 낸다. 따라서 가상머신도 필요 없어서 실행환경이 간단하며, 실행파일 내에 라이브러리를 포함하여 배포가 쉽다. 단, 바이너리 컴파일러이기 때문에 서로 다른 플랫폼을 타겟으로 배포해야 할 경우 환경변수인 GOOS와 GOARCH 등을 재설정한 후 컴파일해서 여러 개의 배포한을 만들어야 한다. Goroutine Go는 Goroutine이라는 언어 차원에서 동시성과 병렬성을 지원한다. Goroutine은 멀티쓰레드 매커니즘의 경량 쓰레드 방식이며 자체적인 스케줄러에 의해 관리되기 때문에 OS에서 관리하는 쓰레드보다 더 가볍고 높은 성능을 보장한다. 자바의 쓰레드의 경우 1MB의 메모리가 필요하지만 go는 2KB의 스택 공간만 필요하다. Context switching 비용 또한 고루틴이 더 적다. 쓰레드는 blocking될 경우 다른 쓰레드가 그 자리를 스케줄링한다. 이렇게 바뀌는 과정에서 모든 레지스터들을 저장 및 복구해야 한다. 쓰레드는 16개의 범용 레지스터, PC, SP, segment 레지스터, 16개의 XMM 레지스터 등 많은 것들을 저장 및 복구해야 하지만 Goroutine은 3개의 레지스터(PC, SP, DX)만 저장 및 복구하면 된다. Goroutine은 일급 객체(First Class)로 정수나 실수와 같은 데이터 타입과 동급으로 취급된다. 비동기 메커니즘을 제공한다. Go의 병행 처리 방식은 Communicating Sequential Processes(CSP) 방식에 근간을 두고 있어서 메모리를 공유하는 것이 아니라 메시지를 전달하는 방식으로 동기화가 된다. 각각의 고루틴은 병렬로 동작하며 메시지 채널을 통해 값을 주고 받는다. 고루틴을 사용하면 이벤트 처리, 병렬 프로그래밍 등이 훨씬 간단해진다. 단, 병렬화된 고루틴의 동기화 문제는 프로그래머가 다뤄야 하며 동기화를 무시할 경우 프로그램이 비정상 종료될 수도 있다. goroutine은 OS 쓰레드보다 훨씬 가볍게 비동기 concurrent 처리를 구현하기 위해 만든 것으로, 기본적으로 Go 런타임이 자체 관리한다. Go 런타임 상에서 관리되는 작업단위인 여러 goroutine들은 종종 하나의 OS쓰레드 1개로도 실행되곤 한다. 즉, goroutine들은 OS쓰레드와 1:1 대응되지 않고, multiplexing으로 훨씬 적은 OS쓰레드를 사용한다. 메모리 측면에서도 OS쓰레드가 1메가바이트의 스택을 갖는 반면, goroutine은 이보다 훨씬 작은 몇 킬로바이트의 스택을 갖는다. 필요시 동적으로 증가할 수도 있다. 가비지 컬렉터 자바와 같이 주로 가상머신 위에서 실행되는 언어들은 별도의 플랫폼 위에서 인스턴스의 할당 및 해제 작업을 해줌으로써 메모리를 관리하는 가비지 컬렉터가 존재한다. Go도 역시 가비지 컬렉터가 있지만 실행파일 내에 내장되어 있어 별도의 가상머신이나 플랫폼이 필요하지 않다. 패키지 Go는 언어 자체적으로 python의 pip나 java의 maven와 같은 온라인 상의 패키지나 의존성을 관리해주는 기능이 내장되어 있다. 소스코드 내에서 import 키워드를 통해 github와 같은 인터넷 저장소의 주소를 지정해서 가져올 수 있다. 참고자료 및 요약 [NDC] golang으로 네트워크 프로그래밍 하기 Go언어는 병렬 프로그래밍과 네트워크 프로그래밍에 특화되어 있다. Go는 C언어가 진화된 것으로 C++과는 다르다. 고루틴은 stateless에서는 아주 좋지만 statefull에서는 한계가 있다. 대규모 분산 게임 서버에는 Front Server(클라이언트와 서버 간의 패킷 전달)는 stateless에 가깝고, 컨텐츠 로직이 없으므로 Go언어를 사용하면 아주 좋다. 메모리 자동 관리 VM이 아니다! 네트워크 프로그래밍 병렬 프로그래밍 goroutine 크로스 플랫폼 개발이 쉽다 네트워크에서 IOCP 지원</summary></entry><entry><title type="html">[TSDB] Prometheus</title><link href="http://sangyun-han.github.io/blog/2018/06/20/Prometheus/" rel="alternate" type="text/html" title="[TSDB] Prometheus" /><published>2018-06-20T00:00:00+00:00</published><updated>2018-06-20T00:00:00+00:00</updated><id>http://sangyun-han.github.io/blog/2018/06/20/Prometheus</id><content type="html" xml:base="http://sangyun-han.github.io/blog/2018/06/20/Prometheus/">&lt;h1 id=&quot;heading-prometheus&quot;&gt;Prometheus&lt;/h1&gt;</content><author><name>Sangyun Han</name><email>sangyun628@gmail.com</email></author><category term="tsdb" /><category term="monitoring" /><summary type="html">Prometheus</summary></entry></feed>