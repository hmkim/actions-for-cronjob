<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>개발자노트</title>
<link>https://jhleed.tistory.com/</link>
<description>Stay hungry, stay foolish. 
자만하지 말고 항상 배우자</description>
<language>ko</language>
<pubDate>Mon, 13 May 2019 22:47:44 +0900</pubDate>
<generator>TISTORY</generator>
<managingEditor>James Lee.</managingEditor>
<image>
<title>개발자노트</title>
<url>http://cfile4.uf.tistory.com/image/99A0DB395A6F833D3E31E2</url>
<link>https://jhleed.tistory.com</link>
<description>Stay hungry, stay foolish. 
자만하지 말고 항상 배우자</description>
</image>
<item>
<title>[Javascript] 클로저(Closure)란?</title>
<link>https://jhleed.tistory.com/150</link>
<description>&lt;article class=&quot;markdown-body entry-content&quot; itemprop=&quot;text&quot;&gt; &lt;h1 id=&quot;javascript-클로저closure란&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99BCEF4A5CD3BEE906&quot; alt=&quot;&quot; style=&quot;font-size: 13px;&quot;&gt;&lt;/h1&gt;
&lt;p&gt;클로저를 정의하는 말들은 여러가지가 있다. MDN에서는 아래와 같이 설명한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;클로저는 독립적인 (자유) 변수를 가리키는 함수이다. 또는, 클로저 안에 정의된 함수는 만들어진 환경을 ‘기억한다’.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이게 무슨 말인가? 언뜻 봐서는 이해가 잘 가지 않는다.&lt;/p&gt;
&lt;p&gt;클로저가 무엇인지 딱 한마디로 설명할 수 있기 위해 글을 정리한다.&lt;/p&gt;
&lt;h3 id=&quot;무엇인가&quot;&gt;무엇인가?&lt;/h3&gt;
&lt;p&gt;쉽게 말하면, 클로저는 &lt;strong&gt;함수 내부에 정의된 함수&lt;/strong&gt;를 의미하며 조금 더 풀어서 설명하면&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;내부함수가 외부함수의 컨텍스트에 접근할 수 있는 것&lt;/strong&gt;을 가르킨다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;특징 : 외부함수가 소멸된 이후에도 내부함수가 소멸된 외부함수의 변수에 접근 할 수 있다.&lt;ul&gt;
&lt;li&gt;메모리에서는 여전히 기억하고 있기 때문에&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;이런 메커니즘을 클로저라고 한다.&lt;ul&gt;
&lt;li&gt;Closure라는 이름은 외부함수가 소멸된(Close) 이후에도 접근할 수 있는 것과 관계가 있었던 것으로 기억한다.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예시)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function outter(){
    var title = 'coding everybody';  
    return function(){        
        alert(title);
    }
}
inner = outter();
inner(); // coding everybdoy&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고 문서&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://opentutorials.org/course/743/6544&quot;&gt;https://opentutorials.org/course/743/6544&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@khwsc1/%EB%B2%88%EC%97%AD-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8A%A4%EC%BD%94%ED%94%84%EC%99%80-%ED%81%B4%EB%A1%9C%EC%A0%80-javascript-scope-and-closures-8d402c976d19&quot;&gt;https://medium.com/@khwsc1/번역-자바스크립트-스코프와-클로저-javascript-scope-and-closures-8d402c976d19&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt; &lt;/article&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jhleed.tistory.com/150&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Javascript</category>
<author>James Lee.</author>
<guid>https://jhleed.tistory.com/150</guid>
<comments>https://jhleed.tistory.com/150#entry150comment</comments>
<pubDate>Thu, 09 May 2019 14:47:21 +0900</pubDate>
</item>
<item>
<title>유튜브 브라우저 무한 로딩만 되고 재생은 안될 때</title>
<link>https://jhleed.tistory.com/144</link>
<description>&lt;article class=&quot;markdown-body entry-content&quot; itemprop=&quot;text&quot;&gt; &lt;h1 id=&quot;유튜브-브라우저-무한-로딩만-되고-재생은-안될-때&quot;&gt;현상&lt;/h1&gt;
&lt;p&gt;유튜브 뮤직 / 유튜브 모두 재생을 클릭하면 로딩 Progress bar만 계속 들어가고 재생은 되지 않는다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99E7913B5CC912BF31&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;캐시나 뭐 그런 문제인가 싶어 시크릿 탭으로 열어봐도 안 된다.&lt;/p&gt;
&lt;p&gt;&quot;잠시 후 재생이 시작되지 않으면 기기를 다시 시작해보세요.&quot; 라는 안내 문구와 함께.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9917A54D5CC912BF2E&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://support.google.com/youtube/forum/AAAAiuErobUukC9khXbEbA/?hl=en&amp;amp;gpf=%23!topic%2Fyoutube%2FukC9khXbEbA&quot;&gt;나와 동일한 증상을 보이는 다른 사용자들도 있는 듯&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;해결&quot;&gt;해결&lt;/h1&gt;
&lt;p&gt;컴퓨터 재부팅 했더니 된다.. &lt;del&gt;(기기를 다시 시작해 보라길래..)&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;(내 컴퓨터는 MacBook Pro (15-inch, 2017))&lt;/p&gt;
&lt;p&gt;시크릿 탭으로 열었는데도 안 되는데, 재부팅으로 해결이 된다면 아마 시스템 리소스와 관련된 문제인 것 같은데 .. 명확한 해결책을 알게 되면 다시 포스팅할 예정이다.&lt;/p&gt; &lt;/article&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jhleed.tistory.com/144&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>IT 상식</category>
<author>James Lee.</author>
<guid>https://jhleed.tistory.com/144</guid>
<comments>https://jhleed.tistory.com/144#entry144comment</comments>
<pubDate>Wed, 01 May 2019 12:30:07 +0900</pubDate>
</item>
<item>
<title>[Mac] 맥에서 한/영 전환이 잘 동작하지 않을때 해결 방안</title>
<link>https://jhleed.tistory.com/143</link>
<description>&lt;article class=&quot;markdown-body entry-content&quot; itemprop=&quot;text&quot;&gt; &lt;h1 id=&quot;mac-맥에서-한영-전환이-잘-동작하지-않을때-해결-방안&quot;&gt;&lt;br /&gt;&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;최근 맥 업데이트 한 뒤로 한/영 전환 및 입력에 이상 현상이 발생했다.&lt;br /&gt;
  정확한 증상은 아래와 같다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;문제점&quot;&gt;문제점&lt;/h1&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;최근 맥 업데이트 한 뒤로 한/영이 제대로 변경이 되지 않는 현상이 발생했다.&lt;/li&gt;
&lt;li&gt;한글로 입력할 때 자음+모음이 연결되지 않는 현상 (ex : ㅇㅏㄴㄴㅕㅇㅎㅏㅅㅔㅇㅛ)이 빈번히 발생함 (화면 상단에 한/영도 바뀌지 않음)&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;해결&quot;&gt;해결&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;맥 공식 문서 - &lt;a href=&quot;https://support.apple.com/ko-kr/HT203221?fbclid=IwAR3GNDBExGl520MEjcmDHxkiiUTgj3c4h-jEWNvKYnxLGsiwqUD8LjwQk6E&quot;&gt;입력 소스가 유실되거나 Mac에서 특정 문자 뷰어를 열 수 없는 경우&lt;/a&gt; 를 참고했다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9955F3475CC90C4814&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;아래의-단계를-따라한다&quot;&gt;아래의 단계를 따라한다.&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;터미널을 열고 아래의 명령어를 입력 (관리자 암호 등 입력해줘야 함)&lt;/p&gt;
&lt;p&gt;sudo rm /System/Library/Caches/com.apple.IntlDataCache*&lt;br /&gt;
sudo rm /var/folders/&lt;em&gt;/&lt;/em&gt;/&lt;em&gt;/com.apple.IntlDataCache&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;참고 - 내 경우는 디렉토리 경로가 약간 달라서 위 */ 명령어로 지워줄 수가 없었는데, 그냥 수동으로 지워줬다.&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Mac 재시작&lt;/li&gt;
&lt;/ol&gt; &lt;/article&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jhleed.tistory.com/143&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>IT 상식</category>
<author>James Lee.</author>
<guid>https://jhleed.tistory.com/143</guid>
<comments>https://jhleed.tistory.com/143#entry143comment</comments>
<pubDate>Wed, 01 May 2019 12:02:32 +0900</pubDate>
</item>
<item>
<title>A/B 테스트 / 다변수(Multivariate) 테스트 / 리디렉션(Redirection) 테스트</title>
<link>https://jhleed.tistory.com/141</link>
<description>&lt;article class=&quot;markdown-body entry-content&quot; itemprop=&quot;text&quot;&gt; &lt;h1 id=&quot;ab-테스트--다변수multivariate-테스트--리디렉션redirection-테스트&quot;&gt;&lt;br /&gt;&lt;/h1&gt;
&lt;script async=&quot;&quot; src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: &quot;ca-pub-4259186830445714&quot;,
    enable_page_level_ads: true
  });
&lt;/script&gt;
&lt;h1 id=&quot;ab-테스트&quot;&gt;AB 테스트&lt;/h1&gt;
&lt;h3 id=&quot;필요성&quot;&gt;필요성&lt;/h3&gt;
&lt;p&gt;예를 들어, 우리 사이트에 디자인 개선 작업을 했는데 매출이 증가했다고 치자. &lt;/p&gt;
&lt;p&gt;여기서 원인은 디자인 개선 작업이고 매출이 증가한것을 결과로 볼 수 있겠다.&lt;/p&gt;
&lt;p&gt;만약 내가 사장님이라면 &lt;strong&gt;디자인 개선 작업이 매출에 정말로 영향&lt;/strong&gt;을 미쳤을지가 궁금할 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(비슷한 시기에 다른 요인으로 매출이 증가했을 수도 있으니까)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 때 아래의 방법으로 해당 궁금증을 확인해볼 수 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;방문자를 임의로 A / B 집단으로 나눈다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A 집단의 방문자에게는 기존 디자인을, B 집단의 방문자에게는 개선된 디자인을 보여준다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B 집단(개선된 디자인을 노출한)의 방문자들이 매출을 많이 일으킨다면, 디자인 개선 작업은 효과가 있었다고 볼 수 있겠다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9991EC355CC3D7AE23&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://brunch.co.kr/@highfree/27&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;ab-test란&quot;&gt;AB Test란?&lt;/h3&gt;
&lt;p&gt;나는 AB Test를 이렇게 이해하고 있다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;인과관계일 가능성이 높은 것을 찾아내기 위해, 서로 다른 시안을 비슷한 사용자군에게 &quot;동시에&quot;노출해서 성과를 측정하는 일종의 통계 테스트&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/A/B_%ED%85%8C%EC%8A%A4%ED%8A%B8&quot;&gt;위키백과&lt;/a&gt;에는 AB Test를 아래와 같이 정의한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;마케팅과 웹 분석에서, A/B 테스트는 두 개의 변형 A와 B를 사용하는 종합 대조 실험이다. 통계 영역에서 사용되는 것과 같은 통계적 가설 검정 또는 &quot;2-표본 가설 검정&quot;의 한 형태&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;주의점&quot;&gt;주의점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A / B 두 집단을 &quot;임의적&quot;으로 나누어야 한다. 그렇지 않으면 두 집단의 차이가 무엇 때문에 발생하는지 정확하게 가려낼 수 없게 된다.&lt;ul&gt;
&lt;li&gt;예를 들어 아래처럼 나누면 안 된다.&lt;ul&gt;
&lt;li&gt;남성은 A 집단, 여성은 B 집단&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;다변수multivariate-테스트&quot;&gt;다변수(Multivariate) 테스트&lt;/h1&gt;
&lt;h3 id=&quot;필요성-1&quot;&gt;필요성&lt;/h3&gt;
&lt;p&gt;위에서 다룬 A/B테스트는 비교군이 2가지였다. (디자인 개선 전 / 후)&lt;/p&gt;
&lt;p&gt;그러나 이보다 더 복합적인 변화에 대한 테스트가 필요하다면?&lt;/p&gt;
&lt;h3 id=&quot;다변수-테스트란&quot;&gt;다변수 테스트란?&lt;/h3&gt;
&lt;p&gt;위와 같은 상황에 테스트할 페이지의 여러 요소를 동시에 바꿔 테스트하는 것이 다변수(Multivariate) 테스트라고 한다. (이하 MVT)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/991B45335CC3D7AD1F&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://condorly.com/5-multivariate-test-case-studies/&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;예시&quot;&gt;예시&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;주문서의 주문 버튼과 색상, 문구가 각각 3가지 타입이 있다면 총 27가지 경우의 수( 3 * 3 * 3)를 테스트한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;주의&quot;&gt;주의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;많은 비용이 든다.&lt;ul&gt;
&lt;li&gt;폭발적으로 늘어나는 변수 (경우의 수) + 설계, 준비, 분석작업 필요&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;변수가 너무 많으면 유의미한 결과를 분석하기 어려움&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;리디렉션redirection-테스트&quot;&gt;리디렉션(Redirection) 테스트&lt;/h1&gt;
&lt;h3 id=&quot;필요성-2&quot;&gt;필요성&lt;/h3&gt;
&lt;h3 id=&quot;what-is-redirection-test&quot;&gt;What is Redirection Test&lt;/h3&gt;
&lt;p&gt;A/B 테스트의 한 유형이며 구분된 여러 웹페이지를 서로 테스트 해서 비교&lt;/p&gt;
&lt;p&gt;페이지상의 요소가 아닌 URL 또는 경로로 확인&lt;/p&gt;
&lt;p&gt;활용 : 전혀 다른 두 방문 페이지를 테스트하거나, 페이지 디자인을 완전히 변경하려는 경우 리디렉션 테스트가 유용함&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99A8C6415CC3D7A628&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://support.google.com/optimize/answer/7012154?hl=ko&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;예시-1&quot;&gt;예시&lt;/h3&gt;
&lt;p&gt;URL이 서로 다른 두 개의 페이지 테스트&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;원본 - &lt;a href=&quot;http://www.example.com/landing1&quot;&gt;www.example.com/landing1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;대안 - &lt;a href=&quot;http://www.example.com/landing1&quot;&gt;www.example.com/landing&lt;/a&gt;2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;하위 도메인에서 호스팅되는 두 개의 페이지 테스트&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;원본 - &lt;a href=&quot;http://www.example.com/&quot;&gt;www.example.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;대안 - &lt;a href=&quot;http://new.example.com/&quot;&gt;new.example.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;참고-문서&quot;&gt;참고 문서&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://brunch.co.kr/@highfree/27&quot;&gt;A/B 테스트 &amp;amp; MVC (다변량 테스트) - 브런치&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt; &lt;/article&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jhleed.tistory.com/141&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>광고 비즈니스</category>
<author>James Lee.</author>
<guid>https://jhleed.tistory.com/141</guid>
<comments>https://jhleed.tistory.com/141#entry141comment</comments>
<pubDate>Sat, 27 Apr 2019 13:16:46 +0900</pubDate>
</item>
<item>
<title>[Node.js] 노드에서 자주 사용되는 기술들을 이용한 템플릿 프로젝트 만들기</title>
<link>https://jhleed.tistory.com/140</link>
<description>&lt;article class=&quot;markdown-body entry-content&quot; itemprop=&quot;text&quot;&gt; &lt;p&gt;Github Project link : &lt;a href=&quot;https://github.com/jhleed/node-default-project&quot; style=&quot;font-size: 13px;&quot;&gt;https://github.com/jhleed/node-default-project&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;올해는 작년보다 더 많은 사이드 프로젝트를 하려고 한다. 그런데 프로젝트를 매번 세팅할때마다 아래와 같은 번거로움이 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;중복된 환경설정을 해줘야 한다.&lt;/li&gt;
&lt;li&gt;환경설정에서 삽질하는 경우가 적지 않다. &quot;아 이거 전에 했었는데 뭐더라..?&quot; → 결국 이전 프로젝트 환경설정을 다시 참고하게 됨&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;그래서 &lt;strong&gt;사이드 프로젝트를 만들때 바로 가져다 쓸 수 있도록 뼈대를 갖춰놓은 기본 프로젝트를 만들려고 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;이 프로젝트가 완성되면 사이드 프로젝트를 만드는데 걸리는 시간이 훨씬 줄어들 것이다.&lt;/p&gt;
&lt;p&gt;기술 스택은 .. 노드를 선택하기로 했다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99DF4F4E5CBC7AA42D&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;나는-왜-노드를-선택하였나&quot;&gt;나는 왜 노드를 선택하였나?&lt;/h2&gt;
&lt;p&gt;나는 노드에 대한 경험이 정말 거의 없다.&lt;/p&gt;
&lt;p&gt;내 기술 스택 중 자바스크립트의 이해도가 제일 높음에도 불구하고, 지금껏 서버 사이드를 구축할때는 Type-Safety한 언어들만을 고집해왔다.&lt;/p&gt;
&lt;p&gt;자바스크립트의 과도한 유연함(장점이기도 하지만)과 IDE 지원이 제대로 되지 않는 점, 그리고 노드는 싱글 스레드 기반이라 자주 서비스가 죽어버린다는 점 등은 서버 사이드에서 노드를 사용하는것을 망설이게 했다.&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;그러나 이번에는 아래 이유로 노드를 선택했다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;각종 프론트엔드 프레임워크와의 궁합이 좋다.&lt;/li&gt;
&lt;li&gt;뛰어난 생산성&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;그래서 작은 규모의 사이드 프로젝트에 적합할 것 같다. (이게 노드를 선택한 주 이유)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;회사에서도 어쩌면 노드를 쓰게 될 수도 있다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;그냥 노드 해보고 싶어서, 새로운 거 배워보고 싶어서..&lt;/del&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;그 외 노드의 장점들을 떠오르는대로 써 보면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;러닝커브가 적음 (자바스크립트는 세계에서 제일 많이 쓰는 프로그래밍 언어)&lt;/li&gt;
&lt;li&gt;서버 구동이 빠름 (피드백이 빠르다는 것은 꽤나 큰 장점이다. )&lt;/li&gt;
&lt;li&gt;노드의 거대한 생태계&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;물론 개인적으로는 여전히 노드는 대규모 프로젝트에는 적합하지 않다는 생각을 가지고 있다.&lt;/p&gt;
&lt;p&gt;그러나 예전 대부분 모노리틱으로 프로젝트를 구축했을때와는 다르게 &lt;strong&gt;지금은 대부분의 대규모 프로젝트는 기능 단위의 API 서버들을 엮어서 (반드시 MSA가 아닐지라도) 만들기 때문에 이제는 이러한 것들이 그다지 큰 단점이 되지 않는다고 생각이 들었다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;세팅할 기능들은 대략적으로 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Backend : &lt;code&gt;Express&lt;/code&gt;, &lt;code&gt;Q Promise&lt;/code&gt;, &lt;code&gt;Sequelize&lt;/code&gt;, API Connector (미정)&lt;/li&gt;
&lt;li&gt;Frontend : &lt;code&gt;Vue&lt;/code&gt;, &lt;code&gt;Webpack&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Common : &lt;code&gt;Testing(Mocha)&lt;/code&gt;, &lt;code&gt;Logging&lt;/code&gt;, &lt;code&gt;MVC Pattern&lt;/code&gt;, &lt;code&gt;CI &amp;amp; CD&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그 외&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Github Issue Template &amp;amp; Task 설정하기&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;config-file&quot;&gt;Config File&lt;/h2&gt;
&lt;p&gt;보안 문제로 외부 시스템과 연결되는 프로퍼티 파일은 프로젝트 외부에 분리하고 Import 해서 사용하도록 함&lt;/p&gt;
&lt;p&gt;&lt;code&gt;config/config-path.json&lt;/code&gt; 파일에 프로퍼티 파일의 경로를 설정&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{  
    &quot;dbConfigPath&quot;: &quot;/Users/jongholee/dev/workspace/project-config/node-pattern-sample/config/config.json&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;import 할 때는 아래와 같이 사용한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//보안상 프로퍼티 정보는 외부에서 가져오도록 설정
const configPath = require(__dirname + '/../config/config-path.json').dbConfigPath;
const config = require(configPath)[env];
const db = {};

const sequelize = new Sequelize(config.database, config.username, config.password, config);&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;express&quot;&gt;Express&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://jistol.github.io/nodejs/2017/09/07/express-generator/&quot;&gt;참고 문서 : express-generator - Node.js + Express 프로젝트 생성하기&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ express --view=hbs
$ cd &amp;lt;project dir&amp;gt;
$ npm install
$ npm start&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Express와 자주 사용하는 라이브러리들 (파서, 로거 등)을 함께 셋업해준다. &lt;/p&gt;
&lt;p&gt;기본 포트는 3000, 프로필은 development다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const createError = require('http-errors');
const express = require('express');
const path = require('path');
const cookieParser = require('cookie-parser');
const logger = require('morgan');

const app = express();

// view engine setup
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'hbs');

app.use(logger('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());
app.use(express.static(path.join(__dirname, 'public')));

app.use('/', indexRouter);
app.use('/users', userRouter);

// catch 404 and forward to error handler
app.use(function(req, res, next) {
  next(createError(404));
});

// error handler
app.use(function(err, req, res, next) {
  // set locals, only providing error in development
  res.locals.message = err.message;
  res.locals.error = req.app.get('env') === 'development' ? err : {};

  // render the error page
  res.status(err.status || 500);
  res.render('error');
});

module.exports = app;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;pm2&quot;&gt;PM2&lt;/h2&gt;
&lt;p&gt;노드 프로세스 관리 도구 (nodemon도 사용해봤는데, PM2가 더 좋은 듯 하다.)&lt;/p&gt;
&lt;p&gt;현재 주로 사용하는 기능은&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;핫 리로드 - 코드 수정시 바로 반영&lt;/li&gt;
&lt;li&gt;서비스 죽으면 자동으로 재기동&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;기본 세팅은 아래와 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.exports = {
    apps: [
        {
            // pm2로 실행한 프로세스 목록에서 이 애플리케이션의 이름으로 지정될 문자열
            name: &quot;Your Service Name&quot;,
            // pm2로 실행될 파일 경로
            script: &quot;./bin/www&quot;,
            // 개발환경시 적용될 설정 지정
            env: {
                &quot;PORT&quot;: 3000,
                &quot;NODE_ENV&quot;: &quot;development&quot;
            },
            // 배포환경시 적용될 설정 지정
            env_production: {
                &quot;PORT&quot;: 8080,
                &quot;NODE_ENV&quot;: &quot;production&quot;
            },
            watch : true,
            ignore_watch : [&quot;logs&quot;]
        }
    ]
};&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;mocha&quot;&gt;Mocha&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;동기 / 비동기 각 경우에 대한 단위 테스트&lt;/li&gt;
&lt;li&gt;Transaction Rollback (적용 예정)&lt;/li&gt;
&lt;li&gt;Mocking (적용 예정)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;javascript language-javascript&quot;&gt;const assert = require('assert');
const userRepository = require('../../persistence/userRepository');

describe('userRepository', () =&amp;gt; {
    it('should return 2 elements when call userCategories', function (done) {
        userRepository.getUsers().then((val) =&amp;gt; {
            assert.strictEqual(val[0].id, 1);
            assert.strictEqual(val[0].name, '이종호');
            done();
        })
    });
});&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;sequelize&quot;&gt;Sequelize&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ORM of Javascript&lt;/p&gt;
&lt;p&gt;npm i sequelize mysql2&lt;br /&gt;
npm i -g sequelize-cli&lt;br /&gt;
sequelize init&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;sequelize-cli&lt;/code&gt; 가 생성해주는 index.js를 수정해야 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;'use strict';

const Sequelize = require('sequelize');
const env = process.env.NODE_ENV || 'development';

//보안상 프로퍼티 정보는 외부에서 가져오도록 설정
const configPath = require(__dirname + '/../config/config-path.json').dbConfigPath;
const config = require(configPath)[env];
const db = {};

const sequelize = new Sequelize(config.database, config.username, config.password, config);

db.sequelize = sequelize;
db.Sequelize = Sequelize;

//모델 정보 읽어옴
db.User = require('./user')(sequelize, Sequelize);

//TODO 모델 관계 매핑

module.exports = db;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;ci--cd-적용-예정&quot;&gt;CI &amp;amp; CD (적용 예정)&lt;/h3&gt;
&lt;p&gt;Docker 적용 예정&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://velog.io/@jeff0720/Travis-CI-AWS-CodeDeploy-Docker-%EB%A1%9C-%EB%B0%B0%ED%8F%AC-%EC%9E%90%EB%8F%99%ED%99%94-%EB%B0%8F-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EB%B0%B0%ED%8F%AC-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0&quot;&gt;참고 문서 : Travis CI, AWS CodeDeploy, Docker 로 배포 자동화 및 무중단 배포 환경 구축하기 - (1)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;github-issue-template--task-설정하기&quot;&gt;Github Issue Template &amp;amp; Task 설정하기&lt;/h1&gt;
&lt;p&gt;비록 혼자 하는 프로젝트지만 실제 프로젝트처럼 관리할 겸, 그리고 Github 사용법에도 더 익숙해질 겸 해서 &lt;a href=&quot;https://www.popit.kr/github로-프로젝트-관리하기-part1-이슈-발급-부터-코드리뷰까/&quot;&gt;GitHub로 프로젝트 관리하기 Part1 - 이슈 발급 부터 코드리뷰까지&lt;/a&gt; 글을 참고하여 Issue Template 세팅을 하여 Feature 단위로 Task를 발급하였다.&lt;/p&gt;
&lt;p&gt;회사에서는 프로젝트를 관리하는 방식이 조금 다르지만 어쨌든 배워두면 추후 사이드 프로젝트를 관리할 때 도움이 될 것 같다. (그리고 다 떠나서 일단 새로운 걸 배운다는 건 재밌다.)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99353C505CBC7AA429&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;후기&quot;&gt;후기&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;노드 특징상 컴파일 타임에 잡히는 에러보다 런타임시 잡히는 에러가 월등히 많다. 그래서 테스트 코드를 견고하게 짜는게 정말 중요하다는 생각이 든다.&lt;/li&gt;
&lt;li&gt;만들면서 아이디어가 계속 떠오른다. 이것도 해보면 어떨까, 저것도 해보면 어떨까?&lt;/li&gt;
&lt;li&gt;이것저것 새로 시도해보는게 많아서 재밌었다. (삽질도 많이 했다.)&lt;/li&gt;
&lt;li&gt;노드에 익숙해지면 굉장히 자주 쓰게 될 것만 같은 느낌&lt;/li&gt;
&lt;/ul&gt; &lt;/article&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jhleed.tistory.com/140&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>NodeJS</category>
<author>James Lee.</author>
<guid>https://jhleed.tistory.com/140</guid>
<comments>https://jhleed.tistory.com/140#entry140comment</comments>
<pubDate>Sun, 21 Apr 2019 23:13:57 +0900</pubDate>
</item>
<item>
<title>[Node] IntelliJ에서 Node 관련 require unresolved function 경고 메세지 제거</title>
<link>https://jhleed.tistory.com/137</link>
<description>&lt;article class=&quot;markdown-body entry-content&quot; itemprop=&quot;text&quot;&gt; &lt;p&gt;&lt;code style=&quot;font-size: 13px;&quot;&gt;IntelliJ&lt;/code&gt;&lt;span style=&quot;font-size: 13px;&quot;&gt;에서 &lt;/span&gt;&lt;code style=&quot;font-size: 13px;&quot;&gt;node.js&lt;/code&gt;&lt;span style=&quot;font-size: 13px;&quot;&gt; 프로젝트를 생성하면 아래처럼 노드와 관련된 API가 정상적으로 인식이 되지 않는 경우가 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/992BD1335CBC0AFA1F&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;그럴 때는 이렇게 하자.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Settings&lt;/code&gt; → &lt;code&gt;Language &amp;amp; Frameworks&lt;/code&gt; → &lt;code&gt;Node.js and NPM&lt;/code&gt; 항목으로 이동&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Coding assistance for Node.js&lt;/code&gt; 체크 활성화&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/996B7D355CBC0AF920&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;이후 &lt;code&gt;require&lt;/code&gt; 메소드가 정상적으로 인식되는 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/994360455CBC0AF917&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;그-외-노드-라이브러리가-인식이-되지-않는-경우&quot;&gt;그 외 노드 라이브러리가 인식이 되지 않는 경우&lt;/h2&gt;
&lt;p&gt;예를 들어 아래처럼 &lt;code&gt;Express&lt;/code&gt;가 인식이 되지 않는 경우.. 해결 방법은 비슷하다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/997B4B365CBC0AFA28&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;처음과 마찬가지로 &lt;code&gt;Settings&lt;/code&gt; → &lt;code&gt;Language &amp;amp; Frameworks&lt;/code&gt; → &lt;code&gt;Node.js and NPM&lt;/code&gt; 항목으로 이동한다.&lt;/p&gt;
&lt;p&gt;아래처럼 본인의 프로젝트를 선택하고 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99E20B355CBC0AF91D&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Download를 클릭하면 프로젝트에서 참조하는 수 많은 의존성들이 나온다. &lt;/p&gt;
&lt;p&gt;그 중 원하는 의존성 (여기서는 express)를 선택하여 다운로드 받자.&lt;/p&gt;
&lt;p&gt;(Tip : 검색을 하면 더 빠르게 찾을 수 있다.)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/992826375CBC0AFA19&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;이후 API가 잘 인식되는 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99DFB6425CBC0AF91C&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;script async=&quot;&quot; src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: &quot;ca-pub-4259186830445714&quot;,
    enable_page_level_ads: true
  });
&lt;/script&gt; &lt;/article&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jhleed.tistory.com/137&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>NodeJS</category>
<author>James Lee.</author>
<guid>https://jhleed.tistory.com/137</guid>
<comments>https://jhleed.tistory.com/137#entry137comment</comments>
<pubDate>Sun, 21 Apr 2019 15:17:30 +0900</pubDate>
</item>
<item>
<title>CI(Continuous Integration), CD(Continuous Delivery / Deployment)에 대해 알아보자.</title>
<link>https://jhleed.tistory.com/130</link>
<description>&lt;article class=&quot;markdown-body entry-content&quot; itemprop=&quot;text&quot;&gt; &lt;p&gt;웹 서비스를 개발/운영하다 보면 CI 와 CD라는 말을 자주 듣게 된다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;
보통 CI 와 CD 를 묶어서 이야기하는 경우가 많아서 많은 사람들이(이전에 내가 그랬듯이) 두 개념을 종종 혼동하곤 한다.&lt;/p&gt;
&lt;p&gt;이 포스팅에서는 CI와 CD란 무엇인지, 그리고 차이점은 무엇인지 알아본다.&lt;/p&gt;
&lt;p&gt;CI 와 CD를 실습해보는 것은 창천향로님의 &lt;a href=&quot;https://jojoldu.tistory.com/265&quot;&gt;6) 스프링부트로 웹 서비스 출시하기 - 6. TravisCI &amp;amp; AWS CodeDeploy로 배포 자동화 구축하기&lt;/a&gt; 글을 읽어보는 것을 추천한다.&lt;/p&gt;
&lt;h1 id=&quot;cicontinuous-integration---지속적-통합&quot;&gt;CI(Continuous Integration) - 지속적 통합&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/992FFF4B5CA9E1130A&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.gds-gov.tech/that-ci-cd-thing-principles-implementation-tools-aa8e77f9a350&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CI(Continuous Integration)는 빌드와 테스트 자동화에 대한 개념이다. &lt;em&gt;(이하 CI)&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개발자를 위한 자동화 프로세스인 지속적인 통합(Continuous Integration)을 의미&lt;/li&gt;
&lt;li&gt;빌드 및 테스트를 자동화해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;ci-예시&quot;&gt;CI 예시&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;개발자는 자신의 로컬에서 코드를 수정하고 Github에 Push를 한다.&lt;/li&gt;
&lt;li&gt;CI 도구에서 변경된 코드에 대한 빌드와 테스트를 수행하고 결과를 피드백해준다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;아래는 CI 도구 중 하나인 Travis CI의 화면이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9983B3365CA9E11333&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;빌드 &amp;amp; 테스트에 이상이 있는 경우 → 실패&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99C86C4D5CA9E11333&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;빌드 &amp;amp; 테스트가 이상 없이 수행되는 경우 → 성공&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;ci-도구&quot;&gt;CI 도구&lt;/h2&gt;
&lt;p&gt;CI를 위한 도구로는 &lt;a href=&quot;https://jenkins.io/&quot;&gt;Jenkins&lt;/a&gt;, &lt;a href=&quot;https://travis-ci.org/&quot;&gt;TravisCI&lt;/a&gt; 등이 있다.&lt;/p&gt;
&lt;h1 id=&quot;cdcontinuous-delivery--deployment---지속적-전달--배포&quot;&gt;CD(Continuous Delivery / Deployment) - 지속적 전달 / 배포&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99D63B4A5CA9E11311&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CI가 &lt;strong&gt;빌드 및 테스트&lt;/strong&gt; 자동화라면 CD는 &lt;strong&gt;배포 자동화&lt;/strong&gt;에 대한 개념이다.&lt;/p&gt;
&lt;p&gt;CD는 자동화의 수준에 따라 아래 2가지로 구별할 수 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Continuous Delivery &lt;/li&gt;
&lt;li&gt;Continuous Deployment&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 둘의 차이점은 &lt;strong&gt;'프로덕션 배포까지 자동화하는가'&lt;/strong&gt;다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Continuous Delivery&lt;/strong&gt; (지속적 전달)은 &lt;strong&gt;프로덕션은 수동&lt;/strong&gt;으로 배포한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Continuous Deployment&lt;/strong&gt; (지속적 배포)는 &lt;strong&gt;프로덕션까지 자동으로 배포&lt;/strong&gt;한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;cd-예시&quot;&gt;CD 예시&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;CI 예시에서 CI가 정상적으로 수행되고 나면 빌드된 파일을 CD에 전달한다.&lt;/li&gt;
&lt;li&gt;CD에서는 빌드가 완료된 파일을 받아서 전처리 / 후처리 등을 수행한다. 아래에선 2가지 예시를 간단하게 설명한다.&lt;ol&gt;
&lt;li&gt;ex 1) 기존에 동작하던 애플리케이션을 종료시키고 업데이트된 빌드 파일로 애플리케이션을 구동&lt;/li&gt;
&lt;li&gt;ex 2) 무중단 배포의 경우, 새로 업데이트된 파일을 다른 포트에 풀어놓고, 구동이 완료되면 프락시에서 들어오는 요청을 스위칭 함 (reverse proxy)&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;cd-도구&quot;&gt;CD 도구&lt;/h2&gt;
&lt;p&gt;CD를 위한 Tool로는 &lt;a href=&quot;https://aws.amazon.com/ko/codedeploy/?sc_channel=PS&amp;amp;sc_campaign=acquisition_KR&amp;amp;sc_publisher=google&amp;amp;sc_medium=english_codedeploy_b&amp;amp;sc_content=aws_codedeploy_e&amp;amp;sc_detail=aws%20code%20deploy&amp;amp;sc_category=code_deploy&amp;amp;sc_segment=161197922586&amp;amp;sc_matchtype=e&amp;amp;sc_country=KR&amp;amp;s_kwcid=AL!4422!3!161197922586!e!!g!!aws%20code%20deploy&amp;amp;ef_id=CjwKCAjwv6blBRBzEiwAihbM-ZrswpV3nIWoFCINT88s6oFdkOrwiqjkn9bddhRFMptK_9DtOuSm8xoCAcgQAvD_BwE:G:s&quot;&gt;AWS Code Deploy&lt;/a&gt; 등이 있다.&lt;/p&gt;
&lt;h1 id=&quot;정리&quot;&gt;정리&lt;/h1&gt;
&lt;p&gt;정리하자면 CI는 Build &amp;amp; Test에 관한 자동화이며, CD는 Deploy에 대한 자동화이다.&lt;/p&gt;
&lt;p&gt;CD는 두 가지 종류 (Delivery / Deployment) 로 분류되는데 그 차이는 &lt;strong&gt;프로덕션 배포까지 자동화하는가&lt;/strong&gt;이다.&lt;/p&gt;
&lt;p&gt;CI / CD의 전체적인 파이프라인은 아래와 같다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/993C23405CA9E11334&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment&quot;&gt;Continuous integration vs. continuous delivery vs. continuous deployment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.redhat.com/ko/topics/devops/what-is-ci-cd&quot;&gt;CI/CD란 무엇일까요? - 레드햇&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt; &lt;/article&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jhleed.tistory.com/130&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>인프라</category>
<author>James Lee.</author>
<guid>https://jhleed.tistory.com/130</guid>
<comments>https://jhleed.tistory.com/130#entry130comment</comments>
<pubDate>Sun, 07 Apr 2019 20:37:56 +0900</pubDate>
</item>
<item>
<title>[Kylin] 1. Data Model 생성하기</title>
<link>https://jhleed.tistory.com/129</link>
<description>&lt;article class=&quot;markdown-body entry-content&quot; itemprop=&quot;text&quot;&gt; &lt;p&gt;최근 사내 Kylin 저장소를 이전하며 Kylin 큐브 구조를 전반적으로 재구성하였다.&lt;/p&gt;
&lt;p&gt;그 이후 Kylin 조회 성능이 많이 향상된 것이 체감된다. &lt;br /&gt;
&lt;em&gt;(물론 여기엔 새로운 저장소의 저장공간이 넉넉한 것도 영향을 줬다.)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;나는 최근 들어온 요구사항에 맞춰서 Kylin Cube를 새로 생성하는 일을 하고 있다. &lt;/p&gt;
&lt;p&gt;Kylin은 기존 큐브에 존재하지 않는 Dimension을 추가해서 조회할 수 없고, 큐브를 새로 생성해야 한다. &lt;del&gt;슬프다.&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;그러면서  Kylin 큐브 생성시 어떤 설정들이 조회 성능과 큐브의 용량에 영향을 주는지 배우고 있다.&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;Kylin의 아래 내용을 글로 쓸 예정인데, 이 포스팅에서는 '1. 데이터 모델 생성'  ← 이 부분을 정리했다. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;데이터 모델 생성&lt;/li&gt;
&lt;li&gt;데이터 큐브 생성&lt;/li&gt;
&lt;li&gt;데이터 큐브 빌드&lt;/li&gt;
&lt;li&gt;데이터 큐브 최적화&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;사내 저장소를 캡쳐할 수 없으므로 Kylin 공식 웹사이트 가이드를 참고했다.&lt;/p&gt;
&lt;p&gt;이 포스팅에서는 데이터 모델을 생성하는 방법 외에 특별한 내용은 없기에 가이드 문서 정도라고 생각하면 된다. &lt;/p&gt;
&lt;p&gt;시간 관계상 큐브 생성, 최적화 관련된 내용은 다음에 다루도록 한다. :')&lt;/p&gt;
&lt;p&gt;그래도 한글 문서가 거의 없는 키린 레퍼런스 생태계에 작은 도움이 되길 바란다.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;data-model이란&quot;&gt;Data Model이란?&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%AA%A8%EB%8D%B8&quot;&gt;wiki&lt;/a&gt;에서는 일반적인 데이터 모델을 아래와 같이 정의한다. &lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;데이터 모델은 데이터의 관계, 접근과 그 흐름에 필요한 처리 과정에 관한 추상화된 모형이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://kylin.apache.org/blog/2015/01/25/introduce-data-model/&quot;&gt;kylin 공식 문서&lt;/a&gt;에서는 데이터 모델을 아래와 같이 정의한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;데이터 요소를 구성하고 데이터 요소가 서로 관련되는 방식을 표준화한 모델&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Kylin의 데이터 모델에서는 아래와 같은 요소들을 정의한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팩트 테이블 선택&lt;/li&gt;
&lt;li&gt;Dimension &amp;amp; Measure 정의&lt;/li&gt;
&lt;li&gt;그 외 설정들&lt;ul&gt;
&lt;li&gt;Partition Date &amp;amp; Time Column (중요)&lt;/li&gt;
&lt;li&gt;Cube Size &amp;amp; Filter ..&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;data-model-생성하기&quot;&gt;Data Model 생성하기&lt;/h1&gt;
&lt;p&gt;데이터 모델을 생성하기 전에 우선 데이터를 가져올 Hive Table을 정의하고 동기화 해주는 작업을 거쳐야 한다.&lt;/p&gt;
&lt;h3 id=&quot;하이브-테이블-동기화&quot;&gt;하이브 테이블 동기화&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Data Source&lt;/code&gt; 탭에서  &lt;code&gt;Load Hive Table&lt;/code&gt; 버튼을 눌러서 하이브 테이블을 동기화&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99860D3B5C9781FE08&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;하이브 테이블 이름을 입력 후 (쉼표로 구별) &lt;code&gt;Sync&lt;/code&gt; 클릭&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/991746365C9781FF3E&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;성공하면 왼쪽 &lt;code&gt;Table&lt;/code&gt; 섹션에 테이블이 추가된 것을 확인할 수 있음&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9995094E5C9781FE13&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;백그라운드에서 Kylin이 MapReduce 작업을 실행하여 새로 동기화 된 테이블의 대략적인 카디널리티를 계산함. 작업이 끝나면 카디널리티가 테이블 정보에 표시 됨&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99FF614E5C9781FF0B&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;데이터-모델-생성&quot;&gt;데이터 모델 생성&lt;/h3&gt;
&lt;p&gt;큐브를 생성하기 전에 데이터 모델을 정의해야 함. 하나의 데이터 모델은 스타 스키마를 정의하며, 여러 큐브에서 재사용할 수 있음&lt;/p&gt;
&lt;p&gt;1.&lt;code&gt;Model&lt;/code&gt; 메뉴 표시 줄에서 &lt;code&gt;New Model&lt;/code&gt; 클릭&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99B5B8435C9781FE29&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;모델 이름 및 설명 입력&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99B6034C5C9781FF0F&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;code&gt;Data Model&lt;/code&gt; 탭에서 &lt;code&gt;Fact Table&lt;/code&gt; 선택 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/991F6F445C9781FE02&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3.1 (옵션) 룩업 테이블을 추가하길 원한다면 &lt;code&gt;Add Lookup Table&lt;/code&gt; 클릭. 테이블 이름 및 조인 유형 (inner, left ..) 선택&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/998B2F395C9781FF18&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3.2 (옵션) &lt;code&gt;New Join Condition&lt;/code&gt; 버튼을 클릭하고 왼쪽 팩트 테이블의 FK 컬럼을 선택한 다음, 오른쪽 룩업 테이블의 PK 컬럼을 선택.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/996B1B475C9781FE08&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3.3 &lt;code&gt;OK&lt;/code&gt; 클릭, 윗 단계를 반복해서 룩업 테이블을  추가한다. 전부 끝나면 &lt;code&gt;Next&lt;/code&gt; 클릭&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;&lt;code&gt;Dimensions&lt;/code&gt; 탭은 하위 큐브에서 &lt;strong&gt;'Dimension'&lt;/strong&gt;으로  사용할 컬럼을 선택함&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Column&lt;/code&gt; 표의 셀을 클릭하고, 드롭 다운 목록에서 컬럼을 선택함.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99FAE93C5C9781FF31&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;&lt;code&gt;Measure&lt;/code&gt; 탭에서는 measure &amp;amp; metrics 으로 사용될 컬럼을 선택함. Measure 컬럼은 팩트 테이블에 있는 컬럼에서만 선택할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/998A09505C9781FF35&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;&lt;code&gt;Settings&lt;/code&gt; 탭 - &lt;code&gt;Partition Date Column&lt;/code&gt; : 만약 팩트 테이블의 데이터가 하루마다 증가하는 경우, 해당하는 날짜의 date format 컬럼을 설정. 아니라면 빈칸으로 내버려 둠. &lt;br /&gt;
(예를 들어 Hive에 데이터가 일별로 'yyyyMMdd' 포맷으로 저장한다면 반드시 'yyyyMMdd' 포맷을 선택해야 한다. 안 그러면 하이브 풀스캔해서.. &lt;del&gt;&lt;em&gt;폭망&lt;/em&gt;&lt;/del&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;(옵션) 큐브의 크기를 나타내는 &lt;code&gt;Cube Size&lt;/code&gt; 를 선택할 수 있다. (기본값 : Medium)&lt;/li&gt;
&lt;li&gt;(옵션) &lt;code&gt;Filter&lt;/code&gt; 에서 제외하고 싶은 데이터를 지정할 수 있다. (ex : dirty data)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/993F0C4D5C9781FF0E&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;모델 생성이 완료되면 오른쪽의 &lt;code&gt;Models&lt;/code&gt; 리스트에서 생성한 모델을 확인할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99B0C9395C9781FE30&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;끝! 다음 장에서는 큐브 생성 및 빌드 과정을 정리해 볼 예정이다.&lt;/p&gt;
&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://kylin.apache.org/docs16/tutorial/create_cube.html&quot;&gt;Kylin Cube Creation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt; &lt;/article&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jhleed.tistory.com/129&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Kylin</category>
<category>bigdata</category>
<category>It</category>
<category>Kylin</category>
<category>OLAP</category>
<category>람다아키텍처</category>
<category>빅데이터</category>
<category>하둡</category>
<author>James Lee.</author>
<guid>https://jhleed.tistory.com/129</guid>
<comments>https://jhleed.tistory.com/129#entry129comment</comments>
<pubDate>Sun, 24 Mar 2019 22:11:27 +0900</pubDate>
</item>
<item>
<title>[Redis] 기본 데이터 타입 정리</title>
<link>https://jhleed.tistory.com/128</link>
<description>&lt;article class=&quot;markdown-body entry-content&quot; itemprop=&quot;text&quot;&gt; &lt;h1 id=&quot;redis-기본-데이터-타입-정리&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9919E8475C85033108&quot; alt=&quot;&quot; style=&quot;font-size: 13px;&quot;&gt;&lt;/h1&gt;
&lt;p&gt;그동안 기존 프로젝트에 적용되어 있는 레디스를 &quot;사용&quot;만 해보다가 &quot;공부&quot;해보려고 한다.&lt;/p&gt;
&lt;p&gt;공부의 구체적 목표는 레디스의 데이터 타입을 모두 파악하고, 레디스를 사용하는 어플리케이션의 성능을 개선하며, 레디스 안티 패턴(사용하면 안 되는 커맨드 들)을 이해하는 것이다.&lt;/p&gt;
&lt;p&gt;이 포스팅은 &lt;a href=&quot;http://www.acornpub.co.kr/book/redis-essentials&quot;&gt;에이콘 출판사의 Redis 핵심정리&lt;/a&gt;를 읽고 기본 데이터 타입인 문자열, 리스트, 해시를 정리한 내용이다. &lt;/p&gt;
&lt;h2 id=&quot;hello-world&quot;&gt;Hello World&lt;/h2&gt;
&lt;p&gt;Hello world가 반이라고 했던가, 우선 간단하게 노드를 이용하여 Hello World 예제를 띄워본다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var redis = require(&quot;redis&quot;);
var client = redis.createClient();

client.set(&quot;my_key&quot;, &quot;Hello World using Node.js and Redis&quot;);
client.get(&quot;my_key&quot;, redis.print);

client.quit();&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;실행-결과&quot;&gt;실행 결과&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Reply: Hello World using Node.js and Redis&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 레디스에서 사용하는 기본 데이터 타입에 대해 알아보자.&lt;/p&gt;
&lt;h1 id=&quot;문자열&quot;&gt;문자열&lt;/h1&gt;
&lt;p&gt;레디스에서 가장 다양한 데이터 타입&lt;/p&gt;
&lt;p&gt;텍스트 문자열 외에도 정수(Integer) 또는 부동소수점(Float), 비트맵 값이 기반이고 연관 커맨드를 사용함으로써 동작한다.&lt;/p&gt;
&lt;p&gt;문자열은 텍스트 (HTML, JSON, HTML 도 저장 가능), 숫자형(Integer, Float) 뿐 아니라 바이너리 데이터(이미지, 비디오, 오디오 파일)까지 저장 가능하다.&lt;/p&gt;
&lt;p&gt;문자열 값은 512MB를 초과할 수 없다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;문자열의 사용 예시&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;캐시 매커니즘 : 어떠한 타입의 데이터라도 캐시할 수 있다.&lt;ul&gt;
&lt;li&gt;커맨드 : SET, GET, MSET, MGET&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;자동 만료되는 캐시 : 데이터베이스 질의 실행이 오래 걸리고, 일정 시간 동안 캐시되어야 할 때 매우 유용하다. 너무 자주 질의가 실행되는 것을 피할 수 있고, 애플리케이션 성능 향상에도 유용하다.&lt;ul&gt;
&lt;li&gt;커맨드 : SETEX, EXPIRE, EXPIREAT&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;개수 계산 : 페이지 뷰, 비디오 뷰, 좋아요 같은 개수 계산이 좋은 예시다.&lt;ul&gt;
&lt;li&gt;커맨드 : INCR, INCRBY, DECR, DECRBY, INCRFLOATBY&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;문자열을-이용한-투표-시스템-만들기&quot;&gt;문자열을 이용한 투표 시스템 만들기&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;var redis = require(&quot;redis&quot;);
var client = redis.createClient();

function upVote(id) {
    var key = &quot;article:&quot; + id + &quot;:votes&quot;;
    client.incr(key);
}

function downVote(id) {
    var key = &quot;article:&quot; + id + &quot;:votes&quot;;
    client.decr(key);
}

function showResults(id) {
    var headlineKey = &quot;article:&quot; + id + &quot;:headline&quot;;
    var voteKey = &quot;article:&quot; + id + &quot;:votes&quot;;

    //콜백을 전달할 수 있는 mget api 
    client.mget([headlineKey, voteKey], function (err, replies) {
        console.log(&quot;The article &quot; + replies[0] + &quot;has &quot; + replies[1] + &quot; votes&quot;);
    });
}


// 12345 아티클 3번 투표 (+3)
upVote(12345);
upVote(12345);
upVote(12345);

// 10001 아티클 3번 투표 (+2, -1)
upVote(10001);
upVote(10001);
downVote(10001);

//  60056 아티클 1번 투표 (+1)
upVote(60056);

//결과 보여주기
showResults(12345);
showResults(10001);
showResults(60056);

client.quit();&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;실행-결과-1&quot;&gt;실행 결과&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;The article Google Wants to Turn Your Clothes Into a Computerhas 3 votes
The article For Millennials, the End of the TV Viewing Partyhas 1 votes
The article Alicia Vikander, Who Portrayed Denmark's Queen, Is Screen Royaltyhas 1 votes&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;리스트&quot;&gt;리스트&lt;/h1&gt;
&lt;p&gt;리스트는 간단한 콜렉션, 스택, 큐와 같이 동작할 수 있기 때문에 레디스에서는 매우 유연한 데이터 타입이다.&lt;/p&gt;
&lt;p&gt;많은 이벤트 시스템은 레디스의 리스트를 큐로 사용하는데, 리스트 커맨드가 원자적인 특성을 갖고 있어, 병렬 시스템이 큐에서 엘리먼트를 얻어낼 때 중복으로 얻지 않도록 보장해준다.&lt;/p&gt;
&lt;p&gt;레디스의 리스트에는 블로킹 커맨드가 존재한다. 즉, 클라이언트가 비어있는 리스트에 블로킹 커맨드를 실행할 때, 클라이언트는 리스트에 새로운 엘리먼트가 추가될 때까지 기다린다는 의미다. &lt;/p&gt;
&lt;p&gt;레디스의 리스트는 연결 리스트이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;처음 또는 끝에서의 접근/추가/삭제 O(1)&lt;/li&gt;
&lt;li&gt;처음과 끝이 아닌 경우는 O(N)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;리스트의 각 엘리먼트가 &lt;code&gt;list-max-ziplist-value(바이트 값)&lt;/code&gt; 설정 값보다 작고, 엘리먼트 개수가 &lt;code&gt;list-max-ziplist-entries&lt;/code&gt; 설정 값보다 작으면, 리스트는 encode 될 수 있고, 메모리를 최적화 할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;리스트를 사용하는 실제 예시&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이벤트 큐 : 레스큐, 셀러리, 로그스태시 등등의 툴에서 사용&lt;/li&gt;
&lt;li&gt;최근 사용자 글 저장하기 : 트위터는 사용자의 최근 트윗을 저장할 때 리스트를 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;커맨드&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LPUSH, RPUSH&lt;/li&gt;
&lt;li&gt;LLEN&lt;/li&gt;
&lt;li&gt;LINDEX&lt;/li&gt;
&lt;li&gt;LRANGE&lt;/li&gt;
&lt;li&gt;LPOP, RPOP&lt;/li&gt;
&lt;li&gt;BRPOP, BLPOP&lt;ul&gt;
&lt;li&gt;RPOP, LPOP의 블로킹 버전&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;RPOPLPUSH&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;참고---atomic&quot;&gt;참고 - Atomic&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;레디스는 항상 한 번에 하나의 커맨드를 실행하는 싱글 스레드 기반으로 동작한다. '원자적(Atomic)'이란 다중 클라이언트가 동시에 동일한 키를 작업하는 커맨드를 수행할 때, 경합 조건이 결코 발생하지 않는다는 것을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;queue를-이용한-생산자소비자-시스템&quot;&gt;Queue를 이용한 생산자/소비자 시스템&lt;/h2&gt;
&lt;p&gt;consumer-worker.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var redis = require(&quot;redis&quot;);
var client = redis.createClient();
var queue = require(&quot;./queue&quot;);
var logsQueue = new queue.Queue(&quot;logs&quot;, client);

function logMessages() {
    logsQueue.pop(function (err, replies) {
        var queueName = replies[0];
        var message = replies[1];

        console.log(&quot;[consumer] Got log: &quot; + message);

        logsQueue.size(function (err,size) {
            console.log(size + &quot; logs left&quot;);
        });

        logMessages();
    });
}

logMessages();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실행 결과&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Created 5 logs&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;producer-worker.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var redis = require(&quot;redis&quot;);
var client = redis.createClient();
var queue = require(&quot;./queue&quot;);
var logsQueue = new queue.Queue(&quot;logs&quot;, client);
var MAX = 5;

for (var i = 0; i&amp;lt; MAX; i++){
    logsQueue.push(&quot;Hello world #&quot; + i);
}

console.log(&quot;Created &quot; + MAX + &quot; logs&quot;);

client.quit();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실행 결과&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[consumer] Got log: Hello world #0
4 logs left
[consumer] Got log: Hello world #1
3 logs left
[consumer] Got log: Hello world #2
2 logs left
[consumer] Got log: Hello world #3
1 logs left
[consumer] Got log: Hello world #4
0 logs left&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;해시&quot;&gt;해시&lt;/h1&gt;
&lt;p&gt;해시는 필드를 값으로 매핑 할 수 있기 때문에 &lt;strong&gt;객체를 저장하기 적합한 구조&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;메모리를 효율적으로 사용하며, &lt;strong&gt;데이터를 빨리 찾을 수 있게 최적화&lt;/strong&gt;되어 있음&lt;/p&gt;
&lt;p&gt;필드 이름과 값은 문자열&lt;/p&gt;
&lt;p&gt;해시의 큰 장점은 &lt;strong&gt;메모리 최적화다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;아래는 인스타그램의 문자열과 해시 성능 벤치마크 사례이다. &lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;인스타그램은 3억 건의 미디어 ID로 사용자 ID를 역참조를 해야 해서, 문자열과 해시를 이용한 레디스 프로토타입의 벤치마크 테스트를 진행하기로 결정했다.&lt;br /&gt;
  문자열을 이용한 솔루션은 미디어 ID당 하나의 키를 사용하고, &lt;strong&gt;약 21GB의 메모리&lt;/strong&gt;를 사용했다.&lt;br /&gt;
  해시를 이용한 솔루션은 일부 설정을 수정해 &lt;strong&gt;약 5GB&lt;/strong&gt;의 메모리를 사용했다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;21GB → 5GB&lt;/p&gt;
&lt;h3 id=&quot;주의--hgetall&quot;&gt;주의 : HGETALL&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;해시에 많은 필드가 존재하고 메모리를 많이 사용한다면, &lt;code&gt;HGETALL&lt;/code&gt; 커맨드가 문제를 일으킬 수 있다. &lt;code&gt;HGETALL&lt;/code&gt; 커맨드는 모든 해시 데이터를 네트워크를 통해 전달해야 할 필요가 있기 때문에 레디스를 느리게 할 수 있다. &lt;br /&gt;
  이러한 경우에는 한 번에 모든 필드를 리턴하지 않고, 커서와 해시 필드의 값을 리턴하는 &lt;code&gt;HSCAN&lt;/code&gt; 커맨드가 대안이 될 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;hash를-이용한-투표-시스템&quot;&gt;Hash를 이용한 투표 시스템&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var redis = require(&quot;redis&quot;);
var client = redis.createClient();

function saveLink(id, author, title, link) {
    client.hmset(&quot;link:&quot; + id, &quot;author&quot;, author, &quot;title&quot;, title, &quot;link&quot;, link, &quot;score&quot;,0);
}

function upVote(id) {
    client.hincrby(&quot;link:&quot; + id, &quot;score&quot;, 1);
}

function downVote(id) {
    client.hincrby(&quot;link:&quot; + id, &quot;score&quot;, -1);
}

function showDetails(id) {
    client.hgetall(&quot;link:&quot; + id, function (err, replies) {
        console.log(&quot;Title:&quot;, replies[&quot;title&quot;]);
        console.log(&quot;Author:&quot;, replies[&quot;author&quot;]);
        console.log(&quot;Link:&quot;, replies[&quot;link&quot;]);
        console.log(&quot;Score:&quot;, replies[&quot;score&quot;]);
    });
}


saveLink(123, &quot;dayvson&quot;, &quot;Maxwell Dayvson's Github page&quot;, &quot;http://github.com/dayvson&quot;);

upVote(123);
upVote(123);

saveLink(456, &quot;hltbra&quot;, &quot;Hugo Tavare's Github Page&quot;, &quot;https://github.com/hltbra&quot;);
upVote(456);
upVote(456);
downVote(456);

showDetails(123);
showDetails(456);

client.quit();&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;실행-결과-2&quot;&gt;실행 결과&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Title: Maxwell Dayvson's Github page
Author: dayvson
Link: http://github.com/dayvson
Score: 2
Title: Hugo Tavare's Github Page
Author: hltbra
Link: https://github.com/hltbra
Score: 1&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;그-외&quot;&gt;그 외&lt;/h2&gt;
&lt;p&gt;keys : 패턴과 일치하는 저장된 모든 키 리턴&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;keys p*
&amp;gt; &quot;philosoper&quot;&lt;/code&gt;&lt;/pre&gt; &lt;/article&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jhleed.tistory.com/128&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Redis</category>
<author>James Lee.</author>
<guid>https://jhleed.tistory.com/128</guid>
<comments>https://jhleed.tistory.com/128#entry128comment</comments>
<pubDate>Sun, 10 Mar 2019 21:29:37 +0900</pubDate>
</item>
<item>
<title>Spring Boot의 Config Annotation 에 대해 알아보자</title>
<link>https://jhleed.tistory.com/126</link>
<description>&lt;article class=&quot;markdown-body entry-content&quot; itemprop=&quot;text&quot;&gt; &lt;p&gt;&lt;span style=&quot;font-weight: normal;&quot;&gt;스프링을 써본 개발자라면, Spring 환경설정을 하다 진이 빠진 경험이 한 두번 쯤은 있을 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;스프링 부트는 어떻게 이러한 설정이 없이 동작이 가능한 것일까?&lt;/p&gt;
&lt;p&gt;스프링 부트는 여러 자주 사용되는 설정들이 기본적으로 잡혀 있다.&lt;/p&gt;
&lt;p&gt;스프링 부트의 시작점인 Application 클래스는 보통 아래와 같은 구조를 가지고 있다.&lt;/p&gt;
&lt;p&gt;(Spring Boot 2.x에서는 &lt;code&gt;@SpringBootApplication&lt;/code&gt; 을 사용한다.)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.builder.SpringApplicationBuilder;

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).run(args);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이&lt;code&gt;@SpringBootApplication&lt;/code&gt; 을 열어보면 아래와 같은 구조를 가지고 있다.&lt;/p&gt;
&lt;p&gt;여기서부터 하나씩 알아보자.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = {
        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
 //...
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;빈-등록하기---componentscan&quot;&gt;빈 등록하기 - &lt;code&gt;@ComponentScan&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;스프링에서 관리하는 POJO(Plain Old Java Object)를 '빈(Bean)'이라 한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@ComponentScan&lt;/code&gt; 어노테이션은 현재 패키지 이하에서 &lt;code&gt;@Component&lt;/code&gt; 어노테이션이 붙어 있는 클래스들을 찾아서 빈으로 등록하는 역할을 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Controller
public class XXController {
    //...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Spring MVC&lt;/code&gt; 에서 자주 사용되는 &lt;code&gt;@Controller&lt;/code&gt; 어노테이션도 내부를 까보면 이 &lt;code&gt;@Component&lt;/code&gt; 를 가지고 있는 것을 확인할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller {

    /**
     * The value may indicate a suggestion for a logical component name,
     * to be turned into a Spring bean in case of an autodetected component.
     * @return the suggested component name, if any (or empty String otherwise)
     */
    String value() default &quot;&quot;;

}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;심지어 설정 파일 어노테이션인 &lt;a href=&quot;https://github.com/Configuration&quot;&gt;@Configuration&lt;/a&gt; 자체도 &lt;a href=&quot;https://github.com/Component&quot;&gt;@Component&lt;/a&gt;이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Configuration {
    @AliasFor(
        annotation = Component.class
    )
    String value() default &quot;&quot;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;설정-자동-등록하기---enableautoconfiguration&quot;&gt;설정 자동 등록하기 - &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; 은 Spring Boot의 핵심으로써, 미리 정의되어 있는 빈들을 가져와서 등록해준다.&lt;/p&gt;
&lt;p&gt;요 녀석도 &lt;a href=&quot;https://github.com/SpringBootApplication&quot;&gt;@SpringBootApplication&lt;/a&gt; 어노테이션에 포함되어 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = {
        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication { &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;@EnableAutoConfiguration&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public @interface EnableAutoConfiguration {

    String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그렇다면 기본적으로 설정되어 있는 빈들은 어디에 정의되어 있는 것일까?&lt;/p&gt;
&lt;p&gt;그 빈들은 외부 라이브러리(External Libraries)중 spring-boot-autoconfigure에 정의되어 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9911DD3E5C7B8A590C&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;이 중 META-INF 디렉토리 하위의 spring.factories 파일에 자동으로 가져올 Bean들이 정의되어 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/991550415C7B8A581E&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99D7243F5C7B8A5805&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;AOP와 같은 각종 스프링의 설정들이 기본으로 잡혀 있는 것을 볼 수 있다. 위에 설정 정의가 기본적으로 되어 있고, 우리가 해당 의존성을 설치했을 때 위의 설정대로 적용이 되는 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 중 &lt;code&gt;org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration&lt;/code&gt; 이라는 녀석은 디스패쳐 서블릿을 정의해주는 설정 파일이다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dispatcherservletautoconfiguration.java&quot;&gt;DispatcherServletAutoConfiguration.java&lt;/a&gt; 파일을 열면 아래와 같이 되어 있다.&lt;/p&gt;
&lt;p&gt;(org.springframework.boot.autoconfigure.web 패키지에 있다.)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@AutoConfigureOrder(-2147483648)
@Configuration
@ConditionalOnWebApplication(
    type = Type.SERVLET
)
@ConditionalOnClass({DispatcherServlet.class}) //DispatcherServlet 일 때만 해당 설정이 적용 됨
@AutoConfigureAfter({ServletWebServerFactoryAutoConfiguration.class})
public class DispatcherServletAutoConfiguration {
    public static final String DEFAULT_DISPATCHER_SERVLET_BEAN_NAME = &quot;dispatcherServlet&quot;;
    public static final String DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME = &quot;dispatcherServletRegistration&quot;;

    public DispatcherServletAutoConfiguration() {
    }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이러한 설정 구조를 파악하고 나면, 사용자가 빈을 재정의 할 수 있다. &lt;/p&gt;
&lt;p&gt;원하는대로 커스터마이징이 가능하게 된다는 말이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ex) 디스패처 서블릿을 사용자가 재정의 할 수 있다.&lt;/li&gt;
&lt;/ul&gt; &lt;/article&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jhleed.tistory.com/126&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<author>James Lee.</author>
<guid>https://jhleed.tistory.com/126</guid>
<comments>https://jhleed.tistory.com/126#entry126comment</comments>
<pubDate>Sun, 03 Mar 2019 17:03:37 +0900</pubDate>
</item>
</channel>
</rss>