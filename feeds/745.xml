<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cro, Developer</title>
  <subtitle>컴파일러는 거짓말을 하지 않는다.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dev-juyoung.github.io/"/>
  <updated>2017-11-13T06:51:23.000Z</updated>
  <id>https://dev-juyoung.github.io/</id>
  
  <author>
    <name>Juyoung, Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android, 조금 더 쉬운 Retrofit 사용을 위한 ServiceGenerator Class.</title>
    <link href="https://dev-juyoung.github.io/2017/11/13/android-retrofit-service-generator/"/>
    <id>https://dev-juyoung.github.io/2017/11/13/android-retrofit-service-generator/</id>
    <published>2017-11-13T03:40:03.000Z</published>
    <updated>2017-11-13T06:51:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android에서 Retrofit 사용하기 두번째 포스팅 입니다.</p>
<p>이전 포스팅에서는 Retrofit을 프로젝트에 추가하고 간단히 사용해보이는 포스팅을 작성하였는데요.</p>
<p><code>Retrofit객체 설정</code> -&gt; <code>API 규격에 맞는 Interface 선언</code> -&gt; <code>Retrofit객체와 Interface를 이용한 클라이언트 객체 생성</code></p>
<p>이러한 일괄의 과정을 통해 결론적으로 얻게 되는 클라이언트 객체를 이용하여 실제 통신을 하게 된다는 것을 이전 포스팅에서 알아보았습니다.</p>
<p>하지만, 아쉽게도 하나의 Application에서는 한번의 통신만이 아닌 수많은 REST API 통신을 구성하여 실제 사용자와 인터렉션한다는 것을 알고 계실 겁니다.</p>
<p>그렇다면 만약 우리가 개발해야 될 App에 50번의 통신이 발생한다고 과정해보죠.</p>
<p>Interface는 단순히 method를 늘려가는 작업으로 해결 될 수 있을 것 같지만,</p>
<p>최악의 경우, 통신이 필요한 곳마다 위에 적혀 있는 일괄의 작업을 50번 하게 됩니다.</p>
<p>그렇다면 더 최악의 경우, Retrofit객체가 50번이나 생성될 수도 있다는 암묵적인 의미도 가지고 있을 수 있겠네요…</p>
<p>그렇다면 여기서 한번 더 시나리오를 추가해봅시다.</p>
<ul>
<li>특정 상황에 의해 통신해야 될 API 서버의 URL이 바뀌어 버린다면?</li>
<li>서버 개발자와 기존엔 협의 되지 않았던 Header에 Token 정보를 API 요청 시, 전달해달라고 한다면?</li>
</ul>
<p>지금 당장엔 두가지 밖에 떠오르지 않는군요.</p>
<p>여러분은 이러한 상황을 겪었을 경우, 문제를 해결하기 위해 어떻게 접근하실 건가요?</p>
<p>정말 일차원적인 생각으로는 하나의 Retrofit 객체를 잘 작동하게 변경하여 50번의 <code>ctrl + c / v</code>를 통해 변경하는 방법이 있습니다.</p>
<p>하지만, 제가 생각하는 개발자란 종족은 언제나 게으르고 싶어하는 종족이라고 생각이 됩니다.</p>
<p>같은 작업을 여러번 하기 싫어하기 때문에, 시스템을 통해 자동화를 하기 시작한게 아닐까요?</p>
<p>이렇듯, 게으른 우리 개발자님들을 위해, </p>
<p>갑작스레 어떠한 변수가 생기더라도 조금 더 대응하기 쉽고, 조금 더 사용하기 쉽게 Retrofit을 관리할 수 있는 방법인 <code>ServiceGenerator</code>클래스에 대해 포스팅을 해보려 합니다.<br><a id="more"></a></p>
<p><del>솔직히, 이번 포스팅은 특별히 적어나갈 내용이 없어요…ㅜㅜㅜ</del></p>
<p>그럼에도 불구하고 이러한 내용을 정리하는 목적요?</p>
<p><strong>설마 서버 URL이 그렇게 자주 바뀌겠어?</strong>와 같은 변명을 해보고 싶지만, 제가 위에 잠시 언급했던 일차원적인 삽질을 하던 개발자 였거든요…ㅎㅎ</p>
<p>하지만 일차원적이였던 저도 어느 순간 개선을 위해 발버둥을 하였고, 나름대로 Retrofit을 관리하는 별도의 클래스를 작성했던 적이 있는데,</p>
<p>우연히 Retrofit에 대한 정보를 얻기 위해 구글링 중, <a href="https://futurestud.io/tutorials/retrofit-getting-started-and-android-client" target="_blank" rel="external">FutureStudio Blog</a>의 <code>ServiceGenerator</code>클래스를 접한적이 있었습니다.</p>
<p>이 클래스를 보고 나서, <strong>우와, 내가 작성했던 클래스가 틀린 방법은 아니였구나!</strong>라는 생각과 나름 개인적인 뿌듯함을 느꼈던 적이 있었습니다.</p>
<p>물론, FutrueStudio Blog를 제가 Retrofit을 갓 사용하게 되었을 때 알았더라면 더 좋긴 했겠지만요…<br><del>왜냐하면, 코드는 제가 작성한 클래스보다 ServiceGenerator가 더 이쁘거든요…ㅜㅜ</del></p>
<p>그래서, 혹시라도 저와 같은 삽질을 경험하고 계시는 분이 남아 계시다면 더 좋은 방법과 코드를 위해 소개를 해드리고자 포스팅을 쓰게 되었습니다.</p>
<h2 id="시작하기에-앞서"><a href="#시작하기에-앞서" class="headerlink" title="시작하기에 앞서"></a>시작하기에 앞서</h2><p>앞으로 계속적으로 Retrofit과 관련된 포스팅을 추가해 나갈 예정 이기에, </p>
<p>혹시 이전의 글을 참고하시고 싶은 분들을 위해 항상 글의 서두에는 이미 작성된 포스팅을 <code>연관 포스팅</code> 섹션으로 소개하고 시작하고자 합니다.</p>
<p>또한, 각 포스팅 마다 관련된 예제 코드의 전체 소스를 확인할 수 있도록 관련된 Github Repository를 언급하고 시작할까 합니다.</p>
<h2 id="연관-포스팅"><a href="#연관-포스팅" class="headerlink" title="연관 포스팅"></a>연관 포스팅</h2><ul>
<li><a href="https://dev-juyoung.github.io/2017/11/10/android-retrofit-basic/">Retrofit 설정과 기본 사용법</a><ul>
<li><a href="https://github.com/dev-juyoung/retrofit-sample/tree/basic-usage" target="_blank" rel="external">참고 Repository</a></li>
</ul>
</li>
<li><a href="https://dev-juyoung.github.io/2017/11/13/android-retrofit-service-generator/">Retrofit ServiceGenerator</a> (현재글)<ul>
<li><a href="https://github.com/dev-juyoung/retrofit-sample/tree/service-generator" target="_blank" rel="external">참고 Repository</a></li>
</ul>
</li>
</ul>
<h2 id="ServiceGenerator-Class-작성"><a href="#ServiceGenerator-Class-작성" class="headerlink" title="ServiceGenerator Class 작성."></a>ServiceGenerator Class 작성.</h2><p>지금 작성하려는 이 <code>ServiceGenerator</code>라는 녀석은 도대체 뭘 위해서 작성하는 걸까요?</p>
<p>위에서도 잠시 언급했지만, 궁극적인 목적은 <strong>공통적으로 사용될 코드의 분리</strong> 라고 생각합니다.</p>
<p>더불어 <strong>유지보수의 편리성</strong>을 위해서 이겠지요.</p>
<p>특별한 경우가 아니라면 하나의 Application은 하나의 동일한 서버로 요청을 하고, 사용자 인증에 관련된 정보 또한 서버 개발자와 협의된 방식을 이용하여 동일한 방법으로 요청을 하게 됩니다.</p>
<p>그렇기에 통신을 필요로하는 곳 마다 Retrofit 객체를 생성할 필요는 없습니다.</p>
<p>하나의 Retrofit 객체만 생성하여 관리하고, 생성된 해당 Retrofit 객체를 이용하여 사용될 Interface만 교체해가며, 클라이언트 객체를 만들어내기만 하면 되니까요.</p>
<p><code>백문이 불여일타</code> 코드부터 확인해봅시다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceGenerator</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL = <span class="string">"https://api.github.com/"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> OkHttpClient.Builder httpClient = <span class="keyword">new</span> OkHttpClient.Builder();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Retrofit.Builder builder =</div><div class="line">            <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">                    .baseUrl(URL)</div><div class="line">                    .addConverterFactory(GsonConverterFactory.create())</div><div class="line">                    .client(httpClient.build());</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Retrofit retrofit = builder.build();</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">S <span class="title">createService</span><span class="params">(Class&lt;S&gt; serviceClass)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> retrofit.create(serviceClass);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이미 이전 포스팅에서 Retrofit.Builder의 설정 및 Retrofit 객체 생성에 대해서는 다루었던 부분이기에, 이해가 안가시는 코드는 없을 것으로 판단됩니다.</p>
<p>정말 기본적인 설정만을 가지고 만들어진 ServiceGenerator의 골격입니다.</p>
<p>이전 포스팅인 <a href="https://dev-juyoung.github.io/2017/11/10/android-retrofit-basic/">Retrofit 기본 사용법</a>에서 살펴 보았듯, URL을 설정하고 사용할 Converter를 지정해주는 코드를 별도의 클래스로 분리한 것이죠.</p>
<p>static 키워드를 이용하여 해당 Retrofit 객체를 정적 객체로 만들어 주었다는 것 밖에는 없습니다.</p>
<p>한가지 조금 틀린점이 있다면 <code>createService()</code>라는 정적 method가 추가되었다는 것인데요.</p>
<p>API 명세에 따라 용도에 맞게 Interface를 여러개 생성할 수 있기 때문에 <code>Generic</code> 타입으로 Interface Class를 매개변수로 받을 수 있도록 해주었고,</p>
<p>받아온 Interface 타입으로 클라이언트 객체를 리턴해주기 위해 Generic 타입을 그대로 다시 리턴해주는 역할을 합니다.</p>
<h2 id="ServiceGenerator-Class-사용"><a href="#ServiceGenerator-Class-사용" class="headerlink" title="ServiceGenerator Class 사용."></a>ServiceGenerator Class 사용.</h2><p>그렇다면, 이제 이렇게 작성된 ServiceGenerator를 실제 사용하는 법을 알아봅시다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">GithubService service = ServiceGenerator.createService(GithubService.class);</div><div class="line"></div><div class="line">Call&lt;JsonArray&gt; request = service.getUserRepositories(<span class="string">"dev-juyoung"</span>);</div><div class="line">request.enqueue(<span class="keyword">new</span> Callback&lt;JsonArray&gt;() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;JsonArray&gt; call, Response&lt;JsonArray&gt; response)</span> </span>&#123;</div><div class="line">    <span class="comment">// Code...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;JsonArray&gt; call, Throwable t)</span> </span>&#123;</div><div class="line">    <span class="comment">// Code...</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>통신이 필요한 곳에서 Retrofit 객체를 생성해주고, 생성된 Retrofit 객체와 Interface를 이용하여 클라이언트 객체를 만드는 몇줄에 걸쳐 작성되어야 할 코드들 대신,</p>
<p>우리가 작성한 <code>ServiceGenerator</code> 클래스를 이용하고, 해당 클래스에 정의되어 있는 <code>createService()</code> method를 호출하여, 클라이언트 객체를 가져오기만 하면 됩니다.</p>
<p>클라이언트 객체를 가져온 이후부터는 지금까지와 같은 방식으로 <code>enqueue()</code> 또는 <code>execute()</code>를 이용해 실제 통신을 진행하시면 되죠.</p>
<p>Square에서 Retrofit 사용을 워낙 간단하게 할 수 있도록 만들어 주었기에 몇 줄 차이나진 않지만, 그래도 조금은 깔끔해진 느낌이 들지 않나요?</p>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리."></a>마무리.</h2><p>이번 포스팅에서는 <code>ServiceGenerator</code>라는 녀석으로 Retrofit에 대한 설정과 객체생성, 그리고 실제 통신에 사용될 클라이언트 객체에 대한 생성과 관련된 부분을 별도의 클래스로 분리하는 방법을 소개해드렸습니다.</p>
<p>글을 작성하며, 이 글을 따로 분리 할 필요가 있을까?라는 의문도 조금은 들긴 했습니다.</p>
<p>어떤분에게는 <strong>당연히 이렇게 분리해서 설계하는게 맞지 않아?</strong> 라는 반응이 있을 수도,</p>
<p>어떤분에게는 <strong>특별히 개선된 걸 잘 모르겠는데?</strong>라는 반응이 있을 수도 있습니다.</p>
<p>하지만 실질적으로 많은 분들과 이야기를 나눠보면 저와 같은 초보개발자 분들은 <code>ctrl + c / v</code> 불상사를 겪었던 분들이 적진 않은 것으로 보입니다.</p>
<p>물론 조금 더 고민하고 시간을 두고 프로그램을 작성한다면 나중에 있을 변수와 유지보수까지 고려한 코드를 작성할 순 있겠지만,</p>
<p>스타트업과 같은 환경에서는 시간에 쫓겨 작성하다 보면 저처럼, 이러한 사소한 부분을 놓치는 바람에 후에 큰 불상사를 겪기도 하지요.</p>
<p>여하튼, 저도 시간에 쫓긴다고 급하게 작성할 게 아니라 이렇게 공통적으로 사용이 가능한 코드는 <code>ServiceGenerator</code>와 같은 클래스처럼 별도로 분리해서 작성하는 버릇을 조금 들여야 한다고 이번 글을 작성하며 다시 한번 반성하게 되었습니다.</p>
<p>그리고 더 나아가, 누구에겐 아무것도 아닐 수 있겠지만 이러한 습관을 들이는 것이 Java의 핵심인 OOP에 조금 더 가까워 질 수 있는 방법이 아닐까 싶기도 하구요.</p>
<p>각설하고, 이번 포스팅에서는 어찌보면 제 신세한탄인가 싶을 정도의 포스팅이 되었지만, 궁극적인 주제는 <code>ServiceGenerator</code>였습니다!</p>
<p>혹여 아직도, Retrofit에 대한 설정과 사용을 <code>ctrl + c/v</code>로 처리하고 계신가요?</p>
<p>그렇다면 소개해드린 <code>ServiceGenerator</code> 클래스를 작성하여 코드를 개선해 보세요!<br><del>물론 기존 코드들 정리해야 되는 시간이 소요된다는 건 안 비밀…</del></p>
<p>약간의 시간이 소요되더라도 조금의 노력으로 조금 더 나은 프로그래밍을 할 수 있다면 더 좋은게 아닐까요? ㅎㅎ</p>
<p>이번 포스팅(신세한탄)은 이쯤에서 마무리하고, 두번의 간단한 Retrofit 소개가 있었으니, 실제 사용에 대한 감도 익히셔야 겠죠?</p>
<p>다음 포스팅에서는 Retrofit과는 조금 주제에 거리감이 있을 수 있지만,</p>
<p>지금까지 다룬 Retrofit과 포스팅으로 다루진 않았지만, Android에서 리스트를 표출하기 위한 RecyclerView를 이용하여 일반적인 Android 개발에 사용되는 <code>MVC Pattern</code>을 적용한 통신과 리스트 표출에 대한 내용을 다뤄보고자 합니다.</p>
<p>이번 글에서도 잘못된 정보가 있다면, 댓글에 거침없는 질타와 조언 부탁드립니다! 끝까지 읽어주셔서 감사합니다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android에서 Retrofit 사용하기 두번째 포스팅 입니다.&lt;/p&gt;
&lt;p&gt;이전 포스팅에서는 Retrofit을 프로젝트에 추가하고 간단히 사용해보이는 포스팅을 작성하였는데요.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Retrofit객체 설정&lt;/code&gt; -&amp;gt; &lt;code&gt;API 규격에 맞는 Interface 선언&lt;/code&gt; -&amp;gt; &lt;code&gt;Retrofit객체와 Interface를 이용한 클라이언트 객체 생성&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;이러한 일괄의 과정을 통해 결론적으로 얻게 되는 클라이언트 객체를 이용하여 실제 통신을 하게 된다는 것을 이전 포스팅에서 알아보았습니다.&lt;/p&gt;
&lt;p&gt;하지만, 아쉽게도 하나의 Application에서는 한번의 통신만이 아닌 수많은 REST API 통신을 구성하여 실제 사용자와 인터렉션한다는 것을 알고 계실 겁니다.&lt;/p&gt;
&lt;p&gt;그렇다면 만약 우리가 개발해야 될 App에 50번의 통신이 발생한다고 과정해보죠.&lt;/p&gt;
&lt;p&gt;Interface는 단순히 method를 늘려가는 작업으로 해결 될 수 있을 것 같지만,&lt;/p&gt;
&lt;p&gt;최악의 경우, 통신이 필요한 곳마다 위에 적혀 있는 일괄의 작업을 50번 하게 됩니다.&lt;/p&gt;
&lt;p&gt;그렇다면 더 최악의 경우, Retrofit객체가 50번이나 생성될 수도 있다는 암묵적인 의미도 가지고 있을 수 있겠네요…&lt;/p&gt;
&lt;p&gt;그렇다면 여기서 한번 더 시나리오를 추가해봅시다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;특정 상황에 의해 통신해야 될 API 서버의 URL이 바뀌어 버린다면?&lt;/li&gt;
&lt;li&gt;서버 개발자와 기존엔 협의 되지 않았던 Header에 Token 정보를 API 요청 시, 전달해달라고 한다면?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;지금 당장엔 두가지 밖에 떠오르지 않는군요.&lt;/p&gt;
&lt;p&gt;여러분은 이러한 상황을 겪었을 경우, 문제를 해결하기 위해 어떻게 접근하실 건가요?&lt;/p&gt;
&lt;p&gt;정말 일차원적인 생각으로는 하나의 Retrofit 객체를 잘 작동하게 변경하여 50번의 &lt;code&gt;ctrl + c / v&lt;/code&gt;를 통해 변경하는 방법이 있습니다.&lt;/p&gt;
&lt;p&gt;하지만, 제가 생각하는 개발자란 종족은 언제나 게으르고 싶어하는 종족이라고 생각이 됩니다.&lt;/p&gt;
&lt;p&gt;같은 작업을 여러번 하기 싫어하기 때문에, 시스템을 통해 자동화를 하기 시작한게 아닐까요?&lt;/p&gt;
&lt;p&gt;이렇듯, 게으른 우리 개발자님들을 위해, &lt;/p&gt;
&lt;p&gt;갑작스레 어떠한 변수가 생기더라도 조금 더 대응하기 쉽고, 조금 더 사용하기 쉽게 Retrofit을 관리할 수 있는 방법인 &lt;code&gt;ServiceGenerator&lt;/code&gt;클래스에 대해 포스팅을 해보려 합니다.&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://dev-juyoung.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://dev-juyoung.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Retrofit 기본 사용법</title>
    <link href="https://dev-juyoung.github.io/2017/11/10/android-retrofit-basic/"/>
    <id>https://dev-juyoung.github.io/2017/11/10/android-retrofit-basic/</id>
    <published>2017-11-10T08:37:21.000Z</published>
    <updated>2017-11-13T03:30:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>개인 App을 만들거나 현업에서 App을 만들다보면, 단순한 화면이동 등의 기능으로는 사용자의 요구사항을 충당하기 힘이 듭니다.</p>
<p>일반적인 App은 서버와 클라이언트가 네트워크 통신을 통해 데이터를 주고 받으며 실질적으로 화면에 정보를 표출하고, 입력된 정보를 저장하는 등의 여러가지 기능들이 구현되어 있습니다.</p>
<p>App에서의 네트워킹 기능은 필수라고 해도 과언이 아닐 정도이죠.</p>
<p>그리고 요즘은 일반적으로 서버와 클라이언트가 데이터를 주고 받는 과정에서, <code>REST API</code>라는 방식을 이용하여 네트워크 통신을 하게 됩니다.</p>
<p>Android Framework에 기본적으로 내장되어 있는 <code>AsyncTask</code>와 <code>HttpURLConnection</code> 객체를 이용하면,<br>충분히 네트워크 통신에 대한 기능을 구현할 수 있지만,<br>직접 네트워크 통신을 구현하면 필수적으로 처리해주어야 할 몇가지의 작업으로 인해 여간 귀찮은 것이 아닙니다.</p>
<p>예를들어, 네트워크 연결 / 해제 / 데이터 파싱 / 파싱된 데이터를 데이터 클래스에 저장 / 에러처리 등이 있겠네요.</p>
<p>하지만, 이렇게 귀찮은 작업을 굉장히 편리하게 해주는 도구가 있습니다.</p>
<p>이번 포스팅에서는,<br>그 중에서도, REST API 통신에 특화되어 있는 <code>Retrofit</code>이라는 App 개발 시 필수적인 Library라고 해도 과언이 아닌 녀석의 기본 사용법에 대해 정리를 해볼까 합니다.<br><a id="more"></a></p>
<p>우선 들어가기에 앞서, <a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit의 공식페이지</a>에서 소개하고 있는 내용을 <code>ctrl + c / v</code>만 잘 이용해도 바로 사용할 수 있을 정도로 자료를 제공해주고 있음에도 불구하고, 이렇게 따로 정리를 하는 이유는 영어문서에 대한 거부감이 있으신 분이나 Android 프로그래밍을 시작한지 얼마 되지 않아 Library에 대한 사용이 익숙하지 않으신 분들에게 조금이나마 도움을 드리고자 글을 작성하게 되었습니다.</p>
<p>그리고 이번 포스팅을 시작으로 <code>Retrofit</code>에 사용에 대한 감을 익히고, </p>
<p>실질적으로 <code>Retrofit</code>을 이용한 REST API 통신과 통신 후, View에 표출하는 과정까지에 대한 방법을 몇번의 포스팅으로 나눠서 작성해보고자 합니다.</p>
<h2 id="구상중인-포스팅-목록"><a href="#구상중인-포스팅-목록" class="headerlink" title="구상중인 포스팅 목록"></a>구상중인 포스팅 목록</h2><p>현재 이 글을 작성하는 시점을 기준으로 4단계의 포스팅을 구상하고 있습니다.</p>
<ul>
<li><a href="https://dev-juyoung.github.io/2017/11/10/android-retrofit-basic/">Retrofit Library 추가와 기본 사용법</a> (현재글)</li>
<li>FutureStudio에서 소개하고 있는 <code>ServiceGenerator</code> Class 작성.</li>
<li><code>MVC Pattern</code>을 적용한 Retrofit과 RecyclerView를 사용한 기능 구현.</li>
<li>완성된 MVC Pattern의 코드를 <code>MVP Pattern</code>의 코드로 적용.</li>
</ul>
<p>추가적으로, 현재의 샘플 프로젝트는 Retrofit의 사용법에 대한 감을 익히기 위한 프로젝트 이므로, <code>GET</code> 요청만 사용하지만,<br>기회가 된다면 <code>POST / PUT / DELETE</code> 요청과 파일 전송을 위한 <code>MULTIPART</code>까지 한번 내용을 추가해 보는 것이 목표입니다.</p>
<p>포스팅을 하나하나 추가해가며, 완성된 포스팅에 대한 글은 추가해나가도록 하겠습니다.</p>
<p><strong>본격적인 시작에 앞서, 최종 결과물만을 원하시는 분은 <a href="https://github.com/dev-juyoung/retrofit-sample" target="_blank" rel="external">Github SampleRepository</a>를 확인해보세요!</strong></p>
<h2 id="참고-Repository"><a href="#참고-Repository" class="headerlink" title="참고 Repository"></a>참고 Repository</h2><p>이번 포스팅과 관련된 샘플 프로젝트의 전체 코드는 링크에서 확인하세요!<br><a href="https://github.com/dev-juyoung/retrofit-sample/tree/basic-usage" target="_blank" rel="external">Github Repository</a></p>
<h2 id="Gradle-Settings"><a href="#Gradle-Settings" class="headerlink" title="Gradle Settings."></a>Gradle Settings.</h2><p>모든 Library의 사용을 위한 첫번째 관문인 Gradle을 세팅해봅시다.</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Project Level Gradle.</span></div><div class="line">ext &#123;</div><div class="line">    retrofitVersion = <span class="string">'2.3.0'</span></div><div class="line">    okhttpVersion = <span class="string">'3.9.0'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// App Level Gradle.</span></div><div class="line"><span class="keyword">dependencies</span> &#123;</div><div class="line">  <span class="keyword">compile</span> <span class="string">"com.squareup.retrofit2:retrofit:$rootProject.retrofitVersion"</span></div><div class="line">  <span class="keyword">compile</span> <span class="string">"com.squareup.retrofit2:converter-gson:$rootProject.retrofitVersion"</span></div><div class="line">  <span class="keyword">compile</span> <span class="string">"com.squareup.okhttp3:okhttp:$rootProject.okhttpVersion"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Gradle 설정작업에 있어서는 개인 성향에 따라 다르겠지만,<br>저의 경우 2번의 Gradle 작업을 진행하였습니다.</p>
<p>사용하는 의존성들에 대한 버전 관리를 조금 더 편리하게 하기 위해, <code>Project Level의 Gradle</code>에 <code>ext</code>를 추가하여, Retrofit과 OkHttp의 버전을 명시해 주었습니다.</p>
<p>두번째로, 실제 Library의 의존성 주입을 위해, <code>App Level의 Gradle</code>에 3가지의 Library를 추가해 주었습니다.</p>
<ul>
<li>Retrofit</li>
<li>Retrofit-Conveter-Gson</li>
<li>OkHttp</li>
</ul>
<p>포스팅의 주제인 <code>Retrofit</code>과 <code>Gson-Converter</code>, 그리고 <code>OkHttp</code>에 대한 의존성을 추가해주었습니다.</p>
<p>네트워크 통신 시, <code>XML / JSON 등</code> 서버개발자와 협의된 방식의 데이터 포맷으로 데이터를 주고 받게 되고,<br>결과값으로 받은 데이터 타입을 실제 프로그램에서 사용할 수 있도록 <code>데이터 파싱</code>이라는 과정이 발생합니다.</p>
<p>이때, 일반적으로 Java에서 <code>DTO 또는 VO</code>등으로 불리는 데이터 클래스를 선언하여,<br>데이터를 파싱하고 파싱된 데이터를 구조에 맞게 작성된 해당 데이터 클래스에 저장해두곤 합니다.</p>
<p>이러한 일괄의 작업들을 Retrofit은 조금 더 편리하게, 그리고 자동으로 해줄 수 있도록 몇가지의 <code>Converter</code>를 함께 제공하고 있습니다.</p>
<p>그 중, 우리는 <code>JSON</code> 포맷을 이용할 예정이며, JSON과 관련된 몇가지의 Converter 중 <code>Gson-Converter</code>을 이용하도록 할 예정입니다.</p>
<p>그렇다면, <code>OkHttp</code> 모듈은 왜 함께 추가되었는지에 대한 의문이 있을 수도 있겠네요.</p>
<p>실질적으로 샘플 프로젝트에서는 사용하고 있지 않은 방식이지만,</p>
<p>요즘들어 사용자 인증과 관련된 방법 중 많이 이야기되고 있는 <code>JSON Web Token</code>등의 방식을 통해,</p>
<p>사용자에 대한 인증정보를 <strong>매 요청마다</strong> 서버로 함께 전달해 주어야 하는 경우가 발생하거나, 개발 중 실질적인 요청과 응답에 대한 로깅을 해야되는 경우가 발생합니다.</p>
<p>비효율적인 방법으로 Token이 필요하거나 로깅이 필요한 통신에 대해서 개발자 스스로 수작업을 통한 <code>ctrl + c / v</code>를 이용하여 요청 시 마다 넣어주는 방법도 있지만,</p>
<p>Retrofit은 개발자들에게 이러한 불편함을 없애주기라도 하겠다는 듯, <code>OkHttpClient</code>를 매개변수로 받는 <code>client()</code> method를 제공해주고 있습니다.</p>
<p>우리는 위와 같은 비효율적인 작업 대신에, <code>OkHttpClient</code>객체를 생성하여, Header정보에 Token정보를 설정해주거나, 로깅과 관련된 추가적인 Library를 프로젝트에 추가 및 설정하여 입맞에 맞게 <code>OkHttpClient</code>객체를 작성하고, 이렇게 작성된 객체를 Retrofit의 <code>client()</code> method에 설정을 해주면, <code>ctrl + c / v</code>를 해오던 불필요한 수작업을 손쉽게 해결할 수 있도록 도와줍니다.</p>
<p>이번 샘플 프로젝트와 포스팅에서는 해당 범주와는 조금 맞지 않은 주제이기에, 혹여 기회가 된다면 Token 정보를 Header에 설정하거나, 로깅을 위한 추가적인 Logger Library를 설정하는 방법도 포스팅으로 다뤄보겠습니다.</p>
<p>그럼 이제 각설하고, 본격적으로 Retrofit을 추가하고, 어떻게 사용하는지 살펴보도록 합시다!</p>
<h2 id="Retrofit-Builder-설정과-Retrofit-객체-생성"><a href="#Retrofit-Builder-설정과-Retrofit-객체-생성" class="headerlink" title="Retrofit Builder 설정과 Retrofit 객체 생성."></a>Retrofit Builder 설정과 Retrofit 객체 생성.</h2><p>실질적인 통신에 앞서, Retrofit을 이용한 REST API 통신을 위해서는 2가지의 선행 작업이 필요합니다.</p>
<ul>
<li>Retrofit 객체 생성.</li>
<li>REST API 명세에 맞는 Interface 선언.</li>
</ul>
<p>해당 섹션에서는 Retrofit을 사용하기 위한 Retrofit에서 제공하는 Builder객체를 이용한 몇가지 설정과 해당 Builder객체를 이용한 실질적인 Retrofit 객체를 생성하는 방법을 다뤄보겠습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">    .baseURL(<span class="string">"https://api.github.com/"</span>)</div><div class="line">    .addConverterFactory(GsonConverterFactory.create())</div><div class="line">    .build();</div></pre></td></tr></table></figure>
<p>위의 코드를 하나하나 살펴보도록 합시다.</p>
<p>우선 Retrofit 객체를 저장할 Retrofit Type의 변수를 하나 선언해주었고,</p>
<p>Retrofit에서 제공하고 있는 Builder객체를 이용하여 몇가지 설정을 해주었습니다.</p>
<p><code>baseURL()</code> method를 이용하여, 어떤 서버로 네트워크 통신을 요청할 것인지에 대한 설정과, <code>addConverterFactory()</code> method를 이용하여,</p>
<p>통신이 완료된 후, 어떤 Converter를 이용하여 데이터를 파싱할 것인지에 대한 설정입니다.</p>
<p>우리는 위에서 <code>Gson-Converter</code>를 이용하도록 할 것이라고 언급하였고, 관련 Library를 추가해주었으니, <code>Gson-Converter</code>를 설정하였습니다.</p>
<p>추가적인 설정을 더 지정할 수 있지만, 우선은 이것만으로도 통신이 가능하므로 추가적인 설정에 대한 내용은 skip 하였습니다.</p>
<p>마지막으로, <code>build()</code> method를 통해, <code>Retrofit.Builder</code>객체에 설정한 정보를 이용하여 실질적으로 Retrofit 객체를 만들어 반환해주도록 하였습니다</p>
<p>아! 여기서 한가지 주의하셔야 할 점이 있는데요.</p>
<p>공식문서상에는 <code>baseURL()</code>에 설정된 서버 URL에 <code>/</code>가 없습니다.</p>
<p>하지만 실질적으로 여러가지 통신을 하면서 로깅을 해보면 <code>baseURL()</code>에 <code>/</code>가 없을 경우, 요청 되어야 할 URL의 일부가 잘려나가는 현상이 발생하여 잘못된 경로로 요청하는 현상이 발생할 수 있습니다.</p>
<p>그러니 꼭 <code>baseURL()</code>에 설정되는 URL의 마지막 경로에는 <code>/</code>를 함께 포함해 주도록 해주세요!</p>
<h2 id="API-규격에-맞는-Interface-선언"><a href="#API-규격에-맞는-Interface-선언" class="headerlink" title="API 규격에 맞는 Interface 선언."></a>API 규격에 맞는 Interface 선언.</h2><p>위에서 언급했던 대로, 실질적인 통신 전에 선행되어야 할 두번째 작업입니다.</p>
<p>우리는 네트워킹과 관련된 코드를 작성하기에 앞서, 서버 개발자와 사전에 협의된 REST API 명세에 맞게 Interface를 선언해주어야 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GithubService</span> </span>&#123;</div><div class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</div><div class="line">  <span class="function">Call&lt;JsonArray&gt; <span class="title">getUserRepositories</span><span class="params">(@Path(<span class="string">"user"</span>)</span> String userName)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>간단하죠? 그럼 해당 코드도 위에서부터 차근차근 한번 살펴보도록 하죠.</p>
<p>코드를 살펴보기에 앞서, Retrofit을 처음 사용하는 분에게는 조금은 생소한 키워드도 있을 법 합니다.</p>
<p>우선 처음보는 키워드를 언급하고 코드를 살펴보면 조금 더 쉬운 이해를 도울 수 있을 것 같습니다.</p>
<ul>
<li><code>@GET / @Path</code> Annotation</li>
<li><code>Call&lt;JsonArray&gt;</code></li>
</ul>
<p><code>@GET / @Path</code>와 같이 <code>@</code>가 붙은 키워드는 흔히 Java 언어에서 사용되는 Annotation 키워드 입니다.</p>
<p>Retrofit은 REST API 통신에 필요한 요소들에 대해서 Annotation을 만들어 두었습니다.</p>
<p><code>@GET</code> Annotation의 경우, HTTP 통신에 사용되는 method 중 GET 요청을 하겠다라는 것을 명시해주는 Annotation이며,</p>
<p><code>@Path</code> Annotation의 경우, URL부분 중 일부의 경로가 필요에 따라 동적으로 바인딩 되어야 하는 경우 <code>@Path</code> Annotation을 지정하여, 문자열을 정의 해두면 해당 문자열을 URL부분 일부에 바인딩하여 동적으로 URL을 만들 수 있도록 도와주는 Annotation 입니다.</p>
<p><code>Call&lt;JsonArray&gt;</code>의 경우는 해당 코드를 추적하여 들여다 보면 Retrofit이 <code>Call&lt;T&gt;</code> 형태의 Generic Type을 매개변수로 받는 Callback Interface인 것을 알 수 있습니다.</p>
<p>조금은 생소했던 키워드들이 눈에 들어오기 시작하였나요? 그럼 다시 코드를 한번 살펴보죠.</p>
<p>우선 method를 선언하는 상단부에, <code>@GET</code> Annotation을 이용하여 해당 method를 구현하는 요청은 <code>HTTP GET</code> 요청을 할 것이라고 명시를 해주었고,<br><code>@GET</code> Annotation 바로 뒤에 <code>()</code>를 이용하여 실질적으로 요청할 API의 URL을 선언해주었습니다.</p>
<p>요청 URL의 경로를 <code>https://</code> 형태로 정의하지 않은 이유는, 우리는 위에서 선행작업을 진행하며 <code>Retrofit</code>객체에 이미 어떤 서버로 요청을 할 것인지 명시를 해두었기 때문에,</p>
<p>해당 Retrofit의 객체와 해당 Interface의 method를 이용하여 통신을 구현하면 <code>https://api.github.com/</code>과 <code>users/{user}/repos</code> URL이 합쳐진 완성된 URL인 <code>https://api.github.com/users/{user}/repos</code> URL로 요청을 할 수 있게 됩니다. 그렇기에 Interface에 정의되는 URL은 <strong>서버 URL을 제외한</strong> 나머지 URL만 작성하면 됩니다.</p>
<p>하단부에는, String 데이터 하나를 매개변수로 전달 받는 <code>Call&lt;JsonArray&gt;</code> 타입을 리턴하는 메서드를 선언해주었습니다.</p>
<p>위에서 언급했던 대로 <code>Call&lt;JsonArray&gt;</code>는 Retrofit이 미리 선언해둔 <code>Call&lt;T&gt;</code>형태의 Callback Interface 인데, 추후에는 실질적으로는 구조에 맞게 작성된 데이터 클래스를 지정하도록 하겠지만, 현재는 빠르게 Retrofit을 사용해보기 위해 <code>JsonArray</code> 타입을 지정하여 Callback으로 JsonArray 타입의 데이터를 전달 받을 수 있도록 그대로 지정하였습니다.</p>
<p>그리고, method의 매개변수에 드디어 위에서 언급했던 <code>@Path</code> Annotation이 있군요.</p>
<p>위에서 잠시 언급하였지만, <code>@Path</code> Annotation은 URL의 특정부분에 문자열을 바인딩해준다고 했습니다. </p>
<p>우리는 해당 method를 구현할 때, String 데이터 하나를 매개변수로 전달하게 되며, 이렇게 전달된 문자열은 <code>@GET</code> Annotation에 정의되어 있는 URL 중, <code>{}</code>로 묶인 <code>{user}</code> 부분에 해당 문자열을 매칭하여 바인딩해주게 됩니다.</p>
<p>그렇다면 우리는 동적인 URL을 이용하여 통신하기 위해서는 <code>@GET / @POST</code> Annotation의 URL 선언부에 <code>{}</code>로 동적으로 변경되어야 할 URL의 일부를 묶어주면 된다는 것을 알게 되었습니다.</p>
<p>Interface의 선언은 이것으로 끝입니다!</p>
<p>이렇게 잠깐 살펴보았지만, 굉장히 <strong>직관적이다</strong>라는 생각이 들지 않나요?</p>
<p>Retrofit은 HTTP 통신에 필요한 요소들에 대해 많은 Annotation을 제공하고 있으며,</p>
<p>이러한 Annotation들을 조합하여, 조금 더 네트워크 통신에 대한 코드를 직관적이고 편리하게 사용할 수 있도록 제공해주고 있습니다.</p>
<p>이번 포스팅에서는 Retrofit이 제공하는 Annotation 모두를 다루기에는 너무 방대하므로,</p>
<p>포스팅을 작성해나가며 새롭게 등장하는 Annotation이 있다면 그때 그때 필요에 따라 해당 Annotation에 대한 설명을 붙여나가도록 하고,</p>
<p>조금 더 자세히 Retrofit이 제공하는 Annotation에 대해 알고싶으신 분들에게는 아쉽지만, 개인의 몫으로 남겨두도록 하겠습니다.</p>
<h2 id="클라이언트-객체-생성-및-요청"><a href="#클라이언트-객체-생성-및-요청" class="headerlink" title="클라이언트 객체 생성 및 요청."></a>클라이언트 객체 생성 및 요청.</h2><p>Retrofit 객체 생성과 API명세에 맞는 Interface를 선언하였다면 통신을 위한 모든 준비는 완료되었습니다.</p>
<p>이제 남은 것은 해당 Retrofit 객체와, 선언된 Interface를 이용하여 실제 HTTP 통신을 요청하고 결과를 받는 작업이겠지요?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">GithubService service = retrofit.create(GithubService.class);</div><div class="line">Call&lt;JsonArray&gt; request = service.getUserRepositories(<span class="string">"dev-juyoung"</span>);</div><div class="line">request.enqueue(<span class="keyword">new</span> Callback&lt;JsonArray&gt;() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;JsonArray&gt; call, Response&lt;JsonArray&gt; response)</span> </span>&#123;</div><div class="line">    <span class="comment">// Code...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;JsonArray&gt; call, Throwable t)</span> </span>&#123;</div><div class="line">    <span class="comment">// Code... </span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Retrofit객체의 <code>create()</code> method와 미리 정의해둔 Interface를 이용하여 실질적으로 사용할 클라이언트 객체를 생성합니다.</p>
<p>이렇게 생성된 클라이언트 객체를 이용하여 요청을 보내고 받아온 응답을 가지고 특정 작업을 하고나면 해당 Retrofit객체의 사용은 끝이나게 되지요.</p>
<p>위의 예제코드에서는 생성된 클라이언트 객체가 제공하는 <code>enqueue()</code> method를 이용하여 요청을 처리하였고, 해당 method에 익명의 Callback Interface를 구현하여 주었습니다.</p>
<p>해당 Callback Interface는 <code>onResponse</code>와 <code>onFailure</code> method를 구현해주어야 하며, method의 명에서도 이미 알 수 있듯,</p>
<p><code>onResponse()</code>에서는 요청이 성공된 경우의 처리를, <code>onFailure()</code>에서는 요청이 실패된 경우의 처리를 해주면 됩니다.</p>
<p>한가지 주의하여야 할 점이라면,</p>
<p>제 경험상 <code>onFailure()</code>의 경우 <strong>정말 요청이 실패된 경우</strong>에 한해서만 호출이 됩니다.</p>
<p>즉, 여기서 말하는 <code>정말 요청이 실패된 경우</code>라 하면,</p>
<p>요청한 API 서버의 다운 / DB Query 중 오류 등와 같은 서버의 비정상적인 동작으로 인해 요청에 대한 응답을 받지 못하는 경우를 말합니다.</p>
<p>또한 <code>onResponse()</code>를 호출하였다 하더라도, 무조건적인 성공이 보장되지는 않는다는 것 입니다.</p>
<p>기획 또는 서버 개발자의 의도에 따라 서버에서 <code>40x</code>등의 응답코드를 전송할 경우라 할지라도, 실질적으로는 <code>onResponse()</code>를 호출합니다.</p>
<p>따라서, <code>onResponse()</code> method 에서는 두번째 매개변수로 전달되는 <code>response</code>를 잘 활용하여, </p>
<p>해당 응답이 <code>20x</code>의 응답코드를 가진 정상적인 응답인지, <code>40x</code>등의 응답코드를 가진 요청은 정상적이였으나 실패된 응답인지 판단하는 추가적인 코드들은 필요할 수 있습니다.</p>
<p>위에서 언급한 <code>40x</code>등의 응답코드를 가졌을 경우, 추가적으로 필요한 Error 핸들링은 추후 자체적인 테스트용 API 서버를 구축한 뒤 포스팅으로 한번 다뤄보겠습니다.</p>
<h2 id="동기-vs-비동기"><a href="#동기-vs-비동기" class="headerlink" title="동기 vs 비동기."></a>동기 vs 비동기.</h2><p>현재 이 글을 보고 계신 개발자 분이라면, 정확히 어떤 뜻을 가지고 있는지는 모를 수 있지만</p>
<p>동기식과 비동기식 방식에 대한 용어는 익히 들어 보셨을 것 같습니다.</p>
<p>추가적으로 설명하기 위해 추가한 해당 섹션에서는 Retrofit을 이용하는 경우, 동기식 방식의 통신과 비동기식 방식의 통신을 어떻게 처리하는지에 대해 언급하고자 추가하였습니다.</p>
<p>우선 자주 사용 될 법한 비동기식 방식의 통신은 위에서 이미 사용해 본 <code>enqueue()</code> method를 이용하는 것 입니다.</p>
<p>이미 코드를 작성하며 느끼셨을 수도 있지만, 매개변수로 Callback Interface를 구현하는 익명객체를 넘겨준다는 것만 보셔도 비동기 통신이구나라는 느낌이 오시지 않았었나요?</p>
<p>그렇다면 반대로 동기식 방식의 통신을 하려면 어떻게?</p>
<p>고민할 필요도 없이 간단합니다. 생성된 클라이언트 객체가 제공하고 있는 <code>execute()</code> method를 <code>enqueue()</code> method 대신 이용하면 됩니다. <del>간단하죠?</del></p>
<p>하지만 제가 진행했던 프로젝트의 특성일 수도 있지만, 개인적인 경험상 <code>execute()</code> method를 몇번이나 쓸지는 의문이긴 합니다.</p>
<p>위의 예제 코드에서도 동기식 방식의 통신인 <code>execute()</code> method의 사용법을 소개하지 않았던 이유는,</p>
<p>제 개인적인 경험상 동기식 통신을 할 상황이 별로 없었다는 첫번째 이유와,</p>
<p>Android의 철학(?) 상,<br><strong>UI Thread</strong>가 일시적으로 멈추는 현상을 사용자에게 제공하는 것은 좋지 않은 사용자 경험을 제공하는 것이므로,<br><strong>시간이 오래 걸리는 작업의 경우 새로운 Thread</strong>를 생성하여 <strong>UI Thread가 멈추는 현상을 방지</strong>하여야 한다라는 것인데요.</p>
<p>네트워크 통신의 특징 상, 사용자의 네트워크 환경에 따라 시간이 얼마나 걸리는 작업인지 알 수 없습니다.</p>
<p>제가 생각했을 때, 네트워크 통신의 경우 <strong>시간이 오래 걸리는 작업</strong>이라는 판단과, 대부분의 App은 <strong>아마 비동기식 방식의 통신을 하고 있을 것이다!</strong>라는 개인적인 추측에 의해 굳이 언급하지 않았습니다.</p>
<p>그리고 Android의 네트워크 통신을 검색해 보시면, 많은 블로그에서 이 포스팅의 서두에서 언급했던 Android Framework의 내장 객체인 <code>AsyncTask</code>와 <code>HttpURLConnection</code>를 이용한 통신에 대한 정보가 수두룩하게 나올 정도로, 대다수의 개발자분들이 비동기식 방식의 통신을 하고 있다라는 판단도 있었구요!</p>
<p>하지만 정말 필요에 의해 동기식 방식의 통신이 이뤄질 수 있을 수도 있으므로, 단순히 method명이라도 소개해드리고자 해당 섹션을 추가하였습니다!</p>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>자주 포스팅을 작성하진 않는 편이지만. </p>
<p>역시, 글을 쓰다보면 언제나 <strong>조금만 더…</strong>, <strong>조금만 더 쉽게…</strong>라는 욕심이 생기나 봅니다.</p>
<p>단순히 Retrofit을 설정하고 간단하게 사용해보는 방법을 언급하려던 글이, </p>
<p>개인적으로 조금 더 좋은 포스팅을 전달해 드리고자 몇번이고 포스팅을 Review하다보니 굉장히 길어졌네요…ㅠㅠ</p>
<p>여튼! 이번 포스팅에서는 Retrofit을 설정하고, 간단한 기본 사용법과 처음 사용하시는 분들에게는 조금은 생소할 수 있는 키워드들에 대해 하나씩 코드를 살펴가며 정리를 해보았습니다.</p>
<p>이미 느끼셨겠지만,</p>
<p>Retrofit은 개발자가 처리하여야 할 필수적인 작업을 대신 처리하여 개발자의 생산성을 높여주고, HTTP 통신에 필요한 요소들을 Annotation으로 제공해주기에 </p>
<p>이를 잘 활용하면 서버 개발자가 미리 작성해둔 여러가지의 API를 굉장히 손쉽게 접근하고 구현할 수 있도록 해주는 편리한 도구 같지 않나요?</p>
<p>개인적인 견해이나, Retrofit이 이렇게 <strong>핫</strong>해질 수 있었던 이유는 불필요한 코드를 제거할 수 있도록 하여 개발자의 생산성을 높여주는 이점도 있지만,</p>
<p>Annotation을 이용하여 통신에 필요한 코드를 간결하게 작성할 수 있도록 제공하여, 코드를 처음보는 개발자도 코드를 쉽게 이해하도록 하고, </p>
<p>단순히 Interface의 선언부만 보는 것 만으로도 해당 코드가 어떤 통신의 역할을 하는지 알 수 있도록 해주는 것이 한 몫하지 않았나? 라는 생각이 듭니다.</p>
<p>아무래도, 글을 작성하다보니 개인적인 의견이 많이 들어가게 되었고, 제가 사용하는 용어들이 다른 개발자분들에게는 조금 생소한 용어일지도 모르겠습니다.</p>
<p>혹여 포스팅을 읽으시다가 잘못된 용어와 설명을 발견하신다면 하단의 댓글에 질타와 조언을 부탁드립니다!</p>
<p>다음 포스팅에서는 Retrofit을 조금 더 편리하게 관리하고 사용할 수 있도록,  저도 모르게 은연중에 생성 했던 Class와 유사한 방법으로 작성된 <code>FutureStudio Blog</code>에서 소개하고 있는 <code>ServiceGenerator Class</code>를 작성해보는 포스팅으로 찾아뵙도록 하겠습니다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;개인 App을 만들거나 현업에서 App을 만들다보면, 단순한 화면이동 등의 기능으로는 사용자의 요구사항을 충당하기 힘이 듭니다.&lt;/p&gt;
&lt;p&gt;일반적인 App은 서버와 클라이언트가 네트워크 통신을 통해 데이터를 주고 받으며 실질적으로 화면에 정보를 표출하고, 입력된 정보를 저장하는 등의 여러가지 기능들이 구현되어 있습니다.&lt;/p&gt;
&lt;p&gt;App에서의 네트워킹 기능은 필수라고 해도 과언이 아닐 정도이죠.&lt;/p&gt;
&lt;p&gt;그리고 요즘은 일반적으로 서버와 클라이언트가 데이터를 주고 받는 과정에서, &lt;code&gt;REST API&lt;/code&gt;라는 방식을 이용하여 네트워크 통신을 하게 됩니다.&lt;/p&gt;
&lt;p&gt;Android Framework에 기본적으로 내장되어 있는 &lt;code&gt;AsyncTask&lt;/code&gt;와 &lt;code&gt;HttpURLConnection&lt;/code&gt; 객체를 이용하면,&lt;br&gt;충분히 네트워크 통신에 대한 기능을 구현할 수 있지만,&lt;br&gt;직접 네트워크 통신을 구현하면 필수적으로 처리해주어야 할 몇가지의 작업으로 인해 여간 귀찮은 것이 아닙니다.&lt;/p&gt;
&lt;p&gt;예를들어, 네트워크 연결 / 해제 / 데이터 파싱 / 파싱된 데이터를 데이터 클래스에 저장 / 에러처리 등이 있겠네요.&lt;/p&gt;
&lt;p&gt;하지만, 이렇게 귀찮은 작업을 굉장히 편리하게 해주는 도구가 있습니다.&lt;/p&gt;
&lt;p&gt;이번 포스팅에서는,&lt;br&gt;그 중에서도, REST API 통신에 특화되어 있는 &lt;code&gt;Retrofit&lt;/code&gt;이라는 App 개발 시 필수적인 Library라고 해도 과언이 아닌 녀석의 기본 사용법에 대해 정리를 해볼까 합니다.&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://dev-juyoung.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://dev-juyoung.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android With Kotlin</title>
    <link href="https://dev-juyoung.github.io/2017/09/08/start-kotlin-with-android/"/>
    <id>https://dev-juyoung.github.io/2017/09/08/start-kotlin-with-android/</id>
    <published>2017-09-08T07:57:25.000Z</published>
    <updated>2017-09-08T15:59:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>Google I/O 2017에서 <code>Kotlin</code>을 안드로이드 개발언어로 지원한다는 발표 이후, 날이 갈수록 Kotlin의 인기가 높아지는 것 같습니다.<br>실제로 현업에서도 Kotlin을 도입하기 시작하는 사례도 많이 볼 수 있고, 개발자 커뮤니티에서 Kotlin으로 개발하던 중 생기는 이슈에 대한 질문과 답이 날이 갈수록 늘어가고 있습니다.<br>또한, 안드로이드와 관련된 컨퍼런스등에서 발표 후 공유되는 자료들만 보아도, Kotlin을 기준으로 진행되는 사례도 많아지고 있고,<br>여러 스타트업에서 채용공고의 우대사항으로 <code>Kotlin 사용 경험 우대</code>라는 채용공고도 많아지고 있습니다.</p>
<p>당장 현업에서 모든 회사가 Java로 되어 있던 부분을 Kotlin으로 대체하지는 못하겠지만,<br>기존에 Objective-C로만 개발을 할 수 있었던 IOS의 어플리케이션도 지금은 Swift라는 언어를 이용하여 개발하는 사례가 많이 늘고 있듯이,<br>머지 않아 안드로이드도 Java의 대안 언어이자 또 다른 공식 언어인 Kotlin을 이용한 개발이 활발해지지 않을까 하는 생각도 듭니다.</p>
<p>아직까지 저희 개발팀에서는 기존의 Java언어를 이용하여 개발 및 유지보수를 진행하고 있지만,<br>필요에 따라 컨버팅하는 일이 발생하게 되거나, 혹은 제 개인적인 커리어 관리를 위해 요즘들어 저도 Kotlin 언어를 틈틈히 공부하고 있습니다.</p>
<p>이번 포스팅에서는 간단하게 새로운 Android Project를 생성하고, Kotlin으로 코드를 변환한 후,<br>기존의 Java와 Kotlin 코드를 비교해보는 글을 작성해볼까 합니다.<br><a id="more"></a></p>
<p>이미 많은 블로그들에서 Kotlin 언어에 대한 기본적인 언어의 소개와 장/단점들이 소개되고 있기에,<br>언어에 대한 설명과 장/단점은 언급하지 않고 바로 Android Studio에서 Kotlin을 시작하는 방법에 대해 작성해보려고 합니다.</p>
<h2 id="Kotlin-Plugin-설치"><a href="#Kotlin-Plugin-설치" class="headerlink" title="Kotlin Plugin 설치"></a>Kotlin Plugin 설치</h2><p>Android Studio 3.0부터는 IDE수준에서 Kotlin을 공식으로 지원하기로 발표되었기 떄문에,<br>해당부분은 Android Studio 2.x 버전을 사용 중이신 분들을 위해 작성 하였습니다.</p>
<p>Kotlin을 시작하기 위해선 우선 Kotlin Plugin 설치가 필요합니다.<br>Android Studio의 메뉴 중 <code>Preferences &gt; Plugins</code>로 이동 한 후, <code>kotlin</code>을 검색하여 설치하기만 하면 끝입니다.<br>저는 이미 설치가 되어 있기에 <code>Uninstall</code>으로 표시되어 있으나, 설치가 필요하신 분은 녹색버튼의 <code>Install</code>이 표출됩니다.<br><img src="/images/start-kotlin-with-android/install-plugin.png" alt="Plugin Install"></p>
<h2 id="프로젝트에-Kotlin-설정"><a href="#프로젝트에-Kotlin-설정" class="headerlink" title="프로젝트에 Kotlin 설정"></a>프로젝트에 Kotlin 설정</h2><p>Plugin을 정상적으로 설치 한 후에는 <code>Tools &gt; Kotlin</code> 메뉴가 생성 됩니다.<br>해당 메뉴로 접근해보시면, <code>Configure Kotlin in Project</code>가 있습니다.<br>해당 메뉴를 선택하여 현재의 프로젝트에 Kotlin을 개발 할 수 있는 환경을 설정할 수 있습니다.<br><img src="/images/start-kotlin-with-android/configure-kotlin.png" alt="Configure Kotlin"></p>
<p>해당 메뉴를 클릭하면 다음과 같은 팝업창이 생성됩니다.<br><img src="/images/start-kotlin-with-android/selection-version.png" alt="Selection Kotlin Version"><br>현재 프로젝트에서 사용될 Kotlin의 버전을 선택 한 후, <code>Ok</code>버튼을 눌러주면 Gradle에 몇줄의 코드가 추가되며,<br>Gradle의 Sync를 맞춰주면 프로젝트에서 Kotlin을 이용한 Android의 개발 준비가 완료됩니다.</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Project Level Gradle</span></div><div class="line"><span class="keyword">buildscript</span> &#123;</div><div class="line">    ext.kotlin_version = <span class="string">'1.1.4-3'</span></div><div class="line">    </div><div class="line">    <span class="comment">// code...</span></div><div class="line"></div><div class="line">    <span class="keyword">dependencies</span> &#123;</div><div class="line">        <span class="comment">// code...</span></div><div class="line">        <span class="keyword">classpath</span> <span class="string">"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// App Level Gradle</span></div><div class="line">apply plugin: <span class="string">'com.android.application'</span></div><div class="line">apply plugin: <span class="string">'kotlin-android'</span></div><div class="line"></div><div class="line">android &#123;</div><div class="line">    <span class="comment">// code...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">dependencies</span> &#123;</div><div class="line">    <span class="comment">// code...</span></div><div class="line">    <span class="keyword">compile</span> <span class="string">"org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Project Level의 build.gradle에서는 Kotlin의 버전을 명시해주는 코드와 classpath를 추가하는 코드가 생성되며,<br>App Level의 build.gradle에서는 Kotlin과 관련된 plugin과 dependency 관련 코드가 추가 됩니다.</p>
<h2 id="MainActivity-Java-gt-Kotlin-Convert"><a href="#MainActivity-Java-gt-Kotlin-Convert" class="headerlink" title="MainActivity Java -&gt; Kotlin Convert"></a>MainActivity Java -&gt; Kotlin Convert</h2><p>Class 또는 Activity를 새롭게 작성해 볼 수 있지만, 빠르게 훓어보기 위해서 프로젝트 생성 시 만들어진 MainActivity Class를 Kotlin으로 컨버팅해보았습니다.<br>IDE를 이용한 컨버팅을 위해서 Android Studio의 메뉴 중 <code>Code &gt; Convert Java file to Kotlin file</code> 메뉴를 사용하면 됩니다.<br>듣기로는 IDE 수준에서 생각보다 수준 높은 컨버팅을 지원하는 기능이라고는 하지만, 실제로 Kotlin에 숙련도가 생기면 자동으로 컨버팅 되는 코드가 마음에 들지 않는다는 이야기도 있습니다.<br>하지만, 저희는 Kotlin의 문법을 우선은 구경해보는 것이 목적이기에 자동으로 컨버팅되는 것으로도 충분 할 것 같습니다.<br><img src="/images/start-kotlin-with-android/convert-code.png" alt="Convert Code"></p>
<h2 id="Kotlin-훑어보기"><a href="#Kotlin-훑어보기" class="headerlink" title="Kotlin 훑어보기"></a>Kotlin 훑어보기</h2><p>성공적으로 변경이 완료된 후에는 개개인에 따라 조금은 낯선 코드들로 변경되었을 것 같습니다.<br>그럼 지금부터, 기존에 작성된 Java코드와 Kotlin코드가 어떻게 다른지 훓어보도록 하죠!</p>
<p>처음으로는 Class의 선언부 부터 한번 살펴보도록 하겠습니다.<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Java Code</div><div class="line">public class MainActivity extends AppCompatActivity &#123;&#125;</div><div class="line"></div><div class="line">// Kotlin Code</div><div class="line">class MainActivity : AppCompatActivity() &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>크게 달라진 부분은 없지만, <code>AppCompatActivity</code>를 <code>상속</code>하는 코드가 달라졌습니다.<br>기존의 Java에서는 Class를 상속받기 위해 <code>extends</code> 키워드를 사용하였던것 과는 달리<br>Kotlin에서는 <code>: (콜론)</code>을 이용하여 상속을 받는 것을 볼 수 있습니다.<br><del>언뜻보아 Swift에서 Class를 상속받는 문법과 비슷해 보입니다.</del></p>
<p>그리고 미세한 차이이지만 Java에서 있던 접근제한자인 <code>public</code> 키워드도 Kotlin에서는 사라진 것을 볼 수 있습니다.<br>Kotlin에서는 명시적으로 <code>open</code>하지 않은 Class는 기본적으로 <code>final</code>이라고 합니다.</p>
<p>다음으로는 Activity가 시작되면 제일 먼저 실행되는 메서드인 <code>onCreate()</code>를 살펴보겠습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java Code</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_main);</div><div class="line">    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);</div><div class="line">    setSupportActionBar(toolbar);</div><div class="line"></div><div class="line">    FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);</div><div class="line">    fab.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">            Snackbar.make(view, <span class="string">"Replace with your own action"</span>, Snackbar.LENGTH_LONG)</div><div class="line">                    .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Kotlin Code</span></div><div class="line"><span class="function">override fun <span class="title">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</div><div class="line">    setContentView(R.layout.activity_main)</div><div class="line">    val toolbar = findViewById(R.id.toolbar) <span class="function">as Toolbar</span></div><div class="line">    <span class="title">setSupportActionBar</span><span class="params">(toolbar)</span></div><div class="line"></div><div class="line">    val fab = findViewById(R.id.fab) as FloatingActionButton</div><div class="line">    fab.setOnClickListener &#123; view -&gt;</div><div class="line">        Snackbar.make(view, <span class="string">"Replace with your own action"</span>, Snackbar.LENGTH_LONG)</div><div class="line">                .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>첫번째 차이점</strong>, <code>method 선언부</code>입니다.<br>Java에서는 오버라이드된 메서드에 대하여 <code>@Override</code> 어너테이션을 이용하여 해당 메서드가 오버라이드 되었음을 명시하고 있지만,<br>Kotlin에서는 method의 선언부 앞에 <code>override</code> 키워드를 붙여 해당 메서드가 오버라이드 되었음을 명시하고 있습니다.</p>
<p>Kotlin문서를 조금이라도 보셨다면 아시겠지만, 보시지 않은 분들은 조금은 낯선 메서드 선언법 같지 않나요?<br>Kotlin에서는 다음과 같이 method를 선언합니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">fun <span class="title">methodName</span><span class="params">(parameter: Type)</span> : retun Type </span>&#123;</div><div class="line">    <span class="comment">// your code</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Kotlin에서는 <code>fun</code> 키워드를 이용하여 메서드를 선언하고, 메서드의 명칭, 매개변수의 명칭과 타입, 그리고 마지막으로 <code>:</code>과 함께 해당 메서드 실행에 따른 반환되는 데이터의 타입을 명시하여 메서드를 선언할 수 있습니다.</p>
<p>하지만 위의 <code>onCreate()</code>메서드에서는 <strong>리턴 타입이 없지 않느냐?</strong> 라는 의문점을 가질 수 있을 것 같은데요,<br>Java에서 <code>void</code> 키워드는 리턴되는 값이 없음을 나타내듯 Kotlin에서는 <code>Unit</code> 키워드를 명시해주면 해당 메서드는 반환값이 없음을 나타낼 수 있습니다.<br><code>Unit</code> 키워드는 생략할 수 있으므로 <code>onCreate()</code>메서드에서는 생략되었습니다.</p>
<p><strong>두번째 차이점</strong>, 메서드의 <code>매개변수</code>입니다.<br>Java에서 메서드로 들어오는 매개변수들은 <code>Type parameter</code>의 형태로 데이터 타입을 먼저 명시하고 변수명을 명시하였다면,<br>Kotlin에서는 Java와는 반대로 <code>parameter: Type</code>의 형태로 변수명을 먼저 명시하고 <code>:</code> 이후에 해당 매개변수의 데이터 타입을 명시되어 있습니다.</p>
<p>그리고, 여기서 조금 더 자세히 들여다보면 Kotlin에서의 Bundle객체 타입에 대하여 <code>?</code>라는 키워드가 하나 더 붙어 있습니다.<br>기본적으로 Kotlin은 <strong>null을 허용하지 않도록 설계되었고</strong>, null을 사용하게 되더라도 안전하게 사용할 수 있도록 설계 되었다고 합니다.<br>때문에, Kotlin에서 null이 될 수 있는 부분에 대해서는 개발자가 이를 미리 인지하고 <code>?</code> 키워드를 데이터 타입과 함께 선언하여 <strong>null이 될 수 있음</strong>을 미리 선언해두어야 합니다.</p>
<p>그렇기에, 안드로이드 개발자라면 기본적으로 모두 알고 있듯, <code>onCreate()</code>메서드로 들어오는 Bundle객체인 <code>savedInstanceState</code>는 null이 될 수 있기에 null을 허용할 수 있도록 <code>Bundle?</code>과 같은 형식으로 선언되었다는 것을 알 수 있습니다.</p>
<p><strong>세번째 차이점</strong>, <code>변수의 선언 및 타입캐스팅</code>입니다.<br>xml에 선언된 View를 찾아오는 코드를 보면 문법의 차이가 확연히 나타나는 것을 볼 수 있습니다.<br>우선 Java에서는 볼 수 없었던 <code>val</code>이라는 키워드 입니다.<br>Kotlin에서의 변수 선언은 <code>val(or var) name: Type = literal</code>과 같은 문법으로 선언하게 됩니다.<br>Kotlin에서는 데이터의 변동유무에 따라, <code>val</code> 또는 <code>var</code>과 같은 키워드를 이용하여 변수를 선언하게 되는데,<br><code>val</code>은 <strong>value</strong>의 약어로 <code>immutable(불변의)</code> 데이터를 저장하기 위한 변수에 사용되며,<br><code>var</code>은 <strong>variable</strong>의 약어로 <code>mutable(변하기 쉬운)</code> 데이터를 저장하기 위한 변수에 사용됩니다.</p>
<p>한가지 더 차이점을 찾아보면, 타입 캐스팅을 위한 코드의 부분입니다.<br>Java에서는 타입캐스팅을 위해 괄호와 함께 타입을 명시하여 <code>Type name = (Type) xxxx</code>의 형태로 사용되었지만,<br>Kotlin에서는 <code>as</code> 키워드를 이용하여 <code>val name = xxx as Type</code>의 형태로 타입캐스팅을 할 수 있습니다.</p>
<p><strong>네번째 차이점</strong>, <code>Lambda식의 지원</code>입니다.<br>드디어 <code>onCreate()</code>메서드 부분의 끝이 왔네요! <code>setOnClickListener</code>부분이 보이시나요?<br>Java에서도 RetroLambda와 같은 라이브러리를 이용하면 Lambda식을 사용할 수 있었지만, Kotlin은 외부의 라이브러리 도움없이 기본적으로 Lambda식을 지원합니다.</p>
<p>안드로이드 개발자 포지션으로 전향한지 몇년되진 않았지만, 안드로이드 개발을 하다보면 Lambda식 지원의 부재가 아쉬울 때가 가끔 있었습니다.<br>안드로이드 프레임워크에서 강제(?)하는 보일러 플레이트로 인해 click listner등을 이용하다 보면 반복적인 불필요한 코드가 많이 발생합니다.<br>그럴때마다 가끔은 <code>Lambda식을 사용할 수 있었다면 불필요한 코드가 많이 줄었을 것 같은데...</code>라는 아쉬움이 많았지만, 위에서 언급한 RetroLambda와 같은 추가적인 외부 라이브러리를 포함하기는 꺼려했었기에 아쉬운대로 안드로이드 프레임워크에서 제공하는 기본틀 그대로 개발을 해왔었습니다. <del>아마 저와 비슷한 분들이 많을 것 같은…</del><br>하지만, Kotlin에서는 Lambda식을 기본적으로 지원하고 있으니, 저와 같은 성향을 가진 개발자분들에게는 희소식일 것 같습니다.<br>언제가 될지 모르겠지만, Kotlin을 도입하여 본격적으로 개발하는 날이 오게 되면 Lambda식을 이용하여 불필요한 코드의 제거, 가독성의 향상 등 많은 이점들을 경험할 수 있을 것 같다는 기대가 됩니다.</p>
<p>여기까지 <code>Class의 선언</code>부터 <code>onCreate()</code>메서드까지의 코드를 한번 살펴보았습니다.<br>그 외의 메서드인 <code>onCreateOptionMenu</code>나 <code>onOptionsItemSelected</code>에 관련된 코드도 더 있지만,<br>이미 <code>onCreate()</code>메서드에서 Java와 Kotlin을 비교하며 적어내려간 설명을 이해하셨다면,<br>언급되지 않은 남은 코드들은 이미 스스로 분석이 가능할 것이라고 믿어 의심치 않습니다.<br>나머지 부분에 대해서는 독자분들에게 숙제로 남겨두고 싶네요!</p>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>단순히 Android에서 Kotlin을 사용하는 방법에 대해서 짧게 써내려가고 싶었는데,<br>사람의 욕심은 끝이 없듯 쓰다보니 조금이라도 더 설명해 드리고 싶어 긴 글이 되었습니다 :(</p>
<p>저 또한, 아직 본격적으로 Kotlin을 적용해보지 않았고, 이제 막 시작하는 <strong>Kotlin Beginner</strong>이기에 잘못 설명된 부분도 없지 않아 있을 것 같습니다.<br>하지만 <strong>나누면 좋다</strong>라는 말이 있듯이 부족한 실력에도 혹시 Android에서 Kotlin을 시작하고 싶어하시는 분들을 위해 포스팅을 남겨보았습니다.</p>
<p>앞으로 틈틈히 못다한 Kotlin 문법에 대한 스터디와 병행하며 개인적인 Android 프로젝트에 Kotlin을 적용해보고,<br>Kotlin을 이용한 Android 개발이 Java로 개발할 때와 어떤 다른점과 이점이 있기에 여러 스타트업에서 Kotlin 경험자를 선호하기 시작하였는지 알아 볼 계획입니다.</p>
<p>이미 많은 Kotlin 능숙자분들이 계시고 블로그에 좋은글을 공유해주시는 분들이 계시기에 Kotlin과 관련된 글을 많이 써내려가진 않을 것 같지만,<br>경험을 통해 얻을 수 있었던 이점이나 소소한 Tip이 생기면 블로그를 통해 공유해보도록 하겠습니다!</p>
<p>여하튼, Kotlin을 본격적으로 적용해보진 않았지만,<br>단순히 플러그인을 설치하고, IDE의 도움을 받아 코드를 Kotlin으로 컨버팅 해보는 것만으로도 Kotlin의 몇가지 매력을 볼 수 있었던 것 같습니다.<br>앞으로도 Kotlin의 많은 매력을 느낄 수 있길 기대해보며 포스팅을 마무리하겠습니다.<br><strong>Kotlin Beginner 파이팅!</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Google I/O 2017에서 &lt;code&gt;Kotlin&lt;/code&gt;을 안드로이드 개발언어로 지원한다는 발표 이후, 날이 갈수록 Kotlin의 인기가 높아지는 것 같습니다.&lt;br&gt;실제로 현업에서도 Kotlin을 도입하기 시작하는 사례도 많이 볼 수 있고, 개발자 커뮤니티에서 Kotlin으로 개발하던 중 생기는 이슈에 대한 질문과 답이 날이 갈수록 늘어가고 있습니다.&lt;br&gt;또한, 안드로이드와 관련된 컨퍼런스등에서 발표 후 공유되는 자료들만 보아도, Kotlin을 기준으로 진행되는 사례도 많아지고 있고,&lt;br&gt;여러 스타트업에서 채용공고의 우대사항으로 &lt;code&gt;Kotlin 사용 경험 우대&lt;/code&gt;라는 채용공고도 많아지고 있습니다.&lt;/p&gt;
&lt;p&gt;당장 현업에서 모든 회사가 Java로 되어 있던 부분을 Kotlin으로 대체하지는 못하겠지만,&lt;br&gt;기존에 Objective-C로만 개발을 할 수 있었던 IOS의 어플리케이션도 지금은 Swift라는 언어를 이용하여 개발하는 사례가 많이 늘고 있듯이,&lt;br&gt;머지 않아 안드로이드도 Java의 대안 언어이자 또 다른 공식 언어인 Kotlin을 이용한 개발이 활발해지지 않을까 하는 생각도 듭니다.&lt;/p&gt;
&lt;p&gt;아직까지 저희 개발팀에서는 기존의 Java언어를 이용하여 개발 및 유지보수를 진행하고 있지만,&lt;br&gt;필요에 따라 컨버팅하는 일이 발생하게 되거나, 혹은 제 개인적인 커리어 관리를 위해 요즘들어 저도 Kotlin 언어를 틈틈히 공부하고 있습니다.&lt;/p&gt;
&lt;p&gt;이번 포스팅에서는 간단하게 새로운 Android Project를 생성하고, Kotlin으로 코드를 변환한 후,&lt;br&gt;기존의 Java와 Kotlin 코드를 비교해보는 글을 작성해볼까 합니다.&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://dev-juyoung.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://dev-juyoung.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Socket.io 라이브러리를 사용해보자.</title>
    <link href="https://dev-juyoung.github.io/2017/09/05/android-socket-io/"/>
    <id>https://dev-juyoung.github.io/2017/09/05/android-socket-io/</id>
    <published>2017-09-05T05:29:44.000Z</published>
    <updated>2017-09-05T08:33:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>요즘 많은 어플리케이션을 사용하다보면, 사용자간의 소통을 위한 기능으로 <code>채팅기능</code>을 제공하고 있습니다.<br>실제로 현업에서 개발을 진행하다보면 채팅은 <code>필수기능</code>으로 꼽힐 정도로 사용자의 니즈가 많은 것 같습니다.</p>
<p>최근들어 제가 속해 있는 스타트업에서는, 채팅기능에 대한 사용자의 피드백과 필요성을 많이 느끼고 있음을 알고,<br>개발팀에서는 실제 본격적인 개발에 들어가기에 앞서, 채팅기능에 대한 검토와 프로토타이핑을 진행하고 있습니다.</p>
<p>요즘은 기술이 많이 발전하여 채팅을 구현한다고하면 socket통신 / mqtt / xmpp 등 많은 기술스택을 생각할 수 있지만,<br>저희는 현재 node.js를 이용하여 back-end를 개발해왔으며, npm의 module중 socket통신과 관련된 유명한 module인 <code>socket.io</code>를 이용해서 채팅을 구현해보기로 했습니다.<br>socket.io팀(?)에서는 다행히도 안드로이드에서 쉽게 socket.io를 사용할 수 있도록 라이브러리도 만들어두었습니다.<br><a id="more"></a></p>
<p>우선 본격적인 글을 시작하기에 앞서, <code>글 읽기 귀찮고 난 코드만 알려줘!</code>라고 하시는분들을 위해 참고 URL부터 언급하고 시작하겠습니다.</p>
<h2 id="참고-URL"><a href="#참고-URL" class="headerlink" title="참고 URL"></a>참고 URL</h2><ul>
<li><a href="https://github.com/socketio/socket.io-client-java" target="_blank" rel="external">공식 Android Socket.io Github</a><ul>
<li>Android용 Socket.io 공식 Github.</li>
</ul>
</li>
<li><a href="https://socket.io/blog/native-socket-io-and-android" target="_blank" rel="external">공식 Android Socket.io Blog</a><ul>
<li>Android용 Socket.io 공식 Blog.</li>
</ul>
</li>
<li><a href="https://github.com/dev-juyoung/cro-node-socket-example" target="_blank" rel="external">Socket.io Example - Server Github</a><ul>
<li>express + socket.io를 이용한 서버 프로젝트 샘플코드.</li>
</ul>
</li>
<li><a href="https://github.com/dev-juyoung/cro-android-socket-example" target="_blank" rel="external">Socket.io Example - Android Github</a><ul>
<li>Android + socket.io를 이용한 안드로이드 프로젝트 샘플코드.</li>
</ul>
</li>
<li><a href="https://cro-socket-example.herokuapp.com" target="_blank" rel="external">Socket.io Demo Site</a><ul>
<li>heroku url (demo)</li>
<li>웹에서 2개의 Tab을 열어 실제로 어떻게 동작되는지 확인할 수 있습니다.</li>
</ul>
</li>
</ul>
<h2 id="의존성-추가"><a href="#의존성-추가" class="headerlink" title="의존성 추가"></a>의존성 추가</h2><p>Android에서 라이브러리를 사용하기 위해, 제일 먼저 하는 작업은 역시나, gradle에 의존성을 추가해주는 일입니다.<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">compile</span> (<span class="string">'io.socket:socket.io-client:1.0.0'</span>) &#123;</div><div class="line">  <span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'org.json'</span>, module: <span class="string">'json'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>의존성을 추가할 때, <code>exclude group: &#39;org.json&#39;, module: &#39;json&#39;</code>를 해주지 않아도 사용에 문제는 없지만,<br>Android Studio의 로그창에 옛날 버전의 json 패키지를 제외처리했다는 warning 메시지를 볼 수 있으니, 추가하는 것이 좋습니다.</p>
<h2 id="Socket-연결"><a href="#Socket-연결" class="headerlink" title="Socket 연결"></a>Socket 연결</h2><p>Socket 통신을 사용할 Activity에서 다음과 같은 코드를 추가합니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Socket mSocket;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">  <span class="comment">// 설명의 편의를 위해 onCreate()메서드에 추가하였으나,</span></div><div class="line">  <span class="comment">// 꼭 onCreate() 메서드에 위치할 필요는 없을 것 같습니다.</span></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    mSocket = IO.socket(<span class="string">"SERVER URL"</span>);</div><div class="line">    mSocket.connect();</div><div class="line">  &#125; <span class="keyword">catch</span>(URISyntaxException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>연결을 위한 코드는 단 2줄이면 가능합니다.<br><code>IO.socket(&quot;SERVER URL&quot;)</code>를 이용하면 <code>Socket</code>객체를 얻을 수 있습니다.<br>이렇게 얻은 Socket객체를 통해 이벤트를 서버로 전송하거나 또는 서버로부터 이벤트를 전송받기 위해 계속적으로 들고 있어야하므로,<br>해당 Activity Class 상단에서 <code>mSocket</code> 변수를 선언하고, 해당 변수에 Socket객체를 저장해두시면 됩니다.</p>
<h2 id="Event-전달-처리"><a href="#Event-전달-처리" class="headerlink" title="Event 전달 처리"></a>Event 전달 처리</h2><p>Socket서버에 성공적으로 연결이 되면, 우리는 앞에서 얻은 Socket객체를 통해 이벤트를 서버로 전송하고,<br>서버로부터 전달받은 이벤트를 이용하여 여러가지 처리를 할 수 있습니다.</p>
<p>복잡하게 느껴질 수 있겠지만, 단 2가지만 기억하시면 됩니다.</p>
<ol>
<li>Socket.on(String event, Listener listener)<ul>
<li>첫번째 인자로 <code>서버로부터 전달을 기다리는 이벤트명</code>을 지정하고, </li>
<li>두번째 인자로 해당 이벤트를 전달받은 후, <code>해당 Listener를 통해 Android에서 제어</code>를 하면 됩니다.</li>
</ul>
</li>
<li>Socket.emit(String event, Object args)<ul>
<li>첫번째 인자로 <code>서버로 전송할 이벤트명</code>을 지정하고,</li>
<li>두번째 인자로 추가적으로 전송할 데이터를 지정합니다. 대부분의 서버 - 클라이언트 통신은 <code>JSON</code>을 이용한 통신을 할 것이므로, JSONObject로 데이터를 생성한 후, 지정해주면 될 것 같습니다.</li>
</ul>
</li>
</ol>
<p>약간은 어렵게 느껴지실 수 있지만, 코드를 보면 바로 이해 될 듯 합니다.<br>우선은 서버로부터 전달받은 이벤트를 Android에서 처리하는 코드의 일부입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">  <span class="comment">// IO.socet()메서드와 mSocket.connect() 메서드사이에 일반적으로 작성하는 것 같습니다.</span></div><div class="line">  mSocket.on(Socket.EVENT_CONNECT, onConnect);</div><div class="line">  mSocket.on(<span class="string">"chat-message"</span>, onMessageReceived);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Socket서버에 connect 된 후, 서버로부터 전달받은 'Socket.EVENT_CONNECT' Event 처리.</span></div><div class="line"><span class="keyword">private</span> Emitter.Listener onConnect = <span class="keyword">new</span> Emitter.Listener() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Object... args)</span> </span>&#123;</div><div class="line">    <span class="comment">// your code...</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 서버로부터 전달받은 'chat-message' Event 처리.</span></div><div class="line"><span class="keyword">private</span> Emitter.Listener onMessageReceived = <span class="keyword">new</span> Emitter.Listener() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Object... args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 전달받은 데이터는 아래와 같이 추출할 수 있습니다.</span></div><div class="line">    JSONObject receivedData = (JSONObject) args[<span class="number">0</span>];</div><div class="line">    <span class="comment">// your code...</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>생각보다 간단하지 않나요?<br>Android에서 서버로 이벤트를 전달하는 부분은 더 간결합니다. 코드로 확인해보시죠.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 서버로 이벤트를 전송하는 부분에 적절히 추가하시면 될 것 같아요.</span></div><div class="line">JSONObject data = <span class="keyword">new</span> JSONObject();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  data.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</div><div class="line">  data.put(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</div><div class="line">  mSocket.emit(<span class="string">'event-name'</span>, data);</div><div class="line">&#125; <span class="keyword">catch</span>(JSONException e) &#123;</div><div class="line">  e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java에서 기본적으로 제공되는 JSONObject를 이용하여 데이터를 처리하기 위해서는 <code>JSONException</code>이 발생할 수 있으므로,<br>필수적으로 <code>try - catch</code>처리를 해주어야 합니다. 예외처리를 좋은 습관이라고 생각하지만,<br>이것마저 귀찮으시다면 JSONObject객체에서 제공하는 <code>optXXX()</code> 메서드를 이용하여 처리해 줄 수도 있습니다.</p>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>저도 실질적으로 프로토타이핑을 해보기 이전에는 Socket통신에 대해 막연한 생각이 있었습니다.<br>하지만 위에서 살펴보았듯, Socket.io 팀에서는 마치 안드로이드에서 사용할 것을 대비하여 Android용 Socket.io 라이브러리를 만들어주었고,<br>Socket 통신을 한번도 안해본 사람도 단 몇줄의 코드를 이용하여 Socket통신을 할 수 있도록 제공하고 있습니다.<br>생활코딩의 <code>이고잉</code>님의 몇몇 강좌에서 하시는 말씀인 <code>프로그래밍하기 좋은 시대에 살고있다.</code>라는 말을 요즘들어 더욱 체감하고 있는 것 같습니다.</p>
<p>위의 코드는 단순히 서버와 클라이언트간의 일회성 Socket통신을 하고 있지만,<br>적절한 이벤트 수/발신 타이밍에 DB나 Push 기능 등을 보강하면 그럴싸한 채팅프로그램을 만들 수 있을 것 같습니다.<br>기회가 된다면, DB나 Push 기능을 조금 더 보강한 그럴싸한 채팅프로그램으로 업데이트를 한 후, 공개하도록 하겠습니다!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;요즘 많은 어플리케이션을 사용하다보면, 사용자간의 소통을 위한 기능으로 &lt;code&gt;채팅기능&lt;/code&gt;을 제공하고 있습니다.&lt;br&gt;실제로 현업에서 개발을 진행하다보면 채팅은 &lt;code&gt;필수기능&lt;/code&gt;으로 꼽힐 정도로 사용자의 니즈가 많은 것 같습니다.&lt;/p&gt;
&lt;p&gt;최근들어 제가 속해 있는 스타트업에서는, 채팅기능에 대한 사용자의 피드백과 필요성을 많이 느끼고 있음을 알고,&lt;br&gt;개발팀에서는 실제 본격적인 개발에 들어가기에 앞서, 채팅기능에 대한 검토와 프로토타이핑을 진행하고 있습니다.&lt;/p&gt;
&lt;p&gt;요즘은 기술이 많이 발전하여 채팅을 구현한다고하면 socket통신 / mqtt / xmpp 등 많은 기술스택을 생각할 수 있지만,&lt;br&gt;저희는 현재 node.js를 이용하여 back-end를 개발해왔으며, npm의 module중 socket통신과 관련된 유명한 module인 &lt;code&gt;socket.io&lt;/code&gt;를 이용해서 채팅을 구현해보기로 했습니다.&lt;br&gt;socket.io팀(?)에서는 다행히도 안드로이드에서 쉽게 socket.io를 사용할 수 있도록 라이브러리도 만들어두었습니다.&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://dev-juyoung.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://dev-juyoung.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>EditText에 Number와 Dash만 허용하기</title>
    <link href="https://dev-juyoung.github.io/2017/06/15/android-edittext-inputtype-number-and-dash/"/>
    <id>https://dev-juyoung.github.io/2017/06/15/android-edittext-inputtype-number-and-dash/</id>
    <published>2017-06-15T06:48:56.000Z</published>
    <updated>2017-06-15T07:25:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>이번 포스팅에서는 안드로이드의 Application을 개발하다보면,<br>흔하게 사용되는 View중에서 <code>EditText</code>에 대한 내용을 정리해보고자 합니다.<br><code>EditText</code>에 대한 전반적인 설명은 하지 않을 것입니다. <del>여러분들은 이미 EditText쯤이야 알고 계시잖…</del><br>특별한 내용을 다루진 않고, 어찌보면 <code>EditText</code>를 다루는 팁(?)정도로 생각하시고 가볍게 읽어주세요!<br><a id="more"></a></p>
<h2 id="숫자와-대시만을-이용하는-상황이-필요했던-이유"><a href="#숫자와-대시만을-이용하는-상황이-필요했던-이유" class="headerlink" title="숫자와 대시만을 이용하는 상황이 필요했던 이유?"></a>숫자와 대시만을 이용하는 상황이 필요했던 이유?</h2><p>포스팅을 작성할 때마다 언급되었듯, 저는 현업으로 안드로이드의 어플리케이션을 개발하는 개발자입니다.<br>하지만 회사에서 업무로만 개발하는 것에서 그치지 않고,<br>개인적인 시간을 이용해서 현업에서 적용해보지 못한 기술을 스터디할 목적으로 개인 어플리케이션을 만들기도 합니다. <del>그만큼 개발을 좋아하…</del><br>요즘 틈틈히 개발하고 있는 어플리케이션이 있는데요. 개발을 하다보니 <code>Number(숫자)형식</code>과 <code>-(대시)형식</code>만 입력받아야 되는 상황이 있었어요.<br>그래서 구글링을 통해 저도 알게 된 지식이지만, 혹시라도 제 블로그를 보시는 분들을 위해 포스팅을 남기기로 했답니다?</p>
<h2 id="각설하고-코드만-줘"><a href="#각설하고-코드만-줘" class="headerlink" title="각설하고 코드만 줘!"></a>각설하고 코드만 줘!</h2><p>일반적인 EditText를 만드는 xml 코드입니다.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">EditText</span></span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/evNumberAndDash"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">    /&gt;</div></pre></td></tr></table></figure></p>
<p>모두가 알고 계셨겠지만, 혹시 모르셨다면 어떤가요? 굉장히 간단한 코드죠?<br>보통의 <code>EditText</code>를 만들때는 기본적으로 위와 같은 코드를 골격으로 시작한다고 생각하시면 됩니다.<br>그렇다면, 오늘의 주요 주제인 <code>inputType</code>을 이용해 <code>Number형식</code>과 <code>Dash형식</code>만 지원하는 속성을 추가해도보록하죠!<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">EditText</span></span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/evNumberAndDash"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:inputType</span>=<span class="string">"numberSigned"</span></div><div class="line">    <span class="attr">android:digits</span>=<span class="string">"0123456789-"</span></div><div class="line">    /&gt;</div></pre></td></tr></table></figure></p>
<p>추가된 코드라면 <code>inputType</code>과 <code>digits</code>을 추가한게 끝입니다. <del>네, 이게 끝이에요…</del></p>
<p>간략하게 설명을 드리자면 <code>inputType</code>중 <code>numberSigned</code>에 해당하는 속성을 지정하면,<br><code>0 ~ 1</code> 그리고, 부호를 입력할 수 있도록 <code>-</code>를 입력할 수 있습니다.<br>하지만, 제가 원하는 기능은 <code>-n</code>형식의 음수를 입력하는 것이 목적이 아니라, <code>1-1</code>과 같은 숫자와 숫자사이에 <code>-</code>를 넣는 것이었기 때문에, <code>digits</code> 속성을 이용하여 입력할 수 있는 범위를 지정해주었다고 보시면 될 것 같아요.</p>
<h2 id="그래서-어디에-쓸-수-있는데"><a href="#그래서-어디에-쓸-수-있는데" class="headerlink" title="그래서 어디에 쓸 수 있는데?"></a>그래서 어디에 쓸 수 있는데?</h2><p>이건 여러분의 몫으로 남겨두도록하겠습니다. 개인적인 생각에는 많은 영역에서 사용할 수 있을 것 같아요.<br>아주 간략한 예시를 하나 만들어보자면… <code>DatePicker</code>라는 훌륭한 Component를 사용하지 않고,<br>사용자로부터 키보드로 직접 <code>2017-06-15</code>와 같은 날짜형식을 입력받고자 한다는 기획명령이 떨어졌을때?정도 일까요…?</p>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>개발자라고하더라도 개발자입장에서 최대한 자신이 만든 어플리케이션을 사용해주는 고마운 사용자를 위해서라도,<br>개발자 나름대로의 고민과 최대한 쾌적한 환경을 제공해주기 위해 많은 노력을 해야된다고 생각합니다.<br>특히 모바일처럼 작은 디바이스에서 입력하기란 쉽지 않기에 <code>EditText</code>의 <code>inputType</code>을 적절히 사용하여 사용자가 무엇을 입력함에 있어 최대한 피로감을 덜 주는 것도 중요하다고 봐요.<br>혹시 기회가 된다면 수많은 <code>inputType</code>에 대해서 한번 정리를 해보는 포스팅을 작성해보도록하겠습니다!<br>이번 포스팅에서는 특별한 정보는 아니지만, 은근히 기본적이지만 적용해야 될 상황이 다가왔을때 기억이 안날수도 있는 부분을 정리해보았습니다! <strong>끝!</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;이번 포스팅에서는 안드로이드의 Application을 개발하다보면,&lt;br&gt;흔하게 사용되는 View중에서 &lt;code&gt;EditText&lt;/code&gt;에 대한 내용을 정리해보고자 합니다.&lt;br&gt;&lt;code&gt;EditText&lt;/code&gt;에 대한 전반적인 설명은 하지 않을 것입니다. &lt;del&gt;여러분들은 이미 EditText쯤이야 알고 계시잖…&lt;/del&gt;&lt;br&gt;특별한 내용을 다루진 않고, 어찌보면 &lt;code&gt;EditText&lt;/code&gt;를 다루는 팁(?)정도로 생각하시고 가볍게 읽어주세요!&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://dev-juyoung.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://dev-juyoung.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>CroPicker, 안드로이드 이미지피커 라이브러리</title>
    <link href="https://dev-juyoung.github.io/2017/06/05/android-library-cropicker/"/>
    <id>https://dev-juyoung.github.io/2017/06/05/android-library-cropicker/</id>
    <published>2017-06-05T03:46:56.000Z</published>
    <updated>2017-06-05T04:25:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>안드로이드를 실제 개발하다보면 이미지는 빠질 수 없는 요소인 것 같습니다.<br>심지어, 많은 여타의 어플레케이션을 보더라도 이미지 없이 단순한 텍스트로만 UI를 구성하는 어플리케이션은 보기 힘들지 않나요?</p>
<p>화면을 구성함에 있어 조금 더 생기있고, 화려해보이는 목적으로 사용되기도 하고,<br>혹은, 특정 상품을 팔기 위한 어플리케이션의 경우 상품에 대한 이미지는 필수 요소일 것으로 보입니다.<br>이러하듯, 이미지를 표출하기 위해서는 우리가 개발하는 어플리케이션에서 유저가 컨텐츠를 작성할 때 이미지를 등록 할 수 있는 무엇인가를 제공해주어야 합니다.</p>
<p>이번 포스팅에서는 제가 개발한 <code>CroPicker</code>라는 안드로이드용 이미지피커 라이브러리를 소개해드릴까 합니다.<br>라이브러리를 어떻게 작성하는지에 대해서는 기회가 된다면 다른 포스팅에서 제공할 수 있도록 포스팅 계획을 수립해 보겠습니다.<br>이번 포스팅에서는 머리아프게 하지 않고, <code>이러한 라이브러리도 있구나?</code>를 알려드리기 위해 라이브러리를 소개하는 짧은 글을 작성해볼까 합니다.<br><a id="more"></a></p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>코드가 궁금하시거나, 결과물부터 보시고자 한다면 <code>Github</code>를 확인해주세요!<br>많은 질타와 조언도 부탁드립니다! 또한, 응원의 마음으로 <code>Star</code>도 눌러주신다면 더욱더 좋습니다!</p>
<ul>
<li><a href="https://github.com/dev-juyoung/CroPicker" target="_blank" rel="external">https://github.com/dev-juyoung/CroPicker</a></li>
</ul>
<p><code>영알못</code>이라 번역의 도움을 통해 <code>README</code>를 작성했습니다.<br>원활한 리딩을 위해 <code>README</code>를 개선에 도움을 주시면 감사하겠습니다!!</p>
<h2 id="CroPicker-이미지피커-그게뭔데"><a href="#CroPicker-이미지피커-그게뭔데" class="headerlink" title="CroPicker?? 이미지피커?? 그게뭔데?"></a>CroPicker?? 이미지피커?? 그게뭔데?</h2><p>저도 그렇게 수준높은 개발자가 아니므로, 정확한 용어인지는 모르겠지만,<br>흔히 개발자들 사이에서는 <code>ImagePicker</code>라고 불리우는 녀석이 있는데요!<br>간단하게 설명드리면 단순히 <code>이미지를 선택할 수 있는 녀석</code>정도로 이해하시면 될 듯 합니다.<br>그렇다면, <code>CroPicker</code>라는 녀석도 같은 기능을 하는 녀석이구나! 라고 이해되시겠죠?<br><code>CroPicker</code>의 <code>Cro</code>는 가상공간상의 제 닉네임 입니다. <del>왜 Cro가 되셨는지 궁금하시다면 개인적인 연락을…</del></p>
<h2 id="CroPicker의-주요기능"><a href="#CroPicker의-주요기능" class="headerlink" title="CroPicker의 주요기능"></a>CroPicker의 주요기능</h2><p><strong>이미 개발자라면 모두가 알고 있는 <code>ImagePicker</code>의 기능과 특별히 다른점은 없습니다.</strong></p>
<ul>
<li>내장갤러리로 접근하여 앨범(Directory)의 정보를 가져오고 리스트로 표출합니다.</li>
<li>앨범(Directory) 선택 시, 해당 앨범에 속해있는 이미지들을 가져오고 리스트로 표출합니다.</li>
<li>이미지를 선택하여 원하는 이미지를 본인의 어플리케이션에 삽입할 수 있도록 지원합니다.</li>
</ul>
<h2 id="CroPicker를-개발하게-된-이유"><a href="#CroPicker를-개발하게-된-이유" class="headerlink" title="CroPicker를 개발하게 된 이유?"></a>CroPicker를 개발하게 된 이유?</h2><p>여기까지 보셨다면, 왜 별로 특별하지도 않은 라이브러리를 또 만들어내느냐 그냥 가져다쓰면되지? 하고 의문점을 남기실 수 있겠지만, 몇가지의 목적을 가지고 개발을 시작하였습니다.</p>
<p>첫번째, 수많이 배포된 여타의 라이브러리에서 내가 원하는 기능을 지원하는가? 였습니다.<br>하지만, 제가 원하는 기능을 충분히 포함한 라이브러리는 많았지만, 제가 원하는 모든 기능을 포함한 라이브러리를 찾기란 쉽지 않았습니다.<br>물론 여타의 수많은 라이브러리 중에 적당히 기능을 포함하고 있다면 Fork 받아 원하는 기능을 추가하고 수정하여 사용할 수 있겠지만,<br>어짜피 건들여야한다면? 이참에 나도 라이브러리라는거 한번 만들어보자! 라는 마인드의 시작이였습니다.<br><strong>몰랐던 내용이 있으면 공부도하고 라이브러리도 한번 배포해보고 일석이조 아닐까요?</strong></p>
<p>두번째, 저와같은 초급개발자도 라이브러리를 만들수 있을까? 라는 의문점이였습니다.<br>항상 남들이 만들어놓은 많은 라이브러리르 사용하면서 <code>우와... 나도 이런 실력을 가지고 있으면 얼마나 좋을까?</code>라는 부러움만 표출하고 있었는데요,<br>조금만 생각을 전환하니 <code>나라고 못만들게 뭐있어?</code>라는 생각이 들더라구요.</p>
<p>물론 실력이 좋으신 분이 보신다면 코드의 품질이 좋진 않을 수 있어, 조금은 부끄러움도 있었고 공개를 해야되나? 라는 고민도 많이 했었습니다.<br>하지만, 못하거나 모르는건 부끄러운게 아니라는 말이 있듯이, <strong>나같은 초보개발자도 이런거 할 수 있어!</strong> 라는 것을 다른 분들에게 보여드리고 싶었습니다.</p>
<p>세번째, 어찌보면 행운인지 불행인지 모르겠지만 저는 4년이라는 짧다면 짧고 길다면 긴 개발생활을 현업으로 하는 개발자 입니다.<br>하지만 한번도 그토록 많은 분들이 말하는 <strong>사수</strong>라는 분은 존재하지 않았고, 제가 작성하고 있는 코드가 제대로된 코드인지도 알지 못한채 시간이 흘러왔습니다.<br>그러던 중, 남들보다는 늦게 <code>Git</code>과 <code>Github</code>라는 녀석을 알게되었고, <code>Github</code>에 내가 짠 코드를 공개하면? 아무의견이 없을 수도 있는 슬픈 일이 발생 할 수 있지만,<br>혹시나 관심을 가져주는 분이 계시다면 그게 바로 나에게는 <strong>선배</strong>이자 <strong>네트워크 사수</strong>가 되지 않을까라는 생각이 들더라구요.<br>그래서, 이렇게 라이브러리를 공개 / 배포함으로써 잘못된 부분에 대한 질타를 받고 싶었습니다.<br>질타를 받아야 잘못된 코드인 것을 인지 할 수 있고, 개선해나갈 수 있으니까요!</p>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>어찌보면 푸념의 글이 될 수도 있을 것 같네요.<br>여튼 결론은! 초보개발자도 충분히 라이브러리를 만들 수 있고, 본인이 작성한 코드가 부끄러운 것이 아닌 한발짝 더 성장해나가는 과정으로 삼을수 있을 것 같다! 입니다.<br>초보개발자에게는 앞으로 더 배우고 성장할 일이 훨씬 많으니 본인의 실력에 좌절하지 말고, 자신감을 가지고 저처럼 라이브러리를 개발하거나 코드를 오픈하여 한발짝 더 성장하는 개발자가 됩시다!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;안드로이드를 실제 개발하다보면 이미지는 빠질 수 없는 요소인 것 같습니다.&lt;br&gt;심지어, 많은 여타의 어플레케이션을 보더라도 이미지 없이 단순한 텍스트로만 UI를 구성하는 어플리케이션은 보기 힘들지 않나요?&lt;/p&gt;
&lt;p&gt;화면을 구성함에 있어 조금 더 생기있고, 화려해보이는 목적으로 사용되기도 하고,&lt;br&gt;혹은, 특정 상품을 팔기 위한 어플리케이션의 경우 상품에 대한 이미지는 필수 요소일 것으로 보입니다.&lt;br&gt;이러하듯, 이미지를 표출하기 위해서는 우리가 개발하는 어플리케이션에서 유저가 컨텐츠를 작성할 때 이미지를 등록 할 수 있는 무엇인가를 제공해주어야 합니다.&lt;/p&gt;
&lt;p&gt;이번 포스팅에서는 제가 개발한 &lt;code&gt;CroPicker&lt;/code&gt;라는 안드로이드용 이미지피커 라이브러리를 소개해드릴까 합니다.&lt;br&gt;라이브러리를 어떻게 작성하는지에 대해서는 기회가 된다면 다른 포스팅에서 제공할 수 있도록 포스팅 계획을 수립해 보겠습니다.&lt;br&gt;이번 포스팅에서는 머리아프게 하지 않고, &lt;code&gt;이러한 라이브러리도 있구나?&lt;/code&gt;를 알려드리기 위해 라이브러리를 소개하는 짧은 글을 작성해볼까 합니다.&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://dev-juyoung.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://dev-juyoung.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Activity 전환하기</title>
    <link href="https://dev-juyoung.github.io/2017/05/11/android-activity-switch/"/>
    <id>https://dev-juyoung.github.io/2017/05/11/android-activity-switch/</id>
    <published>2017-05-11T02:48:53.000Z</published>
    <updated>2017-05-11T09:55:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>저번 포스팅에서 <code>Intent 객체</code>에 대해서 알아보았습니다.<br><code>Intent 객체</code>에 대하여 기억이 나지 않는다면, <a href="https://dev-juyoung.github.io/2017/05/01/android-intent">해당 포스팅</a>을 확인해보세요.</p>
<h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity??"></a>Activity??</h2><p>Activity전환에 대한 이야기를 시작하기에 앞서,<br>안드로이드를 처음 접하시는 분이라면 <code>Activity</code>가 무엇인지 잘 모를 수도 있습니다. 당연하거지요.<br>그렇다면 <code>Activity</code>란 무엇일까요??<br>간단히 말해서, <code>Activity</code>란 하나의 화면을 구성하고 있는 안드로이드 시스템에서의 <code>화면의 단위</code>정도로 생각하시면 됩니다.<br>웹에 대해 지식이 있는 분이라면 여러개의 <code>html</code>파일이 모여 하나의 웹사이트를 이루듯,<br>안드로이드는 여러개의 <code>Activity</code>가 모여 하나의 어플리케이션을 이루는 것이죠.</p>
<p>물론, 실질적으로 안드로이드 어플리케이션을 개발하다보면, <code>Activity</code>뿐만 아니라,<br><code>Fragment</code>라는 녀석도 필요한 경우가 존재하는데, 이 녀석은 오늘의 주제가 아니니 건너가죠!<br><a id="more"></a></p>
<h2 id="단순하게-화면만-전환하기"><a href="#단순하게-화면만-전환하기" class="headerlink" title="단순하게 화면만 전환하기"></a>단순하게 화면만 전환하기</h2><p><code>Intent 객체</code>에 대한 포스팅을 읽어보신 분이라면, 이미 화면을 전환할 수 있습니다! <del>(어떻게…?)</del><br><a href="https://dev-juyoung.github.io/2017/05/01/android-intent">Intent 객체</a> 포스팅에서 잠깐 언급했던 말이지만,<br>안드로이드 시스템에게 <strong>나 지금 어디로 이동할꺼야!</strong>라고 전달하기 위해서는 안드로이드 시스템이 알아 들을 수 있는 언어(?)인 <code>Intent 객체</code>를 이용하여야 된다고 말씀드렸는데요.<br>그럼 실질적인 예제코드부터 확인해보시죠.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MainActivity.java</span></div><div class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, SecondActivity.class);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>어디서 많이 본 코드 같지 않나요??<br>눈썰미가 좋으신 분은 눈치 채셨겟지만, 이미 <code>Intent 객체</code>에 대한 포스팅에서 나온 코드입니다.</p>
<p>이 코드는, 안드로이드 프레임워크에서 제공해주는 기본 method인 <code>startActivity()</code>를 이용하여,<br>생성된 <code>Intent 객체</code>를 기반으로 화면을 이동시키는 코드입니다.</p>
<p>화면을 이동하기 위해서는 <code>Intent 객체</code>에 2개의 Parameter가 필요합니다.<br>간단하게 이해를 돕자면, <strong>현재 어디의 화면에 머물러 있는데 어떤 화면으로 이동을 할것이다!</strong>라는 정보이죠.</p>
<p>즉, 한번 더 풀어쓰면, 현재 <code>MainActivity</code>에 머물러 있는데, <code>SecondActivity</code>라는 화면으로 이동을 할 것이다! 라고 알려주는 것입니다. 우리는 이러한 <code>Intent</code>객체를 <code>명시적 Intent</code>라고 알고있죠. 이것이 끝입니다. 쉽죠?</p>
<h2 id="전환되는-화면으로-데이터-전달하기"><a href="#전환되는-화면으로-데이터-전달하기" class="headerlink" title="전환되는 화면으로 데이터 전달하기"></a>전환되는 화면으로 데이터 전달하기</h2><p>화면만 간단히 전달할 줄 알면 참 좋겠습니다만…프로그램의 생태계란 것이 그렇지 않은 경우가 태반이더라구요…<br>실제 어플리케이션을 개발하다보면 특정한 데이터를 받아서 처리를 해야되는 <code>Activity</code>가 존재하기 마련입니다.<br>하지만 그렇게 걱정하지 않으셔도 되요. 이미 <code>Intent 객체</code>는 그것을 알기라도 했다는 듯이 <strong>필요하면 써!</strong>라고 말하듯이 method를 제공하고 있기 때문이죠.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MainActivity.java</span></div><div class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, SecondActivity.class);</div><div class="line">intent.putExtra(<span class="string">"user_name"</span>, <span class="string">"cro, developer"</span>);</div><div class="line">intent.putExtra(<span class="string">"user_age"</span>, <span class="number">28</span>);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>위의 코드를 이용하여 사용자의 이름과 나이를 함께 전달해주는 코드를 보강해보았습니다.<br>다음화면으로 데이터를 전달해주기 위해서는 <code>putExtra(key, value)</code> 메서드를 사용하시면 됩니다. 이것 또한 간단하죠?<br><code>putExtra()</code>메서드의 두번째 Parameter에는 여러가지의 데이터타입을 전달할 수 있도록 제공하고 있으니, 우리의 똑똑한 IDE인 <code>Android Studio</code>의 어시스트 기능을 이용하여 어떠한 데이터타입을 전달 할 수 있는지 한번 확인해보세요!</p>
<h2 id="전달받은-데이터-획득하기"><a href="#전달받은-데이터-획득하기" class="headerlink" title="전달받은 데이터 획득하기"></a>전달받은 데이터 획득하기</h2><p>위에서 전환되는 화면으로 데이터를 전달해주는 방법은 알아보았는데, 단순히 전달만 한다고 사용할 수 있지는 않습니다.<br>전달은 받았지만 전달받은 데이터를 획득하지 않으면 단순히 쓸모없는 데이터일 뿐입니다.<br>그렇다면 힘들게 넘겨준 데이터를 <strong>쓸모있는</strong>데이터로 만들기 위해, 데이터를 획득하는 방법을 한번 알아볼까요??<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SecondActivity.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 생략</span></div><div class="line">    Intent intent = getIntent();</div><div class="line">    <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</div><div class="line">        String userName = intent.getStringExtra(<span class="string">"user_name"</span>);</div><div class="line">        <span class="keyword">int</span> userAge = intent.getIntExtra(<span class="string">"user_age"</span>, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>특별한 경우가 아니라면 보통은 안드로이드의 생명주기 중, <code>onCreate()</code> 메서드 안에서 데이터를 획득해오는 방식을 많이 사용하는 것 같습니다.<br>데이터를 획득하는 방법 역시 간단합니다. <code>getIntent()</code>메서드를 통해 전달받은 <code>Intent 객체</code>를 획득합니다.<br>그런 다음, 획은한 <code>Intent 객체</code>에서 각각의 데이터 타입에 받는 <code>getXxxExtra()</code>메서드에 전달할 때 사용되었던 <code>KEY</code>값을 이용하여 뽑아오면 그만이죠!<br>하지만 두번째 경우인 사용자의 나이에 대한 데이터를 획득하는 메서드에는 뭔가 하나의 Parameter가 더 있는 것을 볼 수 있는데요.<br>두번째에 넘어가는 데이터는 <code>Default</code>값입니다. 즉, <code>KEY</code>에 해당하는 데이터를 획득하지 못하였을 때, 기본값으로 무엇을 사용할 것이냐는 것이죠.<br><code>Default</code>값을 정할 수 있는 데이터타입은 몇가지가 있는데, 어떻게 구별할 지 궁금 할 수도 있겟네요.<br>Java의 데이터타입에 대해서 생각해보면 편하실 듯 합니다. <code>null</code>로 초기화를 할 수 없는 데이터타입은 모두 <code>Default</code>값을 지정하여 데이터를 전달받지 못한 경우, <code>Default</code>값으로 초기화(?)할 수 있도록 지정해주어야 합니다.</p>
<h2 id="데이터를-이전화면으로-전달하기"><a href="#데이터를-이전화면으로-전달하기" class="headerlink" title="데이터를 이전화면으로 전달하기"></a>데이터를 이전화면으로 전달하기</h2><p>위에서 우리는 화면도 전환하고, 데이터도 넘겨주고, 심지어 데이터를 획득하는 방법에 대해 알아보았습니다.<br>이정도만 있어도 기본적인 어플리케이션을 개발하기에는 충분합니다. 하지만 조금 특별한 경우가 있을 수 있어요..<br>화면을 이동한 후, 이동된 화면에서 어떠한 처리를 하고, 처리된 결과값을 다시 이전화면으로 돌려줘야되는 경우가 있을 수 있죠.<br>조금은 실용적이지 못한 어플리케이션이겠지만, 숫자 2개를 넘겨받아 합산을 한 후, 이전화면으로 다시 돌려주는 어플리케이션이 있다고 가정해봅시다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MainActivity.java</span></div><div class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, CalculatorActivity.class);</div><div class="line">intent.putIntent(<span class="string">"first"</span>, <span class="number">100</span>);</div><div class="line">intent.putIntent(<span class="string">"second"</span>, <span class="number">200</span>);</div><div class="line">startActivityForResult(intent, <span class="number">3641</span>);</div></pre></td></tr></table></figure></p>
<p>위에서 화면을 전환할 때와는 조금은 다른 코드가 나왔습니다. <code>startActivityForResult()</code>인데요.<br>대충 느낌적으로 봤을때 메서드명에서부터 알 수 있듯, Activity를 시작하긴 할껀데 결과값을 뭔가 어떻게 하겠다는 그런 메서드같네요?<br>그리고, 단순히 <code>startActivity()</code>를 할 때와는 다르게, <code>Intent 객체</code> 이외에도 뭐가 숫자코드가 같이 주어지고 있습니다.<br>이 숫자코드는 <code>REQUEST_CODE</code>라는 것인데, 임의로 아무숫자나 정해주셔도 됩니다.<br>하지만 나중에 결과값을 받을 때 중요한 역할을 하므로 기억하고 있어야 합니다.<br>그럼 다시 코드로 돌아가서 <code>CalculatorActivity</code>의 코드를 확인해보죠.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CalculatorActivity.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 생략</span></div><div class="line">    Intent intent = getIntent();</div><div class="line">    <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> first = intent.getIntExtra(<span class="string">"first"</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">int</span> second = intent.getIntExtra(<span class="string">"second"</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">int</span> sum = first + second;</div><div class="line"></div><div class="line">        Intent resultIntent = <span class="keyword">new</span> Intent();</div><div class="line">        resultIntent.putExtra(<span class="string">"sum"</span>, sum);</div><div class="line">        setResult(RESULT_OK, resultIntent);</div><div class="line">        finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><del>참, 쓸모없는 어플리케이션 인 듯 합니다…</del><br>우리는 전달받은 데이터를 획득하는 방법은 이미 알기에 위의 코드를 대충은 이해할 수 있습니다.<br>우선은 <code>first</code>와 <code>second</code>라는 <code>KEY</code>값을 이용하여 전달받은 <code>Integer</code>데이터를 획득하고,<br>새로운 <code>sum</code>이라는 변수를 선언하여 두 값의 합을 구해주고 있지요. 그 뒤에 나오는 코드가 핵심코드가 되겠습니다.</p>
<p>안드로이드에서 <code>Activity</code>를 종료하기 위해서는 <code>finish()</code>메서드를 이용합니다.<br>하지만 화면을 종료하기 전에, 우리는 이전화면으로 결과를 전달해주기 위해 다시 <code>Intent 객체</code>를 생성하였고,<br>해당객체에 두 수의 합이 담겨있는 sum을 데이터로 담아주었습니다.<br>그리고 제일 중요한 <code>setResult()</code>메서드를 이용하여 <code>RESPONSE_CODE</code>와 <code>Intent 객체</code>를 지정해주었습니다.</p>
<p>이름에서부터 알 수 있듯 <code>setResult()</code>메서드는 결과를 전달해주는 메서드 입니다.<br>해당 메서드에는 2개의 Parameter를 전달 할 수 있는데,<br>첫번째가 <code>RESPONSE_CODE</code> 즉, 처리된 결과가 성공이냐, 또는 실패냐, 아니면 어떠한 다른 상태이냐를 나타내는 상태코드입니다. 이것을 잘 사용하면, 성공 / 실패 / 취소 등등 여러가지의 원하는 결과코드를 보낼 수 있죠.<br>두번째는 우리가 계속 사용해오던 일반적인 <code>Intent 객체</code>입니다. 단순히 결과코드에 대해서만 알려줄 필요가 있다면 <code>Intent 객체</code>는 생략 될 수 있으며, 필요에 따라 데이터를 전달해줘야 된다면 지금까지 사용해온 방식대로 <code>Intent 객체</code>에 데이터를 실어서 전달해주시면 됩니다.</p>
<p>참, 긴 여정이였습니다. 이제 마지막 단계만 남겨두었어요! 전달받은 결과값을 처리해야겠죠?<br>그럼 다시 전달받은 값을 처리해야되니 <code>MainActivity</code>코드를 확인해봅시다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (resultCode != RESULT_OK) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (requestCode == <span class="number">3641</span>) &#123;</div><div class="line">        <span class="comment">//... 처리코드</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (requestCode == <span class="number">2172</span>) &#123;</div><div class="line">        <span class="comment">//... 처리코드</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>드디어 끝이 보입니다. 이번 코드는 조금 짧게 썻는데요… <del>귀찮아서 절대아님..</del>~<br>결과를 받아올 경우에는 <code>onActivityResult()</code>라는 특별한 메서드를 이용합니다.<br>해당 메서드가 조금은 복잡해 보일지 모르겠지만, 이미 우리는 지금까지 모두 사용했던 것이므로 굉장히 간답합니다.</p>
<p>우선은 인자값들부터 하나하나 확인해보죠.</p>
<ul>
<li>int requestCode: <code>startActivityForResult()</code>메서드를 실행할 때, 두번째 인자값으로 넘겨준 <code>REQUEST_CODE</code></li>
<li>int resultCode: <code>setResult()</code>메서드를 실행할 때, 첫번째 인자값으로 넘겨준 <code>RESPONSE_CODE</code></li>
<li>Intent data: <code>setResult()</code>메서드를 실행할 때, 두번째 인자값으로 넘겨준 데이터가 담겨있는 <code>Intent 객체</code></li>
</ul>
<p>어때요? 하나하나 살펴보니 되게 쉽지요?<br>저것들만 이해하면 이제 코드를 나머지 코드는 <strong>식은 죽 먹기</strong>입니다.</p>
<p>우선은, 응답코드를 확인하여 <code>RESULT_OK</code>가 아니라면 해당 메서드를 종료해버리는 코드가 작성되어 있습니다.<br>이외의 응답코드에 대한 코드가 더 필요하다면 조건절로 작성해주시면 되겠죠?</p>
<p>그런 다음, 응답코드가 <code>RESULT_OK</code>라면 <code>REQUEST_CODE</code>에 따라서 해당하는 처리로직을 작성해주시면 됩니다.<br>굳이 양념을 첨가하여 예제코드에 있는 <code>3641</code>에 해당하는 처리코드만 작성해보자면…<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sum = data.getIntExtra(<span class="string">"sum"</span>, <span class="number">0</span>);</div><div class="line">Log.d(<span class="string">"MainActivity"</span>, sum);</div></pre></td></tr></table></figure></p>
<p>뭐… 이정도가 되겠네요… 굳이 작성하지 않은 이유를 아시겠죠?</p>
<p>위에서 잠깐 언급했지만, <code>REQUEST_CODE</code>는 기억을 하고 있어야 된다고 이야기 했었습니다. 그 이유가 바로 결과를 받는 곳에서 나타납니다.<br>현재 예제코드에는 한 화면에서 호출하고 다시 전달받는 코드가 한번만 사용되었기에 굳이 외우고 있을 필요는 없지만, 실제 어플리케이션을 개발하다보면 한 화면에서 여러 <code>Activity</code>로부터 결과값을 전달받는 경우가 발생합니다. 하지만 <code>REQUEST_CODE</code>를 기억하고 있지 못하다면, 각각에 기능에 맞는 처리로직을 작성할 수 없을 뿐더러, 여러개로 작성하더라도 <code>REQUEST_CODE</code>가 엉뚱하다면 전혀 생각지도 못하게 어플리케이션이 기능이 꼬이게 되겠죠? 그래서 <code>REQUEST_CODE</code>를 기억하고 있으셔야 된다고 한 것 입니다.</p>
<h2 id="약간의-TIP"><a href="#약간의-TIP" class="headerlink" title="약간의 TIP?"></a>약간의 TIP?</h2><p>여기까지 보셨다면 이미 이번 포스팅에서 원하고자하는 목적은 도달하였으니 제 블로그를 끄셔도 됩니다. <del>하지만 안보면 후회할껄?</del><br>여기서부터는 실제 개발하면서 조금은 이렇게 개발하면 관리하기 편하더라(?)하는 정보를 적어볼까 합니다. 특별한건 없으니 그렇게 큰 기대는…<br>솔직히 Intent와 관련하여 특별한 TIP은 없습니다. 아마 개발자라고 하시면 모든분들이 이렇게 하고 계실수도 있어요…</p>
<h2 id="REQUEST-CODE는-상수를-활용하라"><a href="#REQUEST-CODE는-상수를-활용하라" class="headerlink" title="REQUEST_CODE는 상수를 활용하라."></a>REQUEST_CODE는 상수를 활용하라.</h2><p>이부분은 REQUEST_CODE에만 국한되지는 않습니다<br>변하지 않는 데이터라면 목적에 맞게 상수로 정의해두면 시간이 흐른 뒤, 어떤 목적으로 사용되었는지 기억하기도, 관리하기도 쉽습니다.<br>사람의 기억력은 그렇게 좋지 않기에, 시간이 많이 흐른 뒤 소스코드를 다시 열어 <code>3641</code>이라는 리터럴 데이터가 들어가 있으면 혼동스러을 수 있습니다.<br>이런 리터럴 데이터보다는 이해하기 쉽고 직관적인 상수명으로 사용이 되어 있다면, 시간이 흐른 뒤 열어보더라도 <strong>아! 이 코드는 내가 뭘 원했기 떄문에 사용했지!</strong>하며 기억하기에 좋습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> REQUEST_CODE_SUM = <span class="number">3641</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> REQUEST_CODE_CAMERA = <span class="number">2172</span>;</div><div class="line"><span class="comment">//... 등등등</span></div></pre></td></tr></table></figure></p>
<h2 id="putExtra-getExtra에-사용되는-KEY-역시도-상수로-활용하라"><a href="#putExtra-getExtra에-사용되는-KEY-역시도-상수로-활용하라" class="headerlink" title="putExtra / getExtra에 사용되는 KEY 역시도 상수로 활용하라."></a>putExtra / getExtra에 사용되는 KEY 역시도 상수로 활용하라.</h2><p>실제 개발을 하다보면 혼자서 모든 개발을 맡아 작업하시는 분은 거의 없으시리라 봅니다. 특히 우리는 안드로이드 개발자이므로 서버개발자와 협업하는 일이 빈번하게 일어나죠.<br>이런 경우, 협업을 하다보면 서버와 통신시에 필요한 데이터의 경우 커뮤니케이션 향상과 협업을 위해 서버와 클라이언트가 명칭을 통일하게 되는 경우도 발생합니다. <del>저희는 그렇게 하고있…</del><br>그리고 대체적으로 이런 일은 서버 통신 시에 필요한 최소한의 <code>KEY</code>값에 해당하는 경우가 많습니다.<br>특히 이러한 <code>KEY</code>값에 해당하는 명칭들은 여러 <code>Activity</code>에 걸쳐 사용되기도 하죠.<br>그러다 개발 도중 잦은 기획의 변경이나 특정 목적에 따라 명칭이 변경된다면? 상상만해도 머리가 지끈거리기 시작합니다.<br>모든 Activity를 찾아다니며 명칭을 변경해줘야되는 불상사가 생기기 떄문이죠…<br>이러한 불상사를 미연에 방시할 수 있도록 되도록이면, EXTRA의 <code>KEY</code>로 사용되는 리터럴 데이터는 하나의 <code>Class</code>로 따로 분리하여 관리포인트를 최소화 시키는 것도 좋습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Class 선언</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constants</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXTRA_SERVER_KEY = <span class="string">"serverKey"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXTRA_CLIENT_KEY = <span class="string">"clientKey"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXTRA_BOARD_ID = <span class="string">"boardId"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Activity등에서 실 사용.</span></div><div class="line">Intent intent = <span class="keyword">new</span> Intent();</div><div class="line">intent.putExtra(Constants.EXTRA_SERVER_KEY, <span class="string">"xxxxxx"</span>);</div></pre></td></tr></table></figure></p>
<h2 id="끝맺으며"><a href="#끝맺으며" class="headerlink" title="끝맺으며.."></a>끝맺으며..</h2><p>이번 포스팅에서는 <code>Intent 객체</code>를 이용하여 여러방법으로 화면을 전환하고, 다시 돌아오는 등의 내용을 작성해보았습니다.<br>그리고 추가적으로, 크게 도움이 되지 않는 TIP일 수 있겠지만, 현업을 하다 생기는 문제를 조금은 해소하고자 나름의 TIP도 몇자 적어보았습니다.<br>이미 능력이 좋으신 개발자분들은 <strong>저게 무슨 TIP이야?</strong>라고 할 수 있는 소소한 정보이지만,<br>저는 선임자 없이 혼자서 모든걸 해결해오던 스타트업의 개발자이므로…<del>ㅜㅜㅜㅜㅜㅜ</del><br>저런 사소한 부분때문에 골치가 아프기도, 그리고 불필요한 시간허비도 했었던 것 같습니다.<br>그래서, 혹시 제 포스팅을 보고 계신 여러분이 개발을 시작하시는 분이라면 이러한 삽질을 조금이라도 덜 하시길 원하는 마음에 몇자 적어보았습니다!</p>
<p>물론, 개인 프로젝트로 개발을 진행한다면 문제가 없겠지만,<br>이러한 사소한 코드 작성법과 습관이 실제 현업에서 협업하는 개발자라면, 혹은 이직을 고민하는 개발자라면!<br>회사에 남아있는 사람 또는, 내 뒤를 이어줄 후임자를 위해서라도 좋은 습관이 될 것 같습니다!</p>
<p>그럼 이만 길어진 오늘의 포스팅은 여기서 마무리 하도록 하겠습니다! 안녕!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;저번 포스팅에서 &lt;code&gt;Intent 객체&lt;/code&gt;에 대해서 알아보았습니다.&lt;br&gt;&lt;code&gt;Intent 객체&lt;/code&gt;에 대하여 기억이 나지 않는다면, &lt;a href=&quot;https://dev-juyoung.github.io/2017/05/01/android-intent&quot;&gt;해당 포스팅&lt;/a&gt;을 확인해보세요.&lt;/p&gt;
&lt;h2 id=&quot;Activity&quot;&gt;&lt;a href=&quot;#Activity&quot; class=&quot;headerlink&quot; title=&quot;Activity??&quot;&gt;&lt;/a&gt;Activity??&lt;/h2&gt;&lt;p&gt;Activity전환에 대한 이야기를 시작하기에 앞서,&lt;br&gt;안드로이드를 처음 접하시는 분이라면 &lt;code&gt;Activity&lt;/code&gt;가 무엇인지 잘 모를 수도 있습니다. 당연하거지요.&lt;br&gt;그렇다면 &lt;code&gt;Activity&lt;/code&gt;란 무엇일까요??&lt;br&gt;간단히 말해서, &lt;code&gt;Activity&lt;/code&gt;란 하나의 화면을 구성하고 있는 안드로이드 시스템에서의 &lt;code&gt;화면의 단위&lt;/code&gt;정도로 생각하시면 됩니다.&lt;br&gt;웹에 대해 지식이 있는 분이라면 여러개의 &lt;code&gt;html&lt;/code&gt;파일이 모여 하나의 웹사이트를 이루듯,&lt;br&gt;안드로이드는 여러개의 &lt;code&gt;Activity&lt;/code&gt;가 모여 하나의 어플리케이션을 이루는 것이죠.&lt;/p&gt;
&lt;p&gt;물론, 실질적으로 안드로이드 어플리케이션을 개발하다보면, &lt;code&gt;Activity&lt;/code&gt;뿐만 아니라,&lt;br&gt;&lt;code&gt;Fragment&lt;/code&gt;라는 녀석도 필요한 경우가 존재하는데, 이 녀석은 오늘의 주제가 아니니 건너가죠!&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://dev-juyoung.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://dev-juyoung.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Intent 객체란 무엇일까?</title>
    <link href="https://dev-juyoung.github.io/2017/05/01/android-intent/"/>
    <id>https://dev-juyoung.github.io/2017/05/01/android-intent/</id>
    <published>2017-05-01T04:25:51.000Z</published>
    <updated>2017-05-01T04:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>블로그를 개편(?) 한 후, 첫번째 포스팅입니다.<br>새롭게 시작하는 의미에서 이번 포스팅에서는 가볍게 Intent객체에 대하여 설명하는 시간을 가질 예정입니다.</p>
<h2 id="Intent객체"><a href="#Intent객체" class="headerlink" title="Intent객체?"></a>Intent객체?</h2><p>저도 영어를 잘 못하기 때문에, 사전적 의미를 한번 찾아보았습니다.<br>사전적인 의미로는 <code>의지, ~ 몰두하는, ~ 강한관심을 보이는</code>등의 의미로 사용되는 것 같네요?</p>
<p>그렇다면, 안드로이드 시스템에서의 Intent객체란 무슨 의미일까요?<br>의미를 설명하기에 앞서, 안드로이드에서 어떠한 어플리케이션을 사용해보셨다면 아실테지만,<br>모든 어플리케이션은 여러개의 화면으로 이루어져 있고, 화면을 이동하면서 사용을 한다는 것은 다들 아실 것 같습니다.<br>또는, 어떠한 어플리케이션들은 다른사람이 미리 만들어둔 어플리케이션을 호출하여 실행해주기도 하죠.<br><a id="more"></a><br>이렇게 어플리케이션 내에서 화면을 이동하거나 다른 어플리케이션을 실행하기 위해서는,<br>안드로이드 시스템에서 <strong>나 지금 다른화면 이동할껀데?</strong>라던지, <strong>나 지금 Facebook이라는 어플 실행할꺼야</strong>라는 등의 의사표현을 전달해야 됩니다.<br>이러한 의사표현을 안드로이드 시스템에게 전달하려면 어떻게 해야 될까요?<br>굉장히 간절한 소망을 담아서 아주 큰 목소리로 스마트폰에 대고 말을 걸어도 이름과는 반대인 멍청한 우리의 스마트폰은 실행해주지 않죠.</p>
<p>조금 더 간단하게, 연인 관계에 있을 법한 예시를 들어볼까요?<br>음식사진을 보다가 너무 맛있어 보이는 음식이 있었는데 속으로 <strong>이거 먹고싶어!</strong>라고 죽어라 텔레파시를 보내도 상대방은 알길이 없죠.<br>그래서 사람은 이러한 의사표현을 전달하기 위한 목적으로 언어라는 의사소통을 위한 국가마다 정해진 규약을 사용합니다.</p>
<p>이러한 언어와 마찬가지로 안드로이드 시스템에게 무엇을 하고자한다고 의사표현을 하기 위해서는 안드로이드 시스템이 알아 들을 수 있는 언어를 사용해줘야 하며, 그것이 바로 오늘의 주제인 <strong>Intent객체</strong>입니다.</p>
<h2 id="Intent객체로-할-수-있는-일"><a href="#Intent객체로-할-수-있는-일" class="headerlink" title="Intent객체로 할 수 있는 일?"></a>Intent객체로 할 수 있는 일?</h2><p>그렇다면 위에서 장황하게 설명한 Intent객체라는 녀석이 무엇을 할 수 있을까요?<br>물론 저도 모든 것을 알고 있지는 않기에 몇가지의 예시만 들어보고자 합니다.</p>
<blockquote>
<p>위에서 잠깐 언급했듯, 원하는 화면으로 이동할 수 있습니다.<br>본인이 만든 어플리케이션에서 다른사람이 만들어둔 어플리케이션을 실행 할 수 있습니다.<br>Intent객체를 이용하여 본인의 어플리케이션에서 SMS를 보낼 수도 있죠!<br>혹은, 반대로 수신받은 SMS의 정보를 얻어올 수도 있습니다.</p>
</blockquote>
<p>몇가지의 간단한 예시만 적었지만, 이것들은 Intent객체를 통해 할 수 있는 아주 일부분에 불과합니다.<br>거의 어플리케이션에서 할 수 있는 모든 행위들의 중심은 Intent객체라고 해도 과언이 아닐 정도이죠.</p>
<h2 id="명시적-암시적"><a href="#명시적-암시적" class="headerlink" title="명시적?? 암시적??"></a>명시적?? 암시적??</h2><p>Intent객체라는 녀석만으로도 머리가 아픈데, 어려운 용어가 나왔어요..<br>Intent객체를 사용함에 있어서 <code>명시적 Intent</code>와 <code>암시적 Intent</code>로 다시 나뉠 수 있는데요.<br>우선 간단한 예제부터 알아보죠.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 명시적 Intent</span></div><div class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, SecondaryActivity.class);</div><div class="line">startActivity(intent);</div><div class="line"></div><div class="line"><span class="comment">// 암시적 Intent</span></div><div class="line">Uri uri = Uri.parse(<span class="string">"tel:xxx"</span>);</div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_DIAL, uri);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>어떤가요? 대충 감이 잡히시나요? <code>명시적 Intent</code>란 안드로이드 시스템에게 <strong>나 지금 어떤 컴포넌트를 호출할꺼야!</strong>라고 실행하고자하는 컴포넌트를 정확히 콕! 집어 알려주는 것을 의미합니다.<br>그와 반대로 <code>암시적 Intent</code>란 안드로이드 시스템에게 <strong>나 지금 이런 데이터를 가지고 이런 행위를 하려고하는데 니가 적당한 컴포넌트로 실행해줄래?</strong>라고 실행하고자하는 컴포넌트는 정확히 알 수 없지만, <code>Action과 Data</code>등을 이용하여 안드로이드 시스템에게 컴포넌트 실행을 위임하는 것이라고 보시면 편할 것 같습니다.<br>약간의 부가적인 설명을 덧붙힌다면, <code>암시적 Intent</code>는 어떠한 행위를 뜻하는 <code>Action</code>과 행위에 필요한 정보인 <code>Data</code>, 그리고 더불어 행위에 필요한 데이터의 종류인 <code>Type</code>의 정보만으로 Intent객체를 생성하고 안드로이드 시스템에게 위임하여 원하는 컴포넌트를 실행하는 것이라고 보면 될 것 같습니다.</p>
<p>어떤가요? 조금 어려운가요?<br>물론 포스팅을 작성하고 있는 저도 초급자이기에 정확한 의사전달은 되지 않았을지 모르지만 Intent객체에 대해 이해를 돕는데 조금은 기여했길 바랍니다!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;블로그를 개편(?) 한 후, 첫번째 포스팅입니다.&lt;br&gt;새롭게 시작하는 의미에서 이번 포스팅에서는 가볍게 Intent객체에 대하여 설명하는 시간을 가질 예정입니다.&lt;/p&gt;
&lt;h2 id=&quot;Intent객체&quot;&gt;&lt;a href=&quot;#Intent객체&quot; class=&quot;headerlink&quot; title=&quot;Intent객체?&quot;&gt;&lt;/a&gt;Intent객체?&lt;/h2&gt;&lt;p&gt;저도 영어를 잘 못하기 때문에, 사전적 의미를 한번 찾아보았습니다.&lt;br&gt;사전적인 의미로는 &lt;code&gt;의지, ~ 몰두하는, ~ 강한관심을 보이는&lt;/code&gt;등의 의미로 사용되는 것 같네요?&lt;/p&gt;
&lt;p&gt;그렇다면, 안드로이드 시스템에서의 Intent객체란 무슨 의미일까요?&lt;br&gt;의미를 설명하기에 앞서, 안드로이드에서 어떠한 어플리케이션을 사용해보셨다면 아실테지만,&lt;br&gt;모든 어플리케이션은 여러개의 화면으로 이루어져 있고, 화면을 이동하면서 사용을 한다는 것은 다들 아실 것 같습니다.&lt;br&gt;또는, 어떠한 어플리케이션들은 다른사람이 미리 만들어둔 어플리케이션을 호출하여 실행해주기도 하죠.&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://dev-juyoung.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://dev-juyoung.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>REMAKE, 블로그</title>
    <link href="https://dev-juyoung.github.io/2017/04/28/remake-blog/"/>
    <id>https://dev-juyoung.github.io/2017/04/28/remake-blog/</id>
    <published>2017-04-28T06:26:43.000Z</published>
    <updated>2017-06-15T07:29:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="블로그를-다시-만들다"><a href="#블로그를-다시-만들다" class="headerlink" title="블로그를 다시 만들다."></a>블로그를 다시 만들다.</h2><p>작년도인 2016년도에 들어서면서 처음으로 블로그라는 것을 시작했었다.<br>원래 성격이 무엇이든 시작하고자 마음먹으면 지체하지 않고 행동으로 옮기는 경향을 가지고 있지만,<br>조금은 모순되게도 게으른 성격도 가지고 있는 것이 단점이다.<br><a id="more"></a><br>그러다보니, 업무가 바쁘다는 핑계를 대며 자기합리화와 함께 어느순간 블로그 관리에 소홀해지기 시작했다.<br>누구나 그렇듯 한번 소홀해지기 시작하면 점점 더 관심속에서 멀어지 듯,<br>그렇게 관리하던 블로그라는 존재가 있었나 싶을 정도로 내 관심은 멀어졌다.</p>
<p>그렇게 게으른 생활이 이어지다보면, 누구나 한번쯤은 인생의 터닝포인트가 필요하다는 생각이 들 것 같다.<br>주변의 지인들이 30대에 들어서고 있고, 나 또한 30대를 향해가는 20대 후반에 들어서면서,<br>인생의 터닝포인트가 필요하다는 생각이 들었고, 언제 또 흐지부지 될 지 모르지만 마음을 먹으면 시작해야 되는 성격때문에 요즘 생각하고 있는 것들에 대해 하나씩 실행에 옮겨보고자 한다.</p>
<p>그 중, 첫번째로 실행에 옮기고자하는 것이 블로그를 다시 관리하는 것이다.</p>
<h2 id="리메이크한-이유"><a href="#리메이크한-이유" class="headerlink" title="리메이크한 이유?"></a>리메이크한 이유?</h2><p>누군가는 쓰던 블로그 그대로 사용하면 되지 굳이 왜 힘들게 블로그를 다시 만들었냐고 질문을 던질 수 있겠지만, 이유는 간단하다.</p>
<p>블로그의 첫 시작은 <code>Tistory</code>로 시작했었지만,<br>주변의 많은 개발자들이 <code>github pages</code>서비스와 <code>jekyll</code>을 이용하여 블로그를 운영하는 것을 알게 되었고,<br><strong>개발자스럽다!</strong>라는 마음과 함께 <code>github.io</code>로 끝나는 도메인을 사용할 수 있는 것에 끌려 한번 블로그를 옮겼었다.</p>
<p>그 당시에는 루비를 전혀 몰랐어도 대충 눈칫밥으로 어떻게든 조금씩 수정해나가며 사용했었는데,<br>블로그와 이별한지 반년이라는 시간이 지나버리고 다시 열아보니 도저히 관리할 자신이 생기지 않았다.</p>
<p>심지어, 그 당시에는 힘들게 Windows기반의 PC에서 Jekyll과 관련된 환경설정으로 삽질했었던 기억이 있었는데,<br>Mac기반의 PC로 바꾸면서 환경설정에 대한 안좋은 기억때문에 엄두를 낼 수가 생각조차 들지 않았다.</p>
<p>그렇게 기웃기웃거리다 <code>jekyll</code>과 양대산맥을 이룬다는 <code>hexo</code>를 접하게 되었다.<br>우선 <code>node.js</code>에 기반을 두고 있다라는 것에 메리트를 느꼈고, 언제 다시 소홀해질지 알 수 없지만,<br>다음에 다시 돌아왔을 때를 생각하면 수박 겉핧기 식으로라도 알고 있는 언어이기에 조금은 더 마음이 이끌렸던 것 같다.</p>
<p>그리고, 이전에 작성해둔 포스팅들의 내용을 다시 리뷰해보니, 정확하지 않거나 오타도 많아 한번 재정비를 해야 될 것 같았다.</p>
<h2 id="블로그의-목적은"><a href="#블로그의-목적은" class="headerlink" title="블로그의 목적은?"></a>블로그의 목적은?</h2><p>블로그의 목적은 다음의 몇가지 이유와 같다.</p>
<ul>
<li>블로그에 대한 재도전<blockquote>
<p>블로그를 할 때, 항상 목표를 크게 가졌던 것 같다. (주 1회 1포스팅 이라던지…)<br>이번엔 목표를 낮춰 포스팅의 업로드 주기는 잡지 않고, 꾸준히 포스팅을 시도해보는 것이 목표이다.</p>
</blockquote>
</li>
<li>개발에 대한 정리<blockquote>
<p>나름 기억력이 좋은 편이지만, 사람의 기억력에는 한계가 있다고 생각한다.<br>구글링을 잘하는 것도 실력이지만, 자주 찾는 정보에 대하여 정리하는 것이 목적이다.</p>
</blockquote>
</li>
<li>개발에 대한 공유<blockquote>
<p>같은 삽질은 여러번 반복하지 않는 것이 좋다고 한다.<br>그래서 오픈소스, 각종 라이브러리가 물밀듯 쏟아져 나오는게 아닌가 싶다.<br>세상은 넓으니 이제 갓 입문하시는 분들에게 미약하지만 알고 있는 지식과 겪었던 문제를 공유하고자 한다.</p>
</blockquote>
</li>
<li>개발에 대한 피드백<blockquote>
<p>나 또한 초보개발자이므로 누군가의 도움이 필요하다.<br>현재 짜고있는 코드가 맞는 것인지, 조금 더 좋은 방법이 없을지 생각하는건 개발자라면 당연하다 생각한다.<br>찾아오실지는 미지수지만, 소위 말해 `갓님들의 피드백을 받고 싶은 목적도 있다.</p>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;블로그를-다시-만들다&quot;&gt;&lt;a href=&quot;#블로그를-다시-만들다&quot; class=&quot;headerlink&quot; title=&quot;블로그를 다시 만들다.&quot;&gt;&lt;/a&gt;블로그를 다시 만들다.&lt;/h2&gt;&lt;p&gt;작년도인 2016년도에 들어서면서 처음으로 블로그라는 것을 시작했었다.&lt;br&gt;원래 성격이 무엇이든 시작하고자 마음먹으면 지체하지 않고 행동으로 옮기는 경향을 가지고 있지만,&lt;br&gt;조금은 모순되게도 게으른 성격도 가지고 있는 것이 단점이다.&lt;br&gt;
    
    </summary>
    
      <category term="Story" scheme="https://dev-juyoung.github.io/categories/Story/"/>
    
    
      <category term="Story" scheme="https://dev-juyoung.github.io/tags/Story/"/>
    
  </entry>
  
</feed>
