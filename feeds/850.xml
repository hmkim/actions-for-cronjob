<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>안녕 프로그래밍</title>
  
  <subtitle>모두가 프로그래밍에서 자유로워지는 그 날까지</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.holaxprogramming.com/"/>
  <updated>2018-11-01T14:25:00.042Z</updated>
  <id>https://www.holaxprogramming.com/</id>
  
  <author>
    <name>Minhyeok Jung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git Flow와 자주 사용되는 Git 명령어들</title>
    <link href="https://www.holaxprogramming.com/2018/11/01/git-commands/"/>
    <id>https://www.holaxprogramming.com/2018/11/01/git-commands/</id>
    <published>2018-11-01T06:14:40.000Z</published>
    <updated>2018-11-01T14:25:00.042Z</updated>
    
    <content type="html"><![CDATA[<p><code>Git Flow</code>는 git을 통해 효율적으로 프로젝트를 관리하고 배포하기 위한 전략이다. 기본적으로 Git은 로컬 저장소와 원격 저장소간의 동기화를 위해 아래와 같은 과정을 거친다.</p><a id="more"></a><p><img src="https://about.gitlab.com/images/git_flow/four_stages.png" height="400"></p><p>하지만 프로젝트의 규모가 커지고 협업하는 동료들이 많아진다면 저장소의 master branch만을 이용하는 것에서 이슈에 따라 다양한 branch를 통해 다양한 인원이 독립적으로 개발이 가능한 전략이 필요하다.</p><h2 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h2><p><img src="https://about.gitlab.com/images/git_flow/gitdashflow.png"></p><p>Git Flow는 다양한 branch를 관리하고 통합하기 위한 전략 중 하나이다. 최근에는 Git Flow의 단점을 해소하기 위해 Github Flow, Gitlab Flow 등 다양한 전략이 있지만 이 문서에서는 가장 기본이 되는 Git Flow를 설명하고 여기에 필요한 기본적인 Git 명령어에 대해 알아보도록 하겠다.</p><h2 id="브랜치-전략"><a href="#브랜치-전략" class="headerlink" title="브랜치 전략"></a>브랜치 전략</h2><p>Git Flow의 주요 브랜치는 <code>master</code>와 <code>develop</code> 이며, 이 두 브랜치를 중심으로 feature, release와 필요에 따라 hotfixes 브랜치를 정의한다.</p><p><img src="https://camo.githubusercontent.com/70f7e458a965f38831d1c50757b3a284c4280328/687474703a2f2f646f67666565742e6769746875622e696f2f61727469636c65732f323031312f612d7375636365737366756c2d6769742d6272616e6368696e672d6d6f64656c2f6d61696e2d6272616e636865732e706e67"></p><h4 id="master"><a href="#master" class="headerlink" title="master"></a>master</h4><p>master 브랜치에 merge된 내역은 새로운 버전이 갱신되었다는 것을 의미한다. 즉 master 브랜치에 변경 내역이 생기면 최종 버전인 Tag를 통해 Production에 배포된다. </p><h4 id="develop"><a href="#develop" class="headerlink" title="develop"></a>develop</h4><p>hotfix를 제외한 모든 변경내역이 출발하는 지점이다. develop 브랜치의 코드가 안정화되고 배포할 준비가 되면 <code>master</code>를 통해 배포 버전의 태그를 단다.</p><h4 id="feature"><a href="#feature" class="headerlink" title="feature"></a>feature</h4><p><code>feature</code> 브랜치는 배포하려고 하는 기능을 개발하는 브랜치다. 기능을 개발하기 시작할 때는 언제 배포할 수 있을지 알 수 없다. 기능을 다 완성할 때까지 유지하고 있다가 다 완성되면 <code>develop</code> 브랜치로 병합한다. </p><ul><li>브랜치가 생성되는 대상 : develop</li><li>merge 대상: develop</li></ul><p><img src="https://camo.githubusercontent.com/c9cbf25c64dc0519860230cb98d098c3d069eda3/687474703a2f2f646f67666565742e6769746875622e696f2f61727469636c65732f323031312f612d7375636365737366756c2d6769742d6272616e6368696e672d6d6f64656c2f6d657267652d776974686f75742d66662e706e67"></p><h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p><code>release</code> 브랜치는 실제 배포할 상태가 된 경우에 생성하는 브랜치다.</p><ul><li>브랜치가 생성되는 대상 : develop</li><li>merge 대상: develop, master</li></ul><h4 id="hotfix"><a href="#hotfix" class="headerlink" title="hotfix"></a>hotfix</h4><p>미리 계획되지 않은 브랜치다. 기본적인 동작방식은 <code>release</code>와 비슷하다. 배포 이후에 생긴 치명적인 버그는 즉시 해결해야하기 때문에 문제가 생기면 <code>master</code> 브랜치에 만들어둔 태그<code>tag</code>로 부터 긴급수정을 위한 브랜치를 생성한다.</p><ul><li>브랜치가 생성되는 대상 : master</li><li>merge 대상 : develop, master</li></ul><p><img src="https://camo.githubusercontent.com/aee561ae78af58c9756814432473c8dab15dada7/687474703a2f2f646f67666565742e6769746875622e696f2f61727469636c65732f323031312f612d7375636365737366756c2d6769742d6272616e6368696e672d6d6f64656c2f686f746669782d6272616e636865732e706e67"></p><h2 id="주요-Commands"><a href="#주요-Commands" class="headerlink" title="주요 Commands"></a>주요 Commands</h2><h4 id="소스코드의-origin-저장소를-초기화하고-remote-서버와-처음으로-연결할-때"><a href="#소스코드의-origin-저장소를-초기화하고-remote-서버와-처음으로-연결할-때" class="headerlink" title="소스코드의 origin 저장소를 초기화하고 remote 서버와 처음으로 연결할 때"></a>소스코드의 origin 저장소를 초기화하고 remote 서버와 처음으로 연결할 때</h4><p>최초의 프로젝트(origin)는 로컬 저장소에서 시작될 것이다. 운영체제에 git을 설치하고 여러분의 프로젝트를 관리할 원격 저장소가 준비되었다고 가정했을때 아래와 같이 <code>git init</code> 명령을 통해 git 프로젝트로 초기화할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"# Hola"</span> &gt; README.md</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><h4 id="git-add-commit"><a href="#git-add-commit" class="headerlink" title="git add, commit"></a>git add, commit</h4><p>git add 명령어는 git flow의 첫 단계에 해당되며 인덱스에 새로운 파일이 생겼다는 것을 알리는 행위이다. 이 상태는 저장소에는 반영이 되지 않은 상태이며 git commit 명령을 통해 비로소 저장소에 변경내역이 반영된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add build.gradle <span class="comment"># 특정 파일에 대한 변경 내역을 알린다.</span></span><br><span class="line">$ git add . <span class="comment"># 모든 변경 내역을 알린다</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"이 버전의 변경 내역에 대한 설명"</span></span><br></pre></td></tr></table></figure><p>git add, commit은 아래와 같이 동시에 실행할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am <span class="string">"이 버전의 변경 내역에 대한 설명"</span></span><br></pre></td></tr></table></figure><h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><p>commit이 완료된 시점은 변경 내용이 로컬 저장소에 HEAD안에 머물고 있음을 의미한다. 우리는 변경 내역을 동료들도 확인할 수 있도록 remote 서버에 반영할 필요가 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">$ git push <span class="comment"># -u 옵션을 이용하면 다음 push때 이전 히스토리를 기억하고 반영한다.</span></span><br></pre></td></tr></table></figure><h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><p>git add, commit, push 하는 일련의 과정은 내 컴퓨터에서 일어난 변경내역을 관리하고, remote 서버에 반영하는 행위라면 <code>git pull</code>은 remote 서버의 가장 최근의 변경 내역을 내 컴퓨터로 가져오는 행위이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure><h4 id="새로운-기능을-위해-branch를-생성하는-방법"><a href="#새로운-기능을-위해-branch를-생성하는-방법" class="headerlink" title="새로운 기능을 위해 branch를 생성하는 방법"></a>새로운 기능을 위해 branch를 생성하는 방법</h4><p>git은 강력한 점은 효율적으로 분산된 환경은 제공한다는 것이다. 우리는 master branch가 아닌 더욱 안전하고 격리된 상태에서 새로운 기능을 추가할 수 있다. 새로운 branch를 이용해 개발을 진행하고 개발이 완료가 되면 나중에 master 로 돌아와 merge 하는 프로세스를 의미한다.</p><p>아래의 명령을 통해 <code>master branch</code>에서 <code>develop</code> 이라는 새로운 branch를 만들고 갈아탄다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b develop</span><br></pre></td></tr></table></figure><p>stage라는 특정 branch로 부터 새로운 branch를 만들고 싶다면,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b develop origin/stage</span><br></pre></td></tr></table></figure><p>아래와 같이 다시 master branch로 돌아올 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  stage</span><br><span class="line">  develop</span><br></pre></td></tr></table></figure><p>당신이 새롭게 만든 branch는 remote 서버에 전송하기 전까지는 동료들이 접근할 수가 없다. branch에 대한 검증이 완료되면 여러분은 Github에서 Pull Request를 전송할 수 있게된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin develop</span><br></pre></td></tr></table></figure><p>만약 branch를 여러명과 협업하고 있는 도중 push시에 remote 서버의 최신 내용을 로컬에 반영하지 않았다면 아래와 같이 remote 서버와 연결 후 <code>git pull</code>을 통해 merge 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream-to=origin/develop develop</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure><h4 id="원격-저장소의-기존-branch-확인-후-로컬에-가져오기"><a href="#원격-저장소의-기존-branch-확인-후-로컬에-가져오기" class="headerlink" title="원격 저장소의 기존 branch 확인 후 로컬에 가져오기"></a>원격 저장소의 기존 branch 확인 후 로컬에 가져오기</h4><p>원격 저장소의 브랜치 리스트를 조회한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r</span><br><span class="line">  origin/develop</span><br><span class="line">  origin/master</span><br><span class="line">  origin/stage</span><br></pre></td></tr></table></figure><p>로컬, 원격 저장소의 브랜치 리스트를 모두 조회한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -a</span><br><span class="line">  master</span><br><span class="line">  stage</span><br><span class="line">* develop</span><br><span class="line">  remotes/origin/develop</span><br><span class="line">  remotes/origin/master</span><br><span class="line">  remotes/origin/stage</span><br></pre></td></tr></table></figure><p>원격 저장소의 <code>develop</code>이라는 branch를 로컬 저장소에 가져오고 싶다면</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -t origin/develop</span><br><span class="line">Branch develop <span class="built_in">set</span> up to track remote branch develop from origin.</span><br><span class="line">Switched to a new branch <span class="string">'develop'</span></span><br><span class="line">$ git branch</span><br><span class="line">* develop</span><br><span class="line">  master</span><br><span class="line">  stage</span><br></pre></td></tr></table></figure><p><code>fatal: Cannot update paths and switch to branch &#39;develop&#39; at the same time.</code>이라는 에러가 발생한다면 아래와 같이 원격 저장소를 최신 상태를 로컬 저장소에 갱신한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote update</span><br></pre></td></tr></table></figure><h4 id="원격-저장소-참고하기"><a href="#원격-저장소-참고하기" class="headerlink" title="원격 저장소 참고하기"></a>원격 저장소 참고하기</h4><p>어떤 경우에는 수정 내역을 원격 저장소에 push 하지는 않지만 해당 branch를 참고하기 위해 로컬에 받아서 테스트 해보고 싶은 경우도 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>아무런 옵션없이 원격 저장소의 branch를 checkout 하면 <code>detached HEAD</code> 상태로 소스를 보고 변경 해볼 수도 있지만 변경 사항들은 commit, push 할 수 없으며 다른 branch로 checkout하면 사라진다.</p><h4 id="개발한-내역을-master-branch에-merge하는-과정"><a href="#개발한-내역을-master-branch에-merge하는-과정" class="headerlink" title="개발한 내역을 master branch에 merge하는 과정"></a>개발한 내역을 master branch에 merge하는 과정</h4><p>변경 내역을 master에 merge하는 과정은 아주 중요한 과정이다. 먼저 아래와 같이 remote 서버의 최신 내역을 자신의 로컬 저장소에 갱신하는 습관을 들이는게 좋다. <code>git pull</code>을 통해 remote 서버의 변경 내용이 로컬 저장소에 fetch, merge 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure><p>다른 branch에 있는 변경 내용을 현재의 branch(master)에 병합하려면 아래의 명령을 실행하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge some_function</span><br></pre></td></tr></table></figure><p>첫번째 명령이든 두번째 명령이든, git은 자동으로 변경 내용을 merge하려고 한다. 문제는, 항상 성공하는 게 아니라 가끔 충돌(conflicts)이 일어나기도 한다는 점이다. 필요하다면 개발이 완료되어 merge된 branch는 아래와 같이 삭제한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D some_function</span><br></pre></td></tr></table></figure><h4 id="merge-conflict가-발생한다면"><a href="#merge-conflict가-발생한다면" class="headerlink" title="merge conflict가 발생한다면?"></a>merge conflict가 발생한다면?</h4><p>개발이 완료되면 branch를 merge하는 과정에서 충분히 conflic가 발생할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> foo.java Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD <span class="comment">// conflict 가 발생한 범위의 시작</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">=======</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; <span class="number">55737474728739293729138123737392371293123737</span>e <span class="comment">// 모든 commit은 유일한 커밋 ID를 가진다</span></span><br></pre></td></tr></table></figure><p>conflict 부분을 직접 수정해서 다시 commit하는 전략을 취한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -a -m &apos;Conclude merge&apos;</span><br></pre></td></tr></table></figure><blockquote><p>merge 전에 변경 내용을 확인하는 방법</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status -sb</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff some_function master</span><br></pre></td></tr></table></figure><p>Merge 중에 발생한 충돌을 해결하는 방법은 몇 가지가 있다. 첫 번째는 그저 이 상황을 벗어나는 것이다. 예상하고 있던 일도 아니고 지금 당장 처리할 일도 아니라면 git merge –abort 명령으로 간단히 Merge 하기 전으로 되돌린다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --abort</span><br></pre></td></tr></table></figure><h4 id="로컬-변경-내용을-되돌리기"><a href="#로컬-변경-내용을-되돌리기" class="headerlink" title="로컬 변경 내용을 되돌리기"></a>로컬 변경 내용을 되돌리기</h4><p>로컬에서 발생한 변경내역을 되돌리는 일은 빈번히 발생할 수 있다. <code>git status</code> 명령을 통해 현재 branch의 상태와 이후의 상태 변경을 위한 Commands를 확인할 수 도 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   Git/git-commands.md</span><br></pre></td></tr></table></figure><p>위의 상태는 소스 코드를 변경하고 <code>git add</code>를 통해 인덱스에 변경 내역을 알리기전의 상태이다. 아래와 같이 변경 내역을 되돌릴 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure><p><code>git add</code> 이후에 변경 내역을 되돌리고자 한다면,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure><p>이미 commit된 내역을 과거로 되돌리고 싶은 경우가 있을 것이다! 먼저 commit history를 살펴보자</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">8ed5068 (HEAD -&gt; unit-test, origin/unit-test) Update README.md</span><br><span class="line">dfff29e (origin/master, master) Merge pull request <span class="comment">#8 from stunstunstun/unit-test</span></span><br><span class="line">eec3b7a Integration runner is completed</span><br><span class="line">0a087cf <span class="comment">#2 Specification list, create, get, update</span></span><br><span class="line">a603da7 Inialize unit <span class="built_in">test</span> environments</span><br><span class="line">55c3e73 (origin/stage, stage) Update README.md</span><br><span class="line">c354d50 Merge pull request <span class="comment">#7 from stunstunstun/api-test</span></span><br><span class="line">2e6b522 (origin/api-test) <span class="comment">#3 Add eslint to devDendencies</span></span><br><span class="line">5e35c21 <span class="comment">#3 Add eslint to devDendencies</span></span><br><span class="line">f9bbe2a <span class="comment">#3 version fixed</span></span><br></pre></td></tr></table></figure><p><code>a603da7</code> 이후의 모든 내역을 삭제하고 돌아가고 싶다면 <code>--hard</code> 옵션과 함께 <code>reset</code> 명령을 이용하자</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard a603da7</span><br></pre></td></tr></table></figure><p>특정 commit의 변경 내역을 취소하는 새로운 commit을 발행해야하는 경우도 있다. 이미 commit, push 한 경우 드물게 사용하는 것을 권장한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git revert &lt;commit_id&gt;</span><br></pre></td></tr></table></figure><h4 id="최종-버전-릴리즈하기"><a href="#최종-버전-릴리즈하기" class="headerlink" title="최종 버전 릴리즈하기"></a>최종 버전 릴리즈하기</h4><p>애플리케이션의 빌드 및 테스트가 완료되어 새 버전을 릴리즈한다면 읽기 전용 상태의 tag 버전를 생성하는 것이 좋다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag 1.0.0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>생성한 tag 버전은 아래와 같이 remote 서버에 최종적으로 반영한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin 0.1.0</span><br></pre></td></tr></table></figure><h4 id="gh-pages-브랜치를-통해-정적-페이지-관리하기"><a href="#gh-pages-브랜치를-통해-정적-페이지-관리하기" class="headerlink" title="gh-pages 브랜치를 통해 정적 페이지 관리하기"></a><code>gh-pages</code> 브랜치를 통해 정적 페이지 관리하기</h4><p>GitHub Repository를 운영하다 보면 비어 있는 브랜치를 생성해야할 때가 있다. REST API를 제공하는 프로젝트에서 자동으로 생성되는 API Documentation를 정적 페이지를 통해 제공하는 경우가 좋은 예이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /path/to/repo-name</span><br><span class="line">$ git symbolic-ref HEAD refs/heads/gh-pages</span><br><span class="line">$ rm .git/index</span><br><span class="line">$ git clean -fdx</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"My GitHub Page"</span> &gt; index.html</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -a -m <span class="string">"First pages commit"</span></span><br><span class="line">$ git push origin gh-pages</span><br></pre></td></tr></table></figure><p><code>git checkout -b gh-pages</code>를 통해 브랜치를 생성할 수도 있겠지만 이는 master 브랜치의 과거내역을 가지고 있음을 의미한다. 위와 같은 방법을 참고하면 <code>root branch</code>로 부터 과거 내역이 깔끔히 빈 새로운 브랜치를 생성할 수 있다.</p><p><code>gh-pages</code> 브랜치가 생성되면 아래의 경로를 통해서 정적 페이지에 접속할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://&lt;username&gt;.github.io/&lt;projectname&gt;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://gist.github.com/ramnathv/2227408" target="_blank" rel="external">https://gist.github.com/ramnathv/2227408</a></p></blockquote><h2 id="remote-branch-참조와-업데이트"><a href="#remote-branch-참조와-업데이트" class="headerlink" title="remote branch 참조와 업데이트"></a>remote branch 참조와 업데이트</h2><h4 id="remote-서버를-변경해야-할-때"><a href="#remote-서버를-변경해야-할-때" class="headerlink" title="remote 서버를 변경해야 할 때"></a>remote 서버를 변경해야 할 때</h4><p>git 저장소의 주소가 변경되는 등의 이슈로 인해 remote 서버를 변경해야 한다면 아래의 명령을 참고한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https://wjdsupj@github.com/wjdsupj/awesome-wiki (fetch)</span><br><span class="line">origin  https://wjdsupj@github.com/wjdsupj/awesome-wiki (push)</span><br><span class="line">$ git remote <span class="built_in">set</span>-url origin https://stunstunstun@github.com/stunstunstun/awesome-wiki</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  https://stunstunstun@github.com/stunstunstun/awesome-wiki (fetch)</span><br><span class="line">origin  https://stunstunstun@github.com/stunstunstun/awesome-wiki (push)</span><br></pre></td></tr></table></figure><h4 id="remote-branch-상태-보기"><a href="#remote-branch-상태-보기" class="headerlink" title="remote branch 상태 보기"></a>remote branch 상태 보기</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br></pre></td></tr></table></figure><h4 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h4><p>로컬 저장소를 리모트 저장소와 동기화하고, 자동적으로 더이상 유효하지 않은 branch 참조를 제거한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin --prune</span><br></pre></td></tr></table></figure><h4 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote update --prune  <span class="comment"># Only prune, don't fetch</span></span><br></pre></td></tr></table></figure><h2 id="GitHub의-오픈소스에-기여하기"><a href="#GitHub의-오픈소스에-기여하기" class="headerlink" title="GitHub의 오픈소스에 기여하기"></a>GitHub의 오픈소스에 기여하기</h2><p>GitHub에는 다양한 오픈소스들이 존재하고 경우에 따라서는 직접 참여해 관심있는 오픈소스에 기여할 수도 있다. 이를 위해서는 먼저 오픈소스의 Repository를 아래의 Fork 버튼을 통해 자신의 계정에 추가해야 한다.</p><p><img src="https://help.github.com/assets/images/help/repository/fork_button.jpg"></p><h4 id="Fork한-Repository-clone-하기"><a href="#Fork한-Repository-clone-하기" class="headerlink" title="Fork한 Repository clone 하기"></a>Fork한 Repository clone 하기</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/YOUR-USERNAME/jest</span><br></pre></td></tr></table></figure><h4 id="Fork를-위한-remote-설정하기"><a href="#Fork를-위한-remote-설정하기" class="headerlink" title="Fork를 위한 remote 설정하기"></a>Fork를 위한 remote 설정하기</h4><p>Fork한 Repository를 앞으로 자신의 Repository와 동기화하기 위해서는 아래와 같이 <code>upstream</code> remote를 추가한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">originhttps://github.com/stunstunstun/jest (fetch)</span><br><span class="line">originhttps://github.com/stunstunstun/jest (push)</span><br><span class="line">$ git remote add upstream https://github.com/facebook/jest</span><br><span class="line">$ git remote -v</span><br><span class="line">originhttps://github.com/stunstunstun/jest (fetch)</span><br><span class="line">originhttps://github.com/stunstunstun/jest (push)</span><br><span class="line">upstreamhttps://github.com/facebook/jest (fetch)</span><br><span class="line">upstreamhttps://github.com/facebook/jest (push)</span><br></pre></td></tr></table></figure><h4 id="Fork와-동기화하기"><a href="#Fork와-동기화하기" class="headerlink" title="Fork와 동기화하기"></a>Fork와 동기화하기</h4><p>아래와 같은 명령순으로 원본 Repository에서 merge할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch upstream</span><br><span class="line">remote: Counting objects: 63, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (12/12), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 63 (delta 46), reused 51 (delta 45), pack-reused 6</span><br><span class="line">Unpacking objects: 100% (63/63), <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/facebook/jest</span><br><span class="line"> * [new branch]        ericnakagawa-add-romanian -&gt; upstream/ericnakagawa-add-romanian</span><br><span class="line"> * [new branch]        gh-pages                  -&gt; upstream/gh-pages</span><br><span class="line"> * [new branch]        master                    -&gt; upstream/master</span><br><span class="line">$ git checkout master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">$ git merge upstream/master</span><br><span class="line">Updating 5a378915..4f685d88</span><br><span class="line">Fast-forward</span><br><span class="line"> CHANGELOG.md                                                   |   34 ++-</span><br><span class="line"> docs/GlobalAPI.md                                              |   14 +-</span><br><span class="line"> examples/react-native/package.json                             |    2 +-</span><br><span class="line"> integration_tests/__tests__/__snapshots__/globals.test.js.snap |   17 ++</span><br><span class="line"> integration_tests/__tests__/globals.test.js                    |   18 ++</span><br><span class="line"> integration_tests/__tests__/jasmine_async.test.js              |    6 +</span><br><span class="line"> integration_tests/jasmine_async/__tests__/generator.test.js    |   25 ++</span><br><span class="line"> package.json                                                   |   10 +-</span><br><span class="line"> packages/jest-jasmine2/package.json                            |    2 +</span><br><span class="line"> packages/jest-jasmine2/src/jasmine/Suite.js                    |   29 +-</span><br><span class="line"> packages/jest-jasmine2/src/jasmine_async.js                    |    9 +-</span><br><span class="line"> scripts/browserBuild.js                                        |    4 +-</span><br><span class="line"> types/Circus.js                                                |    2 +-</span><br><span class="line"> yarn.lock                                                      | 1126 ++++++++++++++++++++++++++++++++++++++++++++++++++---------------------</span><br><span class="line"> 14 files changed, 954 insertions(+), 344 deletions(-)</span><br><span class="line"> create mode 100644 integration_tests/jasmine_async/__tests__/generator.test.js</span><br></pre></td></tr></table></figure><h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>이 명령을 통해서는 로컬에서 참고하는 다양한 옵션을 설정한다. 예를 들면 Git Repository에서 참조하는 계정을 아래와 같이 설정할 수 있다.</p><p><code>global</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;stunstunstun&quot;</span><br><span class="line">$ git config --global user.email &quot;wjdsupj@gmail.com&quot;</span><br></pre></td></tr></table></figure><p><code>local</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --local user.name &quot;stunstunstun&quot;</span><br><span class="line">$ git config --local user.email &quot;wjdsupj@gmail.com&quot;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://git-scm.com/docs/git-config" target="_blank" rel="external">https://git-scm.com/docs/git-config</a></p></blockquote><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>지금까지 Git Flow를 통해 기본적인 명령들을 살펴보았다. Git에 대해 더 알고 싶다면 아래의 자료를 참고하면 많은 도움이 될 것이다!</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://git-scm.com/docs/" target="_blank" rel="external">Git Docs</a></li><li><a href="https://github.com/k88hudson/git-flight-rules" target="_blank" rel="external">Git Flight Rules</a></li><li><a href="https://www.youtube.com/watch?v=MJUJ4wbFm_A" target="_blank" rel="external">An Introduction Git and GitHub</a></li><li><a href="https://try.github.io" target="_blank" rel="external">Git Basic Tutorials</a></li><li><a href="http://guides.github.com" target="_blank" rel="external">Git Guides</a></li><li><a href="https://github.com/mingrammer/git-tips" target="_blank" rel="external">Git Tips</a></li><li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="external">Pro Git Book 2nd</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Git Flow&lt;/code&gt;는 git을 통해 효율적으로 프로젝트를 관리하고 배포하기 위한 전략이다. 기본적으로 Git은 로컬 저장소와 원격 저장소간의 동기화를 위해 아래와 같은 과정을 거친다.&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="https://www.holaxprogramming.com/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>React 최적화 - 가상 DOM에 대하여</title>
    <link href="https://www.holaxprogramming.com/2018/04/15/react-optimizing-virtual-dom-explained/"/>
    <id>https://www.holaxprogramming.com/2018/04/15/react-optimizing-virtual-dom-explained/</id>
    <published>2018-04-15T04:42:00.000Z</published>
    <updated>2018-05-29T20:15:35.687Z</updated>
    
    <content type="html"><![CDATA[<ul><li>원문: <a href="https://evilmartians.com/chronicles/optimizing-react-virtual-dom-explained" target="_blank" rel="external">https://evilmartians.com/chronicles/optimizing-react-virtual-dom-explained</a></li></ul><p>이 글을 통해 React 가상 DOM에 대해 알아본 후 배운 것을 활용해 여러분 앱 속도를 높여보세요. React 프레임워크 내부를 철저하게 초보 친화적인 시각에서 소개하는 이 글을 통해 JSX를 명확하게 정의내려 보고, React가 어떻게 렌더링을 결정내리는지 살펴보며, 병목지점을 찾아내는 방법에 대해 설명드리고 흔히 발생하는 실수를 피할 수 있는 몇가지 팁을 공유해 보도록 하겠습니다.</p><p>React가 지속적으로 프론트엔드 세상을 쥐락펴락하면서 인기가 사그라들 기미가 보이지 않는 이유 중 하나는 바로 러닝 커브가 그닥 높지 않다는데 있습니다. <a href="https://reactjs.org/docs/introducing-jsx.html" target="_blank" rel="external">JSX</a>와 바로 그 “<a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="external">State</a> vs. <a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="external">Props</a>“ 개념으로 여러분 머리를 채우셨다면, 이제 React를 사용하셔도 됩니다.</p><p>그러나 진정으로 React에 정통하려면 <em>React적으로 사고할</em> 필요가 있습니다. 이 글은 여러분이 그렇게 할 수 있도록 도와주고자 쓴 글입니다. <a href="https://ebaymag.com/" target="_blank" rel="external">저희 프로젝트</a>에서 사용할 요량으로 만든 React 테이블을 잠시 봐주세요.</p><p>(React가 어떻게 동작하는지 이미 잘 알고 계시다면 “<a href="https://evilmartians.com/chronicles/optimizing-react-virtual-dom-explained#fixing-things-mountingunmounting" target="_blank" rel="external">고치기</a>“ 부분으로 바로 넘어가셔도 됩니다.)</p><p><img src="https://cdn.evilmartians.com/front/posts/optimizing-react-virtual-dom-explained/ebay_table-4023632.png" alt=""></p><p>시시각각 변하면서 필터링 기능이 탑재된 수백줄의 테이블 행이 들어있으므로, 사용자에게 부드러운 경험을 선사하고 싶다면 프레임워크의 내부 구조를 이해하는 것이 매우 중요했습니다.</p><p>그리고 뭔가 일이 잘못되어가고 있다는 것도 자연스레 느끼게 될 수밖에 없습니다. 입력 필드 반응이 느려지고, 체크박스를 눌렀는데 몇 초 후에 체크표시가 나타나면서 모달 창은 나오기까지 매우 힘든 시간을 보내고 있네요.</p><p>이런 종류의 문제를 해결하기 위해서는 여러분에 의해 React 컴포넌트가 정의되고 페이지 상에 렌더링(그리고 업데이트) 되기까지의 그 모든 여정에 대해 먼저 알아봐야 합니다. 안전벨트 매세요!</p><h2 id="JSX의-배후"><a href="#JSX의-배후" class="headerlink" title="JSX의 배후"></a>JSX의 배후</h2><p>컴포넌트를 만들려고 하면 React 개발자들이 여러분에게 HTML과 JavaScript가 뒤섞인 JSX로 코드를 작성하라고 다그칠 겁니다. 그러나 저러나 브라우저는 JSX 문법이 뭔지도 모릅니다. 브라우저는 오직 일반 JavaScript만 이해하기 때문에 JSX는 이에 맞게 형태를 바꿀 필요가 있습니다. (“컴파일레이션(compilation)”이 조금 더 적합한 용어 같기는 한데, 아무튼 프론트엔드 업계에서는 “트랜스파일링”이라는 과정으로 알려져 있습니다.) 다음은 예시 JSX 코드 안의 <code>div</code>는 클래스명도 있고 안에 컨텐츠도 들어갑니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">'cn'</span>&gt;</span></span><br><span class="line">  Content!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>위와 동일한 내용의 코드를 “정석” Javascript로 작성해보면 그저 인자 몇가지를 받는 함수 호출이 되어버립니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125;,</span><br><span class="line">  <span class="string">'Content!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>인자를 조금 더 자세하게 들여다보도록 합시다. 첫번째 인자는 <em>요소의 타입</em>입니다. HTML 태그가 오게 된다면 태그명이 문자열로 들어갑니다. 두번째 인자는 <em>요소의 모든 어트리뷰트</em>가 담긴 객체입니다. 만약 어트리뷰트를 넣을 필요가 없다면 빈 객체가 들어가게 됩니다. 그 다음에 오는 인자는 모두 <em>요소의 자식</em>입니다. 요소 안에 들어가는 텍스트 역시 자식으로 칩니다. 그래서 ‘Content!’ 문자열이 함수 호출될 때 세번째 인자 자리에 들어가는 겁니다.</p><p>자식이 더 있다면 어떤 모양이 될지 벌써 상상가능하네요.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">'cn'</span>&gt;</span></span><br><span class="line">  Content 1!</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  Content 2!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125;,</span><br><span class="line">  <span class="string">'Content 1!'</span>,              <span class="comment">// 첫째</span></span><br><span class="line">  React.createElement(<span class="string">'br'</span>), <span class="comment">// 둘째</span></span><br><span class="line">  <span class="string">'Content 2!'</span>               <span class="comment">// 셋째</span></span><br></pre></td></tr></table></figure><p>함수 호출 인자로 총 다섯개가 들어가네요. 요소의 타입, 어트리뷰트 객체, 그리고 자식 세명입니다. 자식 중 하나 역시 React와 연관된 HTML 태그이기 때문에 이 역시 함수 호출이라 여겨지게 됩니다.</p><p>여태까지 두가지 타입의 자식을 다뤄보았습니다. 하나는 일반 <code>String</code> 자식이고, 다른 하나는 <code>React.createElement</code> 재호출하는 자식입니다. 하지만 이 두가지 말고도 다른 값의 인자가 올 수도 있습니다.</p><ul><li>원시값 <code>false</code>, <code>null</code>, <code>undefined</code>, `true</li><li>배열</li><li>React 컴포넌트</li></ul><p>배열도 들어갈 수 있는데, 이는 자식들을 그룹으로 묶어서 하나의 인자로 전달하기 위함입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125;,</span><br><span class="line">  [<span class="string">'Content 1!'</span>, React.createElement(<span class="string">'br'</span>), <span class="string">'Content 2!'</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>그러나 React의 진정한 힘은 HTML 명세에 기재되어 있는 태그로부터 나오는 것이 아니라, 당연히 사용자가 직접 만들어낸 컴포넌트에서 나옵니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Table(&#123; rows &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">      &#123;rows.map(row =&gt; (</span><br><span class="line">        &lt;tr key=&#123;row.id&#125;&gt;</span><br><span class="line">          &lt;td&gt;&#123;row.title&#125;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>컴포넌트 덕분에 템플릿을 재사용 가능한 덩어리로 더 분해시킬 수 있습니다. 위의 “함수형” 컴포넌트 예시에서는 테이블 행 데이터가 담긴 객체로 이루어진 배열을 받은 후, <code>React.createElement</code> 함수 호출 하나를 반환합니다. 이 함수 호출을 통해 행을 자식으로 가지는 <code>&lt;table&gt;</code> 요소를 만들어 냅니다.</p><p>이제 페이지 레이아웃에 다음과 같은 컴포넌트를 놓아둘 때마다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Table rows=&#123;rows&#125; /&gt;</span><br></pre></td></tr></table></figure><p>브라우저가 보기에는 우리는 다음과 같은 코드를 쓴겁니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(Table, &#123; rows: rows &#125;);</span><br></pre></td></tr></table></figure><p>이번에는 첫번째 인자가 HTML 요소를 나타내는 <code>String</code>이 아니라 아까 컴포넌트를 만들 때 <em>정의 내린 함수에 대한 참조</em>임에 유의해 주세요. 컴포넌트 어트리뷰트는 이제 우리의 <code>props</code>가 되었습니다.</p><h2 id="페이지에-컴포넌트-넣기"><a href="#페이지에-컴포넌트-넣기" class="headerlink" title="페이지에 컴포넌트 넣기"></a>페이지에 컴포넌트 넣기</h2><p>자, 이제 순수 자바스크립트로 JSX 컴포넌트를 모두 트랜스파일 해보니 인자가 담긴 함수 호출 한다발이 우리 앞에 떨어졌네요. 이 함수 호출 중 하나는 이제 다른 함수를 또 호출하고, 그 와중에 옆에는 대기 중인 함수 호출들이 있고… 이 모든 함수 호출을 어떻게 웹 페이지를 이루는 DOM 요소로 바꿀 수 있는 걸까요?</p><p>그 목표를 이루기 위해 우리에게는 <code>ReactDOM</code> 라이브러리와 여기에 같이 딸려 오는 <code>render</code> 메소드가 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Table(&#123; rows &#125;) &#123; /* ... */ &#125; // 컴포넌트 정의</span><br><span class="line"></span><br><span class="line">// 컴포넌트 렌더링</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(Table, &#123; rows: rows &#125;), // &quot;creating&quot; a component</span><br><span class="line">  document.getElementById(&apos;#root&apos;) // inserting it on a page</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>ReactDOM.render</code>가 호출되면 <code>Rect.createElement</code> 역시 최종적으로 호출이 되고 그 결과 다음과 같은 객체를 반환합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 필드가 더 많기는 한데, 아래가 우리에게 가장 중요한 것들입니다</span><br><span class="line">&#123;</span><br><span class="line">  type: Table,</span><br><span class="line">  props: &#123;</span><br><span class="line">    rows: rows</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>여기서 반환된 객체가 React 세계의 가상 DOM을 구성하는 것들입니다.</strong></p><p>앞으로 렌더링이 일어나게 될 때마다 가상 DOM은 비교를 거쳐 (<em>가상</em>과 대비되는) <em>실제</em> DOM으로 마침내 변환이 됩니다.</p><p>다른 예시를 들어보겠습니다. 이번에는 클래스 어트리뷰트와 자식을 몇명 데리고 있는 <code>div</code> 요소입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125;,</span><br><span class="line">  <span class="string">'Content 1!'</span>,</span><br><span class="line">  <span class="string">'Content 2!'</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이는 다음과 같이 변환됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &apos;div&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: &apos;cn&apos;,</span><br><span class="line">    children: [</span><br><span class="line">      &apos;Content 1!&apos;,</span><br><span class="line">      &apos;Content 2!&apos;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>React.createElement</code> 함수에서는 서로 떨어져있던 인자들이 <code>props</code> 안의 <code>children</code> 키 안에 같이 자리를 잡게 된 것에 유의하세요. 그러니까 요소의 자식이 배열 형식으로 들어갔던, 인자를 나열하는 형식으로 들어갔던 <em>상관이 없는</em> 거네요. 어찌되었든 결과로 나온 가상 DOM 객체에는 다같이 묶여 들어가게 되니까요.</p><p>더 신기한 것은 JSX 코드에 직접 props로 자식을 추가할수도 있다는 겁니다. 그래도 결과는 여전히 똑같습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">'cn'</span> <span class="attr">children</span>=<span class="string">&#123;[</span>'<span class="attr">Content</span> <span class="attr">1</span>!', '<span class="attr">Content</span> <span class="attr">2</span>!']&#125; /&gt;</span></span><br></pre></td></tr></table></figure><p>가상 DOM 객체가 만들어지면 <code>ReactDOM.render</code> 메소드가 이 객체를 DOM 노드로 변환하게 됩니다. 브라우저는 DOM 노드를 다음과 같은 규칙을 따라 화면에 표시합니다.</p><ul><li>만약 <code>type</code> 어트리뷰트가 태그명을 <em>문자열</em>로 가지고 있다면, 태그를 만든 후 <code>props</code> 안에 모든 어트리뷰트를 넣습니다.</li><li>만약 <code>type</code> 안에 함수나 클래스가 들어가 있다면, 호출 후에 결과에 따라 재귀적으로 이 과정을 반복합니다.</li><li>만약 <code>props</code> 안에 <code>children</code>이 하나라도 있다면, 이 과정을 각 자식마다 개별적으로 진행하고 그 결과를 부모 DOM 노드 안에 넣습니다.</li></ul><p>그 결과로 다음과 같은 HTML을 얻게 됩니다. (예시로 든 테이블의 경우입니다.)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="DOM-재건하기"><a href="#DOM-재건하기" class="headerlink" title="DOM 재건하기"></a>DOM 재건하기</h2><p>제목의 “재” 글자에 주의하세요! React가 진정한 마법을 부리는 시점은 아무것도 바꾸지 않으면서 페이지를 <em>업데이트</em>하고 싶을 때입니다. 이를 위한 방법이 몇가지 있습니다. 가장 간단한 방법부터 살펴보죠. 동일한 노드에 다시 한번 <code>ReactDOM.render</code>를 호출하는 겁니다. (실제로는 <code>render</code>는 거의 루트 요소에서만 한번 호출이 되고 그 이후에 업데이트가 발생하면 <code>state</code>에 적용이 됩니다.)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 두번째 호출</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(Table, &#123; <span class="attr">rows</span>: rows &#125;),</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'#root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>두번째 호출때는 우리가 이미 본 첫번째와 다르게 동작합니다. 밑바닥에서부터 DOM 노드를 모두 만들어서 페이지에 올려놓기 보다는, React의 <a href="https://reactjs.org/docs/reconciliation.html" target="_blank" rel="external">reconciliation</a>(또는 “diffing”) 알고리즘에 의해 노드 트리의 어느 부분이 갱신되어야 하는지, 그리고 어떤 부분은 손대지 말아야 하는지 결정이 내려집니다.</p><p>자, 그럼 이 알고리즘은 어떻게 돌아가는 걸까요? 간단한 시나리오가 몇가지 있는데  <em>이를 이해하고 넘어가면</em> 최적화에 매우 많은 도움이 될듯 합니다. 이제부터는 React 가상 DOM에서 노드를 표현하는 역할을 하는 객체를 살펴볼 겁니다.</p><ul><li>시나리오 1: <code>type</code>이 문자열이고, <code>type</code>은 모든 호출에서 동일하게 유지. <code>props</code> 역시 변경없음.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 업데이트 전</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 업데이트 후</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p>가장 간단한 경우네요. DOM은 동일하게 유지됩니다.</p><ul><li>시나리오 2: <code>type</code>은 여전히 문자열이나 <code>props</code>가 달라짐.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 업데이트 전:</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 업데이트 후:</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cnn'</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p><code>type</code>이 여전히 HTML <em>요소</em>를 가르키고 있으므로, React는 DOM 트리에서 노드 제거 없이 표준 DOM API 호출을 통해 프로퍼티를 바꾸는 방법을 알고 있습니다.</p><ul><li>시나리오 3: <code>type</code>이 다른 <code>String</code>으로 바뀜, 혹은 <code>String</code>에서 컴포넌트로 변경됨.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 업데이트 전:</span><br><span class="line">&#123; type: &apos;div&apos;, props: &#123; className: &apos;cn&apos; &#125; &#125;</span><br><span class="line"></span><br><span class="line">// 업데이트 후:</span><br><span class="line">&#123; type: &apos;span&apos;, props: &#123; className: &apos;cn&apos; &#125; &#125;</span><br></pre></td></tr></table></figure><p>이제 요소 타입이 달라졌다는 것을 React가 알게 되었기 때문에, 노드를 업데이트 하려는 시도조차 하지 않을 겁니다. 예전 요소는 <strong>모든 자식과 함께</strong> 제거(<em>unmounted</em>)가 됩니다. 그렇기 때문에 완전히 다른 요소로 DOM 트리 저 높은 곳의 노드를 갈아 끼우는 일은 치루는 데 비용이 꽤 들어갈 수 있습니다. 다행이게도 실제 업무 중엔 아주 드물게 일어나는 케이스에 속합니다.</p><ul><li>시나리오 4: <code>type</code>이 컴포넌트일 때.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 업데이트 전:</span><br><span class="line">&#123; type: Table, props: &#123; rows: rows &#125; &#125;</span><br><span class="line"></span><br><span class="line">// 업데이트 후:</span><br><span class="line">&#123; type: Table, props: &#123; rows: rows &#125; &#125;</span><br></pre></td></tr></table></figure><p><strong>“그런데 바뀐게 없잖아요!”라고 말하실 것 같은데, 틀린 말입니다.</strong></p><p>만약 <code>type</code>에 함수나 클래스의 참조(즉, 여러분이 만든 일반 React 컴포넌트)가 들어가있고, 트리 reconciliation 과정이 시작되었다면, React는 언제나 컴포넌트 <em>내부</em>를 조사해서 <code>render</code>로 반환된 값이 바뀌지 않았나 (일종의 부수 효과 예방 차원에서) 확인하려 들겁니다. 확인이 끝나면 흘려보내고 트리 구조상 하위에 위치한 컴포넌트도 모두 확인합니다. 네, 이 과정에는 복잡한 렌더링도 포함되어 있는데 이 렌더링 자체도 비용이 많이 들어갈 가능성이 있습니다. (컴포넌트의 <code>render</code> 메소드(클래스 컴포넌트에서만 이 메소드가 직접적으로 정의됩니다)는 <code>ReactDOM.render</code> 메소드와 같은 것이 아님을 알아두세요. React 세계에서 “render”라는 단어는 사실 조금 과도하게 사용되고 있습니다.)</p><h2 id="자식-돌보기"><a href="#자식-돌보기" class="headerlink" title="자식 돌보기"></a>자식 돌보기</h2><p>위에서 설명한 네가지 시나리오 말고도, 요소의 자식이 하나 이상일 때 React의 행동은 어떤지도 알아봐야 합니다. 다음과 같은 요소가 있다고 해봅시다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">      &#123; type: &apos;div&apos; &#125;,</span><br><span class="line">      &#123; type: &apos;span&apos; &#125;,</span><br><span class="line">      &#123; type: &apos;br&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>그리고 요소에 딸린 자식들을 다음과 같이 섞어보도록 하겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">    &#123; type: &apos;span&apos; &#125;,</span><br><span class="line">    &#123; type: &apos;div&apos; &#125;,</span><br><span class="line">    &#123; type: &apos;br&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>이제 무슨 일이 일어나게 될까요?</p><p>“diff 비교” 과정이 진행되고 있는 와중에 React가<code>props.children</code>에 배열이 <em>하나라도</em> 들어있는 것을 보게 된다면, 그때부터 React는 배열 안에 들어있는 요소를 전에 본 것과 비교하기 시작합니다. 배열 요소는 순서대로 비교하는데, 인덱스 0에 위치한 요소끼리, 그리고 1에 위치한 것끼리 비교하는 식입니다. 비교되는 각 쌍마다 React에서는 위에서 설명한 규칙을 적용해 봅니다. 우리의 경우 <code>div</code>가 <code>span</code>이 된 것 같으므로 <em>3번 시나리오</em>가 적용이 되겠네요. 아주 효율적이지 못한 케이스입니다. 테이블 행이 1000개 있는데 여기서 첫번째 행을 제거한다고 생각해 보세요. React가 나머지 999개의 자식을 “업데이트”해야 하는 상황이 옵니다. 인덱스가 같은 요소끼리 비교하게 된다면 같은 내용을 가지는 요소가 하나도 없을 것이기 때문입니다.</p><p>다행이게도 이런 문제를 해결하기 위한 해결책이 React 안에 내장되어 있습니다. 만약 요소가 <code>key</code> 프로퍼티를 가지고 있으면 인덱스가 아니라 <code>key</code> 프로퍼티가 같은 것들끼리 비교가 진행됩니다. <code>key</code> 값이 유일한 이상 React는 이 요소들을 DOM 트리에서 제거 후에 다시 올려 놓는 과정 <em>없이</em> 그냥 옮기기만 합니다. (React에서 <em>마운팅/언마운팅</em>이라고 불리는 과정입니다.)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">props: &#123;</span><br><span class="line">  children: [ // 이제 React에서는 key값을 참조하지, 인덱스를 보지는 않습니다</span><br><span class="line">    &#123; type: &apos;div&apos;, key: &apos;div&apos; &#125;,</span><br><span class="line">    &#123; type: &apos;span&apos;, key: &apos;span&apos; &#125;,</span><br><span class="line">    &#123; type: &apos;br&apos;, key: &apos;bt&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><h2 id="상태가-바뀐다면"><a href="#상태가-바뀐다면" class="headerlink" title="상태가 바뀐다면"></a>상태가 바뀐다면</h2><p>여태까지는 React 철학 중 살펴본 부분은 <code>props</code> 뿐이고 <code>state</code>는 무시했습니다. 아래는 “상태를 가지는” 컴포넌트의 간단 예시입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  increment = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    counter: <span class="keyword">this</span>.state.counter + <span class="number">1</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  render = <span class="function"><span class="params">()</span> =&gt;</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.increment&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;'Counter: ' + this.state.counter&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자, 이제 상태 객체 안에 <code>counter</code> 키가 들어가게 되었습니다. 버튼을 클릭하면 값이 증가하고 버튼 안의 글자가 바뀌게 됩니다. 그런데 이때 DOM에는 무슨 일이 일어나는 걸까요? DOM 중에 어떤 곳이 재계산이 된 후에 업데이트 되는 걸까요?</p><p><code>this.setState</code>를 호출하면 렌더링이 다시 진행됩니다. 그러나 페이지 전체는 아니고 <em>컴포넌트 자기 자신과 자식들</em>만 다시 렌더링됩니다. 그 컴포넌트의 부모와 자손뻘 컴포넌트에는 아무런 영향이 없습니다. 트리 규모가 크고 부분적으로만 다시 렌더링하고 싶을 때 유용하게 작용합니다.</p><h2 id="문제를-정확히-밝히기"><a href="#문제를-정확히-밝히기" class="headerlink" title="문제를 정확히 밝히기"></a>문제를 정확히 밝히기</h2><p>문제를 고치기 전에, 현실에서 일어날 수 있는 가장 흔한 실수를 직접 겪어보실 수 있게 저희가 <a href="https://iadramelk.github.io/optimizing-react-demo/dist/before.html" target="_blank" rel="external">작은 데모 앱</a> 하나를 준비해봤습니다. <a href="https://github.com/facebook/react-devtools" target="_blank" rel="external">React 개발자도구</a>도 필요하므로 브라우저에 설치했나 확인해 보세요.</p><p>가장 먼저 살펴볼 것은 바로 가상 DOM 업데이트를 발생시키는 <em>요소가 무엇인지, 또 언제인지</em>입니다. 브라우저 개발자 도구의 React 패널을 열어서 “Highlight Updates” 체크박스를 선택해 주세요.</p><p><img src="https://cdn.evilmartians.com/front/posts/optimizing-react-virtual-dom-explained/react_dev_tools-e78197e.png" alt=""></p><p>자 이제 테이블에 행을 추가해보세요. 보시다시피 페이지의 각 요소에 보더가 나타납니다. 우리가 행을 추가할 때마다 React에서 가상 DOM 트리 전체를 다시 계산해서 비교하기 때문에 보더가 나타나는 것입니다. 이제 행 안의 카운터 버튼을 눌러보세요. <code>state</code>가 변할 때 가상 DOM 업데이트가 어떻게 일어나는지 확인할 수 있습니다. 바뀐 <code>state</code>와 연관된 요소 및 그 요소의 자식들만 영향을 받습니다.</p><p>React 개발자도구는 문제가 어디서 발생하는 것인지 힌트는 제공해 줄 수 있지만 세부적인 사항에 대해서는 아무것도 알려주지 않습니다. 특히나 문제가 되는 업데이트가 “diff 비교”인지, 아니면 마운팅/언마운팅인지 알고 싶어도 별 도움이 안됩니다. 더 자세히 알아보기 위해서는 React에 내장된 <a href="https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab" target="_blank" rel="external">프로파일러</a>를 사용해야 합니다. (참고로 프로파일러는 프로덕션 모드에서는 작동하지 않습니다.)</p><p>여러분 앱의 URL 끝에 <code>?react_perf</code>를 추가하고 Chrome 개발자도구의 “성능” 패널로 가보세요. 레코딩 버튼을 클릭한 후에 앱 안의 버튼을 눌러 테이블에 변경사항을 줘보세요. 행도 좀 추가해보고, 카운터에도 변경사항을 줘본 후에 “멈춤” 버튼을 누르세요.</p><p><img src="https://cdn.evilmartians.com/front/posts/optimizing-react-virtual-dom-explained/react_perf_tools-ba86f5e.png" alt=""></p><p>결과 화면 중에 관심가질 것은 “User timing” 부분입니다. “React Tree Reconciliation” 그룹과 하위 자식들이 나타날 때까지 타임라인을 확대해 주세요. 이 그룹에 속하는 컴포넌트는 이름 옆에 <em>[update]</em> 혹은 <em>[mount]</em>가 붙어 있습니다.</p><p><strong>대부분의 성능 문제는 이 두가지 중 하나에 속합니다.</strong></p><p>컴포넌트(+ 여기서 파생되는 모든 것들)가 모종의 이유 때문에 업데이트마다 재마운팅이 되는 데 이런 일이 일어나지 않도록 하고 싶은 경우(재마운팅은 속도가 느립니다), 혹은 아무것도 변한 것이 없음에도 볼구하고 큰 브랜치에 비용이 많이 드는 reconciliation을 발생시키고 있는 경우, 이 둘중 하나입니다.</p><h2 id="문제-해결하기-마운팅-언마운팅"><a href="#문제-해결하기-마운팅-언마운팅" class="headerlink" title="문제 해결하기: 마운팅/언마운팅"></a>문제 해결하기: 마운팅/언마운팅</h2><p>React가 가상 DOM을 업데이트 결정 방법에 관한 몇가지 이론도 살펴보았고, 화면 뒤에 벌어지는 일을 감시하는 방법도 알아보았으니, 마침내 문제를 해결할 준비가 다 되었습니다! 제일 먼저, 마운트/언마운트 부터 다뤄보도록 하겠습니다.</p><p>모든 요소/컴포넌트에 자식이 여러개 있다면 내부적으로 이들은 <em>배열</em>로 표현된다는 사실에만 신경을 쓰면 상당히 괄목할 만한 속도 향상을 이뤄낼 수 있습니다.</p><p>다음과 같은 코드가 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Message</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Table</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Footer</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>그리고 가상 DOM안에는 다음과 같이 표현되겠죠.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">    &#123; <span class="attr">type</span>: Message &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: Table &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: Footer &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>텍스트가 들어있는 <code>div</code>로 되어있는 간단한 <code>Message</code>가 있고 (흔해 빠진 알림이라 생각하세요) 1000줄 이상의 행이 담겨 있는 거대한 <code>Table</code>이 있습니다. 두 컴포넌트 모두 <code>div</code> 안에 담겨있으므로 부모 노드의 <code>props.children</code> 하위에 위치합니다. 그리고 키값을 일부러 가질 필요는 없는 것들입니다. 심지어 이 경우에는 React도 콘솔을 통해 키값 부여를 하라고 경고해주지 않을 겁니다. 자식이 부모의 <code>React.createElement</code>에 배열이 아닌 인자로 나열되어 들어가기 때문입니다.</p><p>이제 우리의 사용자가 알림을 무시하셔서 <code>Message</code>가 트리에서 제거되었다 해봅시다. 이제 남은 것이라고는 <code>Table</code>과 <code>Footer</code>가 다입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">    &#123; type: Table &#125;,</span><br><span class="line">    &#123; type: Footer &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>React는 이를 어떻게 해석할까요? 자식 배열의 모양이 달라졌다고 생각할 겁니다. ‘<code>children[0]</code>에는 <code>Message</code>가 들어있었는데, 이제는 <code>Table</code>이 들어있네.’ 서로 비교할 키값이 없으므로 <code>type</code>을 비교하기 시작합니다. 그리고 비교하는 대상이 모두 함수 참조이므로 (그리고 <em>다른</em> 함수를 참조하고 있으므로), <code>Table</code> 컴포넌트 전체를 <em>언마운트</em>한 후에 다시 마운트시킵니다. 따라서 1000줄이 넘는 행으로 된 자식이 모두 렌더링됩니다.</p><p>그래서 이 상황을 개선하려면 유일한 키값을 추가(그러나 여기서는 키값 사용이 최상의 선택이 되지 못합니다)하거나 좀 더 똑똑한 트릭을 사용하거나 둘 중 하나를 택해야 합니다. 자바스크립트를 비롯해 최신 프로그래밍 언어에 많이 들어있는 기능인 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators" target="_blank" rel="external">Short circuit boolean evaluation</a>을 사용하는 겁니다. 자 보세요.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// boolean 트릭을 사용합니다</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;isShown &amp;&amp; &lt;Message /&gt;&#125;</span><br><span class="line">  &lt;Table /&gt;</span><br><span class="line">  &lt;Footer /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><code>Message</code>가 화면에 보이지 않더라도 부모 <code>div</code>의 <code>props.children</code>에는 여전히 요소가 <em>세 개</em> 들어있게 됩니다. <code>children[0]</code>에는 <code>false</code>(불리언 원시값)값이 들어가게 되는 것이죠. <code>true/false</code>, <code>null</code>, <code>undefined</code> 이 세개 모두 가상 DOM 객체의 <code>type</code> 프로퍼티로 사용할 수 있다는 사실을 기억하고 계시나요? 그러므로 다음과 같은 객체가 나오게 됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">    false, //  isShown &amp;&amp; &lt;Message /&gt; 결과값이 false로 평가됩니다</span><br><span class="line">    &#123; type: Table &#125;,</span><br><span class="line">    &#123; type: Footer &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>그러므로 <code>Message</code>가 있던 없던간에 인덱스는 변하지 않을 것이고 <code>Table</code> 역시 이전 <code>Table</code>하고만 비교가 이루어지게 됩니다. (<code>type</code>에 참조가 들어간 컴포넌트는 reconciliation이 어찌되었든 일어납니다.) <em>하지만 가상 DOM만 비교해도 된다면 DOM 노드를 제거하고 처음부터 다시 만드는 것보다 일이 훨씬 빠르게 진행이 됩니다.</em></p><p>이제 좀 더 진화가 이루어진 것을 봐봅시다. 여러분이 <a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="external">HOC</a>를 좋아하신다는 것 쯤은 알고 있습니다. 고계도 컴포넌트는 컴포넌트를 인자로 받아서 이걸 가지고 뭔가 한 후에 다른 함수를 돌려주는 일을 하는 함수를 말합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function withName(SomeComponent) &#123;</span><br><span class="line">  // 이름을 계산합니다. 비용이 꽤 들어가는 일 같은데요...</span><br><span class="line">  return function(props) &#123;</span><br><span class="line">    return &lt;SomeComponent &#123;...props&#125; name=&#123;name&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>매우 흔한 패턴입니다. 그러나 조심해서 사용해야 합니다. 다음과 같은 상황이 있다 해봅시다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class App extends React.Component() &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    // 렌더할 때마다 새로운 인스턴스를 생성합니다.</span><br><span class="line">    const ComponentWithName = withName(SomeComponent);</span><br><span class="line">    return &lt;SomeComponentWithName /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>부모의 <code>render</code> 메소드에서 HOC를 생성하는 코드입니다. 트리를 다시 렌더링하게 되면 가상 DOM은 다음과 같을 겁니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 첫번째 렌더:</span><br><span class="line">&#123;</span><br><span class="line">  type: ComponentWithName,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 두번째 렌더:</span><br><span class="line">&#123;</span><br><span class="line">  type: ComponentWithName, // 이름은 같지만 인스턴스가 다릅니다</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 React는 <code>ComponentWithName</code>에 대해서만 diffing 알고리즘을 사용하고 싶어할 것 같은데, 이 경우 참조의 이름만 같으나 <em>인스턴스가 다르기 때문에</em>, 엄격한 비교를 할 경우 실패가 뜨게 되고 reconciliation 대신에 전체 재-마운팅이 일어나게 됩니다. <a href="https://github.com/facebook/react/blob/044015760883d03f060301a15beef17909abbf71/docs/docs/higher-order-components.md#dont-use-hocs-inside-the-render-method" target="_blank" rel="external">이 곳에 명시된 대로</a> 상태 역시 잃어버리게 됩니다. 다행이도 해결이 쉽습니다. 항상 <code>render</code> 밖에서 HOC를 만들면 됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 새 인스턴스를 딱 한번만 만듭니다.</span><br><span class="line">const ComponentWithName = withName(Component);</span><br><span class="line"></span><br><span class="line">class App extends React.Component() &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;ComponentWithName /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="문제-해결하기-업데이트"><a href="#문제-해결하기-업데이트" class="headerlink" title="문제 해결하기: 업데이트"></a>문제 해결하기: 업데이트</h2><p>자, 이제 꼭 필요한 경우가 아니면 재-마운팅이 일어나지 않도록 만들어 두었습니다. 그러나 DOM 트리의 뿌리쪽에 가깝게 위치한 컴포넌트에 변경사항이 생긴다면 그 자식들이 모두 diffing과 reconciliation의 대상이 되어버립니다. 복잡한 구조라면 비용이 상당히 많이 들어가게 되므로 종종 회피의 대상이 되곤 합니다.</p><p><strong>React가 특정 브랜치는 보지 못하도록 할 수 있다면 좋을 것 같습니다. 그 브랜치에는 아무런 변경사항이 없을 것이라 확신할 수 있으니까요.</strong></p><p>그런 방법이 존재합니다. <a href="https://reactjs.org/docs/react-component.html#the-component-lifecycle" target="_blank" rel="external">컴포넌트 생명주기</a>의 한 부분인 <code>shouldComponentUpdate</code>라는 메소드가 참여하게 됩니다. 이 메소드는 각 컴포넌트의 <code>render</code> 메소드가 호출되기 <em>전에</em> 먼저 호출되며, props와 state의 새 값을 전달받습니다. 그러면 이제 현재 값과 비교를 해서 컴포넌트를 업데이트할지 말지 자유롭게 정할 수 있게 됩니다. (<code>true</code> 혹은 <code>false</code>를 반환하는 메소드입니다.) 만약 <code>false</code>를 반환하면 React는 문제가 되는 컴포넌트를 다시 렌더링하지 않을 것이고 그 컴포넌트의 자식도 들여다 보지 않을 겁니다.</p><p><code>props</code>와 <code>state</code> 세트를 비교할 때 대부분의 경우 간단한 <em>얕은</em> 비교 정보면 충분합니다. 만약 최상위 층의 값이 다르면 업데이트 할 필요가 없다고 판정내립니다. 얕은 비교는 Javascript의 기능이 아니지만 이를 해낼 수 있는 <a href="https://github.com/dashed/shallowequal" target="_blank" rel="external">유틸리티</a>가 많이 있습니다.</p><p>유틸리티의 도움을 받아서 코드를 다음과 같이 작성할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class TableRow extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  // 새로운 props/state가 예전 것과 다르면 true를 반환하게 됩니다.</span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    const &#123; props, state &#125; = this;</span><br><span class="line">    return !shallowequal(props, nextProps)</span><br><span class="line">           &amp;&amp; !shallowequal(state, nextState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123; /* ... */ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 위 코드를 여러분이 직접 작성할 필요 조차 없습니다. React에는 <code>React.PureComponent</code>라고 불리우는 내장 기능이 있기 때문이죠. <code>React.Component</code>와 비슷한데, 다만 <em>얕은</em> props/state 비교가 필요할 것이라 가정하여 이미 여러분을 위해 <code>shouldComponentUpdate</code>가 구현되어 있습니다.</p><p>따로 생각할 필요가 없어 보이는데, 그냥 클래스 정의 부분의 <code>extends</code> 부분에 들어간 <code>Component</code>를 <code>PureComponent</code>로 바꿔보고 효율이 얼마나 좋나 감상해 보도록 하죠. 그런데 그다지 안 빠르네요! 다음과 같은 코드를 봐봅시다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Table</span><br><span class="line">    // 맵을 사용하면 새로운 배열 인스턴스를 반환하게 되므로 얕은 비교 결과는 실패가 나옵니다</span><br><span class="line">    rows=&#123;rows.map(/* ... */)&#125;</span><br><span class="line">    // 객체 리터럴은 항상 전의 것과 &quot;다릅니다&quot;</span><br><span class="line">    style=&#123; &#123; color: &apos;red&apos; &#125; &#125;</span><br><span class="line">    // 화살표 함수는 스코프 내에 이름 없는 함수를 새로 만드는 것과 같으므로 항상 diff 비교작업이 전부 이뤄지게 됩니다</span><br><span class="line">    onUpdate=&#123;() =&gt; &#123; /* ... */ &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>위 코드 스니펫에 가장 흔한 세가지 안티 패턴이 들어있습니다. 사용하지 않도록 하세요!</p><p><strong>객체, 배열, 함수를 새로 만들 때 <code>render</code> 정의 밖에서 만들고,  호출과 호출 사이에 아무것도 변한게 없다 확신할 수 있다면 여러분은 이제 안전한 겁니다.</strong></p><p><code>PureComponent</code>의 사용 효과는 <a href="https://iadramelk.github.io/optimizing-react-demo/dist/after.html" target="_blank" rel="external">데모 개선버전</a>에서 관찰해 볼 수 있습니다. 테이블의 모든 <code>Row</code>가 정제를 거친 상태입니다. React 개발자도구의 “Highlight Updates”를 키고 새로운 행을 삽입해보면 테이블 그 자체와 새로 넣어진 행만 다시 렌더링되고 다른 모든 행에는 아무 일도 일어나지 않는 것을 관찰해 볼 수 있습니다.</p><p>그러나 pure 컴포넌트로 앱 구석구석까지 대체할 자신이 없다면 여기서 멈추세요. <code>props</code>와 <code>state</code> 두 세트를 비교하는 작업은 공짜로 할 수 있는 것이 아니기도 하고 대부분의 기본적인 컴포넌트에서는 그런 작업을 진행할 필요가 없습니다. Diffing 알고리즘보다 <code>shallowCompare</code> 돌리는 데 시간만 더 걸리게 될 겁니다.</p><p>여기 경험에서 우러난 법칙을 사용해 보세요. Pure 컴포넌트는 복잡한 폼과 테이블에는 좋지만 버튼과 아이콘 같이 상대적으로 간단한 요소에 사용하면 대부분 속도만 느려지게 됩니다.</p><hr><p>읽어주셔서 감사합니다! 이제 여러분은 애플리케이션에 직접 여기서 배운 것들을 적용할 준비를 마치셨어요. 저희가 만든 작은 데모(<code>PureComponent</code> <a href="https://iadramelk.github.io/optimizing-react-demo/dist/after.html" target="_blank" rel="external">있는</a> 버전과 <a href="https://iadramelk.github.io/optimizing-react-demo/dist/before.html" target="_blank" rel="external">없는</a> 버전)가 담긴 이 <a href="https://github.com/iAdramelk/optimizing-react-demo" target="_blank" rel="external">저장소</a>를 여러분 실험의 시작점으로 사용하셔도 됩니다. 그리고 이 시리즈의 다음 글도 기대해주세요. Redux 및 앱의 전반적인 성능 향상을 위해 <em>data</em>를 최적화하는 법에 대해 다룰 예정입니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;원문: &lt;a href=&quot;https://evilmartians.com/chronicles/optimizing-react-virtual-dom-explained&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://evi
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.holaxprogramming.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>GraphQL과 RESTful API</title>
    <link href="https://www.holaxprogramming.com/2018/01/20/graphql-vs-restful-api/"/>
    <id>https://www.holaxprogramming.com/2018/01/20/graphql-vs-restful-api/</id>
    <published>2018-01-20T13:00:00.000Z</published>
    <updated>2018-04-27T06:49:11.201Z</updated>
    
    <content type="html"><![CDATA[<p>GraphQL 은 Server API 를 구성하기 위해 Facebook 에서 만든 Query Language 이다.</p><a id="more"></a><p>이 글에서는 Server API 가 무엇인지, 그리고 GraphQL 이 어떤 역할을 하는지에 대해서 알아볼 것이다.</p><hr><div align="center"><img src="http://graphql.org/img/logo.svg" height="300"></div><h2 id="Server-API"><a href="#Server-API" class="headerlink" title="Server API"></a>Server API</h2><p>Server API (혹은 Server-side web API) 는 적절한 요청을 하였을 때,<br>그에 맞는 응답을 되돌려주는 창구 (Endpoint) 를 Web 을 통해 노출한 것을 말한다.</p><p>이런 Server API 는 어떤 정보들(환율, 주식 시세, 뉴스 …)을 요청하고 수정하기 위해서 만들어지는 경우가 많다.<br>Facebook 의 경우에도 글을 쓰면 <a href="https://www.facebook.com/webgraphql/mutation/" target="_blank" rel="external">https://www.facebook.com/webgraphql/mutation/</a> 과 같은 Domain 으로 요청이 가고,<br>그 요청에 의해서 Facebook 에 글이 써지게 된다.</p><p>이 Server API 를 만드는 방법론 중 하나로 REST 라는 것이 있으며,<br>이 방법론은 많은 Server API 들을 구성하기 위해 사용되어왔고, 또 현재도 많이 사용되고 있다.</p><h2 id="REST-와-RESTful"><a href="#REST-와-RESTful" class="headerlink" title="REST 와 RESTful"></a>REST 와 RESTful</h2><p><a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="external">REST</a> 는 <a href="https://en.wikipedia.org/wiki/Roy_Fielding" target="_blank" rel="external">Roy Fielding</a> 의<br>“Architectural Styles and the Design of Network-based Software Architectures” 라는 책에서 소개된 방법론으로,<br>REpresentational State Transfer 의 줄임말이다.<br>이 내용이 정확히 무슨 뜻이며, REST 가 무슨 개념을 다 포함하는지 설명하기에는 너무 내용이 길어지게 된다.<br>따라서 간단히만 설명하면,<br>모든 Resource (자료, User, …) 들을 하나의 Endpoint 에 연결해놓고,<br>각 Endpoint 는 그 Resource 와 관련된 내용만 관리하게 하자는 방법론이다.</p><p>예시로 어떤 API 가 Community site 용 API 이며,<br>이 API 를 사용해 사용자들이 글을 작성/수정/삭제 할 수 있고,<br>각 글에 댓글을 작성/수정/삭제할 수 있다고 해보자.</p><p>이때, API 의 Endpoint 를 다음과 같이 구성하면 REST 의 조건을 간략히는 만족하게 된다.</p><ol><li>글 관련 API = /posts<ol><li>글 작성 = POST /posts</li><li>글 수정 = PATCH /posts/[postid]</li><li>글 삭제 = DELETE /posts/[postid]</li></ol></li><li>댓글 관련 API = /posts/[postid]/comments<ol><li>댓글 작성 = POST /posts/[postid]/comments</li><li>댓글 수정 = PATCH /posts/[postid]/comments/[commentid]</li><li>댓글 삭제 = DELETE /posts/[postid]/comments/[commentid]</li></ol></li></ol><p>(물론 실제 API 에는 이보다 더 많은 것들 (글 가져오기, 회원가입하기, 회원인증하기, 회원정보 확인하기, …) 이 필요할 것이다.)</p><p>이런 REST 의 조건을 만족하는 API 를 RESTful API 라고 부르고, 이런 방식으로 API 를 작성하는 것을 RESTful 하다고 한다.</p><h2 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h2><p>GraphQL 은 Graph Query Language 의 줄임말이다.<br>Query Language 란 무엇인가?<br>Query Language 는 정보를 얻기 위해 보내는 질의문(Query)을 만들기 위해 사용되는 Computer 언어의 일종이다.<br>GraphQL 은 이런 Query Language 중에서도 Server API 를 통해 정보를 주고받기 위해 사용하는 Query Language 이다.</p><p>GraphQL 은 왜 탄생해야했는가?<br>다시말해, REST 방법론이 있는데도 새로운 언어인 GraphQL 이 탄생해야했던 배경은 무엇인가?<br>Facebook 의 <a href="http://graphql.org/blog/graphql-a-query-language/" target="_blank" rel="external">GraphQL blog</a> 에서는 다음과 같이 이유를 밝히고 있다.</p><ul><li>RESTful API 로는 다양한 기종에서 필요한 정보들을 일일히 구현하는 것이 힘들었다.</li><li>예로, iOS 와 Android 에서 필요한 정보들이 조금씩 달랐고, 그 다른 부분마다 API 를 구현하는 것이 힘들었다.</li></ul><p>이 때문에 정보를 사용하는 측에서 원하는 대로 정보를 가져올 수 있고,<br>보다 편하게 정보를 수정할 수 있도록 하는 표준화된 Query language 를 만들게 되었다.<br>이것이 GraphQL 이다.</p><h2 id="GraphQL-과-RESTful-의-차이점"><a href="#GraphQL-과-RESTful-의-차이점" class="headerlink" title="GraphQL 과 RESTful 의 차이점"></a>GraphQL 과 RESTful 의 차이점</h2><p>GraphQL 을 통한 API 는 RESTful API 와는 다른 측면을 보인다.</p><ol><li>GraphQL API 는 주로 하나의 Endpoint 를 사용한다.</li><li>GraphQL API 는 요청할 때 사용한 Query 문에 따라 응답의 구조가 달라진다.</li></ol><p>하나하나 살펴보자.</p><h4 id="API-의-Endpoint"><a href="#API-의-Endpoint" class="headerlink" title="API 의 Endpoint"></a>API 의 Endpoint</h4><p>위에서 말했듯 RESTful API 는 Resource 마다 하나의 Endpoint 를 가지고,<br>그 Endpoint 에서 그 Resource 에 대한 (거의) 모든 것을 담당한다.<br>반면, GraphQL 은 전체 API 를 위해서 단 하나의 Endpoint 만을 사용한다.</p><p>다음의 Github API v3 과 v4 이 좋은 예시가 될 것이다.</p><ul><li><a href="https://developer.github.com/v3" target="_blank" rel="external">Github API v3</a></li><li><a href="https://developer.github.com/v4" target="_blank" rel="external">Github API v4</a></li></ul><p>각각 <a href="https://developer.github.com/v3/#root-endpoint" target="_blank" rel="external">v3 root endpoint</a> 와 <a href="https://developer.github.com/v4/guides/forming-calls/#the-graphql-endpoint" target="_blank" rel="external">v4 root endpoint</a> 로 Endpoint 를 제공하지만,<br>v4 의 경우 Root endpoint 를 제외한 어떤 Endpoint 도 없는 반면,<br>v3 의 경우는 각 Resource 마다 수많은 Endpoint 들을 제공한다.</p><h4 id="API-응답의-구조"><a href="#API-응답의-구조" class="headerlink" title="API 응답의 구조"></a>API 응답의 구조</h4><p>RESTful API 는 하나의 Endpoint 에서 돌려줄 수 있는 응답의 구조가 정해져 있는 경우가 많다.<br>API 를 작성할 때 이미 정해놓은 구조로만 응답이 오게 되는 것이다.<br>반면, GraphQL 은 사용자가 응답의 구조를 자신이 원하는 방식으로 바꿀 수 있다.</p><p>마찬가지로 Github API 를 예시로 보면,<br><a href="https://developer.github.com/v3/repos/#list-your-repositories" target="_blank" rel="external">v3 repository api</a> 는 구조가 예시에 나온 모양으로 고정되어 있는 반면,<br><a href="https://developer.github.com/v4/explorer/" target="_blank" rel="external">v4 api</a> 의 경우는</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query &#123; </span><br><span class="line">  repository(owner: &quot;Ailrun&quot; name: &quot;rxan&quot;) &#123;</span><br><span class="line">    nameWithOwner</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>를 사용하느냐,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query &#123; </span><br><span class="line">  repository(owner: &quot;Ailrun&quot; name: &quot;rxan&quot;) &#123;</span><br><span class="line">    languages(first: 2) &#123;</span><br><span class="line">      nodes &#123;</span><br><span class="line">        name</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>를 사용하느냐에 따라서 응답의 구조가 완전히 다르게 된다.</p><h4 id="GraphQL-vs-RESTful"><a href="#GraphQL-vs-RESTful" class="headerlink" title="GraphQL vs RESTful"></a>GraphQL vs RESTful</h4><p>이런 차이로 인해 생기는 장단점은 무엇이 있는가?</p><p>GraphQL 은 다음과 같은 장점을 가진다.</p><ol><li>HTTP 요청의 횟수를 줄일 수 있다.<ul><li>RESTful 은 각 Resource 종류 별로 요청을 해야하고, 따라서 요청 횟수가 필요한 Resource 의 종류에 비례한다.<br>반면 GraphQL 은 원하는 정보를 하나의 Query 에 모두 담아 요청하는 것이 가능하다.</li></ul></li><li>HTTP 응답의 Size 를 줄일 수 있다.<ul><li>RESTful 은 응답의 형태가 정해져있고, 따라서 필요한 정보만 부분적으로 요청하는 것이 힘들다.<br>반면 GraphQL 은 원하는 대로 정보를 요청하는 것이 가능하다.</li></ul></li></ol><p>두 장점을 예시를 통해 알아보자.<br>우리가 글의 목록과 각 글에 쓰인 댓글의 목록을 가져올 수 있는 API 가 있다고 해보자.<br>이 API 가 RESTful 하게 작성되었다면 글과 댓글의 목록을 가져오기 위해서 다음 중 한 가지 방법을 선택해야 할 것이다.</p><ol><li>글의 목록을 가져오는 Endpoint 와 댓글의 목록을 가져오는 Endpoint 에 각각 요청을 여러 번 한다.<br>글이 5 개 있다고 해보자.<br>이 경우에는 글의 목록을 가져오는 Endpoint 에 요청을 하고,<br>각 글마다 댓글의 목록을 가져오는 Endpoint 에 요청을 5 번 해야 글과 댓글의 목록을 모두 가져올 수 있을 것이다. (1. 장점)</li><li>글의 목록을 가져오는 Endpoint 의 응답에 댓글의 목록을 포함한다.<br>글이 5 개 있다고 해보자.<br>이 경우에는 글의 목록을 가져오는 Endpoint 에 요청을 1 번 하면 끝이지만,<br>글의 목록만 가져와야 하는 경우나 몇몇 글의 댓글만 가져와야 하는 경우가 있다면<br>필요한 정보에 비해서 응답의 크기가 쓸데없이 큰 경우가 발생할 것이다. (2. 장점)</li><li>글의 목록을 가져오는 요청에 조건을 달아서 댓글의 목록을 포함할 수도, 포함하지 않을 수도 있게 한다.<br>API 에 Endpoint 가 많을 경우, API 를 만드는 것이 점점 더 복잡해지고,<br>결국 Facebook 에서 GraphQL 을 만든 이유와 비슷한 상황에 처하게 된다.</li></ol><p>반면 같은 API 를 GraphQL 로 작성하였다면</p><ol><li>글의 목록만을 가져와야 할 경우에는 글의 목록만을 가져오는 Query 를 작성하여 서버에 요청을 보낸다.</li><li>글의 목록과 댓글을 모두 가져와야 할 경우에는 글의 목록과 댓글을 모두 가져오는 Query 를 작성하여 서버에 요청을 보낸다.</li></ol><p>등을 할 수 있다.</p><p>그렇다면 GraphQL 은 장점만 가지는가? 물론 단점도 있다.<br>GraphQL 은 다음과 같은 단점을 가진다.</p><ol><li>File 전송 등 Text 만으로 하기 힘든 내용들을 처리하기 복잡하다.</li><li>고정된 요청과 응답만 필요할 경우에는 Query 로 인해 요청의 크기가 RESTful API 의 경우보다 더 커진다.</li><li>재귀적인 Query 가 불가능하다. (결과에 따라 응답의 깊이가 얼마든지 깊어질 수 있는 API 를 만들 수 없다.)</li></ol><p>물론 GraphQL 에서 File 전송을 할 수 없는 것은 아니나,<br>일반적인 GraphQL API 에 비해서 복잡해지거나 외부의 Service 에 의존해야하는 등 문제가 발생한다.</p><h4 id="GraphQL-or-RESTful"><a href="#GraphQL-or-RESTful" class="headerlink" title="GraphQL or RESTful?"></a>GraphQL or RESTful?</h4><p>그렇다면 GraphQL 과 RESTful 중 어떤 것을 선택해서 사용해야하는가?<br>다음과 같은 기준으로 선택하면 될 것이다.</p><ol><li>GraphQL<ul><li>서로 다른 모양의 다양한 요청들에 대해 응답할 수 있어야 할 때</li><li>대부분의 요청이 CRUD(Create-Read-Update-Delete) 에 해당할 때</li></ul></li><li>RESTful<ul><li>HTTP 와 HTTPs 에 의한 Caching 을 잘 사용하고 싶을 때</li><li>File 전송 등 단순한 Text 로 처리되지 않는 요청들이 있을 때</li><li>요청의 구조가 정해져 있을 때</li></ul></li></ol><p>그러나 더 중요한 것은, <strong>둘 중 하나를 선택할 필요는 없다</strong>는 것이다.</p><h4 id="GraphQL-and-RESTful"><a href="#GraphQL-and-RESTful" class="headerlink" title="GraphQL and RESTful!"></a>GraphQL and RESTful!</h4><p>File 전송과 같이 RESTful 이 더 유리한 API 가 있을 수 있고,<br>다양한 정보를 주고받는 것 같이 GraphQL 이 더 유리한 API 가 있을 수 있다.</p><p>이럴 때 둘 중 하나만 선택해야할 필요는 없다.<br>하나의 Endpoint 를 GraphQL 용으로 만들고,<br>다른 RESTful endpoint 들을 만들어 놓는 것은 API 개발자의 자유다.<br>주의해야할 것은 하나의 목표를 위해 두 API structure 를 섞어놓는 것은 API 의 품질을 떨어트릴 수 있다는 점이다.<br>(예: 사용자 정보를 등록하는 것은 RESTful API 로, 사용자 정보를 수정하는 것은 GraphQL API 로 한다면 끔찍할 것이다.)</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>GraphQL 은 여러 장점을 가지고 Server 의 구조를 단순화 시켜줄 수 있는 좋은 Query Language 이다.<br>다만, GraphQL 의 장점이 언제나 의미를 가지는 것은 아니며, 어떤 조건에서 사용하는지, 어떤 목표로 사용하는지에 따라서<br>장점으로 작용하기도, 단점으로 작용하기도 한다.<br>훌륭한 API 개발자가 되기 위해서는<br>이런 장단점을 잘 파악하여 GraphQL 만 쓸 것인지,<br>RESTful structure 또한 사용할 것인지,<br>혹은 RESTful structure 만 사용할 것인지를 결정하는 것이 중요하다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GraphQL 은 Server API 를 구성하기 위해 Facebook 에서 만든 Query Language 이다.&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="https://www.holaxprogramming.com/categories/nodejs/"/>
    
    
  </entry>
  
  <entry>
    <title>Python으로 시작하는 알고리듬</title>
    <link href="https://www.holaxprogramming.com/2017/12/29/algorithms-learning-strategy/"/>
    <id>https://www.holaxprogramming.com/2017/12/29/algorithms-learning-strategy/</id>
    <published>2017-12-29T02:54:07.000Z</published>
    <updated>2018-04-27T06:49:11.188Z</updated>
    
    <content type="html"><![CDATA[<p>이 글은 파이썬을 통해 알고리듬 학습을 시작하는 분들을 위한 내용입니다.</p><h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h2><h4 id="Install-Python"><a href="#Install-Python" class="headerlink" title="Install Python"></a>Install Python</h4><p>파이썬은 공식 사이트인 <a href="https://www.python.org/" target="_blank" rel="external">python.org</a>에서 다운로드할 수 있다. 설치가 매우 간단하며 OSX 사용자라면 이미 파이썬이 설치되어 있을 것이다. </p><p>가능하면 가장 최신의 버전의 python3를 설치하는 것을 권장한다. 설치 후 커맨드 라인에서 아래와 같이 입력하면, 파이썬 Interpeter를 통해 프로그래밍할 수 있는 환경이 갖추어진다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python3</span><br><span class="line">Python 3.6.1 (v3.6.1:69c0db5050, Mar 21 2017, 01:21:04)</span><br><span class="line">[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="IDLE과-PyCharm-IDE"><a href="#IDLE과-PyCharm-IDE" class="headerlink" title="IDLE과 PyCharm IDE"></a>IDLE과 PyCharm IDE</h4><p>Interpreter 언어인 파이썬은 위와 같은 Interactive 모드를 통해 별도의 도구 없이 한 줄 한 줄 프로그래밍 하도록 도와준다. </p><p>이 REPL은 매우 유용하지만 앞으로 파이썬 코드를 파일에 작성하고자 한다면 JetBrain의 <a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="external">PyCharm IDE</a>를 사용하는 것을 추천한다.</p><blockquote><p>파이썬에는 파일에 작성하기 위한 기본 도구인 IDLE를 포함하고 있다.</p></blockquote><p>자 뻔한 과정은 생략하고 아래와 같이 Hello World를 출력하는 첫 파이썬 프로그램을 작성해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;print(&apos;Hello World!&apos;)&quot; &gt; hello_world.py</span><br></pre></td></tr></table></figure><p>파일에 작성된 코드 역시 파이썬 Interpreter에 의해서 실행되며 방법은 아래와 같다. 정상적으로 출력이 된다면 우리는 파이썬 프로그래밍을 위한 모든 준비를 마쳤다!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python3 hello_world.py</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h2 id="TDD로-Python-시작하기"><a href="#TDD로-Python-시작하기" class="headerlink" title="TDD로 Python 시작하기"></a>TDD로 Python 시작하기</h2><p>만약 파이썬이 처음이라면 TDD를 통해 프로젝트를 구성하고 파이썬을 더욱 멋지게 활용할 수 있는 아래의 글을 참고하도록 하자. 프로젝트의 소스코드는 GitHub링크를 아래에 첨부하였다. 도움이 될 듯하다면 ★ Star를 누르는 센스도 잊지 말자!</p><ul><li><a href="https://www.holaxprogramming.com/2017/06/15/python-get-started/">시작하기</a></li><li><a href="https://www.holaxprogramming.com/2017/06/17/python-with-test/">unittest와 함께하는 파이썬 테스트</a></li><li><a href="https://www.holaxprogramming.com/2017/06/28/python-project-structures/">파이썬 프로젝트의 구조</a></li><li><a href="https://www.holaxprogramming.com/2017/07/15/python-virtual-environments/">파이썬 실행 환경을 지탱하는 도구들</a></li></ul><blockquote><p>GitHub Repo - <a href="https://github.com/stunstunstun/awesome-algorithms" target="_blank" rel="external">https://github.com/stunstunstun/awesome-algorithms</a></p></blockquote><h2 id="다양한-알고리듬-문제를-제공하는-사이트들"><a href="#다양한-알고리듬-문제를-제공하는-사이트들" class="headerlink" title="다양한 알고리듬 문제를 제공하는 사이트들"></a>다양한 알고리듬 문제를 제공하는 사이트들</h2><ul><li><a href="https://www.hackerrank.com/dashboard" target="_blank" rel="external">Hacker Rank</a></li><li><a href="https://leetcode.com/" target="_blank" rel="external">LeetCode</a></li><li><a href="https://codility.com/programmers/" target="_blank" rel="external">Codility</a></li><li><a href="https://www.kaggle.com/" target="_blank" rel="external">Kaggle</a></li><li><a href="https://visualgo.net/en" target="_blank" rel="external">Visualgo</a></li><li><a href="http://algo-visualizer.jasonpark.me/#path=backtracking/knight&#39;s_tour/basic" target="_blank" rel="external">Algorithm Visualizer</a></li></ul><h2 id="Google과-Facebook은-어떻게-알고리듬-인터뷰를-진행할까"><a href="#Google과-Facebook은-어떻게-알고리듬-인터뷰를-진행할까" class="headerlink" title="Google과 Facebook은 어떻게 알고리듬 인터뷰를 진행할까?"></a>Google과 Facebook은 어떻게 알고리듬 인터뷰를 진행할까?</h2><ul><li><a href="https://careers.google.com/how-we-hire/interview/" target="_blank" rel="external">Google</a></li><li><a href="https://www.facebook.com/notes/facebook-engineering/get-that-job-at-facebook/10150964382448920/" target="_blank" rel="external">Facebook</a></li></ul><h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><h4 id="Time-Complexity와-Space-Complexity"><a href="#Time-Complexity와-Space-Complexity" class="headerlink" title="Time Complexity와 Space Complexity"></a>Time Complexity와 Space Complexity</h4><p>알고리듬을 테스트하면서 가장 고려할 요소는 Time Complexity와 Space complexity이다.</p><h4 id="Time-Complexity"><a href="#Time-Complexity" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p><img src="https://i1.wp.com/texblog.org/Wordpress/wp-content/uploads/2014/06/big-o-example-latex.png" width="400"></p><p>Time Complexity(시간 복잡도)는 문제를 해결하는데 걸리는 시간과 입력의 함수 관계를 표현한다. 얼마나 많은 데이터를 입력 받았는지 그에 따라 CPU는 얼마나 사용하는지 수행 시간은 얼마나 걸리는지를 표현할 수 있다.</p><p>가장 많이 쓰이는 표현법으로는 알고리듬의 실행 시간의 상한을 나타내는 <code>Big-O</code> 표기법이 있다.</p><h4 id="Big-O-Notations"><a href="#Big-O-Notations" class="headerlink" title="Big-O Notations"></a>Big-O Notations</h4><p><img src="https://camo.githubusercontent.com/874181d7b840a494fe94a11cc13c1fad5d372217/68747470733a2f2f6170656c6261756d2e66696c65732e776f726470726573732e636f6d2f323031312f31302f796161636f766170656c6261756d6269676f706c6f742e6a7067" width="400"></p><table><thead><tr><th>Big-O</th><th>Operations for 10 things</th><th>Operations for 100 things</th></tr></thead><tbody><tr><td>O(1)</td><td>1</td><td>1</td></tr><tr><td>O(log n)</td><td>3</td><td>7</td></tr><tr><td>O(n log n)</td><td>30</td><td>700</td><td></td></tr><tr><td>0(n^2)</td><td>100</td><td>10000</td><td></td></tr></tbody></table><blockquote><p>Solutions - <a href="https://www.martinkysel.com/codility-solutions/" target="_blank" rel="external">https://www.martinkysel.com/codility-solutions/</a></p></blockquote><p><code>O(1) - Constant Time</code></p><p>입력되는 데이터양과 상관없이 일정한 실행 시간을 가진다.</p><p><code>O(log n) - Logarithmic Time</code></p><ul><li>입력 데이터 양이 많아져도 수행 시간이 조금씩 늘어난다.</li><li>시간에 비례하여, 탐색 가능한 데이터양이 2의 n승이 된다.</li></ul><blockquote><p>Binary Search</p></blockquote><p><code>O(n) - Linear Time</code></p><ul><li>입력 데이터 양에 따라 수행 시간이 정비례한다.</li></ul><blockquote><p>선형 탐색, for 문을 통한 탐색을 생각하면 되겠다.</p></blockquote><p><code>O(n log n) - Linearithmic time</code></p><ul><li>입력 데이터 양이 n배 많이 진다면, 수행 시간은 n배 보다 조금 더 많아 진다.</li><li>정비례하지 않는다.</li></ul><blockquote><p>예를 들면, 이진 트리 정렬은 n 크기의 배열 각 요소를 하나하나 삽입하여 이진 트리를 만든다. 자가 균형 이진 탐색 트리의 삽입 연산은 O(log n)시간이 걸리기 때문에, 전체 알고리듬은 Linearithmic time이 걸린다.</p></blockquote><p><code>O(n^2) - Quadratic Time</code></p><ul><li>입력 데이터의 양에 따라 수행 시간은 제곱에 비례한다.</li></ul><blockquote><p>Bubble Sort</p></blockquote><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>지금까지 파이썬을 통해 알고리듬을 학습하기 위한 첫 걸음을 띄어보았습니다. 기본적인 알고리듬의 구현, 테스트 코드는 아래의 GitHub링크를 참고하세요. 시작이 반이니 화이팅하세요 :) </p><blockquote><p><a href="https://github.com/stunstunstun/awesome-algorithms" target="_blank" rel="external">https://github.com/stunstunstun/awesome-algorithms</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이 글은 파이썬을 통해 알고리듬 학습을 시작하는 분들을 위한 내용입니다.&lt;/p&gt;
&lt;h2 id=&quot;Get-Started&quot;&gt;&lt;a href=&quot;#Get-Started&quot; class=&quot;headerlink&quot; title=&quot;Get Started&quot;&gt;&lt;/a&gt;Get S
      
    
    </summary>
    
      <category term="algorithm" scheme="https://www.holaxprogramming.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Yarn 톺아보기</title>
    <link href="https://www.holaxprogramming.com/2017/12/21/node-yarn-tutorials/"/>
    <id>https://www.holaxprogramming.com/2017/12/21/node-yarn-tutorials/</id>
    <published>2017-12-21T00:00:00.000Z</published>
    <updated>2018-04-27T06:49:11.205Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://designmodo.com/wp-content/uploads/2016/10/Yarn-1.jpg" width="400"></p><blockquote><p>톺아보다 [동사] 샅샅이 톺아 나가면서 살피다.</p></blockquote><p>Yarn은 프로젝트의 의존성을 관리하는 JavaScript의 패키지 매니저입니다. Java의 gradle이나 Python의 pip과 같이 말이죠. 물론 우리에겐 npm이 있지만 Yarn은 보다 더 빠르고 거기다 더욱 안전합니다. npm과 같이 JavaScript 패키지의 저장소를 제공할 뿐만 아니라 시스템에서 의존 패키지를 설치하거나 업데이트하는 등의 다양한 명령을 제공합니다.</p><p>Yarn은 npm과 마찬가지로 <code>package.json</code>을 통해 의존 패키지를 구분하고 프로젝트에서 어떠한 일들을 해야할지 결정합니다.</p><h2 id="Facebook은-Yarn을-왜-만들었을까"><a href="#Facebook은-Yarn을-왜-만들었을까" class="headerlink" title="Facebook은 Yarn을 왜 만들었을까?"></a>Facebook은 Yarn을 왜 만들었을까?</h2><p>Facebook은 점차 거대해지는 프로젝트에서 npm을 사용하면서 일관적, 보안, 특히 성능에 대한 문제를 겪에 되었고 npm을 대체할 새로운 패키지 매니저를 개발하게 됩니다.</p><h4 id="npm의-한계"><a href="#npm의-한계" class="headerlink" title="npm의 한계"></a>npm의 한계</h4><p>npm 저장소의 취약한 보안 이슈를 시작으로, 의존 패키지의 버저닝 이슈, 무엇보다 패키지가 많아짐에 따라 빌드 성능이 좋지 않다는 점이 가장 큰 문제입니다.</p><p>버저닝 이슈는 예를 들면 로컬에서 특정 패키지의 버전이 1.0.0인데 배포를 위한 빌드 서버에서는 시점에 따라 1.0.3으로 업데이트 될 수도 있음을 말합니다.</p><blockquote><p>최근의 보안 이슈 - <a href="http://blog.npmjs.org/post/163723642530/crossenv-malware-on-the-npm-registry" target="_blank" rel="external">http://blog.npmjs.org/post/163723642530/crossenv-malware-on-the-npm-registry</a></p></blockquote><h4 id="Yarn은-npm에-비해-얼마나-빠른가"><a href="#Yarn은-npm에-비해-얼마나-빠른가" class="headerlink" title="Yarn은 npm에 비해 얼마나 빠른가?"></a>Yarn은 npm에 비해 얼마나 빠른가?</h4><p>간단한 React 애플리케이션을 통해 node_modules을 설치하는 속도는 npm과 크게 차이가 나지 않습니다. 하지만 두 번째 명령을 통해 아래와 같이 성능 차이가 나는 것을 볼 수 있습니다.</p><p><code>React app</code></p><table><thead><tr><th>Action</th><th>First time</th><th>Second Time(Cached)</th></tr></thead><tbody><tr><td>npm install</td><td>24.3s</td><td>5.4s</td></tr><tr><td>yarn install</td><td>22.9s</td><td>976ms</td></tr></tbody></table><blockquote><p>성능 테스트 참고 - <a href="https://yarnpkg.com/en/compare" target="_blank" rel="external">https://yarnpkg.com/en/compare</a></p></blockquote><h4 id="Yarn은-모든-패키지를-유저-디렉토리에-저장해-캐싱합니다"><a href="#Yarn은-모든-패키지를-유저-디렉토리에-저장해-캐싱합니다" class="headerlink" title="Yarn은 모든 패키지를 유저 디렉토리에 저장해 캐싱합니다."></a>Yarn은 모든 패키지를 유저 디렉토리에 저장해 캐싱합니다.</h4><p>캐싱하기 위한 디렉토리 경로는 아래와 같습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yarn cache dir</span><br><span class="line"><span class="variable">$HOME</span>/Library/Caches/Yarn/v1</span><br></pre></td></tr></table></figure><h2 id="시작하기"><a href="#시작하기" class="headerlink" title="시작하기"></a>시작하기</h2><p>지금까지 Yarn이 출현하게 된 배경을 살펴보았고 이제 시스템에 Yarn을 설치해보도록 하겠습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -o- -L https://yarnpkg.com/install.sh | bash</span><br></pre></td></tr></table></figure><p>또는 nvm을 통해 node 버전을 관리하고 있다면 npm을 통해 설치하는 것을 추천합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g yarn</span><br></pre></td></tr></table></figure><p>어디에 설치되어 있을까요?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> yarn</span><br><span class="line"><span class="variable">$HOME</span>/.nvm/versions/node/v8.9.0/bin/yarn</span><br></pre></td></tr></table></figure><h4 id="yarn-global"><a href="#yarn-global" class="headerlink" title="yarn global"></a>yarn global</h4><p>이 명령은 패키지를 시스템 전역에서 설치, 업데이트, 삭제하는 것을 의미합니다. 패지키가 설치되는 경로를 지정할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yarn config <span class="built_in">set</span> prefix ~/.yarn</span><br><span class="line">$ yarn global add pm2 npm-check create-react-app</span><br></pre></td></tr></table></figure><p>아래의 명령을 통해 현재 전역에 설치된 패키지 리스트와 실행 파일의 위치를 확인할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ yarn global list</span><br><span class="line">yarn global v1.3.2</span><br><span class="line">info <span class="string">"create-react-app@1.4.3"</span> has binaries:</span><br><span class="line">   - create-react-app</span><br><span class="line">info <span class="string">"npm-check@5.5.2"</span> has binaries:</span><br><span class="line">   - npm-check</span><br><span class="line">info <span class="string">"pm2@2.8.0"</span> has binaries:</span><br><span class="line">   - pm2</span><br><span class="line">...</span><br><span class="line">✨ Done <span class="keyword">in</span> 1.51s.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yarn global bin</span><br><span class="line"><span class="variable">$HOME</span>/.yarn/bin</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls <span class="variable">$HOME</span>/.yarn/bin</span><br><span class="line">create-react-apppm2-devyarnyarnpkg</span><br><span class="line">npm-checkpm2-dockerpm2pm2-runtime</span><br></pre></td></tr></table></figure><h4 id="yarn-init"><a href="#yarn-init" class="headerlink" title="yarn init"></a>yarn init</h4><p>이 문서에서는 간단하게 <code>pet-kitten</code>이라는 이름의 프로젝트를 <code>yarn init</code> 명령을 통해 생성합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir pet-kitten</span><br><span class="line">$ <span class="built_in">cd</span> pet-kitten</span><br><span class="line">$ yarn init</span><br><span class="line">yarn init v1.3.2</span><br><span class="line">question name (pet-kitten):</span><br><span class="line">question version (1.0.0):</span><br><span class="line">question description:</span><br><span class="line">question entry point (index.js):</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>위와 같이 프로젝트에 필요한 기본적인 정보를 입력하면 <code>package.json</code> 파일이 생성됩니다.</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>이 파일에는 최소한 패지키의 이름과 버전을 포함해야하며 프로젝트에 필요한 의존 프로젝트는 추가로 <code>dependencies</code>라는 키에 정의하게 됩니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"pet-kitten"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">"stunstunstun"</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"MIT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dependencies-패키지의-버전의-범위"><a href="#dependencies-패키지의-버전의-범위" class="headerlink" title="dependencies 패키지의 버전의 범위"></a>dependencies 패키지의 버전의 범위</h2><p>프로젝트에서 HTTP 요청을 위한 의존 패키지를 <code>request</code>를 사용한다면 아래와 같이 정의하면 됩니다.</p><ul><li>npm 패키지의 이름</li><li>npm 패키지의 버전을 표기합니다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"pet-kitten"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"requests"</span>: <span class="string">"^2.0.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">"stunstunstun"</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"MIT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>npm 패키지의 버전 표기 방식이 낮설어 보일수도 있는데, 프로젝트의 의존 패키지의 버전을 정의하기 위해 가장 많이 사용되는 방식은 틸드(~), 캐럿(^)입니다. 이 두 방식이 패키지 버전의 범위를 어떻게 표현하는지 이해할 필요가 있습니다.</p><h4 id="틸드"><a href="#틸드" class="headerlink" title="틸드(~)"></a>틸드(~)</h4><p>틸드는 간단히 말하면 현재 지정한 버전의 마지막 자리의 범위에서만 자동으로 업데이트합니다.</p><table><thead><tr><th>예시</th><th>범위</th></tr></thead><tbody><tr><td>~0.0.1</td><td><code>&gt;=0.0.1 and &lt;0.1.0</code></td></tr><tr><td>~0.1.1</td><td><code>&gt;=0.1.1 and &lt;0.2.0</code></td></tr></tbody></table><h4 id="캐럿"><a href="#캐럿" class="headerlink" title="캐럿(^)"></a>캐럿(^)</h4><p>캐럿(^)은 Node.js 모듈이 이 <a href="http://semver.org/" target="_blank" rel="external">Semantic Versioning</a>의 규약을 따른다는 것을 신뢰한다는 가정하에서 동작하는데, Minor나 Patch버전은 하위 호환성이 보장되어야 하므로 최신 버전이 존재한다면 업그레이드 진행할 수 있습니다.</p><table><thead><tr><th>예시</th><th>범위</th></tr></thead><tbody><tr><td>^1.0.2</td><td><code>&gt;=1.0.2 and &lt;2.0</code></td></tr><tr><td>^1.0</td><td><code>&gt;=1.0.0 and &lt;2.0</code></td></tr><tr><td>^1</td><td><code>&gt;=1.0.0 and &lt;2.0</code></td></tr></tbody></table><p>하지만 아직 npm 저장소 생태계의 몇몇 패키지는 Minor, Patch 버전이 업데이트 되었음에도 하위 호환성을 보장하지 않고 우리가 원하는 방식으로 동작하지 않는 경우가 있습니다. 이점은 대규모 프로젝트의 환경에서는 치명적이기 때문에 프로젝트에서 의존 패키지를 효율적으로 관리하기 위해 Yarn이 어떻게 동작하는지 정확히 이해할 필요가 있습니다.</p><h2 id="yarn-lock"><a href="#yarn-lock" class="headerlink" title="yarn.lock"></a>yarn.lock</h2><p>위와 같이 Yarn은 <code>package.json</code>에 정의된 버전의 범위에 따라 패키지를 관리합니다. 하지만 이는 시스템마다 <code>yarn install</code>이 되는 시점에 따라 패키지의 버전이 다를 수도 있다는 것을 의미합니다.</p><p>Yarn은 이 문제를 해결하고 시스템간에 일관적으로 패키지 버전을 제공하기 위해 <code>yarn.lock</code> 파일을 프로젝트의 루트에 자동으로 생성합니다. 사용자는 이 파일을 직접 수정해서는 안되며 Yarn CLI을 통해 패키지를 관리하면 자동으로 업데이트됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.</span><br><span class="line"># yarn lockfile v1</span><br><span class="line">...</span><br><span class="line">mongoose@^4.9.8:</span><br><span class="line">  version &quot;4.9.8&quot;</span><br><span class="line">  resolved &quot;https://registry.yarnpkg.com/mongoose/-/mongoose-4.9.8.tgz#ef64304231dc2455ab15a0c0cb6c149ce8c787bb&quot;</span><br><span class="line">  dependencies:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>package.json</code>과 <code>yarn.lock</code>은 Version control 시스템과 긴밀하게 연결되어야 합니다. 많은 사람들과 애플리케이션을 안정적으로 운영하고자 한다면 이 파일들을 Git Repository에 함께 저장하는 것을 추천합니다.</p><h4 id="하위-호환성을-보장하지-않는-사례"><a href="#하위-호환성을-보장하지-않는-사례" class="headerlink" title="하위 호환성을 보장하지 않는 사례"></a>하위 호환성을 보장하지 않는 사례</h4><p>현재 <code>yarn.lock</code>의 mongoose 버전은 4.9.8로 resloved 되어 있고, 만약 테스트 환경을 구축하기 위해 <code>devDependencies</code>에 mocha, chai, nyc와 같은 패키지를 추가하거나 버전만을 업데이트했다고 가정합니다.</p><p><code>packages.json</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="string">"chai"</span>: <span class="string">"^4.1.2"</span>,</span><br><span class="line"><span class="string">"mocha"</span>: <span class="string">"^4.0.1"</span>,</span><br><span class="line"><span class="string">"nyc"</span>: <span class="string">"^11.3.0"</span>,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>아래와 같은 명령은 프로젝트의 모든 패키지를 지정된 범위 내에서 업데이트하고 <code>yarn.lock</code>을 <code>recreated</code>하게 됩니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn upgrade</span><br></pre></td></tr></table></figure><p><code>devDependencies</code> 뿐만 아니라 런타임에도 영향을 미치는 mongoose와 같은 패키지도 현재의 기준으로 최신 버전으로 resolved 됩니다.</p><p><code>yarn.lock</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mongoose@^4.9.8:</span><br><span class="line">  version &quot;4.13.6&quot;</span><br><span class="line">  resolved &quot;https://registry.yarnpkg.com/mongoose/-/mongoose-4.13.6.tgz#48102f0b0d797a9bd273e581eef16d0505ef3d79&quot;</span><br><span class="line">  dependencies:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>최신 버전인 4.13.6으로 resloved 된 mongoose 패키지</p></blockquote><p>Major Fixed가 아님에도 이 업데이트는 하위 호환성을 보장하지 않고 MongError를 발생하는 현상이 있었습니다. 이 경우에는 테스트 케이스를 통해 업데이트 버전에 맞게 코드를 수정해야 합니다.</p><h2 id="Yarn-commands"><a href="#Yarn-commands" class="headerlink" title="Yarn commands"></a>Yarn commands</h2><p>지금까지는 Yarn의 출현 배경을 알아봤다면 지금부터는 Yarn이 제공하는 CLI를 통해 효율적으로 패키지를 관리할 필요가 있습니다.</p><h4 id="yarn-install"><a href="#yarn-install" class="headerlink" title="yarn install"></a>yarn install</h4><p>로컬의 <code>node_modules</code> 폴더에 의존 패키지를 설치하거나 업데이트합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn install</span><br></pre></td></tr></table></figure><p>install은 생략할 수 도 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn</span><br></pre></td></tr></table></figure><p>yarn을 통해 패키지를 설치할 때 주의해야할 사항으로는 빌드, 테스트등을 위한 패키지는 런타임에 영향을 미치지 않아야 합니다. 아래와 같이 <code>NODE_ENV</code> 환경 변수나 <code>--production</code> flag를 통해 production 환경에서 devDependencies에 정의된 패키지의 설치를 생략할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn install --production</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ NODE_ENV=production yarn install</span><br></pre></td></tr></table></figure><p>반대로 NODE_ENV가 production임에도 강제로 devDependencies의 설치가 필요하다면 <code>--production</code>을 false로 지정합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn install --production=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>강제로 모든 패키지를 다시 다운로드해야하는 경우도 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install --force</span><br></pre></td></tr></table></figure><p>CI 서버와 같이 재생 가능한 의존 패키지가 필요한 경우 <code>--fronzen-lockfile</code> 플래그는 유용합니다. <code>yarn.lock</code>과 <code>package.json</code>이 동기화 되지 않은 상태에서 업데이트가 필요한 경우에는 설치를 실패하고 <code>yarn.lock</code>을 생성하지 않습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ yarn install --frozen-lockfile</span><br><span class="line">yarn install v1.3.2</span><br><span class="line">[1/4] 🔍  Resolving packages...</span><br><span class="line">error Your lockfile needs to be updated, but yarn was run with `--frozen-lockfile`.</span><br><span class="line">info Visit https://yarnpkg.com/en/docs/cli/install <span class="keyword">for</span> documentation about this <span class="built_in">command</span>.</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/yarnpkg/yarn/issues/4147" target="_blank" rel="external">https://github.com/yarnpkg/yarn/issues/4147</a><br><a href="https://github.com/yarnpkg/yarn/issues/3313" target="_blank" rel="external">https://github.com/yarnpkg/yarn/issues/3313</a></p></blockquote><h4 id="yarn-add"><a href="#yarn-add" class="headerlink" title="yarn add"></a>yarn add</h4><p>프로젝트에서 다른 패키지를 사용하기 위해 <code>package.json</code>에 <code>dependencies</code>를 직접 설정하는 방법과 add 명령이 있습니다. 이 명령은 프로젝트의 <code>package.json</code>과 <code>yarn.lock</code>을 업데이트해 모든 개발자가 일괄적인 패키지를 관리할 수 있도록 합니다.</p><p>npm 저장소의 가장 최신 패키지를 설치합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add request</span><br></pre></td></tr></table></figure><p>패키지의 버전 범위를 지정합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add request@^2.0.0</span><br></pre></td></tr></table></figure><p>devDependencies에 패키지를 추가합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add eslint@^4.0.0 --dev</span><br></pre></td></tr></table></figure><h4 id="yarn-upgrade"><a href="#yarn-upgrade" class="headerlink" title="yarn upgrade"></a>yarn upgrade</h4><p>이 명령은 모든 의존 패키지를 <code>package.json</code>에 정의한 버전의 범위에서 업데이트하거나 삭제합니다.</p><ul><li><code>yarn.lock</code> 파일이 <code>recreated</code> 됩니다.</li><li><code>package.json</code>에는 변화가 없습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn upgrade</span><br></pre></td></tr></table></figure><p>위에서 살펴본대로 대규모의 프로젝트에서는 의존된 모든 패키지가 호환성을 보장하기 힘들기 때문에 이 명령을 통해 일괄적으로 패지키를 업데이트하는 것은 좋지 않습니다. 기존 패키지의 업데이트가 필요하다면 아래와 같이 패키지를 지정해 업데이트하는 것을 추천합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn upgrade mocha@^4.0.0</span><br></pre></td></tr></table></figure><h4 id="yarn-remove"><a href="#yarn-remove" class="headerlink" title="yarn remove"></a>yarn remove</h4><p><code>yarn remove foo</code> 명령은 <code>foo</code>라는 패키지를 프로젝트에서 제거하는 것을 의미합니다.</p><ul><li><code>package.json</code>에서 제거됩니다.</li><li><code>yarn.lock</code>에서 제거됩니다.</li></ul><p>dependencies, devDependencies등 모든 타입에서 패키지가 삭제됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn remove foo</span><br></pre></td></tr></table></figure><blockquote><p>yarn remove는 package.json과 yarn.lock을 언제나 업데이트합니다. 이는 같은 프로젝트에서 협업하는 동료들도 동일한 의존 패키지를 사용하는 것을 보장하는 것을 의미합니다.</p></blockquote><h2 id="yarn-config와-yarnrc"><a href="#yarn-config와-yarnrc" class="headerlink" title="yarn config와 .yarnrc"></a>yarn config와 <code>.yarnrc</code></h2><p><code>yarn config</code> 명령을 통해 Yarn에서 참조하는 설정 파일을 지정할 수 있습니다. 아래와 같이 npm 패키지 저장소의 URL을 변경하거나 라이센스를 지정하는 경우를 말합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ yarn config set registry &apos;https://registry.yarnpkg.com&apos;</span><br><span class="line">$ yarn config set init-license MIT</span><br><span class="line">$ yarn config list</span><br><span class="line">...</span><br><span class="line">registry: &apos;https://registry.yarnpkg.com&apos;,</span><br><span class="line">init-license: &apos;MIT&apos;</span><br></pre></td></tr></table></figure><p>프로젝트의 로컬에서는 아래와 같이 <code>.yarnrc</code> 파일을 통해 별도의 명령 없이 config list를 관리할 수 있습니다.</p><p><code>.yarnrc</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">registry: &apos;https://registry.yarnpkg.com&apos;</span><br><span class="line">init-license: &apos;MIT&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yarn config list</span><br><span class="line">...</span><br><span class="line">registry: &apos;https://registry.yarnpkg.com&apos;,</span><br><span class="line">init-license: &apos;MIT&apos;</span><br></pre></td></tr></table></figure><h2 id="프로젝트의-패키지-버전-안정적으로-관리하기"><a href="#프로젝트의-패키지-버전-안정적으로-관리하기" class="headerlink" title="프로젝트의 패키지 버전 안정적으로 관리하기"></a>프로젝트의 패키지 버전 안정적으로 관리하기</h2><p>npm, yarn을 통해서 dependencies 패키지 버전을 지속적으로 체크하는 다양한 옵션이 존재합니다.</p><h4 id="yarn-check"><a href="#yarn-check" class="headerlink" title="yarn check"></a>yarn check</h4><p>패키지 버전에 따른 의존 패키지들이 프로젝트에서 유효한지 체크합니다. 이 기준은 현재의 <code>package.json</code>이 <code>yarn.lock</code>과 일치하는지 확인하는 것을 말합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ yarn check</span><br><span class="line">yarn check v1.3.2</span><br><span class="line">warning <span class="string">"chokidar#fsevents#node-pre-gyp@^0.6.39"</span> could be deduped from <span class="string">"0.6.39"</span> to <span class="string">"node-pre-gyp@0.6.39"</span></span><br><span class="line">success Folder <span class="keyword">in</span> sync.</span><br><span class="line">✨  Done <span class="keyword">in</span> 6.65s.</span><br></pre></td></tr></table></figure><p><code>yarn check</code> 명령 후에 위와 같이 warning, error를 만난다면 의존 패키지의 버전을 조정할 필요가 있습니다.</p><h4 id="yarn-outdated"><a href="#yarn-outdated" class="headerlink" title="yarn outdated"></a>yarn outdated</h4><p><code>yarn outdated</code>는 업데이트가 필요한 모듈이 정리되어 출력되기 때문에 의존 패키지의 버전을 조종하는데 유용하게 사용됩니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ yarn outdated</span><br><span class="line">yarn outdated v1.3.2</span><br><span class="line">info Color legend :</span><br><span class="line"> <span class="string">"&lt;red&gt;"</span>    : Major Update backward-incompatible updates</span><br><span class="line"> <span class="string">"&lt;yellow&gt;"</span> : Minor Update backward-compatible features</span><br><span class="line"> <span class="string">"&lt;green&gt;"</span>  : Patch Update backward-compatible bug fixes</span><br><span class="line">Package           Current Wanted Latest Package Type    URL</span><br><span class="line">@types/jest       21.1.8  21.1.9 21.1.9 devDependencies https://www.github.com/DefinitelyTyped/DefinitelyTyped.git</span><br><span class="line">@types/koa        2.0.39  2.0.39 2.0.43 devDependencies https://www.github.com/DefinitelyTyped/DefinitelyTyped.git</span><br><span class="line">@types/koa-router 7.0.23  7.0.23 7.0.27 devDependencies https://www.github.com/DefinitelyTyped/DefinitelyTyped.git</span><br><span class="line">cross-env         5.0.5   5.0.5  5.1.1  devDependencies https://github.com/kentcdodds/cross-env<span class="comment">#readme</span></span><br><span class="line">jest              21.2.1  21.2.1 22.0.3 devDependencies http://facebook.github.io/jest/</span><br><span class="line">koa               2.3.0   2.3.0  2.4.1  dependencies    https://github.com/koajs/koa<span class="comment">#readme</span></span><br><span class="line">koa-router        7.2.1   7.2.1  7.3.0  dependencies    https://github.com/alexmingoia/koa-router<span class="comment">#readme</span></span><br><span class="line">nodemon           1.12.0  1.12.0 1.14.1 devDependencies http://nodemon.io</span><br><span class="line">ts-jest           21.2.4  21.2.4 22.0.0 devDependencies https://github.com/kulshekhar/ts-jest<span class="comment">#readme</span></span><br><span class="line">ts-node           3.3.0   3.3.0  4.0.2  devDependencies https://github.com/TypeStrong/ts-node</span><br><span class="line">tslint            5.7.0   5.7.0  5.8.0  devDependencies https://github.com/palantir/tslint.git</span><br><span class="line">typescript        2.5.2   2.5.2  2.6.2  devDependencies http://typescriptlang.org/</span><br><span class="line">✨  Done <span class="keyword">in</span> 1.71s.</span><br></pre></td></tr></table></figure><p><code>Current</code>는 프로젝트에 현재 설치된 버전이고 <code>Wanted</code>는 package.json에 지정한 패키지의 버전에서 호환성을 보장하는 버전을 의미합니다. 즉, yarn upgrade를 통해 변경 되는 버전을 말합니다. </p><p><code>Latest</code>는 패키지의 현재의 최신 버전입니다. 위 화면에서는 <code>jest</code>와 같이 Major 업데이트가 필요한 패키지는 붉은색으로 표시됩니다.</p><h4 id="npm-check"><a href="#npm-check" class="headerlink" title="npm-check"></a>npm-check</h4><p><code>yarn outdated</code>를 통해 원하는 모듈을 업데이트해도 되지만 꽤 귀찮은 작업으로 보입니다. <code>npm-check</code>는 Iteractive한 UI를 터미널에서 제공해 조금 더 쉽게 패키지의 버전을 관리할 수 있도록 도와줍니다.</p><ul><li><a href="https://www.npmjs.com/package/npm-check" target="_blank" rel="external">https://www.npmjs.com/package/npm-check</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn global install npm-check</span><br></pre></td></tr></table></figure><p>프로젝트의 루트경로에서 아래와 같이 사용할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm-check -u</span><br></pre></td></tr></table></figure><p><img src="https://cloud.githubusercontent.com/assets/51505/9569917/96947fea-4f48-11e5-9783-2d78077256f2.png"></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이미 npm을 통해 효율적으로 프로젝트를 관리하고 계시다면 꼭 Yarn을 사용해야 하는 것은 아닙니다. npm 역시 npm@5 부터 더욱 안정적이고 성능이 좋아졌기 때문입니다. 각자의 용도에 따라 필요한 수준의 도구를 이용하면 됩니다. </p><p>만약 대규모 프로젝트에서 Yarn을 통해 더 나은 경험을 얻고자 하신다면 2017년 12월 현재, 아래의 지침으로 정리할 수 있겠습니다.</p><ul><li><code>yarn.lock</code>은 절대 직접 수정하지 않습니다.</li><li><code>package.json</code>을 직접 수정하는 대신 yarn CLI를 통해 추가, 삭제, 업데이트하는 것을 추천합니다.</li><li>새로운 패키지는 <code>yarn add package@^version</code></li><li>기존 패키지의 업데이트를 위해서는 <code>yarn upgrade package@^version</code></li><li><code>yarn upgrade</code> 명령을 통해 모든 패키지를 업데이트 하는 행위는 호환성이 보장되지 않는 대참사를 불러올 수 있기 때문에 사용을 지양합니다.</li></ul><blockquote><p>오직 add, remove, 그리고 upgrade 명령만이 <code>yarn.lock</code>을 업데이트 합니다.</p><p>단, <code>yarn.lock</code>이 <code>package.json</code>과 일치하지 않는 상태라면 install 명령으로 패키지가 업데이트 되고 <code>package.json</code>을 만족하기 위해 필요한 만큼 수정됩니다.</p></blockquote><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="external">https://docs.npmjs.com/files/package.json</a></li><li><a href="https://yarnpkg.com/en/docs/configuration" target="_blank" rel="external">https://yarnpkg.com/en/docs/configuration</a></li><li><a href="https://yarnpkg.com/en/docs/cli/install" target="_blank" rel="external">https://yarnpkg.com/en/docs/cli/install</a></li><li><a href="https://yarnpkg.com/en/docs/cli/add" target="_blank" rel="external">https://yarnpkg.com/en/docs/cli/add</a></li><li><a href="https://yarnpkg.com/lang/en/docs/cli/upgrade/" target="_blank" rel="external">https://yarnpkg.com/lang/en/docs/cli/upgrade/</a></li><li><a href="https://yarnpkg.com/en/docs/cli/check" target="_blank" rel="external">https://yarnpkg.com/en/docs/cli/check</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://designmodo.com/wp-content/uploads/2016/10/Yarn-1.jpg&quot; width=&quot;400&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;톺아보다 [동사] 샅샅이 톺아 나가면서 살피다.&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="nodejs" scheme="https://www.holaxprogramming.com/categories/nodejs/"/>
    
    
  </entry>
  
  <entry>
    <title>소소한 GitHub Tips</title>
    <link href="https://www.holaxprogramming.com/2017/12/20/github-tips/"/>
    <id>https://www.holaxprogramming.com/2017/12/20/github-tips/</id>
    <published>2017-12-20T01:00:00.000Z</published>
    <updated>2018-04-27T06:49:11.200Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub에서 다양한 인원이 프로젝트를 진행하면 이슈 트래킹이 중요합니다. 이슈가 등록될 때 프로젝트에서 참고하는 중요한 정보가 있다면 이슈나 PR을 생성할 때 아래와 같이 Templates를 지정하면 유용합니다.</p><h2 id="Issue-PR-템플릿-활용하기"><a href="#Issue-PR-템플릿-활용하기" class="headerlink" title="Issue, PR 템플릿 활용하기"></a>Issue, PR 템플릿 활용하기</h2><ol><li>프로젝트의 Root 디렉토리에 아래와 같이 <code>.github</code> 폴더를 생성합니다.</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir .github</span><br><span class="line">$ <span class="built_in">cd</span> .github </span><br><span class="line">$ touch ISSUE_TEMPLATE.md    <span class="comment"># 이슈 등록시 템플릿 파일</span></span><br><span class="line">$ touch PULL_REQUEST_TEMPLATE.md  <span class="comment"># PR 등록시 템플릿 파일</span></span><br></pre></td></tr></table></figure><ol><li>새로운 이슈를 등록합니다.</li></ol><p><img src="https://image.toast.com/aaaaahq/new_issues_button.png" width="100"></p><ol><li>적용된 Template를 확인합니다.</li></ol><p><img width="768" alt="github-templates" src="https://image.toast.com/aaaaahq/0c099be0-d9ec-11e7-962d-df3b88f29401.png"></p><p><br></p><h2 id="키워드를-통해-이슈-닫기"><a href="#키워드를-통해-이슈-닫기" class="headerlink" title="키워드를 통해 이슈 닫기"></a>키워드를 통해 이슈 닫기</h2><p>Commit 메세지 뿐만 아니라 PR 등록시에도 아래의 키워드를 통해 PR이 Merge되면 이슈를 Closed 할 수 있습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">close</span><br><span class="line">closes</span><br><span class="line">closed</span><br><span class="line">fix</span><br><span class="line">fixes</span><br><span class="line">fixed</span><br><span class="line">resolve</span><br><span class="line">resolves</span><br><span class="line">resolved</span><br></pre></td></tr></table></figure></p><p><img width="711" alt="github-templates2" src="https://image.toast.com/aaaaahq/d70a1c7a-d9ec-11e7-8910-9686d333d378.png"></p><blockquote><p>참고 - <a href="https://help.github.com/articles/closing-issues-using-keywords/" target="_blank" rel="external">https://help.github.com/articles/closing-issues-using-keywords/</a></p></blockquote><p><br></p><h2 id="의존-패키지-조회하기"><a href="#의존-패키지-조회하기" class="headerlink" title="의존 패키지 조회하기"></a>의존 패키지 조회하기</h2><p>프로젝트의 <code>Insight &gt; Dependency graph</code> 메뉴에서 모든 의존 패키지를 쉽게 확인할 수 있습니다.</p><ul><li><a href="https://github.com/request/request/network/dependencies" target="_blank" rel="external">https://github.com/request/request/network/dependencies</a></li></ul><blockquote><p>현재 이 기능은 GitHub Enterprise에서는 제공되지 않고 있습니다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GitHub에서 다양한 인원이 프로젝트를 진행하면 이슈 트래킹이 중요합니다. 이슈가 등록될 때 프로젝트에서 참고하는 중요한 정보가 있다면 이슈나 PR을 생성할 때 아래와 같이 Templates를 지정하면 유용합니다.&lt;/p&gt;
&lt;h2 id=&quot;Issu
      
    
    </summary>
    
      <category term="git" scheme="https://www.holaxprogramming.com/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>Scala에서의 값 명명과 표현식 평가</title>
    <link href="https://www.holaxprogramming.com/2017/11/18/scala-value-naming/"/>
    <id>https://www.holaxprogramming.com/2017/11/18/scala-value-naming/</id>
    <published>2017-11-18T06:30:00.000Z</published>
    <updated>2018-04-27T06:49:11.206Z</updated>
    
    <content type="html"><![CDATA[<p>모든 Programming 언어는 값 (Value) 을 명명 (Naming) 할 수 있다. 값에 이름을 붙이는 것은 복잡한 계산의 결과가 무엇을 뜻하는지 이해하기 쉽게 해준다. 뿐만 아니라 값에 이름을 붙이는 것은 동일한 계산을 Computer 가 여러 번 할 필요 없이, 효율적으로 한 번만 해도 되게 만들어준다. 따라서 값을 명명하고 값을 어떻게 계산하느냐는 Programming 언어에 있어서 매우 중요한 일 중 하나이다. Scala 에서는 이런 값의 명명과 계산을 어떻게 할 수 있는지, 또 그렇게 명명된 값을 어떻게 쓸 수 있는지 알아보자.</p><h4 id="Scala-를-사용하는-방법"><a href="#Scala-를-사용하는-방법" class="headerlink" title="Scala 를 사용하는 방법"></a>Scala 를 사용하는 방법</h4><p>이전 글(<a href="https://github.com/stunstunstun/awesome-wiki/tree/master/Scala/scala-hello-world.md" target="_blank" rel="external">Github</a>, <a href="https://www.holaxprogramming.com/2017/11/14/scala-hello-world/">안녕 프로그래밍 사이트</a>)을 참고하자.</p><p>이 글에서 역시 <a href="https://scastie.scala-lang.org/" target="_blank" rel="external">Scastie</a> 를 사용할 것이기 때문에 Scala 를 Computer 에 설치할 필요는 없으며, Scastie 에서 Worksheet 기능을 꺼주기만 하면 된다.</p><h4 id="표현식과-값"><a href="#표현식과-값" class="headerlink" title="표현식과 값"></a>표현식과 값</h4><p>사실, 명명법에 대해서 말하기 이전에, 우선 <strong>표현식</strong> (Expression) 이라는 것이 프로그래밍 언어에서 무엇인지를 알아야한다.</p><p>표현식이란, <strong>평가 (Evaluation) 를 통해서 값으로 바뀌는 식</strong>, 혹은 <strong>결과값이 있는 식</strong>을 뜻한다.</p><p>다음 Code 를 보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Expression</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  println(<span class="number">5</span> + <span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>5 + 4</code> 이 <code>9</code> 로 계산되어 출력될 것이다. 이때 <code>9</code> 를 <code>5 + 4</code> 의 평가 결과, 혹은 표현식의 값이라고 하고, <code>5 + 4</code> 를 <strong>표현식</strong>이라고 한다.</p><p>Scala 에서의 표현식은 위와 같이 한 줄로 쓰여질 수도 있지만, 좀 더 복잡하게 쓰여질 수도 있다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Expression</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  println(&#123;</span><br><span class="line">    <span class="number">5</span> * <span class="number">7</span></span><br><span class="line">    <span class="number">4</span> + <span class="number">3</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 Code 에서</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="number">5</span> * <span class="number">7</span></span><br><span class="line"><span class="number">4</span> + <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>에 해당하는 부분이 표현식이다. 이 표현식은 여러 줄로 쓸 수 있고, 여러 줄 중 하나에서 <code>println()</code> 과 같은 함수를  실행할 수도 있다. 이 표현식의 평가 결과는 언제나 <code>{}</code> 로 둘러싸인 제일 마지막 표현식의 평가 결과와 같다. 즉, 위 Code 의 경우는 <code>4 + 3</code> 의 값인 <code>7</code> 이 <code>{}</code> 로 둘러싸인 전체 표현식의 값이다.</p><p>실제로 앞의 Code 를 실행해보면 다음과 같은 출력을 볼 수 있을 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><p>표현식과 평가에 대해서 기본적인 이해를 하였을 것이라 믿는다. 이제 Scala 에서 값을 명명하는 방법들에 대해서 알아보자.</p><h4 id="Scala-에서-쓸-수-있는-값의-명명-방법들"><a href="#Scala-에서-쓸-수-있는-값의-명명-방법들" class="headerlink" title="Scala 에서 쓸 수 있는 값의 명명 방법들"></a>Scala 에서 쓸 수 있는 값의 명명 방법들</h4><p>Scala 에는 기본적으로 다음과 같은 네 종류의 값의 명명이 가능하다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Naming</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> oneAddOne = <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> twoMultTwo = <span class="number">2</span> * <span class="number">2</span></span><br><span class="line">  <span class="keyword">var</span> threeDivThree = <span class="number">3</span> / <span class="number">3</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fourMinusFour</span> </span>= <span class="number">4</span> - <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각각이 무엇을 의미하는지 살펴보도록 하자.</p><h4 id="val-을-사용한-명명"><a href="#val-을-사용한-명명" class="headerlink" title="val 을 사용한 명명"></a>val 을 사용한 명명</h4><p>아래 Code 를 실행시켜보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Naming</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> first = <span class="number">1</span></span><br><span class="line">  println(first)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 Code 의 실행 결과는 아래 Code 의 실행 결과와 똑같을 것이다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Naming</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  println(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>즉 우리는 값 <code>1</code> 에 <code>first</code> 라는 이름을 붙이고 그 이름을 대신 사용할 수 있는 것이다.<br>이 경우에는 명명이 별로 쓸모가 없어보일 수도 있으니, 약간의 계산을 포함하는 다음 경우를 보도록 하자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Naming</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> cooktimeInMin = <span class="number">4</span></span><br><span class="line">  <span class="keyword">val</span> secPerMin = <span class="number">60</span></span><br><span class="line">  <span class="keyword">val</span> cooktimeInSec = cooktimeInMin * secPerMin</span><br><span class="line">  println(<span class="string">"Cup noodle takes "</span> + cooktimeInMin + <span class="string">" min."</span>)</span><br><span class="line">  println(<span class="string">"In other words, it takes "</span> + cooktimeInSec + <span class="string">" sec."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우리는 우선 <code>cooktimeInMin</code> 이라는 이름으로 컵라면을 끓이는데 걸리는 시간을 <strong>(분)</strong> 단위로 정의했다. 그리고 <code>secPerMin</code> 이라는 이름으로 <strong>1 분 안에 몇 초가 있는지</strong>를 정의했다. 마지막으로, 컵라면을 끓이는데 걸리는 시간을 <strong>(초)</strong> 단위로 계산한 뒤 이 표현식의 값을 <code>cooktimeInSec</code> 이라는 이름으로 정의했다. 이 내용을 화면에 출력하기 위해서 <code>println</code> 함수와, <code>+</code>, <code>*</code> 를 사용하였다.</p><p>여기서 <code>println</code> 은 (이전 글을 읽었다면) 이미 알고 있을 것이고, <code>+</code> 와 <code>*</code> 에 대해서 알아보자. <code>+</code> 는 둘 이상의 String (<code>&quot;</code> 로 감싸져있는 Text) 혹은 String 으로 표시할 수 있는 것 (대표적으로는 숫자) 을 하나의 String 이 되도록 <strong>합치는</strong> 것이다. 또한, <code>*</code> 는 숫자 두 개를 곱하는 것이다. :) 실행해보면 이 말이 무슨 뜻인지 알 수 있을 것이다.</p><p>(힌트1: “Cup noodle takes “ 와 숫자 4 과 “ min.” 을 순서대로 쓰면?)<br>(힌트2: 4 * 60 은?)</p><h4 id="lazy-val-def-를-사용한-명명"><a href="#lazy-val-def-를-사용한-명명" class="headerlink" title="lazy val, def 를 사용한 명명"></a>lazy val, def 를 사용한 명명</h4><p><code>lazy val</code>, <code>def</code> 를 사용한 Code 를 보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Naming</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> cooktimeInMin = <span class="number">4</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> secPerMin = <span class="number">60</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> cooktimeInSec = cooktimeInMin * secPerMin</span><br><span class="line">  println(<span class="string">"Cup noodle takes "</span> + cooktimeInMin + <span class="string">" min."</span>)</span><br><span class="line">  println(<span class="string">"In other words, it takes "</span> + cooktimeInSec + <span class="string">" sec."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Naming</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cooktimeInMin</span> </span>= <span class="number">4</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">secPerMin</span> </span>= <span class="number">60</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cooktimeInSec</span> </span>= cooktimeInMin * secPerMin</span><br><span class="line">  println(<span class="string">"Cup noodle takes "</span> + cooktimeInMin + <span class="string">" min."</span>)</span><br><span class="line">  println(<span class="string">"In other words, it takes "</span> + cooktimeInSec + <span class="string">" sec."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아까의 <code>val</code> 예시와 결과가 똑같지 않은가? 대체 차이점이 무엇인가?</p><p><code>val</code>, <code>lazy val</code>, <code>def</code> 의 차이점이 무엇인지 알기 위해서는 표현식의 평가가 어떻게 진행되는지를 알아야 한다.</p><h4 id="표현식의-평가-방법"><a href="#표현식의-평가-방법" class="headerlink" title="표현식의 평가 방법"></a>표현식의 평가 방법</h4><p>표현식의 평가 방법을 알기 위해 좀 더 복잡한 표현식을 사용해보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Evaluation</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> cooktimeInMin = &#123;</span><br><span class="line">    println(<span class="string">"Hi I'm cup noodle!"</span>)</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">"Let's start cooking!"</span>)</span><br><span class="line">  println(<span class="string">"Cup noodle takes "</span> + cooktimeInMin + <span class="string">" min."</span>)</span><br><span class="line">  println(<span class="string">"Oh, "</span> + cooktimeInMin + <span class="string">" min is soooo short!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 Code 를 실행시키면 어떤 값이 출력될까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hi I&apos;m cup noodle!</span><br><span class="line">Let&apos;s start cooking!</span><br><span class="line">Cup noodle takes 4 min.</span><br><span class="line">Oh, 4 min is soooo short!</span><br></pre></td></tr></table></figure><p>이번에는 <code>val</code> 을 <code>lazy val</code> 로 바꾼 뒤 실행시켜보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Evaluation</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> cooktimeInMin = &#123;</span><br><span class="line">    println(<span class="string">"Hi I'm cup noodle!"</span>)</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">"Let's start cooking!"</span>)</span><br><span class="line">  println(<span class="string">"Cup noodle takes "</span> + cooktimeInMin + <span class="string">" min."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Let&apos;s start cooking!</span><br><span class="line">Hi I&apos;m cup noodle!</span><br><span class="line">Cup noodle takes 4 min.</span><br><span class="line">Oh, 4 min is soooo short!</span><br></pre></td></tr></table></figure><p>혹시 차이점을 눈치 챘는가? <code>lazy val</code> 의 경우는 <code>cooktimeInMin</code> 으로 이름 붙인 표현식이 더 늦게 평가된다. 이 ‘더 늦게’가 언제인지 알겠는가? 눈치챘다면, 훌륭하다!</p><p>눈치채지 못한 사람들을 위해 (다른 말론, 거의 모든 사람들을 위해) 정확하게 알려주자면, <code>lazy val</code> 은 <strong>정의된 이름이 처음 사용될 때</strong> 평가된다. 흠? 그렇다면 <code>val</code> 은 언제 평가된단 말인가? <code>val</code> 의 경우에는 <strong>정의되자 마자</strong> 평가된다.</p><p>다음 코드를 실행해보면 이 차이가 왜 중요한 지 알 수 있다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Evaluation</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> noodleCookingTimeInMin = &#123;</span><br><span class="line">    <span class="type">Thread</span>.sleep(<span class="number">5000</span>)</span><br><span class="line">    println(<span class="string">"Hm... it's hard to calculate!"</span>)</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">"Let's start cooking!"</span>)</span><br><span class="line">  println(<span class="string">"To make hamburger, let's start with making patty!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Evaluation</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> noodleCookingTimeInMin = &#123;</span><br><span class="line">    <span class="type">Thread</span>.sleep(<span class="number">5000</span>)</span><br><span class="line">    println(<span class="string">"Hm... it's hard to calculate!"</span>)</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">"Let's start cooking!"</span>)</span><br><span class="line">  println(<span class="string">"To make hamburger, let's start with making patty!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하나는 요리를 시작하기도 전에 컵라면 제조법을 읽느라 5 초를 기다려야한다!</p><p>자, 그러면 <code>def</code> 는? 다음 Code 를 실행해보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Evaluation</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> cooktimeInMin = &#123;</span><br><span class="line">    println(<span class="string">"Hi I'm cup noodle!"</span>)</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> secPerMin = <span class="number">60</span></span><br><span class="line">  println(<span class="string">"Let's start cooking!"</span>)</span><br><span class="line">  println(<span class="string">"Cup noodle takes "</span> + cooktimeInMin + <span class="string">" min."</span>)</span><br><span class="line">  println(<span class="string">"Or, it takes "</span> + cooktimeInMin * secPerMin + <span class="string">" sec."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Evaluation</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cooktimeInMin</span> </span>= &#123;</span><br><span class="line">    println(<span class="string">"Hi I'm cup noodle!"</span>)</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> secPerMin = <span class="number">60</span></span><br><span class="line">  println(<span class="string">"Let's start cooking!"</span>)</span><br><span class="line">  println(<span class="string">"Cup noodle takes "</span> + cooktimeInMin + <span class="string">" min."</span>)</span><br><span class="line">  println(<span class="string">"Or, it takes "</span> + cooktimeInMin * secPerMin + <span class="string">" sec."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>val</code> 과 <code>lazy val</code> 의 차이점을 안 지금이라면 위 둘의 차이점도 알 수 있으리라 믿는다.</p><p>(힌트: <code>def</code> 는 사용될 때마다 …)</p><h4 id="var-을-사용한-정의"><a href="#var-을-사용한-정의" class="headerlink" title="var 을 사용한 정의"></a>var 을 사용한 정의</h4><p>다음 Code 를 실행시켜보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Definition</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cooktimeInMin = <span class="number">4</span></span><br><span class="line">  <span class="keyword">var</span> secPerMin = <span class="number">60</span></span><br><span class="line">  <span class="keyword">var</span> cooktimeInSec = cooktimeInMin * secPerMin</span><br><span class="line">  println(<span class="string">"Cup noodle takes "</span> + cooktimeInMin + <span class="string">" min."</span>)</span><br><span class="line">  println(<span class="string">"In other words, it takes "</span> + cooktimeInSec + <span class="string">" sec."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>흠? 또 다시 <code>val</code> 의 예시와 같지 않은가? 이번에도 표현식이 평가되는 방식이 다른 것인가? 안타깝게도 <code>var</code> 은 <code>val</code> 과 동일하게 정의하는 즉시 평가된다. 그렇다면 대체 무엇이 다를까? 아래 코드를 각각 실행시키려고 해 보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Definition</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Oh, it's mistake!</span></span><br><span class="line">  <span class="keyword">val</span> cooktimeInMin = <span class="number">2</span></span><br><span class="line">  cooktimeInMin = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Definition</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Oh, it's mistake!</span></span><br><span class="line">  <span class="keyword">var</span> cooktimeInMin = <span class="number">2</span></span><br><span class="line">  cooktimeInMin = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 <code>//</code> 부분은 주석 (Comment) 이라고 부르며, 코드 안에 설명을 써 놓을 때 사용하는 기능이다. 지금은 <code>val</code> 을 사용한 Code 를 돌리려고 시도했을 때는 실행에 실패하고, <code>var</code> 의 경우에는 성공적으로 실행된다는 점에만 주목하면 된다.</p><p>Scala 에서 <code>val</code>, <code>lazy val</code>, <code>def</code> 는 한 번 명명한 뒤로 그 이름을 다른 값을 위해 사용할 수 없다. 처음에 <code>val</code> 에서 설명했듯이, <code>val cooktimeInMin = 2</code> 라고 하였으면, (평가하는 과정을 제외하면) <code>cooktimeInMin</code> 을 사용하는 것은 그 뒤에서 <code>2</code> 를 사용하는 것과 마찬가지이다. <code>2</code> 에 다른 이름을 붙인 것에 지나지 않기 때문이다.</p><p>반면 <code>var</code> 을 사용하는 것은 얘기가 조금 다르다. 눈치 빠른 독자는 이 절의 제목이 <strong>명명</strong>이 아닌 <strong>정의</strong>라는 것을 알아챘을 것이다. <code>var</code> 을 사용하면 그 안의 내용물을 언제든지 바꿀 수 있는 <strong>변수</strong>를 <strong>정의</strong>한 뒤, 그 첫 값을 <code>=</code> 뒤에 있는 값으로 설정한다. 대다수의 많은 개발자들이 사용하는 언어들을 기준으로 말하면, <code>var</code> 은 일반적으로 변수를 정의하는 것이고 <code>val</code> 은 <code>const</code>, <code>final</code> 등의 Keyword 를 붙여서 상수 (혹은 그 비슷한 것) 를 정의하는 것이다.</p><h4 id="명명과-정의"><a href="#명명과-정의" class="headerlink" title="명명과 정의?"></a>명명과 정의?</h4><p>이 쯤에서 의문이 드는 개발자도 있을 것이다.</p><blockquote><p>그러면 왜 변수에 해당하는 것은 하나뿐이고 상수에 해당하는 것은 세 개나 있지? 개발할 때 변수를 더 많이 쓰지 않나?</p></blockquote><p>결론만 말하자면, Scala 에서는 <code>val</code>, <code>lazy val</code>, <code>def</code> 를 사용해서 정의하는 것이 기본이고, 어쩔 수 없이 필요할 경우 (정말 중요한 성능의 문제라거나 …) 에만 한정적으로 <code>var</code> 을 사용한다. 이는 Scala 뿐만이 아니라 많은 Programming 언어에서 Bug 를 피하기 위한 Coding style 중에 하나이다.</p><ul><li><a href="http://www.bfilipek.com/2016/12/please-declare-your-variables-as-const.html" target="_blank" rel="external">C++</a></li><li><a href="https://softwareengineering.stackexchange.com/questions/98691/excessive-use-final-keyword-in-java" target="_blank" rel="external">Java</a></li><li><a href="https://eslint.org/docs/rules/prefer-const" target="_blank" rel="external">JavaScript</a></li><li>기타 등등…</li></ul><h4 id="다음에는…"><a href="#다음에는…" class="headerlink" title="다음에는…"></a>다음에는…</h4><p>지금까지 Scala 에서 표현식을 사용하는 방법과 표현식의 값을 명명하는 방법, 그리고 변수를 정의하는 방법에 대해서 알아보았다. 다음 글에서는 순차적인 Code 를 작성하는 방법과 Code 를 작게 쪼개는 방법에 대해서 알아볼 것이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;모든 Programming 언어는 값 (Value) 을 명명 (Naming) 할 수 있다. 값에 이름을 붙이는 것은 복잡한 계산의 결과가 무엇을 뜻하는지 이해하기 쉽게 해준다. 뿐만 아니라 값에 이름을 붙이는 것은 동일한 계산을 Computer 
      
    
    </summary>
    
      <category term="scala" scheme="https://www.holaxprogramming.com/categories/scala/"/>
    
    
  </entry>
  
  <entry>
    <title>Scala로 시작하는 Hello World</title>
    <link href="https://www.holaxprogramming.com/2017/11/14/scala-hello-world/"/>
    <id>https://www.holaxprogramming.com/2017/11/14/scala-hello-world/</id>
    <published>2017-11-14T06:20:00.000Z</published>
    <updated>2018-04-27T06:49:11.206Z</updated>
    
    <content type="html"><![CDATA[<p>Scala 는 Java 의 디자인 및 기능을 현대의 PL 연구 결과에 맞게 확장하는 방법에 대해 연구한 결과로 만들어진 언어이다. Java 와 마찬가지로 JVM (Java Virtual Machine) 위에서 작동하는 언어지만, Java 8 이전의 Java 와는 달리, Object Oriented Programming Style 과 Functional Programming Style 을 모두 훌륭하게 지원하고 있는 언어이다.</p><h4 id="Scala-설치하기"><a href="#Scala-설치하기" class="headerlink" title="Scala 설치하기"></a>Scala 설치하기</h4><p>이 과정은 컴퓨터 내에서 Scala 를 쓰기 위한 과정이다. 이 글 안에서는 편의성을 위해 <a href="https://scastie.scala-lang.org/" target="_blank" rel="external">Scastie</a> 를 사용하여 Web compiler 환경에서 작업하는 것을 기준으로 할 것이지만, 이후의 내용을 따라하기 위해 미리 설치해 놓는 것도 나쁘지 않다.</p><ol><li>위에서 말했듯이, Scala 는 JVM 위에서 작동하는 언어이다. 따라서 JVM (혹은 Java) 를 먼저 설치해야 한다. 아래 Link 에 접속해서 JVM 을 설치할 수 있다. 이미 JDK (Java Development Kit) 8 이상이 설치되어 있다면 이 단계는 넘어가도 된다.<ul><li><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></li></ul></li><li>또한 Scala 를 편집하고 Compile 할 Environment 가 필요하다. 많이 사용되는 것은 IntelliJ IDE 이다. 아래 Link 에서 IntelliJ community edition 을 받을 수 있다. 이미 IntelliJ 가 설치되어 있다면 이 단계는 넘어가도 된다.<ul><li><a href="https://www.jetbrains.com/idea/download/" target="_blank" rel="external">https://www.jetbrains.com/idea/download/</a></li><li>Community 라고 써져있는 것을 받자. 그쪽이 무료 버전이고, Ultimate 의 경우에는 체험판만을 제공한다.</li><li>IntelliJ 를 쓰지 않고 싶다면 SBT 를 설치하여야 한다. SBT 는 Scala 용 Build tool 중에 하나로, IntelliJ 외의 다른 Editor (Vim, Emacs, …) 들에서 Scala 를 쓰고 싶다면 사용하여야 하는 Tool 이다. SBT 에 대해서는 다른 글에서 설명하도록 할 것이다.</li></ul></li><li>이제 IntelliJ 를 킨다. Scala 는 IntelliJ 에서 Plugin 을 설치하는 것으로 설치된다. 아래 Link 를 따라서 IntelliJ 에 Plugin 을 설치할 수 있다. 설치해야하는 Plugin 은 <a href="https://plugins.jetbrains.com/plugin/1347-scala" target="_blank" rel="external">Scala</a> Plugin 이다.<ul><li><a href="https://www.jetbrains.com/help/idea/installing-updating-and-uninstalling-repository-plugins.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/installing-updating-and-uninstalling-repository-plugins.html</a></li><li>내용을 번역하자면,<blockquote><ol><li>Setting Dialog 를 Ctrl-Alt-S 를 누르거나 Menu 의 Settting Icon 을 눌러 연다.</li><li>왼쪽의 Plugins 라고 써져있는 창을 연다.</li><li>Install JetBrains plugin 혹은 Browse repositories 라고 써져있는 Button 을 누른다.</li><li>원하는 Plugin 에 오른쪽 Click 을 하고 Download and Install 을 누른다.</li><li>확인한다.</li><li>Install JetBrains plugin 혹은 Browse repositories 창을 닫는다.</li><li>OK 를 눌러 Setting Dialog 를 빠져나가고, 설정을 저장한다. IntelliJ 를 다시 켜서 Plugin 이 적용되도록 한다.</li></ol></blockquote></li></ul></li><li>이제 File -&gt; New -&gt; Project 를 눌러 Project 생성 창을 띄우고, 왼쪽에서 Scala, 오른쪽에서 Scala (혹은 SBT) 를 고른 뒤, Project 이름을 정한다. 그리고 오른쪽의 Scala SDK 창에서 Create button 을 눌러 Scala 를 (최신 버전을 골라서) 설치한다. SDK 가 설치된 것을 확인하였으면, Finish 를 눌러 Project 를 생성한다.</li><li>이제 Scala 를 설치하는데 성공하였다!</li></ol><p>잠깐, 아직 설치한 Scala 를 쓸 것은 아니다. 미리 받아놓는 것도 나쁘지는 않지만, 지금 꼭 받아야할 필요는 없으니 여유가 날 때 받아놓도록 하자.</p><h4 id="Scala-를-Web-에서-사용하기"><a href="#Scala-를-Web-에서-사용하기" class="headerlink" title="Scala 를 Web 에서 사용하기"></a>Scala 를 Web 에서 사용하기</h4><p>위와 같은 과정을 거쳐서 Scala 를 설치하는 것은 번잡할 뿐더러 이런저런 Setting 에 의해서 Code 가 정상적으로 작동하지 않을 수도 있다. 따라서 File 을 여러 개 만들 필요가 없는 간단한 경우의 예시는 다음 Link 의 Webpage 에서 Code 를 작성하고 Compile 시킨 뒤, 실행시킬 것이다.</p><ul><li><a href="https://scastie.scala-lang.org/MzWqJ6eEQxuEKYk8F25grg" target="_blank" rel="external">Scastie</a></li></ul><p>위 Link 에 접속해보면 이미 간단한 Code 가 써져있는 것을 볼 수 있다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="string">"Hello"</span>, <span class="string">"World"</span>).mkString(<span class="string">""</span>, <span class="string">", "</span>, <span class="string">"!"</span>)</span><br></pre></td></tr></table></figure><p>이 Code 를 실행시키기 위해서는 Run 이라고 써져있는 Button 을 누르면 된다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="string">"Hello"</span>, <span class="string">"World"</span>).mkString(<span class="string">""</span>, <span class="string">", "</span>, <span class="string">"!"</span>) <span class="comment">// Hello, World!: java.lang.String</span></span><br></pre></td></tr></table></figure><p>실제로는 <code>//</code> 이 없이 바로 결과값이 Code 의 옆에 표시될 것이다. 이제 Hello World 를 출력했으니 끝난 것인가? 아니다. 위 Code 는 Hello World 를 출력하지는 않았다. 다음 절에서 실제로 Hello World 를 출력하는 Code 를 작성해보고, 위 Code 와 비교해보도록 하자.</p><h4 id="Scala-로-시작하는-Hello-World"><a href="#Scala-로-시작하는-Hello-World" class="headerlink" title="Scala 로 시작하는 Hello World"></a>Scala 로 시작하는 Hello World</h4><p>이 세상 모든 Program 은 <strong>시작 지점</strong>이 필요하다. 어디서부터 Code 를 읽어서 실행할 지를 모르면, Program 은 무슨 Code 를 실행해야 할 지 알 수가 없을 것이다. 이 <strong>시작지점</strong>을 영어로는 Entry point 라고 부른다.<br>Scala 의 경우에는 다음과 같은 Entry point 들이 있다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object 뒤에 나오는 `Basics` 부분에는 아무 Text 나 들어가도 된다.</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Basics</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// Codes</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object 뒤에 나오는 `Simple` 부분에는 아무 Text 나 들어가도 된다.</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Simple</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Codes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 두 개의 Entry point 는 <code>args</code> 를 사용하는 방법 빼고 동일하다. 이게 무슨 말인지는 다른 글에서 자세히 보도록 하고, 여기서는 우선 타수가 더 적은 두번째 Entry point 를 사용하도록 하자.</p><p>Scastie 에서 Entry point 를 제대로 사용하기 위해서는 Menu 의 Worksheet 부분에 불이 들어오지 않아야 한다. 만일 불이 들어와 있다면 Worksheet 부분을 Click 해서 불을 끄도록 하자.</p><p>이제, 아래와 같은 Code 를 실행하면 Hello World 를 화면에 찍어볼 수 있다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Simple</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  println(<span class="string">"Hello World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이번에는 출력 결과가 Code 옆에 나타나는게 아니라 화면 밑의 검은 창 (Console) 에 나타날 것이다. <code>println</code> 은 그 뒤에 들어간 String (<code>&quot;Hello World!&quot;</code> 와 같이 <code>&quot;</code> 로 감싸져 있는 Text) 을 Console 에 출력하는 역할을 한다. 이름의 <code>print</code> 는 출력한다는 뜻인 걸 알겠는데, 맨 뒤의 <code>ln</code> 은 무엇일까? 이것은 line 의 줄임말로 한 줄을 넘기는 (Editor 에서 Enter key 를 치는) 효과를 가지고 있다. 정확한 효과가 궁금한 사람들은 아래의 코드를 실행해보라.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Simple</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  println(<span class="string">"Hello World!"</span>)</span><br><span class="line">  print(<span class="string">"Hello"</span>)</span><br><span class="line">  print(<span class="string">"World!"</span>)</span><br><span class="line">  println(<span class="string">"THIS IS SCALA!!!!!!!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="출력과-결과값-비교하기"><a href="#출력과-결과값-비교하기" class="headerlink" title="출력과 결과값 비교하기"></a>출력과 결과값 비교하기</h4><p>아까 위에서</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="string">"Hello"</span>, <span class="string">"World"</span>).mkString(<span class="string">""</span>, <span class="string">", "</span>, <span class="string">"!"</span>)</span><br></pre></td></tr></table></figure><p>와 같은 Code 를 보았을 것이다. Worksheet 에 불이 꺼진 채로 이 Code 를 돌리면 Compile Error 가 발생하기 때문에, 아래와 같이 Entry point 안에 넣어서 실행해보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Simple</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="type">List</span>(<span class="string">"Hello"</span>, <span class="string">"World"</span>).mkString(<span class="string">""</span>, <span class="string">", "</span>, <span class="string">"!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>무슨 일이 벌어지는가? 다음과 같은 코드 또한 실행해보고 두 결과의 차이점이 무엇인지 생각해보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Simple</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  println(<span class="type">List</span>(<span class="string">"Hello"</span>, <span class="string">"World"</span>).mkString(<span class="string">""</span>, <span class="string">", "</span>, <span class="string">"!"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>화면에 출력되는 것은 실제로 프로그램을 작동시켰을 때 눈에 보이는 것들이고, Code 의 결과값은 눈에 보이지 않고, Program 내부에서만 알 수 있는 값이다.</p><h4 id="다음에는…"><a href="#다음에는…" class="headerlink" title="다음에는…"></a>다음에는…</h4><p>지금까지 Scala 를 설치하는 방법, Scala 를 웹에서 사용하는 방법, Scala 의 Entry point 에 대해서 알아보았고, Scala 에서 Hello world 를 찍는 코드를 실행해보았다. 다음 글에서는 Scala 에서 값에 이름을 붙이는 방법에 대해서 알아볼 것이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Scala 는 Java 의 디자인 및 기능을 현대의 PL 연구 결과에 맞게 확장하는 방법에 대해 연구한 결과로 만들어진 언어이다. Java 와 마찬가지로 JVM (Java Virtual Machine) 위에서 작동하는 언어지만, Java 8 이전
      
    
    </summary>
    
      <category term="scala" scheme="https://www.holaxprogramming.com/categories/scala/"/>
    
    
  </entry>
  
  <entry>
    <title>Node.js의 실행 환경을 지탱하는 도구들</title>
    <link href="https://www.holaxprogramming.com/2017/10/30/node-environments/"/>
    <id>https://www.holaxprogramming.com/2017/10/30/node-environments/</id>
    <published>2017-10-30T01:07:11.000Z</published>
    <updated>2018-04-27T06:49:11.205Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript(JavaScript)가 Ajax, JSON, jQuery가 등장함으로서 널리 사용 되어지고 우리에게 익숙해졌다면 서버의 실행 환경을 위한 Node.js의 등장으로 JavaScript는 황금기를 맞이하게 되었습니다. 이 글에서는 Node.js를 시작하기 전에 시스템에서 필요한 Node.js의 실행환경에 대해 이야기 합니다.</p><p><img src="https://nodejs.org/static/images/logos/nodejs-new-pantone-black.png" width="400"></p><h2 id="Node-js와-npm"><a href="#Node-js와-npm" class="headerlink" title="Node.js와 npm"></a>Node.js와 npm</h2><p>Javascript가 황금기를 맞이하게 되는 결정적인 이유는 Node.js를 통해 Back-end에서도 동작하는 런타임 환경을 제공하게 된 것 뿐만 아니라 Node.js의 패키지 도구인 <code>npm</code>이 거대한 오픈소스 생태계로 발전한 것이 가장 결정적인 역할을 한 것으로 보인다.</p><p>npm은 JavaScript 패키지의 저장소일 뿐만 아니라 시스템에서 패키지 관리할 수 있는 다양한 명령어를 제공한다.</p><blockquote><p>npm은 JVM 진영의 Maven Central, jCenter나 Python 진영의 PYPI와 유사하다.</p></blockquote><p>우리는 npm을 통해서 Back-end, Front-end 구분 없이 JavaScript 기반으로 개발된 다양한 패키지를 사용 할 수 있고, 먼저 npm을 사용하기 위해서는 Node.js를 시스템에 설치해야 한다.</p><p>운영체제에 Node.js가 설치되어 있지 않다면, 아래와 같이 Terminal에서 Node를 설치하도록 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install node</span><br></pre></td></tr></table></figure><p>설치가 완료되면 Node.js와 npm의 버전을 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">$ npm -v</span><br></pre></td></tr></table></figure><p>npm의 아래의 옵션을 통해 <code>yarn</code>, <code>gulp</code>를 시스템의 전역에서 사용할 수 있도록 설치할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g yarn gulp</span><br></pre></td></tr></table></figure><h4 id="npm의-주요-명령어들"><a href="#npm의-주요-명령어들" class="headerlink" title="npm의 주요 명령어들"></a>npm의 주요 명령어들</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm update</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save requests</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev babel babel-cli babel-core babel-preset-env babel-register</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall --save requests</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm list</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://docs.npmjs.com/cli/npm" target="_blank" rel="external">https://docs.npmjs.com/cli/npm</a></p></blockquote><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><p>JSON Document로 만들어지는 <code>package.json</code>은 Node.js 프로젝트에서 아주 중요한 역할을 한다. 프로젝트의 기본 정보를 시작으로 의존되는 패키지와 버전을 지정할 수 있다.</p><blockquote><p><a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="external">https://docs.npmjs.com/files/package.json</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;papago&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Papago translation API with ES6&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;request&quot;: &quot;^2.83.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;babel&quot;: &quot;^6.23.0&quot;,</span><br><span class="line">    &quot;babel-cli&quot;: &quot;^6.23.0&quot;,</span><br><span class="line">    &quot;babel-core&quot;: &quot;^6.23.0&quot;,</span><br><span class="line">    &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;,</span><br><span class="line">    &quot;babel-register&quot;: &quot;^6.23.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;compile&quot;: &quot;babel lib -d build --presets env&quot;,</span><br><span class="line">    &quot;lint&quot;: &quot;eslint lib/**/*.js test/**/*.js --ignore-path .gitignore&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;npm run compile &amp;&amp; mocha --require babel-register&quot;,</span><br><span class="line">    &quot;coverage&quot;: &quot;istanbul cover mocha -- --require babel-register&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>package.json</code>에 정의된 script는 아래와 같이 <code>npm run</code> 명령으로 실행하며,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run compile</span><br></pre></td></tr></table></figure><p><code>test</code>, <code>start</code> 명령은 <code>run</code>을 생략할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="built_in">test</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm start</span><br></pre></td></tr></table></figure><blockquote><p>웹 애플리케이션인 경우 main에 지정된 경로를 통해서 start명령을 통해 서버를 실행할 수 있다.</p></blockquote><h4 id="npm-모듈-배포하기"><a href="#npm-모듈-배포하기" class="headerlink" title="npm 모듈 배포하기"></a>npm 모듈 배포하기</h4><p>npm 저장소에 자신의 모듈을 배포하는 방법은 비교적 쉬운 편이다.</p><p><code>사용자 추가</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm adduser</span><br></pre></td></tr></table></figure><p><code>테스트</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ../install-test</span><br><span class="line">$ <span class="built_in">cd</span> ../install-test</span><br><span class="line">$ npm install ../my-npm-module/</span><br></pre></td></tr></table></figure><p><code>배포</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm publish</span><br></pre></td></tr></table></figure><h2 id="Node-js의-버전관리-도구-nvm"><a href="#Node-js의-버전관리-도구-nvm" class="headerlink" title="Node.js의 버전관리 도구 nvm"></a>Node.js의 버전관리 도구 nvm</h2><p>한 시스템에서 다양한 프로젝트 그리고 프로젝트별로 Node의 버전을 다르게 사용하는 경우가 있다. 이 의미는 A 프로젝트에서 Node의 v4 버전을 사용해 유지 보수하면서 B 프로젝트에서는 v6 버전을 사용하는 것을 말한다. 뿐만 아니라 Node REPL에서도 지정한 버전을 따르게 된다.</p><h4 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h4><figure c