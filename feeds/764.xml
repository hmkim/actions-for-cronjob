<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by 이한울 on Medium]]></title>
        <description><![CDATA[Stories by 이한울 on Medium]]></description>
        <link>https://medium.com/@kkak10?source=rss-c92452484f56------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*B7kacvP7lpV8RutKSGLnFA.jpeg</url>
            <title>Stories by 이한울 on Medium</title>
            <link>https://medium.com/@kkak10?source=rss-c92452484f56------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Sun, 12 May 2019 22:37:33 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@kkak10" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[Lexical Environment]]></title>
            <link>https://medium.com/@kkak10/lexical-environment-4e0cffcad98d?source=rss-c92452484f56------2</link>
            <guid isPermaLink="false">https://medium.com/p/4e0cffcad98d</guid>
            <category><![CDATA[lexical-environment]]></category>
            <category><![CDATA[excutioncontext]]></category>
            <category><![CDATA[javascript]]></category>
            <dc:creator><![CDATA[이한울]]></dc:creator>
            <pubDate>Sun, 21 Jan 2018 00:19:25 GMT</pubDate>
            <atom:updated>2018-01-21T00:19:25.695Z</atom:updated>
            <content:encoded><![CDATA[<p>Note: 해당 글은 ECAM5스팩을 기준으로 하고 있습니다. ECMA2015에서는 해당 부분에 대부분이 변경된것으로 알고 있습니다.</p><p>ECMA5(ECMA-262) 스팩에서 정의된 스팩인데 이전에는 이와 비슷하지만 다르게 설계되었다고 한다.</p><p>사실 이 부분은 일반적인 자바스크립트 개발자를 위한 내용이라기보다 자바스크립트 엔진 개발자들을 위한 스팩이라고 볼 수 있다.</p><p>엔진 개발자들이 해당 스팩에 맞춰서 구현해야하기 때문이다.</p><p>Lexical Environment는 Execution Context (이하 EC)와 관련이 있는데 Lexical Environment를 설명하기 위해서는 EC에 대한 개념이</p><p>필수적이기 때문에 EC를 먼저 설명하겠다.</p><p>EC는 이름 그대로 실행 환경인데 자바스크립트 런타임에서 엔진이 만들어주는 런타임 유효 범위라고 할 수 있다.</p><p>모든 자바스크립트 코드를 실행하기 위해서는 EC가 필요한데 코드를 실행하다보면 여러 Context가 만들어진다.</p><p>EC를 만드는 단위는 Global Code, Function Code, Eval Code 이렇게 3개인데 이런식으로 나누는 이유는 각각 코드를 초기화 할때</p><p>초기화 과정이 다르기 때문이다.</p><pre>ExecutionContext = {<br>  LexicalEnvironment: [Lexical Environment],<br>  VariableEnvironment: [Lexical Environment],<br>  ThisBinding: [object]<br>}</pre><p>EC는 위와 같이 생겼다.</p><p>Value에 있는 []는 Type을 뜻한다.</p><p>EC 안에는 3개의 프로퍼티가 있는데 LexicalEnvironment, VariableEnvironment, ThisBinding 이다.</p><p>LexicalEnvironment와 VariableEnvironment는 LexicalEnvironment 타입을 가지고 ThisBinding은 object타입을 가지는데</p><p>LexicalEnvironment는 현재 실행 환경에 대한 변수나 참조에 대한 정보를 가지게 되는데 이는 곧 현재 Context에서 변수나 어떤 값들 (자원)을 가져올때 어디서 가져올 것이냐에 대한 답이다.</p><p>VariableEnvironment는 Lexical Environment와 같은 값이 들어가게 되는데 이 둘을 나눈 이유는 이후에 설명하도록 하겠다.</p><p>그리고 ThisBinding은 현재 Context에서의 This를 가르키게 된다.</p><pre>Lexical Environment = {<br>  enviroment record: {},<br>  outter enviroment reference: {}<br>}</pre><p>Lexical Environment 타입은 위와 같은 형태이다.</p><p>enviroment record는 현재 Context에서 선언된 함수 혹은 변수들이 저장되는 공간.</p><p>outter Environment reference는 현재 Context를 기준으로 외부 Context를 참조하는 공간이다. 만약 유효범위가 중첩되어 있을때 상위 유효범위를 참조할 수 있어야 하는데 상위 유효범위를 참조하기 위해서 존재하는 property이다. 그렇기 때문에 record가 아닌 reference라는 이름이 붙여졌다.</p><p>enviroment record는 Declartion와 object 두 가지 타입으로 되어 있는데</p><p>DeclartionEnvironmentRecord는</p><pre>DeclartionEnvironmentRecord = {<br>  a: 33,<br>  b: &#39;Hello World&#39;<br>}</pre><p>와 같이 Object안에 실제 값들이 저장되어 있는 형태이고</p><p>ObjectEnvironmentRecord는</p><pre>ObjectEnvironmentRecord = {<br>  bindObject: [object]<br>}</pre><p>와 같이 단순히 해당 Context 내부를 바인딩 해주는 역할만 하게 된다.</p><p>ES3까지는 DeclartionEnvironmentRecord는 존재하지 않았는데 ES5 스팩에서 추가된 속성이다.</p><p>아마 현재 context의 값을 참조를 통해서 가져오는 형태가 성능상으로나 매커니즘상으로 부합하지 않다고 생각해서</p><p>DecleartionEnvironmentRecord를 만들어서 바로 가져올 수 있도록 만든게 아닌가 싶다.</p><p>그게 문맥상이나 매커니즘상으로 훨씬 더 잘 맞는 형태이니깐.</p><p>만들어진 Context는 내부에서 Stack형태로 저장되게 되는데 먼저 생성된 Context가 아래에 쌓이게 되고 최근에 만들어진 Context가</p><p>위쪽에 쌓이게 된다. 그리고 함수실행을 마치거나 GC가 판단하여 Context를 쓸 일이 없게 되면 Context를 Stack에서 제거하게 된다.</p><p>엔진이 EC를 어떻게 만들어야 하는가에 대한 스팩이 Lexical Environment이다.</p><p>그래서 Lexical Environment와 EC는 깊은 관련이 있다.</p><p>위에서 Execution Context는 3가지 타입으로 나눠서 초기화 된다고 했다.(Global Code, Function Code, Eval Code)</p><p>먼저 Global Code 먼저 살펴보면,</p><pre>Global Execution Context<br>{<br>  LexicalEnvironment: GlobalEnv,<br>  VariableLexicalEnvironment: GlobalEnv,<br>  ThisBinding: window<br>}</pre><p>위와 같이 생겼다.</p><p>GlobalEC의 LexicalEnvironment와 VariableLexicalEnvironment는 같은 GlobaleEnv를 참조하고 있다. (이 부분은 나중에 설명할 예정이다.)</p><p>그리고 ThisBinding은 window를 참조하고 있는데 브라우저의 전역 객체가 Window이기 때문이다.</p><p>만약 브라우저가 아닌 다른 환경(Node.js)일 경우에는 Global 같은 객체가 들어갈 것이다.</p><p>그리고 GlobalEC의 LexicalEnvironment가 참조하는 GlobalEnv를 보면</p><pre>GlobalEnv<br>{<br>  ObjectLexicalRecord: {<br>    ObjectBinding: Window,<br>  },<br>  OutterEnvironmentReference: <strong>null</strong>,<br>}</pre><p>위와 같이 되어 있는데 ObjectLexicalEnvironment의 ObjectBinding 프로퍼티가 Window를 보고있는데 GlobalEC의 ThisBinding도 Window를 보고 있다.</p><p>저 ObjectLexicalEnvironment에 대해 이해하는 관점이 선언된 변수 혹은 함수를 가져오고 만드는게 아니고 미리 저 Window를 넣어놓고 그 후에 선언된 변수와 함수를 가져와서 저 ObjectLexicalRecord에 넣어주는 형태이다.</p><p>전자와 같이 생각하면 전역에서 변수를 선언했을때 전역객체의 프로퍼티에서 변수를 찾는 일이 불가능하다. 그렇기 때문에 후자와 같이 이해를 해야한다.</p><p>Global Code와 Function Code를 나눠서 EC를 생성하는 이유중에 하나가 될 수 있을 것같다. 물론 기본적으로 Global Code는 Base가 되는 EC가 되므로 다르게 Init하는게 맞다.</p><p>전역에서 변수를 선언하면 그 변수는 GlobalEnv의 ObjectLexicalEnvironment의 ObjectBinding에서 찾게되고 ThisBinding 역시 Window를 바라보고 있기때문에 전역에서 선언한 변수가 Global Object의 프로퍼티로 찾을 수 있게 되는 것이다.</p><p>OutterEnvironmentReference는 Global이므로 상위 EC가 없다. 그래서 null이 들어간다.</p><p>그리고 다음으로 Function Code의 EC를 보도록 하자.</p><p>Function Code의 EC가 만들어 질때는 EC Stack에 Gloabel EC가 생성되어 있다.</p><pre><strong>function </strong>sum(x, y){<br>  <strong>var </strong>result = x + y;<br>  <strong>var </strong>etc = <strong>function</strong>(){<br>    console.log(&#39;good&#39;);<br>  }<br>  <strong>function </strong>msg(){<br>    <strong>return </strong>result;<br>  }<br>}<br>sum(10, 20);</pre><p>위와 같은 코드가 있다고 가정해보자.</p><p>자바스크립트 엔진이 sum(10, 20)을 만나면 Function에 대한 EC를 생성하게 된다.</p><p>그리고 우선적으로 this를 찾아서 바인딩 해주게 되는데 엔진이 this를 바인딩하는 메커니즘은 함수 실행시에 좌항을 보는 것이다.</p><p>만약 저 함수가 메서드로 실행된다면 메서드를 가지고 있는 객체가 this에 바인딩 될 것이고 new를 붙여서 실행한다면 해당 함수 자체가 this가 될 것이다.</p><p>위 코드에서는 좌항에 아무것도 없기 때문에 저 EC의 ThisBInding은 null이 될 것이다.</p><p>EC의 ThisBinding이 null일 경우에는 Global EC를 참조하게 된다.</p><p>브라우저에서는 Window가 될 것이다.</p><p>단, “use strict” 모드에서는 Global EC가 아닌 null이 그대로 들어가게 된다.</p><p>그리고 이제 EC의 Lexical Environment를 넣어줘야한다.</p><p>sum의 LE는</p><pre>{<br>     DecleartionEnvironmentRecord: {</pre><pre>},<br>     OutterEnvironmentReference: null<br>}</pre><p>위와 같이 구성되는데 첫번째로 파라미터로 들어오는 x와 y가 저 곳에 들어가게 된다.</p><pre>{<br>     DecleartionEnvironmentRecord: {<br>         x: 10,<br>         y: 20<br>     },<br>     OutterEnvironmentReference: null<br>}</pre><p>와 같은 형태가 될 것이고 그 다음으로는 함수 내부에 선언된 것들을 가져온다.</p><p>처음으로는 함수선언을 먼저 가져온다.</p><pre>{<br>     DecleartionEnvironmentRecord: {<br>         x: 10,<br>         y: 20,<br>         msg: Function Reference<br>     },<br>     OutterEnvironmentReference: null<br>}</pre><p>그리고 함수 내부에서 사용할 수 있는 arguments를 세팅한다.</p><pre>{<br>  DecleartionEnvironmentRecord: {<br>    x: 10,<br>    y: 20,<br>    msg: Function Reference,<br>    arguments: Arguments Object,<br>  },<br>  OutterEnvironmentReference: <strong>null</strong>,<br>};</pre><p>그리고 선언된 변수들을 가져오게 된다.</p><p>그리고 함수 내부에서 사용할 수 있는 arguments를 세팅한다.</p><pre>{<br>  DecleartionEnvironmentRecord: {<br>    x: 10,<br>    y: 20,<br>    msg: Function Reference,<br>    arguments: Arguments Object,<br>    result: <strong>undefined</strong>,<br>    etc: <strong>undefined</strong>,<br>  },<br>  OutterEnvironmentReference: <strong>null</strong>,<br>}</pre><p>이렇게 되는데 undefined이고 msg는 Function Reference를 참조하는 이유는 함수 선언식과 함수 표현식에 대한 차이이다.</p><p>이 부분에 대한 설명은 생략하도록 하겠다.</p><p>자 이제 sum의 EC의 LE의 DecleationEnvironmentRecord의 세팅이 완료 되었는데</p><p>이때 눈치가 빠른 사람은 아! 했을 수 있다.</p><p>이게 바로 호이스팅의 실체이기 때문이다.</p><p>런타임에서 실제적인 실행 전에 EC를 구성하는 단계에서 이런식으로 호이스팅이 일어나게 된다.</p><p>그리고 함수가 실행된다.</p><p>이제 OutterEnvironmentReference를 세팅해준다.</p><p>OutterEnvironmentReference는 스팩을 보면 가까운 상위 EC를 참조한다고 되어있는데 현재의 경우에서는 상위 EC가 Global EC이다.</p><p>그래서</p><pre>{<br>  DecleartionEnvironmentRecord: {<br>    x: 10,<br>    y: 20,<br>    msg: Function Reference,<br>    arguments: Arguments Object,<br>    result: 30,<br>    etc: <strong>undefined</strong>,<br>  },<br>  OutterEnvironmentReference: GloabalEC,<br>}</pre><p>와 같이 된다.</p><p>이제 var result = x + y;를 만나서 계산한 후에</p><pre>{<br>  DecleartionEnvironmentRecord: {<br>    x: 10,<br>    y: 20,<br>    msg: Function Reference,<br>    arguments: Arguments Object,<br>    result: 30,<br>    etc: <strong>undefined</strong>,<br>  },<br>  OutterEnvironmentReference: GloabalEC,<br>}</pre><p>이 되고</p><pre><strong>var </strong>etc = <strong>function</strong>(){<br>  console.log(&quot;good&quot;);<br>}</pre><p>를 만나서</p><pre>{<br>  DecleartionEnvironmentRecord: {<br>    x: 10,<br>    y: 20,<br>    msg: Function Reference,<br>    arguments: Arguments Object,<br>    result: 30,<br>    etc: Function Reference,<br>  },<br>  OutterEnvironmentReference: GloabalEC,<br>}</pre><p>이 된다.</p><p>이런식으로 Function을 실행할때 EC가 생성되는 과정을 보았다.</p><p>만약 이제 상위 EC에 있는 값을 사용하려 할때는 어떻게 하는가 ? 에 대해 궁금해 할 수있는데 이때 사용되는것이 OutterEnvironmentReference이다.</p><p>이때 저 곳에 참조된 값을 사용하여서 상위 Scope로 찾아올라가게 된다.</p><p>이 과정이 바로 Scope Chain이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4e0cffcad98d" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Iterator와 Iterable]]></title>
            <link>https://medium.com/@kkak10/iterator%EC%99%80-iterable-9d9de828cca5?source=rss-c92452484f56------2</link>
            <guid isPermaLink="false">https://medium.com/p/9d9de828cca5</guid>
            <category><![CDATA[iterables]]></category>
            <category><![CDATA[iterators]]></category>
            <category><![CDATA[javascript]]></category>
            <dc:creator><![CDATA[이한울]]></dc:creator>
            <pubDate>Sat, 20 Jan 2018 23:50:08 GMT</pubDate>
            <atom:updated>2018-01-20T23:50:08.871Z</atom:updated>
            <content:encoded><![CDATA[<p>ECMA2015에서 추가된 개념중에 Iterable이라는 개념이 있다.</p><p>이 개념은 Iterable이라는 말 그대로 반복 가능한 객체를 뜻한다.</p><p>ECMA2015에서는 Symbol을 이용한 프로토콜이 추가되었는데,</p><p>이는 프로토콜 기반의 프로그래밍을 가능하게 한다.</p><p>덕타이핑을 이용하여서 Symbol중 Symbol.iterator를 key로 가지고 있는 객체를 iterable한 객체로 본다.</p><p>Symbol.iterator을 key로 가지고 있는 객체는 해당 Key의 함수를 실행할 경우 next함수를 구현한 iterator를 리턴해야 한다.</p><p>예제 코드를 살펴보자.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/661e0c7a95ca97308f794967c9e6f5b9/href">https://medium.com/media/661e0c7a95ca97308f794967c9e6f5b9/href</a></iframe><ol><li>iterable 변수는 Symbol.iterator를 구현하고 있기 때문에 iterable한 변수이다.</li><li>Symbol.iterator 메서드에서는 next 메서드를 구현한 iterator를 리턴해야 한다.</li><li>Symbol.iterator 메서드의 구현 내용은 iteratorData라는 배열의 내용을 next 메서드를 실행 할때마다 하나씩 리턴해주는 메서드이다.</li><li>next 메서드는 {value : 값, done: Boolean}을 리턴해야하는데 이는 규칙이다.</li><li>하단의 for..of문은 iterable한 값을 위한 syntax인데 of의 오른쪽에 iterable한 값을 넣고 왼쪽의 변수로 받을 수 있다.</li><li>for..of 문에서는 리턴 되는 done 값이 true일 경우 loop를 멈춘다.</li></ol><p>기본적인 동작은 이렇게 진행된다.</p><p>JavaScript의 빌드인 Object들 중에서도 iterable한 Object들이 있다.</p><p>예를 들면 String, Map, Set, Array, object literal 같은 Object들은 iterable하다</p><p>따라서 for..of문으로 동작 시킬 수 있다.</p><h3>String</h3><pre>{<br>  let str = &quot;Hello Iterator&quot;;<br>  <br>  //str 문자열이 문자 1개씩 리턴된다.<br>  for(let char of str){<br>    console.log(char);<br>  }<br>}</pre><h3>Array</h3><pre>{<br>  let list = [1, 2, 3, 4, 5];<br>  <br>  //list 변수의 하나의 원소가 리턴된다.<br>  for(let item of list){<br>    console.log(item);<br>  }<br>}</pre><p>위와 같이 Built-in Object 들도 iterable하다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9d9de828cca5" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Javascript Fetch API]]></title>
            <link>https://medium.com/@kkak10/javascript-fetch-api-e26bfeaad9b6?source=rss-c92452484f56------2</link>
            <guid isPermaLink="false">https://medium.com/p/e26bfeaad9b6</guid>
            <category><![CDATA[api]]></category>
            <category><![CDATA[fetch]]></category>
            <category><![CDATA[javascript]]></category>
            <dc:creator><![CDATA[이한울]]></dc:creator>
            <pubDate>Sat, 20 Jan 2018 23:43:28 GMT</pubDate>
            <atom:updated>2018-01-20T23:43:28.696Z</atom:updated>
            <content:encoded><![CDATA[<h3>개요</h3><p>그 동안 WEB에서 어떤 리소스를 비동기로 요청하기 위해서는 XHR(XML HTTP Request)객체를 사용했어야 했었는데,</p><p>XHR은 잘 디자인되어 있는 API가 아니다. 요청의 상태나 변경을 구독하려면 Event를 등록해서 변경사항을 받아야 했고</p><p>요청의 성공, 실패 여부나 상태에 따라 처리하는 로직이 들어가기 좋지 않았다.</p><p>이를 보완하기 위해서 Fetch API를 도입하였는데 이는 HTTP 요청에 최적화 되어 있고 상태도 잘 추상화 되어 있고</p><p>Promise를 기반으로 되어 있기때문에 상태에 따른 로직을 추가하고 처리하는데에 최적화 되어 있다.</p><h3>Baisc Use</h3><pre>fetch(&#39;http://hanur.me/users&#39;)<br>.then(res =&gt; res.json())<br>.then(data =&gt; data.filter(item =&gt; item.isRequired));</pre><p>기본적으로 위와 같이 사용할 수 있다.</p><h3>Basic</h3><p>Fetch API는 3개의 Interface를 도입하고 있는데 Headers, Request, Response 이다.</p><p>이는 곧 HTTP의 개념과 대응되는 Interface이다.</p><h3>Headers</h3><p>Headers 객체는 HTTP Header와 대응되는 객체이다.</p><pre>const reqHeader = new Headers();<br>const content = &quot;HI&quot;;<br>reqHeader.append(&quot;Content-Type&quot;, &quot;application/json&quot;);<br>reqHeader.append(&quot;Content-Length&quot;, content.length.toString());</pre><p>위 처럼 Headers 객체를 만들고 append Method를 이용하여 HTTP Request Header 정보를 추가할 수 있다.</p><p>혹은 Append가 아닌 생성자로 Object literal를 이용하여 정의할 수 도 있다.</p><pre>const content = &quot;HI&quot;;<br>const reqHeader = new Headers({<br>  &quot;Content-Type&quot;: &quot;application/json&quot;,<br>  &quot;Content-Length&quot;: content.length.toString(), <br>});</pre><p>더 자세히 보기위해서 Headers 객체의 Prototype을 보자</p><pre>append: function append()<br>delete: function delete()<br>entries: function entries()<br>forEach: function forEach()<br>get: function get()<br>getAll: function getAll()<br>has: function has()<br>keys: function keys()<br>set: function set()<br>values: function values()<br>constructor: function Headers()<br>Symbol(Symbol.iterator): function ()<br>Symbol(Symbol.toStringTag): &quot;Headers&quot;</pre><p>가장 눈에 띄는것은 Symbol.iterator를 구현한 Iterable 객체라는 점이다.</p><p>아마 기본적으로 key, value로 Header를 Set하고 있으니 해당 아이템을 List로 Iterator를 돌릴 수 있게 제공하는것 같다.</p><pre>const reqHeader = new Headers({<br>  &quot;Content-Type&quot;: &quot;application/json&quot;,<br>  &quot;Content-Length&quot;: &quot;30&quot;,<br>});</pre><pre>for(const item of reqHeader){<br>  console.log(item)<br>}</pre><pre>// console<br>// -&gt; [&quot;content-type&quot;, &quot;application/json&quot;]<br>// -&gt; [&quot;content-length&quot;, &quot;30&quot;]</pre><p>for of문은 Symbol.iterator를 구현하고 있기때문에 for of문은 정상적으로 동작하고 item은 내 예상과 다르게 Array에 Key, Valuer가 담긴 모습으로 뽑히고 있다.</p><p>내가 예상해던건 Object에 {key: value} 느낌이였는데 아마 Object로 하면 해당 Key만 뽑는게 쉽지 않아서 Array에 담은것 같다. (Object.keys나 Object.values를 이용하면 되긴하지만 일을 2번하는 느낌이므로…)</p><h4>entries()</h4><p>해당 메서드는 Iterator를 리턴해주는데 Headers[Symbol.iterator]()와 같은 결과를 반환한다.</p><h4>forEach()</h4><p>forEach을 따로 제공해주는데 Iterator를 돌리는것과 또 다르다.</p><pre>const reqHeader = new Headers({<br>  &quot;Content-Type&quot;: &quot;application/json&quot;,<br>  &quot;Content-Length&quot;: &quot;30&quot;,<br>});</pre><pre>reqHeader.forEach((value, key, header) =&gt; console.log(value, key, header));</pre><p>callback 함수의 파라미터로 value, key, header 순으로 들어오게 된다. header는 헌재 forEach를 돌고있는 해당 header 객체이다</p><h4>keys()</h4><pre>const reqHeader = new Headers({<br>  &quot;Content-Type&quot;: &quot;application/json&quot;,<br>  &quot;Content-Length&quot;: &quot;30&quot;,<br>});</pre><pre>const keys = reqHeader.keys();</pre><pre>for(const key of keys) {<br>  console.log(key)<br>}</pre><p>keys()는 Header에 등록된 Request Header key를 반환하는 Iterator를 반환하는 메서드이다. 만약 중복된 키로 여러 개의 Value가 등록된 경우 중복된 여러개의 Key가 아닌 하나의 key만 반환한다.</p><pre>const reqHeader = new Headers({<br>  &quot;Content-Type&quot;: &quot;application/json&quot;,<br>  &quot;Content-Type&quot;: &quot;plain/text&quot;,<br>  &quot;Content-Length&quot;: &quot;30&quot;,<br>});</pre><pre>const keys = reqHeader.keys();</pre><pre>for(const key of keys) {<br>  console.log(key)<br>}</pre><pre>// console<br>// -&gt; &quot;content-type&quot;<br>// -&gt; &quot;content-length&quot;</pre><h4>values()</h4><p>values()는 Header에 등록된 Request Header value를 반환하는 Iterator를 반환하는 메서드이다.</p><p>만약 중복된 key로 여러 value를 등록했을 경우 하나의 String에 ,Seperator로 이어서 반환된다.</p><pre>const reqHeader = new Headers({<br>  &quot;Content-Type&quot;: &quot;application/json&quot;,<br>  &quot;Content-Type&quot;: &quot;plain/text&quot;,<br>  &quot;Content-Length&quot;: &quot;30&quot;,<br>});</pre><pre>const values = reqHeader.values();<br></pre><pre>for(const value of values) {<br>  console.log(value)<br>}</pre><pre>// console<br>// -&gt; &quot;application/json,plain/text&quot;<br>// -&gt; &quot;30&quot;</pre><p>먼저 등록된 value가 앞에 나오고 나중에 등록된 value가 뒤에 나오게 된다.</p><h4>set()과 append()의 차이점</h4><p>set()과 append()가 겉으로 보기에는 비슷해보일 수 있다.</p><p>두개의 API가 기본적인 사용법은 같은데 무슨 차이가 있나 살펴보자.</p><pre>const reqHeader = new Headers();<br>reqHeader.append(&quot;Content-Type&quot;, &quot;application/json&quot;);<br>reqHeader.append(&quot;Content-Type&quot;, &quot;hihi&quot;);<br>reqHeader.append(&quot;Content-Length&quot;, &quot;30&quot;);</pre><pre>for(const value of reqHeader.values()){<br>  console.log(value);<br>}</pre><pre>// console<br>// -&gt; &quot;application/json,hihi&quot;<br>// -&gt; &quot;30&quot;</pre><pre>reqHeader.set(&#39;Content-Type&#39;, &#39;good&#39;);<br>for(const value of reqHeader.values()){<br>  console.log(value);<br>}<br>// console<br>// -&gt; &quot;good&quot;<br>// -&gt; &quot;30&quot;</pre><p>위 Code를 보면 알 수 있는 것처럼 append()는 설정을 추가해주는 메서드이고 set()은 해당 key를 이용해서 set해주고</p><p>만약 같은 key가 있다면 덮어써주는 메서드이다.</p><h4>guard</h4><p>Headers 객체는 우리가 Request를 보낼때도 사용하고 Response로 받는 경우에도 사용하게 됩니다.</p><p>우리가 직접 만든 Headers는 수정이 가능하지만, 만약 Response로 받은 Header의 경우 우리가 임의로 수정 할 수 없는게 맞습니다.</p><p>Server에서 내려준 Response에 대한 Header 이기때문에 그대로 사용하는게 맞습니다. 그러므로 Header에는 Header를 수정할 수 있는지</p><p>여부를 판단하는 guard가 존재합니다. guard는 Headers instance에 노출되어 있지 않아서 실제로 guard 값을 조회할 방법은 없습니다.</p><p>하지만 내부적으로 존재하는 값입니다.</p><ul><li>none: 기본값.</li><li>request: Request에 존재하는 Headers 객체를 위한 값.</li><li>request-no-cors: no-cors mode로 생성된 Request의 Headers 객체를 위한 값.</li><li>response: Response 객체에 있는 Headers 객체를 위한 값.</li><li>immutable: ServiceWork를 위해서 사용되는 값. Header가 Read-only라는 것을 나타낸다.</li></ul><p>가장 기본값은 “none”이다. 이는 모든 변경을 사실상 허용한다는 의미이다.</p><p>“request”는 request를 위한 Header name이 아닌 경우 변경을 금지한다.</p><p>예를 들어서 request의 Headers의 guard 속성은 “request”이다.</p><p>그래서 Request Header에 정의되는 속성이 아닌 Response Header 값을 세팅한다거나 하면 Type Error를 발생시킨다.</p><p>이런 방식으로 guard가 작동하는데 확인할 수 없다는 점이 아쉬운 점이다.</p><h3>Request</h3><p>Request는 HTTP 요청을 통해 자원을 가져오는 인터페이스이다.</p><p>Request는 URL, Header, body가 필요하다. 그리고 Request에 대한 mode 제한과 certificate 관련 설정도 추가할 수 있다.</p><pre>const req = new Request(&quot;/api/posts&quot;, {<br>  method: &quot;GET&quot;,<br>  headers: new Headers({<br>    &quot;content-type&quot;: &quot;application/json&quot;,<br>  }),<br>  body: {<br>    name: &quot;LeeHanur&quot;,<br>  }<br>});</pre><p>이런 느낌으로 사용할 수 있다. 물론 Request 객체를 생성한다고 HTTP Request가 날아가는건 아니다. Request 객체는 어떠한 HTTP Request에 대한 스팩을 정의한 것이고 실제로 Fetching 하는건 fetch Method를 이용해야 한다.</p><pre>const req = new Request(&quot;/api/posts&quot;, {<br>  method: &quot;GET&quot;,<br>  headers: new Headers({<br>    &quot;content-type&quot;: &quot;application/json&quot;,<br>  }),<br>  body: {<br>    name: &quot;LeeHanur&quot;,<br>  }<br>});<br>// is not Fetched</pre><pre>fetch(req).then(res =&gt; res.json()).then(data =&gt; console.log(data));<br>// is fetched Data!</pre><p>이런 느낌이라고 생각하면 된다.</p><p>Request 객체의 첫번째 인자는 호출한 Path가 들어가고, 두번째 인자에는 Request에 대한 정보가 들어가는데,</p><ul><li>method</li><li>headers</li><li>body</li><li>mode</li><li>cache</li><li>credentials</li><li>redirect</li><li>referrer</li><li>integrity</li></ul><h4>method</h4><p>method는 HTTP Method와 동일한 스팩으로 들어가면 된다. GET / POST / HEAD / PUT / DELETE / OPTION / PATCH 등등..</p><p>만약 지정을 안할 경우 기본값은 “GET”이 된다. 그리고 소문자로 지정해도 자동으로 대문자로 Uppercase된다.</p><pre>const req = new Request(&#39;/api/posts&#39;, {<br>  method: &#39;get&#39;<br>});</pre><pre>req.method // &quot;GET&quot;</pre><h4>headers</h4><p>headers는 Request Header를 지정해주는 곳인데 2가지 형식으로 넣을 수 있다. Object literal과 Headers 객체의 인스턴스를 넣을 수 있다.</p><pre>const req = new Request(&#39;/api/posts&#39;, {<br>  method: &quot;GET&quot;,<br>  headers: {<br>    &#39;content-type&#39;: &#39;application/json&#39;,<br>  }<br>});</pre><pre>const req2 = new Request(&#39;/api/posts&#39;, {<br>  method: &#39;GET&#39;,<br>  headers: new Headers({<br>   &#39;content-type&#39;: &#39;application/json&#39;,<br>  })<br>})</pre><h4>body</h4><p>body는 HTTP Request에 실을 데이터인데 여러가지 타입을 넣을 수 있다. 스팩을 보면 아래와 같이 명시되어 있다.</p><pre>typedef (Blob or BufferSource or FormData or URLSearchParams or ReadableStream or USVString)</pre><p>Blob도 보낼 수 있는 부분을 보면 파일전송까지 모두 고려한것으로 볼 수 있고, FormData와 URLSearchParams도 넣을 수 있도록 모두 고려되어 있다.</p><h4>mode</h4><p>mode는 Request시 어떤 Origin에 있는 Resource에 접근할지를 미리 설정할 수 있는 부분이다.</p><ul><li>same-origin</li><li>no-cors(Default)</li><li>cors</li></ul><p>same-origin은 현재 Origin과 같은 Origin에만 요청 할 수 있는 설정이다. 이를 이용하면 해당 Request는 같은 Origin에만 동작한다는걸 보장할 수 있다.</p><p>no-cors는 기본설정으로, 일반적으로 CDN에 있는 데이터를 가져온다거나 이미지를 불러온다거나 하는 기본적인 동작들을 할 수 있다. GET, POST, HEAD 이외에 다른 Method는 지원하지 않는다.</p><p>cors는 여러 다른 API에 접근할때 사용할 mode이다. Response Header가 일부 공개되지 않을 수 있지만 Body는 모두 접근가능하도록 Response가 온다.</p><h3>Response</h3><p>Response는 fetch를 호출하면 가져올 수 있는 객체인데, Response의 경우는 ServiceWorker가 아니면 생성해서 쓰는것이 크게 의미가 없다.</p><ul><li>status</li><li>statusText</li><li>ok</li><li>headers</li><li>type</li></ul><h4>status</h4><p>status는 HTTP Response Code를 담고 있다. 일반적으로 성공적이였다면 200이 떨어지게 될것이다.</p><h4>statusText</h4><p>statusText는 기본값은 “ok”이고 상황에 따라 다른 Message가 담길 수 있다.</p><h4>ok</h4><p>ok는 Status의 200299의 값을 추상화한 boolean인데 200299사이의 status이면 true를 가지게 된다.</p><h4>headers</h4><p>Response Headers 이기때문에 headers의 guard 속성은 response로 되어있다.</p><h4>type</h4><p>type은 Response 객체의 type을 말한다.</p><ul><li>basic</li><li>cors</li><li>error</li><li>opaque</li></ul><p>basic은 가장 기본적인 속성이고 error가 난 Response가 아니고, Request시 mode의 값이 cors가 아니라면 basic이 오게 될 것이다. 가능한 모든 Headers 속성에 접근할 수 있다.</p><p>cors는 Request의 mode가 cors일때 나오는 값인데, 이 때는 Headers의 일부 값에 대한 접근이 제한된다.</p><p>error는 Response.error()를 호출했을때 나오는 type이다.</p><p>opaque는 Request mode를 no-cors로 설정했을때 가지게 되는 type이다.</p><h3>Body를 다루기</h3><p>Request와 Response 모두 Body값이 존재하는데 Body는 아래와 같은 종류로 설정할 수 있다.</p><ul><li>ArrayBuffer</li><li>ArrayBufferView (Uint8Array와 친구들)</li><li>Blob/File</li><li>string</li><li>URLSearchParams</li><li>FormData</li></ul><p>이런 다양한 종류의 Body를 다루기위해서 제공되는 Method가 있다.</p><ul><li>arrayBuffer()</li><li>blob()</li><li>json()</li><li>text()</li><li>formData()</li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e26bfeaad9b6" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Block Scope에 선언된 함수의 특이 동작]]></title>
            <link>https://medium.com/@kkak10/block-scope%EC%97%90-%EC%84%A0%EC%96%B8%EB%90%9C-%ED%95%A8%EC%88%98%EC%9D%98-%ED%8A%B9%EC%9D%B4-%EB%8F%99%EC%9E%91-39ebdafed9af?source=rss-c92452484f56------2</link>
            <guid isPermaLink="false">https://medium.com/p/39ebdafed9af</guid>
            <category><![CDATA[function]]></category>
            <category><![CDATA[javascript]]></category>
            <dc:creator><![CDATA[이한울]]></dc:creator>
            <pubDate>Sat, 20 Jan 2018 23:42:30 GMT</pubDate>
            <atom:updated>2018-01-20T23:42:30.008Z</atom:updated>
            <content:encoded><![CDATA[<p>일반적으로 Block Scope 안에서 함수를 선언하는 일은 거의 없다. 개인적으로는 안좋은 방법으로 보고 사용하지 않는다. 관련해서 찾아보다가 모르고 있던 부분이 있었는데 아래와 같다.</p><p>ES5 환경에서 존재하는 Block Scope는 with문과 try..catch의 catch 구문 그리고 eval에서만 존재하는걸로 알고 있었다(물론 내부적으로 engine이 처리할때 또 다른 부분이 있을 수 있다.)</p><p>그런데 새로 알게된 점은 Block Scope에 있는 Function과 ‘use strict’;가 만나면 새로운 Block Scope가 만들어진다는 사실이다. 아래 코드를 보자.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/644cc7f0c38bfed880cf5ae4353c99ae/href">https://medium.com/media/644cc7f0c38bfed880cf5ae4353c99ae/href</a></iframe><p>내가 예상한 결과는 main function 이 실행될때 호이스팅이 일어나 if block 밖으로 끌어올려져서 결과는 I’m Block Scope Define이 두번 출력되는 것이다.</p><p>위 코드는 내가 예상한 결과대로 동작한다. 하지만 위 코드에 ‘use strict’가 더해진다면?</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/787584b7d2f573cb5fd92402c12d354f/href">https://medium.com/media/787584b7d2f573cb5fd92402c12d354f/href</a></iframe><p>위 코드는 이전에 내가 예상한 결과와 다르게 동작한다.</p><p>I’m Block Scope Define, I’m Global Scope Define 순으로 출력된다.</p><p>이유가 무엇일까?</p><p>“use strict”를 선언하면 엄격한 문법모드에서는 Block Scope 내에서 함수 선언을 Block 내에 Scope를 만들어서 격리시킨다. Coding Error를 줄이기 위해서 이와 같이 처리하는것 같다.</p><p>이처럼 사용하는 경우는 거의 없어서 실용적이지 않을 수도 있지만 알아두면 이해하는데 좋을것 같아서 Posting을 남긴다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=39ebdafed9af" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Javascript Function이 생성되는 과정]]></title>
            <link>https://medium.com/@kkak10/javascript-function%EC%9D%B4-%EC%83%9D%EC%84%B1%EB%90%98%EB%8A%94-%EA%B3%BC%EC%A0%95-15b74ecb7164?source=rss-c92452484f56------2</link>
            <guid isPermaLink="false">https://medium.com/p/15b74ecb7164</guid>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[function]]></category>
            <dc:creator><![CDATA[이한울]]></dc:creator>
            <pubDate>Sat, 20 Jan 2018 23:19:27 GMT</pubDate>
            <atom:updated>2018-01-20T23:19:27.560Z</atom:updated>
            <content:encoded><![CDATA[<p>Note.이 글은 ES5 Spec을 기준으로 작성된 글입니다. ECMA 2015 이후 Spec은 아래와 다를 수 있습니다.</p><pre>var func = function foo(){};</pre><p>Javascript Engine이 위와 같은 코드를 만나면 할당 연산자(=)를 기준으로 우항의 값을 계산하여 좌항에 할당합니다.</p><p>우항에 function 키워드가 있기때문에 Built In Function Object로 Function object를 생성해서 반환합니다.</p><pre>아래부터는 Built In Object들은 (Math, Function, Object, Array 등등..) Object로 표기하고 실제 instance는 object로 표기합니다</pre><p>해당 과정을 조금 더 자세히 알아봅시다.</p><ol><li>빈 오브젝트를 생성합니다.</li><li>func 변수에 빈 오브젝트를 넣습니다. javascript var func = {}</li><li>func 오브젝트에 prototype을 설정합니다. javascript var func = { prototype: {} }</li><li>func.prototype에 constructor를 설정합니다. javascript var func = { prototype: {constructor: {}} }</li><li>func.prototype.constructor에 foo에 대한 참조를 설정합니다. 이때 foo 함수는 메모리상에 올라가게 됩니다 javascript var func = { prototype: {constructor: foo} }</li><li>func.prototype에 __proto__를 추가합니다. javascript var func ={ prototype: {constructor: foo, __proto__: null} }</li><li>Object의 prototype에 연결된 Property로 object를 생성해서 __proto__에 대입합니다. javascript var func ={ prototype: {constructor: foo, __proto__: {}} }</li><li>Built In Function Object prototype의 property로 Function Object를 생성해서 func.__proto__에 대입한다.</li></ol><pre>var func ={<br>    prototype: {constructor: foo, __proto__: {}},<br>    __proto__: Function Object,<br>  }</pre><p>9. func의 Property에 Function 관련 값들을 설정합니다.</p><pre>var func ={<br>     arguments: null,<br>     length: 0,<br>     name: &quot;foo&quot;,<br>     prototype: {constructor: foo, __proto__: {}},<br>     __proto__: Function Object,<br>   }</pre><p>위 단순한 코드가 실행되는 과정이 이렇게나 복잡하다!</p><p>추가된 property를 하나하나씩 보자</p><p>arguments</p><p>arguments는 실제로 function이 호출될때 넘어가는 인자 값이 담기는 property이다. 기본값은 null이며 실제로 함수의 인자가 넘어올때 set된다</p><p>length</p><p>length는 함수가 parameter로 정의한 인자의 갯수를 말한다. 만약 javascript function (a,b,c){} 이런 함수가 있다면 length가 3으로 설정된다.</p><p>name name에는 기본적으로 함수의 이름이 들어가게 된다. 만약 익명 함수라면 대입되는 변수명이 name이 된다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=15b74ecb7164" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[resource-router-middleware]]></title>
            <link>https://medium.com/@kkak10/resource-router-middleware-e5773f1af3c4?source=rss-c92452484f56------2</link>
            <guid isPermaLink="false">https://medium.com/p/e5773f1af3c4</guid>
            <category><![CDATA[resource-router]]></category>
            <category><![CDATA[express]]></category>
            <category><![CDATA[nodejs]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[route]]></category>
            <dc:creator><![CDATA[이한울]]></dc:creator>
            <pubDate>Sat, 20 Jan 2018 23:16:05 GMT</pubDate>
            <atom:updated>2018-01-20T23:16:05.711Z</atom:updated>
            <content:encoded><![CDATA[<p><a href="https://github.com/developit/resource-router-middleware">https://github.com/developit/resource-router-middleware</a></p><h3>개요</h3><p>해당 모듈은 Node.js에서 RESTFUL API 작성시 쉽게 작성 할 수 있게 도와주는 라이브러리이다.</p><h3>사용법</h3><pre>import resource from &#39;resource-router-middleware&#39;;</pre><pre>export default resource({<br>    id : &#39;user&#39;,</pre><pre>    load(req, id, callback) {<br>        var user = users.find( user =&gt; user.id===id ),<br>            err = user ? null : &#39;Not found&#39;;<br>        callback(err, user);<br>    },</pre><pre>    index({ params }, res) {<br>        res.json(users);<br>    },</pre><pre>    create({ body }, res) {<br>        body.id = users.length.toString(36);<br>        users.push(body);<br>        res.json(body);<br>    },</pre><pre>    read({ user }, res) {<br>        res.json(user);<br>    },</pre><pre>    update({ user, body }, res) {<br>        for (let key in body) {<br>            if (key!==&#39;id&#39;) {<br>                user[key] = body[key];<br>            }<br>        }<br>        res.status(204).send();<br>    },</pre><pre>    delete({ user }, res) {<br>        users.splice(users.indexOf(user), 1);<br>        res.status(204).send();<br>    }<br>});</pre><h3>기본 설명</h3><p>위 사용법을 기반으로 설명하도록 한다.</p><p>기본적인 동작은 index 메서드를 제외한 모든 메서드는 load 메서드를 먼저 실행한 후 load 메서드의 리턴값을 Parameter로 받게되고 받은 인자를 기반으로 처리하여서 response를 던지면 되는 라이프 사이클을 가지고 있다.</p><h3>Q&amp;A</h3><h3>create, read, update, delete 메서드에서 load가 넘긴 값을 못가져올때</h3><p>해당 부분은 “id” Property와 관련이 있는데 “id” Property에 설정한 String이 create, read, update, delete에서 받는 인자의 key값이 된다. 예를들어 id가 “person”이면 인자를 받는 부분도 “person”인지 확인해야한다. 그리고 Javascript는 Case senstive이기때문에 대소문자를 반드시 맞춰야한다.</p><h3>기본 Routing 이외의 다른 Routing을 추가하고 싶을때</h3><p>resource 함수의 결과는 router이다. router에 일반적으로 routing path를 추가하는 방법으로 하면 된다. 아래 예시를 참고해보자.</p><pre>import resource from &#39;resource-router-middleware&#39;;</pre><pre>export default resource({<br>    id : &#39;user&#39;,</pre><pre>load(req, id, callback) {<br>        var user = users.find( user =&gt; user.id===id ),<br>            err = user ? null : &#39;Not found&#39;;<br>        callback(err, user);<br>    },</pre><pre>index({ params }, res) {<br>        res.json(users);<br>    },</pre><pre>create({ body }, res) {<br>        body.id = users.length.toString(36);<br>        users.push(body);<br>        res.json(body);<br>    },</pre><pre>read({ user }, res) {<br>        res.json(user);<br>    },</pre><pre>update({ user, body }, res) {<br>        for (let key in body) {<br>            if (key!==&#39;id&#39;) {<br>                user[key] = body[key];<br>            }<br>        }<br>        res.status(204).send();<br>    },</pre><pre>delete({ user }, res) {<br>        users.splice(users.indexOf(user), 1);<br>        res.status(204).send();<br>    }<br>})<br>.get(&#39;/user/category/:category_id&#39;, (req, res) =&gt; {<br>  // Someing ...<br>});</pre><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e5773f1af3c4" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Sequelize ORM 정리]]></title>
            <link>https://medium.com/@kkak10/sequelize-orm-%EC%A0%95%EB%A6%AC-9d17a39c58cb?source=rss-c92452484f56------2</link>
            <guid isPermaLink="false">https://medium.com/p/9d17a39c58cb</guid>
            <category><![CDATA[sequelize]]></category>
            <category><![CDATA[nodejs]]></category>
            <dc:creator><![CDATA[이한울]]></dc:creator>
            <pubDate>Sat, 20 Jan 2018 23:10:11 GMT</pubDate>
            <atom:updated>2018-01-20T23:10:11.109Z</atom:updated>
            <content:encoded><![CDATA[<h3>개요</h3><p>개인 프로잭트인 “Showing”을 개발중 Node.js에서 사용할 Sequelize ORM을 사용하며 몰랐던 부분을 정리하는 문서</p><h3>ORM이란?</h3><p>ORM(Object Relation Mapper)은 객체지향 Object와 Database의 Table이 1:1 매칭되는 형태의 개념을 말한다. 해당 Object는 Table 및 Query를 추상화하고 있어서 소스상에서 Class는 Table과 매칭되고 Instance는 하나의 row와 매칭되는 형태이다.</p><h3>Getting Started</h3><pre>import Sequelize from &#39;sequelize&#39;</pre><pre>const sequelize = new Sequelize(&#39;database&#39;, &#39;username&#39;, &#39;password&#39;, {<br>                host: &#39;localhost&#39;,<br>                dialect: &#39;mysql&#39;|&#39;mariadb&#39;|&#39;sqlite&#39;|&#39;postgres&#39;|&#39;mssql&#39;,</pre><pre>                pool: {<br>                  max: 5,<br>                  min: 0,<br>                  idle: 10000<br>                },</pre><pre>                define: {<br>                  freezeTableName: true,<br>                  timestamps: false,<br>                }<br>              })</pre><h3>Q&amp;A</h3><h3>테이블 이름이 자동으로 복수형이 되는 문제.</h3><p>Sequelize는 기본적으로 TableName을 복수형으로 만들어서 Query를 날리는데 이는 설정으로 해결할 수 있다.</p><p>DB Connection 설정을 해줄때</p><pre>define: {<br>  freezeTableName: true,<br>}</pre><p>위 처럼 설정해주면 모든 TableName을 복수형이 아닌 Model을 설정할때 이름 그대로 사용하게 해준다.</p><h3>Select 쿼리를 날릴때 자동으로 CreatedAt, UpdatedAt을 날리는 문제.</h3><p>Sequelize는 Select할때 자동으로 CreatedAt, UpdatedAt을 날리는데 이는 일반적으로 ORM에서 timestamp를 찍어주는 기능때문에 자동으로 CreatedAt, UpdatedAt가 날라간다. 해당 부분도 설정으로 Off할 수 있다.</p><pre>define: {<br>  timestamps: true,<br>}</pre><p>위 처럼 설정하면 자동으로 CreatedAt, UpdatedAt를 조회하거나 생성하는것을 막을 수 있다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9d17a39c58cb" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SVG 시작하기#1]]></title>
            <link>https://medium.com/@kkak10/svg-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-1-d0b9aad5058d?source=rss-c92452484f56------2</link>
            <guid isPermaLink="false">https://medium.com/p/d0b9aad5058d</guid>
            <category><![CDATA[svg]]></category>
            <category><![CDATA[getting-started]]></category>
            <dc:creator><![CDATA[이한울]]></dc:creator>
            <pubDate>Sat, 20 Jan 2018 23:07:57 GMT</pubDate>
            <atom:updated>2018-01-20T23:07:57.463Z</atom:updated>
            <content:encoded><![CDATA[<h3>동기</h3><p>그동안 SVG에 대해 막연하게 알고 있었다.</p><p>“백터 기반이라서 사이즈가 변경되어도 안 깨지고 XHTML 문법으로 이루어져서 CSS 및 Event Handle이 가능하다”</p><p>딱 이 정도만 알고 있었고 실무에서 사용한 경험이나 그 이상 공부해본 경험이 없다.</p><p>물론 Canvas는 스터디해봤지만 SVG는 딱 위에서 언급한 정도였는데 최근에 Data Visualization에 대해 관심이 생겨서 보니 D3.js 같은 Data Visualization Library가 SVG를 이용하고 있었다.</p><p>물론 D3나 D3를 Wrapping 한 C3를 이용하면 쉽게 데이터를 Visualization 할 수 있지만 SVG를 이해해서 내가 간단한 라이브러리를 만들어보면 어떨까 라는 생각이 들게 되어 스터디를 시작했다.</p><h3>SVG란?</h3><p>SVG는 정확히 무엇이고 용도가 어떤 것이며 어떠한 문제 영역을 해결하려고 나온 것일까?</p><p>SVG는 “Scalable Vector Graphic”의 약자이며 2차원의 백터 그래픽을 표현하기 위해서 나왔고 XML 기반이다.</p><p>1998년 W3C에서 개발하기 시작했으며 그 이전에서 Microsoft의 “VML”와 Apple의 “PGML”이라는 2차원의 백터 그래픽을 XML로 표현하는 언어가 있었지만 2개의 스펙 모두 W3C에서 채택하지 않았고 W3C는 SVG를 개발하여서 표준으로 채택한 것 같다.</p><p>Microsoft의 “VML”은 Root요소로 &lt;xml&gt; 태그를 지정해야 했는데 이는 XML 표준 위반사항이라서 채택되지 않았지만 아직 Office 제품에서 일부 사용 가능한 것으로 확인되며</p><p>Apple과 Sun Microsystems 등 여러 기업에서 추진한 “PGML”이 채택되지 않은 이유는 찾기가 어려웠다.</p><p>현재 SVG의 가장 최신 버전은 1.2 버전이지만 1.2는 “SVG2”라는 스펙으로 넘어갈 예정이며 현재는 1.1 버전을 쓰는 것이 가장 안정적이다.</p><p>정확하게 스펙을 알아보고 싶다면 <a href="https://github.com/w3c/svgwg">https://github.com/w3c/svgwg</a>를 참고하길 바란다.</p><h3>SVG의 장단점</h3><p>SVG의 장점은 백터 기반이기 때문에 기존의 비트맵 기반의 포맷과 달리 사이즈가 늘어나도 사진이 깨지지 않고 매끄럽게 표현된다.</p><p>Web에서 Device의 Ratio를 대응하기 위해 기존 사이즈보다 x2 된 사진으로 대응하는데 SVG를 사용하면 굳이 원본과 x2를 모두 준비할 필요 없이 자동으로 대응된다.</p><p>그리고 Web환경에서 사용할 때는 CSS를 이용하여 Styling이 가능하고 Javascript를 이용해서 Event Handling도 가능하다. 이를 이용하여 기존에 HTML / CSS로는 조금 어려웠던 Animation이나 효과들을 잘 구현할 수 있지 않을까 생각된다.</p><p>단점으로는 크기를 예로 들 수 있는데, 간단한 경우에는 JPG나 PNG보다 더 적은 용량일 수 있지만 Path가 많아지고 점점 더 무거워지면 기존 이미지 포맷들보다 더 커질 수 있다.</p><p>이러한 단점을 보완하기 위해 SVG Optimizing을 위한 툴도 있다. <a href="https://github.com/svg/svgo">https://github.com/svg/svgo</a></p><h3>SVG 시작해보기</h3><p>&lt;svg width=”300&quot; height=”300&quot; xmlns=”<a href="http://w3.org/2000/svg%22">http://w3.org/2000/svg&quot;</a> version=”1.1&quot; viewbox=”0 0 300 300&quot;&gt;</p><p>&lt;/svg&gt;</p><p>HTML에서 SVG를 시작하려면 &lt;svg&gt; 태그부터 알아야 한다.</p><p>&lt;svg&gt; 태그는 svg의 Root태그이며 svg는 XHTML 스펙을 따르고 있기 때문에 반드시 “xmlns” Attribute를 이용하여 NameSpace을 지정해줘야 한다. version은 사용할 SVG 스펙의 버전을 말하는데 일반적으로는 1.1을 사용하면 된다.</p><p>width와 height는 svg Element의 크기를 지정해주며 Requirement Attribute이므로 무조건 지정해주어야 한다.</p><p>그리고 중요한 viewbox라는 Attribute가 있는데, viewbox는 실제 svg영역 중에 보여줄 기준점을 정하는 Attribute이다. viewbox=”x y width height”로 이루어져 있는데 width나 height는 0 값 이하를 지정하면 SVG가 렌더링 되지 않는다.</p><p>해당 viewbox의 위치나 크기에 따라서 svg Element는 300x300이지만 100x100만 표시될 수도 있고 좌표값 0,0이 아닌 100,100을 기준으로 보여줄 수 있다.</p><p>&lt;svg width=”300&quot; height=”300&quot; xmlns=”<a href="http://w3.org/2000/svg%22">http://w3.org/2000/svg&quot;</a> version=”1.1&quot; viewbox=”0 0 300 300&quot;&gt;</p><p>&lt;rect x=”0&quot; y=”0&quot; width=”100&quot; height=”100&quot; /&gt;</p><p>&lt;/svg&gt;</p><p>위 코드는 300x300의 SVG 위에 100x100의 사각형을 그리는 코드입니다.</p><p>rect의 좌표는 x: 0, y: 0 이기 때문에 SVG의 가장 왼쪽 위에 그려집니다.</p><p>만약 viewbox를 변경하면 어떻게 나올까요?</p><p>&lt;svg width=”300&quot; height=”300&quot; xmlns=”<a href="http://w3.org/2000/svg%22">http://w3.org/2000/svg&quot;</a> version=”1.1&quot; viewbox=”0 0 300 300&quot;&gt;</p><p>&lt;rect x=”0&quot; y=”0&quot; width=”100&quot; height=”100&quot; /&gt;</p><p>&lt;/svg&gt;</p><p>위와 같이 viewbox의 기본 좌표를 50, 50으로 변경하면 0, 0을 기준으로 그려진 rect는 원래 보이던 크기의 반만큼만 나옵니다.</p><p>사실 viewbox가 변한다고 실제 rect의 크기가 작게 변한 것은 아니고 viewbox의 위치만 옮겨서 rect가 모두 보이지 않는 것입니다.</p><h3>SVG에서 사용하는 Tag</h3><h3>rect</h3><p>rect 태그는 SVG에서 사각형을 그릴 수 있는 태그이다.</p><p>&lt;rect x=”0&quot; y=”0&quot; rx=”10&quot; ry=”10&quot; width=”100&quot; height=”100&quot; fill=”red” stroke=”blue” stroke-width=”10&quot;/&gt;</p><p>Attribute</p><p>- x는 좌표계를 기준으로의 x 값을 말한다.</p><p>- y는 좌표계를 기준으로의 y 값을 말한다.</p><p>- rx, ry는 사각형 모서리의 radius 값을 말한다.</p><p>- width, height는 사각형의 크기를 말한다.</p><p>- fill은 사각형의 Background 색을 말한다.</p><p>- stroke는 사각형의 border색을 말한다.</p><p>- stroke-width는 사각형 border의 넓이를 말한다.</p><h3>circle</h3><p>&lt;circle cx=”50&quot; cy=”50&quot; r=”40&quot; stroke=”black” stroke-width=”3&quot; fill=”red”&gt;&lt;/circle&gt;</p><p>Attribute</p><p>- cx는 원의 중심점중 x값을 말한다.</p><p>- cy는 원의 중심점중 y값을 말한다.</p><p>- cx와 cy의 교차점이 해당 circle의 중심점이 된다.</p><p>- r은 원의 반지름의 길이를 말한다. cx와 cy의 교차점부터 r의 값으로 circle의 rendering 된다.</p><h3>Ellipse</h3><p>&lt;ellipse cx=”50&quot; cy=”50&quot; rx=”40&quot; ry=”20&quot; stroke=”black” stroke-width=”3&quot; fill=”red”&gt;&lt;/ellipse&gt;</p><p>Attritube</p><p>- cx는 원의 중심점중 x값을 말한다.</p><p>- cy는 원의 중심점중 y값을 말한다.</p><p>- rx는 원의 가로축 반지름을 말한다.</p><p>- ry는 원의 세로축 반지름을 말한다.</p><h3>Line</h3><p>&lt;line x1=”0&quot; y1=”10&quot; x2=”30&quot; y2=”10&quot; stroke=”orange” stroke-width=”3&quot;&gt;&lt;/line&gt;</p><p>Attribute</p><p>- x1, y1은 line의 시작이 되는 점입니다.</p><p>- x2, y2는 line의 시작 점부터 x2, y2점까지 그어지는 점입니다.</p><h3>Polygon</h3><p>&lt;polygon points=”x1,y1 x2,y2, x3,y3 …” fill=”black” stroke=”” stroke-width=””&gt;&lt;/polygon&gt;</p><p>Attribute</p><p>- points는 Polygon을 형성하는 꼭지점의 좌표값인데 위 처럼 총 3개의 점을 찍으면 자동으로 이어지고 끝점과 시작점은 지정하지 않아도 자동으로 이어준다.</p><h3>polyline</h3><p>&lt;polyline points=”100,100 130,100 130,130 160,130 160,160&quot; fill=”transparent” stroke=”black” stroke-width=”2&quot;&gt;&lt;/polyline&gt;</p><p>Attribute</p><p>- points는 Polygon의 points랑 비슷하다 다만 Polygon은 다각형 도형을 만들때 사용하고 polyline은 여러개의 점을 이을때 사용한다.</p><p>이번 글에서는 SVG에 대한 설명과 대략적인 사용법만을 알아봤다.</p><p>다음 포스트에서는 실제로 SVG 코드 및 예제를 만들어보면서 SVG를 깊숙히 살펴보도록 하겠다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d0b9aad5058d" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Ngrok과 PSI를 이용한 Web 성능 측정]]></title>
            <link>https://medium.com/@kkak10/ngrok%EA%B3%BC-psi%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-web-%EC%84%B1%EB%8A%A5-%EC%B8%A1%EC%A0%95-63bf3d1dc8fd?source=rss-c92452484f56------2</link>
            <guid isPermaLink="false">https://medium.com/p/63bf3d1dc8fd</guid>
            <category><![CDATA[ngrok]]></category>
            <category><![CDATA[ip]]></category>
            <category><![CDATA[web]]></category>
            <category><![CDATA[performance]]></category>
            <dc:creator><![CDATA[이한울]]></dc:creator>
            <pubDate>Sat, 20 Jan 2018 23:04:11 GMT</pubDate>
            <atom:updated>2018-01-20T23:04:11.279Z</atom:updated>
            <content:encoded><![CDATA[<h3>개요</h3><p>Local에 WebServer를 띄워서 개발하던 중 사이트의 성능 측정이 하고 싶어 졌다.</p><p>Chrome Dev Tool을 이용해서도 어느 정도 Insight를 얻을 수 있지만, Google에서 만든 Page Speed Insight(이하 PSI)를 이용해서 Feature 별로 성능에 대한 값을 측정하고 싶었는데,</p><p>Local에서 개발하고 있는 상태여서 PSI를 이용해서는 측정할 수가 없었다.</p><p>그러던 중에 Ngrok을 알게 되어 PSI를 이용해서 성능 측정을 할 수 있었다!</p><p>그래서 Ngrok과 PSI를 이용한 성능 측정 방법에 대한 글을 적어보도록 하겠다.</p><h3>Ngrok</h3><p>ngrok이 어떠한 것인지 알아보자.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*7Hzi3uQWWlbugyEF.png" /><figcaption>Ngrok의 기본 원리</figcaption></figure><p>ngrok은 Webhook을 이용하여 local에 떠있는 서버를 방화벽을 넘어 ngrok.com쪽에 바인딩해주는 서비스이다.</p><p>이를 이용하면 ngrok.com/xxx로 바인딩된 주소를 이용하여 외부에서도 개발 중인 서버에 접속할 수 있는 것이다.</p><h3>ngrok 설치</h3><p>ngrok을 먼저 설치해보자.</p><p><a href="https://ngrok.com/download">https://ngrok.com/download</a></p><p>ngrok 사이트에 들어가면 자신이 사용하는 OS에 맞게 받을 수 있다.</p><p>필자의 경우 Mac을 사용하기 때문에 Mac OS 버전으로 받았다.</p><p>다운로드한 후 압축을 풀고 나온 binary 파일을 terminal에서 global로 사용할 수 있도록 /usr/local/bin으로 옮겨준다.</p><p>이제 ngrok을 사용할 준비는 모두 완료되었다.</p><h3>PSI</h3><p>PSI는 Google Speed Insight의 약자이다.</p><p><a href="https://developers.google.com/speed/pagespeed/insights/">https://developers.google.com/speed/pagespeed/insights/</a></p><p>위 링크를 통해서 Web Site 성능과 Mobile Friendly 점수도 볼 수 있다.</p><p>하지만 위 사이트보다는 CLI Tool을 이용해서 보는 것이 다양한 Item에 대한 Score를 볼 수 있다.</p><p>CLI를 통해서 속도를 측정할 수 있는 Node 기반의 라이브러리를 사용하면 된다.</p><p><a href="https://github.com/addyosmani/psi">https://github.com/addyosmani/psi</a></p><p>위 사이트에서 하단을 보면 CLI에 설치하는 커맨드가 있다.</p><blockquote><em>npm install — global psi</em></blockquote><p>psi까지 설치 완료한다면 준비는 완료된 것이다.</p><h3>성능 측정해보기</h3><p>먼저 ngrok을 이용해 local에 떠있는 서버를 ngrok에 연결시켜줘야 한다.</p><blockquote><em>ngrok http 8080</em></blockquote><p>“8080”부분에는 자신의 웹 서버가 떠 있는 포트를 넣어주면 된다.</p><p>실행하면 뭔가 새로운 화면이 보일 텐데 forwarding이라는 부분이 있다.</p><blockquote><em>Forwarding </em><a href="https://43c93fc0.ngrok.io/"><em>https://43c93 fc0.ngrok.io</em></a><em> -&gt; localhost:8080</em></blockquote><p>forwarding과 연결된 ngrok의 URL에 들어가면 Local에 떠 있는 Web Server에 접속되는 것을 볼 수 있다.</p><p>이제 psi를 이용해서 성능 테스트만 해주면 된다.</p><blockquote><em>psi </em><a href="https://43c93fc0.ngrok.io/"><em>https://43c93 fc0.ngrok.io/</em></a></blockquote><p>이제 터미널에 성능 측정 결과가 나올 것이다!</p><p>기본적으로는 mobile 화면일 때를 기준으로 측정되는데 만약 Desktop기준으로 변경하고 싶다면,</p><blockquote><em>psi </em><a href="https://43c93fc0.ngrok.io/"><em>https://43c93 fc0.ngrok.io/</em></a><em> — strategy=desktop</em></blockquote><p>이렇게 간단하게 개발 중인 Web에 대해서 성능 측정을 할 수 있다!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=63bf3d1dc8fd" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>