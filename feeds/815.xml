<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>Dork's port</title>
<link>https://blog.dork94.com/</link>
<description>컴퓨터 공부하다 알아 가는 것들을 공유하는 블로그 입니다.
틀린 내용 지적해주시면 감사히 받겠습니다.</description>
<language>ko</language>
<pubDate>Mon, 13 May 2019 13:38:12 +0900</pubDate>
<generator>TISTORY</generator>
<managingEditor>Dork94</managingEditor>
<image>
<title>Dork's port</title>
<url>https://tistory4.daumcdn.net/tistory/2820442/attach/2dc4c604771e4f909053e572c7a44f05</url>
<link>https://blog.dork94.com</link>
<description>컴퓨터 공부하다 알아 가는 것들을 공유하는 블로그 입니다.
틀린 내용 지적해주시면 감사히 받겠습니다.</description>
</image>
<item>
<title>PyQt에서 QPlainText를 이용해 정보 출력하기(색상 변경)</title>
<link>https://blog.dork94.com/186</link>
<description>&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/bffJqp/btquxLNcW99/BfGIKaXbuQwIuBHoq9uVO1/img.png' data-lightbox='lightbox' data-alt='결과 화면'&gt;&lt;img src='https://k.kakaocdn.net/dn/bffJqp/btquxLNcW99/BfGIKaXbuQwIuBHoq9uVO1/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbffJqp%2FbtquxLNcW99%2FBfGIKaXbuQwIuBHoq9uVO1%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-14 at 3.15.49 AM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;결과 화면&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;프로그램에서 특정 정보를 출력할 목적으로 Widget를 찾아보았는데, QPlainText을 추천해서 간단하게 구현해봤다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1555179570520&quot; class=&quot;python&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;import sys
from PyQt5.QtWidgets import QApplication, QWidget, QDesktopWidget
from PyQt5.QtWidgets import QPlainTextEdit

alertHtml = &quot;&amp;lt;font color=\&quot;DeepPink\&quot;&amp;gt;&quot;;
notifyHtml = &quot;&amp;lt;font color=\&quot;Lime\&quot;&amp;gt;&quot;;
infoHtml = &quot;&amp;lt;font color=\&quot;Aqua\&quot;&amp;gt;&quot;;
endHtml = &quot;&amp;lt;/font&amp;gt;&amp;lt;br&amp;gt;&quot;;

__author__='d0rk'

class my_app(QWidget):

    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setWindowTitle('PyQt QPlaintext Example')


        self.log_window()


        # self.resize(1280, 800)
        self.center()
        self.show()

    def center(self):
        qr = self.frameGeometry()
        cp = QDesktopWidget().availableGeometry().center()
        qr.moveCenter(cp)
        self.move(qr.topLeft())

    def log_window(self):
        widget = QPlainTextEdit(self)
        widget.setReadOnly(True)
        widget.appendPlainText('Simple Test')

        widget.appendHtml(alertHtml + 'Alert Test')
        widget.appendHtml(notifyHtml + 'Notify Test')
        widget.appendHtml(infoHtml + 'Info Test')
        widget.appendHtml(endHtml + 'Endhtml')
        widget.show()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = my_app()
    sys.exit(app.exec_())

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;appendPlainText 함수를 이용해, 일반 text를 출력할 수 있고, appendHtml을 이용해 html 태그를 이용할 수 있는데, 이를 이용해 color의 색상을 변경할 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block; text-align:center;&quot;
     data-ad-layout=&quot;in-article&quot;
     data-ad-format=&quot;fluid&quot;
     data-ad-client=&quot;ca-pub-3588179945681108&quot;
     data-ad-slot=&quot;3731887415&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.dork94.com/186&amp;amp;layout=button_count&amp;amp;show_faces=true&amp;amp;width=106&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:106px; height:30px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Develop</category>
<author>Dork94</author>
<guid>https://blog.dork94.com/186</guid>
<comments>https://blog.dork94.com/186#entry186comment</comments>
<pubDate>Sun, 14 Apr 2019 03:21:34 +0900</pubDate>
</item>
<item>
<title>pyqt를 이용한 QTreeWidget 이용 및 리스트 간 항목 이동 구현하기</title>
<link>https://blog.dork94.com/185</link>
<description>&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/bUt8sq/btquvOD24GM/Oddvh5mKkVsKurwwttUtd1/img.png' data-lightbox='lightbox' data-alt='결과 화면'&gt;&lt;img src='https://k.kakaocdn.net/dn/bUt8sq/btquvOD24GM/Oddvh5mKkVsKurwwttUtd1/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbUt8sq%2FbtquvOD24GM%2FOddvh5mKkVsKurwwttUtd1%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-13 at 3.01.38 AM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;결과 화면&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;GUI 공부를 위해서 pyqt를 사용하고 있는데, top-down 방식으로 공부하려니 여간 쉽지가 않다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;구성이 모든 class로 이뤄져있고, 객체간의 관계가 복잡해서 document를 정독하고 나서야 겨우 구현에 성공했다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;소스 코드는 다음과 같다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1555092304752&quot; class=&quot;python&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;import sys
from PyQt5.QtWidgets import QApplication, QWidget,QDesktopWidget,QPushButton, QBoxLayout,QTreeWidget,QTreeWidgetItem

__auther__='d0rk'

class my_app(QWidget):
    def __init__(self):
        super().__init__()

        self.add_btn=QPushButton('추가')
        self.del_btn=QPushButton('삭제')
        self.wishlist=QTreeWidget(self)
        self.lecture_list=QTreeWidget(self)

        self.initUI()



    def initUI(self):
        self.setWindowTitle('QTree example')

        self.init_lectures()

        self.resize(800, 480)
        self.center()
        self.show()

    def center(self):
        qr = self.frameGeometry()
        cp = QDesktopWidget().availableGeometry().center()
        qr.moveCenter(cp)
        self.move(qr.topLeft())


    def init_lectures(self):
        headers = ['과목','시간','캠퍼스','강의실','교수명']

        self.lecture_list.setColumnCount(len(headers))
        self.lecture_list.setHeaderLabels(headers)

        self.wishlist.setColumnCount(len(headers))
        self.wishlist.setHeaderLabels(headers)


        list_layout = QBoxLayout(QBoxLayout.LeftToRight)
        list_layout.addWidget(self.lecture_list)
        list_layout.addWidget(self.wishlist)

        lecture_root = QTreeWidget.invisibleRootItem(self.lecture_list)

        datas = ['하','이','루','방','가']
        item = QTreeWidgetItem()
        for idx, data in enumerate(datas):
            item.setText(idx, data)

        lecture_root.addChild(item)

        datas = ['바','이','루','방','가']
        item = QTreeWidgetItem()
        for idx, data in enumerate(datas):
            item.setText(idx, data)

        lecture_root.addChild(item)

        datas = ['D', '0', 'R', 'K', '_']
        item = QTreeWidgetItem()
        for idx, data in enumerate(datas):
            item.setText(idx, data)

        lecture_root.addChild(item)

        btn_layout = QBoxLayout(QBoxLayout.RightToLeft)
        btn_layout.addWidget(self.add_btn)
        btn_layout.addWidget(self.del_btn)

        main_layout = QBoxLayout(QBoxLayout.TopToBottom)
        main_layout.addLayout(list_layout)
        main_layout.addLayout(btn_layout)

        self.add_btn.clicked.connect(self.move_item)
        self.del_btn.clicked.connect(self.move_item)

        self.setLayout(main_layout)
        return main_layout


    def move_item(self):
        sender = self.sender()

        if self.add_btn == sender:
            source = self.lecture_list
            target = self.wishlist
        else:
            source = self.wishlist
            target = self.lecture_list

        item = QTreeWidget.invisibleRootItem(source).takeChild(source.currentIndex().row())
        QTreeWidget.invisibleRootItem(target).addChild(item)


if __name__=='__main__':

    app = QApplication(sys.argv)
    ex = my_app()
    sys.exit(app.exec_())

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;소스코드는&amp;nbsp;&lt;a href=&quot;https://github.com/JangHanbin/pyqt_QtreeWidget&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JangHanbin/pyqt_QtreeWidget&lt;/a&gt;&amp;nbsp;다운받을 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;구글에도 위와 같은 형태에 대해 많은 자료가 없어서 삽질 많이 했다 :(&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block; text-align:center;&quot;
     data-ad-layout=&quot;in-article&quot;
     data-ad-format=&quot;fluid&quot;
     data-ad-client=&quot;ca-pub-3588179945681108&quot;
     data-ad-slot=&quot;3731887415&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.dork94.com/185&amp;amp;layout=button_count&amp;amp;show_faces=true&amp;amp;width=106&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:106px; height:30px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Develop</category>
<category>PyQt</category>
<category>pyqt QTree</category>
<category>QTreeWidget</category>
<category>QTreeWidget example</category>
<author>Dork94</author>
<guid>https://blog.dork94.com/185</guid>
<comments>https://blog.dork94.com/185#entry185comment</comments>
<pubDate>Sat, 13 Apr 2019 03:19:00 +0900</pubDate>
</item>
<item>
<title>IPsec (IP security)</title>
<link>https://blog.dork94.com/184</link>
<description>&lt;p&gt;1994년 IAB(Internet Architecture Board)에서 &quot;Security in the Internet Architecture&quot;라는 이름으로 제안되었고 RFC 1636에 설명되어있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;IPsec의 이점은 다음과 같다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;IPsec은 방화벽이나 라우터에서 구현이되어 있기때문에, 모든 traffic에 대한 보안이 적용된다. 따라서 end-user는 어떤 overhead도 발생하지 않는다.&lt;/li&gt;
&lt;li&gt;방화벽에서 작동하는 IPsec은 만약 외부로부터 오는 모든 트래픽이 IP를 사용해야 하거나, 방화벽이 인터넷에서 조직으로 들어오는 유일한 수단인 경우 방화벽을 bypass 할 수 없다(즉. 모든 트래픽이 IP를 사용하고, in-bound에 방화벽이 설치되어있다면, 무조건 방화벽을 거쳐서 통과해야한다).&lt;/li&gt;
&lt;li&gt;IPsec이 Transport layer 아래에 존재하기때문에 Application에 대해 영향을 끼치지 않는다. 따라서, IPsec을 구현하려는 경우 &amp;nbsp;software나 server system을 바꾸지 않아도 된다.&lt;/li&gt;
&lt;li&gt;IPsec을 사용할때, 사용자에 대한 특별한 관리가 필요없다(key를 지우거나, IPsec에 대해 교육하거나 기타 등등).&lt;/li&gt;
&lt;li&gt;개별적인 보안을 제공할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;IPsec은 3가지 역할을 한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;Authentication&lt;/li&gt;
&lt;li&gt;Confidentiality&lt;/li&gt;
&lt;li&gt;Key management&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;IPsec에 대한 공식 문서는 RFC나 IETF에 많은 문서가 있다. IPsec은 IP layer에서 보안을 제공하며, IPv4, IPv6에 대해 모두 동작한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;시작하기에 앞서 AH, ESP에 대한 내용이 자주 등장하는데, 이 &lt;a href=&quot;http://www.ktword.co.kr/word/abbr_view.php?m_temp1=5567&amp;amp;m_search=A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;링크&lt;/a&gt;에 간단하게 잘 설명되어 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;div data-ke-type=&quot;moreLess&quot; data-text-more=&quot;더보기&quot; data-text-less=&quot;닫기&quot;&gt;&lt;a class=&quot;btn-toggle-moreless&quot;&gt;...더보기&lt;/a&gt;
&lt;div class=&quot;moreless-content&quot;&gt;
&lt;p&gt;간단하게 말해서, AH는 인증, 무결성에 사용되며 ESP는 인증, 무결성, 기밀성(암호화)를 제공한다. ESP가 AH의 모든 내용을 포함하고 있으므로 현재는 잘 사용되지 않는다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#&lt;span style=&quot;color: #333333;&quot;&gt;Transport Mode , Tunnel Mode&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/65H0T/btqubATUDYi/2wR3a91Q1pjvmIvF59s3s0/img.png' data-lightbox='lightbox' data-alt='Transport Mode와 Tunnel Mode Overview'&gt;&lt;img src='https://k.kakaocdn.net/dn/65H0T/btqubATUDYi/2wR3a91Q1pjvmIvF59s3s0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2F65H0T%2FbtqubATUDYi%2F2wR3a91Q1pjvmIvF59s3s0%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-07 at 5.03.42 PM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;Transport Mode와 Tunnel Mode Overview&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;AH와 ESP는 Transport와 Tunnel Mode 두가지를 지원한다. 위의 사진에서 보이는 것처럼 가장 큰 차이는 Transport는 기존의 IP Header를 사용한다는 점과, Tunnel은 새로운 IP Header를 붙인다는 점이 다르다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/46hH2/btqubfoXNPU/bRkavPBTaHui2yfdzOEvzk/img.jpg' data-lightbox='lightbox' data-alt='Layer의 구분'&gt;&lt;img src='https://k.kakaocdn.net/dn/46hH2/btqubfoXNPU/bRkavPBTaHui2yfdzOEvzk/img.jpg' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2F46hH2%2FbtqubfoXNPU%2FbRkavPBTaHui2yfdzOEvzk%2Fimg.jpg' width=&quot;727&quot; height=&quot;417&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;Layer의 구분&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Transport mode&lt;/b&gt;는 upper-layer에 대한 보안을 제공한다. 예를들어 TCP, UDP, ICMP packet의 같은 경우 IP layer위에서 동작하는 프로토콜에 대해서 보안을 제공한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;보통 end-to-end 환경에서 많이 사용된다. ESP는 Transport모드에서 &amp;nbsp;encrypt와 IP Payload(IP header를 제외한 나머지 부분)에 대한 authenticate를 선택적으로 제공한다(IP Header에 대해서는 아님). AH 는 Transport 모드에서 IP payload에 대한 authenticate와 IP header에 대한 authenticate를 제공한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Tunnel Mode&lt;/b&gt;는 전체 IP Packet에 대한 보호를 제공하고, 이를 위해서 IP Header를 새로 생성해서 append 한다. 즉 기존의 ip header를 포함한 payload를 새로운 ip header에 대한 payload로 취급한다. Tunnel Mode는 한쪽, 또는 양쪽에 있는 방화벽이나 라우터가 Security Gateway&lt;span style=&quot;color: #333333;&quot;&gt;(IPsec을 지원하는)인&amp;nbsp;&lt;/span&gt;경우 사용한다. &amp;nbsp;따라서, host들이 IPsec에 대한 구현을 하지 않아도, IPsec을 사용할 수 있다. 왜냐하면, 라우터나 방화벽이 해주기 때! 문! 그래서 Host가 Pacekt을 생성하면, Tunnel Mode를 지원하는 Router에 의해 Tunneling 된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;IP를 위한 authentication과 confidentiality의 핵심은 SA(Security Association)이다. SA는 Sender와 receiver간의 Security Traffic이 전달되는 논리적인 일방향 연결이다. 즉, 양방향 간의 보안 통신이 필요하면 SA는 두개가 필요하다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;SA의 파라미터는 3개가 사용된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot;&gt;
&lt;li&gt;SPI (Security Parameters Index) : 32-bit의 unsigned integer로 되어있으며, 처리될 SA를 선택할 수 있도록 AH나 ESP Header안에 포함하여 전송된다.&lt;/li&gt;
&lt;li&gt;IP Destination Address : SA로 전달될 Destination Address이다. end-user의 router이거나 방화벽이 다수이다.&lt;/li&gt;
&lt;li&gt;Security Protocol Identifier : AH를 이용한것인지 ESP를 이용한 것인지 나타내는 field, 추가한 IP header에 존재함.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;SPD (Security Policy Database)&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot; data-ke-list-type=&quot;square&quot;&gt;
&lt;li&gt;Remote IP Address : IP Address, network range, wildcard가 저장되며 network range와 wildcard는 같은 SA를 사용하는 network를 지원하기 위해 이용된다.&lt;/li&gt;
&lt;li&gt;Local IP Address : IP Address, network range, wildcard가 저장되며, 마찬가지로 같은 SA를 사용하는 network를 지원하기 위해 network range, wildcard가 사용된다.&lt;/li&gt;
&lt;li&gt;Next Layer Protocol : IP header다음에 올 protocol type이 온다.&lt;/li&gt;
&lt;li&gt;Name : IPsec이 동일안 운영체제에서 실행경우 사용하는 사용할 수 있는 식별자&lt;/li&gt;
&lt;li&gt;Local and Remote Ports : TCP, UDP Port로 port의 list나 wild card가 올 수있다.&lt;/li&gt;
&lt;li&gt;처리 방식 : PROTECT ( SAD에 따라 처리), BYPASS(IPsec을 이용하지 않고 그냥 송신), DISCARD(폐기)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/kwN1F/btquc32lH3h/6kqAO8E75bjkUfbkksSsK0/img.png' data-lightbox='lightbox' data-alt='SPD 예제&amp;amp;nbsp;'&gt;&lt;img src='https://k.kakaocdn.net/dn/kwN1F/btquc32lH3h/6kqAO8E75bjkUfbkksSsK0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FkwN1F%2Fbtquc32lH3h%2F6kqAO8E75bjkUfbkksSsK0%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-07 at 11.08.21 PM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;SPD 예제&amp;nbsp;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;SAD (Security Association Database)&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
&lt;li&gt;SPI (Security Parameter Index) : 32bit로, 수신자측의 SA 대한 유일한 값이다. Packet을 송신시에는 AH, ESP Header에 값을 적용해서 보내고, 수신시에는 SPI에 매핑되는 SA를 SAD에서 찾아서 사용한다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;Sequence Number Counter : 32bit로, AH와 ESP Header의 Sequence number field에 사용된다.&lt;/li&gt;
&lt;li&gt;Sequence Counter Overflow : Sequence Number Counter가 overflow되었는지 나타내는 flag로 SA에서 추가적인 전송을 막기 위해 사용됨.&lt;/li&gt;
&lt;li&gt;Anti-Replay Window : Replay Attack 을 막는데 사용된다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;AH Infomation : Authentication algorithm, keys, key lifteim. AH와 관련된 parameters&lt;/li&gt;
&lt;li&gt;ESP Information : Encryption and authentication algorithm, keys, initialization values, key lifetims, ESP와 관련된 parameters&lt;/li&gt;
&lt;li&gt;Lifetime of this Security Association : Time interval 이나 byte count가 저장되고, &amp;nbsp;이 작업중 어떤 작업에 수행되어야 될지에 대한 정보가 저장됨.&lt;/li&gt;
&lt;li&gt;IPsec Protocol Mode : Tunnel, Transport, Wildcard&lt;/li&gt;
&lt;li&gt;Path MTU : Path에 대한 MTU&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;IPsec을 사용하면 Outbound와 Inbound에 대해서 처리를 하는데 Logic을 살펴보도록 하자.&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#OUTBOUND PROCESS&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/tGHpd/btqudtM82Fj/wnZNCe0fxAR3w5xnOSLMy0/img.png' data-lightbox='lightbox' data-alt='Outbound Processing Model'&gt;&lt;img src='https://k.kakaocdn.net/dn/tGHpd/btqudtM82Fj/wnZNCe0fxAR3w5xnOSLMy0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FtGHpd%2FbtqudtM82Fj%2FwnZNCe0fxAR3w5xnOSLMy0%2Fimg.png' &gt;&lt;/span&gt;&lt;figcaption&gt;Outbound Processing Model&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;outbound packet이 들어오면 SPD에 일치하는 rule이 있는지 찾아본다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;match되는 rule이 없으면 폐기하고, 에러 메세지를 발생시킨다.&lt;/li&gt;
&lt;li&gt;match되는 rule이 있을때, DISCARD에 해당하는거면 마찬가지로 폐기 시키고, BYPASS이면 그대로 전송한다&lt;/li&gt;
&lt;li&gt;만약 (3)번에서 PROTECT에 해당한다면, SAD를 만들기 위해 entry에 대한 여부를 검색하는데, entry에 해당하는 내용이 없으면 IKE를 이용해 키를 생성하고 SA를 생성한다(이때 SAD의 Identifier가 생성되는 것 같다 그리고 다음에 Identifier를 이용해 SA에서 SAD를 정보를 읽어와 다음 처리시에 사용하는 듯!).&lt;/li&gt;
&lt;li&gt;match되는 entry가 있다면, encryption, authentication, tunnel, transport 등에 대한 IPsec의 모든 처리를 한다. 그 후에 외부로 forward된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#INBOUND PROCESS&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/cNTtPc/btqudTZhxLJ/ZqJE7rAKLRddrn1YTWLyrk/img.png' data-lightbox='lightbox' data-alt='Inbound Processing Model'&gt;&lt;img src='https://k.kakaocdn.net/dn/cNTtPc/btqudTZhxLJ/ZqJE7rAKLRddrn1YTWLyrk/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FcNTtPc%2FbtqudTZhxLJ%2FZqJE7rAKLRddrn1YTWLyrk%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-07 at 11.31.55 PM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;Inbound Processing Model&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;IP Header의 protocol field를 통해 IP packet인지 ESP 또는 AH packet인지 결정한다.&lt;/li&gt;
&lt;li&gt;IP Packet이면 SPD와 바교해서 BYPASS이면 IP header를 decapsulation하여 상위 계층으로 전달하고, BYPASS이외에 해당하는 것들은 폐기 시킨다(Router나 Firewall에서 IPsec이 구현된다고 했는데, 왜 IP Header를 decapsulation하지..?).&lt;/li&gt;
&lt;li&gt;IPsec packet의 경우 SAD에서 match 되는 것이 없는 경우 DISCARD시키고, 이외는 ESP, AH에 대한 처리를 한다. 그리고 IP Header를 Decapsulation한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#Encapsulating Security Payload&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;ESP는 confidentiality, data origin authentication(data integrity) 등등을 optional하게 지원하며, 다양한 종류의 encrpytion, authentication algorithm을 지원한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/dW5gNC/btqudS0eYJR/SkI6rqrj1sni5rc3joNTuk/img.png' data-lightbox='lightbox' data-alt='AH Header'&gt;&lt;img src='https://k.kakaocdn.net/dn/dW5gNC/btqudS0eYJR/SkI6rqrj1sni5rc3joNTuk/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FdW5gNC%2FbtqudS0eYJR%2FSkI6rqrj1sni5rc3joNTuk%2Fimg.png' width=&quot;566&quot; height=&quot;148&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;AH Header&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/dwxs7F/btqubS1lXsO/QZneDywY2CWo5cLgl61ocK/img.png' data-lightbox='lightbox' data-alt='ESP Packet Format'&gt;&lt;img src='https://k.kakaocdn.net/dn/dwxs7F/btqubS1lXsO/QZneDywY2CWo5cLgl61ocK/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fdwxs7F%2FbtqubS1lXsO%2FQZneDywY2CWo5cLgl61ocK%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-08 at 12.45.15 AM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;ESP Packet Format&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;ESP Header는 다음과 같이 구성되어 있다.&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot; data-ke-list-type=&quot;square&quot;&gt;
&lt;li&gt;Security Parameters Index : SA의 identifier&lt;/li&gt;
&lt;li&gt;Sequence Number : re-play attack을 방어하기 위해 사용&lt;/li&gt;
&lt;li&gt;Payload Data : trasport mode 또는 tunnel mode에서 암호회된 패킷&amp;nbsp;&lt;/li&gt;
&lt;li&gt;Padding : 다용도로 사용될 수 있음(보통 pad length와 next header의 위치를 맞추기 위해 사용).&lt;/li&gt;
&lt;li&gt;Pad Length : Padding에 대한 byte 수&lt;/li&gt;
&lt;li&gt;Next Header : 다음에 올 Protocol type&lt;/li&gt;
&lt;li&gt;Integrity Check Value(Authentication Data) : 가변 길이의 field로 ESP Packet에서 Authentication Data field를 제외한 나머지를 compute한 결과가 들어가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;combined mode를 사용하려면, algorithm은 암호화된 평문과, integrity check에대한 결과를 반환해야 하는데, 이 경우 ICV는 생략될 수 있다. &lt;span style=&quot;color: #333333;&quot;&gt;intergiry가 필요한 상황에서&lt;/span&gt;ICV가 생략될 수 있는데 이때는 Payload data encoding이 ICV와 같은 의미를 가진다. 그리고 IV(Initailizaion Value)는 ESP Algorithm에서 사용되는 경우, optional하게 제공된다. 그리고, Traffic Flow Confidentiality는 tunnel mode사용시에 제공되며 Padding data 앞 Payload Data 뒤에 위치한다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Payload Data와 padding, Pad length, Next Header filed는 ESP에서 암호화 되며, 암호화 알고리즘에서 Initalizaion Vector와 같은 값이 필요할 경우 Payload Data의 처음에 위치하게 되며, 보통 암호화 되어 있지 않은 상태로 전달된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;ICV field는 optional하며 integrity service가 선택된 경우에만 integrity algorithm 또는 combained mode에서 사용된다. ICV는 모든 암호화 과정을 거친 이후에 계산되며, 암호화 과정 이후에 계산을 하면 decrypt전에 무결성에 대한 검증을 할 수 있으므로 packet이 부적절한 경우 decrpyt과정에 대한 불필요한 과정을 줄이게 된다. 이 때문에 , DoS를 줄일수도있으며, 복호화와 무결성 체크를 동시에 진행할 수도 있다.&amp;nbsp;다만, ICV는 암호화 되지 않기때문에 적절한 처리가 필요하다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Padding Field는 다음과 같은 목적이 있다.&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;만약 암호화 알고리즘에서 padding이 필요한 경우(블록암호 등)에 사용될 수 있다.&lt;/li&gt;
&lt;li&gt;Pad length와 next header를 더한 값이 32bit가 되어야 하고, ciphertext는 32bit의 배수여야 하기때문에 사용된다.&lt;/li&gt;
&lt;li&gt;실제 payload 길이를 숨기는데 사용될 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;b&gt;Anti-Replay Service&lt;/b&gt;는 replay attack을 방어하기 위해 사용되며, 이때 Sequence Number field가 사용된다. Sequence Number는 sender에서 생성한다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;SA연결이 활성화 되면 Sender는 sequence number를 0으로 설정하고 SA에게 packet이 보내질때마다 &amp;nbsp;Sequence number를 증가시킨다. 이때, 전송횟수는 32비트 최대값을 초과할 수 없으므로, 초과시에는 SA를 종료하고 새로 연결을 시도한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/wzlOY/btqudurUC7u/ZKiF6nDYNILUY33Sdvvua0/img.png' data-lightbox='lightbox' data-alt='Anti-replay Mechanisum'&gt;&lt;img src='https://k.kakaocdn.net/dn/wzlOY/btqudurUC7u/ZKiF6nDYNILUY33Sdvvua0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FwzlOY%2FbtqudurUC7u%2FZKiF6nDYNILUY33Sdvvua0%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-08 at 1.25.15 AM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;Anti-replay Mechanisum&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;기본 Window size(&lt;i&gt;W&amp;nbsp;&lt;/i&gt;)는 64로 가장 최근에 수신한 메세지를 N이라고 한다. 그리고, 가장 최근에 수신한 메세지가 128번이라고 하면 65번 Packet까지만 유효한 패킷으로 받아들이고, 이때 수신한 Packet에 대해선 별도로 mark처리를 해서 만약, replay-attack이 window size내에 시도된다고 하더라도 폐기될 수 있도록 처리한다. 아래는 처리 과정이다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;Window size이내에 새로운 패킷이 도달할 경우 MAC(Message Authentication Code)를 체크해서 통과한 경우 해당 Sequence에 marking 한다.&lt;/li&gt;
&lt;li&gt;Window size 오른쪽에 즉, N+1에 패킷이 도달한 경우 MAC을 체크하고 인증된다면 Window Size 만큼 오른쪽으로 한칸씩 이동시킨후 marking 한다 (즉, N = N+1).&lt;/li&gt;
&lt;li&gt;Window Size 왼쪽에 있는 경우(이전 seq인 경우)나 인증에 실패한 경우 폐기된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/65H0T/btqubATUDYi/2wR3a91Q1pjvmIvF59s3s0/img.png' data-lightbox='lightbox' data-alt='Transport Mode와 Tunnel Mode'&gt;&lt;img src='https://k.kakaocdn.net/dn/65H0T/btqubATUDYi/2wR3a91Q1pjvmIvF59s3s0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2F65H0T%2FbtqubATUDYi%2F2wR3a91Q1pjvmIvF59s3s0%2Fimg.png' &gt;&lt;/span&gt;&lt;figcaption&gt;Transport Mode와 Tunnel Mode&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;ESP Transport Mode&lt;/b&gt;는 encrpyt와 authenticate(optional)에 사용된다. IPv4의 경우 ESP Header는 IP header와 Transport layer사이에 존재하게 되며, &lt;span style=&quot;color: #333333;&quot;&gt;ESP trailer ( padding, pad length, next header field 등)는 packet의 맨마지막(또는, Auth를 지원하는경우 auth 앞)에 존재한다&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;authentication을 사용하는 경우 ESP authentication data field는 ESP Trailer뒤에 추가된다. 모든 Transport packet과 ESP trailer는 암호화 되며, authentication data는 ESP Header와 모든 암호화를 포함한다. 간단하게 말하면 다음의 과정으로 설명할 수 있다.&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;데이터 + ESP Trailer를 암호화하고 메세지를 만듦.&lt;/li&gt;
&lt;li&gt;Router가 (1)에서 만든 packet을 전달 함(이때 Router는 IP header의 Src, Dest만 필요하므로 이후 암호화된 데이터에 대해 영향을 받지 않음).&lt;/li&gt;
&lt;li&gt;IPsec을 지원하는 Router나 방화벽등에서 IPsec에 대한 처리를 한 다음 나머지 원본을 복호화하여 전송함.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;ESP Tunnel Mode&lt;/b&gt;는 IP Packet을 포함한 전체를 암호화 한다. 이 모드에서는 ESP Header가 packet에 더해진 다음 패킷과 ESP Trailer가 암호화 된다. IP header를 암호화 하는 경우, Router에서 처리할 정보가 사라지므로 새로운 IP header를 append한다. 이렇게 하면 Host 각각에 대한 Key 관리에 대한 cost가 줄어들고 final destination에 대한 analysis를 할수가 없다.&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;Sender가 packet을 생성하고 이 packet앞에 ESP Header를 붙인다. 그다음 암호화된 ESP Trailer와 Authentication Data를 붙인다. 그리고 Destination IP를 firewall로 설정한 새로운 IP Header로 encapsulation한다.&lt;/li&gt;
&lt;li&gt;라우터에 의해 firewall로 전송된다.&lt;/li&gt;
&lt;li&gt;새로 만들어진 IP header(outer IP header)를 처리하고 검사후에 기존내용을 복구하고, 기존에 Destination으로 전송한다.&amp;nbsp;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/bmr8j2/btqucoMwpwE/dxt6ia4LVsCe2LhpAe2aHk/img.png' data-lightbox='lightbox' data-alt='Transport vs Tunnel'&gt;&lt;img src='https://k.kakaocdn.net/dn/bmr8j2/btqucoMwpwE/dxt6ia4LVsCe2LhpAe2aHk/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fbmr8j2%2FbtqucoMwpwE%2Fdxt6ia4LVsCe2LhpAe2aHk%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-08 at 2.22.39 AM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;Transport vs Tunnel&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;SA&lt;/b&gt;는 AH와 ESP Protocol을 모두 지원하지만 동시에 지원하진 못한다. 어떤 상황에서는 AH와 ESP를 동시에 사용해야할 때도 있는데, 이때는 같은 Traffic Flow에 대해 여러개의 SA가 사용되어야 한다. &lt;i&gt;Security Association Bundle &lt;/i&gt;은 IPsec 서비스 set을 제공하기 위해 트래픽을 처리해야 하는 sequnece SA를 의미한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;Transport adjacency : tunneling을 사용하지 않고 2개이상의 보안 프로토콜을 IP packet에 적용하는 것을 의미하며, AH와 ESP가 한곳에서 실행되기 때문에 이점이 없음.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;Iterated tunneling : Tunnel을 통해 (새로운 IP header 추가를 통해) 여러 계층의 보안 프로토콜을 적영할 수 있으므로 경로상에서 각각의 Router에 대해 처리될 수 있으므로 이점이 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#Authentication + Confidentiality&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Encrpytion과 Authenticaion은 IP Packet에서 함께 사용될 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;ESP와 Authentication option&lt;/b&gt;을 함께 사용하는 경우 ESP data를 붙인 후 authentication data field를 붙인다. 즉, &lt;b&gt;암호화를 먼저 한 후, authentication에 대한 처리를 진행&lt;/b&gt;한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot; data-ke-list-type=&quot;square&quot;&gt;
&lt;li&gt;Transport mode ESP : IP payload + ESP trailer를 encrypt하고, Authenication은 Encrpytion은 Ecryption된 데이터와 ESP Header에 대해 유효함(IP Header에는 유효하지 않음).&lt;/li&gt;
&lt;li&gt;Tunnel mode ESP : Authencaiton은 모든 IP header(outer IP Header)를 포함한 모든 패킷에 적용되며, 목적지에서 authentication에 대한 처리가 진행된다. 그리고 inner IP header는 encrpytion 되어있다.&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;두 경우 모두 암호화된 문장에 대해 authentication이 진행된다(이에 대한 이유는 위에서 간단하게 언급했다).&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Transport Adjacency&lt;/b&gt;는 &lt;b&gt;암호화 후 인증&lt;/b&gt;을 적용하는 또다른 방법으로 두개의 SA( AH - ESP)을 &amp;nbsp;사용한다. AH를 ESP의 header부분에 두게 되면, AH에 의해 인증이 되고, 내부의 ESP에 의해 전체 packet이 암호화가 되므로 암호화 이후 인증을 적용할 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;암호화 이전에 인증을 사용하는 이유&lt;/b&gt;에는 몇가지가 있을 수 있는데, 첫번째로 authentication에 대한 내용을 암호화한다면, 다른 사람이 메세지를 가로채서 인증 정보를 조작하는것이 불가능하다. 두번째로, 나중에 사용할때 암호화되지 않은 메세지와 인증 정보를 저장하는 것이 더욱 적합하다. 예를들어 암호화 된 정보에 대해 인증을 제공한다면, 추후에 메세지에 대한 인증을 다시한번 해야할때, 인증 정보를 검증하기 위해선 암호화를 다시 해야하므로 부적절하다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;암호화 이전에 인증을 사용하는 방법으로는 위의 예시와는 반대로 AH를 Inner Header로 두고, ESP를 외부로 두는 경우 인증을 위해선 먼저 &amp;nbsp;암호화를 풀고 AH에 의해 인증을 할 수 있고, AH가 인증 하는 패킷에 대한 내용은 plaintext이므로 구현할 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/b6OMON/btqud6ycWTZ/Rzj7TYNxDeU0a8YoZtz3d0/img.png' data-lightbox='lightbox' data-alt='다양한 IPsec의 조합 및 사용'&gt;&lt;img src='https://k.kakaocdn.net/dn/b6OMON/btqud6ycWTZ/Rzj7TYNxDeU0a8YoZtz3d0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fb6OMON%2Fbtqud6ycWTZ%2FRzj7TYNxDeU0a8YoZtz3d0%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-08 at 10.53.25 PM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;다양한 IPsec의 조합 및 사용&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;# Internet Key Exchange&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Key Management의 일부는 키 결정 및 분배에 관한 문제이다. Key management에는 2가지 type이 존재한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;Manual : 시스템 관리자가 각 시스템 마다 자신의 키와 다른 communicating system의 키를 ㅣ용해서 설정하는 것으로 규모가 작거나 정적인(변동이 거의 없는) 환경에 적합하다.&lt;/li&gt;
&lt;li&gt;Automated : automated system은 on-demand(고객의 needs가 있을 때 즉시 처리해주는 것을 뜻함) 형식으로 key를 만들어 주고, 대규모 시스템에서 키를 쉽게 사용할 수 있게 해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Automated key management protocol은 또 두개(ISAKMP / Oakley)로 나뉜다.&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;Oakley Key Determination Protocol : Deffie-Hellman algorithm을 기반으로 하고 있으나, 추가적인 보안을 제공하며 특별한 format이 없다.&lt;/li&gt;
&lt;li&gt;ISAKMP (Internet Security Association and Key Management Protocol) : Internet key management를 위한 framework를 제공하고 format이 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;ISAKMP는 특별한 key exchange algorithm을 지정하지 않는다. 대신 사용할 수 있는 여러가지 key exchange algorithm에 대한 type으로 구성되어 있다. Oakley는 ISAKMP 초기 버전과 함께 사용되는 특정한 키 교환 알고리즘 이다. IKEv2(Version 2)에서 Oakley와 ISAKMP는 더이상 사용되지 않고, IKEv1의 Oakley 와 ISAKMP의 사용과는 상당히 다르나 기본적인 기능은 같다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#Key Determination Protocol&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;IKE는 Diffie-Hellman key exchange algorithm을 개선 시켜서 사용한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;q &lt;/i&gt;는 아주 큰 소수 이고, a는 q의 primitive root 이다.&lt;/p&gt;
&lt;div data-ke-type=&quot;moreLess&quot; data-text-more=&quot;더보기&quot; data-text-less=&quot;닫기&quot;&gt;&lt;a class=&quot;btn-toggle-moreless&quot;&gt;...더보기&lt;/a&gt;
&lt;div class=&quot;moreless-content&quot;&gt;
&lt;p&gt;primitive root는 q에 대한 modulo 연산을 했을때 q에 대해 모든 나머지가 나오는것을 말한다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;a = 2 q = 11이라고 가정해보자.&lt;/p&gt;
&lt;p&gt;a^2 mod 11 = 4&lt;/p&gt;
&lt;p&gt;a^3 mod 11 = 8&lt;/p&gt;
&lt;p&gt;a^4 mod 11 = 5&lt;/p&gt;
&lt;p&gt;a^5 mod 11 = 10&lt;/p&gt;
&lt;p&gt;a^6 mod 11 = 9&lt;/p&gt;
&lt;p&gt;a^7 mod 11 = 7&lt;/p&gt;
&lt;p&gt;a^8 mod 11 = 3&lt;/p&gt;
&lt;p&gt;a^9 mod 11 = 6&lt;/p&gt;
&lt;p&gt;a^10 mod 11 = 1&lt;/p&gt;
&lt;p&gt;a^11 mod 11 = 2&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;이와같이 모든 나머지를 얻을 수 있으므로 a는 q의 primitive root라고 한다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;$$q$$&lt;/p&gt;
&lt;p&gt;Big Prime Number&lt;/p&gt;
&lt;p&gt;$$\alpha$$&amp;nbsp;&lt;/p&gt;
&lt;p&gt;primmitive root of &lt;i&gt;q&amp;nbsp;&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;Deffie Hellman 알고리즘은 2가지 특징이 있다.&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;Secret-key는 필요시에 생성되며 장기간 보관할 필요가 없다.&lt;/li&gt;
&lt;li&gt;특별한 infrastructure가 필요하지 않다(module 연산과 단순 연산으로 비밀키를 공유할 수 있다).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Deffie-Hellman에서 완벽한 키교환에 대한 알고리즘을 제공하는 반면, 취약점이 있다.&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;통신하는 주체의 신원을 보장할 수 없다.&lt;/li&gt;
&lt;li&gt;따라서, MITM 공격의 대상이 될 수 있으며, A 와 B가 통신을 하려할때 제 3자인 C가 중간에서 A에게는 B인척을, B에게는 A인척을 해서 A와 B의 Diffie-Hellman 키 교환시에 C를 통해서 합의가 이루어 지도록 한다면, 중간에서 C가 정한 임의의 값을 통해 만들어진 Secret-key로 통신을 주도할 수 있다.&lt;/li&gt;
&lt;li&gt;clogging attack에 취약하다(공격자가 많은 양의 key를 request하는 attack).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IKE에서는 이 Diffie-hellman의 장점을 가지는 반면, 위와 같은 취약점을 보완할 수 있도록 다시 디자인했다.&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;clogging attack을 방지 하기 위해 cookie라고 하는 mechanism을 고안했다.&lt;/li&gt;
&lt;li&gt;알고리즘을 식별할 수 있고, Diffie-Hellman exchange의 global parameter를 지정할 수 있도록 하였다/&lt;/li&gt;
&lt;li&gt;replay-attack을 막기위해 nonce값을 사용한다.&lt;/li&gt;
&lt;li&gt;Deffie=Hellman의 &amp;nbsp;public-key교환을 가능하도록 한다.&lt;/li&gt;
&lt;li&gt;MITM을 막기위한 인증을 제공한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위에서 언급한 것 처럼 clogging attack은 중간에서 public-key를 victim에게 전송하면 victim은 secret-key를 얻기위해 지수연산을 계속하게 되고 이런 request가 반복되면 의미없는 지수연산으로 인해 시스템 자원이 소모된다. cookie exchange는 각 pseudo random number를 처음 메세지에 전송시 상대방에게 보내고 상대방은 그에 대한 acknowledge로 응답한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;Cookie는 특정인에 대해 유효해야 하며, 이렇게 하면 Attacker가 실제 IP와 UDP를 사용해서 유효한 Cookie를 획득하더라도, random으로 생성한 IP나 Port를 위에서 생성한 Cookie를 이용해 통신을 시도하려고 해도 정상적으로 동작하지 않는다.&lt;/li&gt;
&lt;li&gt;Cookie를 &amp;nbsp;발행자 이외에 누구도 유효한 쿠키를 생성할 수 없어야 한다. 즉, 발행자가 가지고 있는 local secret information을 통해 생성하고, 검증할 것을 의미하며. 쿠키를 통해 저 local secret information을 추론할 수 없어야 한다. local secret information이 공개되는 경우에는 더 취약해 지지만, 들어오는 쿠키에 대해 검증을 할 수 있다.&lt;/li&gt;
&lt;li&gt;생성 및 검증은 clogging attack을 막기 위해 충분히 빨라야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;권장하는 것은 IP Src, Dest UDP Src, Dest Port과 secret value를 이용해 md5를 사용하는것이다. 또한, 768, 1024, 1536 bit의exponentiation moduler와, Elliptic curve group 2^155, 2^185도 지원한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/d2baKI/btqudTMICwf/vcSAYTiEXMSfhLLgBL1mCK/img.png' data-lightbox='lightbox' data-alt='Group of IKE'&gt;&lt;img src='https://k.kakaocdn.net/dn/d2baKI/btqudTMICwf/vcSAYTiEXMSfhLLgBL1mCK/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fd2baKI%2FbtqudTMICwf%2FvcSAYTiEXMSfhLLgBL1mCK%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-09 at 4.02.23 AM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;Group of IKE&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;그리고 Replay-attack을 막기위해 none가 pesudorandom number로 생성되며, 암호화 된다.&amp;nbsp;&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;Digital signature : User의 ID나 nonce와 같은 값들을 암호화 해서 Hash한 후 각 Private-key로 암호화 한다.&lt;/li&gt;
&lt;li&gt;Public-key encrpytion : ID와 Nonce 값을 Sender의 private-key로 암호화 한다&lt;/li&gt;
&lt;li&gt;Symmetric-key encryption : 기존에 생성된(어디선가 생성된) key를 이용해서 암호화 할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/buRXwi/btquAamFNWz/YbsU8NgeGHL6iwyHaECcQ0/img.png' data-lightbox='lightbox' data-alt='IKEv2 Exchange'&gt;&lt;img src='https://k.kakaocdn.net/dn/buRXwi/btquAamFNWz/YbsU8NgeGHL6iwyHaECcQ0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbuRXwi%2FbtquAamFNWz%2FYbsU8NgeGHL6iwyHaECcQ0%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-16 at 1.05.38 PM 1.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;IKEv2 Exchange&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Initial exchange&lt;/b&gt;에서는 첫번째로 cryptographic algorithm과 security parameters 및 nonce와 같은 정보를 교환한다. 결과로, IKE SA가 set up된다. 이 SA는 상대방 간의 보안 채널에 대한 매개 변수를 정의하며, 이로 인해 메세지는 authentication와 encryption 처리 된다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;두번째로, 인증 및 통신을 보호하는데 사용될 IPsec SA를 설정한다&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;CREATE_CILD_SA exchange&lt;/b&gt;는 트래픽 보호를 위한 추가 SA를 설정할 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Information exchange&lt;/b&gt;는 정보를 교환하는데 사용된다. IKEv2의 error 메세지나 notification 등&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#IKE Header&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;IKE Header는 하나 이상의 payload로 구성되어 있으며 UDP 프로토콜을 이용해서 전달된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/cfEP4s/btqugT5yJ4n/KIk2pCCf4jyyeBc9uKjxbK/img.png' data-lightbox='lightbox' data-alt='IKE Format'&gt;&lt;img src='https://k.kakaocdn.net/dn/cfEP4s/btqugT5yJ4n/KIk2pCCf4jyyeBc9uKjxbK/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FcfEP4s%2FbtqugT5yJ4n%2FKIk2pCCf4jyyeBc9uKjxbK%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-09 at 4.25.24 AM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;IKE Format&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;Initator SPI : SA에 대한 Unique한 값&lt;/li&gt;
&lt;li&gt;Responder SPI : responder가 선택한 SA의 값&lt;/li&gt;
&lt;li&gt;Next Payload : 다음에 올 payload의 값&lt;/li&gt;
&lt;li&gt;Major Version : IKE의 Major version&lt;/li&gt;
&lt;li&gt;Minor Version : Minor version&lt;/li&gt;
&lt;li&gt;Exchange Type : exchange 할 type을 가리킨다.&lt;/li&gt;
&lt;li&gt;Flags : IKE exchange에 대한 옵션으로 &amp;nbsp;8bit 중 3bit가 현재 정의 되어 있으며, initiator bit는 packet이 SA intiiator로 부터 발송되었는지를 뜻하고, version bit 현재 사용중인 버전보다 더 높은 버전을 사용할 수 있는지, 그리고 response bit는 동일 Message ID에 대한 응답인지를 나타냄.&lt;/li&gt;
&lt;li&gt;Message ID : Message ID는 Retransmission및 응답에 대한 제어를 위해 사용&lt;/li&gt;
&lt;li&gt;Length : Header와 Payload를 포함한 전체 길이&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/2mYXP/btqufbzkIRB/QcV6FfktluODRYakt4kNm0/img.png' data-lightbox='lightbox' data-alt='ISAKMP에 대한 패킷&amp;amp;nbsp;'&gt;&lt;img src='https://k.kakaocdn.net/dn/2mYXP/btqufbzkIRB/QcV6FfktluODRYakt4kNm0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2F2mYXP%2FbtqufbzkIRB%2FQcV6FfktluODRYakt4kNm0%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-09 at 4.31.22 AM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;ISAKMP에 대한 패킷&amp;nbsp;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/VGzFk/btqugDoldNi/pnIs2sJwaCP492pbkw1PAk/img.png' data-lightbox='lightbox' data-alt='IKE Payload'&gt;&lt;img src='https://k.kakaocdn.net/dn/VGzFk/btqugDoldNi/pnIs2sJwaCP492pbkw1PAk/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FVGzFk%2FbtqugDoldNi%2FpnIs2sJwaCP492pbkw1PAk%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-09 at 4.48.12 AM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;IKE Payload&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot; data-ke-list-type=&quot;square&quot;&gt;
&lt;li&gt;Key Exchange payload : 키 교교환에 사용되는 Oakley, Diffe-Hellman RSA 등등&lt;/li&gt;
&lt;li&gt;Identification payload : 식별자로 IP 주소가 들어가 있는 경우가 많음&lt;/li&gt;
&lt;li&gt;Certificate payload : 아래와 같은 public-key 인증 정보를 포함하는 filed
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
&lt;li&gt;PKCS #7 wrapped X.509 certificate&lt;/li&gt;
&lt;li&gt;PGP certificate&lt;/li&gt;
&lt;li&gt;DNS signed key&lt;/li&gt;
&lt;li&gt;X.509 certificate - signature&lt;/li&gt;
&lt;li&gt;x.509 certificate - key exchange&lt;/li&gt;
&lt;li&gt;Kerberos tokens&lt;/li&gt;
&lt;li&gt;CRL&lt;/li&gt;
&lt;li&gt;ARL&lt;/li&gt;
&lt;li&gt;SPKI certificate&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#Cryptographic suite&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;IPsec Version 3와 IKEv3는 다양한 암호알고리즘을 지원한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;RFC 4308에는 VPN을 위한 2개의 암호화를 이야기하고 있으며 그게 VPN-A와 VPN-B이다.&lt;/p&gt;
&lt;p&gt;VPN-A의 경우 이전 IKEv1에서 사용하는 보안과 일치하며 VPN-B가 보다 강력한 보안을 제공하며 IPsec Version 3및 IKEv2를 제공하는 VPN에 권장된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/cGBvr2/btqufbTDqbo/VIrDdxtvVytITxy9OiDEk0/img.png' data-lightbox='lightbox' data-alt='VPN-A vs VPN-B'&gt;&lt;img src='https://k.kakaocdn.net/dn/cGBvr2/btqufbTDqbo/VIrDdxtvVytITxy9OiDEk0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FcGBvr2%2FbtqufbTDqbo%2FVIrDdxtvVytITxy9OiDEk0%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-09 at 5.04.53 AM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;VPN-A vs VPN-B&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block; text-align:center;&quot;
     data-ad-layout=&quot;in-article&quot;
     data-ad-format=&quot;fluid&quot;
     data-ad-client=&quot;ca-pub-3588179945681108&quot;
     data-ad-slot=&quot;3731887415&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.dork94.com/184&amp;amp;layout=button_count&amp;amp;show_faces=true&amp;amp;width=106&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:106px; height:30px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Network</category>
<author>Dork94</author>
<guid>https://blog.dork94.com/184</guid>
<comments>https://blog.dork94.com/184#entry184comment</comments>
<pubDate>Sat, 06 Apr 2019 21:24:07 +0900</pubDate>
</item>
<item>
<title>S/MIME (Secure/Multipurpose Internet Mail Extension) - 3</title>
<link>https://blog.dork94.com/183</link>
<description>&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.dork94.com/181&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;S/MIME&amp;nbsp;(Secure/Multipurpose&amp;nbsp;Internet&amp;nbsp;Mail&amp;nbsp;Extension)&amp;nbsp;- 1&lt;/a&gt; 에서는 S/MIME을 알기에 앞서 MIME에 대해 알아보았고,&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.dork94.com/182&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;S/MIME&amp;nbsp;(Secure/Multipurpose&amp;nbsp;Internet&amp;nbsp;Mail&amp;nbsp;Extension)&amp;nbsp;-&amp;nbsp;2&lt;/a&gt; 에서 기본적인 S/MIME에 대해서 알아보았다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#DKIM(Domainkeys Identified Mail)&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;DKIM는 &amp;nbsp;e-mail messages를 서명하기 위한 기술이다. 메세지 수신자는 signer의 domain에 직접 query를 날려 public-key를 가져옴으로써, 메세지가 signing domain의 private-key로 sign되었는지를 확인하여 서명을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;즉, 메일이 오면 메세지에 적혀있는 도메인으로 query를 날려 서명을 비교하여 실제 그 도메인에서 발송된 메일인지, 아닌지를 판별할 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;DKIM은 RFC 4871에 정의되어 있으며 많이 사용되고 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/CzVRC/btqubAZynSd/GU4c95kUikdmoqgo9jNGrK/img.png' data-lightbox='lightbox' data-alt='E-mail Flow'&gt;&lt;img src='https://k.kakaocdn.net/dn/CzVRC/btqubAZynSd/GU4c95kUikdmoqgo9jNGrK/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FCzVRC%2FbtqubAZynSd%2FGU4c95kUikdmoqgo9jNGrK%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-05 at 6.12.23 PM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;E-mail Flow&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot; data-ke-list-type=&quot;square&quot;&gt;
&lt;li&gt;MUA
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
&lt;li&gt;Message User Agent로 사용자가 사용하는 메일 프로그램 등&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MSA
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
&lt;li&gt;Mail Submission Agent로 MUA로부터 메세지를 받아서 전달해주며, 보통 MUA와 함께 있거나 기능으로 제공된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MTA
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
&lt;li&gt;Message Transfer Agent로 메일을 전달해준다. 쉽게 말해 네트워크에서 라우터나 스위치 같은 역할이며, 서버라고 보면 될 듯 하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MDA
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
&lt;li&gt;MHS와 MS사이에 전달을 해주는 다리 같은 역할&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MS
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
&lt;li&gt;MUA와 같이 있거나 원격 서버의 형태로 존재할 수 있으며 POP이나 IMAP을 통해 메세지를 가져온다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;뭔가, 이 저자는 엄청 상세하게 나눈 것 같다. 보통은 (sender)MUA-MTA-MDA-MUA(receiver)의 순서로 생각하면 될 것 같다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#E-mail Threat&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;RFC 4686에서는 DKIM의 Characterisitics, Capabilities, location에 대한 Threat들을 설명하고 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;Characterisitic
&lt;ol style=&quot;list-style-type: decimal;&quot;&gt;
&lt;li&gt;recipient가 원하지 않는 메일을 Attacker가 보내려고 할때 Sender의 Address를 변조해 바꿀 수 있다. 이러면, 스팸을 필터링하기 쉽지 않다.&lt;/li&gt;
&lt;li&gt;다량의 스팸메일을 보내는 Attacker는 Third party대신 상업 enterpise를 이용하며, Tool을 많이 사거나, MTA나 Zombie등을 이용해 attack하기도 한다.&lt;/li&gt;
&lt;li&gt;DNS cache-posioning Attack 이나 , IP routing attack등 가능한 모든 방법을 동원해서 직접적인 금전 이득을 얻는 Attacker도 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Capabilities
&lt;ol style=&quot;list-style-type: decimal;&quot;&gt;
&lt;li&gt;MTA와 MSA에 메세지를 보낼 수 있다.&lt;/li&gt;
&lt;li&gt;Message Header field를 자유롭게 수정할 수 있다.&lt;/li&gt;
&lt;li&gt;domain을 대신해 message에 sign할 수 있다.&lt;/li&gt;
&lt;li&gt;DoS Attack에 이용하기 위해 unsigned되거나 signed된 것처럼 보이는 메세지를 생성할 수 있다.&lt;/li&gt;
&lt;li&gt;이미 Signed된 메세지를 다시 보낼 수 있다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;모든 envelope information을 이용해서 메세지를 보낼 수 있다.&lt;/li&gt;
&lt;li&gt;취약한 컴퓨터에 대해 signed된 메세지 처럼 보낼 수 있다.&lt;/li&gt;
&lt;li&gt;IP routing을 이용해 IP 추적이 어려운 주소를 이용해 메세지를 전송하거나 메세지를 특정 domain으로 forwarding 할 수 있다.&lt;/li&gt;
&lt;li&gt;DNS를 이용하는 한계 때문에 DNS를 이용한 Attack을 할 수 있다.&lt;/li&gt;
&lt;li&gt;특정한 자원을 감염된 좀비를 통해 Access할 수 있다. (DDoS나 Brute Force 등)&lt;/li&gt;
&lt;li&gt;Wireless환경에서 Packet Sniffing을 할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;DKIM은 e-mail 인증 을 제공하기 위해 디자인되었다. 사용자의 이메일은 sender의 administrative domain의 private-key로 signed된다. &amp;nbsp;message header와 content전부를 signed 하며, MDA가 DNS의 public-key를 이용해 검증한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;이 검증 과정을 통해 Domain에서 온 것임을 증명한다. 그래서 이 인증과정에 문제가 있을 경우(Public-key로 복호화를 시도했을때 제대로 복호화가 되지 않은 경우)는 거절될 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;S/MIME는 Sender와 Receiver모두 S/MIME 를 사용해야 한다. 거의 대부분 수신시에 S/MIME을 사용하지 않으며 보낼때 역시 수신자가 S/MIME을 사용하지 않는다. 게다가 S/MINE은 message content에 대해 sign만 진행해서 header에 대해서는 취약할 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;DKIM은 Client program(MUA)에서 구현되지 않아서 사용자에게 전달될때 다른 조치를 취하지 않아도 된다. 그리고 DKIM은 모든 domain을 사용하는 메일에 적용되며 domain을 이용해 속일 수 없도록 만들어준다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/RVTwR/btqubCpZudE/wputHSQYKKUePFQC4qfgY1/img.png' data-lightbox='lightbox' data-alt='DKIM Flow'&gt;&lt;img src='https://k.kakaocdn.net/dn/RVTwR/btqubCpZudE/wputHSQYKKUePFQC4qfgY1/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FRVTwR%2FbtqubCpZudE%2FwputHSQYKKUePFQC4qfgY1%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-06 at 1.27.23 AM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;DKIM Flow&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;DKIM은 위처럼 동작한다. 먼저, 보내고자 하는 메일을 MSA(Mail Submission Agent)를 이용해 메세지를 보내게 되는데(이때 MSA는 User가 이용하는 domain에 속해있다), MSA에게 보낼때는 MSA의 공개키를 이용해 암호화해서 보낸다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;그 후, MSA가 Sign을 하게되고 MTA에게 메일을 전송하게 되고 받고자 하는 사용자의 MDA에 전달되게 된다. 이때 MDA는 MSA의 DNS Server에 public-key에 대한 query를 요청한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;그리고 응답으로 Sign을 했다고 주장하는 MDA의 Public-key를 받아 Sign을 verify하게 된다. public-key를 이용해 복호화에 성공하면 MUA에게 정상적으로 보내고 그렇지 않으면 상황에 따라 다르게(MDA의 정책에 따라) 수신 여부를 결정하게 된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;DKIM에서 message를 처리하는 것은 Signing ADMD(Administrative Management Domain)과 Verifying ADMD로 나뉘며, Singing은 Signing ADMD에서 이뤄지고, Key Store에서 private-key에 대한 정보를 얻어서 사용한다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/bd11jA/btquaPjfktI/fBEM54UMclEA2JbpIZwhE0/img.png' data-lightbox='lightbox' data-alt='DKIM Flow'&gt;&lt;img src='https://k.kakaocdn.net/dn/bd11jA/btquaPjfktI/fBEM54UMclEA2JbpIZwhE0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fbd11jA%2FbtquaPjfktI%2FfBEM54UMclEA2JbpIZwhE0%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-06 at 4.33.28 PM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;DKIM Flow&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;DKIM은 RFC 5322 Header에 부가적으로 존재하며 아래 처럼 생겼다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;v = DKIM version&lt;/p&gt;
&lt;p&gt;a = signature을 서명할때 사용한 알고리즘으로 rsa-sha1이거나 rsa-sha256이어야 한다.&lt;/p&gt;
&lt;p&gt;c = Canonicalization method(아래에서 짧게 설명한다)&lt;/p&gt;
&lt;p&gt;d = domain name (SDID)&lt;/p&gt;
&lt;p&gt;s = selelctor로 같은 도메인에 대해 다른상황에서 다른키가 사용될 수 있기 때문에, s를 지정해준다.&lt;/p&gt;
&lt;p&gt;h = Signed Header field&lt;span style=&quot;color: #333333;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;로&lt;/span&gt; 여러개의 값이 존재하며 ':' 각 field를 구분한다.&lt;/p&gt;
&lt;p&gt;bh = c의 method를 이용해 canonicalized된 &lt;span style=&quot;color: #333333;&quot;&gt;body에 대한 hash값&lt;/span&gt;이다.&lt;/p&gt;
&lt;p&gt;b = encrypt된 hash로 base64의 형태로 인코딩 되어있다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/p6lTB/btquds1fFEw/ZySBq8I3QAlIlzRNkgQYl1/img.png' data-lightbox='lightbox' data-alt='DKIM Header'&gt;&lt;img src='https://k.kakaocdn.net/dn/p6lTB/btquds1fFEw/ZySBq8I3QAlIlzRNkgQYl1/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fp6lTB%2Fbtquds1fFEw%2FZySBq8I3QAlIlzRNkgQYl1%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-06 at 4.50.03 PM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;DKIM Header&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;그리고 실제로 사용중인 메일에서 확인을 해보았다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/xuYud/btquaQCtae9/ivvAa9RdNiplq3ZM8X1Vf0/img.png' data-lightbox='lightbox' data-alt='Applie Mail Application에서 캡쳐한 DKIM Header'&gt;&lt;img src='https://k.kakaocdn.net/dn/xuYud/btquaQCtae9/ivvAa9RdNiplq3ZM8X1Vf0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FxuYud%2FbtquaQCtae9%2FivvAa9RdNiplq3ZM8X1Vf0%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-06 at 4.53.06 PM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;Applie Mail Application에서 캡쳐한 DKIM Header&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;div data-ke-type=&quot;moreLess&quot; data-text-more=&quot;더보기&quot; data-text-less=&quot;닫기&quot;&gt;&lt;a class=&quot;btn-toggle-moreless&quot;&gt;...더보기&lt;/a&gt;
&lt;div class=&quot;moreless-content&quot;&gt;
&lt;p&gt;Apple Mail Application에서는 보고자 하는 메일에서 상태바의 View-message-Raw Source를 통해 확인할 수 있다(단축키는 -option+ command + u). 또한 gmail에서도 아래와 같은 옵션으로 확인할 수 있다.&lt;/p&gt;
&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/phfbv/btquaPXUE0V/pAJsvVkWkItYYRqxuLQo31/img.png' data-lightbox='lightbox' data-alt='원본 보기를 클릭하면 마찬가지로 Raw Data를 볼 수 있다.'&gt;&lt;img src='https://k.kakaocdn.net/dn/phfbv/btquaPXUE0V/pAJsvVkWkItYYRqxuLQo31/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fphfbv%2FbtquaPXUE0V%2FpAJsvVkWkItYYRqxuLQo31%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-06 at 4.59.57 PM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;원본 보기를 클릭하면 마찬가지로 Raw Data를 볼 수 있다.&lt;/figcaption&gt;&lt;/figure&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/PVWei/btqubfWknTl/6n9S5N4bpm0RGMfmryVDuK/img.png' data-lightbox='lightbox' data-alt='네이버에서 이런 서비스도 제공하고 있는데, 아마 DKIM을 이용하거나 본인들의 도메인 IP에서 발송된 IP가 아니면 경고를 띄워주는 방식인 듯하다. naver mail에서 Raw data를 볼 수 있는 항목은 못찾았다.'&gt;&lt;img src='https://k.kakaocdn.net/dn/PVWei/btqubfWknTl/6n9S5N4bpm0RGMfmryVDuK/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FPVWei%2FbtqubfWknTl%2F6n9S5N4bpm0RGMfmryVDuK%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-06 at 5.01.45 PM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;네이버에서 이런 서비스도 제공하고 있는데, 아마 DKIM을 이용하거나 본인들의 도메인 IP에서 발송된 IP가 아니면 경고를 띄워주는 방식인 듯하다. naver mail에서 Raw data를 볼 수 있는 항목은 못찾았다.&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Canonicalization은 character encoding, white space에 대한 처리, 헤더의 foding과 unfoding 기능에 처리 과정중 변화 가능성을 다루기 위해 필요하며, header와 body에 모두에 대해서 처리된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;div data-ke-type=&quot;moreLess&quot; data-text-more=&quot;더보기&quot; data-text-less=&quot;닫기&quot;&gt;&lt;a class=&quot;btn-toggle-moreless&quot;&gt;...더보기&lt;/a&gt;
&lt;div class=&quot;moreless-content&quot;&gt;
&lt;p&gt;Canonical이라는 단어가 생소해서 찾아보니 IT 문서에서 다루는 Canonical의 뜻은 &quot;authoritative&quot;, &quot;standard&quot;, &quot;official과 같은 단어라고 한다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: right;&quot;&gt;Ref:&amp;nbsp;&lt;a href=&quot;https://english.stackexchange.com/questions/34920/what-does-canonical-mean&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://english.stackexchange.com/questions/34920/what-does-canonical-mean&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Canonicalization은 송신 메세지를 작게 하기 위해서 사용되며 body field를 위한 2가지 알고리즘(simple, relaxed)이 있다. simple 알고리즘은 거의 수정을 하지 않으며, 반면 relaxed 알고리즘의 경우 수정을 한다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;요렇게 DKIM도 끗!&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;간단히 말하면, 그냥 sender의 도메인의 dns에 접속해서 실제 그 도메인을 통해 왔는지, 아닌지를 위의 형식(DKIM-signature)를 통해 검사하는 process 이다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;틀린 정보나 궁금한 점이 있으면 댓글로 부탁드립니다 :)&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block; text-align:center;&quot;
     data-ad-layout=&quot;in-article&quot;
     data-ad-format=&quot;fluid&quot;
     data-ad-client=&quot;ca-pub-3588179945681108&quot;
     data-ad-slot=&quot;3731887415&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.dork94.com/183&amp;amp;layout=button_count&amp;amp;show_faces=true&amp;amp;width=106&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:106px; height:30px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Network</category>
<author>Dork94</author>
<guid>https://blog.dork94.com/183</guid>
<comments>https://blog.dork94.com/183#entry183comment</comments>
<pubDate>Fri, 05 Apr 2019 17:10:01 +0900</pubDate>
</item>
<item>
<title>S/MIME (Secure/Multipurpose Internet Mail Extension) - 2</title>
<link>https://blog.dork94.com/182</link>
<description>&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://blog.dork94.com/181&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;S/MIME (Secure/Multipurpose Internet Mail Extension) - 1&lt;/a&gt;&amp;nbsp;&lt;/b&gt;에서는 S/MINE을 시작하기에 앞서 MINE은 어떻게 구성되어 있는지 알아보고, 마지막에 S/MINE이 어떤 것인지 알아봤다. 이제 본격적으로 S/MINE에 대해 알아보자!&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;S/MINE은 Secure &amp;nbsp;+ MIME으로, MINE에 Signature, Encryption이 고려된 것을 말한다. S/MIME는 PKCS를 통해 Algorithm indentifier 이나 certificate 등을 처리한다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;PKCS는 Message content를 통해 처리되며, MIME 형식으로 header를 통해 제공된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/kIjCM/btqt4yVGMYv/qrzpxdrxlJfgq8sm9YlCf1/img.png' data-lightbox='lightbox' data-alt='S/MIME Content Type'&gt;&lt;img src='https://k.kakaocdn.net/dn/kIjCM/btqt4yVGMYv/qrzpxdrxlJfgq8sm9YlCf1/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FkIjCM%2Fbtqt4yVGMYv%2FqrzpxdrxlJfgq8sm9YlCf1%2Fimg.png' &gt;&lt;/span&gt;&lt;figcaption&gt;S/MIME Content Type&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;PGP에서 다뤘듯, Content Type은 중요하다! 대부분의 서비스가 Content Type을 통해 이뤄진다. 마찬가지로, encrypt등을 하게되면 Binary data가 생성되므로, 인코딩도 역시 사용된다(Base64)&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#EnvelopedData&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;EnvelopedData는 아래와 같은 순서로 제공된다(EnvelopedData는 암호화한 데이터 정도로 해석하면 될 것 같다).&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;대칭키 암호화(RC2/40이나 3DES)를 위한 pseudo random session key를 생성한다.&lt;/li&gt;
&lt;li&gt;수신자의 RSA public-key로 session-key를 암호화 한다(수신자는 여러명이 될 수도 있으며, 이때는 각각 수신자의 public-key로 암호화)&lt;/li&gt;
&lt;li&gt;RecipientInfo block을 준비한다. RecipientInfo는 수신자의 public-key certificate에 대한 식별자와 session key를 이용하여 암호화한 Algorithm, 그리고 암호화된 session key로 이루어져있다.&lt;/li&gt;
&lt;li&gt;Message content를 암호화 한다.&amp;nbsp;&lt;/li&gt;
&lt;/ol&gt;
&lt;div data-ke-type=&quot;moreLess&quot; data-text-more=&quot;더보기&quot; data-text-less=&quot;닫기&quot;&gt;&lt;a class=&quot;btn-toggle-moreless&quot;&gt;...더보기&lt;/a&gt;
&lt;div class=&quot;moreless-content&quot;&gt;
&lt;p&gt;pseudo random에 대해 정확한 정의를 알아봤다. pseudo는 '의사'라고 해석하며 뜻은 가짜이다. 즉 pseudo random은 의사 랜덤이라고 하는데 random에 왜 pseudo를 붙이는지 궁금했는데, 네이버 지식 백과에서 다음과 같은 글을 찾을 수 있었다. 왠지 구글에서 찾은게 아니면 죄책감이 들긴 하지만, 아래에 설명에서는 내가 궁금한 부분을 잘 설명한 것 같아 가져왔다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&quot;&lt;/b&gt;처음에&amp;nbsp;주어지는&amp;nbsp;초깃값을&amp;nbsp;이용하여&amp;nbsp;이미&amp;nbsp;결정되어&amp;nbsp;있는&amp;nbsp;메커니즘(의사&amp;nbsp;난수&amp;nbsp;생성기)에&amp;nbsp;의해&amp;nbsp;생성되는&amp;nbsp;수.&amp;nbsp;난수는&amp;nbsp;생성&amp;nbsp;방법이&amp;nbsp;결정되어&amp;nbsp;있지&amp;nbsp;않으며,&amp;nbsp;다음에&amp;nbsp;생성될&amp;nbsp;값을&amp;nbsp;전혀&amp;nbsp;예측할&amp;nbsp;수&amp;nbsp;없으나&amp;nbsp;의사&amp;nbsp;난수&amp;nbsp;생성기에&amp;nbsp;의해&amp;nbsp;생성되는&amp;nbsp;수는&lt;b&gt;&amp;nbsp;초깃값을&amp;nbsp;알면&amp;nbsp;계산될&amp;nbsp;수도&amp;nbsp;있으므로&amp;nbsp;진짜&amp;nbsp;난수와&amp;nbsp;구별하여&amp;nbsp;의사&amp;nbsp;난수라&amp;nbsp;부른다&lt;/b&gt;.&quot;&lt;br /&gt;[네이버&amp;nbsp;지식백과]&amp;nbsp;의사&amp;nbsp;난수&amp;nbsp;[pseudo&amp;nbsp;random&amp;nbsp;number,&amp;nbsp;擬似亂數]&amp;nbsp;(IT용어사전,&amp;nbsp;한국정보통신기술협회)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/lRUVR/btqt7S60jp3/dkpeMtK8UoV2bmTy8blIqk/img.png' data-lightbox='lightbox' data-alt='RecipientInfo 예제'&gt;&lt;img src='https://k.kakaocdn.net/dn/lRUVR/btqt7S60jp3/dkpeMtK8UoV2bmTy8blIqk/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FlRUVR%2Fbtqt7S60jp3%2FdkpeMtK8UoV2bmTy8blIqk%2Fimg.png' &gt;&lt;/span&gt;&lt;figcaption&gt;RecipientInfo 예제&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;RecipientInfo를 처리하는 방법은 다음과 같은 순서로 이뤄 진다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;Base64 decoding&lt;/li&gt;
&lt;li&gt;Recipient의 Private-key로 session key를 decrypt&lt;/li&gt;
&lt;li&gt;(2)에서 복원한 session key로 message content decrypt&lt;/li&gt;
&lt;/ol&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#SignedData&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;SignedData는 다음과 같은 순서로 준비된다.&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;Message Digest Algorithm을 선택한다(SHA-1과 &amp;nbsp;MD5가 있다)&lt;/li&gt;
&lt;li&gt;서명할 내용을 위에서 선택한 Algorithm을 이용해 Message Digest를 계산한다.&lt;/li&gt;
&lt;li&gt;(2)에서 생성한 Message Digest를 Sender의 Private-key로 암호화 한다.&lt;/li&gt;
&lt;li&gt;SignerInfo block을 생성하며, SignerInfo는 Signer의 public-key certificate, message diget algorithm에 대한 identifier, message digest를 암호화 할때 사용한 algorithm(암호화한 algorithm), 암호화한 message digest 값으로 구성 되어있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위에서 언급한 것 처럼 SignedData는 Message Digest algorithm identifier와 signed message, 그리고 SignerInfo로 구성되어 있다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/uOO1F/btqt3IxziuD/69G0RNxqClqvG0w27vrdl1/img.png' data-lightbox='lightbox' data-alt='SignedData 예제&amp;amp;nbsp;'&gt;&lt;img src='https://k.kakaocdn.net/dn/uOO1F/btqt3IxziuD/69G0RNxqClqvG0w27vrdl1/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FuOO1F%2Fbtqt3IxziuD%2F69G0RNxqClqvG0w27vrdl1%2Fimg.png' &gt;&lt;/span&gt;&lt;figcaption&gt;SignedData 예제&amp;nbsp;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;위의 예제를 복원하려면 다음과 같은 절차를 거쳐야 한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;Base64 decnoding&lt;/li&gt;
&lt;li&gt;signer의 public-ket를 이용해 message digest를 복호화&lt;/li&gt;
&lt;li&gt;받은 메세지 내용 decrypt하고 이 내용을 &amp;nbsp;message digest한 후 받은 message digest와 비교&amp;nbsp;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#Clear Signing&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Clear Signing는 Message에 대한 암호를 적용하지 않아, 평문으로 전송된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;만약 Recipient가 MIME는 지원하는데 S/MIME를 지원하지 않는 경우 이 메세지를 읽을 수 있다(Signing에 대한 확인을 거치지 않고, 받아들이는듯 하다, Protocol간의 호환성을 위해 사용되는 듯!).&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;multipart/signed는 두가지 부분으로 나뉘는데 첫번째는 모든 MIME의 type이 올 수 있고, 두번째는 위에서 언급했던 signedData field가 오는데, 이때 signedData field에서 content field는 아무것도 들어가지 않는다(위에서 평문으로 전송하였기 때문)&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/rm1dy/btqt8JPmZtg/QKZgzpbxF5LIl4OvZZYj6K/img.png' data-lightbox='lightbox' data-alt='clear-signed 예제'&gt;&lt;img src='https://k.kakaocdn.net/dn/rm1dy/btqt8JPmZtg/QKZgzpbxF5LIl4OvZZYj6K/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Frm1dy%2Fbtqt8JPmZtg%2FQKZgzpbxF5LIl4OvZZYj6K%2Fimg.png' &gt;&lt;/span&gt;&lt;figcaption&gt;clear-signed 예제&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;위처럼 처음엔 평문의 메세지가 오게 되며 아래에는 그 메세지에 대한 digest의 내용이 암호화 되어 전송된다. micalg는 messaga digest를 만드는데 사용한 Algorithm을 명시하여 수신자 측에서 위의 평문 메세지와 아래 내용을 비교할 수 있도록 하였다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#Registration Request&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;application/pkcs10 S/MIME entity는 certification request를 전송하는데 사용된다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;certification request는 certification requestInfo 블록을포함하여, 여기에는 Public-key를 이용해 encrpytion을 한 Algorithm의 identifier(즉 public-key로 암호화 할때 쓴 알고리즘)와, Sender의 private-key로 서명한 &amp;nbsp;certificationReqeustInfo block의 서명이 들어가며 certificationRequestInfo에는 certificate subject의 이름과 user의 public-key를 bit-string형태로 표현한 내용이 들어간다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#Certificates-Only Message&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;registration request에 대한 응답으로 메세지에 certificate나 CRL(Certificate Revocation List)만 보낼 수 있으며, 이 메세지는 application/pkcs7-mime type/subtypsmime-type에 degenerate parameter로 보낼 수 있으며, signedData를 보낼때와 마찬가지로 보내면 되는데, signerInfo와 message content는 비워둔 상태로 보낸다.&lt;/p&gt;
&lt;div data-ke-type=&quot;moreLess&quot; data-text-more=&quot;더보기&quot; data-text-less=&quot;닫기&quot;&gt;&lt;a class=&quot;btn-toggle-moreless&quot;&gt;...더보기&lt;/a&gt;
&lt;div class=&quot;moreless-content&quot;&gt;
&lt;p&gt;CRL은 인증서 폐기에 대한 정보를 얻어오는 것으로, 유효성을 검사할 수 있고 인증서를 발급한 CA로 부터 정보를 얻어오는데, 주기적으로 업데이트 되어 즉시 확인되지 않을 수도 있다. 기본적으로는 인증서 만료에 대해 인증서에 있는 유효기간으로 확인이 가능하지만, 인증서의 유효기간이 유효하더라도 폐기될 수 있으므로 확인해야 한다. 발급한 CA에게 인증서에 적혀있는 URL을 검사하며, Serial number로 관리 하여 비교한다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#S/MIME Certificate Processing&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;S/MIME은 X.509의 ver.3을 public-key certificate로 이용하며, key-management scheme로는 X.509와 PGP의 web of trust를 사용한다. S/MIME manager 또는 유저는 각 client에 대한 신뢰할 수 있는 key list나 인증서 폐기 목록에 대한 것은 Local에서 관리해야 한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;div data-ke-type=&quot;moreLess&quot; data-text-more=&quot;더보기&quot; data-text-less=&quot;닫기&quot;&gt;&lt;a class=&quot;btn-toggle-moreless&quot;&gt;...더보기&lt;/a&gt;
&lt;div class=&quot;moreless-content&quot;&gt;
&lt;p&gt;X.509는 public-key와 identitiy ( hostname또는 organization, individual)을 포함하고있는 인증서이고, CA나, self-signing이 되어있다. 만약 인증서가 신뢰할수 있는 CA나 검증된 다른사람으로부터 서명된 경우, secure communicataion을 설정하거나. private-key로 서명된 document를 증명할 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Web of Trust는 PGP에서 사용하는 방식으로, 누군가가 공개키를 배포할때 MITM등의 방식으로 공개키를 다른 사용자의 것으로 바꿔치기 할 수 있는 상황을 배제할 수 없다. 이 경우 가장 안전한 방법은 직접 받는 방법인데, 직접 받을 바에야 대칭키를 이용하는게 간편하다. 이 경우 Web of Trust에서는 내가 신뢰하는 다른 사용자가 어떠한 공개키에 대해 신뢰할 수 있다고 sign한 경우 나도 그 공개키가 유효하다고 믿는 것을 말한다. 즉, 내가 믿는 사람이 맞다고하면 믿는거다! 그리고 signed된 수가 많을 수록 더욱더 신빙성이 증가 된다. 어떻게 보면 Block chain에서 비잔틴 문제를 해결한 Consensus와 비슷한 부분이 있는 것 같기도하고...&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;font-size: 1.12em;&quot;&gt;&lt;b&gt;User Agent Role&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;Key generation
&lt;ul style=&quot;list-style-type: disc;&quot;&gt;
&lt;li&gt;어떤 시스템에 대한 관리자들은 반드시 Diffie-Hellman과 DSS Key pair를 생성할 수 있어야 하고, RSA Key를 Generate 할 수 있어야 한다 각 key pair는 완벽한 random으로 인해 생성되어야 하고 기밀성이 유지되어야 한다. 반면 사용자는 768-1024bit의 RSA key를 generate할 수 있어야 하고, 512bit 이하의 key를 생성하면 안된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div data-ke-type=&quot;moreLess&quot; data-text-more=&quot;더보기&quot; data-text-less=&quot;닫기&quot;&gt;&lt;a class=&quot;btn-toggle-moreless&quot;&gt;...더보기&lt;/a&gt;
&lt;div class=&quot;moreless-content&quot;&gt;
&lt;p&gt;찾아보니 RSA 512bit는 1999년에 3년만에 6년만에 깨졌다고 한다. 그리고, 768bit 또한 3년만에 깨졌다고하니 최대한 긴 길이를 사용하자. 현재 &lt;a href=&quot;https://csrc.nist.gov/publications/drafts/800-57pt3_r1/sp800_57_pt3_r1_draft.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SP 800-57&lt;/a&gt;에서는 2048bit나 3072bit를 권장하고 있고, 현재 1024bit는 깨지지 않았지만, 권장되진 않는 듯 하다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;Registration
&lt;ul style=&quot;list-style-type: disc;&quot;&gt;
&lt;li&gt;User의 public-key는 X.509 public-key 인증서를 받기 위해 CA에 등록을 해야함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Certificate storage and retrieval
&lt;ul style=&quot;list-style-type: disc;&quot;&gt;
&lt;li&gt;사용자는 받은 메세지의 signature verify 및 송신시 encrypt를 위해 local에 있는 certificate 목록에 접근할 필요가 있다. 이 목록은 유저 개인이나 관리자가 대신 관리할 수 도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#Verisign Certificates&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;유명한 CA가 있지만 저자는 그중 Verisign에 대해 언급하고 있다. 가장 많이 쓴다고 한다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Versign은 Digital ID라는 X.509 certificate를 선보였는데, 그것에 대해 알아보자.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;소유자의 Public-key&lt;/li&gt;
&lt;li&gt;소유자의 이름이나 별칭&lt;/li&gt;
&lt;li&gt;Digital ID의 만료 기한&lt;/li&gt;
&lt;li&gt;Digital ID의 Serial number&lt;/li&gt;
&lt;li&gt;Digital ID를 발행한 CA의 이름&lt;/li&gt;
&lt;li&gt;Digital ID를 발행한 CA의 Digital signature&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;또한, optional하게 아래의 정보도 제공할 수 있다고 한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;주소&lt;/li&gt;
&lt;li&gt;이메일 주소&lt;/li&gt;
&lt;li&gt;기본 등록 정보 (나라, 우편번호, 나이 ,성별 등등)&lt;/li&gt;
&lt;/ul&gt;
&lt;div data-ke-type=&quot;moreLess&quot; data-text-more=&quot;더보기&quot; data-text-less=&quot;닫기&quot;&gt;&lt;a class=&quot;btn-toggle-moreless&quot;&gt;...더보기&lt;/a&gt;
&lt;div class=&quot;moreless-content&quot;&gt;
&lt;p&gt;아까부터 계속 CA 및 Digital signature에 대해 등장하고 있는데, 무엇인지 알아보자.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;CA가 등장하게 된 배경을 생각해보자. RSA의 등장으로 기존 암호화 방식인 대칭키 알고리즘에서 Key exchange의 문제가 사라졌다. 그러나 , 한가지 상황을 가정해 볼 수 있는데, 공개키를 배포할때 MITM으로 해커의 공개키를 주고 해커가 중간자 공격을 하면 어떻게 될까? 예상한 것 처럼 공개키 알고리즘의 보안과는 별개로 공격이 가능해진다. 그러면 이때 공개키에 대해 해커가 아닌 통신하고자 하는 상대방의 공개키라고 믿을 수 있을 만한 인증이 필요하다. 그 인증을 해주기 위해서는 스스로가 인증을 하거나, 신뢰할 수 있는 누군가로부터 그 공개키는 &quot;그 사람것이 맞다.&quot;라고 보증을 해 줘야한다. 그래서 &amp;nbsp;CA라고하는 인증 기관이 등장하게 되었다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;인증 받고자 하는 공개키(Certificate)를 해쉬를 한 후 CA에 주면, CA는 해당 공개키(Certificate)에 대해 자신의 Private-key로 암호화 하여, 인증서를 돌려준다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;그리고 처음 상황으로 돌아가서 A와 B가 암호화 통신을 하기 위해 공개키를 전달해야하는 상황에서 마찬가지로 악의의 사용자 C가 MITM을 시도 하려한다고 하자.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;B가 A와 통신을 하기 위해 그냥 Public-key를 주는 대신 위에서 Sign한 인증서를 주면, A는 인증서를 받고 그 인증서를 Sign한 CA의&amp;nbsp;&lt;/p&gt;
&lt;p&gt;공개키를 이용해 인증서를 복호화 한다. 정상적으로 복호화가 된다면 CA가 Sign한 것이라는게 인증되었다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;그리고 복호화한 인증서에는 공개키에 대한 Hash 값이 있는데 그 값과 인증서 들어있는 &lt;span style=&quot;color: #333333;&quot;&gt;(B가 자신의 것이라고 주장하는)&lt;/span&gt;공개키를 Hash하여 비교한다. 값이 일치한다면, CA가 공개키에 대해 보증을 하였기 때문에 신뢰할 수 있는 공개키라고 믿을 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;이때 신뢰할 수 있는 CA는 기존에 알고있어야 하며, 브라우저의 경우 Static하게 브라우저 내에 저장되어 있다(브라우저 마다 신뢰할 수있는 CA가 조금씩 상이하다).&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;해커가 공격을 시도한다고 가정을 해볼때, 자신의 공개키를 인증서에 넣고 그 값을 신뢰할 수 있는 CA의 Private-key로 암호화 해야 하는데(A는 CA의 Public-key로 복호화를 시도하기 때문) 해커가 CA의 Private-key로 암호화 할 수 없기 때문에 올바른 인증서를 만들지 못한다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;해커가 자신이 CA이 되어 Signed된 인증서를 발급할 수 는 있으나, 인증되었다고 해서 모두 받아들이는 것이 아니라, &quot;신뢰할 수 있는 CA&quot;가 서명한 인증서만이 사용하도록 하기 때문에 위에서 가정한 공격을 감행할 수 없다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;위의 과정에서 B의 공개키를 CA가 암호화한 값을 Digital signature라고 한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#Enhanced Security Services&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;Signed receipts
&lt;ul style=&quot;list-style-type: disc;&quot;&gt;
&lt;li&gt;SignedData form에 의해 요청할 수 있고, 메세지를 전달했다는 증거로사용할 수 있고, third part에게 recipeint가 메세지를 받았다는 것을 증명할 수 있다. .기본적으로 원본 메세지와 sender의 signatre에 자신의 서명을 추가해 새 S/MIME를 작성한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Security Labels
&lt;ul style=&quot;list-style-type: disc;&quot;&gt;
&lt;li&gt;Security label은 SignedData의 속성 중 하나로 S/MIME에 포함된 내용에 대한 민감도를 나타낸다. 이 label은 access control에 사용되거나 priorty , rolo based등 다양한 목적으로 사용된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Secure Maling lists
&lt;ul style=&quot;list-style-type: disc;&quot;&gt;
&lt;li&gt;동시에 같은 메일을 다른 사용자에게 보낼때, 각 수신자에 대한 정확한 처리가 필요하게 되며 이때 &amp;nbsp;각 수신자에 대한 public-key를 포함해야 한다. 이때 S/MIME MLA(Mail List Agent)을 이용해 안정성있게 이 처리를 할 수 있으며, MLA는 하나의 메세지를 받아 각 수신자가 복호활 수 있도록 암호화 해주고, 전송해준다. 따라서 Sender는 MLA의 Public-key를 이용하여 MLA에게 메세지를 보내기만 하면 MLA가 다~ 알아서해준다!&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;여기까지 작성하고 다음으론 S/MIME에 DKIM에 대해 알아보도록 하자!&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block; text-align:center;&quot;
     data-ad-layout=&quot;in-article&quot;
     data-ad-format=&quot;fluid&quot;
     data-ad-client=&quot;ca-pub-3588179945681108&quot;
     data-ad-slot=&quot;3731887415&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.dork94.com/182&amp;amp;layout=button_count&amp;amp;show_faces=true&amp;amp;width=106&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:106px; height:30px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Network</category>
<author>Dork94</author>
<guid>https://blog.dork94.com/182</guid>
<comments>https://blog.dork94.com/182#entry182comment</comments>
<pubDate>Thu, 04 Apr 2019 03:50:45 +0900</pubDate>
</item>
<item>
<title>S/MIME (Secure/Multipurpose Internet Mail Extension) - 1</title>
<link>https://blog.dork94.com/181</link>
<description>&lt;p&gt;S/MIME은 RSA Data Security의 기술을 이용해 &amp;nbsp;MIME의 Internet e-mail format stanard의 보안을 증가시키기 위해 고안되었다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;S/MIME은 RFCs 3370, 3850, 3851, 3852에 정의되어 있다. S/MINE을 이해하기 위해서는 MIME이라고 불리는 e-mail format에 대한 이해가 필요하다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;MIME을 이해하기 위해서는 아직도 종종 사용되는 RFC 822부터 살펴볼 필요가 있다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;RFC 5322는 가장 최신 버전의 Internet Message Format에 대해 설명하고 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;# RFC 5322&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;RFC 5322는 e-mail의 text message 에 대한 format을 정의하고 있다. 여기서 Message는 envelope와 contents로 나눠지고, envelope는 mail이 전송될 정보를 담고 있으며, &amp;nbsp;contents는 recipient에게 전달 될 내용으로 구성되어있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;RFC 5322에서는 Contents만 다루고 있으나, 이 표준에는 envelope를 만드는데 필요한 header field set을 포함하고 있으며, &amp;nbsp;이 문서에서는 Message를 Header와 body부분으로 나누며, 둘의 구분은 blank line(빈줄)으로 한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Contents는 ASCII Text이고, 첫번째 blank line이 등장할때 까지의 모든 line은 Header로 간주한다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Header는 keyword와, &amp;nbsp;keyword에 대한 arguments로 이루어져 있으며 ':' 으로 구분된다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;가장 자주 사용되는 키워드는 From, To, Subject와 Date이며, 아래에 Header의 예시가 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;pre id=&quot;code_1554145443905&quot; class=&quot;html xml&quot; style=&quot;display: block; overflow: auto; padding: 15px; color: #383a42; background-color: #f6f7f8; font-size: 14px; border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; font-family: Menlo, Consolas, Monaco, monospace; border: 1px solid #dddddd; margin: 20px auto 0px; cursor: default; z-index: 1; font-style: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; text-decoration: none; background-position: initial initial; background-repeat: initial initial;&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt; 	 Date: October 8, 2009 2:15:49 PM EDT
         From: &amp;ldquo;William Stallings&amp;rdquo; &amp;lt;ws@shore.net&amp;gt;
         Subject: The Syntax in RFC 5322
         To: Smith@Other-host.com
         Cc: Jones@Yet-Another-Host.com
         
         Hello. This section begins the actual
         message body, which is delimited from the
         message heading by a blank line.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;또한, Message-ID에 대한 field도 header에서 자주 볼 수 있는데, 이것은 message에 대한 unique identifier라고 한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;MIME은 RFC 821에 정의된 SMTP(Simple Mail Transfer Protocol) 또는 다른 mail transfer protocol과 RFC 5322 e-mail 대한 문제를 해결하기 위한 것이다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;[PARZ06]에는 SMTP/5322 에 관한 제한 사항이 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;1. SMTP는 실행가능한 파일(exe)이나 binary object를 보낼 수 없다. &amp;nbsp;따라서, Binary file을 text형태로 바꾸기 위해 여러가지 schemes(UNIX UUencode / UUdecode 등)를 사용하고 있으나, 이러한 Schemes은 표준이 아니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;2. &amp;nbsp;SMTP는 다른 국가의 언어를 보낼 수 없다. 왜냐하면, SMTP는 7-bit의 ASCII로 표현을 하기 때문&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;3. SMTP의 server는 size를 넘는 경우 메일을 reject 한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;4. ASCII와 EBCDIC을 변환하는 SMTP의 gateway가 일괄된 mapping set을 사용하지 않아 변환문제가 발생한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;5. SMTP X.400 gateways는 nontextual data를 처리할 수 없다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;6. SMTP의 RFC 821에 정의되어있는 standard를 정확히 구현하지 않아 생기는 문제가 있다:&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;carriage return 및 line feed의 삭제, 추가, 재정렬에 대한 문제&lt;/li&gt;
&lt;li&gt;76자 이상에 대한 잘림 문제&lt;/li&gt;
&lt;li&gt;tab과 space에 대한 white space 제거 문제&lt;/li&gt;
&lt;li&gt;같은 메세지 길이에 대한 line padding 문제&lt;/li&gt;
&lt;li&gt;tab과 여러개의 space에 대한 변환 문제&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MIME의 spec&lt;/p&gt;
&lt;p&gt;1. RFC 5322 header를 포함해서&lt;span style=&quot;color: #333333;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;body에 대한 정보를 제공하는&amp;nbsp;&lt;/span&gt;5개의 새로운 header field가 추가 되었으며, MIME-Version, Content-Type, Content-Transfer-Encoding field는 무조건 포함해야 하며 Content-ID와 Content-Description field는 선택적으로 추가할 수 있다(필수적이지 않다).&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;MIME-Version : 값으로는 1.0을 가져야 하며, RFC 2045 2046를 따르는 것을 나타낸다.&lt;/li&gt;
&lt;li&gt;Content-Type : body가 포함하는 data에 대해 수신시에 데이터를 표현하거나 적절한 방식으로 처리할 수 있는 세부 정보를 포함하는field, 이며 boundary도 여기에 포함&lt;/li&gt;
&lt;li&gt;Content-Transfer-Encoding : body에서 사용하는 encoding이나 charset을 표시함&lt;/li&gt;
&lt;li&gt;Content-ID: MIME의 entity를 식별하는데 사용되는 고유 id&lt;/li&gt;
&lt;li&gt;Content-Description: audio data와 같은 body에 대한 object 설명으로 object가 읽을 수 없을 때 유용&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2. multimedia 표현을 표준화 하는 몇가지 content format이 정의 되었다.&lt;/p&gt;
&lt;p&gt;3. 어떤 content format과도 변환할 수 있도록 전송 인코딩이 정의 되었다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;# MIME Content Type&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;MIME의 specificationd은 대부분 다양한 형태의 content type의 정의와 관련있는데, 이는 multi-media 환경에서 다양한 정보 표현의 처리를 할 수 있는 표준화된 방법을 제공해야할 필요성을 반영한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/k9lfN/btqt1YlT2Jx/RuyuKpxNG1dQANfM2Vpenk/img.png' data-lightbox='lightbox' data-alt='RFC 2046에 정의된 Content Type. 7개의 type과 15개의 subtype으로 나눠져 있다.'&gt;&lt;img src='https://k.kakaocdn.net/dn/k9lfN/btqt1YlT2Jx/RuyuKpxNG1dQANfM2Vpenk/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fk9lfN%2Fbtqt1YlT2Jx%2FRuyuKpxNG1dQANfM2Vpenk%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-02 at 6.26.07 AM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;RFC 2046에 정의된 Content Type. 7개의 type과 15개의 subtype으로 나눠져 있다.&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot; data-ke-list-type=&quot;square&quot;&gt;
&lt;li&gt;Text type : 정보를 얻는데 특별한 소프트웨어가 필요하지 않은 형식. subtype으로는 plain과 enriched가 있으며, ASCII 또는 ISO 8859 charset이며, Enriched을 이용해 format의 유연성을 향상 시킬 수 있다.&lt;/li&gt;
&lt;li&gt;
&lt;div data-ke-type=&quot;moreLess&quot; data-text-more=&quot;더보기&quot; data-text-less=&quot;닫기&quot;&gt;&lt;a class=&quot;btn-toggle-moreless&quot;&gt;...더보기&lt;/a&gt;
&lt;div class=&quot;moreless-content&quot;&gt;enriched를 사용하면, rich text format을 사용할 수 있으며, 아래에 예제가 있다.&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;multipart type : &amp;nbsp;body에 대해 여러가지 정보가 담겨 있을 경우 사용되며 body는 Content-Type에 명시된 boundary 문자열에 의해 구분됨. &lt;br /&gt;&amp;nbsp;따라서, boundary는 message의 어디에도 들어가면 안되며 각 새로운 boundary는 newline과 함께 --[boundary value]와 같은 형태로 이루어 져있으며, 마지막 boundary는 --[boundary value]--와 같은 형식으로 이루어져있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre id=&quot;code_1554154806007&quot; class=&quot;html xml&quot; style=&quot;display: block; overflow: auto; padding: 15px; color: #383a42; background-color: #f6f7f8; font-size: 14px; border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; font-family: Menlo, Consolas, Monaco, monospace; border: 1px solid #dddddd; margin: 20px auto 0px; cursor: default; z-index: 1; font-style: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; text-decoration: none; background-position: initial initial; background-repeat: initial initial;&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;    From: Nathaniel Borenstein &amp;lt;nsb@bellcore.com&amp;gt;
    To: Ned Freed &amp;lt;ned@innosoft.com&amp;gt;
    Subject: Sample message
    MIME-Version: 1.0
    Content-type: multipart/mixed; boundary=&quot;simple boundary&quot;
    This is the preamble. It is to be ignored, though it is a handy place for mail composers to include an explanatory note to non-MIME conformant readers.
    &amp;mdash;simple boundary
    This is implicitly typed plain ASCII text. It does NOT end with a linebreak.
    &amp;mdash;simple boundary
    Content-type: text/plain; charset=us-ascii
    This is explicitly typed plain ASCII text. It DOES end with a linebreak.
    &amp;mdash;simple boundary&amp;mdash;
    This is the epilogue. It is also to be ignored.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;multipart subtype
&lt;ul&gt;
&lt;li&gt;mixed &amp;nbsp;: 서로 다른 독립된 부분을 한번의 전송으로 처리하며, 수신자는 순서에 따라 처리해야함(순서가 있음)&lt;/li&gt;
&lt;li&gt;parallel : mixed와 동일하나 특별한 순서가 필요치 않을때, 상황에 따라 병렬로 처리할 수 있음(e,g. 사진 또는 text가 음성 설명과 함께 제공되는 경우)&lt;/li&gt;
&lt;li&gt;digest : RFC 5322 message header를 포함하는 경우, 이 subtype을 이용해 개인 메시지를 작성할 수 있음&lt;/li&gt;
&lt;li&gt;alternative : 둘중에 하나만 선택되며 아래의 상황에서는 enriched가 우선적으로 선택되며 그렇지 않은 경우 plain이 선택 됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre id=&quot;code_1554155819596&quot; class=&quot;html xml&quot; data-ke-type=&quot;codeblock&quot;&gt;&lt;code&gt;    From: Nathaniel Borenstein &amp;lt;nsb@bellcore.com&amp;gt;
    To: Ned Freed &amp;lt;ned@innosoft.com&amp;gt;
    Subject: Formatted text mail
    MIME-Version: 1.0
    Content-Type: multipart/alternative; boundary = boundary42
    &amp;mdash;boundary42
    Content-Type: text/plain; charset = us-ascii ...plain text version of message goes here...
    &amp;mdash;boundary42
    Content-Type: text/enriched
    . . . RFC 1896 text/enriched version of same message goes here...
    &amp;mdash;boundary42&amp;mdash;&lt;/code&gt;&lt;/pre&gt;
&lt;ul style=&quot;list-style-type: square;&quot; data-ke-list-type=&quot;square&quot;&gt;
&lt;li style=&quot;list-style-type: none;&quot;&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
&lt;li&gt;rfc822 subtype: body가 header와 body를 포함한 전체 메세지를 나타냄. subrtype임에도 불구하고 &amp;nbsp;그냥 메시지일 수도 MIME 메세지일 수도 있음.&lt;/li&gt;
&lt;li&gt;partial subtype: 큰 메세지를 여러 부분으로 분할할 수 있으며, 수신지에서 재조립해야한다. 이 경우 세가지 parameter가 Content-Type에 지정되며 조각난 메세지에 대해 같은 id, 각 seqeunce number 및 전체 조각 메세지의 number가 있다.&lt;/li&gt;
&lt;li&gt;external-body: 실제 data가 body에 없는 subtype을 의미하며 대신, body에는 data에 access하는 데 필요한 정보가 있다. outer header와 encapsulated된 own header가 있고, outer field는 message형식이 message/external-body형식이라는 것을 Content-Type에 표시하기 위해만 사용된다.&lt;br /&gt;이때 access-type parameter(FTP와 같은 acesss 방식)이 명시되어 있어야 한다. own header에서는 ecapsulated message에 대한 header의 정보가 있다.&lt;/li&gt;
&lt;li&gt;application-type: 해석되지 않은 binary data 또는 mail-based application에서 처리 될 다른 종류의 데이터를 나타낸다.&amp;nbsp;message type: MIME에서 여러가지 중요한 기능을 제공함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; border=&quot;1&quot; width=&quot;600&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#Examples&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/brrBZd/btqt3i5zY7Q/49O1oQ1fXiny6BZG6kKPY0/img.png' data-lightbox='lightbox' data-alt='Example of multipart'&gt;&lt;img src='https://k.kakaocdn.net/dn/brrBZd/btqt3i5zY7Q/49O1oQ1fXiny6BZG6kKPY0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbrrBZd%2Fbtqt3i5zY7Q%2F49O1oQ1fXiny6BZG6kKPY0%2Fimg.png' &gt;&lt;/span&gt;&lt;figcaption&gt;Example of multipart&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: right;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;위의 그림에서 하나씩 볼 수 있도록 하자.&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/yWpMz/btqt26j1nR3/rtvLlrTvkWEaF7ysfkPBe0/img.png' data-lightbox='lightbox' data-alt='MIME 1'&gt;&lt;img src='https://k.kakaocdn.net/dn/yWpMz/btqt26j1nR3/rtvLlrTvkWEaF7ysfkPBe0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FyWpMz%2Fbtqt26j1nR3%2FrtvLlrTvkWEaF7ysfkPBe0%2Fimg.png' &gt;&lt;/span&gt;&lt;figcaption&gt;MIME 1&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;MIME1 에서는&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;color: #333333;&quot;&gt;처음등장하는&lt;/span&gt;&amp;nbsp;Content-Type으로는 &amp;nbsp;multipart/mixed가 등장하며 boundary로는 'unique-boundary-1'을 사용한다고 명시되어 있다.&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;그 후 This ...~ 으로 시작하는데 이때 boundary가 시작되지 않은 영역이므로, 정상적으로 multipart를 지원하는 경우에선 This ...~ 와 같은 text는 읽지 못할 것이다. 다만,&amp;nbsp;&lt;span style=&quot;color: #333333;&quot;&gt;MIME(&lt;/span&gt;multipart)를 지원하지 않는 경우 &amp;nbsp;This ...~를 읽게 되어 출력해준다.&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;그 후 newline과 --[boundary value]로 part를 시작하게 되며, MIME 1에서는 첫줄을 공백으로 시작한다. 이 말은 header field가 없다는 것을 의미하며, 기본적으로 text에 charset으로는 US ASCII를 사용한다.&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/rtAes/btqt2beTr4X/QxxLjf0ruHwCrO1Dg2P9wk/img.png' data-lightbox='lightbox' data-alt='MIME 2'&gt;&lt;img src='https://k.kakaocdn.net/dn/rtAes/btqt2beTr4X/QxxLjf0ruHwCrO1Dg2P9wk/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FrtAes%2Fbtqt2beTr4X%2FQxxLjf0ruHwCrO1Dg2P9wk%2Fimg.png' &gt;&lt;/span&gt;&lt;figcaption&gt;MIME 2&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;MIME 2에서는 MIME 1 마지막에서 봤던 part를 명시적으로 적어놓은 부분이다. 그리고 multipart/parallel로 명시된 부분이 나오는데, &amp;nbsp;parallel은 위에 설명한 것 처럼 mixed와 달리 순서가 상관이 없고 동시에 실행가능하다. 위의 경우에선 audiodㅘ image가 상황에 따라 동시에 실행 될 수 도 있을 것 이다.&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/cuur7e/btqt1GtfP8K/k3yHceI8ukG3lJDskOvYmK/img.png' data-lightbox='lightbox' data-alt='MIME 3'&gt;&lt;img src='https://k.kakaocdn.net/dn/cuur7e/btqt1GtfP8K/k3yHceI8ukG3lJDskOvYmK/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fcuur7e%2Fbtqt1GtfP8K%2Fk3yHceI8ukG3lJDskOvYmK%2Fimg.png' &gt;&lt;/span&gt;&lt;figcaption&gt;MIME 3&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;예제의 마지막 부분인 MIME 3를 보자. text/enriched를 사용하며, Richtext format을 사용하였다. Richtext의 사용은 조금더 다양하고 보기 좋은 글을 만들 수 있다.&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/UvINa/btqt1E3k1zk/IXUTj2xCNlVklEQq6Yg2E0/img.png' data-lightbox='lightbox' data-alt='Richtext'&gt;&lt;img src='https://k.kakaocdn.net/dn/UvINa/btqt1E3k1zk/IXUTj2xCNlVklEQq6Yg2E0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FUvINa%2Fbtqt1E3k1zk%2FIXUTj2xCNlVklEQq6Yg2E0%2Fimg.png' width=&quot;420&quot; height=&quot;316&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;Richtext&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;그리고, 마지막 part에선 type을 message/rfc822로 정의하고 있다. 위에 언급한 것 처럼 일반 텍스트가 올수도 있고 MIME형식의 텍스트가 올 수 있는데 아래에는 MIME 형식의 메세지가 있어, 또다른 메세지를 보낼 수 있다. 아래 형식에서는 아래에서 설명할 quoted-printable 인코딩을 사용한 Text/plain type의 메세지이다.&lt;/p&gt;
&lt;p style=&quot;text-align: right;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;# MIME Transfer Encoding&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;span style=&quot;color: #333333;&quot;&gt;Cont&lt;/span&gt;ent-Transfer-Encoding field에는 아래와 같은 6개의 값이 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/cakr3A/btqt25ydU7t/abH9noCJZzGM1OfFoVIJq1/img.png' data-lightbox='lightbox' data-alt='MIME Content-Transfer-Encoding Field'&gt;&lt;img src='https://k.kakaocdn.net/dn/cakr3A/btqt25ydU7t/abH9noCJZzGM1OfFoVIJq1/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fcakr3A%2Fbtqt25ydU7t%2FabH9noCJZzGM1OfFoVIJq1%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-02 at 1.02.00 PM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;MIME Content-Transfer-Encoding Field&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;7bit, 8bit, binary는 encoding이 되지 않았음을 나타 내며, 원래의 정보를 나타낸다. SMTP 통신에서는 7bit encoding을 사용하는게 안전하며(호환성) 8bit와 binary encoding도 다른 mail transport contexts에서 사용하다.&amp;nbsp;&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&amp;nbsp;x-token
&lt;ul style=&quot;list-style-type: disc;&quot;&gt;
&lt;li&gt;nonstandard encoding을 뜻하며, vendor-specifc하거나, application-specific한 scheme를 말한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Base64
&lt;ul style=&quot;list-style-type: disc;&quot;&gt;
&lt;li&gt;Binary등의 출력 불가능한 데이터를 영어 대 소문자 + 숫자 + '+, /, = '를 포함한 64개의 ASCII로 바꿔주는 encoding으로 PGP에서 다뤘던 Radix-64와 비슷하다(Radix-64의 경우 '=' 뒤에 에러를 체크할 수 있는 CRC 값이 있다). 마찬가지로 데이터양이 33% 증가한다(3바이트를 4바이트로 치환함).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;quoted-printable
&lt;ul style=&quot;list-style-type: disc;&quot;&gt;
&lt;li&gt;ASCII의 범위에서 표현하지 못하는 값들을 HEX값과 =기호를 이용해서 전달할 수 있도록 하는 인코딩 방식이며 '='을 표현할 경우 '=3D'로 표현함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/by14nl/btqt0aBwTVF/gQKzSAtSmE6J2rPP7rHNIk/img.png' data-lightbox='lightbox' data-alt='원본 문자열'&gt;&lt;img src='https://k.kakaocdn.net/dn/by14nl/btqt0aBwTVF/gQKzSAtSmE6J2rPP7rHNIk/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fby14nl%2Fbtqt0aBwTVF%2FgQKzSAtSmE6J2rPP7rHNIk%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-02 at 4.15.11 PM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;원본 문자열&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;위문자열을 quoted-printable을 적용할 경우 아래와 같다 (출처: Wikipedia)&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/29HA9/btqt1jqX4xp/ajR5qHN54LqBI78drWkkxK/img.png' data-lightbox='lightbox' data-alt='quoted-printable encoded strings'&gt;&lt;img src='https://k.kakaocdn.net/dn/29HA9/btqt1jqX4xp/ajR5qHN54LqBI78drWkkxK/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2F29HA9%2Fbtqt1jqX4xp%2FajR5qHN54LqBI78drWkkxK%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-02 at 4.15.06 PM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;quoted-printable encoded strings&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;위에서 처음 등장하는 =C3=A9에 대한 문자열 대해 찾아보자. 위의 문자열은 UTF-8형식으로 인코딩되어 있다.&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;아래는 UTF-8 코드표를 찾아본 결과 이다.&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/CV1uF/btqt3i5wX3v/cVRaN5Y73PayQqbQkdGxgK/img.png' data-lightbox='lightbox' data-alt='C3A9에 해당하는 문자는 &amp;amp;eacute;임을 알수있고 원본 문자열과 비교해보면 해당 위치에 &amp;amp;eacute;가 들어가야함을 알 수 있다.&amp;amp;nbsp;'&gt;&lt;img src='https://k.kakaocdn.net/dn/CV1uF/btqt3i5wX3v/cVRaN5Y73PayQqbQkdGxgK/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FCV1uF%2Fbtqt3i5wX3v%2FcVRaN5Y73PayQqbQkdGxgK%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-02 at 4.22.04 PM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;C3A9에 해당하는 문자는 &amp;eacute;임을 알수있고 원본 문자열과 비교해보면 해당 위치에 &amp;eacute;가 들어가야함을 알 수 있다.&amp;nbsp;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;이와 같이, 기존의 ASCII를 이용해 HEX value를 표시하는 방법으로 ASCII 범위로 표현하지 못하는 문자를 인코딩으로 표현할 수 있도록 하는 것이 quoted-printable encoding 방식이다.&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#S/MIME&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;S/MIME는 3가지 public-key algorithm을 이용한다.&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li style=&quot;text-align: left;&quot;&gt;DSS(Deigital Signature Standard)&lt;/li&gt;
&lt;li style=&quot;text-align: left;&quot;&gt;Diffie-Hellman (ElGamal 등)&lt;/li&gt;
&lt;li style=&quot;text-align: left;&quot;&gt;RSA&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse; width: 0%; height: 681px;&quot; border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 50%; text-align: center; height: 19px;&quot;&gt;&lt;b&gt;Function&lt;/b&gt;&lt;/td&gt;
&lt;td style=&quot;width: 50%; text-align: center; height: 19px;&quot;&gt;&lt;b&gt;Requirement&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 153px;&quot;&gt;
&lt;td style=&quot;width: 50%; text-align: center; height: 153px;&quot;&gt;Digital signature 생성을 위한 Message Digest&lt;/td&gt;
&lt;td style=&quot;width: 50%; text-align: center; height: 153px;&quot;&gt;
&lt;p&gt;&lt;b&gt;필수&lt;/b&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Sender -&amp;gt;SHA-1&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;권장&lt;/b&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Receiver - &amp;gt; Agent에서의 MD5(호환성)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 203px;&quot;&gt;
&lt;td style=&quot;width: 50%; text-align: center; height: 203px;&quot;&gt;Digital signature 암호화&lt;/td&gt;
&lt;td style=&quot;width: 50%; height: 203px;&quot;&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;b&gt;필수 &lt;/b&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;Sender, Receiver -&amp;gt;DSS&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;b&gt;권장&lt;/b&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;Sender -&amp;gt; RSA&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Receiver -&amp;gt; RSA verification ( key size : 512~1024 bits)&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 153px;&quot;&gt;
&lt;td style=&quot;width: 50%; text-align: center; height: 153px;&quot;&gt;Session key 암호화&lt;/td&gt;
&lt;td style=&quot;width: 50%; height: 153px;&quot;&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;b&gt;필수&lt;/b&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;Sender, Receiver -&amp;gt; RSA Encryption ( key size : 512~1024 bits)&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;b&gt;권장&lt;/b&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;Sender, Receiver -&amp;gt; Diffie-Hellman&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 153px;&quot;&gt;
&lt;td style=&quot;width: 50%; text-align: center; height: 153px;&quot;&gt;one-time session key로 메세지 암호화&lt;/td&gt;
&lt;td style=&quot;width: 50%; text-align: center; height: 153px;&quot;&gt;
&lt;p&gt;&lt;b&gt;필수&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;Sender, Receiver -&amp;gt; 3DES encryption&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;권장&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;Sender -&amp;gt; AES encryption, RC2/40 encryption&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;width: 50%; text-align: center;&quot;&gt;
&lt;p&gt;MAC(Message Authentication Code) 생성&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&quot;width: 50%; text-align: center;&quot;&gt;
&lt;p&gt;&lt;b&gt;필수&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;Receiver -&amp;gt; HMAC, SHA-1&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;권장&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;Sender -&amp;gt; HMAC, SHA-1&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;S/MIME에서 Sender는 message를 보내기 위해 2가지를 결정해야하는데, 처음으로는 Reciver가 Sender가 사용하는 Encryption Algorithm에 대해 decrypt를 할수있는지를 알아야하고, 만약 Recevier가 취약한 Encrypt Algorithm만 사용할 수 있는 경우, Sender는 그 Algorithm을 사용하여 보낼지 결정해야 한다.&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;Sender&lt;span style=&quot;color: #333333;&quot;&gt;(Sender의 Agent)&lt;/span&gt;는 아래의 순서를 따라야한다.&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li style=&quot;text-align: left;&quot;&gt;Receiver가 Decrypt 할 수 있는 Algorithm에 대한 목록을 이미 Sender가 보유하고 있다면, 목록에 있는 Algorithm을 첫번째로 사용하도록 설정해야 한다.&lt;/li&gt;
&lt;li style=&quot;text-align: left;&quot;&gt;위와 같은 목록이 존재하지는 않으나, 하나 이상의 메세지를 Recipient로 부터 받은 경우, Sender는 메세지를 보낼때 마지막으로 Signed되고 Encryption한 것 과 같은 Ecrpytion algorithm을 사용해야 한다(간단히 말해, 정보가 없으므로 받은 메세지로 부터 정보를 획득해 사용한다).&amp;nbsp;&lt;/li&gt;
&lt;li style=&quot;text-align: left;&quot;&gt;Sender가 Receiver가 사용하는 Decrpyt 가능한 Algorithm에 대한 정보가 없는 경우, 그리고 Receiver가 message를 decrypt 할 수 없는 위험을 감수할 수 있는 경우에, &amp;nbsp;3DES를 사용한다(사용할 수 있다).&lt;/li&gt;
&lt;li style=&quot;text-align: left;&quot;&gt;위의 상황에서 decrypt할 수 없는 위험을 감수할 수 없는 경우, 즉 decrypt 가 꼭 진행되어야 하는 경우 RC2/40을 사용 한다(사용해야한다).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;여러명의 사용자에게 Message를 보내야 할때, 모두가 함께 사용하는 Algorithm을 사용할 수 없는 경우(각자 지원하는 Algorithm이 다른데, 공통된 게 없는 경우) 2개로 나누어 보내야 하는데, 이때 상대적으로 보안이 낮은 Algorithm에 의해 보안에 취약해지는것에 주의해야 한다.&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/bPG3q8/btqt7RtsY4A/mkcLstqLHt5oHxHfaXNDk0/img.jpg' data-lightbox='lightbox' data-alt='보안에서 자주 등장하는 weakest link chain, 정확한 이론의 이름은 기억이 안나지만, 보안에 있어 보안 수준은 가장 약한 부분이 전체 서비스의 보안 수준이라는 의미'&gt;&lt;img src='https://k.kakaocdn.net/dn/bPG3q8/btqt7RtsY4A/mkcLstqLHt5oHxHfaXNDk0/img.jpg' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbPG3q8%2Fbtqt7RtsY4A%2FmkcLstqLHt5oHxHfaXNDk0%2Fimg.jpg' width=&quot;744&quot; height=&quot;558&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;보안에서 자주 등장하는 weakest link chain, 정확한 이론의 이름은 기억이 안나지만, 보안에 있어 보안 수준은 가장 약한 부분이 전체 서비스의 보안 수준이라는 의미&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: right;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: right;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: right;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: right;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;내용이 너무 길어지므로 다음 글에서 S/MIME에서 실제로 어떻게 사용되는지 알아 보도록 하자!&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: right;&quot;&gt;Reference : Cryptographpy and Network Security, Sixth Ed&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block; text-align:center;&quot;
     data-ad-layout=&quot;in-article&quot;
     data-ad-format=&quot;fluid&quot;
     data-ad-client=&quot;ca-pub-3588179945681108&quot;
     data-ad-slot=&quot;3731887415&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.dork94.com/181&amp;amp;layout=button_count&amp;amp;show_faces=true&amp;amp;width=106&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:106px; height:30px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Network</category>
<author>Dork94</author>
<guid>https://blog.dork94.com/181</guid>
<comments>https://blog.dork94.com/181#entry181comment</comments>
<pubDate>Tue, 02 Apr 2019 04:05:05 +0900</pubDate>
</item>
<item>
<title>PGP (Pretty Good Privacy)</title>
<link>https://blog.dork94.com/180</link>
<description>&lt;p&gt;Phill Zimmermann에 의해 만들어진 서비스&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;공개키로는 RSA, DSS, Diffie-Hellman이 사용되며, 대칭키로는 CAST-128, IDEA, 3DES가 사용됨.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;해쉬로는 SHA-1이 사용된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Windows, UNIX, Macintosh 및 많은 운영체제에서 사용 가능하다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;PGP는 4개의 서비스(Authentication, Confidentially, Compression, e-mail compatibility)를 제공한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;위의 4개의 서비스를 간단하게 다음과 같이 요약할 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse; width: 100%; height: 95px;&quot; border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 33.333333333333336%; height: 19px; text-align: center;&quot;&gt;&lt;b&gt;Function&lt;/b&gt;&lt;/td&gt;
&lt;td style=&quot;width: 33.333333333333336%; height: 19px; text-align: center;&quot;&gt;&lt;b&gt;Algorithms Used&lt;/b&gt;&lt;/td&gt;
&lt;td style=&quot;width: 33.333333333333336%; height: 19px; text-align: center;&quot;&gt;&lt;b&gt;Descrption&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 33.333333333333336%; height: 19px;&quot;&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;Digital signature&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&quot;width: 33.333333333333336%; height: 19px; text-align: center;&quot;&gt;DSS/SHA or RSA/SHA&lt;/td&gt;
&lt;td style=&quot;width: 33.333333333333336%; height: 19px; text-align: center;&quot;&gt;SHA-1을 이용해 해쉬코드가 만들어지며, 이 해쉬는 Sender의 Private key를 이용해 DSS나 RSA를 이용해 암호화 됨.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 33.333333333333336%; height: 19px; text-align: center;&quot;&gt;Message encryption&lt;/td&gt;
&lt;td style=&quot;width: 33.333333333333336%; height: 19px; text-align: center;&quot;&gt;CAST or IDEA or Three-key Triple DES with Diffie-Hellman or RSA&lt;/td&gt;
&lt;td style=&quot;width: 33.333333333333336%; height: 19px; text-align: center;&quot;&gt;Sender에 의해 생성된 one-time session key로 CAST-128, IDEA, 또는 3DES로 암호화 된다. 이 session key는 Diffe-Hellman이나 수신자의 RSA public key암호화 된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 33.333333333333336%; height: 19px; text-align: center;&quot;&gt;Compression&lt;/td&gt;
&lt;td style=&quot;width: 33.333333333333336%; height: 19px; text-align: center;&quot;&gt;ZIP&lt;/td&gt;
&lt;td style=&quot;width: 33.333333333333336%; height: 19px; text-align: center;&quot;&gt;저장공간이나 전달에 사용하기 위해 ZIP을 이용해 압축을 한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 33.333333333333336%; height: 19px; text-align: center;&quot;&gt;E-mail compatibility&lt;/td&gt;
&lt;td style=&quot;width: 33.333333333333336%; height: 19px; text-align: center;&quot;&gt;Radix-64 conversion&lt;/td&gt;
&lt;td style=&quot;width: 33.333333333333336%; height: 19px; text-align: center;&quot;&gt;e-mail application의 투명성을 제공하기 위해 암호화된 메세지는 Radix-64를 이용해 ASCII로 변환된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;div data-ke-type=&quot;moreLess&quot; data-text-more=&quot;더보기&quot; data-text-less=&quot;닫기&quot;&gt;&lt;a class=&quot;btn-toggle-moreless&quot;&gt;...더보기&lt;/a&gt;
&lt;div class=&quot;moreless-content&quot;&gt;
&lt;p&gt;많은 E-mail 시스템에서 전송에 ASCII 문자열만 지원하므로 encrypted 된 문자를 전송할때에 문제가 생길 수 있다. 그래서 PGP에서는 Radix-64 conversion을 사용해 이 문제를 해결하였다. Base64와 같은 방법으로 인코딩하며 Radix-64같은 경우엔 optional 24-bit CRC가 =이후에 올 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;다음으로 나올 표시의 의미는 아래와 같다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;$$k_{s}$$&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;Session key used in symmetric encryption scheme&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;$$PR_{a}$$&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;Private key of user A, used in public-key encryption scheme&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;$$PU_{a}$$&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;public key of user A, used in public-key encryption scheme&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;$$EP$$&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;Public-key encryption&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;$$DP$$&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;Public-key decryption&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;$$EC$$&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;Symmentric encryption&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;$$DC$$&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;Symmentric decryption&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;$$H$$&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;Hash function&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;$$||$$&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;concatenation&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;$$Z$$&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;Compression suing ZIP algorithm&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;$$R64$$&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;Conversion to radix 64 ASCII format&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#Authentication&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;전체적인 알고리즘은 다음과 같다.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/kPgSV/btqtYLIE72M/3zdNzFWB45SiD73YrWcIC1/img.png' data-lightbox='lightbox' data-alt='Authentication only'&gt;&lt;img src='https://k.kakaocdn.net/dn/kPgSV/btqtYLIE72M/3zdNzFWB45SiD73YrWcIC1/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FkPgSV%2FbtqtYLIE72M%2F3zdNzFWB45SiD73YrWcIC1%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-01 at 6.28.46 PM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;Authentication only&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;A가 B에게 나는 A다! 라고 말할 필요가 있다고 하자.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;이때, PGP에서는 다음과 같은 절차를 따른다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;1. Sender(A)가 메세지를 생성한다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;2. SHA-1을 이용해 메세지에 대한 160bit hash code를 생성한다.&lt;/p&gt;
&lt;p&gt;3. Hash code는 Sender(A)의 RSA Private key로 암호화 한다. 그리고 결과를 (1)에서 생성한 메세지의 앞에 붙인다(merge).&lt;/p&gt;
&lt;p&gt;4. Receiver(B)는 Sender(A)의 Public key를 이용해 Hash code를 복호화 한다.&lt;/p&gt;
&lt;p&gt;5. Receiver(B)가 Sender(A)에게서 받은 메세지 중 Hash code를 제외한 메세지부분을 다시 SHA-1으로 해쉬화 하여 (4)에서 복호화한 Hash code와 비교한다. 비교한 결과 값이 일치하면 수신한 메세지는 A로 부터 송신된 메세지라는 것을 알 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;위의 상황에서는 Authentication은 보장하지만 메세지에 대한 기밀성(Confidentiality)은 보장하지 못한다(위의 과정에서 메세지는 평문으로 보내졌다). 또한,&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;#Confidentiality&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/bbu9eK/btqt1k3XA32/RE97WgAM5SyGZrKPwf48Q1/img.png' data-lightbox='lightbox' data-alt='Confidentiality Only'&gt;&lt;img src='https://k.kakaocdn.net/dn/bbu9eK/btqt1k3XA32/RE97WgAM5SyGZrKPwf48Q1/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fbbu9eK%2Fbtqt1k3XA32%2FRE97WgAM5SyGZrKPwf48Q1%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-01 at 10.14.30 PM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;Confidentiality Only&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;PGP가 가지고 있는 두번째 기능으로는 &lt;span style=&quot;color: #333333;&quot;&gt;메세지 전송에 대한 암호화나, 로컬 파일에 대한 암호화에 대한&amp;nbsp;&lt;/span&gt;기밀성이다. 이때 대칭키 암호화 알고리즘인 CAST-128이 주로 사용되며 또한, IDEA나 3DES가 사용 될 수도 있고, 64-bit cipher feedback (CFB) 모드가 사용된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;div data-ke-type=&quot;moreLess&quot; data-text-more=&quot;더보기&quot; data-text-less=&quot;닫기&quot;&gt;&lt;a class=&quot;btn-toggle-moreless&quot;&gt;...더보기&lt;/a&gt;
&lt;div class=&quot;moreless-content&quot;&gt;
&lt;p&gt;CAST-128은 12-16라운드의 Feistel network로 이루어져 있으며 Feistel network는 블록 암호의 일종으로, 암호화 방식이 특정 계산 함수의 반복으로 이루어진다. 이 모델의 장점으로는 암호화 과정과 복호화 과정이 키 순서를 제외한 전체가 같은 계산을 반복하여 라운드 함수가 역연산이 존재할 필요성이 없다. 또한, 64-bit의 block size를 가지며, key size로는 40~128 bits로 이루어 지는데 이때 8-bit씩만 증가한다. &amp;nbsp;16라운드의 경우 key size가 80bits 이상인 경우 사용된다고 한다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;이때 비대칭키의 키 분배에 관한 문제점을 해결해야하며, PGP에서는 각 대칭키를 한번만 사용한다. 즉, 각 메세지 마다 128-bit의 random한 &amp;nbsp;key가 생성된다. &amp;nbsp;그리고 그 Session-key(실제로는 one-time key)는 메세지와 함께 전송되며 키의 기밀성을 위해 Receiver의 Public Key로 암호화되어 전송된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;1. Sender는 128-bit의 Session-key(one-time) key를 생성한다.&lt;/p&gt;
&lt;p&gt;2. 메세지는 CAST-128(또는, IDEA나 3DES)로 암호화 한다. 이때, 위에서 생성한 Session-key를 이용한다.&lt;/p&gt;
&lt;p&gt;3. Session-Key는 Recipient의 RSA Public Key로 암호화하여 메세지에 첨부된다.&lt;/p&gt;
&lt;p&gt;4. Receiver는 자신의 RSA Private Key를 이용하여 Session Key를 복호화 한다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;5. 이 Sesssion Key는 메세지를 복호화하는데 사용된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;이때, RSA를 사용하시는 대신 PGP는 Diffie-Hellman을 통한 방식도 제공한다.&lt;/p&gt;
&lt;div data-ke-type=&quot;moreLess&quot; data-text-more=&quot;더보기&quot; data-text-less=&quot;닫기&quot;&gt;&lt;a class=&quot;btn-toggle-moreless&quot;&gt;...더보기&lt;/a&gt;
&lt;div class=&quot;moreless-content&quot;&gt;
&lt;p&gt;Diffie-Hellman은 키 교환 방식중 하나로 아래의 조건이 주어졌을때&amp;nbsp;&lt;/p&gt;
&lt;p&gt;$$g^a, g^b $$&lt;/p&gt;
&lt;p&gt;아래의 값을 구하기 어렵다는 전제로 이루어진 키 교환 방식이다.&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #333333;&quot;&gt;$$g^{ab}$$&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;실제로 PGP에서는 다양한 Elgamal과 같은 Deiffie-Hellman 암/복호화를 지원한다.&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;암호화 시간을 줄이기 위해 바로&amp;nbsp;&lt;span style=&quot;color: #333333;&quot;&gt;RSA나 ELGamal 암호를 이용해 메세지 암호화는 것 보다&amp;nbsp;&lt;/span&gt;비대칭키와 대칭키의 조합을 이용한다. &amp;nbsp;CAST-128과 다른 대칭키 암호는 실질적으로 RSA나 ElGamal보다 빠르다.&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;두번째로, 수신자만 seesion-key를 메세지로부터 복호화할 수 있기때문에 session-key 분배 문제를 public-key 알고리즘을 이용하면 해결할 수 있다. e-mail에서는 세션을 계속 유지할 필요가 없기 때문에(전송시에만 연결하고 끊으면 되므로) 세션키 교환에 대한 protocol이 필요가 없으며 게다가, 각 메세지는 one-time key를 사용하므로 store-and-forward nature 방식을 사용하는 e-mail방식에서는 같은 session-key를 같기 위해 handshaking을 사용하는것이 실용적이지 못하다.&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;마지막으로, Session-key를 일회성으로 사용하는것은 대칭기의 장점을 부각시킨다(보안성이 더욱 증대된다). 적은 길이의 평문이 각 key로 암호화 되며, 키 간 어떠한 연관성도 없다. 그리고 PGP는 768 ~ 3072bits의 key size의 옵션을 제공한다(DSS의 경우 1024 bits가 최대).&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;# Confidentiality and authentication&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/cElA4Y/btqtY0siD7G/fCblyKsxcJfhb9I24hLsB1/img.png' data-lightbox='lightbox' data-alt='Confidentiality and authenitication'&gt;&lt;img src='https://k.kakaocdn.net/dn/cElA4Y/btqtY0siD7G/fCblyKsxcJfhb9I24hLsB1/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FcElA4Y%2FbtqtY0siD7G%2FfCblyKsxcJfhb9I24hLsB1%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-02 at 12.07.25 AM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;Confidentiality and authenitication&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;위에서 PGP의 인증 및 기밀성에 대한 부분을 살펴보았따.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;그렇다면 이 두가지를 한번에 할 수 없을까? 있다!&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;1. Sender가 메세지를 생성한다.&lt;/p&gt;
&lt;p&gt;2. SHA-1를 이용해 메세지에 대한 Hash code를 생성하여 기존의 메세지에 첨부한다.&lt;/p&gt;
&lt;p&gt;3. Sender의 Private-key를 이용하여 위의 (2)에서 만든 Hash code를 암호화 한다. (2)를 암호화 한 Hash code와 평문 메세지를 concatenation 한다.&amp;nbsp;&lt;span style=&quot;color: #f41a18;&quot;&gt;※이때 Receiver가 Sender의 Public-key를 이용해서 복호화에 성공한다면, Authentication이 충족된다.&lt;/span&gt;&lt;/p&gt;
&lt;div data-ke-type=&quot;moreLess&quot; data-text-more=&quot;더보기&quot; data-text-less=&quot;닫기&quot;&gt;&lt;a class=&quot;btn-toggle-moreless&quot;&gt;...더보기&lt;/a&gt;
&lt;div class=&quot;moreless-content&quot;&gt;
&lt;p&gt;&lt;s&gt;&lt;span&gt;&lt;span style=&quot;caret-color: #f41a18;&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;왜 이때 압축을 하는지 의문이다. 추후에 알아보도록 하자. 모든 과정이 끝난 후 압축을 한다면 조금 더 효율적일 것 같은데 특별한 이유가 있나..? 아래에 이유가 있다!&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/s&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/XwXYX/btqtZN67RHx/dQLAVQCwz7FmkujNFaUQL0/img.png' data-lightbox='lightbox' data-alt='3번까지의 메세지 상황, &amp;amp;nbsp;이때 Message는 plaintext 상태'&gt;&lt;img src='https://k.kakaocdn.net/dn/XwXYX/btqtZN67RHx/dQLAVQCwz7FmkujNFaUQL0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FXwXYX%2FbtqtZN67RHx%2FdQLAVQCwz7FmkujNFaUQL0%2Fimg.png' data-filename=&quot;Picture1.png&quot; width=&quot;260&quot; height=&quot;313&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;3번까지의 메세지 상황, &amp;nbsp;이때 Message는 plaintext 상태&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;4. Sender가 Session-key를 생성하여 위의 메세지 전체를 암호화 한다. 그리고, 생성한 Session-key를 Recipient의 public-key를 이용하여 암호화 한다&lt;span style=&quot;color: #333333;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color: #f41a18;&quot;&gt;이때 암호화한 내용은 Recipient의 Public-key에 대응하는 Private-key로만 복호화가 가능하므로 Confidentiality 충족&lt;span style=&quot;color: #000000;&quot;&gt;).&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/qgWyJ/btqtZNTyBzr/GOu3zjET1Vl4hPHmR24EA0/img.png' data-lightbox='lightbox' data-alt='Recipient에게 보낼 메세지가 모두 만들어진 상황. 평문의 메세지는 Recipient의 Private-key로만 복호화 할 수 있는 Session-key로 암호화 되어 Confidentiality를 보장하고, 그 메세지에 대한 SHA-1를 Sender의 Public-key로 복호화 할 수 있게 하므로써 Authentication도 보장된다.'&gt;&lt;img src='https://k.kakaocdn.net/dn/qgWyJ/btqtZNTyBzr/GOu3zjET1Vl4hPHmR24EA0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FqgWyJ%2FbtqtZNTyBzr%2FGOu3zjET1Vl4hPHmR24EA0%2Fimg.png' data-filename=&quot;Picture1.png&quot; width=&quot;322&quot; height=&quot;358&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;Recipient에게 보낼 메세지가 모두 만들어진 상황. 평문의 메세지는 Recipient의 Private-key로만 복호화 할 수 있는 Session-key로 암호화 되어 Confidentiality를 보장하고, 그 메세지에 대한 SHA-1를 Sender의 Public-key로 복호화 할 수 있게 하므로써 Authentication도 보장된다.&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;5. 이때 Receiver가 받은 메세지는 위와 같다. 우선 Receiver의 Private-key로 메세지를 복호화를 하면, Session-key를 획득 할 수 있다.&lt;/p&gt;
&lt;p&gt;6. (5)에서 얻은 Session-key로 메세지를 복호화 하면 평문의 'Hello d0rk'와 Sender의 Public-key로 복호화 할 수 있는 Hash code에 대한 값을 얻을 수 있다.&lt;/p&gt;
&lt;p&gt;7. Sender의 Private-key로 암호화 되어있는 Hash code를 Sender의 Public-key로 복호화 하여 평문 메세지에 대한 Hash code를 복호화한다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;8. (7)에서 얻은 Hash code와 얻은 평문에 대한 SHA-1값을 비교하여 일치하면 Authentication도 보증된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;# Compression&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;기본적으로, PGP는 서명 후, 암호화 전 Compression을 한다. 이것은 e-mail 전송과 파일 저장에서 공간을 절약하는 이점이 있다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;서명이 Compression 전에 이루어지는 이유&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;1. future verification을 위해 압축되지 않은 메세지를 서명과 함께 저장하는 것이 더욱 바람직하다. 만약 압축된 메세지를 서명하는 경우, 확인을 위해 압축된 메세지를 저장하거나 확인을 위해 다시 메세지를 압축해야 하기 때문(서명은 압축된 메세지에 대해 유효하다).&lt;/p&gt;
&lt;p&gt;2. 검증을 위해 동적으로 압축된 메세지를 생성하려고 했더라도, PGP의 compression 알고리즘은 다양하다. 다양한 알고리즘 구현은 실행속도와 비율면에서 서로 차이가 있으므로 다른 압축형식이 생성된다(즉, output이 달라진다 == Hash의 결과가 달라진다). 그러나, 어떤 버전의 compression 알고리즘을 을 사용하던 &amp;nbsp;올바르게 압축해제가 되기 때문에 별다른 문제는 없으나, 만약 압축후에 Hash와 서명을 적용하면, 모든 PGP는 동일한 version의 압축을 사용해야 한다(최초에 압축된 알고리즘으로 구현해야 똑같은 데이터 값이 나오고 그래야 Hash가 동일해 지므로 검증을 위해선 같은 압축방식을 사용해야한다).&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;암호화 전에 Compresssion이 이루어지는 이유&lt;/p&gt;
&lt;p&gt;1. 메세지 암호화는 Compression 후에 적용되어 암호학적 보안을 강화시긴다. 이유는 compression된 메세지가 평문 보다 중복이 적기 때문에, 암호 분석이 더욱 어렵다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;PGP는 Compression Algorithm으로는 ZIP이 사용된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse;&quot; width=&quot;600&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;border-bottom: #ff0000 1px solid; border-left: #ff0000 10px solid;&quot; width=&quot;50%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;span style=&quot;font-size: 18pt;&quot;&gt;# E-mail Compatibility&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;PGP가 적용되면, 전송되는 블록중 일부분 이상 암호화 된다(Authentication을 사용하는 경우 message digest 부분 , Confidentially를 사용하는 경우 messsage와 sign부분). 따라서, 결과 블록의 일부나 전체가 임의의 8-bit octets의 stream으로 구성된다. 그러나 많은 e-mail 시스템은 ASCII text만 지원하므로, 암호화된 부분을 전송하려고 하면 전송에 실패할 수 있다(암호화 된 부분이 ASCII의 범위를 초과할 수 있으므로). 따라서 PGP는 암호화 된 부분을 ASCII로 바꾸는 Radix-64를 제공한다.&lt;/p&gt;
&lt;p&gt;3 octets의 이진 데이터는 4개의 ASCII와 대응되며(Base64와 동일), 위에서 언급했듯 오류를 탐지할 수 있는 CRC를 제공한다. 3 Byte를 4 Byte와 대응시키므로 33%의 데이터가 증가된다. Session-key와 Signature 부분이 비교적 작으므로 33%가 증가 되더라도 큰 오버헤드가 일어나진 않으며, 평문은 압축되기 때문에 Radix-64를 사용하여도 평문에 대한 오버헤드 역시 크지 않다(반대로 말하면, 평문에 대한 Compress가 위의 Radix-64의 오버헤드를 상쇄시킬 수 있도록 충분히 압축되어야 한다).&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;[HELD96]에서 보고한 바에 따르면 ZIP 2.0의 버전의 압츅률은 2.0이므로 Session-key와 Signature부분을 무시한다면 PGP에 대한 데이터 증감은 file 길이 X에 대해 다음과 같이 정리할 수 있다.&lt;/p&gt;
&lt;p&gt;$$1.33 * 0.5 * X = 0.665 * X$$&lt;/p&gt;
&lt;p&gt;1.33은 Radix-64를 적용한 데이터의 길이이며, 0.5는 ZIP 2.0의 압축률을 적용한 데이터길이이다. 즉, 파일의 길이 X에서 0.6정도로 감소하므로 약 1/3의 데이터 길이가 절약된다. 또한 Authentication을 사용하는 경우, SHA-1부분만 암호화 되는데, 이때 PGP에서는 SHA-1부분만 Radix-64로 인코딩할 수 있다. 이 경우 PGP를 사용하지 않고도 사용자가 평문을 읽을 수 있다는 장점이 있다(이때 서명에 대한 확인은 불가).&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;PGP의 전체적인 다이어그램은 다음과 같다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/74gsP/btqtZNF3hoL/QmmWZ4E7XrBkv8cKpwipz1/img.png' data-lightbox='lightbox' data-alt='Sender's Diagram'&gt;&lt;img src='https://k.kakaocdn.net/dn/74gsP/btqtZNF3hoL/QmmWZ4E7XrBkv8cKpwipz1/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2F74gsP%2FbtqtZNF3hoL%2FQmmWZ4E7XrBkv8cKpwipz1%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-02 at 2.03.03 AM.png&quot; width=&quot;538&quot; height=&quot;641&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;Sender's Diagram&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;1. 평문 메세지 X&lt;/p&gt;
&lt;p&gt;2. Signature가 필요한 경우 X에 Signature를 concatenate하고, 필요 없을 경우 바로 압축&lt;/p&gt;
&lt;p&gt;3. Confidentiality가 필요한 경우 session-key를 생성하여, &lt;span style=&quot;color: #333333;&quot;&gt;session-key를 이용해 메세지 X를 암호화한 후&amp;nbsp;&lt;/span&gt;session-key를 Recipient의 public-key로 암호화&lt;/p&gt;
&lt;p&gt;4. radix-64 적용&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/bx3FTu/btqtZOkJLNI/DPLT96DO4g8AKDvqXnXgs1/img.png' data-lightbox='lightbox' data-alt='Recipient's Diagram'&gt;&lt;img src='https://k.kakaocdn.net/dn/bx3FTu/btqtZOkJLNI/DPLT96DO4g8AKDvqXnXgs1/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fbx3FTu%2FbtqtZOkJLNI%2FDPLT96DO4g8AKDvqXnXgs1%2Fimg.png' data-filename=&quot;Screen Shot 2019-04-02 at 2.06.58 AM.png&quot; width=&quot;454&quot; height=&quot;528&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;Recipient's Diagram&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;1. Radix-64를 디코딩&lt;/p&gt;
&lt;p&gt;2. Confidentiality가 되어있는 경우 자신의 Private-key를 이용해 Session-key를 복호화 그 후, Session-key로 암호화 되어있는 메세지 X를 복호화 한 Session-key를 이용해 복호화&lt;/p&gt;
&lt;p&gt;3. Decompress&lt;/p&gt;
&lt;p&gt;4. Signature가 필요한 경우 X의 메세지에서 Hash code를 분리하여 일치 여부 확인&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;끗!! ㅋ&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p style=&quot;text-align: right;&quot;&gt;Reference : Cryptography and Network Security, sixth Ed&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block; text-align:center;&quot;
     data-ad-layout=&quot;in-article&quot;
     data-ad-format=&quot;fluid&quot;
     data-ad-client=&quot;ca-pub-3588179945681108&quot;
     data-ad-slot=&quot;3731887415&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.dork94.com/180&amp;amp;layout=button_count&amp;amp;show_faces=true&amp;amp;width=106&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:106px; height:30px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Network</category>
<author>Dork94</author>
<guid>https://blog.dork94.com/180</guid>
<comments>https://blog.dork94.com/180#entry180comment</comments>
<pubDate>Mon, 01 Apr 2019 12:01:54 +0900</pubDate>
</item>
<item>
<title>Python에서 db 연동하기(mysql, mariadb)</title>
<link>https://blog.dork94.com/179</link>
<description>&lt;p&gt;예전에 파이썬에서 db를 사용할 일이있어서 코딩했다가, 오랜만에 다시 사용할일이 생겨 찾아봤다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;또 까먹을 것 같아 정리차 남겨둔다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Python에서 database를 사용할 수 있는 방법은 여러가지가 있지만, 그 중에서 나는 mysql이나 mariadb를 사용하므로 이것들과 연동이 되는 라이브러리를 찾아보았다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;그래서 나는 pymysql을 이용할 것이다!&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;코드는 다음과 같다&lt;/p&gt;
&lt;pre class=&quot;ebnf&quot;&gt;&lt;code&gt;import pymysql
# dbconfig.py
class MysqlController:
    def __init__(self, host, id, pw, db_name):
        self.conn = pymysql.connect(host=host, user= id, password=pw, db=db_name,charset='utf8')
        self.curs = self.conn.cursor()

    def insert_total(self,total):
        sql = 'INSERT INTO entire_nodes (count_of_nodes) VALUES (%s)'
        self.curs.execute(sql,(total,))
        self.conn.commit()


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;간단하게 설명하자면 class에서 인자값으로 host와 id, pw, 그리고 db이름을 인자로 받아 먼저 연결한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;그리고 insert_total함수를 이용해 값을 넣을 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;이때 sql의 문자열에 %s를 넣고 execute시에 값을 인자로 넘기는 것을 볼 수 있는데, 이는 sql_injection 공격을 막기 위함이니 저렇게 적도록 하자 :)&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;그리고 위를 사용하는 코드는 다음과 같다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;pre class=&quot;ebnf&quot;&gt;&lt;code&gt;import dbconfig
import requests
from bs4 import BeautifulSoup
from time import sleep
import re
#  main.py
url = 'https://www.ethernodes.org/network/1'
INTERBAL = 60
if __name__=='__main__':
    regex = re.compile(r'Total(.*\d)\s')
    mysql_controller = dbconfig.MysqlController('localhost','root','test123','etherstat')

    while True:
        res = requests.get(url)
        if res.status_code == 200:
            soup = BeautifulSoup(res.text, 'html.parser')
            items = soup.find_all('li')

            for item in items:
                result = regex.search(item.text)
                if result:
                    mysql_controller.insert_total(result.groups(1)[0])
                    sleep(INTERBAL)



&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;위 코드는 특정 사이트에서 특정 값을 받아 데이터 베이스에 추가시키는 코드이다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;데이터베이스는 다음과 같이 구성되어있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/cmj8th/btqtUjkX2tS/0OSjPJDAOWqUdBWt6AzGW1/img.png' data-lightbox='lightbox' data-alt='테이블은 다음과같이 단순하게 구성되어있다. INT형의 변수와 timestamp 타입의 변수이며, timestamp는 아무런 값도 입력 되지 않는 경우 기본으로 현재 시간이 입력된다.'&gt;&lt;img src='https://k.kakaocdn.net/dn/cmj8th/btqtUjkX2tS/0OSjPJDAOWqUdBWt6AzGW1/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fcmj8th%2FbtqtUjkX2tS%2F0OSjPJDAOWqUdBWt6AzGW1%2Fimg.png' data-filename=&quot;Screen Shot 2019-03-28 at 9.14.36 PM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;테이블은 다음과같이 단순하게 구성되어있다. INT형의 변수와 timestamp 타입의 변수이며, timestamp는 아무런 값도 입력 되지 않는 경우 기본으로 현재 시간이 입력된다.&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/ASG5V/btqtVsO3CZs/BMfkmyrAFkNBjHIIoD5gz0/img.png' data-lightbox='lightbox' data-alt='현재 테이블에 아무 데이터도 없는 것을 볼 수 있다.'&gt;&lt;img src='https://k.kakaocdn.net/dn/ASG5V/btqtVsO3CZs/BMfkmyrAFkNBjHIIoD5gz0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FASG5V%2FbtqtVsO3CZs%2FBMfkmyrAFkNBjHIIoD5gz0%2Fimg.png' data-filename=&quot;Screen Shot 2019-03-28 at 9.17.47 PM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;현재 테이블에 아무 데이터도 없는 것을 볼 수 있다.&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/xOxG3/btqtVfh50uA/JOVAFyVTRkYoR68JPnqmU0/img.png' data-lightbox='lightbox' data-alt='프로그램 실행 후에 정상적으로 데이터가 입력된 것을 볼 수 있다. 프로그램이 계속 돌아간다면 1분마다 데이터가 쌓일 것 이다.'&gt;&lt;img src='https://k.kakaocdn.net/dn/xOxG3/btqtVfh50uA/JOVAFyVTRkYoR68JPnqmU0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FxOxG3%2FbtqtVfh50uA%2FJOVAFyVTRkYoR68JPnqmU0%2Fimg.png' data-filename=&quot;Screen Shot 2019-03-28 at 9.18.00 PM.png&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;프로그램 실행 후에 정상적으로 데이터가 입력된 것을 볼 수 있다. 프로그램이 계속 돌아간다면 1분마다 데이터가 쌓일 것 이다.&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block; text-align:center;&quot;
     data-ad-layout=&quot;in-article&quot;
     data-ad-format=&quot;fluid&quot;
     data-ad-client=&quot;ca-pub-3588179945681108&quot;
     data-ad-slot=&quot;3731887415&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.dork94.com/179&amp;amp;layout=button_count&amp;amp;show_faces=true&amp;amp;width=106&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:106px; height:30px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Develop</category>
<author>Dork94</author>
<guid>https://blog.dork94.com/179</guid>
<comments>https://blog.dork94.com/179#entry179comment</comments>
<pubDate>Thu, 28 Mar 2019 21:21:44 +0900</pubDate>
</item>
<item>
<title>Combination 과 nCr+1 구하기!</title>
<link>https://blog.dork94.com/178</link>
<description>&lt;p&gt;$$_{n}C_{r}$$&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;n개중에 r개를 선택할 경우의 수&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;$$_{n}C_{r+1} = _{n-1}C_{r-1}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_{n}C_{r-1}$$&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;또는,&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;$$_{n}C_{r+1}&amp;nbsp;= (n-r)/(r+1)&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_{n}C_{r}$$&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;위와 같이 계산할 수 있음.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;아래는 실제 테스트한 코드.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    n = 33
    r = 24
    print(ncr(33,24))
    print(ncr(33,25))
    print((n-r)/(r+1) * ncr(33,24))
    exit(0)&lt;/code&gt;&lt;/pre&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;p&gt;result :&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;div class=&quot;txc-textbox&quot; style=&quot;BORDER-TOP: #747474 3px double; BORDER-RIGHT: #747474 3px double; BORDER-BOTTOM: #747474 3px double; PADDING-BOTTOM: 10px; PADDING-TOP: 10px; PADDING-LEFT: 10px; BORDER-LEFT: #747474 3px double; PADDING-RIGHT: 10px; BACKGROUND-COLOR: #000000&quot;&gt;
&lt;p style=&quot;TEXT-ALIGN: left&quot;&gt;&lt;span style=&quot;COLOR: #ffffff&quot;&gt;38567100&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;TEXT-ALIGN: left&quot;&gt;&lt;span style=&quot;COLOR: #ffffff&quot;&gt;13884156&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;TEXT-ALIGN: left&quot;&gt;&lt;span style=&quot;COLOR: #ffffff&quot;&gt;13884156.0&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: start;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: start;&quot;&gt;물론 사용시에는 ncr이전 값을 다른 공간에 저장하고 사용하는 것이 속도를 올릴 수 있을 것 같다!&lt;/p&gt;&lt;p style=&quot;text-align: right;&quot;&gt;Thanks to rach&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block; text-align:center;&quot;
     data-ad-layout=&quot;in-article&quot;
     data-ad-format=&quot;fluid&quot;
     data-ad-client=&quot;ca-pub-3588179945681108&quot;
     data-ad-slot=&quot;3731887415&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.dork94.com/178&amp;amp;layout=button_count&amp;amp;show_faces=true&amp;amp;width=106&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:106px; height:30px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Math</category>
<author>Dork94</author>
<guid>https://blog.dork94.com/178</guid>
<comments>https://blog.dork94.com/178#entry178comment</comments>
<pubDate>Tue, 26 Mar 2019 15:39:14 +0900</pubDate>
</item>
<item>
<title>수학..</title>
<link>https://blog.dork94.com/177</link>
<description>&lt;p&gt;너무싫다......&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block; text-align:center;&quot;
     data-ad-layout=&quot;in-article&quot;
     data-ad-format=&quot;fluid&quot;
     data-ad-client=&quot;ca-pub-3588179945681108&quot;
     data-ad-slot=&quot;3731887415&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://blog.dork94.com/177&amp;amp;layout=button_count&amp;amp;show_faces=true&amp;amp;width=106&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:106px; height:30px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Math</category>
<author>Dork94</author>
<guid>https://blog.dork94.com/177</guid>
<comments>https://blog.dork94.com/177#entry177comment</comments>
<pubDate>Tue, 26 Mar 2019 15:23:52 +0900</pubDate>
</item>
</channel>
</rss>