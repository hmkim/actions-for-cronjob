<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="kr"><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://rokrokss.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://rokrokss.com/" rel="alternate" type="text/html" hreflang="kr" /><updated>2019-04-29T20:53:20+09:00</updated><id>https://rokrokss.com/feed.xml</id><title type="html">ROKROKSS</title><subtitle>ROKROKSS
</subtitle><author><name>김형록</name><email>hyungrok.kim@kaist.ac.kr</email></author><entry><title type="html">신입 개발자 면접을 위한 지식 총정리</title><link href="https://rokrokss.com/post/2019/04/06/%EB%A9%B4%EC%A0%91-%EC%A4%80%EB%B9%84-%EC%A0%84%EC%82%B0-%EC%88%98%EC%97%85-%EC%B4%9D%EC%A0%95%EB%A6%AC.html" rel="alternate" type="text/html" title="신입 개발자 면접을 위한 지식 총정리" /><published>2019-04-06T00:00:00+09:00</published><updated>2019-04-06T00:00:00+09:00</updated><id>https://rokrokss.com/post/2019/04/06/%EB%A9%B4%EC%A0%91-%EC%A4%80%EB%B9%84-%EC%A0%84%EC%82%B0-%EC%88%98%EC%97%85-%EC%B4%9D%EC%A0%95%EB%A6%AC</id><content type="html" xml:base="https://rokrokss.com/post/2019/04/06/%EB%A9%B4%EC%A0%91-%EC%A4%80%EB%B9%84-%EC%A0%84%EC%82%B0-%EC%88%98%EC%97%85-%EC%B4%9D%EC%A0%95%EB%A6%AC.html">&lt;p&gt;면접 관련 준비 사항과 문제들을 끌어모아 정리합니다. 코딩 테스트 준비는 &lt;a href=&quot;https://www.acmicpc.net/user/q0115643&quot;&gt;백준&lt;/a&gt;으로 갑니다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;blockquote&gt;
  &lt;p&gt;당분간 저만 알아볼 수 있을겁니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;ds-algo-pl-network-os&quot;&gt;DS, ALGO, PL, Network, OS&lt;/h1&gt;

&lt;h2 id=&quot;ds-and-algo&quot;&gt;DS and ALGO&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Data Structures&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Data Structure&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;데이터구조는 정돈된 데이터의 집합으로 특정 방식으로 데이터를 넣고, 꺼낼 수 있게 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ADT (Abstract Data Type)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;“Data” + “Operations on the data” =&amp;gt; “A Data Type”&lt;/p&gt;

&lt;p&gt;Data Type은 해당 프로그래밍 언어가 정의해놓은 Primitive Data Type = Concrete Data Type과 Abstract Data Type으로 나뉜다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Array&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;인덱스를 이용하여 데이터를 삽입하거나 참조합니다.&lt;/p&gt;

&lt;p&gt;create, retrieve, store operation이 있습니다.&lt;/p&gt;

&lt;p&gt;인덱스를 안다면 1 step에 데이터를 찾을 수 있지만, 데이터 사이에 삽입을 하려면 먼저 데이터들을 옮겨야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linked-List&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;index 대신 다음 node의 주소를 들고 있게 합니다. 데이터는 선형 탐색으로 찾아야 하지만 삽입과 제거는 O(1)에 가능합니다.&lt;/p&gt;

&lt;p&gt;C로 구현한다면 데이터 삽입과 삭제는 Malloc과 free를 반복하며 하게 됩니다.&lt;/p&gt;

&lt;p&gt;Singly-Linked, Doubly-Linked&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Stack&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;LIFO(Last-In/First-Out) Data Structure&lt;/p&gt;

&lt;p&gt;array나 linked-list로 구현합니다.&lt;/p&gt;

&lt;p&gt;array로 만드려면 간단히 array 하나와 top-index만 가지고 있으면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Queue&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;FIFO(First-In/First-Out) Data Structure&lt;/p&gt;

&lt;p&gt;array를 통한 구현이 stack보다 복잡합니다.&lt;/p&gt;

&lt;p&gt;queue의 item들을 한 array에 담고 enqueue, dequeue에 전체 array를 통째로 옮겨가게 만들면 쉽지만 O(n)이 됩니다.
아니면, front와 rear(꼬리) index를 따로 들고 있게 합니다. 이렇게 하면 enqueue/dequeue가 반복될수록 array의 앞이 비고 뒤로 밀리는데,
Circular Array 개념을 이용하여 해결할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Priority Queue&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;array를 priority마다 준비하던가, 한 array에 enqueue 할 때 올바른 위치로 들어가도록 합니다.
array나 linked-list를 이용하면 삽입이 O(n)인데, heap을 이용하면 삽입과 삭제가 모두 O(log(n))이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Time Complexity&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;f(n) = O(g(n))&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;|f(n)| &amp;lt;= C|g(n)| 이 항상 성립하게 하는 양의 상수 C가 있다면 이런 big-oh notation이 성립합니다.&lt;/p&gt;

&lt;p&gt;“g(n) is an upper bound of f(n)”&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;f(n) = Ω(g(n))&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;|f(n)| &amp;gt;= C|g(n)| 이 항상 성립하게 하는 양의 상수 C가 있다면 이런 big-omega notation이 성립합니다.&lt;/p&gt;

&lt;p&gt;“g(n) is an lower bound of f(n)”&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;f(n) = Θ(g(n))&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;f(n) = O(g(n))과 f(n) = Ω(g(n))이 모두 성립하면 이런 big-theta notation이 성립합니다.&lt;/p&gt;

&lt;p&gt;“g(n) is both an upper bound and a lower bound of f(n)”&lt;/p&gt;

&lt;p&gt;시간 복잡도 분석은 Worst case, Best case, Average case를 따로 다룰 수 있습니다, 예시로 Quick sort가 있죠.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Tree&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Linked-List와 비슷한 구조로 구현됩니다. root node가 존재하며 각 node는 해당 node의 children의 주소들을 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Binary Tree&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;node는 left child와 right child를 가질 수 있습니다. 어디서든 쭉 올라가면 root node가 나옵니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Full Binary Tree&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;특정 깊이까지 전부 꽉 차있는 트리입니다.&lt;/p&gt;

&lt;p&gt;Full Binary Tree에서 level L (root의 level은 0)의 노드 갯수는 &lt;script type=&quot;math/tex&quot;&gt;2^L&lt;/script&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Complete Binary Tree&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;최소한 마지막 레벨을 제외하면 Full Binary Tree 구조를 가지며 마지막 레벨의 node는 왼쪽에서부터 채워진 트리입니다.&lt;/p&gt;

&lt;p&gt;Complete Binary Tree는 array representation이 있습니다. 좌-&amp;gt;우, 상-&amp;gt;하로 쭉 채우면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pre-order Traversal&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;현재 노드 작업
Left Child
Right Child
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;In-order Traversal&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Left Child
현재 노드 작업
Right Child
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Post-order Traversal&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Left Child
현재 노드 작업
Right Child
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Binary Search Tree&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;왼쪽 subtree의 모든 node의 key는 현재 node의 key보다 작거나 같으며 오른쪽은 큽니다.
skewed tree의 가능성이 있으므로 삽입/삭제/탐색 모두 O(n)이 됩니다.&lt;/p&gt;

&lt;p&gt;삭제 매커니즘이 특별한데, 제거해야할 node의 child가 2개로 차있을 경우, 오른쪽 subtree의 최소 key를 가진 node를 제거해야하는 node 자리에 복사하고 원래 자리의 node를 제거합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Heap&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Heap은 기본적으로 complete binary tree 구조를 가집니다.&lt;/p&gt;

&lt;p&gt;MaxHeap: parent는 child에 비하여 크거나 같은 key를 가집니다.&lt;/p&gt;

&lt;p&gt;MinHeap: parent는 child에 비하여 작거나 같은 key를 가집니다.&lt;/p&gt;

&lt;p&gt;Priority Queue를 만드는데 쓰이므로 삭제는 root node를 대상으로 이루어지며, root node를 맨 오른쪽 leaf node와 바꾼 뒤 삭제, leaf node는 아래로 traverse하며 제자리를 찾게 합니다.&lt;/p&gt;

&lt;p&gt;삽입 시에는 마지막 node 자리에 넣고 위로 traverse하며 제자리를 찾게 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B-Tree&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;skewed tree 문제점을 해결하기 위한 해결방안 중 하나입니다.&lt;/p&gt;

&lt;p&gt;node는 둘보다 많은 child node를 가질 수 있으며, 한 node가 여러 element를 가질 수 있습니다.&lt;/p&gt;

&lt;p&gt;B-Tree는 M(Minimum)이라는 양수를 가집니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;root는 element를 최소한 1개까지 가질 수 있지만 다른 node들은 최소한 m개의 element를 가져야 합니다.&lt;/li&gt;
  &lt;li&gt;node 내의 element 갯수의 최댓값은 2m입니다.&lt;/li&gt;
  &lt;li&gt;모든 node의 element는 작은 값부터 정렬된 상태로 array에 담겨있습니다.&lt;/li&gt;
  &lt;li&gt;node가 가지는 subtree는 (node 내의 element 갯수 + 1)개입니다.&lt;/li&gt;
  &lt;li&gt;non-leaf node에서 index i에 위치한 element는 subtree i의 모든 element보다 크고 subtree i+1의 모든 element 값보다 작습니다.&lt;/li&gt;
  &lt;li&gt;모든 leaf node는 같은 깊이에 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;탐색: node 내의 element를 선형탐색하여 target을 찾고, 못 찾을 땐 처음으로 만나는 target보다 큰 값의 index가 i면 subtree[i]에 대하여 반복한다.&lt;/p&gt;

&lt;p&gt;삽입: 탐색과 같은 방식으로 진행하다 leaf에서 target보다 처음으로 커지는 element 앞으로 삽입한다.
element 갯수가 maximum+1이 되면, 가운데 element를 parent로 보내버립니다. root까지 가버리면 새로운 root를 만듭니다.&lt;/p&gt;

&lt;p&gt;삭제: 1) child가 없는데 못찾으면 False, child가 없는데 찾으면 단순 삭제, child가 있는데 찾았다면 직전 subtree의 가장 큰 element와 swap 후 아래에서 삭제합니다.
child가 있는데 root에서 못찾았다면 subtree로 들어가 반복합니다.
이러다 node의 element 갯수가 minimum-1이 된다면 직전 subtree, 직후 subtree 혹은 형제에게서 빌려오거나 합쳐버립니다.&lt;/p&gt;

&lt;p&gt;삽입/삭제/탐색 모두 log(n)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Graphs&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Graph에는 종류가 많지만 제가 들은 수업에서는 self-loop과 동일한 간선의 반복이 없는 종류만 취급했습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;무한하지 않고 공집합이 아닌 node의 집합 V와 무한하지 않은 간선의 집합 E가 모여 Graph(V, E)를 형성합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Free Tree&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;root가 없고 connected이며 acyclic한 graph입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cycle: a simple path in which the first and the last vertices are the same.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Undirected Graph&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;간선에 방향이 주어져 있지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Directed Graph&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;간선에 방향이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Complete Graphs&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Undirect에서는 간선의 갯수가 n(n-1)/2 입니다.&lt;/p&gt;

&lt;p&gt;Directed에서는 n(n-1)입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Subgraphs&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;V와 E가 상위 그래프에 모두 포함되면 Subgraph라 합니다.&lt;/p&gt;

&lt;p&gt;그 외 adjacent, incdent on, adjacent to, adjacent from, in-degree, out-degree&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Adjacency List&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;node 갯수 길이의 array의 각 node가 각자 리스트를 이루고 해당 node에서 adjacent한 node가 push_back됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for edge in edges:
    a, b = edge
    # a-&amp;gt;b    
    adj[a].push_back(b)
    # Undirected면
    adj[b].push_back(a)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;out-degree는 찾기 쉽지만 in-degree는 어렵습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Adjacency Matrix&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;고대로 matrix 만드는 겁니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for edge in edges:
    a, b = edge
    # a-&amp;gt;b
    adj[a][b] = 1
    # Undirected면
    adj[b][a] = 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Depth First Search (DFS)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;아까 나왔던 preorder tree traversal와 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dfs(v): # 아주 대략적으로...
    visited[v] = True
    for w in v-&amp;gt;links:
        if not visited[w]:
            dfs(w)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Adjacency List를 이용하면 간선의 갯수만큼 참조가 일어나고, 그 전에는 visit을 위해 node 갯수만큼 참조하므로 &lt;script type=&quot;math/tex&quot;&gt;O(n+e)&lt;/script&gt;입니다.&lt;/p&gt;

&lt;p&gt;Adjacency Matrix를 이용하면 한 node에 인접한 간선을 모두 찾는데 &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;이 걸리고 node 갯수만큼 반복하므로 &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Breadth First Search (BFS)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Level order tree search와 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bfs(v): # 아주 대략적으로...
    q = Queue()
    q.enqueue(v)
    while not q.is_empty():
        v = q.dequeue()
        for w in v-&amp;gt;links:
            if not visited[w]:
                bfs(w)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;시간복잡도는 DFS와 동일하게 Adjacency List에서 &lt;script type=&quot;math/tex&quot;&gt;O(n+e)&lt;/script&gt;, Adjacency Matrix에서 &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Single Source Shortest Path&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;하나의 출발점에서 각 정점까지 도달하는데 비용을 계산하여 최단경로를 구하는 것입니다.
기본적으로 Directed Graph 구조를 가지고 설명하며, Undirected일 경우 같은 weight의 directed edge 두 개로 바꾸고 시작합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dijkstra Algorithm&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Priority Queue를 이용하여 하나의 정점으로부터 인접한 간선들을 확장해 나가는 방식입니다.
음수 가중치를 갖는 간선이 없어야 합니다.&lt;/p&gt;

&lt;p&gt;d[v] 배열을 모두 ∞으로 초기화하고, 시작점의 d[v] 값을 0으로하고 Priority Queue에 넣습니다.&lt;/p&gt;

&lt;p&gt;Queue가 빌 때까지 minimum을 뽑고, 해당 정점에 adjacent한 정점의 d[v]값을 계산하여 업데이트합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dijkstra(adjacency_list, v):
    n = len(adjacency_list)
    d = [INF for _ in range(n)]
    visited = [False for _ in range(n)]
    d[v] = 0
    q = PriorityQueue()
    q.enqueue((d[v], v))
    while not q.is_empty():
        value, cur = q.dequeue()
        if value &amp;gt; d[cur]: continue
        visited[cur] = True
        for dest, weight in adjacency_list:
            new_v = d[curr] + weight
            if (not visited[dest]) and new_v &amp;lt; d[dest]:
                d[dest] = new_v
                q.enqueue((d[dest], dest))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실제로 priority queue를 heap으로 구현하고 path 구하려면 predecessor 배열 만들긴 해야하는데 아무튼 이런 식으로하면 됩니다.&lt;/p&gt;

&lt;p&gt;heap에 삽입이 &lt;script type=&quot;math/tex&quot;&gt;O(logE)&lt;/script&gt;, 그리고 삽입이 정점 갯수에 한해서 이루어지므로 &lt;script type=&quot;math/tex&quot;&gt;O(VlogE)&lt;/script&gt;, 값 갱신은 간선 갯수에 한해서 이루어지므로 &lt;script type=&quot;math/tex&quot;&gt;O(ElogE)&lt;/script&gt;,
합쳐서 &lt;script type=&quot;math/tex&quot;&gt;O((E+V)logE)&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
V &lt;= E^2 %]]&gt;&lt;/script&gt;이므로 &lt;script type=&quot;math/tex&quot;&gt;O((E+V)logV)&lt;/script&gt;입니다. 피보나치 힙을 사용하면 더 줄일 수 있다고 하네요.&lt;/p&gt;

&lt;p&gt;정당성 증명&lt;/p&gt;

&lt;p&gt;방문된 정점까지의 거리는 최소 거리임을 증명하면 되는데, 초기에 정점 하나만 있을 때 만족하므로 귀납법 + 귀류법으로 풉니다.&lt;/p&gt;

&lt;p&gt;K+1 단계에서 정점 u를 방문하였는데 그 거리가 실제 최소 거리가 아니라고 하면, 다른 정점 u’가 방문되지 않은 채 존재하여 u까지의 실제 최소 거리를 잇는 정점으로 존재한다는 것인데,
그렇게 되면 (중략 w, w’가 등장하는 부분) d[u’]가 d[u]보다 작게 되는데 그러면 알고리즘 진행과정에서 u’가 u보다 먼저 방문되었어야 하므로 contradiction이 생기므로 증명 완료됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Floyd-Warshall’s Algorithm&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;얘는 Single Source Shortest Path 뿐만 아니라 All Pairs Shortest Paths를 구해줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;floyd_warshall():
    for i in range(E):
        for j in range(E):
            for k in range(E):
                if adj[i][k] &amp;gt; adj[j][i] + adj[i][k]:
                    adj[j][k] = adj[j][i] + adj[i][k]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;코드만 보셔도 아실 겁니다. &lt;script type=&quot;math/tex&quot;&gt;O(E^3)&lt;/script&gt; 입니다. 중요한 점은 가운데 지나가는 정점이 맨 바깥 for문에 위치해야 한다는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Minimum Cost Spanning Tree&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;connected graph G에서 모든 node를 방문하는 cycle이 없는 subgraph를 spnning tree라고 합니다.&lt;/p&gt;

&lt;p&gt;weighted undirected graph에서 spanning tree의 모든 간선의 weight 총합이 경우의 수 중 최소라면 해당 tree를
Minimum Cost Spanning Tree라고 부릅니다. (spanning tree with minimum cost)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kruskal’s Algorithm&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;edge를 지우고 정점을 독립적인 집합인 forest로 만듭니다.&lt;/li&gt;
  &lt;li&gt;edge를 ascending order로 정렬합니다.&lt;/li&gt;
  &lt;li&gt;cycle을 만들지 않는 가장 작은 edge를 골라 graph에 추가합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;E(G)를 ascending order로 정렬한다.
T = (V, 공집합) # vertices + no edges
VS =[[v] for v in V]
While num(VS) &amp;gt; 1 and (E(G) is not empty):
    (v, w) = deleteMin(E(G))
    if Find(u) != Find(v):
        replace set(u), set(v) by Union(set(u), set(v))
        add (v, w) to T
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;간선을 정렬하는데에 &lt;script type=&quot;math/tex&quot;&gt;O(ElogE)&lt;/script&gt;,
그리고 Union과Find가 E번 반복되는데, Union-by-height과 path-compression을 이용하면 Union은 &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt; Find는 &lt;script type=&quot;math/tex&quot;&gt;O(log{\star}V)&lt;/script&gt;가 됩니다.
그렇게 아무튼 &lt;script type=&quot;math/tex&quot;&gt;O(ElogE) + O(Elog{\star}V) = O(ElogE)&lt;/script&gt;가 됩니다.&lt;/p&gt;

&lt;p&gt;크루스칼 알고리즘 정당성 증명&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;크루스칼로 만들어진 그래프가 Spanning Tree 임은 Acyclic하고 모든 노드를 포함한다는 점으로 간단하게 증명됩니다.&lt;/li&gt;
  &lt;li&gt;Minimum Spanning Tree&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;귀류법을 통해 크루스칼로 만들어진 트리 T가 MST가 아니라고 합시다. 먼저 알고리즘 시작단계의 공집합에서는 MST를 만족하는데,
어느 순간 크루스칼이 택하는 간선이 아닌 다른 간선 (u, v)가 추가됨으로 MST를 만들게 된다는 의미인데 우리는 간선을 최소 weight 순으로 정렬하고 포함시켰으며
만들어지는 트리가 Spanning Tree 임은 1로 증명되었으므로 모순이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Prim’s Algorithm&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;prim():
    Q = V - {s}
    For v in V:
        D[v] = INF
        v.predecessor = None
    D[s] = 0
    while not Q.is_empty():
       u = Q.extract_min()
       for v in adj[u]:
           if v in Q and w(u,v) &amp;lt; D[v]:
               D[u] = w(u, v)
               v.predecessor = u    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;크루스칼의 정점 버전입니다. heap으로 구현하면 &lt;script type=&quot;math/tex&quot;&gt;O((E+V)logV)&lt;/script&gt;, array를 이용하면 &lt;script type=&quot;math/tex&quot;&gt;O(V^2)&lt;/script&gt;입니다.&lt;/p&gt;

&lt;p&gt;증명&lt;/p&gt;

&lt;p&gt;귀류법+귀납법을 사용합니다. K+1번째에 (u, v)를 추가하여 T를 만들면, (u, v)는 실제 MST T’에 포함되지 않아야 합니다.
그러므로 (u, v)를 T’에 추가하면 cyclic한 graph가 됩니다. (u, v)와 T’가 (u, v) 대신 가진 간선을 바꿨을 때
T는 전보다 weight이 더 커지게 되므로 모순입니다. (알고리즘 상)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Sort Algorithms&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Selection Sort&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;selection_sort():
    for i in range(n):
        min_idx = i
        for j in range(i + 1, n):
            if a[j] &amp;lt; a[min_idx]:
                min_idx = j
        a[i], a[min_idx] = a[min_idx], a[i]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너무 간단합니다. &lt;script type=&quot;math/tex&quot;&gt;O(N^2)&lt;/script&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Insertion Sort&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;insertion_sort():
    for i in range(1, n):
        key = a[i]
        j = i - 1
        while j &amp;gt;= 0 and a[j] &amp;gt; key:
            a[j + 1] = a[j]
            j -= 1
        a[j + 1] = key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;array 앞의 초기에 1칸짜리 구역을 지정하고 한 칸씩 오른쪽으로 늘리면서 해당 item을 왼쪽 구간의 올바른 위치에 넣는것입니다.
마찬가지로 &lt;script type=&quot;math/tex&quot;&gt;O(N^2)&lt;/script&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bubble Sort&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bubble_sort():
    for i in range(n):
        for j in range(n - i - 1):
            if a[j] &amp;gt; a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;뒤에서 i번째 칸을 위해 맨 앞부터 올바른 값을 swap을 반복하며 가져오길 반복합니다.
&lt;script type=&quot;math/tex&quot;&gt;O(N^2)&lt;/script&gt; 이고 위 두 정렬보다 성능이 더 나쁩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Merge Sort&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;merge_sort(a):
    n = len(a)
    if n &amp;lt;= 1:
        return a
    mid = n // 2
    g1 = merge_sort(a[:mid])
    g2 = merge_sort(a[mid:])
    i1 = 0
    i2 = 0
    ia = 0
    while i1 &amp;lt; len(g1) and i2 &amp;lt; len(g2):
        if g1[i1] &amp;lt; g2[i2]:
            a[ia] = g1[i1]
            i1 += 1
        else:
            a[ia] = g2[i2]
            i2 += 1
        ia += 1
    while i1 &amp;lt; len(g1):
        a[ia] = g1[i1]
        i1 += 1
        ia += 1
    while i2 &amp;lt; len(g2):
        a[ia] = g2[i2]
        i2 += 1
        ia += 1
    return a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;분할정복으로 분해된 sub-array들을 한 쌍씩 쭉 합쳐주는겁니다.
&lt;script type=&quot;math/tex&quot;&gt;O(NlogN)&lt;/script&gt; 이지만 같은 시간복잡도의 다른 정렬들과 다르게 추가적인 memory를 필요로 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Quick Sort&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;quick_sort(a, start_idx, end_idx):
    if start_idx &amp;gt;= end_idx:
        return;
    pivot_idx = random.randint(start_idx, end_idx)
    pivot_val = a[pivot_idx]
    a[pivot_idx], a[end_idx] = a[end_idx], a[pivot_idx]
    store_idx = start_idx
    for i in range(start_idx, end_idx):
        if a[i] &amp;lt; pivot_val:
            a[i], a[store_idx] = a[store_idx], a[i]
            store_idx += 1
    a[store_idx], a[end_idx] = a[end_idx], a[store_idx]
    quick_sort(a, start_idx, store_idx - 1)
    quick_sort(a, store_idx + 1, end_idx)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;O(N)&lt;/script&gt;의 extra memory를 허용하게 하면 더 쉽게할 수 있지만 위처럼 만들면 extra memory는 starck frame의 &lt;script type=&quot;math/tex&quot;&gt;O(logN)&lt;/script&gt; 만 필요합니다.&lt;/p&gt;

&lt;p&gt;평균적으로 &lt;script type=&quot;math/tex&quot;&gt;O(NlogN)&lt;/script&gt; 의 시간복잡도를 가지지만, 최악의 경우 &lt;script type=&quot;math/tex&quot;&gt;N^2&lt;/script&gt; 의 시간복잡도를 가집니다.&lt;/p&gt;

&lt;p&gt;시간복잡도에 대한 증명은 &lt;a href=&quot;https://www.khanacademy.org/computing/computer-science/algorithms/quick-sort/a/analysis-of-quicksort&quot;&gt;여기&lt;/a&gt;를 참고하세요.
근데 교수님 수업에서 적분까지 해가면서 strict하게 증명했던 것 같은데 필기가 남아있지 않네요… 나중에 그때 그 내용 어디서 찾으면 추가할게요.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Heap Sort&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;heapify(a, idx, heap_size):
    largest = idx
    left_idx, right_idx = 2 * idx + 1, 2 * idx + 2
    if left_idx &amp;lt; heap_size and a[left_idx] &amp;gt; a[largest]:
        largest = left_idx
    if right_idx &amp;lt; heap_size and a[right_idx] &amp;gt; a[largest]:
        largest = right_idx
    if largest != idx:
        a[largest], a[idx] = a[idx], a[largest]
        heapify(a, largest, heap_size)


heapsort(a):
    n = len(a)
    for i in range((n - 1) // 2, -1, -1):
        heapify(a, i, n)
    for i in range(n - 1, 0, -1):
        a[0], a[i] = a[i], a[0]
        heapify(a, 0, i)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이건 코드를 좀 열심히 봐야 이해가 가더군요. 일단 &lt;code class=&quot;highlighter-rouge&quot;&gt;heapify()&lt;/code&gt; 는 heap을 array로 표현했을 때 idx 위치에 있는 node의
left child, right child와 비교해서 더 셋 중 가장 큰 node를 parent 자리에 위치시키는 겁니다. 이걸 array의 뒤에서부터 해주면 아래에서 자리가 올바르지 않은 node 들이 쭉 올라와서 제자리를 찾으며 정렬이 됩니다.
그리고 두 번째 for문에서는 정렬된 heap에서 max 값인 root를 반복적으로 추출해서 array의 뒤에 위치시키는 겁니다.&lt;/p&gt;

&lt;p&gt;complete binary tree에서 left child가 &lt;code class=&quot;highlighter-rouge&quot;&gt;2*idx+1&lt;/code&gt;, right child가 &lt;code class=&quot;highlighter-rouge&quot;&gt;2*idx+2&lt;/code&gt;를 index로 가지는 것은 귀납법으로 증명 가능하며,
heapify를 &lt;code class=&quot;highlighter-rouge&quot;&gt;(n-1)//2&lt;/code&gt;부터 하는 이유는 해당 node가 바로 child를 가질 수 있는 마지막 node이기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Topological Sort&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Directed Graph에서 정점들의 선행 순서를 위배하지 않으면서 모든 정점을 나열하는 알고리즘입니다.
Scheduler처럼 작업의 순서가 정해져 있을 때 각각의 작업이 완료되어야 끝나는 문제에 주로 쓰입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;topological_sort():
    q = Queue()
    for i in range(n):
        if in_degree[n] == 0: 
	    q.enqueue(i)
    for i in range(n):
        if q.is_empty():
            error
        x = q.dequeue()
        answer[i] = x
        for j in adj[x]:
            in_degree[j] -= 1
            if in_degree[j] == 0:
                q.enqueue(j)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;BFS랑 비슷한데, inDegree를 이용하여 enqueue 합니다. 시간복잡도는 &lt;script type=&quot;math/tex&quot;&gt;O(V+E)&lt;/script&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Hashing&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hashing&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Hashing이란 Hash Function을 이용해 item의 index를 item의 key를 이용해 결정하는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Collision&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;간단하게 array length로 나눠 나머지를 index로 이용하는 방법이 있으며
서로 다른 item이 같은 위치로 배정되는 collision이 일어날 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linear Probing&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;collision이 일어난다면 empty spot을 찾을 때까지 선형 이동하여 해당 index로 이동시킵니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Search&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;hash function을 통해 index를 찾고 해당 key와 동일한 지 이동해가며 찾습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Delete&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;삭제를 할 때에는 해당 index를 빈 공간으로 만들지만 marking하여 원래 item이 있던 곳임을 표시합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Double Hashing&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;hash function 두 개를 사용해서 collision이 일어나면 hash2로 다음 spot을 찾습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Chained Hashing&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;collision이 일어나도 해당 index에서 linked-list를 형성하며 위치시킵니다.&lt;/p&gt;

&lt;p&gt;삽입/삭제/탑색의 시간복잡도가 사실 &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt; 은 아닌데 그렇다고 봐도 무방합니다…&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dynamic Array&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;처음엔 작은 길이의 array를 할당하여 사용하고, 해당 사이즈를 넘어가는 삽입이 일어나면 길이를 두 배로 늘린 array를 할당하여 item을 다 옮겨주길 반복합니다.&lt;/p&gt;

&lt;p&gt;amortized analysis를 통해 놀랍게도 삽입의 시간복잡도가 &lt;script type=&quot;math/tex&quot;&gt;(nO(1) + O(n))/(n+1) = O(1)&lt;/script&gt; 이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;String-related Algorithms&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;String Matching&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;주어진 긴 문자열(길이 m)에서 특정 문자열(길이 n)의 등장 위치를 찾는 알고리즘들입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Brute Force Algorithm&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;모든 상황을 다 검색한다는 의미로 더 크게 쓰이기도 하지만 string matching에서는 앞에서부터 차례대로 검색하는 것입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bruteforce():
    for i in range(len(text) - len(pattern) + 1):
        j = 0
        while j &amp;lt; len(pattern) and pattern[j] == text[i + j]:
            j += 1
        if j == len(pattern):
            print(i)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;시간복잡도는 &lt;script type=&quot;math/tex&quot;&gt;O((n - m + 1)m)&lt;/script&gt; 인데 보통 &lt;script type=&quot;math/tex&quot;&gt;n &gt;&gt; m&lt;/script&gt; 인 상황이 많으며 그럴 때는 &lt;script type=&quot;math/tex&quot;&gt;O(nm)&lt;/script&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rabin-Karp Algorithm&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Hashing을 이용한 알고리즘입니다.&lt;/p&gt;

&lt;p&gt;Rabin Fingerprint라는 hash function을 사용합니다.
alphabet의 길이를 d 라고 하고, pattern을 d-항식으로 두고 갑을 계산합니다.
그리고 Text의 subword에 같은 방법으로 값을 계산하여 비교하는 것입니다.&lt;/p&gt;

&lt;p&gt;하지만 이렇게 하면 hash값이 너무 커질 수 있으니 적당한 prime number를 사용해 modular 값을 이용합니다.
그리고 False-Positive를 피하기 위해 해시값이 같을 때 문자열을 직접 비교하고 결과에 추가합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rabin_karp():
    h = hash(pattern)
    for i in range(len(text) - len(pattern) + 1):
        if h == hash(text[i:i + len(pattern)]):
            j = 0
            while j &amp;lt; len(pattern) and pattern[j] == text[i + j]:
                j += 1
            if j == len(pattern):
                print(i)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 하면&lt;script type=&quot;math/tex&quot;&gt;O(nm)&lt;/script&gt; 입니다만, &lt;a href=&quot;https://en.wikipedia.org/wiki/Horner%27s_method&quot;&gt;Horner’s scheme&lt;/a&gt;을 사용하면 hash값이 한 step 전의 hash값으로 부터 &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt;에 계산하고,
hit의 경우가 엄청 큰 경우가 아니라면 &lt;script type=&quot;math/tex&quot;&gt;O(n + m)&lt;/script&gt; 에 가까워집니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Boyer-Moore Algorithm&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;브루트포스처럼 왼쪽에서 오른쪽을 패턴을 이동시키지만 문자 일치 검사는 패턴의 오른쪽부터 합니다.&lt;/p&gt;

&lt;p&gt;이 때 3가지의 Bad Character Heuristic을 가집니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;text의 character가 pattern 내에 없는 경우 pattern을 그 character 너머로 이동시킵니다.&lt;/li&gt;
  &lt;li&gt;text의 character가 pattern 내에 있을 경우 pattern 안의 가장 오른쪽의 character와 해당 character를 대치하도록 이동시킵니다.&lt;/li&gt;
  &lt;li&gt;아니면 한칸이동합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이렇게 해도 worst case의 경우 브루트포스와 같은 &lt;script type=&quot;math/tex&quot;&gt;O(nm)&lt;/script&gt; 을 가지지만 average case는 &lt;script type=&quot;math/tex&quot;&gt;O(n/m)&lt;/script&gt; 으로 줄일 수 있다고 합니다. 이 계산 증명은 아직 알아보지 않았습니다. 상대적으로 좋은 heuristic이기 때문에 속도가 더 빠르다고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;뿐만 아니라 Good Suffix Heuristic도 사용하는데, Pattern 내부에서 suffix가 prefix로 등장할 경우,
매칭이 되다가 miss가 나왔을 시 1칸만 움직이는 것이 아니라 prefix를 suffix가 매칭되던 위치로 이동시킬 수 있습니다. 이와 같은 경우를 고려하기 위해
Text를 훑기 전, Pattern의 miss가 나는 위치에 따라 몇 칸을 이동시켜야하는지 미리 계산해두고 사용하는 것입니다.&lt;/p&gt;

&lt;p&gt;두 Heuristic을 같이 사용하므로 둘 모두 고려하여 최대 이동거리를 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Edit Distance&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;“LewenStein distance”, 주어진 문자열 u, v가 얼마나 다른지 파악하는 것입니다. delete, insert, replace 3가지 operation을 기준으로  몇 번의 oepration을
통해 u를 v로 변환시키는지 d(u, v)로 표현합니다. rule은 여기 옮기지 않겠지만 dynamic programming으로 해결합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Trie&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Set of Strings을 위한 Data Structure 입니다.&lt;/p&gt;

&lt;p&gt;alphabet의 길이를 d라고 할 때, d-ary tree 구조를 가집니다.&lt;/p&gt;

&lt;p&gt;edge에 character가 label되었다고보고, 모든 정점은 해당 정점까지 path의 string을 의미합니다.&lt;/p&gt;

&lt;p&gt;구현 방식으로 array를 이용하여 d 길이의 array가 각 vertex를 의미하게 만드는 방법과
linked list를 이용하는 방법이 있습니다.&lt;/p&gt;

&lt;p&gt;공간복잡도는 string의 종류를 m이라 할 때 array를 이용하면 &lt;script type=&quot;math/tex&quot;&gt;O(md)&lt;/script&gt;, linked-list를 이용하면 &lt;script type=&quot;math/tex&quot;&gt;O(m)&lt;/script&gt; 입니다.&lt;/p&gt;

&lt;p&gt;탐색/삽입/삭제의 시간복잡도는 linked-list의 경우 outdegree를 전부 확인해야하므로 &lt;script type=&quot;math/tex&quot;&gt;O(md)&lt;/script&gt;, array는 &lt;script type=&quot;math/tex&quot;&gt;O(m)&lt;/script&gt;이 됩니다.&lt;/p&gt;

&lt;p&gt;Linked-list의 경우 edge에 길이가 1 이상인 string을 부여하여(compress paths) 효과적인 구조로 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Suffix Tree&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Trie와 비슷해보이지만 string(+ 끝을 뜻하는 “$”)의 모든 suffix의 집합을 이용하여 만든 tree입니다.
edge에는 string, node에는 index를 표시합니다. construct 시간복잡도와 공간복잡도는 &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt; 입니다.&lt;/p&gt;

&lt;p&gt;String Matching에 사용되는 경우 pattern(edge 중간에 끊길 수도 있습니다)을 찾고 해당 path에서 나오는 모든 leaf node의 index에 해당 pattern이 존재합니다.&lt;/p&gt;

&lt;p&gt;시간복잡도는 &lt;script type=&quot;math/tex&quot;&gt;O(n + m)&lt;/script&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Dynamic programming&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dynamic Programming&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;엄밀히 말하자면 알고리즘은 아니고 알고리즘 설계 기법입니다.
답을 구하기 위해서 했던 계산을 또 하고 또 해야하는 류의 문제(Optimal Substructure)를 위해 memoization을 통해 한번 계산한 결과를 메모리에 저장해 두었다가
꺼내 쓰는 것입니다. 대표적으로 피보나치 수열을 푸는 문제의 경우 시간복잡도를 &lt;script type=&quot;math/tex&quot;&gt;O(2^n)&lt;/script&gt; 에서 &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; 으로 줄일 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/tag/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D&quot;&gt;관련 문제&lt;/a&gt;를 풀고 몸에 익히는 것이 중요합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;pl&quot;&gt;PL&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Static scope and Dynamic scope&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Static Scope&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Static Scope는 우리가 접하는 대부분의 언어에서 사용되는 방식으로 function이 정의된 곳의 environment를 사용하는 것입니다. 아래의 dynamic scope가 어떻게 다른지만 보시면 되겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dynamic Scope&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;반면에 Dynamic scope는 function이 call 된 곳의 environment를 function이 사용합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{deffun {f p} n}
{with {n 5} {f 10}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;제 편의(;;)를 위해 수업에서 사용한 scheme 언어를 사용하면, 위와 같은 코드는 dynamic scope라면 &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;의 값이 함수 내에서도 사용되므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;을 return하고 static scope에서는 error를 뱉게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;First-order functions and First-class functions&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;First-order Functions&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f(x) = 1 + x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;C에서 함수를 정의하고 사용하는 방식을 생각하시면 됩니다. 그리고 아래의 first-class function을 보고 차이점을 이해합시다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;First-class functions&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f = λx. 1 + x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Python에서 함수를 괄호없이 불러서 변수에 저장하는 방식이나, Javascript에서 const로 함수를 정의하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;() =&amp;gt; ...&lt;/code&gt; 등의 문법을 사용하는 것을 예시로 들 수 있습니다.
C에서도 함수포인터를 이용하여 비슷한 효과를 낼 수 있지만 function이 first-class object로 취급되는 언어를 이용하면 후에 Higher-order function (ex. map())을 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Calling Convention&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Calling Convention&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;함수가 호출될 때, 메모리 공간 안에서는 함수 내부의 명령어를 실행하며 사용하기 위한 Stack Frame이 할당됩니다.
이 때 parameter가 어떤 방식으로 전달되는지 아래의 여러 방식이 있습니다. 실제 Calling Convention은 parameter 전달 방법 뿐만 아니라
전달 순서, return value 전달 방법, stack frame 정리 방법, 이렇게 4가지가 있지만 parameter 전달 방법만 다루겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Call by Value&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C에서는 사실상 모든 상황에 Call by Value가 이용됩니다. Java를 예로 들면 primitive type인 int, short, long, float, double, char, boolean에 대해서 적용되며, value를 복사하여 함수의 인자로 사용합니다.
swap 함수를 사용할 때 cadll by value가 적용되면 swap이 되지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Call by Reference&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;value를 복사하는 것이 아닌 해당 variable을 직접 전달하는 것입니다. C에서 변수에 &amp;amp;를 붙인 채 함수를 정의할 때와 같은 효과를 가집니다.
Java에서 reference type인 Array, Class에 대해 적용됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Call by Address&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C에서 포인터를 이용해 주소를 전달하는 것입니다. pointer를 쓰지 않는 언어에서는 언급되지 않는 것 같습니다.. 이 부분은 확실하게 확인하지 못했습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Call by Assignment&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Python의 경우 모든 상황에 Call by Assignment가 사용됩니다. 먼저 int, float, str, tuple은 immutable object, 그리고 list, dict, set은 mutable object로 분류하는데,
mutable object는 call by reference를 적용시키고 immutable object의 경우 처음에는 call by reference를 이용하다 값이 변경되면 call by value로 전환됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Call by Name&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Call by name을 이용할 경우 argument는 function call 즉시 계산되는 것이 아니라 필요시에 계산되게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Lazy Evaluation&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lazy Evaluation&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def some_function(x, y):
    return x + 1

some_function(3, 3 + 2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같은 코드를 실행한다고 합시다. strict evaluation에서는 some_function이 call 되는 순간 3 + 2 가 계산되어야 하지만 lazy evaluation에서는 해당 parameter 값이 필요할 때에 계산합니다.
고로 위 코드에서는 y가 필요없으므로 계산하지 않고 더 높은 성능을 보일 수 있습니다.&lt;/p&gt;

&lt;p&gt;위의 예시는 정말 간단한 경우이지만, list의 head 값을 알기 위해 quick sort를 사용할 시에 head 값이 결졍되는 대로 나머지 계산은 하지 않기도 하며, python의 if문에 여러 condition을 부여했을 때 검증이 필요없어진 condition은
evaluation 하지 않고, infinite list에 대해서도 모든 item의 계산이 필요하지 않을 때 handling이 가능해집니다.&lt;/p&gt;

&lt;p&gt;Lazy Evaluation이 적용될 경우 해당 parameter가 함수 내의 여러 번 사용되는 경우 evaluation이 여러 번 일어나는 것을 예방하기 위해 caching 이 일어납니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Tail recursion and fibonacci programming&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tail Recursion&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def sum(n):
    if n == 0:
        return 0
    else:
        return n + sum(n - 1)


sum(4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같은 코드를 실행한다고 합시다. 그럼 코드의 실행은 이런 식으로 전개됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sum(4)
4 + sum(3)
4 + (3 + sum(2))
4 + (3 + (2 + sum(1)))
4 + (3 + (2 + (1 + sum(0))))
4 + (3 + (2 + (1 + 0)))
4 + (3 + (2 + 1))
4 + (3 + 3)
4 + 6
10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 식으로 전개되며 stack frame은 sum n개가 쌓임을 볼 수 있습니다. 함수 내에서 두 번의 호출이 일어나는 fibonacci 함수는 &lt;script type=&quot;math/tex&quot;&gt;2^n&lt;/script&gt; 개의 stack frame이 쌓입니다.&lt;/p&gt;

&lt;p&gt;반면에 아래와 같이 함수를 정의한다고 합시다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def sum(n, acc):
    return 0 if n == 0 else sum(n - 1, acc + n)


sum(4, 0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 정의한다면 if문이 먼저 검증되고 sum() 함수가 호출되며 return 값이 돌아온 이후에 해야할 operation은 그대로 return 하는 것밖에 남지 않습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sum(4, 0)
sum(3, 4)
sum(2, 7)
sum(1, 9)
sum(0, 10)
10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;코드의 실행은 이런 식으로 전개되며 됩니다. javascript engine이나 jvm, cpython은 기본적으로 tail recursion optimization을 지원하지 않아 stack-frame이 4개 그대로 생성되지만
gcc나 functional programming language는 tail recursion optimization을 지원하여 return 값을 받은 후 추가적으로 해야할 operation이 없는 경우 stack-frame을 덮어씌워 새로 생성하지 않고
recursion을 iteration으로 변환합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Garbage collection (GC)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Garbage Collection (GC)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C나 C++ 같은 low-level(엄밀히 말하자면 C++는 High level 입니다만) language는 변수선언, &lt;code class=&quot;highlighter-rouge&quot;&gt;malloc()&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;free()&lt;/code&gt;를 통해 메모리 할당과 해제가 직접 이루어집니다.
반면에 Python이나 Javascript 같은 high-level language는 Garbage Collector가 자동으로 활동하며 메모리 해제를 해줍니다.&lt;/p&gt;

&lt;p&gt;중요한 점은 GC가 할당된 메모리에 대해 특정 시점에서 필요유무를 판단하고 해제하는 방식입니다.&lt;/p&gt;

&lt;p&gt;CPython에서는 Reference Counting을 기반으로 한 GC가 돌아간다고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Reference Counting&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;모든 record(data를 담은 structure)에 대해 초기에 count 0를 부착합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;해당 record를 가르키는 pointer(이또한 record)가 생성될 때 record의 count에 1을 더합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;해당 record를 가르키는 pointer가 다른 곳을 가르키거나 사라지면 count에 1을 뺍니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;record의 count가 0이 되면 해당 record가 가르키는 record들의 count에서 모두 1을 빼고 기존의 record를 free 해줍니다. (root record는 제거하지 않습니다.)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 root record란 모든 global variable들과 현재 실행되는 함수 내의 모든 local variable을 뜻합니다. 얘네들은 free 되지 않으므로 위 알고리즘이 성립할 수 있습니다.&lt;/p&gt;

&lt;p&gt;명시적이든 암시적이든 A라는 memory를 통해 B라는 memory를 통해 B라는 memory에 접근할 수 있다면 그것이 명시적이든 암시적이든 B는 A에 의해 reference 된다고 정의합니다.
예를 들어 Javascript object는 prototype을 암시적으로 참조하죠. 그리고 기존의 Javascript object 뿐만 아니라 function scope도 포괄됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Limitations&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Cycle이 발생할 경우 free 해줄 수 없습니다. 실제로 IE6, 7은 이 reference counting algorithm을 이용하며 다음과 같은 메모리 누수가 발생합니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// div object는 EventHandler인 onclick 속성을 통해 참조되며, EventHandler scope에도 div object가 있으므로 cycle이 발생합니다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;div&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onclick&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;count를 유지하는 것은 시간을 잡아먹습니다.&lt;/p&gt;

&lt;p&gt;locality가 좋지 않답니다.&lt;/p&gt;

&lt;p&gt;free list를 만들어 available memory를 track 해줘야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mark &amp;amp; Sweep Garbage Collection&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;모든 record를 흰색으로 칠합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;root로 인해 reference된 record들은 회색으로 칠합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;아래 과정을 회색 record가 없어질 때까지 반복합니다.
    &lt;ul&gt;
      &lt;li&gt;회색 record r을 고릅니다.&lt;/li&gt;
      &lt;li&gt;r이 가르키는 모든 흰색 record를 회색으로 칠합니다.&lt;/li&gt;
      &lt;li&gt;r을 검은색으로 칠합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;root를 제외한 모든 흰색 record를 free합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Limitations&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Cycle에 의해 생기는 문제는 해결하지만 Reference Counting의 나머지 문제점은 해결하지 못합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cost가 heap 전체에 비례하게 됩니다.&lt;/li&gt;
  &lt;li&gt;Locality가 좋지 않습니다.&lt;/li&gt;
  &lt;li&gt;free list를 유지해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Two-Space Copying Collectors&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;to-space&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;from-space&lt;/code&gt; 두 메모리 공간으로 나누어 이용합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Allocator:
    &lt;ul&gt;
      &lt;li&gt;memory를 &lt;code class=&quot;highlighter-rouge&quot;&gt;to-space&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;from-space&lt;/code&gt;로 파티션합니다.&lt;/li&gt;
      &lt;li&gt;메모리 할당을 &lt;code class=&quot;highlighter-rouge&quot;&gt;to-space&lt;/code&gt;로만 합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Collector:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;to-space&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;from-space&lt;/code&gt;의 record를 스왑해줍니다.&lt;/li&gt;
      &lt;li&gt;Mark &amp;amp; Sweep에서 회색으로 칠하는 역할을 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;from-space&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;to-space&lt;/code&gt;로 보내줍니다.&lt;/li&gt;
      &lt;li&gt;회색 record를 고르는 것은 &lt;code class=&quot;highlighter-rouge&quot;&gt;to-space&lt;/code&gt;에서만 시행합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Lambda algebra&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lambda Algebra, Lambda Function&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이는 Anonymous Function이면서 First-class Function을 부르는 말입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Type System&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Type system and type checking, strong/weak type, dynamic/static type checking&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Type System&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Type System은 variable, expression, function, module 등 프로그램의 구성품들에 Type을 부여하는 것입니다.
기본적으로 Type System의 목적은 버그를 Runtime 이전에 미리 포착하고 방지하기 위함입니다. (동적 타입 언어는 Runtime에 Type Check가 이루어집니다.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Polymorphic Types&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Typecheck 중 &lt;code class=&quot;highlighter-rouge&quot;&gt;(alpha -&amp;gt; alpha)&lt;/code&gt; 와 같은 타입은 어떠한 타입도 될 수 있는 alpha를 받고 해당 타입을 return한다는 뜻입니다.
따라서 명확히 적으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;∀ alpha (alpha -&amp;gt; alpha)&lt;/code&gt; 이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Statc Type / Dynamic Type Checking&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Static Type Checking Language에서는 Typecheck가 compile time에 이루어지며 Dynamic type에서는 runtime에 이루어집니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Strong Typed / Weak Typed Language&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Strong Typed Language 에서는 암묵적 형변환을 허용하지 않습니다.&lt;/p&gt;

&lt;p&gt;근데 제가 찾다보니 이 부분은 사람들마다 생각하는게 다른 것 같은데(;;) 이건 각잡고 다시 알아봐야겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Type Soundness / Type Completeness&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Type Soundness: 모든 well-typed program은 error를 만들지 않는 올바른 program 입니다. (no false negative)&lt;/li&gt;
  &lt;li&gt;모든 올바른 program은 type-check에 통과합니다. (모든 ill-typed program은 incorrect program 입니다. =&amp;gt; no false positive)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Compiler, interpreter&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Compiler&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Program을 통해 program을 만들어냅니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Interpreter&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Program을 통해 result를 만들어냅니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Compiled Language&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Runtime 이전에 Assembly Language 등으로 변환되는 언어입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Interpreted Language&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Runtime 중에 Instruction 단위로 interpret 되는 언어입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;network&quot;&gt;Network&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Packet Switching vs Circuit Switching&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;서킷 스위칭은 대표적으로 전화에서 쓰이는 데이터 전달 방법입니다. 전화는 시간단위로 요금을 청구하며 실시간성이 중요하기 때문에,
중간에 누군가 그 회선에 끼어들면 안되며 서킷 전체를 독점하며 속도도 일정하게 됩니다.&lt;/p&gt;

&lt;p&gt;패킷 스위칭은 데이터를 패킷단위로 쪼개서 보내는 것이며, 서킷을 독점하지 않고 공용선을 이용합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;How Internet works?&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Internet은 IP(Internet Protocol), TCP(Transport Control Protocol) 등 프로토콜에 합의된 방식으로
Packet을 주고 받는 거대한 네트워크입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What’s a protocol&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로토콜은 컴퓨터가 네트워크 내에서 어떤 방식으로 통신해야하는지 정한 규칙의 집합입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What’s a packet&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Internet으로 전달되는 데이터를 Message라고 할 때, Message가 전송될 때, 먼저 해당 Message를 packet이라는 조각으로 잘게 나눕니다.
이 패킷들은 서로 독립적으로 전송되며 IP(Internet Protocol)은 어떤식으로 패킷화되어야 하는지 명시하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What’s a packet routing network&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Packet Routing Network란 패킷을 시작 지점 컴퓨터로부터 도착 지점 컴퓨터까지 전달하는 네트워크입니다.
인터넷은 수많은 Router들로 이루어져 있으며 각 router의 역할은 패킷을 출발지점으로부터 목적지로 옮기는데에 있습니다.
패킷은 도착지까지 도달하기 위해 다수의 Router를 지나게 됩니다.&lt;/p&gt;

&lt;p&gt;한 Router로부터 다음 Router까지 이동하는 것을 Hop이라고 부릅니다.
Internet Protocol에 의하면 Router는 packet의 header에 address를 명시하여 보내야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Where did these Internet routers come from? Who owns them?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1960년대 ARPANET이 인터넷의 시초가 된 이후 ISP(Internet Service Providers)가 router들을 네트워크 내로 추가하였습니다.
인터넷 라우터의 주인이 되는 개인은 없습니다. ARPANET 이후 정부기관, 대학, AT&amp;amp;T와 같은 기관이 router를 점진적으로 추가하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Do the packets always arrive in order? If not, how is the message reassembled?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Internet Protocol은 패킷이 목적지에 도달한다는 것에 대해 확신을 제공하지 않습니다. Packet Loss 가 일어날 수 있습니다.
Transmission Control Protocol은 packet loss를 retransmission으로 해결합니다. 도착지에서 출발지점으로 ACK 패킷을 보내게 합니다.
도착지에서 누락된 패킷이 있음을 인식하면 출발지에 retransmission을 요청합니다. 이 과정은 사실 더 복잡한데 아래에서 차근차근 다루겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What do these Internet addresses look like?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 주소들은 IP 주소로 불리며 2가지 표준이 있습니다.&lt;/p&gt;

&lt;p&gt;IPv4는 예를 들어 &lt;code class=&quot;highlighter-rouge&quot;&gt;212.78.1.25&lt;/code&gt;와 같이 생겼으며 이는 IPv4가 &lt;script type=&quot;math/tex&quot;&gt;2^{32}&lt;/script&gt;개의 주소값을 허용하기 때문이며,
새로 제시된 IPv6 표준에서는 주소가 &lt;code class=&quot;highlighter-rouge&quot;&gt;3ffe:1893:3452:4:345:f345:f345:42fc&lt;/code&gt;와 같이 생겼으며 &lt;script type=&quot;math/tex&quot;&gt;2^{128}&lt;/script&gt;개의 주소값을 허용합니다.
2014년 구글에 의하면 당시 IPv6 트래픽은 전체의 3% 밖에 되지 않았다고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How can there be over 8 billion networked devices on the Internet if there are only about 4 billion IPv4 addresses?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이유는 public IP address와 private IP address가 존재하기 때문입니다. Local Network로 접속하는 기기들은 같은 public IP address를 공유합니다.
그리고 이 local network 내에서 기기들은 서로 다른 private IP address로 구별됩니다.
일반적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.xx&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;172.16.x.x&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;10.x.x.x&lt;/code&gt; 등의 구조를 가집니다. 그리고 이 private IP address는
Dynamic Host Configuration Protocol (DHCP)에 의해 할당됩니다.&lt;/p&gt;

&lt;p&gt;예를 들어 같은 local network 내에 있는 노트북과 스마트폰으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;www.google.com&lt;/code&gt;에 요청을 보낼 시, 모뎀을 떠나는 패킷은 패킷 헤더에 기기에 배정되는 포트번호를 담고,
응답이 돌아왔을 시 그 포트번호를 이용해 올바른 기기에게 응답을 전달해줍니다.&lt;/p&gt;

&lt;p&gt;private IP address를 public IP address에 매핑하는 프로토콜은 NAT(Network Address Translation) protocol을 통해 이루어집니다.&lt;/p&gt;

&lt;p&gt;이 관점에서 IP address는 기기에 특수하게 부여되지 않은 것으로 보입니다. 기기에 유니크하게 부여되는 주소는 MAC address 입니다.
MAC address는 기기의 life를 통틀어 하나로 특정됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How does the router know where to send a packet? Does it need to know where all the IP addresses are on the Internet?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;라우터는 IP 주소가 어디를 가르키는지 전부 알지는 못합니다. 오직 Outbound Link 라 불리는 이웃한 주소만 알고 있죠.&lt;/p&gt;

&lt;p&gt;IP address는 Network Prefix와 Host Identifier 두 부분으로 나누어 집니다.&lt;/p&gt;

&lt;p&gt;예를 들어 &lt;code class=&quot;highlighter-rouge&quot;&gt;129.42.13.69&lt;/code&gt;는 아래와 같이 나누어집니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Network Prefix: 129.42
Host Identifier: 13.69
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;대학, 기관, ISP(Internet Service Provider) 등 큰 단위의 단일 위치로 연결되는 라우터들은 모두 같은 Network Prefix를 가집니다.&lt;/p&gt;

&lt;p&gt;모든 라우터는 &lt;code class=&quot;highlighter-rouge&quot;&gt;129.42.*.*&lt;/code&gt; 형식의 IP address를 같은 곳으로 먼저 보내게 되는것이죠. 이 방법으로 라우터가 기억해야할 주소는 확 감소됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;If a new router is added to the Internet how does it know how to handle packets for all these network prefixes?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;새로 설치된 라우터가 패킷을 어디로 라우트해야할 지 모르는 경우가 나올 수 있습니다. 그럴 때는 라우터가 이웃하는 라우터들에게
해당 패킷을 전송해야할 곳의 정보를 알고 있는지 쿼리를 보냅니다. 그리고 이웃한 라우터들은 정보를 파악하여 시작점이었던 라우터에게 되돌려 줍니다.
그리고 라우터는 그 정보를 저장하여 다음에 바로 전송할 수 있도록 준비합니다. 이 알고리즘은 원래 더 복잡한데 생략합니다.
이 방법으로 라우터는 Routing Table이라는, Network Prefix와 Outbound Link를 묶은 정보들을 가집니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How do networked computers figure out IP addresses based on domain names?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;컴퓨터는 &lt;code class=&quot;highlighter-rouge&quot;&gt;www.google.com&lt;/code&gt;과 같은 domain name을 이용해 IP address를 얻어내야 합니다.
이는 Domain Name System(DNS)를 이용해 이루어집니다.&lt;/p&gt;

&lt;p&gt;IP address를 얻기 위해 컴퓨터는 먼저 local DNS cache를 참조합니다. local DNS cache에는 최근 방문했던 domain name과 IP address가 저장되어 있습니다.
캐시에서 찾아내지 못했거나, 해당 IP address 기록이 만료되었다면(TTL: Time To Live가 처음 요청을 받아올 때 적혀옵니다.) ISP의 DNS server로 요청을 보냅니다.
같은 방식으로 ISP의 DNS server에서도 IP address를 구하지 못하면 Root Name Server로 요청을 보냅니다.
Root Name Server는 해당 도메인의 IP를 전부 갖고 있진 않고 주소 맨 오른쪽에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;.com&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;.net&lt;/code&gt; 같은 Top-level Domain을 보고 해당 도메인들을 관리하는 서버의 주소를 알려줍니다.
그를 통해 ISP는 해당 Top-level Domain 관리 서버로 요청을 보내 IP address를 받아옵니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How do applications communicate over the Internet?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Internet은 몇 개의 층으로 나눌 수 있습니다. OSI 7 Layer나 TCP/IP 4 Layer가 있지만 여기서는 후자의 구조를 거론하겠습니다.
Internet은 Internet Network Layers로 나뉘며 Link Layer, Internet Layer, Transport Layer, Application Layer가 있습니다.
이들이 Layer라 불리는 이유는 각 레이어가 다른 레이어 위로 쌓아 올려졌기 때문이며, 각 레이어는 해당 레이어 아래 레이어들의 기능을 상세히 고려하지 않고도 모두 포함하며 작동합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/q0115643/my_blog/master/assets/images/interview/0.png&quot; alt=&quot;&quot; width=&quot;350px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Internet Application은 Application Layer에 기반하여 작동하며 그 아래 레이어들의 기능을 자세히 고려하지 않아도 됩니다.
예를 들어, 어플리케이션이 네트워크 다른 어플리케이션과 TCP를 이용하여 통신할 때는 Socket이라는 구조를 이용하며, 이는 packet routing과 re-assembling의 복잡한 구성에 대한 걱정을 없애줍니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What do each of these Internet Layers do?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Link Layer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;가장 낮은 레벨의 Link Layer는 “physical layer”라고도 불리며 데이터를 bit 단위에서 케이블이나 wifi signal을 통해 어떻게 전달되는지를 고려합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Internet Layer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Link layer 위에는 Internet Layer가 위치합니다. Internet Layer는 패킷을 목적지로 라우팅하는 것을 고려합니다.
앞의 언급된 Internet Protocol이 이 레이어에서 사용합니다. Internet Protocol에 따라 network load나 outage를 따져 패킷의 목적지를 동적으로 조정하고 reroute합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Transport Layer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그 위로는 Transport Layer가 있습니다. 이 레이어에서는 아래의 Internet과 Link Layer에서 data 전송이 완전히 되지 않을 시를 위해 보정하는 작업이 일어납니다.
주로 Transmission Control Protocol(TCP)에 따라 packet loss에 반응하여 해당 packet을 재전송합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Application Layer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;맨 위에는 Application Layer가 있습니다. 패킷 통신 관련 복잡한 작업은 아래 레이어에서 해주며 이 레이어에서는 그를 이용하여 인터넷의 다른 어플리케이션들과 통신합니다.
이곳에는 HTTP Protocol이 적용되어 웹 브라우저와 웹 서버가 어떻게 상호 작용하는지 정해집니다.
email client와 관련된 작업에는 IMAP protocol이, File-downloading client와 file-hosting server 사이의 통신에는 FTP protocol이 적용됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What’s a client versus a server?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Client와 Server는 모두 인터넷을 통해 통신하는 어플리케이션입니다.
그 중 Client는 “유저와 더 가까운 편”이라고 말할 수 있습니다. Web browser나 email client, smart phone app 등을 통해 유저를 직접 상대하는 어플리케이션이죠.
그리고 Sever는 remote computer에서 작동하며 client가 필요에 의해 통신하는 어플리케이션입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How can sensitive data like credit cards be transmitted securely over the Internet?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;초기의 인터넷에서는 서로 다른 위치에서 router와 link를 통해 네트워크 안에서 연결되어있음을 확인하면 그것만으로 충분했습니다.
하지면 이젠 인터넷의 크기가 커지고, 라우터가 늘어났습니다. 통신을 통해 거치는 라우터의 수가 늘어난다는 것은 취약한 지점이 많아짐을 뜻하고,
더 나아가 WiFi와 같이 무선통신이 이용되면서 해커들이 패킷을 허공에 뿌려서 공격할수도 있게 되었습니다.&lt;/p&gt;

&lt;p&gt;이전의 구조만으로는 네트워크 연결이 안전한지 장담할 수 없게 되었고 그에 대한 해답으로 SSL/TLS를 통한 encryption과 authentication이 생겼습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is SSL/TLS?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SSL은 Secured Sockets Layer를, TLS는 Transport Layer Security를 뜻합니다.
SSL은 Netscape에 의해 1994년 생겼으며 시간이 지나 수정을 거쳐 TLS로 이름이 정정되어 현재는 SSL/TLS라는 명칭으로 합쳐서 불립니다.&lt;/p&gt;

&lt;p&gt;SSL/TLS는 선택적으로 사용되어 Transport Layer와 Application Layer 사이에 위치합니다.
SSL/TLS는 민감한 정보를 encryption과 authentication을 통해 보호합니다.&lt;/p&gt;

&lt;p&gt;Encryption은 client가 server로 보내는 TCP connection을 요청을 암호화하는 것을 말합니다.
message가 packet으로 나뉘기 전에 일어나기에, 해커가 packet을 가로챈다해도 기존의 message를 파악할 수 없게 됩니다.&lt;/p&gt;

&lt;p&gt;Authentication은 client가 server로 보이는 녀석을 믿을 수 있는지 판단하는 것입니다.
이를 통해, client와 server 사이에서 악의적인 간섭을 일으키는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Man-in-the-middle_attack&quot;&gt;Man-in-the-middle attack&lt;/a&gt;을 막을 수 있습니다.&lt;/p&gt;

&lt;p&gt;SSL이 적용된 웹사이트는 &lt;code class=&quot;highlighter-rouge&quot;&gt;http&lt;/code&gt;가 아닌 &lt;code class=&quot;highlighter-rouge&quot;&gt;https&lt;/code&gt; 프로토콜을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How does SSL authenticate the identity of a server and encrypt their communication?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SSL은 Asymmetric Encryption과 SSL Certificate를 이용합니다.&lt;/p&gt;

&lt;p&gt;Asymmetric Encyption은 소수로 이루어진 public key와 private key를 이용합니다.
private key는 decryption, public key는 encryption에 이용되며
“Asymmetric”인 이유는 Symmetric encryption과 달리 encryption과 decryption에 이용되는 key의 값이 다르기 때문입니다.&lt;/p&gt;

&lt;p&gt;SSL certificate은 public key를 내장한 digital document입니다. SSL certificate는 CA(certificate authority: 인증기관)을 통해 발급됩니다.&lt;/p&gt;

&lt;p&gt;Client가 SSL-encrypted connection을 서버에 요청할 시, 서버는 SSL certificate(인증서)를 client로 먼저 보냅니다.
그리고 client는 SSL certificate을 확인하여 아래 사항들을 확인합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인증서가 해당 서버를 담고 있는지,&lt;/li&gt;
  &lt;li&gt;인증서가 믿을 수 있는 CA를 통해 발급되었는지,&lt;/li&gt;
  &lt;li&gt;만료되지 않았는지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그 후 client는 인증서의 public key를 이용해 temporary secret key를 만들어 server로 보냅니다.
이제 server는 private key를 이용해 해당 secret key를 해석하며 양쪽은 secret key를 이용해 secret key의 기간이 만료될 때까지 encryption과 decryption을 하며 패킷을 주고 받습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What happens if a hacker intercepts an SSL-encrypted session?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 해커가 client와 server 사이 message를 가로챈다면 SSL certificate과 temporary secret key를 볼 수 있지만
private key가 없으므로 secret key를 해석할 수 없으며 그러므로 message를 해석할 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Summary&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인터넷은 탈중앙화된 컴퓨터 네트워크를 목적으로 개발된 1960년대 ARPANET로부터 시작되었습니다.&lt;/li&gt;
  &lt;li&gt;물리적으로 인터넷은 wire, cable, radio signal을 이용해 bit를 전달하는 컴퓨터의 집합입니다.&lt;/li&gt;
  &lt;li&gt;인터넷은 각각 더 작은 문제들을 해결하는 여러 개의 레이어로 구성됩니다.&lt;/li&gt;
  &lt;li&gt;서로 다른 레이어에서 인터넷과 어플리케이션이 어떻게 작동하는지 기술하는 HTTP, IMAP, SSH, TCP, UDP, IP 등의 프로토콜들이 있습니다.
이 관점에서 인터넷은 컴퓨터와 프로그램이 네트워크를 이루기 위해 어떻게 행동하는지 정한 양식의 집합입니다.&lt;/li&gt;
  &lt;li&gt;인터넷이 거대해지고 WiFi, 전자 상거래가 생기며 보안을 위해 SSL/TLS가 개발되었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;UDP, Handshake, HTTP&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Difference between TCP and UDP&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Transport Layer에 사용되는 Transport Protocol에는 TCP(Transmission Control Protocol) 뿐만 아니라 UDP(User Datagram Protocol)도 사용될 수 잇습니다.
TCP는 신뢰성이 있는 연결을 지향하며 UDP(User Datagram Protocol)는 빠른 전송을 지향합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UDP (User Datagram Protocol)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Datagram은 packet에 비해 추상적인 개념으로 message를 뜻합니다. 이름에 굳이 Datagram이 들어갔는지 잘 모르겠습니다만 UDP도 packet을 이용해 통신합니다.&lt;/p&gt;

&lt;p&gt;UDP에서는 TCP와 달리 비연결형 프로토콜로 3-way handshaking과 같은 연결 설정 없이 전송이 이루어집니다.
UDP헤더의 checksum을 이용해 최소한의 오류만 검출하며 신뢰성이 낮지만 TCP보다 속도가 빠릅니다.
때문에 신뢰성보다 연속성이 중요한 streaming에 자주 사용됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TCP (Transmission Control Protocol)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;TCP에서는 보낸 데이터가 확실히 상대방에게 전달이 잘 되었는지 확인하는 과정이 존재합니다.
전송 순서와 수신 여부를 보장하며 1:1 통신으로 이루어지고 UDP에 비해 속도가 느립니다.&lt;/p&gt;

&lt;p&gt;먼저 연결 설정으로 3-Way Handshaking 과정을 통해 목적지와 수신지를 확실히 하여 정확한 전송을 보장합니다. 연결 해제 시에는 4-way handshaking(teardown) 과정을 거칩니다.&lt;/p&gt;

&lt;p&gt;flow-control: 상대방의 buffer overflow를 막기 위해 데이터 처리 속도가 조절됩니다.&lt;/p&gt;

&lt;p&gt;congestion-control: 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지합니다.&lt;/p&gt;

&lt;p&gt;full-duplex: 전송이 양방향으로 동시에 일어날 수 있습니다.&lt;/p&gt;

&lt;p&gt;point-to-point: 각 연결이 정확히 2개의 종단점을 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3-Way Handshake&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/q0115643/my_blog/master/assets/images/interview/1.png&quot; alt=&quot;&quot; width=&quot;450px&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;클라이언트는 서버에 접속을 요청하는 SYN(x) 패킷을 보냅니다.&lt;/li&gt;
  &lt;li&gt;서버는 클라이언트의 요청인 SYN(x)를 받고 클라이언트에게 요청을 수락한다는 ACK(x+1)과 SYN(y)가 설정된 패킷을 보냅니다.&lt;/li&gt;
  &lt;li&gt;클라이언트는 서버의 수락 응답인 ACK(x+1)와 SYN(y) 패킷을 받고 ACK(y+1)를 서버로 보내며 ESTABLISHED 상태가 됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4-Way Teardown&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/q0115643/my_blog/master/assets/images/interview/2.png&quot; alt=&quot;&quot; width=&quot;450px&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;클라이언트는 연결을 종료하겠다는 FIN(x) 패킷을 전송합니다.&lt;/li&gt;
  &lt;li&gt;서버는 FIN(x)를 받고 ACK(x+1)을 보냅니다. 미리 전송되었던 데이터를 모두 받기 때까지 서버는 잠시 CLOSE_WAIT 상태로 머무릅니다.&lt;/li&gt;
  &lt;li&gt;시간이 지난 후 서버는 FIN(y) 패킷을 보냅니다.&lt;/li&gt;
  &lt;li&gt;클라이언트는 FIN(y)를 받고 ACK(y+1)를 보내고 잠시 기다립니다. 서버는 ACK(y+1)를 받고 CLOSED되며 클라이언트또한 시간이 지난 후 CLOSED됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What are HTTP methods? List all HTTP methods that you know, and explain them.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HTTP란 Hyper Text Transfer Protocol의 두문자어로, application layer에서 어플리케이션이 데이터를 주고받기 위해 설정된 프로토콜입니다.&lt;/p&gt;

&lt;p&gt;HTTP에 맞추어 이루어지는 요청에는 아래와 같은 메소드들이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GET&lt;/code&gt; 메소드는 특정 리소스의 표시를 요청합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;GET&lt;/code&gt;을 사용하는 요청은 오직 데이터를 받기만 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt; 메소드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;GET&lt;/code&gt; 메소드의 요청과 유사한 응답을 요구하지만, 응답 본문을 포함하지 않습니다.
헤더 정보 이외에는 어떤 데이터도 보내지 않으며 웹 서버의 다운 여부 점검(Health Check)나 웹 서버 정보(ex. version) 등을 얻기 위해 사용될 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;POST&lt;/code&gt; 메소드는 서버에 데이터를 보내기 위해 쓰입니다. customer info, 파일 업로드 등이 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PUT&lt;/code&gt; 메소드는 타겟 리소스를 제출하는 데이터로 완전 교체합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DELETE&lt;/code&gt; 메소드는 타겟 리소스를 제거합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CONNECT&lt;/code&gt; 메소드는 URI(Uniform Resource Identifier)로 인식된 서버로의 연결을 맺습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OPTION&lt;/code&gt; 메소드는 타겟 리소스를 위한 communication option 설명을 얻습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TRACE&lt;/code&gt; 메소드는 타겟 리소스의 경로를 따라 메시지 loop-back 테스트를 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PATCH&lt;/code&gt; 메소드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;PUT&lt;/code&gt;과 유사하지만 여기서는 전체를 교체하지 않고 일부를 변경합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TCP/IP 에서의 Keep-Alive&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두 소켓간 아무런 통신도 하지 않는 상태가 된지 어느 정도 시간이 지난 후 payload가 없는 패킷을 health-check 용도로 주기적으로 보내는 것입니다.
반응이 없으면 접속을 끊으며, 이를 사용하는 주된 이유는 종단 시스템 중의 하나가 다운될 때 발생할 수 있는 한쪽만 열린 연결 상태를 정리하기 위함입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP 에서의 Keep-Alive&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HTTP는 본디 종단의 연결상태를 유지하지 않지만 keepalive 설정을 사용하면 유지하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;REST, RESTful&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;REST (Representational State Transfer)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HTTP URI를 통해 리소스를 명시하고, HTTP Method를 통해 해당 리소스에 대한
CRUD Operation을 적용하는 것을 의미합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CRUD: Create, Read, Update, Delete 를 묶는 약어로 데이터베이스에 해당되는 용어입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉 REST는 Resource Oriented Architecture로, 리소스가 있고 HTTP 메소드를 통해 리소스를 처리하도록 설계된 아키텍쳐를 의미합니다.
웹 사이트의 이미지, 텍스트, DB 내용 등 자원에 고유한 ID인 HTTP URI를 부여합니다.&lt;/p&gt;

&lt;p&gt;최근의 서버 프로그램은 다양한 브라우저와 안드로이드, 아이폰과 같은 모바일 디바이스와도 통신할 수 있어야 하며,
REST 구조와 범용성은 이를 효과적으로 실현해줍니다.&lt;/p&gt;

&lt;p&gt;REST API란 REST 기반으로 구현한 API를 말합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RESTful&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;RESTful은 일반적으로 REST 아키텍쳐를 구현하는 웹서비스를 나타내기 위해 사용되는 용어입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Proxy, CORS&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Proxy&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프록시는 웹 클라이언트의 요청 URI를 클라이언트에서 서비스의 서버로 직접 보내는 것이 아닌 프록시 서버로 요청하게 하여
중계기로서 대리로 통신을 수행하는 기능을 가르킵니다.&lt;/p&gt;

&lt;p&gt;프록시 서버를 이용하는 목적은 주로 두 가지가 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;프록시 서버를 사용하여 고객이 프록시서버를 통해 웹서핑을 하도록 만들게 되면, 프록시서버에서 자주 가는 웹사이트에 대한 캐시를 쌓아놓고
좀 더 빠르게 웹서핑을 가능하게 하는 이점이 있습니다.&lt;/li&gt;
  &lt;li&gt;익명성 혹은 막혀있는 웹사이트를 우회하여 접속할 수 있기에 내부 네트워크 및 방화벽으로 인해 P2P 사이트, 한국 IP를 막아놓은 사이트 등에 접속할 수 있는 경우가 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CORS (Cross Origin Resource Sharing)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HTTP 요청은 기본적으로 Cross-Site HTTP Request가 가능합니다.&lt;/p&gt;

&lt;p&gt;다시 말해, &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 태그로 다른 도메인의 이미지 파일을 가져오거나, &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;link&amp;gt;&lt;/code&gt; 태그로 다른 도메인의 CSS를 가져오거나,
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그로 다른 도메인의 Javascript 라이브러리를 가져오는 것이 모두 가능합니다.&lt;/p&gt;

&lt;p&gt;하지만 스크립트 내에서 생성된 요청는 Same-Origin Policy를 적용 받기 때문에 Cross-origin HTTP 요청이 불가능합니다.
AJAX가 널리 사용되면서 스크립트에서 생성되는 요청에도 Cross-origin HTTP 요청이 가능해야 한다는 요구가 늘어나 W3C에서 제시한 것이
바로 CORS입니다. 모던 브라우저들은 cross-origin HTTP 요청의 위험성을 완화시키기 위해 (XMLHttpRequest와 같은) API 컨테이너 내에서 CORS를 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Domain 입력부터 화면이 나타날 때까지&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The process from the time you type in &lt;code class=&quot;highlighter-rouge&quot;&gt;google.com&lt;/code&gt; to it finishing loading on your screen.&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;브라우저는 대체로 URI를 HTTP를 사용하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://google.com&lt;/code&gt;, 재설정합니다. 아래의 과정을 통해 요청이 전달되고 해당 uri에서 HTTPS를 강제한다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;https://google.com&lt;/code&gt;로 다시 요청 과정을 반복하게 됩니다.
단, 크롬과 파이어폭스는 HTTP Strict Transport Security라 불리는 preload list를 이용하여 어떤 웹사이트가 HTTPS를 통해야 하는지 명시하기 때문에 이 리스트가 먼저 참조됩니다.&lt;/li&gt;
  &lt;li&gt;DNS의 IP 주소를 조회해야 하는데, 먼저 브라우저의 캐시에 도메인이 저장되어 있는지 확인합니다.
없을 경우 컴퓨터에 저장된 &lt;code class=&quot;highlighter-rouge&quot;&gt;hosts&lt;/code&gt;라는 파일을 확인합니다.
여기에도 없을 경우 Local Network의 local DNS cache를 참조합니다.
여기도 없으면 ISP의 DNS 서버로 요청을 보냅니다. 같은 방식으로 또 찾지 못하면 Root Name Server로 요청을 보내며, Top-level DNS server를 찾아가 IP address를 공수해옵니다.
이 과정에서 쓰이는 Transport Protocol은 UDP입니다. 이는 Domain의 IP 주소를 찾는 과정이 신뢰성 확보를 필요로 하지 않기에 UDP를 이용해 고속으로 동작시키기 위함입니다.&lt;/li&gt;
  &lt;li&gt;클라이언트(내 컴퓨터)와 구글 서버 사이에서 TCP 3-Way Handshake를 통해 TCP 연결이 ESTABLISHED 됩니다.&lt;/li&gt;
  &lt;li&gt;이후 SSL Handshake가 진행됩니다. 클라이언트가 서버로 SSL-encrpyted connection을 요청하고, 서버는 클라이언트로 SSL certificate(인증서)를 보냅니다.&lt;/li&gt;
  &lt;li&gt;클라이언트는 CA의 Public Key를 이용하여 Certificate을 해독하여 서버의 public key를 획득하며 해당 서버가 믿을 수 있는 실제 구글 서버임을 확인합니다.&lt;/li&gt;
  &lt;li&gt;클라이언트는 public key를 이용하여 temporary secret key를 만들어 서버로 보냅니다. 이제 서버는 서버가 가진 private key를 이용해 secret key를 해석하며 양쪽은 그 secret key를 이용해
secret key의 기간이 만료될 때까지 encryption과 decryption을 하며 패킷을 주고 받습니다.&lt;/li&gt;
  &lt;li&gt;이제 클라이언트는 서버로 HTTP GET 메소드를 통한 요청을 보냅니다. (HTTP 코맨드들은 SSL/TLS 암호화와 독립적으로 사용됩니다.)&lt;/li&gt;
  &lt;li&gt;서버는 상태를 나타내는 코드(200)와 함께 &lt;code class=&quot;highlighter-rouge&quot;&gt;google.com&lt;/code&gt;의 HTML 내용의 Payload를 보냅니다.&lt;/li&gt;
  &lt;li&gt;클라이언트는 HTML에서 참조하는 모든 자원(image, CSS, favicon 등)에 대해 GET 요청을 보내는 프로세스를 반복합니다.&lt;/li&gt;
  &lt;li&gt;서버가 모든 리소스를 제공하면 브라우저가 페이지를 그리게 됩니다. HTML, CSS, JS의 구문 분석과 렌더링이 이루어집니다.
렌더링은 DOM Tree를 구성하고 렌더트리 구성, 렌더트리 레이아웃 배치, 렌더트리 그리기로 이루어집니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DOM Tree, Render Tree?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DOM Tree&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DOM은 문서의 객체 모델(Document Object Model)로 HTML이나 XML내에 들어있는 요소를 구조화 객체 모델로 표현하는 양식입니다.
트리 구조를 가집니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Render Tree&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Render Tree란 DOM Tree와 CSS 마크업을 처리한 CSSOM Tree를 결합하여 형성된 트리입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;etc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Traditionally, why has it been better to serve site assets from multiple domains?&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;asset을 여러 도메인에서 받아온다는 것은 여러 서버를 이용한다는 것이므로 병렬화가 이루어져 효율적으로 통신이 됩니다.&lt;/li&gt;
  &lt;li&gt;HTTP 요청 시 HTTP 헤더에는 이전 요청에 대한 정보가 담긴 cookie가 포함되는데, 한 도메인으로 모든 asset의 요청을 보낸다면 축적된 cookie를 계속 들고 다녀야하므로 여러 도메인에 따로 요청이 이루어지면
자연스레 cookie-less 도메인을 이용하게 되므로 부하를 줄일 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is domain pre-fetching and how does it help with performance?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;domain pre-fetching은 클라이언트가 한 페이지에 머무는 동안 해당 페이지의 백그라운드에 존재하는 link들에 대해 DNS lookup를 미리 진행하고
cache에 담아두는 작업입니다. 유저가 페이지에 머무는 시간을 이용해 후에 진행될 수도 있는 작업을 미리 해두므로 후에 이루어질 작업에 걸리는 시간을 최소한으로 줄이고 성능을 향상시킵니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;os&quot;&gt;OS&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;What is an OS(Operating System)?&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Operating System Definition&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;엄밀한 정의는 없습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용자가 컴퓨터를 쉽게 다룰 수 있게 해주는 인터페이스 정도..&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;System Call&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;운영체제는 Kernel Mode와 User Mode로 나뉘어 구동됩니다.
어플리케이션이 하드웨어에 직접 접근하는 것을 막기 위해
파일 수정, 프로세스 실행, 프로세스 종료 등 low-level 명령들은 kernel-mode에서 실행됩니다.&lt;/p&gt;

&lt;p&gt;이렇게 커널모드로의 전환과 로우레벨 명령(시스템 콜)은 시스템 콜 인터페이스의 도움으로 이루어집니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Program, Process, Thread&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Program&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로그램은 실행 가능한 명령어의 집합입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Process&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로그램의 명령어와 정적 데이터가 메모리에 적재되어 실행 중인 상태를 말합니다.
프로그램당 최소 1개의 스레드 (메인 스레드)를 가집니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thread&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로세스가 할당받은 자원을 이용하는 실행의 단위를 말합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Context Switch&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CPU가 현재 진행 중인 프로세스가 아닌 다른 프로세스를 진행하기 위해 현재 프로세스의 상태를 저장하고 다음 진행할 프로세스의 상태값을 읽어오는 과정을 말합니다.&lt;/p&gt;

&lt;p&gt;스레드 간의 switch도 context switch라고 부르는지는 확실히 모르겠습니다만 스레드 교체의 경우 페이지테이블, heap, static, code 영역을 교체할 필요가 없기 때문에 process switching 보다 빠릅니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Memory allocation for a program&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/q0115643/my_blog/master/assets/images/interview/4.png&quot; alt=&quot;&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;왼쪽은 단일 쓰레드 프로세스, 오른쪽은 멀티쓰레드 프로세스의 구성입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/q0115643/my_blog/master/assets/images/interview/3.png&quot; alt=&quot;&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로레스 내의 논리적 주소 구조&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Code (혹은 Text) 영역&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로그램의 명령어들이 올라가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Data (혹은 Static) 영역&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Global variable, static variable, array, structure 등이 저장됩니다.&lt;/p&gt;

&lt;p&gt;초기화된 데이터의 영역과 초기화 되지 않은 데이터(bss)의 영역이 분리되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Heap 영역&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Dynamic memory allocation은 이 영역을 할당합니다. (ex. &lt;code class=&quot;highlighter-rouge&quot;&gt;malloc()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;realloc()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;free()&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;DS에서 배운 Heap과는 관계가 없다고 합니다;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Stack 영역&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;local variable, parameter, return value 등 잠시 사용되었다가 사라지는 데이터를 위해 할당되는 공간입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Scheduling, Synchronization&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Scheduling&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CPU는 한번에 여러 프로세스를 처리할 수 없기 때문에 순간 어떤 프로세스가 CPU를 사용해야 효율적으로 작업할 수 있는지 정리하는 것입니다.&lt;/p&gt;

&lt;p&gt;FCFS, SJF, RR, Priority-based Schduling, Multi-level Queue Scheduling 등의 스케쥴링 알고리즘이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Synchronization&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Synchronization은 아래의 mutex, semaphore 등을 이용하여 공유 자원 접근으로 인해 발생될 수 있는 conflict를 피하는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Mutex, Semaphore, Monitor&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mutex&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;멀티스레드, 멀티프로세스 환경에서 공유 자원에 대한 접속을
제어하기 위해 사용됩니다.
하나의 스레드만 뮤텍스 객체를 소유할 수 있으므로 공유 자원에 대한 접근이 있는 Critical Section 앞에 mutex에 대한 요청을 추가한다면,
오직 한 스레드만 해당 섹션에서 작동할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Semaphore&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;뮤텍스와 유사하지만 최대 한 스레드가 아닌 설정된 수의 스레드가 접근할 수 있게 한 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Monitor&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Semaphore 보다 높은 레벨의 객체로, mutex나 semaphore로 구성된 lock을 갖고 해제하고, 그 다음 스레드가 실행되고 이 과정을 처리하는 함수들을 구현해 놓은 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deadlock&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Deadlock이란 모든 스레드가 락이 플리기를 기다리고 있는 무한 대기 상태(교착 상태)에 빠진 것을 말합니다.&lt;/p&gt;

&lt;p&gt;Deadlock의 조건&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Mutual Exclusion: 한 번에 한 스레드만 공유 자원을 사용할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;Hold and Wait: 공유 자원에 대한 접근 권한을 갖고 있는 프로세스가 해당 권한을 양보하지 않은 상태에서 또 다른 자원에 대한 권한을 요구합니다.&lt;/li&gt;
  &lt;li&gt;No Preemption: 한 스레드가 다른 스레드의 자원을 강제로 뺏어갈 수 없습니다.&lt;/li&gt;
  &lt;li&gt;Circular Wait: 이 자원 접근 관계에 순환이 존재합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;교착상태는 예방하여 회피하거나, 현재 교착을 탐지하여 회복하거나, 무시하는 방식이 있습니다.
예방은 banker’s algorithm 등을 이용하며 회복은 deadlock의 조건 중 하나를 제거함으로 이루어집니다.
둘다 cost가 비싸서 모던 OS는 그냥 무시하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;Virtual Memory&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Virtual Memory&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/q0115643/my_blog/master/assets/images/interview/5.png&quot; alt=&quot;&quot; width=&quot;550px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Logical Memory와 Physical Memory를 분리해주는 테크닉입니다.
또한 프로세스 전체가 메모리에 올라오지 않더라도 실행이 가능하며, Copy-on-Write 등으로 가상 메모리가 물리적 메모리의 크기보다 커질 수 있습니다.&lt;/p&gt;

&lt;p&gt;Demand Paging 기법을 사용하지 않고 프로세스를 위한 메모리를 연속적으로 할당한다면,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;External Fragmentation: 남는 공간을 합치면 요청을 만족시키지 않지만 연속직이지 않기 때문에 메모리 할당 불가능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Internal Fragmentation: partition보다 살짝 작은 메모리가 할당되어 남는 공간이 버려짐&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;등의 문제가 생깁니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Translation Lookaside Buffer (TLB)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Page Table은 Main memory에 적재되며 CPU와 Main memory 사이의 TLB는 페이지 테이블의 최근 쓰인 엔트리들을 캐싱하는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Difference between L1 and L2 cache&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CPU는 여러 레벨의 캐시를 가지고 있습니다. 캐시는 CPU에서 Main Memory로 접근하는데 걸리는 시간을 절약하기 위해
메인 메모리의 instance를 가져와 캐싱합니다. CPU와의 거리에 따라 L1, L2, L3 캐시로 나뉘며
낮은 레벨의 캐시를 먼저 참조하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;etc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Difference between out-of-memory and stack-overflow&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;out-of-memory는 heap, stack-overflow는 stack의 공간 부족을 의미합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Difference between 64bit and 32bit processor&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;기본적으로, CPU가 읽고 처리하는 instruction(?)의 길이가 32bit와 64bit로 다릅니다.
32bit의 instance는 &lt;script type=&quot;math/tex&quot;&gt;2^32&lt;/script&gt; 개의 서로 다른 메모리 주소를 표현하므로 4GB의 메인 메모리(RAM)을 표현할 수 있으며
64bit에서는 훨씬 큽니다… 엄청 커요.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;languages&quot;&gt;Languages&lt;/h1&gt;

&lt;h2 id=&quot;oop&quot;&gt;OOP&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;OOP(Object-Oriented Programming) basic&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OOP basic&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;객체 지향 프로그래밍은 프로그램을 명령어의 목록으로 보는 시각을 벗어나
필요한 데이터를 추상화시켜 객체의 모임으로 파악하고자 하는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;OOP(객체 지향 프로그래밍)와 다른 개념으로는 C 언어를 사용한 절차적 프로그래밍이 있습니다.
물론 C언어로도 객체 지향 프로그래밍이 가능합니다.
기존의 절차적 프로그래밍을 이용하면 프로그래밍을 어떠한 논리를 어떤 순서대로 써나가는 것인가가 지배적인 관점이었습니다.
이 방식으로는 실제 프로그램 내에서 많은 상호작용이 있을수록 코드가 복잡해지고 파악이 힘들어집니다.
스타크래프트를 순서도로 그려야 된다고 생각하면 이를 예감할 수 있습니다.
이런 경우 객체 지향 프로그래밍을 이용해 캡슐화, 다형성, 상속을 이용해 코드 재사용을 증가시키고,
유지보수를 감소시키는 장점을 얻을 수 있습니다.&lt;/p&gt;

&lt;p&gt;명확히 장점을 제대로 이해하기 위해서는 아래 아래의 원칙 5가지를 봐야합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;하지만 캡슐화와 격리 구조 설계로 인해 기능을 묶으면 결국 함수 호출이 추가로 들어가거나 계산식 중간에 포인터 연산 등이 필요해지며,
멤버 함수 같은 경우 어느 객체의 함수인지 지정해야 하기 때문에 역시나 절차적 프로그래밍보다는 무거워지고 성능 하락이 있습니다.
또한 개념을 기준으로 나누다보니 객체마다의 메모리 크기가 달라지며, 결국 고정된 연속 메모리에 담을 수가 없게 됩니다.
메모리 할당을 배열로 하지 못하게 되니 따로따로 생성하며 이렇게 각각의 객체의 생성과 파괴가 반복되면 fragmentation 문제가 생기게 됩니다.&lt;/p&gt;

&lt;p&gt;절차지향프로그래밍이란, 단순히 특정 프로그래밍 언어들을 이루는 말이 아닌
프로그램 설계방법론이자 개념의 일종입니다.
하지만 일반적으로 아래 5개의 특성을 제공한다면 그 언어는 객체지향언어로 불립니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;특성 6가지&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;클래스 + 인스턴스(객체)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;클래스: 어떤 문제 해결을 위한 데이터를, 추상화를 거쳐 집단에 속하는 속성(attribute)와
행위(behavior)를 변수와 메소드로 정의한 것입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;인스턴스(객체): 클래스에서 정의한 것을 토대로 실제 메모리 상에 할당된 것을 말하며 실제 프로그램에서
사용되는 데이터입니다. 인간은 클래스이며 저는 인스턴스가 됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;함수와 메소드의 차이는, 함수는 이름으로 호출할 수 있는 코드 조각이지만,
메소드는 객체의 연결된 이름으로 불리며 메소드를 호출할 때 객체도 호출되는 것입니다. 또한
메소드는 해당 객체의 속성에 접근할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;추상화&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;변수와 함수를 하나의 단위로 묶는 것을 의미합니다.
구체적은 것을 분해해서 관심영역에 있는 특성만을 가지고 재조합하는 것입니다.&lt;/p&gt;

&lt;p&gt;대개 프로그래밍 언어에서 이 번들링은 클래스를 통해 구현됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;캡슐화&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;클래스가 제공하는 메소드의 기능만을 사용할 뿐 실제 그 메소드가 어떻게 동작하는지는
보여주지 않고 감추는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;정보 은닉&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로그램의 세부 구현을 외부로 드러나지 않도록 감추는 것입니다. 실제로 접근제어자(private)을
사용하여 이루어집니다. 모듈 간의 결합도를 떨어뜨려 유연함과 유지보수성을 높입니다.
파이썬의 경우 속성이름 앞에 &lt;code class=&quot;highlighter-rouge&quot;&gt;_(underscore)&lt;/code&gt;를 붙여서 private 속성이라는 의사표현은 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;상속 (재사용 + 확장)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;객체지향적 관점에서 상속이란 자식 클래스가 부모 클래스의 특성과 기능을 물려받는 것을 말합니다.
기능의 일부를 변경해야 할 경우 자식 클래스에서 상속받은 그 기능만을 수정하여 다시 정의합니다.
이러한 작업을 오버라이딩이라고 합니다. 상속은 캡슐화를 유지하면서도 클래스의 재사용이
용이하도록 해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;다형성&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것을 말합니다.&lt;/p&gt;

&lt;p&gt;세부적으로 여러 경우가 있고 그 중 하나로 오버라이딩, 오버로딩(같은 이름의 함수를 여러 개 정의하고 매개변수에 따라 다르게 호출하게 하는 것), 덕타이핑을 생각하시면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;info highlighter-rouge&quot;&gt;원칙 5가지&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;객체지향프로그래밍에서 꼭 지켜야 할 5개의 원칙을 말합니다. 5개의 원칙의 앞글자를 따서
SOLID라고도 불립니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SRP(Single Responsibility Principle): 단일 책임 원칙&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 객체는 오직 하나의 책임을 가져야 합니다.&lt;/li&gt;
  &lt;li&gt;다시 말해 객체는 오직 하나의 변경의 이유만을 가져야 하는 것입니다.&lt;/li&gt;
  &lt;li&gt;예를 들어 계산기를 만들 때, 계산을 하는 책임과 GUI를 나타낸다는 책임은 서로 분리되어야 합니다.
계산기 클래스에 GUI를 나타내는 부분까지 있을 경우, 이는 SRP를 위반합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OCP(Open-Closed Principle): 개방-폐쇄 원칙&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;확장에 대해서는 개방되어 있어야 하지만, 수정에 대해서는 폐쇄되어야 합니다.&lt;/li&gt;
  &lt;li&gt;예를 들어, 캐릭터를 생성한다고 할 때, 각각의 캐릭터가 움직임이 다를 경우 움직임의 패턴을 정의만 하고 구현을
하위 클래스로 보내 캐릭터 클래스의 수정은 막고 재정의만을 맡기게 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LSP(Liskov Substitusion Principle): 리스코프 치환 법칙&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;즉, 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 잘 작동해야 한다는 것입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ISP(Interface Segregation Principle): 인터페이스 분리 원칙&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;클라이언트가 자신이 이용하지 않는 메소드에 의존하지 않아야 합니다.&lt;/li&gt;
  &lt;li&gt;한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 합니다.&lt;/li&gt;
  &lt;li&gt;예를 들어 전화, 웹서핑, 사진 촬영 등 다양한 기능이 있는 스마트폰을 정의할 경우,
각 기능은 독립된 인터페이스로 구현하여 서로에게 영향을 받지 않도록 설계해야 합니다.
(참고: 인터페이스는 무엇을 할 수 있는지, 클래스는 어떤 분류인지에 대한 정의)&lt;/li&gt;
  &lt;li&gt;시스템의 내부 의존성을 약화시켜 리팩토링, 수정, 재배포를 쉽게 할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DIP(Dependency Inversion Principle): 의존성 역전 법칙&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;고수준의 클래스는 저수준의 클래스에 의존해서는 안됩니다.&lt;/li&gt;
  &lt;li&gt;예를 들어 &lt;code class=&quot;highlighter-rouge&quot;&gt;자동차&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;스노우 타이어&lt;/code&gt;에 의존한다고 합시다.
이를 &lt;code class=&quot;highlighter-rouge&quot;&gt;타이어&lt;/code&gt;로 변경하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;스노우 타이어&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;타이어&lt;/code&gt;를
상속바도록 하면 본 원칙을 지킬 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;functional-programming&quot;&gt;Functional Programming&lt;/h2&gt;

&lt;p&gt;데이터 처리를 수학적 함수의 계산으로 취급하고
상태와 가변 데이터를 멀리하는 프로그래밍 패러다임입니다.&lt;/p&gt;

&lt;p&gt;함수형 프로그래밍이 객체 지향 프로그래밍과 완전히 대비되는 개넘은 아닙니다만,
다소 상반된 위치에 있습니다.&lt;/p&gt;

&lt;p&gt;함수형 프로그래밍은 순수 함수를 작성하는 것,
그러니까 숨겨진 입력이나 출력을 최대한 제거하여 가능한한 우리 코드의 대부분이
단지 입력과 출력의 관계를 기술하게끔 하는 것을 말합니다.&lt;/p&gt;

&lt;p&gt;함수형 언어는 여러분이 가능한한 부작용을 제거하고 그렇지 않은 곳에는
철저히 제어 할 수 있도록 적극적으로 도와주는 언어입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;python&quot;&gt;Python&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;args&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;kwargs&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;args는 함수에 임의 갯수의 argument를 넘겨주기 위해 사용됩니다.&lt;/p&gt;

&lt;p&gt;kwargs는 args와 마찬가지로 함수 선언에 사용되는 마법 변수지만 차이점은 함수에 kewworded argument를 dictionary 형태로 넘겨줄 수 있다는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How is &lt;code class=&quot;highlighter-rouge&quot;&gt;dict&lt;/code&gt; implemented in Python?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;파이썬의 &lt;code class=&quot;highlighter-rouge&quot;&gt;dict&lt;/code&gt;는 해시테이블입니다.&lt;/p&gt;

&lt;p&gt;먼저 해시함수는 dictionary보단 object에 따라 다르게 정의되어있습니다.
예를 들어 string의 해시함수는 약간 간단화시켜 아래와 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def hash(string):
    x = string[0] &amp;lt;&amp;lt; 7
    for chr in string[1:]:
        x = ((1000003 * x) ^ chr) &amp;amp; (1&amp;lt;&amp;lt;32)
    return x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;튜플의 경우 아이템의 해시함수를 참고합니다.&lt;/p&gt;

&lt;p&gt;해시테이블은 collision에 대응해야 합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;dict&lt;/code&gt;에서는 chaining이 아닌 충돌이 일어날 때 정해진 칸을 더 나아간 후 다시 확인하는 open addressing이 사용됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Can class be used as a key of dictionary&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;class 객체는 dictionary의 key로 사용될 수 있으며 기본적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;id()&lt;/code&gt; 값을 이용해 해싱됩니다.&lt;/p&gt;

&lt;p&gt;새로운 해시함수를 이용하고 싶으면
class에 &lt;code class=&quot;highlighter-rouge&quot;&gt;__hash__()&lt;/code&gt; 메소드가 정의되어 있어야 하며,
라이프사이클 동안 변하지 않아야 합니다. 또한 &lt;code class=&quot;highlighter-rouge&quot;&gt;__hash__()&lt;/code&gt;의 리턴값들을 비교하여 boolean 값을 반환해주는 &lt;code class=&quot;highlighter-rouge&quot;&gt;__eq__()&lt;/code&gt; 함수도 정의되어 있어야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mutable, Immutable&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mutable&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mutable은 변할 수 있다는 의미입니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;dict&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;byte array&lt;/code&gt; 등이 있습니다.
mutable object는 함수의 parameter로 전달될 때 call-by-reference가 적용되며,
같은 값으로 x, y 두 변수를 선언하여도 서로 다른 메모리와 id를 가집니다.
y를 y=x로 선언한다면 x와 y는 같은 메모리를 가르키게 됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Immutable&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Immutable은 값이 변할 수 없다는 의미입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;인 x에 얼마든 값을 더하거나 뺄 수 있지 않느냐 혼동하실 수 있지만,
Immutable object의 값이 변할 경우 새로운 메모리가 할당됩니다.&lt;/p&gt;

&lt;p&gt;Immutable object에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;tuple&lt;/code&gt; 등이 있습니다.
immutable object는 call-by-value가 적용되며 x, y 두 변수를 같은 값으로 선언하면
서로 같은 메모리와 id를 가집니다. y를 y=x로 선언하여도 서로 다른 메모리와 id를 가집니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Difference between method and function&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;함수와 메소드의 차이는, 함수는 이름으로 호출할 수 있는 코드 조각이지만,
메소드는 객체의 연결된 이름으로 불리며 메소드를 호출할 때 객체도 호출되는 것입니다. 또한
메소드는 해당 객체의 속성에 접근할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Is &lt;code class=&quot;highlighter-rouge&quot;&gt;len()&lt;/code&gt; is function? or method?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;len()은 Python built-in function으로 특정 object 내에 존재하는 메소드가 아닌 함수입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Closure&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;클로져란 first-class function(객체로 취급되는 파이선의 모든 함) static scope의 name binding을 들고 다니는 녀석입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def outer_func(tag):
    tag = tag

    def inner_func(txt):
        text = txt
        print '&amp;lt;{0}&amp;gt;{1}&amp;lt;{0}&amp;gt;'.format(tag, text)

    return inner_func


h1_func = outer_func('h1')
p_func = outer_func('p')

h1_func('h1태그의 안입니다.')
p_func('p태그의 안입니다.')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 함수(&lt;code class=&quot;highlighter-rouge&quot;&gt;inner_func&lt;/code&gt;)를 객체로 &lt;code class=&quot;highlighter-rouge&quot;&gt;h1_func&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;p_func&lt;/code&gt;에 전달하였을 시, 아래와 같이
기존의 &lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt; 값이 이용되는 이유는 그 바인딩들을 &lt;code class=&quot;highlighter-rouge&quot;&gt;__closure__&lt;/code&gt;가 들고 다니기 때문입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python closure.py
&amp;lt;h1&amp;gt;h1태그의 안입니다.&amp;lt;h1&amp;gt;
&amp;lt;p&amp;gt;p태그의 안입니다.&amp;lt;p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Decorator&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;decorator를 한마디로 얘기하자면, 대상 함수를 wrapping 하고,
이 wrapping 된 함수의 앞뒤에 추가적으로 꾸며질 구문 들을 정의해서
손쉽게 재사용 가능하게 해주는 것입니다.&lt;/p&gt;

&lt;p&gt;아래와 같은 코드를 실행하면&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 얘가 데코레이터
def decorator(func):
    def decorator(*args, **kwargs):
        print(&quot;%s %s&quot; % (func.__name__, &quot;before&quot;))
        result = func(*args, **kwargs)
        print(&quot;%s %s&quot; % (func.__name__ , &quot;after&quot;))
        return result
    return decorator

# 함수에 데코레이터를 붙여준다.
@decorator
def func(x, y):
    print(x + y)
    return x + y

func(1,2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이와 같은 결과가 나옵니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func before
3
func after
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;class로 데코레이터를 부르려면 class 내에 아래와 같은 방식으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;__call__&lt;/code&gt; 함수를 정의하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def __call__(self, *args, **kwargs):
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Type casting&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Explicit type casting&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;float(a)&lt;/code&gt;과 같이 타입(변수)로 가능합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Implicit type casting&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파이썬은 weak typed language이기 때문에 암묵적 형변환이 이루어집니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 연산자가 데이터형에 따라 덧셈이나 문자열 병합으로 오버로딩되며,
&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;로 인해 서로 다른 데이터 타입 (&lt;code class=&quot;highlighter-rouge&quot;&gt;3 + 3.2&lt;/code&gt;)가 연산될 경우
표현범위가 좁은 데이터 타입에서 넓은 데이터 타입으로 암묵적 형변환이 일어납니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;print(3 + True)&lt;/code&gt;를 했을 시에 무려 &lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;가 출력됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;html&quot;&gt;HTML&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;HTML (HyperText Mark-up Language)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;웹 페이지의 모습을 기술하기 위한 규약으로, 프로그래밍 언어가 아닌 마크업 언어입니다.
마크업 언어란 문서가 화면에 표시되는 형식을 나타내거나
데이터의 논리적인 구조를 명시하기 위한 규칙들을 정의한 언어로, 데이터를 기술한 언어라는
점에서 프로그래밍 언어와는 차이가 있습니다.&lt;/p&gt;

&lt;p&gt;현재 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTML5&lt;/code&gt;가 최신버전으로, 완전 표준화되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What does a &lt;code class=&quot;highlighter-rouge&quot;&gt;doctype&lt;/code&gt; do?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DOCTYPE&lt;/code&gt;이란 Document Type Definition의 약자로 흔히 더 줄여말해 DTD라고 부릅니다.
HTML 문서를 읽을 때, 이 문서는 HTML 문서이고 어떤 버전을 사용했으며 그 버전에 맞는
방법으로 해석하라고 브라우저에게 알려주는 선언문입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HTML5&lt;/code&gt; 이전의 HTML과 XHTML(XML 바탕으로 만들었던 HTML, 이젠 쓰이지 않습니다.)은 유효성 검사를 위한 선언문이 쓸데없이 길었던 반면, HTML5에서는
간단하게 이렇게만 적으면 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What’s the difference between standards mode and quirks mode?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;브라우저가 HTML 문서를 처리할 때, 위의 HTML DTD(&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;&lt;/code&gt;)이 있다면 표준모드가 설정되며,
그렇지 않으면 쿼크모드가 설정됩니다. 쿼크모드로 렌더링을 할 경우 이전 세대의 브라우저에 맞는
비표준적 방법의 CSS를 적용하며 이는 오래된 웹페이지들의 최신 버전의 브라우저에서 깨져 보이지 않으려는 목적을 가집니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;meta tag&lt;/strong&gt;&lt;/p&gt;

&lt;meta /&gt;
&lt;p&gt;태그는 HTML 문서가 어떤 내용을 담고 있고, 문서의 키워드는 무엇이며, 누가 만들었는지 등의 문서 자체의 특성을 담고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;viewport 란 컴퓨터나 휴대 단말기 등 장치에 Display 요소가 표현되는 영역을 말합니다.
모바일 웹의 경우 아이폰 사파리 브라우저에서 웹 페이지가 표시되는 영역으로 해석할 수 있습니다&lt;/p&gt;

&lt;p&gt;위와 같은 메타태그로 설정하면 뷰포트의 가로 너비와 단말기의 가로너비가 동일하기 때문에
페이지의 배율 조정이 일어나지 않고 기기의 너비 만큼만 브라우저에 표시됩니다.
(물론 좌/우 스크롤 기능으로 모든 컨텐츠를 탐색할 수 는 있습니다.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How do you serve a page with content in multiple languages?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;일단 &lt;code class=&quot;highlighter-rouge&quot;&gt;lang&lt;/code&gt;이 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;lang=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;kr&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;과 같이 문서의 기본 언어 속성을 선언하여 줍니다.
이는 screen read나 search engine에 관여합니다.&lt;/p&gt;

&lt;p&gt;질문의 대한 답으로는 정말 다양한 방법이 있을 수 있습니다만, 제 블로그 같은 경우
아래와 같이 텍스트마다 yml 파일에 여러 언어에 따라 정리해놓고 lang 속성을 불러와 variable[lang]과 같은 방식으로 불러옵니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;READMORE:
  en:      &quot;Read more&quot;
  kr:      &quot;더 보기...&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What kind of things must you be wary of when design or developing for multilingual sites?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자가 쉽게 국가/언어를 변경할 수 있도록 합니다.&lt;/li&gt;
  &lt;li&gt;언어에 따라 텍스트의 길이가 달라질 수 있음에 주의합니다.&lt;/li&gt;
  &lt;li&gt;문화에 따라 민감한 색상을 고려합니다.&lt;/li&gt;
  &lt;li&gt;국가에 따라 날짜의 표현 방식이 다릅니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What are &lt;code class=&quot;highlighter-rouge&quot;&gt;data-&lt;/code&gt; attributes good for?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JS 없이 HTML element에 non-standard attribute로써 새로운 데이터를 저장하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;data-&lt;/code&gt; 속성을 사용합니다.&lt;/p&gt;

&lt;p&gt;요즘 &lt;code class=&quot;highlighter-rouge&quot;&gt;data-&lt;/code&gt;는 잘 쓰지 않고 라이브러리나 프레임워크의 데이터 바인딩을 통해 이 역할을 대신 수행합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Describe the difference between a &lt;code class=&quot;highlighter-rouge&quot;&gt;cookie&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;sessionStorage&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;localStorage&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;위 세 기술은 모두 클라이언트 측에서 데이터를 저장하는 key-value 저장소 매커니즘입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cookie&lt;/code&gt;는 4KB의 크기를 가지고 뒤에 둘과 같은 web storage가 나오기 이전에 저장소 역할을 해왔습니다만,
일반적인 저장소라기보다 매 HTTP 요청에 첨부되어 클라이언트의 신상과 같은 역할을 하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;localStorage&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;sessionStorage&lt;/code&gt;는 HTML5에 추가된 저장소입니다.
이 데이터는 HTTP 요청에 첨부되지 않으며 최대 5MB의 용량을 가집니다.
둘의 차이점으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;localStorage&lt;/code&gt;는 모든 윈도우끼리 공유되며 만료되지 않지만
&lt;code class=&quot;highlighter-rouge&quot;&gt;sessionStorage&lt;/code&gt;는 한 탭 내에서만 공유되며 탭을 닫을 때 초기화됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Describe the difference between &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script async&amp;gt;&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script defer&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt;의 경우 렌더링 중단 후 script를 즉시 가져와 실행합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script async&amp;gt;&lt;/code&gt;는 렌더링을 멈추지 않고 비동기적으로 script를 가져옵니다. 그리고
실행이 가능할 때가 되면 렌더링을 멈추고 script를 실행합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script defer&amp;gt;&lt;/code&gt;는 async와 같이 렌더링을 멈추지 않고 script를 가져오며 렌더링이 끝난 이후에 script를 실행합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is progressive rendering?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로그레시브 렌더링이란 콘텐츠를 가능한 빠르게 유저에게 보여주기 위한 기술로,
HTTP response가 여러 번 일어날 때 브라우저는 모든 요청이 끝날 때까지 기다리지 않고 각각의 아이템을 차례대로 렌더링하게 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Why you would use a &lt;code class=&quot;highlighter-rouge&quot;&gt;srcset&lt;/code&gt; attribute in an image tag? Explain the process the browser uses when evaluating the content of this attribute.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;img srcset=&quot;small.jpg 500w, medium.jpg 1000w, large.jpg 2000w&quot; src=&quot;...&quot; alt=&quot;&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 기기 디스플레이의 너비에 따라 다른 이미지를 제공하기 위해 사용됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;css&quot;&gt;CSS&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;CSS (Cascading Style Sheet)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CSS는 HTML, XHTML, XML 같은 문서의 스타일을 꾸밀 때 사용하는 스타일 시트 언어입니다.
문서가 사용자에게 어떻게 보여질까를 기술합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;difference between css and sass&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Sass&lt;/code&gt;는 css를 만들어주는 언어로 자바스크립트처럼 특정 속성(ex. color, margin, width … )의
값(ex. #000, 3px, 420px … )을 변수로 선언하여 필요한 곳에 선언된 변수를 적용할 수도 있고,
반복되는 코드를 한번의 선언으로 여러 곳에서 재사용할 수 있도록 해주는 등의 기능을 가졌습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;scss&lt;/code&gt;로 사용하면 css와 거의 같은 문법으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sass&lt;/code&gt; 기능을 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;변수 지원 뿐 아니라 함수 선언하듯이 &lt;code class=&quot;highlighter-rouge&quot;&gt;@mixin&lt;/code&gt;으로 custom 속성을 정의하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;@include&lt;/code&gt;로 불러와 사용 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What’s the difference between “resetting” and “normalizing” CSS? Which would you choose, and why?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Resetting - 요소의 모든 기본 브라우저 스타일을 제거하기 위한 것입니다.&lt;/li&gt;
  &lt;li&gt;Normalize - 브라우저가 달라도 일관된 스타일을 유지하기 위한 것입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;reset.css를 이용해 초기화한 후에도 새로 스타일을 정의해줘야 하는데,
저는 normalize.css를 이용하고 결과를 확인하면서 수정합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Describe Floats and how they work&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Float는 CSS 위치지정 속성입니다.
Float된 요소는 페이지의 흐름의 일부가 되며,
페이지의 흐름에서 제거되는 position: absolute 요소와 달리
다른 요소(예: 플로팅 요소 주위로 흐르는 텍스트)의 위치에 영향을 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;left&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;right&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;none&lt;/code&gt;의 값을 가지는데,
값에 따라 어떤 방향으로 element가 쌓일지를 결정합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Describe z-index and how stacking context is formed&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;z-index&lt;/code&gt;는 어떤 element가 앞으로 나오고, 뒤에 나올지 배치 순서를 결정하는 속성입니다.&lt;/p&gt;

&lt;p&gt;스택 컨텍스트란, &lt;code class=&quot;highlighter-rouge&quot;&gt;z-index&lt;/code&gt;값이 루트가 아닌 해당 요소를 기준으로 설정됨을 말합니다.
B가 A의 상단에 위치하는 경우 A의 하위 요소인 C는, C의 &lt;code class=&quot;highlighter-rouge&quot;&gt;z-index&lt;/code&gt;가 B보다 더 높은 경우에도
B보다 위로 올 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How would you approach fixing browser-specific styling issues?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;reset.css를 사용하고, scss의 @mixin을 통해 vendor prefix가 필요한 속성의 경우 전부 포함시켜 따로 불러오게 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Have you ever used a grid system, and if so, what do you prefer?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;bootstrap의 grid system을 써봤지만 상세한 조정이 힘들기에
flex-box를 이용한 반응형 레이아웃을 작성하는 것을 선호합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Can you give an example of an &lt;code class=&quot;highlighter-rouge&quot;&gt;@media&lt;/code&gt; property other than &lt;code class=&quot;highlighter-rouge&quot;&gt;screen&lt;/code&gt;?&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@media print {
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;인쇄를 위한 디자인을 명시해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What are some of the “gotchas” for writing efficient CSS?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;tag selector 보다는 class나 id selector를 사용하며,
페이지마다 전부 적시하기보다 재사용 가능한 style을 최대한 이용해주는 것이 좋습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How would you implement a web design comp that uses non-standard fonts?&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@font-face {
  font-family: 'SpoqaHanSans';
  font-weight: 200;
  src: url('./fonts/SpoqaHanSansThin.woff2') format('woff2'),
       url('./fonts/SpoqaHanSansThin.woff') format('woff'),
       url('./fonts/SpoqaHanSansThin.ttf') format('truetype');
}

body {font-family: 'SpoqaHanSans', 'serif';}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Describe pseudo-elements and discuss what they are used for&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:before&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;:hover&lt;/code&gt; 등이 있으며 element 이전에 special symbol을 더하거나 첫 문자의 색을 바꾸거나, 마우스를 올려 놓을 시 스타일 변화 등을 위해 쓰입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is the CSS &lt;code class=&quot;highlighter-rouge&quot;&gt;display&lt;/code&gt; property and can you give a few examples of its use?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;none&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;flex&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;inline&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;inline-block&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;table&lt;/code&gt;, …&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What’s the difference between inline and inline-block?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;display:inline-block&lt;/code&gt; element들은 각자 width와 height를 가질 수 있으며 &lt;code class=&quot;highlighter-rouge&quot;&gt;inline&lt;/code&gt;은 내용에 의존합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;inline-block&lt;/code&gt;은 모든 방향에서 margin과 padding이 가능하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;inline&lt;/code&gt;은 좌우로만 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What’s the difference between a relative, fixed, absolute and statically positioned element?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt;은 기본값입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;relative&lt;/code&gt;는 별도의 프로퍼티를 지정하지 않는 이상 &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt;과 동일하지만
&lt;code class=&quot;highlighter-rouge&quot;&gt;top&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;right&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;bottom&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;left&lt;/code&gt;를 지정하여 기본 위치와 다르게 위치가 조정됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fixed&lt;/code&gt;는 viewport에 상대적으로 위치가 지정되며 페이지가 스크롤되더라도 늘 같은 곳에 위치합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;absolute&lt;/code&gt;는 viewport가 아닌 부모 element에 상대적으로 위치가 지정됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How is responsive design different from adaptive design?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Responsive: 하나의 기본 레이아웃이 있고 스크린에 따라 반응하여 변형됩니다.&lt;/li&gt;
  &lt;li&gt;Adaptive: 모든 스크린에 대해 다른 레이아웃을 가집니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;javascript&quot;&gt;Javascript&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;ECMAScript&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;자바스크립트는 1990년대 Netscape 회사의 Brendan Eich 라는 사람에 의해 개발되었습니다.
바라스크립트가 잘되자, MS에서는 Jscript라는 언어를 개발해 IE에 탑재하였는데, 이 두 스크립트가 너무
제각각이라 표준이 필요하게 되었습니다.&lt;/p&gt;

&lt;p&gt;이해당사자 간의 이름을 둘러싼 합의 끝에 &lt;code class=&quot;highlighter-rouge&quot;&gt;ECMAScript&lt;/code&gt;라는 이름이 탄생하였습니다.
종종 마주치는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ES&lt;/code&gt;란 &lt;code class=&quot;highlighter-rouge&quot;&gt;ECMAScript&lt;/code&gt;의 약자입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Javascript&lt;/code&gt;는 언어이고, &lt;code class=&quot;highlighter-rouge&quot;&gt;ECMAScript&lt;/code&gt;는 규격, 표준이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ES3 (1999)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;흔히 알고 있는 그냥 Javascript입니다. 함수 단위의 스코프와, Hoisting, closure, prototype 등
기본적인 특징들을 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ES4 (?)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이것저것 생겼다가 폐기되었다고 하네요.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ES5 (2009)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;배열에 &lt;code class=&quot;highlighter-rouge&quot;&gt;forEach&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;reduce&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;some&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;every&lt;/code&gt;와 같은 메소드가 생겼습니다.
이 메소드들로 불필요한 중복 코드를 줄이고 가독성을 높이게 되었습니다.&lt;/li&gt;
  &lt;li&gt;Object에 대한 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object.Create()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Object.defineProperty()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Object.freeze()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Object.assign()&lt;/code&gt; 등과
&lt;code class=&quot;highlighter-rouge&quot;&gt;getter&lt;/code&gt; / &lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt; 지원&lt;/li&gt;
  &lt;li&gt;strict 모드라는, 문법을 좀 더 깐깐하게 체크하는 모드가 생겼습니다.&lt;/li&gt;
  &lt;li&gt;JSON 지원&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ES6 (2015)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; 키워드가 추가되었습니다.
기존의 변수는 함수 scope를 가진 &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; 키워드를 이용하여 선언하였습니다.
때문에 block scope를 가진 &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; 키워드를 추가하였습니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;과는 다르게 변수 재선언이 불가능하며 &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;는 재선언또한 불가능합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;arrow 문접을 지원합니다. 일반 함수의 자신을 호출하는 객체를 가리키는 &lt;code class=&quot;highlighter-rouge&quot;&gt;dynamic this&lt;/code&gt;와
달리 arrows 함수는 코드의 상위 스코프(lexical scope)를 가리키는 &lt;code class=&quot;highlighter-rouge&quot;&gt;lexical this&lt;/code&gt;를 가집니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;가 추가되었습니다. 기존의 prototype 기반으로 클래스를 만드는 것보다 명료하게
클래스를 만들 수 있게 되었습니다. 또한 클래스 선언은 함수 선언과 달리 Hoisting 되지 않습니다.
클래스를 사용하려면 사용하려는 위치 이전에 정의한 상태여야 합니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;constructor&lt;/code&gt; 객체의 생성과 초기화를 하는 특별한 메소드입니다.
클래스에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;constructor&lt;/code&gt; 이름을 갖는 메소드는 하나여야 합니다.
생성자 메소드에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;super&lt;/code&gt; 키워드를 통해 상위 클래스의 생성자 메소드를 호출 할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Polygon&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;width&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Square&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Polygon&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// length로 다각형의 넓이와 높이를 정의하기 위해 부모클래스의 생성자를 호출합니다.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Note: 파생 클래스에서, 'this'를 사용하기 전에는 반드시 super()를&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 호출하여야 합니다. 그렇지 않을 경우 참조에러가 발생합니다.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Square'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
    &lt;span class=&quot;kd&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;area&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
    &lt;span class=&quot;kd&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;area&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;area&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Square&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;area&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;콜백 지옥에서 구원해 줄 &lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Module Loader, Proxy, Reflect, Generator 등등… 많이 추가되었습니다. 설마 이런 것까지 상세히 물어보진 않겠죠?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ES7 (2016)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;제곱 연산자(**)가 등장하였습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;배열.includes(찾을 요소, 시작 순서)&lt;/code&gt;가 추가되었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;includes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;includes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ES8 (2017)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;이 추가되었습니다. 사실 promise가 어렵지 &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;의 기능만 따로 설명하라하면
별로 안 어려운 것 같긴 한데 아래에서 따로 풀어보겠습니다.&lt;/li&gt;
  &lt;li&gt;객체의 심화된 메소드가 등장했습니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.keys()&lt;/code&gt;에 대응되는 메소드인 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object.values()&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.keys()&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object.values()&lt;/code&gt;를 합쳐 놓은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object.entries()&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.getOwnPropertyDescriptor&lt;/code&gt;의 복수 형태인
&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.getOwnPropertDescriptors()&lt;/code&gt;로써 상속받지 않은 속성들의 설명만 보여줍니다.&lt;/li&gt;
  &lt;li&gt;문자열 단순 편의기능으로
문자열 앞부분에 공백을 넣어 자리수를 맞춰주는 &lt;code class=&quot;highlighter-rouge&quot;&gt;String.padStart()&lt;/code&gt;,
문자열 뒷부분에 공백을 넣어 자리수를 맞춰주는 &lt;code class=&quot;highlighter-rouge&quot;&gt;String.padEnd()&lt;/code&gt;가 추가되었습니다.&lt;/li&gt;
  &lt;li&gt;매개변수 마지막에 콤마를 붙이는걸 허용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ES9 (2018)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Rest, Spread 속성이 생겼습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Rest Properties&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;remain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 2&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;remain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//{ c:3, d:4 }&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Spread Properties&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Arr1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;newArr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Arr1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;newArr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//{a: 1, e: 5, b: 2, c: 3, d: 4}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;for-await-of&lt;/code&gt;로 비동기 iterable 객체를 반복하는 구문이 생겼습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Promise에 &lt;code class=&quot;highlighter-rouge&quot;&gt;finally()&lt;/code&gt;라는 메소드가 추가되었습니다. 실행결과에 상관없이
맨 마지막에 실행되는 메소드입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explain how &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; works in JavaScript&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;함수를 호출할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt; 키워드를 사용하는 경우 함수 내부에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;는 완전히 새로운 객체입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;apply&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;bind&lt;/code&gt; 가 함수의 호출 / 작성에 사용되는 경우 함수 내의 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;는 인수로 전달된 객체입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;obj.method()&lt;/code&gt;와 같이 함수를 메소드로 호출하는 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;는 함수가 프로퍼티인 객체입니다.&lt;/li&gt;
  &lt;li&gt;함수가 자유함수로 호출되는 경우, 즉 위의 조건없이 호출되는 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;는 전역 객체입니다.
브라우저에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; 객체입니다.&lt;/li&gt;
  &lt;li&gt;위의 규칙 중 다수가 적용되면 더 높은 규칙이 적용되며 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; 값을 설정합니다.&lt;/li&gt;
  &lt;li&gt;함수가 ES6의 arrow 문법을 이용할 경우 위의 규칙을 무시하고 생성된 시점의 주변 스코프의 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; 값을 받습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Call, Apply, Bind&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt; 메소드는 모든 함수에서 사용할 수 있으며, &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;를 특정값으로 지정할 수 있습니다.
함수를 호출하면서 &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;을 사용하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;를 사용할 객체로 넘기면 해당 함수가 주어진 객체의 메소드인 것처럼 사용할 수 있습니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;의 첫 번째 매개변수는 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;로 사용할 값이고, 매개변수가 더 있으면 그 매개변수는 호출하는 함수로 전달됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;aplly&lt;/code&gt; 메소드는 함수 매개변수를 처리하는 방법을 제외하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;과 같습니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;은 일반적은 함수와 마찬가지로 매개변수를 직접 받지만, &lt;code class=&quot;highlighter-rouge&quot;&gt;apply&lt;/code&gt;는 매개변수를 배열로 받습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bind&lt;/code&gt; 메소드는 함수의 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;값을 영구히 바꿉니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Can you give an example of one of the ways that working with &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; has changed in ES6?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;화살표 함수는 항상 익명 함수이며 this의 값을 현재 문맥에 바인딩 시킵니다.
ES6 이전의 경우 자유 함수에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;는 전역객체(&lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt;)를 가집니다.&lt;/p&gt;

&lt;p&gt;아래의 예시는 화살표 함수가 지원되지 않는 ES5에서 this를 사용하기 위한 처리 예시입니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_this&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'.btn'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;_this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sendData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음은 위 예시를 화살표 함수로 대체한 ES6 예시입니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'.btn'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sendData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Prototype&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;자바스크립트에서 프로토타입은 두 가지의 의미를 혼용해서 사용합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;: 사우이에서 무려 받은 객체의 프로토타입에 대한 정보 (prototype link)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;prototype&lt;/code&gt;: 자신의 프로토타입 객체, 다시 말해 하위로 물려줄 프로토타입의 정보 (prototype object)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;단, 접근 시에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;object.prototype&lt;/code&gt; 이용하여 1번의 경우에 접근합니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bark&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;왈왈!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dog&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 왈왈!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dog.bark()&lt;/code&gt; 를 실행했을 때, dog 객체에는 bark라는 함수가 정의되어 있지 않지만, Animal 프로퍼티에
bark라는 함수가 정의되어 있고, “왈왈!”이라는 결과를 얻게 됩니다.&lt;/p&gt;

&lt;p&gt;이는, 현재의 객체에서 어떠한 기능을 호툴하였는데, 찾지 못하면 상위로 올라가 찾게 되기 때문입니다.
이러한 개념(반복하여 상위로 올라가면서 찾는)을 프로토타입 체인(prototype chain)이라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explain how prototypal inheritance works&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;자바스크립트는 ES6 이전까지 클래스가 존재하지 않았으며 &lt;code class=&quot;highlighter-rouge&quot;&gt;prototype&lt;/code&gt;을 이용하여 클래스와 상속을
흉내냈습니다.&lt;/p&gt;

&lt;p&gt;모든 자바스크립트 객체는 다른 객체에 대한 참조인 &lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt; 프로퍼티를 가지고 있습니다.
객체의 프로퍼티에 접근할 때 해당 객체에 해당 프로퍼티가 없으면 자바스크립트 엔진은 객체의
&lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt; 등을 보고 프로퍼티가 정의될 때까지 찾고 만약 객체의
프로퍼티에 접근할 때 해당 객체의 해당 프로퍼티가 없으면 프로토타입 체인 중 하나에 있거나 프로토타입
체인의 끝에 도달할 때까지 찾습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What’s the difference between a variable that is: &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;undeclared&lt;/code&gt;?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;undeclared&lt;/code&gt; 는 이전에 &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;를 사용하여 생성되지 않은 식별자에 값을 할당할 때 생성됩니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;undeclared&lt;/code&gt;는 전역 변수로 정의되며 strict 모드에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;가 throw 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// strict 모드에서 ReferenceError를 발생시킵니다.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; 변수는 선언되었지만 값이 할당되지 않은 변수입니다. 또한 &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; 타입을 가집니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// undefined&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'undefined'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true. 옳지않습니다. 확인하는 데 사용하지 마세요.&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;baz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;baz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// undefined&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; 변수는 &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; 값에 할당됩니다. 값을 나타내지 않지만 명시적으로 할당된다는 점에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;와는 다릅니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true. 옳지않습니다. 확인하는 데 사용하지 마세요.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is a closure, and how/why would you use one?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;closure&lt;/code&gt;란 함수 내에서 그 함수가 선언된 lexical scope를 담고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Can you describe the main difference between the &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.forEach()&lt;/code&gt; loop and &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.map()&lt;/code&gt; methods and why you would pick one versus the other?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.forEach(() =&amp;gt; {})&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;.map(() =&amp;gt; {})&lt;/code&gt;의 주된 차이점은
&lt;code class=&quot;highlighter-rouge&quot;&gt;.map()&lt;/code&gt;이 새로운 배열을 반환한다는 것입니다.
결과가 필요하지만 원본 배열을 변경하고 싶지 않으면
&lt;code class=&quot;highlighter-rouge&quot;&gt;.map()&lt;/code&gt;이 확실한 선택입니다.
단순히 배열을 반복할 필요가 있다면, &lt;code class=&quot;highlighter-rouge&quot;&gt;.forEach()&lt;/code&gt;가 좋은 선택입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What’s a typical use case for anonymous functions?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;한 번 사용되며 다른 곳에서는 사용할 필요가 없는 콜백으로 사용됩니다.
함수 본체를 찾기 위해 다른 곳을 찾아볼 필요 없이 코드를 호출하는 코드
바로 안에 핸들러가 정의되어 있으면 코드가 보다 독립적이고 읽기 쉽게 보일 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What’s the difference between host objects and native objects?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;호스트 객체는 &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;XMLHTTPRequest&lt;/code&gt;와 같이 런타임 환경(ex. 브라우저, Node.js)에 의해 제공됩니다.&lt;/li&gt;
  &lt;li&gt;내장 객체는 &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Math&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Function&lt;/code&gt;과 같이 Javascript 언어의 일부인 객체입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explain the difference between: &lt;code class=&quot;highlighter-rouge&quot;&gt;function Person(){}&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;var person = Person()&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;var person = new Person()&lt;/code&gt;?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Person(){}&lt;/code&gt;은 정상정인 함수 선언입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var person = Person()&lt;/code&gt;은 생성자가 아니며 &lt;code class=&quot;highlighter-rouge&quot;&gt;Person()&lt;/code&gt;을 함수로 호출합니다.
일반적으로 생성자는 아무것도 반환하지 않으므로
일반 함수처럼 생성자를 호출하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;가 반환됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var person = new Person()&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Person.prototype&lt;/code&gt;을 상속받은 &lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt; 연산자를 사용하여
&lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt; 객체의 인스턴스를 생성합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'John'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// undefined&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Uncaught TypeError: 정의되지 않은 'name' 프로퍼티를 읽을 수 없습니다&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'John'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Person { name: &quot;John&quot; }&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;john&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explain the differences on the usage of &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; between &lt;code class=&quot;highlighter-rouge&quot;&gt;function foo() {}&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;var foo = function() {}&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;function foo() {...}&lt;/code&gt;는 함수 선언문입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var foo = function() {...}&lt;/code&gt;는 함수 표현식으로 초기에 &lt;code class=&quot;highlighter-rouge&quot;&gt;function() {...} ()&lt;/code&gt;(IIFE) 식으로 적어 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;에 리턴값을 할당하거나
이후에 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo()&lt;/code&gt;를 하는 방식으로 실행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Can you explain what &lt;code class=&quot;highlighter-rouge&quot;&gt;Function.call&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Function.apply&lt;/code&gt; do? What’s the notable difference between the two?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.call&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;.apply&lt;/code&gt;는 모두 함수를 호출하는데 사용되며
첫 번째 매개 변수는 함수 내에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;의 값으로 사용됩니다.
단 &lt;code class=&quot;highlighter-rouge&quot;&gt;.call&lt;/code&gt;은 쉼표로 구분된 인수를 매개 변수로 전달하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;.apply&lt;/code&gt;는 배열을 매개 변수로 전달합니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explain &lt;code class=&quot;highlighter-rouge&quot;&gt;Function.prototype.bind&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bind()&lt;/code&gt; 메소드는 호출될 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;가 제공된 값으로 설정됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explain “hoisting”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;객체의 선언을 최상위로 올려주는 것입니다. 할당은 올라가지 않습ㄴ니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;getX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같은 코드는 다음과 같이 재구성되어 인터프릿됩니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// undefined&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 100&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;getX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래도 마찬가지입니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Syntax&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Describe event bubbling&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;element에서 이벤트가 감지되었을 때, 해당 element를 포함하고 있는 부모 element를 통해
최상위까지 이벤트가 전달되는 것을 버블링이라고 합니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;form&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;onclick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;alert('form')&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;FORM&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;onclick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;alert('div')&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;DIV&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;onclick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;alert('p')&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/p&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/form&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드를 실행하면 차례대로 p &amp;gt; div &amp;gt; form 창이 뜨게 됩니다. 대부분의 이벤트는 버블링이 일어나지만
예외적으로 focus는 버블링이 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Describe event capturing&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;캡쳐링은 window부터 최초 이벤트가 발생한 자식 요소로 내려가는 과정을 말합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What’s the difference between an “attribute” and a “property”?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;attribute&lt;/code&gt; 속성은 HTML 마크업에 정의되지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;property&lt;/code&gt; 속성은 DOM에 정의됩니다.
차이점을 설명하기 위해 HTML에 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;input type=&quot;text&quot; value=&quot;Hello&quot;&amp;gt;&lt;/code&gt; 텍스트 필드가 있다고 합시다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;querySelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'input'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getAttribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'value'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Hello&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Hello&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;input&lt;/code&gt; element는 &lt;code class=&quot;highlighter-rouge&quot;&gt;type&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt; 두 attribute를 가집니다.
브라우저가 엘리먼트를 파싱하면서 생성되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTMLInputElement&lt;/code&gt; 객체에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;accept&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;accessKey&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;align&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;alt&lt;/code&gt; 등
많은 property를 존재할 것입니다. 또한 엘리먼트의 attribute도 DOM에서의 객체의 property로 생성되지만
일대일 대응이 지켜지진 않습니다. 예를 들어 텍스트 필드에 “World!”를 추가하면 이렇게 될 것입니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getAttribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'value'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Hello&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Hello World!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is the difference between &lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;===&lt;/code&gt;?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt; 연산자는 타입 변환이 필요한 경우 암시적 타입 변환을 한 후에 동등한지 비교합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;===&lt;/code&gt; 연산자는 타입 변환을 하지 않으므로 두 값의 타입이 다를 경우 단순히 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;를 반환합니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explain the same-origin policy with regards to JavaScript&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;same-origin 정책은 자바스크립트가 도메인 경계를 넘어서 요청하는 것을 방지합니다.
origin은 URI 체계, 호스트 이름 및 포트 번호의 조합으로 정의됩니다.
이 정책은 한 페이지의 악의적인 스크립트가 해당 페이지의 문서 객체 모델을 통해
다른 웹 페이지의 중요한 데이터에 접근하는 것을 방지합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is strict mode? What are some of the advantages/disadvantages of using it?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;스트릭트 모드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;use strict&lt;/code&gt;를 사용하거나, doctype이 정의되어 있지 않을 때 사용됩니다.
이는 안전한 코딩을 위한 하나의 가이드라인으로 더 엄격한 오류 검사를 적용시킵니다.&lt;/p&gt;

&lt;p&gt;ES6에서부터 strict mode가 default라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What are some of the advantages/disadvantages of writing JavaScript code in a language that compiles to JavaScript?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Javascript로 컴파일되는 언어로는 Coffeescript, Purescript, Typescript가 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;장점으로는, 자바스크립트의 안티 패턴(피해야할 패턴)을 방지하는데 도움을 주는 경우가 있으며,
타입스크립트의 경우 정적 타입을 도입하여 시간 경과에 따라 유지 관리해야하는 대규모 프로젝트에서
장점을 드러낼 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;단점으로 항상 자바스크립트로의 컴파일을 필요로 하며
최신 자바스크립트 표준에 뒤쳐지는 경우가 많습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explain the difference between mutable and immutable objects&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Immutable 객체는 생성된 이후 값의 변경이 일어날 수 없습니다.
Primitive 객체들과 같으며 &lt;code class=&quot;highlighter-rouge&quot;&gt;Boolean&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Number&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Symbol&lt;/code&gt;이 있습니다.&lt;/p&gt;

&lt;p&gt;Mutable 객체는 생성된 이후에도 값의 변경이 일어날 수 있는 객체입니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;Function&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Array&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What are the pros and cons of immutability?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;장점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Call-by-value가 적용되므로 매개변수로 넘겨줄 때 방어적 카피를 만들 필요가 없습니다.&lt;/li&gt;
  &lt;li&gt;같은 값으로 생성된 객체들을 위해 새로운 메모리가 사용되지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;단점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;한 번의 메모리 할당 이후 값 변경이 아닌 작은 객체들을 여러 번 생성하는 것은 때론 비효율적입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explain the difference between synchronous and asynchronous functions&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;동기 함수는 다음 명령문이 실행되기 전에 명령문이 완료되어야 하지만,
비동기 함수는 일반적으로 비동기 기능이 호출된 이후 즉시 다음 줄로 실행이 진행됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is event loop? what is the difference between call stack and task queue?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이벤트 루프는 콜 스택을 모니터링하며 태스크 큐에서 수행할 작업이 있는지 확인하는 단일 스레드 루프입니다.
콜 스택이 비어 있고, 태스크 큐에 콜백 함수가 있는 경우, 함수는 큐에서 제외되고 실행될 콜 스택으로 푸시됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What are the differences between &lt;code class=&quot;highlighter-rouge&quot;&gt;ES6&lt;/code&gt; class and &lt;code class=&quot;highlighter-rouge&quot;&gt;ES5&lt;/code&gt; function constructors?&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// ES5 함수 생성자&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// ES6 클래스&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;생성자의 주요 차이점은 상속을 사용할 때 발생합니다.
Person의 하위 클래스이면서 studentId 필드를 추가로 가지고 있는
Student 클래스를 만들고자 한다면, 이것이 우리가 위에 추가해서 해야 할 일입니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// ES5 함수 생성자&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;studentId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 수퍼 클래스의 생성자를 호출하여 수퍼 클래스에서 상속된 멤버를 초기화합니다.&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 서브 클래스의 멤버를 초기화합니다.&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;studentId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;studentId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// ES6 클래스&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;studentId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;studentId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;studentId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Can you offer a use case for the new arrow &lt;code class=&quot;highlighter-rouge&quot;&gt;=&amp;gt;&lt;/code&gt; function syntax? How does this new syntax differ from other functions?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;먼저 syntax가 기존보다 간단합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;function&lt;/code&gt;을 적지 않아도 됩니다. 또한,
arrow 문법을 이용할 경우 함수 내의 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;는 생성된 시점의 주변 스코프의 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; 값을 받습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What advantage is there for using the arrow syntax for a method in a constructor?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;가장 큰 장점은, constructor 내부의 메소드에 arrow 문법을 이용할 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; 값은 함수 생성
당시에 설정되고 변하지 않는다는 것입니다. 그러므로 생성자를 이용해 객체를 만들 경우
&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;는 항상 해당 객체에 의존합니다.&lt;/p&gt;

&lt;p&gt;아래 코드를 예를 들어봅시다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;firstName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;firstName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;firstName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sayName1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;firstName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sayName2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;firstName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;john&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'John'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dave&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Dave'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;john&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sayName1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// John&lt;/span&gt;
&lt;span class=&quot