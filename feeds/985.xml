<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" media="screen" href="/~d/styles/atom10full.xsl"?><?xml-stylesheet type="text/css" media="screen" href="http://feeds.feedburner.com/~d/styles/itemcontent.css"?><feed xmlns="http://www.w3.org/2005/Atom" xmlns:feedburner="http://rssnamespace.org/feedburner/ext/1.0"><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="https://www.saturnsoft.net/" rel="alternate" type="text/html" /><updated>2019-03-26T07:58:30+00:00</updated><id>https://www.saturnsoft.net/feed.xml</id><title type="html">saturnsoft.net</title><subtitle>Junho Choi's personal website</subtitle><author><name>Junho Choi</name></author><atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="self" type="application/atom+xml" href="http://feeds.feedburner.com/saturnsoft" /><feedburner:info uri="saturnsoft" /><atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="hub" href="http://pubsubhubbub.appspot.com/" /><entry><title type="html">QUIC과 HTTP/3 - 2. 기존의 성능 개선 기법 및 한계</title><link href="http://feedproxy.google.com/~r/saturnsoft/~3/cmw6GiveaeQ/" rel="alternate" type="text/html" title="QUIC과 HTTP/3 - 2. 기존의 성능 개선 기법 및 한계" /><published>2019-03-26T00:00:00+00:00</published><updated>2019-03-26T00:00:00+00:00</updated><id>https://www.saturnsoft.net/network/2019/03/26/quic-http3-2</id><content type="html" xml:base="https://www.saturnsoft.net/network/2019/03/26/quic-http3-2/">&lt;p&gt;1편이 주로 기존 전송 프토토콜의 확장성 문제를 다루었다고 한다면
2편에서는 프로토콜의 성능 문제 및 기존의 개선 사항을
알아 보도록 하겠습니다. 이 글의 성능 개선 기법을 이해 한다면
QUIC의 디자인이 더 쉽게 이해될 것입니다.&lt;/p&gt;

&lt;h2 id="성능에-영향을-미치는-문제들"&gt;성능에 영향을 미치는 문제들&lt;/h2&gt;

&lt;p&gt;HTTP/1.1 + TLS (https)를 생각해 보면 하나의 HTTP요청을 위해서는 다음과 같은
단계를 거쳐야 합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;DNS 조회. 호스트 이름에 대해서 DNS 조회 후 연결할 IP주소를 확보&lt;/li&gt;
  &lt;li&gt;TCP 연결을 위한 핸드쉐이크&lt;/li&gt;
  &lt;li&gt;TLS 연결을 위한 핸드쉐이크&lt;/li&gt;
  &lt;li&gt;HTTP 요청 전송&lt;/li&gt;
  &lt;li&gt;HTTP 응답 수신&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;DNS는 보통 1 RTT 라서 캐싱 이외에 시간을 줄일 수 있는 방법은 없습니다만
기본 평문으로 전송되는 단점이 있어서, 암호화를 위해
DoT (DNS over TLS)나 DoH (DNS over HTTPS)를 사용하는 경우가 있습니다.&lt;/p&gt;

&lt;p&gt;DNS 이후 과정을 중심으로 기존의 성능 개선 사항을 알아 보도록 하겠습니다.&lt;/p&gt;

&lt;h3 id="네트워크-지연시간-문제"&gt;네트워크 지연시간 문제&lt;/h3&gt;

&lt;p&gt;인터넷에서는 물리적 또는 네트워크 지점간의 거리 및 처리 속도에 의해서 발생하는
패킷 발송과 도착 사이의 시간차가 존재 합니다.
보통 지연시간(latency)이라고 부르는 것인데,
단방향일 수도 있고 양방향 (보낸 후 받을 때 까지)일 수 있습니다만
우리가 보통 네트워크 지연 시간이라고 하는 경우
요청 패킷을 보내고 난 뒤 응답 내용의 패킷이 도착하는
왕복 시간(Round Trip Time, RTT)을 의미 합니다.&lt;/p&gt;

&lt;p&gt;지연시간은 웹 성능 특성상 중요한 문제로 작용 하는데, 지연시간은 인터넷
발달에 더불어 점점 줄어들고 있지만 가정 또는 모바일 네트워크의 인터넷
사용에 있어서는 아직 &lt;a href="https://www.igvita.com/2012/07/19/latency-the-new-web-performance-bottleneck/"&gt;수십 - 수백 밀리초가 걸리고 있는 것이 현실&lt;/a&gt;입니다.
(온라인 게임에서는 핑 시간이라고 이야기하는 경우가 많습니다)
한국은 워낙 인터넷 기반 환경이 좋아서 잘 느끼지 못하는 부분이지만 국가마다
이런 상황은 크게 차이가 납니다.&lt;/p&gt;

&lt;p&gt;지연시간이 강조 되는 이유는 또 한가지가 있습니다. 보통 인터넷 성능에서
중요하다고 생각하는 것은 100Mbps 나 1Gbps 로 표현되는 대역폭(속도)인데,
웹페이지 로딩에 큰 영향을 미치는 것은 &lt;a href="https://www.igvita.com/2012/07/19/latency-the-new-web-performance-bottleneck/"&gt;지연시간이지 대역폭이 아니기 때문&lt;/a&gt;입니다.&lt;/p&gt;

&lt;p&gt;그런데 전송 프로토콜의 관점에서 보면 지연 시간은 네트워크의 구성에 의한
요소이므로 물리적으로 줄일 수 있는 방법은 존재하지 않습니다. 가령 LTE 모바일
네트워크를 사용한다면 이론적인 RTT 한계는 40ms 정도 이며 더 줄어들지 않습니다.
(5G에서는 1ms 까지 가능하다고 하므로 향후 기대되는 부분입니다) 그런데 이런
숫자는 단순하게 사용자 장치에서 사용중인 ISP까지일 경우이므로
실제 웹 서버에 도착하기 위해서는 중간에 거쳐야 하는 네트워크 경로가 더 있습니다.
가령 한국에서 미국의 웹 서버에 접속하기 위해서는 태평양 해저 케이블을 건너야
하므로 한국-미국 구간 만으로 100 ~ 150ms 정도가 추가 됩니다.&lt;/p&gt;

&lt;p&gt;따라서, 기존의 전송 프로토콜에서의 성능 개선은 크게 두가지로 나누어 집니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;큰 데이터를 전송해야 하는 경우 대역폭을 최대한 활용&lt;/li&gt;
  &lt;li&gt;프로토콜 상에서 초기 왕복이 필요한 구간을 최소화&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1의 경우 TCP의 혼잡 제어 알고리즘 및 패킷 유실 복구 기법이 중요합니다.
관련된 기술로 1편에서 잠시 언급된 TCP의 &lt;a href="https://tools.ietf.org/html/draft-ietf-tcpm-rack-04"&gt;RACK/TLP&lt;/a&gt;(패킷 유실 복구를 개선하는 방법)와 &lt;a href="https://tools.ietf.org/html/draft-cardwell-iccrg-bbr-congestion-control-00"&gt;BBR&lt;/a&gt; 혼잡 제어 알고리즘에 대해 알아보면 도움이 될 것입니다.&lt;/p&gt;

&lt;p&gt;아래에서는 주로 2에 대한 솔루션을 알아 보도록 하겠습니다. 그 이유는 HTTP의 경우
상대적으로 짧은 연결이 많이 발생하기 때문이고, 왕복 구간의 최소화는 사용자 입장에서
얼마나 웹 페이지가 빨리 표시되는지에 관련이 있기 때문입니다.&lt;/p&gt;

&lt;h4 id="tcp---fast-open"&gt;TCP - Fast Open&lt;/h4&gt;

&lt;p&gt;2014년 RFC가 나온 &lt;a href="https://tools.ietf.org/html/rfc7413"&gt;Fast Open&lt;/a&gt;은 기존 TCP의 연결 성립 과정이 최소 1-RTT(3-way handshake)가 걸리는 문제를 개선하기 위해서, 사전에 연결이 한번 되었던 경우에 클라이언트가 서버에 SYN패킷을 보낼 때 사전에 교환된 쿠키 값과 더불어 데이터를 추가하여 보낼 수 있습니다. HTTP와 같이 클라이언트가 요청하는 데이터를 먼저 보내는 경우라면 0-RTT로 HTTP요청을 보낼 수 있습니다.&lt;/p&gt;

&lt;p&gt;아래 그림에서 좌측은 기존의 방법, 우측은 Fast Open 을 사용한 경우 입니다. 1 RTT가
절약 되었음을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-03-26/tcpfastopen.png" alt="TCP Fast Open" width="75%" /&gt;&lt;/p&gt;

&lt;p&gt;단점으로는 실제 사용을 위해서는 클라이언트와 서버가 모두 Fast Open을 지원해야 하고 소켓 API 사용을 일부 수정해야 하고, 1편에서 이야기한 것 처럼 중간 장비나 방화벽에 따라 동작하지 않는 경우가 있습니다. 만약 0-RTT가 불가능하다면 1-RTT로 처리되게 됩니다.&lt;/p&gt;

&lt;h4 id="tls"&gt;TLS&lt;/h4&gt;

&lt;p&gt;TLS는 TCP와 같은 신뢰성 있는 데이터 전송 위에서 사용할 수 있는 데이터 암호화 프로토콜입니다. 최신 버전은 2018년에 RFC가 발표된 &lt;a href="https://tools.ietf.org/html/rfc8446"&gt;TLS 1.3&lt;/a&gt;입니다.&lt;/p&gt;

&lt;p&gt;일반적으로 TLS의 경우 암호화 키를 상호 교환하기 위해서 2 RTT를 필요로 합니다. 첫번째 왕복에서 client hello 메시지를 통해서 프로토콜 버전, 암호화 알고리즘 등을 전달하고 서버는 응답으로 server hello, certificate 메시지를 통해서 서버 인증서, 사용할 암호화 알고리즘 등을 전달하고 두번째 왕복에서는 첫번째 왕복에서 만들어진 세션 키를 통해서 암호화된 메시지를 주고 받고 서로 확인하는 과정입니다. TCP + TLS의 경우 이 경우 실제 데이터를 보내기 위한 연결을 만들기 위해 1 RTT (TCP) + 2 RTT (TLS) = 3 RTT가 소요되므로 지연 시간이 큰 경우 데이터를 보내기 이전에 암호화 연결을 만들기 위해 많은 시간이 걸리게 됩니다.&lt;/p&gt;

&lt;p&gt;RTT를 포함한 성능 개선을 위해 TLS 계층에서 사용될 수 있는 방법은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://tools.ietf.org/html/rfc5077"&gt;RFC 5077 Stateless TLS Session Resumption&lt;/a&gt;은 최초에 만들어졌던 TLS 세션 정보를 클라이언트에서 보관 했다가 두번째 같은 서버에 다시 접속하는 경우 만들었던 세션 티켓을 사용하여 TLS 핸드쉐이크 과정의 2 RTT를 1 RTT로 줄일 수 있습니다. 기존에 동일 목적을 위해서 세션 ID를 사용하였으나 이 경우 서버에서 세션 상태를 보관하고 있어야 하는 문제가 있었는데 RFC 5077은 클라이언트에서만 상태를 보관하는 장점이 있습니다. 이 기법은 TLS 1.1 이후에서 사용할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://tools.ietf.org/html/rfc8446"&gt;RFC 8446 TLS 1.3&lt;/a&gt; TLS의 최신 버전은 2018년에 발표된 1.3인데, TLS 1.3의 중요한 개선점으로 0-RTT 연결이 있습니다. 이는 RFC 5077과 유사하게 첫번째 TLS연결의 정보를 포함하고 있다가 조건이 만족 되면 TLS cliethello를 보낼 때 요청 데이터 암호화해서 같이 보낼 수 있도록 하는데, 이 경우 TCP Fast Open과 유사하게 TLS 연결에서 0-RTT가 가능 합니다. 즉 기존의 TLS연결에 2 RTT가 걸렸다면 조건이 만족되면 0 RTT에 TLS 암호화 연결 및 요청 데이터를 한번에 보낼 수 있습니다(TCP연결은 되어 있다고 가정 합니다).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 두 기법은 각각 1 RTT, 2 RTT를 절약할 수 있습니다. 자세한 사항은 &lt;a href="https://blog.cloudflare.com/introducing-0-rtt/"&gt;Introducing Zero Round Trip Time Resumption (0-RTT)&lt;/a&gt;을 참조 하시기 바랍니다.&lt;/p&gt;

&lt;p&gt;아래의 두 기법은 직접 RTT를 줄일 수 없지만 TLS 연결 상의 부가적인 지연을 줄일 수 있는 기법입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/OCSP_stapling"&gt;OCSP Stapling&lt;/a&gt; - OCSP는 TLS 인증서의 상태를 확인하기 위한 프로토콜인데 보통 인증서 파기 여부를 확인하기 위해 사용됩니다(과거에는 CRL이라는 것을 사용 했습니다). 이 프로토콜을 사용하는 경우 TLS 클라이언트 (보통 브라우저) 인증서 상태 확인을 위해 별도의 OCSP에 통신하는 시간만큼 지연이 발생 하는데 OCSP Stapling은 TLS 핸드쉐이크 과정에서 TLS서버에서 인증서 상태에 대한 확인 정보를 보내므로 클라이언트가 확인할 필요가 없어지는 장점이 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://blog.cloudflare.com/optimizing-tls-over-tcp-to-reduce-latency/"&gt;동적 레코드 크기 조절&lt;/a&gt; TLS는 데이터 전송을 위해 레코드를 정의하고 레코드 단위로 암호화된 데이터를 보냅니다. 이 레코드는 최대 16KB의 크기를 갖는데, TCP위에서 전송하는 경우 레코드 경계가 TCP 패킷 경계와 일치한다는 보장이 없으므로, TLS 레코드 크기가 한 TCP 패킷 크기보다 큰 경우 중간의 TCP 패킷이 유실된 경우 복구에 시간이 걸릴 수 있습니다. 또한 TCP 연결 초기 슬로우 스타트 구간에 큰 TLS 레코드 전송을 하는 경우, 실제 데이터가 브라우저에 전달 될 때 까지 복수의 왕복 시간이 걸릴 수 있습니다. 이 문제를 완화하기 위해 연결 초기의 경우 TLS 레코드 크기를 일부러 하나의 TCP 패킷 크기 (MSS)이하로 맞추어 보내는 기법을 동적 레코드 크기 조절이라고 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 기법을 활용하기 위해서는 클라이언트와 서버가 모두 해당 기능을 지원해야 하는 문제가 있습니다. 최신 버전인 TLS 1.3을 사용하도록 하는 것이 제일 좋습니다만 기존의 많은 프로그램이 업데이트되려면 상당한 기간이 필요할 것입니다.&lt;/p&gt;

&lt;h3 id="head-of-line-blocking-문제"&gt;Head-of-Line Blocking 문제&lt;/h3&gt;

&lt;p&gt;HTTP/1.1에는 하나의 TCP 연결을 열어서 여러 요청을 순차적으로 보낼 수 있는
연결 재사용(keep-alive)기능이 있습니다. TCP연결을 다시 열어도 되지 않고
HTTPS를 사용하는 경우 TLS연결에 필요한 시간도 절약할 수 있다는 장점이
있습니다만 여기에는 문제점이 있습니다.&lt;/p&gt;

&lt;p&gt;보통 Head-of-Line Blocking (HoL Blocking)
이라고 하는데 (딱히 좋은 번역이 없습니다. 이 글에서는 HoLB라고 하겠습니다),
하나의 TCP 연결은 신뢰성 있는 데이터 전송을 제공해야 하므로 중간에 패킷이
유실된 경우 반드시 복구를 해야 합니다. 이 특성 때문에 한 TCP 연결에서
HTTP 요청을 순차적으로 여럿 보내는 경우 중간에 있는 요청이나 응답에서
패킷 유실이 발생하는 경우 복구될 때 까지 지연 시간이 발생하고 그 다음 요청도
그만큼 지연되게 됩니다. 이 문제를 HoLB라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-03-26/holb.png" alt="Head-of-Line Blocking" width="70%" /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 하나의 TCP 연결에서 일어나는 3개의 HTTP 요청과 응답을 나타내고 있습니다.
첫번째 요청(&lt;code class="highlighter-rouge"&gt;/&lt;/code&gt;)은 잘 처리 되었지만 두번째 요청(&lt;code class="highlighter-rouge"&gt;/a.png&lt;/code&gt;)는
중간의 패킷 유실 (X로 표시된) 이 발생할 경우 TCP 수준에서 복구를 위한 재전송이
일어날 때 까지 데이터 전송이 지연된 것을 알 수 있는데,
이는 즉 두번째 응답을 받는 시간 및 세번째 요청(&lt;code class="highlighter-rouge"&gt;/b.png&lt;/code&gt;)을 보내는
시간이 그만큼 지연된다는 것을 의미 합니다. 하나의 연결에서
순차적으로 요청을 보내는 경우에는 이러한 중간의 패킷 유실이 전체 성능을 크게
저하시킬 수 있습니다. &lt;a href="https://en.wikipedia.org/wiki/HTTP_pipelining"&gt;HTTP Pipelining&lt;/a&gt; 이라는 기법도 제안된 바 있습니다만 실제로는 사용되지 않고
하나의 TCP연결을 사용하는 한 HoLB도 그대로 존재 합니다.&lt;/p&gt;

&lt;p&gt;여기에 추가하여 가용한 대역폭을 효과적으로 활용하기 위해서
HTTP/1.1 에서는 복수개의 TCP연결을 열어서 여러 HTTP 요청을 각 TCP 연결에 분배해서
처리하는 것이 일반적입니다.
Chrome 이나 Firefox 의 경우 &lt;a href="https://stackoverflow.com/questions/985431/max-parallel-http-connections-in-a-browser"&gt;기본값이 호스트 이름 당 최대 6개&lt;/a&gt;의 TCP연결을 열 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음 그림은 HTTP 1.1에서 TLS 연결을 병렬로 4개 열어서 5개의 요청을 보내는
것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-03-26/http11.png" alt="HTTP 1.1" width="70%" /&gt;&lt;/p&gt;

&lt;p&gt;이는 성능상의 이점은 있을지 모르지만 한 브라우저가 서버에 여러개의 연결을
열게 되므로 서버에 그만큼 부담이 가는 문제가 발생 합니다. 게다가
병렬 연결 수는 호스트 단위로 제한된다는 점을 이용하여
같은 서버에 여러개의 이름을 만들어서 연결 갯수를 더 늘리고자 하는
&lt;a href="https://www.keycdn.com/support/domain-sharding"&gt;도메인 샤딩&lt;/a&gt; (가령 이미지 파일이
img.foo.com에 있는 경우 img1.foo.com, img2.foo.com 과 같이 동일한
내용의 호스트 이름을 더 만들면 그만큼 TCP연결을 더 만들 수 있습니다)과 같은
기법도 사용되고 있습니다. 이 기법은 서로 다른 호스트명을 사용하는 만큼
DNS 요청 시간이 추가로 필요하고 서버 입장에서는
더 많은 부하로 작용 합니다.&lt;/p&gt;

&lt;p&gt;또한 병렬 TCP 연결을 사용하는 경우의 생각해 봐야 하는 문제가 하나 더 있습니다.
TCP의 혼잡 제어는 연결 단위로 이루어 집니다. 즉 동일 서버로 여러개의 TCP 연결이 생기는 경우 각각의 연결 마다 혼잡 제어를 하게 되는데, 서버까지 동일한 경로라면 하나의 혼잡 제어를 통하는 것이 보다 대역폭을 효율적으로 사용할 수 있습니다. 또한 큰 파일 다운로드가 아니라 웹 페이지와 같이 상대적으로 짧은 연결이 여러개 일어나는 경우라면 사용 가능한 대역폭을 모두 사용하지 못하는 경우가 많은데, 여러개의 병렬 연결 대신 하나의 연결로 여러 HTTP요청을 보낼 수 있다면 대역폭을 보다 효율적으로 이용할 수 있고 이런 생각이 HTTP/2의 멀티플렉싱으로 이어 집니다.&lt;/p&gt;

&lt;p&gt;HTTP/2의 멀티플랙싱의 경우는 아래 그림처럼 하나의 TLS연결에 여러개의 요청을
넣어서 보낼 수 있습니다. 실제로는 적절한 크기의 프레임 단위로 각 요청과 응답을
나누어서 보내게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-03-26/http2.png" alt="HTTP 2 멀티플렉싱" width="70%" /&gt;&lt;/p&gt;

&lt;p&gt;이 방법은 리소스를 절약하고 대역폭의 효과적인 사용을 가능하게 합니다만, 하나의
TCP연결을 사용하고 있으므로 위에서 언급한 HoLB문제가 여전히 존재 합니다.&lt;/p&gt;

&lt;h3 id="종단간-암호화-문제"&gt;종단간 암호화 문제&lt;/h3&gt;

&lt;p&gt;TLS를 사용하면 데이터 통신상의 암호화 문제는 대부분 해결이 됩니다.
TLS 1.3 에서는 기존 1.2까지에서 암호화하지 않던 핸드쉐이크 과정을 추가로
암호화해서 인증서도 암호화 된 상태로 전달이 되고, 평문으로 노출이 되던
SNI 확장의 경우 &lt;a href="https://blog.cloudflare.com/encrypted-sni-ko/"&gt;ESNI&lt;/a&gt;를 사용하면
추가로 암호화가 가능해 집니다.&lt;/p&gt;

&lt;p&gt;하지만 여전히 TLS는 TCP위에서 동작하게 되므로 TCP 연결을 추적하는 경우
TLS연결에 대해서도 어느정도 정보를 얻을 수 있고, 연결을 변조할 수는 없지만
중간에서 RST패킷을 조립해서 보내는 방법으로 강제로 종료시킬 수 있습니다.&lt;/p&gt;

&lt;p&gt;이러한 중간 장비의 개입을 추가로 방지하기 위해서라면 TCP 헤더에 평문으로
노출이 되는 정보까지 모두 암호화해야 할 필요성이 제기 됩니다.
이 부분은 TCP + TLS 기반의 HTTP/2 에서는 해결되지 못하는 부분입니다.&lt;/p&gt;

&lt;h2 id="http-20"&gt;HTTP 2.0&lt;/h2&gt;

&lt;p&gt;위에서 언급된 문제를 해결하기 위해서 기존의 HTTP/1.1을 보완하기 위한
&lt;a href="https://tools.ietf.org/html/rfc7540"&gt;HTTP/2&lt;/a&gt; 가 2015년에 발표되었지만,
아직도 HTTP/2를 적용하지 않은 사이트도 많습니다. &lt;a href="https://w3techs.com/technologies/details/ce-http2/all/all"&gt;Usage of HTTP/2 for websites&lt;/a&gt;에 따르면 전세계 웹사이트의 34.1% (2019년 3월 기준)이 사용중이라고 하니 아마 국내에서의 도입율은 더 낮을 것으로 생각이 됩니다.
가령 &lt;a href="https://www.naver.com"&gt;www.naver.com&lt;/a&gt;은 HTTP/2 로 응답합니다만
&lt;a href="https://www.daum.net"&gt;www.daum.net&lt;/a&gt;은 HTTP/1.1로만 응답하고 있습니다.&lt;/p&gt;

&lt;p&gt;확인을 위해서 http2기능이 포함된 curl 을 사용해 보도록 합니다. 네이버의 경우&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% curl -vso/dev/null https://www.naver.com
* Connected to www.naver.com (210.89.164.90) port 443 (#0)
* ALPN, offering h2
* ALPN, offering http/1.1
...
* ALPN, server accepted to use h2
...
&amp;gt; GET / HTTP/2
...
&amp;lt; HTTP/2 200
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 ALPN에서 h2 라고 응답하고 실제 요청에 &lt;code class="highlighter-rouge"&gt;HTTP/2&lt;/code&gt; 로 응답하는 것을
볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;daum의 경우 아래와 같이 http/1.1 으로 응답하는 것을 볼 수 있습니다.&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% curl -vso/dev/null https://www.daum.net
...
* ALPN, offering h2
* ALPN, offering http/1.1
...
* ALPN, server accepted to use http/1.1
...
&amp;gt; GET / HTTP/1.1
...
&amp;lt; HTTP/1.1 200 OK
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;HTTP/2는 구글이 만든 &lt;a href="https://www.chromium.org/spdy/spdy-whitepaper"&gt;SPDY&lt;/a&gt;를
기반으로 표준화한 것이라 할 수 있는데, 멀티플렉싱, 헤더 압축, 우선순위 및 푸시 등은
SPDY의 주된 디자인 개념이기도 합니다.&lt;/p&gt;

&lt;p&gt;다음은 HTTP/2의 주요 특징 입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TCP와 같은 신뢰성 있는 전송 프로토콜 위에서 동작&lt;/li&gt;
  &lt;li&gt;바이너리 포맷&lt;/li&gt;
  &lt;li&gt;HTTP의 요청-응답 형태, 헤더나 각각의 헤더의 의미에 변화가 없음. 전송하는 방법만을 재정의함&lt;/li&gt;
  &lt;li&gt;멀티플렉싱 - 여러개의 HTTP 요청/응답을 하나의 TCP연결에서 보냄. 각각의 HTTP 요청/응답은 요청 별로 스트림이라는 단위로 전송 되고 스트림 안에 여러개의 프레임이 존재&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://tools.ietf.org/html/rfc7541"&gt;HPACK&lt;/a&gt; 기법을 통해서 요청/응답 헤더를 압축&lt;/li&gt;
  &lt;li&gt;흐름 제어 - 복수의 스트림이 단일 연결에서 전송되지만 각각의 흐름 제어를 통해서 클라이언트에서 받아들일 수 있을 만큼만 전송 가능&lt;/li&gt;
  &lt;li&gt;TLS에 의한 암호화 - HTTP/2는 스펙상 평문으로도 보낼 수 있지만 실제 브라우저는 모두 TLS 위에서만 동작&lt;/li&gt;
  &lt;li&gt;서버 푸시 - 클라이언트가 명시적으로 요청하지 않아도 서버가 선제적으로 보낼 수 있음&lt;/li&gt;
  &lt;li&gt;요청에 대해 우선순위 부여 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HTTP/2에 대한 더 자세한 설명은 &lt;a href="https://developers.google.com/web/fundamentals/performance/http2/"&gt;Introduction to HTTP/2&lt;/a&gt;, &lt;a href="https://daniel.haxx.se/http2/"&gt;http2 explained&lt;/a&gt;을 참조 하시기 바랍니다.&lt;/p&gt;

&lt;h2 id="정리하며"&gt;정리하며&lt;/h2&gt;

&lt;p&gt;이 글에서는 기존에 사용중인 프로토콜인 TCP, TLS, HTTP/2의 주된 성능 개선을 위한 기법을
알아 보았습니다. 이러한 기능을 지원하는 최신 버전의 브라우저와 웹 서버 및 클라우드,
CDN을 사용한다면 많은 성능 향상을 얻을 수 있습니다만,
다음과 같이 여전히 해결되지 않은 문제들이 남아 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하나의 TCP 연결을 사용하는 한 HoLB 회피 불가&lt;/li&gt;
  &lt;li&gt;TCP를 업그레이드하려면 OS 수준의 클라이언트 및 서버 변경 필요&lt;/li&gt;
  &lt;li&gt;TLS를 업그레이드하려면 클라이언트 및 서버의 변경 필요&lt;/li&gt;
  &lt;li&gt;중간 장비 (middlebox)의 고착화 문제로 TCP나 TLS의 성능 개선 기법이 적용되지 않는 경우&lt;/li&gt;
  &lt;li&gt;중간 장비에 의한 데이터 변조 및 필터링&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;QUIC은 기존에 해결된 방법을 그대로 활용하면서 남아있는 문제를 해결하기 위해 새로운 접근 방법을 제시하고 있다고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음 편에서는 QUIC의 특징에 대해서 알아 보도록 하겠습니다.&lt;/p&gt;&lt;img src="http://feeds.feedburner.com/~r/saturnsoft/~4/cmw6GiveaeQ" height="1" width="1" alt=""/&gt;</content><author><name>Junho Choi</name></author><summary type="html">1편이 주로 기존 전송 프토토콜의 확장성 문제를 다루었다고 한다면 2편에서는 프로토콜의 성능 문제 및 기존의 개선 사항을 알아 보도록 하겠습니다. 이 글의 성능 개선 기법을 이해 한다면 QUIC의 디자인이 더 쉽게 이해될 것입니다.</summary><feedburner:origLink>https://www.saturnsoft.net/network/2019/03/26/quic-http3-2/</feedburner:origLink></entry><entry><title type="html">QUIC과 HTTP/3 - 1. UDP기반 전송 프로토콜의 대두</title><link href="http://feedproxy.google.com/~r/saturnsoft/~3/KbZozQ5r-HM/" rel="alternate" type="text/html" title="QUIC과 HTTP/3 - 1. UDP기반 전송 프로토콜의 대두" /><published>2019-03-21T00:00:00+00:00</published><updated>2019-03-21T00:00:00+00:00</updated><id>https://www.saturnsoft.net/network/2019/03/21/quic-http3-1</id><content type="html" xml:base="https://www.saturnsoft.net/network/2019/03/21/quic-http3-1/">&lt;p&gt;2000년대 후반부터 구글의 &lt;a href="https://developers.google.com/speed/"&gt;Make The Web Faster&lt;/a&gt;로
대표될 수 있는 인터넷과 웹 페이지 속도 향상을 위한 일련의 성과가 있습니다.
이런 노력들은 실로 다방면에 걸쳐 있는데, 웹 브라우저 (&lt;a href="https://www.google.com/chrome/"&gt;Chrome&lt;/a&gt;), 압축 이미지 포맷 (&lt;a href="https://developers.google.com/speed/webp/"&gt;WebP&lt;/a&gt;),
페이지 최적화 (&lt;a href="https://developers.google.com/speed/"&gt;PageSpeed&lt;/a&gt;), 데이터 압축 (&lt;a href="https://github.com/google/brotli"&gt;Brotli&lt;/a&gt;)과 같은 어플리케이션 계층의 성과도
있지만 전송 프로토콜 자체에도 많은 개량이 이루어 집니다.&lt;/p&gt;

&lt;p&gt;성능이나 보안 관련한 것들을 나열해 보면 전부는 아니지만 다음과 같은 것들이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TCP - &lt;a href="https://github.com/torvalds/linux/commit/30927520dbae297182990bb21d08762bcc35ce1d"&gt;리눅스 cubic 버그 수정&lt;/a&gt;, &lt;a href="https://tools.ietf.org/html/rfc7413"&gt;Fast Open&lt;/a&gt;, &lt;a href="https://datatracker.ietf.org/doc/draft-ietf-tcpm-rack/"&gt;RACK과 TLP&lt;/a&gt;, &lt;a href="https://github.com/google/bbr"&gt;BBR 혼잡 제어&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/SPDY"&gt;SPDY&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/SPDY"&gt;NPN과 ALPN&lt;/a&gt; - 이후에 &lt;a href="https://http2.github.io/"&gt;HTTP/2 표준&lt;/a&gt;의 기반이 됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://tools.ietf.org/html/rfc7918"&gt;TLS false start&lt;/a&gt;, &lt;a href="https://tools.ietf.org/html/rfc5077"&gt;session resumption&lt;/a&gt; - &lt;a href="https://tools.ietf.org/html/rfc8446"&gt;TLS 1.3 표준&lt;/a&gt;에서 개선/흡수 합니다.&lt;/li&gt;
  &lt;li&gt;DNS - &lt;a href="https://developers.google.com/speed/public-dns/"&gt;Google Public DNS&lt;/a&gt;, &lt;a href="https://1.1.1.1/"&gt;1.1.1.1&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/DNS_over_TLS"&gt;DNS over TLS&lt;/a&gt;, &lt;a href="https://blog.apnic.net/2018/10/12/doh-dns-over-https-explained/"&gt;DNS over HTTPS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 항목 하나하나도 큰 주제이긴 하지만, 이 글에서는 위에서 언급된
여러가지 기능을 하나로 모아서 새로 만들어진 UDP기반의 새로운 전송 프로토콜인
&lt;a href="https://en.wikipedia.org/wiki/QUIC"&gt;QUIC&lt;/a&gt; 그리고 조금씩 이야기가 들려오고 있는 &lt;a href="https://quicwg.org/base-drafts/draft-ietf-quic-http.html"&gt;http3&lt;/a&gt; 에 대해서 간단히 다루어
보도록 하겠습니다.&lt;/p&gt;

&lt;h3 id="udp-기반으로-전송-프로토콜을-만드는-이유"&gt;UDP 기반으로 전송 프로토콜을 만드는 이유&lt;/h3&gt;

&lt;p&gt;이미 TCP가 잘 동작하고 있고 UDP는 DNS나 스트리밍 등에 쓰이는 것으로
아는데 왜 UDP 기반으로 전송 프로토콜을 만들까요? 그 전에 널리 사용되고
있는 TCP의 한계점, 그리고 UDP가 아니라 새로운 프로토콜을 정의했을 때의
한계와 문제점에 대해서 먼저 생각해 봅니다.&lt;/p&gt;

&lt;p&gt;UDP로 전송 프로토콜을 만드는 것은 아주 새로운 아이디어는 아닙니다. 기존의
RTP(Real-time Transport Protocol)과 같이 실시간 미디어 전송을 위한
프로토콜이 UDP기반으로 동작하고 있지만, QUIC은 웹 페이지와
같은 보다 일반적인 사용을 목표로 하고 있습니다.&lt;/p&gt;

&lt;h4 id="tcp의-한계와-문제점"&gt;TCP의 한계와 문제점&lt;/h4&gt;

&lt;p&gt;TCP는 70년대 개발된 이래 인터넷의 중추적인 전송 프로토콜 역할을 하고 있습니다.
설계 특성상 신뢰성 있는 전송과 혼잡 제어를 통해서 대역폭을 사전에 알 수 없고
가변적인 구간에서도
자동적으로 최적의 대역폭으로 데이터를 양방향 전송 가능한 것이 최대의 특징인데,
그러다 보니 FTP, HTTP, SMTP 등의 상위 프로토콜을 전송하는 기반으로 사용 됩니다.
인터넷 되는 운영체제라고 하면 모두 기본적으로 TCP 와 BSD 소켓 구현이 포함되어
있습니다.&lt;/p&gt;

&lt;p&gt;첫번째 한계는 오래전에 설계된 프로토콜인 관계로 확장성이 부족하다는 점입니다.
아래 그림은 TCP 헤더 포맷을 나타내고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-03-21/tcp.png" alt="tcp" /&gt;
&lt;a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol"&gt;Wikipedia - TCP&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;위 그림에서 알 수 있는것은 어떤 기능 확장을 위해서는 Options 필드를 사용해야 하는데
Options 필드의 최대 크기는 320비트 즉 40바이트로 정해져 있습니다. 현재 이미
MSS, Window Scale, Selective ACK, TCP timestamp 등의 거의 기본으로 사용되는
옵션들이 모두 사용 중이고, 그 중 크기를 가장 많이 차지하는 것이 Selective ACK인데
Options 필드의 크기 제약으로 인해서 최대 4 구간 (1 구간이 8바이트를 사용)만을
전달할 수 있고, 여기에 TCP timestamp 를 포함시키면 3구간만 전달 가능할 정도로
추가 정보의 전달에 이미 한계가 온 상황입니다.&lt;/p&gt;

&lt;p&gt;물론 RACK, TLP와 같은 기능들은 이러한 추가 데이터 전달 없이 전송의 안정성과
속도를 향상시키려는 노력의 산물입니다만 그러다 보니 구현상 제약이 생겨나고 있습니다.&lt;/p&gt;

&lt;p&gt;두번째로는 너무 널리 사용되고 있고 헤더 자체가 암호화가 되지 않은 상태로
전달되다 보니 외부에서 관찰하기가 쉽고 표준이 이미 정해진 관계로 외부에서
패킷에 손을 대는 일이 가능하다는 것입니다. 가령 TCP패킷을 캡처할 수 있다면
TCP 패킷을 분석해서 시작과 끝, 현재의 전송 상태 등을 유추하는 일이 가능해지고
이걸 기반으로 다양한 처리가 가능해 집니다. 일반적인 방화벽을 생각하면 되는데
가령 상태 기반 방화벽 (stateful) 이라는 것이 바로 TCP 연결 상태를 추적하는
것으로 생각하면 됩니다. TCP 연결 추적을 위해서는 위 헤더에 있는 시퀀스, ACK 번호와
SYN, FIN등의 플래그를 이용해서 추적을 하는데 없던 플래그를 추가 하거나
기존 동작을 바꾸게 되면 어떻게 될까요?&lt;/p&gt;

&lt;p&gt;실제 네트워크 상에는 방화벽 이외에도 TCP 연결 자체를 사용자 모르게 가로채어
중간에서 연결을 종료 (termination 한다고 합니다. 연결을 끊는다는 의미가 아니라
논리적인 TCP연결이 되는 곳을 이야기 합니다) 하고 새 연결을 사용자과 다시
맺도록 하는 장비들도 많이 존재 합니다. 이런 것들은 주로 TCP로 전송되는 데이터
내용을 관찰하거나 변조, 접근 제어, 캐싱, 가속 등을 위한 목적으로 이용 됩니다.&lt;/p&gt;

&lt;h4 id="미들박스와-고착화-문제"&gt;미들박스와 고착화 문제&lt;/h4&gt;

&lt;p&gt;이러한 상황이다 보니 프토토콜을 쉽게 확장할 수 없는 또 다른 이유도 되는데,
TCP의 동작 자체가 이미 잘 알려져 있다 보니 이러한 중간 장비(middlebox)가
알려져 있는 TCP 동작 기반으로 기능을 수행하도록 만들어진 것들이
많기 때문입니다. 이 경우 프로토콜 스펙이 변하는 경우 대응하지 못하기도
합니다.&lt;/p&gt;

&lt;p&gt;가령 TCP Fast Open 의 예를 들 수 있는데, Fast Open은 TCP 연결을 맺기 위해
수행되는 3단계 핸드쉐이크를 축약해서 1단계만으로 TCP연결을 가능하게 합니다.
즉 일반적으로 알고 있는 SYN -&amp;gt; SYN+ACK -&amp;gt; ACK 을 거쳐서 데이터 연결을
맺는 것이 아니라 바로 SYN + 데이터 로 바로 연결이 시작이 되는데, 가령
중간에 있는 상태 기반 방화벽 장비가 Fast Open 에 대해서 알지 못하면
오동작하거나 연결을 끊게 되는 문제가 발생하게 됩니다.&lt;/p&gt;

&lt;p&gt;이러한 문제는 고착화(Ossification)이라고 불리기도 하는데, 오랜 기간 동안
널리 사용되는 것들의 경우 다들 사용하는 관계로
오히려 확장이 어려워지는 역설적인 문제가 존재합니다.&lt;/p&gt;

&lt;h4 id="그럼-새-프로토콜을-정의하면-안되나요"&gt;그럼 새 프로토콜을 정의하면 안되나요?&lt;/h4&gt;

&lt;p&gt;프로토콜은 어떤 수준에서 정의되어 있는지에 따라 계층이 다릅니다. 가령
TLS나 HTTP와 같은 프토토콜은 신뢰성 있는 전송 계층 위에서 동작할 수 있고
일반적으로는 TCP가 그 역할을 수행 합니다.&lt;/p&gt;

&lt;p&gt;그럼 TCP는 어디서 정의되어 있을까요? TCP 패킷인지의 여부는
해당 패킷의 IP 헤더 포맷의 Protocol 필드의 값을 보면 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-03-21/ipv4.png" alt="ipv4" /&gt;
&lt;a href="https://en.wikipedia.org/wiki/IPv4"&gt;Wikipedia - IPv4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Protocol 필드는 1바이트인데 &lt;a href="https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers"&gt;IANA에서 정한 프로토콜 번호 목록&lt;/a&gt; 중에서 사용하게 됩니다. MacOS나 FreeBSD, Linux 등을
사용하고 있다면 &lt;code class="highlighter-rouge"&gt;/etc/protocols&lt;/code&gt;파일을 열어 보면 쉽습니다.&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% grep tcp /etc/protocols
tcp	6	TCP		# transmission control protocol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;UDP도 같은 방법으로 찾아볼 수 있습니다.&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% grep udp /etc/protocols
udp	17	UDP		# user datagram protocol
crudp	127	CRUDP		# Combat Radio User Datagram
udplite	136	UDPLite		# The UDP-Lite Protocol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 파일을 열어 보면 처음 보는 프로토콜들이 많을 것입니다. 그만큼
특수 목적으로 사용되거나 정의만 되었지 실제 사용되지 않는 프로토콜이 대부분이고
실제 인터넷 트래픽은 TCP와 UDP가 거의 전부라고 해도 과언은 아닐 것입니다. 가령
HTTP는 TCP 위에서 동작하고 DNS는 UDP나 TCP위에서 동작 합니다.&lt;/p&gt;

&lt;p&gt;이러다 보니 TCP나 UDP가 아니면 아예 통과하지 못하는 라우터나 방화벽들도
존재하고 방화벽 설정을 할 때 TCP나 UDP 트래픽이 아니면 모두 막도록 설정하는
경우도 많습니다. 또한 가정용 라우터와 같이 NAT환경을 기본적으로 만드는 경우
TCP나 UDP가 아니라면 제대로 주소 변환이 안 될 수도 있습니다.&lt;/p&gt;

&lt;p&gt;이것이 어떤 문제를 일으키는가 하면
만약 여러분이 멋진 새 프로토콜을 하나 정의했다고 해도 그것이 실험실
밖으로 나왔을 때 인터넷상에서 항상 전송 가능한지 보장이 안된다는 것입니다.&lt;/p&gt;

&lt;p&gt;실제로 &lt;a href="https://tools.ietf.org/html/rfc4960"&gt;SCTP&lt;/a&gt;라는 TCP의 제약을 일부 개선한 프로토콜이 있습니다만
만약 이것으로 클라이언트와 서버를 둘 다 만들었다고 해도 언제 어디서
SCTP패킷이 통과될지는 잘 보장되지 않는다는 현실적인 문제가 &lt;a href="https://stackoverflow.com/questions/1171555/why-is-sctp-not-much-used-known"&gt;보급의 장애&lt;/a&gt;가 되고 있습니다.&lt;/p&gt;

&lt;p&gt;다만 잘 정의된 제한적인 용도라면 큰 문제가 아닐 수도 있습니다. 예를 들어 SCTP는
&lt;a href="https://ltesignaling.blogspot.com/2012/04/stream-control-transmission-protocol.html"&gt;LTE와 같은 모바일 코어 네트워크 내에서 사용&lt;/a&gt;되고 있습니다.&lt;/p&gt;

&lt;h4 id="프로토콜-스택은-역시-커널에-만들어야지"&gt;프로토콜 스택은 역시 커널에 만들어야지!&lt;/h4&gt;

&lt;p&gt;새 프로토콜을 만들었을 때 일반적으로 TCP 구현처럼 커널에 구현되는 것이
대부분입니다. 하지만 아무리 모듈로 만든다고 해도 커널에 새 프로토콜을 구현하는 것은
일반 어플리케이션 대비 쉬운 일이 아니며, 만들었다고 해도 실제 사용을 위해서는
해당 서버와 클라이언트가 모두 해당 프로토콜이 구현되어 있는 커널 내지는
커널 모듈을 설치해야 한다는 현실적인 문제가 존재 합니다.&lt;/p&gt;

&lt;p&gt;특히 인터넷 상에서 일반적으로 사용하기 위해서는 여러가지 클라이언트를 지원해야
하는데, PC는 물론이고 모바일 클라이언트의 경우에는 시스템 권한을 가질 수 없는
경우가 대부분이기 때문에 새로 프로토콜을 만들었다고 해도 보급하는 것은
OSS 운영체제가 아닌 경우 OS벤더가 아니면 어렵다고 봐야 할 것입니다.&lt;/p&gt;

&lt;h3 id="udp-기반-전송-프로토콜의-대두"&gt;UDP 기반 전송 프로토콜의 대두&lt;/h3&gt;

&lt;p&gt;위에서 언급한 제반 사정이 있다 보니 그럼 TCP 기반이 아닌 새 프로토콜을 만들어서
인터넷 상에서 보급하고자 한다면 선택이 매우 제한적일 수 밖에 없는데, 따라서 UDP를
어떻게 활용하는지가 매우 중요하게 됩니다.&lt;/p&gt;

&lt;h4 id="udp는-신뢰성이-없다고-하던데"&gt;UDP는 신뢰성이 없다고 하던데..&lt;/h4&gt;

&lt;p&gt;인터넷 네트워크를 배운 적이 있다면 TCP는 신뢰 가능한 전송 프로토콜, UDP는
신뢰성이 없다고 배웠을 것입니다. 신뢰성이 없다는 의미를 더 생각해 보면, UDP는
그냥 데이터를 실어 보낼 수 있을 뿐 그 이외의 기능은 아무것도 정의해 놓지 않았습니다.
UDP는 User Datagram Protocol의 약자인데 U를 Unreliable이라고 생각하는 사람도
적지 않을 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-03-21/udp.png" alt="udp" /&gt;
&lt;a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol"&gt;Wikipedia - UDP&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 UDP 헤더 포맷입니다. 전송 순서를 알기 위해서 시퀀스나 ACK 번호를 헤더에
정의해 놓은 TCP와는 달리 UDP 헤더에는 포트 번호와 패킷 크기, 체크섬만 있고,
체크섬은 굳이 채워넣지 않아도 됩니다. 따라서 신뢰성을 보장할 수단이
존재하지 않는 것입니다.&lt;/p&gt;

&lt;p&gt;다만 달리 생각하면 이건 백지와도 같은 것입니다. User Datagram 이라는 의미가
바로 사용자가 정의해서 사용하라는 의미입니다. 즉 여기에 원하는 기능을 얼마든지
얹으면 되고 서버와 클라이언트의 구현에 따라서 그 동작은 매우 달라질 수 있습니다.
즉 TCP와 같은 신뢰성 있는 전송을 원한다면 TCP와 같이 시퀀스 번호 등을 정의하고
서버와 클라이언트 간에 패킷 유실이나 순서 바뀜에 어떻게 대처할 것인지를 상호
정의 한다면 UDP기반의 신뢰성 있는 전송 프로토콜을 만들 수 있습니다.
&lt;a href="https://en.wikipedia.org/wiki/UDP-based_Data_Transfer_Protocol"&gt;UDT&lt;/a&gt;와 같은
UDP기반의 파일 전송 어플리케이션을 생각해 보면 됩니다.&lt;/p&gt;

&lt;h4 id="사용자-수준에서-프로토콜-스택이-작성-가능"&gt;사용자 수준에서 프로토콜 스택이 작성 가능&lt;/h4&gt;

&lt;p&gt;UDP 기반으로 전송 프로토콜을 만들게 되는 또 다른 이유는 바로 사용자 수준
네트워크 프로토콜 스택을 만드는 것이 크게 어렵지 않기 때문입니다. 만약 IP에
새 프로토콜 번호를 정의해서 프로토콜을 만든다면 일반 사용자 권한 만으로
서버와 클라이언트를 만드는 것은 거의 불가능 합니다만 (raw socket을 사용해도
그렇습니다) UDP라면 이미 거의 모든 OS에서 소켓 API를 통해서 송수신이
가능 하므로, 간단한 UDP 소켓 기반 서버를 작성하고 그 안의 로직을 채워
넣는 것으로 시작할 수 있습니다.&lt;/p&gt;

&lt;p&gt;또한 이 경우 OS의 커널에 접근할 필요도 없고 1024번 이하 포트를 사용하지
않는다면 관리자 권한도 필요 없으므로 일반 사용자 권한 만으로 서버와 클라이언트
모두 작성할 수 있다는 장점이 있습니다. 웹 브라우저의 &lt;a href="https://stackoverflow.com/questions/18897917/does-webrtc-use-tcp-or-udp"&gt;WebRTC는 이러한 특성을
이용해서 UDP도 사용하고 있다는 점&lt;/a&gt;도 참고할 수 있을 것입니다.&lt;/p&gt;

&lt;h3 id="정리하며"&gt;정리하며&lt;/h3&gt;

&lt;p&gt;위에서 언급한 여러가지 이유로 인해 TCP의 한계를 극복하는 새로운 전송 프로토콜을 만들고자
한다면 UDP기반으로 하는 것이 최적의 선택이라는 점을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;QUIC(Quick UDP Internet Connections 이라고 처음에 불렸는데 지금은 어떤 것의 약어는 아닙니다)은 이러한 기반을 갖고 기존의 TCP, TLS, HTTP, 심지어 HTTP2의 여러가지 단점을 극복하고자 만들어진 프로토콜입니다. 다음 편에서는 QUIC이 해결하고자 하는 문제점에 대해서 조금 더 자세히 다루어 보도록 하겠습니다.&lt;/p&gt;&lt;img src="http://feeds.feedburner.com/~r/saturnsoft/~4/KbZozQ5r-HM" height="1" width="1" alt=""/&gt;</content><author><name>Junho Choi</name></author><summary type="html">2000년대 후반부터 구글의 Make The Web Faster로 대표될 수 있는 인터넷과 웹 페이지 속도 향상을 위한 일련의 성과가 있습니다. 이런 노력들은 실로 다방면에 걸쳐 있는데, 웹 브라우저 (Chrome), 압축 이미지 포맷 (WebP), 페이지 최적화 (PageSpeed), 데이터 압축 (Brotli)과 같은 어플리케이션 계층의 성과도 있지만 전송 프로토콜 자체에도 많은 개량이 이루어 집니다.</summary><feedburner:origLink>https://www.saturnsoft.net/network/2019/03/21/quic-http3-1/</feedburner:origLink></entry><entry><title type="html">Dell R710에 원격으로 FreeBSD 13.0-CURRENT 설치하기</title><link href="http://feedproxy.google.com/~r/saturnsoft/~3/5eSxn2DhwlQ/" rel="alternate" type="text/html" title="Dell R710에 원격으로 FreeBSD 13.0-CURRENT 설치하기" /><published>2019-03-04T00:00:00+00:00</published><updated>2019-03-04T00:00:00+00:00</updated><id>https://www.saturnsoft.net/freebsd/2019/03/04/freebsd-current-dell-r710-using-drac</id><content type="html" xml:base="https://www.saturnsoft.net/freebsd/2019/03/04/freebsd-current-dell-r710-using-drac/">&lt;p&gt;Dell R710에 FreeBSD설치를 원격으로 하는 방법에 대해서 간단히 설명합니다.
생각보다 원하는 대로 진행되지 않아서 시행착오를 일부 겪었습니다.&lt;/p&gt;

&lt;p&gt;다음 환경에서 진행 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Dell R710 에 FreeBSD 13.0-CURRENT 설치. 12나 11 릴리즈도 동일 방법으로 가능 합니다.&lt;/li&gt;
  &lt;li&gt;DRAC 으로 원격 콘솔에 접속해서 설치&lt;/li&gt;
  &lt;li&gt;Virtual Console과 Virtual CD사용에 윈도우와 IE 필요 (MacOS는 콘솔 접속만 가능)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="freebsd-이미지-다운로드하기"&gt;FreeBSD 이미지 다운로드하기&lt;/h3&gt;

&lt;p&gt;13.0-CURRENT (또는 현재의 -CURRENT 버전)은 다음 사이트에서 받을 수 있습니다.
이번에는 Virtual CD를 통해 설치할 예정이므로 CD 이미지를 받습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="ftp://ftp.freebsd.org/pub/FreeBSD/snapshots/ISO-IMAGES/13.0/"&gt;ftp.freebsd.org - 13.0-CURRENT ISO&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;한국에서는 ftp.freebsd.org 대신에 ftp.kr.freebsd.org 또는 ftp2.kr.freebsd.org 에서 받으면 빠르게 받을 수 있습니다.&lt;/p&gt;

&lt;p&gt;받을 수 있는 이미지는 플랫폼과 이미지 크기에 따라 다릅니다. 지금은 인텔 머신에 설치하는 것이므로 amd64를, 원격으로 CD부팅만 되면 나머지는 네트워크 설치로 진행할 것이므로 bootonly 이미지를 받습니다. 가까이서 접속하는 거라면 설치 파일이 다 들어 있는 disc1 이미지를 받아도 좋을 것입니다. 이번에는 bootonly 이미지를 받습니다. 동일한 파일에 .xz 가 되어 있는 것은 xz 로 압축되어 있는 버전이므로 다운로드받아서 xz로 압축을 풀어 사용하면 됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="ftp://ftp.freebsd.org/pub/FreeBSD/snapshots/ISO-IMAGES/13.0/FreeBSD-13.0-CURRENT-amd64-20190228-r344648-bootonly.iso"&gt;FreeBSD-13.0-CURRENT-amd64-20190228-r344648-bootonly.iso&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;또 하나 주의할 점은 CURRENT 설치의 경우 항상 최근 날짜의 이미지를 받아야 한다는 점입니다. 이 snapshot 디렉토리는 일주일 단위로 갱신 되므로 일주일 전의 bootonly 이미지를 받아서 설치하려 하면 설치 과정에서 오류가 납니다. 릴리즈의 경우는 그런 일은 없으니 불안하면 릴리즈 버전을 받아서 설치하기 바랍니다.&lt;/p&gt;

&lt;h3 id="drac-으로-원격-콘솔-연결"&gt;DRAC 으로 원격 콘솔 연결&lt;/h3&gt;

&lt;p&gt;Dell 서버에는 DRAC (Dell Remote Access Card)라고 하는 원격 콘솔 접속용 카드가 있습니다. 이걸 사용하면 OS 콘솔에 원격으로 접속이 가능하며 이 상태로는 OS설치 이전의 시스템 설정등을 모두 할 수 있으므로 매우 편리한 도구입니다. 일단 여기 원격으로 접속이 가능하도록 설정이 되어 있다고 할 때, 사이트에 접속하기 위해서는&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=""&gt;https://DRAC서버IP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;로 접속해서 사전에 설정된 ID와 암호로 로그인합니다. 인증서가 사설 인증서의 경우에는 브라우저에서 경고가 나오겠지만 무시하고 진행하면 됩니다.&lt;/p&gt;

&lt;p&gt;이후 DRAC에 접속 가능하면 아래 화면에서 Virtual Console Preview 오른쪽 하단의 Launch를 눌러서 콘솔에 연결 합니다. Console/Media 메뉴에서도 접속 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-03-04/drac.png" alt="drac" /&gt;&lt;/p&gt;

&lt;p&gt;Virtual Console 은 자바 어플리케이션이므로 적절한 자바 실행 권한이 필요 합니다.
일반적으로는 윈도우 환경 + 32비트 인터넷 익스플로러로 접속하는 것이 가장 쉽게 접속하는 방법입니다만, 이 글 끝에 MacOS에서의 Virtual Console 접속 방법도 설명 합니다. 단 실제 설치에는 Virtual Media 를 설정해야 하는데 MacOS에는 그게 되지 않아서 아래 설치는 MacOS X에 설치된 VMWare Fusion 에 설치된 윈도우 가상 머신에서 진행하였습니다.&lt;/p&gt;

&lt;h4 id="virtual-media에-iso-파일-연결"&gt;Virtual Media에 .iso 파일 연결&lt;/h4&gt;

&lt;p&gt;이제 받아 놓았던 iso 파일을 Virtual Console 의 Virtual Media -&amp;gt; “Add Image…“를 선택해서 FreeBSD iso 파일을 선택 하고, “Mapped”를 클릭해서 Virtual CD에 연결 해 둡니다. 그러면 해당 iso 파일이 가상의 CD로 동작 합니다.&lt;/p&gt;

&lt;h3 id="하드웨어-부팅"&gt;하드웨어 부팅&lt;/h3&gt;

&lt;p&gt;Virtual Console 에서 Power On 을 시키면 바이오스 부팅 화면이 나오는데 여기서 F11를 눌러서 BIOS Boot Manager를 실행 합니다. 그러면 화면이 다음과 같이 바뀌고 펌웨어 초기화 뒤에 부트 장치를 선택하게 됩니다. 물론 서버의 펌웨어 설정을 변경해야 하는 경우라면 (디스크 RAID설정 등)은 F2를 눌러서 시스템 셋업에서 진행 합니다. 이 경우 부트 방식은 UEFI가 아니라 BIOS로 해 두기 바랍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-03-04/boot1.png" alt="bios boot manager" /&gt;&lt;/p&gt;

&lt;p&gt;아래 화면까지 나오면 Virtual CD를 선택하면 Virtual Media에 연결된 ISO이미지로
부팅 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-03-04/boot2.png" alt="boot devices" /&gt;&lt;/p&gt;

&lt;h3 id="freebsd-설치-프로그램-시작"&gt;FreeBSD 설치 프로그램 시작&lt;/h3&gt;

&lt;p&gt;이제 FreeBSD 부트로더가 시작되는 걸 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-03-04/freebsd-bootloader.png" alt="freebsd bootloader" /&gt;&lt;/p&gt;

&lt;p&gt;Virtual CD의 경우 CD이미지를 DRAC에 접속한 클라이언트에서 네트워크로 전송하기 때문에
서버에 실제 CD를 넣어두지 않아도 되는 장점이 있지만 콘솔이 있는 클라이언트가
멀리 떨어져 있는 경우라면 시간이 오래 걸릴 수 있습니다. 같은 LAN안에 있다면
CD 속도와 그다지 다르지 않을 것입니다.&lt;/p&gt;

&lt;p&gt;다만 제 경우 다음 문제가 있었는데, 바로 부트로더가 커널을 읽은 후 설치 이미지로
부팅하지 않는 문제였습니다. 원래는 CD이미지 상에서 설치용 파일시스템을
루트로 마운트해야 하는데 이 동작이 실패하여 다음 프롬프트로 나갑니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-03-04/freebsd-bootloader-fail.png" alt="freebsd bootloader fail" /&gt;&lt;/p&gt;

&lt;p&gt;이 &lt;code class="highlighter-rouge"&gt;mountroot&amp;gt;&lt;/code&gt;는 커널이 루트 파일시스템을 찾지 못할 때 나옵니다. 따라서
사용할 수 있는 루트 파일시스템 장치를 다시 입력하면 되는데… 화면 도움말에
나와 있긴 하지만 그게 쉬운 일은 아닙니다.&lt;/p&gt;

&lt;p&gt;이걸 본 필자의 마음은…&lt;/p&gt;

&lt;p&gt;&lt;img src="https://media.giphy.com/media/d2YWTOsVtuHgOHhC/giphy-downsized.gif" alt="kevin" /&gt;&lt;/p&gt;

&lt;p&gt;인터넷 찾아 보아도 쉬운 해결책을 찾지 못하였는데, 콘솔 화면의 첫 행을 잘 보면&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;cd1: &amp;lt;iDRAC Virtual CD ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;라고 되어 있는 것을 보아 Virtual CD가 &lt;code class="highlighter-rouge"&gt;cd1&lt;/code&gt;으로 연결 된 것으로 보이므로,
&lt;code class="highlighter-rouge"&gt;/dev/cd1&lt;/code&gt;에서 부팅하기 위해 &lt;code class="highlighter-rouge"&gt;mountroot&amp;gt;&lt;/code&gt;프롬프트에서 &lt;strong&gt;침착하게&lt;/strong&gt; 다음을 입력 합니다.&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;mountroot&amp;gt; cd9660:/dev/cd1 ro
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;잘못되면 시스템 부팅부터 다시 시작 주세요. 11이나 12릴리즈를 설치하는 경우에도
이 문제는 동일하게 발생 합니다.&lt;/p&gt;

&lt;p&gt;단 CURRENT버전에서는 디버그 문제인지 설치하는 스냅샷의 문제인지 모르겠지만
위 프롬프트에서 엔터를 몇번 입력하면 커널 패닉에 빠지는 문제(!)가 있었습니다.
엔터를 무의미하게 입력하지 말고 위 프롬프트가 나오면 바로 위 구문을 입력해 주면
커널 패닉 없이 다음과 같이 설치 이미지 부팅이 진행이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-03-04/freebsd1.png" alt="freebsd install - logo" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-03-04/freebsd-welcome.png" alt="freebsd install - welcome" /&gt;&lt;/p&gt;

&lt;p&gt;이후에는 일반적인 FreeBSD 설치를 진행하면 별 무리 없이 끝납니다.&lt;/p&gt;

&lt;h3 id="freebsd-설치후-버전-확인"&gt;FreeBSD 설치후 버전 확인&lt;/h3&gt;

&lt;p&gt;설치 후에 로그인해서 버전을 확인해 봅니다.&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;# uname -a
FreeBSD &amp;lt;host&amp;gt; 13.0-CURRENT FreeBSD 13.0-CURRENT r344648 GENERIC  amd64
# freebsd-version -uk
13.0-CURRENT
13.0-CURRENT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;잘 되었네요.&lt;/p&gt;

&lt;p&gt;FreeBSD 11이나 12 릴리즈 버전도 동일하게 설치하면 됩니다. 단 ISO이미지는
버전에 맞는 걸 준비하기 바랍니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id="번외편-macos-x에서-drac-virtual-console-접속하기"&gt;번외편: MacOS X에서 DRAC Virtual Console 접속하기&lt;/h3&gt;

&lt;p&gt;공식적으로 DRAC 기능을 모두 이용 하려면 32비트 IE만 지원하는 것으로 보입니다만 MacOS X에서도 DRAC접속이 가능 합니다.
다만 시스템 설정을 일부 변경해야 하고 OS나 자바 버전에 따라서 설정 방법이 조금씩
다릅니다. &lt;a href="https://standalone-sysadmin.com/dracs-and-macs-and-java-hacks-b8864efa111f"&gt;DRACs and Macs and Java Hacks&lt;/a&gt;이 많이 도움이 되었는데 약간의 설정이 더 필요 하더군요.
아래 환경을 기준으로 설명 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DRAC에서 Console/Media -&amp;gt; Configuration -&amp;gt; Virtual Console -&amp;gt; Plug-in Type은 “Java”로 선택 합니다.&lt;/li&gt;
  &lt;li&gt;브라우저: Firefox 나 Chrome 둘 다 가능&lt;/li&gt;
  &lt;li&gt;MacOS X Mojave&lt;/li&gt;
  &lt;li&gt;Java: &lt;a href="https://java.com/en/download/help/mac_install.xml"&gt;MacOS X Java Install&lt;/a&gt;의 설명을 통해서 설치. 현재의 경우 Java 8 Update 201 이 설치되어 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 조건이 만족 되면, System Preference 의 Java 항목을 선택하고 아래를 변경 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Security Tab - “High”로 설정&lt;/li&gt;
  &lt;li&gt;Exception Site List의 “Edit Site List”를 클릭해서 DRAC 서버 주소를 추가 (https://drac-ip 를 입력하면 됩니다)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그리고 DRAC의 자바 프로그램이 오래된 인증서로 사인되어 있는 관계로 다음과 같이 java의 보안 설정을 일부 변경 합니다. 최신 버전의 DRAC이나 인증서가 업데이트 되면 필요하지 않을 수도 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;/Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/lib/security/java.security&lt;/code&gt;파일을 열어서 다음 행을 찾아 편집 합니다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class="highlighter-rouge"&gt;jdk.certpath.disabledAlgorithms=&lt;/code&gt;행을 찾아서 &lt;code class="highlighter-rouge"&gt;RSA keySize &amp;lt; 1024&lt;/code&gt;를 &lt;code class="highlighter-rouge"&gt;RSA keySize &amp;lt; 512&lt;/code&gt;로 변경 또는 삭제. 다음과 같이 보이면 됩니다. 아예 comment 처리하는 방법도 있겠지만 권장하지 않습니다.
        &lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;jdk.certpath.disabledAlgorithms=MD2, SHA1 jdkCA &amp;amp; usage TLSServer, \
RSA keySize &amp;lt; 512, DSA keySize &amp;lt; 1024, EC keySize &amp;lt; 224
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class="highlighter-rouge"&gt;jdk.jar.disabledAlgorithms=&lt;/code&gt;을 찾아서 &lt;code class="highlighter-rouge"&gt;MD5&lt;/code&gt;를 삭제하고 &lt;code class="highlighter-rouge"&gt;RSA keySize &amp;lt; 1024&lt;/code&gt;를 &lt;code class="highlighter-rouge"&gt;RSA keySize &amp;lt; 512&lt;/code&gt;로 변경. 다음과 같이 보이면 됩니다.
        &lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;jdk.jar.disabledAlgorithms=MD2, RSA keySize &amp;lt; 512, DSA keySize &amp;lt; 1024
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class="highlighter-rouge"&gt;jdk.tls.disabledAlgorithms=&lt;/code&gt;를 찾아서 &lt;code class="highlighter-rouge"&gt;RC4&lt;/code&gt;를 제거. 다음과 같이 보이면 됩니다.
        &lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;jdk.tls.disabledAlgorithms=SSLv3, DES, MD5withRSA, DH keySize &amp;lt; 1024, \
EC keySize &amp;lt; 224, 3DES_EDE_CBC, anon, NULL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Virtual Console 접속을 하면 viewer.jnlp 뒤에 서버 이름이나 타임스탬프가 붙는 복잡한 이름이 나옵니다. &lt;a href="https://chrome.google.com/webstore/detail/fix-idrac-jnlp-file/knpcepbijjjpmlhbpmkjknghbeghiibo?hl=en"&gt;Chrome의 경우 파일명을 변경해 주는 확장&lt;/a&gt;이 존재 합니다만 굳이 쓸 필요는 없고 jnlp파일을 다운로드받아 파일을 열 때 실행 어플리케이션으로 &lt;code class="highlighter-rouge"&gt;Java Web Start.app&lt;/code&gt;을 선택해 주면 됩니다. 이 파일은 &lt;code class="highlighter-rouge"&gt;/Applications&lt;/code&gt;에 존재하지 않고 &lt;code class="highlighter-rouge"&gt;/System/Library/CoreServices/Java Web Start.app&lt;/code&gt;에 있으므로 일일이 지정하는게 약간 귀찮습니다. 어플리케이션이 보이지 않는다면 찾는 조건을 “All Appplications”로 변경하면 선택할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이후에 브라우저에서 DRAC페이지에 접속 후 Virtual Console 에 접속하면 “Do you want to run this application?” 경고가 나오지만 “Run”을 눌러 진행 하면 됩니다. 위 &lt;code class="highlighter-rouge"&gt;java.security&lt;/code&gt;의 설정을 변경하지 않으면 이 다음에 아래 같이 “Unable to launch the application”또는 서버 접속이 아예 안 될 수 있으므로 이 경우 설정 파일 변경 사항을 다시 확인하기 바랍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-03-04/drac-macos-1.png" alt="drac error" /&gt;&lt;/p&gt;

&lt;p&gt;여기까지는 잘 되는데 Virtual Media 가 실행이 안되어서 ISO이미지 연결은 못 해 봤습니다. 가능한 방법을 찾으면 다시 추가 하도록 하겠습니다.&lt;/p&gt;&lt;img src="http://feeds.feedburner.com/~r/saturnsoft/~4/5eSxn2DhwlQ" height="1" width="1" alt=""/&gt;</content><author><name>Junho Choi</name></author><summary type="html">Dell R710에 FreeBSD설치를 원격으로 하는 방법에 대해서 간단히 설명합니다. 생각보다 원하는 대로 진행되지 않아서 시행착오를 일부 겪었습니다.</summary><feedburner:origLink>https://www.saturnsoft.net/freebsd/2019/03/04/freebsd-current-dell-r710-using-drac/</feedburner:origLink></entry><entry><title type="html">번역: 암호화하지 않으면 무용지물: 암호화된 SNI의 동작</title><link href="http://feedproxy.google.com/~r/saturnsoft/~3/gyw8_5xUgag/" rel="alternate" type="text/html" title="번역: 암호화하지 않으면 무용지물: 암호화된 SNI의 동작" /><published>2019-02-19T00:00:00+00:00</published><updated>2019-02-19T00:00:00+00:00</updated><id>https://www.saturnsoft.net/translation/2019/02/19/esni</id><content type="html" xml:base="https://www.saturnsoft.net/translation/2019/02/19/esni/">&lt;p&gt;6번째 번역글입니다. 요즘 화제가 되고 있는 ESNI에 대해 작년에 발표된
내용입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;암호화하지 않으면 무용지물: 암호화된 SNI의 동작: &lt;a href="https://blog.cloudflare.com/encrypted-sni-ko/"&gt;https://blog.cloudflare.com/encrypted-sni-ko/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cloudflare 블로그에서 한글로 변역된 글은 다음 링크에서 모두 찾을 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://blog.cloudflare.com/tag/korean"&gt;https://blog.cloudflare.com/tag/korean/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;img src="http://feeds.feedburner.com/~r/saturnsoft/~4/gyw8_5xUgag" height="1" width="1" alt=""/&gt;</content><author><name>Junho Choi</name></author><summary type="html">6번째 번역글입니다. 요즘 화제가 되고 있는 ESNI에 대해 작년에 발표된 내용입니다.</summary><feedburner:origLink>https://www.saturnsoft.net/translation/2019/02/19/esni/</feedburner:origLink></entry><entry><title type="html">MacOS X에서 brew를 이용하여 Android NDK 13b 설치</title><link href="http://feedproxy.google.com/~r/saturnsoft/~3/m5-iXbK2zvE/" rel="alternate" type="text/html" title="MacOS X에서 brew를 이용하여 Android NDK 13b 설치" /><published>2019-02-17T00:00:00+00:00</published><updated>2019-02-17T00:00:00+00:00</updated><id>https://www.saturnsoft.net/tech/2019/02/17/brew_android_sdk_13b</id><content type="html" xml:base="https://www.saturnsoft.net/tech/2019/02/17/brew_android_sdk_13b/">&lt;p&gt;보통 안드로이드 개발시에 Android Studio를 사용 하거나 &lt;code class="highlighter-rouge"&gt;sdkmanager&lt;/code&gt;를 사용해서
SDK나 NDK등등의 각종 패키지가 버전 별로 설치 가능 합니다.&lt;/p&gt;

&lt;p&gt;하지만 자동화 등의 이유로 별도의 위치에 설치하고자 하는 경우도 있습니다.
MacOS X에서는 외부 패키지를 설치하기
위해 &lt;a href="https://brew.sh/"&gt;brew&lt;/a&gt; 를 많이 사용하는데, 여기에는 &lt;a href="http://caskroom.io/"&gt;Cask&lt;/a&gt; 라고 하는 바이너리 패키지 설치를 위한
기능이 있습니다. Cask에는 이미 이런 목적으로 android-ndk 패키지가 있습니다만 최신 버전을
설치하는 관계로, 오래된 특정 버전을 사용하고 하는 경우에는 약간의 트릭을
사용해야 합니다.&lt;/p&gt;

&lt;p&gt;제 경우 작업을 위해 NDK 버전 13b를 사용해야 하는데, 물론 수동으로 받아서
설치 하는 것도 가능합니다만 관리를 약간 편하게 하기 위해서
Cask 소스를 변경하여 brew 를 사용해서 Android NDK 13b 를 설치하는 방법에 대해서
설명합니다.&lt;/p&gt;

&lt;h3 id="android-ndk를-brew를-이용하여-설치하기"&gt;android-ndk를 brew를 이용하여 설치하기&lt;/h3&gt;

&lt;p&gt;보통은 다음과 같이 설치할 수 있습니다.&lt;/p&gt;

&lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% brew cask install android-ndk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 이 경우 항상 최신 버전을 받아서 설치하게 됩니다. 이 글을 쓰는 현재
버전 19을 설치 합니다.&lt;/p&gt;

&lt;p&gt;brew는 이전 버전을 설치하는 좋은 방법이 존재하지 않기도
하는데, github에서 이전 버전을 받아서 설치하는 방법이 있습니다만 공교롭게도
&lt;a href="https://github.com/Homebrew/homebrew-cask/commits/master/Casks/android-ndk.rb"&gt;cask의 android-ndk 소스는 가장 오래된 것이 버전 14부터 시작&lt;/a&gt; 합니다.
따라서 13b 자체는 Cask 소스가 존재하지 않으므로 다음과 같은 과정을
거쳐야 합니다.&lt;/p&gt;

&lt;h3 id="brew-의-android-ndk-설치-소스"&gt;brew 의 android-ndk 설치 소스&lt;/h3&gt;

&lt;p&gt;brew 의 개별 패키지의 Cask 파일은 github에서 android-ndk의 경우
&lt;a href="https://raw.githubusercontent.com/Homebrew/homebrew-cask/master/Casks/android-ndk.rb"&gt;다음 위치&lt;/a&gt;
에서 찾을 수 있습니다. 이것을 다운로드합니다.&lt;/p&gt;

&lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% wget https://raw.githubusercontent.com/Homebrew/homebrew-cask/master/Casks/android-ndk.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;버전 19의 경우 android-ndk.rb는 다음과 같이 시작합니다:&lt;/p&gt;

&lt;div class="language-ruby highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;cask&lt;/span&gt; &lt;span class="s1"&gt;'android-ndk'&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="s1"&gt;'19'&lt;/span&gt;
  &lt;span class="n"&gt;sha256&lt;/span&gt; &lt;span class="s1"&gt;'04159ade2fc5c7d055248cf65664039b8596f4b9ee3fbc44a9bf2ce2ee28d95d'&lt;/span&gt;

  &lt;span class="c1"&gt;# dl.google.com/android/repository/android-ndk was verified as official when first introduced to the cask&lt;/span&gt;
  &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="s2"&gt;"https://dl.google.com/android/repository/android-ndk-r&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;-darwin-x86_64.zip"&lt;/span&gt;
  &lt;span class="nb"&gt;name&lt;/span&gt; &lt;span class="s1"&gt;'Android NDK'&lt;/span&gt;
  &lt;span class="n"&gt;homepage&lt;/span&gt; &lt;span class="s1"&gt;'https://developer.android.com/ndk/index.html'&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;파일을 잘 보면 Cask는 버전 19을 위한 것이며 sha256 체크섬과 다운로드 위치가
적혀 있습니다.
원본을 받는 URL도 적혀 있는데 여기서 버전만 바꾸어서 NDK 13b를 다운로드 받습니다.&lt;/p&gt;

&lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% wget https://dl.google.com/android/repository/android-ndk-r13b-darwin-x86_64.zip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;파일을 다 받았으면 sha256 체크섬을 계산해 둡니다. brew에서 &lt;code class="highlighter-rouge"&gt;md5sha1sum&lt;/code&gt;패키지를
설치하면 들어 있는 &lt;code class="highlighter-rouge"&gt;shasum&lt;/code&gt;유틸리티로 계산합니다:&lt;/p&gt;

&lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;shasum &lt;span class="nt"&gt;-a&lt;/span&gt; 256 android-ndk-r13b-darwin-x86_64.zip
eba299f1cdd9059e635d159dbe71678cea9f00efb3ef9b56083c7a09dff665bf  android-ndk-r13b-darwin-x86_64.zip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 위의 &lt;code class="highlighter-rouge"&gt;android-ndk.rb&lt;/code&gt;의 소스에서 버전명과 체크섬을 위에서 구한 값으로
변경 합니다. 아래 diff 를 적용하거나 직접 변경 하세요:&lt;/p&gt;

&lt;div class="language-diff highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="gd"&gt;--- android-ndk-19.rb   2019-02-15 17:17:07.000000000 -0800
&lt;/span&gt;&lt;span class="gi"&gt;+++ android-ndk.rb  2019-02-17 15:29:05.000000000 -0800
&lt;/span&gt;&lt;span class="gu"&gt;@@ -1,6 +1,6 @@
&lt;/span&gt; cask 'android-ndk' do
&lt;span class="gd"&gt;-  version '19'
-  sha256 '04159ade2fc5c7d055248cf65664039b8596f4b9ee3fbc44a9bf2ce2ee28d95d'
&lt;/span&gt;&lt;span class="gi"&gt;+  version '13b'
+  sha256 'eba299f1cdd9059e635d159dbe71678cea9f00efb3ef9b56083c7a09dff665bf'
&lt;/span&gt;
   # dl.google.com/android/repository/android-ndk was verified as official when first introduced to the cask
   url "https://dl.google.com/android/repository/android-ndk-r#{version}-darwin-x86_64.zip"
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;주의할 것은 설치시 파일명은 패키지 이름과 일치해야 하므로 &lt;code class="highlighter-rouge"&gt;android-ndk.rb&lt;/code&gt;이어야
합니다.&lt;/p&gt;

&lt;h3 id="설치"&gt;설치&lt;/h3&gt;

&lt;p&gt;이제 설치해 봅니다. &lt;code class="highlighter-rouge"&gt;brew cask&lt;/code&gt;로 설치시에는 보통 &lt;code class="highlighter-rouge"&gt;brew cask install &amp;lt;패키지이름&amp;gt;&lt;/code&gt;을 사용하는데
패키지 이름에는 URL도 올 수 있습니다. 로컬 파일의 경우에는 &lt;code class="highlighter-rouge"&gt;file:///&lt;/code&gt;를 앞에 붙이면
로컬 파일을 지정할 수 있으므로, 위에서 변경된 android-ndk.rb 파일의 전체 경로명을
지정하면 됩니다. 신규 설치의 경우 &lt;code class="highlighter-rouge"&gt;install&lt;/code&gt;명령을,
이미 설치된 android-ndk가 있다면 재설치를 위해서 &lt;code class="highlighter-rouge"&gt;reinstall&lt;/code&gt;명령을 사용하면 됩니다.
신규 설치의 경우 다음과 같이 실행하면 이제 Android NDK 버전 19 대신에
13b 를 설치하게 됩니다.
(설치에는 시간이 좀 걸립니다)&lt;/p&gt;

&lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% brew cask install file:///Users/junho/android-ndk.rb
&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; Downloading file:/Users/junho/android-ndk.rb.
&lt;span class="c"&gt;######################################################################## 100.0%&lt;/span&gt;
&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; Caveats
You may want to add to your profile:
   &lt;span class="s1"&gt;'export ANDROID_NDK_HOME="/usr/local/share/android-ndk"'&lt;/span&gt;

&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; Satisfying dependencies
&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; Downloading https://dl.google.com/android/repository/android-ndk-r13b-darwin-x86_64.zip
Already downloaded: /Users/junho/Library/Caches/Homebrew/downloads/65a6a66e139e460180b51cf64e9571a101d62c9a555443b2d99243070c1dee18--android-ndk-r13b-darwin-x86_64.zip
&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; Verifying SHA-256 checksum &lt;span class="k"&gt;for &lt;/span&gt;Cask &lt;span class="s1"&gt;'android-ndk'&lt;/span&gt;&lt;span class="nb"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; Uninstalling Cask android-ndk
&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; Unlinking Binary &lt;span class="s1"&gt;'/usr/local/bin/ndk-build'&lt;/span&gt;&lt;span class="nb"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; Unlinking Binary &lt;span class="s1"&gt;'/usr/local/bin/ndk-depends'&lt;/span&gt;&lt;span class="nb"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; Unlinking Binary &lt;span class="s1"&gt;'/usr/local/bin/ndk-gdb'&lt;/span&gt;&lt;span class="nb"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; Unlinking Binary &lt;span class="s1"&gt;'/usr/local/bin/ndk-stack'&lt;/span&gt;&lt;span class="nb"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; Unlinking Binary &lt;span class="s1"&gt;'/usr/local/bin/ndk-which'&lt;/span&gt;&lt;span class="nb"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; Purging files &lt;span class="k"&gt;for &lt;/span&gt;version 13b of Cask android-ndk
&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; Installing Cask android-ndk
&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; Linking Binary &lt;span class="s1"&gt;'ndk_exec.sh'&lt;/span&gt; to &lt;span class="s1"&gt;'/usr/local/bin/ndk-build'&lt;/span&gt;&lt;span class="nb"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; Linking Binary &lt;span class="s1"&gt;'ndk_exec.sh'&lt;/span&gt; to &lt;span class="s1"&gt;'/usr/local/bin/ndk-depends'&lt;/span&gt;&lt;span class="nb"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; Linking Binary &lt;span class="s1"&gt;'ndk_exec.sh'&lt;/span&gt; to &lt;span class="s1"&gt;'/usr/local/bin/ndk-gdb'&lt;/span&gt;&lt;span class="nb"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; Linking Binary &lt;span class="s1"&gt;'ndk_exec.sh'&lt;/span&gt; to &lt;span class="s1"&gt;'/usr/local/bin/ndk-stack'&lt;/span&gt;&lt;span class="nb"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; Linking Binary &lt;span class="s1"&gt;'ndk_exec.sh'&lt;/span&gt; to &lt;span class="s1"&gt;'/usr/local/bin/ndk-which'&lt;/span&gt;&lt;span class="nb"&gt;.&lt;/span&gt;
&#x1f37a;  android-ndk was successfully installed!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 완성입니다! 위에서 설명이 나왔지만 &lt;code class="highlighter-rouge"&gt;ANDROID_NDK_HOME&lt;/code&gt;환경 변수를 설정해서
현재 설치된 버전을 지정하도록 해야 합니다.&lt;/p&gt;

&lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="nb"&gt;export &lt;/span&gt;&lt;span class="nv"&gt;ANDROID_NDK_HOME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"/usr/local/share/android-ndk"&lt;/span&gt;&lt;span class="s1"&gt;'
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치가 제대로 되었는지 알기 위해서 다음 명령을 실행해 봅니다. &lt;code class="highlighter-rouge"&gt;android-ndk-r13b&lt;/code&gt;아래의 gcc를 사용할 수 있는 것을 알 수 있습니다.&lt;/p&gt;

&lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% which ndk-which
/usr/local/bin/ndk-which
% ndk-which gcc
/usr/local/Caskroom/android-ndk/13b/android-ndk-r13b/prebuilt/darwin-x86_64/bin/../../../toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-gcc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id="끝으로"&gt;끝으로&lt;/h3&gt;

&lt;p&gt;원래 brew에는 pin 기능이 있어서 설치된 버전을 고정해서 업그레이드를 막는 기능이
있는데 Cask 로 설치된 패키지에는 이 글을 쓰는 현재 &lt;a href="https://github.com/Homebrew/brew/pull/1523"&gt;pin 기능이 없습니다&lt;/a&gt;. 이 부분은 향후 추가되면 좋겠네요.&lt;/p&gt;&lt;img src="http://feeds.feedburner.com/~r/saturnsoft/~4/m5-iXbK2zvE" height="1" width="1" alt=""/&gt;</content><author><name>Junho Choi</name></author><summary type="html">보통 안드로이드 개발시에 Android Studio를 사용 하거나 sdkmanager를 사용해서 SDK나 NDK등등의 각종 패키지가 버전 별로 설치 가능 합니다.</summary><feedburner:origLink>https://www.saturnsoft.net/tech/2019/02/17/brew_android_sdk_13b/</feedburner:origLink></entry><entry><title type="html">요즘 듣는 팟캐스트</title><link href="http://feedproxy.google.com/~r/saturnsoft/~3/ZL0MVq_BfxE/" rel="alternate" type="text/html" title="요즘 듣는 팟캐스트" /><published>2019-02-09T00:00:00+00:00</published><updated>2019-02-09T00:00:00+00:00</updated><id>https://www.saturnsoft.net/misc/2019/02/09/my-favorite-podcasts</id><content type="html" xml:base="https://www.saturnsoft.net/misc/2019/02/09/my-favorite-podcasts/">&lt;p&gt;대략 2013년 부터라고 생각되는데 출퇴근중이나 기타 시간이 될 때
팟캐스트(podcast)를 종종 듣습니다.
주로 IT 기술 계열 팟캐스트들을 듣는데, 최근 듣는 것들을 한번 정리하는 차원에서
현재 듣고 있는 팟캐스트들을 소개 합니다. 이미 완전히 종료된 것은 제외했습니다.&lt;/p&gt;

&lt;p&gt;팟캐스트는 주로 &lt;a href="https://support.apple.com/en-us/HT201859"&gt;iOS의 기본 Podcasts 앱&lt;/a&gt;
으로 듣습니다. 따라서 아래 팟캐스트들은 모두 Podcasts 앱에서 검색 가능 합니다.&lt;/p&gt;

&lt;h2 id="한국어"&gt;한국어&lt;/h2&gt;

&lt;h3 id="stdoutfm"&gt;stdout.fm&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://stdout.fm/img/logo.png" alt="stdout.fm" width="64px" /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기술 난이도: 중&lt;/li&gt;
  &lt;li&gt;업데이트: 1-2주&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;최근에 잘 듣고 있는 &lt;a href="https://stdout.fm/"&gt;stdout.fm&lt;/a&gt;은 아래서 언급할 Rebuild
처럼 IT관련된 여러가지 주제를 다루고 있습니다. (아마 진행자 중에 Rebuild 를
듣는 분이 있는듯 합니다) 종종 게스트도 초대해서 이야기를 듣기도 합니다.
AWS, Ruby, Python 등 주로 서버사이드의 주제들이 많습니다.&lt;/p&gt;

&lt;h3 id="포럼it"&gt;포럼IT&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://is1-ssl.mzstatic.com/image/thumb/Music117/v4/a7/57/38/a757389c-9d21-149e-986f-5056a4a0ab21/source/170x170bb.jpg" alt="포럼IT" width="64px" /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기술 난이도: 하&lt;/li&gt;
  &lt;li&gt;업데이트: 비정기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href="http://forumit.kr/"&gt;포럼IT&lt;/a&gt;는 IT기술이 관련된 정치, 사회, 문화에 대한 영향에 대해서 많이 다루고 있습니다. 게스트도 다양함이 있어서 좋은데 최근에는 업데이트가 느린 점이 아쉽습니다.&lt;/p&gt;

&lt;h3 id="데이터-지능-팟캐스트"&gt;데이터 지능 팟캐스트&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://is2-ssl.mzstatic.com/image/thumb/Music118/v4/15/1f/cc/151fcc97-ec70-0bb1-ba06-5b48a0b487dd/source/170x170bb.jpg" alt="데이터 지능 팟캐스트" width="64px" /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기술 난이도: 중&lt;/li&gt;
  &lt;li&gt;업데이트: 비정기(시즌1 완료)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href="http://data-intelligence.io/"&gt;데이터 지능 팟캐스트&lt;/a&gt;는 데이터 사이언스, 엔지니어링, 머신러닝 위주의 팟캐스트입니다. 게스트도 다양한 분야의 현업 개발자 위주고 최신 동향을 얻는데 많이 도움이 됩니다. 작년에 시즌 1이 종료되어서 최근에는 업데이트가 없는데 시즌2를 기다리고 있습니다.&lt;/p&gt;

&lt;p&gt;그외 &lt;a href="http://www.iamprogrammer.io/"&gt;나는 프로그래머다&lt;/a&gt;도 잘 들었는데 종료되어서 아쉽네요.
한국어 IT 관련 팟캐스트가 더 많아졌으면 좋겠습니다.&lt;/p&gt;

&lt;h2 id="영어"&gt;영어&lt;/h2&gt;

&lt;h3 id="bsd-now"&gt;BSD Now&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://www.bsdnow.tv/themes/prosimii/bsd_now_logo_vector.png" alt="BSD Now" width="64px" /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기술 난이도: 중&lt;/li&gt;
  &lt;li&gt;업데이트: 매주&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href="https://www.bsdnow.tv/"&gt;BSD Now&lt;/a&gt;는 이름에서 볼 수 있듯이 BSD 계열 운영체제를
(FreeBSD, NetBSD, OpenBSD, DragonFlyBSD, TrueOS 등) 위한 팟캐스트입니다. 저는 보통
오디오로만 듣고 있어서 원래 형식이 비디오인줄은 몇달 전에 알았습니다. 하지만
오디오로만 들어도 별 문제는 없습니다. 종종 키보드 치는 소리만 나길래 왜 그런가
했었지요.&lt;/p&gt;

&lt;p&gt;형식은 한주간 BSD관련된 뉴스 (릴리즈, 업데이트, 행사, 보안 이슈 등)을 다루고,
게스트를 초대해서 인터뷰를 하기도 하고, 이후는 독자들이 보낸 Q&amp;amp;A 위주로
진행 됩니다. 중간에 진행자가 한번 바뀌긴 했는데 현재 진행자 두분은
모두 FreeBSD Core 팀 멤버이기도 합니다.&lt;/p&gt;

&lt;h3 id="microsoft-research-podcast"&gt;Microsoft Research Podcast&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://is3-ssl.mzstatic.com/image/thumb/Music128/v4/7d/7a/85/7d7a8585-e343-c2dd-2234-c048690ed648/source/170x170bb.jpg" alt="Microsoft Research Podcast" width="64px" /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기술 난이도: 하&lt;/li&gt;
  &lt;li&gt;업데이트: 2주&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href="https://www.microsoft.com/en-us/research/blog/category/podcast/"&gt;Microsoft Research Podcast&lt;/a&gt;는 마이크로소프트 리서치에서 운영하는 팟캐스트로 한달에 두번 꼴로 업데이트
됩니다. 주로 직원 중에서 다양한 분야의 인사를 초빙하여 이야기를 듣는데
아주 난이도가 높은편은 아니라 개괄적인 이야기를 좋아한다면 괜찮습니다.
그러고 보니 윈도우 이야기는 한번도 나온적이 없네요.&lt;/p&gt;

&lt;h3 id="behind-the-tech-with-kevin-scott"&gt;Behind the Tech with Kevin Scott&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://ssl-static.libsyn.com/p/assets/f/b/2/4/fb24219dd69886e9/height_90_width_90_115561_BTT_Show_Tile_v5.1.png" alt="Behind the Tech" width="64px" /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기술 난이도: 하&lt;/li&gt;
  &lt;li&gt;업데이트: 1-2달&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href="https://behindthetech.libsynpro.com/"&gt;Behind the Tech with Kevin Scott&lt;/a&gt;은
마이크로소프트 CTO인 Kevin Scott 씨가 진행하는 팟캐스트로 대략 한두달에 한번
꼴로 업데이트 됩니다. 매번 한명씩의 게스트와 진행 하는데 다들 유명한 분들이고
다양한 주제를 다루고 있습니다. 2018년 5월이 1회니까 아직
내용이 많지는 않으므로 지금부터 따라잡아도 될 것 같네요. 개인적으로는
001편이 재밌었는데 무려 터보파스칼/델파이/C# 만드신 분이 나와서 이야기를…
마이크로소프트 리서치와는 별개입니다.&lt;/p&gt;

&lt;h2 id="일본어"&gt;일본어&lt;/h2&gt;

&lt;h3 id="rebuild"&gt;Rebuild&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://is2-ssl.mzstatic.com/image/thumb/Music71/v4/1e/aa/9d/1eaa9dad-a9c1-00ee-69c2-3f14c0923bb4/source/170x170bb.jpg" alt="Rebuild" width="64px" /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기술 난이도: 중&lt;/li&gt;
  &lt;li&gt;업데이트: 1-2주&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href="http://rebuild.fm/"&gt;Rebuild&lt;/a&gt;는 유명한 perl 개발자이기도 한 미야가와씨가
진행하는 팟캐스트입니다. 주로 웹과 언어 관련된 기술을 다루고 있는데, 10명 이내의
레귤러 게스트가 있습니다만 예외도 종종 있습니다.
대부분 각자 전문 분야가 있어서 뉴스가 있다면 이후에 그 뉴스에 맞는 해설을
들을 수 있는 것도 재미있는 점입니다.
가령 새로운 하드웨어 발표가 있었다면 (아이폰 등) 그 다음 편에서 더 자세한
내용을 들을 수도 있습니다.
일본에서도 매우 인기있는 것으로 알고 있습니다.&lt;/p&gt;

&lt;p&gt;처음부터 들었던건 아니고 대략 2015년경부터 들었던것 같은데 점점 시간이 늘어나는
경향이 있습니다. 한편이 두시간 가까이 되는 경우도 있고 해서 요즘에는 본편,
애프터쇼 형태로 나누는 경우가 많은데 그것도 한편당 한시간 반이 되는 경우도
있습니다. 특징은 기술 이야기만 하는게 아니라 정치, 시사, 서브컬처 이야기도
많은 분량을 차지하는 관계로 (주로 일본이나 미국 관련인데 게스트들이 모두
일본인이지만 진행자 포함 미국에서 일하는 사람들도 많기 때문입니다)
그쪽 내용은 애프터쇼로 분리 하는 경향이지만 엄격하게 나뉘지는 않습니다.
일본어나 영어의 다른 팟캐스트에 대한 정보도 많이 얻고 있고, 의외로
애니, 게임, 만화, 영화 정보도 많이 얻어 갑니다.&lt;/p&gt;

&lt;h3 id="turing-complete-fm"&gt;Turing Complete FM&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://is5-ssl.mzstatic.com/image/thumb/Music128/v4/3c/f5/d2/3cf5d218-c9b6-349f-b6a6-a698b09acd62/source/170x170bb.jpg" alt="Turing Complete FM" width="64px" /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기술 난이도: 상&lt;/li&gt;
  &lt;li&gt;업데이트: 비정기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href="https://turingcomplete.fm/"&gt;Turing Complete FM&lt;/a&gt;은 주로 컴파일러, OS 관련
기술에 대해서 이야기하고 있습니다. 진행자가 llvm 링커 개발하는 분이라 그쪽
관련 이야기도 많이 하고 있습니다만 시스템 프로그래밍 관련 내용이 많고
게스트도 대부분 그쪽 사람들입니다. 종종 흥미있는 내용이 있는데
&lt;a href="https://www.is.s.u-tokyo.ac.jp/isnavi/practice01-01.html"&gt;동경대CPU실험&lt;/a&gt;에 대한 이야기가 꽤 재미있더군요. CPU를 직접 만들어 최종적으로 지정된 프로그램을 돌려 보는 프로젝트 수업이라고 합니다.&lt;/p&gt;

&lt;h3 id="misreading-chat"&gt;Misreading Chat&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://misreadingchat.files.wordpress.com/2018/03/favicon.jpg?w=64&amp;amp;h=64" alt="misreading chat" width="64px" /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기술 난이도: 상&lt;/li&gt;
  &lt;li&gt;업데이트: 1-2주&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;“CS논문을 읽고 XXX하는” (XXX는 매번 달라 집니다) 로 시작하는
&lt;a href="https://misreading.chat/"&gt;misreading chat&lt;/a&gt;는 두 진행자가 CS관련 논문을
번갈아 가면서 한편씩 소개 합니다. 드물게 논문이 아닌 것을 소개하는 경우도
있긴 합니다만 대부분 발표된 논문을 해설하고 있습니다.
주로 이미지 처리, 머신러닝, 운영체제, 브라우저, 보안 등등 다양한 분야입니다만
기본적으로 최근 IT관련된 서비스의 기반이 되는 내용을
다루고 있습니다. 논문 해설인 만큼 내용이 조금 어렵고 해당 분야를 잘 알지
못하면 제대로 이해하지 못할 가능성도 큽니다만 한번씩 들어 두어서 나쁘지는
않을것 같군요.&lt;/p&gt;

&lt;h3 id="mozaicfm"&gt;mozaic.fm&lt;/h3&gt;
&lt;p&gt;&lt;img src="https://jxck.io/assets/img/mozaic.svg" alt="mozaic.fm" width="64px" /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기술 난이도: 상&lt;/li&gt;
  &lt;li&gt;업데이트: 1달&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href="https://mozaic.fm/"&gt;mozaic.fm&lt;/a&gt;은 대략 한달에 한번 정도 업데이트되는데
웹 업계의 주요 업데이트를 다루고 있습니다. 브라우저라든가 IETF동향이라든가
HTML/CSS/JS 등등 폭넓게 다루고 있습니다만 기술 난이도는 높은 수준입니다.
내용이 꽤 상세하므로 해당 분야를 잘 알고 있는 경우에 추천 합니다. 의외로
길어서 한편이 대부분 두시간 정도 합니다.&lt;/p&gt;

&lt;h3 id="bilingual-news-バイリンガルニュース"&gt;Bilingual News (バイリンガルニュース)&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://staging.bilingualnews.jp/wp-content/plugins/bilingualnews/assets/images/bilingualnews_twitter.jpg" alt="bilingualnews.jp" width="64px" /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기술 난이도: 하 (시사)&lt;/li&gt;
  &lt;li&gt;업데이트: 매주&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href="https://bilingualnews.jp/"&gt;Bilingual News&lt;/a&gt;는 기술 팟캐스트는 아니고,
여러가지 잡다한 뉴스를 (일본 뿐 아니라 전세계 뉴스, 드물게 한국 관련
뉴스도 있습니다) 간단히 읽어 주고 관련된 이야기를 진행자 둘이서 하는
형식인데, 재미있는건 한사람(마이클)은 영어로 또 다른 사람(마미)은
일본어로 주로 이야기하고 (항상 그런건 아닙니다) 뉴스 요약도 일본어와
영어로 같은 내용을 두번 읽어 줍니다. 따라서 영어와 일본어를 동시에
공부하는 분들에게 도움이 됩니다. 종종
특별편 형식으로 게스트를 초대 하는데 특이한 분들이 많은게 재미
있더군요.&lt;/p&gt;

&lt;h2 id="기타"&gt;기타&lt;/h2&gt;

&lt;p&gt;팟캐스트를 오래 들어 보니, 한번 듣고 있는 것은 계속 듣게 되는데 새로운 걸
찾아 보려는 노력은 덜 하는 것 같습니다. 하나가 끝나면 다른 대체할 것을
찾아 보긴 합니다만. 그리고 실제 들을 수 있는 물리적인 시간에 제약이 있다 보니
너무 이것저것 찾아서 들을 수도 없고요. 한국어의 경우
1.2배나 1.5배속으로 들어도 괜찮아서 배속 조절 기능도 쓰는 경우가
많은데 영어나 일본어는 그렇게 하기는 어렵고 귀기울여 들어야 하는 때도 있어서
주의가 필요 합니다.&lt;/p&gt;

&lt;p&gt;요즘에는 팟캐스트들이 후원 가능한 경우가 많아서, 잘 듣고 있는 컨텐츠라면
부담되지 않는 선에서 고려해 보시는 것도 좋겠습니다.&lt;/p&gt;&lt;img src="http://feeds.feedburner.com/~r/saturnsoft/~4/ZL0MVq_BfxE" height="1" width="1" alt=""/&gt;</content><author><name>Junho Choi</name></author><summary type="html">대략 2013년 부터라고 생각되는데 출퇴근중이나 기타 시간이 될 때 팟캐스트(podcast)를 종종 듣습니다. 주로 IT 기술 계열 팟캐스트들을 듣는데, 최근 듣는 것들을 한번 정리하는 차원에서 현재 듣고 있는 팟캐스트들을 소개 합니다. 이미 완전히 종료된 것은 제외했습니다.</summary><feedburner:origLink>https://www.saturnsoft.net/misc/2019/02/09/my-favorite-podcasts/</feedburner:origLink></entry><entry><title type="html">간만에 듣는 T&amp;amp;E 소프트 5주년기념 뮤직 라이브러리</title><link href="http://feedproxy.google.com/~r/saturnsoft/~3/VRgMccYHXqQ/" rel="alternate" type="text/html" title="간만에 듣는 T&amp;E 소프트 5주년기념 뮤직 라이브러리" /><published>2019-02-03T00:00:00+00:00</published><updated>2019-02-03T00:00:00+00:00</updated><id>https://www.saturnsoft.net/msx/2019/02/03/tande-5</id><content type="html" xml:base="https://www.saturnsoft.net/msx/2019/02/03/tande-5/">&lt;p&gt;&lt;a href="https://blog.naver.com/saebaryo/221458098151"&gt;[MSX] 그레이티스트 드라이버 - 오프닝 / 엔딩, 그리고 기술적 잡설 / Greatest Driver G.D. / グレイテストドライバー&lt;/a&gt;를 읽다가… 포스트 안에 들어있는 이 비디오를 보고 반가워서 써 봅니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://youtu.be/gOnRV-cWRFY"&gt;T&amp;amp;E SOFT 創立５周年記念ゲームミュージックライブラリー&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/gOnRV-cWRFY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""&gt;&lt;/iframe&gt;

&lt;p&gt;집에 &lt;a href="https://en.wikipedia.org/wiki/Super_Hydlide"&gt;MSX2용 하이드라이드3&lt;/a&gt; 원본이 있었고 게임 패키지 안에 들어 있는 부록이 바로 위의 &lt;a href="https://vgmdb.net/album/13794"&gt;T&amp;amp;E소프트 5주년기념 게임뮤직 라이브러리입니다. 테이프로 들어 있습니다&lt;/a&gt;. 하이드라이드3는 1987년 발매니까 1982년 창립이 되겠지요. 지금은 40년이 다 되어 갑니다.&lt;/p&gt;

&lt;p&gt;내용은 당시에 발매된 T&amp;amp;E소프트의 여러 게임 음악 모음집입니다. 수록된 내용은 위 링크를 참조해도 되지만 유튜브 영상에 친절하게 붙어 있으므로 설명이 더 필요 없겠군요. 영상 자체는 PC8801 인것 같습니다.&lt;/p&gt;

&lt;p&gt;음악은 퍼스컴 판을 그대로 녹음한게 아니라 어레인지판이라 당시에 듣기에는 너무 좋았죠. 특히 마지막 음악은 하이드라이드3 오프닝인데 MSX2판도 PSG로는 최상급입니다만 역시 제대로 된 약기로 연주한 것과는 큰 차이가 있었죠. 여기 수록된 게임 중에서는 하이드라이드1(MSX), 하이드라이드3(MSX2), 디바(MSX2) 정도는 제대로 플레이해 보았습니다.&lt;/p&gt;

&lt;p&gt;사실 갖고 있는 그 테이프 앞부분 수십초를 실수로 손상시켜 버린 아픈 기억이 있어서… 더 기억에 남는 음악입니다.&lt;/p&gt;&lt;img src="http://feeds.feedburner.com/~r/saturnsoft/~4/VRgMccYHXqQ" height="1" width="1" alt=""/&gt;</content><author><name>Junho Choi</name></author><summary type="html">[MSX] 그레이티스트 드라이버 - 오프닝 / 엔딩, 그리고 기술적 잡설 / Greatest Driver G.D. / グレイテストドライバー를 읽다가… 포스트 안에 들어있는 이 비디오를 보고 반가워서 써 봅니다.</summary><feedburner:origLink>https://www.saturnsoft.net/msx/2019/02/03/tande-5/</feedburner:origLink></entry><entry><title type="html">구글 픽셀3 루팅하기</title><link href="http://feedproxy.google.com/~r/saturnsoft/~3/pQn46uND_1Y/" rel="alternate" type="text/html" title="구글 픽셀3 루팅하기" /><published>2019-01-30T00:00:00+00:00</published><updated>2019-01-30T00:00:00+00:00</updated><id>https://www.saturnsoft.net/tech/2019/01/30/pixel3-rooting</id><content type="html" xml:base="https://www.saturnsoft.net/tech/2019/01/30/pixel3-rooting/">&lt;p&gt;작년에 발매된 구글 픽셀3에는 안드로이드 9.0이 기본으로 설치되어 있다. 개발을 위해서 루트 권한 등이 필요할 경우가 있는데, 루팅하는 방법에 대해서 간단히 적어 둔다.&lt;/p&gt;

&lt;h2 id="준비물"&gt;준비물&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://store.google.com/us/product/pixel_3?hl=en-US"&gt;Google Pixel 3&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;스토어 버전도 있고 통신사별 버전도 있는데, 통신사 버전의 경우 부트로더에 락이 걸려 있는 경우가 있으므로 권장하지 않는다. 되도록이면 구글 스토어 버전을 구하도록 하자.&lt;/li&gt;
      &lt;li&gt;기본적으로 안드로이드 Pie (9)가 설치되어서 오는 관계로 아래의 메뉴 등은 모두 안드로이드 9 기준이다. 메뉴는 영문 기준으로 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PC (여기서는 MacOS Mojave로 진행)
    &lt;ul&gt;
      &lt;li&gt;&lt;a href="https://developer.android.com/studio/releases/platform-tools"&gt;Android SDK Platform Tools&lt;/a&gt;를 설치한다. 커맨드라인 명령인 adb와 fastboot 가 필요하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PC와 폰을 연결할 수 있는 USB-C 케이블&lt;/li&gt;
  &lt;li&gt;폰 내용 백업&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="macos에서-adb-간단하게-설치하기"&gt;MacOS에서 adb 간단하게 설치하기&lt;/h3&gt;

&lt;p&gt;구글 사이트를 따라서 해도 되는데 &lt;a href="https://brew.sh/"&gt;brew&lt;/a&gt;를 쓰고 있는 경우라면 다음과 같이 설치 가능하다.&lt;/p&gt;

&lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% brew update
% brew tap homebrew/cask
% brew cask install android-sdk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치후에 터미널에서 &lt;code class="highlighter-rouge"&gt;adb&lt;/code&gt;와 &lt;code class="highlighter-rouge"&gt;fastboot&lt;/code&gt; 명령이 실행 가능한지 확인해 두자.&lt;/p&gt;

&lt;h2 id="1-부트로더-언락-준비"&gt;1. 부트로더 언락 준비&lt;/h2&gt;

&lt;p&gt;제일 먼저 해야 할 일은 폰의 부트 로더의 락을 푸는 일이다. 이걸 해야 기존 OS를 수정하거나 덮어 쓰는 일이 가능하다. 스톡 안드로이드 OS를 루팅하는 것도 가능하고, 커스텀 OS를 설치하는 일도 가능한데, 일단 가장 기본적으로 해야 할 일은 부트로더를 언락하는 일이다.&lt;/p&gt;

&lt;p&gt;부트로더를 언락하면 재부팅 후에 OS가 초기화되므로 백업을 하지 않았다면 반드시 하고 시작한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Settings 앱 실행&lt;/li&gt;
  &lt;li&gt;System -&amp;gt; About phone -&amp;gt; Build number (가장 아래)를 7회 탭한다. (암호가 걸려 있다면 여기서 입력한다) 개발자 모드가 열린다.&lt;/li&gt;
  &lt;li&gt;About phone -&amp;gt; Advanced -&amp;gt; Developer options&lt;/li&gt;
  &lt;li&gt;첫 화면에서 “OEM unlocking”을 탭해서 켠다. 경우에 따라서 이 단추 자체가 탭이 안되도록 비활성화되어 있는 경우가 있는데 이 경우에는 부트로더 언락 자체가 불가능하다. 주로 통신사에서 구매하는 경우 (미국의 경우 Verizon) 락이 걸려 있는데 풀 방법도 없다고 하므로 루팅용인 경우에는 스토어 버전을 구하는 것이 안전하다.&lt;/li&gt;
  &lt;li&gt;한화면 반 정도 아래로 스크롤해서 Debugging 섹션으로 가면 “USB debugging”메뉴가 있는데 활성화시켜 준다.&lt;/li&gt;
  &lt;li&gt;PC와 USB케이블로 연결한다. 처음 연결하는 경우 해당 PC의 RSA키를 추가할 것을 묻는데 여기서 Allow를 선택한다. 이걸 허용하지 않으면 PC와 통신할 수 없다.&lt;/li&gt;
  &lt;li&gt;이제 터미널을 띄워서 다음 명령으로 폰과 연결되어 있는지 확인한다. 다음과 같이 연결된 폰의 목록이 나와야 한다.
    &lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% adb devices
List of devices attached
012345678 device
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="2-부트로더-언락"&gt;2. 부트로더 언락&lt;/h2&gt;

&lt;p&gt;이제 폰을 bootloader 모드로 부팅하자. 다음 명령을 실행한다.&lt;/p&gt;

&lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% adb reboot bootloader
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;재부팅해서 까만 화면에 빨간색으로 “Fastboot mode”라고 나오면 된다.
부트로더 언락을 위해 다음 명령을 실행한다.&lt;/p&gt;

&lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% fastboot flashing unlock
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 정말 언락할지 물어보게 되는데 폰에서 볼륨키를 이용해서 “Unlock the bootloader”를 선택하고 전원 버튼을 눌러주면 된다. 언락이 안되는 폰의 경우 여기서 진행이 되지 않는다.&lt;/p&gt;

&lt;p&gt;이후에 다음 명령으로 폰을 다시 부팅한다.&lt;/p&gt;

&lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% fastboot reboot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;폰이 재부팅하면 초기화되어 계정 로그인부터 해야 한다. Developer Options에서 USB debugging을 다시 켜도록 하자.&lt;/p&gt;

&lt;h2 id="3-twrp-실행"&gt;3. TWRP 실행&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://twrp.me/"&gt;TWRP&lt;/a&gt;는 안드로이드용 복구 프로그램이다. 커스텀 펌웨어나 루팅을 위해서는 시스템 이미지를 수정해야 하는데 이를 도와주는 프로그램이다. OS와는 별도의 복구 파티션에 설치 되므로 본체 OS가 망가졌을 때에도 유용하게 사용할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://dl.twrp.me/blueline/"&gt;Pixel3 다운로드&lt;/a&gt;에서 &lt;code class="highlighter-rouge"&gt;twrp-3.2.3-0-blueline.img&lt;/code&gt; 또는 상위 버전을 다운받으면 된다. (Pixel3 의 코드네임이 &lt;code class="highlighter-rouge"&gt;blueline&lt;/code&gt;이다)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;주의할 것은, 필자의 경우 위 파일만 필요했다. 검색해 보면 같은 사이트에서 .zip 파일도 받아 설치하라고 되어 있었는데 이 경우 루팅이 안되고 무한부팅하는 현상이 발생하므로, .img 파일만 받으면 된다.&lt;/p&gt;

&lt;p&gt;이제 다시 fastboot 모드로 들어간다.&lt;/p&gt;

&lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% adb reboot bootloader
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 TWRP로 부트하자.&lt;/p&gt;

&lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% fastboot boot twrp-3.2.3-0-blueline.img
Downloading &lt;span class="s1"&gt;'boot.img'&lt;/span&gt;                             OKAY &lt;span class="o"&gt;[&lt;/span&gt;  1.858s]
booting                                            OKAY &lt;span class="o"&gt;[&lt;/span&gt;  4.542s]
Finished. Total &lt;span class="nb"&gt;time&lt;/span&gt;: 6.450s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;폰이 자동적으로 다시 부팅해서 복구 모드로 진입하고 TWRP메뉴가 나올 것이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;“Enter Password”라고 나오면 Cancel을 탭한다.&lt;/li&gt;
  &lt;li&gt;하단의 “Swipe to Allow Modifications”를 우측으로 밀어내자.&lt;/li&gt;
  &lt;li&gt;TWRP 메인 메뉴가 표시된다. 대략 다음과 같이 생겼다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-01-30/twrp.png" alt="twrp" /&gt;&lt;/p&gt;

&lt;p&gt;주의할 것은 위 명령은 TWRP를 실행하는 것이지 설치하는 것은 아니다. 따라서 다시 TWRP로 가야 할 경우에는 bootloader 모드에서 위 명령을 다시 실행하도록 하자.&lt;/p&gt;

&lt;p&gt;아무것도 안하고 잠시 있으면 화면 락이 걸리는데 너무 자주 걸린다면 Settings -&amp;gt; Screen (상단 메뉴의 다섯개 아이콘 중 가운데 것) -&amp;gt; Enable screen timeout 을 언체크한다. 메인 메뉴로 돌아 가려면 좌측 하단의 좌측 화살표를 탭하면 된다.&lt;/p&gt;

&lt;h2 id="3-루팅---magisk-설치"&gt;3. 루팅 - Magisk 설치&lt;/h2&gt;

&lt;p&gt;안드로이드 루팅에는 여러가지 옵션이 있는데, 스톡 OS에 루팅만 하기 위해서는 요즘에는 &lt;a href="https://github.com/topjohnwu/Magisk"&gt;Magisk&lt;/a&gt;가 대세인 것으로 보인다. Magisk를 설치하도록 하자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href="https://github.com/topjohnwu/Magisk/releases"&gt;Magisk 릴리즈 페이지&lt;/a&gt; 에 가서 최신 릴리즈를 다운 받는다. 현재 시점에서는 다음 파일을 받는다.
    &lt;ul&gt;
      &lt;li&gt;&lt;a href="https://github.com/topjohnwu/Magisk/releases/download/v18.0/Magisk-v18.0.zip"&gt;Magisk-v18.0.zip&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;[MagiskManager-v6.1.0.apk)(https://github.com/topjohnwu/Magisk/releases/download/manager-v6.1.0/MagiskManager-v6.1.0.apk)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;adb로 Magisk 설치 이미지를 올린다. 반드시 TWRP 모드 상태에서 하도록 하자.
    &lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% adb push Magisk-v18.0.zip /sdcard/
Magisk-v18.0.zip: 1 file pushed. 32.8 MB/s &lt;span class="o"&gt;(&lt;/span&gt;4188255 bytes &lt;span class="k"&gt;in &lt;/span&gt;0.122s&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;TWRP 메인 메뉴에서 Install -&amp;gt; &lt;code class="highlighter-rouge"&gt;Magisk-v18.0.zip&lt;/code&gt; 선택 -&amp;gt; “Swipe to confirm Flash”를 밀어 Magisk를 설치한다. 설치 후에는 “Reboot System”을 선택해서 리부팅하면 된다. 이후 “Install TWRP App?”을 물어 보는데 “Do Not Install”을 선택해서 바로 부팅하도록 하자.&lt;/li&gt;
  &lt;li&gt;OS로 부팅하게 된다. 이제 Magisk 앱을 설치한다.
    &lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% adb install MagiskManager-v6.1.0.apk
Success
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;메뉴에서 Magisk 앱을 찾아서 실행해 본다. “Latest Version”과 “Installed Version”이 모두 녹색으로 체크되어 있다면 루팅이 제대로 된 것이다!&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-01-30/magiskapp.png" alt="magisk_app" width="50%" /&gt;&lt;/p&gt;

&lt;p&gt;루팅이 되어 있지 않다면 Installed Version 쪽에 빨간색 아이콘이 나오게 되므로, 이 경우 Magisk 설치를 다시 해 보도록 하자.&lt;/p&gt;

&lt;p&gt;root 로 쉘을 띄우고 싶다면 adb shell 을 실행해서 &lt;code class="highlighter-rouge"&gt;su -&lt;/code&gt;를 해 보면 된다.&lt;/p&gt;

&lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% adb shell
blueline:/ &lt;span class="nv"&gt;$ &lt;/span&gt;su -
blueline:/ &lt;span class="c"&gt;# id&lt;/span&gt;
&lt;span class="nv"&gt;uid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;gid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;groups&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;context&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;u:r:magisk:s0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class="highlighter-rouge"&gt;#&lt;/code&gt;프롬프트가 나오면 성공이다!&lt;/p&gt;

&lt;p&gt;이제 루팅이 되었으므로 관련된 프로그램을 설치할 수 있다. 명령행을 주로 쓴다면 여러가지 기본 명령을 한번에 설치하기 위해 &lt;a href="https://play.google.com/store/apps/details?id=stericson.busybox&amp;amp;hl=en_US"&gt;BusyBox&lt;/a&gt;를 권장한다.&lt;/p&gt;

&lt;p&gt;네트워크 패킷 덤프가 필요하다면 구글 플레이에서 패킷 캡처 앱도 검색이 가능 하지만 명령행이 필요 하면 &lt;a href="https://www.androidtcpdump.com/"&gt;Android Tcpdump&lt;/a&gt;를 설치하도록 하자.&lt;/p&gt;

&lt;h2 id="기타"&gt;기타&lt;/h2&gt;

&lt;h3 id="magisk-삭제"&gt;Magisk 삭제&lt;/h3&gt;

&lt;p&gt;루팅을 해제하고 싶다면 Magisk를 삭제하도록 하자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://github.com/topjohnwu/Magisk/releases/download/v18.0/Magisk-uninstaller-20181208.zip"&gt;Magisk-uninstaller-20181208.zip&lt;/a&gt; 을 받아서, TWRP 모드에서 Magisk 설치와 같이 zip 파일을 adb push 로 올려서 설치하면 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;OS가 부팅하면 Magisk 앱도 삭제하도록 하자.&lt;/p&gt;

&lt;h3 id="기본-os-재설치하기-공장-초기화"&gt;기본 OS 재설치하기 (공장 초기화)&lt;/h3&gt;

&lt;p&gt;루팅을 시도하다가 잘못되는 일이 있으면 설치된 OS가 깨져서 무한 부팅되거나 하는 일이 있다. 이 경우라면 기본 OS 이미지로 재설치하는게 제일 빠른 방법이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href="https://developers.google.com/android/images#blueline"&gt;Pixel 3 (blueline) OS 기본 이미지 다운로드&lt;/a&gt; 여기서 최신 버전의 Link 를 눌러서 .zip 파일을 받는다. 특정 버전을 사용하는 경우 해당 통신사용 버전 등을 받아야 하니까 주의하자.
    &lt;ul&gt;
      &lt;li&gt;zip 파일을 풀어 놓는다. 현재 일자 최신 버전은 &lt;code class="highlighter-rouge"&gt;blueline-pq1a.190105.004-factory-49adfd52.zip&lt;/code&gt;인데 다음과 같이 풀어 놓는다.
        &lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% unzip blueline-pq1a.190105.004-factory-49adfd52.zip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;fastboot 모드로 부팅한다. adb를 사용할 수 있다면 &lt;code class="highlighter-rouge"&gt;adb reboot bootloader&lt;/code&gt;로 진입이 가능하지만 adb연결이 안되는 경우라면, 전원을 끄고 (전원 버튼을 화면이 꺼질 때 까지 누르고 있는다) 나서 전원 버튼 + 볼륨 하단 버튼을 동시에 누르면 부트로더 화면으로 진입한다. 두 버전을 계속 누르고 있으면 바로 부팅해 버리므로 전원을 켜지면 바로 손을 떼고 아무것도 손대지 않으면 된다.&lt;/li&gt;
  &lt;li&gt;다음 명령으로 OS를 재설치한다. 시간이 좀 걸릴 수 있다.
    &lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% &lt;span class="nb"&gt;cd &lt;/span&gt;blueline-pq1a.190105.004
% ./flash-all.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;재부팅하면 OS가 자동으로 부팅되며 기존 내용은 삭제되므로 처음부터 다시 설정해야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="참고-사이트"&gt;참고 사이트&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=""&gt;https://forum.xda-developers.com/pixel-3-xl/how-to/guide-pixel-xl-android-9-0-pie-unlock-t3857195&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=""&gt;https://www.xda-developers.com/google-pixel-3-unlock-bootloader-root-magisk/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=""&gt;https://forum.xda-developers.com/apps/magisk/official-magisk-v7-universal-systemless-t3473445&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;img src="http://feeds.feedburner.com/~r/saturnsoft/~4/pQn46uND_1Y" height="1" width="1" alt=""/&gt;</content><author><name>Junho Choi</name></author><summary type="html">작년에 발매된 구글 픽셀3에는 안드로이드 9.0이 기본으로 설치되어 있다. 개발을 위해서 루트 권한 등이 필요할 경우가 있는데, 루팅하는 방법에 대해서 간단히 적어 둔다.</summary><feedburner:origLink>https://www.saturnsoft.net/tech/2019/01/30/pixel3-rooting/</feedburner:origLink></entry><entry><title type="html">Workers를 이용하여 기존 블로그 기사를 새 블로그로 자동 리다이렉트하기</title><link href="http://feedproxy.google.com/~r/saturnsoft/~3/tZvwg5hBGQ4/" rel="alternate" type="text/html" title="Workers를 이용하여 기존 블로그 기사를 새 블로그로 자동 리다이렉트하기" /><published>2019-01-19T00:00:00+00:00</published><updated>2019-01-19T00:00:00+00:00</updated><id>https://www.saturnsoft.net/tech/2019/01/19/blog-redirect</id><content type="html" xml:base="https://www.saturnsoft.net/tech/2019/01/19/blog-redirect/">&lt;p&gt;&lt;a href="https://import.jekyllrb.com/docs/blogger/"&gt;jekyll-import&lt;/a&gt;를 이용해서
기존 Blogger 기반 블로그 (blog.saturnsoft.net)의 글을 jekyll 기반의
www.saturnsoft.net 로 옮기는 건 무리 없이 처리 되었지만
아직 blog.saturnsoft.net에 접속해서
글을 읽는 경우는 어떻게 할 것인가를 생각해 보았는데, 제일 좋은 건 사용자를
www로 리다이렉션하면 좋겠다는 생각을 했다. 기존 기사에 접속하는 사용자를
새 페이지로 바로 가도록 하는 것인데, 가령&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;https://blog.saturnsoft.net/2009/09/nds.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;에 접속하면&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;https://www.saturnsoft.net/2009/09/12/nds/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;로 리다이렉트하는 것이다.&lt;/p&gt;

&lt;p&gt;기사 단위로 리다이렉트하려면 웹서버에서 설정을 하거나 HTML에서 해야 하는데,
blog 호스트는 구글의 Blogger 플랫폼을 쓰는 관계로 내가 할 수 있는 일이 별로
없다. 다만 현재 saturnsoft.net은 &lt;a href="https://www.cloudflare.com"&gt;Cloudflare&lt;/a&gt;
를 이용하고 있으므로 Workers를 사용하면 비교적 쉽게 구현할 수 있지 않을까 해서
도전해 보았다. &lt;sup id="fnref:disclaimer"&gt;&lt;a href="#fn:disclaimer" class="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h3 id="workers"&gt;Workers&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://www.cloudflare.com/products/cloudflare-workers/"&gt;Cloudflare Workers&lt;/a&gt;가
생소한 사람도 있을텐데, 쉽게 이야기하면 자바스크립트를 작성해서 CDN 엣지 서버에서
바로 실행할 수 있도록 해 준다. 브라우저에서 사용 가능한 &lt;a href="https://developers.google.com/web/fundamentals/primers/service-workers/"&gt;Service Worker&lt;/a&gt; 기능을 서버측에서 구현한
거라 보면 되는데 (필자도 자바스크립트는 잘 모르므로 그 이상의 설명은 어려움)
클라우드 서비스에서 요즘에 각광받는 서버리스(AWS Lambda, Google Cloud Function등)
와 유사하다고 보면 되는데 제일 큰 차이점은 자바스크립트라는 점과
몇몇 리전에서만 실행되는 서버리스와는 달리 CDN의 POP을 모두 이용하게 되므로
사용자 측면에서 응답 시간이 빠르다는 장점이 있다.&lt;/p&gt;

&lt;p&gt;성능 관련은 &lt;a href="https://blog.cloudflare.com/serverless-performance-comparison-workers-lambda/"&gt;Serverless Performance: Cloudflare Workers, Lambda and Lambda@Edge&lt;/a&gt;를 참고로 하면 된다.&lt;/p&gt;

&lt;p&gt;현재(2019/1/19) Free Plan 에서도 추가 비용($5/월)로 이용 가능하므로 무료 서비스는 아니다.
자세한 사항은 &lt;a href="https://www.cloudflare.com/products/cloudflare-workers/"&gt;서비스 정보&lt;/a&gt;를 보도록 하자.&lt;/p&gt;

&lt;h3 id="하고-싶은-것"&gt;하고 싶은 것&lt;/h3&gt;

&lt;p&gt;지금 하고 싶은 일을 정리하면 다음과 같다: 오리진 서버나 HTML 템플릿의 변경 없이 구 blog 기사 (예: &lt;code class="highlighter-rouge"&gt;https://blog.saturnsoft.net/2009/09/nds.html&lt;/code&gt;)에 접속하면 자동으로 www 아래의 이전된 글로 (예: &lt;code class="highlighter-rouge"&gt;https://www.saturnsoft.net/2009/09/12/nds/&lt;/code&gt;)으로 HTTP 301 리다이렉션하기.&lt;/p&gt;

&lt;h3 id="blog-와-www-기사-url간의-변환-목록-만들기"&gt;blog 와 www 기사 URL간의 변환 목록 만들기&lt;/h3&gt;

&lt;p&gt;일단 필요한 것은, blog 기사에 해당하는 www의 기사 URL을 알아야 하는데 이게 미묘하게
다르다. 가령 &lt;code class="highlighter-rouge"&gt;https://blog.saturnsoft.net/2009/09/nds.html&lt;/code&gt;의 경우 www 에서는
&lt;code class="highlighter-rouge"&gt;https://www.saturnsoft.net/2009/09/12/nds/&lt;/code&gt; 가 된다 (일자가 들어간다). 이걸 쉽게
계산할 방법은 없지만, 마이그레이션된 기사 파일을 보면 blog url 이 포함되어 있으므로
이걸 이용하면 매핑을 만들어낼 수 있다. 가령 해당 기사의 소스 파일인
&lt;code class="highlighter-rouge"&gt;_posts/2009-09-11-nds.html&lt;/code&gt;을 보면&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;date: '2009-09-11T23:53:00.000-07:00'
...
blogger_orig_url: https://blog.saturnsoft.net/2009/09/nds.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class="highlighter-rouge"&gt;date&lt;/code&gt; 는 파일명에 관계없이 글의 게시 시각이고, &lt;code class="highlighter-rouge"&gt;blogger_orig_url&lt;/code&gt;은
jekyll-import가 Blogger 글을 변환할 때 자동적으로 붙여 주는 원본 글의 URL이다.
원래는 URL이 http로 시작 하지만 https로 바꾸어 주었다. 나중에 나오겠지만
http를 모두 https로 리다이렉트하기 때문이다.&lt;/p&gt;

&lt;p&gt;약간 까다로운 부분이 있는데, 예를 들어 소스에서 파일명이 &lt;code class="highlighter-rouge"&gt;2009-09-11-nds.html&lt;/code&gt;
인 기사의 경우 2009년 9월 11일자로 생각되고 &lt;code class="highlighter-rouge"&gt;date&lt;/code&gt;도 2009-09-11로 적혀 있지만
실제 jekyll이 생성한 경로명은 &lt;code class="highlighter-rouge"&gt;https://www.saturnsoft.net/2009/09/12/nds/&lt;/code&gt;이어서
날짜가 9월 12일로
계산된 것을 알 수 있다. 이건 jekyll 이 사이트를 만들어낼 때 블로그 글의
경로명에 들어가는 날짜는 GMT로 계산해서이다.
(https://github.com/jekyll/jekyll/issues/6033) 을 보면 로컬 타임존으로
변환한다고 되어 있는데, 현재 www는 github 에서 빌드하므로 그쪽 빌드 서버의
시간대가 GMT이기 때문으로 생각된다(대부분의 서버 관리자는 시간대를 GMT로 설정한다).&lt;/p&gt;

&lt;p&gt;어쨌든 이 부분을 주의하면서 기존의 모든 글에 대해서 매핑을 만들어 낸다. 나중에
Workers에 올릴 거라 자바스크립트로 생성하도록 하는 perl 스크립트를 만들었다.
이 스크립트는 &lt;code class="highlighter-rouge"&gt;_posts/&lt;/code&gt; 아래의 모든 파일에 대해서 &lt;code class="highlighter-rouge"&gt;blogger_orig_url:&lt;/code&gt; 값이
존재하면 매핑을 만들고 자바스크립트 배열 형식으로 출력한다.&lt;/p&gt;

&lt;div class="language-perl highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="c1"&gt;#!/usr/local/bin/perl&lt;/span&gt;

&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nv"&gt;strict&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;File::&lt;/span&gt;&lt;span class="nv"&gt;Slurp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;Date::&lt;/span&gt;&lt;span class="nv"&gt;Parse&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nv"&gt;DateTime&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;my&lt;/span&gt; &lt;span class="nv"&gt;@newfiles&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;glob&lt;/span&gt; &lt;span class="s"&gt;"_posts/*"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"// auto generated at "&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="sb"&gt;`date`&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"const pathmap = {\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;foreach&lt;/span&gt; &lt;span class="k"&gt;my&lt;/span&gt; &lt;span class="nv"&gt;$blog&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sort&lt;/span&gt; &lt;span class="nv"&gt;@newfiles&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="k"&gt;my&lt;/span&gt; &lt;span class="nv"&gt;$blogfile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;read_file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$blog&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="k"&gt;my&lt;/span&gt; &lt;span class="nv"&gt;$path_prefix&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$blogfile&lt;/span&gt; &lt;span class="o"&gt;=~&lt;/span&gt; &lt;span class="sr"&gt;/date: '(.*)'/m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
		&lt;span class="k"&gt;my&lt;/span&gt; &lt;span class="nv"&gt;$ctime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;str2time&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
		&lt;span class="k"&gt;my&lt;/span&gt; &lt;span class="nv"&gt;$cdate_dt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;DateTime&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;from_epoch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;epoch&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;$ctime&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
		&lt;span class="c1"&gt;# convert to GMT&lt;/span&gt;
		&lt;span class="nv"&gt;$cdate_dt&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;set_time_zone&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"GMT"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
		&lt;span class="nv"&gt;$path_prefix&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sprintf&lt;/span&gt; &lt;span class="s"&gt;"/%04d/%02d/%02d"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
			&lt;span class="nv"&gt;$cdate_dt&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;year&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
			&lt;span class="nv"&gt;$cdate_dt&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;month&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
			&lt;span class="nv"&gt;$cdate_dt&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;day&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
	&lt;span class="p"&gt;}&lt;/span&gt;

	&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$blogfile&lt;/span&gt; &lt;span class="o"&gt;=~&lt;/span&gt; &lt;span class="sr"&gt;/blogger_orig_url: (.*)/m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
		&lt;span class="k"&gt;my&lt;/span&gt; &lt;span class="nv"&gt;$oldurl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
		&lt;span class="nv"&gt;$oldurl&lt;/span&gt; &lt;span class="o"&gt;=~&lt;/span&gt; &lt;span class="sr"&gt;s/http:\/\/blog.saturnsoft.net//&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
		&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$blog&lt;/span&gt; &lt;span class="o"&gt;=~&lt;/span&gt; &lt;span class="sr"&gt;/_posts\/(\d\d\d\d)-(\d\d)-(\d\d)-(.*)\.html/&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
			&lt;span class="k"&gt;my&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$yy&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$mm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$dd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
			&lt;span class="k"&gt;my&lt;/span&gt; &lt;span class="nv"&gt;$newpath&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"$path_prefix/$name/"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
			&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"  \"$oldurl\": \"$newpath\",\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
		&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"  \"/\": \"/\"\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"}\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이걸 사이트 디렉토리에서 다음과 같이 실행해서 pathmap.js를 만들어 준다.&lt;/p&gt;

&lt;div class="language-sh highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;perl gen-mappping-js.pl &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; pathmap.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;대략 이렇게 생겼다.&lt;/p&gt;

&lt;div class="language-javascript highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="c1"&gt;// auto generated at 2019년 1월 19일 토요일 01시 11분 09초 PST&lt;/span&gt;
&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;pathmap&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="s2"&gt;"/2008/02/4-nds.html"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"/2008/02/11/4-nds/"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"/2008/02/blog-post.html"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"/2008/02/11/blog-post/"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"/2008/02/blog-post_11.html"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"/2008/02/12/blog-post_11/"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="p"&gt;...&lt;/span&gt;
  &lt;span class="s2"&gt;"/"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"/"&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마지막의 &lt;code class="highlighter-rouge"&gt;"/": "/"&lt;/code&gt;는 &lt;code class="highlighter-rouge"&gt;https://blog.saturnsoft.net/&lt;/code&gt;을 &lt;code class="highlighter-rouge"&gt;https://www.saturnsoft.net/&lt;/code&gt;
으로 리다이렉션하겠다는 의미이다.&lt;/p&gt;

&lt;h3 id="workers-설정"&gt;Workers 설정&lt;/h3&gt;

&lt;p&gt;Workers 에 스크립트를 올리고 실행하기 위해서는 다음 두가지 정보가 필요하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실행할 자바스크립트 텍스트&lt;/li&gt;
  &lt;li&gt;해당 스크립트를 연동할 URL 위치&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자바스크립트는 다음과 같이 작성해 보았다. 자세한 설명은 생략하겠지만
대략 다음과 같은 일을 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;접속한 URL에서 경로명을 얻어서 &lt;code class="highlighter-rouge"&gt;pathmap[oldpath]&lt;/code&gt;의 값을 확인한다. 값이 있으면 새 URL을 조립해서 (www 아래의) 해당 URL로 리다이렉트한다. 아래 pathmap 의 첫번째 값처럼 &lt;code class="highlighter-rouge"&gt;https://blog.saturnsoft.net/2008/02/4-nds.html&lt;/code&gt;로 들어온 요청의 경우 &lt;code class="highlighter-rouge"&gt;https://www.saturnsoft.net/2008/02/11/4-nds/&lt;/code&gt;로 301 리다이렉트한다.&lt;/li&gt;
  &lt;li&gt;리다이렉트하는 경우 &lt;code class="highlighter-rouge"&gt;Redirected-By: blog_redirector&lt;/code&gt; 헤더를 응답에 추가한다.&lt;/li&gt;
  &lt;li&gt;이외의 경우 기존대로 오리진에서 해당 URL의 내용을 받아와서 출력한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그리고 위에서 생성한 pathmap.js의 내용을 아래 스크립트의 표시된 부분에 직접 붙여 넣었다.&lt;/p&gt;

&lt;div class="language-javascript highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="nx"&gt;addEventListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'fetch'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;event&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nx"&gt;event&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;respondWith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;handleRequest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;event&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;request&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;})&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;이&lt;/span&gt; &lt;span class="err"&gt;부분은&lt;/span&gt; &lt;span class="err"&gt;위에서&lt;/span&gt; &lt;span class="err"&gt;만든&lt;/span&gt; &lt;span class="nx"&gt;pathmap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;js&lt;/span&gt;&lt;span class="err"&gt;를&lt;/span&gt; &lt;span class="err"&gt;붙여넣은&lt;/span&gt; &lt;span class="err"&gt;것이다&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;// auto generated at 2019년 1월 19일 토요일 01시 11분 09초 PST&lt;/span&gt;
&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;pathmap&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="s2"&gt;"/2008/02/4-nds.html"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"/2008/02/11/4-nds/"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"/2008/02/blog-post.html"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"/2008/02/11/blog-post/"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="p"&gt;...&lt;/span&gt;
  &lt;span class="s2"&gt;"/2018/07/blog-post.html"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"/2018/07/10/blog-post/"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"/"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"/"&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;newurlprefix&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"https://www.saturnsoft.net"&lt;/span&gt;

&lt;span class="cm"&gt;/**
 * Redirect to new blog address
 * @param {Request} request
 */&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;handleRequest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;request&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// Fetch the response.&lt;/span&gt;

  &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;oldurl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;URL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;oldpath&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;oldurl&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;pathname&lt;/span&gt;
  &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;newpath&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;pathmap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;oldpath&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

  &lt;span class="c1"&gt;// redirect to new url&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;newpath&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;newurl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;newurlprefix&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;newpath&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;''&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="na"&gt;status&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;301&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="na"&gt;headers&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="s1"&gt;'Redirected-By'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'blog_redirector'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
          &lt;span class="s1"&gt;'Location'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;newurl&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="p"&gt;})&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// Everything is fine, return the response normally.&lt;/span&gt;
  &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;await&lt;/span&gt; &lt;span class="nx"&gt;fetch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;request&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;response&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;API를 이용할 수도 있겠지만 스크립트 하나 뿐이므로 Workers editor 에서
바로 붙여 넣는다. (크롬 브라우저를 써야 한다)&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-01-19/worker_edit.png" alt="Worker editor" /&gt;&lt;/p&gt;

&lt;p&gt;우측 패널에서 적용 전에 테스트가 가능한데, 그림을 보면 &lt;code class="highlighter-rouge"&gt;https://blog.saturnsoft.net/2008/02/4-nds.html&lt;/code&gt;에 대해서 올바르게 301 응답이 나오고 있음을 알 수 있다.&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;content-length: 0
content-type: text/plain;charset=UTF-8
location: https://www.saturnsoft.net/2008/02/11/4-nds/
redirected-by: blog_redirector
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 스크립트를 URL에 붙이기 위해서는 Routes 메뉴에서 추가해 주면 된다. 스크립트 이름을 &lt;code class="highlighter-rouge"&gt;blog_redirector&lt;/code&gt;로 주었으므로, “Add Route”를 누르고 다음과 같이 설정한다.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-01-19/routes.png" alt="Routes에 추가" /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 하면 &lt;code class="highlighter-rouge"&gt;https://blog.saturnsoft.net/*&lt;/code&gt; (&lt;code class="highlighter-rouge"&gt;*&lt;/code&gt;는 와일드카드이며 임의의 문자열에 매칭된다)로 접속하는 경우 blog_redirector 스크립트가 엣지서버에서 실행이 된다. 다시 편집기로 돌아가서 하단의 Deploy를 클릭하면 실 서비스에 적용되게 된다. Deploy 하면 모든 서버에 전달되는데 시간이 약간 소요되는데 대략 1-2분 정도면 충분할 것이다. 이제 실제로도 잘 되는지 확인한다.&lt;/p&gt;

&lt;div class="language-sh highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;% curl &lt;span class="nt"&gt;-v&lt;/span&gt; https://blog.saturnsoft.net/2008/02/4-nds.html
&lt;span class="k"&gt;*&lt;/span&gt;   Trying 2606:4700::6812:4c87...
...
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; GET /2008/02/4-nds.html HTTP/2
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; Host: blog.saturnsoft.net
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; User-Agent: curl/7.54.0
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; Accept: &lt;span class="k"&gt;*&lt;/span&gt;/&lt;span class="k"&gt;*&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;*&lt;/span&gt; Connection state changed &lt;span class="o"&gt;(&lt;/span&gt;MAX_CONCURRENT_STREAMS updated&lt;span class="o"&gt;)!&lt;/span&gt;
&amp;lt; HTTP/2 301
&amp;lt; date: Sat, 19 Jan 2019 11:25:28 GMT
&amp;lt; content-type: text/plain&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="nv"&gt;charset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;UTF-8
&amp;lt; content-length: 0
&amp;lt; set-cookie: &lt;span class="nv"&gt;__cfduid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;d7c875ee5bf66000cee23d9270b6521731547897128&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nv"&gt;expires&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;Sun, 19-Jan-20 11:25:28 GMT&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nv"&gt;path&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nv"&gt;domain&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;.saturnsoft.net&lt;span class="p"&gt;;&lt;/span&gt; HttpOnly
&amp;lt; location: https://www.saturnsoft.net/2008/02/11/4-nds/
&amp;lt; redirected-by: blog_redirector
&amp;lt; expect-ct: max-age&lt;span class="o"&gt;=&lt;/span&gt;604800, report-uri&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct"&lt;/span&gt;
&amp;lt; server: cloudflare
&amp;lt; cf-ray: 49b8f0df1fac93f0-SJC
&amp;lt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;잘 동작하고 있다. 브라우저에서도 잘 되는지 blog 사이트에 가서 몇가지 기사 링크를 눌러서 www의 글이 보이게 되는지 확인한다.&lt;/p&gt;

&lt;h3 id="http를-자동으로-https으로-리다이렉트"&gt;HTTP를 자동으로 HTTPS으로 리다이렉트&lt;/h3&gt;

&lt;p&gt;추가로 &lt;code class="highlighter-rouge"&gt;http://blog.saturnsoft.net/&lt;/code&gt; 로 접속하면 HTTP로 서비스되는 걸 발견하였으므로 이것도 모두 HTTPS로만 볼 수 있도록 한다. Page Rule을 쓰면 아래와 같이 간단히 설정 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/images/2019-01-19/pagerule.png" alt="pagerule" /&gt;&lt;/p&gt;

&lt;h3 id="끝으로"&gt;끝으로&lt;/h3&gt;

&lt;p&gt;기사의 URL목록을 만드는데 오히려 시간을 좀 소비했지 (특히 시간대 변환) 막상 Workers용
스크립트는 필자가 자바스크립트 경험이 많지 않음에도 생각보다 쉽게 만들 수 있었다.
이것 말고도 응답을 새로 쓰거나 다른 파일을 불러 오거나 하는 일들이 가능한데
&lt;a href="https://developers.cloudflare.com/workers/recipes/"&gt;Workers Recipes&lt;/a&gt;를 많이 참조
하였다. 최근에는 &lt;a href="https://blog.cloudflare.com/cache-api-for-cloudflare-workers-is-now-in-beta/"&gt;캐시에 저장된 객체를 제어&lt;/a&gt;하거나
자바스크립트 아닌 언어로 작성하기 위해 &lt;a href="https://blog.cloudflare.com/webassembly-on-cloudflare-workers/"&gt;WebAssembly도 지원&lt;/a&gt;하고 있으므로 앞으로 유용하게
활용할 때가 있을 거라 본다.&lt;/p&gt;

&lt;div class="footnotes"&gt;
  &lt;ol&gt;
    &lt;li id="fn:disclaimer"&gt;
      &lt;p&gt;Disclaimer: 2019/1/19 현재 필자는 Cloudflare 에서 일하고 있습니다. &lt;a href="#fnref:disclaimer" class="reversefootnote"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;&lt;img src="http://feeds.feedburner.com/~r/saturnsoft/~4/tZvwg5hBGQ4" height="1" width="1" alt=""/&gt;</content><author><name>Junho Choi</name></author><summary type="html">jekyll-import를 이용해서 기존 Blogger 기반 블로그 (blog.saturnsoft.net)의 글을 jekyll 기반의 www.saturnsoft.net 로 옮기는 건 무리 없이 처리 되었지만 아직 blog.saturnsoft.net에 접속해서 글을 읽는 경우는 어떻게 할 것인가를 생각해 보았는데, 제일 좋은 건 사용자를 www로 리다이렉션하면 좋겠다는 생각을 했다. 기존 기사에 접속하는 사용자를 새 페이지로 바로 가도록 하는 것인데, 가령</summary><feedburner:origLink>https://www.saturnsoft.net/tech/2019/01/19/blog-redirect/</feedburner:origLink></entry><entry><title type="html">새 웹사이트 - www.saturnsoft.net</title><link href="http://feedproxy.google.com/~r/saturnsoft/~3/KYLd-bTXjEs/" rel="alternate" type="text/html" title="새 웹사이트 - www.saturnsoft.net" /><published>2018-11-19T00:00:00+00:00</published><updated>2018-11-19T00:00:00+00:00</updated><id>https://www.saturnsoft.net/update/2018/11/19/new-site</id><content type="html" xml:base="https://www.saturnsoft.net/update/2018/11/19/new-site/">&lt;p&gt;&lt;a href="https://www.saturnsoft.net"&gt;www.saturnsoft.net&lt;/a&gt;를 &lt;a href="https://jekyllrb.com"&gt;jekyll&lt;/a&gt;기반으로 만들었습니다. &lt;a href="https://saturnsoft.net"&gt;saturnsoft.net&lt;/a&gt; 으로도 들어올 수 있습니다.&lt;/p&gt;

&lt;p&gt;기존의 &lt;a href="https://blog.saturnsoft.net"&gt;blog.saturnsoft.net&lt;/a&gt;은 그대로 둡니다만 일정 시점이 되면 리다이렉션할 생각입니다. 블로그 포스트 내용은 이쪽 사이트로도 마이그레이션되어 있습니다.&lt;/p&gt;

&lt;p&gt;kr.freebsd.org 개인 페이지에 있던 오래된 페이지를 옮겨 두고 싶은데 일이 많을것 같네요…&lt;/p&gt;&lt;img src="http://feeds.feedburner.com/~r/saturnsoft/~4/KYLd-bTXjEs" height="1" width="1" alt=""/&gt;</content><author><name>Junho Choi</name></author><summary type="html">www.saturnsoft.net를 jekyll기반으로 만들었습니다. saturnsoft.net 으로도 들어올 수 있습니다.</summary><feedburner:origLink>https://www.saturnsoft.net/update/2018/11/19/new-site/</feedburner:origLink></entry></feed>
