<?xml version='1.0' encoding='UTF-8'?><?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?><feed xmlns='http://www.w3.org/2005/Atom' xmlns:openSearch='http://a9.com/-/spec/opensearchrss/1.0/' xmlns:blogger='http://schemas.google.com/blogger/2008' xmlns:georss='http://www.georss.org/georss' xmlns:gd="http://schemas.google.com/g/2005" xmlns:thr='http://purl.org/syndication/thread/1.0'><id>tag:blogger.com,1999:blog-3538290929769251376</id><updated>2019-05-10T03:48:36.810-07:00</updated><category term="[Programming] GamePhysics"/><category term="[Programming] LearnOpenGL"/><category term="[Programming] Graphics"/><category term="[Programming] Algorithms"/><category term="[Daily Life] Anything"/><category term="[Programming] Networking"/><category term="[Programming] Game"/><category term="[Programming] LearnDirectX"/><category term="[Programming] PPP C++"/><category term="[Programming] Operating Systems"/><category term="[Programming] LearnVulkan"/><category term="[Programming] Unity"/><title type='text'>chan blog</title><subtitle type='html'></subtitle><link rel='http://schemas.google.com/g/2005#feed' type='application/atom+xml' href='http://chanhaeng.blogspot.com/feeds/posts/default'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/3538290929769251376/posts/default'/><link rel='alternate' type='text/html' href='http://chanhaeng.blogspot.com/'/><link rel='hub' href='http://pubsubhubbub.appspot.com/'/><link rel='next' type='application/atom+xml' href='http://www.blogger.com/feeds/3538290929769251376/posts/default?start-index=26&amp;max-results=25'/><author><name>chan</name><uri>http://www.blogger.com/profile/14387528357950501854</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><generator version='7.00' uri='http://www.blogger.com'>Blogger</generator><openSearch:totalResults>239</openSearch:totalResults><openSearch:startIndex>1</openSearch:startIndex><openSearch:itemsPerPage>25</openSearch:itemsPerPage><entry><id>tag:blogger.com,1999:blog-3538290929769251376.post-8961828735505991942</id><published>2019-04-22T08:10:00.000-07:00</published><updated>2019-04-23T08:30:54.364-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="[Programming] LearnVulkan"/><title type='text'>Vulkan Tutorial (2)</title><content type='html'>&lt;a href=&quot;https://vulkan-tutorial.com/Drawing_a_triangle&quot;&gt;https://vulkan-tutorial.com/Drawing_a_triangle&lt;/a&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: x-large;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span style=&quot;font-size: x-large;&quot;&gt;Drawing a triangle&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Instance&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Creating an instance&lt;/b&gt;&lt;br /&gt;- 너가 처음 해야 할 것은 instance를 만들어서 Vulkan 라이브러리를 초기화하는 것이다. 그 인스턴스는 너의 어플리케이션과 벌칸 라이브러리 사이의 연결이고, 그것을 생성하는 것은 너의 어플리케이션에 대해 드라이버에게 몇 가지 세부사항을 명시하는 것을 포함한다.&lt;br /&gt;&lt;br /&gt;- 인스턴스를 생성하기 위해, 우리의 어플리케잇녀에 관한 몇 가지 정보로 struct를 채워야만 한다. 이 데이터는 기술적으로 부가적이지만, 그것은 우리의 구체적인 어플리케이션을 위해 최적화하기 위해 드라이버에게 몇 가지 유용한 정보를 제공할지도 모른다. 예를들어, 그 프로그램이 어떤 특별한 행동을 가진 잘 알려진 그래픽스 엔진을 사용하기 때문이다. 이 구조체는 VkApplicationInfo 라고 불려진다.&lt;br /&gt;&lt;br /&gt;- 이전에 언급되었듯이, 벌칸에 있는 많은 구조체들은 너가 sType 멤버에서 그 type을 explicitly하게 명시하는 것을 요구한다. 이것은 또한 나중에 extension 정보를 가리킬 수 있는 pNext 멤버를 가진 많은 구조체중의 하나이다. 우리는 여기에서 그것을 여기에서 nullptr로 두어서 기본 초기화를 할 것이다.&lt;br /&gt;&lt;br /&gt;- 벌칸에서 많은 정보는 함수 파라미터 대신에 구조체를 통해서 전달된다. 그래서 우리는 한 instance를 생성하는데 있어 충분한 정보를 제공하기 위해, 한 가지 더 구조체를 채워야만 할 것이다. 이 다음 구조체는 부가적이지 않고, 그 벌칸 드라이버에게 어떤 global extensions과 validation layers를 우리가 사용하고 싶은지를 말한다. Global 이란 것은 여기서 그것들이 특정 디바이스가 아닌 전체 프로그램에 적용될 것이라는 것을 의미하고, 이것들은 다음의 챕터들에서 명확해질 것이다.&lt;br /&gt;&lt;br /&gt;- 너가 보게 되듯이, 벌칸에서 오브젝트 생성 함수 파라미터들이 따르는 일반적인 패턴은&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;creation info를 가진 구조체에 대한 포인터&lt;/li&gt;&lt;li&gt;custom allocator callbacks에 대한 포인터, 이 튜토리얼에서는 항상 nullptr&lt;/li&gt;&lt;li&gt;그 새로운 오브젝트에 대한 handle를 저장하는 변수에 대한 포인터&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;- 만약 모든 것이 잘되었다면, instance에 대한 handle이 VkInstance에 저장된다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;b&gt;Checking for extension support&lt;/b&gt;&lt;br /&gt;- 한 instance를 생성하기전에, 지원되는extensions의리스트를 얻기 위해, vkEnumerateInstanceExtensionProperties함수가 있다. 그것은 extensions의 개수를 저장하는 변수에 대한 포인터와, extensions의 세부사항을 저장하는 vkExtensionsProperties의 배열엗 ㅐ한 포인터를 필요한다. 그것은 또한 우리가 특정한 validation layer에 의해 extensions을 필터링하게 해주는 한 가지 부가 파라미터를 필요한다. 그리고 우리는 지금은 이것을 무시한다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Validation Layers&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;What are validation layers&lt;/b&gt;&lt;br /&gt;- Validation layers는 부가적인 연산을 적용하기 위해 Vulkan 함수 호출에 걸려있는 부가적인 컴포넌트들이다. validation layers에서의 흔한 연산들은:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;잘못된 사용을 탐지하기 위해 명세에 대해 파라미터의 값을 체크&lt;/li&gt;&lt;li&gt;resource leaks를 찾기위해 오브젝트들의 생성과 파괴를 추적&lt;/li&gt;&lt;li&gt;호출이 출발하는 쓰레드들을 추적하여 thread safety를 체크&lt;/li&gt;&lt;li&gt;standard output으로 모든 호출과 그것의 파라미터들을 로그화&lt;/li&gt;&lt;li&gt;프로파일링과 replaying을 위한 Vulkan calls을 추적&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;이것은 diagnostics validation layer에서 한 함수의 구현이 어떻게 생겼는지에 대한 예시이다.&lt;/div&gt;&lt;br /&gt;&lt;!-- HTML generated using hilite.me --&gt;&lt;br /&gt;&lt;div style=&quot;background: #f0f0f0; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;&quot;&gt;&lt;pre style=&quot;line-height: 125%; margin: 0;&quot;&gt;VkResult &lt;span style=&quot;color: #06287e;&quot;&gt;vkCreateInstance&lt;/span&gt;(&lt;br /&gt;    &lt;span style=&quot;color: #007020; font-weight: bold;&quot;&gt;const&lt;/span&gt; VkInstanceCreateInfo&lt;span style=&quot;color: #666666;&quot;&gt;*&lt;/span&gt; pCreateInfo,&lt;br /&gt;    &lt;span style=&quot;color: #007020; font-weight: bold;&quot;&gt;const&lt;/span&gt; VkAllocationCallbacks&lt;span style=&quot;color: #666666;&quot;&gt;*&lt;/span&gt; pAllocator,&lt;br /&gt;    VkInstance&lt;span style=&quot;color: #666666;&quot;&gt;*&lt;/span&gt; instance) {&lt;br /&gt;&lt;br /&gt;    &lt;span style=&quot;color: #007020; font-weight: bold;&quot;&gt;if&lt;/span&gt; (pCreateInfo &lt;span style=&quot;color: #666666;&quot;&gt;==&lt;/span&gt; nullptr &lt;span style=&quot;color: #666666;&quot;&gt;||&lt;/span&gt; instance &lt;span style=&quot;color: #666666;&quot;&gt;==&lt;/span&gt; nullptr) {&lt;br /&gt;        log(&lt;span style=&quot;color: #4070a0;&quot;&gt;&quot;Null pointer passed to required parameter!&quot;&lt;/span&gt;);&lt;br /&gt;        &lt;span style=&quot;color: #007020; font-weight: bold;&quot;&gt;return&lt;/span&gt; VK_ERROR_INITIALIZATION_FAILED;&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    &lt;span style=&quot;color: #007020; font-weight: bold;&quot;&gt;return&lt;/span&gt; real_vkCreateInstance(pCreateInfo, pAllocator, instance);&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br /&gt;- 이러한 validation layers는 너가 관심있어 하는 모든 디버깅 기능들을 포함하도록 자유롭게 쌓아질 수 있다. 너는 간단히 디버그 빌드를 위해 validation layers를 활성화할 수 있고, release builds를 위해 그것들을 완전히 비활성화 할 수 있다. 그리고 이것은 너에게 두 세계에 대해 최상의 것을 준다.&lt;br /&gt;&lt;br /&gt;- 벌칸에서 이전에 두 개의 다른 validation layers가 있었다 : instance and device specific. 그 아이디어는 instance layers는 오직 instances같은 global Vulkan objects와 관련된 호출만을 체크하고, device specific layers는 특정한 GPU와 관련된 호출들만을 체크하는 것이다. Device specific layers는 이제 구식이 되었고, instance validation layers가 모든 Vulkan 호출에 대해 적용된다는 것을 의미한다. 명세 문서는 여전히 너가 호환성을 위해 또한 device level에서 validation layers를 활성화 할 것을 추천한다. 그리고 이것은 어떤 구현에 의해 요구된다. 우리는 간단히 logical device level에서의 instance로서 같은 layers를 명시할 것이다. 이것은 나중에 우리가 볼 것이다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Using validation layers&lt;/b&gt;&lt;br /&gt;- explicitly하게 모든 유용한 layers를 명시하는 대신에, 그 SDK는 너가 implicitly하게 유용한 diagnostics layers의 전체를 활성화하는 VK_LAYER_LUNARG_standard_validation layer를 요청하도록 한다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://chanhaeng.blogspot.com/feeds/8961828735505991942/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://chanhaeng.blogspot.com/2019/04/vulkan-tutorial-2.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/3538290929769251376/posts/default/8961828735505991942'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/3538290929769251376/posts/default/8961828735505991942'/><link rel='alternate' type='text/html' href='http://chanhaeng.blogspot.com/2019/04/vulkan-tutorial-2.html' title='Vulkan Tutorial (2)'/><author><name>chan</name><uri>http://www.blogger.com/profile/14387528357950501854</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3538290929769251376.post-6890123583455280635</id><published>2019-04-17T08:20:00.002-07:00</published><updated>2019-04-19T23:06:31.660-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="[Programming] LearnVulkan"/><title type='text'>Vulkan Tutorial (1)</title><content type='html'>&lt;a href=&quot;https://vulkan-tutorial.com/Introduction&quot;&gt;https://vulkan-tutorial.com/Introduction&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;https://vulkan-tutorial.com/Overview&quot;&gt;https://vulkan-tutorial.com/Overview&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;공부하면서 기록할 것들을 적어보자.. 완전 번역하기엔 시간이 없으니, 빠르게 요점만 정리하자. Introduction 부분은 그냥 쉽게 그냥 읽으면 된다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: x-large;&quot;&gt;Overview&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Origin of Vulkan&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;- 벌칸은 GPU에 대한 크로스 플랫폼 추상화로서 설계되었다.&lt;br /&gt;- 벌칸은 프로그래머가 좀 더 장황한 API를 사용하여 그것들의 의도를 명확하게 명시하도록 하여 드라이버 오버헤드를 줄이고, 여러 쓰레드들이 병렬로 명령어를 생성하고 제출하도록 한다.&lt;br /&gt;- 벌칸은 단일 컴파일러로 표준화된 바이트 코드 포맷으로 바꾸어서 쉐이더 컴파일에서 비일관성을 줄인다.&lt;br /&gt;- 마지막으로, 벌칸은 그래픽스 와 연산 기능을 단일의 API로 통합하여 현대 그래픽 카드의 일반 목적 처리 능력을 수용한다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;What it takes to draw a triangle&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;&lt;b&gt;Step1 - Instance and Physical Device Selection&lt;/b&gt;&lt;br /&gt;- 벌칸 프로그램은 VkInstance를 통해 Vulkan API를 설정하여 시작한다.&lt;br /&gt;- 한 instance는 너의 프로그램과, 너가 사용하려는 API Extensions을 설명하여 생성된다.&lt;br /&gt;- 인스턴스를 생성한 후에, 너는 벌칸을 지원하는 하드웨어를 쿼리할 수 있고, 연산을 위해 사용될 한 개 이상의 VkPhysicalDevice를 선택할 수 있다.&lt;br /&gt;- 너는 바람직한 장치를 선택하기 위해 VRAM size와 device capabilities같은 특성들을 쿼리할 수 있는데, 예를들어, 전용 그래픽스 카드를 사용하는 것을 선호하기 위해서이다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Step2 - Logical device and queue families&lt;/b&gt;&lt;br /&gt;- 사용할 올바른 하드웨어 장치를 선택한 후에, 너는 VkDevice(logical device)를 생성할 필요가 있다.&lt;br /&gt;- VkDevice에서, 너는 너가 어떤 VkPhysicalDeviceFeatures를 사용할지를 좀 더 구체적으로 설명하게 된다. 그러한 특징들로는 multi viewport rendering과 64 bit floats 같은 것들이 있다.&lt;br /&gt;- 또한 너는 어떤 queue families를 사용하고 싶은지를 명시할 필요가 있다.&lt;br /&gt;- 왜냐하면, draw commands와 memory operations 같은 벌칸으로 수행되는 대부분의 연산들은 그것들을 VkQueue에 제출하여 비동기적으로 실행된다.&lt;br /&gt;- Queues는 queue families로부터 할당되는데, 거기에서 각 queue family는 그것의 queues 안에서 특정한 연산들의 집합을 지원한다.&lt;br /&gt;- 예를들어, 그래픽스, compute and memory transfer operations에 대해 별개의 queue families가 있을 수 있다.&lt;br /&gt;- queue families의 이용가능성은 또한 physical device 선택시에 구분되는 요소로 사용될 수 있다.&lt;br /&gt;- 벌칸 지원을 하는 한 장치가 어떠한 그래픽스 기능을 제공하지 않는 것이 가능하지만, 그러나 벌칸 지원을 가진 모든 그래픽 카드는 오늘날 일반적으로 우리가 관심있어 하는 모든 queue operations를 지원한다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Step3 - Window surface and swap chain&lt;/b&gt;&lt;br /&gt;-우리는 한 window에 실제로 렌더링할 두 개 이상의 컴포넌트들이 필요하다 : window surface(VkSurfaceKHR) 과 swap chain (VkSwapchainKHR). KHR 후위 표기에 주목해라. 그것은 이러한 오브젝트들이 Vulkan extension의 일부라는 것을 의미한다.&lt;br /&gt;- 벌칸 API는 완전히 platform-agnostic인데, 우리가 표준화된 WSI(Window System Interface) extension을 window manager와 상호작용하기 우해 사용할 필요가 있는 이유이다. 그 surface는 렌더링할 windows에 대해 크로스 플랫폼 추상화이고, 일반적으로 native window handle에 대한 reference를 제공하여 instantiated 된다. 윈도우즈에서 예를들어 HWND이다. 운 좋게도, GLFW 라이브러리는 이 것에 대해 플랫폼 특정한 세부사항을 다루는 내장 함수를 가진다.&lt;br /&gt;- swap chain은 렌더 타겟의 집합이다. 그것의 기본 목적은 우리가 현재 렌더링하고 있는 이미지를 혀냊 스크린에 있는 것과 다르게 하도록 하는 것이다.완전한 이미지들만 보이게 하는 것이 중요하다.&lt;br /&gt;- 완성된 이미지를 스크린에 보이기 위해 렌더 타겟과 조건에 대한 개수는 present mode에 달려있다. 보통의 present modes는 double buffering (vsync)와 triple buffering이다.&lt;br /&gt;- 어떤 플랫폼은 VH_KHR_display와 VK_KHR_display_swapchain을 통해 어떤 윈도우 매니저들과도 상호작용 하는 것 없이 디스플레이에 직접 렌더링하게 해준다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Step4 - Image views and framebuffers&lt;/b&gt;&lt;br /&gt;- swap chain으로부터 얻어진 이미지를 그리기 위해, 우리는 그것을 VkImageView와 VkFramebuffer에 넣어야 한다. 한 image view는 사용될 한 이미지의 특정한 부분을 참조하고, 한 프레임버퍼는 color, depth and stencil targets을 위해 사용될 image views를 참조한다. swap chain에 많은 다른 이미지들이 있을 수 있기 때문에, 우리는 우선적으로 한 image view와 그것들 각각에 대해 프레임버퍼를 만들 것이고, draw time에 올바른 것을 선택할 것이다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Step5 - Render passes&lt;/b&gt;&lt;br /&gt;벌칸에서의 Render passes는 렌더링 연산동안에 상요되는 이미지들의 유형들을 설명하고, 그것들이 어떻게 사용되는지와, 그것들의 내용이 어떻게 다뤄져야 하는지를 설명한다. 우리의 초기 삼각형 렌더링 어플리케이션에서, 우리는 벌카네엑 우리가 단일의 이미지를 color target으로 상요할 것이라고 말할 것이고, 우리가 그것이 drawing operation 직전에, solid color로 cleared되기를 원한다고 말할 것이다. 반면에 한 render pass는 오직 이미지들의 유형을 설명하지만, VkFramebuffer는 실제로 특정한 이미지를 이러한 slots에 바인드한다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Step6 - Graphics pipeline&lt;/b&gt;&lt;br /&gt;벌칸에서의 그래픽스 파이프라인은 VkPipeline object를 생성하여 설정된다. 그것은 그래픽카드의 설정가능한 상태를 설명하는데, viewport size와 depth buffer operation, VkShaderModule objects를 사용하여 programmable state 같은 상태들을 말한다. VkShaderModule objects는 shader byte code로부터 생성된다. 그 드라이버는 또한 어떤 렌더타겟들이 파이프라인에서 사용될지를 알 필요가 있다. 그래서 우리는 그 렌더패스를 참조하여 명시한다.&lt;br /&gt;&lt;br /&gt;현존하는 API들과 비교해서 벌칸의 가장 구분되는 특징들 중 하나는 그래픽스 파이프라인의 거의 모든 환경설정이 미리 설정되어야 할 필요가 있다. 그것은 만약 너가 다른 쉐이더로 바꾸길 원하거나 약간 너의 vertex layout을 바꾸고 싶다면, 너는 전적으로 그래픽스 파이프라인을 재생성해야할 필요가 있다는 것을 의미한다.&amp;nbsp; 그것은 너의 렌더링 연산을 위해 필요한 모드 ㄴ다른 조합을 위해 미리 많은 VkPipeline objects를 만들어야 한다는 것을 의미한다. viewport size와 clear color같은 오직 몇 가지 기본 설정만이 동적으로 바뀔 수 있다. 또한 모든 상태는 explicitly하게 설명되어질 필요가 있고, 예를들어, 어떠한 default color blend state가 없다.&lt;br /&gt;&lt;br /&gt;좋은 소식은 너가 just in-time compilation에 대비하여 ahead-of-time compilation과 같은 것을 하기 떄문에, 드라이버에 대해 좀 더 최적화 기회가 있고, 런타임 성능은 좀 더 예측가능하다. 왜냐하면 다른 그래픽스 파이프라인으로 바꾼는 것 같은 많은 state changes가 매우 explicit하게 만들어지기 때문이다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Step7 - Command pools and command buffers&lt;/b&gt;&lt;br /&gt;이전에 언급되었듯이, drawing operations 같이 벌칸에서 우리가 실행하길 원하는 많은 연산들은 한 queue에 제출되어질 필요가 있다. 이러한 연산들은 그것들이 제출될 수 있기전에, VkCommandBuffer에 처음에 기록될 필요가 있다. 이러한 command buffers는 특정한 queue family와 연관된 VkCommonPool로 부터 할당된다. 간단한 삼각형을 그리기 위해, 우리는 다음의 연산들로 한 command buffer를 기록할 필요가 있다:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Begin render pass&amp;nbsp;&lt;/li&gt;&lt;li&gt;그래픽스 파이프라인 바인드&lt;/li&gt;&lt;li&gt;3개의 정점 그리기&lt;/li&gt;&lt;li&gt;End render pass&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;프레임버퍼에서의 이미지는&amp;nbsp; swap chain이 우리에게 어떤 특정한 이미지를 줄 지에 달려있기 때문에, 우리는 각 가능한 이미지에 대해 command buffer를 기록할 필요가 있고, draw time에 올바른 것을 선택할 필요가 있다. 대안은 매 프레임마다 그 command buffer를 다시 기록 하는 것인데, 효율적이지 않다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;Step8 - Main loop&lt;/b&gt;&lt;/div&gt;&lt;div&gt;drawing commands가 한 command buffer에 들어갔으니, 그 main loop는 꽤 간단하다. 우리는 처음에 swap chain으로부터 vkAcquireNextImageKHR로 한 이미지를 얻는다. 우리는 그러고나서 그 이미지에 대해 적절한 command buffer를 선택할 수 있고, vkQueueSubmit 으로 그것을 실행한다. 마지막으로, 우리는 스크린에 보이기위해 swap chain에 그 이미지를 vkQueuePresentKHR로 반환한다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;queues에 제출되는 연산들은 비동기적으로 실행된다. 그러므로, 우리는 정확한 실행순서를 보장하기 위해 세마포어 같은 동기화 오브젝트들을 사용해야만 한다.&amp;nbsp; draw command buffer의 실행은 image 획득이 마무리 되는 것을 기다리도록 설정되어야 한다. 만약 그렇지 않다면, 우리가 스크린에 보이기위해 여전히 읽혀지고 있는 이미지를 렌더링하기 시작하는 것이 발생할지도 모른다. vkQueuePresentKHR 호출은 차례대로 렌더링이 끝나기를 기다릴 필요가 있다. 왜냐하면 우리가 렌더링이 완료된 후에 signaled 되는 두 번째 세마포어를 사용할 것이기 때문이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Summary&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;- 요악해서, 첫 번째 삼각형을 그리기 위해서, 우리는 다음을 할 필요가 있다:&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;Create a VkInstance&lt;/li&gt;&lt;li&gt;지원되는 그래픽 카드 선택 (VkPhysicalDevice)&lt;/li&gt;&lt;li&gt;drawing과 presentation을 위해 VkDevice와 VkQueue 생성&lt;/li&gt;&lt;li&gt;window, window surface, swap chain 생성&lt;/li&gt;&lt;li&gt;swap chain 이미지들을 VkImageView에 넣기&lt;/li&gt;&lt;li&gt;렌더 타겟과 사용법을 명시하는 render pass 생성&lt;/li&gt;&lt;li&gt;그래픽스 파이프라인 설정&lt;/li&gt;&lt;li&gt;커맨드 버퍼를 할당하고, 모든 가능한 swap chain image에 대해 draw commands로 기록&lt;/li&gt;&lt;li&gt;이미지를 획득하여 프레임들을 그리기, 그리고 올바른 draw command buffer를 제출하고, 그 이미지를 다시 swap chain에 반환하기.&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Coding Conventions&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;- 한 오브젝트를 생성하거나 파괴하는 함수들은 드라이버 메모리에 대해 custom allocator를 사용하게 해주는 VkAllocationCallbacks 파라미터를 가질 것이고, 이것은 또한 이 튜토리얼에서 nullptr로 남아질 것이다.&lt;br /&gt;- 거의 모든 함수들은 VK_SUCCESS or error code 둘 중 하나를 반환하는 VkResult를 반환한다. 명세 문서가 각 함수가 어떤 에러코드를 반환하고 그것들이 무엇을 의미하는지를 설명한다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Validation layers&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;- 이전에 언급했듯이, 벌칸은 고성능과 낮은 드라이버 오버헤드를 위해 설계되었다. 그러므로, 그것은 기본적으로 매우 제한된 에러 체크와 디버깅 능력을 퐇마할 것이다. 그 드라이버는 만약 너가 잘못한다면 종종 에러코드를 반환하는 대신에 충돌이 날 것이다. 그것은 너의 그래픽카드에서는 작동하는 것처럼 보일 것이지만 다른 것에서 완전히 실패할 것이다.&lt;br /&gt;&lt;br /&gt;벌칸은 너가 validation layers라고 알려진 한 기능을 통해서 광범위한 체크를 할 수 있게 해준다. Validation layers는 API와 그래픽스 드라이버 사이에 삽입될 수 있는 코드 조각들인데, 이것은 함수 파라미터에 대해 추가 체크를 하고, 메모리 관리 문제를 추적하는 것 같은 것을 하기 위해서이다. 좋은 것은, 너가 개발하는 동안 그것들을 활성화할 수 있고, 그러므로 너의 어플리케이션을 zero overhead를 위해 출시할 때 완전히 그것들을 비활성화할 수 있다. 누구든지 자신만의 validation layers를 쓸 수 있지만, LunarG가 만든 Vulkan SDK는 우리가 이 튜토리얼에서 사용할 validation layers의 표준 세트를 제공한다. 너는 또한 그 layers로 부터 debug messages를 받는 callback function을 등록할 필요가 있다.&lt;br /&gt;&lt;br /&gt;벌칸은 모든 연산에 대해 매우 explicit하고, validation layers가 매우 광범위하기 때문에, 너의 스크린이 OpenGL과 Direct3D에 비해 왜 검정색이 되었는지를 알아내는 것이 훨씬 더 쉽다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://chanhaeng.blogspot.com/feeds/6890123583455280635/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://chanhaeng.blogspot.com/2019/04/vulkan-tutorial-1.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/3538290929769251376/posts/default/6890123583455280635'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/3538290929769251376/posts/default/6890123583455280635'/><link rel='alternate' type='text/html' href='http://chanhaeng.blogspot.com/2019/04/vulkan-tutorial-1.html' title='Vulkan Tutorial (1)'/><author><name>chan</name><uri>http://www.blogger.com/profile/14387528357950501854</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3538290929769251376.post-7943263435455530721</id><published>2019-04-01T08:47:00.001-07:00</published><updated>2019-04-01T08:47:25.627-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="[Programming] Unity"/><title type='text'>unity scene manager 사용하는 방법</title><content type='html'>&lt;a href=&quot;http://myriadgamesstudio.com/how-to-use-the-unity-scenemanager/&quot;&gt;http://myriadgamesstudio.com/how-to-use-the-unity-scenemanager/&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;여기자료 번역&lt;br /&gt;&lt;br /&gt;========================================&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: x-large;&quot;&gt;유니티 SceneManager 사용방법&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;이 블로그 포스트에서, 나는 모든 강력한 single scene에 대한 대안의 방법을 보여줄 것이다. synchronous and asynchronous scene loading, transition(변환) effects, additive(부가) scenes같은 기법들은 Unity의 SceneManager로 모두 가능하다. 놀랍게도, 이 기능의 어떠한 것을 구현하는데 있어서 복잡한 Scene 관리 스크립트가 요구되지 않는다. Additive scenes는 또한 매우 adaptive(조정할 수 있는)한데, 여러가지 게임 scenes, configuration scenes, debugging scenes, 그리고 많은 다른 유용한 대안들을 불러오는데 사용될 수 있다.&lt;br /&gt;&lt;br /&gt;나는 원래 플레이어가 게임 월드를 탐험하고 있을 때 실시간으로 scenes을 로딩하는 것을 얼마나 잘 처리할지를 보기위해 Unity에서의 scene management를 조사했었다. 몇 가지 실험후에, 우리는 이제 모든 우리의 게임 잼에서 SceneLoader script를 사용할 뿐만 아니라, 우리의 main title에서도 사용한다. 그리고 윌는 그 결과에 매우 만족한다. 나는 이 글이 너에게 scene manager에 대한 유용한 입문을 주고, 그것의 가장 기본적인 기능의 사용방법을 주기를 바란다.&lt;br /&gt;&lt;br /&gt;나는 모든 예제에 대한 깃헙 저장소를 만들었다. 그래서 편하게 끝으로 가서, 그 데모 프로젝트를 다운받아라. 여기에 내가 만든 (Alisha가 아트 작업을 한) 프로토타입의 좋지 않은 퀄리티의 GIF가 있다. 이것은 나의 첫 번째 scene loading 구현에 대해 작업한 것이다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;The Why&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;여기 Myriad Games Studio에서, 우리는 많은 게임 잼들을 한다. 아마도, 2달마다 잼을 한다. Myriad에서 하는 내부적인 것 또는 Tasjam events 같은 구성된 이벤트 둘 중 하나이다. 내부 잼은 일반적으로 우리가 좀 더 배우길 원하는 어떤 기능을 구현하는 게임을 만드는 것에 집중한다. TasJam 이벤트는 우리가 우리의 design muscles을 뽐내고, 특정한 제약 내에서 흥미로운 게임을 만들려고 하는 곳이다.&lt;br /&gt;&lt;br /&gt;게임잼들은 일반적으로 우리가 어떤 분야에서 좀 더 지식을 얻어야 할 필요가 있는지 보는 것을 도와준다. 나에게 있어서 가장 주요한 분야 중의 하나는 game의 scenes을 어떻게 설정하는지와 그러한 scenes들을 부드럽게 load하는 것이다. 팀과 토론한 후에, 나는 scene loading solution을 연구하고 불러올 몇 주의 시간을 확보했다. 그 최종 scripts는 간단하고 우리가 만드는 어떤 게임에서 든지 추가하기에 간단하다. 모든 게임 잼은 이제 엄청난 절약된 시간을 갖는데, 우리가 유연한 scene setup과 pre-made(미리 만들어진) scene loading solution을 가지기 때문이다. 이것은 우리가 설계 단계에서 좀 더 많은 시간을 쓸 수 있다는 것을 의미한다 - 게임 개발의 가장 어려운 부분!&lt;br /&gt;&lt;br /&gt;SceneManager를 사용하는 것의 다른 좀 더 구체적인 이유들 중의 몇몇과 너의 게임을 여러 개의 scenes으로 나누는 것의 장점은 :&lt;br /&gt;&lt;br /&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;loading times과 memory 사용이 줄어든다.&lt;/li&gt;&lt;li&gt;팀 멤버들은 별개의 scenes에 작업할 수 있고, 그러므로 source control 갈등의 개수를 줄인다.&lt;/li&gt;&lt;li&gt;실제로 거대한 open-world games이 가능하다.&lt;/li&gt;&lt;li&gt;scene 변환과 screens을 불러오는 것이 만들어서 추가하는 것이 매우 간단하다.&lt;/li&gt;&lt;li&gt;쉽게 &quot;manager&quot; type scripts와 objects를 너의 게임에 추가할 수 있다.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;The Process&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;여기에서, 나는 menu scene, loading scene, game scene을 가지고 Unity의 SceneManager class의 간단한 어플리케이션을 설명할 것이다. 나중에, 나는 asynchronous scene transitions을 포함하는 좀 더 고급 버전을 다룰 것이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;scene manager를 사용하여 작업하는 프로토타입을 얻기 위해서, 우리는 다음을 할 필요가 있다:&lt;/div&gt;&lt;div&gt;&lt;ol&gt;&lt;li&gt;scenes을 설정하고, 그것들에 build settings을 추가한다.&lt;/li&gt;&lt;li&gt;project에 Singleton script를 추가하고, &quot;SceneLoader.cs&quot;라고 불려지는 새로운 script를 생성한다.&lt;/li&gt;&lt;li&gt;새로운 scenes을 불러올 필요가 있는 scripts를 SceneLoader를 사용하여 추가해라. GUI buttons, in-game scenes, 또는 어디든지에서 처리될 수 있다.&lt;/li&gt;&lt;/ol&gt;&lt;div&gt;이것은 어떤 순서에서 든지 한 scene or scenes들을 불러오기 위해 SceneLoader class에 대해 간단하고 쉬운 호출로 불러와질 수 있는 scenes들을 만들어낼 것이다.&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;Scene Setup&lt;/b&gt;&lt;/div&gt;&lt;div&gt;scenes의 setup은 매우 간단하다. 우리는 다음에 대한 유사한 포맷을 가진 3개의 scenes이 필요하다;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;- Camera, UI button(s)을 포함하는 Menu Scene&lt;/div&gt;&lt;div&gt;- Camera, UI (background) image, Animated sprites/loading bar를 포함하는 Loading&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Scene&lt;/div&gt;&lt;div&gt;- Camera, Playable character, UI button (Menu scene으로 돌아가기 위한)를 포함하는 Game Scene&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;Note : 너는 너의 scenes들을 scene hierarchy에 drag and drop할 수 있고, 한 번에 여러개의 scenes을 보일 수 있다! 이것이 내가 여기에서 한 것이다 - 테스팅을 위해 매우 유용하다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;SceneManager Namespace&lt;/b&gt;&lt;/div&gt;&lt;div&gt;Unity의 오래된 버전에서, 어떤 scene management는 Application class를 사용해서 처리됐는데, 이것은 generic static methods의 뒤범벅된 것을 가지고 있다. 고맙게도, Unity는 Scene과 관련된 methods들을 그것들 자신의 namespace로 강화시켰다 - UnityEngine.SceneManagement. 이 namespace는 scenes을 loading하고 unloading하는데 대부분의 유용한 methods들을 포함한다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;Note : Application class에 있는 모든 scene과 관련된 메소드들은 이제 구식이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;SceneManager는 scenes을 동기적으로/비동기적으로 불러오는 메소드들을 포함한다. 그래서 만약 우리가 추가적으로 노력을 한다면, 우리는 게임이 멈추게 하지 않고 background에서 scenes loading을 할 수 있다.&lt;/b&gt; 그래서 코드로 들어가서, SceneLoader라고 불려지는 우리 자신의 클래스를 작성해보자. 우리는 synchronous versions을 작성하여 시작할 것인데, 그것들이 어떻게 작성하고, async versions을 구현하는 것으로 부터 얼마나 많은 이익들을 얻을 수 있는지를 보기 위해서이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;나는 singleton으로 나의 SceneLoader class를 작성했고, 이것은 MonoBehaviour로부터 상속받는다. 이것은 많은 이유들이 때문에 하게 되었는다; 첫 째로, singletons은 그들 스스로 manager-type classes들에 빌려준다(?), 왜냐하면 너는 일반적으로 한 개의 인스턴스만을 원하기 때문이다. 둘 째로, 내가 사용하는 singleton implementation은 게임 오브젝트가 scene이 unloaded될 때 결코 파괴되지 않는 것을 보장한다. 마지막으로, MonoBehaviour 상속은 그 singleton이 Awake, Start, and Update같은 상속된 메소드들에 대한 접근을 허용하게 한다. 이것은 또한 너가 다른 게임 오브젝트들과 스크립트들을 매니저에 붙이도록 한다. 만약 필요하다면.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;그 singleton implementation은 깃헙 저장소에 포함되어있지만, &lt;a href=&quot;http://wiki.unity3d.com/index.php/Singleton&quot; target=&quot;_blank&quot;&gt;여기&lt;/a&gt;에서 볼 수 있다. 그것은 Unity community에 의해 쓰인 클래스인다 (어떤 다른 좋은 코드를 거기에서 또 참고해라).&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;!-- HTML generated using hilite.me --&gt;&lt;br /&gt;&lt;div style=&quot;background: #111111; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;&quot;&gt;&lt;pre style=&quot;line-height: 125%; margin: 0;&quot;&gt;&lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;using&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;System.Collections;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;using&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;UnityEngine;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;using&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;UnityEngine.SceneManagement;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;class&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;SceneLoader&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;Singleton&amp;lt;SceneLoader&amp;gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: white;&quot;&gt;{&lt;/span&gt;&lt;br /&gt; &lt;span style=&quot;background-color: #0f140f; color: #008800; font-style: italic;&quot;&gt;// guarantee this will be always a singleton only - can&#39;t use the constructor!&lt;/span&gt;&lt;br /&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;protected&lt;/span&gt; &lt;span style=&quot;color: #ff0086; font-weight: bold;&quot;&gt;SceneLoader&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;()&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;{&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;void&lt;/span&gt; &lt;span style=&quot;color: #ff0086; font-weight: bold;&quot;&gt;LoadeScene&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;()&lt;/span&gt;&lt;br /&gt; &lt;span style=&quot;color: white;&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span style=&quot;color: white;&quot;&gt;SceneManager.LoadScene(&lt;/span&gt;&lt;span style=&quot;color: #0086d2;&quot;&gt;&quot;Loading&quot;&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;);&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span style=&quot;color: white;&quot;&gt;StartCoroutine(LoadAfterTimer());&lt;/span&gt;&lt;br /&gt; &lt;span style=&quot;color: white;&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;IEnumerator&lt;/span&gt; &lt;span style=&quot;color: #ff0086; font-weight: bold;&quot;&gt;LoadAfterTimer&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;()&lt;/span&gt;&lt;br /&gt; &lt;span style=&quot;color: white;&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span style=&quot;background-color: #0f140f; color: #008800; font-style: italic;&quot;&gt;// the reason we use a coroutine is simply to avoid a quick &quot;flash&quot; of the&lt;/span&gt;&lt;br /&gt;  &lt;span style=&quot;background-color: #0f140f; color: #008800; font-style: italic;&quot;&gt;// loading screen by introducing an artificial minimum load time&lt;/span&gt;&lt;br /&gt;  &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;yield&lt;/span&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;new&lt;/span&gt; &lt;span style=&quot;color: #ff0086; font-weight: bold;&quot;&gt;WaitForSeconds&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color: #0086f7; font-weight: bold;&quot;&gt;2.0f&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;);&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span style=&quot;color: white;&quot;&gt;LoadScene(&lt;/span&gt;&lt;span style=&quot;color: #0086d2;&quot;&gt;&quot;Game&quot;&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;);&lt;/span&gt;&lt;br /&gt; &lt;span style=&quot;color: white;&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;void&lt;/span&gt; &lt;span style=&quot;color: #ff0086; font-weight: bold;&quot;&gt;LoadScene&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color: #cdcaa9; font-weight: bold;&quot;&gt;string&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;sceneName)&lt;/span&gt;&lt;br /&gt; &lt;span style=&quot;color: white;&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span style=&quot;color: white;&quot;&gt;SceneManager.LoadScene(sceneName);&lt;/span&gt;&lt;br /&gt; &lt;span style=&quot;color: white;&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: white;&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;이것은 매우 기본적인 구현이지만, 그것은 우리가 원하는 것을 성취하고, 우리는 이제 구성할 기반을 가지게된다. 또한, 우리는 이러한 manager methods들을 singleton Instance를 참조하여 한 script로부터 접근할 수 있다, 이렇게 : SceneLoader.Instance.DisplayLoadingScene();&lt;br /&gt;&lt;br /&gt;Note : 너가 모든 scenes들을 build settings에 추가하도록 해라.&lt;br /&gt;&lt;br /&gt;LoadScene (line 10)을 호출하는 것은 Loading scene을 load하고, 그러고나서 Game scene을 불러올 것이다. 코루틴이 이 경우에 사용되는 이유는, 간단한 추가될 휴식시간을 허용하게 하기 위해서이다. 이것이 없다면, 그 Game Scene은 불러와질 것이고, 그 플레이어가 적절히 Loading scene을 볼 기회를 갖기전에 보여진다. Unity는 작은 scenes들을 매우 빠르게 불러온다.&lt;br /&gt;&lt;br /&gt;너는 아마도 이 코드에 또 다른 문제를 발견할 수 잇다. 우리는 우리의 scenes들의 loading을 추적할 방법이 없다 (적어도, 어떤 tracker/subscriber system의 종류를 만드는 문제들을 하지 않느 이상). 그 게임 scene이 실제로 완료되었는지 알 방법이 없다. 만약 그것이 준비되지 않았다면, 그러면 그것을 불러오는 것은 우리의 loading screen을 얼린것 처럼 보일 것이다. Synchronous methods는 그 main thread를 lock할 것이다 - 즉, 모든 것이 scene이 loading 되는 걸 멈출 때 까지 반응하는 것을 멈출 것이다. 만약 너가 animated loading scene을 가지고 있따면, 이것은 큰 문제이다 (그러나 static image를 보여주는 것은 괜찮을 것이다).&lt;br /&gt;&lt;br /&gt;fix? 우리는 물론 asynchronous methods로 넘어간다. 이것은 우리의 코드를 좀 더 복잡하게 만들 것이지만, 그것은 확실히 장기간으로 보상을 해준다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;!-- HTML generated using hilite.me --&gt;&lt;br /&gt;&lt;div style=&quot;background: #111111; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;&quot;&gt;&lt;pre style=&quot;line-height: 125%; margin: 0;&quot;&gt;&lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;using&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;System.Collections;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;using&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;UnityEngine;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;using&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;UnityEngine.SceneManagement;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;class&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;SceneLoaderAsync&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;Singleton&amp;lt;SceneLoader&amp;gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: white;&quot;&gt;{&lt;/span&gt;&lt;br /&gt; &lt;span style=&quot;background-color: #0f140f; color: #008800; font-style: italic;&quot;&gt;// Loading Progreess : private setter, public getter&lt;/span&gt;&lt;br /&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #cdcaa9; font-weight: bold;&quot;&gt;float&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;_loadingProgress;&lt;/span&gt;&lt;br /&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #cdcaa9; font-weight: bold;&quot;&gt;float&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;LoadingProgress&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;{&lt;/span&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;get&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;_loadingProgress;}&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;void&lt;/span&gt; &lt;span style=&quot;color: #ff0086; font-weight: bold;&quot;&gt;LoadScene&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;()&lt;/span&gt;&lt;br /&gt; &lt;span style=&quot;color: white;&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span style=&quot;background-color: #0f140f; color: #008800; font-style: italic;&quot;&gt;// kick-off the one co-routine to rule them all&lt;/span&gt;&lt;br /&gt;  &lt;span style=&quot;color: white;&quot;&gt;StartCoroutine(LoadScenesInOrder());&lt;/span&gt;&lt;br /&gt; &lt;span style=&quot;color: white;&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;IEnumerator&lt;/span&gt; &lt;span style=&quot;color: #ff0086; font-weight: bold;&quot;&gt;LoadScenesInOrder&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;()&lt;/span&gt;&lt;br /&gt; &lt;span style=&quot;color: white;&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span style=&quot;background-color: #0f140f; color: #008800; font-style: italic;&quot;&gt;// LoadSceneAsync() returns an AsyncOperation,&lt;/span&gt;&lt;br /&gt;  &lt;span style=&quot;background-color: #0f140f; color: #008800; font-style: italic;&quot;&gt;// so will only continue past this point when the Operation has finished&lt;/span&gt;&lt;br /&gt;  &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;yield&lt;/span&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;SceneManager.LoadSceneAsync(&lt;/span&gt;&lt;span style=&quot;color: #0086d2;&quot;&gt;&quot;Loading&quot;&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;);&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span style=&quot;background-color: #0f140f; color: #008800; font-style: italic;&quot;&gt;// as soon as we&#39;ve finished loading the loading screen, start loading the game scene&lt;/span&gt;&lt;br /&gt;  &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;yield&lt;/span&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #ff0086; font-weight: bold;&quot;&gt;StartCoroutine&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;(LoadScene(&lt;/span&gt;&lt;span style=&quot;color: #0086d2;&quot;&gt;&quot;Game&quot;&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;);&lt;/span&gt;&lt;br /&gt; &lt;span style=&quot;color: white;&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;IEnumerator&lt;/span&gt; &lt;span style=&quot;color: #ff0086; font-weight: bold;&quot;&gt;LoadScene&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color: #cdcaa9; font-weight: bold;&quot;&gt;string&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;sceneName)&lt;/span&gt;&lt;br /&gt; &lt;span style=&quot;color: white;&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span style=&quot;color: #cdcaa9; font-weight: bold;&quot;&gt;var&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;asyncScene&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;SceneManager.LoadSceneAsync(sceneName);&lt;/span&gt;&lt;br /&gt;  &lt;br /&gt;  &lt;span style=&quot;background-color: #0f140f; color: #008800; font-style: italic;&quot;&gt;// this value stops the scene from displaying when it&#39;s finished loading&lt;/span&gt;&lt;br /&gt;  &lt;span style=&quot;color: white;&quot;&gt;asyncScene.allowSceneActivation&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;false&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;while&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;(!asyncScene.isDone)&lt;/span&gt;&lt;br /&gt;  &lt;span style=&quot;color: white;&quot;&gt;{&lt;/span&gt;&lt;br /&gt;   &lt;span style=&quot;background-color: #0f140f; color: #008800; font-style: italic;&quot;&gt;// loading bar progress&lt;/span&gt;&lt;br /&gt;   &lt;span style=&quot;color: white;&quot;&gt;_loadingProgress&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;Mathf.Clamp01(asyncScene.progress&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;/&lt;/span&gt; &lt;span style=&quot;color: #0086f7; font-weight: bold;&quot;&gt;0.9f&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;)&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;*&lt;/span&gt; &lt;span style=&quot;color: #0086f7; font-weight: bold;&quot;&gt;100&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;   &lt;span style=&quot;background-color: #0f140f; color: #008800; font-style: italic;&quot;&gt;// scene has loaded as much as possible, the last 10% can&#39;t be multi-threaded&lt;/span&gt;&lt;br /&gt;   &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;(asyncScene.progress&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&quot;color: #0086f7; font-weight: bold;&quot;&gt;0.9f&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;)&lt;/span&gt;&lt;br /&gt;   &lt;span style=&quot;color: white;&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span style=&quot;background-color: #0f140f; color: #008800; font-style: italic;&quot;&gt;// we finally show the scene&lt;/span&gt;&lt;br /&gt;    &lt;span style=&quot;color: white;&quot;&gt;asynScene.allowSceneActivation&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;true&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;;&lt;/span&gt;&lt;br /&gt;   &lt;span style=&quot;color: white;&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;   &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;yield&lt;/span&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;null&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span style=&quot;color: white;&quot;&gt;}&lt;/span&gt;&lt;br /&gt; &lt;span style=&quot;color: white;&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: white;&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;클래스를 위에서 밑에까지 보아서, 우리는&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://chanhaeng.blogspot.com/feeds/7943263435455530721/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://chanhaeng.blogspot.com/2019/04/unity-scene-manager.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/3538290929769251376/posts/default/7943263435455530721'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/3538290929769251376/posts/default/7943263435455530721'/><link rel='alternate' type='text/html' href='http://chanhaeng.blogspot.com/2019/04/unity-scene-manager.html' title='unity scene manager 사용하는 방법'/><author><name>chan</name><uri>http://www.blogger.com/profile/14387528357950501854</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3538290929769251376.post-5366335068658685125</id><published>2019-03-13T09:56:00.001-07:00</published><updated>2019-03-14T00:04:17.230-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="[Programming] GamePhysics"/><title type='text'>GDC 2010 Erin Catto - Computing Distance (GJK Algorithm)</title><content type='html'>&lt;b&gt;&lt;span style=&quot;font-size: x-large;&quot;&gt;Computing Distance&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Convex polygons&lt;/div&gt;&lt;div&gt;- 우리가 한 쌍의 convex polygons(볼록 다각형)을 가지고 있다고 가정하자.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Closest points&lt;/div&gt;&lt;div&gt;- 우리는 가장 가까운 점을 어떻게 연산하는가?&lt;/div&gt;&lt;div&gt;- 가장 가까운 점을 아는 것은 우리에게 거리를 준다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Overlap&lt;/div&gt;&lt;div&gt;- 우리는 overlap을 어떻게 탐지하는가?&lt;/div&gt;&lt;div&gt;- 이 경우에 그 거리는 0이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Goal&lt;/div&gt;&lt;div&gt;- convex polygons 사이의 distance를 연산하자&lt;/div&gt;&lt;div&gt;- 이 발표의 목표는 convex polygons 사이의 거리를 연산하는 한 알고리즘을 설명하는 것이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Keep in mind&lt;/div&gt;&lt;div&gt;- 2D이다.&lt;/div&gt;&lt;div&gt;- 최적화되지 않은 코드이다.&lt;/div&gt;&lt;div&gt;- 나는 이 발표에서 오직 2D만을 다룰 것이다. 그러나 대부분의 개념들은 3D로 확장된다.&lt;/div&gt;&lt;div&gt;- 너는 최적화되지 않은 알고리즘들과 코드를 볼지도 모른다. 이것은 좋은 신호인데, 너가 그 재료들을 이해한다는 의미이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Approach&lt;/div&gt;&lt;div&gt;- 이 발표에서 bottom-up 접근법을 사용할 것이다.&lt;/div&gt;&lt;div&gt;- 나는 간단한 솔루션을 가진 간단한 문제로 시작할 것이고, 그러고나서 좀 더 복잡한 문제들과 솔루션 쪽으로 이동할 것이다.&lt;/div&gt;&lt;div&gt;- 각 level은 이전의 levels로부터 구성된다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Geometry&lt;/div&gt;&lt;div&gt;- 나는 그 알고리즘들을 위해 너의 geometric intuition(기하학적 직관)을 구성하려고 할 것이다.&lt;/div&gt;&lt;div&gt;- 결국, 우리는 한 기하학적 문제를 해결하려고 할 것이다.&lt;/div&gt;&lt;div&gt;- 추가 보너스로, 너는 많은 좋은 파스텔 컬러들을 보게 될 것이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* If all else fails ...&lt;/div&gt;&lt;div&gt;- 발표를 보충하기 위해, 나는 소스코드가 있는 알고리즘의 데모를 만들었다.&lt;/div&gt;&lt;div&gt;- 나는 나중에 링크를 올릴 것이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Outline&lt;/div&gt;&lt;div&gt;1. Point to line segment&lt;/div&gt;&lt;div&gt;2. Point to triangle&lt;/div&gt;&lt;div&gt;3. Point to convex polygon&lt;/div&gt;&lt;div&gt;4. Convex polygon to convex polygon&lt;/div&gt;&lt;div&gt;- 이 발표의 나머지의 개요이다.&lt;/div&gt;&lt;div&gt;- 각 주제는 이전의 것으로부터 구성되고, 연산의 대부분은 재활용 될 것이다.&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Concepts&lt;/div&gt;&lt;div&gt;1. Voronoi regions&lt;/div&gt;&lt;div&gt;2. Barycentric coordinates&lt;/div&gt;&lt;div&gt;3. GJK distance algorithm&lt;/div&gt;&lt;div&gt;4. Minkowski Difference&lt;/div&gt;&lt;div&gt;- 그 과정에서, 나는 몇 가지 중요한 개념들을 소개할 것이다.&lt;/div&gt;&lt;div&gt;- 그 첫 번째 개념은 Voronoi regions인데, 이것은 우리가 그 평면을 가장 가까운 feature regions으로 분할하게 해준다.&lt;/div&gt;&lt;div&gt;- 그 두 번째 개념은 barycentric coordinates이고, 이것은 점들의 가중치 합을 기반으로 오브젝트 기반의 좌표 체계를 제공한다.&lt;/div&gt;&lt;div&gt;- 세 번째 개념은 GJK 알고리즘이고, 점과 convex polygon problem에 대해 반복적으로 sovle하기 위해 사용할 것이다.&lt;/div&gt;&lt;div&gt;- 그 네 번째 개념은 Minkowski difference인데, polygon to polygon의 문제를 point to polygon으로 바꾸게 해준다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;* Section 1 : Point to Line Segment&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;- point to line segment를 다루는 첫 번째 주제로 시작해보자.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* A line segment&lt;/div&gt;&lt;div&gt;- 우리가 정점 A와 B를 가진 선분을 가지고 있다고 하자.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Query point&lt;/div&gt;&lt;div&gt;- 이제 우리가 query point Q를 가지고 있다고 하자.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Closest Point&lt;/div&gt;&lt;div&gt;- 우리는 선분 위에 있는 가장 가까운 점 P를 찾길 원한다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Proejction : region A&lt;/div&gt;&lt;div&gt;- 우리는 Q를 A와 B를 지나는 직선에 사영하여 가장 가까운 점을 찾을 수 있다.&lt;/div&gt;&lt;div&gt;- Q가 그 직선에 사영될 수 있는 3 개의 영역이 있다.&lt;/div&gt;&lt;div&gt;- 이 슬라이드에서, Q는 side A의 선분 바깥으로 사영된다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;*&amp;nbsp; Projection : region AB&lt;/div&gt;&lt;div&gt;- 이 슬라이드에서, Q는 그 선분 안으로 사영된다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Projection : region B&lt;/div&gt;&lt;div&gt;- 마지막으로, 이 경우에 Q는 side B에 선분 밖으로 상여된다.&lt;/div&gt;&lt;div&gt;- 그래서 그것은 3 개의 경우들을 보여준다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Voronoi regions&lt;/div&gt;&lt;div&gt;- 그래서 이것은 Voronoi regions의 개념을 꺼내게 한다.&lt;/div&gt;&lt;div&gt;- 우리는 그 평면을 closest feature regions으로 나눌 수 있다.&lt;/div&gt;&lt;div&gt;- region A에 있는 모든 점들은 정점 A와 가장 가깝다.&lt;/div&gt;&lt;div&gt;- region B에 있는 모든 점들은 정점 B와 가장 가깝다.&lt;/div&gt;&lt;div&gt;- region AB에 있는 모든 점들은 AB의 내부와 가장 가깝다.&lt;/div&gt;&lt;div&gt;- 이러한 것들이 Voronoi regions이라고 불려진다.&lt;/div&gt;&lt;div&gt;- 가장 가까운 점을 연산하는 것은 Q의 Voronoi region을 결정하는 것의 문제이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Barycentric coordinates&lt;/div&gt;&lt;div&gt;- 우리는 선분 AB를 지나는 직선에 대해 Q의 사영을 연산하기 위해 barycentric coordinates를 사용할 것이다.&lt;/div&gt;&lt;div&gt;- barycentric coordinates가 무엇인가?&lt;/div&gt;&lt;div&gt;- AB를 지나는 직선 위에 있는 어떤 점 G는 A와 B의 가중치 합으로 나타내어질 수 있다.&lt;/div&gt;&lt;div&gt;- 여기에서 우리는 그 가중치를 u와 v로 이름을 붙인다.&lt;/div&gt;&lt;div&gt;- 이러한 가중치는 합해서 1이 되어야 한다.&lt;/div&gt;&lt;div&gt;- 이러한 가중치들은 선분 AB와 관련하여 G의 barycentric coordinates이다.&lt;/div&gt;&lt;div&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20G%28u%2Cv%29%20%3D%20uA%20&amp;amp;plus;%20vB&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;/div&gt;&lt;div&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20u%20&amp;amp;plus;%20v%20%3D%201&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Fractional lengths&lt;/div&gt;&lt;div&gt;- 우리는 barycentric coordinates를 partial segments의 fractional lengths로 볼 수 있다.&lt;/div&gt;&lt;div&gt;- 이 슬라이드에서 partial segments는 균형을 이룬다. 그래서 u와 v는 0.5이다.&lt;/div&gt;&lt;div&gt;- 이 슬라이드에서 partial segments는 균형을 이루지 않는다. G가 A에 다가갈 때, u는 더 커지고, v는 균등하게 더 작아진다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;{&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;(1) u = 0.5, v = 0.5&lt;/div&gt;&lt;div&gt;(2) u = 0.75, v = 0.25&lt;/div&gt;&lt;div&gt;(3) u = 1.25, v = -0.25&lt;/div&gt;&lt;div&gt;A와 B가 일차원에 있는 값이라고 하자.&lt;/div&gt;&lt;div&gt;10과 100으로&lt;/div&gt;&lt;div&gt;그리고 각 케이스에 대해 G(u,v) 에 대한 값은, 즉 G의 위치는&lt;/div&gt;&lt;div&gt;(1) 0.5 * 10 + 100 * 0.5 = 5 + 50 = 55&lt;/div&gt;&lt;div&gt;(2) 0.75 * 10 + 0.25 * 100 = 7.5 + 25 = 32.5&lt;/div&gt;&lt;div&gt;(3) 1.25 * 10 - 0.25 * 100 = 12.5 - 25 = -12.5&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;}&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Unit Vector&lt;/div&gt;&lt;div&gt;- A에서 B로 향하는 단위 벡터 n을 정의하자.&lt;/div&gt;&lt;div&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Ctextbf%7Bn%7D%20%3D%20%5Cfrac%7BB%20-%20A%7D%7B%7C%7CB%20-%20A%20%7C%7C%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* (u,v) from G&lt;/div&gt;&lt;div&gt;- 이제 우리는 G의 위치를 기반으로 (u, v)를 결정할 수 있다.&lt;/div&gt;&lt;div&gt;- (u, v)는 적절한 n에 대해 sub-segment를 내적하고, 그러고나서 AB의 전체 길이로 나누어서 결정된다.&lt;/div&gt;&lt;div&gt;- u와 v가 개별적으로 음수가 될 수 있다는 것에 주의해라.&lt;/div&gt;&lt;div&gt;- 또한 u와 v가 합해서 1이 된다는 것에 주의해라.&lt;/div&gt;&lt;div&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20v%20%3D%20%5Cfrac%7B%28G%20-%20A%29%20%5Ccdot%20n%7D%7B%7C%7CB%20-%20A%7C%7C%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&amp;nbsp;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20u%20%3D%20%5Cfrac%7B%28B%20-%20G%29%20%5Ccdot%20n%7D%7B%7C%7CB%20-%20A%7C%7C%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;/div&gt;&lt;div&gt;- 우리는 query point Q로부터 직접 (u, v)를 얻을 수 있다.&lt;/div&gt;&lt;div&gt;- 우리가 G 대신에 Q를 사용한다면 그 내적이 변하지 않는다는 것에 주의해라.&lt;/div&gt;&lt;div&gt;- 이것은 내적의 사영 특성에 의한 것이다.&lt;/div&gt;&lt;div&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20v%20%3D%20%5Cfrac%7B%28Q%20-%20A%29%20%5Ccdot%20n%7D%7B%7C%7CB%20-%20A%7C%7C%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20u%20%3D%20%5Cfrac%7B%28B%20-%20Q%29%20%5Ccdot%20n%7D%7B%7C%7CB%20-%20A%7C%7C%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Voronoi region from (u, v)&lt;/div&gt;&lt;div&gt;- AB를 지나는 어떤 점 G는 A와 B의 가중치로 나타내어질 수 있다.&lt;/div&gt;&lt;div&gt;- 그 가중치는 합해서 1이 되어야 한다.&lt;/div&gt;&lt;div&gt;- 이러한 가중치는 선분 AB와 관련하여 G의 barycentric coordinates이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;u &amp;gt; 0 &amp;amp;&amp;amp; v &amp;gt; 0 : region AB&lt;/div&gt;&lt;div&gt;v &amp;lt;= 0 : region A&lt;/div&gt;&lt;div&gt;u &amp;lt;= 0 : region B&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Closest Point Algorithm&lt;/div&gt;&lt;div&gt;- 이제 우리는 우리의 closest point algorithm을 쓸 수 있다.&lt;/div&gt;&lt;div&gt;- 우리는 line segment AB와 query point Q가 주어진다.&lt;/div&gt;&lt;div&gt;- 처음에 우리는 barycentric coordinates를 계산한다.&lt;/div&gt;&lt;div&gt;- 그것으로 부터, 우리는 Voronoi region을 결정하고, 가장 가까운 점 P를 결정한다.&lt;/div&gt;&lt;div&gt;input : A, B, Q&lt;/div&gt;&lt;div&gt;compute u and v&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;if (u &amp;lt;= 0)&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;P = B&lt;/div&gt;&lt;div&gt;else if( v &amp;lt;= 0)&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;P = A&lt;/div&gt;&lt;div&gt;else&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;P = u * A + v * B&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;* Section 2 : Point to Triangle&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;- 우리는 상세히 point to line segment를 다루었다.&lt;/div&gt;&lt;div&gt;- 이제 우리가 좀 더 어려운 문제로 이동하도록 하자 : point to triangle.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Triangle&lt;/div&gt;&lt;div&gt;- 여기에 2D의 삼각형이 있다.&lt;/div&gt;&lt;div&gt;- 선분들 처럼, 우리는 주어진 query point에 대해 Voronoi regions을 확인할 수 있다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Closest feature : vertex&lt;/div&gt;&lt;div&gt;- 여기에서 closest feature는 vertex B이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Closeset feature : edge&lt;/div&gt;&lt;div&gt;- 여기에서 closest feature는 edge BC이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Closest feature : interior&lt;/div&gt;&lt;div&gt;- 이 경우에, closest feature는 triangle&#39;s interior이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Voronoi regions&lt;/div&gt;&lt;div&gt;- 그 평면을 다시 Voronoi regions으로 나누자.&lt;/div&gt;&lt;div&gt;- 이러한 것들이 closest feature regions이라는 것을 기억해라.&lt;/div&gt;&lt;div&gt;- 예를들어, region AB에 있는 한 점은 edge AB의 내부와 가장 가깝다.&lt;/div&gt;&lt;div&gt;- dashed lines이 인접한 edges와 수직이라는 것을 주목해라.&lt;/div&gt;&lt;div&gt;- 우리는 3개의 vertex regions, 3개의 edge regions, 그리고 1개의 내부 region을 갖는다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* 3 line segments&lt;/div&gt;&lt;div&gt;- 우리는 그 삼각형의 3개의 edges를 3개의 line segments로 다룰 수 있다.&lt;/div&gt;&lt;div&gt;- 우리는 각 선분과 관련하여 Q의 uv들을 결정할 수 있다.&lt;/div&gt;&lt;div&gt;- 우리는 우리가 triangle의 Voronoi regions을 결정하는 것을 돕기 위해 line segment barycentric coordinates를 결합할 수 있다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Vertex regions&lt;/div&gt;&lt;div&gt;- 선분 uv들을 결합하여, 우리는 Q가 vertex region에 있는지를 결정할 수 있다.&lt;/div&gt;&lt;div&gt;- 예를들어, region A는 선분 CA의 u와 선분 AB의 v로부터 결정된다.&lt;/div&gt;&lt;div&gt;- 그것은 subscripts가 가리키는 것이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;region A : u_CA &amp;lt;= 0 &amp;amp;&amp;amp; v_AB &amp;lt;= 0&lt;/div&gt;&lt;div&gt;region B : u_AB &amp;lt;= 0 &amp;amp;&amp;amp; v_BC &amp;lt;= 0&lt;/div&gt;&lt;div&gt;region C : u_BC &amp;lt;= 0 &amp;amp;&amp;amp; v_CA &amp;lt;= 0&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Edge regions&lt;/div&gt;&lt;div&gt;- 우리는 the line segment barycentric coordinates를 사용하여 한 점이 edge region에 있는지를 부분적으로(partially) 결정할 수 있다.&lt;/div&gt;&lt;div&gt;- 그러나 그것들이 우리에게 한 점이 AB의 위 또는 아래에 있는지를 말해주지 않기 때문에 어떤 정보를 놓치는 중이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;ex) u_AB &amp;gt; 0 &amp;amp;&amp;amp; v_AB &amp;gt;0 인데, 그 점이 edge 위에 있는지 아래에 있는지 모른다.&lt;/div&gt;&lt;div&gt;Line segment uv가 충분하지 않다는 것이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Interior region&lt;/div&gt;&lt;div&gt;- 또한, 우리는 한 점이 내부에 있는지를 결정할 방법을 가지고 있지 않다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Triangle barycentric coordinates&lt;/div&gt;&lt;div&gt;- 우리는 삼각형에 대해 Q의 barycentric coordinates를 연산하여 우리가 필요한 추가 정보를 얻을 수 있다.&lt;/div&gt;&lt;div&gt;- 우리가 Q를 그 삼각형들의 정점의 가중된 합으로 표현하자.&lt;/div&gt;&lt;div&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20Q%20%3D%20uA%20&amp;amp;plus;%20vB%20&amp;amp;plus;%20wC&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;/div&gt;&lt;div&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20u%20&amp;amp;plus;%20v%20&amp;amp;plus;%20w%20%3D%201&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;/div&gt;&lt;div&gt;- 선분에서 처럼, 우리는 barycentric coordinates가 더해서 1이 되기를 요구한다. 이제는 2개 대신에 3개의 좌표를 요구하는 것을 제외하고.&lt;/div&gt;&lt;div&gt;- 우리는 여전히 부호에 어떠한 제한을 두고있지 않다. 그래서 그 좌표들은 개별적으로 음수가 될 수 있다.&lt;/div&gt;&lt;div&gt;- 이러한 새로운 barycentric coordinates는 (u,v,w)의 관점에서 평면위의 어떤 점을 나타내게 해준다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Linear algebra solution&lt;/div&gt;&lt;div&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Cbegin%7Bbmatrix%7D%20A_x%20%26%20B_x%20%26%20C_x%5C%5C%20A_y%20%26%20B_y%20%26%20C_y%5C%5C%201%20%26%201%20%26%201%20%5Cend%7Bbmatrix%7D%20%5Cbegin%7Bbmatrix%7D%20u%5C%5C%20v%5C%5C%20w%20%5Cend%7Bbmatrix%7D%20%3D%20%5Cbegin%7Bbmatrix%7D%20Q_x%5C%5C%20Q_y%5C%5C%201%20%5Cend%7Bbmatrix%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;/div&gt;&lt;div&gt;- 만약 우리가 이전의 방정식을 결합한다면, 우리는 선형대수를 사용하여 Q의 barycentric coordinates를 연산할 수 있다.&lt;/div&gt;&lt;div&gt;- 우리는 이 방식으로 그것들을 연산하지 않을 것이다. 왜냐하면 그것은 우리의 기하학적 이해를 줄이기 때문이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Fractional areas&lt;/div&gt;&lt;div&gt;- 우리가 삼각형에 대해 barycentric coordinates를 기하학적으로 이해하게 해보자. 이제, 우리는 Q가 내부에 있다고 가정한다.&lt;/div&gt;&lt;div&gt;- 그 point to line segment problem을 다시 떠올리자.&lt;/div&gt;&lt;div&gt;- 그 경우에, 우리는 barycentric coordinates를 partial segments의 fractional lengths에 연관시켰었다.&lt;/div&gt;&lt;div&gt;- 비슷한 방식으로, 우리는 그 삼각형의 barycentric coordinates를 partial triangles의 fractional areas에 연관시킬 수 있다.&lt;/div&gt;&lt;div&gt;- 이것은 barycentric coordinates가 안에 들어있는(insribed) 삼각형들의 면적에(areas) 비례하다는 것을 가리킨다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* The barycentric coordinates are the fractional areas&lt;/div&gt;&lt;div&gt;- 그래서 u는 BCQ의 면적에 비례한다.&lt;/div&gt;&lt;div&gt;- u가 A에 대한 barycentric coordinate 이지만, 그것이 오직 A를 포함하지 않는 sub-triangle 만의 area에 비례한다는 것에 주의해라.&lt;/div&gt;&lt;div&gt;- 비슷한 규칙들이 v와 w에 적용된다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;u ~ Area(BCQ)&lt;/div&gt;&lt;div&gt;v ~ Area(CAQ)&lt;/div&gt;&lt;div&gt;w ~ Area(ABQ)&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Barycentric coordinates&lt;/div&gt;&lt;div&gt;- 만약 우리가 Q를 A 쪽으로 움직인다고 상상해라&lt;/div&gt;&lt;div&gt;- 그러고나서, u는 전체 삼각형을 덮게 되고, 반면에 v와 w는 사라진다.&lt;/div&gt;&lt;div&gt;- 그러므로, u는 명백히 A에 대한 가중치이다.&lt;/div&gt;&lt;div&gt;- 안에있는 삼각형들을 기반으로, 우리는 u,v,w에 대한 이러한 공식들에 도달하게 된다.&lt;/div&gt;&lt;div&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20u%20%3D%20%5Cfrac%7Barea%28QBC%29%7D%7Barea%28ABC%29%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20v%20%3D%20%5Cfrac%7Barea%28QCA%29%7D%7Barea%28ABC%29%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20w%20%3D%20%5Cfrac%7Barea%28QAB%29%7D%7Barea%28ABC%29%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Barycentric coordinates are fractional&lt;/div&gt;&lt;div&gt;- 너는 여기에서 한 경향성을 알아차렸을지도 모른다.&lt;/div&gt;&lt;div&gt;- line segments에 대해 우리는 barycentric coordinates는 fractional lengths이다.&lt;/div&gt;&lt;div&gt;- triangles에 대해, barycentric coordinates는 fractional areas 이다.&lt;/div&gt;&lt;div&gt;- tetrahedrons에 대해 너는 barycentric coordinates가 fractional volumes이라는 것을 추측할지도 모른다. 그리고 그게 맞다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;line segment : fractional length&lt;/div&gt;&lt;div&gt;triangles : fractional area&lt;/div&gt;&lt;div&gt;tetrahedrons : fractional volume&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Computing Area&lt;/div&gt;&lt;div&gt;- 그래서 우리는 어떻게 한 삼각형의 면적을 연산하는가?&lt;/div&gt;&lt;div&gt;- 평행사변형의 넓이가 그 삼각형의 두 개의 변의 외적으로부터 구해진다는 것을 상기해라.&lt;/div&gt;&lt;div&gt;- 2D에서 cross product는 scalar이다.&lt;/div&gt;&lt;div&gt;- 삼각형 ABC의 넓이는 관련된 평행사변형의 넓이의 절반이다.&lt;/div&gt;&lt;div&gt;- ABC의 감기는 순서(winding order)에 따라서, 그 area가 음수일 수 있다는 것에 주의해라.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Q outside the triangle&lt;/div&gt;&lt;div&gt;- 우리가 삼각형에 대해 signed areas를 쓰기 때문에, 우리는 Q가 ABC의 밖에 있는 경우를 처리할 수 있다.&lt;/div&gt;&lt;div&gt;- Q가 edge BC의 밖에 있을 때, v와 w는 양수이고, 그것들의 합은 1보다 더 크다.&lt;/div&gt;&lt;div&gt;- 반면에, BCQ의 감기는 순서는 반대가 된다. 그래서 U는 음수가 된다.&lt;/div&gt;&lt;div&gt;- 그럼에도 불구하고, 그 합은 u + v + w == 1이 된다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Voronoi versus Barycentric&lt;/div&gt;&lt;div&gt;- Voronoi regios != barycentric coordinate regions&lt;/div&gt;&lt;div&gt;- The barycentric regions는 여전히 유용하다.&lt;/div&gt;&lt;div&gt;- 우리가 계속하기전에, 나는 중요한 구분을 할 필요가 있다.&lt;/div&gt;&lt;div&gt;- 우리의 접근법은 Voronoi regions을 사용하여 가장 가까운 점을 연산하는 것이다.&lt;/div&gt;&lt;div&gt;- 우리는 그러한 영역을 찾는 것을 돕기 위해 barycentric coordinates를 연산한다.&lt;/div&gt;&lt;div&gt;- line segment의 경우에, 우리는 barycentric coordinates가 즉시 우리에게 Voronoi regions을 준다는 것을 알았다.&lt;/div&gt;&lt;div&gt;- 그러나 삼각형에 대해서, Voronoi regions는 barycentric coordinates에 의해 결정되는 regions과 같지 않다.&lt;/div&gt;&lt;div&gt;- 우리는 이것을 다룰 수 있지만, 처음에 한 삼각혀에 대해 barycentric regions에 대해 보자.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Barycentric regions of a triangle&lt;/div&gt;&lt;div&gt;- 여기에 우리의 삼각혀이 있다.&lt;/div&gt;&lt;div&gt;- barycentric regions가 무엇인가?&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Interior&lt;/div&gt;&lt;div&gt;- 우리는 모든 좌표들이 양수일 때, interior region을 갖는다.&lt;/div&gt;&lt;div&gt;u &amp;gt; 0 &amp;amp;&amp;amp; v &amp;gt;0 &amp;amp;&amp;amp; w&amp;gt; 0&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Negative u&lt;/div&gt;&lt;div&gt;- 만약 u가 음수라면 (u &amp;lt;= 0), 그러면 Q는 edge BC 밖에 있다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Negative v&lt;/div&gt;&lt;div&gt;- 만약 v가 음수라면, 그러면 Q는 edge CA 밖에 있다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Negative w&lt;/div&gt;&lt;div&gt;- 마지막으로, 만약 w가 음수라면, 그러면 Q는 edge AB 밖에 있다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* The uv regions are not exclusive&lt;/div&gt;&lt;div&gt;- barycentric regions는 상호배제하지 않는다.&lt;/div&gt;&lt;div&gt;- 두 개의 barycentric coordinates가 동시에 음수일 수 있다.&lt;/div&gt;&lt;div&gt;- 이 경우에, 그 query point는 동시에 두 개의 edges의 밖에 있다.&lt;/div&gt;&lt;div&gt;- 일반적으로, 이것은 Q가 vertex region에 있다는 것을 가리키지 않는다.&lt;/div&gt;&lt;div&gt;- 이 슬라이드에서, 우리는 Q가 BC와 CA 밖에 있는 것을 보지만, BC에 가장 가깝다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Finding the Voronoi region&lt;/div&gt;&lt;div&gt;- Voronoi region을 인식하기 위해 barycentric coordinates를 사용해라&lt;/div&gt;&lt;div&gt;- 3개의 line segments와 그 삼각형에 대한 Coordinates&lt;/div&gt;&lt;div&gt;- Regions는 올바른 순서로 고려되어야 한다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;- 우리는 이제 triangle의 Voronoi regions을 결정할 충분한 정보를 가지고 있다.&lt;/div&gt;&lt;div&gt;- 한 query point P는 삼각형과 그리고 3개의 선분들 독립적으로 barycentric coodinates를 가질 수 있다.&lt;/div&gt;&lt;div&gt;- 이것은 총 9개의 barycentric coordinates를 준다.&amp;nbsp;&lt;/div&gt;&lt;div&gt;- 각 line segment에 대해 두 개 그리고 그 삼각형에 대해 3개&lt;/div&gt;&lt;div&gt;- 우리는 Voronoi region을 결정하기 위해 이러한 9개의 스칼라값을 사용할 수 있다.&lt;/div&gt;&lt;div&gt;- 우리는 우리의 logic을 올바르게 구성하기 위해 주의해야만 한다.&lt;/div&gt;&lt;div&gt;-&amp;nbsp; 올바른 접근법은 처음에 가장 낮은 차원의 features를 고려하는 것이다: vertices, 그러고나서 edges, 그러고나서 triangle&#39;s interior&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* First : vertex regions&lt;/div&gt;&lt;div&gt;- 우리는 처음에 vertex regions을 테스트한다.&lt;/div&gt;&lt;div&gt;- 여기에 우리는 3개의 line segments로부터 6개의 coordinates를 사용한다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;region vertex A : u_CA &amp;lt;= 0 &amp;amp;&amp;amp; v_AB &amp;lt;= 0&lt;/div&gt;&lt;div&gt;region vertex B : u_AB &amp;lt;= 0 &amp;amp;&amp;amp; v_BC &amp;lt;= 0&lt;/div&gt;&lt;div&gt;region vertex C : u_BC &amp;lt;= 0 &amp;amp;&amp;amp; v_CA &amp;lt;= 0&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Second : edge regions&lt;/div&gt;&lt;div&gt;- line segment uv들이 query point가 edge Voronoi region 안에 있는지를 결정하는데 충분하지 않다는 것을 상기해라.&lt;/div&gt;&lt;div&gt;- 편리하게도, 삼각형의 uv는 놓친 정보를 제공한다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Second : edge regions solved&lt;/div&gt;&lt;div&gt;- 우리는 line segment uv들을 triangle uv와 결합할 수 있는데, query point가 edge region 안에 있는지를 결정하기 위해서이다.&lt;/div&gt;&lt;div&gt;- 우리는 그 query point가 A와 B 사이에 있는지를 가리키기 위해 두 개의 line segment uv를 갖는다.&lt;/div&gt;&lt;div&gt;- 우리는 이제 그 query point가 AB 위에 있는지를 가리키기 위해 triangle w coordinate를 가진다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;region edge AB : u_AB &amp;gt; 0 &amp;amp;&amp;amp; v_AB &amp;gt; 0 &amp;amp;&amp;amp; w_ABC &amp;lt;= 0&lt;/div&gt;&lt;div&gt;region edge BC : u_BC &amp;gt; 0 &amp;amp;&amp;amp; v_BC &amp;gt; 0 &amp;amp;&amp;amp; u_ABC &amp;lt;= 0&lt;/div&gt;&lt;div&gt;region edge CA : u_CA &amp;gt; 0 &amp;amp;&amp;amp; v_CA &amp;gt; 0 &amp;amp;&amp;amp; v_ABC &amp;lt;= 0&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Third : interior region&lt;/div&gt;&lt;div&gt;- 모든 다른 테스트들이 실패한 후에, 우리는 Q가 interior region에 있다고 결정한다.&lt;/div&gt;&lt;div&gt;- 어떠한 다른 경우가 없기 때문에, 우리는 삼각형 uv들이 모두 양수라고 주장한다.&lt;/div&gt;&lt;div&gt;region interior ABC : u_ABC &amp;gt; 0 &amp;amp;&amp;amp; v_ABC &amp;gt; 0 &amp;amp;&amp;amp; w_ABC &amp;gt; 0&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Closest point&amp;nbsp;&lt;/div&gt;&lt;div&gt;- Find the Voronoi region for point Q&lt;/div&gt;&lt;div&gt;- Use the barycentric coordinates to compute the closest point P&lt;/div&gt;&lt;div&gt;- 마침내 우리는 삼각형에서 가장 가까운 점을 연산할 준비가 되었다.&lt;/div&gt;&lt;div&gt;- 처음에, 우리는 점 Q에 대해 Voronoi region을 찾는다.&lt;/div&gt;&lt;div&gt;- 그러고나서, 우리는 가장 가까운 점을 연산하기 위해 적절한 barycentric coordinates를 사용한다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Example 1&lt;/div&gt;&lt;div&gt;- 여기에 가장 가까운 점을 어떻게 연산하는지에 대한 예제가 있다.&lt;/div&gt;&lt;div&gt;- 우리는 삼각형 ABC와 query point Q로 시작한다.&lt;/div&gt;&lt;div&gt;- 우리는 u_AB가 음수라는 것을 결정한다.&lt;/div&gt;&lt;div&gt;- 우리는 v_BC가 또한 음수라는 것을 결정한다.&lt;/div&gt;&lt;div&gt;- 우리는 Q가 vertex region B에 있다고 결론짓는다.&lt;/div&gt;&lt;div&gt;- 그래서 P = B이다.&lt;/div&gt;&lt;div&gt;- A와 C는 P에 기여하지 않는다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Example 2&lt;/div&gt;&lt;div&gt;- 여기에 다른 위치를 가진 Q의 또 다른 예시이다.&lt;/div&gt;&lt;div&gt;- 처음에, Q는 어떠한 vertex region에 들어있지 않다고 결정한다.&lt;/div&gt;&lt;div&gt;- 우리는 Q가 B의 오른쪽에 있다는 것을 결정한다 (u_AB &amp;gt; 0)&lt;/div&gt;&lt;div&gt;- 그리고 A의 왼쪽에 있다는 것을 결정한다. (v_AB &amp;gt; 0)&lt;/div&gt;&lt;div&gt;- 그래서 Q는 A와 B 사이에 있다.&lt;/div&gt;&lt;div&gt;- 우리는 Q가 AB의 밖에 있는지를 결정하기 위해 삼각형의 barycentric coordinate를 사용한다.&lt;/div&gt;&lt;div&gt;- Q는 edge region AB에 있다. (u_AB &amp;gt; 0 &amp;amp;&amp;amp; v_AB &amp;gt; 0 &amp;amp;&amp;amp; w_ABC &amp;lt;= 0)&lt;/div&gt;&lt;div&gt;- 가장 가까운 점 P는 AB 위에 있다.&lt;/div&gt;&lt;div&gt;- 그래서 우리는 P를 결정하기 위해 AB의 barycentric coordinates를 사용한다&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;P = u_AB * A + v_AB * B&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Implementation&lt;/div&gt;&lt;div&gt;input: A, B, C, Q&lt;/div&gt;&lt;div&gt;compute uAB, vAB, uBC, vBC, uCA, vCA&lt;/div&gt;&lt;div&gt;compute uABC, vABC, wABC&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;// Test vertex regions&lt;/div&gt;&lt;div&gt;...&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;// Test edge regions&lt;/div&gt;&lt;div&gt;...&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;// Else interior region&lt;/div&gt;&lt;div&gt;...&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;- 우리는 입력으로 삼각형의 정점들과 query point Q를 갖는다.&lt;/div&gt;&lt;div&gt;- 모든 line segment barycentric coordinates를 연산해라.&lt;/div&gt;&lt;div&gt;- 그러고나서 triangular barycentric coordinates를 연산해라.&lt;/div&gt;&lt;div&gt;- 그러고나서 우리는 Voronoi regions을 연산하기 시작한다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Testing the vertex regions&lt;/div&gt;&lt;div&gt;// Region A&lt;/div&gt;&lt;div&gt;if ( vAB &amp;lt;= 0 &amp;amp;&amp;amp; uCA &amp;lt;= 0)&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;P = A&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;return&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;// Similar tests for Region B and C&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;- 처음에 3 개의 vertex regions을 테스트한다.&lt;/div&gt;&lt;div&gt;- 우리는 여기에서 early return을 얻을 수 있다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Testing the edge regions&lt;/div&gt;&lt;div&gt;// Region AB&lt;/div&gt;&lt;div&gt;if (uAB &amp;gt; 0 &amp;amp;&amp;amp; vAB &amp;gt; 0 &amp;amp;&amp;amp; wABC &amp;lt;= 0)&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; P = uAB * A + vAB * B&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; return&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;// Similar for Regions BC and CA&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;- 다음에 우리는 edge regions를 테스트한다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Testing the interior region&lt;/div&gt;&lt;div&gt;// Region ABC&lt;/div&gt;&lt;div&gt;assert(uABC &amp;gt; 0 &amp;amp;&amp;amp; vABC &amp;gt; 0 &amp;amp;&amp;amp; wABC &amp;gt; 0)&lt;/div&gt;&lt;div&gt;P = Q&lt;/div&gt;&lt;div&gt;return&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;이 점에서, Q는 그 삼각형의 내부에 있음에 틀림없다. 그래서 우리는 이것이 사실이라고 주장한다.&lt;/div&gt;&lt;div&gt;- 그러고나서 barycentric coordinates는 triangular barycentric coordinates이고, 모든 삼각형 정점들은 P에 기여한다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;* Section 3 : Point to Convex Polygon&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;- 그래서 우리는 point vs triangle을 정복했다.&lt;/div&gt;&lt;div&gt;- 이제, point to convex polygon을 봐서 우리의 목표에 더 가까이 가자.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Convex polygon&lt;/div&gt;&lt;div&gt;- 여기에 임의의 convex polygon (볼록 다각형) ABCDE가 있다.&lt;/div&gt;&lt;div&gt;- 우리는 그 다각형이 한 변(edge)를 가로지르는 내부의 점들 사이의 선분이 존재하지 않기 때문에 convex라고 말한다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Polygon structure&lt;/div&gt;&lt;div&gt;struct Polygon&lt;/div&gt;&lt;div&gt;{&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;Vec2* points;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;int count;&lt;/div&gt;&lt;div&gt;};&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;- 여기에 polygon structure 코드가 있다.&lt;/div&gt;&lt;div&gt;- 이것은 2D points의 배열이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Convex polygon : closest point&lt;/div&gt;&lt;div&gt;- 그래서 이제 우리는 query point Q를 가지고 있다.&lt;/div&gt;&lt;div&gt;- 우리는 가장 가까운 점 P를 결정하기를 원한다.&lt;/div&gt;&lt;div&gt;- 우리는 이것을 쉽게 시각화할 수 있다. 그러나, 컴퓨터가 이것을 정확하고 효율적으로 하게 하는 것은 또 다른 문제이다.&lt;/div&gt;&lt;div&gt;- How do we compute P?&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* What do we know?&lt;/div&gt;&lt;div&gt;- Closest point to point&lt;/div&gt;&lt;div&gt;- Closest point to line segment&lt;/div&gt;&lt;div&gt;- Closest point to triangle&lt;/div&gt;&lt;div&gt;- 우리가 이미 어떻게 할 지를 아는 것들이 위의 것이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Simplex&lt;/div&gt;&lt;div&gt;- 편리성을 위해서, 우리는 points, line segments, triangles를 하나의 공통된 주제 아래에서 그룹화 한다.&lt;/div&gt;&lt;div&gt;- A simplex is a point, a line segment, a triangle, or a tetrahedron 이다.&lt;/div&gt;&lt;div&gt;- 우리는 0차원 simplex에 대해 0-simplex라고 말한다 (a point), 1차원 simplex에 대해 1-simplex(a line segment), 등등&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Idea : inscribe a simplex&lt;/div&gt;&lt;div&gt;- 그래서 여기에 P를 연산하는 것에 대한 아이디어가 있다.&lt;/div&gt;&lt;div&gt;- 우리는 그 polygon에 triangle을 inscribe한다.&lt;/div&gt;&lt;div&gt;- 왜 그렇게 하는가?&lt;/div&gt;&lt;div&gt;- 왜냐하면 우리는 한 삼각형에서 가장 가까운 점을 어떻게 연산할지를 알고 있기 때문이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Idea : closest point on simplex&lt;/div&gt;&lt;div&gt;- Vertex C가 Q에 대한 simplex에서 가장 가까운 점이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Idea : evolve the simplex&lt;/div&gt;&lt;div&gt;- 이제 Q에 대해 simplex를 어느정도 진화시키기 위해 그 simplex에서 가장 가까운 점을 사용한다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Simplex vertex&lt;/div&gt;&lt;div&gt;struct SimplexVertex&lt;/div&gt;&lt;div&gt;{&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;Vec2 point;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;int index;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;float u;&lt;/div&gt;&lt;div&gt;};&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;- 여기에 simplex vertex structure가 있다.&lt;/div&gt;&lt;div&gt;- 그 점은 한 polygon vertex로부터 복사된다.&lt;/div&gt;&lt;div&gt;- 우리는 또한 그 index를 저장한다.&lt;/div&gt;&lt;div&gt;- 우리 closest point calculations를 위해 barycentric coordinate u를 포함한다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Simplex&lt;/div&gt;&lt;div&gt;struct Simplex&lt;/div&gt;&lt;div&gt;{&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;SimplexVertex vertexA;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;SimplexVertex vertexB;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;SimplexVertex vertexC;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;int count;&lt;/div&gt;&lt;div&gt;};&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;- 여기에 simplex data structure가 있다.&lt;/div&gt;&lt;div&gt;- 그것은 a point, a line segment, or a triangle를 나타낼 수 있다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* We are onto a winner!&lt;/div&gt;&lt;div&gt;- 그래서 나는 우리가 성공가능한 것을 찾아냈다고 생각한다.&lt;/div&gt;&lt;div&gt;- 우리는 처리할 어떤 세부사항을 가진다.&lt;/div&gt;&lt;div&gt;- 주로, 우리는 그 simplex를 어떻게 진화시킬지를 이해할 필요가 있다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* GJK distance algorithm&lt;/div&gt;&lt;div&gt;- Computes the closest point on a convex polygon&lt;/div&gt;&lt;div&gt;- Invented by Gilbert, Johnson, and Keerthi&lt;/div&gt;&lt;div&gt;- 운 좋게도, Gilbert, Johnson, and Keerthi가 우리를 위해 GJK라고 불려지는 한 알고리즘의 세부사항을 작업했다.&lt;/div&gt;&lt;div&gt;- Gilbert와 회사는 1980년대 후반에 알고리즘에 대한 몇 가지 논문들을 썼었다.&lt;/div&gt;&lt;div&gt;- 그것들은 모두 매우 수학적이고 이해하기에 어렵다.&lt;/div&gt;&lt;div&gt;- 그것들은 또한 좋은 pastel colors가 부족하다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* The GJK distance algorithm&lt;/div&gt;&lt;div&gt;- Inscribed simplexes&lt;/div&gt;&lt;div&gt;- Simplex evolution&lt;/div&gt;&lt;div&gt;- 그것의 깊은 수학적 뿌리에도 불구하고, GJK는 직관적 기하학 해석이다.&lt;/div&gt;&lt;div&gt;- GJK는 iterative algorithm이다.&lt;/div&gt;&lt;div&gt;- 우리는 우리의 convex polygon에 새겨진 한 임의의 simplex로 시작한다.&lt;/div&gt;&lt;div&gt;- 우리는 그 simplex에서 가장 가까운 점을 연산하고, 그 polygon에서 가장 가까운 점 쪽으로 simplex를 진화시키기위해 그 결과를 사용한다.&lt;/div&gt;&lt;div&gt;- 원리적으로, 우리는 유한한 개수의 반복으로 정확한 솔루션을 얻는다. 현실적으로, 우리가 처리해야 할 numerical problems가 있다.&lt;/div&gt;&lt;div&gt;- GJK 알고리즘을 더 섦여하기 보다, 이 시점에서, 그것이 어떻게 작동하는지에 대한 예제를 보는 것이 더 좋다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Starting simplex&lt;/div&gt;&lt;div&gt;- Start with arbitrary vertex. Pick E.&lt;/div&gt;&lt;div&gt;- This is our starting simplex&lt;/div&gt;&lt;div&gt;- 우리는 우리의 convex polygon과 query point Q를 가지고 있다.&lt;/div&gt;&lt;div&gt;- 우리는 한 임의의 simplex를 골라서 GJK 알고리즘을 시작한다.&lt;/div&gt;&lt;div&gt;- 이 경우에, 우리는 vertex E를 가진 0-simplex를 선택한다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Closest point on simplex&lt;/div&gt;&lt;div&gt;- P is the closest point&lt;/div&gt;&lt;div&gt;- 다음으로 우리는 Q에 대해 우리의 simplex에서 가장 가까운 점을 결정한다.&lt;/div&gt;&lt;div&gt;- 이 경우에 P = E이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Search vector&lt;/div&gt;&lt;div&gt;- Draw a vector from P to Q. And call this vector &lt;b&gt;d&lt;/b&gt;.&lt;/div&gt;&lt;div&gt;- 이제 우리는 search vector를 구성한다.&lt;/div&gt;&lt;div&gt;- 이 벡터는 우리의 simplex에 있는 가장 가까운점에서 Q를 가리킨다.&lt;/div&gt;&lt;div&gt;- 우리가 0-simplex를 가지고 있기 때문에, 그 가장 가까운 점은 E이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Find the support point&lt;/div&gt;&lt;div&gt;- Find the vertex on polygon furthest in direction &lt;b&gt;d&lt;/b&gt;.&lt;/div&gt;&lt;div&gt;- This is the support point.&lt;/div&gt;&lt;div&gt;- 우리는 이제 search direction에서 가장 멀리있는 정점을 결정한다.&lt;/div&gt;&lt;div&gt;- 이것은 support point라고 불려진다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Support point code&lt;/div&gt;&lt;div&gt;&lt;!-- HTML generated using hilite.me --&gt;&lt;br /&gt;&lt;div style=&quot;background: #111111; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;&quot;&gt;&lt;pre style=&quot;line-height: 125%; margin: 0;&quot;&gt;&lt;span style=&quot;color: #cdcaa9; font-weight: bold;&quot;&gt;int&lt;/span&gt; &lt;span style=&quot;color: #ff0086; font-weight: bold;&quot;&gt;Support&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;const&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;Polygon&amp;amp;&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;poly,&lt;/span&gt; &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;const&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;Vec2&amp;amp;&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;d)&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: white;&quot;&gt;{&lt;/span&gt;&lt;br /&gt;   &lt;span style=&quot;color: #cdcaa9; font-weight: bold;&quot;&gt;int&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;index&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #0086f7; font-weight: bold;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;;&lt;/span&gt;&lt;br /&gt;   &lt;span style=&quot;color: #cdcaa9; font-weight: bold;&quot;&gt;float&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;maxValue&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;Dot(d,&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;poly.points[index]);&lt;/span&gt;&lt;br /&gt;   &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;for&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color: #cdcaa9; font-weight: bold;&quot;&gt;int&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;i&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #0086f7; font-weight: bold;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;;&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;i&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;poly.count;&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;++i)&lt;/span&gt;&lt;br /&gt;   &lt;span style=&quot;color: white;&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      &lt;span style=&quot;color: #cdcaa9; font-weight: bold;&quot;&gt;float&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;value&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;Dot(d,&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;poly.points[i]);&lt;/span&gt;&lt;br /&gt;      &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color: white;&quot;&gt;(value&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;maxValue)&lt;/span&gt;&lt;br /&gt;      &lt;span style=&quot;color: white;&quot;&gt;{&lt;/span&gt;&lt;br /&gt;         &lt;span style=&quot;color: white;&quot;&gt;index&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;i;&lt;/span&gt;&lt;br /&gt;         &lt;span style=&quot;color: white;&quot;&gt;maxValue&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;value;&lt;/span&gt;&lt;br /&gt;      &lt;span style=&quot;color: white;&quot;&gt;}&lt;/span&gt;&lt;br /&gt;   &lt;span style=&quot;color: white;&quot;&gt;}&lt;/span&gt;&lt;br /&gt;   &lt;span style=&quot;color: #fb660a; font-weight: bold;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: white;&quot;&gt;index;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: white;&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;- 여기에 그 support point를 연산하는 코드가 있다.&lt;br /&gt;- 그 거리는 간단한 dot product로 결정된다.&lt;br /&gt;- 그 코드는 모든 polygon vertices에 대해 반복하고, 가장 큰 내적 값을 추적한다.&lt;br /&gt;- 그 비교가 모두 상대적이기 때문에, search direction d는 표준화 될 필요가 없다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Support point found&lt;br /&gt;- C is the support point.&lt;br /&gt;- 이 경우에, 시각적으로 C가 명백히 support point이다.&lt;br /&gt;- 그래서 우리는 C로 무엇을 하는가?&lt;/div&gt;&lt;div&gt;&lt;br /&gt;* Evolve the simplex&lt;br /&gt;- Create a line segment CE&lt;br /&gt;- We now have a 1-simplex.&lt;br /&gt;- 우리는 C를 현재의 simplex와 합친다.&lt;br /&gt;- 우리가 E를 가진 0-simplex를 가졌기 때문에, 우리는 이제 CE를가진 1-simplex를 가진다.&lt;br /&gt;&lt;br /&gt;* Repeat the process&lt;br /&gt;- Find closest point P on CE&lt;br /&gt;- 우리는 그 프로세스를 이제 반복한다.&lt;br /&gt;- 우리는 우리의 현재 simplex CE에서 가장 가까운 점을 찾는다.&lt;br /&gt;&lt;br /&gt;* New search direction&lt;br /&gt;- Build &lt;b&gt;d&lt;/b&gt; as a line pointing from P to Q&lt;br /&gt;- 우리는 P에서 Q를 가리키는 새로운 search direction을 구성한다.&lt;br /&gt;&lt;br /&gt;* New support point&lt;br /&gt;- D is the support point&lt;br /&gt;- 다음으로, 우리는 방향 d에서 새로운 support point를 연산한다.&lt;br /&gt;- 우리는 support point로서 D를 찾는다.&lt;br /&gt;&lt;br /&gt;* Evolve the simplex&lt;br /&gt;- Create triangle CDE.&lt;br /&gt;- This is a 2-simplex.&lt;br /&gt;- 우리는 우리의 simplex에 D를 합치고, 2-simplex CDE를 만든다.&lt;br /&gt;&lt;br /&gt;* Closest point&lt;br /&gt;- Compute closest point on CDE to Q&lt;br /&gt;- 우리는 그 simplex에 대해 가장 가까운 점으로서 P를 연산한다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* E is worthless&lt;br /&gt;- Closest point is on CD&lt;br /&gt;- E does not contribute&lt;br /&gt;- 우리는 E가 P에 기여하지 않는 다는 것을 알게 된다.&lt;br /&gt;- 그래서 우리는 simplex에서 E를 제외한다.&lt;br /&gt;- 우리는 simplex가 결코 3개 이상의 정점을 갖지 않도록 기여하지 않는 정점을 cull해야한다.&lt;br /&gt;&lt;br /&gt;* Reduced simplex&lt;br /&gt;- We dropped E, so we now have a 1-simplex&lt;br /&gt;- 현재 simplex는 이제 CD 이다.&lt;br /&gt;- 우리가 2-simplex에서 1 or 0-simplex로 갈 수 있다는 것을 주목해라.&lt;br /&gt;- 그래서 우리는 동시에 두 개 까지의 simplex vertices를 제거할 수 있다.&lt;br /&gt;&lt;br /&gt;* Termination&lt;br /&gt;- Compute support point in direction &lt;b&gt;d&lt;/b&gt;.&lt;br /&gt;- We find either C or D. Since this is a repeat, we are done.&lt;br /&gt;- 우리는 P에서 Q를 가리키는 새로운 search vector를 형성한다.&lt;br /&gt;- 이제 그 새로운 support point는 C 또는 D 둘 중 하나이다.&lt;br /&gt;- 우리는 그 점을 유일하게 결정할 수 없다.&lt;br /&gt;- 그러나 그것은 중요하지 않다.&lt;br /&gt;- 이러한 정점들은 이미 simplex에 있기 때문에, 우리는 어떠한 진행을 할 수 없다.&lt;br /&gt;- 그러므로, 우리는 P가 가장 가까운 점으로 그 알고리즘을 종료시킨다.&lt;br /&gt;&lt;br /&gt;* GJK algorithm&lt;br /&gt;Input : polygon and point Q&lt;br /&gt;pick arbitrary initial simplex S&lt;br /&gt;loop&lt;br /&gt;&amp;nbsp; &amp;nbsp;compute closest point P on S&lt;br /&gt;&amp;nbsp; &amp;nbsp;cull non-contributing vertices from S&lt;br /&gt;&amp;nbsp; &amp;nbsp;build vector d pointing from P to Q&lt;br /&gt;&amp;nbsp; &amp;nbsp;compute support point in direction &lt;b&gt;d&lt;/b&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp;add support point to S&lt;br /&gt;end&lt;br /&gt;- 여기에 GJK 알고리즘에 대한 pseudo code가 있다.&lt;br /&gt;- 이것은 iterative algorithm이고, 그래서 우리는 loop해야만 한다.&lt;br /&gt;- 이 코드는 종료 조건을 포함하지 않는다.&lt;br /&gt;- 나는 이것을 잠시 뒤에 다룰 것이다.&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Numerical Issues&lt;br /&gt;- Search Direction&lt;br /&gt;- Termination&lt;br /&gt;- Poorly formed polygons&lt;/div&gt;&lt;div&gt;- 내가 너에게 경고했었듯이, 우리가 다룰 필요가 있는 많은 numerical problems가 있다.&lt;br /&gt;- 내 경험에서, 이러한 문제들은 search direction과 loop termination에 영향을 미친다.&lt;br /&gt;&lt;br /&gt;* A bad direction&lt;br /&gt;- &lt;b&gt;d&lt;/b&gt; can be built from PQ&lt;br /&gt;- Due to round-off : dot(Q - P, C- E) != 0&lt;br /&gt;- 이제까지, 우리는 P에서 Q로가는 벡터로서 search direction을 연산했었다.&lt;br /&gt;- 이것은 항상 가장 좋은 접근법이 아니다.&lt;br /&gt;- 이 예제에서, P는 the line segment CE에서 barycentric coordinates로부터 연산된다.&lt;br /&gt;- Barycentric coordinates는 round off error를 겪는다. 그래서 PQ는 segment CE에 대해 수직이 아닐지도 모른다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;* A real example in single precision&lt;br /&gt;Line Segment&lt;br /&gt;A = [0.021119118, 79.584320]&lt;br /&gt;B = [0.020964622, -31.515678]&lt;br /&gt;&lt;br /&gt;Query Point&lt;br /&gt;Q = [0.0 0.0]&lt;br /&gt;&lt;br /&gt;Barycentric Coordinates&lt;br /&gt;(u, v) = (0.28366947, 0.71633047)&lt;br /&gt;&lt;br /&gt;Search Direction&lt;br /&gt;d = Q - P = [-0.021008447, 0.0]&lt;br /&gt;&lt;br /&gt;dot(d, B - A) = 3.2457051e-006&lt;br /&gt;&lt;br /&gt;- 여기에 내가 겪었던 실제 세계 예제가 있다.&lt;br /&gt;- 나는 선분 AB와 query point Q를 가지고있다.&lt;br /&gt;- 나는 가장 가까운 점 P를 연산하고, search direction d를 만들기 위해 그것을 사용한다.&lt;br /&gt;- 내가 segment direction과 search direction을 내적을 연산했을때, 0이 아닌 값을 얻는다.&lt;/div&gt;&lt;div&gt;- 그렇다, 그것은 작언 에러지만, search direction에서 작은에러들은 커질 수 있다.&lt;br /&gt;&lt;br /&gt;* Small errors matter&lt;br /&gt;- 부정확한 search directions는 나쁘다. 왜냐하면 그것들은 부정확한 support points를 이끌 수 있기 때문이다.&lt;br /&gt;- 이것은 괃환 반복 또는 심지어 부정확한 결과를 이끌지도 모른다.&lt;br /&gt;&lt;br /&gt;* An accurate search direction&lt;br /&gt;- Directly compute a vector perpendicular to CE&lt;br /&gt;- &lt;b&gt;d&lt;/b&gt; = cross(C - E, &lt;b&gt;z&lt;/b&gt;)&lt;br /&gt;- where &lt;b&gt;z&lt;/b&gt; is normal to the plane.&lt;/div&gt;&lt;div&gt;- 우리가 어려움없이 정확한 search direction을 얻을 수 있다는 것이 밝혀졌다.&lt;br /&gt;- 가장 가까운 점이 한 edge위에 있을 때, 너는 search direction을 연산하기 위해 closest point를 사용해선 안된다.&lt;br /&gt;- 대신에, 그 edge에 수직인 벡터를 형성하여 search direction을 연산하는게 더 좋다.&lt;br /&gt;- 우리는 edge vector와 plane normal를 외적하여 perpendicular vector를 얻을 수 있다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;* The dot product is exactly zero&lt;br /&gt;- edge direction : &lt;b&gt;e&lt;/b&gt; = (x y)&lt;br /&gt;- search direction : d = (-y x)&lt;br /&gt;- dot product : dot(e, d) = -xy+ xy = 0&lt;br /&gt;- 이것은 search direction이 그 edge에 수직이라는 것을 의미한다.&lt;br /&gt;- 그 내적은 numerically하게 zero이다. 심지어 floating point arithmetic으로 할지라도.&lt;br /&gt;&lt;br /&gt;* Fixing the sign&lt;br /&gt;- Flip the sign of d so that : dot(d, Q - C) &amp;gt; 0&lt;br /&gt;- Perk : no divides&lt;br /&gt;- 그러고나서 우리는 그것이 Q를 가리키도록하기 위해 d의 부호를 바꿀 필요가 있다.&lt;br /&gt;&lt;br /&gt;* Termination conditions&lt;br /&gt;- 부정확한 search directions으로, termination conditions는 많은 슬픔을 만들어 낼 수 있다.&lt;br /&gt;- 우리는 너무 일찍 종료하길 원하지 않고, 전혀 종료하지 않길 원하지 않는다.&lt;br /&gt;- infinite loop는 너의 frame-rate를 죽일 모든 것이다.&lt;br /&gt;- 그래서 우리는 termination conditions에 좋은 일들을 하려고 해야 한다.&lt;br /&gt;&lt;br /&gt;* Case 1 : repeated support point&lt;br /&gt;- 우리의 첫 번째 케이스는 반복된 support point이다.&lt;br /&gt;- 이 경우에, 우리는 우리의 현재 simplex에 속하는 support point를 연산한다.&lt;br /&gt;- 이것은 우리가 어떠한 진행을 할 수 없다는 것을 가리킨다.그래서, 우리는 가장 가까운 점 P로 종료해야 한다.&lt;br /&gt;&lt;br /&gt;* Case 2 : containment&lt;br /&gt;- We find a 2-simplex and all vertices contribute&lt;br /&gt;- 우리의 GJK 반복에서 어떤 시점에서, 우리는 2-simplex를 발견할지도 모르는데, 거기에서 Q에 대한 모든 triangular barycentric coordinates가 양수일 수 있다.&lt;br /&gt;- 이것은 Q가 2-simplex 안에 있다는 것을 의미한다. 그러므로, parent polygon 안에 있다는 것이다.&lt;br /&gt;&lt;br /&gt;* Case 3a : vertex overlap&lt;br /&gt;- We will compute &lt;b&gt;d&lt;/b&gt; = Q - P as zero&lt;br /&gt;- So we terminate if &lt;b&gt;d&lt;/b&gt; = &lt;b&gt;0&lt;/b&gt;&lt;br /&gt;- 만약 Q가 한 정점과 중첩된다면, 그러면 P = Q이고, 우리는 zero search direction을 연산하게 될 것이다.&lt;br /&gt;- 그래서 우리는 d가 zero라면 종료해야 한다.&lt;br /&gt;&lt;br /&gt;* Case 3b : edge overlap&lt;br /&gt;- &lt;b&gt;d&lt;/b&gt; will have an arbitrary sign&lt;br /&gt;- Q가 edge와 중첩되는 것이 가능하다.&lt;br /&gt;- 우리는 d를 perpendicular vector로서 연산할 수 있다.&lt;br /&gt;- 그러나, 우리는 그것의 부호를 결정할 수 없다.&lt;br /&gt;- d의 부호가 임의로 될 것이기 때문에, 우리는 두 경우를 조사해야 한다.&lt;br /&gt;&lt;br /&gt;* Case 3b : d points left&lt;br /&gt;- If we search left, we get a duplicate support point. In this case we terminate.&lt;br /&gt;- 만약 d가 왼쪽을 가리킨다면, 우리는 Case 1 : a duplicate support point를 얻는다.&lt;br /&gt;&lt;br /&gt;* Case 3b : d points right&lt;br /&gt;- If we search right, we get a new support point (A).&lt;br /&gt;- 만약 d가 오른쪽을 가리킨다면, 그러면 우리는 새로운 support point를 얻는다.&lt;br /&gt;&lt;br /&gt;- But then we get back the same P, and then the same d.&lt;br /&gt;- Soon, we detect a repeated support point or detect containment.&lt;br /&gt;- round-off error에 따라, 우리는 P가 edge CD 위에 있거나 P가 triangle ACD안에 있다는 것을 알게 될 것이다.&lt;br /&gt;- 그래서 우리는 duplicate vertex를 얻거나 또는 containment를 탐지할 것이다.&lt;br /&gt;&lt;br /&gt;* Case 4 : interior edge&lt;br /&gt;- &lt;b&gt;d&lt;/b&gt; will have an arbitrary sign&lt;br /&gt;- 우리가 고려하는 마지막 경우는 Q가 우리의 simplex의 interior edge와 중첩될 때 이다.&lt;br /&gt;- 이 경우에, 우리의 simplex는 an interior line segment이다.&lt;br /&gt;- Q가 그 line segment와 중첩되기 때문에, 우리는 d를 유일하게 결정할 수 없다.&lt;br /&gt;&lt;br /&gt;- Similar to Case 3b&lt;br /&gt;- 이것은 궁극적으로 Case 3b와 같다.&lt;br /&gt;- 우리가 어떤 d의 부호를 결정하든, 우리는 repeated vertex를 탐지할 수 있을것이다.&lt;br /&gt;&lt;br /&gt;* Termination in 3D&lt;br /&gt;- May require new/different conditions&lt;br /&gt;- Check for distance progression&lt;br /&gt;- 3D에서 GJK는 다른 termination conditions이 필요하다.&lt;br /&gt;- 예를들어, 너는 P에서 Q로 가는 거리가 매 반복마다 줄어드는지를 테스트 할 필요가 있을지도 모른다.&lt;br /&gt;&lt;br /&gt;* Non-convex polygon&lt;br /&gt;- Vertex B is non-convex&lt;br /&gt;- 만약 우리가 non-convex polygon을 만난다면 무슨일이 발생하는가?&lt;br /&gt;&lt;br /&gt;* Non-convex polygon&lt;br /&gt;- B is never a support point&lt;br /&gt;- GJK는 non-convex vertex는 보지 않을 것이다. 왜냐하면 , 그것은 결코 support point로서 나타나지 않을 것이기 때문이다.&lt;br /&gt;&lt;br /&gt;* Collinear vertices&lt;br /&gt;- B, C, and D are collinear&lt;br /&gt;- collinear points로는 무엇이 발생하는가?&lt;br /&gt;&lt;br /&gt;- 2-simplex BCD&lt;br /&gt;- 우리는 degenerate triangular simplex로 끝날 수 있다.&lt;br /&gt;&lt;br /&gt;- area(BCD) = 0&lt;br /&gt;- 그 삼각형 넓이는 zero이다. 그래서 그 triangular barycentric coordinates는 무한이다.&lt;br /&gt;- 너는 area로 나누는 것을 피할 수 있다.&lt;br /&gt;- 너는 너의 triangle solver가 이 경우에 vertex or edge region을 선택하도록 보장해야만 한다.&lt;br /&gt;- 세부사항에 대해 데모코드를 보아라.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;* Section 4 : Convex Polygon to Convex Polygon&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;- 그래서 그것이 GJK를 위한 것이다.&lt;br /&gt;- 우리는 이제 우리의 최종 목표를 다룰 준비가 되어있다: 한 쌍의 convex polygons 사이의 closest point.&lt;br /&gt;&lt;br /&gt;* Closest point between convex polygons&lt;br /&gt;- 그래서 우리는 두 개의 convex polygons 사이의 가장 가까운 점을 연산하기를 원한다.&lt;br /&gt;- 이것은 a single polygon에서 가장 가까운 점 보다 더 복잡한 것처럼 보일지도 모른다.&lt;br /&gt;- 그러나, 그 두 문제를 연관짓는 방법이 있다.&lt;br /&gt;&lt;br /&gt;* What do we know?&lt;br /&gt;- 우리는 GJK 반복을 사용하여 point to polygon을 풀기위해 point to simplex problem에 대한 지식을 적용했었다.&lt;br /&gt;&lt;br /&gt;* What do we need to know?&lt;br /&gt;- 이제, 우리는 어떻게 point to polygon의 지식을 polygon to polygon에 적용할 수 있는가?&lt;br /&gt;&lt;br /&gt;* Idea&lt;br /&gt;- Convert polygon to polygon into point to polygon&lt;br /&gt;- Use GJK to solve point to polygon&lt;br /&gt;- 그 기본 아이디어는 우리는 polygon to polygon을 point to polygon으로 바꾼다.&lt;br /&gt;- 그러고나서 우리는 point to polygon problem을 풀기위해 GJK를 사용할 수 있다.&lt;br /&gt;&lt;br /&gt;* Minkowski difference&lt;br /&gt;- 우리에게 정확히 우리가 필요한 것을 주는 Minkowski difference라고 불려지는 geometrical construction이 있다고 밝혀졌다.&lt;br /&gt;- Minkowski difference는 우리가 두 개의 polygons을 단일의 convex polygon으로 합치도록 해준다.&lt;br /&gt;&lt;br /&gt;* Minkowski difference definition&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20Z%20%3D%5Cbegin%7BBmatrix%7D%20y_j%20-%20x_i%20%3A%20x_i%20%5Cin%20X%2C%20y_j%20%5Cin%20Y%20%5Cend%7BBmatrix%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- 여기에, Minkowski difference에 대한 수학적 정의가 있다.&lt;br /&gt;&lt;br /&gt;* Building the Minkowski difference&lt;br /&gt;Input : polygon X and Y&lt;br /&gt;array points&lt;br /&gt;for all xi in X&lt;br /&gt;&amp;nbsp; &amp;nbsp; for all yj in Y&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; points.push_back(yj - xi)&lt;br /&gt;&amp;nbsp; &amp;nbsp; end&lt;br /&gt;end&lt;br /&gt;&lt;br /&gt;polygon Z = ConvexHull(points)&lt;br /&gt;&lt;br /&gt;- 우리는 단순한 기법을 사용하여 super polygon을 구성 할 수 있다.&lt;br /&gt;- 우리는 두 폴리곤의 점들 사이의 차를 연산하기 위해 두 개의 nested loops를 사용한다.&lt;br /&gt;- 그러고나서 우리는 그 point cloud의 convex hull를 연산한다.&lt;br /&gt;- 물론,이것은 하기에 싸지 않지만, 인내심을 가져라&lt;br /&gt;- 무지개 끝에 황금이 있다.&lt;br /&gt;&lt;br /&gt;* Example point cloud&lt;br /&gt;- 여기에 그 point cloud가 이 삼각형과 사각형에 대해 어떻게 보이는지가 있다.&lt;br /&gt;- 그렇다, 나는 실제로 그러한 점들을 연산한다.&lt;br /&gt;&lt;br /&gt;* Building the convex hull&lt;/div&gt;&lt;div&gt;- 나는 convex hull algorithms을 다루지 않을 것이지만, 개념적으로 우리는 convex hull algorithm을 a shrink wrapping process로서 상상할 수 있다.&lt;br /&gt;&lt;br /&gt;- 우리는 extreme point로 시작하고, 둘레를 따라 우리의 길을 만든다.&lt;br /&gt;&lt;br /&gt;* The final polygon&lt;br /&gt;- 우리는 이제 Minkowski difference polygon에 도착했다.&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* Property 1 : distances are equal&lt;br /&gt;- distance(X, Y) == distance(O, Y - X)&lt;br /&gt;- Minkowski difference는 몇 가지 &lt;b&gt;&lt;span style=&quot;font-size: x-large;&quot;&gt;놀랄만한&lt;/span&gt;&lt;/b&gt; 특성들을 가지고 있다. (유레카적)&lt;br /&gt;- 처음에, X와 Y 사이의 거리는 원점과 super polygon 사이의 거리와 가탇.&lt;br /&gt;&lt;br /&gt;* Property 2 : support points&lt;br /&gt;- support(Z, d) = support(Y, d) - support(X, -d)&lt;br /&gt;- 둘 째로, 우리는 X와 Y의 support points를 결합하여 Z의 한 support point를 결정할 수 있다.&lt;br /&gt;- 우리는 Y에서 d 방향에 있는 support point와 X에서 -d방향의 support point를 사용한다.&lt;br /&gt;- 이러한 두 개의 support points의 차는 Z에서의 support point와 동일하다.&lt;br /&gt;- 우리는 explicitly하게 Z를 구성하지 않고 Z의 support point를 연산할 방법을 안다.&lt;br /&gt;&lt;br /&gt;- 이것은 우리가 Z를 explicitly하게 구성할 필요가 없다는 것을 의미한다.&lt;br /&gt;- 그래서 우리는 convex hull을 연산할 필요가 없다.&lt;br /&gt;- 이것은 우리의 어플리케이션에서 많은 양의 시간과 공간을 절약시킨다.&lt;br /&gt;&lt;br /&gt;* Modifying GJK&lt;br /&gt;- Change the support function&lt;br /&gt;- Simplex vertices hold two indices&lt;br /&gt;- 우리는 Minkowski difference를 다루기 위 쉽게 GJK를 수정할 수 있다.&lt;br /&gt;- 우리는 그냥 support function을 바꾸고 좀 더 bookkeeping을 추가할 필요가 있다.&lt;br /&gt;- 세부사항을 위해 데모 코드를 보아라.&lt;br /&gt;&lt;br /&gt;* Closest point on polygons&lt;br /&gt;- Use the barycentric coordinates to compute the closest point on X and Y&lt;br /&gt;- See the demo code for details&lt;br /&gt;- 우리는 또한 원래의 폴리곤에 대해 closest points를연산하기 위해 GJK를 수정할 수 있다.&lt;br /&gt;- 그러고나서 우리는 the closest points를 결정하기위해 original vertices에 대해 barycentric coordinates를 적용한다.&lt;br /&gt;- 또 다시, 세부사항에 대해서는 데모 코드를 보아라.&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://chanhaeng.blogspot.com/feeds/5366335068658685125/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://chanhaeng.blogspot.com/2019/03/gdc-2010-erin-catto-computing-distance.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/3538290929769251376/posts/default/5366335068658685125'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/3538290929769251376/posts/default/5366335068658685125'/><link rel='alternate' type='text/html' href='http://chanhaeng.blogspot.com/2019/03/gdc-2010-erin-catto-computing-distance.html' title='GDC 2010 Erin Catto - Computing Distance (GJK Algorithm)'/><author><name>chan</name><uri>http://www.blogger.com/profile/14387528357950501854</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3538290929769251376.post-4697345544900533672</id><published>2019-03-12T06:45:00.000-07:00</published><updated>2019-03-12T06:45:49.909-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="[Programming] Game"/><title type='text'>지금까지 만든 것 (2019년 1월 기준)</title><content type='html'>1월에 프로젝트를 끝내고 이것저것 하다보니 업데이트를 해놓지 않았다.&lt;br /&gt;이런 기록을 남겨두는 것은 이전으로부터 어떻게 발전해왔는지를 보여주기 때문에&lt;br /&gt;종종 남겨놓는 것이 좋다고 생각한다.&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;span style=&quot;text-align: start;&quot;&gt;&lt;a href=&quot;https://youtu.be/KSpS1TO2YgM&quot;&gt;https://youtu.be/KSpS1TO2YgM&lt;/a&gt;&lt;/span&gt;&lt;br /&gt;&lt;iframe width=&quot;320&quot; height=&quot;266&quot; class=&quot;YOUTUBE-iframe-video&quot; data-thumbnail-src=&quot;https://i.ytimg.com/vi/KSpS1TO2YgM/0.jpg&quot; src=&quot;https://www.youtube.com/embed/KSpS1TO2YgM?feature=player_embedded&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;1. 현재 만들어놓은 3D 게임 엔진의 최종 상황이다.&lt;br /&gt;Sponza 모델과 Nanosuit를 통해 렌더링 했다.&lt;br /&gt;영상은 최종 Scene을 만들기 위해 Light의 여러 Property를 수정하는 것을 보여준다.&lt;br /&gt;아직 Culling 기능을 개발하지 않고 최적화가 이루어지지 않아 한 프레임 연산 속도는 느리다. Object Picking With Broad Phase(Dynamic AABB Tree), Model Loading (using Assimp) and Rendering + Model Diffuse/Specular/Emissive/Normal/Height Map (Normal Mapping, Parallax Occlusion Mapping), Light Property 편집, Light Shadow 설정 등이 들어갔다. learnopengl.com에서 배웠던 것을 Deferred Rendering 기반으로 바꾸면서 나의 이해를 증진시켰다. Post-Processing으로 Gamma Correction, Bloom, SSAO가 들어갔다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;https://youtu.be/c333rQkeskM&quot;&gt;https://youtu.be/c333rQkeskM&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;iframe width=&quot;320&quot; height=&quot;266&quot; class=&quot;YOUTUBE-iframe-video&quot; data-thumbnail-src=&quot;https://i.ytimg.com/vi/c333rQkeskM/0.jpg&quot; src=&quot;https://www.youtube.com/embed/c333rQkeskM?feature=player_embedded&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;2. 물리엔진 기반을 Box2D로 바꾸기로 결심하면서 Box2D-lite 코드를 이해하고 DirectX11 로 포팅해서 시뮬레이션 세팅하여 찍은 영상이다. 현재 Box2D 관련 자료들을 공부하며 이 기반을 다시 철저히 이해하기 위해 공부중이다. 2D를 이해하고 3D로 넘어갈 예정이다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;https://youtu.be/gEwG9HVjTYk&quot;&gt;https://youtu.be/gEwG9HVjTYk&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;iframe width=&quot;320&quot; height=&quot;266&quot; class=&quot;YOUTUBE-iframe-video&quot; data-thumbnail-src=&quot;https://i.ytimg.com/vi/gEwG9HVjTYk/0.jpg&quot; src=&quot;https://www.youtube.com/embed/gEwG9HVjTYk?feature=player_embedded&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;3. Terrain Rendering + Physics&lt;br /&gt;Terrain을 Triangle Strip으로 한 번의 draw call로 렌더링했다.&lt;br /&gt;그리고 Mesh vs Sphere의 Collision Detection and Response를 특히, Collision Detection 부분을 Bullet Physics를 참고해서 따라했다. 그 Bullet Physics의 코드를 이해하고 내 엔진에 적용할 수 있어서 매우 도전적이고 재미있는 경험이였다.&lt;br /&gt;여기에서 BroadPhase(Dynamic AABB Tree) -&amp;gt; Mesh Quantization -&amp;gt; Early Exit (AABB vs AABB(of sphere) -&amp;gt; Narrow Phase(Triangle vs Sphere, Closest point on triangle using barycentric coordinate from Real Time Collision Detection book). 등의 많은 것들이 적용되었다. Mesh vs Box를 구현하려다 포기하고 Box2D로 돌아가게 되는 계기였는데, 어쨋든 가치있는 작업이였다.&lt;br /&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://chanhaeng.blogspot.com/feeds/4697345544900533672/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://chanhaeng.blogspot.com/2019/03/2019-1.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/3538290929769251376/posts/default/4697345544900533672'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/3538290929769251376/posts/default/4697345544900533672'/><link rel='alternate' type='text/html' href='http://chanhaeng.blogspot.com/2019/03/2019-1.html' title='지금까지 만든 것 (2019년 1월 기준)'/><author><name>chan</name><uri>http://www.blogger.com/profile/14387528357950501854</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://img.youtube.com/vi/KSpS1TO2YgM/default.jpg" height="72" width="72"/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3538290929769251376.post-7493136171956226004</id><published>2019-03-09T08:57:00.002-08:00</published><updated>2019-03-12T22:53:22.438-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="[Programming] GamePhysics"/><title type='text'>GDC2007 Erin Catto 발표</title><content type='html'>&lt;b&gt;&lt;span style=&quot;font-size: x-large;&quot;&gt;Modeling and Solving Constraints&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;* 개요&lt;br /&gt;- Constraints는 joints, contact, and collision을 재현하기 위해 사용된다.&lt;br /&gt;- 우리는 박스들을 쌓고, ragdoll limbs가 붙어있도록 하기 위해 contraints를 풀어야 한다.&lt;br /&gt;- Constraint solvers는 impulse or forces를 계산하고, 그것들은 constrained bodies에 적용&amp;nbsp; &amp;nbsp; 하여 이것을 한다.&lt;br /&gt;&lt;br /&gt;* 개관&lt;br /&gt;- Constraint Formulas&lt;br /&gt;- Deriving Constraints : Joints, Motors, Contact&lt;br /&gt;- Building a Constraint Solver&lt;br /&gt;&lt;br /&gt;* Constraint Types&lt;br /&gt;- Contact and Friction&lt;br /&gt;- Ragdolls&lt;br /&gt;- Particles and Cloth&lt;br /&gt;&lt;br /&gt;* Motivation&lt;br /&gt;- Bead on a Rigid Wire (2D)&lt;br /&gt;- Implicit Function C(x) = 0&lt;br /&gt;- This is a constraint equation!&lt;br /&gt;&lt;br /&gt;* Velocity&lt;br /&gt;- The normal vector is perpendicular to the curve&lt;br /&gt;- So this dot product is zero:&amp;nbsp;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Ctextbf%7Bn%7D%5ET%20%5Ctextbf%7Bv%7D%3D%200&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;br /&gt;* Velocity Constraint&lt;br /&gt;- Position Constraint : C(x) = 0&lt;br /&gt;- 만약 C가 zero라면, 그러면 그것의 시간에 대한 미분은 0이여야 한다.&lt;br /&gt;- Velocity Constraint :&amp;nbsp;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Cdot%7B%5Ctextbf%7BC%7D%7D%20%3D%200&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- Velocity constraints는 허용되는 motion을 정의한다.&lt;br /&gt;- Velocity constraints는 impulses를 적용하여 만족될 수 있다.&lt;br /&gt;- 이후에 더 다룬다.&lt;br /&gt;&lt;br /&gt;* The Jacobian&lt;br /&gt;- 연쇄법칙에 의해, velocity constraint는 특별한 구조를 갖는다:&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Cdot%7BC%7D%20%3D%20%5Ctextbf%7BJ%7D%5Ctextbf%7Bv%7D%20%3D%200&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- &lt;b&gt;J&lt;/b&gt;는 jacobian이다.&lt;br /&gt;- 그 Jacobian은 velocity에 수직이다&lt;br /&gt;&lt;br /&gt;* The Velocity Map&lt;br /&gt;- &lt;b&gt;V&lt;/b&gt;(Cartesian Space Velocity) -&amp;gt; &lt;b&gt;J&lt;/b&gt; -&amp;gt; dot(&lt;b&gt;C&lt;/b&gt;) (Constraint Space Velocity)&lt;br /&gt;&lt;br /&gt;* Constraint Force&lt;br /&gt;- Assume the wire is frictionless&lt;br /&gt;- What is the force between the wire and the bead&lt;br /&gt;&lt;br /&gt;* Lagrange Multiplier&lt;br /&gt;- 직관적으로 그 constraint force &lt;b&gt;F&lt;/b&gt;_c는 normal vector와 평행하다.&lt;br /&gt;- 방향과 크기가 알려져 있다는 것은 다음을 암시한다&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Ctextbf%7BF%7D_c%20%3D%20%5Ctextbf%7BJ%7D%5ET%20%5Clambda&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- Lambda는 constraint force의 signed magnitude이다.&lt;br /&gt;- 우리는 lambda를 어떻게 계산하는가?&lt;br /&gt;- 그것이 solver의 일이다.&lt;br /&gt;- Solvers는 나중에 이야기 된다.&lt;br /&gt;&lt;br /&gt;* The Force Map&lt;br /&gt;- &lt;b&gt;ƛ&lt;/b&gt;(Constraint Space Force) -&amp;gt; &lt;b&gt;J&lt;/b&gt;^T -&amp;gt; &lt;b&gt;F&lt;/b&gt;_c (Cartesian Space Force)&lt;br /&gt;&lt;br /&gt;* Work, Energy, and Power&lt;br /&gt;- &lt;b&gt;Work&lt;/b&gt; = Force * Distance&lt;br /&gt;- Work는 단위 에너지를 갖는다 (Joules)&lt;br /&gt;- &lt;b&gt;Power&lt;/b&gt; = Force * Velocity (Watts)&lt;br /&gt;&lt;br /&gt;* Principle of Virtual Work&lt;br /&gt;- Constraint forces는 do not work이다. 그래서 그것들은 허용된 velocity에 수직이여야 한다.&lt;br /&gt;&lt;br /&gt;주장 :&amp;nbsp;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Ctextbf%7BF%7D_c%20%3D%20%5Ctextbf%7BJ%7D%5ET%20%5Clambda&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;증명 :&amp;nbsp;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Ctextbf%7BF%7D%5ET_c%20%5Ctextbf%7Bv%7D%20%3D%20%5Clambda%20%5Ctextbf%7BJ%7D%5Ctextbf%7Bv%7D%20%3D%200&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- 그래서 constraint force는 에너지에 영향을 미치지 않는다.&lt;br /&gt;&lt;br /&gt;* Constraint Quantities&lt;br /&gt;- Position Constraint : C&lt;br /&gt;- Velocity Constraint : dot(C)&lt;br /&gt;- Jacobian : &lt;b&gt;J&lt;/b&gt;&lt;br /&gt;- Lagrange Multiplier :&amp;nbsp;&lt;b&gt;ƛ&lt;/b&gt;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;&lt;/b&gt;* Why all the Painful Abstraction?&lt;br /&gt;- 모든 종류의 constraints를 solver를 위해 하나의 공통된 형태로 만들기 위해&lt;br /&gt;- 우리가 효율적으로 다른 solution 기법들을 시도할 수 있게 하기 위해&lt;br /&gt;&lt;br /&gt;* Time Dependence&lt;br /&gt;- Some constraints, like motors, have prescribed motion.&lt;br /&gt;- This is represented by time dependence&lt;br /&gt;Position : C(x, t) = 0&lt;br /&gt;Velocity: dot(C) = &lt;b&gt;Jv&lt;/b&gt; + b(t) = 0 ; b(t) is velocity bias&lt;br /&gt;&lt;br /&gt;* Example : Distance Constraint&lt;br /&gt;- Position : C = ||&lt;b&gt;x&lt;/b&gt;|| - L&lt;br /&gt;- Velocity : dot(C) = &lt;b&gt;x&lt;/b&gt;^T / ||&lt;b&gt;x&lt;/b&gt;|| * &lt;b&gt;v&lt;/b&gt;&lt;br /&gt;- Jacobian : &lt;b&gt;J&lt;/b&gt; = &lt;b&gt;x&lt;/b&gt;^T / ||&lt;b&gt;x&lt;/b&gt;||&lt;br /&gt;- Velocity Bias :&amp;nbsp; b = 0&lt;br /&gt;- ƛ is the tension&lt;br /&gt;&lt;br /&gt;* Gory Details&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Cfrac%7BdC%7D%7Bdt%7D%20%3D%20%5Cfrac%7Bd%7D%7Bdt%7D%28%5Csqrt%7Bx%5E2%20&amp;amp;plus;%20y%5E2%7D%20-%20L%29%20%5C%5C%20%3D%5Cfrac%7B1%7D%7B2%5Csqrt%7Bx%5E2%20&amp;amp;plus;%20y%5E2%7D%7D%5Cfrac%7Bd%7D%7Bdt%7D%28x%5E2%20&amp;amp;plus;%20y%5E2%29%20-%20%5Cfrac%7BdL%7D%7Bdt%7D%20%5C%5C%20%3D%20%5Cfrac%7B2%28xv_x%20&amp;amp;plus;%20yv_y%29%7D%7B2%5Csqrt%7Bx%5E2%20&amp;amp;plus;%20y%5E2%7D%7D%20-%200%20%5C%5C%20%3D%20%5Cfrac%7B1%7D%7B%5Csqrt%7Bx%5E2%20&amp;amp;plus;%20y%5E2%7D%7D%20%5Cbegin%7Bbmatrix%7D%20x%20%5C%5C%20y%20%5Cend%7Bbmatrix%7D%20%5ET%20%5Cbegin%7Bbmatrix%7D%20v_x%5C%5C%20v_y%20%5Cend%7Bbmatrix%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;br /&gt;* Computing the Jacobian&lt;br /&gt;- 처음에, Jacobian을 계산하는 것은 쉽지 않다.&lt;br /&gt;- constraint equation을 처음에 갖는 것은 도움이 된다.&lt;br /&gt;- 그것은 연습으로 더 쉬워진다&lt;br /&gt;- 벡터의 관점에서 생각해보려고 해라.&lt;br /&gt;&lt;br /&gt;* A Recipe for &lt;b&gt;J&lt;/b&gt;&lt;br /&gt;- C를 작성하기 위해 기하학을 사용해라&lt;br /&gt;- 시간에 대해 C를 미분해라&lt;br /&gt;- &lt;b&gt;v&lt;/b&gt;를 고립시켜라(isolate).&lt;br /&gt;- 검사해서 &lt;b&gt;J&lt;/b&gt;를 확인해라 (그리고 b도)&lt;br /&gt;- 편미분을 연산하지 말아라!&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Cdot%7BC%7D%20%3D%20%5Ctextbf%7BJ%7D%5Ctextbf%7Bv%7D%20&amp;amp;plus;%20b&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: x-large;&quot;&gt;* Homework&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;- Angle Constraint : C = &lt;b&gt;a&lt;/b&gt;1^T&lt;b&gt;a&lt;/b&gt;2 - cosθ&lt;br /&gt;- Point Constraint : C = &lt;b&gt;p&lt;/b&gt;2 - &lt;b&gt;p&lt;/b&gt;1&lt;br /&gt;- Line Constraint : C = (&lt;b&gt;p&lt;/b&gt;2 - &lt;b&gt;p&lt;/b&gt;1)^T * &lt;b&gt;a&lt;/b&gt;1 = 0&lt;br /&gt;&lt;br /&gt;* Newton&#39;s Law&lt;br /&gt;- 우리는 적용된 forces와 constraint forces를 나눈다.&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Ctextbf%7BM%7D%20%5Cdot%7B%5Ctextbf%7Bv%7D%7D%20%3D%20%5Ctextbf%7BF%7D_a%20&amp;amp;plus;%20%5Ctextbf%7BF%7D_c&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;br /&gt;* Types of Forces&lt;br /&gt;- 적용된 forces는 어떤 법칙에 따라 연산된다: F=mg, F=kx 등등&lt;br /&gt;- Constraints는 kinematic (motion) conditions을 부과한다.&lt;br /&gt;- Constraint forces는 implicit하다.&lt;br /&gt;- 우리는 constraint forces에 대해 solve해야 한다.&lt;br /&gt;&lt;br /&gt;* Constraint Potpourri(여러가지를 섞은 것)&lt;br /&gt;- Joints&lt;br /&gt;- Motors&lt;br /&gt;- Contact&lt;br /&gt;- Restitution&lt;br /&gt;- Friction&lt;br /&gt;&lt;br /&gt;* Joint : Distance Constraint&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Ctextbf%7BF%7D_a%20%3D%20m%20%5Ctextbf%7Bg%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Ctextbf%7BJ%7D%20%3D%20%5Cfrac%7B%5Ctextbf%7Bx%7D%5ET%7D%7B%7C%7C%5Ctextbf%7Bx%7D%7C%7C%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Ctextbf%7BF%7D_c%20%3D%20%5Ctextbf%7BJ%7D%5ET%20%5Clambda&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;br /&gt;* Motors&lt;br /&gt;- A motor는 limited force (torque)를 가진 constraint이다.&lt;br /&gt;C = θ - sint&amp;nbsp; (-10 &amp;lt;= ƛ &amp;lt;= 10)&lt;br /&gt;바퀴&lt;br /&gt;&lt;br /&gt;* Velocity Only Motors&lt;br /&gt;- Example&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Cdot%7BC%7D%20%3D%20%5Comega%20-%202&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20-5%20%5Cleq%20%5Clambda%20%5Cleq%205&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- 사용법 : 일정한 비율로 spin 하는 한 바퀴. 우리는 각을 신경쓰지 않는다.&lt;br /&gt;&lt;br /&gt;* Inequality Constraints&lt;br /&gt;- 이제까지, 우리는 equality constraints 를 보았다 (왜냐하면 그것들이 간단하기 때문에)&lt;br /&gt;- Inequality constraints (부등식 제약)은 contact, joint limits, rope 등을 위해 필요하다.&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20C%28%5Ctextbf%7Bx%7D%2C%20t%29%20%5Cgeq%200&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- What is the velocity constraint?&lt;br /&gt;만약&amp;nbsp;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20C%20%5Cleq%200&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&amp;nbsp;이라면&lt;br /&gt;&amp;nbsp; &amp;nbsp; enforce:&amp;nbsp;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Cdot%7BC%7D%20%5Cgeq%200&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;아니라면&lt;br /&gt;&amp;nbsp; constraint를 skip해라.&lt;br /&gt;- Force Limits :&amp;nbsp;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%200%20%5Cleq%20%5Clambda%20%5Cleq%20%5Cinfty&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- Inequality constraints don&#39;t suck&lt;br /&gt;&lt;br /&gt;* Contact Constraint&lt;br /&gt;- Non-penetration&lt;br /&gt;- Restitution : bounce&lt;br /&gt;- Friction : sliding, sticking, and rolling&lt;br /&gt;&lt;br /&gt;* Non-Penetration Constraint&lt;br /&gt;-&amp;nbsp;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20C%20%3D%20%5Cdelta&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&amp;nbsp;(separation)&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Cdot%7BC%7D%20%3D%20%28%5Ctextbf%7Bv%7D_%7Bp2%7D%20-%20%5Ctextbf%7Bv%7D_%7Bp1%7D%29%20%5Ccdot%20%5Ctextbf%7Bn%7D%20%5C%5C%20%3D%20%5Cbegin%7Bbmatrix%7D%20%5Ctextbf%7Bv%7D_2%20&amp;amp;plus;%20%5Ctextbf%7Bw%7D_2%20%5Ctimes%20%28%5Ctextbf%7Bp%7D%20-%20%5Ctextbf%7Bx%7D_2%29%20-%20%5Ctextbf%7Bv%7D_1%20-%20%5Ctextbf%7Bw%7D_1%20%5Ctimes%20%28%5Ctextbf%7Bp%7D%20-%20%5Ctextbf%7Bx%7D_1%29%20%5Cend%7Bbmatrix%7D%20%5Ccdot%20%5Ctextbf%7Bn%7D%20%5C%5C%20%3D%20%5Cbegin%7Bbmatrix%7D%20-%5Ctextbf%7Bn%7D%5C%5C%20-%28%5Ctextbf%7Bp%7D%20-%20%5Ctextbf%7Bx%7D_1%29%20%5Ctimes%20%5Ctextbf%7Bn%7D%5C%5C%20%5Ctextbf%7Bn%7D%5C%5C%20%28%5Ctextbf%7Bp%7D%20-%20%5Ctextbf%7Bx%7D_2%29%20%5Ctimes%20%5Ctextbf%7Bn%7D%20%5Cend%7Bbmatrix%7D%20%5Cbegin%7Bbmatrix%7D%20%5Ctextbf%7Bv%7D_1%5C%5C%20%5Ctextbf%7Bw%7D_1%5C%5C%20%5Ctextbf%7Bv%7D_2%5C%5C%20%5Ctextbf%7Bw%7D_2%20%5Cend%7Bbmatrix%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;b&gt;J&lt;/b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;b&gt;v&lt;/b&gt;&lt;br /&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/b&gt;(이 행렬에 ^T 해야함 모르고 빼먹음)&lt;br /&gt;- Handy Identities&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Ctextbf%7BA%7D%20%5Ccdot%20%28%5Ctextbf%7BB%7D%20%5Ctimes%20%5Ctextbf%7BC%7D%29%20%3D%20%5Ctextbf%7BC%7D%20%5Ccdot%20%28%5Ctextbf%7BA%7D%20%5Ctimes%20%5Ctextbf%7BB%7D%29%20%3D%20%5Ctextbf%7BB%7D%20%5Ccdot%20%28%5Ctextbf%7BC%7D%20%5Ctimes%20%5Ctextbf%7BA%7D%29&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;br /&gt;* Restitution&lt;br /&gt;- Relative Normal Velocity&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20v_n%20%3D%20%28%5Ctextbf%7Bv%7D_%7Bp2%7D%20-%20%5Ctextbf%7Bv%7D_%7Bp1%7D%29%20%5Ccdot%20%5Ctextbf%7Bn%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- Velocity Reflection&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20v_n%5E&amp;amp;plus;%20%5Cgeq%20-ev_n%5E-&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- bounce를 velocity bias로 더하기&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Cdot%7BC%7D%20%3D%20v%5E&amp;amp;plus;_n%20&amp;amp;plus;%20ev%5E-_n&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20b%20%3D%20ev%5E-_n&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;br /&gt;* Friction Constraint&lt;br /&gt;- Friction은 velocity-only motor와 같다.&lt;br /&gt;- target velocity는 zero이다.&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Cdot%7BC%7D%20%3D%20%5Ctextbf%7Bv%7D_p%20%5Ccdot%20%5Ctextbf%7Bt%7D%20%5C%5C%20%3D%20%5Cbegin%7Bbmatrix%7D%20%5Ctextbf%7Bv%7D%20&amp;amp;plus;%20%5Ctextbf%7Bw%7D%20%5Ctimes%20%28%5Ctextbf%7Bp%7D%20-%20%5Ctextbf%7Bx%7D%29%20%5Cend%7Bbmatrix%7D%20%5Ccdot%20%5Ctextbf%7Bt%7D%20%5C%5C%20%3D%20%5Cbegin%7Bbmatrix%7D%20%5Ctextbf%7Bt%7D%20%5C%5C%20%28%5Ctextbf%7Bp%7D%20-%20%5Ctextbf%7Bx%7D%29%20%5Ctimes%20%5Ctextbf%7Bt%7D%20%5Cend%7Bbmatrix%7D%20%5E%20T%20%5Cbegin%7Bbmatrix%7D%20%5Ctextbf%7Bv%7D%20%5C%5C%20%5Ctextbf%7Bw%7D%20%5Cend%7Bbmatrix%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;b&gt;J&lt;/b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;b&gt;v&lt;/b&gt;&lt;br /&gt;- friction force는 normal force에 의해 제한된다&lt;br /&gt;- Coulomb&#39;s Law :&amp;nbsp;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%7C%5Clambda_t%7C%20%5Cleq%20%5Cmu%20%5Clambda_n&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- Or :&amp;nbsp;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20-%5Cmu%20%5Clambda_n%20%5Cleq%20%5Clambda_t%20%5Cleq%20%5Cmu%20%5Clambda_n&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- Where :&amp;nbsp;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Cmu%20%5Cgeq%200&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;&lt;/b&gt;* What is a Solver?&lt;br /&gt;- 모든 forces를 모으고, velocity와 position을 integrate한다.&lt;br /&gt;- 새로운 상태(state)가 제약을 만족하도록 하기 위해 constraint forces를 적용&lt;br /&gt;- constraint forces가 implicit이기 때문에, 그 constraint forces에 대해 solve해야만 한다.&lt;br /&gt;&lt;br /&gt;* Solver Types&lt;br /&gt;- Global Solvers (slow)&lt;br /&gt;- Iterative Solvers (fast)&lt;br /&gt;&lt;br /&gt;* Solving A Chain&lt;br /&gt;- Global :&lt;br /&gt;solve for ƛ1, ƛ2, ƛ3 simultaneously.&lt;br /&gt;- Iterative:&lt;br /&gt;while !done&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;solve for ƛ1&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;solve for ƛ2&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;solve for ƛ3&lt;br /&gt;&lt;br /&gt;* Sequential Impulses (SI)&lt;br /&gt;- An iterative solver&lt;br /&gt;- SI는 velocity errors를 고치기 위해 각 constraint에 impulses를 적용&lt;br /&gt;- Si는 빠르고 안정적이다 (보통).&lt;br /&gt;- global solution에 수렴한다 (결국에)&lt;br /&gt;&lt;br /&gt;* Why Impulses?&lt;br /&gt;- friction과 collision을 다루기에 더 쉽다.&lt;br /&gt;- Velocity는 가속도보다 더 직관적이다.&lt;br /&gt;- time step을 고려한다면, impulse와 force는 상호교환가능하다.&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Ctextbf%7BP%7D%20%3D%20h%20%5Ctextbf%7BF%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;br /&gt;* Sequential Impulses&lt;br /&gt;- Step1 : applied forces를 Integrate하고, 새로운 velocities를 만듬.&lt;br /&gt;- Step2 : velocity errors를 고치기 위해 모든 constraints에 대해 순차적으로 impulses 적용&lt;br /&gt;- Step3 : positions를 업데이트하기 위해 그 새로운 velocities를 사용.&lt;br /&gt;&lt;br /&gt;* Step1 : Integrate Applied Forces&lt;br /&gt;- Euler&#39;s Method&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Coverline%7B%5Ctextbf%7Bv%7D%7D_2%20%3D%20%5Ctextbf%7Bv%7D_1%20&amp;amp;plus;%20h%20%5Ctextbf%7BM%7D%5E%7B-1%7D%20%5Ctextbf%7BF%7D_a&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- 이 새로운 velocity는 velocity constraints를 위반하는(violate) 경향이 있다.&lt;br /&gt;&lt;br /&gt;* Step2 : Apply Corrective Impulses&lt;br /&gt;- 각 constraint에 대해 다음을 solve:&lt;br /&gt;Newton :&amp;nbsp;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Ctextbf%7Bv%7D_2%20%3D%20%5Coverline%7B%5Ctextbf%7Bv%7D%7D_2%20&amp;amp;plus;%20%5Ctextbf%7BM%7D%5E%7B-1%7D%20%5Ctextbf%7BP%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;Virtual Work :&amp;nbsp;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Ctextbf%7BP%7D%20%3D%20%5Ctextbf%7BJ%7D%5ET%20%5Clambda&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;Velocity Constraint :&amp;nbsp;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Ctextbf%7BJ%7D%5Ctextbf%7Bv%7D_2%20&amp;amp;plus;%20b%20%3D%200&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;br /&gt;* Step 2 : Impulse Solution&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Clambda%20%3D%20-m_c%20%28%5Ctextbf%7BJ%7D%20%5Coverline%7B%5Ctextbf%7Bv%7D%7D_2%20&amp;amp;plus;%20b%29&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20m_c%20%3D%20%5Cfrac%7B1%7D%7B%5Ctextbf%7BJ%7D%20%5Ctextbf%7BM%7D%5E%7B-1%7D%20%5Ctextbf%7BJ%7D%5ET%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- scalar m_c는 constraint impulse에 의해 seen되는 effective mass이다.&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20m_c%20%5CDelta%20%5Cdot%7BC%7D%20%3D%20%5Clambda&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;br /&gt;* Step2 : Velocity Update&lt;br /&gt;- lambda에 대해서 풀었으니, 우리는 velocity를 업데이트 하기 위해 그것을 사용할 수 있다.&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Ctextbf%7BP%7D%20%3D%20%5Ctextbf%7BJ%7D%5ET%20%5Clambda&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Ctextbf%7Bv%7D_2%20%3D%20%5Coverline%7B%5Ctextbf%7Bv%7D%7D_2%20&amp;amp;plus;%20%5Ctextbf%7BM%7D%5E%7B-1%7D%20%5Ctextbf%7BP%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;br /&gt;* Step2 : Iteration&lt;br /&gt;- 해결될 때 까지 모든 constraints에 대해 Loop&lt;br /&gt;- 고정된 수의 iterations&lt;br /&gt;- Corrective impulses become small&lt;br /&gt;- Velocity Errors become small&lt;br /&gt;&lt;br /&gt;* Step3 : Integrate Positions&lt;br /&gt;- Use the &lt;b&gt;new&lt;/b&gt; velocity:&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Ctextbf%7Bx%7D_2%20%3D%20%5Ctextbf%7Bx%7D_1%20&amp;amp;plus;%20h%5Ctextbf%7Bv%7D_2&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- 이것은 Symplectic Euler integrator이다.&lt;br /&gt;&lt;br /&gt;* Extensions to Step 2&lt;br /&gt;- Handle position drift&lt;br /&gt;- Handle force limits&lt;br /&gt;- Handle inequality constraints&lt;br /&gt;&lt;br /&gt;* Handling Position Drift&lt;br /&gt;- Velocity constraints는 정확히 obeyed되지 않는다.&lt;br /&gt;- Joints는 떨어질 것이다.&lt;br /&gt;&lt;br /&gt;* Baumgarte Stabilization&lt;br /&gt;- position error를 velocity constraint에 다시 feed&lt;br /&gt;- New velocity constraint&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Cdot%7BC%7D%20%3D%20%5Ctextbf%7BJ%7D%5Ctextbf%7Bv%7D%20&amp;amp;plus;%20%5Cfrac%7B%5Cbeta%7D%7Bh%7DC%20%3D%200&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- Bias factor :&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%200%20%5Cleq%20%5Cbeta%20%5Cleq%201&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- What is the solution to :&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Cdot%7BC%7D%20%3D%20%5Ctextbf%7BJ%7D%5Ctextbf%7Bv%7D%20&amp;amp;plus;%20%5Cfrac%7B%5Cbeta%7D%7Bh%7DC%20%3D%200&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- ??? ODE... First-order differential equation&lt;br /&gt;- Answer&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20C%20%3D%20C_0%20exp%5Cbegin%7Bpmatrix%7D%20-%5Cfrac%7B%5Cbeta%20t%7D%7Bh%7D%20%5Cend%7Bpmatrix%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;br /&gt;* Tuning the Bias Factor&lt;br /&gt;- 만약 너의 시뮬레이션이 불안정성을 가진다면, bias factor를 zero로 설정하고, 안정성을 체크해라.&lt;br /&gt;- simulation이 불안정해질 때 까지 느리게 bias factor를 증가시켜라&lt;br /&gt;- 그 값의 절반을 사용해라.&lt;br /&gt;&lt;br /&gt;* Handling Force Limits&lt;br /&gt;- 처음에 force limits을 impulse limits으로 바꾸어라.&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Clambda_%7Bimpulse%7D%20%3D%20h%20%5Clambda_%7Bforce%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;br /&gt;* Handling Impulse Limits&lt;br /&gt;- corrective impulses를 clamping :&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Clambda%20%3D%20clamp%28%5Clambda%2C%20%5Clambda_%7Bmin%7D%2C%20%5Clambda_%7Bmax%7D%29&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- 그것이 정말 이렇게 간단한가? 아니다.&lt;br /&gt;&lt;br /&gt;* How to Clamp&lt;br /&gt;- Each iteration은 corrective impulses를 연산한다.&lt;br /&gt;- corrective impulses를 Clamping하는 것은 틀린 것이다!&lt;br /&gt;- 너는 time step에 걸쳐 적용된 &lt;b&gt;total impulse&lt;/b&gt;를 clamp해야만 한다.&lt;br /&gt;- 그 다음의 예제는 왜 그런지 보여준다.&lt;br /&gt;&lt;br /&gt;* Example : Inelastic Collision&lt;br /&gt;- A Falling Box&lt;br /&gt;- Global Solution&lt;br /&gt;&lt;br /&gt;* iterative Solution&lt;br /&gt;- Suppose the corrective impulses are too strong.&lt;br /&gt;- What should the second iteration look like?&lt;br /&gt;- To keep the box from bouncing, we need downward corrective impulses.&lt;br /&gt;- In other words, the corrective impulses are negative!&lt;br /&gt;- But clamping the negative corrective impulses wipes them out:&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Clambda%20%3D%20clamp%28%5Clambda%2C%200%2C%20%5Cinfty%29%20%3D%200&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- 이것은 너의 시뮬레이션에 jitter를 도입하는 좋은 방법이다.&lt;br /&gt;&lt;br /&gt;* Accumulated Impulses&lt;br /&gt;- 각 constraint에 대해, 적용된 total impulse를 추적해라.&lt;br /&gt;- 이것이 accumulated impulse이다.&lt;br /&gt;- 그 accumulated impulse를 Clamp해라.&lt;br /&gt;- 이것은 accumulated impulse가 여전히 positive일 때, corrective impulse가 &lt;b&gt;negative(음수)&lt;/b&gt;가 되는 것을 허용한다.&lt;br /&gt;&lt;br /&gt;* New Clamping Procedure&lt;br /&gt;- Step A : Compute the corrective impulse, but don&#39;y apply it.&lt;br /&gt;- Step B : Add the corrective impulse to the accumulated impulse.&lt;br /&gt;- Step C : Clamp the accumulated impulse.&lt;br /&gt;- Step D : Compute the change in the accumulated impulse.&lt;br /&gt;- Step E : Apply the impulse found in Step D.&lt;br /&gt;&lt;br /&gt;* Handling Inequality Constraints&lt;br /&gt;- Before iterations, determine if the inequality constraint is active.&lt;br /&gt;- If it is inactive, then ignore it.&lt;br /&gt;- Clamp accumulated impulses:&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%200%20%5Cleq%20%5Clambda_%7Bacc%7D%20%5Cleq%20%5Cinfty&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;br /&gt;* Inequality Constraints&lt;br /&gt;- A problem : active -&amp;gt; overshoot -&amp;gt; inactive -&amp;gt; gravity -&amp;gt; active&lt;br /&gt;- Jitter is not nice!&lt;br /&gt;&lt;br /&gt;* Preventing Overshoot&lt;br /&gt;- Allot a little bit of penetration (slop).&lt;br /&gt;if separation &amp;lt; slop factor&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Cdot%7BC%7D%20%3D%20%5Ctextbf%7BJ%7D%5Ctextbf%7Bv%7D%20&amp;amp;plus;%20%5Cfrac%7B%5Cbeta%7D%7Bh%7D%28%5Clambda%20-%20%5Clambda_%7Bslop%7D%29&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;else&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Cdot%7BC%7D%20%3D%20%5Ctextbf%7BJ%7D%5Ctextbf%7Bv%7D&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;- Note : the slop factor will be negative (separation).&lt;br /&gt;&lt;br /&gt;* Other Important Topics&lt;br /&gt;- Warm Starting&lt;br /&gt;- Split Impulses&lt;br /&gt;&lt;br /&gt;* Warm Starting&lt;br /&gt;- Iterative solvers use an initial guess for the lambdas.&lt;br /&gt;- So save the lambdas from the previous time step.&lt;br /&gt;- Use the stored lambdas as the initial guess for the new step.&lt;br /&gt;- Benefit : Improved Stacking&lt;br /&gt;&lt;br /&gt;* Step 1.5&lt;br /&gt;- Apply the stored lambdas.&lt;br /&gt;- Use the stored lambdas to initialize the accumulated impulses.&lt;br /&gt;&lt;br /&gt;* Step 2.5&lt;br /&gt;- Store the accumulated impulses&lt;br /&gt;&lt;br /&gt;* Split Impulses&lt;br /&gt;- Baumgarte stabilization affects momentum&lt;br /&gt;- This is bad, bad, bad!&lt;br /&gt;- Unwanted bounces&lt;br /&gt;- Spongy contact&lt;br /&gt;- Jet propulsion&lt;br /&gt;- use different velocity vectors and impulses&lt;br /&gt;Real : &lt;b&gt;v&lt;/b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ƛ&lt;br /&gt;Pseudo : &lt;b&gt;v&lt;/b&gt;_pseudo&amp;nbsp; &amp;nbsp; &amp;nbsp;ƛ_pseudo&lt;br /&gt;- Two parallel solvers&lt;br /&gt;- The real velocity only sees pure velocity constraints&lt;br /&gt;- The pseudo velocity sees position feedback (Baumgarte)&lt;br /&gt;- The Jacobians are the same&lt;br /&gt;&lt;br /&gt;* Pseudo Velocity&lt;br /&gt;- The pseudo velocity is initialized to zero each time step.&lt;br /&gt;- The pseudo accumulated impulses don&#39;t use warm starting (open issue)&lt;br /&gt;&lt;br /&gt;* Step 3 (revised) : Integrate Positions&lt;br /&gt;- Use the &lt;b&gt;combined&lt;/b&gt; velocity :&lt;br /&gt;&lt;img id=&quot;equationview&quot; name=&quot;equationview&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Ctextbf%7Bx%7D_2%20%3D%20%5Ctextbf%7Bx%7D_1%20&amp;amp;plus;%20h%28%5Ctextbf%7Bv%7D_2%20&amp;amp;plus;%20%5Ctextbf%7Bv%7D_%7Bpseudo%7D%29&quot; style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 12px; margin: 10px; text-align: center;&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; /&gt;&lt;br /&gt;&lt;br /&gt;======================================&lt;br /&gt;더 이해해야 할 것들&lt;br /&gt;- Constraint에 대한 이해, 체화&lt;br /&gt;- Inequality Constraint&lt;br /&gt;- How to Compute the Jacobians (Constraint를 만들고 거기에 대한 jacobians을 계산하는 것, 좀 더 예시가 필요하다)&lt;br /&gt;- Handling Position Drift - Baumgarte Stabilization&lt;br /&gt;======================================&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: x-large;&quot;&gt;Contact Manifolds&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;* Executive Summary&lt;br /&gt;- Constraint solvers는 penetration을 방지하기 위해 contact points가 필요하다.&lt;br /&gt;- 우리는 contact manifold를 한 번에 연산하기 위해 SAT를 사용할 수 있다.&lt;br /&gt;- 우리는 point-by-point(점 마다) contact manifold를 구성하기 위해 GJK를 사용할 수 있다.&lt;br /&gt;&lt;br /&gt;* Contact&lt;br /&gt;- Contact는 두 개의 shapes가 닿을 때 발생한다.&lt;br /&gt;- 우리는 penetration을 방지하고 friction을 재현하기 위해 contact를 모델링한다.&lt;br /&gt;- contact를 모델링하는 것은 기하학과 많은 수완을 요구한다.&lt;br /&gt;&lt;br /&gt;* Contact Manifolds&lt;br /&gt;- convex polyhedra에 대해, contact manifold는 이상적으로 a single point, a line segment, or a convex polygon 이다.&lt;br /&gt;- 일반적인 convex 3D shapes에 대해, contact manifold는 convex 2D shape 이다.&lt;br /&gt;- 내가 overlap을 언급했었나?&lt;br /&gt;&lt;br /&gt;* Overlap Happens&lt;br /&gt;- What we want.&lt;br /&gt;- What we get.&lt;br /&gt;&lt;br /&gt;* Approximate Manifolds&lt;br /&gt;- 우리는 contact manifold를 근사하기 위해 contact points의 모음을 사용한다.&lt;br /&gt;- 우리의 목적은 빠르고, 안정되고, 그럴듯한 시뮬레이션이다.&lt;br /&gt;- 이 의미에서, 좋은 manifolds를 연산하는 것은 art이다.&lt;br /&gt;&lt;br /&gt;* Contact Points&lt;br /&gt;- Position&lt;br /&gt;- Normal&lt;br /&gt;- Penetration&lt;br /&gt;- Contact ID&lt;br /&gt;&lt;br /&gt;* Example Manifold&lt;br /&gt;- Two points and a common nomral&lt;br /&gt;&lt;br /&gt;* Contact Manifold Quality&lt;br /&gt;- 오브젝트들이 상당히 크게 관통할 때, 그 contact manifold는 fuzzy(애매)하다.&lt;br /&gt;- Contact solvers는 coherence(일관성)을 좋아한다.&lt;br /&gt;- 단계마다 일관성있게 하자.&lt;br /&gt;&lt;br /&gt;* Exterme Fuzziness&lt;br /&gt;- manifold 1&lt;br /&gt;- manifold 2&lt;br /&gt;&lt;br /&gt;* Using the SAT&lt;br /&gt;- convex polyhedra (boxes, triangles, 등)에 대해 주로 유용하다.&lt;br /&gt;- minimum penetration의 축을 찾아라.&lt;br /&gt;- edge-edge contact에 대해, midpoint를 찾아라.&lt;br /&gt;- face contact에 대해, Sutherland-Hodgeman clipping을 사용해라.&lt;br /&gt;&lt;br /&gt;* Example: 2D Box-Box SAT&lt;br /&gt;- 처음에 minimum penetration을 가진 separating axis를 찾아라.&lt;br /&gt;- 2D 에서, separating axis는 face normal이다.&lt;br /&gt;&lt;br /&gt;* Box-Box Clipping Setup&lt;br /&gt;- reference face를 확인하고&lt;br /&gt;- incident face를 확인해라.&lt;br /&gt;&lt;br /&gt;* Box-Box Clipping&lt;br /&gt;- reference face의 side planes에 대해 (reference face가 아닌) incident face를 clip해라&lt;br /&gt;- 양수의(positive) penetration를 가진 clip points를 고려해라.&lt;br /&gt;&lt;br /&gt;* Feature Flip-Flop&lt;br /&gt;- 어떤 normal이 min separating axis인가?&lt;br /&gt;- 다른 것에 대해 한 축을 선호하는 가중치를 적용해라&lt;br /&gt;- 개선된 일관성을 준다.&lt;br /&gt;&lt;br /&gt;* Coherence&lt;br /&gt;- 그 step의 초기에 old force/impulse solution을 적용해라.&lt;br /&gt;- 더 적은 반복으로 더 훌륭한 안정성을 준다.&lt;br /&gt;- 우리는 old and new contact를 매치할 방법이 필요하다.&lt;br /&gt;&lt;br /&gt;* Feature-Based Contact Points&lt;br /&gt;- 각 contact point는 clipping의 결과이다.&lt;br /&gt;- 그것은 두 개의 다른 edges의 결합이다.&lt;br /&gt;- 한 edge는 둘 중 하나의 box로부터 올지도 모른다.&lt;br /&gt;- 그 두 개의 edge numbers를 각 contact point와 저장해라 - 이것이 contact ID이다.&lt;br /&gt;&lt;br /&gt;* Contact Point IDs&lt;br /&gt;&lt;br /&gt;* GJK Contact Points&lt;br /&gt;- 세 가지 경우 :&lt;br /&gt;&amp;nbsp; &amp;nbsp;No Contact&lt;br /&gt;&amp;nbsp; &amp;nbsp;Shallow Contact&lt;br /&gt;&amp;nbsp; &amp;nbsp;Deep Contact&lt;br /&gt;&lt;br /&gt;* GJK Shallow Contact&lt;br /&gt;- support points는 contact를 탐지하기 위해 작은 margin으로 scaled up된다.&lt;br /&gt;- 가장 가까운 점을 연산해라 (no margin).&lt;br /&gt;- 이것은 position과 normal를 준다.&lt;br /&gt;- penetration은 margin - 실제 거리 이다.&lt;br /&gt;&lt;br /&gt;* GJK Contact Margins&lt;br /&gt;* GJK Contact Point&lt;br /&gt;* GJK Deep Contact&lt;br /&gt;- 어떤 다른 알고리즘을 사용해라&lt;br /&gt;- 그것은 GJK보다 더 느릴 것이지만, 그것은 오래 지속되지 않을 것이다.&lt;br /&gt;- SAT, EPA, brute force.&lt;br /&gt;- EPA를 배우기 위해 Gino의 북을 읽어라.&lt;br /&gt;&lt;br /&gt;* GJK&amp;nbsp; Manifolds&lt;br /&gt;- GJK는 한 번에 한 개의 contact point만을 준다.&lt;br /&gt;- 우리는 각 contact point를 유지하고 귀중히 여긴다.&lt;br /&gt;- 몇 가지 time steps에 걸쳐 한 manifold를 구성해라.&lt;br /&gt;- 이것은 자동적으로 coherence를 제공한다.&lt;br /&gt;&lt;br /&gt;* Building the Manifold&lt;br /&gt;* Manifold Persistence&lt;br /&gt;- 각 body에 있는 points를 추적&lt;br /&gt;- 만약 그 points가 너무 멀리 떨어져 움직인다면, 그것들을 해제&lt;br /&gt;- 이것은 sliding에 나쁘다.&lt;br /&gt;- Contact ID들을 사용?&lt;br /&gt;&lt;br /&gt;* Adding New Points&lt;br /&gt;- manifold마다 점들의 한 최소 집합을 유지 (예를들어, 4 개의 points)&lt;br /&gt;- 오래된 점들과 가장 가까운 새로운 점들은 Reject&lt;br /&gt;&lt;br /&gt;* Manifold Reduction&lt;br /&gt;- 이것은 one-shot과 incremental manifolds에 적용된다.&lt;br /&gt;- 우리는 안정된 재현을 위해 최소한의 수의 contact points를 유지하길 원한다.&lt;br /&gt;- 이것은 성능을 급격히 개선한다.</content><link rel='replies' type='application/atom+xml' href='http://chanhaeng.blogspot.com/feeds/7493136171956226004/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://chanhaeng.blogspot.com/2019/03/gdc2007-erin-catto.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/3538290929769251376/posts/default/7493136171956226004'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/3538290929769251376/posts/default/7493136171956226004'/><link rel='alternate' type='text/html' href='http://chanhaeng.blogspot.com/2019/03/gdc2007-erin-catto.html' title='GDC2007 Erin Catto 발표'/><author><name>chan</name><uri>http://www.blogger.com/profile/14387528357950501854</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3538290929769251376.post-1909293207675743305</id><published>2019-02-28T09:30:00.002-08:00</published><updated>2019-02-28T09:32:09.270-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="[Programming] GamePhysics"/><title type='text'>Physics 공부 계획 다시</title><content type='html'>지금 취업 준비를 하고 있지만,&lt;br /&gt;&lt;div&gt;나는 헤매다가 이제 Physics의 세계에 발을 담구었다고 생각한다.&lt;/div&gt;&lt;div&gt;그래서, 취업 준비를 하면서도 이 Physics를 공부할 생각이다. 하지만 이전처럼&lt;/div&gt;&lt;div&gt;빡세게는 하지 않고, 올바른 길을 따라서 방향을 바로잡고 천천히 할 생각이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;일단 큰 줄기는&lt;/div&gt;&lt;div&gt;Box2D-lite -&amp;gt; Box2D -&amp;gt; 나의 3D Physics Engine.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;현재 Box2D-lite의 내용은 대부분 이해하고 구현했다.&lt;/div&gt;&lt;div&gt;이제 문제는 Box2D인데, 이 Box2D를 상당히 잘 이해하고 구현해야,&lt;/div&gt;&lt;div&gt;올바른 3D Physics로 넘어갈 수 있는 발판을 마련하게 된다. 그리고,&lt;/div&gt;&lt;div&gt;Box2D를 상당히 잘 이해해야, 여기에서 더 진보된 Physics도 내가 나중에&lt;/div&gt;&lt;div&gt;논문이나&amp;nbsp; 최신 자료들을 보면서 구현할 수 있게 된다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;그래서 기본 Physics Engine을 구현하게 되면, 이제 Inverse Kinematics도 공부할 준비가 되었을 것이다. 그래서 더 큰 줄기는&lt;/div&gt;&lt;div&gt;2D Physics -&amp;gt; 3D Physics -&amp;gt; Inverse Kinematics -&amp;gt; Animation 가 될 것이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;그렇다면 가장 큰 줄기들을 잘 따라가게 할, Box2D를 이해하는게 중요하기 때문에,&lt;/div&gt;&lt;div&gt;나는 여기에서 Box2D를 어떻게 공부할지에 대한 내용을 열거할 것이다.&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;Game Programming Gems 2006 Erin Catto - Buoyancy in 3D&amp;nbsp;&lt;/li&gt;&lt;li&gt;GDC 2006 Erin Catto - Fast and Simple Physics using Sequential Impulses (이건 이미 했지만, 기본이 되는 것이므로 반복하자) - &lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;DEMO&lt;/span&gt;&lt;/b&gt;&lt;/li&gt;&lt;li&gt;GDC 2007 Erin Catto - Physics 1 Modeling and Solving Constraints&lt;/li&gt;&lt;ul&gt;&lt;li&gt;Constraint Formulas&lt;/li&gt;&lt;li&gt;Deriving Constraints (Joints, Motors, Contact)&lt;/li&gt;&lt;li&gt;Building a Constraint solver&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;GDC 2007 Erin Catto - Physics 2&lt;/li&gt;&lt;ul&gt;&lt;li&gt;Constraint solver&lt;/li&gt;&lt;li&gt;SAT&lt;/li&gt;&lt;li&gt;GJK&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;GDC 2008 Erin Catto - Physics Tutorial Modeling and Solving Constraints&lt;/li&gt;&lt;ul&gt;&lt;li&gt;Jacobians, Lagrange Multipliers&lt;/li&gt;&lt;li&gt;Joints, Motors, Contact&lt;/li&gt;&lt;li&gt;Sequential Impulses&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;GDC 2009 Erin Catto - Numerical Integration&lt;/li&gt;&lt;ul&gt;&lt;li&gt;Differential Equations&lt;/li&gt;&lt;li&gt;Numerical Integrations&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;GDC 2009 Erin Catto - Modeling and Solving Constraints -&amp;nbsp;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;DEMO&lt;/span&gt;&lt;/b&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;Jacobians, Lagrange Multipliers&lt;/li&gt;&lt;li&gt;Joints, Motors, Contact&lt;/li&gt;&lt;li&gt;Sequential Impulses&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;GDC 2010 Erin Catto - Computing Distance (using GJK) - &lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;DEMO&lt;/span&gt;&lt;/b&gt;&lt;/li&gt;&lt;li&gt;GDC 2012 Erin Catto - Diablo 3 Ragdolls&lt;/li&gt;&lt;li&gt;GDC 2013 Richard Togne - Iterative Rigid Body Solvers&lt;/li&gt;&lt;li&gt;GDC 2013 Erin Catto - Continuous Collision&amp;nbsp;&lt;/li&gt;&lt;li&gt;GDC 2013 Dirk Gregorius - The Separating Axis Test between Convex Polyhedra - &lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;DEMO&lt;/span&gt;&lt;/b&gt;&lt;/li&gt;&lt;li&gt;GDC 2013 Gino van den Bergen - Spatial Data Structures (AABB Tree)&lt;/li&gt;&lt;li&gt;GDC 2014 Erin Catto - Understanding Constraints&lt;/li&gt;&lt;li&gt;GDC 2014 Dirk Gregorius - Implementing Quickhull&lt;/li&gt;&lt;li&gt;GDC 2015 Dirk Gregorius - Robust Contact Creation for Physics Simulations&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div&gt;일단 GDC에서 발효된 자료들을 모두 읽고 공부할 것이다. 이 내용들은 모두 Box2D에 들어가있는 내용이기 때문에, 이 내용들을 모두 공부하고, 알고 이해하고 있어야 한다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;이 년도의 순서를 따라갈 필요는 없다. 어쨋든 결국에는 다들 같은 말을하고 있기 때문에, 모든 자료들을 반복해서 봐야할 것이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;일단은 내 생각에 LCP를 좀 이해하는 것이 먼저일 것 같다. 왜냐하면 그게 기반으로 좀 더 contact를 정확하게 처리하고, 그리고 contact를 어떻게 관리하는지, 그리고 충돌 탐지를 어떻게 하는지가 더해지기 때문이다. 그리고나서 더 어려운 고급 충돌탐지(GJK, Gauss Map of convex polyhedra), Physics Object 관련하여 Hull 형성 등 여러가지가 추가된다. 그러고나서 Ragdoll, Destructible Object 등 application에 대해서 편하게 공부할 것이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;그렇다면 내가 할 것은&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;LCP solver -&amp;gt; 고급 충돌탐지 (GJK, Gauss Map) -&amp;gt; QuickHull -&amp;gt; 여러가지 충돌 탐지를 위한 오브젝트 및 탐지 알고리즘 형성 -&amp;gt; Continuous Collision (+ Swept Collision) -&amp;gt; Destructible Object -&amp;gt; Inverse Kinematics -&amp;gt; Ragdolls&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;뭐 이 순서는 내가 아직 어떻게 공부해야 할지 모르니, 당연히 바뀔 것이지만, 일단 이렇게 시작해보자. 따라서 결론적으로 정리해보자면,&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: x-large;&quot;&gt;매우 크게&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;2D Physics -&amp;gt;&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;I&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;nverse Kinematics + Ragdoll -&amp;gt;&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Animation&amp;nbsp;-&amp;gt;&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;3D Physics로 전체 구현&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: x-large;&quot;&gt;크게(좀 더 구체적)&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Box2D-lite -&amp;gt; Box2D -&amp;gt; 나의 3D Physics Engine.&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: x-large;&quot;&gt;작게(완전 구체적)&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;LCP solver -&amp;gt;&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;고급 충돌탐지 (GJK, Gauss Map) -&amp;gt;&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;QuickHull -&amp;gt;&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;여러 충돌 탐지를 위한 오브젝트 형성 및 탐지 알고리즘 -&amp;gt;&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Continuous Collision (+ Swept Collision) -&amp;gt;&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Destructible Object -&amp;gt;&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Inverse Kinematics -&amp;gt;&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Ragdolls -&amp;gt;&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;모두 3D로 전환&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://chanhaeng.blogspot.com/feeds/1909293207675743305/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://chanhaeng.blogspot.com/2019/02/physics.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/3538290929769251376/posts/default/1909293207675743305'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/3538290929769251376/posts/default/1909293207675743305'/><link rel='alternate' type='text/html' href='http://chanhaeng.blogspot.com/2019/02/physics.html' title='Physics 공부 계획 다시'/><author><name>chan</name><uri>http://www.blogger.com/profile/14387528357950501854</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3538290929769251376.post-2617424359557007749</id><published>2019-02-25T00:30:00.001-08:00</published><updated>2019-02-28T01:38:51.570-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="[Programming] Operating Systems"/><title type='text'>OS Chapter 5 : Process Synchronization</title><content type='html'>critical-section problem을 소개. 그것의 솔루션은 공유 데이터의 일관성을 보장하기 위해 사용될 수 있다.&lt;br /&gt;critical-section 문제에 대해 소프트웨어와 하드웨어 솔루션 둘 다 보여준다.&lt;br /&gt;몇 가지 고전적 프로세스 동기화 문제를 조사.&lt;br /&gt;프로세스 동기화 문제를 해결하기 위해 사용되는 몇 가지 툴을 조사.&lt;br /&gt;&lt;br /&gt;* Background&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;이 챕터에서, 우리는 concurrent or parallel execution이 여러 프로세스들에 의해 공유되는 data의 integrity를 포함한 문제들에 어떻게 기여할 수 있는지를 설명한다.&lt;/li&gt;&lt;li&gt;bounded buffer에 count 변수를 추가하여, 생산자와 소비자가 올리거나 줄인다고 했을 때 해결되는 것 처럼 보이지만, concurrently하게 실행될 때 정확히 실행되지 않을지도 모른다.&lt;/li&gt;&lt;li&gt;counter++와 counter--의 low level statements에서 살펴보면 lower-level 명령어들은 어떤 순서로 중간에 끼여들게 되는데, 그러한 끼어들기가 다음과 같다:&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;T0 : producer execute register1 = counter {register1 = 5}&lt;/div&gt;&lt;div&gt;T1 : producer execute register1 = register1 + 1 {register1 = 6}&lt;/div&gt;&lt;div&gt;T2 : consumer execute register2 = counter {register2 = 5}&lt;/div&gt;&lt;div&gt;T3 : consumer execute register2 = register2 - 1 {register2 = 4}&lt;/div&gt;&lt;div&gt;T4 : producer execute counter = register1 {counter = 6}&lt;/div&gt;&lt;div&gt;T5 : consumer execute counter = register2 {counter = 4}&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;우리는 두 프로세스들이 변수 counter를 concurrently하게 조작하는 것을 허용했기 때문에 부정확한 상태에 도달할 것이다. 몇 가지 프로세스들이 같은 데이터에 concurrently하게 접근하고 그 실행의 결과가 프로세스가 접근하는 특정 순선에 의존하는 이러한 상황은 &lt;b&gt;race condition&lt;/b&gt;이라고 불려진다. 위의 race condition으로부터 보호하기 위해서, 우리는 한 번에 오직 한 프로세스만이 그 변수 counter를 조작할 수 있도록 보장할 필요가 있다. 그러한 보장을 하기 위해서, 우리는 그 프로세스들이 어떤 방식으로 synchronized 되는 것을 요구한다.&lt;/li&gt;&lt;li&gt;설명된 것과 같은 상황들은 운영체제에서 자주 발생하는데, 그 시스템의 다른 부분들이 자원을 조작하기 때문이다. 명확히 우리는 그러한 활동으로부터 발생하는 어떤 변화들이 서로를 간섭하지 않기를 원한다. 이 문제의 중요성 때문에, 우리는 이 챕터의 대부분을 cooperating processes사이의 &lt;b&gt;process synchronization(프로세스 동기화)&lt;/b&gt;과 &lt;b&gt;coordination(조정)&lt;/b&gt;에 헌신한다.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;* The Critical-Section Problem&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;소위 critical-section problem을 이야기해서 프로세스 동기화를 고려하기 시작한다. n개의 프로세스들 {P0, ..., P(n-1)}로 구성된 시스템을 고려하자. 각 프로세스는 critical section이라고 불려지는 코드의 한 segment를 가지고 있는데, 거기에서 그 프로세스는 공통된 변수를 바꾸고,&amp;nbsp; 한 테이블을 업데이트하고, 한 파일을 쓰거나 등등을 할 지도 모른다. 그 시스템의 중요한 기능은, 한 프로세스가 critical section에서 실행될 때, 어떠한 다른 프로세스도 그것의 critical section에서 실행되지 않도록 하는 것이다. 즉, 어떠한 두 개의 프로세스들은 그들의 critical sections에서 동시에 실행될 수 없다. 그 &lt;b&gt;critical-section problem&lt;/b&gt;은 그 프로세스들이 협력하기 위해 사용할 수 있는 protocol을 설계하는 것이다. 각 프로세스는 그것의 critical section에 들어가기위해 허가를 요청해야 한다. 이 요청을 구현하는 코드의 section이 &lt;b&gt;entry section&lt;/b&gt;이다. 그 critical section 다음에 &lt;b&gt;exit section&lt;/b&gt;이 나올지도 모른다. 나머지 코드는 &lt;b&gt;remainder section&lt;/b&gt;이다.&lt;/li&gt;&lt;li&gt;critical-section problem에 대한 솔루션은 다음의 세 가지 요구사항을 만족해야만 한다:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;1.&amp;nbsp; Mutual exclusion (상호배제)&lt;/b&gt; : 만약 process Pi가 그것의 critical section에서 실행하고 있다면, 그러면 어떠한 프로세스들이 그들의 critical sections에서 실행할 수 없다.&lt;/li&gt;&lt;li&gt;&lt;b&gt;2. Progress (진행)&lt;/b&gt; : 만약 그것의 critical section에서 어떠한 프로세스도 실행되고 있지 않고, 어떤 프로셋드ㅡㄹ이 그들의 critical sections에 들어가길 원한다면, 그것들의 remainder sections에 실행되고 있지 않은 프로세스들만 그것의 critical section에 다음에 들어갈지를 결정하는데 참여할 수 있고, 이 선택은 무기한적으로 연장될 수 없다.&lt;/li&gt;&lt;li&gt;&lt;b&gt;3. Bounded waiting (한정된 대기)&lt;/b&gt; : 한 프로세스가 그것의 critical section을 들어가는 요청을 하고난 후와 그 요청이 받아들여지기 전에 다른 프로세스들이 critical sections에 들어가도록 허용되는 횟수에 제한이 존재한다.&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;주어진 한 시점에서, 많은 kernel-mode 프로세스들은 운영체제에서 활성화되어 있을지도 모른다. 결과적으로, 한 운영체제 (kernel code)를 구현하는 코드는 몇 가지 가능한 race conditions에 종속된다. 한 예로서 시스템에서 모든 open files의 목록을 유지하는 kernel 자료 구조를 고려해라. 이 리스트는 한 새로운 파일이 열리거나 닫혀졌을 때 (그 파일을 리스트에 더하거나, 그 리스트에서 그것을 제거하거나), 수정되어야만 한다. 만약 두 프로세스들이 동시에 파일을 열었다면, 이 리스트에대한 별개의 업데이트들은 race conditions을 발생시킬 수 있다. race conditions 발생하기 쉬운 다른 kernel data structures는 메모리 할당을 유지하기 위한 구조, 프로세스 리스트들을 유지하기위한 구조, interrupt handling을 위한 자료구조를 포함한다. 그 운영체제가 그러한 race conditions에 자유롭도록 보장하는 것은 kernel 개발자에게 달려있다.&lt;/li&gt;&lt;li&gt;두 개의 일반적인 접근법이 운영체제에서 critical sections을 다루기 위해 사용된다: &lt;b&gt;preemptive kernels&lt;/b&gt;와 &lt;b&gt;nonpreemptive kernels&lt;/b&gt;. preemptive kerenl은 한 프로세스가 그것이 kernel mode에서 작동하고 있는 동안에 preempted(선점)되는 것을 허용한다. 한 nonpreemptive kernel은 kernel mode에서 작동하고 있는 한 프로세스가 선점되는 것을 허용하지 않는다; 한 kernel-mode process는 그것이 kernel mode, blocks을 종료하거나 자의적으로 CPU control을 포기할 때 까지 작동할 것이다. 명백히 nonpreemptive kernel은 커널 자료구조에서 race conditions으로부터 본질적으로 자유롭다, 왜냐하면 오직 한 프로세스만이 한 번에 kernel에서 활성화 되기 때문이다. 우리는 preemptive kerenels에서 똑같이 말할 수 없다. 그래서 그것들은 shared kerenel data가 race conditions로부터 자유롭도록 보장하기위해 조심스럽게 설계되어야 한다. Preemptive kerenls은 특히 SMP architectures에 대해 설계하기에 어려운데, 이러한 환경에서, 두 개의 kernel-mode processes들이 다른 프로세서들에서 동시에 작동하는 것이 가능하기 때문이다.&lt;/li&gt;&lt;li&gt;왜 어떤 사람은 nonpreemptive kernel보다 preemptive kernel를 선호하는 것일까? preemptive kernel은 좀 더 responsive하다. 왜냐하면 한 kernel-mode process가 그 processor를 waiting processes를 포기하기 전에 임의로 긴 시간동안 작동할 위험이 더 적기 때문이다. (물론, 이 위험은 이 방식으로 행동하지 않는 커널 코드를 설계하여 최소화될 수 있다.) 게다가, preemptive kernel은 real-time programming에 더 적절한데, 그것이 real-time process가 kernel에 현재 작동하는 한 프로세스를 선점하게 허용할 것이기 때문이다.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;* Peterson&#39;s Solution&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;다음으로 우리는 Peterson&#39;s solution이라고 알려진 critical-section problem의 고전적인 software 기반의 솔루션을 설명한다. 현대 컴퓨터가 load와 store같은 기본 기계어 명령어를 수행하는 방식 때문에, Peterson&#39;s solution이 그러한 아키텍쳐에서 정확히 작동할 보장은 없다. 그러나, 그것이 critical-section problem에 대한 좋은 알고리즘적인 설명을 제공하고, 상호배제, 진행, 한정된 대기의 요구사항을 다루는 소프트웨어를 설계할 때 관련된 복잡성을 보여주기 때문에 우리는 이 솔루션을 보여준다.&lt;/li&gt;&lt;li&gt;Peterson의 solution은 critical sections과 remainder sections사이에서 실행을 번갈아 하는 두 개의 프로세스들에 제한된다. 그 프로세스들은 P0과 P1으로 번호를 받는다. 편의성을 위해 Pi를 나타낼 떄, 우리는 Pj를 다른 프로세스로 표기한다.; 즉, j는 1 - i와 같다. Peterson의 solution은 두 개의 프로세스들이 두 개의 data items을 공유하는 것을 요구한다 :&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;int turn;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;boolean flag[2];&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;그 변수 turn는 그것이 critical section에 들어갈 turn을 가리킨다. 즉, turn == i이라면, process pi는 그것의 critical section에서 실행되는 것을 허용한다. flag array는 한 프로세스가 그것의 critical section에 들어갈 준비가 되어있는지를 가리키는데 사용된다.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;do&lt;/div&gt;&lt;/div&gt;&lt;div&gt;{&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; flag[i] = true;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; turn = j;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; while (flag[j] &amp;amp;&amp;amp; turn == j);&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; critical section&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; flag[i] = false;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; remainder section&lt;/div&gt;&lt;div&gt;}while(true);&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;critical section에 들어가기 위해, process Pi는 처음에 flag[i]를 true로 설정하고, turn을 j값으로 설정한다. 그것으로 인해, 만약 다른 프로세스가 critical section에 들어가길 원한다면 그것이 그렇게 할 수 있게 한다. 만약 두 프로세스가 동시에 들어가려고 한다면, turn은 대강 동시에 i와 j로 설정될 것이다. 이러한 할당들 중 하나만이 남을 것이다. 다른 것은 발생할 것이지만, 즉시 덮여 씌워질 것이다. turn의 최종 값은 그 두 개의 프로세스들 중 어떤 것이 그것의 critical section에 처음 들어갈 지를 결정한다.&amp;nbsp;&lt;/li&gt;&lt;li&gt;우리는 이제 이 솔루션이 옳다는 것을 증명한다. 우리는 다음을 보여줄 필요가 있다:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;1. Mutual exclusion이 보존된다.&lt;/li&gt;&lt;li&gt;2. progress requirement가 만족된다.&lt;/li&gt;&lt;li&gt;3. bounded-waiting requirement가 충족된다.&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;특성 1을 증명하기 위해, 각 Pi가 그것의 critical section을 flag[j] == false or turn == i여야 들어갈 수 있다는 것을 주목한다. 또한 만약 두 프로세스가 그것들의 critical sections에서 동시에 실행한다면, 그러면 flag[0] == flag[1] == true이다. 이러한 두 개의 관찰은 P0과 P1이 성공적으로 동시에 while statements를 실행할 수 없다는 것을 암시한다. turn의 값이 0 또는 1 둘 중 하나일 것이기 때문이다. 그러므로 그 프로세스들 중 하나는 성공적으로 while 문을 실행했을 것이지만, 반면에 다른 것은 적어도 한 부가적 명령어를 실행시켰어야 한다 (&quot;turn == j&quot;). ~~&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;* Synchronization Hardware&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;Peterson의 것과 같은 software-based solutions은 현대 컴퓨터 아키텍쳐에서 작동하는 것이 보장되지 않는다. 다음의 이야기에서, 우리는 critical-section problem에 대한 좀 더 많은 몇 가지 솔루션들을 볼건데, 커널 개발자와 어플리케이션 프로그래머 둘 다에게 이용가능한 하드웨어에서 부터 소프트웨어 기반 API까지 범위를 가진 기법들을 사용할 것이다. 모든 이러한 솔루션들은 &lt;b&gt;locking&lt;/b&gt;의 전제에 기반을 둔다 - 즉, locks을 사용해서 critical sections을 보호하는 것이다. 우리가 보게 되듯이, 그러한 locks의 설계는 꽤 정교해질 수 있다.&lt;/li&gt;&lt;li&gt;많은 시스템에서 이용가능한 어떤 간단한 하드웨어 명령어들은 보여주고, 그것들이 어떻게 그 critical-section problem을 해결하는데 효과적으로 사용될 수 있는지를 보여주어 시작한다. 하드웨어 기능들은 어떤 프로그래밍 task를 더 쉽게 만들 수 있고, 시스템 효율성을 개선할 수 있다.&lt;/li&gt;&lt;li&gt;critical-section problem은 single-processor 환경에서 쉽게 해결될 수 있는데, 만약 우리가 인터럽드들이 shared variable이 수정되는 동안 발생하지 않도록 방지한다면. 이 방식으로, 우리는 명령어의 현재 sequence가 선점없이 순서대로 실행되도록 허용될 수 있는 것을 확신할 수 있다. 어떠한 다른 명령어도 실행되지 않을 것이고, 그래서 어떠한 예상치 못한 수정이 shared variable에 만들어지지 않을 것이다. 이것은 종종 nonpreemptive kernels에 의해 취해지는 접근법이다. 불행하게도, 이 솔루션은 multiprocessor 환경에서 그럴듯 하지 않다. multiprocessor에서 interrupts를 비활성화하는 것은 시간을 소모적일 수 있다. 왜냐하면 그 메세지가 모든 프로세서에게 전달되기 때문이다. 이 전달되는 메세지는 각 critical section으로의 입장을 지연시키고, 시스템 효율성을 줄인다.&lt;/li&gt;&lt;li&gt;많은 현대 컴퓨터 시스템들은 그러므로 우리가 한 word의 내용을 테스트하고 수정할지 또는 두 개의 words의 내용을 &lt;b&gt;atomically&lt;/b&gt;하게 swap할지 둘 중 하나를 하도록 특별한 하드웨어 명령어를 제공한다 - atomically는, 즉, 하나의 interrupt불가능한 단위이다. 우리는 이러한 특별한 명령어를 상대적으로 간단한 방식으로 critical-section 문제를 해결하기 위해 사용할 수 있다. 한 특정한 기계에 대해 한 가지 특정한 명령어를 이야기하기 보다, 우리는 test_and_set()과 compare_and_swap() 명령어를 설명하여 이러한 유형의 명령어 뒤에 있는 주된 개념들을 추상화한다.&lt;/li&gt;&lt;li&gt;test_and_set() 명령어는 그림 5.3에서 보이듯이 정의될 수 있다.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;boolean test_and_set(boolean* target)&lt;/div&gt;&lt;/div&gt;&lt;div&gt;{&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;boolean rv = *target;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;*target = true;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;return rv;&lt;/div&gt;&lt;div&gt;}&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;이 명령어의 중요한 특징은 그것이 atomically하게 실행되는 것이다. 따라서, 만약 두 개의 test_and-set() 명령어가 동시에 실행된다면 (다른 CPU에서 각각), 그것들은 어떤 임의의 순서로 순차적으로 실행될 것이다. 만약 그 기계가 test_and_set() 명령어를 지원한다면, 우리는 false로 초기화된 boolean 변수 lock을 선언하여 mutual exclusion을 구현할 수 있다. 프로세스 Pi의 구조는 그림 5.4에 보여진다.&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div&gt;do&lt;/div&gt;&lt;div&gt;{&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;while(test_and_set(&amp;amp;lock))&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ; /* do nothing */&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;/* critical section */&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;lock = false;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;/* remainder section */&lt;/div&gt;&lt;div&gt;} while (true);&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;compare_and_swap() 명령어는 test_and_set()과 대조적으로, 세 개의 operands에 작동한다; 그것은 그림 5.5에 정의된다.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;int compare_and_swap(int* value, int expected, int new_value)&lt;/div&gt;&lt;/div&gt;&lt;div&gt;{&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; int temp = *value;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; if(*value == expected)&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; *value = new_value;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; return temp;&lt;/div&gt;&lt;div&gt;}&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;value operand는 만약 그 표현 (*value == expected)가 true라면 new_value로 설정된다. 상관없이, compare_and_swap()은 항상 value 변수의 원래 값을 반환한다. test_and_set() 명령어 처럼, compare()_and_swap()은 atomically하게 실행된다. Mutual exclusion은 다음과 같이 제공될 수 있다: global variable (lock)은 선언되고 0으로 초기화된다. compare_and_swap()을 불러오는 첫 번째 프로세스는 lock을 1로 설정할 것 이다. 그것은 그러고나서 그것의 critical section에 들어갈 것인데, ock의 원래 값이 0의 expected value와 같기 때문이다. comapre_and_swa()에 대한 나중의 호출들은 성공하지 못할 것인데, lock이 이제 0의 예상된 값과 다르기 때문이다. 한 프로세스가 그것의 critical section을 끝낼 때, 그것은 lock을 0으로 다시 설정하고, 이것은 또 다른 프로세스가 그것의 critical section에 들어가도록 허용한다.&amp;nbsp;&lt;/li&gt;&lt;li&gt;비록 이러한 알고리즘들이 상호배제 요구사항을 만족시킬지라도, 그것들은 bounded-waiting 요구사항을 만조깃키지 않는다. 그림 5.7에서, 우리는 test_and_set() 명령어를 사용하여 모든 critical-section 요구사항을 만족시키는 또 다른 알고리즘을 보여준다. 그 공통 자료구조는&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;boolean waiting[n];&lt;/div&gt;&lt;/div&gt;&lt;div&gt;boolean lock;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;do&lt;/div&gt;&lt;div&gt;{&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; waiting[i] = true;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; key = true;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; while (waiting[i] &amp;amp;&amp;amp; key)&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; key = test_and_set(&amp;amp;lock);&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; waiting[i] = false;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; /* critical section */&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; j = (i + 1) % n;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; while( (j != i) &amp;amp;&amp;amp; !waiting[j])&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; j = (j + 1) % n;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; if(j == i) lock = false;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; else waiting[j] = false;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; /* remainder section */&lt;/div&gt;&lt;div&gt;} while (true);&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;이러한 자료구조는 false로 초기화된다. 상호 배제 요구사항이 충족되는 것을 증명하기 위해, 우리는 process Pi가 그것의 critical section을 오직 waiting[i] == false or key == false 둘 중 하나인 경우에만 들어갈 수 있다. key의 값은 test_and_set()이 실행되기만 한다면 false가 될 수 있다. test_and_set()을 실행하는 그 첫 번째 프로세스는 key == false인 거를 알게 될 것이다; 모든 다른 것들이 기다려야 한다. 변수 waiting[i]는 만약 또 다른 프로세스가 그것의 critical section을 떠나다면 false가 될 수 있다; 즉, 한 waiting[i]이 false로 설정되고, 상호 배제 요구사항이 유지된다.&lt;/li&gt;&lt;li&gt;progress requirement가 충족되는 것을 증명하기 위해, 우리는 상호 배제를 위해 보여진 인자들이 또한 여기에 적용되는 것을 주목한다. critical section을 종료하는 한 프로세스가 lock을 false하거나 또는 waiting[j]를 false 로 둘 중 하나를 설정한다. 둘 다 critical section을 들어가기를 기다리는 한 프로세스가 진행되도록 한다.&lt;/li&gt;&lt;li&gt;bounded-waiting requirement가 충족되는지 증명하기 위해, 한 프로세스가 그것의 critical section을 떠날 때, 그것은 cyclic ordering으로 waiting 배열을 스캔한다. 그것은 이 순서소로 entry section에 있는 (wainting[h] == true)인 첫 번째 프로세스를 critical section에 들어갈 다음 것으로 지정한다. 그것의 critical section에 들어갈 기다리는 어떤 프로세스는 따라서 n - 1 turns안에 그렇게 할 것이다.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;* Mutex Locks&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;Section 5.4에서 보여진 critical-section problem에 대한 하드웨어 기반 솔루션들은 복잡할 뿐만 아니라 일반적으로 어플리케이션 프로그래머들에게 접근가능하지 않다. 대신에, 운영체제 설계자들은 critical-section problem을 해결할 소프트웨어 도구를 만든다. 이러한 도구들 중 가장 간단한 것은 &lt;b&gt;mutex lock&lt;/b&gt;이다. (사실, &lt;b&gt;mutex&lt;/b&gt;라는 용어는 &lt;b&gt;mut&lt;/b&gt;ual &lt;b&gt;ex&lt;/b&gt;clusion을 줄인 것이다.) 우리는 critical regions을 보호하고 따라서 race conditions을 방지하기 위해 mutex lock을 사용한다. 즉, 한 프로세스는 critical section에 들어가기 전에 그 locm을 얻어야만 한다; 그것은 그것이 critical section을 종료할 때 lock을 해제한다. acquire() 함수는 그 lock을 얻고, release() 함수는 그 lock을 해제한다.&amp;nbsp;&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;acquire()&lt;/div&gt;&lt;/div&gt;&lt;div&gt;{&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; while(!available)&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ; /* busy wait */&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; available = false;&lt;/div&gt;&lt;div&gt;}&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;release()&lt;/div&gt;&lt;div&gt;{&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; available = true;&lt;/div&gt;&lt;div&gt;}&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;do&lt;/div&gt;&lt;div&gt;{&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; acquire lock&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; critical section&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; release lock&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; remainder section&lt;/div&gt;&lt;div&gt;} while (true);&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;mutex lock은 value가 그 lock이 이용가능한지 안한지를 가리키는 boolean 변수 available를 가진다. 만약 그 lock이 이용가능하다면, acquire()에 대한 호출은 성공하고, 그 lock은 그러고나서 unavailable하다고 고려된다. unavailable lock을 얻으려고 하는 한 프로세스는 그 lock이 해제될 때 까지 봉쇄(blocked)된다. acquire() 또는 release()에 대하 호출 둘 중 하나는 atomically 하게 수행되어야 한다. 따라서, mutex locks은 종종 섹션 5.4에 설명된 하드웨어 메커니즘 들 중 하나를 사용하여 구현된다.&lt;/li&gt;&lt;li&gt;여기에서 주어진 구현의 주된 단점은 그것이 &lt;b&gt;busy waiting&lt;/b&gt;을 요구한다는 것이다. 한 프로세스가 그것의 critical section에 있는 반면에, 그것의 critical section에 들어갈려고 하는 어떤 다른 프로세스는 acquire()에 대한 호출에서 지속적으로 loop를 해야한다. 사실, 이러한 mutex lock의 종류는 &lt;b&gt;spinlock&lt;/b&gt;이라고 불려지는데, 그 프로세스가 그 lock이 이용가능해지기를 기다리면서 &quot;spins&quot;하기 때문이다. 이 지속적인 looping은 한 single CPU가 많은 프로세스들 사이에서 공유되는 real multiprogramming system에서 명백히 한 문제이다. Busy waiting은 어떤 다른 프로세스가 생산적으로 사용할지도 모르는 CPU cycles을 낭비한다.&lt;/li&gt;&lt;li&gt;Spinlocks은 그러나, 한 프로세스가 lock에 대해 기다려야 할 때 어떠한 context switch가 요구된다는 점에서 이점을 가지고 있고, 한 context switch는 상당한 시간이 걸릴지도 모른다. 따라서, locks이 짧은 시간에 대해 유효하길 기대될 때, spinlocks은 유용하다. 그것들은 종종 한 쓰레드가 한 프로세서에 대해 &quot;spin&quot;할 수 있는, 그리고 또 다른 쓰레드가 또 다른 프로세서에서 그것의 critical section을 수행하고 있는 multiprocessor systems에서 이용된다.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;* Semaphores&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;semaphore&lt;/b&gt; S는 초기화와 별개로 오직 두 개의 표준 atomic operations를 통해서만 접근 가능한 정수 변수이다 : wait() and signal(). wait() 연산은 원래 P라고 용어가 정해졌다 (네덜란드어 proberen, &quot;to test&quot;); signal은 원래 V로 불려졌다 (verhogen으로부터, &quot;to increment&quot;). wait()과 signal()의 정의는 다음과 같다:&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;wait(S)&lt;/div&gt;&lt;/div&gt;&lt;div&gt;{&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; while(S &amp;lt;= 0)&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ; // busy wait&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; S--;&lt;/div&gt;&lt;div&gt;}&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;signal(S)&lt;/div&gt;&lt;div&gt;{&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; S++;&lt;/div&gt;&lt;div&gt;}&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;wait()과 signal() 연산에서 semaphore의 정수값에 대한 모든 수정은 분리되지 않게 실행되어야 한다. 즉, 한 프로세스가 세마포어 값을 수정할 때, 어떠한 다른 프로세스는 그 같은 세마포어 값을 동시에 수정할 수 없다. 게다가, wait(S)의 경우에, 그 S의 정수값에 대한 테스팅 뿐만 아니라, 그것의 가능한 수정 (S--)도 interruption 없이 실행되어야 한다.&lt;/li&gt;&lt;li&gt;운영체제는 counting semaphores와 binary semaphores 사이를 구분한다. &lt;b&gt;counting semaphore&lt;/b&gt;의 값은 제한되지 않는 영역까지의 범위를 갖을 수 있다. &lt;b&gt;binary semaphore&lt;/b&gt;의 값은 오직 0에서 1사이의 범위만을 갖을 수 있다. 따라서, binary semaphores는 mutex locks와 유사하게 행동한다. 사실, mutex locks을 제공하지 않는 시스템들에서, binary semaphores는 mutual exclusion을 제공하는 대신에 사용되어질 수 있다.&lt;/li&gt;&lt;li&gt;Counting semaphores는 유한한개수의 인스턴스들로 구성된 주어진 resource에 대한 접근을 제어하기 위해 사용될 수 있다.그 세마포어는 이용가능한 자원의 개수로 초기화된다. 한 자원을 사용하길 원하는 각 프로세스는 그 세마포어에서 wait() 연산을 수행한다 (그것으로 인해 그 count를 감소시킨다.) 한 프로세스가 한 resource를 해제할 때, 그것은 signal() 연산을 수행한다 (그 count를 증가시킨다). semaphore에 대한 count가 0으로 될 때, 모든 자원들이 사용되고 있는 중이다. 그 이후에, 한 자원을 사용하길 원하는 프로세스들은 그 count가 0보다 더 커지게 될 때까지 봉쇄(block)될 것이다.&lt;/li&gt;&lt;li&gt;우리는 다양한 동기화 문제들을 해결하기 위해 세마포어들을 또한 사용할 수 있다. 예를들어, 두 개의 concurrently하게 작동하는 프로세스들을 고려해라: 명령어 S1를 가진 P1과 명령어 S2를 가진 P2. S2가 오직 S1이 완료된 후에만 실행되어야 하는 것을 요구한다고 가정하자. 우리는 이 전략을 쉽게 P1과 P2가 0으로 초기화된 공통의 semaphore synch를 공유하게 하여 이 전략을 구현할 수 있다&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;S1;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;signal(synch);&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;프로세스 P2에서, 우리는 다음의 명령어를 넣는다&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;wait(synch);&lt;/div&gt;&lt;div&gt;S2;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;왜냐하면 synch는 0으로 초기화 되기 때문에, P2는 P1이 signal(synch)를 불러온 후에만 S2를 실행할 것이다. 그리고 이것은 S1이 실행되고 난 후이다.&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;mutex locks이 busy waiting의 단점이 있다는 것을기억해라. 여기에서 설명된 wait()과 signal()의 세마포어 연산들의 정의들도 같은 문제를 보여준다. busy waiting에 대한 필요성을 극복하기 위해, 우리는 wait()과 signal() 연산을 다음의 정의로 수정할 수 있다: 한 프로세스가 wait() 연산을 실행하고 그 semaphore 값이&amp;nbsp; 양수가 아닌 것을 발견했을 때, 그 프로세스 그 자체로 봉쇄될 수 있다. 그 block operation은 한 프로세스를 그 세마포어와 관련된 waiting queue에 넣는다. 그러고나서 제어가 CPU scheduler에 넘겨지고, 그 스케쥴러는 실행한 또 다른 프로세스를 선택한다. semaphore S에 대기하고 있는 봉쇄된 한 프로세스는 어떤 다른 프로세스가 signal() 연산을 실행할 때 재개되어야 한다. 그 프로세스는 wakeup() 연산으로 재개될 수 있고, 그것은 그 프로세스를 waiting state에서 ready state로 바꾼다. 그 프로세스는 그러고나서 ready queue에 배치되어진다. (그 CPU는 작동하는 프로세스에서 새롭게 준비된 프로세스로 바껴질 수도 아닐지도 모른다. 이것은 cpu 스케쥴링 알고리즘에 따른다.)&lt;/li&gt;&lt;li&gt;이 정의 하에서 세마포어를 구현하기 위해서, 우리는 세마포어를 다음과같이 정의한다:&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;typedef struct&lt;/div&gt;&lt;/div&gt;&lt;div&gt;{&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; int value;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; struct process* list;&lt;/div&gt;&lt;div&gt;} semaphore;&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;각 세마포어는 한 정수 value와 프로세스의 한 리스트인 list를 갖는다. 한 프로세스가 한 세마포어를 기다려야만 할 때, 그것은 프로세스들의 리스트에 더해진다. signal() 연산은 대기하고있는 프로세스의 리스트에서 한 프로세스를 제거하고, 그 프로세스를 깨운다. 이제 그 wait(), signal() semahore 연산은 다음으로 정의될 수 있다&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;wait(semaphore* S)&lt;/div&gt;&lt;/div&gt;&lt;div&gt;{&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; S-&amp;gt;value--;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; if(S-&amp;gt;value &amp;lt; 0)&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; {&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; add this process to S-&amp;gt; list;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; block();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; }&lt;/div&gt;&lt;div&gt;}&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;signal(semaphore* S)&lt;br /&gt;{&lt;br /&gt;&amp;nbsp; &amp;nbsp; S-&amp;gt;value++;&lt;br /&gt;&amp;nbsp; &amp;nbsp; if(S-&amp;gt;value &amp;lt;= 0)&lt;br /&gt;&amp;nbsp; &amp;nbsp; {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; remove a process P from S-&amp;gt;list;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; wakeup(P);&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;그 block() 연산은 그것을 불러내는 프로세스를 중지시킨다. 그 wakeup(P) 연산은 봉쇄된 프로세스 P의 실행을 재개한다. 이러한 두 개의 연산은 운영체제에 의해 기본 시스템 호출로서 제공된다. 이 구현에서, 세마포어 값들이 음수일지도 모른다는 것에 주목해라, 바면에 세마포어 값들은 busy waiting이 있는 세마포어의 고전적인 정의하에서는 결코 음수가 아니다. 만약 한 세마포어 값이 음수라면, 그것의 크기는 그 세마포어를 대기하는 프로세스들의 개수이다. 이 사실은 decrement의 순서를 바꾸는 것과 wait() 연산의 구현에서 테스트에 의한 것이다.&lt;/li&gt;&lt;li&gt;대기하는 프로세스들의 리스트는 쉽게 각 process control block(PCB)에서의 link field에의해 구현될 수 있다. bounded waiting을 보장하기위해서 그 리스트에서 프로세스들을 더하고 제거하는 한 방법은 FIFO queue를 사용하는 것이다. 거기에서 그 세마포어는 그 큐에 대해 head와 tail pointers 둘 다를 포함한다. 그러나, 일반적으로, 그 리스트는 어떠한 queueing strategy든지 사용할 수 있다. 세마포어에 대한 올바른 사용은 그 세마포어 lists에 대한 특정한 queueing strategy에 의존하지 않는다.&lt;/li&gt;&lt;li&gt;세마포어 연산들이 atomically하게 실행되는 것이 중요하다. 우리는 어떠한 두 프로세스가 wait() and signal() 연산을 같은 세마포어에 대해 동시에 실행할 수 없도록 보장해야만 한다. 이것이 critical-section problem이다; 그리고 single-processor 환경에서, 우리는 간단히 wait()/signal() 연산이 실행되는 시간 동안 interrupts를 금지하여 그것을 해결 할 수 있다. 이 전략은 단일 프로세서 환경에서 효과가 있는데, 왜냐하면 일단 interrupts가 금지되기만 한다면, 다른 프로세스로 부터의 명령어들이 interleaved 되어질 수 없기 때문이다. 오직 그 현재 작동하는 프로세스는 interrupst가 재활성화되고 스케듈러가 제어를 다시 얻을 때 까지 실행된다.&lt;/li&gt;&lt;li&gt;multiprocessor 환경에서, interrupts는 모든 프로세서에 대해 비활성화되어야 한다. 그렇지 않다면, 다른 프로세스로부터의 명령어들이 어떤 임의의 방식으로 끼어들지도 모른다. 모든 프로세서에 대해 interrupts를 비활성화하는 것은 어려운 일일 수 있고, 게다가 심각하게 성능을 감소시킬 수 있다. 그러므로, SMP systems은 compare_and_swap() or spinlocks 같은 대안적인 locking 기법을 wait()과 signal()이 atomically하게 수행되는 것을 보장하기 위해 제공해야만 한다.&lt;/li&gt;&lt;li&gt;우리가 완전히 이 wait()과 signal() 연산의 정의로 busy waiting으 제거하지 않았다는 것을 인정하는 것이 중요하다. 오히려, 우리는 busy waiting을 application program의 entry section에서 critical sections으로 옮겼다. 게다가, 우리는 busy waiting을 wait()/signal() 연산의 critical sections에 제한하고, 이러한 섹션들은 짧다 (만약 적절히 코딩된다면, 그것들은 10개 이상의 명령어가 되서는 안된다). 따라서, 그 critical section은 거의 결코 점유되지 않고, busy waiting은 드물게 일어난다, 오직 짧은 시간 동안만. critical sections이 길거나 (몇 분 또는 몇 시간) 또는 항상 점유될지도 모르는 어플리케이션 프로그램이 가진 전적으로 다른 상황이 존재한다. 그러한 경우에, busy waiting은 매우 비효율적이다.&lt;/li&gt;&lt;li&gt;waiting queue를 가진 semaphore의 구현은 두 개 이상의 프로세스들이 그 waiting processes들 중의 하나에 의해서만 발생할 수 있는 한 사건을 무기한으로 기다리는 상황을 발생시킬지도 모른다. 그 궁금한 event는 signal() 연산의 실행이다. 그허나 한 상태가 도달되었을 때, 이러한프로세스들은 &lt;b&gt;deadlocked&lt;/b&gt;되었다고 말해진다. 이것을 보이기 위해서, 두 개의 프로세스들 P0과 P1로 구성된 하 닛스템을 고려하자, 그리고 각각은 1로 설정된 두 개의 세마포어들 S와 Q에 접근한다:&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;P0&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; P1&lt;/div&gt;&lt;div&gt;wait(S);&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;wait(Q);&lt;/div&gt;&lt;div&gt;wait(Q);&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;wait(S);&lt;/div&gt;&lt;div&gt;&amp;nbsp;...&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;