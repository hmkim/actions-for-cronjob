<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rootjang&#39;s IT Blog</title>
  
  <subtitle>Geunho&#39;s IT Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rootjang92.github.io/"/>
  <updated>2019-01-26T08:23:17.509Z</updated>
  <id>http://rootjang92.github.io/</id>
  
  <author>
    <name>Geun ho</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP 통신과 Ajax</title>
    <link href="http://rootjang92.github.io/2019/01/26/httpAjax/"/>
    <id>http://rootjang92.github.io/2019/01/26/httpAjax/</id>
    <published>2019-01-26T07:41:00.000Z</published>
    <updated>2019-01-26T08:23:17.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-통신과-Ajax"><a href="#HTTP-통신과-Ajax" class="headerlink" title="HTTP 통신과 Ajax"></a>HTTP 통신과 Ajax</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP는 Hyper Text Transfer Protocol의 줄임말로 HTML로 작성된 웹 페이지나 동영상, 음성 파일 등을 주고 받기 위한 통신 규약이다.<br>이것을 SSL로 암호화한 것이 HTTPS이다.</p><h2 id="HTTP-통신"><a href="#HTTP-통신" class="headerlink" title="HTTP 통신"></a>HTTP 통신</h2><p><img src="https://poiemaweb.com/img/traditional-webpage-lifecycle.png" alt="http"></p><p>HTTP에서는 클라이언트가 요청 메세지(Request)를 보내고 서버가 응답메세지(Response)를 반환한다.<br>HTTP에서는 전송 계층 프로토콜로 TCP를 사용하고 네트워크 계층 프로토콜로 IP를 사용하는데 이를 합쳐 TCP/IP라고 부른다. 즉 IP주소를 사용한 포트 번호를 이용해 통신할 컴퓨터를 결정한다. 기본적으로 80번 포트를 사용한다.</p><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>Ajax는 Asynchronous(비동기적) Javascript + XML로 XMLHttpRequest라는 자바스크립트 객체를 이용하여 웹 서버와 <strong>비동기</strong>로 통신하고 DOM을 이용하여 웹 페이지를 <strong>동적</strong>으로 갱신하는 프로그래밍 기법을 말한다.</p><p><img src="https://poiemaweb.com/img/ajax-webpage-lifecycle.png" alt="Ajax Listcycle"></p><p>주로 JSON과 text 데이터를 사용하고 있다. Ajax의 포인트는 <strong>필요한 부분</strong>만 DOM으로 변경한다는 것이다. 또한 통신이 비동기적으로 이루어지기 때문에 서버가 데이터를 다 보내지 않은 상태라 하더라도 클라이언트를 자유롭게 사용할 수 있다.</p><p>즉 Ajax의 장점을 정리하자면</p><ol><li>최소한의 데이터 통신으로 속도가 빠르고 부하가 적다.</li><li>비동기 통신이기 때문에 클라이언트가 다른 작업을 할 수 있다.</li><li>웹 페이지의 갱신을 클라이언트가 담당하여 페이지 전환대신 일부분만 변경하여 빠른 렌더링이 가능하다.</li></ol><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON은 JavaScript Object Notation의 약자로 클라이언트와 서버간의 데이터 교환 규칙(데이터 포맷)을 말한다. JSON은 일반 데이터 포맷보다 효과적인 데이터 구조화가 가능하며 XML보다 가볍기 떄문에 사용이 편리하다. 또한 <strong>순수한 텍스트</strong>로 구성되어 있다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Jang"</span>,</span><br><span class="line">  <span class="attr">"gender"</span>: <span class="string">"male"</span>,</span><br><span class="line">  <span class="attr">"age"</span>: <span class="number">26</span>,</span><br><span class="line">  <span class="attr">"alive"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>키는 반드시 큰 따옴표로 둘러싸야 한다.</strong></p><h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h3><p>JSON.stringify 메서드는 객체를 JSON 형식의 문자열로 변형한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  name: <span class="string">'Jang'</span>,</span><br><span class="line">  gender: <span class="string">'male'</span>,</span><br><span class="line">  age: <span class="number">26</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strObj = <span class="built_in">JSON</span>.stringify(o);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> strObj, strObj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 값의 타입이 Number이면 필터링되어 반환하지 않게 만들어 보세요.!</span></span><br></pre></td></tr></table></figure><h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h3><p>JSON.parse는 JSON 데이터 문자열을 객체로 반환한다. 서버로부터 전달된 JSON 데이터는 텍스트이기 때문에 객체화하여야 한다. 이를 역직렬화라고 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSON 형식의 문자열 =&gt; 객체</span></span><br><span class="line"><span class="comment">// 위 예제와 이어서 진행.</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(strObj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj, obj); <span class="comment">// object &#123; name: 'Lee', gender: 'male' &#125;</span></span><br></pre></td></tr></table></figure><h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><p>Ajax 기법을 사용할 때에는 자바스크립트의 XMLHttpRequest 객체를 사용하여야 한다. 기본적인 처리 흐름으로는</p><ol><li>XMLHttpRequest 객체를 생성한다.</li><li>서버와 통신할 떄 사용할 처리 방법을 등록한다.</li><li>요청을 전송하고 통신을 시작한다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XMLHttpRequest 객체의 생성</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 비동기 방식으로 Request를 오픈한다</span></span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'/users'</span>);</span><br><span class="line"><span class="comment">// Request를 전송한다</span></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>open 메서드를 사용하여 서버로의 요청을 준비한다.</p><table><thead><tr><th style="text-align:left"><center>매개변수</center></th><th style="text-align:center"><center>설명</center></th></tr></thead><tbody><tr><td style="text-align:left"><center>method<center></center></center></td><td style="text-align:center"><center>HTTP method(“GET”,”POST”,”PUT”,”DELETE”)</center></td></tr><tr><td style="text-align:left"><center>async</center></td><td style="text-align:center"><center>비동기 조작여부, default는 true</center></td></tr></tbody></table><p>send 메서드로 준비된 요청을 서버에 전달한다. 기본적으로 GET,POST에 따라 그 방식이 달라진다. GET의 경우 URL의 일부분을인 쿼리 문자열로 데이터를 전달하는 반면에 POST는 페이로드를 Request Body에 담아 전달한다.</p><p><img src="https://poiemaweb.com/img/HTTP_request+response_message.gif" alt="HTTP Request Example"></p><p><strong>페이로드란?</strong></p><p>페이로드라는 용어는 큰 데이터 덩어리 중에 ‘흥미 있는’ 데이터를 구별하는 데 사용된다. 이 용어는 운송업에서 비롯하였는데, 지급(pay)해야 하는 적화물(load)을 의미한다. 예를 들어, 유조선 트럭이 20톤의 기름을 운반한다면 트럭의 총 무게는 차체, 운전자 등의 무게 때문에 그것보다 더 될 것이다. 이 모든 무게를 운송하는데 비용이 들지만, 고객은 오직 기름의 무게만을 지급(pay)하게 된다. 그래서 ‘pay-load’란 말이 나온 것이다.</p><p>프로그래밍에서 주로 메시지 프로토콜(message protocols) 중에 프로토콜 오버헤드(protocol overhead)와 원하는 데이터를 구별할 때 사용된다.<br>(출처 : 위키백과)</p><p><a href="https://stackoverflow.com/questions/978061/http-get-with-request-body" target="_blank" rel="noopener">https://stackoverflow.com/questions/978061/http-get-with-request-body</a></p><h3 id="XMLRequest-setRequestHeader"><a href="#XMLRequest-setRequestHeader" class="headerlink" title="XMLRequest.setRequestHeader"></a>XMLRequest.setRequestHeader</h3><p>이것은 HTTP Request Header의 값을 설정한다. Content-type은 Request Body에 담아 전송할 데이터의 MIME-type의 정보를 표현한다 MIME-type이란<br>클라이언트에게 전송된 문서의 다양성을 알려주기 위한 메커니즘이다. text타입(text/plain, text/html, text/css, text/javascritp), Application(application/json, application/x-www-form-urlencode), File 업로드(multiport/formed-data)가 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// json으로 전송하는 경우</span></span><br><span class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">'/users'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 클라이언트가 서버로 전송할 데이터의 MIME-type 지정: json</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-type'</span>, <span class="string">'application/json'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">title</span>: <span class="string">'JavaScript'</span>, <span class="attr">author</span>: <span class="string">'Park'</span>, <span class="attr">price</span>: <span class="number">5000</span>&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send(<span class="built_in">JSON</span>.stringify(data));</span><br></pre></td></tr></table></figure><p>이런식으로 사용한다.</p><p>또한 클라이언트가 서버에 요청할 때 서버가 Send Back할 데이터의 MIME-type을 Accept로 정할 수 있다. Accept를 설정하지 않으면 send 메서드 호출 시 Acccept 헤더가 <em>/</em>로 전송된다.</p><h3 id="응답처리"><a href="#응답처리" class="headerlink" title="응답처리"></a>응답처리</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XMLHttpRequest.readyState 프로퍼티가 변경될 때 이벤트 핸들러를 호출.</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// readyStates는 XMLHttpRequest의 상태(state)를 반환</span></span><br><span class="line">  <span class="comment">// readyState: 4 =&gt; DONE(서버 응답 완료)</span></span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === XMLHttpRequest.DONE) &#123;</span><br><span class="line">    <span class="comment">// status는 response 상태 코드를 반환 : 200 =&gt; 정상</span></span><br><span class="line">    <span class="keyword">if</span>(xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Error!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>여기서 onreadystatechange는 Response가 클라이언트에 도달하여 발생하게 된 이벤트를 감지하여 콜백함수를 실행하여 준다. 이 상황은 readyState가 변했을 떄 실행횐다.</p><p>readyState의 값은 0~4까지 있으며 0은 open메서드 호출 이전, 1은 호출 완료(OPENED), 2는 (HEADERS_RECIVED), 3은 LOADING, 4는 DONE(완료)이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTP-통신과-Ajax&quot;&gt;&lt;a href=&quot;#HTTP-통신과-Ajax&quot; class=&quot;headerlink&quot; title=&quot;HTTP 통신과 Ajax&quot;&gt;&lt;/a&gt;HTTP 통신과 Ajax&lt;/h1&gt;&lt;h2 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot;
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="JS Memo" scheme="http://rootjang92.github.io/categories/Javascript/JS-Memo/"/>
    
    
      <category term="Javascript, HTTP, Ajax" scheme="http://rootjang92.github.io/tags/Javascript-HTTP-Ajax/"/>
    
  </entry>
  
  <entry>
    <title>HTML 폼과 CSS 제어하기</title>
    <link href="http://rootjang92.github.io/2019/01/18/form/"/>
    <id>http://rootjang92.github.io/2019/01/18/form/</id>
    <published>2019-01-18T09:46:23.000Z</published>
    <updated>2019-01-18T10:04:33.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML-폼-태그와-CSS-제어하기"><a href="#HTML-폼-태그와-CSS-제어하기" class="headerlink" title="HTML 폼 태그와 CSS 제어하기"></a>HTML 폼 태그와 CSS 제어하기</h1><h2 id="폼"><a href="#폼" class="headerlink" title="폼"></a>폼</h2><p>웹에서는 사용자 정보를 입력할 때, 검색 키워드를 입력할 때 그리고 키워드를 검색할 때 등 다양한 용도로 사용된다. 데이터 처리 관점에서 바라보자면</p><p>폼에 입력한 데이터를 웹 서버로 보내고 웹 서버는 데이터를 처리하여 반환한다는 관점과<br>클라이언트 측 자바스크립트로 웹 어플리케이션을 만들 때 사용자 입력을 받는 UI로 사용한다. 이 때 데이터 처리는 클라이언트 자바스크립트가 담당한다라는 두 가지 관점이 있다.</p><h3 id="폼-요소와-폼-컨트롤-요소"><a href="#폼-요소와-폼-컨트롤-요소" class="headerlink" title="폼 요소와 폼 컨트롤 요소"></a>폼 요소와 폼 컨트롤 요소</h3><p>폼 요소를 작성하고는 method와 action 속성을 지정한다. method 속성에는 post, get 등의 방법이 있고 action은 데이터를 처리하는 CGI 프로그램의 URL을 받는다.</p><h3 id="폼-요소와-폼-컨트롤-요소-가져오기"><a href="#폼-요소와-폼-컨트롤-요소-가져오기" class="headerlink" title="폼 요소와 폼 컨트롤 요소 가져오기"></a>폼 요소와 폼 컨트롤 요소 가져오기</h3><ul><li>DOM 메서드로 가져오기</li></ul><p>DOM을 할 때 배웠던 getElementById, getElementByTagName 등의 메서드를 사용하여 가져올 수 있다.</p><ul><li>forms 프로퍼티로 form 요소 가져오기</li></ul><p>form 요소 목록은 Document 객체의 forms 프로퍼티에서도 가져올 수 있다.</p><ul><li>form 요소 객체의 자식 요소로 객체 가져오기</li></ul><h2 id="CSS-제어하기"><a href="#CSS-제어하기" class="headerlink" title="CSS 제어하기"></a>CSS 제어하기</h2><p>스타일을 변경하는 방법에는 요소 객체의 style 속성을 수정하기, class 속성 값을 바꾸어 스타일 전환하기, 스타일 시트를 수정하는 방법이 있다.<br>주로 1,2를 사용한다.</p><h3 id="인라인-스타일-제어하기"><a href="#인라인-스타일-제어하기" class="headerlink" title="인라인 스타일 제어하기"></a>인라인 스타일 제어하기</h3><p>1번의 방법을 인라인 스타일이라고 하는데 이를 제어할 수 있다.</p><p>요소 객체가 가진 style 프로퍼티의 값은 CSSStyleDeclaration 객체이다(카멜 케이스)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"title"</span>&gt;</span>Javascript<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'title'</span>);</span></span><br><span class="line"><span class="javascript">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      element.style.backgroundColor = <span class="string">"pink"</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="클래스-제어로-스타일-변경"><a href="#클래스-제어로-스타일-변경" class="headerlink" title="클래스 제어로 스타일 변경"></a>클래스 제어로 스타일 변경</h3><p>이 방법을 이용하면 여러 요소의 스타일을 한꺼번에 바꿀 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTML-폼-태그와-CSS-제어하기&quot;&gt;&lt;a href=&quot;#HTML-폼-태그와-CSS-제어하기&quot; class=&quot;headerlink&quot; title=&quot;HTML 폼 태그와 CSS 제어하기&quot;&gt;&lt;/a&gt;HTML 폼 태그와 CSS 제어하기&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="JS Memo" scheme="http://rootjang92.github.io/categories/Javascript/JS-Memo/"/>
    
    
      <category term="js, form, css" scheme="http://rootjang92.github.io/tags/js-form-css/"/>
    
  </entry>
  
  <entry>
    <title>문서 제어</title>
    <link href="http://rootjang92.github.io/2019/01/18/DOM/"/>
    <id>http://rootjang92.github.io/2019/01/18/DOM/</id>
    <published>2019-01-18T08:08:55.000Z</published>
    <updated>2019-01-18T09:45:32.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="자바스크립트로-문서를-제어하기"><a href="#자바스크립트로-문서를-제어하기" class="headerlink" title="자바스크립트로 문서를 제어하기."></a>자바스크립트로 문서를 제어하기.</h1><h2 id="DOM-Tree"><a href="#DOM-Tree" class="headerlink" title="DOM Tree"></a>DOM Tree</h2><p>DOM(Document Object Model)은 문서를 제어하는 API이다. 웹 브라우저가 웹 페이지를 읽으면 렌더링 엔진은 웹 페이지의 HTML 구문을 해석하고 Document 객체에서 문서 내용을 관리하는 <strong>DOM 트리</strong> 구조를 만들어낸다.</p><p>간단한 웹페이지가 만들어졌을 때 DOM 트리를 구성하는 객체 하나를 <strong>노드(Node)</strong>라고 한다. 기본적으로 문서 노드(Document 객체), HTML 요소 노드, 텍스트 노드로 구성이 된다.</p><p><img src="https://poiemaweb.com/img/dom-tree.png" alt="DOM 트리"></p><p>주의할 점은 HTML과 달리 DOM 트리는 요소 앞뒤에 연속적인 공백 문자를 발견하면 텍스트로 취급한다. (그래서 특히 제이쿼리 사용할 때 주의!)<br>html 요소 안에 있는 첫 번째와 마지막 공백 문자에 대해서는 공백 노드를 생성하지 않는다. 공백 노드를 주의해야 하는 것은 크로스 브라우징 때문인데, IE8이하 버전에서는 공백 노드가 없기 때문이다. (이놈의 IE…)</p><ul><li>Document 객체</li></ul><p>Document 객체는 모든 노드의 조상 노드이며 DOM 트리의 루트이다. 그래서 DOM 트리는 많은 요소들의 포함 관계를 표현한다.</p><h2 id="노드-객체의-프로퍼티"><a href="#노드-객체의-프로퍼티" class="headerlink" title="노드 객체의 프로퍼티"></a>노드 객체의 프로퍼티</h2><p>parentNode : 이 노드의 부모 노드를 참조한다. Document객체의 부모 노드는 null이다.<br>childNodes : 이 노드의 자식 노드의 참조를 저장한 유사 배열 객체를 나타낸다.(NodeList).<br>firstChild : 이 노드의 첫 번째 자식 노드를 나타낸다.<br>lastChild : 이 노드의 마지막 자식 노드를 나타낸다.<br>nextSibling : 이 노드와 같은 부모를 가진 노드의 다음 형제 노드를 가리킨다.<br>previousSibling : 이 노드와 같은 부모를 가진 노드의 이전 형제 노드를 가리킨다.<br>nodeType : 노드 유형을 뜻하는 숫자를 나타낸다.<br>nodeValue : 텍스트 노드의 텍스트 콘텐츠를 나타낸다.<br>nodeName : 요소 노드는 대문자로 바뀐 요소 이름이 들어가고 텍스트 노드는 ‘#text’가 들어간다.</p><p>이를 참조하기 위해선 공백 노드의 영향을 받기 때문에 주의가 필요하다. 그래서 이러한 불편함 때문에 자주 사용하진 않는다.</p><h2 id="HTML-요소의-트리"><a href="#HTML-요소의-트리" class="headerlink" title="HTML 요소의 트리"></a>HTML 요소의 트리</h2><p>이러한 불편함을 제거하고자 (HTML 트리에선 공백 노드가 없기 때문에) HTML 문서에서 요소의 계층 구조만 가져오기 위한 프로퍼티도 존재한다.</p><p>childNodes : 이 요소의 자식 요소를 참조한 유사 배열 객체(NodeList)<br>parentElement : 이 요소의 부모 요소 객체를 참조.<br>firstElementChild : 이 요소의 첫 번째 자식 요소 객체를 참조.<br>lastElementChild : 이 요소의 마지막 자식 요소 객체를 참조.<br>nextElementSibling : 이 요소와 같은 부모를 가진 요소 다음의 형제 요소 객체를 참조.<br>previousElementSibling : 이 요소와 같은 부모를 가진 요소 이전의 형제 요소 객체를 참조.<br>childElementCount : 자식 요소의 개수를 나타낸다. === children.length</p><h2 id="자바스크립트로-웹-페이지-제어하기"><a href="#자바스크립트로-웹-페이지-제어하기" class="headerlink" title="자바스크립트로 웹 페이지 제어하기"></a>자바스크립트로 웹 페이지 제어하기</h2><p>자바스크립트를 사용하면 DOM 트리의 노드 객체를 가져와서 제어할 수 있다. 또한 스타일 규칙 제어도 가능하다. 렌더링 엔진은 DOM 트리와 스타일 규칙이 바뀔떄마다 렌더 트리를 다시 구성하게 된다.</p><h2 id="노드-객체-가져오기"><a href="#노드-객체-가져오기" class="headerlink" title="노드 객체 가져오기"></a>노드 객체 가져오기</h2><p>자바스크립트로 HTML 요소를 제어하려면 그 전에 제어하고자 하는 요소 객체를 먼저 가져와야 한다.</p><h3 id="id-속성으로-노드-가져오기"><a href="#id-속성으로-노드-가져오기" class="headerlink" title="id 속성으로 노드 가져오기"></a>id 속성으로 노드 가져오기</h3><p>HTML 문서에 id 속성을 지정해서 가져올 수 있다. id는 같은 문서에서 유일한 값이다. id값으로 요소 객체를 가져올 때는 getElementById 메서드를 사용한다.</p><h3 id="요소의-이름으로-노드-가져오기"><a href="#요소의-이름으로-노드-가져오기" class="headerlink" title="요소의 이름으로 노드 가져오기"></a>요소의 이름으로 노드 가져오기</h3><p>getElementsByTagName이라는 메서드를 이용해서 인수로 넘긴 문자열과 같은 이름의 태그 목록을 가져올 수 있다. 중요한 건 이 메서드는 NodeList 객체를 반환한다. (같은 이름의 태그가 많기 때문이다.)</p><h3 id="NodeList를-반환하는-메서드"><a href="#NodeList를-반환하는-메서드" class="headerlink" title="NodeList를 반환하는 메서드"></a>NodeList를 반환하는 메서드</h3><p>getElementsByTagName, getElementsByName, getElementsByClassName 메서드는 NodeList 객체를 반환한다.<br>NodeList 객체는 HTML 문서의 변화에 따라 동적으로 바뀐다.</p><h3 id="class-속성값으로-노드-가져오기"><a href="#class-속성값으로-노드-가져오기" class="headerlink" title="class 속성값으로 노드 가져오기"></a>class 속성값으로 노드 가져오기</h3><p>HTML 요소에 class 속성을 지정하여 가져오는 방법을 말한다. getElementByClassName 메서드를 사용하면 특정 class 속성을 가지고 있는 요소 객체 목록을 가져온다.</p><p>이 메서드는 공백 문자로 연결한 문자열을 인수로 넘기면 그 식별자들을 class 속성 값으로 갖는 요소의 목록을 가져올 수 있다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cat black"</span>&gt;</span>봄베이<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cat white"</span>&gt;</span>페르시안<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dog white"</span>&gt;</span>스피츠<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> cats = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'cat'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cats.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(i + <span class="string">" 번 째 고양이 : "</span> + cats[i].innerHTML);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="css-선택자로-노드-가져오기"><a href="#css-선택자로-노드-가져오기" class="headerlink" title="css 선택자로 노드 가져오기."></a>css 선택자로 노드 가져오기.</h3><p>querySelectorAll 메서드를 사용하면 인수로 넘긴 선택자와 일치하는 요소 객체가 담긴 NodeList를 가져올 수 있다. 단 이 방법의 NodeList는 메서드를 호출한 시점에 일치하는 요소를 반환한다.(동적으로 NodeList가 변하진 않는다.)</p><p>querySelector는 지정한 선택자와 일치한 요소 객체 중 첫 번째 요소를 반환한다.</p><h2 id="속성-값의-읽기와-쓰기"><a href="#속성-값의-읽기와-쓰기" class="headerlink" title="속성 값의 읽기와 쓰기."></a>속성 값의 읽기와 쓰기.</h2><p>HTML 요소에는 속성을 설정할 수가 있다. 이를 자바스크립트로도 읽거나 쓸 수 있다.</p><h3 id="요소-객체의-프로퍼티로-요소의-속성을-읽고-쓰기"><a href="#요소-객체의-프로퍼티로-요소의-속성을-읽고-쓰기" class="headerlink" title="요소 객체의 프로퍼티로 요소의 속성을 읽고 쓰기"></a>요소 객체의 프로퍼티로 요소의 속성을 읽고 쓰기</h3><p>HTML의 일반적인 속성이나 이벤트 처리기 프로퍼티 등이 정의되어 있기 때문에 <strong>요소 객체.속성 이름</strong> 방식으로 작성하면 된다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"school"</span> <span class="attr">href</span>=<span class="string">"http://school.gilbut.co.kr"</span>&gt;</span>길벗 스쿨<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> anchor = <span class="built_in">document</span>.getElementById(<span class="string">'school'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(anchor.href);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="속성-값-가져오기"><a href="#속성-값-가져오기" class="headerlink" title="속성 값 가져오기"></a>속성 값 가져오기</h3><p><strong>요소 객체.getAttribute(속성 이름)</strong>의 방식으로 사용한다. 속성이 없으면 null 혹은 빈 문자열을 반환한다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"favorite"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"dog"</span> <span class="attr">value</span>=<span class="string">"pome"</span>&gt;</span>포메라니안<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"dog"</span> <span class="attr">value</span>=<span class="string">"dalma"</span>&gt;</span>달마시안<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"dog"</span> <span class="attr">value</span>=<span class="string">"bool"</span>&gt;</span>불독</span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> result = [];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> fm = <span class="built_in">document</span>.getElementById(<span class="string">'favorite'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> list = fm.children;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span>(list[i].nodeName == <span class="string">'INPUT'</span> &amp;&amp; list[i].type == <span class="string">"checkbox"</span>) &#123;</span></span><br><span class="line"><span class="javascript">        result.push(list[i].getAttribute(<span class="string">"value"</span>));</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(result.join(<span class="string">','</span>));</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="속성-값-설정하기"><a href="#속성-값-설정하기" class="headerlink" title="속성 값 설정하기"></a>속성 값 설정하기</h3><p>setAttribute 메서드를 이용하면 요소의 속성을 설정할 수 있다. 해당 속성이 없으면 그 속성을 새롭게 추가한다.</p><p>위 두 메서드의 장점은 HTML의 일반적인 속성 외에도 모든 속성을 설정할 수 있다는 점과 속성 이름을 프로그램 실행 중에 동적으로 설정할 수 있다는 것이다.</p><p>그 외에도 속성을 확인하는 hasAttribute, 제거하는 removeAttribute 메서드가 있다.</p><h2 id="HTML-요소의-내용을-읽고-쓰기"><a href="#HTML-요소의-내용을-읽고-쓰기" class="headerlink" title="HTML 요소의 내용을 읽고 쓰기"></a>HTML 요소의 내용을 읽고 쓰기</h2><h3 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h3><p>innerHTML 프로퍼티는 요소 안의 HTML 코드를 읽거나 쓸 수 있다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"cards"</span>&gt;</span>&amp;hearts;하트는 <span class="tag">&lt;<span class="name">em</span>&gt;</span>승려<span class="tag">&lt;/<span class="name">em</span>&gt;</span>라는 뜻입니다.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> para = <span class="built_in">document</span>.getElementById(<span class="string">'cards'</span>);</span></span><br><span class="line"><span class="xml">    para.innerHTML = "&amp;diams;다이아는 <span class="tag">&lt;<span class="name">strong</span>&gt;</span>상인<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>이라는 뜻입니다."</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(para.innerHTML);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="textContent와-innerText-프로퍼티"><a href="#textContent와-innerText-프로퍼티" class="headerlink" title="textContent와 innerText 프로퍼티"></a>textContent와 innerText 프로퍼티</h3><p>textContent는 웹 페이지에 표시했을 때의 텍스트 정보를 표시한다. 다만 IE9 이하에서는 사용이 안되니 크로스 브라우징을 신경써야 한다.<br>대신 사용할 수 있는 프로퍼티가 innerText이다. 둘의 차이점은</p><ul><li>textContent는 script 요소 안의 텍스트를 반환하지만 innerText는 반환하지 않는다.</li><li>textContent는 공백 문자를 그대로 반환하지만 innerText는 남는 공백 문자를 제거한다.</li><li>innerText는 table, tbody, tr 요소 등의 테이블 요소를 수정할 수 없다.</li></ul><p>라는 차이가 있다.</p><h2 id="노드-생성-삽입-삭제"><a href="#노드-생성-삽입-삭제" class="headerlink" title="노드 생성, 삽입, 삭제"></a>노드 생성, 삽입, 삭제</h2><p><strong>노드 객체를 생성하는 주요 메서드</strong></p><p>document.createElement : 요소 노드 객체 생성<br>document.createAttribute : 속성 노드 객체 생성<br>document.createTextNode : 텍스트 노드 객체 생성<br>document.createComment : 주석 노드 객체 생성<br>document.createDocumentFragment : 도큐먼트 프레그먼트<br>document.importNode : 다른 문서에 있는 노드 복사</p><h2 id="노드-삽입하기"><a href="#노드-삽입하기" class="headerlink" title="노드 삽입하기"></a>노드 삽입하기</h2><ol><li>appendChild</li></ol><p>인수로 넘긴 노드 객체를 해당 요소에 마지막 자식 노드로 삽입한다. 그 객체가 DOM 트리에 추가되고 각 노드에 계층 구조를 정의하는 프로퍼티가 바뀐다.</p><ol start="2"><li>insertBefore</li></ol><p>지정한 자식 노드 바로 앞에 노드 객체를 삽입할 때 사용하는 메서드이다.</p><p>이 두 메서드를 문서에 삽입하면 해당 노드를 현재 위치에서 삭제하고 새로운 위치에 삽입하게 된다. 그래서 결과적으론 그 노드가 이동하게 되는 셈이다.</p><ol start="3"><li>HTML 요소를 생성하는 편리한 함수.</li></ol><p>실제 요소를 동적으로 생성하는 코드는 요소 이름, 속성 이름과 속성 값, 자식 노드 목록을 지정하는 코드가 대부분이다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./elt.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> headline = elt(<span class="string">'h1'</span>, <span class="literal">null</span>, <span class="string">"DOM에 관하여"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.body.appendChild(headline);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> input = elt(<span class="string">'input'</span>, &#123; <span class="attr">type</span>: <span class="string">"button"</span>, <span class="attr">value</span>: <span class="string">"click"</span>&#125;);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.body.appendChild(input);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> bloodtypes = [<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"O"</span>,<span class="string">"AB"</span>];</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> form = elt(<span class="string">"form"</span>, &#123;<span class="attr">id</span>: <span class="string">"menu"</span>&#125;);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> select = elt(<span class="string">"select"</span>, &#123;<span class="attr">name</span>: <span class="string">"bloodtype"</span>, <span class="attr">id</span>: <span class="string">"bloodtype"</span>&#125;);</span></span><br><span class="line"><span class="javascript">      bloodtypes.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        select.appendChild(elt(<span class="string">"option"</span>, <span class="literal">null</span>, type));</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="undefined">      form.appendChild(select);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.body.appendChild(form);</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;form id="menu"&gt;</span></span><br><span class="line"><span class="comment">    &lt;select name="bloodtype" id="bloodtype"&gt;</span></span><br><span class="line"><span class="comment">      &lt;option&gt;A&lt;/option&gt;</span></span><br><span class="line"><span class="comment">      &lt;option&gt;B&lt;/option&gt;</span></span><br><span class="line"><span class="comment">      &lt;option&gt;O&lt;/option&gt;</span></span><br><span class="line"><span class="comment">      &lt;option&gt;AB&lt;/option&gt;</span></span><br><span class="line"><span class="comment">    &lt;/select&gt;</span></span><br><span class="line"><span class="comment">  &lt;/form&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>노드 삭제하기</li></ol><p>removeChild 메서드는 노드의 자식 노드를 삭제한다.</p><ol start="5"><li>노드 치환하기</li></ol><p>replaceChild는 인수로 받은 자식 노드를 제거하고 새로운 노드로 치환한다.</p><h2 id="HTML-요소의-위치"><a href="#HTML-요소의-위치" class="headerlink" title="HTML 요소의 위치"></a>HTML 요소의 위치</h2><h3 id="좌표계"><a href="#좌표계" class="headerlink" title="좌표계"></a>좌표계</h3><p>요소 위치를 표현하기 위한 좌표계는 뷰포트 좌표계와 문서 좌표계가 있다. 단위는 픽셀이고 x축 방향은 오른쪽, y축 방향은 아래쪽이다.</p><p>뷰포트 좌표계는 왼쪽 위 꼭짓점을 원점으로 하는 웹 브라우저에서 문서의 내용을 표시하는 영역이다. (그래서 윈도우 좌표계라고도 한다.)<br>문서좌표계는 왼쪽 위 꼭짓점을 원점으로 하며 웹 브라우저 표시 영역 안에 표시된다. 그래서 문서를 스크롤하면 문서 좌표계의 원점이 뷰표트를 따라 이동한다.</p><h3 id="HTML-요소의-위치와-크기"><a href="#HTML-요소의-위치와-크기" class="headerlink" title="HTML 요소의 위치와 크기"></a>HTML 요소의 위치와 크기</h3><p>getBoundingClientRect 메서드는 뷰포트 좌표계로 측정한 해당 요소의 border 박스 위치와 크기 정보를 담은 객체를 반환한다.</p><p>left, top, right, bottom, width, height 프로퍼티를 가지고 있다.</p><p>IE9 이후에는</p><p>window.innerWidth, window.innerHeight를 사용하여 뷰포트늬 너비나 높이를 구할 수 있다.</p><h3 id="스크롤한-거리-구하기"><a href="#스크롤한-거리-구하기" class="headerlink" title="스크롤한 거리 구하기"></a>스크롤한 거리 구하기</h3><p>각 브라우저 마다 제공하는 프로퍼티가 다르다.</p><ul><li>IE, Firefox</li></ul><p>document.documentElement.scrollLeft(Top) : x축 방향(y축 방향)으로 스크롤한 거리.</p><ul><li>Chrome, Safari, Ofera, Edge</li></ul><p>document.body.scrollLeft(Top) :  x축 방향(y축 방향)으로 스크롤한 거리.</p><ul><li>firefox, chrome, safari, ofera, edge, IE9 이상</li></ul><p>window.pageX(Y)Offset : X축(Y축) 방향으로 스크롤한 거리.</p><h3 id="특정-위치로-스크롤-하기"><a href="#특정-위치로-스크롤-하기" class="headerlink" title="특정 위치로 스크롤 하기"></a>특정 위치로 스크롤 하기</h3><p>window 객체의 scrollTo 메서드는 문서 좌표를 인수로 받으며, 원점까지 스크롤 합니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;자바스크립트로-문서를-제어하기&quot;&gt;&lt;a href=&quot;#자바스크립트로-문서를-제어하기&quot; class=&quot;headerlink&quot; title=&quot;자바스크립트로 문서를 제어하기.&quot;&gt;&lt;/a&gt;자바스크립트로 문서를 제어하기.&lt;/h1&gt;&lt;h2 id=&quot;DOM-Tre
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="JS Memo" scheme="http://rootjang92.github.io/categories/Javascript/JS-Memo/"/>
    
    
      <category term="javascript, dom" scheme="http://rootjang92.github.io/tags/javascript-dom/"/>
    
  </entry>
  
  <entry>
    <title>Map과 Set</title>
    <link href="http://rootjang92.github.io/2019/01/05/Map/"/>
    <id>http://rootjang92.github.io/2019/01/05/Map/</id>
    <published>2019-01-05T09:17:41.000Z</published>
    <updated>2019-01-05T09:44:58.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Map과-Set-객체"><a href="#Map과-Set-객체" class="headerlink" title="Map과 Set 객체"></a>Map과 Set 객체</h1><h2 id="Map-객체의-생성"><a href="#Map-객체의-생성" class="headerlink" title="Map 객체의 생성"></a>Map 객체의 생성</h2><p>Map 객체는 데이터를 수집하여 활용하기 위한 객체이다. 키와 값의 쌍을 Map 객체 안에 저장해서 사용한다.<br>Object와의 차이점으로는</p><ol><li>데이터를 수집하기 위한 다양한 메서드들</li><li>Map 객체는 키 타입에 제한이 없다.</li><li>해시 테이블을 이용하여 검색 속도가 빠르다.</li><li>이터러블하고 for/of문으로 순회하면 키와 값으로 구성된 배열을 반환한다.</li><li>size 프로퍼티로 데이터 개수를 구할 수 있다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zip = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">"Tom"</span>, <span class="string">"131-8634"</span>], [<span class="string">"Huck"</span>, <span class="string">"556-0002"</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(zip);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">제네레이터를 이용한 이터레이터 생성</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">makeZip</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> [<span class="string">"Tom"</span>, <span class="string">"131-8634"</span>],</span><br><span class="line">  <span class="keyword">yield</span> [<span class="string">"Huck"</span>, <span class="string">"556-0002"</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> zips = makeZip();</span><br><span class="line">zip = <span class="keyword">new</span> <span class="built_in">Map</span>(zips);</span><br><span class="line"><span class="built_in">console</span>.log(zip);</span><br><span class="line"><span class="built_in">console</span>.log(zip.size);</span><br></pre></td></tr></table></figure><h2 id="Map-객체의-메서드"><a href="#Map-객체의-메서드" class="headerlink" title="Map 객체의 메서드"></a>Map 객체의 메서드</h2><p>Map.prototype의 메서드를 상속받는다.</p><p>clear() : Map 객체 안의 모든 데이터를 삭제한다.<br>delete(key) : key가 가리키는 데이터를 삭제한다.<br>entries() : 데이터값을 저장한 이터레이터를 데이터를 삽입한 순서대로 반환한다.<br>forEach(callback) : 모든 데이터를 대상으로 콜백함수 실행.<br>get(key) : key가 가리키는 데이터를 반환한다.<br>has(key) : 키가 가리키는 데이터가 있는지 판정한다.<br>keys() : 데이터 키를 값으로 가지는 이터레이터를 반환한다.<br>set(key, value) : 키가 key이고 값이 value인 데이터를 추가한다.<br>values() : 데이터 값을 값으로 가지는 이터레이터를 반환한다.</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 객체는 중복되지 않는 유일한 데이터를 수집하여 활용하기 위한 객체이다. Set 객체는 데이터의 값의 단순 집합으로 간주한다. Set 객체는 외부에서 키를 사용하여 데이터 값을 추가/삭제/검색할 수 있다는 장점이 있다. 또한 값의 데이터 타입에 제한이 없다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="built_in">console</span>.log(set);</span><br></pre></td></tr></table></figure><p>초기 데이터를 인수로 지정해서 생성할 수도 있다. 이 때 초기 데이터는 값을 가지는 이터러블한 객체이다.</p><ul><li>동일성의 정의</li></ul><p>Set 객체에서의 동일성은 일반적인 동등 연산자(===)와는 차이가 있다. NaN과 NaN이 같고 +0과 -0이 같다.</p><h2 id="Set-객체의-메서드"><a href="#Set-객체의-메서드" class="headerlink" title="Set 객체의 메서드"></a>Set 객체의 메서드</h2><p>add(value) : Set 객체에 데이터 값 value를 추가한다.<br>clear() : Set 객체 안의 모든 데이터를 삭제한다.<br>delete(value) : Set 객체에서 value를 값으로 갖는 데이터를 삭제한다.<br>values() : Set 객체에서 데이터 값을 값으로 갖는 이터레이터를 반환한다.<br>forEach(callback) : Set 객체의 모든 데이터를 대상으로 콜백함수 실행.<br>has(value) : Set 객체에서 value를 값으로 갖는 데이터가 있는지 판별.<br>keys() : Set 객체에서 데이터 값을 값으로 갖는 이터레이터를 반환.<br>values() : Set 객체에서 데이터 값을 값으로 갖는 이터레이터를 반환한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Map과-Set-객체&quot;&gt;&lt;a href=&quot;#Map과-Set-객체&quot; class=&quot;headerlink&quot; title=&quot;Map과 Set 객체&quot;&gt;&lt;/a&gt;Map과 Set 객체&lt;/h1&gt;&lt;h2 id=&quot;Map-객체의-생성&quot;&gt;&lt;a href=&quot;#Map-객체의
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="JS Memo" scheme="http://rootjang92.github.io/categories/Javascript/JS-Memo/"/>
    
    
      <category term="javascript,Map, Set" scheme="http://rootjang92.github.io/tags/javascript-Map-Set/"/>
    
  </entry>
  
  <entry>
    <title>자바스크립트의 배열</title>
    <link href="http://rootjang92.github.io/2019/01/05/Array/"/>
    <id>http://rootjang92.github.io/2019/01/05/Array/</id>
    <published>2019-01-05T08:06:13.000Z</published>
    <updated>2019-01-26T07:41:41.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="자바스크립트의-배열-활용하기"><a href="#자바스크립트의-배열-활용하기" class="headerlink" title="자바스크립트의 배열 활용하기"></a>자바스크립트의 배열 활용하기</h1><p>저~~번에 살펴봤듯이 배열은 Array 타입의 <strong>객체</strong> 이며 Array.prototype의 프로퍼티를 상속받는다. 오늘은 Array.prototype 객체에 저장되어 있는 배열 메서드를 활용하는 방법에 대해 알아보려고 한다.</p><h2 id="수정-메서드"><a href="#수정-메서드" class="headerlink" title="수정 메서드"></a>수정 메서드</h2><p>수정 메서드는 원본 배열을 바로 수정해버리기 때문에 주의가 필요하다.</p><ul><li>push 메서드</li></ul><p>배열 마지막에 하나 이상의 요소를 추가한 후 그 배열의 길이를 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>];</span><br><span class="line">a.push(<span class="string">'D'</span>);</span><br></pre></td></tr></table></figure><p>두 개 이상 추가 시에는 요소의 값을 쉼표로 구분하여 인수로 넘긴다.</p><ul><li>pop 메서드</li></ul><p>배열의 마지막 요소를 잘라내어 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>];</span><br><span class="line">a.pop();</span><br></pre></td></tr></table></figure><ul><li>shift 메서드</li></ul><p>배열의 첫 번째 요소를 제거한 후 모든 배열 요소를 왼쪽으로 이동시킨다. 반환값은 삭제된 요소의 값이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>];</span><br><span class="line">a.shift();</span><br></pre></td></tr></table></figure><ul><li>unshift 메서드</li></ul><p>배열 앞부분에 요소를 한 개 이상 추가한 후 배열 요소를 모두 오른쪽으로 이동시킨다. 반환값을 배열의 길이이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>];</span><br><span class="line">a.unshift(<span class="string">"X"</span>);</span><br></pre></td></tr></table></figure><ul><li>splice 메서드</li></ul><p>특정 인덱스의 배열 요소를 갈아 끼우거나 삭제할 때 사용한다.</p><p>Array.prototype.splice(index, howmany [,data …]);</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>];</span><br><span class="line">a.splice(<span class="number">1</span>, <span class="number">2</span>, <span class="string">'X'</span>,<span class="string">'Y'</span>,<span class="string">'Z'</span>); <span class="comment">// 인덱스 1부터 2개를 삭제하고 그 위에 생성된 요소를 끼워 넣는다.</span></span><br></pre></td></tr></table></figure><p>첫 번째 인수만 넘기면 그 인덱스 <strong>이후</strong>에 있는 모든 배열 요소를 삭제한다. 또한 첫 번째 인수가 음수이면 이 값에 배열 길이를 더한 값을 삭제 시작위치로 간주한다.</p><p>두 번째 인수가 0일 경우 인덱스가 가리키는 요소 바로 앞에 세 번째 이후 요소를 끼워 넣는다.</p><ul><li>sort 메서드</li></ul><p>배열 안의 요소를 정렬하는 메서드이다. 인수는 실제 비교를 담당하는 함수의 참조를 넘기고 반환값을 정렬된 배열이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points = [<span class="number">40</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">25</span>, <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">points.sort();</span><br><span class="line"><span class="built_in">console</span>.log(points); <span class="comment">// [ 1, 10, 100, 2, 25, 40, 5 ]</span></span><br></pre></td></tr></table></figure><p>주의할 점은 배열의 요소가 숫자여도 일시적으로 문자열로 변환된다는 사실이다. 그래서 10이 2보다 앞서게 되는 상황이 발생하게 된다. (유니코드)</p><p>그래서 그런 경우를 방지하기 위해 밑의 예제처럼 사용하는 공식이 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points = [<span class="number">40</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">25</span>, <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 숫자 배열 오름차순 정렬</span></span><br><span class="line"><span class="comment">// 비교 함수의 반환값이 0보다 작은 경우, a를 우선하여 정렬한다.</span></span><br><span class="line">points.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a - b; &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(points); <span class="comment">// [ 1, 2, 5, 10, 25, 40, 100 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 숫자 배열에서 최소값 취득</span></span><br><span class="line"><span class="built_in">console</span>.log(points[<span class="number">0</span>]); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 숫자 배열 내림차순 정렬</span></span><br><span class="line"><span class="comment">// 비교 함수의 반환값이 0보다 큰 경우, b를 우선하여 정렬한다.</span></span><br><span class="line">points.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> b - a; &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(points); <span class="comment">// [ 100, 40, 25, 10, 5, 2, 1 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 숫자 배열에서 최대값 취득</span></span><br><span class="line"><span class="built_in">console</span>.log(points[<span class="number">0</span>]); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p>또한 undefined는 배열의 마지막에 위치시킨다.<br>예제를 참조하여 프로퍼티 이름을 key값으로 받아 key가 가리키는 프로퍼티를 기준으로 객체 배열을 정렬해 보자.</p><h2 id="접근자-메서드"><a href="#접근자-메서드" class="headerlink" title="접근자 메서드"></a>접근자 메서드</h2><p>접근자 메서드는 새로운 배열을 반환하여 원래 배열을 수정하지 않는 메서드이다. 사실 상 가장 많이 사용되는 배열 메서드이다.</p><ul><li>join 메서드</li></ul><p>join은 배열의 모든 요소 값을 문자열로 바꾼 후에 인수로 받은 문자로 연결하여 반환한다. undefined나 null은 빈 문자열로 간주한다.</p><ul><li>concat 메서드</li></ul><p>concat은 인수로 받은 값을 그 배열의 요소로 추가하여 새로운 배열을 생성한다. 참고로 원시값도 배열에 추가할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = a.concat(b);</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// ['a', 'b', 'c', 'x', 'y', 'z']</span></span><br></pre></td></tr></table></figure><ul><li>slice 메서드</li></ul><p>일부 요소를 제거한 새로운 배열을 반환하는 메서드이다.</p><p>첫 번째 인수는 요소를 꺼낼 시작 위치를, 두 번째 인수는 요소를 꺼낼 마지막 위치를 지정한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res1 = items.slice(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res1);</span><br></pre></td></tr></table></figure><p>두 번째 인수를 생략하면 마지막 요소까지 잘라내며 음수는 끝에서 n번째 라는 의미를 갖는다.</p><ul><li>indexOf와 lastIndexOf 메서드</li></ul><p>두 메서드는 배열 안에서 인수로 지정한 값을 검색해서 가장 먼저 찾은 요소의 인덱스를 반환한다. 찾지 못하면 -1을 반환한다. 첫 번째 인수는 검색할 값을 지정하고 두 번째 인수에는 검색을 시작할 인덱스를 지정한다. 생략하면 0으로 간주한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">2</span>));    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">4</span>));    <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">2</span>, <span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>toString과 toLocaleString 메서드</li></ul><p>배열의 요소를 문자열로 변환하여 쉼표로 연결한 문자열을 반환한다. toLocaleString은 해당 지역에 맞는 언어로 지역화한 문자열로 변환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,date].toString());</span><br><span class="line"><span class="built_in">console</span>.log([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,date].toLocaleString());</span><br></pre></td></tr></table></figure><h2 id="반복-메서드"><a href="#반복-메서드" class="headerlink" title="반복 메서드"></a>반복 메서드</h2><p>반복 메서드는 모든 요소를 순회하며 특정한 작업을 수행하거나 특정 조건을 만족하는 요소를 가져올 때 사용한다. 반복 메서드의 인수로 전달한 함수는 배열의 요소마다 호출된다.</p><ul><li>forEach 메서드</li></ul><p>Array.prototype.forEach(callback: (value: T, index: number, array: T[]) =&gt; void, thisArg?: any): void<br>인수로 받은 함수를 배열의 요소별로 한 번씩 실행한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> testArray = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach 메소드는 원본 배열을 변경하지 않는다.</span></span><br><span class="line">testArray.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'['</span> + index + <span class="string">'] = '</span> + item);</span><br><span class="line">  total += item;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>함수형 프로그래밍을 할 때 for문 대신 사용할 수 있다. 하지만 for문에 비해 성능이 좋지는 않다.</p><p>또한 두 번째 인자로 this를 전달할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Counter.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// entry는 array의 배열 요소의 값</span></span><br><span class="line">  array.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">entry</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sum += entry; <span class="comment">// 2번째 인자 this를 전달하지 않으면 this === window</span></span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">  &#125;, <span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter = <span class="keyword">new</span> Counter();</span><br><span class="line">counter.add([<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(counter.count);</span><br><span class="line"><span class="built_in">console</span>.log(counter.sum);</span><br></pre></td></tr></table></figure><ul><li>map 메서드</li></ul><p>인수로 받은 함수를 배열의 요소별로 한번씩 실행하는 데 그 콜백함수의 반환값으로 새로운 배열을 생성한다. 반드시 값을 반환해야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백함수를 실행</span></span><br><span class="line"><span class="keyword">var</span> roots = a.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(item);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 위 코드의 축약표현은 아래와 같다.</span></span><br><span class="line"><span class="comment">// var roots = numbers.map(Math.sqrt);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(roots);   <span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line"><span class="comment">// map 메소드는 원본 배열은 변경하지 않는다</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [ 1, 4, 9 ]</span></span><br></pre></td></tr></table></figure><p>map의 반환값은 원본 배열과 같은 개수의 원소가 들어 있는 배열이기 때문에 메서드 체인으로 연결해서 배열 처리가 가능하다.</p><ul><li>reduce</li></ul><p>배열의 첫 번째 요소부터 마지막 요소까지 합성 곱 처리를 한다.(배열 요소 하나를 함수로 처리한 후 그 반환값을 다음 번 요소를 처리할 때 함수의 입력값으로 사용)<br>그래서 마지막 요소를 처리한 함수가 값을 반환한다.</p><p>Array.prototype.reduce<u>(callback: (state: U, element: T, index: number, array: T[]) =&gt; U, firstState?: U): U</u></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">previousValue: 이전 콜백의 반환값</span></span><br><span class="line"><span class="comment">currentValue : 배열 요소의 값</span></span><br><span class="line"><span class="comment">currentIndex : 인덱스</span></span><br><span class="line"><span class="comment">array        : 순회할 배열</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">previousValue, currentValue, currentIndex, array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(previousValue + <span class="string">'+'</span> + currentValue + <span class="string">'='</span> + (previousValue + currentValue));</span><br><span class="line">  <span class="keyword">return</span> previousValue + currentValue; <span class="comment">// 결과는 다음 콜백의 첫번째 인자로 전달된다</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열의 최대값.</span></span><br><span class="line"><span class="keyword">var</span> max = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prev &gt; cur ? prev : cur;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(max); <span class="comment">// 5: 최대값</span></span><br></pre></td></tr></table></figure><p>주의할 점은 초깃값 지정 여부에 따라 callback 함수가 처음 호출될 때 인수로 들어오는 값이 바뀌는데 지정했을 경우에는 state는 초깃값, element는 배열의 첫 번째 요소, index는 0이 된다.<br>지정하지 않을 경우에는 state는 배열의 첫 번째 요소의 값, element는 두 번째 요소의 값, index는 1이 된다.</p><p>[예제 살펴보기]</p><h2 id="유사-배열-객체"><a href="#유사-배열-객체" class="headerlink" title="유사 배열 객체"></a>유사 배열 객체</h2><p>배열은 아니지만 배열로 처리할 수 있는 개체를 유사 배열 객체라고 한다.</p><p>Arguments객체와 DOM의 getElementByTagName, getElementByName이 반환하는 Nodelist, String등이 유사 배열 객체이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">a.length = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, sum = <span class="number">0</span>; i&lt;a.length; i++) sum += a[i];</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure><p>그래서 Array.prototype.call 메서드를 이용하여 메서드들을 간접 호출할 수 있다. 하지만 concat 메서드를 제외한 나머지는 배열처럼 동작하지는 않는다.</p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ul><li>비구조화 할당</li></ul><p>우리가 디스트럭쳐링이라고 부르는 것이 바로 비구조화 할당이다. 구조화 되어 있는 배열 혹은 객체를 파괴하여 개별적인 변수에 할당하는 것이다.</p><ul><li>배열 디스트럭쳐링</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> one = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> two = arr[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> three = arr[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(one, two, three);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [one,two,three] = arr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(one, two, three);</span><br></pre></td></tr></table></figure><p>배열 디스트럭쳐링을 위해서는 할당 연산자 왼쪽에 배열 형태의 변수 리스트가 있어야 한다. 이 때 배열의 인덱스를 기준으로 할당된다.</p><ul><li>객체 디스트럭쳐링</li></ul><p>ES5에선 객체의 프로퍼티 이름을 활용하여야 변수에 할당이 가능했다. ES6에서는 객체의 각 프로퍼티를 객체로부터 추출하여 변수 리스트에 할당할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">firstName</span>: <span class="string">'Geun ho'</span>, <span class="attr">lastName</span>: <span class="string">'Jang'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> firstName = obj.firstName;</span><br><span class="line"><span class="keyword">var</span> lastName = obj.lastName;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstName, lastName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">firstName</span>: <span class="string">'Geun ho'</span>, <span class="attr">lastName</span>: <span class="string">'Jang'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; firstName, lastName &#125; = obj;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstName, lastName);</span><br></pre></td></tr></table></figure><p>객체 디스트럭처링도 마찬가지로 할당 연산자 왼쪽에 객체 형태의 변수 리스트가 필요하다. 또한 객체 디스트럭처링은 객체에서 프로퍼티 이으로 필요한 프로퍼티 값만을 추출할 수 있다.</p><p>이는 예제를 통해 살펴보도록 하자.</p><h2 id="Spread-연산자"><a href="#Spread-연산자" class="headerlink" title="Spread 연산자"></a>Spread 연산자</h2><p>Spread 연산자는 연산자의 대상 배열이나 반복 가능한 객체를 개별 요소로 분리한다. Rest 파라미터와는 다르다는 것을 주의하여야 한다.</p><ul><li>함수를 인자로 사용하는 경우</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y,z</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">  <span class="built_in">console</span>.log(z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">foo.apply(<span class="literal">null</span>, arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y,z</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">  <span class="built_in">console</span>.log(z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">foo(...arr);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;자바스크립트의-배열-활용하기&quot;&gt;&lt;a href=&quot;#자바스크립트의-배열-활용하기&quot; class=&quot;headerlink&quot; title=&quot;자바스크립트의 배열 활용하기&quot;&gt;&lt;/a&gt;자바스크립트의 배열 활용하기&lt;/h1&gt;&lt;p&gt;저~~번에 살펴봤듯이 배열은 Ar
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="JS Memo" scheme="http://rootjang92.github.io/categories/Javascript/JS-Memo/"/>
    
    
      <category term="javascript,array" scheme="http://rootjang92.github.io/tags/javascript-array/"/>
    
  </entry>
  
  <entry>
    <title>표현식과 연산자 정리</title>
    <link href="http://rootjang92.github.io/2018/12/19/expAndope/"/>
    <id>http://rootjang92.github.io/2018/12/19/expAndope/</id>
    <published>2018-12-19T07:53:59.000Z</published>
    <updated>2018-12-21T06:39:02.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="표현식과-연산자"><a href="#표현식과-연산자" class="headerlink" title="표현식과 연산자"></a>표현식과 연산자</h1><h2 id="표현식이란"><a href="#표현식이란" class="headerlink" title="표현식이란?"></a>표현식이란?</h2><p>표현식은 어떤 값이 평가되는 식을 말한다. 값이나 변수 그리고 함수 등의 값을 바탕으로 식을 계산하는 행위를 하여 값을 평가하는 것이다.<br>우리가 앞 시간에 살펴보았던 Primitive value가 가장 쉬운 표현식이다.</p><h2 id="연산자란"><a href="#연산자란" class="headerlink" title="연산자란?"></a>연산자란?</h2><p>연산자(Operator)는 표현식을 조합하여 더욱 복잡한 표현식을 만들도록 도와주는 것이다. 우리가 흔히 사용하는 더하기, 빼기 등이 그 예이다.<br>연산자는 우리가 어렸을 때 배웠던 산술식이 그대로 적용된다. (우선순위라던지 결합 법칙 이라던지)</p><h2 id="산술-연산하기"><a href="#산술-연산하기" class="headerlink" title="산술 연산하기"></a>산술 연산하기</h2><p>더하기, 빼기, 곱하기, 나누기 이런 것들이 산술 연산자다. 이것들이 자바스크립트에서는 어떻게 동작하는 지.araboza</p><ol><li>정수끼리 나누어도 부동소수점이 된다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span> / <span class="number">2</span> <span class="comment">// -&gt; 3.5</span></span><br></pre></td></tr></table></figure><p>다른 언어에서는 정수 나누기 정수는 정수값이 나온다. js는 그딴거 없다.</p><ol start="2"><li>%의 피연산자는 부동소수점이다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span> % <span class="number">4</span> <span class="comment">// -&gt; 3</span></span><br></pre></td></tr></table></figure><ol start="3"><li>+연산자는 피연사 중 하나가 문자열이면 나머지 피연산자를 문자열로 만든다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">'2month'</span> <span class="comment">// -&gt; '12month'</span></span><br></pre></td></tr></table></figure><ol start="4"><li>NaN, undefined</li></ol><h2 id="단항-연산자"><a href="#단항-연산자" class="headerlink" title="단항 연산자"></a>단항 연산자</h2><p>++는 증가연산자로 ++a, a++로 나눈다. 둘은 형태가 다르다. 전자의 경우는 a에 1을 더한 후 값을 평가하고 후자의 경우 a를 평가한 후에 1을 더한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = ++a; <span class="comment">// b = 2, a = 2</span></span><br><span class="line">c = a++ +<span class="number">2</span>; <span class="comment">// c = 4, a = 3</span></span><br></pre></td></tr></table></figure><h2 id="대입연산자"><a href="#대입연산자" class="headerlink" title="대입연산자"></a>대입연산자</h2><p>대입 연산자와 산술 이항 연산자를 조합하여 간략하게 표현할 수도 있다.</p><p>+= -&gt; a = a + b 뭐 이런식으로 말이다.</p><h2 id="Math-객체의-프로퍼티"><a href="#Math-객체의-프로퍼티" class="headerlink" title="Math 객체의 프로퍼티"></a>Math 객체의 프로퍼티</h2><p>자바스크립트는 기본적인 산술 연산과 수학 연산을 지원한다 Math 객체의 프로퍼티와 메서드를 사용하여 간단한 산술 연산을 할 수 있다.</p><h3 id="Math의-프로퍼티"><a href="#Math의-프로퍼티" class="headerlink" title="Math의 프로퍼티"></a>Math의 프로퍼티</h3><p>프로퍼티에는 여러가지가 있지만 기본적으로(사실 사용하는 것도 많지는 않다.) Math.PI를 사용하여 원주율을 사용한다.</p><h3 id="Math의-메서드"><a href="#Math의-메서드" class="headerlink" title="Math의 메서드"></a>Math의 메서드</h3><ol><li>Math.abs(x: number): number (ES1)</li></ol><p>절댓값을 반환하는 메서드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs(<span class="number">-1</span>) <span class="comment">// 1;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Math.round(x: number): number(ES1)</li></ol><p>숫자를 가장 인접한 정수로 올리거나 내림한다. (반올림)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.round(<span class="number">10.49</span>) <span class="comment">// 11;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Math.sqrt(x: number): number(ES1)</li></ol><p>양의 제곱근을 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">9</span>) <span class="comment">// 3;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>Math.ceil(x: number): number(ES1)</li></ol><p>지정된 숫자를 자신보다 큰 가장 가까운 정수로 올림한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">1.4</span>) <span class="comment">// 2;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>Math.floor(x: number): number(ES1)</li></ol><p>지정된 숫자를 자신보다 작은, 가장 가까운 정수로 내림한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(<span class="number">1.9</span>) <span class="comment">// 1;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>Math.random(): number(ES1)</li></ol><p>0~1 사이의 임의의 숫자를 반환한다. 1은 포함되지 않는다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> randomNum = <span class="built_in">Math</span>.floor((<span class="built_in">Math</span>.random() * <span class="number">10</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(randomNum);</span><br></pre></td></tr></table></figure><ol start="7"><li>Math.pow(x: number, y: number): number(ES1)</li></ol><p>첫 번째 인수를 base, 두 번째 인수를 지수로 하여 거듭제곱을 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">8</span>) <span class="comment">// 1;</span></span><br></pre></td></tr></table></figure><h3 id="주의할-점"><a href="#주의할-점" class="headerlink" title="주의할 점"></a>주의할 점</h3><p>산술 연산을 할 때에는 유효한 자릿수가 있기 때문에 어느 정도의 오차가 발생할 수 있다.</p><h2 id="문자열"><a href="#문자열" class="headerlink" title="문자열"></a>문자열</h2><ol><li>문자열 연결하기</li></ol><p>+연산자는 피연사자가 모두 문자열이면 문자열로 연결한다. 하나만 문자열일 때는 (혹은 문자열로 변환할 수 있을 때는) 다른 피연사자의 타입을 문자열로 바꾼 다음 연결한다.</p><ol start="2"><li>문자열 메서드</li></ol><p>String 래퍼 객체는 문자열을 처리하기 위해 프로퍼티와 메서드를 보유하고 있는 객체이다. 하지만 굳이 생성자를 사용하지 않아도 문자열이 일시적으로 래퍼 객체로 변환되기 때문에 메서드를 사용할 수 있다.</p><ol start="2"><li><ol><li>String.prototype.charAt(pos: number): string(ES1)</li></ol></li></ol><p>매개 변수로 전달된 인덱스 번호에 해당하는 문자 를 반환한다. 지정된 인덱스를 벗어난 경우 빈문자열을 반환한다.</p><p><img src="https://poiemaweb.com/img/index.png" alt="charAt"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(str.charAt(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><ol start="2"><li>String.prototype.concat(…strings: string[]): string(ES3)</li></ol></li></ol><p>매개변수로 전달된 1개 이상의 문자열과 연결하여 새로운 문자열을 반환한다.</p><p>+연산자를 사용하는 것이 더 빠르다.(지금은 뭐..)</p><ol start="2"><li><ol start="3"><li>String.prototype.indexOf(searchString: string, fromIndex=0): number(ES1)</li></ol></li></ol><p>매개변수로 전달된 문자열을 대상으로 검색하여 처음 발견될 곳에 index를 반환한다. 없을 경우 -1을 반환한다.</p><ol start="2"><li><ol start="4"><li>String.prototype.lastIndexOf(searchString: string, fromIndex=this.length-1): number(ES1)</li></ol></li></ol><p>마지막으로 발견된 곳의 index를 반환한다. 발견하지 못한 경우 -1을 반환한다.</p><ol start="2"><li><ol start="5"><li>String.prototype.replace(searchValue: string | RegExp, replaceValue: string): string(ES3)</li></ol></li></ol><p>첫 번째 인자로 전달된 문자열 또는 정규표현식을 대상 문자열에서 검색하여 인자에 전달된 문자열로 대체한다. 원본 문자열은 변경되지 않고 새로운 문자열을 반환한다. 복수일 경우 첫 번째 문자열로 대체된다.</p><ol start="2"><li><ol start="6"><li>String.prototype.split(separator: string | RegExp, limit?: number): string[] (ES3)</li></ol></li></ol><p>첫 번째 인자에 전달된 문자열 또는 정규표현식을 대상 문자열에서 검색하여 문자열을 구분한 후 분리된 각 문자열로 이루어진 배을 반환한다. 원본 문자열은 변경되지 않는다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'How are you doing?'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> splitStr = str.split(<span class="string">' '</span>);</span><br><span class="line"><span class="built_in">console</span>.log(splitStr);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"></span><br><span class="line">splitStr = str.split();</span><br><span class="line"><span class="built_in">console</span>.log(splitStr);</span><br><span class="line"></span><br><span class="line">splitStr = str.split(<span class="string">''</span>);</span><br><span class="line"><span class="built_in">console</span>.log(splitStr);</span><br><span class="line"></span><br><span class="line">splitStr = str.split(<span class="string">' '</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(splitStr);</span><br><span class="line"></span><br><span class="line">splitStr = str.split(<span class="string">'o'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(splitStr);</span><br></pre></td></tr></table></figure><ol start="2"><li><ol start="7"><li>String.prototype.substring(start: number, end=this.length): string(ES3)</li></ol></li></ol><p>첫 번째 인자에 전달된 인덱스의 문자부터 두 번째 인자에 전달된 인덱스에 해당하는 문자의 바로 이전 문자까지 반환한다.</p><p><img src="https://poiemaweb.com/img/substring.png" alt="substring"></p><p>첫 번째 인수가 두번째 인수가 더 클 경우 두 인ㅅ는 교환되고 두 번째 인수가 생략되면 문자열 끝까지 반환한다. 인수가 0보다 작거나 NaN이면 0으로 취급하고 인수가 문자열의 길이보다 크면 문자열의 길이로 인식된다.</p><h2 id="동일-연산자와-일치-연산자"><a href="#동일-연산자와-일치-연산자" class="headerlink" title="동일 연산자와 일치 연산자"></a>동일 연산자와 일치 연산자</h2><p>둘의 차이는 값만 비교한다는 것과 값과 타입을 같이 비교한다는 점이다.</p><h2 id="논리-연산자"><a href="#논리-연산자" class="headerlink" title="논리 연산자"></a>논리 연산자</h2><p>&amp;&amp;(논리곱), ||(논리합), !(부정)이 있으며 뜻을 한 번 풀어보면,</p><p>a &amp;&amp; b는 a와 b가 모두 true면 true가 된다. 여기서 a가 false값이면 b와 상관없이 false가 된다. a를 평가한 값이 true면 b의 값으로 결정된다.</p><p>a || b는 a또는 b 중 하나가 true면 true이다. a가 true면 b를 평가하지 않는다. a를 평가한 값이 false면 b의 값이 된다.</p><h2 id="조건-연산자"><a href="#조건-연산자" class="headerlink" title="조건 연산자"></a>조건 연산자</h2><p>삼항 연산자로 간단히 표현할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0은 false로 취급된다.</span></span><br><span class="line"><span class="keyword">var</span> kind = num ? (num &gt; <span class="number">0</span> ? <span class="string">'양수'</span> : <span class="string">'음수'</span>) : <span class="string">'영'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(kind); <span class="comment">// 양수</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;표현식과-연산자&quot;&gt;&lt;a href=&quot;#표현식과-연산자&quot; class=&quot;headerlink&quot; title=&quot;표현식과 연산자&quot;&gt;&lt;/a&gt;표현식과 연산자&lt;/h1&gt;&lt;h2 id=&quot;표현식이란&quot;&gt;&lt;a href=&quot;#표현식이란&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="JS Memo" scheme="http://rootjang92.github.io/categories/Javascript/JS-Memo/"/>
    
    
      <category term="Javasciprt, expression, operator" scheme="http://rootjang92.github.io/tags/Javasciprt-expression-operator/"/>
    
  </entry>
  
  <entry>
    <title>데이터 타입</title>
    <link href="http://rootjang92.github.io/2018/12/13/dataType/"/>
    <id>http://rootjang92.github.io/2018/12/13/dataType/</id>
    <published>2018-12-13T08:28:02.000Z</published>
    <updated>2018-12-13T08:51:02.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="데이터-타입"><a href="#데이터-타입" class="headerlink" title="데이터 타입"></a>데이터 타입</h1><p>데이터 타입은 프로그래밍 언어에서 사용할 수 있는 데이터의 종류들이자 기본적인 구성 요소이다. 변수에서 살펴봤듯이 자바스크립트에서는 데이터 타입이 동적 할당된다.<br>그래서 자바스크립트는 동적 타입 언어라고 부른다.</p><p>자바스크립트는 크게 primitive type(원시타입), Object type으로 나눈다.</p><p>원시 타입에는 Number, String, boolean, undefined, null, Symbol(ES6)가 있다.</p><p>그 외에는 모두 Object(이하 객체)이다.</p><h2 id="원시-타입"><a href="#원시-타입" class="headerlink" title="원시 타입"></a>원시 타입</h2><p>그래서 원시 타입은 immutable하고 pass-by-value(값에 의한 전달)의 속성을 갖는다.</p><p>pass-by-value는 값이 복사되어 전달된다는 의미이다. 메모리의 Stack 영역에 고정된 메모리 영역을 점유하여 저장된다.</p><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>c나 java같은 경우는 int, long, float, double 등 여러가지의 유형이 존재하지만 자바스크립트는 그런거 없다. 그냥 범위 내에서 다 때려박는다.</p><p>-(253 -1) 와 253 -1 사이의 숫자값에서는 그냥 마음대로 쓴다. 즉 모든 수를 <strong>실수</strong> 처리 한다.</p><p>추가적인 개념으로 Infinity, -Infinity, NaN이 있다.</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>텍스트 데이터를 지정할 때 사용한다. 문자열 역시 변경 불가능하다.</p><pre><code>var str = &apos;Hello&apos;;str = &apos;world&apos;;</code></pre><p>변경되는데????</p><p>Hello와 world는 모두 메모리에 존재하고 str이 가리키는 것이 바뀌었을 뿐이다.</p><p>또한 string은 유사 배열이다</p><pre><code>var str = &apos;string&apos;;// 문자열은 유사배열이다.for (var i = 0; i &lt; str.length; i++) {  console.log(str[i]);}// 문자열을 변경할 수 없다.str[0] = &apos;S&apos;;console.log(str);</code></pre><p>문자열은 배열처럼 인덱스에 접근할 수 있다.</p><h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p>선언은 되었지만 값을 할당하지 않은 변수에 접근하거나 존재하지 않는 객체 프로퍼티에 접근할 경우 undefined가 할당된다.</p><h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>null은 변수에 값이 없다는 것을 의미한다. 메모리 주소의 참조 정보를 제거한다.</p><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol은 ES6에서 추가된 원시 값으로 자기 자시능ㄹ 제외한 그 어떤 값과도 다른 유일무이한 값이다.<br>그래서 충돌 위험이 없이 객체의 프로퍼티 키를 만들기 위해 사용한다.</p><pre><code>var key = Symbol(&apos;no1&apos;);console.log(typeof key); // no1var obj = {};obj[key] = &apos;value&apos;;console.log(obj[key]); // value</code></pre><h2 id="Object-Type"><a href="#Object-Type" class="headerlink" title="Object Type"></a>Object Type</h2><p>객체는 모든 것을 포함하는 존재이다. 그래서 원시 타입을 제외한 모든 것을 말한다. 또한 객체는 pass-by-reference(참조에 의한 전달)이다.</p><p>pass-by-reference는 객체의 모든 값이 참조로 처리되는 것을 말한다. 프로퍼티를 변경, 추가 가능한 mutable이라고 할 수 있다.</p><p>그 이유는 객체 타입은 동적으로 변화할 수 있는 메모리라 메모리의 공간을 얼마나 할당해야 하는 지 예측이 힘들기 때문에 메모리의 Heap 영역에 저장되어 메모리 공간을 확보한다.</p><h2 id="템플릿-리터럴"><a href="#템플릿-리터럴" class="headerlink" title="템플릿 리터럴"></a>템플릿 리터럴</h2><p>ES6에서는 이스케이프 문자 등의 불편함을 개선하고자 템플릿 리터럴을 추가했다. 이를 사용하여 표현식을 문자열에 추가하거나 여러 줄로 문자열을 한 번에 작성할 수 있다.</p><pre><code>const template = `템플릿 리터럴은 &apos;작은따옴표(single quotes)&apos;과 &quot;큰따옴표(double quotes)&quot;를 혼용할 수 있다.`;console.log(`1 + 1 = ${1 + 1}`);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;데이터-타입&quot;&gt;&lt;a href=&quot;#데이터-타입&quot; class=&quot;headerlink&quot; title=&quot;데이터 타입&quot;&gt;&lt;/a&gt;데이터 타입&lt;/h1&gt;&lt;p&gt;데이터 타입은 프로그래밍 언어에서 사용할 수 있는 데이터의 종류들이자 기본적인 구성 요소이다. 변
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="JS Memo" scheme="http://rootjang92.github.io/categories/Javascript/JS-Memo/"/>
    
    
      <category term="js, js data type" scheme="http://rootjang92.github.io/tags/js-js-data-type/"/>
    
  </entry>
  
  <entry>
    <title>자바스크립트의 변수</title>
    <link href="http://rootjang92.github.io/2018/12/12/Variable/"/>
    <id>http://rootjang92.github.io/2018/12/12/Variable/</id>
    <published>2018-12-12T07:05:42.000Z</published>
    <updated>2018-12-13T08:26:27.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="자바스크립트의-변수-비교해보기"><a href="#자바스크립트의-변수-비교해보기" class="headerlink" title="자바스크립트의 변수 비교해보기."></a>자바스크립트의 변수 비교해보기.</h1><p><strong>변수</strong>는 어떠한 프로그래밍 언어든지 가장 중요한 요소 중 하나이다.</p><h2 id="변수란"><a href="#변수란" class="headerlink" title="변수란?"></a>변수란?</h2><p>값을 담기 위해 사용하는 것으로 데어터에 고유한 이름(식별자)를 붙여 명시한 것이다. ES5에선 ‘var’ 키워드를 사용한다.</p><p>즉 변수는 키워드를 사용하여 선언하고 할당 연산자를 이용하여 값을 할당하고 값을 참조하여 사용한다.</p><pre><code>var a = 1;</code></pre><p>그렇다면 왜 저장을 할까? 그냥 쓰면 되지?! (실제로 받아본 질문)</p><p>결국 <strong>재사용성</strong>이다. 일정 기간 유지할 필요가 있는, 즉 지속적으로 사용할 값은 저장해 놓은 후 계속 참조하는 게 효율성이 더 좋지 않을까??</p><h2 id="명명-규칙"><a href="#명명-규칙" class="headerlink" title="명명 규칙."></a>명명 규칙.</h2><p>그렇다면 변수를 의미있게 사용하려면 우선 변수명에 의미를 담아야 한다. 예를 들어 변수에 원주율을 담는다고 했을 때, 변수명을 단순히 만들면 모르는 사람은 이게 뭔가 싶을 것이다.</p><pre><code>var PI = 3.14;</code></pre><p>이렇게 하면 ‘아 이게 원주율 변수구나!’ 하지 않을까 싶다.</p><p>또한 다른 명명 규칙이 있는데 변수명 시작에는 영문자, underscore(_), 달러표시($)가 와야 한다. 또한 대소문자를 구별한다는 것도 중요하다.</p><h2 id="var의-문제들"><a href="#var의-문제들" class="headerlink" title="var의 문제들"></a>var의 문제들</h2><p>우선 var 키워드를 사용한 변수 선언은 중복 선언이 가능하다.</p><pre><code>var x = 1;console.log(x);var x = 100;console.log(x);</code></pre><p>위 예제를 살펴보면 변수의 값을 덮어쓴다는 것을 알 수 있을 것이다.<br>그렇기 때문에 변수명을 확실하게 짓지 않거나 이런식으로 x로 지어버리면 <strong>의도치 않은</strong> 변수의 값 변경이 일어날 수 있다.</p><p>두 번째로 암묵적으로 전역 변수가 선언된다.</p><pre><code>x = 1;</code></pre><p>이런 식으로 값을 지정하면 자바스크립트 엔진이 전역 변수로 만든다.</p><p>세 번째는 동적 타이핑이다. 자바스크립트는 다른 언어와 달리 변수의 타입을 선언하지 않고 값이 할당되었을 때 자바스크립트 엔진이 동적으로 값의 타입을 결정한다.</p><p>마지막으로 변수 호이스팅이 발생한다. 호이스팅이란 var, function 선언문이 선언되지 않았지만 모든 선언문의 Scope의 선두로 옮겨진 것처럼 동작하는 특성이다.</p><p>그 전에 변수는 선언, 초기화, 할당의 순서로 발생하는 데 선언과 초기화가 동시에 이루어진다. 즉 선언 후에는 값을 할당하지 않아도 undefined로 초기화가 된다.</p><pre><code>var x;console.log(foo);var foo = 123;console.log(foo);{  var foo = 456;}console.log(foo);</code></pre><p>자바스크립트는 함수 레벨 스코프를 갖는다. 따라서 예제에서 봤듯이 foo의 값은…</p><h2 id="let과-const의-등장"><a href="#let과-const의-등장" class="headerlink" title="let과 const의 등장"></a>let과 const의 등장</h2><p>앞서 봤듯이 var는 변수 선언 규칙이나 할당 등이 매우 자유롭지만 그만큼 단점도 많다. 그래서 ES6에서 등장한 키워드가 let과 const이다.</p><p>우선 let과 const는 블록 레벨 스코프를 갖는다. 앞에서 var는 함수 레벨 스코프를 갖는다고 하였다. 위 예제를 let으로 바꾸어 보면,</p><pre><code>let foo = 123;{  let foo = 456;  let bar = 456;}console.log(foo);console.log(bar);</code></pre><p>분명한 차이를 느낄 것이다. 에러가 나기 때문이다. 블록 내에 선언한 foo와 bar는 블록 안에서만 유효한 변수이다.</p><p>또한 중복 선언이 금지된다. let 키워드는 중복 선언시 문법에러가 발생하게 된다.</p><h2 id="호이스팅-문제"><a href="#호이스팅-문제" class="headerlink" title="호이스팅 문제"></a>호이스팅 문제</h2><p>자바스크립트는 기본적으로 모든 선언을 호이스팅한다. 하지만 let은 선언 이전에 참조하면 참조에러가 발생한다. 그 이유는 바로 <strong>일시적 사각지대</strong> 이다.</p><p><img src="https://poiemaweb.com/img/let-lifecycle.png" alt="TDZ"></p><p>var 키워드는 선언과 초기화가 한 번에 이루어지지만 let은 선언 후 일시적 사각지대에 빠지게 된다.(즉 선언과 초기화가 분리되어 진행된다.)</p><pre><code>let foo = 1; // 전역 변수{  console.log(foo); // ReferenceError: foo is not defined  let foo = 2; // 지역 변수}</code></pre><p>전역 변수 foo가 출력될 것 같지만 참조에러가 발생한다. 블록 레벨 스코프에 이한 호이스팅이 발생하기 때문이다.</p><h2 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h2><pre><code>var funcs = [];// 함수의 배열을 생성하는 for 루프의 i는 전역 변수다.for (var i = 0; i &lt; 3; i++) {  funcs.push(function () { console.log(i); });}// 배열에서 함수를 꺼내어 호출한다.for (var j = 0; j &lt; 3; j++) {  funcs[j]();}</code></pre><p>실습을 통해 답이 어떻게 나오나 알아보도록 하자</p><pre><code>var funcs = [];// 함수의 배열을 생성하는 for 루프의 i는 for 루프의 코드 블록에서만 유효한 지역 변수이면서 자유 변수이다.for (let i = 0; i &lt; 3; i++) {  funcs.push(function () { console.log(i); });}// 배열에서 함수를 꺼내어 호출한다for (var j = 0; j &lt; 3; j++) {  console.dir(funcs[j]);  funcs[j]();}</code></pre><p>지금은 아 이렇구나 하고 넘어가면 된다. ㅎㅎ..</p><h2 id="const는"><a href="#const는" class="headerlink" title="const는?"></a>const는?</h2><p>const는 보통 상수에 사용한다. 그래서 let은 재할당이 자유로우나 const는 재할당이 금지되어 있다. 또한 const는 선언과 동시에 할당이 이루어져야 한다.</p><h2 id="const와-객체"><a href="#const와-객체" class="headerlink" title="const와 객체"></a>const와 객체</h2><p>const는 재할당이 금지되어 있기 때문에 객체에 대한 참조를 변경하지 못할 것 같지만, 객체의 프로퍼티는 <strong>보호되지 않는다.</strong></p><pre><code>const user = {name: &apos;Jang&apos; };user.name = &apos;Son&apos;;console.log(user);</code></pre><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>ES6를 사용하면 var 쓰지 말자!<br>재할당은 let!<br>재할당이 필요없는 원시 타입이나 객체 타입은 const!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;자바스크립트의-변수-비교해보기&quot;&gt;&lt;a href=&quot;#자바스크립트의-변수-비교해보기&quot; class=&quot;headerlink&quot; title=&quot;자바스크립트의 변수 비교해보기.&quot;&gt;&lt;/a&gt;자바스크립트의 변수 비교해보기.&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;변수&lt;/
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="JS Memo" scheme="http://rootjang92.github.io/categories/Javascript/JS-Memo/"/>
    
    
      <category term="js,var,let,const" scheme="http://rootjang92.github.io/tags/js-var-let-const/"/>
    
  </entry>
  
  <entry>
    <title>이터레이션과 for-of</title>
    <link href="http://rootjang92.github.io/2018/11/28/iteration/"/>
    <id>http://rootjang92.github.io/2018/11/28/iteration/</id>
    <published>2018-11-28T01:40:40.000Z</published>
    <updated>2018-11-28T01:51:23.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="이터레이션-프로토콜과-for-of"><a href="#이터레이션-프로토콜과-for-of" class="headerlink" title="이터레이션 프로토콜과 for-of"></a>이터레이션 프로토콜과 for-of</h1><h2 id="iteration-protocol"><a href="#iteration-protocol" class="headerlink" title="iteration protocol"></a>iteration protocol</h2><p>우선 이터러블(iterable)에 대한 개념부터 알아보자. 이터러블은 <strong>순회 가능한 자료구조</strong>를 뜻한다. Symbol.iterator를 프로퍼티 키로 사용한 메서드를 구현함으로써 순회 가능한 자료구조가 된다.</p><p>그럼 어터레이터(iterator)는 무엇일까? 이터러블 메서드는 이터레이터를 반환하는데 여기서 이터레이터는 요소를 탐색하기 위한 포인터이다.<br>(next() 메서드를 갖는 객체) next() 메서드는 value, done 프로퍼티를 갖는 객체를 반환해서 이터러블 객체를 순회할 수 있다.</p><p>그래서 next() 메서드를 통해 데이터에 순차적으로 접근할 수 있는 방법을 보여주는 것이다.</p><pre><code>const iterable = [1,2,3];const iterator = iterable[Symbol.iterator]();console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());// for문 으로 순회for (;;) {  const res = iterator.next();  console.log(res);  if (res.done) break;}</code></pre><h2 id="for-of"><a href="#for-of" class="headerlink" title="for-of"></a>for-of</h2><p>for-of는 이터러블 객체를 순회한다. next() 메서드를 호출하며 반환하는 객체의 done 프로퍼티가 true값이 될 떄까지 반복된다.</p><pre><code>for (const val of [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]) {  console.log(val);}// 문자열for (const val2 of &apos;abc&apos;) {  console.log(val2);}// Mapfor (const [key, value] of new Map([&apos;a&apos;,&apos;1&apos;],[&apos;b&apos;,&apos;2&apos;],[&apos;c&apos;,&apos;3&apos;])) {  console.log(`key : ${key} value: ${value}`);}// Setfor (const val3 of new Set([1,2,3,])) {  console.log(val3);}</code></pre><h2 id="커스텀-이터러블"><a href="#커스텀-이터러블" class="headerlink" title="커스텀 이터러블"></a>커스텀 이터러블</h2><p>이터레이션 프로토콜을 지킨다면 객체도 이터러블로 만들 수 있다. 밑 예제는 피보나치 수열을 이터러블 객체로 구현해본 것이다.</p><pre><code>const fibonacci = {  [Symbol.iterator]() {    let [prev, curr] = [0,1];    let step = 0;    const maxStep = 5;    return {      next() {        [prev,curr] = [curr, prev + curr];        return { value: curr, done: step++ &gt;= maxStep };      }    };  }};for (const num of fibonacci) {  console.log(num);}const arr = [...fibonacci];console.log(arr);const [first, second, ...rest] = fibonacci;console.log(first,seond,rest);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;이터레이션-프로토콜과-for-of&quot;&gt;&lt;a href=&quot;#이터레이션-프로토콜과-for-of&quot; class=&quot;headerlink&quot; title=&quot;이터레이션 프로토콜과 for-of&quot;&gt;&lt;/a&gt;이터레이션 프로토콜과 for-of&lt;/h1&gt;&lt;h2 id=&quot;i
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES6" scheme="http://rootjang92.github.io/categories/Javascript/ES6/"/>
    
    
      <category term="js,javascript, iteration, for of" scheme="http://rootjang92.github.io/tags/js-javascript-iteration-for-of/"/>
    
  </entry>
  
  <entry>
    <title>프로미스</title>
    <link href="http://rootjang92.github.io/2018/11/26/es6Promise/"/>
    <id>http://rootjang92.github.io/2018/11/26/es6Promise/</id>
    <published>2018-11-26T02:42:03.000Z</published>
    <updated>2018-11-26T03:01:55.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-Promise"><a href="#ES6-Promise" class="headerlink" title="ES6 Promise"></a>ES6 Promise</h1><p>자바스크립트는 비동기 처리 방법 중 하나로 콜백 함수를 사용하는 데, 가독성 측면에서 좋지 않고 예외 처리가 힘들다.</p><p>비동기식 처리 모델은 task를 병렬로 수행하기 때문에 task가 종료되지 않아도 다음 task를 수행한다. 이후 서버로부터 데이터가 응답되면 이벤트가 발생하게 되고 eventHandler가 데이터를 가지고 수행할 task를 계속 수행하게 된다.</p><p>DOM 이벤트, Timer 함수, Ajax 요청 등이 그 예이다.</p><p>하지만 병렬로 처리하기 때문에 블로킹이 되지 않아서 콜백 함수를 통해 순서를 보장하는데 그 과정에서 콜백함수가 중첩되어 callback Hell이 발생하게 된다.</p><p>비동기 처리 함수의 콜백 함수는 해당 이벤트가 발생하면 이벤트 큐로 이동한 후 호출스택이 비워졌을 때, 호출 스택으로 이동되어 실해된다.</p><p>setTimeout 함수의 콜백 함수는 이벤트 큐로 이동한 후에 호출 스택이 비워졌을 때 호출 스택으로 이동되어 실행되는데 이 때 setTimeout은 호출 스택에서 제거된 상태다. 결국 호출해봤자 말짱도루묵이라는 소리가 된다. (호출 스택이 비워져 아무리 함수를 호출해도 없어져 버린다.)</p><h2 id="프로미스의-생성"><a href="#프로미스의-생성" class="headerlink" title="프로미스의 생성"></a>프로미스의 생성</h2><p>Promise는 생성자 함수를 통해 인스턴스화 한다. resolve와 reject 함수를 인자로 전달받는다.</p><p>프로미스의 상태 정보는 fulfilled(비동기 처리 성공), rejected(비동기 처리 실패)가 있다.</p><p>또 후속 처리 메서드에는 then(두 개의 콜백 함수를 인자로 전달받아 성공, 실패 시 호출되도록 한다.), catch(예외처리, then 메서드의 에러가 발생하면 호출)</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;Promise example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;Promise Example&lt;/h1&gt;  &lt;pre id=&quot;result&quot;&gt;&lt;/pre&gt;  &lt;script&gt;  function get(url) {    return new Promise((resolve, reject) =&gt; {      const xhr = new XMLHttpRequest();      xhr.onreadystatechange = function() {        if (xhr.readyState === XMLHttpRequest.DONE) {          if (xhr.status === 200) {            resolve(xhr.response);          } else {            reject(&apos;Error&apos; + xhr.status);          }        }      };      xhr.open(&apos;GET&apos;, url);      xhr.send();    });  }  const url = &apos;http://jsonplaceholder.typicode.com/posts&apos;;  //  get(url).then(  //    result =&gt; document.getElementById(&apos;result&apos;).innerHTML = result,  //    error =&gt; console.log(error)  //  );  get(`${url}/1`)  .then(result1 =&gt; get(`${url}?userID=${JSON.parse(result1).userID}`))  // id가 1인 포스트 작성자의 아이디로 작성된 모든 포스트 검색  .then(result2 =&gt; document.getElementById(&apos;result&apos;).innerHTML = result2)  .catch(error =&gt; console.log(error));  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="프로미스-체이닝"><a href="#프로미스-체이닝" class="headerlink" title="프로미스 체이닝"></a>프로미스 체이닝</h2><p>비동기 함수의 처리 결과에 따라 다른 비동기 함수를 호출해야 할 경우 중첩을 방지하고 후속 처리 메서드를 체이닝하여 여러 개의 프로미스를 연결할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6-Promise&quot;&gt;&lt;a href=&quot;#ES6-Promise&quot; class=&quot;headerlink&quot; title=&quot;ES6 Promise&quot;&gt;&lt;/a&gt;ES6 Promise&lt;/h1&gt;&lt;p&gt;자바스크립트는 비동기 처리 방법 중 하나로 콜백 함수를 사용하
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES6" scheme="http://rootjang92.github.io/categories/Javascript/ES6/"/>
    
    
      <category term="javascript, promise" scheme="http://rootjang92.github.io/tags/javascript-promise/"/>
    
  </entry>
  
  <entry>
    <title>ES6 Class</title>
    <link href="http://rootjang92.github.io/2018/11/22/es6class/"/>
    <id>http://rootjang92.github.io/2018/11/22/es6class/</id>
    <published>2018-11-22T02:07:56.000Z</published>
    <updated>2018-11-22T03:02:05.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Class에-대하여"><a href="#Class에-대하여" class="headerlink" title="Class에 대하여"></a>Class에 대하여</h1><p>원래 자바스크립트는 <strong>프로토타입 기반 객체지향 언어</strong>이다.</p><a href="https://rootjang92.github.io/2018/09/05/jsprototype/">프로토타입이란?</a><p>그래서 프로토타입 체인, 클로저를 이용하여 class없이 상속과 캡슐화 등을 구현할 수 있다.</p><p><strong>프로토타입 예제</strong></p><pre><code>var Person = (function () {  function Person(name) {    this._name = name;  }  Person.prototype.sayHi = function() {    console.log(&apos;Hi! &apos; + this._name)  };  return Person;}());var me = new Person(&apos;Jang&apos;);me.sayHi();console.log(me instanceof Person);</code></pre><p>Person 생성자 함수가 new 생성자로 객체를 생성하면 [[prototype]]에 의해 Person.prototype에 있는 sayHi() 함수를 불러 올 수 있다.</p><h2 id="그렇다면-class를-왜"><a href="#그렇다면-class를-왜" class="headerlink" title="그렇다면 class를 왜?"></a>그렇다면 class를 왜?</h2><p>클래스 기반에 언어를 익힌 사람들에게 편리성을 제공하기 위해 ES6에서는 class라는 <strong>함수</strong>를 만들었다.</p><p>위 예제를 class로 정의한다면</p><pre><code>class Person {  constructor(name) {    this._name = name;  }  sayHi() {    console.log(`Hi! ${this._name}`);  }}const me = new Person(&apos;Jang&apos;);me.sayHi();console.log(me instanceof Person);</code></pre><p>중요한 점은 class는 표현식으로 정의하는 것을 자제해야 하는데 클래스 표현식에서 사용한 클래스 이름은 외부에서 접근할 수 없기 때문이다.</p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>constructor는 인스턴스를 생성하고 클래스 프로퍼티를 초기화하기 위한 메서드이다. 클래스 내에 한 개만 존재하며 new 연산자를 이용해 호출한다.<br>또한 생략이 가능하며 생략 시 빈 객체가 생성된다. 결국 클래스 프로퍼티를 선언하려면 인스턴스를 생성하고 클래스 프로퍼티를 동적으로 할당해줘야 한다.</p><pre><code>class Foo {}const foo = new Foo();console.log(foo) // ???foo.num = 1;console.log(foo);</code></pre><h2 id="클래스-프로퍼티"><a href="#클래스-프로퍼티" class="headerlink" title="클래스 프로퍼티"></a>클래스 프로퍼티</h2><p>클래스 몸체에는 메서드만 선언할 수 있기 때문에 클래스 프로퍼티는 <strong>반드시</strong> constructor 안에서 선언과 초기화를 진행해야 한다.<br>이 클래스 프로퍼티는 this에 바인딩 된다. 그러면서 클래스 프로퍼티는 생성할 인스턴스의 프로퍼티가 되고 클래스 외부에서 언제나 참조가 가능하게 된다.<br>주의할 점은 접근 제한자를 지원하지 않는다.</p><h2 id="호이스팅"><a href="#호이스팅" class="headerlink" title="호이스팅"></a>호이스팅</h2><p>클래스는 let, const 처럼 호이스팅 되지 않는 것처럼 동작한다.(TDZ) 선언문 전에 참조하면 참조 에러가 발생한다.<br>여기서 알 수 있는 것은 클래스는 결국 함수고 함수 표현식처럼 동작한다는 것이다.</p><p>{$ link TDZ <a href="https://github.com/wonism/TIL/blob/master/front-end/javascript/tdz.md%}" target="_blank" rel="noopener">https://github.com/wonism/TIL/blob/master/front-end/javascript/tdz.md%}</a></p><h2 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter, setter"></a>getter, setter</h2><p>getter는 클래스 프로퍼티에 접근할 때마다 클래스 프로퍼티의 값을 조작해야 할 때 사용한다. get 키워드를 사용하여 정의하며 메서드 이름은 클래스 프로퍼티 이름처럼 사용한다. (참조 형식) 무언가를 얻을 때 사용하기 떄문에 반드시 반환값이 있어야 한다.</p><pre><code>class Foo {  constructor(arr = []) {    this._arr = arr;  }  get firstElem() {    return this._arr.length ? this._arr[0] : null;  }}const foo = new Foo([1,2]);console.log(foo.firstElem); // ???</code></pre><p>setter는 클래스 프로퍼티에 값을 할당할 때 클래스 프로퍼티 값을 조작해야 할 때 사용한다. set 키워드를 사용하여 정의하며 마찬가지로 메서드 이름은 클래스 프로퍼티 이름처럼 사용할 수 있다. setter는 호출이 아니라 값을 할당하는 것이기 때문에 메서드가 호출된다.</p><pre><code>class Foo {  constructor(arr = []) {    this._arr = arr;  }  get firstElem() {    return this._arr.length ? this._arr[0] : null;  }  set firstElem(elem) {    this._arr = [elem, ...this._arr];  }}const foo = new Foo([1,2,3]);foo.firstElem = 100;console.log(foo.firstElem);</code></pre><h2 id="static-메서드"><a href="#static-메서드" class="headerlink" title="static 메서드"></a>static 메서드</h2><p>정적 메서드란 인스턴스에 따라 달라지지 않는 메서드를 말한다. static 키워드를 사용하며 클래스 이름으로 호출한다. 인스턴스에 따라 달라지지 않기 때문에 클래스의 인스턴스를 생성하지 않아도 호출이 가능하다.</p><pre><code>class Foo {  constructor(prop) {    this.prop = prop;  }  static staticMethod() {    return &apos;staticMethod&apos;;  }  prototypeMethod() {    return this.prop;  }}console.log(Foo.staticMethod());const foo = new Foo(123);console.log(foo.staticMethod()); // TypeError</code></pre><p>하지만 인스턴스를 호출할 수 없기 때문에 this를 사용할 수 없다. 주로 Math 객체의 메서드처럼 애플리케이션 전역에서 사용할 유틸리티 함수를 생성할 때 주로 사용한다.</p><p>프로토타입의 개념으로 살펴보자면 staticMethod는 Foo 생성자 함수의 메서드이고 prototypeMethod는 프로토타입 객체의 메서드이다. 따라서 foo 객체는 [[prototype]]에 의해서 prototype 객체 메서드를 참조할 수는 있지만(프로토타입 체인) Foo 생성자 함수의 메서드는 참조할 수 없다.</p><h2 id="클래스-상속"><a href="#클래스-상속" class="headerlink" title="클래스 상속"></a>클래스 상속</h2><p>extends 키워드는 부모 클래스를 상속받는 자식 클래스를 정의할 때 사용한다.</p><pre><code>class Circle {  constructor(radius) {    this.radius = radius;  }  getDiameter() {    return 2 * this.radius;  }  getPerimeter() {    return 2 * Math.PI * this.radius;  }  getArea() {    return Math.PI * Math.pow(this.radius,2);  }}class Cylinder extends Circle {  constructor(radius, height) {    super(radius);    this.height = height;  }  getArea() {    return (this.height * super.getPerimeter()) + (2 * super.getArea());  }  getVolume() {    return super.getArea() + this.height;  }}const cylinder = new Cyliner(2, 10);console.log(cylinder.getDiameter());console.log(cylinder.getPerimeter());//더 찍어보세요!</code></pre><h3 id="오버라이딩과-오버로딩"><a href="#오버라이딩과-오버로딩" class="headerlink" title="오버라이딩과 오버로딩"></a>오버라이딩과 오버로딩</h3><p>오버라이딩은 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식이다. 오버로딩은 매개변수의 타입 또는 개수가 다르지만 같은 이름의 메서드를 구현하고 매개변수에 의해 메서드를 구별하여 호출하는 방식이다. JS에서는 오버로딩 자체는 지원하지 않고 arguments 객체를 사용하여 구현한다.</p><p>클래스 상속 역시 프로토타입 체이닝으로 구현되어 있기 때문에 부모 클래스의 메서드를 자식 클래스가 사용할 수 있다.</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>여기서 사용된 super 키워드는 부모 클래스를 참조하거나 constructor를 호출할 때 사용하는 키워드다. 부모 클래스의 인스턴스를 호출할 수도 있다. 또한 super를 사용하지 않으면 자식 클래스는 이게 뭔지 알 수 없기 때문에 this를 사용할 수 없다.</p><h3 id="static-메서드와-prototype-메서드의-상속"><a href="#static-메서드와-prototype-메서드의-상속" class="headerlink" title="static 메서드와 prototype 메서드의 상속"></a>static 메서드와 prototype 메서드의 상속</h3><p>자식 클래스의 <strong>proto</strong>는 부모 클래스이다. (프로토타입 체인) 그렇기 때문에 super 키워드를 이용하여 자식 클래스의 정적 메서드에서 부모 클래스의 정적 메서드도 호출할 수 있다. 하지만 프로토타입 메서드에서는 정적메서드를 호출할 수 없다.<br>자식 클래스의 인스턴스 자체로는 프로토타입 체인으로 정적 메서드를 참조할 수 없기 때문이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Class에-대하여&quot;&gt;&lt;a href=&quot;#Class에-대하여&quot; class=&quot;headerlink&quot; title=&quot;Class에 대하여&quot;&gt;&lt;/a&gt;Class에 대하여&lt;/h1&gt;&lt;p&gt;원래 자바스크립트는 &lt;strong&gt;프로토타입 기반 객체지향 언어&lt;/s
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES6" scheme="http://rootjang92.github.io/categories/Javascript/ES6/"/>
    
    
      <category term="es6, js, javascript, class" scheme="http://rootjang92.github.io/tags/es6-js-javascript-class/"/>
    
  </entry>
  
  <entry>
    <title>객체 리터럴 확장, 상속 그리고 디스트럭처링</title>
    <link href="http://rootjang92.github.io/2018/11/14/distructuring/"/>
    <id>http://rootjang92.github.io/2018/11/14/distructuring/</id>
    <published>2018-11-14T02:39:28.000Z</published>
    <updated>2018-11-14T03:09:48.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="객체-리터럴의-확장"><a href="#객체-리터럴의-확장" class="headerlink" title="객체 리터럴의 확장"></a>객체 리터럴의 확장</h2><ul><li>프로퍼티 축약 표현</li></ul><p>es5의 객체 리터럴을 살펴보자. 객체 리터럴의 프로퍼티는 프로퍼티 이름과 프로퍼티 값으로 구성되어 있다.</p><pre><code>var x = 1, y = 2var obj = {  x: x,  y: y}</code></pre><p>이런 식으로 말이다.</p><p>es6의 경우 프로퍼티 이름을 생략할 수 있다. 이 때의 프로퍼티 이름은 변수명으로 자동 생성된다.</p><pre><code>let x = 1, y = 2;const obj = { x, y};</code></pre><ul><li>프로퍼티 이름 조합하기</li></ul><p>es5의 객체 리터럴 프로퍼티 이름을 문자열과 변수를 조합하여 동적으로 생성하기 위해선 객체 리터럴 외부에서 프로퍼티 이름을 생성하여 객체에 할당했다.</p><pre><code>var i = 0;var propName = &apos;prop_&apos;;var obj = {};obj[propName + ++i] = i;obj[propName + ++i] = i;obj[propName + ++i] = i;console.log(obj);</code></pre><p>es6에서는 객체 리터럴 내부에서 프로퍼티 이름을 동적으로 생성할 수 있다.</p><pre><code>const i = 0;const propName = &apos;prop_&apos;;const obj = {  [propName + ++i] = i;}console.log(obj);</code></pre><ul><li>메소드 축약 표현</li></ul><p>es5에선 메소드를 선언하기 위해 함수 선언식을 사용한다.</p><pre><code>var obj = {  name: &apos;Jang&apos;,  sayHi: function() {    console.log(&apos;Hi! &apos; + this.name)  }};obj.sayHi();</code></pre><p>es6에서는 function 키워드를 생략하여 축약 표현이 가능하다.</p><pre><code>const obj = {  name: &apos;Jang&apos;,  sayHi() {    console.log(&apos;Hi! &apos; + this.name)  }};obj.sayHi();</code></pre><ul><li>[[prototype]] 프로퍼티에 의한 상속</li></ul><p>es5에서 객체 리터럴을 상속하기 위해선 Obejct.create() 함수를 사요했다. (프로토타입 패턴 상속)</p><pre><code>var parent = {  name: &apos;Kim&apos;,  sayHello: function() {    console.log(&apos;Hello! &apos; + this.name)  }};var child = Object.create(parent);child.name = &apos;Jang&apos;;parent.sayHello();child.sayHello();</code></pre><p>es6에서는 객체 리터럴 내부에 [[prototype]] 프로퍼티를 <strong>직접</strong> 설정할 수 있다. 즉 다른 객체를 직접 바인딩하여 상속을 표현할 수 있다.</p><pre><code>const parent = {  name: &apos;Jang&apos;,  sayHi() {    console.log(&apos;Hi! &apos; + this.name)  }};const child = {  __proto__: parent,  name: &apos;Jang&apos;};parent.sayHi();child.sayHi();</code></pre><ul><li>디스트럭처링</li></ul><p>디스트럭처링의 개념은 구조화된 배열 또는 개체를 비구조화하여 개별적인 변수에 할당한다는 것이다. (말로 설명하면 어렵다…) 배열 혹은 객체 리터럴에서 필요한 값을 뽑아내여 변수에 할당하거나 변환할 때 유용하게 사용된다.</p><ol><li>배열 디스트럭처링</li></ol><p>es5에서 배열의 각 요소들을 배열로부터 디스트럭처링하여 변수에 할당하기 위해선</p><pre><code>var arr = [1,2,3];var one = arr[0];var two = arr[1];var three = arr[2];console.log(one, two, three);</code></pre><p>이런 식으로 해서 귀찮음이 커진다. 하지만 es6에서는</p><pre><code>const arr = [1,2,3];const [one, two, three] = arr;console.log(one, two, three);</code></pre><p>무려 코드가 2줄이나 줄어들었다! 귀찮음이 때로는 이런 엄청난(?) 결과물을 만들어 내기도 한다.</p><p>배열 디스트럭처링을 위해서는 할당 연산자 왼쪽에 배열 형태의 변수 리스트가 필요하고 변수 리스트와 배열은 인덱스를 기준으로 할당된다.</p><p>Date 객체에서 연, 월, 일을 추출하는 예제를 같이 만들어 보자.</p><pre><code>const today = new Date();const date = today.isISOString().substring(0, 10);const [year, month, day ] = date.split(&apos;-&apos;);console.log([year, month, day]);</code></pre><ol start="2"><li>객체 디스트럭처링</li></ol><p>es5에서의 객체 디스트럭처링은 프로퍼티 이름을 사용했다.</p><pre><code>var obj = { first: &apos;apple&apos;, last: &apos;pineapple&apos; };var first = obj.first;var second = obj.last;console.log(first, second);</code></pre><p>es6에서는 각 프로퍼티를 객체에서 뽑아서 변수 리스트에 할당한다. 기준은 프로퍼티 이름이다.</p><pre><code>const obj = { first: &apos;apple&apos;, last: &apos;pineapple&apos; };const { first, last } = obj;console.log(first, last);</code></pre><p>객체 디스트럭처링을 위해서는 할당 연산자 왼쪽에 객체 형태의 변수 리스트가 있어야 한다. 객체 디스트럭처링의 장점은 프로퍼티 이름으로 필요한 프로퍼티 값만을 추출할 수 있다는 점이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;객체-리터럴의-확장&quot;&gt;&lt;a href=&quot;#객체-리터럴의-확장&quot; class=&quot;headerlink&quot; title=&quot;객체 리터럴의 확장&quot;&gt;&lt;/a&gt;객체 리터럴의 확장&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;프로퍼티 축약 표현&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;es5의 객체
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES6" scheme="http://rootjang92.github.io/categories/Javascript/ES6/"/>
    
    
      <category term="js, javascript, es6, destructuring" scheme="http://rootjang92.github.io/tags/js-javascript-es6-destructuring/"/>
    
  </entry>
  
  <entry>
    <title>ES6 파라미터를 알아보자.araboza</title>
    <link href="http://rootjang92.github.io/2018/11/12/param/"/>
    <id>http://rootjang92.github.io/2018/11/12/param/</id>
    <published>2018-11-12T03:12:32.000Z</published>
    <updated>2018-11-12T03:45:17.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-파라미터"><a href="#ES6-파라미터" class="headerlink" title="ES6 파라미터"></a>ES6 파라미터</h1><ul><li>파라미터 기본값</li></ul><p>es5에서는 파라미터 기본값을 설정할 수 없었지만, es6에선 기본값을 설정할 수 있어 함수 내 파라미터 검사를 수행하지 않아도 된다.</p><ul><li>Rest 파라미터</li></ul><p>Rest 파라미는 Spread 연산자를 사용하여 파라미터를 정의한 것이다. 그래서 인수 리스트를 함수 내부에서 배열로 전달받을 수 있다.</p><pre><code>function foo(...rest) {  console.log(Array.isArray(rest));  console.log(rest);}foo(1,2,3,4,5);</code></pre><p>위 결과로 볼 수 있듯이 인수는 순차적으로 파라미터와 Rest 파라미터에 할당된다.<br>또한 주의할 점은 rest 파라미터는 항상 인수의 맨 마지막에 와야 한다는 것이다. 그렇게 하지 않을 시 문법에러가 발생한다.</p><ul><li>argumetns와 rest 파라미터</li></ul><p>es5의 가변 인자 함수는 arguments 객체를 통해서 인수를 확인했다.</p><pre><code>var foo = fucntion() {  console.log(arguments);};foo(1,2);</code></pre><p>arguments는 파라미터로 인수를 전달받는 것이 불가능했다. 또한 유사 배열 객체이기 때문에 배열 메서드를 사용하기 위해선 Function.prototype.call을 사용해야 하는 불편함이 있었다.</p><p>하지만 es6에서는 rest 파라미터를 통해 가변 인자를 함수 내부에 배열로 전달이 가능하다. 위처럼 arguments 객체를 배열로 변경하는 등의 수고스러움을 덜 수 있다.</p><pre><code>function sum(...args) {  console.log(arguments)  console.log(Array.isArray(args));  return args.reduce((pre,cur) =&gt; pre + cur);}console.log(sum(1,2,3));</code></pre><p>주의할 점은 화살표 함수에는 arguments 프로퍼티가 없기 떄문에 화살표 함수로 가변 인자 함수롤 구현해야 한다면 <strong>반드시</strong> rest 파라미터를 사용해야 한다.</p><ul><li>Spread 연산자</li></ul><p>spread 연산자는 대상 배열이나 이터러블을 개별 요소로 분리한다.</p><ol><li>함수 인자로 사용하는 경우</li></ol><p>원래라면 Function.prototype.apply를 통해 개별적인 파라미터로 전달했다. 하지만 spread 연산자를 이용하면 쉽게 매개변수로 전달이 가능하다.</p><pre><code>function foo(x,y,z) {  console.log(x);  console.log(y);  console.log(z);}const arr = [1,2,3];foo(...arr);</code></pre><p>…rest와 spread연산자의 차이는 …rest는 분리된 요소를 <strong>함수 내부에 배열로 전달</strong>한다는 것이고 spread 연산자는 <strong>매개변수에 할당</strong>한다는 것이다.<br>또한 spread연산자는 자유롭게 사용할 수 있다.</p><ol start="2"><li>배열에서 사용할 경우</li></ol><p>es5에서는 기존 배열에 대한 많은 메서드를 사용하여 해결해야 했지만 spread 연산자로 좀 더 편하고 가독성이 좋게 만들 수 있다.</p><ul><li><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><pre><code>var arr = [1,2,3];console.log(arr.concat([4,5,6]));const arr = [1,2,3];console.log([...arr,4,5,6]);</code></pre></li></ul><ul><li><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><pre><code>var arr1 = [1,2,3];var arr2 = [4,5,6];Array.prototype.push.apply(arr1, arr2);console.log(arr1);const arr1 = [1,2,3];const arr2 = [4,5,6];arr1.push(...arr2);console.log(arr1);</code></pre></li></ul><ul><li><h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><pre><code>var arr1 = [1,2,3,6];var arr2 = [4,5];Array.prototype.splice.apply(arr1, [3,0].concat(arr2));console.log(arr1);const arr1 = [1,2,3,6];const arr2 = [4,5];arr1.splice(3,0,...arr2);console.log(arr1);</code></pre></li></ul><ul><li><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><pre><code>var arr = [1,2,3];var copy = arr.slice();console.log(copy);copy.push(4);console.log(copy);console.log(arr);</code></pre></li></ul><p>원본 배열에 변화는 없다.</p><pre><code>const arr = [1,2,3];const copy = [...arr];console.log(copy);</code></pre><ol start="3"><li><h2 id="객체에서-사용하는-경우"><a href="#객체에서-사용하는-경우" class="headerlink" title="객체에서 사용하는 경우"></a>객체에서 사용하는 경우</h2><p>   cost merged = {…{x:1, y:2 }, …{y: 10, z: 3}};<br>   console.log(merged);</p><p>   const changed = {…{x:1, y:2 }, y:100};<br>   console.log(changed);</p><p>   const added = {…{x:1, y:2},z:0};<br>   console.log(added);</p></li></ol><p>Object.assign 메서드를 사용해도 같은 작업이 가능하다.</p><pre><code>const merged = Object.assign({}, {x:1, y:2}, {y: 10, z: 3});console.log(merged);const changed = Object.assign({}, {x:1, y:2}, {y: 100});console.log(changed);const added = Object.assign({}, {x:1,y:2}, {z:0});console.log(added);</code></pre><p>spread연산자를 사용하여 유사 배열 객체를 손쉽게 배열로 변경할 수 있다.</p><pre><code>const htmlCollection = document.getElementByTagName(&apos;li&apos;);const newArray = [...htmlCollection];</code></pre><p>위 예제는 html 파일을 만들어서!<br>Array.from 메서드로도 가능하다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6-파라미터&quot;&gt;&lt;a href=&quot;#ES6-파라미터&quot; class=&quot;headerlink&quot; title=&quot;ES6 파라미터&quot;&gt;&lt;/a&gt;ES6 파라미터&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;파라미터 기본값&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;es5에서는 파라미터 기본값을 
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES6" scheme="http://rootjang92.github.io/categories/Javascript/ES6/"/>
    
    
      <category term="es6, javascript, rest parameter, spread" scheme="http://rootjang92.github.io/tags/es6-javascript-rest-parameter-spread/"/>
    
  </entry>
  
  <entry>
    <title>화살표 함수</title>
    <link href="http://rootjang92.github.io/2018/11/10/arrow-function/"/>
    <id>http://rootjang92.github.io/2018/11/10/arrow-function/</id>
    <published>2018-11-10T01:44:04.000Z</published>
    <updated>2018-11-10T02:17:49.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="화살표-함수"><a href="#화살표-함수" class="headerlink" title="화살표 함수"></a>화살표 함수</h1><p>화살표 함수란 es5의 function키워드 대신 <code>=&gt;</code>를 사용하여 쉽게 함수를 선언하는 것을 말한다.</p><ul><li>기본 문법</li></ul><p>() =&gt; {}는 매개변수가 없을 경우에 사용하는 방법, x =&gt; {}는 매개변수가 한 개일 경우, 소괄호를 생략 가능하다. (x,y) =&gt; {} 매개변수가 여러개일 경우 소괄호에 묶어 사용한다.</p><ul><li>호출</li></ul><p>화살표 함수는 익명함수만 사용이 가능하기 때문에 함수 표현식으로 사용하여야 한다.</p><pre><code>const plus = x =&gt; x + x;console.log(plus(2)); // 4</code></pre><p>또는 콜백함수로 사용이 가능하다.</p><pre><code>const arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];const pow = arr.map(x =&gt; x * x);console.log(pow);</code></pre><ul><li>this</li></ul><p>일반 함수의 this는 <strong>함수를 호출하는 패턴</strong>에 따라서 this에 바인딩되는 객체가 달라진다. 우선적으로 콜백 함수의 this는 기본적으로 전역을 가리킨다.</p><pre><code>function Strarr(str) {  this.str = str; // 1}Strarr.prototype.StrarrArray = function (arr) {  return arr.map(function (x) {    return this.str + &apos; &apos; + x; // 2  });};var res = new Strarr(&apos;Nice to meet you&apos;);console.log(res.StrarrArray([&apos;Jang&apos;, &apos;Park&apos;]));</code></pre><p>Strarr이라는 함수를 만들어서 새로운 프로토타입에서 문자열을 리턴하는 메서드를 다시 만들어 반환해보았다. 예상되는 결과값이 있는가?<br>상식적으로 [‘Nice to meet you Jang’, ‘Nice to meet you Park’]이 나올 것으로 예상했지만 결과는 Nice to meet you 부분은 undefined가 반환된다.</p><p>1번 this는 Strarr이 생성한 객체(인스턴스인 str)을 가리킨다. 2번에서이 this는 전역 객체를 가리킨다. 그 이유는 생성자 함수와 객체의 메서드를 제외한 모든 함수 내부의 this는 전역객체를 가리키기 때문이다.</p><p>그래서 es5에서는 이를 대체할 몇가지 방법을 제시하고 있다.</p><ol><li>that = this</li></ol><hr><pre><code>function Strarr(str) {  this.str = str;}Strarr.prototype.StrarrArray = function (arr) {  var that = this; // 참조값을 변경해준다.  return arr.map(function (x) {    return that.str + &apos; &apos; + x;  });};var res = new Strarr(&apos;Nice to meet you&apos;);console.log(res.StrarrArray([&apos;Jang&apos;,&apos;Park&apos;]));</code></pre><ol start="2"><li>생성자 함수의 인스턴스로 this 넣어주기</li><li>bind메서드 이용하기</li></ol><ul><li>화살표 함수의 this</li></ul><p>화살표 함수의 this는 상위 컨텍스트의 this를 계승하게 된다.</p><pre><code>function Strarr(str) {  this.str = str; // 1}Strarr.prototype.StrarrArray = function (arr) {  return arr.map(x =&gt; `${this.str} ${x}`);};const res = new Strarr(&apos;Nice to meet you&apos;);console.log(res.StrarrArray([&apos;Jang&apos;, &apos;Park&apos;]));</code></pre><ul><li>화살표 함수는 언제 쓰면 안될까?</li></ul><p>화살표 함수가 매우 편리한 기능인 것은 맞지만, 그것을 남용하는 것은 문제가 된다. 특히 몇가지 경우에는 화살표 함수를 사용해서는 안된다.<br>첫 번째로 화살표 함수로 객체의 메서드를 정의하는 경우이다. 화살표 함수의 this는 상위 컨텍스트를 가리키기 때문에 객체 메서드를 생성할 경우 this가 전역객체를 가리켜 문제가 될 수 있다.</p><p>이 경우 축약 메서드 표현을 사용하기로 하자!</p><pre><code>const person = {  name: &apos;Jang&apos;,  sayHello() {    console.log(`Hi ${this.name}`);  }};person.sayHello();</code></pre><p>또한 같은 이유로 prototype에 할당하는 경우도 배제해야 한다. prototype에 메서드를 할당하려는 경우에는 일반 함수로 하자!</p><p>세 번째로는 생성자 함수이다. 생성자 함수는 prototype 프로퍼티와 그가 가리키는 constructor 객체를 사용한다. 근데 화살표 함수에는 <strong>prototype 프로퍼티</strong>가 존재하지 않는다.</p><p>마지막으로 addEventListner의 콜백함수로 사용하면 안된다. 이도 마찬가지로 this가 상위 컨텍스트인 전역 객체를 가리켜버리기 때문이다. 이도 마찬가지로 this를 사용하고 싶다면 일반 함수를 사용하도록 하자.(이 때의 this는 이벤트 리스터에 바인딩된 요소를 가리킨다.)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;화살표-함수&quot;&gt;&lt;a href=&quot;#화살표-함수&quot; class=&quot;headerlink&quot; title=&quot;화살표 함수&quot;&gt;&lt;/a&gt;화살표 함수&lt;/h1&gt;&lt;p&gt;화살표 함수란 es5의 function키워드 대신 &lt;code&gt;=&amp;gt;&lt;/code&gt;를 사용하여 쉽
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES6" scheme="http://rootjang92.github.io/categories/Javascript/ES6/"/>
    
    
      <category term="javascript, es6, arrow" scheme="http://rootjang92.github.io/tags/javascript-es6-arrow/"/>
    
  </entry>
  
  <entry>
    <title>템플릿 리터럴</title>
    <link href="http://rootjang92.github.io/2018/11/08/template-literal/"/>
    <id>http://rootjang92.github.io/2018/11/08/template-literal/</id>
    <published>2018-11-08T02:08:42.000Z</published>
    <updated>2018-11-08T02:18:25.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="템플릿-리터럴"><a href="#템플릿-리터럴" class="headerlink" title="템플릿 리터럴"></a>템플릿 리터럴</h1><p>일반 문자열과 비슷해 보이는 템플릿 리터럴이지만 ES6에서는 백틱 문자를 도입했다.</p><pre><code>const template = `템플릿 리터럴은 백틱안에서 &apos;작은 따옴표&apos;, &quot;큰 따옴표&quot;를 사용할 수 있어요.!`console.log(template);</code></pre><p>백틱문자는 키보드의 물결표시와 함께 있다.</p><p>또한 일반 문자열에서 줄바꿈이 안되어 사용하던 white-space나 백슬래쉬(<code>\</code>)를 사용할 필요 없이 여러줄에 걸쳐서 사용이 가능하다.</p><pre><code>const soccerplayers = `&lt;ul class=&quot;player&quot;&gt;  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;램파드&lt;/a&gt;&lt;/li&gt;  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;제라드&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;`;console.log(soccerplayers);</code></pre><p><code>+</code>를 사용하지 않고 새로운 문자열을 삽입할 수도 있다.</p><pre><code>const first = &apos;Frank&apos;;const second = &apos;Lampard&apos;;console.log(&apos;I like &apos; + first + &apos; &apos; + second + &apos;.&apos;);console.log(`I like ${first} ${second}.`);</code></pre><p>${expression}을 템플릿 대입문이라고 한다. 문자열말고도 자바스크립트 표현식에서 사용할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;템플릿-리터럴&quot;&gt;&lt;a href=&quot;#템플릿-리터럴&quot; class=&quot;headerlink&quot; title=&quot;템플릿 리터럴&quot;&gt;&lt;/a&gt;템플릿 리터럴&lt;/h1&gt;&lt;p&gt;일반 문자열과 비슷해 보이는 템플릿 리터럴이지만 ES6에서는 백틱 문자를 도입했다.&lt;/p&gt;
      
    
    </summary>
    
      <category term="Javascript" scheme="http://rootjang92.github.io/categories/Javascript/"/>
    
      <category term="ES6" scheme="http://rootjang92.github.io/categories/Javascript/ES6/"/>
    
    
      <category term="js, javascript, es6, template literal" scheme="http://rootjang92.github.io/tags/js-javascript-es6-template-literal/"/>
    
  </entry>
  
  <entry>
    <title>HTMLCanvas</title>
    <link href="http://rootjang92.github.io/2018/11/02/HTMLCanvas/"/>
    <id>http://rootjang92.github.io/2018/11/02/HTMLCanvas/</id>
    <published>2018-11-02T02:46:29.000Z</published>
    <updated>2018-11-02T02:48:12.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML-Canvas-만들기"><a href="#HTML-Canvas-만들기" class="headerlink" title="HTML Canvas 만들기"></a>HTML Canvas 만들기</h1><p>이 동영상과 코드는 Javascript 30 동영상 강의를 참조하였습니다.</p><a href="https://courses.wesbos.com/" target="_blank" rel="noopener">Javascript30</a><p>동영상 보기</p><iframe width="797" height="510" src="https://www.youtube.com/embed/YIhBLMhhlDA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><a href="https://github.com/Rootjang92/js30/tree/master/08-html5%20Canvas" target="_blank" rel="noopener">깃허브 보기</a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTML-Canvas-만들기&quot;&gt;&lt;a href=&quot;#HTML-Canvas-만들기&quot; class=&quot;headerlink&quot; title=&quot;HTML Canvas 만들기&quot;&gt;&lt;/a&gt;HTML Canvas 만들기&lt;/h1&gt;&lt;p&gt;이 동영상과 코드는 Javascr
      
    
    </summary>
    
      <category term="Project" scheme="http://rootjang92.github.io/categories/Project/"/>
    
      <category term="JS30" scheme="http://rootjang92.github.io/categories/Project/JS30/"/>
    
    
      <category term="JavaScript,js,es6, HTML Canvas" scheme="http://rootjang92.github.io/tags/JavaScript-js-es6-HTML-Canvas/"/>
    
  </entry>
  
  <entry>
    <title>JS30 - Ajax ahead example</title>
    <link href="http://rootjang92.github.io/2018/10/25/js303/"/>
    <id>http://rootjang92.github.io/2018/10/25/js303/</id>
    <published>2018-10-25T12:50:48.000Z</published>
    <updated>2018-10-25T12:56:32.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS30-Project-Ajax-Type-ahead"><a href="#JS30-Project-Ajax-Type-ahead" class="headerlink" title="JS30 Project - Ajax Type ahead"></a>JS30 Project - Ajax Type ahead</h1><p>유튜브 보기</p><iframe width="750" height="510" src="https://www.youtube.com/embed/M3ecTcf9aG4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><p>코드 보기</p><a href="https://github.com/Rootjang92/js30/tree/master/06-Ahead" target="_blank" rel="noopener">MyGithub</a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS30-Project-Ajax-Type-ahead&quot;&gt;&lt;a href=&quot;#JS30-Project-Ajax-Type-ahead&quot; class=&quot;headerlink&quot; title=&quot;JS30 Project - Ajax Type ahead&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Project" scheme="http://rootjang92.github.io/categories/Project/"/>
    
      <category term="JS30" scheme="http://rootjang92.github.io/categories/Project/JS30/"/>
    
    
      <category term="JavaScript, es6, javascript 30" scheme="http://rootjang92.github.io/tags/JavaScript-es6-javascript-30/"/>
    
  </entry>
  
  <entry>
    <title>플랙서블 박스 레이아웃에 대해 알아보자.</title>
    <link href="http://rootjang92.github.io/2018/10/19/flexbox/"/>
    <id>http://rootjang92.github.io/2018/10/19/flexbox/</id>
    <published>2018-10-19T02:04:03.000Z</published>
    <updated>2018-10-19T03:40:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flex-box-layout"><a href="#Flex-box-layout" class="headerlink" title="Flex box layout"></a>Flex box layout</h1><p>flexible box layout은 그리드 레이아웃을 기본으로 하여 플랙스 박스를 원하는 위치에 배치하는 것이다. 여유 공간에 따라 너비나 높이, 위치를 자유롭게 변형할 수 있고 화면 크기에 따라 에이아수의 배치나 크기를 조절할 때 편하게 이용 가능하다는 장점이 있다.</p><p><img src="https://poiemaweb.com/img/CSS3-Flexbox-Model.jpg" alt="flexbox"></p><p>flexbox를 사용하기 위해서는 부모 요소의 display 속성을 flex로 만들어야 한다. 이를 flex-container라고 한다. (부모 요소가 inline이라면 inline-flex)</p><p>이 flex-container에 담기는 자식 요소들을 flex-item이라고 한다.</p><p>main-axis는 플렉스 항목을 배치하는 기본 방향으로 기본적으로는 왼쪽에서 오른쪽(수평)으로 배치된다. flex 항목의 배치가 시작하는 점을 main start(주축 시작점), 끝을 main end(주축 끝점)이라고 한다.</p><p>cross-axis는 주축과 교차되는 방향을 나타낸다. cross start(교차축 시작점, cross end(교차축 끝점)으로 표현한다.</p><p>더 자세히 알고 싶다면 w3c의 표준 documents를 보는 것이 좋다.</p><a href="https://www.w3.org/TR/css-flexbox-1/" target="_blank" rel="noopener">표준</a><ul><li>기본 속성</li></ul><ul><li>display 속성을 flex-container에 지정하기</li></ul><p>flexible한 레이아웃을 만들기 위해서는 컨텐츠를 flex-container로 감싸 주어야 한다. 그 후 그 부모요소의 display값을 flex (inline 요소일 경우 inline-flex)로 만들어 주어야 한다.</p><p>주의할 점은 각 브라우저마다 지원 방법이 다르기 때문에 브라우저 접두사를 붙여주어야 한다는 것이다.</p><ul><li>flex-direction : 플렉스 방향</li></ul><p>이 속성은 배치를 row(가로)로 할지 column(세로)로 할지 결정하는 것이다. 기본 값은 row이다.</p><p>row(주축 가로, 교차축 세로 / 주축 시작 -&gt; 끝), row-inverse(주축 가로, 교차축 세로 / 주축끝 -&gt; 시작)<br>column(주축 세로, 교차축 가로 / 주축 시작 -&gt; 끝), column-inverse(주축 세로, 교차축 가로 / 주축 끝 -&gt; 시작)</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/d37610Lx/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/7bhceaf9/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>flex-wrap : 항목을 한 줄 혹은 여러 줄로 배치하기</li></ul><p>기본적으로는 주축을 따라 한 줄로 배치되지만 flex-wrap 속성을 통해 조절할 수 있다. no-wrap은 기본값으로 한 줄에 표시, wrap은 여러 줄에 표시, wrap-reverse는 여러 줄에 표시하지만 반대방향으로 배치하는 속성 값이다.</p><p>flex-wrap: wrap은 왼쪽에서 오른쪽으로 위에서 아래로 배치한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/tjqumfxn/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>flex-wrap: wrap-reverse은 왼쪽에서 오른쪽이지만 아래에서 위 방향으로 배치한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/prazju5h/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>flex-flow : flex-direction과 flex-wrap을 한꺼번에</li></ul><p>귀찮으니깐 한 번에 표시하자!</p><pre><code>flex-flox: row wrap;</code></pre><p>이런식으로 쓰면 된다.</p><ul><li>order : 배치 순서 바꾸기</li></ul><p>flex 항목은 입력한 순서대로 주축을 따라 배치되는데, order 속성을 사용하면 배치를 바꿀 수 있다. order:0이면 그대로 하며 숫자값이 바뀔 때마다 그 순서에 따라 배치된다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/stez07o5/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>flex : 항목 크기 조절하기</li></ul><p>플렉스 항목의 너비를 조절하는 속성이다.</p><p>flex-grow는 얼마나 늘일지, flex-shrink는 얼마나 줄일지, flex-basis는 기본 크기를 지정하는 속성값으로 0이나 auto를 지정한다.<br>initial은 항목의 width, height 값으로 결정하며 컨테이너 공간을 넘어갈 경우 최소 크기까지 줄인다.<br>auto는 항목의 width, height값으로 결정되지만 공간에 따라 늘이거나 줄일 수 있다.</p><p>예를 들어</p><pre><code>flex: [&lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt;] | auto | initialflex : 2 2 0;</code></pre><p>으로 설정하면 2배 늘이거나 2배 줄인다는 의미이다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/w9eo6f0b/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>flex 항목 배치 속성들</li></ul><ul><li>justify-content : 주축 기준의 배치 방법 지정</li></ul><p>이 속성은 flex 항목을 주축 방향으로 배치할 때의 배치 기준을 지정할 수 있다.</p><p>flex-start는 주축의 시작점을 기준으로 배치한다.<br>flex-end는 주축의 끝 점을 기준으로 배치한다.<br>center는 주축의 중앙을 기준으로 배치한다.<br>space-between은 첫 번째 flex 항목과 마지막 flex 항목을 시작점과 끝점에 배치한 후 가운데 항목들을 같은 간격으로 배치한다.<br>space-around는 모든 플렉스 항목들을 같은 간격으로 배치한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/xfthwog6/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>align-items, align-self : 교차축 기준의 배치</li></ul><p>교차축으로 배치 방법을 조절할 수 있다.</p><p><strong>align-items 속성들</strong></p><p>stretch : flex 항목을 확장하여 교차축을 꽉 채운다. (기본값)<br>flex-start: 교차축의 시작점을 기준으로 배치한다.<br>flex-end : 교차축의 끝점을 기준으로 배치한다.<br>center: 교차축의 중앙을 기준으로 배치한다.<br>baseline: 시작점과 글자 기준선이 가장 먼 flex 항목을 시작점에 배치한다. 그리고 그 글자의 기준선과 다른 항목의 기준선을 맞춰 배치한다. (예시로 보는게 빠릅니다.)</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/p4wua215/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p><strong>align-self 속성들</strong></p><p>align-self는 각 flex 항목들을 개별적으로 배치할 수 있다. 속성값들은 위와 같지만 auto 속성이 추가된다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/n6L5v02d/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>위 예제는 align-items 항목을 center로 지정한 후 box1 항목만 align-self를 flex-start로 지정했다.</p><ul><li>align-content : 여러 줄일 때의 배치 방법</li></ul><p>flex 항목이 여러 줄에 표시될 때 align-content 속성을 사용하면 교차축 방향 배치방법을 정할 수 있다. 속성값은 justify-contetn와 같다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/3dajos06/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>예제</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/5m8cjrna/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>(이미지는 찾아서 넣으시면 됩니다. 솔로라서 슬픈데 이런 예제를…)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flex-box-layout&quot;&gt;&lt;a href=&quot;#Flex-box-layout&quot; class=&quot;headerlink&quot; title=&quot;Flex box layout&quot;&gt;&lt;/a&gt;Flex box layout&lt;/h1&gt;&lt;p&gt;flexible box layou
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css, css3, css flex, flex box" scheme="http://rootjang92.github.io/tags/css-css3-css-flex-flex-box/"/>
    
  </entry>
  
  <entry>
    <title>미디어 쿼리</title>
    <link href="http://rootjang92.github.io/2018/10/16/mediaquery/"/>
    <id>http://rootjang92.github.io/2018/10/16/mediaquery/</id>
    <published>2018-10-16T02:48:32.000Z</published>
    <updated>2018-10-16T03:45:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="미디어-쿼리"><a href="#미디어-쿼리" class="headerlink" title="미디어 쿼리"></a>미디어 쿼리</h1><p>미디어 쿼리는 CSS3 모듈 중 하나로 사이트에 접속하는 장치에 따라 그에 맞는 css 스타일링을 하게 해준다. 즉, 다른 기기로 접속할 때마다 레이아웃이 바뀐다.</p><ul><li>구문</li></ul><p>구문은</p><pre><code>@media [only | not] 미디어 유형 [and 조건] * [and 조건]</code></pre><p>이런 식으로 작성한다. 대소문자 구별이 없고 style 태그 내에서 사용한다. 여기서 only는 미디어쿼리를 지원하는 웹 브라우저에서만 동작하게, not은 지정하는 미디어 유형을 제외하는 것이다. 유형의 종류에는 all(모두), print(인쇄 장치), screen, tv, aural(음성 장치), braille(점자 표시), handheld(패드), projection(프로젝터)가 있다.</p><ul><li>조건</li></ul><p>미디어 쿼리는 조건 체크가 중요하다. 조건에 따라 css가 적용되기 때문이다.</p><ul><li>웹 문서의 가로, 세로</li></ul><p>뷰포트의 너비와 높이를 미디어 쿼리의 조건으로 사용할 수 있다. 예를 들어서</p><pre><code>@media all (min-width: 600px) and (max-width: 959px)</code></pre><p>이라고 하면 모든 장치의 뷰포터의 너비가 600이상 959이하일 때 적용한다는 의미이다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/e5qxmpjg/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>화면의 너비를 늘였다 줄였다 해보면 어떻게 변화하는 지 볼 수 있을 것이니 코드를 직접 작성해보길 바란다.</p><ul><li>단말기의 가로, 세로</li></ul><p>device-width, device-height로 측정하고 앞에 min, max를 붙여 최소, 최대값을 나타낼 수 있다.</p><ul><li>화면 회전</li></ul><p>스마트폰이나 태블릿은 가로모드 혹은 세로 고정 모드가 있다. 즉 화면을 회전시킬 수 있다. 미디어 쿼리에서는 orientation 속성을 통해서 회전을 지정할 수 있다.<br>orientation:portrait는 세로방향, orientation: landscape는 가로 방향이다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/un42wv5b/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>개발자 도구의 디바이스 모드에서 확인해볼 수 있다.</p><ul><li>화면 비율과 단말기의 물리적 화면 비율</li></ul><p>aspect-ratio 속성은 너비 값을 높이 값으로 나눈 것으로 계산이 가능하다. 예를 들어 화면 비율이 16:9라고 가정했을 때</p><pre><code>@media all and (device-aspect-ratio: 16/9)</code></pre><p>이런 식으로 작성할 수 있다.</p><ul><li>색상 비트 수</li></ul><p>단말기의 최대 색상 비트 수를 미디어 쿼리로 사용할 수 있다. 속성은 color이다. 예를 들어 color:4이면 2^4 즉 16가지의 색상을 표현할 수 있다. 만약 컬러를 지원하지 않는다면 color:0으로 설정하면 된다.</p><ul><li>중단점 만들기</li></ul><p>미디어 쿼리 작성 시 다른 css를 적용할 화면 크기를 중단점이라고 한다. 보통은 모바일, 태블릿, 데스크탑 정도로만 구분한다. (모든 크기를 맞추긴 힘들기 때문에)<br>또한 처리 속도나 화면의 크기 등을 고려했을 때 모바일의 제약 조건이 많기 때문에 모바일을 기본으로 css를 만든다.</p><ul><li>외부 css 연결하기</li></ul><ul><li>link 태그 사용하기</li></ul><p>가장 많이 사용하는 방법이다. (css) head태그 사이에 삽입한다.</p><pre><code>&lt;link rel=&quot;stylesheet&quot; media=&quot;조건&quot; href=&quot;주소&quot;&gt;</code></pre><p>즉 미디어에 따른 스타일 시트 파일을 만들어 놓았다면 조건을 좀 더 추가해서 사용할 수도 있다.</p><ul><li>@import 구문</li></ul><p>@import 구문은 style태그 사이에 만든다.</p><pre><code>@import url(&quot;css/tablet.css&quot;) only screen and (min-width:321px) and (max-width:768px)</code></pre><p>이런 식으로 사용한다.</p><p>둘의 차이는 크지 않으나 많은 css 파일을 사용할 때에는 <strong>link 태그</strong>가 좀 더 처리 속도가 빠르다. 또한 IE의 경우 @import구문과 js가 함께 있으면 js를 먼저 다운로드하기 때문에 자바스크립트에서 스타일 처리를 할 경우 오류가 날 가능성이 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/7819xhpk/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>모바일용 미디어쿼리이다. (div부분은 이미지파일을 가져오기 힘들어 임의로 넣었습니다.)</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/xj5hLb6o/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>테블릿용이다. 이미지는 본인이 직접 넣어서 적용해보면 된다. (css 그대로입니다.)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;미디어-쿼리&quot;&gt;&lt;a href=&quot;#미디어-쿼리&quot; class=&quot;headerlink&quot; title=&quot;미디어 쿼리&quot;&gt;&lt;/a&gt;미디어 쿼리&lt;/h1&gt;&lt;p&gt;미디어 쿼리는 CSS3 모듈 중 하나로 사이트에 접속하는 장치에 따라 그에 맞는 css 스타일링을
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css, css3, css mediaquery" scheme="http://rootjang92.github.io/tags/css-css3-css-mediaquery/"/>
    
  </entry>
  
  <entry>
    <title>가변 레이아웃과 가변 요소</title>
    <link href="http://rootjang92.github.io/2018/10/15/fluid/"/>
    <id>http://rootjang92.github.io/2018/10/15/fluid/</id>
    <published>2018-10-15T02:03:10.000Z</published>
    <updated>2018-10-15T02:55:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="가변-레이아웃과-가변-요소"><a href="#가변-레이아웃과-가변-요소" class="headerlink" title="가변 레이아웃과 가변 요소"></a>가변 레이아웃과 가변 요소</h1><h2 id="가변-글꼴"><a href="#가변-글꼴" class="headerlink" title="가변 글꼴"></a>가변 글꼴</h2><p>보통 우리는 텍스트 크기를 px단위로 지정한다. 하지만 px단위로 지정하게 되면 화면에 크기가 고정되기 떄문에 작은 기기에서 매우 작게 표시되는 상황이 발생한다.<br>가변 그리드 레이아웃을 사용할 때는 글자 크기도 유동적으로 변해야 하는데 그 때 사용하는 것이 ‘가변 글꼴’이다.</p><ul><li>em 단위</li></ul><p>em단위는 부모 요소에서 지정한 폰트의 대문자 M의 넓이를 1em으로 지정한 것이다. (1em = 16px) 따라서 이미 px로 표시한 글자의 크기를 16px로 나누면 em값으로 계산이 가능하다.</p><p>em = px / 16px</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/xfm467cu/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>여기서 2em은 32px이다. (크롬 인스펙터에서 Computed를 확인해보길 바란다.)</p><ul><li>rem 단위</li></ul><p>em 단위는 부모 요소의 글꼴을 기준으로 하기 때문에 부모 요소의 크기에 따라 글자 크기가 달라진다. 이러한 점은 보완하는 단위가 rem 단위이다. rem은 처음부터 기본 크기를 지정하기 때문에 중간에 기본값이 바뀌지 않는다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/z12ywLmr/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>가변 이미지</li></ul><p>이미지 또한 크기가 정해져있기 때문에 가변 이미지 형태로 만들어 창의 너비에 따라 이미지 너비도 적절히 조절할 수 있다.</p><ul><li>css 이용하기</li></ul><p>css에 max-width 속성값은 100%로 하면 이미지와 너비가 바뀐다.</p><p><img src="/images/fluid-img.png" alt="fluid-img"></p><p><img src="/images/fluid-img2.png" alt="fluid-img2"></p><ul><li>img 태그와 srcset 속성</li></ul><p>max-width 속성을 언제든지 사용할 수 있다면 참 좋겠지만, 고해상도 이미지를 크기만 줄인다면 파일 사이즈 크기 떄문에 모바일에서는 시간이 더 오래걸린다. 또한 텍스트가 포함되어 있다면 크기가 줄었을 때 텍스트를 알아보기가 힘들어진다. 이 때 사용하는 것이 img 태그에 srcset 속성이다.</p><pre><code>&lt;img src=&quot;&lt;img&gt;&quot; srcset=&quot;&lt;img&gt;[,]&quot;&gt;</code></pre><p>[]안에는 화면 너비가 달라질 때마다 표시할 이미지를 나열한 것이다. 이 때 픽셀 밀도를 함께 표시하여야 한다.</p><ul><li>picture 태그와 source 태그</li></ul><p>두 태그는 상황별로 다른 이미지를 표시하는 태그이다. 둘을 함께 사용한다면 해상도나 화면 너비에 따른 이미지 파일을 표시할 수 있다.</p><pre><code>&lt;picture&gt;  &lt;source srcset=&quot;&lt;img-large&gt;&quot; media=&quot;(min-width)&quot;&gt;  &lt;img src=&quot;&lt;img&gt;&quot; style=&quot;width&quot;&gt;&lt;/picture&gt;</code></pre><ul><li>가변 비디오</li></ul><p>이미지와 마찬가지로 비디오도 max-width:100%를 사용할 수 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/98jfvdwm/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;가변-레이아웃과-가변-요소&quot;&gt;&lt;a href=&quot;#가변-레이아웃과-가변-요소&quot; class=&quot;headerlink&quot; title=&quot;가변 레이아웃과 가변 요소&quot;&gt;&lt;/a&gt;가변 레이아웃과 가변 요소&lt;/h1&gt;&lt;h2 id=&quot;가변-글꼴&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css, css3, css fluid elements" scheme="http://rootjang92.github.io/tags/css-css3-css-fluid-elements/"/>
    
  </entry>
  
  <entry>
    <title>반응형 웹이란?</title>
    <link href="http://rootjang92.github.io/2018/10/12/reactiveweb/"/>
    <id>http://rootjang92.github.io/2018/10/12/reactiveweb/</id>
    <published>2018-10-12T04:36:36.000Z</published>
    <updated>2018-10-12T05:17:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="반응형-웹이란-무엇일까"><a href="#반응형-웹이란-무엇일까" class="headerlink" title="반응형 웹이란 무엇일까?"></a>반응형 웹이란 무엇일까?</h1><p>많은 웹 사이트가 데스크탑 위주로 만들어 지긴 하지만, 모바일 시장이 점점 발전하고 스마트폰 보급이 많아지면서 어디서 접속하든 화면을 보는데 불편함이 없게 만들고자 하는 디자인 형태가 늘어나고 있다. 이를 반응형 웹 디자인이라고 한다.</p><h2 id="모바일-기기와-웹-디자인"><a href="#모바일-기기와-웹-디자인" class="headerlink" title="모바일 기기와 웹 디자인"></a>모바일 기기와 웹 디자인</h2><p>스마트폰에서 웹을 사용하는 일이 더 많아지면서 반응형 웹은 이제 흔히 볼 수 있게 되었다. 그래서 포털 사이트, 쇼핑몰 등이 모바일 전용 사이트를 따로 만들어내기 시작하였다. 근데 솔직히 언제 하나하나 다 만들고 있을지 의문이다. 그렇기 때문에 하나의 웹 사이트에서도 크기에 맞게 웹 사이틀 표시하게 만든 것이 반응형 웹 이다.</p><ul><li>반응형 웹의 장점</li></ul><ol><li><p>어떤 스마트 기기던지 접속할 수 있다.<br>단 W3C의 웹 표준으로 만든다면!</p></li><li><p>스마트 폰이나 태블릿 가로 모드의 맞춰 레이아웃을 변경할 수 있다.<br>개인적으로 이게 제일 신기하다.</p></li><li><p>사이트 유지와 관리가 용이해진다.<br>사이트를 하나하나 만드는 것이 아니기 때문이다.</p></li></ol><h2 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h2><p>반응형 웹의 기본 중 하나는 뷰포트를 알고 가는 것이다. pc화면과 모바일 기기의 픽셀 표현방법이 다르기 때문이다. 뷰포트는 스마트폰 화면에서 표시되는 실제 영역이다. webkit 기반의 모바일 브라우저들의 기본 뷰포트는 980px이다. 결국 스마트폰의 비율인 320px에 맞춰 웹 사이트를 제작해도 스마트폰의 모바일 브라우저의 기본 뷰포트가 980px이기 때문에 글씨와 그림이 작아진다.</p><p>그래서 뷰포트를 따로 설정해 줘야 한다.</p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;&quot;&gt;</code></pre><p>이 때 content안의 속성은 width, height, user-scalable, initial-scale, minimum-scale, maximum-scale이 있다.</p><h2 id="가변-그리드-레이아웃-만들기"><a href="#가변-그리드-레이아웃-만들기" class="headerlink" title="가변 그리드 레이아웃 만들기"></a>가변 그리드 레이아웃 만들기</h2><ul><li>고정 그리드와 가변 그리드</li></ul><p>grid system은 사이트 전체의 디자인이나 일관성을 유지하는 데 편안하다. 그리드 시스템이란 화면을 몇가지 column으로 나누어 요소들을 배치할 때 사용하는 것이다.</p><p>고정 그리드 아웃은 화면 너비를 특정값으로 지정하여 그 안에 표시할 요소들의 너비 값을 지정하기 때문에 배치가 굉장히 편하다. 반면 기기에 상관없이 동일한 레이아웃을 위해서는 각 요소의 너비를 백분율과 같은 가변 값으로 지정해줘야 한다.</p><p>고정 그리드</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/rez8x0k5/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>코드를 직접 입력해보고 창을 줄였다 늘였다하면서 비교해보면 좋을 것 같다.</p><p>가변 그리드</p><p>우선 전체를 감싸는 요소를 확인한다. 고정된 픽스값이 아니라 너비를 백분율로 표시하는 것이 좋다. 그 후 각 요소의 너비 값을 계싼해서 지정해야 한다.<br>(요소의 너비 / 콘텐츠 전체를 감싸는 요소의 너비) * 100</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/oLx5uqtp/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;반응형-웹이란-무엇일까&quot;&gt;&lt;a href=&quot;#반응형-웹이란-무엇일까&quot; class=&quot;headerlink&quot; title=&quot;반응형 웹이란 무엇일까?&quot;&gt;&lt;/a&gt;반응형 웹이란 무엇일까?&lt;/h1&gt;&lt;p&gt;많은 웹 사이트가 데스크탑 위주로 만들어 지긴 하지
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css, css3, 반응형 웹, reactive web" scheme="http://rootjang92.github.io/tags/css-css3-%EB%B0%98%EC%9D%91%ED%98%95-%EC%9B%B9-reactive-web/"/>
    
  </entry>
  
  <entry>
    <title>애니메이션</title>
    <link href="http://rootjang92.github.io/2018/10/07/cssanimation/"/>
    <id>http://rootjang92.github.io/2018/10/07/cssanimation/</id>
    <published>2018-10-07T03:44:46.000Z</published>
    <updated>2018-10-07T04:15:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="애니메이션-알아보기"><a href="#애니메이션-알아보기" class="headerlink" title="애니메이션 알아보기"></a>애니메이션 알아보기</h1><p>트랜스폼과 트랜지션 등으로 애니메이션 효과를 만들 수도 있지만, animation 속성을 이용하면 더욱 쉽게 애니메이션을 만들 수 있다.</p><h2 id="CSS와-애니메이션"><a href="#CSS와-애니메이션" class="headerlink" title="CSS와 애니메이션"></a>CSS와 애니메이션</h2><p>자바스크립트나 플래시 대신에 웹 요소에 애니메이션을 추가하는 기능이다. 트랜지션과 비슷한 점은 시작부터 끝 스타일까지의 스타일을 지정한다는 점이다. 하지만 애니메이션은 원하는 곳에 스타일을 바꾸며 애니메이션을 적용할 수 있다는 점에서 다르다. (여기서 사용하는 개념이 keyframes)</p><ul><li>@keyframes : 지점 설정하기</li></ul><p>시작과 끝을 비롯해 상태가 바뀌는 부분에 이 속성을 이용하여 지정한다.</p><pre><code>@keyframes &lt;이름&gt; {  &lt;선택자&gt; { &lt;스타일&gt; }}</code></pre><p>이름으로 애니메이션을 구분하고 선택자로 속성 값이 바뀌는 지점을 선택해준다. 백분율 혹은 from ~ to를 사용할 수 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/wmg05jy9/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>animation-name : 이름 정하기</li></ul><p>말 그대로 애니메이션의 이름을 정하는 속성이다. 위 예제처럼 change-bg라는 이름을 붙여 사용한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/hy5ep0fg/3/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>animation-direction : 방향 지정</li></ul><p>원래 위치로 되돌리거나 반대 방향으로 애니메이션을 한 번 더 실행시킬 수 있다. 속성값으로는 normal(원래 위치로 , 기본값), alternate(왔던 방향으로 되돌아감)</p><ul><li>animation-iteration-count : 반복 횟수 지정하기</li></ul><p>애니메이션이 실행되는 횟수를 지정한다. 숫자로 지정할 수 있고 infinite(무한)반복이 가능하다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/4opuzL90/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>animation-timing-function : 속도 곡선 지정하기</li></ul><p>시작과 중간 끝에 속도를 선택해서 전체적인 속도를 지정할 수 있다.</p><pre><code>animation-timing-function: linear | ease | ease-in | ease-out | ease-in-out | cubic-bezier</code></pre><ul><li>animation : 한 번에 설정하기</li></ul><p>이것저것 다 지정하면 엄청 긴 코드가 작성될 것이다. 그냥 한 번에 쓰자. 하지만 주의할 점은 animation-duration은 반드시 표기를 하여야 한다. 실행 시간을 지정하지 않으면 기본 값인 0이 지정되기 때문에 애니메이션 효과를 볼 수 없다. 또한 시간 관련 된 값이 2개라면 첫 번째는  animation-time, 두 번째는 animation-delay로 인지한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/L7s0tcqk/6/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;애니메이션-알아보기&quot;&gt;&lt;a href=&quot;#애니메이션-알아보기&quot; class=&quot;headerlink&quot; title=&quot;애니메이션 알아보기&quot;&gt;&lt;/a&gt;애니메이션 알아보기&lt;/h1&gt;&lt;p&gt;트랜스폼과 트랜지션 등으로 애니메이션 효과를 만들 수도 있지만, an
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css, css3, css animation, keyframes" scheme="http://rootjang92.github.io/tags/css-css3-css-animation-keyframes/"/>
    
  </entry>
  
  <entry>
    <title>트랜지션</title>
    <link href="http://rootjang92.github.io/2018/10/06/transition/"/>
    <id>http://rootjang92.github.io/2018/10/06/transition/</id>
    <published>2018-10-06T03:07:56.000Z</published>
    <updated>2018-10-06T03:43:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="트랜지션과-애니메이션-살펴보기"><a href="#트랜지션과-애니메이션-살펴보기" class="headerlink" title="트랜지션과 애니메이션 살펴보기"></a>트랜지션과 애니메이션 살펴보기</h1><h2 id="트랜지션"><a href="#트랜지션" class="headerlink" title="트랜지션?"></a>트랜지션?</h2><p>트랜지션은 웹 요소의 배경 색, 도형 테두리 변경 등 스타일 속성을 변화시키는 것을 말한다. 예를 들어 마우스를 올려 놓았을 때 배경색이 바뀐다던지, 테두리가 사격형에서 원형으로 바뀐다던 지의 변화들을 말하는 것이다.</p><ul><li>transition-property : 트랜지션을 적용할 속성 지정</li></ul><p>트랜지션을 어느 속성에 적용할 지 정하는 속성이다. 속성 값에는 all(모든 요소, 생략 가능), none, 속성이름 등이 있다.</p><pre><code>transition-property: all; /* 해당 요소의 모든 속성 */transition-property: none; /* 아무것도 적용되지 않음 */transition-property: beckground-color; /* 해당 요소의 배경색에 트랜지션 적용 */</code></pre><ul><li>transition-duration : 트랜지션 시간 정하기</li></ul><p>트랜지션 대상을 지정한 후, 진행 시간을 지정하는 속성이 바로 transition-duration 이다. 기본은 0초이며 초 혹은 밀리초로 지정할 수 있다. 또한 쉼표를 이용하여 순서대로 여러 개를 지정할 수 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/qL6n1ckx/1/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>만약 transition-property 속성을 4개 지정하고 transition-duration을 2개 지정했다면 2개의 속성 씩 반복 적용된다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/6u719hcq/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>transition-timing-function : 트랜지션 속도 곡선 지정</li></ul><p>천천히 시작하다가 빨라지거나 하는 속도를 지정할 수 있는 속성이다. 속성 값에는 linear(같은 속도로), ease(천천히-빠르게-천천히, 기본값)<br>ease-in(시작을 느리게), ease-out(끝을 느리게), ease-in-out(느리게 시작하고 느리게 끝), cubic-bezier(n,n,n,n)(베지에 함수를 직접 정의 n은 0~1)</p><ul><li>transition-delay : 지연 시간 설정</li></ul><p>시작 시간을 언제로 시작할 것인지를 설정하는 속성이다. 초나 밀리초를 사용하며 기본값은 0s이다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/seyb5L20/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>transition : 한꺼번에 설정하기</li></ul><p>단 트랜지션 적용 대상을 한정할 시에는 따로따로 지정해주는 게 좋다. 하지만 전체적으로 적용할 때 실행시간이 다르지 않다면 한 번에 하는 것이 편하다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/cyvb85a4/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;트랜지션과-애니메이션-살펴보기&quot;&gt;&lt;a href=&quot;#트랜지션과-애니메이션-살펴보기&quot; class=&quot;headerlink&quot; title=&quot;트랜지션과 애니메이션 살펴보기&quot;&gt;&lt;/a&gt;트랜지션과 애니메이션 살펴보기&lt;/h1&gt;&lt;h2 id=&quot;트랜지션&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css, css transition" scheme="http://rootjang92.github.io/tags/css-css-transition/"/>
    
  </entry>
  
  <entry>
    <title>CSS 애니메이션 - 변형</title>
    <link href="http://rootjang92.github.io/2018/10/04/csstransform/"/>
    <id>http://rootjang92.github.io/2018/10/04/csstransform/</id>
    <published>2018-10-04T02:37:34.000Z</published>
    <updated>2018-10-04T03:32:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-Transform"><a href="#CSS-Transform" class="headerlink" title="CSS Transform"></a>CSS Transform</h1><p>특정 요소의 크기나 형태가 변하는 것을 변형이라고 한다. 웹에서도 마찬가지로 css를 이용하여 텍스트나 이미지 등을 움직이게 할 수 있다.</p><h2 id="2차원과-3차원-변형"><a href="#2차원과-3차원-변형" class="headerlink" title="2차원과 3차원 변형"></a>2차원과 3차원 변형</h2><p>2차원 변형은 x,y 축, 즉 수평 혹은 수직으로 이동하고 회전시키는 것을 말한다. x축은 오른쪽으로 y축은 아래쪽으로 이동한다.<br>3차원 변형은 x,y 축에 z라는 원근감을 주는 요소를 추가하여 변형시킨다. 보는 사람 쪽으로 다가올 수록 값이 커진다.</p><ul><li>transform과 변형 함수</li></ul><p>이 때 사용하는 것이 transform 속성이다.</p><pre><code>.photo { transform: translate(50px, 100px); }</code></pre><p>2차원 변형 함수에는 translate(x,y), scale(x,y),rotate(degree), skew(x,y)가 있다.<br>translate는 이동, scale은 확대/축소, rotate는 회전, skew는 왜곡이다.</p><p>3차원 변형 함수에는 matrix3d(n,[, n]), translate3d(x,y,z), scale3d(x,y,z), rotate3d(x,y,z),rotateX,rotateY,rotateZ, perspective(길이)가 있다.</p><p>matrix3d는 4*4행렬을 이용해 이동, 확대/축소, 회전 등의 변환을 지정할 수 있다.<br>그 외에는 모두 같고 perspective는 입체적으로 보일 수 있는 깊이 값을 지정하는 것이다.</p><ul><li>translate : 요소 이동</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/snkxu5b6/2/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>scale : 요소 확대/축소</li></ul><p>숫자로 얼만큼 확대할 것인지 지정할 수 있다. (몇 배로 확대할 것인지)</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/hfecx7w2/3/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>rotate : 요소 회전하기</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/98k6w0vt/7/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>skew : 요소 왜곡하기</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/vksqfgap/2/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><h2 id="변형-관련-속성들"><a href="#변형-관련-속성들" class="headerlink" title="변형 관련 속성들"></a>변형 관련 속성들</h2><ul><li>transform-origin : 변형 기준점 설정하기</li></ul><p>이 속성을 사용하면 x,y,z 축이 아닌 다른 지점을 변형의 기준으로 설정할 수 있다. 2차원, 3차원 변형 모두 적용할 수 있다.</p><ul><li>perspective, perspective-origin : 원근감 표현하기</li></ul><p>3차원 변형 속성으로 원근감을 갖게 한다. 속성값은 0보다 커야한다. 또한 perspective-origin을 사용하면 더 높은 곳에서 원근을 조절하는 느낌을 받을 수 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/azuo185f/3/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>transform-style : 3D 변형 적용하기</li></ul><p>여러 가지 변형을 동시에 적용할 땐 이 속성을 사용하면 된다. 속성값으로는 flat(하위 요소 평면 처리), preserve-3d(하위 요소들 3d적용)<br>이 있다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/o53r187t/9/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>backface-visibility : 요소의 뒷면 표시</li></ul><p>요소 회전 시 각도가 90도가 넘으면 뒷면이 보이는 데, 그 때의 표시 유무를 지정할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS-Transform&quot;&gt;&lt;a href=&quot;#CSS-Transform&quot; class=&quot;headerlink&quot; title=&quot;CSS Transform&quot;&gt;&lt;/a&gt;CSS Transform&lt;/h1&gt;&lt;p&gt;특정 요소의 크기나 형태가 변하는 것을 변형이라
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css,css3, css transform" scheme="http://rootjang92.github.io/tags/css-css3-css-transform/"/>
    
  </entry>
  
  <entry>
    <title>JS30 - 시계만들기</title>
    <link href="http://rootjang92.github.io/2018/10/02/js302/"/>
    <id>http://rootjang92.github.io/2018/10/02/js302/</id>
    <published>2018-10-02T07:24:29.000Z</published>
    <updated>2018-10-02T07:25:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS와-CSS로-시계-만들기"><a href="#JS와-CSS로-시계-만들기" class="headerlink" title="JS와 CSS로 시계 만들기"></a>JS와 CSS로 시계 만들기</h1><p>코드 설명은 추후에 만들기로…</p><p>유튜브 보기</p><iframe width="560" height="315" src="https://www.youtube.com/embed/JHrBJF7jDz4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><p>코드 보기<br><a href="https://github.com/Rootjang92/js30" target="_blank" rel="noopener">MyGithub</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS와-CSS로-시계-만들기&quot;&gt;&lt;a href=&quot;#JS와-CSS로-시계-만들기&quot; class=&quot;headerlink&quot; title=&quot;JS와 CSS로 시계 만들기&quot;&gt;&lt;/a&gt;JS와 CSS로 시계 만들기&lt;/h1&gt;&lt;p&gt;코드 설명은 추후에 만들기로…&lt;/
      
    
    </summary>
    
      <category term="Project" scheme="http://rootjang92.github.io/categories/Project/"/>
    
      <category term="JS30" scheme="http://rootjang92.github.io/categories/Project/JS30/"/>
    
    
      <category term="javascript,js,es6,clock" scheme="http://rootjang92.github.io/tags/javascript-js-es6-clock/"/>
    
  </entry>
  
  <entry>
    <title>CSS 선택자</title>
    <link href="http://rootjang92.github.io/2018/10/02/cssselector/"/>
    <id>http://rootjang92.github.io/2018/10/02/cssselector/</id>
    <published>2018-10-02T04:10:05.000Z</published>
    <updated>2018-10-02T05:10:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-선택자-알아보기"><a href="#CSS-선택자-알아보기" class="headerlink" title="CSS 선택자 알아보기"></a>CSS 선택자 알아보기</h1><h2 id="연결-선택자"><a href="#연결-선택자" class="headerlink" title="연결 선택자"></a>연결 선택자</h2><p>combination selector라고도 부른다.</p><ul><li>하위 선택자 : 지정한 하위 요소에 스타일 적용하기</li></ul><p>예제 코드를 살펴보자</p><pre><code>div p { color: blue }</code></pre><p>여기서 div는 상위 요소 p는 하위 요소이다. 이 코드를 해석하자면 div 태그안에 있는 모든 p태그에 css 요소를 적용하겠다는 의미이다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/0u1dq8ks/2/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>예제를 보면 ul태그 모두 section의 하위 요소에 속하기 때문에 모두 적용되는 것을 볼 수 있다.</p><ul><li>자식 선택자 : 자식 요소에만 스타일 적용하기</li></ul><p>부모 요소의 자식 요소에만 스타일을 적용하는 방법도 있다.</p><pre><code>section &gt; p { color: blue }</code></pre><p>하위 요소 전체가 아닌 section 요소 안에 포함된 p 요소 중 자식 p요소에만 스타일을 적용하겠다는 의미이다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/hgjqcbp6/1/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>여기서는 container의 자식인 첫 번째 ul요소에만 스타일이 적용된다.</p><ul><li>인접 형제 선택자</li></ul><p>문서 구조상 같은 부모를 가진 형제 요소 중 첫 번째 동생 요소에만 스타일을 적용할 때 사용한다.</p><pre><code>h1 + p { text-decoration: underline; }</code></pre><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/ws8oecx1/2/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>형제 선택자</li></ul><p>인접 형제 선택자와 달리 모든 형제 요소에 적용된다. 인접 형제 선택자에선 ‘+’ 기호를 사용했다면 형제 선택자에선 ‘~’ 기호를 사용한다.</p><h2 id="속성-선택자"><a href="#속성-선택자" class="headerlink" title="속성 선택자"></a>속성 선택자</h2><ul><li>‘[속성]’ 선택자 : 지정한 속성에 스타일 적용</li></ul><p>특정 요소에 스타일을 적용시킨다. 대괄호 사이에 찾으려는 속성을 넣으면 된다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/fvn8oe74/2/embedded/html,css,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>[속성 = 값] : 특정 값을 갖는 속성에 스타일 적용</li></ul><p>위 예제에서</p><pre><code>a[target=&quot;_blank&quot;] { ... }</code></pre><p>라고 입력하면 target=”_blank”인 링크를 찾아 스타일을 적용시킨다.</p><ul><li>[속성 ~= 값] : 여러 값 중 특정 값이 포함된 소성에 스타일 적용</li></ul><p>[속성 = 값]이 속성과 값이 정확히 일치하는 요소를 찾는다면 [속성 ~= 값]은 여러 속성 값 중 해당 값이 포함되어 있는 요소를 선택한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/4rdLno59/2/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>[속성 |= 값] : 특정 값이 포함된 속성에 스타일 적용</li></ul><p>이 때 값은 한 단어로 같아야 한다. 단어가 포함된 하이픈 연결 단어도 스타일이 적용된다.</p><ul><li>[속성 ^= 값] : 특정 값으로 시작하는 속성에 스타일 적용</li></ul><p>^는 캐럿이라고 한다. 캐럿이 붙으면 지정한 문자로 시작하는 속성 값에 대해서만 스타일을 적용시킨다.</p><ul><li>[속성 $= 값] : 특정 값으로 끝나는 속성에 스타일 적용</li></ul><p>반대로 $는 지정한 문자로 끝나는 속성에 스타일을 적용시킨다.</p><ul><li>[속성 *= 값] : 값의 일부가 일치하는 속성에 스타일 적용</li></ul><p>사용자가 지정한 속성 값의 위치에 관계없이 값이 포함되어 있으면 스타일이 적용된다.</p><h2 id="가상-클래스와-가상-요소"><a href="#가상-클래스와-가상-요소" class="headerlink" title="가상 클래스와 가상 요소"></a>가상 클래스와 가상 요소</h2><ul><li>사용자 동작에 반응하는 가상 클래스</li></ul><p>사용자가 커서를 올린다던 지 클릭을 한다던지의 이벤트가 발생할 때 스타일이 바뀌도록 만들고 싶을 때 사용하는 것이 가상 클래스 선택자이다.</p><ol><li>:link</li></ol><p>하이퍼링크 중 사용자가 아직 방문하지 않은 링크에 스타일을 적용한다. 기본적으로 파란줄이 표시되는 것을 없애고 싶다거나 할 때에 사용한다.</p><ol start="2"><li>:visited</li></ol><p>링크 중 한 번 이상 방문한 링크에 대해 스타일을 적용한다.</p><ol start="3"><li>:hover</li></ol><p>요소에 마우스 커서를 올렸을 때 스타일을 지정한다. 롤오버 효과등이 그 예이다.</p><ol start="4"><li>:active</li></ol><p>요소를 활성화 시켰을 때 스타일을 지정하는 요소이다.</p><ol start="5"><li>:focus</li></ol><p>요소에 초점이 맞춰젔을 때 사용한다. 아이디를 입력하기 위해 텍스트 필드로 마우스 커서를 갖다 놓았을 때 등에 사용한다.</p><ul><li>주의할 점은 가상 클래스 선택자는 순서를 중요하게 해야한다. link, visited, hover, active 순으로 정의한다.</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/19kzwt2x/1/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>UI 요소 상태에 따른 가상 클래스</li></ul><p>User Interface 요소에 상태에 따른 가상 클래스는 화면 디자인할 때 상태 스타일을 지정하기 위해 사용한다.</p><ol><li>:enabled, :disabled : 요소를 사용할 수 있을 때와 없을 때</li></ol><p>둘의 차이를 예제로 설명하자면 회원가입은 사용자가 텍스트를 작성해야 하기 때문에 enabled 상태, 약관 등은 disabled 상태로 표시해야 한다.</p><ol start="2"><li>:checked : 라디오, 체크 박스에서 항목을 선택했을 때</li></ol><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/o970fqwa/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><ul><li>구조 가상 클래스</li></ul><p>웹 문서의 구조를 기준으로 특정 위치에 있는 요소를 찾아서 스타일을 지정한다.</p><ol><li>:root</li></ol><p>문서 전체에 적용한다.</p><ol start="2"><li>:nth-child(n) , nth-last-child(n) : 자식 요소의 위치에 따른 스타일 적용</li></ol><p>특정 부분에 스타일을 적용하기 위해서는 보통 class나 id를 통해 이름을 붙여준다. 그러나 여러 개의 항목이 일렬로 나열되어 있다면, nth-child(n)을 사용하여 n번째 자식 요소에 스타일을 적용하거나 nth-last-child(n) 끝에서부터 n번째 자식 요소를 통해서 사용한다.<br>an+b 처럼 수식사용도 가능하다. 조금은 어려운 개념이므로 충분한 연습이 필요하다.<br>단, 위치에 따른 스타일 적용이기 때문에 해당 요소들이 모두 한 부모 요소를 가지고 있어야 한다.</p><iframe width="100%" height="300" src="//jsfiddle.net/rootjang/tpwvx671/2/embedded/html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe><p>다음 예제는 홀수 열에만 스타일을 적용시키는 예제이다.</p><ol start="3"><li>:nth-of-type(n), nth-last-of-type(n) : 특정 태그 위치에 스타일 적용하기</li></ol><ol start="4"><li>:first-child, :last-child : 첫번째, 마지막 자식 요소에 스타일 적용하기</li></ol><ol start="5"><li>:first-of-type, :last-of-type : 형제 관계 요소의 위치에 따른 스타일 적용</li></ol><p>형제 관계 요소 중에서 첫번째, 마지막 요소에 스타일을 적용한다.</p><ol start="6"><li>:only-child, :only-of-type : 하나뿐인 자식 요소에 스타일 적용하기</li></ol><p>부모 요소 중 자식 요소가 하나일 때 스타일을 적용한다. only-child는 다른 자식요소가 존재할 수 없고 only-of-type은 다른 자식 요소가 있어도 된다.</p><ul><li>그 외에 가상 요소</li></ul><ol><li>:target : 앵커 목적지에 스타일 적용</li></ol><p>다른 사이트로 이동할 때 링크를 이용하고, 같은 문서 안에서 다른 위치로 이동할 때에는 앵커를 사용한다.</p><ol start="2"><li>:not : 특정 요소가 아닐 때 스타일 적용</li></ol><ul><li>가상 요소</li></ul><ol><li>::first-line, ::first-letter : 첫 번째 줄과 첫 번째 글자에 스타일 적용</li></ol><ol start="2"><li>::before, ::after : 내용 앞 뒤에 콘텐츠 추가하기</li></ol><p>요소 앞 뒤에 텍스트, 이미지 등을 표시한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS-선택자-알아보기&quot;&gt;&lt;a href=&quot;#CSS-선택자-알아보기&quot; class=&quot;headerlink&quot; title=&quot;CSS 선택자 알아보기&quot;&gt;&lt;/a&gt;CSS 선택자 알아보기&lt;/h1&gt;&lt;h2 id=&quot;연결-선택자&quot;&gt;&lt;a href=&quot;#연결-선택자&quot;
      
    
    </summary>
    
      <category term="HTML &amp; CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/"/>
    
      <category term="CSS" scheme="http://rootjang92.github.io/categories/HTML-CSS/CSS/"/>
    
    
      <category term="css, css3, css selector" scheme="http://rootjang92.github.io/tags/css-css3-css-selector/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 30 project Day 1 - Drum kit</title>
    <link href="http://rootjang92.github.io/2018/10/02/js301/"/>
    <id>http://rootjang92.github.io/2018/10/02/js301/</id>
    <published>2018-10-02T02:30:29.000Z</published>
    <updated>2018-10-02T02:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6로-Drum-kit-제작하기"><a href="#ES6로-Drum-kit-제작하기" class="headerlink" title="ES6로 Drum kit 제작하기"></a>ES6로 Drum kit 제작하기</h1><p>이 동영상과 코드는 Javascript 30 동영상 강의를 참조하였습니다.</p><a href="https://courses.wesbos.com/" target="_blank" rel="noopener">Javascript30</a><p>동영상 보기</p><iframe width="596" height="331" src="https://www.youtube.com/embed/eP1KufDzsK4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><p>깃허브 링크</p><a href="https://github.com/Rootjang92/js30" target="_blank" rel="noopener">MyGithub</a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6로-Drum-kit-제작하기&quot;&gt;&lt;a href=&quot;#ES6로-Drum-kit-제작하기&quot; class=&quot;headerlink&quot; title=&quot;ES6로 Drum kit 제작하기&quot;&gt;&lt;/a&gt;ES6로 Drum kit 제작하기&lt;/h1&gt;&lt;p&gt;이 동영상과
      
    
    </summary>
    
      <category term="Project" scheme="http://rootjang92.github.io/categories/Project/"/>
    
      <category term="JS30" scheme="http://rootjang92.github.io/categories/Project/JS30/"/>
    
    
      <category term="Javascript, js, es6, drum" scheme="http://rootjang92.github.io/tags/Javascript-js-es6-drum/"/>
    
  </entry>
  
  <entry>
    <title>HTML 멀티 미디어</title>
    <link href="http://rootjang92.github.io/2018/10/01/htmlmedia/"/>
    <id>http://rootjang92.github.io/2018/10/01/htmlmedia/</id>
    <published>2018-10-01T05:10:44.000Z</published>
    <updated>2018-10-01T05:39:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML-멀티미디어-관련-태그들"><a href="#HTML-멀티미디어-관련-태그들" class="headerlink" title="HTML 멀티미디어 관련 태그들"></a>HTML 멀티미디어 관