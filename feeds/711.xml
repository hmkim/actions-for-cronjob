<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.2.1">Jekyll</generator><link href="https://sori-nori.gitlab.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sori-nori.gitlab.io/" rel="alternate" type="text/html" /><updated>2019-05-02T02:20:39+00:00</updated><id>https://sori-nori.gitlab.io/</id><title type="html">Sori-Nori</title><subtitle>28살 컴맹 개발자의 성장 로그.</subtitle><entry><title type="html">EC2에 배포한 Java 어플리케이션에서 키 없이 타계정에 접근하기</title><link href="https://sori-nori.gitlab.io/youngkyung-done/assumerole_and_instance_profile/" rel="alternate" type="text/html" title="EC2에 배포한 Java 어플리케이션에서 키 없이 타계정에 접근하기" /><published>2019-05-02T00:00:00+00:00</published><updated>2019-05-02T00:00:00+00:00</updated><id>https://sori-nori.gitlab.io/youngkyung-done/assumerole_and_instance_profile</id><content type="html" xml:base="https://sori-nori.gitlab.io/youngkyung-done/assumerole_and_instance_profile/">&lt;p&gt;ec2에 배포한 Java 어플리케이션이 키 없이 다른 계정에 접근할 수 있다면?&lt;br /&gt;
액세스키, 시크릿키를 줄여 관리의 수고를 덜어줄 수있을 뿐 아니라, 노출의 위험 자체가 없어지니 보안적으로도 장점이 있다.&lt;br /&gt;
&lt;a href=&quot;https://sori-nori.gitlab.io/youngkyung-done/IAM_assumerole/&quot;&gt;지난 포스팅&lt;/a&gt;에서 언급했듯이 이러한 이유들로 IAM 역할을 사용할 수 있다면, 이를 최대한 활용하고 싶고 
개인적으로는 최대한 액세스키, 시크릿키를 사용하고 싶지 않다.&lt;/p&gt;

&lt;p&gt;지난 포스팅에서는 단순히 logstash에서 AssumeRole을 이용하기 위해 IAM Role을 생성해주고,&lt;br /&gt;
Input 혹은 Output에 role arn을 지정해주는 간단한 설정만으로 액세스키, 시크릿키 없이 타계정 리소스 접근을 허용해주었는데&lt;br /&gt;
이번에는 Java 어플리케이션에서 AWS SDK를 이용하여 개발할 때 방법을 소개하고자 한다.&lt;br /&gt;
AWS SDK를 사용한다고 해서 무슨 특별한 차이점이 있겠느냐고 생각할 수 도있지만, 삽질을 몇시간했기 때문에 잊지않기 위해 남긴다.&lt;/p&gt;

&lt;p&gt;먼저 삽질을 시작하게된 이유는 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/IAM/latest/UserGuide/id_credentials_temp_use-resources.html&quot;&gt;AssumeRole을 소개하는 AWS 공식 문서&lt;/a&gt;에서 소개한대로 
AWS SDK에서 AssumeRole을 사용하기위해 임시 보안자격증명을 선언하고 이를 통해 타계정의 리소스에 접근하려했다는 점이다.&lt;br /&gt;
나와 같은 실수를 했다면 아마 아래와 같은 오류메세지를 만났을 것이다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Cannot call GetSessionToken with session credentials&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그리고 이 문구와 함께 403 에러라는 에러코드도 보여주는데, 403오류코드에 집착해 IAM 설정만을 들여다보았다.(삽질 대장정 시작)&lt;br /&gt;
IAM Role에 GetSessionToken 권한도 넣어보았지만 원하는 결과를 얻을 수 없었다.&lt;/p&gt;

&lt;p&gt;이에 대한 해답은 &lt;a href=&quot;https://stackoverflow.com/questions/35873012/error-when-ec2-running-as-a-role-tries-to-get-a-session-token-in-aws&quot;&gt;의외의 곳&lt;/a&gt;에서 찾았다.&lt;br /&gt;
구글링하다가 찾은 스택오버플로우 링크인데, 나와 똑같은 문제를 고민하고 있는 질문에 아래와 같은 답변이 달려있었다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;According to AWS support, roles cannot request temporary credentials. Only actual Users can do that.&lt;br /&gt;
A work around is to use the role’s credentials. They get rolled over every hour, so they are temporary (albeit hard coded to 1 hour TTL)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;애초에 IAM Role은 임시 자격증명을 요청할 수 없다는 것이다.&lt;br /&gt;
결국 AWS SDK 사용법이 잘못됐다는 것에 힌트를 얻어 role arn을 지정하여 AssumeRole Session을 받아오고, client를 생성할때 Credential을 지정해줌으로서 해결하였다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;n&quot;&gt;STSAssumeRoleSessionCredentialsProvider&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stsCred&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;STSAssumeRoleSessionCredentialsProvider&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ARN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Role&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Session&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;AmazonEC2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ec2Client&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AmazonEC2ClientBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;standard&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withCredentials&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stsCred&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;IAM Role은 이미 Session Credential을 사용하고 있다.&lt;br /&gt;
AWS 콘솔에서 Role 설정화면에 들어가면 최대 CLI/API 세션 기간이라는 설정 항목을 볼 수 있는데, 
이 항목을 사용자 지정 기간으로 선택하면 다음과 같은 힌트를 얻을 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;CLI/API 최대 세션 기간은 3,600 (1시간) 에서 43,200 (12시간) 사이여야 합니다.&lt;br /&gt;
이 역할을 수임하면 IAM에서 기본 시간 동안 유효한 임시 보안 자격 증명을 발급합니다.&lt;strong&gt;(기본으로 제공하는 시간은 따로 있음을 의미함)&lt;/strong&gt;&lt;br /&gt;
최대 세션기간을 늘려 해당 역할을 수임하는 사람이 선택적으로 DurationSeconds 파라미터를 이용해 세션 연장을 요청하도록 허용합니다.&lt;strong&gt;(이 설정은 기본 세션에 초과하여 연장을 요청할때의 최대값임)&lt;/strong&gt; &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/IAM/latest/UserGuide/id_roles_use.html?icmpid=docs_iam_console&quot;&gt;자세히 알아보기&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 공식 문서에서 제공하는 정보에 따르면&lt;br /&gt;
AssumeRole CLI/API의 자격 증명의 수명은 최소 15분~최대 (세션 기간 설정만큼) 이며, 기본은 1시간이다.&lt;br /&gt;
즉, 자격증명의 수명을 연장하기 위해서는 STSAssumeRoleSessionCredentials을 받아오기전에 duration seconds를 지정해주면 된다.&lt;br /&gt;
나 같은 경우에는 최대 시간을 1시간으로 지정해두었기 때문에, 기본 제공하는 세션 시간에서 연장할 수 없다.&lt;/p&gt;</content><category term="aws" /><category term="iam_role" /><summary type="html">다른 AWS 계정에 있는 리소스를 역할로 접근하기-2</summary></entry><entry><title type="html">AWS IAM Role 공유해서 쓰기</title><link href="https://sori-nori.gitlab.io/youngkyung-done/IAM_assumerole/" rel="alternate" type="text/html" title="AWS IAM Role 공유해서 쓰기" /><published>2019-03-05T00:00:00+00:00</published><updated>2019-03-05T00:00:00+00:00</updated><id>https://sori-nori.gitlab.io/youngkyung-done/IAM_assumerole</id><content type="html" xml:base="https://sori-nori.gitlab.io/youngkyung-done/IAM_assumerole/">&lt;p&gt;수많은 액세스키를 보안상 문제없이 잘 관리하기란 참 어려운 문제이다.&lt;br /&gt;
그래서 나는 IAM 역할을 사용할 수 있다면, 이를 최대한 활용하고 싶다.&lt;/p&gt;

&lt;p&gt;그동안 니즈가 없어서 고민해보지 않은 문제였는데, A계정의 EC2에 올라와있는 logstash에서 B계정의 클라우드워치 메트릭을 뽑아오고 싶다.&lt;br /&gt;
타 계정의 리소스를 어떻게 공유할까? 분명 AWS에서 지원할만한 기능이다.&lt;/p&gt;

&lt;p&gt;아래 두 페이지만 참고하면 간단히 해결할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/aws/comments/8k436d/how_to_create_crossaccount_role_for_access_to/&quot;&gt;구글링하다 찾은 reddit 링크&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/IAM/latest/UserGuide/id_credentials_temp_control-access_enable-create.html&quot;&gt;임시보안 자격증명에 대한 AWS 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;b--&quot;&gt;B계정에 역할 생성하기&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;신뢰할수 있는 유형의 개체를 다른 AWS 계정으로 선택하고, A계정의 고유ID값을 입력한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;a----b--&quot;&gt;A계정에 역할 생성 및 B계정 역할 연결&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;B계정의 역할을 사용할 수 있는 정책을 연결한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;Version&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;2012-10-17&quot;&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&quot;Statement&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s2&quot;&gt;&quot;Effect&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;Allow&quot;&lt;/span&gt;,
        &lt;span class=&quot;s2&quot;&gt;&quot;Action&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;sts:AssumeRole&quot;&lt;/span&gt;,
        &lt;span class=&quot;s2&quot;&gt;&quot;Resource&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;B계정에 생성한 역할의 ARN기입&quot;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;세팅은 끝났다, 번외로 logstash에서 지원하는 aws 서비스들의 플러그인을 보면 role_arn을 설정할 수 있는 값이 있을 것이다.&lt;br /&gt;
role_arn에 B계정에서 생성한 역할의 arn을 입력하고, 해당 EC2에 A계정에서 생성한 역할을 연결하면,&lt;br /&gt;
별다른 키세팅없이 역할만으로 문제없이 프로그램을 운용할 수 있다.&lt;/p&gt;</content><category term="aws" /><category term="iam_role" /><summary type="html">다른 AWS 계정에 있는 리소스를 역할로 접근하기</summary></entry><entry><title type="html">AWS EC2 과금 포인트</title><link href="https://sori-nori.gitlab.io/youngkyung-done/AWS_EC2_pricing/" rel="alternate" type="text/html" title="AWS EC2 과금 포인트" /><published>2018-08-11T00:00:00+00:00</published><updated>2018-08-11T00:00:00+00:00</updated><id>https://sori-nori.gitlab.io/youngkyung-done/AWS_EC2_pricing</id><content type="html" xml:base="https://sori-nori.gitlab.io/youngkyung-done/AWS_EC2_pricing/">&lt;h3 id=&quot;instance-usage&quot;&gt;Instance Usage&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;온디맨드, 예약, 스팟 인스턴스에 대해서 Amazon Linux 및 Ubuntu에 한하여 초당 과금을 지원한다.&lt;/li&gt;
  &lt;li&gt;인스턴스 유형별로 요금이 많이 차이나므로 충분한 테스트를 거쳐 인스턴스를 선택하자.&lt;/li&gt;
  &lt;li&gt;운용중인 인스턴스에 대한 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/solutions/latest/cost-optimization-ec2-right-sizing/deployment.html&quot;&gt;RightSizing&lt;/a&gt;은 AWS에서 제공하는 CloudFormation 스택으로 간단하게 돌려볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;고려사항&lt;/h4&gt;
&lt;h5 id=&quot;section-1&quot;&gt;프리티어&lt;/h5&gt;
&lt;p&gt;1년간 750시간 t2.micro&lt;/p&gt;

&lt;h5 id=&quot;section-2&quot;&gt;지불(구매) 방법&lt;/h5&gt;

&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;구매방법&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://aws.amazon.com/ko/ec2/pricing/on-demand/&quot;&gt;온디맨드&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;약정없이 사용하길 원할 때 / 예측할 수 없는 워크로드 / 중단되어서는 안되는 애플리케이션&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://aws.amazon.com/ko/ec2/pricing/reserved-instances/pricing/&quot;&gt;예약인스턴스(RI)&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;수요가 꾸준한 인스턴스 패밀리 유형을 사용할 때 / 예약 용량이 필요한 애플리케이션 / 1년 또는 3년의 약정으로 비용절감을 원할 때&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://aws.amazon.com/ko/ec2/spot/pricing/&quot;&gt;스팟인스턴스&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;시작 및 종료 시간이 자유로운 애플리케이션 / 단시간동안 대량의 서버가 필요한 경우&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://aws.amazon.com/ko/ec2/dedicated-hosts/pricing/&quot;&gt;전용호스팅&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;내부정책/규정에 의해 단독 서버 구성이 필요한 경우 / 서버 한정 라이센스를 사용해야하는 경우&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;스팟인스턴스만 사용하는 것이 불안정할 것같다 판단되면 Worker의 성격이 강한 EC2는 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/ec2-fleet.html&quot;&gt;EC2 Fleet&lt;/a&gt; 사용을 검토해보자!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;t2-&quot;&gt;T2 과금&lt;/h5&gt;
&lt;h6 id=&quot;cpu-&quot;&gt;CPU 크레딧&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;사용률 및 시간의 조합으로 계산한다.
    &lt;blockquote&gt;
      &lt;p&gt;CPU 크레딧 1개 = 1분동안 100%의 사용률로 실행되는 vCPU 1개&lt;br /&gt;
CPU 크레딧 1개 = 2분동안 50% 사용률로 실행되는 vCPU 1개&lt;br /&gt;
CPU 크레딧 1개 = 2분동안 25% 사용률로 실행되는 vCPU 2개&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;크레딧 획득 : 인스턴스 크기에 따라 지속적으로 특정 비율의 크레딧을 획득하고, 사용하지 않은 크레딧은 누적된다.&lt;/li&gt;
  &lt;li&gt;누적 크레딧 : 누적할 수 있는 크레딧은 상한선이 있으며, 획득한 크레딧은 만료되지 않으나 중지되면 손실된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;standard&quot;&gt;표준(Standard)&lt;/h6&gt;
&lt;p&gt;시작 시 지급되는 크레딧, 시간당 지급되는 크레딧, 이로 인해 누적된 크레딧 선에서 버스트가 가능하며 크레딧이 전부 소진되면 성능이 점차적으로 기준 성능 수준으로 떨어진다.&lt;br /&gt;
따라서, &lt;strong&gt;평균 CPU 사용률이 인스턴스 기준 성능보다 일관되게 낮은 워크로드에 적합하다.&lt;/strong&gt;&lt;/p&gt;

&lt;h6 id=&quot;unlimited&quot;&gt;무제한(Unlimited)&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;모든 리전, 모든 T2 인스턴스, 온디맨드 혹은 예약 인스턴스에 대해서 CPU 크레딧 요금 과금 정책은 동일하다.&lt;br /&gt;
&lt;strong&gt;누적된 크레딧 외 별도 크레딧을 소비하면서 버스트가 가능&lt;/strong&gt;하며, 소진한 별도 크레딧에 대하여 과금이 발생한다.
    &lt;ol&gt;
      &lt;li&gt;Linux, RHEL 및 SLES : vCPU 시간당 0.05 USD&lt;/li&gt;
      &lt;li&gt;Windows 및 SQL Web 용 Windows : vCPU 시간당 0.096 USD&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;section-3&quot;&gt;인스턴스 유형&lt;/h6&gt;

&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;인스턴스 유형&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;vCPU&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;ECU&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;메모리 (GiB)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;시작 시 지급되는 크레딧 (Standard 일 때만)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;시간당 지급되는 CPU 크레딧&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;누적 크레딧 상한선&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;vCPU당 기준 성능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;t2.nano&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;변수&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.5GiB&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;30&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;72&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;t2.micro&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;변수&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1GiB&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;30&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;144&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;t2.small&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;변수&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2GiB&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;30&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;288&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;t2.medium&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;변수&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4GiB&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;60&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;24&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;576&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;t2.large&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;변수&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8GiB&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;60&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;36&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;864&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;30%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;t2.xlarge&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;변수&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16GiB&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;120&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;54&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1296&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;22.5%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;t2.2xlarge&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;변수&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;32GiB&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;240&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;81&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1944&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16.88%&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;ebs&quot;&gt;EBS&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;gp2 : 스토리지&lt;/li&gt;
  &lt;li&gt;io1 : 스토리지 / IOPS&lt;/li&gt;
  &lt;li&gt;st1 : 스토리지&lt;/li&gt;
  &lt;li&gt;sc1 : 스토리지&lt;/li&gt;
  &lt;li&gt;스냅샷&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;elastic-load-balancing&quot;&gt;Elastic Load Balancing&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;실행된 시간 / 로드밸런서 용량 단위(LCU)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;1LCU = 초당 25개의 새로운 연결&lt;br /&gt;
1LCU = 분당 3,000개의 활성 연결&lt;br /&gt;
1LCU = 2.22Mbps (시간당 1GB) 대역폭&lt;br /&gt;
1LCU = 초당 1,000 규칙 평가(=요청속도 * 규칙 처리 수)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;elastic-ip-address&quot;&gt;Elastic IP Address&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;인스턴스 당 1개의 무료 EIP 제공&lt;/li&gt;
  &lt;li&gt;추가 IP 매핑 시 주소당 시간에 비례하여 과금 발생&lt;/li&gt;
  &lt;li&gt;매핑되지 않은 EIP 주소당 시간에 비례하여 과금 발생&lt;/li&gt;
&lt;/ul&gt;</content><category term="aws" /><category term="ec2" /><category term="pricing" /><summary type="html">AWS EC2를 선택하기 전에 요금발생 포인트 정리해보기!!</summary></entry><entry><title type="html">관리해야할 데몬들이 많아진다! Monit 써보기</title><link href="https://sori-nori.gitlab.io/youngkyung-done/Monit-1/" rel="alternate" type="text/html" title="관리해야할 데몬들이 많아진다! Monit 써보기" /><published>2018-07-12T00:00:00+00:00</published><updated>2018-07-12T00:00:00+00:00</updated><id>https://sori-nori.gitlab.io/youngkyung-done/Monit-1</id><content type="html" xml:base="https://sori-nori.gitlab.io/youngkyung-done/Monit-1/">&lt;p&gt;2년전에 Monit 이란 존재를 들어보기만 하고 사용은 해보지 않았는데,&lt;br /&gt;
배포에 꼭 필요한 에이전트가 부팅 시 START에 실패하는 사례가 있어서 해결책을 찾아보다가 Monit을 사용해보기로 하였다.  &lt;br /&gt;
마침 php-fpm의 child 개수가 일정 수치를 넘어가면 알람을 받고 싶은 니즈도 있어서 Monit으로 간단하게 두가지 고민을 해결하려한다.&lt;/p&gt;

&lt;p&gt;codedeploy-agent 상태를 지켜보다가 프로세스가 다운되면 다시 시작해준다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@ip-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; monit.d]# cat codedeploy-agent
check process codedeploy-agent with pidfile /opt/codedeploy-agent/state/.pid/codedeploy-agent.pid
start program &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/usr/sbin/service codedeploy-agent start&quot;&lt;/span&gt;
stop program &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/usr/sbin/service codedeploy-agent stop&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;5 restarts within 5 cycles &lt;span class=&quot;k&quot;&gt;then &lt;/span&gt;timeout
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@ip-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; monit.d]# monit status codedeploy-agent
Monit 5.25.1 uptime: 3h 34m

Process &lt;span class=&quot;s1&quot;&gt;'codedeploy-agent'&lt;/span&gt;
  status                       OK
  monitoring status            Monitored
  monitoring mode              active
  on reboot                    start
  pid                          29848
  parent pid                   1
  uid                          0
  effective uid                0
  gid                          0
  uptime                       3h 31m
  threads                      2
  children                     1
  cpu                          0.0%
  cpu total                    0.0%
  memory                       0.1% &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;19.6 MB]
  memory total                 0.2% &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;61.1 MB]
  security attribute           &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;null&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  disk write                   0 B/s &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;4 kB total]
  data collected               Thu, 12 Jul 2018 20:37:45
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;php-fpm 차일드 개수가 62개보다 크면 슬랙으로 노티를 준다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@ip-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; monit.d]# cat php-fpm
check process php-fpm with pidfile /run/php-fpm/php-fpm.pid
group php
start program &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/usr/sbin/service php-fpm start&quot;&lt;/span&gt;
stop program &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/usr/sbin/service php-fpm stop&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;children &amp;gt; 62 &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;1 cycles &lt;span class=&quot;k&quot;&gt;then &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/etc/monit/slack_notifications.sh&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;10 restarts within 10 cycles &lt;span class=&quot;k&quot;&gt;then &lt;/span&gt;timeout
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@ip-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; monit.d]# monit status php-fpm
Monit 5.25.1 uptime: 3h 38m

Process &lt;span class=&quot;s1&quot;&gt;'php-fpm'&lt;/span&gt;
  status                       Resource limit matched
  monitoring status            Monitored
  monitoring mode              active
  on reboot                    start
  pid                          7019
  parent pid                   1
  uid                          0
  effective uid                0
  gid                          0
  uptime                       2h 41m
  threads                      1
  children                     64
  cpu                          0.0%
  cpu total                    0.0%
  memory                       0.1% &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;30.2 MB]
  memory total                 1.6% &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;465.2 MB]
  security attribute           &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;null&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  data collected               Thu, 12 Jul 2018 20:42:15
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><category term="codedeploy" /><category term="agent" /><category term="tool" /><category term="monit" /><category term="chkconfig" /><summary type="html">Monit 입문하기</summary></entry><entry><title type="html">AWS EC2 Auto Scaling 구성 시 고려사항</title><link href="https://sori-nori.gitlab.io/youngkyung-done/ASG-2/" rel="alternate" type="text/html" title="AWS EC2 Auto Scaling 구성 시 고려사항" /><published>2018-03-20T00:00:00+00:00</published><updated>2018-03-20T00:00:00+00:00</updated><id>https://sori-nori.gitlab.io/youngkyung-done/ASG-2</id><content type="html" xml:base="https://sori-nori.gitlab.io/youngkyung-done/ASG-2/">&lt;p&gt;ASG 생성에 앞서 서비스 레벨에서 가상환경을 어떻게 최신으로 유지할 것인지에 대해 고민해보아야한다.&lt;br /&gt;
이 점을 고려하기 위해서는 먼저 &lt;strong&gt;가상환경을 원하는 환경으로 세팅하는 방법&lt;/strong&gt;을 생각해보아야한다.&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;가상환경을 원하는 환경으로 세팅하는 방법&lt;/h4&gt;

&lt;p&gt;우리가 로컬 PC에 Git 중앙 Repository를 구성하는 작업을 한다고 생각해보자.&lt;/p&gt;

&lt;h5 id=&quot;os---&quot;&gt;1. os 설치부터 처음부터 구성한다.&lt;/h5&gt;
&lt;h5 id=&quot;git----&quot;&gt;2. Git이 설치된 이미지를 구해서 구성한다.&lt;/h5&gt;

&lt;p&gt;AWS에서 EC2를 원하는 환경으로 세팅하는 방법도 위와 비슷하다.&lt;/p&gt;

&lt;h5 id=&quot;golden-image----&quot;&gt;1. golden image로 인스턴스를 생성한다, 직접 설치한다.&lt;/h5&gt;
&lt;h5 id=&quot;golden-image-----&quot;&gt;2. golden image로 인스턴스를 생성한다, 서버가 설치하도록 설정한다.&lt;/h5&gt;
&lt;h5 id=&quot;git--ami--&quot;&gt;3. Git이 구성된 AMI로 인스턴스를 생성한다.&lt;/h5&gt;

&lt;p&gt;더 많은 방법이 있을 수 있지만, 
직접 설치하는 방법, 서버가 설치하도록 설정하는 방법, 아예 구성된 이미지 기반으로 생성하는 방법 내가 아는 방법은 이 세가지가 전부이다.&lt;br /&gt;
ASG가 어떠한 이유로 ‘확장’이벤트가 발생했을 때, 인스턴스가 생성된다는 것은 이처럼 os만 있든, 어떠한 패키지가 설치되어있든 간에 기준이 되는 이미지가 있다는 것이다.&lt;br /&gt;
그리고 이것을 우리는 ASG 시작 구성에서 설정할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Golden image : 탬플릿, 기준이 되는 이미지.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;그래서 코드 레벨에서 가상환경을 어떻게 최신으로 유지할 것인가.&lt;/h4&gt;

&lt;p&gt;“우리는 CI/CD를 통해서 배포자동화를 구성해놓았으니 고민할 필요없는 문제야.”라고 생각할 엔지니어는 없을 거라 생각이 든다.&lt;br /&gt;
배포자동화로 운용 중인 인스턴스들에 대해서 항상 최신의 코드를 반영하고 있다고 하더라도 트래픽이나 리소스 사용량에 따라 ASG의 확장이벤트가 발생 시 
새로 생성되는 인스턴스에 대해서는 지금이 아닌 ‘이 전에 설정한 이미지’ 기반으로 인스턴스가 생성될 테니 말이다.&lt;br /&gt;
물론, 최신 코드를 기반으로 AMI까지 생성해서 ASG 설정까지 바꿔준다면 논외이다.&lt;/p&gt;

&lt;p&gt;서비스 레벨에서 가상환경을 최신으로 유지하기 위해서는 곧 ASG 확장 이벤트에 의해 이미지가 생성될 때 최신의 코드를 반영해서 올라갈 수 있도록 설정을 해야한다.&lt;/p&gt;

&lt;h4 id=&quot;ec2---&quot;&gt;어떤 설정을 통해 최신의 코드를 반영해서 EC2가 생성될 수 있을까.&lt;/h4&gt;

&lt;h5 id=&quot;user-data-httpsdocsawsamazoncomkokrawsec2latestuserguideuser-datahtml-&quot;&gt;1. &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/user-data.html&quot;&gt;user data(사용자 데이터)&lt;/a&gt;의 활용.&lt;/h5&gt;
&lt;p&gt;기본적으로 인스턴스 시작 시 최초 부팅에서만 실행되는 Shell 혹은 cloud-init 명령입니다.&lt;br /&gt;
사용하는 AMI에 따라 공급업체나 소유주가 실행 방식 및 시기를 지정했을 수도 있습니다. 직접 구성한 golden image가 아니라면 확인이 필요할 것 같습니다.&lt;br /&gt;
간단한 패키지 설치나 WAS 서비스 시작 등에서 유용합니다. 로드밸런서의 Healthy Check가 모든 명령 구성을 완료하기전에 있을 수 있으므로 주의해야합니다.&lt;br /&gt;
모든 스크립트 혹은 명령을 완료하는 시점까지 Healthy Check를 미룰 수 있도록 설정을 해두면 조금 더 견고한 구성이 될 것 같습니다.&lt;br /&gt;
해당 내용은 grace period 라는 키워드로 검색하면 더 많은 자료를 얻을 수 있으며, &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/autoscaling/ec2/userguide/lifecycle-hooks.html&quot;&gt;AWS Docs&lt;/a&gt;에서도 명시된 사항입니다.&lt;/p&gt;

&lt;p&gt;Grace Period를 추가는 CLI와 콘솔에서 가능합니다.&lt;/p&gt;

&lt;h5 id=&quot;lifecycle-hook-actionhttpsdocsawsamazoncomkokrautoscalingec2userguidelifecycle-hookshtml-&quot;&gt;2. &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/autoscaling/ec2/userguide/lifecycle-hooks.html&quot;&gt;lifecycle hook action&lt;/a&gt;의 활용.&lt;/h5&gt;
&lt;p&gt;수명주기 후크는 인스턴스 확장 혹은 축소 이벤트로부터 야기되는 인스턴스의 시작, 종료에서 특정 액션을 취하도록 설정하는 것을 말합니다.&lt;br /&gt;
어떠한 액션이 종료되거나, 설정한 시간이 초과되면 해당 인스턴스는 기존 ASG의 수명주기에 따라 대기상태에서 proceed 상태로 전환됩니다. 
user data에 비하면 견고한 설정이 가능하다는 장점이 있으나, 다소 복잡하다는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;위 글은 &lt;a href=&quot;https://docs.aws.amazon.com&quot;&gt;AWS 설명서&lt;/a&gt;의 문서를 바탕으로 작성되었습니다.&lt;/em&gt;&lt;/p&gt;</content><category term="aws" /><category term="ec2" /><category term="autoscaling" /><category term="asg" /><summary type="html">AWS EC2 Auto Scaling 적용 시 버전 관리에 대한 고민</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://sori-nori.gitlab.io{&quot;feature&quot;=&gt;&quot;aws_logo_smile.png&quot;, &quot;credit&quot;=&gt;&quot;amazon web service&quot;, &quot;creditlink&quot;=&gt;&quot;https://aws.amazon.com&quot;}" /></entry><entry><title type="html">AWS EC2 Auto Scaling 이란?</title><link href="https://sori-nori.gitlab.io/youngkyung-done/ASG-1/" rel="alternate" type="text/html" title="AWS EC2 Auto Scaling 이란?" /><published>2018-03-14T00:00:00+00:00</published><updated>2018-03-14T00:00:00+00:00</updated><id>https://sori-nori.gitlab.io/youngkyung-done/ASG-1</id><content type="html" xml:base="https://sori-nori.gitlab.io/youngkyung-done/ASG-1/">&lt;p&gt;클라우드 환경의 장점은 무엇일까요? 
fail over에 대한 빠른 인지와 처리, 자동화? 비용? 개발 및 인프라 구성에 대한 편의성? 이에 따른 개발 속도와 서비스 생산성 증대?&lt;br /&gt;
많은 장점이 있겠지만, 저는 그중에서도 단연 으뜸은 탄력, 유연성이 아닐까 생각합니다. 
그리고 Auto Scaling은 이러한 클라우드의 장점을 가장 잘 표현할 수 있는 서비스라고 생각합니다.&lt;/p&gt;

&lt;h3 id=&quot;aws-ec2-auto-scalinghttpsdocsawsamazoncomkokrautoscalingec2userguideauto-scaling-benefitshtml&quot;&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/autoscaling/ec2/userguide/auto-scaling-benefits.html&quot;&gt;AWS EC2 Auto Scaling&lt;/a&gt;이란?&lt;/h3&gt;

&lt;p&gt;애플리케이션의 로드를 처리할 수 있는 정확한 수의 EC2 인스턴스 보유를 보장할 수 있습니다. 
최소 인스턴스 수를 지정할 수 있으며, EC2 인스턴스 수는 이 값 아래로는 내려가지 않습니다. 
최대 인스턴스 수를 지정할 수 있으며, EC2 인스턴스 수는 이 값을 넘기지 않습니다. 
조정 정책 값에 따라 EC2 인스턴스가 시작 혹은 종료됩니다.&lt;/p&gt;

&lt;p&gt;이를 통해 다음 이점을 기대할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;내결함성 향상&lt;br /&gt;
비정상 상태일 때를 감지하여 종료한 다음 이를 대체할 인스턴스를 시작합니다. 
혹은 복수의 AZ에 배포하도록 ASG를 구성하였을 때 하나의 AZ가 사용 불가 상태가 되어도, 
다른 AZ에 같은 수의 인스턴스가 새로 배포되어 비교적 비슷한 품질의 서비스를 제공할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;가용성 향상&lt;br /&gt;
현재 트래픽 요구를 처리할 수 있는 적절한 용량을 갖출 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;비용 관리 개선&lt;br /&gt;
필요에 따라 동적으로 인스턴스 수를 확장, 축소하면서 사용한 EC2 인스턴스에 대해서만 비용을 지불하므로 비용 절감을 기대할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;auto-scaling-httpsdocsawsamazoncomkokrautoscalingec2userguideas-account-limitshtml&quot;&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/autoscaling/ec2/userguide/as-account-limits.html&quot;&gt;Auto Scaling 제한&lt;/a&gt;&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;리전 제한&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;리전별 시작 구성: 200&lt;/li&gt;
  &lt;li&gt;리전별 Auto Scaling 그룹: 200&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;auto-scaling--&quot;&gt;Auto Scaling 그룹 제한&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Auto Scaling 그룹당 조정 정책: 50&lt;/li&gt;
  &lt;li&gt;Auto Scaling 그룹당 예약된 작업: 125&lt;/li&gt;
  &lt;li&gt;Auto Scaling 그룹당 수명 주기 후크: 50&lt;/li&gt;
  &lt;li&gt;Auto Scaling 그룹당 SNS 주제: 10&lt;/li&gt;
  &lt;li&gt;Auto Scaling 그룹당 Classic Load Balancer: 50&lt;/li&gt;
  &lt;li&gt;Auto Scaling 그룹당 대상 그룹: 50&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;조정 정책 제한&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;조정 정책당 단계 조정: 20&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;auto-scaling-api-&quot;&gt;Auto Scaling API 제한&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;한 번에 최대 20개의 인스턴스 ID에 AttachInstances, DetachInstances, EnterStandby 및 ExitStandby를 사용할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;한 번에 최대 10개의 로드 밸런서에 AttachLoadBalancers 및 DetachLoadBalancers를 사용할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;한 번에 최대 10개의 대상 그룹에 AttachLoadBalancerTargetGroups 및 DetachLoadBalancerTargetGroups를 사용할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;auto-scaling---1&quot;&gt;Auto Scaling 수명 주기&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://gitlab.com/sori-nori/post-images/raw/master/blog/auto_scaling_lifecycle.png&quot; alt=&quot;Auto Scaling 수명주기&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 그림은 Auto Scaling 수명 주기를 표현한 그림입니다.&lt;/p&gt;

&lt;h4 id=&quot;scale-out&quot;&gt;Scale out&lt;/h4&gt;
&lt;p&gt;Scale out 이벤트가 발생할 수 있는 경우는 다음과 같습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;수동&lt;/li&gt;
  &lt;li&gt;자동 (조정 정책에 따른)&lt;/li&gt;
  &lt;li&gt;예약&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;desired-capacity--&quot;&gt;수동으로 desired capacity를 늘리는 방법&lt;/h5&gt;
&lt;h6 id=&quot;section-2&quot;&gt;1. 콘솔에서 변경하기&lt;/h6&gt;
&lt;p&gt;EC2 콘솔 화면 &amp;gt; 탐색 창(왼쪽 패널)의 Auto Scaling Groups 선택 &amp;gt; 
변경을 하고자하는 Auto Scaling Group 선택 &amp;gt; Details 탭에서 Edit 선택 &amp;gt; Desired에서 한 개씩 원하는 용량 증가하면서 올리기&lt;/p&gt;

&lt;h6 id=&quot;cli--&quot;&gt;2. CLI를 사용하여 변경하기&lt;/h6&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.aws.amazon.com/cli/latest/reference/autoscaling/set-desired-capacity.html&quot;&gt;set-desired-capacity&lt;/a&gt; 명령을 사용하여 변경합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aws autoscaling &lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;-desired-capacity --auto-scaling-group-name my-asg --desired-capacity 2 --honor-cooldown
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;–honor-cooldown 옵션을 지정해주어 기본 동작을 재정의하고 휴지 기간이 완료될 때까지 기다릴 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;휴지 기간?&lt;br /&gt;
Auto Scaling 그룹에 구성할 수 있는 설정으로 이전 조정 활동이 적용되기 전에 인스턴스를 추가로 시작하거나 종료하지 않도록 합니다. 
조정 정책을 사용하여 동적으로 조정하면 휴지 기간이 완료될 때까지 대기한 후에 조정 활동을 재기합니다. 
하지만 수동으로 조정하는 경우 기본적으로 휴지 기간이 적용되지 않습니다. 만일 인스턴스가 비정상적 상태인 경우 휴지 기간이 완료될 때까지 대기하지 않고 비정상적 인스턴스를 교체합니다. 
EC2 인스턴스가 inService 즉, 가용 상태에 도달하기까지 수 분의 시간이 걸립니다. 휴지 기간이 없다면, 조정 정책에 의해 Max 만큼의 인스턴스가 생성될 수 있습니다. 
적절한 휴지 기간은 이러한 상황에 매우 유리하게 작용합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기본 휴지&lt;br /&gt;
기본값은 300초입니다. 단순 조정 정책의 모든 동적 조정 활동에 자동으로 적용되며, 필요한 경우 수동 조정 활동에 적용되도록 요청할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;조정 특정 휴지&lt;br /&gt;
조정 특정 휴지 기간은 기본 휴지 기간보다 우선합니다. 특정 기준 또는 지표에 따라 인스턴스를 종료하는 Scale in 정책에서 자주 사용됩니다.&lt;br /&gt;
인스턴스를 종료할지 여부를 결정하는데 굳이 300초라는 휴지 기간을 둘 필요가 없기 때문에 더 적은 시간을 소요하도록 설정한다면 비용 절감의 효과를 기대할 수 있습니다.&lt;br /&gt;
만일 여러 인스턴스를 시작하는 경우 휴지 기간은 마지막 인스턴스가 시작된 시점에 적용되기 시작합니다. 
수명주기 후크는 휴지 기간에 영향을 미칠 수 있습니다. 휴지 기간은 해당 인스턴스가 Wait(대기) 상태를 벗어날 때까지 시작되지 않습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;httpsdocsawsamazoncomkokrautoscalingec2userguideas-scale-based-on-demandhtml&quot;&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/autoscaling/ec2/userguide/as-scale-based-on-demand.html&quot;&gt;조정 정책을 걸어 자동으로 이벤트를 주는 방법&lt;/a&gt;&lt;/h5&gt;
&lt;h6 id=&quot;section-3&quot;&gt;1. 대상 추적 조정 정책&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;Target tracking scaling&lt;br /&gt;
특정 측정치의 목표 값을 기준으로 그룹의 desired capacity를 늘리거나 줄입니다.
    &lt;ol&gt;
      &lt;li&gt;대상당 애플리케이션 로드 밸런서 요청 수&lt;/li&gt;
      &lt;li&gt;평균 CPU 사용률&lt;/li&gt;
      &lt;li&gt;평균 네트워크 입력 (바이트)&lt;/li&gt;
      &lt;li&gt;평균 네트워크 출력 (바이트)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;section-4&quot;&gt;2. 단계 또는 단순 조정 정책&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Step scaling&lt;br /&gt;
조정 값(임계치) 초과의 정도에 따라 desired capacity를 늘리거나 줄입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Simple scaling&lt;br /&gt;
조정 값에 따라 desired capacity를 늘리거나 줄입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-5&quot;&gt;예약된 시간에 이벤트를 주는 방법&lt;/h5&gt;
&lt;p&gt;서비스 카테고리에 따라 블랙프라이데이, 크리스마스, 명절, 이벤트(마케팅)가 있는 날 등 미리 트래픽 증가를 예상할 수 있는 날이 있을 것입니다.&lt;br /&gt;
동적 설정을 해두었더라도 미리 리소스를 확보해둔다면 좀더 양질의 서비스를 제공할 수 있을 것입니다.&lt;/p&gt;

&lt;h6 id=&quot;section-6&quot;&gt;1. 콘솔에서 생성하기&lt;/h6&gt;
&lt;p&gt;EC2 콘솔 화면 &amp;gt; 탐색 창(왼쪽 패널)의 Auto Scaling Groups 선택 &amp;gt; 
변경을 하고자하는 Auto Scaling Group 선택 &amp;gt; Scheduled Actions 탭에서 Create Scheduled Action 선택 &amp;gt; 
설정 지정 &amp;gt; Create&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Min, Max, Desired Capacity 중 하나 이상을 사용하여 그룹의 크기 지정합니다.&lt;/li&gt;
  &lt;li&gt;Recurrence 옵션을 선택합니다. Once, Cron, Every을 선택할 수 있고 반복일정을 선택한 경우 Start Time 과 End Time을 지정할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;cli---1&quot;&gt;2. CLI를 사용하여 변경하기&lt;/h6&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.aws.amazon.com/cli/latest/reference/autoscaling/put-scheduled-update-group-action.html&quot;&gt;put-scheduled-update-group-action&lt;/a&gt;명령을 사용합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aws autoscaling put-scheduled-update-group-action --scheduled-action-name scaleup-schedule-year --auto-scaling-group-name my-asg --recurrence &lt;span class=&quot;s2&quot;&gt;&quot;0 0 25 12 0&quot;&lt;/span&gt; --desired-capacity 3 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;scale-in&quot;&gt;Scale in&lt;/h4&gt;
&lt;p&gt;Scale in 이벤트가 발생할 수 있는 경우는 위의 Scale out과 동일하게 수동, 자동(설정값에 따른), 예약이 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;stand-by--&quot;&gt;Stand by 상태로 만들기&lt;/h4&gt;
&lt;h5 id=&quot;section-7&quot;&gt;1. 콘솔&lt;/h5&gt;
&lt;p&gt;EC2 콘솔 &amp;gt; 탐색창(왼쪽 패널) Auto Scaling Groups &amp;gt; Group 선택 &amp;gt; Instances 탭에서 인스턴스 선택 &amp;gt; Actions, Set to Standby&lt;/p&gt;

&lt;h5 id=&quot;cli&quot;&gt;2. CLI&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.aws.amazon.com/cli/latest/reference/autoscaling/enter-standby.html&quot;&gt;enter-standby&lt;/a&gt; 이용.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aws autoscaling enter-standby --instance-ids &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;instance_id&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; --auto-scaling-group-name &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;instance_group&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; --should-decrement-desired-capacity
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/blogs/aws/auto-scaling-update-lifecycle-standby-detach/&quot;&gt;Stand by와 Detach의 차이점?&lt;/a&gt;&lt;br /&gt;
Stand by 상태의 인스턴스는 서비스에서는 분리되지만 &lt;strong&gt;여전히 ASG에 의해 관리&lt;/strong&gt;되며, 자동으로 로드밸런서에서 분리됩니다. 
Detach를 할 경우 하나의 독립된 인스턴스가 되며, 다른 ASG에 연결도 가능합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;위 글은 &lt;a href=&quot;https://docs.aws.amazon.com&quot;&gt;AWS 설명서&lt;/a&gt;의 문서를 바탕으로 작성되었습니다.&lt;/em&gt;&lt;/p&gt;</content><category term="aws" /><category term="ec2" /><category term="autoscaling" /><category term="asg" /><summary type="html">AWS EC2 Auto Scaling 이란 무엇인가.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://sori-nori.gitlab.io{&quot;feature&quot;=&gt;&quot;aws_logo_smile.png&quot;, &quot;credit&quot;=&gt;&quot;amazon web service&quot;, &quot;creditlink&quot;=&gt;&quot;https://aws.amazon.com&quot;}" /></entry><entry><title type="html">Jenkins 사용기-1</title><link href="https://sori-nori.gitlab.io/youngkyung-done/Jenkins-1/" rel="alternate" type="text/html" title="Jenkins 사용기-1" /><published>2018-03-02T00:00:00+00:00</published><updated>2018-03-02T00:00:00+00:00</updated><id>https://sori-nori.gitlab.io/youngkyung-done/Jenkins-1</id><content type="html" xml:base="https://sori-nori.gitlab.io/youngkyung-done/Jenkins-1/">&lt;p&gt;빌드, 배포 자동화를 손쉽게 구성할 수 있도록 도와주는 도구 Jenkins 첫번 째 사용기이다.&lt;br /&gt;
두번 째 포스팅이 있을지는 모르겠지만, 만약을 위하여 첫번 째 사용기라 명명하겠다.&lt;br /&gt;
먼저 AWS 환경을 사용하므로 EC2에 젠킨스를 설치하는 방법도 있지만, AMI를 이용하면 손쉽게 구성이 가능하다.&lt;/p&gt;

&lt;p&gt;AMI 퍼블릭 이미지는 EC2 대시보드 왼쪽 패널에서 이미지 &amp;gt; AMI를 누르고, 좌측 상단 [내 소유]로 지정된 드롭다운 메뉴를 누르면 
퍼블릭 이미지를 선택할 수 있다. 해당 메뉴에서 퍼블릭 이미지를 선택한 후, jenkins를 검색하면 bitnami 이미지들을 볼 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;Jenkins의 장점은 확장성인데 여러 플러그인들이 있어서, 필요한 기능을 추가하여 사용하기에 적합하다.&lt;br /&gt;
여러 플러그인들을 설치해놓았지만 그중에서도 유용하게 사용했던 플러그인 몇개를 소개해보겠다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;1. 유용하게 사용한 플러그인&lt;/h2&gt;

&lt;h3 id=&quot;aws-codedeploy-plugin-for-jenkins&quot;&gt;AWS CodeDeploy Plugin for Jenkins&lt;/h3&gt;
&lt;p&gt;빌드 후 조치로 CodeDeploy를 사용할 수 있도록 지원해주는 플러그인이다. &lt;br /&gt;
해당 job이 완료되면 사후 조치로 AWS CodeDeploy 서비스를 추가하여 배포까지 자동으로 할 수 있다.&lt;br /&gt;
배포 실패 시, 가장 최근에 성공한 버전으로 자동 롤백도 가능하다.&lt;br /&gt;
ELB 활성화 기능과 자동 롤백 기능, 블루/그린 배포를 잘 활용하면 서비스 퀄리티를 유지하면서 안전한 배포를 기대할 수 있다.&lt;br /&gt;
과금은 사용한 S3, 인스턴스만큼 지불되니 블루/그린 배포가 굳이 필요하지 않은 서비스라면 오버프로비저닝하지 않도록 주의해야한다.&lt;/p&gt;

&lt;h3 id=&quot;gitlab-hook-plugin&quot;&gt;GitLab Hook Plugin&lt;/h3&gt;
&lt;p&gt;GitLab WebHook을 이용하여 빌드 유발을 가능하게 해주는 플러그인이다.&lt;br /&gt;
GitLab hook은 각종 Git 이벤트 발생 시에 Jenkins에 hook을 날릴 수 있도록 설정할 수 있다.&lt;br /&gt;
예를 들면, push 이벤트나 merge 이벤트 시 해당 job에 어떤 git 이벤트가 있었는지 알려줄 수 있다.&lt;br /&gt;
jenkins는 이러한 hook을 받아서 빌드 유발을 설정한 이벤트라면 job을 시작한다.&lt;/p&gt;

&lt;h3 id=&quot;slack-notification-plugin&quot;&gt;Slack Notification Plugin&lt;/h3&gt;
&lt;p&gt;슬랙 노티 플러그인이다. 따로 노티를 구현할 필요없이 팀슬랙에 Jenkins-CI 앱만 추가하면 사용가능하다.&lt;/p&gt;

&lt;h3 id=&quot;workspace-cleanup-plugin&quot;&gt;Workspace Cleanup Plugin&lt;/h3&gt;
&lt;p&gt;job상태가 stable하게 완료되었다면 해당 workspace를 삭제하도록 사용하고 있다.&lt;/p&gt;

&lt;h3 id=&quot;parameterized-trigger-plugin&quot;&gt;Parameterized Trigger plugin&lt;/h3&gt;
&lt;p&gt;한 개의 job은 하나의 활동만 하도록 설정해놓았다. 예를 들면, gitlab으로부터 코드를 clone하는 job 하나, 그 job이 stable 하게 완료되면 build를 하는 job 하나.&lt;br /&gt;
이런 이유로 하나의 workspace에서 여러 job들이 일련의 활동들을 하도록 설정했어야하는데, 이때 활용한 플러그인이 Shared Workspace이다.&lt;br /&gt;
이와 마찬가지로 앞단의 job과 공유해야하는 여러 파라미터들을 관리하기 위하여 사용한 플러그인이다.&lt;br /&gt;
빌드 후 조치로 다음 job을 트리거 걸면서 파라미터를 넘겨줄 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;build-pipeline-plugin&quot;&gt;Build Pipeline Plugin&lt;/h3&gt;
&lt;p&gt;연결된 job의 상태를 가시성있게 볼 수 있도록 View를 제공해주는 플러그인이다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2. 평일에만 주기적으로 배포하기&lt;/h2&gt;

&lt;p&gt;Jenkins를 이용하면 스케쥴 배포를 이용하여 원하는 시간마다 빌드와 배포를 자동으로 수행할 수 있다.&lt;br /&gt;
사용하고 있지는 않지만, 평일에만 스케쥴 적용을 할 수 있는 플러그인은 없나 찾아본 결과, 현재까지 해당 기능은 없는 것으로 보인다.&lt;br /&gt;
(혹시 잘못된 정보라면, 댓글 남겨주시면 큰 힘이 됩니다. ) &lt;br /&gt;
그래서 있는 기능을 활용해서 어떻게 설정할 수 있을까 고민하다가, Jenkins가 설치된 서버의 cron을 사용하여 curl로 빌드유발을 하도록 설정해보았다.&lt;br /&gt;
빌드 유발에 빌드를 원격으로 유발을 활성화하면 되고, 크론으로 밑의 쉘을 원하는 시간에 실행하도록 하면 된다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash   &lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;TODAY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;date +%a&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;   
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TODAY&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Sat&quot;&lt;/span&gt; -o &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TODAY&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Sun&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;  
&lt;span class=&quot;k&quot;&gt;then
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TODAY&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;is weekend&quot;&lt;/span&gt;  
&lt;span class=&quot;k&quot;&gt;else   
    &lt;/span&gt;curl -X -POST http://&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;jenkins_user&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;:&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;jenkins_token&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;@localhost:8080/job/&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;jenkins_job&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;/buildWithParameters?token&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;jenkins_job_token&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&amp;amp;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;jenkins_param_name&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;jenkins_param_value&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;   
&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;혹시 You must use POST method to trigger builds. 라는 메세지와 함께 버튼을 눌러야 빌드가 되도록 응답이 온다면, job token을 제대로 설정하고 입력했는지 확인해보자.&lt;/p&gt;

&lt;p&gt;(사실 빌드유발을 Build periodically 로 설정하고 크론잡 설정을 평일로 하기만하면 됨.)&lt;/p&gt;</content><category term="ci/cd" /><summary type="html">Jenkins를 사용하여 빌드, 배포 자동화 구축하기</summary></entry><entry><title type="html">AWS S3 Security</title><link href="https://sori-nori.gitlab.io/docs/AWS_S3_Security/" rel="alternate" type="text/html" title="AWS S3 Security" /><published>2018-01-25T00:00:00+00:00</published><updated>2018-01-25T00:00:00+00:00</updated><id>https://sori-nori.gitlab.io/docs/AWS_S3_Security</id><content type="html" xml:base="https://sori-nori.gitlab.io/docs/AWS_S3_Security/">&lt;p&gt;S3에서의 데이터 보호는 전송 중(in Transit), 유휴 시(at Rest) 이렇게 크게 두 항목으로 나눌 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;전송 중의 데이터 보호&lt;/h1&gt;
&lt;p&gt;S3는 HTTPS를 통해 접근된다.&lt;/p&gt;

&lt;p&gt;Amazon S3를 관리하기 위해 AWS 콘솔 서비스를 사용할 때는 SSL/TLS 보안 커넥션이 브라우저와 서비스 콘솔간에 유지된다. 
이 커넥션 내에서의 모든 트래픽은 보호된다.&lt;/p&gt;

&lt;p&gt;S3 API를 직접적이든 간접적이든 사용할 때 SSL/TLS 보안 커넥션이 클라이언트와 S3 종단간에 수립되고,
모든 HTTP 트래픽과 사용자 페이로드 트래픽은 보호되고있는 세션 내에 캡슐화된다.&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;유휴 시 데이터 보호&lt;/h1&gt;
&lt;p&gt;Amazon S3는 유휴 시 데이터 보호를 위한 보안 기능을 제공하고 있다.&lt;/p&gt;

&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Amazon S3 기능&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;Permissions&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;IAM 정책의 버킷 레벨 혹은 오브젝트 레벨에서의 사용 권한을 이용하여 인증되지 않은 액세스로부터 리소스를 보호하고 정보 유출, 데이터 무결성 손상, 삭제를 방지한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;Versioning&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;기본적으로 버전 관리는 비활성화되어 있다. 버전 관리를 활성화하게 되면 변경하거나 삭제된 모든 신규 버전의 오브젝트들에 대해 필요할 경우 손상된 객체를 복원할 수 있다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Replication&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;S3는 오브젝트를 각 리전 내의 모든 가용영역에 복제를 한다. 복제는 시스템 장애의 경우에서도 데이터 및 서비스 가용성을 제공할 수 있다. 그러나 복사본이 저장되는 모든 가용영역에 걸쳐 변경 사항을 복제하기 때문에 우발적인 삭제나 데이터 손상에 관해서는 보호를 제공받지 못한다. S3는 standard redundancy와 reduced redundancy 옵션을 제공하며 이는 오브젝트의 내구성이 중요한가, 가격 절감이 더 중요한가에 따라 선택할 수 있는 옵션이다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Backup&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;S3는 자동 백업대신에 데이터 복제와 버전 관리를 지원한다. 그러나 필요하다면, 애플리케이션 레벨의 기술을 사용하여 S3에 저장된 데이터를 다른 리전 또는 on-premise 로 백업 할 수는 있다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;Encryption-server side&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;서버 사이드 암호화는 최종 사용자에게는 티가 나지 않는다. AWS는 &lt;strong&gt;각각의 오브젝트&lt;/strong&gt;를 위해 고유한 암호화키를 생성한 다음에 &lt;strong&gt;AES-256&lt;/strong&gt;을 사용해서 각각의 오브젝트를 암호화한다. 암호화키는 그런다음에 안전한 위치에 저장된 마스터키로 AES-256을 사용하여 스스로를 암호화 한다. 마스터키는 정기적으로 rotate 된다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;Encryption-client side&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;클라이언트 사이드 암호화는 자체 암호화를 생성하고 관리할 수 있다. 생성한 키는 AWS에 export 되지 않는다. 클라이언트 측 애플리케이션에서는 S3에 업로드하기 전이나 다운로드하고난 후에 데이터를 암호화 혹은 복호화한다.데이터는 오직 클라이언트만 알고있는 키와 알고리즘을 가지고 암호화되어 저장된다. 모든 암호화 알고리즘, 대칭키 또는 비대칭키를 암호화하는데 사용할 수 있고, AWS에서 S3 클라이언트 사이드 암호화 기능을 제공하는 Java SDK를 제공하기도 한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;em&gt;위 글은 &lt;a href=&quot;https://d1.awsstatic.com/whitepapers/Security/AWS_Security_Best_Practices.pdf&quot;&gt;AWS_Security_Best_Practices&lt;/a&gt;의 문서를 바탕으로 작성되었습니다.&lt;/em&gt;&lt;/p&gt;</content><category term="aws" /><category term="S3" /><summary type="html">AWS S3에서의 데이터 보호</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://sori-nori.gitlab.io{&quot;feature&quot;=&gt;&quot;aws_logo_smile.png&quot;, &quot;credit&quot;=&gt;&quot;amazon web service&quot;, &quot;creditlink&quot;=&gt;&quot;https://aws.amazon.com&quot;}" /></entry><entry><title type="html">AWS 한국 사용자 그룹의 구디, 신촌지역 소모임이 신설되다!</title><link href="https://sori-nori.gitlab.io/youngkyung-life/AWSKRUG_gudi/" rel="alternate" type="text/html" title="AWS 한국 사용자 그룹의 구디, 신촌지역 소모임이 신설되다!" /><published>2017-03-15T00:00:00+00:00</published><updated>2017-03-15T00:00:00+00:00</updated><id>https://sori-nori.gitlab.io/youngkyung-life/AWSKRUG_gudi</id><content type="html" xml:base="https://sori-nori.gitlab.io/youngkyung-life/AWSKRUG_gudi/">&lt;p&gt;AWS 한국 사용자 그룹의 구로디지털단지·신촌 지역 소모임이 신설되었습니다.&lt;br /&gt;
강남은 너무 멀었는데, 가까운 곳에 생겨서 너무 좋아요! &lt;br /&gt;
신설되기 기다렸던 소모임이니만큼 2주 전에 있었던 소모임 준비모임에 참여에 이어서 13일에 있었던 제 1회 차 모임에도 참여하고 왔는데요,&lt;br /&gt;
왜 리뷰가 아니고, 다녀온 이야기가 아니고! 사는 얘기 카테고리에 있을까!!!!&lt;br /&gt;
바로 제가 신촌지역 총무가 되었기 때문입니다. 이제 소모임은 당분간 저의 삶이 되지 않을까 싶어요! &lt;br /&gt;
신촌 지역은 참여자가 많지 않아, 당분간 구로디지털단지에 속해서 운영됩니다.&lt;br /&gt;
AWS 사용자들과 소통을 하고 싶으신 분, 공부를 시작하고 싶으신 분들은 많은 참여 부탁드릴게요!&lt;/p&gt;

&lt;p&gt;모임은 &lt;a href=&quot;https://www.meetup.com/ko-KR/awskrug/events/238411836/&quot;&gt;MeetUp 페이지&lt;/a&gt;를 통해 참가신청을 하실 수 있고, AWSKRUG 슬랙에 조인하셔서 #gudi 채널에 들어오시면 됩니다.&lt;/p&gt;

&lt;p&gt;영향력없는 블로거의 영향력없는 홍보였습니다~&lt;/p&gt;</content><category term="awskrug" /><category term="aws" /><summary type="html">AWSKRUG 소모임이 구디, 신촌지역에도 신설되었습니다.</summary></entry><entry><title type="html">남대문 주류시장 “형제상회”에 가다!</title><link href="https://sori-nori.gitlab.io/youngkyung-life/Liquor_Store/" rel="alternate" type="text/html" title="남대문 주류시장 &quot;형제상회&quot;에 가다!" /><published>2017-02-28T00:00:00+00:00</published><updated>2017-02-28T00:00:00+00:00</updated><id>https://sori-nori.gitlab.io/youngkyung-life/Liquor_Store</id><content type="html" xml:base="https://sori-nori.gitlab.io/youngkyung-life/Liquor_Store/">&lt;p&gt;&lt;img src=&quot;https://gitlab.com/sori-nori/post-images/raw/2540e16d08379930dec9ab2027d31257b159002d/blog/MillwoodAndBoodles.jpg&quot; alt=&quot;밀우드와부들스&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러저러한 사정으로 미처 생일을 챙겨주지 못해, 미안했던 친구들을 초대하여 준비차 미리 주류상가에 다녀왔습니다.&lt;br /&gt;
술을 참 잘마시고 좋아라하는 친구들이기 때문에 큰맘먹고 제대로 대접하고자 주류상가를 찾았는데요,&lt;br /&gt;
지인에게 “형제상회”를 추천받아 많은 상점들중에 굳이 형제상회를 찾아갔습니다.&lt;/p&gt;

&lt;p&gt;저도 그랬지만, 남대문 주류상가를 가보지 않으신 분들은 굉장히 규모가 클 것이라고 생각할 것같은데요. 생각보다는 작은 규모였습니다.&lt;br /&gt;
작은 규모의 상점들이 오밀조밀 모여있는 형태였고요.&lt;/p&gt;

&lt;p&gt;저는 진과 리큐어를 칵테일바에서 칵테일로 혹은 샷으로 마셔봤을 뿐이지 이렇게 보틀로 매장에서 구매한것은 처음입니다.&lt;br /&gt;
술을 잘하지 못하는 언니를 위해 베일리스를 하나, 친구들을 위해 진을 하나 사고자 고든스 진과 베일리스를 보여달라고 했습니다.   &lt;br /&gt;
먼저 저 밀우드를 조그마한 종이컵에 조금따라 권해주시더라고요.&lt;br /&gt;
개인적으로 마시는 것이라면 베일리스보다는 조금 저렴한 가격에 비슷한 맛과 향을 즐길 수 있으니 이것은 어떠냐는 말씀과 함께말이죠.&lt;br /&gt;
참 친절하고 적극적으로 구매를 도와주셨습니다.&lt;br /&gt;
부들스는 고든스 진보다는 가격이 조금 더 나가지만 무슨 이유때문인지 행사를 하고있다고 하시더라고요. (말씀을 해주셨는데 잊었네요..)&lt;br /&gt;
친절하신 사장님 덕에 맛있는 술, 두 병을 4만 5천원이라는 저렴한 가격에 업어왔습니다.&lt;/p&gt;

&lt;p&gt;주류상가 가격을 알고나니 앞으로는 술, 사다마셔야 될 것 같아요~! &lt;br /&gt;
형제상회, 추천합니다!&lt;/p&gt;</content><category term="blog" /><summary type="html">진과 리큐어를 하나 샀습니다.</summary></entry></feed>
