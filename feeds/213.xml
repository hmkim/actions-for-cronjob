<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>한글로는 삽잡이, 영어로는 shovelman</title>
<link>https://blog.shovelman.dev/</link>
<description>blog.shovelman.dev</description>
<language>ko</language>
<pubDate>Sun, 12 May 2019 18:46:46 +0900</pubDate>
<generator>TISTORY</generator>
<managingEditor>shovelman</managingEditor>
<image>
<title>한글로는 삽잡이, 영어로는 shovelman</title>
<url>http://cfile1.uf.tistory.com/image/24683F5055825AAE07AF9E</url>
<link>https://blog.shovelman.dev</link>
<description>blog.shovelman.dev</description>
</image>
<item>
<title>6개월 글쓰기 회고</title>
<link>https://blog.shovelman.dev/961</link>
<description>&lt;p&gt;'글또' 라는 모임 2기가 곧 종료된다. (글또 시작 전 다짐 글 : &lt;a href=&quot;https://shovelman.tistory.com/939&quot;&gt;참고&lt;/a&gt;) 한동안 모른 채 하던 블로그를 다시 가동하는 데 도움이 되어줄 것이라 생각하여 시작했고, 돈을 뱉지 않기 위해(?) 월별로 글을 작성하는 데 성공했다. 덕분에 글을 쓸 수 있는 시동을 걸었다고 생각한다. 글또를 시작한 이후로 어떤 글을 써왔는지 생각해봤다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;2018.11월 시작 기준으로 월별 평균 4개씩 글을 썼다. 대부분 공부한 내용을 정리한 글이 대부분이었다. 처음에 목표로 잡은 글은 모두 접근하는 데 실패하여 아쉬운 마음이 든다. 처음 목표로 잡은 주제를 살펴보고 왜 실패했는지 핑계(?)를 대보자.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Spring 기반 오픈소스 하나를 선정하여 분석한다.&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&amp;rarr; 참여하는 Java 기반 오픈소스 분석 스터디가 시작한 뒤 얼마 되지 않아 사라져서... 강제성이 사라져 자연스레 멀어졌다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;분석하며 새롭게 얻은 정보와 삽질기를 정리한다.&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&amp;rarr; 이 부분은 SonarQube라는 솔루션을 분석하며 소기의 목적은 달성했다. 기능별 소스 코드를 분석하며 배울 만한 특징을 정리해보려고 했지만, 단순히 따라가는 수준의 글을 작성하게 되어 아쉬웠다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;분석한 영역을 지금 공부 중인 React + a (아마도 Node.js)로 만들어본다.&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&amp;rarr; 간단하게 도입해보며 사용했지만, 실제로 직접적인 공부 글은 만들지 못했다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;그러면 5개월 동안 어떤 글을 작성하였는가?&lt;/p&gt;
&lt;p&gt;1. 컨퍼런스 후기&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.shovelman.dev/940&quot;&gt;GDG DevFest Seoul 2018 후기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.shovelman.dev/944&quot;&gt;글쓰는 개발자 세미나 후기 (MASOCON 2018)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2. 개발 관련글&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.shovelman.dev/941&quot;&gt;SonarQube 프로젝트를 까보자&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.shovelman.dev/951&quot;&gt;SonarQube는 어떻게 Routing을 할까?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.shovelman.dev/946&quot;&gt;Kubernetes 노드 소개&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.shovelman.dev/947&quot;&gt;Kubernetes를 통한 클라우드 조정&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.shovelman.dev/948&quot;&gt;Kubernetes Engine으로 배포 관리&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.shovelman.dev/949&quot;&gt;Kubernetes Helm 소개&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.shovelman.dev/950&quot;&gt;Kubernetes에 MongoDB 설정&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.shovelman.dev/952&quot;&gt;프로그램을 작성하는 33가지 방법 - Chaptor 1 ~9&lt;/a&gt; (링크는 Chaptor 1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3. 기타&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.shovelman.dev/943&quot;&gt;2018 회고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;되돌아보면 자발적으로 앉아 작성한 경우가 거의 없었다. 스터디 참여(GCP Study Jam, 필독서 스터디)로 공부를 할 수밖에 없는 강제성이 있는 상황에서 글이 나왔다. 이 외에 관심을 가지고 개인적으로 공부하며 나온 글은 얼마 되지 않았다. 5개월 동안 작성된 글을 보면서 공부의 강제성 없이는 개발 관련 글을 쓰지 않았다는 것을 알 수 있었다. (계속 스터디를 찾아 해야할까...)&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;최근에 이것 저것 일을 벌이며 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%83%88%EC%A7%84_%EC%A6%9D%ED%9B%84%EA%B5%B0&quot;&gt;Burn Out&lt;/a&gt; 이 찾아온 것 같은 느낌이 들어, 잠깐은 스터디를 끊고(?) 여유 있게 쓰고 싶은 글을 쓰며 보낼 생각이다. 스터디라는 강제성 없이 개발 글을 써보는 것을 새로운 목표로 삼고 몇 개월 뒤 다시 한번 회고하는 시간을 가져볼까?&amp;nbsp;그때는 조금 더 나아진 모습으로 작성했으면 좋겠다 :)&lt;/p&gt;</description>
<category>- 주절주절</category>
<category>개발글</category>
<category>글쓰기</category>
<category>회고</category>
<author>삽잡이 shovelman</author>
<guid>https://blog.shovelman.dev/961</guid>
<comments>https://blog.shovelman.dev/961#entry961comment</comments>
<pubDate>Sun, 21 Apr 2019 20:12:08 +0900</pubDate>
</item>
<item>
<title>프로그램을 작성하는 33가지 방법 - Chaptor 09 정리</title>
<link>https://blog.shovelman.dev/960</link>
<description>&lt;p&gt;&lt;p&gt;최근 '&lt;a href=&quot;https://wikibook.co.kr/programming-patterns/&quot;&gt;프로그래밍 패턴 (프로그램을 작성하는 33가지 방법)&lt;/a&gt;' 을 읽기 시작했다.&lt;/p&gt;
&lt;p&gt;한 가지의 기능을 Chaptor 마다 각각 다른 패턴으로 구현하여 설명한 책이다.&lt;/p&gt;
&lt;p&gt;모두 비슷하게 동작하지만 환경과 상황이라는 제약 조건 안에서 탄생된 패턴을 직접 코드로 보여주고 있어직접 코딩을 하며 이해하고 있는 중이다.&lt;/p&gt;
&lt;p&gt;책에서 소개하는 한 가지 기능은 '텍스트 파일을 읽어 단어 빈도 출력' 하는 프로그램이다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;가장 빈도가 높은 단어 순으로 그에 해당하는 빈도를 내림차순으로 출력하는 기능을 구현하고 있다.&lt;/p&gt;
&lt;p&gt;이전 Chaptor 보기 :&lt;a href=&quot;https://blog.sapzape.com/957&quot;&gt;프로그램을 작성하는 33가지 방법 - Chaptor 08 정리&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h2&gt;Chaptor 09 유일&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;값이 변환될 대상인 추상화가 존재한다.&lt;/li&gt;
&lt;li&gt;이 추상화는
&lt;ul&gt;
&lt;li&gt;(1) 값을 감싸 그 값을 해당하는 추상화로 만들고&lt;/li&gt;
&lt;li&gt;(2) 자신을 함수와 결합해 일련의 함수를 수립하며&lt;/li&gt;
&lt;li&gt;(3) 최종 결과를 살펴볼 수 있도록 그 값을 풀어내는 연산을 제공한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;규모가 큰 문제를 함수 파이프라인을 함께 결합하고 마지막에 값을 다시 풀어내서 해결한다.&lt;/li&gt;
&lt;li&gt;유일 형식에서는 특히 결합 연산에서 주어진 함수를 단순히 호출하기만 하는데,&lt;br /&gt;이때 연산에서 담고 있는 값을 그 함수에 전달한 다음 그 함수에서 반환된 값을 다시 담는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;여러 함수를 조합하는 것을 넘어 함수를 배열하고 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class TFTheOne:
    def __init__(self, v):
        self._value = v
    
    def bind(self, func):
        self._value = func(self._value)
        return self

    def printme(self):
        print (self._value)

#
# 주 함수
#
TFTheOne(sys.argv[1])\\
.bind(read_file)\\
.bind(normalize)\\
.bind(scan)\\
.bind(remove_stop_words)\\
.bind(frequencies)\\
.bind(sort)\\
.bind(top25_freqs)\\
.printme()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;'TFTheOne' 이라는 클래스를 정의하여 매개변수로 들어온 값을 감싸고(&lt;strong&gt;init&lt;/strong&gt;),
함수 호출을 통해 새로 반환된 결과가 반영된 인스턴스를 반환한다. (bind),&lt;/p&gt;
&lt;p&gt;이 형식은 함수형 프로그래밍 언어인 하스켈의 동일성 모나드(Identity monad)에서 유래했다.&lt;/p&gt;
&lt;p&gt;모나드란?&lt;/p&gt;
&lt;p&gt;일련의 단계로 정의한 계산을 캡슐화한 구조(ex.객체). 모나드에는 두가지 주요 연산이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1) 모나드 안에 값을 감싸는 생성자&lt;/li&gt;
&lt;li&gt;(2) 함수를 인자로 취해 이를 어떤 방법으로 모나드에 결합한 다음,
어떤 모나드를 반환하는 결합 연산&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;대부분 프로그래밍 언어에서는 이 같은 표준적인 함수 합성 형식을 제공해 왔다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;word_freqs = sort(frequencies(remove_stop_words(scan(
		filter_chars_and_normalize(read_file(sys.argv[1]))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h2&gt;맺으며&lt;/h2&gt;&lt;p&gt;메서드 체이닝을 왼쪽에서 오른쪽으로 하는 특성 외 뭐가 있는가?&lt;/p&gt;&lt;p&gt;연쇄적인 계산을 서로 다른 방법으로 할 수 있다는데, 뭔지 모르겠다. 책을 더 읽어보면 말해준다고 한다.&lt;/p&gt;
&lt;p&gt;모나드에 대한 학습이 필요할까?&lt;/p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>- ETC</category>
<category>패턴</category>
<category>프로그래밍 패턴</category>
<author>삽잡이 shovelman</author>
<guid>https://blog.shovelman.dev/960</guid>
<comments>https://blog.shovelman.dev/960#entry960comment</comments>
<pubDate>Sat, 23 Mar 2019 19:45:13 +0900</pubDate>
</item>
<item>
<title>프로그램을 작성하는 33가지 방법 - Chaptor 08 정리</title>
<link>https://blog.shovelman.dev/959</link>
<description>&lt;p&gt;&lt;p&gt;최근 '&lt;a href=&quot;https://wikibook.co.kr/programming-patterns/&quot;&gt;프로그래밍 패턴 (프로그램을 작성하는 33가지 방법)&lt;/a&gt;' 을 읽기 시작했다.&lt;/p&gt;
&lt;p&gt;한 가지의 기능을 Chaptor 마다 각각 다른 패턴으로 구현하여 설명한 책이다.&lt;/p&gt;
&lt;p&gt;모두 비슷하게 동작하지만 환경과 상황이라는 제약 조건 안에서 탄생된 패턴을 직접 코드로 보여주고 있어직접 코딩을 하며 이해하고 있는 중이다.&lt;/p&gt;
&lt;p&gt;책에서 소개하는 한 가지 기능은 '텍스트 파일을 읽어 단어 빈도 출력' 하는 프로그램이다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;가장 빈도가 높은 단어 순으로 그에 해당하는 빈도를 내림차순으로 출력하는 기능을 구현하고 있다.&lt;/p&gt;
&lt;p&gt;이전 Chaptor 보기 :&lt;a href=&quot;https://blog.sapzape.com/955&quot;&gt;프로그램을 작성하는 33가지 방법 - Chaptor 0&lt;/a&gt;&lt;a href=&quot;https://blog.sapzape.com/956&quot;&gt;7 정리&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2&gt;Chaptor 08. 앞으로 차기&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;각 함수에서 추가 매개변수를 취하는데, 맨 마지막 매개변수는 일반적으로 다른 함수를 사용한다.&lt;/li&gt;
&lt;li&gt;현재 함수 처리 마지막에 그 함수 매개변수를 적용한다.&lt;/li&gt;
&lt;li&gt;현재 함수의 출력을 그 함수 매개변수의 입력으로 사용한다.&lt;/li&gt;
&lt;li&gt;규모가 큰 문제를 함수의 파이프라인으로 해결한다. 이때 다음에 적용할 함수를 현재 함수의 매개변수로 사용한다.&lt;/li&gt;
&lt;li&gt;1970년대 이러한 연속성을 처음 사용하기 시작했다. (1964년 해당 내용이 기술되었지만 당시 사람들이 이해하지 못했다고 한다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;연속 전달 형식(CPS; continuation-passing style)&lt;/p&gt;
&lt;p&gt;함수 별 추가 매개변수로 함수 하나를 받는다. (맨 마지막에 호출, 대개 현재 함수의 반환값을 전달함)&lt;/p&gt;
&lt;p&gt;함수는 자신의 호출자에게 값을 반환하지 않는 대신 다른 함수를 계속해서 실행한다.&lt;/p&gt;
&lt;p&gt;주로 연속성에는 흔히 명명된 함수보다는 람다(lambda)라고 하는 익명 함수를 사용한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def read_file(path_to_file, func):
    with open(path_to_file) as f:
        data = f.read()
    func(data, normalize)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;최초 호출은 '공장'의 모든 단계를 완전히 정의할 수 있는 함수 호출 사슬이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;read_file(sys.argv[1], filter_chars)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;br /&gt;&lt;/h3&gt;&lt;h3&gt;시스템 설계 관점에서 본 이러한 형식&lt;/h3&gt;
&lt;p&gt;주로 컴파일러 최적화 목적으로 사용한다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;일부 컴파일러에서는 컴파일하는 프로그램을 이 형식을 사용하는 중간 표현으로 변형함으로써 꼬리 호출(tail call)에 최적화할 수 있다.&lt;/p&gt;
&lt;p&gt;꼬리 호출이란?&lt;/p&gt;
&lt;p&gt;함수에서 가장 마지막 행동으로 취하는 함수 호출이다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;해당 함수 꼬리 위치에서 하는 재귀 호출이며, 언어 처리기에서는 이전 호출의 스택 기록을 모두 안전하게 제거할 수 있다. (꼬리 재귀 최적화)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def f(data):
	if data == []:
			a() # f의 꼬리 위치
	else:
			b(data) # f의 꼬리 위치
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;다른 목적으로는 일반 사례와 실패 사례를 다루는 것이 있다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;함수에서 해당 함수가 성공하거나 실패할 경우에 따라 계속 진행할 수 있게 일반 매개변수에 추가로 두 함수를 매개변수로 받는 것이 편리할 수 있다.&lt;/p&gt;
&lt;p&gt;ex. ajax success, error ??&lt;/p&gt;
&lt;p&gt;단일 스레드 언어에서 입출력(IO), 봉쇄(blocking)를 처리하는 것이다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;해당 언어에서는 프로그램이 IO 연산을 할 때까지 절대 blocking하지 않으며, 어느 시점이 되면 제어를 해당 프로그램의 다른 명령으로 전달한다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;이는 함수에 하나 이상의 추가 함수 인자를 전달해 처리한다.&lt;/p&gt;
&lt;p&gt;ex. node.js에서 사용하는 웹소켓용 자바스크립트 라이브러인 &lt;a href=&quot;http://socket.io&quot;&gt;socket.io&lt;/a&gt; 예제 일부&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function handler (req, res) {
	fs.readFile(__dirname + '/index.html',
	function (err, data) {
		if (err) {
			res.writeHead(500);
			return end('Error loading index.html');
		}

		res.writeHead(200);
		res.end(data);
	});
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;readFile 함수는 원칙적으로 디스크에서 데이터를 읽을 때까지 스레드를 blocking 한다.&lt;/p&gt;
&lt;p&gt;스레드가 없다면 해당 디스크 연산을 완료할 때 까지 아무런 요청을 처리할 수 없음을 의미한다.&lt;/p&gt;
&lt;p&gt;자바스크립트의 설계 원칙은 비동기화인데, 디스크 연산으로 blocking 되더라도 응용 프로그램은 다음 명령을 계속 진행한다.&lt;/p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>- ETC</category>
<category>패턴</category>
<category>프로그래밍 패턴</category>
<author>삽잡이 shovelman</author>
<guid>https://blog.shovelman.dev/959</guid>
<comments>https://blog.shovelman.dev/959#entry959comment</comments>
<pubDate>Sat, 23 Mar 2019 19:43:38 +0900</pubDate>
</item>
<item>
<title>프로그램을 작성하는 33가지 방법 - Chaptor 07 정리</title>
<link>https://blog.shovelman.dev/958</link>
<description>&lt;p&gt;&lt;p&gt;최근 '&lt;a href=&quot;https://wikibook.co.kr/programming-patterns/&quot;&gt;프로그래밍 패턴 (프로그램을 작성하는 33가지 방법)&lt;/a&gt;' 을 읽기 시작했다.&lt;/p&gt;
&lt;p&gt;한 가지의 기능을 Chaptor 마다 각각 다른 패턴으로 구현하여 설명한 책이다.&lt;/p&gt;
&lt;p&gt;모두 비슷하게 동작하지만 환경과 상황이라는 제약 조건 안에서 탄생된 패턴을 직접 코드로 보여주고 있어직접 코딩을 하며 이해하고 있는 중이다.&lt;/p&gt;
&lt;p&gt;책에서 소개하는 한 가지 기능은 '텍스트 파일을 읽어 단어 빈도 출력' 하는 프로그램이다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;가장 빈도가 높은 단어 순으로 그에 해당하는 빈도를 내림차순으로 출력하는 기능을 구현하고 있다.&lt;/p&gt;
&lt;p&gt;이전 Chaptor 보기 :&lt;a href=&quot;https://blog.sapzape.com/955&quot;&gt;프로그램을 작성하는 33가지 방법 - Chaptor 0&lt;/a&gt;&lt;a href=&quot;https://blog.sapzape.com/956&quot;&gt;6 정리&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2&gt;Chaptor 07. 무한 거울&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;문제에서 모든 또는 중요한 부분을 귀납법을 통해 모델링한다.&lt;/li&gt;
&lt;li&gt;즉, 기초 사례(n0) 다음에 n+1 규칙을 명시한다.&lt;/li&gt;
&lt;li&gt;귀납법
&lt;ul&gt;
&lt;li&gt;어떤 현상을 관찰하고 거기서 어떤 원리를 유도해 내는 일&lt;/li&gt;
&lt;li&gt;개별적인 특수한 사실이나 원리로부터 일반적이고 보편적인 명제 및 법칙을 유도해 내는 일&lt;/li&gt;
&lt;li&gt;여기서 귀납법으로 접근했다는 방식의 의미는
&lt;ul&gt;
&lt;li&gt;기초 사례를 하나 이상 풀고&lt;/li&gt;
&lt;li&gt;그 해법이 (Nth) 사례에서 유효하면 (Nth + 1) 사례에서도 유효한 해법을 제공하는 방식으로 일반 목표를 달성한다&lt;br /&gt;&amp;nbsp;→ 컴퓨팅에서는 일반적으로 재귀(recursion)을 통해 표현한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;재귀의 기원은 수학적 귀납법에서 유래한다.&lt;/li&gt;
&lt;li&gt;1950년대 초기 프로그래밍 언어에서는 재귀 호출을 지원하지 않았다.&lt;/li&gt;
&lt;li&gt;1960년대 일부 프로그래밍 언어에서 재귀를 지원했고, 70년대에 이르러 일반적인 요소로 자리 잡았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;빈도 회수를 센다&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def count(word_list, stopword, wordfreqs):
    # 빈 리스트일 때 할 일
    if word_list == []:
        return
    # 귀납적 사례, 단어 목록으로 할 일
    else:
        # 가장 앞 단어를 처리한다
        word = word_list[0]
        if word not in stopword:
            if word in wordfreqs:
                wordfreqs[word] += 1
            else:
                wordfreqs[word] = 1
        # 가장 끝 단어를 처리한다.
        count(word_list[1:], stopword, wordfreqs) ## 재귀
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;귀납법을 사용하여 출력한다&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def wf_print(wordfreqs):
    if wordfreqs == []:
        return
    else:
        (w, c) = wordfreqs[0]
        print (w, '-', c)
        wf_print(wordfreqs[1:]) ## 재귀&lt;/code&gt;&lt;/pre&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>- ETC</category>
<category>패턴</category>
<category>프로그래밍 패턴</category>
<author>삽잡이 shovelman</author>
<guid>https://blog.shovelman.dev/958</guid>
<comments>https://blog.shovelman.dev/958#entry958comment</comments>
<pubDate>Sat, 23 Mar 2019 19:41:32 +0900</pubDate>
</item>
<item>
<title>프로그램을 작성하는 33가지 방법 - Chaptor 06 정리</title>
<link>https://blog.shovelman.dev/957</link>
<description>&lt;p&gt;&lt;p&gt;최근 '&lt;a href=&quot;https://wikibook.co.kr/programming-patterns/&quot;&gt;프로그래밍 패턴 (프로그램을 작성하는 33가지 방법)&lt;/a&gt;' 을 읽기 시작했다.&lt;/p&gt;
&lt;p&gt;한 가지의 기능을 Chaptor 마다 각각 다른 패턴으로 구현하여 설명한 책이다.&lt;/p&gt;
&lt;p&gt;모두 비슷하게 동작하지만 환경과 상황이라는 제약 조건 안에서 탄생된 패턴을 직접 코드로 보여주고 있어직접 코딩을 하며 이해하고 있는 중이다.&lt;/p&gt;
&lt;p&gt;책에서 소개하는 한 가지 기능은 '텍스트 파일을 읽어 단어 빈도 출력' 하는 프로그램이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;가장 빈도가 높은 단어 순으로 그에 해당하는 빈도를 내림차순으로 출력하는 기능을 구현하고 있다.&lt;/p&gt;
&lt;p&gt;이전 Chaptor 보기 :&lt;a href=&quot;https://blog.sapzape.com/955&quot;&gt;프로그램을 작성하는 33가지 방법 - Chaptor 0&lt;/a&gt;&lt;a href=&quot;https://blog.sapzape.com/956&quot;&gt;5 정리&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Chaptor 06. 코드 골프&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;코드 줄 수를 가능한 적게 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;가능한 한 가장 짧은 프로그램을 다양한 프로그래밍 언어로 만드는 기술에는 코드 골프라는 이름이 붙는다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;이 형식의 주된 관심사는 간결함이다. 가능한 적은 코드 줄 수로 프로그램의 기능을 구현하는 것이 목표다.&lt;/p&gt;
&lt;p&gt;일반적으로 언어의 고급 기능과 라이브러리를 사용해 이를 달성한다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;간결함이 유일한 목표라면 이 형식으로 작성된 코드가 이해하기 어려운 명령이 나열된, 매우 긴 몇 줄의 코드가 되는 것은 이해해야한다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#-*- coding: utf-8-*-
#!/usr/bin/env python
import re, sys, collections

stops = open('../stop_words.txt').read().split(',')
words = re.findall('[a-z]{2,}', open(sys.argv[1]).read().lower())
counts = collections.Counter(w for w in words if w not in stops)
for (w, c) in counts.most_common(25):
    print(w, ' - ', c)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;간결함이 일반적으로 많은 프로그래머가 달성하려고 노력하는 좋은 목표이더라도 LOC만을 위한 최적화는 잘못된 목표이며,&amp;nbsp;&lt;/p&gt;&lt;p&gt;문제를 해당 줄 속에 숨겨 진단하기가 매우 어려워질 수 있다.&lt;/p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>- ETC</category>
<category>패턴</category>
<category>프로그래밍 패턴</category>
<author>삽잡이 shovelman</author>
<guid>https://blog.shovelman.dev/957</guid>
<comments>https://blog.shovelman.dev/957#entry957comment</comments>
<pubDate>Sat, 23 Mar 2019 19:39:54 +0900</pubDate>
</item>
</channel>
</rss>