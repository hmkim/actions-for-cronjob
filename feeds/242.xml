<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Jim Kim on Medium]]></title>
        <description><![CDATA[Stories by Jim Kim on Medium]]></description>
        <link>https://medium.com/@jimkimau?source=rss-dcafe9bee493------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/0*n4pn6PKmJz3Azppd.jpg</url>
            <title>Stories by Jim Kim on Medium</title>
            <link>https://medium.com/@jimkimau?source=rss-dcafe9bee493------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Sun, 12 May 2019 23:02:26 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@jimkimau" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[시니어는 아니고 미드급 포지션이었습니다. 시니어 포지션 기술 면접은 주로 프론트앤드 시스템 설계에 관한 질문이 대부분인걸로 알고 있어요. :)]]></title>
            <link>https://medium.com/@jimkimau/%EC%8B%9C%EB%8B%88%EC%96%B4%EB%8A%94-%EC%95%84%EB%8B%88%EA%B3%A0-%EB%AF%B8%EB%93%9C%EA%B8%89-%ED%8F%AC%EC%A7%80%EC%85%98%EC%9D%B4%EC%97%88%EC%8A%B5%EB%8B%88%EB%8B%A4-%EC%8B%9C%EB%8B%88%EC%96%B4-%ED%8F%AC%EC%A7%80%EC%85%98-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91%EC%9D%80-%EC%A3%BC%EB%A1%9C-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%95%A4%EB%93%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84%EC%97%90-%EA%B4%80%ED%95%9C-%EC%A7%88%EB%AC%B8%EC%9D%B4-%EB%8C%80%EB%B6%80%EB%B6%84%EC%9D%B8%EA%B1%B8%EB%A1%9C-%EC%95%8C%EA%B3%A0-%EC%9E%88%EC%96%B4%EC%9A%94-1974a95d4f4d?source=rss-dcafe9bee493------2</link>
            <guid isPermaLink="false">https://medium.com/p/1974a95d4f4d</guid>
            <dc:creator><![CDATA[Jim Kim]]></dc:creator>
            <pubDate>Tue, 24 Apr 2018 03:37:24 GMT</pubDate>
            <atom:updated>2018-04-24T03:37:24.461Z</atom:updated>
            <content:encoded><![CDATA[<p>시니어는 아니고 미드급 포지션이었습니다. 시니어 포지션 기술 면접은 주로 프론트앤드 시스템 설계에 관한 질문이 대부분인걸로 알고 있어요. :)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1974a95d4f4d" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ShoppingCart.prototype.addItem = () => ‘nope!’]]></title>
            <link>https://medium.com/@jimkimau/shoppingcart-prototype-additem-nope-8a7ea8ee8b56?source=rss-dcafe9bee493------2</link>
            <guid isPermaLink="false">https://medium.com/p/8a7ea8ee8b56</guid>
            <dc:creator><![CDATA[Jim Kim]]></dc:creator>
            <pubDate>Fri, 16 Mar 2018 06:29:08 GMT</pubDate>
            <atom:updated>2018-03-16T06:29:08.734Z</atom:updated>
            <content:encoded><![CDATA[<p>ShoppingCart.prototype.addItem = () =&gt; ‘nope!’</p><p>Shoul be</p><p>ShoppingCart.prototype.addProduct = () =&gt; ‘nope!’</p><p>I believe?</p><p>Otherwise a brilliant article, I’ve been using RORO style these days and I love it. 👍</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8a7ea8ee8b56" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[:) 네, 호주 멜번에서 일하고 있습니다.]]></title>
            <link>https://medium.com/@jimkimau/%EB%84%A4-%ED%98%B8%EC%A3%BC-%EB%A9%9C%EB%B2%88%EC%97%90%EC%84%9C-%EC%9D%BC%ED%95%98%EA%B3%A0-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4-89ee6bf4190e?source=rss-dcafe9bee493------2</link>
            <guid isPermaLink="false">https://medium.com/p/89ee6bf4190e</guid>
            <dc:creator><![CDATA[Jim Kim]]></dc:creator>
            <pubDate>Tue, 19 Sep 2017 23:42:32 GMT</pubDate>
            <atom:updated>2017-09-19T23:42:32.192Z</atom:updated>
            <content:encoded><![CDATA[<p>:) 네, 호주 멜번에서 일하고 있습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=89ee6bf4190e" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[제가 엥귤라는 1.x만 했습니다. 이제 정말 2 이상 버젼 공부 좀 해야 할 것 같습니다. 모르는게 너무 많네요 ㅠㅜ 어쨌든 댓글 주셔서 감사합니다~]]></title>
            <link>https://medium.com/@jimkimau/%EC%A0%9C%EA%B0%80-%EC%97%A5%EA%B7%A4%EB%9D%BC%EB%8A%94-1-x%EB%A7%8C-%ED%96%88%EC%8A%B5%EB%8B%88%EB%8B%A4-%EC%9D%B4%EC%A0%9C-%EC%A0%95%EB%A7%90-2-%EC%9D%B4%EC%83%81-%EB%B2%84%EC%A0%BC-%EA%B3%B5%EB%B6%80-%EC%A2%80-%ED%95%B4%EC%95%BC-%ED%95%A0-%EA%B2%83-%EA%B0%99%EC%8A%B5%EB%8B%88%EB%8B%A4-%EB%AA%A8%EB%A5%B4%EB%8A%94%EA%B2%8C-%EB%84%88%EB%AC%B4-%EB%A7%8E%EB%84%A4%EC%9A%94-%E3%85%A0%E3%85%9C-%EC%96%B4%EC%A8%8C%EB%93%A0-%EB%8C%93%EA%B8%80-%EC%A3%BC%EC%85%94%EC%84%9C-%EA%B0%90%EC%82%AC%ED%95%A9%EB%8B%88%EB%8B%A4-5e223d93acd8?source=rss-dcafe9bee493------2</link>
            <guid isPermaLink="false">https://medium.com/p/5e223d93acd8</guid>
            <dc:creator><![CDATA[Jim Kim]]></dc:creator>
            <pubDate>Fri, 16 Jun 2017 12:40:13 GMT</pubDate>
            <atom:updated>2017-06-16T12:40:13.118Z</atom:updated>
            <content:encoded><![CDATA[<p>제가 엥귤라는 1.x만 했습니다. 이제 정말 2 이상 버젼 공부 좀 해야 할 것 같습니다. 모르는게 너무 많네요 ㅠㅜ 어쨌든 댓글 주셔서 감사합니다~</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5e223d93acd8" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[아, 사실 제가 리엑트 보다 백본이랑 엥귤라를 더 오래 했습니다.]]></title>
            <link>https://medium.com/@jimkimau/%EC%95%84-%EC%82%AC%EC%8B%A4-%EC%A0%9C%EA%B0%80-%EB%A6%AC%EC%97%91%ED%8A%B8-%EB%B3%B4%EB%8B%A4-%EB%B0%B1%EB%B3%B8%EC%9D%B4%EB%9E%91-%EC%97%A5%EA%B7%A4%EB%9D%BC%EB%A5%BC-%EB%8D%94-%EC%98%A4%EB%9E%98-%ED%96%88%EC%8A%B5%EB%8B%88%EB%8B%A4-53546a1e10e8?source=rss-dcafe9bee493------2</link>
            <guid isPermaLink="false">https://medium.com/p/53546a1e10e8</guid>
            <dc:creator><![CDATA[Jim Kim]]></dc:creator>
            <pubDate>Fri, 16 Jun 2017 05:07:37 GMT</pubDate>
            <atom:updated>2017-06-16T05:07:37.193Z</atom:updated>
            <content:encoded><![CDATA[<p>아, 사실 제가 리엑트 보다 백본이랑 엥귤라를 더 오래 했습니다. ㅎㅎ 그래서 원래 엥귤라랑 백본에 관련된 질문들도 더 있었는데 그 날 면접관에게 너무 리드 당하면서 면접 봤더니 머리 속이 하얘져서 기억이 다 안나네요 ㅠㅜ<br>네 저도 개인적으로 엥귤라는 컨트롤러든 디렉티브든 DOM을 직접 수정할 필요가 전혀 없다고 생각합니다. 그래서 그 질문에 너무 당황했었습니다. ㅎㅎ</p><p>그리고 정보 알려주셔서 감사합니다. 또 다른 분은 jqLite으로 할 수 있다고 전해 주시더군요. :)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=53546a1e10e8" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[감사합니다. :)]]></title>
            <link>https://medium.com/@jimkimau/%EA%B0%90%EC%82%AC%ED%95%A9%EB%8B%88%EB%8B%A4-877ea7966aea?source=rss-dcafe9bee493------2</link>
            <guid isPermaLink="false">https://medium.com/p/877ea7966aea</guid>
            <dc:creator><![CDATA[Jim Kim]]></dc:creator>
            <pubDate>Fri, 16 Jun 2017 05:02:34 GMT</pubDate>
            <atom:updated>2017-06-16T05:02:34.999Z</atom:updated>
            <content:encoded><![CDATA[<p>감사합니다. :)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=877ea7966aea" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[이번 기술 면접 중 기억나는 질문과 답변들 (프론트엔드)]]></title>
            <link>https://medium.com/@jimkimau/%EC%9D%B4%EB%B2%88-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A4%91-%EA%B8%B0%EC%96%B5%EB%82%98%EB%8A%94-%EC%A7%88%EB%AC%B8%EA%B3%BC-%EB%8B%B5%EB%B3%80%EB%93%A4-712daa9a2dc?source=rss-dcafe9bee493------2</link>
            <guid isPermaLink="false">https://medium.com/p/712daa9a2dc</guid>
            <dc:creator><![CDATA[Jim Kim]]></dc:creator>
            <pubDate>Thu, 15 Jun 2017 04:49:53 GMT</pubDate>
            <atom:updated>2017-06-16T04:46:17.749Z</atom:updated>
            <content:encoded><![CDATA[<blockquote>이번에 이직하게 된 회사 기술 면접에서 주고 받았던 질문과 답변들 중 기억이 나는 몇 가지만 나열해 봤습니다. 제가 맞는 답변을 했는지 아닌지 정확히 모르는 부분도 있으니 염두에 두시고 읽어 주세요. 그리고 틀린 부분있으면 알려주시면 더욱 감사하겠습니다.</blockquote><p><strong>주로 어떤 프레임웍을 사용 했었나?<br></strong>백본, 엥귤라, 리엑트를 사용했었다.</p><p><strong>그 중 가장 선호하는건 어떤거냐?<br></strong>현재는 리액트를 가장 선호 한다. 컴포넌트 개념이 가져다 주는 이점이 많은 것 같다.</p><p><strong>어떤 이점들을 말하는지 설명 해줄 수 있나?<br></strong>조그만 UI 컴포넌트를 만들어 재사용 하는 방법이 아주 간단하고 직관적이다.</p><p><strong>백본과 엥귤라에서도 그런 컴포넌트를 만들 수 있지 않는가?<br></strong>물론 만들 수 있다. 하지만 직관적이라는 관점에서 볼 때 백본이나 엥귤라 모두 리엑트를 따라 갈 수 없다고 생각 한다.<br>그나마 백본이 엥귤라에 비해 차라리 좀 더 직관적인 면이 있다. 엥귤라의 디렉티브는 신텍스도 쉽지 않고 테스트도 쉽지 않은 것 같다.</p><p><strong>그렇다면 테스트 관점에서 다른 프레임웍들은 어떻게 생각 하는가?<br></strong>테스트만 놓고 본다 하더라도 여전히 리액트가 가장 테스트하기 쉬운 것 같다. 엥귤라도 다이제스트 사이클만 아니면 테스트하기 편하다. 오히려 엥귤라가 유닛 테스트는 가장 쉬운 것 같기도 하다.</p><p><strong>무슨 의미인가?<br></strong>나에게 백본 뷰 테스트에서 가장 불편한 점은 유닛 테스트와 인테그레이션 테스트와의 경계를 구분하기가 쉽지 않다는 것이었다. 정말 유닛 테스트만 하고 싶지만 결국 jQuery를 이용한 DOM 수정이 많은 이유로 유닛 테스트만 한다는 것도 쉽지 않다. 그래서 종종 유닛 테스트와 인테그레이션 테스트가 뒤섞인 애매한 테스트 쪽으로 많이 유도 되는 것 같은 느낌이다.<br>그에 비해 엥귤라는 컨트롤러와 템플릿이 확실히 나뉘어져 있고 둘 사이에 연결되는 부분은 추상화 되어 있기 때문에 직접적인 DOM 수정 없이 개발이 가능 하다. 따라서 유닛 테스트가 훨씬 직관적인 것 같다.</p><p><strong>그러면 엥귤라에 직접 DOM을 수정해야 할 때는 어떻게 수정할 수 있나?</strong><br>(여기서는 질문의 의도를 정확하게 파악하지 못했다.)<br>아직까지 직접적으로 DOM을 수정해야 할 필요성을 발견하진 못했다. 하지만 정말 필요하면 jQuery를 의존성으로 주입해서 사용하면 되지 않을까?</p><p><strong>하지만 jQuery를 사용하지 않고도 할 수 있지 않는가?</strong><br>(…) 정확히 무슨 질문인지 잘 모르겠다.</p><p>(면접관) 엥귤라는 그런 DOM 변화 관련된 유닛들을 특별히 다루기 위해서 디렉티브를 만들었다. 디렉티브 단위에서 해당 DOM 변화를 커버해 주면 컨트롤러가 훨씬 깔끔해 진다.</p><p>맞다. 동의 한다.<br>(엥귤라 디렉티브는 UI 엘리먼트를 컴포넌트화 해주는건 맞지만 이것이 jQuery처럼 DOM 노드를 직접 수정하는 것과 무슨 상관이 있는지 질문을 하고 싶었지만, 자칫 더 깊은 질문으로 빠지면 그에 대답할 자신이 없어서 그냥 넘어감)</p><p><strong>그럼 다시 테스트로 돌아가서, 백본의 경우 유닛 테스트와 인테그레이션 테스트의 경계가 모호하다 했고 엥귤라는 유닛 테스트가 편하다 했는데, 리액트는 어떻게 생각 하는가?<br></strong>리액트는 둘 다 약간 섞여 있는 느낌이다. 백본의 경우 jQuery 때문에 Headless 브라우져에 직접 렌더링을 해서 테스트 하고 엥귤라의 경우 유닛 테스트만 할 수 있기에 브라우져 없이 빠르게 테스를 돌릴 수 있다(이 부분은 틀렸을 수 있다). 리액트는 이런 측면에서 유닛 테스트도 쉽게 할 수 있고 원하면 렌더링을 해서 테스트 할 수도 있다.</p><p><strong>리액트는 왜 렌더링을 해서 테스트 하는가? 렌더링 없이 그냥 테스트 할 수 있지 않는가? 어떤 경우에 렌더링을 해서 테스트 하는가?<br></strong>그렇다. 방금 말했듯이 선택이다. 반드시 렌더링을 해야 하는건 아니고 기본적으로 shallow 렌더링만으로 유닛 테스트가 가능하지만, 그리고 대게는 부모 컴포넌트의 테스트에서 자식 컴포넌트를 테스트 할 필요가 없지만, 만약 어떤 이유에서든 자식 컴포넌트까지 모두 테스트할 필요가 있는 경우 풀 렌더링을 해야 테스트가 가능해 진다.<br>하지만 대부분의 경우 풀 렌더링 없이 유닛 테스트와 더불어 몇 가지 경우의 수에 해당하는 DOM tree 스냅샷 테스트만으로 충분하다 생각 한다.</p><p><strong>백본, 엥귤라, 리액트에서 렌더링 하는 방식에 차이가 있는가?<br></strong>개인적 생각에 가장 큰 차이점은 엥귤라와 리액트는 자바스크립트와 HTML이 이미 바인딩되어 있고 왓쳐나 옵져버를 이용해 상태 변화에 따른 자동 리렌더링(re-rendering) 기능이 있는데 반해 백본의 경우 어떤 상태 변화에 따른 자동 리렌더링 기능이 없어서 필요할 때 마다 render() 메소드를 직접 실행 시켜야 한다는 점 인것 같다.</p><p><strong>지난 프로젝트 들에서 state 관리는 어떤식으로 했었나?</strong><br>백본에서는 네임스페이스 변수를 이용해 자체적으로 state 관리를 했고 엥귤라에서는 서비스를 이용해 자체적으로 관리 했다. 리액트는 가장 많이 사용되는 Redux를 사용했다.</p><p><strong>리덕스를 사용하는 목적이 무엇인가? 리액트 자체적으로 이미 state를 관리할 수 있지 않는가?</strong><br>물론 리액트 컴포넌트 별로 각각의 state를 외부 라이브러리 없이 관리 할 수 있는 것은 사실이다. 하지만 컴포넌트 양이 많아지고 컴포넌트 사이에서 state를 쉐어해야 할 경우가 늘어나면 해당 컴포넌트들이 공통으로 가지고 있는 부모 컴포넌트로 소위 말하는 state up lifting을 해야 한다(부모 컴포넌트에서 스테이트를 관리하고 각각의 자식 컴포넌트들에 props로 주입해줘야 다른 두 컴포넌트 사이에 똑같은 상태를 공유할 수 있다는 의미).</p><p>이 방식은 상태를 공유해야하는 컴포넌트들이 많아지면 급속도로 복잡해진다. Redux를 이용하면 state lifting 없이 각각의 컨테이너들에서 store에 바로 접근이 가능하기 때문에 코딩 및 디버깅이 훨씬 쉬워진다.</p><p><strong>&lt;추가 Jun 16&gt;</strong><br><em>이 다음 이어졌던 질문 하나가 더 기억나서 추가 합니다.</em></p><p><strong>어떤식으로 복잡해 진다는 말인가?<br></strong>특히 자식 컴포넌트에서 발생하는 이벤트에 의해 상태가 변경되는 경우 부모 컴포넌트에서 그 상태를 관리하므로 이벤트 핸들러를 부모 컴포넌트에서 정의하고 그 함수를 자식 컴포넌트로 props로 주입해 줘야 하는데, 자식 컴포넌트에 있어야할 비지니스 로직이 부모 컴포넌트에 있음으로 인해 이런 이벤트 핸들러가 많아질수록 정작 부모 컴포넌트와는 상관없는 함수들이 부모 컴포넌트에 너무 많이 쌓이게 되고 디버깅이 점점 힘들어 진다. (하지만 사실 이 부분은 리덕스를 사용해도 어느정도 발생하는 문제이긴 한 것 같음. 다만, 리덕스를 사용하면 그렇지 않을 경우에 비해 이런 복잡성을 많이 줄일 수 있다고 생각함)<br><strong>&lt;/추가&gt;</strong></p><p><strong>리덕스를 이용해 비동기 API 리퀘스트는 어떻게 했는가?<br></strong>thunk 미들웨어를 사용했다. 리덕스 액션 크리에이터는 원래 함수를 반환하지 못하는데, thunk를 이용해 함수를 반환 할 수 있게 된다. 이 때 fetch등을 이용한 Promise를 반환하는 함수를 사용 할 수 있다.</p><p><strong>비동기 함수들은 어떻게 테스트 하는가?</strong><br>Jest, Jasmine, Qunit 등을 사용해 봤는데, 이들 모두 비동기 함수를 임의로 resolve 또는 reject 하는 메소드를 제공 하고 있어서, 비동기 함수를 테스트에서 실행시키고 또 resolve또는 reject 시키면서 콜백 함수를 테스트 한다.</p><p><strong>마지막으로 클로져가 무엇인가?<br></strong>클로져는 함수 안의 또 다른 함수를 이용해 하나의 독립된 스코프를 생성하는 메카니즘이다.</p><p><strong>아무거나 간단한 예를 보여 줄 수 있나?</strong><br>(화이트 보드에 적음)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*L4euIMECQEJWIIzXUOpG-g.png" /></figure><p><strong>코드에 대해 설명 해 줄 수 있는가?<br></strong>counter 함수를 실행 함으로써 add 함수가 반환되는데 중요한 점은 counter 함수가 실행 된 후에도 반환된 내부 함수를 통해 count 변수에 접근이 가능 하다는 것이다. 즉, count 변수와 반환된 함수를 포함하는독립된 환경이 생성된 것이다.</p><p><strong>알겠다. 하지만 그 독립된 환경이라는 것이 가져다 주는 특별한 의미가 있는가?<br></strong>자바스크립트 코어에는 private 함수나 변수의 개념이 없다. 클로져를 이용해 이런 private 함수나 변수를 만들 수 있게 된다.</p><p><strong>실제 코딩하면서 클로져를 많이 사용하는가? 주로 어떤 패턴으로 사용하는가?<br></strong>자바스크립트에서 클로져를 사용하지 않고 모듈들을 만드는 건 거의 불가능 하다 생각 한다. 가장 많이 사용하는 패턴은 모듈 패턴 또는 revealing 모듈 패턴이다. 백본에서 모든 뷰나 모델들이 이 패턴을 사용하기 때문에 가장 익숙한 패턴이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=712daa9a2dc" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[호주 정리해고, 이직 그리고 지난 2년간의 경험]]></title>
            <link>https://medium.com/@jimkimau/%ED%98%B8%EC%A3%BC-%EC%A0%95%EB%A6%AC%ED%95%B4%EA%B3%A0-%EC%9D%B4%EC%A7%81-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%A7%80%EB%82%9C-2%EB%85%84%EA%B0%84%EC%9D%98-%EA%B2%BD%ED%97%98-fad11c7e856?source=rss-dcafe9bee493------2</link>
            <guid isPermaLink="false">https://medium.com/p/fad11c7e856</guid>
            <dc:creator><![CDATA[Jim Kim]]></dc:creator>
            <pubDate>Tue, 13 Jun 2017 15:42:38 GMT</pubDate>
            <atom:updated>2017-06-14T00:37:29.108Z</atom:updated>
            <content:encoded><![CDATA[<p>호주 멜번에서 겪은 갑작스런 정리해고(Redundancy)와 그동안 했던 경험들 그리고 2주간의 이직 과정을 기록해 본다.</p><p>지난 약 2년간(정확히 말하자면 1년 9개월) 스포츠 팀, 클럽 관리용 앱을 운영 중인 스타트업에서 프론트엔드 개발자로 일을 해왔다. 입사 했을 당시 앱은 이미 약 4년 정도 운영해왔던 시점이었고 총 가입자수 35만명에 분당 평균 액티브 유저가 약 250명 정도인 그냥 조그만 어플리케이션 이었다. 하지만 이 회사를 지탱하는 실제 매출은 회사의 다른 제품에서 발생되고 있었고 내가 있었던 팀은 다른 팀의 수입을 이용해 자체적으로 펀딩 되고 있던 깍두기 팀이었다.</p><p>모바일(iOS, 안드로이드) 어플리케이션 위주로 셋업 되어 있었고 모든 중요한 기능들은 모바일에 가장 먼저 적용되었다. 그에 비해 웹은 거의 껍대기에 불과한 수준. 그 땐 몰랐지만 지금 생각해 보니 그 때부터 회사에서 본격적으로 마지막 승부수를 던지기 시작했던 것 같다. 이제 어느정도 유저 베이스도 생겼고 한달 평균 신규 가입자 수가 3만을 넘어 4만에 육박하던 시점이라 그 간 돌려막기 하며 버티던 어플리케이션을 웹 버젼도 모바일 버젼과 동일한 수준으로 끌어 올리고 유료화 하여 수입을 만들어야만 하는 시점이 왔던 것 같다. 그래서 나를 포함한 4명의 개발자들이 2~3개월 차를 두고 팀에 합류하게 되었다. 풀타임 개발자 8명과 디자이너 1명의 팀을 유지하는건 굳이 말하지 않아도 얼마나 큰 비용이 드는지 짐작하리라 생각 한다.</p><p>하지만 그리 서두르진 않았던 것 같다. 나이에 걸맞지 않게 아직 초보 개발자인 나에게 좋은 개발 문화란 무엇인가, 개발자로써 무엇을 고민해야 하는가, 좋은 개발자를 키우기 위해 매니지먼트를 비롯해 선배 개발자들이 무엇을 할 수 있는가 등등 너무나도 값진 경험들을 이 회사를 통해 했다. 급할 수록 돌아가라는 말이 마치 여기서도 통하는 듯 하나 하나 밑돌 들을 깔며 차근차근 쌓아 올렸다.</p><p>웹에서도 그 동안 모바일에서만 지원하던 거의 모든 기능들이 구현 되었고 드디어 작년(2016) 12월 어플리케이션 유료화 에픽이 공지 되었다. 디자이너와 스크럼 마스터의 주도 하에 개발 순서를 정하고 시간 예측을 했고 대망의 유료화 버전을 프로덕션 서버에 올리는 날이 1차 2차 각각 3월 중순과 4월 중순으로 잡혔다. 그리고 호주의 회계년도인 6월 말까지 앱 유료화로 인해 생기는 총 매출의 15%를 개발자들에게 배분한다는 공식 발표도 있었다.</p><p>내가 매니지먼트 라인에서 어떤 말들이 오갔는지 전혀 알지 못하는 입장이라 정확하진 않지만 기억이 맞다면 유료화 청사진이 한참 그려지고 있던 작년 하반기 언제쯤인가 부터 조금씩 팀 분위기가 이상해지기 시작했다. 여지껏 한번 도 그런 적이 없던 스크럼 마스터가 조금씩 무리한 일정을 짜기 시작했다. 모르긴 몰라도 분명 그 윗 선에서 내려오는 압박이 있었겠지.</p><p>해커톤이란 핑계로 2주 스프린트로 만들어야 겨우 만들 것 같은 기능을 그것도 업무와 무관한 실험적 앱도 아닌 이미 계획에 있던 기능을 1주 만에 만들어 보자는 이상한 해커톤을 기획하는가 하면 CI 과정에서 레이턴시로 인해 랜덤하게 생기는 E2E 테스트 에러들을 무시하고 강제로 디플로이하는 경우가 생기기 시작하고, 그 간 개발자들이 개발하는 방식에 일체의 간섭도 없던 딜리버리 매니져까지 가세하여 개발 순서와 시간 예측을 간섭하는 시점까지 오게 되었다.</p><p>그 때 난 이미 결정했다. 유료화 버전 올라가고 인센티브 받고 이직을 해야겠다고.</p><p>돈도 물론 중요했지만 그보다는 그 간 나에게 너무 많은 것을 가르쳐 준 앱 이었기 때문에 뭔가 좀 잘되는것 까지 꼭 보고 나가고 싶었다.</p><p>드디어 대망의 첫 유료화 버전이 프로덕션 서버에 올라갔고 모두들 부푼 기대를 가지고 있었다. 하지만, 결과는 참담 했던것 같다. 결과 수치 마져 결국 공개 되지 않았고, 2주전 6월의 어느 날 잠시 얘기 좀 하자던 스크럼 마스터를 따라 들어간 회의실에 보스가 앉아 있는 것을 보고 순간 올 것이 왔구나 하는 생각이 스치고 지나갔다.</p><p>아니나 다들까 정리해고 하게 되어서 미안하다는 말과 랜덤으로 선택했고 개발자로써 퍼포먼스에 문제가 있다거나 다른 이유가 있어서 대상이 된 건 절대 아니라고 거듭 말했지만 뭐 딱히 믿지는 않는다. 공개적으로 뽑기를 했던것도 아니고 팀원 들 중 유일하게 비 호주인이었던 나와 다른 개발자 이렇게 두 명이 9 명 중에서 랜덤으로 걸렸다곤 절대 생각하진 않는다.</p><p>하지만 그렇다고 인종차별이니 뭐니 그런거 갖다 대고 싶은 생각도 절대 없다. 내가 반대 입장이라도 효율측면에서 영어가 제일 안되는 두 명을 선택하는 건 어찌보면 너무 당연한 일 같아서.</p><p>정작 내가 쥐 똥 만큼 서운 했던건 그래도 지난 2년간 같이 고생한 팀 원인데 고작 2주 통보로 정리해고 한다는 것이었다. 뭐 사실 원래 이 쯤에 이직 할 계획이 이미 있었고 지난 몇 주간 이력서도 다시 재정비해서 다른 회사에 막 지원을 시작했던 참이라 뭐 억울한건 딱히 없지만 그래도 이렇게 고작 2주 통보로 해고 하려면 차라리 미안해 하지나 말던가. 그 뒤로 2주간 스크럼 마스터는 몇 번이나 연락이 왔었다. 회사 알아보는거 잘 되고 있는지, 레퍼런스 잘 해 줄테니 필요하면 언제든 알려 달라고.</p><p>쳇, 여튼 나에게 너무나 많은 것을 가르쳐 주었던 회사에서 해고 당한 화창한 금요일 오후는 태어나서 처음 느껴보는 막막함과 섭섭함으로 가득 찼다.</p><p>원래 한 며칠간 푹 쉬고 다른 회사들을 알아 볼 생각이었다. 호주 법상 일반 해고가 아닌 정리해고의 경우 일 한 년 수에 따라 따로 지급되는 돈이 있다. 내 경우 이 회사에서 일 한지 2년이 안되어서 총 4주치(오래 일할 수록 더 많이 지급 됨) 정리해고 급여가 추가로 지급된다. 통보 기한 2주와 남아있는 휴가 모두 계산하고 4주치 정리해고 급여를 합하니 약 7~8주 정도의 급여가 동시에 통장으로 들어 오게 되는 셈이다. 그리고 회사에선 2주 통보 기간에는 나오지 않아도 된다 했기에 나에겐 총 2개월이란 시간이 있는 것과 마찬가지다. 뭐 또 이렇게 생각하니 2주 통보도 그리 서운할 필요 없겠다는 생각도 들긴 한다.</p><p>여튼 처음엔 2개월이란 시간이 있으니 좀 천천히 움직일 생각이었는데 막상 주말이 지나고 월요일에 와이프 출근 하고 혼자 집에 앉아 있으니 뭔가 어색하기도 하고 겨우 주말 이틀 놀았는데 충분히 논것 같은 착각도 들고 무엇보다 이런 상황에서 진짜 맘 편히 쉴 수 있는 강심장이 아니라는 생각이 드니 차라리 최대한 빨리 이직해서 8주치 급여 받은거나 세이브 하자는 생각이 들기 시작했다.</p><p>잠시 이 회사에 입사했던 시점으로 다시 돌아가서, 첨엔 이 회사가 크게 두 파트가 있었다. 하나는 컨설팅 부서 였는데 약 8~90명 정도의 개발자들이 곳곳의 대기업들에 파견 나가 일 하는 구조이다. 나머지 부서가 본사에 있는 두 개의 팀이었고 난 그 두 팀 중 깍뚜기 팀에 있었었다. 이 회사는 두 명의 창업자가 운영하고 있었는데, 한 명은 컨설팅 쪽을 나머지 한 명은 본사 팀들을 맡고 있었다.<br>내가 입사한지 불과 세 달여 만에 이 회사는 내부적으로 둘로 갈라질 계획이 세워 졌고, 서로 다른 비젼을 가지고 있다는 이유로 작년 회계년도를 기점으로 같은 그룹 내 두 개의 회사로 각각 분리 되었었다.<br>그리고 공교롭게도 나를 인터뷰 했던 제너럴 매니져와 스크럼 마스터도 각각의 회사로 나뉘어졌다.</p><p>이왕 빨리 이직 하기로 맘 먹은 이상 평소 몇 마디 주고 받아 놓았던 잡 에이젼트들에게 바로 이력서 뿌리고 주저할 이유 없이 2년 전 날 인터뷰 했던 같은 그룹 컨설팅 회사의 매니저에게도 연락 했다.<br>며칠 후 보드 미팅이 있는데 그 때나 되어야 지원 가능한 포지션이 생길지 아닐지 알 수 있으니 며칠 후에 연락 주겠다는 매니저 말을 뒤로 하고 약 20여개 정도의 회사에 이력서를 넣게 되었다. 원래 이런식으로 이직하는게 참 좋지 않지만 상황이 상황인지라 물불 가리지 않고 일단 지원하기로 했다.</p><p>서류 불합격 통보를 받은 3곳과 아직도 연락이 없는 10여개 정도의 회사 (아마도 역시 서류 불합격이겠지) 그리고 전화 인터뷰를 진행하고 코딩 시험을 치르고 기술 면접이 잡힌 5 곳의 회사. 이 중 한 곳은 단기 프로젝트라 최종 면접 불참 통보. 4개 중 두 곳은 기술 면접 후 아직 연락이 없는 상황이고(아마 다른 지원자들 면접 진행하고 있는 듯) 2개는 며칠 후에 기술 면접 잡혀 있는 상황.</p><p>그 사이 애타게 기다리던 매니저에게 연락이 왔다. 사실 나 해고 했던 보스에게 연락해서 상황 파악 한 후 같은 그룹인데 우리쪽에서 면접봐도 되겠냐는 확인 받느라 연락이 늦었다며 면접 날짜를 잡아 줬다. 다행히 2년 전 날 인터뷰 했던 매니저라 전화 인터뷰는 생략 하고 대신 절차상 기술 면접과 컬츄럴 면접(한국의 인성 면접 정도로 생각 하면 된다. Cultural 면접을 통해 우리 회사 팀원들과 원만하게 일할 수 있는지 최종적으로 판단하고 거의 기술 면접 후 최종적으로 간단히 확인 하는 경우가 대부분.)은 진행해야 한다고 해서 당연한거 아님? 이라고 대답해 줬다.</p><p>그래서 지난 금요일 컨설팅 회사에서 기술 면접을 진행했다. 근데 왠걸, 기술 면접치고 너무 설렁 설렁 하길래 음 이미 어느정도 검증된? 개발자니 많이 배려해 주는 건가라는 착각을 했다. 그도 그럴것이 면접 후 의논해보고 연락 준다더니 1층 로비 내려가서 커피 주문하고 있는데 전화와서 담주 화욜에 최종 면접 보러 오라고 한다. 뭔가 이렇게 쉽게 해도 되는 건가 하는 의구심마저 드는 상황. 그데 최종 컬츄럴 면접 담당자 이름을 보니 컨설팅 총괄 기술 팀장이다. 뭔가 꼬이고 있다는 느낌적 느낌.</p><p>그리고 어제 그간 해봤던 기술 면접 중 가장 심도 깊고 진빠지는 기술 면접을 했다. 시간은 1시간이 채 안걸렸지만 미친듯 집요하게 파고드는 질문들 때문에 정말 토나올뻔 했다(지난 2주간 있었던 몇 차례의 기술 면접을 통해 받았던 질문들도 정리해서 따로 올려 볼까 한다). 그리고 늦은 오후 무렵에 원하는 연봉에 거의 근접한 연봉으로 오퍼를 받았다.</p><p>이제 서류에 싸인 하고 보내주면 고용 계약은 끝난다. 쫄리면 지는 건데 내 기술에 자신이 더 있다면 시간적 여유가 좀 더 있으니 나머지 면접들 포함 더 좋은 기회를 기다려 보겠지만 난 쫄린다. 무엇보다 왠지 2년 전 처음 입사 했을 때 내가 경험하고 놀랐던, 너무 많은 것을 배웠던 그 개발 문화가 이 회사엔 왠지 그대로 남아 있을 것 같아서 그래서 아침에 눈 뜨면 바로 싸인해서 서류 돌려 보낼 계획이다. 비록 컨설팅 회사라 이 회사 보다는 파견 나가는 회사 분위기가 더 중요하겠지만 좋은 개발 문화는 전염성이 높기 때문에 그리고 적어도 2년 전에는 그 것을 하나의 큰 재산으로 삼던 회사였기에 그 개발 문화를 여전히 유지하고 전파 하고 있길 간절히 바라면서…</p><p>그리고 남아있는 면접에는 예정대로 참석할 예정이다. 어떤 사람들이 어떤 앱으로 어떤 비전과 꿈을 꾸며 개발하고 있는지 나는 너무 궁금하다. 이미 결정난 후 참석하는거라 미안한 마음도 있지만 면접 자리만큼 이런 궁금증을 풀기에 좋은 기회도 없기에...</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fad11c7e856" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[리액트 라우터 v4 간단 예제]]></title>
            <link>https://medium.com/@jimkimau/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%9D%BC%EC%9A%B0%ED%84%B0-v4-%EA%B0%84%EB%8B%A8-%EC%98%88%EC%A0%9C-d1ee363bbe45?source=rss-dcafe9bee493------2</link>
            <guid isPermaLink="false">https://medium.com/p/d1ee363bbe45</guid>
            <category><![CDATA[리액트]]></category>
            <dc:creator><![CDATA[Jim Kim]]></dc:creator>
            <pubDate>Mon, 29 May 2017 11:23:18 GMT</pubDate>
            <atom:updated>2017-05-29T11:27:32.992Z</atom:updated>
            <content:encoded><![CDATA[<p>리액트 라우터 v4의 아주 간단한 예제를 통해 내가 생각하는 이전 버전과의 가장 큰 차이점에 관한 글이다.</p><pre><em>// react-router v3</em><br>render((<br>  <strong>&lt;</strong>Router<strong>&gt;</strong><br>    <strong>&lt;</strong>Route path<strong>=</strong>&quot;/&quot; component<strong>=</strong>{App}<strong>&gt;</strong><br>      <strong>&lt;</strong>IndexRoute component<strong>=</strong>{Home} /&gt;<br>      <strong>&lt;</strong>Route path<strong>=</strong>&quot;about&quot; component<strong>=</strong>{About} /&gt;<br>      <strong>&lt;</strong>Route path<strong>=</strong>&quot;contact&quot; component<strong>=</strong>{Contact} /&gt;<br>    <strong>&lt;</strong>/Route&gt;<br>  <strong>&lt;</strong>/Router&gt;<br>), document.body)</pre><p>위 예제가 아마도 리액트 라우터 v3를 이용해 표현할 수 있는 가장 간단한 예제가 아닐까 생각 한다. 특별한 설명이 필요 없을 정도로 아주 간단 명료하다. &lt;Route /&gt;를 단순 나열 할 수도 있고 &lt;Route /&gt; 안에 &lt;Route /&gt;를 넣을 수도 있다.</p><p>만약 라우터를 이용해 레이아웃을 잡고자 한다면 위 예제처럼 &lt;Route /&gt; 안에 &lt;Route /&gt;를 넣고 바깥 &lt;Route /&gt;에 레이아웃으로 사용 할 컴포넌트를 지정해 주고 내부 &lt;Route /&gt;에는 컨텐츠에 해당하는 컴포넌트를 지정해 주면 된다.</p><p>v4에서 가장 눈에 띄는 차이점은 일단 &lt;Route /&gt;를 다른 &lt;Route /&gt; 안에 더이상 넣을 수 없다는 점이고 또 하나는 &lt;Route /&gt;를 여느 리액트 UI 컴포넌트와 똑같은 방식으로 사용 할 수 있다는 것이다. 즉, &lt;Route /&gt;를 그냥 하나의 리액트 컴포넌트라 생각 하면 된다.</p><pre><em>// react-router v4</em><br>render((<br>  <strong>&lt;</strong>Router<strong>&gt;</strong><br>    <strong>&lt;</strong>Route exact path<strong>=</strong>&quot;/&quot; component<strong>=</strong>{App} /&gt;<br>    <strong>&lt;</strong>Route path<strong>=</strong>&quot;/about&quot; component<strong>=</strong>{About} /&gt;<br>    <strong>&lt;</strong>Route path<strong>=</strong>&quot;/contact&quot; component<strong>=</strong>{Contact} /&gt;<br>  <strong>&lt;</strong>/Router&gt;<br>), document.body)</pre><p>따라서 v3와 달리 v4에서는 일반 리액트 컴포넌트를 &lt;Router&gt;&lt;/Router&gt; 안에서 사용할 수 있게 된다. 위에서 보았던 v3 레이아웃 예제를 v4로 다시 쓴다면 아래와 비슷해 진다.</p><pre><em>// react-router v4</em><br>render((<br>  <strong>&lt;</strong>Router<strong>&gt;</strong><br>    <strong>&lt;</strong>div<strong>&gt;</strong><br>      <strong>&lt;</strong>ul<strong>&gt;</strong><br>        <strong>&lt;</strong>li<strong>&gt;&lt;</strong>Link to<strong>=</strong>&quot;/&quot;<strong>&gt;</strong>Home<strong>&lt;</strong>/Link&gt;&lt;/li<strong>&gt;</strong><br>        <strong>&lt;</strong>li<strong>&gt;&lt;</strong>Link to<strong>=</strong>&quot;/about&quot;<strong>&gt;</strong>Aount<strong>&lt;</strong>/Link&gt;&lt;/li<strong>&gt;</strong><br>        <strong>&lt;</strong>li<strong>&gt;&lt;</strong>Link to<strong>=</strong>&quot;/contact&quot;<strong>&gt;</strong>Contact<strong>&lt;</strong>/Link&gt;&lt;/li<strong>&gt;</strong><br>      <strong>&lt;</strong>/ul&gt;<br>    <strong>&lt;</strong>/div&gt;<br><br>    <strong>&lt;</strong>Route exact path<strong>=</strong>&quot;/&quot; component<strong>=</strong>{Home} /&gt;<br>    <strong>&lt;</strong>Route path<strong>=</strong>&quot;/about&quot; component<strong>=</strong>{About} /&gt;<br>    <strong>&lt;</strong>Route path<strong>=</strong>&quot;/contact&quot; component<strong>=</strong>{Contact} /&gt;<br>  <strong>&lt;</strong>/Router&gt;<br>), document.body)</pre><p>위와 같이 라우터를 설정하면 따로 레이아웃용 컴포넌트를 따로 사용하지 않아도 &lt;ul&gt;에 해당하는 메뉴는 메 페이지마다 렌더링 되게 된다.</p><p>exact의 경우 Home 컴포넌트가 About 또는 Contact 컴포넌트와 함께 렌더링 되는 것을 방지 하기 위한 속성이다. 쉽게 설명 하자면, /about를 / + about. 즉, Home + About 컴포넌트라 생각하면 될 듯 하다.</p><p>또는 아래와 같이 메인 메뉴와 &lt;Route /&gt;들을 다른 파일로 나누어 완전 분리 할 수도 있다.</p><pre><em>// index.js</em><br><br><strong>import</strong> HeaderNav from &#39;HeaderNav&#39;;<br><strong>import</strong> ContentContainer from &#39;ContentContainer&#39;;<br><br>render((<br>  <strong>&lt;</strong>Router<strong>&gt;</strong><br>    <strong>&lt;</strong>HeaderNav <strong>/&gt;</strong><br>    <strong>&lt;</strong>ContentContainer <strong>/&gt;</strong><br>  <strong>&lt;</strong>/Router&gt;<br>), document.body)</pre><pre><em>// HeaderNav.js</em><br><br>render(<br>  <strong>&lt;</strong>div<strong>&gt;</strong><br>    <strong>&lt;</strong>ul<strong>&gt;</strong><br>      <strong>&lt;</strong>li<strong>&gt;&lt;</strong>Link to<strong>=</strong>&quot;/&quot;<strong>&gt;</strong>Home<strong>&lt;</strong>/Link&gt;&lt;/li<strong>&gt;</strong><br>      <strong>&lt;</strong>li<strong>&gt;&lt;</strong>Link to<strong>=</strong>&quot;/about&quot;<strong>&gt;</strong>Aount<strong>&lt;</strong>/Link&gt;&lt;/li<strong>&gt;</strong><br>      <strong>&lt;</strong>li<strong>&gt;&lt;</strong>Link to<strong>=</strong>&quot;/contact&quot;<strong>&gt;</strong>Contact<strong>&lt;</strong>/Link&gt;&lt;/li<strong>&gt;</strong><br>    <strong>&lt;</strong>/ul&gt;<br>  <strong>&lt;</strong>/div&gt;<br>)</pre><pre><em>// ContentContainer.js</em><br><br>render(<br>  <strong>&lt;</strong>div<strong>&gt;</strong><br>    <strong>&lt;</strong>Route exact path<strong>=</strong>&quot;/&quot; component<strong>=</strong>{Home} /&gt;<br>    <strong>&lt;</strong>Route path<strong>=</strong>&quot;/about&quot; component<strong>=</strong>{About} /&gt;<br>    <strong>&lt;</strong>Route path<strong>=</strong>&quot;/contact&quot; component<strong>=</strong>{Contact} /&gt;<br>  <strong>&lt;</strong>/div&gt;<br>)</pre><p>따라서 결론은 리액트 라우터 v4가 이전 버젼과 다른 점은 위에 설명한 것 보다 훨씬 많지만 개인 관점에서 가장 먼저 눈에 띄는 차이점은 v4에서의 &lt;Route /&gt;는 일반 리액트 컴포넌트와 동일한 개념으로 사용할 수 있다는 것이고, 내 경우 v3보다 확실히 레이아웃 사용하는 것도 더 직관적으로 바뀌었고 특히 여러 prop들을 다른 컴포넌트로 패스하는 것이 전 보다 훨씬 편해진 것 같다는 생각이다.</p><blockquote>혹시 잘못된 정보가 있다면 알려주시면 감사하겠습니다.</blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d1ee363bbe45" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[React Router v4 quick example]]></title>
            <link>https://medium.com/@jimkimau/react-router-v4-quick-example-ccf5c4237b43?source=rss-dcafe9bee493------2</link>
            <guid isPermaLink="false">https://medium.com/p/ccf5c4237b43</guid>
            <category><![CDATA[react-router]]></category>
            <category><![CDATA[javascript]]></category>
            <dc:creator><![CDATA[Jim Kim]]></dc:creator>
            <pubDate>Mon, 29 May 2017 08:42:30 GMT</pubDate>
            <atom:updated>2017-05-29T11:25:36.930Z</atom:updated>
            <content:encoded><![CDATA[<p>This is very simple example to show differences between previous versions of React router and v4.</p><pre><em>// react-router v3</em><br>render((<br>  <strong>&lt;</strong>Router<strong>&gt;</strong><br>    <strong>&lt;</strong>Route path<strong>=</strong>&quot;/&quot; component<strong>=</strong>{App}<strong>&gt;</strong><br>      <strong>&lt;</strong>IndexRoute component<strong>=</strong>{Home} /&gt;<br>      <strong>&lt;</strong>Route path<strong>=</strong>&quot;about&quot; component<strong>=</strong>{About} /&gt;<br>      <strong>&lt;</strong>Route path<strong>=</strong>&quot;contact&quot; component<strong>=</strong>{Contact} /&gt;<br>    <strong>&lt;</strong>/Route&gt;<br>  <strong>&lt;</strong>/Router&gt;<br>), document.body)</pre><p>This maybe the bare minimum example of React router v3. The concept here is very straightforward that &lt;Route /&gt; can be listed alongside or nested insdie another &lt;Route /&gt;.</p><p>If you want to use layout you can simply wrap layout, in this case &lt;App /&gt;, around any inner components and you can pass children from the &lt;App /&gt; component to children components.</p><p>In version 4, however, the biggest difference is that you can actually treat those each &lt;Route /&gt; component just as another react UI component.</p><pre><em>// react-router v4</em><br>render((<br>  <strong>&lt;</strong>Router<strong>&gt;</strong><br>    <strong>&lt;</strong>Route exact path<strong>=</strong>&quot;/&quot; component<strong>=</strong>{App} /&gt;<br>    <strong>&lt;</strong>Route path<strong>=</strong>&quot;/about&quot; component<strong>=</strong>{About} /&gt;<br>    <strong>&lt;</strong>Route path<strong>=</strong>&quot;/contact&quot; component<strong>=</strong>{Contact} /&gt;<br>  <strong>&lt;</strong>/Router&gt;<br>), document.body)</pre><p>Being able to treat those &lt;Route /&gt;s mean that you can put any React UI components inside &lt;Router&gt;&lt;/Router&gt;, so to achieve similar layout of v3 example with v4 becomes,</p><pre><em>// react-router v4</em><br>render((<br>  <strong>&lt;</strong>Router<strong>&gt;</strong><br>    <strong>&lt;</strong>div<strong>&gt;</strong><br>      <strong>&lt;</strong>ul<strong>&gt;</strong><br>        <strong>&lt;</strong>li<strong>&gt;&lt;</strong>Link to<strong>=</strong>&quot;/&quot;<strong>&gt;</strong>Home<strong>&lt;</strong>/Link&gt;&lt;/li<strong>&gt;</strong><br>        <strong>&lt;</strong>li<strong>&gt;&lt;</strong>Link to<strong>=</strong>&quot;/about&quot;<strong>&gt;</strong>Aount<strong>&lt;</strong>/Link&gt;&lt;/li<strong>&gt;</strong><br>        <strong>&lt;</strong>li<strong>&gt;&lt;</strong>Link to<strong>=</strong>&quot;/contact&quot;<strong>&gt;</strong>Contact<strong>&lt;</strong>/Link&gt;&lt;/li<strong>&gt;</strong><br>      <strong>&lt;</strong>/ul&gt;<br>    <strong>&lt;</strong>/div&gt;<br><br>    <strong>&lt;</strong>Route exact path<strong>=</strong>&quot;/&quot; component<strong>=</strong>{Home} /&gt;<br>    <strong>&lt;</strong>Route path<strong>=</strong>&quot;/about&quot; component<strong>=</strong>{About} /&gt;<br>    <strong>&lt;</strong>Route path<strong>=</strong>&quot;/contact&quot; component<strong>=</strong>{Contact} /&gt;<br>  <strong>&lt;</strong>/Router&gt;<br>), document.body)</pre><p>The top header navigation will appear on every page as layout. Note that exactattribute in the first &lt;Route /&gt; is to prevent Home component to render together with About or Contact component again. You can think of like / is Home and /about is / + about which becomes Home + About component.</p><p>Furthermore, you can completely separate the header navigation and those three &lt;Route /&gt;s into their own components.</p><pre><em>// index.js</em><br><br><strong>import</strong> HeaderNav from &#39;HeaderNav&#39;;<br><strong>import</strong> ContentContainer from &#39;ContentContainer&#39;;<br><br>render((<br>  <strong>&lt;</strong>Router<strong>&gt;</strong><br>    <strong>&lt;</strong>HeaderNav <strong>/&gt;</strong><br>    <strong>&lt;</strong>ContentContainer <strong>/&gt;</strong><br>  <strong>&lt;</strong>/Router&gt;<br>), document.body)</pre><pre><em>// HeaderNav.js</em><br><br>render(<br>  <strong>&lt;</strong>div<strong>&gt;</strong><br>    <strong>&lt;</strong>ul<strong>&gt;</strong><br>      <strong>&lt;</strong>li<strong>&gt;&lt;</strong>Link to<strong>=</strong>&quot;/&quot;<strong>&gt;</strong>Home<strong>&lt;</strong>/Link&gt;&lt;/li<strong>&gt;</strong><br>      <strong>&lt;</strong>li<strong>&gt;&lt;</strong>Link to<strong>=</strong>&quot;/about&quot;<strong>&gt;</strong>Aount<strong>&lt;</strong>/Link&gt;&lt;/li<strong>&gt;</strong><br>      <strong>&lt;</strong>li<strong>&gt;&lt;</strong>Link to<strong>=</strong>&quot;/contact&quot;<strong>&gt;</strong>Contact<strong>&lt;</strong>/Link&gt;&lt;/li<strong>&gt;</strong><br>    <strong>&lt;</strong>/ul&gt;<br>  <strong>&lt;</strong>/div&gt;<br>)</pre><pre><em>// ContentContainer.js</em><br><br>render(<br>  <strong>&lt;</strong>div<strong>&gt;</strong><br>    <strong>&lt;</strong>Route exact path<strong>=</strong>&quot;/&quot; component<strong>=</strong>{Home} /&gt;<br>    <strong>&lt;</strong>Route path<strong>=</strong>&quot;/about&quot; component<strong>=</strong>{About} /&gt;<br>    <strong>&lt;</strong>Route path<strong>=</strong>&quot;/contact&quot; component<strong>=</strong>{Contact} /&gt;<br>  <strong>&lt;</strong>/div&gt;<br>)</pre><p>That’s it. The bottom line is that &lt;Route /&gt;s can be treated just like any other React UI components and, for me, this makes easier to understand the whole flow and also makes easier to pass props down to other children components.</p><blockquote>Please correct me if I was wrong by any mean.</blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ccf5c4237b43" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>