<?xml version="1.0" encoding="UTF-8" ?>








<rss version="2.0"
	xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:taxo="http://purl.org/rss/1.0/modules/taxonomy/"
	xmlns:activity="http://activitystrea.ms/spec/1.0/" >
<channel>
	
		
			<title><![CDATA[개발자의 하루]]></title>
			<link>https://blog.naver.com/edy5016</link>
			
				<image>
					<url><![CDATA[https://blogpfthumb-phinf.pstatic.net/MjAxODAyMDdfMTI0/MDAxNTE4MDA3MDU4MjAz.dgFc3LzLExZaeq0Ah3mt_PLVjBv3CYe98EowL-wc9v4g.97TJEJH9lbH0VHBdzoye1_L4N59KOFV6N9OyIHxLFoog.JPEG.edy5016/o-APPLE-IPHONE-570.jpg?type=m2]]></url>
					<title><![CDATA[개발자의 하루]]></title>
					<link>https://blog.naver.com/edy5016</link>
				</image>
			
			<description><![CDATA[자기소개를 입력하세요.]]></description>
			<language>ko</language>
			<generator>Naver Blog</generator>
			<pubDate>Mon, 13 May 2019 04:57:25 +0900</pubDate>

			
				<item>
					<author>edy5016</author>
					<category><![CDATA[Spring boot(게시판)]]></category>
					<title><![CDATA[3.스프링 부트-local 소스 코드를 github에 올리기]]></title>
					<link>https://blog.naver.com/edy5016/221281876810</link>
					<guid>https://blog.naver.com/edy5016/221281876810</guid>
					<description><![CDATA[local에 소스 코드가 있는데 개발 서버/ 실 서버에 배포 할 때 바로 하는 것이 아니라 중간에 local에있는 코드를 git/svn(버전관리시스템)에 저장한다음 개발 서버/실 서버에 전달하는 방식으로 배포를 한다. 개발서버나 실서버는 git/svn에서 받아서 반영하면 된다. github 편하게 사용할 수 있는 GUI 툴 --&gt; SourceTree https://ko.atlassian.com/software/sourcetree https://github.com/계정 가입후 로그인. git 이랑 clone 되었다. git에는 모든 코드를 저장할 필요가 없다. maven 과 같은 자동으로 생성되는 빌드들은 github에 올릴 필요가 없다. ignore 기능을 활용해서 제거한다.]]></description>
					<pubDate>Wed, 23 May 2018 01:04:51 +0900</pubDate>
					<tag><![CDATA[스프링부트,springboot,깃허브에올리기,github]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[Spring boot(게시판)]]></category>
					<title><![CDATA[2.스프링 부트 - HTML 페이지 개발]]></title>
					<link>https://blog.naver.com/edy5016/221281779457</link>
					<guid>https://blog.naver.com/edy5016/221281779457</guid>
					<description><![CDATA[BootstrapPom.xml 에 Bootstrap 의존성 추가.jar 파일로 html에 추가.index.htmlform.html]]></description>
					<pubDate>Tue, 22 May 2018 22:35:24 +0900</pubDate>
					<tag><![CDATA[스프링부트,springboot,html개발]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[Spring boot(게시판)]]></category>
					<title><![CDATA[1.스프링 부트 게시판 - 개발 환경 세팅]]></title>
					<link>https://blog.naver.com/edy5016/221281770257</link>
					<guid>https://blog.naver.com/edy5016/221281770257</guid>
					<description><![CDATA[ctrl+n Group - 일반적으로 도메인명 사용. Web, mustache, devtools - 의존성 추가방금설정 된 것은 pom.xml에 설정되어 있다. 이 설정에 따라서 프로젝트들과 의존관계과 있는 것들이 연결이 된다. start를 눌러서 서버 실행가능 resource -&gt; static - &gt; index.htmlLiveReloadLiveReload : sts에서 변경사항이 생겼을때 자동으로 인식해서 자동으로 refresh 하는 역할을 해줌. 이부분 눌러서 커넥션]]></description>
					<pubDate>Tue, 22 May 2018 22:22:52 +0900</pubDate>
					<tag><![CDATA[springboot,스프링부트,개발환경세팅]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[angular  마스터북]]></category>
					<title><![CDATA[7.앵귤러 HTTP]]></title>
					<link>https://blog.naver.com/edy5016/221281218507</link>
					<guid>https://blog.naver.com/edy5016/221281218507</guid>
					<description><![CDATA[■ 목차소개앵귤러는 외부 API를 사용하기 위한 자체 HTTP 라이브러를 제공한다. 외부 서버를 호출 할 때는 사용자가 계속해서 페이지와 소통하도록 하는 것이 중요하다. 다시 말해, HTTP 요청이 외부 서버로부터 리턴될 때까지 페이지가 멈춰 있으면 안된다. 아런 결과를 얻으러면 HTTP 요청이 비동기(asynchronous)여야 한다. 지금껏 비동기 코드는 동기(sychronous) 코드에 비해 다루기가 까다로웠다. 자바스크립트에서 비동기 코드를 처리할 수 있는 방식은 일반적으로 세가지로 나뉜다. 1. 콜백(callback) 2. 프로미스(promise) 3. 옵저버블(observable) 앵귤러 2에서 선호되는 비동기 코드 처리 방식은 옵저버블이다. @angular/common/http.......]]></description>
					<pubDate>Tue, 22 May 2018 02:59:31 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[스프링 기본]]></category>
					<title><![CDATA[스프링 PropertySource]]></title>
					<link>https://blog.naver.com/edy5016/221280995381</link>
					<guid>https://blog.naver.com/edy5016/221280995381</guid>
					<description><![CDATA[Environment에서 살펴 볼 첫 번째 기능은 프로퍼티 값을 제공하는 기능이다. 스프링 컨테이너가 기본으로 사용하는 Environment의 구현체는 다수의 PropertySource로 부터 프로퍼티 값을 읽어온다. 실제 Environment로부터 프로퍼티를 읽어오는 과정은 아래와 같다. ● Environment의 프로퍼티 읽는 과정 o.s.core.env.MutablePropertySources에 두 개 이상의 PropertySource가 등록되어 있을 경우, 프로퍼티 값을 구할 때까지 등록된 순서에 따라 차례대로 확인한다. 예를 들어 이름이 JAVA_HOME인 환경 변수가 존재하고, 위의 그림에서 PropertySource의 우선 순위가 왼쪽이 높고 오른쪽이 낮다고 가정해보자. 이 때 Environment로부터 "JAVA_H.......]]></description>
					<pubDate>Mon, 21 May 2018 20:06:34 +0900</pubDate>
					<tag><![CDATA[스프링,spring,스프링property]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[스프링 기본]]></category>
					<title><![CDATA[스프링 profile 사용]]></title>
					<link>https://blog.naver.com/edy5016/221280993916</link>
					<guid>https://blog.naver.com/edy5016/221280993916</guid>
					<description><![CDATA[보통 로컬 개발 환경, 통합 테스트 환경, 실제 운영 환경은 동일하지 않다. 데이터베이스 IP 정보, 디렉토리 경로, 외부 서비스 URL 등이 동일하지 않다. 단순히 DB IP/사용자 정보만 바뀌는 경우라면, 프로퍼티 파일에 DB정보를 기록하고 &lt;context:property-placeholder&gt;를 사용하면 될 것이다. 이 경우 사용할 DB 정보가 변경되면 프로퍼티 파일에서 값을 알맞게 변경해주면 된다. 하지만, 환경이 바뀔 때마다 프로퍼티 파일을 수정하는 방법은 좋아보이지 않는다. 더 나은 방법은 각 환경에 맞는 설정 정보를 따로 만들고, 환경에 따라 알맞은 설정 정보를 사용하는 것이다. 스프링의 프로필(profile)은 정확하게 이를 위한 기능이다. 스.......]]></description>
					<pubDate>Mon, 21 May 2018 20:04:03 +0900</pubDate>
					<tag><![CDATA[스프링,스프링profile,profile,spring]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[스프링 기본]]></category>
					<title><![CDATA[스프링 Environment 사용]]></title>
					<link>https://blog.naver.com/edy5016/221280992935</link>
					<guid>https://blog.naver.com/edy5016/221280992935</guid>
					<description><![CDATA[스프링 빈은 Environment에 직접 접근해서 Environment가 제공하는 프로퍼티를사용할 수 있다. 스프링 빈 객체에서 Environment에 접근할 필요가 있다면, 다음의 두 가지 방법 중 하나를 사용하면 된다. · o.s.context.EnvironmentAware 인터페이스를 구현 · @Autowired 애노테이션을 Environment 필드에 적용 EnvironmentAware 인터페이스는 다음과 같이 정의되어 있다. 스프링 빈 객체가 EnvironmentAware 인터페이스를 구현하고 있을 경우, 스프링 컨테이너는 빈 객체를 생성한 뒤에 빈 객체의 setEnvironment() 메서드를 호출해서 컨테이너가 사용하는 Environment 객체를 전달한다. 따라서, EnvironmentAware 인터페이스를 구현한 스프링 빈.......]]></description>
					<pubDate>Mon, 21 May 2018 20:02:25 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[스프링 기본]]></category>
					<title><![CDATA[스프링 메시지 국제화 처리]]></title>
					<link>https://blog.naver.com/edy5016/221280991974</link>
					<guid>https://blog.naver.com/edy5016/221280991974</guid>
					<description><![CDATA[웹 어플리케이션은 화면에 다양한 텍스트 메시지를 출력한다. 게시글 목록을 보여 줄 때 각 컬럼에 '제목', '번호'와 같은 메시지를 사용하고, 특정 기능을 성공적으로 수행한 경우에도 그 결과를 메시지로 출력해서 알려 주게 된다. 만약 개발해야 할 어플리케이션이 다국어를 지원해야 한다면, 각 언어에 맞는 메시지가 화면에 출력되어야 할 것이다. 스프링은 메시지의 국제화를 지원하기 위해 o.s.context.MessageSource 인터페이스를 제공하고 있다. MessageSource 인터페이스에는 지역 및 언어에 따라 알맞은 메시지를 구할 수 있는 메서드가 다음과 같이 정의되어 있다. 각 getMessage() 메서드는 Locale에 따라 알맞은 메시지를 리턴한다.......]]></description>
					<pubDate>Mon, 21 May 2018 20:00:49 +0900</pubDate>
					<tag><![CDATA[스프링,국제화처리,국제화,spring]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[스프링 기본]]></category>
					<title><![CDATA[스프링 빈 객체의 라이프사이클]]></title>
					<link>https://blog.naver.com/edy5016/221280377077</link>
					<guid>https://blog.naver.com/edy5016/221280377077</guid>
					<description><![CDATA[스프링 컨테이너는 빈 객체를 생성하고, 프로퍼티를 할당하고, 초기화를 수행하고 사용이 끝나면 소멸시키는 일련의 과정을 관리한다. 예를 들어 데이터베이스에 대한 커넥션 풀을 제공하는 빈은 사용되기 전에 일정 개수의 커넥션을 연결해야 하고, 어플리케이션 종료 시점에는 열려 있는 커넥션을 모두 닫아야 하는데 스프링 컨테이너는 이런 커넥션 생성과 종료 시점을 제어하게 된다. 스프링 컨테이너는 다음의 두 가지 방식을 이용해서 빈의 라이프사이클을 관리할 수 있다. ○ 스프링이 제공하는 특정 인터페이스를 상속받아 빈을 구현한다. ○ 스프링 설정에서 특정 메서드를 호출하라고 지정한다. 스프링은 라이프사이클에 특화된 인터페.......]]></description>
					<pubDate>Mon, 21 May 2018 01:50:49 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[스프링 기본]]></category>
					<title><![CDATA[스프링 빈 객체 범위(Scope)]]></title>
					<link>https://blog.naver.com/edy5016/221280376150</link>
					<guid>https://blog.naver.com/edy5016/221280376150</guid>
					<description><![CDATA[스프링의 빈은 범위(scope)를 갖는데 , 주요 범위에는 다음의 두 가지가 있다. · 싱글톤(singleton) 범위 · 프로토타입(prototype) 범위 이 범위는 생성되는 빈 객체의 생명주기와 관련되는데, 이 절에서는 이 범위에 대한 내용을 알아볼 것이다. 위에 언급한 두 개의 범위 외에 웹 어플리케이션에서 사용되는 요청(request) 범위와 세션(session) 범위가 존재하는데 실제 프로젝트에서는 잘 사용되지 않는 편이다. 1. 싱글톤 범위별도 설정을 하지 않을 경우 스프링은 빈 객체를 한 번만 생성한다. getBean() 메서드를 두 번 이상 호출해서 빈을 구하면 매번 동일한 빈 객체를 리턴한다. 예를 들어 아래와 같은 XML 설정이 있다고 하자. 이 XML .......]]></description>
					<pubDate>Mon, 21 May 2018 01:47:49 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[angular  마스터북]]></category>
					<title><![CDATA[6.앵귤러 의존성주입]]></title>
					<link>https://blog.naver.com/edy5016/221278417195</link>
					<guid>https://blog.naver.com/edy5016/221278417195</guid>
					<description><![CDATA[■ 목차프로그램의 덩치가 커지면 앱의 특정 부분이 다른 모듈과 소통할 수밖에 없다. 모듈 A에 모듈 B가 반드시 필요할 때, B를 가리켜 A의 의존성(dependency)이라고 부른다. 이런 의존성 파일에 액세스할 때는 단순히 import를 사용하는 것이 일반적이다. 대부분 import만으로도 충분하다. 하지만 좀 더 정교한 방법으로 의존성 파일들을 제공받아야 할 때도 있다. ○ 테스트 동안 B의 구현을 MockB로 대체한다. ○ B 클래스의 '단일 인스턴스'를 앱 전체에서 공유한다.(예: 싱글턴 패턴) ○ B 클래스의 '새 인스턴스'를 사용할 때마다 만든다(예: 팩토리 패턴) 의존성 주입은 이런 문제들을 해결할 수 있다. 의존성 주입(Dependency Injectio.......]]></description>
					<pubDate>Fri, 18 May 2018 02:27:03 +0900</pubDate>
					<tag><![CDATA[의존성주입,의존성,앵귤러,앵귤러마스터북,angular,앵귤러의존성주입]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[angular  마스터북]]></category>
					<title><![CDATA[5.앵귤러 폼(form)]]></title>
					<link>https://blog.naver.com/edy5016/221278396941</link>
					<guid>https://blog.naver.com/edy5016/221278396941</guid>
					<description><![CDATA[■ 목차폼은 중요하다. 그리고 복잡하다.○ 폼 입력은 데이터를 페이지나 서버에서 수정하기 위한 것이다. ○ 변경된 내용이 페이지 내 다른 곳에 반영되기도 해야 한다. ○ 사용자는 정해진 구조대로만 입력하지 않는다. 따라서 입력 내용을 검증해야 한다. ○ 입력 예시나 혹시 있을지 모를 오류를 분명하게 적시하는 UI여야 한다. ○ 종속된 필드가 있으면 로직이 복잡해진다. ○ DOM 셀렉터에 의존하지 않고 폼을 테스트할 수 있어야 한다. 다행히 앵귤러는 이와 관련한 각종 도구를 지원하고 있다. ● FormControl은 폼에 입력된 내용을 캡슐화하고, 이를 처리할 수 있는 객체를 제공한다. ● Validator는 일정 방식에 따라 입력 내용을 검.......]]></description>
					<pubDate>Fri, 18 May 2018 00:54:59 +0900</pubDate>
					<tag><![CDATA[angular,앵귤러,앵귤러폼,앵귤러form]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[angular  마스터북]]></category>
					<title><![CDATA[4.앵귤러 내장 지시자]]></title>
					<link>https://blog.naver.com/edy5016/221274970953</link>
					<guid>https://blog.naver.com/edy5016/221274970953</guid>
					<description><![CDATA[■ 목차ngIfngIf 지시자는 어떤 요소를 일정 조건에 따라 표시하거나 숨길 때 사용한다. 여기서 조건은 지시자에 전달하는 '수식'의 결과에 따라 저장된다. 수식의 결과가 거짓이면 해당 요소는 DOM에서 제거된다. ngSwitch경우에 따라서는 일정 조건에 따라 서로 다른 요소들을 렌더링 해야 한다. 이런 상황에서 다음처럼 ngIf를 몇 번씩 사용해도 문제는 없다. 이런 상황 떄문에 앵귤러는 ngSwitch 지시자를 도입했다. ngSwitch 지시자는 프로그래밍 언어의 switch문과 그개념이 서로 같다. ○ 알고 있는 결과를 기술한다. 이때 ngSwitchCase 지시자를 사용한다. ○ 아직 모르는 다른 경우들은 ngSwitchDefault로 처리한다. app/src//src/app/n.......]]></description>
					<pubDate>Sun, 13 May 2018 23:24:12 +0900</pubDate>
					<tag><![CDATA[앵귤러,angular,지시자,앵귤러지시자]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[oracle]]></category>
					<title><![CDATA[PCTFREE와 PCTUSED]]></title>
					<link>https://blog.naver.com/edy5016/221271600181</link>
					<guid>https://blog.naver.com/edy5016/221271600181</guid>
					<description><![CDATA[ * PCTFREE란?- 사용가능한 Block 공간 중에서 데이터 Row의 Update 등 데이터의 변경에 대비해서 확보해 놓은 BLOCK의 %값입니다. - PCTFREE의 Default 값은 10%입니다. - PCTFREE와 PCTUSED의 합이 100을 초과하지 않는 범위내에서 0~99까지 값을 PCTFREE값을 PCTFREE 값으로 사용할 수 있습니다. ● PCTFREE가 적을 경우 - 기존 테이블 행 갱신에 의한 확장을 위해 적은 공간을 확보합니다. - 많은 ROW가 한 BLOCK안에 INSERT 될 수 있습니다. - 수정이 적은 SEGMENT에 적합합니다. ● PCTFREE가 클 경우 - BLOCK당 적은 ROW가 INSERT됩니다. 즉 같은 ROW를 입력하기 위해 많은 BLOCK이 필요합니다. - ROW의 조각을 자주 CACHING할 필요가 없.......]]></description>
					<pubDate>Wed, 09 May 2018 14:56:16 +0900</pubDate>
					<tag><![CDATA[oracle,db,pctfree,pctused]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[spring]]></category>
					<title><![CDATA[스프링 - 커스텀 어노테이션]]></title>
					<link>https://blog.naver.com/edy5016/221267980575</link>
					<guid>https://blog.naver.com/edy5016/221267980575</guid>
					<description><![CDATA[]]></description>
					<pubDate>Fri, 04 May 2018 12:15:01 +0900</pubDate>
					<tag><![CDATA[커스텀어노테이션생성,스프링]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[angular  마스터북]]></category>
					<title><![CDATA[3.앵귤러 컴포넌트]]></title>
					<link>https://blog.naver.com/edy5016/221267396988</link>
					<guid>https://blog.naver.com/edy5016/221267396988</guid>
					<description><![CDATA[■ 목차 애플리케이션앵귤러 애플리케이션은 컴포넌트의 트리 구조, 그 이상도 그 이하도 아니다. 이 트리 구조의 루트에서 최상위 컴포넌트는 애플리케이션 그 자체다. 브라우저가 앱을 시동(booting, 다시말해 '부트스트래핑') 할 때 렌덩링하는 것이 바로 애플리케이션이다. ○ 컴포넌트의 장점 중 하나로 컴포넌트는 구성 가능(composable) 하다는 점을 들 수 있다. ○ 컴포넌트는 구조적으로 부모/자식 트리 관계이므로 각 컴포넌트는 자신의 자식 컴포넌트를 재귀적으로 렌더링한다. 제품 모델앵귤러에서 가장 핵심적인 사실은 특정 모델 라이브러리가 규정되지 않는다. 앵귤러는 서로 다른 여러 모델((과 데이터 아키텍처)의 지원이 유연.......]]></description>
					<pubDate>Thu, 03 May 2018 17:38:11 +0900</pubDate>
					<tag><![CDATA[angular3장,angular,컴포넌트,component,앵귤러컴포넌트]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[spring&#160;기본]]></category>
					<title><![CDATA[스프링 빈 객체 범위(Scope)]]></title>
					<link>https://blog.naver.com/edy5016/221235632234</link>
					<guid>https://blog.naver.com/edy5016/221235632234</guid>
					<description><![CDATA[스프링의 빈은 범위(scope)를 갖는데 , 주요 범위에는 다음의 두 가지가 있다. · 싱글톤(singleton) 범위 · 프로토타입(prototype) 범위 이 범위는 생성되는 빈 객체의 생명주기와 관련되는데, 이 절에서는 이 범위에 대한 내용을 알아볼 것이다. 위에 언급한 두 개의 범위 외에 웹 어플리케이션에서 사용되는 요청(request) 범위와 세션(session) 범위가 존재하는데 실제 프로젝트에서는 잘 사용되지 않는 편이다. 1. 싱글톤 범위별도 설정을 하지 않을 경우 스프링은 빈 객체를 한 번만 생성한다. getBean() 메서드를 두 번 이상 호출해서 빈을 구하면 매번 동일한 빈 객체를 리턴한다. 예를 들어 아래와 같은 XML 설정이 있다고 하자. 이 XML .......]]></description>
					<pubDate>Fri, 23 Mar 2018 15:40:40 +0900</pubDate>
					<tag><![CDATA[스프링,개발자의하루,빈객체범위,scope,빈scope,spring,sts,eclipse]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[javascript 개념]]></category>
					<title><![CDATA[프로토타입 이해하기]]></title>
					<link>https://blog.naver.com/edy5016/221235386688</link>
					<guid>https://blog.naver.com/edy5016/221235386688</guid>
					<description><![CDATA[https://medium.com/@bluesh55/javascript-prototype-이해하기-f8e67c286b67]]></description>
					<pubDate>Fri, 23 Mar 2018 10:34:21 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[spring&#160;기본]]></category>
					<title><![CDATA[스프링 빈 객체의 라이프사이클]]></title>
					<link>https://blog.naver.com/edy5016/221234919074</link>
					<guid>https://blog.naver.com/edy5016/221234919074</guid>
					<description><![CDATA[스프링 컨테이너는 빈 객체를 생성하고, 프로퍼티를 할당하고, 초기화를 수행하고 사용이 끝나면 소멸시키는 일련의 과정을 관리한다. 예를 들어 데이터베이스에 대한 커넥션 풀을 제공하는 빈은 사용되기 전에 일정 개수의 커넥션을 연결해야 하고, 어플리케이션 종료 시점에는 열려 있는 커넥션을 모두 닫아야 하는데 스프링 컨테이너는 이런 커넥션 생성과 종료 시점을 제어하게 된다. 스프링 컨테이너는 다음의 두 가지 방식을 이용해서 빈의 라이프사이클을 관리할 수 있다. ○ 스프링이 제공하는 특정 인터페이스를 상속받아 빈을 구현한다. ○ 스프링 설정에서 특정 메서드를 호출하라고 지정한다. 스프링은 라이프사이클에 특화된 인터페.......]]></description>
					<pubDate>Thu, 22 Mar 2018 17:52:29 +0900</pubDate>
					<tag><![CDATA[개발자의하루,스프링빈,스프링,스프링라이프사이클,lifecycle]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[spring&#160;기본]]></category>
					<title><![CDATA[스프링 MessageSource를 이용한 메시지 국제화 처리]]></title>
					<link>https://blog.naver.com/edy5016/221234846871</link>
					<guid>https://blog.naver.com/edy5016/221234846871</guid>
					<description><![CDATA[웹 어플리케이션은 화면에 다양한 텍스트 메시지를 출력한다. 게시글 목록을 보여 줄 때 각 컬럼에 '제목', '번호'와 같은 메시지를 사용하고, 특정 기능을 성공적으로 수행한 경우에도 그 결과를 메시지로 출력해서 알려 주게 된다. 만약 개발해야 할 어플리케이션이 다국어를 지원해야 한다면, 각 언어에 맞는 메시지가 화면에 출력되어야 할 것이다. 스프링은 메시지의 국제화를 지원하기 위해 o.s.context.MessageSource 인터페이스를 제공하고 있다. MessageSource 인터페이스에는 지역 및 언어에 따라 알맞은 메시지를 구할 수 있는 메서드가 다음과 같이 정의되어 있다. 각 getMessage() 메서드는 Locale에 따라 알맞은 메시지를 리턴한다.......]]></description>
					<pubDate>Thu, 22 Mar 2018 16:26:27 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[spring&#160;기본]]></category>
					<title><![CDATA[Environment를 스프링 빈에서 사용하기]]></title>
					<link>https://blog.naver.com/edy5016/221225026646</link>
					<guid>https://blog.naver.com/edy5016/221225026646</guid>
					<description><![CDATA[스프링 빈은 Environment에 직접 접근해서 Environment가 제공하는 프로퍼티를사용할 수 있다. 스프링 빈 객체에서 Environment에 접근할 필요가 있다면, 다음의 두 가지 방법 중 하나를 사용하면 된다. · o.s.context.EnvironmentAware 인터페이스를 구현 · @Autowired 애노테이션을 Environment 필드에 적용 EnvironmentAware 인터페이스는 다음과 같이 정의되어 있다. 스프링 빈 객체가 EnvironmentAware 인터페이스를 구현하고 있을 경우, 스프링 컨테이너는 빈 객체를 생성한 뒤에 빈 객체의 setEnvironment() 메서드를 호출해서 컨테이너가 사용하는 Environment 객체를 전달한다. 따라서, EnvironmentAware 인터페이스를 구현한 스프링 빈.......]]></description>
					<pubDate>Fri, 09 Mar 2018 09:48:32 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[spring&#160;기본]]></category>
					<title><![CDATA[스프링 profile]]></title>
					<link>https://blog.naver.com/edy5016/221224411429</link>
					<guid>https://blog.naver.com/edy5016/221224411429</guid>
					<description><![CDATA[보통 로컬 개발 환경, 통합 테스트 환경, 실제 운영 환경은 동일하지 않다. 데이터베이스 IP 정보, 디렉토리 경로, 외부 서비스 URL 등이 동일하지 않다. 단순히 DB IP/사용자 정보만 바뀌는 경우라면, 프로퍼티 파일에 DB정보를 기록하고 &lt;context:property-placeholder&gt;를 사용하면 될 것이다. 이 경우 사용할 DB 정보가 변경되면 프로퍼티 파일에서 값을 알맞게 변경해주면 된다. 하지만, 환경이 바뀔 때마다 프로퍼티 파일을 수정하는 방법은 좋아보이지 않는다. 더 나은 방법은 각 환경에 맞는 설정 정보를 따로 만들고, 환경에 따라 알맞은 설정 정보를 사용하는 것이다. 스프링의 프로필(profile)은 정확하게 이를 위한 기능이다. 스.......]]></description>
					<pubDate>Thu, 08 Mar 2018 13:39:20 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[spring&#160;기본]]></category>
					<title><![CDATA[Environment와 PropertySource]]></title>
					<link>https://blog.naver.com/edy5016/221218530427</link>
					<guid>https://blog.naver.com/edy5016/221218530427</guid>
					<description><![CDATA[Environment에서 살펴 볼 첫 번째 기능은 프로퍼티 값을 제공하는 기능이다. 스프링 컨테이너가 기본으로 사용하는 Environment의 구현체는 다수의 PropertySource로 부터 프로퍼티 값을 읽어온다. 실제 Environment로부터 프로퍼티를 읽어오는 과정은 아래와 같다. ● Environment의 프로퍼티 읽는 과정 o.s.core.env.MutablePropertySources에 두 개 이상의 PropertySource가 등록되어 있을 경우, 프로퍼티 값을 구할 때까지 등록된 순서에 따라 차례대로 확인한다. 예를 들어 이름이 JAVA_HOME인 환경 변수가 존재하고, 위의 그림에서 PropertySource의 우선 순위가 왼쪽이 높고 오른쪽이 낮다고 가정해보자. 이 때 Environment로부터 "JAVA_H.......]]></description>
					<pubDate>Wed, 28 Feb 2018 12:11:38 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[css]]></category>
					<title><![CDATA[3.CSS3_PositionAbsolute_position 속성에 absolute 속성값을 주어 부모 요소로부터 절대좌표를 갖는 박스 만들기]]></title>
					<link>https://blog.naver.com/edy5016/221205189669</link>
					<guid>https://blog.naver.com/edy5016/221205189669</guid>
					<description><![CDATA[]]></description>
					<pubDate>Fri, 09 Feb 2018 19:54:44 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[css]]></category>
					<title><![CDATA[2.CSS3_PositionFixed_position 속성에 fixed 속성값을 주어 브라우저에 고정된 박스 만들기]]></title>
					<link>https://blog.naver.com/edy5016/221205179904</link>
					<guid>https://blog.naver.com/edy5016/221205179904</guid>
					<description><![CDATA[정리 : fixed는 항상 웹브라우저에서 고정]]></description>
					<pubDate>Fri, 09 Feb 2018 19:38:41 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[css]]></category>
					<title><![CDATA[1. CSS3 텍스트 색상,너비 와 높이설정, 특정태그에 css 적용]]></title>
					<link>https://blog.naver.com/edy5016/221203675648</link>
					<guid>https://blog.naver.com/edy5016/221203675648</guid>
					<description><![CDATA[● CSS3 텍스트 색상● 너비 와 높이설정● 특정태그에 css 적용]]></description>
					<pubDate>Wed, 07 Feb 2018 23:59:42 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[python 장고]]></category>
					<title><![CDATA[05.Model AND Model Fileds]]></title>
					<link>https://blog.naver.com/edy5016/221192977841</link>
					<guid>https://blog.naver.com/edy5016/221192977841</guid>
					<description><![CDATA[● SQL - Query : 정보 수집에 대한 요청에 쓰이는 컴퓨터 언어 (위키백과) - SQL : 관계형 데이터베이스 관리 시스템 (Relational Database Management System) 의 데이터를 관리하기 위해 설계된 특수 목적으로 프로그래밍 언어 (위키백과) - RDBMS 종류 : PostgreSQL, MySQL, MariaDB 등 - 장고 모델은 RDBMS만을 지원 - 장고 모델을 통해 SQL을 생성/실행 ● Django Model- Django 내장 ORM - SQL을 직접 작성하지 않아도, 장고 모델을 통해 데이터베이스로의 접근 (조회/추가/수정/삭제) - (중요) SQL을 몰라도 된다는 것은 아님. 최소한 내가 짠 코드가 어떤 SQL을 만들어내는 지는 검증해야함. - &lt;파이썬 클래스&gt; 와 &lt;데이터베이.......]]></description>
					<pubDate>Thu, 25 Jan 2018 09:10:35 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[python 장고]]></category>
					<title><![CDATA[04 . view , Overview]]></title>
					<link>https://blog.naver.com/edy5016/221192977331</link>
					<guid>https://blog.naver.com/edy5016/221192977331</guid>
					<description><![CDATA[● View #ref&#8226; URLConf에 매핑된 Callable Object &#8226; 첫번째 인자로 HttpRequest 인스턴스를 받습니다. &#8226; 필히 HttpResponse 인스턴스를 리턴해야합니다. &#8226; 크게 Function Based View와 Class Based View로 구분 ● FBV (Function Based View ) 샘플 예시● CBV (Class Based View ) 샘플 예시 django.views.generic 뷰 사용패턴을 일반화시켜놓은 뷰의 모음 .as_view() 클래스함수1를 통해, FBV를 생성해주는 클래스]]></description>
					<pubDate>Thu, 25 Jan 2018 09:09:40 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[javascript&#160;예제]]></category>
					<title><![CDATA[자바스크립트 예제]]></title>
					<link>https://blog.naver.com/edy5016/221191696560</link>
					<guid>https://blog.naver.com/edy5016/221191696560</guid>
					<description><![CDATA[● 타이머와 함수 클로저 사용하기결과:● 경과 시간 구하기 이벤트 사이에 경과한 시간을 구하기. -&gt; 첫번째 이벤트 발생할 때 Date 객체를 생성하고, 두 번째 이벤트가 발생할 때 다른 새 Date객체를 생성한다. 그러고 나서 두 번째 객체에서 첫 번째 객체를 빼면된다. 뺀값은 밀리초 단위. 따라서 초단위로 변환하려면 1000으로 나눈다. Date 객체 인스턴스에서는 뺄셈 계산만 할 수 있다. ● 10 진수 값을 16진수 값으로 변환하기 자바스크립트의 숫자는 기본적으로 10진수 이다. 그러나 16진수, 8진수 등과 같이 다른 진수로 변환할 수 있다. 16진수 숫자는 0x(숫자0과 소문자x) 로 시작하고, 8 진수 숫자는 언제나 숫자 0으로 시작한다.......]]></description>
					<pubDate>Tue, 23 Jan 2018 17:35:30 +0900</pubDate>
					<tag><![CDATA[자바스크립트,javascript,개발자의하루,자바스크립트예제,테이블숫자모두더하기,타이머함수]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[jquery&#160;실습]]></category>
					<title><![CDATA[Jquery 가로메뉴 활용]]></title>
					<link>https://blog.naver.com/edy5016/221190880927</link>
					<guid>https://blog.naver.com/edy5016/221190880927</guid>
					<description><![CDATA[가로메뉴 마우스 올릴시 서브메뉴 활성 over 이미지 적용 및 해체basic.css mystyle.css htmlscript]]></description>
					<pubDate>Mon, 22 Jan 2018 18:41:55 +0900</pubDate>
					<tag><![CDATA[제이쿼리,개발자의하루,jquery,jquery실습,제이쿼리실습,가로메뉴,가로메뉴활용,가로메뉴실습]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[javascript&#160;패턴]]></category>
					<title><![CDATA[리터럴과 생성자]]></title>
					<link>https://blog.naver.com/edy5016/221188812890</link>
					<guid>https://blog.naver.com/edy5016/221188812890</guid>
					<description><![CDATA[● 객체 리터럴자바스크립트에서 '객체'라고 하면 단순히 이름-값 쌍의 해시 테이블을 생각하면 된다. 다른 언어에서 '연관 배열'이라 불리는 것과 유사하다. 원시 데이터 타입과 객체 모두 값이 될 수 있다. 함수도 값이 될 수 있으며 이런 함수는 메서드라고 부른다. 자바스크립트에서 생성한 객체 ( 다시 말해 사용자가 정의한 네이티브 객체 ) 는 언제라도 변경 할 수 있으며, 내장 네이티브 객체의 프로퍼티들도 대부분 변경이 가능하다 . 빈 객체를 정의해놓고 기능을 추가해 나갈 수도 있다. 객체 리터럴 표기법은 이처럼 필요에 따라 객체를 생성할 때 이상적이다. 이 예제는 백지와도 같은 빈객체에서 시작한다. 그리고 나서 프로퍼티와.......]]></description>
					<pubDate>Fri, 19 Jan 2018 17:05:34 +0900</pubDate>
					<tag><![CDATA[객체,객체리터럴,생성자함수,생성자,자바스크립트,개발자의하루,자바스크립트패턴,javascript,객체와리터럴,에러객체]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[javascript&#160;예제]]></category>
					<title><![CDATA[ISO 8601 형식의 날짜를 Date 객체에 사용 가능한 형식으로 변환하기]]></title>
					<link>https://blog.naver.com/edy5016/221188048166</link>
					<guid>https://blog.naver.com/edy5016/221188048166</guid>
					<description><![CDATA[ISO 8601은 날짜와 시간을 표기하는 국제표준 규격이다. API를 제공하는 프로그램이 ISO 8601을 요구하는 것은 자주 있는 일이다. 또한 API로 주고 받는 대부분의 날짜가 지역 시간보다는 UTC를 따르는 것도 흔한 일이다. --&gt; 숫자가 아닌 모든 문자를 특정한 하나의 문자로 변환해준다. ISO 형식의 월은 1에서 12까지의 값을 갖는다. 자바스크립트 Date 객체에서 월의 값을 사용하려면 1을 뺴서 월을 수정해주어야 한다. UTC설정을 유지하려면 Date 객체의 UTC() 메서드를 사용해 세계 표준시의 날짜를 생성한 다음 , Date 생성자로 전달한다. 모든 날짜 값을 일일이 나열하는 대신 apply() 메서드를 사용할 수 있다. 이메서드는 첫 번째 값.......]]></description>
					<pubDate>Thu, 18 Jan 2018 18:14:15 +0900</pubDate>
					<tag><![CDATA[자바스크립트,date,UTC,javascript,개발자의하루,ISO8601,Date객체,날짜]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[javascript&#160;패턴]]></category>
					<title><![CDATA[자바스크립트 패턴]]></title>
					<link>https://blog.naver.com/edy5016/221186359330</link>
					<guid>https://blog.naver.com/edy5016/221186359330</guid>
					<description><![CDATA[● 유지보수 가능한 코드 작성 발견 즉시 버그를 고칠 수 있다면 가장 좋다. 코드가 어떤 일을 수행하는지가 머릿속에 아직 생생하기 때문이다. 그렇지 않으면 개발자는 다른작업으로 넘어가버리고 이코드에 대해서는 전부 다 잊어버린다. 얼마간 시간이 흐른 다음에 코드를 다시들여다 볼 때는 다음과 같은 이유로 시간이 든다. - 문제를 다시 학습하고 이해하는데 걸리는 시간 - 이 문제를 해결하는 코드를 이해하는데 걸리는 시간 프로젝트나 회사의 규모가 클 경우 또 다른 문제가 있다. 실제로 버그를 고치는 사람과 버그를 만든 사람, 버그를 발견한 사람이 전부 다 다른 사람일 수 있다. 유지보수가 가능한 코드란 다음과 같은 특징을 지.......]]></description>
					<pubDate>Tue, 16 Jan 2018 18:53:26 +0900</pubDate>
					<tag><![CDATA[자바스크립트,자바스크립트패턴,javascript,javascriptPattern,자바스크립트패턴기초,개발자의하루,함수호이스팅,동료리뷰,swtich패턴,단일var]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[javascript 개념]]></category>
					<title><![CDATA[자바스크립트 참조 타입]]></title>
					<link>https://blog.naver.com/edy5016/221183621846</link>
					<guid>https://blog.naver.com/edy5016/221183621846</guid>
					<description><![CDATA[참조 값(객체) 이란 특정 '참조 타입'의 인스턴스이다. ECMAScript 에서 참조 타입은 데이터와 기능을 그룹으로 묶는 구조이다. 객체는 특정 참조 타입의 '인스턴스' 이다. 객체를 생성할 때는 new 연산자 뒤에 셍성자를 쓴다. 이 코드는 참조 타입 Object의 인스턴스를 생성해서 변수 person에 할당한다. 생성자는 Object() 이며 기본 프로퍼티와 메서드만 가진 단순한 객체를 생성했다. ● Object 타입Object 타입은 ECMAScript 에서 가장 많이 쓰이는 타입이다. Object의 인스턴스에 많은 기능이 들어있지는 않지만 애플리케이션에 사용할 데이터를 저장하고 전송하는 목적에는 안성맞춤이다. Object의 인스턴스를 명시적으로 생성하는 방법은.......]]></description>
					<pubDate>Fri, 12 Jan 2018 15:13:57 +0900</pubDate>
					<tag><![CDATA[자바스크립트,javascript,개발자의하루,참조타입,자바스크립트참조타입,javascript참조타입,배열,filter,reduce,map]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[python&#160;자동화]]></category>
					<title><![CDATA[파이썬 이메일보내기]]></title>
					<link>https://blog.naver.com/edy5016/221182492100</link>
					<guid>https://blog.naver.com/edy5016/221182492100</guid>
					<description><![CDATA[[ 메세지를 보내는 다양한 방법 ]이메일 : 다양한 포맷의 메세지를 보낼 수 있음. AWS SES &#8226; 대량 발송 시에는 대량 발송 서비스를 이용 &#8226; 일반 네이버메일/지메일 계정을 통해 대량 발송 시, 스팸우려해 발송거부 가능성 &#8226; 주로 쇼핑몰에서 활용 &#8226; SMTP1 프로토콜이나 특정 서비스의 API를 활용 &#8226; 가장 손쉽게 보낼 수 있으나, 건당 발송비용이 발생 &#8226; 선거/마트 홍보 문자 등 &#8226; 서비스 업체의 open api를 활용 &#8226; SMS (단문 메세지 80byte ) , LMS (장문 메세지), MMS (멀티미디어 메세지) 별 로 가격 상이 &#8226; 메세지 발송에는 추가 비용이 없음. &#8226; 서비스 업체의 OpenAPI를 통해 발.......]]></description>
					<pubDate>Thu, 11 Jan 2018 04:42:52 +0900</pubDate>
					<tag><![CDATA[python,파이썬,파이썬자동화,이메일,이메일보내기,smtp,파이썬smtp,python자동화,pythonsmtp]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[javascript 개념]]></category>
					<title><![CDATA[자바스크립트 변수와 스코프 , 메모리]]></title>
					<link>https://blog.naver.com/edy5016/221182119117</link>
					<guid>https://blog.naver.com/edy5016/221182119117</guid>
					<description><![CDATA[● 원시 값과 참조 값 변수에 값을 할당하면 자바스크립트 엔진은 해당 값이 원시 데이터인지 참조인지 판단한다. 원시 타입은 Undefined와 Null, boolean , 숫자, 문자열이다. 이 변수들은 값으로 접근한다. 참조 값은 메모리에 저장된 객체이다. 객체를 조작할 때는 사실 객체 자체가 아니라 해당 객체에 대한 참조를 조작한다. ● 동적 프로퍼티 참조 값을 다룰 때는 언제든 프로퍼티와 메서드를 추가하거나 바꾸고 삭제 할 수 있다. 객체를 생성후 person 변수에 저장 했다. 다음에는 name이란 프로퍼티를 추가하고 문자열 "Lee"를 할당했다. 이 시점부터 객체가 파괴되거나 프로퍼티를 명시적으로 제거하기 전까지는 해당 프로퍼티에 접근할.......]]></description>
					<pubDate>Wed, 10 Jan 2018 16:52:21 +0900</pubDate>
					<tag><![CDATA[개발자의하루,자바스크립트,javascript,스코프체인,자바스크립트메모리,식별자,동적프로퍼티,가비지콜렉션,실행컨텍스트,스코프]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[python 장고]]></category>
					<title><![CDATA[장고 앱 , URLConf ,  Template, ngrok]]></title>
					<link>https://blog.naver.com/edy5016/221181023502</link>
					<guid>https://blog.naver.com/edy5016/221181023502</guid>
					<description><![CDATA[&#8226; 장고 프로젝트 : &lt;장고 프로젝트 Rule&gt; 에 따라, 파일/디렉토리 구성이 된 디렉토리 &#8226; &lt;장고 앱 Rule&gt; 에 따라, 파일/디렉토리 구성이 된 디렉토리 &#8226; 하나의 장고 프로젝트의 다수의 장고 앱 [ 장고 프로젝트 구조 ] [ 장고 앱 구조 ] [ 첫번째 앱 &lt;blog&gt; 앱 생성 ] &#8226; 앱 디렉토리 생성 : shell&gt; python manage.py startapp blog &#8226; django/conf/app_template 구성으로 생성 &#8226; 앱을 프로젝트에 등록 : 아래와 같이 myproj/settings.py 을 편집하 여, INSTALLED_APPS 항목 끝에 blog 앱이름을 추가 주의 : 콤마에 유의 # myproj/settings.py 파일 [ 첫 뷰 blog.views.post_list 구현 ].......]]></description>
					<pubDate>Tue, 09 Jan 2018 10:47:22 +0900</pubDate>
					<tag><![CDATA[파이썬,장고,urlconf,개발자의하루,ngrok,장고앱,장고구조]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[python 장고]]></category>
					<title><![CDATA[파이썬 장고 설치 및 소개]]></title>
					<link>https://blog.naver.com/edy5016/221181002905</link>
					<guid>https://blog.naver.com/edy5016/221181002905</guid>
					<description><![CDATA[[ 파이썬 설치 ] 파이썬 3.4 이상 &#8226; 처음부터 pyenv, venv, virtualenv를 구지 쓰지 않아도됨. &#8226; 윈도우에서 데이터분석이나 머신러닝을 같이 하실려면, Anaconda Python 64비트 추천 [ 파이썬 버전 확인 ] 쉘&gt; python --version Python 3.5.2 :: Anaconda custom (x86_64) 윈도우에서는 PowerShell 보다는 명령프롬프트가 지원이 좋습니다. 주의 : 맥/리눅스에서는 python 명령으로 파이썬2가 실행될 수 있습니다. 그럴 때에는 python3 명령을 입력해보세요. 환경변수 PATH에 대한 명확 한 이해가 필요합니다. [ 장고 설치 ] &#8226; 장고 1.10 이상 &#8226; Django 에서의 LTS (Long Term Support) 버전 &#8226; 대개 3년동안 업.......]]></description>
					<pubDate>Tue, 09 Jan 2018 10:20:37 +0900</pubDate>
					<tag><![CDATA[파이썬,python,장고,장고설치,개발자의하루,python설치,파이썬설치,장고프로젝트,프로젝트]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[jquery&#160;실습]]></category>
					<title><![CDATA[jquery 가로메뉴 실습]]></title>
					<link>https://blog.naver.com/edy5016/221178705006</link>
					<guid>https://blog.naver.com/edy5016/221178705006</guid>
					<description><![CDATA[[ 가로 메뉴 1 ] css html스크립트 ( 상위 메뉴 hover시 하위 매뉴 나오게 기능 구현) 결과 : [ 가로 메뉴 2 : 디폴트로 메뉴페이지 활성화 ]html,css 동일 script 결과 : [ 스르르 슬라이딩 메뉴 ] css html script 결과: 이미지는 아무거나 넣어서~~~]]></description>
					<pubDate>Fri, 05 Jan 2018 18:59:32 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[spring&#160;기본]]></category>
					<title><![CDATA[@Configuration , 컴포넌트 스캔]]></title>
					<link>https://blog.naver.com/edy5016/221178644753</link>
					<guid>https://blog.naver.com/edy5016/221178644753</guid>
					<description><![CDATA[[ @Configuration과 의존 설정 ]@Configuration 애노테이션을 이용할 경우, 여러 클래스에 빈 정보를 나눠서 설정할 수 있다. 예를 들어 다음 코드를 보자. Config2 클래스는 UserRepository 타입의 빈을 정의하고 있고, Config1 클래스에 정의된 두 개의 빈(pwChangeSvc와 authenticationService)은 UserRepository 타입의 빈을 필요로 한다. @Configuration을 이용한 설정에서는 @Bean 애노테이션이 적용된 메서드를 호출하는 방법으로 의존 객체를 참조하게 되는데, 다른 @Configuration 클래스에 정의된 @Bean의 경우는 이 방법을 사용할 수 없다. 이렇게 다른 @Configuration 클래스에 정의한 빈을 참조해야 할 때, 앞서 살펴본 @Autowired .......]]></description>
					<pubDate>Fri, 05 Jan 2018 17:37:16 +0900</pubDate>
					<tag><![CDATA[스프링,개발자의하루,spring,aop,어노테이션,fillter,type,컴포넌트스캔,컴포넌트,Configuration]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[spring 활용]]></category>
					<title><![CDATA[jqgrid 사용법]]></title>
					<link>https://blog.naver.com/edy5016/221178507544</link>
					<guid>https://blog.naver.com/edy5016/221178507544</guid>
					<description><![CDATA[[ jqgrid ajax 기본틀 ] [ optionName , optionValue에 들어갈 jqGrid option ] [ jqGrid 자체 옵션 ] [j [ jqGrid - formatter 옵션으로 컬럼 내용 변경 ] jqGrid를 사용하면서 데이터를 json 형식으로 변환해야 하기 때문에 데이터를 표현을 변경해주는 formatter 옵션이 있다. colModel 에서 컬럼을 정의할 때 옵션으로 함수를 삽입해서 데이터를 함수를 통해 가공, 변경 하는 것이다. jqgrid javascript //cell는 현재 셀의 값을 그대로 가져옵니다. //Object는 현재 셀이 포함되어있는 row를 가져옵니다. //options는 해당 데이터를 date포맷이나 다른 포맷으로 변경할 수 있습니다.]]></description>
					<pubDate>Fri, 05 Jan 2018 14:52:52 +0900</pubDate>
					<tag><![CDATA[jqgrid,개발자의하루,스프링,ajax,자바스크립트,jqgridformatter]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[spring&#160;기본]]></category>
					<title><![CDATA[@Autowired , @Resource , @Inject  의존 자동 설정]]></title>
					<link>https://blog.naver.com/edy5016/221172770013</link>
					<guid>https://blog.naver.com/edy5016/221172770013</guid>
					<description><![CDATA[[ @Autowired , @Resource , @Inject 차이점 ] 의존 자동 설정 사용할 전처리기를 따로 등록하기 보다는 &lt;context:anotation-config&gt; 태그를 사용한다. [ @Autowired 애노테이션 ] @Autowired 애노테이션은 생성자,필드,메서드의 세곳에 적용이 가능하다. 스프링은 필드,메서드,생성자 등에 @Autowired 애노테이션이 적용되어 있으면, 해당 하는 타입의 스프링 빈객체를 알맞게 연결해준다. XML 설정을 보면, orderService 빈은 erpClientFactory 프로퍼티의 값을 설정하고 있지 않다. 하지만 setErpClientFactory() 메서드에 @Autowired 애노테이션이 적용되어 있으므로 스프링은 동일한 타입을 갖는 "ecFactory" 빈을 erpClientFactory 프.......]]></description>
					<pubDate>Thu, 28 Dec 2017 11:11:41 +0900</pubDate>
					<tag><![CDATA[개발자의하루,Autowired,Named,Qualifier,Inject,Resource,required,스프링,spring,애노테이션]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[spring&#160;기본]]></category>
					<title><![CDATA[의존관계설정방법 및 Bean Life cycle , Bean scope ,외부 파일을 이용한 빈 설정]]></title>
					<link>https://blog.naver.com/edy5016/221172084504</link>
					<guid>https://blog.naver.com/edy5016/221172084504</guid>
					<description><![CDATA[[의존 관계 설정 방법] - JAVA를 이용한 설정방법(어노테이션을 이용한다. @Configuration, @Bean) : 어노테이션(Annotation:Metadata) -JDK5 부터 등장한 개념 ex)@Override 어노테이션은 . 컴파일러에게 정보를 알려주거나 . 컴파일 할 떄와 설치(deployment)시의 작업을 지정하거나 . 실행할 때 별도의 처리가 필요한 경우 사용한다. 클래스,메소드,변수 등 모든 요소에 선언이 가능하다. ○ @Configuration : 클래스 앞에 선언하는데, "이 클래스는 스프링 설정에 사용되는 클래스입니다" 라고 알려주는 어노테이션 ○ @Bean : 메소드 앞에 선언, "객체를 생성" Player.java ConfigApp.java MainBaseBall.java [ 스프링 컨테이너 생명주기 ] .......]]></description>
					<pubDate>Wed, 27 Dec 2017 13:17:29 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[spring&#160;기본]]></category>
					<title><![CDATA[스프링 DI 와 IOC]]></title>
					<link>https://blog.naver.com/edy5016/221171193976</link>
					<guid>https://blog.naver.com/edy5016/221171193976</guid>
					<description><![CDATA[[스프링 프레임웍이란?] - 스프링은 엔터프라이즈 어플리케이션에서 필요로하는 여러가지 기능들을 제공하는 프레임워크이다. - J2E가 제공하는 기능들을 스프링에서 자원을 하고 있기 때문에 국내에서는 가장 인기 있는 프레임웍으로 자리를 잡았다. - 스프링은 J2E에서 제공하는 기능 외에 DI나 AOP와 같은 기능을 지원한다. ## 특징 = &gt; 스프링은 경량의 프레임워크 - 자바의 객체를 담고 있는 컨테이너 - 외부에서 생성하는 객체를 컨테이너라함 - 객체의 생성, 소멸과 같은 생명주기를 관리한다. a 객체 --&gt; b 객체 메소드 (안녕하세요.) a가 B를 의존한다. 종속적인 문제가생겨서 DI 가나왔다. &gt;DI (Dependency Injection) 의존성.......]]></description>
					<pubDate>Tue, 26 Dec 2017 11:07:59 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[spring&#160;기본]]></category>
					<title><![CDATA[스프링 AOP]]></title>
					<link>https://blog.naver.com/edy5016/221168782457</link>
					<guid>https://blog.naver.com/edy5016/221168782457</guid>
					<description><![CDATA[[ AOP : 관점 지향 프로그래밍 ] : 기존의 OOP를 보완 한 개념(핵심사항과 공통관심사항을 분리하여 구현) 예&gt; 은행업무 --&gt; 핵심 입/출 ,계좌이체 + 부가적인 작업 (누가 입금,출금했는지 정보남겨야됨 + 보안 + 인증 + 중복체크 ) 부가적인 작업들을 따로모아서 모듈로 관리함 primary concern : 핵심 관심사항 이라고 한다. core concern AOP는 primary concern과 cross-cutting concern을 별도의 코드로 구현해서 최종적으로 이들을 조합해서 완성하는 것 주요 용어 - 핵심관심 사항(core concern) : 비지니스 로직 (주 업무) - 공통관심 사항(횡단관심사항 : cross-cutting concern ) : 부가적인 기능(보조 업무) * 비지니스로직은 co.......]]></description>
					<pubDate>Fri, 22 Dec 2017 11:03:10 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[jquery&#160;실습]]></category>
					<title><![CDATA[jquery - 기본적인 세로 메뉴 시작]]></title>
					<link>https://blog.naver.com/edy5016/221165868831</link>
					<guid>https://blog.naver.com/edy5016/221165868831</guid>
					<description><![CDATA[jquery 파일 다운로드해서 포함시키던가 cdn 받아서 하시면됩니다. jquery cdn : &lt;script src="//ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"&gt;&lt;/script&gt; 공식홈페이지에서 최신버전 다운을 수 있는 링크 - http://jquery.com/download/ 위 링크에서 Download the compressed, production jQuery x.x.x 처럼 되어있는 것을 받으면 무난합니다. 2017년 11월 1일(수) 47일 전 기준 최신 버전 jQuery 3.2.1 다운로드 링크 - https://code.jquery.com/jquery-3.2.1.min.js 아래는 모든 제이쿼리 버전을 보거나 다운 받을 수 있는 페이지 입니다. https://code.jquery.com/jquery/ 1.x 마지막 버전 링크 (jQuery Core 1.12.4) .......]]></description>
					<pubDate>Mon, 18 Dec 2017 16:48:46 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[javascript 개념]]></category>
					<title><![CDATA[함수형 프로그래밍]]></title>
					<link>https://blog.naver.com/edy5016/221163934477</link>
					<guid>https://blog.naver.com/edy5016/221163934477</guid>
					<description><![CDATA[[ 자바스크립트 함수형 프로그래밍] 함수형 프로그래밍 가능한이유 - 일급 객체로서의 함수 - 클로저 결과 : 1 2 3 함수가 일급 객체로 취급되기 때문에 함수의 인자로 함수를 넘기고, 결과로 함수를 반환할 수있다. 게다가 변수 str 값이 영향을 받지 않게 하려고 클로저를 사용하였다. get_encrypted() 함수에서 반환하는 익명 함수가 클로저이다. 이클로저에서 접근하는 변수 str은 외부에서는 접근할 수 없으므로 클로저로 함수형 프로그래밍의 개념을 정확히 구현해 낼 수 있다. ○ 배열의 각 원소 총합 구하기 ○ 배열의 각 원소를 모두 곱한값 위의 두예제는 명령형 프로그래밍 방식으로 작성된 코드이다. 다음예제로 함수형 프로그래밍을.......]]></description>
					<pubDate>Fri, 15 Dec 2017 17:50:15 +0900</pubDate>
					<tag><![CDATA[]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[javascript 개념]]></category>
					<title><![CDATA[자바스크립트 객체지향 프로그래밍]]></title>
					<link>https://blog.naver.com/edy5016/221163118651</link>
					<guid>https://blog.naver.com/edy5016/221163118651</guid>
					<description><![CDATA[[ 클래스 , 생성자 , 메서드 ] 클래스,생성자,메서드 모두 함수로 구현이 가능하다. 함수Person이 클래스이자 생성자의 역할을 한다. 자바스크립트에서 클래스 기반의 객체지향 프로그램은 기본적인 형태가 이와 같다. 클래스 및 생성자의 역할을 하는 함수가 있고, 사용자는 new 키워드로 인스턴스를 생성하여 사용할 수 있다. 생성된 me는 Person의 인스턴스로서 name변수가 있고, getName()과 setName() 함수가 있다. Person을 생성자로 하여 여러개의 객체를 생성한다고 가정해보자. var me = new Person("me"); var you = new Person("you); 각객체는 자기영역에서 공통적으로 사용할 수 있는 setName() 함수와 getName() 함수를 따로 생성.......]]></description>
					<pubDate>Thu, 14 Dec 2017 17:55:49 +0900</pubDate>
					<tag><![CDATA[자바스크립트,개발자의하루,자바스크립트객체,객체및상속,자바스크립트객체및상속,객체,상속,클로저,프로토타입상속,클래스상속]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[javascript 개념]]></category>
					<title><![CDATA[실행 컨텍스트와 클로저]]></title>
					<link>https://blog.naver.com/edy5016/221161415051</link>
					<guid>https://blog.naver.com/edy5016/221161415051</guid>
					<description><![CDATA[[ 실행 컨택스트 개념 ] ECMAScript 에서는 실행 컨텍스트를 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념 . 콜 스택과 연관하여 정의하면 , 실행 가능한 자바스크립트 코드 블록이 실행되는 환경이라고 할 수 있다. 이 컨텍스트 안에 실행에 필요한 여러 가지 정보를 담고 있다. 실행 컨텍스트가 형성되는 경우 세가지가 있다. 1. 전역 코드 2. eval() 함수로 실행되는 코드 3. 함수 안의 코드를 실행할 경우 대부분 프로그래머는 함수로 실행 컨택스를 만듬. 이 코드 블록 안에 변수 및 객체, 실행 가능한 코드가 있다. 이 코드가 실행되면 실행 컨텍스트가 생성되고, 실행 컨텍스트는 스택 안에 하나씩 차곡차곡 쌓이고, 제일 위에.......]]></description>
					<pubDate>Tue, 12 Dec 2017 17:58:11 +0900</pubDate>
					<tag><![CDATA[자바스크립트,javascript,개발자의하루,setTimeout,스코프체인,라이브러리]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
				<item>
					<author>edy5016</author>
					<category><![CDATA[spring 활용]]></category>
					<title><![CDATA[폼검증 (validatate)]]></title>
					<link>https://blog.naver.com/edy5016/221160143839</link>
					<guid>https://blog.naver.com/edy5016/221160143839</guid>
					<description><![CDATA[[ Validator(인터페이스를 구현한 객체) ] - 서버단에서 검증하는것 객체(커멘드객체) 에담아서 한번에 검증 Client Controller form -----------&gt; Validator 가져와서 유효성 체크 -----&gt; 검증된후 뷰 에전달 객체 실패면 form 에 [ 유효성 검사 ] # Validator : org.springframework.validation.Validator 인터페이스 . 구현 메소드 - boolean supports(Class&lt;?&gt; arg0) : Validator가 해당 클래스에 대한 값 검증을 지원하는지의 여부를 리턴한다. - void validate( Object target, Errors erros ) : target 객체에 대한 검증을 실행하는 메소드 ,검증결과에 문제 있을 경우에는 errors 객체에 에러 정보를 저장 form에서 넘어온 t.......]]></description>
					<pubDate>Mon, 11 Dec 2017 02:09:17 +0900</pubDate>
					<tag><![CDATA[스프링,스프링폼검증,validate]]></tag>
					<activity:verb>http://activitystrea.ms/schema/1.0/post</activity:verb>
					<activity:object-type>http://activitystrea.ms/schema/1.0/blog-entry</activity:object-type>
				</item>
			
		
		
	
</channel>
</rss>
