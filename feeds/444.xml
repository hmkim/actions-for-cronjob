<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Seo Yoochan on Medium]]></title>
        <description><![CDATA[Stories by Seo Yoochan on Medium]]></description>
        <link>https://medium.com/@seoyoochan?source=rss-ee627a24b6b2------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*slg2ME0exH-DbBHvynkwAg.jpeg</url>
            <title>Stories by Seo Yoochan on Medium</title>
            <link>https://medium.com/@seoyoochan?source=rss-ee627a24b6b2------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 12:17:39 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@seoyoochan" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[will I get a boost in perf if I use immutable-js?]]></title>
            <link>https://medium.com/@seoyoochan/will-i-get-a-boost-in-perf-if-i-use-immutable-js-e0e24ed859c9?source=rss-ee627a24b6b2------2</link>
            <guid isPermaLink="false">https://medium.com/p/e0e24ed859c9</guid>
            <dc:creator><![CDATA[Seo Yoochan]]></dc:creator>
            <pubDate>Sun, 24 Apr 2016 18:38:26 GMT</pubDate>
            <atom:updated>2016-04-24T18:38:26.256Z</atom:updated>
            <content:encoded><![CDATA[<p>will I get a boost in perf if I use immutable-js? and also it might be able to get applied with redux-search and immutable-js.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e0e24ed859c9" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[아이비리그 CS 인기 교과서 — 운영체제/리눅스/커널/C언어]]></title>
            <link>https://medium.com/@seoyoochan/%EC%95%84%EC%9D%B4%EB%B9%84%EB%A6%AC%EA%B7%B8-cs-%EC%9D%B8%EA%B8%B0-%EA%B5%90%EA%B3%BC%EC%84%9C-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%BB%A4%EB%84%90-c%EC%96%B8%EC%96%B4-7bafe2751851?source=rss-ee627a24b6b2------2</link>
            <guid isPermaLink="false">https://medium.com/p/7bafe2751851</guid>
            <category><![CDATA[tech]]></category>
            <category><![CDATA[computer-science]]></category>
            <category><![CDATA[college]]></category>
            <dc:creator><![CDATA[Seo Yoochan]]></dc:creator>
            <pubDate>Thu, 21 Apr 2016 15:40:46 GMT</pubDate>
            <atom:updated>2016-04-21T15:42:16.610Z</atom:updated>
            <content:encoded><![CDATA[<p>아이비리그 컴퓨터 과학부에서 주로 쓰는 교과서 및 추천도서입니다.</p><p>운영체제/리눅스/커널/C언어</p><p><strong>운영체제와 리눅스 커널 공부하기전에 숙련된 C언어 지식(C++는 안됨), 커맨드라인 유닉스 개발 툴체인(make, gcc), 다른 사람의 코드를 수정할줄 알정도의 스킬과 욕구가 필요합니다.</strong></p><p><strong>운영체제</strong></p><p>Computer Systems: A Programmer’s Perspective (3rd Edition) by Randal E. Bryant, David R. O’Hallaron</p><p>(http://www.amazon.com/Computer-Systems-Programmers-Perspective-3rd/dp/013409266X/ref=pd_sim_14_1?ie=UTF8&amp;dpID=41AoUQujOCL&amp;dpSrc=sims&amp;preST=_AC_UL160_SR124%2C160_&amp;refRID=00ND25GQ975W12ZS74ER)</p><p>Operating System Concepts, 9th Edition by Abraham Silberschatz, Peter B. Galvin, Greg Gagne. ISBN 978–1–1180–6333–0. December 2012.</p><p>(http://www.amazon.com/Operating-System-Concepts-Abraham-Silberschatz/dp/1118063333)</p><p>Modern Operating Systems (4th Edition) by Andrew S. Tanenbaum, Herbert Bos.</p><p>(http://www.amazon.com/Modern-Operating-Systems-Andrew-Tanenbaum/dp/013359162X/ref=sr_1_1?ie=UTF8&amp;qid=1461250428&amp;sr=8-1&amp;keywords=Modern+Operating+Systems)</p><p><strong>리눅스 커널</strong></p><p>Linux Kernel Development, 3rd Edition by Robert Love. ISBN: 978–0672329463. July 2010</p><p>(http://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468)</p><p>Bovet and Desati, Understanding the Linux Kernel, 3rd Edition, O’Reilly, 2006, ISBN 0–596–00565–2. Note: get only the 3rd Edition, since it describes the Linux 2.6 kernel. (http://www.amazon.com/Understanding-Linux-Kernel-Third-Daniel/dp/0596005652/ref=sr_1_1?ie=UTF8&amp;qid=1461250315&amp;sr=8-1&amp;keywords=0596005652)</p><p><strong>C언어</strong></p><p>The C Programming Language</p><p>(http://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131103628/ref=sr_1_fkmr0_1?ie=UTF8&amp;qid=1461249993&amp;sr=8-1-fkmr0&amp;keywords=The+C+Programming+Language%2C+Second+Edition.+Brian+W.+Kerninghan+and+Dennis+M.+Ritchi)</p><p>C Programming: A Modern Approach, 2nd Edition by K. N. King (http://www.amazon.com/C-Programming-Modern-Approach-2nd/dp/0393979504/ref=sr_1_fkmr1_3?ie=UTF8&amp;qid=1461249993&amp;sr=8-3-fkmr1&amp;keywords=The+C+Programming+Language%2C+Second+Edition.+Brian+W.+Kerninghan+and+Dennis+M.+Ritchi)</p><p><strong>리눅스</strong></p><p>The UNIX Programming Environment by Brian W. Kernighan, Rob Pike (http://www.amazon.com/Unix-Programming-Environment-Prentice-Hall-Software/dp/013937681X/ref=sr_1_1?ie=UTF8&amp;qid=1461250041&amp;sr=8-1&amp;keywords=The+UNIX+Programming+Environment)</p><p>Advanced Programming in the UNIX Environment, 3rd Edition by W. Richard Stevens, Stephen A. Rago</p><p>(http://www.amazon.com/Advanced-Programming-UNIX-Environment-3rd/dp/0321637739/ref=sr_1_2?ie=UTF8&amp;qid=1461250041&amp;sr=8-2&amp;keywords=The+UNIX+Programming+Environment)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7bafe2751851" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[유닉스]]></title>
            <link>https://medium.com/@seoyoochan/%EC%9C%A0%EB%8B%89%EC%8A%A4%EC%9C%A0%EB%8B%89%EC%8A%A4-unix-%EB%8A%94-1969%EB%85%84%EC%97%90-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EC%97%AC-1973%EB%85%84%EC%97%90-at-t-%EB%B2%A8-%EC%97%B0%EA%B5%AC%EC%86%8C%EC%97%90%EC%84%9C-%EC%B2%98%EC%9D%8C-%EB%B0%9C%ED%91%9C%EB%90%9C-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%8B%A4-bc25761e2ea1?source=rss-ee627a24b6b2------2</link>
            <guid isPermaLink="false">https://medium.com/p/bc25761e2ea1</guid>
            <category><![CDATA[operating-systems]]></category>
            <category><![CDATA[unix]]></category>
            <category><![CDATA[tech]]></category>
            <dc:creator><![CDATA[Seo Yoochan]]></dc:creator>
            <pubDate>Thu, 21 Apr 2016 15:20:04 GMT</pubDate>
            <atom:updated>2016-04-21T15:28:12.144Z</atom:updated>
            <content:encoded><![CDATA[<p>유닉스(UNIX)는 1969년에 개발하기 시작하여 1973년에 AT&amp;T 벨 연구소에서 처음 발표된 운영체제다. 원래의 목적은 워크스테이션/서버용이었지만 요새는 데스크탑 클라이언트용이나 임베디드용으로도 쓰인다. 이름이 ~ix로 끝나는 것이 불문율로 되어 있다. (POSIX에서 X가 붙은 이유가 이에 해당)</p><p>1970년대 초반 AT&amp;T 연구소에서 개발을 시도했던 시분할 운영체제 멀틱스가 그 기원이다. 그러나 이 프로젝트는 실패했고, 이에 팀에 소속되어 있던 개발자들이 우주여행 게임을 실행하기 위해서 만든 운영체제가 바로 유닉스이다.</p><p><strong>컴퓨터 운영체제 역사상 가장 중요한 운영체제</strong>라고 할 수 있다. 이는 무엇보다도 처음으로 어셈블리가 아니라 C 언어라는 고급 프로그래밍 언어로 커널까지 작성되어 제대로 돌아간 운영체제이기 때문이다.</p><blockquote>사실 유닉스가 처음 만들어졌을 때는 어셈블리로 작성되었고 그 후에 C언어를 개발해서 C언어로 다시 작성되었다.</blockquote><p>그 이전에도 고급언어로 작성된 운영체제가 있기는 했다. (PL/1으로 작성된 멀틱스라거나…) 하지만 C언어 만큼 시스템 프로그래밍에 뛰어난 언어가 없었기 때문에 수많은 버그, 느린 성능, 지나치게 큰 사이즈 등의 문제로 성공적이지 못했다. 따라서 유닉스를 기점으로 운영체제 개발의 역사 및 프로그래밍의 역사가 크게 변하게 된다.</p><p>기존의 메인프레임 컴퓨터용 운영체제는 대부분 어셈블리어로 개발되었는데, 어셈블리어는 기계어와 사실상 1:1 대응되는 언어이므로 다른 하드웨어로의 이식이 매우 어려웠다. (오늘날 어셈블리어는 이식성도 고려해서 만들어진 것들이 많다.)<br>그러나 유닉스는 고급 언어인 C 언어로 개발되었기 때문에 <strong>다른 하드웨어로 이식하기가 쉬웠다</strong>. 또한 당시에는 최신 기술이었던 <a href="https://namu.wiki/w/%EB%A9%80%ED%8B%B0%ED%83%9C%EC%8A%A4%ED%82%B9">멀티태스킹</a> 기술을 도입하여 여러 사용자가 동시에 사용할 수 있었기 때문에 인기를 끌었다.</p><p>서버 운영에 필수적이라 할 수 있는 CLI 인터페이스가 상당히 강하기 때문에, 서버 시장에서는 윈도우 이상으로 인기가 좋다. 스마트폰용 OS도 시장을 양분하고 있는 iOS(BSD 기반)와 안드로이드(리눅스 기반)가 모두 유닉스 계열이다.</p><p>또한<strong> 인터넷의 역사와도 떼어놓을 수 없는 운영체제</strong>이다. 운영체제가 인터넷에 접근하는 표준 인터페이스인 “<strong>소켓</strong>”은 BSD 유닉스에서 만들어진 개념이다.</p><p>당시 AT&amp;T는 합법적인 전화사업 독점기업이라 여러가지 제약을 정부로 부터 받았는데, 전화와 직접관련이 없는 제품을 팔거나 사후지원을 해줄 수 없는 것도 그 한가지였다. 덕분에 초기 버전의 UNIX는 무료로 소스코드까지 배포되었고, 사후지원의 부재를 메꾸기 위해 세계각지에 Usenix 그룹이 생겨나 교류하게 되었다</p><blockquote>말이 교류지 인터넷이 없던 그 시대에는 코드가 담긴 자기테입이나 종이테입을 우편으로 돌려가며 공유해야 했다.</blockquote><p>이후에 유닉스를 모방한 많은 운영체제들이 나타났는데, 이들을 표준화하기 위해 <strong>POSIX</strong>라는 표준이 등장했다. POSIX 표준을 만족하는 것들을 유닉스 계열 운영체제라고 한다. 리눅스와 Mac OS X가 대표적인 유닉스 계열 운영체제이다.</p><p>인증 비용 문제인지, 대부분의 리눅스 배포판들은 POSIX의 거의 모든 상세스펙을 따르고 있지만 공식 인증은 아니다. <br>NetBSD, FreeBSD같은 오픈소스 BSD계열도 마찬가지로 공식 인증된 UNIX가 아니다.</p><blockquote>예를들어, BSD 류는 공식인증을 하지 않았지만, 역사적으로 AT&amp;T의 코드베이스와 직접적 관련이 있기 때문에 Genetic UNIX 로 분류하고, 리눅스같은 경우는 유닉스라 불릴 만한 조건을 만족하지만, AT&amp;T 의 코드베이스와 직접적 관련은 없기때문에 Functional UNIX 라 분류하는 기준도 있다.</blockquote><p>Mac OS X의 경우 POSIX 공식 인증이다.</p><blockquote>Mac OS의 경우 9.x 버전까지는 유닉스 계열이 아니었으나 Mac OS X부터 BSD Unix 계열로 다시 개발하였으며, <strong>10.5버전 레오파드부터는 정식으로 POSIX 인증을 획득</strong>했다.</blockquote><p>Microsoft Windows는 엄밀히 말해 유닉스가 아니라고 할 수 있겠지만 POSIX 표준을 따르는 서브 시스템을 제공한다. Microsoft사의 홈페이지에서 다운로드 할 수 있는 Subsystem for UNIX-based Applications(aka SUA)라는 것을 설치하면 된다. 이 서브시스템은 과거 FreeBSD로 돌리던 핫메일 서버를 윈도우 서버로 전환하던 과도기에 만들어 쓰던것으로, 윈도우 8에서 부터는 deprecated가 되었고 다음 윈도우 버전부터는 완전히 삭제될 예정이다. 윈도우 7 에서는 얼티밋과 엔터프라이즈 버전 한정으로 사용가능하다. 이 상태의 OS명칭은 Interix라고 한다.</p><p>이 글은 나무위키 <em>유닉스를 요약 발췌한 것입니다.<br>출처: </em><a href="https://namu.wiki/w/%EC%9C%A0%EB%8B%89%EC%8A%A4">https://namu.wiki/w/%EC%9C%A0%EB%8B%89%EC%8A%A4</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bc25761e2ea1" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Linux CFS 알고리즘]]></title>
            <link>https://medium.com/@seoyoochan/linux-cfs-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-e25a7ee5d9a0?source=rss-ee627a24b6b2------2</link>
            <guid isPermaLink="false">https://medium.com/p/e25a7ee5d9a0</guid>
            <category><![CDATA[operating-systems]]></category>
            <category><![CDATA[algorithms]]></category>
            <category><![CDATA[linux]]></category>
            <dc:creator><![CDATA[Seo Yoochan]]></dc:creator>
            <pubDate>Thu, 21 Apr 2016 14:17:16 GMT</pubDate>
            <atom:updated>2016-04-21T14:17:16.147Z</atom:updated>
            <content:encoded><![CDATA[<p>출처 <a href="http://egloos.zum.com/studyfoss/v/5326671">http://egloos.zum.com/studyfoss/v/5326671</a></p><p>Linux: 2.6.34</p><p>CFS(Completely Fair Scheduler)는 2.6.23 이후로 <br>리눅스의 기본 스케줄러로 사용되고 있는 알고리즘이다.</p><p>모든 우선순위 값에 대한 배열을 이용해 run queue를 구현한 기존의 O(1) 스케줄러에 비해<br>red-black tree를 사용하는 CFS는 기본 성능은 O(log N)으로 느려졌지만<br>대부분의 경우에서 이는 거의 영향을 주지 않기 때문에<br>여러 corner case들을 공정하게 처리해주는 CFS가 대신 도입되었다.<br>real time process의 경우에는 아직도 O(1) 스케줄러가 (약간 변형되어) 사용된다.</p><p>CFS의 기본 원리는 이름에서 알 수 있듯이 모든 프로세스를 공평하게 실행하는 것이다.<br>프로세스 우선순위나 sleep을 통해 자발적으로 CPU를 반환하는 경우를 고려하지 않는다면<br>CFS가 관리하는 모든 프로세스는 동일한 시간동안 실행하고 CPU를 반환한다.</p><p>프로세스의 우선순위를 반영하기 위해 각 프로세스는 (정확히 말하면 sched_entity 구조체는)<br>load_weight 구조체를 이용하여 자신의 우선순위에 따른 load 값을 저장하고 있다.</p><p>sched.h:</p><p>struct load_weight {<br> unsigned long weight, inv_weight;<br>};</p><p>weight는 load 즉, 우선순위에 대한 가중치이고 inv_weight는 이의 역수(1/weight)에 해당하는 값이다.<br>weight 값은 nice를 통해 지정할 수 있는 우선순위에 대응하는 값이며 (nice level 0일 때: 1024)<br>sched.c 파일의 prio_to_weight[] 배열에 저장되어 있다.<br>참고로 nice (우선순위) 값의 1 차이는 weight 값의 1.25 배 차이이며<br>이는 프로세스가 CPU를 사용하는 시간에 10% 정도 영향을 준다.</p><p>inv_weight 값은 단지 계산을 간편하게 하기 위한 목적으로 도입된 것으로<br>가중치 계산을 위한 나눗셈을 피하기 위해 미리 정해진 충분히 큰 수(2³²)에 나눗셈을 미리 계산해 둔 값이다.<br>이도 마찬가지로 sched.c 파일의 prio_to_wmult[] 배열에 저장되어 있다.</p><p>이렇게 우선순위에 따른 load를 계산해 두었다면 주어진 값에 대한 자신의 몫을 계산하는 작업은<br>아래의 calc_delta_mine() 함수를 통해 이루어진다.<br>(생략한 부분은 inv_weight를 새로 계산하는 부분이다.)</p><p>sched.c:</p><p>static unsigned long<br>calc_delta_mine(unsigned long delta_exec, unsigned long weight,<br> struct load_weight *lw)<br>{<br> u64 tmp;</p><p>…</p><p>tmp = (u64)delta_exec * weight;<br> /*<br> * Check whether we’d overflow the 64-bit multiplication:<br> */<br> if (unlikely(tmp &gt; WMULT_CONST))<br> tmp = SRR(SRR(tmp, WMULT_SHIFT/2) * lw-&gt;inv_weight,<br> WMULT_SHIFT/2);<br> else<br> tmp = SRR(tmp * lw-&gt;inv_weight, WMULT_SHIFT);</p><p>return (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);<br>}</p><p>먼저 함수의 매개 변수를 살펴보면, delta_exec는 계산하고자 하는 기준값이며<br>weight는 자신이 차지하는 가중치이고, lw는 전체에 대한 가중치이다.</p><p>즉, 기본적인 산수는 (delta_exec * weight / lw-&gt;weight)를 계산하고자 함이다.<br>하지만 (특정 아키텍처에서는 매우 느린) 나눗셈 연산을 피하기 위해 inv_weight를 이용한다.<br>먼저 tmp가 WMULT_CONST (= 2³²)보다 작은 간단한 경우를 살펴보기로 하자.</p><p>기본적으로 inv_weight = (WMULT_CONST / weight)이기 때문에 다음이 성립한다.</p><p>tmp * lw-&gt;inv_weight = (delta_exec * weight) * (WMULT_CONST / lw-&gt;weight)</p><p>여기서 WMULT_CONST를 제거하기 위해서는 다시 나눗셈이 필요한데<br>WMULT_CONST는 2의 제곱이기 때문에 간단히 shift 연산으로 계산이 가능하다.<br>하지만 shift right 시의 값 버림을 방지하기 위해 미리 반올림을 하는 SRR 매크로로 이용한다.</p><p>/*<br> * Shift right and round:<br> */<br>#define SRR(x, y) (((x) + (1UL &lt;&lt; ((y) — 1))) &gt;&gt; (y))</p><p>위의 if 문의 경우에는 SRR 시 shift left에 의해 상위 워드의 정보를 잃어버리지 않기 위해<br>나눗셈을 두 번에 걸쳐 수행한다.</p><p>CFS는 우선순위에 따라 프로세스를 run queue (red-black tree)에 배치하기 위해<br>가상의 시간인 vruntime을 사용하는데 이는 실제로 프로세스가 실행한 시간에<br>nice 0에 대한 현재 프로세스의 우선순위 가중치를 역으로(!) 계산한 값이다.<br>(아래의 calc_delta_mine() 호출 시 se의 load 값이 전달되는 위치에 주목하자.)</p><p>static inline unsigned long<br>calc_delta_fair(unsigned long delta, struct sched_entity *se)<br>{<br> if (unlikely(se-&gt;load.weight != NICE_0_LOAD))<br> delta = calc_delta_mine(delta, NICE_0_LOAD, &amp;se-&gt;load);</p><p>return delta;<br>}</p><p>프로세스의 vruntime 값을 갱신하는 __update_curr() 함수는 다음과 같은 작업을 수행한다.</p><p>sched_fair.c:</p><p>static inline void<br>__update_curr(struct cfs_rq *cfs_rq, struct sched_entity *curr,<br> unsigned long delta_exec)<br>{<br> unsigned long delta_exec_weighted;</p><p>…</p><p>delta_exec_weighted = calc_delta_fair(delta_exec, curr);</p><p>curr-&gt;vruntime += delta_exec_weighted;<br> update_min_vruntime(cfs_rq);<br>}</p><p>이와 같이 vruntime은 (절대적인) nice 우선순위에 영향을 받기 때문에<br>우선순위가 낮은 프로세스인 경우 vruntime은 실제보다 더 큰 값을 갖게 되고,<br>우선순위가 높은 프로세스의 경우 반대로 더 작은 값을 갖게 되어 평준화를 이루게 된다.</p><p>CFS의 run queue (cfs_rq)는 기준이 되는 최소 vruntime 값을 유지하며<br>각 프로세스의 vruntime 값과 이 값의 차이를 key로 하여 red-black tree를 구성한다.<br>따라서 __update_curr() 실행 시 필요하다면 cfs_rq-&gt;min_vruntime 값도 갱신한다.</p><p>time slice의 계산도 이와 비슷하지만 약간 차이가 있다.<br>아래의 __sched_period() 함수는 모든 프로세스에게 주어진 전체 time slice 값을 계산한다.</p><p>static u64 __sched_period(unsigned long nr_running)<br>{<br> u64 period = sysctl_sched_latency;<br> unsigned long nr_latency = sched_nr_latency;</p><p>if (unlikely(nr_running &gt; nr_latency)) {<br> period = sysctl_sched_min_granularity;<br> period *= nr_running;<br> }</p><p>return period;<br>}</p><p>nr_running은 실행 가능한 프로세스의 개수이며,<br>sysctl_sched_latency는 round robin으로 모든 프로세스를 한 번씩 수행시킬 시간이고<br>sysctl_sched_min_granularity는 한 프로세스가 수행될 (최소)시간이다. (모두 ns 단위이다!)<br>sched_nr_latency는 위의 두 값의 비율로 이루어지는 값으로 프로세스 수에 해당한다.</p><p>이렇게 설명하면 복잡하니, 실제 값을 이용하여 알아보면 아래와 같다. (CPU 수에 따른 scaling은 무시한다)</p><p>sched_nr_latency = sysctl_sched_latency / sysctl_sched_min_granularity = 5ms / 1ms = 5</p><p>즉, 전체 프로세스 수가 5개 이하라면 전체 프로세스를 5ms 주기로 한 번씩 수행시키고<br>그 보다 많다면 (1ms * 프로세스 수) 만큼의 주기로 수행시키게 된다.</p><p>이제 위에서 계산한 전체 시간에 대해 현재 프로세스에게 할당된 시간을 알아내야 한다.<br>아래는 프로세스의 load (weight)를 통해 이를 수행하는 sched_slice() 함수이다.<br>(앞서 __update_curr()와 비교하여 calc_delta_mine() 호출 시 se의 위치를 살펴보자.)</p><p>static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)<br>{<br> u64 slice = __sched_period(cfs_rq-&gt;nr_running + !se-&gt;on_rq);</p><p>for_each_sched_entity(se) {<br> struct load_weight *load;<br> struct load_weight lw;</p><p>cfs_rq = cfs_rq_of(se);<br> load = &amp;cfs_rq-&gt;load;</p><p>if (unlikely(!se-&gt;on_rq)) {<br> lw = cfs_rq-&gt;load;</p><p>update_load_add(&amp;lw, se-&gt;load.weight);<br> load = &amp;lw;<br> }<br> slice = calc_delta_mine(slice, se-&gt;load.weight, load);<br> }<br> return slice;<br>}</p><p>먼저 se-&gt;on_rq가 0인 경우는 현재 프로세스가 CPU에서 실행 중인 경우이다.<br>CFS는 실행 중인 프로세스를 run queue에서 제거하므로 전체 시간 및 load 계산 시<br>이를 다시 추가해서 계산해 주어야 한다.<br>또한 지금은 설명을 단순하게 하기 위해 group scheduling은 고려하지 않으므로<br>for_each_sched_entity 부분은 단 한 번만 수행된다고 생각하기로 하자.</p><p>이는 프로세스마다 (load에 따라) 공평하게 계산하여 주어진 시간이므로<br>이상적인(ideal) 실행 시간으로 생각할 수 있으며 타이머 인터럽트 핸들러에서는<br>프로세스의 실행 시간이 이상적인 실행 시간보다 큰 경우 스케줄링을 요청한다.<br>이를 처리하는 함수는 다음과 같다.</p><p>static void<br>check_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr)<br>{<br> unsigned long ideal_runtime, delta_exec;</p><p>ideal_runtime = sched_slice(cfs_rq, curr);<br> delta_exec = curr-&gt;sum_exec_runtime — curr-&gt;prev_sum_exec_runtime;<br> if (delta_exec &gt; ideal_runtime) {<br> resched_task(rq_of(cfs_rq)-&gt;curr);<br> …<br> return;<br> }</p><p>…<br>}</p><p>이제 nice 값에 따라 CPU 자원이 어떻게 분배되는지 한 번 계산해 보기로 하자.<br>간단한 예제를 위해 다음과 같은 프로세스가 5개 있고, __sched_period가 10ms를 반환한다고 가정한다.</p><p>niceweightWp/Wttime slice (ms)W0/Wpvruntime (ms)-1095480.6756.750.1070.72–531210.2212.210.3280.72010240.0720.7210.7253350.0240.243.0570.73101100.0080.089.3090.74total141381.00010.00</p><p>먼저, Wp는 해당 프로세스의 weight 값, Wt는 시스템 전체의 weight 값을 의미하며<br>W0는 nice 0인 프로세스의 weight (NICE_O_LOAD)를 의미한다.<br>weight 값을 보면 nice 5 단계 당 약 3 배 정도 CPU를 더 사용할 수 있음을 짐작할 수 있다.</p><p>nice -10인 프로세스는 전체 load의 67.5%를 차지하므로<br>10ms 중에서 6.75ms의 시간 동안 실행될 것이다.<br>반대로 weight의 역비는 0.107이므로 vruntime은 6.75 * 0.107 = 0.72가 된다.<br>위의 표에서 보듯이 실제 할당된 time slice는 프로세스의 weight에 비례하지만<br>vruntime은 모든 프로세스에서 거의 동등하게 나타나는 것을 볼 수 있다.</p><p>하지만 타이머 인터럽트는 HZ 주기로 발생하므로<br>weight가 낮은 프로세스의 실제 time slice 값이 이 보다 작게 할당되었어도<br>(별다른 외부 요인이 없는 경우) 1 tick 만큼의 시간 동안 실행될 수는 있겠지만<br>이 경우 vruntime에 훨씬 큰 값이 반영될 것이므로 CFS run queue의 뒤쪽에 놓일 것이고<br>그 만큼 오랜 시간이 지난 후에야 다시 CPU를 획득할 수 있을 것이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e25a7ee5d9a0" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Utilities of Mac OS X]]></title>
            <link>https://medium.com/@seoyoochan/utilities-of-mac-os-x-c8db71ea6c35?source=rss-ee627a24b6b2------2</link>
            <guid isPermaLink="false">https://medium.com/p/c8db71ea6c35</guid>
            <category><![CDATA[tech]]></category>
            <category><![CDATA[apple]]></category>
            <category><![CDATA[mac]]></category>
            <dc:creator><![CDATA[Seo Yoochan]]></dc:creator>
            <pubDate>Thu, 21 Apr 2016 13:50:56 GMT</pubDate>
            <atom:updated>2016-04-21T13:50:56.752Z</atom:updated>
            <content:encoded><![CDATA[<p>When I am tired of googling about how to use some of utilities on Mac, I came across my mind about<em> </em><a href="https://developer.apple.com/library/"><em>Apple Developer Library</em></a>!</p><p>ADL provides all the documentation about their OS/App.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*qQy51K0VRGoHBURbS6aKQA.png" /><figcaption>Apple Developer Library</figcaption></figure><p>Because I want to read the documentation of Mac OSX, click <strong>‘OS X’</strong> and search <strong><em>man page</em></strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*orC_98HrD045sMsDzVLAwA.png" /><figcaption>OS X Library</figcaption></figure><p>If you open <em>OS X Man Pages</em>,<em> </em>you will see the below.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*aDkeOugHq4uD3oru7Ep1AA.png" /><figcaption>Mac OS X Manual Pages</figcaption></figure><p>There you go!</p><p>Now you can find anything provided by Darwin(actually based on BSD and POSIX tho).</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c8db71ea6c35" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Federal Information Processing Standards]]></title>
            <link>https://medium.com/@seoyoochan/federal-information-processing-standards-5e5e7ba66e69?source=rss-ee627a24b6b2------2</link>
            <guid isPermaLink="false">https://medium.com/p/5e5e7ba66e69</guid>
            <category><![CDATA[tech]]></category>
            <category><![CDATA[government]]></category>
            <category><![CDATA[computer-security]]></category>
            <dc:creator><![CDATA[Seo Yoochan]]></dc:creator>
            <pubDate>Thu, 21 Apr 2016 13:25:46 GMT</pubDate>
            <atom:updated>2016-04-21T13:25:46.610Z</atom:updated>
            <content:encoded><![CDATA[<p><strong>Federal Information Processing Standards</strong> (<strong>FIPS</strong>) are publicly announced <a href="https://en.wikipedia.org/wiki/Standardization">standards</a> developed by the <a href="https://en.wikipedia.org/wiki/United_States_federal_government">United States federal government</a> for use in computer systems by non-military government agencies and government contractors.<a href="https://en.wikipedia.org/wiki/Federal_Information_Processing_Standards#cite_note-GenInfo-1">[1]</a></p><p>FIPS standards are issued to establish requirements for various purposes such as ensuring computer security and interoperability, and are intended for cases in which suitable industry standards do not already exist.<a href="https://en.wikipedia.org/wiki/Federal_Information_Processing_Standards#cite_note-GenInfo-1">[1]</a> Many FIPS specifications are modified versions of standards used in the technical communities, such as the <a href="https://en.wikipedia.org/wiki/American_National_Standards_Institute">American National Standards Institute</a> (ANSI), the <a href="https://en.wikipedia.org/wiki/Institute_of_Electrical_and_Electronics_Engineers">Institute of Electrical and Electronics Engineers</a> (IEEE), and the <a href="https://en.wikipedia.org/wiki/International_Organization_for_Standardization">International Organization for Standardization</a> (ISO).</p><p><a href="https://en.wikipedia.org/wiki/Federal_Information_Processing_Standards">https://en.wikipedia.org/wiki/Federal_Information_Processing_Standards</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5e5e7ba66e69" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Critical Security Parameter]]></title>
            <link>https://medium.com/@seoyoochan/critical-security-parameter-33f031558129?source=rss-ee627a24b6b2------2</link>
            <guid isPermaLink="false">https://medium.com/p/33f031558129</guid>
            <category><![CDATA[authentication]]></category>
            <category><![CDATA[cryptography]]></category>
            <category><![CDATA[security]]></category>
            <dc:creator><![CDATA[Seo Yoochan]]></dc:creator>
            <pubDate>Thu, 21 Apr 2016 13:18:46 GMT</pubDate>
            <atom:updated>2016-04-21T13:18:46.413Z</atom:updated>
            <content:encoded><![CDATA[<p>In <a href="https://en.wikipedia.org/wiki/Cryptography">cryptography</a>, the abbreviation <strong><em>CSP</em></strong> may refer to <strong><em>Critical Security Parameter</em></strong>.<a href="https://en.wikipedia.org/wiki/Critical_Security_Parameter#cite_note-1">[1]</a> A Critical Security Parameter is information that is either <a href="https://en.wikipedia.org/wiki/User_(computing)">user</a> or <a href="https://en.wikipedia.org/wiki/System">system</a>defined and is used to operate a cryptography module in processing <a href="https://en.wikipedia.org/wiki/Encryption">encryption</a> functions including cryptographic keys and authentication data, such as passwords, the disclosure or modification of which can compromise the security of a cryptographic module or the security of the information protected by the module.</p><p><a href="https://en.wikipedia.org/wiki/Critical_Security_Parameter">https://en.wikipedia.org/wiki/Critical_Security_Parameter</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=33f031558129" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Get CPU Info via Command Line in Mac OS X]]></title>
            <link>https://medium.com/@seoyoochan/get-cpu-info-via-command-line-in-mac-os-x-566f45a43f46?source=rss-ee627a24b6b2------2</link>
            <guid isPermaLink="false">https://medium.com/p/566f45a43f46</guid>
            <category><![CDATA[mac]]></category>
            <category><![CDATA[tech]]></category>
            <dc:creator><![CDATA[Seo Yoochan]]></dc:creator>
            <pubDate>Thu, 21 Apr 2016 12:40:10 GMT</pubDate>
            <atom:updated>2016-04-21T12:40:10.801Z</atom:updated>
            <content:encoded><![CDATA[<p>There are twoways to grab a Macs CPU details from the command line of OS X.</p><h4>Finding Mac Processor Details &amp; CPU Speed with sysctl</h4><p>First we’ll use sysctl because it give us everything on one easy to read line:</p><blockquote>sysctl -n machdep.cpu.brand_string</blockquote><p>The example output may look like any of the following:</p><blockquote>Intel(R) Core(TM) M-5Y31 CPU @ 0.90GHz</blockquote><p>This is basically in the following format: <strong>Chip Brand — Processor Type and Chip Model — CPU Speed</strong></p><p>That detailed output of sysctl is advantageous because it reports back the chip model as well.</p><h4>Get CPU Processor Details of a Mac with system_profiler</h4><p>On the other hand, if you don’t want the model number and simply want processor name, speed, and the number of processors, you can use grep with <strong>system_profiler</strong>:</p><blockquote>system_profiler | grep Processor</blockquote><blockquote>Apple: AUDynamicsProcessor:<br>Apple: AUVoiceProcessor:<br>Processor Name: Intel Core M<br>Processor Speed: 1.1 GHz<br>Number of Processors: 1<br>&lt;key&gt;BootCampProcessorPstates&lt;/key&gt;<br>| “BootCampProcessorPstates” = &lt;0700&gt;</blockquote><p>For the record, and for more average Mac users, there is a much easier way to get this information, just go to “About This Mac” under the  Apple menu.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/353/1*IVPT7b3qeNjTHWt3luXgLw.jpeg" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*2l2NCwCDgQwWkYdlxYmAGw.png" /></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=566f45a43f46" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Do not use or update system Ruby]]></title>
            <link>https://medium.com/@seoyoochan/do-not-use-or-update-system-ruby-7661e01a919c?source=rss-ee627a24b6b2------2</link>
            <guid isPermaLink="false">https://medium.com/p/7661e01a919c</guid>
            <category><![CDATA[programming]]></category>
            <category><![CDATA[ruby]]></category>
            <category><![CDATA[mac]]></category>
            <dc:creator><![CDATA[Seo Yoochan]]></dc:creator>
            <pubDate>Thu, 21 Apr 2016 07:36:33 GMT</pubDate>
            <atom:updated>2016-04-21T07:36:33.433Z</atom:updated>
            <content:encoded><![CDATA[<p>author: Joel Oliveira</p><p>date: June 28, 2013</p><p>original link: <a href="https://robots.thoughtbot.com/psa-do-not-use-system-ruby">https://robots.thoughtbot.com/psa-do-not-use-system-ruby</a></p><p>OS X Mavericks may ship with Ruby 2.0. Cool, right?<strong> Don’t touch it.</strong></p><h3>Why eschew system Ruby</h3><p>The root problem is not with using a pre-installed Ruby per se, but with <em>not using a Ruby version manager.</em></p><h3>Problem: Gem Dependencies</h3><p>PC users will remember <a href="http://en.wikipedia.org/wiki/DLL_Hell">DLL hell</a>. Ruby developers have dealt with similar problems.</p><p>Problems regarding gem dependencies are introduced after upgrading sudo-installed gems. At this point you are left to shepherd the gems and dependencies of Rubygems on your system’s install. Plain vanilla dependency management of Rubygems is not for the faint of heart, this is why Bundler exists. It could be argued that <a href="http://gembundler.com/">Bundler</a> singlehandedly saved the Ruby ecosystem from this issue. If you don’t plan to use Bundler to manage your Ruby-based app dependencies you will shoot yourself in the foot.</p><p>For your Ruby-centric applications use Bundler.</p><h3>Problem: Upgrading Ruby</h3><p>If you’ve run into issues with Ruby and decided to upgrade your system’s runtime you stand the chance of breaking tools that may depend on your old install. Tools like VIM depend on what it was compiled against. Making that update could very well impact the tools that have been built against it.</p><h3>Choose an Alternative</h3><p>Ruby “version managers” will install Ruby and configure your environment for their use.</p><p>rbenv is a light-weight solution from 37Signals that we default to in our laptop setup.<br>Chruby and ruby-install (installation instructions) are the latest option and leave the lightest footprint of the three. Pat Brisbin, a thoughtbot teammate, has a recent blog post about chruby that is worth reading.<br>RVM (installation instructions), the father of Ruby version managers. Full disclosure — I am a happy user and supporter.</p><h3>System Ruby and Rubygems — don’t use them</h3><p>The amount of uncertainty is too great to build your working environment around the default Ruby-related tools. For the experienced Ruby developer this is nothing new. For the beginner or novice working with Ruby for the first time this might not be quite so obvious. Consider <a href="https://www.google.com/search?q=%22sudo+gem+install%22&amp;oq=%22sudo+gem+install%22&amp;aqs=chrome.0.57j0l3j62l2.3569j0&amp;sourceid=chrome&amp;ie=UTF-8">how many gems still recommend</a> using sudo gem install in their instructions? If your project is one of them, please update it to <strong>not</strong> do so.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7661e01a919c" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[How to fix the error installing therubyracer]]></title>
            <link>https://medium.com/@seoyoochan/how-to-fix-the-error-installing-therubyracer-2ca65406f685?source=rss-ee627a24b6b2------2</link>
            <guid isPermaLink="false">https://medium.com/p/2ca65406f685</guid>
            <category><![CDATA[ruby]]></category>
            <category><![CDATA[ruby-on-rails]]></category>
            <category><![CDATA[rails]]></category>
            <dc:creator><![CDATA[Seo Yoochan]]></dc:creator>
            <pubDate>Thu, 21 Apr 2016 05:28:32 GMT</pubDate>
            <atom:updated>2016-04-21T05:52:50.239Z</atom:updated>
            <content:encoded><![CDATA[<p>When you install `therubyracer` gem with rails, you are likely to see installation errors relating to `libv8` gem, the interface of v8 engine, or `therubyracer` gem, V8 javascript interpreter in Ruby.</p><p>My OSX: v10.11.4 ( El Capitan )</p><p>Ruby: 2.2.4</p><p>Here’s the solution.</p><pre>brew tap homebrew/versions<br>brew install v8-315<br>brew link --force v8-315<br>bundle config --local build.libv8 --with-system-v8<br>bundle config --local build.therubyracer --with-v8-dir=/usr/local/opt/v8-315<br>bundle install</pre><p>Reference: <a href="https://github.com/cowboyd/therubyracer/issues/405">https://github.com/cowboyd/therubyracer/issues/405</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2ca65406f685" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>