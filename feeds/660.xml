<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Donghwa Lee on Medium]]></title>
        <description><![CDATA[Stories by Donghwa Lee on Medium]]></description>
        <link>https://medium.com/@moralmk?source=rss-f44fb2a64b8d------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*dRsN6q7Ws7Ql7bnleD9HyA.png</url>
            <title>Stories by Donghwa Lee on Medium</title>
            <link>https://medium.com/@moralmk?source=rss-f44fb2a64b8d------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 08:14:45 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@moralmk" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[Node.js 버전 관리 방법]]></title>
            <link>https://medium.com/@moralmk/node-js-%EB%B2%84%EC%A0%84-%EA%B4%80%EB%A6%AC-%EB%B0%A9%EB%B2%95-84818ceeff08?source=rss-f44fb2a64b8d------2</link>
            <guid isPermaLink="false">https://medium.com/p/84818ceeff08</guid>
            <category><![CDATA[nodejs]]></category>
            <category><![CDATA[javascript]]></category>
            <dc:creator><![CDATA[Donghwa Lee]]></dc:creator>
            <pubDate>Tue, 19 Feb 2019 13:23:41 GMT</pubDate>
            <atom:updated>2019-02-19T13:31:15.130Z</atom:updated>
            <content:encoded><![CDATA[<h3>Node.js 버전 관리도구 nvm 맛보기</h3><p>개발을 하다보면 필요에 따라 다양한 node.js의 버전을 사용해야할 때가 있습니다. nvm을 사용하면 다양한 버전 node.js를 설치할 수 있고, 간단한 명령어 만으로 버전을 스위치 할 수 있습니다.</p><figure><img alt="node nvmì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼" src="https://cdn-images-1.medium.com/proxy/1*XeFELjfQfDkPL-s7dE9-CQ.png" /></figure><h3>nvm 설치하기</h3><p>Mac에서 설치하는 것으로 가정하겠습니다. MacOS 패키지 관리자 brew를 사용해서 설치할 수 있습니다. 만약 미처 brew가 설치되어 있지 않다면, <a href="https://brew.sh/index_ko">여기</a>를 먼저 참고하세요.</p><pre>$ brew install nvm</pre><p>nvm 명령어를 사용하기 위해 .bash_profile 파일에 아래를 추가합니다.</p><pre>export NVM_DIR=~/.nvm<br>source $(brew --prefix nvm)/nvm.sh</pre><p>마지막으로 수정한 .bash_profile을 적용합니다.</p><pre>$ source ~/.bash_profile</pre><p>여기까지 해서 지금부터는 nvm 명령어를 사용할 수 있습니다.</p><h3>nvm 통해 node 설치하기</h3><p>10.x 버전 중 가장 최신 버전의 node를 설치하는 명령입니다. 제거는 물론install 옵션 대신 uninstall 사용하면 됩니다.</p><pre>$ nvm install 10</pre><h3>node 버전 전환하기</h3><p>7.x 버전을 사용하기 위해 아래 명령을 사용합니다. 7.x 버전이 설치되어 있다면 바로 전환될 것이고, 만약 설치되어 있지 않다면 nvm install 7와 같이 설치 명령어가 안내됩니다.</p><pre>$ nvm use 7</pre><p>아래 명령으로 현재 설치되어 있는 node 버전들을 확인할 수 있습니다.</p><pre>$ nvm ls</pre><p><a href="https://github.com/creationix/nvm">creationix/nvm</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=84818ceeff08" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Electron 앱 만들기 맛보기]]></title>
            <link>https://medium.com/@moralmk/electron-%EC%95%B1-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EB%A7%9B%EB%B3%B4%EA%B8%B0-a141e648bfdb?source=rss-f44fb2a64b8d------2</link>
            <guid isPermaLink="false">https://medium.com/p/a141e648bfdb</guid>
            <category><![CDATA[application-development]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[nodejs]]></category>
            <category><![CDATA[desktop-app]]></category>
            <category><![CDATA[electron]]></category>
            <dc:creator><![CDATA[Donghwa Lee]]></dc:creator>
            <pubDate>Mon, 18 Feb 2019 18:46:24 GMT</pubDate>
            <atom:updated>2019-02-19T13:29:58.138Z</atom:updated>
            <content:encoded><![CDATA[<p><a href="https://electronjs.org/">Electron</a>을 이용하면 Chromium과 Node.js를 사용하여 HTML, CSS, 그리고 JavaScript 만으로 데스크톱 애플리케이션을 만들 수 있습니다. 특히 Mac, Windows, Linux 세 가지 플랫폼에서 빌드되고 동작하기 때문에 아주 효율적입니다.</p><p>Skype, <a href="https://desktop.github.com/">Github Desktop</a>, <a href="https://www.gitkraken.com/">GitKraken</a>, <a href="https://code.visualstudio.com/">Visual Studio Code</a>, <a href="https://slack.com/">Slack</a>, <a href="https://atom.io/">Atom</a>… 개발자라면 익숙해할 이 데스크톱 애플리케이션들이 모두 Electron으로 설계된 것들 입니다.</p><h3>프로젝트 생성 및 준비</h3><p>먼저 프로젝트 폴더를 생성한 후 초기화 합니다. 그리고 electron을 설치합니다. 여기에서 프로젝트명은 ‘snicat’ 으로 하겠습니다.</p><pre>$ mkdir snicat &amp;&amp; cd snicat<br>$ npm init<br>$ npm install --save-dev electron</pre><h3>애플리케이션 구동 파일 작성</h3><p>main.js 파일을 작성합니다. 애플리케이션이 준비되면 브라우저 윈도우를 800 * 600 사이즈로 생성한 뒤 index.html 페이지를 표시하는 내용입니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/2d2972ba16bbef631944953b06a52b9f/href">https://medium.com/media/2d2972ba16bbef631944953b06a52b9f/href</a></iframe><h3>페이지 파일 작성</h3><p>index.html 파일을 작성합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/8c9a91e45b82859be3bc362666158699/href">https://medium.com/media/8c9a91e45b82859be3bc362666158699/href</a></iframe><p>이와 같은 결과를 보여주는 페이지입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*O2qXpc65zyiMl_ltCrOb6Q.png" /></figure><h3>실행 스크립트 추가</h3><p>프로젝트 초기화 시에 생성된 package.json 내용을 수정합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/6b1be742455156ad0aaf666599ccedad/href">https://medium.com/media/6b1be742455156ad0aaf666599ccedad/href</a></iframe><p>5번째 라인은 앞서 작성한 main.js 파일입니다. 그리고 8번째 라인은 애플리케이션 실행을 위한 스크립트 명령입니다.</p><h3>애플리케이션 실행</h3><p>마지막으로 아래 명령으로 애플리케이션을 실행합니다.</p><pre>$ npm start</pre><p><a href="https://electronjs.org/docs/tutorial/first-app">Writing Your First Electron App | Electron</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a141e648bfdb" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Lottie : 새로운 오픈 소스 애니메이션 도구]]></title>
            <link>https://medium.com/@moralmk/lottie-%EC%83%88%EB%A1%9C%EC%9A%B4-%EC%98%A4%ED%94%88-%EC%86%8C%EC%8A%A4-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-%EB%8F%84%EA%B5%AC-4488d3da6e26?source=rss-f44fb2a64b8d------2</link>
            <guid isPermaLink="false">https://medium.com/p/4488d3da6e26</guid>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[animation]]></category>
            <category><![CDATA[lottie]]></category>
            <category><![CDATA[front-end-development]]></category>
            <category><![CDATA[airbnb]]></category>
            <dc:creator><![CDATA[Donghwa Lee]]></dc:creator>
            <pubDate>Mon, 28 Aug 2017 09:42:57 GMT</pubDate>
            <atom:updated>2019-02-18T19:01:16.590Z</atom:updated>
            <content:encoded><![CDATA[<p>아래는 Airbnb에서 Experience and Motion Designer로 일하고 있는 Salih Abdul-Karim(아래)의 글의 번역글이며, 원문 url은 아래와 같습니다.</p><p>번역 원문 :<br><a href="https://airbnb.design/introducing-lottie/">https://airbnb.design/introducing-lottie/</a></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/500/0*Ht9rXkZED8x7hxMA.jpg" /><figcaption>Salih Abdul-Karim is an Experience and Motion Designer at Airbnb.</figcaption></figure><p>과거에는 Android, iOS 및 React Native 앱용 복합 애니메이션을 제작하는 것이 어렵고 긴 과정이었습니다. 각 화면 크기에 용량이 큰 이미지 파일을 추가하거나 1,000 줄이 넘는 관리하기 어려운 코드를 작성해야 했습니다. 이 때문에 대부분의 앱은 아이디어를 전달하고 강력한 사용자 경험을 창출하는 강력한 도구 임에도 불구하고, 애니메이션을 사용하지 않았습니다. 1 년 전, 우리는 그것을 바꾸기 시작했습니다.</p><p>오늘 우리는 우리의 솔루션을 소개하려고 합니다. Lottie는 After Effects 애니메이션을 실시간으로 렌더링하는 iOS, Android 및 React Native 라이브러리로, 정적 앱을 사용하는 것처럼 쉽게 기본 앱에서 애니메이션을 사용할 수 있습니다. Lottie는 <a href="https://github.com/bodymovin/bodymovin">Bodymovin</a> 이라는 오픈 소스를 이용한 After Effects 확장 기능에서 JSON 형식으로 추출한 애니메이션 데이터를 사용합니다 . 확장 기능은 웹상에서 애니메이션을 렌더링 할 수있는 JavaScript 플레이어와 번들로 제공됩니다. Bodymovin의 창시자 <a href="https://twitter.com/airnanan">Hernan Torrisi</a>는 2015년 2월 이래로 매월 플러그인 기능과 개선사항을 추가하여 탄탄한 기반을 구축해왔습니다. 우리 팀(<a href="https://github.com/airbnb/lottie-ios">iOS</a>에는 <a href="http://github.com/buba447">Brandon Withrow</a>, <a href="https://github.com/airbnb/lottie-android">안드로이드</a>에는 <a href="https://twitter.com/gpeal8">Gabriel Peal</a>, <a href="https://github.com/airbnb/lottie-react-native">React Native</a>에는 <a href="https://twitter.com/intelligibabble">Leland Richardson</a>, 그리고 <a href="https://twitter.com/therealsalih?lang=en">저는</a> Experience Design을 담당)은 Torrisi의 놀라운 작업물을 시작으로 여정을 시작했습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*tLJBvcMic0P_toYRCuXZCQ.gif" /></figure><p>Lottie를 사용하면 엔지니어가 다시 작성하는 번거로움 없이 풍부한 애니메이션을 제작할 수 있습니다. Nick Butcher의 <a href="https://medium.com/google-developers/animation-jump-through-861f4f5b3de4#.xlw1n2u2d">jump-through</a> 애니메이션, Bartek Lipinski의 <a href="https://android.jlelse.eu/animatedvectordrawablecompat-3d9568727c53#.fmiujhcdj">햄버거 메뉴</a>, Miroslaw Stanek의 <a href="http://frogermcs.github.io/twitters-like-animation-in-android-alternative/">Twitter heart</a>는 처음부터 애니메이션을 다시 만드는 것이 얼마나 어렵고 오래 걸리는지를 보여줍니다. Lottie를 활용하면 참조용을 위해 프레임워크를 파헤치고, 기간을 추측키만 하고, 직접 Bezier 곡선을 작성하고, 참조용 GIF로 애니메이션을 다시 만들어야 하는 일들이 과거가 될 것입니다. 이제 개발자는 디자이너의 의도를 정확하게 파악할 수 있습니다. 이를 증명하기 위해 우리는 샘플 애니메이션에서 각각의 애니메이션을 재 생성하고, After Effects 및 JSON 파일을 제공합니다.</p><p>우리의 목표는 가능한 한 많은 After Effects 기능을 지원하여 단순한 아이콘 애니메이션 이상의 것이 가능하도록 하는 것입니다. 우리는 라이브러리의 flexibility, richness 및 특별한 기능들을 보여줄 수 있는 몇 가지 샘플을 만들었습니다. 샘플 앱에는 기본 라인 아트, 문자 기반 애니메이션, 여러 각도와 컷이 포함된 동적 로고 애니메이션 등 다양한 종류의 애니메이션에 대한 소스 파일도 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*6FrdkRVvurbr_RDz-P-BYQ.gif" /></figure><p>이미 In-app 알림, 전체 프레임에서 움직이는 일러스트레이션 및 리뷰 플로우와 같은 여러 화면에서 자체 Lottie 애니메이션을 만들기 시작했습니다. 앞으로도 재미있고 유용한 방법으로 애니메이션 사용을 크게 확대할 계획입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Skzy0VeoVwi124DW6rrhGA.gif" /></figure><h3>유연하고 효율적인 솔루션</h3><p>Airbnb는 수백만 명의 게스트 및 호스트를 지원하는 글로벌 기업이므로 여러 플랫폼에서 재생할 수 있는 유연한 애니메이션 형식을 갖추는 것이 매우 중요했습니다. Marcus Eckert의 <a href="http://www.marcuseckert.com/squall/">Squall</a> 이나 Facebook의 <a href="https://github.com/facebookincubator/Keyframes">Keyframes</a> 와 같은 Lottie와 유사한 라이브러리가 있지만 목표는 약간 다릅니다. Facebook은 주로 반응성에 초점을 맞추기 때문에 After Effects 기능을 지원하기 위해 작은 세트를 선택했지만, 우리는 최대한 많은 것을 지원하고자 합니다. Squall의 경우 Airbnb의 디자이너가 Lottie와 함께 사용합니다. 그 이유는 workflow의 필수적인 부분이 된 놀라운 After Effects 미리보기 앱이 있기 때문입니다. 그러나 iOS만 지원하며 엔지니어링 팀에서는 cross-platform 솔루션이 필요했습니다.</p><p>Lottie는 API를 보다 다양하고 효율적으로 만들 수 있는 몇 가지 기능을 API에 담고 있습니다. 네트워크를 통해 JSON 파일을 로드할 수 있으므로 A/B 테스트하기에 유용합니다. 또한 caching 메커니즘을 가지고 있어 자주 사용되는 애니메이션(예 : 위시리스트)은 캐시된 복사본을 매번 로드할 수 있습니다. Lottie 애니메이션은 제스처에 의해서 구동될 수 있으며, 애니메이션 속도는 간단한 값을 변경하여 조작할 수 있습니다. iOS는 런타임 시 애니메이션에 추가적인 native UI를 추가하는 기능을 지원하기 때문에 복잡한 애니메이션 전환에 사용할 수 있습니다.</p><p>지금까지 작업한 모든 After Effects 기능 및 API 추가 외에도 많은 아이디어가 있습니다. 여기에는 Lottie 애니메이션에 뷰를 매핑하고, Lottie로 뷰 전환을 제어하고, <a href="http://www.battleaxe.co/rubberhose/">Battle Axs의 RubberHose</a>를 지원하고, 그라디언트, 타입 및 이미지 지원이 포함됩니다. 가장 어려운 것은 다음에 해결할 기능 하나를 선택하는 것입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*bZbrDT3NGJDw8LoIy3L3mQ.png" /></figure><h3>커뮤니티 구성</h3><p>오픈소스로 무언가를 공개하는 것은 모두가 사용할 수 있도록 공개하는 것 이상의 의미입니다. 이것은 사람들을 연결하고 커뮤니티를 만드는 다리입니다. 우리가 GitHub을 통해 디자이너와 엔지니어에게 Lottie를 공개할 때가 가까워짐에 따라, 우리는 애니메이션 관련 folks들과도 소통하고 싶었습니다.</p><p>우리는 <a href="http://9-squares.tumblr.com/">9 Squares</a>, <a href="https://motioncorpse.tumblr.com/">Motion Corpse</a> 및 <a href="https://animography.net/products/mobilo">Animography</a>가 만든 커뮤니티에서 영감을 받았습니다 . 이 세 명 모두는 공공 애니메이션 프로젝트에 협력하기 위해 전세계 사람들을 모았습니다. 이 프로젝트는 수개월의 작업과 각 팀의 많은 조직 및 논쟁을 가지고있지만 의심의 여지없이 애니메이션 커뮤니티 전체에 막대한 가치를 제공합니다. Motion Corpse 및 Animography는 After Effects 소스 파일도 공개적으로 공유하므로 사람들의 작업방식에 대한 통찰력을 제공합니다.</p><p>그들의 공동 연구 결과에 따라 우리는 세 팀 모두에게 샘플 앱에 애니메이션을 제공했습니다. JR Canest가 제작한 Motion Corpse의 애니메이션, 9 Square 프로젝트의 Al Boardman의 사각형 중 하나, Animography의 Mobilo 애니메이션 서체를 사용한 애니메이션 키보드가 포함되어 있습니다. 이 서체에는 24명이 넘는 아티스트의 작품이 있습니다. 우리는 이러한 애니메이션 커뮤니티와 강력한 개발 커뮤니티가 합쳐져 ​​뭔가 특별한 것을 만들어 내기를 바랍니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*VYA3Hx-eO7qDCr0ONlIlhQ.gif" /></figure><p>디자이너, 애니메이터 또는 개발자든 상관없이 Lottie를 어떻게 사용하고 있는지 듣고 싶습니다. 당신의 생각, 의견 및 통찰력을 통해 lottie@airbnb.com으로 직접 문의해주세요. 우리는 상상도 못했던 방식으로 Lottie를 사용하기 시작했을 때, 전세계 사람들이 어떤 일을 할 것인지 알게 되다면 매우 기쁠 것입니다.</p><p><strong>다운로드 </strong><a href="https://github.com/bodymovin/bodymovin"><strong>Bodymovin</strong></a><strong>, 로티 </strong><a href="https://github.com/airbnb/lottie-ios"><strong>iOS</strong></a><strong> , </strong><a href="https://github.com/airbnb/lottie-android"><strong>안드로이드</strong></a><strong> 및 </strong><a href="https://github.com/airbnb/lottie-react-native"><strong>React Native</strong></a><strong>.</strong></p><p><a href="http://github.com/buba447">Brandon Withrow</a>, <a href="https://twitter.com/gpeal8">Gabriel Peal</a> 및 <a href="https://twitter.com/therealsalih?lang=en">Salih Abdul-Karim</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4488d3da6e26" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Node.js, MySQL and Promises]]></title>
            <link>https://medium.com/@moralmk/node-js-mysql-and-promises-6309f3915d37?source=rss-f44fb2a64b8d------2</link>
            <guid isPermaLink="false">https://medium.com/p/6309f3915d37</guid>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[mysql]]></category>
            <category><![CDATA[nodejs]]></category>
            <category><![CDATA[promises]]></category>
            <dc:creator><![CDATA[Donghwa Lee]]></dc:creator>
            <pubDate>Mon, 28 Aug 2017 02:16:57 GMT</pubDate>
            <atom:updated>2019-02-18T19:01:54.052Z</atom:updated>
            <content:encoded><![CDATA[<p>번역 원문 :<br><a href="https://codeburst.io/node-js-mysql-and-promises-4c3be599909b">https://codeburst.io/node-js-mysql-and-promises-4c3be599909b</a></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*SqFb9yvFonPuSdby.jpg" /></figure><p>Node.js에서 데이터베이스 액세스는 대부분의 I/O 작업과 마찬가지로 비동기로 작동합니다. 결과를 기다리는 동안 다른 작업을 수행할 수 있기 때문에 매우 매력적인 기능입니다. 그러나 이 기능은 다른 프로그래밍 언어를 사용한다면 정말 짜증납니다.</p><p>PHP로는 다음과 같이 작성할 수 있습니다.</p><pre>$results = $connection -&gt; query(&#39;SELECT * FROM some_table&#39;);<br>// the following code is executed after the query is executed</pre><p>물론 query() 메서드는 실행하는데 약간의 시간이 걸릴 수 있지만 개발자의 관점에서는 큰 문제가 되지 않습니다. SQL 쿼리를 실행해서 결과를 반환하는 단일 연산으로 작동합니다.</p><p>Node.js에서는 다음과 같이 작성해야 합니다.</p><pre>connection.query(&#39;SELECT * FROM some_table&#39;, (err, rows) =&gt; {<br>    // do something with the results here<br>});<br>// the following code is executed *before* the query is executed</pre><p>예에서는 MySQL 클라이언트 라이브러리를 사용하고 있지만, no-SQL 엔진을 포함한 다른 모든 데이터베이스에서도 마찬가지입니다. 🙂</p><p>일단 위의 예는 그리 나쁘지 않습니다. 그러나 몇 가지 쿼리를 순차적으로 수행해야한다고 가정해볼까요? 마지막에는 비동기 작업이기도 한 데이터베이스 연결을 끊는 작업까지 한다면 아래와 같습니다.</p><pre>connection.query(&#39;SELECT * FROM some_table&#39;, (err, rows) =&gt; {<br>  connection.query(&#39;SELECT * FROM other_table&#39;, (err, rows2) =&gt; {<br>    connection.close(err =&gt; {<br>      // ... do something with all the results<br>    }<br>  }<br>}</pre><p>이런 방식으로 10개의 중첩된 쿼리가 있다고 상상해보세요. 그리고 각각의 쿼리 블락에서 오류 처리를 다루어야 합니다. 어느 레벨에서 오류가 발생하더라도 데이터베이스 연결이 정상적으로 닫히는지 확인해야 합니다.</p><p>이러한 작업은 위와 같은 방식으로 쓰는 것이 매우 어렵습니다. 중간에 또 다른 쿼리를 삽입해야하는 경우 수정하기도 어렵습니다. 그리고 무엇보다 소스코드를 읽고 이해하는데 큰 어려움을 줍니다.</p><h3>Using promises</h3><p>Promises가 이러한 문제들을 해결할 수 있습니다. Promise 개념이 익숙하지 않다면 사전에 소개를 읽는 것이 좋습니다. (예 : <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises">여기</a> 또는 <a href="https://developers.google.com/web/fundamentals/getting-started/primers/promises">여기)</a> 저는 순차적인 데이터베이스 쿼리 수행에 있어서 Promise의 실제적인 사용법을 보여주고자 합니다. 그래서 저는 일단 당신이 기본적인 개념에 대해서는 이미 알고 있다고 가정하겠습니다.</p><p>먼저 데이터베이스 클라이언트를 ‘Promisfy’ 해야 합니다. 수동으로 할 필요는 없습니다. <a href="https://codeburst.io/quick-dig-promisify-in-node-js-6d5d763f847d">여기</a>에 설명된 것과 같이 자동화 도구를 사용할 수도 있지만 MySQL 클라이언트에 대한 Wrapper 클래스를 만드는 것은 매우 간단합니다.</p><pre>const mysql = require(&#39;mysql&#39;);</pre><pre>class Database {<br>    constructor(config) {<br>        this.connection = mysql.createConnection(config);<br>    }<br>    query(sql, args) {<br>        return new Promise((resolve, reject) =&gt; {<br>            this.connection.query(sql, args, (err, rows) =&gt; {<br>                if (err)<br>                    return reject(err);<br>                resolve(rows);<br>            });<br>        });<br>    }<br>    close() {<br>        return new Promise((resolve, reject) =&gt; {<br>            this.connection.end(err =&gt; {<br>                if (err)<br>                    return reject(err);<br>                resolve();<br>            });<br>        });<br>    }<br>}</pre><p>생성자는 createConnection()으로 간단하게 MySQL에 연결합니다. 선언 시점에 연결이 되지 않고 첫 번째 쿼리가 실행될 때 자동으로 연결됩니다. 그래서 연결을 만드는 것이 비동기 작업이 아닙니다.</p><p>query() 메서드는 SQL 문자열과 쿼리에 전달할 매개 변수의 선택적 배열을 사용합니다. 그리고 Promise 객체를 리턴합니다. Promise는 쿼리가 실행을 끝내면 ‘reslove’ 되고, 쿼리수행 결과는 Promise의 결과가 됩니다. 오류가 발생하면 약속은 ‘reject’ 됩니다.</p><p>close() 메서드도 유사합니다. 데이터베이스 연결이 닫힐 때 Promise는 ‘resolve’ 됩니다. 결과는 없습니다.</p><p>query() 메서드는 여전히 쿼리가 실행되기 전에 즉시 반환됩니다. 결과를 얻으려면 반환된 Promise의 then() 메서드를 호출하고, 쿼리 실행이 끝날 때 호출될 callback 함수를 지정해야 합니다.</p><p>새로운 Database 클래스는 다음과 같은 방식으로 사용할 수 있습니다.</p><pre>database.query(&#39;SELECT * FROM some_table&#39;).then(rows =&gt; {<br>    // do something with the result<br>});<br>// the following code is executed *before* the query is executed</pre><p>위 코드는 첫 번째 예제와 거의 같습니다. 그러나 callback과 달리 Promise는 매우 쉽게 연결될 수 있습니다. 몇 가지 쿼리를 순차적으로 수행하고 마지막으로 연결을 닫으려면 다음과 같이 할 수 있습니다.</p><pre>database.query(&#39;SELECT * FROM some_table&#39;)<br>    .then(rows =&gt; database.query(&#39;SELECT * FROM other_table&#39;))<br>    .then(rows =&gt; database.close());</pre><p>이것은 훨씬 더 가독성이 높고, 필요한 경우 쉽게 수정하고, 확장할 수 있습니다. 그러나 이 방법에는 여전히 두 가지 문제점이 있습니다.</p><h3>Extracting the results</h3><p>첫 번째 문제는 각 callback 함수에서 마지막 쿼리의 결과만을 액세스 할 수 있다는 것입니다. 따라서 두 쿼리의 결과를 이용해서 무언가를 가공하고 싶다면 로컬 변수에 저장해야 합니다.</p><pre>let someRows, otherRows;</pre><pre>database.query(&#39;SELECT * FROM some_table&#39;)<br>    .then(rows =&gt; {<br>        someRows = rows;<br>        return database.query(&#39;SELECT * FROM other_table&#39;);<br>    })<br>    .then(rows =&gt; {<br>        otherRows = rows;<br>        return database.close();<br>    })<br>    .then(() =&gt; {<br>        // do something with someRows and otherRows<br>    });</pre><p>쿼리들의 결과를 다음 then()에서 사용하려면 함수가 query() 메서드에서 Promise를 반환해야 합니다. 만약 return 키워드를 쓰지 않는다면 다음의 then() 메서드에서 이전 쿼리의 결과는 undefined 입니다.</p><h3>Error handling and closing connection</h3><p>또 우리는 오류를 처리하는 것이 필요합니다. Promise 내 작업에서 오류가 발생하고 이 오류를 catch 하지 않으면 프로그램은 중단되게 됩니다.</p><p>Promise를 사용하면 체인의 끝에 하나의 catch() 함수를 추가하는 것만으로 충분합니다. 모든 단계 어디에서라도 오류가 발생하면 이후의 모든 then() 메서드는 실행이 생략되고 catch() 메서드가 실행됩니다. 이는 try/catch 블록과 매우 유사합니다.</p><p>이 솔루션의 문제점은 오류가 발생하면 데이터베이스 연결이 끊어지지 않는다는 것입니다. 동기식 프로그램에서는 try/catch 블록에 finally 절을 추가해서 이를 방지할 수 있지만, 아쉽게도 JavaScript Promise에는 finally() 메서드가 없습니다.</p><p>오류가 발생하더라도 데이터베이스 연결이 잘 닫히도록 하려면 다음과 같이 쓸 수 있습니다.</p><pre>let someRows, otherRows;</pre><pre>database.query(&#39;SELECT * FROM some_table&#39;)<br>    .then(rows =&gt; {<br>        someRows = rows;<br>        return database.query(&#39;SELECT * FROM other_table&#39;);<br>    })<br>    .then(rows =&gt; {<br>        otherRows = rows;<br>        return database.close();<br>    }, <strong>err =&gt; {<br>        return database.close().then(() =&gt; { throw err; })<br>    }</strong>)<br>    .then(() =&gt; {<br>        // do something with someRows and otherRows<br>    }<br>    .catch(err =&gt; {<br>        // handle the error<br>    });</pre><p>then()에 전달된 두 번째 함수(굵은 글꼴로 표시)는 체인의 이전 단계에서 오류가 발생되면 호출됩니다. 그럼 여기에서 데이터베이스 연결을 닫은 다음 오류를 다시 throw하여 최종적으로 catch()에 도달하게 합니다.</p><p>이 패턴을 자주 사용하는 경우 다음과 같이 별도의 함수로 연결을 만들고 닫을 수 있습니다.</p><pre>Database.execute = function(config, callback) {<br>    const database = new Database(config);<br>    return callback(database).then(<br>        result =&gt; database.close().then(() =&gt; result),<br>        err =&gt; database.close().then(() =&gt; { throw err; })<br>    );<br>};</pre><p>다음은 위 함수를 사용하여 다시 작성한 내용입니다.</p><pre>let someRows, otherRows;</pre><pre>Database.execute(config,<br>    database =&gt; database.query(&#39;SELECT * FROM some_table&#39;)<br>    .then(rows =&gt; {<br>        someRows = rows;<br>        return database.query(&#39;SELECT * FROM other_table&#39;)<br>    })<br>    .then(rows =&gt; {<br>        otherRows = rows;<br>    })<br>).then(() =&gt; {<br>    // do something with someRows and otherRows<br>}).catch( err =&gt; {<br>    // handle the error<br>});</pre><p>비슷한 기술을 사용하여 트랜잭션을 래핑할 수 있습니다. 트랜잭션은 모든 쿼리가 성공적으로 실행되거나 중간에 오류가 발생하면 rollback 될 때 자동으로 commit 합니다.</p><h3>Final notes</h3><p>Promise는 까다롭고 익숙해지기까지 시간이 걸릴 수 있습니다. 그러나 실제로 비동기 코드는 항상 까다롭습니다. Promise는 callback 보다 작성하고 예상하는 것이 쉽습니다. 만약 제 말을 믿지 못한다면, ‘callback hell’로 검색을 해보셔도 좋습니다. 🙂</p><p>Promise 보다 비동기 코드를 쉽게 작성하게 하는 새로운 방법으로 async/await 키워드를 사용하는 것입니다. 저는 이것을 C#에서 얼마동안 사용해왔고, 정말 좋아합니다. Node.js 6에서는 지원되지 않지만 Node.js 8 또는 Babel로 사용할 수 있습니다. 하지만 그건 다른 글에서 다루겠습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6309f3915d37" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Hybrid Apps And React Native: A Time To Transition?]]></title>
            <link>https://medium.com/@moralmk/hybrid-apps-and-react-native-a-time-to-transition-e905a32d915b?source=rss-f44fb2a64b8d------2</link>
            <guid isPermaLink="false">https://medium.com/p/e905a32d915b</guid>
            <category><![CDATA[web-apps]]></category>
            <category><![CDATA[react]]></category>
            <category><![CDATA[hybrid-apps]]></category>
            <category><![CDATA[mobile-app-development]]></category>
            <category><![CDATA[react-native]]></category>
            <dc:creator><![CDATA[Donghwa Lee]]></dc:creator>
            <pubDate>Wed, 23 Aug 2017 04:20:22 GMT</pubDate>
            <atom:updated>2019-02-18T19:05:57.092Z</atom:updated>
            <content:encoded><![CDATA[<p>번역 원문 :<br><a href="https://www.smashingmagazine.com/2017/06/transition-hybrid-apps-react-native/">https://www.smashingmagazine.com/2017/06/transition-hybrid-apps-react-native/</a></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*ow-J0bVpiyc1E-CofIY9Rg.png" /></figure><p>뮤지션에게는 현재 자신의 경력을 한 단계 더 발전시키기 위해 어느 순간에는 오래된 습관을 잊어야 할 때가 있습니다. 이것은 궁극적으로는 더 나은 수준이 되게 하지만 그 과정 상에는 종종 한시적으로 후퇴하게 만들기도 합니다. 새로운 기술이 습득되면 이전 기술로는 도저히 불가능했던 새로운 수준에 도달할 수 있습니다.</p><p>뮤지션과 마찬가지로 모든 전문가는 자신의 방법론에 자주 질문하고 다른 옵션이 있는지 확인해야 합니다. 한 접근법이 이전에 최고였던 것이 그것이 언제까지나 최상의 상태라는 것을 의미하지는 않습니다. 우리는 늘 더 나은 접근법에 대해서 고려해야 하고, 가장 익숙한 접근법에 지나치게 편향되어 있지는 않은지 생각해보아야 합니다.</p><p>이 글에서는 하이브리드 모바일 앱 개발에 대해서 React Native가 여러 가지면에서 우수한 솔루션이라고 할 수 있는 이유를 이야기합니다. 이를 위해 먼저 하이브리드 앱이 나타나게 된 배경을 살펴보고 현재까지 나와있는 방법을 알아보겠습니다. 그런 다음 컨텍스트 안에서 React Native가 어떻게 자리하는 논의하고, 대부분의 경우에 대해 React Native가 왜 더 나은 접근 방식인지를 설명합니다.</p><h3>An Origin Story</h3><p>2010년입니다. A사는 jQuery를 사용하는 멋진 웹 애플리케이션을 사용합니다. HTML, CSS 및 JavaScript에 능숙한 개발자들로 이루어진 팀이 있습니다. 갑자기 모바일 앱을 만들어야 하는 이슈가 생겨났습니다. 팀원들은 자신만의 모바일 앱을 만드는 방법을 광란하게 연구하고 즉시 여러 가지 문제에 직면하게됩니다. 팀에는 Java 또는 Objective-C 개발자는 없고, 더욱이 별도의 두 가지 앱을 개발, 테스트 및 배포할 여력이 없는 상황입니다.</p><p>하지만 걱정할 필요가 없습니다. 하이브리드 모바일 앱이 해결책이 될 수 있습니다. 이 신기술을 사용하면 (이론적으로) 새로운 모바일 앱을 위해 코드와 노하우들을 쉽게 재사용 할 수 있습니다. Cordova, PhoneGap 등의 프레임워크를 선택해서 모바일 앱을 제작하거나 포팅할 수 있습니다!</p><p>위와 같은 방법으로 많은 기업과 개발자에게서 문제가 해결될 수 있었고, 그들은 자신만의 모바일 앱을 만들 수 있었습니다.</p><h3>Problems Arise</h3><p>2010년 이래로 개발자포럼, 블로그 및 게시판에는 하이브리드 앱의 생산성, 효율성에 대한 논란이 가득합니다. 이전 단락에서 설명한 유연성과 이점에도 불구하고 하이브리드 앱은 매우 실제적인 문제점과 단점을 가지고 있습니다. 다음은 가장 주목할만한 몇 가지 문제입니다.</p><h4>USER-EXPERIENCE SHORTCOMINGS</h4><p>지난 몇 년 동안 모바일 앱의 UX에 대한 관심과 니드가 극적으로 증가했습니다. 대부분의 스마트 폰 소유자는 소수의 프리미어 앱만 사용하며 대부분의 시간을 보냅니다. 사용자들은 아마도 Facebook, MLB TV, YouTube 및 Uber와 같은 세련된 UX의 앱을 기대합니다.</p><p>이 매우 높아진 기대치에 하이브리드 앱은 모든 것을 만족시키기가 매우 어렵습니다. 반응이 느리거나 제한된 애니메이션, 키보드 오작동 및 플랫폼 별 인식하는 제스처의 한계와 같은 문제는 모두 하이브리드 앱을 만족스럽다라고 생각하기 어렵게 합니다. 이 문제를 복잡하게하는 것은 하이브리드 애플리케이션이 오픈 소스 커뮤니티에 의존하여 네이티브 기능을 위한 래퍼런스를 작성하는 것입니다. 다음은 이러한 문제를 잘 표현해주는 어느 앱의 스크린샷입니다. 이 애플리케이션은 Ionic의 쇼케이스에서 소개되었으며, Morgan Stanley가 만들었습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/0*IHPS_sr8V5c3M5ht.png" /><figcaption><em>Screenshot of the app store listing for MS StockPlan</em></figcaption></figure><p>몇 가지 내용은 즉시 명백하게 확인할 수 있습니다. 이 앱의 평점은 매우 낮습니다(별 2.5개). 모바일 앱처럼 보이지 않지만 분명히 모바일 웹 앱의 모습입니다. 고유하지 않은 세그먼트 컨트롤, 글꼴 크기, 텍스트 밀도 및 기본형이 아닌 탭 표시줄 등이 눈에 띕니다. 이 앱은 기본적으로 구현이 쉽지 않고, 특히 가장 중요한 점은 고객이 이러한 모든 문제를 파악하고 있으며, ‘오래되었다’라는 느낌이라고 평가합니다.</p><h4>USER INTERFACE CHALLENGES</h4><p>대다수의 사용자는 새로운 앱을 제거하거나 잊어버리는 주기가 매우 짧습니다. 앱이 좋은 첫 인상을 보이고 사용자가 쉽게 이해할 수 있는 것이 중요합니다. 하이브리드 앱은 멋지게 보일 수 있지만, 웹 앱처럼 보이거나, 다른 플랫폼 독립적인 성격에 따라 다른 플랫폼의 모습으로 보일 수 있는 등의 문제를 동시에 가지고 있습니다.</p><p>앱을 설치하기 전에 많은 고객이 앱 스토어의 이미지를 검토합니다. 이러한 스크린샷이 매력적이지 않거나 불쾌감을주는 경우에는 앱이 전혀 다운로드되지 않을 수 있습니다. 다음은 그러한 앱의 한 예입니다. 이 앱은 Nationwide에서 제작했으며, 두 앱 모두 모바일 앱이 아닌 모바일 반응형으로 제작된 웹 사이트처럼 보입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/392/0*dMY16TIct12HEUa6.png" /><figcaption><em>Screenshot of the Nationwide app on iOS</em></figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/392/0*PR5-ADO7NMPOBwzB.png" /><figcaption><em>Screenshot of the Nationwide app on Android</em></figcaption></figure><p>앱 스토어 리뷰에서 이 앱에는 몇 가지 문제가 있지만 이러한 UI가 있는 앱은 새로운 고객을 유치할 가능성이 거의 없어 보입니다. 이 앱은 반드시 이 앱을 사용해야만 하는 기존의 고객들에 의해서만 사용될 것입니다.</p><h4>PERFORMANCE ISSUES</h4><p>하이브리드 애플리케이션에 대한 가장 일반적인 불만은 성능, 버그 및 충돌입니다. 물론 모든 앱에서 이러한 문제가 나타날 수 있지만 성능 문제는 오랫동안 하이브리드 앱을 괴롭히고 있습니다. 또한 하이브리드 애플리케이션은 종종 오프라인 지원이 적고 열악한 네트워크 조건에서는 치명적으로 성능이 저하될 수 있습니다. 모든 개발자는 위에서 언급 한 내용 중 ‘버그’라고 하는 것을들은 적이 아마 있을 것이고, 결과적으로 공개적으로 벌점 처리된 앱을 보유하고 있을지도 모르겠습니다.</p><h4>OVERALL LACK OF PREMIER APPS</h4><p>PhoneGap과 Ionic으로 개발된 애플리케이션들은 ‘Best App’으로 분류되는 리스트에서 잘 찾을 수 없습니다. 유망한 하이브리드 애플리케이션의 예로 ‘Untappd’가 있습니다. Untappd는 상당히 훌륭한 플랫폼임에도 불구하고 다운로드 횟수는 불과 5 백만회 미만입니다. 이것은 큰 숫자처럼 보일지 모르지만 가장 많이 사용되는 앱 목록에서 비교하면 상당히 저조한 숫자입니다.</p><p>또한 하이브리드에서 네이티브로 마이그레이션 한 많은 애플리케이션들이 있습니다. 이 목록에는 Facebook, TripAdvisor, Uber, Instagram 및 많은 사람들이 훌륭하다고 평가하는 앱입니다.</p><p>반대로 네이티브에서 하이브리드로 이동한 앱을 찾는 것은 상당히 어려울 것입니다.</p><h4>FINAL DEFENCE OF HYBRID APPS</h4><p>이 섹션의 핵심은 하이브리드 앱을 지나치게 비판하는 것이 아니라 대안적인 접근 방식을 위한 여지가 있음을 보여주는 것입니다. 하이브리드 앱은 매우 중요한 기술이었으며 많은 경우에 성공적으로 사용되었습니다. Ionic 쇼케이스에서 보면 위에서 예를 든 앱들보다 더 좋아 보이는 여러 가지 앱이 있습니다. Baskin Robbins, Pacifica 및 Sworkit은 최근의 세 가지 예입니다.</p><p>지난 4년 동안 하이브리드 앱 개발자와 프레임워크는 앱을 개선하기 위해 열심히 노력했으며 훌륭한 일을 해왔습니다. 그러나 근본적인 문제와 단점이 남아 있지만, 만약 지금부터 새로운 앱을 제작한다면 더 나은 옵션을 찾을 수 있습니다.</p><h3>Another Approach</h3><p>하이브리드 앱이 네이티브 앱을 완전히 대체하기에는 부족하지만, 그 장점과 성공은 무시할 수 없습니다. 하이브리드 앱은 리소스, 생산성 및 기능 문제 등 실질적인 문제를 해결하는데 도움이 됩니다. 하이브리드 애플리케이션의 단점을 제거하면서 장점을 그대로 가져갈 수 있는 접근 방법이 있다면 상당히 매력적일 것입니다. 그리고 여기에 React Native가 대답이 될 수 있습니다.</p><h4>OVERVIEW AND ADVANTAGES</h4><p>React Native는 널리 사용되는 React 웹개발 프레임워크를 기반으로 하는 크로스 플랫폼 모바일 애플리케이션 개발 프레임워크입니다. React와 마찬가지로 React Native는 Facebook 및 Instagram의 개발자가 주로 관리하는 오픈 소스 프로젝트입니다.</p><p>이 프레임워크는 플랫폼 간 JavaScript 소스코드를 공유하는 기반으로 Android 및 iOS 앱을 만드는 데 사용됩니다. React Native 앱을 만들 때 모든 비즈니스 로직, API 호출 및 상태 관리를 JavaScript로 합니다. UI 요소와 그 스타일은 코드에서 일반화되지만 기본 뷰로 렌더링됩니다. 이를 통해 코드의 재사용성을 높은 수준으로 끌어 올리 수 있고, 각 플랫폼의 스타일 가이드 및 모범 사례를 따르는 UI를 사용할 수 있습니다.</p><p>또한 React Native를 사용하면 플랫폼 별 코드, 로직, 그리고 스타일을 필요한대로 작성할 수 있습니다. 이는 플랫폼 별 React 구성 요소를 보유하는 것만큼 간단할 수도 있고 React Native 앱에서 플랫폼 별 C Library를 사용하는 것만큼 고급일 수도 있습니다.</p><h4>SIMILARITIES TO HYBRID APPS</h4><p>하이브리드 앱 프레임워크와 마찬가지로 React Native는 진정한 크로스 플랫폼 개발을 가능하게 합니다. Instagram은 React Native 프로젝트에 85–99 %의 코드를 재사용하고 있습니다. 또한 React Native는 많은 웹 개발자가 익숙하게 사용할 수 있는 기술(JavaScript 및 React)을 사용하여 만들어졌습니다. 개발자가 React에 익숙하지 않은 경우 Objective-C 또는 Java를 배우는 것보다 AngularJS, jQuery 또는 vanilla JavaScript에 익숙하면 배우는 것이 훨씬 쉽다는 의미입니다.</p><p>또한 React Native 앱 디버깅은 Chrome 브라우저의 개발자 도구를 사용할 수 있고 이는 웹 개발자에게 아주 익숙한 프로세스입니다. 에뮬레이터 또는 실제 기기에서 앱을 구동할 때 Chrome 개발자 도구를 통해서 코드 동작을 모니터링 할 수 있습니다. 추가로 개발자는 필요에 따라 더 많은 Native 디버거를 사용할 수도 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/300/1*H9fgWc3Exb7RHs8nl3zAxg.png" /><figcaption><em>iOS React Native debugger window</em></figcaption></figure><p>여기에서 주의 깊에 볼만한 점은 React Native가 하이브리드 앱 프레임워크가 해결하려고 하는 핵심 문제를 해결한다는 것입니다.</p><h4>FURTHER IMPROVEMENTS OVER HYBRID APPS</h4><p>하이브리드 앱과 달리 React Native 앱은 웹뷰를 통해서가 아닌, 기기 자체적으로 실행됩니다. 즉, JavaScript 인터프리터와 함께 동작하면서 속도를 저하시킬 수 있는 웹 기반 UI 요소에만 국한되지 않는다는 의미입니다. React Native는 기기 OS의 기본 UI 요소를 렌더링하므로 애플리케이션은 플랫폼에서 더 많은 것을 즉시 사용할 수 있으며, 때문에 사용자가 더 편안하게 사용할 수 있습니다. 또한 네이티브 툴링 및 프로파일링 유틸리티를 보다 완벽하게 사용할 수 있어 React Native는 개발생산성을 높입니다.</p><p>아래는 최근 공개된 어느 React Native 앱의 스크린 샷입니다. 이 이미지에서는 이 프레임워크를 사용하여 얻을 수 있는 플랫폼 별 인터페이스를 강조 표시했습니다. 보시다시피 각 앱은 기본지도를 사용하며 각 플랫폼의 디자인 가이드 라인을 따르는 문구가 있습니다. Android에서 설명영역은 지도의 맨 아래에서 위로 올라오는 형식입니다. iOS에서는 말풍선이 지도에서 선택한 요소에 표시되는 형식입니다. 두 애플리케이션에서 동일한 작업을 수행할 수 있으며 대부분의 코드가 공유되지만 플랫폼 별 특성을 각기 잘 나타낼 수 있는 UI를 구현할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/750/1*263MgU5ajwljcIp8s6RbrQ.png" /><figcaption><em>Screenshot of the Vett Local app on iOS</em></figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*DihJ84OszWCLPLSnGhcJ5A.png" /><figcaption><em>Screenshot of the Vett Local app on Android</em></figcaption></figure><h4>HOW IS THIS DONE?</h4><p>아래 샘플 소스가 있습니다. 웹 개발자가 이미 알고 있어야하는 영역을 강조하는 몇 가지 공통 요소를 보여줍니다. 코드 다음에는 각 섹션에서 수행중인 작업에 대한 설명이 나와 있습니다.</p><pre>import PropTypes from &quot;prop-types&quot;;<br>import React, { PureComponent } from &quot;react&quot;;<br>import { Dimensions, StyleSheet, Text, View } from &quot;react-native&quot;;<br>import LoadingAnimation from &quot;./LoadingAnimation&quot;;<br>import SearchBar from &quot;./SearchBar&quot;;<br><br>const { width } = Dimensions.get(&quot;window&quot;);<br>const styles = StyleSheet.create({<br>  title: {<br>    backgroundColor: colors.transparent,<br>    color: colors.black,<br>    fontSize: 19,<br>    fontWeight: &quot;500&quot;,<br>  },<br>});<br><br>export default class MovieList extends PureComponent {<br>  state = {<br>    movies: [],<br>    filteredMovies: [],<br>    loading: true,<br>  };<br><br>  componentWillMount() {<br>    this._fetchMovies();<br>  }<br><br>  _fetchMovies = () =&gt; {<br>    fetch(&quot;https://mywebsite.com/getMovies/&quot;, {<br>      method: &quot;GET&quot;,<br>    })<br>      .then(res =&gt; res.json())<br>      .then(res =&gt; {<br>        this.setState({<br>          movies: res,<br>          filteredMovies: res,<br>          loading: false,<br>        });<br>      })<br>      .catch(err =&gt; {<br>        this.setState({<br>          error: &quot;Unable to get movies.&quot;,<br>        });<br>      });<br>  };<br><br>  _applyFilter = term =&gt; {<br>    const filteredList = this.state.movies.filter(<br>      movie =&gt; movie.title.toLowerCase().search(term) !== -1,<br>    );<br><br>    this.setState({<br>      filteredMovies: filteredList,<br>    });<br>  };<br><br>  _renderTitleRow = movie =&gt; {<br>    const titleLimit = width &gt;= 375 ? 26 : 20;<br>    let formattedTitle = movie.title;<br>    if (formattedTitle.length &gt; titleLimit) {<br>      formattedTitle = formattedTitle.slice(0, titleLimit - 3) + &quot;...&quot;;<br>    }<br><br>    return (<br>      &lt;Text numberOfLines={1} style={styles.title} key={movie.id}&gt;<br>        {formattedTitle}<br>      &lt;/Text&gt;<br>    );<br>  };<br><br>  render() {<br>    if (this.state.loading) {<br>      return (<br>        &lt;View&gt;<br>          &lt;LoadingAnimation /&gt;<br>        &lt;/View&gt;<br>      );<br>    } else {<br>      return (<br>        &lt;View&gt;<br>          &lt;SearchBar onFilterChange={this._applyFilter} /&gt;<br>          {this.state.filteredMovies.map(movie =&gt; this._renderTitleRow(movie))}<br>        &lt;/View&gt;<br>      );<br>    }<br>  }<br>}</pre><p>위의 코드 대부분은 JavaScript이고 때문에 대다수의 웹 개발자에게 친숙할 것입니다. 렌더링 로직의 대부분은 새로운 것이지만, HTML에서 React Native 뷰로의 마이그레이션은 매우 간단합니다. 또한 스타일 속성은 CSS와 매우 유사합니다.</p><h4>WHO IS DOING THIS?</h4><p>자신의 애플리케이션을 작성하는 방법을 결정할 때 업계 전문가로부터 배우는 것이 중요합니다. 그들은 수억원에 달하는 애플리케이션을 개발하면서 이미 깊이 있는 고민을 선행했을 것이고, 그런 그들을 통해서 우리는 짧은 시간에 실수나 경험을 간접적으로 배울 수 있습니다. Facebook, Instagram, Airbnb, Baidu, Discord, Tencent, Uber 및 Twitter : 앱에서 React Native를 사용하는 대기업들입니다.</p><p>이러한 앱의 대부분은 원래 다른 접근 방식을 사용하여 작성되었지만 React Native로 완전히 전환했거나 현재 React Native를 사용하여 기존 네이티브 애플리케이션을 보강하고 있습니다.</p><p>이전에는 대개의 기술 변화가 cross-platform에서 platform-specific에 이르기까지 다양했지만, 이제는 많은 프리미어 앱이 React Native를 통해서 크로스 플랫폼 솔루션으로 옮겨갔습니다. 이 변화는 단순히 무시하기에는 매우 의미있는 변화입니다.</p><h3>What Should You Do Now?</h3><p>더 나은 커리어를 위해 접근 방식을 재고해야하는 뮤지션처럼 모바일 앱 개발자도 지속적으로 기술을 다시 생각해야 합니다. 사용가능한 최상의 옵션을 기반으로 의사결정을 내리고, 본인의 개발친숙도에만 의존하지 않는 것이 중요합니다. 변화를 실행하는 것이 처음에는 불편하고 노력이 요구되지만, 앱 마켓의 소비자들은 계속 발전할 것을 요구합니다.</p><p>React Native는 하이브리드 앱의 재사용성과 비용 효율성을 네이티브 앱의 성능과 결합시킨 매우 매력적인 기술입니다. 그것은 앞으로 빠른 속도로 전파될 것으로 예상되며, 다가오는 하이브리드 앱에 대한 대체 접근 방법이 될 것입니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e905a32d915b" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Web Scraping With Node.js]]></title>
            <link>https://medium.com/@moralmk/web-scraping-with-node-js-9a289ad19558?source=rss-f44fb2a64b8d------2</link>
            <guid isPermaLink="false">https://medium.com/p/9a289ad19558</guid>
            <category><![CDATA[web-scraping]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[cheerios]]></category>
            <category><![CDATA[nodejs]]></category>
            <category><![CDATA[data-mining]]></category>
            <dc:creator><![CDATA[Donghwa Lee]]></dc:creator>
            <pubDate>Tue, 22 Aug 2017 04:04:17 GMT</pubDate>
            <atom:updated>2019-02-18T19:03:29.366Z</atom:updated>
            <content:encoded><![CDATA[<p>번역 원문 :<br><a href="https://www.smashingmagazine.com/2015/04/web-scraping-with-nodejs/">https://www.smashingmagazine.com/2015/04/web-scraping-with-nodejs/</a></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*CG2pw8YfQkyOhXR0LGL7yw.png" /></figure><p>Web Scraping은 프로그램을 이용해서 인터넷에서 정보를 검색하는 프로세스입니다. 웹에서 데이터량이 증가함에 따라 이러한 방식이 점차 보편화되고 있습니다. Web Scraping을 간편하게 하기 위해서 여러가지 강력한 서비스들이 등장했습니다. 하지만 대다수의 서비스들은 비용이 고가이거나, 기능이 제한적이거나 등의 단점이 있습니다. 우리는 그러한 서비스들을 이용하지 않고, Node.js를 사용해서 완전히 무료이면서 강력한 웹 스크래퍼를 만들 수 있습니다.</p><p>이 글에서는 다음 내용을 다룹니다.</p><ul><li>Web Scraping을 간편하게 하는 Node.js 모듈, Request와 Cheerio</li></ul><p>또한 먼저 다음을 진행하기 전에 몇 가지 알아두어야 할 사항이 있습니다. 이 글에서는 Node.js에 대한 기본적인 이해가 필요합니다. 또 Web Scraping은 일부 웹 사이트의 서비스 약관을 위반할 수 있으므로 Scraping을 수행하기 전에 해당 웹 사이트에 문의 혹은 약관을 확인하셔야 합니다.</p><h3>Modules</h3><p>앞에서 언급 한 Node.js 모듈을 사용하려면 Node Package Manager 인 NPM을 이용합니다. NPM은 Node.js와 함께 자동 설치되는 패키지 관리 유틸리티로 모듈을 간편하게 설치할 수 있도록 도와줍니다. 기본적으로 NPM은 모듈을 node_modules라는 폴더에 설치됩니다.</p><p>자, 그럼 본격적으로 시작해볼게요.</p><h4>REQUEST</h4><p>Node.js는 HTTP 및 HTTPS 인터페이스를 통해 인터넷에서 데이터를 다운로드하는 간단한 방법을 제공하지만, Web Scraping으로 작업을 시작할 때 나타나는 리디렉션 및 기타 문제에 대해서는 별도로 처리해야 합니다. Request 모듈을 이용하면 그러한 골치아픈 것들을 따로 처리하지 않을 수 있습니다. 웹 페이지 소스를 메모리로 직접 다운로드합니다. Request 모듈을 설치하려면 프로젝트 디렉토리에서 npm install request를 실행하세요.</p><h4>CHEERIO</h4><p>Cheerio를 사용하면 다운로드한 웹 페이지 소스를 jQuery와 동일한 구문을 사용하여 작업할 수 있습니다. 서버용으로 특별히 설계된 jQuery를 빠르고 유연하게 구현할 수 있고 Parsing보다는 데이터를 직접 다운로드하는데 집중할 수 있습니다. Cheerio 모듈을 설치하려면 프로젝트 디렉토리에서 npm install cheerio를 실행하세요.</p><h3>Implementation</h3><p>아래 코드는 날씨 웹 사이트에서 온도를 감지할 수 있는 작은 애플리케이션입니다. URL의 끝에 지역번호가 붙는 것을 확인할 수 있고, 이 지역번호에 따라 해당 지역의 날씨정보를 얻을 수 있습니다.</p><pre>var request = require(&quot;request&quot;);<br>var cheerio = require(&quot;cheerio&quot;);<br>var url = &quot;http://www.wunderground.com/cgi-bin/findweather/getForecast?&amp;query=&quot; + 02888;<br>  <br>request(url, function (error, response, body) {<br>  if (!error) {<br>    var $ = cheerio.load(body);<br>    var temperature = $(&quot;[data-variable=&#39;temperature&#39;] .wx-value&quot;).html();</pre><pre>    console.log(&quot;It’s &quot; + temperature + &quot; degrees Fahrenheit.&quot;);<br>  } else {<br>    console.log(&quot;We’ve encountered an error: &quot; + error);<br>  }<br>});</pre><p>먼저 모듈을 액세스 할 수 있도록 모듈을 선언합니다. 그런 다음 url 변수에 다운로드 할 URL을 정의합니다.</p><p>Request 모듈을 사용해서 위에 지정된 URL에서 페이지를 다운로드합니다. Request 함수에 다운로드하고자하는 URL과 요청결과를 처리할 콜백 함수를 전달합니다. 페이지가 다운로드 되면 콜백이 호출되고 오류, 응답 및 본문 세 가지 변수가 전달됩니다. 요청에서 웹 페이지를 다운로드하는 데 문제가 발생하여 데이터를 검색할 수 없는 경우 오류 객체가 함수에 전달되고 본문 변수는 null이 됩니다. 데이터 작업을 시작하기 전에 오류가 없는지 확인합니다. 만약 오류가 있다면, 오류 내용이 무엇인지 볼 수 있도록 로그를 남깁니다.</p><p>오류 없이 정상적으로 페이지가 다운로드 되면 데이터를 Cheerio에 전달합니다. 그런 다음 표준 jQuery 구문을 사용하여 다른 웹 페이지처럼 데이터를 처리 할 수 있습니다. 우리가 원하는 데이터를 찾으려면 우리가 관심있는 요소를 페이지에서 가져올 수 있는 선택자(selector)를 알아내야 합니다. Chrome 브라우저에서 이 예제에 사용했던 URL로 이동하여 개발자 도구로 페이지를 탐색하면 선택자를 쉽게 알 수 있습니다. 선택자로부터 데이터를 가져와 콘솔에 기록하는 것은 간단합니다.</p><h4>IN YOUR BROWSER</h4><ol><li>브라우저에서 스크랩하려는 페이지를 방문하고 URL을 기록합니다.</li><li>데이터가 필요한 요소를 찾아 jQuery 선택자를 찾습니다.</li></ol><h4>IN YOUR CODE</h4><ol><li>Request 모듈을 사용하여 URL에 페이지를 다운로드합니다.</li><li>다운로드 된 데이터를 Cheerio에 전달하면 jQuery와 같은 인터페이스를 얻을 수 있습니다.</li><li>미리 알아둔 선택기를 사용하여 페이지에서 데이터를 스크랩합니다.</li></ol><h3>추가정보 : Data Mining</h3><p>데이터 마이닝은 Web Scraping의 고급 사용 사례입니다. 데이터 마이닝은 많은 웹 페이지를 다운로드하고 웹 페이지에서 추출된 데이터를 기반으로 보고서를 생성하는 작업입니다. Node.js는 이러한 성격의 애플리케이션에 적합합니다.</p><p>위에서 언급한 두 라이브러리를 보다 깊이 있게사용하는 방법을 보여주기 위해 Node.js에 100줄 미만의 작은 데이터 마이닝 프로그램을 작성했습니다. 이 앱은 Google 검색의 첫 페이지에 링크된 각 페이지의 텍스트를 분석하여 특정 Google 검색과 관련된 가장 인기있는 용어를 찾습니다.</p><p>이 앱에는 세 가지 주요 단계가 있습니다.</p><ol><li>Google에서 검색합니다.</li><li>모든 페이지를 다운로드하고 각 페이지의 모든 텍스트를 분석합니다.</li><li>텍스트를 분석해서 가장 인기있는 단어를 제시합니다.</li></ol><p>우리는 이러한 각각의 일이 일어나는데 필요한 코드를 간략하게 살펴볼 것입니다.</p><h4>DOWNLOADING THE GOOGLE SEARCH</h4><p>우리가 해야할 첫 번째 일은 분석할 페이지를 찾는 것입니다. Google 검색에서 가져온 페이지를 보고 있기 때문에 원하는 검색을 위한 URL을 찾고 다운로드하고 결과를 분석해서 필요한 URL을 찾을 수 있습니다.</p><p>위의 예제에서처럼 Request를 사용하는 페이지를 다운로드하고 분석하기 위해 Cheerio를 다시 사용하겠습니다. 코드는 다음과 같습니다.</p><pre>request(url, function (error, response, body) {<br>  if (error) {<br>    console.log(“Couldn’t get page because of error: “ + error);<br>    return;<br>  }<br>  <br>  // load the body of the page into Cheerio so we can traverse the DOM<br>  var $ = cheerio.load(body);<br>  var links = $(&quot;.r a&quot;);<br>    <br>  links.each(function (i, link) {<br>    // get the href attribute of each link<br>    var url = $(link).attr(&quot;href&quot;);<br>    <br>    // strip out unnecessary junk<br>    url = url.replace(&quot;/url?q=&quot;, &quot;&quot;).split(&quot;&amp;&quot;)[0];<br>    <br>    if (url.charAt(0) === &quot;/&quot;) {<br>      return;<br>    }<br>    <br>    // this link counts as a result, so increment results<br>    totalResults++;<br>  }<br>} </pre><p>이 경우 전달할 URL 변수는 Google에서 ‘Data Ming’이라는 용어를 검색한 것입니다.</p><p>보시다시피 우리는 먼저 페이지 내용을 요청합니다. 그런 다음 페이지의 내용을 Cheerio에로드하여 관련 결과에 대한 링크가 있는 요소를 DOM으로 얻을 수 있습니다. 그런 다음 링크를 반복하고 Google에서 자체적으로 삽입하는 추가 URL 매개 변수를 제거합니다. Request 모듈을 사용하여 페이지를 다운로드 할 때 추가 매개 변수는 필요하지 않습니다.</p><p>마지막으로 모든 작업을 완료하면 URL이 /로 시작하지 않는지 확인합니다. 그렇다면 Google의 다른 URL에 대한 내부 링크이므로 다운로드를 하지 않습니다.</p><h4>PULLING THE WORDS FROM EACH PAGE</h4><p>이제 우리 페이지의 URL을 얻었으므로 각 페이지에서 단어를 가져와야 합니다. 이 단계는 위에서 수행한 것과 거의 동일한 작업을 수행하는 것으로 구성됩니다. 이 경우 URL 변수는 위 반복구문에서 찾은, 처리된 페이지의 URL을 참조합니다.</p><pre>request(url, function (error, response, body) {<br>  // load the page into Cheerio<br>  var $page = cheerio.load(body);<br>  var text = $page(&quot;body&quot;).text();<br>}</pre><p>다시 말하지만 Request와 Cheerio를 사용하여 페이지를 다운로드하고, DOM에 접근할 수 있습니다. 여기에서는 페이지의 텍스트 만 가져옵니다.</p><p>다음으로 페이지의 텍스트를 정리해야 합니다. 여분의 공백, 스타일, 때로는 JSON 데이터의 홀수 비트 등 유의미하지 않은 데이터들을 분별해야 합니다.</p><ol><li>모든 공백을 단일 공백으로 압축합니다.</li><li>글자나 공백이 아닌 글자를 버립니다.</li><li>모든 것을 소문자로 변환합니다.</li></ol><p>일단 우리가 텍스트를 공백으로 나누면 페이지에 렝더링된 모든 단어가 들어있는 배열을 얻을 수 있습니다. 그런 다음 루프를 반복하여 변수 ‘corpus’에 추가할 수 있습니다.</p><p>코드로 보자면 다음과 같습니다.</p><pre>// Throw away extra white space and non-alphanumeric characters.<br>text = text.replace(/\s+/g, &quot; &quot;)<br>       .replace(/[^a-zA-Z ]/g, &quot;&quot;)<br>       .toLowerCase();<br><br>// Split on spaces for a list of all the words on that page and loop through that list.<br>text.split(&quot; &quot;).forEach(function (word) {<br>  // We don&#39;t want to include very short or long words because they&#39;re probably bad data.<br>  if (word.length &gt; 20) {<br>    return;<br>  }<br>        <br>  if (corpus[word]) {<br>    // If this word is already in our corpus, our collection of terms, increase the count for appearances of that word by one.<br>    corpus[word]++;<br>  } else {<br>    // Otherwise, say that we&#39;ve found one of that word so far.<br>    corpus[word] = 1;<br>  }<br>});</pre><h4>ANALYZING OUR WORDS</h4><p>일단 모든 단어들을 변수 ‘corpus’에 데이터로 갖게 되면, 그것을 반복해서 인기에 따라 분류할 수 있습니다. 먼저 corpus가 객체이기 때문에 배열로 가공하겠습니다.</p><pre>// stick all words in an array<br>for (prop in corpus) {<br>  words.push({<br>    word: prop,<br>    count: corpus[prop]<br>  });<br>}<br>  <br>// sort array based on how often they occur<br>words.sort(function (a, b) {<br>  return b.count - a.count;<br>});</pre><p>결과는 Google 검색 결과의 첫 페이지에 있는 모든 웹 사이트에서 각 단어가 얼마나 자주 사용되었는지를 나타내는 정렬된 배열입니다. 아래는 ‘Data Mining’이라는 검색어에 대한 결과 예시입니다.</p><pre>[ { word: &#39;data&#39;, count: 981 },<br>  { word: &#39;mining&#39;, count: 531 },<br>  { word: &#39;that&#39;, count: 187 },<br>  { word: &#39;analysis&#39;, count: 120 },<br>  { word: &#39;information&#39;, count: 113 },<br>  { word: &#39;from&#39;, count: 102 },<br>  { word: &#39;this&#39;, count: 97 },<br>  { word: &#39;with&#39;, count: 92 },<br>  { word: &#39;software&#39;, count: 81 },<br>  { word: &#39;knowledge&#39;, count: 79 },<br>  { word: &#39;used&#39;, count: 78 },<br>  { word: &#39;patterns&#39;, count: 72 },<br>  { word: &#39;learning&#39;, count: 70 },<br>  { word: &#39;example&#39;, count: 70 },<br>  { word: &#39;which&#39;, count: 69 },<br>  { word: &#39;more&#39;, count: 68 },<br>  { word: &#39;discovery&#39;, count: 67 },<br>  { word: &#39;such&#39;, count: 67 },<br>  { word: &#39;techniques&#39;, count: 66 },<br>  { word: &#39;process&#39;, count: 59 } ]</pre><p>앞으로 이 애플리케이션을 한 단계 업그레이드 할 수도 있겠습니다. 텍스트 파싱을 최적화하고, 검색 결과를 Google 결과의 여러 페이지로 확장하고, 핵심 용어가 아닌 일반적인 단어들은 제거할 수도 있습니다.</p><ul><li><a href="https://github.com/request/request">request/request</a></li><li><a href="https://github.com/cheeriojs/cheerio">cheeriojs/cheerio</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9a289ad19558" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>