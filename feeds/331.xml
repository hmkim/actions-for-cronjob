<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>돌아서면 까먹는다</title>
    <link>https://humbledude.github.io/blog/</link>
    <atom:link href="/blog/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 26 Mar 2019 15:06:27 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>기초 데이터 분석 방법 - 확률부터 가설검정, 베이지안 추론까지</title>
      <link>https://humbledude.github.io/blog/2019/02/27/basic-data-analysis/</link>
      <guid>https://humbledude.github.io/blog/2019/02/27/basic-data-analysis/</guid>
      <pubDate>Tue, 26 Feb 2019 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;문제의-시작&quot;&gt;&lt;a href=&quot;#문제의-시작&quot; class=&quot;headerlink&quot; title=&quot;문제의 시작&quot;&gt;&lt;/a&gt;문제의 시작&lt;/h2&gt;&lt;p&gt;회사에서 검색어를 기반으로 유저의 니즈를 추정하는 업무를 맡게 되었다.&lt;br&gt;예를 들어 &lt;em&gt;강
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="문제의-시작"><a href="#문제의-시작" class="headerlink" title="문제의 시작"></a>문제의 시작</h2><p>회사에서 검색어를 기반으로 유저의 니즈를 추정하는 업무를 맡게 되었다.<br>예를 들어 <em>강남 맛집</em> 이라는 검색어에 대한 유저의 니즈는 <em>강남역 근처의 맛있는 음식점</em> 이다.</p><p>이번에 유저의 니즈를 파악해야 할 검색어는 <em>스키복할인매장</em> 이다.<br>검색어 <em>스키복할인매장</em> 을 입력한 유저들이 찾는 장소가 다음중 어느것 일까?</p><ol><li>스키타러 가다보면 보이는 외곽지역에 있는 창고형 할인 매장 같은 느낌의 장소인지?</li><li>아니면 스키복을 파는 모든 장소인지? (어짜피 다 할인중이니까!!)</li></ol><p>위 문제를 얼렁뚱땅 내 느낌으로 말고 데이터에 의거해 판단해 보기로 했다.</p><ol><li><em>스키복할인매장</em> 을 검색한 유저의 로그를 분석해서 (1) 또는 (2) 로 분류 한다</li><li>그리고 통계적 추론?을 통해 최종 결론을 내린다.</li></ol><p>일단 1번 스텝에서 로그를 분석해서 분류 하는 부분은 하나씩 로그를 열어봐서 유저의 패턴을 찾아야 되는 상황이다.<br>그러면 가지고 있는 로그 중에 몇 개를 샘플링 해서 수동으로 해야겠다.<br>그리고 그 결과를 바탕으로 통계적 추론 도구를 적용해 보면 되겠다는 생각이 들었다.</p><p>이렇게 생각하고 통계적 추론 도구로 덜컥 <em>베이지안 추론</em> 을 집어 들었다.<br><em>베이지안 추론</em>을 집어 들은 이유는 아래 링크에서 <strong>데이터 사이언티스트가 갖추어야 할 스킬</strong>로서 Bayesian inference 라는 단어를 보았기 때문이다.<br><a href="https://brunch.co.kr/@hero4earth/3" target="_blank" rel="noopener">https://brunch.co.kr/@hero4earth/3</a><br>(그렇게 하면 안되는 것이었다..)</p><p>그렇게 무식한 나는 베이지안 추론 -&gt; 베이즈 정리 -&gt; 베이즈 이론? -&gt; 베이즈 확률 -&gt; 확률 -&gt; 통계 -&gt; 가설 검정 … 의 늪에 빠져든다. (이해가 안되니 다른걸 참조 참조 참조.. ㅠㅠ)</p><p>나의 무식함을 탓하며 깊은 늪에 빠졌다가 빠져나오면서 순서대로 정리 해본다.<br>늪에서 발견한 이 모든것의 시작점은 <strong>확률</strong> 이다.</p><h2 id="확률"><a href="#확률" class="headerlink" title="확률"></a>확률</h2><p>중고등학교때 배운 확률과 통계 과목을 떠올려 보자.<br>(안 떠오른다. 그냥 상식적으로 생각한다.)</p><p>보통 이렇게 확률이라는 단어를 사용했다.</p><blockquote><p>동전 하나를 던졌을때 앞면이 나올 확률은 1/2 이다.</p></blockquote><p>근데 실제로 동전을 던져보자</p><blockquote><p>동전 하나를 실제로 100번 던졌는데 앞면이 52번 나왔다.</p></blockquote><p>당연한 말인데, 이걸 정확히 뭐라 부르는지를 못해서 베이지안 추론 에서 여기까지 굴러왔다.<br>같은 내용을 관점에 따라 다르게 표현한 것이다.</p><p>엄밀히 말해 동전의 앞면이 나올 확률이 1/2 이라고 할때는 몇가지 가정이 포함된다.</p><ul><li>동전의 가장자리의 면적은 0이다</li><li>동전의 앞, 뒷면의 면적이 같다</li><li>동전을 던질때 공기의 흐름 등 어쩌구 외부적인 요인은 없다.</li></ul><p>이를 바탕으로 확률을 계산하면 ‘이상적인’ 확률이 등장한다.<br>이 1/2 이라는 값을 <strong>수학적 확률</strong> 이라고 한단다.<br>이건 계산상, 즉 이론상이고..</p><p>현실에 있는 동전을 실제로 던져보면 동전은 분명 앞면 또는 뒷면이 나오고, 동전이 세워지기도 한다…<br>한 100번 던지면 실제로 앞면이 52번이 나오는 경우도 있고, 43번 나올수도 있는거다<br>그러면, 100번 던져서 52번 앞면이 나왔으니까 이렇게 말해도 될까?</p><blockquote><p>이 동전을 던져서 앞면이 나올 확률은 52/100 이야</p></blockquote><p>아 여기부터 좀 애매해진다. 상식적으로는 이렇게 말할 수 있다.</p><blockquote><p>(학교에서 배웠다는 말투로) 야.. 그 동전을 무한히 던지다 보면 확률은 1/2 이 될꺼야..</p></blockquote><p>이처럼 현실에서 <em>확률</em>은 어떠한 <em>확정된 결과</em>로 나타나고, 이를 모아서 <em>일련의 데이터</em>로 취급한다.<br>또는 반대로, <em>현실에 있는 다양한 데이터</em>를 수집해서 사건의 <em>확률</em>을 계산 해 내기도 한다.</p><p>그런데, 이렇게 계산한 확률을 가지고, 아직 일어나지 않은 일이 어떻게 될것인지 <strong>예측</strong>해 보는것도 가능하다.<br>예를 들어, 어떤 이상한 동전이 있는데, 아무리 봐도 이건 1/2 로 앞면이 나오지 않을꺼 같이 생긴거다.<br>(휜거 같기도 하고 뭐 그런느낌)<br>그래서 이걸 100번 던져봤더니 앞면이 46번 나왔다.<br>그래서 이런 결론을 내려 봤다.</p><blockquote><p>이 동전을 던져서 앞면이 나올 확률은 1/2 보다 작다.</p></blockquote><p>자, 이 주장을 믿을 수 있을까?<br>100번 던져서 앞면이 46번 나왔다니까 1/2 보다 적은건 맞는데,<br>그렇다고 이 테스트 결과에 의거해 이 동전을 가지고 하는 도박에서 뒷면에 돈을 더 많이 베팅 할 수 있겠느냐 이거다.</p><p>좀 불안해서 100 번을 더 던져서 앞면이 49번 나왔다.<br>그러면 이걸 믿을 수 있는건가?<br>차라리 무한히 던져보면 어떨까? 무한히 던졌더니 48/100 의 확률이 나온다면 전재산을 가지고 뒷면에 계속 베팅하면 결국 돈을 딴다는 거잖니.<br>근데 당장 돈걸어야되는데 언제까지 무한히 던져야 하는건가..<br>얼마나 동전을 더 던지면 되는걸까?</p><p>이 질문에 답을 찾다보니 <strong>통계</strong>가 등장했다.<br>정확히는 <em>Frequentist (빈도주의) 통계</em>의 영역이 등장한거다.</p><h2 id="빈도주의-통계와-가설검정"><a href="#빈도주의-통계와-가설검정" class="headerlink" title="빈도주의 통계와 가설검정"></a>빈도주의 통계와 가설검정</h2><p>빈도주의 통계?<br>나에게는 매우 생소한 단어였다. 빈도주의와 구분되는 단어는 <em>베이지안</em> 이다.<br>뭐 두가지 학파? 가 있다는 것으로 이해 했다…<br>그리고 보통 접할 수 있는 통계는 빈도주의 통계라고 한다..<br>(그치만 요새 머신러닝 때문에 베이지안도 많이 들을 수도 있다.)</p><p>빈도주의와 베이지안 사고방식의 차이는 아래 블로그에서 잘 설명 해 주셨다.<br><a href="https://blog.naver.com/bestian/10095013721" target="_blank" rel="noopener">https://blog.naver.com/bestian/10095013721</a></p><p>위 블로그를 참고해서 우리의 이상한 동전에 대해서 빈도주의적인 접근을 해보자.</p><ol><li>(귀무가설) 이 동전도 보통 동전이라면 1/2 확률로 앞면이 나올 것이다.</li><li>(대립가설) 근데 내눈에는 이 동전이 휘어 보여서 1/2 확률로 앞면이 나올거 같지가 않다.</li><li>그럼 실제로 좀 던져본다. 총 100번 중에 앞면이 46번 나왔다.</li><li>그럼 통계 이론에 따라 좀 계산을 해본다. 결과에 따라 동전이 휘었는지 안휘었는지 판단한다.</li></ol><p>그럼 ‘4. 통계이론에 따라 계산’은 어떻게 풀면 될까?<br>기존의 가설 (1. 귀무가설)을 기반으로 확률 분포를 계산하고,<br><strong>내가 가진 데이터</strong>가 이 분포 상에서 <strong>있을만한 일</strong>이면, <strong>기존의 가설이 맞는것</strong>이고,<br><strong>있을만한 일이 아니</strong>라면, <strong>기존의 가설이 틀릴</strong> 수 있다는거다.<br>있을만한 일의 기준은 <em>신뢰수준</em> 이라는 단어를 써서 95%, 99% 등으로 설정하며,<br>주로 뉴스에서 선거철에 듣는, <em>이 여론조사는 95%의 신뢰수준이 어쩌고..</em> 하는 말에서 나오는 그말이다.<br>95% 신뢰 수준이라는 말은, <strong>100번중에 95번은 가설에 맞는 데이터가 나타난다</strong>는 소리란다.<br>신뢰 수준의 정확한 의미는 여기서 한번 보자<br><a href="http://mkseo.pe.kr/stats/?p=763" target="_blank" rel="noopener">http://mkseo.pe.kr/stats/?p=763</a></p><p>상당히 혼미한데, 이 어려운 내용은 그림으로 보자.</p><img src="/blog/2019/02/27/basic-data-analysis/NormalDist1.96.png" title="정규분포-95신뢰수준"><p>그림 펌 : <a href="https://en.wikipedia.org/wiki/Statistical_significance" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Statistical_significance</a></p><p>많이 본듯한 정규 분포 그래프에서 가운데 색칠된 부분이 95% 신뢰 구간이다.<br>내가 가진 데이터가 95% 의 영역 안에 들어가는지? 아니면 양쪽끝 5% (양쪽이니까 각 2.5%) 구간에 속하는지 보는거다.<br>그림상 파란부분이 위 설명에 따르면 <strong>있을만한 일</strong> 의 구간이고, 나머지가 <strong>있을만한 일이 아닌</strong> 구간이다.</p><p>아무튼 됐고, 이제 풀어볼까 하는데, 나는 수학은 1도 모르니까 계산으로는 못푼다. 그냥 그림으로만 보자 ㅎㅎ</p><p>동전을 100번 던졌을때 앞면이 몇번 나올지에 대한 그림을 그려본다.<br>동전 상태는 앞, 뒤 두개밖에 없다고 치면 이항분포를 사용해서 그리면 된단다.<br>그림 그리기에 쓴 툴 : <a href="http://onlinestatbook.com/2/calculators/binomial_dist.html" target="_blank" rel="noopener">http://onlinestatbook.com/2/calculators/binomial_dist.html</a><br><img src="/blog/2019/02/27/basic-data-analysis/binomial_1.png" title="동전던지기1"></p><p>이게 무슨 뜻이냐면, 정상 동전은 100번 던져서 46번 이하로 앞면이 나올 확률이 0.2421 이라는 거다.<br>그게 무슨 소리냐면 지금 100번 던져서 46번 앞면 나온게 <strong>95% 신뢰구간 안</strong>에 있는 상황이고, 이건 꽤나 <strong>있을법한 일</strong>이라는거다.<br>그래서 대체 이게 무슨 소리냐며는 <strong>이 동전은 정상같아 보인다</strong>는거다.</p><p>아 그럴리가 없어.. 얼마나 앞면이 안나와야 이게 휜것일까?<br>100번을 더 던졌는데 이번엔 앞면이 39번 나와서, 앞에 케이스랑 합해서 총 200번 중에 85번 정도 앞면이 나왔다고 치고, 그림을 다시 그려본다<br><img src="/blog/2019/02/27/basic-data-analysis/binomial_2.png" title="동전던지기2"></p><p>그림대로라면 200번 던져서 앞면이 85번 이하로 나올 확률이 0.02 라는거다.<br>위의 95% 신뢰구간 그림에서 <strong>아랫쪽 2.5% 구간</strong>에 우리 데이터가 들어왔다!!<br>다시말해, 지금 데이터로는 <em>이 동전은 1/2 확률로 앞면이 나온다</em>는 가설로는 <strong>잘 안일어나는 일</strong>이 일어났고,<br>그래서 <em>이 동전은 휘었다</em>는 주장을 통계 이론에 의거해 꽤나 신빙성 있게 하게 되었다.</p><h2 id="베이즈-확률론"><a href="#베이즈-확률론" class="headerlink" title="베이즈 확률론"></a>베이즈 확률론</h2><p>가설검정을 했더니 매우 피곤해졌다.<br>하지만 여기서 멈출수가 없는데, 간지나는 <strong>데이터 사이언티스트</strong>가 되기 위해 베이지안 추론을 할줄 알아야 되겠다.<br>동전던지기를 베이지안 추론으로 어떻게든 해결할 줄 알아야 되는게 아닐까..</p><p>베이지안 추론을 검색하고 글을 보다보면 <em>베이지안 xx</em> 라고 자꾸 베이지안 시리즈가 나오는데,<br>위에서 다룬 빈도주의와 좀 다른 개념으로 확률을 접근한다.<br>베이즈 확률론 이라고 불리는 이 확률 개념을 보자. (검색하면 베이지안 확률론 이라고도 나온다)<br><a href="https://ko.wikipedia.org/wiki/%EB%B2%A0%EC%9D%B4%EC%A6%88_%ED%99%95%EB%A5%A0%EB%A1%A0" target="_blank" rel="noopener">https://ko.wikipedia.org/wiki/%EB%B2%A0%EC%9D%B4%EC%A6%88_%ED%99%95%EB%A5%A0%EB%A1%A0</a></p><p><em>지식 또는 믿음의 정도를 나타내는 양</em>을 확률로 표현한다는데…  매우 곤란하고 혼란하다.<br>구지 위의 동전 앞면 1/2 확률에 대해 베이지안 스타일로 말해본다면,</p><blockquote><p>나는 이 동전이 1/2 확률로 앞면이 나올꺼라고 믿는 양이 많아…</p></blockquote><p>정도일려나..ㅜㅜ (그냥 헛소리 같다)</p><p>동전가지고 이 소리를 하면 말이 좀 어색하지만, 보통 베이지안을 사용하는 문제의 영역에서는 꽤나 그럴듯한 표현이 된다.</p><blockquote><p>뉴스에서 어떤 병에 걸릴 확률이 1/100 이란다. 조심하래…</p></blockquote><p>위 내용은 빈도주의적 접근을 해서 표본을 구성하고 그중에 몇명이 병에 걸렸는지 세어본 뒤 나온 의미일 수 있다.</p><blockquote><p>100명중에 1 명이 이 병에 걸렸더라. 그니까 병에 걸릴 확률은 1/100 이야. 신뢰수준 95% 에 표본 오차가 어쩌고..</p></blockquote><p>똑똑한 사람들은 가설 검정을 해서 저 확률을 신빙성 있는 주장으로 만들수도 있겠지?<br>(나는 이제 가설검정 못하겠다..ㅠㅠ)</p><p>그럼 좀더 속편하게 베이지안 사고방식으로 말을 해보자 (조금은 덜 배운 베이지안이다)</p><blockquote><p>100명 중에 1명이 이 병에 걸렸더라. 그니까 나는 이 병에 걸릴 확률이 1/100 임에 손모가지를 걸겠어</p></blockquote><p>와 가설 검정을 건너 뛰었다.. 만세!!!<br>근데 그럼 이런 베이지안 사고방식은 어떻게 신빙성을 갖추는건가? 손모가지로?<br>가설검정처럼 똑똑해 보이는 복잡한 과정 없이 그냥 나누기 하나로 퉁쳤는데??</p><p>사실 답으로 제시한 값은 나누기 한번으로 계산한 것과 같지만, 그 안에는 생략한 말들이 있다.<br>생략한 말을 포함해서 조금 더 배운 베이지안 사고방식으로 말을 해보자</p><blockquote><p>답이 1/100 이 아니고 다른 값일 확률도 존재 하지만, 현 시점에서 나는 답이 1/100 일 확률이 제일 큰거 같다</p></blockquote><p>베이지안 확률론에서 내가 제일 혼미했던 부분이 <strong>확률의 확률</strong>을 언급하고 있다는 거였는데,<br>이거는 어떻게 말로 설명하기 어려우니 좀더 글을 읽다 보다보면 이해가 되길 바란다..<br>(나도 수많은 예제를 보고 겨우 정리한 말이 확률의 확률이라는 단어다.. ㅠㅠ)</p><h2 id="베이지안-추론"><a href="#베이지안-추론" class="headerlink" title="베이지안 추론"></a>베이지안 추론</h2><p>아무튼 데이터 사이언티스트 할려면 베이지안 추론을 해야 된다는데. 너무 돌아돌아 왔다.<br>이제 진짜 베이지안 추론이 뭔지 볼수 있다.<br><a href="https://ko.wikipedia.org/wiki/%EB%B2%A0%EC%9D%B4%EC%A6%88_%EC%B6%94%EB%A1%A0" target="_blank" rel="noopener">https://ko.wikipedia.org/wiki/%EB%B2%A0%EC%9D%B4%EC%A6%88_%EC%B6%94%EB%A1%A0</a></p><p><em>추론 대상의 사전 확률과 추가적인 정보를 통해 해당 대상의 사후 확률을 추론하는 방법</em> 이라는데.. ㅠㅠ<br>수많은 글을 섭렵한뒤, 나는 이렇게 생각하기로 했다.</p><ul><li>추론 대상 = 내가 구하고 싶은 사건의 확률</li><li>사전 확률 = 기존에 갖고 있는 데이터로 구한 확률 (또는 데이터가 없다면 그냥 그럴듯한걸로 내세운 확률)</li><li>추가적인 정보 = 이제 새로 구한 데이터</li><li>사후 확률 = 기존 데이터 + 새로 구한 데이터 까지 합해서 구한 확률</li></ul><p>또 다른 말로 표현해보면,<br>베이지안 추론은 <em>현 시점 (현재 내가 가진 데이터 상황)에서의 답</em>을 말하고,<br>데이터가 추가되면 그 데이터에 맞게 확률을 다시 계산함으로써 <em>결론을 갱신</em>해 나간다.<br>데이터가 추가될 때마다 결론이 갱신되고, 문제에 어떠한 확률적 경향이 있다면 점점 그 답에 가까워질 것이다.</p><p>여기서 데이터 추가, 결론 갱신 이라는 속성이 매우 머신러닝 같지 않은가?<br>(그래서 베이지안 검색하다보면 머신러닝이 딸려나오나보다)</p><p>말이 점점 길어지면서  더 혼미하니까, 예제를 보자.</p><blockquote><p>처음에는 100명중에 1명의 환자를 발견했는데, 추가로 100명을 더 검사했더니 3명의 환자가 더 발견 되었다.</p></blockquote><p>일단그림으로 그려보자.<br>참고 : <a href="https://ratsgo.github.io/statistics/2017/06/30/bayesinfer/" target="_blank" rel="noopener">https://ratsgo.github.io/statistics/2017/06/30/bayesinfer/</a><br>그림 그리기 툴: <a href="https://homepage.stat.uiowa.edu/~mbognar/applets/beta.html" target="_blank" rel="noopener">https://homepage.stat.uiowa.edu/~mbognar/applets/beta.html</a></p><p>위 참고 블로그에 따르면 요건 베타 분포로 그리란다.<br>처음 조사에서 100 명중에, 1명은 감염, 99 명은 비감염이다.<br><img src="/blog/2019/02/27/basic-data-analysis/beta_1.png" title="감염자1"></p><p>이 그림에 따르면, 그래프가 x 축이 0.01 부분에서 가장 높은데,<br>이게 감염율이 0.01 일 확률 (y축) 이 제일 크다 (확률의 확률..) 라는 의미란다.<br>x 축이 0.01 이 아닌 부분에도 확률이 있음을 확인하자.<br>그치만 그냥 이걸 나같이 덜 배운 사람은 편하게 이렇게 말한다.</p><blockquote><p>이 병에 걸릴 확률은 1% 야..</p></blockquote><p>그러면 추가 검사한 내용까지 포함 해보자.<br>이제 200명 중에, 4명은 감염, 196명은 비감염이다<br><img src="/blog/2019/02/27/basic-data-analysis/beta_2.png" title="감염자2"></p><p>이제 데이터가 업데이트 되고, x축이 0.02 부분이 제일 높다.<br>이건 이렇게 편하게 말한다.</p><blockquote><p>이 병에 걸릴 확률은 이제 2% 야..</p></blockquote><p>다시 혼미하게 말해 보자.</p><blockquote><p>“이 병에 걸릴 확률은 2%” 라는 확률이 제일 커.. (혼미)</p></blockquote><p>그러나..</p><p>열심히 공부해서 말만 혼미하게 했지, 결국 4/200 계산했다..<br>다음에 더 복잡한 문제가 나왔을때 쓸 일이 있겠지.. ㅠㅠ<br>(하지만 더 복잡한 문제가 나오면 손도 못댄다고 하더라)</p><h2 id="다시-문제로-돌아가서"><a href="#다시-문제로-돌아가서" class="headerlink" title="다시 문제로 돌아가서.."></a>다시 문제로 돌아가서..</h2><p>‘스키복할인매장’ 검색어를 입력한 사람은 대체 무슨 생각이었을까?<br>이게 처음의 문제였다.</p><p>베이지안 추론의 마지막 단락에 의거하여 내린 결론은,<br>그냥 로그 분석해서 그중에 몇개가 창고형 할인매장의 니즈를 갖추었는지 세어보고, 나누기 하면 끝이라는거다…<br>그러면 대략 이런 말을 하게 될것이다.</p><blockquote><p>“스키복할인매장 검색어를 입력한 사람이 창고형 할인 매장을 찾고 있었을 확률이 xx%” 라는 확률이 제일 커.. (혼미)</p></blockquote><p>로그 분석을 자동화 하는데 시간을 쓰는게 낫겠다.. ㅠㅠㅠㅠ<br>(왠지 여기도 머신러닝 -&gt; 베이지안 xx 의 혼미한 구간이 나타날꺼 같다는…)</p><h2 id="그-외-삽질"><a href="#그-외-삽질" class="headerlink" title="그 외 삽질"></a>그 외 삽질</h2><p>베이지안 추론과 베이지안 정리는 공식은 비슷하게 생겼지만, 풀고자 하는 문제의 도메인이 많이 다르다<br>둘을 같이 공부하다보면 매우 혼미해진다</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><h3 id="확률-개념-잡기"><a href="#확률-개념-잡기" class="headerlink" title="확률 개념 잡기"></a>확률 개념 잡기</h3><p>확률론 기초 <a href="https://ratsgo.github.io/statistics/2017/09/21/prob/" target="_blank" rel="noopener">https://ratsgo.github.io/statistics/2017/09/21/prob/</a><br>빈도주의적 접근과 베이지안 접근 <a href="https://blog.naver.com/bestian/10095013721" target="_blank" rel="noopener">https://blog.naver.com/bestian/10095013721</a></p><h3 id="빈도주의-통계"><a href="#빈도주의-통계" class="headerlink" title="빈도주의 통계"></a>빈도주의 통계</h3><p>오차범위? 신뢰수준? <a href="http://www.pagi.co.id/bbs/board.php?bo_table=economy&amp;wr_id=7279" target="_blank" rel="noopener">http://www.pagi.co.id/bbs/board.php?bo_table=economy&amp;wr_id=7279</a><br>가설 검정 한번에 정리하기 <a href="https://kkokkilkon.tistory.com/36" target="_blank" rel="noopener">https://kkokkilkon.tistory.com/36</a></p><h3 id="베이지안-통계"><a href="#베이지안-통계" class="headerlink" title="베이지안 통계"></a>베이지안 통계</h3><p>베이지안 통계 첫걸음<br> <a href="https://medium.com/@deepvalidation/%EB%B2%A0%EC%9D%B4%EC%8B%9C%EC%95%88-%ED%86%B5%EA%B3%84-%EC%B2%AB%EA%B1%B8%EC%9D%8C-7e7e1a5f5adc" target="_blank" rel="noopener">https://medium.com/@deepvalidation/%EB%B2%A0%EC%9D%B4%EC%8B%9C%EC%95%88-%ED%86%B5%EA%B3%84-%EC%B2%AB%EA%B1%B8%EC%9D%8C-7e7e1a5f5adc</a><br>베이지안 통계 둘째걸음<br><a href="https://medium.com/@deepvalidation/%EB%B2%A0%EC%9D%B4%EC%8B%9C%EC%95%88-%ED%86%B5%EA%B3%84-%EB%91%98%EC%A7%B8-%EA%B1%B8%EC%9D%8C-b486aa23d68b" target="_blank" rel="noopener">https://medium.com/@deepvalidation/%EB%B2%A0%EC%9D%B4%EC%8B%9C%EC%95%88-%ED%86%B5%EA%B3%84-%EB%91%98%EC%A7%B8-%EA%B1%B8%EC%9D%8C-b486aa23d68b</a><br>베이지안 추론<br> <a href="https://ratsgo.github.io/statistics/2017/06/30/bayesinfer/" target="_blank" rel="noopener">https://ratsgo.github.io/statistics/2017/06/30/bayesinfer/</a></p><h3 id="그래프-그리기-참고"><a href="#그래프-그리기-참고" class="headerlink" title="그래프 그리기 참고"></a>그래프 그리기 참고</h3><p>그래프 그려주는 사이트 모음<br> <a href="https://easy7.tistory.com/17" target="_blank" rel="noopener">https://easy7.tistory.com/17</a></p>]]></content:encoded>
      
      <comments>https://humbledude.github.io/blog/2019/02/27/basic-data-analysis/#disqus_thread</comments>
    </item>
    
    <item>
      <title>휴먼을 위한 컴퓨터의 이해 3 - CPU 동작 원리</title>
      <link>https://humbledude.github.io/blog/2018/12/10/csforhuman-3/</link>
      <guid>https://humbledude.github.io/blog/2018/12/10/csforhuman-3/</guid>
      <pubDate>Mon, 10 Dec 2018 14:34:31 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;이제 슬슬 컴퓨터가 어떻게 동작하는지 보자.&lt;/p&gt;
&lt;p&gt;컴퓨터를 분해하면 초록색 기판에 뭐가 덕지덕지 붙어있다.&lt;br&gt;그 중에 뭐 하나 빼고 전원 버튼을 눌러보자.&lt;br&gt;컴퓨터가 동작을 할수도 있고 안할수도 있다. ㄷㄷ&lt;/p&gt;
&lt;p&gt;이 부품중에
        
      
      </description>
      
      <content:encoded><![CDATA[<p>이제 슬슬 컴퓨터가 어떻게 동작하는지 보자.</p><p>컴퓨터를 분해하면 초록색 기판에 뭐가 덕지덕지 붙어있다.<br>그 중에 뭐 하나 빼고 전원 버튼을 눌러보자.<br>컴퓨터가 동작을 할수도 있고 안할수도 있다. ㄷㄷ</p><p>이 부품중에 뺐을때 반드시 동작을 안하는 몇가지 부품이 있는데, 그중에 하나가 CPU 이다.<br>(몇 개는 빼도 동작한다!!)<br>우리 독자님은 CPU 는 대충 컴퓨터의 두뇌라고 불린다고는 알고 있기를 바란다.</p><p>CPU 는 보통 컴퓨터에서 이렇게 생긴걸로 보인다.<br><img src="/blog/2018/12/10/csforhuman-3/cooler.jpg" title="쿨러 그림"><br>근데 실은 이건 쿨러라고 에어컨 같은 놈이고, 그 밑에 이런 놈이 있다.<br><img src="/blog/2018/12/10/csforhuman-3/cpu.jpg" title="CPU 그림"><br>이놈을 뭐 빼볼 일은 별로 없겠지만 이걸 빼서 뒤집으면 이렇게 생겼다.<br><img src="/blog/2018/12/10/csforhuman-3/cpu_bottom.jpg" title="CPU 뒤집은 그림"><br>뭐가 쩜쩜이 많이 있는데 저게 뭘까?</p><p>우리가 알고있는 애벌레 전자칩에 있는 다리가 저렇게 된거다.<br>CPU 는 다리가 너무 많이 필요해서 저렇게 쩜쩜이로 만든거다.<br>이것만 봐도 CPU 는 너무 복잡한 물건이라는걸 알수 있다.</p><p>CPU 는 뭘하는걸까?<br>CPU 는 복잡하니까 쉽게 생각해보자.</p><p>라면을 끓여 먹어보자.</p><p>라면을 끓이는 방법은 대충 아래와 같다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 냄비에 물을 담는다.</span><br><span class="line">2. 냄비를 가스렌지에 올린다</span><br><span class="line">3. 가스렌지를 켠다.</span><br><span class="line">4. 물이 끓으면 스프를 넣는다.</span><br><span class="line">5. 면을 넣는다.</span><br><span class="line">6. 면이 다 익으면 불을끈다.</span><br><span class="line">7. 냄비를 가져가서 맛있게 냠냠</span><br></pre></td></tr></table></figure><p>(면이 먼저다 스프가 먼저다는 중요한 문제이지만 이 글에서는 일단 그렇다 치고 넘어가자)</p><p>CPU 같은 친구들에게 라면을 끓이게 할려면 아래와 같이 한다.<br>일단 각 행동에 숫자를 붙인다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">001 = 냄비에 물을 담는다.</span><br><span class="line">002 = 냄비를 가스렌지에 올린다.</span><br><span class="line">003 = 냄비를 식탁으로 가져간다.</span><br><span class="line">010 = 가스렌지를 켠다</span><br><span class="line">011 = 가스렌지를 끈다.</span><br><span class="line">020 = 스프를 넣는다.</span><br><span class="line">021 = 면을 넣는다</span><br><span class="line">031 = 물이 끓는지 확인한다.</span><br><span class="line">032 = 면이 익었는지 확인한다.</span><br></pre></td></tr></table></figure><p>그리고 이 행동을 어떤 순서로 해야 되는지 종이에 숫자만 적어준다.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">001</span><br><span class="line">002</span><br><span class="line">010</span><br><span class="line">031</span><br><span class="line">020</span><br><span class="line">021</span><br><span class="line">032</span><br><span class="line">003</span><br><span class="line">011</span><br></pre></td></tr></table></figure></p><p>이걸 다시 위의 한글로 순서대로 써보면 이렇게 된다.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">001 = 냄비에 물을 담는다.</span><br><span class="line">002 = 냄비를 가스렌지에 올린다.</span><br><span class="line">010 = 가스렌지를 켠다</span><br><span class="line">031 = 물이 끓는지 확인한다.</span><br><span class="line">020 = 스프를 넣는다.</span><br><span class="line">021 = 면을 넣는다</span><br><span class="line">032 = 면이 익었는지 확인한다.</span><br><span class="line">003 = 냄비를 식탁으로 가져간다.</span><br><span class="line">011 = 가스렌지를 끈다.</span><br></pre></td></tr></table></figure></p><p>뭐 얼추 맞는 순서다.<br>이 CPU 같은 친구는 종이를 보고 시키는 대로 해서 라면을 끓인다.<br>재밌는건, CPU 는 스스로 판단하지 않고, 오로지 시키는 대로만 한다는거다.</p><p>우리 집에 있는 컴퓨터에 들어있는 CPU 도 하는짓이 이 라면 끓이는 방법과 크게 다르지는 않다.<br>뭔가 숫자를 주면 그 숫자에 맞는 행동을 하는거다.<br>그게 CPU 가 하는 일이다.<br>물론 숫자가 매우 복잡하다…ㄷㄷ</p><p>CPU 는 이렇게 숫자와 그 숫자에 따라 해야 될일을 외우고 있는 칩이다.<br>그리고 누군가 CPU 에게 숫자의 순서들이 적힌 종이를 주면 CPU 는 그대로 움직인다.<br>대신 매우 빠르고 정확하다.</p><p>그럼 누가 CPU 한테 종이를 주는건지는 다음 글에서 알아보자.</p><blockquote><p>연관 용어 : instruction set</p></blockquote>]]></content:encoded>
      
      <comments>https://humbledude.github.io/blog/2018/12/10/csforhuman-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Kubernetes 에서 Spark 돌려보기</title>
      <link>https://humbledude.github.io/blog/2018/12/01/spark-on-kube/</link>
      <guid>https://humbledude.github.io/blog/2018/12/01/spark-on-kube/</guid>
      <pubDate>Sat, 01 Dec 2018 13:48:04 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;쿠버네티스에서 스파크를 돌려볼까 한다.&lt;br&gt;kubernetes 는 좀 할줄 아는 사람, spark 완전 초보를 대상으로 글을 썼다.&lt;br&gt;내가 오늘 처음 Spark 를 돌려봤기에..&lt;br&gt;모든 bash command 는 spark 설치 루트 디
        
      
      </description>
      
      <content:encoded><![CDATA[<p>쿠버네티스에서 스파크를 돌려볼까 한다.<br>kubernetes 는 좀 할줄 아는 사람, spark 완전 초보를 대상으로 글을 썼다.<br>내가 오늘 처음 Spark 를 돌려봤기에..<br>모든 bash command 는 spark 설치 루트 디렉토리 기준이다.</p><h2 id="환경"><a href="#환경" class="headerlink" title="환경"></a>환경</h2><p>로컬 : Mac, mojave 10.14<br>Kubernetes : 1.9, RBAC enabled<br>Spark : 2.4.0</p><h2 id="일단-로컬-mac-에서-standalone-으로-돌려보기"><a href="#일단-로컬-mac-에서-standalone-으로-돌려보기" class="headerlink" title="일단 로컬 mac 에서 standalone 으로 돌려보기"></a>일단 로컬 mac 에서 standalone 으로 돌려보기</h2><h3 id="mac-에-설치하기"><a href="#mac-에-설치하기" class="headerlink" title="mac 에 설치하기"></a>mac 에 설치하기</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install apache-spark</span><br></pre></td></tr></table></figure><p>로 깔아도 되지만.. 이렇게 설치하면 테스트해볼 example 이 없다..<br>그래서 그냥 <a href="https://spark.apache.org/downloads.html" target="_blank" rel="noopener">다운로드 페이지</a>에서 tar 받아서 압축 푼다.</p><h3 id="mac-에서-spark-예제-돌려보기"><a href="#mac-에서-spark-예제-돌려보기" class="headerlink" title="mac 에서 spark 예제 돌려보기"></a>mac 에서 spark 예제 돌려보기</h3><p>제일 간단하게 python pi 예제  돌려보는 커맨드<br>(결과가 log 사이에 섞여서 나온다.)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin/spark-submit examples/src/main/python/pi.py</span><br></pre></td></tr></table></figure></p><p>워드카운트 예제도 돌려본다.<br>(arguments를 받을 수 있다는걸 배웠다.)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin/spark-submit examples/src/main/python/wordcount.py README.md</span><br></pre></td></tr></table></figure></p><h2 id="이제-kubernetes에서-클러스터로-돌려보기"><a href="#이제-kubernetes에서-클러스터로-돌려보기" class="headerlink" title="이제 kubernetes에서 클러스터로 돌려보기"></a>이제 kubernetes에서 클러스터로 돌려보기</h2><h3 id="그전에-이미지-빌드"><a href="#그전에-이미지-빌드" class="headerlink" title="그전에 이미지 빌드"></a>그전에 이미지 빌드</h3><p>kubernetes에서 spark 를 돌리려면, pods 를 생성할 base docker image 가 필요하다.<br>요렇게 해서 한번 만들어 보자<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin/docker-image-tool.sh build</span><br></pre></td></tr></table></figure></p><p><code>docker images</code>로 확인해보면 이미지가 세개 만들어져 있다.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REPOSITORY     TAG                  IMAGE ID            CREATED             SIZE</span><br><span class="line">spark-r        latest               76831d4bc63c        5 days ago          764MB</span><br><span class="line">spark-py       latest               ec2d882c5f8a        5 days ago          438MB</span><br><span class="line">spark          latest               90cf7bdaee92        5 days ago          348MB</span><br></pre></td></tr></table></figure></p><p>아 이미지가 개발 언어마다 다른가보다..<br>참고로 이 이미지를 만드는 <code>dockerfile</code> 은 여기 있다.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubernetes/dockerfiles/spark</span><br></pre></td></tr></table></figure></p><p>(spark-r 과 spark-py 용 dockerfile 은  그 아래 <code>bindings</code> 를 뒤져보면 각각 dockerfile 이 나온다.)</p><p>docker image 안에 필요한 파일을 다 넣고 이미지를 만들어야 한다.<br>application 도 이미지 안에 넣어두어야 하는데, 로컬에 있는 application 을 kubernetes 로 바로 전송하면서 실행하는 모드는 아직 없다고 한다.<br>(네트워크에서 접근 가능한  링크로 제공하는건 괜찮다고 한다.)</p><p>이렇게 만든 이미지는 kubernetes 가 pods 를 만들때 끌어다 쓸 수 있는 docker registry 에 올려 두자<br>나는 docker 커맨드를 사용했지만, docker-image-tool.sh 의 옵션으로도 제공한다.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin/docker-image-tool.sh -r docker.io/myrepo -t v2.3.0 build</span><br><span class="line">bin/docker-image-tool.sh -r docker.io/myrepo -t v2.3.0 push</span><br></pre></td></tr></table></figure></p><p>-r 옵션으로 registry 를 지정하고<br>-t 옵션으로 tag 를 지정하자</p><h3 id="RBAC-설정"><a href="#RBAC-설정" class="headerlink" title="RBAC 설정"></a>RBAC 설정</h3><p>알고보니 내가 쓰는 클러스터는 RBAC 가 enable 되어있었다.<br>일단 spark-submit 을 kubernetes 에다가 때리면, driver 라는 pod 가 생기고, 이놈이 다른 executor pods 를 만든다.<br><img src="https://spark.apache.org/docs/latest/img/k8s-cluster-mode.png" title="출처 : 공식 홈페이지"></p><p>그런데 pod 주제에 다른 pods 를 만들려면 권한이 있어야 하는거다.<br>그래서 권한 셋팅을 한다.<br>(나는 어쩌다보니 namespace 까지 설정 해버렸다.. namespace 는 default 로 해도 되겠더라)</p><h4 id="namespace-yml"><a href="#namespace-yml" class="headerlink" title="namespace.yml"></a>namespace.yml</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: Namespace</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: spark</span><br><span class="line">  labels:</span><br><span class="line">    name: spark</span><br></pre></td></tr></table></figure><h4 id="serviceaccount-yml"><a href="#serviceaccount-yml" class="headerlink" title="serviceaccount.yml"></a>serviceaccount.yml</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: ServiceAccount</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  namespace: spark</span><br><span class="line">  name: spark</span><br></pre></td></tr></table></figure><h4 id="role-yml"><a href="#role-yml" class="headerlink" title="role.yml"></a>role.yml</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: Role</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  namespace: spark</span><br><span class="line">  name: spark-role</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups: [&quot;&quot;]</span><br><span class="line">    resources: [&quot;pods&quot;]</span><br><span class="line">    verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;, &quot;delete&quot;]</span><br></pre></td></tr></table></figure><h4 id="rolebinding-yml"><a href="#rolebinding-yml" class="headerlink" title="rolebinding.yml"></a>rolebinding.yml</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: RoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: spark-rolebinding</span><br><span class="line">  namespace: spark</span><br><span class="line">subjects:</span><br><span class="line">  - kind: ServiceAccount</span><br><span class="line">    name: spark</span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role</span><br><span class="line">  name: spark-role</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure><p>파일이 많아서 혼미한데, 이게 뭔소리냐면,<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spark 네임스페이스 아래에서 이 모든 일이 일어날 것인데,</span><br><span class="line">spark-rolebinding 에 적혀있기를,</span><br><span class="line">spark 서비스 어카운트 님은</span><br><span class="line"> spark-role 롤을 가질 것이다.</span><br></pre></td></tr></table></figure></p><h2 id="진짜로-예제-돌리기"><a href="#진짜로-예제-돌리기" class="headerlink" title="진짜로 예제 돌리기"></a>진짜로 예제 돌리기</h2><p>이렇게 셋팅을 하고 아래와 같이 예제를 돌린다</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">-—master k8s://https://KUBERNETES_MASTER_NODE:PORT \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">--name spark-pi \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--conf spark.executor.instances=2 \</span><br><span class="line">—-conf spark.kubernetes.namespace=spark \</span><br><span class="line">—-conf spark.kubernetes.authenticate.driver.serviceAccountName=spark \</span><br><span class="line">--conf spark.kubernetes.container.image=humbledude/spark \</span><br><span class="line">local:///opt/spark/examples/jars/spark-examples_2.11-2.4.0.jar</span><br></pre></td></tr></table></figure><p>local:// 부터는 docker image 안에서 application 의 위치를 지정해준다.<br>내 pc에 있는걸 바로 돌리는건 아직 안된다고 한다.</p><p>옵션은 이렇게 동작한다.</p><ul><li><code>--master</code> : 쿠버네티스 마스터 노드, k8s://로 시작하면 된다. (kubectl cluster-info 로 알수 있다)</li><li><code>--deploy-mode</code> : cluster / client 모드가 있다.<ul><li>cluster 모드는 쿠버네티스 상에 application 을 돌리기 위해 driver 와 executor  를 다 알아서 생성하고 정리하는 모드이다.</li><li>client 모드는 spark-shell 이나 notebook 처럼 interactive 모드로 작업하기 위한 모드라 한다. (별도 옵션으로 server / port 를 지정해 줘야 한다)</li></ul></li><li><code>--name</code> : 이름이다. pod 이름이 이거 기반으로 생성된다.</li><li><code>—-class</code> : jar 파일 내 실행 클래스</li><li><code>—-conf spark.executor.instances</code> : executor 갯수이다. 쿠버네티스 클러스터에서 감당 못하는 숫자를 넣으면 어떻게 되는지 아직 안해봤다.</li><li><code>—-conf spark.kubernetes.authenticate.driver.serviceAccountName</code> : 위에서 만든 serveice account 를 넣는다. 이 account 가 적절한 권한이 있어야 한다.</li><li><code>—-conf spark.kubernetes.namespace</code> : 위에서 만든 namespace 를 넣는다. namespace 를 따로 안만들고 default 로 했으면, 이 옵션이 필요가 없다.</li><li><code>—-conf spark.kubernetes.container.image</code> : 위에서 만든 docker image 위치를 넣는다. 쿠버네티스에서 접근 가능한 위치에 image 가 있어야겠지?</li></ul><p>python 도 돌려보자</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spark-submit \</span><br><span class="line">-—master k8s://https://KUBERNETES_MASTER_NODE:PORT \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">--name spark-py-pi \</span><br><span class="line">--conf spark.executor.instances=2</span><br><span class="line">--conf spark.kubernetes.namespace=spark</span><br><span class="line">--conf spark.kubernetes.authenticate.driver.serviceAccountName=spark \</span><br><span class="line">--conf spark.kubernetes.container.image=humbledude/spark-py \</span><br><span class="line">local:///opt/spark/examples/src/main/python/pi.py</span><br></pre></td></tr></table></figure><p>별거 없고, image 만 교체하고, <code>—-class</code>  만 뺐다.<br>잘돈다.</p><p>결과는 <code>kubectl logs PODS</code> 으로 본다.<br>(example 이니까 결과가 로그에 나오는걸로..)</p><h2 id="기타-삽질들"><a href="#기타-삽질들" class="headerlink" title="기타 삽질들.."></a>기타 삽질들..</h2><h3 id="삽질-1"><a href="#삽질-1" class="headerlink" title="삽질 1"></a>삽질 1</h3><p>얼마전엔 brew 로 spark 인스톨 했더니 <code>2.3.2</code> 가 깔리고,<br>image build 는 홈페이지에 받은 <code>2.4.0</code> tar 파일 압축푼 디렉토리에서 했더니 application 을 돌릴수가 없었다.<br><code>2.3.2</code>/ <code>2.4.0</code> 두 버전간 호환이 안되니, 잘 맞춰서 하자</p><h3 id="삽질-2"><a href="#삽질-2" class="headerlink" title="삽질 2"></a>삽질 2</h3><p><code>2.3.2</code> 에서 python 돌릴라고 했더니 쿠버네티스에서는 python 안된다고 떴었다.<br><code>2.4.0</code> 에서는 잘 돌았다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><h3 id="공식-문서"><a href="#공식-문서" class="headerlink" title="공식 문서"></a>공식 문서</h3><p><a href="https://spark.apache.org/docs/latest/running-on-kubernetes.html" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/running-on-kubernetes.html</a></p><h3 id="2-4-0-what’s-new-블로그"><a href="#2-4-0-what’s-new-블로그" class="headerlink" title="2.4.0 what’s new 블로그"></a>2.4.0 what’s new 블로그</h3><p><a href="https://databricks.com/blog/2018/09/26/whats-new-for-apache-spark-on-kubernetes-in-the-upcoming-apache-spark-2-4-release.html" target="_blank" rel="noopener">https://databricks.com/blog/2018/09/26/whats-new-for-apache-spark-on-kubernetes-in-the-upcoming-apache-spark-2-4-release.html</a></p>]]></content:encoded>
      
      <comments>https://humbledude.github.io/blog/2018/12/01/spark-on-kube/#disqus_thread</comments>
    </item>
    
    <item>
      <title>휴먼을 위한 컴퓨터의 이해 2 - 전자칩 동작 원리</title>
      <link>https://humbledude.github.io/blog/2018/11/27/csforhuman-2/</link>
      <guid>https://humbledude.github.io/blog/2018/11/27/csforhuman-2/</guid>
      <pubDate>Mon, 26 Nov 2018 15:57:47 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;이전 글에서 깃발을 올렸다 내렸다 하면서 숫자를 만들었다.&lt;br&gt;그럼 청기가 얼마나 올라가야 청기를 올린것으로 봐주나?&lt;/p&gt;
&lt;p&gt;명확하게 청기를 번쩍 들었을때는 모두 알 수 있다. 청기가 올라갔구나&lt;br&gt;그런데 그렇게 하면 사회자의 연속적인 
        
      
      </description>
      
      <content:encoded><![CDATA[<p>이전 글에서 깃발을 올렸다 내렸다 하면서 숫자를 만들었다.<br>그럼 청기가 얼마나 올라가야 청기를 올린것으로 봐주나?</p><p>명확하게 청기를 번쩍 들었을때는 모두 알 수 있다. 청기가 올라갔구나<br>그런데 그렇게 하면 사회자의 연속적인 명령에 빠르게 반응하기가 어렵다.<br>최소한의 움직임으로 사회자를 만족시켜야 한다.<br>그런데 애매하게 청기를 꿈틀 하고 청기가 올라갔다고 우기다가 한대 맞았다면 이 억울함을 어찌해야 하나.</p><p>이걸 방지하기 위해 규칙을 정해보자. 팔꿈치보다 청기가 올라가면 올라간거고, 팔꿈치보다 내려가면 내려간거다.<br>팔꿈치와 일직선은 그냥 내려간거로 하자.</p><p>이제 규칙은 명확해졌고, 청기백기 고수라면 이것을 이용해 매우 작은 움직임 만으로도 청기백기 게임을 승리할수 있으리라.<br>대략 팔꿈치 근처에서 꿈틀 거리겠지.</p><p>요것이 전기를 0과 1로 바꾸는 방법이랑 비슷하다.<br>다양한 상태를 가질 수 있는걸 명확한 규칙을 적용해서 두가지 케이스로 만드는 거다.</p><p>피카츄의 백만볼트를 생각해보자.<br><img src="https://media.giphy.com/media/NfmqJkgxr6VEc/giphy.gif" title="피카츄 백만볼트"><br>피카츄는 백만볼트 기술을 써서 로켓단을 무찌르는데, 로켓단이 하도 전기를 많이 맞아서 오십만 볼트까지는 맞아도 안날라간다고 치자.<br>근데 우리 피카츄는 백만볼트 기술을 쓰더라도 항상 백만볼트가 나가지는 않나보다.<br>배가고프다던가 몇대 맞았다던가 하면 좀 빠워가 약하다.</p><p>그래서 이렇게 된다.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">피카츄 백만 볼트 -&gt; 로켓단 사망</span><br><span class="line">피카츄 구십구만 볼트 -&gt; 로켓단 사망</span><br><span class="line">…</span><br><span class="line">피카츄 오십일만 볼트 -&gt; 로켓단 사망</span><br><span class="line">피카츄 오십만 볼트 -&gt; 로켓단 생존</span><br><span class="line">…</span><br><span class="line">피카츄 만볼트 -&gt; 로켓단 생존</span><br></pre></td></tr></table></figure></p><p>피카츄의 전기(만볼트 ~ 백만볼트)가 로켓단 사망(0) , 생존(1) 으로 이어지는것이다.<br>피카츄는 다양한 컨디션을 갖지만, 결국 로켓단의 사망(0)과 생존(1)의 두가지 결론만 있다.</p><p>전자칩도 마찬가지다.<br><img src="/blog/2018/11/27/csforhuman-2/microchip.png" title="전자칩 그림"><br>뭣에다 쓰는 전자칩인지는 모르겠지만 애벌레같이 생긴 이 전자칩의 다리를 통해 전기가 왔다갔다 하는데,<br>백만볼트는 아니지만 몇 볼트 보다 높게 들어가면 전자칩이 아 1이 들어왔구나 하고<br>그거보다 낮게 들어오면 아 0이 들어왔구나 한다.<br>(이 기준은 칩을 만든 회사에서 정하기도 하고, 표준이 있기도 하다)</p><p>물론 현실은 이거보다는 복잡하지만, 전자칩은 아무튼 전기로 0 과 1을 주고 받는구나 이렇게 생각하면 된다.<br>누구랑? 다른 전자칩이랑.<br><img src="/blog/2018/11/27/csforhuman-2/pcb.jpg" title="회로 그림"><br>컴퓨터를 뜯어보면 이렇게 생긴 칩들이 많이 박혀있고, 하얀 선으로 서로 연결 되어있다.<br>이 선들중 대부분이 0 과 1이 왔다갔다 하는 통로 이다.<br>그리고 전자칩은 0과 1을 다양하게 조합해서 더 많은 숫자들로 인식 한다.</p><p>그러면 이 다양한 숫자가 오고가는게 컴퓨터에서 어떤 역할을 하는지 슬슬 알아 보자.</p><blockquote><p>연관 용어 : pull-up, pull-down, ic, bus, gpio</p></blockquote>]]></content:encoded>
      
      <comments>https://humbledude.github.io/blog/2018/11/27/csforhuman-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>휴먼을 위한 컴퓨터의 이해 1 - 이진법</title>
      <link>https://humbledude.github.io/blog/2018/11/22/csforhuman-1-0-1/</link>
      <guid>https://humbledude.github.io/blog/2018/11/22/csforhuman-1-0-1/</guid>
      <pubDate>Thu, 22 Nov 2018 14:55:07 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;아무리 컴퓨터에 대해 잘 모르는 사람도  어디 지나가다가 컴퓨터는 0과 1을 가지고 뭘 했다는 소리 정도는 들었을 것이다.&lt;br&gt;컴퓨터는 기본적으로 0과 1을 가지고 동작하는 기계이다.&lt;br&gt;일단 그놈의 0과 1이 어쨌다는건지 알아보자.&lt;/p&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<p>아무리 컴퓨터에 대해 잘 모르는 사람도  어디 지나가다가 컴퓨터는 0과 1을 가지고 뭘 했다는 소리 정도는 들었을 것이다.<br>컴퓨터는 기본적으로 0과 1을 가지고 동작하는 기계이다.<br>일단 그놈의 0과 1이 어쨌다는건지 알아보자.</p><img src="/blog/2018/11/22/csforhuman-1-0-1/matrix-434035_640.jpg" title="매트릭스 0과 1"><p>일단 청기 백기 게임을 떠올려 본다.<br>청기백기 게임을 모르는 청춘들은 유투브에서 한번 검색 해 보자.<br><img src="/blog/2018/11/22/csforhuman-1-0-1/blue-white.jpg" title="청기백기"></p><p>청기 올려 라는 사회자의 명령에 청기를 올려 본다.<br>대략 틀리면 맞기도 하고 벌주를 먹기도 한다.<br>이거 하다보면 점점 빨리하는데 잘하는 사람은 진짜 빨리 반응을 잘한다.</p><p>요걸로 컴퓨터의 기본 숫자인 0 과 1을 표현해 볼것이다.</p><p>청기가 올라간것을 1, 내려간것을 0이라고 표현해 보자.<br>얼마나 올라갔는지 보다는 올라갔는지 내려갔는지만 알면 되는거다.<br>이제 0이랑 1을 깃발 하나로 표현할 수 있다는걸 알았다.</p><p>근데 2를 표현하고 싶으면 어떻게 해야 하나?<br>우리에겐 백기가 있다.<br>청기랑 백기를 조합하면 무려 3까지 표현할 수 있다.<br>대충 이런식이다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 = 청기 내려 백기 내려</span><br><span class="line">1 = 청기 내려 백기 올려</span><br><span class="line">2 = 청기 올려 백기 내려</span><br><span class="line">3 = 청기 올려 백기 올려</span><br></pre></td></tr></table></figure><p>깃발 두개로 0 에서 3까지의 숫자를 표현할 수 있는 규칙을 만들었다.<br>그럼 청기백기를 든 아저씨를 몇명 더 데려오면 표현할 수 있는 숫자가 더 많아지겠지?</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 = 아저씨1 (청기 내려 백기 올려) 아저씨2 (청기 내려 백기 내려)</span><br><span class="line">5 = 아저씨1 (청기 내려 백기 올려) 아저씨2 (청기 내려 백기 올려)</span><br></pre></td></tr></table></figure><p>혹자는 이것이 이진법이라는것을 알것이다.<br>이진법이란 쉽게 생각해서 0과 1, 두가지 숫자를 여러개 조합해서 우리가 이미 알고있는 다른 숫자를 표현하는 방법이다.<br>위에 나온 깃발든 아저씨들이 많이 모이면 얼마든지 더 큰 숫자도 표현할 수 있다.</p><p>참고로 아저씨들을 많이 모으지 않고 깃발 한개로 숫자를 더 표현하는 방법도 있다.<br>바로 시간차를 두고 순서대로 명령을 읊으면 된다.<br>청기 하나로 해보자 (고급 사회자는 이런 혼미한 명령을 잘 내린다)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 = 청기 내리고 청기 내려</span><br><span class="line">1 = 청기 내리고 청기 올려</span><br><span class="line">2 = 청기 올리고 청기 내려</span><br><span class="line">3 = 청기 올리고 청기 올려</span><br></pre></td></tr></table></figure><p>사회자가 이 혼미한 말을 계속 읊으면 더 많은 숫자를 표현 할 수 있다는것을 기억하자.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">245 = 청기 올리고 청기 내리고 청기 내리고 청기 올리고 청기 내리고 청기 내리고 청기 내리고 청기 올리고 청기 내리고 청기 올려!!!!</span><br></pre></td></tr></table></figure><p>그럼 오늘은 여기까지 하고 깃발 올린거랑 내린거랑 숫자랑 갖고 컴퓨터를 뭘 어쨌다는건지는 다음 글에서 알아보자.</p><blockquote><p>연관 용어 : 이진법, digital, serial, parallel</p></blockquote>]]></content:encoded>
      
      <comments>https://humbledude.github.io/blog/2018/11/22/csforhuman-1-0-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>휴먼을 위한 컴퓨터의 이해 0 - 들어가는 말</title>
      <link>https://humbledude.github.io/blog/2018/11/22/csforhuman-0/</link>
      <guid>https://humbledude.github.io/blog/2018/11/22/csforhuman-0/</guid>
      <pubDate>Wed, 21 Nov 2018 15:26:01 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;저는 소프트웨어 개발을 업으로 하는 사람입니다.&lt;br&gt;일을 하다보면 개발자와 이야기 하는 일도 많지만,&lt;br&gt;개발자가 아닌 분들과 업무를 진행해야 하는 일도 많습니다.&lt;/p&gt;
&lt;p&gt;보통 기획자와 개발자의 커뮤니케이션이 상당히 어렵다고 하는데요,&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>저는 소프트웨어 개발을 업으로 하는 사람입니다.<br>일을 하다보면 개발자와 이야기 하는 일도 많지만,<br>개발자가 아닌 분들과 업무를 진행해야 하는 일도 많습니다.</p><p>보통 기획자와 개발자의 커뮤니케이션이 상당히 어렵다고 하는데요,<br>개발자는 보통 기획자가 알아듣기 어려운 기술 용어를 써가며 말을 하고<br>기획자는 추상적인 말을 사용하니, 서로의 의도를 정확히 파악하지 못하곤 합니다.</p><p>나름 커뮤니케이션에 문제가 없는 편이라고 자부하면서도,<br>막상 업무 관계에서 명확히 의사소통을 하는것은 항상 어려운 일입니다.</p><p>그들을 저는 휴먼 종족이라고 칭합니다.<br>개발자 종족과는 다른 언어와 종교를 갖고, 다른 세계에서 살고 있는것 처럼 보입니다.<br>저는 휴먼들에게 개발자와 소통하기 위해 개발자가 대체 뭘 배웠기에 이 지경이 되었는지 휴먼들이 이해할 수 있도록 설명하는게 어떨까 생각 했습니다.<br>그래서 이 글을 써 봅니다. 약간 전도지와 같습니다.<br>휴먼에서 개발자로 개종을 원하시는 분에게도 어렴풋이 도움이 되었으면 하네요.</p><p>목표는 정상적이고 매우 상식적인 사람들이 보고서 개발자들이 말하는 용어들을 대충 느낌적인 느낌으로 알아들을 수 있게 하는겁니다.<br>그렇게 하기 위해서 자세한 내용은 다 던져버리고 매우 핵심에 대한 내용을 매우 대충 다루며 지나갈 예정입니다.</p><p>그게 맘처럼 될지 모르겠으나,<br>어렵거나 이해가 안되는 내용은 알려주세요. 가능한 더 쉽게 설명해 보겠습니다.</p>]]></content:encoded>
      
      <comments>https://humbledude.github.io/blog/2018/11/22/csforhuman-0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MySql 테이블 백업 &amp; 복구</title>
      <link>https://humbledude.github.io/blog/2018/11/16/mysql-backup-restore/</link>
      <guid>https://humbledude.github.io/blog/2018/11/16/mysql-backup-restore/</guid>
      <pubDate>Thu, 15 Nov 2018 18:09:20 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;백업&quot;&gt;&lt;a href=&quot;#백업&quot; class=&quot;headerlink&quot; title=&quot;백업&quot;&gt;&lt;/a&gt;백업&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="백업"><a href="#백업" class="headerlink" title="백업"></a>백업</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysqldump -u USER_NAME -h HOST -p DB_NAME TABLE_NAME &gt; backup.sql</span><br></pre></td></tr></table></figure><p><em>-p 는 패스워드 입력 옵션 </em></p><h2 id="복구"><a href="#복구" class="headerlink" title="복구"></a>복구</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql -u USER_NAME -h HOST -p DB_NAME &lt; backup.sql</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://humbledude.github.io/blog/2018/11/16/mysql-backup-restore/#disqus_thread</comments>
    </item>
    
    <item>
      <title>zsh &amp; bash locale 설정</title>
      <link>https://humbledude.github.io/blog/2018/11/16/zsh-bash-locale/</link>
      <guid>https://humbledude.github.io/blog/2018/11/16/zsh-bash-locale/</guid>
      <pubDate>Thu, 15 Nov 2018 18:05:51 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h2&gt;&lt;p&gt;mac os 에서 기본 bash 를 사용하고 있었고, 원격 서버로 ssh 접속했을 때, ssh 상에서 한글 표시가 문제 없었다
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>mac os 에서 기본 bash 를 사용하고 있었고, 원격 서버로 ssh 접속했을 때, ssh 상에서 한글 표시가 문제 없었다.</p><p>그런데 zsh 를 쓰고 원격 서버로 ssh 접속하니, 한글 표시가 문제가 되었다.</p><p>여기서 원격 서버는 bash 사용중.</p><h2 id="작업-내용"><a href="#작업-내용" class="headerlink" title="작업 내용"></a>작업 내용</h2><p>결국 locale 설정 문제다.<br>mac os 에서 locale 확인:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ locale</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LANG=<span class="string">"ko_KR.UTF-8"</span></span><br><span class="line">LC_COLLATE=<span class="string">"ko_KR.UTF-8"</span></span><br><span class="line">LC_CTYPE=<span class="string">"ko_KR.UTF-8"</span></span><br><span class="line">LC_MESSAGES=<span class="string">"ko_KR.UTF-8"</span></span><br><span class="line">LC_MONETARY=<span class="string">"ko_KR.UTF-8"</span></span><br><span class="line">LC_NUMERIC=<span class="string">"ko_KR.UTF-8"</span></span><br><span class="line">LC_TIME=<span class="string">"ko_KR.UTF-8"</span></span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure><p>bash -&gt; 원격 서버 접속 후 locale 확인:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LANG=en_US.UTF-8</span><br><span class="line">LANGUAGE=</span><br><span class="line">LC_CTYPE=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_NUMERIC=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_TIME=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_COLLATE=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_MONETARY=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_MESSAGES=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_PAPER=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_NAME=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_ADDRESS=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_TELEPHONE=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_MEASUREMENT=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_IDENTIFICATION=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure></p><p>zsh -&gt; 원격 서버 접속 후 locale 확인:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locale: Cannot <span class="built_in">set</span> LC_CTYPE to default locale: No such file or directory</span><br><span class="line">locale: Cannot <span class="built_in">set</span> LC_ALL to default locale: No such file or directory</span><br><span class="line">LANG=en_US.UTF-8</span><br><span class="line">LANGUAGE=</span><br><span class="line">LC_CTYPE=ko_KR.UTF-8</span><br><span class="line">LC_NUMERIC=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_TIME=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_COLLATE=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_MONETARY=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_MESSAGES=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_PAPER=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_NAME=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_ADDRESS=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_TELEPHONE=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_MEASUREMENT=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_IDENTIFICATION=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure></p><p>원격 서버에서 아래와 같이 입력하면 이슈는 해결된다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo locale-gen <span class="string">"ko_KR.UTF-8"</span></span><br></pre></td></tr></table></figure><p>다시 locale 확인해보면~<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LANG=en_US.UTF-8</span><br><span class="line">LANGUAGE=</span><br><span class="line">LC_CTYPE=ko_KR.UTF-8</span><br><span class="line">LC_NUMERIC=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_TIME=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_COLLATE=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_MONETARY=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_MESSAGES=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_PAPER=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_NAME=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_ADDRESS=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_TELEPHONE=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_MEASUREMENT=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_IDENTIFICATION=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure></p><p>LC_CTYPE 이 ko_KR.UTF-8 로 설정되고, ssh 에서 한글 사용이 자유롭게 되는것을 볼 수 있다.</p><h2 id="원인-분석"><a href="#원인-분석" class="headerlink" title="원인 분석"></a>원인 분석</h2><p>일단 LC_CTYPE 이게 뭔가?</p><p>gnu 정의 보면..</p><blockquote><p>This category applies to classification and conversion of characters, and to multibyte and wide characters;</p></blockquote><p>conversion 에 관여하는 항목이라고 보인다.</p><p>아직 정확히 파악은 안되었지만, ssh 통해서 지원하지 않는 locale 이 나타났을때 LC_CTYPE 기준으로 conversion 이 이루어진다고 보인다.</p><p>bash 는 뭔가 능숙히 터널링이 되었고, zsh 는 안되는건 안된다라고 표현한듯…</p>]]></content:encoded>
      
      <comments>https://humbledude.github.io/blog/2018/11/16/zsh-bash-locale/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://humbledude.github.io/blog/2018/11/15/hello-world/</link>
      <guid>https://humbledude.github.io/blog/2018/11/15/hello-world/</guid>
      <pubDate>Thu, 15 Nov 2018 14:37:11 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
        
      
      </description>
      
      <content:encoded><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content:encoded>
      
      <comments>https://humbledude.github.io/blog/2018/11/15/hello-world/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
