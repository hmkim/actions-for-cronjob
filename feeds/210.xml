<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Developer&#39;s Record</title>
  <subtitle>개발자의 기록 보관소</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://infoscis.github.io/"/>
  <updated>2018-11-28T13:55:08.820Z</updated>
  <id>http://infoscis.github.io/</id>
  
  <author>
    <name>Jongcheol-Kim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot와 Kotlin으로 웹 애플리케이션 구축하기</title>
    <link href="http://infoscis.github.io/2018/08/30/spring-boot-kotlin/"/>
    <id>http://infoscis.github.io/2018/08/30/spring-boot-kotlin/</id>
    <published>2018-08-29T15:30:20.000Z</published>
    <updated>2018-11-28T13:55:08.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot와-Kotlin으로-웹-애플리케이션-구축하기"><a href="#Spring-Boot와-Kotlin으로-웹-애플리케이션-구축하기" class="headerlink" title="Spring Boot와 Kotlin으로 웹 애플리케이션 구축하기"></a>Spring Boot와 Kotlin으로 웹 애플리케이션 구축하기</h1><p>이 튜토리얼은 <a href="https://projects.spring.io/spring-boot/" target="_blank" rel="external">Spring Boot</a>와 <a href="https://kotlinlang.org/" target="_blank" rel="external">Kotlin</a>을 결합하여 예제 블로그 애플리케이션을 효율적으로 빌드하는 방법을 설명합니다..</p>
<p>만약 Kotlin을 처음 시작한다면 <a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="external">참고 문서</a>를 읽고 온라인 <a href="https://try.kotlinlang.org/" target="_blank" rel="external">Kotlin Koans 자습서</a>를 따라하며 언어를 배울 수 있습니다.</p>
<p>Spring Kotlin 지원은 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/languages.html#kotlin" target="_blank" rel="external">Spring Framework</a> 및 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-kotlin.html" target="_blank" rel="external">Spring Boot</a> 참고문서에 설명되어 있습니다. 도움이 필요하면 StackOverflow에서 <a href="https://stackoverflow.com/questions/tagged/kotlin+spring" target="_blank" rel="external">Spring 및 kotlin 태그로 검색하거나 질문</a>을 할 수 있고, <a href="http://slack.kotlinlang.org/" target="_blank" rel="external">Kotlin Slack</a>의 <code>#spring</code> 채널에서 토론하십시오.</p>
<h2 id="새-프로젝트-만들기"><a href="#새-프로젝트-만들기" class="headerlink" title="새 프로젝트 만들기"></a>새 프로젝트 만들기</h2><p>먼저 Spring Boot 애플리케이션을 만들어야하고, 이는 여러 가지 방법으로 수행 할 수 있습니다. 예를 들어, 우리는 Kotlin 생태계에서 가장 많이 사용하는 Gradle 빌드 시스템을 사용할 것이지만, 만약 원하는 경우 Maven도 자유롭게 사용할 수 있습니다.(예제 블로그 프로젝트의 일부로 Gradle 빌드와 동일한 Maven pom.xml을 <a href="https://github.com/spring-guides/tut-spring-boot-kotlin/blob/master/pom.xml" target="_blank" rel="external">사용할 수</a> 있습니다).</p>
<h3 id="Initializr-웹-사이트-사용"><a href="#Initializr-웹-사이트-사용" class="headerlink" title="Initializr 웹 사이트 사용"></a>Initializr 웹 사이트 사용</h3><p><a href="https://start.spring.io" target="_blank" rel="external">https://start.spring.io</a> 로 이동하여 Kotlin 언어를 선택합니다. 또는 Kotlin을 미리 선택하려면 직접 <a href="https://start.spring.io/#!language=kotlin" target="_blank" rel="external">https://start.spring.io/#!language=kotlin</a> 로 방문할 수 있습니다.</p>
<p>그런 다음 Gradle 빌드 시스템, “blog” Artifact, “blog” Package Name(고급 설정)을 선택하고 “Web”, “Mustache”, “JPA”및 “H2” 종속성을 시작점으로 추가한 다음 “Generate Project”를 클릭합니다.<br><img src="https://github.com/spring-guides/tut-spring-boot-kotlin/raw/master/images/initializr.png" alt=""></p>
<p>압축을 풀기전에 빈 디렉토리를 만듭니다. 그리고 .zip 파일의 루트 디렉토리에는 표준 Gradle 프로젝트가 포함되어 있습니다.</p>
<h3 id="Command-Line-사용"><a href="#Command-Line-사용" class="headerlink" title="Command Line 사용"></a>Command Line 사용</h3><p>Command Line에서 Initializr HTTP API를 사용할 수 있습니다 (예 : UN*X 시스템의 curl).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir blog &amp;&amp; cd blog</div><div class="line">$ curl https://start.spring.io/starter.zip -d type=gradle-project -d language=kotlin -d style=web,mustache,jpa,h2 -d packageName=blog -d name=Blog -o blog.zip</div></pre></td></tr></table></figure>
<h3 id="IntelliJ-IDEA-사용"><a href="#IntelliJ-IDEA-사용" class="headerlink" title="IntelliJ IDEA 사용"></a>IntelliJ IDEA 사용</h3><p>또한 Spring Initializr은 IntelliJ IDEA Ultimate 에디션에 통합되어 있어 IDE에서 Command Line 또는 웹 UI와 같이 새 프로젝트를 만들고 가져올 수 있습니다.</p>
<p>File | New | Project를 선택하고 Spring Initializr을 선택합니다.</p>
<p>각 단계에 따라 다음 파라미터를 사용합니다.</p>
<ul>
<li>Package name: “blog”</li>
<li>Artifact: “blog”</li>
<li>Type: Gradle Project</li>
<li>Language: Kotlin</li>
<li>Name: “Blog”</li>
<li>Dependencies: “Web”, “Mustache”, JPA” and “H2”</li>
</ul>
<h2 id="생성된-프로젝트-이해하기"><a href="#생성된-프로젝트-이해하기" class="headerlink" title="생성된 프로젝트 이해하기"></a>생성된 프로젝트 이해하기</h2><h3 id="Gradle-build"><a href="#Gradle-build" class="headerlink" title="Gradle build"></a>Gradle build</h3><h4 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h4><p>명백한 <a href="https://kotlinlang.org/docs/reference/using-gradle.html" target="_blank" rel="external">Kotlin Gradle plugin</a> 외에도, 기본 설정은 스프링 Annotation으로 annotated 또는 meta-annotated가 달린 클래스와 메서드가 자동으로 열리는(Automatically open)<a href="https://kotlinlang.org/docs/reference/compiler-plugins.html#spring-support" target="_blank" rel="external">kotlin-spring plugin</a>을 선언합니다 (Java와 달리 Kotlin의 기본 한정자(Qualifier)는 <code>final</code>입니다). 예를 들어 CGLIB 프록시에 필요한 <code>open</code> 한정자를 추가하지 않고도 <code>@Configuration</code> 또는 <code>@Transactional</code> Bean을 만들 수있는 경우에 유용합니다.</p>
<p><strong>build.gradle</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">  ext &#123;</div><div class="line">44kotlinVersion = &apos;1.2.51&apos;</div><div class="line">44springBootVersion = &apos;2.0.4.RELEASE&apos;</div><div class="line">  &#125;</div><div class="line">  repositories &#123;</div><div class="line">    mavenCentral()</div><div class="line">  &#125;</div><div class="line">  dependencies &#123;</div><div class="line">    classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot;)</div><div class="line">    classpath(&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$&#123;kotlinVersion&#125;&quot;)</div><div class="line">    classpath(&quot;org.jetbrains.kotlin:kotlin-allopen:$&#123;kotlinVersion&#125;&quot;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">apply plugin: &apos;kotlin&apos;</div><div class="line">apply plugin: &apos;kotlin-spring&apos;</div><div class="line">apply plugin: &apos;org.springframework.boot&apos;</div><div class="line">apply plugin: &apos;io.spring.dependency-management&apos;</div></pre></td></tr></table></figure></p>
<h4 id="컴파일러-옵션-Compiler-options"><a href="#컴파일러-옵션-Compiler-options" class="headerlink" title="컴파일러 옵션 (Compiler options)"></a>컴파일러 옵션 (Compiler options)</h4><p>Kotlin의 핵심 기능 중 하나는 런타임시 유명한 <code>NullPointerException</code>에 부딪히지 않고 컴파일 타임에 <code>null</code>값을 깔끔하게 처리하는 <a href="https://kotlinlang.org/docs/reference/null-safety.html" target="_blank" rel="external">null-safety</a>입니다. 따라서 애플리케이션이 null 허용 선언을 통해 안전하고, <code>Optional</code>(“값 또는 값 없음” 의미를 표현)과 같은 래퍼의 비용을 지불하지 않아도됩니다. Kotlin은 nullable 값을 가진 함수 생성자를 사용할 수 있습니다. <a href="http://www.baeldung.com/kotlin-null-safety" target="_blank" rel="external">Kotlin null-safety에 대한 포괄적 가이드</a>를 확인하십시오.</p>
<p>Java는 type-system에서 null-safety를 허용하지 않지만 Spring Framework는 <code>org.springframework.lang</code> 패키지에 선언된 도구 친화적인(Tooling-friendly) Annotation을 통해 전체 Spring Framework API의 null-safety를 제공합니다. 기본적으로 Kotlin에서 사용되는 Java API의 타입은 null 체크가 완화된 <a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types" target="_blank" rel="external">플랫폼 타입</a>으로 인식됩니다. <a href="https://kotlinlang.org/docs/reference/java-interop.html#jsr-305-support" target="_blank" rel="external">JSR 305 annotations</a> + Spring Nullability Annotation에 대한 Kotlin 지원은 컴파일 타임에 <code>null</code> 관련 문제를 처리 할 수 있다는 이점을 가지고 Kotlin 개발자에게 전체 Spring Framework API에 대한 null-safety를 제공합니다.</p>
<p>이 기능은 <code>-Xjsr305</code> 컴파일러 플래그에 <code>strict</code> 옵션을 추가하여 활성화 할 수 있습니다.</p>
<p>아래 코드의 Kotlin 컴파일러는 Java 8 바이트 코드 (Java 6이 기본값)를 생성하도록 구성되어 있습니다.</p>
<p><strong>build.gradle</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">sourceCompatibility = 1.8</div><div class="line">compileKotlin &#123;</div><div class="line">  kotlinOptions &#123;</div><div class="line">    freeCompilerArgs = [&quot;-Xjsr305=strict&quot;]</div><div class="line">    jvmTarget = &quot;1.8&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">compileTestKotlin &#123;</div><div class="line">  kotlinOptions &#123;</div><div class="line">    freeCompilerArgs = [&quot;-Xjsr305=strict&quot;]</div><div class="line">    jvmTarget = &quot;1.8&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="종속성-Dependencies"><a href="#종속성-Dependencies" class="headerlink" title="종속성(Dependencies)"></a>종속성(Dependencies)</h4><p>Kotlin 특정 라이브러리 3개는 이러한 Spring Boot 웹 애플리케이션에 필요하며 기본 구성에 필요합니다.</p>
<ul>
<li><code>kotlin-stdlib-jdk8</code>은 Kotlin 표준 라이브러리의 Java 8 변형입니다.</li>
<li><code>kotlin-reflect</code>은 Kotlin 리플렉션 라이브러리입니다 (Spring Framework 5에서 필수).</li>
<li><code>jackson-module-kotlin</code>은 Kotlin 클래스 및 데이터 클래스의 직렬화 / 비 직렬화에 대한 지원을 추가합니다 (단일 생성자 클래스는 자동으로 사용할 수 있고 보조 생성자 또는 정적 팩토리가 있는 클래스도 지원됩니다)</li>
</ul>
<p><strong>build.gradle</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">  compile(&apos;org.springframework.boot:spring-boot-starter-data-jpa&apos;)</div><div class="line">  compile(&apos;org.springframework.boot:spring-boot-starter-web&apos;)</div><div class="line">  compile(&apos;org.springframework.boot:spring-boot-starter-mustache&apos;)</div><div class="line">  compile(&apos;com.fasterxml.jackson.module:jackson-module-kotlin&apos;)</div><div class="line">  compile(&quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8&quot;)</div><div class="line">  compile(&quot;org.jetbrains.kotlin:kotlin-reflect&quot;)</div><div class="line">  testCompile(&apos;org.springframework.boot:spring-boot-starter-test&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Spring Boot Gradle 플러그인은 Kotlin Gradle 플러그인에 선언된 Kotlin 버전을 자동으로 사용합니다.</p>
<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p><strong>src/main/kotlin/blog/BlogApplication.kt</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> blog</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication</div><div class="line"><span class="keyword">import</span> org.springframework.boot.runApplication</div><div class="line"></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogApplication</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  runApplication&lt;BlogApplication&gt;(*args)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java와 비교하면, 세미콜론이 줄어들었고, 빈 클래스에 괄호가 없으며 (<code>@Bean</code> Annotation을 통해 Bean을 선언해야하는 경우 추가 할 수 있습니다), 최상위 수준 함수 <code>runApplication</code>을 사용할 수 있다는 것을 알수 있습니다. <code>runApplication&lt;BlogApplication&gt;(*args)</code>은 <code>SpringApplication.run(BlogApplication::class.java, *args)</code>에 대한 Kotlin의 대안적인 표현이며, 다음 구문을 사용하여 사용자 정의 애플리케이션을 사용할 수 있습니다.</p>
<p><strong>src/main/kotlin/blog/BlogApplication.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  runApplication&lt;BlogApplication&gt;(*args) &#123;</div><div class="line">    setBannerMode(Banner.Mode.OFF)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="첫-번째-Kotlin-컨트롤러-작성하기"><a href="#첫-번째-Kotlin-컨트롤러-작성하기" class="headerlink" title="첫 번째 Kotlin 컨트롤러 작성하기"></a>첫 번째 Kotlin 컨트롤러 작성하기</h2><p>간단한 웹 페이지를 표시하는 간단 컨트롤러를 만들어 보겠습니다.</p>
<p><strong>src/main/kotlin/blog/HtmlController.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> blog</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller</div><div class="line"><span class="keyword">import</span> org.springframework.ui.Model</div><div class="line"><span class="keyword">import</span> org.springframework.ui.<span class="keyword">set</span></div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.GetMapping</div><div class="line"></div><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlController</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@GetMapping(<span class="meta-string">"/"</span>)</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">blog</span><span class="params">(model: <span class="type">Model</span>)</span></span>: String &#123;</div><div class="line">    model[<span class="string">"title"</span>] = <span class="string">"Blog"</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"blog"</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="external">Kotlin extension</a>을 사용하여 기존의 Spring 타입에 Kotlin 함수나 연산자를 추가 할 수 있습니다. 여기에서는 <code>model.addAttribute(&quot;title&quot;, &quot;Blog&quot;)</code> 대신 <code>model[&quot;title&quot;] = &quot;Blog&quot;</code>를 사용할 수 있도록 <code>org.springframework.ui.set</code> 확장 함수를 가져옵니다.</p>
<p>그리고 관련된 Mustache 템플릿을 만들어야합니다.</p>
<p><strong>src/main/resources/templates/header.mustache</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>src/main/resources/templates/footer.mustache</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>src/main/resources/templates/blog.mustache</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;&gt; header&#125;&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"></div><div class="line">&#123;&#123;&gt; footer&#125;&#125;</div></pre></td></tr></table></figure></p>
<p><code>BlogApplication.kt</code>의 <code>main</code> 함수를 실행하여 응용프로그램을 시작하고, <code>http://localhost:8080/</code>으로 이동하면 “Blog” 제목이 있는 단순한 웹 페이지가 나타납니다.</p>
<h2 id="JUnit-5로-테스트하기"><a href="#JUnit-5로-테스트하기" class="headerlink" title="JUnit 5로 테스트하기"></a>JUnit 5로 테스트하기</h2><p>JUnit 4는 여전히 Spring Boot와 함께 제공되는 기본 테스트 프레임 워크이지만, JUnit 5는 null이 허용되지 않는 <code>val</code> 프로퍼티를 사용할 수 있는 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-junit-jupiter-di" target="_blank" rel="external">생성자/메서드 파라미터의 Autowiring</a>을 포함하여 Kotlin에서 매우 편리한 다양한 기능을 제공합니다. 그리고 <code>@BeforeAll</code>/<code>@AfterAll</code>을 일반적인 비 정적 메서드에서 사용할 수 있습니다.</p>
<h3 id="JUnit-4에서-JUnit-5로-전환"><a href="#JUnit-4에서-JUnit-5로-전환" class="headerlink" title="JUnit 4에서 JUnit 5로 전환"></a>JUnit 4에서 JUnit 5로 전환</h3><p>먼저 <a href="https://docs.gradle.org/4.6/release-notes.html#junit-5-support" target="_blank" rel="external">네이티브 JUnit 5 지원</a>을 활용할 수 있도록 <code>./gradlew -version</code>을 실행하여 Gradle 4.6 이상을 사용하고 있는지 확인하십시오. 이전 버전을 사용하는 경우 <code>./gradlew wrapper --gradle-version 4.7</code>을 실행하여 <a href="https://docs.gradle.org/current/release-notes.html" target="_blank" rel="external">최신 버전의 Gradle</a>을 업데이트 할 수 있습니다.</p>
<p><code>build.gradle</code> 파일에 다음 줄을 추가하여 JUnit 5 지원을 활성화합니다.</p>
<p><strong>build.gradle</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">test &#123;</div><div class="line">  useJUnitPlatform()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>그런 다음 <code>junit</code>을 <code>spring-boot-starter-test</code> 전이(transitive) 의존성에서 제외하고 <code>junit-jupiter-api</code> 및 <code>junit-jupiter-engine</code>을 추가합니다.</p>
<p><strong>build.gradle</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">  testCompile(&apos;org.springframework.boot:spring-boot-starter-test&apos;) &#123;</div><div class="line">    exclude module: &apos;junit&apos;</div><div class="line">  &#125;</div><div class="line">  testImplementation(&apos;org.junit.jupiter:junit-jupiter-api&apos;)</div><div class="line">  testRuntimeOnly(&apos;org.junit.jupiter:junit-jupiter-engine&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Gradle 설정을 새로 고치고 <code>BlogApplicationTests</code>를 열어 <code>@RunWith(SpringRunner::class)</code>를 <code>@ExtendWith(SpringExtension::class)</code>로 대체합니다.</p>
<p><strong>src/test/kotlin/blog/BlogApplicationTests.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ExtendWith(SpringExtension::class)</span></div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogApplicationTests</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">contextLoads</span><span class="params">()</span></span> &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>테스트는 Command Line과 IDE에서 잘 실행되어야합니다.</p>
<h3 id="Kotlin에서-JUnit-5-테스트-작성하기"><a href="#Kotlin에서-JUnit-5-테스트-작성하기" class="headerlink" title="Kotlin에서 JUnit 5 테스트 작성하기"></a>Kotlin에서 JUnit 5 테스트 작성하기</h3><p>이 예제에서는 다양한 기능을 보여주기 위해 통합 테스트를 작성해 보겠습니다.</p>
<ul>
<li>표현형 테스트 함수 이름을 제공하기 위해 camel-case 대신 백틱 사이에 실제 문장을 사용합니다.</li>
<li>JUnit 5는 생성자와 메서드 파라미터를 삽입(Inject) 할 수 있습니다.이 파라미터는 Kotlin 불변(Immutable) 및 Nullable 속성과 잘 어울립니다.</li>
<li>이 코드는 <code>getForObject</code> 및 <code>getForEntity</code> Kotlin extension을 사용합니다 (import 할 필요가 있음).</li>
</ul>
<p><strong>src/test/kotlin/blog/IntegrationTests.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ExtendWith(SpringExtension::class)</span></div><div class="line"><span class="meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegrationTests</span></span>(<span class="meta">@Autowired</span> <span class="keyword">val</span> restTemplate: TestRestTemplate) &#123;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> `Assert blog page title, content and status code`<span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> entity = restTemplate.getForEntity&lt;String&gt;(<span class="string">"/"</span>)</div><div class="line">    assertThat(entity.statusCode).isEqualTo(HttpStatus.OK)</div><div class="line">    assertThat(entity.body).contains(<span class="string">"&lt;h1&gt;Blog&lt;/h1&gt;"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="테스트-인스턴스-생명주기-Lifecycle"><a href="#테스트-인스턴스-생명주기-Lifecycle" class="headerlink" title="테스트 인스턴스 생명주기(Lifecycle)"></a>테스트 인스턴스 생명주기(Lifecycle)</h3><p>때로는 주어진 클래스의 모든 테스트 전후에 메서드를 실행해야 할 때가 있습니다. Junit 4와 마찬가지로 JUnit 5는 테스트 클래스가 테스트마다 한 번 인스턴스화되기 때문에 기본적으로 이 메서드가 정적 (이것은 Kotlin의 <a href="https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects" target="_blank" rel="external">companion object</a>로 변환되며, 이는 매우 장황하고 직설적이지 않습니다.) 이어야합니다.</p>
<p>그러나 Junit 5에서는 이 기본 동작을 변경하고 클래스당 한 번 테스트 클래스를 인스턴스화 할 수 있습니다. 이 작업은 <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle" target="_blank" rel="external">다양한 방법</a>으로 수행 할 수 있습니다. 여기서는 프로퍼티 파일을 사용하여 전체 프로젝트의 기본 동작을 변경합니다.</p>
<p><strong>src/test/resources/junit-platform.properties</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">junit.jupiter.testinstance.lifecycle.default = per_class</div></pre></td></tr></table></figure>
<p>이 구성(Configuration)을 사용하면 위의 <code>IntegrationTest</code>의 업데이트된 버전과 같은 일반 메서드에서 <code>@BeforeAll</code> 및 <code>@AfterAll</code> Annotation을 사용할 수 있습니다.</p>
<p><strong>src/test/kotlin/blog/IntegrationTests.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ExtendWith(SpringExtension::class)</span></div><div class="line"><span class="meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegrationTests</span></span>(<span class="meta">@Autowired</span> <span class="keyword">val</span> restTemplate: TestRestTemplate) &#123;</div><div class="line"></div><div class="line">  <span class="meta">@BeforeAll</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"&gt;&gt; Setup"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> `Assert blog page title, content and status code`<span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"&gt;&gt; Assert blog page title, content and status code"</span>)</div><div class="line">    <span class="keyword">val</span> entity = restTemplate.getForEntity&lt;String&gt;(<span class="string">"/"</span>)</div><div class="line">    assertThat(entity.statusCode).isEqualTo(HttpStatus.OK)</div><div class="line">    assertThat(entity.body).contains(<span class="string">"&lt;h1&gt;Blog&lt;/h1&gt;"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> `Assert article page title, content and status code`<span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"&gt;&gt; TODO"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@AfterAll</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">teardown</span><span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"&gt;&gt; Tear down"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="JPA를-이용한-Persistence"><a href="#JPA를-이용한-Persistence" class="headerlink" title="JPA를 이용한 Persistence"></a>JPA를 이용한 Persistence</h2><p>Kotlin 불변 클래스(Immutable class)를 사용하려면 <a href="https://kotlinlang.org/docs/reference/compiler-plugins.html#jpa-support" target="_blank" rel="external">Kotlin JPA 플러그인</a>을 활성화해야합니다. <code>@Entity</code>, <code>@MappedSuperclass</code> 또는 <code>@Embeddable</code>로 Annotation된 모든 클래스에 대해 파라미터가 없는 생성자를 생성합니다.</p>
<p><strong>build.gradle</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">  dependencies &#123;</div><div class="line">    classpath(&quot;org.jetbrains.kotlin:kotlin-noarg:$&#123;kotlinVersion&#125;&quot;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">apply plugin: &apos;kotlin-jpa&apos;</div></pre></td></tr></table></figure></p>
<p>그런 다음 데이터를 보유하고 <code>equals()</code>, <code>hashCode()</code>, <code>toString()</code>, <code>componentN()</code> 함수 및 <code>copy()</code>를 자동으로 제공하도록 설계된 Kotlin <a href="https://kotlinlang.org/docs/reference/data-classes.html" target="_blank" rel="external">데이터 클래스(Data class)</a>를 사용하여 모델을 만듭니다.</p>
<p><strong>src/main/kotlin/blog/Model.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span></span>(</div><div class="line">    <span class="keyword">val</span> title: String,</div><div class="line">    <span class="keyword">val</span> headline: String,</div><div class="line">    <span class="keyword">val</span> content: String,</div><div class="line">    <span class="meta">@ManyToOne</span> <span class="meta">@JoinColumn</span> <span class="keyword">val</span> author: User,</div><div class="line">    <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="keyword">val</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span>,</div><div class="line">    <span class="keyword">val</span> addedAt: LocalDateTime = LocalDateTime.now())</div><div class="line"></div><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</div><div class="line">    <span class="meta">@Id</span> <span class="keyword">val</span> login: String,</div><div class="line">    <span class="keyword">val</span> firstname: String,</div><div class="line">    <span class="keyword">val</span> lastname: String,</div><div class="line">    <span class="keyword">val</span> description: String? = <span class="literal">null</span>)</div></pre></td></tr></table></figure></p>
<p>기본 값이 있는 선택적 파라미터는 위치가 있는 파라미터를 사용할 때 생략 할 수 있도록 마지막 위치에 정의됩니다 (Kotlin은 <a href="https://kotlinlang.org/docs/reference/functions.html#named-arguments" target="_blank" rel="external">이름이 있는 파라미터</a>도 지원함). Kotlin에서 동일한 파일에서 간결한 클래스 선언을 그룹화하는 것은 이례적인 일이 아닙니다.</p>
<p>Spring Data JPA Repository를 다음과 같이 선언합니다.</p>
<p><strong>src/main/kotlin/blog/Repositories.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ArticleRepository</span> : <span class="type">CrudRepository</span>&lt;<span class="type">Article, Long</span>&gt; </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">findAllByOrderByAddedAtDesc</span><span class="params">()</span></span>: Iterable&lt;Article&gt;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> : <span class="type">CrudRepository</span>&lt;<span class="type">User, String</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>그리고 JPA 테스트를 작성하여 기본 유스 케이스가 예상대로 작동하는지 확인합니다.</p>
<p><strong>src/test/kotlin/blog/RepositoriesTests.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ExtendWith(SpringExtension::class)</span></div><div class="line"><span class="meta">@DataJpaTest</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RepositoriesTests</span></span>(<span class="meta">@Autowired</span> <span class="keyword">val</span> entityManager: TestEntityManager,</div><div class="line">                        <span class="meta">@Autowired</span> <span class="keyword">val</span> userRepository: UserRepository,</div><div class="line">                        <span class="meta">@Autowired</span> <span class="keyword">val</span> articleRepository: ArticleRepository) &#123;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> `When findById then return Article`<span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> juergen = User(<span class="string">"springjuergen"</span>, <span class="string">"Juergen"</span>, <span class="string">"Hoeller"</span>)</div><div class="line">    entityManager.persist(juergen)</div><div class="line">    <span class="keyword">val</span> article = Article(<span class="string">"Spring Framework 5.0 goes GA"</span>, <span class="string">"Dear Spring community ..."</span>, <span class="string">"Lorem ipsum"</span>, juergen)</div><div class="line">    entityManager.persist(article)</div><div class="line">    entityManager.flush()</div><div class="line"></div><div class="line">    <span class="keyword">val</span> found = articleRepository.findById(article.id!!)</div><div class="line"></div><div class="line">    assertThat(found.<span class="keyword">get</span>()).isEqualTo(article)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> `When findById then return User`<span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> juergen = User(<span class="string">"springjuergen"</span>, <span class="string">"Juergen"</span>, <span class="string">"Hoeller"</span>)</div><div class="line">    entityManager.persist(juergen)</div><div class="line">    entityManager.flush()</div><div class="line"></div><div class="line">    <span class="keyword">val</span> found = userRepository.findById(juergen.login)</div><div class="line"></div><div class="line">    assertThat(found.<span class="keyword">get</span>()).isEqualTo(juergen)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="나만의-확장-기능-만들기"><a href="#나만의-확장-기능-만들기" class="headerlink" title="나만의 확장 기능 만들기"></a>나만의 확장 기능 만들기</h2><p>Java에서 추상 메서드로 util 클래스를 사용하지만, Kotlin에서는 Kotlin 확장을 통해 제공하는 것이 일반적입니다. 여기서 영어 날짜 형식으로 텍스트를 생성하기 위해 기존 <code>LocalDateTime</code> 타입에 <code>format()</code> 함수를 추가 할 것입니다.</p>
<p><strong>src/main/kotlin/blog/Extensions.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> LocalDateTime.<span class="title">format</span><span class="params">()</span></span> = <span class="keyword">this</span>.format(englishDateFormatter)</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">val</span> daysLookup = (<span class="number">1.</span><span class="number">.31</span>).associate &#123; it.toLong() to getOrdinal(it) &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">val</span> englishDateFormatter = DateTimeFormatterBuilder()</div><div class="line">    .appendPattern(<span class="string">"MMMM"</span>)</div><div class="line">    .appendLiteral(<span class="string">" "</span>)</div><div class="line">    .appendText(ChronoField.DAY_OF_MONTH, daysLookup)</div><div class="line">    .appendLiteral(<span class="string">" "</span>)</div><div class="line">    .appendPattern(<span class="string">"yyyy"</span>)</div><div class="line">    .toFormatter(Locale.ENGLISH)</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getOrdinal</span><span class="params">(n: <span class="type">Int</span>)</span></span> = <span class="keyword">when</span> &#123;</div><div class="line">  n <span class="keyword">in</span> <span class="number">11.</span><span class="number">.13</span> -&gt; <span class="string">"<span class="subst">$&#123;n&#125;</span>th"</span></div><div class="line">  n % <span class="number">10</span> == <span class="number">1</span> -&gt; <span class="string">"<span class="subst">$&#123;n&#125;</span>st"</span></div><div class="line">  n % <span class="number">10</span> == <span class="number">2</span> -&gt; <span class="string">"<span class="subst">$&#123;n&#125;</span>nd"</span></div><div class="line">  n % <span class="number">10</span> == <span class="number">3</span> -&gt; <span class="string">"<span class="subst">$&#123;n&#125;</span>rd"</span></div><div class="line">  <span class="keyword">else</span> -&gt; <span class="string">"<span class="subst">$&#123;n&#125;</span>th"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>다음 섹션에서 이 확장을 활용할 것입니다.</p>
<h2 id="블로그-엔진-구현하기"><a href="#블로그-엔진-구현하기" class="headerlink" title="블로그 엔진 구현하기"></a>블로그 엔진 구현하기</h2><p>우리가 구현중인 블로그 엔진은 Markdown을 HTML로 렌더링해야하며, 이를 위해 <code>commonmark</code> 라이브러리를 사용할 것입니다.</p>
<p><strong>build.gradle</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">  compile(&quot;com.atlassian.commonmark:commonmark:0.11.0&quot;)</div><div class="line">  compile(&quot;com.atlassian.commonmark:commonmark-ext-autolink:0.11.0&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://kotlinlang.org/docs/reference/lambdas.html#function-types" target="_blank" rel="external">Kotlin 함수 타입</a>을 활용하는 <code>MarkdownConverter</code> Bean을 소개합니다.</p>
<p><strong>src/main/kotlin/blog/MarkdownConverter.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarkdownConverter</span> : <span class="type"></span></span>(String?) -&gt; String &#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> parser = Parser.builder().extensions(listOf(AutolinkExtension.create())).build()</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> renderer = HtmlRenderer.builder().build()</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(input: <span class="type">String</span>?)</span></span>: String &#123;</div><div class="line">    <span class="keyword">if</span> (input == <span class="literal">null</span> || input == <span class="string">""</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">""</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> renderer.render(parser.parse(input))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>그리고 HTML을 렌더링 할 수 있는 커스텀 <code>Mustache.Compiler</code> Bean을 제공합니다.</p>
<p><strong>src/main/kotlin/blog/BlogApplication.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogApplication</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">mustacheCompiler</span><span class="params">(loader: <span class="type">Mustache</span>.<span class="type">TemplateLoader</span>?)</span></span> =</div><div class="line">      Mustache.compiler().escapeHTML(<span class="literal">false</span>).withLoader(loader)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Null을 허용하는 <code>Mustache.TemplateLoader?</code>는 선택적인 Bean이라는 것을 의미합니다(JPA 전용 테스트를 실행할 때 실패를 피하기 위해서).</p>
<p>“Blog” Mustache 템플릿을 업데이트합니다.</p>
<p><strong>src/main/resources/templates/blog.mustache</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;&gt; header&#125;&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"articles"</span>&gt;</span></div><div class="line"></div><div class="line">  &#123;&#123;#articles&#125;&#125;</div><div class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"article-header"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"article-title"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/article/&#123;&#123;id&#125;&#125;"</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-meta"</span>&gt;</span>By  <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123;author.firstname&#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>, on <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123;addedAt&#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-description"</span>&gt;</span></div><div class="line">        &#123;&#123;headline&#125;&#125;</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></div><div class="line">  &#123;&#123;/articles&#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">&#123;&#123;&gt; footer&#125;&#125;</div></pre></td></tr></table></figure>
<p>그리고 우리는 새로운 “article”를 만듭니다.</p>
<p><strong>src/main/resources/templates/article.mustache</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;&gt; header&#125;&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"article"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"article-header"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"article-title"</span>&gt;</span>&#123;&#123;article.title&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"article-meta"</span>&gt;</span>By  <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123;article.author.firstname&#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>, on <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123;article.addedAt&#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-description"</span>&gt;</span></div><div class="line">    &#123;&#123;article.headline&#125;&#125;</div><div class="line"></div><div class="line">    &#123;&#123;article.content&#125;&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></div><div class="line"></div><div class="line">&#123;&#123;&gt; footer&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>렌더링된 마크 다운 및 형식이 지정된 날짜로 블로그 및 기사 페이지를 렌더링하기 위해 <code>HtmlController</code>를 업데이트합니다. <code>ArticleRepository</code> 및 <code>MarkdownConverter</code> 생성자 파라미터는 <code>HtmlController</code>가 단일 생성자 (암시적 <code>@Autowired</code>)를 가지고 있기 때문에 자동으로 Autowired 됩니다.</p>
<p><strong>src/main/kotlin/blog/HtmlController.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlController</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> repository: ArticleRepository,</div><div class="line">           <span class="keyword">private</span> <span class="keyword">val</span> markdownConverter: MarkdownConverter) &#123;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping(<span class="meta-string">"/"</span>)</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">blog</span><span class="params">(model: <span class="type">Model</span>)</span></span>: String &#123;</div><div class="line">      model[<span class="string">"title"</span>] = <span class="string">"Blog"</span></div><div class="line">      model[<span class="string">"articles"</span>] = repository.findAllByOrderByAddedAtDesc().map &#123; it.render() &#125;</div><div class="line">      <span class="keyword">return</span> <span class="string">"blog"</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping(<span class="meta-string">"/article/&#123;id&#125;"</span>)</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">article</span><span class="params">(<span class="meta">@PathVariable</span> id: <span class="type">Long</span>, model: <span class="type">Model</span>)</span></span>: String &#123;</div><div class="line">      <span class="keyword">val</span> article = repository</div><div class="line">          .findById(id)</div><div class="line">          .orElseThrow &#123; IllegalArgumentException(<span class="string">"Wrong article id provided"</span>) &#125;</div><div class="line">          .render()</div><div class="line">      model[<span class="string">"title"</span>] = article.title</div><div class="line">      model[<span class="string">"article"</span>] = article</div><div class="line">      <span class="keyword">return</span> <span class="string">"article"</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fun</span> Article.<span class="title">render</span><span class="params">()</span></span> = RenderedArticle(</div><div class="line">        title,</div><div class="line">        markdownConverter.invoke(headline),</div><div class="line">        markdownConverter.invoke(content),</div><div class="line">        author,</div><div class="line">        id,</div><div class="line">        addedAt.format()</div><div class="line">    )</div><div class="line"></div><div class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderedArticle</span></span>(</div><div class="line">        <span class="keyword">val</span> title: String,</div><div class="line">        <span class="keyword">val</span> headline: String,</div><div class="line">        <span class="keyword">val</span> content: String,</div><div class="line">        <span class="keyword">val</span> author: User,</div><div class="line">        <span class="keyword">val</span> id: <span class="built_in">Long</span>?,</div><div class="line">        <span class="keyword">val</span> addedAt: String)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>BlogApplication</code>에 데이터 초기화를 추가합니다.</p>
<p><strong>src/main/kotlin/blog/BlogApplication.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">databaseInitializer</span><span class="params">(userRepository: <span class="type">UserRepository</span>,</span></span></div><div class="line">                        articleRepository: <span class="type">ArticleRepository</span>) = CommandLineRunner &#123;</div><div class="line">  <span class="keyword">val</span> smaldini = User(<span class="string">"smaldini"</span>, <span class="string">"Stéphane"</span>, <span class="string">"Maldini"</span>)</div><div class="line">  userRepository.save(smaldini)</div><div class="line"></div><div class="line">  articleRepository.save(Article(</div><div class="line">      <span class="string">"Reactor Bismuth is out"</span>,</div><div class="line">      <span class="string">"Lorem ipsum"</span>,</div><div class="line">      <span class="string">"dolor **sit** amet https://projectreactor.io/"</span>,</div><div class="line">      smaldini,</div><div class="line">      <span class="number">1</span></div><div class="line">  ))</div><div class="line">  articleRepository.save(Article(</div><div class="line">      <span class="string">"Reactor Aluminium has landed"</span>,</div><div class="line">      <span class="string">"Lorem ipsum"</span>,</div><div class="line">      <span class="string">"dolor **sit** amet https://projectreactor.io/"</span>,</div><div class="line">      smaldini,</div><div class="line">      <span class="number">2</span></div><div class="line">  ))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>그리고 통합 테스트(Integration test)도 업데이트합니다.</p>
<p><strong>src/test/kotlin/blog/IntegrationTests.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ExtendWith(SpringExtension::class)</span></div><div class="line"><span class="meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegrationTests</span></span>(<span class="meta">@Autowired</span> <span class="keyword">val</span> restTemplate: TestRestTemplate) &#123;</div><div class="line"></div><div class="line">  <span class="meta">@BeforeAll</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"&gt;&gt; Setup"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> `Assert blog page title, content and status code`<span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"&gt;&gt; Assert blog page title, content and status code"</span>)</div><div class="line">    <span class="keyword">val</span> entity = restTemplate.getForEntity&lt;String&gt;(<span class="string">"/"</span>)</div><div class="line">    assertThat(entity.statusCode).isEqualTo(HttpStatus.OK)</div><div class="line">    assertThat(entity.body).contains(<span class="string">"&lt;h1&gt;Blog&lt;/h1&gt;"</span>, <span class="string">"Reactor"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> `Assert article page title, content and status code`<span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"&gt;&gt; Assert article page title, content and status code"</span>)</div><div class="line">    <span class="keyword">val</span> entity = restTemplate.getForEntity&lt;String&gt;(<span class="string">"/article/2"</span>)</div><div class="line">    assertThat(entity.statusCode).isEqualTo(HttpStatus.OK)</div><div class="line">    assertThat(entity.body).contains(<span class="string">"Reactor Aluminium has landed"</span>,,</div><div class="line">        <span class="string">"&lt;a href=\"https://projectreactor.io/\"&gt;https://projectreactor.io/&lt;/a&gt;"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@AfterAll</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">teardown</span><span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"&gt;&gt; Tear down"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>웹 애플리케이션을 시작(또는 재시작)하고 <code>http://localhost:8080/</code>으로 이동하면 클릭 가능한 링크가있는 기사 목록이 나타나 특정 기사를 볼 수 있습니다.</p>
<h2 id="HTTP-API-노출"><a href="#HTTP-API-노출" class="headerlink" title="HTTP API 노출"></a>HTTP API 노출</h2><p><code>@RestController</code> Annotation이 달린 컨트롤러를 통해 HTTP API를 구현합니다.</p>
<p><strong>src/main/kotlin/blog/HttpApi.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/api/article"</span>)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleController</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> repository: ArticleRepository,</div><div class="line">            <span class="keyword">private</span> <span class="keyword">val</span> markdownConverter: MarkdownConverter) &#123;</div><div class="line"></div><div class="line">  <span class="meta">@GetMapping(<span class="meta-string">"/"</span>)</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">findAll</span><span class="params">()</span></span> = repository.findAllByOrderByAddedAtDesc()</div><div class="line"></div><div class="line">  <span class="meta">@GetMapping(<span class="meta-string">"/&#123;id&#125;"</span>)</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">findOne</span><span class="params">(<span class="meta">@PathVariable</span> id: <span class="type">Long</span>, <span class="meta">@RequestParam</span> converter: <span class="type">String</span>?)</span></span> = <span class="keyword">when</span> (converter) &#123;</div><div class="line">    <span class="string">"markdown"</span> -&gt; repository.findById(id).map &#123; it.copy(</div><div class="line">        headline = markdownConverter.invoke(it.headline),</div><div class="line">        content = markdownConverter.invoke(it.content)) &#125;</div><div class="line">    <span class="literal">null</span> -&gt; repository.findById(id)</div><div class="line">    <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Only markdown converter is supported"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/api/user"</span>)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> repository: UserRepository) &#123;</div><div class="line"></div><div class="line">  <span class="meta">@GetMapping(<span class="meta-string">"/"</span>)</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">findAll</span><span class="params">()</span></span> = repository.findAll()</div><div class="line"></div><div class="line">  <span class="meta">@GetMapping(<span class="meta-string">"/&#123;login&#125;"</span>)</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">findOne</span><span class="params">(<span class="meta">@PathVariable</span> login: <span class="type">String</span>)</span></span> = repository.findById(login)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>테스트의 경우 통합 테스트 대신 <code>@WebMvcTest</code> 및 <code>@MockBean</code>을 사용하여 웹 레이어만 테스트합니다.</p>
<p><strong>src/test/kotlin/blog/HttpApiTests.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ExtendWith(SpringExtension::class)</span></div><div class="line"><span class="meta">@WebMvcTest</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpApiTests</span></span>(<span class="meta">@Autowired</span> <span class="keyword">val</span> mockMvc: MockMvc) &#123;</div><div class="line"></div><div class="line">  <span class="meta">@MockBean</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> userRepository: UserRepository</div><div class="line"></div><div class="line">  <span class="meta">@MockBean</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> articleRepository: ArticleRepository</div><div class="line"></div><div class="line">  <span class="meta">@MockBean</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> markdownConverter: MarkdownConverter</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> `List articles`<span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> juergen = User(<span class="string">"springjuergen"</span>, <span class="string">"Juergen"</span>, <span class="string">"Hoeller"</span>)</div><div class="line">    <span class="keyword">val</span> spring5Article = Article(<span class="string">"Spring Framework 5.0 goes GA"</span>, <span class="string">"Dear Spring community ..."</span>, <span class="string">"Lorem ipsum"</span>, juergen, <span class="number">1</span>)</div><div class="line">    <span class="keyword">val</span> spring43Article = Article(<span class="string">"Spring Framework 4.3 goes GA"</span>, <span class="string">"Dear Spring community ..."</span>, <span class="string">"Lorem ipsum"</span>, juergen, <span class="number">2</span>)</div><div class="line">    whenever(articleRepository.findAllByOrderByAddedAtDesc()).thenReturn(listOf(spring5Article, spring43Article))</div><div class="line">    whenever(markdownConverter.invoke(any())).thenAnswer &#123; it.arguments[<span class="number">0</span>] &#125;</div><div class="line">    mockMvc.perform(<span class="keyword">get</span>(<span class="string">"/api/article/"</span>).accept(MediaType.APPLICATION_JSON))</div><div class="line">        .andExpect(status().isOk)</div><div class="line">        .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))</div><div class="line">        .andExpect(jsonPath(<span class="string">"\$.[0].author.login"</span>).value(juergen.login))</div><div class="line">        .andExpect(jsonPath(<span class="string">"\$.[0].id"</span>).value(spring5Article.id!!))</div><div class="line">        .andExpect(jsonPath(<span class="string">"\$.[1].author.login"</span>).value(juergen.login))</div><div class="line">        .andExpect(jsonPath(<span class="string">"\$.[1].id"</span>).value(spring43Article.id!!))</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> `List users`<span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> juergen = User(<span class="string">"springjuergen"</span>, <span class="string">"Juergen"</span>, <span class="string">"Hoeller"</span>)</div><div class="line">    <span class="keyword">val</span> smaldini = User(<span class="string">"smaldini"</span>, <span class="string">"Stéphane"</span>, <span class="string">"Maldini"</span>)</div><div class="line">    whenever(userRepository.findAll()).thenReturn(listOf(juergen, smaldini))</div><div class="line">    mockMvc.perform(<span class="keyword">get</span>(<span class="string">"/api/user/"</span>).accept(MediaType.APPLICATION_JSON))</div><div class="line">        .andExpect(status().isOk)</div><div class="line">        .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))</div><div class="line">        .andExpect(jsonPath(<span class="string">"\$.[0].login"</span>).value(juergen.login))</div><div class="line">        .andExpect(jsonPath(<span class="string">"\$.[1].login"</span>).value(smaldini.login))</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>when</code>은 예약된 Kotlin 키워드이므로, <code>whenever</code> 별칭을 제공하는 <a href="https://github.com/nhaarman/mockito-kotlin/" target="_blank" rel="external">mockito-kotlin</a> 라이브러리 (이스케이프된 <code>`when` </code>도 사용 가능)를 사용하기로 결정한 이유입니다. 이를 사용하려면 다음 종속성을 추가하십시오.</p>
<p><strong>build.gradle</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">  testCompile(&quot;com.nhaarman:mockito-kotlin:1.5.0&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>$</code>는 문자열 보간(Interpolation)에 사용되기 때문에 문자열에서 이스케이프 해야합니다. <code>@MockBean</code> JUnit 5 파라미터 리졸버(Parameter resolver)가 <a href="https://github.com/spring-projects/spring-boot/issues/13113" target="_blank" rel="external">아직 없으므로</a> 지금은 <code>lateinit var</code>를 사용해야합니다.</p>
<h2 id="Configuration-properties"><a href="#Configuration-properties" class="headerlink" title="Configuration properties"></a>Configuration properties</h2><p>애플리케이션 프로퍼티를 관리하는 가장 좋은 방법은 <code>@ConfigurationProperties</code>를 활용하는 것입니다. 변경할 수 없는 프로퍼티는 <a href="https://github.com/spring-projects/spring-boot/issues/8762" target="_blank" rel="external">아직 지원되지 않지만</a> Null이 허용되지 않는 프로퍼티를 처리해야하는 경우 <code>lateinit var</code>을 사용할 수 있습니다.</p>
<p><strong>src/main/kotlin/blog/BlogProperties.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ConfigurationProperties(<span class="meta-string">"blog"</span>)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogProperties</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> title: String</div><div class="line">  <span class="keyword">val</span> banner = Banner()</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Banner</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> title: String? = <span class="literal">null</span></div><div class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> content: String</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>그런 다음 <code>BlogApplication</code> 수준에서 사용하도록 설정합니다.</p>
<p><strong>src/main/kotlin/blog/BlogApplication.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableConfigurationProperties(BlogProperties::class)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogApplication</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>IDE에서 이러한 사용자 정의 프로퍼티를 인식하기 위해 <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#configuration-metadata-annotation-processor" target="_blank" rel="external">자신의 메타 데이터</a>를 생성하려면 <code>spring-boot-configuration-processor</code> 종속성을 사용하여 다음과 같이  <a href="https://kotlinlang.org/docs/reference/kapt.html" target="_blank" rel="external">Kapt가 설정되어야</a>합니다.</p>
<p><strong>build.gradle</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;kotlin-kapt&apos;</div><div class="line">dependencies &#123;</div><div class="line">  kapt(&quot;org.springframework.boot:spring-boot-configuration-processor&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>IntelliJ IDEA에서 :</p>
<ul>
<li>메뉴 File | Settings | Plugins | Spring Boot 에서 Spring Boot plugin이 활성화되어 있는지 확인하십시오.</li>
<li>Annotation 처리를 위해 메뉴의 File | Settings | Build, Execution, Deployement | Compiler | Annotation Processors | Enable annotation processing 을 활성화 합니다.</li>
<li><a href="https://youtrack.jetbrains.com/issue/KT-15040" target="_blank" rel="external">Kapt가 아직 IDEA에 통합되지 않았으므로</a> 메타 데이터를 생성하려면 <code>./gradlew kaptKotlin</code> 명령을 수동으로 실행해야합니다.</li>
</ul>
<p><code>application.properties</code>(Autocomplete, Validation 등)를 편집 할 때 사용자 정의 프로퍼티를 인식해야합니다.</p>
<p><strong>src/main/resources/application.properties</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">blog.title=Blog</div><div class="line">blog.banner.title=Warning</div><div class="line">blog.banner.content=The blog will be down tomorrow.</div></pre></td></tr></table></figure></p>
<p>그에 따라 템플릿과 컨트롤러를 수정합니다.</p>
<p><strong>src/main/resources/templates/blog.mustache</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;&gt; header&#125;&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"articles"</span>&gt;</span></div><div class="line"></div><div class="line">  &#123;&#123;#banner.title&#125;&#125;</div><div class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"banner"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"banner-title"</span>&gt;</span>&#123;&#123;banner.title&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"banner-content"</span>&gt;</span></div><div class="line">      &#123;&#123;banner.content&#125;&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></div><div class="line">  &#123;&#123;/banner.title&#125;&#125;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">&#123;&#123;&gt; footer&#125;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>src/main/kotlin/blog/HtmlController.kt</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlController</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> repository: ArticleRepository,</div><div class="line">           <span class="keyword">private</span> <span class="keyword">val</span> markdownConverter: MarkdownConverter,</div><div class="line">           <span class="keyword">private</span> <span class="keyword">val</span> properties: BlogProperties) &#123;</div><div class="line"></div><div class="line">  <span class="meta">@GetMapping(<span class="meta-string">"/"</span>)</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">blog</span><span class="params">(model: <span class="type">Model</span>)</span></span>: String &#123;</div><div class="line">    model[<span class="string">"title"</span>] = properties.title</div><div class="line">    model[<span class="string">"banner"</span>] = properties.banner</div><div class="line">    model[<span class="string">"articles"</span>] = repository.findAllByOrderByAddedAtDesc().map &#123; it.render() &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">"blog"</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>웹 애플리케이션을 다시 시작하고 <code>http://localhost:8080/</code>을 새로 고치면 블로그 홈페이지에 배너가 나타납니다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>이제 이 예제 Kotlin 블로그 애플리케이션을 빌드했습니다. 소스 코드는 <a href="https://github.com/spring-guides/tut-spring-boot-kotlin" target="_blank" rel="external">Github에서 사용</a>할 수 있습니다. 특정 기능에 대한 자세한 내용은 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/languages.html#kotlin" target="_blank" rel="external">Spring Framework</a> 및 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-kotlin.html" target="_blank" rel="external">Spring Boot</a> 참고 문서를 읽어 보십시오.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 Spring Boot 가이드 문서를 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article <a href="http://spring.io/guides/tutorials/spring-boot-kotlin/" target="_blank" rel="external">Building web applications with Spring Boot and Kotlin</a></p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-Boot와-Kotlin으로-웹-애플리케이션-구축하기&quot;&gt;&lt;a href=&quot;#Spring-Boot와-Kotlin으로-웹-애플리케이션-구축하기&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot와 Kotlin으로 
    
    </summary>
    
      <category term="Kotlin" scheme="http://infoscis.github.io/categories/Kotlin/"/>
    
      <category term="SpringBoot" scheme="http://infoscis.github.io/categories/Kotlin/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://infoscis.github.io/tags/SpringBoot/"/>
    
      <category term="Kotlin" scheme="http://infoscis.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Angular Observable &amp; RxJS</title>
    <link href="http://infoscis.github.io/2018/08/08/angular-observables-and-rxjs/"/>
    <id>http://infoscis.github.io/2018/08/08/angular-observables-and-rxjs/</id>
    <published>2018-08-08T14:38:02.000Z</published>
    <updated>2018-08-08T14:44:11.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h1><p><em>Observable</em>은 Application의 Publisher와 Subscriber 사이의 메시지 전달을 지원하는 기능을 제공합니다. <em>Observable</em>은 이벤트 처리, 비동기 프로그래밍 및 다중 값 처리와 관련된 다른 기술에 비해 상당한 이점을 제공합니다.</p>
<p><em>Observable</em>은 선언적입니다. 즉, 여러분이 값을 게시하는 함수를 정의해도, Consumer가 구독 하기전까지 실행되지 않습니다. 그리고 구독된 Consumer는 함수가 완료되거나 구독을 취소 할 때까지 알림을 받습니다.</p>
<p><em>Observable</em>은 컨텍스트에 따라 리터럴(Literal), 메시지(Message) 또는 이벤트(Event)등 여러 값을 전달할 수 있습니다. 값을 수신하기 위한 API는 값이 동기적 또는 비동기적으로 전달되는지 여부에 관계없이 동일합니다. 설정 및 해체 로직은 모두 <em>Observable</em>에 의해 처리되고, 응용 프로그램에서는 값을 소비하기 위해 구독하고, 완료되면 구독을 취소하는 것에 신경을 써야 합니다. Stream이 Keystroke인지, HTTP 응답인지, 인터벌 타이머인지 여부와 관계없이 값을 구독하고 멈추는 인터페이스는 동일합니다.</p>
<p>이러한 이점 때문에 <em>Observable</em>은 Angular 내에서 광범위하게 사용되며 앱 개발에도 권장됩니다.</p>
<h2 id="기본-사용법-및-용어"><a href="#기본-사용법-및-용어" class="headerlink" title="기본 사용법 및 용어"></a>기본 사용법 및 용어</h2><p>Publisher는 <em>subscriber</em> 함수를 정의하는 <em>Observable</em> 인스턴스를 만듭니다. 이 함수는 Consumer가 <code>subscribe()</code>함수를 호출할 때 실행 됩니다. <em>subscriber</em> 함수는 게시될 값 또는 메시지를 얻거나 생성하는 방법을 정의합니다. </p>
<p>생성한 <em>Observable</em> 객체를 실행하고 알림 수신을 시작하려면 <em>observer</em>를 전달하여 <code>subscribe()</code> 메서드를 호출합니다. <em>observer</em>는 여러분이 수신한 알림을 처리하는 핸드러를 정의한 JavaScript 객체입니다. <code>subscribe()</code> 메서드는 Subscripotion 객체를 반환하는데, 이 객체에는 알림 수신을 중지하기 위해 호출하는 <code>unsubscribe()</code> 메서드가 있습니다.</p>
<p>다음은 Geolocation 업데이트 정보 제공에 <em>Observable</em>을 어떻게 사용할 수 있지 보여줌으로써 기본 사용 모델을 설명하는 예제입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Consumer가 구독할때 Geolocation 변경사항을 수신하는 *Observable*을 생성합니다.</span></div><div class="line"><span class="keyword">const</span> locations = <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// next와 error 콜백을 가져옵니다. 이것은 Consumer가 구독할때 넘겨줍니다.</span></div><div class="line">  <span class="keyword">const</span> &#123;next, error&#125; = observer;</div><div class="line">  <span class="keyword">let</span> watchId;</div><div class="line"> </div><div class="line">  <span class="comment">// 게시할 값을 제공하는 간단한 geolocation API를 확인</span></div><div class="line">  <span class="keyword">if</span> (<span class="string">'geolocation'</span> <span class="keyword">in</span> navigator) &#123;</div><div class="line">    watchId = navigator.geolocation.watchPosition(next, error);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    error(<span class="string">'Geolocation not available'</span>);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// Consumer가 구독을 중지하면 다음 구독을 위해 준비한 데이터를 정리합니다.</span></div><div class="line">  <span class="keyword">return</span> &#123;unsubscribe() &#123; navigator.geolocation.clearWatch(watchId); &#125;&#125;;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 변경사항 수신을 시작하기 위해 subscribe()를 호출합니다.</span></div><div class="line"><span class="keyword">const</span> locationsSubscription = locations.subscribe(&#123;</div><div class="line">  next(position) &#123; <span class="built_in">console</span>.log(<span class="string">'Current Position: '</span>, position); &#125;,</div><div class="line">  error(msg) &#123; <span class="built_in">console</span>.log(<span class="string">'Error Getting Location: '</span>, msg); &#125;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 10초후에 수신을 중지합니다.</span></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; locationsSubscription.unsubscribe(); &#125;, <span class="number">10000</span>);</div></pre></td></tr></table></figure>
<h2 id="Observer-정의"><a href="#Observer-정의" class="headerlink" title="Observer 정의"></a>Observer 정의</h2><p><em>Observable</em> 알람을 수신하기 위한 핸들러는 <code>Observer</code> 인터페이스를 구현합니다. 이것은 <em>Observable</em>이 보낼수 있는 3가지 알람 타입을 처리할 수 있는 콜백 메서드가 정의된 객체입니다.</p>
<table>
<thead>
<tr>
<th></th>
<th>알람 종류</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>next</code></td>
<td>필수. 전달된 각각의 값을 처리하는 핸들러. 실행 시작후 0번 또는 그 이상 호출됩니다.</td>
</tr>
<tr>
<td><code>error</code></td>
<td>선택사항. 오류 알람에 대한 처리 핸들러. 오류로 인해 <em>Observable</em> 인스턴스의 실행이 중지됩니다.</td>
</tr>
<tr>
<td><code>complete</code></td>
<td>선택사항. 실행 완료 알람에 대한 처리 핸들러. 지연된 값은 실행 완료 후에도 계속해서 <code>next</code> 핸들러로 전달될 수 있습니다.</td>
</tr>
</tbody>
</table>
<p><em>Observable</em> 객체는 이러한 핸들러의 조합을 정의할 수 있습니다. 만약 알람 종류에 대한 핸들러를 제공하지 않으면, <em>observer</em>는 해당 종류의 알람을 무시합니다.</p>
<h2 id="구독-Subscribing"><a href="#구독-Subscribing" class="headerlink" title="구독(Subscribing)"></a>구독(Subscribing)</h2><p><code>Observable</code> 인스턴스는 누군가가 구독할 때만 값을 게시 시작합니다. 여러분은 알람을 수신받을 <em>observer</em> 객체를 <code>Observable</code> 인스턴스의 <code>subscribe()</code> 메서드에 넘겨 구독을 시작합니다.</p>
<blockquote>
<p>어떻게 구독(Subscribing)이 작동하는지 보여주기 위해 새로운 <em>Observable</em>을 만듭니다. 새로운 인스턴스를 생성하기 위해 사용할 수 있는 생성자가 있지만, 설명을 위해 <em>Observable</em> 클래스에서 자주 사용하는 간단한 <em>Observable</em>을 만드는 몇가지 정적 메서드를 사용할 수 있습니다.</p>
<ul>
<li>Observable.of(…items)-인수로 제공된 값을 동기적으로 전달하는 <code>Observable</code> 인스턴스를 반환합니다.</li>
<li>Observable.from(iterable)-인수를 <code>Observable</code> 인스턴스로 변경합니다. 일반적으로 이 메서드는 Array를 <em>Observable</em>로 변환할 때 사용합니다.</li>
</ul>
</blockquote>
<p>다음은 수신받은 메시지를 console에 기록하는 간단한 <em>observer</em>를 이용하여 <em>Observable</em>을 생성하고 구독하는 예제입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 값 3개를 발생시키는 간단한 observable 생성</span></div><div class="line"><span class="keyword">const</span> myObservable = Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="comment">// observer 객체 생성</span></div><div class="line"><span class="keyword">const</span> myObserver = &#123;</div><div class="line">  next: <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a next value: '</span> + x),</div><div class="line">  error: <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Observer got an error: '</span> + err),</div><div class="line">  complete: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a complete notification'</span>),</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// observer 객체를 이용해 실행시킴</span></div><div class="line">myObservable.subscribe(myObserver);</div><div class="line"><span class="comment">// Logs:</span></div><div class="line"><span class="comment">// Observer got a next value: 1</span></div><div class="line"><span class="comment">// Observer got a next value: 2</span></div><div class="line"><span class="comment">// Observer got a next value: 3</span></div><div class="line"><span class="comment">// Observer got a complete notification</span></div></pre></td></tr></table></figure>
<p>또는 <code>subscribe()</code> 메서드는 <code>next</code>, <code>error</code> 및 <code>complete</code> 핸들러에 대한 콜백 함수를 인수에서 정의하는 것을 허용합니다. 예를 들어, 다음 <code>subscribe()</code> 호출은 사전 정의된 <em>observer</em>를 지정하여 호출하는 것과 똑같습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myObservable.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a next value: '</span> + x),</div><div class="line">  <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Observer got an error: '</span> + err),</div><div class="line">  <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a complete notification'</span>)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>위의 두가지 방법 모두 <code>next</code>는 필수사항이고, <code>error</code>와 <code>complete</code>는 선택사항입니다.</p>
<p><code>next</code> 메서드는 컨텍스트에 따라 메시지 문자열, 이벤트 객체, 숫자값 또는 구조체를 수신 받을수 있습니다. 일반적으로 우리는 <em>Stream</em>에 의해 <em>Observable</em>로 게시된 데이터를 참조합니다. 모든 타입은 <em>Observable</em>로 표시될 수 있으며, 해당 값은 <em>Stream</em>으로 게시됩니다.</p>
<h2 id="Observable-생성"><a href="#Observable-생성" class="headerlink" title="Observable 생성"></a>Observable 생성</h2><p><code>Observable</code> 생성자를 사용하여 모든 타입의 <em>Observable Stream</em>을 만듭니다. 생성자는 <em>Observable</em>의 <code>subscribe()</code> 메서드가 호출될 때 실행시킬 <em>subscriber</em> 함수를 인수로 받습니다. <em>subscriber</em> 함수는 <em>observer</em> 객체를 받고, <em>observer</em>의 <code>next</code> 메서드에 값을 게시할 수 있습니다.</p>
<p>예를 들어 <code>Observable.of(1, 2, 3)</code>에 해당하는 <em>Observable</em> 객체를 만들려면 다음과 같이할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 이 함수는 subscribe()가 호출될 때 실행됩니다.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequenceSubscriber</span>(<span class="params">observer</span>) </span>&#123;</div><div class="line">  <span class="comment">// 순차적으로 1, 2, 그리고 3 을 전달하 후 완료(complete) 합니다.</span></div><div class="line">  observer.next(<span class="number">1</span>);</div><div class="line">  observer.next(<span class="number">2</span>);</div><div class="line">  observer.next(<span class="number">3</span>);</div><div class="line">  observer.complete();</div><div class="line"> </div><div class="line">  <span class="comment">// 값이 순차적으로 전달되기 때문에 unsubscribe 함수는 아무것도 할 필요가 없습니다.</span></div><div class="line">  <span class="keyword">return</span> &#123;unsubscribe() &#123;&#125;&#125;;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 위의 시퀀스를 전달할 새로운 Observable을 생성합니다.</span></div><div class="line"><span class="keyword">const</span> sequence = <span class="keyword">new</span> Observable(sequenceSubscriber);</div><div class="line"> </div><div class="line"><span class="comment">// Observable을 실행 시키고 각 알람의 결과를 출력합니다.</span></div><div class="line">sequence.subscribe(&#123;</div><div class="line">  next(num) &#123; <span class="built_in">console</span>.log(num); &#125;,</div><div class="line">  complete() &#123; <span class="built_in">console</span>.log(<span class="string">'Finished sequence'</span>); &#125;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// Logs:</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// 3</span></div><div class="line"><span class="comment">// Finished sequence</span></div></pre></td></tr></table></figure>
<p>이 예를 좀 더 발전시키기 위해, 우리는 이벤트를 게시하는 <em>Observable</em>을 생성할 수 있습니다. 이 예제에서 <em>subscriber</em>함수가 인라인으로 정의 됩니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fromEvent</span>(<span class="params">target, eventName</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> handler = <span class="function">(<span class="params">e</span>) =&gt;</span> observer.next(e);</div><div class="line"> </div><div class="line">    <span class="comment">// target에 Event 핸들러를 붙입니다.</span></div><div class="line">    target.addEventListener(eventName, handler);</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="comment">// target에서 이벤트 핸들러를 제거합니다.</span></div><div class="line">      target.removeEventListener(eventName, handler);</div><div class="line">    &#125;;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이제 이 함수를 keydown 이벤트를 게시하는 <em>Observable</em>을 생성하는데 사용할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ESC_KEY = <span class="number">27</span>;</div><div class="line"><span class="keyword">const</span> nameInput = <span class="built_in">document</span>.getElementById(<span class="string">'name'</span>) <span class="keyword">as</span> HTMLInputElement;</div><div class="line"></div><div class="line"><span class="keyword">const</span> subscription = fromEvent(nameInput, <span class="string">'keydown'</span>)</div><div class="line">  .subscribe(<span class="function">(<span class="params">e: KeyboardEvent</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (e.keyCode === ESC_KEY) &#123;</div><div class="line">      nameInput.value = <span class="string">''</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<h2 id="여러-Comsumer에게-동시에-보내기-Multicasting"><a href="#여러-Comsumer에게-동시에-보내기-Multicasting" class="headerlink" title="여러 Comsumer에게 동시에 보내기(Multicasting)"></a>여러 Comsumer에게 동시에 보내기(Multicasting)</h2><p>일반적인 <em>Observable</em> 생성은, 구독하는 각각 <em>observer</em>에 대해 독립적으로 실행 됩니다. <em>observer</em>가 구독할 때 <em>Observable</em>은 이벤트 핸들러를 연결하고 그 <em>observer</em>에 값을 전달합니다. 두 번째 <em>observer</em>가 구독하면 <em>Observable</em>은 새로운 이벤트 핸들러에 연결하고 별도의 실행으로 두 번째 <em>observer</em>에 값을 전달합니다.</p>
<p>Document 객체에 대한 클릭을 <em>Observable</em>하는 경우와 같이 각 <em>subscriber</em>가 독립된 실행으로 시작하는 대신에 이미 값이 발행되고 있다고 할지라도 각 구독자가 같은 값을 갖기를 원할 수도 있습니다.</p>
<p><em>Multicasting</em>은 단일 실행으로 여러 구독자 목록에 브로드 캐스트하는 기능입니다. <em>Multicasting observable</em>을 활용하면 Document에 여러개의 수신자(Listener)를 등록할 필요가 없고, 첫 번째 수신자(Listener)를 재사용하여 각 구독자에 값을 보냅니다.</p>
<p><em>Observable</em>을 생성할 때 <em>Observable</em>을 어떻게 사용 할지, 그리고 값을 Multicast 할지 말지를 결정합니다.</p>
<p>아래의 예제는 1부터 3까지 카운트 하며, 각 숫자가 발행된 후 1초가 지연됩니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequenceSubscriber</span>(<span class="params">observer</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">  <span class="keyword">let</span> timeoutId;</div><div class="line"> </div><div class="line">  <span class="comment">// 배열 끝에 도달 할 때까지 초당 하나의 값을 게시하는 숫자 배열을 따라 실행합니다.</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSequence</span>(<span class="params">arr, idx</span>) </span>&#123;</div><div class="line">    timeoutId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      observer.next(arr[idx]);</div><div class="line">      <span class="keyword">if</span> (idx === arr.length - <span class="number">1</span>) &#123;</div><div class="line">        observer.complete();</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        doSequence(arr, idx++);</div><div class="line">      &#125;</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  doSequence(seq, <span class="number">0</span>);</div><div class="line"> </div><div class="line">  <span class="comment">// Unsubscribe 할때 timeout을 취소 합니다.</span></div><div class="line">  <span class="keyword">return</span> &#123;unsubscribe() &#123;</div><div class="line">    clearTimeout(timeoutId);</div><div class="line">  &#125;&#125;;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 위에 정의한 시퀀스를 전달하는 Observable을 새로 생성합니다.</span></div><div class="line"><span class="keyword">const</span> sequence = <span class="keyword">new</span> Observable(sequenceSubscriber);</div><div class="line"> </div><div class="line">sequence.subscribe(&#123;</div><div class="line">  next(num) &#123; <span class="built_in">console</span>.log(num); &#125;,</div><div class="line">  complete() &#123; <span class="built_in">console</span>.log(<span class="string">'Finished sequence'</span>); &#125;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 출력 결과:</span></div><div class="line"><span class="comment">// (at 1 second): 1</span></div><div class="line"><span class="comment">// (at 2 seconds): 2</span></div><div class="line"><span class="comment">// (at 3 seconds): 3</span></div><div class="line"><span class="comment">// (at 3 seconds): Finished sequence</span></div></pre></td></tr></table></figure>
<p>두번 구독하면 매초 값이 게시되는 두개의 분리된 Stream이 생성되고, 아래와 같이 보여집니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 구독을 시작합니다. 1초후 값이 게시 됩니다.</span></div><div class="line">sequence.subscribe(&#123;</div><div class="line">  next(num) &#123; <span class="built_in">console</span>.log(<span class="string">'1st subscribe: '</span> + num); &#125;,</div><div class="line">  complete() &#123; <span class="built_in">console</span>.log(<span class="string">'1st sequence finished.'</span>); &#125;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 0.5초 후에 다시 구독합니다.</span></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  sequence.subscribe(&#123;</div><div class="line">    next(num) &#123; <span class="built_in">console</span>.log(<span class="string">'2nd subscribe: '</span> + num); &#125;,</div><div class="line">    complete() &#123; <span class="built_in">console</span>.log(<span class="string">'2nd sequence finished.'</span>); &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;, <span class="number">500</span>);</div><div class="line"> </div><div class="line"><span class="comment">// 출력:</span></div><div class="line"><span class="comment">// (at 1 second): 1st subscribe: 1</span></div><div class="line"><span class="comment">// (at 1.5 seconds): 2nd subscribe: 1</span></div><div class="line"><span class="comment">// (at 2 seconds): 1st subscribe: 2</span></div><div class="line"><span class="comment">// (at 2.5 seconds): 2nd subscribe: 2</span></div><div class="line"><span class="comment">// (at 3 seconds): 1st subscribe: 3</span></div><div class="line"><span class="comment">// (at 3 seconds): 1st sequence finished</span></div><div class="line"><span class="comment">// (at 3.5 seconds): 2nd subscribe: 3</span></div><div class="line"><span class="comment">// (at 3.5 seconds): 2nd sequence finished</span></div></pre></td></tr></table></figure>
<p><em>Observable</em>을 Multicasting 으로 변경하면 다음과 같습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multicastSequenceSubscriber</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">  <span class="comment">// 각 observer를 추적합니다.(모든 활성 구독마다 하나씩).</span></div><div class="line">  <span class="keyword">const</span> observers = [];</div><div class="line">  <span class="comment">// 하나의 value set만 생성되고 각 subscriber로 Multicast 되기 때문에 하나의 timeoutId만 있습니다.</span></div><div class="line">  <span class="keyword">let</span> timeoutId;</div><div class="line"> </div><div class="line">  <span class="comment">// subscribe() 함수가 invoke 될때 실행 되는 subscriber 함수를 리턴합니다.</span></div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</div><div class="line">    observers.push(observer);</div><div class="line">    <span class="comment">// 첫 번째 구독인 경우 시퀀스를 시작합니다.</span></div><div class="line">    <span class="keyword">if</span> (observers.length === <span class="number">1</span>) &#123;</div><div class="line">      timeoutId = doSequence(&#123;</div><div class="line">        next(val) &#123;</div><div class="line">          <span class="comment">// observer를 순회하면서 모든 구독에 알람을 줍니다.</span></div><div class="line">          observers.forEach(<span class="function"><span class="params">obs</span> =&gt;</span> obs.next(val));</div><div class="line">        &#125;,</div><div class="line">        complete() &#123;</div><div class="line">          <span class="comment">// 모든 complete 콜백에 알람을 줍니다.</span></div><div class="line">          observers.forEach(<span class="function"><span class="params">obs</span> =&gt;</span> obs.complete());</div><div class="line">        &#125;</div><div class="line">      &#125;, seq, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      unsubscribe() &#123;</div><div class="line">        <span class="comment">// observer 배열에서 제거합니다. 그리고 더이상 알람을 받지 않습니다.</span></div><div class="line">        observers.splice(observers.indexOf(observer), <span class="number">1</span>);</div><div class="line">        <span class="comment">// Listener가 없을 경우 정리합니다.</span></div><div class="line">        <span class="keyword">if</span> (observers.length === <span class="number">0</span>) &#123;</div><div class="line">          clearTimeout(timeoutId);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 배열을 순회하면서 배열의 끝에 다다를 때까지 1초에 하나의 값을 게시합니다.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSequence</span>(<span class="params">observer, arr, idx</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    observer.next(arr[idx]);</div><div class="line">    <span class="keyword">if</span> (idx === arr.length - <span class="number">1</span>) &#123;</div><div class="line">      observer.complete();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      doSequence(observer, arr, idx++);</div><div class="line">    &#125;</div><div class="line">  &#125;, <span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 위의 시퀀스를 전달하는 새로운 Observable을 생성합니다.</span></div><div class="line"><span class="keyword">const</span> multicastSequence = <span class="keyword">new</span> Observable(multicastSequenceSubscriber);</div><div class="line"> </div><div class="line"><span class="comment">// 구독을 시작하고 1초후에 게시를 시작합니다.</span></div><div class="line">multicastSequence.subscribe(&#123;</div><div class="line">  next(num) &#123; <span class="built_in">console</span>.log(<span class="string">'1st subscribe: '</span> + num); &#125;,</div><div class="line">  complete() &#123; <span class="built_in">console</span>.log(<span class="string">'1st sequence finished.'</span>); &#125;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 1.5초 후에 구독을 다시 시작 합니다. (첫 값은 받지 못합니다.)</span></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  multicastSequence.subscribe(&#123;</div><div class="line">    next(num) &#123; <span class="built_in">console</span>.log(<span class="string">'2nd subscribe: '</span> + num); &#125;,</div><div class="line">    complete() &#123; <span class="built_in">console</span>.log(<span class="string">'2nd sequence finished.'</span>); &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;, <span class="number">1500</span>);</div><div class="line"> </div><div class="line"><span class="comment">// 출력:</span></div><div class="line"><span class="comment">// (at 1 second): 1st subscribe: 1</span></div><div class="line"><span class="comment">// (at 2 seconds): 1st subscribe: 2</span></div><div class="line"><span class="comment">// (at 2 seconds): 2nd subscribe: 2</span></div><div class="line"><span class="comment">// (at 3 seconds): 1st subscribe: 3</span></div><div class="line"><span class="comment">// (at 3 seconds): 1st sequence finished</span></div><div class="line"><span class="comment">// (at 3 seconds): 2nd subscribe: 3</span></div><div class="line"><span class="comment">// (at 3 seconds): 2nd sequence finished</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>Multicast Observable</em>은 조금더 많은 설정을 필요로 하지만, 어떤 어플리케이션에서는 이러한 사용법이 훨씬 더 유용할 수 있습니다. 나중에 Multicasting 프로세스를 간소화하는 도구를 살펴볼 예정이며, 또한 임의의 <em>Observable</em>을 가져와 Multicasting 할 수도 있습니다.</p>
</blockquote>
<h2 id="오류-처리"><a href="#오류-처리" class="headerlink" title="오류 처리"></a>오류 처리</h2><p><em>Observable</em>은 값을 동기적으로 생성하기 때문에 오류를 잡는데(catch) try/catch가 효율적이지 않습니다. 대신에 <em>observer</em>의 <code>error</code> 콜백을 지정하여 오류를 처리할 수 있습니다. 오류가 발생하면 <em>Observable</em>이 구독을 정리하고 값 생성을 중지합니다. <em>Observable</em>은 값을 생성하거나 (<code>next</code> 콜백을 호출할 수 있습니다.) <code>complete</code> 또는<code>error</code> 콜백을 호출하여 완료할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">myObservable.subscribe(&#123;</div><div class="line">  next(num) &#123; <span class="built_in">console</span>.log(<span class="string">'Next num: '</span> + num)&#125;,</div><div class="line">  error(err) &#123; <span class="built_in">console</span>.log(<span class="string">'Received an errror: '</span> + err)&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>오류 처리(특히 오류 복구)에 대해서는 다음 섹션에서 자세히 설명합니다.</p>
<h1 id="RxJS-라이브러리"><a href="#RxJS-라이브러리" class="headerlink" title="RxJS 라이브러리"></a>RxJS 라이브러리</h1><p>반응형 프로그래밍(Reactive programming)은 데이터 스트림 및 변경 전파와 관련된 비동기 프로그래밍 패러다임입니다.  RxJS (Reactive Extensions for JavaScript)는 비동기 또는 콜백 기반 코드를 보다 쉽게 작성할 수 있도록 <em>Observable</em>을 이용한 반응형 프로그래밍 라이브러리 입니다.</p>
<p>RxJS는 <code>Observable</code> 타입 구현을 제공합니다. 이 구현은 <code>Observable</code>이 언어(Language)의 일부 또는 브라우저가 지원할 때까지 필요합니다. 이 라이브러리는 <code>Observable</code> 객체를 생성하고 작업하기 위한 유틸리티 함수도 제공합니다. 이 유틸리티 함수는 다음과 같은 경우에 사용할 수 있습니다.</p>
<ul>
<li>기존 코드를 <em>Observable</em>의 비동기 작업으로 변환</li>
<li>스트림의 값 순회</li>
<li>값을 다른 타입으로 매핑</li>
<li>스트림 필터링</li>
<li>여러 스트림 작성</li>
</ul>
<h2 id="Observable-생성-함수"><a href="#Observable-생성-함수" class="headerlink" title="Observable 생성 함수"></a>Observable 생성 함수</h2><p>RxJS는 새로운 <em>Observable</em>을 생성하는데 사용할 수 있는 몇가지 함수를 제공합니다. 이러한 함수는 Event, Timer , Promise등으로 부터 <em>Observable</em> 객체를 만드는 프로세스를 단순화 할 수 있습니다.</p>
<p><strong>Promise로 부터 Observable 생성</strong><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; fromPromise &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</div><div class="line"></div><div class="line"><span class="comment">// Promise에서 Observable을 만듭니다.</span></div><div class="line"><span class="keyword">const</span> data = fromPromise(fetch(<span class="string">'/api/endpoint'</span>));</div><div class="line"><span class="comment">// 구독하여 비동기적으로 결과를 수신 시작</span></div><div class="line">data.subscribe(&#123;</div><div class="line"> next(response) &#123; <span class="built_in">console</span>.log(response); &#125;,</div><div class="line"> error(err) &#123; <span class="built_in">console</span>.error(<span class="string">'Error: '</span> + err); &#125;,</div><div class="line"> complete() &#123; <span class="built_in">console</span>.log(<span class="string">'Completed'</span>); &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>Counter로 부터 Observable 생성</strong><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; interval &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 주기적으로 값을 게시하는 Observable 생성</span></div><div class="line"><span class="keyword">const</span> secondsCounter = interval(<span class="number">1000</span>);</div><div class="line"><span class="comment">// 구독하여 값의 게시를 시작</span></div><div class="line">secondsCounter.subscribe(<span class="function"><span class="params">n</span> =&gt;</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`It's been <span class="subst">$&#123;n&#125;</span> seconds since subscribing!`</span>));</div></pre></td></tr></table></figure></p>
<p><strong>이벤트(Event)로 부터 Observable 생성</strong><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; fromEvent &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</div><div class="line"> </div><div class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'my-element'</span>);</div><div class="line"> </div><div class="line"><span class="comment">// 마우스 이동을 게시하는 Observable 생성</span></div><div class="line"><span class="keyword">const</span> mouseMoves = fromEvent(el, <span class="string">'mousemove'</span>);</div><div class="line"> </div><div class="line"><span class="comment">// 구독하여 마우스 이동 이벤트를 수신 시작</span></div><div class="line"><span class="keyword">const</span> subscription = mouseMoves.subscribe(<span class="function">(<span class="params">evt: MouseEvent</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 마우스 움직임 좌표를 로깅</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`Coords: <span class="subst">$&#123;evt.clientX&#125;</span> X <span class="subst">$&#123;evt.clientY&#125;</span>`</span>);</div><div class="line"> </div><div class="line">  <span class="comment">// 마우스가 화면의 왼쪽 상단에 있을때 구독을 중지하여 마우스 이동정보 수신을 중지한다.</span></div><div class="line">  <span class="keyword">if</span> (evt.clientX &lt; <span class="number">40</span> &amp;&amp; evt.clientY &lt; <span class="number">40</span>) &#123;</div><div class="line">    subscription.unsubscribe();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>AJAX 요청을 생성하는 Observable 생성</strong><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; ajax &#125; <span class="keyword">from</span> <span class="string">'rxjs/ajax'</span>;</div><div class="line"></div><div class="line"><span class="comment">// AJAX 요청을 생성하는 Observable 생성</span></div><div class="line"><span class="keyword">const</span> apiData = ajax(<span class="string">'/api/data'</span>);</div><div class="line"><span class="comment">// 구독하여 요청을 생성</span></div><div class="line">apiData.subscribe(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res.status, res.response));</div></pre></td></tr></table></figure></p>
<h2 id="연산자-Operator"><a href="#연산자-Operator" class="headerlink" title="연산자(Operator)"></a>연산자(Operator)</h2><p>연산자는 컬렉션의 정교한 조작을 가능하게하는 <em>Observable</em>의 기반이 되는 함수입니다. 예를 들어, RxJS는 <code>map()</code>, <code>filter()</code>, <code>concat()</code> 및 <code>flatMap()</code>과 같은 연산자를 정의합니다. 연산자는 설정 옵션을 사용하고 원본 <em>Observable</em>을 사용하는 함수를 반환합니다. </p>
<p>반환된 함수를 실행할 때, 연산자는 원본 <em>Observable</em>에서 생성된 값을 주시하여, 변환하고 변환된 값의 새로운 <em>Observable</em> 값을 반환합니다. 다음은 간단한 예입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; map &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</div><div class="line"> </div><div class="line"><span class="keyword">const</span> nums = of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"> </div><div class="line"><span class="keyword">const</span> squareValues = map(<span class="function">(<span class="params">val: <span class="built_in">number</span></span>) =&gt;</span> val * val);</div><div class="line"><span class="keyword">const</span> squaredNums = squareValues(nums);</div><div class="line"> </div><div class="line">squaredNums.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</div><div class="line"> </div><div class="line"><span class="comment">// Logs</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 4</span></div><div class="line"><span class="comment">// 9</span></div></pre></td></tr></table></figure>
<p><em>pipe</em>를 사용하여 연산자를 함께 연결할 수 있습니다. <em>pipe</em>를 사용하면 여러 함수를 단일 함수로 결합할 수 있습니다. <code>pipe()</code> 함수는 결합하려는 함수를 인수로 받고, 실행될 때 작성된 순서대로 함수를 실행하는 새로운 함수를 반환합니다.</p>
<p><em>Observable</em>에 적용되는 연산자 집합은 레시피입니다. 즉, 원하는 값을 생성하기 위한 지침 집합입니다. 레시피 자체적으로는 아무 것도하지 않습니다. 레시피를 통해 결과를 얻으려면 <code>subscribe()</code>를 호출 해야합니다.</p>
<p>아래 예제를 보겠습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; filter, map &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</div><div class="line"> </div><div class="line"><span class="keyword">const</span> nums = of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</div><div class="line"> </div><div class="line"><span class="comment">// Observable을 받는 함수를 생성합니다.</span></div><div class="line"><span class="keyword">const</span> squareOddVals = pipe(</div><div class="line">  filter(<span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span>),</div><div class="line">  map(<span class="function"><span class="params">n</span> =&gt;</span> n * n)</div><div class="line">);</div><div class="line"> </div><div class="line"><span class="comment">// filter와 map 함수를 실행시키는 Observable을 생성합니다.</span></div><div class="line"><span class="keyword">const</span> squareOdd = squareOddVals(nums);</div><div class="line"> </div><div class="line"><span class="comment">// 구독하여 결합된 함수를 실행합니다.</span></div><div class="line">squareOdd.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</div></pre></td></tr></table></figure>
<p><code>pipe()</code> 함수는 RxJS <code>Observable</code>의 메서드이기도 하므로 아래와 같이 짧은 표현식을 사용하여 동일한 연산을 정의할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; filter, map &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> squareOdd = of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">  .pipe(</div><div class="line">    filter(<span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> !== <span class="number">0</span>),</div><div class="line">    map(<span class="function"><span class="params">n</span> =&gt;</span> n * n)</div><div class="line">  );</div><div class="line"></div><div class="line"><span class="comment">// 구독하여 값을 받습니다.</span></div><div class="line">squareOdd.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</div></pre></td></tr></table></figure>
<h2 id="일반-연산자"><a href="#일반-연산자" class="headerlink" title="일반 연산자"></a>일반 연산자</h2><p>RxJS는 많은 연산자(150개 이상)를 제공하지만 몇몇 연산자만 자주 사용됩니다. 다음은 일반 연산자 목록입니다. 사용 예는 RxJS 문서의 <a href="https://github.com/btroncone/learn-rxjs/blob/master/operators/complete.md" target="_blank" rel="external">RxJS 5 연산자 사용 예제</a>를 참조하십시오.</p>
<blockquote>
<p>Angular app의 경우 체인(chaining)을 연결하는 대신 연산자를 파이프(pipe)와 결합하는 것이 더 좋습니다. 하지만 체인(chaining)은 많은 RxJS 예제에서 사용됩니다.</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>영역</th>
<th>연산자들</th>
</tr>
</thead>
<tbody>
<tr>
<td>생성</td>
<td><code>from</code> , <code>fromPromise</code> , <code>fromEvent</code> , <code>of</code></td>
</tr>
<tr>
<td>결합</td>
<td><code>combineLatest</code> , <code>concat</code> , <code>merge</code> , <code>startWith</code> , <code>withLatestFrom</code> , <code>zip</code></td>
</tr>
<tr>
<td>필터링</td>
<td><code>debounceTime</code> , <code>distinctUntilChanged</code> , <code>filter</code> , <code>take</code> , <code>takeUntil</code></td>
</tr>
<tr>
<td>변환</td>
<td><code>bufferTime</code> , <code>concatMap</code> , <code>map</code> , <code>mergeMap</code> , <code>scan</code> , <code>switchMap</code></td>
</tr>
<tr>
<td>유틸리티</td>
<td><code>tap</code></td>
</tr>
<tr>
<td>멀티캐스팅</td>
<td><code>share</code></td>
</tr>
</tbody>
</table>
<h2 id="오류-처리-1"><a href="#오류-처리-1" class="headerlink" title="오류 처리"></a>오류 처리</h2><p>RxJS는 <code>subscribe()</code>서 사용할 수 있는 <code>error()</code> 핸들러 외에도 알려진 오류를 처리 할 수있는 <code>catchError</code> 연산자도 제공합니다.</p>
<p>예를 들어, API 요청을 만들고 서버의 응답에 매핑하는 <em>Observable</em>이 있다고 가정해 보겠습니다. 만약 서버에서 오류를 반환하거나 값이 없다면 오류가 발생합니다. 하지만 여러분이 이 오류를 잡아서 Default 값을 제공한다면, Stream은 오류 대신 계속 진행될 것입니다.</p>
<p>아래는 <code>catchError</code> 연산자를 사용하는 예제입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; ajax &#125; <span class="keyword">from</span> <span class="string">'rxjs/ajax'</span>;</div><div class="line"><span class="keyword">import</span> &#123; map, catchError &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</div><div class="line"><span class="comment">// API에서 "response"를 반환합니다. 하지만 오류가 발생하면 빈 배열을 반환합니다.</span></div><div class="line"><span class="keyword">const</span> apiData = ajax(<span class="string">'/api/data'</span>).pipe(</div><div class="line">  map(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!res.response) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Value expected!'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res.response;</div><div class="line">  &#125;),</div><div class="line">  catchError(<span class="function"><span class="params">err</span> =&gt;</span> of([]))</div><div class="line">);</div><div class="line"> </div><div class="line">apiData.subscribe(&#123;</div><div class="line">  next(x) &#123; <span class="built_in">console</span>.log(<span class="string">'data: '</span>, x); &#125;,</div><div class="line">  error(err) &#123; <span class="built_in">console</span>.log(<span class="string">'errors already caught... will not run'</span>); &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="실패한-Observable-재시도"><a href="#실패한-Observable-재시도" class="headerlink" title="실패한 Observable 재시도"></a>실패한 Observable 재시도</h2><p><code>catchError</code> 연산자가 간단한 복구 경로를 제공하는 경우, <code>retry</code> 연산자를 사용하여 실패한 요청을 다시 시도할 수 있습니다.</p>
<p><code>catchError</code> 연산자 앞에 <code>retry</code>연산자를 사용합니다. 이는 <em>Observable</em> 원본 소스를 다시 구독하여 오류를 유발한 모든 동작 시퀀스를 다시 실행할 수 있습니다. 그리고 만약 HTTP 요청을 포함하고 있다면 HTTP 요청을 다시 보냅니다.</p>
<p>아래 예제는 이전 예제를 수정하여 오류를 발생하기 전에 요청을 다시 시도합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; ajax &#125; <span class="keyword">from</span> <span class="string">'rxjs/ajax'</span>;</div><div class="line"><span class="keyword">import</span> &#123; map, retry, catchError &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</div><div class="line"> </div><div class="line"><span class="keyword">const</span> apiData = ajax(<span class="string">'/api/data'</span>).pipe(</div><div class="line">  retry(<span class="number">3</span>), <span class="comment">// 실패하기 전에 최대 3번 다시 시도합니다.</span></div><div class="line">  map(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!res.response) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Value expected!'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res.response;</div><div class="line">  &#125;),</div><div class="line">  catchError(<span class="function"><span class="params">err</span> =&gt;</span> of([]))</div><div class="line">);</div><div class="line"> </div><div class="line">apiData.subscribe(&#123;</div><div class="line">  next(x) &#123; <span class="built_in">console</span>.log(<span class="string">'data: '</span>, x); &#125;,</div><div class="line">  error(err) &#123; <span class="built_in">console</span>.log(<span class="string">'errors already caught... will not run'</span>); &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>인증 요청은 사용자 작업에 의해서만 시작되어야 하므로 다시 시도하지 마십시오. 사용자가 시작하지 않은 반복 로그인 요청으로 사용자 계정이 잠길수 있습니다.</p>
</blockquote>
<h3 id="Observable에-대한-명명-규칙"><a href="#Observable에-대한-명명-규칙" class="headerlink" title="Observable에 대한 명명 규칙"></a>Observable에 대한 명명 규칙</h3><p>Angular 응용 프로그램은 대부분 TypeScript로 작성되기 때문에 일반적으로 변수가 Observable 일때 알 수 있습니다. 비록 Angular 프레임워크가 <em>Observable</em>에 대한 명명 규칙을 강제하지 않더라도 여러분은 종종 이름 끝에 “$”가 붙은 변수를 볼수 있습니다.</p>
<p>이러한 방법은 코드를 훑어 보며 <em>Observable</em> 값을 찾을때 유용할 수 있습니다. 또한, <em>Observable</em>에서 가장 최근의 값을 저장하는 프로퍼티를 원할 때 “$”의 유무와 상관없이 동일한 이름을 사용하는 것이 편리할 수 있습니다.</p>
<p>예를 들어 아래와 같습니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</div><div class="line"> </div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  selector: <span class="string">'app-stopwatch'</span>,</div><div class="line">  templateUrl: <span class="string">'./stopwatch.component.html'</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> StopwatchComponent &#123;</div><div class="line"> </div><div class="line">  stopwatchValue: <span class="built_in">number</span>;</div><div class="line">  stopwatchValue$: Observable&lt;<span class="built_in">number</span>&gt;;</div><div class="line"> </div><div class="line">  start() &#123;</div><div class="line">    <span class="keyword">this</span>.stopwatchValue$.subscribe(<span class="function"><span class="params">num</span> =&gt;</span></div><div class="line">      <span class="keyword">this</span>.stopwatchValue = num</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Angular에서-Observable"><a href="#Angular에서-Observable" class="headerlink" title="Angular에서 Observable"></a>Angular에서 Observable</h1><p>Angular는 <em>Observable</em>을 다양한 공통의 비동기 작업을 처리하기 위한 인터페이스로 사용합니다. 예를 들어:</p>
<ul>
<li><code>EventEmitter</code> 클래스는 <code>Observable</code>를 상속받습니다.</li>
<li>HTTP 모듈은 <em>Observable</em>을 사용하여 AJAX 요청 및 응답을 처리합니다.</li>
<li>Router 및 Form 모듈은 <em>Observable</em>을 사용하여 사용자 입력 이벤트를 수신하고 응답합니다.</li>
</ul>
<h2 id="Event-Emitter"><a href="#Event-Emitter" class="headerlink" title="Event Emitter"></a>Event Emitter</h2><p>Angular는 <code>@Output()</code> 데코레이터를 통해 <em>Component</em>의 값을 게시할 때 사용되는 <code>EventEmitter</code> 클래스를 제공합니다. <code>EventEmitter</code>는 <code>Observable</code>을 상속하고 <code>emit()</code> 메서드를 추가하여 임의의 값을 방출할 수 있습니다. <code>emit()</code> 메서드를 호출하면 방출된 값을 구독하고 있는 <em>observer</em>의 <code>next()</code> 메서드로 전달합니다.</p>
<p><a href="https://angular.io/api/core/EventEmitter" target="_blank" rel="external">EventEmitter</a> 문서에서 좋은 예제들을 찾을 수 있습니다. 다음은 open 및 close 이벤트를 수신하는 예제 <em>Component</em> 입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;zippy (open)=<span class="string">"onOpen($event)"</span> (close)=<span class="string">"onClose($event)"</span>&gt;&lt;<span class="regexp">/zippy&gt;</span></div></pre></td></tr></table></figure>
<p>아래는 <em>Component</em>에 대한 정의입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  selector: <span class="string">'zippy'</span>,</div><div class="line">  template: <span class="string">`</span></div><div class="line">  &lt;div class="zippy"&gt;</div><div class="line">    &lt;div (click)="toggle()"&gt;Toggle&lt;/div&gt;</div><div class="line">    &lt;div [hidden]="!visible"&gt;</div><div class="line">      &lt;ng-content&gt;&lt;/ng-content&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/div&gt;`&#125;)</div><div class="line"> </div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> ZippyComponent &#123;</div><div class="line">  visible = <span class="literal">true</span>;</div><div class="line">  <span class="meta">@Output</span>() open = <span class="keyword">new</span> EventEmitter&lt;<span class="built_in">any</span>&gt;();</div><div class="line">  <span class="meta">@Output</span>() close = <span class="keyword">new</span> EventEmitter&lt;<span class="built_in">any</span>&gt;();</div><div class="line"> </div><div class="line">  toggle() &#123;</div><div class="line">    <span class="keyword">this</span>.visible = !<span class="keyword">this</span>.visible;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.visible) &#123;</div><div class="line">      <span class="keyword">this</span>.open.emit(<span class="literal">null</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">this</span>.close.emit(<span class="literal">null</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>Angular의 <code>HttpClient</code>는 HTTP 메서드 호출에서 <em>Observable</em>을 반환합니다. 예를 들어 <code>http.get(&#39;/api&#39;)</code>은 <em>Observable</em>을 반환합니다. 이러한 방식은 <em>Promise</em> 기반의 API에 비해 몇가지 장점을 제공합니다.</p>
<ul>
<li>Observables는 서버 응답을 변경하지 않습니다 (<em>Promise</em>의 <code>.then()</code> 호출을 통해 발생할 수 있음). 대신에 필요하다면 일련의 연산자를 이용하여 값을 변형할 수 있습니다.</li>
<li><code>unsubscribe()</code> 메서드를 통해 HTTP 요청을 취소할 수 있습니다.</li>
<li>요청에 대한 설정을 통해 진행 이벤트 업데이트를 가져올 수 있습니다.</li>
<li>실패한 요청을 쉽게 재시도할 수 있습니다.</li>
</ul>
<h2 id="비동기-Pipe-Async-Pipe"><a href="#비동기-Pipe-Async-Pipe" class="headerlink" title="비동기 Pipe (Async Pipe)"></a>비동기 Pipe (Async Pipe)</h2><p><a href="https://angular.io/api/common/AsyncPipe" target="_blank" rel="external">AsyncPipe</a>는 <em>Observable</em> 또는 <em>Promise</em>를 구독하고 방출된 최신 값을 반환합니다. 새 값이 방출(emit)되면 Pipe는 변경 사항을 검사할 <em>Component</em>를 표시합니다.</p>
<p>아래 예제는 <code>time</code> <em>Observable</em>을 <em>Component</em>의 뷰에 바인딩 합니다. <em>Observable</em>은 연속적으로 현재 시각을 뷰에 업데이트 합니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  selector: <span class="string">'async-observable-pipe'</span>,</div><div class="line">  template: <span class="string">`&lt;div&gt;&lt;code&gt;observable|async&lt;/code&gt;:</span></div><div class="line">       Time: &#123;&#123; time | async &#125;&#125;&lt;/div&gt;`</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> AsyncObservablePipeComponent &#123;</div><div class="line">  time = <span class="keyword">new</span> Observable(<span class="function"><span class="params">observer</span> =&gt;</span></div><div class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> observer.next(<span class="keyword">new</span> <span class="built_in">Date</span>().toString()), <span class="number">1000</span>)</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p><a href="https://angular.io/api/router/Router#events" target="_blank" rel="external">Router.events</a>는 이벤트를 <em>Observable</em>로 제공합니다. RxJS의 <code>filter()</code> 연산자를 사용하여 관심있는 이벤트를 찾을수 있고 Navigation 프로세스의 이벤트 순서를 기반으로 의사 결정을 내리기 위해 구독할 수 있습니다. 예를 들어:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Router, NavigationStart &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</div><div class="line"><span class="keyword">import</span> &#123; filter &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</div><div class="line"> </div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  selector: <span class="string">'app-routable'</span>,</div><div class="line">  templateUrl: <span class="string">'./routable.component.html'</span>,</div><div class="line">  styleUrls: [<span class="string">'./routable.component.css'</span>]</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> Routable1Component <span class="keyword">implements</span> OnInit &#123;</div><div class="line"> </div><div class="line">  navStart: Observable&lt;NavigationStart&gt;;</div><div class="line"> </div><div class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> router: Router</span>) &#123;</div><div class="line">    <span class="comment">// NavigationStart만 게시하기 위한 새로운 Observable을 생성합니다.</span></div><div class="line">    <span class="keyword">this</span>.navStart = router.events.pipe(</div><div class="line">      filter(<span class="function"><span class="params">evt</span> =&gt;</span> evt <span class="keyword">instanceof</span> NavigationStart)</div><div class="line">    ) <span class="keyword">as</span> Observable&lt;NavigationStart&gt;;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="keyword">this</span>.navStart.subscribe(<span class="function"><span class="params">evt</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Navigation Started!'</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://angular.io/api/router/ActivatedRoute" target="_blank" rel="external">ActivatedRoute</a>는 <em>Observable</em>을 사용하여 Route path 및 파라미터에 대한 정보를 가져 오는 Inject된 Router <em>Service</em>입니다. 예를 들어, <code>ActivateRoute.url]</code>에는 Route path를 보고하는 <em>Observable</em>을 포함하고 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; ActivatedRoute &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</div><div class="line"> </div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  selector: <span class="string">'app-routable'</span>,</div><div class="line">  templateUrl: <span class="string">'./routable.component.html'</span>,</div><div class="line">  styleUrls: [<span class="string">'./routable.component.css'</span>]</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> Routable2Component <span class="keyword">implements</span> OnInit &#123;</div><div class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> activatedRoute: ActivatedRoute</span>) &#123;&#125;</div><div class="line"> </div><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="keyword">this</span>.activatedRoute.url</div><div class="line">      .subscribe(<span class="function"><span class="params">url</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'The URL changed to: '</span> + url));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="반응형-Form-Reactive-form"><a href="#반응형-Form-Reactive-form" class="headerlink" title="반응형 Form (Reactive form)"></a>반응형 Form (Reactive form)</h2><p>반응형 Form은 <em>Observable</em>을 사용하여 Form control 값을 모니터링하는 프로퍼티를 가지고 있습니다. <a href="https://angular.io/api/forms/FormControl" target="_blank" rel="external">FormControl</a> 프로퍼티는 변경 이벤트를 발생시키는 <code>valueChanges</code> 및 <code>statusChanges</code> <em>Observable</em>을 포함합니다. <em>Observable</em> From control 프로퍼티를 구독하는 것은 <em>Component</em> 클래스 내에서 응용 프로그램 로직을 실행시키는 방법입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; FormGroup &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</div><div class="line"> </div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  selector: <span class="string">'my-component'</span>,</div><div class="line">  template: <span class="string">'MyComponent Template'</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyComponent <span class="keyword">implements</span> OnInit &#123;</div><div class="line">  nameChangeLog: <span class="built_in">string</span>[] = [];</div><div class="line">  heroForm: FormGroup;</div><div class="line"> </div><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="keyword">this</span>.logNameChange();</div><div class="line">  &#125;</div><div class="line">  logNameChange() &#123;</div><div class="line">    <span class="keyword">const</span> nameControl = <span class="keyword">this</span>.heroForm.get(<span class="string">'name'</span>);</div><div class="line">    nameControl.valueChanges.forEach(</div><div class="line">      <span class="function">(<span class="params">value: <span class="built_in">string</span></span>) =&gt;</span> <span class="keyword">this</span>.nameChangeLog.push(value)</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Observable의-실제-사용방법"><a href="#Observable의-실제-사용방법" class="headerlink" title="Observable의 실제 사용방법"></a>Observable의 실제 사용방법</h1><p>다음은 <em>Observable</em>이 특히 유용한 도메인의 예입니다.</p>
<h2 id="자동완성-Type-ahead-suggestion"><a href="#자동완성-Type-ahead-suggestion" class="headerlink" title="자동완성(Type-ahead suggestion)"></a>자동완성(Type-ahead suggestion)</h2><p><em>Observable</em>은 자동완성(Type-ahead)의 구현을 간단히할 수 있습니다. 일반적으로 자동완성(Type-ahead)은 일련의 별도 작업을 수행해야합니다.</p>
<ul>
<li>입력 데이터 수신합니다.</li>
<li>값에서 공백을 제거하고, 최소 길이인지 확인합니다.</li>
<li>Debounce(모든 키 입력에 대해 API 요청을 보내지 않고 대신 키 입력이 중단될 때까지 대기).</li>
<li>값이 동일하게 유지되면 요청을 보내지 않습니다 (예를 들어 문자를 빠르게 치고 백스 페이스 하는등).</li>
<li>업데이트된 결과로 인해 결과가 무효화되는 경우 진행중인 AJAX 요청을 취소합니다.</li>
</ul>
<p>이런 내용을 JavaScript로 전체 작성하면 상당히 복잡할 수 있습니다. 하지만 <em>Observable</em>를 사용하면 간단한 일련의 RxJS 연산자를 사용할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; fromEvent &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</div><div class="line"><span class="keyword">import</span> &#123; ajax &#125; <span class="keyword">from</span> <span class="string">'rxjs/ajax'</span>;</div><div class="line"><span class="keyword">import</span> &#123; map, filter, debounceTime, distinctUntilChanged, switchMap &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</div><div class="line"> </div><div class="line"><span class="keyword">const</span> searchBox = <span class="built_in">document</span>.getElementById(<span class="string">'search-box'</span>);</div><div class="line"> </div><div class="line"><span class="keyword">const</span> typeahead = fromEvent(searchBox, <span class="string">'input'</span>).pipe(</div><div class="line">  map(<span class="function">(<span class="params">e: KeyboardEvent</span>) =&gt;</span> e.target.value),</div><div class="line">  filter(<span class="function"><span class="params">text</span> =&gt;</span> text.length &gt; <span class="number">2</span>),</div><div class="line">  debounceTime(<span class="number">10</span>),</div><div class="line">  distinctUntilChanged(),</div><div class="line">  switchMap(<span class="function"><span class="params">()</span> =&gt;</span> ajax(<span class="string">'/api/endpoint'</span>))</div><div class="line">);</div><div class="line"> </div><div class="line">typeahead.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line"> <span class="comment">// API로 부터 받은 데이터 처리</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Exponential-backoff"><a href="#Exponential-backoff" class="headerlink" title="Exponential backoff"></a>Exponential backoff</h2><blockquote>
<p>대규모 서비스를 설계할 때, 적절한 타임아웃 설정이 중요합니다. 실제로 어떤 요청에 대해 부하 상태 등으로 타임아웃이 발생하게 되면 그 다음 요청에 대한 응답을 조금 더 긴 시간에 랜덤으로 처리하는 방법을 엑스포넨셜 백오프(exponential backoff)라고 합니다.</p>
</blockquote>
<p>엑스포넨셜 백오프는 API 요청 실패후 재시도하고, 연속적인 실패가 발생할 때마다 재시도 간격을 늘립니다. 그리고 최대 재시도 횟수이후 요청이 실패한 것으로 간주하는 기술입니다. 이러한 내용을 <em>Promise</em>와 AJAX 호출을 추적하는 다른 메서드로 구현하는 것은 꽤 복잡 할 수 있습니다. 하지만 <em>Observable</em>로 구현하는 것은 매우 쉽습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; pipe, range, timer, zip &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</div><div class="line"><span class="keyword">import</span> &#123; ajax &#125; <span class="keyword">from</span> <span class="string">'rxjs/ajax'</span>;</div><div class="line"><span class="keyword">import</span> &#123; retryWhen, map, mergeMap &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">backoff</span>(<span class="params">maxTries, ms</span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> pipe(</div><div class="line">   retryWhen(<span class="function"><span class="params">attempts</span> =&gt;</span> range(<span class="number">1</span>, maxTries)</div><div class="line">     .pipe(</div><div class="line">       zip(attempts, <span class="function">(<span class="params">i</span>) =&gt;</span> i),</div><div class="line">       map(<span class="function"><span class="params">i</span> =&gt;</span> i * i),</div><div class="line">       mergeMap(<span class="function"><span class="params">i</span> =&gt;</span>  timer(i * ms))</div><div class="line">     )</div><div class="line">   )</div><div class="line"> );</div><div class="line">&#125;</div><div class="line"> </div><div class="line">ajax(<span class="string">'/api/endpoint'</span>)</div><div class="line">  .pipe(backoff(<span class="number">3</span>, <span class="number">250</span>))</div><div class="line">  .subscribe(<span class="function"><span class="params">data</span> =&gt;</span> handleData(data));</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleData</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="다른-기술들과-Observable-비교"><a href="#다른-기술들과-Observable-비교" class="headerlink" title="다른 기술들과 Observable 비교"></a>다른 기술들과 Observable 비교</h1><p><em>Observable</em>을 이용하여 <em>Promise</em> 대신 값을 비동기로 전달할 수 있고, <em>Event</em> 핸들러 대신 사용할 수 있습니다. 그리고 <em>Observable</em>이 여러개의 값을 전달할 수 있기 때문에 <em>Array</em>를 만들고 처리할 수 있는 곳에 사용할 수 있습니다.</p>
<p><em>Observable</em>는 이러한 각각의 상황에서 대체 기술과 다소 다르게 동작하지만 중요한 이점을 제공합니다. 다음은 차이점에 대한 자세한 비교 내용입니다.</p>
<h2 id="Observable과-Promise-비교"><a href="#Observable과-Promise-비교" class="headerlink" title="Observable과 Promise 비교"></a>Observable과 Promise 비교</h2><p><em>Observable</em>은 종종 <em>Promise</em>와 비교됩니다. 주요 차이점은 다음과 같습니다.</p>
<ul>
<li><em>Observable</em>은 선언적입니다. 구독이 될 때까지 실행을 하지 않습니다. 하지만 <em>Promise</em>는 생성즉시 실행이 됩니다. 따라서 <em>Observable</em>은 결과가 필요할 때마다 실행할 수 있는 레시피를 정의하는데 유용합니다.</li>
<li><em>Observable</em> 다수의 값을 제공할 수 있습니다. 하지만 <em>Promise</em>는 하나만 제공합니다. <em>Observable</em>은 시간이 지남에 따라 여러 값을 얻는데 유용할 수 있습니다.</li>
<li><em>Observable</em>는 체인과 구독을 구분합니다. 하지만 <em>Promise</em>에는 <code>.then()</code> 절만 있습니다. 이것은 <em>Observable</em>로 시스템의 다른 부분에서 사용할 수 있고, 작업이 바로 실행 되지 않는 복잡한 변환 레시피를 만드는데 유용하게 합니다.</li>
<li><em>Observable</em>의 <code>subscribe()</code>는 오류 처리를 담당합니다. <em>Promise</em>는 오류를 자식(Child) <em>Promise</em>로 넘깁니다. 따라서 <em>Observable</em>은 중앙 집중적이고 예측 가능한 오류 처리에 유용합니다.</li>
</ul>
<h3 id="생성과-구독"><a href="#생성과-구독" class="headerlink" title="생성과 구독"></a>생성과 구독</h3><ul>
<li><em>Observable</em>은 Consumer가 구독할 때까지 실행되지 않습니다. <code>subscribe()</code>는 행위에 대한 정의를 한번 실행하고, 다시 호출할 수 있습니다. 각 구독은 고유한 계산이 존재 합니다. 그리고 재구독은 값의 재계산을 유발합니다.</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 게시 작업을 선언합니다.</span></div><div class="line"><span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123; subscriber_fn &#125;);</div><div class="line"><span class="comment">// 실행을 시작</span></div><div class="line">observable.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="comment">// observer가 알람을 처리</span></div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<ul>
<li><em>Promise</em>는 즉시 한번만 실행이 됩니다. 결과 계산은 <em>Promise</em>가 만들어지면 시작됩니다. 작업을 재시작 할 수 있는 방법이 없습니다. 모든 <code>then</code> 절(구독)은 동일한 계산을 공유합니다.</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 실행 시작</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; executer_fn &#125;);</div><div class="line"><span class="comment">// 반환값을 처리</span></div><div class="line">promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</div><div class="line">      <span class="comment">// 여기에서 결과값을 처리</span></div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<h3 id="체인-Chaining"><a href="#체인-Chaining" class="headerlink" title="체인(Chaining)"></a>체인(Chaining)</h3><ul>
<li><p><em>Observable</em>은 map과 같은 변환 함수와 구독(subscription)을 구분합니다. 구독(subscription)만 subscriber 함수를 활성화하여 값 계산을 시작합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observable.map(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="number">2</span>*v);</div></pre></td></tr></table></figure>
</li>
<li><p><em>Promise</em>는 마지막 <code>.then</code> 절(구독과 동일)과 중간 <code>.then</code> 절 (map과 동일)을 구별하지 않습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise.then(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="number">2</span>*v);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="취소-Cancellation"><a href="#취소-Cancellation" class="headerlink" title="취소(Cancellation)"></a>취소(Cancellation)</h3><ul>
<li><p><em>Observable</em> 구독을 취소할 수 있습니다. 구독 취소는 수신자(listener)가 더 이상 값을 받지 못하도록 하고 subscriber 함수에 작업 취소를 알립니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> sub = obs.subscribe(...);</div><div class="line">sub.unsubscribe();</div></pre></td></tr></table></figure>
</li>
<li><p><em>Promise</em>는 취소가 가능하지 않습니다.</p>
</li>
</ul>
<h3 id="오류-처리-Error-handling"><a href="#오류-처리-Error-handling" class="headerlink" title="오류 처리 (Error handling)"></a>오류 처리 (Error handling)</h3><ul>
<li><em>Observable</em> 실행 오류는 <em>subscriber</em>의 오류 처리기로 전달되며 <em>subscriber</em>는 자동으로 <em>Observable</em>에서 구독을 취소합니다.</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">obs.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'my error'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li><em>Promise</em>는 자식 <em>Promise</em>에 오류를 넘깁니다.</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'my error'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Cheat-sheet"><a href="#Cheat-sheet" class="headerlink" title="Cheat sheet"></a>Cheat sheet</h3><p>아래 코드는 <em>Observable</em>과 <em>Promise</em>를 이용하여 같은 종류의 연산을 정의하는 방법을 보여줍니다.</p>
<ul>
<li><p>생성 (Creation)</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</div><div class="line">  observer.next(<span class="number">123</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>Promise</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">  resolve(<span class="number">123</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>변환 (Transform)</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obs.map(<span class="function">(<span class="params">value</span>) =&gt;</span> value * <span class="number">2</span> );</div></pre></td></tr></table></figure>
</li>
<li><p>Promise</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> value * <span class="number">2</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>구독 (Subscribe)</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub = obs.subscribe(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(value)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>Promise</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>구독 취소 (Unsubscribe)</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub.unsubscribe();</div></pre></td></tr></table></figure>
</li>
<li><p>Promise :  Promise의 해결(resolve)로 암묵적으로 처리</p>
</li>
</ul>
</li>
</ul>
<h2 id="Observable과-Event-API-비교"><a href="#Observable과-Event-API-비교" class="headerlink" title="Observable과 Event API 비교"></a>Observable과 Event API 비교</h2><p><em>Observable</em>은 <em>Event API</em>를 사용하는 <em>Event</em> 핸들러와 매우 유사합니다. 이 두 개술은 모두 알람에 대한 핸들러를 정의하고 시간이 지남에 따라 전달되는 여러 값을 처리하는데 사용합니다. <em>Observable</em>을 구독하는 것은 <em>Event</em> Listener를 추가하는 것과 같습니다. 한가지 주요한 다른점은 <em>Observable</em>은 이벤트가 핸들러에 전달되기 전에 이벤트를 변환하도록 구성할 수 있다는 것입니다.</p>
<p><em>Observable</em>을 사용하여 <em>Event</em> 및 비동기 작업을 처리하면 HTTP 요청과 같은 컨텍스트에서 일관성이 향상됩니다.</p>
<p>다음은 <em>Observable</em>와 <em>Event API</em>를 사용하여 같은 종류의 연산을 정의하는 방법을 보여주는 코드 샘플입니다.</p>
<ul>
<li><p>생성과 취소 (Creation &amp; cancellation)</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Setup</span></div><div class="line"><span class="keyword">let</span> clicks$ = fromEvent(buttonEl, ‘click’);</div><div class="line"><span class="comment">// Begin listening</span></div><div class="line"><span class="keyword">let</span> subscription = clicks$</div><div class="line">  .subscribe(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(‘Clicked’, e))</div><div class="line"><span class="comment">// Stop listening</span></div><div class="line">subscription.unsubscribe();</div></pre></td></tr></table></figure>
</li>
<li><p>Event API</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(‘Clicked’, e);</div><div class="line">&#125;</div><div class="line"><span class="comment">// Setup &amp; begin listening</span></div><div class="line">button.addEventListener(‘click’, handler);</div><div class="line"><span class="comment">// Stop listening</span></div><div class="line">button.removeEventListener(‘click’, handler);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>구독 (Subscription)</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// notification handlers here</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>Event API</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">element.addEventListener(eventName, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// notification handler here</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>구성 (Configuration)</p>
<ul>
<li><p>Observable<br>Keystroke를 Listen 하지만 입력 값을 나타내는 Stream을 제공합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fromEvent(inputEl, <span class="string">'keydown'</span>).pipe(</div><div class="line">  map(<span class="function"><span class="params">e</span> =&gt;</span> e.target.value)</div><div class="line">);</div></pre></td></tr></table></figure>
</li>
<li><p>Event API<br>구성은 제공하지 않습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">element.addEventListener(eventName, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 핸들러에 도착하기 전에 전달된 이벤트를 다른 값으로 변경할 수 없습니다.</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="Observable과-Array-비교"><a href="#Observable과-Array-비교" class="headerlink" title="Observable과 Array 비교"></a>Observable과 Array 비교</h2><p><em>Observable</em>은 시간이 지남에 따라 값을 발생시킵니다. <em>Array</em>는 정적인 값 집합으로 만들어집니다. 어떤 의미에서, <em>Observable</em>은 <em>Array</em>가 동기적인 곳에서 비동기적입니다. 다음 예에서 ➞는 비동기 값 전달을 의미합니다.</p>
<ul>
<li><p>Given</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obs: ➞<span class="number">1</span>➞<span class="number">2</span>➞<span class="number">3</span>➞<span class="number">5</span>➞<span class="number">7</span></div><div class="line">obsB: ➞<span class="string">'a'</span>➞<span class="string">'b'</span>➞<span class="string">'c'</span></div></pre></td></tr></table></figure>
</li>
<li><p>Array</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</div><div class="line">arrB: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>concat()</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obs.concat(obsB)</div><div class="line">➞<span class="number">1</span>➞<span class="number">2</span>➞<span class="number">3</span>➞<span class="number">5</span>➞<span class="number">7</span>➞<span class="string">'a'</span>➞<span class="string">'b'</span>➞<span class="string">'c'</span></div></pre></td></tr></table></figure>
</li>
<li><p>Array</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.concat(arrB)</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>filter()</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obs.filter(<span class="function">(<span class="params">v</span>) =&gt;</span> v&gt;<span class="number">3</span>)</div><div class="line">➞<span class="number">5</span>➞<span class="number">7</span></div></pre></td></tr></table></figure>
</li>
<li><p>Array</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.filter(<span class="function">(<span class="params">v</span>) =&gt;</span> v&gt;<span class="number">3</span>)</div><div class="line">[<span class="number">5</span>, <span class="number">7</span>]</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>find()</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obs.find(<span class="function">(<span class="params">v</span>) =&gt;</span> v&gt;<span class="number">3</span>)</div><div class="line">➞<span class="number">5</span></div></pre></td></tr></table></figure>
</li>
<li><p>Array</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.find(<span class="function">(<span class="params">v</span>) =&gt;</span> v&gt;<span class="number">3</span>)</div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>findIndex()</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obs.findIndex(<span class="function">(<span class="params">v</span>) =&gt;</span> v&gt;<span class="number">3</span>)</div><div class="line">➞<span class="number">3</span></div></pre></td></tr></table></figure>
</li>
<li><p>Array</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.findIndex(<span class="function">(<span class="params">v</span>) =&gt;</span> v&gt;<span class="number">3</span>)</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>forEach()</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">obs.forEach(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(v);</div><div class="line">&#125;)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="number">7</span></div></pre></td></tr></table></figure>
</li>
<li><p>Array</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">arr.forEach(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(v);</div><div class="line">&#125;)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="number">7</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>map()</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obs.map(<span class="function">(<span class="params">v</span>) =&gt;</span> -v)</div><div class="line">➞<span class="number">-1</span>➞<span class="number">-2</span>➞<span class="number">-3</span>➞<span class="number">-5</span>➞<span class="number">-7</span></div></pre></td></tr></table></figure>
</li>
<li><p>Array</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.map(<span class="function">(<span class="params">v</span>) =&gt;</span> -v)</div><div class="line">[<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-5</span>, <span class="number">-7</span>]</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>reduce()</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obs.scan(<span class="function">(<span class="params">s,v</span>)=&gt;</span> s+v, <span class="number">0</span>)</div><div class="line">➞<span class="number">1</span>➞<span class="number">3</span>➞<span class="number">6</span>➞<span class="number">11</span>➞<span class="number">18</span></div></pre></td></tr></table></figure>
</li>
<li><p>Array</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.reduce(<span class="function">(<span class="params">s,v</span>) =&gt;</span> s+v, <span class="number">0</span>)</div><div class="line"><span class="number">18</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 Angular 6.0.4 기술 문서를 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://angular.io/guide/observables" target="_blank" rel="external">https://angular.io/guide/observables</a>, <a href="https://angular.io/guide/rx-library" target="_blank" rel="external">https://angular.io/guide/rx-library</a>, <a href="https://angular.io/guide/observables-in-angular" target="_blank" rel="external">https://angular.io/guide/observables-in-angular</a>, <a href="https://angular.io/guide/comparing-observables" target="_blank" rel="external">https://angular.io/guide/comparing-observables</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-introduction/">Angular 튜토리얼 - 소개</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-the-hero-editor/">Angular 튜터리얼 - Hero 에디터</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-master-detail/">Angular 튜터리얼 - Master/Detail</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-multiple-components/">Angular 튜터리얼 - 다중 콤포넌트</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-services/">Angular 튜터리얼 - 서비스</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-routing/">Angular 튜터리얼 - 라우팅</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-http/">Angular 튜터리얼 - HTTP</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-http-client/">Angular HttpClient</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/angular-translation-service/">Angular에서 간단하게 번역기능 구현하기</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/angular-dynamic-component/">Angular 동적 컴포넌트 로딩</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/dynamic-content-in-angular/">Angular에서 동적 컨텐츠 생성</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/understanding-viewchildren-contentchildren-and-querylist-in-angular/">Angular에서 ViewChildren, ContentChildren, 그리고 QueryList 이해하기</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Observable&quot;&gt;&lt;a href=&quot;#Observable&quot; class=&quot;headerlink&quot; title=&quot;Observable&quot;&gt;&lt;/a&gt;Observable&lt;/h1&gt;&lt;p&gt;&lt;em&gt;Observable&lt;/em&gt;은 Application의 Publ
    
    </summary>
    
      <category term="Angular" scheme="http://infoscis.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="http://infoscis.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 6 부록 B. ECMAScript 7 (2016) 이해하기</title>
    <link href="http://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/"/>
    <id>http://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/</id>
    <published>2018-02-27T13:32:48.000Z</published>
    <updated>2018-02-27T14:11:41.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-6-부록-B-ECMAScript-7-2016-이해하기"><a href="#ECMAScript-6-부록-B-ECMAScript-7-2016-이해하기" class="headerlink" title="ECMAScript 6 부록 B. ECMAScript 7 (2016) 이해하기"></a>ECMAScript 6 부록 B. ECMAScript 7 (2016) 이해하기</h1><p>ECMAScript 6의 개발은 약 4년이 걸렸으며, 그후 TC-39는 이러한 긴 개발 프로세스가 지속 가능하지 않다고 결정했습니다. 대신, 매년 릴리즈하는 주기로 전환하여 새로운 기능 적용을 더 빨리 진행할 수 있도록 했습니다.</p>
<p>더자주 출시되려면 ECMAScript의 새버전은 ECMAScript 6보다 새로운 기능이 적어야합니다. 이 변경 사항을 나타내기 위해 새버전의 사양에는 더이상 버전 번호가 표시되지 않으며 대신 사양이 게시된 연도를 나타냅니다. 결과적으로 ECMAScript 6은 ECMAScript 2015로 알려져 있으며 ECMAScript 7은 공식적으로 ECMAScript 2016으로 알려져 있습니다. TC-39는 향후 모든 ECMAScript 에디션에 연도 기반 명명 시스템을 사용할 것으로 기대하고 있습니다.</p>
<p>ECMAScript 2016은 2016년 3월에 완성되었으며 새로운 수학 연산자, 새로운 <em>Array</em> 메서드 및 새로운 구문 오류가 추가된 3가지 기능만 포함되었습니다. 모두 이 부록에서 다룹니다.</p>
<h2 id="지수-연산자"><a href="#지수-연산자" class="headerlink" title="지수 연산자"></a>지수 연산자</h2><p>ECMAScript 2016에서 소개된 JavaScript 구문의 유일한 변경 사항은 <em>지수 연산자</em>입니다. 이는 베이스에 지수를 적용하는 수학 연산입니다. JavaScript는 지수 연산을 수행하기 위해 이미 <code>Math.pow()</code> 메서드를 가지고 있었지만 JavaScript는 공식 연산자가 아닌 메서드를 필요로하는 유일한 언어중 하나이기도합니다. (일부 개발자들은 연산자가 읽고 이해하기가 더 쉽다고 주장합니다.)</p>
<p>지수 연산은 두개의 별표(<code>**</code>)이며 왼쪽 피연산자는 베이스이고 오른쪽 피연산자는 지수입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> result = <span class="number">5</span> ** <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result);                        <span class="comment">// 25</span></div><div class="line"><span class="built_in">console</span>.log(result === <span class="built_in">Math</span>.pow(<span class="number">5</span>, <span class="number">2</span>));     <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 예제에서는 5^2와 동일한 25를 계산합니다. <code>Math.pow()</code>를 사용하여 동일한 결과를 얻을 수 있습니다.</p>
<h3 id="연산자-우선순위"><a href="#연산자-우선순위" class="headerlink" title="연산자 우선순위"></a>연산자 우선순위</h3><p>지수 연산자는 JavaScript에서 모든 2진 연산자중 우선 순위가 가장 높습니다 (단항 연산자는 <code>**</code>보다 우선 순위가 높음). 즉, 아래 예제에서와 같이 모든 복합 연산에서 처음에 적용됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> result = <span class="number">2</span> * <span class="number">5</span> ** <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log(result);        <span class="comment">// 50</span></div></pre></td></tr></table></figure>
<p>먼저 5^2의 계산이 수행되고 결과 값에 2를 곱해 최종 결과 50을 얻습니다.</p>
<h3 id="피연산자-제한"><a href="#피연산자-제한" class="headerlink" title="피연산자 제한"></a>피연산자 제한</h3><p>지수 연산자는 다른 연산자에 대해 존재하지 않는 다소 특이한 제한이 있습니다. 지수 연산의 왼쪽은 <code>++</code> 또는 <code>--</code>이외의 단항식일 수 없습니다. 예를 들어 아래는 잘못된 구문입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 구문 오류</span></div><div class="line"><span class="keyword">let</span> result = <span class="number">-5</span> ** <span class="number">2</span>;</div></pre></td></tr></table></figure>
<p>이 예제에서 <code>-5</code>는 연산 순서가 모호하기 때문에 구문 오류입니다. <code>-</code>는 <code>5</code> 또는 <code>5 ** 2</code> 표현식의 어떤 결과에 적용되어야 할까요? 지수 연산자의 왼쪽에 단항식을 허용하지 않으면 해당 모호성이 제거됩니다. 의도를 명확하게 지정하려면 다음과 같이 <code>-5</code> 또는 <code>5 ** 2</code> 주변에 괄호를 포함시켜야합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ok</span></div><div class="line"><span class="keyword">let</span> result1 = -(<span class="number">5</span> ** <span class="number">2</span>);    <span class="comment">// equal to -25</span></div><div class="line"></div><div class="line"><span class="comment">// also ok</span></div><div class="line"><span class="keyword">let</span> result2 = (<span class="number">-5</span>) ** <span class="number">2</span>;    <span class="comment">// equal to 25</span></div></pre></td></tr></table></figure>
<p>식 주변에 괄호를 넣으면 <code>-</code>가 전체에 적용됩니다. 괄호가 <code>-5</code>를 둘러 싸면 <code>-5</code>의 2승에 대한 계산이 분명해집니다.</p>
<p>지수 연산자의 왼쪽에 <code>++</code> 및 <code>--</code>를 사용하면 두 연산자가 피연산자에 대해 명확하게 정의된 동작을 하기 때문에 괄호가 필요하지 않습니다. 접두어 <code>++</code> 또는 <code>--</code>는 다른 연산이 수행되기 전에 피연산자를 변경하며, 접미어 버전은 전체 표현식이 평가될 때까지 변경 사항을 적용하지 않습니다. 이 코드는 다음과 같이 이 연산자의 왼쪽에서 두 사례 모두 안전합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> num1 = <span class="number">2</span>,</div><div class="line">    num2 = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(++num1 ** <span class="number">2</span>);       <span class="comment">// 9</span></div><div class="line"><span class="built_in">console</span>.log(num1);              <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(num2-- ** <span class="number">2</span>);       <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(num2);              <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>이 예제에서, 지수 연산자가 적용되기 전에 <code>num1</code>이 증가하기 때문에 <code>num1</code>은 3이되고 연산 결과는 9가됩니다. <code>num2</code>의 경우, 지수 연산값은 2를 유지한 다음 1로 감소합니다.</p>
<h2 id="Array-prototype-includes-메서드"><a href="#Array-prototype-includes-메서드" class="headerlink" title="Array.prototype.includes() 메서드"></a>Array.prototype.includes() 메서드</h2><p>주어진 문자열 내에 특정 부분 문자열이 존재하는지 확인하기 위해 ECMAScript 6에 <code>String.prototype.includes()</code>를 추가했음 기억하실 것입니다. 원래 ECMAScript 6에는 문자열과 <em>Array</em>를 비슷한 방식으로 처리하기 위해 <code>Array.prototype.includes()</code> 메서드를 도입했습니다. 그러나 <code>Array.prototype.includes()</code>에 대한 사양을 ECMAScript 6 마감 시한에 완료하지 못하고 <code>Array.prototype.includes()</code>는 ECMAScript 2016에서 완료되었습니다.</p>
<h3 id="Array-prototype-includes-사용법"><a href="#Array-prototype-includes-사용법" class="headerlink" title="Array.prototype.includes() 사용법"></a>Array.prototype.includes() 사용법</h3><p><code>Array.prototype.includes()</code> 메서드는 검색할 값과 검색을 시작할 선택적 인덱스라는 두개의 파라미터를 받습니다. 두 번째 파라미터가 제공되면 <code>includes()</code>가 해당 인덱스에서 검색을 시작합니다. (기본 시작 인덱스는 0입니다.) 값이 <em>Array</em> 안에 있으면 <code>true</code>를 반환하고 그렇지 않으면 <code>false</code>를 반환합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(values.includes(<span class="number">1</span>));        <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(values.includes(<span class="number">0</span>));        <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// 인덱스 2부터 검색 시작</span></div><div class="line"><span class="built_in">console</span>.log(values.includes(<span class="number">1</span>, <span class="number">2</span>));     <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>여기서 <code>values.includes()</code>를 호출하면 <code>1</code>의 값은 <code>true</code>를, <code>0</code>은 <em>Array</em>에 없기 때문에 <code>false</code>를 반환합니다. 두 번째 파라미터가 인덱스 2 (값 <code>3</code>을 포함)에서 검색을 시작하는데 사용되고, 인덱스 2와 <em>Array</em>의 끝 사이에 숫자 <code>1</code>이 없기 때문에 <code>values.includes()</code> 메서드는 <code>false</code>를 반환합니다.</p>
<h3 id="값-비교"><a href="#값-비교" class="headerlink" title="값 비교"></a>값 비교</h3><p><code>includes()</code> 메서드에 의해 수행된 값 비교는 한가지 예외를 제외하고는 <code>===</code> 연산자를 사용합니다(<code>NaN === NaN</code>이 <code>false</code>로 평가 되더라도<code>NaN</code>은 <code>NaN</code>과 같은 것으로 간주됩니다). 이는 비교를 위해 엄격하게 <code>===</code>를 사용하는 <code>indexOf()</code> 메서드의 동작과는 다릅니다. 차이점을 확인하기위해 다음 코드를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="literal">NaN</span>, <span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(values.indexOf(<span class="literal">NaN</span>));       <span class="comment">// -1</span></div><div class="line"><span class="built_in">console</span>.log(values.includes(<span class="literal">NaN</span>));      <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>values.indexOf()</code> 메서드는 <code>NaN</code>이 <code>values</code> <em>Array</em>에 포함되어 있더라도 <code>NaN</code>에 대해 <code>-1</code>을 반환합니다. 하지만, <code>values.includes()</code>는 다른 값 비교 연산자를 사용하기 때문에 <code>NaN</code>에 대해 <code>true</code>를 반환합니다.</p>
<blockquote>
<p><em>Array</em>에서 값의 존재만을 확인하고 인덱스를 알 필요가 없는 경우 <code>NaN</code>을 처리하는 방법의 차이 때문에 <code>includes()</code>를 사용하는 것이 좋습니다. 하지만 <em>Array</em>의 어느 위치에 값이 있는지 알아야하는 경우 <code>indexOf()</code> 메서드를 사용해야합니다.</p>
</blockquote>
<p>이 구현의 또 다른 단점은 <code>+0</code>과 <code>-0</code>이 같은 것으로 간주된다는 것입니다. 이 경우 <code>indexOf()</code> 및 <code>includes()</code>의 동작은 동일합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, +<span class="number">0</span>, <span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(values.indexOf(<span class="number">-0</span>));        <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(values.includes(<span class="number">-0</span>));       <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>여기에서 <code>indexOf()</code>와 <code>includes()</code>는 두값이 같다고 간주되어 <code>-0</code>이 전달되면 <code>+0</code>을 찾습니다. 이것은 <code>+0</code> 및 <code>-0</code>을 다른 값으로 간주하는 <code>Object.is()</code> 메서드의 동작과 다릅니다.</p>
<h2 id="함수-Scope의-Strict-모드-변경"><a href="#함수-Scope의-Strict-모드-변경" class="headerlink" title="함수 Scope의 Strict 모드 변경"></a>함수 Scope의 Strict 모드 변경</h2><p><em>strict</em> 모드가 ECMAScript 5에 도입되었을 때, ECMAScript 6의 변화보다 더 단순했습니다. 그럼에도 불구하고 ECMAScript 6에서는 전역 <em>Scope</em>(모든 코드가 <em>strict</em> 모드로 실행됨) 또는 함수 <em>Scope</em>에서(함수만 <em>strict</em> 모드로 실행됨) “use strict” 지시문을 사용하여 <em>strict</em> 모드를 지정할 수있었습니다. 후자는 ECMAScript 6에서 파라미터를 정의할 수있는 보다 복잡한 방법, 특히 <em>Destructuring</em> 및 <em>Default</em> 파라미터로 인해 문제가되었습니다. 아래 코드를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">first = this</span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> first;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>여기서, 명명된 파라미터 <code>first</code>에는 <em>Default</em> 값으로 <code>this</code>가 할당됩니다. <code>first</code>의 값이 무엇이라고 기대 하시겠습니까? 이 경우, ECMAScript 6 사양은 <em>strict</em> 모드로 실행되는 파라미터를 처리하도록 JavaScript 엔진에 지시 했으므로 <code>this</code>는 <code>undefined</code>와 같아야합니다. 그러나 <em>strict</em> 모드에서 실행중인 파라미터를 구현할 때 “use strict” 기능이 있는 경우 파라미터 <em>Default</em>값이 기능을 수행할 수 있기 때문에 매우 어려웠습니다. 이러한 어려움으로 인해 대부분의 JavaScript 엔진은 이 기능을 구현하지 못했습니다 (따라서 <code>this</code>는 전역 객체와 동일합니다).</p>
<p>구현의 어려움으로 인해 ECMAScript 2016은 파라미터가 <em>Destructuring</em>되거나 <em>Default</em>값을 갖는 함수 내부에 “use strict” 지시문을 사용하는 것을 구문 오류로 판단합니다. 함수의 본문에 “use strict”가 있는 경우 <em>단순 파라미터 목록(simple parameter list)</em>, 즉 <em>Destructuring</em> 또는 <em>Default</em>값을 포함하지 않는 파라미터 목록만 허용됩니다. 아래 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// okay - using simple parameter list</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">okay</span>(<span class="params">first, second</span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> first;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// syntax error</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">notOkay1</span>(<span class="params">first, second=first</span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> first;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// syntax error</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">notOkay2</span>(<span class="params">&#123; first, second &#125;</span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> first;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>단순 파라미터 목록에서 “use strict”를 사용할 수 있습니다. 따라서 <code>okay()</code>가 예상대로 작동합니다(ECMAScript 5에서와 동일). <code>notOkay1()</code> 함수는 <em>Default</em> 파라미터 값을 가진 함수라서 더 이상 “use strict”를 사용할 수 없으므로 구문 오류입니다. 비슷하게, <code>notOkay2()</code> 함수는 <em>Destructuring</em> 파라미터를 가진 함수라서 “use strict”를 사용할 수 없기 때문에 마찮가지로 구문 오류입니다.</p>
<p>전반적으로 이러한 변경으로 인해 JavaScript 개발자가 느끼는 혼란스러운 점과 JavaScript 엔진의 구현상 문제가 모두 제거됩니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-appendix-b-understanding-ecmascript-7-2016" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-appendix-b-understanding-ecmascript-7-2016</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/e