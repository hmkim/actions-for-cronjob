<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Jungwook Park on Medium]]></title>
        <description><![CDATA[Stories by Jungwook Park on Medium]]></description>
        <link>https://medium.com/@jungwook?source=rss-4f18c87b3573------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/0*Hrvoq6PbK-r-95lj.png</url>
            <title>Stories by Jungwook Park on Medium</title>
            <link>https://medium.com/@jungwook?source=rss-4f18c87b3573------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Sun, 12 May 2019 12:02:11 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@jungwook" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[Kotlin Reflection 사용시 주의점]]></title>
            <link>https://medium.com/kjcoop/kotlin-reflection-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%A0%90-ce571c6297fd?source=rss-4f18c87b3573------2</link>
            <guid isPermaLink="false">https://medium.com/p/ce571c6297fd</guid>
            <category><![CDATA[kotlin]]></category>
            <category><![CDATA[android-app-development]]></category>
            <dc:creator><![CDATA[Jungwook Park]]></dc:creator>
            <pubDate>Mon, 10 Dec 2018 18:32:51 GMT</pubDate>
            <atom:updated>2018-12-10T18:32:51.568Z</atom:updated>
            <content:encoded><![CDATA[<p><em>Android 8.1 emulator, kotlin-reflect:1.3.11 기준으로 확인하였습니다.</em></p><p>Reflection 을 사용할 경우 Java Class 와 달리 Kotlin Class (KClass) 를 이용할 수 있는데 사용시 주의할 점이 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/398/1*6K-mry9e2fgdoJDOeKZohQ.png" /></figure><p>Reflection 중 자주 사용하는 annotation 을 기준으로 보면 다음과 같다.</p><ul><li>Java</li></ul><p>Java 의 경우 annotation 은 java.lang.Class.getAnnotations 등을 사용하게 되며 Class 의 멤버 함수이다. Class 객체는 Object 의해 생성되며 runtime class 를 반환한다. 자바의 경우 primitive 를 제외한 모든 객체는 Object를 상속받기 때문에 사실상 거의 모든 객체가 인스턴스를 이용하여 해당 값에 접근할 수 있으며, 실체는 아래와 같다.</p><pre>@Override<br>@FastNative<br>public native Annotation<em>[] </em>getDeclaredAnnotations<em>()</em>;</pre><p><a href="https://android.googlesource.com/platform/libcore/+/master/dalvik/src/main/java/dalvik/annotation/optimization/FastNative.java">FastNative</a> 는 ART runtime에 built in 최적화되어 있는 함수들에 대한 표기로, 사용하는 입장에서 빠른 JNI transition 를 보장하는 native 함수로 보면 된다.</p><ul><li>Kotlin</li></ul><p>Kotlin의 경우 kotlin.reflect.KAnnotatedElement.annotations 를 사용하며 kotlin.reflect.jvm.internal.KClassImpl 의 annotations val 에 해당한다. KClassImpl 의 내부 Data class 가 annotation을 처리하는데, 아래와 같이 얻어오게 된다.</p><pre>val annotations: List<em>&lt;</em>Annotation<em>&gt; </em>by ReflectProperties.lazySoft <strong>{ </strong>descriptor.computeAnnotations<em>() </em><strong>}</strong></pre><p>KClassImpl의 내부에서는 Data Instance를 생성해야 하는데, descriptor 를 생성할 때 아래와 같은 호출부가 있다.</p><pre>val moduleData = data<em>()</em>.moduleData</pre><p>moduleData 는</p><pre>val moduleData: RuntimeModuleData by ReflectProperties.lazySoft <strong>{<br>    </strong>jClass.<em>getOrCreateModule()<br></em><strong>}</strong></pre><p>jClass.getOrCreateModule 은 kotlin.reflect.jvm.internal.components.RuntimeModuleData.create 를 하게 되는데</p><pre>val builtIns = JvmBuiltIns<em>(</em>storageManager<em>)<br></em>val module = ModuleDescriptorImpl<em>(</em>Name.special<em>(</em>&quot;&lt;runtime module for $classLoader&gt;&quot;<em>)</em>, storageManager, builtIns<em>)</em></pre><pre><em>~ 중략 ~</em></pre><pre>builtIns.initialize<em>(</em>module, isAdditionalBuiltInsFeatureSupported = true<em>)</em></pre><pre><em>~ 중략 ~</em></pre><pre>val binaryClassAnnotationAndConstantLoader = BinaryClassAnnotationAndConstantLoaderImpl<em>(<br>        </em>module, notFoundClasses, storageManager, reflectKotlinClassFinder<br><em>)</em></pre><pre><em>~ 중략 ~</em></pre><pre>module.setDependencies<em>(</em>module, builtIns.<em>builtInsModule)<br></em>module.initialize<em>(</em>javaDescriptorResolver.<em>packageFragmentProvider)</em></pre><p>java / kotlin 패키지 상호 호환 처리를 위해 built in module 들을 처리하는 것으로 보인다. (정확한 내용 아시는 분은 도움 주세요.)</p><p>Java Class 와 다른 KClass 의 복잡한 처리로 인해 아래와 같은 수행 속도의 차이가 발생한다. 수행 코드는 다음과 같다.</p><ul><li>Java</li></ul><pre>@Test<br>fun runViaJava<em>() {<br>    </em>val classList = <em>listOf(<br>            </em>AnnotatedClass1<em>()</em>,<br>            AnnotatedClass2<em>()</em>,<br>            AnnotatedClass3<em>()</em>,<br>            AnnotatedClass4<em>()</em>,<br>            AnnotatedClass5<em>()<br>    )<br><br>    </em>var sum = 0<br><br>    Debug.startMethodTracing<em>(</em>&quot;runViaJava&quot;<em>)<br>    </em>classList.<em>forEach </em><strong>{<br>        it</strong>.<em>javaClass</em>.<em>annotations</em>.<em>firstOrNull </em><strong>{ </strong>it <strong>-&gt;<br>            </strong>it is SampleAnnotation<br>        <strong>}</strong>?.<em>let </em><strong>{<br>            </strong>sum += <em>(</em><strong>it </strong>as SampleAnnotation<em>)</em>.value<br>        <strong>}<br>    }<br>    </strong>Debug.stopMethodTracing<em>()<br><br>    </em>assertEquals<em>(</em>sum, 1 + 2 + 3 + 4 + 5<em>)<br>}</em></pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*WRl3jJsGhWGcxWdXuAlxiA.png" /><figcaption>runViaJava, 5414ms</figcaption></figure><ul><li>Kotlin</li></ul><pre>@Test<br>fun runViaKotlin<em>() {<br>    </em>val classList = <em>listOf(<br>            </em>AnnotatedClass1<em>()</em>,<br>            AnnotatedClass2<em>()</em>,<br>            AnnotatedClass3<em>()</em>,<br>            AnnotatedClass4<em>()</em>,<br>            AnnotatedClass5<em>()<br>    )<br><br>    </em>var sum = 0<br><br>    Debug.startMethodTracing<em>(</em>&quot;runViaKotlin&quot;<em>)<br>    </em>classList.<em>forEach </em><strong>{<br>        it</strong>::class.annotations.<em>firstOrNull </em><strong>{ </strong>it <strong>-&gt;<br>            </strong>it is SampleAnnotation<br>        <strong>}</strong>?.<em>let </em><strong>{<br>            </strong>sum += <em>(</em><strong>it </strong>as SampleAnnotation<em>)</em>.value<br>        <strong>}<br>    }<br>    </strong>Debug.stopMethodTracing<em>()<br><br>    </em>assertEquals<em>(</em>sum, 1 + 2 + 3 + 4 + 5<em>)<br>}</em></pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*uUhbBA4ll9sniH0Jj3INMg.png" /><figcaption>runViaKotlin, 1,109,660ms</figcaption></figure><p>위 테스트에서는 약 205 배 정도의 차이가 있다.</p><ul><li>Kotlin #2</li></ul><p>Kotlin annotation 을 쓰기 위해서 built in 처리를 위해 시간이 오래 걸린다는 가정하에 먼저 annotation 을 먼저 한 번 수행한 후 사용시에는 다음과 같다.</p><pre>@Test<br>fun runViaKotlinWithPreload<em>() {<br>    </em>Debug.startMethodTracing<em>(</em>&quot;preload&quot;<em>)<br>    </em>this::class.annotations<br>    Debug.stopMethodTracing<em>()<br><br>    </em>val classList = <em>listOf(<br>            </em>AnnotatedClass1<em>()</em>,<br>            AnnotatedClass2<em>()</em>,<br>            AnnotatedClass3<em>()</em>,<br>            AnnotatedClass4<em>()</em>,<br>            AnnotatedClass5<em>()<br>    )<br><br>    </em>var sum = 0<br><br>    Debug.startMethodTracing<em>(</em>&quot;runViaKotlinWithPreload&quot;<em>)<br>    </em>classList.<em>forEach </em><strong>{<br>        it</strong>::class.annotations.<em>firstOrNull </em><strong>{ </strong>it <strong>-&gt;<br>            </strong>it is SampleAnnotation<br>        <strong>}</strong>?.<em>let </em><strong>{<br>            </strong>sum += <em>(</em><strong>it </strong>as SampleAnnotation<em>)</em>.value<br>        <strong>}<br>    }<br>    </strong>Debug.stopMethodTracing<em>()<br><br>    </em>assertEquals<em>(</em>sum, 1 + 2 + 3 + 4 + 5<em>)<br>}</em></pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*05ADDFJRDO5AT-xklK84jw.png" /><figcaption>preload, 781,523ms</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*0ZaWgVLAYEkAtdw7eaView.png" /><figcaption>runViaKotlinWithPreloadm 103,329ms</figcaption></figure><p>이 경우는 (preload + runViaKotlinWithPreload) / runViaJava = 163 배이다.</p><p>preload 를 제외하면 약 19배 정도의 차이가 발생한다.</p><ul><li>결론</li></ul><p>Kotlin reflection 은 사용하려면 org.jetbrains.kotlin:kotlin-reflect package 가 추가로 필요하며 android studio 는 class reference 연산자 (::) 등을 이용해 annotation 을 사용하려고 할 때 아래와 같은 메시지를 출력할 뿐만 아니라</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*vi28kEbLPi3Dawto3FRwgQ.png" /></figure><p>해당 패키지 dependency를 추가하지 않을 경우 Runtime 에kotlin.jvm.KotlinReflectionNotSupportedError 이 발생하며 앱이 정상 동작하지 않는다.</p><p>즉, org.jetbrains.kotlin:kotlin-reflect dependency 를 사용하지 않고 있는 경우 kotlin reflection 을 사용하려는 경우 충분히 인지가 가능하다.</p><p>가능하다면 <strong>Reflection 사용시 KClass 대신 Java의 Class 를 사용하는 것이 좋다.</strong></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ce571c6297fd" width="1" height="1"><hr><p><a href="https://medium.com/kjcoop/kotlin-reflection-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%A0%90-ce571c6297fd">Kotlin Reflection 사용시 주의점</a> was originally published in <a href="https://medium.com/kjcoop">kjcoop</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Kotlin let, also, run, apply, with 분석]]></title>
            <link>https://medium.com/kjcoop/kotlin-let-also-run-apply-with-%EB%B6%84%EC%84%9D-8709838be4a4?source=rss-4f18c87b3573------2</link>
            <guid isPermaLink="false">https://medium.com/p/8709838be4a4</guid>
            <category><![CDATA[android-app-development]]></category>
            <category><![CDATA[kotlin]]></category>
            <dc:creator><![CDATA[Jungwook Park]]></dc:creator>
            <pubDate>Wed, 23 May 2018 04:23:30 GMT</pubDate>
            <atom:updated>2018-05-23T04:29:26.369Z</atom:updated>
            <content:encoded><![CDATA[<p><a href="https://medium.com/kjcoop/kotlin-higher-order-functions-828dedb7185b">Higher-order functions</a> 를 읽으면 도움이 됩니다.</p><p>Standard.kt 에는 유용한 함수들이 있는데 그 중 자주 사용하는 함수는 let, also, run, apply, with 등을 들 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/500/0*h0BlRm6OQDKbMZOv.jpg" /></figure><p>contract block 은 동작에 영향이 없으므로, 이외의 부분을 살펴보면</p><ul><li>let</li></ul><pre>public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R {<br> <strong>  </strong>return block(this)<br>}</pre><p>함수 signature 를 보면 &lt;T, R&gt; T.let(block: (T) -&gt; R) : R 인데 이 의미는 다음과 같이 생각할 수 있다.</p><p>&lt;T, R&gt; 은 generics type parameter 이며, 어떤 type이라도 올 수 있다.</p><p>T.let(block : (T) -&gt; R) 은 Type T 에 대해 let extension 함수를 정의하며 인자로 (T) -&gt; R lambda 식을 받고 이름을 block 으로 정의한다.</p><p>: R 의 R 은 최종 반환 값이다.</p><p>따라서 let 은 (T) -&gt; R 형태의 lambda 식을 인자로 받고 lambda 식을 수행하여 결과를 반환한다.</p><p>인자로 사용하는 lambda 식이 (T) -&gt; R 이기 때문에 block 에서 T 를 인자로서 접근할 수 있다. block(this) 에서 this 는 let 을 호출하는 T 를 의미한다.</p><p>예를 들어</p><pre>val stringfied = 3.<em>let </em>(<strong>{ </strong>input <strong>-&gt;<br>    </strong>(input * 2).toString()<br><strong>}</strong>)  // &quot;6&quot;</pre><p>T 는 Int 이고 block 에 해당하는 (T) -&gt; R 은 {input -&gt; (input * 2).toString()} 이며 해당 block 을 수행하여 “6”을 반환하며 반환하는 Type은 String 이다.</p><p>let 의 인자가 (T) -&gt; R 이기 때문에 lambda 안에서 T 에 해당하는 input 을 사용할 수 있다.</p><p>kotlin 은 single parameter에 대해 <a href="https://kotlinlang.org/docs/reference/lambdas.html#it-implicit-name-of-a-single-parameter">it keyword</a> 를 지원하며</p><pre>val stringfied = 3.<em>let </em>(<strong>{<br>    </strong>(<strong>it </strong>* 2).toString()<br><strong>}</strong>)  // &quot;6&quot;</pre><p>맨 마지막 인자가 lambda 인 경우 괄호 밖으로 뺄 수 있기 때문에</p><pre>val stringfied = 3.<em>let </em><strong>{<br>    </strong>(<strong>it </strong>* 2).toString()<br><strong>}  </strong>// &quot;6&quot;</pre><p>모두 동일하다.</p><ul><li>also</li></ul><pre>public inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T {<br><strong>    </strong>block(this)<br>    return this<br>}</pre><p>T.also(block: (T) -&gt; Unit) : T 이므로</p><p>Type T 에 대해 lambda 식 (T) -&gt; Unit 인 block 을 수행하고 다시 T 를 반환한다. let은 결과를 반환한다면 also는 T를 반환하는데 차이가 있다. 마찬가지로 block 이 (T) -&gt; Unit 이므로 lambda 식 안에서 T 를 사용할 수 있다.</p><p>예를 들어 아래와 같은 코드에서</p><pre>&quot;/sdcard/sample.file&quot;<br>        .<em>let </em><strong>{ </strong>File(<strong>it</strong>) <strong>}<br>        </strong>.<em>also </em><strong>{ it</strong>.mkdir() <strong>}<br>        </strong>.<em>also </em><strong>{ </strong><em>println</em>(<strong>it</strong>.<em>absolutePath</em>) <strong>} </strong></pre><p>.let { File(it) } 의 it 은 String 이고 첫번째 also 의 it 은 File 이며 두번째 also 의 it 은 also 가 T 의 type 을 그대로 반환하기 때문에 File 이다.</p><ul><li>run #1</li></ul><p>run 은 두가지 정의가 있고, 순서대로 살펴보면</p><pre>public inline fun &lt;R&gt; run(block: () -&gt; R): R {<br><strong>    </strong>return block()<br>}</pre><p>run(block: () -&gt; R): R 이기 때문에 lambda 식 block() 을 수행하고 그 값을 반환한다. let 과는 다르게 lambda 식의 인자로 () 가 쓰였으며 따라서 T 를 lambda 식 안에서 사용할 수 없다.</p><p>사용 예는 아래와 같다.</p><pre>val block = <strong>{<br>    </strong>&quot;Hello&quot;<br><strong>}<br></strong><em>run</em>(block).<em>also </em><strong>{ </strong><em>println</em>(<strong>it</strong>) <strong>} </strong></pre><p>block 은 인자가 없고 String 을 반환하는 lambda 식이고 위 식을 수행하면 also 에서 문자열을 출력한다.</p><pre><em>run </em><strong>{ </strong>&quot;Hello&quot; <strong>}</strong>.<em>also </em><strong>{ </strong><em>println</em>(<strong>it</strong>) <strong>}</strong></pre><p>block 을 inline 하고 마지막 인자가 lambda 이므로 괄호를 제거하면 위와 같다.</p><ul><li>run #2</li></ul><pre>public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R {<br><strong>    </strong>return block()<br>}</pre><p>run #1 과 조금 차이가 있는데 block: T.() -&gt; R 에서 T.() 는 <a href="https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver">Function literals with receiver</a> 이며 T 의 멤버 함수를 의미한다. 함수의 이름을 미리 알 수 있다면 T.memberFunction() 등의 형태로 사용하겠지만, 멤버 함수의 이름을 미리 알 수 없기 때문에 T.() 형태로 표현한다고 생각하면 편하다.</p><p>즉, block: T.() -&gt; R 은 lambda 식 안에서 T 의 멤버 함수를 T. 없이 사용할 수 있다는 의미이다.</p><p>따라서 run #2 의</p><p>T.run(block: T.() -&gt; R) : R 은 lambda 식 안에서 T 의 멤버 함수를 T. 를 생략하여 쓸 수 있으며 lambda 식의 결과를 R type으로 반환한다는 의미이다.</p><p>예를 들어 아래와 같은 코드에서</p><pre>class Outer(var inner: Inner? = null)<br><br>class Inner(var value1: Int? = null, var value2: Int? = null) {<br>    fun method1() = Unit<br>    fun method2() = Unit<br>}</pre><pre>fun caller() {<br>    val outer: Outer? = null<br>    outer?.inner?.<em>run </em><strong>{<br>        </strong>value1 = 1<br>        value2 = 2<br>        method1()<br>        method2()<br>        &quot;Hello&quot;     // return<br>    <strong>}</strong>.<em>let </em><strong>{ </strong><em>println</em>(<strong>it</strong>) <strong>}<br></strong>}</pre><p>위 예는 outer 가 null 이므로 수행되지 않지만, Outer.Inner 의 여러 멤버들을 한 번의 null 검사로 쉽게 이용할 수 있다는 것을 알 수 있다. 마지막의 &quot;Hello”가 lambda의 반환 값이며 block: () -&gt; R 이므로 block 에 인자가 없어 it 을 사용할 수 없다. 또 마지막의 “Hello” 가 없는 경우 method2() 의 반환 type인 Unit 이 반환된다.</p><ul><li>apply</li></ul><pre>public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T {<br><strong>    </strong>block()<br>    return this<br>}</pre><p>T.apply(block: T.() -&gt; Unit) : T 는 block 안에서 T. 없이 멤버를 사용할 수 있으며 block 을 수행한 후 T 를 반환한다는 의미이다.</p><p>block 을 수행한 후 this 를 반환하며 block 안에서 T 의 멤버 함수를 호출할 수 있기 때문에 생성과 동시에 값을 설정하는데 쓰인다.</p><p>예로, 아래와 같이 사용할 수 있다.</p><pre>val intent = Intent()<br>        .<em>apply </em><strong>{ </strong>putExtra(&quot;Sample&quot;, 1) <strong>}<br>        </strong>.<em>apply </em><strong>{ </strong><em>action </em>= &quot;io.github.genju83.SAMPLE_ACTION&quot; <strong>}</strong></pre><ul><li>with</li></ul><pre>public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R {<br><strong>    </strong>return receiver.block()<br>}</pre><p>with 는 receiver T 를 받고 T. 없이 멤버를 사용할 수 있는 lambda 식 block 을 인자로 받는다. apply 와 유사하지만 T 없이 with 로 시작한다. receiver 가 T 이고 block 이 T.() 이기 때문에 receiver.block() 으로 사용하는게 포인트.</p><p>즉, T 를 receiver 로 T 의 멤버인 lambda 식 block 을 수행하고 block 의 결과를 반환한다.</p><p>apply 는 T 를 반환하는데 반해 with 는 block 결과를 반환하는 차이가 있다.</p><p>아래와 같이 사용할 수 있다.</p><pre>val intent = <em>with</em>(Intent()) <strong>{<br>    </strong>putExtra(&quot;Sample&quot;, 1)<br>    <em>action </em>= &quot;io.github.genju83.SAMPLE_ACTION&quot;<br><strong>}</strong></pre><p>표로 정리해보면 다음과 같다.</p><p>T 의 확장 함수로 사용가능</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d325b72ed398d90514f2626ba1aa5591/href">https://medium.com/media/d325b72ed398d90514f2626ba1aa5591/href</a></iframe><p>어느 곳에서나 사용 가능</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/812ebf624d53101620c9e0951ef976aa/href">https://medium.com/media/812ebf624d53101620c9e0951ef976aa/href</a></iframe><ul><li><em>연습</em></li></ul><p>Int 의 확장 함수로 짝수, 홀수 각각 실행 lambda block 을 인자로 받고 짝수일 경우 그에 해당하는 lambda block, 홀수일 경우 그에 해당하는 lambda block 을 수행하고 각각의 반환에 따라 다른 동작을 하며 편의상 it 을 쓰는 함수를 만들어야 하는 경우 아래와 같은 함수 signature 를 정의할 수 있다.</p><pre>fun &lt;R&gt; Int.evenOrOdd(evenBlock:(Int) -&gt; R, oddBlock:(Int) -&gt; R) : R</pre><p>간단히 홀수인지 짝수인지 판단하고 해당 block(this) 를 수행하면 되기 때문에 아래와 같이 구현할 수 있다.</p><pre>fun &lt;R&gt; Int.evenOrOdd(evenBlock:(Int) -&gt; R, oddBlock:(Int) -&gt; R): R {<br>    return when {<br>        this % 2 == 0 -&gt; evenBlock(this)<br>        else -&gt; oddBlock(this)<br>    }<br>}</pre><p>위 함수는 아래와 같이 사용 가능하다.</p><pre>4.<em>evenOrOdd</em>(<br>        <strong>{ </strong>&quot;Even block $<strong>it</strong>&quot; <strong>}</strong>,<br>        <strong>{ </strong>&quot;Odd block $<strong>it</strong>&quot; <strong>}<br></strong>).<em>let </em><strong>{ </strong><em>println</em>(<strong>it</strong>) <strong>}   </strong>// Even block 4<br><br>3.<em>evenOrOdd</em>(<br>        <strong>{ </strong>&quot;Even block $<strong>it</strong>&quot; <strong>}</strong>,<br>        <strong>{ </strong>&quot;Odd block $<strong>it</strong>&quot; <strong>}<br></strong>).<em>let </em><strong>{ </strong><em>println</em>(<strong>it</strong>) <strong>}   </strong>// Odd block 3</pre><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8709838be4a4" width="1" height="1"><hr><p><a href="https://medium.com/kjcoop/kotlin-let-also-run-apply-with-%EB%B6%84%EC%84%9D-8709838be4a4">Kotlin let, also, run, apply, with 분석</a> was originally published in <a href="https://medium.com/kjcoop">kjcoop</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Kotlin Higher-Order Functions]]></title>
            <link>https://medium.com/kjcoop/kotlin-higher-order-functions-828dedb7185b?source=rss-4f18c87b3573------2</link>
            <guid isPermaLink="false">https://medium.com/p/828dedb7185b</guid>
            <category><![CDATA[kotlin]]></category>
            <category><![CDATA[android-app-development]]></category>
            <dc:creator><![CDATA[Jungwook Park]]></dc:creator>
            <pubDate>Sun, 20 May 2018 17:46:12 GMT</pubDate>
            <atom:updated>2018-05-23T04:32:52.377Z</atom:updated>
            <content:encoded><![CDATA[<p><a href="https://kotlinlang.org/docs/reference/lambdas.html#higher-order-functions">코틀린</a>에서는 아래와 같이 정의하고 있다.</p><p>A higher-order function is a function that takes functions as parameters, or returns a function.</p><p>함수를 인자로 받거나, 함수를 반환하면 higher-order 함수이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/610/0*zA17_4xmX3wqLOg-.jpg" /></figure><ul><li>인자로 사용하는 경우</li></ul><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/3a66178624f077e4af93f9327c91b8c5/href">https://medium.com/media/3a66178624f077e4af93f9327c91b8c5/href</a></iframe><p>21~23 라인의 higherOrderFunction는 세 개의 인자를 가지고 있는데,</p><p>Int, Int, (Int, Int) -&gt; Int 세개 인자를 가지고 있으며 맨 마지막 인자가 함수이기 때문에 higher-order 함수이다.</p><p>(Int, Int) -&gt; Int 를 block으로 이름 붙여 함수 안에서 사용한 점이 포인트.</p><p>sum과 sum2 함수는 동일하며 인자 맨 마지막이 lambda 인 경우 괄호 밖으로 빼낼 수 있어 기술 형식만 차이가 있다.</p><ul><li>반환하는 경우</li></ul><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/1c5d2a9e7804e08840af278370d43d8e/href">https://medium.com/media/1c5d2a9e7804e08840af278370d43d8e/href</a></iframe><p>9~11 라인의 higherOrderFunction2는 인자 없이 (Int, Int) -&gt; Int 리턴 타입만 가지고 있기 때문에 higher-order 함수이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=828dedb7185b" width="1" height="1"><hr><p><a href="https://medium.com/kjcoop/kotlin-higher-order-functions-828dedb7185b">Kotlin Higher-Order Functions</a> was originally published in <a href="https://medium.com/kjcoop">kjcoop</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Android Studio 정적 데이터 흐름 분석]]></title>
            <link>https://medium.com/kjcoop/android-studio-%EC%A0%95%EC%A0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9D%90%EB%A6%84-%EB%B6%84%EC%84%9D-bc9c744ec731?source=rss-4f18c87b3573------2</link>
            <guid isPermaLink="false">https://medium.com/p/bc9c744ec731</guid>
            <category><![CDATA[android-studio]]></category>
            <category><![CDATA[android-development]]></category>
            <dc:creator><![CDATA[Jungwook Park]]></dc:creator>
            <pubDate>Sat, 05 May 2018 14:09:30 GMT</pubDate>
            <atom:updated>2018-05-05T14:09:30.924Z</atom:updated>
            <content:encoded><![CDATA[<p>break point 로 call stack 따라 가는 방법도 좋지만 정적 분석으로도 알 수 있다.</p><p>원하는 곳에서 우클릭 &gt; Analyze &gt; Analyze Data Flow to Here / from Here</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/720/1*I5wPAj8oBxYSUvEywh3F4g.png" /></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bc9c744ec731" width="1" height="1"><hr><p><a href="https://medium.com/kjcoop/android-studio-%EC%A0%95%EC%A0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9D%90%EB%A6%84-%EB%B6%84%EC%84%9D-bc9c744ec731">Android Studio 정적 데이터 흐름 분석</a> was originally published in <a href="https://medium.com/kjcoop">kjcoop</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ADB idea]]></title>
            <link>https://medium.com/kjcoop/adb-idea-ef727cbd1519?source=rss-4f18c87b3573------2</link>
            <guid isPermaLink="false">https://medium.com/p/ef727cbd1519</guid>
            <category><![CDATA[android-studio-plugins]]></category>
            <category><![CDATA[android-app-development]]></category>
            <dc:creator><![CDATA[Jungwook Park]]></dc:creator>
            <pubDate>Sat, 05 May 2018 13:53:53 GMT</pubDate>
            <atom:updated>2018-05-05T14:12:57.118Z</atom:updated>
            <content:encoded><![CDATA[<p>Android studio 에서 쓰기 편한 플러그인 (데이터 삭제/권한 회수)</p><p><a href="https://github.com/pbreault/adb-idea">pbreault/adb-idea</a></p><p>설치 후 <a href="http://www.jetbrains.com/idea/webhelp/navigating-to-action.html">Find Action</a> 에서 adb 를 입력해 편하게 사용할 수 있다.</p><p>앱 데이터 삭제 / 권한 회수는 개발에 매우 편리하다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*-giFOWQgPn4a7EXdUC5p5w.png" /></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ef727cbd1519" width="1" height="1"><hr><p><a href="https://medium.com/kjcoop/adb-idea-ef727cbd1519">ADB idea</a> was originally published in <a href="https://medium.com/kjcoop">kjcoop</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
    </channel>
</rss>