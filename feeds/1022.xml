<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>한장현입니다.</title>
<link>https://han41858.tistory.com/</link>
<description></description>
<language>ko</language>
<pubDate>Mon, 13 May 2019 10:33:35 +0900</pubDate>
<generator>TISTORY</generator>
<managingEditor>한장현</managingEditor>
<image>
<title>한장현입니다.</title>
<url>http://cfile28.uf.tistory.com/image/2167754157791CB6234D18</url>
<link>https://han41858.tistory.com</link>
<description></description>
</image>
<item>
<title>angular.kr 사이트를 오픈합니다.</title>
<link>https://han41858.tistory.com/48</link>
<description>&lt;p&gt;안녕하세요. 한장현입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;회사를 다녀서 그렇기도 하지만 블로그에 거의 글을 쓰지 않았습니다.&lt;/p&gt;&lt;p&gt;작년에는 Angular 메이저 버전 업데이트과 관련된 글 2개가 전부였네요 ㅎ&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그동안 이런걸 만들고 있었습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99E71E4C5C37489B0E&quot; filemime=&quot;image/jpeg&quot; filename=&quot;main.png&quot; height=&quot;776&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 사이트는 &lt;a href=&quot;https://angular.io/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Angular 공식 가이드 문서&lt;/a&gt;를 생성하는&amp;nbsp;&lt;a href=&quot;https://github.com/angular/angular/tree/master/aio&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;angular.io 프로젝트&lt;/a&gt;를 번역해서 만든 웹사이트입니다.&lt;/p&gt;&lt;p&gt;angular.io가 워낙 잘 만들어져 있어서&amp;nbsp;사이트를 다루는 데에 큰 문제는 없었습니다.&lt;/p&gt;&lt;p&gt;(버그가 있어서 이슈로 올렸더니 금방 고쳐줬어요.)&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;저는 별거 안했는데 PWA도 잘 되더라구요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99DDA8465C3748FD03&quot; filemime=&quot;image/jpeg&quot; filename=&quot;pwa.png&quot; height=&quot;525&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;번역 작업을 언제부터 시작했는지는 기억이 잘 안나네요.&lt;/p&gt;&lt;p&gt;2017년 말부터 시작했던 것 같으니&amp;nbsp;1년 좀 넘게 작업하고 있는&amp;nbsp;것 같습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;혼자서 공부하려고 시작했는데 내용이 너무 방대해서 힘들긴 합니다.&lt;/p&gt;&lt;p&gt;웹 사이트로 빌드된 용량이 45MB나 될 줄 몰랐어요.&lt;/p&gt;&lt;p&gt;그래도 공식 가이드 문서의 문장이나 예제 코드를 하나하나 꼼꼼히 볼 수 있는 좋은 기회라고 생각하고 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;작업하던 중에 angular.kr 도메인이 풀렸길래 낼름 집어왔는데, 제 용도에 맞게 사용할 수 있어서 다행이네요 ㅎ&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;원래 계획으로는 모든 내용을 번역한 이후에 사이트를 오픈하려고 했습니다.&lt;/p&gt;&lt;p&gt;그런데 Google Angular 코어 팀이 일을 너무 열심히 하더라구요.&lt;/p&gt;&lt;p&gt;최신 코드로 머지하고 한달쯤 번역하다 보면 커밋이 500개쯤 쌓여있어요.&lt;/p&gt;&lt;p&gt;다 끝내고 오픈하면 더 좋겠지만, 지금까지 작업한 내용이라도 Angular를 사용하는 분들께 도움이 되는 것이 낫겠다 생각해서 사이트를 오픈하기로 했습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;번역은 80% 정도 끝난 것 같습니다.&lt;/p&gt;&lt;p&gt;사이트를 오픈하고 나서도 틈틈이 번역 안된 문서들 번역하고, 새 버전 나오면 되도록 빠르게 업데이트 하려고 합니다.&lt;/p&gt;&lt;p&gt;다 하고 나면 또 새로운 커밋이 있겠죠. 하하하.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;번역이 잘못되었거나 이상한 내용이 있으면&amp;nbsp;&lt;a href=&quot;https://github.com/han41858/angular-ko/issues&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;이슈&amp;nbsp;게시판&lt;/a&gt;에 올려 주시면 됩니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Angular를 사용하시는 분들에게&amp;nbsp;미약하게나마 도움이 되기를 바랍니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;감사합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;ps. 초반에 함께 했지만 육아에 전념하느라 지금은 함께 하지 못하는&amp;nbsp;이영빈님 아쉽네요...&lt;/p&gt;&lt;p&gt;ps. 묵묵히 지켜봐 주시는 루비페이퍼 한창훈 대표님께 감사드립니다. 하기로 한 건 잊지 않고 진행하겠습니다 ㅎ&lt;/p&gt;&lt;p&gt;ps. GitHub Page 설정에 막혔을 때 해결방법을 찾아&amp;nbsp;주신 정문창(Murry Jeong)님께 감사드립니다.&lt;/p&gt;</description>
<author>한장현</author>
<guid>https://han41858.tistory.com/48</guid>
<comments>https://han41858.tistory.com/48#entry48comment</comments>
<pubDate>Thu, 10 Jan 2019 23:09:32 +0900</pubDate>
</item>
<item>
<title>Angular v7 릴리즈 노트</title>
<link>https://han41858.tistory.com/47</link>
<description>&lt;p&gt;&amp;nbsp;안녕하세요. 한장현입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;10월 19일에&amp;nbsp;Angular 7.0.0 버전이 발표되었습니다. Angular는 6개월마다 메이저 버전을 올리고 있는데, 너무 빨리 올라가는 것 같아 약간 부담스럽네요... ㅎ&lt;/p&gt;&lt;p&gt;&amp;nbsp;7.0.0 버전에서는 어떤 내용이 변경되었는지 알아봅시다. &lt;a href=&quot;https://blog.angular.io/version-7-of-angular-cli-prompts-virtual-scroll-drag-and-drop-and-more-c594e22e7b8c&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Angular 공식 블로그&lt;/a&gt;를 참고했습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;* 추가&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/angular/angular/blob/master/CHANGELOG.md&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;CHANGELOG.md&lt;/a&gt; 를 확인해봤는데 기능이 없어지거나 deprecated 된 것은 없어보입니다.&lt;/p&gt;&lt;p&gt;사용하던 Angular 애플리케이션에 그대로 적용해도 문제는 없을 것 같습니다.&lt;/p&gt;&lt;p&gt;다행이네요 :)&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;hr class=&quot;tx-hr-image-4&quot; style=&quot;background: url(//i1.daumcdn.net/deco/contents/horizontalrule/line08.gif?v=2) repeat-x scroll left; height: 15px; border:0; width:54px; margin:30px auto&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;b&gt;&lt;br /&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;b&gt;Angular 7 - CLI 프롬프트, 버추얼 스크롤, 드래그 &amp;amp; 드랍&lt;/b&gt;&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;드디어 Angular 7.0.0이 나왔습니다! 이 버전은 코어 프레임워크와 Angular Material, Angular CLI를 포함해서 플랫폼 전체에 적용되는 새 버전입니다. 이번 버전부터 툴 체인에 새로운 기능이 추가되었으며, 파트너 프로젝트 지원 기능도 강화되었습니다.&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*CQKUmJrBs-523I4GOiEUaA.gif&quot; border=&quot;0&quot;&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;버추얼 스크롤을 사용하면 애플리케이션 반응 속도를 향상시킬 수 있습니다.&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;v7로 업데이트하는 방법&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;지금까지는 Angular 버전을 업데이트할 때&amp;nbsp;&lt;a href=&quot;https://update.angular.io/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;이 사이트&lt;/a&gt;를 참고하는 것이 일반적이었습니다. 하지만 v6에 도입된 기능 덕분에 v6에서 v7로 업데이트하는 것은 아주 간단합니다. 다음 명령 하나만 실행하면 됩니다:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ng update @angular/cli @angular/core&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;이 명령을 실행해본 사람들에 의하면 이 작업은 오래 걸리지 않으며 10분 안에 끝났다고 합니다 :)&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;CLI 프롬프트&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;CLI는 이제 사용자가 &lt;code class=&quot;language-bash&quot;&gt;ng new&lt;/code&gt;나 &lt;code class=&quot;language-bash&quot;&gt;ng add @angular/material&lt;/code&gt;과 같은 명령을 실행했을 때 프롬프트로 동작합니다. Angular 라이브러리가 지원하는 기능을 좀 더 편하게 제공할 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;CLI 프롬프트는 &lt;a href=&quot;https://blog.angular.io/schematics-an-introduction-dc1dfbc2a2b2&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;스키매틱(schematics&lt;/a&gt;&lt;a href=&quot;https://blog.angular.io/schematics-an-introduction-dc1dfbc2a2b2&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;)&lt;/a&gt;에&amp;nbsp;정의된 대로 동작하기 때문에 스키매틱을 지원하는 패키지는 모두 이 기능을 사용할 수 있습니다. 스키매틱 콜렉션에 &lt;code class=&quot;language-bash&quot;&gt;x-prompt&lt;/code&gt; 키만 추가하면 됩니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/StephenFluin/aad275e49bd96fe7fc35385f5a8d7020.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;애플리케이션 성능 향상&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;Angular 팀은 Angular 생태계를 지속적으로 분석하면서 성능 향상을 위해 힘써왔습니다. 그러던 중 많은 개발자가 개발용으로만&amp;nbsp;필요한&amp;nbsp;&lt;code class=&quot;language-bash&quot;&gt;reflect-metadata&lt;/code&gt; 폴리필을 운영용에도 사용하고 있다는 것을 발견했습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;이 문제를 해결하기 위해 &lt;code class=&quot;language-bash&quot;&gt;ng update&lt;/code&gt; 명령으로 v7을 도입하게 되면 자동으로 &lt;code class=&quot;language-bash&quot;&gt;polyfills.ts&lt;/code&gt; 파일에서 이 폴리필을 제거합니다. 이 폴리필은 JIT 컴파일러를 사용해서 애플리케이션을 빌드할 때 자동으로 포함되며, 운영용 빌드에는 제거된 채로 빌드될 것입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;운영용 빌드에 적용되는 내용이 또 하나 있습니다. 이제 애플리케이션 번들링 결과물의&amp;nbsp;크기가 2MB 이상이면 경고가 표시되며, 5MB 이상이면 에러가 표시됩니다.&amp;nbsp; 에러가 발생하는 기준값은 &lt;code class=&quot;language-bash&quot;&gt;angular.json&lt;/code&gt;에서 변경할 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/StephenFluin/4bfd4cf9633a9f2222784bfb08e4212e.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;경고가 발생한 애플리케이션을&amp;nbsp;Chrome에서 실행시키면 Chrome 데이터 절약 모드가 동작하면서&amp;nbsp;다음과 같은 경고 메시지가 표시될 수도 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*jXHBMok5cNnkXD8O0a8gAg.png&quot; border=&quot;0&quot;&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;Chrome 데이터 절약 모드&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;Angular Material &amp;amp; CDK&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;2018년 들어 Material 디자인이&amp;nbsp;&lt;a href=&quot;https://www.youtube.com/watch?v=1Dh8ZBQp9jo&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;많이 변경되었습니다&lt;/a&gt;. Angular의 버전업에 맞춰 Angular Material도 v7로 업데이트 되었으며, Material 디자인 표준에 맞춰 일부 스타일이 변경되었습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*lgZYt3RBGM_c7HUcg85Zgg.png&quot; border=&quot;0&quot;&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;Material 디자인을 사용하던 애플리케이션은 개발자가 따로 작업하지 않아도 새로운 디자인 표준이 적용됩니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;그리고 CDK에 새로운 기능이 추가되었습니다. 이번 버전부터는 드래그 &amp;amp; 드랍을 제공하는 &lt;code class=&quot;language-bash&quot;&gt;DragDropModule&lt;/code&gt;과 버추얼 스크롤을 제공하는 &lt;code class=&quot;language-typescript&quot;&gt;ScrollingModule&lt;/code&gt;이 제공됩니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;버추얼 스크롤&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;버추얼 스크롤을 사용하면 현재 화면에 보이는 엘리먼트만 DOM에 추가하며 화면에 보이지 않는 엘리먼트는 자동으로 DOM에서 제거할 수 있습니다. 이 기능을 사용하면 길이가 아주 긴 리스트를 다룰 때 사용자에게 좀 더 나은 UX를 제공할 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/StephenFluin/fcbc2d573aa1b7d1c33bb81b0224ddbb.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://material.angular.io/cdk/scrolling/overview&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;버추얼 스크롤에 대해 자세하게 알아보세요.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;드래그 &amp;amp; 드랍&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*i30ZQdBC7CKbXXdOrUNQcg.gif&quot; border=&quot;0&quot;&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;드래그 &amp;amp; 드랍을 사용한 대시보드 예제&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;이제 CDK를 통해 드래그 &amp;amp; 드랍이 제공됩니다. 사용자가 항목을 옮기면 렌더링도 자동으로 수행되며, 리스트의 실제 순서를 변경하는 헬퍼 메소드(&lt;code class=&quot;language-typescript&quot;&gt;moveItemInArray&lt;/code&gt;)와 리스트끼리 아이템을 주고받는 메소드(&lt;code class=&quot;language-typescript&quot;&gt;transferArrayItem&lt;/code&gt;)도 제공됩니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/StephenFluin/c570de6689d6e4582c84ffc54623f1cc.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/StephenFluin/913250779e97507d01ca05da567da305.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://material.angular.io/cdk/drag-drop/overview&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;드래그 &amp;amp; 드랍에 대해 자세하게 알아보세요.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;Select 엘리먼트의 접근성 개선&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;code class=&quot;language-html&quot;&gt;mat-form-field&lt;/code&gt; 안에 사용되는 네이티브 &lt;code class=&quot;language-xml&quot;&gt;select&lt;/code&gt; 엘리먼트의 접근성이 개선되었습니다. 이제 &lt;code class=&quot;language-xml&quot;&gt;mat-select&lt;/code&gt;를 사용해도 네이티브 select 엘리먼트와 비슷한 성능, 접근성을 확보할 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://material.angular.io/components/select/overview&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;mat-select와 mat-form-field에 대해 자세하게 알아보세요.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;Angular Elements&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;이제 Angular Element에도 컨텐츠 프로젝션을 사용할 수 있습니다. 이 기능은 웹 표준을 사용합니다.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;my-custom-element&amp;gt;This content can be projected!&amp;lt;/my-custom-element&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;파트너 지원&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;Angular는 Angular를 사용하는 개발자들의 커뮤니티 덕분에&amp;nbsp;수많은 혁신을 이룰 수 있었습니다. 이에 보답하기 위해 몇 가지 커뮤니티 프로젝트와 함께 작업하며 Angular를 더욱 개선하고&amp;nbsp;있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*5dDsNd840QO7btuZUsnBYw.gif&quot; border=&quot;0&quot;&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;StackBlitz 2.0에서는 여러 파일을 동시에 열어놓고 작업할 수 있습니다.&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;ul style=&quot;list-style-type: square;&quot;&gt;&lt;li&gt;&lt;a href=&quot;https://angularconsole.com/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;Angular Console&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt; - 로컬 개발환경에서 Angular 프로젝트를 생성하고 실행할 수 있는 GUI 콘솔입니다.&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/angular/angularfire2&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;@angular/fire&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt; - AngularFire의 npm 주소가 변경되었습니다. 이제 AngularFire는 Angular의 공식 릴리즈와 함께 배포됩니다.&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.nativescript.org/code-sharing/intro&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;NativeScript&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt; - NativeScript를 사용하면 웹에서 동작하는 프로젝트를 네이티브 앱으로 빌드할 수 있습니다.&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://stackblitz.com/fork/angular&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;StackBlitz&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt; - StackBlitz 2.0부터&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;https://angular.io/guide/language-service&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;Angular 언어 지원 서비스&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;가 도입되었습니다. 여러 탭을 열고 동시에 작업할 수도 있습니다.&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;문서 업데이트&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;Angular 팀은 Angular 가이드 문서를 최신 버전으로 유지하는 것에도 힘쓰고 있습니다. 이제 &lt;a href=&quot;https://angular.io/cli&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Angular CLI도 angular.io 가이드 문서에&lt;/a&gt; 함께 제공됩니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;의존성 패키지 버전업&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;Angular에서 사용하는 주요 서드 파티 프로젝트의 버전이 다음과 같이 업데이트되었습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;ul style=&quot;list-style-type: square;&quot;&gt;&lt;li&gt;&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;TypeScript 3.1&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/ReactiveX/rxjs/blob/master/CHANGELOG.md#630-2018-08-30&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;RxJS 6.3&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://nodejs.org/en/blog/release/v10.0.0/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;Node 10&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt; - Node 8 버전 지원은 계속되며 이제 Node 10 버전도 지원됩니다.&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;Ivy는?&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;차세데 렌더링 파이프라인인 &lt;a href=&quot;https://youtu.be/dIxknqPOWms?t=1360&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Ivy는 아직 개발중&lt;/a&gt;이기&amp;nbsp;때문에&amp;nbsp;v7 릴리즈에 포함되지 않았습니다. 지금은 이미 동작하고 있는 애플리케이션에 Ivy가 호환되는지 확인하고 있으며, 몇 달 안에 Ivy 프리뷰를 발표할 수 있을 것 같습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;Angular에 대한 최신 정보는 &lt;a href=&quot;https://blog.angular.io/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Angular 공식 블로그&lt;/a&gt;와 &lt;a href=&quot;https://twitter.com/angular&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;트위터&lt;/a&gt;, &lt;a href=&quot;https://www.youtube.com/angular&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;유튜브&lt;/a&gt;를 통해 계속 제공됩니다.&lt;/p&gt;</description>
<category>Angular 7.0.0</category>
<author>한장현</author>
<guid>https://han41858.tistory.com/47</guid>
<comments>https://han41858.tistory.com/47#entry47comment</comments>
<pubDate>Sun, 21 Oct 2018 01:25:26 +0900</pubDate>
</item>
<item>
<title>Angular v6.0.0 릴리즈 노트</title>
<link>https://han41858.tistory.com/45</link>
<description>&lt;p&gt;안녕하세요. 한장현입니다.&lt;/p&gt;&lt;p&gt;오랜만에 글을 쓰네요 ㅎ 회사일에 이래저래 치이다보니.. ㅎㅎ&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Angular 6.0.0 버전이 발표되었다는 반가운 소식으로 찾아왔습니다.&lt;/p&gt;&lt;p&gt;Angular 2가 발표된 후로 Angular는 메이저 버전을 정기적으로 올리겠다고 했고, 이전 버전인 5.0.0가 2017년 11월 1일에 나온지 6개월만에 메이저 버전을 새로 발표했습니다.&lt;/p&gt;&lt;p&gt;이번 글에서는 6.0.0에 어떤 내용이 변경되었는지 알아봅니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;원문은 &lt;a href=&quot;https://blog.angular.io/version-6-of-angular-now-available-cc56b0efa7a4&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Angular 공식 블로그 릴리즈 노트&lt;/a&gt;입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;hr class=&quot;tx-hr-image-4&quot; style=&quot;background: url(//i1.daumcdn.net/deco/contents/horizontalrule/line08.gif?v=2) repeat-x scroll left; height: 15px; border:0; width:54px; margin:30px auto&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;Angular 6 버전이 발표되었습니다.&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Angular 6.0.0 버전이 드디어 발표되었습니다! 이번 버전은 메이저 버전이 바뀐 배포버전이며, 이제 Angular는 프레임워크로만 머무르지 않고 Angular를 더 쉽게 활용할 수 있는 도구로 발전했습니다.&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이번 버전에서는 Angular 프레임워크를 구성하는 패키지들(&lt;code class=&quot;language-typescript&quot;&gt;@angular/core&lt;/code&gt;, &lt;code class=&quot;language-typescript&quot;&gt;@angular/common&lt;/code&gt;, &lt;code class=&quot;language-typescript&quot;&gt;@angular/compiler&lt;/code&gt; 등) 외에도 Angular CLI나 Angular Material + CDK 의 메이저 버전을 맞추는 데에도 신경을 썼습니다. Angular 6.0.0 버전이 발표된 시점을 기준으로 이 패키지들은 모두 6.0.0 버전입니다. 버전을 맞추면서 이 패키지들의 호환성을 보완하는 데에도 노력했습니다. 이제 개별 패키지의 버그나 마이너 패치가 있더라도 프로젝트 전체를 고려하며 수정될 것입니다.&lt;/p&gt;&lt;p&gt;각 패키지의 변동 내역은 &lt;a href=&quot;https://github.com/angular/angular/blob/master/CHANGELOG.md&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Angular 프레임워크&lt;/a&gt;, &lt;a href=&quot;https://github.com/angular/material2/blob/master/CHANGELOG.md&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;material+cdk&lt;/a&gt;, &lt;a href=&quot;https://github.com/angular/angular-cli/releases&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;cli&lt;/a&gt; 개별 문서를 확인해 보세요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;ng update&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;CLI 커맨드에 &lt;code class=&quot;language-bash&quot;&gt;ng update &amp;lt;package&amp;gt;&lt;/code&gt; 명령이 추가되었습니다. 이 명령은 &lt;code class=&quot;language-bash&quot;&gt;package.json&lt;/code&gt; 파일을 분석하고 애플리케이션의 Angular 버전을 어떻게 업데이트할 수 있을지 정보를 제공합니다. 이 정보를 활용하면 &lt;a href=&quot;https://update.angular.io/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Angular 업데이트 가이드&lt;/a&gt;를 좀 더 효율적으로 활용할 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-bash&quot;&gt;ng update&lt;/code&gt; 명령은 npm 패키지들의 의존성에 대한 정보만 제공하지 않고, 호환되는 의존성을 제대로 맞추도록 활용할 수 있습니다. 다만, 이 명령과 호환되지 않는 서드 파티 패키지들은 &lt;a href=&quot;https://blog.angular.io/schematics-an-introduction-dc1dfbc2a2b2&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;조금 더 복잡한 방법&lt;/a&gt;을 사용해야 하긴 합니다. 앞으로 서드 파티 패키지도 &lt;code class=&quot;language-bash&quot;&gt;ng update&lt;/code&gt; 명령과 호환이 되면 자동으로 버전을 업데이트할 수 있을 것입니다.&lt;/p&gt;&lt;p&gt;하지만 &lt;code class=&quot;language-bash&quot;&gt;ng update&lt;/code&gt;가 패키지 매니저를 대체하는 것은 아니며, 기존에 사용하던 npm이나 yarn을 활용하는 또 다른 방법으로 이해해야 합니다. &lt;code class=&quot;language-bash&quot;&gt;ng update&lt;/code&gt; 명령을 실행하면서 의존성 목록이 변경되면 이 내용을 프로젝트에 반영할 때도 기존 패키지 매니저를 활용합니다.&lt;/p&gt;&lt;p&gt;예를 들어 &lt;code class=&quot;language-bash&quot;&gt;ng update @angular/core&lt;/code&gt; 명령을 실행하면 Angular 프레임워크의 전체 패키지는 물론, RxJS와 TypeScript, 호환된 것으로 확인된 서드 파티 패키지도 모두 최신 버전으로 업데이트 합니다. 그리고 이 때 &lt;code class=&quot;language-bash&quot;&gt;rxjs-compat&lt;/code&gt; 패키지가 자동으로 설치되기 때문에 RxJS v6도 자연스럽게 애플리케이션에 도입할 수 있습니다.&lt;/p&gt;&lt;p&gt;몇개월만 지나면 좀 더 많은 라이브러리나 패키지가 &lt;code class=&quot;language-bash&quot;&gt;ng update&lt;/code&gt; 명령과 호환이 될 것이라고 생각합니다. 기업용 컴포넌트 라이브러리 일부가 &lt;code class=&quot;language-bash&quot;&gt;ng update&lt;/code&gt; 를 지원하는 작업에 들어갔다는 정보도 들리고 있습니다. 패키지들이 이 명령과 호환이 되면 개발자가 패키지 버전을 수동으로 업데이트하는 시간을 많이 줄일 수 있을 것입니다.&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-bash&quot;&gt;ng update&lt;/code&gt; 명령이 어떻게 동작하는지 확인하려면 &lt;a href=&quot;https://github.com/angular/devkit/blob/master/docs/specifications/update.md&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;이 문서&lt;/a&gt;를 확인해 보세요. 그리고 &lt;code class=&quot;language-bash&quot;&gt;ng update&lt;/code&gt;와 호환이 되는 패키지를 만들려면 &lt;a href=&quot;https://github.com/ReactiveX/rxjs/blob/8c5d680494a8bc986e638f6138447917c7ba180f/package.json#L231-L233&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;rxjs가 이미 한 것처럼&lt;/a&gt; &lt;code class=&quot;language-bash&quot;&gt;package.json&lt;/code&gt;에 &lt;code class=&quot;language-bash&quot;&gt;&lt;a href=&quot;https://github.com/ReactiveX/rxjs/blob/master/migrations/collection.json&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;collection.json&lt;/a&gt;&lt;/code&gt;&lt;a href=&quot;https://github.com/ReactiveX/rxjs/blob/master/migrations/collection.json&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt; 파일을 지정&lt;/a&gt;하면 됩니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;ng add&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;CLI에는 &lt;code class=&quot;language-bash&quot;&gt;ng add &amp;lt;package&amp;gt;&lt;/code&gt; 명령도 추가되었습니다. 이 명령을 실행하면 프로젝트에 npm 패키지를 설치하면서 패키지에 정의된 설치 스크립트도 자동으로 실행합니다. 이 명령을 실행하는 것은 패키지를 단순하게 설치하는 것 외에 프로젝트 설정 자체를 조정하기도 합니다.&lt;/p&gt;&lt;p&gt;이 명령은 다음과 같이 활용할 수 있습니다.&lt;/p&gt;&lt;ul style=&quot;list-style-type: square;&quot;&gt;&lt;li&gt;&lt;code class=&quot;language-bash&quot;&gt;ng add @angular/pwa&lt;/code&gt; - 앱 매니페스트와 서비스 워커 파일을 생성하면서 애플리케이션을 PWA용으로 전환합니다.&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;language-bash&quot;&gt;ng add @ng-bootstrap/schematics&lt;/code&gt; - 애플리케이션에 &lt;a href=&quot;https://ng-bootstrap.github.io/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;ng-bootstrap&lt;/a&gt;을 적용합니다.&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;language-bash&quot;&gt;ng add @angular/material&lt;/code&gt; - Angular Material을 설치하고 테마를 준비하며, &lt;code class=&quot;language-bash&quot;&gt;ng generate&lt;/code&gt;&amp;nbsp;명령으로 생성할 수 있는 컴포넌트를 추가합니다.&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;language-bash&quot;&gt;ng add @clr/angular@next&lt;/code&gt; - VMWare에 사용하는 Clarity를 설치하고 초기 설정을 수행합니다.&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;language-bash&quot;&gt;ng add @angular/elements&lt;/code&gt; - Angular Elements에 사용되는 &lt;code class=&quot;language-bash&quot;&gt;document-register-element.js&lt;/code&gt; 폴리필을 추가하고 의존성 패키지를 설치합니다.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;p&gt;&lt;code class=&quot;language-bash&quot;&gt;ng add&lt;/code&gt; 명령은 npm 레지스트리를 그대로 활용하면서 패키지에 필요한 추가 동작을 실행할 수 있기 때문에, 좀 더 많은 라이브러리와 커뮤니티가 이 생태계를 함께 발전시켜 나가기를 희망합니다.&lt;/p&gt;&lt;p&gt;ng-add 메커니즘을 활용하는 패키지를 만들려면 &lt;a href=&quot;https://github.com/angular/material2/blob/master/src/lib/schematics/collection.json&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Angular Material이 ng-add 호환성을 준비한 방법&lt;/a&gt;을 확인해 보세요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;Angular Elements&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Angular Elements가 처음 도입되었으며, 이 버전에서는 기존에 사용하던 Angular 컴포넌트를 부트스트랩 과정에서 커스텀 엘리먼트로 쉽게 등록할 수 있도록 하는 것에 주력했습니다. 이 로직은 Angular 가이드 문서인 angular.io에 광범위하게 적용되어 있으며, 템플릿으로 지정한 HTML 문서를 좀 더 동적으로 활용할 수 있는 방안을 마련할 것입니다. 이 개념이 좀 더 확립되면 HTML 문서를 정적으로 활용할 때도 컴포넌트를 수동으로 부트스트랩해야 하는 수고로움을 덜 수 있을 것입니다.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://stackblitz.com/edit/angular-f3nrpv?file=app%2Fapp.module.ts&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;컴포넌트를 커스텀 엘리먼트로 등록하는 예제&lt;/a&gt;를 확인해 보거나 &lt;a href=&quot;https://angular.io/guide/elements&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Angular Elements의 개념&lt;/a&gt;에 대해 좀 더 확인해 보세요.&lt;/p&gt;&lt;p&gt;커뮤니티에서 제공하는 &lt;a href=&quot;https://www.youtube.com/watch?v=4u9_kdkvTsc&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Angular Elements Quick Start 영상&lt;/a&gt;도 추천합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;Angular Material + CDK 컴포넌트&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;이번 버전에서 가장 눈에 띄는 것은 새로운 트리 컴포넌트가 추가된 것입니다. 이 트리 컴포넌트는 데이터의 계층 구조를 표현하는 데에 사용되며, 기존에 CDK에서 제공하던 데이터 테이블 컴포넌트와 비슷하게 사용합니다. 그리고&amp;nbsp;Angular Material 디자인 스타일에 어울리도록 트리를 구성할 수도 있습니다. 이 컴포넌트에 대해서는 &lt;a href=&quot;https://www.youtube.com/watch?v=s0Vy3sLbeyA&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;영상&lt;/a&gt;이나 &lt;a href=&quot;https://docs.google.com/presentation/d/1DmWdfr8j25owK2ac5qlt7oeX6HpxQnXEGwmHIjf6EHI&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;슬라이드&lt;/a&gt;를 보는 것을 추천합니다. 새 컴포넌트는 Material 디자인을 따르는 것을 &lt;code class=&quot;language-bash&quot;&gt;mat-tree&lt;/code&gt;, Material 디자인을 적용하지 않은 것을 &lt;code class=&quot;language-bash&quot;&gt;cdk-tree&lt;/code&gt;로 구분합니다.&lt;/p&gt;&lt;p&gt;트리 컴포넌트 외에도, 새로운 &lt;a href=&quot;https://material.angular.io/components/badge/overview&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;뱃지 컴포넌트&lt;/a&gt;와 &lt;a href=&quot;https://material.angular.io/components/bottom-sheet/overview&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;하단 팝업 컴포넌트&lt;/a&gt;도 추가되었습니다. 뱃지는 '아직 읽지 않은 정보'와 같은 아주 간단한 정보를 표시하는 데에 적합합니다. 그리고 하단 팝업 컴포넌트는 화면 아래쪽에서 올라오는 팝업이며, 기존 셀렉트 태그를 모바일에 좀 더 어울리게 개선한 컴포넌트입니다.&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-bash&quot;&gt;@angular/cdk/overlay&lt;/code&gt; 패키지도 유심히 볼 필요가 있습니다. 이번 6.0.0 버전에서는 &lt;a href=&quot;https://material.angular.io/cdk/overlay/overview#position-strategies&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;새로운 위치 지정 로직&lt;/a&gt;을 도입했기 때문에 팝업을 어떠한 상황에서도 어울리게, 좀 더 효율적으로 구성할 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;Angular Material 스타터 컴포넌트&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*vD2u7I_a_uxs33qcdo2R6g.gif&quot; border=&quot;0&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-bash&quot;&gt;ng add @angular/material&lt;/code&gt; 명령을 한 번 실행하면 Angular Material을 프로젝트에 설치하면서, `ng generate` 명령으로 만들 수 있는 Angular Material 스타일 컴포넌트를 3개 추가합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&lt;b&gt;Material 사이드 네비게이션&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;앱 이름과 좌측 네비게이션을 구성하는 컴포넌트를 생성할 수 있습니다. 이 컴포넌트는 반응형 웹도 지원합니다.&lt;/p&gt;&lt;p&gt;생성방법 : &lt;code class=&quot;language-bash&quot;&gt;ng generate @angular/material:material-nav --name=my-nav&lt;/code&gt;&lt;/p&gt;&lt;p&gt;이 명령을 실행하면 다음과 같은 컴포넌트가 만들어집니다:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*PKi-6dOhlb61g8CM2JCx-Q.png&quot; border=&quot;0&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&lt;b&gt;Material 대시보드&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;대시보드 컴포넌트를 생성하며 이 컴포넌트는 카드 디자인을 활용하는 그리드 리스트로 구성됩니다.&lt;/p&gt;&lt;p&gt;생성방법 : &lt;code class=&quot;language-bash&quot;&gt;ng generate @angular/material:material-dashboard --name=my-dashboard&lt;/code&gt;&lt;/p&gt;&lt;p&gt;이 명령을 실행하면 다음과 같은 컴포넌트가 만들어집니다:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*De1Vnm2m1yID_EL_xRYIyw.png&quot; border=&quot;0&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&lt;b&gt;Material 데이터 테이블&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;정렬과 페이징 기능을 지원하는 데이터 테이블 컴포넌트를 만들 수 있습니다.&lt;/p&gt;&lt;p&gt;생성방법 : &lt;code class=&quot;language-bash&quot;&gt;ng generate @angular/material:material-table --name=my-table&lt;/code&gt;&lt;/p&gt;&lt;p&gt;이 명령을 실행하면 다음과 같은 컴포넌트가 만들어집니다:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*2MO1hno7d30iTPIZ9CnBzw.png&quot; border=&quot;0&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Angular Material에서 지원하는 문법을 좀 더&amp;nbsp;확인하려면 &lt;a href=&quot;http://material.angular.io/guide/schematics&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;이 문서&lt;/a&gt;를 확인해 보세요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;CLI 워크스페이스 관리&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Angular CLI v6에서는 이제 여러 애플리케이션이나 라이브러리를 워크스페이스 하나로 관리할 수 있습니다. 그리고 기존에 사용하던 &lt;code class=&quot;language-bash&quot;&gt;.angular-cli.json&lt;/code&gt; 파일 대신 &lt;code class=&quot;language-bash&quot;&gt;angular.json&lt;/code&gt; 파일을 사용합니다.&lt;/p&gt;&lt;p&gt;각각의 CLI 워크스페이스는 여러 프로젝트를 포함할 수 있으며, 각각의 프로젝트는 여러 배포 환경을 가질 수 있고, 각 배포 환경을 개별 설정할 수 있습니다.&lt;/p&gt;&lt;p&gt;새로운 CLI 환경 설정파일에 대해 알아보려면 &lt;a href=&quot;https://github.com/angular/angular-cli/wiki/angular-workspace&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;이 문서&lt;/a&gt;를 확인해 보세요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;라이브러리 지원&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;CLI에 추가되었으면 하는 기능으로 가장 많이 언급된 것은 라이브러리를 생성하거나 빌드하는 것이었습니다. 이 기능이 이번에 추가되었습니다:&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-bash&quot;&gt;ng generate library &amp;lt;name&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*6uz18nxGzAtk5ftoDZv_iQ.gif&quot; border=&quot;0&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 명령을 실행하면 CLI 워크스페이스 안에 라이브러리 프로젝트를 생성하며, 테스트와 빌드를 위한 환경 설정도 자동으로 구성됩니다.&lt;/p&gt;&lt;p&gt;Angular CLI에서 라이브러리를 만드는 방법에 대해 알아보려면 &lt;a href=&quot;https://github.com/angular/angular-cli/wiki/stories-create-library&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;이 문서&lt;/a&gt;를 확인해 보세요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;트리 셰이킹을 지원하는 프로바이더&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;애플리케이션 번들링 결과물의 크기를&amp;nbsp;좀 더 작게 만들기 위해, Angular 모듈이 서비스를 참조하는 방식은 이제 서비스가 모듈을 참조하는 방식으로 변경되었습니다. 이제는 모듈에 실제로 주입되는 서비스만 번들링 결과물에 포함됩니다.&lt;/p&gt;&lt;p&gt;&lt;b style=&quot;font-size: 14pt;&quot;&gt;이전&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/StephenFluin/a4d7c97db0236567b07f43b85a1f4eff.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;b style=&quot;font-size: 14pt;&quot;&gt;이후&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/StephenFluin/8818d6045425d01edaede6fd34a4e4ab.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;의존성 주입에 대해 좀 더 알아보려면 &lt;a href=&quot;https://angular.io/guide/dependency-injection&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;이 문서&lt;/a&gt;를 확인해 보세요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;애니메이션 성능 개선&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;애니메이션 코드의 로직이 개선되었으며, 이제 더이상 &lt;a href=&quot;https://angular.io/guide/browser-support#enabling-polyfills&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;웹 애니메이션 폴리필&lt;/a&gt;을 사용하지 않습니다. 이로써 애플리케이션에서 사용하던 폴리필을 제거할 수 있으며, Safari에서 동작하는 애니메이션 성능을 끌어올리면서도 번들링 사이즈를 약 47kb 정도 줄일 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;RxJS v6&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Angular 6.0.0 버전부터는 RxJS v6를 사용합니다. RxJS v6 버전은 Angular 6.0.0 버전이 발표되기 몇 주 전에 먼저 발표되었으며, 이 버전에서 몇 가지 큰 변화가 있었습니다. RxJS는 하위버전의 호환성을 보장하기 위해 &lt;code class=&quot;language-bash&quot;&gt;rxjs-compat&lt;/code&gt; 패키지를 추가로 마련하기도 했습니다.&lt;/p&gt;&lt;p&gt;RxJS 코드는 트리 셰이킹에 좀 더 적합하도록 개선되었습니다. 이제 RxJS는 실제로 사용하는 구성요소만 번들링에 포함됩니다.&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-bash&quot;&gt;ng update&lt;/code&gt; 명령을 실행해서 RxJS 버전을 올리더라도 애플리케이션은 그대로 실행되지만, &lt;a href=&quot;https://github.com/ReactiveX/rxjs/blob/master/MIGRATION.md&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;RxJS 5.5 버전에서 6.0 버전으로 올리는 것에 대한 문서&lt;/a&gt;는 꼭 확인해 보세요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;장기 지원(Long Term Support, LTS)&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;이제 Angular 프레임워크의 지원은 모든 메이저 버전으로 확대되었습니다.&lt;/p&gt;&lt;p&gt;이전까지는 v4 버전과 v6 버전만 LTS 대상이라고 언급했지만, 메이저 버전을 올리는 것에 대한 부담을 줄이면서 새로운 메이저 버전 도입을 적극 권장하기 위해 v4 버전부터 모든 메이저 버전을 LTS 대상으로 확대합니다.&lt;/p&gt;&lt;p&gt;이제 모든 메이저 버전은 적극적인 개발 기간 6개월과 버그 수정, 보안 패치 기간 12개월을 포함해서 총 18개월동안 지원합니다.&lt;/p&gt;&lt;p&gt;Angular 버전과 릴리즈에 대한 내용은 &lt;a href=&quot;https://angular.io/guide/releases&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;이 문서&lt;/a&gt;를 확인해 보세요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;6.0.0으로 업데이트하는 방법&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Angular 애플리케이션의 버전을 올리려면 &lt;a href=&quot;https://update.angular.io/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;update.angular.io&lt;/a&gt; 사이트에서 제공하는 정보와 가이드를 확인할 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*HDecs3czt3cTRMaDu9yo0w.png&quot; border=&quot;0&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;버전 업데이트는 3단계로 진행하며, &lt;code class=&quot;language-bash&quot;&gt;ng update&lt;/code&gt; 명령을 활용하면 이 과정을 한 번에 수행할 수 있습니다.&lt;/p&gt;&lt;ol style=&quot;list-style-type: decimal;&quot;&gt;&lt;li&gt;@angular/cli 업데이트&lt;/li&gt;&lt;li&gt;Angular 프레임워크 패키지 업데이트&lt;/li&gt;&lt;li&gt;의존성 패키지 업데이트&lt;/li&gt;&lt;/ol&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;p&gt;개발자들이 프레임워크의 최신 버전을 쉽게 적용도록 하는 것은 우리에게 굉장히 중요한 일입니다. 좋은 아이디어가 있다면 댓글로 알려주세요!&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;Ivy에 대해&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://youtu.be/dIxknqPOWms?t=1360&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;이번 ng-conf에서 새로운 Angular 렌더링 엔진인 Ivy에 대해 언급한 적&lt;/a&gt;이 있습니다. 하지만 Ivy는 아직 개발하고 있는 중이기 때문에 이번 6.0 릴리즈에는 포함되지 않았습니다. Ivy는 좀 더 준비되는 대로 다시 소개할 것이기 때문에 조금만 더 기다려주세요.&lt;/p&gt;&lt;hr class=&quot;tx-hr-image-4&quot; style=&quot;background: url(//i1.daumcdn.net/deco/contents/horizontalrule/line08.gif?v=2) repeat-x scroll left; height: 15px; border:0; width:54px; margin:30px auto&quot;&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Angular는 다른 프레임워크와 다르게 그 자체로 종합 프레임워크로써 활용되고 있습니다.&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이번 업데이트는 그 영역을 좀 더 확장하면서 좀 더 풍부한 생태계를 만들려고 하는 노력도 보이네요 ㅎ&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;고맙습니다.&lt;/p&gt;</description>
<author>한장현</author>
<guid>https://han41858.tistory.com/45</guid>
<comments>https://han41858.tistory.com/45#entry45comment</comments>
<pubDate>Sat, 05 May 2018 00:17:44 +0900</pubDate>
</item>
<item>
<title>Angular v5.0.0</title>
<link>https://han41858.tistory.com/43</link>
<description>&lt;p&gt;안녕하세요. 한장현입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;드디어 Angular 5.0.0 버전이 나왔습니다!!&lt;/p&gt;&lt;p&gt;Angular 2가&amp;nbsp;나온지 13개월만에, 3 버전을 뛰어넘고 4 버전이 나온지 약 7개월만에 메이저 버전이 올라갔네요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 글에서는&amp;nbsp;5.0.0 버전에서 달라진 점을 간단하게 살펴봅니다.&lt;/p&gt;&lt;p&gt;글을 번역하면서 봤는데 AOT 빌드를 기본으로 적용한다던가, 라우터 이벤트가 늘었다는 내용같이 눈에 띄는 기능들이 많네요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;원문은 Angular 블로그의 게시글 &lt;a href=&quot;https://blog.angular.io/version-5-0-0-of-angular-now-available-37e414935ced&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Version 5.0.0 of Angular Now Available&lt;/a&gt;에서 확인할 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;hr class=&quot;tx-hr-image-4&quot; style=&quot;background: url(//i1.daumcdn.net/deco/contents/horizontalrule/line08.gif?v=2) repeat-x scroll left; height: 15px; border:0; width:54px; margin:30px auto&quot;&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;Angular 5.0.0 버전 릴리즈&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;드디어 Angular 5.0.0버전, pentagonal-donut이 나왔다. 이 버전은 Angular의 새로운 메이저 버전이며, 몇 가지 기능을 추가하고, 알려진 버그도&amp;nbsp;해결되었다. Angular팀은 좀 더 작고, 좀 더 빠르고, 좀 더 사용하기 쉬운 프레임워크를 만드는 노력을 계속할 것이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:250px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99A0FB3359FA9FE713&quot; filemime=&quot;image/jpeg&quot; filename=&quot;v5.0.0.png&quot; height=&quot;250&quot; width=&quot;250&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 글에서는 5.0.0 버전에서 바뀐 내용 중 중요한 내용을 다룬다. 변경된 내용 전체를 확인하려면 &lt;a href=&quot;https://github.com/angular/angular/blob/master/CHANGELOG.md&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;체인지로그&lt;/a&gt;를 확인하자.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;b&gt;빌드 최적화 툴(Build Optimizer)&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;빌드 최적화 툴은 CLI에 포함되어 있으며, 프로덕션 빌드에 CLI를 사용한다면 최적화 툴이 기본으로 적용된다.&lt;/p&gt;&lt;p&gt;빌드 최적화 툴은 크게 두 가지 작업을 수행한다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;먼저, 애플리케이션 코드에 &lt;code class=&quot;language-typescript&quot;&gt;pure&lt;/code&gt; 마크를 지정할 수 있다. Webpack과 같이 트리 셰이킹을 수행하는 툴은 애플리케이션에서 사용하지 않는 코드를 제거하는데, 이 마크를 사용하면 트리 셰이킹 성능을 더 끌어올릴 수 있다.&lt;/p&gt;&lt;p&gt;그리고 런타임에서 동작하는 Angular 애플리케이션 코드에서 Angular 데코레이터를 제거한다. 데코레이터는 컴파일러를 위한&amp;nbsp;함수이며, 런타임에는 사용되지 않기 때문에 없어도 된다.&lt;/p&gt;&lt;p&gt;빌드 최적화 툴이 수행하는 작업 덕에 JavaScript로 번들링한 애플리케이션 크기는 더욱 작아지며, 사용자가 경험하는 애플리케이션 실행 속도는 더욱 빨라질 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;b&gt;Angular Universal State Transfer API와 Dom 지원&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Angular Universal을 사용하면서 서버 버전과 클라이언트 버전 두 개를 유지하고 있다면, 이들을 관리하기 좀 더 편해졌다.&lt;/p&gt;&lt;p&gt;Angular Universal은 Angular 애플리케이션을 서버에서&amp;nbsp;렌더링할 때 사용하는 프로젝트다. 애플리케이션을 서버에서 렌더링하면 전체를 클라이언트에서 렌더링하는 것보다는 좀 더 정적인 HTML이 생성되며, 이 파일을 이용해서 검색엔진을 최적화 할 수 있고 페이지 안에 있는 JavaScript를 실행하지 않는 검색 엔진에도 대응할 수 있다. 클라이언트에서 체감할 수 있는 애플리케이션 성능도 물론 빨라진다.&lt;/p&gt;&lt;p&gt;5.0.0버전에는 ServerTransferStateModule과 BrowserTransferStateModule이 추가되었다. 이 모듈을 사용하면 platform-server를 사용해서 애플리케이션을 렌더링할 때 사용한 정보를 클라이언트로 전달할 수 있으며, 클라이언트에서&amp;nbsp;애플리케이션을 실행했을 때 이 정보를 다시 만들어 내지 않아도 된다. 이 기능은 애플리케이션이 HTTP 통신으로 데이터를 가져오려고 할 때 유용한데, 서버의 상태를 클라이언트가 미리 알고 있다면 서버 상태를 확인하는 HTTP 콜을 생략하고 원하는 작업을 바로 할 수 있기 때문이다. State Transfer API에 대한 문서는 몇 주 후에 공개될 것 같다.&lt;/p&gt;&lt;p&gt;그리고 platform-server에 &lt;a href=&quot;https://github.com/fgnass/domino&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Domino&lt;/a&gt;가 추가되었다. Domino를 사용하면 서버 사이드 렌더링에서도 DOM을 조작할 수 있으며, 서드 파티 JS 라이브러리나 컴포넌트 라이브를 사용하는 것도 더 편해졌다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;b&gt;컴파일러 개선&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Angular 컴파일러는 이제 증분 컴파일(incremental compilation)을 지원한다. 컴파일 할 때마다 모든 코드를 컴파일하는 것이 아니라, 변경된 부분만 추적해서 컴파일하기 때문에 재빌드 속도가 빨라졌다. 이 차이는 프로덕션 빌드나 AOT 빌드에서 좀 더 확실하다. 이밖에도 공백문자를 제거해서 번들링 결과물의 크기를 줄일 수 있는 데코레이터들도 추가되었다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;TypeScript 변환&lt;/span&gt;&lt;/p&gt;&lt;p&gt;이제 Angular 컴파일러는 TypeScript 컴파일러처럼 사용한다.&amp;nbsp;Angular의 TypeScript 컴파일은 증분 컴파일 기능 덕분에 재빌드 속도가 더욱 빨라졌고, TypeScript 컴파일러 2.3버전에 추가된 컴파일 파이프라인 기능을 적극 활용한다.&lt;/p&gt;&lt;p&gt;덕분에 다음과 같이 ng serve 명령을 실행하면서 AOT 빌드를 수행할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-typescript&quot;&gt;ng serve --aot&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 기능은 모두 한 번 써보기를 권한다. 이 동작은 앞으로 배포될 CLI에서는 기본 기능이 될 것이다. 다만, 컴포넌트가 천개를 넘어가는 프로젝트에서는 아직 성능&amp;nbsp;이슈가 있긴 하다. 이 이슈는 곧 해결될 것이며, 결국 모든 크기의 프로젝트에서 이 기능을 사용하는 것이 도움이 될 것이다.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://angular.io&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://angular.io&lt;/a&gt;&amp;nbsp;애플리케이션에 증분 AOT 빌드를 적용했을 때는 빌드 시간이 95% 단축되었다!! 원래 빌드 시간은 40초 정도 걸렸지만, 증분 AOT 빌드를 적용했을 때는 2초 정도 걸렸다.&lt;/p&gt;&lt;p&gt;우리가 생각하는 AOT 빌드의 최종 목표는 개발자가 AOT 빌드로 개발을 하면서 가끔&amp;nbsp;프로덕션 빌드를 할 때 차이를 느끼지 못하게 하는 것이다. angular.io 페이지를 AOT 증분 빌드하는 데에 2초밖에 걸리지 않았기 때문에, AOT 빌드는 곧 CLI 기본 기능이 될 것이다.&lt;/p&gt;&lt;p&gt;이런 변화와 함께, AOT 빌드에 사용하는 &lt;code class=&quot;language-bash&quot;&gt;genDir&lt;/code&gt; 설정은 더이상 필요없다. 임시로 생성되는 파일은 모두 node_modules 안에서 처리할 것이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;공백문자 보호 옵션&lt;/span&gt;&lt;/p&gt;&lt;p&gt;지금까지 템플릿에 있는 탭, 개행문자, 공백문자는 빌드 결과물에 그대로 포함되는 것이 일반적이었다. 이제는 이런 공백문자들을 그대로 포함할지, 포함시키지 않을지 선택할 수 있다.&lt;/p&gt;&lt;p&gt;이 기능은 true가 기본값이며, 컴포넌트 데코레이터에 따로 설정할 수도 있다.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;@Component({
	templateUrl: 'about.component.html',
	preserveWhitespaces: false
}
export class AboutComponent {}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;그리고 이 옵션을 tsconfig.json에 지정하면 애플리케이션 전체에 적용할 수 있다. 기본값은 true다.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;{
	&quot;extends&quot;: &quot;../tsconfig.json&quot;,
	&quot;compilerOptions&quot;: {
		&quot;outDir&quot;: &quot;../out-tsc/app&quot;,
		&quot;baseUrl&quot;: &quot;./&quot;,
		&quot;module&quot;: &quot;es2015&quot;,
		&quot;types&quot;: []
	},
	&quot;angularCompilerOptions&quot;: {
		&quot;preserveWhitespaces&quot;: false
	},
	&quot;exclude&quot;: [
		&quot;test.ts&quot;,
		&quot;**/*.spec.ts&quot;
	]
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;일반적으로 컴포넌트 레벨에서 옵션값을 설정하면 애플리케이션 설정은 무시한다. 따라서 공백문자를 처리하지 않아야 하는 컴포넌트에서는 애플리케이션 설정에 true가 되어있다고 해도 컴포넌트 레벨에서 false를 지정할 수 있다.&lt;/p&gt;&lt;p&gt;&amp;lt;pre&amp;gt; 태그에 대해 걱정할 필요는 없다. 이 태그는 예외적으로 잘 처리하고 있다.&lt;/p&gt;&lt;p&gt;preserveWhiteSpaces 옵션에 대해서는 &lt;a href=&quot;https://angular.io/api/core/Component#preserveWhitespaces&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;이 문서&lt;/a&gt;를 참고하자.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;데코레이터 지원 강화&lt;/span&gt;&lt;/p&gt;&lt;p&gt;이제 데코레이터에서도 람다표현식( &lt;code class=&quot;language-typescript&quot;&gt;() =&amp;gt; { }&lt;/code&gt; )을 지원한다. useValue, useFactory, data 를 사용할 때도 물론 람다표현식을 사용할 수 있다. 컴포넌트에서 사용하는 값이 런타임에 계산되는 경우라면 람다표현식을 사용하는 것이 더 적절할 것이다.&lt;/p&gt;&lt;p&gt;그래서 이제는 함수의 이름을 지정하거나 d.ts 파일에 선언된 API를 사용하지 않고도 더욱 간단한 코드를 작성할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;@Component({
	provider: [{provide: SOME_TOKEN, useFactory: () =&amp;gt; null}]
})
export class MyClass {}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;useValue를 쓸 때도 마찬가지다&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;@Component({
	provider: [{provide: SOME_TOKEN, useValue: SomeEnum.OK}]
})
export class MyClass {}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;b&gt;i18n 숫자, 날짜, 통화 파이프&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;숫자, 날짜, 통화 파이프가 i18n에 더 적합하게 개선되었으며, 더이상 i18n을 지원하기 위해 폴리필을 사용할 필요가 없다.&lt;/p&gt;&lt;p&gt;원래 Angular는 숫자, 날짜, 통화 형식을 자체적으로 제공하지 않고 브라우저의 i18n API를 사용하도록 했다. 따라서&amp;nbsp;개발자가 원하는 i18n을 구현하려면 폴리필을 사용해야만 했고, 사용자가 보는 애플리케이션은 브라우저에 따라 다른 동작을 하기도 했다. 우리 팀은 이 이슈에 대해 수많은 댓글을 받았으며(특히 통화 파이프에 대해), 파이프를 한 번 정리하기로 했다.&lt;/p&gt;&lt;p&gt;5.0.0에서는 파이프들을 자체적으로 모두 구현했으며, 특수문자가 필요한 경우는 &lt;a href=&quot;http://cldr.unicode.org/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;CLDR&lt;/a&gt;을 활용하기도 했다. Angular 5 버전의 파이프가 4 버전과 달라진 점은 &lt;a href=&quot;https://docs.google.com/spreadsheets/d/12iygt-_cakNP1VO7MV9g4lq9NsxVWG4tSfc98HpHb0k/edit#gid=0&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;이 문서&lt;/a&gt;에서 확인하자.&lt;/p&gt;&lt;p&gt;새로운 파이프를 아직 사용하지 않으려면 &lt;code class=&quot;language-typescript&quot;&gt;DeprecatedI18NPipesModule&lt;/code&gt;을 사용하면 된다.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/angular/angular/blob/master/CHANGELOG.md#i18n-pipes&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;i18n 파이프 체인지로그 보기&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;b&gt;ReflectiveInjector를 StaticInjector로 대체&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;폴리필들을 좀 더 제거하기 위해 ReflectiveInjector는 StaticInjector로 대체했다. StaticInjector를 사용하면 Relect 폴리필을 사용할 필요가 없으며, 폴리필이 빠지기 때문에 애플리케이션 크기도 좀 더 줄어든다.&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;변경 전&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-typescript&quot;&gt;ReflectiveInjector.resolveAndCreate(providers);&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;변경 후&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-typescript&quot;&gt;Injector.create(providers);&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;b&gt;Zone 활용 성능 개선&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Zone 라이브러리를 생략할 수 있는 기능이 추가되었다. 이제 애플리케이션 성능을 더 끌어올리기 위해&amp;nbsp;Zone 라이브러리를 일부 생략할 수 있다.&lt;/p&gt;&lt;p&gt;Zone 라이브러리를 생략하려면 애플리케이션을 부트스트랩할 때 ngZone에 'noop' 옵션을 주면 된다.&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-typescript&quot;&gt;latformBrowserDynamic().bootstrapModule(AppModule, {ngZone: 'noop'}).then( ref =&amp;gt; {} );&lt;/code&gt;&lt;/p&gt;&lt;p&gt;예제를 확인하려면 &lt;a href=&quot;https://stackblitz.com/edit/ng-component-state&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;ng-component-state 프로젝트&lt;/a&gt;를 확인하자.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;b&gt;exportAs 개선&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;컴포넌트나&amp;nbsp;디렉티브를 여러 이름으로 외부에 공개할 수 있는 기능이 추가되었다. 이 기능은 이전 이름을 유지하면서 새 이름을 지정하려고 할 때 유용하다. 새로 작성하는 코드는 새 이름을 사용하더라도, 이전 코드는 변경하지 않아도 된다. 이 기능은 사실 Angular Material 프로젝트에서 접두사를 변경하는 과정에 사용했었다. 컴포넌트를 유지하고 관리해야 하는 개발자라면 이 기능이 특히 반가울 것이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;예제&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;@Component({
	moduleId: module.id,
	selector: 'a[mat-button], a[mat-raised-button], a[mat-icon-button], a[mat-fab], a[mat-mini-fab]',
	exportAs: 'matButton, matAnchor',
	.
	.
	.
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;b&gt;HttpClient&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;HttpClient는 4.3 버전부터 &lt;code class=&quot;language-typescript&quot;&gt;@angular/common&lt;/code&gt; 패키지에 도입되었으며, 이전보다 간단하고 쉬우면서도 효율적인 방법으로 웹 요청을 처리할 수 있다. HttpClient는 도입된 이후로 개발자들의 큰 환호를 받았으며, 이제는 우리도 &lt;code class=&quot;language-typescript&quot;&gt;@angular/http&lt;/code&gt; 라이브러리에 있는&amp;nbsp;HttpModule을 사용하지 말고 HttpClient 모듈을 사용할 것을 권장한다.&lt;/p&gt;&lt;p&gt;이미 개발하고 있는 애플리케이션에 HttpClient 모듈을 도입하려면 HttpModule을 HttpClientModule로 바꾸고 HttpClient 서비스를 주입한 뒤에, &lt;code class=&quot;language-typescript&quot;&gt;map(res =&amp;gt; res.json())&lt;/code&gt; 코드를 제거하면 된다. 이 코드는 HttpClient에서는 더이상 필요 없다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;b&gt;CLI v1.5&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Angular CLI v1.5부터는 CLI로 생성하는 Angular 프로젝트에 v5.0.0을 기본으로 사용한다.&lt;/p&gt;&lt;p&gt;CLI v1.5부터는 위에서 설명한 빌드 최적화 툴이 기본으로 적용되며, 설정을 특별히 바꾸지 않아도 번들링 결과물이 더 작아지는 것을 확인할 수 있다.&lt;/p&gt;&lt;p&gt;그리고 .tsconfig 파일을 사용하는 방식을 개선했기 때문에&amp;nbsp;이제는 TypeScript 표준을 좀 더 엄격하게 적용한다. 이전에는 tsconfig.json 파일의 &lt;code class=&quot;language-typescript&quot;&gt;files&lt;/code&gt;나 &lt;code class=&quot;language-typescript&quot;&gt;include&lt;/code&gt;에 파일 목록을 나열하고, 이 파일을 Angular가 추적해서&amp;nbsp;지연 로딩되는 라우터를 사용할 수 있었지만, 이제는 TypeScript 표준에 맞지 않기 때문에 이 방식은 사용할 수 없다. 이제 CLI가 지원하는 TypeScript 설정에는&amp;nbsp;&lt;code class=&quot;language-typescript&quot;&gt;files&lt;/code&gt;나 &lt;code class=&quot;language-typescript&quot;&gt;include&lt;/code&gt; 항목이 포함되지 않는다. 이 내용이 그리 많은 개발자에게 영향을 주지 않기를 바란다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;Angular 폼 변경 감지 &lt;/span&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;옵션&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;이제는 폼에 입력이 들어올때마다 유효성을 검사하지 않고 'blur' 시점이나 'submit' 시점을 활용할 수 있다.&lt;/p&gt;&lt;p&gt;폼은 애플리케이션에서 아주 중요한 부분이다. 서버에서 유효성 검사를 하지 않아서 클라이언트의 유효성 검사를 아주 엄격하게 한다면, 유효성 검사를 원할 때마다 수행하기 부담스러울 수도 있다. 이제는 값이 변경되는 시점을 선택해서 유효성 검사를 수행할 수 있다. 이 동작은 폼 컨트롤 레벨에서 할 수도 있고 전체 폼에 적용할 수도 있다.&lt;/p&gt;&lt;p&gt;그리고 이제 'asyncValidators'를 폼 컨트롤의 옵션으로&amp;nbsp;직접 적용할 수 있다. 이전에는 폼 컨트롤 생성자의 세번째 옵션으로만 지정할 수 있었다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;템플릿 기반 폼&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;변경 후&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;input name=&quot;firstName&quot; ngModel&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;변경 후&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;input name=&quot;firstName&quot; ngModel [ngModelOptions]=&quot;{updateOn: 'blur'}&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;또는&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;form [ngFormOptions]=&quot;{updateOn: 'submit'}&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;반응형 폼&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;변경 전&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;new FormGroup(value);
new FormControl(value, [], [myValidator])&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;변경 후&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;new FormGroup(value, {updateOn: 'blur'}));
new FormControl(value, {updateOn: 'blur', asyncValidators: [myValidator]})&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;b&gt;RxJS 5.5&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Angular에서 사용하는 RxJS가 5.5버전으로 업데이트 되었다. 이제&amp;nbsp;&lt;a href=&quot;https://github.com/ReactiveX/rxjs/blob/master/doc/lettable-operators.md&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;RxJS v5.5에서 도입한 lettable 연산자&lt;/a&gt;를 사용할 수 있으며, 개발자가 할 수 있는 일은 더 많아졌다. 이제 연산자를 불러올 때 사용하는 문법이 좀 더 깔끔해졌고, 코드 분할이나 트리 셰이킹에서 발생하던 사이드 이펙트도 해결되었다.&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;변경 전&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/filter';

names = allUserData
	.map(user =&amp;gt; user.name)
	.filter(name =&amp;gt; name);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;변경 후&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;import { Observable } from 'rxjs/Observable';
import { map, filter } from 'rxjs/operators';

names = allUserData.pipe(
	map(user =&amp;gt; user.name),
	filter(name =&amp;gt; name),
);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;게다가 RxJS는 이제 ECMAScript 모듈로 배포되며, Angular CLI v1.5는 이 버전을 기본으로 탑재할 것이다. Angular CLI를 사용하지 않는다면 물론 패키지를 따로 설치해야 한다. &lt;a href=&quot;https://github.com/ReactiveX/rxjs/blob/master/doc/lettable-operators.md#build-and-treeshaking&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;RxJS의 &lt;/a&gt;&lt;a href=&quot;https://github.com/ReactiveX/rxjs/blob/master/doc/lettable-operators.md#build-and-treeshaking&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;빌드와 트리 셰이킹에 대한 내용&lt;/a&gt;은 lettable 연산자 문서에서 찾을 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;b&gt;새로운 라우터 라이프싸이클 이벤트&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;라우터에 새로운 라이프싸이클 이벤트가 추가되었다. 이제는 라우터 가드가 실행되는 시점부터 라우터가 활성화되는 시점을 감지할 수 있다. 자식 라우터가 변경될 때 라우터 영역에 로딩 UI를 표시해야 하거나, 라우터 가드의 성능을 확인하려고 할 때 활용하면 좋다.&lt;/p&gt;&lt;p&gt;새로 추가된 이벤트는 실행되는&amp;nbsp;순서대로 &lt;code class=&quot;language-typescript&quot;&gt;GuardsCheckStart&lt;/code&gt;, &lt;code class=&quot;language-typescript&quot;&gt;ChildActivationStart&lt;/code&gt;, &lt;code class=&quot;language-typescript&quot;&gt;ActivationStart&lt;/code&gt;, &lt;code class=&quot;language-typescript&quot;&gt;GuardsCheckEnd&lt;/code&gt;, &lt;code class=&quot;language-typescript&quot;&gt;ResolveStart&lt;/code&gt;, &lt;code class=&quot;language-typescript&quot;&gt;ResolveEnd&lt;/code&gt;, &lt;code class=&quot;language-typescript&quot;&gt;ActivationEnd&lt;/code&gt;, &lt;code class=&quot;language-typescript&quot;&gt;ChildActivationEnd&lt;/code&gt;다. 이 이벤트를 활용하면 로딩 UI를 표시하고 감추는 동작을 다음과 같이 구현할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;class MyComponent {
	constructor(public router: Router, spinner: Spinner) {
		router.events.subscribe(e =&amp;gt; {
			if (e instanceof ChildActivationStart) {
				spinner.start(e.route);
			} else if (e instanceof ChildActivationEnd) {
				spinner.end(e.route);
			}
		});
	}
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;b&gt;새 버전은 어떻게 적용해야 하나?&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;우리는 Firebase 애플리케이션으로 &lt;a href=&quot;https://angular-update-guide.firebaseapp.com/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Angular 업데이트 가이드&lt;/a&gt;를 제공하고 있다. 이 가이드를 활용하면 지금 어떤 버전을 사용하고 있는지에&amp;nbsp;관계없이, 원하는 버전을 적용할 때 코드의 어느 부분을 수정해야 하는지 적절한 가이드를 확인할 수 있다. 현재 사용하는 버전과 바꾸려고 하는 버전을 선택하고 가이드의 내용을 따라하면 된다.&lt;/p&gt;&lt;p&gt;Angular v5.0.0에서는 &lt;code class=&quot;language-typescript&quot;&gt;OpaqueToken&lt;/code&gt;과 같이 이제는 사용하지 않는 API를 많이 제거했으며, 앞으로 사용하지 않을 API를 새롭게 지정하기도 했다. Angular 애플리케이션을 만드는 데에 이 글이 도움이 되기를 바란다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;b&gt;알려진 이슈&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;프로덕션 빌드에서 소스맵을 생성할 때 일부 소스맵이 정상적으로 생성되지 않는 이슈가 있긴 하다.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/angular/angular/issues/19840https://github.com/angular/angular/issues/19840&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://github.com/angular/angular/issues/19840&lt;/a&gt;&lt;/p&gt;</description>
<category>Angular 5.0.0</category>
<author>한장현</author>
<guid>https://han41858.tistory.com/43</guid>
<comments>https://han41858.tistory.com/43#entry43comment</comments>
<pubDate>Thu, 02 Nov 2017 12:50:43 +0900</pubDate>
</item>
<item>
<title>Angular 커스텀 컴포넌트에 양방향 바인딩 구현하기</title>
<link>https://han41858.tistory.com/42</link>
<description>&lt;p&gt;안녕하세요. 한장현입니다.&lt;/p&gt;&lt;p&gt;오늘은 Angular 커스텀 컴포넌트에 양방향 바인딩 구현하면서&amp;nbsp;삽질했던 경험을 공유해 봅니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;목표 : 커스텀 컴포넌트에 &lt;code class=&quot;language-typescript&quot;&gt;[( )]&lt;/code&gt; 문법으로 양방향 바인딩 구현하기&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;hr class=&quot;tx-hr-image-4&quot; style=&quot;background: url(//i1.daumcdn.net/deco/contents/horizontalrule/line08.gif?v=2) repeat-x scroll left; height: 15px; border:0; width:54px; margin:30px auto&quot;&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&lt;b&gt;1. Angular 데이터 바인딩&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Angular에서 기본 데이터 바인딩은 단방향이죠. 간단하게 정리하면 다음과 같습니다.&lt;/p&gt;&lt;ul style=&quot;list-style-type: disc;&quot;&gt;&lt;li&gt;데이터에서 뷰로 향하는 바인딩 (프로퍼티 바인딩) : &lt;code class=&quot;language-typescript&quot;&gt;property=&quot;{{ expression&amp;nbsp;}}&quot;&lt;/code&gt;, &lt;code class=&quot;language-typescript&quot;&gt;[property]=&quot;expression&quot;&lt;/code&gt;, &lt;code class=&quot;language-typescript&quot;&gt;bind-property=&quot;expression&quot;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;뷰에서 데이터로 향하는 바인딩 (이벤트 바인딩) : &lt;code class=&quot;language-typescript&quot;&gt;(target)=&quot;statement&quot;&lt;/code&gt;, &lt;code class=&quot;language-typescript&quot;&gt;on-target=&quot;statement&quot;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;양방향 바인딩 : &lt;code class=&quot;language-typescript&quot;&gt;[(target)]=&quot;expression&quot;&lt;/code&gt;, &lt;code class=&quot;language-typescript&quot;&gt;bindon-target=&quot;expression&quot;&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-typescript&quot;&gt;{{ 평가식 }}&lt;/code&gt; 으로 사용하는 방법과 &lt;code class=&quot;language-typescript&quot;&gt;[프로퍼티]&lt;/code&gt; 로 사용하는 방법이 일반적인데, 찾아보니 &lt;code class=&quot;language-typescript&quot;&gt;bind-&lt;/code&gt; 접두사를 붙이는 방법도 있었네요.&lt;/p&gt;&lt;p&gt;마찬가지로 &lt;code class=&quot;language-typescript&quot;&gt;(target)&lt;/code&gt; 을 사용하는 방법 말고 &lt;code class=&quot;language-typescript&quot;&gt;on-&lt;/code&gt; 접두사를 사용하는 방법도 있고, 양방향 바인딩도 &lt;code class=&quot;language-typescript&quot;&gt;bindon-&lt;/code&gt; 접두사를 사용하는 방법도 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;양방향 바인딩 문법이 &lt;code class=&quot;language-typescript&quot;&gt;[( )]&lt;/code&gt; 인지, &lt;code class=&quot;language-typescript&quot;&gt;([ ])&lt;/code&gt; 인지 헷갈릴 때는 '상자[ ]에 든 바나나( )'를 생각하면 됩니다. Angular 공식 문서에서도 이렇게 설명을 하고 있네요 ㅎㅎㅎ&lt;/p&gt;&lt;p&gt;사진을 찾아보니 적절한 비유 같습니다 ㅎ&lt;/p&gt;&lt;p&gt;banana in a&amp;nbsp;box만 생각하면 문법이 헷갈릴 일은 없겠네요~&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:348px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9952CE3359DB66DF04&quot; filemime=&quot;image/jpeg&quot; filename=&quot;banana-in-the-box.jpg&quot; height=&quot;905&quot; width=&quot;348&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;2. 컴포넌트 연결&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;컴포넌트를 외부와 연결할 때는&amp;nbsp;&lt;code class=&quot;language-typescript&quot;&gt;@angular/core&lt;/code&gt;에 있는 &lt;code class=&quot;language-typescript&quot;&gt;Input&lt;/code&gt;, &lt;code class=&quot;language-typescript&quot;&gt;Output&lt;/code&gt; 데코레이터를 사용합니다.&lt;/p&gt;&lt;p&gt;컴포넌트로 들어가는 데이터는 &lt;code class=&quot;language-typescript&quot;&gt;@Input()&lt;/code&gt; 데코레이터로 지정하는 프로퍼티에,&lt;/p&gt;&lt;p&gt;컴포넌트에서 나오는 이벤트는 &lt;code class=&quot;language-typescript&quot;&gt;@Output()&lt;/code&gt; 데코레이터로 지정하는 프로퍼티로 지정하죠.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;외부에서 boolean 값을 받고 값(&lt;code class=&quot;language-typescript&quot;&gt;checked&lt;/code&gt;)이 바뀌는 이벤트(&lt;code class=&quot;language-typescript&quot;&gt;checkChanged&lt;/code&gt;)를 처리하는 CustomCheckComponent는 다음과 같이 구현합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;- app.component.html&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;custom-check [checked]=&quot;checkValue&quot; (checkedChange)=&quot;changed($event)&quot;&amp;gt;&amp;lt;/custom-check&amp;gt;
&amp;lt;p&amp;gt;value : {{ checkValue  }}&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;- custom-check.component.ts&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;import { Component, Input, Output, EventEmitter } from '@angular/core';

@Component({
	selector : 'custom-check',
	template : `
		&amp;lt;button (click)=&quot;toggle()&quot;&amp;gt;toggle&amp;lt;/button&amp;gt;
		&amp;lt;span&amp;gt;{{ checked }}&amp;lt;/span&amp;gt;
	`
})
export class CustomCheckComponent {
	@Input() checked : boolean = false;
	@Output() checkedChange : EventEmitter&lt;boolean&gt; = new EventEmitter();

	toggle () {
		this.checked = !this.checked;
		this.checkedChange.emit(this.checked);
	}
}
&lt;/boolean&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그런데 이 방식은 완벽한 양방향 바인딩이 아닙니다. 단방향 바인딩이 양쪽으로 각각 연결되어 있을 뿐이죠.&lt;/p&gt;&lt;p&gt;AppComponent에서 &lt;code class=&quot;language-typescript&quot;&gt;checkedChange&lt;/code&gt; 이벤트를 보고 있다가, 이벤트를 받으면 AppComponent에 있는 &lt;code class=&quot;language-typescript&quot;&gt;checkValue&lt;/code&gt;를 수동으로 바꿔줘야 합니다.&lt;/p&gt;&lt;p&gt;원하는 건 CustomCheckComponent에 바인딩 한 &lt;code class=&quot;language-typescript&quot;&gt;checked&lt;/code&gt; 값이 바뀔때 부모 컴포넌트의 값도 같이 바뀌는 거죠&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 태그에 &lt;code class=&quot;language-typescript&quot;&gt;[(ngModel)]&lt;/code&gt;를 사용하듯이 &lt;code class=&quot;language-typescript&quot;&gt;[(checked)]&lt;/code&gt; 같이 사용하고 싶은데... 방법이 없나 열심히 찾아봤습니다.&lt;/p&gt;&lt;p&gt;Angular 가이드 문서에는 딱히 이런 내용이 없는데, 구글링을 하다가 JavaScript&amp;nbsp;문법에 있는 getter와 setter를 사용하는 방법을 찾았습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&lt;b&gt;3. getter, setter&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;getter와 setter는 프로퍼티 값을 참조하거나 변경하는 시점을 가로채는 함수입니다. 이 때 getter와 setter로 지정하는 함수의 이름이 접근하는 프로퍼티 이름으로 사용되며, 이 프로퍼티 값을 저장하는 변수를 컴포넌트 안에 추가로 만들어야 합니다.&lt;/p&gt;&lt;p&gt;이 기능은 TypeScript&amp;nbsp;문법으로 다음과 같이 사용합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;- custom-check.component.ts&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;export class CustomCheckComponent {
	private value : boolean = false;

	@Input()
	get checked () : boolean {
		return this.value;
	}

	set checked (value) {
		this.value = value;
	}

	@Output() checkedChange : EventEmitter&amp;lt;boolean&amp;gt;&lt;boolean&gt; = new EventEmitter();

	toggle () {
		this.checked = !this.checked;
		this.checkedChange.emit(this.checked);
	}
}&lt;/boolean&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이렇게 구현하면 컴포넌트 외부에서 &lt;code class=&quot;language-typescript&quot;&gt;checked&lt;/code&gt; 프로퍼티에 접근할 때 getter와 setter로 지정한 함수를 실행하면서 내부 변수인 &lt;code class=&quot;language-typescript&quot;&gt;value&lt;/code&gt; 프로퍼티를 사용합니다.&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-typescript&quot;&gt;toggle()&lt;/code&gt; 함수에서도 &lt;code class=&quot;language-typescript&quot;&gt;this.value&lt;/code&gt; 프로퍼티를 사용하지 않고, getter와 setter를 사용하기 위해 &lt;code class=&quot;language-typescript&quot;&gt;checked&lt;/code&gt; 프로퍼티를 사용합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그런데 &lt;code class=&quot;language-typescript&quot;&gt;checked&lt;/code&gt; 프로퍼티 값이 바뀌는 것을 CustomCheckComponent 외부에서 알 수 있는 방법은 여전히 &lt;code class=&quot;language-typescript&quot;&gt;checkedChange&lt;/code&gt; 이벤트를 활용해야 합니다. 추가 작업이 발생하는 것은 마찬가지네요.&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-typescript&quot;&gt;checked&lt;/code&gt;를 양방향으로 연결하기 위해 &lt;code class=&quot;language-typescript&quot;&gt;[( )]&lt;/code&gt; 문법을 사용하고 &lt;code class=&quot;language-typescript&quot;&gt;checked&lt;/code&gt; 프로퍼티에 &lt;code class=&quot;language-typescript&quot;&gt;@Input()&lt;/code&gt;, &lt;code class=&quot;language-typescript&quot;&gt;@Output()&lt;/code&gt;를 같이 적용하면 되나 싶은데,&amp;nbsp;&lt;code class=&quot;language-typescript&quot;&gt;@Input()&lt;/code&gt; 데코레이터와 &lt;code class=&quot;language-typescript&quot;&gt;@Output()&lt;/code&gt; 데코레이터는 한 프로퍼티에 함께 적용할 수 없습니다. 에러 나요 ㅎ&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 때 AppComponent 템플릿에서는 &lt;code class=&quot;language-typescript&quot;&gt;[(checked)]&lt;/code&gt; 표현식을 사용하고,&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-typescript&quot;&gt;(checkedChange)&lt;/code&gt; 이벤트를 받는 부분을 지우면서 setter 함수에서 &lt;code class=&quot;language-typescript&quot;&gt;checkedChange&lt;/code&gt; 프로퍼티로 이벤트를 보내줍니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그러면 &lt;code class=&quot;language-typescript&quot;&gt;checked&lt;/code&gt; 값(실제로는 &lt;code class=&quot;language-typescript&quot;&gt;value&lt;/code&gt; 값)이 바뀔 때 이벤트를 외부로 보내는데,&amp;nbsp;신기한 일이 발생합니다.&lt;/p&gt;&lt;p&gt;이벤트 이름이 프로퍼티명 + 'Change'인 경우에, 위 코드에서는 checked + Change === checkedChange인 이벤트가 있으면, 이 이벤트를 잡지 않아도 양방향 바인딩이 연결됩니다.&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;이 부분이 중요합니다!! 이벤트 프로퍼티 이름이 이 규칙을 벗어나면 양방향 바인딩이 연결되지 않습니다.&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;그리고 &lt;code class=&quot;language-typescript&quot;&gt;(checkedChange)&lt;/code&gt; 이벤트를 AppComponent에서 잡고 있어도 양방향 바인딩은 연결되지 않습니다.&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;최종 코드는 이렇게 됩니다.&lt;/p&gt;&lt;p&gt;- app.component.html&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;custom-check [(checked)]=&quot;checkValue&quot;&amp;gt;&amp;lt;/custom-check&amp;gt;
&amp;lt;p&amp;gt;checkValue = {{ checkValue }}&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;- custom-check.component.ts&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;import { Component, Input, Output, EventEmitter } from '@angular/core';

@Component({
	selector : 'custom-check',
	template : `
		&amp;lt;button (click)=&quot;toggle()&quot;&amp;gt;toggle&amp;lt;/button&amp;gt;
		&amp;lt;span&amp;gt;{{ checked }}&amp;lt;/span&amp;gt;
	`
})
export class CustomCheckComponent {
	private value : boolean = false;
	@Output() checkedChange : EventEmitter&lt;boolean&gt; = new EventEmitter();

	@Input()
	get checked () {
		return this.value;
	}

	set checked (val) {
		this.value = val;
		this.checkedChange.emit(this.value);
	}

	toggle () {
		this.checked = !this.checked;
	}
}&lt;/boolean&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;커스텀 컴포넌트도 양방향 바인딩을 사용할 수 있네요 ㅎㅎㅎㅎ&lt;/p&gt;&lt;p&gt;원하는 대로 깔끔하게 동작해서 좋습니다 ㅎㅎ&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;참고할만한 코드 샘플은 &lt;a href=&quot;https://plnkr.co/edit/RtrRej?p=preview&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;이 링크&lt;/a&gt;를 참고하세요~&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;고맙습니다.&lt;/p&gt;</description>
<category>Angular</category>
<category>양방향 바인딩</category>
<category>커스텀 컴포넌트</category>
<author>한장현</author>
<guid>https://han41858.tistory.com/42</guid>
<comments>https://han41858.tistory.com/42#entry42comment</comments>
<pubDate>Mon, 09 Oct 2017 21:24:04 +0900</pubDate>
</item>
<item>
<title>[이메일 문답] Angular + Node.js vs. Spring</title>
<link>https://han41858.tistory.com/41</link>
<description>&lt;p&gt;안녕하세요. 한장현입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;최근 메일로 흥미로운 주제에 대해 질문을 주신 분이 있었습니다.&lt;/p&gt;&lt;p&gt;간단하지 않은 문제라서 고민을 좀 하다가 답변을 드렸는데&lt;/p&gt;&lt;p&gt;다른 분들은 어떻게 생각하시는지 궁금해서 공유해봅니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;hr class=&quot;tx-hr-image-4&quot; style=&quot;background: url(//i1.daumcdn.net/deco/contents/horizontalrule/line08.gif?v=2) repeat-x scroll left; height: 15px; border:0; width:54px; margin:30px auto&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;b&gt;[질문]&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;안녕하세요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이제까지 웹이 아닌 윈도우 영역에서만 개발을 해 왔는데 웹에 대한 이해를 할려고 공부중입니다.&lt;/p&gt;&lt;p&gt;다음 프로젝트를 웹으로 개발을 준비해야 할것 같아서 질문을 하나 드렸으면 하는데&lt;/p&gt;&lt;p&gt;누가 안된다면 이에 대한 답변 부탁 드립니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;제가 계획하고 있는것은 Node.JS+Angular로 웹 애플리케이션 프레임워크를 만들려고 하는데&lt;/p&gt;&lt;p&gt;주위에 알아보면 스프링기반으로 하라고 합니다.&lt;/p&gt;&lt;p&gt;여러가지고 고민스럽고 약간은 혼란 스럽기도 합니다.&lt;/p&gt;&lt;p&gt;백엔드를 Node.JS로 구성하고 프론트엔드를 Angular로 구성할려고 하는데&lt;/p&gt;&lt;p&gt;스프링에도 백엔드와 프론트엔드가 모두 있다고 하는데 두 프레임워크에 대한 장단점을 파악하기가 저로서는 난감한 상황입니다..&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그리고 Node + Angular를 선택할려고 한 것은 Javascript + Typescript로 통일해서 구성이 가능하기 때문인데&lt;/p&gt;&lt;p&gt;Spring을 하면 Java로 모두 구성하면 된다고 하는데 이 부분이 조금 이해가 안갑니다.&lt;/p&gt;&lt;p&gt;그럼 javascript를 사용하지 않고 모든 부분이 구성이 되는 것인지 알고 싶습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;제가 추구하고자 하는것은 앞으로 발전가능성이 크면서 중간정도 프로젝트 규모에서 안정적으로&amp;nbsp;&lt;/p&gt;&lt;p&gt;잘 돌아가는 환경, 시간투자대비 생산성에 중점을 둘려고 합니다. 물론 애플리케이션 프레임워크를&lt;/p&gt;&lt;p&gt;잘 만들면 되지만 애플리케이션 프레임워크를 만들어 가는 과정도 고민을 하게 됩니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;현재 Java(SWT, Swing), Javascript, Typescript 이 셋언어는 가능합니다.&lt;/p&gt;&lt;p&gt;그러나 앞에서도 말씀 드린 바 팀원들의 사용하는것은 &amp;nbsp;C#이며 웹에 대한&amp;nbsp;&lt;/p&gt;&lt;p&gt;부담갖지 않고 쉽게 따라올 수 있는 방향으로 추진 할려고 합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;현 시점에서 Node+Angular를 해야할지 Spring으로 전환을 해야 할지&lt;/p&gt;&lt;p&gt;아니면 또다른 좋은 의견이 있으신지 문의 드립니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;감사합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;[답변]&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;안녕하세요. 한장현입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Spring은 Java 백엔드 프레임워크이며,&lt;/p&gt;&lt;p&gt;많은 개발자들이 오랫동안 사용하고 유지해왔기 때문에 알려진 버그와 보안 문제는 많이 잡혀있어서 안정성이 우수하다고 볼 수 있습니다.&lt;/p&gt;&lt;p&gt;많은 사람들이 사용하다보니 정형화되어있는 패턴이 있고, 막혔을 때 다른 사람들에게 물어보기 쉬운 것도 장점입니다.&lt;/p&gt;&lt;p&gt;그래서 대기업이나 정부과제에서 많이 사용하죠.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;비교적 오래전에 나온 프레임워크지만 DI나 IoC에 대한 개념도 충실하게 들어있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;아키텍트는 패러다임의 문제이며, 구성하기에 따라 달라질 수 있으니 넘어갑니다.&lt;/p&gt;&lt;p&gt;보통 MVC 모델을 사용하는 것으로 알고 잇습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Node.js는 JavaScript 백엔드 프레임워크이며,&lt;/p&gt;&lt;p&gt;운영환경이기도 하지만 이 논의에서는 백엔드 프레임워크로만 생각하겠습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;가장 좋은 점은 모든 개발 스택에서 JavaScript를 사용할 수 있다는 것인데,&lt;/p&gt;&lt;p&gt;백엔드부터 프론트엔드까지, 더 확장하면 DB도 JavaScript로 구현할 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;아주 간단한 서버는 코드 10줄 정도로 구현할 수 있다는 것도 장점입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Angular는 프론트엔드 프레임워크이며, 프론트엔드 SPA를 만들수 있는 기능을 다양하게 제공합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;일단, 비교 대상이 잘못되었습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;백엔드를 Spring으로 개발하더라도 프론트엔드는 뭔가가 있어야 하는데&lt;/p&gt;&lt;p&gt;Spring + Angular도 가능하다는 측면에서는 Spring과 Node.js를 비교해야 하는 것이 맞습니다.&lt;/p&gt;&lt;p&gt;Angular는 온전히 프론트엔드의 영역입니다.&lt;/p&gt;&lt;p&gt;Angular는 이 논의에서 제외하겠습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Spring에 백엔드와 프론트엔드가 같이 있다는 말은&lt;/p&gt;&lt;p&gt;서버의 입장에서 프론트엔드 코드를 보내는 백엔드가 있다는 것을 혼동하신 것 같은데,&lt;/p&gt;&lt;p&gt;그렇다고 해서 Spring 프레임워크가 프론트엔드에 적극적으로 개입하는 것은 아니며,&lt;/p&gt;&lt;p&gt;JSP와 서블릿을 사용해서 프론트엔드를 개발하는 것은 조금 다른 문제입니다.&lt;/p&gt;&lt;p&gt;Spring은 어디까지나 서버 프레임워크입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;웹 표준에서 HTML 문서는 DOM 마크업과 JavaScript, CSS로 이루어지며,&lt;/p&gt;&lt;p&gt;JSP와 서블릿을 사용한다면 HTML을 JSP로 컨트롤 할 수 있지만,&lt;/p&gt;&lt;p&gt;이 부분은 JavaScript의 역할을 일부 가져온 것일 뿐입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그렇게 보면 가장 큰 차이는 Java냐 JavaScript냐의 차이이며,&lt;/p&gt;&lt;p&gt;최신 트렌드를 얼마나 반영할 수 있느냐, 안정적이냐, 자유도는 얼마나 있느냐의 문제입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;먼저 말씀드린 대로 Spring은 정형화된 패턴 위주로 개발하며, 자유도는 낮지만 같은 이유로 안정성은 높다고 생각합니다.&lt;/p&gt;&lt;p&gt;Node.js는 딱 정해진 패턴은 없으며, npm에 있는 모듈을 활용할 수 있고 JavaScript의 특성상 자유롭게 개발할 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;MVC 모델과 이벤트 드리븐의 차이도 있지만,&lt;/p&gt;&lt;p&gt;MVC 모델에서 HTTP 요청이 들어왔을 때 어떤 로직을 처리한다고 보면 이벤트 드리븐이라고 봐도 크게 다르지 않습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;결국엔 개발 언어의 차이인 것 같네요.&lt;/p&gt;&lt;p&gt;Spring을 사용하는 경우에는 Java 외에 프론트엔드에 JavaScript도 사용해야 하며,&lt;/p&gt;&lt;p&gt;DB가 SQL이든 NoSQL이든 이 부분도 Java 외에 다른 언어를 사용해야 합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;개발 언어 외에, 처리하는 데이터 객체도 각 스택마다 다릅니다.&lt;/p&gt;&lt;p&gt;SQL로 가져온 데이터는 Java에서 데이터 오브젝트(DO)로 처리하고, 프론트엔드에서는 JSON으로 처리합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;하지만 Node.js을 JSON NoSQL와 함께 사용하는 경우 모든 스택이 JavaScript를 사용합니다.&lt;/p&gt;&lt;p&gt;DB에서 JSON 객체를 가져와서 백엔드에서 JSON으로 처리하고 프론트엔드에서도 JSON으로 처리합니다.&lt;/p&gt;&lt;p&gt;Node.js의 개발 스택 중 가장 인기 있는 MEAN 스택은 이것이 가장 큰 장점이라고 생각합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&quot;중간정도 프로젝트 규모에서 안정적으로 잘 돌아가는 환경&quot;이라는 말은 좀 애매하네요...&lt;/p&gt;&lt;p&gt;보통 Spring은 엔터프라이즈급 프로젝트에 적합하다고 하고,&lt;/p&gt;&lt;p&gt;Node.js는 빠르게 개발하는 프로젝트나 프로토타입에 적합하다고 생각합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Spring에 비해 Node.js가 나온지 얼마 되지 않았기 때문에 정형화된 패턴은 아직 보지 못한 것 같네요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&quot;시간투자대비 생산성&quot;의 측면에서는 잘 아는 언어와 프레임워크를 사용하는 것이 당연히 좋습니다.&lt;/p&gt;&lt;p&gt;어떻게 개발해야 하는지 막혔을 때 찾아보기 쉬운 것은 Spring이라고 생각합니다.&lt;/p&gt;&lt;p&gt;적은 양의 코딩으로 빠르게 개발할 수 있는 것은 Node.js라고 생각합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;어떤 프레임워크와 어떤 개발 언어를 선택해야 하느냐에 대한 문제는&lt;/p&gt;&lt;p&gt;프로젝트 상황과 팀 구성요소의 실력에 따라 다르며 딱 정해진 답을 드릴 수는 없겠네요 ㅎㅎ;;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;프론트엔드만 해도 수많은 선택지가 있는 것이 또 어려운 점이죠 ㅠㅠ&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;저는 스프링을 썼을 때보다 Node.js + Angular로 개발하는 것이 더 재미있었습니다 ㅎ&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;아무쪼록 현명한 선택을 하셔서 즐겁게 개발하시길 바랍니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;고맙습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;* 3줄 요약&lt;/p&gt;&lt;p&gt;- 비교는 Spring과 Node.js를 하는 것이 맞습니다.&lt;/p&gt;&lt;p&gt;- Spring은 안정성, Node.js은 개발 언어와 데이터 객체를 풀스택으로 구성할 수 있다는 점이 가장 큰 장점이라고 생각합니다.&lt;/p&gt;&lt;p&gt;- 생산성은 개발자들이 익숙한 언어로 하는 것이 가장 좋겠죠.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;hr class=&quot;tx-hr-image-4&quot; style=&quot;background: url(//i1.daumcdn.net/deco/contents/horizontalrule/line08.gif?v=2) repeat-x scroll left; height: 15px; border:0; width:54px; margin:30px auto&quot;&gt;&lt;p&gt;결국 프로젝트와 팀원에게 가장 맞는 기술 스택을 선택하라고밖에 말씀드리지 못했는데..&lt;/p&gt;&lt;p&gt;이 글을 보시는 분들은 어떻게 생각하시나요? ㅎ&lt;br /&gt;&lt;/p&gt;</description>
<author>한장현</author>
<guid>https://han41858.tistory.com/41</guid>
<comments>https://han41858.tistory.com/41#entry41comment</comments>
<pubDate>Wed, 20 Sep 2017 19:18:05 +0900</pubDate>
</item>
<item>
<title>Angular 기본 개념 잡기</title>
<link>https://han41858.tistory.com/40</link>
<description>&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;text-align: left;&quot;&gt;안녕하세요. 한장현입니다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;지난 주말 GDG WebTech 밋업에서 발표한 &quot;Angular 기본 개념 잡기&quot; 발표 자료 공유합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;발표를 준비하면서 느꼈지만, Angular를 다른 프레임워크와 비교했을 때 가장 큰 차이는 '종합 프레임워크'라는 것이며,&lt;/p&gt;&lt;p&gt;프레임워크 자체에서 많은 기능을 제공하기 때문에 견고한 데이터 흐름을 유지할 수 있고,&lt;/p&gt;&lt;p&gt;팀원들과 작업할 때도 일정한 코드 품질을 유지할 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Angular 2.x.x 버전이 나오면서 개발 방법이나 구조가 크게 바뀐 것에 부담을 갖는 분들이 많은 것으로 보입니다.&lt;/p&gt;&lt;p&gt;하지만 AngularJS의 프레임워크 철학을 계승하고 있기 때문에, AngularJS를 사용해봤다면 Angular를 이해하기 더 쉬울 것이라 생각합니다.&lt;/p&gt;&lt;p&gt;개발 환경이나 언어가 바뀐 것에 걱정하지만, 직접 해보면 AngularJS와 개발 방법은 크게 다르지 않습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;이 자료가 Angular에 대한 거부감을 줄이는 데에 도움이 되기를 바랍니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;고맙습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/key/Zw7Y48iHd3jva&quot; width=&quot;595&quot; height=&quot;485&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt; &lt;/p&gt;&lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;//www.slideshare.net/janghyunhan/angular-79195313&quot; title=&quot;Angular 기본 개념 잡기&quot; target=&quot;_blank&quot;&gt;Angular 기본 개념 잡기&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&quot;//www.slideshare.net/janghyunhan&quot; target=&quot;_blank&quot;&gt;장현 한&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;&lt;p&gt;&lt;/p&gt;</description>
<category>Angular</category>
<author>한장현</author>
<guid>https://han41858.tistory.com/40</guid>
<comments>https://han41858.tistory.com/40#entry40comment</comments>
<pubDate>Mon, 28 Aug 2017 04:12:22 +0900</pubDate>
</item>
<item>
<title>Angular v.4.3.0에 추가된 HttpClientModule</title>
<link>https://han41858.tistory.com/39</link>
<description>&lt;p&gt;2017년 7월 10일에 발표된 Angular v.4.3.0 버전에 HttpClientModule이 추가되었습니다.&lt;/p&gt;&lt;p&gt;Angular에는 원래 &lt;code class=&quot;language-typescript&quot;&gt;@angular/http&lt;/code&gt; 패키지로 제공하던 HttpModule이 있었지만, 이번에 추가된 HttpClientModule을 사용하면 좀 더 편한 방식으로 HTTP 요청을 보낼 수 있습니다. HTTP 요청에 인터셉터를 적용할 수도 있죠.&lt;/p&gt;&lt;p&gt;원문은 angular-university.io 블로그의 &lt;a href=&quot;http://blog.angular-university.io/angular-http/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;The Angular HTTP Client - Quistart Guide&lt;/a&gt;이며, &amp;nbsp;저자의 허락을 받아 번역합니다.&lt;/p&gt;&lt;p&gt;보충 설명이 필요한 부분에는 일부 내용을 추가했습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;hr class=&quot;tx-hr-image-4&quot; style=&quot;background: url(//i1.daumcdn.net/deco/contents/horizontalrule/line08.gif?v=2) repeat-x scroll left; height: 15px; border:0; width:54px; margin:30px auto&quot;&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 글은 Angular HTTP Client 모듈을 사용하는 개발자에게 실질적인 도움을 주기 위해 작성하는 글이다. &amp;nbsp;먼저, 지금까지 Angular 프레임워크에서 사용하던 HTTP 요청에 대해 알아보고, 이번에 추가된 &lt;code class=&quot;language-typescript&quot;&gt;@angular/common/http&lt;/code&gt; 패키지에 대해 설명한다. 그리고 이 패키지가 기존에 있던 &lt;code class=&quot;language-typescript&quot;&gt;@angular/http&lt;/code&gt; 패키지와 어떻게 다른지 살펴본다.&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그리고 이 글에서는 HTTP Client 모듈을 설명하면서 실제로 동작하는 예제 코드들을 함께 적어두기 때문에, 개발에 바로 활용할 수 있을 것이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;이 글에서 다루는 내용&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul style=&quot;list-style-type: disc;&quot;&gt;&lt;li&gt;새로 추가된 HTTP Client 모듈 소개&lt;/li&gt;&lt;li&gt;HTTP GET 요청 예제&lt;/li&gt;&lt;li&gt;HTTP 요청을 보낼 때 인자 전달하기&lt;/li&gt;&lt;li&gt;HTTP 헤더&lt;/li&gt;&lt;li&gt;HTTP PUT, PATCH, POST, DELETE&lt;/li&gt;&lt;li&gt;HTTP 의 4가지 방식을 사용하는 REST 구성 예제&lt;/li&gt;&lt;li&gt;타입 검사가&amp;nbsp;강화된 새로운 API&lt;/li&gt;&lt;li&gt;중복&amp;nbsp;HTTP 요청을 방지하는 방법&lt;/li&gt;&lt;li&gt;HTTP 요청을 병렬로 보내거나, 여러 HTTP 요청 결과를 모아서 처리하는 방법&lt;/li&gt;&lt;li&gt;HTTP 요청을 순차적으로 처리하는 방법&lt;/li&gt;&lt;li&gt;여러 HTTP 요청 결과를 결합하는 방법&lt;/li&gt;&lt;li&gt;HTTP 에러 처리&lt;/li&gt;&lt;li&gt;HTTP 인터셉터&lt;/li&gt;&lt;li&gt;HTTP 진행 이벤트 처리하기&lt;/li&gt;&lt;li&gt;정리&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;Note : 이 글에서 다루는 예제는 &lt;a href=&quot;https://github.com/angular-university/angular-http-guide&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;GitHub 저장소&lt;/a&gt;에 올려두었으며, 내려받아서 직접 실행해볼 수 있다.&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;HTTP 모듈 기본&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Angular에서 제공하는 HTTP 모듈은 RxJS 옵저버블 객체를 기반으로 만들어졌다. 이 말은, Angular에서 실행하는 HTTP 관련 함수는 옵저버블을 반환하며, 이 객체를&amp;nbsp;구독해서 사용할 수 있다는 뜻이다.&lt;/p&gt;&lt;p&gt;따라서, HTTP 요청 함수를 실행하면&amp;nbsp;옵저버블 객체를 반환하기 때문에, 다음&amp;nbsp;내용을 염두에 두어야 한다.&lt;/p&gt;&lt;ul style=&quot;list-style-type: disc;&quot;&gt;&lt;li&gt;옵저버블을 구독하지 않으면 어떠한 요청도 발생하지 않는다. 실제 HTTP 요청은 &lt;code class=&quot;language-typescript&quot;&gt;subscribe()&lt;/code&gt; 함수를 실행할 때 발생한다.&lt;/li&gt;&lt;li&gt;한 옵저버블 객체를 여러번 구독하면, HTTP 요청이 여러번 발생한다. (자세한 내용은 &lt;a href=&quot;http://blog.angular-university.io/angular-2-rxjs-common-pitfalls/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;이 글&lt;/a&gt;을 참고)&lt;/li&gt;&lt;li&gt;옵저버블은 하나의 데이터를&amp;nbsp;전달하는 스트림이기 때문에, HTTP 요청이 한 번 발생할 때마다 하나의 데이터를 반환한다.&lt;/li&gt;&lt;li&gt;HTTP 요청이 실패하면 옵저버블이 에러를 반환한다.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;이 내용을 염두에 두고 HTTP 모듈에 대해 좀 더 자세하게 살펴보자.&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;새로운 HTTP 모듈 설치하기&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;새로 추가된 HTTP Client 모듈을 설치하려면 최상위 모듈에 다음과 같이 &lt;code class=&quot;language-typescript&quot;&gt;HttpClientModule&lt;/code&gt;을 추가해야 한다. 기존에 있던&amp;nbsp;&lt;code class=&quot;language-typescript&quot;&gt;HttpModule&lt;/code&gt;을 사용하는 방식과 같다.&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=01.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;예제로&amp;nbsp;사용하는 REST API&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;먼저, HTTP GET 요청부터 생각해보자. 이 글에서는 Firebase DB에서 제공하는 REST API를 사용해서 설명한다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;Firebase를 사용하는 것이 가장 일반적인 방법은 아니지만, REST API를 사용하기 간단한 방법 중에 하나다.&lt;/p&gt;&lt;p&gt;Firebase에 저장된 데이터는 다음과 같다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:725px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/225B99375970ED3303&quot; filemime=&quot;image/jpeg&quot; filename=&quot;http-guide-data.png&quot; height=&quot;482&quot; width=&quot;725&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;위 그림에서 보는&amp;nbsp;것처럼 데이터는 JSON 객체로 저장되어 있고, 배열은 사용하지 않았다. 모든 항목은 key-value 형식이며, courses의 프로퍼티로 사용된 조금 이상하게 보이는 문자열은 Firebase에서 제공하는 ID다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;HTTP GET 예제&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;이 DB에 HTTP GET 요청을 보내기 위해, 다음과 같은 컴포넌트를 하나 만들자.&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=02.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 예제는 새로운 HTTP Client 모듈을 사용하는 컴포넌트이며, DB에서 교육 과정을 정의하는&amp;nbsp;JSON 파일의 내용을 가져와서 화면에 표시한다.&lt;/p&gt;&lt;p&gt;예제 코드를 하나씩 살펴보자.&lt;/p&gt;&lt;ul style=&quot;list-style-type: disc;&quot;&gt;&lt;li&gt;이 예제는 &lt;code class=&quot;language-typescript&quot;&gt;HttpClientModule&lt;/code&gt;을 사용하며, Angular의 의존성 주입 방식에 맞게 생성자로&amp;nbsp;주입한다.&lt;/li&gt;&lt;li&gt;그리고 이 모듈의 &lt;code class=&quot;language-typescript&quot;&gt;get()&lt;/code&gt; 함수를 실행하면 Observable 객체를 반환한다.&lt;/li&gt;&lt;li&gt;옵저버블은 &lt;code class=&quot;language-typescript&quot;&gt;Object&lt;/code&gt; 객체를 반환하며, HTTP 라이브러리는 이 객체를 HTTP 응답으로 간주하고, JSON으로 파싱한다.&lt;/li&gt;&lt;li&gt;일반적으로 HTTP API는&amp;nbsp;객체를 사용하며, 배열을 전달하지는 않는다. 배열을 전달하는 방식은&lt;a href=&quot;http://haacked.com/archive/2009/06/25/json-hijacking.aspx/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt; JSON 하이재킹에 대한 문제&lt;/a&gt;도 있다.&lt;/li&gt;&lt;li&gt;그래서 응답으로 받은 객체를 배열로 변환하는 방식을&amp;nbsp;사용하는 것이 일반적이다. 데이터를 화면에 표시할 때는 객체를 사용하는 것보다 배열을 사용하는&amp;nbsp;것이 더 편하다.&lt;/li&gt;&lt;li&gt;응답으로 받은 객체를 배열로 변환할 때는 lodash에서 제공하는 &lt;code class=&quot;language-typescript&quot;&gt;values&lt;/code&gt; 함수를 사용한다.&lt;/li&gt;&lt;li&gt;옵저버블 데이터를 템플릿에 연결할 때는 &lt;code class=&quot;language-typescript&quot;&gt;courses$&lt;/code&gt; 변수를 사용한다.&lt;/li&gt;&lt;li&gt;템플릿에 사용한 &lt;code class=&quot;language-typescript&quot;&gt;async&lt;/code&gt; 파이프는 옵저버블을 구독한다. 따라서 HTTP 요청과 연결한 옵저버블의 구독은 템플릿에서&amp;nbsp;시작되며, 실제 HTTP 요청도 이 때 발생한다.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;예제를 실행하면 데이터베이스에 있는 내용이 화면에 리스트로 표시된다.&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;HTTP 요청을 보낼 때 인자 전달하기&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;HTTP GET 요청을 보낼 때 인자를 함께 전달할 수 있으며, 이 내용은 HTTP 요청 url에 추가된다. 만약 리스트를 페이지 단위로 표시하기 위해 페이지에 대한 내용을 요청 쿼리에 추가한다면 다음과 같은 형식이 될 것이다.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;https://angular-http-guide.firebaseio.com/courses.json?orderBy=&quot;$key&quot;&amp;amp;limitToFirst=1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이렇게 요청을 보내도 결과는 이전과 같겠지만, 엄밀히 따지면 이번 응답은 &lt;code class=&quot;language-typescript&quot;&gt;$key&lt;/code&gt; 프로퍼티에 따라 정렬이 된 결과다. 이 요청은 URL에 &lt;code class=&quot;language-typescript&quot;&gt;orderBy&lt;/code&gt; 인자와 &lt;code class=&quot;language-typescript&quot;&gt;limitToFirst&lt;/code&gt; 인자를 추가해서 요청해봤다.&lt;/p&gt;&lt;p&gt;Angular HTTP Client 모듈에서 이런 쿼리를 사용하는 방법은 다음과 같다.&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=03.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 코드에서는 &lt;code class=&quot;language-typescript&quot;&gt;HttpParams&lt;/code&gt; 객체를 생성하고 &lt;code class=&quot;language-typescript&quot;&gt;set()&lt;/code&gt; 함수를 체이닝하는 방식을 사용했다. &lt;code class=&quot;language-typescript&quot;&gt;HttpParams&lt;/code&gt; 객체는 이뮤터블이기 때문에 객체의 값을 직접 변경할 수 없고, &lt;code class=&quot;language-typescript&quot;&gt;set()&lt;/code&gt;과 같은&amp;nbsp;API를 사용해서 값을 지정해야 한다.&lt;/p&gt;&lt;p&gt;주의할 점은, &lt;code class=&quot;language-typescript&quot;&gt;set()&lt;/code&gt; 함수는 항상 새로운 &lt;code class=&quot;language-typescript&quot;&gt;HttpParams&lt;/code&gt; 객체를 반환하기 때문에 체이닝해서 사용해야 이전 설정이 유효하며, 다음과 같이 사용하는 방식은 유효하지 않다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=04.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;위와 같이 실행하면 &lt;code class=&quot;language-typescript&quot;&gt;params&lt;/code&gt; 객체는 아무것도 설정되지 않은 빈 &lt;code class=&quot;language-typescript&quot;&gt;HttpParams&lt;/code&gt; 객체가 된다. JavaScript String 객체의 &lt;code class=&quot;language-typescript&quot;&gt;substr()&lt;/code&gt; 함수와 비슷하게, &lt;code class=&quot;language-typescript&quot;&gt;set()&lt;/code&gt; 함수는 원래 있던 객체를 유지하고 항상 새로운 &lt;code class=&quot;language-typescript&quot;&gt;HttpParams&lt;/code&gt; 객체를 반환한다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;인자를 전달하는 또 다른 방법 : &lt;/span&gt;&lt;code class=&quot;language-typescript&quot;&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;fromString&lt;/span&gt;&lt;/code&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;미리 만들어 둔&amp;nbsp;쿼리 스트링을 그대로 활용한다면, &lt;code class=&quot;language-typescript&quot;&gt;fromString&lt;/code&gt; 옵션을 사용해서 다음과 같이 사용할 수도 있다.&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=05.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;code class=&quot;language-typescript&quot;&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;request()&lt;/span&gt;&lt;/code&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt; 함수를 사용하는 또 다른 방법&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;위에서 살펴본 코드는 GET 요청을 보내기 위해 &lt;code class=&quot;language-typescript&quot;&gt;get()&lt;/code&gt; 함수를 직접 사용했지만, 제네릭 타입인 &lt;code class=&quot;language-typescript&quot;&gt;request()&lt;/code&gt; 함수를 사용할 수도 있다. 이 함수는 GET, PUT, POST, DELETE 함수를 모두 처리하며, 첫번째 인자로 요청의 종류를 구분한다. &lt;code class=&quot;language-typescript&quot;&gt;request()&lt;/code&gt; 함수를 사용해서 이전과 같은 요청을 처리하는 코드는 다음과 같다.&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=06.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 코드에서 HTTP 요청 형식은 문자열로 지정해서 &lt;code class=&quot;language-typescript&quot;&gt;request()&lt;/code&gt; 함수에 인자로 전달하기 때문에, &lt;code class=&quot;language-typescript&quot;&gt;get()&lt;/code&gt;이나 &lt;code class=&quot;language-typescript&quot;&gt;post()&lt;/code&gt;와 같이 특정 HTTP 요청을 보내는 방식에 비교할 때 좀 더 일반적인 방식으로 사용할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;HTTP 헤더&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;브라우저에서 자동으로 붙이는 헤더 외에 커스텀 헤더를 추가하려면 &lt;code class=&quot;language-typescript&quot;&gt;HttpHeaders&lt;/code&gt; 클래스를 사용한다.&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=07.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;이 코드에서 보듯이, &lt;code class=&quot;language-typescript&quot;&gt;HttpHeaders&lt;/code&gt;는 이뮤터블 API이기 때문에 &lt;code class=&quot;language-typescript&quot;&gt;set()&lt;/code&gt; 함수를 사용해서 객체의 값을 지정하며, &lt;code class=&quot;language-typescript&quot;&gt;get()&lt;/code&gt; 함수로 HTTP 요청을 보낼 때 두 번째 인자로 &lt;code class=&quot;language-typescript&quot;&gt;HttpHeaders&lt;/code&gt; 객체를 전달한다.&lt;/p&gt;&lt;p&gt;위 예제에는 &lt;code class=&quot;language-typescript&quot;&gt;get()&lt;/code&gt; 함수에 전달하는 옵션에 &lt;code class=&quot;language-typescript&quot;&gt;headers&lt;/code&gt;만 지정했지만, 이 프로퍼티의 값은 &lt;code class=&quot;language-typescript&quot;&gt;const&lt;/code&gt;로 선언한 &lt;code class=&quot;language-typescript&quot;&gt;headers&lt;/code&gt;로 지정되며, 오브젝트의 프로퍼티 이름과 변수의 이름이 같을 때 축약해서 선언하는 방식을 사용했다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;HTTP PUT&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Angular HTTP Client 모듈은 GET 방식 외에도 다양한 HTTP 형식을 지원한다. 이 중&amp;nbsp;PUT은 RESTful API를 설계할 때 데이터를 수정하는 용도로&amp;nbsp;일반적으로 사용한다.&lt;/p&gt;&lt;p&gt;PUT 방식은 데이터의 값 전체를 바꿀 때 사용하는 것이 좋다. 그래서 이 글에서는 교육 과정 객체를 완전히 바꾸는 예제로 PUT 방식을 소개한다.&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=08.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 코드는 컴포넌트 클래스 중 &lt;code class=&quot;language-typescript&quot;&gt;httpPutExample()&lt;/code&gt; 함수에 대한 내용이다. 버튼에서 클릭 이벤트가 발생하면 PUT 요청 결과가 콘솔에 다음과 같이 표시된다.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;
PUT call successful value returned in body 

{courseListIcon: &quot;https://angular-academy.s3.amazonaws.com/main-logo/main-page-logo-small-hat.png&quot;, description: &quot;Angular Tutorial For Beginners TEST&quot;, iconUrl: &quot;https://angular-academy.s3.amazonaws.com/thumbnails/angular2-for-beginners.jpg&quot;, longDescription: &quot;...&quot;, url: &quot;new-value-for-url&quot;}

The PUT observable is now completed.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;결과에서 보듯이 PUT 요청을 사용하면 교육 과정 객체를 새로운 객체로 바꿀 수 있으며, 물론 일부 프로퍼티만 바꿀 수도 있다.&lt;/p&gt;&lt;p&gt;그리고 PUT 요청으로 보낸 데이터는 응답으로 다시 한 번 돌아온다. 이 예제의 경우는 새로운 교육 과정을 정의한 객체다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;HTTP PATCH&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;지금까지 설명한 내용은 이미 익숙하겠지만, 이제 새로운 내용을 알아보자. 어떤 객체의 프로퍼티를 하나만 바꾸고 싶을 때 HTTP PATCH 방식을 사용할 수 있다.&lt;/p&gt;&lt;p&gt;예를 들면, 교육 과정 객체에서 설명만 바꾸고 싶다면 다음과 같이 사용한다.&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=09.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;PATCH 요청이&amp;nbsp;끝나고 콘솔에 표시되는 결과는 다음과 같다.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;
PATCH call successful value returned in body 

{description: &quot;Angular Tutorial For Beginners PATCH TEST&quot;}

The PATCH observable is now completed.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;결과에서 보는 것처럼 PATCH 방식은 변경하려는 항목만 서버로 보내며, 응답도 마찬가지로 서버에서 변경된 항목만 받는다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;HTTP DELETE&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;데이터를 삭제하는 용도로 DELETE 방식도 많이 사용되며,&amp;nbsp;서버에서 DELETE 요청을 받으면 데이터를 완전히 삭제할 수도 있고, 삭제되었다고 표시만 할 수도 있다. 교육 과정 객체 중 하나를 삭제하는 코드는 다음과 같다.&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=10.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 코드를 실행했을 때 콘솔의 출력되는 내용은 다음과 같다.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;
DELETE call successful value returned in body null
The DELETE observable is now completed.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Firebase를 사용하는 경우에는 DB에 있던 데이터가 완전히 삭제되지만, 다른 방식으로 REST API를 구성한다면 논리적으로 삭제 표시를 하는 방법도 사용할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;HTTP POST&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;지금까지 설명한 GET 방식이나 PUT, PATCH, DELETE 방식에 해당되지 않는 경우는 POST를 다양하게 활용할 수 있다.&lt;/p&gt;&lt;p&gt;POST 방식은 보통 새로운 데이터를 DB에 입력하기 위해 사용하지만, 그 외의 용도로도 많이 활용한다. 다음 코드는 새로운 교육 과정을 DB에 추가하는 예제 코드다.&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=11.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그리고 POST 요청이 완료된 후에 콘솔에 출력되는 내용은 다음과 같다.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;
POST call successful value returned in body {name: &quot;-KolPZIn25aSYCNJfHK5&quot;}
The POST observable is now completed.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 코드에서는 POST 요청을 보내서 DB에 데이터를 추가한 후에 추가된 객체의 식별자를 클라이언트에서 받았기 때문에, 필요하다면 이 식별자를 활용할 수도 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;중복 HTTP 요청 방지하기&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;HTTP 모듈을 어떻게 사용하느냐에 관계없이, 같은 HTTP 요청이 여러번 발생하는 것은&amp;nbsp;언제나 신경쓰이는 문제다. 원래 이 동작은 HTTP 옵저버블의 입장에서는 당연한 동작이지만, 개발하던 코드가 이렇게 동작하면 아무래도 찜찜할 수 밖에 없다.&lt;/p&gt;&lt;p&gt;반응형으로 프로그래밍하다 보면 옵저버블을 자주 만들고, 이 옵저버블을 다른 곳에서 구독하면서 옵저버블을 생성하게 된다.&lt;/p&gt;&lt;p&gt;예를 들어, 서비스 객체에서 어떤 로그를 서버로 보내기 위해 HTTP 옵저버블을 생성하는 경우를 생각해보자.&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=12.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 예제에서는 HTTP 옵저버블을 바로 생성하기 위해 함수 안에서 &lt;code class=&quot;language-typescript&quot;&gt;subcribe()&lt;/code&gt; 함수도 실행했다. 그리고 이 옵저버블은 &lt;code class=&quot;language-typescript&quot;&gt;courses$&lt;/code&gt; 클래스 멤버로 할당하고&amp;nbsp;컴포넌트 템플릿에서 &lt;code class=&quot;language-typescript&quot;&gt;async&lt;/code&gt; 파이프로 사용한다고 하자.&lt;/p&gt;&lt;p&gt;즉, 옵저버블의 구독이 두 번 이루어지기 때문에 같은 HTTP 요청이 두 번 발생한다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;새로운 RxJS 연산자 : &lt;/span&gt;&lt;code class=&quot;language-typescript&quot;&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;shareReplay&lt;/span&gt;&lt;/code&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;이런 상황을 해결하는 방법은 여러가지가 있지만, 최근에 RxJS에서도 이 경우를 처리하기 위해 &lt;a href=&quot;https://github.com/ReactiveX/RxJS/commit/5a2266a&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;shareReplay&lt;/a&gt; 연산자를 추가했으며, 이 연산자를 사용하는 것이 가장 좋다.&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-typescript&quot;&gt;shareReplay&lt;/code&gt; 연산자는 2017년 5월 9일에 발표된 RxJS 5.4.0 버전부터 제공된다. 이 연산자가 처음 추가된 것은 2015년 10월 13일에 발표된 5.0.0-alpha.3 버전이었지만, 이후 알파버전에서 삭제되었다가 다시 추가되었다.&lt;/p&gt;&lt;p&gt;RxJS 개발자인 Ben Lesh에 따르면 이 연산자는 다음과 같은 방식으로 동작한다.&lt;/p&gt;&lt;blockquote class=&quot;tx-quote-tistory&quot;&gt;&lt;p&gt;&lt;code class=&quot;language-typescript&quot;&gt;shareReplay&lt;/code&gt; 연산자는 자주 보내는 AJAX 요청의 결과를 캐시에 저장해 두는 것처럼&amp;nbsp;활용하는 연산자다.&lt;br /&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;이 연산자를 사용하면 위 코드는 다음과 같이 수정할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=14.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;language-typescript&quot;&gt;shareReplay&lt;/code&gt; 연산자를 사용하면, 똑같은 HTTP 요청이 발생하는 것을 더이상 걱정하지 않아도 된다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;HttpClient 모듈로 HTTP를 처리하는 기본 내용은 여기까지다. 그리고 이제는 실제 개발에 적용할 만한 고급 테크닉을 살펴보자.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;HTTP 요청을 병렬로 보내거나, 결과를 조합하는 방법&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;HTTP 요청을 병렬로 보내는 방법 중 하나는 RxJS에서 제공하는 &lt;code class=&quot;language-typescript&quot;&gt;forkjoin&lt;/code&gt; 연산자를 사용하는 것이다.&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=15.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 예제는 HTTP GET 옵저버블을 &lt;code class=&quot;language-typescript&quot;&gt;forkjoin&lt;/code&gt; 연산자로 조합해서 새로운 옵저버블 객체를 만드는 방식이다.&lt;/p&gt;&lt;p&gt;다만,&amp;nbsp;&lt;code class=&quot;language-typescript&quot;&gt;parallel$&lt;/code&gt; 옵저버블은 GET 요청을 위해 생성한 두 개의 옵저버블이 모두 스트림을 생성할 때만 새로운 스트림을 생성한다. 그리고 &lt;code class=&quot;language-typescript&quot;&gt;parallel$&lt;/code&gt; 옵저버블 스트림으로 전달되는 결과값은 배열 형식이며, &lt;code class=&quot;language-typescript&quot;&gt;get()&lt;/code&gt; 함수의 개수에 따라 길이도 변하는 것도 처리해야 한다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;HTTP 요청을 순서대로 처리하기, 첫 번째 응답 결과를 두 번째 요청에 활용하기&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;HTTP 요청을 보낼 때, 첫 번째 보낸 요청의 응답의 결과를 두 번째 HTTP 요청에 활용하는 경우도 자주 만날 수 있다. 이 경우를 간단하게 처리하는 방법은 &lt;code class=&quot;language-typescript&quot;&gt;switchMap&lt;/code&gt; 연산자를 사용하는 것이다.&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=16.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 예제에서는 &lt;code class=&quot;language-typescript&quot;&gt;get()&lt;/code&gt; 함수를 사용할 때 제네릭을 사용해서 &lt;code class=&quot;language-typescript&quot;&gt;Course&lt;/code&gt; 타입을 명시적으로 지정했다. &lt;code class=&quot;language-typescript&quot;&gt;get()&lt;/code&gt; 함수를 사용할 때 옵션으로 제네릭을 지정할 수 있으며, 타입에&amp;nbsp;좀 더 엄격한 코드를 작성할 수 있다.&lt;/p&gt;&lt;p&gt;제네릭 타입을 사용하지 않는다면 &lt;code class=&quot;language-typescript&quot;&gt;Course&lt;/code&gt; 타입에 대해 추론한 결과는 &lt;code class=&quot;language-typescript&quot;&gt;Object&lt;/code&gt;가 되겠지만, 이 예제에서는 명시적으로&amp;nbsp;&lt;code class=&quot;language-typescript&quot;&gt;Course&lt;/code&gt; 타입을 지정했기 때문에, &lt;code class=&quot;language-typescript&quot;&gt;switchMap&lt;/code&gt; 함수 안에서도 &lt;code class=&quot;language-typescript&quot;&gt;Course&lt;/code&gt;타입에 대한 안내나 자동완성 기능도 지원된다.&lt;/p&gt;&lt;p&gt;이 예제에서 &lt;code class=&quot;language-typescript&quot;&gt;switchMap&lt;/code&gt; 연산자를 사용했을 때&amp;nbsp;HTTP 요청을 어떻게 체이닝하는지 단계별로 자세하게 살펴보자.&lt;/p&gt;&lt;ul style=&quot;list-style-type: disc;&quot;&gt;&lt;li&gt;교육 과정 데이터를 받아올 HTTP GET 요청을 정의한다.&lt;/li&gt;&lt;li&gt;HTTP 응답과 연결된 옵저버블에 새로운 값이 생성되면, 옵저버블로 맵핑된 함수가 실행되고 HTTP PUT 요청을 처리하는 또 다른 옵저버블을&amp;nbsp;생성한다.&lt;/li&gt;&lt;li&gt;이렇게 생성된 옵저버블은 수정할 교육 과정에 대한 데이터를 서버에 보낸다.&amp;nbsp;&lt;/li&gt;&lt;li&gt;HTTP PUT 요청 함수는 &lt;code class=&quot;language-typescript&quot;&gt;switchMap&lt;/code&gt;&amp;nbsp;연산자로 연결하는데, &lt;code class=&quot;language-typescript&quot;&gt;switchMap&lt;/code&gt;&amp;nbsp;연산자는 옵저버블을 반환하며, 마지막으로 이 옵저버블을 &lt;code class=&quot;language-typescript&quot;&gt;subscribe()&lt;/code&gt; 함수로 구독한다.&lt;/li&gt;&lt;li&gt;마지막 옵저버블을 구독하면 제일 처음 정의했던 HTTP GET 요청도 시작된다.&lt;/li&gt;&lt;li&gt;제일 처음 정의했던 HTTP GET 요청의 결과는 마지막 옵저버블까지 영향을 준다.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://blog.angular-university.io/rxjs-switchmap-operator/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;이전에 작성했던 switchMap 연산자에 대한 포스팅&lt;/a&gt;을 잠시 보면, 이 연산자는 이 경우 말고도 여러가지 방식으로 활용할 수 있다.&lt;/p&gt;&lt;p&gt;그리고, 다음과 같이 여러 HTTP 요청 결과를 동시에 처리하는 경우에도 사용할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;순서대로 발생한 HTTP 요청 결과를 모으는 방법&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;이전 절에서는 &lt;code class=&quot;language-typescript&quot;&gt;switchMap&lt;/code&gt; 연산자를&amp;nbsp;사용해서 HTTP 요청을 순서대로 처리하고, 이 때 첫&amp;nbsp;번째 HTTP 요청에 대한 응답을 두 번째 HTTP 요청에 활용하는 방법을 알아봤다.&lt;/p&gt;&lt;p&gt;하지만 이 경우는 최종 옵저버블 스트림에 첫 번째 HTTP 요청에 대한 결과는 없으며, 두 번째 HTTP 요청에 대한 결과만 전달된다.&lt;/p&gt;&lt;p&gt;두 번의 HTTP 요청이 있었고, 이 요청의 응답 데이터를 모두 활용하려고 한다면, &lt;code class=&quot;language-typescript&quot;&gt;switchMap&lt;/code&gt;&amp;nbsp;연산자의 두 번째 인자로 셀렉터 함수(selector function)를 지정하면 된다.&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=17.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그러면 마지막에 구독한 옵저버블에는 두 번의 HTTP 요청에 대한 결과가 배열로 전달된다. 셀렉터 함수를 사용하면 뒤에 연결될 옵저버블 스트림에 원하는 데이터를 선택해서 전달할 수 있으며, &lt;code class=&quot;language-typescript&quot;&gt;switchMap&lt;/code&gt;&amp;nbsp;연산자뿐만 아니라 옵저버블 연산자 중에 셀렉터 함수를 지원하는 함수들도 몇가지&amp;nbsp;있다.&lt;/p&gt;&lt;p&gt;이 예제에서는 두 번의 HTTP 요청을 체이닝하기 위해 &lt;code class=&quot;language-typescript&quot;&gt;switchMap&lt;/code&gt; 연산자를 사용했지만, 필요하다면 마지막 옵저버블에도 &lt;code class=&quot;language-typescript&quot;&gt;switchMap&lt;/code&gt; 연산자를 사용해서 체이닝을 이어갈 수도 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;HTTP 에러 처리&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;RxJS를 사용했을 때 특히 좋은 점 중에 하나는, 에러 처리 기능이 내장되어 있다는 것이다. 이 에러 처리 기능은 비동기 프로그래밍 라이브러리를 사용하면서 흔하게 접할 수 없기 때문에 더 반가운 기능이다.&lt;/p&gt;&lt;p&gt;RxJS에서 에러를 처리해야 하는 경우는 &lt;a href=&quot;https://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/error_handling.html&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;정말 많지만&lt;/a&gt;, 이 포스팅은 HTTP 모듈에 대해 설명하고 있기 때문에 HTTP 요청에 대한 에러 처리에 집중하자. 이번 예제에서는 다음과 같은 경우에 처리하려고 한다.&lt;/p&gt;&lt;ul style=&quot;list-style-type: disc;&quot;&gt;&lt;li&gt;HTTP 요청에서 에러가 발생할 수 있다.&lt;/li&gt;&lt;li&gt;HTTP 응답이 돌아오면 이 에러 메시지를 사용자에게 보여주고 싶다.&lt;/li&gt;&lt;li&gt;HTTP 요청은 성공하지 않았지만, 화면에 표시할&amp;nbsp;데이터는 따로 준비한다.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;p&gt;RxJS에서 에러를 처리할 때는&amp;nbsp;&lt;code class=&quot;language-typescript&quot;&gt;catch&lt;/code&gt; 연산자를 사용한다.&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=18.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 예제를 이해하기 위해, 먼저 콘솔에 출력되는 내용이 어떻게 되는지 보자.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;
Error catched 

HttpErrorResponse {headers: HttpHeaders, status: 404, statusText: &quot;Not Found&quot;, url: &quot;http://localhost:4200/api/simulate-error&quot;, ok: false, … }

Value emitted successfully {description: &quot;Error Value Emitted&quot;}
HTTP Observable completed...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그리고 에러가 처리되는 과정을 보면 다음과 같다.&lt;/p&gt;&lt;ul style=&quot;list-style-type: disc;&quot;&gt;&lt;li&gt;HTTP 요청이 발생했을 때&amp;nbsp;테스트 서버에서는 에러 결과를 응답한다.&lt;/li&gt;&lt;li&gt;옵저버블에서 예외가 발생하면 &lt;code class=&quot;language-typescript&quot;&gt;catch&lt;/code&gt; 연산자가 실행되고, 이 연산자에 연결된 에러 처리 함수가 실행된다.&lt;/li&gt;&lt;li&gt;이 에러 처리 함수 안에서 화면에 표시할 에러 메시지를 생성한다.&lt;/li&gt;&lt;li&gt;그리고 이렇게 만든 에러 메시지는 &lt;code class=&quot;language-typescript&quot;&gt;Observable.of()&lt;/code&gt; 연산자를 사용해서&amp;nbsp;반환한다.&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;language-typescript&quot;&gt;Observable.of()&lt;/code&gt; 연산자는 한 번만 값을 보내는 옵저버블을 생성한다. 이때 생성된 옵저버블은 사용된 후에 바로 종료된다.&lt;/li&gt;&lt;li&gt;에러가 처리된 옵저버블은 &lt;code class=&quot;language-typescript&quot;&gt;subscribe()&lt;/code&gt; 함수에 의해 다시 한 번 구독되면서, 에러가 발생했을 때 새로 만든 에러 메시지를 정상 객체로 전달한다. 만약 HTTP GET 요청에서 에러가 발생하지 않았다면, HTTP GET 요청의 결과가 &lt;code class=&quot;language-typescript&quot;&gt;subscribe&lt;/code&gt; 함수로 전달될 것이다.&lt;/li&gt;&lt;li&gt;에러를 처리한 옵저버블이 종료되면, 마지막에 생성한 옵저버블도 종료된다.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;code class=&quot;language-typescript&quot;&gt;catch&lt;/code&gt; 연산자를 사용하면 마지막&amp;nbsp;옵저버블의 에러 처리함수는 절대 실행되지 않는다는 점만&amp;nbsp;명심하자. &lt;code class=&quot;language-typescript&quot;&gt;catch&lt;/code&gt; 연산자 이전의 옵저버블(이 예제에서는 HTTP 요청)에서 에러가 발생하는 것은 &lt;code class=&quot;language-typescript&quot;&gt;catch&lt;/code&gt; 연산자에 지정된 에러 처리함수가 모두 처리하기 때문이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;HTTP 인터셉터&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;이번에 발표된 HTTP&amp;nbsp;Client 모듈에는 HTTP 인터셉터가 추가되었는데, 이 HTTP 인터셉터를 사용하면&amp;nbsp;HTTP 요청을 처리하기 전이나 후에 특정 기능을 실행할 수 있다.&lt;/div&gt;&lt;p&gt;클라이언트에서 보내는 모든 HTTP 요청의 헤더에 인증 토큰을 넣어야 하는 경우를 생각해보자.&lt;/p&gt;&lt;p&gt;이 경우에는 &lt;code class=&quot;language-typescript&quot;&gt;HttpInterceptor&lt;/code&gt; 인터페이스를 기반으로 다음과 같이 구현하면 된다.&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=19.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 예제에서 작성한 인터셉터를 한 단계씩 살펴보자.&lt;/p&gt;&lt;ul style=&quot;list-style-type: disc;&quot;&gt;&lt;li&gt;HTTP 인터셉터도 일반적인 Angular 서비스다. 필요하다면 생성자를 통해 다른 서비스를 의존성으로 주입할 수도 있다.&lt;/li&gt;&lt;li&gt;이 예제에서는 인증 토큰을 가져오기 위해, 전역에 만들어 둔&amp;nbsp;인증 서비스(&lt;code class=&quot;language-typescript&quot;&gt;AuthService&lt;/code&gt;)를 의존성으로 주입한다.&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;language-typescript&quot;&gt;intercept()&lt;/code&gt; 메소드는 인자를 두 개 받는다. 첫 번째는 처리할 요청이고, 두번째는 다음 인터셉터를 가리키는&amp;nbsp;HTTP 핸들러다.&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;language-typescript&quot;&gt;next.handle()&lt;/code&gt; 메소드는 인터셉터를 체이닝할 때 사용한다.&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;language-typescript&quot;&gt;next.handle()&lt;/code&gt; 메소드는 옵저버블을 반환하기 때문에, 이 예제의 &lt;code class=&quot;language-typescript&quot;&gt;intercept()&lt;/code&gt; 함수도 옵저버블을 반환한다고 볼 수 있다.&lt;/li&gt;&lt;li&gt;이런 구현 방식은 express와 같은 미들웨어 라이브러리와도 비슷하다.&lt;/li&gt;&lt;li&gt;첫 번째 인자로 받는 &lt;code class=&quot;language-typescript&quot;&gt;HttpRequest&lt;/code&gt; 객체는 이뮤터블이며, 헤더를 추가하는 등 &amp;nbsp;객체의 내용을 변경하려면 &lt;code class=&quot;language-typescript&quot;&gt;clone()&lt;/code&gt; 함수를 사용해서 새로운 &lt;code class=&quot;language-typescript&quot;&gt;HttpRequest&lt;/code&gt; 객체를 만들어야 한다.&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;language-typescript&quot;&gt;HttpRequest&lt;/code&gt; 안의 헤더 객체도 이뮤터블이다. 따라서, 이 예제에서는 &lt;code class=&quot;language-typescript&quot;&gt;HttpRequest&lt;/code&gt; 객체의 &lt;code class=&quot;language-typescript&quot;&gt;clone()&lt;/code&gt; 함수를 실행할 때 &lt;code class=&quot;language-typescript&quot;&gt;req.headers.set()&lt;/code&gt; 함수로 새로운 헤더 객체를 생성하고 있다.&lt;/li&gt;&lt;li&gt;이제 복사된 &lt;code class=&quot;language-typescript&quot;&gt;HttpRequest&lt;/code&gt; 객체의 헤더에는 &lt;code class=&quot;language-typescript&quot;&gt;X-CustomAuthHeader&lt;/code&gt; 항목이 존재한다.&lt;/li&gt;&lt;li&gt;이 &lt;code class=&quot;language-typescript&quot;&gt;HttpRequest&lt;/code&gt; 객체는 다음 미들웨어 체인으로 전달된다.&amp;nbsp;&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;이렇게 작성한 인터셉터를 HTTP 요청에 적용하려면, 모듈을 정의하는 파일을 열어서 프로바이더에 &lt;code class=&quot;language-typescript&quot;&gt;HTTP_INTERCEPTOR&lt;/code&gt; 프로바이더를 다음과 같이 추가하면 된다.&lt;/div&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=20.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;HTTP 진행 이벤트 처리하기&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;HTTP Client 모듈을 사용하면 HTTP 통신의 진행 상황을 나타내는 이벤트를 처리할 수 있다. 이 이벤트를 받아서 처리하는 예제는 다음과 같다.&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/jhades/9c439200c392d4e32c5b28c1c8052d02.js?file=21.ts&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그리고 이 예제를 실행하면 콘솔의 출력 결과는 다음과 같다.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;line-numbers language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;
Upload progress event Object {type: 1, loaded: 2, total: 2}
Download progress event Object {type: 3, loaded: 31, total: 31}
Response Received... Object {description: &quot;POST Response&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;HTTP 요청을 생성할 때 &lt;code class=&quot;language-typescript&quot;&gt;reportProgress&lt;/code&gt; 옵션을 지정하는 아주 간단한 방법으로,&amp;nbsp;HTTP 요청이 어디까지 진행되었는지 이벤트로 받아서 처리할 수 있다. 이 예제에서는 다음과 같은 경우를 처리한다.&lt;/p&gt;&lt;ul style=&quot;list-style-type: disc;&quot;&gt;&lt;li&gt;서버로 데이터를 보낼 때 업로드 진행도에&amp;nbsp;대한 이벤트&lt;/li&gt;&lt;li&gt;서버에서 파일을 내려받을 때 진행도에 대한 이벤트&lt;/li&gt;&lt;li&gt;HTTP 요청이 완료되고 서버 응답을 받았을 때&amp;nbsp;발생하는 이벤트&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;정리&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Angular에 새로 추가된 Http Client 모듈은 이전에 있던 HTTP 모듈을 크게 개선한 것으로 보이며, 한 단계 진화했다고 할 수 있을 정도다. 사용자가 사용하기 좀 더 편해졌고, 타입 검사에 대한 안전성도 높였다.&lt;/p&gt;&lt;p&gt;그리고 이전에 있던 HTTP 모듈과 비교하면, 인터셉터나 HTTP 진행 이벤트를 처리하는 기능도 추가되었다.&lt;/p&gt;&lt;p&gt;이전에 있던&amp;nbsp;HTTP 모듈을 사용하고 있었더라도, 이 API들은 HTTP&amp;nbsp;Client 모듈에도 대응하는 API가 있기 때문에 HttpClientModule로 변경하는 것도 크게 어려운 작업은 아닐 것이다.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<category>Angular HttpClientModule</category>
<author>한장현</author>
<guid>https://han41858.tistory.com/39</guid>
<comments>https://han41858.tistory.com/39#entry39comment</comments>
<pubDate>Tue, 18 Jul 2017 01:00:07 +0900</pubDate>
</item>
<item>
<title>Angular 책 출판 후기 &amp; 세미나 사전 조사</title>
<link>https://han41858.tistory.com/38</link>
<description>&lt;p&gt;안녕하세요. 한장현입니다.&lt;/p&gt;&lt;p&gt;책을 집필하기 시작하면서 블로그는 잠시 쉬었네요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:410px;width: 410px; height: 359px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/26B70233596898F11A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;cover_3D.png&quot; height=&quot;359&quot; style=&quot;width: 410px; height: 359px;&quot; width=&quot;410&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;길게 봤을 때 블로그에 단편적인 내용을 적기 보다는,&lt;/p&gt;&lt;p&gt;한 권의 책에 체계적인 내용을 담는 것이 더 낫다고 생각했기 때문에 블로그는 잠시 쉬기로 했었습니다.&lt;/p&gt;&lt;p&gt;이제 책을 낸 지 한 달 정도 된 시점에, 책을 낸 이후의 상황을 잠시 돌아보려고 합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;역자 서문에 썼던 것처럼, 블로그를 시작했던 것이 책을 집필할 수 있는 기회가 되었습니다.&lt;/p&gt;&lt;p&gt;웹 트렌드에 대한 글을 옮겨오면서, 개인적으로 관심이 많던 Angular에 대한 글을 자주 쓰게 되었고&lt;/p&gt;&lt;p&gt;Angular 원서를 번역할 저자를 찾던 출판사에서 연락을 주셨네요.&lt;/p&gt;&lt;p&gt;부족한 글재주를 좋게 보고 기회를 주신 출판사 관계자분들께 다시 한 번 감사드립니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Angular 2 초기 버전에 변동사항이 많았기 때문에 최종 원고를 받은 것은 2017년 1월초였고,&lt;/p&gt;&lt;p&gt;이 때부터 풀타임으로 집필을 시작해서 6월 2일에 마지막 원고를 보냈으니, 5개월 걸린 것 같네요&lt;/p&gt;&lt;p&gt;그 이후에 마무리 시간이 조금 들어가고 책은 6월 7일에 출간되었습니다.&lt;/p&gt;&lt;p&gt;서점에 갈때마다 제 책이 놓여있는 것을 보면 굉장히 뿌듯하네요 ㅎㅎㅎ&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;책을 출판한 후에 GitHub을 통해 오타 제보를 받고 있는데, 다행히 예제가 돌아가지 않을 정도의 심각한 오류는 없는 것 같습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;정오표는 GitHub 메인 페이지의 아래쪽에 둘까 했지만, 독자의 입장에서는 목차보다 이 내용이 중요할 것이라고 생각해서 위쪽으로 올렸습니다.&lt;/p&gt;&lt;p&gt;꼼꼼히 봤다고 생각했지만, 정오표가 굉장히 길어지고 있어서 한편으로는 부끄럽습니다.&lt;/p&gt;&lt;p&gt;초판이 다 팔려서 2쇄를 할지는 모르겠지만, 2쇄를 진행한다면 이 내용은 꼭 반영하도록 하겠습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;질문하시는 내용도 아는 한에서 설명을 드리고 있고, 잘 모르는 내용이면 제가 찾아봐서 답변을 드리기 때문에 제가 공부하는 데에도 도움이 됩니다 ㅎ&lt;/p&gt;&lt;p&gt;질문을 하시는 것에 부담을 느끼지 않으시면 좋겠습니다^^&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;책이 잘 팔리고 있는지는 잘 모르겠습니다 ㅎㅎㅎ&lt;/p&gt;&lt;p&gt;출판사와 한 계약이 번역 계약이기 때문에, 인세 계약과는 달리 출판 부수를 정확히 알기는 어렵네요.&lt;/p&gt;&lt;p&gt;출판사에 물어볼 수도 있지만, 호기심을 해결하기 위해 바쁘게 일하는 분들을 귀찮게 하고 싶지는 않고.. 가끔씩 물어보려구요^^;&lt;/p&gt;&lt;p&gt;온라인 서점 판매지수로 간접적으로 확인하고 있습니다 ㅎ&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;가끔 &quot;집필이 아니고 번역이야~?&quot; 라는 말을 듣는 경우가 있는데,&lt;/p&gt;&lt;p&gt;이 얘기를 들으면 조금 울컥하기도 합니다 ㅎㅎ&lt;/p&gt;&lt;p&gt;이야기 하시는 분들이 &quot;집필이 아니고 번역이니 조금 덜 대단하다&quot;는 식으로 얘기하시는 건 물론 아니겠지만, 민감한 부분이거든요 ㅎ&lt;/p&gt;&lt;p&gt;사전에서 단어를 찾아서 1:1로 변환하는 거라면 저런 이야기를 들어도 신경쓰지 않겠지만&lt;/p&gt;&lt;p&gt;여러 번 보면서 문장의 흐름도 생각해서 필요없는 부분을 빼고, 원서에 없는 부분을 보충해서 넣은 만큼, 제가 집필한 책에 애정을 갖고 있어서 그런 얘기를 듣고 가볍게 흘릴만큼 마음이 넓지 못해 죄송합니다 ㅠㅠ&lt;/p&gt;&lt;p&gt;혹시 주변에 책 쓰는 분들이 있으면 &quot;어휴~ 뭐 그런 어려운 걸 하냐&quot;라고 해주시는 것만으로 충분할 것 같습니다 ㅎㅎㅎㅎ&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;요즘은 Angular 프레임워크를 현업에 사용하고 있으며, 좀 더 깊이있는 내용을 연구해서 Angular 심화 내용을 다루는 책을 준비하려고 합니다.&lt;/p&gt;&lt;p&gt;목차가 어떻게 되냐, 책은 언제 나오냐를 이야기 할 단계는 아니며, 어떤 내용을 담을지 고민하고 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;책을 준비하며 이런 저런 내용을 보기도 하고,&lt;/p&gt;&lt;p&gt;GitHub으로 독자분들의 질문에 대해서도 생각을 하고,&lt;/p&gt;&lt;p&gt;다른 프론트엔드 프레임워크도 공부하면서 생각을 해보니&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Angular는 이렇게 좋은데 왜 안쓸까...&lt;/p&gt;&lt;p&gt;AngularJS에 비해서도 Angular의 인기가 시들해진 것 같아서 새로운 프로젝트를 하려고 합니다.&lt;/p&gt;&lt;p&gt;써보니까 Angular 되게 좋거든요 ㅎㅎㅎㅎㅎ&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그래서...&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24pt;&quot;&gt;* Angular 기초 세미나&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Angular 세미나를 해보려고 합니다.&lt;/p&gt;&lt;p&gt;내용은 기초 내용부터 하려고 하는데 JavaScript부터 해야할 지, ES6부터 해야할 지, Angular를 바로 시작할 지는 고민중입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그리고 오프라인으로 사람들을 모으려면 신경써야 하는 내용이 좀 더 있어서&lt;/p&gt;&lt;p&gt;시간을 정해서 온라인으로 진행하려고 하고 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;아직 기획을 하는 단계라서 딱히 말씀 드릴 내용이 많지는 않네요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그래서 세미나를 어떻게 진행하면 좋을지 의견을 좀 받고 싶습니다^^&lt;/p&gt;&lt;p&gt;커리큘럼 난이도에 대한 내용이며, 이 설문이 신청을 의미하는 것은 아닙니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;준비가 되면 따로 신청을 받도록 하겠습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Angular를 기초부터 공부하려고 하는 분들은 본인이 듣고 싶은 내용으로 설문에 답해주시면 적극 반영하겠습니다~&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://goo.gl/forms/YdRflUuA2PGuZoy62&quot; target=&quot;_blank&quot;&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&amp;gt; 설문 작성하기 &amp;lt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;</description>
<author>한장현</author>
<guid>https://han41858.tistory.com/38</guid>
<comments>https://han41858.tistory.com/38#entry38comment</comments>
<pubDate>Fri, 14 Jul 2017 18:30:14 +0900</pubDate>
</item>
<item>
<title>Angular 책을 출판했습니다.</title>
<link>https://han41858.tistory.com/37</link>
<description>&lt;p&gt;안녕하세요. 한장현입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;블로그에 오랜만에 글을 쓰네요 ㅎ&lt;/p&gt;&lt;p&gt;잠시 블로그를 쉬고 Angular 책을 쓰기 시작했는데, 얼마 전에 Angular 책을 출판했습니다~ㅎㅎ&lt;/p&gt;&lt;p&gt;책 제목은 Angular Development with TypeScript입니다~~&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:734px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/2325E350594392B637&quot; filemime=&quot;image/jpeg&quot; filename=&quot;cover.jpg&quot; height=&quot;1012&quot; width=&quot;734&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;단편적인 내용을 포스팅하는 것보다는, Angular 프레임워크를 처음부터 끝까지 다루는 것이 실질적인 도움이 될 것으로 생각합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;지금 서점에서 만나볼 수 있습니다!! ㅎ&lt;/p&gt;&lt;p&gt;Angular 공부하시는 데에 도움이 되길 바랍니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;제 책을 구입하신 분 중에 오프라인에서 저를 만나는 분에게는 제가 직접 주문한 Angular 스티커를 드립니다 ㅎㅎ&lt;/p&gt;&lt;p&gt;스티커 달라고 하세요~!! ㅎ&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;고맙습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&lt;b&gt;- 구입처&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul style=&quot;padding-left: 2em; box-sizing: border-box; margin-top: 0px; margin-bottom: 16px; color: rgb(36, 41, 46); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Segoe UI&amp;quot;, Helvetica, Arial, sans-serif, &amp;quot;Apple Color Emoji&amp;quot;, &amp;quot;Segoe UI Emoji&amp;quot;, &amp;quot;Segoe UI Symbol&amp;quot;; font-size: 16px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9791186710159&amp;amp;orderClick=LEA&amp;amp;Kc=&quot; style=&quot;color: rgb(3, 102, 214); box-sizing: border-box; background-color: transparent;&quot;&gt;인터넷 교보문고&lt;/a&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;&lt;a href=&quot;http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=110998774&quot; style=&quot;color: rgb(3, 102, 214); box-sizing: border-box; background-color: transparent;&quot;&gt;알라딘&lt;/a&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;&lt;a href=&quot;http://www.yes24.com/24/goods/42474040?scode=032&amp;amp;OzSrank=5&quot; style=&quot;color: rgb(3, 102, 214); box-sizing: border-box; background-color: transparent;&quot;&gt;예스24&lt;/a&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;&lt;a href=&quot;http://bsearch.interpark.com/dsearch/book.jsp?sch=all&amp;amp;sc.shopNo=&amp;amp;bookblockname=s_main&amp;amp;booklinkname=s_main&amp;amp;bid1=search_auto&amp;amp;bid2=product&amp;amp;bid3=004&amp;amp;bid4=001&amp;amp;query=Angular+Development+with+TypeScript++&quot; style=&quot;color: rgb(3, 102, 214); box-sizing: border-box; background-color: transparent;&quot;&gt;인터파크 도서&lt;/a&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;&lt;a href=&quot;http://www.bandinlunis.com/front/product/detailProduct.do?prodId=4076746&quot; style=&quot;color: rgb(3, 102, 214); box-sizing: border-box; background-color: transparent;&quot;&gt;반디앤루니스&lt;/a&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;&lt;a href=&quot;http://www.ypbooks.co.kr/book.yp?bookcd=100783703&quot; style=&quot;color: rgb(3, 102, 214); box-sizing: border-box; background-color: transparent;&quot;&gt;영풍문고&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&lt;b&gt;&lt;br /&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&lt;b&gt;- 기준 버전&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul style=&quot;padding-left: 2em; box-sizing: border-box; margin-top: 0px; margin-bottom: 16px; color: rgb(36, 41, 46); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Segoe UI&amp;quot;, Helvetica, Arial, sans-serif, &amp;quot;Apple Color Emoji&amp;quot;, &amp;quot;Segoe UI Emoji&amp;quot;, &amp;quot;Segoe UI Symbol&amp;quot;; font-size: 16px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;@angular : 4.1.0&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;@angular/cli : 1.0.3&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;TypeScript : 2.3.3&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;yarn : 0.24.5&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&lt;b&gt;&lt;br /&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&lt;b&gt;- 목차&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p id=&quot;more37_0&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '37_0','목차 열기','목차 접기'); return false;&quot;&gt;
        목차 열기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content37_0&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; color: rgb(36, 41, 46); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Segoe UI&amp;quot;, Helvetica, Arial, sans-serif, &amp;quot;Apple Color Emoji&amp;quot;, &amp;quot;Segoe UI Emoji&amp;quot;, &amp;quot;Segoe UI Symbol&amp;quot;; font-size: 16px; margin-bottom: 0px !important;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;&lt;p style=&quot;box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;&quot;&gt;Chapter 01 Angular 소개&lt;/p&gt;&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;1.1 JavaScript 프레임워크와 라이브러리&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;1.1.1 종합 프레임워크&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;1.1.2 경량 프레임워크&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;1.1.3 라이브러리&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;1.1.4 Node.js는 무엇인가?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;1.2 AngularJS 살펴보기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;1.3 Angular 살펴보기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;1.3.1 단순해진 코드&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;1.3.2 성능 향상&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;1.4 Angular 개발자가 사용하는 툴&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;1.5 Angular 기능 구현 방식&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;1.6 온라인 경매 애플리케이션 예제&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;1.7 정리&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;&lt;p style=&quot;box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;&quot;&gt;Chapter 02 Angular 시작하기&lt;/p&gt;&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;2.1 첫 번째 Angular 애플리케이션&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;2.1.1 TypeScript로 작성하는 Hellow World&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;2.1.2 ES5로 작성하는 Hello World&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;2.1.3 ES6로 작성하는 Hello World&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;2.1.4 애플리케이션 실행하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;2.2 Angular 애플리케이션의 구성 요소&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;2.2.1 모듈(Module)&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;2.2.2 컴포넌트(Component)&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;2.2.3 디렉티브(Directive)&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;2.2.4 데이터 바인딩 기초&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;2.3 SystemJS 모듈 로더&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;2.3.1 모듈 로더&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;2.3.2 모듈 로더 vs. &amp;lt;script&amp;gt; 태그&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;2.3.3 SystemJS 시작하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;2.4 패키지 매니저 선택하기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;2.4.1 npm과 jspm 비교&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;2.4.2 npm vs. yarn&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;2.4.3 yarn으로 Angular 프로젝트 시작하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;2.5 실습 : 온라인 경매 애플리케이션&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;2.5.1 프로젝트 설정&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;2.5.2 첫 페이지 구성하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;2.5.3 온라인 경매 애플리케이션 실행하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;2.6 정리&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;&lt;p style=&quot;box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;&quot;&gt;Chapter 03 라우터로 내비게이션 구현하기&lt;/p&gt;&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;3.1 라우터&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;3.1.1 위치 정책(Location strategy)&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;3.1.2 라우터 구성 요소&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;3.1.3 navigate( ) 함수 사용하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;3.2 라우터로 데이터 전달하기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;3.2.1 ActivatedRoute에서 라우팅 인자 추출하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;3.2.2 라우터로 정적 데이터 전달하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;3.3 자식 라우팅&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;3.4 라우팅 가드(Route Guards)&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;3.5 라우팅 영역 여러 개 만들기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;3.6 모듈 단위로 앱 나누기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;3.7 모듈 지연 로딩&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;3.8 실습 : 내비게이션 추가하기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;3.8.1 ProductDetailComponent 만들기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;3.8.2 HomeComponent 만들기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;3.8.3 ApplicationComponent 정리하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;3.8.4 ProductComponent에 RouterLink 추가하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;3.8.5 루트 모듈에 라우팅 추가하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;3.8.6 애플리케이션 실행하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;3.9 정리&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;&lt;p style=&quot;box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;&quot;&gt;Chapter 04 의존성 주입&lt;/p&gt;&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;4.1 의존성 주입과 제어권 역전&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;4.1.1 의존성 주입 패턴&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;4.1.2 제어권 역전 패턴&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;4.1.3 의존성 주입의 장점&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;4.2 인젝터와 프로바이더&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;4.2.1 프로바이더 등록하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;4.3 의존성 주입 예제&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;4.3.1 상품 서비스 주입하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;4.3.2 HTTP 서비스 주입하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;4.4 프로바이더 변경하기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;4.4.1 프로바이더에 useFactory와 useValue 사용하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;4.4.2 불투명 토큰(OpaqueToken) 사용하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;4.5 인젝터의 계층 구조&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;4.5.1 viewProviders&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;4.6 실습 : 의존성 주입 패턴 확인하기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;4.6.1 라우터 인자를 상품의 ID로 수정하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;4.6.2 ProductDetailComponent 수정하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;4.7 정리&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;&lt;p style=&quot;box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;&quot;&gt;Chapter 05 바인딩, 옵저버블, 파이프&lt;/p&gt;&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;5.1 데이터 바인딩&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;5.1.1 이벤트 바인딩&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;5.1.2 프로퍼티 바인딩, 어트리뷰트 바인딩&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;5.1.3 템플릿 바인딩&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;5.1.4 양방향 데이터 바인딩&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;5.2 반응형 프로그래밍과 옵저버블&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;5.2.1 옵저버와 옵저버블이 무엇인가?&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;5.2.2 옵저버블 이벤트 스트림&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;5.2.3 옵저버블 취소하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;5.3 파이프&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;5.3.1 커스텀 파이프&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;5.4 실습 : 상품 필터링&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;5.4.1 프로젝트에 FormModule 추가하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;5.4.2 커스텀 파이프 정의하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;5.4.3 SearchComponent 수정하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;5.4.4 HomeComponent 수정하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;5.4.5 AppModule 수정하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;5.4.6 경매 애플리케이션 실행하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;5.5 정리&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;&lt;p style=&quot;box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;&quot;&gt;Chapter 06 컴포넌트 통신&lt;/p&gt;&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;6.1 컴포넌트끼리 통신하기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;6.1.1 입력 프로퍼티와 출력 프로퍼티&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;6.1.2 중개자 패턴&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;6.1.3 프로젝션&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;6.2 컴포넌트 생명주기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;6.2.1 ngOnChanges( ) 함수 사용하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;6.3 변화 감지기 동작 원리&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;6.4 자식 컴포넌트의 API 직접 실행하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;6.5 실습 : 별점 기능 추가하기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;6.5.1 StarsComponent 클래스 코드 수정하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;6.5.2 StarsComponent 템플릿 수정하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;6.5.3 ProductDetailComponent 템플릿 수정하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;6.5.4 ProductDetailComponent 클래스 코드 수정하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;6.5.5 AppModule 수정하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;6.6 정리&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;&lt;p style=&quot;box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;&quot;&gt;Chapter 07 폼 처리하기&lt;/p&gt;&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;7.1 HTML 폼&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;7.1.1 HTML 표준 폼&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;7.1.2 Angular 폼&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;7.2 템플릿 기반 폼&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;7.2.1 템플릿 기반 폼에 사용하는 디렉티브&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;7.2.2 HTML 폼에 적용하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;7.3 반응형 폼&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;7.3.1 폼 모델&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;7.3.2 폼 디렉티브&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;7.3.3 예제 폼 리팩토링&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;7.3.4 FormBuilder 사용하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;7.4 폼 유효성 검사&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;7.4.1 반응형 폼 유효성 검사&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;7.5 실습 : 검색 폼에 유효성 검사 추가하기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;7.5.1 SearchComponent에 카테고리 목록 추가하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;7.5.2 폼 모델 만들기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;7.5.3 템플릿 수정하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;7.5.4 onSearch( ) 함수 구현하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;7.5.5 애플리케이션 실행하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;7.6 정리&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;&lt;p style=&quot;box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;&quot;&gt;Chapter08 서버와 데이터 주고받기&lt;/p&gt;&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;8.1 Http 객체&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;8.2 Node.js와 TypeScript로 웹 서버 만들기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;8.2.1 간단한 웹 서버 만들기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;8.2.2 JSON 데이터 제공하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;8.2.3 TypeScript로 실시간 변환하고 로드하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;8.2.4 상품 정보를 제공하는 RESTful API 추가하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;8.3 Angular와 Node.js 연동하기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;8.3.1 정적 리소스(Static resources) 제공하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;8.3.2 클라이언트 환경 설정&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;8.3.3 HTTP GET 요청하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;8.3.4 AsyncPipe&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;8.3.5 서비스에 HTTP 주입하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;8.4 웹소켓 사용하기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;8.4.1 Node.js 서버에서 데이터 푸시하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;8.4.2 웹소켓을 옵저버블로 만들기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;8.5 실습 : 상품 검색과 입찰 알림 구현하기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;8.5.1 HTTP 서버 구현하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;8.5.2 상품 검색 기능 구현하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;8.5.3 웹소켓으로 입찰 알림 보내기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;8.6 정리&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;&lt;p style=&quot;box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;&quot;&gt;Chapter09 유닛 테스트&lt;/p&gt;&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;9.1 Jasmine 프레임워크&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;9.1.1 무엇을 테스트할 것인가&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;9.1.2 Jasmine 설치하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;9.2 Angular 테스트 라이브러리&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;9.2.1 서비스 테스트&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;9.2.2 라우터 테스트&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;9.2.3 컴포넌트 테스트&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;9.3 날씨 애플리케이션 테스트&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;9.3.1 프로젝트 설정&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;9.3.2 라우터 테스트&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;9.3.3 서비스 테스트&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;9.3.4 컴포넌트 테스트&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;9.4 Karma 테스트 러너 실행하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;9.5 실습 : 유닛 테스트 적용하기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;9.5.1 ApplicationComponent 테스트 코드&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;9.5.2 ProductService 테스트 코드&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;9.5.3 StarsComponent 테스트 코드&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;9.5.4 테스트 실행&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;9.6 정리&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;&lt;p style=&quot;box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;&quot;&gt;Chapter10 번들링, 배포&lt;/p&gt;&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;10.1 Webpack 살펴보기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;10.1.1 Webpack 시작하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.1.2 Webpack 로더&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.1.3 Webpack 플러그인&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.2 Webpack 기본 설정&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;10.2.1 yarn build&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.2.2 yarn start&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.3 개발용 설정과 운영용 설정 분리하기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;10.3.1 package.json 설정&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.3.2 환경변수 설정&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.3.3 Webpack 설정&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.3.4 Angular 애플리케이션에 Node.js 환경 변수 전달하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.3.5 실행하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.4 Angular CLI&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;10.4.1 Angular CLI로 프로젝트 생성하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.4.2 Angular CLI 커맨드&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.5 실습 1 : Webpack 적용하기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;10.5.1 서버 수정하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.5.2 클라이언트 수정하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.5.3 Karma 테스트 설정하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.5.4 운영용으로 빌드하고 배포하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.6 실습 2 : Angular CLI로 리팩토링하기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;10.6.1 프로젝트 생성하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.6.2 컴포넌트 생성하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.6.3 라우터 연결하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.6.4 서비스 생성하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.6.5 서드 파티 라이브러리 사용하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.6.6 테스트 스펙 수정하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.6.7 빌드, 배포하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;10.7 정리&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;&lt;p style=&quot;box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;&quot;&gt;appendix A ECMAScript 6&lt;/p&gt;&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;A.1 예제 코드 실행하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;A.2 템플릿 리터럴&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;A.3 옵션 인자와 인자 기본값&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;A.4 변수 스코프&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;A.5 화살표 함수 표현식과 this&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;A.6 forEach( ), for-in, for-of&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;A.7 클래스와 상속&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;A.8 프로미스로 비동기 작업 처리하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;A.9 모듈&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;&lt;p style=&quot;box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;&quot;&gt;appendix B TypeScript&lt;/p&gt;&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;B.1 Angular 애플리케이션은 왜 TypeScript로 작성할까?&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;B.2 트랜스파일러의 역할&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;B.3 TypeScript 시작하기&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;B.3.1 TypeScript 설치하고 실행하기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;B.4 JavaScript의 상위 집합&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;B.5 타입 지정&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;B.5.1 함수&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;B.5.2 인자 기본값&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;B.5.3 옵션 인자&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;B.5.4 화살표 함수 표현식&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;B.6 클래스&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;B.6.1 접근 제한자&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;B.6.2 메소드&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;B.6.3 상속&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;B.7 제네릭(Generics)&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;B.8 인터페이스(Interfaces)&lt;ul style=&quot;box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 0px;&quot;&gt;&lt;li style=&quot;box-sizing: border-box;&quot;&gt;B.8.1 커스텀 타입으로 사용하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;B.8.2 추상 클래스로 사용하기&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;B.8.3 실행할 수 있는 인터페이스&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;B.9 클래스 메타데이터 추가하기, 어노테이션&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;B.10 타입 정의 파일&lt;/li&gt;&lt;li style=&quot;box-sizing: border-box; margin-top: 0.25em;&quot;&gt;B.11 TypeScript &amp;amp; Angular 개발 단계 훑어보기&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<author>한장현</author>
<guid>https://han41858.tistory.com/37</guid>
<comments>https://han41858.tistory.com/37#entry37comment</comments>
<pubDate>Fri, 16 Jun 2017 17:16:33 +0900</pubDate>
</item>
</channel>
</rss>