<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FELog</title>
  
  <subtitle>FrontEnd Engineer, Jbee&#39;s blog</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://jaeyeophan.github.io/"/>
  <updated>2019-01-04T09:49:58.055Z</updated>
  <id>https://jaeyeophan.github.io/</id>
  
  <author>
    <name>Jbee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Vuetorials] 7. Vuex Best Practice로 가는 여정</title>
    <link href="https://jaeyeophan.github.io/2018/11/17/Vuetorials-7-Vuex-Best-Practice/"/>
    <id>https://jaeyeophan.github.io/2018/11/17/Vuetorials-7-Vuex-Best-Practice/</id>
    <published>2018-11-17T08:09:44.000Z</published>
    <updated>2019-01-04T09:49:58.055Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vuetorials.png" alt=""></p><h1 id="Vuex-Best-Practice로-가는-여정"><a href="#Vuex-Best-Practice로-가는-여정" class="headerlink" title="Vuex Best Practice로 가는 여정"></a>Vuex Best Practice로 가는 여정</h1><p>Vuex에 대한 설명은 다음 두 글을 첨부함.</p><ul><li><a href="https://jaeyeophan.github.io/2018/11/07/Vuetorials-5-Vuex/">5. Vuex API</a></li><li><a href="https://jaeyeophan.github.io/2018/11/16/Vuetorials-6-Vuex-Module-pattern/">6. Vuex Module pattern</a></li></ul><p>진행하고 있는 프로젝트에서 Vuex를 어떻게 하면 잘 사용할 수 있을까 고민을 했고 그 과정을 기록함. 총 다섯 단계로 나누어져 있음.</p><p>관전 포인트는 다음과 같음.</p><ul><li>String을 덜 사용할 수는 없는가?<ul><li>오류 발생가능성을 낮추기 위해</li></ul></li><li>생산성이 좋은가?</li><li>가독성이 좋은가?</li><li>유지보수에는 적절한가?</li></ul><p>예제 코드는 실제 product 코드 대신 Todo application 예제를 사용함. <a href="https://github.com/JaeYeopHan/vuex-best-practice-lab/pull/1/files" target="_blank" rel="noopener">refactoring pull request</a></p><blockquote><p>Let’s Refactoring 🚧</p></blockquote><h2 id="Step-1-module-pattern-with-namespace"><a href="#Step-1-module-pattern-with-namespace" class="headerlink" title="Step 1. module pattern with namespace"></a>Step 1. module pattern with namespace</h2><p>Vuex에서 관리하게 되는 상태가 커지면 커질수록 <code>state</code>, <code>action</code>, <code>mutation</code> 관리가 제대로 이뤄지지 않음. 그렇기 때문에 Vuex 공식 문서에서도 <strong>module</strong>이란 것을 소개하고 있음. 또한 Vuex에서는 <code>namespaced</code>라는 아주 훌륭한 API를 지원하고 있기 때문에 여기까지는 대부분의 Vue application에서는 적용하고 있을 것 같음.</p><figure class="highlight js"><figcaption><span>@/store/modules/todos/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    todos,</span><br><span class="line">    <span class="comment">// other modules...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>@/store/modules/todos/</code> directory 밑에 각각 <code>state.js</code>, <code>getters.js</code>, <code>mutations.js</code>, <code>actions.js</code>를 만들어두고 <code>todos/index.js</code>에서 <code>namespaced: true</code>로 export 해줌.</p><p>컴포넌트에서 Vuex는 다음과 같이 사용할 수 있음.</p><figure class="highlight js"><figcaption><span>todo.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// state</span></span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    allItems: <span class="keyword">this</span>.$store.state.todos.items,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// getters</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  doneItems() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters[<span class="string">"todos/doneItems"</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">  activeItems() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters[<span class="string">"todos/activeItems"</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// actions</span></span><br><span class="line">method: &#123;</span><br><span class="line">  addItem() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(<span class="string">"todos/addItem"</span>, &#123; newItem &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실제 product 코드에서는 state, getter 등이 크지 않으면 <code>index.js</code> 에서 전부 처리하고 분리가 필요한 부분만 분리하여 작성하고 있음.</p><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem!"></a>Problem!</h3><ul><li>안 그래도 <code>.</code> 이 깊어지는 코드인데 <code>todos</code> 라는 <strong>namespace가 추가</strong>되면서 한 depth 또 추가됨.</li><li>Vuex에 정의된 모든 state, getters, actions에 접근이 가능함.</li><li>만약 <code>todos</code> 라는 namespace가 변경된다면…?</li><li><code>doneItems</code>, <code>addItem</code> 등등의 이름이 변경된다면…?</li></ul><p><strong>끔찍함.</strong> 위와 같은 이유로 1번은 고려하지 않음. (사실 난 중복된 string을 가만히 볼 수 없는 병에 걸려있음.)</p><h2 id="Step-2-Binding-helpers"><a href="#Step-2-Binding-helpers" class="headerlink" title="Step 2. Binding helpers"></a>Step 2. Binding helpers</h2><p>이 부분도 Vuex 공식 문서에서 나옴. 보통 <code>react-redux</code>, <code>mobx-react</code> 이런 라이브러리에서 제공하는 기능인데 Vuex에서는 자체적으로 제공함. 근데 이 helper API가 일관성이 없는게 문제임. 그리고 namespace가 들어가게 되면 작업이 추가됨.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions, mapState, mapGetters &#125; <span class="keyword">from</span> <span class="string">"vuex"</span>;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(<span class="string">"todos"</span>, &#123;</span><br><span class="line">    allItems: <span class="function">(<span class="params">&#123; items &#125;</span>) =&gt;</span> items,</span><br><span class="line">  &#125;),</span><br><span class="line">  ...mapGetters(<span class="string">"todos"</span>, &#123;</span><br><span class="line">  doneItems: <span class="string">"doneItems"</span>,</span><br><span class="line">  activeItems: <span class="string">"activeItems"</span></span><br><span class="line">&#125;),</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions(<span class="string">"todos"</span>, [</span><br><span class="line">    <span class="string">"addItem"</span>,</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>바인딩을 해줄 때, 첫번째 인자로 namespace를 추가해줘야 함. (namespace가 별도로 존재하지 않을 경우 바로 binding 객체를 넣어줌.)</p><h3 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem!"></a>Problem!</h3><ul><li>Step 1의 2번 3번 문제점과 동일</li></ul><p>이 binding helper는 depth를 줄이는 데에는 성공적이지만 아직 string 중복 처리는 이뤄지지 않음.</p><h2 id="Step-3-binding-시-사용되는-namespace를-제거하자"><a href="#Step-3-binding-시-사용되는-namespace를-제거하자" class="headerlink" title="Step 3. binding 시 사용되는 namespace를 제거하자."></a>Step 3. binding 시 사용되는 namespace를 제거하자.</h2><p>Vuex에서 제공하는 <a href="https://github.com/vuejs/vuex/blob/dev/src/helpers.js#L117" target="_blank" rel="noopener">createNamespacedHelpers</a>란 API를 사용할 수 있음,</p><figure class="highlight js"><figcaption><span>@/store/modules/todos/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span><span class="string">"vuex"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NAMESPACE &#125; <span class="keyword">from</span> <span class="string">"./types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; mapState, mapGetters, mapActions &#125; = createNamespacedHelpers(NAMESPACE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; mapState, mapGetters, mapActions &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; <span class="comment">/* namespaced, state, getters, mutations, actions */</span> &#125;</span><br></pre></td></tr></table></figure><p>컴포넌트에서 바로 정의해서 사용해도 되지만 store 단에서 정의하고 export 함. 컴포넌트 단에서 <code>NAMESPACE</code>를 import할 필요는 없다는 판단하에 진행함. 이렇게 정의해두고 이 namespace를 추가한 helper binding 함수를 사용하자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import &#123; mapActions, mapState, mapGetters &#125; from "vuex";</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapActions, mapState, mapGetters &#125; <span class="keyword">from</span> <span class="string">"@/store/modules/todos"</span>;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    allItems: <span class="function">(<span class="params">&#123; items &#125;</span>) =&gt;</span> items,</span><br><span class="line">  &#125;),</span><br><span class="line">  ...mapGetters(&#123;</span><br><span class="line">  doneItems: <span class="string">"doneItems"</span>,</span><br><span class="line">  activeItems: <span class="string">"activeItems"</span></span><br><span class="line">&#125;),</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions([</span><br><span class="line">    <span class="string">"addItem"</span>,</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>namespace 중복을 제거했음. 아직 Step 1의 3번 문제점이었던 constant들이 남아있음.</p><h2 id="Step-4-Extract-constant-in-action"><a href="#Step-4-Extract-constant-in-action" class="headerlink" title="Step 4. Extract constant in action"></a>Step 4. Extract constant in action</h2><p>Vuex 코드를 작성하다보면 <code>action</code>과 <code>mutation</code> 에서 많은 중복이 발생함. <code>mutation</code>에서 정의한 것을 그대로 <code>action</code> 에서 <code>commit</code> 해줘야 하기 때문임. (그렇다고 컴포넌트에서 commit 하면 안 됨… <a href="https://jaeyeophan.github.io/2018/11/07/Vuetorials-5-Vuex/#mutations">참고</a>) 그래서 이 부분을 상수로 추출고 이를 공통으로 사용할 수 있음.</p><p>일단 <code>action</code>과 <code>mutation</code>에서 사용되는 type을 별도 파일로 분리하자.</p><figure class="highlight js"><figcaption><span>@/store/module/todos/types.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// namespace</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NAMESPACE = <span class="string">"todos"</span>;</span><br><span class="line"><span class="comment">// actions</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_ITEM = <span class="string">"ADD_ITEM"</span>;</span><br></pre></td></tr></table></figure><p>이에 따라 정의한 <code>mutation.js</code>와 <code>actions.js</code>도 변경됨.</p><figure class="highlight js"><figcaption><span>@/store/mdules/todos/mutations.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">"./types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  [actions.ADD_ITEM](state, newItem) &#123;</span><br><span class="line">    state.items.push(newItem);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>@/store/mdules/todos/actions.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">"./types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  [actions.ADD_ITEM](&#123; commit &#125;, payload) &#123;</span><br><span class="line">    commit(actions.ADD_ITEM, payload.newItem);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 이 constant를 컴포넌트에서도 사용하자.</p><figure class="highlight js"><figcaption><span>todo.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions, mapState, mapGetters &#125; <span class="keyword">from</span> <span class="string">"@/store/modules/todos"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">"@/store/modules/todos/action-types"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      actions.ADD_ITEM,</span><br><span class="line">    ]),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Step-5-Extract-constant-in-getters"><a href="#Step-5-Extract-constant-in-getters" class="headerlink" title="Step 5. Extract constant in getters"></a>Step 5. Extract constant in getters</h2><p>나와 같은 병에 걸렸다면 <code>getters</code>에서의 중복도 불편할 것이라 생각됨. 이제 getters의 상수를 제거하자.</p><figure class="highlight js"><figcaption><span>@/store/mdules/todos/getters.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DONE_ITEMS = <span class="string">"DONE_ITEMS"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ACTIVE_ITEMS = <span class="string">"ACTIVE_ITEMS"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  [DONE_ITEMS]: <span class="function"><span class="params">state</span> =&gt;</span> state.items.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.isDone),</span><br><span class="line">  [ACTIVE_ITEMS]: <span class="function"><span class="params">state</span> =&gt;</span> state.items.filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.isDone)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>컴포넌트에서 getters를 바인딩하자.</p><figure class="highlight js"><figcaption><span>todo.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> getters <span class="keyword">from</span> <span class="string">"@/store/modules/todos/getters"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      allItems: <span class="function">(<span class="params">&#123; items &#125;</span>) =&gt;</span> items,</span><br><span class="line">    &#125;),</span><br><span class="line">    ...mapGetters(&#123;</span><br><span class="line">      doneItems: getter.DONE_ITEMS,</span><br><span class="line">      activeItems: getter.ACTIVE_ITEMS,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사실 이 getters는 이렇게도 표현 가능함. (as <code>mapActions</code>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...mapGetters([</span><br><span class="line">  getter.DONE_ITEMS,</span><br><span class="line">  getter.ACTIVE_ITEMS,</span><br><span class="line">]),</span><br></pre></td></tr></table></figure><p><code>getters</code>는 컴포넌트에서 <strong>값</strong>으로 사용되기 때문에 <code>doneItems</code>와 <code>activeItems</code>로 다시 mapping 시킴. 이게 더 깔끔해 보임. (물론 개취의 문제일 수도)<br><code>getters</code>와 <code>actions</code>를 전부 상수로 binding 했음. 이제 컴포넌트에서는 <code>this.doneItems</code> 이렇게 getter에 접근할 수 있고 <code>this[actions.ADD_ITEM]()</code> 이렇게 action에 접근할 수 있음.</p><blockquote><p>Vuex 코드를 작성하면서 발생한 문제점들을 어느정도 해결했음. :tada:</p></blockquote><h3 id="JFYI"><a href="#JFYI" class="headerlink" title="JFYI"></a>JFYI</h3><p>사실 원래 <code>getters</code>의 key값도 <code>types.js</code>에서 관리를 하려고 했으나</p><ol><li>컴포넌트 단에서 상수를 사용할 때, getters의 key값인지 action type인지 구분되지 않음.</li><li><code>getters</code>의 key 값은 <code>getters</code>에서만 사용하므로 굳이 <code>types.js</code>에 위치할 필요가 없음.</li></ol><p><code>getters.js</code> 내부에서 상수로 분리 후 export 함. 그리고 <code>getters</code>로 <code>* as</code> 하면 action type과 구분지을 수 있음.</p><h2 id="Remained-Task"><a href="#Remained-Task" class="headerlink" title="Remained Task"></a>Remained Task</h2><h3 id="1-여러-modules-바인딩"><a href="#1-여러-modules-바인딩" class="headerlink" title="1. 여러 modules 바인딩"></a>1. 여러 modules 바인딩</h3><p>한 컴포넌트에서 두 개 이상의 modules에 있는 action, getters 등을 바인딩해야 할 경우가 발생할 수 있음. 이렇게 되면 <code>mapActions</code>로 import할 수 없음. (name 충돌)</p><figure class="highlight js"><figcaption><span>my-component.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions <span class="keyword">as</span> mapActionsOfTodo &#125; <span class="keyword">from</span> <span class="string">'@/store/todo'</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapActiosn <span class="keyword">as</span> mapActiosnOfFilters &#125; <span class="keyword">from</span> <span class="string">'@store/filter'</span></span><br></pre></td></tr></table></figure><p>이럴 경우, 이렇게 <code>as</code>를 통해 <code>Of-*</code> suffix로 사용할 수 있음. 또는,</p><figure class="highlight js"><figcaption><span>my-component.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> todo <span class="keyword">from</span> <span class="string">'@store/todo'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    todo.mapState(&#123; ... &#125;),</span><br><span class="line">    todo.mapGetters(&#123; ... &#125;),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 <code>todo</code>로 묶어서 import 한 후 사용할 수 있음. 개인적으로는 두번째 방법을 사용하고 있음.</p><h3 id="2-통일되지-않은-API-형태"><a href="#2-통일되지-않은-API-형태" class="headerlink" title="2. 통일되지 않은 API 형태"></a>2. 통일되지 않은 API 형태</h3><p><code>mapState({ ... })</code>, <code>mapGetters({ ... })</code>는 <code>{}</code>로 받고 <code>mapActions([ ... ])</code>는 <code>[]</code>로 받는다. 같은 binding helper인데 일관성이 없음. 이 부분을 해결하기 위해 mapAction을 <code>{}</code>하면 다음과 같음.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  ...mapAction(&#123;</span><br><span class="line">    addNewItem: actions.ADD_ITEM,</span><br><span class="line">  &#125;),</span><br><span class="line">  addItem() &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">this</span>.addNewITem(newItem);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이게 더 좋은 것인지는 아직 잘 모르겠으나. <code>this[ADD_ITEM]</code> 형식을 사용하고 있음.</p><h3 id="3-Nested-Modules-namespace"><a href="#3-Nested-Modules-namespace" class="headerlink" title="3. Nested Modules namespace"></a>3. Nested Modules namespace</h3><p>child module에서 parent module의 namespace 상수를 import하여 <code>createNamespaceHelpers</code>에 넘겨줄 namespace를 지정해주려고 했는데, 에러가 발생함. 아직 원인을 모르겠음. 보다 자세한 내용은 <a href="https://github.com/JaeYeopHan/tip-archive/issues/35" target="_blank" rel="noopener">Vuex nested modules createNamespaceHelpers Issue</a>를 참고.</p><h2 id="Final-Step-Seperate-action-type-and-mutation-type"><a href="#Final-Step-Seperate-action-type-and-mutation-type" class="headerlink" title="Final Step. Seperate action type and mutation type"></a>Final Step. Seperate action type and mutation type</h2><p>Vuex를 계속 사용하다보니 컴포넌트에 노출되어야 하는 타입은 action type 뿐임. 또한 action에서 정의되는 type의 의미와 mutation에서 사용하는 type의 의미가 명확히 다름. 그래서 이 둘을 분리하기로 함. 분리를 하다보니 <code>types.js</code>라는 파일을 별도로 둘 필요가 없음. 컴포넌트에 노출되는 것은 action type만 노출되며 mutation type은 action에서 가져와 사용하는 방식을 취함.</p><figure class="highlight js"><figcaption><span>modules/actions.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> mutations <span class="keyword">from</span> <span class="string">'./mutations'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_TODO = <span class="string">'ADD_TODO'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  [ADD_TODO] (&#123; commit &#125;, payload) &#123;</span><br><span class="line">    commit(mutations.SET_NEW_ITEM, payload)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>modules/mutations.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_NEW_ITEM = <span class="string">'SET_NEW_ITEM'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  [SET_NEW_ITEM] (state, payload) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">item</span>: newItem &#125; = payload</span><br><span class="line">    state.items.push(newItem);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 두니 <code>actions.js</code>에서 action type이 정의되고 <code>mutations.js</code>에서 mutation type이 정의되고 getter type은 <code>getters.js</code>에서 정의되니 그 의미가 더욱 명확해졌음. 기존에 괜히 <code>types.js</code>에서 정의되고 있던 <code>NAMESPACE</code>는 <code>module/index.js</code>에서 관리하게 됨.</p><figure class="highlight js"><figcaption><span>module/indes.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">'./actions'</span></span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">'./mutations'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NAMESPACE = <span class="string">'todo'</span></span><br><span class="line"><span class="keyword">const</span> &#123; mapState, mapGetters, mapActions &#125; = createNamespacedHelpers(NAMESPACE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; mapState, mapGetters, mapActions &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespaced: <span class="literal">true</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  actions,</span><br><span class="line">  mutations,</span><br><span class="line">  getters,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScript의 <code>export</code>와 <code>export default</code>를 활용하여 보다 깔끔한 코드를 작성할 수 있음. Vuex의 모듈을 세 파일로 정의하게 됨. 이 상태들을 컴포넌트에서는 다음과 같이 사용할 수 있음.</p><figure class="highlight js"><figcaption><span>my-component.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> todoStore <span class="keyword">from</span> <span class="string">'@/store/todo'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> todoActions <span class="keyword">from</span> <span class="string">'@/store/todo'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> todoGetters <span class="keyword">from</span> <span class="string">'@/store/todo/getters'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...todoStore.mapGetters(&#123;</span><br><span class="line">      getItems: todoGetters.GET_ITEMS,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...todoStore.mapActions([</span><br><span class="line">      todoActions.ADD_ITEM,</span><br><span class="line">    ]),</span><br><span class="line">    onClick() &#123;</span><br><span class="line">      <span class="keyword">this</span>[todoActions.ADD_ITEM]</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컴포넌트 단에서 <code>NAMESPACE</code>를 전혀 모른 상태에서 올바른 상태값을 가져다 사용할 수 있고 <code>string</code>을 남발하지 않고 중복을 줄여가며 올바른 상태값을 매핑(mapping)할 수 있게 되었다.</p><h2 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h2><p>애플리케이션의 상태는 크게 두 가지로 나눌 수 있음. 도메인 영역과 UI의 상태. 이 두 가지가 하나의 모듈 안에서 구분없이 관리가 된다면 나중에 헬파티가 열림. 그래서 현재 프로젝트에서는 UI상태를 <code>view</code>로 감싸서 관리하고 있음.</p><p><em>example</em></p><figure class="highlight js"><figcaption><span>@/store/todo/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [ ... ],</span><br><span class="line">    views: &#123;</span><br><span class="line">      isPopupOpen: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 식으로 UI와 관련된 상태는 따로 <code>views</code>로 묶어 구분지어 주고 있음.</p><h2 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h2><h3 id="In-Vuex"><a href="#In-Vuex" class="headerlink" title="In Vuex"></a>In Vuex</h3><ul><li>상태 트리를 설계할 때, 기본적으로 <code>namespaced: true</code>로 진행.</li><li>디렉토리 이름과 namespace를 통일.</li><li>UI 상태와 도메인 상태 구분지어서 관리.</li><li>바인딩 헬퍼는 <code>createNamespacedHelpers</code>로 custom하여 사용.<ul><li>생성된 binding helper들을 <code>export { ... }</code>로 컴포넌트에 노출.</li><li>이를 노출하는 <code>index.js</code>에서 <code>NAMESPACE</code>를 정의.</li></ul></li><li>action, mutation, getter 의 각 타입들은 각 파일에서 정의.<ul><li>action에서 필요한 mutation type들은 <code>import * as mutations from &#39;./mutations</code>로 가져와 사용.</li></ul></li></ul><h3 id="In-Component"><a href="#In-Component" class="headerlink" title="In Component"></a>In Component</h3><p>최대 다음 세 가지를 import 하여 Vuex와 mapping 할 수 있음.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> [MODULE_NAME]Store <span class="keyword">from</span> <span class="string">'@/store/[MODULE_NAME]'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> [MODULE_NAME]Actions <span class="keyword">from</span> <span class="string">'@/store/[MODULE_NAME]'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> [MODULE_NAME]Getters <span class="keyword">from</span> <span class="string">'@/store/[MODULE_NAME]/getters'</span></span><br></pre></td></tr></table></figure><ul><li>state) arrow function + destructuring으로 분해해서 binding.<ul><li><code>...[MODULE_NAME]Store.mapState({ ... })</code></li><li><code>({ items }) =&gt; items</code></li><li>use: <code>this.items</code></li></ul></li><li>getter) <code>{ ... }</code>에 binding.<ul><li><code>...[MODULE_NAME]Store.mapGetters({ ... })</code><ul><li><code>{ key: todoGetters.[GETTER_TYPE] }</code></li><li>use: <code>this.[key]</code></li></ul></li></ul></li><li>action), <code>[...]</code>에 binding.<ul><li><code>...[MODULE_NAME]Store.mapActions([ ... ])</code></li><li><code>[ todoActions.ACTION_TYPE ]</code></li><li>use: <code>this[todoActions.ACTION_TYPE]</code></li></ul></li></ul><p>더 좋은 방법이 있다면 피드백 부탁드립니다 :)<br>관련 코드는 <a href="https://github.com/JaeYeopHan/vuex-best-practice-lab" target="_blank" rel="noopener">Vuex best practice GitHub Repository</a>에서 확인 가능합니다.</p><p><em>감사합니다.</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vuetorials.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Vuex-Best-Practice로-가는-여정&quot;&gt;&lt;a href=&quot;#Vuex-Best-Practice로-가는-여정&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Vue" scheme="https://jaeyeophan.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jaeyeophan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>[Vuetorials] 6. Vuex Module pattern</title>
    <link href="https://jaeyeophan.github.io/2018/11/16/Vuetorials-6-Vuex-Module-pattern/"/>
    <id>https://jaeyeophan.github.io/2018/11/16/Vuetorials-6-Vuex-Module-pattern/</id>
    <published>2018-11-16T00:47:02.000Z</published>
    <updated>2018-11-17T09:11:47.447Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vuetorials.png" alt=""></p><h1 id="Vuetorials-6-Vuex-Module-pattern"><a href="#Vuetorials-6-Vuex-Module-pattern" class="headerlink" title="[Vuetorials] 6. Vuex Module pattern"></a>[Vuetorials] 6. Vuex Module pattern</h1><h2 id="구조"><a href="#구조" class="headerlink" title="구조"></a><a href="https://vuex.vuejs.org/guide/structure.html" target="_blank" rel="noopener">구조</a></h2><p>Vuex 를 구성할 때 <code>action</code>, <code>mutation</code>, <code>getter</code> 이런 식으로 나누거나 각각의 module 을 기준으로 나눠 <code>index.js</code>에서 세 가지를 모두 기술할 수 있음. <code>modules</code>를 나눠 구성하는 경우 root 에서 사용하는 <code>action</code>과 <code>mutation</code>을 분리할 수 있음. <code>action</code>과 <code>mutation</code>은 <strong>actionType 을 공유</strong>하기 때문에 <code>types.js</code>로 별도 관리하기도 함.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">└── store</span><br><span class="line">    ├── index.js          # where we &apos;assemble&apos; modules and export the store</span><br><span class="line">    ├── actions.js        # root actions</span><br><span class="line">    ├── mutations.js      # root mutations</span><br><span class="line">    └── modules</span><br><span class="line">        ├── A             # A module</span><br><span class="line">        │   ├── index.js</span><br><span class="line">        │   └── types.js</span><br><span class="line">        └── B             # B module</span><br><span class="line">            ├── index.js</span><br><span class="line">            └── types.js</span><br></pre></td></tr></table></figure><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a><a href="https://vuex.vuejs.org/guide/modules.html" target="_blank" rel="noopener">Modules</a></h2><p>각각을 <code>modules</code>로 작성할 경우 다음과 같이 작성할 수 있음.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  key: &#123;</span><br><span class="line">    state: <span class="built_in">Object</span>,</span><br><span class="line">    namespaced?: <span class="built_in">Boolean</span>,</span><br><span class="line">    mutations?: <span class="built_in">Object</span>,</span><br><span class="line">    actions?: <span class="built_in">Object</span>,</span><br><span class="line">    getters?: <span class="built_in">Object</span>,</span><br><span class="line">    modules?: Module</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다른 것은 이전 포스팅에서 다 다룬 내용이고 <code>namespaced</code>라는 것이 있음.</p><h4 id="namespaced"><a href="#namespaced" class="headerlink" title="namespaced"></a>namespaced</h4><p>기본적으로 모듈에서 작성된 action, mutation, getter 들은 global namespace 에 등록됨. 이 때 <code>namespaced: true</code>로 지정을 해주면 <strong>해당 모듈의 namespace 로 제한됨.</strong> (완전 매력있는 API임.) 이 기능과 action type을 상수로 분리하여 작성을 했다면 한 가지 추가 작업이 더 필요함. 다음의 경우를 보자.</p><figure class="highlight js"><figcaption><span>todos/type.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_ITEM = <span class="string">'ADD_ITEM'</span></span><br></pre></td></tr></table></figure><p>이 action type을 action과 mutation과 <code>mapActions</code>해주는 곳에서 같이 사용한다고 가정했을 때,</p><figure class="highlight js"><figcaption><span>todos/actions.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  [ADD_ITEM](&#123; commit &#125;, payload) &#123;</span><br><span class="line">    commit(ADD_ITEM, payload.newItem);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>todos/mutations.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  [ADD_ITEM](state, newItem) &#123;</span><br><span class="line">    state.items.push(newItem);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vuex에서 바로 제공되는 <code>mapActions</code> helper를 바로 쓸 수 없음. namespace를 넣어줘야 함. 이 namespace는 module에 등록했을 때의 key 값이 됨.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions(<span class="string">"todos"</span>, [ ADD_ITEM ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 경우 저 액션은 <code>todos/ADD_ITEM</code>이 됨. 개인적으로는 <code>createNamespacedHelpers</code>를 쓰는 게 더 좋아보임.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import &#123; mapActions &#125; from 'vuex'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; mapActions &#125; = createNamespacedHelpers(<span class="string">"todos"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([ ADD_ITEM ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 modules에서 정의한 <strong>namespace로 한 번 wrapping 후</strong> <code>mapActions</code>로 binding 해야 함. 이렇게 해주면 action type에 자동으로 <code>todos</code>라는 namespace가 추가됨.</p><h4 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h4><p>중첩 모듈 작성이 가능함. <code>module</code> 내부에 트리 형식으로 또 <code>module</code>을 등록할 수 있음. 이 경우에도 <code>namespaced</code>를 지정해주면 <code>namespace</code>가 중첩되어 접근할 수 있음. namespace 중복은 <code>/</code>으로 중첩됨. (<a href="https://github.com/vuejs/vuex/blob/dev/src/module/module-collection.js#L16" target="_blank" rel="noopener">관련 코드</a>)</p><h3 id="그-외"><a href="#그-외" class="headerlink" title="그 외"></a>그 외</h3><ul><li>Vuex 생성자에 <code>strict: true</code>로 지정하면 <code>mutations</code>이외에 상태 변이에서 에러를 발생시킬 수 있음.</li><li><code>Vuex.Store</code>에서 제공하고 있는 API 가 여럿 있음. <code>subscribe</code>, <code>registerModule</code> 등. 활용하면 좋은 기능을 추가할 수 있을 것 같다는 막연한 생각.</li></ul><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p><code>redux</code>, <code>mobx</code>, <code>mobx-state-tree</code> 등의 상태 관리 라이브러리가 많음. <code>mutation</code>이란 부분은 MobX 와 비슷하고 트리 형식으로 구성하는 것은 MST 와 비슷하고 action 을 dispatch 하는 부분에 있어서는 redux 와 비슷한 듯. 그리고 다시 한 번 느끼는 거지만 Vue 쪽은 많은 편의성을 제공하려고 하다보니 그런건지 문서 상에서만 접할 수 있는 (코드 상으로는 파악이 불가능한) 그래서 꼭 읽어봐야 하는 그런 것들이 많은 듯. Vuex의 best practice에 대해서는 다음 포스팅에 이어서.</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://stackoverflow.com/questions/40390411/vuex-2-0-dispatch-versus-commit" target="_blank" rel="noopener">https://stackoverflow.com/questions/40390411/vuex-2-0-dispatch-versus-commit</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vuetorials.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Vuetorials-6-Vuex-Module-pattern&quot;&gt;&lt;a href=&quot;#Vuetorials-6-Vuex-Module-pattern&quot; class
      
    
    </summary>
    
      <category term="Vue" scheme="https://jaeyeophan.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jaeyeophan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>[Vuetorials] 5. Vuex API</title>
    <link href="https://jaeyeophan.github.io/2018/11/07/Vuetorials-5-Vuex/"/>
    <id>https://jaeyeophan.github.io/2018/11/07/Vuetorials-5-Vuex/</id>
    <published>2018-11-07T04:35:48.000Z</published>
    <updated>2018-11-16T00:57:50.470Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vuetorials.png" alt=""></p><h1 id="Vuetorials-5-Vuex-API"><a href="#Vuetorials-5-Vuex-API" class="headerlink" title="[Vuetorials] 5. Vuex API"></a>[Vuetorials] 5. Vuex API</h1><p>Vuex 가 왜 필요한지 그 배경에 대한 이야기는 과감히 스킵하겠음. 설치하는 과정도 스킵함. <a href="https://vuex.vuejs.org/installation.html" target="_blank" rel="noopener">공식 문서</a>에 아주 잘 나와 있음.</p><h2 id="Vuex-API"><a href="#Vuex-API" class="headerlink" title="Vuex API"></a>Vuex API</h2><p>Vuex 는 크게 네 가지로 볼 수 있음. <code>state</code>, <code>getter</code>, <code>action</code>, <code>mutation</code>. 그리고 컴포넌트와 연동시키기 위한 <strong>바인딩 헬퍼(Binding helper)</strong>가 있음. 이 바인딩 헬퍼는 <a href="https://github.com/reduxjs/react-redux" target="_blank" rel="noopener">react-redux</a> 나 <a href="https://github.com/mobxjs/mobx-react" target="_blank" rel="noopener">mobx-react</a> 같은 거라고 보면 됨. Vuex 에서는 아예 자체적으로 제공하고 있음.</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a><a href="https://vuex.vuejs.org/guide/state.html" target="_blank" rel="noopener">state</a></h3><p>말 그대로 Vuex 를 적용할 애플리케이션의 상태를 말함. 객체 형식으로 기술할 수 있음.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  todos: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>컴포넌트에서는 <code>this.$store.state.todos</code>로 접근하거나 바인딩 헬퍼를 통해 컴포넌트와 연결(mapping)할 수 있음. 각각의 바인딩 헬퍼 함수인 <code>map-*</code> 에서 반환되는 값이 전부 객체이기 때문에 <code>...</code>을 통해 destructuring 할 수 있음.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// computed: mapState(&#123;</span></span><br><span class="line">  <span class="comment">//   todos: state =&gt; state.todos,</span></span><br><span class="line">  <span class="comment">// &#125;);</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// component computed properties</span></span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      <span class="comment">// todos: state =&gt; state.todos</span></span><br><span class="line">      todos: <span class="function">(<span class="params">&#123; todos &#125;</span>) =&gt;</span> todos,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>각각의 바인딩 헬퍼에는 <code>String</code>, <code>String[]</code>, <code>Object</code> 등이 전달될 수 있음. 이들은 전부 <a href="https://github.com/vuejs/vuex/blob/2a67103a1f5fc1448a694e7f83a5f0c6d6bc8262/src/helpers.js#L46" target="_blank" rel="noopener">nomalizeMap</a>을 통해서 객체로 변환되어 매핑(mapping)됨.</p><h3 id="getter"><a href="#getter" class="headerlink" title="getter"></a><a href="https://vuex.vuejs.org/guide/getters.html" target="_blank" rel="noopener">getter</a></h3><p>Vue component API 중 <code>computed</code> 같은 역할을 수행함. 그냥 <code>store</code>에서 접근한 후 컴포넌트에서 <code>computed</code> 하게 되면 재사용성이 떨어지므로 Vuex 에서부터 지원을 함.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getter = &#123;</span><br><span class="line">  doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done),</span><br><span class="line">  getTodoById: <span class="function"><span class="params">state</span> =&gt;</span> id =&gt; state.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id === id)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>컴포넌트에서는 payload 가 함께 일 경우, 메소드 형태로 호출(함수를 반환하므로)하고 없을 경우 property 로 접근할 수 있음.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// helper 없이 mapping</span></span><br><span class="line">    <span class="comment">// doneTodos() &#123;</span></span><br><span class="line">    <span class="comment">//   return this.$store.getter.doneTodos;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    ...mapGetters([<span class="string">"doneTodos"</span>])</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    ...mapGetters(&#123;</span><br><span class="line">      doneTodos: <span class="string">"doneTodos"</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a><a href="https://vuex.vuejs.org/guide/mutations.html" target="_blank" rel="noopener">mutations</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  increment(state) &#123;</span><br><span class="line">    <span class="comment">// mutate state</span></span><br><span class="line">    state.count++;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// with payload (n)</span></span><br><span class="line">  increment(state, n) &#123;</span><br><span class="line">    state.count += n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>mutation</code>은 값을 변경하는 로직들이 들어감. synchronous 하게 동작해서 순차적인 로직들만 선언함. 그래서 컴포넌트에서 호출되면 안 됨. 선언된 <code>mutation</code>들은 <code>action</code>에서 <code>commit</code>되는 형태로만 호출되어야 함. <code>mapMutation</code>이라는 바인딩 헬퍼가 있긴 한데, 컴포넌트와 mapping 할 일이 없으므로 거의 사용되지 않음. (사용하는 부분이 있다면 제보 바람.)</p><h3 id="action"><a href="#action" class="headerlink" title="action"></a><a href="https://vuex.vuejs.org/guide/actions.html" target="_blank" rel="noopener">action</a></h3><p><code>action</code>은 <code>mutation</code>과 다르게 asynchronous 로 동작함. 그래서 <code>action</code>에서 비순차적 또는 비동기 처리 로직들을 선언함.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  increment(context) &#123;</span><br><span class="line">    context.commit(<span class="string">"increment"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  incrementBy(context, payload) &#123;</span><br><span class="line">    context.commit(<span class="string">"incrementBy"</span>, payload);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>action</code>에서는 여러 <code>mutation</code>을 조합하여 <code>commit</code> 할 수 있음. Promise 나 async/await 을 통해서 비동기 작업들을 순차적으로 동작하게 할 수 있음. 이 <code>action</code>은 컴포넌트에서 <code>dispatch</code>되는 형식으로 사용됨.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    triggerMethods() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.dispatch(<span class="string">"increment"</span>);</span><br><span class="line">      <span class="comment">// or</span></span><br><span class="line">      <span class="keyword">this</span>.$store.dispatch(<span class="string">"increment"</span>, &#123;</span><br><span class="line">        amount: <span class="number">10</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>with binding helper</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([<span class="string">"increment"</span>])</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      increment: <span class="string">"increment"</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>Vuex 관련 포스팅을 하나로 마무리 지으려고 했는데 너무 길어져서 두 개로 나눔. 다음 포스팅에서는 Vuex를 module pattern으로 작성하는 부분에 대해 다룰 예정임. Vuex에 대한 총체적인 느낌도 다음 포스팅에서.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vuetorials.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Vuetorials-5-Vuex-API&quot;&gt;&lt;a href=&quot;#Vuetorials-5-Vuex-API&quot; class=&quot;headerlink&quot; title=&quot;[
      
    
    </summary>
    
      <category term="Vue" scheme="https://jaeyeophan.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jaeyeophan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>[Vuetorials] 4. 내장 컴포넌트</title>
    <link href="https://jaeyeophan.github.io/2018/11/05/Vuetorials-4-Internal-Component/"/>
    <id>https://jaeyeophan.github.io/2018/11/05/Vuetorials-4-Internal-Component/</id>
    <published>2018-11-05T11:48:30.000Z</published>
    <updated>2018-11-05T11:52:13.099Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vuetorials.png" alt=""></p><h1 id="Vuetorials-4-내장-컴포넌트"><a href="#Vuetorials-4-내장-컴포넌트" class="headerlink" title="[Vuetorials] 4. 내장 컴포넌트"></a>[Vuetorials] 4. 내장 컴포넌트</h1><p>Vue 에서 제공하고 있는 컴포넌트에 대해 알아보는 포스팅.</p><h2 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a><a href="https://vuejs.org/v2/guide/components-slots.html" target="_blank" rel="noopener">Slot</a></h2><p>일단 이 <code>Slot</code> 이라는 것은 Vue 에서 특별히 만든 그런 기능이 아님. <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md" target="_blank" rel="noopener">w3c/proposals - Slots-Proposal.md</a>가 있음. 이 Slots 을 제대로 이해하려고 했더니 <code>Shadow Tree</code>까지 봐야함. 자세한 내용은 <a href="http://w3c.github.io/webcomponents/spec/shadow/" target="_blank" rel="noopener">관련 Spec 문서</a>를 봐야 함. <a href="https://kr.vuejs.org/v2/api/#slot-1" target="_blank" rel="noopener">API</a>는 별 게 없음. <a href="https://kr.vuejs.org/v2/guide/components.html#%EB%8B%A8%EC%9D%BC-%EC%8A%AC%EB%A1%AF" target="_blank" rel="noopener">공식 문서 설명</a>도 딱히 도움이 되진 않음. 일단 문법 자체가 처음 보면 익숙하지 않아서 부모-자식 이 부분이 약간 헷갈림.</p><h4 id="언제-쓰는가"><a href="#언제-쓰는가" class="headerlink" title="언제 쓰는가"></a>언제 쓰는가</h4><p>Vue 에서 component 를 등록하고 렌더링할 때 보통 <code>props</code>로 데이터를 전달하거나 함수를 전달함. 그런데 children 에 <code>HTML</code> 또는 Vue 컴포넌트를 전달해서 렌더링하고 싶을 때가 있음. 이 때 slot 을 사용할 수 있음.</p><p>사실 React 사용자에겐 ‘응? 그냥 props 로 JSX 넘겨주면 되지 않나?’ 할 수 있음. Vue 에서는 <code>components</code>에 컴포넌트를 등록해야 <code>template</code>에서 렌더링 할 수 있음. 근데 <code>props</code>로 전달함과 동시에 <code>components</code>에 등록할 수 없음.</p><p>그냥 props 로 전달하는 것보다 slot 이 더 Composability(합성 가능성)를 극대화 할 수 있는 기능이라고 하는데, 아직 감이 잘 안 잡힘.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"todo-header"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"todo-container"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"todo-filters"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"todo-footer"</span> <span class="attr">:author</span>=<span class="string">'"Jbee"'</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>slot 을 사용하는 가장 쉽고 대표적인 예제는 layout 을 잡기 위한 <code>.vue</code> 임. 위와 같이 <code>TodoLayout.vue</code>를 지정한 후,</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">todo-layout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 정의한 컴포넌트를 slot으로 배포 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">todo-title</span></span></span><br><span class="line"><span class="tag">      <span class="attr">msg</span>=<span class="string">"TODO APP"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">slot</span>=<span class="string">"todo-header"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">todo-title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 축약형 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">todo-container</span> <span class="attr">slot</span>=<span class="string">"todo-container"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- scope를 통해 전달받은 props를 렌더링 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">"todo-footer"</span> <span class="attr">slot-scope</span>=<span class="string">"props"</span>&gt;</span></span><br><span class="line">      Copyright: @&#123;&#123; props.author &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">todo-layout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이렇게 <code>todo-layout</code> 컴포넌트에 주입할 수 있음. <code>slot=&quot;A&quot;</code> 어트리뷰트와 <code>&lt;slot name=&quot;A&quot; /&gt;</code>로 부모-자식 관계를 정의함.</p><h2 id="component"><a href="#component" class="headerlink" title="component"></a><a href="https://vuejs.org/v2/api/#component" target="_blank" rel="noopener">component</a></h2><p><strong>동적 컴포넌트</strong>를 정의할 때 편리한 내장 컴포넌트 API. <code>is</code>라는 속성과 함께 사용됨.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentFilterView"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- shorten --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;component :is="currentFilterView"&gt;&lt;/component&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    component: &#123;</span></span><br><span class="line"><span class="undefined">      A,</span></span><br><span class="line"><span class="undefined">      B,</span></span><br><span class="line"><span class="undefined">      C,</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>currentFilterView</code>는 Vue 컴포넌트에서 <code>data</code>로 지정된 속성임. 이 값에 <code>A</code> 또는 <code>B</code> 또는 <code>C</code> 값(컴포넌트이름)이 들어갈 경우, <code>component</code> 태그에 <code>A</code> 또는 <code>B</code> 또는 <code>C</code>컴포넌트가 렌더링 됨. <code>component</code> 태그 하위에 렌더링 되는게 아니라 바로 그 자리에 대체됨. 언뜻보면 단순한 <code>switch statement</code> sugar syntax 같지만, <code>keep-alive</code> 라는 내장 컴포넌트로 감싸줄 경우, cache 를 타게 됨.</p><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a><a href="https://vuejs.org/v2/api/#keep-alive" target="_blank" rel="noopener">keep-alive</a></h2><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/components/keep-alive.js#L51" target="_blank" rel="noopener">무엇이 어떻게 caching 되는가</a>를 보면 인스턴스를 destroy 하지 않고 남겨둠. 즉 <code>keep-alive</code>라는 <a href="https://github.com/vuejs/vue/blob/dev/src/core/components/keep-alive.js#L55" target="_blank" rel="noopener">추상 엘리먼트</a>로 감싸져있는 컴포넌트들이 변경될 때, 사라질 인스턴스를 메모리에서 제거하지 않음. 이로 인해 불필요한 re-render 를 막고 활성화되을 때 변경되었던 상태가 비활성화 후 다시 활성화 되었을 때 유지 됨. <a href="https://kr.vuejs.org/v2/api/#keep-alive" target="_blank" rel="noopener">공식 문서</a>에서는 <code>transition</code> 내장 컴포넌트와 함께 사용하여 애니메이션 된 상태를 유지할 때 사용하기도 한다고 되어있음.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentFilterView"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>아까 <code>component</code>를 정의한 부모에 <code>keep-alive</code> 태그로 감싸주면 됨. <code>keep-alive</code> 하위에 렌더링되는 컴포넌트들은 두 가지 hook 이 mixin 으로 추가됨. <code>activated</code>, <code>deactivated</code> 두 가지 훅(hook)은 해당 컴포넌트가 활성화 될 때, 비활성화 될 때 호출됨.</p><p><code>:include</code>, <code>:exclude</code>디렉티브를 통해서 caching 을 적용할 컴포넌트와 적용하지 않을 컴포넌트를 적용할 수 있음. String, 정규식, 배열을 전달할 수 있음. (<a href="https://github.com/vuejs/vue/blob/dev/src/core/components/keep-alive.js#L51" target="_blank" rel="noopener">관련 코드</a>)</p><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p><code>transition</code>과 <code>trasition-group</code>은 animation 관련하여 함께 다루는 것이 좋을 듯하여 이번 장에서 다루지 않음. React 는 개발자 너희들이 알아서 해라 식이었다면 Vue 는 <code>computed</code>도 그렇고 <code>keep-alive</code>도 그렇고 라이브러리 자체에서 제공하고 있는 API 를 충분히 활용할 수 있을 듯 함.</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://skyronic.com/blog/vue-slots-example" target="_blank" rel="noopener">https://skyronic.com/blog/vue-slots-example</a></li><li><a href="https://daveceddia.com/pluggable-slots-in-react-components/" target="_blank" rel="noopener">https://daveceddia.com/pluggable-slots-in-react-components/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vuetorials.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Vuetorials-4-내장-컴포넌트&quot;&gt;&lt;a href=&quot;#Vuetorials-4-내장-컴포넌트&quot; class=&quot;headerlink&quot; title=&quot;[Vu
      
    
    </summary>
    
      <category term="Vue" scheme="https://jaeyeophan.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jaeyeophan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>[Vuetorials] 3. Component API</title>
    <link href="https://jaeyeophan.github.io/2018/10/23/Vuetorials-3-Component-API/"/>
    <id>https://jaeyeophan.github.io/2018/10/23/Vuetorials-3-Component-API/</id>
    <published>2018-10-23T03:01:56.000Z</published>
    <updated>2018-11-15T12:33:34.818Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vuetorials.png" alt=""></p><h1 id="Vuetorials-3-Component-API"><a href="#Vuetorials-3-Component-API" class="headerlink" title="[Vuetorials] 3. Component API"></a>[Vuetorials] 3. Component API</h1><h2 id="Component-API"><a href="#Component-API" class="headerlink" title="Component API"></a>Component API</h2><p>컴포넌트에는 여러 가지 내용들이 기술될 수 있음. 객체에 <code>[key-value]</code> 형식으로 기술됨. 성격이 다른 옵션 API 들이 아무런 그룹없이 존재할 수 있기 때문에 객체로 기술할 경우 인위적인 그룹화가 필요해보임. (내키는대로 작성하게 되면 가독성 폭망할 듯.)</p><ol><li>DOM rendering 과 관련된 내용</li><li>컴포넌트에서 사용될 data 에 대한 내용</li><li>컴포넌트의 라이프 사이클 메소드</li><li>에셋이라고 표현한 옵션들.</li><li>기타라고 표현한 옵션들</li></ol><p>각각의 내용에 대해서는 <a href="https://kr.vuejs.org/v2/api/#data" target="_blank" rel="noopener">공식 문서</a>에 잘 나와있음. 자질구레한 <strong>제한</strong>이 있고 이런 제한에 대해서는 <strong>런타임에</strong> 에러가 발생함. 몇 가지 짚고 넘어갈 API 만 살펴봄.</p><h3 id="props"><a href="#props" class="headerlink" title="props"></a><a href="https://kr.vuejs.org/v2/api/#props" target="_blank" rel="noopener">props</a></h3><p>컴포넌트가 전달받을 props 에 대해 기술하기 위한 API 임. 단순히 배열로 표현이 가능하지만 객체로 기술할 경우, 타입 체크 및 유효성 검사 로직을 추가할 수 있음. 검사 대상은 다음 네 가지 임.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 타입 체크만</span></span><br><span class="line">    height: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 타입 체크와 유효성 검사</span></span><br><span class="line">    age: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">0</span>,</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value &gt;= <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>props</code>에 추가될 수 있는 프로퍼티를 interface 로 구성하자면 다음과 같음.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PropPropertyInterface &#123;</span><br><span class="line">  <span class="keyword">type</span>?: <span class="built_in">Function</span> | <span class="built_in">Array</span>&lt;<span class="built_in">Function</span>&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">default</span>?: <span class="built_in">any</span> = <span class="literal">undefined</span>;</span><br><span class="line">  required?: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">  validator?: <span class="built_in">Function</span> = <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그 무엇하나 필수가 아님. 필수가 아니기 때문에 <code>age: {}</code>로 해도 그냥 돌아감. props 와 관련된 로직은 <a href="https://github.com/vuejs/vue/blob/dev/src/core/util/props.js#L14" target="_blank" rel="noopener">여기</a>에서 볼 수 있음. JavaScript 환경에서는 Interface 또는 type alias 를 별도로 지원하지 않으니 반쪽짜리 타입 체크가 될 수 밖에 없음. <code>validator</code> 부분과 객체로 기술 한다는 부분에서는 React 의 <a href="https://github.com/facebook/prop-types" target="_blank" rel="noopener">prop-types</a>보다 낫다고 봄. 실제로 <code>validator</code>를 쓸 지는 잘 모르겠음. (제보 부탁드림.)</p><h3 id="data"><a href="#data" class="headerlink" title="data"></a><a href="https://kr.vuejs.org/v2/api/#data" target="_blank" rel="noopener">data</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// Recommend</span></span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; ... &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// or</span></span><br><span class="line">  data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; ... &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data 는 <code>this</code>에 value 들을 바인딩(binding)해야 하기 때문에 메소드 형태나 <code>function</code> keyword 를 사용하여 함수 형태로 기술해줘야 함. 화살표 함수(arrow function)을 쓰면 this binding 이 외부 context 를 잡게 되고 undefined 가 되어 <code>data</code>로 기술한 객체에 Vue 인스턴스에서 접근할 수 없음. 이게 런타임에서 에러나는게 참 아쉬움.</p><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a><a href="https://kr.vuejs.org/v2/api/#computed" target="_blank" rel="noopener">computed</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    totalSum: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125; <span class="comment">// only getter</span></span><br><span class="line">    addTo: &#123;</span><br><span class="line">      get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.num;</span><br><span class="line">      &#125;,</span><br><span class="line">      set: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.num + val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 API 는 <a href="https://kr.vuejs.org/v2/guide/computed.html" target="_blank" rel="noopener"><strong>cache</strong></a>가 핵심임. getter 와 setter 로 접근이 가능함. 변경 사항을 반영할 때 caching 때문에 methods 를 사용하는 것보다 빠르게 계산할 수 있음. <code>cache:false</code>를 통해서 cache 기능을 끌 수도 있음. <code>data</code> API 와 마찬가지로 각각의 프로퍼티는 arrow function 을 사용하면 안 됨. (같은 이유임) 3.0에서는 Proxy를 통해 getter, setter가 구현될 예정이라고 함.</p><h3 id="render"><a href="#render" class="headerlink" title="render"></a><a href="https://kr.vuejs.org/v2/api/#render" target="_blank" rel="noopener">render</a></h3><p>React 에서 익숙하게 봐오던 API 임. Vue 컴포넌트에서는 <code>&lt;template&gt;</code> 태그로 HTML 을 기술할 수 있었음. 하지만 이 API 를 통해 React 처럼 렌더링 될 HTML 을 기술할 수 있음. <code>render</code> function 에는 <code>createElement: () =&gt; VNode</code>가 파라미터로 전달됨. 이걸 이용해서 HTML 엘리먼트를 기술할 수 있음.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(</span><br><span class="line">      <span class="string">"ul"</span>,</span><br><span class="line">      <span class="keyword">this</span>.todos.map(<span class="function"><span class="params">item</span> =&gt;</span> createElement(<span class="string">"li"</span>, item.content))</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>각각의 태그를 저렇게 명시해줘야 하는 부분이 너무 귀찮음. <a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx" target="_blank" rel="noopener">babel-plugin-transform-vue-jsx</a>를 추가하면 <code>render</code> 함수의 return value 를 JSX 로 사용할 수 있음.</p><h4 id="Stateless-Functional-Component"><a href="#Stateless-Functional-Component" class="headerlink" title="Stateless Functional Component"></a>Stateless Functional Component</h4><p>이 API 로 상태가 없는 functional component 를 만들 수 있음. (일단 React 에 비해 뭘 잔뜩 적어줘야 함.)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  functional: <span class="literal">true</span>,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; props &#125; = context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">'ul'</span>, props.todos.map(...))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue 는 기본적으로 <code>this</code>에 필요한 데이터나 메소드 등을 binding 해주는데 함수형 컴포넌트(Functional Component)일 경우, <code>this</code>에 접근하지 못하기 때문에 <code>functional: true</code>일 경우, <code>render</code> function 에 두번째 파라미터로 <code>context</code>를 넘겨줌. 이 <code>context</code>를 <strong>FunctionalRenderContext</strong>이라 하며 <code></code>data<code>,</code>props<code>,</code>listeners` 등에 접근할 수 있음. 이 함수형 컴포넌트의 경우에는 multi-root 로 렌더링 할 수 있음.</p><h4 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h4><p>다루지 않은 많은 API 들이 존재하지만 필요할 때 공식 문서에서 확인 가능함. 해당 글이 길어졌기 때문에 다뤄야 할 다른 API 가 있으면 다른 포스팅에서 다룰 예정임.</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://kr.vuejs.org/v2/api/" target="_blank" rel="noopener">Vue Official Doucument</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vuetorials.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Vuetorials-3-Component-API&quot;&gt;&lt;a href=&quot;#Vuetorials-3-Component-API&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Vue" scheme="https://jaeyeophan.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jaeyeophan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>[Vuetorials] 2. 전반적인 concept</title>
    <link href="https://jaeyeophan.github.io/2018/10/21/Vuetorials-2-Vue-concept/"/>
    <id>https://jaeyeophan.github.io/2018/10/21/Vuetorials-2-Vue-concept/</id>
    <published>2018-10-21T07:27:24.000Z</published>
    <updated>2018-11-16T01:53:05.179Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vuetorials.png" alt=""></p><h1 id="Vuetorials-2-전반적인-concept"><a href="#Vuetorials-2-전반적인-concept" class="headerlink" title="[Vuetorials] 2. 전반적인 concept"></a>[Vuetorials] 2. 전반적인 concept</h1><h2 id="Single-File-Component"><a href="#Single-File-Component" class="headerlink" title="Single File Component"></a>Single File Component</h2><p>Vue 는 <strong>싱글 파일 컴포넌트</strong>로 작성하는 것을 권장함. 처음엔 이게 무슨 말인지 몰랐음. React 에선 SFC 는 Stateless Functional Component 인데… Vue 에선 SFC 가 Single File Component 임…</p><p>뭐 그렇다 치고. SFC 는 컴포넌트 단위로 View 를 구성할 때, HTML/CSS/JavaScript 를 어떤 방식으로 작성할 것인가에 대한 내용임.</p><p>일단 React 의 경우에는 HTML 을 JSX 라는 문법으로 표현하며 자연스럽게 JavaScript 와 하나가 됨. 불쌍한 CSS 는 혼자 별도 파일에 존재하여 import 되어 사용됨. 물론 <code>CSS-in-JS</code> 로 <code>.jsx</code> 또는 <code>.tsx</code>에 CSS 코드를 포함시키기도 함.</p><p>Angular 의 경우 세 가지는 모두 별도 파일로 기술됨.</p><p>Vue 는 하나의 <code>.vue</code>라는 파일에서 HTML/CSS/JavaScript 를 모두 기술하게 함. 이게 <strong>싱글 파일 컴포넌트</strong>임. 이 세 가지 다른 언어는 <code>&lt;template&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;style&gt;</code> 이라는 태그로 구분됨. 관심사의 분리라는 측면에서는 앵귤러와 리액트의 중간쯤 단계로 타협을 본 것 같음.</p><p><strong>‘분리’</strong>를 하게 되면 <strong>“정적인 HTML 과 JavaScript 로직을 어떻게 유기적으로 연동할 것인가?”</strong> 이 부분이 이슈가 됨. 애초에 분리를 하지 않은 React 는 JSX 문법으로 HTML 을 기술하기 때문에 JavaScript 와 아주 자연스럽게 연동됨. 앵귤러와 뷰는 그렇지 못하기 때문에 ‘<strong>디렉티브</strong>‘라는 것이 있음.</p><h2 id="Directives"><a href="#Directives" class="headerlink" title="Directives"></a>Directives</h2><p>HTML 에 JavaScrpit 를 입히기 위해 추가하는 속성(attribute) 중 하나라고 생각하면 편함. <code>v-on</code>, <code>v-for</code> 등 여러 가지 디렉티브가 있고 custom directive 도 만들어서 등록할 수 있음. JSX 의 경우, onclick 을 <code>onClick</code>으로 표현했다면 Vue 의 디렉티브로는 <code>v-on:click</code> 이렇게 이벤트를 등록함. 축약형도 제공하고 있는데 이게 처음에는 조금 헷갈릴 수 있겠다 싶었음. <code>(v-on:click</code>은 <code>@click</code>으로 <code>v-bind:</code>는 <code>:</code>으로 축약 가능.) <a href="https://vuejs.org/v2/style-guide/#Directive-shorthands-strongly-recommended" target="_blank" rel="noopener">공식 스타일 가이드</a>에서는 둘 중 하나로 통일해서 작성하라고 함. 이 공식 스타일은 꼭 한 번 읽고 개발을 진행하는게 좋음.</p><h2 id="Component-를-생성"><a href="#Component-를-생성" class="headerlink" title="Component 를 생성"></a>Component 를 생성</h2><p><code>.vue</code>에서 js 로직을 기술하기 위해 <code>&lt;script&gt;</code>를 만드는 방법은 기본적으로 3 가지 정도가 있음.</p><h3 id="1-Vue-component"><a href="#1-Vue-component" class="headerlink" title="1. Vue.component"></a>1. Vue.component</h3><p>이 방식으로 컴포넌트를 선언하게 되면 그 컴포넌트는 전역 컴포넌트(Global Component)가 됨. JavaScript 를 처음 공부할 때부터 전역 공간을 오염시키지 않기 위해 <a href="http://asfirstalways.tistory.com/233" target="_blank" rel="noopener">Name space pattern</a>과 <a href="http://asfirstalways.tistory.com/234" target="_blank" rel="noopener">Module pattern</a>을 배웠던 기억이 남. 전역 컴포넌트는 다음과 같은 이슈가 있기 때문에 개인적으론 사용을 지양하고 싶음.</p><ul><li>컴포넌트 이름이 충돌할 가능성이 많음</li><li>VSCode extension 인 Vetur 는 local component 에 대해서만 prop auto-complete 을 지원함.</li><li>일단 디버깅 및 코드 구조 파악이 어려움.</li></ul><p>전역 컴포넌트를 사용하기 좋은 예가 무엇이 있을지 연구 중임.</p><h3 id="2-export-default"><a href="#2-export-default" class="headerlink" title="2. export default { }"></a>2. <code>export default { }</code></h3><p><code>.vue</code> 파일에서 <code>&lt;script&gt;</code>에 이렇게 선언을 하면 지역 컴포넌트(Local Component)로 선언됨. 객체 형식으로 기술을 하게 됨. 사용하는 측은 별도로 import 한 후 <code>components</code>에 기술 후 사용할 수 있음.</p><h3 id="3-vue-class-component-사용"><a href="#3-vue-class-component-사용" class="headerlink" title="3. vue-class-component 사용"></a>3. vue-class-component 사용</h3><p><a href="https://github.com/vuejs/vue-class-component" target="_blank" rel="noopener">vue-class-component</a>라는 라이브러리를 사용하여 component 를 기술할 수 있음. 객체의 프로퍼티로 정의해줬던 것들을 클래스의 메소드나 클래스의 프로퍼티로 정의할 수 있음.</p><ul><li><code>methods</code> -&gt; <code>class member methods</code></li><li><code>computed</code> -&gt; <code>class property accessors</code></li><li><code>data</code> -&gt; <code>class properties</code></li><li><code>life cycle hook</code> -&gt; <code>class member methods</code></li><li><code>prop</code> =&gt; <code>parameter of @Component</code> or <code>@prop</code></li><li>…</li></ul><p>단, decorator 문법을 사용하므로 다른 babel-plugin 들이 필요함. TypeScript 기반이라면 <code>tsconfig.json</code>에서 <code>--experimentalDecorators</code> 옵션을 켜줘야 함. 객체로 컴포넌트를 정의하는게 불편했는데 이 부분은 아마 3.0 에서 native 로 지원할 예정인 듯.</p><h3 id="new-Vue"><a href="#new-Vue" class="headerlink" title="+ new Vue({ ... })"></a><code>+ new Vue({ ... })</code></h3><p>처음 <code>@vue/cli</code>로 스캐폴딩하면 <code>main.js</code>에 <code>new Vue({ render: ... })</code> 이렇게 되어있음. 이 Vue 인스턴스는 컴포넌트가 아니라 MVVM 패턴에서 VM(ViewModel)임. Vue 로 SPA 를 구성한다고 했을 때 이 인스턴스는 <code>main.js</code>에 하나만 있으면 되는 거임. 마치 <code>ReactDOM.render</code>가 하나 있는 것처럼. MVVM 에 대한 자세한 내용은 <a href="https://joshua1988.github.io/web-development/vuejs/vuejs-tutorial-for-beginner/" target="_blank" rel="noopener">캡틴 판교님의 글</a>을 확인해보면 됨. (처음에 Vue 를 접했을 때 이 부분이 Vue 인스턴스랑 컴포넌트랑 많이 헷갈렸음.)</p><h2 id="나름의-장점"><a href="#나름의-장점" class="headerlink" title="나름의 장점"></a>나름의 장점</h2><ul><li><code>&lt;template&gt;</code>을 기술할 때 pure html 로도 기술할 수 있고 <a href="https://github.com/pugjs/pug" target="_blank" rel="noopener">pug(구 jade)</a>로도 기술할 수 있음.</li><li><code>&lt;style&gt;</code> 기술 시에도 <code>lang</code>으로 pure css, scss 등 선택할 수 있음.</li><li><code>&lt;style scoped&gt;</code>, <code>&lt;style module&gt;</code>을 통해 component 범위에서만 적용되는 style 을 기술 할 수 있음. (짱짱)</li><li>JSX보다 표준에 가까움.</li><li>cli가 좋음.</li></ul><h2 id="나름의-단점"><a href="#나름의-단점" class="headerlink" title="나름의 단점"></a>나름의 단점</h2><ul><li>JSX 에선 뭐든 <code>{}</code>로 감싸서 전달하면 됐는데, 문법이 약간 헷갈림.<ul><li><code>&lt;template&gt;</code>에 <code>data</code> , <code>computed</code>, <code>prop</code> 등을 기술하는데 이중 대괄호를 씀.</li><li>클래스 조작하기 위해 일반 <code>class</code> attribute 가 아니라 <code>v-bind:class</code>로 기술해야 함.</li><li>directive 에는 string 으로 기술.</li><li>삼항 연산자를 넘기려면 string 안에 <code>[]</code>로 기술.</li><li>토글을 위한 syntax 도 제공하는데 이건 <code>{}</code>로 기술.<ul><li>lint가 이러한 부분을 잡아주지 못하기 때문에 팀 내에서 약속된 규칙을 만드는 것이 중요함.</li></ul></li></ul></li><li>컴포넌트 내부에서 관리되는 data 들이 immutable 이 아닌게 조금 찝찝함.<ul><li>MobX 처음 봤을 때의 느낌임.</li><li>Redux 사용자들에겐 불편하게 다가갈 수 있을 듯 함.</li><li>3.0 에서 immutable version 의 value 가 추가된다고 하는데 어떤 형태일지 궁금함.</li></ul></li><li><code>&lt;template&gt;</code>에는 Single Root Element 가 들어가야 함.<ul><li>Vue 의 함수형 컴포넌트로 multi-root components 를 렌더링 할 수 있긴 함. (3 장에서 다룰 예정.)</li></ul></li><li>Object-based API 임.<ul><li>3.0에 Class-based API가 나온다고 하니 기대 중.</li></ul></li></ul><h2 id="개인적인-인상"><a href="#개인적인-인상" class="headerlink" title="개인적인 인상"></a>개인적인 인상</h2><p>Vue 를 홍보할 때 흔히 “러닝커브가 낮다.”라는 말을 함. 그러나 초기 접근이 쉽다는 것은 그만큼 magic(눈에 보이지 않는 로직, 라이브러리에서 처리하는 로직)이 많다는 것임. 이를 제대로 이해하지 못한다면 애플리케이션의 크기가 커졌을 경우나 복잡한 로직 디버깅이 힘들어짐. 매직이 많다는 것이 나쁘다는 것은 아님. 함께 프로젝트를 진행하는 팀원 모두가 동일하게 이 매직에 대해 이해하고 있으면 매직은 발목을 붙잡는 것이 아니라 오히려 생산성을 증대시켜주는 녀석으로 바뀜.</p><p>그리고 배우기 쉽다는 것은 es6 선행 학습 없이, npm, webpack 등의 선행 학습 없이 jQuery 쓰듯이 script 태그에 cdn에 올려놓고 바로 시작할 수 있어서 생긴 말이 아닐까 하는 생각이 들었음.</p><p><code>&lt;template&gt;</code>으로 HTML 을 분리하느냐 JSX 문법으로 HTML 을 흡수하느냐는 Vue 와 React 를 구분짓는 큰 요소 중 하나라고 생각함. 가독성 측면에서는 익숙한게 좋은 거라고 생각함. 딱히 둘 중 뭐가 더 나은지는 아직 잘 모르겠음. 아직 개발하기에는 JSX 가 편한 듯. 만약 프론트엔드 개발 인력 중 마크업을 작성하는 인력이 나뉘어져 있다면 Vue 가 더 편할지도 모르겠으나 멀티 루트를 지원하지 않는 관계로 쓸데없는 태그들이 추가될 수 있을 듯.</p><p>Vue는 기본적으로 Object-based API이다 보니 <code>,</code>(comma)를 정말 많이 쓰게 됨. 은근히 짜증남. 빨리 vue 3.0이 나와서 vue 자체적으로 지원하는 class-based API로 쓰고 싶음. 3.0이 TypeScript로 rewrite 된다고 해서 더 기대됨!</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://frontendsociety.com/why-you-shouldnt-use-vue-component-ff019fbcac2e" target="_blank" rel="noopener">https://frontendsociety.com/why-you-shouldnt-use-vue-component-ff019fbcac2e</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vuetorials.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Vuetorials-2-전반적인-concept&quot;&gt;&lt;a href=&quot;#Vuetorials-2-전반적인-concept&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Vue" scheme="https://jaeyeophan.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jaeyeophan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>[Vuetorials] 1. @vue-cli 3.0</title>
    <link href="https://jaeyeophan.github.io/2018/10/21/Vuetorials-1-vue-cli-3-0/"/>
    <id>https://jaeyeophan.github.io/2018/10/21/Vuetorials-1-vue-cli-3-0/</id>
    <published>2018-10-21T07:22:02.000Z</published>
    <updated>2018-11-16T03:01:14.735Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vuetorials.png" alt=""></p><h1 id="Vuetorials-1-vue-cli-3-0"><a href="#Vuetorials-1-vue-cli-3-0" class="headerlink" title="[Vuetorials] 1. @vue-cli 3.0"></a>[Vuetorials] 1. @vue-cli 3.0</h1><h2 id="프로젝트-세팅"><a href="#프로젝트-세팅" class="headerlink" title="프로젝트 세팅"></a>프로젝트 세팅</h2><p>일단 뭐가 됐든 프로젝트 세팅부터 할 <code>CRA(Create React App)</code> 같은게 필요함. 그게 <a href="https://cli.vuejs.org/" target="_blank" rel="noopener">@vue/cli</a> 임. 2018 년 8 월 version 3 이 release 되었음.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g @vue/cli</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vue create vue-app</span><br></pre></td></tr></table></figure><p><code>default</code> 랑 <code>Manually select features</code>를 선택할 수 있음. <code>default</code> 옵션은 말 그대로 기본적인 옵션으로 프로젝트를 생성해줌. <code>babel</code>과 <code>eslint</code> 기반임. 이렇게 <strong>선택</strong>을 할 수 있는건 CRA 보다 좋은 듯. 이전 버전에서 template 이라는 용어를 사용했다면 그 용어를 버리고 여러 옵션들을 조합하여 프로젝트를 스캐폴딩 해줌. template 으로는 여러 경우의 수를 모두 대응하기엔 한계가 있기 때문에 이러한 방법을 선택한 것 같음.</p><p>일단 처음이니 <code>default</code> 옵션으로 프로젝트를 생성해보겠음. yarn 쓸 지, npm 쓸 지도 선택할 수 있는데 npm 선택한 후 프로젝트 생성함.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> vue-app</span><br><span class="line">$ npm run serve</span><br></pre></td></tr></table></figure><p>깔끔하게 vue application 이 띄워졌음. (‘요즘것들’은 이 정도는 다 기본적으로 제공하고 있는 듯.)</p><p>스캐폴딩 된 프로젝트 구조는 다음과 같음. (VSCode 에서 해당 프로젝트를 열어보니 확장 프로그램이 권장됨. 바로 Vetur 설치함.)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── README.md</span><br><span class="line">├── babel.config.js</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   └── index.html</span><br><span class="line">└── src</span><br><span class="line">    ├── App.vue</span><br><span class="line">    ├── assets</span><br><span class="line">    │   └── logo.png</span><br><span class="line">    ├── components</span><br><span class="line">    │   └── HelloWorld.vue</span><br><span class="line">    └── main.js</span><br></pre></td></tr></table></figure><p>CRA 처럼 webpack config 등 여러 config 들을 숨겨버렸음. <code>babel.config.js</code>만 밖으로 나와있고 <code>preset</code>으로 <code>@vue/app</code>이 들어가있음. 이 녀석의 지원 범위라던가 스펙 등은 <a href="https://github.com/vuejs/vue-cli/blob/dev/packages/%40vue/babel-preset-app/README.md" target="_blank" rel="noopener">@vue/babel-preset-app</a>에서 확인할 수 있음. 그리고 다른 webpack 설정은 <a href="https://github.com/vuejs/vue-cli/blob/dev/packages/%40vue/cli-service/lib/config/base.js" target="_blank" rel="noopener">@vue/cli-service 의 lib 디렉토리</a>에서 확인할 수 있음.</p><p>babel 이 7 version 으로 올라가면서 전부 <code>@babel</code> namespace 로 들어가면서 monorepo 형식으로 운영되는데 <code>vue-cli</code> 도 <code>@vue</code> namespace 를 기반으로 monorepo 로 구성된 것을 확인할 수 있음.</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>가장 중요한 npm scripts 는 <code>vue-cli-service</code> 라는 모듈로 제공됨. 다양한 옵션들은 <a href="https://cli.vuejs.org/guide/cli-service.html#using-the-binary" target="_blank" rel="noopener">여기</a>에서 확인 가능함.</p><p><code>serve</code>, <code>build</code>, <code>lint</code> 세 가지 기본 command 를 제공함. 일단 <code>npm start</code> 가 없다는게 마음에 안 듬. 그리고 왜 <code>test</code> 커맨드가 없나 했는데 default 에서는 테스트를 위한 package 가 포함이 안 되어있음. 그래서 커맨드도 만들어주지 않음.</p><h2 id="Project-Configuration"><a href="#Project-Configuration" class="headerlink" title="Project Configuration"></a>Project Configuration</h2><p><code>@vue/cli</code>는 CRA 랑 다르게 애초에 <code>eject</code>를 지원하지 않음. CRA(1.x 기준)에서는 override 하기 위해 eject 를 하거나 <a href="https://github.com/timarney/react-app-rewired" target="_blank" rel="noopener">react-app-rewired</a> 를 썼음.</p><p>Vue 에서는 <code>vue.config.js</code>를 통해 override 하거나 필요한 loader, plugin 들을 추가하라고 함. <a href="https://github.com/survivejs/webpack-merge" target="_blank" rel="noopener">webpack-merge</a>를 사용해봤다면 익숙하게 사용할 수 있을 듯. 그냥 사용할 로더나 플러그인에 대해 <code>module.exports = { ... }</code> 형태로 작성하면 알아서 config 에 merge 함. <a href="https://github.com/neutrinojs/webpack-chain" target="_blank" rel="noopener">webpack-chain</a> 도 지원하고 있어서 chaining 문법으로도 vue.config.js 를 작성할 수도 있음. 실제로 내부 config들은 chaining 문법으로 작성되어 있음. (보기 더 편한 것 같기도 함.)</p><p>아직 config 를 추가해보지 않았고 최근에 release 된 CRA 2.x version 을 사용해보지 않았지만 Vue 쪽 지원이 더 좋은 듯.</p><p>@vue/cli 로 스캐폴딩 된 프로젝트의 webpack config 가 너무 궁금하면 해당 프로젝트에서 <code>vue inspect</code> 명령어를 치면 확인해볼 수 있음. 파일로 보고 싶으면 <code>&gt;</code>와 함께 사용하면 됨. <code>vue inspect &gt; output.js</code> 이렇게. <code>inspect</code> 명령어는 다양한 옵션도 제공하고 있으니 유용하게 사용할 수 있을 듯 함.</p><h2 id="Manually-select-features"><a href="#Manually-select-features" class="headerlink" title="Manually select features"></a>Manually select features</h2><ol><li>transpiler 로는 <strong>babel</strong>과 <strong>TypeScript</strong>를 지원함.</li><li>Unit test 로는 <strong>Mocha + chai 조합</strong>과 <strong>Jest</strong>를 지원함.</li><li>E2E test 로는 <strong>Cypress</strong>와 <strong>nightwatch</strong>를 지원함.</li><li>PWA 도 지원함.</li><li>server side renderer 라이브러리인 vue-server-renderer 를 포함하여 스캐폴딩 해주는 옵션은 없음. <a href="https://github.com/vuejs/vue-cli/issues/1034" target="_blank" rel="noopener">논의</a>는 있었던 것 같음. <a href="https://github.com/nuxt/nuxt.js" target="_blank" rel="noopener">nuxt.js</a>가 있으니 별도 지원 필요성을 느끼지 못하는 듯.</li></ol><p>babel 이랑 typescript 랑 같이 선택하면 <code>Use Babel alongside TypeScript for auto-detected polyfills?</code> 이런 메세지가 나옴. TypeScript 만 선택했을 때와 비교하면 <code>tsconfig.json</code>에서 <code>target</code> 이 다르게 설정됨. babel 과 함께 스캐폴딩할 경우 <code>esnext</code>로 target 이 지정되고 아닐 경우 es5 로 지정됨.</p><p>참고로 typescript 를 위한 loader 는 <a href="https://github.com/s-panferov/awesome-typescript-loader" target="_blank" rel="noopener">atsl</a>이 아닌 <a href="https://github.com/Realytics/fork-ts-checker-webpack-plugin" target="_blank" rel="noopener">fork-ts-checker-webpack-plugin</a>과 함께 <a href="https://github.com/TypeStrong/ts-loader" target="_blank" rel="noopener">ts-loader</a>로 스캐폴딩 됨.</p><h2 id="Add-dependency"><a href="#Add-dependency" class="headerlink" title="Add dependency"></a>Add dependency</h2><p>초기 프로젝트 세팅에서 추가하고 싶은 경우가 있을 경우, <code>vue add</code>라는 command를 통해 추가할 수 있음. dependency는 물론 npm scripts, 기본적인 scaffolding까지 해줌.</p><ul><li><a href="https://kazupon.github.io/vue-i18n/installation.html#vue-cli-3-x" target="_blank" rel="noopener"><code>vue add i18n</code></a></li><li><a href="https://www.npmjs.com/package/@vue/cli-plugin-unit-jest" target="_blank" rel="noopener"><code>vue add @vue/unit-jest</code></a></li></ul><h2 id="Support-GUI"><a href="#Support-GUI" class="headerlink" title="Support GUI"></a>Support GUI</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vue ui</span><br></pre></td></tr></table></figure><p><code>@vue/cli</code> 설치 후, 이 명령어를 실행하면 8000 포트로 Vue Project Manager 가 열림. 프로젝트를 생성하고 create 할 수 있는 GUI 를 제공함. 터미널 명령어들이 익숙하지 않거나 초심자 입장에서는 사용하기 정말 좋아보임. (아직 Beta 딱지가 붙어있음.)</p><p>딱히 사용할 일이 있겠나 싶었는데 방금 생성한 vue-app 을 import 했더니 프로젝트와 관련된 plugins, dependencies, configuration, npm tasks 를 볼 수 있음. (vue project directory 에서 <code>vue ui</code> 명령어를 입력하면 바로 해당 프로젝트의 GUI 가 나타남.)</p><h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><p>현재 설치된 <code>@vue</code>의 plugins 리스트를 보여줌. 관련된 문서로 바로 이동할 수 있음. vue 측에서 이번에 각종 옵션들을 플러그인 형태로 구성하면서 cli plugins 를 만들기도 권장하고 있는 것 같음. <a href="https://cli.vuejs.org/dev-guide/plugin-dev.html#core-concepts" target="_blank" rel="noopener">Plugin Development Guide</a>도 있음.</p><h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><p>npm version 관리를 위해 현재 설치된 version 과 wanted version, 그리고 latest version 을 보여줌. npm versioning 을 관리하기 위해 VSCode 의 extension 을 쓰거나 별도 tool 을 사용하고 있었는데 여기서도 충분할 것 같음. 마찬가지로 공식 문서로 바로 이동할 수 있음.</p><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><p>Vue 에서는 현재 프로젝트의 설정들을 override 하거나 별도로 추가하기 위해 <code>vue.config.js</code>를 제공하고 있음. 이 부분을 GUI 로도 보여줌. eslint rules 또한 GUI 상에서 끄고 켤 수 있음. (별의별 기능이 다 있음.)</p><h3 id="npm-tasks"><a href="#npm-tasks" class="headerlink" title="npm tasks"></a>npm tasks</h3><p>GUI 상에서 바로 실행할 수 있으며 각각의 명령어에 대해 output, dashboard, analyzer 까지 지원됨. 기존에 <code>webpack-bundle-analyzer</code> 나 webpack 이 내뱉는 지저분한 로그들을 정리하기 위해 <code>webpack-stylish</code> 등을 사용했던 편이라 굉장히 좋아보임. 참고로 기본으로 세팅되는 npm scripts <code>vue-cli-service</code>를 통해 <code>serve</code>하게 되면 <a href="https://github.com/geowarin/friendly-errors-webpack-plugin" target="_blank" rel="noopener">friendly-errors-webpack-plugin</a>을 기반으로 로그가 만들어짐.</p><h2 id="추가-개발-환경"><a href="#추가-개발-환경" class="headerlink" title="추가 개발 환경"></a>추가 개발 환경</h2><p>개발하기 위해서는 개발자 도구가 빠질 수 없음. Vue 역시 Chrome extension 을 제공하고 있음. <a href="https://github.com/vuejs/vue-devtools#vue-devtools" target="_blank" rel="noopener">vue-devtools</a> 이 녀석을 사용하면 됨. react의 경우 redux-devtools가 따로 있는데 Vue는 이걸로 Vuex까지 지원하고 있음.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Vue 를 시작하는데 있어서 @vue/cli 의 여러 기능 중 필요한 기본적인 것들에 대해서만 다뤘음. 보다 자세한 @vue/cli 의 3 version 정보가 필요하다면 Evan You 가 쓴 이 <a href="https://medium.com/the-vue-point/vue-cli-3-0-is-here-c42bebe28fbb" target="_blank" rel="noopener">아티클</a>을 읽어보거나 release note 를 확인해보면 좋을 듯. 회사에서 업무로 프로젝트 스캐폴딩 도구를 담당하기도 했고 생산성에 관심이 많아 재미있게 봤음. 너무 잘 만들었음.</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noopener">https://github.com/vuejs/vue-cli</a></li><li><a href="https://medium.com/the-vue-point/vue-cli-3-0-is-here-c42bebe28fbb" target="_blank" rel="noopener">https://medium.com/the-vue-point/vue-cli-3-0-is-here-c42bebe28fbb</a></li><li><a href="https://blog.logrocket.com/vue-cli-3-the-deep-dive-41dff070ac4a" target="_blank" rel="noopener">https://blog.logrocket.com/vue-cli-3-the-deep-dive-41dff070ac4a</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vuetorials.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Vuetorials-1-vue-cli-3-0&quot;&gt;&lt;a href=&quot;#Vuetorials-1-vue-cli-3-0&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Vue" scheme="https://jaeyeophan.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jaeyeophan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>[Vuetorials] 0. 들어가면서</title>
    <link href="https://jaeyeophan.github.io/2018/10/21/Vuetorials-0-intro/"/>
    <id>https://jaeyeophan.github.io/2018/10/21/Vuetorials-0-intro/</id>
    <published>2018-10-21T07:21:13.000Z</published>
    <updated>2018-11-17T08:49:15.550Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vuetorials.png" alt=""></p><h1 id="Vuetorials-0-들어가면서"><a href="#Vuetorials-0-들어가면서" class="headerlink" title="[Vuetorials] 0. 들어가면서"></a>[Vuetorials] 0. 들어가면서</h1><h2 id="구성"><a href="#구성" class="headerlink" title="구성"></a>구성</h2><p>각 내용들은 짧은 호흡으로 진행됩니다. @vue/cli 로 시작하여 Vue 에 대한 기본적인 내용을 다루고 Vue 생태계를 구성하고 있는 라이브러리들도 함께 다뤄볼 예정입니다. vuex, vue-router, vue-server-renderer, nuxt 순서가 되지 않을까 싶습니다. 그리고 React 와의 비교가 약간씩 들어갈 예정입니다.</p><p>뷰토리얼은 Vue 라는 라이브러리의 A 부터 Z 까지 전부 다루지 않습니다. Vue 의 모든 것을 처음부터 끝까지 다 보려는 목적이라면 책을 보거나 다른 강의나 튜토리얼 포스트를 보세요! 공식 문서 또한 매우 잘 되어있기 때문에 이러한 부분은 별도로 다루지 않습니다.</p><p>필자도 공부하면서 정리 중이라 모르는 것은 모른다고 하고 있습니다. (물론 알게 되면 업데이트 예정입니다.)</p><h2 id="그럼-뭘-다룰-예정인가"><a href="#그럼-뭘-다룰-예정인가" class="headerlink" title="그럼 뭘 다룰 예정인가?"></a>그럼 뭘 다룰 예정인가?</h2><ul><li>개발에 들어갈때 혼동이 될 수 있는 부분</li><li>매직이 어떻게 동작하는지</li><li>리액트와 비교</li><li>필자가 이해한 라이브러리가 추구하는 철학과 방향</li><li>…</li></ul><h2 id="이-튜토리얼을-따라가볼-대상자는-누군가"><a href="#이-튜토리얼을-따라가볼-대상자는-누군가" class="headerlink" title="이 튜토리얼을 따라가볼 대상자는 누군가?"></a>이 튜토리얼을 따라가볼 대상자는 누군가?</h2><ol><li>React 또는 다른 라이브러리로 개발을 해봤는데 Vue 도 궁금한 개발자.</li><li>Vue 로 개발 중인 개발자.</li><li>Vue 공식 문서 정도 본 개발자.</li><li>그냥 Vue 를 훑어보고 싶은 개발자.</li></ol><h2 id="‘음슴체’로-작성"><a href="#‘음슴체’로-작성" class="headerlink" title="‘음슴체’로 작성"></a>‘음슴체’로 작성</h2><p>뷰토리얼(Vuetorials)이 다른 튜토리얼과 다른 점은 음슴체로 진행된다는 점입니다.(ㅋㅋㅋ) 포스트 하나를 작성하는데 문체를 다듬거나 어순을 변경하는 등 부수적인 요소에 많은 시간이 소요됐습니다. 책을 쓰는 것도 아닌데 조금 더 편한 문체로 작성해도 되지 않나? 라는 생각에 시도해봤습니다.</p><h2 id="순서"><a href="#순서" class="headerlink" title="순서"></a>순서</h2><ol><li><a href="https://jaeyeophan.github.io/2018/10/21/Vuetorials-1-vue-cli-3-0/">@vue-cli 3.0</a></li><li><a href="https://jaeyeophan.github.io/2018/10/21/Vuetorials-2-Vue-concept/">Vue 의 전반적인 concept</a></li><li><a href="https://jaeyeophan.github.io/2018/10/23/Vuetorials-3-Component-API/">Vue 의 Component API</a></li><li><a href="https://jaeyeophan.github.io/2018/11/05/Vuetorials-4-Internal-Component/">Vue 의 내장 컴포넌트</a></li><li><a href="https://jaeyeophan.github.io/2018/11/07/Vuetorials-5-Vuex/">Vuex API</a></li><li><a href="https://jaeyeophan.github.io/2018/11/16/Vuetorials-6-Vuex-Module-pattern/">Vuex Module Pattern</a></li><li><a href="https://jaeyeophan.github.io/2018/11/17/Vuetorials-7-Vuex-Best-Practice/">Vuex Best Practice로 가는 여정</a></li></ol><blockquote><p>Let’s Vue!</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vuetorials.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Vuetorials-0-들어가면서&quot;&gt;&lt;a href=&quot;#Vuetorials-0-들어가면서&quot; class=&quot;headerlink&quot; title=&quot;[Vuetor
      
    
    </summary>
    
      <category term="Vue" scheme="https://jaeyeophan.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jaeyeophan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>[TS] 8. enum vs const enum</title>
    <link href="https://jaeyeophan.github.io/2018/06/16/TS-8-enum-vs-const-enum/"/>
    <id>https://jaeyeophan.github.io/2018/06/16/TS-8-enum-vs-const-enum/</id>
    <published>2018-06-16T06:02:44.000Z</published>
    <updated>2018-06-16T06:14:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/typescript.png" alt=""></p><h1 id="TS-8-enum-vs-const-enum"><a href="#TS-8-enum-vs-const-enum" class="headerlink" title="[TS] 8. enum vs const enum"></a>[TS] 8. enum vs const enum</h1><p>TypeScript 문법 중 <code>enum</code> 이라는 것이 있다. 주로 상수를 선언할 때 namespace 를 줘서 상수끼리의 응집도를 높이고 그 의미를 더할 수 있으며 VSCode 의 auto complete 의 지원을 받을 때 유용하다. 이 <code>enum</code> 키워드를 사용하는 방법에는 두 가지가 존재한다. 그냥 <code>enum</code> 키워드를 사용해 선언할 수 있으며 <code>const</code> 키워드와 함께 사용하여 <code>const enum</code>으로 선언할 수 있다.</p><p>이 두 가지는 무엇이 다를까.</p><p><a href="http://www.typescriptlang.org/play/" target="_blank" rel="noopener">TypeScript Playground</a>에 가서 JavaScript 로 compile 된 모습을 먼저 살펴보자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> JustEnumNumber &#123;</span><br><span class="line">  zero,</span><br><span class="line">  one</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(JustNumber.one); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>간단한 <code>enum</code> 을 선언했다. 이 <code>JustEnumNumber</code>는 다음과 같이 transpile 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> JustEnumNumber;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">JustEnumNumber</span>) </span>&#123;</span><br><span class="line">  JustEnumNumber[(JustEnumNumber[<span class="string">"zero"</span>] = <span class="number">0</span>)] = <span class="string">"zero"</span>;</span><br><span class="line">  JustEnumNumber[(JustEnumNumber[<span class="string">"one"</span>] = <span class="number">1</span>)] = <span class="string">"one"</span>;</span><br><span class="line">&#125;)(JustEnumNumber || (JustEnumNumber = &#123;&#125;));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(JustNumber.one); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><code>enum</code>에 대해 알아본 적이 있다면 익숙한 JavaScript 형태로 transpile 되는 것을 확인할 수 있다. 사실 저 코드는 조금 복잡해보여도 다음과 같은 코드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> JustEnumNumber;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">JustEnumNumber</span>) </span>&#123;</span><br><span class="line">  JustEnumNumber[<span class="string">"zero"</span>] = <span class="number">0</span>;</span><br><span class="line">  JustEnumNumber[<span class="string">"one"</span>] = <span class="number">1</span>;</span><br><span class="line">  JustEnumNumber[<span class="number">0</span>] = <span class="string">"zero"</span>;</span><br><span class="line">  JustEnumNumber[<span class="number">1</span>] = <span class="string">"one"</span>;</span><br><span class="line">&#125;)(JustEnumNumber || (JustEnumNumber = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>이젠 <code>const enum</code>을 보자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> ConstEnumNumber &#123;</span><br><span class="line">  zero,</span><br><span class="line">  one</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ConstEnumNumber.one); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>아까와 같은 간단한 <code>enum</code>을 선언했고 플레이그라운드에서 JavaScript 도 transpile 을 해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="comment">/* one */</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><code>enum</code> 구현체는 다 사라지고 console 을 위한 코드만 남아있다. <code>const</code> 키워드를 사용하고 안 하고의 차이가 좀 큰 것 같다.</p><p>다시 <code></code>JustEnumNumber<code>코드를 보자.</code>enum`만으로 선언할 경우, namespace 를 위한 변수가 선언이 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> JustEnumNumber;</span><br></pre></td></tr></table></figure><p>그리고 선언된 변수를 객체로 우리가 원하는 상수값들을 선언하게 된다. 이 때 선언된 변수는 transpile 되어서도 남아있게 되어 우리는 <code>enum</code>으로 선언한 객체 자체에 접근할 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(JustEnumNumber); <span class="comment">// [object object]</span></span><br></pre></td></tr></table></figure><p>하지만 <code>const enum</code>으로 enum 을 선언하게 되면 compile 단계에서 namespace 가 날라가게 되므로 접근할 수 없다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(ConstEnumNumber); <span class="comment">// [ERROR] 'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment or type query.</span></span><br></pre></td></tr></table></figure><p>내부 상수값들이 전부 compile 단계에서 대치된 것이다. 내부 필드를 전부 상수로 변경하기 때문에 런타임에 의존 모듈의 영향을 받지 않게 되며, 코드 크기가 더 적기 때문에 더 선호된다고 한다.</p><p>사실 이 부분은 TypeScript Official Document 에 다음과 같이 나와있다.</p><blockquote><p>To avoid paying the cost of extra generated code and additional indirection when accessing enum values, it’s possible to use <code>const</code> enums.</p></blockquote><p>그렇다면 <code>enum</code>만으로 선언하는 경우는 언제일까.</p><p>우선 namespace 가 남아있으니 우리는 enum 을 이렇게도 사용할 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(JustEnumNumber[JustEnumNumber.one]); <span class="comment">// one</span></span><br></pre></td></tr></table></figure><p>상수만으로 로그가 찍히면 알아보기 힘드니 reverse 참조를 하여 로그를 찍을 수 있다. lookup object 로 사용하는 것이다. 하지만 이렇게 선언된 enum 은 런타임에 이 lookup object 를 통해 참조가 이루어지므로 조심해야 한다. 물론 webpack 환경에서는</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 scope 를 쳐주지만 test 환경에서는 browser 객체(ex. window…)를 참조하는 경우 에러가 발생할 수 있다.</p><p>참고한 블로그의 문장을 인용하여 해당 글을 마친다.</p><blockquote><p><code>const enum</code> is a <strong>compile-time only</strong> feature, while the original <code>enum</code> is a <strong>runtime + compile-time</strong>feature. Most projects will be well suited for <code>const enum</code>, but there may be cases where <code>enum</code> is preferred.</p></blockquote><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://www.typescriptlang.org/docs/handbook/enums.html" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/enums.html</a></li><li><a href="https://www.sitepoint.com/10-essential-typescript-tips-tricks-angular/?WT.mc_id=link-twitter-jeliknes" target="_blank" rel="noopener">https://www.sitepoint.com/10-essential-typescript-tips-tricks-angular/?WT.mc_id=link-twitter-jeliknes</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/typescript.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;TS-8-enum-vs-const-enum&quot;&gt;&lt;a href=&quot;#TS-8-enum-vs-const-enum&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="TypeScript" scheme="https://jaeyeophan.github.io/categories/TypeScript/"/>
    
    
      <category term="ts" scheme="https://jaeyeophan.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>[TS] 7. TypeScript type system</title>
    <link href="https://jaeyeophan.github.io/2018/01/10/TS-7-TypeScript-type-system/"/>
    <id>https://jaeyeophan.github.io/2018/01/10/TS-7-TypeScript-type-system/</id>
    <published>2018-01-10T04:31:30.000Z</published>
    <updated>2018-01-10T04:31:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/typescript.png" alt=""></p><h1 id="TS-7-Typescript’s-Type-System"><a href="#TS-7-Typescript’s-Type-System" class="headerlink" title="[TS] 7. Typescript’s Type System"></a>[TS] 7. Typescript’s Type System</h1><h3 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h3><ul><li>TypeScript의 Type Checking System</li><li>Type Inference</li><li>Type Assertion</li><li>Type Guards</li><li>Type Compatibility</li></ul><p><br></p><h2 id="TypeScript의-Typing-Checking-System"><a href="#TypeScript의-Typing-Checking-System" class="headerlink" title="TypeScript의 Typing Checking System"></a>TypeScript의 Typing Checking System</h2><p><code>TypeScript</code>에서의 Type System에 대한 이해를 하기 전, 기존 프로그래밍 언어의 큰 두 축인 정적 언어와 동적 언어에 대한 정의를 다시 한 번 살펴볼 필요가 있습니다.</p><h3 id="정적언어-Static-Language"><a href="#정적언어-Static-Language" class="headerlink" title="정적언어 (Static Language)"></a>정적언어 (Static Language)</h3><ul><li>변수(variables) 또는 함수(function)의 <code>Type</code>을 <strong>미리</strong> 지정해야 한다.</li><li>컴파일되는 시점에 Type Check를 수행한다.</li></ul><h3 id="동적-언어-Dynamic-Language"><a href="#동적-언어-Dynamic-Language" class="headerlink" title="동적 언어 (Dynamic Language)"></a>동적 언어 (Dynamic Language)</h3><ul><li>변수(variables) 또는 함수(function)의 <code>Type</code>을 지정하지 않는다.</li><li>Type Check는 런타임(runtime) 환경에서나 알 수 있다.</li></ul><h3 id="Duck-Typing"><a href="#Duck-Typing" class="headerlink" title="Duck Typing"></a>Duck Typing</h3><p>덕 타이핑(Duck Typing)이라고 많이 들어보셨을 텐데요, 현재 이 덕 타이핑 체계를 기반으로 동적 언어에 타입을 추론하는 언어는 GoLang과 Python 등이 있습니다. 하지만 TypeScript는 이 덕타이핑과는 조금 다른 체계로 <strong>Typing</strong>을 하고 있습니다.</p><blockquote><p>덕 타이핑에 대한 보다 자세한 내용은 <a href="https://www.google.co.kr/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;ved=0ahUKEwjj5dzEl8PYAhXCNJQKHfG9DdYQFggxMAE&amp;url=http%3A%2F%2Fwww.popit.kr%2Fgolang%25EC%259C%25BC%25EB%25A1%259C-%25EB%25A7%258C%25EB%2582%2598%25EB%25B3%25B4%25EB%258A%2594-duck-typing%2F&amp;usg=AOvVaw1dXNKFpMsVofdtJ-QOglzu" target="_blank" rel="noopener">여기</a>를 참고해주세요.</p></blockquote><h3 id="Structural-typing"><a href="#Structural-typing" class="headerlink" title="Structural typing"></a>Structural typing</h3><p>TypeScript는 <strong>Structural typing</strong> (구조적 타이핑)을 기반으로 타입 시스템을 갖추고 있습니다. 구조적 타이핑이란, <code>멤버</code>에 따라 타입을 <strong>연관짓는</strong> 방법을 말합니다. 구조적 타이핑과 반대인 방법으로 <code>nominal typing</code>이 있습니다. 우리가 알고 있는 일반적인 정적 언어인 C#, Java는 이 <code>nominal typing</code> 방식으로 <strong>type checking</strong>이 이루어집니다.</p><p><em>Official Document</em>에 나온 예제를 통해 설명드립니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Named &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;  </span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Named;</span><br><span class="line">p = <span class="keyword">new</span> Person(); <span class="comment">// Ok, because of structural typing</span></span><br></pre></td></tr></table></figure></p><p>위 코드를 C# 또는 Java의 문법에 맞게 변경한다면 동작하지 않는 잘못된 코드가 됩니다. 하지만 TypeScript에서는 정상적으로 동작합니다. <code>Named</code>와 <code>Person</code> 두 가지는 오로지 <code>name</code>이라는 프로퍼티(or 멤버)만 갖고 있는 타입이므로 서로 <code>compatibility</code> 하다고 볼 수 있습니다. 때문에 위 코드는 문제되지 않습니다. (compatibility에 대해서는 뒤에서 알아봅니다.)</p><p><br></p><h2 id="Type-Inference"><a href="#Type-Inference" class="headerlink" title="Type Inference"></a>Type Inference</h2><p>‘누가봐도 이 변수는 이 타입이다.’라는 것에 대해 TypeScript가 지원해주는 것을 <strong>타입 추론</strong> 이라고 합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">`jbee`</span>;</span><br></pre></td></tr></table></figure></p><p><code>name</code>이라는 변수는 <code>string</code> 타입의 변수가 됩니다. 그렇기 때문에 굳이 <code>: string</code>이라고 타입을 지정해주지 않아도 다음과 같이 에러가 발생합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="number">1</span>; <span class="comment">// Error: Type '1' is not assignable to type 'string'.</span></span><br></pre></td></tr></table></figure></p><p>그렇다면 다음과 같은 경우에는 어떻게 추론될까요?<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mixedArr = [<span class="number">0</span>, <span class="number">1</span>, <span class="string">`jbee`</span>];</span><br></pre></td></tr></table></figure></p><p><code>number</code>에 해당되는 value와 <code>string</code>에 해당하는 value가 공존하기 때문에 위 코드에서 <code>mixedArr</code>은 <code>(number | string)[]</code>의 타입을 갖게 됩니다. 이렇게 여러 타입이 공존하는 경우에 추론하여 지정되는 타입을 <strong>Best common type</strong>이라고 합니다.</p><p><br></p><h2 id="Type-Assertion"><a href="#Type-Assertion" class="headerlink" title="Type Assertion"></a>Type Assertion</h2><p>이 변수의 타입은 분명 <code>A</code>인데 TypeScript에서 보수적으로 처리하여 에러를 발생시키는 경우가 있습니다. 이럴 경우 해당 변수를 <code>A</code>라고 명시하여 에러를 사라지게 할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Todo = &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  text: <span class="built_in">string</span>;</span><br><span class="line">  completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Todos = Todo[];</span><br></pre></td></tr></table></figure></p><p>위와 같이 <code>Todo</code> 타입과 <code>Todos</code> 타입을 지정한 상황이라고 했을 때를 예로 들어보겠습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState: Todos = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">0</span>,</span><br><span class="line">    text: <span class="string">'Study RxJS'</span>,</span><br><span class="line">    completed: <span class="literal">false</span>,</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>위 코드에서 <code>Todos</code>에 해당하는 타입을 제대로 지정해줬지만 뭔가 아쉬움이 남을 수 있는데요, 이 때 두 가지 방법을 사용할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState: Todos = [</span><br><span class="line">  &lt;TODO&gt;&#123;</span><br><span class="line">    id: <span class="number">0</span>,</span><br><span class="line">    text: <span class="string">'Study RxJS'</span>,</span><br><span class="line">    completed: <span class="literal">false</span>,</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>위 코드처럼 <code>&lt;&gt;</code>을 사용하거나<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState: Todos = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">0</span>,</span><br><span class="line">    text: <span class="string">'Study RxJS'</span>,</span><br><span class="line">    completed: <span class="literal">false</span>,</span><br><span class="line">  &#125; <span class="keyword">as</span> Todo</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>위 코드처럼 <code>as</code> 키워드를 사용할 수 있습니다. 두 가지 모두 동일하지만 <code>tsx</code>와 함께 사용하기 위해서는 <code>as</code> 키워드를 사용하는 것이 좋습니다.</p><blockquote><p>[!] 이 Type Assertion은 Type Casting과는 다릅니다. 자세한 내용은 <a href="https://hyunseob.github.io/2017/12/12/typescript-type-inteference-and-type-assertion/" target="_blank" rel="noopener">DailyEngineering - 타입 추론과 타입 단언</a>을 참고해주세요!</p></blockquote><p><br></p><h2 id="Type-Guards"><a href="#Type-Guards" class="headerlink" title="Type Guards"></a>Type Guards</h2><p>자바스크립트에서는 <code>typeof</code> 또는 <code>instanceof</code>와 같은 오퍼레이터가 타입을 확인해주는 역할을 했었습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.state[key] !== <span class="keyword">typeof</span> newData) &#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>하지만 이 방법은 런타임에서 타입 체크를 수행하게 됩니다. 따라서 컴파일 시점에서는 올바른 타입인지 알 수 없습니다. TypeScript에서는 컴파일 시점에서 타입 체크를 수행할 수 있도록 <code>Type Guard</code>를 지원합니다.</p><p><br></p><h3 id="typeof-instanceof"><a href="#typeof-instanceof" class="headerlink" title="typeof, instanceof"></a><code>typeof</code>, <code>instanceof</code></h3><p>TypeScript에서도 마찬가지로 <code>typeof</code>와 <code>instanceof</code> 오퍼레이터를 지원합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setNumberOrString</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x.subtr(<span class="number">1</span>)); <span class="comment">// Error</span></span><br><span class="line">    <span class="built_in">console</span>.log(x.substr(<span class="number">1</span>)); <span class="comment">// OK</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(typof x); <span class="comment">// number</span></span><br><span class="line">  &#125;</span><br><span class="line">  x.substr(<span class="number">1</span>); <span class="comment">// Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 코드에서 <code>if-block</code>내에서의 <code>x</code>변수의 타입은 <code>string</code>일 수 밖에 없다는 것을 컴파일 시점에 체크하여 transpiler가 Error를 발생시키는 경우입니다. 이 예제와 비슷한 방법으로 <code>instanceof</code> 오퍼레이터를 사용할 수 있습니다. <code>instanceof</code>는 클래스를 기반으로 생성된 인스턴스의 타입을 판단하는데 사용됩니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Pet &#123;</span><br><span class="line">  name = <span class="number">123</span>;</span><br><span class="line">  common = <span class="string">'123'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Basket &#123;</span><br><span class="line">  size = <span class="number">123</span>;</span><br><span class="line">  common = <span class="string">'123'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">arg: Pet | Basket</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Pet) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.name); <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.size); <span class="comment">// Error!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Basket) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.name); <span class="comment">// Error!</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.size); <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(arg.common); <span class="comment">// OK</span></span><br><span class="line">  <span class="built_in">console</span>.log(arg.name); <span class="comment">// Error!</span></span><br><span class="line">  <span class="built_in">console</span>.log(arg.size); <span class="comment">// Error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>typeof</code>와 마찬가지로 <code>instanceof</code>로 필터링 된 block 내부에서 <strong>Type checking</strong>이 이루어집니다.</p><p><br></p><h3 id="in"><a href="#in" class="headerlink" title="in"></a><code>in</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  y: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">q: A | B</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'x'</span> <span class="keyword">in</span> q) &#123;</span><br><span class="line">    <span class="comment">// q: A</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// q: B</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>A</code> 또는 <code>B</code>를 유니온 타입으로 받을 수 있는 <code>execute</code> 함수 내에서 각각에 대해 다른 처리를 할 경우, <code>in</code>이라는 오퍼레이터를 사용할 수 있습니다. 해당 오퍼레이터는 check하고자 하는 타입에 해당 프로퍼티가 존재하는지의 유무를 판단할 수 있습니다.</p><p><br></p><h3 id="kind-Literal-Type-Guard"><a href="#kind-Literal-Type-Guard" class="headerlink" title=".kind Literal Type Guard"></a><code>.kind</code> Literal Type Guard</h3><p>사용자에 의해 <code>type</code>으로 정의된 타입에 대해서, 즉 TypeScript 내부에서 지원하는 primitive type이 아닌 <strong>사용자 정의 타입에 대해서 타입 검사를 수행할 때</strong>, <code>.kind</code>를 사용할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = &#123;</span><br><span class="line">  kind: <span class="string">'foo'</span>, <span class="comment">// Literal type </span></span><br><span class="line">  foo: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bar = &#123;</span><br><span class="line">  kind: <span class="string">'bar'</span>, <span class="comment">// Literal type </span></span><br><span class="line">  bar: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">arg: Foo | Bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arg.kind === <span class="string">'foo'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.foo); <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.bar); <span class="comment">// Error!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 코드에서 처럼 <code>type</code> 키워드를 사용하여 별도 타입을 지정할 때, <code>kind</code>라는 프로퍼티를 추가하여 타입 검사를 수행할 수 있습니다.</p><p><br></p><h3 id="User-Defined-Type-Guards"><a href="#User-Defined-Type-Guards" class="headerlink" title="User Defined Type Guards"></a>User Defined Type Guards</h3><p>메소드를 별도로 분리하여 Type Guard를 지정할 수 있습니다. 아까 지정한 interface A로 만들어보겠습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Define Type Guard</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isA</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">arg</span> <span class="title">is</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg.x !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>arg is A</code>라는 타입으로 <code>isA</code> 메소드가 Type Guard의 역할을 수행한다는 것을 명시할 수 있습니다. if 내부에 들어가는 로직을 별도로 추출하여 보다 가독서이 좋은 코드를 작성할 수 있습니다.</p><p><br></p><h2 id="Type-Compatibility"><a href="#Type-Compatibility" class="headerlink" title="Type Compatibility"></a>Type Compatibility</h2><p>한국어로 번역하게 되면 <strong>타입 호환성</strong> 정도로 할 수 있겠는데요, TypeScript는 위에서 언급했듯이 <strong>Structural subtyping</strong>을 기반으로 Type checking을 하기 때문에 이를 기반으로 타입 간의 호환성을 고려할 수 있습니다.</p><h4 id="1-Comparing-two-Objects"><a href="#1-Comparing-two-Objects" class="headerlink" title="1. Comparing two Objects"></a>1. Comparing two Objects</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123;name: <span class="string">`Jbee`</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> y = &#123;name: <span class="string">`James`</span>, age: <span class="number">34</span>&#125;;</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// OK!</span></span><br><span class="line">y = x; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><p>위 코드에서 <code>x</code>는 <code>{name: string}</code> 타입으로 추론되며, <code>y</code>는 <code>{name: string, age: number}</code>로 추론됩니다. 이 경우 <code>x = y</code>는 <code>y</code>에 <code>name</code>이라는 속성이 있으므로 가능하지만 <code>y = x</code>의 경우, <code>x</code>에는 <code>age</code>라는 속성이 없으므로 에러가 발생합니다.</p><h4 id="2-Comparing-two-functions"><a href="#2-Comparing-two-functions" class="headerlink" title="2. Comparing two functions"></a>2. Comparing two functions</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="function">(<span class="params">b: <span class="built_in">number</span>, s: <span class="built_in">string</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// OK</span></span><br><span class="line">x = y; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>함수일 경우에는 객체인 경우와 조금 다른 것을 볼 수 있습니다. 위 코드에서 두 <code>x</code>, <code>y</code>함수는 parameter 만 다르게 정의되어 있습니다. 이 경우, <code>x</code> 함수에 전달할 수 있는 parameter의 경우의 수가 y에 모두 해당하므로 <code>y = x</code>가 정상적으로 동작합니다. 하지만 그 반대인 <code>x = y</code>는 <code>y</code> 함수에 전달할 수 있는 parameter를 <code>x</code>가 모두 포용할 수 없으므로 에러가 발생합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;name: <span class="string">`Jbee`</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> y = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;name: <span class="string">`James`</span>, age: <span class="number">34</span>&#125;);</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// OK!</span></span><br><span class="line">y = x; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></p><p>이번에는 return value의 type이 다른 경우입니다. 이 경우에는 함수의 경우를 따르지 않고 객체인 경우를 따르게 됩니다.</p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>TypeScript의 단순한 문법을 조금 넘어서 어떻게 Type Checking이 이루어지는지 살펴봤습니다.<br>감사합니다.</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://www.typescriptlang.org/docs/handbook/type-inference.html" target="_blank" rel="noopener">TypeScript Official Document - Type Inference</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html" target="_blank" rel="noopener">TypeScript Official Document - Type Compatibility</a></li><li><a href="http://www.popit.kr/golang%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%82%98%EB%B3%B4%EB%8A%94-duck-typing/" target="_blank" rel="noopener">Golang으로 만나보는 duck typing</a></li><li><a href="https://medium.com/@thejameskyle/type-systems-structural-vs-nominal-typing-explained-56511dd969f4" target="_blank" rel="noopener">Type Systems: Structural vs Nominal typing explained</a></li><li><a href="https://basarat.gitbooks.io/typescript/docs/types/typeGuard.html" target="_blank" rel="noopener">TypeScript Deep dive - Type Guard</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/typescript.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;TS-7-Typescript’s-Type-System&quot;&gt;&lt;a href=&quot;#TS-7-Typescript’s-Type-System&quot; class=&quot;head
      
    
    </summary>
    
      <category term="TypeScript" scheme="https://jaeyeophan.github.io/categories/TypeScript/"/>
    
    
      <category term="ts" scheme="https://jaeyeophan.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>[TS] 6. Decorator</title>
    <link href="https://jaeyeophan.github.io/2018/01/09/TS-6-Decorator/"/>
    <id>https://jaeyeophan.github.io/2018/01/09/TS-6-Decorator/</id>
    <published>2018-01-09T00:59:14.000Z</published>
    <updated>2018-01-09T00:59:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/typescript.png" alt=""></p><h1 id="TS-6-Decorators"><a href="#TS-6-Decorators" class="headerlink" title="[TS] 6. Decorators"></a>[TS] 6. Decorators</h1><p>이번 포스팅에서는 현재 JavaScript에서도 <a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noopener">ts39/proposal stage-2</a>에 올라와있는 <code>Decorator</code>에 대해 알아보겠습니다.</p><h3 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h3><ul><li>Setup</li><li>Intro</li><li>Decorator to method</li><li>Decorator to class</li><li>Decorator with parameter</li></ul><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><p>자바스크립트 babel환경에서 데코레이터를 테스트해보기 위해서는 babel 플러그인이 추가적으로 필요합니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install babel-core babel-plugin-transform-decorators-legacy --save-dev</span><br></pre></td></tr></table></figure></p><p><code>babel-core</code>를 기본으로 하며, babel-plugin을 추가적으로 설치해줍니다.<br><figure class="highlight"><figcaption><span>.babelrc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  //...</span><br><span class="line">  "plugins": ["transform-decorators-legacy"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>해당 프로젝트의 babel설정을 담고 있는 <code>.babelrc</code>파일에 설치한 플러그인을 추가해줍니다. 보다 구체적인 해당 개발환경은 <a href="https://github.com/JaeYeopHan/esnext_labs" target="_blank" rel="noopener">여기</a>를 참고해주세요.</p><p>TyeScript에서는 <code>tsconfig.json</code>의 <code>compilerOption</code>을 다음과 같이 변경해줍니다.<br><figure class="highlight json"><figcaption><span>tsconfig.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"target"</span>: <span class="string">"ES5"</span>,</span><br><span class="line">        <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>TypeScript(JavaScript)에서 <code>@</code>이라는 character로 사용하는 문법을 <code>Decorator(데코레이터)</code>라고 합니다. 자바를 경험해보신 분이라면 <code>Annotation</code>인가? 라고 생각하기 쉬운데요, 조금 다릅니다. 데코레이터는 <strong>함수</strong> 라고 할 수 있습니다. 데코레이터는 말 그대로 코드 조각을 장식해주는 역할을 하며 타입스크립트에서는 그 기능을 함수로 구현할 수 있습니다.</p><p>Decorator는 클래스 선언, 메서드, 접근 제어자, 속성 또는 매개 변수에 첨부 할 수 있는 특별한 종류의 선언입니다. 데코레이터는 <code>@expression</code> 형식을 사용하는데, expression은 데코레이팅 된 선언에 대한 정보와 함께 존재하며 이는 <strong>런타임에</strong> 호출됩니다.</p><h4 id="참조-reference"><a href="#참조-reference" class="headerlink" title="참조(reference)"></a>참조(reference)</h4><p>데코레이터는 <code>@decorator</code>과 같이 사용할 수 있으며 <code>@[name]</code>의 형식일 때 <code>name</code>에 해당하는 이름의 함수를 참조하게 됩니다.</p><h4 id="실행-시점-execute-time"><a href="#실행-시점-execute-time" class="headerlink" title="실행 시점(execute time)"></a>실행 시점(execute time)</h4><p>이렇게 데코레이터로 정의된 함수는 데코레이터가 적용된 메소드가 실행되거나 클래스가 <code>new</code>라는 키워드를 통해 인스턴스화 될 때가 아닌 런타임 때 실행됩니다. 즉, 매번 실행되지 않습니다.</p><p><em>그럼 데코레이터가 메소드에 적용되는 경우, 클래스에 적용되는 경우, 프로퍼티에 적용되는 경우 이렇게 세 가지로 나누어 코드를 살펴보겠습니다.</em></p><p><br></p><h2 id="Decorator-to-Method"><a href="#Decorator-to-Method" class="headerlink" title="Decorator to Method"></a>Decorator to Method</h2><blockquote><p>메소드에 적용되는 경우</p></blockquote><p>우선 데코레이터로 사용할 <code>chaining</code>이라는 함수를 정의해줍니다.<br><figure class="highlight ts"><figcaption><span>decorator.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chaining</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(target); <span class="comment">// &#123;bark: f, constructor: f&#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// bark</span></span><br><span class="line">  <span class="built_in">console</span>.log(descriptor); <span class="comment">// &#123;value: f, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 함수는 추후 메소드에 <code>@chaining</code> 형식으로 사용될 함수입니다. <code>@</code>과 함께 함수가 호출되는 경우 받게 되는 파라미터는 다음과 같습니다.</p><blockquote><ul><li>target : 속성을 정의하고자 하는 객체</li><li>name : 속성의 이름</li><li>descriptor : 새로 정의하고자 하는 속성에 대한 설명</li></ul></blockquote><p>이는 <code>Object.defineProperty()</code>를 통해 이를 정의하고 있기 때문입니다.</p><p><code>target</code>은 해당 메소드가 속해있는 클래스 프로토타입을 가리키게 되며 <code>Pet</code>의 프로토타입에는 <code>constructor</code>와 <code>bark</code>메소드가 있는 것을 확인할 수 있습니다. <code>name</code>은 데코레이터가 적용된 메소드의 이름이 됩니다. <code>descriptor</code>는 <code>defineProperty</code>에서 정의할 수 있는 각각의 속성값들이 됩니다.</p><p>Object의 <code>defineProperty</code>에 해당하는 보다 자세한 내용은 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">여기</a>에서 살펴보실 수 있습니다. 그럼 각각을 활용해서 <code>chaining</code> 기능을 구현해보겠습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Decorator to method</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chaining</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fn: <span class="built_in">Function</span> = descriptor.value;</span><br><span class="line"></span><br><span class="line">  descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">    fn.apply(target, args);</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>descriptor의 <code>value</code>가 데코레이터가 적용된 함수, 즉 실행 대상이라고 할 수 있습니다. <code>descriptor.value</code>를 재정의(override)하기 전에 <code>fn</code>이라는 변수로 caching해둔 다음, 호출한 후의 일을 정의하기 위해 위와 같이 재정의 해줍니다. 재정의 하기 전 caching 해둔 함수를 호출하기 위해서 <code>apply</code> 함수를 사용했습니다. 어떠한 변수가 얼만큼 전달될지 모르니 rest parameter를 통해 <code>fn</code>을 호출해주는 코드입니다.</p><p>위와 같이 <code>descriptor.value</code>가 재정의 되면 <code>chaining</code>이 적용된 메소드는 재정의된대로 호출되게 됩니다.</p><blockquote><p><code>apply</code> 함수에 대한 내용은 <a href="https://www.google.co.kr/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwj9wKqt1cDYAhUBtpQKHQNvC34QFggmMAA&amp;url=https%3A%2F%2Fdeveloper.mozilla.org%2Fko%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fapply&amp;usg=AOvVaw2tqAzWzgnT49rXId1wsV11" target="_blank" rel="noopener">여기</a>를 참고해주세요.</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Pet &#123;</span><br><span class="line">  <span class="meta">@chaining</span></span><br><span class="line">  bark() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 적용해보겠습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pet = <span class="keyword">new</span> Pet();</span><br></pre></td></tr></table></figure></p><p><code>Pet</code>클래스에서 <code>bark</code>라는 메소드는 <code>Pet.prototype.bark</code>로 됩니다. class syntax 내부에서 위 코드에서는 <code>bark</code>라는 메소드가 <code>Pet</code>의 prototype의 프로퍼티로 추가되기 전에 <code>decorate</code> 함수가 실행되어 본래 <code>bark</code>라는 메소드에서 정의된 것에 추가적인 <strong>‘장식’</strong> 을 더해 prototype에 추가되도록 합니다.</p><blockquote><p>만약 compile target이 ES5보다 낮다면 <code>PropertyDescriptor</code> 값으로 <code>undefined</code>이 전달됩니다.</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pet.bark().bark();</span><br></pre></td></tr></table></figure><p>위 데코레이터의 효과로 <code>return this;</code>를 해주지 않아도 chaining 기능을 사용하여 메소드를 호출할 수 있습니다.</p><p><br></p><h2 id="Decorator-to-Class"><a href="#Decorator-to-Class" class="headerlink" title="Decorator to Class"></a>Decorator to Class</h2><p>하지만 데코레이터가 class에 적용되었을 때는 그 signature가 조금 달라집니다. 클래스 데코레이터는 클래스 선언 바로 전에 선언됩니다. 클래스 데코레이터는 클래스 생성자에 적용되며 클래스 정의를 관찰, 수정 또는 대체하는 데 사용할 수 있습니다.</p><p>클래스 데코레이터가 값을 반환하면 클래스 선언을 제공된 생성자 함수로 바꿉니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(target); <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(descriptor); <span class="comment">//undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>메소드에 데코레이터를 적용하듯이 데코레이터 함수를 선언하면 올바른 선언을 할 수 없습니다. 클래스에 적용되는 데코레이터 함수에 전달되는 인자는 <code>constructor</code>하나입니다. 제대로 된 데코레이터 선언은 다음과 같습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classDecorator</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123;<span class="keyword">new</span>(...args:<span class="built_in">any</span>[]):&#123;&#125;&#125;&gt;(<span class="keyword">constructor</span>:T) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="keyword">extends</span> <span class="keyword">constructor</span> &#123;</span><br><span class="line">    newProperty = <span class="string">"new property"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>클래스에 적용되는 데코레이터 함수 내에서 새로운 생성자 함수를 반환하면 원래 프로토타입을 유지해야 합니다. 런타임에 데코레이터를 적용하는 로직은 이를 수행하지 않기 때문입니다. 위 코드에서는 기존의 프로토타입을 유지하기 위해 적용되는 클래스의 <code>constructor</code>를 <code>extends</code> 합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classDecorator</span></span><br><span class="line"><span class="keyword">class</span> Pet &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pet = <span class="keyword">new</span> Pet(<span class="string">"async"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pet.newProperty); <span class="comment">// new Property</span></span><br></pre></td></tr></table></figure><p><code>classDecorator</code> 데코레이터가 적용된 <code>Pet</code> 클래스의 인스턴스에는 <code>newProperty</code>가 존재하지 않지만 데코레이터 함수에서 해당 클래스의 constructor를 재정의했기 대문에 <code>newProperty</code>에 접근할 수 있습니다.</p><p><br></p><h2 id="Decorator-with-parameter"><a href="#Decorator-with-parameter" class="headerlink" title="Decorator with parameter"></a>Decorator with parameter</h2><blockquote><p>파라미터를 받는 데코레이터</p></blockquote><p>데코레이터 함수에 인자를 넘겨줄 수 있습니다. 이 인자는 무엇이든 될 수 있습니다. 예제 코드로 descriptor의 <code>enumerable</code> 속성을 변경하는 데코레이터를 만들어보겠습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enumerableToFalse</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">  descriptor.enumerable = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이렇게 정의하면 <code>enumerableToFalse</code>이 적용된 메소드의 enumerable 속성은 false가 됩니다. 위 <code>enumerableToFalse</code> 함수를 한 번 감싸서 반환하는 함수를 만들면 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enumerable</span>(<span class="params">value: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">    descriptor.enumerable = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 이 함수를 데코레이터 함수로 사용할 수 있습니다. <code>value</code>에 해당하는 값으로 데코레이터를 적용하는 메소드의 <code>enumerable</code>속성을 제어할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Pet &#123;</span><br><span class="line">  <span class="meta">@enumerable</span>(<span class="literal">false</span>)</span><br><span class="line">  bark() &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 <code>false</code>라는 인자를 받는 데코레이터를 정의했습니다. 저 인자에는 함수도 들어갈 수 있으며 데코레이터도 들어갈 수 있습니다.</p><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>target을 ES5로 지정해야 제대로 된 데코레이터를 사용할 수 있어서 아직 한계가 있는 Decorator지만 React에서는 HOC(High-Order-Component)에 많이 사용하고 있는 Decorator 였습니다!</p><p>감사합니다.</p><p><em>6. Decorator in TypeScript end</em></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://www.typescriptlang.org/docs/handbook/generics.html" target="_blank" rel="noopener">TypeScript Official Document - Generics</a></li><li><a href="https://github.com/wycats/javascript-decorators" target="_blank" rel="noopener">https://github.com/wycats/javascript-decorators</a></li><li><a href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841" target="_blank" rel="noopener">https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841</a></li><li><a href="https://www.sitepoint.com/javascript-decorators-what-they-are/" target="_blank" rel="noopener">https://www.sitepoint.com/javascript-decorators-what-they-are/</a></li><li><a href="https://cabbageapps.com/fell-love-js-decorators/" target="_blank" rel="noopener">https://cabbageapps.com/fell-love-js-decorators/</a></li><li><a href="https://javarouka.github.io/blog/2016/09/30/decorator-exploring/#class-il-gyeongu" target="_blank" rel="noopener">https://javarouka.github.io/blog/2016/09/30/decorator-exploring/#class-il-gyeongu</a></li><li><a href="https://github.com/jayphelps/core-decorators" target="_blank" rel="noopener">https://github.com/jayphelps/core-decorators</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/typescript.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;TS-6-Decorators&quot;&gt;&lt;a href=&quot;#TS-6-Decorators&quot; class=&quot;headerlink&quot; title=&quot;[TS] 6. Decor
      
    
    </summary>
    
      <category term="TypeScript" scheme="https://jaeyeophan.github.io/categories/TypeScript/"/>
    
    
      <category term="ts" scheme="https://jaeyeophan.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>[번역] React를 본격적으로 하기 전 알면 좋은 6가지</title>
    <link href="https://jaeyeophan.github.io/2018/01/02/React-tips-for-beginners/"/>
    <id>https://jaeyeophan.github.io/2018/01/02/React-tips-for-beginners/</id>
    <published>2018-01-02T04:36:04.000Z</published>
    <updated>2018-01-03T01:50:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/react_special_1.png" alt=""></p><h1 id="I-wish-I-knew-these-before-diving-into-React"><a href="#I-wish-I-knew-these-before-diving-into-React" class="headerlink" title="I wish I knew these before diving into React"></a>I wish I knew these before diving into React</h1><p><em>해당 글은 원작자의 허가를 받고 번역한 글 입니다.</em><br><em>원본 링크 : <a href="https://engineering.opsgenie.com/i-wish-i-knew-these-before-diving-into-react-301e0ee2e488" target="_blank" rel="noopener">https://engineering.opsgenie.com/i-wish-i-knew-these-before-diving-into-react-301e0ee2e488</a></em></p><h3 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h3><ul><li>By default, setState triggers a re-render</li><li>setState updates the local state asynchronously</li><li>Component Lifecycle is important!</li><li>Use componentWillReceiveProps</li><li>Use React Developer Tools</li><li>Use CRA(Create React App)</li></ul><p><br></p><h2 id="1-By-default-setState-triggers-a-re-render"><a href="#1-By-default-setState-triggers-a-re-render" class="headerlink" title="1. By default, setState triggers a re-render"></a>1. By default, setState triggers a re-render</h2><blockquote><p>기본적으로 <code>setState</code> 메소드는 해당 컴포넌트의 재렌더링(re-render)을 발생시킨다.</p></blockquote><p>리액트의 기본 동작은 애플리케이션을 구성하고 있는 컴포넌트에서 발생하는 모든 변경사항에 대해서 다시 렌더링 하는 것이고 대부분의 경우 이 이러한 기본 동작에 맡겨도 정상적으로 동작합니다. 하지만 불필요한 re-render는 컴포넌트의 라이프 사이클 압장에서 봤을 때, Best practice일 수 없습니다.</p><p>각각의 컴포넌트들은 <code>shouldComponentUpdate</code>라는 메소드를 가지고 있고 이것은 <code>state</code>가 변경되거나 부모 컴포넌트로부터 새로운 <code>props</code>를 전달받을 때 실행됩니다. React는 이 메소드(<code>shouldComponentUpdate</code>)의 반환 값에 따라서 re-render를 할지에 대한 여부를 결정하게 됩니다.</p><p>기본적으로 <code>shouldComponentUpdate</code> 메소드는 <code>true</code>를 반환합니다. 하지만 React 개발자는 re-render를 원하지 않는 경우에, 이 return value를 <code>false</code>로 오버라이드 할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="keyword">const</span> vitalPropsChange = <span class="keyword">this</span>.props.bar !== nextProps.bar;</span><br><span class="line">    <span class="keyword">const</span> vitalStateChange = <span class="keyword">this</span>.state.foo !== nextState.foo;    </span><br><span class="line">    <span class="keyword">return</span> vitalPropsChange || vitalStateChange;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// React will not re-render the component unless vitalPropsChange</span></span><br><span class="line"><span class="comment">// or vitalStateChange is true.</span></span><br></pre></td></tr></table></figure><h3 id="important-notes"><a href="#important-notes" class="headerlink" title="important notes:"></a>important notes:</h3><ol><li><code>shouldComponentUpdate</code>를 잘못 설정하거나 이러한 설정을 잊어 버리면 구성 요소가 예상대로 업데이트되지 않아 애플리케이션에 문제가 발생할 수 있습니다.</li><li><code>shouldComponentUpdate</code>에서 계산을 실행하는 것은 성능과 노력면에서 비용이 많이들 수 있으므로 그만한 가치가 있는지 확인해야합니다. <a href="https://reactjs.org/docs/perf.html" target="_blank" rel="noopener">React ‘s Performance Tools</a>를 사용하여 <code>shouldComponentUpdate</code> 사용 전후에 낭비되는 사이클 수를 확인하는 것이 좋습니다. 아주 간단한 사용법이 있습니다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Perf.start() </span><br><span class="line"><span class="comment">// React operations in-between are recorded for analyses.</span></span><br><span class="line">Perf.stop()</span><br><span class="line">Perf.printWasted()</span><br></pre></td></tr></table></figure></li></ol><p><br></p><h2 id="2-setState-updates-the-local-state-asynchronously"><a href="#2-setState-updates-the-local-state-asynchronously" class="headerlink" title="2. setState updates the local state asynchronously"></a>2. setState updates the local state asynchronously</h2><blockquote><p><code>setState</code> 메소드는 <strong>비동기</strong>로 state를 업데이트 한다.</p></blockquote><p><code>setState</code>메소드는 즉시 실행되는, 동기적으로 실행되는 것이 아니라 하나의 <strong>요청</strong>이라고 생각해야 합니다. 즉, <code>setState</code>를 통해 상태를 변경하더라도 해당 메소드가 실행된 직후에 변경된 상태가 적용되는 것이 아닙니다.</p><p><code>setState</code>를 호출한 직후에 <code>this.state</code>에 접근하는 것은 흔한 실수 입니다. 일반적으로, <code>setState</code> 메소드 내에서 <code>this.state</code>를 사용하는 것은 신뢰할 수 없습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this.state.value is initially 0</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</span><br><span class="line"><span class="comment">// this.state.value is 1 instead of 3</span></span><br></pre></td></tr></table></figure></p><p>만약 이전의 상태에 기반하여 상태를 변경해야 한다면 가장 좋은 방법 중 하나는 <code>updater</code> 함수를 사용하는 것입니다. <code>updater</code>함수를 <code>setState</code> 메소드의 첫번째 인자로 넘기는 방식으로 사용할 수 있습니다. ( <code>setState(updater, [callback])</code> ) 예제 코드입니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123;<span class="attr">value</span>: prevState.value + <span class="number">1</span>&#125;));</span><br></pre></td></tr></table></figure></p><p>여기서 <code>[callback]</code>은 optional argument로 <code>setState</code>의 실행이 완료된 후 실행되며 해당 <code>callback</code>이 실행된 후에 해당 컴포넌트의 re-render가 이루어집니다. <code>updater</code>에 대한 보다 자세한 내용은 다음 <a href="https://reactjs.org/docs/react-component.html#setstate" target="_blank" rel="noopener">링크</a>를 참고하세요.</p><p><br></p><h2 id="3-Component-Lifecycle-is-important"><a href="#3-Component-Lifecycle-is-important" class="headerlink" title="3. Component Lifecycle is important!"></a>3. Component Lifecycle is important!</h2><blockquote><p>컴포넌트의 라이프 사이클이 중요하다!</p></blockquote><p>React를 이해하는데 있어서 가장 첫번째로 이해해야 하는 부분이 바로 <strong>Component life cycle</strong>입니다. 각각의 React 컴포넌트는 component의 life cycle 안에서 특정 시간에 호출할 수 있는 메소드들을 내장하고 있습니다. 이 컴포넌트 내장 메소드들을 올바르게 사용하기 위해서는 해당 메소드들이 실행되는 순서를 이해해야만 합니다. 이 라이프 사이클을 세 부분으로 나눌 수 있습니다.</p><h3 id="Mounting"><a href="#Mounting" class="headerlink" title="Mounting"></a>Mounting</h3><p>React 컴포넌트의 인스턴스가 생성되고 DOM에 삽입되는 과정의 life cycle 입니다.</p><ol><li>constructor</li><li>componentWillMount</li><li>render</li><li>componentDidMount</li></ol><h3 id="Updating"><a href="#Updating" class="headerlink" title="Updating"></a>Updating</h3><p><code>prop</code> 또는 <code>state</code>의 변경으로 해당 컴포넌트가 re-render 되는 경우의 life cycle 입니다.</p><h4 id="Props-Change"><a href="#Props-Change" class="headerlink" title="Props Change"></a>Props Change</h4><ol><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>render</li><li>componentDidUpdate</li></ol><h4 id="State-Change"><a href="#State-Change" class="headerlink" title="State Change"></a>State Change</h4><ol><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>render</li><li>componentDidUpdate</li></ol><h3 id="Unmounting"><a href="#Unmounting" class="headerlink" title="Unmounting"></a>Unmounting</h3><ul><li>componentWillUnmount</li></ul><h3 id="Life-Cycle과-관련된-좋은-Article"><a href="#Life-Cycle과-관련된-좋은-Article" class="headerlink" title="Life Cycle과 관련된 좋은 Article"></a>Life Cycle과 관련된 좋은 Article</h3><ul><li>React Lifecycle Methods - how and when to use them<ul><li><a href="https://jaeyeophan.github.io/2018/01/01/React-4-Component-Life-Cycle/">번역 링크</a></li><li><a href="https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1" target="_blank" rel="noopener">원본 링크</a></li></ul></li><li><a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener">React Official Document</a></li></ul><p><br></p><h2 id="4-Use-componentWillReceiveProps"><a href="#4-Use-componentWillReceiveProps" class="headerlink" title="4. Use componentWillReceiveProps"></a>4. Use componentWillReceiveProps</h2><blockquote><p><code>componentWillReceiveProps</code> 메소드를 사용해라.</p></blockquote><p>만약 <code>props</code>의 변경에 따라서 상태를 변경해야 한다면, 이 <code>componentWillReceiveProps</code> 메소드가 필요합니다. <code>this.props</code>와 <code>nextProps</code>를 비교해서 중요한 변화(significant change)가 있다면 해당 메소드를 실행합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.foo !== nextProps.foo) &#123;</span><br><span class="line">    <span class="keyword">this</span>.whenFooChanges();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.porps.bar !== nextProps.bar) &#123;</span><br><span class="line">    <span class="keyword">this</span>.whenBarChanges();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Two-important-notes"><a href="#Two-important-notes" class="headerlink" title="Two important notes:"></a>Two important notes:</h3><ol><li><code>props</code>가 변경되지 않아도 <code>componentWillReceiveProps</code>는 실행하기 때문에 <code>this.props</code>와 <code>nextProps</code>를 비교하는 것이 중요합니다.</li><li><code>componentWillReceiveProps</code>은 해당 컴포넌트가 <strong>mounted</strong> 되기 전에 실행되어 새로운 <code>props</code>를 받습니다. 이것은 React가 mount 중에는 초기 props에 대해 <code>componentWillReceiveProps</code>를 호출하지 않는다는 것을 의미합니다.</li></ol><h3 id="추가-내용"><a href="#추가-내용" class="headerlink" title="추가 내용"></a>추가 내용</h3><p>React version 16에서 <code>componentWillReceiveProps</code>를 사용하여 상태를 변경할 때는 <strong>동기적으로</strong> 업데이트 해야 합니다.(dispatch request 또는 <code>setTimeout</code>과 같은 비동기적 요청은 해당 메소드에서 처리하면 안 됩니다.)<br><strong>React Fiber</strong> 를 사용하면 라이프 사이클이 진행되기 전에 <code>componentWill[*]</code> 메서드가 여러 번 호출 될 수 있습니다. <code>props</code>이 변경될 때 상태를 비동기적으로 업데이트하려면 <code>componentDidUpdate</code>를 사용해야 합니다.</p><p><br></p><h2 id="5-Use-React-Developer-Tools"><a href="#5-Use-React-Developer-Tools" class="headerlink" title="5. Use React Developer Tools"></a>5. Use React Developer Tools</h2><blockquote><p>각종 React 개발자 도구를 사용해라.</p></blockquote><p>React Developer Tools를 사용하면 애플리케이션을 구성하고 있는 React 컴포넌트의 계층, 컴포넌트의 <code>props</code> 및 <code>state</code>를 검사 할 수 있습니다. React는 모두 컴포넌트에 관한 것이기 때문에 많은 경우, 매우 유용합니다. 브라우저 확장 프로그램 (<a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi" target="_blank" rel="noopener">Chrome용</a> 및 <a href="https://addons.mozilla.org/ko/firefox/addon/react-devtools/" target="_blank" rel="noopener">Firefox 용</a>)과 <a href="https://github.com/facebook/react-devtools/tree/master/packages/react-devtools" target="_blank" rel="noopener">독립 실행 형 앱</a>으로 존재합니다.</p><p><br></p><h2 id="6-Use-CRA-Create-React-App"><a href="#6-Use-CRA-Create-React-App" class="headerlink" title="6. Use CRA(Create React App)"></a>6. Use CRA(Create React App)</h2><blockquote><p>CRA를 사용해라.</p></blockquote><p>Facebook의 <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a>을 사용하면 빌드 구성없이 React 앱을 만들 수 있습니다. CRA는 사용하기가 매우 쉽고 잘 갖춰진 documentation을 가지고 있습니다. Node&gt; = 6 만 있으면 되며 macOS, Windows 및 Linux에서 작동합니다. 개발 생산성을 높여주는 HRM도 해당 scaffolding 모듈에서 지원하고 있습니다. (개인적으로는 글로벌로 설치해도 아쉽지 않은 녀석입니다!)</p><p><br></p><h3 id="역자-덧붙임"><a href="#역자-덧붙임" class="headerlink" title="역자 덧붙임"></a>역자 덧붙임</h3><p>좋은 참고자료를 첨부합니다.</p><ul><li><a href="https://github.com/reactkr/learn-react-in-korean" target="_blank" rel="noopener">한국어로 배우는 리액트</a></li><li><a href="https://github.com/Microsoft/TypeScript-React-Starter" target="_blank" rel="noopener">TypeScript-React-Stater</a></li><li><a href="https://github.com/chantastic/reactpatterns.com" target="_blank" rel="noopener">react-patterns (영어)</a></li></ul><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>일부 의역이 들어갔으며 오역이 존재할 수 있습니다. 해당 사항에 대해서는 댓글로 피드백 주시면 감사하겠습니다. 더 좋은 포스팅으로 뵙겠습니다! 감사합니다.</p><p><em>해당 글은 원작자의 허가를 받고 번역한 글 입니다.</em><br><em>원본 링크 : <a href="https://engineering.opsgenie.com/i-wish-i-knew-these-before-diving-into-react-301e0ee2e488" target="_blank" rel="noopener">https://engineering.opsgenie.com/i-wish-i-knew-these-before-diving-into-react-301e0ee2e488</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/react_special_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;I-wish-I-knew-these-before-diving-into-React&quot;&gt;&lt;a href=&quot;#I-wish-I-knew-these-be
      
    
    </summary>
    
      <category term="React" scheme="https://jaeyeophan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://jaeyeophan.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>[React] 4. Component Life Cycle</title>
    <link href="https://jaeyeophan.github.io/2018/01/01/React-4-Component-Life-Cycle/"/>
    <id>https://jaeyeophan.github.io/2018/01/01/React-4-Component-Life-Cycle/</id>
    <published>2018-01-01T08:08:03.000Z</published>
    <updated>2018-01-15T09:37:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/react_logo.png" alt=""></p><h1 id="React-Lifecycle-Methods-how-and-when-to-use-them"><a href="#React-Lifecycle-Methods-how-and-when-to-use-them" class="headerlink" title="React Lifecycle Methods - how and when to use them"></a>React Lifecycle Methods - how and when to use them</h1><p><em>해당 글은 원작자의 허가를 받고 번역한 글 입니다.</em><br><em>원본 링크 : <a href="https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1" target="_blank" rel="noopener">https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1</a></em></p><h3 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h3><ul><li>Intro</li><li>React Component Life Cycle<ul><li>componentWillMount</li><li>componentDidMount</li><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>componentDidUpdate</li><li>componentWillUnmount</li></ul></li></ul><p><br></p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p><img src="/images/react_component_life_cycle.png" alt=""></p><p>위 다이어그램은 React 컴포넌트의 출생(pre-mounting)과 사망 (unmounting)에서의 Life Cycle입니다. React의 장점은 복잡한 UI를 작은 크기로 나누는 것입니다. 따라서 앱을 각각의 컴포넌트 단위로 분류 할 수 있을 뿐만 아니라 각 컴포넌트에 대해 customize 할 수 있습니다.</p><p>React Component의 라이프 사이클 메소드를 통해 UI의 각 컴포넌트가 <strong>렌더링(rendering)</strong>, <strong>업데이트(update)</strong>, <strong>재렌더링(re-rendering)</strong> 될 때를 고려할 수 있으며 <strong>완전히 사라질 때(unmount)</strong> 일어나는 일을 제어 할 수 있습니다.</p><p><br></p><h2 id="React-Component-Life-Cycle"><a href="#React-Component-Life-Cycle" class="headerlink" title="React Component Life Cycle"></a>React Component Life Cycle</h2><p>React 컴포넌트의 생명 주기를 부분적으로 나누어 간단히 살펴보면 다음과 같습니다.</p><h3 id="Mounting"><a href="#Mounting" class="headerlink" title="Mounting"></a>Mounting</h3><p>React 컴포넌트의 인스턴스가 생성되고 DOM에 삽입되는 과정의 life cycle 입니다.</p><ol><li>constructor</li><li>componentWillMount</li><li>render</li><li>componentDidMount</li></ol><h3 id="Updating"><a href="#Updating" class="headerlink" title="Updating"></a>Updating</h3><p><code>prop</code> 또는 <code>state</code>의 변경으로 해당 컴포넌트가 re-render 되는 경우의 life cycle 입니다.</p><h4 id="Props-Change"><a href="#Props-Change" class="headerlink" title="Props Change"></a>Props Change</h4><ol><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>render</li><li>componentDidUpdate</li></ol><h4 id="State-Change"><a href="#State-Change" class="headerlink" title="State Change"></a>State Change</h4><ol><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>render</li><li>componentDidUpdate</li></ol><h3 id="Unmounting"><a href="#Unmounting" class="headerlink" title="Unmounting"></a>Unmounting</h3><ul><li>componentWillUnmount</li></ul><p>이제 각각에 대해서 살펴봅시다.</p><p><br></p><h2 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a><code>componentWillMount</code></h2><p>개발자가 정의한 컴포넌트는 눈 깜짝할 사이에 화면에 그려집니다. 이 순간 무엇을 할 수 있을까요? 그에 대한 대답은 사실 할 수 있는 것이 별로 없습니다. <code>componentWillMount</code> 메소드는 딱히 쓸모가 없습니다.</p><p><code>componentWillMount</code>에서는 아직 생성된 컴포넌트가 없으므로 DOM 관련 작업을 수행 할 수 없습니다. 또한 컴포넌트의 기본 구성(<code>props</code> or <code>state</code>)을 설정하는 생성자(constructor)가 호출된 이후에는 아무 것도 변경되지 않았습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Sidebar</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  tooltipsEnabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      analyticsOpen: <span class="literal">false</span>,</span><br><span class="line">      requirementsOpen: <span class="literal">false</span>,</span><br><span class="line">      brandInfoOpen: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>생성자가 호출되고 나면 그 상태가 바로 컴포넌트의 초기 상태가 됩니다. 추가적인 라이프 사이클 메소드를 복잡하게 사용하지 않고도 거의 모든 것이 컴포넌트 코드의 나머지 부분에서 처리되어야 합니다. 그 중에서도 예외가 있다면 초기에만 수행할 수있는 설정 즉, 외부 API에 연결하는 작업이 있을 것입니다. 예를 들어, 앱에 Firebase를 사용한다면, 앱이 처음 설치 될 때 설정을 가져와야합니다. 그러나 여기서 핵심은 이러한 작업은 앱의 최상위 컴포넌트 (루트 컴포넌트)에서 수행되어야 한다는 것입니다.</p><p>이는 컴포넌트의 99 %가 <code>componentWillMount</code>를 사용하지 않아야 함을 의미합니다. <code>componentWillMount</code>를 사용하여 컴포넌트에 대한 데이터를 로드하기 위해 AJAX 호출을 시작하는 사람들을 볼 수 있습니다. 하지만 이 글을 읽는 당신은 이러지 않았으면 좋겠습니다. 바로 다음 section인 두번째 section에서 이 부분에 대해 이야기하겠습니다.</p><h4 id="이-메소드의-가장-일반적인-사용-사례"><a href="#이-메소드의-가장-일반적인-사용-사례" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul><li>루트 컴포넌트에서 App과 관련된 외부 API를 설정할 떄.</li><li>setState 호출(?) : <code>setState</code>도 호출하지 말고 constructor에서 설정한 <code>this.state</code>를 사용하세요.</li></ul><p><br></p><h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a><code>componentDidMount</code></h2><p>이제 컴포넌트가 mount되고 사용할 준비가 되었습니다.</p><p><code>componentDidMount</code>는 가지고 놀 컴포넌트가 없을 때 할 수 없었던 것들을 모두 할 수 있는 메소드입니다. 몇 가지 예를 들면 다음과 같습니다.</p><ul><li><code>&lt;canvas&gt;</code> 에 렌더링을 수행한다.</li><li>요소 컬렉션에서 <a href="https://masonry.desandro.com/" target="_blank" rel="noopener">Masonry</a> 그리드 레이아웃을 초기화한다.</li><li>Event listener를 추가한다.</li></ul><p>기본적으로 여기에서는 DOM에 대한 접근이 필요한 모든 설정을 수행하고 필요한 데이터를 가져오기 시작합니다.</p><h4 id="이-메소드의-가장-일반적인-사용-사례-1"><a href="#이-메소드의-가장-일반적인-사용-사례-1" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul><li>Ajax 호출을 시작하여 컴포넌트에서 사용해야 하는 데이터를 로드합니다.</li><li>setState를 호출할 수 있습니다.</li></ul><p><br></p><h2 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a><code>componentWillReceiveProps</code></h2><p>컴포넌트가 정상적으로 잘 동작하고 있었는데 새로운 <code>props</code>가 전달되었습니다. 아마 상위 컴포넌트에서 <code>componentDidMount</code>에 의해 로드된 데이터 중 일부가 내려왔을 것입니다.</p><p>새로운 <code>props</code>로 어떠한 작업을 수행하기 전 이 새로운 <code>props</code>를 인자로 하여 <code>componentWillReceiveProps</code>가 호출됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">parseInt</span>(nextProps.id, <span class="number">10</span>) !== <span class="built_in">parseInt</span>(<span class="keyword">this</span>.props.id, <span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">postsLoaded</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">    <span class="keyword">this</span>.contentLoaded = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우리는 이 메소드 안에서 <code>nextProps</code>를 통해 다음의 <code>props</code>(새로운 <code>props</code>)에 접근할 수 있고 <code>this.props</code>를 통해 현재의 <code>props</code>에 접근할 수 있습니다.</p><p>이 메소드에서 우리 해야하는 것은 다음과 같습니다.</p><ol><li>props가 바뀌었는지 확인합니다. 가끔 <code>props</code>가 변경되지 않은 경우에도 호출됩니다.</li><li>만약 <code>props</code>가 변경되었다면 그에 따라 로직을 구성해야 한다.</li></ol><p>새로운 <code>props</code>를 받았을 때, 다음과 같이 처리합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.percent !== nextProps.percent) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setUpPercent(nextProps.percent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>하나 더 주의해야 할 것은 <code>componentWillReceiveProps</code>는 초기 렌더링시 호출되지 않습니다. 코드 상으로는 컴포넌트가 <code>props</code>를 받는다는 것을 의미하지만 비교할 기존의 <code>props</code>가 없으므로 로직에 포함되지 않습니다.</p><h4 id="이-메소드의-가장-일반적인-사용-사례-2"><a href="#이-메소드의-가장-일반적인-사용-사례-2" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul><li>해당 컴포넌트의 상태 변경에 영향을 끼지는 <code>props</code>의 변경에 따라 로직을 구성합니다.</li><li>setState를 호출할 수 있습니다.</li></ul><p><br></p><h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a><code>shouldComponentUpdate</code></h2><p>컴포넌트가 불안정한(?) 상태입니다. 이 메소드가 호출되었다는 것은 현재 컴포넌트의 상태와 view에 그려진 내용, 상태가 다르다는 것을 의미하기 때문입니다.</p><p>우리에게는 새로운 <code>props</code>가 있습니다. 전형적인 React 신조에 따르면 컴포넌트가 새로운 <code>props</code>나 새로운 <code>state</code>를 받으면 업데이트해야 한다고 말합니다.</p><p><code>shouldComponentUpdate</code> 메소드는 <code>nextProps</code>를 첫 번째 인수로 사용하고 <code>nextState</code>는 두 번째 인수로 사용합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.props.engagement !== nextProps.engagement</span><br><span class="line">    || nextState.input !== <span class="keyword">this</span>.state.input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>shouldComponentUpdate</code>는 항상 <code>boolean</code>을 반환해야 합니다. 이것은 “해당 컴포넌트를 다시 렌더링(re-render)해야 하나요?”라는 질문에 대한 답이 됩니다. 해당 컴포넌트를 특별히 override하지 않는 이상 이 메소드는 기본적으로 <code>true</code>를 반환합니다.</p><p>하지만 불필요한 재렌더링(re-render)를 방지하기 위해서는 <code>shouldComponentUpdate</code>를 override 할 수 있습니다. 자세한 내용은 다음 <a href="https://engineering.musefind.com/how-to-benchmark-react-components-the-quick-and-dirty-guide-f595baf1014c" target="_blank" rel="noopener">링크</a>를 참고해주세요. (이 링크에서는 많은 필드가 있는 테이블에서 테이블이 다시 렌더링 될 때 각 필드가 다시 렌더링되어 작업속도가 느려지게 된다는 것을 보여주고 있습니다.)</p><p><code>shouldComponentupdate</code>를 사용하면 변화에 신경써야 하는 <code>props</code>의 변경에 대해서만 update를 진행할 수 있습니다. 하지만 이에 대한 설정을 잊으면 React 컴포넌트가 제대로 동작하지 않기 때문에 명심해야 합니다.</p><h4 id="이-메소드의-가장-일반적인-사용-사례-3"><a href="#이-메소드의-가장-일반적인-사용-사례-3" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul><li>해당 컴포넌트의 re-render를 제어할 때 사용합니다.</li><li>setState를 호출할 수 없습니다.</li></ul><p><br></p><h2 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a><code>componentWillUpdate</code></h2><p>방금 전까지 컴포넌트를 update하는데 집중을 했는데요, 이 메소드에서는 update가 발생하기 전 어떠한 작업이 필요한 경우 해당 메소드 안에서 해결할 수 있습니다.<br>이 메소드는 메소드 내에서 <code>this.setState</code>를 호출할 수 없다는 점을 제외하면 기본적으로 <code>componentWillReceiveProps</code>와 동일합니다.</p><p>이미 <code>shouldComponentUpdate</code>를 사용 중인데 또 <code>props</code>가 변경될 때 작업이 필요한 경우 이 메소드가 적절하겠지만 추가적인 유용성은 많이 주지는 못할 것입니다.</p><h4 id="이-메소드의-가장-일반적인-사용-사례-4"><a href="#이-메소드의-가장-일반적인-사용-사례-4" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul><li><code>shouldComponentUpdate</code>가 이미 사용되고 있는 컴포넌트에서 <code>componentWillReceiveProps</code> 대신 사용됩니다. 단 해당 메소드 내에서는 이전 <code>props</code>에 접근할 수 없습니다.</li><li>setState를 호출할 수 없습니다.</li></ul><p><br></p><h2 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a><code>componentDidUpdate</code></h2><p>이 메소드에서는 <code>componentDidMount</code>에서 했던 것과 동일한 작업을 수행할 수 있습니다. (예를 들면, 레이아웃을 다시 설정한다던가 canvas를 그린다던가) </p><p><code>shouldComponentUpdate</code>가 호출된 다음, <code>render</code>가 호출된 다음 호출되는 메소드입니다. 하지만 아쉽게도 이 메소드 내에서는 어떠한 이유로 update가 이루어졌는지 알 수 없습니다. 그렇기 때문에 변경된 데이터에 대해 DOM조작을 다시 해줘야하는 경우가 있다면 이 메소드에서 수행해줄 수 있습니다.</p><p><code>componentWillReceiveProps</code>에서도 충분히 해줄 수 있는 작업들이지만 불필요한 re-render를 방지하기 위해 DOM과 관련된 작업들을 주로 수행합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate() &#123;</span><br><span class="line">  <span class="keyword">this</span>.createGrid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="이-메소드의-가장-일반적인-사용-사례-5"><a href="#이-메소드의-가장-일반적인-사용-사례-5" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul><li><code>prop</code> 또는 <code>state</code>에 따라서 DOM을 업데이트 합니다.</li><li>setState를 호출할 수 있습니다.</li></ul><p><br></p><h2 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a><code>componentWillUnmount</code></h2><p>컴포넌트가 unmount 되기 전 호출되는 메소드로 마지막으로 수행해야하는 작업이 있다면 이 메소드에서 수행해줄 수 있습니다. 여기서는 네트워크 요청을 취소하거나 컴포넌트와 관련된 모든 이벤트 리스터를 제거할 수 있습니다. 기본적으로 해당 컴포넌트와 관련있는 작업들만 수행합니다.</p><h4 id="이-메소드의-가장-일반적인-사용-사례-6"><a href="#이-메소드의-가장-일반적인-사용-사례-6" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul><li>컴포넌트와 관련된 것들을 제거하는 메소드입니다.</li><li>setState를 호출할 수 없습니다.</li></ul><p><br></p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>이상적인 애플리케이션에서는 life cycle 에 접근할 필요가 없습니다. 렌더링과 관련된 거의 모든 이슈는 <code>state</code>와 <code>props</code>만을 통해 제어될 수 있습니다. 하지만 몇몇의 경우, 컴포넌트의 업데이트 방법과 그 순간 순간에 대해 좀 더 명확히 제어할 필요가 있습니다. 때문에 life cycle에 접근하여 컴포넌트를 제어하는 것이 필요하다면 이상적인 동작에 영향이 끼치지 않도록 조심스럽게 사용해야 합니다.</p><p><br></p><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>일부 의역이 들어갔으며 오역이 존재할 수 있습니다. 해당 사항에 대해서는 댓글로 피드백 주시면 감사하겠습니다. 더 좋은 포스팅으로 뵙겠습니다! 감사합니다.</p><p><em>해당 글은 원작자의 허가를 받고 번역한 글 입니다.</em><br><em>원본 링크 : <a href="https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1" target="_blank" rel="noopener">https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/react_logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;React-Lifecycle-Methods-how-and-when-to-use-them&quot;&gt;&lt;a href=&quot;#React-Lifecycle-Methods
      
    
    </summary>
    
      <category term="React" scheme="https://jaeyeophan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://jaeyeophan.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>[TS] 5. Generics in TypeScript</title>
    <link href="https://jaeyeophan.github.io/2017/12/30/TS-5-Generics-in-TypeScript/"/>
    <id>https://jaeyeophan.github.io/2017/12/30/TS-5-Generics-in-TypeScript/</id>
    <published>2017-12-30T07:11:41.000Z</published>
    <updated>2017-12-30T07:12:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/typescript.png" alt=""></p><h1 id="TS-5-Generics-in-TypeScript"><a href="#TS-5-Generics-in-TypeScript" class="headerlink" title="[TS] 5. Generics in TypeScript"></a>[TS] 5. Generics in TypeScript</h1><p><code>Generics</code>는 자바스크립트 개발자에게 친숙하지 않은 용어일꺼라고 생각됩니다. 하지만 정적 타이핑에 있어서 큰 부분을 차지하고 있는 Generics syntax에 대해 알아봅니다.</p><h4 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h4><ul><li>Generics?</li><li>Generics to Class</li><li>Generics to Function</li></ul><p><br></p><h2 id="Generics"><a href="#Generics" class="headerlink" title="Generics?"></a>Generics?</h2><p>이전에 다뤘던 인터페이스가 어떠한 ‘틀’을 지정하여 함수 또는 클래스를 정의했다면, 제네릭을 통하여 함수 또는 클래스에 ‘틀’을 ‘주입’하여 그 확장성을 보다 높일 수 있습니다. 즉, 제네릭의 목적은 재사용성(reusable)을 높이고 함수나 클래스의 확장성을 높여 중복된 코드를 방지하기 위함이라고 할 수 있습니다.</p><p><br></p><h2 id="Generics-to-Class"><a href="#Generics-to-Class" class="headerlink" title="Generics to Class"></a>Generics to Class</h2><p>어떠한 장바구니(Basket)에 물건(Item)을 넣어야 한다고 가정을 해봅시다. 이 때, 하나의 장바구니에는 모두 동일한 타입의 물건이 들어있어야 합니다. 이 경우 모든 경우의 수에 해당하는 장바구니를 각각의 클래스로 만들어줘야 하는 문제점이 발생합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BookBasket &#123; ... &#125;</span><br><span class="line"><span class="keyword">class</span> CupBasket &#123; ... &#125;</span><br><span class="line"><span class="keyword">class</span> DollBasket &#123; ... &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></p><p>이럴 경우, 제네릭을 사용하여 하나의 클래스에서 타입을 <strong>주입받아</strong> 모든 경우의 수에 해당하는 장바구니를 만들 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Basket&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> item: T[];</span><br><span class="line"></span><br><span class="line">  getItem(index: <span class="built_in">number</span>): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.item[index];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>아주 간단한 <code>Basket</code>클래스를 만들어 보았습니다. 일반 클래스를 정의할 때와는 다르게 <code>&lt;T&gt;</code>라는 것이 클래스 이름 옆에 추가된 것을 확인하실 수 있는데요, 해당 클래스 내에서 사용할 타입을 <code>T</code>라는 값으로 받을 수 있게 되는 것입니다. 여기서 <code>T</code>는 별 뜻이 있는게 아니라 Type의 약자입니다. 이렇게 정의한 클래스를 이용하여 여러 경우에 해당하는 장바구니를 생성할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bookBasket = <span class="keyword">new</span> Basket&lt;Book&gt;();</span><br><span class="line"><span class="keyword">const</span> cupBasket = <span class="keyword">new</span> Basket&lt;Cup&gt;();</span><br><span class="line"><span class="keyword">const</span> dollBasket = <span class="keyword">new</span> Basket&lt;Doll&gt;();</span><br></pre></td></tr></table></figure></p><p><code>new</code> 키워드를 통해 인스턴스를 생성할 때 정의할 때와 마찬가지로 <code>&lt;&gt;</code>와 함께 타입을 지정하여 인스턴스를 생성해줍니다. (<code>Book</code>, <code>Cup</code>, <code>Doll</code>에 대한 인터페이스 정의는 생략합니다.)</p><p><br></p><h2 id="Generics-to-Function"><a href="#Generics-to-Function" class="headerlink" title="Generics to Function"></a>Generics to Function</h2><p>제네릭스는 클래스 뿐만 아니라 함수에도 적용될 수 있는데요, 이전에 살펴보았던 AjaxUtils를 예제로 제네릭에 대해 알아보겠습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params">param: fetchDataParam</span>): <span class="title">Promise</span>&lt;<span class="title">DataFormat</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 함수는 <code>fetchDataParam</code>이라는 타입의 인자만 받을 수 있으며 <code>Promise&lt;DataFormat&gt;</code>이라는 타입의 반환만 할 수 있게 설계되어 있습니다. 그러나 함수의 body가 여러 곳에서 중복된다면 <code>fetchDataParam</code> 또는 <code>DataFormat</code>을 위 함수에 주입하여 여러 상황에 대응할 수 있는 함수로 변환시킬 수 있습니다. 이 때, 제네릭이 사용됩니다.</p><p>위 함수에 제네릭을 적용하여 함수의 재사용성을 높여보겠습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchDataOf</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">param: T</span>): <span class="title">Promise</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">`<span class="subst">$&#123;param&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>arrow function에도 마찬가지로 적용할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchDataOf = <span class="keyword">async</span> &lt;T, U&gt;(param: T): <span class="built_in">Promise</span>&lt;U&gt; =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">`<span class="subst">$&#123;param&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이렇게 정의를 하면 다음과 같이 호출할 수 있습니다. 여기서 T와 U는 그냥 type의 종류를 나타내는 character라고 생각하시면 됩니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data: DataFormat = <span class="keyword">await</span> fetchDataOf&lt;<span class="built_in">string</span>, DataFormat&gt;(baseUrl);</span><br></pre></td></tr></table></figure><p><code>param</code>으로 넘겨주게 되는 인자의 타입이 다르거나, 반환하게 되는 값의 타입이 다를 경우에도 <code>&lt;&gt;</code>에 해당 타입을 지정하여 하나의 함수를 사용할 수 있게 됩니다.</p><p>물론 <any>의 형식으로도 사용할 수 있지만(이럴바에 차라리 자바스크립트를 사용하는 것이 생산성 측면에서 더 좋을 것 같습니다.) 특정 타입을 받아 해당 타입으로 반환한다는 측면에 있어서 안정성과 확장성 두 마리 토끼를 모두 잡을 수 있습니다.</any></p><p><br></p><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>실제 개발해서보다는 라이브러리를 개발할 때 많이 사용할 수 있는 Generics에 대해 알아봤습니다. 해당 포스팅 외 다른 타입스크립트 포스팅은 <a href="https://github.com/JaeYeopHan/typescript_tutorial_docs" target="_blank" rel="noopener">여기</a>에서 보실 수 있으며 예제에 사용된 코드는 <a href="https://github.com/JaeYeopHan/typescript_playground" target="_blank" rel="noopener">여기</a>에서 확인하실 수 있습니다.<br>감사합니다.</p><p><em>5. Generic in TypeScript end</em></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.typescriptlang.org/docs/handbook/generics.html" target="_blank" rel="noopener">TypeScript Official Document - Generics</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/typescript.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;TS-5-Generics-in-TypeScript&quot;&gt;&lt;a href=&quot;#TS-5-Generics-in-TypeScript&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="TypeScript" scheme="https://jaeyeophan.github.io/categories/TypeScript/"/>
    
    
      <category term="ts" scheme="https://jaeyeophan.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>[TS] 4. Interface in TypeScript</title>
    <link href="https://jaeyeophan.github.io/2017/12/28/TS-4-Interface-in-TypeScript/"/>
    <id>https://jaeyeophan.github.io/2017/12/28/TS-4-Interface-in-TypeScript/</id>
    <published>2017-12-28T01:10:52.000Z</published>
    <updated>2017-12-28T01:25:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/typescript.png" alt=""></p><h1 id="TS-4-Interface-in-TypeScript"><a href="#TS-4-Interface-in-TypeScript" class="headerlink" title="[TS] 4. Interface in TypeScript"></a>[TS] 4. Interface in TypeScript</h1><p><code>interface</code>는 자바스크립트 개발자에게 친숙하지 않은 용어일꺼라고 생각됩니다. 하지만 정적 타이핑에 있어서 큰 부분을 차지하고 있는 syntax에 대해 알아봅니다.</p><h4 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h4><ul><li>Interface?</li><li>Useful Interface</li><li>Available properties<ul><li>Optional</li><li>readonly</li></ul></li><li>Interface Type<ul><li>Function Type</li><li>Indexable Type</li></ul></li><li>Class interface</li></ul><p><br></p><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface?"></a>Interface?</h2><p><code>interface</code>란 <strong>객체의 껍데기 또는 설계도</strong> 라고 할 수 있을 것 같습니다. 자바스크립트에서는 클래스도 함수도 결국 모두 객체인데요, 클래스 또는 함수의 ‘틀’을 정의할 때 사용할 수 있는 것이 인터페이스 입니다.</p><p>여러 함수가 특정한 시그니처를 동일하게 가져야 할 경우 또는 여러 클래스가 동일한 명세를 정의해야하는 경우 인터페이스를 통해서 정의할 수 있습니다. 인터페이스는 특정 타입으로서 사용될 수 있으며, <code>implements</code>의 대상이 될 수 있습니다. 객체에 인터페이스를 적용하는 경우 또는 반환값 등을 설정할 때 타입으로 이용될 수 있습니다.</p><p><br></p><h2 id="Useful-Interface"><a href="#Useful-Interface" class="headerlink" title="Useful Interface"></a>Useful Interface</h2><p>함수에서 어떤 객체를 받아야 할 경우, 해당 type을 어떻게 정의할 수 있을까요?<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AjaxUtils.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchBasic</span>(<span class="params">param: &#123;url: <span class="built_in">string</span>&#125;</span>): <span class="title">Promise</span>&lt;<span class="title">Response</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(param.url);</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 <code>param</code>이라는 인자의 타입을 literal 형식으로 정의할 수 있습니다. 그런데 그 객체의 프로퍼티가 많아지는 경우에는 어떻게 정의할까요? (반환값 형식에 <code>Promise&lt;?&gt;</code>형식으로 지정을 해줬는데요, 이는 Generics 부분에서 다룰 예정입니다.)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params">param: &#123;baseUrl: <span class="built_in">string</span>, <span class="keyword">type</span>: <span class="built_in">string</span>, subject?: <span class="built_in">string</span>&#125;</span>): <span class="title">Promise</span>&lt;<span class="title">Response</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;baseUrl, <span class="keyword">type</span>, subject&#125; = param;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">`<span class="subst">$&#123;baseUrl&#125;</span>/<span class="subst">$&#123;subject&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> contentType = response.headers.get(<span class="string">"content-type"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (response.ok &amp;&amp; contentType &amp;&amp; contentType.includes(<span class="keyword">type</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.json();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"Invalid baseUrl or subject"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>literal로 인자의 타입을 정의하다보니 함수의 signature가 너무 길어졌습니다. 그런데 여기서 <code>Promise&lt;Response&gt;</code> 이 부분도 정의가 필요합니다. 따라서 다음과 같이 길어집니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params">param: &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  baseUrl: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">type</span>: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  subject?: <span class="built_in">string</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>): <span class="title">Promise</span>&lt;</span>&#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  company: <span class="built_in">string</span>;</span><br><span class="line">&#125;[]&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>뭔가 최대한 가독성을 좋게 하기 위해서 개행을 했지만 성공하진 못한 것 같습니다. 문제는 여기서 끝이 아닙니다. 이 함수를 호출하는 곳에서는 다음과 같은 일이 벌어집니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">async</span> ajax(): <span class="built_in">Promise</span>&lt;&#123;id: <span class="built_in">number</span>; name: <span class="built_in">string</span>; company: <span class="built_in">string</span>;&#125;[]&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data: &#123;id: <span class="built_in">number</span>; name: <span class="built_in">string</span>; company: <span class="built_in">string</span>;&#125;[] = <span class="keyword">await</span> fetchData(&#123;</span><br><span class="line">    baseUrl: <span class="string">"http://localhost:3000"</span>,</span><br><span class="line">    subject: <span class="string">"users"</span>,</span><br><span class="line">    <span class="keyword">type</span>: <span class="string">"application/json"</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// ...do something</span></span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 혼란의 상황을 interface를 통해 깔끔하게 정리할 수 있습니다. 인자와 반환값을 interface를 통해 정리해보겠습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces.ts</span></span><br><span class="line"><span class="keyword">interface</span> Character &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  company: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> dataFormat &#123;</span><br><span class="line">  charaters: Character[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> fetchDataParam &#123;</span><br><span class="line">  baseUrl: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">string</span>;</span><br><span class="line">  subject: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 <code>interfaces.ts</code>라는 파일을 생성하여 인터페이스들을 정의할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AjaxUtils.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; fetchDataParam, dataFormat &#125; <span class="keyword">from</span> <span class="string">"./interfaces"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params">param: fetchDataParam</span>): <span class="title">Promise</span>&lt;<span class="title">dataFormat</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AjaxUtils.ts</code>에서는 정의한 인터페이스를 import하여 인자와 반환값에 해당 인터페이스를 통해 타입을 정의할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Controller.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; fetchDataParam, dataFormat &#125; <span class="keyword">from</span> <span class="string">"./interfaces"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">async</span> ajaxCall(): <span class="built_in">Promise</span>&lt;dataFormat&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> param: fetchDataParam = &#123;</span><br><span class="line">    baseUrl: <span class="string">"http://localhost:3000"</span>,</span><br><span class="line">    subject: <span class="string">"users"</span>,</span><br><span class="line">    <span class="keyword">type</span>: <span class="string">"application/json"</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> data: dataFormat = <span class="keyword">await</span> fetchData(param);</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>호출하는 부분에서도 마찬가지로 <code>interfaces.ts</code>파일에서 필요한 인터페이스를 import하여 타입을 지정해줍니다. 예시 코드에서 처럼 인터페이스를 정의하여 인자에 정의하던 타입들을 깔끔하게 정리할 수 있습니다. 또한 다른 파일에서 해당 함수를 정의하는 부분과 호출하는 부분이 다를 때, 하나의 인터페이스를 공유할 수 있습니다. 인터페이스를 통일시키는 것이 중요할 때 매우 유용하게 사용할 수 있습니다.</p><p><br></p><h2 id="Available-properties"><a href="#Available-properties" class="headerlink" title="Available properties"></a>Available properties</h2><p>인터페이스에도 클래스와 동일하게 optional하게 property를 지정할 수 있으며 readonly 타입으로 property를 지정할 수 있습니다.</p><h3 id="Optional-properties"><a href="#Optional-properties" class="headerlink" title="Optional properties"></a>Optional properties</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> WeatherSpec &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">string</span>;</span><br><span class="line">  amount?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> rainfall: WeatherSpec = &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">"rainfall"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>optional property로 지정한 <code>amount</code>에 대해서는 구현하지 않아도 에러가 발생하지 않는 것을 확인할 수 있습니다.</p><p><br></p><h3 id="Readonly-properties"><a href="#Readonly-properties" class="headerlink" title="Readonly properties"></a>Readonly properties</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> WeatherSpec &#123;</span><br><span class="line">  readonly <span class="keyword">type</span>: <span class="built_in">string</span>;</span><br><span class="line">  amount: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> rainfall: WeatherSpec = &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">"rainfall"</span>,</span><br><span class="line">  amount: <span class="number">24</span>,</span><br><span class="line">&#125;</span><br><span class="line">rainfall.type = <span class="string">"snow"</span>; <span class="comment">// Error!</span></span><br><span class="line">rainfall.amout += <span class="number">3</span>; <span class="comment">// OK!</span></span><br></pre></td></tr></table></figure><p>에러 메시지는 다음과 같습니다. <code>[!] Error: Cannot assign to &#39;type&#39; because it is a constant or a read-only property.</code> 위와 같이 interface에서 readonly로 지정한 프로퍼티에 대해서는 그 값을 바꿀 수 없습니다. 이는 변수를 사용할 때 사용하는 <code>const</code>키워드와 동일한 역할을 수행한다고 이해할 수 있습니다.</p><p><br></p><h2 id="Interface-Types"><a href="#Interface-Types" class="headerlink" title="Interface Types"></a>Interface Types</h2><p>인터페이스에 프로퍼티를 정의할 때 여러 가지 형식으로 정의할 수 있습니다.</p><h3 id="Function-Type"><a href="#Function-Type" class="headerlink" title="Function Type"></a>Function Type</h3><p>인터페이스의 프로퍼티로 함수의 시그니처를 정의할 수 있습니다. 반환하는 형식 또는 그 값이 다르지만 시그니처를 통일시켜야 하는 경우가 존재할 수 있습니다. 그럴 경우 다음과 같이 interface를 설계하여 함수를 구현할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> TimeFunc &#123;</span><br><span class="line">  (hour: <span class="built_in">number</span>, minutes: <span class="built_in">number</span>): <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buildTimeStamp: TimeFunc = (hour, minutes): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (minutes &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(<span class="string">`<span class="subst">$&#123;hour&#125;</span>0<span class="subst">$&#123;minutes&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>  <span class="built_in">Number</span>(<span class="string">`<span class="subst">$&#123;hour&#125;</span><span class="subst">$&#123;minutes&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buildTimeText: TimeFunc = (hour, minutes): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (minutes &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;hour&#125;</span>시 0<span class="subst">$&#123;minutes&#125;</span>분`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;hour&#125;</span>시 <span class="subst">$&#123;minutes&#125;</span>분`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buildTimeStamp(<span class="number">12</span>, <span class="number">33</span>); <span class="comment">//1233</span></span><br><span class="line">buildTimeText(<span class="number">12</span>, <span class="number">33</span>); <span class="comment">//12시 33분</span></span><br></pre></td></tr></table></figure></p><p>반환 타입을 제외하고 동일한 형식의 함수를 정의했습니다. 이것은 특정 콜백 함수를 받는 함수를 구현할 때 그 유용성이 더 빛을 발합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildTime = <span class="function">(<span class="params">timeText: <span class="built_in">string</span>, cb: TimeFunc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> hour: <span class="built_in">number</span> = <span class="built_in">Number</span>(timeText.split(<span class="string">":"</span>)[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">const</span> minutes: <span class="built_in">number</span> = <span class="built_in">Number</span>(timeText.split(<span class="string">":"</span>)[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cb(hour, minutes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(buildTime(<span class="string">"12:33"</span>, buildTimeStamp)); <span class="comment">//1233</span></span><br><span class="line"><span class="built_in">console</span>.log(buildTime(<span class="string">"12:33"</span>, buildTimeText)); <span class="comment">//12시 33분</span></span><br></pre></td></tr></table></figure><p>콜백 함수를 인자로 받을 때 해당하는 시그니처가 통일되어야 하는 부분을 인터페이스를 통해 해결할 수 있습니다.</p><p><br></p><h3 id="Indexable-Types"><a href="#Indexable-Types" class="headerlink" title="Indexable Types"></a>Indexable Types</h3><p>자바스크립트에서 다음과 같은 코드는 매우 자연스럽습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  first: <span class="number">1</span>,</span><br><span class="line">  second: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> <span class="built_in">console</span>.log(obj[key]));</span><br></pre></td></tr></table></figure></p><p>즉, 객체의 프로퍼티에 접근할 때, 동적으로 생성된 <code>key</code>를 통해 객체의 프로퍼티에 <code>[]</code> 표기법으로 접근하는 경우입니다. 하지만 이 코드는 타입스크립트에서 동작하지 않습니다.</p><p><code>[!] Element implicitly has an &#39;any&#39; type because type &#39;{ first: number; second: number; }&#39; has no index signature.</code>이란 에러를 발생시킵니다. 왜냐하면 정의한 <code>obj</code>라는 객체에 index signature가 없기 때문입니다. 따라서 이 에러는 다음과 같이 해결할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Indexable &#123;</span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj: Indexable = &#123;</span><br><span class="line">  first: <span class="number">1</span>,</span><br><span class="line">  second: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key: <span class="built_in">string</span></span>) =&gt;</span> obj[key]);</span><br></pre></td></tr></table></figure></p><p><code>Indexable</code>이란 이름의 인터페이스를 정의해준 다음, <code>string</code> 타입의 key에 <code>any</code> 타입을 지정해줍니다. 이 인터페이스를 통해서 객체를 생성하면 <code>[]</code> 표기법을 통해 객체의 프로퍼티에 접근할 수 있습니다.</p><p><br></p><h2 id="Class-interface"><a href="#Class-interface" class="headerlink" title="Class interface"></a>Class interface</h2><p>인터페이스를 클래스에서도 사용할 수 있습니다. 상위 클래스를 <code>extends</code>라는 키워드로 상속하듯이 <code>implements</code>라는 키워드로 인터페이스를 구현할 수 있습니다. 클래스는 인터페이스를 <code>implements</code>하면서 인터페이스에 명세되어 있는 기능들을 구현해야 하는 의무를 갖게 됩니다.</p><p>인터페이스에서는 클래스의 프로퍼티(필드 멤버), 메소드 등을 정의할 수 있습니다. 또한 optional 한 명세 또한 정의할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Movable &#123;</span><br><span class="line">  velocity: <span class="built_in">number</span>;</span><br><span class="line">  move(time: <span class="built_in">number</span>): Position;</span><br><span class="line">  startPos?: Position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> BMWCar <span class="keyword">implements</span> Movable &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>여기까지 입력했을 때 나타나는 에러 메세지는 다음과 같습니다. <code>[!] Class &#39;Car&#39; incorrectly implements interface &#39;Movable&#39;.</code>. 특정 인터페이스를 구현한 클래스는 인터페이스에 정의된 명세를 구현해야 합니다.</p><p>즉 여기서는 <code>velocity</code>라는 프로퍼티를 포함해야 하며, <code>move</code>라는 메소드를 구현해야만 합니다. 이 <code>BMWCar</code> 클래스는 생성할 때 다음과 같이 생성할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BMWCar <span class="keyword">implements</span> Movable &#123;</span><br><span class="line">  velocity: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">velocity</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.velocity = velocity;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  move(time: <span class="built_in">number</span>): Position &#123;</span><br><span class="line">    <span class="comment">//... do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bmw: Movable = <span class="keyword">new</span> BMWCar();</span><br></pre></td></tr></table></figure></p><p><code>BMWCar</code>라는 타입 말고도 해당 클래스에서 구현한 인터페이스인 <code>Movable</code> 타입으로 지정할 수 있습니다.</p><h3 id="Public-Property"><a href="#Public-Property" class="headerlink" title="Public Property"></a>Public Property</h3><p>TypeScript Official Document에 <code>Interfaces describe the public side of the class, rather than both the public and private side.</code> 이런 말이 나옵니다. <code>인터페이스</code>를 통해 구현해야 함을 명시하는 메소드는 <code>private</code> 접근 제어자로 정의될 메소드가 아니라 <code>public</code> 접근 제어자로 정의될 메소드이어야 한다고 합니다.</p><p>즉, 인터페이스를 통해 명세를 정의할 때는 <code>private</code> 속성말고 <code>public</code> 속성에 대해 정의합니다.</p><p><br></p><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>인터페이스를 통해 보다 세밀한 구조 설계와 추상화가 가능해졌습니다. 해당 포스팅 외 다른 타입스크립트 포스팅은 <a href="https://github.com/JaeYeopHan/typescript_tutorial_docs" target="_blank" rel="noopener">여기</a>에서 보실 수 있으며 예제에 사용된 코드는 <a href="https://github.com/JaeYeopHan/typescript_playground" target="_blank" rel="noopener">여기</a>에서 확인하실 수 있습니다.<br>감사합니다.</p><p><em>3. Interface in TypeScript end</em></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.typescriptlang.org/docs/handbook/interfaces.html" target="_blank" rel="noopener">TypeScript Official Document - Interface</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/typescript.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;TS-4-Interface-in-TypeScript&quot;&gt;&lt;a href=&quot;#TS-4-Interface-in-TypeScript&quot; class=&quot;header
      
    
    </summary>
    
      <category term="TypeScript" scheme="https://jaeyeophan.github.io/categories/TypeScript/"/>
    
    
      <category term="ts" scheme="https://jaeyeophan.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>[TS] 3. Function in TypeScript</title>
    <link href="https://jaeyeophan.github.io/2017/12/18/TS-3-Function-in-TypeScript/"/>
    <id>https://jaeyeophan.github.io/2017/12/18/TS-3-Function-in-TypeScript/</id>
    <published>2017-12-18T03:15:32.000Z</published>
    <updated>2018-01-06T08:15:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/typescript.png" alt=""></p><h1 id="TS-3-Function-in-TypeScript"><a href="#TS-3-Function-in-TypeScript" class="headerlink" title="[TS] 3. Function in TypeScript"></a>[TS] 3. Function in TypeScript</h1><p><a href="https://jaeyeophan.github.io/2017/12/13/TS-2-Class/">&lt; 이전: Class in TypeScript &lt;</a></p><p>TypeScript에서 함수를 정의하는데 있어서 몇 가지 추가된 기능에 대해 살펴봅니다.</p><h4 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h4><ul><li>Return type, Parameter type</li><li>Default Parameter / Rest Parameter</li><li>Optional Parameter</li><li>Union Type</li><li>Overloading</li></ul><h2 id="인자와-반환값의-타입을-설정한다"><a href="#인자와-반환값의-타입을-설정한다" class="headerlink" title="인자와 반환값의 타입을 설정한다."></a>인자와 반환값의 타입을 설정한다.</h2><p>함수 또는 메소드를 정의할 때, 타입을 정의해줍니다.<br><em>ES6 code</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMonthFromString</span>(<span class="params">dateOfStringFormat</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> monthOfNumberFormat = <span class="built_in">parseInt</span>(dateOfStringFormat.substring(<span class="number">4</span>, <span class="number">6</span>), <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> monthOfNumberFormat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 함수는 ‘201712’이라는 문자열을 받아서 해당하는 월을 반환하는 함수입니다. (반환값의 형식을 명시하기 위해 바로 return하지 않고 변수에 임시로 받아준 뒤 반환합니다.) 위와 같이 String 타입의 인자를 받아야 한다는 것을 명시해줘야 하기 때문에 변수명부터 굉장히 이상해집니다. 자바스크립트에는 타입이라는 것이 없기 때문에 메소드명 또는 변수명에 타입을 명시할 수 밖에 없습니다.</p><p>만약 Number 타입의 201712를 인자로 넘겨준다면 Number에는 substring이라는 함수가 없기 때문에 에러가 발생합니다. 위 함수를 보다 안정적으로 작성하기 위해서는 다음과 같은 if 문이 필요하게 됩니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMonthFromString</span>(<span class="params">dateOfStringFormat</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> dateOfStringFormat !== <span class="string">"string"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"Invalid format of parameter"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> monthOfNumberFormat = <span class="built_in">parseInt</span>(dateOfStringFormat.substring(<span class="number">4</span>, <span class="number">6</span>), <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> monthOfNumberFormat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>기본적으로 함수가 수행해야하는 비즈니스 로직 외 불필요한 방어코드가 코드를 더럽히고 있습니다. 위 함수를 TypeScript 함수로 변경해보겠습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getMonth = (date: <span class="built_in">string</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(date.substring(<span class="number">4</span>, <span class="number">6</span>), <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>인자와 반환값에 타입을 설정하여 메소드 이름과 변수명이 훨씬 짧아졌습니다. 그럼에도 불구하고 해당 함수가 하는 역할을 ES6로 작성했을 때보다 명확해졌으며, 불필요한 방어코드 마저 사라졌습니다.<br><a href="https://github.com/denysdovhan/wtfjs" target="_blank" rel="noopener">wtfjs</a>에서 확인하실 수 있지만 자바스크립트에서는 타입이 멋대로(사실은 매우 다양한 규칙을 기반으로) 캐스팅되는 경우가 많은데요, 이를 방지하기 위해 우리는 불필요한 방어코드를 작성해왔습니다. 타입을 지정함으로써 이러한 작업을 최소화 할 수 있습니다.</p><p><br></p><h2 id="Default-Parameter-Rest-Parameter"><a href="#Default-Parameter-Rest-Parameter" class="headerlink" title="Default Parameter, Rest Parameter"></a>Default Parameter, Rest Parameter</h2><p>해당 스펙은 ES6 표준 스펙에서도 지원하고 있는 스펙이므로 구체적은 설명은 넘어가겠습니다. 자세한 내용은 첨부하는 포스팅을 확인해주세요.</p><ul><li><a href="https://jaeyeophan.github.io/2017/04/18/ES6-4-Spread-Rest-parameter/">ES6. Rest Parameter</a></li><li><a href="https://jaeyeophan.github.io/2017/04/18/ES6-5-Destructuring-and-Default-Parameter/">ES6. Default Parameter</a></li></ul><p>TypeScript에서도 해당 스펙을 지원합니다.<br><em>Default parameter TypeScript code</em><br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getRandomNumber = (min: <span class="built_in">number</span> = <span class="number">0</span>, max: <span class="built_in">number</span> = <span class="number">10</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min)) + min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getRandomNumber(<span class="number">1</span>)); <span class="comment">// OK!</span></span><br></pre></td></tr></table></figure></p><p>위 코드에서는 인자가 넘겨지지 않았을 경우(<code>undefined</code>), 지정해준 값으로 인자를 설정합니다. 명시적으로 <code>null</code>을 인자로 넘겨주면 default로 설정된 parameter를 무시하고 <code>null</code>을 인자로 넘깁니다. 지정한 인자를 모두 넘기지 않으면 에러를 뱉던 TypeScript도 default parameter가 지정되어 있으면 에러를 발생시키지 않습니다.</p><p><em>Rest parameter TypeScript code</em><br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setSkills = (...skills: <span class="built_in">string</span>[]): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>rest parameter</code>의 타입은 배열(array)이므로 인자에 해당하는 타입을 설정해줍니다.</p><p><br></p><h2 id="Optional-Parameter"><a href="#Optional-Parameter" class="headerlink" title="Optional Parameter"></a>Optional Parameter</h2><p>TypeScript에서는 default parameter 없을 경우, signature에서 정의한대로 인자를 넘겨주지 않으면 에러가 발생합니다. 하지만 파라미터를 넘겨주지 않아도 되도록 설정할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setSpec = (major: <span class="built_in">string</span>, option?: <span class="built_in">string</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(major);</span><br><span class="line">  <span class="built_in">console</span>.log(option);</span><br><span class="line">&#125;</span><br><span class="line">setSpec(<span class="string">"Computer Science"</span>);</span><br><span class="line"><span class="comment">// console&gt; Computer Science</span></span><br><span class="line"><span class="comment">// console&gt; undefined</span></span><br></pre></td></tr></table></figure></p><blockquote><p><code>?</code>를 통해서 함수에 optional한 parameter를 지정할 수 있습니다.</p></blockquote><p><br></p><h2 id="Union-Type"><a href="#Union-Type" class="headerlink" title="Union Type"></a>Union Type</h2><p>파라미터에 타입을 지정할 때, 두 가지 이상의 타입이 지정할 필요가 있을 수 있는데요, 그럴 때 Union type을 통해서 파라미터의 타입을 지정해줄 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sayName(position: <span class="built_in">string</span> | <span class="built_in">boolean</span> | <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> position === <span class="string">"string"</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`string type position`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> position === <span class="string">"boolean"</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`boolean type position`</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`else`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 코드에서는 <code>position</code>이라는 파라미터가 <code>string</code>, <code>boolean</code>, <code>number</code> 세 가지의 타입일 수 있다고 signature를 지정했습니다. (예제가 송구스럽네요)</p><p><br></p><h2 id="Overloading"><a href="#Overloading" class="headerlink" title="Overloading"></a>Overloading</h2><p>바로 이전 <a href="https://jaeyeophan.github.io/2017/12/13/TS-2-Class/">Class 포스팅</a>에서 자바와 같은 오버로딩을 지원하지 않는다고 했는데요, <code>optional parameter</code>와 <code>union type</code> 그리고 <code>any</code>라는 타입을 사용하면 자바에서 구현하는 것과는 조금 다르지만 오버로딩을 구현할 수 있습니다.</p><figure class="highlight ts"><figcaption><span>Person.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">  sayName(position: <span class="built_in">string</span>, option?: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">  sayName(position: <span class="built_in">boolean</span>, option: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">  sayName(position: <span class="built_in">string</span> | <span class="built_in">boolean</span>, option: <span class="built_in">any</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> position === <span class="string">"string"</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`string type position`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> position === <span class="string">"boolean"</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`boolean type position`</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`else`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 동일한 메소드 명에 대해 여러 Signature를 정의할 수 있습니다. 위 코드에서는 <code>sayName</code>이라는 메소드의 Signature가 세 개이며 마지막 메소드에서만 이를 구현하고 있습니다. 그리고 메소드 body에서는 parameter의 타입으로 분기를 하여 로직을 수행하고 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person: Person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.sayName(<span class="string">"FrontEnd"</span>);</span><br><span class="line">person.sayName(<span class="string">"FrontEnd"</span>, <span class="string">"optional);</span></span><br><span class="line"><span class="string">person.sayName(false, "</span>option required<span class="string">");</span></span><br><span class="line"><span class="string">// person.sayName(true); Error! (1)</span></span><br><span class="line"><span class="string">// person.sayName(1); Error! (2)</span></span><br></pre></td></tr></table></figure></p><p><code>sayName</code>을 호출하게 되면, 메소드를 <strong>호출하는 시점에서</strong> 각 상황에 맞는 signature가 적용됩니다. <code>Error (1)</code>을 보면 <code>boolean</code> 타입이 인자로 넘어갔을 경우의 signature에 따라 <code>option</code>이 <code>required</code> 인자이므로 에러가 발생합니다. <code>Error (2)</code>는 어느 signature와도 일치하지 않으니 에러가 발생합니다. 이렇게 TypeScript에서는 여러 signature를 정의한 뒤 메소드 내에서 이를 분기하여 오버로딩을 구현할 수 있습니다.</p><p><br></p><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>TypeScript 좀 더 안정성 있는, 간결한, 가독성이 좋은 함수를 작성할 수 있게 되었습니다. 어떻게 보면 타이핑이 길어지는 결과처럼 보일 수 있겠지만 타입의 명시가 필요한 부분에 있어서는 오히려 코드가 더 짧아지게 되었습니다.</p><p>해당 포스팅 외 다른 타입스크립트 포스팅은 <a href="https://github.com/JaeYeopHan/typescript_tutorial_docs" target="_blank" rel="noopener">여기</a>에서 보실 수 있으며 예제에 사용된 코드는 <a href="https://github.com/JaeYeopHan/typescript_playground" target="_blank" rel="noopener">여기</a>에서 확인하실 수 있습니다.<br>감사합니다.</p><p><em>3. Function in TypeScript end</em></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.typescriptlang.org/docs/handbook/functions.html" target="_blank" rel="noopener">TypeScript Official Document - Function</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/typescript.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;TS-3-Function-in-TypeScript&quot;&gt;&lt;a href=&quot;#TS-3-Function-in-TypeScript&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="TypeScript" scheme="https://jaeyeophan.github.io/categories/TypeScript/"/>
    
    
      <category term="ts" scheme="https://jaeyeophan.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>[TS] 2. Class in TypeScript</title>
    <link href="https://jaeyeophan.github.io/2017/12/13/TS-2-Class/"/>
    <id>https://jaeyeophan.github.io/2017/12/13/TS-2-Class/</id>
    <published>2017-12-13T06:56:11.000Z</published>
    <updated>2017-12-17T07:23:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/typescript.png" alt=""></p><h1 id="TS-2-Class-in-TypeScript"><a href="#TS-2-Class-in-TypeScript" class="headerlink" title="[TS] 2. Class in TypeScript"></a>[TS] 2. Class in TypeScript</h1><p><em><a href="https://jaeyeophan.github.io/2017/04/23/TS-1-Basic-Types/">이전 포스팅: 1. Basic Types</a></em></p><p>이번 포스팅에서는 TypeScript에서의 클래스(class)에 대해 다뤄보겠습니다.</p><h4 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h4><ul><li>Constructor</li><li>extend를 통한 상속</li><li>Access Modifier<ul><li>public</li><li>private</li><li>protected</li><li>readonly</li><li>static</li></ul></li></ul><p>자바스크립트 개발자라고 하더라도 ES6덕분에 우리는 클래스에 이미 많이 익숙해져 있습니다. 그러나 ES6의 클래스는 뭔가가 조금 아쉬웠는데요, 이 부분을 TypeScript가 채워줄 예정입니다. 일단 ES6에서 클래스를 살펴봅니다.</p><p><em>ES6 code</em><br><figure class="highlight js"><figcaption><span>Person.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(firstName, lastName) &#123;</span><br><span class="line">    <span class="keyword">this</span>._firstName = firstName;</span><br><span class="line">    <span class="keyword">this</span>._lastName = lastName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get fullName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>._firstName&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>._lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1: Person = <span class="keyword">new</span> Person(<span class="string">"Jbee"</span>, <span class="string">"Han"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.fullName); <span class="comment">// Jbee Han</span></span><br></pre></td></tr></table></figure></p><p>익숙한 클래스의 형태라고 생각합니다. 익숙하지 않으시다면 <a href="https://jaeyeophan.github.io/2017/04/18/ES6-6-Class-sugar-syntax/">ES6 Class에 대한 포스팅</a>을 참고해주세요. TypeScript에서의 클래스에는 ES6 코드와 비교해봤을 때, 이것 저것 키워드가 많이 추가가 됬는데요, 하나씩 알아보기로 합시다.</p><h2 id="1-Constructor"><a href="#1-Constructor" class="headerlink" title="1. Constructor"></a>1. Constructor</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name, gender</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.gender = gender; <span class="comment">// Error!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6에서는 constructor로 받은 인자를 해당 클래스에 멤버로 등록하기 위해 this로 등록을 해줬습니다. 그 제한 또한 없었습니다. 하지만 타입스크립트에서는 해당 클래스의 프로퍼티로 등록되지 않은 속성에 대해 constructor에서 받을 수 없습니다. 위 코드에서는 <code>gender</code>라는 프로퍼티를 정의하지 않았기 때문에 constructor에서 인자로 받을 수 없습니다.</p><blockquote><p>프로퍼티(or filed member)로 미리 정의되지 않은 인자를 constructor에서 받을 수 없습니다.</p></blockquote><p><br></p><h2 id="2-extend를-통한-상속"><a href="#2-extend를-통한-상속" class="headerlink" title="2. extend를 통한 상속"></a>2. extend를 통한 상속</h2><p>TypeScript에서도 ES6와 마찬가지 방식으로 상속을 구현할 수 있습니다. <code>public</code>, <code>protected</code> 접근제어자로 정의된 프로퍼티와 메소드에 접근할 수 있습니다. (접근제어자에 대해서는 바로 다음 section에서 알아봅니다.)<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Developer <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devPerson: Person = <span class="keyword">new</span> Developer(<span class="string">"jbee"</span>);</span><br><span class="line">devPerson.sayName(); <span class="comment">// jbee</span></span><br></pre></td></tr></table></figure></p><p><code>sayName</code>은 <code>Person</code>클래스에만 정의되어 있는 메소드입니다. <code>Person</code>에서 정의한 대로 <code>this.name</code>을 console에 출력하는 것을 확인할 수 있습니다.</p><blockquote><p>extends 키워드를 통해서 클래스를 상속받아 부모 클래스의 메소드와 프로퍼티에 접근할 수 있습니다.</p></blockquote><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p>자식 클래스에서 constructor를 정의하려면 <code>super()</code>를 꼭 호출해줘야 합니다. (이는 ES6 문법과 동일합니다.) <code>super()</code>로 넘어가게 되는 인자 또한 부모 클래스에서 정의한 signature와 동일해야 합니다. 물론 별도로 정의하지 않으면 부모 클래스의 constructor를 따라갑니다.</p><h3 id="Override-method"><a href="#Override-method" class="headerlink" title="Override method"></a>Override method</h3><p><code>Developer</code>클래스에서 해당 메소드 구현하게 되면 부모 클래스의 메소드를 override 하게 됩니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Developer <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    cosole.log(<span class="string">`I'm developer, <span class="subst">$&#123;this.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devPerson: Developer = <span class="keyword">new</span> Developer(<span class="string">"jbee"</span>);</span><br><span class="line">devPerson.sayName(); <span class="comment">// I'm developer, jbee</span></span><br></pre></td></tr></table></figure></p><p><code>sayName</code>이라는 메소드는 <code>Developer</code>클래스에서 재정의된 형태로 console에 출력합니다.</p><blockquote><p>부모 클래스를 override하게 되면 부모 클래스에서 정의된 메소드를 재정의할 수 있습니다.</p></blockquote><p>한 가지 짚고 넘어가자면, 자바에서 지원되는 overloading이 지원되지 않습니다. 따라서 다음과 같은 메소드는 추가할 수 없습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Developer <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  sayName(position) &#123; <span class="comment">// Error!</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>[!] Types of property &#39;sayName&#39; are incompatible.</code>라는 에러가 발생합니다. 자식 클래스에서 부모 클래스와 메소드의 이름은 동일하고 signature가 다른 메소드는 정의할 수 없습니다. 이미 부모 클래스에 <code>sayName</code>이라는 메소드가 존재하기 때문에 해당 메소드와 동일한 signature로 override하지 않는 이상, 다른 signature로 또다른 메소드를 정의할 수 없습니다.</p><blockquote><p><strong>[!]</strong> 하지만 <code>any</code>라는 타입과 함께 오버로딩을 메소드 내부에서 if 문 또는 switch 문으로 분기하여 비슷하게 구현할 수 있습니다. <strong>바로 다음에 다룰 Function 포스팅에서 다루겠습니다.</strong></p></blockquote><p><br></p><h2 id="3-Access-Modifier"><a href="#3-Access-Modifier" class="headerlink" title="3. Access Modifier"></a>3. Access Modifier</h2><p>TypeScript에서는 클래스의 프로퍼티 또는 메소드에 접근제어자를 추가할 수 있습니다.</p><h3 id="public-by-default"><a href="#public-by-default" class="headerlink" title="public (by default)"></a>public (by default)</h3><p>타입스크립트에서 아무 접근 제어자를 추가하지 않으면 기본적으로 <code>public</code> 접근제어자와 동일하게 동작합니다. ES6에서와 마찬가지로 클래스 내부, 외부에서 모두 접근할 수 있는 프로퍼티를 정의할 때 사용합니다. <code>getter</code>, <code>setter</code>를 별도로 만들지 않아도 접근이 가능합니다. 위에서 정의한 <code>Person</code>클래스를 사용하여 예시를 보겠습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">"jbee"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.name); <span class="comment">// "jbee"</span></span><br></pre></td></tr></table></figure></p><p>프로퍼티에 바로 접근할 수 있는 것을 확인할 수 있습니다.</p><p><br></p><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p><code>private</code> 접근 제어자로 정의된 멤버는 클래스 밖에서 접근할 수 없습니다. 이번 예시 코드에서는 <code>getter</code>, <code>setter</code>를 추가해주기 위해 프로퍼티 명 앞에 <code>_</code>(언더바)를 추가했습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> _job: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name, job</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1: Person = <span class="keyword">new</span> Person(<span class="string">"jbee"</span>, <span class="string">"Developer"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1._job); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></p><p><code>Property &#39;_job&#39; is private and only accessible within class &#39;Person&#39;.</code>이라는 에러가 발생합니다. 클래스 내부가 아닌 외부에서 <code>private</code>으로 정의된 프로퍼티에 접근하려고 했기 때문에 발생하는 에러입니다. 해당 프로퍼티에 접근하기 위해 <code>getter</code>를 추가하겠습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">get</span> job() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._job;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1: Person = <span class="keyword">new</span> Person(<span class="string">"jbee"</span>, <span class="string">"Developer"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.job); <span class="comment">// Developer</span></span><br></pre></td></tr></table></figure></p><p>이렇게 접근할 수 있게 됩니다. <code>getter</code>, <code>setter</code>를 추가하는 것보다 접근제어자를 <code>public</code>하는 것이 맞는 것 같습니다.</p><blockquote><p>프로퍼티 또는 메소드에 <code>private</code>이라는 접근 제한자를 붙이게 되면 클래스 내에서만 사용할 수 있는 프로퍼티, 그리고 메소드가 됩니다.</p></blockquote><p><br></p><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p>기본적으로는 <code>private</code> 접근 제어자와 동일하게 동작합니다. 하지만 어느 한 곳에서는 접근이 가능한데요, 바로 해당 클래스를 상속한 클래스에서 접근이 가능합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Perosn &#123;</span><br><span class="line">  <span class="keyword">protected</span> isWorking: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1: Person = <span class="keyword">new</span> Person(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.isWorking);<span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></p><p><code>[!] Property &#39;isWorking&#39; is protected and only accessible within class &#39;Person&#39; and its subclasses.</code>라는 에러가 발생합니다. <code>private</code> 접근제어자와 마찬가지로 클래스 외부에서 접근할 수 없음을 뜻합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Developer <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">isWorking</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(isWorking);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isWork() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.isWorking);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devPerson: Developer = <span class="keyword">new</span> Developer(<span class="literal">true</span>);</span><br><span class="line">devPerson.isWork(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>위 <code>Person</code>클래스를 상속한 클래스에서는 <code>protected</code>로 정의된 프로퍼티에 접근할 수 있습니다.</p><blockquote><p>프로퍼티 또는 메소드에 <code>protected</code>이라는 접근 제한자를 붙이게 되면 클래스 내에서와 해당 클래스를 상속한 클래스 안에서만 사용할 수 있게 됩니다.</p></blockquote><p>이 접근 제어자는 <code>constructor</code>에도 추가될 수 있습니다. <code>constructor</code>에 해당 접근제어자를 추가하는 경우, 해당 클래스는 바로 인스턴스화될 수 없으며 이 클래스를 상속받은 클래스에서 <code>super</code>라는 키워드로 호출이 가능합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Perosn &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Developer <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1: Person = <span class="keyword">new</span> Person(<span class="literal">true</span>); <span class="comment">// Error!</span></span><br><span class="line"><span class="keyword">const</span> devPerson: Developer = <span class="keyword">new</span> Developer(); <span class="comment">// OK!</span></span><br></pre></td></tr></table></figure><p><code>[!] Constructor of class &#39;Person&#39; is protected and only accessible within the class declaration.</code>라는 에러가 발생하며 상속받은 클래스만 인스턴스화 시킬 수 있습니다. 추상클래스(Abstract class)도 마찬가지로 상속을 하기 위한 클래스인데요, 추상 클래스는 구현되지 않은 메소드가 존재하는 반면 이 방식은 모든 메소드가 구현되어야 합니다.</p><h4 id="ES-NEXT"><a href="#ES-NEXT" class="headerlink" title="ES.NEXT"></a>ES.NEXT</h4><p><a href="https://github.com/tc39/proposal-class-fields" target="_blank" rel="noopener">tc39/proposal-class-field</a>를 참고해보시면, ECMAScript에서도 <code>private</code>에 대한 스펙이 논의 중이며(stage-3) 해당 스펙은 <code>private</code>이라는 키워드 대신 <code>#</code>이라는 키워드로 스펙이 논의 중입니다.</p><p><br></p><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><p>자바를 공부하셨던 분이라면 <code>final</code>키워드를 아실텐데요, TypeScript에서는 읽기 전용 프로퍼티를 설정하기 위해 <code>readonly</code>프로퍼티를 사용합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">public</span> readonly age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> setAge(age: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age; <span class="comment">// Error!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1: Person = <span class="keyword">new</span> Person(<span class="number">25</span>);</span><br><span class="line">p1.age = <span class="number">20</span>; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></p><p><code>[!] Cannot assign to &#39;age&#39; because it is a constant or a read-only property.</code>라는 에러가 발생합니다! <code>readonly</code>키워드가 추가되면 상수(constant)로 인식하게 됩니다.</p><blockquote><p><code>readonly</code>와 함께 정의된 프로퍼티는 <code>constructor</code>에서 한 번 결정되면 수정할 수 없습니다.</p></blockquote><p><br></p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><code>static</code> 키워드는 ES6에서와 동일하게 사용되며 사용할 수 있습니다. 다만 ES6에서는 메소드에만 해당 키워드를 추가하는 것이 가능했는데요, TypeScript에서는 <code>static</code> 키워드를 프로퍼티에도 추가할 수 있습니다. 해당 키워드를 프로퍼티 또는 메소드에 추가하게 되면 인스턴스를 생성하지 않고 접근하거나 생성할 수 있습니다.<br><em>ES6 code</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Circle.center = [<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><p><em>TypeScript code</em><br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Circle &#123;</span><br><span class="line">  <span class="keyword">static</span> center: <span class="built_in">number</span>[];</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>TypeScript에서 사용하는 클래스에 대해 알아봤습니다. 잘 사용하던 ES6에서의 클래스가 조금 덜떨어져 보일 수 있습니다!</p><p>해당 포스팅 외 다른 타입스크립트 포스팅은 <a href="https://github.com/JaeYeopHan/typescript_tutorial_docs" target="_blank" rel="noopener">여기</a>에서 보실 수 있으며 예제에 사용된 코드는 <a href="https://github.com/JaeYeopHan/typescript_playground" target="_blank" rel="noopener">여기</a>에서 확인하실 수 있습니다.<br>감사합니다.</p><p><em>2. Class in TypeScript end</em></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.typescriptlang.org/docs/handbook/classes.html" target="_blank" rel="noopener">TypeScript Official Document - Class</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/typescript.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;TS-2-Class-in-TypeScript&quot;&gt;&lt;a href=&quot;#TS-2-Class-in-TypeScript&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="TypeScript" scheme="https://jaeyeophan.github.io/categories/TypeScript/"/>
    
    
      <category term="ts" scheme="https://jaeyeophan.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>[TS] TypeScript Playground</title>
    <link href="https://jaeyeophan.github.io/2017/12/06/TS-TypeScript-Playground/"/>
    <id>https://jaeyeophan.github.io/2017/12/06/TS-TypeScript-Playground/</id>
    <published>2017-12-06T11:17:18.000Z</published>
    <updated>2018-10-21T07:08:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/typescript.png" alt=""></p><h1 id="TS-TypeScript-Playground-만들기"><a href="#TS-TypeScript-Playground-만들기" class="headerlink" title="[TS] TypeScript Playground 만들기"></a>[TS] TypeScript Playground 만들기</h1><p>최소한의 npm 과 설정으로 TypeScript playground 만들기를 진행해보겠습니다. 사실 가장 빠른 playground 세팅은 <a href="https://github.com/JaeYeopHan/typescript_playground" target="_blank" rel="noopener">이 저장소</a>를 clone 하면 됩니다!ㅎㅎ</p><p>우선적으로 <code>TypeScript</code>님부터 모셔오도록 합시다 :)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g typescript</span><br></pre></td></tr></table></figure><h3 id="프로젝트-세팅"><a href="#프로젝트-세팅" class="headerlink" title="프로젝트 세팅"></a>프로젝트 세팅</h3><p>디렉토리를 하나 만들고 <code>npm init</code>을 통해 <code>package.json</code> 설정을 해줍니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir typescript_playground &amp;&amp; <span class="built_in">cd</span> typescript_playground</span><br><span class="line">$ npm init</span><br><span class="line"><span class="comment"># set configuration of npm</span></span><br></pre></td></tr></table></figure><p>transpiler 를 태울 webpack 이 필요한데 그 config 파일과 TypeScript 설정파일인 <code>tsconfig.json</code>파일을 생성해줍니다. 그리고 타입스크립트 문법을 익히기 위해 tslint 를 사용할건데 tslint 설정 파일인 <code>tslint.json</code>파일도 생성합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ touch webpack.config.js tsconfig.json</span><br><span class="line">$ touch index.html</span><br><span class="line">$ mkdir src</span><br><span class="line">$ touch src/index.ts</span><br></pre></td></tr></table></figure><p>다음은 개인 취향에 따른 optional 한 세팅 파일들입니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># And create optional files...</span></span><br><span class="line">$ touch .editorconfig</span><br><span class="line">$ touch .gitignore</span><br><span class="line">$ touch README.md</span><br></pre></td></tr></table></figure><p>이 파일들의 내용은 repo 를 참고하세요!</p><p>이젠 필요한 npm 모듈들을 설치합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install webpack webpack-dev-server --save-dev</span><br><span class="line">$ npm install awesome-typescript-loader --save-dev</span><br></pre></td></tr></table></figure><p>프론트엔드 개발자의 영원한 친구 <code>webpack</code>과 그 친구 <code>webpack-dev-server</code>를 설치해줍니다. 그리고 공식 문서에는 <code>ts-loader</code>를 사용하던데요, 저희는 가볍게 무시하고 <code>awesome-typescript-loader</code>를 설치해줍니다. 딱 이만큼만 설치하면 됩니다. ES6 를 한 번 사용해보려고 <code>babel</code>이며 <code>babel-core</code>며 <code>.babelrc</code>파일이며 온갖 이상한 npm 파일과 설정 파일을 생성한 기억이 한 번쯤은 있으실텐데요, 타입스크립트는 여기까지가 끝입니다. (행복합니다.)</p><h3 id="설정-파일-작성하기"><a href="#설정-파일-작성하기" class="headerlink" title="설정 파일 작성하기"></a>설정 파일 작성하기</h3><p>이제 각종 config 파일들을 작성해봅시다. 물론 설정 파일 또한 최소한으로 작성합니다.</p><h4 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h4><figure class="highlight js"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CheckerPlugin &#125; = <span class="built_in">require</span>(<span class="string">"awesome-typescript-loader"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">"./src/index.ts"</span>,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"./dist/bundle.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">".ts"</span>, <span class="string">".js"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  devtool: <span class="string">"inline-source-map"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.ts?$/</span>,</span><br><span class="line">        loader: <span class="string">"awesome-typescript-loader"</span>,</span><br><span class="line">        include: path.resolve(__dirname, <span class="string">"src"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [<span class="keyword">new</span> CheckerPlugin(), <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이 문서에서는 webpack tutorial 을 다루지 않습니다. webpack tutorial 은 <a href="https://github.com/JaeYeopHan/webpack2_tutorial" target="_blank" rel="noopener">여기</a>에서 따라하실 수 있습니다. (깨알홍보!) <code>HotMoudleReplacementPlugin</code> 이 녀석은 도저히 포기할 수 없어서 추가했습니다. 이제 본격적으로 typescript 설정 들어갑니다.</p><p><br></p><h4 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"noImplicitAny"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"removeComments"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es5"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"awesomeTypescriptLoaderOptions"</span>: &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 를 처음 시작하던 때의 <code>.babelrc</code>파일이 기억나시나요? 그것과 비슷하다고 볼 수 있는데요, 상당히 간단합니다. 거의 모든 부분을 <code>awesome-typescript-loader</code>에서 cover 하고 있고 입맛에 맞게 customize 할 수 있도록 <code>&quot;awesomeTypescriptLoaderOptions&quot;</code>라는 이름으로 인터페이스가 열려있습니다. <code>&quot;target: &quot;es5&quot;</code>옵션을 추가해서 <code>getter</code>, <code>setter</code>문법을 지원받을 수 있도록 합니다.</p><p><br></p><h4 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h4><p>javascript 로 transpile 될 typescript 파일을 브라우저 개발자 도구에서 확인하기 위해서 <code>index.html</code> 파일을 간단히 작성해줍니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Hello, TypeScript world!!</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/dist/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>왠만한 설정은 모두 끝났습니다. webpack 에 설정한 loader 를 잘 타는지 확인하기 위해 index.ts 에 console 한 번 찍어봅니다.</p><figure class="highlight ts"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`hello typescript world`</span>);</span><br></pre></td></tr></table></figure><p>그리고 start!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm start</span><br></pre></td></tr></table></figure><p>브라우저가 자동으로 실행될텐데요, 개발자 도구를 열어보면 hello typescript world 라는 console 이 찍혀있을 겁니다. 이제 TypeScript 로 해볼 수 있는 것을 이것 저것 해보면 됩니다.</p><p>해당 포스팅은 소스코드와 함께 다음 <a href="https://github.com/JaeYeopHan/typescript_playground" target="_blank" rel="noopener">GitHub Repository</a>에서 확인하실 수 있습니다.</p><p>감사합니다.</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://github.com/s-panferov/awesome-typescript-loader" target="_blank" rel="noopener">GitHub of awesome-typescript-loader</a></li><li><a href="https://github.com/wbuchwalter/tslint-loader" target="_blank" rel="noopener">GitHub of tslint-loader</a></li><li><a href="https://github.com/JaeYeopHan/webpack2_tutorial" target="_blank" rel="noopener">Jbee’s Webpack tutorial</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="noopener">TypeScript Official Document</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/typescript.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;TS-TypeScript-Playground-만들기&quot;&gt;&lt;a href=&quot;#TS-TypeScript-Playground-만들기&quot; class=&quot;header
      
    
    </summary>
    
      <category term="TypeScript" scheme="https://jaeyeophan.github.io/categories/TypeScript/"/>
    
    
      <category term="ts" scheme="https://jaeyeophan.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>[React-router] 1. react-router basic</title>
    <link href="https://jaeyeophan.github.io/2017/08/30/React-router-1-react-router-basic/"/>
    <id>https://jaeyeophan.github.io/2017/08/30/React-router-1-react-router-basic/</id>
    <published>2017-08-30T09:03:18.000Z</published>
    <updated>2017-08-30T09:05:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/react_router_logo.png" alt=""></p><h1 id="React-router-1-react-router-basic"><a href="#React-router-1-react-router-basic" class="headerlink" title="[React-router] 1. react-router basic"></a>[React-router] 1. react-router basic</h1><p><em><a href="https://github.com/ReactTraining/react-router" target="_blank" rel="noopener">react-router</a>라이브러리에 대해서 살펴봅니다 :) 포스팅 시점의 react-router의 버전은 <code>v4.1.1</code>입니다.</em></p><h2 id="Why-react-router"><a href="#Why-react-router" class="headerlink" title="Why react-router?"></a>Why react-router?</h2><p>React는 SPA(Single Page Application)를 위한 View 라이브러리입니다.즉 여러 개의 <code>html</code>파일로 구성된, 여러 개의 페이지의 웹 애플리케이션이 아닌 단일 페이지로 구성된 웹 애플리케이션을 위한 라이브러리인 것입니다. 하나의 url로 웹 애플리케이션이 실행된다고 볼 수 있습니다. 하지만 이렇게 되면 특정 url에 따른 다른 페이지를 보여줄 수가 없습니다. 이로 인해 여러 가지 아쉬운 점들이 생겼습니다. 물론 html의 <code>anchor</code> 태그(<code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code>)를 사용하면 되지만, 이 태그는 모든 페이지를 모두 reloading합니다. <code>react-router</code>를 사용하게 되면 지정한 부분에 대해서만 reloading시킬 수 있습니다 :D</p><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add react-router-dom</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ npm install react-router-dom</span><br></pre></td></tr></table></figure><p>React project에서 해당 npm을 추가합니다.</p><p><br></p><h2 id="Sample-code-directory’s-structure"><a href="#Sample-code-directory’s-structure" class="headerlink" title="Sample code directory’s structure"></a>Sample code directory’s structure</h2><p>이번 포스팅에서 사용되는 프로젝트의 구조는 다음과 같습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">--containers</span><br><span class="line">----App.js</span><br><span class="line">--components</span><br><span class="line">----Navigators.js</span><br><span class="line">----Home.js</span><br><span class="line">----Comp1.js</span><br><span class="line">----Comp2.js</span><br><span class="line">----Comp3.js</span><br><span class="line">--index.js</span><br></pre></td></tr></table></figure></p><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><figure class="highlight js"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Route, Switch&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br></pre></td></tr></table></figure><p><code>BrowserRouter</code>, <code>Route</code>, <code>Switch</code> 세 가지 모듈을 <code>react-router-dom</code>으로부터 불러옵니다.<br>사용하는 방식은 다음과 같습니다.</p><figure class="highlight js"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Router&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;Navigators/&gt;</span><br><span class="line">                    <span class="comment">//[components according to path]</span></span><br><span class="line">                &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Router&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p><code>Router</code>(<code>BrowserRouter</code>) 태그로 rendering하고자 하는 태그들을 감싸줍니다. <code>Router</code>태그 child로는 하나의 자식, 즉 하나의 태그만이 올 수 있기 때문에 <code>div</code>태그로 하위 태그들을 감싸줍니다. 위 예제는 <code>Navigators</code>에 있는 버튼들로 하위 태그들을 렌더링하기 위한 구조입니다. <code>Router</code>태그 안쪽의 구성을 살펴보겠습니다.</p><figure class="highlight js"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import components</span></span><br><span class="line"><span class="keyword">import</span> Navigators <span class="keyword">from</span> <span class="string">'../components/Navigators'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'../components/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> Comp1 <span class="keyword">from</span> <span class="string">'../components/Comp1'</span></span><br><span class="line"><span class="keyword">import</span> Comp2 <span class="keyword">from</span> <span class="string">'../components/Comp2'</span></span><br><span class="line"><span class="keyword">import</span> Comp3 <span class="keyword">from</span> <span class="string">'../components/Comp3'</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&lt;Router&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Navigators/&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/comp1"</span> component=&#123;Comp1&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/comp2"</span> component=&#123;Comp2&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/comp3"</span> component=&#123;Comp3&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/Router&gt;</span></span><br></pre></td></tr></table></figure><p>이제 <code>Switch</code>태그와 <code>Route</code>태그들을 사용해줍니다. 변경될 부분에 대해서 <code>Switch</code>태그로 감싸준 다음, 지정해준 <code>path</code>에 따라서 렌더링될 component를 지정해줍니다.</p><p><code>exact</code>라는 키워드가 <code>/</code> path에 대해서만 지정이 된 것을 확인할 수 있는데요, 이 <code>/</code>는 각각의 <code>/comp1</code>, <code>/comp2</code>, <code>/comp3</code> path에도 포함되는 path입니다. 그렇기 때문에 중복으로 렌더링이 되는데요, <code>exact</code>는 “<code>/</code>일 경우에만 해당 component를 렌더링해!” 라는 의미의 키워드입니다. 렌더링 해줄 컴포넌트는 이렇게만 작성해주면 됩니다!</p><p>이제 <code>Navigators</code> 컴포넌트를 살펴봅시다.</p><figure class="highlight js"><figcaption><span>Navigators.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;NavLink&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br></pre></td></tr></table></figure><p>이 컴포넌트에서는 <code>NavLink</code>라는 녀석을 불러와줍니다.</p><figure class="highlight js"><figcaption><span>Navigators.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Navigators = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">"Navigators"</span>&gt;</span><br><span class="line">            &lt;NavLink exact to=<span class="string">"/"</span>&gt; Home &lt;<span class="regexp">/NavLink&gt;</span></span><br><span class="line"><span class="regexp">            &lt;NavLink to="/</span>comp1<span class="string">"&gt; One &lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">            &lt;NavLink to="</span>/comp2<span class="string">"&gt; Two &lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">            &lt;NavLink to="</span>/comp3<span class="string">"&gt; Three &lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">export default Navigators;</span></span><br></pre></td></tr></table></figure><p>그리고 <code>NavLink</code> 태그를 사용해서 <code>to</code>를 통해 <code>App.js</code>에서 <code>path</code>로 지정해준 값들과 매핑시켜줍니다. 정말 간단합니다.</p><h3 id="NoMatch"><a href="#NoMatch" class="headerlink" title="NoMatch"></a>NoMatch</h3><p>사용자가 어쩌다가 잘못된 url로 접속했을 시, <code>404 Not Found</code> 페이지가 나타나는데요, 이러한 문제를 방지하기 위해 잘못된 접근을 처리해줄 수 있는 Route를 추가해줍니다. 우선 잘못된 접근에 대해 보여줄 컴포넌트를 만듭니다.<br><figure class="highlight js"><figcaption><span>NoMatch.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NoMatch = <span class="function">(<span class="params">&#123;location&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;No match <span class="keyword">for</span> &#123;location.pathname&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">export default NoMatch;</span></span><br></pre></td></tr></table></figure></p><p>다른 컴포넌트와 다른 건 없습니다. 그리고 <code>App.js</code>에서 <code>Switch</code> 하위에 <code>Route</code>를 추가해주면 됩니다.</p><figure class="highlight js"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> NoMatch <span class="keyword">from</span> <span class="string">'../components/NoMatch'</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//[Other Route tags]</span></span><br><span class="line">&lt;Route component=&#123;NoMatch&#125;/&gt;</span><br></pre></td></tr></table></figure><p>다른 <code>Route</code>태그들과는 달리 <code>path</code>가 지정되어 있지 않습니다. 이 <code>NoMatch</code>에 해당하는 <code>Route</code>태그는 가장 마지막에 작성해주어야 합니다 :)</p><h4 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h4><p><code>react-router</code>라이브러리는 이 포스팅에서 소개해준 기능외에 <code>Server-Rendering</code>, <code>Code-Splitting</code>, <code>Testing</code> 등 다양한 기능을 제공하고 있는 유용한 라이브러리 입니다 :) 얼른 공식 React에 포함되었으면 좋겠네요!</p><p>!<code>React</code>와 관련된 포스팅은 <a href="https://github.com/JaeYeopHan/react_tutorial_with_docs" target="_blank" rel="noopener">Github Repository</a>에서 받아볼 수 있으며 <code>watch</code> 또는 <code>star</code>로 피드를 받아보실 수 있습니다.</p><h4 id="Reference-gt"><a href="#Reference-gt" class="headerlink" title="Reference&gt;"></a>Reference&gt;</h4><p><a href="https://reacttraining.com/react-router/web/example/basic" target="_blank" rel="noopener">react-router docs</a></p><p><em>1. end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/react_router_logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;React-router-1-react-router-basic&quot;&gt;&lt;a href=&quot;#React-router-1-react-router-bas
      
    
    </summary>
    
      <category term="React" scheme="https://jaeyeophan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://jaeyeophan.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>ES8 Standard Release Overview</title>
    <link href="https://jaeyeophan.github.io/2017/07/16/ES8-Standard-Release-Overview/"/>
    <id>https://jaeyeophan.github.io/2017/07/16/ES8-Standard-Release-Overview/</id>
    <published>2017-07-16T10:11:00.000Z</published>
    <updated>2017-07-17T11:35:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/es8_standard_release.png" alt=""></p><h1 id="ES8-Standard-Release-Overview"><a href="#ES8-Standard-Release-Overview" class="headerlink" title="ES8 Standard Release Overview"></a>ES8 Standard Release Overview</h1><p>얼마 전, standard release가 되었는데요, 이 글은 ECMAScript2017 (a.k.a es8)의 주요 스펙에 대해 간단하게 살펴보는 포스팅입니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev babel-core babel-preset-es2017</span><br></pre></td></tr></table></figure><p>아시다시피 <code>babel</code>을 통해서 바로 <code>es2017</code>을 사용해보실 수 있습니다.</p><ul><li><a href="https://github.com/bettiolo/babel-preset-es2017" target="_blank" rel="noopener">babel-preset-es2017</a></li><li><a href="https://github.com/JaeYeopHan/es8_playground" target="_blank" rel="noopener">es8_playground Repository</a></li></ul><h2 id="ES8-Overview"><a href="#ES8-Overview" class="headerlink" title="ES8 Overview"></a>ES8 Overview</h2><p><em>es8의 주요 기능은 다음과 같습니다.</em></p><ul><li>String.prototype.padStart/String.prototype.padEnd</li><li>Object.entries/Object.values</li><li>Object.getOwnPropertyDescriptors</li><li>Trailing Commas in Function Param Lists</li><li>Async Functions</li></ul><p>간단한 예제를 통해 알아보겠습니다 :)</p><p><br></p><h2 id="String-padding"><a href="#String-padding" class="headerlink" title="String padding"></a>String padding</h2><p><code>String</code> 객체에 두 개의 메소드 <code>padStart</code>, <code>padEnd</code>가 추가되었습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.padStart(targetLength [, padString])</span><br><span class="line"><span class="built_in">String</span>.prototype.padEnd(targetLength [, padString])</span><br></pre></td></tr></table></figure></p><p>메소드를 호출하는 문자열의 길이를 주어진 <code>targetLength</code>에 도달하도록 하는 메소드입니다. <code>padString</code>으로 전달된 문자열을 통해 주어진 길이에 도달할 수 있습니다. <code>padString</code> 값을 따로 전달하지 않는 경우 공백으로 문자열의 길이가 도달하게 됩니다.</p><p><code>padStarat</code>의 경우는 문자열의 시작 부분에 값을 추가하여 문자열의 길이를 조정하고 <code>padEnd</code>는 문자열의 끝 부분에 값을 추가하여 문자열의 길이를 조정합니다.</p><ul><li><code>targetLength</code>의 크기가 함수를 호출하는 문자열의 길이보다 작을 경우 문자열의 길이는 변하지 않습니다.</li><li><code>padString</code>으로 넘겨진 문자열로 길이를 맞출 경우, 각각의 문자열에 대해서 채워지고 길이를 넘어가게 되면 버려지게 됩니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String.prototype.padStart</span></span><br><span class="line"><span class="string">'hi'</span>.padStart(<span class="number">1</span>);         <span class="comment">// 'hi'</span></span><br><span class="line"><span class="string">'hi'</span>.padStart(<span class="number">2</span>);         <span class="comment">// 'hi'</span></span><br><span class="line"><span class="string">'hi'</span>.padStart(<span class="number">5</span>);         <span class="comment">// '   hi'</span></span><br><span class="line"><span class="string">'hi'</span>.padStart(<span class="number">5</span>, <span class="string">'p'</span>);    <span class="comment">// 'ppphi'</span></span><br><span class="line"><span class="string">'hi'</span>.padStart(<span class="number">5</span>, <span class="string">'power'</span>);<span class="comment">// 'powhi'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String.prototype.padEnd</span></span><br><span class="line"><span class="string">'hi'</span>.padEnd(<span class="number">1</span>);           <span class="comment">// 'hi'</span></span><br><span class="line"><span class="string">'hi'</span>.padEnd(<span class="number">2</span>);           <span class="comment">// 'hi'</span></span><br><span class="line"><span class="string">'hi'</span>.padEnd(<span class="number">5</span>);           <span class="comment">// 'hi   '</span></span><br><span class="line"><span class="string">'hi'</span>.padEnd(<span class="number">5</span>, <span class="string">'p'</span>);      <span class="comment">// 'hippp'</span></span><br><span class="line"><span class="string">'hi'</span>.padEnd(<span class="number">5</span>, <span class="string">'power'</span>);  <span class="comment">//'hipow'</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="Object-entries-Object-values"><a href="#Object-entries-Object-values" class="headerlink" title="Object.entries(), Object.values()"></a>Object.entries(), Object.values()</h2><p>Object에 <code>entries()</code> 함수와 <code>values()</code> 함수가 추가되었습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.entries(obj);</span><br><span class="line"><span class="built_in">Object</span>.values(obj);</span><br></pre></td></tr></table></figure></p><p><code>entries</code> 함수는 파라미터로 전달된 객체의 <code>key-value</code>를 배열로 반환합니다. <code>values</code> 함수는 파라미터로 전달된 객체의 <code>value</code>만을 배열로 반환합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="string">"1"</span>: <span class="string">"one"</span>, <span class="string">"2"</span>:<span class="string">"two"</span>, <span class="string">"3"</span>: <span class="string">"three"</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj);<span class="comment">// [["1", "one"], ["2", "two"], ["3", "three"]]</span></span><br><span class="line"><span class="built_in">Object</span>.values(obj);<span class="comment">// ["one", "two", "three"]</span></span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptor<strong>s</strong></h2><p>ES5 스펙에서부터 <code>Object.getOwnPropertyDescriptor</code>란 녀석이 있었는데요, 이번에 추가된 함수는 <code>getOwnPropertyDescriptors</code>입니다. (뒤에 ‘s’가 추가되었네요.)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;<span class="string">"1"</span>: <span class="string">"one"</span>, <span class="string">"2"</span>:<span class="string">"two"</span>, <span class="string">"3"</span>: <span class="string">"three"</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(object, <span class="string">"1"</span>);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     value: "one",</span></span><br><span class="line"><span class="comment">//     writable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     configurable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></p><p><code>Object.getOwnPropertyDescriptor(obj, prop)</code> 메서드는 주어진 객체 자신의 속성(즉, 객체에 직접 제공하는 속성, 객체의 프로토타입 체인을 따라 존재하는 덕택에 제공하는 게 아닌)에 대한 속성 설명자(descriptor)를 반환합니다. ES5에서는 <code>obj</code> 파라미터에 원시 데이터 타입이 전달될 경우 <code>TypeError</code>가 발생했지만 ES6에서는 객체로 강제하기 때문에 에러가 발생하지 않습니다.</p><p>ES8에서는 <code>.getOwnPropertyDescriptors</code>를 제공하여 전달된 객체의 모든 프로퍼티에 대한 descriptor에 접근할 수 있습니다. <code>{1: Object, 2: Object, ...}</code> 형태인 객체로 반환되어 접근할 수 있습니다. (배열로 반환하지 않습니다.)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;<span class="string">"1"</span>: <span class="string">"one"</span>, <span class="string">"2"</span>:<span class="string">"two"</span>, <span class="string">"3"</span>: <span class="string">"three"</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(object);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     1: &#123;</span></span><br><span class="line"><span class="comment">//         configurable: true,</span></span><br><span class="line"><span class="comment">//         enumerable: true,</span></span><br><span class="line"><span class="comment">//         value: "one",</span></span><br><span class="line"><span class="comment">//         writable: true,</span></span><br><span class="line"><span class="comment">//     &#125;,</span></span><br><span class="line"><span class="comment">//     2: &#123;</span></span><br><span class="line"><span class="comment">//         ...</span></span><br><span class="line"><span class="comment">//     &#125;,</span></span><br><span class="line"><span class="comment">//     3: &#123;</span></span><br><span class="line"><span class="comment">//         ...</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="함수-매개-변수-목록에서-후행-쉼표"><a href="#함수-매개-변수-목록에서-후행-쉼표" class="headerlink" title="함수 매개 변수 목록에서 후행 쉼표"></a>함수 매개 변수 목록에서 후행 쉼표</h2><p>함수 매개 변수에서 후행 쉼표가 가능해졌습니다. 기존에는 <code>syntax error</code>를 발생시켰습니다. 추가된 이 문법은 다음을 가능하게 합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(</span><br><span class="line">        firstName,</span><br><span class="line">        lastName,</span><br><span class="line">        age,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>객체를 선언할 때, 후행 comma를 통해 선언한 경우와 비슷하다고 생각됩니다. 수정이 필요할 경우, 수정이 필요한 파라미터의 한 줄만 수정하면 됩니다. 함수를 호출할 때도 마찬가지로 후행 comma를 사용할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailingComma</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    param1,</span></span></span><br><span class="line"><span class="function"><span class="params">    param2,</span></span></span><br><span class="line"><span class="function"><span class="params">    param3,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;param1&#125;</span> <span class="subst">$&#123;param2&#125;</span> <span class="subst">$&#123;param3&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tailingComma(</span><br><span class="line">    <span class="string">'hello'</span>,</span><br><span class="line">    <span class="string">'es8'</span>,</span><br><span class="line">    <span class="string">'world'</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="Async-functions"><a href="#Async-functions" class="headerlink" title="Async functions"></a>Async functions</h2><p>이미 많이 들 사용하고 계실거라 생각됩니다만 ES8부터 공식 release되었습니다. 간단한 예제로만 설명하고 넘어갑니다 :)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">'fetch complete!'</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`before`</span>);</span><br><span class="line">fetchData().then(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="built_in">console</span>.log(data));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`after`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// console&gt;</span></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="comment">// fetch complete!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use Async function</span></span><br><span class="line"><span class="keyword">const</span> sayComplete = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> message = <span class="keyword">await</span> fetchData();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`status: <span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`before`</span>);</span><br><span class="line">sayComplete();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`after`</span>);</span><br><span class="line"><span class="comment">// console&gt;</span></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="comment">// status: fetch complete!</span></span><br></pre></td></tr></table></figure></p><p>감사합니다 :)</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://hackernoon.com/es8-was-released-and-here-are-its-main-new-features-ee9c394adf66" target="_blank" rel="noopener">https://hackernoon.com/es8-was-released-and-here-are-its-main-new-features-ee9c394adf66</a></li><li><a href="http://2ality.com/2016/10/async-function-tips.html" target="_blank" rel="noopener">async function tip</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" target="_blank" rel="noopener">MDN Object.getOwnPropertyDescriptor()</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors" target="_blank" rel="noopener">MDN Object.getOwnPropertyDescriptors()</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/es8_standard_release.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES8-Standard-Release-Overview&quot;&gt;&lt;a href=&quot;#ES8-Standard-Release-Overview&quot; c
      
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="ecma" scheme="https://jaeyeophan.github.io/tags/ecma/"/>
    
  </entry>
  
  <entry>
    <title>[React] 3. Props and State in Component</title>
    <link href="https://jaeyeophan.github.io/2017/06/13/React-3-Props-and-State-in-Component/"/>
    <id>https://jaeyeophan.github.io/2017/06/13/React-3-Props-and-State-in-Component/</id>
    <published>2017-06-13T02:23:14.000Z</published>
    <updated>2017-06-13T02:23:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/react_logo.png" alt=""></p><h1 id="React-3-Props-and-State-in-Component"><a href="#React-3-Props-and-State-in-Component" class="headerlink" title="[React] 3. Props and State in Component"></a>[React] 3. Props and State in Component</h1><p>React Component에는 <code>props</code>라는 것이 존재합니다.</p><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p><code>Props</code>은 컴포넌트가 가지고 있는 속성으로 컴포넌트 내부에서는 <code>this.props.[xxx]</code>와 같은 형식으로 접근할 수 있는 것을 말합니다. <code>Props</code>은 외부에서 컴포넌트로 전달하는 값이기 때문에 컴포넌트 내부에서 전달받은 <code>props</code>을 변경해서는 안됩니다. 즉 <code>Props</code>은 immutable한 속성을 갖고 있습니다.</p><h3 id="Use-Props"><a href="#Use-Props" class="headerlink" title="Use Props"></a>Use Props</h3><p>함수로 작성된 Component의 경우와 class 문법으로 작성된 Component의 경우, 두 가지에 대해서 props를 살펴봅니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App name=<span class="string">"Jbee"</span> /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>Component 외부(해당 Component를 사용하는 Component 또는 render 메소드)에서 name이라는 속성을 props라는 객체를 통해 전달할 수 있습니다. 함수로 작성된 Component에서는 파라미터를 통해 <code>props</code>를 전달받아 이를 내부에서 사용할 수 있습니다. ES6의 destructuring 문법을 사용하면 다음과 같이 사용할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">&#123;name&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App name=<span class="string">"Sara"</span> /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>class 문법을 사용하여 Component를 정의하는 경우에는 <code>constructor</code>를 통해 props를 받아 사용할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      &lt;div&gt;Hello! &#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;App name="Jbee"/</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><code>constructor(props)</code>내부에 <code>super(props)</code>이 부분이 보이시나요? 이 부분을 빠뜨리면 에러가 발생합니다. ES6 문법에서도 어떠한 클래스를 상속받은 다음 super를 호출해주지 않으면 에러가 발생하는데요, 그와 같은 원리라고 생각하시면 됩니다.</p><h3 id="TypeChecking-to-Props"><a href="#TypeChecking-to-Props" class="headerlink" title="TypeChecking to Props"></a>TypeChecking to Props</h3><p>컴포넌트가 외부와의 데이터를 주고 받기 위해 props를 사용했는데요, 이럴 경우 props의 Type을 확인해줘야 하는 필요성이 생깁니다. (물론 애플리케이션의 크기가 작을 때는 props를 주고 받는 것이 한 눈에 보이기 때문에 필수적이지는 않습니다. 하지만 정적 언어를 주로 사용하셨던 분들에게는 적지 않은 찝찝함이 남아있을 거라생각합니다.)</p><p>이러한 니즈를 충족시키기 위해 기존에는 React.PropTypes라는 방식을 사용했지만 React v15.5 부터 prop-types라는 npm을 통해 해결합니다. Facebook에서 개발한 <code>Flow</code>를 사용하는 방법도 존재하고, MS의 <code>TypeScript</code>를 사용하는 것도 한 가지 방법이겠습니다 :)</p><p>기존의 방식과 npm을 설치하는 방법은 import 구문이 추가되는 것을 제외하고 모두 동일합니다.<br>App Component에서 받는 props에 대한 TypeChecking 예제 코드입니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">App.propTypes = &#123;</span><br><span class="line">  title: React.PropType.string,</span><br><span class="line">  author: React.PropType.string.isRequired</span><br><span class="line">  onSubmit: React.PropType.func</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>기존의 React에 포함되어 있는 <code>PropType</code>을 사용하는 경우에는 위와 같이 사용하면 됩니다. 필수적으로 요구하는 값에 대해서는 <code>isRequired</code>라는 속성을 더해줍니다. (포스팅을 작성하는 시점에서는 경고 메시지만 로그로 찍힐 뿐 실행에는 문제가 없습니다.)</p><p><code>Prop-Types</code> npm 설치는 다음과 같습니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save prop-types</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ yarn add prop-types</span><br></pre></td></tr></table></figure></p><p>그리고 해당 npm을 import하여 사용할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line">App.propTypes = &#123;</span><br><span class="line">  title: PropType.string,</span><br><span class="line">  author: PropType.string.isRequired,</span><br><span class="line">  onSubmit: PropType.func</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Prop-Type</code>npm에서는 다음과 같은 Type들을 제공합니다.<br><code>array</code>, <code>bool</code>,<code>func</code>,<code>number</code>,<code>object</code>,<code>string</code>,<code>symbol</code>,<code>node</code>,<code>element</code><br>또한 다음과 같은 메소드를 제공하여 보다 강력한 TypeChecking을 제공합니다.<br><code>instanceOf()</code>,<code>oneOf([[array]])</code>,<code>oneOfType([[array]])</code>  etc…<br>보다 더 자세한 내용은 다음 링크를 참고하시면 됩니다. <a href="https://github.com/reactjs/prop-types" target="_blank" rel="noopener">reactjs/prop-types</a></p><h3 id="Set-Default-Props"><a href="#Set-Default-Props" class="headerlink" title="Set Default Props"></a>Set Default Props</h3><p>Component에서 외부로부터 받기로 한 props가 전달되지 않았을 경우를 대비해 props에 대한 default value도 지정해줘야 합니다. default props를 지정하는 것은 props의 type을 check하는 것과 매우 유사합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">App.defaultProps = &#123;</span><br><span class="line">  title: <span class="string">"unknown"</span>,</span><br><span class="line">  author: <span class="string">"unknown"</span>,</span><br><span class="line">  onSubmit: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.warn(<span class="string">'onSubmit function is not defined!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>각 타입에 맞는 적절한 default value를 설정해줄 수 있습니다. propType을 통해 정의한 type은 defaultProps에도 적용됩니다.</p><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>Component 내부에서 관리해야하는 상태 값이 존재하는 경우 <code>state</code>를 통해 관리할 수 있습니다. 이 <code>state</code>는 <code>constructor()</code> 내부에서 정의할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      isSelected: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 예제 코드와 같이 Object로 state를 관리할 수 있습니다. state를 <strong>업데이트할 경우</strong>에는 Component의 <code>.setState()</code>라는 메소드를 사용할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      isSelected: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">isSelected</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Component의 <code>.setState()</code>메소드를 사용하는 메소드를 만들었습니다. Component의 메소드를 JSX 구문에서 사용하기 위해서는 <code>constructor</code>내부에서 <code>this</code>를 binding해줘야 합니다. 해당 메소드를 실행하는 시점에서 메소드 내부에 정의된 <code>this</code>가 달라지기 때문입니다.</p><p><code>.setState()</code>에 대해서 추가적으로 반드시 알아둬야 하는 부분이 있습니다. 바로 이 메소드는 비동기로 호출된다는 점입니다. 즉 일반 메소드처럼 콜스택에 추가되어 호출되는 것이 아니라 이벤트 큐로 들어가게 됩니다. 메소드를 호출할 때 이 부분을 유의하여 작성해야 합니다 :)</p><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>외부, 즉 상위 컴포넌트에 의해 값이 변경될 수 있는 경우에 대해서는 props를 통해 해결하고 이 props는 해당 컴포넌트에서 변경해서는 안됩니다. 컴포넌트 내부에서 변경될 수 있는 값에 대해서는 state를 통해 해결합니다.</p><p>React와 관련된 포스트는 <a href="https://github.com/JaeYeopHan/react_tutorial_with_docs" target="_blank" rel="noopener">Github Repository</a>에서 실시간 피드를 받으실 수 있습니다.</p><p><em>Reference&gt;</em><br><a href="https://facebook.github.io/react/docs/components-and-props.html" target="_blank" rel="noopener">https://facebook.github.io/react/docs/components-and-props.html</a><br><a href="https://facebook.github.io/react/docs/typechecking-with-proptypes.html" target="_blank" rel="noopener">https://facebook.github.io/react/docs/typechecking-with-proptypes.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/react_logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;React-3-Props-and-State-in-Component&quot;&gt;&lt;a href=&quot;#React-3-Props-and-State-in-Componen
      
    
    </summary>
    
      <category term="React" scheme="https://jaeyeophan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://jaeyeophan.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>[ES6] 13. Map, WeakMap</title>
    <link href="https://jaeyeophan.github.io/2017/06/05/ES6-13-Map-WeakMap/"/>
    <id>https://jaeyeophan.github.io/2017/06/05/ES6-13-Map-WeakMap/</id>
    <published>2017-06-05T05:44:56.000Z</published>
    <updated>2017-06-07T04:35:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript_es6.png" alt=""></p><h1 id="ES6-13-Map-WeakMap-API"><a href="#ES6-13-Map-WeakMap-API" class="headerlink" title="[ES6] 13. Map, WeakMap API"></a>[ES6] 13. Map, WeakMap API</h1><h2 id="Map-Object"><a href="#Map-Object" class="headerlink" title="Map Object"></a>Map Object</h2><p>아시다시피, <code>Map</code>오브젝트는 key-value의 자료구조입니다. 기존 자바스크립트의 Object도 마찬가지로 key-value형식으로 구성되는데요, <code>Map</code>오브젝트는 <code>key</code>로 사용될 수 있는 타입이 다양하다는 것이 다른 점이라고 할 수 있습니다. 또한 <code>Map</code>오브젝트는 Object 오브젝트와는 달리 <code>이터러블 오브젝트</code>입니다. 그렇기 때문에 <code>for-of</code> statement를 사용하여 순회할 수 있습니다.</p><p><code>Map</code>오브젝트는 새로 추가되는 값의 <code>key</code>와 기존에 저장되어 있던 데이터의 <code>key</code>의 값이 동일하면 추가되지 않습니다. Java에서의 Map은 key를 hash값으로 저장하기 때문에 동일한 hash 값에 대해서 추가하지 않는데요, JavaScript에서는 조금 다른 방식으로 이를 판단합니다. key와 value가 저장될 때, 엔진이 별도의 일련 번호를 부여하여 이를 판단하게 됩니다. 또한 이 일련번호로 추가된 순서를 보장해줍니다.</p><h5 id="다음과-같이-정리할-수-있겠습니다"><a href="#다음과-같이-정리할-수-있겠습니다" class="headerlink" title="다음과 같이 정리할 수 있겠습니다."></a>다음과 같이 정리할 수 있겠습니다.</h5><ul><li>다양한 타입으로 <code>key</code>를 정의할 수 있다.</li><li>이터러블 오브젝트(iterable object)이다.</li><li>중복된 <code>key</code>를 추가할 수 없다.</li><li>중복된 <code>key</code>를 통해 추가하는 경우 해당 <code>key</code>의 <code>value</code>를 덮어쓴다.<ul><li>즉 기존 <code>key</code>의 순서를 유지한다.</li></ul></li><li>순서를 보장하는 자료구조이다.</li></ul><h4 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h4><p>예제 코드의 길이을 줄이기 위해 <code>Map</code>의 key와 value를 확인하기 위한 함수를 정의해두고 사용하겠습니다 :)<br><figure class="highlight js"><figcaption><span>utils.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printMap</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`key: <span class="subst">$&#123;key&#125;</span>, value: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Expected console</span></span><br><span class="line"><span class="comment">// key: something, value: something</span></span><br></pre></td></tr></table></figure></p><p><code>Map</code>은 이터러블 오브젝트이기 때문에 <code>[key, value]</code>형식으로 값을 받아서 사용할 수 있습니다.<br>물론 다음과 같이 함수를 정의할 수도 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(item));<span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Expected console</span></span><br><span class="line"><span class="comment">// [ 'something', 'something' ]</span></span><br></pre></td></tr></table></figure></p><p><code>for-of</code> statement에서 추출된 <code>item</code>은 <code>Array</code>입니다. 따라서 console에도 <code>Array</code> 타입으로 찍힙니다.</p><h3 id="new-Map"><a href="#new-Map" class="headerlink" title="new Map()"></a>new Map()</h3><p><code>Map</code> 오브젝트는 다음과 같이 생성가능합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newMap = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'1'</span>, <span class="string">'one'</span>],</span><br><span class="line">  [<span class="string">'2'</span>, <span class="string">'two'</span>],</span><br><span class="line">  [<span class="string">'3'</span>, <span class="string">'three'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">printMap(newMap);</span><br><span class="line"><span class="comment">// console</span></span><br><span class="line"><span class="comment">// key: 1, value: one</span></span><br><span class="line"><span class="comment">// key: 2, value: two</span></span><br><span class="line"><span class="comment">// key: 3, value: three</span></span><br></pre></td></tr></table></figure></p><h3 id="Map-prototype-set-get"><a href="#Map-prototype-set-get" class="headerlink" title="Map.prototype.set(), get()"></a>Map.prototype.set(), get()</h3><p>key와 value를 설정합니다. <code>set()</code> 메소드의 반환 값은 <code>set()</code> 메소드를 호출한 Map입니다. 그래서 chaining처럼 연속적으로 key와 value를 설정해줄 수 있습니다. <code>get()</code>메소드는 인자로 넘겨간 <code>key</code>값과 일치하는 <code>value</code>를 반환합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> webs = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">webs.set(<span class="string">'1'</span>, <span class="string">'React'</span>)</span><br><span class="line">    .set(<span class="string">'2'</span>, <span class="string">'Angular2'</span>)</span><br><span class="line">    .set(<span class="string">'3'</span>, <span class="string">'Vue'</span>)</span><br><span class="line">    .set(<span class="string">'2'</span>, <span class="string">'Redux'</span>);</span><br><span class="line"></span><br><span class="line">printMap(webs);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`webs.get('1'): <span class="subst">$&#123;webs.get(<span class="string">'1'</span>)&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// console</span></span><br><span class="line"><span class="comment">// key: 1, value: React</span></span><br><span class="line"><span class="comment">// key: 2, value: Redux</span></span><br><span class="line"><span class="comment">// key: 3, value: Vue</span></span><br><span class="line"><span class="comment">// webs.get('1'): React</span></span><br></pre></td></tr></table></figure></p><h3 id="Map-prototype-entries-keys-values"><a href="#Map-prototype-entries-keys-values" class="headerlink" title="Map.prototype.entries(), keys(), values()"></a>Map.prototype.entries(), keys(), values()</h3><p>각각 해당하는 이터레이터 오브젝트를 반환하는 메소드입니다.</p><h3 id="Map-prototype-has"><a href="#Map-prototype-has" class="headerlink" title="Map.prototype.has()"></a>Map.prototype.has()</h3><p><code>.has()</code>는 파라미터로 전달되는 <code>key</code>에 해당하는 값이 존재하는지에 대한 여부를 <code>boolean</code>으로 반환합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(webs.has(<span class="string">'1'</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(webs.has(<span class="string">'4'</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure></p><h3 id="Map-prototype-delete-clear"><a href="#Map-prototype-delete-clear" class="headerlink" title="Map.prototype.delete(), clear()"></a>Map.prototype.delete(), clear()</h3><p><code>.delete()</code>메소드의 파라미터로 특정 <code>key</code>값을 넘겨주면 해당 key와 value가 map에서 삭제됩니다. <code>.clear()</code>는 모든 <code>key</code>와 <code>value</code>를 삭제합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(webs.size);<span class="comment">// 3</span></span><br><span class="line">webs.delete(<span class="string">'1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(webs.size);<span class="comment">// 2</span></span><br><span class="line">printMap(webs);</span><br><span class="line"><span class="comment">// console</span></span><br><span class="line"><span class="comment">// key: 2, value: Redux</span></span><br><span class="line"><span class="comment">// key: 3, value: Vue</span></span><br><span class="line"></span><br><span class="line">webs.clear();</span><br><span class="line"><span class="built_in">console</span>.log(webs.size);<span class="comment">// 0</span></span><br><span class="line">printMap(webs);</span><br><span class="line"><span class="comment">// console</span></span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><h3 id="Map-prototype-forEach"><a href="#Map-prototype-forEach" class="headerlink" title="Map.prototype.forEach"></a>Map.prototype.forEach</h3><p><code>forEach</code>의 파라미터로는 콜백 함수를 넘겨줍니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">webs.forEach(<span class="function">(<span class="params">value, key, obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`key: <span class="subst">$&#123;key&#125;</span>, value: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// console</span></span><br><span class="line"><span class="comment">// key: 1, value: React</span></span><br><span class="line"><span class="comment">// key: 2, value: Redux</span></span><br><span class="line"><span class="comment">// key: 3, value: Vue</span></span><br></pre></td></tr></table></figure></p><p>넘겨지는 콜백 함수에는 세 가지 인자가 전달될 수 있습니다. key, value의 순서가 조금 다르다는 것에 주의하면 되겠네요. 세 번째 인자로는 콜백 함수 내부에서 <code>this</code>로 참조할 오브젝트가 전달됩니다.</p><h2 id="WeakMap-Object"><a href="#WeakMap-Object" class="headerlink" title="WeakMap Object"></a>WeakMap Object</h2><p><code>WeakMap</code> 오브젝트의 <code>key</code>에는 Object만 지정될 수 있습니다.</p><h3 id="GC와의-연관성"><a href="#GC와의-연관성" class="headerlink" title="GC와의 연관성"></a>GC와의 연관성</h3><p><code>key</code>로 사용하고 있던 Object 오브젝트가 메모리에서 사라질 경우, 즉 GC에 의해서 Garbage Colleting이 되면, 더이상 <code>value</code>의 <code>key</code>로서 역할을 수행하지 못합니다. 그렇기 때문에 이 key에 대한 내용을 삭제해줘야 한다. 메모리에서 사라진 <code>key</code>에 대해서 삭제하는 작업을 <code>WeakMap</code>을 사용하면 자동으로 해결됩니다.</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p><code>set()</code>, <code>get()</code>, <code>has()</code>, <code>delete()</code> 이 네 가지 API만 제공할 뿐, 열거를 위한 API는 제공하지 않습니다. 또한 <code>size</code> 프로퍼티가 존재하지 않기 때문에, 특정 시점의 <code>[key, value]</code>의 수를 알 수 없습니다. 이는 <code>WeakMap</code> 자체적으로 <code>key</code>를 제거하므로 값이 비결정적이기 때문에 API를 통해 제공되지 않습니다.</p><p><em>cf) <code>Set</code> 자료구조는 <code>Map</code>자료구조의 <code>key</code>에 <code>value</code>가 들어가게 되는 자료구조 입니다. 그러므로 <code>Map</code>과 거의 유사한 API를 제공하며 저장하는 방식의 차이만 존재합니다. 마찬가지로 <code>Set</code>과 <code>WeakSet</code>은 <code>Map</code>과 <code>WeakMap</code>의 관계와 동일합니다.</em></p><p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="noopener">Github Respository</a>에서 확인하실 수 있습니다.</p><p><em>13. end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javascript_es6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES6-13-Map-WeakMap-API&quot;&gt;&lt;a href=&quot;#ES6-13-Map-WeakMap-API&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="es6" scheme="https://jaeyeophan.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>[React] 2. Elements and Component</title>
    <link href="https://jaeyeophan.github.io/2017/05/19/React-2-Elements-and-Component/"/>
    <id>https://jaeyeophan.github.io/2017/05/19/React-2-Elements-and-Component/</id>
    <published>2017-05-19T05:02:02.000Z</published>
    <updated>2017-05-19T05:12:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/react_logo.png" alt=""></p><h1 id="React-2-Elements-and-Component"><a href="#React-2-Elements-and-Component" class="headerlink" title="[React] 2. Elements and Component"></a>[React] 2. Elements and Component</h1><h2 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h2><p><code>Element</code>는 화면에 표시되는 내용이며, React를 구성하고 있는 가장 작은 블록이라고 할 수 있습니다. 브라우저 요소인 DOM과 달리 React Element는 보다 적은 비용으로 생성할 수 있으며 React DOM은 React Element와 일치하도록 DOM을 업데이트 합니다.</p><h2 id="Rendering-Elements"><a href="#Rendering-Elements" class="headerlink" title="Rendering Elements"></a>Rendering Elements</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>위와 같은 html 코드가 존재합니다. 실제로 존재하는 코드는 <code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code>뿐이라고 볼 수 있습니다. React에서는 이것을 루트 노드(<code>Root DOM node</code>)라고 부릅니다. 이 태그 내부의 모든 element들은 <code>React DOM</code>에 의해 관리됩니다.</p><p>이전 포스팅에서 다뤘던 예제 코드를 다시 한번 살펴볼 차례입니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">    &lt;h1&gt;Hi!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure></p><p><code>루트 노드</code>를 select하여 내부에 작성한 element를 <code>render</code>할 수 있습니다.</p><p><br></p><h2 id="Immutable-Element"><a href="#Immutable-Element" class="headerlink" title="Immutable Element"></a>Immutable Element</h2><p>React element는 <code>immutable</code>입니다. element 렌더링한 후에는, 해당 element의 자식이나 attribute를 변경할 수 없습니다. React에서는 <strong>새로운 element를 전달</strong>하여 UI를 업데이트할 수 있습니다. 뭔가 너무 비효율적으로 보이지 않나요?</p><p>만약에 렌더링 된 element가 위의 예제처럼 짧지 않고 엄청 긴 element인데, 모든 element를 새로 전달해야 한다니. <strong>하지만</strong> React는 <strong>필요한 부분만 업데이트</strong> 합니다! React DOM은 새로 전달받은 element와 그 자식들을 이전의 element들과 비교하여 업데이트가 필요한 부분만 업데이트 합니다.</p><p>다음은 공식 홈페이지에 올라온 예제 코드입니다. 1초마다 <code>ReactDOM.render()</code>를 호출하여 UI를 업데이트합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p><p>개발자 도구를 열어서 확인해보면 <code>{new Date().toLocaleTimeString()}</code>부분만 업데이트 되는 것을 확인하실 수 있습니다.</p><p><br></p><h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><p>Component는 Element로 구성될 수 있습니다. React에서는 Component를 설계하고 이를 사용하여 UI를 독립적이고 재사용 가능한 부분으로 분할할 수 있습니다.</p><h3 id="Component-정의"><a href="#Component-정의" class="headerlink" title="Component 정의"></a>Component 정의</h3><p>Component는 ES6의 <code>class</code>문법을 사용하여 정의할 수 있고 <code>React.createClass</code> 문법을 통하여 정의할 수 있고, <code>stateless한 Component</code>에 대하여 <code>functional Component</code> 방식으로 정의할 수 있습니다.</p><h4 id="class문법을-사용하여-React-Component를-extends-하는-방식으로-컴포넌트를-정의"><a href="#class문법을-사용하여-React-Component를-extends-하는-방식으로-컴포넌트를-정의" class="headerlink" title="class문법을 사용하여 React.Component를 extends 하는 방식으로 컴포넌트를 정의."></a><code>class</code>문법을 사용하여 React.Component를 extends 하는 방식으로 컴포넌트를 정의.</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello React World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="일반-함수-or-Arrow-function-를-사용하여-컴포넌트를-정의"><a href="#일반-함수-or-Arrow-function-를-사용하여-컴포넌트를-정의" class="headerlink" title="일반 함수(or Arrow function)를 사용하여 컴포넌트를 정의"></a>일반 함수(or Arrow function)를 사용하여 컴포넌트를 정의</h4><p><a href="https://facebook.github.io/react/docs/context.html" target="_blank" rel="noopener">React 공식 문서</a>에서는 <code>stateless functional component</code>라는 용어로 해당 컴포넌트를 설명하고 있습니다. 개발자들 사이에서는 Pure Component, Dumb Component, Presential Component 라고 불리기도 합니다. UI를 구성하게 되는 Component 중 state가 없거나 LifeCycle API를 사용할 일이 없는 경우 함수를 사용하여 정의합니다. 즉, 렌더링의 역할만 수행하는 컴포넌트를 정의할 때 사용하는 방식이라고 할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> dumb = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">&lt;div&gt;...&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">export default dumb;</span></span><br></pre></td></tr></table></figure><p>위와 같이 Arrow function을 사용할 수도 있지만 일반 함수를 사용하는 경우에는 함수의 이름을 추론할 수 있기 때문에 airbnb convention에서는 다음과 같은 일반 함수 방식을 권장하고 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dumb</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Functional Component에 대해 자세히 설명된 포스팅입니다.<a href="https://velopert.com/2994" target="_blank" rel="noopener">Velopert-함수형 컴포넌트</a></p><ol start="3"><li><code>React.createElement()</code>를 사용하여 컴포넌트를 정의<br>사실 JSX로 작성된 element 또는 Component는 <code>React.createElement()</code>로 컴파일됩니다. React에서 일종의 sugar syntax를 제공하는 셈입니다. 즉 1번 case의 예제 코드는 다음과 같이 컴파일됩니다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> React.createElement(<span class="string">'div'</span>, <span class="literal">null</span>, <span class="string">`Hello React World`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>물론 위 코드도 <code>babel</code>에 의해 ES5 문법으로 transpile되겠지만 그 결과는 생략했습니다. 저번 포스팅에서도 언급된 <a href="https://github.com/apple77y/javascript/tree/master/react" target="_blank" rel="noopener">airbnb 에서 제공하는 React convention</a>에서는 JSX를 사용하고 있는데, 특별한 사유가 없다면 위 구문을 사용하지 말라고 합니다.</p><p>정의된 컴포넌트는 ReactDOM에서 render하거나 Component를 정의할 때 사용(composition)할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Hello/&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure></p><p>혹시 위 예제와 이전 예제에서 차이점을 발견하셨나요? 일부러 다르게 작성해보았습니다. 달라진 점은 바로 <code>extends</code>하고 있는 클래스가 달라진 점인데요, 이 부분은 어떻게 React 라이브러리를 import하느냐에 따라 달라질 수 있습니다. 바로 위의 예제 같은 경우에는 다음과 같이 import하여 사용할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br></pre></td></tr></table></figure></p><p><code>Component</code>만 import하지 않고 <code>React</code>까지 import하는 것은 바로 <code>React.createElement()</code>로 컴파일 되기 때문입니다. 마찬가지의 이유로 일반 함수로 Component를 정의할 때도 <code>React</code>를 import해줘야 합니다. <code>React.Component</code>보다는 <code>Component</code>만 extends하는 것이 타이핑도 줄고 더 깔끔하겠죠? 물론 snippet이 제공되서 직접 타이핑 할 필요는 없지만요 :)</p><p>Element에 대해서 그리고 Component를 어떻게 정의하는가에 대한 포스팅이었습니다. 감사합니다 :D</p><p>React와 관련된 포스트는 <a href="https://github.com/JaeYeopHan/react_tutorial_with_docs" target="_blank" rel="noopener">Github Repository</a>에서 실시간 피드를 받으실 수 있습니다.</p><p>Reference&gt;<br><a href="https://facebook.github.io/react/docs/react-without-jsx.html" target="_blank" rel="noopener">https://facebook.github.io/react/docs/react-without-jsx.html</a></p><p><em>2. end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/react_logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;React-2-Elements-and-Component&quot;&gt;&lt;a href=&quot;#React-2-Elements-and-Component&quot; class=&quot;he
      
    
    </summary>
    
      <category term="React" scheme="https://jaeyeophan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://jaeyeophan.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>[Tool] (번역)Babel에 대한 모든 것</title>
    <link href="https://jaeyeophan.github.io/2017/05/16/Everything-about-babel/"/>
    <id>https://jaeyeophan.github.io/2017/05/16/Everything-about-babel/</id>
    <published>2017-05-16T03:04:26.000Z</published>
    <updated>2017-05-16T03:06:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/babel.png" alt=""></p><h1 id="Tool-번역-Everything-you-need-to-know-about-BabelJS"><a href="#Tool-번역-Everything-you-need-to-know-about-BabelJS" class="headerlink" title="[Tool] (번역) Everything you need to know about BabelJS"></a>[Tool] (번역) Everything you need to know about BabelJS</h1><p>원본 : <a href="http://kleopetrov.me/2016/03/18/everything-about-babel/" target="_blank" rel="noopener">http://kleopetrov.me/2016/03/18/everything-about-babel/</a><br><em>이 글은 위 글을 기반으로 하여 나름 최신으로 업데이트하며 작성되었습니다 :) 물론, 본 저자의 동의하에 작성되었습니다.</em></p><h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p><code>Babel</code>은 아시다시피 ES6/ES7 코드를 ECMAScript5 코드로 transpiling 하기 위한 도구입니다. <code>Babel</code>은 다양한 작은 모듈들로 구성되어 있습니다. <code>Babel</code> 다양한 모듈을 담는 일종의 상자 역할을 하며 코드를 컴파일 하기 위해 작은 모듈들(ex. presets)을 사용합니다.</p><h2 id="Set-up"><a href="#Set-up" class="headerlink" title="Set up"></a>Set up</h2><p><code>babel</code> 학습을 위한 디렉토리를 구축합니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir babel-tutorial &amp;&amp; <span class="built_in">cd</span> babel-tutorial</span><br><span class="line">$ npm init</span><br><span class="line">$ mkdir src &amp;&amp; touch src/example.js</span><br><span class="line"><span class="comment"># Write some code of ES6 syntax in example.js</span></span><br></pre></td></tr></table></figure></p><h2 id="bael-cli"><a href="#bael-cli" class="headerlink" title="bael-cli"></a>bael-cli</h2><p><code>bael-cli</code>는 command line을 통해 코드를 transpile 할 수 있는 도구입니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev babel-cli</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ yarn add -D babel-cli</span><br></pre></td></tr></table></figure></p><p><code>-g</code> 옵션을 통해서 <code>bael-cli</code>를 전역에 설치할 수도 있지만 <code>--save-dev</code> 옵션으로 설치하는 이유는 하나의 컴퓨터에 존재하는 다른 프로젝트들이 각각 다른 버전의 babel에 의존성을 갖고 있을 수 있습니다. <code>--save-dev</code> 옵션을 통해서 이를 해결할 수 있습니다.</p><p>설치한 후 터미널에서 다음 명령을 실행할 수 있습니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ babel example.js --out-file compiled.js</span><br></pre></td></tr></table></figure></p><p>이 명령어는 다음과 같은 의미를 담고 있습니다.</p><ul><li><code>babel</code> - babel을 호출합니다.</li><li><code>example.js</code> - transpile 하고자하는 ES6/ES7의 자바스크립트 파일입니다.</li><li><code>--out-file</code> - babel에게 전달할 옵션을 명시합니다. 파일로 output을 지정하는 옵션입니다.<br><em>cf1&gt; shortcut으로 <code>-o</code> 옵션을 제공합니다.</em><br><em>cf2&gt; 이 이외에도 <code>--out-dir</code> or <code>-d</code> 옵션을 전달할 수 있습니다.</em></li><li><code>compiled.js</code> - 출력 파일의 이름을 명시합니다.</li></ul><p>npm script를 사용하여 해당 프로세스를 자동화 할 수 있습니다.<br><figure class="highlight"><figcaption><span>package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "build": "babel ./src -d ./lib -w"  </span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>and<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build</span><br></pre></td></tr></table></figure></p><p><code>src</code> 디렉토리 밑에 있는 파일을 transpile하여 <code>lib</code> 디렉토리 밑으로 output을 출력합니다. 이 때는 동일한 파일명이 사용됩니다. <code>-w</code> 옵션을 통해서 <code>src</code> 디렉토리 밑의 파일들이 변경될 때마다 자동으로 transpile 하도록 할 수 있습니다.</p><h2 id="babel-register"><a href="#babel-register" class="headerlink" title="babel-register"></a>babel-register</h2><p><code>babel-register</code>는 각각의 모듈을 결합할 때 사용되는 후크(Hook) 모듈입니다. <code>require</code> 메소드를 바인드하여 자바스크립트 코드를 transpile 시킵니다. <code>babel-register</code> 모듈은 production을 위한 모듈은 아닙니다. 예를 들어 mocha 기반의 ES6로 작성된 테스트 코드를 실행시키기 위해서는 다음과 같은 스크립트를 사용할 수 있습니다.<br><figure class="highlight"><figcaption><span>package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"script": &#123;</span><br><span class="line">  "test": "mocha --require babel-register"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Configuring-Babel"><a href="#Configuring-Babel" class="headerlink" title="Configuring Babel"></a>Configuring Babel</h2><p>처음에도 말했듯이, babel에게 어떠한 정보를 전달해주지 않는 한 babel은 아무 작업도 수행하지 않는 ‘상자’에 불과합니다. 방금 전에 살펴봤던 예제에서 아무 옵션없이 babel을 실행시키면 <code>src</code> 디렉토리에 있는 파일을 <code>lib</code> 디렉토리에 옮기는 작업만 수행하게 됩니다. 그렇기 때문에 babel에게 설정 정보를 전달해줘야 합니다. 이 정보는 <code>.babelrc</code>파일을 통해서 전달할 수 있습니다.</p><h3 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a>.babelrc</h3><p><code>.babelrc</code>파일은 babel을 설정하기 위한 파일입니다. 다음과 같이 구성되어 있습니다.<br><figure class="highlight js"><figcaption><span>.babelrc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [],</span><br><span class="line">  <span class="string">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>presets를 추가하기 위해서는 npm 설치가 필요합니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev babel-preset-es2015</span><br></pre></td></tr></table></figure></p><p>만약 React code를 transpile해야 한다면 다음과 같이 설치해줍니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev babel-preset-react</span><br></pre></td></tr></table></figure></p><p>그리고 <code>.babelrc</code>파일을 수정해줍니다.<br><figure class="highlight js"><figcaption><span>.babelrc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"es2015"</span>, <span class="string">"react"</span>],</span><br><span class="line">  <span class="string">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>자바스크립트 스펙으로 아직 확정되지 않은 <code>proposal 스펙</code>들이 존재합니다. 이들은 5개의 stage로 구분됩니다. babel에서는 각각의 stage에 대해서 preset을 제공합니다.</p><ul><li>babel-preset-stage-0</li><li>babel-preset-stage-1</li><li>babel-preset-stage-2</li><li>babel-preset-stage-3</li></ul><p><code>babel-preset-stage-4</code>는 <code>babel-preset-es2015</code>를 의미합니다. 각각의 stage에 대해서도 위와 같은 방법으로 설치하고 <code>.babelrc</code>파일을 수정하여 사용할 수 있습니다. 하지만 babel에서 이들을 모두 한번에 사용할 수 있도록 해주는 preset을 하나 제공했는데요, 바로 <code>babel-preset-env</code>입니다. 이 <code>preset</code>으로 모든 stage를 대체할 수 있습니다.</p><h2 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="babel-polyfill"></a>babel-polyfill</h2><p><code>babel-polyfill</code>은 ES6 환경을 제공해줍니다.<br>polyfill이 없는 경우를 예제를 통해 살펴봅니다.<br><figure class="highlight js"><figcaption><span>ES6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allAdd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).map(<span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>위 코드는 <code>babel</code>에 의해 다음과 같이 transpile됩니다.<br><figure class="highlight js"><figcaption><span>ES5</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allAdd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(argument).map(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Array.from()</code>은 ES6 syntax이므로 지원하지 않는 브라우저가 존재하기 때문에 위 코드는 transpile은 되었지만 모든 브라우저에서 작동하지 않습니다. 이 문제를 해결하기 위해서 <code>polyfill</code>을 사용해야 합니다. <code>polyfill</code>이란 code 조각으로 런타임에 존재하지 않는 native API의 복사본을 말합니다.</p><p><code>babel-polyfill</code> 사용을 위해서 다음과 같이 npm을 설치해줍니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev babel-polyfill</span><br></pre></td></tr></table></figure></p><p>그리고 해당 <code>polyfill</code>이 필요한 곳에서 <code>import</code>해줍니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span>;</span><br></pre></td></tr></table></figure></p><p>만약 webpack과 함께 사용한다면 entry point에 <code>babel-polyfill</code>을 추가해줍니다.<br><figure class="highlight js"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: [<span class="string">'babel-polyfill'</span>, <span class="string">'...'</span>]</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="babel-plugins"><a href="#babel-plugins" class="headerlink" title="babel-plugins"></a>babel-plugins</h2><p>아직 공식 스펙에서 지원하지 않은 기능들을 <code>transform-plugin</code>을 추가하여 사용할 수 있습니다. 여러 플러그인은 babel 공식 홈페이지에서 확인실 수 있습니다. 추가로 설치한 플러그인은 <code>plugins</code> 옵션으로 추가할 수 있습니다. <code>.babelrc</code>파일에서 설정해줄 수도 있고 Webpack이란 도구에서도 설정해줄 수 있습니다.</p><p>주로 <code>Webpack</code>이라는 도구와 함께 사용하는 babel에 대해서 알아봤는데요, webpack과 함께 사용하는 것에 대해서는 <a href="https://jaeyeophan.github.io/2017/05/05/webpack-tutorial-1/">Webpack2 입문 가이드</a> 포스팅에 자세히 나와있습니다 :)</p><p><em>end</em></p><h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h5><p><a href="https://babeljs.io/docs/plugins/" target="_blank" rel="noopener">https://babeljs.io/docs/plugins/</a><br><a href="http://kleopetrov.me/2016/03/18/everything-about-babel/" target="_blank" rel="noopener">http://kleopetrov.me/2016/03/18/everything-about-babel/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/babel.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Tool-번역-Everything-you-need-to-know-about-BabelJS&quot;&gt;&lt;a href=&quot;#Tool-번역-Everything-you-need
      
    
    </summary>
    
      <category term="Tool" scheme="https://jaeyeophan.github.io/categories/Tool/"/>
    
    
      <category term="tool" scheme="https://jaeyeophan.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>[React] 1. Introducing JSX and DOM</title>
    <link href="https://jaeyeophan.github.io/2017/05/15/React-1-Introducing-JSX-and-DOM/"/>
    <id>https://jaeyeophan.github.io/2017/05/15/React-1-Introducing-JSX-and-DOM/</id>
    <published>2017-05-15T04:15:27.000Z</published>
    <updated>2017-05-15T04:17:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/react_logo.png" alt=""></p><h1 id="React-1-Introducing-JSX-and-DOM"><a href="#React-1-Introducing-JSX-and-DOM" class="headerlink" title="[React] 1. Introducing JSX and DOM"></a>[React] 1. Introducing JSX and DOM</h1><h2 id="JSX란-무엇인가"><a href="#JSX란-무엇인가" class="headerlink" title="JSX란 무엇인가"></a>JSX란 무엇인가</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;h1&gt; Hello, world!&lt;/h1&gt;;</span><br></pre></td></tr></table></figure><p><code>JSX</code>라고 불리는 이 구문은 <code>string</code>도 아니고 <code>HTML</code>도 아닙니다. React 라이브러리에서 UI를 구성할 때 사용하는 구문으로 <strong>JavaScript의 extension</strong>이라고 할 수 있습니다.(물론, 사용하지 않을 수도 있습니다.) 타 프레임워크에서 사용했던 템플릿 엔진이라고 불리는 것들과 유사한 문법을 취하며(생김새만), JavaScript의 모든 기능을 제공합니다.</p><h2 id="JSX에-표현식-포함하기"><a href="#JSX에-표현식-포함하기" class="headerlink" title="JSX에 표현식 포함하기"></a>JSX에 표현식 포함하기</h2><p>자바스크립트의 표현식을 <code>{}</code>으로 묶어 JSX에 삽입할 수 있습니다. 기존의 템플릿 엔진에서 사용했던 방법과 비슷합니다. ES6에서 도입된 Template literal과도 비슷한 모습을 보입니다. 코드를 살펴보겠습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">    &lt;h1&gt;Hi!&lt;/h1&gt;</span><br><span class="line">);</span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br><span class="line"><span class="comment">//이 코드는 다음 포스팅에서 설명하며, 다음 예제 코드부터는 추가하지 않습니다.</span></span><br></pre></td></tr></table></figure></p><p>위와 같이 <code>element</code>라는 객체를 만들어서 <code>render()</code>메소드에 전달하여 렌더링할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">    &lt;h1&gt;<span class="number">1</span> + <span class="number">1</span> = &#123;<span class="number">1</span> + <span class="number">1</span>&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><p><code>{}</code>내부에서 자바스크립트 문법을 그대로 사용할 수도 있습니다.</p><h2 id="JSX는-결국-표현식입니다"><a href="#JSX는-결국-표현식입니다" class="headerlink" title="JSX는 결국 표현식입니다."></a>JSX는 결국 표현식입니다.</h2><p>컴파일이 끝나면 JSX 표현식은 일반 자바스크립트 <strong>객체</strong>가 됩니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">"api/get/someting"</span>;</span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">        &lt;img src=&#123;url&#125; /&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>JSX로 HTML 태그의 속성 값을 지정하고자 할 때는 <code>&quot;&quot;</code>(double quote)를 사용하지 않습니다. 사용하게 되면 JSX는 속성을 표현식이 아닌 문자열 리터럴로 인식하게 됩니다. 위 <code>img</code>태그의 경우처럼 태그가 비어있으면 <code>/&gt;</code>로 바로 닫아줘야 합니다. 자식 컴포넌트가 없거나 한 줄로 element 작성이 끝나는 경우에는 닫힘 태그로 self-close를 해줍니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hi&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h2&gt;1 + 1 = &#123;1 + 1&#125;&lt;/</span>h2&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><p>위의 같은 경우처럼 HTML의 문법을 사용하여 태그들을 계층화하여 구성할 수 있습니다. 하지만 이 때 주의할 사항이 한 가지 있습니다. 반드시 루트 노드(Root Node)로 <strong>하나의 노드를 지정</strong>해야 한다는 것입니다. ReactDOM은 오직 하나의 루트 노드만 렌더링하기 때문에 다음의 경우는 렌더링하지 못합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Error!</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">    &lt;h1&gt;Hi&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h2&gt;1 + 1 = &#123;1 + 1&#125;&lt;/</span>h2&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>동일 depth에 존재하는 element가 여러 개 존재하기 때문에 error가 발생하게 됩니다. 여러 개의 element들을 계층화하는 경우에는 이전의 예제 코드처럼 element들을 <code>div</code>태그로 감싸줘야 합니다.</p><p>기본적으로 <code>React DOM</code>은 렌더링하기 전에 JSX에 임베디드 된 모든 값을 이스케이프 처리합니다. 따라서 응용프로그램에 명시적으로 작성되지 않은 것을 삽입할 수 없고 XSS 공격을 방지할 수 있습니다.</p><h2 id="DOM-Elements"><a href="#DOM-Elements" class="headerlink" title="DOM Elements"></a>DOM Elements</h2><p>React는 성능과 크로스 브라우징 이슈를 해결하기 위해 브라우저로부터 독립적인 DOM 체계를 구축하고 있습니다. 그렇기 때문에 기존의 HTML 속성과 다른 점이 존재합니다.</p><h3 id="Camel-Case-Attributes"><a href="#Camel-Case-Attributes" class="headerlink" title="Camel-Case Attributes"></a>Camel-Case Attributes</h3><p>기본적으로 React에서는 모든 DOM 속성 또는 이벤트 핸들러를 Camel-case로 처리해야 합니다.</p><h3 id="다른-Attributes"><a href="#다른-Attributes" class="headerlink" title="다른 Attributes"></a>다른 Attributes</h3><h4 id="style"><a href="#style" class="headerlink" title="style"></a>style</h4><p><code>style</code> 속성은 camelCase를 기반으로 작성된 style JavaScript 객체로 설정합니다. 모든 DOM의 속성과 일치하여, 원래 CSS에서 사용하던 속성들을 camelCase로 변경해서 사용할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> headerStyle = &#123;</span><br><span class="line">  backgroundColor: <span class="string">'#EEE'</span>;</span><br><span class="line">  borderRadius: <span class="string">'5px'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div style=&#123;headerStyle&#125;&gt;Apply style <span class="keyword">as</span> camelCase&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><h4 id="className"><a href="#className" class="headerlink" title="className"></a>className</h4><p>기본적으로 HTML에서는 태그에 class를 지정해줄 때, <code>&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;</code>와 같은 방식을 사용했습니다. 그러나 React에서는 <code>className</code>이라는 속성을 통해 접근합니다. 다음과 같이 나타낼 수 있습니다.<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> container = (&lt;div className="container"&gt;&lt;/div&gt;);</span><br></pre></td></tr></table></figure></p><p>cf&gt; JSX 속성값에는 항상 <strong>double quote</strong>를 사용합니다. JSX 속성값을 제외한 나머지 경우에 대해서는 <strong>single quote</strong>를 사용합니다. 강제적인 것이 아닌 <a href="https://github.com/apple77y/javascript/tree/master/react" target="_blank" rel="noopener">airbnb 에서 제공하는 React convention</a> 입니다.</p><h4 id="onChange"><a href="#onChange" class="headerlink" title="onChange"></a>onChange</h4><p>이 속성을 가지고 있는 필드가 변경될 때마다 이벤트가 발생합니다. React에서는 실시간으로 사용자 입력을 처리하기 위한 방법으로 이벤트를 사용합니다.<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input onChange=&#123;<span class="keyword">this</span>.handleChange&#125;/&gt;</span><br></pre></td></tr></table></figure></p><p>위 예제 코드에서는 <code>input</code>태그에 event가 발생할 때마다 <code>handleChange</code>라는 메소드가 호출됩니다.</p><h4 id="checked"><a href="#checked" class="headerlink" title="checked"></a>checked</h4><p><code>input</code>태그 중 <code>checkbox</code>타입 또는 <code>radio</code>타입에서 지원되는 <code>checked</code> 속성입니다. 이 속성은 <code>controlled components</code>에 대해서 사용할 때 유용합니다.</p><h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><p><code>value</code> 속성은 <code>input</code>과 <code>textarea</code>태그에 대해 지원되는 속성입니다. 이 속성을 통하여 요소의 값을 설정할 수 있습니다. 하지만 이 값은 DOM의 값보다 우선됩니다. 그렇기 때문에 이 속성은 <code>controlled components</code>에 대해서 사용할 때 유용합니다. 초기값만 지정하려는 경우에는. 즉 <code>uncontrolled components</code>에 대해서는 <code>defaultValue</code> 속성을 사용할 수 있습니다.</p><h4 id="defaultValue-defaultChecked"><a href="#defaultValue-defaultChecked" class="headerlink" title="defaultValue, defaultChecked"></a>defaultValue, defaultChecked</h4><p><code>&lt;textarea&gt;</code>와 <code>&lt;input type=&#39;text&#39;&gt;</code>에 대해서 지원합니다. 또한 <code>type=checkbox</code>와 <code>type=radio</code>타입의 <code>&lt;input&gt;</code>태그에 대해서는 <code>defaultChecked</code>를 지원합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input  </span><br><span class="line">  type=<span class="string">"text"</span></span><br><span class="line">  defaultValue=<span class="string">"Jbee"</span>  </span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p><h4 id="htmlFor"><a href="#htmlFor" class="headerlink" title="htmlFor"></a>htmlFor</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">'name'</span>&gt;Name: &lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">'text'</span>/&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/"Warning: Unknown DOM property for. Did you mean htmlFor?</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/  in label</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/  in div"</span></span><br></pre></td></tr></table></figure><p><code>for</code>를 대체하는 <code>htmlFor</code>입니다. <code>for</code>속성을 사용하려고 하면 warning이 발생합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label htmlFor=<span class="string">'name'</span>&gt;Name: &lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">'text'</span>/&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><p>JavaScript 문법의 <code>for</code> 예약어와 겹치기 때문에 <code>htmlFor</code>가 생겨났습니다.</p><h4 id="dangerouslySetInnerHTML"><a href="#dangerouslySetInnerHTML" class="headerlink" title="dangerouslySetInnerHTML"></a>dangerouslySetInnerHTML</h4><p>이 속성은 DOM에서 사용하던 <code>innerHTML</code> 속성을 대체하기 위해 만들어졌습니다. 코드에서 HTML을 설정하는 것은 XSS 공격에 노출되기 쉽기 때문에 위험합니다. 그렇기 때문에 React에서는 이 속성 사용을 최소화하기 위해 장치를 마련해놓은 것입니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">innerHTML</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">__html</span>: <span class="string">'Dangerous inner html!'</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div dangerouslySetInnerHTML=&#123;innerHTML()&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>그럼에도 불구하고 <code>dangerouslySetInnerHTML</code> 속성을 사용하려면 위의 예제 코드와 같이 <code>__html</code>이라는 키 값과 함께 객체를 전달하여 사용할 수 있습니다.</p><p>React와 관련된 포스트는 <a href="https://github.com/JaeYeopHan/react_tutorial_with_docs" target="_blank" rel="noopener">Github Repository</a>에서 실시간 피드를 받으실 수 있습니다.</p><p><em>1. end</em></p><p>Reference&gt;<br><a href="https://facebook.github.io/react/docs/introducing-jsx.html" target="_blank" rel="noopener">React Documentation - Introducing JSX</a><br><a href="https://facebook.github.io/react/docs/dom-elements.html" target="_blank" rel="noopener">React Documentation - DOM Elements</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/react_logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;React-1-Introducing-JSX-and-DOM&quot;&gt;&lt;a href=&quot;#React-1-Introducing-JSX-and-DOM&quot; class=&quot;
      
    
    </summary>
    
      <category term="React" scheme="https://jaeyeophan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://jaeyeophan.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>[ES6] 12. Array API</title>
    <link href="https://jaeyeophan.github.io/2017/05/11/ES6-12-Array-API/"/>
    <id>https://jaeyeophan.github.io/2017/05/11/ES6-12-Array-API/</id>
    <published>2017-05-11T05:22:30.000Z</published>
    <updated>2017-05-12T05:32:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript_es6.png" alt=""></p><h1 id="ES6-12-Array-API"><a href="#ES6-12-Array-API" class="headerlink" title="[ES6] 12. Array API"></a>[ES6] 12. Array API</h1><p>JavaScript의 Array가 제공하는 API들에 대해서 살펴봅니다.</p><p><code>! Array.[methodName] vs Array.prototype.[methodName]</code><br>위 두 가지는 접근 방법이 다릅니다. 전자는 Array라는 오브젝트의 메소드이며 후자는 Array 타입의 모든 오브젝트에서 사용할 수 있는 메소드입니다. 간단한 예제를 통해 살펴보겠습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.from(<span class="string">'jbee'</span>); <span class="comment">//Error: arr.from is not a function</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//console</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure></p><p><code>Array.from()</code>과 <code>Array.prototype.values()</code> 둘 차이를 보여주는 예제였습니다 :D<br>그럼 이제 Array API들에 대해 알아봅시다.</p><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><ul><li><code>from()</code>은 유사배열(Array-Like-Object)을 배열로 바꿔줍니다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrLikeObj = &#123;<span class="string">'0'</span>: <span class="string">'zero'</span>, <span class="string">'1'</span>: <span class="string">'one'</span>, <span class="string">'2'</span>: <span class="string">'two'</span>, <span class="string">'length'</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> arrFrom = <span class="built_in">Array</span>.from(arrLikeObj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arrFrom);<span class="comment">//Array ['zero', 'one', 'two']</span></span><br></pre></td></tr></table></figure></li></ul><p>이 방법을 통해 <code>String</code>을 Array로 변경할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"Jbee"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(str));<span class="comment">//Array ['J', 'b', 'e', 'e']</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Array</span>(...str));<span class="comment">//Array ['J', 'b', 'e', 'e']</span></span><br></pre></td></tr></table></figure></p><p>ES6의 문법인 <code>Spread</code> 연산자를 사용해서도 가능합니다.<br><code>from()</code>을 다음과 같은 경우에 사용하면 유용할 것 같습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>);</span><br><span class="line"><span class="keyword">const</span> ulClassList = ul.classList;</span><br><span class="line"><span class="built_in">console</span>.log(ulClassList);</span><br><span class="line"><span class="comment">//["content-list", "foo", "bar", "baz", value: "content-list foo bar baz"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(ulClassList));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ulClassArr = <span class="built_in">Array</span>.from(ulClassList);</span><br><span class="line"><span class="built_in">console</span>.log(ulClassArr);<span class="comment">//["content-list", "foo", "bar", "baz"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(ulClassArr));<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>DOM의 <code>classList</code>는 유사배열(Array-Like-Object)로 반환이 됩니다. 이것을 <code>from()</code>을 사용하여 배열로 변경하여 Array API를 사용할 수 있도록 바꿔줄 수 있습니다.</p><ul><li><code>from()</code>의 두번째 인자로 콜백 함수를 넘겨줄 수 있습니다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrLikeObj = &#123;<span class="string">'0'</span>: <span class="number">100</span>, <span class="string">'1'</span>: <span class="number">101</span>, <span class="string">'2'</span>: <span class="number">102</span>, <span class="string">'length'</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> arrFromWithCb = <span class="built_in">Array</span>.from(arrLikeObj, elm =&gt; elm + <span class="number">100</span>);</span><br></pre></td></tr></table></figure></li></ul><p>Array로 변경된 각각의 엘리먼트들을 <code>elm</code>으로 받아서 100을 더해줍니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arrFromWithCb);<span class="comment">// [200, 201, 202]</span></span><br></pre></td></tr></table></figure></p><ul><li><code>from()</code>의 세번째 인자로는 두번째 인자로 넘겨준 콜백 함수에서 참조할 오브젝트를 넘겨줄 수 있습니다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrFromWithCb3 = <span class="built_in">Array</span>.from(arrLikeObj, <span class="function"><span class="keyword">function</span>(<span class="params">elm</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +elm + <span class="keyword">this</span>.value</span><br><span class="line">&#125;, &#123;<span class="attr">value</span>: <span class="number">200</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arrFromWithCb3);<span class="comment">//[300, 301, 302]</span></span><br></pre></td></tr></table></figure></li></ul><p><code>this</code>를 통해 참조하기 때문에 <code>arrow function</code>대신에 <strong>일반 함수</strong>를 사용하여 콜백 함수를 전달해줬습니다.</p><p><br></p><h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p><code>of()</code>로 전달되는 파라미터 값을 배열로 반환합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure></p><p>문자열도 <code>Spread</code> 연산자와 함께 사용하면 배열로 변환할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">`Jbee`</span>;</span><br><span class="line"><span class="keyword">const</span> strArr = <span class="built_in">Array</span>.of(...str);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(strArr));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(strArr);<span class="comment">//['J', 'b', 'e', 'e']</span></span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="Array-prototype-entries"><a href="#Array-prototype-entries" class="headerlink" title="Array.prototype.entries()"></a>Array.prototype.entries()</h2><p>Array 오브젝트의 iterator를 반환하는 메소드입니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;item&#125;</span>`</span>);<span class="comment">//1  2  3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [ key, value ] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> : <span class="subst">$&#123;value&#125;</span>`</span>);<span class="comment">//0:1  1:2  2:3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>key와 value는 각각 <code>Array.prototype.keys()</code>, <code>Array.prototype.values()</code>으로도 접근할 수 있습니다.</p><p><br></p><h2 id="Array-prototype-find"><a href="#Array-prototype-find" class="headerlink" title="Array.prototype.find()"></a>Array.prototype.find()</h2><p><code>find()</code> 파라미터로 콜백 함수를 넘겨서 처리한 내용을 반환합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'Jbee'</span>, <span class="string">'babel'</span>, <span class="string">'React'</span>]</span><br><span class="line"><span class="keyword">const</span> result = arr.find(<span class="function"><span class="params">elm</span> =&gt;</span> elm.includes(<span class="string">'e'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//'Jbee'</span></span><br></pre></td></tr></table></figure></p><p><code>e</code>를 포함하고 있는 문자열은 <code>&#39;Jbee&#39;</code>, <code>&#39;babel&#39;</code>, <code>&#39;React&#39;</code> 모두 해당하는데 <code>&#39;Jbee&#39;</code>만 반환했습니다. <code>find()</code>는 콜백 함수로 넘겨진 조건이 <code>true</code>되는 순간 반환하기 때문에 그 다음은 확인하지 않습니다.</p><p><code>Array.prototype.findIndex()</code>을 통해서 <code>value</code>가 아닌 <code>index</code>를 반환하게 하는 API도 존재합니다.</p><p><br></p><h2 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter()"></a>Array.prototype.filter()</h2><p>위 <code>find()</code>와는 다르게 다시 <code>Array</code>를 반환합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'Jbee'</span>, <span class="string">'babel'</span>, <span class="string">'React'</span>]</span><br><span class="line"><span class="keyword">const</span> result = arr.filter(<span class="function"><span class="params">elm</span> =&gt;</span> elm.includes(<span class="string">'e'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//'Jbee', 'babel', 'React'</span></span><br></pre></td></tr></table></figure></p><p>전달받은 콜백 함수로 각 엘리먼트들의 조건을 판단하여 <code>true</code>인 엘리먼트들에 대해서만 Array를 반환합니다.</p><p><br></p><h2 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h2><p>마찬가지로 다시 <code>Array</code>를 반환하는데, 배열의 엘리먼트에 접근하여 엘리먼트의 값을 reformat할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'Jbee'</span>, <span class="string">'babel'</span>, <span class="string">'React'</span>]</span><br><span class="line"><span class="keyword">const</span> result = arr.map(<span class="function">(<span class="params">elm, i</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;i&#125;</span>: <span class="subst">$&#123;elm&#125;</span>`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">// ['0: Jbee', '1: babel', '2: React']</span></span><br></pre></td></tr></table></figure></p><p>콜백 함수의 두번째 인자, <code>i</code>로 API를 호출한 배열의 인덱스에 접근할 수 있습니다.</p><h2 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce()"></a>Array.prototype.reduce()</h2><p>배열의 각 값에 대해(0부터 arr.length 순서로) 넘겨받은 콜백 함수의 결과를 하나의 값으로 반환합니다.<br>콜백 함수의 인자로는 총 네 가지를 받을 수 있습니다.<br><code>previousValue</code>, <code>currentValue</code>, <code>currentIndex</code>, <code>array</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">previousValue, currentValue, currentIndex, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> previousValue + currentValue;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p><p>arrow function을 사용하면 다음과 같습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + cur);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></p><p><br></p><p>Array.prototype에서 제공하는 <code>pop</code>, <code>push</code>, <code>splice</code>, <code>sort</code> 등은 배열 자체를 변화시킵니다.<br><code>concat</code>, <code>slice</code>, <code>join</code>, <code>indexOf</code> 함수들은 새로운 배열을 반환합니다.</p><h2 id="Array-prototype-splice-Array-prototype-slice"><a href="#Array-prototype-splice-Array-prototype-slice" class="headerlink" title="Array.prototype.splice(), Array.prototype.slice()"></a>Array.prototype.splice(), Array.prototype.slice()</h2><p><code>splice</code>에 전달되는 인자는 <code>startIndex</code>, <code>deleteCount</code>, <code>newItem</code> 총 세 개입니다.<br><figure class="highlight js"><figcaption><span>Array.prototype.splice()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [&#123;<span class="number">0</span>: <span class="string">'zero'</span>&#125;, &#123;<span class="number">1</span>: <span class="string">'one'</span>&#125;, &#123;<span class="number">2</span>: <span class="string">'two'</span>&#125;];</span><br><span class="line"><span class="keyword">const</span> result = arr.splice(<span class="number">0</span>, <span class="number">1</span>, &#123;<span class="number">4</span>: <span class="string">'foour'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">// [&#123;4: 'foour'&#125;, &#123;1: 'one'&#125;, &#123;2: 'two'&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">// [&#123;0: 'zero'&#125;]</span></span><br></pre></td></tr></table></figure></p><p><code>slice</code>에 전달되는 인자는 <code>startIndex</code>, <code>deleteCount</code> 총 두 개입니다.<br><figure class="highlight js"><figcaption><span>Array.prototype.slice()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [&#123;<span class="number">0</span>: <span class="string">'zero'</span>&#125;, &#123;<span class="number">1</span>: <span class="string">'one'</span>&#125;, &#123;<span class="number">2</span>: <span class="string">'two'</span>&#125;];</span><br><span class="line"><span class="keyword">const</span> newArr = arr.slice(<span class="number">0</span>, arr.length);</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">// [&#123;0: 'zero'&#125;, &#123;1: 'one'&#125;, &#123;2: 'two'&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr);<span class="comment">// [&#123;1: 'one'&#125;, &#123;1: 'one'&#125;, &#123;2: 'two'&#125;] is new Array</span></span><br></pre></td></tr></table></figure></p><p>기존의 <code>arr</code>에는 변경사항이 존재하지 않고 새로운 Array 오브젝트가 반환된 것을 확인하실 수 있습니다.</p><p><br></p><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>Array에서 제공하는 기본적인 메소드들에 대해서 알아봤습니다. 포스트에서 소개한 메소드 이외에도 여러 메소드들이 존재하는데요, 잘 사용하면 보다 깔끔한 코드를 작성할 수 있겠습니다 :)</p><p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="noopener">Github Respository</a>에서 확인하실 수 있습니다.</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/splice</a><br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/slice</a><br><a href="http://programmingsummaries.tistory.com/357" target="_blank" rel="noopener">http://programmingsummaries.tistory.com/357</a></p><p><em>12. end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javascript_es6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES6-12-Array-API&quot;&gt;&lt;a href=&quot;#ES6-12-Array-API&quot; class=&quot;headerlink&quot; title=&quot;[ES6] 1
      
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="es6" scheme="https://jaeyeophan.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>Webpack2, 입문 가이드 3편, Option</title>
    <link href="https://jaeyeophan.github.io/2017/05/08/webpack-tutorial-3/"/>
    <id>https://jaeyeophan.github.io/2017/05/08/webpack-tutorial-3/</id>
    <published>2017-05-08T08:06:52.000Z</published>
    <updated>2017-05-08T08:10:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/webpack.png" alt=""></p><h1 id="Tool-Webpack2-입문-가이드-3편-Option"><a href="#Tool-Webpack2-입문-가이드-3편-Option" class="headerlink" title="[Tool] Webpack2, 입문 가이드 3편, Option"></a>[Tool] Webpack2, 입문 가이드 3편, Option</h1><p><a href="https://jaeyeophan.github.io/2017/05/05/webpack-tutorial-1/">&gt; Webpack2, 입문 가이드 1편 &gt;</a><br><a href="https://jaeyeophan.github.io/2017/05/06/webpack-tutorial-2/">&gt; Webpack2, 입문 가이드 2편 &gt;</a></p><h2 id="Config’s-other-options"><a href="#Config’s-other-options" class="headerlink" title="Config’s other options"></a>Config’s other options</h2><p>기본적인 네 가지 옵션, <code>entry</code>, <code>output</code>, <code>module</code>, <code>plugin</code>에 대해 알아봤습니다. 이번 포스팅에서는 좀 더 나아가 추가적인 옵션들도 살펴봅니다.<br><br></p><h3 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h3><p>2편에서 <code>HMR(HotModuleReplacement)</code> 플러그인을 사용할 때 추가해줬던 <code>webpack-dev-server</code>와 관련된 옵션입니다. 여러 가지 추가 설정이 존재합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    inline: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">4000</span>,</span><br><span class="line">    compress: <span class="literal">true</span>,</span><br><span class="line">    publicPath: <span class="string">'/dist/'</span>,</span><br><span class="line">    contentBase: path.join(__dirname, <span class="string">'/dist/'</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="pulicPath-‘-dirname-‘"><a href="#pulicPath-‘-dirname-‘" class="headerlink" title="pulicPath: ‘/[dirname]/‘"></a>pulicPath: ‘/[dirname]/‘</h4><p><code>pulicPath</code>를 지정해주지 않았다면 default path는 ‘/‘로 설정되어 있습니다. 그렇기 때문에 <code>$ webpack-dev-server</code> 명령어를 통해 실행하면 다음과 같은 메세지가 나타납니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ webpack output is served from /</span><br></pre></td></tr></table></figure></p><p>이것은 bundle된 결과 파일들이 <code>http://localhost:[portNumber]</code>에 served되었다는 것을 의미합니다. <code>publicPath</code> 설정으로 이를 지정할 수 있으며 그 값은 예제처럼 <code>/</code>로 둘러쌓여 있어야 합니다. 이 값을 따로 설정해주면 live reloading 기능이 기존의 url로는 안되겠죠? <code>http://localhost:[portNumber]/[publicpath]/</code>로 접근해야 예전처럼 live reloading 기능을 사용하실 수 있습니다.</p><p>이외에도 <code>port</code>, <code>host</code>, <code>proxy</code> 등 다양한 옵션들이 존재합니다. <code>devServer</code>와 관련된 다양한 옵션은 다음 <a href="https://webpack.js.org/configuration/dev-server/" target="_blank" rel="noopener">링크</a>에서 볼 수 있습니다.<br><br></p><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>entry point에서 사용할 절대 경로(absolute path)를 지정할 때 사용합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  context: path.join(__dirname),</span><br><span class="line">  [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h3><h4 id="reslove-alias"><a href="#reslove-alias" class="headerlink" title="reslove.alias"></a>reslove.alias</h4><p>path에 alias를 설정하여 모듈을 <code>import</code>할 때, 보다 간편히가 코드를 작성할 수 있습니다. 다음과 같은 import 구문이 있다고 가정해봅니다.<br><figure class="highlight js"><figcaption><span>app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Utility &#125; <span class="keyword">from</span> <span class="string">'../../../../utilities/utility'</span>;</span><br></pre></td></tr></table></figure></p><p>상대경로로 타고 타고 올라가서 해당 경로를 찾아야 하는 불편함이 존재합니다. 이를 해결하기 위해 alias를 사용하면 다음과 같은 코드로 재탄생합니다.<br><figure class="highlight js"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  Utilities: path.join(__dirname, <span class="string">'src/utilities'</span>);</span><br><span class="line">  post$: path.join(__dirname, <span class="string">'src/service/post.js'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>path를 마치 상수처럼 선언하여 프로젝트에서 사용할 수 있도록 해줍니다.<br><figure class="highlight js"><figcaption><span>app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Utility &#125; <span class="keyword">from</span> <span class="string">'Utilities/utility'</span>;</span><br><span class="line"><span class="keyword">import</span> post <span class="keyword">from</span> <span class="string">'post'</span>;</span><br></pre></td></tr></table></figure></p><p>디렉토리에 대해서 그리고 파일에 대해서 path를 지정했습니다. 위의 예제처럼 특정 파일에 대해서 alias를 생성할 때, 생성하고자 하는 alias 뒤에 <code>$</code>를 붙여주면 해당 path뒤로 추가적인 path를 설정할 수 없습니다.</p><p><code>resolve</code>와 관련된 다양한 옵션은 다음 <a href="https://webpack.js.org/configuration/resolve/" target="_blank" rel="noopener">링크</a>에서 볼 수 있습니다.</p><p><br></p><h3 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h3><p>webpack에서 제공하는 기술 중, <code>SourceMaps</code>이라는 기술이 있습니다. <code>SourceMaps</code>은 하나의 파일로 병합되거나 압축된 자바스크립트, CSS 파일을 원형으로 분리(path 구조까지)하여, 복원해주는 기술입니다.<br><code>devtool</code> 옵션은 <code>SourceMaps</code>을 생성할지 말지를 결정하는 옵션입니다. 에러가 발생할 때, 어느 부분에서 에러가 발생했는지 알아야 디버깅이 수월할텐데요, <code>source map</code>은 bundle된 코드에서 발생한 에러를 기존의 코드와 연결시켜주는 역할을 합니다. <code>devtool</code>에서 설정할 수 있는 옵션들에는 여러 가지가 존재하며 각각의 장단점이 존재합니다.</p><table><thead><tr><th>devtool</th><th>build</th><th>rebuild</th><th>production</th></tr></thead><tbody><tr><td>eval</td><td>+++</td><td>+++</td><td>no</td></tr><tr><td>cheap-eval-source-map</td><td>+</td><td>++</td><td>no</td></tr><tr><td>cheap-source-map</td><td>+</td><td>0</td><td>yes</td></tr><tr><td>cheap-module-eval-source-map</td><td>0</td><td>++</td><td>no</td></tr><tr><td>cheap-module-source-map</td><td>0</td><td>-</td><td>yes</td></tr><tr><td>eval-source-map</td><td>- -</td><td>+</td><td>no</td></tr><tr><td>source-map</td><td>- -</td><td>- -</td><td>yes</td></tr><tr><td>nosources-source-map</td><td>- -</td><td>- -</td><td>yes</td></tr></tbody></table><p><a href="https://webpack.js.org/configuration/devtool/" target="_blank" rel="noopener">https://webpack.js.org/configuration/devtool/</a></p><p>Webpack2 공식 홈페이지에서 소개하고 있는 devtool 옵션들입니다. <code>+</code>는 작업 속도가 빠르다는 것을 의마하며 <code>-</code>는 그 반대로 느린 것을 의미합니다. 이 많은 옵션 중에서 개발할 때 적합한 옵션은 무엇이고, 배포할 때 적합한 옵션은 무엇일까요?</p><p>개발 시에는 얼머나 용량을 줄이느냐보다 어디에서 에러가 발생했는지 알 수 있어야 하므로 로그가 상세히 나타나는 옵션을 선택해야하며 생산성을 높이기 위해 빌드 시간이 짧아야 합니다. 배포용은 용량이 우선적으로 작아야 겠죠? 저는 다음과 같이 정리해보았습니다.  </p><p><em>Option for development)</em></p><ul><li><code>cheap-module-eval-source-map</code></li><li><code>inline-source-map</code></li><li><code>eval-source-map</code></li></ul><p><em>Option for production)</em></p><ul><li><code>cheap-module-source-map</code></li></ul><p>각 옵션들에 대한 상세한 내용은 링크를 첨부합니다.<br><a href="http://cheng.logdown.com/posts/2016/03/25/679045" target="_blank" rel="noopener">&gt; Webpack devtool source map&gt;</a><br><a href="https://perfectacle.github.io/2016/11/14/Webpack-devtool-option-Performance/" target="_blank" rel="noopener">&gt; (webpack) devtool 옵션 퍼포먼스&gt;</a></p><p><br></p><h3 id="env-EnvironmentPlugin"><a href="#env-EnvironmentPlugin" class="headerlink" title="env, EnvironmentPlugin"></a>env, EnvironmentPlugin</h3><p>환경에 따라 webpack이 수행해줘야 할 작업이 달라질 수 있습니다. 여기서 말하는 <code>환경</code>이란, 개발을 진행하는 과정에서 webpack 작업인지, 배포하는 과정에서의 작업인지로 구분할 수 있습니다. webpack이 작동하는 환경은 기본적으로 <code>development</code>라는 string value로 설정되어 있습니다.<br><figure class="highlight js"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.EnvironmentPlugin(&#123;</span><br><span class="line">  NODE_ENV: <span class="string">'development'</span>,</span><br><span class="line">  DEBUG: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>bundle된 파일 전체에서 사용할 수 있는 상수를 만들어서 환경 변수로 사용할 수 있습니다. 이 때 <code>DefinePlugin</code>을 사용할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">  <span class="string">'process.env.NODE_ENV'</span> : <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV),</span><br><span class="line">  <span class="string">'process.env.DEBUG'</span> : <span class="built_in">JSON</span>.stringify(process.env.DEBUG)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>특정한 환경을 위한 코드를 작성하는 경우, process.env.NODE_ENV를 통해 NODE_ENV의 값을 확인할 수 있습니다. 환경 변수의 값을 확인하는 작업은 성능 저하를 유발하므로 이러한 작업은 낮은 빈도로 실행해야 한다는 점에 주의하세오.</p><p><br></p><h4 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h4><p>이외에도 많은 옵션들이 존재합니다. <a href="https://webpack.js.org/configuration/" target="_blank" rel="noopener">Webpack 공식 홈페이지</a>에서 확인하실 수 있습니다 :)</p><p>포스팅에서 사용된 예제 코드와 webpack tutorial 시리즈 전체는 <a href="https://github.com/JaeYeopHan/webpack2_tutorial" target="_blank" rel="noopener">Github repository</a>에서 확인하실 수 있습니다 :D</p><p><em>3편 end</em></p><p>Reference<br><a href="https://webpack.js.org/configuration/" target="_blank" rel="noopener">Webpack configuration</a><br><a href="https://perfectacle.github.io/2016/11/14/Webpack-devtool-option-Performance/" target="_blank" rel="noopener">Webpack devtool 옵션 퍼포먼스</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/webpack.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Tool-Webpack2-입문-가이드-3편-Option&quot;&gt;&lt;a href=&quot;#Tool-Webpack2-입문-가이드-3편-Option&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="Tool" scheme="https://jaeyeophan.github.io/categories/Tool/"/>
    
    
      <category term="tool" scheme="https://jaeyeophan.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>Webpack2, 입문 가이드 2편: Plugins</title>
    <link href="https://jaeyeophan.github.io/2017/05/06/webpack-tutorial-2/"/>
    <id>https://jaeyeophan.github.io/2017/05/06/webpack-tutorial-2/</id>
    <published>2017-05-06T03:15:26.000Z</published>
    <updated>2017-05-08T08:11:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/webpack.png" alt=""></p><h1 id="Tool-Webpack2-입문-가이드-2편"><a href="#Tool-Webpack2-입문-가이드-2편" class="headerlink" title="[Tool] Webpack2, 입문 가이드 2편"></a>[Tool] Webpack2, 입문 가이드 2편</h1><p><a href="https://jaeyeophan.github.io/2017/05/05/webpack-tutorial-1/">&gt; Webpack2, 입문 가이드 1편 &gt;</a></p><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>플러그인을 통해 코드를 난독화(Uglify)하여 압축할 수 있고, 공통된 코드(Common chunk)를 분리할 수 있고, 코드의 변경사항을 파악하게 하여 자동으로 재실행시킬 수 있습니다. 이외에도 여러 가지 훌륭한 기능들이 존재하는데요, Webpack이 제공하는 플러그인과 외부 플러그인들 중에서 일부에 대해 알아봅니다.</p><p>Webpack에 내장된 플러그인에는 <code>webpack.[plugin-name]</code>을 통해 접근할 수 있습니다.</p><figure class="highlight js"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: [...],</span><br><span class="line">  output: [...],</span><br><span class="line">  <span class="built_in">module</span>: [...],</span><br><span class="line">  plugins: [...]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><p><code>plugins</code>에는 배열을 통하여 여러 플러그인을 설정할 수 있습니다. 1편에서와는 다르게 기본 구조에서 코드 한 줄이 추가되었는데요, webpack이 제공하는 플러그인을 사용하기 위해서 <code>webpack</code>이란 모듈을 불러와야 합니다.</p><p><br></p><h3 id="UglifyJsPlugin"><a href="#UglifyJsPlugin" class="headerlink" title="UglifyJsPlugin"></a>UglifyJsPlugin</h3><p>webpack을 통해 작업을 수행할 때, 코드를 압축하여 난독화시켜주는 플러그인입니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  [...]</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">//new webpack.optimize.UglifyJsPlugin()</span></span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">      compressor: &#123;</span><br><span class="line">        warnings: <span class="literal">false</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>UglifyJsPlugin</code>은 <code>optimize</code>로 접근할 수 있습니다. config파일 설정을 마쳤으면 <code>$ webpack</code> 명령어를 수행해줍니다. 그리고 나서 <code>dist/bundle.js</code> 파일을 확인해봅니다. 코드가 한 줄로 알아볼 수 없게 압축되어 있는 것을 확인하실 수 있습니다 :) 해당 플러그인을 생성할 때, 파라미터로 옵션을 전달할 수 있습니다. 이 예제에서는 압축 시 발생할 수 있는 경고를 무시하는 옵션을 추가했습니다.</p><p><br></p><h3 id="CommonChunkPlugin"><a href="#CommonChunkPlugin" class="headerlink" title="CommonChunkPlugin"></a>CommonChunkPlugin</h3><p>entry point가 여러 개 설정되어있는 경우, 공통된 모듈 또는 라이브러리를 별도의 chunk로 분리하여 bundle 작업을 수행할 때 사용할 수 있는 plugin입니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  [...]</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">"commons"</span>,</span><br><span class="line">      filename: <span class="string">"commons.js"</span>,</span><br><span class="line">      minChunks: <span class="literal">Infinity</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>name</code>, <code>filename</code>, <code>minChunks</code> 세 가지 옵션만 설정해봤습니다. <code>name</code>은 생성될 chunk의 이름을 지정합니다. 생성될 파일의 이름인 <code>filename</code>을 설정하고 <code>minChunks</code>라는 옵션을 통해서 <code>commons</code>로 묶일 최소한의 module 개수를 설정할 수 있습니다. <code>Infinity</code>라는 설정값을 주면 공통으로 묶을 수 있는 모듈들을 모두 commons로 묶습니다. <code>number</code> or <code>function</code>을 지정하여 customize할 수 있습니다.</p><p>위 설정을 마치고 <code>$webpack</code> 명령어를 실행하게 되면 <code>commons.js</code>파일과 <code>bundle.js</code>파일 두 파일이 생성됩니다. 이를 <code>index.html</code>에서 로드를 할 때, 다음과 같이 <code>commons.js</code>파일을 먼저 로드해야 한다는 점 주의하시면 되겠습니다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/commons.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>추가적인 다른 옵션은 다음 <a href="https://webpack.js.org/plugins/commons-chunk-plugin/" target="_blank" rel="noopener">링크</a>를 참고하시면 됩니다 :)</p><p><br></p><h3 id="ExtractTextPlugin"><a href="#ExtractTextPlugin" class="headerlink" title="ExtractTextPlugin"></a>ExtractTextPlugin</h3><p>이 플러그인은 따로 설치가 필요합니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev extract-text-webpack-plugin</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ yarn add -D extract-text-webpack-plugin</span><br></pre></td></tr></table></figure></p><p>webpack을 통해서 css를 로드하는 경우 발생하는 문제점은 js와 함께 로드된다는 것입니다. 기존에는 js와 따로 css만 로드되었습니다. 이 플러그인이 bundle되는 과정에서 js파일과 css파일을 분리해줍니다. 분리된 css bundle 파일은 병렬로 로드가 되어 사용자 입장에서는 더 빠르게 완성된 웹 페이지 화면을 볼 수 있게 됩니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  [...]</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="string">"style-loader"</span>,</span><br><span class="line">          use: <span class="string">"css-loader"</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"styles.css"</span>),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>module</code> 옵션에서 <code>style-loader</code>를 사용하는 설정 코드가 변경되었습니다. <code>plugins</code> 옵션에 해당 플러그인을 추가해주고 파라미터로 bundle된 output의 filename을 설정해줍니다. <code>$ webpack</code> 명령어를 실행해주면 dist 폴더에 <code>styles.css</code>파일이 생성된 것을 확인할 수 있습니다.</p><p>추가적인 다른 옵션은 다음 <a href="https://webpack.js.org/plugins/extract-text-webpack-plugin/" target="_blank" rel="noopener">링크</a>를 참고하시면 됩니다 :)</p><p><br></p><h3 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h3><p>따로 분리하여 bundle한 css파일과 js파일을 각각 html 파일에 link 태그와 script태그로 추가해줘야 합니다. 이 플러그인은 이것을 자동화해줍니다. 이 플러그인도 마찬가지로 따로 설치가 필요합니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev html-webpack-plugin</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ yarn add -D html-webpack-plugin</span><br></pre></td></tr></table></figure></p><p>그리고 plugin에 추가해줍니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./index.html'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>template 옵션에는 해당하는 html파일의 패스를 입력해주시면 됩니다. <code>$ webpack</code> 명령어를 실행해주면 dist 폴더에 <code>index.html</code>파일이 생성되고 자동으로 bundle된 css파일과 js파일이 link태그와 script태그로 추가된 것을 확인하실 수 있습니다. !webpack에 의해서 자동으로 추가되므로 <strong>우리가 작성하는 </strong> html 파일에는 script태그와 link태그를 작성할 필요가 없습니다. 오히려 작성하면 두 번 load를 하게 되므로 성능상 좋지 않습니다.</p><p>사실 이 플러그인은 우리의 귀차니즘을 해결해주는 것보다 더 훌륭한 존재의 이유가 있습니다. 그것을 바로 <code>caching</code>할 때, bundle 작업의 결과물로 hash 값을 파일 명이 쓰게 되는데, 이 hash 값을 개발자가 예측할 수 없다는 것입니다. 그렇기 때문에 개발자가 추가하지 못하는 것을 webpack이 대신 해줍니다 :) (webpack에서의 caching에 대해서는 추후 포스팅에서 다룹니다.)</p><p>추가적인 다른 옵션은 다음 <a href="https://webpack.js.org/plugins/html-webpack-plugin/" target="_blank" rel="noopener">링크</a>를 참고하시면 됩니다 :)</p><p><br></p><h3 id="HotModuleReplacementPlugin"><a href="#HotModuleReplacementPlugin" class="headerlink" title="HotModuleReplacementPlugin"></a>HotModuleReplacementPlugin</h3><p><code>HMR</code>이라는 약자로도 많이 불리는 플러그인 입니다. 개발 생산성을 극대화(?)시켜주는 플러그인이라고 할 수 있습니다. 이 플러그인 없이 <code>$ webpack-dev-server --watch</code> 명령어를 실행하여 작업을 하고 저장을 해도 자동 reload가 안됩니다. 다음과 같이 추가해줍니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  [...]</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>사실 이 플러그인을 추가해도 reload는 되지 않고 webpack 작업만 자동으로 실행됩니다. 웹 브라우저에 자동으로 reload를 시켜주려면 한 가지 설정이 추가적으로 필요합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  [...]</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">    hot: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>$ webpack-dev-server --watch</code>를 실행하고 js파일을 수정하고 저장을 해주면 자동으로 웹브라우저에 reload가 되는 것을 확인하실 수 있습니다! (<code>devServer</code>는 config에서 설정할 수 있는 또다른 옵션입니다.)</p><p><br></p><h3 id="NoEmitOnErrorsPlugin"><a href="#NoEmitOnErrorsPlugin" class="headerlink" title="NoEmitOnErrorsPlugin"></a>NoEmitOnErrorsPlugin</h3><p>컴파일 도중 오류가 발생한 리소스들은 제외하고 작업을 진행하여 bundling하도록 합니다. 참고로 <code>NoErrosPlugin</code>은 deprecated되었습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.NoEmitOnErrorsPlugin()</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h4><p>이외에도 많은 플러그인들이 존재합니다. <a href="https://github.com/webpack-contrib/awesome-webpack" target="_blank" rel="noopener">awsome-webpack</a>에서 확인하실 수 있습니다 :)<br>다음 포스팅에서는 config파일의 기본적인 옵션을 제외한 다른 옵션들에 대해 알아보겠습니다. :)</p><p>포스팅에서 사용된 예제 코드는 <a href="https://github.com/JaeYeopHan/webpack2_tutorial" target="_blank" rel="noopener">Github repository</a>에서 확인하실 수 있습니다 :D</p><p><em>2편 end</em></p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="https://webpack.js.org/plugins/" target="_blank" rel="noopener">Webpack Plugins</a><br><a href="https://webpack.js.org/configuration/plugins/" target="_blank" rel="noopener">Webpck official DOCS</a><br><a href="https://webpack.js.org/concepts/hot-module-replacement/" target="_blank" rel="noopener">Webpck official CONCEPT</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/webpack.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Tool-Webpack2-입문-가이드-2편&quot;&gt;&lt;a href=&quot;#Tool-Webpack2-입문-가이드-2편&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="Tool" scheme="https://jaeyeophan.github.io/categories/Tool/"/>
    
    
      <category term="tool" scheme="https://jaeyeophan.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>Webpack2, 입문 가이드 1편</title>
    <link href="https://jaeyeophan.github.io/2017/05/05/webpack-tutorial-1/"/>
    <id>https://jaeyeophan.github.io/2017/05/05/webpack-tutorial-1/</id>
    <published>2017-05-05T08:58:38.000Z</published>
    <updated>2017-05-05T09:38:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/webpack.png" alt=""></p><h1 id="Tool-Webpack2-입문-가이드-1편"><a href="#Tool-Webpack2-입문-가이드-1편" class="headerlink" title="[Tool] Webpack2, 입문 가이드 1편"></a>[Tool] Webpack2, 입문 가이드 1편</h1><h2 id="Webpack이란-무엇인가"><a href="#Webpack이란-무엇인가" class="headerlink" title="Webpack이란 무엇인가"></a>Webpack이란 무엇인가</h2><p>너무 유명해져서 더이상의 말은 필요없을 것 같습니다:) 이에 대해 잘 정리해놓은 문서도 정말 많구요! 이 포스팅에서는 <code>webpack.config.js</code> 파일의 구조에 집중할 예정입니다. 아래 Reference의 링크를 참고해주세요!</p><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g webpack webpack-dev-server</span><br><span class="line">$ npm install --save-dev webpack webpack-dev-server</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ yarn global add webpack webpack-dev-server</span><br><span class="line">$ yarn add -D webpack webpack-dev-server</span><br></pre></td></tr></table></figure><p>Webpack이 제공하는 기능 중 로컬에서도 사용해야 하는 플러그인이 존재하므로 로컬에도 설치해줍니다. 그리고 webpack의 결과물을 확인하기 위해 서버를 띄워야하므로 <code>webpack-dev-server</code>도 함께 설치해줍니다. webpack 실행은 <code>$ webpack</code>이란 명령어로, webpack-dev-server 실행은 <code>$ webpack-dev-server</code>라는 명령어로 가능합니다 :)<br>이제 config 파일을 파헤쳐봅니다…</p><h2 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h2><figure class="highlight js"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: [...],</span><br><span class="line">  output: [...],</span><br><span class="line">  <span class="built_in">module</span>: [...],</span><br><span class="line">  plugins: [...]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><p><code>webpack.config.js</code> 파일은 복잡해보이지만, <code>config</code> 객체를 정의하고 <code>module.exports</code> 구문을 통해 노출시킵니다. 모든 config 파일은 이런 구조로 <code>entry</code>, <code>output</code>, <code>module</code>, <code>plugins</code> 네 가지 설정을 <strong>기본적인</strong> 옵션을 제공합니다. <code>entry</code>, <code>output</code> option만 있을 때는 bundling 작업만 진행합니다.(이 두 option은 반드시 필요합니다.) 그럼, 각각에 대해서 알아봅니다.</p><h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p>webpack은 라이브러리 간의 의존성을 그래프(<code>dependency tree</code>)로 표현을 합니다. 이 그래프를 만들 때의 시작점을 <code>entry</code>라는 옵션을 통해 설정할 수 있습니다. 즉, webpack을 이용하여 bundle하고 build할 애플리케이션의 시작점을 설정하는 옵션이라고 할 수 있습니다.</p><h4 id="Usage1-entry-string-Array-lt-string-gt"><a href="#Usage1-entry-string-Array-lt-string-gt" class="headerlink" title="Usage1: entry: string|Array&lt;string&gt;"></a>Usage1: <code>entry: string|Array&lt;string&gt;</code></h4><p><code>entry</code> 값으로는 <code>string</code> 또는 <code>배열</code>이 올 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>배열을 사용하는 경우의 대표적인 경우로는 <code>react-hot-loader</code>를 사용하는 경우가 있습니다.</p><h4 id="Usage2-entry-entryChunkName-string-string-Array-lt-string-gt"><a href="#Usage2-entry-entryChunkName-string-string-Array-lt-string-gt" class="headerlink" title="Usage2: entry: {[entryChunkName: string]: string|Array&lt;string&gt;}"></a>Usage2: <code>entry: {[entryChunkName: string]: string|Array&lt;string&gt;}</code></h4><p><code>entry point</code>를 여러 개 설정해야 하는 경우에는 Object를 사용하여 지정할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    vendors: <span class="string">'./src/vendors.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>다른 <code>entry point</code>에서 시작하므로 각각의 <code>entry point</code>에서 생성된 그래프는 <strong>완전히 독립적인 그래프</strong>가 됩니다. (이러는 경우 각각의 dependency tree에서 중복되는 코드들이 발생할 수 있는데 이 부분은 <code>commons-chunk-plugin</code>을 통해서 해결할 수 있습니다.)</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p><code>entry</code>로 지정된 파일로부터 bundling을 진행하고, 그 결과를 <strong>어떻게 할지</strong>를 설정합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: [...]</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: <span class="string">'/home/proj/dist'</span>,</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>bundling된 결과 파일의 이름을 <code>filename</code>으로 어디에 생성할지에 대한 정보를 <code>path</code>에 설정해줍니다. <code>path</code>에는 <strong>절대 경로</strong>를 통해 설정해줘야합니다. 그렇기 때문에 <code>__dirname</code>을 사용할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: [...]</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="string">'/dist'</span>,</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>path</code>라는 모듈을 사용해서 path를 지정해줄 수 있습니다. <code>.join()</code>, <code>.resolve()</code> 두 가지의 메소드는 약간의 차이는 있지만 <code>__dirname</code>을 사용하는 경우 두 메소드 둘 다 동일한 의도하는 값을 반환하기 때문에 둘 다 사용 가능합니다. 두 메소드에 차이는 <a href="http://stackoverflow.com/questions/35048686/difference-between-path-resolve-and-path-join-invocation" target="_blank" rel="noopener">링크</a>를 참고하시면 됩니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: [...]</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>path</code> 모듈을 통해 path를 정리한 후의 상태입니다.<br><br></p><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p><code>module</code> 옵션은 webpack을 통해 bundling을 진행할 때 처리해야 하는 task들을 실행할 때 사용합니다. ES5 문법을 사용하기 위해 먼저 <code>babel</code>을 통해 <strong>transpile</strong>을 해야 하는데 이 작업을 <code>babel-loader</code>를 통해 설정해줄 수 있습니다. 또 javascript 파일 뿐만 아니라 css 파일을 load해야하는 경우에는 <code>css-loader</code>를 사용할 수 있습니다.</p><h4 id="module-rules"><a href="#module-rules" class="headerlink" title="module.rules"></a>module.rules</h4><p><code>rules</code>에 각종 loader들을 등록할 수 있습니다. 배열의 형태로 여러 loader들을 등록합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>여기에서 <code>babel-loader</code>, <code>css-loader</code> 등이 설정됩니다. 하나의 <code>loader</code>당 하나의 Object로 추가할 수 있습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            include: path.join(__dirname, <span class="string">'src'</span>),</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    presets: [</span><br><span class="line">                        [<span class="string">'env'</span>, &#123; <span class="attr">module</span>: <span class="literal">false</span> &#125;]</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>babel-loader</code> 하나만 추가했습니다. (<code>babel-loader</code>를 사용하기 위해서는 <code>babel-core</code>, <code>babel-loader</code>, <code>babel-preset-env</code> 세 개의 모듈이 필요합니다. <code>babel-preset-env</code>의 <code>env</code>가 <code>es2015</code>, <code>es2016</code>, <code>es2017</code>, <code>latest</code>를 대체합니다.)</p><p><code>test</code>를 통해 load할 파일을 지정하고, <code>exclude</code>와 <code>include</code>를 통해 <code>path</code>를 지정해줄 수 있습니다. 그리고 나서 사용할 module을 <code>use</code>를 통해 작성해 줍니다. <code>use</code> 안에는 <code>loader</code>와 <code>options</code>를 명시하여 loader에 대한 명세를 합니다. 이 <code>options</code>의 경우는 <code>babel</code>의 <code>.babelrc</code>파일로 따로 추출할 수 있습니다. <code>config.js</code> 파일이 과도하게 복잡해지는 것을 방지하기 위해서 loader에 대한 옵션은 따로 추출하는 것도 좋은 방법입니다.</p><p><code>presets</code>에서 <code>{ module: false }</code>는 <a href="https://webpack.js.org/guides/tree-shaking/" target="_blank" rel="noopener">tree shaking</a>을 사용하는 옵션으로 bundling 결과로부터 사용되지 않은 코드를 삭제하어 파일 크기를 줄여줍니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">        <span class="string">'style-loader'</span>, <span class="string">'css-loader'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rules</code>에 위와 같은 객체를 추가해주면 css 파일을 load할 수 있습니다. (마찬가지로 <code>style-loader</code>, <code>css-loader</code> 두 가지를 install 해야합니다.)</p><p>다음 포스팅에서는 보다 효율적으로 개발을 도와주고 애플리케이션의 성능 향상에 도움을 주는 <code>Plugins</code>에 대해 알아보겠습니다 :)</p><p>포스팅에서 사용된 예제 코드는 <a href="https://github.com/JaeYeopHan/webpack2_tutorial" target="_blank" rel="noopener">Github repository</a>에서 확인하실 수 있습니다 :D</p><p><em>1편 end</em></p><p>Reference&gt;<br><a href="https://github.com/AriaFallah/WebpackTutorial/tree/master/ko-arahansa/part1" target="_blank" rel="noopener">Webpack Tutorial</a><br><a href="https://github.com/FEDevelopers/tech.description/wiki/Webpack2%EC%99%80-%EB%AA%A8%EB%93%88%EB%B2%88%EB%93%A4%EB%A7%81%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%B4%88%EB%B3%B4%EC%9E%90-%EA%B0%80%EC%9D%B4%EB%93%9C" target="_blank" rel="noopener">Webpack2와 모듈 번들링을 위한 초보자 가이드</a><br><a href="http://d2.naver.com/helloworld/0239818" target="_blank" rel="noopener">Javascript 모듈화 도구, webpack</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/webpack.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Tool-Webpack2-입문-가이드-1편&quot;&gt;&lt;a href=&quot;#Tool-Webpack2-입문-가이드-1편&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="Tool" scheme="https://jaeyeophan.github.io/categories/Tool/"/>
    
    
      <category term="tool" scheme="https://jaeyeophan.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>[ES6] 11. Modulization</title>
    <link href="https://jaeyeophan.github.io/2017/05/04/ES6-11-Modulization/"/>
    <id>https://jaeyeophan.github.io/2017/05/04/ES6-11-Modulization/</id>
    <published>2017-05-04T06:22:01.000Z</published>
    <updated>2017-05-04T08:07:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript_es6.png" alt=""></p><h1 id="ES6-11-Modulization"><a href="#ES6-11-Modulization" class="headerlink" title="[ES6] 11. Modulization"></a>[ES6] 11. Modulization</h1><p>ES6에서 추가된 import/export 구문을 9가지 Case로 나누어 정리해봤습니다.</p><h2 id="Module-in-Javascript"><a href="#Module-in-Javascript" class="headerlink" title="Module in Javascript"></a>Module in Javascript</h2><p><a href="http://asfirstalways.tistory.com/234" target="_blank" rel="noopener">Module pattern</a>이라고 들어보셨나요? ES5에서는 기본적으로 global에 변수가 할당되기 때문에, <a href="http://asfirstalways.tistory.com/233" target="_blank" rel="noopener">Namespace pattern</a>, module pattern 등등의 기법들이 필요했습니다. 또한 CommonJS, AMD처럼 같은 언어에서 환경에 따라 다른 방식으로 소스코드를 가져와 사용해야 했습니다. 이에 대한 부분은 <a href="http://d2.naver.com/helloworld/12864" target="_blank" rel="noopener">JavaScript 표준을 위한 움직임: CommonJS와 AMD</a>를 참고하시면 될 것 같습니다.</p><p>ES6에서는 이러한 문제점을 인식하고 <code>import</code>라는 구문을 통해 Modulization을 제공합니다. 하지만 아쉽게도 <strong>Safari</strong>를 제외한 다른 브라우저에서는 아직 지원을 하지 않습니다. 그렇기 때문에 Webpack과 babel의 도움을 받아 테스트해볼 수 있습니다.</p><h2 id="import-amp-export"><a href="#import-amp-export" class="headerlink" title="import &amp; export"></a>import &amp; export</h2><h3 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1"></a>Case 1</h3><p>함수를 다른 자바스크립트 파일에서 불러와 실행해야 하는 경우에 대한 예제 코드입니다.<br><figure class="highlight js"><figcaption><span>module1.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`module1`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hello &#125; <span class="keyword">from</span> <span class="string">'./module1'</span>;</span><br><span class="line">hello(); <span class="comment">//module1</span></span><br></pre></td></tr></table></figure><p>외부의 자바스크립트 파일에서 다른 자바스크립트 파일에 존재하는 함수를 문제없이 사용할 수 있게 되었습니다:)<br><code>{ ... }</code>는 ES6의 <code>destructuring</code> 문법을 사용한 것입니다. <code>module1.js</code>파일에서 export가 붙은 함수를 import하는데 그 중 <code>hello</code>라는 함수를 import하겠다는 의미입니다. 이와 같은 방법으로 여러 함수 또는 변수를 export하고 import할 수 있습니다. 다른 방법도 살펴보겠습니다.</p><h3 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2"></a>Case 2</h3><figure class="highlight js"><figcaption><span>module1.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`module1`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module1 <span class="keyword">from</span> <span class="string">'./module1'</span>;</span><br><span class="line">module1();<span class="comment">// module1</span></span><br></pre></td></tr></table></figure><p><code>default</code>라는 키워드가 보이시나요? <code>export</code> 키워드를 사용하여 함수를 외부로 노출시킬 때, <code>default</code>라는 키워드를 붙여주면 해당 파일이 import되는 경우 기본적으로 지정된 함수 또는 변수를 노출시키겠다라는 의미입니다. 주로 파일에서 하나의 함수 또는 변수를 노출시킬 경우에 사용합니다. <code>default</code> 키워드를 사용하게 되면 특정 함수나 변수를 import하는 것이 아니므로 import하는 곳에서 변수명 또는 함수명을 임의로 지정할 수 있습니다. 이번 예제에서는 <code>hello</code>라는 함수 이름을 그대로 사용하지 않고 <code>module1</code>이라는 이름을 지정하여 함수를 호출했습니다.</p><h3 id="Case-3"><a href="#Case-3" class="headerlink" title="Case 3"></a>Case 3</h3><p><code>export default</code>로 이미 export를 한 후에 다른 함수나 변수를 export하기 위해서는 import할 때 다음과 같은 방법을 사용해야 합니다.<br><figure class="highlight js"><figcaption><span>module1.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`module1`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">"jbee"</span>;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module1, &#123; name &#125; <span class="keyword">from</span> <span class="string">'./module1'</span>;</span><br><span class="line">module1();<span class="comment">// module1</span></span><br><span class="line"><span class="built_in">console</span>.log(name);<span class="comment">// jbee</span></span><br></pre></td></tr></table></figure><p><code>name</code>이라는 변수를 import하는 경우에는 반드시 <code>name</code>이라는 변수명으로 import해야겠죠? 다음의 경우에는 어떻게 될까요?</p><h4 id="Case-3-1"><a href="#Case-3-1" class="headerlink" title="Case 3-1"></a>Case 3-1</h4><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module1, &#123; name &#125; <span class="keyword">from</span> <span class="string">'./module1'</span>;</span><br><span class="line">module1();<span class="comment">// module1</span></span><br><span class="line"><span class="built_in">console</span>.log(name);<span class="comment">// jbee</span></span><br><span class="line">name = <span class="string">"newName"</span>; <span class="comment">//SyntaxError!</span></span><br></pre></td></tr></table></figure><p>import한 name을 다시 정의하려고 하면 SyntaxError가 발생합니다. import된 <code>name</code>이란 변수는 <code>read-only</code> 속성이 적용되기 때문입니다. 만약에 다음과 같은 경우는 어떻게 해야할까요?</p><h4 id="Case-3-2"><a href="#Case-3-2" class="headerlink" title="Case 3-2"></a>Case 3-2</h4><figure class="highlight js"><figcaption><span>module1.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">"jbee"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>module2.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">"newName"</span>;</span><br></pre></td></tr></table></figure><p>다른 자바스크립트 파일에서 같은 변수명을 사용한 경우입니다. 기존의 방식대로 import를 해볼까요?<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">'./module1'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">'./module2'</span>;</span><br></pre></td></tr></table></figure></p><p>default로 export되지 않은 함수 또는 변수에 대해서는 반드시 그 이름을 지정해야 했습니다. 이럴 경우에는 <code>Duplicate declaration</code>에러가 발생합니다.</p><h3 id="Case-4"><a href="#Case-4" class="headerlink" title="Case 4"></a>Case 4</h3><p>위에서 발생한 문제를 해결하기 위한 첫번째 방법입니다.<br><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name <span class="keyword">as</span> module1Name&#125; <span class="keyword">from</span> <span class="string">'./module1'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; name <span class="keyword">as</span> module2Name&#125; <span class="keyword">from</span> <span class="string">'./module2'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(module1Name);</span><br><span class="line"><span class="built_in">console</span>.log(module2Name);</span><br></pre></td></tr></table></figure></p><p><code>as</code>라는 키워드가 등장했습니다. <code>alias</code>의 줄임으로 import한 변수 또는 함수에 대해 별명을 지정할 수 있습니다. 이렇게 import를 하면 변수명끼리 충돌이 일어나지 않습니다:) 그러나 변수명이 점점 많아지게 되면 계속해서 새로운 변수명을 지정해줘야 하는 문제점이 발생하게 됩니다.</p><h3 id="Case-5"><a href="#Case-5" class="headerlink" title="Case 5"></a>Case 5</h3><p>위의 문제를 조금 더 개선해보겠습니다:)<br><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Module1 <span class="keyword">from</span> <span class="string">'./module1'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Module2 <span class="keyword">from</span> <span class="string">'./module2'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Module1.name);</span><br><span class="line"><span class="built_in">console</span>.log(Module2.name);</span><br></pre></td></tr></table></figure></p><p><code>as</code>키워드를 사용함과 동시에 <code>*</code>이 등장했습니다. <code>*</code>은 import하고자 하는 자바스크립트 파일에서 <code>export</code>키워드가 붙어있는 모든 함수, 변수를 import할 때 사용합니다. 그리고 <code>as</code> 키워드를 통해서 <code>namespace</code>를 지정해줘야 합니다. 이렇게 import가 되면 <code>Module1</code>이라는 객체의 프로퍼티로 import한 변수 또는 함수에 접근할 수 있습니다.</p><h3 id="Case-6"><a href="#Case-6" class="headerlink" title="Case 6"></a>Case 6</h3><figure class="highlight js"><figcaption><span>module1.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"Jbee"</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; obj &#125; <span class="keyword">from</span> <span class="string">'./module1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">// Jbee</span></span><br><span class="line">obj.name = <span class="string">"newName"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">// newName</span></span><br></pre></td></tr></table></figure><p>위 예제로부터 Object를 import하는 경우에, Object의 프로퍼티까지 보호할 수 없다는 것을 알 수 있습니다.</p><h3 id="Case-7"><a href="#Case-7" class="headerlink" title="Case 7"></a>Case 7</h3><p>여태까지 정의함과 동시에 export를 할지 말지 결정했는데요, 자바스크립트 코드의 마지막에서 이를 정의해줄 수 있습니다.<br><figure class="highlight js"><figcaption><span>module1.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"Jbee"</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; obj &#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; obj &#125; <span class="keyword">from</span> <span class="string">'./module1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">// Jbee</span></span><br></pre></td></tr></table></figure><h3 id="Case-8"><a href="#Case-8" class="headerlink" title="Case 8"></a>Case 8</h3><p>Object 또는 변수를 export하는 경우 <code>default</code>키워드를 붙일 수 없습니다. 대신 다른 방법이 존재합니다.<br><figure class="highlight js"><figcaption><span>module1.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"Jbee"</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; obj <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> obj <span class="keyword">from</span> <span class="string">'./module1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">// Jbee</span></span><br></pre></td></tr></table></figure><p><code>as default</code>라는 키워드를 붙여 export할 수 있습니다. 이는 함수 또는 변수에도 적용 가능합니다.</p><h3 id="Case-9"><a href="#Case-9" class="headerlink" title="Case 9"></a>Case 9</h3><p>import 구문을 class에도 물론 적용할 수 있습니다.<br><figure class="highlight js"><figcaption><span>module1.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`create component!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'./module1'</span>;</span><br><span class="line"><span class="keyword">new</span> Component();</span><br><span class="line"><span class="comment">//create component!</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="import-export-5-convention-from-Airbnb-ES6-Convention"><a href="#import-export-5-convention-from-Airbnb-ES6-Convention" class="headerlink" title="import/export 5 convention from Airbnb ES6 Convention"></a>import/export 5 convention from <a href="https://github.com/JaeYeopHan/javascript" target="_blank" rel="noopener">Airbnb ES6 Convention</a></h2><p>1) Wildcard(<code>*</code>) 사용을 자제하세요!<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> AirbnbStyleGuide <span class="keyword">from</span> <span class="string">'./AirbnbStyleGuide'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> AirbnbStyleGuide <span class="keyword">from</span> <span class="string">'./AirbnbStyleGuide'</span>;</span><br></pre></td></tr></table></figure></p><p>2) import함과 동시에 export를 하지 말고 코드의 마지막에서 따로 export하세요!<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="comment">// filename es6.js</span></span><br><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./airbnbStyleGuide'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="comment">// filename es6.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./AirbnbStyleGuide'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br></pre></td></tr></table></figure></p><p>3) 동일한 path를 import하는 경우에는 한 줄에서 모두 import하세요!<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br><span class="line"><span class="comment">// … some other imports … //</span></span><br><span class="line"><span class="keyword">import</span> &#123; named1, named2 &#125; <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> foo, &#123; named1, named2 &#125; <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br></pre></td></tr></table></figure></p><p>4) import 구문은 호이스팅 됩니다. 그러므로 import문은 모두 상단에 위치시키세요!<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br><span class="line">foo.init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> bar <span class="keyword">from</span> <span class="string">'bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">import</span> bar <span class="keyword">from</span> <span class="string">'bar'</span>;</span><br><span class="line"></span><br><span class="line">foo.init();</span><br></pre></td></tr></table></figure></p><p>5) 하나만 export하는 경우에는 default 키워드를 붙여주세요!</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h4><p>이상 9가지의 case로 ES6의 import와 export를 정리해봤습니다 :D</p><p>ES6 모든 포스팅은 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="noopener">Github Respository</a>에서 확인하실 수 있습니다.</p><p><em>11. end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javascript_es6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES6-11-Modulization&quot;&gt;&lt;a href=&quot;#ES6-11-Modulization&quot; class=&quot;headerlink&quot; title=&quot;[
      
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="es6" scheme="https://jaeyeophan.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>[Tool] Issue Management Tool, Zenhub</title>
    <link href="https://jaeyeophan.github.io/2017/04/30/issue-management-tool/"/>
    <id>https://jaeyeophan.github.io/2017/04/30/issue-management-tool/</id>
    <published>2017-04-29T15:30:28.000Z</published>
    <updated>2017-05-02T12:46:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/github_logo.jpg" alt=""></p><h1 id="Issue-Management-Tool"><a href="#Issue-Management-Tool" class="headerlink" title="Issue Management Tool"></a>Issue Management Tool</h1><p>개발자들에게 정말 많은 사랑을 받고 있는 <code>Github</code>. 이제는 더 이상 없어서는 안 될 존재가 되었는데요:) 이 Github도 약간 아쉬운 부분이 존재합니다. 그래서 이번 포스팅에서는 Github과 함께 사용할 수 있는 <code>Issue Management Tool</code> 몇 가지를 소개해드리려고 합니다. (Github도 이에 대한 필요성을 느끼고 <code>Project</code>라는 이름의 기능을 추가하였는데요, 이것과 비교도 해보겠습니다.)<br>Github Help에서 제공하는 <a href="https://help.github.com/articles/managing-your-work-with-issues/" target="_blank" rel="noopener">Issue 관리에 대한 자료</a>입니다. 이 포스팅을 읽기 전에 참고해봐도 좋을 것 같습니다.</p><h2 id="Agile이라는-녀석"><a href="#Agile이라는-녀석" class="headerlink" title="Agile이라는 녀석,"></a>Agile이라는 녀석,</h2><p><img src="/images/agile_cloud_tag.png" alt=""><br> _ reference&gt;<a href="http://www.onedesk.com/scrum-methodology-vs-agile-methodology/" target="_blank" rel="noopener">http://www.onedesk.com/scrum-methodology-vs-agile-methodology/</a>_<br><code>Agile 방법론</code>이 대두되면서, 프로젝트의 진행 상황을 공유하고 관리하는 것이 전보다 복잡하고 중요해졌습니다.(<a href="http://blog.rightbrain.co.kr/?p=5810" target="_blank" rel="noopener">Agile이란 무엇인가</a>) 개발자들간의 의사소통은 물론이고 프로젝트를 관리하는 매니저, 팀장 등과의 의사소통이 매우 중요해졌는데요, 이러한 상황 속에서 매번 회의를 하거나 서로에게 물어보면 그만큼 생산성이 감소하게 됩니다. 보다 효율적으로, Agile하게 프로젝트가 진행될 수 있도록 각종 도구들을 제대로 알고 팀에 적합한 도구를 고르는 것이 중요해졌습니다.</p><h2 id="Github이-제공하는-기능들"><a href="#Github이-제공하는-기능들" class="headerlink" title="Github이 제공하는 기능들"></a>Github이 제공하는 기능들</h2><p><img src="/images/default_github.png" alt=""><br>프로젝트 Repository안에는 viewer인 <code>Code</code> 탭, task 관리를 위한 <code>Issue</code>탭, 그리고 이 이슈들을 관리하기 위한 <code>Label</code>과 <code>Milestone</code>이 존재합니다. 프로젝트에서 진행되고 있는 Issue의 상태(Status) 또는 성격을 <code>Label</code>이라는 Metadata로 관리할 수 있고, <code>Milestone</code>이란 기능으로 단기적인 목표의 기간을 관리할 수 있습니다. 또 <code>Project</code>라는 탭을 통해 kanban 형식으로 Issue들을 관리할 수 있습니다. Trello라는 서비스를 아시나요? Tello가 대표적인 <strong>kanban 형식의 dashboard</strong> 입니다.</p><p><em>cf&gt; 포스팅에서 언급되는 <code>기존 형식의 dashboard</code>란 Agile workflow를 중심으로 드래그 앤 드롭을 통한 우선순위 선정 기능, Label 기능, Real-time dashboard 기능 등을 포함한 kanban 형식의 dashboard을 말합니다.</em></p><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><p>Github에서 제공하는 다양한 Plugin 형태의 Tool들은 <a href="https://github.com/integrations" target="_blank" rel="noopener">Integration Tab</a>에서 볼 수 있습니다. 이미 널리 알려진 <code>JIRA</code>를 제외하고 몇 가지 Tool들을 알아보겠습니다:) 제 나름대로의 판단 기준을 갖고 검색해보았습니다.</p><ol><li>기존의 Github Repository와 연동이 잘 되는가?</li><li>어떤 형식으로 dashboard를 제공하는가? (kanban 형식인가?)</li><li>UI/UX적으로 어떤가?</li><li>부가적인 기능에는 무엇이 있는가?</li></ol><h2 id="Zenhub"><a href="#Zenhub" class="headerlink" title="Zenhub"></a>Zenhub</h2><p><img src="/images/zenhub.png" alt=""><br><code>Zenhub</code>은 기존 형식의 dashboard를 제공합니다. Repository 기준으로 dashboard가 생성되고 기존에 등록되어 있던 Issue들은 물론이고 추후 생성하는 Issue들은 <code>New Issues</code>라는 column으로 들어갑니다. 가장 기본적이고 중요한 Github과의 연동은 문제가 없습니다.</p><h3 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h3><h4 id="기존의-Github에서-Tab만-추가되는-형식"><a href="#기존의-Github에서-Tab만-추가되는-형식" class="headerlink" title="기존의 Github에서 Tab만 추가되는 형식"></a>기존의 Github에서 Tab만 추가되는 형식</h4><p><img src="/images/zenhub_plugin.png" alt=""><br>기존의 Github에서 제공하는 탭에서 Board라는 탭과 Report라는 탭이 추가되었습니다. <code>Zenhub</code>을 추가하게 되면 자동으로 Repository마다 저런 형식으로 탭이 추가됩니다. 기존 Github에서 제공되는 기능에서 Board라는 탭이 추가되는 형식이기 때문에 기존의 Github을 그대로 이용할 수 있다는 장점이 있습니다.</p><h4 id="Chrome-Extension"><a href="#Chrome-Extension" class="headerlink" title="Chrome Extension"></a>Chrome Extension</h4><p><img src="/images/zenhub_chrome_extension.png" alt=""><br>원한다면 Chrome extension을 추가하여 브라우저 어디에서든 변동사항을 파악할 수 있다는 장점도 존재합니다. 접근성면에서 아주 좋습니다.</p><h4 id="Metadata를-통한-Issue-구체화"><a href="#Metadata를-통한-Issue-구체화" class="headerlink" title="Metadata를 통한 Issue 구체화"></a>Metadata를 통한 Issue 구체화</h4><p><code>Zenhub</code>은 Github에서 제공하는 Issue Metadata들에서 추가적으로 몇 가지 기능을 더 제공합니다.<br><img src="/images/zenhub_modal.png" alt=""></p><h5 id="1-Pipeline"><a href="#1-Pipeline" class="headerlink" title="1. Pipeline"></a>1. Pipeline</h5><p>제공되는 dashboard를 기준으로 제공되는 <code>Pipleline</code>이라는 기능으로 Issue의 Status를 설정할 수 있습니다.</p><h5 id="2-Epic"><a href="#2-Epic" class="headerlink" title="2. Epic"></a>2. Epic</h5><p>Github에서는 Issue들을 명시적으로 <code>그룹화</code>할 방법이 없었습니다. <code>Label</code>을 통해서 어떻게든 그룹화하려면 할 수는 있었지만, 아쉬운 점이 많았습니다. <code>Zenhub</code>에서는 <code>epic</code>이라는 기능을 제공하여 Issue들을 그룹화할 수 있습니다.</p><h5 id="3-Estimate"><a href="#3-Estimate" class="headerlink" title="3. Estimate"></a>3. Estimate</h5><p>Issue에 <code>Estimate</code>라는 Metadata를 이용하여 해당 Issue의 <code>복잡도(complexity)</code>를 설정할 수 있습니다. <code>1, 2, 3, 5, 8, 13, 21, 40</code>이라는 총 8단계의 레벨을 제공하고 있습니다. 팀 내부에서의 회의를 통해 일정을 산정하고 그에 맞는 레벨을 설정할 수 있습니다. 플래닝 포커라는 방법으로 일정을 산출할 수 있습니다. <em>&gt; 참고자료:<a href="http://bcho.tistory.com/1041" target="_blank" rel="noopener">플래닝 포커를 이용한 프로젝트 일정 산정</a></em></p><h4 id="Merge-repository"><a href="#Merge-repository" class="headerlink" title="Merge repository"></a>Merge repository</h4><p><img src="/images/merge_repository.png" alt=""><br>Respository를 <code>merge</code>하여 <strong>하나의 dashboard에서 복수 개의 Respository를</strong> 관리할 수 있습니다. 여러 프로젝트를 통합하여 관리해야 한다면 <code>Zenhub</code>의 merge 기능을 이용할 수 있습니다. 개인 Issue 관리 Repository를 따로 만들어서 자신만의 Issue를 관리할 수 있겠네요:)</p><h4 id="Report-기능"><a href="#Report-기능" class="headerlink" title="Report 기능"></a>Report 기능</h4><p><img src="/images/zenhub_report.png" alt=""><br><code>Burndown</code>, <code>Velocity tracking</code>, <code>Release Report</code> 세 가지의 옵션으로 그래프 형식의 보고서를 보여줍니다. 지정한 <code>Milestone</code>의 진행 상황을 한 눈에 살펴볼 수 있는 좋은 기능입니다 :) <code>Label</code>에 따라서 또는 Issue의 상태에 따라서 다양한 보고서를 볼 수 있습니다.</p><h4 id="To-do-list"><a href="#To-do-list" class="headerlink" title="To do list"></a>To do list</h4><p><img src="/images/zenhub_topbar.png" alt=""><br><code>Zenhub</code>플러그인을 설치하게 되면 위과 같이 상단 bar에 <code>Todo</code>라는 탭이 하나 더 추가됩니다.<br><img src="/images/zenhub_todo.png" alt=""><br>TODO를 관리할 수 있도록 플러그인을 제공해주고 있습니다. 물론 다른 Todo 전용 애플리케이션보다는 기능이 미약합니다.</p><h4 id="기타-부가적인-기능"><a href="#기타-부가적인-기능" class="headerlink" title="기타 부가적인 기능"></a>기타 부가적인 기능</h4><p>그리고 Zenhub에서는 Repository에서 다른 Respository로 손쉽게 이동할 수 있는 통로(?)를 제공해줍니다. Repository 이름 옆에 햄버거 버튼이 생성되는데요, 그 버튼을 통해서 계정에 존재하는 다른 Repository로 이동할 수 있습니다.<br><img src="/images/move_repository.png" alt=""><br>한 가지 또 부가적인 기능은 키보드 자판에서의 <code>b</code>버튼을 shotcut으로 제공해서 repository 화면에서 바로 <code>Board</code>탭으로 이동이 가능하네요:)</p><h3 id="가격"><a href="#가격" class="headerlink" title="가격"></a>가격</h3><p>공식 웹 사이트에는 5명 이하의 작은 팀에 대해서는 무료로 제공한다고 합니다. 물론 이것은 private repository에 대해서 적용되는 사항이구요, public repository에 대해서는 사용자 수에 상관없이 무료로 제공하고 있습니다.</p><h4 id="Github에서-제공하는-Project-기능과비교"><a href="#Github에서-제공하는-Project-기능과비교" class="headerlink" title="Github에서 제공하는 Project 기능과비교"></a>Github에서 제공하는 Project 기능과비교</h4><p><code>Zenhub</code>에서는 dashboard에서 <code>Issue</code>를 클릭하면 <strong>modal형태로</strong> 해당 Issue의 내용이 보이면서 바로 comment를 달거나 <code>Label</code>을 변경하는 등의 작업을 수행할 수 있는 기능을 제공합니다. 그러나 Github에서 제공하는 <code>Project dashboard</code>는 Issue를 클릭하면 해당 Issue 페이지로 redirect되어 (개인적으로는 매우)불편합니다.</p><p>또한 <code>Zenhub</code>을 사용하면 Issue의 특성에 따라서 필터를 적용할 수 있습니다. dashboard에 흩어져 있는 Issue들을 <code>Milestone</code>에 따라서 또는 <code>Label</code>에 따라서 등등의 특성으로 분류가 가능합니다. 아직 Github에서 default로 제공하는 Project 기능은 부족한 점이 많아 보입니다 :(</p><p><a href="https://www.zenhub.com/product" target="_blank" rel="noopener">Zenhub 공식 사이트</a>에서 보다 자세한 내용을 확인하실 수 있습니다.</p><h2 id=""><a href="#" class="headerlink" title=""></a><br></h2><h2 id="그-외-Management-Tools"><a href="#그-외-Management-Tools" class="headerlink" title="그 외 Management Tools"></a>그 외 Management Tools</h2><h3 id="Hueboard"><a href="#Hueboard" class="headerlink" title="Hueboard"></a>Hueboard</h3><p><a href="https://huboard.com/huboard/huboard" target="_blank" rel="noopener">Hueboard 예시</a><br><code>Zenhub</code>과 마찬가지로 하나의 Repository마다, 하나의 dashboard를 제공해주며 기존의 dashboard 형식을 취합니다. UI적으로는 <code>Zenhub</code>보다 조금 나아보입니다. <code>Zenhub</code>과는 달리 별도의 웹 사이트로 redirect되면서 프로젝트 관리에 대한 총체적인 dashboard를 제공합니다. Filter 기능이 유독 눈에 들어오네요. <code>Zenhub</code>에서도 가능했던 기능이지만 UI적으로 깔끔해서 dashboard에 집중할 수가 있을 것 같습니다.<br><a href="https://huboard.com/" target="_blank" rel="noopener">Hueboard 공식 사이트</a>에서 보다 자세한 내용을 확인하실 수 있습니다.</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><br></h2><h3 id="Zube"><a href="#Zube" class="headerlink" title="Zube"></a>Zube</h3><p><img src="/images/zube_feature.png" alt=""><br>기존의 dashboard 외에 몇 가지 추가적인 기능을 제공합니다. <code>Sprint board</code>, <code>Sprint</code>, <code>Tickets</code> 눈에 들어오는 것은 <code>Analytics</code> 기능입니다.<br><img src="/images/zube_analysis.png" alt=""><br><code>Zenhub</code>에서 제공하는 보고서 유형보다 2종류가 더 많네요. 프로젝트를 처음 시작할 때부터 도입하지 않으면 사용하기에 부담이 생기는 Tool일 것 같다는 생각이 들었습니다. 또한 너무 많은 기능을 제공하면 오히려 생산성을 저해하는 요소가 될 수 있지 않을까 생각이 드는 Tool이었습니다.</p><p><a href="https://zube.io/" target="_blank" rel="noopener">Zube 공식 사이트</a>에서 보다 자세한 내용을 확인하실 수 있습니다.</p><p><br></p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>이 외에도 <code>Waffle</code>, <code>CodeTree</code>, <code>Asana</code> 등등 정말 많은 Tool들이 존재합니다. 제공하는 기능은 조금씩만 다르고 다 거기서 거기인 것 같습니다. 기존에 사용했던 다른 도구들(예를 들면 <code>Slack</code>, <code>Trello</code>, <code>hipchat</code> 등)과 얼마나 통합이 잘 되는지 또한 중요한 쟁점이 될 것 같습니다.</p><p>또 프로젝트에서 사용하는 Tool이 많아질수록 본래 프로젝트를 관리하기 위해 도입했던 관리 Tool을 관리해야 하는 주객전도 현상이 발생할 수 있습니다. 이 부분 또한 인지하여 프로젝트 관리 도구를 도입해야할 것입니다.</p><p>저는 개인적으로 새로운 Tool이 도입되는 부담감이 가장 적고 기존의 Github에 가장 잘 녹아드는 <code>Zenhub</code>이 가장 잘 맞는 것 같습니다:)</p><p><em>여러분 팀에 맞는 프로젝트 관리 도구는 무엇인가요?</em><br>감사합니다 :)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/github_logo.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Issue-Management-Tool&quot;&gt;&lt;a href=&quot;#Issue-Management-Tool&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="Tool" scheme="https://jaeyeophan.github.io/categories/Tool/"/>
    
    
      <category term="tool" scheme="https://jaeyeophan.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>[TS] 1. Basic Types</title>
    <link href="https://jaeyeophan.github.io/2017/04/23/TS-1-Basic-Types/"/>
    <id>https://jaeyeophan.github.io/2017/04/23/TS-1-Basic-Types/</id>
    <published>2017-04-23T07:12:08.000Z</published>
    <updated>2018-01-02T04:38:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/typescript.png" alt=""></p><h1 id="TS-1-Basic-Types"><a href="#TS-1-Basic-Types" class="headerlink" title="[TS] 1. Basic Types"></a>[TS] 1. Basic Types</h1><p>TypeScript에서는 JavaScript에서 사용했었던 <code>number</code>, <code>string</code>, <code>boolean</code>과 같은 데이터 타입을 기반으로 <code>정적 타이핑</code>을 지원합니다.</p><p>본격적인 TypeScript Tutorial 진행을 위해 에디터에 <code>TSLint</code>를 설치하겠습니다. (TypeScript에서 제공하는 <a href="https://www.typescriptlang.org/play/index.html" target="_blank" rel="noopener">Playground</a>에서 해보실 수도 있습니다.)</p><h2 id="Install-TSLint"><a href="#Install-TSLint" class="headerlink" title="Install TSLint"></a>Install TSLint</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn global add tslint typescript</span><br><span class="line">yarn global tslint typescript</span><br></pre></td></tr></table></figure><p><code>typescript</code>패키지는 <code>TSLint</code>와 동일한 version을 사용해야 하기 때문에 <code>peerDependencies</code>로 설치해줍니다.<br>작업할 디렉토리로 이동하여 <code>tslint</code>를 설정해줍니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tslint --init</span><br></pre></td></tr></table></figure></p><p>위 명령어를 실행하게 되면 <code>tslint.json</code>이라는 파일이 생성됩니다.<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"defaultSeverity"</span>: <span class="string">"error"</span>,</span><br><span class="line">    <span class="attr">"extends"</span>: <span class="string">"tslint:recommended"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>기본적으로 <code>tslint</code>에서 제공하는 <code>recommended</code> rule을 적용했습니다. 저는 <code>WebStorm</code>이라는 에디터를 사용하고 있습니다. 각자 사용하는 에디터에서 환경설정을 통해 TSLint를 able로 설정해주시면 됩니다. TSLint에서 제공하고 있는 rule은 <a href="http://palantir.github.io/tslint/rules/" target="_blank" rel="noopener">공식 사이트</a>에서 제공하고 있습니다. 입맛에 맞게 해당 rule들을 오버라이딩하여 사용하실 수 있습니다. (<code>WebStorm</code>에서는 console찍는 것 가지고 뭐라 안하는데, 다른 editor에서는 console마저 지우라고 하는 것 같습니다. <code>no-console</code> rule을 설정하시는게 정신 건강에 좋을 것 같습니다.) 보다 자세한 <code>tslint.json</code> 설정은 다음 링크를 참고하시면 좋을 것 같습니다. MicroSoft가 만든 <code>VSCode</code> 에디터가 요즘 뜨고 있는데요, <code>VSCode</code> 에디터에 TypeScript 개발 환경 설정하는 내용을 포함하고 있습니다. <a href="http://poiemaweb.com/typescript-vscode" target="_blank" rel="noopener">Visual Studio Code에서의 TypeScript 개발 환경 구축</a></p><h2 id="Basic-Types"><a href="#Basic-Types" class="headerlink" title="Basic Types"></a>Basic Types</h2><p>변수에 타입을 지정해주기 위해서 TypeScript에서는 <code>:</code>을 통해 지원합니다. 기존의 JavaScript에서 변수를 선언하면서 <code>:</code>으로 해당 변수의 타입을 지정해줍니다.</p><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isExist: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p><code>boolean</code> 타입을 지정합니다.</p><h3 id="Number-숫자"><a href="#Number-숫자" class="headerlink" title="Number, 숫자"></a>Number, 숫자</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decimal: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hex: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> binary: <span class="built_in">number</span> = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> octal: <span class="built_in">number</span> = <span class="number">0o744</span>;</span><br></pre></td></tr></table></figure><p><code>number</code> 타입을 지정합니다.</p><h3 id="String-문자열"><a href="#String-문자열" class="headerlink" title="String, 문자열"></a>String, 문자열</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">"jbee"</span>;</span><br><span class="line"><span class="keyword">let</span> greeting: <span class="built_in">string</span> = <span class="string">`Hi, I'm <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br></pre></td></tr></table></figure><p><code>string</code> 타입을 지정합니다.</p><h3 id="Array-배열"><a href="#Array-배열" class="headerlink" title="Array, 배열"></a>Array, 배열</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>or<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></p><p>기존에 배열 리터럴을 사용하여 배열을 정의하면서 정의하는 배열에 어떠한 데이터 타입의 원소가 들어갈 것인지를 Type을 통해 제공할 수 있습니다.</p><h3 id="Tuple-튜플"><a href="#Tuple-튜플" class="headerlink" title="Tuple, 튜플"></a>Tuple, 튜플</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tuple = [<span class="string">"age"</span>, <span class="number">25</span>];</span><br><span class="line">tuple = [<span class="string">"name"</span>, <span class="string">"jbee];// Error</span></span><br><span class="line"><span class="string">&gt; message: 'Type '[string, string]' is not assignable to type '[string, number]'.</span></span><br><span class="line"><span class="string">  Type 'string' is not assignable to type 'number'.' at: '5,1'</span></span><br></pre></td></tr></table></figure><p><code>key-value</code>의 형태를 저장할 때는, 위와 같이 타입을 지정해줄 수 있습니다. TSLint가 잘못된 타입의 값이 들어왔다는 것을 error message로 알려줍니다.</p><h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;Red, Green, Blue&#125;;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure><p>마찬가지로 Java의 <code>enum</code>과 같은 구조를 갖습니다. 시작하는 멤버에 0부터 번호를 매기고, 만약 1부터 시작해야 한다면 임의적으로 시작하는 숫자를 지정할 수 있습니다. 또는 각각에게 번호를 지정할 수도 있습니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Subject &#123;<span class="built_in">Math</span> = <span class="number">1</span>, Science = <span class="number">3</span>, History = <span class="number">7</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Subject[<span class="number">3</span>]);<span class="comment">//Science</span></span><br></pre></td></tr></table></figure></p><p>지정한 번호로 호출도 가능합니다.</p><p><code>tsc</code> 명령어를 통해서 저희가 작성한 TypeScript 코드를 변환된 Javascript 코드로 볼 수 있습니다. TypeScript의 <code>Enum</code>은 다음과 같이 변환되는 것을 확인하실 수 있습니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Subject;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Subject</span>) </span>&#123;</span><br><span class="line">    Subject[Subject[<span class="string">"Math"</span>] = <span class="number">1</span>] = <span class="string">"Math"</span>;</span><br><span class="line">    Subject[Subject[<span class="string">"Science"</span>] = <span class="number">3</span>] = <span class="string">"Science"</span>;</span><br><span class="line">    Subject[Subject[<span class="string">"History"</span>] = <span class="number">7</span>] = <span class="string">"History"</span>;</span><br><span class="line">&#125;)(Subject || (Subject = &#123;&#125;));</span><br></pre></td></tr></table></figure></p><p>자바스크립트의 다섯 줄이 타입스크립트 한 줄로 작성되었습니다 :)</p><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>코드를 작성하면서 사용되는 변수에 알맞은 데이터 타입을 설정하는 것은 중요하지만 데이터 타입이 동적으로 결정되는 변수도 존재하게 됩니다. 이럴 때 사용할 수 있는 타입이 <code>any</code>입니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> notSureVar: <span class="built_in">any</span>;</span><br><span class="line">notSureVar = <span class="number">3</span>;</span><br><span class="line">notSureVar = <span class="string">`hi`</span>;</span><br><span class="line">notSureVar = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure></p><p><code>any</code>로 타입을 지정하면 Compile Time에서 <code>Type checking</code>을 하지 않습니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> notSureVar; <span class="comment">// == let notSureVar: any;</span></span><br></pre></td></tr></table></figure></p><p><code>any</code>로 타입을 지정하는 것과 위의 자바스크립트는 동치라고 볼 수 있습니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="string">`jbee`</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure></p><p>여러 가지 타입의 요소가 포함되는 배열을 정의할 때도 <code>any</code>를 사용할 수 있습니다.<br><code>any</code>의 역할이 다른 언어에서의 <code>Object</code>와 같은 역할을 하는 느낌이 드는데요, 실제로 2.2version에서 <code>Object</code>타입이 추가되었습니다. 일단 코드를 통해 확인해보겠습니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`hi`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    name : <span class="string">"jbee"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> notSureObj: <span class="built_in">Object</span>;</span><br><span class="line">notSureObj = user;</span><br><span class="line">notSureObj.getName(); <span class="comment">// error</span></span><br><span class="line">notSureObj.name; <span class="comment">// error</span></span><br><span class="line"><span class="comment">//Property 'getName' does not exist on type 'Ojbect'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> notSureVar: <span class="built_in">any</span>;</span><br><span class="line">notSureVar = user;</span><br><span class="line">notSureVar.getName(); <span class="comment">// success</span></span><br><span class="line">notSureVar.name; <span class="comment">// "jbee"</span></span><br></pre></td></tr></table></figure></p><p>변수의 type을 <code>Object</code>로 지정하고, 실제 Object를 정의하여 변수에 할당했습니다. 그리고 할당한 Ojbect에 존재하는 메소드를 호출했더니 에러가 발생합니다. <code>getName()</code>이라는 프로퍼티가 없다고 하네요. 분명 <code>getName()</code>메소드가 존재하는 Object를 할당했는데 말이죠. <code>name</code> 프로퍼티도 마찬가지입니다. 하지만 <code>any</code> 타입으로 지정했을 때는 메소드를 호출할 수 있고, 프로퍼티를 찾을 수 있습니다. 이 <code>Object</code> 타입은 할당만 가능할 뿐, 메소드나 프로퍼티에 접근할 수 없습니다.<br><a href="https://blog.mariusschulz.com/2017/02/24/typescript-2-2-the-object-type" target="_blank" rel="noopener">About Object Type</a></p><h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><p>값을 반환하지 않는 함수의 return type을 지정할 때 사용할 수 있습니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hi`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>물론 변수의 타입에도 사용할 수 있습니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo: <span class="built_in">void</span>;</span><br><span class="line">foo = <span class="literal">undefined</span>;</span><br><span class="line">foo = <span class="literal">null</span>;</span><br><span class="line">foo = <span class="string">`foo`</span>; <span class="comment">//error</span></span><br><span class="line">&gt; Type <span class="string">'string'</span> is not assignable to <span class="keyword">type</span> <span class="string">'void'</span></span><br></pre></td></tr></table></figure></p><p>하지만 <code>void</code>로 선언된 변수에는 <code>undefined</code>와 <code>null</code> 값만 할당할 수 있습니다.</p><h3 id="Null-Undefined"><a href="#Null-Undefined" class="headerlink" title="Null, Undefined"></a>Null, Undefined</h3><p>기본적으로 <code>null</code>과 <code>undefined</code>는 모든 타입들의 서브타입이라고 할 수 있습니다. 즉 다른 타입으로 지정된 변수에도 <code>null</code>과 <code>undefined</code>를 할당할 수 있습니다.</p><blockquote><p><code>--strictNullChecks</code> flag를 사용하게 되면 <code>null</code>과 <code>undefined</code>는 <code>void</code>타입의 변수에만 할당할 수 있습니다. TypeScript에서는 해당 flag사용을 권장하고 있습니다.</p></blockquote><h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p><code>never</code> 타입은 발생하지 않는 경우에 대한 타입을 대표하는 타입입니다. 코드를 통해 살펴보겠습니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function returning never must have unreachable end point</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inferred return type is never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">"Something failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function returning never must have unreachable end point</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 예제와 같이 <code>throw</code>를 하거나 error를 발생시키는 function의 return type으로 설정합니다.<br><a href="https://blog.mariusschulz.com/2016/11/18/typescript-2-0-the-never-type" target="_blank" rel="noopener">About Never Type</a></p><h3 id="Type-Assertions"><a href="#Type-Assertions" class="headerlink" title="Type Assertions"></a>Type Assertions</h3><p>타입 어설션이란 개발자가 타입스크립트에게 “내가 무슨 짓을 하고 있는지 아니까, 나를 믿어줘!”하고 메세지를 보내는 것입니다. 주로 엔티티의 타입을 보다 구체적으로 설정할 때 사용합니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greet: <span class="built_in">any</span> = <span class="string">`Hello!`</span>;</span><br><span class="line"><span class="keyword">let</span> lengthOfGreet: <span class="built_in">number</span>;</span><br><span class="line">lengthOfGreet = greet.length;</span><br><span class="line">lengthOfGreet = (&lt;<span class="built_in">string</span>&gt; greet).length;</span><br><span class="line">lengthOfGreet = (greet <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure></p><p><code>any</code>타입에 대해서 <code>형변환(type casting)</code>하는 것처럼 보이지만 실제로는 특별한 검사나 데이터 재구성을 하지 않습니다. 이 타입 어설션은 컴파일 타임에만 영향을 미칠뿐 런타임시에는 아무런 영향을 주지 않습니다. 보다 데이터 타입을 구체화 시킬 때 사용합니다.<br><code>&lt;&gt;</code>를 사용하는 방법과 <code>as</code>를 사용하는 두 가지 방법이 존재합니다. 선호도에 따라 어떻게 사용할지 결정할 수 있지만 <code>JSX</code>와 함께 사용하는 경우에는 <code>as</code>를 사용하는 방법만 허용됩니다.</p><p>감사합니다 :)</p><p><em>1. Basic Type end</em></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="noopener">TypeScript Official Document - Basic Types</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/typescript.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;TS-1-Basic-Types&quot;&gt;&lt;a href=&quot;#TS-1-Basic-Types&quot; class=&quot;headerlink&quot; title=&quot;[TS] 1. Bas
      
    
    </summary>
    
      <category term="TypeScript" scheme="https://jaeyeophan.github.io/categories/TypeScript/"/>
    
    
      <category term="ts" scheme="https://jaeyeophan.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>[TDD] 3. Chai-http 사용하여 REST API Test하기</title>
    <link href="https://jaeyeophan.github.io/2017/04/23/BDD-3-chai-http/"/>
    <id>https://jaeyeophan.github.io/2017/04/23/BDD-3-chai-http/</id>
    <published>2017-04-23T07:07:57.000Z</published>
    <updated>2017-05-21T04:42:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/tool_chai.png" alt=""></p><h1 id="TDD-3-Chai-http-사용하여-REST-API-Test하기"><a href="#TDD-3-Chai-http-사용하여-REST-API-Test하기" class="headerlink" title="[TDD] 3. Chai-http 사용하여 REST API Test하기"></a>[TDD] 3. Chai-http 사용하여 REST API Test하기</h1><p><a href="https://jaeyeophan.github.io/2017/04/23/BDD-1-mocha/">&gt;Mocha - Getting started&gt;</a><br><br><a href="https://jaeyeophan.github.io/2017/04/23/BDD-2-chai/">&gt;Chai - Getting started&gt;</a></p><p>이번 포스팅에서는 <code>chai-http</code>라는 module을 사용해서 REST API를 테스트하는 코드를 작성해보겠습니다.</p><p>테스트에 집중하기 위해 요청을 받을 서버는 <code>json-server</code>라는 모듈을 사용하여 구축하겠습니다. <code>json</code>형태로 데이터를 생성하고 요청을 받을 수 있는 임시 서버입니다. 데이터베이스를 따로 구축하지 않아도 <code>CRUD</code>와 같은 기본적인 API를 제공해주는 모듈입니다. 포스팅에서 다루는 내용보다 더 자세한 내용은 해당 <a href="https://github.com/typicode/json-server" target="_blank" rel="noopener">링크</a>를 참조하시면 되겠습니다.</p><h2 id="테스트-환경-구축하기"><a href="#테스트-환경-구축하기" class="headerlink" title="테스트 환경 구축하기"></a>테스트 환경 구축하기</h2><p>우선 <code>chai-http</code>를 설치합니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add chai-http</span><br></pre></td></tr></table></figure></p><p>그리고 서버로 사용할 <code>json-server</code>를 설치합니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn global add json-server</span><br></pre></td></tr></table></figure></p><p>그런 다음 <code>src</code> 디렉토리(작업하고자 하는 디렉토리)로 이동하여 다음 명령어를 실행해줍니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ json-server --watch db.json</span><br></pre></td></tr></table></figure></p><p>위 명령어를 실행하게 되면 <code>db.json</code> 파일을 생성하게 되고 해당 <code>.json</code>파일에 기본적인 데이터가 들어가있습니다. <code>json-server</code>는 기본적으로 <code>3000</code>번 포트를 사용합니다. <a href="http://localhost:3000/" target="_blank" rel="noopener">localhost:3000</a>에 접속해보면 어떠한 데이터가 들어가있는지를 간단한 웹 페이지를 통해서도 확인하실 수 있습니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\&#123;^_^&#125;/ hi!</span><br><span class="line"></span><br><span class="line">Loading db.json</span><br><span class="line">Done</span><br></pre></td></tr></table></figure></p><p>console에는 귀여운 이모티콘이 환영을 해주네요 :)</p><p>보다 customized한 서버를 사용하시고 싶은 경우에는 다음과 같은 <code>.js</code>파일을 만들어 사용하실 수 있습니다.<br><figure class="highlight javascript"><figcaption><span>server.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsonServer = <span class="built_in">require</span>(<span class="string">'json-server'</span>);</span><br><span class="line"><span class="keyword">const</span> server = jsonServer.create();</span><br><span class="line"><span class="keyword">const</span> router = jsonServer.router(<span class="string">'db.json'</span>);</span><br><span class="line"><span class="keyword">const</span> middlewares = jsonServer.defaults();</span><br><span class="line"></span><br><span class="line">server.use(middlewares);</span><br><span class="line">server.use(router);</span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'JSON Server is running'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>위 파일은 <code>node server.js</code> 명령어로 실행하실 수 있습니다 :) 이번 포스팅에서는 default로 생성되는 임시 서버를 사용하겠습니다.</p><h2 id="test-파일-작성"><a href="#test-파일-작성" class="headerlink" title=".test 파일 작성"></a>.test 파일 작성</h2><p>이제 테스트 코드를 작성할 <code>.test</code>파일을 만들어 보겠습니다.<br><figure class="highlight javascript"><figcaption><span>rest.test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chai = <span class="built_in">require</span>(<span class="string">'chai'</span>);</span><br><span class="line"><span class="keyword">const</span> chaiHttp = <span class="built_in">require</span>(<span class="string">'chai-http'</span>);</span><br><span class="line"><span class="keyword">const</span> expect = chai.expect;</span><br><span class="line">chai.use(chaiHttp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">'http://localhost:3000'</span>;</span><br></pre></td></tr></table></figure></p><p>이전에 설치한 <code>chai</code>와 테스트 환경을 구축할 때 설치한 <code>chai-http</code>를 불러옵니다. 그리고 <code>chai</code>가 <code>chai-http</code>를 <code>use</code>합니다. 이전 포스팅에서 소개해드렸던 <code>expect</code>를 사용하기 위해 준비합니다. 마지막으로 요청을 보낼 서버의 api에서 반복될 url을 상수로 할당해줬습니다.</p><h2 id="Request-TEST"><a href="#Request-TEST" class="headerlink" title="Request TEST"></a>Request TEST</h2><p>본격적인 테스트 코드를 작성할 시간입니다. 우선 server에 요청이 제대로 가는지 확인해보겠습니다.<br><figure class="highlight javascript"><figcaption><span>rest.test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'Request test'</span>, () =&gt; &#123;</span><br><span class="line">    it(<span class="string">'request to server'</span>, done =&gt; &#123;</span><br><span class="line">        chai.request(url)</span><br><span class="line">            .get(<span class="string">'/'</span>)</span><br><span class="line">            .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">                expect(err).to.be.null;</span><br><span class="line">                expect(res).to.have.status(<span class="number">200</span>);</span><br><span class="line">                done();</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>위 코드는 <code>http://localhost:3000/</code>에 대한 <code>GET</code> 요청이 제대로 동작하는지 테스트하는 코드입니다.<br>해당 <code>url</code>로 <code>request</code>를 보내고 <code>get</code> 방식으로 그 요청을 보냅니다. 요청에 대한 응답을 <code>.end()</code>메소드로 받을 수 있습니다. 이 <code>end()</code> 메소드에는 요청에 대한 응답으로 <code>err</code>와 <code>res</code>를 파라미터로 받는 콜백 함수를 넘겨줍니다.<br>콜백 함수에서는 에러(<code>err</code>)는 <code>null</code>값이어야 하고, http status code는 <code>200</code>이어야 한다는 내용을 담고 있습니다. 모든 조건이 만족되면 <code>done()</code> 함수가 호출되면서 test가 pass하게 됩니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><p>위 명령어로 test를 실행해보겠습니다. 방금 전 <code>json-server</code>를 running한 터미널 창이 아닌 다른 터미널 창에서 실행하셔야 합니다. 요청을 받으러면 서버가 running 중이어야 하니까요 :)<br><figure class="highlight bash"><figcaption><span>test terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REST <span class="built_in">test</span></span><br><span class="line">  ✓ request to server</span><br><span class="line"></span><br><span class="line">1 passing (13ms)</span><br></pre></td></tr></table></figure></p><p>해당 테스트가 잘 pass한 것을 확인하실 수 있습니다.<br><figure class="highlight bash"><figcaption><span>json-server terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET / 200 2.318 ms - -</span><br></pre></td></tr></table></figure></p><p>그리고 아까 <code>json-server --watch db.json</code> 명령어를 실행한 console에서는 GET요청에 대한 로그를 남깁니다.</p><h2 id="CRUD-TEST"><a href="#CRUD-TEST" class="headerlink" title="CRUD TEST"></a>CRUD TEST</h2><h3 id="Data-Modeling"><a href="#Data-Modeling" class="headerlink" title="Data Modeling"></a>Data Modeling</h3><p>테스트를 위해 <code>db.json</code>에 간단한 데이터를 넣어보겠습니다. 다음과 비슷한 형식으로 바꿔줍니다.<br><figure class="highlight json"><figcaption><span>db.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"users"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Jbee"</span>,</span><br><span class="line">      <span class="attr">"age"</span>: <span class="number">25</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"foo"</span>,</span><br><span class="line">      <span class="attr">"age"</span>: <span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"bar"</span>,</span><br><span class="line">      <span class="attr">"age"</span>: <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>users</code>라는 배열을 지정해줬습니다. 배열의 요소에는 <code>name</code>과 <code>age</code>를 갖고 있는 <code>json</code>형식의 데이터를 넣어줬습니다. 저장을 하면 <code>--watch</code>옵션을 붙여 실행했기 때문에 변경된 데이터 사항이 자동으로 반영됩니다. <code>localhost:3000</code>의 웹 페이지도 새로고침을 해보면 새로운 데이터가 들어가있는 것을 확인하실 수 있습니다. 이 데이터에는 <code>/users</code>라는 api로 접근이 가능합니다.</p><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p><code>db.json</code>파일에 추가한 <code>users</code>데이터를 가져와 봅시다.<br><figure class="highlight javascript"><figcaption><span>rest.test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'GET'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'fetch all users'</span>, done =&gt; &#123;</span><br><span class="line">    chai.request(url)</span><br><span class="line">        .get(<span class="string">'/users'</span>)</span><br><span class="line">        .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">            expect(err).to.be.not.ok;</span><br><span class="line">            expect(res).to.have.status(<span class="number">200</span>);</span><br><span class="line">            expect(res.body).to.be.an(<span class="string">'array'</span>);</span><br><span class="line">            done();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>이전의 코드와 매우 유사합니다. <code>res.body</code>에 대한 값을 확인하는 코드가 추가되었습니다. array 형식의 데이터라면 test를 pass시키도록 테스트 코드를 작성했습니다. test가 잘 통과하네요 :)<br>특정 <code>user</code>에 대한 값만 가져오려면 어떻게 해야 할까요?<br><figure class="highlight javascript"><figcaption><span>rest.test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'fetch one user'</span>, done =&gt; &#123;</span><br><span class="line">  chai.request(url)</span><br><span class="line">      .get(<span class="string">'/users'</span>)</span><br><span class="line">      .query(&#123;<span class="attr">id</span>: <span class="number">1</span>&#125;)</span><br><span class="line">      .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">          expect(err).to.be.null;</span><br><span class="line">          expect(res).to.have.status(<span class="number">200</span>);</span><br><span class="line">          expect(res.body[<span class="number">0</span>]).to.deep.equal(</span><br><span class="line">              &#123;</span><br><span class="line">                  id: <span class="number">1</span>,</span><br><span class="line">                  name: <span class="string">"Jbee"</span>,</span><br><span class="line">                  age: <span class="number">25</span></span><br><span class="line">              &#125;</span><br><span class="line">          );</span><br><span class="line">          done();</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>위 예제 코드를 describe 콜백 함수 안에 추가해줍니다. 와 같이 <code>.query()</code>에 해당하는 조건을 넘겨줄 수 있습니다. 응답으로 오는 데이터가 명시한 값과 일치하는지를 테스트 코드로 작성해줬습니다.</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><figure class="highlight javascript"><figcaption><span>rest.test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'POST'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'add user'</span>, done =&gt; &#123;</span><br><span class="line">    chai.request(url)</span><br><span class="line">        .post(<span class="string">'/users'</span>)</span><br><span class="line">        .send(&#123;<span class="attr">id</span>: <span class="number">4</span>, <span class="attr">name</span>: <span class="string">'react'</span>, <span class="attr">age</span>: <span class="number">3</span>&#125;)</span><br><span class="line">        .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">            expect(err).to.be.not.ok;</span><br><span class="line">            expect(res).to.have.status(<span class="number">201</span>);</span><br><span class="line">            user = res.body;</span><br><span class="line">            done();</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>post()</code>메소드와 <code>send()</code> 메소드를 통해 테스트를 진행할 수 있습니다.</p><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><figure class="highlight javascript"><figcaption><span>rest.test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'PATCH'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'update user'</span>, done =&gt; &#123;</span><br><span class="line">    chai.request(url)</span><br><span class="line">        .patch(<span class="string">'/users/2'</span>)</span><br><span class="line">        .send(&#123;<span class="attr">name</span>: <span class="string">'angular'</span>, <span class="attr">age</span>: <span class="number">1</span>&#125;)</span><br><span class="line">        .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">            expect(err).to.be.not.ok;</span><br><span class="line">            expect(res).to.have.status(<span class="number">200</span>);</span><br><span class="line">            done();</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>patch()</code>메소드와 <code>send()</code> 메소드를 통해 테스트를 진행할 수 있습니다.</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><figure class="highlight javascript"><figcaption><span>rest.test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'DELETE'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'delete user'</span>, done =&gt; &#123;</span><br><span class="line">    chai.request(url)</span><br><span class="line">        .delete(<span class="string">'/users/4'</span>)</span><br><span class="line">        .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">            expect(err).to.be.not.ok;</span><br><span class="line">            expect(res).to.have.status(<span class="number">200</span>);</span><br><span class="line">            done();</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>delete()</code>메소드를 통해 테스트를 진행할 수 있습니다.</p><p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/javascript_test_tutorial" target="_blank" rel="noopener">Github Respository</a>에서 확인하실 수 있습니다.</p><p><em>[TDD] 3. end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/tool_chai.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;TDD-3-Chai-http-사용하여-REST-API-Test하기&quot;&gt;&lt;a href=&quot;#TDD-3-Chai-http-사용하여-REST-API-Test하기
      
    
    </summary>
    
      <category term="Tool" scheme="https://jaeyeophan.github.io/categories/Tool/"/>
    
    
      <category term="TDD" scheme="https://jaeyeophan.github.io/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>[TDD] 2. Chai - Getting started</title>
    <link href="https://jaeyeophan.github.io/2017/04/23/BDD-2-chai/"/>
    <id>https://jaeyeophan.github.io/2017/04/23/BDD-2-chai/</id>
    <published>2017-04-23T07:07:45.000Z</published>
    <updated>2017-05-21T04:42:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/tool_chai.png" alt=""></p><h1 id="TDD-2-Chai-Getting-started"><a href="#TDD-2-Chai-Getting-started" class="headerlink" title="[TDD] 2. Chai - Getting started"></a>[TDD] 2. Chai - Getting started</h1><p><a href="https://jaeyeophan.github.io/2017/04/23/BDD-1-mocha/">&gt;Mocha - Getting started&gt;</a></p><p>이전 포스팅에서 <code>Mocha</code>를 사용한 테스트를 진행해봤습니다. 이전 포스팅의 예제 코드에 Assertion Library인 <code>Chai</code>를 추가해보겠습니다.</p><p><code>Chai</code>는 세 가지 style의 <code>Assertion</code>을 제공합니다.</p><ul><li>assert<br>기본적으로 node에서 제공하는 <code>Assert</code>라이브러리와 유사합니다.<br></li><li>expect<br><code>BDD</code> 스타일로 제공되는 인터페이스 중 하나로 공식 문서에서는 <code>natural longuage</code>처럼 <code>chaining</code>을 제공하여 코드를 작성할 수 있게 해준다고 합니다. 잠시 후 예제 코드로 살펴보겠습니다.<br></li><li>should<br><code>BDD</code> 스타일로 제공되는 인터페이스 중 나머지 하나로 <code>expect</code> 인터페이스와 마찬가지로 <code>chainging</code>을 통한 API를 제공합니다.<br></li></ul><p>라이브러리에 대한 보다 구체적인 내용은 공식 문서를 참조하시면 되겠습니다. <a href="http://chaijs.com/guide/styles/" target="_blank" rel="noopener">&gt;Chai Documents&gt;</a></p><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>우선, <code>Chai</code>를 설치해줍니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn global add chai</span><br></pre></td></tr></table></figure><p>이전에 작성했던 <code>/test/operator.test.js</code> 코드에서 <code>Chai</code>를 불러옵니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chai = <span class="built_in">require</span>(<span class="string">'chai'</span>);</span><br><span class="line"><span class="keyword">const</span> expect = chai.expect;</span><br><span class="line"><span class="keyword">const</span> should = chai.should();</span><br></pre></td></tr></table></figure><p><code>expect</code>와 <code>should</code>가 불러오는 방식이 약간 다릅니다. <code>expect</code> 인터페이스는 assertion을 제공하는 시작점으로 함수를 제공합니다. <code>should</code> 인터페이스는 <code>Object.prototype</code>을 확장하여 단일 Getter를 제공하고 그것을 시작점으로 제공합니다.</p><p><code>expect</code> 인터페이스를 통해 지저분했던 <code>if</code> 구문을 제거해봅시다!</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'sum 함수 테스트'</span>, () =&gt; &#123;</span><br><span class="line">    it (<span class="string">'10과 20를 넘기면 30이 나와야 한다'</span>, done =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> result = sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        expect(result).to.equal(<span class="number">30</span>);</span><br><span class="line">        done();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>첫번째로 등장한 api, <code>equal</code>입니다! <code>equal()</code>메소드에는 파라미터르 기대값이 들어가게 됩니다. 테스트 하고자 하는 함수의 반환 값이 기대값과 다르게 되면 그에 해당하는 error message가 나타납니다. 30을 40으로 바꾸고 실행해보겠습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sum 함수 테스트</span><br><span class="line">    1) 10과 20를 넘기면 30이 나와야 한다</span><br><span class="line"></span><br><span class="line">  0 passing (6ms)</span><br><span class="line">  1 failing</span><br><span class="line"></span><br><span class="line">  1) sum 함수 테스트 10과 20를 넘기면 30이 나와야 한다:</span><br><span class="line"></span><br><span class="line">      AssertionError: expected 30 to equal 40</span><br><span class="line">      + expected - actual</span><br><span class="line"></span><br><span class="line">      -30</span><br><span class="line">      +40</span><br><span class="line"></span><br><span class="line">      at Context.done (<span class="built_in">test</span>/operator.test.js:37:27)</span><br></pre></td></tr></table></figure><p>정말 친절한 <code>log</code>가 출력되는 것을 확인할 수 있습니다. describe에 기술했던 section 이름이 제일 먼저 출력되고, 테스트를 실행한 단위 테스트의 이름이 출력됩니다. 그리고 통과한 단위 테스트와 실패한 단위 테스트에 대한 정보가 나타납니다. 기대값과 실제 반환값과의 차이를 보여주며 어느 부분에서 에러가 발생했는지까지 출력됩니다 :)</p><h2 id="Expect-API"><a href="#Expect-API" class="headerlink" title="Expect API"></a>Expect API</h2><p><a href="http://chaijs.com/api/bdd/" target="_blank" rel="noopener">BDD style, Expect API</a></p><h3 id="ok"><a href="#ok" class="headerlink" title=".ok"></a>.ok</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect(<span class="literal">false</span>).to.not.be.ok;</span><br><span class="line">expect(<span class="literal">undefined</span>).to.not.be.ok;</span><br><span class="line">expect(<span class="literal">null</span>).to.not.be.ok;</span><br></pre></td></tr></table></figure><p>넘겨받는 값이 <code>false</code>인지 <code>undefined</code>인지 <code>null</code>인지 한 번에 판단할 수 있는 API입니다. 위 예제 코드에서는 일단 테스트가 통과하는 상황을 만들기 위해 <code>not</code>을 붙였는데요, 실제 테스트 코드에서는 <code>not</code>을 제거하여 사용하면 값을 한 번에 판단할 수 있는 API가 됩니다. <code>boolean</code>에 대해서는 <code>.true</code>, <code>.falase</code>가 별도로 존재합니다. 그리고 배열이 <code>empty</code>인지를 판단하는 <code>.empty</code>도 별도로 존재합니다.</p><h3 id="deep"><a href="#deep" class="headerlink" title=".deep"></a>.deep</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect(foo).to.deep.equal(&#123; <span class="attr">bar</span>: <span class="string">'baz'</span> &#125;);</span><br><span class="line">expect(&#123; <span class="attr">foo</span>: &#123; <span class="attr">bar</span>: &#123; <span class="attr">baz</span>: <span class="string">'quux'</span> &#125; &#125; &#125;)</span><br><span class="line">  .to.have.deep.property(<span class="string">'foo.bar.baz'</span>, <span class="string">'quux'</span>);</span><br></pre></td></tr></table></figure><p>객체를 <code>equal</code>로 비교를 하기 위해서는 추가적으로 <code>deep</code> flag가 필요합니다.</p><h3 id="include-vs-have"><a href="#include-vs-have" class="headerlink" title=".include vs .have"></a>.include vs .have</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.include vs .have</span></span><br><span class="line">expect([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).to.include(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// expect([1,2,3]).to.have(2); // error!</span></span><br><span class="line">expect([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).to.have.property(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;;</span><br><span class="line">expect(obj).to.include.property(<span class="string">'foo'</span>);</span><br><span class="line">expect(obj).to.have.property(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">expect(<span class="string">'foobar'</span>).to.include.string(<span class="string">'bar'</span>);</span><br><span class="line">expect(<span class="string">'foobar'</span>).to.have.string(<span class="string">'bar'</span>);</span><br></pre></td></tr></table></figure><p>(사실 두 API의 차이점을 잘 모르겠다.)</p><h3 id="사용하기"><a href="#사용하기" class="headerlink" title="사용하기"></a>사용하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deepCss = &#123; <span class="string">'.link'</span>: &#123; <span class="string">'[target]'</span>: <span class="number">42</span> &#125;&#125;;</span><br><span class="line">expect(deepCss).to.have.deep.property(<span class="string">'\\.link.\\[target\\]'</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure><p><code>.</code>이나 <code>[</code>,<code>]</code>을 사용하기 위해서는 <code>\\</code>를 사용하여 표시할 수 있습니다.</p><p>제공되는 API 종류가 정말 많아서, 왠지 있을 것 같은 API는 <a href="http://chaijs.com/api/bdd/" target="_blank" rel="noopener">공식 문서</a>에서 찾아보면서 테스트 코드를 작성하면 되겠습니다.</p><p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/javascript_test_tutorial" target="_blank" rel="noopener">Github Respository</a>에서 확인하실 수 있습니다.</p><p><a href="https://jaeyeophan.github.io/2017/04/23/BDD-3-chai-http/">&gt;Chai-http를 사용하여 REST API test하기&gt;</a></p><p><em>[TDD] 2. end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/tool_chai.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;TDD-2-Chai-Getting-started&quot;&gt;&lt;a href=&quot;#TDD-2-Chai-Getting-started&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="Tool" scheme="https://jaeyeophan.github.io/categories/Tool/"/>
    
    
      <category term="TDD" scheme="https://jaeyeophan.github.io/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>[TDD] 1. Mocha - Getting started</title>
    <link href="https://jaeyeophan.github.io/2017/04/23/BDD-1-mocha/"/>
    <id>https://jaeyeophan.github.io/2017/04/23/BDD-1-mocha/</id>
    <published>2017-04-23T07:07:34.000Z</published>
    <updated>2017-05-21T04:42:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/tool_mocha.png" alt=""></p><h1 id="TDD-1-Mocha-Getting-started"><a href="#TDD-1-Mocha-Getting-started" class="headerlink" title="[TDD] 1. Mocha - Getting started"></a>[TDD] 1. Mocha - Getting started</h1><p><code>Mocha</code>란 러너를 포함하고 있는 테스트 프레임워크로 사용자 수가 가장 많은 테스크 프레임워크입니다. <code>Mocha</code>는 자체적으로 assertion을 지원하지 않기 때문에 다른 <code>Assertion</code>라이브러리와 함께 사용해야 합니다. 기본적으로 node에서 제공하는 <code>assert</code>라이브러리가 존재하며 요즘에는 주로 <code>chai</code>라는 라이브러리와 함께 사용한다고 합니다. 라이브러리에 대한 내용은 공식 문서를 참조하시면 되겠습니다.<br><a href="http://mochajs.org/" target="_blank" rel="noopener">&gt;Mocha Documents</a></p><p>Mocha는 기본적으로 BDD 기반의 프레임워크입니다. 하지만 BDD와 TDD 두 종류의 인터페이스를 모두 제공하고 있습니다. 이번 포스팅에서는 BDD 기반의 예제를 살펴봅니다.<br><a href="http://joshldavis.com/2013/05/27/difference-between-tdd-and-bdd/" target="_blank" rel="noopener">TDD vs BDD</a></p><h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><ol><li><code>mocha</code>를 global로 설치해줍니다. <em>(cf <a href="http://jaeyeophan.github.io/2017/04/21/YARN-New-Package-Manger/">YARN, 새로운 Package Manager</a>)</em><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ yarn global add mocha</span><br><span class="line"><span class="comment">#success Installed "mocha@3.2.0" with binaries:</span></span><br><span class="line"><span class="comment">#      - mocha</span></span><br><span class="line"><span class="comment">#      - _mocha</span></span><br><span class="line"><span class="comment">#✨  Done in 4.23s.</span></span><br></pre></td></tr></table></figure></li></ol><p>저는 3.2.0 version의 <code>mocha</code>를 설치했습니다.</p><ol start="2"><li>보다 간편한 테스트 run을 위해 <code>package.json</code>에 scripts 추가합니다.<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">"scripts": &#123;</span><br><span class="line">  "test": "mocha $(find ./ -name '*./test/**/*.test.js') --recursive -w"</span><br><span class="line">&#125;,</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure></li></ol><p><code>test</code>라는 명령어로 <code>mocha</code>를 실행하며 <code>test</code>디렉토리에 있고 <code>.test.js</code>파일을 찾아 <code>mocha</code>를 실행시킵니다. 그리고 추가적으로 <code>-w</code>옵션을 통해 파일이 변경될 때마다 자동으로 테스트를 수행할 수 있게 합니다.</p><ol start="3"><li><code>/src/operator.js</code> 파일을 생성하고 다음 코드를 작성합니다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>정말 간단하게, 두 수를 파라미터로 받아 합을 반환하는 <code>sum</code> 함수를 테스트해보겠습니다.</p><ol start="4"><li><code>/test/operator.test.js</code> 파일을 생성하고 다음 코드를 작성합니다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> operator = <span class="built_in">require</span>(<span class="string">'../src/operator'</span>);</span><br><span class="line"><span class="keyword">const</span> sum = operator.sum;</span><br></pre></td></tr></table></figure></li></ol><p>우선 <code>/src/operator.js</code> 파일을 <code>import</code>합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'operator.js Test'</span>, () =&gt; &#123;</span><br><span class="line">    describe(<span class="string">'sum 함수 테스트'</span>, () =&gt; &#123;</span><br><span class="line">        it (<span class="string">'10과 20를 넘기면 30이 나와야 한다.'</span>, done =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> result = sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span> (result === <span class="number">30</span>) &#123;</span><br><span class="line">                done();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'결과 값이 30이 아니다.'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>드디어 테스트 코드를 작성했습니다. <code>describe</code>에서는 테스트의 <code>이름</code>을 지정합니다. 위 예제 코드처럼 중첩하여 사용할 수 있으며 테스트를 구분하는 <code>section</code>이라고 표현할 수 있겠습니다. 그리고 실행해야하는 부분(단위 테스트 단위)을 콜백으로 넘겨줍니다. <code>it</code> 구문에는 단위 테스트 이름을 작성하고 실제 실행되는 코드를 콜백(<code>done</code>)으로 넘겨줍니다. 그런 다음, <code>package.json</code>에 작성했던 <code>npm test</code> 명령어를 통해 test를 실행해줍니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm test</span><br><span class="line">  sum 함수 테스트</span><br><span class="line">    ✓ 10과 20를 넘기면 30이 나와야 한다.</span><br><span class="line"></span><br><span class="line">  1 passing (2ms)</span><br></pre></td></tr></table></figure></p><p>이렇게 나왔으면 테스트가 통과한 것입니다. <code>done()</code> 메소드가 실행되면 테스트가 통과하도록 테스트 코드를 작성할 수 있습니다. <code>result === 40</code>처럼 옳지 않은 값을 넣어주면, <code>throw Error()</code>가 실행되면서 테스트가 실패했다는 메세지가 나타납니다.</p><h3 id="Mocha의-hook"><a href="#Mocha의-hook" class="headerlink" title="Mocha의 hook"></a>Mocha의 hook</h3><p><code>Mocha</code>에서는 추가적으로 네 가지의 함수를 제공합니다. 각각은 테스트 코드가 실행되기 전과 후에 실행되는 함수입니다.</p><ul><li>before<br>: 테스트 코드가 실행되기 전에 한 번 실행된다.</li><li>beforeEach<br>: (테스트가 여러 개일 경우) 각각의 테스트 코드가 실행되기 전마다 실행된다.</li><li>afterEach<br>: (테스트가 여러 개일 경우) 각각의 테스트 코드가 실행된 후마다 실행된다.</li><li>after<br>: 모든 테스트 코드가 실행된 후 한 번 실행된다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'operator.js Test'</span>, () =&gt; &#123;</span><br><span class="line">    describe(<span class="string">'sum 함수 테스트'</span>, () =&gt; &#123;</span><br><span class="line">        before(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"before"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">"beforeEach"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        it (<span class="string">'10과 20를 넘기면 30이 나와야 한다.'</span>, (done) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> result = sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span> (result === <span class="number">30</span>) &#123;</span><br><span class="line">                done();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'결과 값이 30이 아니다.'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        after(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"after"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"afterEach"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>각각 상황에 맞는 <code>console.log()</code>를 찍어줬습니다. <code>npm test</code> 명령어를 실행해보겠습니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="built_in">test</span></span><br><span class="line">  operator.js Test</span><br><span class="line">    sum 함수 테스트</span><br><span class="line">before</span><br><span class="line">beforeEach</span><br><span class="line">      ✓ 10과 20를 넘기면 30이 나와야 한다.</span><br><span class="line">afterEach</span><br><span class="line">after</span><br><span class="line"></span><br><span class="line">  1 passing (3ms)</span><br></pre></td></tr></table></figure></p><p>각각의 함수들이 위치하는 라인은 상관이 없습니다. 가독성이 좋기 위해 의미상으로 적절한 위치에 코드를 작성했습니다. 정말 간단하게 <code>Mocha</code>를 사용해봤습니다. <code>if</code>문을 통한 테스트 코드 작성이 너무 지저분했는데요, 이제 <code>Mocha</code>와 함께 <code>Chai</code>를 사용해보겠습니다!</p><p><a href="https://jaeyeophan.github.io/2017/04/23/BDD-2-chai/">&gt;&gt;Chai 테스트 프레임워크 &gt;&gt;</a></p><p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/javascript_test_tutorial" target="_blank" rel="noopener">Github Respository</a>에서 확인하실 수 있습니다.</p><p><em>[TDD] 1. end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/tool_mocha.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;TDD-1-Mocha-Getting-started&quot;&gt;&lt;a href=&quot;#TDD-1-Mocha-Getting-started&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Tool" scheme="https://jaeyeophan.github.io/categories/Tool/"/>
    
    
      <category term="TDD" scheme="https://jaeyeophan.github.io/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>[ES6] 10. Generator</title>
    <link href="https://jaeyeophan.github.io/2017/04/22/ES6-10-Generator/"/>
    <id>https://jaeyeophan.github.io/2017/04/22/ES6-10-Generator/</id>
    <published>2017-04-22T08:49:54.000Z</published>
    <updated>2017-04-24T08:58:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript_es6.png" alt=""></p><h1 id="ES6-10-Generator"><a href="#ES6-10-Generator" class="headerlink" title="[ES6] 10. Generator"></a>[ES6] 10. Generator</h1><h2 id="Generator는-무엇인가"><a href="#Generator는-무엇인가" class="headerlink" title="Generator는 무엇인가?"></a>Generator는 무엇인가?</h2><p><code>Generator function</code>으로 반환된 값을 <code>Generator Object</code>라고 하고 이 <code>Generator Obejct</code>는 <code>iterator</code> 프로토콜을 따르고 있다. 즉 <code>[Symbol.iterator]</code>가 프로퍼티에 추가되어 있다는 것이다. <code>Generator function</code>안에서는 <code>yield</code>라는 키워드를 사용해서 함수에 내부에 작성된 코드를 전부 실행하지 않는다. 제너레이터 함수는 <code>yield</code>를 기준으로 실행을 나누어서 진행한다. <code>iterator</code>프로토콜을 따르고 있기 때문에 순차적으로 실행할 수 있는 것이다.<br><em>cf&gt;<code>Generator function</code>를 <code>제너레이터 함수</code>로, <code>Generator Object</code>를 <code>제너레이터 오브젝트</code>로 표기.</em></p><h2 id="Generator-Function"><a href="#Generator-Function" class="headerlink" title="Generator Function"></a>Generator Function</h2><p><code>function*</code>로 표현할 수 있으며, 작성할 때는 일반 <code>function</code>처럼 선언문과 표현식으로 작성할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">calc</span>(<span class="params">prev, post</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"generator start"</span>);</span><br><span class="line">  <span class="keyword">yield</span> prev + post;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>or<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> calc = <span class="function"><span class="keyword">function</span>*(<span class="params">prev, post</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"generator start"</span>);</span><br><span class="line">  <span class="keyword">yield</span> prev + post;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>제너리에터 함수에 의해 반환되는 값은 제너레이터 오브젝트이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = calc(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> generator); <span class="comment">// object</span></span><br></pre></td></tr></table></figure></p><p>제너레이터 오브젝트를 반환하는 순간에는 오브젝트를 반환하기만 할 뿐, 내부 코드는 실행되지 않는다.</p><h2 id="Generator-Object"><a href="#Generator-Object" class="headerlink" title="Generator Object"></a>Generator Object</h2><p><code>new</code> 키워드를 사용하여 인스턴스를 생성할 수 없다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cal = <span class="keyword">new</span> calc();<span class="comment">// Error</span></span><br><span class="line"><span class="comment">//TypeError: calc is not a constructor</span></span><br></pre></td></tr></table></figure></p><p><code>next()</code> 메소드를 통해 제너레이터 함수를 실행시킬 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(generator.next());</span><br><span class="line"><span class="comment">//generator start</span></span><br><span class="line"><span class="comment">//&#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next());</span><br><span class="line"><span class="comment">//&#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></p><p><code>iterator</code>의 <code>next()</code>메소드를 실행시킨 것처럼 <code>value</code>와 <code>done</code>이라는 프로퍼티를 갖고 있는 객체로 반환된다. 그런데 첫번째 <code>next()</code>메소드 실행 시에는 <code>generator start</code>가 출력되었는데, 두번째 실행 시에는 출력되지 않았다. <code>yield</code>라는 키워드를 중심으로 함수가 나눠 실행되는 것이다.</p><h2 id="yield-키워드-함수를-실행하고-멈출-수-있다"><a href="#yield-키워드-함수를-실행하고-멈출-수-있다" class="headerlink" title="yield 키워드, 함수를 실행하고 멈출 수 있다."></a>yield 키워드, 함수를 실행하고 멈출 수 있다.</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[returnValue] = <span class="keyword">yield</span>[expression]</span><br></pre></td></tr></table></figure><p>위와 같은 구문으로 <code>yield</code>를 작성할 수 있다.</p><p>위의 예제 코드에서 살펴봤듯이, <code>next()</code> 메소드의 반환 값은 <code>value</code>와 <code>done</code>으로 구성되어 있는 오브젝트이다. 제너레이터의 메소드 <code>next()</code>에서 이 두 가지의 값은 yield에 의해 결정된다. <code>value</code>가 결정되는 규칙이 조금 복잡하다.</p><h5 id="value-결정-규칙"><a href="#value-결정-규칙" class="headerlink" title="value 결정 규칙"></a>value 결정 규칙</h5><ul><li><code>expression</code>으로 반환되는 값이 할당.<br>이 때, <code>expression</code>에 있는 값이 <code>returnValue</code>에 할당되지 않는다.</li><li><code>expression</code>에 아무것도 없으면 <code>undefined</code>가 할당.<br>이 때, <code>next()</code>의 파라미터로 넘겨지는 값이 <code>returnValue</code>에 할당된다.</li></ul><h5 id="done-결정-규칙"><a href="#done-결정-규칙" class="headerlink" title="done 결정 규칙"></a>done 결정 규칙</h5><ul><li>계속 수행할 <code>yield</code>가 남아있으면 <code>false</code>.</li><li>더 이상 실행할 <code>yield</code>가 없으면 <code>true</code>.</li></ul><p><em>예제 코드를 살펴보자.</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">calc</span>(<span class="params">prev, post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Initial result: <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">  result = <span class="keyword">yield</span> prev + post;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Middle result: <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  result = <span class="keyword">yield</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Last result: <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator = calc(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure></p><p>위에서 언급한 규칙에 대한 내용을 모두 담고 있는 예제코드이다. <code>console.log()</code>에는 어떠한 값이 찍히게 될까? 코드를 통해 하나씩 살펴보자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(generator.next());</span><br><span class="line"><span class="comment">// Initial result: 0</span></span><br><span class="line"><span class="comment">// &#123; value: 30, done: false &#125;</span></span><br></pre></td></tr></table></figure></p><p><code>next()</code> 메소드를 실행시키면 첫번째 yield까지 실행한다.<br>초기 <code>result</code> 변수에 대한 값이 출력되고,<br><code>expression</code>으로 계산된 값인 <code>30</code>이 <code>value</code>이 출력된다.<br>아직 <code>yield</code>가 남았으니 <code>done</code>은 <code>false</code>가 되겠다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(generator.next());</span><br><span class="line"><span class="comment">// Middle result: undefined</span></span><br><span class="line"><span class="comment">// &#123; value: undefined, done: false &#125;</span></span><br></pre></td></tr></table></figure><p>두번째 yield까지 실행한다.<br><code>expression</code> 값이 <code>result</code>에 할당되지 않은 것을 확인할 수 있다.<br>아직 <code>yield</code>가 남았으니 <code>done</code>은 <code>false</code>가 되겠다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(generator.next(<span class="number">20</span>));</span><br><span class="line"><span class="comment">// Last result: 20</span></span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>yield가 없으므로 brace까지 실행한다.<br><code>next()</code>메소드의 파라미터로 넘겨진 <code>20</code>이 <code>result</code> 변수에 할당된 것을 확인할 수 있다.<br>더이상 <code>yield</code> 키워드가 없으므로 <code>done</code>은 <code>true</code>가 된다.</p><h3 id="yield-대신-return"><a href="#yield-대신-return" class="headerlink" title="yield 대신 return"></a>yield 대신 return</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">calc</span>(<span class="params">prev, post</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + post;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator = calc(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(generator.next());</span><br><span class="line"><span class="comment">// &#123; value: 30, done: true &#125;</span></span><br></pre></td></tr></table></figure><p><code>return</code> 키워드 뒤에 오는 값이 <code>value</code>에 할당되고 <code>yield</code> 키워드의 유무와 상관없이 <code>done</code>에는 <code>true</code>가 할당된다. <code>return</code>은 수행되고 있는 이터레이터를 종료시키는 역할을 수행한다.</p><h3 id="이터레이터-종료하기"><a href="#이터레이터-종료하기" class="headerlink" title="이터레이터 종료하기"></a>이터레이터 종료하기</h3><p><code>yield</code> 키워드의 유무와 상관없이 이터레이터를 종료하고자 할 때는 제너레이터 오브젝트의 <code>throw()</code>메소드와 <code>return()</code>메소드를 사용할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">idMaker</span>(<span class="params">prev, post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> ++value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = idMaker();</span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.return(<span class="number">100</span>));<span class="comment">// &#123; value: 100, done: true &#125;</span></span><br></pre></td></tr></table></figure><p><code>return()</code>메소드의 파라미터로 넘어가는 값이 <code>value</code>에 할당된다.<br>위의 예제 코드에 <code>return()</code> 대신 <code>throw()</code>를 호출하게 되면 파라미터로 넘겨준 Error Message를 출력하고 이터레이터가 바로 종료된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">idMaker</span>(<span class="params">prev, post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> ++value;</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Error message: <span class="subst">$&#123;e&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = idMaker();</span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.throw(<span class="string">"Throw Exception"</span>));</span><br><span class="line"><span class="comment">//Error message: Throw Exception</span></span><br><span class="line"><span class="comment">//&#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></p><p>여기서 <code>try-catch</code> 구문에 <code>yield</code>를 추가하면 어떻게 될까?<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">idMaker</span>(<span class="params">prev, post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> ++value;</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="keyword">yield</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = idMaker();</span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.throw(<span class="string">"Throw Exception"</span>));</span><br><span class="line"><span class="comment">//&#123; value: 'Throw Exception', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></p><p>바로 이터레이터가 종료되지 않고 <code>yield</code> 다음의 구문이 실행된다.</p><h2 id="yield-키워드"><a href="#yield-키워드" class="headerlink" title="yield* 키워드"></a>yield* 키워드</h2><p><code>yield</code>에 <code>*</code>를 붙인 다음 <code>[expression]</code>에 이터러블 오브젝트를 작성할 수 있다. 이렇게 되면 해당 <code>yield</code>가 수행될 때 이터러블 오브젝트를 순회하게 된다. 코드를 통해 살펴보자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">// &#123; value: 10, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">// &#123; value: 20, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">// &#123; value: 30, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></p><p>우선적으로 배열을 순회한 후에, 다음에 해당하는 <code>yield</code>를 수행하게 된다.</p><h4 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h4><p>문법을 아는 것과 실제 프로그래밍에서 적용하는 것은 확실히 다른 문제이다. 지금 <code>yield</code>의 향연을 보고 이걸 어디에다가 쓰나 하는 생각이 들 것이다. 다음 링크들을 참고하면 좀 나아질 것 같아서, 몇 가지 링크를 첨부한다.</p><p><a href="http://meetup.toast.com/posts/73" target="_blank" rel="noopener">ES6의 제너레이터를 사용한 비동기 프로그래밍</a><br><a href="http://www.haruair.com/blog/3425" target="_blank" rel="noopener">Javascript의 Generator와 Koa.js</a><br><a href="http://blog.coderifleman.com/2014/11/15/javascript-and-async-error/" target="_blank" rel="noopener">자바스크립트와 비동기 오류 처리</a></p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="noopener">MDN function*</a></p><p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="noopener">Github Respository</a>에서 확인하실 수 있습니다.</p><p><em>10. end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javascript_es6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES6-10-Generator&quot;&gt;&lt;a href=&quot;#ES6-10-Generator&quot; class=&quot;headerlink&quot; title=&quot;[ES6] 1
      
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="es6" scheme="https://jaeyeophan.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>YARN, 새로운 Package Manger</title>
    <link href="https://jaeyeophan.github.io/2017/04/21/YARN-New-Package-Manger/"/>
    <id>https://jaeyeophan.github.io/2017/04/21/YARN-New-Package-Manger/</id>
    <published>2017-04-21T10:18:49.000Z</published>
    <updated>2017-04-21T13:13:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/fe_tool_yarn.jpg" alt=""></p><h1 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h1><p><code>YARN</code>이란 Facebook에서 만든 새로운 자바스크립트 패키지 매니저입니다. 기존에 존재하는 <code>npm</code>과 동일한 기능을 수행합니다. 그렇다면 Facebook은 <code>YARN</code>을 왜 만들었을까요? 이 부분에 대해서는 정리가 잘 되어 있는 링크를 첨부할게요!<br><a href="http://fetobe.co.kr/%EC%83%88%EB%A1%9C%EC%9A%B4-npm-client-yarn/" target="_blank" rel="noopener">&gt;새로운 NPM Client YARN&gt;</a></p><h2 id="YARN-설치하기"><a href="#YARN-설치하기" class="headerlink" title="YARN 설치하기"></a>YARN 설치하기</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install yarn</span><br></pre></td></tr></table></figure><p><code>Homebrew</code>를 통하여 설치할 수 있습니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn --version</span><br></pre></td></tr></table></figure></p><p>어느 모듈이나 마찬가지로 설치된 version을 확인할 수 있습니다.</p><h2 id="YARN-사용하기"><a href="#YARN-사용하기" class="headerlink" title="YARN 사용하기"></a>YARN 사용하기</h2><h3 id="새-프로젝트-시작하기"><a href="#새-프로젝트-시작하기" class="headerlink" title="새 프로젝트 시작하기"></a>새 프로젝트 시작하기</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn init</span><br></pre></td></tr></table></figure><p><code>npm</code>과 마찬가지로 <code>init</code>이라는 명령어를 통해 시작할 수 있으며, <code>package.json</code>파일이 없는 경우에는 <code>대화형 인터페이스</code>가 출력되면서 프로젝트를 설정할 수 있습니다. 이미 <code>package.json</code>이 존재하는 경우에는 해당 파일을 재사용하게 됩니다.</p><h3 id="패키지-설치하기"><a href="#패키지-설치하기" class="headerlink" title="패키지 설치하기"></a>패키지 설치하기</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add [package_name]</span><br><span class="line">$ yarn add [package_name]@[version]</span><br><span class="line">$ yarn add [package_name]@[tag]</span><br></pre></td></tr></table></figure><p><code>add</code>라는 command로 패키지를 설치(add)할 수 있습니다. <code>@</code>로 설치할 <code>version</code>과 <code>tag</code>를 명시할 수 있습니다.</p><h4 id="add-option"><a href="#add-option" class="headerlink" title="add option"></a><code>add</code> option</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add [package_name] --dev / -D</span><br></pre></td></tr></table></figure><p>해당 패키지가 <code>devDependencies</code>에 추가됩니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add [package_name] --peer / -P</span><br></pre></td></tr></table></figure></p><p>해당 패키지가 <code>peerDependencies</code>에 추가됩니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add [package_name] --optional / -O</span><br></pre></td></tr></table></figure></p><p>해당 패키지가 <code>optionalDependencies</code>에 추가됩니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add [package_name] --exact / -E</span><br></pre></td></tr></table></figure></p><p><code>@</code>로 version을 명시할 수 있지만, 보다 strict하게 version을 명시하여 설치하는 경우에 사용합니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add [package_name] --tilde / -T</span><br></pre></td></tr></table></figure></p><p>기본적으로 가장 최근 release version의 패키지를 설치하지만, 좀 더 최신의 version을 설치하는 경우에 사용합니다.</p><h3 id="패키지-업그레이드"><a href="#패키지-업그레이드" class="headerlink" title="패키지 업그레이드"></a>패키지 업그레이드</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yarn upgrade [package_name]</span><br><span class="line">$ yarn upgrade [package_name]@[version]</span><br><span class="line">$ yarn upgrade [package_name]@[tag]</span><br></pre></td></tr></table></figure><p><code>upgrade</code>라는 명령어를 통해 설치한 패키지를 업그레이드 할 수 있습니다.</p><h3 id="모듈-제거"><a href="#모듈-제거" class="headerlink" title="모듈 제거"></a>모듈 제거</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn remove [package]</span><br></pre></td></tr></table></figure><p><code>remove</code>라는 명령어를 통해 설치한 패키지를 제거할 수 있습니다.</p><h3 id="다른-Command"><a href="#다른-Command" class="headerlink" title="다른 Command"></a>다른 Command</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn global [add/ls/remove/upgrade]</span><br></pre></td></tr></table></figure><p><code>npm</code>에서의 <code>--global</code> 와 비슷한 기능을 수행하는 <code>global</code> 이 추가된 명령어입니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn clean</span><br></pre></td></tr></table></figure></p><p><code>clean</code> 명령어는 현재 설치된 패키지들의 의존성을 분석하여 사용하지 않는, 불필요한 파일들을 제거해줍니다. 이 명령어를 한 번 실행하면 <code>.yarnclean</code> 파일이 생성되며 version control에 추가해야 합니다. 한 번 실행된 후, 불필요한 파일들을 제거해주는 작업은 yarn 커맨드를 통해 어떠한 패키지를 설치하는 경우(<code>add</code> or <code>run</code> command)에 자동적으로 수행됩니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn info [package_name] [option]</span><br></pre></td></tr></table></figure></p><p><code>info</code> 명령어를 통해 해당 패키지의 정보를 볼 수 있습니다. <code>option</code>으로 <code>readme</code>를 입력하게 되면 해당 패키지에 작성된 <code>README.md</code>파일을 볼 수 있습니다.(다양한 option command가 존재합니다!)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn list [--depth]</span><br></pre></td></tr></table></figure></p><p><code>list</code> 명령어를 통해 현재 작업 중인 디렉토리의 모든 패키지들의 의존성 관계를 리스트로 확인할 수 있습니다. <code>depth</code> 옵션을 통해서 level을 지정할 수도 있습니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn outdated [package]</span><br></pre></td></tr></table></figure></p><p><code>outdated</code> 명령어를 통해 패키지들의 현재 설치된 version(Current)과 권장하는 version(Wanted), 최신 version(Latest)을 보여줍니다. 특정 <code>[package]</code>를 입력하여 원하는 패키지에 대해서만 볼 수 있습니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn pack</span><br></pre></td></tr></table></figure></p><p><code>pack</code> 명령어를 통해 패키지의 의존성들을 <code>gzip</code>으로 압축시킬 수 있습니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn run [script] [--&lt;args&gt;]</span><br></pre></td></tr></table></figure></p><p><code>run</code> 명령어를 통해 <code>npm</code>에서 처럼 <code>package.json</code>에서 정의한 <code>scripts</code>를 실행할 수 있습니다.</p><p>거의 모든 명령어가 기존에 사용하던 <code>npm</code>과 동일한 것을 확인하실 수 있었습니다 :)</p><h3 id="yarn-lock"><a href="#yarn-lock" class="headerlink" title="yarn.lock"></a>yarn.lock</h3><p><code>yarn</code>으로 모듈을 설치하다보면 <code>yarn.lock</code>이라는 파일이 생성된 것을 확인할 수 있다. 이것은 설치한 모듈들의 각각 의존성 관리를 해줍니다.<br>이미 <code>package.json</code>이 하고 있는거 아닌가? 라는 생각이 드는데요, 하지만 페이스북이 <code>yarn</code>을 만든 이유 중 하나는 보다 정확하게 패키지들의 의존성을 관리하기 위함이었습니다. <code>yarn.lock</code> 파일에는 <code>package.json</code>에 있는 것보다 더 많은 정보를 갖고 있습니다. 그렇기 때문에 좀 더 엄격한 의존성 관리가 가능하다고 합니다. (위에서 언급한 <code>.yarnclean</code>파일과 함께  version control system에 추가해줘야 합니다.)</p><h4 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h4><p>기존의 NPM과 많이 다를 줄 알고 열심히 정리했는데 거의 정말 비슷하네요! 같은 값이면 다홍치마라고, 좀 더 빠르고 의존성 관리를 정확하게 해주는 <code>YARN</code>으로 옮겨갈 때인가요? 이상 <code>YARN</code>에 대한 포스팅이었습니다 :)</p><h4 id="참고할-만한-링크"><a href="#참고할-만한-링크" class="headerlink" title="참고할 만한 링크"></a>참고할 만한 링크</h4><ul><li><a href="https://www.pluralsight.com/guides/node-js/yarn-a-package-manager-for-node-js" target="_blank" rel="noopener">YARN vs NPM</a></li><li><a href="https://shift.infinite.red/npm-vs-yarn-cheat-sheet-8755b092e5cc" target="_blank" rel="noopener">YARN Cheet Sheet</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/fe_tool_yarn.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;YARN&quot;&gt;&lt;a href=&quot;#YARN&quot; class=&quot;headerlink&quot; title=&quot;YARN&quot;&gt;&lt;/a&gt;YARN&lt;/h1&gt;&lt;p&gt;&lt;code&gt;YARN&lt;
      
    
    </summary>
    
      <category term="Tool" scheme="https://jaeyeophan.github.io/categories/Tool/"/>
    
    
      <category term="tool" scheme="https://jaeyeophan.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>[ES6] 9. Iterator</title>
    <link href="https://jaeyeophan.github.io/2017/04/21/ES6-9-Iterator/"/>
    <id>https://jaeyeophan.github.io/2017/04/21/ES6-9-Iterator/</id>
    <published>2017-04-21T08:15:09.000Z</published>
    <updated>2017-04-21T08:18:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript_es6.png" alt=""></p><h1 id="ES6-9-Iterator"><a href="#ES6-9-Iterator" class="headerlink" title="[ES6] 9. Iterator"></a>[ES6] 9. Iterator</h1><p><a href="https://jaeyeophan.github.io/2017/04/18/ES6-3-Iteration-and-for-of-statement/">&gt;&gt;3. Iterable and for-of statement&gt;&gt;</a><br><a href="https://jaeyeophan.github.io/2017/04/20/ES6-8-Symbol/">&gt;&gt;8. Symbol</a></p><p><em>이 포스팅은 이전에 작성된 두 포스팅을 기반으로 작성되었습니다.</em>  </p><p><code>iterator</code>는 순회 가능한 값들의 <code>시퀀스</code>를 만드는 방법을 정의한다.<br>대표적인 순회 가능한 것은 <code>Array</code>다. <code>Array</code> 오브젝트는 <code>Symbol.iterator</code>를 가지고 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arr[<span class="built_in">Symbol</span>.iterator]);<span class="comment">// function</span></span><br></pre></td></tr></table></figure></p><p>위 예제 코드에서 정의한 <code>arr</code>의 <code>iterator</code>를 추출하여 <code>arr</code>를 순회할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></p><p><code>iterator</code>를 추출하자마자 <code>head</code>(공식 용어는 아니고 설명을 위한 용어)는 배열의 시작점을 가리키게 된다.(첫 원소를 가리키는 것이 아니다.) 그 상태에서 <code>next()</code>메소드를 호출하게 되면, 첫번재 원소가 출력된다. 출력 값은 원소의 값인 <code>value</code>와 <code>done</code>이라는 <code>boolean</code> 값을 가지고 있는 <code>Object</code>이다. 마지막 원소까지 출력된 상태에서 <code>next()</code> 메소드를 호출하게 되면 <code>value</code>는 <code>undefined</code>가 되고 <code>done</code> 값은 <code>true</code>가 된다.</p><p>문자열에도 적용할 수 있다. <code>String</code> 오브젝트도 <code>iterable</code>프로토콜을 구현한 오브젝트이기 때문에 <code>iterator</code>를 사용할 수 있는 것이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"jbee"</span>;</span><br><span class="line"><span class="keyword">let</span> iterator = name[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value: j, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value: b, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value: e, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value: e, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></p><p><code>Object</code>에는 기본적으로 <code>iterator</code>가 존재하지 않는다. 때문에 <code>for-of</code>로 순회할 수 없다. 하지만 <code>iterator</code>를 오브젝트에 추가하여 <code>iterable</code>하게 만들 수 있다. 또한 배열을 상속받은 객체는 <code>iterable</code> 객체이므로 <code>iterator</code>를 사용할 수 있다.</p><p><code>iterator</code>를 사용하다 보면 뭔가 Java의 <code>interface</code> 또는 <code>@FunctionalInterface</code> 같은 느낌도 든다. java에서 해당 <code>interface</code>를 <code>implements</code>하게 되면 해당 기능을 사용할 수 있는 것처럼 구현하고자 하는 <code>Symbol</code>, 즉 <code>iterator</code>를 프로퍼티에 추가해서 사용하면 <code>iterator</code> 기능을 사용할 수 있는 것이다.</p><p>어떻게 하면 <code>iterator</code>를 그럴싸하게 사용해볼 수 있을까?<br>다음 예제는 이렇게 사용하면 어떨까? 정도의 예제 코드이다. 가볍게 보고 넘어가자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object to create id</span></span><br><span class="line"><span class="keyword">let</span> autoIncrement = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: ++id,</span><br><span class="line">          done: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Define User class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(id, name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> idCreator = autoIncrement[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> User(idCreator.next().value, <span class="string">"jbee"</span>));<span class="comment">// &#123; id: 1, name: 'jbee' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> User(idCreator.next().value, <span class="string">"foo"</span>));<span class="comment">// &#123; id: 2, name: 'foo' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> User(idCreator.next().value, <span class="string">"bar"</span>));<span class="comment">// &#123; id: 3, name: 'bar' &#125;</span></span><br></pre></td></tr></table></figure></p><p><code>autoIncraement</code> 객체에 <code>iterator</code> 프로퍼티를 추가하여, <code>id</code>를 순차적으로 생성하게 만들었다. <code>id</code>에 대해서는 외부에서 접근할 수 없으므로 안정적인 <code>id</code>가 생성될 수 있지 않을까?</p><p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="noopener">Github Respository</a>에서 확인하실 수 있습니다.</p><p><em>9.end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javascript_es6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES6-9-Iterator&quot;&gt;&lt;a href=&quot;#ES6-9-Iterator&quot; class=&quot;headerlink&quot; title=&quot;[ES6] 9. It
      
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="es6" scheme="https://jaeyeophan.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>[ES6] 8. Symbol</title>
    <link href="https://jaeyeophan.github.io/2017/04/20/ES6-8-Symbol/"/>
    <id>https://jaeyeophan.github.io/2017/04/20/ES6-8-Symbol/</id>
    <published>2017-04-20T02:53:45.000Z</published>
    <updated>2017-05-02T06:54:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript_es6.png" alt=""></p><h1 id="ES6-8-Symbol"><a href="#ES6-8-Symbol" class="headerlink" title="[ES6] 8. Symbol"></a>[ES6] 8. Symbol</h1><h2 id="Symbol이란-무엇인가"><a href="#Symbol이란-무엇인가" class="headerlink" title="Symbol이란 무엇인가?"></a>Symbol이란 무엇인가?</h2><blockquote><p>고유하고 수정 불가능한 데이터 타입(?)</p></blockquote><p>자바스크립트에는 <code>Primitive type</code>이라는 개념이 있다. ES5에는 <code>string</code>, <code>number</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>로 총 <strong>5가지</strong>의 원시 자료형이 존재한다. 여기에 ES6부터 <code>symbol</code>이라는 타입이 추가되었다.</p><p><code>Primitive type</code>들에게는 각각 Wrapper Object가 존재한다.(undefined와 null은 wrapper object가 존재하지 않는다.) <code>String</code> 오브젝트, <code>Boolean</code>오브젝트가 그 예이다. <code>symbol</code>도 마찬가지로 <code>Symbol</code> 오브젝트라는 wrapper Object가 존재한다. 각각의 wrapper obect에는 값을 처리하기 위한 메서드와 프로퍼티가 존재한다. <code>valueOf()</code>메소드를 통해 primitive value를 구할 수 있는 것이다. 하지만, <code>symbol</code>은 값을 반환하지 않는다!</p><h2 id="Symbol-도입-배경"><a href="#Symbol-도입-배경" class="headerlink" title="Symbol 도입 배경"></a>Symbol 도입 배경</h2><blockquote><p>왜 Symbol이 도입되었을까?</p></blockquote><p>처음 <code>Symbol</code>을 봤을 때는 <code>고유한 값</code>이라는 말에 <code>const</code>를 떠올렸다. 하지만 <code>Symbol</code>은 프로그램 전체를 통틀어 유일한 값을 의미한다. <code>Symbol()</code>이 실행될 때마다 유일한 값을 생성하는 것이다. 약속된 <code>Symbol</code> 값을 가지고 객체에 어떠한 특성을 부여할 수 있지 않을까? <code>Symbol</code>이란 무엇인가 먼저 알아보자.<br><em>(사실 라이브러리를 만들거나 프레임워크를 만들지 않는 이상, 실무에서 사용할 일이 거의 없을 것 같다.)</em></p><h2 id="Symbol에-대해서"><a href="#Symbol에-대해서" class="headerlink" title="Symbol에 대해서"></a>Symbol에 대해서</h2><p><code>Symbol</code>은 두 가지 <code>스코프(scope)</code>에 <code>생성</code>하여 <code>저장</code>할 수 있다.</p><h3 id="Symbol-생성하기-1"><a href="#Symbol-생성하기-1" class="headerlink" title="Symbol 생성하기 1"></a>Symbol 생성하기 1</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Symbol</span>(<span class="string">"symbol description"</span>);</span><br><span class="line"><span class="comment">//Error: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure><p><code>Symbol</code>은 <strong>객체가 아니다.</strong> 객체가 아닌 <code>Primitive type</code>이기 때문에 <code>new</code>키워드를 통해서 생성할 수 없다.<br><code>Symbol</code>을 생성할 때에는 다음과 같이 생성한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>(<span class="string">"symbol description"</span>);</span><br></pre></td></tr></table></figure><p><code>console.log()</code>를 통해 <code>Symbol</code>의 특징을 살펴보자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s);<span class="comment">//symbol</span></span><br><span class="line"><span class="built_in">console</span>.log(s.toString());<span class="comment">//Symbol(symbol description)</span></span><br><span class="line"><span class="built_in">console</span>.log(s.valueOf());<span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(s);<span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure></p><p>1) <code>Symbol</code>의 타입은 <code>symbol</code>이다.<br>2) 모든 built-in 오브젝트의 프로토타입에 연결되어 있는 <code>toString</code> 메소드를 통해서 <code>Symbol</code>의 <code>형태(description)</code>를 확인할 수 있다. 여기서 <code>형태</code>란 <code>Symbol</code>을 생성할 때 넘겨지는 parameter를 말한다. 주로 생성하는 <code>Symbol</code>을 설명하기 위한 문자열을 넘겨준다. 왠지 이 값을 통해 <code>Symbol</code>에 접근할 수 있을 것 같지만 그럴 수 없다.<br>3) 뒤에서 확인할 테지만 <code>Symbol</code>은 값을 외부로 노출시키지 않는다. 이러한 특성 때문에 <code>Symbol</code>을 출력하려고 하거나 <code>valueOf()</code> 메소드를 통해 값을 출력하려고 하면 <code>empty object</code>가 반환이 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"s1: "</span>, s1.toString());<span class="comment">//Symbol(foo)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"s2: "</span>, s2.toString());<span class="comment">//Symbol(foo)</span></span><br><span class="line"><span class="built_in">console</span>.log(s1 == s2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>두 <code>Symbol</code>은 같은 <code>description</code>을 갖고 있는 <code>Symbol</code>일 뿐, 다른 <code>Symbol</code>이다. <code>Symbol()</code>이 <strong>호출될 때마다</strong> 새로운 <code>Symbol</code>을 생성하기 때문이다. 이 때 <code>Symbol</code>은 생성한 <code>scope</code>에 <code>Symbol</code>값이 설정된다.</p><h3 id="Symbol-생성하기-2-key"><a href="#Symbol-생성하기-2-key" class="headerlink" title="Symbol 생성하기 2, key"></a>Symbol 생성하기 2, key</h3><p>아까 생성한 <code>Symbol</code>을 다시 사용할 니즈가 있을 것 같다. 그래서 고유한 값을 갖는 <code>Symbol</code>을 만들 때, <code>key</code>를 등록하고, <code>key</code>를 통해 접근한다.</p><ul><li><code>for</code> 메소드<br><code>for</code> 메소드를 사용하여 생성 또는 호출할 수 있다. <code>key</code> 값이 파라미터로 넘어가고 등록되어 있는 <code>Symbol</code>을 반환한다. 이 때 <code>key</code> 값에 해당하는 <code>Symbol</code>이 없다면 해당 <code>Symbol</code>을 <code>Symbol registry</code>에 등록한다. 즉 없으면 생성하는 것이다.</li><li><code>keyFor</code> 메소드<br><code>keyFor</code> 메소드는 <code>Symbol</code>을 받아서 해당 <code>Symbol</code>의 <code>description</code> 값을 반환한다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sFor1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="keyword">let</span> sFor2 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sFor1.toString());<span class="comment">//Symbol(foo)</span></span><br><span class="line"><span class="built_in">console</span>.log(sFor2.toString());<span class="comment">//Symbol(foo)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(sFor1));<span class="comment">//foo</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(sFor2));<span class="comment">//foo</span></span><br><span class="line"><span class="built_in">console</span>.log(sFor1 == sFor2);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(sFor1 === sFor2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>같은 <code>key</code>값으로 <code>Symbol</code>을 호출하게 되면 두 <code>Symbol</code>은 같은 <code>Symbol</code>이다. 위에서 그냥 <code>Symbol()</code>을 통해 생성한 것과의 차이점은 <code>key</code>값과 함께 <code>Symbol</code>을 만들게 되면 <code>Global Symbol registry</code>에 해당 <code>Symbol</code>이 등록되어 <code>Symbol()</code>이 호출될 때마다 새로운 <code>Symbol</code>이 생성되지 않는다.<br><em>cf&gt; <code>Global Symbol registry</code>란 <code>Symbol</code>값을 공유하기 위한 영역으로 다른 자바스크립트 프레임워크에서도 공유할 수 있다.</em></p><h3 id="Symbol-특징-1"><a href="#Symbol-특징-1" class="headerlink" title="Symbol 특징 1"></a>Symbol 특징 1</h3><p>위의 예제에서도 살펴봤듯이, <code>Symbol</code>은 값을 외부에 노출시키지 않는다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">"symbol description"</span>);</span><br><span class="line"><span class="built_in">console</span>.log (<span class="string">`symbol: <span class="subst">$&#123;sym&#125;</span>`</span>);</span><br><span class="line"><span class="comment">//TypeError: Cannot convert a Symbol value to string</span></span><br></pre></td></tr></table></figure></p><p>그렇기 때문에 <code>Template literal</code>에서 사용할 수 없다. 또한 <code>JSON.stringify()</code>메소드를 통해서 특정 오브젝트를 <code>stringify</code>하려고 해도 빈 객체가 리턴된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">"symbol description"</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [sym]: <span class="string">"value"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure></p><p>값을 외부에 노출시키지 않기 때문이다.</p><h3 id="Symbol-특징-2"><a href="#Symbol-특징-2" class="headerlink" title="Symbol 특징 2"></a>Symbol 특징 2</h3><p>객체에 <code>Symbol</code>로 등록된 프로퍼티를 <code>symbol-keyed property</code>라고 하는데 이 <code>symbol-keyed property</code>는 Object의 <code>getOwnPropertyNames</code> 반환 값에서 제외된다.<br><figure class="highlight javascript"><figcaption><span>user.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.for(<span class="string">"name"</span>)] : <span class="string">"jbee"</span>,</span><br><span class="line">  age : <span class="number">25</span>,</span><br><span class="line">  major: <span class="string">"Computer Science"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(user));<span class="comment">//['age', 'major']</span></span><br></pre></td></tr></table></figure></p><p>그렇기 때문에 <code>for-in statement</code>에서 열거되지 않는다.</p><figure class="highlight javascript"><figcaption><span>user.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> user) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>&gt;</span><br><span class="line">age</span><br><span class="line">major</span><br></pre></td></tr></table></figure><p>Object의 <code>symbol-keyed property</code>는 <code>getOwnPropertySymbols()</code> 메소드를 통해 확인할 수 있다.<br><figure class="highlight javascript"><figcaption><span>user.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(user)[<span class="number">0</span>].toString());<span class="comment">//Symbol(name)</span></span><br></pre></td></tr></table></figure></p><p><code>symbol-keyed property</code>로 value에 접근할 때는 <code>[]</code>를 통해 접근해야 한다. <code>.</code>을 통해 접근하면 <code>undefined</code>가 반환된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>.for(<span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  [sym] : <span class="string">"jbee"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(user.sym);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(user[sym]);<span class="comment">//jbee</span></span><br></pre></td></tr></table></figure></p><p><code>.</code>(dot)을 통해서 <code>getOwnPropertyNames</code>에서 반환되는 <strong>일반적인</strong> 프로퍼티에 접근했다면 <code>symbol-keyed property</code>에는<code>[]</code>을 통해 접근하는 것이라고 생각해볼 수 있겠다.</p><h2 id="Well-known-Symbols"><a href="#Well-known-Symbols" class="headerlink" title="Well-known Symbols"></a>Well-known Symbols</h2><p><code>built-in Symbol property</code>로 Override하여 기능을 추가 및 변경할 수 있다. 대표적인 세 가지에 대해 알아보자.(<code>iterator</code>는 다음 포스팅에서 따로 다룬다.)</p><h3 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h3><p>객체의 기본 설명(description)에 사용되는 문자열 값을 지정할 수 있으며 <code>Object.prototype.toString()</code> 메소드가 호출될 때 사용된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User(<span class="string">"jbee"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user.toString());<span class="comment">//[object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"jbee"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.toString());<span class="comment">//[object Object]</span></span><br><span class="line"></span><br><span class="line">User.prototype[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">"User"</span>;</span><br><span class="line"><span class="built_in">Object</span>.prototype[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">"Obj"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(user.toString());<span class="comment">//[object User]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.toString());<span class="comment">//[object Obj]</span></span><br></pre></td></tr></table></figure></p><p><code>new</code> 키워드를 통해 생성한 인스턴스와 <code>객체 리터럴</code>로 생성한 객체 둘 다 <code>[object Object]</code>라는 값으로 출력되기 때문에 구분하는 것이 어렵다. <code>toStringTag</code> 프로퍼티를 오버라이드하여 customize할 수 있다.</p><h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> sum = values + <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sum);<span class="comment">//1,2,3100</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sum);<span class="comment">//string</span></span><br></pre></td></tr></table></figure><p>배열이 <code>string</code>으로 casting이 되고 그 뒤에 연산되는 <code>100</code> 마저 <code>string</code>으로 casting이 된다. 그래서 결과값이 <code>string</code>타입의 <code>1,2,3100</code>이 되는 것이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//overriding</span></span><br><span class="line">values[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(hint);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> values) &#123;</span><br><span class="line">    result += item;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum2 = values + <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"sum2: "</span>, sum2);<span class="comment">//106</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sum2);<span class="comment">//number</span></span><br></pre></td></tr></table></figure></p><p>위 예제 코드에서는 <code>toPrimitive</code>라는 값을 통해서 배열의 값이 어떻게 반환될 지를 결정한다. 이 예제 코드에서는 배열의 모든 element 값을 더한 값으로 설정했다.<br><code>hint</code>라는 값을 console로 찍어보기만 하고 아직 사용하지 않았는데, 이 <code>hint</code> 값을 통해서 어떠한 형태로 반환할 지 분기를 나눌 수 있다. 다음 코드를 살펴보자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hint === <span class="string">"number"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hint === <span class="string">"string"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"문자열"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"default"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log (<span class="string">"default: "</span>, <span class="number">100</span> + obj);<span class="comment">//100default</span></span><br><span class="line"><span class="built_in">console</span>.log (<span class="string">"number: "</span>, <span class="number">1</span> * obj);<span class="comment">//number: 1</span></span><br><span class="line"><span class="built_in">console</span>.log (<span class="string">`string: <span class="subst">$&#123;obj&#125;</span>`</span>);<span class="comment">//string: 문자열</span></span><br><span class="line"><span class="built_in">console</span>.log(+obj +<span class="number">1</span>);<span class="comment">//2</span></span><br></pre></td></tr></table></figure></p><p><code>[Symbol.toPrimitive]()</code>가 호출되면 자바스크립트 엔진은 parameter인 <code>hint</code>에 <code>number</code>, <code>string</code>, <code>default</code> 셋 중 하나를 설정하게 된다. 엔진은 어떻게 <code>hint</code>값을 설정할까? 네 개의 <code>console</code>을 찍어봤다.</p><ol><li><code>100 + obj</code>에서는 <code>obj</code>가 피연산자(연산 대상)이므로 <code>default</code>가 설정된다.</li><li><code>1 * obj</code>에서는 <code>*</code>연산 때문에 <code>number</code>가 설정된다. (곱셈 말고도 뺄셈, 나눗셈도 <code>number</code>가 설정된다.)</li><li><code>${obj}</code>에서는 <code>Template literal</code>로 사용되었으므로 <code>string</code>이 설정된다.</li><li><code>+obj +1</code>에서는 <code>+</code>라는 단항 연산자가 <code>obj</code>앞에 붙어서 <code>number</code>가 설정된다.</li></ol><h3 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h3><p><code>Array</code> 오브젝트의 <code>concat()</code>이라는 함수를 호출할 때의 상황을 지정하는 프로퍼티다. 두 배열을 결합할 때, 배열의 <code>펼침 여부</code>를 지정할 수 있다. <code>default value</code>는 <code>true</code>이다. 다음 예제 코드를 살펴보자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> prev = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> post = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(prev.concat(post));<span class="comment">//[1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">prev[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(prev.concat(post));<span class="comment">//[[1, 2], 3, 4]</span></span><br><span class="line">post[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(prev.concat(post));<span class="comment">//[[1, 2], [3, 4]]</span></span><br></pre></td></tr></table></figure></p><p>배열을 결합할 때, 펼치지 않고(프로퍼티 값을 <code>false</code>로 지정하고) 결합을 하게 되면, 배열의 구조를 그대로 유지하면서 합쳐진다. <code>Array-like</code> 오브젝트에서도 <code>concat()</code> 함수의 결과 형태를 지정할 수 있다.</p><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>이 이외에도 <code>@@iterator</code>, <code>@@hasInstance</code>, <code>@@replace</code>, <code>@@species</code> 등 다양한 <code>Well-known Symbol</code>들이 존재한다. 이 <code>Well-known Symbol</code>들은 이미 ES5 스펙에서부터 존재했었고 자연스럽게 그것들을 사용해왔던 것이고 ES6에서 각 프로퍼티들을 오버라이드하여 좀 더 유연한 코드를 작성할 수 있게 끔 공개된 것이다.<br><em>cf&gt; <code>@@</code>은 <code>Symbol</code> 대신 사용할 수 있는 약자이다.</em></p><p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="noopener">Github Respository</a>에서 확인하실 수 있습니다.</p><h4 id="Symbol과-관련된-다른-글들"><a href="#Symbol과-관련된-다른-글들" class="headerlink" title="Symbol과 관련된 다른 글들"></a>Symbol과 관련된 다른 글들</h4><ul><li><a href="https://perfectacle.github.io/2017/04/16/ES6-Symbol/index.html" target="_blank" rel="noopener">(ES6) Symbol - 양권성님 블로그 글</a></li></ul><p><em>8. end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javascript_es6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES6-8-Symbol&quot;&gt;&lt;a href=&quot;#ES6-8-Symbol&quot; class=&quot;headerlink&quot; title=&quot;[ES6] 8. Symbol
      
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="es6" scheme="https://jaeyeophan.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>[ES6] 7. Template literal</title>
    <link href="https://jaeyeophan.github.io/2017/04/19/ES6-7-Template-literal/"/>
    <id>https://jaeyeophan.github.io/2017/04/19/ES6-7-Template-literal/</id>
    <published>2017-04-19T07:26:04.000Z</published>
    <updated>2017-04-19T07:30:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript_es6.png" alt=""></p><h1 id="ES6-7-Template-literal"><a href="#ES6-7-Template-literal" class="headerlink" title="[ES6] 7. Template literal"></a>[ES6] 7. Template literal</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`template literal`</span>);</span><br></pre></td></tr></table></figure><p>ES6에서 문자열 처리를 보다 간편하게 할 수 있는 <code>템플릿</code>을 제공한다. 문자열 처리를 위해 single quote나 double quote가 아닌 <strong>Backtick</strong>을 사용한다. 변수를 <code>${ }</code>로 감싸서 inline으로 표현할 수 있으며 \n을 작성할 필요없이 Backtick 안에서 개행을 해주면 된다. 기존의 템플릿 엔진들에서 제공하고 있었던 기능인 <code>${ }</code> 안에는 <code>변수</code> 또는 <code>연산식</code> 등의 <code>표현식</code>이 들어갈 수 있다.<br><em>Example code&gt;</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"jbee"</span>;</span><br><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hi, "</span> + name + <span class="string">"!\nHave a nice day!"</span>);</span><br><span class="line"><span class="comment">// console&gt;</span></span><br><span class="line"><span class="comment">// Hi, jbee!</span></span><br><span class="line"><span class="comment">// Have a nice day!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="keyword">let</span> grettingTemplate = <span class="string">`</span></span><br><span class="line"><span class="string">Hi, <span class="subst">$&#123;name&#125;</span>!</span></span><br><span class="line"><span class="string">Have a nice day!</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(grettingTemplate);</span><br><span class="line"><span class="comment">//console&gt;</span></span><br><span class="line"><span class="comment">// Hi, jbee!</span></span><br><span class="line"><span class="comment">// Have a nice day!</span></span><br></pre></td></tr></table></figure></p><p>Template literal을 사용하여 거추장스러운 <code>&#39;+&#39;</code>이나 <code>&#39;\n&#39;</code>을 더이상 사용하지 않아도 된다.</p><h2 id="tagged-template"><a href="#tagged-template" class="headerlink" title="tagged template"></a>tagged template</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"jbee"</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">27</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`hi, <span class="subst">$&#123;name&#125;</span>! Have a nice day! <span class="subst">$&#123;num&#125;</span> is your number`</span>);</span><br><span class="line"><span class="comment">//console&gt; hi, jbee! Have a nice day! 27 is your number</span></span><br></pre></td></tr></table></figure><p>위 템플릿 리터럴을 <code>tagged template</code>을 사용하여 <code>text</code>와 <code>value</code>로 분리할 수 있다. <code>text</code>는 공백 문자를 기준으로 <code>배열</code>의 형태로 파라미터가 들어오며, ${ } 안의 표현식은 <code>value</code>라는 파라미터로 <code>String</code> type으로 들어온다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">text, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> value);</span><br><span class="line">&#125;</span><br><span class="line">greet <span class="string">`hi, <span class="subst">$&#123;name&#125;</span>! Have a nice day! <span class="subst">$&#123;num&#125;</span> is your number`</span>;</span><br><span class="line"><span class="comment">//console&gt; [ 'hi, ', '! Have a nice day! ', ' is your number' ]</span></span><br><span class="line"><span class="comment">//console&gt; jbee</span></span><br><span class="line"><span class="comment">//console&gt; string</span></span><br></pre></td></tr></table></figure></p><p>parameter로 넘겨지는 <code>value</code>는 하나인데, 템플릿 리터럴에는 표현식이 두개가 존재한다. 그렇기 때문에 number에 해당하는 값이 함수로 넘겨지지 못했다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">text, value, value2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="built_in">console</span>.log(value2);</span><br><span class="line">&#125;</span><br><span class="line">greet <span class="string">`hi, <span class="subst">$&#123;name&#125;</span>! Have a nice day! <span class="subst">$&#123;num&#125;</span> is your number`</span>;</span><br><span class="line"><span class="comment">//console&gt; [ 'hi, ', '! Have a nice day! ', ' is your number' ]</span></span><br><span class="line"><span class="comment">//console&gt; jbee</span></span><br><span class="line"><span class="comment">//console&gt; 27</span></span><br></pre></td></tr></table></figure></p><p>이렇게 해결할 수 있지만, 지난 chapter에서 다룬 <code>Rest parameter</code>를 사용할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">text, ...value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line">greet <span class="string">`hi, <span class="subst">$&#123;name&#125;</span>! Have a nice day! <span class="subst">$&#123;num&#125;</span> is your number`</span>;</span><br><span class="line"><span class="comment">//console&gt; [ 'hi, ', '! Have a nice day! ', ' is your number' ]</span></span><br><span class="line"><span class="comment">//console&gt; [ 'jbee', 27 ]</span></span><br></pre></td></tr></table></figure></p><h3 id="템플릿-리터컬의-표현식-값-결정"><a href="#템플릿-리터컬의-표현식-값-결정" class="headerlink" title="템플릿 리터컬의 표현식 값 결정"></a>템플릿 리터컬의 표현식 값 결정</h3><p>템플릿 리터럴을 사용하여 문자열을 함수의 파라미터를 넘길 수 있을 것이다. 그렇다면 템플릿 러터럴 내부의 표현식의 값은 언제 결정될까?<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Assign expression statement</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">`ecmascript`</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">`jbee`</span>;</span><br><span class="line">greeting(<span class="string">`Hi, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line"><span class="comment">//console&gt; Hi, jbee</span></span><br></pre></td></tr></table></figure></p><p>함수의 파라미터로 <strong>넘겨질 때부터</strong> 결정되어 넘어가기 때문에 <code>greeting</code>이라는 함수 내부에 있는 local variable인 <code>ecmascript</code>라는 단어가 <code>name</code>으로 들어가지 않고 <code>jbee</code>라는 문자열이 <code>name</code>의 값으로 결정되었다.</p><p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="noopener">Github Respository</a>에서 확인하실 수 있습니다.</p><p><em>7. end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javascript_es6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES6-7-Template-literal&quot;&gt;&lt;a href=&quot;#ES6-7-Template-literal&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="es6" scheme="https://jaeyeophan.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>[TS] 0. Quick Start</title>
    <link href="https://jaeyeophan.github.io/2017/04/19/TS-0-Quick-Start/"/>
    <id>https://jaeyeophan.github.io/2017/04/19/TS-0-Quick-Start/</id>
    <published>2017-04-19T04:49:15.000Z</published>
    <updated>2017-04-19T07:30:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/typescript.png" alt=""></p><h1 id="TS-0-Quick-Start"><a href="#TS-0-Quick-Start" class="headerlink" title="[TS] 0. Quick Start"></a>[TS] 0. Quick Start</h1><p>이 포스팅은 TypeScript Official Document를 번역 및 의역한 자료입니다. 직접 타이핑 해본 결과 5분정도 소요되는 짧은 Quick start 입니다:) 가볍게 봐주세요.</p><h2 id="Install-TypeScript"><a href="#Install-TypeScript" class="headerlink" title="Install TypeScript"></a>Install TypeScript</h2><p>npm을 통해서 간단하게 TypeScript를 설치할 수 있습니다. VSCode 등 타입스크립트를 지원하는 에디터에서는 플러그인을 통해서 설치가 가능합니다.</p><p>via npm<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g typescript</span><br></pre></td></tr></table></figure></p><p>command를 이용하여 또는 Editor를 열어 <code>greeter.ts</code>라는 파일을 만듭니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch greeter.ts</span><br></pre></td></tr></table></figure></p><p><code>greeter.ts</code>코드는 다음과 같습니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="string">"Jane User"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = greeter(user);</span><br></pre></td></tr></table></figure></p><p>TypeScript는 <code>.ts</code>라는 확장자를 사용합니다. 이 파일은 컴파일되어 <code>greeter.js</code>파일이 됩니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc greeter.ts</span><br></pre></td></tr></table></figure></p><p><code>tsc</code>라는 명령어를 통해서 TypeScript로 작성된 파일을 컴파일할 수 있습니다.<br>현재 <code>greeter.ts</code>에 작성되어있는 코드는 기존의 JavaScript와 다를 바가 없습니다. 이 JavaScript code인 <code>greeter.ts</code>에 TypeScript 문법을 하나씩 추가해보겠습니다.</p><h2 id="TypeScript가-제공하는-대표적인-기능"><a href="#TypeScript가-제공하는-대표적인-기능" class="headerlink" title="TypeScript가 제공하는 대표적인 기능"></a>TypeScript가 제공하는 대표적인 기능</h2><h3 id="Type-annotations"><a href="#Type-annotations" class="headerlink" title="Type annotations"></a>Type annotations</h3><p>동적으로 변수의 타입을 결정했던 JavaScript에게 타입이 생겼습니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>TypeScript</strong>는 Type을 제공합니다. Type annotations는 함수가 받는 parameter에 타입을 지정해주어, 함수 내부에서 별도의 타입 체크 없이 parameter를 사용할 수 있게 해줍니다. 즉, <code>person</code>에 다른 타입의 parameter가 주어지면 error가 발생하게 됩니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = greeter(user);</span><br></pre></td></tr></table></figure></p><p>error:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">greeter.ts(7,26): Supplied parameters do not match any signature of call target</span><br></pre></td></tr></table></figure></p><p>타입스크립트는 코드의 구조와 작성된 <code>type annotation</code>으로 정적 분석을 제공합니다. 위와 같이 error가 발생하더라도 타입스크립트 파일은 컴파일되어 <code>.js</code>파일을 만들게 됩니다. TypeScript의 역할은 제대로 동작하지 않을 것 같은 코드에 대해 개발자에게 <code>warning</code>해주는 역할이라고 생각해도 될 것 같습니다 :)</p><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>Java개발자라면 익숙한 <code>interface</code> 문법입니다. 위에서 사용했던 예제를 <code>interface</code>를 사용하여 확장해보겠습니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    firstName: <span class="built_in">string</span>;</span><br><span class="line">    lastName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: Person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + person.firstName + <span class="string">" "</span> + person.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = &#123; firstName: <span class="string">"Jane"</span>, lastName: <span class="string">"User"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = greeter(user);</span><br></pre></td></tr></table></figure></p><p>함수의 parameter에 <code>String</code>이라는 타입 대신 인터페이스(interface)를 적용했습니다. Java의 Generic과 비슷하게 보이는데요, interface를 사용하여 함수가 넘겨받는 parameter의 타입을 보다 구체적으로 정의할 수 있게 되었습니다. 위의 예제 코드와 마찬가지로 정의된 type과 맞지 않은 type의 parameter가 전달되면 error를 출력합니다.</p><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>ES6(ECMAScript2015)에서부터 추가된 <code>Class</code> 문법입니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Student &#123;</span><br><span class="line">    fullName: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> firstName, <span class="keyword">public</span> middleInitial, <span class="keyword">public</span> lastName</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fullName = firstName + <span class="string">" "</span> + middleInitial + <span class="string">" "</span> + lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> Student(<span class="string">"Jane"</span>, <span class="string">"M."</span>, <span class="string">"User"</span>);</span><br></pre></td></tr></table></figure></p><p>ES6의 <code>Class</code>와는 약간 다른 모습을 보입니다. 바로 Class 내부에서 <code>field member</code>를 갖게 된 것입니다. 하지만 그 근본은 ES6의 <code>Class</code>와 같습니다. JavaScript에서 프로토타입을 통해 구현했던 OOP를 보다 간결한 방법으로 문법을 제공하는 것입니다.</p><p>공식 문서에서 제공하는 Quick Start를 통해서 TypeScript 맛보기를 해봤습니다. 감사합니다.</p><p><em>0. Quick start end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/typescript.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;TS-0-Quick-Start&quot;&gt;&lt;a href=&quot;#TS-0-Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;[TS] 0. Qui
      
    
    </summary>
    
      <category term="TypeScript" scheme="https://jaeyeophan.github.io/categories/TypeScript/"/>
    
    
      <category term="ts" scheme="https://jaeyeophan.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 근황</title>
    <link href="https://jaeyeophan.github.io/2017/04/19/TypeScript-Recent/"/>
    <id>https://jaeyeophan.github.io/2017/04/19/TypeScript-Recent/</id>
    <published>2017-04-19T04:39:38.000Z</published>
    <updated>2017-04-28T06:16:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/typescript.png" alt=""></p><h1 id="TypeScript-근황"><a href="#TypeScript-근황" class="headerlink" title="TypeScript 근황"></a>TypeScript 근황</h1><p>얼마 전, 구글의 발표에 타입스크립트에 관심을 갖게 되었습니다. 기술적인 내용보다는 여러 기술 소식이 담긴 포스팅입니다.<br>이 포스팅은 17년 4월 중순 경에 작성되었으며 작성되는 시점의 TypeScript version은 <code>2.2 version</code>입니다.<br>(4월 28일, 2.3 version이 release되었습니다.)</p><h2 id="JavaScript의-미래"><a href="#JavaScript의-미래" class="headerlink" title="JavaScript의 미래"></a>JavaScript의 미래</h2><p>올해가 벌써 2017년이니, 재작년인 2015년에 <code>ECMAScript2015(aka ECMAScript6 or ES6)</code>가 JavaScript 표준으로 정의되었고, 작년에는 <code>ECMAScript2016(aka ECMAScript7 or ES7)</code>이 발표되었습니다. 머지않아 <code>ECMAScript2017</code>도 발표될 예정(6월 예정)이라고 합니다. <code>Node.js</code>의 등장으로 JavaScript가 소프트웨어 개발 환경에서 막대한 비중을 차지하자 현재 <a href="https://github.com/tc39/tc39-notes" target="_blank" rel="noopener">tc39</a>라는 커뮤니티에서 끊임없이 JavaScript라는 언어의 표준을 명세하고 있습니다. 이것은 무엇을 의미할까요?</p><p>TypeScript에 대한 이야기를 하기 위해 JavaScript에 관한 내용은 다음 글을 참조하시면 좋을 것 같아 링크를 첨부합니다. <a href="http://d2.naver.com/helloworld/2809766" target="_blank" rel="noopener">2017년과 이후 JavaScript의 동향 - JavaScript(ECMAScript)</a></p><h2 id="TypeScript의-정체"><a href="#TypeScript의-정체" class="headerlink" title="TypeScript의 정체"></a>TypeScript의 정체</h2><blockquote><p>TypeScript란 JavaScript의 <code>super set</code>이다.</p></blockquote><p>어디선가 이런 말을 많이 들어봤을것 같은데요.<br><img src="/images/typescript_javascript.png" alt=""><br>사실, TypeScript는 JavaScript입니다. 기존의 JavaScript와는 다르게 <code>.ts</code>라는 확장자를 갖고 있지만 결국 JavaScript로 compile되는 언어입니다. JavaScript의 성장과 동시에 언어 자체의 한계점을 인지한 MicroSoft는 JavaScript에 <code>타입(Type)</code>을 추가해서 TypeScript를 만듭니다.(TypeScript의 Type system을 <a href="https://en.wikipedia.org/wiki/Structural_type_system" target="_blank" rel="noopener">Structural Type System</a>이라고 합니다.) 그리고 2016년 9월에 TypeScript 2.0 버전이 공개되었습니다.(현재는 <a href="http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html" target="_blank" rel="noopener">2.2 version</a> 이네요!)</p><p>이와 같은 움직임은 Google에서 개발한 <code>Dart</code>에서도 찾아볼 수 있습니다. 하지만 얼마 전, 프론트엔드 개발자들의 눈길을 끌만한 소식이 들려왔습니다.</p><blockquote><p><a href="http://www.zdnet.co.kr/news/news_view.asp?artice_id=20170413085316&amp;lo=z45" target="_blank" rel="noopener">MS 타입스크립트, 구글 사내 표준 언어되다.</a></p></blockquote><p>Google이 만든 프론트엔드 프레임워크 Angular2(얼마 전, <a href="http://angularjs.blogspot.kr/2017/03/angular-400-now-available.html" target="_blank" rel="noopener">Angular4.0</a>이 release되었습니다.)도 Dart, JavaScript를 지원하지만 TypeScript를 공식 언어로 지정할만큼 TypeScript의 위상이 높아졌다는 것을 확인하실 수 있습니다.</p><p>이에 더해, 다들 아실만한 협업 툴인 Slack이 TypeScript로 전환했습니다. 다음 링크는 Slack이 코드베이스를 TypeScript로 전환하는 과정에 대한 글로, 정적 분석의 필요성에 대해 인지했다는 내용입니다. <a href="https://slack.engineering/typescript-at-slack-a81307fa288d" target="_blank" rel="noopener">TypeScript at Slack</a></p><p>Facebook에서 개발한 정적 타입 분석기(static typechecker of javascript) <code>Flow</code>도 마찬가지 행보가 아닐까 생각합니다. 애플리케이션의 규모가 커질 수록 안정성에 대한 수요는 높아지기 마련입니다. 동적 타입이라는 JavaScript가 갖고 있는 장점이자 한계점인 이 부분을 해결하기 위해 정적 분석의 중요도가 높아지고 있습니다.</p><h2 id="TypeScript의-현주소"><a href="#TypeScript의-현주소" class="headerlink" title="TypeScript의 현주소"></a>TypeScript의 현주소</h2><p>이젠 개발자들에게 없어서는 안 될 존재인 <code>Github</code>의 <a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="noopener">star</a>를 보니 <code>21,076개</code>입니다! (star개수가 64,556개인 React에 비하면 한참 멀었네요!) 올라온 Issue는 2,351개고 진행중인 Pull Request는 82개가 되네요.<br><img src="/images/github_typescript.png" alt=""><br>다음 자료는 Github과 마찬가지로 개발자들에게 없어선 안 되는 <a href="http://stackoverflow.com/insights/survey/2017/#most-loved-dreaded-and-wanted" target="_blank" rel="noopener">Stackoverflow의 조사 자료</a>입니다. 개발자들이 가장 사랑하는 언어로 Rust, Smalltalk에 이어 TypeScript가 3위를 당당히 차지했습니다.(오, 이 정도인가요?)<br><img src="/images/stackoverflow_survey.png" alt=""></p><p>추가된 Type System을 바탕으로 여러 가지 Tool과 구문 완성(content assist) 등의 도움을 받을 수 있는 TypeScript 소개였습니다. 얼마 전 공개된 <a href="https://github.com/Microsoft/reactxp" target="_blank" rel="noopener">ReactXP</a>를 만든 Microsoft의 지지로 React에서도 TypeScript 방향으로 가지 않을까 생각해봅니다.(Flow 의문의 1패?) 무엇을 공부해야 하나 걱정할 필요없는 프론트엔드 개발자분들을 응원합니다. 감사합니다 :)</p><p><em>cf. 짤막하게 정리해본 <a href="https://jaeyeophan.github.io/2017/04/19/TS-0-Quick-Start/">TypeScript Quick Start</a>입니다.</em></p><h3 id="TypeScript와-관련된-글과-그룹"><a href="#TypeScript와-관련된-글과-그룹" class="headerlink" title="TypeScript와 관련된 글과 그룹"></a>TypeScript와 관련된 글과 그룹</h3><ul><li><a href="https://github.com/Microsoft/TypeScript-Handbook" target="_blank" rel="noopener">Microsoft/TypeScript-Handbook</a></li><li><a href="https://www.facebook.com/groups/TSKorea/?hc_ref=SEARCH" target="_blank" rel="noopener">TypeScript Korea 페이스북 그룹</a></li><li><a href="http://han41858.tistory.com/14" target="_blank" rel="noopener">TypeScript를 무서워하지 않아도 되는 이유(번역)</a></li><li><a href="https://hyunseob.github.io/2016/09/25/typescript-introduction/index.html" target="_blank" rel="noopener">TypeScript 소개(hyunseob님 블로그)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/typescript.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;TypeScript-근황&quot;&gt;&lt;a href=&quot;#TypeScript-근황&quot; class=&quot;headerlink&quot; title=&quot;TypeScript 근황&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="TypeScript" scheme="https://jaeyeophan.github.io/categories/TypeScript/"/>
    
    
      <category term="ts" scheme="https://jaeyeophan.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>[ES6] 6. Class sugar syntax</title>
    <link href="https://jaeyeophan.github.io/2017/04/18/ES6-6-Class-sugar-syntax/"/>
    <id>https://jaeyeophan.github.io/2017/04/18/ES6-6-Class-sugar-syntax/</id>
    <published>2017-04-18T12:11:41.000Z</published>
    <updated>2017-11-29T09:34:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript_es6.png" alt=""></p><h1 id="ES6-6-Class-sugar-syntax"><a href="#ES6-6-Class-sugar-syntax" class="headerlink" title="[ES6] 6. Class sugar syntax"></a>[ES6] 6. Class sugar syntax</h1><p>ES6에서 자바스크립트에는 존재하지 않았던 클래스(Class)가 도입되었다. 자바스크립트에 대해 잘 모르는 사람들이 Java에서의 클래스와 <strong>똑같은</strong> 기능을 하는 녀석인 줄 알고 많이 혼동한다. 자바스크립트는 기본적으로 프로토타입 기반의 언어이기 때문에 새로 도입된 이 클래스도 프로토타입 기반이다. 객체 지향을 <strong>흉내</strong>내고 있지만, 그 내부는 여전히 프로토타입으로 구성되어 있는 것이다. 프로토타입 기반으로 객체 지향적으로 설계하는 것이 복잡하여 클래스라는 <code>sugar syntax</code> 문법이 도입된 것이다. 그렇기 때문에 이에 따른 제약사항이 많다. 편한 만큼 고려해야할 사항도 많은 것이다. 하나씩 살펴보자.</p><h3 id="클래스는-선언문-또는-표현식으로-선언할-수-있다"><a href="#클래스는-선언문-또는-표현식으로-선언할-수-있다" class="headerlink" title="클래스는 선언문 또는 표현식으로 선언할 수 있다."></a>클래스는 선언문 또는 표현식으로 선언할 수 있다.</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//클래스 선언문으로 클래스 선언</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">name</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//클래스 표현식으로 클래스 선언</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = <span class="class"><span class="keyword">class</span> <span class="title">inner_name</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name); <span class="comment">//function</span></span><br></pre></td></tr></table></figure><p>자바스크립트 엔진은 <code>class</code> 키워드를 만나면 <code>Class 오브젝트</code>를 생성한다. <code>Class 오브젝트</code>도 마찬가지로 <code>String</code>, <code>Function</code>과 같은 하나의 오브젝트 타입이다.<br><em>cf&gt; 표현식으로 선언했을 때의 inner-name은 클래스 내부에서 자신을 호출할 때 사용한다.</em></p><h2 id="Class-keyword-특징"><a href="#Class-keyword-특징" class="headerlink" title="Class keyword 특징"></a>Class keyword 특징</h2><ol start="0"><li>클래스의 선언부는 <code>let</code>과 <code>const</code>와 마찬가지로 호이스팅은 되지만 <code>temporary dead zone</code>이 형성된다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Not hoisting</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Error:Use before declaration</span></span><br></pre></td></tr></table></figure></li></ol><p>클래스를 선언한 다음, <code>new</code> 키워드를 통해 인스턴스를 생성할 수 있다.</p><ol><li>클래스의 코드는 ‘use strict’를 선언하지 않아도 strict 모드에서 실행된다.</li><li>메서드를 작성할 때, function 키워드와 콜론( : )을 작성하지 않는다.</li><li>메서드 사이에 콤마(,)를 작성하지 않는다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class method</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"name"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    getScore() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"score"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> student = <span class="keyword">new</span> Student();</span><br><span class="line">student.getName(); <span class="comment">//name</span></span><br><span class="line">student.getScore(); <span class="comment">//score</span></span><br></pre></td></tr></table></figure></li></ol><p>바로 함수를 정의하고, 콤마(,)가 없다.</p><ol start="4"><li>생성자 함수를 통해 인스턴스를 생성하면 window에 설정되지만 class 키워드를 통해 생성하면 window에 설정되지 않는다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//window object?</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.Foo); <span class="comment">// function Foo() &#123;...&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.Student); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Sugar-Syntax"><a href="#Sugar-Syntax" class="headerlink" title="Sugar Syntax"></a>Sugar Syntax</h3><p><code>Class</code> keyword는 <code>sugar syntax</code>라고 했다. 자바스크립트는 기본적으로 <code>prototype</code> 기반의 언어이기 때문에 엔진이 <code>prototype</code>에 메서드들을 연결한다. 즉, 클래스에서 메서드를 추가하면 자동으로 <code>prototype</code>에 추가되는 것이다. 자바스크립트에서는 프로토타입을 사용해서 클래스 밖에서도 메서드를 추가할 수 있다. 이미 생성된 인스턴스에 메서드를 추가하게 되면, 이전에 생성되었던 인스턴스들이 새로 추가된 메서드들을 공유해야하기 때문에 부하가 걸리지만 코드가 유연해진다는 장점도 존재한다. 위 예제코드에서 생성한 <code>Student</code> 클래스의 프로토타입에 새로운 메서드를 추가하고 이전에 생성되었던 인스턴스에서 새롭게 추가한 메서드를 호출할 수 있는 것이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add method to prototype</span></span><br><span class="line">Student.prototype.newMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Add new Method"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student.newMethod(); <span class="comment">//Add new Method</span></span><br></pre></td></tr></table></figure></p><p><code>new</code> 연산자는 <code>constructor</code>를 호출하면서 받은 인자들을 <code>constructor</code>의 파라미터로 전달한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new keyword</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, score) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Student(<span class="string">"Jbee"</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s.name); <span class="comment">//Jbee</span></span><br><span class="line"><span class="built_in">console</span>.log(s.score); <span class="comment">//100</span></span><br><span class="line"><span class="built_in">console</span>.log(s.getName()); <span class="comment">//Jbee</span></span><br></pre></td></tr></table></figure></p><p>위 예제 코드에서 볼 수 있듯이 <code>class</code> 키워드로 선언한 클래스에 대해서 <code>new</code> keyword를 통해 인스턴스를 생성할 수 있다. 이 때 클래스 내부에 별도의 <code>constructor</code>가 설정되어 있지 않으면 기존의 <code>protytype</code>의 constructor가 호출되고 이를 <code>default constructor</code>라고 부른다. 별도로 작성된 <code>constructor</code>는 <code>Student.prototype.constructor</code>로 호출된다. </p><p><strong>new 키워드가 실행되는 메커니즘은 다음과 같다.</strong></p><pre><code>1. constructor는 우선적으로 빈(empty) 오브젝트(인스턴스)를 생성한다.2. 넘겨받은 파라미터를 생성한 빈 오브젝트의 프로퍼티에 설정한다.3. 인스턴스를 먼저 생성하므로, constructor 내부에서는 this keyword를 통해 인스턴스 자신을 가리킬 수 있다.4. constructor에 별도의 return이 설정되어 있지 않으면 new를 실행한 곳으로 해당 클래스의 인스턴스를 반환한다.</code></pre><p><em>cf) constructor는 별도의 return을 설정할 수 있다. 하지만 Number, String 값이 return value로 지정되어 있으면 이를 무시하고 인스턴스 자신을 return 한다.</em></p><h3 id="extends-keyword"><a href="#extends-keyword" class="headerlink" title="extends keyword"></a>extends keyword</h3><p>자바스크립트에서도 <code>extends</code>라는 키워드를 통해 클래스 간의 상속이 가능해졌다. 상속받은 클래스(이하 슈퍼클래스)의 메소드를 사용할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line">bar.getName(); <span class="comment">//Foo</span></span><br></pre></td></tr></table></figure></p><p>슈퍼 클래스의 메소드를 오버라이딩(Overriding)할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line">bar.getName(); <span class="comment">//Bar</span></span><br></pre></td></tr></table></figure></p><p><code>super</code> 키워드를 통해 슈퍼 클래스의 메소드에 접근할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Foo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="string">" Bar"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line">bar.getName(); <span class="comment">//Foo Bar</span></span><br></pre></td></tr></table></figure></p><h3 id="constructor-keyword"><a href="#constructor-keyword" class="headerlink" title="constructor keyword"></a>constructor keyword</h3><p>서브 클래스에서 정의된 <code>constructor</code>가 없다면 슈퍼 클래스의 <code>constructor</code>가 호출된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Foo constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="comment">//console&gt; Foo constructor</span></span><br></pre></td></tr></table></figure></p><p>서브 클래스에서 <code>constructor</code>를 정의하려면 <strong>반드시</strong> constructor 내부에서 <code>super()</code>를 <strong>호출</strong>해야 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="comment">//ReferenceError: this is not defined</span></span><br></pre></td></tr></table></figure></p><p><code>constructor()</code>메소드 안에서 <code>super()</code>를 호출해주면, 슈퍼 클래스가 생성되고 서브 클래스가 생성된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Foo constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Bar constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="comment">//console&gt; Foo constructor</span></span><br><span class="line"><span class="comment">//console&gt; Bar constructor</span></span><br></pre></td></tr></table></figure></p><h3 id="static-keyword"><a href="#static-keyword" class="headerlink" title="static keyword"></a>static keyword</h3><p>자바스크립트 클래스에서 <code>static</code> 키워드를 사용하면 정적 메소드를 정의할 수 있다. 정적 메소드라 함은 인스턴스를 생성하지 않고 사용할 수 있는 메소드를 말한다. 정적 메소드는 인스턴스를 생성하지 않고도 호출할 수 있지만 인스턴스에서는 호출할 수 없다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> getName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.getName(); <span class="comment">//Foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.getName();<span class="comment">//not a function</span></span><br></pre></td></tr></table></figure></p><p>정적 메소드는 <code>prototype</code>에 추가되지 않는다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> getName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getAlias() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype.getName === Foo.getName);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype.getAlias === <span class="keyword">new</span> Foo().getAlias);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>클래스 내부에서 <code>정적 변수(static variable)</code>를 지정할 수는 없지만 클래스 밖에서 지정할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.name = <span class="string">"foo"</span>;</span><br></pre></td></tr></table></figure></p><h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p><code>new.target</code>을 이용하면 슈퍼 클래스에서 서브 클래스의 static method에 접근할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target);<span class="comment">//[Function: Bar]</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span>.target);<span class="comment">//function</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Foo: "</span>, <span class="keyword">new</span>.target.getName());<span class="comment">//Foo: bar</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"bar"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br></pre></td></tr></table></figure></p><p>ES6에서 추가된 sugar syntax class에 대해 정리해봤다. TypeScript에서는 보다 더 객체지향적인 클래스로서 사용할 수 있다. 아직 불완전한 ES6의 클래스는 신경써야할 부분도 많지만 제대로 이해하면 <code>prototype</code>을 사용하는 것보다 효율적으로 자바스크립트 코드를 작성할 수 있을 것이다.</p><p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="noopener">Github Respository</a>에서 확인하실 수 있습니다.</p><p><em>6. end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javascript_es6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES6-6-Class-sugar-syntax&quot;&gt;&lt;a href=&quot;#ES6-6-Class-sugar-syntax&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="es6" scheme="https://jaeyeophan.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>[ES6] 5. Destructuring and Default Parameter</title>
    <link href="https://jaeyeophan.github.io/2017/04/18/ES6-5-Destructuring-and-Default-Parameter/"/>
    <id>https://jaeyeophan.github.io/2017/04/18/ES6-5-Destructuring-and-Default-Parameter/</id>
    <published>2017-04-18T11:59:34.000Z</published>
    <updated>2018-05-01T05:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript_es6.png" alt=""></p><h1 id="ES6-5-Destructuring-and-Default-Parameter"><a href="#ES6-5-Destructuring-and-Default-Parameter" class="headerlink" title="[ES6] 5. Destructuring and Default Parameter"></a>[ES6] 5. Destructuring and Default Parameter</h1><h2 id="Destructuring"><a href="#Destructuring" class="headerlink" title="Destructuring"></a>Destructuring</h2><p><code>shorthand</code> 방식을 이용하여 함수의 반환값을 <strong>바로 객체에 할당</strong>할 수 있다. 이 때 함수에서 반환되는 <strong>프로퍼티 값</strong>과 <strong>지역 변수</strong>의 이름이 같아야 가능하다. 이렇게 하면 함수의 반환 값을 <strong>임시 객체에 저장</strong>하고 그 객체의 프로퍼티를 통해 접근하여 지역 변수에 할당하는 과정을 축소할 수 있다. 굳이 전체를 객체에 할당하지 않고 부분적으로만 할당도 가능하다. 즉, 리턴되는 값이 객체일 경우, 그 객체를 분해하여 바로 지역변수로 접근이 가능하다는 것이다. (iterable protocol을 구현해야만 destructuring이 가능하다.)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUser</span>(<span class="params">first, last</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fullName = first + <span class="string">" "</span> + last;</span><br><span class="line">    <span class="keyword">return</span> &#123;first, last, fullName&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; first, last, fullName &#125; = buildUser(<span class="string">"Sam"</span>, <span class="string">"Williams"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// Sam</span></span><br><span class="line"><span class="built_in">console</span>.log(last); <span class="comment">// Williams</span></span><br><span class="line"><span class="built_in">console</span>.log(fullName); <span class="comment">// Sam Williams</span></span><br></pre></td></tr></table></figure></p><p>굳이 전체를 객체에 할당하지 않고 부분적으로만 할당도 가능하다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; fullName &#125; = buildUser(<span class="string">"Sam"</span>, <span class="string">"Williams"</span>);</span><br><span class="line"><span class="built_in">console</span>.log( fullName ); <span class="comment">// Sam Williams</span></span><br></pre></td></tr></table></figure></p><h3 id="Method-Initializer-Shorthand"><a href="#Method-Initializer-Shorthand" class="headerlink" title="Method Initializer Shorthand"></a>Method Initializer Shorthand</h3><p>객체에 함수를 추가할 때, 객체의 프로퍼티에 익명 함수를 추가하는 방식을 사용했다. ES6에서는 메소드를 활용한다. 비교를 위해 ES5도 함께 제시한다.<br><em>ES5code&gt;&gt;</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUser</span>(<span class="params">first, last, postCount</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        isActive : <span class="function"><span class="keyword">function</span>(<span class="params"> </span>) </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>ES6code&gt;&gt;</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUser</span>(<span class="params">first, last, postCount</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        isActive( ) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Destructuring-Assignment"><a href="#Destructuring-Assignment" class="headerlink" title="Destructuring Assignment"></a>Destructuring Assignment</h3><p>오른쪽의 배열을 분할하여 왼쪽 변수에 값을 <code>할당</code>한다. 인덱스 번째의 엘리먼트 값을 인덱스 번째의 변수에 할당하는 것이다. 엘리먼트가 아직 남았는데 할당할 변수가 없다면 그대로 할당되지 않고, 엘리먼트가 남지 않았는데 할당한 변수가 있다면 그 변수는 <code>undefined</code>로 할당된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> one, two, three, four;</span><br><span class="line"><span class="comment">//case1</span></span><br><span class="line">[one, two] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(one); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(two); <span class="comment">//2</span></span><br><span class="line"><span class="comment">//case2</span></span><br><span class="line">[one, two, three] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(one); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(two); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(three);<span class="comment">//undefined</span></span><br><span class="line"><span class="comment">//case3</span></span><br><span class="line">[one, two] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(one); two<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(two); <span class="comment">//2</span></span><br></pre></td></tr></table></figure></p><p>이전 Chapter에서 다뤘던 <code>Spread</code> 연산자를 사용할 수 있으며, 공백으로 두어 해당 값을 건너 뛰고 <code>할당</code>할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[one, ...other] = [<span class="number">1</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>];</span><br><span class="line"><span class="built_in">console</span>.log(one); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(other); <span class="comment">//[23, 24, 25]</span></span><br><span class="line"></span><br><span class="line">[one, , , four] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(one); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(four); <span class="comment">//4</span></span><br></pre></td></tr></table></figure></p><h2 id="Default-Value"><a href="#Default-Value" class="headerlink" title="Default Value"></a>Default Value</h2><p><code>destructuring</code>을 통해 값을 할당할 때, 해당하는 값이 없을 때, <code>undefined</code> 대신 할당할 default value를 지정해줄 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [first, second, third = <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">//1 by destructuring</span></span><br><span class="line"><span class="built_in">console</span>.log(second); <span class="comment">//2 by destructuring</span></span><br><span class="line"><span class="built_in">console</span>.log(third); <span class="comment">//3 by default value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [fourth, fifth, sixth = <span class="number">6</span>] = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">66</span>];</span><br><span class="line"><span class="built_in">console</span>.log(fourth); <span class="comment">//4 by destructuring</span></span><br><span class="line"><span class="built_in">console</span>.log(fifth); <span class="comment">//5 by destructuring</span></span><br><span class="line"><span class="built_in">console</span>.log(sixth); <span class="comment">//66 by destructuring</span></span><br></pre></td></tr></table></figure></p><h2 id="Default-Parameter"><a href="#Default-Parameter" class="headerlink" title="Default Parameter"></a>Default Parameter</h2><p>parameter에 값이 넘어가지 않아도, default value로 설정된 값이 해당 파라미터 대신 값이 할당된다. parameter에서도 마찬가지로 기존의 default value는 <code>undefined</code> 값이었지만, 그 값을 코드 상에서 설정할 수 있게 된 것이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> somethingFunction = <span class="function">(<span class="params">prev, post = <span class="number">20</span></span>) =&gt;</span> prev + post;</span><br><span class="line"><span class="built_in">console</span>.log(somethingFunction(<span class="number">1</span>)); <span class="comment">//21 by default parameter</span></span><br><span class="line"><span class="built_in">console</span>.log(somethingFunction(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(somethingFunction(<span class="number">1</span>, <span class="literal">undefined</span>)); <span class="comment">//21 by default parameter</span></span><br><span class="line"><span class="built_in">console</span>.log(somethingFunction(<span class="number">1</span>, <span class="literal">null</span>)); <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p><p>함수에도 <code>length</code>라는 <code>property</code>가 따로 존재한다. 그런데 이 때, <code>default parameter</code>는 <code>length</code>에서 무시된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getTotal(<span class="number">100</span>); <span class="comment">//1</span></span><br><span class="line">getTotal(<span class="number">100</span>, <span class="number">0.05</span>); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(getTotal.length); <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p><p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="noopener">Github Respository</a>에서 확인하실 수 있습니다.</p><p><em>5. end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javascript_es6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES6-5-Destructuring-and-Default-Parameter&quot;&gt;&lt;a href=&quot;#ES6-5-Destructuring-and-De
      
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="es6" scheme="https://jaeyeophan.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>[ES6] 4. Spread, Rest parameter</title>
    <link href="https://jaeyeophan.github.io/2017/04/18/ES6-4-Spread-Rest-parameter/"/>
    <id>https://jaeyeophan.github.io/2017/04/18/ES6-4-Spread-Rest-parameter/</id>
    <published>2017-04-18T11:59:13.000Z</published>
    <updated>2017-09-04T07:08:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript_es6.png" alt=""></p><h1 id="ES6-4-Spread-Rest-parameter"><a href="#ES6-4-Spread-Rest-parameter" class="headerlink" title="[ES6] 4. Spread, Rest parameter"></a>[ES6] 4. Spread, Rest parameter</h1><h2 id="Spread"><a href="#Spread" class="headerlink" title="Spread"></a>Spread</h2><p>이터러블 오브젝트(Iterable object)의 엘리먼트를 하나씩 분리하여 전개한다. 전개한 결과를 변수에 할당하거나 호출하는 함수의 파라미터 값으로 사용할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> prev = [<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> post = [<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> spreadObj = [<span class="number">1</span>, <span class="number">2</span>, ...prev, <span class="number">5</span>, <span class="number">6</span>, ...post, <span class="number">9</span>];</span><br><span class="line"><span class="built_in">console</span>.log(spreadObj); <span class="comment">// [1,2,3,4,5,6,7,8,9]</span></span><br></pre></td></tr></table></figure></p><p>문자열도 가능하다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sObj = [...<span class="string">"javascript"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(sObj); <span class="comment">// ["j", "a", "v", "a", "s", "c", "r", "i", "p", "t"]</span></span><br></pre></td></tr></table></figure></p><h2 id="Rest-Parameter"><a href="#Rest-Parameter" class="headerlink" title="Rest Parameter"></a>Rest Parameter</h2><p>함수를 호출할 때 <code>spread</code> 연산자로 파라미터를 작성한 형태를 <code>Rest parameter</code>라고 한다. 함수안의 코드를 확인하지 않고도 호출문의 형태만 보더라도 <code>Rest parameter</code> 의 범위를 확인할 수 있어 가독성이 높아진다. 또한 <code>Rest parameter</code>는 <code>Array</code>, 즉 배열이므로 <code>Array</code> 오브젝트의 메서드를 사용할 수 있다. 그리고 <code>arrow funtion</code>에서도 사용 가능하다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> price = [<span class="number">12</span>, <span class="number">20</span>, <span class="number">18</span>];</span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">12</span>, <span class="number">20</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure></p><p>built in Object인 <code>Math</code>의 메소드 <code>max()</code>를 사용하기 위해서는 위 코드처럼 하나씩 넘겨줘야 한다.<br>또는 다음과 같은 방식을 사용했다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, price);</span><br></pre></td></tr></table></figure></p><p>하지만 Rest parameter를 사용하면 보다 깔끔하게 작성할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maxPrice = Max.max(...price);</span><br></pre></td></tr></table></figure></p><p><code>Rest parameter</code>는 동적(dynamic)으로 생성된 파라미터라고 할 수 있기 때문에 함수의 <code>length</code>에서 포함되지 않는다. 기본적으로 함수의 <code>length</code> 프로퍼티는 파라미터의 개수를 의미한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getElementByRestWithParam = <span class="function">(<span class="params">param, ...rest</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(param);</span><br><span class="line">    <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getElementByRestWithParam.length); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p>위 <code>getElementByRestWithParam</code>메소드에 <code>spread operator</code>를 사용하여 인자를 넘겨보자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> values = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line">getElementByRestWithParam(...values); <span class="comment">//10 \n [20, 30]</span></span><br></pre></td></tr></table></figure></p><p><code>param</code>에 해당하는 인자가 따로받아지고 나머지 인자들은 <code>...rest</code>로 넘겨지면서 다시 배열로 넘겨지게 된다!</p><p><code>Rest parameter</code>를 사용했을 때와 기존의 자바스크립트에서 <code>arguments</code>를 사용했을 때의 차이점을 살펴보기 위해 <code>arguments</code>에 대해서 잠깐 살펴보자. <code>arguments</code>는 <code>Array-Like Object</code>라는 공식 명칭을 하고 있는 유사 배열이다.</p><h2 id="Array-like-Object-유사배열"><a href="#Array-like-Object-유사배열" class="headerlink" title="Array-like Object(유사배열)"></a>Array-like Object(유사배열)</h2><p>배열의 특징 중 하나는 index를 갖고 있어서 임의 접근(random access)가 가능하고, 그 index가 순차적으로 증가한다는 것이다. 만약 Object가 key값이 순차적으로 증가하는 값이고, 그에 따른 value가 존재한다고 했을 때, <code>Array-like Object</code>라고 한다.<br>배열의 인덱스 값을 프로퍼티 key 값으로 사용하는 것이다. 그리고 <code>length</code>라는 프로퍼티 값을 갖고 있어서 전개를 할 때는 다음과 같이 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array-like object</span></span><br><span class="line"><span class="keyword">let</span> arrLikeObj = &#123;</span><br><span class="line">    <span class="number">0</span> : <span class="string">"zero"</span>,</span><br><span class="line">    <span class="number">1</span> : <span class="string">"one"</span>,</span><br><span class="line">    <span class="number">2</span> : <span class="string">"two"</span>,</span><br><span class="line">    length : <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arrLikeObj.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arrLikeObj[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Array-like Object</code>는 다음 두 가지 규칙을 모두 만족시켜야 한다.<br>1) 프로퍼티 값을 0부터 1씩 증가하면서 순차적으로 작성해야 한다.<br>2) length를 프로퍼티 키로 하여 전체 프로퍼티 수를 작성해야 한다.</p><h3 id="Rest-parameter와-arguments의-차이"><a href="#Rest-parameter와-arguments의-차이" class="headerlink" title="Rest parameter와 arguments의 차이"></a>Rest parameter와 arguments의 차이</h3><p><code>arguments</code>도 <code>Array-like object</code>이기 때문에 <code>for statement</code>로 전개할 수 있다. 하지만 <code>Array</code> 오브젝트의 메서드를 사용할 수 없다. 이것이 치명적인 단점인 것이다. 또 <code>arrow function</code>에서는 <code>arguments</code>를 사용할 수 없다. 이것으로 미루어보아, ES6에서는 <code>arguments</code>를 사용하는 것을 최대한 자제하라는 느낌이다. 사실 <code>Rest parameter</code>에 익숙해지기만 하면 <code>arguments</code>를 통해 인자를 받는 것보다 유연한 코드를 작성할 수 있다.</p><p>한 가지 더 한계점을 지적하자면 <code>arguments</code>는 함수 내부를 봐야 어느 부분에서 <code>arguments</code> 객체를 사용하는지 알 수 있어 코드의 가독성이 떨어지게 된다. 그렇기 때문에 <code>arguments</code> 대신 <code>Rest parameter</code>를 도입한 것이다.</p><p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="noopener">Github Respository</a>에서 확인하실 수 있습니다.</p><p><em>4. end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javascript_es6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES6-4-Spread-Rest-parameter&quot;&gt;&lt;a href=&quot;#ES6-4-Spread-Rest-parameter&quot; class=&quot;head
      
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="es6" scheme="https://jaeyeophan.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>[ES6] 3. Iteration and for-of statement</title>
    <link href="https://jaeyeophan.github.io/2017/04/18/ES6-3-Iteration-and-for-of-statement/"/>
    <id>https://jaeyeophan.github.io/2017/04/18/ES6-3-Iteration-and-for-of-statement/</id>
    <published>2017-04-18T04:52:45.000Z</published>
    <updated>2017-04-19T07:31:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript_es6.png" alt=""></p><h1 id="ES6-3-Iteration-and-for-of-statement"><a href="#ES6-3-Iteration-and-for-of-statement" class="headerlink" title="[ES6] 3. Iteration and for-of statement"></a>[ES6] 3. Iteration and for-of statement</h1><h2 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h2><p>ES6에서 이터레이션 프로토콜은 <code>Iterable 프로토콜</code>과 <code>Iterator 프로토콜</code>로 구성된다. 결론부터 말하자면 <code>Iterable</code> 프로토콜은 <code>반복 가능한</code> 오브젝트를 나타내는 프로토콜이며 <code>Iterator</code> 프로토콜은 이터러블 오브젝트(<code>Iterable</code> 프로토콜을 따르는 오브젝트)의 값을 <code>작성한 순서대로</code> 처리하는 프로토콜이다.</p><h2 id="Iterable-프로토콜"><a href="#Iterable-프로토콜" class="headerlink" title="Iterable 프로토콜"></a>Iterable 프로토콜</h2><p>오브젝트의 반복 처리 규약을 정의한다.<br>Iterable Object</p><blockquote><p><code>String</code>, <code>Array</code>, <code>Map</code>, <code>Set</code>, <code>TypedArray</code>, <code>Argument</code> 오브젝트<br>그리고 DOM의 <code>NodeList</code>  </p></blockquote><p>위 <em>built in 오브젝트</em>들은 디폴트로 이터러블 프로토콜을 갖고 있다. 오브젝트에 <code>Symbol.iterator</code>가 있어야 한다. <code>Symbol.iterator</code>가 있는 오브젝트는 이터러블 오브젝트이다. 또한 상속받은 prototype chain에 있어도 이터러블 오브젝트이다. (<code>Symbol</code>에 대해서는 다음 포스팅에서 다룰 예정이다.)</p><p>오브젝트에 프로퍼티 존재 여부를 체크할 때, Symbol의 경우에는 arrayObj[Symbol.iterator]와 같이 대괄호 <code>[]</code>안에 작성해야 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="built_in">Symbol</span>.iterator]); <span class="comment">//function values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="built_in">Symbol</span>.iterator]); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p><p><code>Array</code> 오브젝트는 기본적으로 <code>iterable</code> 프로토콜을 구현한다. 하지만 <code>Object</code> 오브젝트는 <code>iterable</code> 프로토콜을 구현하지 않는다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iteratorObj = arr[<span class="built_in">Symbol</span>.iterator](); <span class="comment">//iterator object</span></span><br></pre></td></tr></table></figure></p><p>위와 같은 방식으로 <code>Array</code> 오브젝트는 <code>iterator</code>를 받을 수 있다.</p><h2 id="JavaScript’s-for-statement"><a href="#JavaScript’s-for-statement" class="headerlink" title="JavaScript’s for statement"></a>JavaScript’s for statement</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>forEach 문은 arrow function과 조합해서 사용하면 추가적인 변수 사용 없이 코드가 깔끔해질 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> categories = [<span class="string">"Korean"</span>, <span class="string">"English"</span>, <span class="string">"Science"</span>];</span><br><span class="line">categories.forEach(<span class="function"><span class="params">subject</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(subject);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>&gt;</span><br><span class="line">Korean</span><br><span class="line">English</span><br><span class="line">Science</span><br></pre></td></tr></table></figure></p><p>그러나 for문 중간에 <code>continue</code> or <code>break</code> or <code>return</code> 선언문을 사용할 수 없다. 기존의 for-statement를 사용하는 경우를 보자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; subject.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(categoried[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>&gt;</span><br><span class="line">Korean</span><br><span class="line">English</span><br><span class="line">Science</span><br></pre></td></tr></table></figure></p><p><code>i</code>의 역할이 index를 잡아주는 것 외에 별 다른 기능이 없다. 그래서 기존에는 <code>for-in statement</code>를 사용했다. 하지만 <code>for-in statement</code> 은 문자열 키를 가진 일반 <code>Object</code> 객체들을 위해 만들어졌다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> categories) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>&gt;</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>그래서 ES6에서 <code>for-of statement</code>가 등장했다.<br><code>for-in loop statement</code>는 객체의 프로퍼티들을 루프시키지만 <code>for-of loop statement</code>는 데이터, 즉 배열 내의 value들을 루프시킨다. 또한 for-of는 배열 뿐만 아니라 다양한 Collection에도 동작한다. DOM의 <code>NodeList</code> 같은 유사배열 객체들에도 동작하고 문자열에도 동작한다. 문자열을 유니코드 문자의 배열로 취급하는 것이다. <code>Set</code>, <code>Map</code>에 대해서도 물론 동작한다. key-value 형식의 <code>Map</code>에 대해서는 for (let [key, value] of …) 형식의 <code>destructuring</code>을 사용한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> categories) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>&gt;</span><br><span class="line">Korean</span><br><span class="line">English</span><br><span class="line">Science</span><br></pre></td></tr></table></figure></p><p>단 for-of 가 만능은 아니다. <code>Object</code>의 프로퍼티를 루프시키려면 <code>for-in statement</code>를 사용해야 한다. 사실 <code>for-in statement</code>의 원래 목적이 <code>Object</code> 프로퍼티 순회이다. Object를 순회하는 경우를 살펴보자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    one : <span class="number">1</span>,</span><br><span class="line">    two : <span class="number">2</span>,</span><br><span class="line">    three : <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>위와 같은 obj라는 오브젝트를 정의한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console&gt;</span></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure></p><p><code>for-in statement</code>를 통해서 정의한 오브젝트(obj)의 key를 순회했다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj[key]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// console&gt;</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>오브젝트를 <code>for-of statment</code>로 순회하면 어떻게 될까?<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// console&gt;</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: obj[Symbol.iterator] is not a function</span></span><br></pre></td></tr></table></figure></p><p>JavaScript의 Object는 <code>iterable</code> 프로토콜을 구현하고 있지 않기 때문에, <code>Symbol.iterator</code>가 존재하지 않는다.</p><p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="noopener">Github Respository</a>에서 확인하실 수 있습니다.</p><p><em>3. end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javascript_es6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES6-3-Iteration-and-for-of-statement&quot;&gt;&lt;a href=&quot;#ES6-3-Iteration-and-for-of-stat
      
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="es6" scheme="https://jaeyeophan.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>[ES6] 2. Arrow function</title>
    <link href="https://jaeyeophan.github.io/2017/04/18/ES6-2-Arrow-function/"/>
    <id>https://jaeyeophan.github.io/2017/04/18/ES6-2-Arrow-function/</id>
    <published>2017-04-18T04:51:49.000Z</published>
    <updated>2017-04-18T04:54:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript_es6.png" alt=""></p><h1 id="ES6-2-Arrow-Function"><a href="#ES6-2-Arrow-Function" class="headerlink" title="[ES6] 2. Arrow Function"></a>[ES6] 2. Arrow Function</h1><blockquote><p>Always apply to ‘Anonymous function’  </p></blockquote><h3 id="자바스크립트의-Scope"><a href="#자바스크립트의-Scope" class="headerlink" title="자바스크립트의 Scope"></a>자바스크립트의 Scope</h3><p>자바스크립트에서 생성자 함수를 통해 객체를 생성하면 변수 scope가 변경된다. 즉, 생성자 함수 내부에서의 this는 자신을 호출한 대상이 아닌 생성자 함수를 가리키게 된다. 생성자 함수를 통해 생성되는 객체의 과정 때문이다. 그래서 우리는 여태껏 별의 별짓을 다해왔다. <code>self</code>며 <code>bind</code>며 jQuery에서는 <code>proxy</code>라는 녀석도 사용했다.</p><h3 id="새로운-function의-등장"><a href="#새로운-function의-등장" class="headerlink" title="새로운 function의 등장"></a>새로운 function의 등장</h3><p>하지만 이제는 새로 도입된 Arrow function 을 사용하여 변수 스코프를 보존하자. Arrow function를 통해서 함수를 정의하게 되면, 변수들이 사용되는 위치와는 상관없이 변수들이 정의되어 있는 값으로 scope가 binding  된다. 한 가지 특징을 덧붙이자면, arrow function을 사용하게 되면 <code>arguments</code> 객체가 생성되지 않는다. 하지만 우리는 ES6 문법을 사용하는 이상, <code>arguments</code>는 필요하지 않다!</p><h3 id="Arrow-function-Rule"><a href="#Arrow-function-Rule" class="headerlink" title="Arrow function Rule"></a>Arrow function Rule</h3><p>ES6의 arrow function에는 몇 가지 규칙이 존재하며 대부분의 <code>lamda</code>에서도 비슷한 규칙을 가지고 있어서 <code>lamda</code>를 사용해본 경험이 있다면 어색하지 않을 것이다.<br>1) Parameter와 화살표 사이에서 개행할 수 없다.<br>2) Parameter가 하나일 때는 괄호를 생략할 수 있다.<br>3) Parameter가 없으면 소괄호( ( ) )만 작성한다.<br>4) Block scope({ })를 지정하지 않고 한 줄로 arrow function을 사용할 때는 return이 생략될 수 있다.<br>5) 그 반대로 block scope를 사용한다면 return을 명시해줘야 한다.</p><h3 id="Arrow-Function은-this를-bind하지-않는다"><a href="#Arrow-Function은-this를-bind하지-않는다" class="headerlink" title="Arrow Function은 this를 bind하지 않는다!"></a>Arrow Function은 this를 bind하지 않는다!</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"todos"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//#todos</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"todos"</span>).addEventListener(<span class="string">"click"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//Window</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="this의-정체"><a href="#this의-정체" class="headerlink" title="this의 정체"></a>this의 정체</h3><p>ES5에서 <code>this</code> 결정되는 세 가지 조건을 짚고 넘어가자.<br>1) 생성자 내에서<br>생성자 함수를 <code>new</code>라는 키워드를 통해 호출하면 내부에서 <code>this</code>는 인스턴스 그 자체를 가리킨다. 생성자 함수 내부에서 <code>return this;</code>가 생략되어 있기 때문이다.<br>2) 함수 내에서<br><code>this</code>는 생략된 매개 변수이다. 무엇이 함수를 호출했는가가 <code>this</code>를 결정한다.<br>3) <code>bind</code>, <code>apply</code>, <code>call</code> method or <code>proxy</code> method of jQuery<br><code>this</code>는 메소드로 바꿔준 대상을 가리키게 된다.</p><blockquote><p>그렇다면 arrow function 내에서 <code>this</code>는 무엇을 가리키는가.</p></blockquote><p>해당 function을 정의한 영역의 <code>this</code>를 가져온다. 한 단계 더 위의 <code>element</code>를 가리키는 것이다. 그렇기 때문에 <code>prototype</code>에 함수를 정의할 때 arrow function을 사용할 때 내부적으로 <code>this</code>를 사용하게 되면 객체를 가리키지 않고 <code>window</code> 객체를 가리키게 된다. 또한 arrow function은 명식적으로 <code>bind</code>, <code>call</code>로 <code>this</code>를 넣어줘도 이를 무시한다. </p><p>ES6의 arrow function은 단순히 함수를 간단하게 작성할 수 있는 문법이 아니다. 기존의 방식대로 function을 작성해야만 의도대로 작동하는 function이 존재할 수 있고, arrow function으로 기존의 function을 작성하던 방식보다 편하게 작성할 수 있게 된 것이다. 두 가지 방식의 차이점을 제대로 이해하고 새로운 문법과 기존의 문법을 적재적소에서 사용하는 것이 중요해졌다.</p><p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="noopener">Github Respository</a>에서 확인하실 수 있습니다.</p><p><em>2. end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javascript_es6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES6-2-Arrow-Function&quot;&gt;&lt;a href=&quot;#ES6-2-Arrow-Function&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="es6" scheme="https://jaeyeophan.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>[ES6] 1. let-const</title>
    <link href="https://jaeyeophan.github.io/2017/04/18/let-const/"/>
    <id>https://jaeyeophan.github.io/2017/04/18/let-const/</id>
    <published>2017-04-18T04:48:49.000Z</published>
    <updated>2017-04-18T06:48:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript_es6.png" alt=""></p><h1 id="ES6-1-let-amp-const"><a href="#ES6-1-let-amp-const" class="headerlink" title="[ES6] 1. let &amp; const"></a>[ES6] 1. let &amp; const</h1><h2 id="자바스크립트의-정체"><a href="#자바스크립트의-정체" class="headerlink" title="자바스크립트의 정체"></a>자바스크립트의 정체</h2><p>ES6의 문법을 알아보기 전에 자바스크립트의 정체부터 짚고 넘어가자. 자바스크립트(JavaScript)는 스크립트 언어(script language)이다. 스크립트 언어란 언어를 해석하고 실행하는 소프트웨어가 따로 존재하는 언어를 말한다. 자바스크립트를 해석하고 실행하는 소프트웨어는 브라우저이다. 이러한 의미에서 Node.js는 스크립트 언어라고 부르기 애매하고 자바스크립트의 문법을 차용한 다른 종류의 언어라고 생각해도 된다. 우선 자바스크립트가 해석되고 실행될 때 일어나는 확보, 선언, 할당의 차이를 짚고 넘어가야 한다.</p><h3 id="확보"><a href="#확보" class="headerlink" title="확보"></a>확보</h3><p>브라우저가 자바스크립트를 해석할 때 두 번 파싱(parsing)하는데 첫번째 파싱 과정이 Lexical parsing이다. 실행하려는 자바스크립트 파일이 어느 정도의 메모리를 필요로 하는지를 파악하기 위해 거치는 파싱 과정인 것이다. 이 때 자바스크립트의 모든 선언문은 호이스팅(Hoisting)된다.</p><h3 id="선언"><a href="#선언" class="headerlink" title="선언"></a>선언</h3><p>말 그대로 선언하는 것이다. 값을 할당하지 않는다. 자바스크립트에서는 선언만 하고 값을 할당하지 않으면 <code>undefined</code>값이 할당된다. 확보만 하고 선언하지 않으면 <code>Reference error</code>가 발생하고 선언을 하게 되면 <code>undefined</code> 값이 나타난다.</p><h3 id="할당"><a href="#할당" class="headerlink" title="할당"></a>할당</h3><p>특정 변수에 값을 할당하는 과정이다. 위 세 가지를 파악해야 var와 let 그리고 const의 차이를 이해할 수 있다</p><h2 id="let-으로-변수-선언-및-할당하기"><a href="#let-으로-변수-선언-및-할당하기" class="headerlink" title="let 으로 변수 선언 및 할당하기"></a>let 으로 변수 선언 및 할당하기</h2><p><code>let</code>으로 정의된 변수들은 호이스팅 되지 않는다(?) 많은 책에서 이렇게 표현을 하고 있지만 이것은 잘못된 표현이다. <code>let</code>으로 선언해도 호이스팅된다. lexical parsing 단계에서 해당 자바스크립트 파일을 실행하기 위한 메모리 공간을 <code>확보</code>해야하기 때문이다. 다만 let 변수로 선언이 되기 전 해당 변수를 사용하려고 하면 <code>Reference error</code>를 발생시키는 것이다. 예제 코드를 보자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5 code :: var&gt;&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//undefined</span></span><br><span class="line">foo = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//123</span></span><br><span class="line"><span class="comment">//ES6 code :: let&gt;&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> foo;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//undefined</span></span><br><span class="line">foo = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//123</span></span><br></pre></td></tr></table></figure></p><p>let은 유효범위의 시작에서부터 <code>선언</code>될 때까지 <code>temporary dead zone</code>(일시적 사각지대)에 있다. 이 dead zone에서 사용하게 되면 <code>ReferenceError</code>가 발생한다.</p><h2 id="let-in-for-loop"><a href="#let-in-for-loop" class="headerlink" title="let - in for loop"></a>let - in for loop</h2><p><code>let</code>으로 정의된 변수들은 가장 가까운 블록으로 scope이 지정된다. 여기서 블록이란 <code>if</code>, <code>else</code>, <code>for</code>, <code>while</code> 같은 문법으로 지정된 { } 블록을 의미한다. <code>let</code> 키워드를 사용한 변수들은 그들 각각의 함수 block에 귀속된다. <code>var</code> 변수는 함수의 상단으로 호이스팅(hoisting) 된 다음에, 각 루프의 반복 변수가 공유하게 된다. 그 결과, 콜백이 실행될 때는 <code>i</code> 변수가 루프의 마지막 변수로 할당된다. 즉 콜백에서 반복문을 제어하는 변수에 접근할 때 문제가 발생하는 것이다. 이러한 문제를 해결하기 위해 <code>let</code>을 사용할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5 code</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadFiles</span>(<span class="params"> userNames </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> userNames)&#123;</span><br><span class="line">        _fetchProfiles(userNames[i], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(userNames[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">loadFiles([<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span> &gt;</span><br><span class="line">D <span class="comment">// userNames[4]</span></span><br><span class="line">D <span class="comment">// userNames[4]</span></span><br><span class="line">D <span class="comment">// userNames[4]</span></span><br><span class="line">D <span class="comment">// userNames[4]</span></span><br></pre></td></tr></table></figure><p>ES6 code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6 code</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadFiles</span>(<span class="params"> userNames </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> i <span class="keyword">in</span> userNames )&#123;</span><br><span class="line">        _fetchProfile(userNames[i], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(userNames[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">loadFiles([<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span> &gt;</span><br><span class="line">A <span class="comment">// userNames[1]</span></span><br><span class="line">B <span class="comment">// userNames[2]</span></span><br><span class="line">C <span class="comment">// userNames[3]</span></span><br><span class="line">D <span class="comment">// userNames[4]</span></span><br></pre></td></tr></table></figure></p><h2 id="let-cannot-be-redeclared"><a href="#let-cannot-be-redeclared" class="headerlink" title="let cannot be redeclared"></a>let cannot be redeclared</h2><p><code>let</code>으로 정의된 변수는 같은 블록에서 재할당될 수는 있지만 재정의는 될 수 없다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6 code</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'hello'</span>;</span><br><span class="line">a = <span class="string">'world'</span> <span class="comment">// available</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'world'</span>; <span class="comment">// false -&gt; TypeError : Identifier ‘a’ has already been declared</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flashMessage = <span class="string">'hello'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadFiles</span>(<span class="params">userNames</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flashMessage = <span class="string">'world'</span>; <span class="comment">// available</span></span><br><span class="line">    <span class="keyword">return</span> flashMessage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="const-declaration"><a href="#const-declaration" class="headerlink" title="const - declaration"></a>const - declaration</h2><p>const 키워드는 상수라고 불리는 읽기 전용 변수를 생성하는 키워드이다. 한 번 할당되면, 상수는 새로운 값으로 할당될 수 없다. 명시적으로 변경을 시도해도 바뀌지 않는다. const 로 정의된 변수는 초기에 정의할 때, 반드시 값을 할당해줘야 한다. 그렇지 않으면 <code>Syntax Error</code>가 발생하게 된다. const 로 정의된 변수는 <code>let</code>과 마찬가지로, 가장 가까운 블록에 scope이 지정된다.</p><p>예제로 사용된 코드는 <a href="https://github.com/JaeYeopHan/ECMAScript6_study" target="_blank" rel="noopener">Github Respository</a>에서 확인하실 수 있습니다.</p><p><em>chapter 1. end</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javascript_es6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES6-1-let-amp-const&quot;&gt;&lt;a href=&quot;#ES6-1-let-amp-const&quot; class=&quot;headerlink&quot; title=&quot;[
      
    
    </summary>
    
      <category term="ECMAScript6" scheme="https://jaeyeophan.github.io/categories/ECMAScript6/"/>
    
    
      <category term="es6" scheme="https://jaeyeophan.github.io/tags/es6/"/>
    
  </entry>
  
</feed>
