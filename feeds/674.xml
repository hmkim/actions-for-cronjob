<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Sangboak Lee on Medium]]></title>
        <description><![CDATA[Stories by Sangboak Lee on Medium]]></description>
        <link>https://medium.com/@sangboaklee?source=rss-ee2bc1ce72f7------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/0*2Y_ub1UQLx5iFhYd.</url>
            <title>Stories by Sangboak Lee on Medium</title>
            <link>https://medium.com/@sangboaklee?source=rss-ee2bc1ce72f7------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Sun, 12 May 2019 20:43:16 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@sangboaklee" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[Redux-saga 테스트 코드 작성하기]]></title>
            <link>https://medium.com/@sangboaklee/redux-saga-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0-1fc13f7fd279?source=rss-ee2bc1ce72f7------2</link>
            <guid isPermaLink="false">https://medium.com/p/1fc13f7fd279</guid>
            <category><![CDATA[redux]]></category>
            <category><![CDATA[redux-saga]]></category>
            <category><![CDATA[test]]></category>
            <category><![CDATA[react]]></category>
            <dc:creator><![CDATA[Sangboak Lee]]></dc:creator>
            <pubDate>Fri, 25 May 2018 14:30:01 GMT</pubDate>
            <atom:updated>2018-05-25T14:30:01.709Z</atom:updated>
            <content:encoded><![CDATA[<h4>Redux-saga의 테스트 용이성과 실제적인 테스트 코드 작성 방법</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*-GC9G3YWGrTD85yV5N0STg.png" /><figcaption><a href="https://github.com/redux-saga/redux-saga">https://github.com/redux-saga/redux-saga</a></figcaption></figure><p><a href="https://redux-saga.js.org/">Redux-saga</a>는 <a href="https://redux.js.org/">Redux</a>에서 비동기 액션을 핸들링하기 위한 다양한 라이브러리 중 하나이다. 전형적인 Callback 스타일, Observable을 활용한 라이브러리 등이 있지만 Redux-saga는 ES2015의 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/function*">Generator Function</a>를 적극적으로 활용했다. 덕분에 훌륭한 테스트 용이성 제공하고 있다.</p><p><em>**이 포스팅은 Redux-saga에 대한 기본적인 지식을 전제한다</em></p><h3>Redux-saga의 무엇이 테스트를 쉽게 만드나</h3><p>실제적인 테스트 코드 작성 방법을 다루기 전에, Redux-saga의 어떤 요소가 테스트를 용이하게 만드는지 간략하게 정리해보겠다. 이 내용은 공식 문서에도 정리가 되어있으므로, 큰 개념만 설명하고 넘어가도록 한다.</p><p>Saga는 기본적으로 비동기 액션을 모니터링하는 Watcher Saga와 실제로 비동기 작업을 수행하는 Worker Saga로 구성된다. 그리고 Saga들을 실제적으로 핸들링하여 Redux(Store)와 연결하는 Saga Middleware(이하 미들웨어)가 있다.</p><p>그 중 Worker Saga는 yield 표현을 이용하여 비동기로 특정 객체를 반환한다. 미들웨어는 (Worker) Saga가 반환하는 Promise나 단순 Object를 핸들링 할 수 있다. 여기서 Promise는 axios.get(...) 이나 $.get(...) 등과 같은 비동기 작업을 하는 <strong>API를 호출한 결과로 반환되는 Promise</strong>를 의미한다. 문제는 Promise 객체는 테스트가 어렵다는 점이다.</p><p>여기서 <strong>미들웨어가 핸들링하는 두 번째 타입인 단순 Object</strong>가 등장한다. 해당 Object는 미들웨어로 하여금 특정 작업을 수행하도록 가이드의 역할을 한다. 위에 Promise의 예시와 비교하면 아래와 유사한 객체를 반환하는 셈이다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/82ed9fd0268ec827657d06d7cf8cbfc5/href">https://medium.com/media/82ed9fd0268ec827657d06d7cf8cbfc5/href</a></iframe><p>첫 번째 시나리오와 대조적으로 Promise를 반환하는 <strong>실제 API 호출이 미들웨어로 위임</strong>되는 것이다. 미들웨어는 해당 객체를 받아서 적절한 작업을 수행하겠지만, 이 단계를 사용자(개발자)가 신경쓰지 않아도 된다. 이것을 공식 문서에서는 <em>(사이드)이펙트 생성과 (사이드)이펙트 실행의 분리</em>라고 표현했다.</p><blockquote>Separation between Effect creation and Effect excution</blockquote><p>사용자는 이러한 분리 덕분에 <strong>이펙트가 제대로 생성되었는지(가이드 객체가 제대로 반환되었는지)만 테스트</strong>하면 되며, 단순 객체의 테스트는 Promise 객체 테스트보다 훨씬 용이하다.</p><h3>무엇을 테스트 하는가</h3><p>위에서 언급한 Worker Saga는 경우에 따라 상이하나 일반적으로는 아래와 같은 형태를 가진다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/314313eae2aacc1965906f5ee3798cbe/href">https://medium.com/media/314313eae2aacc1965906f5ee3798cbe/href</a></iframe><p>위의 코드를 테스트 가능한(해야할) 작은 조각으로 하나씩 풀어보도록 하자.</p><pre>yield put(fooActions.setIsFetching(true));</pre><p>비동기 작업(HTTP Request)을 시작하기 전에 <strong>동기 액션을 Dispatch</strong> 한다. 여기서는 로딩 인디케이터 따위를 표시하기 위한 정보를 업데이트 한다.</p><pre>const foo = yield call(api.fetchFoo, {<br>  id: id,<br>  ...otherOption<br>});</pre><p>fetchFoo를 위한<strong> (비동기)이펙트를 생성</strong>한다. 두 번째 인자로 fetchFoo 함수와 함께 호출할 인자를 넘긴다.</p><pre>yield put(fooActions.fetchFooSuccess(fooObject));</pre><p>예외가 발생하지 않는다면 fetchFoo가 성공했다는 <strong>동기 액션을 Dispatch</strong> 한다.</p><pre>catch(error) {<br>  yield put(fooActions.fetchFooFailure(error));<br>}</pre><p>try 구문 안의 블록을 실행하다 예외가 발생한 경우 즉시 fetchFoo가 실패했다는 <strong>동기 액션을 Dispatch</strong> 한다.</p><pre>yield put(fooActions.setIsFetching(false));</pre><p>상기 조건과 관계없이 <strong>비동기 작업이 종료되었다는 정보를 업데이트</strong> 한다.</p><p>이 흐름이 바로 우리가 <strong>Redux-saga를 테스트 할 때 검사해야 할 주요 지점</strong>이다. 이 지점들의 공통점으로는 모두 yield 표현을 사용했다는 점이며, yield 표현을 통해서 반환된 값을 테스트 하는 방식으로 진행하게 된다.</p><h3>테스트 코드</h3><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ed5cf7a0cba018abedb7af3543a7b39d/href">https://medium.com/media/ed5cf7a0cba018abedb7af3543a7b39d/href</a></iframe><p>기본적으로 Saga의 테스트는 <strong>Generator Function으로부터 생성된 Iterator가 순차적으로 </strong><strong>yield 구문을 만나서 반환하는 값을 확인하는 방법</strong>으로 진행된다.</p><pre>expect(iterator.next().value).toEqual(<br>  put(setIsFetching(true))<br>);</pre><p>첫 번째 yield가 setIsFetching 액션을 true 값으로 제대로 반환하는지 테스트 한다. (엄밀하게 말하면 <strong>해당 액션을 처리하도록 가이드하는 객체</strong>)</p><pre>expect(iterator.next().value).toEqual(<br>  call(api.fetchFoo, {<br>    id: id,<br>    ...otherOption<br>  })<br>);</pre><p>두 번째 yield가 <strong>비동기 작업에 대한 이펙트를 제대로 생성/반환</strong>하였는지 테스트 한다.</p><pre>expect(iterator.next({ value: &#39;foo&#39; }).value).toEqual(<br>  put(fetchFooSuccess({<br>    wrappedWithObject: true,<br>    foo: { value: &#39;foo&#39; } <br>  }))<br>);</pre><p>비동기 작업이 성공한 경우, <strong>next 메소드에 특정 값을 전달하여 호출하고 그 값이 </strong><strong>fetchFooSuccess를 통해 제대로 처리되었는지 테스트</strong> 한다. 특히 이 부분이 Redux-saga 테스트 용이성을 단적으로 드러내는 부분이다.</p><p>Redux-thunk같은 라이브러리를 사용할 경우, 일반적인 비동기 작업을 테스트하기 위해서는 <a href="http://sinonjs.org/">Sinon.js</a>등을 활용하여 <strong>비동기 작업을 수행하는 메소드가 반환할 값을 Stubbing 해주거나 해당 메소드 자체를 Mock</strong>으로 만들어야한다. 하지만 Redux-saga는 Generator Function의 yield 구문을 통해서 Stub 없이 <strong>원하는 값을 주입</strong>할 수가 있다. 이 테스트 코드는 해당 값을 주입하고, Worker Saga 안에서 그 값이 다른 객체로 한번 더 감싸졌는지 검사한다.</p><pre>expect(iterator.next().value).toEqual(<br>  put(setIsFetching(false))<br>);</pre><p>첫 번째 테스트와 마찬가지로 setIsFetching 이펙트를 제대로 생성하였는지 테스트 한다.</p><pre>expect(iterator.next().done).toBeTruthy();</pre><p>해당 Worker Saga로 부터 생성된 <strong>Iterator가 종결되었는지 테스트</strong>한다.</p><p>Saga의 세부적인 과정들을 쪼개어 테스트하는 이 방법은 유용하지만, 개발자가 임의로 값을 주입할 수 있는 지점이 많아 질 경우 <strong>테스트 자체가 불안정(Brittle)해질 가능성</strong>이 있다. 테스트 코드에서 임의로 주입한 값으로 인해서 실제로 소스 코드가 변경되었음에도 테스트가 실패하지 않는 경우가 그런 것이다.</p><p>이에 대한 보완책으로 공식 문서에서는 <strong>하나의 Saga를 처음부터 끝까지 실행시킨 후, 수반되는 (사이드)이펙트들을 한번에 검사하는 방법을 제시</strong>한다. 이 경우 외부 API를 호출하는 부분만 Sinon 등으로 Stub을 만들고, 나머지 부분은 소스 코드 원형 그대로 테스트에 통과시키는 것이다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d0133c4c9355c021e1745bc601d848fd/href">https://medium.com/media/d0133c4c9355c021e1745bc601d848fd/href</a></iframe><p>이 방법은 원형 그대로의 소스 코드를 최대한 보존한 채 테스트를 진행할 수 있다는 장점이 있으나, 역시 <strong>Saga 내부의 새부적인 로직에 대한 테스트는 어려울 수 있다</strong>. 상황에 따라 두가지 방법을 취사 선택하거나, 전체적인 Flow를 두 번째 방법을 활용하여 테스트하고 세부적인 로직을 첫 번째 방법으로 테스트하는 등 개발자의 재량껏 조합해서 사용하면 된다.</p><p>여기까지 Redux-saga의 실제적인 테스트 코드 작성 방법에 대해 정리해보았다. 실제 제품에서 사용되는 Saga는 예시의 것보다 훨씬 복잡한 경우가 많을 것이나, 기본적인 방법은 큰 틀을 벗어나지 않는다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1fc13f7fd279" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Elixir Guard Clause의 in Expression]]></title>
            <link>https://medium.com/@sangboaklee/til-elixir-guard-clause%EC%9D%98-in-expression-69a69822338e?source=rss-ee2bc1ce72f7------2</link>
            <guid isPermaLink="false">https://medium.com/p/69a69822338e</guid>
            <category><![CDATA[til]]></category>
            <category><![CDATA[elixir]]></category>
            <dc:creator><![CDATA[Sangboak Lee]]></dc:creator>
            <pubDate>Tue, 22 May 2018 23:55:56 GMT</pubDate>
            <atom:updated>2018-05-25T12:10:49.329Z</atom:updated>
            <content:encoded><![CDATA[<p><a href="https://elixir-lang.org/">Elixir</a>에서 빈번하게 사용되는 <a href="https://hexdocs.pm/elixir/master/guards.html">Guard</a> Clause에는 일부 허용된 표현만 사용할 수 있다. 흔하게 사용되는 비교 연산자 ==, !=, &gt; 등과 타입 검사 함수 is_binary, is_boolean 등이 포함된다. 그리고 in 표현도 사용이 가능한데, 해당 표현을 활용하여 <a href="https://elixir-lang.org/getting-started/case-cond-and-if.html#case">Case</a>를 좀 더 유연하게 사용할 수 있다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5e04848b8ce2a3a7a0920d9854ea9556/href">https://medium.com/media/5e04848b8ce2a3a7a0920d9854ea9556/href</a></iframe><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=69a69822338e" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[TypeScript 현업 적용 후기]]></title>
            <link>https://medium.com/tapjoykorea/typescript-%ED%98%84%EC%97%85-%EC%A0%81%EC%9A%A9-%ED%9B%84%EA%B8%B0-caad266c8142?source=rss-ee2bc1ce72f7------2</link>
            <guid isPermaLink="false">https://medium.com/p/caad266c8142</guid>
            <category><![CDATA[typescript]]></category>
            <category><![CDATA[개발]]></category>
            <category><![CDATA[react]]></category>
            <category><![CDATA[리액트]]></category>
            <category><![CDATA[redux]]></category>
            <dc:creator><![CDATA[Sangboak Lee]]></dc:creator>
            <pubDate>Tue, 22 May 2018 12:14:12 GMT</pubDate>
            <atom:updated>2018-05-22T12:14:12.541Z</atom:updated>
            <content:encoded><![CDATA[<h4>React + Redux 기반의 실제 제품에 TypeScript를 적용한 후기</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Ukhx76VQ8E6JXEW7xfIzSA.png" /></figure><p><a href="https://reactjs.org/">React</a>와 <a href="https://redux.js.org/">Redux</a> 그리고 <a href="https://www.typescriptlang.org/">TypeScript</a>는 국내에서도 더이상 생소한 단어가 아니다. 이미 많은 회사와 서비스에서 해당 기술들을 사용하고 있고 활발하게 정보가 공유되고 있다. 이미 진부한 내용일 수도 있으나 실제 서비스 되고 있는 제품에 React + Redux + TypeScript 조합을 적용한 경험을 널리 공유하고자 이 포스팅을 작성하게 되었다.</p><p><em>* 이 글은 기본적인 TypeScript에 대한 배경 지식을 전제로 하고 있습니다.</em></p><h4>TypeScript 도입에 앞서</h4><p>아마 현업에서 TypeScript(이하 TS)가 사용된 상당수의 케이스는 프론트엔드 기술로 <a href="https://angular.io/">Angular</a>를 사용하는 경우가 아닐까 한다. Angular2 이후부터 TS를 권유하기 시작했으니 해당 언어를 실제 제품에 적용할 때는 Angular를 가장 먼저 떠올리게 된다. 하지만 현재 우리 팀의 주된 프론트엔드 기술은 React이었고, TS를 자연스럽게 적용할 수 있는지에 대한 의구심도 가졌다.</p><p>또한 자유분방한 JavaScript(이하 JS)를 만끽하던 팀원들이 가지는 타입 시스템에 대한 불신과 거부감 또한 TS를 적용하기에 큰 장벽으로 작용했다.</p><p>당시 우리 팀에서 가졌던 의문과 불안요소들을 정리해보았다.</p><ol><li><strong>정적 타입 시스템이 정말 필요한가? 상당수의 버그를 잡아준다고 하는데, 타입 시스템의 도입으로 잡을 수 있는 버그가 유의미한 수준인가?</strong></li><li><strong>React 생태계와 TS의 호환성 문제는 없는가?</strong></li><li><strong>코드가 장황(Verbose)해짐으로써 생산성의 저하가 발생하지 않는가?</strong></li><li><strong>기타 마이너한 기술적 우려와 심리적인 저항감(</strong><a href="https://www.microsoft.com"><strong>M$</strong></a><strong>)</strong></li></ol><p>이런 고민들이 있었지만 결과적으로 TS를 도입하게 되었고, 실제 제품에 적용하고 약 4개월이 지난 지금, 팀원들과의 대화를 통해 정리한 내용과 개인적인 소감을 버무려 사용 경험을 공유해보겠다.</p><h4>Happy and Safe Refactoring</h4><p>JS로 대규모 웹 어플리케이션을 개발할 때 종종 경험하는 어려움 중 하나는 바로 <strong>여러 모듈에 걸쳐있는 객체의 리팩토링 작업</strong>이다. 일반적인 타입-컴파일 언어와 달리 JS는 객체 속성의 이름은 변경하는 작업을 할 때 단순한 오타가 발생하더라도 런타임 환경에서만 발견할 수 있다. 개발 중에 테스트를 통해서 발견할 수 있다면 다행이지만, 프로덕션 레벨에서 발견되면 장애로 이어진다.</p><p>필자와 팀이 TS를 도입하고 크게만족하는 부분 중 하나가 리팩토링의 용이함이다. 사전에 정의된 객체의 인터페이스를 여러 모듈에 걸쳐서 빈틈없이 적용해두었다면, <strong>인터페이스 정의 한군데만 수정해도 해당 객체의 수정된 부분이 사용되는 모든 파일에서 경고를 띄워주고 컴파일도 되지 않는다</strong>.</p><p>특히<strong> Redux를 이용하여 어플리케이션의 상태관리를 할 경우 하부 State 객체들이 여러 React 컴포넌트에서 참조</strong>하게 되는데, 단순한 State 필드 이름 변경부터 실제 값의 타입을 변경하는 변경까지 TS의 도움으로 안전한 리팩토링을 진행할 수 있었다.</p><p>버그를 사전에 잡아준다는 캐치프레이즈에 부정적이었던 필자도 몇차례에 걸친 위와 같은 경험을 통해서, 다양한 상황에서 정적 타입 시스템이 빛을 발할 수 있음을 인정하게 되었다.</p><h4>훌륭한 도구</h4><p>JS는 언어의 특성상 개발 도구의 도움 받을 수 있는 영역이 제한적이다. C#의 Visual Studio 수준의 지원은 기대하기 어렵다. TS를 사용함으로써 얻을 수 있는 또 다른 큰 이점은 훌륭한 도구의 지원을 받을 수 있다는 점이다.</p><p>MS에서 개발한 언어인만큼 동 회사에서 개발하여 공개한 Visual Studio Code(이하 VS Code)와의 궁합이 매우 훌륭하다. 물론 C#과 Visual Studio 수준의 기능을 제공하지는 않지만, 타입 시스템을 비롯한 언어적 특성을 십분 활용한 VS Code의 기능은 생산성에 큰 도움을 준다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/852/1*V9YEbfH4BVYhsAV7cy2PJw.gif" /><figcaption>향상된 Intellisense</figcaption></figure><p>위 예시는 VS Code의 Intellisense가 특정 객체의 속성을 자동완성 시켜주고 해당 속성의 타입까지 알려주는 모습이다. 일반적인 JS의 자동완성과는 달리 파일 내에서만 지원하는 것이 아니라, 특정 객체의 타입(인터페이스)가 올바르게 정의되어있다면 정확한 자동완성의 지원을 받을 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/832/1*4YHxsbNcT5klqKIYVE86RQ.gif" /><figcaption><a href="https://code.visualstudio.com/docs/languages/typescript#_auto-imports">Auto Import</a></figcaption></figure><p>VS Code가 TS에 대응하여 제공하는 기능 중 하나인 Auto Import는 대규모 웹어플리케이션을 개발하면서 종종 경험하는 불편함 중 하나인 모듈 Import의 번거로움을 일거에 해결해준다. 특히 <strong>Redux를 이용한 어플리케이션에서는 Action을 중심으로 모듈 Import가 빈번하게 발생</strong>하는데, 이런 단순 작업의 로드를 상당 부분 줄여준다.</p><p>VS Code가 제공하는 많은 기능 중 일부를 예시로 들었으나, 이외에도 다양한 기능들을 제공하고 있으며 대부분의 기능을 추가적인 Extension 설치 없이도 사용할 수 있다는 간편함 또한 장점이다.</p><p>웹 프론트엔드 개발을 할 때, 언제나 목마름을 느꼈던 훌륭한 도구에 대한 니즈는 TS와 VS Code를 사용함으로써 상당 부분 해소되었다.</p><h4>기존 JS 생태계와의 호환성도 안정화 단계</h4><p>React를 비롯한 JS 기반 라이브러리들이 TS에 원활하게 돌아가느냐에 대한 우려도 있었으나, 수개월 동안 사용한 유수의 라이브러리들은 이미 호환성에 대한 이슈가 거의 존재하지 않았다.</p><p>JS 라이브러리를 TS에서 Import하여 사용하기 위해서는 해당 라이브러리의 타입이 정의된 모듈을 추가로 설치해줘야 한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/486/1*UDycpAils8wLmwSy8pYgEA.png" /></figure><p>특정 모듈에 타입 정의 패키지가 존재하는지는 이곳에서 확인이 가능하다.</p><p><a href="http://definitelytyped.org/">Home | DefinitelyTyped</a></p><p>필자가 처음 TS를 접했던 2016년에는 많은 라이브러리에 타입 정의 패키지가 존재하지 않아 타입 시스템의 도움을 받지 못했으나, 이제는 안정화 단계에 올라서있다고 단언할 수 있겠다.</p><p>그리고 React로 개발을 할때, 대부분 사람들이 활용하는 <strong>JSX 문법도 TS에서 훌륭하게 지원</strong>하고 있으므로, 이 부분에 대해서도 문제없다. 물론 타입 시스템을 적용한 React 컴포넌트나 Props 타입과 관련한 지식이 필요하나, <strong>기술적 장벽으로 작용할 수준은 전혀 아니다</strong>.</p><p><a href="https://www.typescriptlang.org/docs/handbook/jsx.html">JSX · TypeScript</a></p><h4>생산성과의 Trade-Off</h4><p>정적 타입 시스템을 적극적으로 활용할 경우, JS로 코드를 작성했을 때보다 다소 <strong>코드의 양이 늘어난다는 것은 부정할 수 없는 사실</strong>이다. 이로 인해서 생산성이 저하될 수도 있다는 팀내 우려도 있었다.</p><p>실제로 작성하는 코드의 양은 체감이 될 정도로 증가하였다. 하지만 그것으로 인해 생산성이 저하되었다고 단언하기는 힘들다. 위에서 언급한 다양한 기능들의 지원으로 <strong>단순 작업의 속도는 상당부분 개선</strong>되었으며, 오히려 불필요한 <strong>디버깅 시간을 절감</strong>함으로써, 코드 양 증가로 인한 <strong>생산성 저하가 상쇄</strong>되는 느낌이었다.</p><h4>다음 프로젝트도 TypeScript로…</h4><p>이상으로 현업에서 TS를 적용하면서 마주했던 우려와 실제로 사용하면서 느낀 점들을 정리해보았다. 상당 부분 간소화되어있으나, 이 포스팅을 통해서 TS 적용을 고민하는 팀/개인들이 의사결정을 함에 있어서 도움이 되기를 바라면서 글을 마무리하도록 하겠다.</p><p>개인적으로도 팀 전체로도 TS 적용은 성공적이었다고 느꼈으며, 특히 필자는 큰 이변이 없는 한 앞으로도 하게 될 프로젝트는 TS를 사용할 생각이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=caad266c8142" width="1" height="1"><hr><p><a href="https://medium.com/tapjoykorea/typescript-%ED%98%84%EC%97%85-%EC%A0%81%EC%9A%A9-%ED%9B%84%EA%B8%B0-caad266c8142">TypeScript 현업 적용 후기</a> was originally published in <a href="https://medium.com/tapjoykorea">Tapjoy Korea</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[GraphQL] Apollo 2.x + React + Redux 세팅]]></title>
            <link>https://medium.com/@sangboaklee/graphql-apollo-2-x-react-redux-%EC%84%B8%ED%8C%85-f0d36ef607cf?source=rss-ee2bc1ce72f7------2</link>
            <guid isPermaLink="false">https://medium.com/p/f0d36ef607cf</guid>
            <category><![CDATA[redux]]></category>
            <category><![CDATA[apollo-client]]></category>
            <category><![CDATA[graphql]]></category>
            <category><![CDATA[react]]></category>
            <category><![CDATA[리액트]]></category>
            <dc:creator><![CDATA[Sangboak Lee]]></dc:creator>
            <pubDate>Thu, 14 Dec 2017 14:45:45 GMT</pubDate>
            <atom:updated>2017-12-14T14:45:45.583Z</atom:updated>
            <content:encoded><![CDATA[<h4>React + Redux 앱에 Apollo 2.x 버젼 적용하기</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/400/1*2iQRjEG1CmOcpTacuxbPjA.png" /></figure><p>GraphQL의 대표적인 구현체 라이브러리인 Apollo client의 2.0 버젼이 릴리즈 되었다.</p><p><a href="https://dev-blog.apollodata.com/apollo-client-2-0-beyond-graphql-apis-888807b53afe">Apollo Client 2.0: Beyond GraphQL APIs</a></p><p>필자도 1.x 버젼을 사용해보지 않았기 때문에 실제로 어떤 점이 변경되었는지는 체감할 수 없다. 하지만 여러 변경사항 중에 React + Redux 앱과의 연동에 변화가 있으나 명확하게 정리된 문서가 미비하여 경험담을 공유하고자 한다.</p><h4>기존 버젼에서의 세팅</h4><p>2.0 버젼 이전의 Apollo Client는 내부적으로 Redux를 사용하고 있었기에 React-redux를 사용하는 앱에 연동할 때, 앱의 루트 파일에서 아래와 같이 &lt;ApolloProvider /&gt; 를 사용하면 됐다.</p><pre>return (<br>  &lt;ApolloProvider client={apolloClient} store={store}&gt;<br>    &lt;div&gt;<br>      ...<br>    &lt;/div&gt;<br>  &lt;/ApolloProvider&gt;<br>);</pre><h4>2.0 버젼에서의 세팅</h4><p>하지만 2.0 버젼에서는 Apollo Client가 내부적으로 Redux를 사용하지 않게 되었다. 이로 하여금 Apollo Client가 좀 더 유연해지고 Redux의 구조에 의존하지 않게 되었다고 한다. 다만 이로 인해서 &lt;ApolloProvider /&gt; 와 별도로 기존에 Redux 스토어를 위한 &lt;Provider /&gt; 를 다시금 사용해야한다.</p><pre>return (<br>  &lt;ApolloProvider client={apolloClient}&gt;<br>    &lt;Provider store={store}&gt;<br>      &lt;div&gt;<br>        ...<br>      &lt;/div&gt;<br>    &lt;/Provider&gt;<br>  &lt;/ApolloProvider&gt;<br>);</pre><h4>graphql 함수와 connect 함수의 순서</h4><p>react-apollo 라이브러리(react-redux와 유사한 용도)가 제공하는 graphql 함수는 Apollo Client의 기능을 담은 Higher Order Component(이하 HOC)를 반환한다. 이는 react-redux의 connect 함수와 거의 동일하며 사용방법도 유사하다. 훌륭한 공식 문서가 제공되고 있으므로 자세한 설명은 링크로 대체한다.</p><p><a href="https://www.apollographql.com/docs/react/basics/setup.html#graphql">Setup and options | Apollo Client</a></p><p>문제는 Redux와 병행해서 사용하며, GraphQL 서버로 쿼리를 보낼 때 Redux store의 데이터가 필요한 경우이다. 이런 상황은 graphql 함수와 connect 함수 간에 순서 의존성이 발생하는데 아래와 같이 사용하면 무리없이 Redux store의 데이터에 접근할 수 있다. (정확하게는 connect 를 통해 props로 심어진 Redux store의 데이터)</p><pre>const LIST_QUERY = gql`<br>  query List($id: ID!) {<br>    list(id: $id) {<br>      id<br>      title<br>    }<br>  }<br>`;</pre><pre>const withList = graphql(LIST_QUERY, {<br>  name: &#39;ListData&#39;,<br>  options: (props) =&gt; ({ // props에 접근 가능<br>    variables: { <br>      id: props.fooFromRedux.listId // redux store의 데이터 필요<br>    },<br>  }),<br>});</pre><pre>const ListPageWithData = withList(ListPage);<br>export default connect(mapStateToProps, mapDispatchToProps)(ListPageWithData);</pre><p>이번 포스팅에서는 실제로 Apollo Client 2.0을 앱에 적용하면서 발생한 문제와 이를 해결하는 실전적인 내용을 다루었다. 사실 공식 문서가 충분히 훌륭하여 가이드나 API 레퍼런스들은 포스팅에서 상세하게 다루진 않았고, 앞으로 관련된 포스팅을 하더라도 다루지 않을 생각이다.</p><p>앞으로는 Apollo Client를 실제로 프로젝트에 적용하며 마주치는 문제들과 이를 해결하며 배운 내용들을 TIL(Today I Learned)처럼 간단하게 포스팅을 작성해보도록 하겠다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f0d36ef607cf" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[React] 컴포넌트 테스트에 대한 생각]]></title>
            <link>https://medium.com/@sangboaklee/react-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%97%90-%EB%8C%80%ED%95%9C-%EC%83%9D%EA%B0%81-6ec4b234b8eb?source=rss-ee2bc1ce72f7------2</link>
            <guid isPermaLink="false">https://medium.com/p/6ec4b234b8eb</guid>
            <category><![CDATA[tdd]]></category>
            <category><![CDATA[리액트]]></category>
            <category><![CDATA[react]]></category>
            <dc:creator><![CDATA[Sangboak Lee]]></dc:creator>
            <pubDate>Wed, 22 Nov 2017 13:17:10 GMT</pubDate>
            <atom:updated>2017-11-22T13:17:10.827Z</atom:updated>
            <content:encoded><![CDATA[<h4>어떻게 React 컴포넌트를 테스트 해야하는가</h4><p>테스트 주도 개발이라는 패러다임이 낯설지 않은 2017년이지만, 자바스크립트 테스팅 씬은 여전히 정리되지 않은 모습이다. 그 이유를 생각해보자면, 짧은 시간에 많은 라이브러리와 프레임워크가 쏟아져나오고 있고 유독 DOM이라는 외적인 요소와의 인터랙션이 많기 때문이 아닌가 한다.</p><p>React를 다년간 사용하면서 컴포넌트에 대한 테스트를 어떻게 해야하는가에 대해서 많은 시행착오와 고민이 있었다. 최근에 그것에 대한 생각이 어느 정도 정리되었기에 내 생각을 공유하고자 이번 포스팅을 작성하게 되었다. 하지만 이 포스팅을 통해 필자가 전달하고자 하는바는 React에만 국한된 것은 아니다. 다른 프레임워크, 라이브러리, 어쩌면 다른 언어에도 적용될 수 있다고 생각한다.</p><p>React 컴포넌트의 테스트 코드를 작성하기에 앞서 컴포넌트의 책임에 대해서 생각해볼 필요가 있다. 내가 테스트하려는 코드의 주요한 책임이 무엇인지 파악하고, 그 책임에 좀 더 집중해서 테스트를 작성하는 것이 의미있는 테스트 코드를 작성하는 방법일 것이다.</p><p>그리고 만들어진 라이브러리를 사용하는 만큼 해당 라이브러리가 제공하는 인터페이스를 잘 파악하고 그에 맞는 테스트 코드를 작성할 필요가 있다.</p><h4>React 컴포넌트의 책임</h4><p>React는 렌더링 라이브러리이다. 그리고 React에서 제공하는 컴포넌트는 당연히 렌더링이 가장 중요한 요소이다.</p><p>그리고 렌더링(UI)과 관련해서 여러 범주의 구성물로 구성된다.</p><ol><li><strong>컴포넌트의 상태를 관리하는 부분</strong></li><li><strong>실질적인 산출물을 반환하는 </strong><strong>render() 메소드(Props 전달 포함)</strong></li><li><strong>컴포넌트의 생애주기에 관련된 메소드(componentDidMount 등)</strong></li><li><strong>이벤트를 핸들링하는 부분</strong></li><li><strong>자식 컴포넌트에게 넘겨주는 콜백 함수</strong></li></ol><p>위와 같은 주요한 역할을 하는 부분을 제외하고 개발자가 구현하는 메소드는 상기의 기능을 도와주는 역할이 대부분이며 해당 컴포넌트 안에서만 사용되는 (의미상) Private한 메소드가 될 것이다. 또한 상당수의 기능들이 React가 제공하는 인터페이스에 개발자가 해당 메소드들을 오버라이드하고, 실제로 해당 기능들의 작동은 React로 책임이 넘어가게 된다. 따라서 테스트 코드를 작성할 때도 해당 기능 자체와 관련된 부분은 React에 위임하고, 실제로 개발자가 오버라이드한 내용을 테스트하는 것이 초점을 맞추어야 한다.</p><p><em>우리는 </em><em>componentDidMount 생애주기 메소드가 </em><em>mount 된 후에 호출이 되었는지 테스트 할 필요가 없다. 그저 </em><em>mount 된 이후에 </em><em>componentDidMount 안에 작성된 로직이 제대로 동작하는지를 테스트해야 한다.</em></p><h4>예제 — 최종 결과물</h4><p>먼저 최종적으로 우리가 목표로 하는 컴포넌트를 살펴보도록 하자. 아래의 컴포넌트는 부모 컴포넌트로부터 data prop을 전달받으며, 자체적인 isActive state를 가지고 있다. 그리고 모종의 작업을 통해 변형된 데이터를 자식 컴포넌트에게 prop으로 전달해주거나 span 태그를 통해 직접 그려준다. 마지막으로 이 컴포넌트는 클릭 이벤트 핸들러를 가지고 있고 button 요소가 클릭되면 해당 이벤트 핸들러가 호출되게 된다.</p><p>React로 작업을 하다보면 굉장히 자주 접하게 되는 컴포넌트 패턴이다. Redux나 여타 라이브러리의 사용에 따라 다소 달라질 수는 있으나, 큰틀은 여기에서 변하지 않는다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/8bc2602d23ad5c17b852e8e8bfb6c66a/href">https://medium.com/media/8bc2602d23ad5c17b852e8e8bfb6c66a/href</a></iframe><h4>예제 — Test-first</h4><p>본 포스팅에선 해당 컴포넌트를 Test-first 방식으로 구현해나가는 모습을 재현해보도록 하겠다. 먼저 해당 컴포넌트를 실제 구현하기 전에 컴포넌트 테스트 파일의 기본을 작성하도록 하자.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ad2223895b2249d00fb98d7e7212dd7c/href">https://medium.com/media/ad2223895b2249d00fb98d7e7212dd7c/href</a></iframe><p>마찬가지로 최소한의 컴포넌트의 작성하여 예외를 방지하도록 한다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d3fc95c0570fc9b9e81c5c7aa14e3e0a/href">https://medium.com/media/d3fc95c0570fc9b9e81c5c7aa14e3e0a/href</a></iframe><p>해당 컴포넌트는 isActive 라는 state를 가지고 있으며 기본값은 false 임을 확인하는 테스트 코드를 작성한다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/0f36ff91c357e289cab61ba8e50d2480/href">https://medium.com/media/0f36ff91c357e289cab61ba8e50d2480/href</a></iframe><figure><img alt="" src="https://cdn-images-1.medium.com/max/617/1*e8ZDRvRCoWPuw4FCLCZoCw.png" /><figcaption>이렇게 실패한다.</figcaption></figure><p>이 테스트 케이스를 성공하게 만들기 위해 state를 추가하고 기본값을 부여한다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/0eda13e35f4d0e7f88820c4d4686bcff/href">https://medium.com/media/0eda13e35f4d0e7f88820c4d4686bcff/href</a></iframe><figure><img alt="" src="https://cdn-images-1.medium.com/max/272/1*ui6kpqLZAgkfpDcUZbQB4g.png" /><figcaption>It passed!</figcaption></figure><p>하나의 컴포넌트를 테스트할 때 어느 범주의 기능부터 테스트 할 것인가에 대해서는 정답이 없겠으나, 개인적으로는 컴포넌트의 기본 상태를 구현하는 것부터 시작하는 편이다.</p><p>그 다음 단계로 렌더링 결과를 Test-first 방법으로 구현해보도록 하자. render() 메소드가 그리는 산출물 중 하나를 골라 먼저 테스트 코드를 작성한다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/03b6734cdc2c1b3548e835e119268791/href">https://medium.com/media/03b6734cdc2c1b3548e835e119268791/href</a></iframe><p>테스트 코드가 얼핏 복잡해보이나 실제로는 간단한 테스트를 수행하고 있다. 순서대로 1)test-button 이라는 클래스를 가진 button 이 제대로 그려지는가, 2) 해당 요소에 FOO 라는 텍스트가 제대로 그려지는가, 3) 해당 요소에 클릭 이벤트가 발생하였을 경우, 컴포넌트의 isActive state가 적절하게 변경되는가. 그리고 테스트가 수행되면 아래와 같은 결과가 나타난다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/623/1*XrxBD8ZGno4ohqHwRD1vDg.png" /><figcaption>역시나 실패(Red)</figcaption></figure><p>그렇다면 위의 테스트 케이스를 통과시키기 위해 컴포넌트를 구현해보도록 하자.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/c44a322980afce605c6d84d909e5975f/href">https://medium.com/media/c44a322980afce605c6d84d909e5975f/href</a></iframe><figure><img alt="" src="https://cdn-images-1.medium.com/max/537/1*Ky2YBQRJ5iwAgaNwayv-vQ.png" /><figcaption>짠!(Green)</figcaption></figure><p>이런 방식으로 차근차근 테스트 코드를 작성하고 실제 컴포넌트를 구현해간다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/caa1aac2e97897584d00112b286ab4c4/href">https://medium.com/media/caa1aac2e97897584d00112b286ab4c4/href</a></iframe><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d8f4a81dc469ad7c083c3c2ffd6cb075/href">https://medium.com/media/d8f4a81dc469ad7c083c3c2ffd6cb075/href</a></iframe><figure><img alt="" src="https://cdn-images-1.medium.com/max/898/1*97MIqRP2oLE6NlzUkNrSIw.png" /></figure><p>이제 리팩토링 단계를 진행해야하는데 여기서 문제가 하나 발생한다. 예를 들어 render() 함수 안의 로직을 일부 추출하여 메소드를 하나 만드는 리팩토링을 수행했다고 가정해보자. 자바스크립트 뿐만 아니라 React도 명시적인 Private 함수 기능을 따로 제공하지 않는다. 추출된 함수도 테스트가 가능한 Public 함수인데 추가로 테스트 코드를 작성하고 테스트를 진행해야 하는가의 문제다.</p><h4>리팩토링을 통해 생성된 함수의 테스트</h4><p>필자는 초기에 컴포넌트를 테스트 할 때는 해당 컴포넌트에 구현되어 있는 모든 함수에 1:1로 테스트 코드를 작성하였다. 따라서 리팩토링 과정을 통해 추출된 함수도 테스트 코드를 작성한 셈이다. 문제는 이런 방식을 채택할 경우, 테스트 코드의 유연성을 크게 해치게 된다.</p><p>테스트 주도 개발을 실제로 현업에 적용하면서 경험하는 어려움 중에 하나는 소스 코드를 변경(함수 추출 등)할 때마다 테스트 코드를 수정하게 되는 현상인데, 이는 테스트 코드 관리의 비용을 급증시켜 결국 테스트 코드 작성을 미루게 만든다. 하지만 이러한 상황의 상당수는 인터페이스의 Public 메소드와 Private 메소드의 적절한 경계없이 무조건적으로 테스트 코드를 작성함으로써 발생하는 경우가 많았다.</p><blockquote>인터페이스 상에서 Public하게 공개되는 메소드는 안정적(Stable)이어야하고 Private한 메소드는 유연(Flexible)해야한다. Private 메소드에 하나하나 테스트 케이스를 작성하는 것은 유연성을 크게 저해하는 요인이다. Public 메소드를 충분히 테스트했다면 일부 로직을 추출해서 생성된 Private 메소드는 추가로 테스트를 작성하지 않고도 그 결과로 테스트에 포함(Cover)되어 있을 것이다.</blockquote><h4>공개(Public)/비공개(Private)의 명시적 구분이 없는 문제</h4><p>특히 React는(자바스크립트 자체도) 라이브러리 자체가 제공하는 인터페이스에서 따로 구분된 Private 메소드가 없기 때문에 컴포넌트의 내부에 추가한 모든 함수를 테스트하려 시도할 경우 사소한 리팩토링에도 수정이 필요한 무수히 많은 테스트 코드를 생산하게 될 가능성이 높다. 따라서 React 뿐만 아니라 자바스크립트 소스 코드의 테스트를 작성할 경우, 암묵적인 의미의 Public 함수와 Private 함수를 잘 구분할 필요가 있다.</p><p>물론 컴포넌트 자체에서 일부 렌더링 로직을 추출하여 또 다른 컴포넌트를 만들어 그것으로 기존 렌더링 로직을 대체한다면, 이것은 테스트 코드의 변경도 수반하는 리팩토링이라고 할 수 있겠다.</p><h4>예제 — 리팩토링</h4><p>위의 설명을 기반으로 리팩토링 작업을 진행해보자. 예제에서는 render() 함수에서 곱셈을 하는 로직과 제곱을 하는 로직을 각각의 메소드를 추출하도록 하겠다. 여기서 새로 생성될 함수의 테스트 코드를 작성하고 Red-Green-Refactor의 단계를 다시 밟아야 하는가? 필자는 그렇게 생각하지 않는다. 이제는 이미 작성된 render() 메소드의 테스트 케이스를 믿고 자신있게 render() 메소드를 리팩토링하여 새로운 (의미상) Private 함수를 두개 만들어보자.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/7539a9c08940f2eb6a5574e77fd0134c/href">https://medium.com/media/7539a9c08940f2eb6a5574e77fd0134c/href</a></iframe><p>테스트가 실패하는지 확인해보자.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/892/1*iYDrlx4KIr8hYVpexfoLDw.png" /><figcaption>리팩토링 중 발생한 실수를 잡아준다</figcaption></figure><p>테스트 결과 제곱을 수행하여 결과를 그려주는 기능의 테스트 케이스가 실패했다. 의도적으로 잘못된 리팩토링을 수행하였기 때문이다. 하지만 이 과정을 통해 우리가 기존에 의도했던 기능에 이상이 있는지 없는지 손쉽게 확인할 수 있고, 자신감을 가지고 리팩토링을 수행할 수 있다. 마지막으로 잘못된 부분을 수정하고 예제를 마무리 하도록 하자.</p><pre>Math.pow(data, 3) =====&gt; Math.pow(data, 2)</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/880/1*WfsWZ0H69DG0kb6N-un6XA.png" /><figcaption>All Green</figcaption></figure><h4>결론</h4><p>우리는 이번 포스팅을 통해서 어떻게 Test-first 방식으로 테스트 코드와 React 컴포넌트를 구현하는지에 대해서 알아보았다. 그리고 테스트 코드가 어떤식으로 어느 정도의 범위까지 작성되어야 하는지도 알아보았다.</p><p>테스트 코드는 높은 품질의 코드를 작성하기 위해 필요하다. 필자도 적극적으로 테스트 코드를 작성하고 있으며, 동료들에게 적극 권유하고 있다. 하지만 테스트 코드는 잘 작성되어있을때 비로소 가치를 가진다. 무분별하게 작성된, 커버리지를 위한, 자기 위안을 위한 테스트 코드는 오히려 관리의 비용만 증가시키고 적절한 효용을 얻을 수 없는 경우도 있다.</p><p>이 글을 읽고 많은 자바스크립트, React 개발자들이 좀 더 자연스럽고 의미있는 테스트 코드를 작성하기를 기원한다. 물론 테스트 코드 작성을 위한 테스트용 API 활용은 초반에는 익숙하지 않더라도 시간이 지날수록 숙련도가 올라가기 때문에 조바심을 낼 필요가 없다. 다만 그런 기술적인 측면보다 항상 제대로 된 테스트 코드를 작성하기 위해 고민하고 연습하는 습관이 중요하다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6ec4b234b8eb" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[리뷰] Clean Code]]></title>
            <link>https://medium.com/@sangboaklee/%EB%A6%AC%EB%B7%B0-clean-code-201d781d7aa6?source=rss-ee2bc1ce72f7------2</link>
            <guid isPermaLink="false">https://medium.com/p/201d781d7aa6</guid>
            <category><![CDATA[클린코드]]></category>
            <category><![CDATA[엉클밥]]></category>
            <category><![CDATA[리뷰]]></category>
            <category><![CDATA[clean-code]]></category>
            <dc:creator><![CDATA[Sangboak Lee]]></dc:creator>
            <pubDate>Sat, 09 Sep 2017 12:49:56 GMT</pubDate>
            <atom:updated>2017-12-01T14:31:10.812Z</atom:updated>
            <content:encoded><![CDATA[<p><em>&lt;클린 코드 — 애자일 소프트웨어 장인 정신&gt;</em>을 읽고</p><p>개발자들 사이에서 엉클 밥(Uncle Bob)으로 유명한 로버트 C. 마틴이 쓴 책 <em>&lt;클린 코드 — 애자일 소프트웨어 장인 정신&gt;</em>를 읽고 몇가지 느낀 점을 기록해둔다.</p><p>이 책은 어떻게 어떻게 깨끗하고 아름다운 코드를 작성할 것 인가에 대한 문제를 객체지향 프로그래밍(주로 자바) 관점을 중심으로 풀어나간다. 하지만 객체지향 프로그래밍이나 자바에 많이 익숙하지 않더라도 특정 부분을 제외하고는 큰 무리없이 읽을 수 있는 책이다. <strong>기본적인 프로그래밍 소양이 있는 개발자라면 부담없이 읽고, 비록 그것이 자바로 쓰여진 예시들일지라도 저자가 의도한 바를 파악하고 이해할 수 있으리라</strong> 생각한다.</p><p>저자가 책에서 전하는 깨끗한 코드(Clean Code)를 작성하는 방법은 좁게는 변수명이나 코딩 습관부터 넓게는 아키텍쳐 레벨까지 아우른다. 그는 세부적인 내용들에 들어가기 앞서서 그가 생각하는 깨끗한 코드는 무엇이며, 깨끗하지 못한 코드는 어떤 결과를 초래하고, 어떻게 깨끗한 코드를 작성할 것 인지에 대해 첫 번째 장을 할애한다. 그리고 나머지 장에서는 기술적인 부분을 다양한 측면에서 접근하고 저자가 생각하는 더 나은 방법은 독자에게 제안한다.</p><p>리뷰라고는 하지만 개인적으로 기록해두고 두고두고 살펴보고자 하는 목적으로 작성하는 포스팅인만큼, <strong>전체적인 내용보다는 일부 기억에 남는 부분들을 메모</strong>해두려고 한다.</p><h3>기억에 남는 부분</h3><h4>내가 작성한 코드는 항상 누군가가 읽는다는 점을 잊지 말 것</h4><p>깨끗한 코드 작성이 중요한 이유. 이 시대의 소프트웨어 개발은 혼자서 하는 작업이 아니다. <strong>팀원이나 미래의 본인</strong>이 코드를 읽었을 때, 이해가 잘 되는 코드를 작성할 의무가 있다. 스스로를 해커, 닌자라고 생각하며 마법같은 코드를 짜둘거라면 팀으로 일해서는 안된다.</p><h4>의도가 명확하게 드러나도록 이름을 지어라</h4><p>단순한 코드일지라도 변수나 함수의 이름을 지을 때 그것의 목적을 정확하게 드러낼 수 있는 이름을 지어야 한다. 비록 <strong>이름이 조금 길어지더라도 명확한 이름이 장기적으로 유익</strong>하다. 글을 읽는 것처럼 코드가 읽혀져야 코드 작성자의 의도를 조금이라도 빠르게 파악할 수 있다.</p><pre>// Bad<br>const cate = getCate()<br>const cateStr = form(cate)</pre><pre>// Good<br>const category = getCategoryFromJSON()<br>const formattedCategory = formatCategory(category)</pre><h4>함수의 인자로 Boolean값은 최대한 피하라</h4><p>종종 함수의 인자로 Boolean값을 받는 경우가 있는데, 이러한 형태도 최대한 피해야한다. 함수를 만든 사람은 <em>(어쩌면)</em>해당 플래그의 의미를 알 수도 있지만, 함수를 사용하는 입장에서는 함수를 호출 할 때마다 함수 정의를 재확인해야하는 비효율이 발생하게 된다.</p><pre>function checkFoo(bar, isBaz) {<br>  if (isBaz) {<br>    ...<br>  } else {<br>    ...<br>  }<br>}</pre><pre>// true값은 무엇을 의미?<br>const foo = checkFoo(bar, true)</pre><p>행여나 이런 함수가 이미 존재하며 리팩토링이 불가능한 상황이라면 다음과 같은 방법으로 함수를 사용할 때 Boolean값에 의미를 부여해주는 방법도 고려해보자.</p><pre>const isBaz = true<br>const foo = checkFoo(bar, isBaz)</pre><p>단순하지만 훗날 이 코드를 읽는 사람은 checkFoo 함수의 두 번째 인자가 어떤 의미인지(baz인지 아닌지 여부) 좀 더 쉽게 파악할 수 있다.</p><h4>의미불명의 숫자는 상수로 만들어라</h4><p>실제 업무에서 종종 실수를 범하는 부분이라 좀 더 기억에 남는 내용이다. 맥락에 익숙하지 않은 사람이 읽었을 때 <strong>의미를 파악하기 힘든 숫자를 상수</strong>로 만들어 사용하라는 조언이다.</p><pre>// Bad<br>cons totalWidth = (columnWidth * 10) + 20</pre><pre>// Good<br>const NUMBER_OF_COLUMNS = 10<br>const PADDING_WIDTH = 20</pre><pre>const totalWidth = (columnWidth * NUMBER_OF_COLUMNS) + PADDING_WIDTH</pre><p>무엇을 의미하는지 알 수 없었던 숫자에 의미가 부여되었다.</p><h4>주석 사용을 최소화하라</h4><p>주석과 관련된 내용만으로도 하나의 챕터를 할애하고 있으나, 요는 주석 사용을 최소화하라는 것이다. 주석으로 주저리주저리 부연설명을 하느니, 함수를 잘게 쪼개고 중간 변수를 선언하고 좋은 이름을 부여해서 <strong>코드 자체로 설명이 가능(Self-explanatory)하게 만들라</strong>는 조언이다.</p><h4>일관된 추상화 수준으로 함수를 쪼개라</h4><p>함수가 비대해지면 버그가 숨어들 위험이 발생하고 테스트가 어려워지는 등 여러가지 문제를 수반하기 때문에 함수는 잘게 쪼개야 한다는 얘기는 이미 진리처럼 여겨지고 있다.</p><p>다만 이 책에서는 한걸음 더 나아가 ‘어떻게&#39; 함수를 쪼갤 것 인가에 대해서도 다루고 있다. 그리고 그 중 하나가 함수를 분리함에 있어서 일관된 추상화 수준으로 분리하라는 것이다. 선뜻 이해가 되지 않는데 예를 들어서 정리해보자.</p><p>가령 ABC라는 일을 하는 함수가 있다고 하자. 그리고 그 함수는 A, B, C의 크게 세 단계로 하는 일을 분리할 수 있고, 각각의 하부 단계는 또 다른 작은 단위로 하는 일을 나눌 수 있다. 필자가 이해하기로 올바른 함수의 분리는 doABC 함수 안에서 doA, doB, doC 의 함수를 부르고 각각의 함수는 또 다시 하부 단계의 함수를 부르는 것이다.</p><pre>// 올바른 추상화 수준<br>function doABC() {<br>  doA()<br>  doB()<br>  doC()<br>}</pre><pre>function doA() {<br>  doBasicA()<br>  doAnotherA()<br>}</pre><pre>function doB() {<br>  doBasicB()<br>  doAnotherB()<br>}</pre><pre>function doC() {<br>  doBasicC()<br>  doAnotherC()<br>}</pre><p>만약 doABC 함수 안에서 혼재된 수준의 추상화가 적용되면 아래와 같을 것이다.</p><pre>// 일정하지 못한 추상화 수준<br>function doABC() {<br>  doA()<br>  doBasicB()<br>  doAnotherB()<br>  doC()<br>}</pre><pre>...</pre><p>이처럼 추상화 수준을 적절하게 유지하고 일관성있게 함수를 분리하는 방법을 통해서 코드의 가독성과 관리의 용이함을 끌어올릴 수 있다.</p><h4>테스트는 중요하다</h4><p>알고 있지만 항상 실천이 어려운 테스트. 그 중에서도 이제는 널리 알려진 테스트 주도 개발(Test-driven development)에 관한 좋은 조언이 많이 담겨있다. 실제로 최근 스프린트에서 다시 한번 적극적으로 TDD를 실천해보았고, 좋은 경험을 쌓을 수 있었다. 특히 책의 다른 내용과 어우러져 <strong>TDD의 중요성과 테스트 용이성에 대한 내용</strong>이 좀 더 와닿았다.</p><h4>코드가 돌아간다고 일을 끝내지마라</h4><p>모든 코드가 처음부터 완벽할 수 없다. 그러나 그것을 핑계로 그저 돌아가기만 하는 코드를 방치하고 다음 일로 넘어가는 것도 있을 수 없는 일이다. 테스트의 중요성과 함께 <strong>점진적으로 코드를 개선하는 행위</strong>의 중요성에 대해 언급되어 있다. 역시나 알고는 있지만 실천이 쉽지 않은 일. 두고두고 돌이켜보며 스스로를 감시해야겠다.</p><h4>내가 쓴 코드가 아니라고 지나치지 마라</h4><p>이런 내용을 책에서 직접적으로 언급했는지, 아니면 그저 책 내용에서 내가 유추하고 발전시킨 내용인지는 헷갈리지만 기록으로 남겨둔다.</p><p>위의 모든 내용들을 본인이 지금 작성하는 코드에만 적용해서는 역시 팀플레이어로써 아쉬움이 남는다. <strong>기존에 작성되어 있는 코드에 작업을 할 때도 간단하게 수정할 수 있는 부분들은 꾸준히 개선을 해주는게 장기적인 팀의 생산성</strong>에도 아주 좋은 영향을 준다. 다만, 기존 코드를 수정하는 경우 발생할 수 있는 문제에 대한 <strong>대비책으로 테스트 코드</strong>를 작성해두면 더욱 좋을 듯 하다.</p><h3>스스로를 돌아보는 기회</h3><p>소프트웨어 개발은 끊임없는 나태함과의 싸움이다. 대충대충, 빨리빨리 돌아가기만 하는 코드 작성의 유혹은 언제나 우리의 주변을 맴돈다. 실제로 업무를 진행함에 있어서 코드의 질을 포기하고 납기를 우선해야하는 경우도 있다. 이 부분은 비즈니스의 숙명이니 적절히 균형을 맞출 필요는 있다.</p><p>하지만 조금 돌아가더라도, 조금 시간이 더 걸리더라도 코드를 작성할 때 숙고해야 한다. 나쁜 짓을 하면 안된다는 진리와 같이 나뿐만 아니라 모든 개발자들이 알고 있는 사실이다. 하지만 나도 의욕이 넘칠 때는 열심히 진리를 추구하다가 간혹 나태함의 함정에 빠지는 우를 범하곤 한다.</p><p>적절한 시기에 이 책을 접하고 진지하게 고민하면서 많은 생각들을 정리해보았다. 책의 내용 모두가 절대 진리인 것은 아니고 시대의 흐름이 맞춰 취할 것은 취하고 버릴 것은 버려야겠지만 책이 말하고 있는 깨끗한 코드라는 개념에는 많은 부분 공감했다. 포스팅에 모두 담지 못했지만 그 고민들이 좋은 개발자가 되기 위한 자양분이 될 것이라 믿고, 두고두고 돌아보며 담금질 할 생각이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=201d781d7aa6" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[탭조이(Tapjoy) 오퍼월+ 프론트엔드 사용 기술]]></title>
            <link>https://medium.com/@sangboaklee/%ED%83%AD%EC%A1%B0%EC%9D%B4-tapjoy-%EC%98%A4%ED%8D%BC%EC%9B%94-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%8A%A4%ED%83%9D-1676e8f87cab?source=rss-ee2bc1ce72f7------2</link>
            <guid isPermaLink="false">https://medium.com/p/1676e8f87cab</guid>
            <category><![CDATA[기술스택]]></category>
            <category><![CDATA[리액트]]></category>
            <category><![CDATA[탭조이]]></category>
            <category><![CDATA[오퍼월]]></category>
            <category><![CDATA[프론트엔드]]></category>
            <dc:creator><![CDATA[Sangboak Lee]]></dc:creator>
            <pubDate>Tue, 29 Aug 2017 13:05:58 GMT</pubDate>
            <atom:updated>2017-12-01T14:32:26.969Z</atom:updated>
            <content:encoded><![CDATA[<h4>…과 그에 대한 단상…과 개인적인 관심사</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1019/1*md1Evs2_CsPFG57NFJu4vg.jpeg" /></figure><p>이번 포스팅에서는 별도의 포스팅에서 다루었던 탭조이(Tapjoy)의 주력 광고 상품 중 하나인 오퍼월 플러스(이하 오퍼월)의 프론트엔드 기술 스택에 대해 정리하고 일부 기술에 대한 개인적인 견해도 공유해보도록 하겠다.</p><p>현재 오퍼월은 자바스크립트 기반의 싱글 페이지 앱으로 구현되어 있다. 다양한 기술들이 사용되고 있지만, 굵직한 라이브러리들을 중심으로 정리하면 다음과 같다.</p><ul><li><strong>렌더링: </strong><a href="https://facebook.github.io/react/"><strong>React.js</strong></a></li><li><strong>상태 관리: </strong><a href="http://redux.js.org/"><strong>Redux</strong></a><strong>, </strong><a href="https://redux-saga.js.org/"><strong>Redux-Saga</strong></a><strong>, </strong><a href="https://github.com/reactjs/reselect"><strong>Reselect</strong></a></li><li><strong>유틸리티: </strong><a href="https://lodash.com/"><strong>Lodash</strong></a></li><li><strong>테스트: </strong><a href="https://karma-runner.github.io/1.0/index.html"><strong>Karma</strong></a><strong>, </strong><a href="https://mochajs.org/"><strong>Mocha</strong></a><strong>, </strong><a href="http://chaijs.com/"><strong>Chai</strong></a><strong>, </strong><a href="http://sinonjs.org/"><strong>Sinon</strong></a><strong>, </strong><a href="http://airbnb.io/enzyme/"><strong>Enzyme</strong></a></li><li><strong>번들/컴파일/린트: </strong><a href="https://webpack.js.org/"><strong>Webpack</strong></a><strong>, </strong><a href="https://babeljs.io/"><strong>Babel</strong></a><strong>, </strong><a href="https://eslint.org/"><strong>ESLint</strong></a></li></ul><p>이외에도 자잘한 목적에 맞게 사용하고 있는 라이브러리들이 더 있으나 큰 의미는 없는 듯 하여 포함시키지 않았다.</p><h3><strong>렌더링: </strong><a href="https://facebook.github.io/react/"><strong>React.js</strong></a></h3><p>React에 대해서는 더이상 무슨 말이 필요할까 싶다. 해외에선 수년 전부터 사용되어 왔고, 한국에서도 최근에는 보급율과 인지도가 급격하게 올라가고 있는 것이 체감 될 정도다.</p><p>나름 2년째 React를 사용하면서 개인적으로 느낀 점과 팀원들의 의견을 수렴해보면 다음과 같은 특징적인 요소가 있다.</p><h4>특정한 구조나 컨벤션을 강하게 강요하지 않음 (Unopinionated)</h4><p>이 특징은 개발자 개인적 성향에 따라서 호불호가 크게 갈릴 수 있는 부분이다. React는 잘 정리된 API는 제공하고 훌륭한 예시들을 어디서나 찾을 수 있지만, 엄격한 <strong>규칙으로 개발자를 제한하지는 않는다</strong>. 따라서 누구나 자유롭게 뷰(View)의 구조를 잡고 로직을 구현할 수 있는 장점이 있지만, 이러한 특성은 팀에서 사용할 때 양날의 검으로 작용하기도 한다.</p><p>여러 개발자가 제각각의 방식으로 코드를 작성할 경우, <strong>일관되지 못한 형태의 누더기같은 앱이 탄생할 가능성</strong>이 높다. 당연히 유지/보수와 가독성과 같인 생산성 측면에서 치명적으로 작용한다.</p><p>따라서 React를 사용하는 팀이라면 이러한 점을 염두에 두고, 좋은 예시를 많이 살펴보고 <strong>팀원과의 빈번한/깊이있는 토론을 통해서 팀에 맞는 규칙을 확립해 나갈 것을 제안</strong>한다.</p><h4>템플릿과 로직을 하나의 컴포넌트에서 관리 가능</h4><p>이 특징은 React가 처음 등장했을 때, 전통적인 개발자들에게 무수히 많은 공격을 받는 부분으로, “감히 HTML과 JavaScript”를 한 공간에서 혼용한다는 점은 React를 처음 접하는 개발자에겐 선뜻 받아들이기 어려울 수도 있다.</p><p>역시나 팀내에서도 다소 생소하다는 의견도 있었지만, 개인적으로는 코드의 가독성 측면에서 템플릿과 로직이 통합되어 있는 구조가 상당히 마음에 든다. 게다가 개발자가 조금 방심하면 개별 컴포넌트의 크기(줄 수)가 급격하게 커지는 경우도 있어서, 반강제적으로 깔끔한 코드를 쓰게끔하는 효과도 있다.</p><p>React 이후의 자바스크립트 프레임워크/렌더링 라이브러리는 여전히 <strong><em>분리주의</em></strong>와 <strong><em>통합주의</em></strong>가 공존하고 있으며, 앞으로도 계속 개발자의 선택의 문제로 남아있을 듯 하다. (유행은 언제나 돌고 돈다)</p><h4>디자인에 신경쓰면 구성 요소의 재사용 용이</h4><p>React가 워낙 디자인부터 재사용을 용이하게 하는 라이브러리라는 목표의식을 갖고 있었던 탓에, <strong>재사용 가능한 컴포넌트(Reusable component)는 일종의 React를 표현하는 상징</strong> 중의 하나가 되었다.</p><p>우리 팀도 항상 새로운 기능을 추가할 때는 새롭게 추가되는 컴포넌트 중 기존의 컴포넌트에서 재사용이 가능한 부분이 있는지 확인하고, 가능하다면 <strong>공통되는 부분을 추출하여 재사용 컴포넌트로 따로 관리</strong>하려고 노력한다. 이런 방법과 습관은 깨끗한 코드(Clean code)를 작성하려고 항상 노력하는 개발자라면 익숙할 것이라 크게 어려울 것은 없다. (<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">Don’t Repeat Yourself</a>)</p><p>다만 재사용을 고려할 때, 컴포넌트간에 주고받는 <strong>데이터의 형태나 흐름 등을 면밀히 따져보고 확장성</strong>이 있는 공용 컴포넌트를 작성하는게 중요하다. 그렇지 않으면 막상 재사용 컴포넌트를 만들어도 특정 부분에서밖에 재사용이 불가능한 사태가 발생하곤 하니 주의가 필요하다.</p><h4>Facebook에서 관리</h4><p>더이상 설명이 필요한가. 메이저 벤더에서 관리하는 프로젝트는 자체적으로도 <strong>관리가 잘될뿐만 아니라</strong>, 전세계 많은 개발자가 오픈소스로 참여하고 있어서 <strong>활발하게 커뮤니티가 운영</strong>된다. 개인 혹은 팀에서 선택한 라이브러리가 융성하지 못하고 수명을 다해버린 경험을 해본 사람이라면 이 특징의 소중함을 잘 알 수 있을 것이다.</p><h3><strong>상태 관리: </strong><a href="http://redux.js.org/"><strong>Redux</strong></a><strong>, </strong><a href="https://redux-saga.js.org/"><strong>Redux-Saga</strong></a><strong>, </strong><a href="https://github.com/reactjs/reselect"><strong>Reselect</strong></a></h3><p>팀에서 프론트엔드의 상태 관리를 위해서 Redux, Redux-Saga, Reselect를 사용하고 있다.</p><p>Redux는 앱의 여러 장소에서 상태가 관리되는 React의 문제를 해결하는 상태 저장소와 API를 제공하는 라이브러리이다. 이미 국내에서도 상당수의 스타트업을 중심으로 널리 사용되고 있는 것으로 보이며, <a href="https://mobx.js.org/getting-started.html">MobX</a>가 등장하기 전까지 <strong>React 커뮤니티의 사실상 표준</strong>과도 같이 사용되었다. MobX는 <a href="http://reactivex.io/rxjs/">RxJS</a> 등에서 사용되는 <a href="http://reactivex.io/documentation/ko/observable.html">Observable</a>을 활용한 상태 관리 라이브러리인데, 아직은 규모가 큰 앱에서의 활용도에 의구심이 있는 것으로 보이는 관계로 <strong>Redux는 앞으로도 한동안 그 지위를 유지할 것으로 판단</strong>된다.</p><p>Redux-Saga는 일반적으로 <strong>Redux에서 비동기 작업을 처리할 때 사용</strong>되던 Redux-thunk를 대체하는 라이브러리인데, 기존의 콜백 방식의 처리를 <strong>Es2015의 생성자(Generator) 함수를 활용</strong>한 좀 더 깔끔한 방식으로 처리하게끔 지원한다.</p><p>단순하게 콜백 지옥을 피할 수 있다는 장점뿐만 아니라, 비동기 작업을 동기 작업처럼 처리할 수 있게 도와주는 생성자 함수의 특성을 활용하여 비동기 작업의 테스트에도 많은 장점을 제공한다. 특히 Redux-Saga는 팀에서도 새롭게 도입한 기술로 여전히 많은 연구가 필요한 관계로 개인적으로도 공식 문서나 소스 코드를 살펴보며 공부를 계속하고 있다.</p><p>Reselect는 Redux를 사용해 상태를 하나의 저장소(Store)에서 관리할 때 발생할 수 있는 문제 중에 하나인 <strong>복잡하고 깊은 데이터 구조를 편리하게 사용</strong>할 수 있도록 도와주는 라이브러리이다.</p><p>이름처럼 Selector 함수를 조합하여 깊은(Nested) 데이터 구조에서 필요한 정보만 선택(Select)해서 사용할 수 있다. 뿐만 아니라 Selector 함수를 이용해서 필요한 정보를 뽑아낼 때, <strong>기존의 상태값을 기억(Memoize)</strong>해두어 값이 변하지 않았을 경우에는 <strong>재계산을 피해 성능 최적화</strong>를 꾀하는 똑똑한 라이브러리이다.</p><p>팀에서 사용하는 상태 관리와 관련된 기술들은 앱의 안정성에 직접적으로 영향을 미치는만큼 최대한 검증된 기술을 꾸준히 사용해야 한다고 생각한다. (개인적으로는 MobX를 토이 프로젝트로 실험해 볼 계획이다)</p><h3><strong>유틸리티: </strong><a href="https://lodash.com/"><strong>Lodash</strong></a></h3><p>Babel을 통해서 Es2015의 새로운 기능들이 손쉽게 사용가능해짐에 따라서 Lodash와 같은 자바스크립트 유틸리티 라이브러리의 활용도가 많이 떨어진 것이 사실이다.</p><p>하지만 여전히 Lodash는 여러 상황에서 유용하며, <strong>자바스크립트의 새로운 기능들로 완전히 대체할 수 없는 유틸리티 함수를 제공</strong>한다. 함수형 프로그래밍에서 일반적으로 사용되는 함수 역시 다수 제공하고 있어 골라서 사용하는 재미가 있다.</p><p>또한 <a href="https://github.com/lodash/babel-plugin-lodash">babel-plugin-lodash</a>, <a href="https://github.com/lodash/lodash-webpack-plugin">lodash-webpack-plugin</a> 등과 같은 플러그인을 통해서 더 가볍고 효율적으로 사용할 수 있기에 팀에서 꾸준히 사용되는 라이브러리이다.</p><h3><strong>테스트: </strong><a href="https://karma-runner.github.io/1.0/index.html"><strong>Karma</strong></a><strong>, </strong><a href="https://mochajs.org/"><strong>Mocha</strong></a><strong>, </strong><a href="http://chaijs.com/"><strong>Chai</strong></a><strong>, </strong><a href="http://sinonjs.org/"><strong>Sinon</strong></a><strong>, </strong><a href="http://airbnb.io/enzyme/"><strong>Enzyme</strong></a></h3><p>이 조합은 전통적으로 두루 사용되던 조합이긴 하나, React에 맞추어 개발되었다고 볼 수 있는 <a href="https://facebook.github.io/jest/">Jest</a>나 요즈음 인지도를 넓혀가는 <a href="https://github.com/avajs/ava">AVA</a> 등에 비하면 새로운 기술이라고는 할 수 없다.</p><p>하지만 전통적인 조합인만큼 <strong>훌륭한 커뮤니티가 형성</strong>되어 있고, 좋은 참고자료들을 손쉽게 구할 수 있다는 장점이 있다. 또한, 이미 성숙한 API를 최대한 활용하면 <strong>테스트 본연의 목적을 달성하는데 부족함이 없다</strong>. 그리고 오랜 시간 <strong>현업에서 증명된(Battle-proven) 조합</strong>이라는 점은 테스트라는 업무의 특성상 명백한 강점이라고 볼 수 있다.</p><p><a href="https://medium.com/@sangboaklee/react-%ED%85%8C%EC%8A%A4%ED%8C%85-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0-1c3719cee5af">[React] 테스팅 코드 작성하기</a></p><p>추후에 새롭게 시작하는 프로젝트에서는 테스트 프로세스를 병렬로 처리하는 AVA를 실험해보고 싶다. 만약 해당 프로젝트가 React를 사용하게 된다면 Jest도 고려해볼 수 있을 것 같다.</p><h3><strong>번들/컴파일/린트: </strong><a href="https://webpack.js.org/"><strong>Webpack</strong></a><strong>, </strong><a href="https://babeljs.io/"><strong>Babel</strong></a><strong>, </strong><a href="https://eslint.org/"><strong>ESLint</strong></a></h3><p>이 기술 또한 자바스크립트 개발자들에게는 전혀 새로운 기술이 아닐 것이다. 초반 프로젝트 세팅 단계에서 가장 손이 많이가고 신경써줘야 할 점이 많은 영역이지만, Webpack과 Babel은 자바스크립트 개발을 완전히 업그레이드 시켜준 위대한 발명이라고 생각한다.</p><p>Webpack을 사용함으로써 개발자는 좀 더 쉽게 파일을 분리하고 손쉽게 관리할 수 있게 되었고, Babel 덕분에 항상 새롭게 등장하는 ECMAScript의 기능들을 빨리 사용할 수 있게 되었다.</p><p>Webpack이 다른 많은 언어들이 기본적으로 제공하는 모듈링을 비로소 가능하게 해주었다는 점에서 <strong>자바스크립트의 단점을 보완</strong>했다면, Babel은 새로운 기능을 아주 빠르게 사용해볼 수 있게 <strong>확장성을 제공</strong>했다는 점에서 자바스크립트 자체의<strong> 장점을 더욱 강화</strong>시켰다고 볼 수 있다.</p><p>팀에서도 새로운 ECMAScript의 새로운 기능이 도입되면 팀원들과 공유하며 프로젝트 도입 여부를 결정하곤 한다. (최근에는 <a href="https://github.com/babel/babel/blob/7.0/packages/babel-plugin-transform-optional-chaining/README.md">Optional Chaining</a> 도입을 결정하고 Babel 업그레이드 작업을 진행하고 있다)</p><p>ESLint 자체는 일반적으로 사용되는 Lint 기능을 제공하는 라이브러리지만, 다양한 프리셋을 활용해서 다른 회사들의 규칙과 우리 팀이 정한 커스텀 규칙을 조합할 수 있어서 팀의 여러 프로젝트에서 계속해서 사용하고 있다.</p><h3>앞으로…</h3><p>이렇게 팀에서 사용하는 프론트엔드 기술들을 정리해보니, 자바스크립트 생태계는 참으로 빨리 변한다는 것이 실감이 난다. 작년까지만 해도 핫하던 기술들 중에 이미 폐기된 것들도 있고, 우리가 사용하는 기술 중에 일부는 굉장히 오래된 기술이 되기도 했다.</p><p>새로운 것을 다 체크하고 받아들여야 하는 것은 아니지만, 앞으로도 계속해서 눈과 귀를 열어놓고 자바스크립트 세상의 흐름을 파악하기 위해 부던히 노력해야 할 것 같다. 그래도 이렇게 새로운 기술들을 열린 마음으로 받아들이고 함께 고민하는 팀원들이 있고, 믿고 지원해주는 환경에서 일을 할 수 있어서 길을 잃을 걱정은 없다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1676e8f87cab" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[탭조이(Tapjoy) 오퍼월 개선하기]]></title>
            <link>https://medium.com/tapjoykorea/%ED%83%AD%EC%A1%B0%EC%9D%B4-tapjoy-%EC%98%A4%ED%8D%BC%EC%9B%94-%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0-b33652d7d908?source=rss-ee2bc1ce72f7------2</link>
            <guid isPermaLink="false">https://medium.com/p/b33652d7d908</guid>
            <dc:creator><![CDATA[Sangboak Lee]]></dc:creator>
            <pubDate>Fri, 25 Aug 2017 12:23:01 GMT</pubDate>
            <atom:updated>2017-08-25T12:23:01.722Z</atom:updated>
            <content:encoded><![CDATA[<h4>Rails, jQuery 그리고 React</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/930/1*nIt9ZZxJozsqXYYVvcLHuA.jpeg" /></figure><h4>오퍼월(Offerwall)</h4><p>오퍼월은 한 화면에 다양한 광고들을 보여주고 선택적으로 보상을 받을 수 있는, 어플리케이션에 탑재하는 모바일 광고의 전통적 제품의 한 형태이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/536/1*K9saMOZxFCkHHENlBhsKVA.png" /><figcaption>Tapjoy Offerwall (기존 제품)</figcaption></figure><p>탭조이도 모바일 광고업에 진출한 이래로 해당 제품을 운영해왔으며, 매출 역시 안정적으로 발생하여 당사의 주력 제품 중 하나라고 할 수 있다.</p><h4>문제점…</h4><p><strong>하지만</strong> 초창기부터 운영되어온 만큼 개발 생산성 측면과 UX 측면 모두에서 최적의 상태라고 할 수 없었다. 내외부적으로 해당 제품에 대한 문제점을 인식하고 있었으며 크게 아래와 같이 분류할 수 있다.</p><ol><li><strong>다년간 변하지 않은 낡은 느낌의 디자인 (UX 측면)</strong></li><li><strong>페이지를 이동할 때마다 화면을 새로받아 체감 속도가 느림 (UX 측면)</strong></li><li><strong>뷰를 담당하는 로직이 규모가 큰 서버에 담겨있어 기능 추가와 유지 보수가 어려움 (개발 측면)</strong></li></ol><p>사내에서는 이러한 문제의식을 기반으로 기존의 오퍼월 제품을 개선하는 프로젝트를 진행하였고, 그 중 <strong><em>프론트엔드 부분에 해당하는 내용</em></strong>을 이번 포스팅에서 공유하도록 하겠다.</p><p><em>*실제로는 뷰를 담당하는 부분 뿐만 아니라 모든 로직이 거대한 메인 서버에 위치하고 있어 개발 효율성을 크게 저하시키고 있었다. 백엔드 로직을 분리하는 작업 또한 사내에서 진행되고 있으며, 기회가 된다면 해당 내용도 추후에 다뤄보도록 하겠다.</em></p><h4>기존 제품과 그 구조</h4><p>아래는 기존의 당사 오퍼월 제품을 유저가 실제 사용할 때의 모습이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/187/1*aVLWEczesM2e-Q7YoXuD_A.gif" /><figcaption>올드한 스피너와 느린 체감속도</figcaption></figure><ol><li><strong>탭조이 SDK가 탑재된 앱에서 당사의 비즈니스 로직이 담겨있는 서버에 오퍼월 제품의 렌더링을 요청하면,</strong></li><li><strong>루비 온 레일즈로 만들어진 서버에서는 렌더링에 필요한 데이터를 통합한 후,</strong></li><li><strong>템플릿에 구성요소들을 그려서 유저에게 돌려주고,</strong></li><li><strong>그려진 오퍼월의 여러 광고들 중 하나를 선택할 경우,</strong></li><li><strong>다시 서버에 요청을 보내 새로운 페이지를 그려서 유저에게 반환한다.</strong></li></ol><p>이처럼 기존 오퍼월은 SDK의 웹뷰 위에 루비 온 레일즈를 통해서 화면을 그려주는 전통적인 웹앱의 구조를 가지고 있었으며, 기능 추가와 같은 변화들은 있었으나 이런 구조 자체는 몇년째 개선없이 사용되고 있었다.</p><p>이 제품을 개선하고자 해도 기타 당사의 비즈니스 로직을 상당부분 담고 있는 거대한 서버에서 작업을 해야하는 문제가 있어, 개발 생산성이 몹시 떨어지는 상태였다. 테스트와 배포에도 상당한 시간이 소요되며, 행여나 다른 부분에 영향을 줄 수 있다는 문제점은 개발 측면에서 큰 부담이었다.</p><h4>프론트엔드 분리와 SPA 구현</h4><p>이번 프로젝트에서 진행된 프론트엔드 부분의 가장 큰 변화는 뷰 관련 로직을 메인 서버에서 분리한 것이었다. 기존의 구현이 매 요청마다 서버에서 새로운 페이지를 그려주는 기존의 레일즈 스타일이었다면, 새로운 구현은 최초 요청 이후에는 SPA(Single Page Application)의 형태로 화면을 그려주게 된 것이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*rqBA5a-q2GfC6JLFegLz2g.png" /><figcaption>좌측: 기존 구조 / 우측: 새로운 구조</figcaption></figure><p>새로운 구조는 아래와 같은 순서를 가지게 된다.</p><ol><li><strong>유저가 최초의 요청을 서버로 보낸다.</strong></li><li><strong>화면을 그려주는데 필요한 HTML 템플릿을 AWS S3로부터 받아 필요한 정보를 삽입하여 HTML로 유저에게 돌려주면,</strong></li><li><strong>해당 HTML에 삽입되어 있는 AWS S3 위치를 기반으로 JS/CSS를 내려받아 화면을 그린다.</strong></li><li><strong>그 후의 데이터 요청은 화면 새로고침을 수반하지 않는 Ajax call로 진행</strong></li></ol><p>새로운 구조는 <strong>페이지를 이동할 때마다 화면을 새로받아 체감 속도가 느리다</strong>는 UX 측면의 문제점을 해결하였을 뿐만 아니라, <strong>뷰를 담당하는 로직이 규모가 큰 서버에 담겨있어 기능 추가와 유지 보수가 어렵다</strong>는 문제도 해결해주었다.</p><h4>별개의 저장소로 관리</h4><p>개발 생산성과 관련된 개선은 뷰(View)를 담당하는 로직을 별개의 프로젝트(Github 저장소)로 분리하여 관리할 수 있게 된 점을 들 수 있다. 기존에는 거대한 메인 서버에 직접 변화를 가해야했으나, 이제는 굉장히 가벼운 <strong>프론트엔드 관련 프로젝트만 수정하고 AWS S3로 배포하면 바로 프로덕션에 적용</strong>할 수 있게 되었다.</p><p>뿐만 아니라 새로운 버젼을 배포하기에 앞서 빌드된 HTML/JS/CSS만 간단하게 교체해가며 테스트 해볼 수 있도록 세팅하여 테스트 용이성도 크게 개선되었다.</p><h4>첫 번째 SPA (jQuery)</h4><p>그리고 위와 같은 구조적인 변화에 수반되어야할 작업은 자바스크립트로 SPA를 구현하는 것이었다. 이 프로젝트를 진행할 당시에도 팀이 담당하는 제품에 React를 사용하고 있었으나, <strong>빠른 프로토타이핑을 위해서 jQuery로 어플리케이션</strong>을 만들기로 결정하였다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/902/1*HeAGd0lT1WrQhkX1AWwNtw.png" /><figcaption>전형적인 jQuery를 활용한 SPA</figcaption></figure><p>jQuery로 만든 SPA는 ES2015의 클래스 문법을 활용하여 화면을 구성하는 요소별로 클래스를 선언하여 만들어졌다. 추후에 좀 더 구조화 된 라이브러리로 다시 구현하더라도 초반의 구현 속도를 위해 jQuery를 선택한 셈인데, 쉽게 예상할 수 있다시피 <strong>오래 지나지않아 문제에 봉착</strong>하게 되었다.</p><p>자체적으로 구조를 잡고 규칙에 맞춰서 컴포넌트를 작성하였으나, 기능이 많아지고 요소간에 주고받는 데이터의 양과 복잡도가 높아짐에 따라서 1)<strong>규칙 예외 상황</strong>이 늘어나고 부득이하게 2)<strong>글로벌 스코프를 오염</strong>시키는 빈도가 늘어나게 되었다. 또한 무분별하게 사용된 jQuery 이벤트로 인해서 오작동이 발생하거나 메모리 누수로 인한 3)<strong>성능 저하가 발생</strong>하곤 하였다.</p><h4>결국 React로</h4><p>jQuery로 구현한 SPA에서 발생한 여러 문제점을 해결하기 위해서 결국 <strong>React로 다시 한번 포팅</strong>하기로 결정하였다. 이 과정에서 React 뿐만 아니라 Vue.js와 Preact 등 여러 렌더링 라이브러리가 후보에 올랐으나, 기존 프로젝트에서 이미 상당기간 사용한 React가 최종 선정되었다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/186/1*4ECQD3vRLgp1DW0Qu6AvaA.gif" /><figcaption>새로운 오퍼월 플러스</figcaption></figure><p>새롭게 쓰여진 SPA은 <strong>React와 Redux 그리고 Redux-Saga의 조합</strong>으로 작성되었으며, jQuery로 만들어진 앱에서 발견되었던 여러 문제점들을 보완할 수 있었다.</p><p><em>*다만 구현해야 하는 기능의 복잡도에 비해서 라이브러리의 용량이 크고 초기 가동시간이 다소 걱정이 되었는데 이 문제는 포팅 후에 실제로 나타났으며, 그것을 팀에서 어떻게 해결했는지도 따로 포스팅 할 예정이다.</em></p><h3>프로젝트를 마치고</h3><p>탭조이의 주력 상품 중 하나인 오퍼월을 개선하는 작업은 제품의 매출 비중만큼이나 부담감이 컸고, 개발 생산성 측면 뿐만 아니라 유저의 경험까지 개선해야 하는 두가지 목표가 있었다.</p><p>결과적으로 해당 제품 로직의 대부분을 별개의 프로젝트로 분리하고 새로운 구조로 다시 작성함으로써 개발 생산성을 크게 개선시킬 수 있었고, 유저에게도 쾌적한 사용감과 리뉴얼 된 디자인을 제공할 수 있었다.</p><p>이런 노력들 덕분인지 실제로 파트너사(탭조이 SDK를 탑재한 앱을 개발하는 개발사)로부터 좋은 반응을 꾸준히 받고 있으며, 실제로 황혼기에 접어든 오퍼월이라는 제품을 다시 한번 끌어올리는데 성공하였다.</p><p><a href="http://blog.naver.com/tapjoykorea/220930217996">Tapjoy + 5Rocks : 네이버 블로그</a></p><p>개선 작업과 새로운 제품에 대해서 세세하게 다루지 못한 부분이 남아있지만, 그런 내용들은 추후에 기회가 되면 다른 포스팅으로 정리할 계획이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b33652d7d908" width="1" height="1"><hr><p><a href="https://medium.com/tapjoykorea/%ED%83%AD%EC%A1%B0%EC%9D%B4-tapjoy-%EC%98%A4%ED%8D%BC%EC%9B%94-%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0-b33652d7d908">탭조이(Tapjoy) 오퍼월 개선하기</a> was originally published in <a href="https://medium.com/tapjoykorea">Tapjoy Korea</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[React] PropTypes 활용하기]]></title>
            <link>https://medium.com/@sangboaklee/react-proptypes-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0-7a0615da236?source=rss-ee2bc1ce72f7------2</link>
            <guid isPermaLink="false">https://medium.com/p/7a0615da236</guid>
            <dc:creator><![CDATA[Sangboak Lee]]></dc:creator>
            <pubDate>Tue, 01 Aug 2017 12:11:35 GMT</pubDate>
            <atom:updated>2017-08-01T12:11:35.380Z</atom:updated>
            <content:encoded><![CDATA[<h4>PropTypes 활용하여 코드 퀄리티 개선하기</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*jDIj2SKAE-Bp32owLoHDjw.png" /></figure><p>이번 포스팅에서는 <a href="https://facebook.github.io/react/docs/typechecking-with-proptypes.html">React의 PropTypes</a>를 활용하여 코드 퀄리티를 개선한 경험에 대해 다뤄보도록 하겠다.</p><h4>들어가기에 앞서…</h4><p>대부분의 독자들께서 아시다시피 React는 굉장히 자유도가 높은 라이브러리이다. 일부 자바스크립트 프레임워크와 달리 특정한 코드 스타일과 문법을 강요하지 않는다.</p><p>이러한 특성때문에 일부 사용자들은 React를 팀에서 사용하게 되면 다양한 스타일과 컨벤션 상의 충돌이 발생하는 부분에 대해선 불만을 가질 수도 있으나, 그러한 문제는 팀원들 사이의 충분한 토론과 협의를 통해서 발전적인 방향으로 코드 퀄리티를 유지해나갈 수 있다는 점에서 오히려 장점으로 작용한다고 생각한다.</p><p>필자가 근무 중인 탭조이 LTV팀(과거 파이브락스)은 프론트엔드에 React를 사용하기 시작한 지 1년이 훌쩍 넘어가고 있다. 그동안 팀 내부적으로도 React를 잘 활용하는 방법에 대한 논의가 계속 되었고 PropTypes의 활용도 그 중 하나이다.</p><p>PropTypes에 대해 생소한 독자들을 위해 한 줄로 설명을 하면, <em>컴포넌트의 </em><em>props에 대해서 런타임 환경(개발 환경 only)에서 타입체크를 해주는 React의 내장된 기능</em>이다.</p><h3>초기의 PropTypes 활용</h3><p>팀에서 React을 도입한 초기의 PropTypes 활용은 굉장히 단순하였다. props의 종류와 포괄적인 타입만 선언하였으며, 따라서 개발 환경에서의 치명적인 버그를 잡는 것 이외에는 활용도가 낮을 수 밖에 없었다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/cd138bb6f619fd2a90a368df17afd198/href">https://medium.com/media/cd138bb6f619fd2a90a368df17afd198/href</a></iframe><p>위의 예시에서 config는 object 타입으로 선언이 되어있으나, 그 형태에 대해서는 아무런 정보가 없다. 예를 들어 비어있는 오브젝트가 넘어와도 PropTypes를 통해서는 잡아낼 수가 없다. 또한 팀내의 다른 개발자들이 위와 같은 PropTypes를 통해서 얻어 낼 수 있는 정보가 상당히 제한적이다.</p><h3>디테일한 PropTypes 선언</h3><p>가장 기본적인 PropTypes의 목적이 타입체크 기능이라면, 부수적인(그러나 매우 중요한) 기능은 코드의 가독성 개선과 Self-documentation이라는 결론을 팀내에서 내리고 디테일하게 PropTypes를 선언하는 방향으로 코드를 개선시켜 나갔다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9659ca1a179ce64bdebc3b4a70b19acc/href">https://medium.com/media/9659ca1a179ce64bdebc3b4a70b19acc/href</a></iframe><p>기존의 예시와 비교해보면 어떻게 PropTypes를 고도화 시켰는지 쉽게 비교가 가능하다. 단순하게 object 타입을 체크하던 부분은 해당 오브젝트의 형태와 각 프로퍼티의 타입까지 정의해주었고, 프로퍼티의 값이 오브젝트인 경우 동일한 방식으로 세밀하게 형태까지 정의해주었다. 또한 array 역시 엘리먼트의 타입을 정의해주었고, 단순 string 타입을 체크하던 currentChartType은 일부 프로그래밍 언어의 <a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/language-reference/keywords/enum">Enum</a> 타입과 유사한 형태로 타입을 정의하였다.</p><p>이러한 상세한 PropTypes 정의를 통해서 얻을 수 있었던 이점은 크게 두가지로 볼 수 있다.</p><ol><li><strong>컴포넌트 간에 주고 받는 </strong><strong>props를 좀 더 세밀하게 검사함으로써 버그를 사전에 발견</strong></li><li><strong>상세한 PropTypes 정의 자체만으로도 문서화의 효과(가독성 개선)</strong></li></ol><p>특히 2번, 문서화는 단순하게 해당 컴포넌트에 대한 가독성을 개선시켜 줄 뿐만 아니라, 어플리케이션 전체를 보았을 때 컴포넌트 간에 주고받는 정보들을 쉽게 파악할 수 있게 도와주는 효과도 있다는 점에서 큰 의미가 있다.</p><h3>Custom PropTypes 활용</h3><p>PropTypes는 기본으로 제공되는 타입 뿐만 아니라, 사용자가 직접 설정한 커스텀 타입까지 사용할 수 있도록 API를 제공하고 있다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/7c41fc349b99e04653999c3b1c436de6/href">https://medium.com/media/7c41fc349b99e04653999c3b1c436de6/href</a></iframe><p>실제로 팀에서 관리하는 코드베이스에 레거시로 Backbone Model, Collection를 사용하는 부분이 남아있었고, Backbone Model과 Collection을 커스텀 타입으로 정의하여 React에서 활용할 수 있도록 구현하기도 하였다.</p><h3>결론: 단순한 타입체크 기능이 아니다!</h3><p>타입 시스템은 원래 1)버그를 잡는 목적과 2)문서화와 가독성 개선이라는 목적이 공존한다고 필자는 생각한다. 다만 프로그래밍 언어 자체적으로 타입체크 기능을 제공하지 않는 자바스크립트를 주 언어로 사용하는 개발자분들은 React의 PropTypes를 단순하게 타입을 검사하는 용도로만 사용하는 경우도 있는 듯 하다. (필자도 마찬가지였음)</p><p>React에서 제공하는 PropTypes는 단순한 타입체크를 위해 존재하는 기능이라고 생각할 수 있으나, 어떻게 활용하느냐에 따라서 전체적인 코드의 품질을 개선할 수 있는 훌륭한 도구라고 생각한다.</p><p>특히 팀으로 일하고 서로 작업물을 공유하는 근래의 개발 문화에서는 항상 다른 개발자가 본인의 코드를 쉽게 이해하고 전체적인 생산성을 높이기 위해 노력해야한다.</p><p>그러한 트렌드를 고려할 때, 필자는 PropTypes 기능을 좀 더 공격적으로 활용해보는 것은 어떨지 제안해본다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7a0615da236" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[React] 테스팅 코드 작성하기]]></title>
            <link>https://medium.com/@sangboaklee/react-%ED%85%8C%EC%8A%A4%ED%8C%85-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0-1c3719cee5af?source=rss-ee2bc1ce72f7------2</link>
            <guid isPermaLink="false">https://medium.com/p/1c3719cee5af</guid>
            <category><![CDATA[react]]></category>
            <category><![CDATA[enzyme]]></category>
            <category><![CDATA[테스트]]></category>
            <category><![CDATA[tdd]]></category>
            <category><![CDATA[리액트]]></category>
            <dc:creator><![CDATA[Sangboak Lee]]></dc:creator>
            <pubDate>Thu, 27 Jul 2017 13:17:59 GMT</pubDate>
            <atom:updated>2017-12-01T14:33:23.720Z</atom:updated>
            <content:encoded><![CDATA[<h4>Enzyme을 활용하여 React 컴포넌트 테스팅 코드 작성하기</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/638/1*jYMwq2q_trqS3PKXulpfmg.jpeg" /></figure><p>이번 포스팅에서는 Airbnb에서 오픈소스화 한 React 테스팅 유틸리티인 <a href="https://github.com/airbnb/enzyme">Enzyme</a>을 활용하여 React 컴포넌트 테스팅 코드 작성하는 법을 알아보도록 하겠다.</p><blockquote>Enzyme is a JavaScript Testing utility for React that makes it easier to assert, manipulate, and traverse your React Components’ output.</blockquote><p>React는 자체적인 <a href="https://facebook.github.io/react/docs/test-utils.html">테스팅 유틸리티</a>를 제공하고 있으나, 공식 문서에서도 Airbnb의 Enzyme을 사용하도록 권장하고 있을 정도로 상당히 편리하고 직관적인 API를 제공하고 있다. 세부적인 API reference는 Enzyme 공식 문서를 통해서 확인할 수 있으니, 실제적으로 적용할 수 있는 예제 위주로 글을 풀어나갈 것이며 Mocha와 Chai에 대한 상세한 설명은 생략하도록 하겠다.</p><h3>Enzyme 세팅하기</h3><p>Enzyme은 기존의 테스트 환경에서 enzyme 모듈만 추가해주면 간단하게 설정이 가능하다.</p><pre>npm i --save-dev enzyme</pre><p>enzyme 모듈 설치 후 테스트 파일에서 필요한 API를 불러와 아래와 같이 컴포넌트 테스트에 활용할 수 있다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/a08925fa3a073666c8a59190e9ac8864/href">https://medium.com/media/a08925fa3a073666c8a59190e9ac8864/href</a></iframe><h3>렌더링 테스트하기</h3><p>Enzyme을 통해서(혹은 기본 제공되는 ReactTestUtils을 통해) 테스트하는 가장 기본적인 항목은 해당 컴포넌트가 의도한대로 내용물을 그려주느냐 하는 것이다. 좀 더 쉽게 설명하면 render() 메소드가 리턴하는 요소를 테스트하는 것이다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e16b8834a0d2ab19e7c0a6bae14c2460/href">https://medium.com/media/e16b8834a0d2ab19e7c0a6bae14c2460/href</a></iframe><p>만약 render() 메소드 안에 부모 컴포넌트에서 주어진 props에 따라 조건부로 엘리먼트를 그려줘야 한다면 다음과 같이 테스트 할 수 있다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/7b71fbd6963ebc894ec855a687e7d2b8/href">https://medium.com/media/7b71fbd6963ebc894ec855a687e7d2b8/href</a></iframe><p>div나 span 같은 DOM 엘리먼트 뿐만 아니라 동일한 React 컴포넌트 역시 같은 방법으로 테스트가 가능하다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/c1723cca682c79400f9bea50d9f604e0/href">https://medium.com/media/c1723cca682c79400f9bea50d9f604e0/href</a></iframe><h3>Method 테스트하기</h3><p>Webpack을 이용하여 ES2015의 클래스 문법을 사용하여 React 컴포넌트를 작성할 때, 비즈니스 로직을 포함한 메소드를 만드는 경우가 많다. 컴포넌트를 테스트할 때, 단순한 렌더링 테스트 뿐만 아니라 이러한 메소드 역시 테스트 해줄 필요가 있다. 메소드만 독립적으로 테스트 하는 방법은 크게 두가지가 있다.</p><h4>1. 프로토타입을 활용하는 방법</h4><p>아시다시피 ES2015의 클래스는 본질적으로 자바스크립트의 프로토타입 상속 체계를 기반으로 만들어진 <a href="http://web-front-end.tistory.com/26">Syntactic sugar</a>이다. 따라서 해당 클래스 안에 만들어진 메소드는 그 클래스의 프로토타입을 통해 접근하고 테스트 할 수 있다. 아래의 예시를 참고 하도록 하자.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/0fd0fe482a7790e15d648ca338eab486/href">https://medium.com/media/0fd0fe482a7790e15d648ca338eab486/href</a></iframe><p>다만 이 방법은 해당 메소드가 this 키워드로 컴포넌트의 state나 props에 접근하고자 할 때 의도한대로 동작을 하지 않는 문제가 있어 추천하지 않는다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/2973e3305a343dda4ff935934db2a67c/href">https://medium.com/media/2973e3305a343dda4ff935934db2a67c/href</a></iframe><p>Enzyme은 이러한 문제를 위해 해당 React 컴포넌트의 인스턴스로 접근하는 API를 제공하고 있다.</p><h4>2. Enzyme의 instance 메소드 활용하기</h4><p>컴포넌트의 메소드를 테스트하는 다른 방법으로는 Enzyme의 instance() API를 이용하는 것이다. shallow나 mount를 이용하여 ReactWrapper를 생성한 후에 instance() 메소드를 호출해줌으로써 해당 React 컴포넌트의 인스턴스에 접근할 수 있게 된다. 그 후에 해당 인스턴스의 메소드를 테스트하게 되면 this 키워드가 의도한대로 작동하게 되어 문제없이 테스트를 진행할 수 있다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/76dd3bf1c8bd242c7bbc42808af9f286/href">https://medium.com/media/76dd3bf1c8bd242c7bbc42808af9f286/href</a></iframe><h3>Lifecycle 테스트하기</h3><p>라이프사이클은 React로 어플리케이션을 만들 때, 빈번하게 사용되는 기능인데, 이것 역시 Enzyme으로 손쉽게 테스트 할 수 있다. 필자는 본 섹션의 예시 코드에서 특정 메소드의 호출 여부를 확인할 수 있도록 도와주는 <a href="http://sinonjs.org/">sinon.js</a>를 활용하도록 하겠다. 예를 들어 아래와 같은 컴포넌트가 있다고 가정하자.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/4aac0588bb7499d44afcd07c8c49c794/href">https://medium.com/media/4aac0588bb7499d44afcd07c8c49c794/href</a></iframe><p>componentDidMount hook에서 props로 주어진 callback 함수를 한번 호출하는 컴포넌트이다. callback 함수의 동작 자체는 따로 테스트를 하면 될 것이고, 여기서는 해당 컴포넌트가 마운트 된 후에 해당 함수가 호출이 되었는지를 테스트 할 필요가 있다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/6edc4af62534717fd6bbba7bd2c2586f/href">https://medium.com/media/6edc4af62534717fd6bbba7bd2c2586f/href</a></iframe><h4>mount vs. shallow</h4><p>그리고 위의 예시에서는 이전의 테스트 코드에서 사용하던 shallow API 대신에 mount를 사용하였는데, 두 API는 유사한 동작을 하나 mount가 좀 더 실제와 유사한 수준의 동작을 한다. 공식 문서에서는 테스트 해야할 컴포넌트가 DOM API와 인터랙션하거나 라이프사이클 훅을 모두 활용하는 경우에 mount API의 사용을 가이드하고 있다.</p><p>특히 라이프사이클 훅 호출 여부는mount API와 shallow API가 상이하므로 유의가 필요하다. 간단하게 정리하면 mount API는 모든 라이프사이클 훅이 호출되고 shallow API는 componentDidMount와 componentDidUpdate를 제외하고 라이프사이클 훅이 호출된다. 이러한 차이점에 유의하여 선별적으로 API를 사용하도록 하자.</p><h3>React 테스트하기…</h3><p>React는 Enzyme과 같은 유틸리티의 도움으로 컴포넌트 단위로 유닛 테스트가 상당히 용이하다. 비록 완벽한 브라우저 상의 테스트는 아닐지라도 이런 유틸리티 덕분에 렌더링과 주요 비즈니스 로직 등을 테스트하기에 부족함이 없기에 React로 만든 웹앱은 테스트가 상당히 용이한 편이다. (Angular 1.x의 테스트와 비교하면…) 상대적으로 적은 노력으로 큰 효과를 얻을 수 있다는 점이 많은 사람들로 하여금 React를 사용하게 만드는 한가지 이유라고 생각한다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1c3719cee5af" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>