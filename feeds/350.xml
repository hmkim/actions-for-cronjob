<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>알파카 낙서장</title>
  
  <subtitle>끄적</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://a1p4ca.netlify.com/"/>
  <updated>2018-11-10T13:29:11.576Z</updated>
  <id>https://a1p4ca.netlify.com/</id>
  
  <author>
    <name>a1p4ca</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mongoose의 올바른 사용 가이드 1 - Validator, Middleware 그리고 Query</title>
    <link href="https://a1p4ca.netlify.com/2018/09/10/Mongoose%EC%9D%98-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%82%AC%EC%9A%A9-%EA%B0%80%EC%9D%B4%EB%93%9C-1-Validator-Middleware-%EA%B7%B8%EB%A6%AC%EA%B3%A0-Query/"/>
    <id>https://a1p4ca.netlify.com/2018/09/10/Mongoose의-올바른-사용-가이드-1-Validator-Middleware-그리고-Query/</id>
    <published>2018-09-10T02:39:00.000Z</published>
    <updated>2018-11-10T13:29:11.576Z</updated>
    
    <content type="html"><![CDATA[<p>Mongoose에서 문서를 꼼꼼하게 읽지 않으면 저지를 수 있는 실수들을 저지르지 않기 위해 작성된 가이드입니다. Mongoose의 기초적인 사용법과 모델 등에 관해선 다루지 않습니다. 쿼리와 사용할 때 유용한 몇가지 옵션등도 소개하고 있습니다.</p><a id="more"></a><p>본 문서를 작성할 당시 Mongoose의 최신 버전은 5.2.13 이었습니다. 버전이 바뀜에 따라 API도 변경됐을 수 있으니 만약 오류가 있다면 제보해주세요.</p><img src="/2018/09/10/Mongoose의-올바른-사용-가이드-1-Validator-Middleware-그리고-Query/cover.jpg" title="Photo by Samuel Austin on Unsplash"><blockquote><p>Photo by Samuel Austin on Unsplash</p></blockquote><h1 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h1><p>쿼리를 실행(execute)하는 방법에는 두 가지가 있습니다.</p><ol><li>콜백 함수를 넘기기</li><li><code>.exec()</code>으로 <code>Promise</code>같이 쓰기</li></ol><p>쿼리 인스턴스의 함수 중 콜백을 넘기지 않았을 때 <code>Promise</code>를 반환하는(정확히는 <code>Promise-Like</code>) 함수는 <code>create()</code>, <code>save()</code>, <code>remove()</code>, <code>exec()</code> 등 일부고 그 외엔 모두 자기 자신(쿼리 인스턴스)를 다시 반환하기 때문에, 아래와 같은 구문은 옳지 않습니다. 쿼리 인스턴스에 대해 <code>await</code>를 쓰는 것은 말이 안되죠.</p><p>따라서 쿼리를 최종 실행시키려면 반드시 <code>.exec()</code> 함수를 쓰거나 쿼리의 마지막 매개변수로 콜백 함수를 넘겨줘야 합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="keyword">await</span> User.findOne(&#123; <span class="attr">name</span>: <span class="string">'a1p4ca'</span> &#125;) <span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">const</span> transactions = <span class="keyword">await</span> Transaction</span><br><span class="line">    .find(&#123; <span class="attr">user</span>: user._id &#125;)</span><br><span class="line">    .limit(<span class="number">5</span>).exec() <span class="comment">// Correct</span></span><br></pre></td></tr></table></figure><h1 id="Middleware와-Validators"><a href="#Middleware와-Validators" class="headerlink" title="Middleware와 Validators"></a>Middleware와 Validators</h1><h2 id="Validators"><a href="#Validators" class="headerlink" title="Validators"></a>Validators</h2><p>MongoDB에 입력한 데이터의 무결성을 보장합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    age: &#123;</span><br><span class="line">        type: <span class="built_in">Number</span>,</span><br><span class="line">        min: [<span class="number">13</span>, <span class="string">'Too young'</span>],</span><br><span class="line">        max: <span class="number">130</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Middlewares"><a href="#Middlewares" class="headerlink" title="Middlewares"></a>Middlewares</h2><p>미들웨어는 MongoDB에서 특정 작업(저장 등)이 실행되기 전/후에 실행되는 함수들입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">userSchema.pre(<span class="string">'save'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = capitalize(<span class="keyword">this</span>.firstName)</span><br><span class="line">    <span class="keyword">this</span>.lastName = capitalize(<span class="keyword">this</span>.lastName)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Validation과-Middleware을-우회하는-함수를-주의하세요"><a href="#Validation과-Middleware을-우회하는-함수를-주의하세요" class="headerlink" title="Validation과 Middleware을 우회하는 함수를 주의하세요"></a>Validation과 Middleware을 우회하는 함수를 주의하세요</h2><p>Middleware와 Validator가 호출되지 않는 경우가 있습니다. 이 경우 잘못된 데이터를 DB에 저장하려고 해도 모델을 검사하는 모든 작업을 우회하여 그대로 DB에 때려박을 것입니다.</p><p>위와 같은 일은 Mongoose가 ORM을 이용한 데이터 핸들링과 DB에 직접 데이터를 때려박는 두가지 기능을 모두 제공하기 때문에 발생합니다. <del>버그가 아니라 기능.</del> 문제는 이러한 ‘기능’이 문서에 명확하게 나와있지 않고, 단지 조그마한 각주로 예외에 대해서 설명하고 있을 뿐이라는 것입니다.</p><p>예시를 들어보겠습니다. <strong>만약 아래의 함수들 중 어느 하나를 특정 옵션 없이 그대로 사용하고 있다면 이미 위 문제를 겪고 있는 것이고, 따라서 해당 코드를 다시 작성해야 할 것입니다.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User.update()</span><br><span class="line">User.findOneAndUpdate()</span><br><span class="line">User.findByIdAndUpdate()</span><br><span class="line"></span><br><span class="line">User.remove()</span><br><span class="line">User.findOneAndRemove()</span><br><span class="line">User.findByIdAndRemove()</span><br></pre></td></tr></table></figure><h1 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h1><p>아래 예시들은 Create, Read, Update, Delete (CRUD) 쿼리들을 Validator와 미들웨어를 통과하도록 사용하는 적절한 방법을 제시합니다.</p><h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><p>아래 두 예제는 정확하게 같은 일을 합니다. <code>Model.create(doc)</code> 는 <code>new Model(doc).save()</code> 과 일치합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> User(&#123;</span><br><span class="line">    name: <span class="string">'Brian'</span></span><br><span class="line">&#125;).save()</span><br><span class="line"></span><br><span class="line">User.create(&#123;</span><br><span class="line">    name: <span class="string">'Brain'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h2><p>어떻게 사용하든 상관없습니다. 다만 주의해야 할 점은 <code>findOne()</code>와 <code>find()</code>는 서로 다른 미들웨어(각각 <code>findOne</code>과 <code>find</code>)를 호출합니다. 또한 <code>findById(id)</code>는 <code>findOne({ _id: id })</code>와 같습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> User.findOne(&#123;&#125;).exec()</span><br><span class="line"><span class="keyword">await</span> User.findById(&#123;&#125;).exec()</span><br></pre></td></tr></table></figure><h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><p>쿼리 요청 횟수를 줄이기 위해서는 <code>find()</code> ⇒ document modify ⇒ <code>save()</code> 의 과정보다 <code>where()</code> 을 활용하는 것이 더 효율적이겠습니다. 물론 Validator와 미들웨어도 잘 통과해야하구요. 그러나 <code>update()</code> 는 기본적으로 Validator는 실행하지 않습니다. 따라서 옵션으로 <code>runValidators</code>를 켜줘야 실수를 막을 수 있습니다. 아래 예제처럼요.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> User.where(&#123; <span class="attr">_id</span>: id &#125;)</span><br><span class="line">    .update(&#123; <span class="attr">name</span>: <span class="string">'Omega'</span> &#125;)</span><br><span class="line">    .setOptions(&#123; <span class="attr">runValidators</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    .exec()</span><br></pre></td></tr></table></figure><p><code>update()</code>에서 유용한 몇가지 옵션을 소개합니다. 괄호는 디폴트 값입니다.</p><ul><li><code>upsert</code> (<code>false</code>) : 만약 참이면 존재하지 않는 문서의 경우 새로 생성합니다.</li><li><code>multi</code> (<code>false</code>) : 만약 참이면 여러개의 문서를 업데이트합니다.</li><li><code>overwrite</code> (<code>false</code>) : HTTP에서 PUT과 PATCH의 차이로 보시면 됩니다. 만약 참이라면 기존의 문서를 전달한 객체로 교체하고(물론 _id 등은 제외), 거짓이면 전달받은 객체에서 명시한 필드의 값만 변경합니다.</li></ul><p>MongoDB에서 <code>findOneAndUpdate()</code>는 <code>findOne()</code>과 <code>update()</code> 쿼리의 조합이 아니라 별개의 쿼리로 실행됩니다. 그리고 Mongoose에서 <code>Query.findByIdAndUpdate()</code> 는 <code>Query.findOneAndUpdate({ _id: id }, ...)</code> 의 alias입니다(추가적으로<br> <code>Query.findById()</code> 역시 MongoDB의 자체 쿼리가 아닌 <code>Query.findOne({ _id: id })</code> 의 alias입니다). 따라서 두 쿼리를 호출하면 동일하게 <code>findOneAndUpdate</code> 훅이 발생합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UserSchema.pre(<span class="string">'findOneAndUpdate'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'called'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> User.findByIdAndUpdate(<span class="comment">/* ... */</span>)</span><br><span class="line">    .setOptions(&#123; <span class="attr">runValidators</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    .exec() <span class="comment">// called</span></span><br><span class="line"><span class="keyword">await</span> User.findOneAndUpdate(<span class="comment">/* ... */</span>)</span><br><span class="line">    .setOptions(&#123; <span class="attr">runValidators</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    .exec() <span class="comment">// called</span></span><br></pre></td></tr></table></figure><h2 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h2><p>삭제에서는 데이터 검증이 중요하지 않습니다. 하지만 미들웨어는 호출해야 할 수도 있습니다. 예를 들면, 어떤 도큐먼트가 삭제될 때 함께 정리되어야 하는 의존성이 존재하는 경우가 있을 수 있겠죠. 따라서 미들웨어 호출을 보장하기 위해선 아래와 같이 먼저 도큐먼트를 불러온 뒤 삭제해야 합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="keyword">await</span> User.findById(req.params.id).exec()</span><br><span class="line"><span class="keyword">await</span> user.remove()</span><br><span class="line">res.send(&#123; <span class="attr">data</span>: user &#125;)</span><br></pre></td></tr></table></figure><p>아래 중 <code>remove()</code>의 경우 <code>remove</code> 훅을 발생시키지 않습니다. 그러나 <code>findByIdAndRemove()</code> 와 <code>findOneAndRemove()</code> 을 호출하면 <code>findOneAndRemove</code> 훅이 발생합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 주의하세요</span></span><br><span class="line">User.remove()</span><br><span class="line">User.findByIdAndRemove()</span><br><span class="line">User.findOneAndRemove()</span><br></pre></td></tr></table></figure><h1 id="Clarify-Middleware-Behavior"><a href="#Clarify-Middleware-Behavior" class="headerlink" title="Clarify Middleware Behavior"></a>Clarify Middleware Behavior</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Mongoose 4.x 까지는 미들웨어의 호출 순서가 상식적이지 않았습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>)</span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema</span><br><span class="line"></span><br><span class="line">run().catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error.stack))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> mongoose.connect(<span class="string">'mongodb://localhost:27017/test'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123; <span class="attr">name</span>: <span class="built_in">String</span> &#125;)</span><br><span class="line">    schema.post(<span class="string">'save'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">doc, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'post save 1'</span>)</span><br><span class="line">    next()</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    schema.post(<span class="string">'save'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'post save 2'</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Person = mongoose.model(<span class="string">'Person'</span>, schema)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> Person(&#123; <span class="attr">name</span>: <span class="string">'Taco'</span> &#125;)</span><br><span class="line">    <span class="keyword">await</span> p.save()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'save promise resolved!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">post</span> <span class="keyword">save</span> 2</span><br><span class="line"><span class="keyword">post</span> <span class="keyword">save</span> 1</span><br></pre></td></tr></table></figure><p>예제를 보면 <code>post save 1</code> 을 출력하는 비동기 미들웨어가 먼저 등록되었기 때문에 <code>post save 2</code> 가 출력되기 전에 실행되었어야 하는데, 결과는 그렇지 않습니다. 약간 다른 예제를 보겠습니다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>)</span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema</span><br><span class="line"></span><br><span class="line">run().catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error.stack))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> mongoose.connect(<span class="string">'mongodb://localhost:27017/test'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123; <span class="attr">name</span>: <span class="built_in">String</span> &#125;)</span><br><span class="line">    schema.post(<span class="string">'findOne'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">doc, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'post find 1'</span>)</span><br><span class="line">    next()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    schema.post(<span class="string">'findOne'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'post find 2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Person = mongoose.model(<span class="string">'Person'</span>, schema)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> Person.findOne()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'find promise resolved!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">post <span class="builtin-name">find</span> 1</span><br><span class="line">post <span class="builtin-name">find</span> 2</span><br></pre></td></tr></table></figure><p>이전 예제와는 달리 예상했던 정상적인 출력 결과를 볼 수 있습니다. 왜냐하면 findOne 훅은 <a href="https://www.npmjs.com/package/kareem" target="_blank" rel="noopener">kareem</a>을 미들웨어 라이브러리로 사용하기 때문입니다. Mongoose 4.x에서 kareem을 사용하지 않는 <code>save</code>, <code>remove</code> 등<br> <a href="https://github.com/Automattic/mongoose/blob/4.x/lib/schema.js#L15-L27" target="_blank" rel="noopener">https://github.com/Automattic/mongoose/blob/4.x/lib/schema.js#L15-L27</a> 을 제외한 훅에 매개변수가 1개인 미들웨어를 등록할 경우에는 (<code>.post(&#39;save&#39;, doc ⇒ {})</code>) 이벤트를 등록하는 것으로(<code>.on(&#39;save&#39;, doc ⇒ {})</code>)  <a href="https://github.com/Automattic/mongoose/blob/4.x/lib/schema.js#L1179-L1183" target="_blank" rel="noopener">치환했으나</a>(이는 pre 훅도 비슷합니다) 매개변수가 2개인(<code>(doc, next)</code>) 비동기 미들웨어의 경우는 별도로 처리했기 때문입니다.</p><p>이런 문제를 버전 5에서는 거의 모든 훅을 kareem으로 처리해서 해결하게 됩니다. 따라서 모든 미들웨어들은 항상 등록된 순서대로 호출된다고 보장할 수 있죠. 덕분에 모든 미들웨어에 <code>async/await</code>함수를 사용할 수 있게 되었습니다. 아래는 그 예제입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">schema.pre(<span class="string">'save'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> something.async()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'saving..'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">schema.post(<span class="string">'save'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setInterval(<span class="function"><span class="params">()</span> =&gt;</span> resolve(), <span class="number">1000</span>))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'saved!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="‘this’-in-middleware"><a href="#‘this’-in-middleware" class="headerlink" title="‘this’ in middleware"></a>‘this’ in middleware</h2><p>Mongoose는 미들웨어에 <code>this</code>를 바인딩하여 유용하게 사용할 수 있습니다. 다만 미들웨어 함수에서 <code>this</code>는 해당 훅의 종류에 따라 다릅니다. 아래 표에 정리해두었습니다.</p><table><thead><tr><th style="text-align:center">this</th><th style="text-align:center">middleware</th></tr></thead><tbody><tr><td style="text-align:center">document</td><td style="text-align:center"><code>validate</code>, <code>save</code>, <code>remove</code>, <code>init(synchronous)</code></td></tr><tr><td style="text-align:center">query</td><td style="text-align:center"><code>count</code>, <code>find</code>, <code>findOne</code>, <code>findOneAndRemove</code>, <code>findOneAndUpdate</code>, <code>update</code>, <code>updateOne</code>, <code>updateMany</code></td></tr><tr><td style="text-align:center">aggregation object</td><td style="text-align:center"><code>aggregate</code></td></tr><tr><td style="text-align:center">model</td><td style="text-align:center"><code>insertMany</code></td></tr></tbody></table><h1 id="Type-of-Middlewares"><a href="#Type-of-Middlewares" class="headerlink" title="Type of Middlewares"></a>Type of Middlewares</h1><p>미들웨어 함수의 매개변수의 개수, 미들웨어가 <code>pre</code>인지 <code>post</code>인지에 따라 Mongoose가 미들웨어 함수에 전달하는 인자의 값도 많이 달라집니다.</p><h2 id="pre"><a href="#pre" class="headerlink" title="pre"></a>pre</h2><p><code>pre</code> 미들웨어는 쿼리(hooked method)가 실행되기 전에 모두 실행되는 함수들입니다.</p><p>Mongoose는 <code>pre</code> 훅을 Serial과 Parallel, 두가지 타입으로 설명합니다.  </p><p>Serial 미들웨어는 우리가 일반적으로 사용하는 훅인데요, 하나의 미들웨어가 끝나야 다음 미들웨어가 실행됩니다. <code>Promise</code>를 반환하는 미들웨어의 경우, resolve가 되어야만 다음 미들웨어를 실행하죠.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">schema.pre(<span class="string">'save'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do stuff</span></span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">schema.pre(<span class="string">'save,'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> somethingAsync()</span><br><span class="line">    <span class="keyword">await</span> coolStuff()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>여기서 주의할 점은, <code>next()</code>는 반드시 모든 비동기 작업을 마친 후 실행해야 한다는 것입니다. 다음 미들웨어를 호출하는 함수이기 때문에, 모든 미들웨어가 실행된 후에는 쿼리가 실행되기 때문이죠. 물론 쿼리가 실행되기 전까지 끝나지 않아도 문제가 없는 작업이라면 상관없습니다.</p><p>Parallel 미들웨어는 각 미들웨어에서 <code>done()</code> 함수가 호출되기 전까지는 쿼리를 실행하지 않습니다. 오랜 시간이 걸리는 비동기 작업을 하는 미들웨어들이 많을 경우 매우 유용한 옵션입니다. Parallel 미들웨어를 사용하기 위해서는 반드시 함수의 2번째 인자로 true를 주어야 합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">schema.pre(<span class="string">'save'</span>, <span class="literal">true</span>, <span class="function"><span class="keyword">function</span>(<span class="params">next, done</span>) </span>&#123;</span><br><span class="line">    next()</span><br><span class="line">    setTimeout(done, <span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">schema.pre(<span class="string">'save'</span>, <span class="literal">true</span>, <span class="function"><span class="keyword">function</span>(<span class="params">next, done</span>) </span>&#123;</span><br><span class="line">    next()</span><br><span class="line">    setTimeout(done, <span class="number">200</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>pre</code> 훅에서 에러가 발생하면, 그 이후에 예정되어 있던 미들웨어 함수들과 쿼리는 실행되지 않습니다.</p><h2 id="post"><a href="#post" class="headerlink" title="post"></a>post</h2><p><code>post</code> 훅은 모든 <code>pre</code>  훅의 미들웨어, 그리고 쿼리(hooked method)가 끝난 뒤에 발동합니다.</p><p>미들웨어 함수의 매개변수가 1개 혹은 2개인 경우, 첫 번째 매개변수는 해당 hooked method의 결과값을, 두 번째 매개변수는 다음 미들웨어를 호출하는 <code>next</code> 함수입니다. 매개변수가 2개인 경우 비동기 미들웨어로 인식하여 <code>next</code> 를 호출하기 전까진 다음 미들웨어가 실행되지 않습니다.</p><p>또한 <code>pre</code> 훅과 마찬가지로 <code>Promise</code>를 반환할 수도 있습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">schema.post(<span class="string">'save'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">doc, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(doc.name + <span class="string">'saved!'</span>)</span><br><span class="line">    setTimeout(next, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">schema.post(<span class="string">'save'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> somethingAsync()</span><br><span class="line">    <span class="keyword">await</span> somethingCool()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>미들웨어 함수의 매개변수가 3개라면 약간 다릅니다. 이 경우 Mongoose 에서는 Error Handling Middleware라고 특별하게 분류하는데, 첫번째 매개변수는 <code>error</code>, 그리고 두번째와 세번째는 각각 해당 hooked method의 결과값과 <code>next</code> 함수가 됩니다.  <strong>이 미들웨어 함수는 에러가 발생했을 때만 실행됩니다.</strong> 에러가 발생했을 때 로깅을 하거나 읽기 쉽게 출력하고 싶을 때 유용합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">schema.post(<span class="string">'save'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, doc, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error.name === <span class="string">'MongoError &amp;&amp; error.code === 11000) &#123;</span></span><br><span class="line"><span class="string">        next(new Error('</span>There was a duplicate key error<span class="string">'))</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">        next()</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><p>유의할 점은, <code>next()</code>에 에러를 전달하지 않았어도, 발생한 에러는 사라지지 않습니다. 이미 던져진 에러는 가던대로 흘러가죠.</p><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p><code>init</code> 훅은 조금 특별합니다. <code>init</code> 훅을 제외한 모든 훅들은 비동기 미들웨어를 지원합니다. 그러나 <code>init</code> 훅은 비동기 미들웨어를 허용하지 않습니다. 왜냐하면 <a href="https://mongoosejs.com/docs/api.html#document_Document-init" target="_blank" rel="noopener"><code>init()</code> 함수</a>가 동기이기 때문이죠.</p><p><code>Document.prototype.init()</code> 함수가 <code>init</code> 훅을 발생시키는데, 해당 함수는 네이티브 Mongo 드라이버가 반환한 오브젝트(document)를 Mongoose의 document 인스턴스로 변환하는 역할을 합니다. 따라서 미들웨어의 호출 시점도 <code>init</code>이 호출되기 전(pre)와 후(post)로 구분됩니다. 아래에 Mongoose 문서에 있는 예제를 붙여넣었습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123; <span class="attr">title</span>: <span class="built_in">String</span>, <span class="attr">loadedAt</span>: <span class="built_in">Date</span> &#125;);</span><br><span class="line"></span><br><span class="line">schema.pre(<span class="string">'init'</span>, pojo =&gt; &#123;</span><br><span class="line">    assert.equal(pojo.constructor.name, <span class="string">'Object'</span>); <span class="comment">// Plain object before init</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">schema.post(<span class="string">'init'</span>, doc =&gt; &#123;</span><br><span class="line">    assert.ok(doc <span class="keyword">instanceof</span> mongoose.Document); <span class="comment">// Mongoose doc after init</span></span><br><span class="line">    doc.loadedAt = now;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Test = db.model(<span class="string">'TestPostInitMiddleware'</span>, schema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Test.create(&#123; <span class="attr">title</span>: <span class="string">'Casino Royale'</span> &#125;).</span><br><span class="line">    then(<span class="function"><span class="params">doc</span> =&gt;</span> Test.findById(doc)).</span><br><span class="line">    then(<span class="function"><span class="params">doc</span> =&gt;</span> assert.equal(doc.loadedAt.valueOf(), now.valueOf()));</span><br></pre></td></tr></table></figure><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>중요한 것은 쿼리를 요청할 때는 항상 미들웨어와 Validator를 정상적으로 거치도록 적절한 옵션을 주어 사용해야한다는 것입니다. 또한 쿼리 요청은 비용이 크기 때문에 되도록이면 <code>findOneAndUpdate()</code>등 요청의 횟수를 줄이는 쿼리를 사용하거나 쿼리의 체이닝을 통한 최적화를 고려해야 합니다.</p><p>p.s - 원래 이 가이드의 시작은 <a href="https://twm.me/correct-way-to-use-mongoose/" target="_blank" rel="noopener">이 글</a>의 번역이었는데, Best Practice라고 하면서 잘못된 정보와 별로 좋지 않은 사용법만 알려주길래 초장만 번역하고 글의 거의 모든 부분을 새로 작성하였습니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mongoose에서 문서를 꼼꼼하게 읽지 않으면 저지를 수 있는 실수들을 저지르지 않기 위해 작성된 가이드입니다. Mongoose의 기초적인 사용법과 모델 등에 관해선 다루지 않습니다. 쿼리와 사용할 때 유용한 몇가지 옵션등도 소개하고 있습니다.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>블로그 시작합니다</title>
    <link href="https://a1p4ca.netlify.com/2018/09/09/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%8B%9C%EC%9E%91%ED%95%A9%EB%8B%88%EB%8B%A4/"/>
    <id>https://a1p4ca.netlify.com/2018/09/09/블로그-시작합니다/</id>
    <published>2018-09-09T08:29:19.000Z</published>
    <updated>2018-11-10T13:29:11.585Z</updated>
    
    <content type="html"><![CDATA[<p>개발자가 글을 쓰면 힙할 것 같아서 시작합니다.</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;개발자가 글을 쓰면 힙할 것 같아서 시작합니다.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
