<?xml version='1.0' encoding='UTF-8'?><?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?><feed xmlns='http://www.w3.org/2005/Atom' xmlns:openSearch='http://a9.com/-/spec/opensearchrss/1.0/' xmlns:blogger='http://schemas.google.com/blogger/2008' xmlns:georss='http://www.georss.org/georss' xmlns:gd="http://schemas.google.com/g/2005" xmlns:thr='http://purl.org/syndication/thread/1.0'><id>tag:blogger.com,1999:blog-667922483794864061</id><updated>2019-04-22T21:21:57.412-07:00</updated><category term="GAN"/><category term="adversarial learning"/><category term="minimax game"/><category term="mode collapse"/><category term="구조"/><category term="데이터분포"/><category term="적대적 학습"/><category term="확률분포"/><title type='text'>Learn.AI</title><subtitle type='html'></subtitle><link rel='http://schemas.google.com/g/2005#feed' type='application/atom+xml' href='http://dl-ai.blogspot.com/feeds/posts/default'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/667922483794864061/posts/default'/><link rel='alternate' type='text/html' href='http://dl-ai.blogspot.com/'/><link rel='hub' href='http://pubsubhubbub.appspot.com/'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><generator version='7.00' uri='http://www.blogger.com'>Blogger</generator><openSearch:totalResults>5</openSearch:totalResults><openSearch:startIndex>1</openSearch:startIndex><openSearch:itemsPerPage>25</openSearch:itemsPerPage><entry><id>tag:blogger.com,1999:blog-667922483794864061.post-335581696275001517</id><published>2017-08-19T20:58:00.002-07:00</published><updated>2017-08-19T20:58:27.672-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="GAN"/><category scheme="http://www.blogger.com/atom/ns#" term="mode collapse"/><title type='text'>[GAN] GAN이 풀어야 할 과제들</title><content type='html'>&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;지금까지 GAN의 원리를 살펴봤습니다. 작동 원리를 알고나니 GAN으로 무엇이든 만들어낼 수 있을&amp;nbsp;것 같은 생각이 듭니다. 하지만 세상에 완벽한 것은 없는 법. GAN에도 아직 해결해야 할 문제점들이 있습니다. 이제부터 그 문제점들을 살펴보겠습니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&lt;strong&gt;판별자 - 나를 믿지 말아요&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;앞에서 GAN은 패턴을 만들어내는 문제를 Minimax Game 으로 접근한다고 했습니다. 이미 설명했듯이 Minimax Game은 최악(최대 손실)의 상황에서 손실을 최소화하는 게임입니다. 그리고 GAN에서의 최악의 상황은 판별자가 진짜 데이터의 분포를 완벽히 학습한 상태입니다. 그러나 여기서 모순이 생깁니다. 학습을 마치기 전에는 완벽한 판별자를 얻을 수 없기때문에, GAN이 해결하는 문제가 Minimax Game 이라는 가정이 애초에 성립하지 않는 것이죠.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;GAN의 학습 과정에서 모델이 수렴하지 않거나 진동하는 이유 중의 하나가 바로 이것입니다. 판별자가 안정적으로 최적해로 수렴한다면 문제가 없지만, 그렇지 않을 경우 생성자도 최적의 해로 수렴하지 않는 것은 당연한 일입니다. 생성자를 지도하는 &#39;선생님&#39;의 역할을 하는 판별자의 능력이 떨어지면 생성자의 능력도 떨어질 수 밖에 없습니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;끝없는 숨바꼭질&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;GAN의 학습 과정에서 판별자와 생성자를 번갈아가며 학습시킨다고 설명했습니다.&amp;nbsp;이때문에 또 다른 문제가 발생할 수 있습니다. 특정 학습 이터레이션에서 판별자의 학습과 생성자의 학습이 서로를 상쇄할 수 있다는 말입니다. 이를 데이터 분포의 측면에서 그림으로 단순화하면 다음과 같습니다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-vgiN_5VQAM8/WZkIIcklDOI/AAAAAAAAAJo/cVjRqFYVUqIQiCW7fa4sOxqlt1eLaxyMwCEwYBhgL/s1600/12.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;421&quot; data-original-width=&quot;857&quot; height=&quot;196&quot; src=&quot;https://1.bp.blogspot.com/-vgiN_5VQAM8/WZkIIcklDOI/AAAAAAAAAJo/cVjRqFYVUqIQiCW7fa4sOxqlt1eLaxyMwCEwYBhgL/s400/12.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;이처럼 판별자와 생성자가 서로를 속고 속이며 제자리를 맴돈다면 양쪽 모두 전역해로 수렴할 수 없게 됩니다. 이런 상황을 일컬어 모델이 진동(oscillation)한다고 합니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;Mode collapsing - 나는&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;한 놈만 팬다&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;위에서 설명한 문제점들이 얽히고 설켜서 나타나는 대표적인 현상이 바로 mode collapsing 입니다. 특히나 학습 데이터의 분포가 multi-modal 한 경우에 그러한 현상이 두드러질 수 있습니다. 실제로&amp;nbsp;많은 데이터가 multi-modal 이기에 문제가 되는 것입니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;mode collapsing이 무엇인지 이해하려면, 우선&amp;nbsp;mode 가 무엇인지 이해해야 합니다. 통계를 조금이라도 공부한 분은 알겠지만, 통계학에서 mode는 최빈값, 즉 가장 빈도가 높은 값을 말합니다. 지금까지 다뤄온 데이터의 확률밀도함수에서는 색이 가장 진한 부분, 즉 밀도가 가장 높은 부분을 말합니다. 확률밀도함수를 등고선에 비유하자면 mode는 산봉우리 부분에 해당한다고 할 수 있습니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;그렇다면 multi-modal 분포란 무엇일까요? 말그대로 mode가 여러개 존재한다는 말입니다. 손으로 쓴 숫자 이미지(MNIST)를 예로 들면, 각각의 숫자 10개가 mode에 해당할 것입니다. 설명을 쉽게하기 위해 0~3까지 네개의 숫자만 존재한다고 가정합시다. X,&amp;nbsp;Y를 임의의 특징 벡터라고 한다면 MNIST 데이터의 분포는 아래와 같이 나타낼 수 있습니다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-9-HiLIYvhqk/WZkIIVsr7_I/AAAAAAAAAJg/MQjFnSs80kwNF6dvqvByjBuNMHVf4wYYACEwYBhgL/s1600/13.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;317&quot; data-original-width=&quot;422&quot; height=&quot;300&quot; src=&quot;https://1.bp.blogspot.com/-9-HiLIYvhqk/WZkIIVsr7_I/AAAAAAAAAJg/MQjFnSs80kwNF6dvqvByjBuNMHVf4wYYACEwYBhgL/s400/13.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;설명한대로 mode가 여러개인 분포입니다. 문제는 생성자가 주어진 입력을 네개의 mode 중 하나로만 치우쳐서 변환시킬 때 벌어집니다. 말그대로 mode의 충돌, mode collapsing이 발생한 것입니다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-oDCR5UnEIl4/WZkIId-rYCI/AAAAAAAAAJk/PoLvou4JLNIxn5U-OmPFZ_heyxVQGbMNQCEwYBhgL/s1600/14.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;427&quot; data-original-width=&quot;925&quot; height=&quot;183&quot; src=&quot;https://1.bp.blogspot.com/-oDCR5UnEIl4/WZkIId-rYCI/AAAAAAAAAJk/PoLvou4JLNIxn5U-OmPFZ_heyxVQGbMNQCEwYBhgL/s400/14.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;실제로 MNIST 데이터세트를&amp;nbsp;이용하여 GAN을 학습시키다 보면 같은 숫자만 계속해서 생성되는 현상을 볼 수 있는데, 이것이 바로 mode collapsing이 발생한 것입니다. 생성자 입장에서는 어떤 숫자를 만들든 판별자만 속이면 되기때문에 게임의 목적은 달성했다고 말할&amp;nbsp;수 있고, 판별자 입장에서도 잘못된 판단이라고 말할 수 없습니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;이러한 현상은 위에서 언급했듯이 판별자가 완벽하지 못하거나, 모델이 진동할 때, 혹은 두가지 문제점이 동시에 발생하는 경우 심하게 나타납니다. 생성자가 &#39;0&#39;만 계속 생성하다가 판별자가 진동하면서 &#39;1&#39;의 분포로 이동하면, 생성자는 다시 &#39;1&#39;만 계속해서 생성합니다. 그리고 이러한 악순환이 다른 숫자들에 대해서 반복되는 것이죠. 결과적으로 생성자가 학습 데이터 전체의 분포를 학습하지 못하고 그 중 일부분만 배우게 되는 것입니다. 아래 그림에서 그 예를 볼 수 있습니다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-Y88Bj3R0bl0/WZkIJG3_DRI/AAAAAAAAAJs/Bo33QoRrIZcv3y2aSNctqsjUCmBiSjWagCEwYBhgL/s1600/15.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;367&quot; data-original-width=&quot;826&quot; height=&quot;177&quot; src=&quot;https://3.bp.blogspot.com/-Y88Bj3R0bl0/WZkIJG3_DRI/AAAAAAAAAJs/Bo33QoRrIZcv3y2aSNctqsjUCmBiSjWagCEwYBhgL/s400/15.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;결국 생성자와 판별자 사이의 능력에 적절한 균형을 이루면서, 두 네트워크가 안정적으로 전역해로 수렴하도록 만드는 것이 GAN이 해결해야 할 숙제입니다. 이미 이를 해결하기 위해 많은 모델이 제안되었습니다. 이러한 모델들에 대해서는 앞으로 차차 살펴보도록 하겠습니다.&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://dl-ai.blogspot.com/feeds/335581696275001517/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://dl-ai.blogspot.com/2017/08/gan-problems.html#comment-form' title='3개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/667922483794864061/posts/default/335581696275001517'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/667922483794864061/posts/default/335581696275001517'/><link rel='alternate' type='text/html' href='http://dl-ai.blogspot.com/2017/08/gan-problems.html' title='[GAN] GAN이 풀어야 할 과제들'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://1.bp.blogspot.com/-vgiN_5VQAM8/WZkIIcklDOI/AAAAAAAAAJo/cVjRqFYVUqIQiCW7fa4sOxqlt1eLaxyMwCEwYBhgL/s72-c/12.png" height="72" width="72"/><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-667922483794864061.post-7489869826078681200</id><published>2017-08-19T20:52:00.001-07:00</published><updated>2017-08-19T21:05:49.894-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="GAN"/><category scheme="http://www.blogger.com/atom/ns#" term="데이터분포"/><category scheme="http://www.blogger.com/atom/ns#" term="확률분포"/><title type='text'>[GAN]  GAN과 확률분포 - 평범한게 좋아!</title><content type='html'>&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;GAN 관련 논문을&amp;nbsp;보면 &#39;데이터의 확률분포&#39;를 근사(approximate)한다는 말이 나오는데, 선뜻 이해가 되질 않습니다. 사람의 얼굴을 예로 든다면 &#39;사람 얼굴의 확률분포&#39;는 도대체 무슨 의미일까요? 이제부터 GAN의 관점에서 데이터의 확률분포란 무엇인지 살펴보겠습니다.&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&lt;strong&gt;확률분포&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp; GAN에서의 확률분포를 이해하려면,&amp;nbsp;&#39;확률분포&#39;라는 말의 의미를 먼저 이해해야 합니다. 이제 확률분포라는 개념부터 차근차근 짚고 넘어가도록 하겠습니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;우리가 흔히 생각하는 확률은 어떤 일이 일어날 가능성을 말합니다. 확률분포란 어떤 확률변수 X와 X에 대응하는 확률의 쌍이라고 생각할 수 있습니다. 가장 쉬운 예로 주사위를 던지는 일을 생각해봅시다. 여기서의 확률 변수 X는 주사위를 던져서 나오는 수이고, 가능한 수는&amp;nbsp;1, 2, 3, 4, 5, 6 입니다. 그리고 각 수마다 해당 수가 나올 확률이 존재합니다. 모두가 알다시피 그 확률은 1/6 로 동일합니다. 이를 좌표계의 형태로 나타내면 아래 그림과 같습니다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-YvVgB0q6LPQ/WZkGOsLq-VI/AAAAAAAAAJE/faQT4dR2MQUMePPAMs5nNJPDDyhcdKn-QCLcBGAs/s1600/7.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;433&quot; data-original-width=&quot;663&quot; height=&quot;260&quot; src=&quot;https://1.bp.blogspot.com/-YvVgB0q6LPQ/WZkGOsLq-VI/AAAAAAAAAJE/faQT4dR2MQUMePPAMs5nNJPDDyhcdKn-QCLcBGAs/s400/7.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;즉, 확률변수 X가 가질 수 있는 값마다 대응하는 확률이 존재합니다. 이처럼 확률변수 X가 셀수 있는 값일때, X의 확률 분포 P(X)를 &#39;이산확률분포&#39;라고 합니다. 주사위 눈금의 수는 말그대로&amp;nbsp;&quot;1, 2, 3, 4, 5, 6&quot;이라고 셀 수 있고, 각각에 대한 확률도 명확히 말할 수 있습니다. 1/6 이라고 말이죠.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;반면에 확률변수 X가 셀수 없는 값이라면 어떨까요? 서울의 연평균 강수량을 예로 들어 봅시다. 강수량이라는 확률변수는 0이상의 실수(real number)로 정의할 수 있습니다. 즉, 셀수 없다는 말입니다. 0과 1 사이의 모든 숫자를 하나씩 셀 수 있을까요? 0.1 간격으로 나누어 세면 되지 않을까요? 하지만 똑같은 문제가 발생합니다. 0과 0.1 사이에도 무한히 많은 실수가 존재하기 때문입니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;강수량이라는 확률변수 X를 셀 수 없을 뿐 아니라, 확률변수 각각에 대한 확률도 명확히 정의하기 어렵습니다. 어떤 해의 강수량이 정확히 125.4533242 일 확률은 얼마일까요? 그저 &#39;0에 가깝다&#39;고 대답할 수 밖에 없습니다. 이처럼 확률변수 X가 셀 수 없는 연속적인 값일 경우의 확률분포를 특별히 &#39;확률밀도함수&#39;라고 합니다. 특정 확률변수 X에 대한 확률을 명확히 정의하기 어렵기 때문에 &#39;밀도&#39;라는 개념을 채용하는 것입니다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-mT7MQri6QfM/WZkGeWE0gAI/AAAAAAAAAJI/y14IXY61tesz4b_DYYDRBYDMPXY9zUd3gCLcBGAs/s1600/8.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;426&quot; data-original-width=&quot;663&quot; height=&quot;256&quot; src=&quot;https://1.bp.blogspot.com/-mT7MQri6QfM/WZkGeWE0gAI/AAAAAAAAAJI/y14IXY61tesz4b_DYYDRBYDMPXY9zUd3gCLcBGAs/s400/8.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;말이 길어졌지만 요점을 정리하면 이렇습니다. 확률분포란 임의의 확률변수 X와 그에 해당하는 확률의 쌍을 말하는 것으로 P(X)라고 표기할 수 있습니다. 즉, 수학적으로는 특정 변수 x 에 대응하는 확률 p(x)&amp;nbsp;를 나타내므로 함수의 형태로 생각할 수 있으며, 시각적으로 상상해보자면 위의 그림과 같은 좌표계 상의 그래프로 표현할 수 있습니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&lt;strong&gt;사람 얼굴의 확률분포&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;이제 GAN에서 말하는 데이터의 확률분포를 살펴볼 차례입니다. 여기서는 데이터가 &#39;사람 얼굴 사진&#39;이라고 가정하겠습니다. 그렇다면 사람 얼굴의 확률분포란 무엇일까요? 사람의 얼굴을 어떻게 확률변수라는 수치로 표현할 수 있을까요? 또 그에 대한 확률은 어떻게 정의할까요?&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;앞에서 CNN을 이용한 이미지 분류를 설명할 때, 이미지를 특징 공간 상의 한 점으로 나타낼 수 있다고 했습니다. 그리고 그 특징 공간의 각 좌표축(기저 벡터)는 어떤 특징을 나타내는 것입니다. 사람의 얼굴을 예로 들자면 얼굴 크기, 눈, 코, 입의 상대적 크기, 이마 넓이, 미간의 폭, 쌍커풀의 정도 등을 특징으로 선택할 수 있겠죠.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;이렇게 생각하면 사람의 얼굴도 변수로 수치화할 수 있습니다. 설명을 간단히 하기 위해 얼굴 크기와 미간의 폭이라는 두 가지 특징만을 고려하겠습니다. 여기서 얼굴 크기를 S, 미간의 폭을 W라고 하면 어떤 사람의 얼굴 F는&amp;nbsp;S 와&amp;nbsp;W 의 순서쌍 F(S, W) 로 표기할 수 있습니다. 맙소사! 사람 얼굴을 숫자로 바꾸는데 성공했습니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;이제 사람 얼굴을 확률변수로 수치화하는데 성공했으니 그에 대한 확률도 정의할 수 있습니다. 그 확률이란 바로 비슷한 얼굴이 존재할 확률을 말합니다. 세상에 나와 얼굴이 정확히 똑같은 사람이 존재할 확률은 0에 가까우므로, 여기서도 밀도의 개념을 빌려와야 합니다. 즉, 사람 얼굴의 확률밀도는 (S, W) 좌표계 상에서 특정 좌표 근처에 얼마나 많은 얼굴이 존재하냐는 것입니다. 결국 &#39;평범한 얼굴&#39;일수록 그 근처의 확률 밀도는 커질 것입니다. 이를 그림으로 나타내면 아래와 같습니다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://2.bp.blogspot.com/-aOIKZvG7fY0/WZkGv0Hm2bI/AAAAAAAAAJM/curLqjlOUzAwTIdNk7IWtmRAa21uBuMIgCLcBGAs/s1600/9.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;621&quot; data-original-width=&quot;850&quot; height=&quot;291&quot; src=&quot;https://2.bp.blogspot.com/-aOIKZvG7fY0/WZkGv0Hm2bI/AAAAAAAAAJM/curLqjlOUzAwTIdNk7IWtmRAa21uBuMIgCLcBGAs/s400/9.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;GAN과&lt;/span&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&amp;nbsp;확률분포&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;이제 GAN의 판별자 네트워크 입장에서 확률분포를 생각해 보겠습니다. 판별자의 역할은 주어진 얼굴 f=(s, w)가 학습 데이터세트에 포함된 진짜 얼굴인지, 생성자가 만들어낸 가짜 얼굴인지를 가려내는 것입니다. 결국 판단의 근거는 주어진 얼굴이 얼마나 그럴싸하냐는 것 입니다. 다른말로 하자면 주어진 얼굴과 비슷한 얼굴이 얼마냐 존재하냐는 것이죠. 결국 판별자는 주어진 얼굴이 아래 그림에서 진한 색으로 표시한 영역에 가까울 수록 진짜일 확률이 높다고 판단합니다.&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;그렇다면 생성자는 판별자를 속이기 위해 어떻게 해야 할까요? 판별자가 비밀로하는 확률분포를 알아내야 합니다. 한 마디로 입력으로 주어지는 랜덤 노이즈의 확률 분포를 사람 얼굴의 확률분포로 변환하는 함수를 학습해야 합니다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://2.bp.blogspot.com/-BJZVl4g8ixg/WZkG_Pd4qFI/AAAAAAAAAJQ/xvClQJM-d5c-rrtbWDsrY-PJ4QUpXCungCLcBGAs/s1600/10.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;451&quot; data-original-width=&quot;925&quot; height=&quot;193&quot; src=&quot;https://2.bp.blogspot.com/-BJZVl4g8ixg/WZkG_Pd4qFI/AAAAAAAAAJQ/xvClQJM-d5c-rrtbWDsrY-PJ4QUpXCungCLcBGAs/s400/10.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;학습 초기에는 생성자가 만들어낸 얼굴이 판별자가 진짜라고 판단하는 영역에서 멀리 떨어져 있습니다. 하지만 수없이 많은 학습을 반복하면서, 생성자가 만들어내는 얼굴의 확률분포는 판별자가 알고있는 진짜 얼굴의 확률분포와 비숫해집니다. 학습이 완료된 시점에서는 생성자가 만들어낸 얼굴의 확률분포와 판별자가 알고있는 얼굴의 확률분포가 일치하게 되고, 판별자로서는 도저히 진짜와 가짜를 구분할 수 없게됩니다. 결국 앞에서 설명한대로 판별자가 정답을 맞힐 확률은 0.5가 됩니다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-jQrnAX5oIBM/WZkHS-q0CdI/AAAAAAAAAJU/0ZAxhhX54IQS7WXTmojIYvdg-0XGE7hPgCLcBGAs/s1600/11.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;327&quot; data-original-width=&quot;1240&quot; height=&quot;105&quot; src=&quot;https://4.bp.blogspot.com/-jQrnAX5oIBM/WZkHS-q0CdI/AAAAAAAAAJU/0ZAxhhX54IQS7WXTmojIYvdg-0XGE7hPgCLcBGAs/s400/11.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;이제 GAN이 확률분포를 근사한다는 말의 의미를 이해할 수 있게 됐습니다. 그렇다면 GAN은 패턴을 흉내낼 수 있는 완벽한 도구일까요?&amp;nbsp;&lt;a class=&quot;tx-link&quot; href=&quot;https://dl-ai.blogspot.kr/2017/08/gan-problems.html&quot; style=&quot;color: #8a8a8a;&quot; target=&quot;_blank&quot;&gt;다음 포스트&lt;/a&gt;에서는 GAN이 앞으로 해결해야할 과제들을 살펴보겠습니다.&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://dl-ai.blogspot.com/feeds/7489869826078681200/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://dl-ai.blogspot.com/2017/08/gan-distribution.html#comment-form' title='1개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/667922483794864061/posts/default/7489869826078681200'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/667922483794864061/posts/default/7489869826078681200'/><link rel='alternate' type='text/html' href='http://dl-ai.blogspot.com/2017/08/gan-distribution.html' title='[GAN]  GAN과 확률분포 - 평범한게 좋아!'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://1.bp.blogspot.com/-YvVgB0q6LPQ/WZkGOsLq-VI/AAAAAAAAAJE/faQT4dR2MQUMePPAMs5nNJPDDyhcdKn-QCLcBGAs/s72-c/7.png" height="72" width="72"/><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-667922483794864061.post-3083498294967906114</id><published>2017-08-19T20:44:00.001-07:00</published><updated>2017-08-19T21:04:46.301-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="adversarial learning"/><category scheme="http://www.blogger.com/atom/ns#" term="GAN"/><category scheme="http://www.blogger.com/atom/ns#" term="적대적 학습"/><title type='text'>[GAN] 적대적 학습</title><content type='html'>&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;학습 데이터와 생성자 네트워크, 판별자 네트워크는 서로 어떻게 상호작용하면서 학습이 이뤄질까요? 생성자는 판별자의 정확도를 최소화하는 것이 목적이고, 판별자는 판별의 정확도를 최대화하는 것이 목적이라는 점은 알겠는데, 도데체 어떻게 학습이 이뤄지는지 감이 오질 않습니다. 이제부터 적대적 학습의 과정을 차근차근 살펴보겠습니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&lt;strong&gt;번갈아 학습하기&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;기본적인 적대적 학습에서는 판별자와 생성자를 번갈아가며 학습합니다. 학습을 처음 시작할 때는 판별자와 생성자가 모두 엉망인 상태죠. 판별자는 가짜와 진짜를 전혀 구별하지 못하고, 생성자는 전혀 엉뚱한 데이터를 생성해냅니다. 이렇게 양쪽이 모두&amp;nbsp;엉망인 상태에서는 학습이 어렵습니다. 생성자가&amp;nbsp;풀어야할 문제의 힌트를&amp;nbsp;주기위해서는 판별자를 먼저 학습 시킨 후, 생성자가 판별자의 지도를 받아 그 제약 안에서 학습하도록 해야 합니다. 이를 정리해보면, 전체적인 적대적 학습의 얼개는 다음과 같습니다.&lt;/div&gt;&lt;ol style=&quot;background-color: white; border: 0px; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; line-height: 1.3; margin: 0px; padding: 0px 0px 0px 25px;&quot;&gt;&lt;li style=&quot;border: 0px; line-height: 1.3; margin: 0px; padding: 0px;&quot;&gt;판별자 네트워크 학습&lt;/li&gt;&lt;ul style=&quot;border: 0px; line-height: 1.3; list-style-type: disc; margin: 0px; padding: 0px 0px 0px 25px;&quot;&gt;&lt;li style=&quot;border: 0px; line-height: 1.3; margin: 0px; padding: 0px;&quot;&gt;랜덤 노이즈 m 개를 생성하여, 생성자 네트워크에 전달하고 변환된&amp;nbsp;데이터 m 개를 얻습니다.&lt;/li&gt;&lt;/ul&gt;&lt;ul style=&quot;border: 0px; line-height: 1.3; list-style-type: disc; margin: 0px; padding: 0px 0px 0px 25px;&quot;&gt;&lt;li style=&quot;border: 0px; line-height: 1.3; margin: 0px; padding: 0px;&quot;&gt;학습 데이터셋에서 진짜 데이터 m 개를 선택합니다.&lt;/li&gt;&lt;/ul&gt;&lt;ul style=&quot;border: 0px; line-height: 1.3; list-style-type: disc; margin: 0px; padding: 0px 0px 0px 25px;&quot;&gt;&lt;li style=&quot;border: 0px; line-height: 1.3; margin: 0px; padding: 0px;&quot;&gt;2m 개의 데이터(진짜 m개 +&amp;nbsp;가짜 m개)를 이용해 판별자 네트워크의 정확도를 최대화하는 방향으로 학습합니다.&lt;/li&gt;&lt;/ul&gt;&lt;li style=&quot;border: 0px; line-height: 1.3; margin: 0px; padding: 0px;&quot;&gt;생성자 네트워크 학습&lt;/li&gt;&lt;ul style=&quot;border: 0px; line-height: 1.3; list-style-type: disc; margin: 0px; padding: 0px 0px 0px 25px;&quot;&gt;&lt;li style=&quot;border: 0px; line-height: 1.3; margin: 0px; padding: 0px;&quot;&gt;랜덤 노이즈 m 개를 다시 생성합니다.&lt;/li&gt;&lt;li style=&quot;border: 0px; line-height: 1.3; margin: 0px; padding: 0px;&quot;&gt;랜덤&amp;nbsp;노이즈 m 개를 이용해&amp;nbsp;생성자가 판별자의 정확도를 최소화하도록 학습합니다.&lt;/li&gt;&lt;/ul&gt;&lt;/ol&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;학습은 1,2 단계를 반복하면서 진행됩니다. 1 단계는 위에서 말한대로 판별자를 먼저 학습 시키는 과정이고,&amp;nbsp;2 단계는 어느 정도 학습된 판별자를 바탕으로 생성자를 학습시키는 과정입니다. 실제로는 판별자의 학습 속도를 높이기 위해 1번 단계를 여러번 반복한 후, 2번 단계로 넘어갈 수도 있습니다. 그만큼 판별자의 능력이 중요하다는 합니다. 앞에서 설명한 Minimax Game이 성립하려면 판별자의 능력이 최대화돼야하기 때문입니다. 이제 판별자 학습 과정과 생성자 학습 과정을 자세히 살펴보겠습니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&lt;strong&gt;판별자 네트워크 학습&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;판별자는 진짜 혹은 가짜 데이터를 입력으로 받고, 그 입력이 진짜일 확률을 출력합니다. 결국 판별자의 정확도가 높다는 말은 다음과 같이 두 가지 경우로 나누어 생각할 수 있습니다. (확률은 0이상 1이하의 실수입니다.)&lt;/div&gt;&lt;ul style=&quot;background-color: white; border: 0px; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; line-height: 1.3; margin: 0px; padding: 0px 0px 0px 25px;&quot;&gt;&lt;li style=&quot;border: 0px; line-height: 1.3; margin: 0px; padding: 0px;&quot;&gt;입력 데이터가 진짜인 경우 : 1에 가까운 큰 확률값을 출력한다.&lt;/li&gt;&lt;li style=&quot;border: 0px; line-height: 1.3; margin: 0px; padding: 0px;&quot;&gt;입력 데이터가 가짜인 경우 : 0에 가까운 작은 확률값을 출력한다.&lt;/li&gt;&lt;/ul&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;이제 이런 목적을 달성할 수 있는 목적함수(손실함수)를 설계해야 합니다. 이해를 쉽게하기 위해 Ian J. Goodfellow 논문의 수식을 판별자 입장에서 단순히 표현하면 다음과 같습니다. 입력 데이터 x에 대하여, D(x)는 판별자가 출력한 확률을 말합니다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-FIDfMpb-lrQ/WZkCbfehFlI/AAAAAAAAAIg/30NJFzscN3EHZyd55pED_iznKkJKuiLJACLcBGAs/s1600/math_uf_1502611603051.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;65&quot; data-original-width=&quot;289&quot; src=&quot;https://3.bp.blogspot.com/-FIDfMpb-lrQ/WZkCbfehFlI/AAAAAAAAAIg/30NJFzscN3EHZyd55pED_iznKkJKuiLJACLcBGAs/s1600/math_uf_1502611603051.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;즉, 입력 데이터 x가 학습 데이터에 포함되는 진짜라면 판별자가 출력하는 확률 D(x)를 최대화한다는 말입니다. 반대로 입력&amp;nbsp;데이터 x가 학습 데이터에 없는 가짜라면&amp;nbsp;판별자는 입력 x가 가짜일 확률을 크게 출력해야 하므로 1-D(x)를 최대화해야 합니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;이제 이 손실함수를 최대화하는 방향으로 판별자를 학습시킵니다. 학습과정은 역전파 알고리즘을 이용한 일반적인 SGD와 동일합니다. 단지, 판별자의 목표는 손실을 최대화하는 것이므로 목적함수의 기울기가 하강하는 방향이 아니라 상승하는 방향으로 파라미터를 조정합니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;원래 논문에서 표현된 GAN 전체의 목적함수는&amp;nbsp;위와는 크게 다른 모습입니다. 하지만, 판별자의 입장에서 판별자 네트워크를 학습시키는 부분만 분리해서 보면 위와 같이 이해해도 무방하다고 생각됩니다. 또한 원래 논문에서는 D(x)와 1-D(x)에 log를 적용하여 사용하는데 이는 좀 더 안정적인 학습을 위한 것으로, 손실을 최대화한다는 점에서는 동일합니다. 결국 실제로 GAN에서 판별자 네트워크를 학습시킬 때 사용하는 목적함수는 다음과 같습니다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-wylA3Dm1Fp0/WZkCs8ZqOsI/AAAAAAAAAIk/iLfPdOURNpU3cFgO5hJS4IvZShY6Xxf3ACLcBGAs/s1600/math_uf_1502637696846.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;65&quot; data-original-width=&quot;343&quot; height=&quot;60&quot; src=&quot;https://4.bp.blogspot.com/-wylA3Dm1Fp0/WZkCs8ZqOsI/AAAAAAAAAIk/iLfPdOURNpU3cFgO5hJS4IvZShY6Xxf3ACLcBGAs/s320/math_uf_1502637696846.png&quot; width=&quot;320&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; clear: none; color: #8a8a8a; float: none; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&lt;strong&gt;생성자 네트워크 학습&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; clear: none; color: #8a8a8a; float: none; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;자, 이제 판별자가 어느 정도 능력을 갖추게 됐으니 그 경쟁자인 생성자에게 좋은 적수가 될 수 있겠습니다. 생성자 네트워크의 학습은 말그대로 판별자를 속이는 방법을 학습시키는 과정입니다. 생성자의 입력으로 주어지는 랜덤 노이즈 데이터를 z 라하고, 주어진 랜덤 노이즈를 생성자가 변환시킨 결과를 G(z)라고 합시다. 그렇다면 판별자가 변환된 데이터를 입력으로 받아 출력하는 확률은 D(G(z))로 표기할 수 있습니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; clear: none; color: #8a8a8a; float: none; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;우리는 생성자가 판별자를 속이도록 학습시켜야하므로, 판별자가 G(z)를 가짜라고 판별할 확률 1-D(G(z))를 최소화해야 합니다. 정리하면, 생성자의 손실함수는 아래와 같습니다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-6IN75cmdWVE/WZkEzUiWlKI/AAAAAAAAAIw/mznaMQ-HMqEyj25Zem_zsjl3Zk8nqot8gCLcBGAs/s1600/math_uf_1503200291208.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;24&quot; data-original-width=&quot;197&quot; src=&quot;https://3.bp.blogspot.com/-6IN75cmdWVE/WZkEzUiWlKI/AAAAAAAAAIw/mznaMQ-HMqEyj25Zem_zsjl3Zk8nqot8gCLcBGAs/s1600/math_uf_1503200291208.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; clear: none; color: #8a8a8a; float: none; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;일반적인 기울기 하강법과 SGD를 이용하여 생성자 네트워크의 파라미터를 업데이트 하면 됩니다. 물론 이 과정에서 판별자 네트워크의 파라미터는 업데이트하면 안됩니다.&amp;nbsp;판별자의 목적은 손실을 최소화하는 것이 아니라 최대화하는 것이기 때문입니다. 즉, 판별자는 손실함수에서 발생하는 기울기의 흐름을 생성자 네트워크에 전달하는 통로 역할을 할뿐, 판별자 네트워크 자체는 변하지 않습니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; clear: none; color: #8a8a8a; float: none; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;하지만 위에서 설명한 손실함수를 이용하면 생성자를 학습시키기가 어렵습니다. 그 이유는 학습 초기에 생성자와 판별자의 능력차가 크기 때문입니다. &#39;가짜와 진짜를 판별하는 일&#39;에 비해서 &#39;진짜와 똑같은 가짜를 만드는 일&#39;이 훨씬 더 어렵기 때문에, 생성자에 비해 판별자가 더 빠르게 학습됩니다. 결국 학습 초기에 생성자가 만들어낸 데이터는 진짜와 전혀 비슷하지 않은 &#39;엉터리 가짜&#39;이므로 판별자는 아주 쉽게 이를 판별해냅니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; clear: none; color: #8a8a8a; float: none; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;즉, 주어지는 모든 z에 대해 1-D(G(z))는 항상 1에 가까운 값을 가지게 됩니다.&amp;nbsp;생성자 입장에서는 어떻게 해도 판별자를 속일 힌트를 얻을 수 없는 것입니다. 수학적으로 보면 1-D(G(z))가 최대값인 1에 가까울 수록&amp;nbsp;log{1-D(G(z))}의&amp;nbsp;기울기는 작아지기 때문에, 생성자 네트워크의 파라미터를 조정하기에 충분한 기울기를 얻기 어렵습니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; clear: none; color: #8a8a8a; float: none; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;이런 문제를 해결하기 위해 약간의 트릭을 사용합니다. 판별자가 G(z)를 가짜라고 판별할 확률 1-D(G(z))을 최소화하는 대신에, 판별자가 G(z)를 진짜라고 할 확률 D(G(z))를 최대화하는 것입니다. 논리적으로는 완벽히 동일한 얘기지만, log를 적용했을 때의 기울기라는 측면에서 보면 아래 그림과 같이 전혀 다른 얘기가 됩니다. 즉, 학습초기에 D(G(z))가 0에 가까울 때 log{D(G(z))}의 기울기는 거의 수직에 가깝기 때문에 빠른 학습이 가능한 것입니다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://2.bp.blogspot.com/-AJ30OJEo018/WZkFGeIcZ_I/AAAAAAAAAI0/_d85GkkBEM4cL9n7JGMsoP4QM-SYI_vQACLcBGAs/s1600/16.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;422&quot; data-original-width=&quot;642&quot; height=&quot;262&quot; src=&quot;https://2.bp.blogspot.com/-AJ30OJEo018/WZkFGeIcZ_I/AAAAAAAAAI0/_d85GkkBEM4cL9n7JGMsoP4QM-SYI_vQACLcBGAs/s400/16.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; clear: none; color: #8a8a8a; float: none; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; clear: none; color: #8a8a8a; float: none; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;결론적으로 아래 목적 함수를 최대화하는 방향으로 생성자 네크워크를 학습시키게 됩니다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-dyk7jqiIY7w/WZkFaMK6_UI/AAAAAAAAAI4/-moEo0jEARoixkKA1kpoLQaSYdO6WL0VQCLcBGAs/s1600/math_uf_1503200328893.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;24&quot; data-original-width=&quot;173&quot; src=&quot;https://4.bp.blogspot.com/-dyk7jqiIY7w/WZkFaMK6_UI/AAAAAAAAAI4/-moEo0jEARoixkKA1kpoLQaSYdO6WL0VQCLcBGAs/s1600/math_uf_1503200328893.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: white; color: #8a8a8a; font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;applegothic&amp;quot; , sans-serif; font-size: 12px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: white; color: #8a8a8a; font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;applegothic&amp;quot; , sans-serif; font-size: 12px;&quot;&gt;&amp;nbsp;이제 적대적 학습의 전체적인 흐름을 설명했습니다. 그런데 GAN을 다루는 논문들을 보면 이 모든 것을 &#39;데이터의 확률분포&#39;로 설명합니다. 우리는 흔히 확률이라고하면 &#39;어떤 일이 벌어질 가능성&#39;이라고 생각합니다. 그런데 패턴을 흉내내는 일과 확률분포 사이에 어떤 관계가 있을까요?&amp;nbsp;&lt;/span&gt;&lt;a class=&quot;tx-link&quot; href=&quot;https://dl-ai.blogspot.kr/2017/08/gan-distribution.html&quot; style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px;&quot; target=&quot;_blank&quot;&gt;다음 포스트&lt;/a&gt;&lt;span style=&quot;background-color: white; color: #8a8a8a; font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;applegothic&amp;quot; , sans-serif; font-size: 12px;&quot;&gt;에서는 GAN에서 확률분포가 어떤 의미를 갖는지 살펴보겠습니다.&lt;/span&gt;&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://dl-ai.blogspot.com/feeds/3083498294967906114/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://dl-ai.blogspot.com/2017/08/gan-adversarial-learning.html#comment-form' title='2개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/667922483794864061/posts/default/3083498294967906114'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/667922483794864061/posts/default/3083498294967906114'/><link rel='alternate' type='text/html' href='http://dl-ai.blogspot.com/2017/08/gan-adversarial-learning.html' title='[GAN] 적대적 학습'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://3.bp.blogspot.com/-FIDfMpb-lrQ/WZkCbfehFlI/AAAAAAAAAIg/30NJFzscN3EHZyd55pED_iznKkJKuiLJACLcBGAs/s72-c/math_uf_1502611603051.png" height="72" width="72"/><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-667922483794864061.post-1940974973012475216</id><published>2017-08-19T20:25:00.002-07:00</published><updated>2017-08-19T21:03:05.862-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="GAN"/><category scheme="http://www.blogger.com/atom/ns#" term="구조"/><title type='text'>[GAN] GAN의 구성</title><content type='html'>&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;앞서 살펴봤듯이 GAN은 패턴을 흉내내는 문제를 Minimax Game으로 접근합니다. 즉, 패턴을 흉내내는 생성자(generator) 네트워크와 그 패턴의 진위 여부를 판별하는 판별자(discriminator) 네트워크로 구성됩니다. 이 두 네트워크가 서로의 목적을 달성하도록 학습을 반복하는 것이죠. 물론 학습을 하려면 학습 데이터가 필요합니다. GAN의 학습 데이터는 생성자가 흉내내야 할 진짜 데이터를 말합니다. 예를 들어 사람의 얼굴을 그려내는 모델을 학습시킨다면 사람의 얼굴 사진이 필요하겠죠. 반면 사람이&amp;nbsp;손으로 쓴 숫자를 흉내낸다면 수기 숫자 이미지가 필요할 것입니다. 간단히 말하면 GAN 학습을 위해서 아래와 같은 세가지 구성요소가 필요합니다.&lt;/div&gt;&lt;ul style=&quot;background-color: white; border: 0px; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; line-height: 1.3; list-style-type: square; margin: 0px; padding: 0px 0px 0px 25px;&quot;&gt;&lt;li style=&quot;border: 0px; line-height: 1.3; margin: 0px; padding: 0px;&quot;&gt;학습 데이터 : 흉내내고자 하는 진짜 데이터&lt;/li&gt;&lt;li style=&quot;border: 0px; line-height: 1.3; margin: 0px; padding: 0px;&quot;&gt;생성자 네트워크 : 진짜 데이터와 유사한 패턴을 생성하는 네트워크&lt;/li&gt;&lt;li style=&quot;border: 0px; line-height: 1.3; margin: 0px; padding: 0px;&quot;&gt;판별자 네트워크 : &#39;학습(진짜) 데이터&#39;와 생성자가 만들어낸 &#39;가짜 데이터&#39;의 진위 여부를 판별하는 네트워크&lt;/li&gt;&lt;/ul&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;이제 이 세가지 구성요소를 자세히 살펴보겠습니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;학습 데이터&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;GAN의 학습 데이터는 간단합니다. 분류 문제처럼 각 데이터의 분류를 라벨링(labeling)하거나 회귀 문제처럼 정확한 답을 사람이 일일이 지정해줄 필요가 없습니다. 단지 흉내내고자 하는 데이터를 수집하면 됩니다. 이러한 이유로 GAN이 비지도 학습(unsupervised learning)의 성격을 띈다고 말하기도 합니다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-9DpQrVv7r2Y/WZkAG6QkiHI/AAAAAAAAAII/96eXRrRG-hcm_5WDVNTCRJHW7ZuPk2MugCLcBGAs/s1600/3.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;263&quot; data-original-width=&quot;647&quot; height=&quot;162&quot; src=&quot;https://3.bp.blogspot.com/-9DpQrVv7r2Y/WZkAG6QkiHI/AAAAAAAAAII/96eXRrRG-hcm_5WDVNTCRJHW7ZuPk2MugCLcBGAs/s400/3.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;물론 데이터의 수는 일반적으로 많을 수록 좋습니다. 데이터의 수가 많을 수록 다양한 패턴이 포함될 확률이 크기 때문이죠. 데이터의 양에 더불어 데이터의 다양성도 중요합니다. 수기 숫자를 흉내낼 때, 학습 데이터에 0부터 9까지의 모든 숫자가 골고루 필요하다는 말입니다. 학습 데이터에 포함된 숫자가 &#39;1&#39;뿐이라면, 생성자도 &#39;1&#39;만 생성해낼 것입니다.&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&lt;strong&gt;생성자 네트워크&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;생성자는 학습 데이터의 패턴을 흉내내어 판별자의 정확도를 최소화하는 것이 목적입니다. 기본적인 GAN 모델에서 생성자 네트워크에 주어지는 입력은 랜덤 노이즈(random noise)이며, 출력은 학습 데이터와 유사한 패턴을 지닌 데이터 입니다. 즉, 생성자 네트워크는 랜덤 노이즈를 학습 데이터와 유사한 패턴으로 변환하는 함수를 학습하게 됩니다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://2.bp.blogspot.com/-CMJKIsqoI-Y/WZkAbwKSNUI/AAAAAAAAAIM/gIwBTInYzU4MsWDclE80W9oFyZnmX-tCACLcBGAs/s1600/4.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;186&quot; data-original-width=&quot;730&quot; height=&quot;101&quot; src=&quot;https://2.bp.blogspot.com/-CMJKIsqoI-Y/WZkAbwKSNUI/AAAAAAAAAIM/gIwBTInYzU4MsWDclE80W9oFyZnmX-tCACLcBGAs/s400/4.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;네트워크의 형태는 목적에 따라 다양할 수 있습니다. 생성하고 싶은 패턴의 형태에 따라 MLP(multi-layer perceptron)와 CNN,&amp;nbsp;auto-encoder&amp;nbsp;등 어떤 형태든 가능합니다. 기본적인 GAN에서 파생된 모델들에 대해서는 차차 살펴보도록 하겠습니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;판별자 네트워크&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;판별자는 입력으로 주어진 데이터가 학습 데이터에 포함된 진짜인지, 생성자가 만들어낸 가짜인지를 판별하는 역할을 하며, 판별의 성공 확률을 최대화하는 것이 목적입니다. 즉, 진짜 혹은 가짜 데이터를 입력으로 받아, 입력받은 데이터가 학습 데이터에 포함된 진짜 데이터일 확률을 출력합니다. 판별자 네트워크의 형태도 생성자와 마찬가지로 제한이 없습니다. 판별코자 하는 데이터의 형태에 적합한 네트워크 형태를 선택하면 됩니다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-xX4pJeIbGOs/WZkAvs2zZgI/AAAAAAAAAIQ/GZoxNnXHH2UEar42oMw5dKoTy6Jcv4DfwCLcBGAs/s1600/5.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;325&quot; data-original-width=&quot;823&quot; height=&quot;157&quot; src=&quot;https://3.bp.blogspot.com/-xX4pJeIbGOs/WZkAvs2zZgI/AAAAAAAAAIQ/GZoxNnXHH2UEar42oMw5dKoTy6Jcv4DfwCLcBGAs/s400/5.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&lt;strong&gt;셋이 함께 모이면...&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;지금까지 설명한 내용을 처음부터 끝까지 정리해 보면 다음과 같습니다.&amp;nbsp;&lt;/div&gt;&lt;ol style=&quot;background-color: white; border: 0px; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; line-height: 1.3; margin: 0px; padding: 0px 0px 0px 25px;&quot;&gt;&lt;li style=&quot;border: 0px; line-height: 1.3; margin: 0px; padding: 0px;&quot;&gt;랜덤 노이즈를 생성하여 생성자의 입력으로 전달합니다.&lt;/li&gt;&lt;li style=&quot;border: 0px; line-height: 1.3; margin: 0px; padding: 0px;&quot;&gt;생성자는 입력으로 주어진 랜덤 노이즈를 변환하여 가짜 데이터를 만듭니다.&lt;/li&gt;&lt;li style=&quot;border: 0px; line-height: 1.3; margin: 0px; padding: 0px;&quot;&gt;생성자가 만들어낸 &#39;가짜&#39; 출력과&amp;nbsp;&#39;진짜&#39; 학습 데이터를 적절히 조합하여 판별자의 입력으로 제공합니다.&lt;/li&gt;&lt;li style=&quot;border: 0px; line-height: 1.3; margin: 0px; padding: 0px;&quot;&gt;판별자는 주어진 입력이 학습 데이터에 포함된 &#39;진짜&#39;일 확률을 구합니다.&lt;/li&gt;&lt;/ol&gt;&lt;div&gt;&lt;span style=&quot;color: #8a8a8a; font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;applegothic&amp;quot; , sans-serif;&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-n9mKBe3m9zw/WZkBAS_oUcI/AAAAAAAAAIU/WKIHqZp7z_IvQ-arRsEvWDp8C8foPDc2wCLcBGAs/s1600/6.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;300&quot; data-original-width=&quot;1232&quot; height=&quot;96&quot; src=&quot;https://1.bp.blogspot.com/-n9mKBe3m9zw/WZkBAS_oUcI/AAAAAAAAAIU/WKIHqZp7z_IvQ-arRsEvWDp8C8foPDc2wCLcBGAs/s400/6.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: white; color: #8a8a8a; font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;applegothic&amp;quot; , sans-serif; font-size: 12px;&quot;&gt;&amp;nbsp;GAN의 실행 순서는 위와 같으며, 학습 과정은 위의 과정을 거꾸로 거슬러 올라가면서 역전파(back propogation) 알고리즘을 바탕으로 네트워크의 파라미터를 최적화하는 과정입니다.&amp;nbsp;&lt;/span&gt;&lt;a class=&quot;tx-link&quot; href=&quot;https://dl-ai.blogspot.kr/2017/08/gan-adversarial-learning.html&quot; style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px;&quot; target=&quot;_blank&quot;&gt;다음 포스트&lt;/a&gt;&lt;span style=&quot;background-color: white; color: #8a8a8a; font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;applegothic&amp;quot; , sans-serif; font-size: 12px;&quot;&gt;에서는 적대적 학습의 과정을 자세히 살펴보겠습니다.&lt;/span&gt;&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://dl-ai.blogspot.com/feeds/1940974973012475216/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://dl-ai.blogspot.com/2017/08/gan-structure.html#comment-form' title='1개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/667922483794864061/posts/default/1940974973012475216'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/667922483794864061/posts/default/1940974973012475216'/><link rel='alternate' type='text/html' href='http://dl-ai.blogspot.com/2017/08/gan-structure.html' title='[GAN] GAN의 구성'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://3.bp.blogspot.com/-9DpQrVv7r2Y/WZkAG6QkiHI/AAAAAAAAAII/96eXRrRG-hcm_5WDVNTCRJHW7ZuPk2MugCLcBGAs/s72-c/3.png" height="72" width="72"/><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-667922483794864061.post-7028147528717808350</id><published>2017-08-19T20:11:00.000-07:00</published><updated>2017-08-19T21:00:23.356-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="GAN"/><category scheme="http://www.blogger.com/atom/ns#" term="minimax game"/><title type='text'>[GAN] 속고 속이는 게임 - Minimax Game</title><content type='html'>&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;딥러닝하면 떠오르는 CNN과 RNN은 데이터에 존재하는 패턴을 인식하는데 주로 사용 됩니다. 주어진 데이터가 연속적인 신호(음성, 영상, 심전도 등)의 형태일 때, CNN을 사용하여 시공간 축에 따라 존재하는 패턴을 찾아낼 수 있습니다. 반면에 주어진 데이터가 불연속적인 시퀀스(자연어 등)일 때, RNN을 이용하여 시간에 따라 변화하는 패턴을 찾아낼 수 있습니다. 하지만 진정한 인공지능을 구현하려면 주어진 패턴을 인식하는 것 만으로는 부족합니다. 우리 인류의 위대한 점은 바로 패턴을 창조하는데 있습니다. 고흐나 모네같은 화가, 베토벤이나 모짜르트 같은 작곡가 등을 그 예로 들 수 있습니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;그렇다면 딥러닝으로 패턴을 만들어 낼 수 있을까요? 그에 대한 답이 바로 GAN(Generative Adversarial Networks) 입니다. 엄밀히 말하자면 고흐처럼 새로운 패턴(화풍)을 만드는 것이 아니라, 이미 존재하는 고흐의 패턴을 흉내내는 수준이지만 말입니다. 어쨋든 그 정도만으로도 충분히 흥미로운 일이니, 한번쯤 살펴볼 가치가 있겠습니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;&lt;strong&gt;기본적인 아이디어 - Minimax Game&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;GAN의 시초라 할 수 있는&amp;nbsp;&lt;a class=&quot;tx-link&quot; href=&quot;https://arxiv.org/abs/1406.2661&quot; style=&quot;color: #8a8a8a;&quot; target=&quot;_blank&quot;&gt;Ian J. Goodfellow의 논문&lt;/a&gt;을 보면 재미있는 비유를 들고 있습니다. 위조지폐를 만드는 위조지폐범과 위조지폐를 가려내려는 경찰이 있다고 가정합시다. 위조지폐범의 목적은 실제 지폐와 똑같은 위폐를 만들어서 경찰을 속이는 것이고, 경찰의 목적은 진폐와 위폐를 완벽히 구별해내는 것 입니다. 좀 더 명확히 말하자면 위조지폐범의 목적은 경찰이 진폐와 위폐를 구별하는 정확도를 최소화하는 것이고, 경찰의 목적은 그 정확도를 최대화하는 것이죠.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-EjQWfwWOyKM/WZj9GVFX0KI/AAAAAAAAAH0/2Q1G_gElEbUukJ4VvC9l44tYR9-TX3G4gCLcBGAs/s1600/1.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;389&quot; data-original-width=&quot;527&quot; height=&quot;295&quot; src=&quot;https://4.bp.blogspot.com/-EjQWfwWOyKM/WZj9GVFX0KI/AAAAAAAAAH0/2Q1G_gElEbUukJ4VvC9l44tYR9-TX3G4gCLcBGAs/s400/1.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;제3자인 우리는 패턴을 똑같이 만들어내는 것이 목적이니 최종적으로는 위조지폐범의 편에 서야합니다. 즉, 경찰의 정확도를 최소화해야 합니다. 하지만 위폐를 어설프게 만들다가 적발되면 큰일이니, 최대한 보수적인 가정을 합시다. 경찰이 위폐와 지폐를 완벽히 구분할 수 있다고 가정하는 것이죠. 위폐범에게는 최악의 상황(worst case)이 벌어진 겁니다. 그래도 위폐범은 나쁜 짓을 하려는 불굴의 의지(?)를 꺽지 않습니다. 결국 방법은 하나 뿐, 위폐를 진폐와 정말 똑같이 만들어내는 방법 뿐입니다. 수많은 시행착오 끝에 진폐와 똑같은 위폐를 만들어낸 우리의 위폐범! 결국 게임은 위폐범의 승리로 끝났습니다.&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;자, 이 시점에서 경찰이 진폐와 위폐를 구별하는 최소 확률은 얼마일까요? 우리의 불쌍한 경찰을 불러다가 테스트를 한다고 상상해 보죠. 우리는 도저히 위조 여부를 알수 없는 위폐와 진폐를 무작위하게 선택하여 한 번에 한장씩 경찰에게 보여줍니다. 경찰 입장에서는 여전히 위조 여부를 정확히 맞추려고 하겠죠. 이해를 쉽게하기 위해 세 가지 극단적인 경우를 생각해 봅시다.&lt;/div&gt;&lt;ul style=&quot;background-color: white; border: 0px; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; line-height: 1.3; margin: 0px; padding: 0px 0px 0px 25px;&quot;&gt;&lt;li style=&quot;border: 0px; line-height: 1.3; margin: 0px; padding: 0px;&quot;&gt;&amp;nbsp;무조건 위폐라고 답하는 경우 : 위폐와 지폐가 무작위하게 주어지므로, 테스트 횟수가 많아질 수록 정답을 맞힐 확률은 0.5에 가까워집니다.&lt;/li&gt;&lt;li style=&quot;border: 0px; line-height: 1.3; margin: 0px; padding: 0px;&quot;&gt;&amp;nbsp;무조건 진폐라고 답하는 경우 : 마찬가지 이유로 정답을 맞힐 확률은 0.5에 가까워집니다.&lt;/li&gt;&lt;li style=&quot;border: 0px; line-height: 1.3; margin: 0px; padding: 0px;&quot;&gt;&amp;nbsp;무작위하게 답하는 경우 : 지폐 한장의 위조 여부를 맞힐 확률이 0.5이므로, 테스트 전체의 확률도 0.5에 가까워집니다.&lt;/li&gt;&lt;/ul&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;결국 경찰이 학습을 완벽히 마쳤다고 가정했을 때, 위폐범이 달성할 수 있는 최소의 판별 정확도는 0.5 입니다. 결국 우리의 목적은 완벽히 학습을 마친 경찰의 판별 정확도를 0.5로 최소화하는 것입니다.&amp;nbsp;이처럼 최악의 경우(max)를 가정했을 때, 손실(loss)을 최소화(min)하는 것을 수학적으로는 Minimax Game이라고 합니다. 위폐범과 경찰의 예에서 손실은 경찰의 판별 정확도이고, 최악의 경우는 경찰이 진폐와 위폐를 완벽히 구별하는 경우입니다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-xTQnudJp9b0/WZj9basfizI/AAAAAAAAAH4/D3LUVSXygEcLF--xbw8b3SrdtZcoU7wngCLcBGAs/s1600/2.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;571&quot; data-original-width=&quot;673&quot; height=&quot;337&quot; src=&quot;https://4.bp.blogspot.com/-xTQnudJp9b0/WZj9basfizI/AAAAAAAAAH4/D3LUVSXygEcLF--xbw8b3SrdtZcoU7wngCLcBGAs/s400/2.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;background-color: white; color: #8a8a8a; font-family: 돋움, Dotum, AppleGothic, sans-serif; font-size: 12px; margin-bottom: 1em; margin-top: 1em; padding-bottom: 0px !important; padding-top: 0px !important;&quot;&gt;&amp;nbsp;GAN은 이처럼 패턴을 생성하는 문제를 Minimax Game의 형태로 접근합니다. 즉, 패턴을 생성하는 생성자(generator) 네트워크와 패턴의 진위 여부를 판별하는 판별자(discriminator) 네트워크가 존재할 때, 두 네트워크를 적대적(adversarial)으로 학습시키는 것입니다.&amp;nbsp;자, 이제 GAN의 배경이 되는&amp;nbsp;아이디어를 설명했으니&amp;nbsp;&lt;a class=&quot;tx-link&quot; href=&quot;https://dl-ai.blogspot.kr/2017/08/gan-structure.html&quot; style=&quot;color: #8a8a8a;&quot; target=&quot;_blank&quot;&gt;다음 포스트&lt;/a&gt;에서는 조금 더 구체적인 내용을 살펴보겠습니다.&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://dl-ai.blogspot.com/feeds/7028147528717808350/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://dl-ai.blogspot.com/2017/08/gan-minimax-game.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/667922483794864061/posts/default/7028147528717808350'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/667922483794864061/posts/default/7028147528717808350'/><link rel='alternate' type='text/html' href='http://dl-ai.blogspot.com/2017/08/gan-minimax-game.html' title='[GAN] 속고 속이는 게임 - Minimax Game'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://4.bp.blogspot.com/-EjQWfwWOyKM/WZj9GVFX0KI/AAAAAAAAAH0/2Q1G_gElEbUukJ4VvC9l44tYR9-TX3G4gCLcBGAs/s72-c/1.png" height="72" width="72"/><thr:total>0</thr:total></entry></feed>