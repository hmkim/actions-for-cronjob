<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Hoon CHOI on Medium]]></title>
        <description><![CDATA[Stories by Hoon CHOI on Medium]]></description>
        <link>https://medium.com/@idchoi2?source=rss-2a236da04e48------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*KJKQ-tbNG4EagBxYs10Cjw.png</url>
            <title>Stories by Hoon CHOI on Medium</title>
            <link>https://medium.com/@idchoi2?source=rss-2a236da04e48------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 01:58:16 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@idchoi2" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[비밀번호 없는 웹서비스 (Passwordless)]]></title>
            <link>https://medium.com/@idchoi2/%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8-%EC%97%86%EB%8A%94-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4-passwordless-c25fb859b601?source=rss-2a236da04e48------2</link>
            <guid isPermaLink="false">https://medium.com/p/c25fb859b601</guid>
            <category><![CDATA[개발]]></category>
            <category><![CDATA[auth]]></category>
            <category><![CDATA[passwordless]]></category>
            <category><![CDATA[로그인]]></category>
            <category><![CDATA[login]]></category>
            <dc:creator><![CDATA[Hoon CHOI]]></dc:creator>
            <pubDate>Tue, 20 Nov 2018 15:24:11 GMT</pubDate>
            <atom:updated>2018-11-20T15:24:11.369Z</atom:updated>
            <content:encoded><![CDATA[<p>여러분이 현재 보는 이 글은 Medium 에서 서비스되고 있다.</p><p>처음 이 서비스를 가입할때 혹은 로그인을 새로 하려고 할때 굉장히 독특한 경험을 하게 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/692/1*SNDfhFZ5LYG_YfiWHc4ShA.png" /><figcaption>회원 가입 화면</figcaption></figure><p>보통 회원가입을 하기위해서는 로그인을 하기 위한 <strong>아이디 혹은 이메일</strong>과 <strong>비밀번호</strong>를 입력하기 마련이다. 하지만 보다시피 회원가입창에 이메일, 아이디, 비밀번호를 적는 란은 어디에도 없이 구글이나 페이스북으로만 가입이 되게 되어있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/497/1*TiumD8t4H7PDvNcZEl-JQQ.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/401/1*pvqlPviG33A1AIf5SdPW_Q.png" /><figcaption>로그인 화면</figcaption></figure><p>로그인을 하기위해 이메일로 로그인을 눌러보면 역시 비밀번호 입력란은 없고 이메일만 입력하게 되어있다. 이메일을 입력하고 진행해보면 메일로 링크가 발송되고 해당 링크를 클릭하면 해당 이메일로 로그인이 된다.</p><p>바로 여기서 사용하는 방법이 비밀번호 없는 로그인 (Login with Passwordless) 이다. auth0.com 에 잘 소개되어있는 방법이다. (<a href="https://auth0.com/blog/auth0-passwordless-email-authentication-and-sms-login-without-passwords/">https://auth0.com/blog/auth0-passwordless-email-authentication-and-sms-login-without-passwords/</a>)</p><p>결론은 다음과 같다.</p><ol><li>회원가입시 SNS로그인을 하거나 이메일로 회원가입 링크를 발송한다.</li><li>로그인시에 SNS로그인을 하거나 이메일로 로그인 링크를 발송한다.</li></ol><p>이메일발송대신 SMS나 푸시알람등으로도 해결이 가능하다. 모바일앱에서 사용할때는 SMS나 푸시가 좀더 좋은 방법이겠다.</p><p>실제로 이 방법이 언제 처음 누가 도입했는지 모르지만 점점 쓰이는곳이 많아지는 추세다.</p><p>비밀번호가 없기때문에 비밀번호 유출의 위험이 없으며 검증된 3rd party의 인증을 사용하기때문에 보안에 더 뛰어나다.</p><p>특히 외부의 공공 PC에서 비밀번호 노출을 원천적으로 막을 수 있다.</p><p>비밀번호를 잃어버리는 일이 없지만 반대로 이메일을 확인해야하는 번거로움또한 있는것이 사실이다. 개인 PC는 한번 로그인한 이후 로그아웃을 하는경우가 매우 드물기 때문에 편의성대신 보안을 취한다면 사용해볼만한 좋은 방법인듯 하다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c25fb859b601" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Javascript 도형 그리기 — HTML vs SVG vs Canvas 성능 비교]]></title>
            <link>https://medium.com/@idchoi2/javascript-%EB%8F%84%ED%98%95-%EA%B7%B8%EB%A6%AC%EA%B8%B0-html-vs-svg-vs-canvas-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90-9e1ce2396fcd?source=rss-2a236da04e48------2</link>
            <guid isPermaLink="false">https://medium.com/p/9e1ce2396fcd</guid>
            <category><![CDATA[svg]]></category>
            <category><![CDATA[canvas]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[html]]></category>
            <category><![CDATA[dom]]></category>
            <dc:creator><![CDATA[Hoon CHOI]]></dc:creator>
            <pubDate>Sat, 22 Sep 2018 16:54:34 GMT</pubDate>
            <atom:updated>2018-09-22T16:54:34.572Z</atom:updated>
            <content:encoded><![CDATA[<h3>배경</h3><p>프론트엔드 작업은 화면 그리는일이 많다. 여러 프로젝트중 데이터 시각화를 구현하다보면 단순히 그리는 행위가 다가 아니라는것을 금방 깨닫게 된다. 데이터가 클수록 백엔드, 프론트엔드 전체를 생각하는 현명한 방법이 필요하다.</p><p>오늘은 브라우저단에서 대용량 데이터를 바탕으로 도형을 그릴때 어떤 방법이 효율적인지 비교를 해보도록 하겠다.</p><h3>목표</h3><p>해결해야할 목표는 다음과 같다.</p><p><strong>500 x 500px 화면에 25만개의 1px 점(dot)을 그린다. 100 x 100px (1만개) / 1000 x 1000px (100만개) 에서도 동일하게 그려본다.</strong></p><p>웹기반 UI를 그리기위해 세가지의 방법을 해보면서 비교해본다.</p><ol><li>HTML DOM</li><li>SVG</li><li>Canvas</li></ol><p>편의상 25만개의 픽셀에 랜덤하게 색상을 입혀서 적용시켜보았다.</p><p>CPU/RAM/GPU등 하드웨어 성능과 브라우저 성능에 따라서 차이가 날 수 있으니 상대적인 비교를 보는것이 좋다. 테스트 환경은 i7/8GB/macOS/Chrome으로 테스트를 하였다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1018/1*EEBz9i4OtIAypD2x1ymPPA.png" /><figcaption>25만개 점을 그려보았다.</figcaption></figure><h3>1. HTML DOM</h3><p>첫번째로 DOM으로 그리는 방식이다. 1px짜리 dom 25만개를 몰아서 그려넣엇을때 걸리는 시간은 얼마나 될까?</p><pre>const <em>area </em>= <em>document</em>.getElementById(&#39;html&#39;);<br><br><em>console</em>.time(&#39;Draw using HTML&#39;);<br><br>for(let <em>i </em>= 0; <em>i </em>&lt; 500; <em>i</em>++) {<br>    for(let <em>j </em>= 0; <em>j </em>&lt; 500; <em>j</em>++) {<br>        let <em>dot </em>= <em>document</em>.createElement(&quot;div&quot;);<br>        <em>dot</em>.classList = &#39;dot&#39;;<br>        <em>dot</em>.style.backgroundColor = getHex();<br>        <em>area</em>.appendChild(<em>dot</em>)<br>    }<br>}<br><br><em>console</em>.timeEnd(&#39;Draw using HTML&#39;);</pre><p>결과는?</p><blockquote><em>Draw using HTML: 4356.2841796875ms<br>Draw using HTML: 3448.929931640625ms<br>Draw using HTML: 4671.57275390625ms</em></blockquote><p>대략 3~4초 정도 걸린다.</p><p>그렇다면 메모리의 관점에서 본다면 얼마나 차지할지를 알아보자.</p><blockquote>Google Chrome Helper: 796.3M</blockquote><h3>2. SVG</h3><p>다음은 SVG를 이용하겠다. 1px짜리 rect를 그린다.</p><pre>const <em>area </em>= <em>document</em>.getElementById(&#39;svg&#39;);<br>let <em>dots </em>= [];<br><br><em>console</em>.time(&#39;Draw using SVG&#39;);<br><br>for(let <em>i </em>= 0; <em>i </em>&lt; 500; <em>i</em>++) {<br>    for(let <em>j </em>= 0; <em>j </em>&lt; 500; <em>j</em>++) {<br>        <em>dots</em>.push(&quot;&lt;rect class=&#39;dot&#39; style=&#39;fill:&quot;+getHex()+&quot;&#39; width=&#39;1&#39; height=&#39;1&#39; x=&#39;&quot;+(<em>i</em>)+&quot;&#39; y=&#39;&quot;+(<em>j</em>)+&quot;&#39;&gt;&lt;/rect&gt;&quot;);<br>    }<br>}<br><br><em>area</em>.innerHTML = <em>area</em>.innerHTML + <em>dots</em>.join(&quot;&quot;);<br><br><em>console</em>.timeEnd(&#39;Draw using SVG&#39;);</pre><blockquote>Draw using SVG: 7799.06103515625ms<br>Draw using SVG: 6832.514892578125ms<br>Draw using SVG: 7336.588134765625ms</blockquote><p>DOM방식보다 오래 걸리는것을 알 수 있다.</p><blockquote>Google Chrome Helper:1.7G</blockquote><p>메모리 측면에서도 과부하가 더 심하게 걸린다.</p><h3>3.Canvas</h3><p>마지막으로 Canvas에 마찬가지로 1px을 찍어본다.</p><pre>const <em>area </em>= <em>document</em>.getElementById(&#39;canvas&#39;);<br>let <em>ctx </em>= <em>area</em>.getContext(&quot;2d&quot;);<br><br><em>console</em>.time(&#39;Draw using Canvas&#39;);<br><br>for(let <em>i </em>= 0; <em>i </em>&lt; 500; <em>i</em>++) {<br>    for(let <em>j </em>= 0; <em>j </em>&lt; 500; <em>j</em>++) {<br>        <em>ctx</em>.fillStyle = getHex();<br>        <em>ctx</em>.fillRect(<em>i</em>, <em>j</em>, 1, 1);<br>    }<br>}<br><br><em>console</em>.timeEnd(&#39;Draw using Canvas&#39;);</pre><blockquote>Draw using Canvas: 430.7109375ms<br>Draw using Canvas: 417.10888671875ms<br>Draw using Canvas: 388.585693359375ms</blockquote><p>와우. 확연하게 빨라진 모습이다. 1,2번 방식은 화면이 나올때까지 시간이 상당히 걸리고 불러온뒤에도 과부하가 많이 발생한다. 하지만 Canvas로 그릴때는 시간뿐만 아니라 화면상 다른 동작을 할때도 전혀 부담이 없다.</p><blockquote>Google Chrome Helper:217.6M</blockquote><p>빠른 응답속도가 말해주듯 메모리 과부하고 가장 적다.</p><h3>캔버스 사이즈 변경</h3><p>이와 같은 방법으로 100 x 100 / 1000 x 1000 에서도 동일하게 테스트를 해보았다. 결과를 표로 정리해서 비교해보자.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*zMYzN6xArL1hM503GZuBNg.png" /></figure><p>1000 x 1000의 화면의 경우 HTML DOM / SVG는 테스트가 불가능할정도로 과부하가 심하게 걸렸다. 테스트를 할수록 RAM을 더 많이 잡아먹기때문에 더더욱 느려진다.</p><p>Canvas만이 1000 x 1000화면에서 쾌적한 성능을 보여준다.</p><h3>결론</h3><p>앞서 말했듯이 사용하는 컴퓨터의 성능에 따라 결과가 많이 달라진다. 그렇기 때문에 각 기법의 상대적인 비교를 보면 되겠다.</p><p>테스트에서 보듯이 Canvas를 이용하여 그리는것이 비교할수 없을만큼 빠르다는것을 알 수 있다.</p><p>다만 Canvas의 경우 DOM / SVG에서 가능한 개별 dot에 대한 이벤트 (click, mouseover등) 이 불가능하기 때문에 interaction이 필요한 작업이라면 다른 기법을 활용해야한다. 그렇기때문에 각 기법에 대한 이해를 높이고 작업의 목표에 따라서 자유자재로 적절한 기법을 사용하는것이 중요하겠다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9e1ce2396fcd" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[진짜로 Javascript Array, Object 복사하기 / 자르기 (Reference 하지 않기)]]></title>
            <link>https://medium.com/@idchoi2/%EC%A7%84%EC%A7%9C%EB%A1%9C-javascript-array-object-%EB%B3%B5%EC%82%AC%ED%95%98%EA%B8%B0-%EC%9E%90%EB%A5%B4%EA%B8%B0-reference-%ED%95%98%EC%A7%80-%EC%95%8A%EA%B8%B0-17f01a9db998?source=rss-2a236da04e48------2</link>
            <guid isPermaLink="false">https://medium.com/p/17f01a9db998</guid>
            <category><![CDATA[개발]]></category>
            <category><![CDATA[frontend]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[프론트엔드]]></category>
            <category><![CDATA[json]]></category>
            <dc:creator><![CDATA[Hoon CHOI]]></dc:creator>
            <pubDate>Fri, 29 Jun 2018 08:42:43 GMT</pubDate>
            <atom:updated>2018-06-29T08:42:43.219Z</atom:updated>
            <content:encoded><![CDATA[<p>오늘은 Javascript에서 Array혹은 Object를 복사하거나 잘라서 쓸때 발생하는 문제점을 알아보겠다.</p><p>아래 코드를 작성하면 어떤 결과값이 나올까?</p><pre>var arr1 = [<br>    {&quot;name&quot;: &quot;Joel&quot;, &quot;type&quot;: &quot;player&quot;}, <br>    {&quot;name&quot;: &quot;Tom&quot;, &quot;type&quot;: &quot;player&quot;}, <br>    {&quot;name&quot;: &quot;Sally&quot;, &quot;type&quot;: &quot;coach&quot;}<br>];</pre><pre><strong>var arr2 = arr1;</strong></pre><pre>arr2[0].name = &quot;Sam&quot;;</pre><pre>console.log(arr1);<br>// [{&quot;name&quot;: &quot;Sam&quot;, &quot;type&quot;: &quot;player&quot;}, ... ]<br>console.log(arr2);<br>// [{&quot;name&quot;: &quot;Sam&quot;, &quot;type&quot;: &quot;player&quot;}, ... ]</pre><p>arr1를 복사해서 arr2변수에 넣고 arr2의 첫번째 값을 변경했다. 당연히 arr1과 arr2의 첫번째 object값이 달라질것이라 생각했지만 arr1역시 변경된 값이 출력되었다.</p><p>Javascript는 = 연산자를 이용하면 물리적인 copy가 아닌 reference를 한다는것을 알 수 있다. 아래와 같이 slice를 이용하여 부분만 갖다써도 같은 문제가 발생한다.</p><pre>var arr1 = [<br>    {&quot;name&quot;: &quot;Joel&quot;, &quot;type&quot;: &quot;player&quot;}, <br>    {&quot;name&quot;: &quot;Tom&quot;, &quot;type&quot;: &quot;player&quot;}, <br>    {&quot;name&quot;: &quot;Sally&quot;, &quot;type&quot;: &quot;coach&quot;}<br>];</pre><pre><strong>var arr2 = arr1.slice(0, 1);</strong></pre><pre>arr2[0].name = &quot;Sam&quot;;</pre><pre>console.log(arr1);<br>// [{&quot;name&quot;: &quot;Sam&quot;, &quot;type&quot;: &quot;player&quot;}, ... ]<br>console.log(arr2);<br>// [{&quot;name&quot;: &quot;Sam&quot;, &quot;type&quot;: &quot;player&quot;}, ... ]</pre><p>Array를 reference하는 방법이 아닌 또 하나의 array를 복사해서 별도로 사용하고 싶다면 약간의 트릭을 써야한다.</p><pre>var arr1 = [<br>    {&quot;name&quot;: &quot;Joel&quot;, &quot;type&quot;: &quot;player&quot;}, <br>    {&quot;name&quot;: &quot;Tom&quot;, &quot;type&quot;: &quot;player&quot;}, <br>    {&quot;name&quot;: &quot;Sally&quot;, &quot;type&quot;: &quot;coach&quot;}<br>];</pre><pre><strong>var arr2 = JSON.parse(JSON.stringify(arr1));</strong></pre><pre>arr2[0].name = &quot;Sam&quot;;</pre><pre>console.log(arr1);<br>// [{&quot;name&quot;: &quot;Joel&quot;, &quot;type&quot;: &quot;player&quot;}, ... ]<br>console.log(arr2);<br>// [{&quot;name&quot;: &quot;Sam&quot;, &quot;type&quot;: &quot;player&quot;}, ... ]</pre><p>JSON.stringify로 array를 string화 한뒤에 다시 JSON.parse를 이용하여 array로 변환하는 작업을 해준다. 위의 코드를 이용하면 arr1과 arr2 두 array의 값이 달라진다.</p><pre>var arr1 = [<br>    {&quot;name&quot;: &quot;Joel&quot;, &quot;type&quot;: &quot;player&quot;}, <br>    {&quot;name&quot;: &quot;Tom&quot;, &quot;type&quot;: &quot;player&quot;}, <br>    {&quot;name&quot;: &quot;Sally&quot;, &quot;type&quot;: &quot;coach&quot;}<br>];</pre><pre><strong>var arr2 = JSON.parse(JSON.stringify(arr1[0]));</strong></pre><pre>arr2.name = &quot;Sam&quot;;</pre><pre>console.log(arr1);<br>// [{&quot;name&quot;: &quot;Joel&quot;, &quot;type&quot;: &quot;player&quot;}, ... ]<br>console.log(arr2);<br>// {&quot;name&quot;: &quot;Sam&quot;, &quot;type&quot;: &quot;player&quot;}</pre><p>arr1의 특정 부분만 따로 떼어내고 싶다면 위와같이 해주면 되겠다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=17f01a9db998" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[html5 video 태그 자동재생 이슈]]></title>
            <link>https://medium.com/@idchoi2/html5-video-%ED%83%9C%EA%B7%B8-%EC%9E%90%EB%8F%99%EC%9E%AC%EC%83%9D-%EC%9D%B4%EC%8A%88-f97e5d397516?source=rss-2a236da04e48------2</link>
            <guid isPermaLink="false">https://medium.com/p/f97e5d397516</guid>
            <category><![CDATA[개발]]></category>
            <category><![CDATA[videos]]></category>
            <category><![CDATA[autoplay]]></category>
            <category><![CDATA[자동재생]]></category>
            <category><![CDATA[html5]]></category>
            <dc:creator><![CDATA[Hoon CHOI]]></dc:creator>
            <pubDate>Wed, 09 May 2018 16:27:10 GMT</pubDate>
            <atom:updated>2018-05-09T16:27:10.688Z</atom:updated>
            <content:encoded><![CDATA[<p>사용자 경험(UX)을 공부하다 보면 배워야 할것이 참 많다. 그 중에 하나가 사용자의 예상을 벗어난 소리가 나는 미디어의 자동재생을 하지 말라는 것이다. 무작위적인 광고를 막고 불필요한 대역폭을 방지하기도 한다.</p><p>그런데 바로 한달 전 2018년 4월부터 크롬에서 이 자동재생 방지를 아에 브라우저 정책에 적용시켜버렸다.</p><p><a href="https://developers.google.com/web/updates/2017/09/autoplay-policy-changes">Autoplay Policy Changes | Web | Google Developers</a></p><p>위에 나온 내용은 아주 간단하다.</p><ul><li>소리가 없는 동영상은 자동재생이 가능하다.</li><li>다음의 경우에 소리가 있는 영상의 자동재생이 가능하다.<br>1. 같은 도메인안에서 interaction이 있을 경우<br>2. 데스크탑일때 <a href="https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#mei">Media Engagement Index (MEI)</a> 를 만족하는 경우<br>3. 모바일일때 해당 사이트를 홈 스크린에 즐겨찾기 한 경우</li><li>부모 Frame이 권한을 부여한 경우 자식 프레임안에서 자동재생이 가능하다.</li></ul><p>프로모션 사이트에서 비디오를 BG로 까는 경우가 많은데 이럴때 muted 속성을 추가하면 자동재생이 가능하다. muted 속성이 없다면 이제 대부분의 modern 브라우저에서 자동재생이 불가능할 것이다.</p><pre>&lt;<strong>video </strong>muted autoplay loop&gt;</pre><p>웹사이트 UX 측면에서는 좋은 방향이지만 브라우저단에서 아에 강제로 막아버렸다는점에서 개발자들에게 좋은 점수는 받지 못할것이다. 특히 HTML5 기반 게임이나 키오스크 미디어등 웹사이트가 아닌 다른 용도로 브라우저를 이용하는 이들에게는 치명적인 정책이라고 할 수 있다.</p><p>왜 이런 정책을 도입했는지 이해가 가지 않는것은 아니지만 부작용이 만만치 않기때문에 계속 유지될지는 의문이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f97e5d397516" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[파이어폭스로 프린트창 없이 인쇄하기]]></title>
            <link>https://medium.com/@idchoi2/%ED%8C%8C%EC%9D%B4%EC%96%B4%ED%8F%AD%EC%8A%A4%EB%A1%9C-%ED%94%84%EB%A6%B0%ED%8A%B8%EC%B0%BD-%EC%97%86%EC%9D%B4-%EC%9D%B8%EC%87%84%ED%95%98%EA%B8%B0-1a0c9401b878?source=rss-2a236da04e48------2</link>
            <guid isPermaLink="false">https://medium.com/p/1a0c9401b878</guid>
            <category><![CDATA[printers]]></category>
            <category><![CDATA[개발]]></category>
            <category><![CDATA[development]]></category>
            <category><![CDATA[firefox]]></category>
            <category><![CDATA[media]]></category>
            <dc:creator><![CDATA[Hoon CHOI]]></dc:creator>
            <pubDate>Wed, 25 Apr 2018 11:21:32 GMT</pubDate>
            <atom:updated>2018-04-25T11:21:32.442Z</atom:updated>
            <content:encoded><![CDATA[<p>미디어 개발을 하다보면 프린터로 출력할 때가 있다. 웹 기반의 미디어의 경우 브라우저에서 바로 인쇄가 진행되야 하는데 그럴때마다 브라우저의 기본 프린트 팝업창이 나오곤 한다.</p><p>어떤 액션을 취했을때 바로 프린팅을 하고 싶다면 Firefox를 이용하자. 아주 간단한 방법으로 프린트창을 없앨 수 있다.</p><ol><li>파이어폭스를 설치한다.</li><li>주소창에 about:config 를 입력한다. 그러면 다음과 같이 주의하라는 메세지가 나온다. 확인을 눌러주자. 파폭의 여러 환경을 조정하는 화면이다.</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*11lPCXwVy8CVlGRWXJGWNQ.png" /><figcaption>about:config</figcaption></figure><p>3. 마우스 우클릭후 New -&gt; Boolean을 선택한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*GUSw-tnyWR2TPbYyBI5VdQ.png" /></figure><p>4. <strong>print.always_print_silent </strong>이라고 입력한후 확인을 누른다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*8Kc89vuVDlSpESbweKJN3w.png" /></figure><p>5. <strong>true</strong> 값을 입력한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*--vptNNx6qTDyAf_eHfb9A.png" /></figure><p>이제 파이어폭스에서 프린트를 하면 팝업창없이 바로 프린트가 된다. 다시 되돌리고 싶다면 해당 값을 false로 하거나 아에 지우면 된다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1a0c9401b878" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Laravel 다국어(Localization)를 Javascript / vue.js 에 적용하기]]></title>
            <link>https://medium.com/@idchoi2/laravel-%EB%8B%A4%EA%B5%AD%EC%96%B4-localization-%EB%A5%BC-javascript-vue-js-%EC%97%90-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0-c747adb4dd0?source=rss-2a236da04e48------2</link>
            <guid isPermaLink="false">https://medium.com/p/c747adb4dd0</guid>
            <category><![CDATA[laravel]]></category>
            <category><![CDATA[개발]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[vuejs]]></category>
            <category><![CDATA[localization]]></category>
            <dc:creator><![CDATA[Hoon CHOI]]></dc:creator>
            <pubDate>Tue, 10 Apr 2018 11:56:09 GMT</pubDate>
            <atom:updated>2018-04-10T11:56:09.832Z</atom:updated>
            <content:encoded><![CDATA[<p>Laravel은 아주 훌륭한 다국어 시스템 (Localization)을 지원한다. <a href="https://laravel.com/docs/5.6/localization">공식문서</a>에 자세한 내용이 나와있기 때문에 따로 설명은 하지 않겟다.</p><p>하지만 Laravel + vue.js를 활용할 경우 Vue.js단에서 Laravel의 다국어에 직접 접근이 불가능하기때문에 연결하는 방법을 연구하다가 좋은 레퍼런스를 찾아서 소개할까 한다.</p><p><a href="https://medium.com/@serhii.matrunchyk/using-laravel-localization-with-javascript-and-vuejs-23064d0c210e">Using Laravel localization with JavaScript and VueJS</a></p><h3>방법</h3><p>순서는</p><ol><li>일단 모든 번역은 기본 <strong>Laravel 다국어로 정의</strong></li><li>route를 활용하여 해당 번역 언어를 <strong>스크립트 파일로 추출</strong></li><li>해당 <strong>스크립트를 불러와서 JS에 적용</strong></li><li><strong>Vue.js에서 사용</strong></li></ol><p>이 되겠다.</p><h3>1. Laravel 다국어로 정의</h3><p>이 부분은 생략한다.</p><h3>2. 스크립트 파일로 추출</h3><p>routes/web.php 파일에 다음 코드를 붙여보자.</p><pre>// Localization<br>Route<strong>::</strong>get(&#39;/js/lang.js&#39;, function () {<br>    $strings <strong>= </strong>Cache<strong>::</strong>rememberForever(&#39;lang.js&#39;, function () {<br>        <strong>$lang = config(&#39;app.locale&#39;);</strong><br><br>        $files   <strong>= </strong>glob(resource_path(&#39;lang/&#39; <strong>. </strong>$lang <strong>. </strong>&#39;/*.php&#39;));<br>        $strings <strong>= </strong>[];<br><br>        foreach ($files as $file) {<br>            $name           <strong>= </strong>basename($file, &#39;.php&#39;);<br>            $strings[$name] <strong>= </strong>require $file;<br>        }<br><br>        return $strings;<br>    });<br><br>    header(&#39;Content-Type: text/javascript&#39;);<br>    echo(&#39;window.i18n = &#39; <strong>. </strong>json_encode($strings) <strong>. </strong>&#39;;&#39;);<br>    exit();<br>})<strong>-&gt;</strong>name(&#39;assets.lang&#39;);</pre><p>/js/lang.js 경로로 접근하면 1번에서 정의한 번역본을 모두 포함하는 스크립트 파일을 불러온다. 굵은 글씨로 표시한 부분이 언어를 선택하는 부분인데 /config/app.php 에 ‘locale’ 값을 사용한다.</p><h3>3. 스크립트를 불러와서 JS에 적용</h3><p>자, 이제 해당 스크립트를 불러온뒤에 적용시켜보자.</p><pre>&lt;script src=&quot;/js/lang.js&quot;&gt;&lt;/script&gt;</pre><p>를 불러온뒤에 <strong>window.i18n</strong> 라는 object로 접근하여 해당 번역본을 추출할 수 있다.</p><h4>Laravel blade에서 적용</h4><pre>&lt;p&gt;{{ trans(&#39;common.hello&#39;) }}&lt;/p&gt;</pre><h4>Script에서 확인</h4><pre>console.log(i18.common.hello);</pre><h3>4. Vue.js 에서 사용</h3><p>Vue.js는 component단위로 개발하기때문에 prototype을 app.js 부분(new Vue정의하기 전) 에 생성하여 모든 component에서 접근이 가능하도록 한다. <a href="https://lodash.com/">lodash</a>를 이용하여 다음과 같이 prototype을 만들자.</p><pre>Vue.prototype.trans = <em>string </em>=&gt; <em>window</em>.<em>_</em>.get(<em>window</em>.<em>i18n</em>, <em>string</em>);</pre><p>그러면 어디서든 trans라는 함수를 이용하여 접근이 가능하다.</p><pre>// component.vue</pre><pre>&lt;template&gt;<br>      &lt;p&gt;{{ trans(&#39;common.hello&#39;) }}&lt;/p&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>     export default {<br>          mounted() {<br>              console.log(trans(&#39;common.hello&#39;));<br>          }<br>     }<br>&lt;/script&gt;</pre><h3>Session을 활용하여 언어 변경시</h3><p>여러개의 언어를 바로바로 어플리케이션내에서 바꾼다면 /js/lang.js 부분을 변경해줘야 한다. app.php에 정의된 값이 아닌 session을 이용하여 현재 언어를 선택한다. 굵은 글씨가 바뀐 부분이다.</p><pre>// Localization<br>Route<strong>::</strong>get(&#39;/js/lang.js&#39;, function () {<br>    $strings <strong>= </strong>Cache<strong>::</strong>rememberForever(&#39;lang.js&#39;, function () {<br>        <strong><em>$lang </em>= session()-&gt;get(&#39;lang&#39;, \Lang::getLocale());<br>        \Lang::setLocale(<em>$lang</em>);</strong><br><br>        $files   <strong>= </strong>glob(resource_path(&#39;lang/&#39; <strong>. </strong>$lang <strong>. </strong>&#39;/*.php&#39;));<br>        $strings <strong>= </strong>[];<br><br>        foreach ($files as $file) {<br>            $name           <strong>= </strong>basename($file, &#39;.php&#39;);<br>            $strings[$name] <strong>= </strong>require $file;<br>        }<br><br>        return $strings;<br>    });<br><br>    header(&#39;Content-Type: text/javascript&#39;);<br>    echo(&#39;window.i18n = &#39; <strong>. </strong>json_encode($strings) <strong>. </strong>&#39;;&#39;);<br>    exit();<br>})<strong>-&gt;</strong>name(&#39;assets.lang&#39;);</pre><p>주의할 점은 /js/lang.js가 캐시에 저장되어 있기때문에 언어를 바꾸는 실행을 할때 캐시를 비워주던가 lang.js의 버전을 업데이트 하던가 해서 lang.js를 새로 불러와야 한다.</p><p>캐시를 삭제하고 새로운 언어를 세션에 저장시키 위해서는 아래처럼 사용하도록 한다.</p><pre><em>// Store lang session<br>$request</em>-&gt;session()-&gt;put(&#39;lang&#39;, <em>$lang</em>);<br>\Lang::setLocale(<em>$lang</em>);</pre><pre>// Reset language cache<br>Cache::forget(&#39;lang.js&#39;);</pre><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c747adb4dd0" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vue.js 에서 정확한 CJK(중국어, 일본어, 한글) 데이터 바인딩]]></title>
            <link>https://medium.com/@idchoi2/vue-js-%EC%97%90%EC%84%9C-%EC%A0%95%ED%99%95%ED%95%9C-cjk-%EC%A4%91%EA%B5%AD%EC%96%B4-%EC%9D%BC%EB%B3%B8%EC%96%B4-%ED%95%9C%EA%B8%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B0%94%EC%9D%B8%EB%94%A9-d7cb57c67edc?source=rss-2a236da04e48------2</link>
            <guid isPermaLink="false">https://medium.com/p/d7cb57c67edc</guid>
            <category><![CDATA[한글바인딩]]></category>
            <category><![CDATA[vuejs]]></category>
            <category><![CDATA[개발]]></category>
            <category><![CDATA[frontend]]></category>
            <category><![CDATA[javascript]]></category>
            <dc:creator><![CDATA[Hoon CHOI]]></dc:creator>
            <pubDate>Mon, 26 Mar 2018 05:30:33 GMT</pubDate>
            <atom:updated>2018-03-26T05:30:33.815Z</atom:updated>
            <content:encoded><![CDATA[<p>Javascript framework에서 가장 편리한 기능은 데이터 바인딩이다. 구구절절 스크립트를 짜지않아도 알아서 바인딩되는 첫 느낌은 잊을 수 없다.</p><p>Vue.js에서는 <strong>v-model</strong> directive 를 사용하여 양방향 데이터 바인딩 (two-way data bindings)를 구현한다. 그런데 Vue.js에서는 약간 귀찮은 문제가 발생하는데 바로 한글, 일어, 중국어의 입력을 할때 정확한 바인딩이 되지 않는다는 점이다. 좀더 엄밀히 말하면 끝까지 바인딩이 되지않는다. 예를 들어보자.</p><p>keyword라는 이름의 Input element을 만들었다.</p><blockquote>&lt;input v-model=”<strong>keyword</strong>”&gt;</blockquote><p>위 Element에 keyup이벤트를 발생시켜 추천 검색목록을 띄우는 작업을 해보았다.</p><blockquote>&lt;input v-model=”<strong>keyword</strong>” v-on:keyup=”getRecommendations()”&gt;</blockquote><p>그리고 ‘지도’ 라는 검색을 해보았다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*VPi1zXk4Ih5y8VQpIkqP9g.png" /><figcaption>v-model directive를 이용한 한글 키워드 검색</figcaption></figure><p>위와 같이 ‘지도’ 를 검색하지 않고 ‘지’ 까지만 바인딩이 되었다.</p><p>Vue.js 공식 문서에도 원인이 나오며 해답을 같이 제시한다. (<a href="https://vuejs.org/v2/guide/forms.html#vmodel-ime-tip">https://vuejs.org/v2/guide/forms.html#vmodel-ime-tip</a>)</p><p>IME를 요구하는 즉 한글과 같은 언어가 제대로 업데이트되기 위해서는 <strong>v-model</strong>대신 <strong>input</strong> directive를 사용하라고 명시되어 있다. 다음과 같이 수정하면 제대로된 결과값을 얻을 수 있다.</p><blockquote>&lt;input v-on:input=<strong>”keyword</strong> = $event.target.value<strong>”</strong> v-on:keyup=”getRecommendations()”&gt;</blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*eIJwQFuFz7dwatoCReP3mw.png" /><figcaption>input directive를 이용한 한글 키워드 검색</figcaption></figure><p>보다시피 정확한 검색결과를 얻을 수 있다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d7cb57c67edc" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Bootstrap 4버전의 새로운 특징]]></title>
            <link>https://medium.com/@idchoi2/bootstrap-4%EB%B2%84%EC%A0%84%EC%9D%98-%EC%83%88%EB%A1%9C%EC%9A%B4-%ED%8A%B9%EC%A7%95-743a5636b111?source=rss-2a236da04e48------2</link>
            <guid isPermaLink="false">https://medium.com/p/743a5636b111</guid>
            <category><![CDATA[html]]></category>
            <category><![CDATA[bootstrap-4]]></category>
            <category><![CDATA[ui]]></category>
            <category><![CDATA[부트스트랩-4]]></category>
            <category><![CDATA[bootstrap]]></category>
            <dc:creator><![CDATA[Hoon CHOI]]></dc:creator>
            <pubDate>Wed, 07 Mar 2018 02:28:06 GMT</pubDate>
            <atom:updated>2018-03-07T02:28:06.472Z</atom:updated>
            <content:encoded><![CDATA[<p>지난 1월말, UI Framework중 가장 유명한 Bootstrap이 정식 4버전을 내놓았다. 앞자리가 바뀌는 메이저 버전업이니 만큼 이전과 다른점도 많고 사라진 요소도 많다. 최근 4버전을 처음 적용해보면서 이전버전과 크게 달라진점을 알아보겠다.</p><h3>1. LESS =&gt; SASS로 변경</h3><p>LESS를 버리고 SASS로 가는것은 추세인듯 하다. Bootstrap official package도 SASS를 기본 도입하고 있다. 각 component 마다 변수를 재정의 할 수 있다. 화면 개발자는 SASS는 꼭 익혀두는것이 좋다.</p><h3>2. IE 9이하 미지원</h3><p>4버전은 공식적으로 IE+10을 지원한다. iOS도 7버전 이상만을 지원한다.</p><h3>3. REM 적용</h3><p>4버전의 유닛은 REM로 이루어져 있다. PX / EM과 비교해서 많은 장점이 있는 만큼 멀티 디바이스 환경에서 최적화된 단위라고 볼 수 있다. REM에 대한 자세한 내용은 <a href="https://www.sitepoint.com/understanding-and-using-rem-units-in-css/">https://www.sitepoint.com/understanding-and-using-rem-units-in-css/</a> 에 잘 정리되어 있다.</p><h3>4. Breakpoint 다변화</h3><p>반응형웹의 Breakpoint가 다변화 되었다. 기존 모바일/태블릿/PC에서 5가지 variation으로 확장되었다. variable.scss에 다음과 같이 정의되어 있다.</p><pre>// Grid breakpoints<br>//<br>// Define the minimum dimensions at which your layout will change,<br>// adapting to different screen sizes, for use in media queries.<br><br><em>$grid-breakpoints</em>: (<br>  xs: 0,<br>  sm: 576<strong>px</strong>,<br>  md: 768<strong>px</strong>,<br>  lg: 992<strong>px</strong>,<br>  xl: 1200<strong>px<br></strong>) <strong>!default</strong>;</pre><h3>5. 그리드 레이아웃: float =&gt; flexbox</h3><p>기존의 .col-xx-# 클래스는 float를 이용하여 레이아웃을 잡았다. 4번에서는 float대신 flexbox를 적용한다. flexbox를 이용하면 모바일등 다양한 환경에서 좀더 유연한 코딩이 가능하다. 적용방법자체는 크게 차이나지 않는다.</p><h3>6. Card 적용</h3><p>기존에 panel, well등의 요소가 사라지고 card 요소가 추가되었다. 좀더 트렌드에 맞는 요소라고 볼 수 있다.</p><h3>7. Grunt -&gt; NPM</h3><p>Grunt역시 점점 대세에서 밀리는듯 하다. Bootstrap도 npm를 빌드 시스템으로 도입했다.</p><p>아직 이전버전에서 마이그레이션은 하지 않았다.</p><p>새로운 버전으로 코딩을 해본 소감은 확실히 최신 트렌드를 따라간다. 이전버전보다 좀더 멀티디바이스에 힘을 주었고 확실히 가벼워진 느낌이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=743a5636b111" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Laravel + Homestead 환경에서 DB 마이그레이션 / 접속 문제]]></title>
            <link>https://medium.com/@idchoi2/laravel-homestead-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-db-%EB%A7%88%EC%9D%B4%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%85%98-%EC%A0%91%EC%86%8D-%EB%AC%B8%EC%A0%9C-f9f38f81aea0?source=rss-2a236da04e48------2</link>
            <guid isPermaLink="false">https://medium.com/p/f9f38f81aea0</guid>
            <category><![CDATA[php]]></category>
            <category><![CDATA[개발]]></category>
            <category><![CDATA[dbs]]></category>
            <category><![CDATA[homestead]]></category>
            <category><![CDATA[laravel]]></category>
            <dc:creator><![CDATA[Hoon CHOI]]></dc:creator>
            <pubDate>Mon, 19 Feb 2018 15:36:02 GMT</pubDate>
            <atom:updated>2018-02-19T15:36:02.795Z</atom:updated>
            <content:encoded><![CDATA[<p>라라벨 (Laravel)을 다루는 개발자라면 Homestead 환경을 가상 환경을 만드는것을 추천한다. 손쉽게 다양한 환경으로 개발이 가능하기 때문이다.</p><p>보통 Homestead 환경에서 DB설정은 다음과 같이 해주게 된다. (.env)</p><pre>DB_CONNECTION=mysql<br>DB_HOST=localhost<br>DB_PORT=33060<br>DB_DATABASE=db_name<br>DB_USERNAME=homestead<br>DB_PASSWORD=secret</pre><p>여기서 db_name은 db명을 의미한다.</p><p>그런데 DB 스키마를 짜고 마이그레이션을 시도할때 다음과 같은 에러가 나오는 때가 있다.</p><blockquote>SQLSTATE[HY000] [2002] No such file or directory (SQL: select * from information_schema.tables where table_schema = db_name and table_name = migrations)</blockquote><p>이럴땐 다음과 같이 DB_HOST를 변경해주면 마이그레이션이 잘 진행된다.</p><pre>DB_CONNECTION=mysql<br><strong>DB_HOST=127.0.0.1</strong><br>DB_PORT=33060<br>DB_DATABASE=db_pautch<br>DB_USERNAME=homestead<br>DB_PASSWORD=secret</pre><p>DB_HOST를 127.0.0.1으로 그대로 두고 웹을 실행시키면 php에서 접속에러가 발생한다.</p><blockquote>[error] 3233#3233: *1629 FastCGI sent in stderr: “PHP message: PHP Fatal error: Maximum function nesting level of ‘512’ reached, aborting! in /home/vagrant/workspace/demo.test/vendor/laravel/framework/src/Illuminate/Support/Collection.php on line 1754</blockquote><p>마이그레이션 할때만 127.0.0.1을 써주고 보통은 localhost로 둬야겠다.</p><p>현재 사용중인 환경은 아래와 같다.</p><p>Laravel: 5.5</p><p>Vagrant: 2.0.1</p><p>PHP: 7.0</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f9f38f81aea0" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[자바스크립트 프레임워크에 고찰 (Javascript Frameworks)]]></title>
            <link>https://medium.com/@idchoi2/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%97%90-%EA%B3%A0%EC%B0%B0-javascript-frameworks-8cc34fbfc754?source=rss-2a236da04e48------2</link>
            <guid isPermaLink="false">https://medium.com/p/8cc34fbfc754</guid>
            <category><![CDATA[자바스크립트]]></category>
            <category><![CDATA[angular]]></category>
            <category><![CDATA[framework]]></category>
            <category><![CDATA[개발]]></category>
            <category><![CDATA[프론트엔드]]></category>
            <dc:creator><![CDATA[Hoon CHOI]]></dc:creator>
            <pubDate>Wed, 31 Jan 2018 01:04:18 GMT</pubDate>
            <atom:updated>2018-01-31T01:06:38.325Z</atom:updated>
            <content:encoded><![CDATA[<p>프론트엔드 개발자라면 자바스크립트 프레임워크를 한번쯤 들어보았거나 이미 실무에 적용하고 있을것이다. jQuery가 나온뒤에 AngularJS가 선풍적인 인기를 끌었고 최근엔 Angular로 급속히 넘어가는 추세다. 그리고 React, Vue.js, backbone등도 한번쯤 들어보았을것이다.</p><p>필자는 AngularJS를 처음으로 자바스크립트 프레임워크에 첫 발을 내딛었다.</p><p>그러던중 최근 흥미로운 글을 발견했다.</p><h3>The Brutal Lifecycle of JavaScript Frameworks</h3><p><a href="https://stackoverflow.blog/2018/01/11/brutal-lifecycle-javascript-frameworks/">The Brutal Lifecycle of JavaScript Frameworks - Stack Overflow Blog</a></p><p>글 전체를 번역하지는 않겠다. 간략하게 요약하자면</p><p>어떤 프레임워크를 사용하냐 혹은 어떤 프레임워크가 유행이냐보다 <strong>자신이 문제해결에 필요한 가장 적합한 도구</strong>를 익히는것이 중요하다는 것이다.</p><p>필자는 Angular와 Vue.js를 주로 사용하고 학습하고 있다.</p><p>그 이유는 Angular는 Ionic을 사용하기 때문이며 Vue.js는 Laravel이 채택한 프레임워크기 때문이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/675/0*twwgPCdiQKhwPrcX.png" /><figcaption>PHP사용자가 상대적으로 vue.js이용률이 높다.</figcaption></figure><p>사람들이 많이 사용할 수록 Stackoverflow에 질문이 많이 올라오면서 답을 찾기 빨라지며 오픈소스도 많기 때문에 장점이 많다. 그렇기에 처음으로 JS Framework를 접하는 사람들에게는 Angular나 React를 권하고 싶다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/609/0*ggRg8H-ECTN4GxUS.png" /><figcaption>최근의 추세는 Angular와 React가 강세</figcaption></figure><p>이미 특정 프레임워크를 학습한 사람들 역시 다른 프레임워크를 어렵지 않게 학습할 수 있을것이라 생각된다. 글에도 나타나지만 요즘에는 특정 프레임워크를 채용한다는 채용글도 많기때문에 구직의 전략중 하나도 활용할 수 도 있을듯 하다.</p><p>자바스크립트 프레임워크는 이제 막 시작단계이기 때문에 변화 속도가 빠르다. 그만큼 사장되는 제품도 많을것이고 앞으로 나올 제품도 많을것이다. 그렇기때문에 더욱더 하나의 Tool에 얽매일 필요가 없다.</p><p>비단 개발 뿐만이 아니다. Tool은 도움을 줄 뿐이다. 결국 본질은 Tool 자체에 있는것이 아니라 문제를 해결해야하는 것이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8cc34fbfc754" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>