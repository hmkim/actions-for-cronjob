<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Mijeong (Rachel) on Medium]]></title>
        <description><![CDATA[Stories by Mijeong (Rachel) on Medium]]></description>
        <link>https://medium.com/@mjspring?source=rss-a5b93d2efa4c------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*P3f0w5k0MnKXK41ScWaPSg.jpeg</url>
            <title>Stories by Mijeong (Rachel) on Medium</title>
            <link>https://medium.com/@mjspring?source=rss-a5b93d2efa4c------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 00:07:02 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@mjspring" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[[WHY 시리즈 1]E.008 — 서비스 추상화, Mongoose, Webhook]]></title>
            <link>https://medium.com/@mjspring/why-%EC%8B%9C%EB%A6%AC%EC%A6%88-1-e-008-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%B6%94%EC%83%81%ED%99%94-mongoose-webhook-b7ea2d3b0e?source=rss-a5b93d2efa4c------2</link>
            <guid isPermaLink="false">https://medium.com/p/b7ea2d3b0e</guid>
            <category><![CDATA[software-engineering]]></category>
            <category><![CDATA[mongoose]]></category>
            <category><![CDATA[webhooks]]></category>
            <category><![CDATA[why]]></category>
            <category><![CDATA[abstract]]></category>
            <dc:creator><![CDATA[Mijeong (Rachel)]]></dc:creator>
            <pubDate>Thu, 25 Apr 2019 06:17:26 GMT</pubDate>
            <atom:updated>2019-04-25T06:18:32.527Z</atom:updated>
            <content:encoded><![CDATA[<h3>[WHY 시리즈 1]E.008 — 서비스 추상화, Mongoose, Webhook</h3><blockquote>‘코드와 서비스 만들기를 좋아하는 소프트웨어 엔지니어’로 일하고 있다. 엔지니어는 문제를 해결하는 사람이다. 문제를 해결하는 과정에는 여러 가지 선택이 존재할 수 있다. 가능한 최선의 결과를 위해, 항상 내 선택의 Why에 답할 수 있는 사람이 되고자 한다. 매주, 한 주 동안 내가 결정한 선택의 Why에 대해 정리하고자 한다.</blockquote><p>베트남에서 프로덕트를 만든 지 벌써 4개월이라는 시간이 흘렀다. 동시에 프로덕트 오픈 일자가 정말 코앞으로 다가왔다. 실제로 다양한 종류의 테스트 기간을 거치면서 예상하지 못했던 상황들 그리고 오류들을 개선해 나가고, 프로덕트 오픈 준비를 병행하며 참 정신없는 시간을 보내고 있다. 그사이에 또 다시 나는 면 수습을 겪고, 면 수습 회고 글도 작성하며 WHY 시리즈 글을 한동안 작성할 시간이 부족했다고 핑계를 대어본다. 어쨌거나 다시 WHY 시리즈 글을 쓰며 키보드를 두드리고 있는 지금, 업무 노트를 뒤적이며 그동안 쌓아두었던 주제에 대해 역시나 Why를 던져본다.</p><blockquote>Note: <a href="https://medium.com/@mjspring/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%98%95%EC%A0%9C%EB%93%A4-%EB%B2%A0%ED%8A%B8%EB%82%A8-%ED%94%84%EB%A1%9C%EB%8D%95%ED%8A%B8-%ED%8C%80-3%EA%B0%9C%EC%9B%94-%ED%9A%8C%EA%B3%A0-1caee5cc3d5f">우아한 형제들, 베트남 프로덕트 팀 3개월 회고</a></blockquote><h3>Why?</h3><h4>1. 서비스 추상화</h4><p>상점 목록을 검색해서 반환하는 엔드포인트가 있다. 테스트를 진행하면서 해당 ‘엔드포인트를 사용하는 주체’에 따라 ‘상점 목록을 검색하는 필터의 조건이 달라지도록 개선’할 필요가 있었다. 사용하는 주체는 엔드포인트를 호출하는 Session의 role을 이용하여 식별할 수 있는 상황이었다. 처음에는 서비스 레이어에 존재하는 search 함수에서 role을 매개변수로 전달받고, 특정 role의 경우 필터의 조건을 변경하는 방향으로 구현을 시도했다. 하지만, 다른 방향으로 role이 아닌 flag를 매개변수로 전달받는 것으로 구현을 완성했다.</p><ul><li>Why? search 함수의 역할과 책임은 상점 목록을 검색하는 일이다. <strong>role을 식별하는 것은 상점 서비스 레이어에 존재하는 search 함수의 역할을 벗어나는 일</strong>이라고 판단했다. 오히려 서비스 레이어 전, 컨트롤러 레이어에서 혹은 search 함수를 호출하기 전 단계에서 수행되어야 하는 로직이라고 판단했다.</li><li>Why? 특정 값(role)을 매개변수로 전달받는 것 보다, flag를 매개변수로 전달받는 것이 <strong>더 적절한 추상화</strong>라고 판단했다. role 자체를 매개변수로 전달받았을 때에는 해당 필터 조건을 오직 Session의 role에 따라서만 적용할 수 있었다. 하지만, flag를 사용한다면 추후에 role이 아닌 다른 종류의 값에도 얼마든지 기존 search 함수의 변경 없이 적용 가능하다고 판단했다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*LMezfNVQrU0Mv9urLCY1Uw.png" /><figcaption>항상 주옥같은 리드의 피드백</figcaption></figure><h4>2. Mongoose toObject vs toJson</h4><p>기능이 추가되면 자연스럽게 필요한 모델이 추가된다. 우리는 도큐먼트 기반 MongoDB와 이를 위한 ODM(Object Data Mapping)인 Mongoose를 사용하고 있다. 최근, 필요한 모델을 추가하면서 자연스럽게 Schema에 toObject와 toJson을 정의하고 있는 나를 발견했다. 그러다 문득, Mongoose model을 작성하면서 왜 toObject와 toJson을 모두 정의해야 하는지 의문이 들었다. Mongoose의 코드를 살펴보면 toObject와 toJson 모두 결국 같은 함수($toObject)를 호출하는데?</p><ul><li>Why? <strong>toOject</strong>는 <strong>Mongoose Document 유형의 객체를 자바스크립트의 Object 유형으로 변환</strong>할 때 사용된다. 주로 비즈니스 로직을 구현할 때 MongoDB에서 조회한 결과를 자바스크립트의 Object 유형으로 변환하기 위해 사용된다. 이때 속성의 추가/수정/삭제 작업이 필요하다면 toObject의 transform 함수를 정의하여 사용하고 있다.</li><li>Why? <strong>toJson</strong>은 <strong>Mongoose Document 유형이 JSON.stringify()를 통해 변환</strong>될 때 사용된다. 즉, Mongoose Schema 모델에 toJson이 정의되어 있으면 해당 모델 객체에 대한 JSON.stringify() 호출 시 toJson에 정의된 내용을 이용하여 변환된다. 주로 express의 res.json()을 통해 MongoDB에서 조회한 결과를 응답으로 반환할 때, 내부적으로 JSON.stringify()가 호출되어 사용되고 있다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*SesmLF9xPqc36YzNvZNs0Q.png" /><figcaption>Mongoose Document의 toObject 정의</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*KgUn-cbTRGqnxvdsydYfDQ.png" /><figcaption>Mongoose Document의 toJSON 정의</figcaption></figure><blockquote>Note: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON()_behavior">toJSON() behavior</a> 참고</blockquote><blockquote>Note: <a href="https://github.com/Automattic/mongoose/issues/2072">Documentation: clarify the difference between toObject() and toJSON() 이슈</a> 참고</blockquote><h4>3. Webhook validation 제거</h4><p>이전 글에서도 몇 번 언급했던 것처럼 현재 우리 프로덕트는 다양한 3rd party 서비스를 이용하고 있다. 우리가 직접 3rd party의 API 호출하여 로직을 구현하는 경우가 대부분이지만 필요에 따라 3rd party에서 전달하는 Webhook을 통해 동기화를 할 필요가 있다. 최근, 쿠폰 서비스를 제공하는 3rd party의 Webhook을 받아 처리하는 로직의 오류 로그를 발견했다. 기존에는 오류 없이 잘 사용되던 부분이었고, 코드 상의 다른 변경은 없었기 때문에 갑작스런 오류 로그에 당황했다. 결국, 3rd party에서 전달하는 Webhook 매개변수 중 반드시 필요한 속성이 아닌 경우, 검증하는 로직을 제거하기로 결정했다.</p><ul><li>Why? <strong>3rd party Webhook의 인터페이스</strong>가 사전 공지 없이 <strong>변경</strong>되었다. 기존에 문제없이 실행되던 Webhook에서 갑작스런 오류가 발생했던 이유는 Webhook에서 전달하는 매개변수 구조가 변경되었기 때문이었다. 변경 내역에 대한 공지를 내가 놓친것은 아닌지 다시 확인해 보았지만, 사전 공지 없이 기존과 다른 Webhook 매개변수 구조가 전달되었던 것이다. 3rd party 서비스는 100% 우리의 제어 아래에 있을 수는 없다. 즉, 또 다시 이런일이 발생하지 않으리라는 보장이 없었다. 약속된 인터페이스를 강하게 검증할 것인가 혹은 서비스가 유지되는 것에 더 초점을 맞출것인가에서 우리는 후자의 우선순위가 높다고 판단했다.</li><li>Why? 앞서 언급한 것 처럼, 이와 같은 문제는 언제든지 발생할 수 있다. 우리에게 중요한 것은, 해당 Webhook이 전달하는 매개변수 중 <strong>우리에게 반드시 필요한 매개변수만 식별</strong>하는 일이었다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*jAX36PlkMaNuEHHAf19kHw.png" /><figcaption>우리 팀 화났음.png</figcaption></figure><p>다음 주는 또 이번 주보다 더 정신없고 바쁘겠지만, 힘든 와중에도 프로덕트 오픈이 이렇게 기다려지는 건 참 오랜만인 것 같다. 문제가 발생하지 않을 수는 없지만, 문제가 생기면 또 어때. 참 좋은 동료들과 잘 해결해나갈 수 있는 자신감이 있다. 이제 WHY 시리즈 글 밀리지 말자 다짐.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b7ea2d3b0e" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[우아한 형제들, 베트남 프로덕트 팀 3개월 회고]]></title>
            <link>https://medium.com/@mjspring/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%98%95%EC%A0%9C%EB%93%A4-%EB%B2%A0%ED%8A%B8%EB%82%A8-%ED%94%84%EB%A1%9C%EB%8D%95%ED%8A%B8-%ED%8C%80-3%EA%B0%9C%EC%9B%94-%ED%9A%8C%EA%B3%A0-1caee5cc3d5f?source=rss-a5b93d2efa4c------2</link>
            <guid isPermaLink="false">https://medium.com/p/1caee5cc3d5f</guid>
            <category><![CDATA[회고]]></category>
            <category><![CDATA[우아한형제들]]></category>
            <dc:creator><![CDATA[Mijeong (Rachel)]]></dc:creator>
            <pubDate>Fri, 12 Apr 2019 07:19:07 GMT</pubDate>
            <atom:updated>2019-04-12T07:19:07.623Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/567/1*jXTZMqLx2TEq-HMkPMfTeA.png" /><figcaption>2017년, 페이스북에 적었던 새 회사에 대한 소망</figcaption></figure><p>이 페이스북 글 이후, 네이버 랩스를 거쳐 현재 <strong>우아한 형제들 베트남 프로덕트 팀</strong>에 존재하고 있다. 3개월 수습 기간이 지난 기념으로 또다시 회고 글을 쓰려고 보니, 그래 나는 프로 수습러다. 어쨌든, 베트남 호찌민(사이공)이라는 곳에서의 면 수습은 처음이니 즐거운 마음으로 회고 글을 작성해본다.</p><h3>Why?</h3><p>지인들은 알겠지만 우아한 형제들에 입사하기 전, 나는 약 5개월 동안 자발적 백수였다. 아무것도 하지 않고 살아보며 마음이 가는 대로 이것저것 해보다가 개발자가 아닌 삶도 고려해 보겠다는 생각으로 시작한 자발적 백수 생활이었다. 그리고 난 여전히 개발자로 살고 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1010/1*uoTUPxhgJh_DoqBMadcnEw.png" /><figcaption>페이스북에 끄적인 백수생활 회고 feat. 진지충</figcaption></figure><p>그렇다면 다시 선택한 개발자의 삶을 왜 우아한 형제들과 함께했을까?</p><h4>1. 함께 일해보고 싶었던 동료</h4><p>나에게 우아한 형제들 베트남에서의 일을 처음 제안한 사람은 Joy다. Joy는 현재 팀의 리더이자 예전부터 개발자/스타트업 행사에서 함께 스피커로 섰던 사람이다. 함께 일해본 적은 없지만, 그 사람의 생각과 이야기를 전달하는 방식에 있어서 참 닮고 싶다는 생각을 많이 했었다.</p><p>Joy는 본인을 개발자가 아닌 ‘<strong>프로덕트를 만드는 사람</strong>’으로 정의한다. 그리고 프로덕트를 만들기 위한 사람, 프로세스, 의사결정 방법 등을 많이 고민하고 행동하는 사람이라 생각했다. 내가 언젠가 다시 리더라는 역할을 맡게 된다면 이런 사람이었으면 좋겠다는 생각을 했다. 그리고 기회가 된다면 함께 일해보고 내 생각이 맞는지 확인해보고 싶었으며, 우리는 현재 같은 팀에서 프로덕트를 만들고 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/532/1*Kp3ucJo7y2flZJxvC5LDLg.png" /><figcaption>Joy의 페이스북 프로필: 만드는 사람</figcaption></figure><h4>2. 해외 근무환경</h4><p>2019년 1월 2일이 나의 입사일이다. 입사일에 나는 잠실에 있는 본사로 출근하지 않고 호찌민 행 비행기를 타러 인천국제공항에 갔다. 그렇게 낯선 타지에서 입사일을 맞이했다.</p><p>아주 예전부터 우리나라가 아닌 다른 나라, 다른 환경에서 일해보고 싶다는 막연한 희망이 있었다. 낯선 환경에서 어떻게든 살아내는 내 모습을 보고싶은 마음이 있었던 것 같다. 그와 동시에 불안한 내 정신이 너무 급격한 변화를 감당하기 버거워하지 않을까 걱정도 했다. 다행히도, 낯선 타지이지만 어느정도 신뢰가 있는 지인이 꾸리는 팀에 속한다는 사실에 좋은 시작이라는 생각이 들었고 함께하게 되었다.</p><h4>3. 권한과 책임이 주어지는 환경</h4><p>규모가 있는 회사를 갈 때마다 나의 가장 큰 우려는 결정된 일만 잘 수행하면 되는 환경이다. 우아한 형제들 역시 동일한우려를 했었지만 적어도 베트남 프로덕트팀은 그렇지 않을거라는 기대가 있었다.</p><p>빠르게 프로덕트를 빌드하고 시장의 반응을 확인해야 하는 환경이다. 그러기에는 철저하게 리소스가 부족한 상황이었고, 오히려 이 상황이 나에게는 반가웠다. 프로덕트를 만들기 위해 서로가 각자의 역할을 구분 짓지 않고, 일이 되게끔 하는 일을 찾아서 해야 하는 환경이기 때문이다. 스스로 일을 찾고 행동하기 위해서는 권한과 책임이 동시에 주어지는 환경이어야 가능하며, 그 속에서 개인은 성장한다고 믿는 사람이다. 당시, 현재 팀은 그럴 수 있는 곳이라고 판단했다.</p><p>물론, 처음 결정 시에는 리더들과의 대화를 통해서만 판단해야 했기에 리스크도 존재했지만 적어도 3개월이 지난 지금 그 판단은 틀리지 않았다고 생각한다.</p><h3>What?</h3><p>그럼, 3개월이 지난 이 시간 동안 나는 이곳에서 무엇을 해왔을까? 어떤 결과를 내고 성장을 하고 있을까?</p><h4>쿠폰 시스템 구축 — 3rd party 서비스 분석</h4><p>첫 출근을 하고 내가 맡은 주 업무는 <strong>쿠폰 시스템 구축</strong>이었다. 쿠폰 시스템 구축의 복잡도는 이전 경험을 통해 알고 있었기에 살짝 불안감이 엄습했다. 하지만, 순수하게 인하우스로 개발하는 것이 아닌 3rd party 서비스를 이용하기로 결정했고 integration에 필요한 분석/설계/구축 그리고 마케팅팀과의 협업 등을 진행했다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/796/1*2pDiJz7H_dfEomfmCF7m7A.png" /><figcaption>Joy는 이미 계획하고 있었다.png</figcaption></figure><ul><li>3rd party가 필요한 이유: 서비스 오픈 일자는 정해져 있었고, 프로모션은 반드시 오픈 시 포함되어야 하는 기능이며, 인적 리소스는 부족한 상황이었다(쿠폰 도메인을 주 업무로 진행하는 사람은 혼자였으니). 일정 수준의 기능, 품질을 보장하며 쿠폰 시스템을 구축하기 위해 3rd party 도입은 적절한 결정이었다고 생각한다.</li><li>기능 분석: 3rd party 쿠폰 시스템에 기대하는 기본적인 기능은 몇 가지 유형의 쿠폰 발급, 관리였다. 예를 들어, 특정 상점 대상 정률 할인 혹은 첫 주문 고객 대상 정액 할인과 같은 유형의 쿠폰 발급이 가능한지 직접 기능을 사용하며 분석했다. 또한, 여러가지 유형의 쿠폰을 상상하며 어느 수준까지 쿠폰 조건을 설정할 수 있는지 테스트를 진행했다.</li><li>API 분석: 클라이언트 앱 &lt;&gt; 우리 서버 &lt;&gt; 3rd party 서버 구조의 통합을 위해 3rd party 에서 제공하는 API를 분석했다. 필요한 API가 존재하는지, 존재한다면 우리 서버에서는 어느정도의 의존성을 갖고 원하는 기능을 구축할 수 있을지 분석하는 작업을 진행했다.</li></ul><h4>쿠폰 시스템 구축 — 마케팅 팀 요구사항 수립 지원</h4><p>백엔드 엔지니어 포지션으로 입사를 했지만 나의 업무 영역을 개발로 한정지을 수는 없었고, 스스로 원하지도 않았다. 내 경험으로 구체화하여 이야기 하자면, 나는 마케팅 팀이 운영하게될 쿠폰 시스템을 구축하고 있었고, 마케팅 팀이 요구사항을 더 빠르고 구체적으로 수립할 수 있도록 내가 할 수 있는 일을 해야했고 그러기를 원했다.</p><ul><li>3rd party 기능 분석을 진행하면서 다양한 유형의 쿠폰을 생성 및 발급해봤다. 이 경험과 우리 서비스 특성을 결합하여 발급 가능하다고 생각되는 유형의 쿠폰을 정의하고 마케팅팀에 선제안하는 방식으로 일을 진행시켰다.</li><li>그렇게 마케팅팀에서 제안하는 첫 요구사항을 모두 구현할 수 있을 거라고 기대하지는 않았다. 우리는 <strong>요구사항과 우리가 할 수 있는 것을 서로 맞춰나가는 과정</strong>이었다. 요구사항을 온전히 개발로 풀어가기에 주어진 시간과 자원 내에서 한계가 있다고 생각한다면, 요구사항을 다른 방식으로 만족시키기 위해 솔루션을 찾거나 마케팅팀과 커뮤니케이션 하는 방식으로 일을 진행했다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*PWC9CcWy63h9lvlAZWeqXw.png" /><figcaption>무언가 열심히 했는데 벌써 기억이 잘 안나.png</figcaption></figure><h4>쿠폰 시스템 구축 — 3rd party 및 우리 서버 integration</h4><p>3rd party 서비스를 분석하고, 마케팅팀의 요구사항이 구체화되기 시작할 때 우리 서버와의 integration을 위한 설계와 구축 작업을 진행했다. 개발자 동료들과 <strong>설계 방향에 대해 지속적으로 논의하며 모두가 동의하는 방향</strong>으로 일을 진행했다.</p><ul><li>설계의 기본 방향은 3rd party를 걷어낸다고 할 때, 언제든 쉽게 분리할 수 있는 구조를 유지하자였다. 기존 데이터 모델이 쿠폰 데이터 모델에 의존하지 않도록, 애플리케이션 코드 레벨에서 쿠폰 관련 로직이 다른 비즈니스 로직과 공존하지 않도록 모듈화하여 분리시키는 원칙을 가지고 작업을 진행했다.</li><li>그렇게 구축한 쿠폰 시스템의 결과는 다음과 같다. 마케팅 운영자들이 3rd party dashboard를 통해 쿠폰을 생성 및 수정하면 우리 서버와 동기화, 사용자들이 앱을 통해 쿠폰을 확인 및 사용, 첫 구매 고객 대상 정액/정률 할인 지원, 특정 상점 대상 정액/정률 할인 지원 등.</li></ul><h4>그 외,</h4><p>내가 쿠폰 시스템 구축을 주 업무라고 표현한 이유는, 프로덕트 팀원이라면 프로덕트를 완성하기 위해 필요한 일은 담당 업무의 구분 없이 할 수 있어야 한다고 생각하기 때문이다. 쿠폰 시스템 구축에 3개월 중 가장 많은 시간을 할애한 것은 맞지만 다음과 같이 필요한 업무도 병행했다.</p><ul><li>우리 프로덕트의 핵심 기능인 주문 관련 기능을 조금씩 개선했다. 나보다 먼저 프로덕트 개발을 진행하고 있었던 동료가 대부분의 기능을 구축해 두신 상황이었다. 나 역시 핵심 비즈니스 로직에 대해 당연히 동기화가 필요했기 때문에 작은 이슈이지만 티켓을 할당받아 주문 관련 기능을 개선해나갔다.</li><li>백엔드 엔지니어 포지션으로 있는 팀원은 나를 포함해서 2명이다. 프로덕트 오픈 날짜이 다가오면서 자연스럽게 인프라 구축도 진행해야 했다. 기본적으로 AWS, MongoDB Atlas 등을 이용하여 인프라 구축을 진행했다.</li><li>개인적으로 공유하고 피드백받는 걸 매우 좋아한다. 그 속에서 가장 많이 성장할 수 있다고 생각한다. 지금 팀에서도 역시 Pull Request 기반으로 서로의 코드를 리뷰 받고 개선하는 과정이 자연스럽게 스며들어있다. 하루의 업무 시간 중, 동료의 코드를 리뷰하는 일을 높은 우선순위로 두고 진행하는 팀이다. Pull Request, 코드 리뷰와 관련된 에피소드는 아래 링크에서 확인할 수 있다.</li></ul><blockquote>1. <a href="https://medium.com/@mjspring/why-%EC%8B%9C%EB%A6%AC%EC%A6%88-1-e-007-pull-request%EC%9D%84-%ED%86%B5%ED%95%B4-%EC%9E%A1%EC%9D%80-%EC%98%A4%EB%A5%98%EB%93%A4-93b8056a7c5a">[WHY 시리즈 1]E.007 — Pull Request를 통해 잡은 오류</a></blockquote><blockquote>2. <a href="https://medium.com/@mjspring/why-%EC%8B%9C%EB%A6%AC%EC%A6%88-1-e-006-%EC%BB%A4%EB%B0%8B-%EA%B7%B8%EB%9E%98%ED%94%84-mongoose-virtual-pull-request-bbde3d690d3">[WHY 시리즈 1]E.006 — 커밋 그래프, mongoose virtual, Pull Request</a></blockquote><h3>Who?</h3><p>그럼 나는 지금 누구와 일하고 있는지에 대해 이야기하고자 한다. <strong>회고 글을 가장한 동료 자랑</strong>이 될 수도 있겠다.</p><ul><li><strong>팀장</strong>이자 <strong>PM</strong>이자 <strong>엔지니어</strong>인 Joy. 나를 베트남 프로덕트 팀으로 이끌어 준 분이다. 팀장이자 PM이자 엔지니어로 존재하고 있다. Joy와 일을 해보는 건 처음이지만, 내가 Joy에게 기대했던 모습 그 이상의 모습을 보고있다. 내가 만난 매니저 중 <strong>가장 합리적인 의사결정을 잘하는 사람</strong>이다. 사업 초기인 만큼 수많은 의사결정이 Joy 앞에 놓여있다. 항상 당황하지 않고 우리에게 필요한 일을 냉정하게 판단하고, 우리가 <strong>이 일을 왜 해야 하는지</strong>를 모두에게 동기화시킨다. 또한, Joy는 팀장으로서 우리 팀을 위한 일을 한다기보다 <strong>우리 팀이 만들게 될 프로덕트를 위한 일</strong>을 한다. 프로덕트를 만들어가는 팀원들에게 부담스러울 수 있는 요구사항이 들어와도, 프로덕트를 위해 필요한 요구사항이라면 주어진 리소스 내에서 해결할 수 있는 방법을 끊임없이 고민하고 결정한다. 그러면서 동시에 개발을 손에서 놓지 않는다. 운영자를 위한 도구는 외로이 홀로 개발을 진행하고, 클라이언트 개발도 여력이 닿는 한 돕고 있다. 가끔은 엄청난 책임감의 무게가 비출 때도 있어서 걱정도 된다. 하지만 조이라면 그 무게를 동료들에게 현명하게 나누고 지금처럼 잘 이끌어 나갈 것이라는 믿음이 있다. 앞서 언급한 것 처럼, 내가 매니저가 된다면 조이처럼.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/828/1*2Bw5hRj0W28GXfQTbVhIOA.jpeg" /><figcaption>괜한 말이었나 아.. 아냐.png</figcaption></figure><ul><li><strong>공유</strong>하고 <strong>피드백</strong> 주고받기를 선호하는 개발팀. 손가락이 아플 정도로 글로 쓰고 공유했던 코드리뷰 문화가 있다. 개발자 어느 하나 코드리뷰 합시다 라고 주장하지 않았고, 자연스럽게 스며들어있는 문화였다. 필수 업무로 서로의 코드를 리뷰하고, 개발 프로세스 중 불편한 혹은 비효율적인 부분이 있다면 자발적으로 개선해 나가고 공유한다. 이러한 환경에서 서로의 성장에 동기 부여가 된다는 점은 당연하고, 내가 느끼는 가장 좋은 점은 ‘우리 코드 리뷰 해야해요, 우리 테스트 코드 만들어야 해요’ 설득시키기 위한 노력을 굳이 하지 않아도 된다는 점이다. 또 하나의 자랑거리는, 내가 개발해야 할 일이 아닌 <strong>우리가 만들어야 할 프로덕트를 먼저 생각하는 개발팀</strong>이라는 점.</li><li><strong>배달의 민족 DNA</strong>를 보유한 PM 및 디자이너. 베트남 프로덕트 팀은 또 다른 PM 및 디자이너 2분을 제외하면 모두 우아한 형제들로 새롭게 입사한 분들이다. 한국의 배달의 민족 서비스와는 별도로 베트남에서 새로운 서비스를 구축하고 있지만, 자칫 배달의 민족 색깔을 잃어버릴 수 있는 상황에서 PM 및 디자이너 2분의 적절한 방향 제시는 소중하다. 더 다행인 것은 고집하기보다는 <strong>유연하게 새로운 시장과 변화를 받아들이시는 분들</strong>이라는 점이다.</li></ul><p>수습이 해제되고 회고 글을 써야 하는 시기가 하필(?) 매우 바쁠 수밖에 없는 시기와 맞물려서 평소만큼 개요를 고민하지 않고 두서없이 써 내려갔다. 내가 우아한 형제들 베트남 프로덕트 팀을 <strong>왜</strong> 선택했고, 그래서 <strong>무엇</strong>을 했으며, <strong>누구</strong>와 함께하는지 이야기하고 싶었으니 개인적인 목표는 달성했다. 앞으로 서비스가 런칭되고 확장되면서 분명 새로운 동료들과 함께해야 하는 시기가 다가올 텐데, 지금처럼 힘들지만 즐겁고 서로 동기부여가 될 수 있는 좋은 동료들과 계속하기를 기대한다. 얼마 남지 않은 베트남 프로덕트 팀의 첫 서비스 런칭도 화이팅.</p><p>앞으로 나의 우아한 형제들 베트남 프로덕트 팀 생활을 더 응원한다. <strong>자, 이제 면 수습 회고 글은 당분간 그만쓰자 제발.</strong></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1caee5cc3d5f" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[WHY 시리즈 1]E.007 — Pull Request을 통해 잡은 오류들]]></title>
            <link>https://medium.com/@mjspring/why-%EC%8B%9C%EB%A6%AC%EC%A6%88-1-e-007-pull-request%EC%9D%84-%ED%86%B5%ED%95%B4-%EC%9E%A1%EC%9D%80-%EC%98%A4%EB%A5%98%EB%93%A4-93b8056a7c5a?source=rss-a5b93d2efa4c------2</link>
            <guid isPermaLink="false">https://medium.com/p/93b8056a7c5a</guid>
            <category><![CDATA[software-engineering]]></category>
            <category><![CDATA[why]]></category>
            <category><![CDATA[software]]></category>
            <category><![CDATA[pull-request]]></category>
            <dc:creator><![CDATA[Mijeong (Rachel)]]></dc:creator>
            <pubDate>Sun, 17 Mar 2019 10:13:50 GMT</pubDate>
            <atom:updated>2019-03-17T10:17:37.973Z</atom:updated>
            <content:encoded><![CDATA[<h3>[WHY 시리즈 1]E.007 — Pull Request를 통해 잡은 오류들</h3><blockquote>‘코드와 서비스 만들기를 좋아하는 소프트웨어 엔지니어’로 일하고 있다. 엔지니어는 문제를 해결하는 사람이다. 문제를 해결하는 과정에는 여러 가지 선택이 존재할 수 있다. 가능한 최선의 결과를 위해, 항상 내 선택의 Why에 답할 수 있는 사람이 되고자 한다. 매주, 한 주 동안 내가 결정한 선택의 Why에 대해 정리하고자 한다.</blockquote><p>프로덕트의 첫 오픈을 위한 QA 전, 마지막 Phase가 종료됐다. 그만큼 정신없고 바쁜 일상을 보내고 있지만 빨리 우리 서비스가 출시되는 날을 기대하는 마음이 더 크다. (밑밥이었고) 사실 이번 주에 어떤 키워드로 글을 작성할지 매일 정리하지 못했다. 그래서 주말이 시작되는 토요일 아침, ‘<strong>아! Pull Request로 배포 전 미리 발견한 오류에 대해 이야기를 해볼까?</strong>’ 라는 생각이 들었고 이 글을 쓰게 되었다. 왜 Pull Request를 해야 하는 지에 대한 글이 될 수 있기 때문에 WHY 시리즈에 포함하는 것으로 결정. 토요일, 그리고 이 글을 쓰는 일요일 모두 틈틈이 일을 하면서 Pull Request를 통해 잡은 오류들에 대한 이야기를 적어본다.</p><h3>What?</h3><h4>1. 거리 계산</h4><p>두 지점 사이의 거리를 기반으로 배달비를 계산하는 로직이 포함된 Pull Request를 리뷰했다. 거릿값을 소수점 둘째 자리까지 처리하고, 계산된 배달비를 백의 자리까지 처리하는 코드였다. 코드를 리뷰하다가 문득 예전에 내가 작성한 두 지점 사이의 거리와 관련된 코드가 생각났다. 해당 부분에서도 동일한 로직으로 거릿값을 처리해야 할 것 같다고 피드백을 남겼다. 동일한 개념의 값을 다른 형식의 값으로 반환할 수 있었던 오류 상황을 예방할 수 있었다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*knVPuqNDfFLzwj3lk1BCbQ.png" /><figcaption>동료와 나의 행복한 PR 리뷰 #1</figcaption></figure><p>Pull Request의 author가 예측하지 못했던 부분을 reviewer가 (직접 작성했던 코드이기 때문에)발견한 좋은 사례라고 생각한다.</p><h4>2. 시각 포맷</h4><p>서비스 자체의 open 및 close 시간에 따라 서비스 이용 가능 여부를 확인하는 로직이 포함된 Pull Request를 생성했다. configuration에 open 및 close 시간 정보를 설정해 두었고, 내가 시각 포맷 자체를 다르게 생각하고 있었다는 사실을 동료의 피드백을 통해 알게 되었다. 물론 다른 포맷을 사용해도 서비스 이용 가능 여부를 정상적으로 반환할 수는 있겠지만, 당연히 우리 서버에서 사용하는 시각 포맷은 통일시키는 것이 좋다고 생각했다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*qamjmC_kxIdPirEGHv-BcQ.png" /><figcaption>동료와 나의 행복한 PR 리뷰 #2</figcaption></figure><p>Pull Request의 author가 잘못 이해하고 있는 부분을 reviewer를 통해 발견한 좋은 사례라고 생각한다. (util 함수 작업도 얻고..)</p><h4>3. 데이터 검증</h4><p>외부 서비스로부터 webhook을 받아서 처리하는 로직이 포함된 Pull Request를 생성했다. 나는 해당 webhook에서 전달되는 데이터 구조와 동일한 인터페이스를 생성하여 서버 로직을 생성했다. 인터페이스를 통해 webhook에서 전달된 데이터를 검증하겠다는 의도도 포함되어 있었다. 동료는 webhook에서 전달되는 데이터가 약속된 포맷이 아니라면, 애초에 우리 서버 로직을 태우지 않고 거부하는게 옳은 방향 같다는 피드백을 주었고 동의했다. 내부 인터페이스로 관리하던 데이터를 request validation으로 처리하도록 수정했다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*GoZgS6xUcsodc3ARJQBpcQ.png" /><figcaption>동료와 나의 행복한 PR 리뷰 #3 그리고 좋아하는 Joy</figcaption></figure><p>사전에 설계 방향에 대해 피드백을 요청했으면 좋았겠지만, Pull Request의 reviewer를 통해 더 나은 설계 방향에 대한 피드백을 받을 수 있었던 좋은 사례라고 생각한다.</p><h4>4. 응답 필드 오류</h4><p>주문과 관련된 로직을 전반적으로 개선한 Pull Request를 리뷰했다. 주문 프로세스가 가장 핵심이며, 많은 기능을 필요로하기 때문에 볼륨이 더 커지기 전 프로세스를 다듬고 리팩토링하는 것이 필요하다고 판단하여 이루어진 작업이었다. 해당 Pull Request는 다양한 end point에 영향을 주기 때문에 reviewer인 나도 평소보다 많은 시간을 할애해서 꼼꼼하게 리뷰했다. 그러던 중, coupon 관련 end point에서 필요로 하는 필드가 포함되지 않는 오류를 발견했다. 평소 coupon 관련 로직은 내가 많은 부분 관여하고 구현했기 때문에 발견할 수 있었다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*0D5jsvc-UTulrtaLrBchgg.png" /><figcaption>동료와 나의 행복한 PR 리뷰 #4</figcaption></figure><p>2시간이 넘게 해당 Pull Request만 열심히 리뷰했던 기억이 있다. 누군가 놓칠 수 있는 부분을 서로의 리뷰를 통해 발견할 수 있는 경험은 언제나 옳고 좋다.</p><p>마지막으로 또 다른 재미를 주는 Pull Request 갈무리를 공개하고, 다음 주에도 여전히 행복한 Pull Request를 기대한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ySeDCye6TWp-26uA3DS3sQ.png" /><figcaption>모두가 즐거운 리뷰</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*-dfEdQVae5LtLuSdQwDgnQ.png" /><figcaption>지적 무서워, 왜 때문에 Like 누른 클라이언트 개발자</figcaption></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=93b8056a7c5a" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[번역] TDD 변절자: TDD는 설계 기법이 아니다.]]></title>
            <link>https://medium.com/@mjspring/%EB%B2%88%EC%97%AD-tdd-%EB%B3%80%EC%A0%88%EC%9E%90-tdd%EB%8A%94-%EC%84%A4%EA%B3%84-%EA%B8%B0%EB%B2%95%EC%9D%B4-%EC%95%84%EB%8B%88%EB%8B%A4-2519b05474d0?source=rss-a5b93d2efa4c------2</link>
            <guid isPermaLink="false">https://medium.com/p/2519b05474d0</guid>
            <category><![CDATA[test-driven-development]]></category>
            <category><![CDATA[tdd]]></category>
            <category><![CDATA[design]]></category>
            <category><![CDATA[solid-principles]]></category>
            <category><![CDATA[software-engineering]]></category>
            <dc:creator><![CDATA[Mijeong (Rachel)]]></dc:creator>
            <pubDate>Sun, 10 Mar 2019 23:53:53 GMT</pubDate>
            <atom:updated>2019-03-10T23:54:52.046Z</atom:updated>
            <content:encoded><![CDATA[<blockquote>얼마 전, 페이스북에서 트립스토어 CTO 이신 규원님의 글을 보았다. ‘TDD는 안 해도 되지만 설계는 안하면 안돼요.’ 라는 글과 함께 본인의 <a href="https://gyuwon.github.io/blog/2019/03/03/tdd-is-not-a-design-methodology.html?fbclid=IwAR0mQn64MyvSHErsztAvIi1EKEXi9bZYn-OsCPsSC5U7J0GiUQBXC2tqi9o">블로그 글</a>을 공유하셨다. TDD를 적극적으로 공부하게끔 영향을 주신 분의 글이기에 블로그 글을 정독했고, 마지막에 소개해주신 글 또한 정독해보고자 하는 마음에서 Mark Seemann의 ‘<a href="https://blog.ploeh.dk/2010/12/22/TheTDDApostate/">The TDD Apostate</a>’라는 글을 번역했다.</blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*tRyn1-IdnArv8nUXKmJs2A.png" /><figcaption>규원님 페이스북 갈무리</figcaption></figure><p>나는 2003년부터 테스트 주도 개발(Test-Driven Development)을 하고 있다. 여전히 테스트 주도 개발을 좋아하며, 앞으로도 계속할 것으로 생각한다. 수년간 테스트 주도 개발을 테스트 주도 개발(Test-Driven Development)로 간주할지 혹은 테스트 주도 설계(Test-Driven Design)로 간주해야 할지 논의가 반복됐다. 나는 오랜 시간 테스트 주도 개발은 둘 다를 의미한다고 생각했지만, 더 이상은 그렇게 생각하지 않는다.</p><blockquote>테스트 주도 개발은 좋은 설계 방법론이 아니다.</blockquote><p>나는 수년간 테스트 주도 개발을 통해 정말 많은 코드를 작성해왔다. 테스트가 설계를 움직이는 코드를 작성해왔고, 오랜 시간 신중함의 결과인 설계를 위한 코드를 작성해왔으며, 테스트는 이미 잘 짜여진 아이디어의 표현일 뿐이었다.</p><p>테스트만으로 설계를 작성한 코드는 특별히 좋은 결과가 아니었다고 말할 수 있다. 비록 테스트가 가능하고 어느 정도 느슨한 결합이라는 결과가 있었지만, 일관성 및 좋은 추상화 관점에서는 여전히 스파게티 코드(Spaghetti Code)였다.</p><p>반면에, 자전거로 출퇴근하는 몇 시간 동안 신중하게 생각한 결과였던 AutoFixture 2.0와 같은 결과물은 매우 만족스럽다. 이 역시 코드는 테스트 우선으로 작성되었지만, 설계는 미리 충분히 고려된 것이었다.</p><p>나는 이런 생각을 하게 되었다: 나는 테스트 주도 설계에 실패한 것인가? 아니면 전체적으로 개념을 잘못 생각하고 있던 것일까?</p><p>이것은 대답하기 쉬운 질문이 아니다. 무엇이 좋은 설계를 만들까? SOLID 설계 원칙이 좋은 설계를 위한 꽤 좋은 지표라고 가정해보자. 그렇다면, 테스트 주도는 우리를 SOLID 설계로 이끌 수 있을까?</p><h4>테스트 주도 개발 vs 단일 책임 원칙(Single Responsibility Principle)</h4><p>테스트 주도 개발은 ‘<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">단일 책임 원칙</a>’의 적용을 보장할 수 있을까? 이 질문에 대한 대답은 ‘아니다!’ 라고 어렵지 않게 이야기할 수 있다. 테스트 주도 개발이 ‘<a href="https://en.wikipedia.org/wiki/God_object">God 클래스</a>’로 가는 것을 전혀 예방하지 못하는 사례를 많이 보았고, 나 역시 그러했다.</p><p>오히려 단일 책임 원칙 위배를 더 어렵게 만드는 생성자 주입(Constructor Injection)이 도움이 된다. (역주: 생성자 주입을 위한 매개변수가 많아질 때, 해당 클래스에서 많은 책임을 지고 있다는 신호로 받아들일 수 있기 때문이라고 생각)</p><p>현재까지 테스트 주도 개발의 점수: 0</p><ul><li>단일 책임 원칙: 하나의 클래스는 하나의 책임을 가지며, 변경 이유 역시 하나여야 함</li><li>God 클래스: 너무 많은 책임과 역할을 담당하고 있는 클래스</li></ul><h4>테스트 주도 개발 vs 개방 폐쇄 원칙(Open-Closed Principle)</h4><p>테스트 주도 개발은 ‘<a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">개방 폐쇄 원칙</a>’을 따르도록 유도할까? 이에 대한 대답은 조금 어렵다. 나는 예전에 <a href="https://blog.ploeh.dk/2009/06/05/TestabilityIsReallyTheOpenClosedPrinciple/">테스트 용이성(Testability)이 개방 폐쇄 원칙의 다른 이름일 뿐</a>이라고 주장했으며, 이는 테스트 주도 개발이 개방 폐쇄 원칙을 이끈다는 의미를 내포한다. 하지만, 개방 폐쇄 원칙을 다루기 위한 몇 가지 방법들이 존재하기 때문에 이 문제는 단순하게 대답할 수 없다.</p><ul><li>상속 (Inheritance)</li><li>합성 (Composition)</li></ul><p>Roy Osherove의 책 <a href="http://affiliate.manning.com/idevaffiliate.php?id=1150_91">The Art of Unit Testing</a>에 따르면, 추출(Extract) 및 오버라이드(Override)는 일반적으로 단위 테스트의 요령이다. 개인적으로는 잘 사용하지 않지만, 상속을 통해 간접적으로 개방 폐쇄 원칙으로 향할 수 있다.</p><p>하지만 우리는 상속보다는 합성을 선호해야 한다는 사실을 알고 있다.(역주: 상속을 적절히 사용하지 못했을 때 상위 클래스에 깊게 의존적인 하위 클래스를 만들 수 있는 등의 문제 때문이라고 생각) 과연 테스트 주도 개발은 이 방향으로 갈 수 있을까? 예전에 언급했듯이, 테스트 주도 개발은 <a href="http://xunitpatterns.com/Test%20Double.html">테스트 대역(Test Double)</a>을 사용하는 경향이 있고, 테스트 대역은 합성을 통해 개방 폐쇄 원칙을 달성하는 방법 중 하나이다.</p><p>내가 좋아하는 또 다른 합성을 위한 기술은 ‘<a href="https://en.wikipedia.org/wiki/Decorator_pattern">데코레이터(Decorator) 패턴</a>’을 이용하여 기능을 추가하는 것이다. 이 기술은 원래의 타입이 인터페이스를 구현하는 경우에만 가능하다. ‘테스트 대상(System Under Test, SUT)’이 인터페이스를 구현하도록 테스트를 작성할 수는 있지만, 테스트 주도 개발 자체가 이 방향으로 이끄는 것은 아니다.</p><p>하지만, 테스트 주도 개발이 개방 폐쇄 원칙에 대해 일부 점수를 얻어야 함을 부정할 수는 없다.</p><p>현재까지 테스트 주도 개발의 점수: 0.5</p><ul><li>개방 폐쇄 원칙: 확장에는 열려있고, 수정에는 닫혀있어야 한다는 원칙</li><li>데코레이터 패턴: 객체에 추가적인 요건을 동적으로 추가할 때 이용하는 패턴</li></ul><h4>테스트 주도 개발 vs 리스코프 치환 원칙(Liskov Substitution Principle)</h4><p>테스트 주도 개발은 ‘<a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">리스코프 치환 원칙</a>’을 따르도록 유도할까?</p><p>블랙박스 테스트는 테스트 대상(SUT)이 종속성에 깊게 관여하는 것을 막을 수는 없지만, 적어도 그 방향으로 이끌지는 않는다. 테스트 주도 개발은 테스트 대상의 종속성에 대해 어느 방향으로도 이끌지 않는다.</p><p>실수로 리스코프 치환 원칙을 위반하는 인터페이스 구현을 테스트할 수 있을까? 물론, 쉽게 가능하다. 이전 글에서 논의했듯이, <a href="https://martinfowler.com/bliki/HeaderInterface.html">헤더 인터페이스(Header Interface)</a>의 사용은 리스코프 치환 원칙 위반으로 쉽게 끌어들인다. 인터페이스에 구성 요소가 많을 때, 리스코프 치환 원칙 위반 가능성은 커진다.</p><p>테스트 주도 개발은 헤더 인터페이스로 이끌 가능성이 크며, 실제로 나는 이러한 일을 여러 번 겪었다. 테스트 주도 개발은 리스코프 치환 원칙 준수를 권장하지 않는다.</p><p>현재까지 테스트 주도 개발의 점수: 0.5</p><ul><li>리스코프 치환 원칙: 상위 타입을 하위 타입으로 치환해도 상위 타입을 사용하는 프로그램은 정상 동작해야 한다는 원칙</li></ul><h4>테스트 주도 개발 vs 인터페이스 분리 원칙(Interface Segregation Principle)</h4><p>테스트 주도 개발은 ‘<a href="https://en.wikipedia.org/wiki/Interface_segregation_principle">인터페이스 분리 원칙</a>’을 지향할까? 그렇지 않다. 테스트 주도 개발은 쉽게 헤더 인터페이스가 되도록 테스트 대상(SUT)을 테스트할 수 있다.</p><p>현재까지 테스트 주도 개발의 점수: 0.5</p><ul><li>인터페이스 분리 원칙: 클라이언트가 자신이 사용하지 않는 메서드에 의존하지 말아야 한다는 원칙 (한 개의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스)</li></ul><h4>테스트 주도 개발 vs 의존성 역전 원칙(Dependency Inversion Principle)</h4><p>테스트 주도 개발은 ‘<a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">의존성 역전 원칙</a>’을 따르도록 유도할까? 그렇다.</p><p>테스트 용이성(Testability)을 위한 모든 노력 — 즉, 테스트 대역(Test Double)으로 의존성을 대체할 수 있는 능력 — 은 의존관계 역전 원칙과 같은 방향으로 이끈다.</p><p>우리는 이러한 느슨한 결합(loose coupling)을 적절한 애플리케이션 설계로 착각하는 경우가 있고, 이것이 테스트 주도 개발과 좋은 설계를 혼동하는 이유이다. 느슨한 결합을 좋은 설계를 위한 전제 조건으로 생각하지만, 이 자체로는 충분하지 않다.</p><p>현재까지 테스트 주도 개발의 점수:1.5</p><ul><li>의존성 역전 원칙: 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다는 원칙</li></ul><h4>테스트 주도 개발은 SOLID 설계 원칙을 보장하지 않는다.</h4><p>테스트 주도 개발에게 5점 만점에 1.5점의 점수를 줬다. 나는 테스트 주도 개발 자체가 SOLID 설계 방향으로 이끌지 않는다고 확신한다. SOLID 설계를 지향하기 위해 테스트 주도 개발을 사용하는 것은 가능하지만, 테스트 주도 개발 자체로 부족한 것을 보완하려는 노력을 항상 병행해야 한다. 이는 테스트 주도 개발 자체에 본질적으로 포함된 개념이 아니기 때문이다.</p><p>분명, SOLID 설계 원칙 자체가 적절한 API 설계를 위한 전부가 아니라고 주장할 수 있으며, 나 역시 동의한다. 하지만 테스트 주도 개발에 대한 나의 경험을 기반으로 나는 결론을 내릴 수 있다. 테스트 주도 개발은 우리를 좋은 설계로 이끌지 않으며, 이는 설계 기법이 아니다.</p><p>나는 좋은 생산성을 위해 여전히 테스트 코드를 먼저 작성하지만, 설계는 해당 영역 밖에서 결정한다. 나는 테스트 주도 개발 변절자다.</p><blockquote>오역 혹은 설명이 부족한 내용은 계속해서 보완할 예정입니다. 읽으시는 분들의 피드백 환영합니다.</blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2519b05474d0" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[WHY 시리즈 1]E.006 — 커밋 그래프, mongoose virtual, Pull Request]]></title>
            <link>https://medium.com/@mjspring/why-%EC%8B%9C%EB%A6%AC%EC%A6%88-1-e-006-%EC%BB%A4%EB%B0%8B-%EA%B7%B8%EB%9E%98%ED%94%84-mongoose-virtual-pull-request-bbde3d690d3?source=rss-a5b93d2efa4c------2</link>
            <guid isPermaLink="false">https://medium.com/p/bbde3d690d3</guid>
            <category><![CDATA[why]]></category>
            <category><![CDATA[mongoose]]></category>
            <category><![CDATA[software-engineering]]></category>
            <category><![CDATA[pull-request]]></category>
            <category><![CDATA[git]]></category>
            <dc:creator><![CDATA[Mijeong (Rachel)]]></dc:creator>
            <pubDate>Sun, 03 Mar 2019 07:33:44 GMT</pubDate>
            <atom:updated>2019-03-03T07:33:44.384Z</atom:updated>
            <content:encoded><![CDATA[<h3>[WHY 시리즈 1]E.006 — 커밋 그래프, mongoose virtual, Pull Request</h3><blockquote>‘코드와 서비스 만들기를 좋아하는 소프트웨어 엔지니어’로 일하고 있다. 엔지니어는 문제를 해결하는 사람이다. 문제를 해결하는 과정에는 여러 가지 선택이 존재할 수 있다. 가능한 최선의 결과를 위해, 항상 내 선택의 Why에 답할 수 있는 사람이 되고자 한다. 매주, 한 주 동안 내가 결정한 선택의 Why에 대해 정리하고자 한다.</blockquote><p>어느덧, 팀 내부 QA가 2주 앞으로 다가왔다. 프로덕트 팀의 PM, 개발자, 디자이너 모두 바쁘지만 즐겁게(?) 하루하루를 보내고 있다. 개발 프로젝트에도 많은 기능이 코드로 담기면서 소스 코드 관리를 더욱 신경 쓰게 되고, 자칫 복잡도가 높아질 수 있는 상황을 경계하며, 바쁜 와중에도 서로의 코드를 정성껏 리뷰하는 시간을 보냈다. 정신없이 지나간 이번 주에도 Why를 던져본다.</p><h3>Why?</h3><h4>1. git 커밋 그래프</h4><p>프로덕트의 Phase 3 종료가 다가오면서 하루에 Pull Request 올라오는 양이 점점 많아지고 있다. 서버를 함께 개발하는 동료와 나는 매일 잊지 않고 서로의 코드를 리뷰하고, merge 시키는 작업을 하고 있다. 서버 프로젝트는 기본적으로 커밋 내역을 squash 하지 않고 merge 커밋을 생성하고 있다. (클라이언트 프로젝트는 커밋 내역을 하나의 커밋으로 묶는 squash 전략을 채택하고 있다.) 그러다 몇 번, 예쁘게 그려나가고 있었던 서버 프로젝트의 커밋 그래프가 못생겨지는 경험을 했다. 예측되겠지만, rebase and merge를 수행하지 않았기 때문이었다. 동료와 나는 항상 rebase and merge를 수행하면서 커밋 그래프를 예쁘게 유지하기로 다짐했다.</p><ul><li>Why? <strong>작업 내용과 흐름을 파악</strong>하기에 좋다. ‘커밋 그래프가 못생겨지면 어때, 코드가 잘 merge 돼서 동작하기만 하면 되지’ 라고 생각할 수도 있다. 하지만 예쁜 커밋 그래프는 하나의 프로젝트에서 여러 명의 개발자가 진행하는 작업의 내용과 흐름을 파악하기에 좋다.</li><li>Why? 이슈 발생 시, <strong>기능을 rollback</strong> 하기에 좋다. 어떠한 이유로 기능을 rollback 하고자 했을 때, (Pull Request의 단위가 적절한 범위의 기능이라는 전제하에)다른 기능에 영향을 주지 않으면서 특정 commit 시점으로 깔끔하게 reset 할 수 있다.</li><li>Why? <strong>심리적 안정감</strong>을 준다. 예쁜 커밋 그래프가 개발자에게 주는 심리적 안정감은 무시할 수 없다.</li></ul><p>아직은 명확하게 우리만의 전략이 수립되지는 않았지만, 각 프로젝트별로 하나의 공감대를 형성하고 조금씩 완성해나가고 있다. 우리의 프로젝트 성격과 상황에 맞는 전략이 계속해서 자리 잡기를 기대한다.</p><blockquote>Note: <a href="https://justhackem.wordpress.com/2018/01/30/writing-git-commit-messages-using-vscode/#more-7897">Visual Studio Code를 사용해 Git 커밋 메시지 작성하기</a> 확인 (commit 메시지에 대한 이야기지만, 역시 소스 코드 관리를 위해 읽어보면 좋을 글이다.)</blockquote><blockquote>Note: <a href="http://woowabros.github.io/experience/2017/10/30/baemin-mobile-git-branch-strategy.html">우린 Git-flow를 사용하고 있어요</a> 확인</blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/548/1*OMIvhgfnQbpHTCWZZTET9w.png" /><figcaption>예쁜 커밋 그래프</figcaption></figure><h4>2. mongoose virtual</h4><p>현재 서버는 도메인의 분리가 명확히 되지 않고, 하나의 Monolithic 시스템으로 동작하고 있다. 이후에 실행하게 될 도메인 분리를 위해, 데이터 컬렉션은 가능한 단순하게 그리고 복잡도가 낮은 구조로 가져가자는 철학으로 개발을 진행하고 있다. 그러던 중, 현재 데이터 모델에는 존재하지 않지만 추가적으로 필요한 필드가 생겼고, 처리 방법에 대해 고민했다. 결론은, 컬렉션에 새로운 컬럼을 추가하는 대신 mongoose에서 제공하는 virtual 키워드로 모델 계층에서 처리하는 것으로 결정했다.</p><ul><li>Why? 해당 필드는 조회 요청 시 마다 <strong>동적으로 변경되는 값</strong>이며, <strong>데이터 베이스에 지속할 필요가 없다.</strong> 이 필드는 요청 조건에 따라 동적으로 계산되어 응답으로 반환되어야 한다. 또한, 논리적으로 특정 데이터 컬렉션에 포함되는 것이 명확하기 때문에 virtual 키워드를 이용하여 데이터베이스에 지속하지는 않으면서, 데이터 모델 계층에서 처리가 가능하다.</li></ul><p>하지만, 무분별하게 virtual 키워드를 사용하다 보면 데이터 컬렉션은 가능한 단순하게 복잡도 낮은 구조로 가져가겠다는 철학에 위배될 수 있겠다는 생각이 들었다. 만능은 없다.</p><blockquote>Note: <a href="https://mongoosejs.com/docs/guide.html#virtuals">Mongoose — Virtuals</a></blockquote><h4>3. 이번 주의 Pull Request</h4><p>흥미로웠던 Pull Request가 있었다. 두 지점 사이의 거리를 계산하는 로직 개선에 대한 Pull Request 였고, 나의 Pull Request를 리뷰해 준 동료와 많은 댓글 쓰레드를 통해 피드백을 주고받았다. 좌표가 매개변수로 넘어올 때와 넘어오지 않을 때 분기하는 코드에서 논의가 시작됐다.</p><ul><li>Why? 동료: 좌표가 넘어오는 경우 불필요하게 쿼리가 2번 실행된다.</li><li>Why? 나: side effect의 원인이 될 수 있는 let 변수를 사용하고 싶지 않다. 쿼리가 1번 혹은 2번 실행될 수 있는 현재 상황이 성능에 큰 영향을 준다고 생각하지 않으며 오히려 let 변수를 제거하는 방향이 맞다고 생각한다.</li><li>Why? 동료: 쿼리가 1번 실행되면서 let 변수를 제거한 코드로 만들어 보았다. (미정 개이득)</li><li>Why? 나: 가독성이 조금 떨어지는 것 같은데, 작성해주신 코드에서 쿼리하는 부분을 별도의 모듈로 분리하고 개선해 보았다.</li></ul><p>결국 우리는 <strong>성능</strong>, <strong>side effect</strong>, <strong>가독성</strong> 관점에서 서로 피드백을 주고받다가 함께 만족할 수 있는 코드로 개선했다. 이건, 동료와 나의 Pull Request 리뷰에 대한 자랑이 맞다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/640/1*P-0nwPb5uGb8qaPj9IZg0Q.png" /><figcaption>왜 때문에 퇴근을 안하고 다들 PR을 노려보고 있는거죠?</figcaption></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bbde3d690d3" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Qus 왜 하려고 하는지 명확히 하고 개발하자 찡구야]]></title>
            <link>https://medium.com/@mjspring/qus-%EC%99%9C-%ED%95%98%EB%A0%A4%EA%B3%A0-%ED%95%98%EB%8A%94%EC%A7%80-%EB%AA%85%ED%99%95%ED%9E%88-%ED%95%98%EA%B3%A0-%EA%B0%9C%EB%B0%9C%ED%95%98%EC%9E%90-%EC%B0%A1%EA%B5%AC%EC%95%BC-c56a5995c011?source=rss-a5b93d2efa4c------2</link>
            <guid isPermaLink="false">https://medium.com/p/c56a5995c011</guid>
            <dc:creator><![CDATA[Mijeong (Rachel)]]></dc:creator>
            <pubDate>Sat, 23 Feb 2019 10:01:50 GMT</pubDate>
            <atom:updated>2019-02-23T10:01:50.810Z</atom:updated>
            <content:encoded><![CDATA[<p><a href="https://medium.com/u/2e41794ba3e1">Qus</a> 왜 하려고 하는지 명확히 하고 개발하자 찡구야</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c56a5995c011" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[WHY 시리즈 1]E.005 — map/filter, 반환 유형, 비동기 호출]]></title>
            <link>https://medium.com/@mjspring/why-%EC%8B%9C%EB%A6%AC%EC%A6%88-1-e-005-map-filter-%EB%B0%98%ED%99%98-%EC%9C%A0%ED%98%95-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%98%B8%EC%B6%9C-3e39914f6aa7?source=rss-a5b93d2efa4c------2</link>
            <guid isPermaLink="false">https://medium.com/p/3e39914f6aa7</guid>
            <category><![CDATA[asynchronous]]></category>
            <category><![CDATA[why]]></category>
            <category><![CDATA[software-development]]></category>
            <category><![CDATA[software-engineering]]></category>
            <category><![CDATA[pull-request]]></category>
            <dc:creator><![CDATA[Mijeong (Rachel)]]></dc:creator>
            <pubDate>Sat, 23 Feb 2019 09:49:34 GMT</pubDate>
            <atom:updated>2019-02-23T09:49:34.398Z</atom:updated>
            <content:encoded><![CDATA[<h3>[WHY 시리즈 1]E.005 — map/filter, 반환 유형, 비동기 호출</h3><blockquote>‘코드와 서비스 만들기를 좋아하는 소프트웨어 엔지니어’로 일하고 있다. 엔지니어는 문제를 해결하는 사람이다. 문제를 해결하는 과정에는 여러 가지 선택이 존재할 수 있다. 가능한 최선의 결과를 위해, 항상 내 선택의 Why에 답할 수 있는 사람이 되고자 한다. 매주, 한 주 동안 내가 결정한 선택의 Why에 대해 정리하고자 한다.</blockquote><p>한국 출장과 설 연휴로 인해 오랜만에 글을 쓰고 있다. 일은 점점 바빠지고, 동료들은 점점 더 좋아지는 시간을 보내고 있다. 약 2달 동안, 서버 프로젝트에 40개 정도의 Pull Request가 오고 갔으며, 클라이언트 프로젝트는 Pull Request 100개가 넘어가면서 축하 케익을 먹기도 했다. 이번 글에서는, 동료의 Pull Request 리뷰로 수정하게 된 코드에 대해 Why를 던져본다.</p><h3>Why?</h3><h4>1. map, filter</h4><p>사용자들이 사용할 수 있는 쿠폰을 위한 개발을 한창 진행 중이다. 쿠폰은 하나를 사용할 수도 있지만, 여러 쿠폰이 사용될 수 있는 구조로 설계되었다. 자연스럽게 코드에는 for 루프와 쿠폰 유형으로 인한 if 문이 빈번하게 사용되었다. 해당 코드가 포함된 Pull Request에서 동료의 피드백을 계기로 for 루프와 if 문을 만나면 map과 filter로 변경하는 시도를 시작했다.</p><ul><li>Why? <strong>코드의 가독성이 향상</strong>된다. 개인적으로는 for 루프와 if 문이 포함된 코드를 읽어가다 보면 로직이 자연스럽게 읽히지 않는 경우가 적지 않게 존재했다. 그런 나의 코드를 리뷰하는 동료는 얼마나 피곤했겠는가. map과 filter를 사용하게 되면서 코드가 하고자 하는 로직이 명확하게 읽히기 시작했다. 최소 10줄 이상으로 표현되었던 코드가 아래의 코드처럼 2줄로 표현 가능하며, 그 의도 역시 더욱 명확해지게 되었다.</li></ul><pre>const getCoupon = code =&gt; CouponService.get(code)<br>Promise.all(codes.map(getCoupon))</pre><ul><li>Why? <strong>side effect를 제거</strong>할 수 있다. for 루프와 if 문을 사용하다 보면 가변적인 상태를 자주 만들게 된다. map과 filter의 사용을 통해 가변 상태로 인한 side effect를 제거할 수 있게 되었다. 아주 단순하게는 var 대신 const만 사용할 수 있는 코드가 되었다.</li></ul><p>동료와 미래의 나와 함께 일하기 위해 코드의 가독성을 높이기 위한 시도는 언제나 옳다고 생각한다.</p><h4>2. 함수 반환 유형</h4><p>아직 찜찜한 상태로 존재하는 코드가 있다. 역시나 나의 동료는 Pull Request를 리뷰하면서 여러 코멘트를 남겼다. 해당 코멘트에 여러 쓰레드가 남았고, 나는 이 코멘트가 남겨진 함수에 반환 유형을 명시하지 않았다는 것을 발견했다. 즉시, 코드를 수정했다.</p><ul><li>Why? 역시 <strong>코드의 가독성을 위함</strong>이다. 해당 함수는 특정 값 혹은 undefined를 반환할 수 있도록 구현되었다. undefined가 반환될 수 있는 것도 의도된 작업이긴 하지만, 설계가 매끄럽지 못하여 나온 결과라고 생각한다. 그래서 여전히 찜찜한 상태의 코드이지만, 우선은 이 코드를 보게 될 동료를 위해 그리고 (분명히 의도를 까먹게 될) 미래의 나를 위해 반환 유형을 명시하는 것이 좋다고 판단했다.</li></ul><p>사실, 반환 유형을 명시하지 않아도 자연스럽게 코드가 읽힐 수 있도록 구현하는 것이 먼저라고 생각한다. 현재는 현실과 타협하여 반환 유형을 명시하고, 단위 테스트를 작성하는 것으로 마무리한 작업이지만 곧 갖게 될 서버 정비의 시간에 더 우아한 코드가 되어있을 것이다(그래야만 한다).</p><h4>3. 비동기 호출</h4><p>3rd party를 이용하는 코드에서 동료는 코멘트를 남겼다. 해당 코드는 await를 통해 3rd party API 호출의 promise를 기다리는 방향으로 작성되어 있었다. 동료와의 논의를 통해 해당 코드의 await 작업을 제거하는 것으로 결정했다.</p><ul><li>Why? 3rd party API <strong>호출 결과에 따른 의존성</strong>이 없다. 사용자가 회원가입을 진행할 때, 특정 3rd party 서버에도 사용자 정보 일부를 등록시키는 작업이 필요했다. ‘해당 3rd party API 호출 결과가 성공이 아니라면, 과연 우리 서비스의 회원가입 작업도 rollback 되어야 하는가?’ 에 대한 의사결정이 필요했다. 결론은, 3rd party API 호출 결과와 상관없이 우리 서비스 회원가입은 정상적으로 진행되어야 하며, 다만 3rd party API 호출의 예외 상황에 대해서는 로그를 남기는 것으로 결정했다.</li><li>Why? 3rd party API 호출 결과를 기다리는 일로 인한 <strong>시간 지연을 제거</strong>할 수 있다. await를 사용하면 당연히 3rd party API 호출의 promise를 기다린 후, 다음 로직을 수행하기 때문에 시간 지연이 발생한다. 하지만, 우리는 위의 이유처럼 3rd party API 호출 결과에 의존성이 존재하지 않으며 굳이 시간 지연을 감수할 필요가 없다.</li></ul><p>현재 우리의 서비스는 다양한 3rd party 서비스를 사용 중이다. 이번 일을 계기로, 동료와 함께 사용 중인 3rd party 호출에 대한 의존성과 불필요한 시간 지연에 대해 점검하기로 다짐했다.</p><p>Pull Request 100개 달성을 축하하기 위한 케익은 인생 첫 경험이었다. 이렇게나 서로의 피드백을 갈구하는 동료들과 함께 일한다는 사실은 축복이라고 생각한다. 서버 프로젝트의 Pull Request 100개 달성도 매우 기대하는 중이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/992/1*Z1XCN_TrZFGSbzKrNWhXtA.jpeg" /><figcaption>클라이언트 프로젝트(SWING) Pull Request #100 축하 케익</figcaption></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3e39914f6aa7" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[WHY 시리즈 1] E.004 — 서버 분리, 데이터 모델 관계, API Resource]]></title>
            <link>https://medium.com/@mjspring/why-%EC%8B%9C%EB%A6%AC%EC%A6%88-1-e-004-%EC%84%9C%EB%B2%84-%EB%B6%84%EB%A6%AC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8-%EA%B4%80%EA%B3%84-api-resource-75433452b368?source=rss-a5b93d2efa4c------2</link>
            <guid isPermaLink="false">https://medium.com/p/75433452b368</guid>
            <category><![CDATA[distributed-systems]]></category>
            <category><![CDATA[software-engineering]]></category>
            <category><![CDATA[data-model]]></category>
            <category><![CDATA[rest-api]]></category>
            <category><![CDATA[why]]></category>
            <dc:creator><![CDATA[Mijeong (Rachel)]]></dc:creator>
            <pubDate>Sun, 27 Jan 2019 04:57:27 GMT</pubDate>
            <atom:updated>2019-02-23T09:56:48.755Z</atom:updated>
            <content:encoded><![CDATA[<h3>[WHY 시리즈 1] E.004 — 서버 분리, 데이터 모델 관계, API Resource</h3><blockquote>‘코드와 서비스 만들기를 좋아하는 소프트웨어 엔지니어’로 일하고 있다. 엔지니어는 문제를 해결하는 사람이다. 문제를 해결하는 과정에는 여러 가지 선택이 존재할 수 있다. 가능한 최선의 결과를 위해, 항상 내 선택의 Why에 답할 수 있는 사람이 되고자 한다. 매주, 한 주 동안 내가 결정한 선택의 Why에 대해 정리하고자 한다.</blockquote><p>호찌민(사이공)에서의 4주 차가 시작되었다. 한 달이 되어가니 여기에서의 생활에도 나만의 패턴이 생기기 시작했다. 이번 주는 프로덕트의 첫 릴리즈를 위한 Phase 3가 시작되는 한 주였으며, 동료들과 시스템 개발을 위한 설계에 대해 본격적으로 시작한 한 주였다. 주로, 동료들과의 논의에서 재미있는 주제가 나왔으며 그 주제의 결론에 대해 Why를 던져본다.</p><h3>Why?</h3><h4>1. API 서버 분리</h4><p>서버 백로그 그루밍(Backlog grooming) 작업을 하던 중, 다른 서버 개발자 동료와 현재의 Monolithic 서버 구조를 변경하는 일에 대해 이야기를 나누었다. <a href="https://medium.com/@mjspring/why-%EC%8B%9C%EB%A6%AC%EC%A6%88-1-e-002-monolith-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD-pull-request-a5c827ebd3f">[WHY 시리즈 1] E.002</a>에서 언급한 것처럼 분산 시스템은 현재까지의 고려대상이 아니었다. 자연스럽게, 해당 백로그를 남은 Phase 3, Phase 4의 태스크로 결정할 것인가 아닌가에 대한 이야기가 오고 갔다. 결론은 Phase 3, Phase 4의 태스크로 포함시키지 않기로 했다.</p><ul><li>Why? <strong>도메인을 어떻게 분리시킬 지에 대한 학습이 필요</strong>하다. 단순히 엔드 포인트 별로 서버를 분리한다면(예를 들어, 일반 사용자 / 에이전트 / 관리자 / 라이더 등) 분산된 monolith 구조가 될 가능성이 크다(이러고 나중에 이런 생각을 하겠죠. ‘어랏, 난 분명 서버를 분리했는데 왜 자꾸 여러 서버에 같이 배포하는 거지..’)</li><li>Why? 지금까지의 에피소드에서 계속 언급한 것처럼, 첫 릴리즈 전까지의 목표는 일반 사용자가 서비스를 이용하는데 기능적으로 문제없는 시스템을 개발하는 것이다. 이 관점에서 생각했을 때 API 서버 분리는 높은 우선순위가 아니라고 판단했다. 도메인 분리를 어떻게 가져갈지에 대한 학습 시간이 중요하다고 생각했으며, 비록 남은 Phase 3와 Phase 4의 태스크로 포함시키지는 않았지만, 부지런히 이에 대한 고민과 학습은 병행되어야 한다고 생각한다.</li></ul><blockquote>Note: <a href="https://blog.newrelic.com/engineering/distributed-monolith-vs-microservices/">Distributed Monolith vs. Microservices Architecture: 4 Ways New Relic Can Tell You Which Is Which</a> 확인</blockquote><h4>2. 데이터 모델 관계 설정</h4><p>프로덕트를 위한 Phase 3가 시작되었고, 지금부터는 프로모션 관련 시스템이 함께 개발되어야 한다. 추가적인 시스템 개발이 필요하게 되면서 데이터 모델 구조에 대해 동료들과 논의하는 시간을 갖게 되었다. 여러 가지 논의 중, 프로모션 데이터 모델과 다른 데이터 모델의 관계를 데이터베이스 레벨에서 설정할 것인가 아니면 애플리케이션 레벨에서 코드로 처리할 것인가에 대한 이야기가 있었다. 데이터베이스 레벨에서 설정한다면 Aggregation과 같은 기능을 통해 비교적 쉬운 방법으로 데이터를 조회할 수 있지만, 애플리케이션 레벨에서 코드로 처리하는 것으로 결정했다.</p><ul><li>Why? 프로모션과 관련된 다른 데이터 모델이 증가할 때, <strong>유연한 구조</strong>를 가져갈 필요가 있다. 현재는 첫 릴리즈에 꼭 필요한 요구사항만 도출하여 설계 및 개발을 진행하고 있기 때문에 프로모션과 관련된 데이터 모델이 많지 않은 상황이다. 하지만 프로모션이라는 개념은 충분히 다른 데이터 모델과 많은 관계를 맺을 가능성이 높고, 그때 마다 관련된 데이터 모델의 구조를 함께 변경해야 하는 상황은 피하는 것이 좋다고 판단했다.</li><li>Why? <strong>서버 분리 시, 방해가 될 요소를 제거</strong>해야 했다. 현재는 API 서버 분리는 높은 우선순위의 고려대상이 아니라고 말했지만, 프로모션이라는 도메인 자체는 추후에 독립적으로 분리될 가능성이 크다고 판단했다. 자연스럽게 데이터베이스 레벨에서 다른 도메인 영역의 데이터 모델과의 관계를 최소화하는 것이 현명하다고 판단했다. (데이터 마이그레이션 작업을 위한 필요 이상의 리소스 사용, 서버를 분리했다면서 데이터베이스를 공유하는 잘못된 구조 등에 대한 리스크를 최소화하기 위함)</li></ul><p>처음에는 데이터베이스 레벨에서 결정할 수 있는 선택사항들에 대해서만 논의를 했다. 애플리케이션 레벨에서 코드로 처리하는 선택사항까지 논의를 확장하게 된 계기는 이런 생각을 하면서부터였다. ‘첫 릴리즈 이후, 프로모션과 관련된 데이터 모델은 빠르게 증가할 것이다.’</p><h4>3. API Resource 표현</h4><p>특정 기능을 위해 API를 설계하다가 API Resource를 표현하는 일이 난감해져서 동료에게 도움을 요청했다. ‘이게 이렇게 시간을 잡아먹을 일인가?’ 라는 생각이 들어 동료의 시간을 요청했고, 왜 Resource를 표현하는 일이 어려웠는지 알게 되었다.</p><ul><li>Why? 해당 API는 (역시나) 부족한 시간으로 인해, 임시로 추가된 기능이었다. 즉, 이 API는 사용될 <strong>엔드 포인트나 도메인 영역이 명확하지 않은 상황</strong>이었다. API URI 설계 시, <strong>정보의 자원</strong>과 <strong>자원에 대한 행위</strong>가 표현되어야 한다는 기준을 갖고 있는데, 이 기준으로 쉽게 Resource를 표현할 수 없다는 것은 ‘이 API의 대상 자원이 있을 곳은 여기가 아닌가 봐..’ 라고 판단을 하게 만들었다.</li></ul><p>당장은 해당 API가 포함되어야 하는 도메인 영역을 명확하게 설계하고 개발할 수 없는 상황이라, 처음 결정대로 임시적인 기능으로써 진행할 수밖에 없다. 하지만 Resource에 대한 표현은, 명확한 도메인 영역이 존재한다는 전제하에 표현하는 것으로 마무리 지었다.</p><blockquote>Note: <a href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design#organize-the-api-around-resources">Microsoft Azure API design — Organize the API around resources</a></blockquote><p>설계를 진행하는 과정에서 동료들과의 논의는 항상 충만하다. 서로의 의견을 공유하고, 피드백을 주고받는 과정에서 생각의 폭이 넓어진다. 이제 다가오는 새로운 한 주에는 우아한 코드를 작성하게 될 테니 기대하지 않을 수 없다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*nP_9sKT4nJy53Tm8USyREw.jpeg" /><figcaption>사이공 오피스의 화이트 보드는 오목을 위한 것입니다.</figcaption></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=75433452b368" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[WHY 시리즈 1] E.003 — 단위 테스트, 개밥 먹기, 데이터 구조 정의]]></title>
            <link>https://medium.com/@mjspring/why-%EC%8B%9C%EB%A6%AC%EC%A6%88-1-e-003-%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B0%9C%EB%B0%A5-%EB%A8%B9%EA%B8%B0-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0-%EC%A0%95%EC%9D%98-3d7568f9023e?source=rss-a5b93d2efa4c------2</link>
            <guid isPermaLink="false">https://medium.com/p/3d7568f9023e</guid>
            <category><![CDATA[software]]></category>
            <category><![CDATA[software-engineering]]></category>
            <category><![CDATA[data-structures]]></category>
            <category><![CDATA[unit-testing]]></category>
            <category><![CDATA[why]]></category>
            <dc:creator><![CDATA[Mijeong (Rachel)]]></dc:creator>
            <pubDate>Sat, 19 Jan 2019 17:49:10 GMT</pubDate>
            <atom:updated>2019-02-23T09:57:21.172Z</atom:updated>
            <content:encoded><![CDATA[<h3>[WHY 시리즈 1] E.003 — 단위 테스트, 개밥 먹기, 데이터 구조 정의</h3><blockquote>‘코드와 서비스 만들기를 좋아하는 소프트웨어 엔지니어’로 일하고 있다. 엔지니어는 문제를 해결하는 사람이다. 문제를 해결하는 과정에는 여러 가지 선택이 존재할 수 있다. 가능한 최선의 결과를 위해, 항상 내 선택의 Why에 답할 수 있는 사람이 되고자 한다. 매주, 한 주 동안 내가 결정한 선택의 Why에 대해 정리하고자 한다.</blockquote><p>호찌민(사이공)에서의 3주차 일과 삶. 이제 꽤 사람과 환경에 적응해가고 있다. 이번 주는 프로젝트 Phase 2에 대한 회고에 참여할 수 있었고, 원격에서 근무를 하고 계시던 서버 엔지니어 동료가 사이공 오피스로 출근하여 모든 엔지니어가 얼굴을 마주하고 토론할 수 있었다. 정신없이 흘러갔던 3주차의 선택에 Why를 던져본다.</p><h3>Why?</h3><h4>1. 3rd party API 단위 테스트</h4><p>현재 맡고있는 업무 중, 3rd party API를 사용하여 개발을 진행해야 하는 일이 존재한다. 이 외부 API와 통신하는 모듈을 개발하고, 단위 테스트 코드를 작성하던 중 정신이 번쩍 들었다. 내가 작성하는 단위 테스트 코드는, 같은 입력에 대해서도 외부 서버의 상태에 따라 실패할 수도 성공할 수도 있는 단위 테스트 코드였기 때문이다. 그래서, 처음부터 생각을 다시 정리했다. 단위 테스트란 무엇인가? <a href="https://en.wikipedia.org/wiki/Unit_testing">위키피디아</a>에서는 ‘<strong>unit testing is a software testing method by which individual units of source code.</strong>’ 즉, 소스 코드의 개별 단위(가장 작은 단위라고 이해하고 있다.)를 테스트하는 방법 중 하나라고 정의한다. <a href="https://justhackem.wordpress.com/2016/05/23/unit-integration-acceptance-and-functional-testing/">이규원님의 글</a>에서는 ‘<strong>이상적으로 단위 테스트 케이스는 테스트 대상이 아닌 코드의 결점에 독립적이어야 합니다.</strong>’ 라고 표현했다. 그래서 외부 API와 통신하는 해당 모듈을 위해 테스트 대역(Test Double)을 사용하기로 결정했다.</p><ul><li>Why? 해당 단위 테스트 코드의 목적은, <strong>테스트 대상이 되는 단위 내에서 내가 작성한 코드의 결점을 발견하기 위함</strong>이다. 즉, 외부 환경(3rd party API 서버)에 따라 단위 테스트 결과가 달라지는 것은 본 목적을 벗어나는 일이다.</li></ul><p>가급적 단위 테스트 코드를 작성하기 전, 테스트 하려는 대상과 목적을 명확히 하고 시작하려 한다. 그렇지 않으면 테스트 대상의 범위를 벗어난 단위 테스트 코드를 작성하게 될 수도 있다.</p><blockquote>Note: <a href="https://justhackem.wordpress.com/2018/01/16/is-that-integration-test-really/#more-7604">이규원님의 다른 글</a>을 읽고 공감되는 구절을 발견했다. ‘<strong>나는 테스트 케이스를 작성할 때 단위 테스팅을 할지 통합 테스팅을 할지 심각하게 판단하지 않는다. 다시 말하지만 그건 나에게 별 의미가 없는 고민이다. 중요한 것은 테스트 케이스가 없음으로 인해 불안함을 느끼는지다.</strong>’</blockquote><blockquote>중요한 것은 내가 작성한 코드의 불안함을 제거했느냐이지, 어떤 테스팅 기법을 적용했느냐가 아니다.</blockquote><h4>2. 개밥 먹기</h4><p>현재 프로젝트의 Phase 2가 종료될 무렵, 팀에 조인하게 되었다. 프로덕트 팀에서 Phase 2를 회고하는 시간을 갖게 되었고, ‘우리는 개밥 먹기를 잘 했는가’에 대해서는 아쉬움이 남는다는 동료의 말을 듣게 되었다. 개밥 먹기란 <strong>본인이 만들고 있는 프로덕트를, 본인이 직접 사용해보는 것</strong>을 의미한다. Phase 2에서는 개밥 먹기에 대해 스스로 회고할 내용이 없었지만, Phase 3에서는 더욱 자주 개밥 먹기를 하자는 동료들의 의견에 동의했다.</p><ul><li>Why? 적어도 내가 만든(혹은 개발한) 결과가 전체 프로덕트에 어떤 영향을 미치는지 알고 있는 것은 중요하다. 내가 맡은 기능 범위 안에서 개발의 결과물은 좋았을지라도, 전체 프로덕트를 사용하는 관점에서는 예상 밖의 불편함을 경험할 수도 있다. 이러한 <strong>불편함을 빠르게 발견하고, 프로덕트 자체를 더 옳은 방향으로 개선하기 위해서</strong>라도 개밥 먹기는 중요하다.</li></ul><p>다음주 부터 시작되는 Phase 3에서는, 새로운 버전의 앱이 릴리즈 되었다는 알림이 올 때 마다 다같이 역동적으로 프로덕트를 써보는 모습을 볼 수 있을 것 같다.</p><h4>3. 데이터 구조 정의</h4><p>원격으로 근무하시던 서버 엔지니어 동료가 사이공 오피스로 1주일 동안 출근하게 되셨고, 모바일 앱 개발을 하시던 다른 엔지니어 분의 제안으로 클라이언트와 서버 간의 특정 인터페이스에 대해 토론하는 시간을 갖게 되었다. 클라이언트와 서버가 주고 받는 데이터 구조에 대한 이야기였으며, 특정 object와 그 하위 object의 구조를 어떻게 설계할까에 대한 것이었다. 왜 예상보다 오랜 시간을 이 주제에 대해 토론하는데 사용했을까?</p><ul><li>Why? 당연한 이야기지만, 클라이언트와 서버쪽 모두가 동의할 수 있는 데이터 구조를 이끌어내야 했다. 클라이언트 쪽의 기능 요구사항을 지원할 수 있는 데이터를 서버에서 보내주어야 하고, 굳이 클라이언트와 서버 양쪽에서 검증할 필요가 없는 데이터를 걸러내고, 클라이언트에서 파싱하기 유리한 구조로 갈지 혹은 서버의 데이터 스키마를 최대한 유지할지 등의 이야기는 결국 <strong>모두가 동의할 수 있는 데이터 구조를 이끌어내기 위함</strong>이었다.</li><li>Why? 안타깝게도, 현재는 요구사항이 명확한 상태에서 개발을 진행한다기 보다는 명확한 요구사항 도출 과정과 개발 과정이 어느 정도 중첩되는 형태로 일이 진행되고 있다. 프로젝트 특성 상, 동료들 모두 동의한 환경이며 적극적으로 역할이 다른 동료들과 협업하고 일이 되게끔 해야 하는 상황이다. 즉, 요구사항의 변경 가능성이 적지 않은 환경이라는 말이다. <strong>현재까지의 요구사항을 만족시키면서</strong>, 예측할 수 있는 다른 상황들을 고민해보고 <strong>추후 변경에 열려있는 구조를 가져가기 위함</strong>이었다.</li></ul><p>이제 다가오는 새로운 주 부터는, Phase 3의 본격적인 설계/개발이 시작된다. 또 어떤 고난들이 날 기다리고 있을지 걱정 반 설렘 반. 잘 해결해 나가고, 배움의 이야기가 충만한 한 주가 되길 바란다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*gDU6pWpQXQgBMQm5TLuVlg.jpeg" /><figcaption>사이공 오피스의 즐거운 토론 시간</figcaption></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3d7568f9023e" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[WHY 시리즈 1] E.002 — Monolith, 요구사항, Pull Request]]></title>
            <link>https://medium.com/@mjspring/why-%EC%8B%9C%EB%A6%AC%EC%A6%88-1-e-002-monolith-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD-pull-request-a5c827ebd3f?source=rss-a5b93d2efa4c------2</link>
            <guid isPermaLink="false">https://medium.com/p/a5c827ebd3f</guid>
            <category><![CDATA[why]]></category>
            <category><![CDATA[pull-request]]></category>
            <category><![CDATA[software-engineering]]></category>
            <category><![CDATA[monolith]]></category>
            <category><![CDATA[requirements]]></category>
            <dc:creator><![CDATA[Mijeong (Rachel)]]></dc:creator>
            <pubDate>Sun, 13 Jan 2019 08:17:51 GMT</pubDate>
            <atom:updated>2019-02-23T09:58:07.793Z</atom:updated>
            <content:encoded><![CDATA[<h3>[WHY 시리즈 1] E.002 — Monolith, 요구사항, Pull Request</h3><blockquote>‘코드와 서비스 만들기를 좋아하는 소프트웨어 엔지니어’로 일하고 있다. 엔지니어는 문제를 해결하는 사람이다. 문제를 해결하는 과정에는 여러 가지 선택이 존재할 수 있다. 가능한 최선의 결과를 위해, 항상 내 선택의 Why에 답할 수 있는 사람이 되고자 한다. 매주, 한 주 동안 내가 결정한 선택의 Why에 대해 정리하고자 한다.</blockquote><p>호찌민 시티에서의 2주 차 생활에 접어들었다. 환경 설정의 1주 차를 지나고, 본격적으로 나의 업무 및 현재 프로젝트에 대한 이해를 시작했다. 기존의 코드를 구체적으로 살펴보기 시작했고, 현재 프로젝트에 나의 코드를 조금씩 작성하기 시작했다. 5개월의 공백 기간을 지내고, ‘아 다시 개발을 시작하는구나’ 체감했다. 이번 주도 역시 동료의 선택과 나의 선택에 Why를 던져본다.</p><h3>Why?</h3><h4>1. 시작은 Monolithic</h4><p>현재까지 구축된 시스템은 Monolithic 시스템이다. 여러 가지 도메인이 결합할(아직은 그렇지 않다는 이야기) 서비스를 위한 시스템이기에 분산 시스템을 고려할 수도 있다. 서비스 복잡도가 증가할수록 Monolithic 시스템 구조로 인한 문제가 발생할 수 있다(특정 프로젝트의 장애가 전체 서비스의 장애로 이어질 수 있거나, 항상 전체 배포를 수행해야 한다거나, 코드 분석 복잡도의 증가라던가, 오랜 빌드 시간으로 인한 개발 시 불편함이라던가..). 그럼에도 불구하고, 현재는 Monolithic 시스템이며 분산 시스템을 구체적으로 고려하고 있지 않다.</p><ul><li>Why? 현재 우리는 <strong>최대한 빠르게 서비스를 구축해서 시장의 반응을 보는 것</strong>이 중요하다. 또한, <strong>개발 리소스가(인력, 시간) 충분한 상황이 아니다.</strong> 지금 보유한 리소스로 최대한 빠르게 서비스를 구축한다는 목표를 달성하기 위해, 분산 시스템은 아직 고려대상이 아니다.</li><li>Why? 현재 리소스로 어떻게든 꾸역꾸역 분산 시스템을 설계하고 구축한다 하더라도, <strong>문제가 많은 설계를 결과로 내놓지 않을 자신이 없다.</strong> 오히려 Monolithic 시스템 구조로 가져가되, 그 안에서 도메인이 잘 분리될 수 있는 구조를 유지하며 개발하는 것이 낫다고 생각한다. (설계 원칙들을 제대로 공부하고 적용하면서)</li></ul><p>결국, 현재는 분산 시스템으로 굳이 설계하고 구축할 이유가 없다는 것이 결론이다.</p><h4>2. 요구사항 제안</h4><p>Voucher 서비스의 결합이 필요했고, 이를 위한 리서치를 수행하고 우리가 구축할 수 있는 서비스의 유형을 PM에게 선제안(?)했다. 흔히 우리는 기획하는 과정에서 요구사항이 결정되면, 개발자는 이를 전달받아 설계 후 개발을 진행하게 된다. 요구사항이 결정되는 과정에서 기획을 수행하는 사람과 개발자 간에는 수많은 미팅을 통해 서로가 이해하고 있는 것 그리고 할 수 있는 것을 동기화하는 과정이 필요할 수도 있다. 하지만, 우리가 현재 구축하고 있는 서비스는 (위에서 언급한 것처럼) 최대한 빠르게 서비스를 구축해야 하며, 동기화하는 시간을 최소화할 수 있다면 그렇게 하는 것이 좋다.</p><ul><li>Why? 개발자가 리서치를 수행한 후, 우리가 할 수 있는 것을 선제안(?) 한다면, 우리가 <strong>현재 할 수 없는 것을 인지하지 못한 상황에서 나온 무리한 요구사항의 리스크를 감소</strong>시킬 수 있다.</li><li>Why? 이는 결국, <strong>불필요한 시간을 최소화</strong>시킬 수 있다.</li></ul><h4>3. Pull Request</h4><p>호찌민에 온지 2주차, 동료의 Pull Request 리뷰를 시작했고 가능한 꼼꼼하게 코멘트를 남기려고 노력했다. ‘아, 이렇게 구현이 가능하구나’ 생각하며 LGTM을 남기고 끝난 리뷰도 있었고, 하나의 코멘트에 10개 이상의 쓰레드가 남겨져 있는 리뷰도 존재했다. 각자가 맡은 기능에 대해 구현하기도 바쁜 와 중에 왜 우리는 서로의 코멘트에 의견을 달고, 또 달고, 리뷰를 지속했을까?</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*LrDX_NWLHkPsVM9qcfseNQ.png" /><figcaption>예제 코드가 담긴 하나의 코멘트 쓰레드가 12개</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*4-7dLBqj03vo6tO-wftXTA.png" /><figcaption>코멘트 쓰레드 샘플 1</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*6Lba9bWIhZKkR28xFqg_pA.png" /><figcaption>코멘트 쓰레드 샘플 2</figcaption></figure><ul><li>Why? 동료의 PR을 리뷰하면서 신규 입사자인 나는 <strong>현재 프로젝트 및 구조에 대해 더 깊게 이해</strong>할 수 있다. 기존 개발자들에게는 익숙하고 당연한 코드도, 나에게는 궁금증의 대상이 되었고 관련 코드들을 찾아가다 보면 현재 프로젝트에 대해 자연스럽게 공부하는 시간을 갖게 됐다.</li><li>Why? 동일한 기능의 구현 방법에 대해 서로 다른 의견을 갖고 있을 수 있다. 그리고 우리는 각자의 서비스를 구현하는 것이 아니며, 서로의 코드를 통해 하나의 서비스를 구현하는 것이다. 즉, 우리의 PR 리뷰는 <strong>서비스를 더 잘 만들기 위한 동일한 목표를 위해 노력</strong>하는 것이다.</li></ul><p>코드 리뷰를 통해 다양한 구현 방법에 대한 의견으로 생각의 폭을 넓힐 수도 있고, 코드 자체의 명료함과 품질도 향상시킬 수 있으며, 자칫 놓칠 수 있는 오류도 사전에 발견할 수 있는 등 다양한 효과를 누릴 수 있다. 기회를 잡아서 우리 팀의 Pull Request 및 코드 리뷰 프로세스 정리를 위한 시간을 보내기를 희망한다.</p><blockquote>Note: <a href="https://blog.plaid.com/building-an-inclusive-code-review-culture/">Building an Inclusive Code Review Culture</a> 확인</blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/480/1*RuyF1HWIsSGrM7iv48ne4w.jpeg" /><figcaption>서버 HOST 주소를 복사한다는 게, ㅋ을 복사해서 붙여넣은 몸살 걸린 어느 날</figcaption></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a5c827ebd3f" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>