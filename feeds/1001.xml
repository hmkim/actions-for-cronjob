<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Haegul Pyun on Medium]]></title>
        <description><![CDATA[Stories by Haegul Pyun on Medium]]></description>
        <link>https://medium.com/@la.place?source=rss-e91974b65d5c------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*Vm0x2VYk1OuAOH9SVFu09g.jpeg</url>
            <title>Stories by Haegul Pyun on Medium</title>
            <link>https://medium.com/@la.place?source=rss-e91974b65d5c------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Sun, 12 May 2019 09:02:56 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@la.place" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[Dan Abramov Hi, it’s a really cool article.]]></title>
            <link>https://medium.com/@la.place/dan-abramov-hi-its-a-really-cool-article-a3d6ebc47e34?source=rss-e91974b65d5c------2</link>
            <guid isPermaLink="false">https://medium.com/p/a3d6ebc47e34</guid>
            <category><![CDATA[transportation]]></category>
            <dc:creator><![CDATA[Haegul Pyun]]></dc:creator>
            <pubDate>Sat, 01 Dec 2018 03:48:20 GMT</pubDate>
            <atom:updated>2018-12-01T03:48:20.942Z</atom:updated>
            <content:encoded><![CDATA[<p><a href="https://medium.com/u/a3a8af6addc1">Dan Abramov</a> Hi, it’s a really cool article. I want to translate this text into Korean. Is it okay to translate it into Korean?</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a3d6ebc47e34" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Async-await는 어떻게 구현하는가]]></title>
            <link>https://medium.com/@la.place/async-await%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94%EA%B0%80-fa08a3157647?source=rss-e91974b65d5c------2</link>
            <guid isPermaLink="false">https://medium.com/p/fa08a3157647</guid>
            <category><![CDATA[asynchronous]]></category>
            <category><![CDATA[developer]]></category>
            <category><![CDATA[front-end-development]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[it]]></category>
            <dc:creator><![CDATA[Haegul Pyun]]></dc:creator>
            <pubDate>Sun, 07 Oct 2018 06:57:37 GMT</pubDate>
            <atom:updated>2018-10-07T12:41:13.331Z</atom:updated>
            <content:encoded><![CDATA[<p>지난 포스트였던 <a href="https://medium.com/@la.place/javascript-iterator-b16ca3c51af2">Javascript Iterator</a>에서 잠깐 언급했었던 async-await에 관해 이야기해 보도록 하자. <strong>시작하기에 앞서 이 포스트에서는 async-await에 대한 문법을 다루지 않는다.</strong> <strong>async-wait가 어떤 배경을 가지고, 어떤 방법을 통해 구현이 되어있는지 그 근원에 대한 탐구를 할 생각이다.</strong> 따라서 iterator, promise, generator, async-wait, 그리고 Babel에 대한 사전 지식이 필요한 사람들은 아래 링크에 있는 글들을 먼저 읽어보길 바란다.</p><ul><li><a href="https://medium.com/@la.place/javascript-iterator-b16ca3c51af2">Javascript Iterator</a></li><li><a href="https://meetup.toast.com/posts/73">ES6의 제너레이터를 사용한 비동기 프로그래밍</a></li><li><a href="https://developers.google.com/web/fundamentals/primers/async-functions?hl=ko">Async Function</a></li></ul><h3>Async-await?</h3><p>Async-await는 <a href="https://tc39.github.io/ecma262/#sec-async-function-definitions">ECMA-262</a>에서 초안으로 처음 등장했으며, ECMAScript 2017에서 표준으로 정의되었다. 비동기 프로그래밍을 동기 방식처럼 직관적으로 표현할 수 있어서, Callback을 많이 사용하는 프론트엔드 개발자들에게 많은 사랑을 받고 있다.</p><p>다른 언어를 공부해 본 사람은 어렴풋이 느끼겠지만, 사실 async-wait는 자바스크립트의 전유물이 아니다. 비동기 로직을 쉽게 작성하기 위한 방법은 자바스크립트 뿐만 아니라, 네트워크를 다루는 모든 언어에서 고민을 해왔다. 비동기가 들어간 비지니스 로직은 중첩될수록 그 복잡도가 기하 급수적으로 늘어나며, 이를 간결하게 한다는 것은 유지보수와 생산성의 향상으로 귀결되기 때문이다. 마찬가지로 TC-39에서도 같은 고민을 했을 것이고, 다른 언어에서 사용하는 솔루션을 많이 참고했을 것이다. 결과적으로 promise와 generator, 그리고 async-wait가 새로운 스펙으로 도입되었다. 그래서 다른 언어(예를들면 C#)에도 비슷한 문법이 존재하는데, 마찬가지로 비동기 로직을 제어하기 위해 주로 사용되며, 사용방법도 크게 다르지 않다. 그러나 자바스크립트에는 다른 언어와 다른 치명적인 단점이 존재하는데, 바로 하위 버전의 브라우저에서는 사용할 수 없다는 것이다.</p><p>이는 자바스크립트가 브라우저에 종속적이기 때문에 발생하는 태생적인 문제이다. 다행스럽게도 하위 브라우저에서도 사용할 수 있는 방법이 있었으니 바로 Babel같은 컴파일러(트랜스파일러라고도 부른다)를 이용하여 ES5 문법으로 바꿔주면 되기 때문이다. 여기서 한가지 의문이 든다. ES5로 바꿔준다는 것은, 다시 말하면 ES5로 구현이 가능하다는 것이다. 그렇다면 브라우저에서 구현과 별개로 어떻게 ES5 스펙만으로 이를 가능하게 하는 것일까? 여기에 이전 포스팅에서 다루었던 <strong>Generator</strong>, 그리고 <strong>Promise</strong>가 깊게 관여한다.</p><h3><strong>Async-await와 Generator</strong></h3><p>이 포스트에서는 Babel을 통해 어떻게 async-await를 구현하는지 알아볼 것이다. 거두 절미하고 Babel에서 어떻게 컴파일 하는지 살펴보도록 하자.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/32c92546f804c512a86976f07065d36d/href">https://medium.com/media/32c92546f804c512a86976f07065d36d/href</a></iframe><p>간단한 비동기 함수 foo 와 bar 를 이용해서 컴파일 해 보았다. 컴파일 된 함수를 보면 크게 복잡하지 않은데, async keyword를 generator로 바꾸고 await keyword는 yield로 바꾸었다.</p><p>그렇다. Babel에서는 async-wait를 generator를 이용해서 구현을 한다. 이전 포스팅인 iterator에서도 설명을 했었지만, generator는 yield를 만날 때까지 실행되고, 이때 컨텍스트는 저장된 상태로 남아 있게 된다. 따라서, 비동기 로직이 종료되었을 때마다 적절하게next()를 호출해주기만 하면, aysnc-await 함수가 완성되는 것이다.</p><p>그러나 bar()함수의 작업이 종료되는 시점은 bar()함수밖에 모른다. 그렇다고next()를 bar()함수 내에서 직접 실행하게 된다면 의존성이 생기게 된다. 그렇다면 어떻게 의존성을 분리할 수 있을까? 이 문제를 해결하기 위해서 사용된 것이 바로 promise이다. Babel은 promise와 재귀함수를 이용하여 next()를 대신 호출해주는 함수를 만드는데, 그게 바로 _asyncToGenerator이다.</p><p>_asyncToGenerator 함수를 간략하게 살펴보도록 하자. fn.apply를 실행하여 인자로 넘어온 generator를 실행하여 iterator 객체를 클로저로 저장해둔다. 나머지는 클로저에 저장한 iterator를 실행시키고, 반환된 promise객체를 재귀함수(여기서는 step)를 통해 반복해서 실행시켜 주는 것이다<strong>(잘 이해가 되지 않는 사람은 </strong><a href="https://meetup.toast.com/posts/73"><strong>ES6의 제너레이터를 사용한 비동기 프로그래밍</strong></a><strong>의 “<em>제너레이터와 프라미스의 만남” </em>부분을 다시 보도록 하자).</strong></p><p>정리하자면 generator는 비동기적 패턴을 yield를 통해 동기적인 “모습&quot;으로 바꾸어주고, promise는 generator로 만든 iterator를 반복해서 실행해주는 역할을 한다. await keyword에 사용하는 함수가 항상 promise를 반환해야하는 이유가 여기에 있다.</p><h3>ES5와 Generator</h3><p>여기서 한가지 더 생각해 보자. generator 도 ES5 스펙이 아니지 않은가? 그렇다면 generator는 어떻게 ES5로 구현이 되는 것일까. Babel에 ES2015옵션을 주면 다음과 같이 컴파일 된다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/b847506394d836b6acaa84f81b93b269/href">https://medium.com/media/b847506394d836b6acaa84f81b93b269/href</a></iframe><p>Iterator 포스팅에서 generator는 Iterable Protocol을 구현하는 객체였다. 그러나 실제로 컴파일 된 모습을 보면 프로토콜과 관련된 코드는 찾아 볼 수 없다. 대신에 regeneratorRuntime 이라는 객체가 눈에 띄는데 혹시 이녀석이 그 역할을 해주는게 아닐까?</p><p>결론부터 말하자면 Babel은 regenerator라는 라이브러리를 사용하여 generator를 구현한다. 그렇다면 이 라이브러리는 누가 만든 것인가. 코드의 역사를 따라가다 보면 <a href="https://github.com/facebook/regenerator">facebook/regenerator repository</a>에 도달하게 된다. 이 라이브러리는 2013년 Node.js v0.11.2에서 generator syntax를 지원하기 위해 만들어 졌으며, Babel에서는 이 라이브러리를 사용하여 generator를 구현하고 있다. 실제 코드를 들여다보면 Symbol과 Iterator를 이용해서 Iterable Protocol을 구현하고 있다. 결국 좀 과장을 보태면 async-wait는 iterator 개념으로부터 시작되어 generator로 발전하였으며, promise와 콜라보레이션으로 이루어진 멋진 스펙인 것이다.</p><p>Generator에 대해 찾아보면서, 세부 구현은 꽤 오래전에 이미 완성되어있었다는 것을 깨닫고 놀랐으며, 글을 쓰다보니 스스로도 언어에 대한 철학과 그 원리에 대해 깊게 고민해보지 않았던 것을 깊게 반성했다. 또 비교적 어려운 내용이다보니 쉽게 풀어쓰려 노력했지만, 무거운 내용이 되어서 아쉽기도 하다. 마지막으로 promise의 구현에 대한 내용은 이 포스트에서 다루지 않았는데, 다음 기회에 깊게 알아보도록 하자. 처음 접한 사람은 이해하기 힘든 부분이 많을 것이라 생각되므로, 서론에 링크한 글은 다시 한번 꼭 읽어보길 바란다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fa08a3157647" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Javascript Iterator]]></title>
            <link>https://medium.com/@la.place/javascript-iterator-b16ca3c51af2?source=rss-e91974b65d5c------2</link>
            <guid isPermaLink="false">https://medium.com/p/b16ca3c51af2</guid>
            <category><![CDATA[developer]]></category>
            <category><![CDATA[iterators]]></category>
            <category><![CDATA[generator]]></category>
            <category><![CDATA[it]]></category>
            <category><![CDATA[javascript]]></category>
            <dc:creator><![CDATA[Haegul Pyun]]></dc:creator>
            <pubDate>Thu, 04 Oct 2018 16:00:45 GMT</pubDate>
            <atom:updated>2018-10-04T16:03:17.728Z</atom:updated>
            <content:encoded><![CDATA[<p>ECMA2015 문법이 추가되면서 javascript는 큰 변화를 겪어가는 중이다. 개발하는데 정말 유용한 개념들이 되었는데, 한꺼번에 많은 스펙들이 추가되면서 생각보다 조명받지 못한 개념들도 많다. 그 중에서 우리가 많이 사용하지만, 또 간과하기 쉬운 개념인 <strong>Iterator(반복자)</strong>에 대해 알아보도록 하자.</p><h3>for-of</h3><p>Iterator에 대해 이야기 하자마자 갑자기 for-of가 나온 것인지 의아할 것이다. 하지만for-of 가 그 무엇보다 Iterator와 매우 밀접한 연관을 지닌 문법인데 이제부터 차근차근 알아가 보도록 하자.</p><p>for-of 가 생긴 배경에 대해 알아보기 위해서 약간 과거로 거슬러 올라가보도록 하자. ES5 시절, 자바스크립트에서 object 를 순회하는 방법은 한가지 뿐이었다. 바로 for-in 문법을 사용하는 것인데 이 문법을 사용하면 key 를 이용해서 object를 쉽게 순회할 수 있다. 그렇다면 for-in 을 사용해서 배열(Array)를 순회하면 어떨까? 결론부터 말하자면 순회는 가능하지만, index가 문자열이라는 점, prototype chain까지 순회를 한다는 점 등 배열을 순회하기엔 이것저것 문제점이 많다. 그렇다면 forEach 를 사용하면 되지않느냐 라고 말할 수 도 있겠다. 물론 forEach 도 훌륭한 함수이지만 사용자의 의도대로break; 를 하기가 쉽지 않다는 문제점이 있다.</p><p>이러한 for-in 의 문제점을 보완하기 위해서 ECMA2015에 새로운 문법이 추가되었는데 그것이 바로 for-of 이다. for-of 를 사용하면 배열은 물론 object까지 쉽게 순회가 가능하다(물론 Obejct.key()를 사용해야 하지만). 하지만 for-of 의 강력한 힘은 따로 있는데. 바로 <strong><em>열거가능(enumerable)</em></strong>한 객체라면 모두 순회가 가능하다는 것이다.</p><p>그렇다면 열거가능한 객체란 무엇인가? 배열(Array)는 물론, TypedArray, 문자열(String), Map, Set, DOM Collection 등을 말한다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d7a6a1f41921169e11090cd01863fd68/href">https://medium.com/media/d7a6a1f41921169e11090cd01863fd68/href</a></iframe><p>그렇다면 이렇게 반복 가능한 객체들은 어떤 원리를 통해 for-of 를 이용해서 순회를 할 수 있는 것일까? 여기에서 바로 오늘의 주인공인 <strong>Iterator</strong>가 등장한다. 위 Collection들은 내부적으로 <strong><em>Iterable Protocol</em></strong>을 구현한다. 그렇다면 <strong><em>Iterable Protocol </em></strong>이란 무엇인가. 자세하게 알아보도록 하자.</p><h3>Iterable Protocol</h3><p>어떤 객체가 반복되기 위해서는 Iteration 동작에 대해 정의되어 있어야 한다. 자바스크립트에서 정의하는 Iterator protocol에 의하면 Iterator는 next() 함수를 구현해야 하고 이 함수는 결과값으로{value: someValue, done: Boolean} 와 같은 객체를 반환해야 한다. 아래 makeRangeIterator() 함수는 앞에서 언급한 protocol을 구현한 함수이다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/95f81a26c6321b841ebd419a3b802f08/href">https://medium.com/media/95f81a26c6321b841ebd419a3b802f08/href</a></iframe><p>하지만 ECMA2015에서 오면서 Iterator protocol을 이용하여 열거가능한 객체를 만들 수 있게 되었다. [Symbol.iterator]() 와 next()를 이용하면 쉽게 정의 할 수 있게 되었는데, for-of 순회의 비밀은 여기에 있다. for-of는 [Symbol.iterator]()를 호출하여 반복을 실행하게 된다(여기서 새로운 원시타입으로 추가된 Symbol 에 대한 개념은 다루지 않도록 하겠다).</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/65562dce5ae60ca439c875ae751d39ae/href">https://medium.com/media/65562dce5ae60ca439c875ae751d39ae/href</a></iframe><p>그렇다. Iterable Protocol만 잘 지켜 구현한다면 어떤 객체든 for-of 를 이용해서 순회 가능하게 <strong>정의</strong>할 수 있다. 뿐만 아니라, Iterator가 구현된 객체들은 for-of 뿐만 아니라 <strong>전개 연산자(spread operator)</strong>와 만나서 강력한 시너지를 발휘한다.</p><p>만약 크기가 100이고 0으로 초기화 된 배열이 필요하다고 하자 . 가장 쉬운 방법은 반복문을 사용하는 것이다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/07955a83be89373adc809437973a565b/href">https://medium.com/media/07955a83be89373adc809437973a565b/href</a></iframe><p>물론 위 방법도 좋은 방법이긴 하지만, Iterator와 spread를 이용하면 좀더 간편하게 생성 할 수 있다. (Functional 한것은 덤이다!)</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/65240d9e67e568a752301ca45f74ef06/href">https://medium.com/media/65240d9e67e568a752301ca45f74ef06/href</a></iframe><h3>Generator</h3><p>다음 내용으로 Generator가 나올 것을 예측했다면, Iterator에 대해 어느 정도 잘 알고 있는 사람이라 할 수 있겠다. Iterator와 비슷한 이녀석은 일종의 코루틴(Co-Routine)인데, 다른 언어에서는 곧 잘 사용하는 개념이다 (Finite State Machine, Automaton 을 만들때 자주 사용하곤 했다).</p><p>Generator는 함수 실행도중에 잠시 멈췄다가 다시 실행할 수 있는 독특한 함수이다. Generator는 function*키워드를 사용해서 생성하며, Generator를 호출하면 실행되는 것이 아니라 Iterator객체가 반환된다. 따라서 Iterator에서 구현한 next() 함수를 호출하면 Generator가 실행되면서 yield 를 만날 때까지 실행되고, 이때 컨텍스트는 저장된 상태로 남아 있게 된다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/99d7032d3ac75921b839bf8cf9f3da1e/href">https://medium.com/media/99d7032d3ac75921b839bf8cf9f3da1e/href</a></iframe><p>Generator를 사용하면 Iterable Protocol을 구현하는 것보다 좀 더 쉽게 Iterator를 사용할 수 있다. 컨텍스트를 저장하기 때문에 Dynamic Programming을 구현하는데도 매우 유용하다. 아래 함수는 유명한 fibonacci 수열을 Generator로 구현한 것이다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/0534109265a0c54ee3ec90e3ca2c90d2/href">https://medium.com/media/0534109265a0c54ee3ec90e3ca2c90d2/href</a></iframe><p>Generator의 진면목은 비동기 프로그래밍에서 볼 수 있다. 함수가 실행 도중에 멈춘다니. 언제 응답이 올지 알 수 없기 때문에, callback을 등록하는 비동기 프로그래밍에 응용하면 callback hell을 탈출할 수 있지 않을까? 이 주제에 대한 답은 <a href="https://meetup.toast.com/posts/73">ES6 제네레이터를 사용한 비동기 프로그래밍</a> 이라는 포스트를 꼭 읽어 보도록 하자. 일목요연하게 Generator를 이용한 비동기 프로그래밍에 대해 설명하고 있다.</p><p>비동기 프로그래밍이라면 async-await라는 더 쉽고, 더 직관적인 멋진 문법이 있지 않은가? 굳이 비동기 제어를 위해 generator를 알아야 할까? 라고 생각하는 사람들도 있을 것이다. 그러나 만약 async-await를 <strong>제대로 </strong>이해하고 싶다면 generator에 대해 알아야 한다. async-await의 동작 원리에는 generator와 promise가 깊게 관여하기 때문이다. 이 관계에 대해서는 나중에 자세히 다뤄보도록 하겠다.</p><p>이번에는 Iterator에 대해서 간략하게 다뤄보았다. 다른 언어에서는 기본적으로 제공하는 Iterator를 javascript에서는 잘 지원하지 않았던 점이 아쉬웠는데 ECMA2015에 추가 되면서 요즘 나의 호기심을 독차지하고 있다. 물론 javascript에서 다루는 Iteraotr에 대해서는 아직도 쓰임새라던가 한계 등 의견이 분분하다. 그러나 Iterator에 대해서 다루기 시작하면, 페이지 하나 둘 쯤으론 끝나지 않을 만큼 그 사용법은 동기/비동기를 막론하고 정말 무궁 무진하다. 이번 포스트에서는 정말 간략하게만 다뤘지만 관심이 많은 사람들은 꼭 깊게 공부해 보길 바란다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b16ca3c51af2" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Higher-Order Function 이란 무엇인가]]></title>
            <link>https://medium.com/@la.place/higher-order-function-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-1c61e0bea79?source=rss-e91974b65d5c------2</link>
            <guid isPermaLink="false">https://medium.com/p/1c61e0bea79</guid>
            <category><![CDATA[functional-programming]]></category>
            <category><![CDATA[developer]]></category>
            <category><![CDATA[programming]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[higher-order-function]]></category>
            <dc:creator><![CDATA[Haegul Pyun]]></dc:creator>
            <pubDate>Sun, 09 Sep 2018 10:43:26 GMT</pubDate>
            <atom:updated>2018-09-09T13:32:38.204Z</atom:updated>
            <content:encoded><![CDATA[<p>Higher-Order Function. 한국어로 고차함수라 부르는 이 함수는 Functional Programming을 할 때 많이 사용 한다. Higher-Order Function(이하 HOF)를 사용하면 보다 유연하고 반복을 줄일 수 있는 코드를 작성할 수 있다. 이번 기회에 간단한 개념 정리와 어떻게 써먹을 수 있을 지 정리해 보도록 하자.</p><h3>HOF ??</h3><p>컴퓨터 과학(Computer Science)에서 적어도 아래 중 하나 이상을 만족하면 HOF라 할 수 있다.</p><ul><li>하나 이상의 함수를 인자로 받는다.</li><li>함수를 결과로 반환한다.</li></ul><p>쉽게 말하면, 함수를 다루는 함수라고 말할 수 있겠다. 말로 설명하는 것보다 간단한 예제 코드를 보도록 하자.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/aea0de4c35b490b2c1bcbcfe25076a5b/href">https://medium.com/media/aea0de4c35b490b2c1bcbcfe25076a5b/href</a></iframe><p>twice() 는 함수를 인자로 받아 2번 반복해주는 HOF이다. 이 함수는 단순히 2번 반복하는 것 뿐이지만, 인자로 받는 함수에 어떻게 반복할 것인가를 제어할 수 있다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f15086d37cf1f3ba7d42909b3650512c/href">https://medium.com/media/f15086d37cf1f3ba7d42909b3650512c/href</a></iframe><p>같은 twice()함수지만 이번엔 제곱을 하는 함수를 인자로 전달했다. 인자로 넘기는 함수에 따라 사용자의 입맛대로 비지니스 로직을 제어할 수 있다.</p><h3><strong><em>Abstracting Patterns of Control</em></strong></h3><p>HOF는 단순히 함수의 값을 전달하는 기존 관념을 넘어, 함수의 흐름을 제어하는 파라미터로써 수용한다. 이를 <strong><em>제어 패턴 추상화(Abstracting Patterns of Control)</em></strong>라고 부른다. HOF는 계산의 세부사항을 인자로 넘기는 함수 안에 캡슐화 하여 추상적으로 제공할 수 있도록 한다.</p><p>이 또한 말로 설명을 들으면 잘 이해가 되지 않는다. 마찬가지로 예제를 통해 이해해 보도록 하자. 여기서는 예제로 많이 사용하는 함수인 repeat를 구현해 보면서 설명하도록 하겠다.</p><p>repeat는 문자 그대로 반복이다. 일반적인 프로그래밍에서 반복을 위해 보통 반복문을 사용한다. 0부터 99까지 출력하라 라고 요구사항이 주어진다면 보통 아래와 같이 코드를 짤 것이다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/83209b20349ad736effa50b8b9aa7276/href">https://medium.com/media/83209b20349ad736effa50b8b9aa7276/href</a></iframe><p>하지만 보통 요구사항은 자주 변경되기 마련이다… ㅠㅅㅠ 0부터 9999까지 출력하라 로 요구사항이 변경 되었다. 위 코드에서 단순히 i&lt;10 을 i&lt;10000 으로 수정해도 되지만 대부분의 경우 함수로 만들어 사용하는 것이 가독성에 좋고, 수정에 용이하며, 실수를 줄일 수 있다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/03ca4e0c1f448eb42a35f3f818f4c708/href">https://medium.com/media/03ca4e0c1f448eb42a35f3f818f4c708/href</a></iframe><p>이제 우리는 n값으로 몇번을 출력할지 쉽고 빠르게 제어할 수 있다. 그런데 이번엔 요구사항이 다음과 같이 바뀌었다. 0부터 9999까지 배열에 담아라</p><p>우리가 만든 repeat() 함수는 출력을 수행하는 일밖에 할 수 없다. 그 이유는 출력을 하는 비지니스 로직이 repeat() 함수와 강력하게 결합을 하고 있기 때문이다. 그렇다면 repeat 함수의 console.log(i) 부분을 list.push(i)와 같이 수정하면 배열에 담으라는 요구사항을 만족 할 수 있다.</p><p>하지만 단순하게 for문안의 로직을 변경한다고 해서 모든 요구사항에 유연하게 대처할 수 있는 것은 아니다. <strong><em>출력과 배열을 동시에 하라면? 짝수만 골라 담으라고 한다면?</em></strong> 물론 몇줄밖에 되지않으니 for문안의 로직을 수정하는게 편하지 않겠냐는 생각도 들것이다. 하지만 예제와 달리, 일반적인 대부분의 함수는 복잡한 로직을 가지고 있을 것이며, 복잡한 코드를 수정 했을 때 다른 부분에 영향을 미치진 않을지 부작용(Side-Effect)에 대한 공포를 가지고 수정을 해야할 것이다.</p><p>그렇다면 어떻게 하면 좀더 유연한 구조를 만들 수 있을 것인가? 앞에서 설명한 HOF가 그 대안이 될 수 있다. 핵심 요구사항이고, 변경이 있을만한 부분인 for문안의 로직을 추상화하여 함수로 제공한다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/2b10384ec68c8ddda5440eb35e882929/href">https://medium.com/media/2b10384ec68c8ddda5440eb35e882929/href</a></iframe><p>수행해야할 비지니스 로직을 fn(i) 으로 추상화 하였다. 또 fn 을 인자로 받아 수행함으로써 해당 로직을 캡슐화하여 제공한다. 이 과정을 통해 repeat() 함수의 비지니스 로직은 추상화되어 결합도가 낮아진다. 처음보다 다양한 요구사항에 대응할 수 있을 뿐만 아니라, 로직을 캡슐화 함으로써 재사용성을 높히고, 부작용에서도 어느정도 해방된 것을 볼 수 있다. 물론 반복되는 횟수(Pattern of Control)도 추상화(Abstract)하여 더 유연한 구조를 만들 수 있다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9291eccfc0452fbe8c0f74eb2cd39d75/href">https://medium.com/media/9291eccfc0452fbe8c0f74eb2cd39d75/href</a></iframe><h3>함수를 반환하는 함수</h3><p>여기서 끝이 아니다. 지금까지는 HOF의 조건 중 하나 이상의 함수를 인자로 받는다 를 살펴봤는데, 조건은 한가지가 더 있다.</p><blockquote>함수를 결과로 반환한다.</blockquote><p>이번에는 <strong><em>함수를 반환하는 함수</em></strong>에 대해 알아보도록 하자. 아래의 fillArray(n, fn) 함수는 반복 횟수와 배열에 넣을 인자를 리턴 하는 함수를 넘겨받아 완성된 Array를 반환한다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/2451954381e15d38f8152a638b361907/href">https://medium.com/media/2451954381e15d38f8152a638b361907/href</a></iframe><p>함수를 반환하는 함수가 보이는가? 잘 안보인다면 다음과 같이 바꿔보도록 하자.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/4d788c68fdfca68f36f7a7f6b10f02b8/href">https://medium.com/media/4d788c68fdfca68f36f7a7f6b10f02b8/href</a></iframe><p>makeItem() 함수가 바로 함수를 반환하는 함수이다. 이 HOF 또한 i를 인자로 넘겨받아 item0, item1 ... item6 뿐만 아니라 item0, item2, ...item12 와 같이 다양한 형태로 응용할 수가 있다. 또 함수를 리턴 함으로써 item${i} 은 클로저(Closure)로 메모리에 계속 남아있게 되므로 다른곳에서 사용할 수 있다.</p><h3>Use Case</h3><p>그렇다면 HOF가 사용되는 예는 무엇이 있을까? 다들 많이 사용하는 Filter, Map, Reduce 이 함수들이 바로 HOF이다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/bd2a952b13d4b25f825a1851c9a8bf74/href">https://medium.com/media/bd2a952b13d4b25f825a1851c9a8bf74/href</a></iframe><p>Fitler 함수를 잘 들여다 보면 필터링 하는 조건을 함수를 통해 제어하는 것을 볼 수 있다. Map과 Reduce 함수도 마찬가지다. 함수를 인자로 받아 제어 패턴을 추상화 했다. 함수형 라이브러리인lodash 많은 함수도 HOF로 만들어져 있다.</p><p>다른 라이브러리에서 찾아보면 특히 React에서 이 HOF의 개념을 적극적으로 활용하고 있다. 나아가 개념을 함수 뿐만이 아니라 컴포넌트의 영역까지 확장시킨것이 바로 HOC(Higher-Order Component)이다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/81237f950fa41cbe21bf260d12a89928/href">https://medium.com/media/81237f950fa41cbe21bf260d12a89928/href</a></iframe><p>HOF의 강력한 매력은 함수를 이용해서 새로운 함수를 합성할 수 있다는 것이다. 이 개념을 적극 활용한 라이브러리가 <a href="https://ramdajs.com/">Ramda</a>이다. Ramda의 함수들은 HOF로 만들어져 있으므로 이를 활용하면 쉽게 적절한 합성함수들을 만들어 낼 수 있다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/166e6c6aceed22fc26f4a33644dbf38f/href">https://medium.com/media/166e6c6aceed22fc26f4a33644dbf38f/href</a></iframe><p>여담으로 Ramda는 Curry까지 사용하여 함수의 재사용에 있어서 더욱 강력한방법들을 제공한다.</p><h3>마치며</h3><p>HOF는 람다대수와 일급 객체(First-Class Citizens)라는 개념에 그 근간을 두고 있다. 또 Pure Function, Immutability같은 Functional Programming에 대한 개념의 이해가 선행되어야 자유자재로 사용하는데 무리가 없을 것이다. 이 포스트에서는 다루지 않았지만 흥미가 있는 사람은 꼭 FP의 매력을 공부해보길 바란다. 필자도 HOF를 코드에 잘 녹여낼 수 있는 그날을 상상하며 이곳에 정리해 본다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1c61e0bea79" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Babel 7 Released]]></title>
            <link>https://medium.com/@la.place/babel-7-released-2c00af5a3360?source=rss-e91974b65d5c------2</link>
            <guid isPermaLink="false">https://medium.com/p/2c00af5a3360</guid>
            <category><![CDATA[front-end-development]]></category>
            <category><![CDATA[babel]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[it]]></category>
            <category><![CDATA[development]]></category>
            <dc:creator><![CDATA[Haegul Pyun]]></dc:creator>
            <pubDate>Sun, 02 Sep 2018 08:48:08 GMT</pubDate>
            <atom:updated>2018-09-09T04:57:41.707Z</atom:updated>
            <content:encoded><![CDATA[<blockquote>Use next generation JavaScript, today.</blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*XmHUL5DeySv_dGmvbPqdDQ.png" /></figure><p>2018년 8월 27일. Front-End Developer라면 거의 모두 사용하고 있을 것이라 생각하는 Babel의 새로운 버전이 release 되었다. 기존 Babel 6이 나온지 3년이 되어가는 시점에서 Major 버전 업인 만큼 많은 변화가 생겼는데, 이번 기회에 어떻게 업그레이드 되었는지 살펴보도록 하자.</p><h3>Node.js 지원 버전의 변경</h3><p>기존 바벨에서 지원하고있던 node.js 0.10, 0.12, 4, 5버전의 지원이 중단되었다. 오피셜 가이드에서는 현재 LTS v8 버전을 권장하고 있으니, 이전 버전을 사용하는 개발자라면 이번 기회에 node.js 버전업도 같이 하도록 하자.</p><h3>SPEED</h3><p>기존 Babel보다 약 60% 정도 속도가 향상되었다고 한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/595/1*wA8I1wJLxFi9H6bDt0nYHA.png" /><figcaption>Henry Zhu Twitter</figcaption></figure><h3>Scoped Package 사용</h3><p>기존에 npm에서 babel을 설치할 때 아래와 같이 설치하였다.</p><pre>$ npm install babel-cli</pre><p>하지만 버전 7부터는 npm scope인 babel을 붙이는 방식으로 변경되었다.</p><pre>$ npm install @babel/cli </pre><p>설정파일을 사용할 경우에도 Scoped Package를 사용해야한다.</p><pre>module.exports = {  <br>  &quot;presets&quot;: [&quot;@babel/env&quot;],  // &quot;@babel/preset-env&quot;으로도 사용 가능<br>  &quot;plugins&quot;: [&quot;@babel/transform-arrow-functions&quot;]<br>};</pre><h3>Yearly Preset 지원 중단</h3><p>babel-preset-2015 , babel-preset-2016 , babel-preset-2017 , babel-preset-latest 등의 지원이 중단된다. 이제부턴 babel-preset-env 로 완전히 대체되므로 env를 사용하도록 하자.</p><h3>Stage Preset 지원 중단</h3><p>Babel 7부터는 babel-preset-stage-x preset의 지원이 중단된다. spread, decorators등 아직 proposal단계인 문법들이 강력해서 자주 사용했었는데, 이제는 필요한 proposal을 직접 추가하여 사용하여야 한다. Babel에서는 이를 자동으로 바꿔주는 <a href="https://github.com/babel/babel-upgrade">npx babel-upgrade</a>라는 것도 있으니 잘 활용하면 좋을 것 같다.</p><p>또 TC39에서 제안한 플러그인은 -proposal이 붙게 되므로, 변경할 때 주의하도록 하자.</p><pre>- @babel/plugin-transform-class-properties<br>+ @babel/plugin-proposal-class-properties</pre><h3>Babel Core의 Peer Dependency 변경</h3><p>peer dependency란 특정 모듈이 다른 모듈과 함께 의존성을 가지는 것을 말한다. 따라서 앞으로 babel을 사용하기 위해서는 @babel/core 를 명시적으로 추가해야 한다.</p><h3>Javascript Config Files</h3><p>기존에는 .babelrc 에 JSON Format만 사용할 수 있었는데, babel.config.js 를 사용하여 js로도 export할 수 있게 되었다. 이에 따라 빌드 환경에 따른 분기처리를 보다 쉽게 할 수 있다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d20f0065ebc4d28114233e85c19d45b4/href">https://medium.com/media/d20f0065ebc4d28114233e85c19d45b4/href</a></iframe><h3>설정 파일 overrides</h3><p>overrides 라는 기능이 추가되었는데, 특정 파일에 대해서는 다른 preset을 적용할 수 있는 기능이다. 이 기능을 사용하면, client, server, 혹은 test 환경이라던지 필요에 따라 다른 preset를 적용하는게 가능하다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f1fd752b1adf1fad3eb23ce454802cd0/href">https://medium.com/media/f1fd752b1adf1fad3eb23ce454802cd0/href</a></iframe><h3>TypeScript 지원</h3><p>이번 버전에서는 Babel개발팀이 TypeScript팀과 협업하여 type syntax를 파싱/트랜스파일링 할 수 있도록 만들었다고 한다. 이제 Babel에서 @babel/preset-typescript 를 사용하여 Typescript를 컴파일 할 수 있다. 자세한 내용은 <a href="https://blogs.msdn.microsoft.com/typescript/2018/08/27/typescript-and-babel-7/">여기</a>를 참고하도록 하자.</p><h3>JSX Fragment Support</h3><p>React로 개발할때 꽤 자주 사용하던 문법이 &lt;React.Fragment&gt;였는데, Babel7부터는 &lt;&gt;sugger syntax를 지원한다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f38b39579c38b1b223273285de3c15e6/href">https://medium.com/media/f38b39579c38b1b223273285de3c15e6/href</a></iframe><h3>“Pure” Annotation Support</h3><p>/*#__PURE__*/ 주석을 사용하여 minifiers에게 힌트를 줄수 있다는데, 아직까진 정확하게 어떻게 사용해야 할지 감이 잡히진 않는다. 혹시 아는 사람이 있다면 제보 부탁드립니다.</p><h3>class C extends HTMLElement {}</h3><p>Babe 7 에서 이제 HTMLElement , Array , Error 객체를 상속할 수 있다. 다른 언어에서는 Array를 상속해서 다양한 자료구조를 만들곤 했었는데, JS Class에서는 이에 대해 약간 아쉬운 감이 있었었다. 이번 기능의 추가로 Native built-in들을 상속함으로서 더 다양하게 Class를 사용할 수 있을 것이라 생각한다.</p><p>이 밖에도 Proposal의 자잘한 문법 변화, babel/core쪽 변화들이 있었지만 여기서는 다루지 않도록 하겠다. 이번 7버전은 그동안 Babel에 있었던 문제점의 수정, 그리고 재정비를한 느낌이 드는 메이저 업그레이드였다.</p><p>현대 JS에서 TC39의 새로운 Spec들은 개발의 생산성을 높여주고, 보다 편하게 개발할 수 있도록 많은 도움을 주고 있다. 이와 함께 Babel은 앞으로 프론트 개발에 있어서 더욱 그 필요성이 커질 것이라 본다. Javascript를 공부하면서 Babel의 다양한 기능들은 정말 보면 볼수록 흥미로우며, Babylon(지금은 @babel/parser로 이름이 바뀌었지만), core, generator, traverse등 어렵지만 알아두면 정말 큰 도움이 되는것 같다. 기회가 된다면 babel에서 사용하는 tooling들에 대해서도 다뤄보고 싶다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2c00af5a3360" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[React Render Props Pattern]]></title>
            <link>https://medium.com/@la.place/react-render-props-pattern-1c53a6b9645c?source=rss-e91974b65d5c------2</link>
            <guid isPermaLink="false">https://medium.com/p/1c53a6b9645c</guid>
            <category><![CDATA[it]]></category>
            <category><![CDATA[front-end-development]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[render-props]]></category>
            <category><![CDATA[react]]></category>
            <dc:creator><![CDATA[Haegul Pyun]]></dc:creator>
            <pubDate>Wed, 13 Jun 2018 08:49:41 GMT</pubDate>
            <atom:updated>2018-06-13T09:24:10.156Z</atom:updated>
            <content:encoded><![CDATA[<p>React에서 Component를 재사용 하기위해 많이 사용하는 기법중에HOC(Higher-Order Component)가 있다. 이와 마찬가지로 Component의 재사용성을 증가시켜 줄 Render Props Pattern에 대해 공부해 보도록 하자. 먼저 Render Props가 무엇인지 이해하기 위해 <a href="https://reactjs.org/docs/render-props.html">공식 문서</a>를 번역해 보았다.</p><h3><strong>Render Props</strong></h3><blockquote>“render props” 용어는 React component들 간에 코드를 공유하기 위해 함수형 props를 이용한 간단한 테크닉 입니다.</blockquote><p>render props pattern으로 구현된 component는 자체적으로 rendering 로직을 구현하는 대신 react element 요소를 반환하고 이를 호출하는 함수를 사용합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/635c3941aa583911954bbf0ea3754e46/href">https://medium.com/media/635c3941aa583911954bbf0ea3754e46/href</a></iframe><p>render props를 사용하는 라이브러리로는 <a href="https://reacttraining.com/react-router/web/api/Route">React Router</a>와 <a href="https://github.com/paypal/downshift">Downshift</a>가 있습니다.</p><p>이 문서에서는 왜 render props가 유용하고, 어떻게 여러분에 프로젝트에 적용할 수 있을지에 대해 이야기 하겠습니다.</p><h4><strong>횡단 관심사(Cross-Cutting Concerns)를 위한 render props 사용법</strong></h4><p>Component는 React에서 코드의 재사용성을 위한 주요 단위 입니다. 하지만한 컴포넌트에서 캡슐화 된 상태나 동작을, 같은 상태를 가진 다른 컴포넌트와 공유하는 방법이 항상 명확하지는 않았습니다.</p><p>예를 들면, 아래 Component는 웹 어플리케이션에서 마우스 위치를 추적하는 로직을 가지고 있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/8e059d1595a7620e92d5ce195ec94703/href">https://medium.com/media/8e059d1595a7620e92d5ce195ec94703/href</a></iframe><p>스크린 주위로 마우스 커서를 움직이면, component가 마우스의 (x, y)좌표를 &lt;p&gt;에 나타냅니다.</p><p>여기서 질문입니다: 다른 component에서 이 행위를 재사용하려면 어떻게 해야 할까요? 즉, 다른 component에서 커서 위치에 대해 알아야 할 경우, 해당 행위를 쉽게 공유할 수 있도록 캡슐화할 수 있습니까?</p><p>React에서 component는 코드 재사용의 기본 단위이므로, 우리가 필요로 하는 마우스 커서 트래킹 행위를 &lt;Mouse&gt; 컴포넌트로 캡슐화 하여 어디서든 사용할 수 있게 리팩토링 해보겠습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/fb589de04db4b7427ccd1b9c85c579b9/href">https://medium.com/media/fb589de04db4b7427ccd1b9c85c579b9/href</a></iframe><p>이제 &lt;Mouse&gt; component는 mousemove event를 감지하고 마우스 커서의 (x, y)위치를 저장하는 행위를 캡슐화 했습니다. 그러나 아직 완벽하게 재사용할 수 있는 건 아닙니다.</p><p>예를 들어, 마우스 주위에 고양이 그림을 보여주는 &lt;Cat&gt; component를 생각해 보겠습니다. 우리는 &lt;Cat mouse={{x, y}}&gt; prop을 통해 Cat component에게 마우스 좌표를 전달해주고 화면에 어떤 위치에 이미지를 보여줄지 알려 주고자 합니다.</p><p>첫번째 방법으로는, 다음과 같이 &lt;Mouse&gt; component의 render method안에 &lt;Cat&gt; component를 넣어 랜더링하는 방법이 있을 겁니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/06565a7d828e4126d6e92bd62d795a99/href">https://medium.com/media/06565a7d828e4126d6e92bd62d795a99/href</a></iframe><p>이러한 접근 방법은 특정 사례에서는 적용할 수 있지만, 우리가 원하는 행위의 캡슐화(마우스 트랙킹)라는 목표는 달성하지 못했습니다. 이제 우리는 다른 use case에서도 언제든지 마우스 위치를 추적할 수 있는 새로운 component(&lt;MouseWithCat&gt;과 근본적으로 다른)를 만들어야 합니다.</p><p>여기에 render prop를 사용할 수 있습니다. &lt;Mouse&gt;component 안에 &lt;Cat&gt;component를 hard-coding해서 결과물을 바꾸는 대신에, &lt;Mouse&gt;에게 동적으로 rendering을 할 수 있도록 해주는 함수형 prop을 제공 할 수 있습니다. — 이것이 render prop의 개념입니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/bac1530530fca958e401d7516536598e/href">https://medium.com/media/bac1530530fca958e401d7516536598e/href</a></iframe><p>이제 &lt;Mouse&gt; component의 행위를 복제하기 위해 hard-coding을 할 필요 없이 render함수에 prop으로 전달해 줌으로서, &lt;Mouse&gt; component는 동적으로 트래킹 기능을 가진 component들을 rendering할 수 있습니다.</p><p>정리하자면, <strong><em>render prop은 무엇을 render할지 component에게 알려주는 함수 입니다.</em></strong></p><p>이 테크닉은 행위(마우스 트래킹 같은)를 매우 쉽게 공유할 수 있도록 만들어 줍니다. 해당 행위를 적용하려면, &lt;Mouse&gt; 를 그리고 현재 (x, y) 커서위치에 무엇을 그릴지에 대한 정보를 prop을 통해 넘겨주기만 하면 됩니다.</p><p>render props에 대해 한가지 흥미로운점은 대부분의 <a href="https://reactjs.org/docs/higher-order-components.html">higher-order components(HOC)</a>에 render props pattern을 이식할 수 있습니다. 예를들면, 만약에 &lt;Mouse&gt; component보다 withMouse HOC를 더 선호한다면 render prop을 이용해서 다음과 같이 쉽게 HOC를 만들 수 있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/cbfbe110b9cc0c68ab213ee81fb43424/href">https://medium.com/media/cbfbe110b9cc0c68ab213ee81fb43424/href</a></iframe><p>render props를 사용하면 두가지 모두 사용이 가능합니다.</p><h4>Props를 사용하지 않은 패턴</h4><blockquote>여기서 중요하게 기억해야 할 것은, “render props pattern” 으로 불리는 이유 때문에 꼭 prop name으로 render를 사용할 필요는 없습니다. 사실, <a href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce">어떤 함수형 prop이든 render prop이 될 수 있습니다.</a></blockquote><p>위 예제에서는 render를 사용했지만, 우리는 children prop을 더 쉽게 사용할 수 있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/96571f7840876dc45b464983addbb844/href">https://medium.com/media/96571f7840876dc45b464983addbb844/href</a></iframe><p>실제로 JSX element의 “속성”목록에 하위 속성 이름(예를들면 render)을 지정할 필요는 없습니다. 대신에, element안에 직접 꽂아넣을 수 있습니다!</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/db6ae153ace54fcbfe6d0e3bc36f2bf9/href">https://medium.com/media/db6ae153ace54fcbfe6d0e3bc36f2bf9/href</a></iframe><p>이 테크닉은 <a href="https://github.com/chenglou/react-motion">react-motion</a> API에서 실제로 사용된 것을 볼 수 있습니다.</p><p>이 테크닉은 자주 사용되지 않기 때문에, API를 디자인 할 때 children은 function type을 가지도록 propTypes를 지정하는 것이 좋습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/c6a7102b1e420f351823342d5c536c20/href">https://medium.com/media/c6a7102b1e420f351823342d5c536c20/href</a></iframe><h3>주의 사항</h3><h4>React.PureComponent에서 render props pattern을 사용할 땐 주의 해주세요.</h4><p>render props pattern을 사용하면 React.PureComponent를 사용할 때 발생하는 이점이 사라질 수 있습니다. shallow prop comparison은 새로운 prop에 대해 항상 false를 반환합니다. 이 경우 각 render마다 render prop으로 넘어온 값을 항상 새로 생성합니다.</p><p>위에서 사용했던 &lt;Mouse&gt; component를 이용해서 예를 들어보겠습니다. mouse에 React.Component 대신에 React.PureComponent를 사용하면 다음과 같은 코드가 됩니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/72f1a3bb3da6a2848ac232bf03f6a070/href">https://medium.com/media/72f1a3bb3da6a2848ac232bf03f6a070/href</a></iframe><p>이 예제에서 &lt;MouseTracker&gt;가 render 될때마다, &lt;Mouse render&gt;의 prop으로 넘어가는 함수가 계속 새로 생성됩니다. 따라서 React.PureComponent를 상속받은 &lt;Mouse&gt; component의 효과가 사라지게 됩니다.</p><p>이 문제를 해결하기 위해서, 다음과 같이 instance method를 사용해서 prop을 정의합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/fd60f48ec49613c82fb56ebed8d6e0ec/href">https://medium.com/media/fd60f48ec49613c82fb56ebed8d6e0ec/href</a></iframe><p>만약 prop을 정적으로 정의할 수 없는 경우에는 &lt;Mouse&gt; component는 React.Component를 상속받아야 합니다.</p><p>render props 개념은 간단하다. 중복되는 Logic은 공유하고, 파생되는 UI는 props를 통해 분리하는 것이다. 이 간결하지만 강력한 패턴은 HOC와 더불어 생산성을 많이 향상시켜준다. HOC와 비교해서 알아두면 유용한데, 이 부분에 대해서는 다음에 따로 포스팅 하도록 하겠다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1c53a6b9645c" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[React v16.3.0 번역]]></title>
            <link>https://medium.com/@la.place/react-v16-3-0-release-note-%EB%B2%88%EC%97%AD-326c3e00706c?source=rss-e91974b65d5c------2</link>
            <guid isPermaLink="false">https://medium.com/p/326c3e00706c</guid>
            <category><![CDATA[react]]></category>
            <category><![CDATA[front-end-development]]></category>
            <category><![CDATA[web-development]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[it]]></category>
            <dc:creator><![CDATA[Haegul Pyun]]></dc:creator>
            <pubDate>Wed, 04 Apr 2018 14:47:11 GMT</pubDate>
            <atom:updated>2018-04-09T02:36:41.775Z</atom:updated>
            <content:encoded><![CDATA[<p>새로운 라이프 사이클이 추가된 React v16에 관해 공부할 겸 <a href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html">React v16.3.0 Official</a> 문서를 번역했습니다. 이해를 돕기 위해 의역한 부분도 있으므로 참고하여 읽어주시길 바랍니다.</p><h3>Official Context API</h3><p>수 년 동안, React는 Context를 위한 실험적인 API를 제공해 왔습니다. API는 강력한 도구임에도 불구하고, 상속문제로 인해 사용이 권장되지 않았습니다. 또 항상 더 나은 API로 대체하려고 했기 때문입니다.</p><blockquote>Note:: 오래된 Context API는 마이그레이션을 하기 위한 시간을 필요로 하기 때문에 React 16.x 버전에는 계속 유지될 예정입니다.</blockquote><p>다음은 새로운 Context API를 사용하여 “Theme”를 사용하는 방법을 보여주는 예제 입니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/b1d0c28b2409d5c4839679b49e3d2ea9/href">https://medium.com/media/b1d0c28b2409d5c4839679b49e3d2ea9/href</a></iframe><p><a href="https://reactjs.org/docs/context.html">새로운 context API 에 대해서 배우고 싶으면 여기를 클릭하세요.</a></p><h3>createRef API</h3><p>이전에는 React에선 refs를 관리하기 위해 두가지 방법을 제공했습니다: legacy string ref API와 callback API. lagacy string ref API가 더 편리하지만 <a href="https://github.com/facebook/react/issues/1373">두 가지 단점</a>이 있었기 때문에 공식적으로 callback API를 사용하는 것이 더 좋습니다.</p><p>16.3 버전에는 string ref API방식의 두가지 단점을 보완한 새로운 ref 관리 방법이 추가되었습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ebdb6e40048eccc82b5053ec8982a705/href">https://medium.com/media/ebdb6e40048eccc82b5053ec8982a705/href</a></iframe><blockquote>Note:: 새로운 createRef API가 추가되었어도 callback ref API는 계속 지원 될 예정입니다. 여러분의 Components에 있는 callback ref API를 교체할 필요는 없습니다. callback ref API는 더욱 유연한 기능이기 때문에 고급 기능으로 계속 남아있을 예정입니다.</blockquote><p><a href="https://reactjs.org/docs/refs-and-the-dom.html">새로운 createRef API에 대해서 배우고 싶으면 여기를 클릭하세요.</a></p><h4>forwardRef API</h4><p>Higher-order components(또는 HOCs)는 일반적으로 컴포넌트간 재사용을 위해이용됩니다. 위에서 언급한 “Theme” Context 예제를 바탕으로 현재 “Theme”를 주입하는 HOC를 만들 수 있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/15e01e4509860a5f1e365f4e9b4a73fc/href">https://medium.com/media/15e01e4509860a5f1e365f4e9b4a73fc/href</a></iframe><p>위의 HOC를 사용하여 ThemeContext를 직접 사용할 필요없이 구성 요소를 ThemeContext에 연결 할 수 있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/deb8b24d45854f1863e8042c1c744b34/href">https://medium.com/media/deb8b24d45854f1863e8042c1c744b34/href</a></iframe><p>HOC는 일반적으로 래핑하고있는 컴포넌트로 props를 전달합니다. 그러나 안타깝게도 refs는 전달할 수 없습니다. 만약 우리가 “FancyThemedButton을 사용할 때, “FancyButton”에 ref를 붙일 수 없다는 것을 의미합니다. 그래서 이 경우 focus() 함수를 호출 할 수 있는 방법이 없습니다.</p><p>새로운 forwardRef API는 ref를 props로 전달 할 수 있는 방법을 제공함으로써 이 문제를 해결하고 있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/6f6d83b067cf3ac997aaaa8e037531ba/href">https://medium.com/media/6f6d83b067cf3ac997aaaa8e037531ba/href</a></iframe><h3><strong>Component Lifecycle Changes</strong></h3><p>React 클래스 컴포넌트의 API들은 몇년간 조금씩 변화해오고 있습니다. 그러나 몇가지 고급 기능을 추가하면서(예를들면 <a href="https://reactjs.org/docs/react-component.html#componentdidcatch">error boundaries</a> 또는 곧 추가될 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">async rendering mode</a>) 설계 모델이 의도하지 않은 방향으로 확장되고 있었습니다.</p><p>예를 들면, 현재 API에서는 필수적이지 않은 초기 렌더링을 차단하기가 너무 쉽습니다. 부분적으로 주어진 task를 완료하는데 너무 많은 방법이 제공되어서 어떤 방법이 최적의 방법인지를 찾기가 쉽지 않습니다. 오류를 처리할 때 발생하는 인터럽트는 고려되지 않았으며 메모리 누수가 발생할 수 있다는 것을 인식했습니다. (이것은 향후 async rendering mode에 영향을 미칠 수 있습니다.) 또한 현재 클래스 컴포넌트 API는 <a href="https://twitter.com/trueadm/status/944908776896978946">React Compiler Prototype</a> 작성과 같은 작업을 복잡하게 만듭니다.</p><p>이러한 많은 이슈들은 컴포넌트 생명주기(Component lifecycle) 중 componentWillMount, componentWillReceiveProps, ComponentWillUpdate에 의해 발생하게 됩니다. 이들은 또한 React 커뮤니티에서 가장 혼란을 일으키고 있는 lifecycle이기도 합니다. 이러한 이유로 더 나은 방법을 제공하기 위해 위 method들은 deprecate될 예정입니다.</p><p>이 변화가 기존 구성 요소에 많은 영향을 미친다는 것을 알고 있습니다. 때문에 마이그레이션은 가능한 한 점진적으로 진행하여 천천히 개선할 수 있게 제공할 예정입니다.(페이스북에서는 50000개 이상의 컴포넌트들이 유지되고 있습니다. 우리 또한 영향을 받고 있습니다.)</p><blockquote>Note:: 16.x버전에서는 deprecation warning이 나타날 예정입니다. 그러나 legacy lifecycle들은 17 version까지 여전히 작동할 예정입니다.</blockquote><blockquote>17 version에서도 계속 사용할 수 있지만 문제가 발생할 수 있음을 나타내기 위해서 “UNSAFE_” prefix가 지정됩니다. 또한 <a href="https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles">자동으로 이들을 바꿀 수 있는 스크립트</a>도 준비하고 있습니다.</blockquote><p>추가로 unsafe lifecycle들 대신에 우리는 새로운 lifecycle들을 제공하고 있습니다.</p><ul><li><a href="https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops">getDerivedStateFromProps</a>는 componentWillReceiveProps의 대안으로 추가되었습니다.</li><li><a href="https://reactjs.org/docs/react-component.html#getsnapshotbeforeupdate">getSnapshotBeforeUpdate</a>는 안전하게 property들(예를들면 update로 인해 만들어지기전 DOM으로 부터)을 읽을 수 있도록 제공하고 있습니다.</li></ul><p><a href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html">새로운 lifecycle에 대해서 배우고 싶으면 여기를 클릭하세요.</a></p><h3>StrictMode Component</h3><p>StrictMode는 응용 프로그램의 잠재적인 문제점을 파악하기 위한 도구입니다. 그러나 Fragment, StrictMode는 가시적으로 보이는 UI가 없습니다. 이들은 추가적인 확인을 위한 경고들을 활성화 합니다.</p><blockquote>Note:: StrictMode는 개발 환경에서만 동작합니다. Production build에는 영향을 미치지 않습니다.</blockquote><p>StrictMode가 모든 문제를 해결할 순 없지만, 여러가지로 도움이 될 수 있습니다. 만약 당신이 strict mode에서 경고창을 보게 된다면 async rendering에 대한 버그를 발견할 수 있을 것입니다.</p><p>16.3 version에서는 다음과 같은 내용이 도움이 될 것입니다.</p><ul><li>안전하지 않은 lifecycle에 대한 식별</li><li>legacy string ref API를 사용할 때 경고</li><li>예상하지 못한 부작용(side effect)들을 탐색</li></ul><p>React의 향후 릴리즈에는 더 많은 기능이 추가 될 예정입니다.</p><p><a href="https://reactjs.org/docs/strict-mode.html">StrictMode 구성 요소에 대한 자세한 내용은 여기를 참고하세요.</a></p><p>React v16.3.0에서 가장 주목할만한 부분은 lifecycle API의 변화인 것 같습니다. async rendering mode에 대해서도 여러번 언급한 만큼 이 기능이 향후 React를 선택하게 되는 강력한 기능이 되지 않을까 조심스럽게 생각해 봅니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=326c3e00706c" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[알아두면 쓸만한 Chrome Console 기능]]></title>
            <link>https://medium.com/@la.place/%EC%95%8C%EC%95%84%EB%91%90%EB%A9%B4-%EC%93%B8%EB%A7%8C%ED%95%9C-chrome-console-%EA%B8%B0%EB%8A%A5-3a1bcbf447b5?source=rss-e91974b65d5c------2</link>
            <guid isPermaLink="false">https://medium.com/p/3a1bcbf447b5</guid>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[front-end-development]]></category>
            <category><![CDATA[debug]]></category>
            <category><![CDATA[it]]></category>
            <category><![CDATA[chrome]]></category>
            <dc:creator><![CDATA[Haegul Pyun]]></dc:creator>
            <pubDate>Sun, 31 Dec 2017 08:01:12 GMT</pubDate>
            <atom:updated>2018-04-08T06:02:16.772Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/721/0*o590KlBIMRrlsbUG." /></figure><p>개발할 때 Chrome 개발자도구의 console을 굉장히 자주 사용하는데(대부분의 개발자들이 그럴 것이라 생각한다), 오늘은 크롬 개발자도구의 편리한 기능과 잘 쓰진 않지만 알아두면 좋은 기능들을 한 번 정리해 보고자 한다.</p><h3>Console Open</h3><ul><li><strong>Windows / Linux</strong>: Ctrl+Shift+J</li><li><strong>Mac</strong>: Cmd+Opt+J</li><li><strong>개발자 도구가 열린 상태:</strong> ESC</li></ul><h3>Console Clear</h3><ul><li>clear() 입력</li><li>Ctrl+L</li></ul><h3>Log Options</h3><p>console 오른쪽 상단위 톱니바퀴를 누르면 옵션을 볼 수 있다. 주로 사용하는 기능은 다음과 같다.</p><ul><li>Hide network: 404 또는 500 오류 등은 보여주지 않는다.</li><li>Log XMLHttpRequst: XML Request를 기록</li><li>Preserve log: refresh나 탐색하는 동안 log기록을 유지</li><li>Show timestamps: log행 마다 timestamp를 보여 준다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/820/0*yHcG8UgbP3h6cMCg." /></figure><h3>그룹화하여 console message 출력하기</h3><p>console.group(), console.groupEnd() 명령어를 사용하면 메세지들을 그룹화 하여 보여줄 수 있다. 또한 이 그룹들은 중첩도 가능하다. 또 그룹이 축소된 상태로 보이게 하고 싶다면 console.group()대신 console.Collapsed()를 사용할 수도 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/820/0*jwcKiAxsuZC-G8HZ." /></figure><h3>특정 상황에서만 console message 출력하기</h3><p>console.assert()를 사용하면 첫번째 매개변수가 false일때만 두번째 매개변수를 출력한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/820/0*6sg7uek0hxTFLrqo." /></figure><h3>CSS로 출력 스타일 변경하기</h3><p>%c와 css style을 이용하면 출력되는 색이나 글자 크기를 바꿀 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/820/0*oDdWC6UNlABpgIEB." /></figure><h3>DOM Element를 Javascript 객체로 나타내기</h3><p>console로 DOM Element를 출력해보면 보통 다음과 같이 HTML 형식으로 표현되는 것을 볼 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/820/0*O1ECzoI8wPhaZK_6." /></figure><p>그러나 개발하다보면 해당 element의 속성을 보고싶은 경우가 있는데 이때 console.dir()를 사용하면 해당 element를 javascript객체로 표현해준다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/320/0*D1pZayT2u-1t7Xst." /></figure><h3>객체 정보를 표로 보기</h3><p>object나 배열을 console.table()을 사용하면 표로 볼 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/580/0*1jWIRe-uPciWOxfq." /></figure><h3>실행 시간 측정 하기</h3><p>console.time()과 console.timeEnd()를 사용하면 실행하는데 걸린 시간을 표시해준다. 따로 new Date() 함수등을 사용할 필요가 없어 편리하다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/820/0*pYxNglV_j0EOWidg." /></figure><h3>$_</h3><p>$_를 사용하면 가장 마지막으로 사용했던 selector나 평가식을 반환하다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/820/0*3Ho4pXjgljeWfxDP." /></figure><p>console에서 DOM Element를 선택할때 단축 선택자를 사용할 수 있다. 단축 선택자는 세 종류가 있다.</p><ul><li>$(): 일치하는 첫 번째 요소를 반환, document.querySelector()와 같다.</li><li>$$(): 일치하는 모든 요소의 배열을 반환, document.querySelectorAll()과 같다.</li><li>$x(): Xpath와 일치하는 요소의 배열을 반환한다.</li><li>$0–4: console에서는 마지막으로 불러왔던 요소 5개를 저장해둔다. 가장 최신은 $0, 가장 오래된 항목은 $4이다.</li></ul><h3>이벤트가 발생 했을 때 콘솔을 출력하고 싶을 때</h3><p>monitorEvents(element, eventType)을 사용하면 특정 이벤트가 발생 했을 때 coonsole에 보여줄 수 있다. unmonitorEvents(element)를 사용하면 이벤트 수신을 해제한다. 또 특정 객체에 연결되어있는 eventListener들을 보고싶다면 getEventListeners(element)를 사용하면 된다.</p><p>copy(object)를 사용하면 지정된 객체의 문자열 표현을 클립보드에 복사할 수 있다.</p><h3>특정 함수가 호출 되었을 때 디버그 실행하기</h3><p>debug(function)을 사용하면 해당 함수가 실행되었을때 sources 패널 내부에서 단계적으로 디버그를 할 수 있도록 해준다.</p><p>monitor(function) 함수를 실행하면 지정된 함수가 실행 되었을 때 함수 이름과 인수를 출력해준다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/820/0*uLJPE9Y8JcY2xiju." /></figure><h3>ES6 Template literals 응용하기</h3><p>chrome은 대부분의 ES6 문법을 지원하기 때문에 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Template_literals">template literals</a>를 그대로 사용할 수 있는데, console.log와 조합하면 꽤나 편리하게 사용이 가능하다. 특히 문자열과 변수를 함께 사용해야하는 경우 편리하다. 예를 들어보자. 보통 문자열 중간에 변수 값을 표현하려면 다음과 같이 많이 사용한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/820/0*74RXr2HktPqPbyOP." /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/820/0*O2UUlwnZr9MOwBVc." /></figure><p>template literals은 ``(backtick)과 ${object}를 사용하여 표현할 수 있다. 따라서 다음과 같이 console.log()에 다음과 같이 표현할 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/820/0*WktMbv13g0ujGKor." /></figure><p><em>Originally published at </em><a href="http://dev-momo.tistory.com/entry/%EC%95%8C%EB%A7%88%EB%91%90%EB%A9%B4-%EC%93%B8%EB%A7%8C%ED%95%9C-Chrome-Console-%EA%B8%B0%EB%8A%A5"><em>dev-momo.tistory.com</em></a><em> on December 31, 2017.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3a1bcbf447b5" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Image Filter for Nodejs]]></title>
            <link>https://medium.com/@la.place/image-filter-for-nodejs-62495cf38e7d?source=rss-e91974b65d5c------2</link>
            <guid isPermaLink="false">https://medium.com/p/62495cf38e7d</guid>
            <category><![CDATA[nodejs]]></category>
            <category><![CDATA[image-filter]]></category>
            <category><![CDATA[image-processing]]></category>
            <category><![CDATA[libraries]]></category>
            <category><![CDATA[javascript]]></category>
            <dc:creator><![CDATA[Haegul Pyun]]></dc:creator>
            <pubDate>Sun, 20 Aug 2017 07:47:41 GMT</pubDate>
            <atom:updated>2017-08-20T08:06:18.169Z</atom:updated>
            <content:encoded><![CDATA[<p>Introduce simple nodejs image filter library. When I developed server-side image processing project, there was no image filter library in nodejs. So, I decided to develop myself.</p><p>Here is a result.</p><p><a href="https://github.com/haegul/node-image-filter">haegul/node-image-filter</a></p><h3>Installation</h3><p>You can Install using NPM(Node Package Manager).</p><pre>$ npm install node-image-filter --save</pre><h3>Simple Usage</h3><p>You only remember only render function usage.</p><pre>render(imagePath, filter[, options], callback);</pre><p>You can use preset filters or custom filters. callback function receive result data. The data contains image buffer, type, width, height information. Let’s look at the example.</p><pre>const Filter = require(&#39;node-image-filter&#39;);<br><br>// express<br>app.use(function (req, res, next) {<br><br>    let imagePath = path.join(__dirname, &#39;../samples/cat.jpg&#39;);<br><br>    Filter.render(imagePath, Filter.preset.invert, function (result) {<br>        /* result format<br>        {<br>            data : stream,<br>            type : &#39;jpg&#39;,<br>            width : 1024,<br>            height : 768<br>        }<br>        */<br>        result.data.pipe(fs.createWriteStream(`result.${result.type}`));<br> // save local<br>        res.send(&#39;save filtered image&#39;);<br>    })<br>});</pre><h3>Preset Filters</h3><p>‘node-image-filter’ includes Preset filters. There are currently four filters in total. You just need to pass it as the second parameter of the Render function.</p><pre>const Filter = require(&#39;node-image-filter&#39;);<br><br>// filter list<br>Filter.preset.invert<br>Filter.preset.grayscale<br>Filter.preset.sepia<br>Filter.preset.brightness</pre><h3>Custom Filter</h3><p>You can also use your own filters. Pass the filter you created yourself as the second parameter. The filter function takes pixels as a parameter and must process these pixels.data and return.</p><pre>// custom filter<br>let CustomInvertFilter = function (pixels) {<br>    var data = pixels.data;<br>    for(let i=0; i&lt;data.length; i+=4 ){<br>        data[i] = 255 - data[i];<br>        data[i+1] = 255 - data[i+1];<br>        data[i+2] = 255 - data[i+2];<br>        data[i+3] = 255;<br>    }<br>    return data;<br>};<br><br>Filter.render(imagePath, CustomInvertFilter, function (result) {<br>    result.data.pipe(fs.createWriteStream(`result.${result.type}`)); // save local<br>    res.send(&#39;save filtered image&#39;);<br>})</pre><h3>Convolution</h3><p>You can also use convolution theory such as sobel, sharpen, and others. Here are some examples.</p><pre>// sobel<br>Filter.render(imagePath, Filter.preset.sobel, function (result) {<br>    result.data.pipe(fs.createWriteStream(`result.${result.type}`)); // save local<br>    res.send(&#39;save filtered image&#39;);<br>})<br><br>// sharpen<br>Filter.render(imagePath, Filter.preset.sharpen, function (result) {<br>    result.data.pipe(fs.createWriteStream(`result.${result.type}`)); // save local<br>    res.send(&#39;save filtered image&#39;);<br>})<br><br>// blur<br>let options = {<br>    value : 100<br>};<br><br>Filter.render(imagePath, Filter.preset.blur, options, function (result) {<br>    result.data.pipe(fs.createWriteStream(`result.${result.type}`)); // save local<br>    res.send(&#39;save filtered image&#39;);<br>})</pre><h4>Thanks for reading !</h4><p>In the GHB Repository, You can more detail introduction.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=62495cf38e7d" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Hello Medium]]></title>
            <link>https://medium.com/@la.place/hello-medium-39ed254cf706?source=rss-e91974b65d5c------2</link>
            <guid isPermaLink="false">https://medium.com/p/39ed254cf706</guid>
            <dc:creator><![CDATA[Haegul Pyun]]></dc:creator>
            <pubDate>Sun, 20 Aug 2017 07:20:44 GMT</pubDate>
            <atom:updated>2017-08-20T07:20:44.229Z</atom:updated>
            <content:encoded><![CDATA[<p>Hello Medium!!</p><p>안녕!!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=39ed254cf706" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>