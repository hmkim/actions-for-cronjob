<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Sangyeop Bono Yu on Medium]]></title>
        <description><![CDATA[Stories by Sangyeop Bono Yu on Medium]]></description>
        <link>https://medium.com/@Dev_Bono?source=rss-74dac2dd62dc------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*SJiCmwwOeJPzrLJhO0fD8Q.jpeg</url>
            <title>Stories by Sangyeop Bono Yu on Medium</title>
            <link>https://medium.com/@Dev_Bono?source=rss-74dac2dd62dc------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Sun, 12 May 2019 11:42:18 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@Dev_Bono" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[탄력적인 컴포넌트 작성하기]]></title>
            <link>https://medium.com/@Dev_Bono/%ED%83%84%EB%A0%A5%EC%A0%81%EC%9D%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0-3e73c6a4f36?source=rss-74dac2dd62dc------2</link>
            <guid isPermaLink="false">https://medium.com/p/3e73c6a4f36</guid>
            <category><![CDATA[react]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[transportation]]></category>
            <dc:creator><![CDATA[Sangyeop Bono Yu]]></dc:creator>
            <pubDate>Sun, 28 Apr 2019 08:10:18 GMT</pubDate>
            <atom:updated>2019-04-28T08:10:18.274Z</atom:updated>
            <content:encoded><![CDATA[<blockquote>이 글은 Dan Abramov의 <a href="https://overreacted.io/writing-resilient-components/">Writing Resilient Components</a>를 번역한 글입니다.</blockquote><p>이제 막 React를 배우기 시작한 사람들은 스타일 가이드를 찾고는 합니다. 프로젝트 전체에 일관된 규칙을 적용하는 것은 좋은 생각이지만, 규칙들 중 많은 수가 자의적인 것이고 React는 이들에 대해 별로 구애되지 않습니다.</p><p>서로 다른 타입 시스템을 사용할 수도 있고, 함수 선언이나 화살표 함수 중 한 쪽을 선호할 수도 있고, props를 알파벳 순으로 정렬하거나 원하는 대로 정렬할 수도 있습니다.</p><p>이러한 유연성은 이미 사용중인 코딩 규칙에 <a href="https://reactjs.org/docs/add-react-to-a-website.html">React 프로젝트를 통합하기</a> 쉽게 해 줍니다. 하지만 끊임없는 논쟁을 불러일으키기도 하죠.</p><p><strong>모든 컴포넌트가 따라야 하는 디자인 원칙은 <em>존재합니다</em>. 하지만 저는 스타일 가이드가 이러한 원칙을 잘 담고 있다고 생각하지 않습니다. 먼저 스타일 가이드에 대해 이야기한 다음, </strong><a href="https://overreactedio-pdui1sahc.now.sh/#%EC%9C%A0%EC%97%B0%ED%95%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0"><strong>정말로 유용한 원칙들에 대해 알아봅시다</strong></a><strong>.</strong></p><h3>상상 속의 문제에 신경쓰지 마세요</h3><p>컴포넌트 디자인 원칙에 대해 이야기하기 전에, 스타일 가이드에 대해 몇 마디 하겠습니다. 일반적인 의견은 아니지만 누군가는 이에 대해 이야기해야 하니까요!</p><p>자바스크립트 커뮤니티에는 linter에 의해 강제되는 몇몇 엄격하고 독선적인 스타일 가이드들이 있습니다. 이 가이드들이 일으키는 마찰이 그 이득보다 더 크다는게 제 개인적인 의견입니다. 완벽히 유효한 코드를 들고 와서는 “React가 이 코드에 대해 불평해요”라고 말하지만, 사실 불평하고 있는 것은 그 사람들의 lint 설정인 경우를 저는 수도 없이 봐왔습니다! 이 때문에 세 가지 문제가 생깁니다:</p><ul><li>사람들이 linter를 유용한 도구가 아니라 <strong>지나치게 시끄러운 문지기</strong> 정도로 여깁니다. 스타일 지적의 홍수 속에 유용한 경고가 묻히고 맙니다. 결과적으로 사람들은 디버깅 중에 linter의 메시지를 훑어보지 않게 되고, 유용한 조언도 놓치게 됩니다. Javascript를 별로 쓰지 않는 사람들(예를 들어 디자이너)은 코딩이 더 힘들어집니다.</li><li><strong>유효하거나 그렇지 않은 패턴을 구분</strong>하는 법을 배우지 않습니다. 예를 들어, 널리 알려진 규칙으로 componentDidMount 안에서 setState 호출을 금지하는 것이 있습니다. 하지만 이 방식이 정말로 “나쁜” 것이라면, React에서 그냥 그러지 못하게 막았을겁니다! 툴팁의 위치를 잡기 위해 DOM 노드의 레이아웃을 확인하는 것과 같이, 이 방식이 적당한 경우가 분명히 있습니다. 이 규칙을 “우회”하기 위해 setTimeout을 사용하는 사람들을 봤습니다. 완전히 핵심을 놓치고 있는거죠.</li><li>결국 사람들은 “규칙을 집행하는 사람의 마음가짐”을 가지고 <strong>의미있는 차이를 가져오지는 않지만</strong> 코드에서 쉽게 찾을 수 있는 규칙들을 강요하게 됩니다. “넌 함수 선언을 사용했지만, <em>우리</em> 프로젝트는 화살표 함수를 써.”. 저는 이런 식의 규칙을 강요하고 싶은 기분이 들 때면, 마음 속 깊은 곳을 들여다보고 이 규칙에 감정이 실려 있음을 깨닫습니다. 그리고 이 규칙을 놓아주기 위해 노력합니다. 이것들은 코드를 개선하지 않으면서도 가짜 성취감을 느끼게 합니다.</li></ul><p>제가 lint를 쓰지 말라고 말하는걸까요? 절대 아닙니다!</p><p><strong>좋은 설정과 함께라면 linter는 버그를 미리 발견하게 해주는 훌륭한 도구입니다.</strong>혼란은 <em>스타일</em>에 너무 집중할 때 생깁니다.</p><h3>Lint 설정, 설레지 않으면 버려라</h3><p>다음 주 월요일에 할 일을 제안해 보겠습니다. 30분 정도 팀원들을 소집해서 프로젝트 설정 내의 모든 lint 규칙을 확인합시다: <em>“이 규칙이 우리가 버그를 잡는데 도움이 된 적이 있었나?”</em> 만약 아니라면, <em>꺼버리세요.</em> (아니면 스타일 규칙이 없는 <a href="https://www.npmjs.com/package/eslint-config-react-app">eslint-config-react-app</a>에서 바닥부터 시작할 수도 있습니다.)</p><p>적어도 여러분의 팀은 마찰을 일으키는 규칙을 제거하는 절차를 갖추고 있어야 합니다. 당신이나 다른 누군가가 작년에 추가한 lint 설정이 “최선”일거라고 생각하지 마세요. 질문하고 답을 찾으세요. 누구도 당신이 직접 lint 규칙을 고를 만큼 똑똑하지 못하다고 말할 수 없습니다.</p><p><strong>하지만 포맷팅은 어떻게 하죠?</strong> <a href="https://prettier.io/">Prettier</a>를 사용하고 “스타일”에 대해서는 잊으세요. 당신 대신 수정해주는 도구가 있다면, 공백을 추가로 넣으라고 당신에게 소리지르는 도구는 필요 없습니다. <em>미학</em>을 위해서가 아니라 <em>버그</em>를 찾기 위해서 linter를 사용하세요.</p><p>물론, 포맷팅과 직접적인 연관이 있지는 않지만 프로젝트 전체에 일관성이 없으면 곤란한 코딩 스타일도 있습니다.</p><p>하지만 그 중 대부분은 lint 규칙을 통해 잡아내기에는 너무 미묘합니다. 팀원 간에 <strong>신뢰를 쌓고</strong>, 위키 페이지나 짧은 디자인 가이드를 통해 유용한 학습 내용을 공유하는 것이 중요한 이유입니다.</p><p>모든 것을 자동화할 필요는 없습니다! 가이드 안의 설명을 <em>정말로 읽어서</em> 얻을 수 있는 통찰은 “규칙”을 따르는 것보다 가치있습니다.</p><p><strong>하지만 엄격한 스타일 가이드를 따르는 것이 혼란을 줄 뿐이라면, 정말로 중요한건 뭐죠?</strong></p><p>그것이 이 글의 주제입니다.</p><h3>유연한 컴포넌트 작성하기</h3><p>몇 단계나 들여쓰기를 하는지나 import를 알파벳 순으로 정렬하는 일은 망가진 디자인을 고치는데엔 아무 도움이 안 됩니다. 그러니 코드가 어떻게 <em>보이는지</em> 대신, 어떻게 <em>작동하는지</em>에 집중하겠습니다. 다음 몇 가지 컴포넌트 디자인 원칙이 제가 매우 유용하다고 여기는 것들입니다:</p><ol><li><a href="https://overreactedio-pdui1sahc.now.sh/#%EC%9B%90%EC%B9%99-1-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9D%90%EB%A6%84%EC%9D%84-%EC%A4%91%EB%8B%A8%ED%95%B4%EC%84%9C%EB%8A%94-%EC%95%88-%EB%90%A9%EB%8B%88%EB%8B%A4"><strong>데이터 흐름을 중단해서는 안 됩니다</strong></a></li><li><a href="https://overreactedio-pdui1sahc.now.sh/#%EC%9B%90%EC%B9%99-2-%EC%96%B8%EC%A0%9C%EB%82%98-%EB%A0%8C%EB%8D%94%EB%A7%81-%ED%95%A0-%EC%A4%80%EB%B9%84%EA%B0%80-%EB%90%98%EC%96%B4-%EC%9E%88%EC%96%B4%EC%95%BC-%ED%95%A9%EB%8B%88%EB%8B%A4"><strong>언제나 렌더링 할 준비가 되어 있어야 합니다</strong></a></li><li><a href="https://overreactedio-pdui1sahc.now.sh/#%EC%9B%90%EC%B9%99-3-%EC%8B%B1%EA%B8%80%ED%86%A4%EC%9D%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%8A%94-%EC%97%86%EC%8A%B5%EB%8B%88%EB%8B%A4"><strong>싱글톤인 컴포넌트는 없습니다</strong></a></li><li><a href="https://overreactedio-pdui1sahc.now.sh/#%EC%9B%90%EC%B9%99-4-%ED%95%AD%EC%83%81-%EC%A7%80%EC%97%AD-%EC%83%81%ED%83%9C%EB%A5%BC-%EA%B2%A9%EB%A6%AC%ED%95%98%EC%84%B8%EC%9A%94"><strong>항상 지역 상태를 격리하세요</strong></a></li></ol><p>React를 쓰지 않더라도, 단방향 데이터 흐름을 사용하는 UI 컴포넌트를 사용한다면 시행착오를 통해 같은 원칙에 도달할겁니다.</p><h3>원칙 1: 데이터 흐름을 중단해서는 안 됩니다</h3><h3>렌더링 내에서 데이터 흐름을 중단하지 마세요</h3><p>여러분이 만든 컴포넌트를 사용하는 사람들은, 서로 다른 props를 전달할 때마다 컴포넌트가 그 변화를 반영하리라고 기대합니다:</p><pre>// isOk는 state에서 왔고 시간에 따라 변할 수 있습니다<br>&lt;Button <em>color</em>={isOk ? &#39;blue&#39; : &#39;red&#39;} /&gt;</pre><p>일반적으로, 이것이 React가 작동하는 기본 방식입니다. color prop을 Button컴포넌트 안에서 사용하면, 렌더링 할 때 위에서 전달한 값을 확인할 수 있습니다:</p><pre>function Button({ color, children }) {<br>  return (<br>    // ✅ `color`는 언제나 최신값입니다!<br>    &lt;button <em>className</em>={&#39;Button-&#39; + color}&gt;<br>      {children}<br>    &lt;/button&gt;<br>  );<br>}</pre><p>하지만 React를 배우는 사람들은 props를 state에 복사하는 실수를 종종 저지릅니다:</p><pre>class Button extends React.Component {<br>  state = {<br>    color: this.props.color  };<br>  render() {<br>    const { color } = this.state; // 🔴 `color`는 최신값이 아닙니다!    return (<br>      &lt;button <em>className</em>={&#39;Button-&#39; + color}&gt;<br>        {this.props.children}<br>      &lt;/button&gt;<br>    );<br>  }<br>}</pre><p>React외의 경우에 클래스를 사용해온 사람에게는 이쪽이 더 직관적으로 보일 수도 있습니다. <strong>하지만, prop을 state에 복사하면 이후의 모든 업데이트를 무시하게 됩니다.</strong></p><pre>// 🔴 위의 구현에서는 더 이상 작동하지 않습니다<br>&lt;Button <em>color</em>={isOk ? &#39;blue&#39; : &#39;red&#39;} /&gt;</pre><p>드물게 이러한 동작이 <em>의도적인</em> 경우에는, 변경 사항이 무시되리라는 점을 확실히 하기 위해 initialColor이나 defaultColor 같은 prop 이름을 사용하세요.</p><p>하지만 보통은 <strong>컴포넌트에서 바로 props를 읽도록</strong> 하고, props(또는 props에서 계산된 값)를 state에 복사하는 일은 피해야 합니다:</p><pre>function Button({ color, children }) {<br>  return (<br>    // ✅ `color`는 언제나 최신값입니다!<br>    &lt;button <em>className</em>={&#39;Button-&#39; + color}&gt;<br>      {children}<br>    &lt;/button&gt;<br>  );<br>}</pre><p>계산된 값 또한 사람들이 props를 state에 복사하게 만드는 이유 중 하나입니다. 예를 들어, 인수로 받은 배경색 color에 따라 고비용의 계산을 통해 <em>버튼의 텍스트</em> 색을 정하려는 경우를 생각해 봅시다:</p><pre>class Button extends React.Component {<br>  state = {<br>    textColor: slowlyCalculateTextColor(this.props.color)  };<br>  render() {<br>    return (<br>      &lt;button <em>className</em>={<br>        &#39;Button-&#39; + this.props.color +<br>        &#39; Button-text-&#39; + this.state.textColor // 🔴 `color` prop이 바뀌면 최신값이 아니게 됩니다      }&gt;<br>        {this.props.children}<br>      &lt;/button&gt;<br>    );<br>  }<br>}</pre><p>color의 변화에 따라 this.state.textColor를 다시 계산해주지 않기 때문에 이 컴포넌트는 제대로 작동하지 않습니다. 가장 쉬운 해결법은 textColor의 계산을 render 메서드 안으로 옮기고 PureComponent로 만드는 것입니다:</p><pre>class Button extends React.PureComponent {  render() {<br>    const textColor = slowlyCalculateTextColor(this.props.color);    return (<br>      &lt;button <em>className</em>={<br>        &#39;Button-&#39; + this.props.color +<br>        &#39; Button-text-&#39; + textColor // ✅ 언제나 최신입니다<br>      }&gt;<br>        {this.props.children}<br>      &lt;/button&gt;<br>    );<br>  }<br>}</pre><p>해결했습니다! 이제 props가 바뀌면, textColor를 다시 계산하지만, 같은 props에서 고비용의 계산을 다시 하는 일은 피하게 됩니다.</p><p>하지만 여기서 더 최적화하고 싶을 수도 있습니다. children이 바뀌면 어떻게 될까요? 이 경우에 textColor를 다시 계산하는 것은 좋아 보이지 않습니다. 두 번째 시도로 componentDidUpdate에서 계산을 해봅시다:</p><pre>class Button extends React.Component {<br>  state = {<br>    textColor: slowlyCalculateTextColor(this.props.color)<br>  };<br>  componentDidUpdate(prevProps) {    if (prevProps.color !== this.props.color) {      // 😔 업데이트가 있을 때마다 추가 렌더링      this.setState({        textColor: slowlyCalculateTextColor(this.props.color),      });    }  }  render() {<br>    return (<br>      &lt;button <em>className</em>={<br>        &#39;Button-&#39; + this.props.color +<br>        &#39; Button-text-&#39; + this.state.textColor // ✅ 마지막 렌더링에서는 최신<br>      }&gt;<br>        {this.props.children}<br>      &lt;/button&gt;<br>    );<br>  }<br>}</pre><p>하지만 컴포넌트에 변경이 있을 때마다 두 번의 렌더링이 필요하다면 개운치 못한 일입니다. 우리가 하려고 했던 최적화의 관점에서도 이상적이지 못합니다.</p><p>레거시 생명주기 메서드인 componentWillReceiveProps를 사용할 수도 있습니다. 하지만 사람들이 그 안에 부수효과를 넣어두는 경우가 종종 있습니다. 그러면 앞으로 나올 동시(Concurrent) 렌더링에서 문제가 생깁니다. 좀 더 안전한 getDerivedStateFromProps 메서드는 거추장스럽고요.</p><p>잠시 뒤로 물러나서 봅시다. 사실 우리가 원하는건 <a href="https://en.wikipedia.org/wiki/Memoization"><em>메모이제이션</em></a>입니다. 입력이 있고, 입력이 변하기 전에는 출력을 다시 계산하고 싶지 않습니다.</p><p>클래스를 사용한다면 메모이제이션을 위한 <a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization">핼퍼</a>를 사용할 수 있습니다. 하지만 Hooks는 거기서 더 나아가서 고비용의 계산을 메모이즈해주는 기능을 내장하고 있습니다:</p><pre>function Button({ color, children }) {<br>  const textColor = useMemo(    () =&gt; slowlyCalculateTextColor(color),    [color] // ✅ `color`가 바뀌기 전에는 다시 계산하지 않습니다  );  return (<br>    &lt;button <em>className</em>={&#39;Button-&#39; + color + &#39; Button-text-&#39; + textColor}&gt;<br>      {children}<br>    &lt;/button&gt;<br>  );<br>}</pre><p>필요한 코드는 이게 전부입니다!</p><p>클래스 컴포넌트에서는 <a href="https://github.com/alexreardon/memoize-one">memoize-one</a> 같은 핼퍼를 사용할 수 있습니다. 함수형 컴포넌트에서는 useMemo Hook이 비슷한 기능을 제공해줍니다.</p><p>이제 <strong>고비용의 계산을 최적화하기 위해서도 props를 state에 복사할 필요가 없습니다.</strong> 렌더링 결과는 props의 변화를 제대로 반영할 것입니다.</p><h3>부수효과 내에서 데이터 흐름을 중단하지 마세요</h3><p>지금까지 우리는 props 변화에 따라 일관된 렌더링 결과를 유지하는 방법에 대해 이야기했습니다. props를 state에 복사하지 않는 것은 그 중 일부입니다. 하지만 <strong>부수효과(예를 들어 데이터 가져오기) 또한 데이터 흐름의 중요한 부분 중 하나입니다</strong>.</p><p>이 React 컴포넌트를 살펴봅시다:</p><pre>class SearchResults extends React.Component {<br>  state = {<br>    data: null<br>  };<br>  componentDidMount() {    this.fetchResults();  }  fetchResults() {<br>    const url = this.getFetchUrl();<br>    // 데이터 가져오기 실행...<br>  }<br>  getFetchUrl() {<br>    return &#39;http://myapi/results?query&#39; + this.props.query;<br>  }<br>  render() {<br>    // ...<br>  }<br>}</pre><p>많은 React 컴포넌트가 이런 식입니다 — 하지만 자세히 들여다보면 버그가 있습니다. fetchResults 메서드는 데이터 가져오기를 위해 query prop을 사용합니다:</p><pre>getFetchUrl() {<br>    return &#39;http://myapi/results?query&#39; + this.props.query;  }</pre><p>하지만 query prop이 바뀌면 어떻게 될까요? 이 컴포넌트에서는 아무 일도 일어나지 않습니다. <strong>우리의 컴포넌트에서 부수효과가 props 변경을 제대로 반영하지 않는다는 뜻입니다.</strong> React 앱에서 버그를 일으키는 굉장히 흔한 원인입니다.</p><p>컴포넌트를 수정하기 위해 해야 할 일은:</p><ul><li>componentDidMount와 그 안에서 호출하는 모든 메서드들을 확인합니다.</li><li>우리 예시에서는 fetchResults와 getFetchUrl입니다.</li><li>이들 메서드에서 사용하는 모든 props와 state를 기록해둡니다.</li><li>우리 예시에서는 this.props.query입니다.</li><li>이 props들이 바뀔 때마다 부수효과를 다시 실행하도록 합니다.</li><li>componentDidUpdate를 통해 구현할 수 있습니다.</li></ul><pre>class SearchResults extends React.Component {<br>  state = {<br>    data: null<br>  };<br>  componentDidMount() {<br>    this.fetchResults();<br>  }<br>  componentDidUpdate(prevProps) {    if (prevProps.query !== this.props.query) { // ✅ 변경시에 다시 가져오기      this.fetchResults();    }  }  fetchResults() {<br>    const url = this.getFetchUrl();<br>    // 데이터 가져오기 실행...<br>  }<br>  getFetchUrl() {<br>    return &#39;http://myapi/results?query&#39; + this.props.query; // ✅ 변경사항이 제대로 처리됩니다  }<br>  render() {<br>    // ...<br>  }<br>}</pre><p>이제 우리의 코드는 부수효과에서도 props의 변경을 제대로 반영합니다.</p><p>하지만 이를 유지하는 것은 쉽지 않습니다. 예를 들어, 지역 상태에 currentPage를 추가하고 이를 getFetchUrl에서 사용하려 합니다:</p><pre>class SearchResults extends React.Component {<br>  state = {<br>    data: null,<br>    currentPage: 0,  };<br>  componentDidMount() {<br>    this.fetchResults();<br>  }<br>  componentDidUpdate(prevProps) {<br>    if (prevProps.query !== this.props.query) {<br>      this.fetchResults();<br>    }<br>  }<br>  fetchResults() {<br>    const url = this.getFetchUrl();<br>    // 데이터 가져오기 실행...<br>  }<br>  getFetchUrl() {<br>    return (<br>      &#39;http://myapi/results?query&#39; + this.props.query +<br>      &#39;&amp;page=&#39; + this.state.currentPage // 🔴 변경사항이 무시됩니다    );<br>  }<br>  render() {<br>    // ...<br>  }<br>}</pre><p>아이고, 부수효과가 currentPage의 변화를 제대로 따르지 않기 때문에 다시 버그가 생기고 말았습니다.</p><p><strong>props와 state는 React의 데이터 흐름에서 한 부분을 차지합니다. 렌더링과 부수효과 양쪽에서 이 데이터 흐름을 반영해야만 합니다!</strong></p><p>To fix our code, we can repeat the steps above:</p><ul><li>componentDidMount와 그 안에서 호출하는 모든 메서드들을 확인합니다.</li><li>우리 예시에서는 fetchResults와 getFetchUrl입니다.</li><li>이들 메서드에서 사용하는 모든 props와 state를 기록해둡니다.</li><li>우리 예시에서는 this.props.query <strong>와 </strong><strong>this.state.currentPage</strong>입니다.</li><li>이 props들이 바뀔 때마다 부수효과를 다시 실행하도록 합니다.</li><li>componentDidUpdate를 수정해서 구현할 수 있습니다.</li></ul><p>우리의 컴포넌트가 currentPage state의 변경사항을 처리하게끔 수정해 봅시다:</p><pre>class SearchResults extends React.Component {<br>  state = {<br>    data: null,<br>    currentPage: 0,<br>  };<br>  componentDidMount() {<br>    this.fetchResults();<br>  }<br>  componentDidUpdate(prevProps, prevState) {<br>    if (<br>      prevState.currentPage !== this.state.currentPage || // ✅ 변경시에 다시 가져오기      prevProps.query !== this.props.query<br>    ) {<br>      this.fetchResults();<br>    }<br>  }<br>  fetchResults() {<br>    const url = this.getFetchUrl();<br>    // 데이터 가져오기 실행...<br>  }<br>  getFetchUrl() {<br>    return (<br>      &#39;http://myapi/results?query&#39; + this.props.query +<br>      &#39;&amp;page=&#39; + this.state.currentPage // ✅ 변경사항이 제대로 처리됩니다    );<br>  }<br>  render() {<br>    // ...<br>  }<br>}</pre><p><strong>이런 실수를 자동으로 잡아낼 수 있다면 좋지 않을까요?</strong> linter가 도움이 되지 않을까요?</p><p>불행히도, 클래스 컴포넌트의 일관성을 자동적으로 확인하는 것은 매우 어렵습니다. 어떤 메서드도 다른 메서드를 호출할 수 있습니다. componentDidMount와 componentDidUpdate에서의 함수 호출을 정적으로 분석해보면 잘못된 탐지 결과 투성이입니다.</p><p>하지만 일관성을 정적으로 분석할 수 <em>있는</em> API 디자인이 <em>있습니다</em>. <a href="https://overreactedio-pdui1sahc.now.sh/a-complete-guide-to-useeffect/">React </a><a href="https://overreactedio-pdui1sahc.now.sh/a-complete-guide-to-useeffect/">useEffectHook</a>이 그러한 API의 예입니다:</p><pre>function SearchResults({ query }) {<br>  const [data, setData] = useState(null);<br>  const [currentPage, setCurrentPage] = useState(0);</pre><pre>  useEffect(() =&gt; {<br>    function fetchResults() {<br>      const url = getFetchUrl();<br>      // 데이터 가져오기 실행...<br>    }</pre><pre>    function getFetchUrl() {<br>      return (<br>        &#39;http://myapi/results?query&#39; + query +        &#39;&amp;page=&#39; + currentPage      );<br>    }</pre><pre>    fetchResults();<br>  }, [currentPage, query]); // ✅ 변경시에 다시 가져오기<br>  // ...<br>}</pre><p>우리는 로직을 부수효과의 <em>안쪽</em>에 두었고, 이는 <em>React 데이터 흐름의 어떤 값에</em>의존하는지 알기 쉽게 만들어줍니다. 이러한 값을 “종속성”이라고 하며, 예시에서는 [currentPage, query]입니다..</p><p>이 “부수효과의 종속성” 배열은 새로운 개념이 아닙니다. 클래스에서는 이 “종속성”들을 전체 메서드 호출에서 찾아야 했습니다. useEffect API는 같은 개념을 명시적으로 만들었을 뿐입니다.</p><p>이제는 이들을 자동적으로 검증할 수 있습니다:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/753/0*Br8ck-IYjVhzZlMC.gif" /></figure><p><em>(</em><em>eslint-plugin-react-hooks에 포함된 </em><em>exhaustive-deps lint 규칙의 데모입니다. 이 플러그인은 조만간 Create React App에 포함될 예정입니다.)</em></p><p><strong>컴포넌트를 클래스로 작성하든지 함수로 작성하든지에 관계 없이, 모든 props와 state 변경을 반영하는 것이 중요합니다.</strong></p><p>클래스 API를 사용한다면, 일관성에 대해 스스로 생각하고 모든 props나 state의 변화가 componentDidUpdate에서 적절히 처리되는지 검증해야 합니다. 그렇지 않으면 여러분의 컴포넌트는 props와 state의 변화에 대해 탄력적이라고 할 수 없습니다. 이는 React에만 해당하는 문제는 아닙니다. “생성”과 “변경”을 별개로 처리할 수 있는 모든 UI 라이브러리에 적용 가능합니다.</p><p><strong>useEffect API는 일관성을 위해 기존의 것을 뒤엎었습니다.</strong> <a href="https://overreactedio-pdui1sahc.now.sh/a-complete-guide-to-useeffect/">처음에는 좀 어색하게 느껴지지만</a>, 결과적으로 여러분의 컴포넌트는 변화에 더 탄력적이 됩니다. 그리고 “종속성”이 명시적이기 때문에, lint 규칙을 이용해 부수효과의 일관성을 <em>검증</em>할 수 있습니다. 버그를 잡기 위해 linter를 사용할 수 있는거죠!</p><h3>최적화 내에서 데이터 흐름을 중단하지 마세요</h3><p>실수로 props의 변경 사항을 무시할 수 있는 경우가 하나 더 있습니다. 컴포넌트를 직접 최적화하려고 할 때 일으킬 수 있는 실수입니다.</p><p>PureComponent나 React.memo처럼 기본적으로 얕은 비교를 이용하는 최적화 방법은 안전합니다.</p><p><strong>하지만, 비교를 직접 작성해서 컴포넌트를 “최적화”하려 하다가 실수로 함수 props를 비교하는 일을 잊어버릴 수 있습니다:</strong></p><pre>class Button extends React.Component {<br>  shouldComponentUpdate(prevProps) {    // 🔴 this.props.onClick을 비교하지 않음    return this.props.color !== prevProps.color;  }  render() {<br>    const onClick = this.props.onClick; // 🔴 변경사항을 반영하지 않습니다    const textColor = slowlyCalculateTextColor(this.props.color);<br>    return (<br>      &lt;button<br>        <em>onClick</em>={onClick}<br>        <em>className</em>={&#39;Button-&#39; + this.props.color + &#39; Button-text-&#39; + textColor}&gt;<br>        {this.props.children}<br>      &lt;/button&gt;<br>    );<br>  }<br>}</pre><p>처음에는 이 실수를 간과하기 쉽습니다. 클래스를 사용하면 보통은 <em>메서드</em>를 전달하다보니, 결과적으로 동일한 함수를 전달하기 때문입니다:</p><pre>class MyForm extends React.Component {<br>  handleClick = () =&gt; { // ✅ 언제나 같은 함수입니다    // 뭔가 하기  }  render() {<br>    return (<br>      &lt;&gt;<br>        &lt;h1&gt;Hello!&lt;/h1&gt;<br>        &lt;Button <em>color</em>=&#39;green&#39; <em>onClick</em>={this.handleClick}&gt;          Press me        &lt;/Button&gt;      &lt;/&gt;<br>    )<br>  }<br>}</pre><p>그래서 우리의 최적화는 <em>당장은</em> 아무 문제도 없습니다. 하지만, 다른 props가 바뀌지 않는 동안 onClick이 바뀌어도 이 컴포넌트는 계속 예전 값을 “보고” 있을겁니다.</p><pre>class MyForm extends React.Component {<br>  state = {<br>    isEnabled: true<br>  };<br>  handleClick = () =&gt; {<br>    this.setState({ isEnabled: false });    // 뭔가 하기<br>  }<br>  render() {<br>    return (<br>      &lt;&gt;<br>        &lt;h1&gt;Hello!&lt;/h1&gt;<br>        &lt;Button <em>color</em>=&#39;green&#39; <em>onClick</em>={          // 🔴 Button은 onClick prop의 변화를 무시합니다          this.state.isEnabled ? this.handleClick : null        }&gt;<br>          Press me<br>        &lt;/Button&gt;<br>      &lt;/&gt;<br>    )<br>  }<br>}</pre><p>이 예시에서는, 버튼을 누르면 그 버튼이 비활성화 되어야 합니다 — 하지만 Button컴포넌트는 onClick prop의 변화를 무시하기 때문에 제대로 작동하지 않습니다.</p><p>이 예시의 draft.content처럼, 함수의 동일성이 시간에 따라 바뀔 수 있는 무언가에 의존하고 있다면 상황은 더 혼란스러워집니다:</p><pre>drafts.map(draft =&gt;<br>    &lt;Button<br>      <em>color</em>=&#39;blue&#39;<br>      <em>key</em>={draft.id}<br>      <em>onClick</em>={<br>        // 🔴 Button은 onClick prop의 변화를 무시합니다        this.handlePublish.bind(this, draft.content)      }&gt;<br>      Publish<br>    &lt;/Button&gt;<br>  )</pre><p>draft.content이 나중에 바뀔 수 있음에도, Button 컴포넌트는 onClick prop의 변화를 무시하고 처음의 draft.content에 바인딩된 onClick 메서드의 “첫 번째 버전”을 보고 있습니다.</p><p><strong>그러면 이 문제를 어떻게 피할 수 있나요?</strong></p><p>저는 shouldComponentUpdate를 직접 구현하거나 React.memo()에 임의의 비교 함수를 지정하는 일은 피하라고 권하겠습니다. React.memo의 기본값인 얕은 비교는 함수 변화를 제대로 반영합니다:</p><pre>function Button({ onClick, color, children }) {<br>  const textColor = slowlyCalculateTextColor(this.props.color);<br>  return (<br>    &lt;button<br>      <em>onClick</em>={onClick}<br>      <em>className</em>={&#39;Button-&#39; + color + &#39; Button-text-&#39; + textColor}&gt;<br>      {children}<br>    &lt;/button&gt;<br>  );<br>}<br>export default React.memo(Button); // ✅ 얕은 비교를 사용합니다</pre><p>클래스에서는 PureComponent가 이렇게 동작합니다.</p><p>이렇게 하면 props로 다른 함수를 전달하더라도 항상 제대로 작동합니다.</p><p>임의의 비교 함수를 고집하겠다면, <strong>함수들을 빼먹지 않도록 하세요:</strong></p><pre>shouldComponentUpdate(prevProps) {<br>    // ✅ this.props.onClick를 비교하세요<br>    return (<br>      this.props.color !== prevProps.color ||<br>      this.props.onClick !== prevProps.onClick    );<br>  }</pre><p>앞에서 언급했듯이, 클래스 컴포넌트에서의 메서드 동일성은 거의 안정적이기 때문에 이 문제를 놓치기 쉽습니다(항상 그런 것은 아닙니다 — 그리고 거기서 일어나는 버그는 수정하기가 더 어렵죠). Hooks와 함께라면, 상황은 좀 달라집니다.</p><ol><li>함수는 <em>매 렌더링마다</em> 다르기 때문에 이런 문제를 <a href="https://github.com/facebook/react/issues/14972#issuecomment-468280039">즉시</a> 발견할 수 있습니다.</li><li>useCallback과 useContext를 이용해, <a href="https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down">함수를 전부 깊숙하게 전달하는 일을 피할 수 있습니다</a>. 이를 통해 함수에 대해 걱정하지 않고 렌더링을 최적화할 수 있습니다.</li></ol><p>이 절을 요악하자면, <strong>데이터 흐름을 중단하지 마세요!</strong></p><p>props와 state를 사용할 때마다, 이들을 변경하면 어떻게 되는지 생각해보세요. 대부분의 경우 컴포넌트는 최초의 렌더링과 업데이트를 다르게 처리해서는 안됩니다. 이를 통해 컴포넌트를 변화에 탄력적으로 만들 수 있습니다.</p><p>클래스를 사용하면, 생명주기 메서드 내에서 props와 state를 사용할 때 변경사항에 대해 잊어버리기 쉽습니다. Hooks는 여러분이 올바른 방법을 사용하게끔 도와주지만, 그러지 않고 있었다면 마음가짐을 좀 다르게 할 필요가 있습니다.</p><h3>원칙 2: 언제나 렌더링 할 준비가 되어 있어야 합니다</h3><p>React 컴포넌트는 여러분이 시간의 흐름에 대해 크게 걱정하지 않고도 렌더링 코드를 작성하도록 해줍니다. 여러분이 특정한 시점에 UI가 어때야 <em>하는지</em> 기술하면, React는 그렇게 되도록 해줍니다. 이 모델의 이점을 잘 활용하세요!</p><p>불필요한 시간적 가정을 컴포넌트의 행동에 도입하려 하지 마세요. <strong>컴포넌트는 언제든지 다시 렌더링할 준비가 되어 있어야 합니다.</strong></p><p>어떤 경우에 이 원칙을 어기게 될까요? React가 그러기 어렵게 해 주기는 하지만, 레거시 생명주기 메서드인 componentWillReceiveProps를 사용하면 가능합니다:</p><pre>class TextInput extends React.Component {<br>  state = {<br>    value: &#39;&#39;<br>  };<br>  // 🔴 부모가 렌더링 될 때마다 지역 상태를 초기화합니다  componentWillReceiveProps(nextProps) {    this.setState({ value: nextProps.value });  }  handleChange = (e) =&gt; {<br>    this.setState({ value: e.target.value });<br>  };<br>  render() {<br>    return (<br>      &lt;input<br>        <em>value</em>={this.state.value}<br>        <em>onChange</em>={this.handleChange}<br>      /&gt;<br>    );<br>  }<br>}</pre><p>이 예제에서 우리는 value를 지역 상태에 유지함과 동시에, value를 props에서 전달받습니다. “새 props를 전달받을 때마다”, state에서 value를 초기화하죠.</p><p><strong>우연한 시점에 전적으로 의존한다는 점이 이 패턴의 문제입니다.</strong></p><p>혹시 오늘은 이 컴포넌트의 부모가 거의 업데이트되지 않아서, TextInput이 폼을 저장할 때와 같이 중요한 순간에만 “props를 전달받을” 수도 있습니다.</p><p>하지만 내일 당신이 부모에 애니메이션을 좀 추가해서 더 자주 다시 렌더링되게 만들 수도 있습니다. 그러면 그 부모 컴포넌트는 자식의 상태를 계속해서 <a href="https://codesandbox.io/s/m3w9zn1z8x">“날려버리게”</a> 됩니다! <a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html">“You Probably Don’t Need Derived State”</a>에서 이 문제에 대해 더 알아볼 수 있습니다.</p><p><strong>그러면 이 문제를 어떻게 고치나요?</strong></p><p>무엇보다도 먼저, 우리는 마음 속 모델을 고쳐야 합니다. 우리는 “렌더링”을 “props 전달받기”와는 다른 무언가로 생각하는 것을 그만두어야 합니다. 부모에 의해 다시 렌더링되는 것과 자신의 지역 상태 변화에 의해 다시 렌더링되는 것이 서로 다르게 작동해서는 안 됩니다. <strong>컴포넌트는 렌더링이 가끔 일어나든 자주 일어나든간에 탄력적으로 작동해야 하고, 만약 그러지 못하고 있다면 특정한 부모와 너무 강하게 결합된 것입니다.</strong></p><p><em>(</em><a href="https://codesandbox.io/s/m3w9zn1z8x"><em>이 데모는</em></a><em> 다시 렌더링하는 일이 어떻게 취약한 컴포넌트를 망가뜨리는지 보여줍니다.)</em></p><p>여러분이 <em>정말로</em> props에서 state를 만들고 싶다면 몇 가지 <a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#preferred-solutions">다른</a> <a href="https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops">방법</a>이 있긴 하지만, 보통은 완전히 제어된(controlled) 컴포넌트를 사용해야 합니다:</p><pre>// Option 1: 완전히 제어된 컴포넌트.<br>function TextInput({ value, onChange }) {<br>  return (<br>    &lt;input<br>      <em>value</em>={value}<br>      <em>onChange</em>={onChange}<br>    /&gt;<br>  );<br>}</pre><p>아니면 제어되지 않는 컴포넌트를 초기화 가능한 key와 함께 사용할 수 있습니다:</p><pre>// Option 2: 완전히 제어되지 않는 컴포넌트.<br>function TextInput() {<br>  const [value, setValue] = useState(&#39;&#39;);<br>  return (<br>    &lt;input<br>      <em>value</em>={value}<br>      <em>onChange</em>={e =&gt; setValue(e.target.value)}<br>    /&gt;<br>  );<br>}</pre><pre>// 컴포넌트의 내부 상태를 key를 바꿈으로서 초기화 할 수 있습니다:<br>&lt;TextInput <em>key</em>={formId} /&gt;</pre><p>단지 컴포넌트 자신이나 부모가 더 자주 렌더링된다고 해서 그 컴포넌트가 망가져서는 안 된다는게 이 절의 핵심입니다. componentWillReceiveProps 생명주기 메서드만 피한다면 React API 디자인이 그러지 않도록 도와줄겁니다.</p><p>컴포넌트를 강제로 테스트해보려면 부모에게 이 코드를 잠시 추가해보세요:</p><pre>componentDidMount() {<br>  // 바로 제거하는 것을 잊지 마세요!  setInterval(() =&gt; this.forceUpdate(), 100);<br>}</pre><p><strong>이 코드를 남겨두지 마세요</strong> — 부모가 자주 다시 렌더링 되었을 때 무슨 일이 일어나는지 보기 위한 방법일 뿐입니다. 자식 컴포넌트가 망가지면 안 됩니다!</p><p>이렇게 생각할수도 있습니다: “props가 바뀔 때마다 state를 초기화하더라도, PureComponent를 통해 불필요한 렌더링을 막을 수 있을거야”.</p><p>아래 코드처럼 하면 되죠. 맞나요?</p><pre>// 🤔 불필요한 렌더링을 막아줍니다... 맞나요?class TextInput extends React.PureComponent {  state = {<br>    value: &#39;&#39;<br>  };<br>  // 🔴 부모가 렌더링될때마다 지역 상태를 초기화합니다<br>  componentWillReceiveProps(nextProps) {<br>    this.setState({ value: nextProps.value });<br>  }<br>  handleChange = (e) =&gt; {<br>    this.setState({ value: e.target.value });<br>  };<br>  render() {<br>    return (<br>      &lt;input<br>        <em>value</em>={this.state.value}<br>        <em>onChange</em>={this.handleChange}<br>      /&gt;<br>    );<br>  }<br>}</pre><p>처음에는 부모가 다시 렌더링될때 상태를 “날려버리는” 문제를 해결한 것처럼 보일수도 있습니다. props가 같으면 업데이트를 건너뛰므로, componentWillReceiveProps는 호출되지 않습니다.</p><p>하지만 이 방법이 우리에게 주는 안정감은 가짜입니다. <strong>이 컴포넌트는 <em>실제로</em> prop의 변화에 탄력적이지 않습니다.</strong> 예를 들어, 애니메이션 style과 같은 계속 변화하는 prop을 더 추가하게 되면, 내부 상태를 “잃게” 됩니다:</p><pre>&lt;TextInput<br>  <em>style</em>={{opacity: someValueFromState}}  <em>value</em>={<br>    // 🔴 TextInput의 componentWillReceiveProps가<br>    // 모든 애니메이션 틱마다 이 값으로 초기화됩니다.<br>    value<br>  }<br>/&gt;</pre><p>그러므로 이 접근방식은 여전히 취약합니다. PureComponent, shouldComponentUpdate, React.memo와 같은 여러 가지 최적화가 <em>행동</em>을 제어하기 위해 사용되어서는 안 된다는 점을 알 수 있습니다. <em>성능</em>을 개선하기 위해서만 이들을 사용하세요. 최적화를 제거했는데 컴포넌트가 <em>망가진</em>다면, 시작부터 부서지기 쉬운 컴포넌트였던 것입니다.</p><p>이에 대한 해결책은 앞에서 설명했던 것과 같습니다. “props를 전달받는”일을 특별한 이벤트로 다루지 마세요. props와 state를 “동기화”하지 마세요. 대부분의 경우, 모든 값은 완전히 (props를 통해) 제어되거나, (지역 상태를 통해) 제어되지 않아야 합니다. <a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#preferred-solutions">가능한</a> 파생 상태를 피하세요. <strong>그리고 언제나 렌더링 할 준비가 되어 있도록 하세요!</strong></p><h3>원칙 3: 싱글톤인 컴포넌트는 없습니다</h3><p>가끔 우리는 특정한 컴포넌트가 단 한번만 표시된다고 가정합니다. 네비게이션 바 처럼요. 가끔은 정말 그렇습니다. 하지만 이런 가정은 나중에서야 드러나는 디자인 문제를 일으키곤 합니다.</p><p>예를 들어, 당신이 라우팅 변화에 따라 두 Page 간에 애니메이션을 구현해야 할 수 있습니다. 애니메이션 중에는 두 컴포넌트가 모두 마운트되어 있어야 합니다. 하지만 이들 컴포넌트가 화면 상의 유일한 Page일 것이라고 가정했다는 사실을 깨닿게 됩니다.</p><p>이런 문제를 찾아내기는 쉽습니다. 그냥 재미삼아 여러분의 앱을 두 번 렌더링해보세요:</p><pre>ReactDOM.render(<br>  &lt;&gt;<br>    &lt;MyApp /&gt;    &lt;MyApp /&gt;  &lt;/&gt;,<br>  document.getElementById(&#39;root&#39;)<br>);</pre><p>이것저것 눌러보세요. (이 실험을 위해 CSS를 좀 손봐야 할수는 있습니다.)</p><p><strong>여러분의 앱이 여전히 의도한대로 작동하나요?</strong> 아니면 이상한 충돌과 오류가 보이나요? 이러한 테스트를 복잡한 컴포넌트에 가끔 해보고, 그 컴포넌트의 여러 복사본이 서로 충돌하지 않는지 확인해보는 것은 좋은 생각입니다.</p><p>저 자신도 몇 번 작성했던 문제가 될만한 패턴으로는 componentWillUnmount에서 전역 상태를 “정리”하는 것이 있습니다:</p><pre>componentWillUnmount() {<br>  // Redux 스토어 내의 뭔가를 초기화합니다  this.props.resetForm();}</pre><p>이런 컴포넌트가 페이지 내에 두 개 있다면, 하나를 언마운트하면 다른 하나가 망가질겁니다. <em>마운트</em> 할 때 전역 상태를 초기화하는 방법도 딱히 나은 것은 아닙니다:</p><pre>componentDidMount() {<br>  // Redux 스토어 내의 뭔가를 초기화합니다  this.props.resetForm();}</pre><p>이 경우 두 번째 컴포넌트를 <em>마운트</em>하면 처음 것이 망가져 버립니다.</p><p>이런 패턴은 우리의 컴포넌트가 깨지기 쉬운지 알아보는 좋은 지표입니다. <strong>트리를 <em>보여주거나</em> <em>숨기는</em> 일이 트리 바깥의 컴포넌트를 망가뜨려서는 안 됩니다.</strong></p><p>이 컴포넌트를 두 번 렌더링 할 생각이 있건 없건 간에, 이러한 문제를 해결하는 일은 장기적으로 도움이 됩니다. 이를 통해 더 탄력적인 디자인에 도달할 수 있습니다.</p><h3>원칙 4: 항상 지역 상태를 격리하세요</h3><p>소셜 미디어의 Post 컴포넌트를 생각해봅시다. 컴포넌트 내에는 (펼칠 수 있는) Comment 목록과 NewComponent 입력창이 있습니다.</p><p>React 컴포넌트는 지역 상태를 가질 수 있습니다. 하지만 어떤 상태가 정말로 지역 상태인가요? 포스팅 내용 자체는 지역 상태인가요 아닌가요? 댓글 목록은 어떤가요? 댓글 목록이 펼쳐저 있는지 아닌지는요? 댓글 입력창의 내용은요?</p><p>모든 것을 “상태 관리자”에 넣는 것에 익숙하다면, 이 질문에 대답하기 어려울 수 있습니다. 여기에 간단한 방법이 있습니다.</p><p><strong>어떤 상태가 지역 상태인지 확신할 수 없다면, 자기 자신에게 물어보세요: “이 컴포넌트가 두 번 렌더링된다면, 한 쪽에서 일어난 상호작용이 다른 쪽에서도 반영되어야 할까?” 답이 “아니오”라면, 지역 상태를 찾아낸겁니다.</strong></p><p>예를 들어, 같은 Post를 두 번 렌더링했다고 생각해봅시다. 그 안에서 서로 달라질 수 있는 것을 찾아봅시다.</p><ul><li><em>포스팅 내용.</em> 한 쪽 트리에서 포스팅을 수정하면 다른 트리에서 업데이트되기를 바랄겁니다. 그러므로 포스팅 내용은 Post 컴포넌트의 지역 상태가 되어서는 <strong>안됩니다</strong>. (대신 그 포스팅 내용이 Apollo나 Relay, Redux 같은 캐시 내에 있으면 됩니다.)</li><li><em>댓글 목록.</em> 포스팅 내용의 경우와 비슷합니다. 어느 한 트리에서 새 댓글을 추가하면 다른 트리에도 반영되기를 원할겁니다. 그러니 이상적으로는 댓글 목록을 위한 캐시를 두고, Post 내의 지역 상태에는 <strong>없어야</strong> 합니다.</li><li><em>어느 댓글이 펼쳐저 있는지.</em> 한쪽 트리에서 댓글을 펼쳤는데 다른 쪽에서도 펼쳐진다면 좀 이상할겁니다. 이런 경우에 우리는 코멘트 전체가 아닌 특정한 Comment <em>UI 표현</em>과 상호작용하고 있는 것입니다. 그러므로, “펼쳐짐” 플래그는 Comment의 지역 상태에 <strong>있어야</strong> 합니다.</li><li><em>댓글 입력창의 내용.</em> 한 입력창에서 타이핑하고 있는 댓글이 다른 트리에서도 업데이트되면 이상하겠죠. 입력창들이 명백하게 묶여있지 않은 한, 사람들은 이들이 독립적일거라고 생각합니다. 그러니 입력 내용은 NewComment 컴포넌트의 지역 상태에 <strong>있어야</strong> 합니다.</li></ul><p>이 규칙에 대해 교조적인 해석을 제안하는 것은 아닙니다. 물론 간단한 앱에서는 이들 “캐시”를 비롯해 모든 것을 지역 상태에 놓을 수도 있습니다. 저는 단지 이상적인 사용자 경험의 <a href="https://overreactedio-pdui1sahc.now.sh/ko/the-elements-of-ui-engineering/">첫번째 원칙</a>에 대해 이야기하고 있을 뿐입니다.</p><p><strong>정말로 지역 상태라면 전역에 두지 않도록 하세요.</strong> 이는 “탄력성”에 대한 우리의 주제와 맞닿아 있습니다: 그러면 컴포넌트 간의 예기치 못한 동기화가 줄어들게 됩니다. 거기에 더해서 이를 통해 성능 문제의 큰 부분 <em>또한</em> 해결할 수 있습니다. 상태가 적당한 위치에 있으면 “과도한 렌더링”이 문제가 되는 일이 더 줄어듭니다.</p><h3>요약</h3><p>지금까지의 원칙들을 다시 요약해 보겠습니다:</p><ol><li><a href="https://overreactedio-pdui1sahc.now.sh/#%EC%9B%90%EC%B9%99-1-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9D%90%EB%A6%84%EC%9D%84-%EC%A4%91%EB%8B%A8%ED%95%B4%EC%84%9C%EB%8A%94-%EC%95%88-%EB%90%A9%EB%8B%88%EB%8B%A4"><strong>데이터 흐름을 중단해서는 안 됩니다.</strong></a> props와 state는 변할 수 있으며, 컴포넌트는 항상 이들 변화를 반영해야 합니다.</li><li><a href="https://overreactedio-pdui1sahc.now.sh/#%EC%9B%90%EC%B9%99-2-%EC%96%B8%EC%A0%9C%EB%82%98-%EB%A0%8C%EB%8D%94%EB%A7%81-%ED%95%A0-%EC%A4%80%EB%B9%84%EA%B0%80-%EB%90%98%EC%96%B4-%EC%9E%88%EC%96%B4%EC%95%BC-%ED%95%A9%EB%8B%88%EB%8B%A4"><strong>언제나 렌더링 할 준비가 되어 있어야 합니다.</strong></a> 컴포넌트는 자주 렌더링되건 그러지 않건간에 망가져서는 안 됩니다.</li><li><a href="https://overreactedio-pdui1sahc.now.sh/#%EC%9B%90%EC%B9%99-3-%EC%8B%B1%EA%B8%80%ED%86%A4%EC%9D%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%8A%94-%EC%97%86%EC%8A%B5%EB%8B%88%EB%8B%A4"><strong>싱글톤인 컴포넌트는 없습니다.</strong></a> 컴포넌트가 딱 한 번 렌더링되더라도, 두 번 렌더링되었을 때 망가지지 않도록 하면 더 나은 설계가 됩니다.</li><li><a href="https://overreactedio-pdui1sahc.now.sh/#%EC%9B%90%EC%B9%99-4-%ED%95%AD%EC%83%81-%EC%A7%80%EC%97%AD-%EC%83%81%ED%83%9C%EB%A5%BC-%EA%B2%A9%EB%A6%AC%ED%95%98%EC%84%B8%EC%9A%94"><strong>항상 지역 상태를 격리하세요.</strong></a> 특정 UI 표현에서 어느 상태가 지역 상태인지 생각해보고, 그 상태를 필요 이상으로 끌어올리지 마세요.</li></ol><p><strong>이들 원칙은 여러분이 </strong><a href="https://overreactedio-pdui1sahc.now.sh/optimized-for-change/"><strong>변화에 최적화된</strong></a><strong> 컴포넌트를 작성하도록 도와줍니다. 이들 컴포넌트는 추가하고, 바꾸고, 없애기 쉽습니다.</strong></p><p>그리고 무엇보다도, 일단 우리의 컴포넌트가 탄력적이 되고 나면, props를 알파벳 순으로 정리할 것인가 말 것인가 하는 심각한 딜레마를 다시 고민할 수 있게 된다는 점이 중요합니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3e73c6a4f36" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[HTML Canvas로 기가 픽셀 데이터 시각화하기]]></title>
            <link>https://medium.com/lunit-engineering/html-canvas%EB%A1%9C-%EA%B8%B0%EA%B0%80-%ED%94%BD%EC%85%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EA%B0%81%ED%99%94%ED%95%98%EA%B8%B0-2645b3aa2091?source=rss-74dac2dd62dc------2</link>
            <guid isPermaLink="false">https://medium.com/p/2645b3aa2091</guid>
            <category><![CDATA[data-visualization]]></category>
            <category><![CDATA[digital-pathology]]></category>
            <category><![CDATA[web-development]]></category>
            <category><![CDATA[html5-canvas]]></category>
            <dc:creator><![CDATA[Sangyeop Bono Yu]]></dc:creator>
            <pubDate>Fri, 28 Dec 2018 07:46:27 GMT</pubDate>
            <atom:updated>2018-12-28T08:02:12.599Z</atom:updated>
            <content:encoded><![CDATA[<h3>HTML5 Canvas로 기가 픽셀 데이터 시각화하기</h3><p>이미 대부분의 의료기관에서 디지털화 되어 있는 영상의학(radiology) 분야와는 달리, 현재까지도 병리학(pathology) 분야에서는 조직 슬라이드를 광학 현미경을 통해 관찰하여 진단, 연구하는 전통적인 방법을 사용해 왔습니다. 그러나 IT 기술의 발전과 함께, 슬라이드를 스캔하여 컴퓨터로 저장, 분석할 수 있는 digital pathology system이 최근 활발히 보급되기 시작했습니다.</p><p>슬라이드 스캐너는 픽셀당 0.25μm 수준의 높은 해상도를 가지기 때문에, 손가락만 한 슬라이드 하나가 27.5 기가 픽셀의 고해상도 이미지로 변환됩니다. 이러한 고해상도 이미지를 다루는 작업은 <a href="https://www.slideshare.net/deview/134-ai-product">여러 어려움이 따르지만</a> 그만큼 흥미로운 도전입니다.</p><p>루닛의 인공지능 엔진은 Tissue, Structure, Cell의 세 가지 패널에서 분석 결과를 예측합니다. 이 결과를 시각화하여 자유롭게 확대 / 축소 / 이동하면서 살펴보기 위해 저희는 웹 애플리케이션 기반의 툴을 제작했습니다. 전체 UI는 React를, 타일링된 슬라이드 이미지 표시에는 <a href="https://openseadragon.github.io">OpenSeadragon</a>을 사용했습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/480/1*fLzjdT7IjvrNnkCw_qozag.gif" /></figure><h3>Tissue</h3><p>하나의 슬라이드 안에는 상피, 기질, 지방, 근육 등 여러 조직이 섞여 있게 마련입니다. 인공지능은 각 픽셀이 어느 영역에 속하는지를 예측합니다.</p><h4>요구 사항</h4><ul><li>슬라이드 이미지는 매우 크기 때문에 12.5배율에서 전체 형태를 볼 수도, 400배율에서 각 세포의 위치와 형태를 볼 수도 있습니다. Tissue 영역의 시각화는 어떤 배율에서도 표시할 수 있어야 합니다.</li><li>영역을 표시하기 때문에 시각화의 정밀도가 픽셀 수준으로 정확할 필요는 없습니다.</li><li>사용자에 의한 확대 / 축소 / 이동이 매우 빈번하게 일어나며, 프레임 저하를 최소화해야 합니다.</li><li>여러 종류의 Tissue의 시각화를 켜고 끄면서 동시에 표시할 수 있어야 합니다.</li></ul><h4>데이터 포맷</h4><p>원본인 슬라이드 이미지가 매우 크기 때문에, 예측 결과도 저장하거나 전송하기에는 지나치게 큽니다. 효율적인 데이터 포맷을 고르기 위해 다음과 같은 고려가 필요했습니다.</p><ul><li>높은 공간 효율성: 최초에 시도했던 JSON 포맷은 특정 영역이 어떤 조직에 속하는지를 표시하기 위해 X 좌표, Y 좌표, 영역 크기, Tissue 종류를 텍스트로 저장하기 때문에 실제로 가지는 정보 값에 비하면 크기가 매우 컸습니다.</li><li>브라우저 환경에서 처리의 용이성: 직접 스키마를 고안하고 바이너리 형태로 저장한다면 저장과 전송의 효율성은 극도로 올라가겠지만, 브라우저 환경에서 자바스크립트로 처리하기는 매우 어려워집니다. 네이티브 디코더를 사용할 수 있는 JSON보다도 성능이 떨어질 가능성이 높습니다.</li><li>디버깅 용이성: 데이터가 형식에 맞게 제대로 생성되었는지, 그 대략적인 형태는 어떠한지 엔진 개발자와 프론트엔드 개발자가 모두 쉽게 알 수 있어야 합니다. 일반적인 경우 JSON은 개발자가 읽기 쉽지만, 수십 MB에 달하는 크기가 되면 이야기가 달라집니다.</li></ul><p>이들 모두를 고려하여 선택한 데이터 포맷은 평범한 이미지 포맷입니다. 예측 결과를 bitmap mask로 표현하여 조직 종류를 색상 값으로 지정하면 전체 Tissue 데이터가 하나의 비트맵 이미지가 됩니다. 이미지 코덱을 이용하여 높은 효율로 압축할 수 있고, 디코딩도 브라우저가 처리해줍니다. 이미지 뷰어로 열어보면 대략적인 형태도 바로 알 수 있습니다.</p><p>이렇게 생성된 이미지를 네트워크로 전송하여 Canvas에 그리면 각 픽셀에 해당하는 데이터를 Uint8ClampedArray 형태로 접근할 수 있습니다. 픽셀의 색상 값에 따라 조직별로 mask를 분리하면 시각화 준비가 끝납니다.</p><h4>Pre-rendering</h4><p>사용자가 확대 / 축소 / 이동을 통해 시점(viewport)을 이동하게 되면 Canvas 영역을 새로 그려야 합니다. 초당 60프레임을 유지하기 위해서는 16.7ms 안에 모든 처리를 마쳐야 합니다(실제로는 브라우저에도 여유를 줘야 하기 때문에 이보다 더 적은 시간이 주어집니다). 이 때문에 전달받은 데이터를 매번 다시 그리는 방법은 사용할 수 없습니다.</p><p>대신 메모리를 사용해서 성능을 확보하도록 합시다. Tissue 영역을 종류별로 OffscreenCanvas에서 시각화하여 메모리에 저장합니다. OffscreenCanvas는 Chrome 69 버전 이후에서 플래그 없이 사용할 수 있으며, 웹 워커에서도 사용 가능하기 때문에 여러 Tissue를 멀티 스레드로 동시에 처리할 수 있습니다. 메인 UI 스레드의 로딩 애니메이션을 멈추지 않기 때문에 사용자가 더 빠르게 느끼는 것도 소소한 장점입니다.</p><p>이 중 사용자가 선택한 Tissue들만 합성해서 ImageBitmap 형태로 저장해 두었다가, 시점이 이동할 때마다 바뀐 transform matrix를 적용하여 화면상의 Canvas에 옮겨주면 됩니다. ImageBitmap은 Canvas에 매우 빠르게(<em>without undue latency</em>) 그릴 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*b07sNrPt7ikKoCGE7IbNFg.png" /></figure><p>실제로는 이 코드대로 구현할 경우 화면상에 아무것도 표시되지 않습니다. 전체 이미지 영역은 기가 픽셀 사이즈인데 비해 브라우저에서 Canvas에 할당해주는 메모리는 한계가 있기 때문입니다. 저는 downsampling을 통해 더 작은 공간에 그리도록 구현했습니다. 픽셀 수준의 정확도가 필요 없기 때문에 영역 경계가 조금 거칠어도 괜찮습니다.</p><h3>Structure / Cell</h3><p>슬라이드 이미지 내에 존재하는 혈관과 신경(Structure) 및 다양한 세포(Cell)들을 감별하기 위한 패널입니다. 인공지능은 Structure의 외곽선과 Cell의 중심점을 예측합니다.</p><h4>요구 사항</h4><ul><li>개별 요소가 전체 슬라이드 크기에 비해 매우 작으므로 저배율(100배 이하)에서는 표시하지 않아도 됩니다.</li><li>시각화의 정밀도가 픽셀 수준으로 정확하게 슬라이드 이미지와 일치해야 합니다.</li><li>사용자에 의한 확대 / 축소 / 이동이 매우 빈번하게 일어나며, 프레임 저하를 최소화해야 합니다.</li><li>여러 종류의 Structure와 Cell의 시각화를 켜고 끄면서 동시에 표시할 수 있어야 합니다.</li></ul><h4>데이터 포맷</h4><p>영역 정보이기 때문에 픽셀 수만큼의 데이터를 가지는 Tissue에 비해, Polygon 형태의 Structure와 Point 형태의 Cell의 경우 수십만 개 수준으로 데이터가 많지 않습니다. 다만 여전히 JSON으로 직렬화할 경우 지나치게 커서 네트워크를 통한 전송도 오래 걸리고, 브라우저에서 디코딩도 몇 초나 걸려서 사용에 불편함이 있었습니다. 때문에 인코딩 결과물이 훨씬 더 작고 디코딩도 빠른 <a href="https://msgpack.org">MessagePack</a>으로 변경하기로 했습니다.</p><h4>Spatial Indexing</h4><p>Tissue 시각화에서 했던 것처럼 전체 영역을 미리 그려둘 수 있으면 편하겠지만, 픽셀 수준의 정확도를 가지고 슬라이드 이미지 위에 표시하기 위해서는 downsampling을 사용할 수 없습니다. 종류도 Tissue 보다 몇 배는 많기 때문에 모두 그려두기에는 메모리 낭비가 심합니다.</p><p>다행히도 100배 이상의 고배율에서만 표시하면 된다는 조건이 있기 때문에, 한 번에 화면에 표시되어야 하는 요소의 개수는 많지 않습니다. spatial index를 사용해서 현재 시점 안에서 표시해야 할 요소만 골라서 그리도록 하면 수 ms 이내에 처리가 가능합니다.</p><p>서버에서 받아온 데이터의 X, Y 좌표를 키로 검색할 수 있게 적당한 자료구조에 넣어줍시다. 저는 R 트리보다 검색이 빠른 K-d 트리를 사용했습니다. 사용자가 시점을 이동할 때마다 표시 영역 내에 있는 요소만 꺼내서 Canvas에 그려주면 됩니다.</p><h3>마치며</h3><p>제목은 거창하게 시작했지만, 실제 구현에 대단한 로직이 들어가 있지는 않습니다. 다만 웹 개발에서 일상적이지는 않은 요구 사항을 마주하면서 문제를 풀어나가는 즐거움을 느낄 수 있는 프로젝트였습니다. 비슷한 요구 사항을 해결해야 하는 분들께 힌트가 되었으면 좋겠습니다.</p><blockquote><a href="https://www.wanted.co.kr/wd/2119">루닛에서는 저희와 함께 큰 문제를 풀어나가실 FRONT-END ENGINEER 분들을 모십니다.</a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2645b3aa2091" width="1" height="1"><hr><p><a href="https://medium.com/lunit-engineering/html-canvas%EB%A1%9C-%EA%B8%B0%EA%B0%80-%ED%94%BD%EC%85%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EA%B0%81%ED%99%94%ED%95%98%EA%B8%B0-2645b3aa2091">HTML Canvas로 기가 픽셀 데이터 시각화하기</a> was originally published in <a href="https://medium.com/lunit-engineering">루닛 (Lunit) 개발팀</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[문 문제(“THE DOOR PROBLEM”)]]></title>
            <link>https://medium.com/@Dev_Bono/%EB%AC%B8-%EB%AC%B8%EC%A0%9C-the-door-problem-716db2506b5e?source=rss-74dac2dd62dc------2</link>
            <guid isPermaLink="false">https://medium.com/p/716db2506b5e</guid>
            <category><![CDATA[game-design]]></category>
            <category><![CDATA[korean]]></category>
            <category><![CDATA[game-development]]></category>
            <dc:creator><![CDATA[Sangyeop Bono Yu]]></dc:creator>
            <pubDate>Mon, 30 Jul 2018 02:48:41 GMT</pubDate>
            <atom:updated>2018-07-31T02:30:24.656Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/640/1*BRfhpYXlmirNX8UWbsFVww.gif" /><figcaption><a href="https://www.deviantart.com/joseromanhdez/art/Knock-Penny-Big-Bang-Theory-264406488">Knock Penny — Big Bang Theory</a> by <a href="https://www.deviantart.com/joseromanhdez">JoseRomanHdez</a> (CC BY-NC-SA 3.0)</figcaption></figure><blockquote>이 글은 <a href="http://www.lizengland.com/blog/2014/04/the-door-problem/">Liz England의 &quot;The Door Problem”</a>을 번역한 글입니다.</blockquote><blockquote><em>“그래서 게임 디자이너가 하는 일이 뭔데? 당신 아티스트야? 캐릭터를 디자인하고 스토리를 쓰나? 아니 잠깐, 당신 프로그래머야?”</em></blockquote><p>내가 “천체물리학자”라는 직업에 대해 알고 있는 만큼이나, 게임 산업 바깥에 있는 사람들에게는 게임 디자인이 모호한 용어이다. 이게 내 직업이기도 하므로, 나는 게임에 대해서는 전혀 모르는 사람을 포함해서 다양한 배경을 가진 사람들에게 게임 디자인의 의미를 설명해야 했다.</p><h3>문 문제</h3><p>나는 내 직업을 “문 문제”라는 용어로 설명하는 걸 좋아한다.</p><p>가정: 당신은 게임을 만들고 있다.</p><ul><li>게임 안에 문이 있는가?</li><li>플레이어가 문을 열 수 있는가?</li><li>플레이어가 게임 안의 모든 문을 열 수 있는가?</li><li>아니면 문 중의 일부는 장식인가?</li><li>열 수 있는 문은 녹색이고 열 수 없는 문은 빨간색인가? 열 수 없는 문 앞에는 쓰레기가 쌓여있는가? 당신 그냥 문손잡이를 없애고 퇴근하려고 한 건가?</li><li>문을 잠그거나 잠금을 해제할 수 있는가?</li><li>문이 잠겨있지만 열 수 있을 것이거나, 반대로 절대 열 수 없다면 플레이어에게 어떤 의미인가?</li><li>플레이어가 잠긴 문을 어떻게 여는지 아는가? 열쇠가 필요한가? 콘솔을 해킹해서? 퍼즐을 풀어서? 스토리가 흐르기를 기다려서?</li><li>열 수는 있지만 플레이어가 들어가지 않을 문이 있는가?</li><li>적들은 어디서 오는가? 문으로 뛰어들어오는가? 그 후에 문은 잠기는가?</li><li>플레이어는 어떻게 문을 여는가? 단지 걸어 들어가면 미닫이로 열리는가? 여닫이문인가? 플레이어가 문을 열기 위해 버튼을 눌러야 하는가?</li><li>플레이어가 지나가면 문이 잠기는가?</li><li>플레이어가 둘이라면? 두 플레이어가 모두 지나가야만 문이 잠기는가?</li><li>해당 레벨이 매우 크고 모든 것이 동시에 존재할 수 없다면? 만약 한 플레이어가 뒤에 남아있고 그 아래 계단은 사라진다면 어떻게 하겠는가?</li><li>두 플레이어가 같은 방에 올 때까지는 진행을 멈추겠는가?</li><li>뒤에 남은 플레이어를 순간 이동 시킬까?</li><li>문은 얼마나 큰가?</li><li>문이 플레이어가 지나갈 수 있을 만큼 커야 하나</li><li>동료 플레이어는 어떻게 되나? 플레이어 1이 문 앞에 서 있으면 플레이어 2는 가로막히나?</li><li>당신을 따라다니는 우군은? 그들 중 몇 명이나 걸리지 않고 문을 지나갈 수 있는가?</li><li>적들은? 중간보스들이 사람보다 크면서 문에는 크기가 맞아야 하나?</li></ul><p>이건 전통적인 디자인 문제이다. 누군가는 문 문제를 풀어야 하고 그 누군가는 바로 디자이너이다.</p><h3>다른 문 문제들</h3><p>큰 회사에서의 역할분담을 이해시키기 위해, 나는 다른 사람들이 문을 어떻게 대하는지 설명한다.</p><ul><li>크리에이티브 디렉터: “그래, 우리는 분명히 이 게임에 문이 필요해”</li><li>프로젝트 매니저: “사람들이 문을 만들 수 있게 스케줄에 반영할게”</li><li>디자이너: “우리가 필요한 문이 어때야 하는지 문서를 쓸게”</li><li>컨셉 아티스트: “죽여주는 문 그림을 좀 그려왔어”</li><li>아트 디렉터: “여기 세 번째 그림이 바로 우리가 필요한 스타일의 문이야”</li><li>환경 아티스트: “이 그림 가져다가 게임 안의 대상으로 만들게”</li><li>애니메이터: “문이 열리고 닫히게 해주지”</li><li>오디오: “문이 열리고 닫힐 때 나는 소리를 만들게”</li><li>FX 아티스트: “문이 열릴 때 멋진 스파크를 넣어주지”</li><li>작가: “문이 열릴 때, 플레이어는 ‘이것 봐! 문이 열렸어!’라고 말할거야”</li><li>광원효과담당: “문이 잠겨있을 땐 붉은빛이 나고, 열려있을 땐 녹색빛이 나”</li><li>법무: “환경 아티스트가 문 위에 스타벅스 로고를 그렸어. 고소당하고 싶지 않으면 빼야 할 거야”</li><li>게임플레이 프로그래머: “이 문은 플레이어가 얼마나 가까이 있느냐에 따라 열리고 닫혀. 그리고 스크립트로 잠갔다 풀었다 할 수 있어”</li><li>AI 프로그래머: “적들과 우리 편들은 문이 있으면 지나갈지 말지 판단해”</li><li>네트워크 프로그래머: “모든 플레이어들이 문이 열리는걸 동시에 봐야 하나요?”</li><li>릴리즈 엔지니어: “그 문이 발매에 포함되길 원한다면 오후 3시까지는 만들어줘야 해”</li><li>코어 엔진 프로그래머: “게임 내에 문이 1024개까지 들어갈 수 있도록 코드를 최적화했어”</li><li>툴 프로그래머: “문을 배치하기 더 쉽게 만들었어”</li><li>레벨 디자이너: “이 단계에 문을 배치하고 잠갔어. 이벤트 후에 문을 열 거야”</li><li>UI 디자이너: “문에 대상 표시를 추가하고 지도에 아이콘이 표시되게 했어”</li><li>QA 테스터: “문으로 걸어가고, 뛰어가고, 점프하고, 닫힐 때까지 서있어봤어. 저장했다가 불러온 다음 문으로 걸어갔어. 죽었다가 다시 불러온 다음 문으로 걸어갔어. 문으로 수류탄을 던졌어”</li><li>UX / 사용성 연구원: “Craigslist(미국판 벼룩시장)에서 문을 지나가볼 사람들을 모집했으니 무슨 문제가 생기는지 알 수 있을 거야”</li><li>현지화: “Door. Puerta. Porta. Porte. Tür. Dør. Deur. Drzwi. Drws. 문”</li><li>프로듀서: “그 문을 모두에게 줘야 할까 아니면 예약구매자를 위한 특전으로 남겨둬야 할까?”</li><li>퍼블리셔: “이 문들이 올가을 라인업에서 이 게임이 살아남는 데 많은 도움이 될거야”</li><li>CEO: “이 문을 만드는데 얼마나 시간과 노력이 들었는지 잘 알고 있다네”</li><li>PR: “팬 여러분, 우리의 다음 작품에 열광하실 겁니다 #게임개발 #문 #차세대 #리트윗”</li><li>커뮤니티 매니저: “팬들에게 문에 대한 그들의 관심사가 다음 패치에 반영될 거라고 알려줘야겠어”</li><li>고객지원: “플레이어 하나가 문을 잘 모르겠다고 문의해서 어떻게 사용하는지 설명해줬어요”</li><li>플레이어: “문이 있는 줄도 몰랐어”</li></ul><p>내가 이 예시를 좋아하는 이유는 이 예시가 매우 따분하기 때문이다. 게임 디자인은 현란하고 멋지고 광적인 아이디어에 대한 것이고 언제나 재밌을 거라는 인상이 있다. 하지만 내가 “문에 관해 이야기하자면…”이라고 시작하면, 바로 매일같이 이루어지는 실제적인 고민으로 넘어가게 된다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=716db2506b5e" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[제프 딘의 진실]]></title>
            <link>https://medium.com/@Dev_Bono/%EC%A0%9C%ED%94%84-%EB%94%98%EC%9D%98-%EC%A7%84%EC%8B%A4-3fbb4e0e1cf5?source=rss-74dac2dd62dc------2</link>
            <guid isPermaLink="false">https://medium.com/p/3fbb4e0e1cf5</guid>
            <category><![CDATA[korean]]></category>
            <category><![CDATA[programming]]></category>
            <category><![CDATA[humor]]></category>
            <category><![CDATA[jeff-dean]]></category>
            <dc:creator><![CDATA[Sangyeop Bono Yu]]></dc:creator>
            <pubDate>Fri, 11 May 2018 08:47:16 GMT</pubDate>
            <atom:updated>2018-05-11T08:51:52.205Z</atom:updated>
            <content:encoded><![CDATA[<p>Jeff Dean은 구글의 전설적인 프로그래머로, BigTable, MapReduce등 구글의 핵심기술을 만들었습니다. 그의 위대함을 칭송하기 위해 사람들은 ‘척 노리스의 진실’을 패러디한 ‘제프 딘의 진실’을 만들었습니다.</p><blockquote><a href="https://www.quora.com/Jeff-Dean/What-are-all-the-Jeff-Dean-facts">https://www.quora.com/Jeff-Dean/What-are-all-the-Jeff-Dean-facts</a></blockquote><ul><li>컴파일러는 제프 딘에게 경고하지 않는다. 그가 컴파일러에게 경고한다.</li><li>2000년 후반에 제프 딘의 코드 작성 속도가 40배로 빨라졌는데, 그가 키보드를 USB 2.0으로 업그레이드 했기 때문이다.</li><li>제프 딘은 커밋하기 전에 코드를 빌드 해보는데, 컴파일러와 링커에 버그가 있는지 확인하기 위해서일 뿐이다.</li><li>모든 포인터는 제프 딘을 가리킨다.</li><li>gcc -O4 명령은 당신의 코드를 제프 딘에게 보내서 재작성한다.</li><li>제프 딘은 피보나치 수열의 203번째 숫자를 1초 내에 답하는 바람에 튜링 테스트에서 떨어진 적이 있다.</li><li>제프 딘이 이더넷에 프레임을 보내면 다른 프레임들은 자기들이 나온 랜카드의 버퍼메모리로 도망가 버리기 떄문에 절대 충돌이 일어나지 않는다.</li><li>상수 효율에도 만족하지 못한 제프 딘은 세계 최초의 O(1/n) 알고리즘을 만들었다.</li><li>제프 딘이 휴가를 갔을 때, 구글의 서비스들이 불가사의하게도 며칠동안 멈춰버렸다. 이것은 정말 사실이다.</li><li>제프 딘은 어쩔 수 없이 비동기 API를 만들었는데, 그가 어느날 함수를 최적화했더니 실행하기도 전에 결과를 반환했기 때문이다.</li><li>제프 딘이 소프트웨어를 설계할때면, 먼저 바이너리로 코드를 짠 다음 문서화를 위해 소스코드를 작성한다.</li><li>제프 딘이 O(n²) 알고리즘을 짠 적이 있었다. 바로 외판원 문제를 해결하기 위한 것이었다.</li><li>제프 딘은 printf() 호출 하나만으로 웹서버를 구현한 적이 있다. 다른 엔지니어들이 거기에 수천줄의 설명을 주석으로 달았지만 어떻게 작동하는지는 아직도 모른다. 오늘날의 구글 검색 페이지가 그 프로그램이다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ytPYOBKTnBe-Lm7fexsz4A.jpeg" /><figcaption><a href="https://ko.wikipedia.org/wiki/커넥트포#/media/File:Connect_Four.jpg">Connect Four</a>, CC BY 3.0</figcaption></figure><ul><li>제프 딘은 Connect Four 게임(4목 게임)에서 당신을 이길 수 있다. 세 턴만에.</li><li>당신의 코드가 정의되지 않은 동작을 포함한다면, 당신은 세그멘테이션 오류와 깨진 데이터를 얻게 될 것이다. 제프 딘의 코드가 정의되지 않은 동작을 포함한다면, 유니콘이 무지개를 타고 나타나 모두에게 공짜로 아이스크림을 나눠 줄 것이다.</li><li>제프 딘이 프로파일러를 실행하자, 루프들이 겁에 질려서 저절로 풀려버렸다.</li><li>제프 딘의 키보드에는 두 개의 키밖에 없다. 1과 0.</li><li>제프 딘은 잠이 오지 않을 때면 양을 맵리듀스한다.</li><li>제프 딘은 스피커나 헤드폰이 필요 없다. 그가 cat *.mp3라고 친 다음 화면을 힐끗 보면, 일하는 동안 그의 뇌가 백그라운드에서 음악을 재생한다.</li><li>제프 딘은 그의 프로그래밍 수업을 cat &gt; /dev/mem으로 시작한다.</li><li>제프 딘은 Emacs와 VI 양쪽 다 쓰지 않는다. 그는 zcat에 그의 코드를 적는데, 그 쪽이 더 빠르기 때문이다.</li><li>제프 딘은 패스워드를 딱 하나만 외우고 있다. 그는 매번 사이트 이름을 거기에 붙인 다음 SHA-256 해시를 계산해서 패스워드로 입력한다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*35zhr22ksEOsakbbZe5llg.jpeg" /><figcaption><a href="https://en.wikipedia.org/wiki/Etch_A_Sketch#/media/File:Taj_Mahal_drawing_on_an_Etch-A-Sketch.jpg">Etch-a-Sketch</a>, CC BY-SA 3.0</figcaption></figure><ul><li>하루는 제프 딘이 나가면서 노트북 대신 Etch-a-Sketch를 들고 나간 적이 있다. 진짜 노트북을 가지러 돌아오는 길에, 그는 Etch-a-Sketch로 테트리스를 할 수 있도록 프로그램했다.</li><li>제프 딘이 거미를 깨문 적이 있는데, 그 거미는 초능력이 생기고 C언어를 읽을 수 있게 되었다.</li><li>알렉산더 그레이엄 벨이 전화기를 발명했을때, 그는 제프 딘에게서 온 부재중 전화를 발견했다.</li><li>예전에 빛의 속도는 진공에서 35마일이었다. 그래서 제프 딘은 그의 주말을 물리법칙을 최적화하는데 썼다.</li><li>제프 딘은 1969년 12월 31일 오후 11시 48분에 태어났다. 그리고 그가 타임카운터를 구현하는데 12분이 걸렸다.</li><li>제프 딘의 시계는 1970년 1월 1일부터 지난 시간을 초로 표시한다. 그는 절대 늦지 않는다.</li><li>신이 &quot;빛이 있으라!&quot;한 순간에, 제프 딘은 코드 리뷰를 위해 거기 있었다.</li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3fbb4e0e1cf5" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Context API가 Redux를 대체할 수 있을까요?]]></title>
            <link>https://medium.com/lunit-engineering/context-api%EA%B0%80-redux%EB%A5%BC-%EB%8C%80%EC%B2%B4%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C%EC%9A%94-76a6209b369b?source=rss-74dac2dd62dc------2</link>
            <guid isPermaLink="false">https://medium.com/p/76a6209b369b</guid>
            <category><![CDATA[front-end-development]]></category>
            <category><![CDATA[react]]></category>
            <category><![CDATA[korean]]></category>
            <category><![CDATA[javascript]]></category>
            <dc:creator><![CDATA[Sangyeop Bono Yu]]></dc:creator>
            <pubDate>Tue, 01 May 2018 07:00:26 GMT</pubDate>
            <atom:updated>2018-05-03T04:24:06.144Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/997/1*Rh3PjitrhtDNn4y_NFVo5w.png" /></figure><p>React 16.3 버전에서 정식으로 <a href="https://reactjs.org/docs/context.html">Context API</a>가 발표되었습니다. Props를 직접 전달하는 것과 달리, Context는 중간의 컴포넌트를 건너뛰고 원하는 컴포넌트로 바로 상태를 전달할 수 있어서 예전부터 React 라이브러리 개발자들 사이에서 요긴하게 쓰였습니다. 이제 새 API를 통해 앱 개발에서도 안심하고(그리고 편리하게) Context 기능을 사용할 수 있게 되었습니다.</p><p>새 API는 &lt;Provider /&gt;와 &lt;Consumer /&gt;를 통해 선언적으로 Context를 사용할 수 있도록 설계되어 있습니다. 전역 상태를 &lt;Provider /&gt;에 제공하면 트리 내의 어디에서나 &lt;Consumer /&gt;를 통해 가져올 수 있습니다. 공식 문서의 예제를 가져와 보겠습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e45883bf11bbce18db7c89e335969643/href">https://medium.com/media/e45883bf11bbce18db7c89e335969643/href</a></iframe><p>Redux에 익숙하신 분들이라면 &lt;ThemeContext.Provider /&gt;가 react-redux의 &lt;Provider /&gt;에, withTheme()가 connect()에 대응한다는 사실을 눈치채셨을 겁니다. 같은 코드를 Redux로 짜면 이렇게 됩니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/88649a2317c8bff4b019982d44175969/href">https://medium.com/media/88649a2317c8bff4b019982d44175969/href</a></iframe><p>이쯤 되면 ‘<em>Context API가 Redux를 대체할 수 있지 않을까?</em>&#39; 하는 의문을 품게 됩니다. Redux가 출시되었을 당시 <a href="https://deminoth.github.io/redux/">공식 문서를 번역</a>했을 정도로 Redux 팬인 저에게도 이런 질문을 하는 분들이 많았고요.</p><p>여기에 답하기 위해 먼저 답해야 하는 질문이 바로 &#39;왜 Redux를 쓰는가?&#39; 입니다. 2015년 당시에 제가 Redux를 썼던 이유는 &#39;<a href="https://facebook.github.io/flux/"><em>Flux 아키텍처</em></a><em>를 위한 가장 훌륭한 상태 관리 구현체가 Redux이기 때문에</em>&#39; 였습니다. Facebook에서 Flux 아키텍처와 함께 공개한 <a href="https://github.com/facebook/flux/blob/master/src/Dispatcher.js">dispatcher 구현체</a>를 직접 뜯어서 쓰던 저에게 Redux가 얼마나 예뻐보였을까요.</p><p>하지만 Redux는 단순히 전역 상태 관리를 위해서만 사용하기에는 너무 번잡한 도구입니다. 배우기가 까다로워서 React에 입문하는 동료들을 좌절시키기도 하고, 태생적인 제약조건들 때문에 앱을 짜면서도 번거로운 부분이 한둘이 아닙니다. 그럼에도 아래와 같은 장점들 때문에 Redux가 강력한 것이죠.</p><blockquote>로컬 스토리지에 상태를 영속적으로 저장하고 시작할 때 다시 불러오는 데 특히 뛰어납니다.<br>상태를 서버에서 미리 채워서 HTML에 담아 클라이언트로 보내고 앱을 시작할 때 다시 불러오는데 특히 뛰어납니다.<br>사용자의 액션을 직렬화해서 상태와 함께 자동으로 버그 리포트에 첨부할 수 있습니다. 개발자들은 이를 통해 에러를 재현할 수 있습니다.<br>액션 객체를 네트워크를 통해 보내면 코드를 크게 바꾸지 않고도 협업 환경을 구현할 수 있습니다.<br>실행취소 내역의 관리나 낙관적인 변경(optimistic mutations)을 코드를 크게 바꾸지 않고도 구현할 수 있습니다.<br>개발할 때 상태 내역 사이를 오가고 액션 내역에서 현재 상태를 다시 계산하는 일을 TDD 스타일로 할 수 있습니다.<br>개발자 도구에게 완전한 조사와 제어를 가능하게 해서 개발자들이 자신의 앱을 위한 도구를 직접 만들 수 있게 해 줍니다.<br>비즈니스 로직 대부분을 재사용하면서 UI를 변경할 수 있게 해 줍니다.</blockquote><blockquote>– <a href="https://medium.com/@Dev_Bono/당신에게-redux는-필요-없을지도-모릅니다-b88dcd175754">당신에게 Redux는 필요 없을지도 모릅니다.(번역)</a></blockquote><p>이러한 장점들을 활용할 필요가 없다면, 전역 상태를 관리하기 위해 Context API를 활용하는 방법을 추천합니다. 필요하다면 Redux의 장점을 일부 빌려올 수도 있습니다. 리듀서를 따로 분리해내서 순수함수의 장점을 활용할 수도 있고, <a href="https://deminoth.github.io/redux/recipes/reducers/UsingCombineReducers.html">combineReducers</a>와 유사하게 여러 Context를 동시에 사용할 수 있는 HOC를 만들어 쓰셔도 됩니다.</p><p>저도 이미 사내 프로젝트 하나를 Redux에서 Context API로 완전히 전환했습니다. 코드 면적이 많이 줄었고 동료들이 이해하기에도 더 쉬워졌습니다. 앞으로도 위에서 나열한 것과 같이 특별한 이유가 아니면 Redux를 다시 꺼내 들지는 않을 것 같습니다. 하지만 Redux가 쓸모없어졌다고 생각하지는 않습니다.</p><p>닭 잡는데 소 잡는 칼을 쓰지 않게 되었을 뿐입니다.</p><blockquote><a href="https://www.wanted.co.kr/wd/2119">루닛에서는 저희와 함께 큰 문제를 풀어나가실 FRONT-END ENGINEER 분들을 모십니다.</a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=76a6209b369b" width="1" height="1"><hr><p><a href="https://medium.com/lunit-engineering/context-api%EA%B0%80-redux%EB%A5%BC-%EB%8C%80%EC%B2%B4%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C%EC%9A%94-76a6209b369b">Context API가 Redux를 대체할 수 있을까요?</a> was originally published in <a href="https://medium.com/lunit-engineering">루닛 (Lunit) 개발팀</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google Fonts + 한국어 알아보기]]></title>
            <link>https://medium.com/lunit-engineering/google-fonts-%ED%95%9C%EA%B5%AD%EC%96%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-51bcce473434?source=rss-74dac2dd62dc------2</link>
            <guid isPermaLink="false">https://medium.com/p/51bcce473434</guid>
            <category><![CDATA[web-development]]></category>
            <category><![CDATA[web-design]]></category>
            <category><![CDATA[korean]]></category>
            <category><![CDATA[google-fonts]]></category>
            <dc:creator><![CDATA[Sangyeop Bono Yu]]></dc:creator>
            <pubDate>Thu, 05 Apr 2018 06:00:20 GMT</pubDate>
            <atom:updated>2018-05-03T04:25:18.172Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*mxV0NqqraVG_-RzVMeCx0A.png" /><figcaption><a href="https://googlefonts.github.io/korean/">https://googlefonts.github.io/korean/</a></figcaption></figure><p>Google Fonts에서 Early Access를 통해서만 일부 사용할 수 있었던 한글 폰트들이 드디어 정식으로 출시되었습니다. 사실 공식 출시(graduate)만 해 줘도 감지덕지라고 생각했는데 분할 다운로드와 다양한 폰트 추가 등의 멋진 선물들이 기다리고 있었네요.</p><h3>폰트 분할을 통한 최적화</h3><p>글리프가 많지 않은 영문 폰트와는 달리 유니코드에 포함된 한글 전부를 표현하려면 한글 폰트에는 11,172개의 글리프가 필요합니다. 이 때문에 폰트 파일의 용량이 매우 커질 수밖에 없고, 국내의 웹 개발자들은 웹 폰트 사용을 포기하거나 자주 사용하는 글자들만 포함하는 웹 폰트 파일을 만들어 사용하는 수밖에 없었습니다.</p><p>구글에서는 이 문제를 해결하기 위해 구글의 웹 문서 검색능력과 머신러닝을 이용해 글의 주제에 따라 함께 자주 쓰이는 글자들을 100여 개의 그룹으로 묶었습니다. 그런 다음 하나의 폰트를 그룹에 따라 여러 파일로 나누고, CSS3의 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/unicode-range">unicode-range</a> 속성을 이용해 화면에 표시되는 글자를 포함하는 파일만 내려받도록 만들었습니다. 각각의 파일은 woff2 형식으로 수십 kB에서 수백 byte 정도밖에 되지 않습니다. 구글의 CDN을 사용하기에 여러 사이트에서 사용할수록 사용자들이 체감하는 속도는 더욱 빨라질 것이고요.</p><h3>다양한 한글 폰트의 추가</h3><p>Early Access에서 제공하던 나눔 고딕, 나눔 고딕 코딩, 나눔 명조, 나눔 손글씨 붓, 나눔 손글씨 펜의 5가지 폰트를 포함하여, 12개 제작사의 23가지 폰트가 추가되었습니다. 모든 폰트는 오픈 폰트 라이센스(OFL)을 따르므로 다양한 용도로 걱정 없이 이용할 수 있습니다. Noto Sans CJK가 포함되지 않은 점은 조금 아쉽습니다.</p><p><a href="https://googlefonts.github.io/korean/">소개 페이지</a>에 따르면 이번 폰트 제공은 시범적이라고 하니 앞으로도 더 많은 폰트 추가와 최적화된 분할을 기대할 수 있지 않을까 생각합니다. 이번 Google Fonts + 한국어를 통해 더 아름다운 타이포그래피가 적용된 한국어 페이지를 많이 볼 수 있게 되었으면 좋겠습니다.</p><blockquote><a href="https://www.wanted.co.kr/wd/2119">루닛에서는 저희와 함께 큰 문제를 풀어나가실 FRONT-END ENGINEER 분들을 모십니다.</a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=51bcce473434" width="1" height="1"><hr><p><a href="https://medium.com/lunit-engineering/google-fonts-%ED%95%9C%EA%B5%AD%EC%96%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-51bcce473434">Google Fonts + 한국어 알아보기</a> was originally published in <a href="https://medium.com/lunit-engineering">루닛 (Lunit) 개발팀</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[두 번이나 나오는 표현인데 중대한 오역을 했군요! 감사합니다.]]></title>
            <link>https://medium.com/@Dev_Bono/%EB%91%90-%EB%B2%88%EC%9D%B4%EB%82%98-%EB%82%98%EC%98%A4%EB%8A%94-%ED%91%9C%ED%98%84%EC%9D%B8%EB%8D%B0-%EC%A4%91%EB%8C%80%ED%95%9C-%EC%98%A4%EC%97%AD%EC%9D%84-%ED%96%88%EA%B5%B0%EC%9A%94-%EA%B0%90%EC%82%AC%ED%95%A9%EB%8B%88%EB%8B%A4-a75a1d24b040?source=rss-74dac2dd62dc------2</link>
            <guid isPermaLink="false">https://medium.com/p/a75a1d24b040</guid>
            <dc:creator><![CDATA[Sangyeop Bono Yu]]></dc:creator>
            <pubDate>Sat, 11 Nov 2017 23:11:23 GMT</pubDate>
            <atom:updated>2017-11-11T23:11:23.207Z</atom:updated>
            <content:encoded><![CDATA[<p>두 번이나 나오는 표현인데 중대한 오역을 했군요! 감사합니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a75a1d24b040" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Korean version is here!]]></title>
            <link>https://medium.com/@Dev_Bono/korean-version-is-here-d22add4a86bd?source=rss-74dac2dd62dc------2</link>
            <guid isPermaLink="false">https://medium.com/p/d22add4a86bd</guid>
            <dc:creator><![CDATA[Sangyeop Bono Yu]]></dc:creator>
            <pubDate>Sat, 11 Nov 2017 11:47:24 GMT</pubDate>
            <atom:updated>2017-11-11T11:47:24.739Z</atom:updated>
            <content:encoded><![CDATA[<p><a href="https://medium.com/@Dev_Bono/redux%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%98%EB%8B%A4%EB%8A%94-%EA%B2%83%EC%9D%84-%EC%96%B8%EC%A0%9C-%EC%95%8C-%EC%88%98-%EC%9E%88%EB%82%98%EC%9A%94-426a148da64d">Redux가 필요하다는 것을 언제 알 수 있나요?</a></p><p>Korean version is here!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d22add4a86bd" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Redux가 필요하다는 것을 언제 알 수 있나요?]]></title>
            <link>https://medium.com/lunit-engineering/redux%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%98%EB%8B%A4%EB%8A%94-%EA%B2%83%EC%9D%84-%EC%96%B8%EC%A0%9C-%EC%95%8C-%EC%88%98-%EC%9E%88%EB%82%98%EC%9A%94-426a148da64d?source=rss-74dac2dd62dc------2</link>
            <guid isPermaLink="false">https://medium.com/p/426a148da64d</guid>
            <category><![CDATA[redux]]></category>
            <category><![CDATA[react]]></category>
            <category><![CDATA[javascript]]></category>
            <dc:creator><![CDATA[Sangyeop Bono Yu]]></dc:creator>
            <pubDate>Sat, 11 Nov 2017 11:41:06 GMT</pubDate>
            <atom:updated>2018-05-03T04:25:35.231Z</atom:updated>
            <content:encoded><![CDATA[<blockquote>이 글은 <a href="https://medium.com/dailyjs/when-do-i-know-im-ready-for-redux-f34da253c85f">Simon Schwartz의 &quot;When do I know I’m ready for Redux?&quot;</a>를 번역한 글입니다.</blockquote><p>이 포스팅은 당신이 Redux 사용을 고려해야 하는 시점이 언제인지, Redux가 해결해준 우리의 문제가 무엇인지, 우리가 찾아낸 이점들은 무엇인지에 대한 것입니다. 이 글은 우리가 <a href="https://reactjs.org/">React</a> 앱을 키워나가면서 배운 것들을 기반으로 쓰였습니다.</p><p>만약 당신이 상태가 무엇인지 모르거나, Redux에 대해 들어본 적이 없다면 앞으로의 내용이 별로 와닿지 않을 것입니다. 이러한 개념들에 대해 생소한 분들을 위해 간단한 개요가 아래에 있습니다. 생소하지 않다면 본문으로 넘어가시면 됩니다.</p><h4>상태란 무엇인가요?</h4><p>상태는 단지 데이터입니다. 현재 사용자의 이름이나, 로그인 여부나, 페이지가 로딩 중인지에 대한 것들과 같은 애플리케이션 데이터의 집합이라고 생각하세요. 앱의 상태는 사용자의 동작이나 API 응답 등에 의해 바뀔 수 있습니다. 앱은 어떤 UI를 보여주어야 할지 결정하기 위해 상태를 읽어오게 됩니다.</p><h4>Redux는 무엇인가요?</h4><p><a href="http://redux.js.org/">Redux</a>는 앱의 상태를 관리하기 위한 도구입니다. React 앱에서는 매우 일반적으로 쓰입니다.</p><h3>우리가 Redux를 사용하기로 한 이유</h3><blockquote>섣부른 최적화는 만악의 근원이다 — 도널드 커누스</blockquote><p>이것이 제가 소프트웨어를 만들 때면 따르는 격언입니다. 우리가 <a href="https://developers.digital.abc.net.au/">Australian Broadcasting Corporation</a>을 위한 React 앱을 만들기 시작하면서 우리 앱의 상태를 지역 컴포넌트 상태를 이용해 관리하기로 한 이유죠.</p><p>처음 몇 주 동안은 이게 잘 통했지만 앱에 기능을 추가할수록 상태 관리에 문제가 생겼습니다.</p><p>우리 앱에서 상태의 변화를 추적하기가 정말 힘들어졌습니다. 우리 앱의 상태를 변경하는 함수는 여러 React 컴포넌트들에 흩어져 있었습니다. 몇몇 컴포넌트들은 상태를 관리하는 함수들 때문에 너무 비대해졌습니다. 모든 것이 지저분해졌고 코드 베이스가 점점 커다란 그릇에 담긴 스파게티처럼 보이기 시작했습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/245/1*G9_PmZtV4uqno0GaitNHMQ.gif" /></figure><p>그러면 앱이 커지면서 제가 겪은 것들을 차례차례 보여드리겠습니다.</p><h4>1일 차</h4><p>우리는 React의 지역 컴포넌트 상태에서 시작했습니다.</p><p>React는 &#39;<a href="https://reactjs.org/docs/state-and-lifecycle.html#the-data-flows-down">일방향 데이터 흐름</a>&#39;을 가집니다. 컴포넌트가 상태를 props로 내려보내 준다는 뜻입니다.</p><p>우리는 최상위 컴포넌트에 상태를 설정하고 props로 데이터를 내려주었습니다. 쉽죠.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/550/1*cz7sgeny9IGyKLjjj2d0cA.gif" /></figure><h4>5일 차</h4><p>우리는 기능들을 좀 더 추가했습니다. 불행하게도 몇몇 컴포넌트들이 상태를 공유해야 했지만 부모-자식 관계는 아니었습니다.</p><p>다행히도 우리는 <a href="https://reactjs.org/docs/lifting-state-up.html">상태를 끌어올리는(Lifting)</a> 것으로 이를 해결했습니다. 상태(와 이를 변경하는 함수들)를 가장 가까운 조상(컨테이너 컴포넌트)까지 끌어올렸다는 뜻이죠. 우리는 함수들을 컨테이너 컴포넌트에 바인드한 다음 이들을 props로 내려보냈습니다. 자식 컴포넌트들은 부모 컴포넌트의 상태 변경을 일으킬 수 있고 트리 내의 다른 모든 컴포넌트가 업데이트될 겁니다. 좋아요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/550/1*jLx_QbELsRrTFG94mDmmxw.gif" /></figure><h4>20일 차</h4><p>우리는 몇 가지 기능을 더 추가했고 앱의 상태 흐름은 이렇게 보이기 시작했습니다...</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/550/1*PBgAz9U9SrkINPo-n5glgw.gif" /></figure><p>당신도 볼 수 있듯이 상태가 업데이트 되고 앱 전체로 퍼뜨려지는 방식이 점점 복잡해지기 시작했습니다. 우리가 앱을 키우면서 고통스러웠던 부분들은 아래와 같습니다:</p><ul><li>컴포넌트의 구조는 앱의 UI를 따릅니다. 앱의 상태는 UI를 따를 필요가 없습니다.</li><li>앱 상태의 형태가 여러 컴포넌트에 걸쳐 퍼져있습니다.</li><li>상태를 바꾸는 함수가 여러 컴포넌트에 걸쳐 퍼져있습니다.</li><li>앱 상태의 개요를 파악하기 위해서는 마음속에 앱 구조에 대해 모델을 가지고 있어야 합니다.</li><li>여러 단계의 컴포넌트에 걸쳐 같은 props를 전달해야 합니다.</li><li>디버깅할 때 상태 변경을 추적하기가 점차 힘들어졌습니다.</li></ul><p>당신이 위의 문제들에 맞닥뜨린다면, Redux를 사용할 때가 된 것입니다.</p><h3>Redux는 어떻게 작동하나요?</h3><p>모든 React 앱이 Redux를 사용할 필요는 없다고 먼저 말해두겠습니다. 사실 정말 간단한 React 앱은 Redux에서 얻을 수 있는 이득이 전혀 없습니다.</p><p>Redux에 관한 가장 일반적인 불평들은 장황하고 익히는데 시간이 걸린다는 점입니다. Redux는 개발자가 앱의 상태를 어떻게 업데이트할지 액션과 리듀서를 통해 명시적으로 서술하도록 요구합니다. 이를 통해 앱의 상태를 단일한 지역 컴포넌트 상태 대신 하나의 전역 스토어로 관리하게 해줍니다.</p><p>아래는 Redux의 구조에 대한 개요입니다.</p><h4>액션</h4><p>액션은 이벤트에 대한 정보에 불과합니다. Redux로 상태를 업데이트하고 싶으면 반드시 액션을 보내는 것으로 시작해야 합니다. 액션은 반드시 액션의 이름(타입)을 포함해야 하고 함께 보내고 싶은 정보를 포함할 수 있습니다. 액션이 타입을 가져야만 리듀서가 구분할 수 있습니다. 간단히 말해, 액션은 상태 변경을 일으키는 이벤트에 대한 정적인 정보입니다.</p><h4>리듀서</h4><p>보내진 액션은 리듀서로 전달됩니다. 리듀서는 각 액션이 스토어를 어떻게 업데이트하는지 기술하는 순수 함수입니다. 순수 함수는 같은 입력에 대해 항상 같은 출력을 반환하는 함수입니다. 리듀서는 언제나 새 앱 상태를 반환한다는 점도 중요합니다. 결코 스토어를 변형(mutate)하지 않습니다.</p><h4>스토어</h4><p>스토어는 객체로 저장되는 앱의 상태입니다. React 컴포넌트는 스토어를 구독해서 스토어가 업데이트될 때마다 컴포넌트를 업데이트할 수 있습니다.</p><p>이제 어떻게 생겼는지 보여드리겠습니다. Redux를 사용했을 때의 도식을 추가했습니다.</p><p>기억하세요: Redux에서 액션을 보내면, 리듀서 함수를 작동시켜서, 스토어를 업데이트합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/700/1*T_Q66EkNEhca6TyrvY1xBQ.gif" /></figure><h3>우리가 배운 것</h3><p>우리가 Redux로 업데이트하고 나서 다음과 같은 이점들을 발견했습니다:</p><h4>단순해진 React 컴포넌트들</h4><ul><li>React 컴포넌트 구조를 평평하게 할 수 있었고 몇몇 컨테이너 컴포넌트들은 제거할 수 있었습니다. 데이터를 아래로 전달하기 위해 컴포넌트의 계층구조를 만들 필요가 없어졌기 때문입니다.</li><li>몇몇 클래스 컴포넌트들을 함수형 컴포넌트로 변경할 수 있었습니다.</li></ul><h4>관심사의 분리</h4><ul><li>앱에서 액션과 리듀서 함수들을 모은 분리된 부분을 가짐으로써 신규 개발자들이 앱의 비즈니스 로직에 대한 개요를 한 곳에서 쉽게 볼 수 있게 되었습니다.</li><li>React 컴포넌트들이 상태와 상태를 업데이트하는 함수들 때문에 비대해지는 일이 줄어들었습니다. 컴포넌트가 사용자 인터페이스를 관리하는데 집중할 수 있고 가독성이 더 좋아졌다는 뜻이죠.</li></ul><h4>품질</h4><ul><li><a href="https://github.com/evgenyrodionov/redux-logger">Redux logger</a>를 통해 앱의 상태를 디버깅하는 것이 매우 쉬워졌습니다.</li><li>Redux는 <a href="https://deminoth.github.io/redux/recipes/WritingTests.html">유닛 테스트를 작성하기가</a> 정말 쉽습니다.</li></ul><h3>마무리</h3><blockquote>섣부른 최적화는 만악의 근원이다 — 도널드 커누스</blockquote><p>아직도 저는 이 격언이 진실이라고 생각하지만, 대부분의 React 앱에서 Redux를 일찍부터 도입하는 것은 올바른 접근이라고 믿습니다. 우리의 경험에서 핵심은 지역 상태를 사용하는 것이 꽤나 빠르게 성가신 일이 된다는데에 있었습니다.</p><p>당신의 앱이 아래 기준 중 몇몇과 일치한다면, 저는 Redux를 즉시 도입하는 것이 최고의 접근법이라고 봅니다.</p><ul><li>UI가 앱의 상태에 따라 크게 바뀐다.</li><li>상태가 항상 선형으로, 일방향으로 흐르지는 않는다.</li><li>일반적으로 사용자가 앱을 사용하면서 여러 상태 업데이트와 연관된다.</li><li>관련 없는 여러 컴포넌트가 같은 방식으로 상태를 업데이트한다.</li><li>상태 트리가 단순하지 않다.</li><li>상태가 여러 다른 방식으로 업데이트된다.</li><li>사용자 액션을 되돌릴 필요가 있다.</li></ul><p>우리 앱에서 어떤 컴포넌트에서는 지역 상태만 한 것이 없었습니다. 예를 들어 우리는 폼 화면 컴포넌트를 몇 개 가지고 있었는데 폼 유효성 검증은 지역 상태를 이용하는 것이 가장 좋았습니다. 우리가 폼 화면에서 지역 상태를 그대로 둔 이유는 아래와 같습니다.</p><ul><li>컴포넌트가 마운트 해제된 후에는 폼 상태를 유지하고 싶지 않았습니다.</li><li>폼 유효성 상태는 컴포넌트 밖에서 공유되지 않습니다.</li></ul><h4>바로 시작하려면?</h4><p>제가 Redux를 배울 때 사용했던 리소스들입니다.</p><ul><li><a href="https://egghead.io/courses/getting-started-with-redux">egghead.io의 Getting started with Redux</a></li><li><a href="https://deminoth.github.io/redux/">Redux 문서</a></li><li><a href="https://css-tricks.com/learning-react-redux/">Levelling up with React: Redux from CSS Tricks</a></li></ul><p>읽어주셔서 감사합니다!</p><blockquote><a href="https://www.wanted.co.kr/wd/2119">루닛에서는 저희와 함께 큰 문제를 풀어나가실 FRONT-END ENGINEER 분들을 모십니다.</a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=426a148da64d" width="1" height="1"><hr><p><a href="https://medium.com/lunit-engineering/redux%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%98%EB%8B%A4%EB%8A%94-%EA%B2%83%EC%9D%84-%EC%96%B8%EC%A0%9C-%EC%95%8C-%EC%88%98-%EC%9E%88%EB%82%98%EC%9A%94-426a148da64d">Redux가 필요하다는 것을 언제 알 수 있나요?</a> was originally published in <a href="https://medium.com/lunit-engineering">루닛 (Lunit) 개발팀</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Great post. Would you mind if I translate your post into Korean?]]></title>
            <link>https://medium.com/@Dev_Bono/great-post-would-you-mind-if-i-translate-your-post-into-korean-ced97e53c2b4?source=rss-74dac2dd62dc------2</link>
            <guid isPermaLink="false">https://medium.com/p/ced97e53c2b4</guid>
            <dc:creator><![CDATA[Sangyeop Bono Yu]]></dc:creator>
            <pubDate>Mon, 30 Oct 2017 07:57:05 GMT</pubDate>
            <atom:updated>2017-10-30T07:57:05.009Z</atom:updated>
            <content:encoded><![CDATA[<p>Great post. Would you mind if I translate your post into Korean?</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ced97e53c2b4" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>