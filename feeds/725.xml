<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>eungjun</title>
	<atom:link href="https://blog.npcode.com/feed/" rel="self" type="application/rss+xml" />
	<link>https://blog.npcode.com</link>
	<description></description>
	<lastBuildDate>
	Wed, 20 Mar 2019 19:47:25 +0000	</lastBuildDate>
	<language>ko-KR</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='blog.npcode.com' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://s0.wp.com/i/buttonw-com.png</url>
		<title>eungjun</title>
		<link>https://blog.npcode.com</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://blog.npcode.com/osd.xml" title="eungjun" />
	<atom:link rel='hub' href='https://blog.npcode.com/?pushpress=hub'/>
	<item>
		<title>REST의 representation이란 무엇인가</title>
		<link>https://blog.npcode.com/2017/04/03/rest%ec%9d%98-representation%ec%9d%b4%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80/</link>
				<comments>https://blog.npcode.com/2017/04/03/rest%ec%9d%98-representation%ec%9d%b4%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80/#comments</comments>
				<pubDate>Sun, 02 Apr 2017 18:00:24 +0000</pubDate>
		<dc:creator><![CDATA[Yi EungJun]]></dc:creator>
				<category><![CDATA[HTTP]]></category>
		<category><![CDATA[REST]]></category>

		<guid isPermaLink="false">http://blog.npcode.com/?p=923</guid>
				<description><![CDATA[사실 서버가 보내준 것은 리소스가 아니다. 다음과 같은 HTTP GET 요청을 서버에 보내서 GET https://example.org/greeting Host: example.org Accept: text/plain, text/html; q=0.9 *; q=0.1 Accept-Language: en, ko; q=0.9, *; q=0.1 &#8220;hello&#8221;라는 메시지를 응답으로 받았다고 해 보자. HTTP/1.1 200 OK Content-Length: 6 Date: Sun, 19 Mar 2017 10:20:47 GMT Last-Modified: Sun, 19 Mar 2017 08:00:00 GMT Content-Type: text/plain Content-Language: &#8230; <a href="https://blog.npcode.com/2017/04/03/rest%ec%9d%98-representation%ec%9d%b4%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80/" class="more-link"><span class="screen-reader-text">REST의 representation이란 무엇인가</span> 계속 읽기</a>]]></description>
								<content:encoded><![CDATA[<h3>사실 서버가 보내준 것은 리소스가 아니다.</h3>
<p>다음과 같은 HTTP GET 요청을 서버에 보내서</p>
<pre>GET https://example.org/greeting
Host: example.org
Accept: text/plain, text/html; q=0.9 *; q=0.1
Accept-Language: en, ko; q=0.9, *; q=0.1

</pre>
<p>&#8220;hello&#8221;라는 메시지를 응답으로 받았다고 해 보자.</p>
<pre>HTTP/1.1 200 OK
Content-Length: 6
Date: Sun, 19 Mar 2017 10:20:47 GMT
Last-Modified: Sun, 19 Mar 2017 08:00:00 GMT
Content-Type: text/plain
Content-Language: en

hello</pre>
<p>이러한 상황을, <a href="https://example.org/greeting" rel="nofollow">https://example.org/greeting</a> 라는 uri를 요청해서 &#8220;hello&#8221;라는 리소스를 응답으로 받았다고 표현하는 경우를 흔히 보았을 것이다. 그런데 그건 엄밀히 말해 약간 틀린 표현이다. 왜냐하면 &#8220;hello&#8221;는 리소스가 아니라 representation data이기 때문이다.</p>
<h3>HTTP에서의 representation</h3>
<p>GET 메서드의 정의는 다음과 같다.</p>
<pre>The GET method requests transfer of a current selected representation
for the target resource.</pre>
<p>즉, target resource에 대한 현재의 선택된 representation 하나를 반환한다.</p>
<p>위 정의에서 &#8220;target resource&#8221;란 <a href="https://example.org/greeting" rel="nofollow">https://example.org/greeting</a> 라는 uri가 가리키는 리소스이다. 그렇다면 리소스란 무엇인가? HTTP 요청의 대상이다. HTTP는 리소스의 개념을 제한하지 않으며 무엇이든 될 수 있다. 여기서는 &#8220;hello&#8221; 라는 텍스트 자체가 리소스가 아니라, &#8220;환영의 의미를 담은 문서&#8221;가 리소스가 된다고 볼 수 있을 것이다.</p>
<p>그럼 &#8220;현재의 선택된 representation&#8221;이란 무엇인가? 단어 하나 하나를 차근차근 따져보도록 하자.</p>
<p>일단 &#8220;representation&#8221;은 무엇인가? 어떤 리소스의 특정 시점의 상태를 반영하고 있는 정보이다. 하나의 representation은 representation data와 representation metadata로 구성된다. 위의 예에서는 &#8220;hello&#8221;가 representation data이고, &#8220;Content-Type: text/plain&#8221;과 &#8220;Content-Language: en&#8221;이 representation metadata이다. (<a href="https://tools.ietf.org/html/rfc7231#section-3.1">HTTP 헤더들 중 representation metadata에 해당하는 것이 있고 그렇지 않은 것이 있다.</a>)</p>
<p>&#8220;현재&#8221;란 무엇인가? 이것은 말 그대로 해석하면 될 것이다. 만약 <a href="https://example.org/greeting" rel="nofollow">https://example.org/greeting</a> 가 가리키는 리소스의 representation이 &#8220;hi&#8221;에서 &#8220;hello&#8221;로 수정되었다면 &#8220;현재&#8221; representation은 &#8220;hi&#8221;가 아닌 &#8220;hello&#8221;가 될 것이다.</p>
<p>&#8220;선택된&#8221;이라고 함은 무슨 뜻인가? 이는 하나의 리소스의 현재 representation이 하나 이상이 될 수 있으며, 그 중 하나가 선택되었음을 의미한다. 즉 &#8220;greeting&#8221; 리소스의 현재 representation은, 영어 사용자를 위한 &#8220;hello&#8221;, 한국어 사용자를 위한 &#8220;안녕하세요&#8221;, HTML 문서를 원하는 클라이언트를 위한 &#8220;&lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;&#8221;등 여러가지가 될 수 있는데, 이들 중 하나가 선택되었다는 의미이다. metadata를 포함하여 representation들의 예를 들어보자.</p>
<p>영어 사용자를 위한 representation:</p>
<pre>Content-Type: text/plain
Content-Language: en

hello</pre>
<p>한국어 사용자를 위한 representation:</p>
<pre>Content-Type: text/plain
Content-Language: ko

안녕하세요</pre>
<p>HTML을 선호하는 영어 사용자를 위한 representation:</p>
<pre>Content-Type: text/html; charset=UTF-8
Content-Language: en

&lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;</pre>
<p>HTML을 선호하는 한국어 사용자를 위한 representation:</p>
<pre>Content-Type: text/html; charset=UTF-8
Content-Language: ko

&lt;html&gt;&lt;body&gt;안녕하세요&lt;/body&gt;&lt;/html&gt;</pre>
<p>그렇다면 이들 중 하나를 &#8220;선택&#8221;하는 것은 누가 어떻게 하는가? 클라이언트와 서버간의 내용 협상(Content negotiation)을 통해 선택하며, 선택의 주체는 협상 방법에 따라 다르다. 사전 협상(proactive negotiation)의 경우 서버가 선택한다. 클라이언트가 GET 요청에 &#8220;Accept-Language: ko&#8221; 헤더를 포함시켜 한국어를 선호함을 밝혔다면, 서버는 가장 적절한 representation인 &#8220;안녕하세요&#8221;로 응답할 것이며, 만약 여기에 &#8220;Accept: text/html; charset=UTF-8&#8221; 헤더도 포함시켜서 한국어로 되어있고 UTF-8로 인코딩된 HTML 문서를 선호한다고 밝혔다면 &#8220;&lt;html&gt;&lt;body&gt;안녕하세요&lt;/body&gt;&lt;/html&gt;&#8221; representation을 선택하여 응답할 것이다. 만약 적절한 representation이 존재하지 않는다면 406 Not Acceptable로 응답할 것이다.</p>
<p>이러한 선택을 &#8220;여러 리소스 중 하나가 선택되었다&#8221;라고 말할 수 없는 이유는 무엇인가? &#8220;안녕하세요&#8221;든 &#8220;hello&#8221;든 모두 uri가 동일하기 때문이다. uri가 동일하다면 같은 리소스이다. 따라서 여러 리소스 중 하나가 선택된 것이 아니다.</p>
<p>주의: 서버가 uri의 목록으로 된 선택지를 주면 클라이언트가 선택하는 사후 협상(reactive negotiation)도 있는데, 이 경우는 선택지마다 uri가 각각 다를 것이므로, 클라이언트가 리소스들 중 하나를 선택한다고 표현해도 무방할지도 모른다. 자세한 것은 HTTP 명세를 참고하라.</p>
<h3>REST에서의 representation</h3>
<p>이처럼 HTTP 명세는 representation이라는 개념을 도입하고 있다. 그리고 이 <a href="https://tools.ietf.org/html/rfc7231#section-3">representation은 바로 REST에서 온 것이다.</a></p>
<p>REST는 REpresentational State Transfer의 줄임말이다. &#8220;State&#8221;는 웹 애플리케이션 의 상태를 의미하며, &#8220;Transfer&#8221;는 이 상태의 전송을 의미한다.</p>
<p>웹 브라우저로 웹 사이트를 이용하는 예를 들어보자. 웹 페이지 A를 보고 있던 사용자가 웹 페이지 B로 가는 링크를 클릭하면, 웹 브라우저는 링크가 가리키는 웹 페이지 B를 렌더링해서 보여줄 것이다.</p>
<p>위의 상황에서 웹 애플리케이션은 무엇인가? 웹 브라우저와 웹 서버가 연결되어 사용자에게 가치를 제공하는 애플리케이션이다. 웹 서버가 웹 애플리케이션인 것이 아니라, 웹 브라우저가 웹 서버에 접속해야 웹 애플리케이션이다. 두 명의 사용자가 각각 자신의 웹 브라우저로 같은 웹 서버에 접속한다면, 두 개의 웹 애플리케이션이 실행되고 있는 것이다.</p>
<p>링크를 클릭함으로써 브라우저가 보여주던 페이지는 A에서 B로 바뀌었다. 즉, 웹 애플리케이션의 상태가 변경된 것이다. 또한 이 상태의 변경은 representation의 전송(Transfer)을 통해 이루어졌다. 그렇기 때문에 이것이 REpresentational State Transfer인 것이다.</p>
<p>여기서 두 가지 주의할 점이 있다.</p>
<p>1. Transfer는 상태의 전이(transit)을 의미하는 것이 아니다. 사용자가 링크를 클릭함으로써 웹 애플리케이션의 상태가 전이된 것은 사실이지만, Transfer가 의미하는 것은 그 전이가 아니라 network component 사이에서의 전송을 말한다. 즉 이 예에서는 서버에서 클라이언트로의 웹 페이지 전송을 의미하는 것이다.</p>
<p>2. 리소스의 상태와 애플리케이션의 상태는, 둘 다 동일하게 &#8220;state&#8221;라는 단어로 표현되고 있긴 하지만, 본질적으로 완전히 다른 것이다. 앞서 representation이란 &#8220;어떤 리소스의 특정 시점의 상태(state)를 반영하고 있는 정보&#8221;라고 말했다. 그것은 리소스의 상태지 애플리케이션의 상태는 아니다. 애플리케이션의 상태란, 웹 애플리케이션이 웹 페이지 A를 렌더링하다가 B를 렌더링하는 것으로 바뀐 그 상태를 말하는 것이다.</p>
<h3>모든 payload는 representation</h3>
<p><a href="https://lists.w3.org/Archives/Public/ietf-http-wg/2017JanMar/0523.html">HTTP 메시지의 payload로 전달되는 모든 것은 하나의 representation이거나 적어도 그의 일부이다.</a> PUT 메서드를 이용해 &#8220;welcome&#8221; 이란 텍스트를 전송해서, greeting 리소스의 representation을 업데이트하는 경우, 클라이언트가 서버로 전송한 &#8220;welcome&#8221;은 representation이다. 업데이트가 성공하여 서버가 &#8220;성공적으로 업데이트되었습니다&#8221;라는 메시지를 응답의 payload로 돌려보냈다면 이 메시지 역시 representation이다. &#8220;권한이 없습니다&#8221;라는 에러 메시지로 응답했다면 그 메시지도 역시 representation이다.</p>
<p>그렇다. 성공시나 에러시의 메시지도 역시 representation이다. 그런데 앞에서 분명 representation은 어떤 &#8220;리소스&#8221;에 대한 상태를 담은 정보라고 했다. 그렇다면 도대체 &#8220;성공적으로 업데이트되었습니다&#8221;는 어떤 리소스에 대한 것인가? greeting 리소스의 representation은 &#8220;welcome&#8221;으로 업데이트되었으니 분명 그것은 아닐 것인데 대체 무엇일까?</p>
<p>이론적으로 정확한 정답은 &#8220;Content-Location 헤더에 들어있는 uri가 가리키는 리소스&#8221;이다. 그러나 보통 Content-Location 헤더는 비어 있을 것이므로 현실적인 정답은 &#8220;uri를 모르는 어떤 리소스&#8221;이다. 그 메시지는 representation이 맞고, 어떤 존재하는 리소스에 대한 것이지만, 그 리소스를 가리키는 uri가 뭔지는 모른다. 이와 같은 representation을 unidentified representation이라고 하며, 어떤 payload가 unidentified representation인지 판단하는 방법은 RFC 7231의 &#8220;3.1.4.1. Identifying a Representation&#8221; 에 자세히 나와있다.</p>
<h3>나는 왜 representation을 몰랐을까</h3>
<p>HTTP를 이용해서 오래 개발을 해 온 개발자라도 representation에 대해 잘 몰랐을 수 있다(일단 나는 몰랐다). 그것은 당연한 일이다. 왜냐하면 2014년에 HTTP/1.1이 개정되기 전 까지는 representation의 개념이 명세에 명확하게 드러나 있지 않았기 때문이다. 예를 들어 1999년부터 15년간 HTTP/1.1 명세였던 RFC 2616의 GET 메서드 정의는 다음과 같다.</p>
<blockquote><p>The GET method means retrieve whatever information (in the form of an<br />
entity) is identified by the Request-URI.</p></blockquote>
<p>이처럼 representation에 대한 명시적인 언급이 없었다.</p>
<p>하지만 이제 HTTP를 사용하는 개발자들은 representation에 대해 알아야 할 것이다. 그 첫 번째 이유는 오늘날의 HTTP 명세에서 수도 없이 등장하는 개념이기 때문에 이를 모른다면 명세를 올바르게 해석할 수 없기 때문이며, 두 번째 이유는 representation을 이해하지 않고서는 REST에 대해 진지하게 이야기하기가 매우 어렵기 때문이다.</p>
]]></content:encoded>
							<wfw:commentRss>https://blog.npcode.com/2017/04/03/rest%ec%9d%98-representation%ec%9d%b4%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80/feed/</wfw:commentRss>
		<slash:comments>6</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/065bcc1fd59a5b1bcc8753b1c8cc1276?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">yieungjun</media:title>
		</media:content>
	</item>
		<item>
		<title>바쁜 개발자들을 위한 REST 논문 요약</title>
		<link>https://blog.npcode.com/2017/03/02/%eb%b0%94%ec%81%9c-%ea%b0%9c%eb%b0%9c%ec%9e%90%eb%93%a4%ec%9d%84-%ec%9c%84%ed%95%9c-rest-%eb%85%bc%eb%ac%b8-%ec%9a%94%ec%95%bd/</link>
				<comments>https://blog.npcode.com/2017/03/02/%eb%b0%94%ec%81%9c-%ea%b0%9c%eb%b0%9c%ec%9e%90%eb%93%a4%ec%9d%84-%ec%9c%84%ed%95%9c-rest-%eb%85%bc%eb%ac%b8-%ec%9a%94%ec%95%bd/#respond</comments>
				<pubDate>Wed, 01 Mar 2017 15:39:22 +0000</pubDate>
		<dc:creator><![CDATA[Yi EungJun]]></dc:creator>
				<category><![CDATA[HTTP]]></category>

		<guid isPermaLink="false">http://blog.npcode.com/?p=903</guid>
				<description><![CDATA[REST란 무엇인가? REST는 Representational State Transfer의 줄임말로, 웹을 위한 네트워크 기반 아키텍처 스타일이다. REST는 Roy T. Fielding이 그의 박사학위 논문 &#8220;Architectural Styles and the Design of Network-based Software Architectures&#8221; 에서 처음 소개하였다. 그의 논문을 읽고 매우 간략히 요약해보았다. 논문의 모든 부분을 동등하게 요약하지는 않았고, REST가 무엇인가를 이해하는데 초점을 맞추어 차별적으로 요약하였다. 논문 요약 1장: Software &#8230; <a href="https://blog.npcode.com/2017/03/02/%eb%b0%94%ec%81%9c-%ea%b0%9c%eb%b0%9c%ec%9e%90%eb%93%a4%ec%9d%84-%ec%9c%84%ed%95%9c-rest-%eb%85%bc%eb%ac%b8-%ec%9a%94%ec%95%bd/" class="more-link"><span class="screen-reader-text">바쁜 개발자들을 위한 REST 논문&#160;요약</span> 계속 읽기</a>]]></description>
								<content:encoded><![CDATA[<p>REST란 무엇인가? REST는 Representational State Transfer의 줄임말로, 웹을 위한 네트워크 기반 아키텍처 스타일이다. REST는 Roy T. Fielding이 그의 박사학위 논문 &#8220;<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">Architectural Styles and the Design of Network-based Software Architectures</a>&#8221; 에서 처음 소개하였다.</p>
<p>그의 논문을 읽고 매우 간략히 요약해보았다. 논문의 모든 부분을 동등하게 요약하지는 않았고, REST가 무엇인가를 이해하는데 초점을 맞추어 차별적으로 요약하였다.</p>
<h2>논문 요약</h2>
<h3>1장: Software Architecture</h3>
<p>아키텍처 스타일(architectural style)이란, 그 스타일을 따르는 아키텍처가 지켜야 하는 제약조건들의 집합이다.</p>
<h3>2장: Network-based Application Architectures</h3>
<p>이 논문에서 다루는 아키텍처 스타일의 적용 범위는 네트워크 기반 애플리케이션(Network-based Application)으로 한정된다.</p>
<p>네트워크 기반 소프트웨어는 operation이 네트워크를 경유해서 일어난다는 사실을 사용자에게 감출 필요가 없다. 분산(distributed) 소프트웨어는 감추어야한다.</p>
<p>애플리케이션이기 때문에, OS나 네트워킹 소프트웨어 같은 것은 고려 대상에서 제외된다.</p>
<p>네트워크 기반 애플리케이션 아키텍처의 관심 사항은 다음과 같다.</p>
<ul>
<li>성능</li>
<li>규모확장성(Scalability)</li>
<li>단순성</li>
<li>수정용이성(Modifiability)</li>
<li>가시성(Visibility)</li>
<li>이식성(Portability)</li>
<li>신뢰성(Reliability)</li>
</ul>
<h3>3장: Network-based Architectural Styles</h3>
<p>이 장에서는 Pipe and Filter, Layered-Client-Cache-Stateless-Server, Code on Demand 를 비롯한 여러가지 네트워크 기반 아키텍처 스타일들을 소개한다.</p>
<h3>4장: Designing the Web Architecture: Problems and Insights</h3>
<p>이 장에서는 웹 아키텍처의 요구사항, 해결해야할 문제를 설명하고 이를 해결하기 위한 접근 방법을 제시한다.</p>
<h3>5장: Representational State Transfer (REST)</h3>
<p>4장에서 제시한 접근방법의 결과물로 웹을 위한 아키텍처 스타일 &#8220;REST&#8221;를 소개한다. REST는 3장에서 소개했던 네트워크 기반 아키텍처 스타일들 몇 가지와 추가로 Uniform Interface 스타일을 함께 결합한 하이브리드 스타일이다.</p>
<ul>
<li>Client-Server &#8211; 클라이언트-서버 스타일은 사용자 인터페이스에 대한 관심(concern)을 데이터 저장에 대한 관심으로부터 분리함으로써 클라이언트의 이식성과 서버의 규모확장성을 개선한다.</li>
<li>Stateless &#8211; 클라이언트와 서버의 통신에는 상태가 없어야한다. 모든 요청은 필요한 모든 정보를 담고 있어야한다. 요청 하나만 봐도 바로 뭔지 알 수 있으므로 가시성이 개선되고, task 실패시 복원이 쉬우므로 신뢰성이 개선되며, 상태를 저장할 필요가 없으므로 규모확장성이 개선된다.</li>
<li>Cache &#8211; 캐시가 가능해야한다. 즉 모든 서버 응답은 캐시 가능한지 그렇지 아닌지 알 수 있어야한다. 호율, 규모확장성, 사용자 입장에서의 성능이 개선된다.</li>
<li>Uniform Interface &#8211; 구성요소(클라이언트, 서버 등) 사이의 인터페이스는 균일(uniform)해야한다. 인터페이스를 일반화함으로써, 전체 시스템 아키텍처가 단순해지고, 상호작용의 가시성이 개선되며, 구현과 서비스가 분리되므로 독립적인 진화가 가능해진다. 이 스타일은 다음의 네 제약조건으로 이루어진다: identification of resources, manipulation of resources through representation, self-descriptive messages, hypermedia as the engine of application state</li>
<li>Layered System &#8211; 계층(hierarchical layers)으로 구성이 가능해야하며, 각 레이어에 속한 구성요소는 인접하지 않은 레이어의 구성요소를 볼 수 없어야한다.</li>
<li>Code-On-Demand (Optional) &#8211; Code-On-Demand가 가능해야한다. 서버가 네트워크를 통해 클라이언트에 프로그램을 전달하면 그 프로그램이 클라이언트에서 실행될 수 있어야한다. (Java applet이나 Javascript 같은 것을 말함) 다만 이 제약조건은 필수는 아니다.</li>
</ul>
<h3>6장: Experience and Evaluation</h3>
<p>REST 아키텍처 스타일은 URI, HTTP 등의 웹 표준에 반영되었다.</p>
<h2>문제는 Uniform Interface (그리고 다음 포스팅 예고)</h2>
<p>우리가 이 논문에서 가장 주목해야 할 부분은 바로, REST를 구성하는 스타일들 중 하나인 &#8220;Uniform Interface&#8221;다. 이 스타일에 따르면, REST API는 기본 URI와 미디어 타입의 정의만 알면 이용할 수 있어야한다.</p>
<p>예를 들어 Github API가 REST API라면, <a href="https://api.github.com" rel="nofollow">https://api.github.com</a> 이라는 기본 URI와 application/json의 정의만 알면 API 문서 없이도 Github API 전체가 이용이 가능해야 한다는 말이 된다. 아마 가능하지 않을 것이다. 따라서 Github API는 REST API가 아니다. 아마 세상의 거의 모든 HTTP API가 REST API가 아닐 것이다.</p>
<p>Code-On-Demand를 제외한 모든 스타일을 다 따라야만 REST API이기 때문에, 자신의 API를 REST API라고 부르고 싶다면 이 Uniform Interface 스타일 역시 따라야한다.</p>
<p>과연 Uniform Interface 스타일을 따르는 것은 가능할까? 아니 그 이전에 따르기는 해야 하는 것일까? 그것에 대해서는 다음 포스팅에서 다룰 것이다.</p>
]]></content:encoded>
							<wfw:commentRss>https://blog.npcode.com/2017/03/02/%eb%b0%94%ec%81%9c-%ea%b0%9c%eb%b0%9c%ec%9e%90%eb%93%a4%ec%9d%84-%ec%9c%84%ed%95%9c-rest-%eb%85%bc%eb%ac%b8-%ec%9a%94%ec%95%bd/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/065bcc1fd59a5b1bcc8753b1c8cc1276?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">yieungjun</media:title>
		</media:content>
	</item>
		<item>
		<title>비바 리퍼블리카로 이직한 이야기</title>
		<link>https://blog.npcode.com/2016/11/22/%eb%b9%84%eb%b0%94-%eb%a6%ac%ed%8d%bc%eb%b8%94%eb%a6%ac%ec%b9%b4%eb%a1%9c-%ec%9d%b4%ec%a7%81%ed%95%9c-%ec%9d%b4%ec%95%bc%ea%b8%b0/</link>
				<comments>https://blog.npcode.com/2016/11/22/%eb%b9%84%eb%b0%94-%eb%a6%ac%ed%8d%bc%eb%b8%94%eb%a6%ac%ec%b9%b4%eb%a1%9c-%ec%9d%b4%ec%a7%81%ed%95%9c-%ec%9d%b4%ec%95%bc%ea%b8%b0/#comments</comments>
				<pubDate>Mon, 21 Nov 2016 17:34:26 +0000</pubDate>
		<dc:creator><![CDATA[Yi EungJun]]></dc:creator>
				<category><![CDATA[미분류]]></category>

		<guid isPermaLink="false">http://blog.npcode.com/?p=898</guid>
				<description><![CDATA[2016년 11월 20일, 나는 8년 10개월간 근무한 네이버를 퇴사하고, 그 바로 다음날인 21일 스마트폰 송금 서비스 토스를 만드는 비바 리퍼블리카에 입사했다. 입사를 결정하게 된 계기 작년 즈음부터 스타트업에서 일해보는 것도 괜찮을 것 같다는 생각을 하게 되었는데, 그 와중에 비바 리퍼블리카에서 보낸 구인 메일을 받고서 이직을 생각하게 되었다. 2주일 정도 생각을 해보다가 한번 면접을 보기로 결정하고 &#8230; <a href="https://blog.npcode.com/2016/11/22/%eb%b9%84%eb%b0%94-%eb%a6%ac%ed%8d%bc%eb%b8%94%eb%a6%ac%ec%b9%b4%eb%a1%9c-%ec%9d%b4%ec%a7%81%ed%95%9c-%ec%9d%b4%ec%95%bc%ea%b8%b0/" class="more-link"><span class="screen-reader-text">비바 리퍼블리카로 이직한&#160;이야기</span> 계속 읽기</a>]]></description>
								<content:encoded><![CDATA[<p>2016년 11월 20일, 나는 8년 10개월간 근무한 네이버를 퇴사하고, 그 바로 다음날인<br />
21일 스마트폰 송금 서비스 토스를 만드는 비바 리퍼블리카에 입사했다.</p>
<h3>입사를 결정하게 된 계기</h3>
<p>작년 즈음부터 스타트업에서 일해보는 것도 괜찮을 것 같다는 생각을 하게 되었는데,<br />
그 와중에 비바 리퍼블리카에서 보낸 구인 메일을 받고서 이직을 생각하게 되었다.</p>
<p>2주일 정도 생각을 해보다가 한번 면접을 보기로 결정하고 회신 메일을 보냈다. 나는<br />
내가 좋아하는 서비스를 만들기를 원했고, 비바 리퍼블리카에서 만드는 토스는 UX가<br />
굉장히 훌륭해서 매우 만족스럽게 쓰고 있다. 그것이 입사를 결정한 가장 결정적인<br />
이유이다.</p>
<h3>채용 과정</h3>
<p>이후 진행은 일사천리였다.</p>
<p>10월 2일(일), 입사 제의를 받아들이기로 결정하고 회신<br />
10월 4일(화), 오프라인에서 비바 리퍼블리카가 어떤 회사인지 이야기를 들음<br />
10월 5일(수), 메일로 이력서 전달<br />
10월 7일(금), 기술 면접<br />
10월 10일(월), 최종 면접<br />
10월 11일(화), 최종 합격 및 오퍼 받음<br />
10월 12일(수), 오퍼 수락</p>
<p>면접을 보기로 결정하고 최종적으로 오퍼를 받아들이기까지 고작 10일밖에 걸리지<br />
않았다. 정말 놀라운 속도였다.</p>
<h3>퇴사 및 입사</h3>
<p>10월 17일(월), 네이버 퇴직 신청<br />
11월 5일(금), 네이버 마지막 출근<br />
11월 20일(일), 네이버 퇴사<br />
11월 21일(월), 비바 리퍼블리카 입사</p>
<p>2주간 휴가를 갖고 비바 리퍼블리카에 입사하였다.</p>
<h3>여담</h3>
<p>비바 리퍼블리카에 이력서를 보낸 날, 적립 서비스 도도포인트를 만드는 스타트업인<br />
스포카에도 이력서를 보냈다. 스포카는 오픈소스 활동을 적극적으로 하는 점이<br />
매력적이어서 관심을 갖고 있던 회사였다.</p>
<p>하지만 아쉽게도 스포카에서 서류 전형 합격 메일을 받았을 때는 이미 내가 비바<br />
리퍼블리카의 오퍼를 받은 뒤였기 때문에 스포카의 면접을 보는 일은 없었다.<br />
스포카의 채용 프로세스가 느리지는 않았지만 비바 리퍼블리카가 너무나도 빨랐다.</p>
]]></content:encoded>
							<wfw:commentRss>https://blog.npcode.com/2016/11/22/%eb%b9%84%eb%b0%94-%eb%a6%ac%ed%8d%bc%eb%b8%94%eb%a6%ac%ec%b9%b4%eb%a1%9c-%ec%9d%b4%ec%a7%81%ed%95%9c-%ec%9d%b4%ec%95%bc%ea%b8%b0/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/065bcc1fd59a5b1bcc8753b1c8cc1276?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">yieungjun</media:title>
		</media:content>
	</item>
		<item>
		<title>wordpress.com로 이사</title>
		<link>https://blog.npcode.com/2015/12/03/wordpress-com%eb%a1%9c-%ec%9d%b4%ec%82%ac/</link>
				<comments>https://blog.npcode.com/2015/12/03/wordpress-com%eb%a1%9c-%ec%9d%b4%ec%82%ac/#comments</comments>
				<pubDate>Thu, 03 Dec 2015 14:21:37 +0000</pubDate>
		<dc:creator><![CDATA[Yi EungJun]]></dc:creator>
				<category><![CDATA[미분류]]></category>

		<guid isPermaLink="false">http://blog.npcode.com/?p=887</guid>
				<description><![CDATA[원래 cafe24 가상 호스팅에 설치형 워드프레스를 쓰고 있었는데, 때때로 서버가 죽어서 좋지 않았다. 죽어도 알려주지도 않는다는 점은 더욱 나빴다. 그래서 서비스형 워드프레스로 이사왔다. 도메인 연결비용 연 13달러만 내면 되고 서버가 잘 죽지도 않을 것 같고 죽더라도 알아서 살려낼테니. disqus로 댓글 단 건 옮겨오지 못하고 백업만 했다. xml로 export를 하기는 했는데, 여기로 import 하는 방법은 모르겠다.]]></description>
								<content:encoded><![CDATA[<p>원래 cafe24 가상 호스팅에 설치형 워드프레스를 쓰고 있었는데, 때때로 서버가 죽어서 좋지 않았다. 죽어도 알려주지도 않는다는 점은 더욱 나빴다.</p>
<p>그래서 서비스형 워드프레스로 이사왔다. 도메인 연결비용 연 13달러만 내면 되고 서버가 잘 죽지도 않을 것 같고 죽더라도 알아서 살려낼테니.</p>
<p>disqus로 댓글 단 건 옮겨오지 못하고 백업만 했다. xml로 export를 하기는 했는데, 여기로 import 하는 방법은 모르겠다.</p>
]]></content:encoded>
							<wfw:commentRss>https://blog.npcode.com/2015/12/03/wordpress-com%eb%a1%9c-%ec%9d%b4%ec%82%ac/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/065bcc1fd59a5b1bcc8753b1c8cc1276?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">yieungjun</media:title>
		</media:content>
	</item>
		<item>
		<title>구글 크롬으로 구글에 접속하면 HTTP/2가 아닌 SPDY/3.1을 사용하는 이유</title>
		<link>https://blog.npcode.com/2015/09/18/%ea%b5%ac%ea%b8%80-%ed%81%ac%eb%a1%ac%ec%9c%bc%eb%a1%9c-%ea%b5%ac%ea%b8%80%ec%97%90-%ec%a0%91%ec%86%8d%ed%95%98%eb%a9%b4-http2%ea%b0%80-%ec%95%84%eb%8b%8c-spdy3-1%ec%9d%84-%ec%93%b0%eb%8a%94/</link>
				<comments>https://blog.npcode.com/2015/09/18/%ea%b5%ac%ea%b8%80-%ed%81%ac%eb%a1%ac%ec%9c%bc%eb%a1%9c-%ea%b5%ac%ea%b8%80%ec%97%90-%ec%a0%91%ec%86%8d%ed%95%98%eb%a9%b4-http2%ea%b0%80-%ec%95%84%eb%8b%8c-spdy3-1%ec%9d%84-%ec%93%b0%eb%8a%94/#respond</comments>
				<pubDate>Fri, 18 Sep 2015 04:38:05 +0000</pubDate>
		<dc:creator><![CDATA[Yi EungJun]]></dc:creator>
				<category><![CDATA[미분류]]></category>

		<guid isPermaLink="false">http://npcode.com/blog/?p=885</guid>
				<description><![CDATA[구글 크롬을 이용해서 구글 사이트에 접속하면 HTTP/2가 아닌 QUIC+SPDY/3.1로 동작하게 된다. 왜 HTTP/2가 아닌 SPDY/3.1을 사용하는 것일까? 내 생각엔 명세상 QUIC과 HTTP/2를 동시에 사용할 수 없어서가 아닐까 싶다. HTTP 명세를 살펴보자. 우선 HTTP/1.1은 TCP를 강제하지 않는다. 신뢰할 수 있는 transport layer 위에서 구현되어 있기만 하면 된다. HTTP is a stateless request/response protocol that operates by &#8230; <a href="https://blog.npcode.com/2015/09/18/%ea%b5%ac%ea%b8%80-%ed%81%ac%eb%a1%ac%ec%9c%bc%eb%a1%9c-%ea%b5%ac%ea%b8%80%ec%97%90-%ec%a0%91%ec%86%8d%ed%95%98%eb%a9%b4-http2%ea%b0%80-%ec%95%84%eb%8b%8c-spdy3-1%ec%9d%84-%ec%93%b0%eb%8a%94/" class="more-link"><span class="screen-reader-text">구글 크롬으로 구글에 접속하면 HTTP/2가 아닌 SPDY/3.1을 사용하는&#160;이유</span> 계속 읽기</a>]]></description>
								<content:encoded><![CDATA[<p>구글 크롬을 이용해서 구글 사이트에 접속하면 HTTP/2가 아닌 QUIC+SPDY/3.1로<br />
동작하게 된다. 왜 HTTP/2가 아닌 SPDY/3.1을 사용하는 것일까?</p>
<p>내 생각엔 명세상 QUIC과 HTTP/2를 동시에 사용할 수 없어서가 아닐까 싶다.</p>
<p>HTTP 명세를 살펴보자. 우선 HTTP/1.1은 TCP를 강제하지 않는다. 신뢰할 수 있는<br />
transport layer 위에서 구현되어 있기만 하면 된다.</p>
<blockquote>
<p>HTTP is a stateless request/response protocol that operates by<br />
  exchanging messages (Section 3) across a reliable transport- or<br />
  session-layer &#8220;connection&#8221; (Section 6).</p>
<p>&#8212; <a href="https://tools.ietf.org/rfc/rfc7230.txt" rel="nofollow">https://tools.ietf.org/rfc/rfc7230.txt</a></p>
</blockquote>
<p>다음 문장에서도 그 사실을 확인할 수 있다.</p>
<blockquote>
<p>Although HTTP is independent of the transport protocol, the &#8220;http&#8221;<br />
  scheme is specific to TCP-based services because the name delegation<br />
  process depends on TCP for establishing authority.</p>
<p>&#8212; <a href="https://tools.ietf.org/rfc/rfc7230.txt" rel="nofollow">https://tools.ietf.org/rfc/rfc7230.txt</a></p>
</blockquote>
<p>TCP를 강제하지 않는 것은 SPDY/3.1 역시 마찬가지다.</p>
<blockquote>
<p>SPDY adds a framing layer for multiplexing multiple, concurrent streams<br />
  across a single TCP connection (or any reliable transport stream).</p>
<p>&#8212; <a href="https://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1" rel="nofollow">https://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1</a></p>
</blockquote>
<p>반면에 HTTP/2는 명시적으로 TCP를 요구한다.</p>
<blockquote>
<p>An HTTP/2 connection is an application-layer protocol running on top<br />
  of a TCP connection ([TCP]).</p>
<p>&#8212; <a href="https://tools.ietf.org/rfc/rfc7540.txt" rel="nofollow">https://tools.ietf.org/rfc/rfc7540.txt</a></p>
</blockquote>
<p>구글에서 구현한 QUIC 프로토콜은 TCP의 영역인 transport layer를 포함한다.<br />
따라서 QUIC을 사용한다는 것은 TCP를 사용하지 않는다는 것이므로 QUIC 위에서<br />
HTTP/2를 동작시키는 것은 HTTP/2 명세의 정의상 불가능하다.</p>
<p><a href="https://twitter.com/Outsideris/status/644378099786780672/photo/1">변정훈님의 트윗</a>을 보고 생각나서 적어보았다.</p>
<p>ps. <a href="https://twitter.com/serialx_net/status/644763826970193921">Brian Hong님의 트윗</a>에 따르면 QUIC은 TCP만을 대체하는 것이 아니라 SPDY도 대체하는 것이라고 한다. 확인해보니 QUIC은 <a href="https://www.chromium.org/quic">TCP+TLS+SPDY</a> 혹은 <a href="http://tools.ietf.org/html/draft-tsvwg-quic-protocol-01">TCP+TLS+HTTP/2와 동등</a>하다고 한다.</p>
]]></content:encoded>
							<wfw:commentRss>https://blog.npcode.com/2015/09/18/%ea%b5%ac%ea%b8%80-%ed%81%ac%eb%a1%ac%ec%9c%bc%eb%a1%9c-%ea%b5%ac%ea%b8%80%ec%97%90-%ec%a0%91%ec%86%8d%ed%95%98%eb%a9%b4-http2%ea%b0%80-%ec%95%84%eb%8b%8c-spdy3-1%ec%9d%84-%ec%93%b0%eb%8a%94/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/065bcc1fd59a5b1bcc8753b1c8cc1276?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">yieungjun</media:title>
		</media:content>
	</item>
		<item>
		<title>gnome에서 hidpi 1.5배 스케일</title>
		<link>https://blog.npcode.com/2015/09/18/gnome%ec%97%90%ec%84%9c-hidpi-1-5%eb%b0%b0-%ec%8a%a4%ec%bc%80%ec%9d%bc/</link>
				<comments>https://blog.npcode.com/2015/09/18/gnome%ec%97%90%ec%84%9c-hidpi-1-5%eb%b0%b0-%ec%8a%a4%ec%bc%80%ec%9d%bc/#respond</comments>
				<pubDate>Thu, 17 Sep 2015 15:15:07 +0000</pubDate>
		<dc:creator><![CDATA[Yi EungJun]]></dc:creator>
				<category><![CDATA[미분류]]></category>
		<category><![CDATA[gnome]]></category>
		<category><![CDATA[linux]]></category>

		<guid isPermaLink="false">http://npcode.com/blog/?p=882</guid>
				<description><![CDATA[요새 hidpi 지원하는 모니터/노트북들이 많은데, 이런 디스플레이의 경우 gnome은 자동으로 2배로 스케일을 해 준다. 하지만 솔직히 2배는 너무 크다. 1.5배 정도가 적당할 것 같은데, 스케일은 오직 정수 단위로만 지원된다. 하지만 다음과 같이 스케일은 1배로 하고, 텍스트만 1.5배로 하는 걸로 어느정도 흉내는 낼 수 있다. gsettings set org.gnome.desktop.interface scaling-factor 1 gsettings set org.gnome.desktop.interface text-scaling-factor 1.5 그럭저럭 &#8230; <a href="https://blog.npcode.com/2015/09/18/gnome%ec%97%90%ec%84%9c-hidpi-1-5%eb%b0%b0-%ec%8a%a4%ec%bc%80%ec%9d%bc/" class="more-link"><span class="screen-reader-text">gnome에서 hidpi 1.5배&#160;스케일</span> 계속 읽기</a>]]></description>
								<content:encoded><![CDATA[<p>요새 hidpi 지원하는 모니터/노트북들이 많은데, 이런 디스플레이의 경우 gnome은 자동으로 2배로 스케일을 해 준다. 하지만 솔직히 2배는 너무 크다. 1.5배 정도가 적당할 것 같은데, 스케일은 오직 정수 단위로만 지원된다.</p>
<p>하지만 다음과 같이 스케일은 1배로 하고, 텍스트만 1.5배로 하는 걸로 어느정도 흉내는 낼 수 있다.</p>
<pre><code>gsettings set org.gnome.desktop.interface scaling-factor 1
gsettings set org.gnome.desktop.interface text-scaling-factor 1.5
</code></pre>
<p>그럭저럭 만족하면서 쓸 수 있는 수준은 될 것이다.</p>
]]></content:encoded>
							<wfw:commentRss>https://blog.npcode.com/2015/09/18/gnome%ec%97%90%ec%84%9c-hidpi-1-5%eb%b0%b0-%ec%8a%a4%ec%bc%80%ec%9d%bc/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/065bcc1fd59a5b1bcc8753b1c8cc1276?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">yieungjun</media:title>
		</media:content>
	</item>
		<item>
		<title>웹 프로그래머를 위한 HTTP 완벽 가이드 읽는 법</title>
		<link>https://blog.npcode.com/2015/06/07/%ec%9b%b9-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%a8%b8%eb%a5%bc-%ec%9c%84%ed%95%9c-http-%ec%99%84%eb%b2%bd-%ea%b0%80%ec%9d%b4%eb%93%9c-%ec%9d%bd%eb%8a%94-%eb%b2%95/</link>
				<comments>https://blog.npcode.com/2015/06/07/%ec%9b%b9-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%a8%b8%eb%a5%bc-%ec%9c%84%ed%95%9c-http-%ec%99%84%eb%b2%bd-%ea%b0%80%ec%9d%b4%eb%93%9c-%ec%9d%bd%eb%8a%94-%eb%b2%95/#comments</comments>
				<pubDate>Sat, 06 Jun 2015 16:01:00 +0000</pubDate>
		<dc:creator><![CDATA[Yi EungJun]]></dc:creator>
				<category><![CDATA[HTTP]]></category>
		<category><![CDATA[프로그래밍]]></category>

		<guid isPermaLink="false">http://npcode.com/blog/?p=876</guid>
				<description><![CDATA[HTTP 완벽가이드는 이름 그대로 HTTP를 매우 자세히 다루고 있는 책이다. HTTP를 이해해야 하는 사람은 웹 프로그래머만은 아니므로, 이 책은 웹 프로그래머만을 위해 쓰여진 책이 아니다. 따라서 웹 프로그래머가 이 책의 내용을 모두 다 완전히 이해해야 하는 것은 아니며, 중요도가 장 마다 크게 다르다. 웹 프로그래머의 시간은 유한한데 반해 공부해야 할 내용은 어마어마하게 많으므로, 중요한 것만 &#8230; <a href="https://blog.npcode.com/2015/06/07/%ec%9b%b9-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%a8%b8%eb%a5%bc-%ec%9c%84%ed%95%9c-http-%ec%99%84%eb%b2%bd-%ea%b0%80%ec%9d%b4%eb%93%9c-%ec%9d%bd%eb%8a%94-%eb%b2%95/" class="more-link"><span class="screen-reader-text">웹 프로그래머를 위한 HTTP 완벽 가이드 읽는&#160;법</span> 계속 읽기</a>]]></description>
								<content:encoded><![CDATA[<p><a href="http://www.yes24.com/24/Goods/15381085?Acode=101">HTTP 완벽가이드</a>는 이름 그대로 HTTP를 매우 자세히 다루고 있는 책이다. HTTP를 이해해야 하는 사람은<br />
웹 프로그래머만은 아니므로, 이 책은 웹 프로그래머만을 위해 쓰여진 책이 아니다.<br />
따라서 웹 프로그래머가 이 책의 내용을 모두 다 완전히 이해해야 하는 것은 아니며,<br />
중요도가 장 마다 크게 다르다.</p>
<p>웹 프로그래머의 시간은 유한한데 반해 공부해야 할 내용은 어마어마하게 많으므로,<br />
중요한 것만 읽고 안 읽어도 되는 부분은 그냥 넘어가자.</p>
<h1>무엇을 읽고 무엇을 안 읽을 것인가</h1>
<h2>I. HTTP: 웹의 기초</h2>
<p>Part I은 모두 읽는 것이 좋다. 기초가 튼튼해야 이후의 내용을 잘 이해할 수 있다.</p>
<p>1장 &#8220;HTTP 개관&#8221;은 HTTP에 대해 개략적으로 설명해주므로, 이후의 내용들을<br />
이해하는데 도움이 된다.</p>
<p>2장 &#8220;URL과 리소스&#8221;와 3장 &#8220;HTTP 메시지&#8221;는 반드시 읽어야 한다. 이 장들을 읽지<br />
않으면 이후 내용들도 이해하기 어렵다. 특히 3장은 이름대로 HTTP 그 자체를<br />
설명하는 장이다.</p>
<p>4장 &#8220;커넥션 관리&#8221;도 읽는 것이 좋다. HTTP 기저에서 TCP가 어떻게 동작하는지<br />
설명한다. 읽고 나면 HTTP가 왜 느린지 이해할 수 있게 될 것이다.</p>
<h2>II. HTTP 아키텍처</h2>
<p>Part II는 유용한 내용이 많다. 특히 5장이 가장 중요하고 그 다음은 7장이 유용하다.</p>
<p>5장 &#8220;웹 서버&#8221;는 웹 서버가 어떻게 동작하는지 설명한다. 웹 프로그래머라면 반드시<br />
이해해야 할 것이다.</p>
<p>6장 &#8220;프락시&#8221;도 읽는 것이 좋다. 프락시에 대한 이야기는 이후에도 계속 나오게<br />
된다. 또한 네트워크 엔지니어들과 대화하려면 프락시 정도는 이해하는 것이 좋다.</p>
<p>7장 &#8220;캐시&#8221;도 읽어 두자. 제목은 캐시지만 캐시 뿐 아니라 조건부 요청(304로<br />
응답하는 그거)도 다룬다. 웹 프로그래머라면 반드시 써먹게 될 것이다. 15장에서도<br />
같은 내용을 다루기는 하지만 7장이 더 자세하다.</p>
<p>8장 &#8220;통합점: 게이트웨이, 터널, 릴레이&#8221;는 꼭 읽어야 하는 건 아니다. 나중에<br />
궁금해지면 읽어도 별 상관은 없다.</p>
<p>9장 &#8220;웹 로봇&#8221;은 로봇이나 검색엔진에 관심이 있다면 읽어보자. 웹 서비스를<br />
운영하게 된다면 웹 로봇이 무슨 원리와 규칙으로 동작하는지 궁금해질 것이다. 혹은 그냥 웹에 대한 교양이라는 느낌으로 읽어도 좋다.</p>
<p>10장 &#8220;HTTP/2.0&#8243;는 HTTP/2가 궁금하다면 읽어보자. HTTP/2의 목적은 성능 개선이니, HTTP/1이 느린 것이 불만인 사람도 읽어보자. HTTP/2가 완성되기 전에 쓴<br />
것이긴 하지만 최신 명세와 크게 다른 점은 없을 것이다.</p>
<h2>III. 식별, 인가, 보안</h2>
<p>Part III는 13장 빼고는 대체로 유용하다.</p>
<p>11장 &#8220;클라이언트 식별과 쿠키&#8221;를 읽으면 쿠키에 대해 올바르게 이해할 수 있게 된다.</p>
<p>12장 &#8220;기본 인증&#8221;도 읽으면 좋다. 기본 인증(Basic Authentication)은 여전히 종종<br />
쓰이기 때문이다. 그리고 매우 쉬워서 읽기도 좋다.</p>
<p>13장 &#8220;다이제스트 인증&#8221;은 읽을 필요가 없다. 다이제스트 인증 쓰는 것은 거의 본<br />
일이 없다. 이걸 공부해도 써 먹을 일은 아마 없을 것이다. 심지어 내용도 복잡해서<br />
읽어도 이해가 잘 안된다. 여럿이 같이 스터디 중이라면 이 장은 그냥 제끼자.</p>
<p>14장 &#8220;보안 HTTP&#8221;은 HTTPS를 다루고 있다. 읽는 것이 좋다. 몰라도 HTTPS를 쓸 수는<br />
있겠지만, 왜 HTTPS가 안전한지 이해하고 싶다면 읽는 것이 좋다.</p>
<h2>IV. 엔터티, 인코딩, 국제화</h2>
<p>파트 I가 HTTP에 대한 기본적인 이해를 위해 필요했다면, 파트 IV는 HTTP를 제대로<br />
쓰기 위해서 필요하다. 여기서 다루는 내용들은 대체로 웹 서버나 웹 프레임워크가<br />
알아서 처리해주지 않아서 웹 프로그래머가 이해해야 하는 것들이 많다. 가급적 모두<br />
읽도록 하자.</p>
<p>그 중에서도 16장 &#8220;국제화&#8221;에서 다루는 내용은 비단 웹 프로그래밍이나 HTTP에만<br />
적용되는 내용이 아니라 다국어를 다루는 모든 프로그래머가 알아야 할 내용이므로 활용 범위가 매우 넓다.</p>
<h2>V. 콘텐츠 발행 및 배포</h2>
<p>이 파트의 내용은 선택적으로 필요에 따라 읽으면 된다. 스터디를 하고 있다면 이<br />
파트 전체를 생략해도 괜찮다.</p>
<p>18장 &#8220;웹 호스팅&#8221;은 웹 서비스 운영을 시작하게 되면 그때 읽어도 무방하다.</p>
<p>19장 &#8220;배포 시스템&#8221;은 FrontPage와 WebDAV을 다루는데, 지금 FrontPage나 WebDAV을 쓸 일이 없다면 읽지<br />
않아도 무방하다.</p>
<p>20장 &#8220;리다이렉션과 부하 균형&#8221;은 앞부분만 좀 읽고 넘어가도 된다. 이 장에서<br />
다루고 있는 캐시 배열 라우팅 프로토콜 같은 거 나는 써본 일이 없다. 혹시<br />
네트워크 엔지니어 역할까지 겸하고 있다면 알 필요가 있을지도 모르겠는데, 나는<br />
그런 경험을 해 본 일이 없어서 잘 모르겠다.</p>
<p>21장 &#8220;로깅과 사용추적&#8221;도 역시 필요에 따라 읽으면 된다. 로그 포맷에 대한 내용은<br />
사용하고 있는 웹 서버의 매뉴얼을 읽어도 충분할 것이고, 사용 추적은 필요하지<br />
않을 수도 있다.</p>
<h2>VI. 부록</h2>
<p>부록은 대체로 HTTP 명세나 IANA 웹사이트 등에서 찾아볼 수 있는 것들이다. 책이<br />
두꺼워서 들고다니기 무겁다면 잘라내도 좋다. 그냥 인터넷에서 찾아봐도 된다.</p>
<h1>세줄 요약</h1>
<p>매우 바쁘다면 1-3장만 읽자. 그 정도만 읽어도 큰 도움이 된다.</p>
<p>조금 바쁘다면 1-5, 7, 11, 12, 14, 15, 16, 17장을 읽자.</p>
<p>13, 19장은 관심있는 사람만 읽자.</p>
]]></content:encoded>
							<wfw:commentRss>https://blog.npcode.com/2015/06/07/%ec%9b%b9-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%a8%b8%eb%a5%bc-%ec%9c%84%ed%95%9c-http-%ec%99%84%eb%b2%bd-%ea%b0%80%ec%9d%b4%eb%93%9c-%ec%9d%bd%eb%8a%94-%eb%b2%95/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/065bcc1fd59a5b1bcc8753b1c8cc1276?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">yieungjun</media:title>
		</media:content>
	</item>
		<item>
		<title>프로 Git 읽는 법</title>
		<link>https://blog.npcode.com/2013/04/27/git%ec%9d%84-%eb%b0%b0%ec%9a%b0%eb%a0%a4%eb%a9%b4-%ec%b1%85-%ed%94%84%eb%a1%9c-git%ec%9d%84-%ec%9d%bd%ec%9e%90/</link>
				<comments>https://blog.npcode.com/2013/04/27/git%ec%9d%84-%eb%b0%b0%ec%9a%b0%eb%a0%a4%eb%a9%b4-%ec%b1%85-%ed%94%84%eb%a1%9c-git%ec%9d%84-%ec%9d%bd%ec%9e%90/#respond</comments>
				<pubDate>Sat, 27 Apr 2013 12:34:22 +0000</pubDate>
		<dc:creator><![CDATA[Yi EungJun]]></dc:creator>
				<category><![CDATA[Git]]></category>
		<category><![CDATA[책]]></category>

		<guid isPermaLink="false">http://npcode.com/blog/?p=853</guid>
				<description><![CDATA[Git은 서브버전보다 사용하기 어렵다. 아마 대중적인 버전관리도구 중 가장 어려울 것이다. 서브버전은 따로 공부하지 않고 썼던 개발자라도, Git을 쓰려면 공부를 해야한다. Git을 공부하는 최고의 방법은 책 &#8216;프로 Git&#8216;을 읽는 것이다. 프로 Git을 처음 읽는 순간 그것을 확신했으며, 이후 사용자로서 Git을 익히고, 부분적으로 Git을 구현해보기도 하고, 사내에 Git 교육과정을 만들어 진행해본 이후에도 그 생각은 변하지 않았다. &#8230; <a href="https://blog.npcode.com/2013/04/27/git%ec%9d%84-%eb%b0%b0%ec%9a%b0%eb%a0%a4%eb%a9%b4-%ec%b1%85-%ed%94%84%eb%a1%9c-git%ec%9d%84-%ec%9d%bd%ec%9e%90/" class="more-link"><span class="screen-reader-text">프로 Git 읽는&#160;법</span> 계속 읽기</a>]]></description>
								<content:encoded><![CDATA[<p>Git은 서브버전보다 사용하기 어렵다. 아마 대중적인 버전관리도구 중 가장 어려울 것이다. 서브버전은 따로 공부하지 않고 썼던 개발자라도, Git을 쓰려면 공부를 해야한다.</p>
<p><strong>Git을 공부하는 최고의 방법은 책 &#8216;<a href="http://www.yes24.com/24/goods/8737301?scode=032&amp;OzSrank=1">프로 Git</a>&#8216;을 읽는 것이다.</strong> 프로 Git을 처음 읽는 순간 그것을 확신했으며, 이후 사용자로서 Git을 익히고, 부분적으로 Git을 구현해보기도 하고, 사내에 Git 교육과정을 만들어 진행해본 이후에도 그 생각은 변하지 않았다.</p>
<p>그러나 아무리 훌륭한 책이라고 할지라도, 오직 버전관리도구만을 위해 200페이지가 넘는 책을 처음부터 끝까지 모두 읽어야 한다는 것은 당장 개발을 시작하고 싶어하는 개발자들에게는 너무나도 지루하고 고통스러운 일이다.</p>
<p>다행히도 이 책을 반드시 모두가 완독해야만 하는 것은 아니다. 필요에 따라서 골라 읽어도 무방하다. 예를 들어 당장 내일부터 Git을 써서 개발을 시작해야 하는 상황이라면, 이 책의 1.3.5절과 2장을 읽고 연습해서 Git의 사용법을 익히면 된다.</p>
<p>어떤 챕터를 언제 읽는 것이 좋을지 적어보면 다음과 같다.</p>
<ol>
<li>시작하기 &#8211; 가급적이면 읽자. 정 읽기 싫으면 &#8220;1.3.5 세 가지 상태&#8221;만이라도 읽자. 그것만은 <strong>절대로</strong> 읽어야 한다. 읽지 않으면 Git을 쓸 수 없다.</li>
<li>Git의 기초 &#8211; 이것을 읽으면 Git을 쓸 수 있게 된다. <strong>반드시 읽자</strong></li>
<li>Git 브랜치 &#8211; 이것을 읽으면 Git을 잘 쓸 수 있게 된다. 왠만하면 읽자.</li>
<li>Git 서버 &#8211; Git 서버를 직접 운영한다면 읽어야 한다. 그렇지 않다면 읽지 않아도 무방하다. 물론 읽으면 서버를 이해할 수 있게 되어서 좋기는 하다.</li>
<li>분산 환경에서의 Git &#8211; 여러명이 협업한다면 읽는 것이 좋다.</li>
<li>Git 도구 &#8211; 뭐 더 좋은 기능 없어? 라는 생각이 들 때 읽어도 무방하다.</li>
<li>Git 맞춤 &#8211; 위와 마찬가지로, 이런 설정은 없나? 라는 생각이 들 때 발췌해서 읽어도 무방하다.</li>
<li>Git과 다른 VCS &#8211; Subversion과의 차이가 궁금하다면 읽자.</li>
<li>Git의 내부구조 &#8211; Git을 능숙하고 편안하게 다루려면 <strong>반드시</strong> 그 내부를 이해해야 한다. 팀에 한 명 정도는 이 챕터의 내용을 이해할 수 있는 수준에 달해있는 것이 좋다.</li>
</ol>
<p>이런 훌륭한 책을 지은 스캇 샤콘과, 한국어로 번역한 박창우, 이성환, 최용재님께 깊은 감사를 드리고 싶다.</p>
]]></content:encoded>
							<wfw:commentRss>https://blog.npcode.com/2013/04/27/git%ec%9d%84-%eb%b0%b0%ec%9a%b0%eb%a0%a4%eb%a9%b4-%ec%b1%85-%ed%94%84%eb%a1%9c-git%ec%9d%84-%ec%9d%bd%ec%9e%90/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/065bcc1fd59a5b1bcc8753b1c8cc1276?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">yieungjun</media:title>
		</media:content>
	</item>
		<item>
		<title>400 Bad Request와 403 Forbidden의 의미에 대해</title>
		<link>https://blog.npcode.com/2013/04/23/400-bad-request%ec%99%80-403-forbidden%ec%9d%98-%ec%9d%98%eb%af%b8%ec%97%90-%eb%8c%80%ed%95%b4/</link>
				<comments>https://blog.npcode.com/2013/04/23/400-bad-request%ec%99%80-403-forbidden%ec%9d%98-%ec%9d%98%eb%af%b8%ec%97%90-%eb%8c%80%ed%95%b4/#comments</comments>
				<pubDate>Tue, 23 Apr 2013 12:07:48 +0000</pubDate>
		<dc:creator><![CDATA[Yi EungJun]]></dc:creator>
				<category><![CDATA[HTTP]]></category>

		<guid isPermaLink="false">http://npcode.com/blog/?p=830</guid>
				<description><![CDATA[HTTP/1.1 HTTP/1.1을 정의한 최신 명세인 RFC 2616에 따르면, 흔히 알고 있는 것과는 달리 의외로 403 Forbidden은 권한(authorization)에 대한 에러가 아니다. 그냥 요청은 이해하지만 수행을 거절(refuse)하겠다는 의미이다. 그리고 또 의외로 400 Bad Request는 그냥 &#8220;요청이 잘못되었다&#8221;라는 의미가 아니라 &#8220;요청의 syntax가 잘못되어서 이해를 못하겠다&#8221;라는 의미를 담은 응답이다. 400 Bad Request에 대한 설명 (( http://tools.ietf.org/html/rfc2616#section-10.4.1 )) The request &#8230; <a href="https://blog.npcode.com/2013/04/23/400-bad-request%ec%99%80-403-forbidden%ec%9d%98-%ec%9d%98%eb%af%b8%ec%97%90-%eb%8c%80%ed%95%b4/" class="more-link"><span class="screen-reader-text">400 Bad Request와 403 Forbidden의 의미에&#160;대해</span> 계속 읽기</a>]]></description>
								<content:encoded><![CDATA[<h2>HTTP/1.1</h2>
<p>HTTP/1.1을 정의한 최신 명세인 RFC 2616에 따르면, 흔히 알고 있는 것과는 달리 의외로 403 Forbidden은 권한(authorization)에 대한 에러가 아니다. 그냥 요청은 이해하지만 수행을 거절(refuse)하겠다는 의미이다.</p>
<p>그리고 또 의외로 400 Bad Request는 그냥 &#8220;요청이 잘못되었다&#8221;라는 의미가 아니라 &#8220;요청의 syntax가 잘못되어서 이해를 못하겠다&#8221;라는 의미를 담은 응답이다.</p>
<p>400 Bad Request에 대한 설명 (( <a href="http://tools.ietf.org/html/rfc2616#section-10.4.1" rel="nofollow">http://tools.ietf.org/html/rfc2616#section-10.4.1</a> ))</p>
<pre><code>The request could not be understood by the server due to malformed syntax.
</code></pre>
<p>403 Forbidden에 대한 설명 (( <a href="http://tools.ietf.org/html/rfc2616#section-10.4.4" rel="nofollow">http://tools.ietf.org/html/rfc2616#section-10.4.4</a> ))</p>
<pre><code>The server understood the request, but is refusing to fulfill it.
</code></pre>
<h2>HTTP/1.1 개정판</h2>
<p>그런데 HTTP/1.1 개정판에선 흔히 알려진대로가 거의 맞다. 403 Forbidden은 권한(authorization)에 대한 에러가 맞고, 400 Bad Request는 그냥 요청에 문제가 있어서 처리를 못하겠다(혹은 안하겠다)는 에러다.</p>
<p>400 Bad Request에 대한 설명 (( <a href="http://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-22#section-6.5.1" rel="nofollow">http://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-22#section-6.5.1</a> ))</p>
<pre><code>The server cannot or will not process the request, due to a client error (e.g., malformed syntax).
</code></pre>
<p>403 Forbidden에 대한 설명 (( <a href="http://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-22#section-6.5.3" rel="nofollow">http://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-22#section-6.5.3</a> ))</p>
<pre><code>The server understood the request, but refuses to authorize it.
</code></pre>
<p>요새 점점 RFC 2616보다 개정판을 따르는게 낫겠다는 생각이 들고 있다. 별 차이 없겠지 싶어서 그냥 RFC 2616을 따르고 있었는데, 의외로 이렇게 차이가 나는 부분이 있다. 어차피 개정판이라고 해봐야 설명만 고친거고 프로토콜의 요구사항 자체는 둘 다 같으니 동작에 문제를 일으키는 일은 없겠지.</p>
]]></content:encoded>
							<wfw:commentRss>https://blog.npcode.com/2013/04/23/400-bad-request%ec%99%80-403-forbidden%ec%9d%98-%ec%9d%98%eb%af%b8%ec%97%90-%eb%8c%80%ed%95%b4/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/065bcc1fd59a5b1bcc8753b1c8cc1276?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">yieungjun</media:title>
		</media:content>
	</item>
		<item>
		<title>절대경로가 &#034;//&#034;로 시작하는 URL은 스펙 위반일까?</title>
		<link>https://blog.npcode.com/2013/03/01/url%ec%9d%98-%ea%b2%bd%eb%a1%9c%ea%b0%80-%eb%a1%9c-%ec%8b%9c%ec%9e%91%ed%95%98%eb%8a%94-%ea%b2%bd%ec%9a%b0%ec%9d%98-%ed%95%b4%ec%84%9d%ec%97%90-%eb%8c%80%ed%95%b4/</link>
				<comments>https://blog.npcode.com/2013/03/01/url%ec%9d%98-%ea%b2%bd%eb%a1%9c%ea%b0%80-%eb%a1%9c-%ec%8b%9c%ec%9e%91%ed%95%98%eb%8a%94-%ea%b2%bd%ec%9a%b0%ec%9d%98-%ed%95%b4%ec%84%9d%ec%97%90-%eb%8c%80%ed%95%b4/#comments</comments>
				<pubDate>Fri, 01 Mar 2013 11:25:52 +0000</pubDate>
		<dc:creator><![CDATA[Yi EungJun]]></dc:creator>
				<category><![CDATA[HTTP]]></category>

		<guid isPermaLink="false">http://npcode.com/blog/?p=811</guid>
				<description><![CDATA[http://example.org//foo/bar 와 같이 path의 절대경로가 //로 시작하는 것은, URI의 정의에 대한 최신 명세인 RFC 3986을 위반한 것이다. 절대 경로는 &#8220;//&#8221;로 시작해서는 안된다. path-absolute ; begins with "/" but not "//" 그러나 HTML에서 &#60;a href="//foo/bar"&#62;test&#60;/a&#62; 와 같은 상대경로를 사용하는 것은 아무 문제가 없는데, 왜냐하면 HTML의 가장 최신 표준인 4.01(아직 5는 드래프트)은 RFC 3986보다 훨씬 오래된 RFC &#8230; <a href="https://blog.npcode.com/2013/03/01/url%ec%9d%98-%ea%b2%bd%eb%a1%9c%ea%b0%80-%eb%a1%9c-%ec%8b%9c%ec%9e%91%ed%95%98%eb%8a%94-%ea%b2%bd%ec%9a%b0%ec%9d%98-%ed%95%b4%ec%84%9d%ec%97%90-%eb%8c%80%ed%95%b4/" class="more-link"><span class="screen-reader-text">절대경로가 &#34;//&#34;로 시작하는 URL은 스펙&#160;위반일까?</span> 계속 읽기</a>]]></description>
								<content:encoded><![CDATA[<p><a href="http://example.org//foo/bar" rel="nofollow">http://example.org//foo/bar</a> 와 같이 path의 절대경로가 //로 시작하는 것은, URI의 정의에 대한 최신 명세인 RFC 3986을 위반한 것이다. 절대 경로는 &#8220;//&#8221;로 시작해서는 안된다.</p>
<pre><code>  path-absolute   ; begins with "/" but not "//"
</code></pre>
<p>그러나 HTML에서 <code>&lt;a href="//foo/bar"&gt;test&lt;/a&gt;</code> 와 같은 상대경로를 사용하는 것은 아무 문제가 없는데, 왜냐하면 HTML의 가장 최신 표준인 4.01(아직 5는 드래프트)은 RFC 3986보다 훨씬 오래된 RFC 1808에 따라 상대경로를 해석하기 때문이다. RFC 1808의 &#8220;2.4.3. Parsing the Network Location/Login&#8221;에 보면 url이 //로 시작하는 경우, // 이후부터 다음번 / 이전까지의 문자열을 net_loc(network location과 login information)로 삼게 되어있으므로, <code>//foo/bar</code>는 <code><a href="http://foo/bar" rel="nofollow">http://foo/bar</a></code>로 해석된다.</p>
<p>또한 HTTP/1.1 역시 URI를 해석할 때 RFC 3986이 아닌 그보다 오래된 RFC 2396을 따르므로 앞의 URL은 HTTP/1.1 명세를 위반한 것도 아니다.</p>
<p>그러나 HTTP/1.1은 곧 개정될 예정이며, 이 개정될 HTTP/1.1은 RFC 3986을 따르므로 결국 명세를 위반하는 것이 되지 않을까 걱정이 살짝 되는데, 다행히도 HTTP Working Group에서 몇 주 전에 이 문제를 발견하고서는 <a href="http://lists.w3.org/Archives/Public/ietf-http-wg/2013JanMar/thread.html#msg531">논의</a>를 거친 끝에 <a href="//trac.tools.ietf.org/wg/httpbis/trac/ticket/431">절대경로가 //로 시작해도 되는 것으로 예외처리</a>를 했기 때문에 위반이 아니게 될 것이다. 다만 그렇다고 해도 어디까지나 이건 HTTP에 국한된 이야기이므로, HTTP 응용프로그램이 아닌 소프트웨어를 개발할 때는 //로 시작하는 절대경로를 사용하면 RFC 3986을 위반하게 된다는 점을 신경써야 할 것이다.</p>
<p>그리고 마지막으로, 로이 필딩에 따르면 RFC 3986이 절대경로가 //로 시작할 수 없도록 막은 것은, URI 규칙을 새로운 ABNF로 재작성하는 과정에서 발생한 사고(accident)라고 한다.</p>
<pre><code>&gt; Roy, do you recall whether there's a reason why we would
&gt; want to rule out a path starting with "//"?

No, it is an accident of the transition to new URI ABNF and
should be raised as an issue.  There are several different ways to
fix it, depending on how lenient we want to be with parsing.
</code></pre>
<p>위 메일의 전문은 <a href="http://lists.w3.org/Archives/Public/ietf-http-wg/2013JanMar/0538.html">여기</a>서 확인할 수 있다.</p>
]]></content:encoded>
							<wfw:commentRss>https://blog.npcode.com/2013/03/01/url%ec%9d%98-%ea%b2%bd%eb%a1%9c%ea%b0%80-%eb%a1%9c-%ec%8b%9c%ec%9e%91%ed%95%98%eb%8a%94-%ea%b2%bd%ec%9a%b0%ec%9d%98-%ed%95%b4%ec%84%9d%ec%97%90-%eb%8c%80%ed%95%b4/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/065bcc1fd59a5b1bcc8753b1c8cc1276?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">yieungjun</media:title>
		</media:content>
	</item>
	</channel>
</rss>
