<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>Problem Solving</title>
<link>https://kesakiyo.tistory.com/</link>
<description></description>
<language>ko</language>
<pubDate>Mon, 13 May 2019 18:58:11 +0900</pubDate>
<generator>TISTORY</generator>
<managingEditor>kesakiyo</managingEditor>
<image>
<title>Problem Solving</title>
<url>http://cfile24.uf.tistory.com/image/264B204C58821F72213255</url>
<link>https://kesakiyo.tistory.com</link>
<description></description>
</image>
<item>
<title>자바스크립트의 typeof 연산자</title>
<link>https://kesakiyo.tistory.com/31</link>
<description>&lt;p style=&quot;clear: none; float: none;&quot;&gt;대부분의 프로그래밍 언어에서 데이터 타입을 확인할 수 있는 연산자를 제공한다. 자바스크립트도 데이터 타입을 확인할 수 있는 \(typeof\) 연산자를 제공한다. \(typeof\)연산자는 피 연산자의 데이터 타입을 문자열로 리턴한다. 사용법은 어렵지 않기때문에 실습 코드로 설명을 대신한다.&lt;/p&gt;
&lt;p style=&quot;clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;소스 코드&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: javascript&quot;&gt;/* number example */
var intNum = 10
var floatNum = 3.14

console.log(typeof intNum, typeof floatNum) // number number

/* string example */
var ch = 'a'
var str =  &quot;hello world&quot;

console.log(typeof ch, typeof str) // string string

/* boolean example */
var boolVal = true

console.log(typeof boolVal) // boolean

/* null, undefined example */
var nullVal = null
var undefinedVal = undefined

console.log(typeof nullVal) // object
console.log(typeof undefinedVal) // undefined
/* array, object example */
var arr = [1, 2, 3, 4]
var obj = {
	name: 'kesakiyo'
}

console.log(typeof arr) // object
console.log(typeof obj) // object

/* function example */
var func = function(x, y) {
	return x + y
}

console.log(typeof func) // function
&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;마무리&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;위 코드에서 유의해야 할 점이 몇 가지 있다. 첫 번째로 숫자는 정수형, 실수형 상관없이 \(number\) 타입을 가진다. 이는 자바스크립트에서 모든 숫자를 부동 소수점으로 저장하기 때문이다. 두 번째로 자바스크립트에서는 문자열과 \(char\) 구분이 없다.&amp;nbsp;세 번째로는 기본타입인 \(null\)이 \(object\) 타입을 가진다. 이 세가지는 헷갈리지 말고 정확히 기억하고 있어야 한다. 더 자세한 설명은 &lt;a href=&quot;http://kesakiyo.tistory.com/30&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&quot;자바스크립트의 데이터 타입&quot;&lt;/a&gt;에서 읽을 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:580px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/214AA036588CC0632B&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Picture1.png&quot; height=&quot;200&quot; width=&quot;580&quot;/&gt;&lt;/span&gt;&lt;/p&gt;</description>
<category>Javascript</category>
<category>typeof</category>
<category>데이터타입</category>
<category>데이터타입 확인</category>
<category>자바스크립트</category>
<author>kesakiyo</author>
<guid>https://kesakiyo.tistory.com/31</guid>
<comments>https://kesakiyo.tistory.com/31#entry31comment</comments>
<pubDate>Sun, 29 Jan 2017 00:03:18 +0900</pubDate>
</item>
<item>
<title>자바스크립트의 데이터 타입</title>
<link>https://kesakiyo.tistory.com/30</link>
<description>&lt;blockquote class=&quot;tx-quote-tistory&quot;&gt;&lt;p&gt;&lt;strike&gt;&lt;i&gt;&lt;span style=&quot;font-size: 10pt;&quot;&gt;이 글은 C, C++에 익숙한 개발자의 시점으로 작성됐습니다.&lt;/span&gt;&lt;/i&gt;&lt;/strike&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 13.3333px;&quot;&gt;&lt;b&gt;Symbol과 Object는 다루지 않습니다.&lt;/b&gt; 이 두 가지는 다른 포스팅에서 자세히 다룰 예정입니다.&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;자바 스크립트의 데이터 타입은 크게 두 가지로 나눠질 수 있다. 첫 번째는 &lt;b&gt;기본 타입&lt;/b&gt;, 두 번째는 &lt;b&gt;객체(Object)&lt;/b&gt;이다. 기본 타입은 숫자, 문자열, 불리언, undefined, null, Symbol(ECMAscript6)로 나눠지며 객체는 배열, 함수, 정규표현식으로 나눠진다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:580px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/2554C03A5882268A34&quot; filemime=&quot;image/jpeg&quot; filename=&quot;11111.png&quot; height=&quot;338&quot; width=&quot;580&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;이 글에서는 기본 타입에 해당하는 데이터 타입들을 살펴볼 것이다.&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;숫자(Number)&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;C, C++, Java는 숫자를 정수, 실수로 나눠 \(int\), &amp;nbsp;\(float\), &amp;nbsp;\(double\) 등과 같은 다양한 타입이 존재한다. 하지만 자바스크립트에서는 모든 숫자를 64비트 부동 소수점으로 저장하기 때문에 숫자 타입이 하나밖에 없다. 이는 ECMAscirpt 명세서 4.3.20 에서 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;그렇기 때문에 변수에 값을 초기화 할 때 정수, 실수 구분없이 바로 저장이 가능하다. 아래 예제에서 \(num\)에는&amp;nbsp;10을, \(PI\)에는 3.14를 대입한 뒤 출력하면 10과 3.14가 출력되는 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: javascript&quot;&gt;var num = 10
var PI = 3.14

console.log(num, PI)

&amp;gt; 10 3.14
&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;어떻게 보면 상당히 편리하다고 생각할 수 있다. 하지만 모든 수들이 부동 소수점으로 저장되기 때문에 연산을 할 때 주의해야 한다. 두 가지 예제를 보면서 어떤 위험이 도사리고 있는지 확인을 해 보자.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;첫 번째 예제는 나눗셈에서 흔히 할 수 있는 실수다. 변수 \(a\)에는 정수 3을, \(\ b\)에는 정수 2를 대입한다. 그리고 \(a\ /\ b\)를 출력해 보자. C++에 익숙한 개발자라면 당연히 출력값이 1이라고 생각한다. 하지만 이는 잘못된 생각이다. 자바스크립트는 모든 숫자 타입이 부동 소수점으로 저장되기 때문에 두 숫자를 실수로 취급하고 계산을 한다. 그렇기 때문에 1.5가 출력된다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;원하는 값인 1을 얻으려면 내장 함수 Math.floor( )을 사용하면 된다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: javascript&quot;&gt;var a = 3
var b = 2

console.log(a / b)
console.log(Math.floor(a / b))

&amp;gt; 1.5
&amp;gt; 1
&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;두 번째 예제는 두 수를 더할 때 발생할 수 있는 부동 소수점 오차이다. 부동 소수점은 한정된 메모리 내에서 넓은 범위의 수를 표현하기 위해 사용된다. 하지만 정확한 수를 저장하는 것이 아니라 근삿값으로 저장을 하기 때문에 연산을 할 때 오차가 발생을 할 수 있다. 아래 예제를 보면서 확인을 해보자.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre class=&quot;brush: javascript&quot;&gt;var a = 0.1
var b = 0.2

console.log(a * b, a + b)

&amp;gt; 0.020000000000000004 0.30000000000000004
&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;우리가 원하는 값은 암산으로 계산할 수 있을 정도로 간단하다. 0.1과 0.2을 곱하면 0.02가 돼야하고 0.1과 0.2를 더하면 0.3이 돼야 한다. 하지만 실제로 출력된 값은 기괴하기 짝이없다. 이런 부동 소수점 오류는 개발자가 의도하지 않은 상황을 야기하기 때문에 항상 주의를 할 필요가 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;문자열(String)&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;문자열은 말 그대로 문자열을 표현할 수 있는 데이터 타입이다. C, C++에서는 문자열은&amp;nbsp;큰따옴표로 초기화 하고, \(char\)는 작은따옴표로 초기화를 했다. 하지만 자바스크립트는 다르다. 큰따옴표와 작은따옴표 모두 문자열을 초기화 하는데 사용할 수 있다. 그리고 위에서 언급을 안했듯이 자바스크립트에는 \(char\)타입이 없다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre class=&quot;brush: javascript&quot;&gt;var str1 = &quot;hello world&quot;
var str2 = 'hello world'
var ch = 'c'

console.log(
	typeof str1,
	typeof str2,
	typeof ch
)

&amp;gt; string string string
&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;위 예제에서는 str1은 큰따옴표로 문자열을 초기화하고, str2는 작은따옴표로 문자열을 초기화했다. 마지막으로 ch 변수에 한 문자만 대입했다. 그리고 typeof 연산을 통해 str1, str2, ch의 데이터 타입을 출력한다. 세&amp;nbsp;변수 모두 string 데이터 타입을 갖는 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;문자열에서 주의할 점은 한번 초기화 된 문자열은 변하지 않는다는 점이다. 아래 예제를 살펴보자.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre class=&quot;brush: javascript&quot;&gt;var str = &quot;hello world&quot;
str[0] = &quot;H&quot;

console.log(str)

&amp;gt; hello world
&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;위 코드를 작성한 개발자는 첫 글자를 대문자로 바꾸고 출력하길 원했다. 하지만 출력 결과는 의도와는 전혀 다르게 원래 문자열이 출력된다. 심지어 런타임때 에러도 발생하지 않는다!! 자바스크립트에서 문자열을 수정하려면 새롭게 문자열 변수를 만들어 줘야 한다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;불리언(Boolean)&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;불리언 타입은 C나 C++과 거의 비슷하다. true 또는 false의 값을 가진다. 불리언에 대해서는 자세히 다룰 내용이 없으므로 간단한 예제코드 하나를 보고 넘어가자.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre class=&quot;brush: javascript&quot;&gt;var bool = true

console.log(typeof bool)

&amp;gt; boolean
&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;undefined와 null&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;undefined와 null은 한 챕터에서 설명을 하려 한다. 두 개를 헷갈려서 사용하는 개발자들이 의외로 많기 때문이다. 특히 C++이나 JAVA를 다루다 자바스크립트를 처음 접하는 사람들은 이 두 개의 차이를 확실하게 알아 둘 필요가 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;undefined는 값이 정의되지 않은 상태다. 변수가 선언된 뒤 어떠한 값도 할당받지 못한 상태라 할 수 있다. undefined 타입은 값 또한 undefined이다. 즉 undefined는 타입과 값을 동시에 나타내는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;null은 개발자가 명시적으로 값이 없다는 것을 나타내는 것이다. 여기서 주의할 점은 null의 typeof 값은 object라는 점이다. 따라서 자바스크립트에서 null 값을 확인할 때 일치 연산자('===')를 사용해 값을 직접 비교해야 한다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;아래 예제에서 아무 값도 할당하지 않은 변수가 undefined 타입을 가지는 것을 확인할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre class=&quot;brush: javascript&quot;&gt;var undefinedVal
var nullVal = null

console.log(undefinedVal, typeof undefinedVal) // undefined 'undefined'
console.log(nullVal, typeof nullVal) // null 'object'

console.log(typeof nullVal == null) // false
console.log(nullVal == null) // true

&amp;gt; undefined 'undefined'
&amp;gt; null 'object'
&amp;gt; false
&amp;gt; true&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>Javascript</category>
<category>object</category>
<category>Symbol</category>
<category>undefined</category>
<category>객체</category>
<category>데이터 타입</category>
<category>문자열</category>
<category>숫자</category>
<category>자바스크립트</category>
<author>kesakiyo</author>
<guid>https://kesakiyo.tistory.com/30</guid>
<comments>https://kesakiyo.tistory.com/30#entry30comment</comments>
<pubDate>Fri, 20 Jan 2017 22:58:36 +0900</pubDate>
</item>
<item>
<title>실수 없는 프로그래밍을 위한 몇 가지 방법</title>
<link>https://kesakiyo.tistory.com/29</link>
<description>&lt;p&gt;프로그래밍 대회에서 좋은 성적을 올리기 위한 방법에는 어떤 것이 있을까요? 아마 대부분의 사람들이 다양한 알고리즘을 알고 있는 것이라 대답할 것입니다. 물론 문제를 풀기 위해서 여러 알고리즘을 아는 것은 매우 중요합니다. 하지만 단순히 알고리즘만&amp;nbsp;많이 알고 있다고 해서 프로그래밍 대회에서 좋은 성적을 거둘 수 있는 것은 아닙니다. 그렇다면 어떤 것이 가장 중요할까요?&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;혼자서 공부를 할 때는 제한시간이 없기 때문에 여유로운 마음으로 코딩을 할 수 있습니다. 하지만 프로그래밍 대회에서는 그렇지 않습니다. 제한시간이 있고 다른 사람들이 문제를 얼마나 풀었는지 볼 수 있습니다. 또한 팀원들이 같이 있을 경우 내가 잡은 문제를 꼭 풀어야 한다는 압박감을 받을 수 있습니다. 이러한 상황 속에서 여유로운 마음으로 코딩을 하기 쉽지 않습니다. 이때 평상시와 같이 코딩을 할 수 있게 도와주는 것은 철저하게 훈련된 &lt;b&gt;&lt;i&gt;&lt;u&gt;코딩 능력&lt;/u&gt;&lt;/i&gt;&lt;/b&gt;입니다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;여기서 말하는 코딩 능력은 구현 능력과는 다릅니다. 구현 능력은 내가 생각한 것을 코드로 옮기는 능력이고 코딩 능력은 정확하고 읽기 쉬운 코드를 작성하는 능력입니다. 이 글에서는 코딩 능력을 높이기 위한 몇 가지 주제를 다뤄보려고 합니다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p id=&quot;bookmark&quot;&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;책갈피&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#indentation&quot;&gt;1. 들여쓰기의 중요성&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#convention&quot;&gt;2. 자신만의 코딩 컨벤션&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#macro&quot;&gt;3. 매크로 사용을 지양&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#modularization&quot;&gt;4. 코드의 재활용&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#naming&quot;&gt;&lt;b&gt;5. 의미있는 작명&lt;/b&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#stl&quot;&gt;6. STL과 c++11을 활용&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;indentation&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;들여쓰기의 중요성&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;코딩을 할 때 들여쓰기는&amp;nbsp;생명과도 같습니다. 혹자는 당연히 지켜야 하는 것 아니냐 얘기할 수 있지만&amp;nbsp;생각보다 많은 사람들이 들여쓰기를 지키지 않고 코딩을 합니다. 아래 코드는 들여쓰기를 지키지 않은 코드입니다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre class=&quot;brush:cpp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;algorithm&amp;gt;

int main() {
  int n, A[1010];
  scanf(&quot;%d&quot;, &amp;amp;n);
  
  for (int i = 0 ; i &amp;lt; n ; ++i) {
  scanf(&quot;%d&quot;, &amp;amp;A[i]);
  }
  
  for (int i = 0 ; i &amp;lt; n ; ++i) {
  for (int j = 0 ; j &amp;lt; i ; ++j) {
    if (A[j] &amp;gt; A[i]) {
    std::swap(A[i], A[j]);
  }
  }
  }
}&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;단순한 코드임에도 불구하고 한눈에 알아보기 힘듭니다. 20줄 남짓한 코드조차 알아보기 힘든데 코드가 길어진다면 어떻게 될까요? 그 누구도 읽기 싫은 코드가 될 것이 자명해 보입니다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;물론 미관상의 이유만으로 들여쓰기를 지키라는 것이 아닙니다. Python, Ruby 같은 언어와 달리 C, C++, Java는 중괄호로 Block Scope가 나눠집니다. 때문에&amp;nbsp;Block 안에서만 유효한 변수 또는 로직이 있을 수 있습니다. 만약 들여쓰기를 지키지 않는다면 한 Block의 시작과 끝을 한눈에 알 수 없어&amp;nbsp;자신이 선언한 변수나 로직이 어디서부터 어디까지 영향을 미치는지 다시 확인을 해야 하는 경우가 발생할 수 있습니다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;1분 1초도 아까운 프로그래밍 대회에서 들여쓰기를 지키는 것만으로 디버깅 시간을 줄일 수 있다면 당연히 들여쓰기를 지켜야 할 것입니다. 거의 모든 에디터들이 자동 들여쓰기를 지원해 주니 이를 활용하면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;위에 들여쓰기가&amp;nbsp;엉망인 코드는 아래와 같이 바꿔야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre class=&quot;brush:cpp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;algorithm&amp;gt;

int main() {
  int n, A[1010];
  scanf(&quot;%d&quot;, &amp;amp;n);
  
  for (int i = 0 ; i &amp;lt; n ; ++i) {
    scanf(&quot;%d&quot;, &amp;amp;A[i]);
  }
  
  for (int i = 0 ; i &amp;lt; n ; ++i) {
    for (int j = 0 ; j &amp;lt; i ; ++j) {
      if (A[j] &amp;gt; A[i]) {
        std::swap(A[i], A[j]);
      }
    }
  }
}&lt;/pre&gt;

&lt;p id=&quot;convention&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;&amp;nbsp;자신만의 코딩 컨벤션&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;프로그래밍 대회를 준비하면 수많은 종류의 알고리즘을 공부하고 반복적으로 작성하게 됩니다. 한 알고리즘을 구현할 때 여러 가지 방법을 시도해 봅니다.&amp;nbsp;\(while\)과 \(do-while\)을 돌아가며 써보기도 하고, 반복문과 재귀를 번갈아 가며 써보기도 합니다. 이는 처음 알고리즘을 배우고 자신에게 최적화할 때 도움이 됩니다. 하지만 이런 방법을 계속해서 사용을 한다면 잦은 실수의 원인이 되기도 합니다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;새로운 방법으로 작성한 코드가 제대로 동작하는지 확인을 하기란 쉬운 일이 아닙니다. 물론 이렇게 바꾼 코드가 기대하던 대로 동작하고 성능이 향상될 수도 있지만 여러 변수가 존재하는 프로그래밍 대회에서 이런 여유를 부리다가는 좋지 않은 결과를 받기 십상입니다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;어떻게 하면 효율적이고 읽기 쉬운 코드를 짤 수 있는지 계속해서 생각을 할 필요는 있습니다. 하지만 이것을 굳이 시간에 쫓기는 프로그래밍 대회 때 할 필요는 없습니다. 자주 사용하는 알고리즘들은 여러 번 반복해서 작성해보고 자신만의 코딩 컨벤션을 확립할 필요가 있습니다. 그래야 문제를 풀 때 어떻게 구현을 할지 생각을 하지 않고 오로지 어떻게 풀지에 집중을 할 수 있습니다.&lt;/p&gt;

&lt;p id=&quot;macro&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;무분별한 매크로 사용을 지양&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;C에서는 어떤 문자열을 원하는 문자열로 치환시켜주는 매크로가 존재합니다. 많은 사람들이 \(min, max, square\) 등의 함수들을 매크로 함수로 정의해 사용하곤 합니다. 하지만 매크로 함수의 정확한 이해 없이 사용하다간 끝나지 않는 디버깅의 늪에 빠질 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;아래는 매크로 함수에 대한 예시입니다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre class=&quot;brush:cpp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#define max(a, b) ((a) &amp;gt; (b) ? (a) : (b))

int main() {
  int a = 10;
  int b = 20;
  
  int mmax1 = max(a, b);
  int mmax2 = max(a, b++);
  
  printf(&quot;%d %d\n&quot;, mmax1, mmax2);
}&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;어떤 의도를 가지고 작성된 코드인지는 쉽게 알 수 있습니다. 그렇다면 어떤 값이 출력될까요? [20 20]이 출력된다고 생각하시는 분이 많을 거라 생각됩니다. 하지만 코드를 직접 실행해 본다면 [20 21]이 출력되는 것을 볼 수 있습니다. 만약 이러한 일이 프로그래밍 대회 때 발생한다면 어떻게 될까요. 매크로 함수를&amp;nbsp;잘못 사용했다는 생각을 못하고 알고리즘을 계속해서 확인할 확률이 높습니다. 생각만 해도 정말 끔찍한 일입니다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;그럼 왜 이러한 일이 일어나는지 간단하게 알아봅시다. C에서 제공하는 매크로는 컴파일 시간 전에 이뤄지는 텍스트의 치환 작업입니다. 즉 위 코드는 다음 코드와 같이 컴파일이 이뤄집니다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre class=&quot;brush:cpp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
  int a = 10;
  int b = 20;
  
  int mmax1 = ((a) &amp;gt; (b) ? (a) : (b));
  int mmax2 = ((a) &amp;gt; (b++) ? (a) : (b++));
  
  printf(&quot;%d %d\n&quot;, mmax1, mmax2);
}&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;삼항 연산자 안에 후치 연산이 두 번이나 들어가 있는 형태가 돼버립니다. 심지어 \(b\)를 21로 만들려고 했음에도 최종적으로 22라는 값을 가집니다.&amp;nbsp;이렇듯 조금 복잡한 로직을 매크로 함수에 녹이게 된다면 직접 써보기 전까지 어떠한 일이 일어나는지 추적을 하기가 쉽지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;매크로 함수를 정확하게 이해하고 사용한다면 이런 일이 발생하지 않겠지만 이보다 더 최선은 매크로 함수를 아예 사용하지 않는 것입니다. C++에서는 \(inline\) 함수가 있으므로 매크로 함수 대신 이를 사용하면 위와 같은 일을 원천봉쇄할 수 있습니다. 아래는 \(inline\) 함수를 사용한 예시입니다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre class=&quot;brush:cpp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

inline int max(int a, int b) {
  return a &amp;gt; b ? a : b;
}

int main() {
  int a = 10;
  int b = 20;
  
  int mmax1 = max(a, b);
  int mmax2 = max(a, b++);
  
  printf(&quot;%d %d\n&quot;, mmax1, mmax2);
}&lt;/pre&gt;

&lt;p id=&quot;modularization&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;코드의 재활용&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;코딩을 하다 보면 반복해서 나오는 로직이 있습니다. 이때 반복되는 로직을 어떻게 처리하냐에 따라 코딩의 정확성, 속도가 달라집니다. 반복되는 로직이 나오면 이를 모듈화하는 것이 일반적입니다. 프로그래밍 대회에서 코딩을 한다고 이는 달라지지 않습니다. 하지만 시간에 쫓기는 프로그래밍 대회에서 반복되는 로직을 모듈화하는데 시간을 할애하기 쉽지 않습니다. 그럼에도 불구하고 코드를 재활용해야 하는 이유는 무엇일까요?&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;첫째, 코드를 한층 더 읽기 쉽게 만들어 줍니다. 가독성이 높은 코드가 눈에 더 잘 들어오고 다른 사람들을 이해시키기 훨씬 쉽습니다. 또한 계속해서 간결한 코드를 보게 된다면 간결한 코드를 짜는데 익숙해집니다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;둘째, 디버깅 시간이 확연히 줄어듭니다. 만약 한 로직이 전체 코드에서 다섯 번 사용됐다고 가정을 합시다. 그런데 그 로직이 잘못됐다면 다섯 군데를 수정해야 합니다. 하지만 이를 모듈화했다면 단 한 군데만 수정하는 것으로 디버깅을 끝낼 수 있습니다. 또한 오타가 나기 쉬운 로직 같은 경우 한, 두 군데만 잘못될 수 있습니다. 이런 경우 모듈화를 하지 않았다면 디버깅 시간이 많게는 열 배 이상 차이 날 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;아래는 어떠한 동작을 하는 코드입니다. 어떤 일을 하는지 읽어보며 생각해 봅시다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre class=&quot;brush:cpp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int t, n, m, x[110], y[110];

int main() {
  scanf(&quot;%d%d&quot;, &amp;amp;n, &amp;amp;m);
  for (int i = 1 ; i &amp;lt; n ; ++i) {
    scanf(&quot;%d%d&quot;, &amp;amp;x[i], &amp;amp;y[i]);
  }
  for (int i = n ; i &amp;lt; n + m ; ++i) {
    scanf(&quot;%d%d&quot;, &amp;amp;x[i], &amp;amp;y[i]);
  }
  
  scanf(&quot;%d&quot;, &amp;amp;t);
  while (t--) {
    int q, from , to, ans;
    
    scanf(&quot;%d%d%d&quot;, &amp;amp;q, &amp;amp;from, &amp;amp;to);
    if (q == 1) {
      ans = (x[from] - x[to]) * (x[from] - x[to]) + (y[from] - y[to]) * (y[from] - y[to]);
    } else if (q == 2) {
      ans = (x[from + n] - x[to + n]) * (x[from + n] - x[to + n]) + (y[from + n] - y[to + n]) * (y[from + n] - y[to + n]);
    } else if (q == 3) {
      ans = (x[from] - x[to + n]) * (x[from] - x[to + n]) + (y[from] - y[to + n]) * (y[from] - y[to + n]);
    }
    
    printf(&quot;%d\n&quot;, ans);
  }
}&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;먼저 \(A\) 그룹, \(B\) 그룹의&amp;nbsp;좌표를 입력받고 쿼리에 따라 \(A\) 그룹 간의 거리, \(B\) 그룹 간의 거리, \(A\) 그룹과 \(B\) 그룹간의 거리를 구해서 출력하는 코드입니다. 거리를 구하는 로직이 세 번이나 반복되는 것을 볼 수 있습니다. 또한 쿼리를 처리하는 부분이 어떤 일을 하는지 설명을 듣기전에는 이해하기 힘듭니다. 만약 이 부분을 모듈화 하면 어떻게 될까요?&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre class=&quot;brush:cpp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int t, n, m, x[110], y[110];

int dist(int from, int to) {
  return (x[from] - x[to]) * (x[from] - x[to]) + (y[from] - y[to]) * (y[from] - y[to]);
}

int main() {
  scanf(&quot;%d%d&quot;, &amp;amp;n, &amp;amp;m);
  for (int i = 1 ; i &amp;lt; n ; ++i) {
    scanf(&quot;%d%d&quot;, &amp;amp;x[i], &amp;amp;y[i]);
  }
  for (int i = n ; i &amp;lt; n + m ; ++i) {
    scanf(&quot;%d%d&quot;, &amp;amp;x[i], &amp;amp;y[i]);
  }
  
  scanf(&quot;%d&quot;, &amp;amp;t);
  while (t--) {
    int q, from , to, ans;
    
    scanf(&quot;%d%d%d&quot;, &amp;amp;q, &amp;amp;from, &amp;amp;to);
    if (q == 1) {
      ans = dist(from, to);
    } else if (q == 2) {
      ans = dist(from + n, to + n);
    } else if (q == 3) {
      ans = dist(from, to + n);
    }
    
    printf(&quot;%d\n&quot;, ans);
  }
}&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;쿼리를 처리하는 부분이 훨씬 간결해진 것을 볼 수 있습니다. 또한 모듈화&amp;nbsp;한 부분이 어떤 일을 하는지 한눈에 볼 수 있게 됐습니다. 이렇듯 코드를 재활용하는 것은 잃는 것보다 얻는 것이 훨씬 더 많으므로 이에 익숙해질 필요가 있습니다.&lt;/p&gt;

&lt;p id=&quot;naming&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;의미있는 작명&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;우스갯소리로 프로그래머들이 코딩을 할 때 변수 및 함수 이름을 짓는데 가장 많은 시간이 소요된다고 합니다. 하지만 이를 단순 우스갯소리로 치부하면 안 됩니다. 그만큼 변수 및 함수의 작명이 중요하기 때문입니다. 하지만 프로그래밍 대회에서 사용되는 코드들을 보면 작명에 신경 쓰지 않은 경우가 많습니다. 프로그래밍 대회를 준비하는 사람이라면 아래와 같은 작명을 많이 봤을 겁니다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;pre class=&quot;brush:cpp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int A[110], B[110], C[110], a, aa, b, bb;

bool flag(...) {
  // ...
}

int main() {
  /*
   main function
   */
}&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이런 작명은 코딩을 한 본인은 알아볼 수 있을지 모르겠지만 다른 사람 혹은 같은 팀원이 보기에는 최악의 코드입니다. 또한 디버깅을 할 때 변수 혹은 함수가 어떤 역할을 하는지 계속해서 생각을 해야 하기 때문에 시간이 더 오래 걸립니다. 물론 작명을 하는데 엄청난 시간을 할애하라는 것이 아닙니다. 작성자 본인 혹은 같은 팀원이 봤을 때 어떤 역할을 하는지 대략적으로 알 수 있다면 그것으로 충분합니다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;프로그래밍 대회에서 많이 사용하는 알고리즘들은 함수 및 변수들을 의미 있게 작명한 다음 꾸준히 사용하는 것도 좋은 방법입니다.&lt;/p&gt;

&lt;p id=&quot;stl&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;STL과 C++11의 활용&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;알고리즘 공부를 처음 시작하는 사람들이 흔히 하는 생각은 &lt;strike&gt;&lt;i&gt;&quot;처음부터 끝까지 가내수공업&quot;&lt;/i&gt;&lt;/strike&gt; 입니다. 벡터, 큐, 균형잡힌 이진트리 등 많은 자료구조들을 직접 구현하고 사용합니다. 물론 한 번쯤은 직접 구현해보는 것은 좋은 방법입니다. 하지만 시간제한이 있는 대회에서 이들을 직접 구현해서 쓴다는 것은 시간 낭비입니다.&lt;/p&gt;
&lt;p&gt;(간혹가다 수행 시간에 병적으로 집착한다거나 컴파일 최적화를 안 해주는 대회에서는 어쩔 수 없이 직접 구현해야 할 때도 있긴 하지만 대부분의 경우는 아닙니다.)&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;C++에서는 표준 템플릿 라이브러리(이하 STL)를 제공합니다. 벡터, 큐, 맵, 셋 등 여러 자료구조들을 헤더 파일을 하나 추가하는 것만으로 사용할 수 있습니다. 이 STL들은 수많은 사람들이 사용하고 수없이 많이 검증됐기 때문에 믿고 사용할 수 있습니다. 또한 누가 사용하던 인터페이스가 똑같기 때문에 다른 팀원이 봤을 때 코드를 이해하기 한결 수월합니다. 그렇기 때문에 STL 사용방법을 익히는 것은 필수적입니다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;다음은 C++11에 대한 내용입니다.(C++11에 대해서 자세한 내용은 이 글에서는 다루지 않습니다.) C++11을 활용하면 익명 함수를 사용해 코드의 가독성을&amp;nbsp;높일 수 있을 뿐더러 &amp;nbsp;\(for-each\)구문을 사용해 배열의 범위 밖에 접근하는 것을 방지할 수 있습니다. 따라서 C++11의 문법을 익히고 사용한다면 코딩을 할 때 실수할 확률을 줄일 수 있습니다.&lt;/p&gt;</description>
<category>잡다한 이야기</category>
<category>실수 없는 프로그래밍</category>
<category>코딩 능력</category>
<author>kesakiyo</author>
<guid>https://kesakiyo.tistory.com/29</guid>
<comments>https://kesakiyo.tistory.com/29#entry29comment</comments>
<pubDate>Sat, 31 Dec 2016 02:51:16 +0900</pubDate>
</item>
<item>
<title>KOI 2016 전국대회 초등부</title>
<link>https://kesakiyo.tistory.com/28</link>
<description>&lt;p&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 14pt; color: rgb(116, 116, 116);&quot;&gt;1. 방 배정&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/13300&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://www.acmicpc.net/problem/13300&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;학생들을 학년별, 성별로 한 방에 배정하려고 하는데 필요한 최소 방의 개수를 구하는 문제다. 문제에서 요구하는 대로 학년별, 성별로 인원을 센 다음에 각각에 대해 최소로 필요한 방의 개수를 센 뒤 더해주면 된다. 이는 나눗셈과 나머지 연산으로 쉽게 구할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more28_0&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '28_0','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content28_0&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;brush:cpp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int n, k, s, y, C[7][2];

int main() {
  scanf(&quot;%d%d&quot;, &amp;amp;n, &amp;amp;k);
  while (n--) {
    scanf(&quot;%d%d&quot;, &amp;amp;s, &amp;amp;y);
    ++C[y][s];
  }
  
  int ans = 0;
  for (int i = 1 ; i &amp;lt;= 6 ; ++i) {
    for (int j = 0 ; j &amp;lt; 2 ; ++j) {
      int cnt = C[i][j];
      ans += cnt / k + (cnt % k ? 1 : 0);
    }
  }
  printf(&quot;%d\n&quot;, ans);
}&lt;/pre&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 14pt; color: rgb(116, 116, 116);&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 14pt; color: rgb(116, 116, 116);&quot;&gt;2. 타일 장식물&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/13301&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://www.acmicpc.net/problem/13301&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:240px;text-align: center;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/23781D46583C3BD00F&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Screen Shot 2016-11-28 at 11.13.32 PM.png&quot; height=&quot;375&quot; style=&quot;text-align: center;&quot; width=&quot;240&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;위 그림과 같은 규칙으로 타일을 붙여 나갈 때 \(n\)번 째 타일을 붙이고 난 뒤 생긴 직사각형의 둘레를 출력하는 문제다. 문제를 잘 보면 \(n\)번 째 타일의 크기는 점화식&amp;nbsp;\(dp[n]=dp[n-1]+dp[n-2]\)으로 정의되는 것을&amp;nbsp;알 수 있다. 이렇게 모든 순서의 타일 크기를 알아내면 &amp;nbsp;전체 직사각형의 둘레를 쉽게 구할수 있다. 답을 구하는 식은 아래와 같다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;\(ans = dp[n] \times&amp;nbsp;4 + dp[n-1] \times&amp;nbsp;2\)&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;왜 그런지는 잘 생각해보면 알 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more28_1&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '28_1','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content28_1&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;brush:cpp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

typedef long long ll;

int n;
ll dp[81];

int main() {
  scanf(&quot;%d&quot;, &amp;amp;n);
  
  dp[1] = dp[2] = 1;
  for (int i = 3 ; i &amp;lt;= n ; ++i) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  ll ans = dp[n] * 4LL + dp[n - 1] * 2LL;
  printf(&quot;%lld\n&quot;, ans);
}&lt;/pre&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;(리조트, 장애물 경기 업로드 예정)&lt;/p&gt;</description>
<category>BOJ</category>
<category>2016 koi</category>
<category>brute force</category>
<category>DP</category>
<category>초등부</category>
<author>kesakiyo</author>
<guid>https://kesakiyo.tistory.com/28</guid>
<comments>https://kesakiyo.tistory.com/28#entry28comment</comments>
<pubDate>Mon, 28 Nov 2016 23:09:32 +0900</pubDate>
</item>
<item>
<title>5626 - 제단</title>
<link>https://kesakiyo.tistory.com/27</link>
<description>&lt;p&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 14pt; color: rgb(116, 116, 116);&quot;&gt;문제 링크&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/5626&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://www.acmicpc.net/problem/5626&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 14pt; color: rgb(116, 116, 116);&quot;&gt;문제 요약&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;현재 제단의 상태가 주어진다. 도둑이 훔쳐간 부분은 -1이고 남아있는 부분은 정수로 표현이 되어있다. &amp;nbsp;이 때 가능한 초기 제단의 경우의 수를 구하는 문제다. 문제에서 초기 제단을 만드는 방법은 주어진다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;b style=&quot;font-size: 16px;&quot;&gt;&lt;span style=&quot;font-size: 14pt; color: rgb(116, 116, 116);&quot;&gt;문제 풀이&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;모든 열의 초기값은 0이다. 이 때 한가지 연산을 할 수 있다. 같은 높이를 가지는 연속하는 열들을 선택한다. 그리고 선택한 연속된 열 중 처음 열과 가장 끝 열을 제외한 모든 열의 높이를 1씩 높인다. 이 연산을 사용해서 제단을 만들어 나갈 수 있다. 이 연산을 잘 생각해 본다면 두가지&amp;nbsp;통찰을 얻을 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;1. 첫 번째 제단과 마지막 열의 높이는 0이다.&lt;/p&gt;
&lt;p&gt;2. 인접한 두 열의&amp;nbsp;높이차는 최대 1이다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 두가지 통찰을 이용해 우리는 \(dynamic\ programming\)을 설계할 수 있다. \(dp\)식은 아래와 같다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;\(dp[i][j]\) : \(i\)번 째 열의&amp;nbsp;높이가 \(j\)일 경우의 수(첫 번째 열부터 순서대로 높이를 결정해 나갈 때)&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;그렇다면 \(dp\)식은 어떻게 계산이 될까? \(dp[i][j]\)는 위에서 언급한 두 번째 통찰에 의해 쉽게 계산이 가능하다. 인접한 두 열의 높이차는 최대 1까지 가능하으로 \(dp[i][j]\)는 \(dp[i - 1][j - 1],\ dp[i - 1][j],\ dp[i - 1][j + 1]\)의 합이 된다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;한가지 유의할 점은 \(i\)의 값에 따라 \(j\)가 결정이 될때도 있고 안될때도 있다는 것이다. \(A[i]\)의 값이 -1이라면 \(j\)는 1부터 \(n\)까지 가능할 것이다. 하지만 \(A[i]\)값이 음이 아닌 정수라면 \(j\)는 A[i]를 제외 하고는 전부 0이 되어야 한다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;자 이제 우리는 완벽하게 답이 나오는 \(dp\)식을 설계했지만 아쉽게도 메모리 제한으로 인해 \(ML\)을 받는다. 이러한 점을 개선할 수 있을까? \(dp\)식을 개선해 본다면 \(i\)번째 테이블을 계산할 때 \(i-1\)번째 테이블만 필요하다는 것을 알 수 있다. 이 점을 이용해 슬라이딩 윈도우를 적용한다면 최종적으로 정답을 받을 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;소스 코드&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more27_0&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '27_0','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content27_0&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;brush:cpp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

typedef long long ll;

const ll mod = 1000000007;
int n, A[10010];
ll dp[2][10010];

int main() {
  scanf(&quot;%d&quot;, &amp;amp;n);
  for (int i = 0 ; i &amp;lt; n ; ++i) {
    scanf(&quot;%d&quot;, &amp;amp;A[i]);
    if (A[i] != -1) {
      ++A[i];
    }
  }
  
  int t = 1;
  dp[0][1] = (A[0] == -1 || A[0] == 1) ? 1 : 0;
  for (int i = 1 ; i &amp;lt; n ; ++i, t = 1 - t) {
    memset(dp[t], 0, sizeof(dp[t]));
    if (A[i] == -1) {
      for (int j = 1 ; j &amp;lt;= n ; ++j) {
        dp[t][j] = (dp[1 - t][j - 1] + dp[1 - t][j] + dp[1 - t][j + 1]) % mod;
      }
    } else {
      dp[t][A[i]] = (dp[1 - t][A[i] - 1] + dp[1 - t][A[i]] + dp[1 - t][A[i] + 1]) % mod;
    }
  }
    
  printf(&quot;%lld\n&quot;, dp[1 - t][1]);
}&lt;/pre&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>BOJ</category>
<category>DP</category>
<category>sliding window</category>
<author>kesakiyo</author>
<guid>https://kesakiyo.tistory.com/27</guid>
<comments>https://kesakiyo.tistory.com/27#entry27comment</comments>
<pubDate>Sun, 27 Nov 2016 20:32:35 +0900</pubDate>
</item>
<item>
<title>1637 - 날카로운 눈</title>
<link>https://kesakiyo.tistory.com/26</link>
<description>&lt;p&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 14pt; color: rgb(116, 116, 116);&quot;&gt;문제 링크&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1637&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://www.acmicpc.net/problem/1637&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 14pt; color: rgb(116, 116, 116);&quot;&gt;문제 요약&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;정수가 여러개 모여있는 정수더미가 있다. 이 때 정수더미 안에서 홀수개 들어있는 특정 정수를 찾는 문제다. 홀수개 들어있는 정수의 수는 최대 한개이며 없을수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;b style=&quot;font-size: 16px;&quot;&gt;&lt;span style=&quot;font-size: 14pt; color: rgb(116, 116, 116);&quot;&gt;문제 풀이&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 문제는 정수가 직접 주어지는게 아니라 정수더미 안에 들어있는 수들의 규칙이 주어지고 이를 통해 홀수개 들어있는 정수를 찾아야 하기 때문에 단순 시뮬레이션으로는 풀수가 없다. 그렇다면 어떻게 접근해야 할까?&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;우선 예제의 수들을 한번 직접 계산해보자.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:580px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/2679D54D5835BACD0F&quot; filemime=&quot;image/jpeg&quot; filename=&quot;eye1.png&quot; height=&quot;62&quot; width=&quot;580&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;직접 계산해 본다면 숫자 4가 3개 들어있어서 답이 됨을 알 수 있다. 이것만으로 일정한 규칙을 찾을수가 없다. 하지만 이들 수의 누적합을 계산해 본다면 특정 규칙을 찾을 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:580px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/255FB6495835BC3D1E&quot; filemime=&quot;image/jpeg&quot; filename=&quot;eye2.png&quot; height=&quot;91&quot; width=&quot;580&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;위 표를 잘 살펴보면 숫자 4이후로 누적합은 홀수가 되는것을 알 수 있다. 홀수개 존재하는 정수는 최대 하나니까 한번 누적합이 홀수가 된 이후는 다시 짝수로 바뀌는 일은 없다. 이러한 특징을 이용해 \(binary\ search\)를 이용해 풀 수 있다.&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 문제는 \(func(x)\)라는 함수를 정의해서 쉽게 풀 수 있다. 함수의 의미는 &lt;b&gt;\(x\)보다 작거나 같은 수들 중 정수더미에 들어있는 수의 개수&lt;/b&gt;라고 정의한다. 이 함수는 마지막에 답을 출력할 때도 도움이 된다. 만약 홀수개 들어있는 정수를 &amp;nbsp;\(ans\)라고 했을 때 \(ans\)는 정수더미에 몇개 존재하는지 출력을 해야 한다. 이는 \(func(ans)-func(ans-1)\)로 쉽게 계산할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;소스 코드&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more26_0&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '26_0','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content26_0&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;brush:cpp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

typedef long long ll;

const ll INF = 1LL &amp;lt;&amp;lt; 32;
const int MAX = 20010;
int n;
ll A[MAX], B[MAX], C[MAX];

ll func(ll mid) {
  ll ret = 0;
  for (int i = 0 ; i &amp;lt; n ; ++i) {
    if (mid &amp;gt;= A[i]) {
      ret += (min(mid, C[i]) - A[i]) / B[i] + 1;
    }
  }
  return ret;
}

int main() {
  scanf(&quot;%d&quot;, &amp;amp;n);
  for (int i = 0 ; i &amp;lt; n ; ++i) {
    scanf(&quot;%lld%lld%lld&quot;, &amp;amp;A[i], &amp;amp;C[i], &amp;amp;B[i]);
  }
  
  ll lo = 0, hi = INF;
  while (lo &amp;lt;  hi) {
    ll mid = (lo + hi) &amp;gt;&amp;gt; 1;
    if (func(mid) &amp;amp; 1) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  
  if (lo == INF) {
    puts(&quot;NOTHING&quot;);
  } else {
    printf(&quot;%lld %lld\n&quot;, lo, func(lo) - func(lo - 1));
  }
}&lt;/pre&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>BOJ</category>
<category>Binary Search</category>
<author>kesakiyo</author>
<guid>https://kesakiyo.tistory.com/26</guid>
<comments>https://kesakiyo.tistory.com/26#entry26comment</comments>
<pubDate>Thu, 24 Nov 2016 00:41:51 +0900</pubDate>
</item>
<item>
<title>MO's algorithm</title>
<link>https://kesakiyo.tistory.com/25</link>
<description>&lt;p&gt;MO's algorithm은 온라인으로 풀기 힘든 쿼리 문제를 오프라인으로 쉽게 풀 수 있게 해주는 알고리즘이다.&amp;nbsp;MO's algorithm은 쿼리를 정렬한 뒤 정렬된 순서대로 처리를 한다. 이론은 이게 끝이다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이론만 들어서는 아마 문제에 어떻게 적용해야 할 지 감이 안올것이다. 그럼&amp;nbsp;연습문제를 풀면서 MO's algorithm을 익혀보도록 하자. 연습문제는&amp;nbsp;&lt;a href=&quot;https://www.acmicpc.net/problem/13547&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://www.acmicpc.net/problem/13547&lt;/a&gt;에서 풀 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;구간에 존재하는 서로 다른 수의 개수&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;연습 문제는 아래와 같다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;자연수로 이루어진 \(A_1,\ A_2,\ A_3,\ ...\ ,\ A_{N-1},\ A_{N}\)시퀀스가 있다. 이 때 다음 쿼리를 처리해야 한다.&lt;/p&gt;
&lt;p&gt;1. \(x,\ y\ (1 \le x \le y \le N)\)가 주어졌을 때 \([A_x,\ A_y]\)에 존재하는 수들 중 서로 다른 수의 개수를 출력한다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;문제 자체는 상당히 단순하다. 문제를 꼬아놓은 것도 없으며 요구하는것도 명확하다. 이 문제에 어떻게 MO's algorithm을 적용할 수 있을까?&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;완전 탐색&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;우선 가장 쉽게 짤 수 있는 완전 탐색코드를 살펴 보자. 쿼리로 들어온 구간을 모두 살펴보면서 flag배열을 하나 둬 중복되는 것을 제외하고 수를 카운팅한다.&amp;nbsp;이 코드의 시간복잡도는 어떻게 될까? 쿼리의 개수가 \(Q\)개라 한다면 총 \(O(QN)\)의 시간복잡도를 가진다. \(Q\)나 \(N\)이 크다면 시간초과를 받기 딱 좋을것이다.&lt;/p&gt;

&lt;pre class=&quot;brush:cpp&quot;&gt;// brute force function
int query(int lo, int hi) {
  int ret = 0;
  
  // A[i]가 체크가 안됐다면 체크를 해주고 count를 1증가 시킨다
  for (int i = lo ; i &amp;lt;= hi ; ++i) {
    if (!isExist[A[i]]) {
      ++ret;
      isExist[A[i]] = true;
    }
  }
  
  // 다음 쿼리를 위해 true로 체크되어 있는 곳을 false로 초기화 시켜준다
  for (int i = lo ; i &amp;lt;= hi ; ++i) {
    isExist[A[i]] = false;
  }
  
  return ret;
}&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;이전 쿼리를 재활용&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;우리는 완전 탐색보다 조금 더 똑똑하게 코드를 짤 수 있다. 잘 생각해 본다면 이전 쿼리의 내용을 일부 재활용 할 수 있다는 것을 알 수 있다. 만약 \(Q_{i - 1}\)과 \(Q_i\)의 구간에 겹치는 부분이 있다고 생각을 해 보자. 그림으로 표현하자면 아래와 같다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:400px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/26015B405832908B28&quot; filemime=&quot;image/jpeg&quot; filename=&quot;mos1.png&quot; height=&quot;130&quot; width=&quot;400&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;시퀀스의 원소들을 총 네가지로 분류할 수 있다.&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;1. 회색 원소들 : \(Q_{i - 1}\)과 \(Q_i\) 어디에도 속하지 않는 원소들&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;2. 파란색 원소들 : \(Q_{i - 1}\)과 \(Q_i\) 두 곳에 모두 속하는 원소들&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;3. 주황색 원소들 : \(Q_{i - 1}\)에만 속하는 원소들&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;4. 초록색 원소들 : \(Q_i\)에만 속하는 원소들&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;\(Q_{i - 1}\)에서 \(Q_i\)로 넘어갈 때 1번에 속하는 원소들은 신경쓰지 않아도 됨은 자명하다. 그렇다면 쿼리가 변경될 때 2, 3, 4번에 속하는 원소들만&amp;nbsp;적절하게 처리해 준다면 이전 쿼리의 내용을 일부 재활용 할 수 있을 것이다. 2번&amp;nbsp;원소들은&amp;nbsp;양쪽에 모두 속하므로 변경을 할 필요가 없다. 3번 원소들은 쿼리가 변경될 때 제거가 될 것이고 4번 원소들은 쿼리가 변경될 때 추가가 될 것이다. 이 때 이러한 추가, 제거 연산을 편하게 하기 위해 \(cnt\)배열을 도입한다. 아래 코드는 3번과 4번 연산을 어떻게 구현하는지 보여준다.&lt;/p&gt;

&lt;pre class=&quot;brush:cpp&quot;&gt;// add function
void add(int num) {
  // num이 새롭게 cnt배열에 들어올때만 카운팅 해준다
  if (++cnt[num] == 1) {
    ++distinctNumbers;
  }
}

// erase function
void erase(int num) {
  // num이 cnt배열에서 완전히 없어질때 카운팅 해준다
  if (--cnt[num] == 0) {
    --distinctNumbers;
  }
}&lt;/pre&gt;

&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;추가 함수에서는 \(cnt\)배열에 수가 처음 들어갈 때만 카운팅 해주고 제거 함수에서는 \(cnt\)배열에서 수가 완전히 없어졌을 때만 카운팅 해준다. 두 함수를 통해 이전 쿼리에서 다음 쿼리로 넘어갈 때 겹치는 부분을 재활용 할 수 있게 됐다. 재활용을 하는 코드는 어떻게 작성할 수 있을까? 이전 쿼리의 범위에서 다음 쿼리의 범위로 넘어갈 때 이터레이터를 조정해 가면서 적절하게 \(add\)함수와 \(erase\)함수를 호출해 주면 된다. 이 부분이 살짝 까다로울 수 있다. 이 글에서 쿼리의 범위를 나타내는 이터레이터는 \([lo,\ hi]\)로 표현된다.(양쪽이 전부 폐구간임을 주의해야 한다.)&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre class=&quot;brush:cpp&quot;&gt;  // Change the iterator from the previous query to the current query
  int lo = 0, hi = 0;
  
  // 시작 이터레이터는 [0, 0]이기 때문에 A[0]의 값을 cnt배열에 넣고 시작한다
  add(A[0]);
  
  // 모든 쿼리에 대한 답을 계산한다
  for (auto cur : query) {
    // 현재 위치는 [lo, hi]이고 다음 위치는 [nlo, nhi]이다
    int nlo = cur.lo, nhi = cur.hi;
    
    // lo를 nlo로 움직이는 부분
    // 1. lo가 nlo보다 왼쪽에 있는 경우 : 수를 제거할 필요가 있다
    for (int i = lo ; i &amp;lt; nlo ; ++i) {
      erase(A[i]);
    }

    // 2. lo가 nlo보다 오른쪽에 있는 경우 : 수를 더할 필요가 있다
    for (int i = lo - 1; i &amp;gt;= nlo ; --i) {
      add(A[i]);
    }
    
    // hi를 nhi로 움직이는 부분
    // 1. hi가 nhi보다 왼쪽에 있는 경우 : 수를 더할 필요가 있다
    for (int i = hi + 1 ; i &amp;lt;= nhi ; ++i) {
      add(A[i]);
    }

    // 2. hi가 nhi보다 오른쪽에 있는 경우 : 수를 제거할 필요가 있다
    for (int i = hi ; i &amp;gt; nhi ; --i) {
      erase(A[i]);
    }
    
    // 이터레이터가 현재 쿼리의 범위를 나타내도록 한다
    lo = nlo;
    hi = nhi;
    
    // 답을 저장할 배열에 실제 쿼리의 순서에 맞게 답을 기록해 준다
    ans[cur.idx] = distinctNumbers;
  }&lt;/pre&gt;

&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;이제 완벽하게 이전 쿼리를 재활용 할 수 있게 됐다. 그렇다면 이 코드의 시간복잡도는 어떻게 될까? 너무나 불행하게도 이코드 또한 \(O(QN)\)이다. 아주 최악의 경우에는 쿼리가 시퀀의 처음부분에 등장하고 끝 부분에 등장하고 다시 처음 부분에 등장하는 형태로 들어올 수 있기 때문이다. 그렇다면 우리는 이제까지 쓸모없는 코드를 짠 것일까?&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;쿼리를 정렬&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;놀랍게도 쿼리를 정렬함으로써 위 코드의 시간복잡도를 개선할 수 있다. 쿼리를 정렬할 때 &lt;a href=&quot;http://kesakiyo.tistory.com/22&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Sqrt decomposition&lt;/a&gt;의 개념이 들어간다. 우선 시퀀스의 인덱스들을 일정한 크기로 나눈 뒤 나눠진 부분을 한 묶음으로 생각한다. 통상적으로 나누는 크기는 \(\sqrt N\)을 사용한다. 쿼리의 끝 부분이 어떠한 묶음에 놓여져 있는지 계산한 뒤 쿼리를 쿼리가 속한 묶음의 번호 순으로 정렬을 해 준다. 이 부분은 글을 읽는것보다 코드로 보는것이 훨씬 명쾌할 것이다.&lt;/p&gt;&lt;pre class=&quot;brush:cpp&quot;&gt;  // sort queries
  int sz = sqrt(n);
  sort(query.begin(), query.end(), [&amp;amp;](const Query&amp;amp; l, const Query&amp;amp; r) {
    // 쿼리가 끝나는 부분이 어떠한 묶음에 속하는지 확인하다
    // 묶음의 인덱스가 더 작은곳에 속하는 쿼리를 먼저 처리한다
    // 만약 묶음의 인덱스가 같다면 쿼리의 시작지점이 작은것을 먼저 처리한다
    int lIdx = l.hi / sz;
    int rIdx = r.hi / sz;
    return lIdx == rIdx ? l.lo &amp;lt; r.lo : lIdx &amp;lt; rIdx;
  });&lt;/pre&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;MO's algorithm의 정당성&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이렇게 쿼리를 정렬하는 것만으로 \(O(QN)\)의 가망없는 시간복잡도가 개선될 수 있을까? 만약 된다면 왜 이러한 일이 벌어지는 것일까? 위에 코드를 한번 살펴보자. 정렬된 쿼리를 순회하면서 프로그램은 네개의 반복문을 실행한다. 처음 두개는&amp;nbsp;이터레이터 \(lo\)를 변경해주는 반복문이였고 그 다음 두개는 이터레이터 \(hi\)를 변경해주는 반복문이였다. 프로그램의 전체 수행시간은 모든 쿼리를 순회하면서 이 네 개의 반복문이 얼마나&amp;nbsp;실행이 됐는지에 따라 달라질 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;먼저 이터레이터 \(lo\)가 얼마나 움직일 지 생각을 해보자. 같은 묶음 내에서 \(lo\)는 오름차순으로 정렬이 되어 있다. 이 때 \(lo\)는 \(A_1\)부터 \(A_N\)까지 움직일 수 있다. 즉 한 묶음 내에서 최대 \(O(N)\)만큼 움직일 수 있다는 얘기다. 우리는 한 묶음의 크기를 \(\sqrt N\)개로 정의 했으니 전체 묶음의 개수는 \(\sqrt N\)개가 될 것이고 \(lo\)는 최악의 경우 \(O(N \sqrt N)\)만큼 움직일 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이제 이터레이터 \(hi\)를 생각해보자. 이터레이터 \(hi\)는 묶음의 인덱스 순으로 정렬이 되어있다. 한 쿼리에서 다음 쿼리로 갈 때 최악의 경우 묶음의 크기인 \(\sqrt N\)만큼 움직일 수 있다. 쿼리의 개수가 \(Q\)라고 했을 때 \(O(Q \sqrt N)\)만큼 움직일 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이터레이터 \(lo\)와 \(hi\)의 시간복잡도를 계산했으니 이 두개의 시간복잡도를 합쳐주면 전체 프로그램의 수행시간이 된다. 즉 MO's algorithm을 사용하면 \(O((N\ + \ Q) \sqrt N)\)으로 이 문제를 해결할 수 있다. \(logN\)과 같이 기가막히게 아름다운 시간복잡도는 아니지만 \(O(QN)\)이 걸리던 기존의 알고리즘에 비하면 충분히 아름다운 시간복잡도라 할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;마지막으로 이 문제의 전체 소스코드를 첨부한다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;전체 코드&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more25_0&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '25_0','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content25_0&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;brush:cpp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;math.h&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

struct Query {
  int lo, hi, idx;
  Query(int lo, int hi, int idx) : lo(lo), hi(hi), idx(idx) {}
};

int n, m, A[100010], cnt[1000010], ans[100010], distinctNumbers;
vector&amp;lt;Query&amp;gt; query;

// add function
void add(int num) {
  // num이 새롭게 cnt배열에 들어올때만 카운팅 해준다
  if (++cnt[num] == 1) {
    ++distinctNumbers;
  }
}

// erase function
void erase(int num) {
  // num이 cnt배열에서 완전히 없어질때 카운팅 해준다
  if (--cnt[num] == 0) {
    --distinctNumbers;
  }
}

int main() {
  scanf(&quot;%d&quot;, &amp;amp;n);
  for (int i = 0 ; i &amp;lt; n ; ++i) {
    scanf(&quot;%d&quot;, &amp;amp;A[i]);
  }
  scanf(&quot;%d&quot;, &amp;amp;m);
  for (int i = 0 ; i &amp;lt; m ; ++i) {
    int lo, hi;
    scanf(&quot;%d%d&quot;, &amp;amp;lo, &amp;amp;hi);
    query.emplace_back(lo - 1, hi - 1, i);
  }
  
  // sort queries
  int sz = sqrt(n);
  sort(query.begin(), query.end(), [&amp;amp;](const Query&amp;amp; l, const Query&amp;amp; r) {
    // 쿼리가 끝나는 부분이 어떠한 묶음에 속하는지 확인하다
    // 묶음의 인덱스가 더 작은곳에 속하는 쿼리를 먼저 처리한다
    // 만약 묶음의 인덱스가 같다면 쿼리의 시작지점이 작은것을 먼저 처리한다
    int lIdx = l.hi / sz;
    int rIdx = r.hi / sz;
    return lIdx == rIdx ? l.lo &amp;lt; r.lo : lIdx &amp;lt; rIdx;
  });
  
  // Change the iterator from the previous query to the current query
  int lo = 0, hi = 0;
  
  // 시작 이터레이터는 [0, 0]이기 때문에 A[0]의 값을 cnt배열에 넣고 시작한다
  add(A[0]);
  
  // 모든 쿼리에 대한 답을 계산한다
  for (auto cur : query) {
    // 현재 위치는 [lo, hi]이고 다음 위치는 [nlo, nhi]이다
    int nlo = cur.lo, nhi = cur.hi;
    
    // lo를 nlo로 움직이는 부분
    // 1. lo가 nlo보다 왼쪽에 있는 경우 : 수를 제거할 필요가 있다
    for (int i = lo ; i &amp;lt; nlo ; ++i) {
      erase(A[i]);
    }
    
    // 2. lo가 nlo보다 오른쪽에 있는 경우 : 수를 더할 필요가 있다
    for (int i = lo - 1; i &amp;gt;= nlo ; --i) {
      add(A[i]);
    }
    
    // hi를 nhi로 움직이는 부분
    // 1. hi가 nhi보다 왼쪽에 있는 경우 : 수를 더할 필요가 있다
    for (int i = hi + 1 ; i &amp;lt;= nhi ; ++i) {
      add(A[i]);
    }
    
    // 2. hi가 nhi보다 오른쪽에 있는 경우 : 수를 제거할 필요가 있다
    for (int i = hi ; i &amp;gt; nhi ; --i) {
      erase(A[i]);
    }
    
    // 이터레이터가 현재 쿼리의 범위를 나타내도록 한다
    lo = nlo;
    hi = nhi;
    
    // 답을 저장할 배열에 실제 쿼리의 순서에 맞게 답을 기록해 준다
    ans[cur.idx] = distinctNumbers;
  }
  
  for (int i = 0 ; i &amp;lt; m ; ++i) {
    printf(&quot;%d\n&quot;, ans[i]);
  }
}&lt;/pre&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>etc.</category>
<category>mo's algorithm</category>
<category>Sqrt Decomposition</category>
<author>kesakiyo</author>
<guid>https://kesakiyo.tistory.com/25</guid>
<comments>https://kesakiyo.tistory.com/25#entry25comment</comments>
<pubDate>Mon, 21 Nov 2016 12:49:06 +0900</pubDate>
</item>
<item>
<title>2365 - 숫자판 만들기</title>
<link>https://kesakiyo.tistory.com/24</link>
<description>&lt;p&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 14pt; color: rgb(116, 116, 116);&quot;&gt;문제 링크&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2365&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://www.acmicpc.net/problem/2365&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 14pt; color: rgb(116, 116, 116);&quot;&gt;문제 요약&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;\(N*N\)행렬의 각 열들의 합과 각 행들의 합이 주어졌을 때 원본 행렬을 복구하는 문제다. 하지만 아무렇게나 복구하는것이 아니라 행렬에 써져있는 숫자의 최댓값이 최소가 되도록 하고 싶다. 이 때 행렬을 복구한 뒤 출력한다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;b style=&quot;font-size: 16px;&quot;&gt;&lt;span style=&quot;font-size: 14pt; color: rgb(116, 116, 116);&quot;&gt;문제 풀이&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 문제는&amp;nbsp;&lt;a href=&quot;https://www.acmicpc.net/problem/1960&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://www.acmicpc.net/problem/1960&lt;/a&gt;와 상당히 유사한 문제다. 먼저 이 문제를 풀어보는것을 권장한다. 이 문제의 풀이를 알고 있다는 전제조건 하에 풀이를 서술하려 한다. 이 문제의 풀이는 &lt;a href=&quot;http://kesakiyo.tistory.com/23&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;링크&lt;/a&gt;에서 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 문제에서 달라진 점은 각 행렬에 들어갈 수 있는 값이 0또는 1이 아니라 내가 정할 수 있다는 점이다. 만약 내가 원본 행렬에 존재하는 최댓값을 \(x\)라고 정했다고 하자. 그럼 각 행들을 대표하는 정점들과 각 열들을 대표하는 정점들을 이어줄 때 \(capacity\)를 \(x\)로 설정해주면 된다. 그렇게 모든 \(x\)에 대해서 가능한지 확인한다면 답을 구할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;하지만 모든 \(x\)에 대해서 네트워크 플로우를 돌리기에는 시간이 부족하다. 우리는 여기서 한가지 아이디어를 생각할 수 있다. \(x\)는 커지면 커질수록 원본 행렬을 만들 수 있는 확률이 높아진다는 것이다. 즉 단조증가 그래프가 그려지기 때문에 \(binary\ search\)를 적용할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;\(binary\ search\)를 사용하면 원본 행렬에 존재하는 값의 최댓값중의 최솟값을 빠른 시간내로 찾을 수 있고 역추적 과정을 통해 원본 행렬을 복구할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;소스 코드&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more24_0&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '24_0','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content24_0&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;brush:cpp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

const int INF = 987654321;
int n, tot, N, src, sink, RS[60], CS[60], C[110][110], dist[110], iter[110];

void makeGraph(int x) {
  memset(C, 0, sizeof(C));
  for (int i = 0 ; i &amp;lt; n ; ++i) {
    C[src][i] = RS[i];
    C[i + n][sink] = CS[i];
    for (int j = 0 ; j &amp;lt; n ; ++j) {
      C[i][j + n] = x;
    }
  }
}

bool bfs() {
  memset(dist, -1, sizeof(dist));
  dist[src] = 0;
  queue&amp;lt;int&amp;gt; q;
  q.push(src);
  
  while (!q.empty()) {
    int here = q.front();
    q.pop();
    
    for (int there = 0 ; there &amp;lt; N ; ++there) {
      if (C[here][there] &amp;amp;&amp;amp; dist[there] == -1) {
        dist[there] = dist[here] + 1;
        q.push(there);
      }
    }
  }
  
  return dist[sink] != -1;
}

int dfs(int here, int flow) {
  if (here == sink) {
    return flow;
  }
  
  for (int&amp;amp; there = iter[here] ; there &amp;lt; N ; ++there) {
    if (C[here][there] &amp;amp;&amp;amp; dist[here] &amp;lt; dist[there]) {
      int minFlow = dfs(there, min(flow, C[here][there]));
      if (minFlow) {
        C[here][there] -= minFlow;
        C[there][here] += minFlow;
        return minFlow;
      }
    }
  }
  
  return 0;
}

int maxFlow() {
  int ret = 0;
  while (bfs()) {
    memset(iter, 0, sizeof(iter));
    int flow;
    while ((flow = dfs(src, INF))) {
      ret += flow;
    }
  }
  return ret;
}

bool solve(int x) {
  makeGraph(x);
  return maxFlow() == tot;
}

int main() {
  scanf(&quot;%d&quot;, &amp;amp;n);
  for (int i = 0 ; i &amp;lt; n ; ++i) {
    scanf(&quot;%d&quot;, &amp;amp;RS[i]);
    tot += RS[i];
  }
  for (int i = 0 ; i &amp;lt; n ; ++i) {
    scanf(&quot;%d&quot;, &amp;amp;CS[i]);
  }
  
  N = n * 2 + 2;
  src = n * 2;
  sink = n * 2 + 1;
  
  int lo = 0, hi = 1000000;
  while (lo &amp;lt; hi) {
    int mid = (lo + hi) &amp;gt;&amp;gt; 1;
    if (solve(mid)) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  
  solve(lo);
  printf(&quot;%d\n&quot;, lo);
  for (int i = 0 ; i &amp;lt; n ; ++i) {
    for (int j = 0 ; j &amp;lt; n ; ++j) {
      printf(&quot;%d &quot;, lo - C[i][j + n]);
    }
    puts(&quot;&quot;);
  }
}&lt;/pre&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>BOJ</category>
<category>Binary Search</category>
<category>max flow</category>
<author>kesakiyo</author>
<guid>https://kesakiyo.tistory.com/24</guid>
<comments>https://kesakiyo.tistory.com/24#entry24comment</comments>
<pubDate>Mon, 21 Nov 2016 01:23:48 +0900</pubDate>
</item>
<item>
<title>1960 - 행렬만들기</title>
<link>https://kesakiyo.tistory.com/23</link>
<description>&lt;p&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 14pt; color: rgb(116, 116, 116);&quot;&gt;문제 링크&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1960&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://www.acmicpc.net/problem/1960&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 12pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 14pt; color: rgb(116, 116, 116);&quot;&gt;문제 요약&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;\(N*N\)행렬의 각 열들의 합과 각 행들의 합이 주어졌을 때 원본 행렬을 복구해 출력하는 문제다. 원본 행렬이 가질 수 있는 값은 0또는 1이다. 물론 만들지 못하는 경우도 주어질 수 있으며 이때는 -1을 출력한다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;b style=&quot;font-size: 16px;&quot;&gt;&lt;span style=&quot;font-size: 14pt; color: rgb(116, 116, 116);&quot;&gt;문제 풀이&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 문제는 전형적인 네트워크 플로우로 문제다.(그리디로도 해결이 가능하다고 한다.) 모델링 또한 너무 간단하다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;우선 왼쪽에는 각 행들을 대표할 수 있는 정점들을 두고 오른쪽에는 각 열들을 대표할 수 있는 정점들을 둔다. 그리고 소스와 왼쪽 정점들을, 싱크와 오른쪽 정점들을 연결해준다. 각각의 \(capacity\)는 행들의 합과 열들의 합으로 설정해 준다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;그 뒤 행들을 대표하는 정점들과 열들을 대표하는 정점들이 모두 연결되어 있는 완전 그래프 형태로 만들어 준다. 이 간선들의 \(capacity\)는 1이다. 그 뒤 \(max\ flow\)를 구하면 답을 구할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;답을 구하는 과정은 크게 두 가지 파트로 나누어 진다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;첫 번째 파트는 실제로 원본 행렬을 만들 수 있는지 판단하는 것이다. 이는 주어진 행들의 합의 합과 열들의 합의 합이 같은지 확인한 다음에 \(max\ flow\)또한 이와 같은지 확인해주면 된다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;두 번째 파트는 실제로 원본 행렬을 만드는 과정이다. 이 과정이 조금 까다로울 수 있지만 우리가 모델링한 그래프의 의미를 정확하게 이해하고 있다면 어렵지 않게 행렬을 복원할 수 있다. 만약 첫 번째 행을 대표하는 정점에서 두 번째 열을 대표하는 정점으로 \(flow\)가 1흐른다고 생각을 해보자. 이는 우리가 복원할 행렬의 \((1,\ 2)\)에 1이&amp;nbsp;채워져 있다는 의미다. 만약 흐르는 유량이 없다면 그 칸은 0으로 채워지면 될 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;소스 코드&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more23_0&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '23_0','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content23_0&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;brush:cpp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

const int INF = 987654321;
int row, col, n, x, src, sink, N, C[1010][1010], D[1010], iter[1010];

bool bfs() {
  memset(D, -1, sizeof(D));
  queue&amp;lt;int&amp;gt; q;
  D[src] = 0;
  q.push(src);
  
  while (!q.empty()) {
    int here = q.front();
    q.pop();
    
    for (int there = 0 ; there &amp;lt; N ; ++there) {
      if (C[here][there] &amp;amp;&amp;amp; D[there] == -1) {
        D[there] = D[here] + 1;
        q.push(there);
      }
    }
  }
  
  return D[sink] != -1;
}

int dfs(int here, int flow) {
  if (here == sink) {
    return flow;
  }
  
  for (int&amp;amp; there = iter[here] ; there &amp;lt; N ; ++there) {
    if (C[here][there] &amp;amp;&amp;amp; D[here] &amp;lt; D[there]) {
      int minFlow = dfs(there, min(flow, C[here][there]));
      if (minFlow) {
        C[here][there] -= minFlow;
        C[there][here] += minFlow;
        return minFlow;
      }
    }
  }
  
  return 0;
}

int maxFlow() {
  int ret = 0;
  while (bfs()) {
    int flow;
    memset(iter, 0, sizeof(iter));
    while ((flow = dfs(src, INF))) {
      ret += flow;
    }
  }
  return ret;
}

int main() {
  scanf(&quot;%d&quot;, &amp;amp;n);
  src = 2 * n;
  sink = 2 * n + 1;
  N = 2 * n + 2;
  
  for (int i = 0 ; i &amp;lt; n ; ++i) {
    scanf(&quot;%d&quot;, &amp;amp;x);
    C[src][i] += x;
    row += x;
  }
  for (int i = 0 ; i &amp;lt; n ; ++i) {
    scanf(&quot;%d&quot;, &amp;amp;x);
    C[i + n][sink] += x;
    col += x;
  }
  for (int i = 0 ; i &amp;lt; n ; ++i) {
    for (int j = 0 ; j &amp;lt; n ; ++j) {
      ++C[i][j + n];
    }
  }
  
  int flow =  maxFlow();
  if (row == flow &amp;amp;&amp;amp; col == flow) {
    puts(&quot;1&quot;);
    for (int i = 0 ; i &amp;lt; n ; ++i) {
      for (int j = 0 ; j &amp;lt; n ; ++j) {
        printf(&quot;%d&quot;, C[i][j + n] ? 0 : 1);
      }
      puts(&quot;&quot;);
    }
  } else {
    puts(&quot;-1&quot;);
  }
}&lt;/pre&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>BOJ</category>
<category>max flow</category>
<author>kesakiyo</author>
<guid>https://kesakiyo.tistory.com/23</guid>
<comments>https://kesakiyo.tistory.com/23#entry23comment</comments>
<pubDate>Mon, 21 Nov 2016 00:20:15 +0900</pubDate>
</item>
<item>
<title>Sqrt Decomposition</title>
<link>https://kesakiyo.tistory.com/22</link>
<description>&lt;p&gt;원소들을 효율적으로 관리해야할 일이 있을때 우리는 어떤 전략을 선택해야할까? 원소들을 효율적으로 관리하는 방법은 여러가지가 있다. 이번에는 그 중 하나인 Sqrt Decomposition에 대해 알아보도록 하자.&amp;nbsp;Sqrt Decomposition에서 Sqrt는 Square root의 약자다. 이를 우리나라 말로 번역하자면 평방분할이라고 한다. 하지만 의미적으로 별로 와닿지 않는다고 생각하기 때문에 Sqrt Decomposition이라고 하겠다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;연속적인 원소들을 하나의 묶음으로&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;Sqrt Decomposition의 기본 아이디어는 정말 간단하다. 연속적인 원소들을 하나의 묶음으로 생각하자는 것이다. 이 때 한 묶음의 크기는&amp;nbsp;보통 \(\sqrt N\)으로 잡는다.(그래서 Square root라는 이름이 붙은것 같다.)&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:400px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/225BED485830A3D22E&quot; filemime=&quot;image/jpeg&quot; filename=&quot;sqrt1.png&quot; height=&quot;157&quot; width=&quot;400&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;위 그림은 원소가 9개일 때 연속한 3개씩 끊어 한 묶음으로 취급하는 예를 보여준다. 그렇다면 일차원 배열에서만 사용할 수 있는것일까? 아래 그림은 이차원 배열에서 Sqrt Decomposition를 적용한 결과를 보여준다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:400px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/276C5F4F5830A4591B&quot; filemime=&quot;image/jpeg&quot; filename=&quot;sqrt2.png&quot; height=&quot;206&quot; width=&quot;400&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;또한 일차원, 이차원 배열 외에도 \(Tree\)에도 적용할 수 있는 등 그 활용범위가 상당히 다양하다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;구간의 합 구하기&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;Sqrt Decomposition의 이론은 위에서 설명한 것이 전부이다. 너무 간단해 어떻게 사용하는지 감이 잘 안올것이다. 그래서 구간의 합을 구하는 문제를 Sqrt Decomposition를 이용해 푸는 과정을 보여주려 한다. 구간의 합을 찾는 문제는 다음과 같다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;\(A_1,\ A_2,\ A_3,\ ...\ ,\ A_{N-1},\ A_{N}\)인 시퀀스가 있을 때 두 가지 쿼리를 처리해야 한다.&lt;/p&gt;
&lt;p&gt;1. \(x,\ y\ (1 \le x \le y \le N)\)가 주어졌을 때 \([A_x,\ A_y]\)의 합을 구한다.&lt;/p&gt;
&lt;p&gt;2. \(x\ (1 \le x \le N)\)와 \(val\)이 주어졌을 때 \(A_x\)의 값을 \(val\)로 갱신한다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 때 이 쿼리들을 완전탐색으로 해결할수도 있다. 하지만 \(N\)이 크고 쿼리의 수가 많다면 빠른시간내에 답을 낼 수 없다. 우리는 각각의 쿼리에 대해서 \(O(\sqrt N)\)에 푸는것을 목표로 하자.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 문제는&amp;nbsp;&lt;a href=&quot;https://www.acmicpc.net/problem/2042&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://www.acmicpc.net/problem/2042&lt;/a&gt;에서 풀어볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;전처리&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Sqrt Decomposition는 쿼리를 수행하기 전에 전처리가 필요하다. 우선 원소들을 연속한 \(\sqrt N\)개만큼 묶은 다음 이 묶음들의 합을 미리 계산해 놓는다. 이렇게 계산된 합들은 각각의 쿼리를 \(O(\sqrt N)\)에 처리하는데 큰 도움을 준다. 전 처리는 \(O(N)\)에 할 수 있다.&amp;nbsp;&lt;/p&gt;&lt;pre class=&quot;brush:cpp&quot;&gt;// initialize function
// sz = sqrt(n)
void init() {
  sz = sqrt(n)
  for (int i = 0 ; i &amp;lt; n ; ++i) {
    bucket[i / sz] += A[i];
  }
}&lt;/pre&gt;&lt;div&gt;&lt;span style=&quot;font-size: 10pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-size: 10pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;구간의 합을 구하는 쿼리&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;전처리를 했으면 이제 두 가지 쿼리를 처리해야 한다. 그 중 첫 번째 쿼리인 구간의 합을 구하는 쿼리를 처리해 보자. 합을 구하고자 하는 구간이 주어졌을 때 구간 내에 포함된 묶음들은 크게 두 가지 종류로 분류할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;1. 구간에 완전히 포함된 묶음&lt;/p&gt;
&lt;p&gt;2. 구간에 애매하게 걸쳐있는 묶음&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;1번 경우는 전처리한 묶음의 합들을 사용해 쉽게 계산이 가능하다. 하지만 2번 경우에는 전처리한 합을 이용해 계산하는것이 불가능하다. 그래서 구간에 애매하게 걸쳐있는 묶음은 구간 내 포함된 원소들을 찾아 직접 더해줘야 한다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:580px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/240ED94C5830B2F82B&quot; filemime=&quot;image/jpeg&quot; filename=&quot;sqrt3.png&quot; height=&quot;176&quot; width=&quot;580&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;과연 이렇게 구하는 방법이 완전탐색으로 구하는 것보다 더 빠른 시간을 보장할 수 있을까? 1번에 포함된 묶음은 최대 몇개가 있을지 생각해보자. 우리는 한 묶음을 \(\sqrt N\)개의 연속된 원소들로 정의를 했다. 그렇기 때문에 묶음의 개수는 \(\sqrt N\)개를 넘을 수 없다. 따라서 구간에 완전히 포함된 묶음은 최대 \(\sqrt N\)개가 될 것이다. 2번의 경우는 확인해야 하는 원소들의 개수가 한 묶음 전체가 될 수도 있다. 그래서 2번의 경우에 해당하는 묶음의 수가 중요하다. 하지만 잘 생각해 보면 구간에 애매하게 걸쳐있는 묶음이 발생하는 곳은&amp;nbsp;구간의 양 끝에서만 존재한다는 것을 알 수 있다. 결국 2번의 경우에 해당하는 묶음은 최대 2개까지 존재할 수 있다.&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;따라서 구간의 합을&amp;nbsp;\(O(\sqrt N)\)의 시간에 구할 수 있다.&lt;/p&gt;&lt;pre class=&quot;brush:cpp&quot;&gt;// query function
long long query(int lo, int hi) {
  long long ret = 0;
  
  // 2번 경우를 처리해 주는 부분
  // 구간의 왼쪽에 애매하게 걸쳐있는 묶음의 원소들을 모두 더해준다
  while (lo % sz != 0 &amp;amp;&amp;amp; lo &amp;lt;= hi) {
    ret += A[lo++];
  }
  
  // 구간의 오른쪽에 애매하게 걸쳐있는 묶음의 원소들을 모두 더해준다
  while ((hi + 1) % sz != 0 &amp;amp;&amp;amp; lo &amp;lt;= hi) {
    ret += A[hi--];
  }
  
  // 1번 경우를 처리해 주는 부분
  // 구간 내 완벽하게 포함된 묶음들의 합을 더해준다
  while (lo &amp;lt;= hi) {
    ret += bucket[lo / sz];
    lo += sz;
  }
  
  return ret;
}&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;특정 원소의 값을 갱신&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이제 남은 쿼리는 특정 원소의 값을 갱신하는 쿼리다. 구간의 합을 구하는 쿼리보다 특정 원소를 갱신하는 쿼리는 비교적 많이 쉽다. 해당 원소가 속해있는 묶음의 합에 바뀐 값의 차이만큼 더해주고 실제 원소의 값을 변경시켜주면 끝난다. 이 작업은 모두 상수시간에 가능하며 시간복잡도는 \(O(1)\)이다.&lt;/p&gt;&lt;pre class=&quot;brush:cpp&quot;&gt;// update function
void update(int pos, long long val) {
  // 원래 원소의 값과 갱신해야 하는 값의 차이를 계산
  long long diff = val - A[pos];
  
  // 기존 원소를 새로운 값으로 대체
  A[pos] = val;
  
  // 기존 원소가 속해있는 묶음에 갱신으로 인해 생기는 차이만큼의 값을 더해준다
  bucket[pos / sz] += diff;
}&lt;/pre&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;결론&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;자, 이제 우리가 원하는 모든 작업을 어떻게 구현해야 하는지 알아봤다. Sqrt Decomposition을 이용해 구간의 합을 구하는 문제를 풀기 위해서 다음과 같은 세 가지 작업을 필요로 했다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;1. 전처리 : \(O(N)\)&lt;/p&gt;
&lt;p&gt;2. 구간의 합을 구하는 쿼리 : \(O(\sqrt N)\)&lt;/p&gt;
&lt;p&gt;3. 특정 값을 갱신 : \(O(1)\)&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;만약 쿼리의 수가 \(Q\)개라면 우리는 \(O(N+Q\sqrt N)\)의 시간에 문제를 해결할 수 있을 것이다. 물론 세그먼트 트리를 사용하면 \(O(N+QlogN)\)이라는 훌륭한 시간에 문제를 해결할 수 있다. 하지만 우리는&amp;nbsp;Sqrt Decomposition의 사용방법을 배웠기 때문에&amp;nbsp;Sqrt Decomposition으로 문제를 한번 풀어보도록 하자.&amp;nbsp;Sqrt Decomposition로 풀 수 있는 문제는 대부분 세그먼트 트리로도 해결이 가능하지만 간혹&amp;nbsp;Sqrt Decomposition로 푸는것이 훨씬 간단하고 쉬울때가 있다. 이는 나중에 다뤄보도록 하자.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#747474&quot;&gt;&lt;span style=&quot;font-size: 18.6667px;&quot;&gt;&lt;b&gt;전체 코드&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more22_0&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '22_0','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content22_0&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;brush:cpp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;math.h&amp;gt;

const int MAX = 1e6 + 10;
int sz, n, m, k, q;
long long y, A[MAX], bucket[MAX];

// initialize function
// sz = sqrt(n)
void init() {
  sz = sqrt(n);
  for (int i = 0 ; i &amp;lt; n ; ++i) {
    bucket[i / sz] += A[i];
  }
}

// query function
long long query(int lo, int hi) {
  long long ret = 0;
  
  // 2번 경우를 처리해 주는 부분
  // 구간의 왼쪽에 애매하게 걸쳐있는 묶음의 원소들을 모두 더해준다
  while (lo % sz != 0 &amp;amp;&amp;amp; lo &amp;lt;= hi) {
    ret += A[lo++];
  }
  
  // 구간의 오른쪽에 애매하게 걸쳐있는 묶음의 원소들을 모두 더해준다
  while ((hi + 1) % sz != 0 &amp;amp;&amp;amp; lo &amp;lt;= hi) {
    ret += A[hi--];
  }
  
  // 1번 경우를 처리해 주는 부분
  // 구간 내 완벽하게 포함된 묶음들의 합을 더해준다
  while (lo &amp;lt;= hi) {
    ret += bucket[lo / sz];
    lo += sz;
  }
  
  return ret;
}

// update function
void update(int pos, long long val) {
  // 원래 원소의 값과 갱신해야 하는 값의 차이를 계산
  long long diff = val - A[pos];
  
  // 기존 원소를 새로운 값으로 대체
  A[pos] = val;
  
  // 기존 원소가 속해있는 묶음에 갱신으로 인해 생기는 차이만큼의 값을 더해준다
  bucket[pos / sz] += diff;
}

int main() {
  scanf(&quot;%d%d%d&quot;, &amp;amp;n, &amp;amp;m, &amp;amp;k);
  
  for (int i = 0 ; i &amp;lt; n ; ++i) {
    scanf(&quot;%lld&quot;, &amp;amp;A[i]);
  }
  
  // 초기화 함수 호출
  init();
  
  for (int iter = 0 ; iter &amp;lt; m + k ; ++iter) {
    scanf(&quot;%d&quot;, &amp;amp;q);
    
    // 특정 원소의 값을 갱신하는 쿼리
    if (q == 1) {
      int pos;
      long long val;
      scanf(&quot;%d%lld&quot;, &amp;amp;pos, &amp;amp;val);
      update(pos - 1 , val);
    }
    
    // 구간의 합을 구하는 쿼리
    else {
      int lo, hi;
      scanf(&quot;%d%d&quot;, &amp;amp;lo, &amp;amp;hi);
      printf(&quot;%lld\n&quot;, query(lo - 1, hi - 1));
    }
  }
}&lt;/pre&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>etc.</category>
<category>Sqrt Decomposition</category>
<author>kesakiyo</author>
<guid>https://kesakiyo.tistory.com/22</guid>
<comments>https://kesakiyo.tistory.com/22#entry22comment</comments>
<pubDate>Sun, 20 Nov 2016 03:53:45 +0900</pubDate>
</item>
</channel>
</rss>