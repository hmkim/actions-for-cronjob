<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dongho Sim's dev story</title>
    <description>Dongho Sim's dev story,use Jekyll and github pages.</description>
    <link>https://dhsim86.github.io/</link>
    <atom:link href="https://dhsim86.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 12 May 2019 12:20:26 +0000</pubDate>
    <lastBuildDate>Sun, 12 May 2019 12:20:26 +0000</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>도메인 주도 설계 08 - 도약</title>
        <description>&lt;p&gt;도메인 주도 설계에서 가장 어려운 일은 도메인 전문가의 관심사를 포착하고 효과적인 설계로 이끌어줄 &lt;strong&gt;명확한 모델을 발견하는 것이다.&lt;/strong&gt; 궁극적으로는 도메인에 대한 심층적인 이해를 반영한 모델이 필요하다. 이를 통해 도메인 전문가의 사고방식과 좀더 자연스럽게 융합되고 사용자의 요구에 기민하게 대응할 수 있는 소프트웨어를 개발할 수 있다.&lt;/p&gt;

&lt;p&gt;유용한 모델을 성공적으로 개발하기 위해 명심해야 할 세 가지는 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;정교한 도메인 모델은 만들 수 있으며, 노력을 들일 만한 가치가 있다.&lt;/li&gt;
  &lt;li&gt;해당 도메인을 학습하는 개발자와 도메인 전문가의 긴밀한 참여와 반복적인 리팩터링 과정없이는 유용한 모델을 개발하기가 쉽지 않다.&lt;/li&gt;
  &lt;li&gt;유용한 모델을 효과적으로 구현하고 사용하기 위해서는 정교한 설계 기술이 필요할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;리팩터링-수준&quot;&gt;리팩터링 수준&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;리팩터링(Refactoring)이란 소프트웨어의 기능을 수정하지 않고, 설계를 다시 하는 것을 의미한다.&lt;/strong&gt; 사전에 모든 설계 결정을 내리기보다는 기존의 기능은 유지한 채, 끊임없이 코드를 변경하면서 설계를 좀 더 유연하게 개선하거나 이해하기 쉽도록 만든다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;자동화된 유닛 테스트를 통해 비교적 안전하게 리팩터링을 수행할 수 있다. 개발자는 리팩터링으로 인한 코드 변경을 안심하고 진행할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;시스템의 생존력에 가장 큰 영향을 미치는 리팩터링은 &lt;strong&gt;도메인에 대한 새로운 통찰력을 얻었을 때 수행하거나 코드를 사용하여 모델이 표현하고자 하는 바를 명확하게 드러내고자 할 때이다.&lt;/strong&gt; 리팩터링의 목표는 개발자가 단순히 코드가 수행하는 바를 이해하는 것뿐만 아니라 &lt;strong&gt;왜 그렇게 수행되는지를 이해하고 도메인 전문가와의 의사소통에 이를 연관시키는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;심층-모델&quot;&gt;심층 모델&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;심층 모델(deep model)이란 도메인의 피상적인 측면은 배제하고, 도메인 전문가의 주요 관심사와 가장 적절한 지식을 알기 쉽게 표현한 모델이다.&lt;/strong&gt; 도메인과 조화를 이루는 모델에서는 융통성, 단순함, 설명력을 얻을 수 있다. 그러한 모델이 공통적으로 지니고 있는 특징은 &lt;strong&gt;업무 전문가가 즐겨쓰는 단순하지만 충분히 추상적인 언어가 존재한다는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;기본에-집중하라&quot;&gt;기본에 집중하라&lt;/h2&gt;

&lt;p&gt;지식탐구와 더불어 인내심을 가지고 UBIQUITOUS LANGUAGE를 만드는 일에 집중해야 한다. 이를 통해 중요한 도매인 개념을 포착할 수 있고 그러한 개념을 모델 내에 명시적으로 표현할 수 있다. 그리고 수많은 리팩터링 과정에서의 연속적인 정제를 통해 서서히 모델에 대한 통찰력을 얻게 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;도메인 모델의 정제를 통해 얻은 심층적인 모델은 애플리케이션을 더 풍부하게 만들고 설계를 더 명확하게 만들 수 있는 기회를 제공하기도 한다. 이전에는 몰랐지만 정제된 도메인 모델과 유연해지고 명확해진 설계로 인해 설계상의 또다른 문제점을 깨닫게 되는 기회가 만들어질 수 있기 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 12 May 2019 00:00:00 +0000</pubDate>
        <link>https://dhsim86.github.io/programming/2019/05/12/domain_driven_design_08-post.html</link>
        <guid isPermaLink="true">https://dhsim86.github.io/programming/2019/05/12/domain_driven_design_08-post.html</guid>
        
        <category>DDD</category>
        
        <category>Domain</category>
        
        <category>Domain Driven Design</category>
        
        
        <category>Programming</category>
        
      </item>
    
      <item>
        <title>도메인 주도 설계 06 - 도메인 객체의 생명주기</title>
        <description>&lt;p&gt;모든 객체에는 생명주기가 있다. 한 객체는 생성되어 다양한 상태를 거친 후 결국 저장되거나 삭제되면서 소멸한다. 다른 객체와 복잡한 상호의존성을 맺으며, 여러 가지 상태의 변화를 겪기도 하는데 이 때 갖가지 불변식이 적용된다. 이러한 객체들을 관리하는데 실패한다면 Model-Driven Design을 시도하는 것이 쉽게 좌절될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/programming/2019-04-28-domain_driven_design_06/00.png&quot; alt=&quot;00.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도메인 객체의 관리와 관련되 문제는 아래의 두 가지 범주로 나뉜다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;생명주기 동안의 무결성 유지하기&lt;/li&gt;
  &lt;li&gt;생명주기 관리의 복잡성으로 모델이 난해해지는 것을 방지하기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 문제를 해결하는데 도메인 주도 설계에서는 세 가지 패턴을 통해 해결한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Aggregate: &lt;strong&gt;소유권과 경계를 명확히 정의하여 모델을 엄격하게 만들어&lt;/strong&gt; 객체 간의 연관관계가 혼란스럽게 얽히는 것을 방지하고, 도메인 객체의 &lt;strong&gt;무결성&lt;/strong&gt;을 유지한다.&lt;/li&gt;
  &lt;li&gt;Factory: 복잡한 객체와 Aggregate를 생성 및 재구성함으로써 그것들의 &lt;strong&gt;내부 구조를 캡슐화&lt;/strong&gt;한다.&lt;/li&gt;
  &lt;li&gt;Repository: &lt;strong&gt;영속성과 관련된 인프라스트럭처를 캡슐화하면서 영속 객체를 찾아 조회하는 수단&lt;/strong&gt;을 제공한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Repository와 Factory가 도메인에서 나오는 것은 아니지만, 그것들은 도메인 설계에서 중요한 역할을 담당한다. Aggregate를 모델링하고 Repository와 Factory를 통해 모델 객체의 생명주기 동안 그것들 체계적이고 의미 있는 단위로 조작할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Aggregate는 생명주기의 전 단계에서 불변식이 유지해야할 범위를 표시하는 것이며, Repository와 Factory는 Aggregate를 대상으로 연산을 수행하며 특정 생명주기로 이동하는 과정에 따른 복잡성을 캡슐화한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;aggregate-집합체&quot;&gt;Aggregate (집합체)&lt;/h2&gt;

&lt;p&gt;연관관계를 최소주의 관점에서 설계하면 탐색이 단순해지고 증가하는 관계를 제한하는데 어느정도 도움이 되긴 하지만, 대부분의 업무 도메인은 상호 연관의 정도가 높으므로 객체 참조를 통해 얽히고 설킨 객체 관계망을 추적해야 한다. 그런데 이런 과도한 관계망은 소프트웨어 설계에서는 문제가 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;일반적인 객체 모델의 관계망은 잠재적인 변경의 효과가 미칠 범위를 명확히 한정해주지 않는다.&lt;/strong&gt; 특히 동일한 객체에 여러 클라이언트가 동시에 접근하는 시스템에서는 문제가 심각해질 수 있다. &lt;strong&gt;변경의 범위를 알맞게 제한하지 않는다면 심각한 결과가 초래될 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;모델 내에서 복잡한 연관관계를 맺는 객체를 대상으로 변경의 일관성을 보장하기란 쉽지 않다. &lt;strong&gt;개별 객체뿐만 아니라 그 객체가 참조하는, 서로 밀접한 관계에 있는 객체 집합에도 불변식이 적용되어야 하기 때문이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이러한 문제의 균형잡힌 해법을 찾기 위해서는 도메인을 심층적으로 이해해야 하며, 특히 특정 클래스의 인스턴스 사이의 변화 빈도와 같은 사항까지도 이해하고 있어야 한다. &lt;strong&gt;경합이 높은 지점을 느슨하게 연결하고, 엄격한 불변식을 더욱 엄격하게 지켜지케 하는 모델을 찾을 필요가 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;문제의 근원은 &lt;strong&gt;모델에 경계가 정의되어 있지 않다는 점이다.&lt;/strong&gt; 모델을 근간으로 하는 해법을 이용하면 모델을 좀 더 이해하기 쉬워지고 설계한 바가 더 쉽게 전달될 것이다.&lt;/p&gt;

&lt;p&gt;다음과 같은 엄격한 체계는 그와 같은 개념에서 정수를 뽑아낸 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;모델 내의 참조에 대한 캡슐화를 추상화할 필요가 있다.&lt;/strong&gt; &lt;strong&gt;Aggregate는 데이터 변경의 “단위”로 다루는 연관 객체의 묶음을 말하는데, 각 Aggregate에는 루트(root)와 경계(boundary)가 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;경계: Aggregate에 무엇이 포함되고 포함되지 않는지를 정의한다.&lt;/li&gt;
  &lt;li&gt;루트: Aggregate 내에 단 하나만 존재하며 특정 Entity를 가리킨다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;경계 안의 객체들은 서로 참조할 수 있지만, &lt;strong&gt;경계 바깥의 객체는 해당 Aggregate의 구성요소 가운데 루트만 참조할 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;루트 이외의 Aggregate 내부의 Entity는 지역 식별성을 가지며, Aggregate 내에서만 구분된다. Aggregate 경계 밖에서는 루트 Entity 말고는 내부를 직접 들여다 볼 수 없도록 하기 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/programming/2019-04-28-domain_driven_design_06/01.png&quot; alt=&quot;01.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 그림과 같이 Car는 외부에서 식별할 수 있는 루트 Entity이며, Aggregate 내부의 Wheel, Tire는 외부에서 바로 접근할 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;불변식은 데이터가 변경될 때마다 유지되어야 하는 일관성 규칙을 뜻하며, Aggregate를 구성하는 각 구성요소 간의 관계도 포함한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이런 특징을 가지는 Aggregate에 대한 트랜잭션에 적용되는 규칙은 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;루트 Entity는 전역 식별성을 가지며, 불변식을 검사할 책임이 있다.&lt;/li&gt;
  &lt;li&gt;Aggregate 경계 안의 Entity들은 지역 식별성을 지니며, Aggregate 내부에서만 유일하다.&lt;/li&gt;
  &lt;li&gt;Aggregate 경계 밖에서는 루트 Entity를 제외하고는 내부의 구성요소에 대해 직접 참조할 수 없다.
    &lt;ul&gt;
      &lt;li&gt;루트 Entity가 내부 Entity에 대한 참조를 바깥에 전달해 줄 수는 있지만 그러한 객체는 바깥에서 일시적으로만 사용해야 되고 계속 보유하면 안된다.&lt;/li&gt;
      &lt;li&gt;방어적 복사를 통해 다른 객체에 전달하도록 하며 외부에 의해 불변식이 깨지지 않도록 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터베이스에 질의를 하면 Aggregate의 루트만 직접적으로 획득하도록 구현한다.
    &lt;ul&gt;
      &lt;li&gt;Aggregate 내부의 다른 객체들은 모두 Aggregate의 루트를 통해서 탐색해서 발견해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Aggregate 안의 객체는 다른 Aggregate의 루트만 참조 가능하다.&lt;/li&gt;
  &lt;li&gt;삭제 연산은 Aggregate 경계 안의 모든 요소를 한 번에 제거해야 불변식을 지킬 수 있다.&lt;/li&gt;
  &lt;li&gt;Aggregate 경계 안의 어떤 객체를 변경하더라도 전체 Aggregate의 불변식은 지켜져야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;객체 간의 복잡한 연관관계로 인해 발생하는 문제점을 해소하고, 지켜져야 하는 불변식의 경계를 명확히 하기 위해서는&lt;/strong&gt; Entity와 Value Object를 한 Aggregate로 모으고 각각에 대해 경계를 정의하도록 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;factory-팩터리&quot;&gt;Factory (팩터리)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;어떤 객체나 Aggregate를 생성하는 일이 복잡하거나 외부로 내부 구조를 많이 드러내는 경우 Factory가 이를 캡슐화해준다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;객체의 장점 중 상당 부분은 객체의 내부구조와 연관관계를 정교하게 구성하는 데서 나온다. 객체는 그것의 존재 이유와 관련이 없거나 다른 객체와 상호작용함에 있어서 필요없는 것이 남지 않을 때까지 정제해야 한다. 이러한 객체의 책임 중에는 객체 전체 생명 주기의 중간 단계에서 수행하는 것들이 많다. 문제는 이러한 책임만으로도 복잡한 객체에 객체 자체를 생성하는 책임까지 맡기는 데 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;복잡한 객체를 조립하거나 생성하는 일은 생성 후 해당 객체가 하는 일이나 책임과 가장 관련성이 적은 일이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;객체 생성하는 책임을 클라이언트 객체로 옮긴다면 문제가 훨씬 더 나빠진다. 클라이언트가 객체 생성 책임을 가진다는 것은 &lt;strong&gt;클라이언트가 도메인 객체의 내부 구조를 어느 정도 알고 있어야 한다는 것이다.&lt;/strong&gt; 도메인 객체의 각 구성요소에 대해 적용되는 모든 불변식을 지키기 위해 &lt;strong&gt;클라이언트는 해당 객체의 규칙을 알아야 한다.&lt;/strong&gt; 이렇게 되면 객체의 클래스와 클라이언트가 결합되어, 객체 구현을 변경시, 클라이언트도 변경해야 한다.&lt;/p&gt;

&lt;p&gt;어떤 객체를 생성하는 것이 그 자체로도 주요한 연산이 될 수 있지만 &lt;strong&gt;복잡한 생성 / 조립 연산은 생성된 객체 자체의 책임으로는 어울리지 않는다. 그렇다고 이 책임을 클라이언트에 두면 이해하기 힘든 설계, 구현이 나올 수도 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;복잡한 객체를 생성하는 일은 도메인 계층의 책임이지만, 그것이 모델을 표현하는 객체에 속하는 것은 아니다. 일반적으로 객체 생성하는 것은 도메인에서는 의미가 없긴 하지만, 구현 측면에서는 반드시 필요하다. &lt;strong&gt;이러한 문제를 해결하기 위해 Entity나 Value Object, Service가 아닌 다른 무언가를 도메인 설계에 추가해야 한다.&lt;/strong&gt; 도메인 모델링의 결과로 나타나는 모델 내의 어떤 것에도 해당하지 않는 요소를 추가하는 것이지만, 이는 도메인 계층에서 맡고 있는 책임의 일부를 구성한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;자신의 책임이 다른 객체를 생성하는 것인 프로그램 요소를 Factory라고 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/programming/2019-04-28-domain_driven_design_06/02.png&quot; alt=&quot;02.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어느 한 객체의 인터페이스가 자신의 구현을 캡슐화하고 객체의 동작방식을 알 필요가 없도록 해주듯이 &lt;strong&gt;Factory는 복잡한 객체나 Aggregate를 생성하는데 필요한 지식을 캡슐화한다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;복잡한 객체와 Aggregate의 인스턴스를 생성하는 책임을 가지는 Factory는 도메인 설계의 일부를 구성하며, 이를 통해 클라이언트로부터 해당 객체의 내부구조나 규칙을 캡슐화할 수 있다. Factory는 전체 Aggregate 단위로 생성해서 그 것의 불변식이 지켜지도록 해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Factory를 설계하는 방법에는 여러가지가 있지만, 다음 두 가지 요건을 통해 Factory를 잘 설계하기 위한 필요 요소를 알 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;각 생성 방법은 원자적이어야 하며, 생성된 객체나 Aggregate의 불변식은 반드시 지켜져야 한다.&lt;/li&gt;
  &lt;li&gt;Factory는 생성된 클래스보다는 생성하고자 하는 타입으로 추상화되어야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;factory와-factory의-위치-선정&quot;&gt;Factory와 Factory의 위치 선정&lt;/h3&gt;

&lt;p&gt;Aggregate 내부에 요소를 추가하기 위해 내부 객체를 생성하는 용도라면, 해당 &lt;strong&gt;Aggregate 루트에 Factory 메서드를 둘 수 있다.&lt;/strong&gt; 다음과 같이 한 요소가 추가될 때마다 Aggregate의 무결성을 보장하는 책임을 루트가 담당하고 동시에 외부에 대해 Aggregate의 내부 구현을 숨길 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/programming/2019-04-28-domain_driven_design_06/03.png&quot; alt=&quot;03.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또 다른 예로는 생성된 객체를 소유하지는 않지만 다른 객체를 만들어내는 것과 &lt;strong&gt;밀접한 관련이 있는 특정 객체에 Factory 메서드를 두는 것이다.&lt;/strong&gt; 이렇게 하면 한 객체의 데이터나 규칙이 객체를 생성하는데 큰 영향을 주는 경우 클라이언트에서 해당 객체를 생성할 때 필요로 하는 정보의 양을 줄일 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/programming/2019-04-28-domain_driven_design_06/04.png&quot; alt=&quot;04.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림에서 TradeOrder 객체와 Brokerage Account 객체는 같은 Aggregate를 구성하지는 않지만 Brokerage Account 객체가 TradeOrder 객체를 생성함에 있어서 충분한 정보를 가지고 있으므로 Factory 메서드를 둘 수 있다.&lt;/p&gt;

&lt;p&gt;Factory는 해당 Factory에서 생성되는 객체와 매우 강하게 결합되므로, &lt;strong&gt;자신의 생성하는 객체와 가장 밀접한 관계에 있는 객체에 있어야 한다.&lt;/strong&gt; 생성 과정이 복잡하여 여러 프로그램 요소가 개입되는 경우, 비록 자연스럽게 보이지는 않더라도 별도의 Factory 객체나 Service를 만들어야 한다. 이런 독립형 Factory는 전체 Aggregate를 생성하여 (불변식은 지켜지고) 루트에 대한 참조를 리턴할 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/programming/2019-04-28-domain_driven_design_06/05.png&quot; alt=&quot;05.png&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;특정 Aggregate 안의 어떤 객체가 Factory를 필요로 하는데, Aggregate 루트가 해당 Factory가 있기에 적절하지 않다면 독립형 Factory로 만들면 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;생성자만으로-충분한-경우&quot;&gt;생성자만으로 충분한 경우&lt;/h3&gt;

&lt;p&gt;때로는 직접적으로 생성자를 이용하여 객체를 생성하는 것이 최선의 선택일 때가 있다. 특히 Factory는 &lt;strong&gt;다형성을 활용하지 않는 간단한 객체를 이해하기 어렵게 만들 수 있다.&lt;/strong&gt; 반대로 생성자를 사용하는 편이 좋은 상황은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;클라스가 타입인 경우, 클래스가 어떤 계층 구조의 일부를 구성하지 않으며 인터페이스를 구현하는 식으로 다형적으로 사용되지 않는 경우&lt;/li&gt;
  &lt;li&gt;클래스가 Strategy, 즉 전략 패턴을 위해 구현체에 관심이 있는 경우&lt;/li&gt;
  &lt;li&gt;클라이언트가 이미 객체의 속성을 모두 이용할 수 있고, 노출된 생성자 내에서 객체 생성 구현이 중복되지 않는 경우&lt;/li&gt;
  &lt;li&gt;생성자가 복잡하지 않은 경우&lt;/li&gt;
  &lt;li&gt;공개 생성자가 Factory가 동일한 규칙을 준수하는 경우. 마찬가지로 생성자로 객채 생성시에도 불변식은 충족시켜야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;다른 클래스의 생성자 내에서 생성자를 호출하지 않도록 한다. 생성자는 극도로 단순해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;인터페이스-설계&quot;&gt;인터페이스 설계&lt;/h3&gt;

&lt;p&gt;Factory의 메서드를 설계할 때는 Factory가 어떤 형태이든지 상관없이 다음의 두 가지 사항을 명심해야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;각 연산은 원자적이어야 한다.
    &lt;ul&gt;
      &lt;li&gt;복잡한 객체를 생성하기 위해 필요한 모든 것들을 한 번에 전달해야 한다.&lt;/li&gt;
      &lt;li&gt;생성이 실패할 경우에 대해서도 대비를 해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Factory는 자신에게 전달된 인자와도 결합된다.
    &lt;ul&gt;
      &lt;li&gt;입력 매개변수 타입이나 클래스에 대해서 결합이 생기게 된다.&lt;/li&gt;
      &lt;li&gt;구체적인 클래스가 아닌 추상적인 타입의 인자를 사용하도록 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;불변식-로직의-위치&quot;&gt;불변식 로직의 위치&lt;/h3&gt;

&lt;p&gt;Factory의 책임은 그것이 만들어내는 객체나 Aggregate의 불변식이 충족되도록 보장하는 것이다. 자기 자신이 직접 불변식을 검사할 수도 있지만, 간혹 생성된 객체에 위임할 수도 있다. 특히 &lt;strong&gt;각 도메인 객체 각각 내부에서 불변식을 검사하는 것이 더 깔끔할 때이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예를 들면 Entity를 생성할 때, Entity 식별성을 위해 사용하는 값은 Entity 내부에서 검사하는 것이 좋을 수 있다.&lt;/p&gt;

&lt;p&gt;그 외에 해당 객체가 활동하는 생애 동안 결코 수행되거나 적용되지 않을 불변식 로직을 객체에 위치시킬 필요는 없다. 이 때는 Factory가 불변식을 둘 논리적인 위치가 되며, 객체는 더 단순하게 유지될 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;entity-factory와-value-object-factory&quot;&gt;Entity Factory와 Value Object Factory&lt;/h3&gt;

&lt;p&gt;Entity Factory와 Value Object Factory는 두 가지 점에서 다른데, Value Object가 불변적이고, Entity는 식별성을 가진다는 차이에 기인한다.&lt;/p&gt;

&lt;p&gt;특히 Entity는 식별성을 위해 식별성 할당이 필요하므로 그런 식별자를 관리하기에는 Factory가 적절한 곳이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;저장된-객체의-재구성&quot;&gt;저장된 객체의 재구성&lt;/h3&gt;

&lt;p&gt;Factory는 특정 객체의 생명주기의 초반에 해당하는 부분에 관여하지만, 객체를 재구성할 때 (DB에서 데이터를 읽어 객체를 생성하는 등)도 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;객체를 재구성할 때 사용되는 Factory는 객체 생명주기의 초반에 관여하는 Factory와 유사하지만 주된 차이점은 아래의 두 가지가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;재구성에 사용되는 Entity Factory는 식별성을 위해 새로운 ID를 할당하지 않는다.&lt;/li&gt;
  &lt;li&gt;객체를 재구성하는 Factory는 불변식 위반을 다른 방식으로 처리해야 한다.
    &lt;ul&gt;
      &lt;li&gt;새로운 객체를 생성할 경우에는 단순히 객체 생성을 멈추면 되지만, 재구성할 때의 불변식 위반은 좀 더 탄력적으로 대응해야 된다. 가령 DB의 데이터 정합성이 맞지 않거나 일시적인 오류가 원인일 수도 있기 때문이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Factory는 모델의 어떤 부분도 표현하지는 않지만 해당 모델을 나타내는 객체를 뚜렷하게 드러내는 데 일조하는 도메인 설계의 일부로 볼 수 있다. Factory는 객체의 생성과 재구성이라는 생명주기 전이를 캡슐화한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;repository&quot;&gt;Repository&lt;/h2&gt;

&lt;p&gt;연관관계를 통해 다른 객체와의 관계에 근거하여 특정 객체에 접근할 수도 있지만, 객체의 생명주기 중간에도 Entity나 Value를 탐색하기 위핸 진입점이 존재해야 한다.&lt;/p&gt;

&lt;p&gt;객체를 이용해 무언가를 하려면 해당 객체에 대한 참조를 가지고 있어야 한다. 이를 위해 객체를 직접 생성해서 참조를 획득하거나, 객체 간의 연관관계를 탐색하여 필요한 객체의 참조를 얻는 방법이 있다. &lt;strong&gt;어쨋든 필요한 객체를 찾기 위한 진입점이 되는 첫 번째 객체가 있어야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;그리고 대부분의 객체 내용을 관계형 데이터베이스에 저장하는 경우가 많다. 데이터베이스에 저장된 데이터를 토대로 객체로 구성하여 사용하기 위해서, 데이터베이스 질의를 수행하여 데이터를 찾아 객체에 대한 참조를 획득하는 방법도 필요하다.&lt;/p&gt;

&lt;p&gt;객체 참조를 획득함에 있어서 탐색을 제공할 것이냐, 검색에 의존할 것이냐가 설계 결정이 되며, 연관관계의 응집성과 검색의 분리는 상충관계에 있다. 예를 들어 데이터베이스에서 조회한 Customer 객체를 통해 (Order 컬렉션을 필드로 가지고 있는) Order를 접근해야 하는가? 아니면 CustomerID를 통해 데이터베이스에서 직접 Order를 검색해야 하는가?&lt;/p&gt;

&lt;p&gt;기술적 관점에서 보면 저장된 객체를 가져오는 것은 실제로는 생성의 한 부분집합이다. 데이터베이스에서 가져온 데이터를 토대로 객체를 생성하기 때문이다. 하지만 개념상 객체의 생명주기 가운데 &lt;strong&gt;중간 단계에 불과하다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;데이터-중심의-구현이-안좋은-점&quot;&gt;데이터 중심의 구현이 안좋은 점&lt;/h3&gt;

&lt;p&gt;도메인 주도 설계의 목표는 기술보다는 &lt;strong&gt;도메인에 대한 모델에 집중하여 더 나은 소프트웨어를 만들어내는 것이다.&lt;/strong&gt; 개발자가 직접 SQL 질의문을 구성하여 인프라스트럭처 계층의 관련 서비스에 전달하고, 테이블 행의 결과집합을 획득하여 필요한 정보를 꺼내 직접 생성자나 Factory로 전달할 때쯤이면 &lt;strong&gt;모델에 집중하기 힘들어진다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;특히 클라이언트 코드에서 직접적으로 데이터베이스를 이용하고 데이터베이스의 데이터를 다룰수록 개발자들은 Aggregate나 캡슐화와 같은 특징을 활용하는 것을 우회하려 하고 직접 조작하려하는 유혹에 빠진다. 필요도 없는 연관관계를 추가할 수도 있다. 이럴 경우 점점 많은 도메인 규칙이 SQL 질의 코드로 들어가거나 그냥 사라져 버린다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;도메인 객체의 참조를 쉽게 획득하도록, 특히 Aggregate 내부의 객체 참조를 쉽게 획득하게 해준다면 기껏 Aggregate 개념을 추가한게 무색해질만큼 모델을 엉망으로 만들고 불변식을 훼손할 수 있다. &lt;strong&gt;도메인 로직은 질의나 클라이언트 코드로 들어가고 Entity나 Value Object는 단순히 데이터 홀더로서의 역할로 끝나게 될 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Aggregate 내부에 존재하는 모든 객체는 루트에서 탐색을 토대로 접근하는 것 말고는 접근해서는 안된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;영속 객체는 해당 객체의 속성에 근거하여 검색하는 식으로 전역적으로 접근할 수 있어야 하지만, 그러한 접근 방식이 필요한 곳은 탐색으로 찾기에는 쉽지 않은 Aggregate의 루트만으로 한정해야 한다.&lt;/strong&gt; 마음대로 데이터베이스에 질의를 수행하면 실제로 도메인 객체와 Aggregate의 캡슐화가 깨질 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Repository 패턴은 이를 해결하고 개발자로 하여금 다시 모델에 집중할 수 있도록 개념적 틀에 해당한다.&lt;/strong&gt; &lt;strong&gt;Repository는 특정 속성에 근거하여 요청된 객체를 가져오며 데이터베이스 질의 및 메타데이터 매핑에 대한 장치를 캡슐화한다.&lt;/strong&gt; 이를 통해 클라이언트는 단순해지고 인터페이스를 통해 소통하며 &lt;strong&gt;모델 측면에서 필요로 하는 것들을 요청할 수 있게 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Repository를 통해 실제로 데이터 저장소에 데이터를 저장하고 제거하는 연산을 캡슐화하고, 외부에서 직접 접근 가능한 Aggregate의 루트에 대해서만 Repository를 제공해야 한다. 모든 객체 저장과 접근은 Repository에 위임하여 클라이언트가 모델에 집중하도록 해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;repository에-질의하기&quot;&gt;Repository에 질의하기&lt;/h3&gt;

&lt;p&gt;가장 만들기 쉬운 Repository는 질의에 구체적인 매개변수룰 직집 전달하는 것이다. 식별자를 기준으로 Entity를 조회하거나 특정 속성 값을 가지는 객체 컬렉션 요청이 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/programming/2019-04-28-domain_driven_design_06/06.png&quot; alt=&quot;06.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Repository를 통해 질의를 하는 한 가지 특별한 접근법은 Specification(명세)에 기반을 둔 질의를 사용하는 것이다. 이 명세를 이용해 클라이언트는 질의의 획득 방법에는 신경쓰지 않고도 원하는 바를 서술할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/programming/2019-04-28-domain_driven_design_06/07.png&quot; alt=&quot;07.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;클라이언트-코드가-repository-구현을-무시한다&quot;&gt;클라이언트 코드가 Repository 구현을 무시한다.&lt;/h3&gt;

&lt;p&gt;영속화 기술을 Repository를 통해 캡슐화하면 클라이언트가 매우 단순해지고, Repository 구현에서 완전히 분리된다. 그러나 캡슐화가 종종 그렇듯이 &lt;strong&gt;개발자들은 캡슐화를 한 내부 구현에서 무슨 일이 일어나는지는 반드시 파악하고 있어야 한다.&lt;/strong&gt; Repository가 의도하지 않은 방식으로 사용되거나 작동한다면 수행 성능이 극단에 치우칠 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;repository-구현&quot;&gt;Repository 구현&lt;/h3&gt;

&lt;p&gt;구현은 영속화에 사용되는 기술과 인프라스트럭처에 따라 매우 다양하겠지만 이상적인 모습은 &lt;strong&gt;클라이언트로부터 모든 내부 기능을 숨기고 어떤 기술을 사용하느냐에 상관없이 클라이언트 코드를 동일하게 유지하는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;저장, 조회, 질의 매커니즘을 캡슐화하는 것은 Repository 구현의 가장 기본적인 기능이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/programming/2019-04-28-domain_driven_design_06/08.png&quot; alt=&quot;08.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림처럼 TradeOrder 객체를 조회함에 있어서 식별자(ID)를 통해 Repository에 전달하고, 필요한 SQL문으로 질의하고, 객체로 재구성하는 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;Repository를 구현함에 있어서 명심해야 할 몇 가지 중요한 사항이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;타입을 추상화한다.
    &lt;ul&gt;
      &lt;li&gt;특정 타입의 인스턴스를 Repository가 담기는 하지만, 이것이 각 클래스마다 하나의 Repository가 필요하다는 것은 아니다.&lt;/li&gt;
      &lt;li&gt;타입은 상황에 따라 인터페이스가 될 수도 있고, 추상 상위 클래스가 될 수도 있고 구현 클래스가 될 수도 있다.&lt;/li&gt;
      &lt;li&gt;사용하는 영속화 기술에 따라 다형성이 제약될 수도 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클라이언트와의 분리를 활용한다.
    &lt;ul&gt;
      &lt;li&gt;클라이언트와 영속화 기술을 분리함으로써 더 자유롭게 Repository의 구현을 변경할 수 있도록 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;트랜잭션 제어를 클라이언트에 둔다.
    &lt;ul&gt;
      &lt;li&gt;불변식을 제어하는 트랜잭션의 시작와 끝은 클라이언트가 잘 알고 있다. 클라이언트에 올바르게 단위 작업을 시작하고 커밋하는 컨텍스트가 있기 때문이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;factory와의-관계&quot;&gt;Factory와의 관계&lt;/h3&gt;

&lt;p&gt;Factory가 객체 생애의 초기 단계를 다루는 데 반해, Repository는 중간 단계(재구성)와 마지막 단계(삭제)를 관리한다.&lt;/p&gt;

&lt;p&gt;데이터베이스로부터 데이터를 읽어 객체를 생성하므로 Repository를 Factory로 생각할 수도 있는데, 기술적 관점에서는 그렇다고 볼 수 있다. 그러나 &lt;strong&gt;모델을 중심으로 생각했을 때는 저장된 객체를 재구성하는 것이 실질적으로 새로운 객체를 생성하는 것은 아니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;도메인 주도 관점에서 봤을 때는 &lt;strong&gt;Repository와 Factory의 책임이 뚜렷이 구분되는데, Factory가 새로운 객체를 만들어 내는 데 반해 Repository는 기존 객체를 찾아낼 뿐이다.&lt;/strong&gt; 클라이언트 입장에서는 Repository를 통해 기존 객체를 찾는 것처럼 보여야 한다. 이런 객체는 그 객체 생명주기 상에서 중간 단계에 해당한다.&lt;/p&gt;

&lt;p&gt;다만 다음과 같이 Repository가 Factory로 데이터베이스로부터 읽은 데이터를 전달하여 객체 인스턴스 생성을 위임할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/programming/2019-04-28-domain_driven_design_06/09.png&quot; alt=&quot;09.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사람들이 Factory와 Repository를 합쳐서 생각하게 만드는 또 한 가지 경우는 “데이터베이스에서 찾아서 없으면 생성하는” 기능을 원할 때다. 이 기능은 사용하는 것을 자제해야 한다. 기껏해야 조금 더 편리할 뿐이다. 일반적으로 &lt;strong&gt;새로운 객체와 이미 존재하는 객체를 구분하는 것은 도메인에서 중요하다.&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 28 Apr 2019 00:00:00 +0000</pubDate>
        <link>https://dhsim86.github.io/programming/2019/04/28/domain_driven_design_06-post.html</link>
        <guid isPermaLink="true">https://dhsim86.github.io/programming/2019/04/28/domain_driven_design_06-post.html</guid>
        
        <category>DDD</category>
        
        <category>Domain</category>
        
        <category>Domain Driven Design</category>
        
        
        <category>Programming</category>
        
      </item>
    
      <item>
        <title>도메인 주도 설계 05 - 소프트웨어에서 표현되는 모델</title>
        <description>&lt;p&gt;Model Driven Design의 효과를 놓치지 않으면서 구현과 조화를 이루려면 기본적인 사항을 재구성할 필요가 있다. &lt;strong&gt;모델과 구현은 상세 수준에서 연결되어야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;도메인 개념을 담은 객체를 정의하는 일은 겉으로는 매우 쉬워보이지만 의미 상의 미묘한 차이로 발생할 수 있는 중대한 문제가 잠재되어 있다. &lt;strong&gt;각 모델 요소의 의미를 명확하게 하고, 특정 종류의 객체를 도출하기 위해 설계에 부합하는 일정한 구분법이 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;어떤 객체가 연속성과 식별성을 지니고 있는가? -&amp;gt; Entity&lt;/li&gt;
  &lt;li&gt;다른 무언가의 상태를 기술하는 속성에 불과한가? -&amp;gt; Value Object&lt;/li&gt;
  &lt;li&gt;상태보다는 행동이나 연산으로 명확히 표현되는 것 -&amp;gt; Service
    &lt;ul&gt;
      &lt;li&gt;상태를 주고받지는 않는 활동을 모델링하는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이런 기본 요소들은 관례적인 것으로, 그 개념을 따르는 모델링과 설계 경향에 대해서 예전부터 책이나 문헌으로 존재하였다. 그러한 개념에 맞게 더 규모가 큰 모델과 설계 문제를 다룰 때 개발자들이 도메인 주도 설계의 우선순위에 부합하는 세부 구성요소를 만드는데 도움이 될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;연관관계&quot;&gt;연관관계&lt;/h2&gt;

&lt;p&gt;모델링과 실제 구현 간의 상호작용은 여러 객체 간의 연관관계에서 특히 까다롭다.&lt;/p&gt;

&lt;p&gt;서로 다른 모델 객체끼리는 연관관계가 있다. 어느 두 사물들끼리의 연관관계를 나타내는 것은 두 사물에 관계된 것이다. 그러한 모델은 개발자가 실제 사물끼리의 관계를 추상화한 것이기도 하다.&lt;/p&gt;

&lt;p&gt;일대다(one-to-many) 연관관계는 어느 인스턴스 변수에 필드로서 컬렉션을 두는 것으로 구현할 수 있다. 반드시 그렇게 되는 것은 아니며, 컬렉션이 없이 접근자 메서드에서 직접 데이터베이스를 조회하여 적절한 레코드를 찾은 다음 해당 레코드를 토대로 객체를 인스턴스화할 수도 있다. &lt;strong&gt;어떤 형태로 구현하든 그러한 행위는 모델 내의 연관관계와 일치해야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;현실세계에는 수많은 다대다(many-to-many) 연관관계가 있는데, 상당수가 양방향 연관관계로 나타난다. 초기 도메인 모델링의 결과인 모델도 그와 같은 경향을 보인다. 이러한 일반적인 형태의 연관관계는 구현과 유지보수를 복잡하게 만든다.&lt;/p&gt;

&lt;p&gt;연관관계를 좀더 쉽게 다루는 방법으로 아래의 세 가지가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;탐색 방향을 부여한다.&lt;/li&gt;
  &lt;li&gt;한정자(qualifier)를 추가하여 사실상 다중성(multiplicity)를 줄인다.&lt;/li&gt;
  &lt;li&gt;중요하지 않은 연관관계를 제거한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;가능한 한 관계를 제약하는 것이 중요하다.&lt;/strong&gt; 양방향 연관관계는 두 객체가 모두 있어야만 이해할 수 있다. 애플리케이션의 요구사항에 두 방향을 모두 탐색해야 한다는 요건이 없을 경우에는, 어느 한 방향으로만 탐색 방향을 추가하면 상호의존성이 줄어들고 설계가 단순해진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/programming/2019-04-28-domain_driven_design_05/00.png&quot; alt=&quot;00.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;국가와 역대 대통령에 대한 관계를 표현할 수 있는데, 이는 일대다 관계로 연관관계를 단순화시킬 수 있다. 대통령 이름으로 ‘이 대통령이 있던 나라가 어디입니까?’ 라고 물어보지는 않는다. 위와 같이 단방향으로 탐색 방향을 제한함으로써 &lt;strong&gt;설계가 단순해지고 도메인에 통찰력(연관관계에서 어느 특정 방향이 다른 것에 비해 더 의미있고 중요하다는 점)을 반영하게 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;어떤 탐색 방향은 도메인의 본연적인 특성을 드러낸다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;도메인을 깊이있게 이해하다보면 자주 &lt;strong&gt;한정적인&lt;/strong&gt; 관계에 이른다. 대통령은 특정 시점에 한 명의 대통령만이 있다. 따라서 이러한 중요한 도메인 규칙을 명시적으로 모델에 포함시킨다면 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/programming/2019-04-28-domain_driven_design_05/01.png&quot; alt=&quot;01.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 일대다와 같은 다중성을 일대일 관계로 제약하여 줄일 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;제약이 더해진 연관관계는 더 많은 도메인 지식과 실제적인 설계를 전해준다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위와 같은 방법들로 연관관계를 제약하면 훨씬 더 구현이 용이해진다. &lt;strong&gt;도메인의 특성이 드러나게끔 일관되게 제약하면 연관관계의 의사전달력이 더욱 풍부해지고 구현이 단순해진다.&lt;/strong&gt; 복잡한 다대다 관계를 구현하기 쉬운 일대다 관계로 바꿀 수 있으며, 한정자를 통해 다중성을 줄일 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;물론 양방향 연관관계가 도메인에 있어서 의미가 있고 애플리케이션의 요구사항에도 부합한다면 유지해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;중요한 의미를 담고 있지 않는 연관관계라면 완전히 제거하는 것이 좋다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;제약조건은 모델과 구현에 포함되어 있어야 한다. 그와 같은 제약조건은 모델을 더 정확하게 하고, 구현을 더욱 쉽게 유지보수할 수 있도록 해준다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;entity-엔티티&quot;&gt;Entity (엔티티)&lt;/h2&gt;

&lt;p&gt;수많은 객체는 본질적으로 해당 객체의 속성이 아닌 &lt;strong&gt;연속성과 식별성이 이어지느냐를 기준으로 정의된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;많은 것들이 속성이 아닌 식별성에 의해 정의될 수 있다. ‘사람’을 나타내는 객체는 여러 시스템에서 그 객체의 형태가 각기 다를 수 있지만, 동일한 사람인지 아니면 다른 사람인지 파악알 필요가 있다. 이러한 &lt;strong&gt;개념적 식별성은 객체와 해당 객체의 저장 형태, 구현 사이에서 일치해야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;객체 모델링을 할 때 속성에 집중하곤 하는데, &lt;strong&gt;Entity의 근본적인 개념은 객체의 생명주기 내내 이어지는 추상적인 연속성이며 그러한 추상적인 연속성은 여러 형태를 거쳐 전달된다는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이러한 객체는 객체의 속성을 자신의 주된 정의로 삼지 않는다. 오랜 시간에 걸쳐 작용하는 식별성의 이어짐이 나타나며, 그 형태는 종종 다르게 나타나기도 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;어떤 객체를 일차적으로 해당 객체의 식별성으로 정의할 경우 그 객체를 Entity(엔티티)라고 한다.&lt;/strong&gt; Entity는 자신의 생명주기 동안 형태와 내용은 바뀌더라도 연속성은 유지해야 한다. 이런 객체를 추적하기 위해서는 식별성이 정의되어 있어야 한다. &lt;strong&gt;Entity의 클래스 정의와 책임, 속성, 연관관계는 Entity의 특정 속성보다는 정체성에 초첨을 맞추어야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Entity는 생명 주기 내내 이어지는 연속성과 애플리케이션 사용자에게 중요한 속성과는 다른 독립적인 특징을 가진 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;모델 내의 모든 객체가 의미있는 식별성을 지닌 Entity인 것은 아니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;한 객체가 속성보다는 식별성으로 구분될 경우 모델 내에서 이를 해당 객체의 주된 정의로 삼아야 한다.&lt;/strong&gt; 클래스 정의를 단순히 하고 생명주기의 연속성과 식별성에 집중해야 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;식별성을 주된 정의로 삼고, 집중하기 위해 객체의 형태나 이력에는 상관없이 각 객체를 구별하기 위한 수단이 있어야 한다. 이러한 식별 수단의 구현 방법은 여러가지가 있겠지만 모델에서 이 식별성을 구분하는 방법과 일치해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;식별성은 원래 세상에 존재하는 것이 아닌, 필요에 의해 보충된 의미이다. 현실세계의 같은 사물을 표현한 것일지라도 도메인 모델에서 Entity로 표현되거나 표현되지 않을 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;entity-모델링&quot;&gt;Entity 모델링&lt;/h3&gt;

&lt;p&gt;객체를 모델링할 때 속성에 관해 생각하는 것은 자연스러운 일이며, 객체의 행위에 관해 생각해보다는 것은 아주 중요하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Entity의 가장 기본적인 책임은 객체의 행위가 명확하고 예측 가능하도록 연속성을 확립하는 것이다.&lt;/strong&gt; Entity를 모델링할 때, 속성이나 행위에 집중하기 보다는 가장 본질적인 특징(Entity를 식별하고 탐색하여 일치시키는데 사용하는)만으로 정의한다. 개념에 필수적인 것만 추가하고 그 행위에 필요한 속성만 추가한다.&lt;/p&gt;

&lt;p&gt;그 밖의 것들은 행위나 속성을 검토하여 Entity와 연관관계에 있는 다른 객체로 옮기도록 한다. 이들은 다른 Entity가 되거나 Value Object가 될 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/programming/2019-04-28-domain_driven_design_05/02.png&quot; alt=&quot;02.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 그림에서 customerID는 Entity의 유일한 식별자이며, 전화번호와 주소(contact phone, contact address)는 이러한 Customer를 찾거나 일치 여부를 판단하는 데 사용된다. 이름(name)은 한 사람의 식별성을 정의하지는 않지만 간혹 식별성을 판단하는 수단의 일부로 사용되기도 한다.&lt;/p&gt;

&lt;p&gt;이에 따라 이름, 연락처 같은 속성을 Customer로 옮겼지만 그 것은 어느 두 Customer 간의 식별성을 파악하기 위해 옮긴 것이다. 만약 Customer에 여러 전화번호가 있고 그 번호가 식별성과 관련이 없다면 Sale Contact에 그대로 있어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;식별-연산의-설계&quot;&gt;식별 연산의 설계&lt;/h3&gt;

&lt;p&gt;각 Entity에는 다른 객체와 구분해줄 식별성을 만들어낼 수 있는 수단이 있어야 한다. 식별에 사용되는 속성은 시스템의 상태와 관계없이 해당 시스템에서 유일해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;식별성에 대한 정의는 모델로부터 나온다. 따라서 식별성을 정의하려면 도메인을 이해해야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;value-object-값-객체&quot;&gt;Value Object (값 객체)&lt;/h2&gt;

&lt;p&gt;개념적 식별성이 없는 객체도 많은데, 이러한 객체는 사물의 어떤 특징을 묘사한다.&lt;/p&gt;

&lt;p&gt;보통 식별성을 정의하고 추적 및 관리하기 위해서는 분석적인 노력이 필요하다. 그런데 식별성이 필요없는 객체에 대해서도 일괄적으로 식별성을 도입할 경우 오해를 불러 일으킬 수 있다는 점이다.&lt;/p&gt;

&lt;p&gt;Entity의 식별성을 관리하는 일은 매우 중요하지만, &lt;strong&gt;식별성이 필요없는 그 밖의 객체에 대해서 식별성을 추가한다면 시스템의 성능이 저하되고, 분석작업이 별도로 필요하며, 모든 객체를 동일한 것으로 보이게 해서 모델이 혼란스러워질 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이러한 식별성이 필요하지 않은 객체는 사물을 서술하는 객체로, 모델에 중요한 의미를 갖고 있다. &lt;strong&gt;개념적 식별성을 갖지 않으면서 도메인의 서술적 측면을 나타내는 객체를 Value Object라고 부른다.&lt;/strong&gt; 이러한 객체는 이 객체가 어느 것인지에 대해서는 관심이 없고, 무엇인지에 대해서만 관심이 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;모델에 포함되는 요소들 중, 속성을 기술하는 데 중점을 둔다면 그것은 Value Object로 분류해야 한다.&lt;/strong&gt; 속성의 의미를 잘 표현할 수 있도록 구현하고, 관련 행위나 기능을 부여하라. 그리고 Value Object는 아무런 식별성도 부여하지 말고, &lt;strong&gt;불변적&lt;/strong&gt;으로 다루어야 한다.&lt;/p&gt;

&lt;p&gt;Value Object는 다른 객체를 속성으로 가지거나 풍부한 기능을 가질 수도 있으며, Entity를 참조할 수도 있다. 다만 식별성을 가지는 것이 의미가 없는 객체일 뿐이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Value Object는 여러 객체 간에 오가는 메시지의 매개변수로 사용되기도 하며, 어떤 연산에서 임시로 사용할 목적으로 만들어 진 후 폐기되기도 한다. 또한 Entity이나 또다른 Value Object의 속성으로 사용되기도 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Value Object를 구성하는 속성은 &lt;strong&gt;개념적 완정성&lt;/strong&gt;을 형성해야 한다. 예를 들어 다음과 같은 그림의 왼쪽과 같이 Customer 객체에서 street, city, state와 같은 주소를 나타내는 속성은 개별 속성으로 표현되어서는 안된다. 이런 속성들은 오른쪽과 같이 하나의 완전한 Address(주소)를 구성함으로써 &lt;strong&gt;더 단순한 Customer와 더 응집력 있는 Value Object를 만들어낸다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/programming/2019-04-28-domain_driven_design_05/03.png&quot; alt=&quot;03.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;value-object의-설계&quot;&gt;Value Object의 설계&lt;/h2&gt;

&lt;p&gt;Value Object를 사용함에 있어서 인스턴스의 복사나 공유, 불변성에 대한 의사결정이 필요하다.&lt;/p&gt;

&lt;p&gt;두 사람의 이름이 같다고 해서 두 사람이 동일 인물이 되는 것은 아니다. 그러한 이름을 나타내는 객체는 서로 바꿀 수 있는데, 이름에서는 &lt;strong&gt;오직 이름의 철자만이 중요하기 때문이다.&lt;/strong&gt; 따라서 어느 사람을 나타내는 Person 객체에서 두 번째 Person 객체로 Name 객체를 복사할 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 Person 객체에서 제각기 고유한 이름 인스턴스를 가질 필요도 없을지 모른다. 동일한 Name 객체는 두 Person 객체 간에 공유가 가능하며 두 Person 객체의 행위나 식별성은 아무것도 변경할 필요없다. 그런데 이 상황에서 어느 한 객체의 Name이 변경된다면 다른 사람의 이름까지 바뀌게 되므로 해당 객체는 불변적으로 다루어야 할 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 &lt;strong&gt;불변성은 한 객체가 해당 객체의 속성을 인자나 반환 값으로 다른 객체로 전달할 때 나타나는 문제를 방지할 수 있다.&lt;/strong&gt; 객체의 소유자가 제어하지 못하는 이러한 떠돌이 객체로 인해 &lt;strong&gt;소유자의 불변식이 훼손될 수 있으므로, 속성을 전달할 때 방어적 복사나 불변 객체로 전달하여 방지하는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;복사나 공유 중 어느 것이 경제성 면에서 더 나은지는 구현 환경에 따라 달라진다. 복사의 경우 객체의 개수가 매우 많아져 시스템이 무거워질 수 있다.&lt;/p&gt;

&lt;p&gt;Value Object가 불변적으로 다루어진다면 이 객체는 마음껏 공유할 수 있다. 달리 말하면, &lt;strong&gt;Value Object가 변경 가능하다면 공유해서는 안된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Value Object가 변경되는 것을 허용하는 경우는 새로운 Value Object를 매번 생성함으로서 나타나는 성능의 문제가 있을 경우에만 한해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;value-object를-포함한-연관관계-설계&quot;&gt;Value Object를 포함한 연관관계 설계&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;모델에 포함되는 요소들은 연관관계의 수가 적고 연관관계가 단순할수록 더 나은 모델이라 할 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Entity 간의 양방향 연관관계는 필요에 따라 존재할 수 있지만, Value Object 간의 양방향 연관관계는 논리적으로 타당하지 않다. 어떠한 객체가 식별성 없이 자신을 가리키는 동일한 Value Object를 역으로 가리키는 것은 아무런 의미가 없다. Value Object끼리의 양방향 연관관계에 대한 유용한 예도 별로 없다. 따라서 &lt;strong&gt;Value Object 간의 양방향 연관관계는 없다고 봐도 좋다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;service-서비스&quot;&gt;Service (서비스)&lt;/h2&gt;

&lt;p&gt;도메인 모델의 각 요소들 중 &lt;strong&gt;개념적으로 어떠한 객체에도 속하지 않는 연산이 포함될 때가 있다.&lt;/strong&gt; 이러한 연산은 특정 Entity나 Value Object의 연산이 아닌 경우이다.&lt;/p&gt;

&lt;p&gt;이런 연산은 본질적으로 사물이 아닌 &lt;strong&gt;활동&lt;/strong&gt;이나 어떠한 &lt;strong&gt;행동&lt;/strong&gt;인데 이러한 연산도 객체와 잘 어울리게끔 노력해야 한다.&lt;/p&gt;

&lt;p&gt;특정 Entity나 Value Object에 종속되지 않는 이러한 연산을 강제로 그 객체에 포함시킨다면 &lt;strong&gt;해당 객체는 자신의 개념적 명확성을 잃어버리고 이해하거나 리팩터링하기가 어려워진다.&lt;/strong&gt; 이럴 경우, 해당 객체의 역할을 불분명하게 만든다.&lt;/p&gt;

&lt;p&gt;또한 이러한 연산은 여러 도메인 객체를 모아 그것들을 조율해나가면서 어떤 행위를 일어나게 하므로, 그 연산을 특정 객체에 추가시킨다는 것은 그 객체가 다른 도메인 객체에 대한 의존성을 만들어낸다.&lt;/p&gt;

&lt;p&gt;이 연산의 특징은 &lt;strong&gt;자신의 상태를 비롯해 도메인에서 맡고 있는 연산 이상으로는 어떠한 의미도 가지지 않는 경우가 많다.&lt;/strong&gt; 이런 기능을 Entity나 Value Object에서 억지로 맡게 된다면 &lt;strong&gt;모델에 기반을 둔 객체의 정의가 왜곡되거나 무의미하고 인위적으로 만들어진 객체가 추가될 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Service는 모델에서 독립적인 인터페이스로 제공되는 연산으로 Entity나 Value Object와 같이 상태를 캡슐화하지는 않는다. 단지 행위만 모델링 할 뿐이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;서비스라는 이름은 다른 객체와의 관계를 강조하며, Entity나 Value Object와는 달리 정의하는 기준이 &lt;strong&gt;순전히 클라이언트에게 무엇을 제공할 수 있느냐에 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Service는 주로 활동으로 이름을 지으며, Service에 부여된 책임과 행위, 인터페이스는 도메인 모델의 일부로서 정의될 수 있다. 당연히 연산의 명칭은 Ubiquitous Language에서 가져와야 하며 Service의 매개변수와 결과는 도메인 객체여야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Service에서 구현되는 행위는 Entity나 Value Object에서 수행될 수 있는 행위여서는 안된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;잘 만들어지는 Service에는 아래의 세 가지 특징이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;연산이 원래부터 Entity나 Value Object의 일부를 구성하는 것이 아닌, 도메인 개념과 관련이 있다.&lt;/li&gt;
  &lt;li&gt;인터페이스가 도메인 모델의 외적 요소의 측면에서 정의된다.&lt;/li&gt;
  &lt;li&gt;연산이 상태를 갖지 않는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;도메인의 중요한 연산이나 과정이 Entity나 Value Object의 고유한 책임이 아니면 Service로 선언되는 독립 인터페이스로 모델에 추가시키도록 한다.&lt;/strong&gt; Service는 상태를 가져서는 안된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;service와-격리된-도메인-계층&quot;&gt;Service와 격리된 도메인 계층&lt;/h3&gt;

&lt;p&gt;Service는 도메인 계층에서만 이용되는 것이 아니다. &lt;strong&gt;도메인 계층에 속하는 Service와 다른 계층에 속하는 것들을 구분하고 그러한 구분을 분명하게 유지하는 책임을 나누는데 주의를 기울여야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;도메인 Service와 응용 Service는 인프라스트럭처 계층의 Service와 협업하도록 구현한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;응용 Service와 도메인 Service의 구분은 중요한 업무 규칙을 포함하고 있느냐 없느냐에 달려 있다. 인프라스트럭처 Service는 단순히 기술과 관련된 것만 구현하며 업무와 관련된 어떠한 것도 포함되어서는 안된다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;은행 시스템에서 서비스를 여러 계층으로 분할하기
    &lt;ul&gt;
      &lt;li&gt;응용 Service: 업무 규칙, 도메인 기능과 관련이 없음
        &lt;ul&gt;
          &lt;li&gt;사용자 입력의 암호화&lt;/li&gt;
          &lt;li&gt;고객에 이메일 발송&lt;/li&gt;
          &lt;li&gt;도메인 Service 호출 (도메인 객체의 행위를 조정)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;도메인 Service: 업무 규칙, 도메인 기능을 포함
        &lt;ul&gt;
          &lt;li&gt;자금 이체&lt;/li&gt;
          &lt;li&gt;계좌 잔고 확인&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;인프라스트럭처 Service: 기술적인 구현을 포함
        &lt;ul&gt;
          &lt;li&gt;애플리케이션에서 이메일이나 우편을 보내는 기술적인 내용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;도메인 Service를 적절히 도입하면 응용이나 도메인, 인프라스트럭처 계층 간의 경계를 선명하게 하는 데 도움될 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;모듈&quot;&gt;모듈&lt;/h2&gt;

&lt;p&gt;Module은 오래 전부터 확립되어 사용되고 있는 설계 요소다. &lt;strong&gt;Module 간에는 결합도가 낮아야 하고, Module의 내부는 응집도가 높아야 한다. Module로 쪼개지는 기준은 코드가 아닌 바로 개념이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;낮은 결합도와 높은 응집도는 개별 객체에서와 마찬가지로 Module에도 적용되는 일반적인 설계 원칙이며, 그 원칙은 구상 단위가 큰 모델링과 설계에서는 특히 중요하다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;적절히 선택된 Module은 특별히 개념적 관계가 풍부한 모델 요소를 한 곳으로 모아주는 역할을 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;도메인 주도 설계의 다른 모든 것들과 마찬가지로 Module도 하나의 의사소통 매커니즘이다. &lt;strong&gt;분할되는 객체의 의미에 따라 Module을 선택해야 한다. 일련의 응집력있는 개념들을 하나의 Module에 담아야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;객체의 가장 기본적인 개념 중 하나는 데이터와 해당 데이터를 대상으로 연산을 수행하는 로직을 캡슐화하는 것이다.&lt;/strong&gt; 하나의 개념적 객체를 구현하는 코드는 모두 같은 Module에 두어야 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;어떤 것의 개념이 도메인 객체와 밀접하게 관련되어 있지 않다면 그것을 도메인 객체에 추가해서는 안된다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 28 Apr 2019 00:00:00 +0000</pubDate>
        <link>https://dhsim86.github.io/programming/2019/04/28/domain_driven_design_05-post.html</link>
        <guid isPermaLink="true">https://dhsim86.github.io/programming/2019/04/28/domain_driven_design_05-post.html</guid>
        
        <category>DDD</category>
        
        <category>Domain</category>
        
        <category>Domain Driven Design</category>
        
        
        <category>Programming</category>
        
      </item>
    
      <item>
        <title>도메인 주도 설계 04 - 도메인의 격리</title>
        <description>&lt;p&gt;소프트웨어 구현을 건전한 상태로 유지하고, 모델과의 밀접한 관계를 유지하려면 모델링과 설계의 우수한 실천법을 적용해야 한다.&lt;/p&gt;

&lt;p&gt;훌륭한 도메인 모델을 개발하는 것은 일종의 예술이다. 그런데 &lt;strong&gt;모델의 개별 요소를 실제로 설계하고 구현할 때는 일정한 체계적인 방법으로 진행할 수 있다.&lt;/strong&gt; 일정한 구분법에 따라 모델 요소를 정의하면 모델 요소의 의미가 더욱 명확해진다. 또한 널리 입증된 패턴을 따른다면 구현에 실질적으로 도움이 되는 모델을 만드는데도 도움이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/programming/2019-04-25-domain_driven_design_04/00.png&quot; alt=&quot;00.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;도메인의-격리&quot;&gt;도메인의 격리&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;시스템에서 도메인과 관련이 적은 기능으로부터 도메인 객체를 분리해야 한다.&lt;/strong&gt; 그래야 도메인 개념을 다른 소프트웨어 기술에만 관련된 개념과 혼동하거나 시스템이라는 하나의 큰 덩어리에서 도메인을 전혀 바라보지 못하는 문제를 방지할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;개발자가 도메인 모델에 집중할 수 있도록 시스템의 수많은 관심사로부터 도메인 설계를 격리하면 모델과 설계의 관계는 훨씬 분명해질 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;layerd-architecture-계층형-아키텍처&quot;&gt;Layerd Architecture (계층형 아키텍처)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/programming/2019-04-25-domain_driven_design_04/01.png&quot; alt=&quot;01.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;소프트웨어에는 갖가지 작업을 수행하는 설계와 코드가 포함된다. 사용자 입력을 받아들이고, 비즈니스 로직을 수행하며, DB에 접근하고, 네트워크로 통신하며, 사용자에게 정보를 보여주는 등의 다양한 일을 수행한다. 따라서 이런 기능들과 관련된 코드의 양은 상당히 많을 수 있다.&lt;/p&gt;

&lt;p&gt;객체지향 프로그래밍에서는 간혹 UI와 데이터베이스, 기타 보조적인 성격의 코드를 비즈니스 객체에 직접 작성하기도 한다. 아니면 비즈니스 로직이 UI나 DB의 스크립트에 들어가기도 한다. 이런 일이 발생하는 이유는 단기적으로 이렇게 구현하는 것이 가장 쉬운 방법이기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;도메인과 관련된 코드가 도메인과 관련이 없는 코드를 통해 여기저기 흩어진다면, 도메인에 관련된 코드를 확인하고 이해하기가 상당히 어려워진다.&lt;/strong&gt; UI를 변경하는 것이 실제 비즈니스 로직을 변경하는 것으로 이어질 수도 있다. 업무 규칙을 이해하고자 UI나 DB 코드, 자잘한 요소들을 세심하게 추적해야 될 수 있다. 이러면 &lt;strong&gt;응집력 있고, 모델 주도적인 객체를 구현&lt;/strong&gt;하는 것이 비현실적이 된다. 기술과 로직이 모든 활동에 같이 포함되어 있다면 프로그램을 이해하기가 불가능해진다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;매우 복잡한 작업을 처리하는 소프트웨어를 작성할 때는 &lt;strong&gt;관심사의 분리&lt;/strong&gt;가 필요하며, 이를 통해 서로 격리된 각 설계 요소에 집중할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;보통 시스템을 분리하는 방법은 다양하지만 오랜 경험과 관례를 통해 &lt;strong&gt;Layered Architecture&lt;/strong&gt;라는 몇 개의 일반화된 계층이 널리 받아들여지고 있다. 계층화의 핵심은 &lt;strong&gt;한 계층의 모든 요소는 오직 같은 계층에 존재하는 다른 요소나 아래 계층에 위치한 요소에만 의존한다&lt;/strong&gt;라는 것이다.&lt;/p&gt;

&lt;p&gt;이러한 계층화의 가치는 &lt;strong&gt;각 계층이 프로그램의 특정 측면만을 전문적으로 다룬다는 데 있다.&lt;/strong&gt; 따라서 더욱 응집력 있는 설계가 가능해지며 설계를 훨씬 더 쉽게 이해할 수 있다.&lt;/p&gt;

&lt;p&gt;오랜 경험과 관례를 바탕으로 널리 받아들여지는 계층형 아키텍처는 보통 아래의 네 가지 개념적 계층으로 나뉜다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;표현 계층: 사용자에게 정보를 보여주고, 사용자의 명령을 해석하는 일을 책임진다.&lt;/li&gt;
  &lt;li&gt;응용 계층: 소프트웨어가 수행할 작업을 정의하고 표현력이 있는 도메인 객체가 문제를 해결하도록 한다.
    &lt;ul&gt;
      &lt;li&gt;보통 이 계층은 얇게 유지되는데, 업무 규칙이나 도메인 지식이 전혀 포함되지 않으며 오직 수행할 작업을 조정하고 도메인 계층에 포함되는 도메인 객체에 작업을 위임한다.&lt;/li&gt;
      &lt;li&gt;응용 계층은 업무 상황을 반영하는 상태가 존재하지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;도메인 계층: 업무 개념과 업무 상황에 대한 상태 관리, 업무 규칙을 표현하는 일을 책임진다.
    &lt;ul&gt;
      &lt;li&gt;업무 상황을 반영하는 상태를 제어하고 사용하며, 상태 저장과 관련된 기술적인 세부사항은 인프라스트럭처 계층에 위임한다.&lt;/li&gt;
      &lt;li&gt;소프트웨어의 핵심이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인프라스트럭처 계층: 상위계층을 지원하는 일반화된 기술적 기능을 제공한다.
    &lt;ul&gt;
      &lt;li&gt;메시지 전송이나 도메인 영속화 등이 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Model Driven Design을 가능케 하는 것은 결정적으로 도메인 계층을 분리하는 데 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;복잡한 프로그램을 여러 개의 계층으로 나누어야 한다. 응집력있고 오직 아래에 위치한 계층에만 의존하는 각 계층에서 설계를 발전시켜나가야 한다. 표준 아키텍처 패턴에 따라 각 계층은 다른 계층들과의 결합을 느슨하게 유지해야 한다. 깔끔한 관심사의 분리를 토대로 각 계층의 설계를 이해하고 유지하기가 쉬워진다.&lt;/p&gt;

&lt;p&gt;도메인 모델과 관련된 코드는 모두 도메인 계층으로 모으고, 사용자 인터페이스 코드나 애플리케이션 코드 (응용 계층 코드), 인프라스트럭처 코드로부터 격리시켜야 한다. &lt;strong&gt;그래야 도메인 객체는 도메인 모델을 표현하는 것에만 집중할 수 있다.&lt;/strong&gt; 이를 통헤 모델에 풍부하고 명확한 업무 지식을 반영할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;응용 계층이 아닌 도메인 계층에서 업무 규칙을 다루어야 한다. 응용 계층은 어느 한 작업을 정의만 할 뿐, 실질적인 비즈니스 로직은 도메인 계층에 위임한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;계층-간-관계-설정&quot;&gt;계층 간 관계 설정&lt;/h2&gt;

&lt;p&gt;각 계층은 설계 의존성을 오직 한 방향으로만 두어서 느슨하게 결합시켜야 한다. 상위 계층은 하위 계층의 공개된 인터페이스로 호출하여 하위 계층의 구성 요소를 사용할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;응용 계층과 도메인 계층에 UI를 연결하는 패턴은 Model-View-Controller, MVC 패턴에서 유래한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;인프라스트럭처 계층은 지원하는 도메인의 구체적인 업무 규칙이나 지식을 가져서는 안된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;아키텍처-프레임워크&quot;&gt;아키텍처 프레임워크&lt;/h2&gt;

&lt;p&gt;인프라스트럭처가 인터페이스를 통해 호출되는 Service 형태로 제공하면 계층화의 동작 방식과 각 계층이 느슨하게 결합되는 방식이 직관적으로 보여진다. 그런데 일부 기술적인 문제에서는 더욱 침습적인(intrusive) 형태의 인프라스트럭처가 필요하다. (예를 들면 스프링에서 AOP 형태로 제공하는 트랜잭션 기능이라든지)&lt;/p&gt;

&lt;p&gt;예전 J2EE에서처럼 특정 계층이 매우 특수한 방식으로 구현되기를 요구하기도 한다. 어느 특정 클래스의 하위 클래스가 되어야 한다거나 일정한 메서드 이름 규칙을 사용해야 하는 것처럼 말이다. &lt;strong&gt;가장 바람직한 아키텍처 프레임워크라면 도메인 개발자가 모델을 표현하는 것에만 집중할 수 있도록 복잡한 기술적 난제를 해결한다.&lt;/strong&gt; 스프링 프레임워크도 이를 따르는 애플리케이션 프레임워크로, DI나 AOP, 서비스 추상화 등을 통해 개발자가 비즈니스 로직에 집중할 수 있도록 해준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;도메인-계층은-모델이-살아가는-곳&quot;&gt;도메인 계층은 모델이 살아가는 곳&lt;/h2&gt;

&lt;p&gt;도메인 주도 설계에서는 오직 한가지 특정한 계층이 중요하다.&lt;/p&gt;

&lt;p&gt;도메인 모델은 일련의 개념을 모아놓은 것이다. &lt;strong&gt;도메인 계층은 그러한 모델과 설계 요소에 직접적으로 관계된 모든 것들을 명시한 곳이며, 업무 로직에 대한 설계와 구현으로 구성된다.&lt;/strong&gt; 도메인 로직이 프로그램 상의 다른 관심사와 섞여 있다면, 유연하게 유지보수나 요구사항 반영과 같은 대응을 달성하기가 쉽지 않다. &lt;strong&gt;도메인 주도 설계의 전제조건은 도메인 구현을 격리하는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;도메인-구현을-격리하지-않을-때&quot;&gt;도메인 구현을 격리하지 않을 때&lt;/h2&gt;

&lt;p&gt;도메인 구현을 다른 관심사와 분리하지 않고 개발한다면 다음과 같은 상황에 직면할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터베이스를 이용하는 방식 말고는 여러 애플리케이션을 통합하기가 수월하지 않다.&lt;/li&gt;
  &lt;li&gt;행위를 재사용하지 않으며, 업무 문제에 대해 추상화가 제대로 이루어지지 않는다. 각 연산마다 로직이 중복되는 경우가 생긴다.&lt;/li&gt;
  &lt;li&gt;추상화의 부재로 리팩터링의 여지가 제한될 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;도메인을 격리할 때의 가장 좋은 점은 부수적인 것을 배제하고 개발자로 하여금 도메인 설계에만 집중할 수 있다는 것이다.&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate>
        <link>https://dhsim86.github.io/programming/2019/04/25/domain_driven_design_04-post.html</link>
        <guid isPermaLink="true">https://dhsim86.github.io/programming/2019/04/25/domain_driven_design_04-post.html</guid>
        
        <category>DDD</category>
        
        <category>Domain</category>
        
        <category>Domain Driven Design</category>
        
        
        <category>Programming</category>
        
      </item>
    
      <item>
        <title>도메인 주도 설계 03 - 모델과 구현의 연계</title>
        <description>&lt;p&gt;프로젝트에 도메인 모델은 있지만, 동작하는 소프트웨어를 개발하는 데 직접적으로 도움을 주지 못한다면, 아무 의미가 없다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;model-driven-design&quot;&gt;Model Driven Design&lt;/h2&gt;

&lt;p&gt;코드와 그것의 기반이 되는 모델이 긴밀하게 연결되면 코드에 의미가 부여되고, 모델과 코드가 서로 대응하게 된다.&lt;/p&gt;

&lt;p&gt;도메인 모델이 전혀 없고 기능만 차례대로 구현하기 위해 코드를 작성하는 프로젝트에서는 지식 탐구와 의사소통의 이점을 거의 살리지 못한다.&lt;/p&gt;

&lt;p&gt;설계의 기반이 되는 개념이 부족한 소프트웨어는 소프트웨어의 행위를 설명하지 못한 채 그저 유익한 일을 수행하는 매커니즘 정도밖에 되지 못한다.&lt;/p&gt;

&lt;p&gt;설계 혹은 설계의 주된 부분이 도메인 모델과 대응하지 않는다면, 모델은 그다지 가치가 없으며 소프트웨어의 정확성도 의심스러워진다. 모델과 설계 기능 사이의 복잡한 대응은 이해하기가 힘들고 설계가 변경되면 유지보수도 불가능해진다. 분석과 설계가 동떨어지고, 그에 따라 각자의 활동에서 얻은 통찰력이 서로에게 전해지지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;소프트웨어를 설계할 때는 도메인 모델을 있는 그대로 반영하여 설계와 모델의 대응을 분명하게 해야한다.&lt;/strong&gt; 모델을 검토하여 자연스럽게 소프트웨어로 구현할 수 있도록 수정해나가야 하며, 공통 언어를 지원하는 것과 더불어 분석과 설계의 두 가지 측면을 충분히 만족하는 단 하나의 모델을 만들어야 한다.&lt;/p&gt;

&lt;p&gt;모델로부터 설계와 기본적인 책임 할당에 사용한 용어를 도출하고, 코드를 작성할 때 그러한 용어를 사용하면 코드가 모델을 표현한 것이 되고 코드의 변경이 모델의 변경으로 이어질 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;도메인 주도 설계는 모델을 동작하게 만들어 애플리케이션의 문제를 해결한다. 지식 탐구를 바탕으로 팀은 지식의 정수를 추출해 실제적인 모델을 만든다. Model Driven Design은 모델과 구현을 매우 밀접하게 연결한다. UBIQUITOUS Language는 개발자와 도메인 전문가, 소프트웨어 사이에 흐르는 모든 정보의 통로에 해당한다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate>
        <link>https://dhsim86.github.io/programming/2019/04/25/domain_driven_design_03-post.html</link>
        <guid isPermaLink="true">https://dhsim86.github.io/programming/2019/04/25/domain_driven_design_03-post.html</guid>
        
        <category>DDD</category>
        
        <category>Domain</category>
        
        <category>Domain Driven Design</category>
        
        
        <category>Programming</category>
        
      </item>
    
      <item>
        <title>도메인 주도 설계 02 - 의사소통과 언어사용</title>
        <description>&lt;p&gt;도메인 모델은 소프트웨어 프로젝트를 위한 공통 언어의 핵심이 될 수 있다. &lt;strong&gt;모델은 프로젝트에 참여한 사람들의 머릿속에 축적된 개념을 모아 놓은 것으로, 도메인에 대한 통찰력을 반영하는 용어와 관계로 표현된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이러한 용어와 상호관계는 도메인에 맞게 조정된 언어의 의미체계를 제공하며, 이는 모델을 개발 활동과 결부시키고 코드와 연계하는 데 매우 중요한 연결고리 역할을 한다.&lt;/p&gt;

&lt;p&gt;모델 기반의 의사소통은 UML의 다이어그램으로 한정되어서는 안되고, 모든 의사소통 수단에 스며들 필요가 있다. 이렇게 해야 형식에 얽매이지 않는 의사통을 이룰 수 있고, 개발 문서의 유용성도 향상된다. 또한 코드 자체 혹은 해당 코드의 테스트를 토대로 의사소통 향상을 꾀할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ubiquitous-language-보편-언어&quot;&gt;UBIQUITOUS LANGUAGE (보편 언어)&lt;/h2&gt;

&lt;p&gt;유연하고 풍부한 지식이 담긴 설계를 만들려면 다양한 용도로 사용될 수 있는 팀의 공유 언어와 그 언어에 대한 활발한 실험이 필요하다.&lt;/p&gt;

&lt;p&gt;도메인 전문가는 소프트웨어 개발에 사용되는 기술적인 전문 용어를 이해하는 데 한계가 있지만, 자신이 종사하는 분야의 전문 용어는 다양하게 사용할 것이다. 반면에 개발자는 시스템을 서술적이고 기능적인 용어로 이해하고 토론하겠지만 전문가들의 언어에 담긴 의미를 알지 못한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이렇게 언어적으로 어긋남으로써 생기는 문제로 서로가 모호하게 이해하고 이야기하게 되며, 이는 모델의 개념을 혼란스럽게 만들게 되고 해로운 코드 개발, 리팩터링으로 이어진다.&lt;/strong&gt; 즉, 조화가 깨진 신뢰할 수 없는 소프트웨어가 만들어지는 것이다.&lt;/p&gt;

&lt;p&gt;프로젝트에서 사용하는 언어가 분열, 즉 서로가 모호한 단어를 사용하거나 불분명한 문장으로 말하게 된다면 심각한 문제가 발생한다. 지식 탐구를 빈약하게 만들어내고, 도메인의 표현이 코드나 문서에도 담기지 않는 결과가 나타난다.&lt;/p&gt;

&lt;p&gt;프로젝트에서 서로가 의식적인 노력을 기울인다면, 도메인 모델이 서로가 이해하는 공통 언어의 근간을 제공하고 의사소통을 소프트웨어의 구현에 이르기까지 연결시킬 수 있다. &lt;strong&gt;도메인 모델을 공통 언어의 근간으로 사용한다면, 도메인을 원활하게 이해하고 더욱 쓸모 있는 모델을 만들어 낼 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;도메인 모델을 언어의 근간으로 사용하고, 팀 내의 모든 의사소통과 코드, 문서에 이르기까지 해당 언어를 공통으로 사용해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;한-팀-한-언어&quot;&gt;한 팀, 한 언어&lt;/h2&gt;

&lt;p&gt;설계에는 도메인 전문가와 관련없는 기술적인 요소도 있지만, 모델의 핵심은 도메인 전문가의 관심을 끌어야 한다. 도메인 전문가로부터 피드백을 받는 등의 협업을 통해 끊임없이 모델을 검증하면서 정제해나가야 되기 때문이다.&lt;/p&gt;

&lt;p&gt;UBIQUITOUS LANGUAGE가 마련되면, 개발자 간의 대화, 도메인 전문가 간의 논의, 코드 자체에까지 모든 것이 공유된 도메인 모델에서 비롯된 동일한 언어를 기반으로 사용한다.&lt;/p&gt;

&lt;p&gt;이를 통해 프로젝트에 참여한 인원끼리 의사소통을 원활히 할 수 있으며, 모호한 개념이 없는 정제된 풍부한 모델을 바탕으로 신뢰성있는 코드 구현에 도달할 수 있을 것이다.&lt;/p&gt;
</description>
        <pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate>
        <link>https://dhsim86.github.io/programming/2019/04/25/domain_driven_design_02-post.html</link>
        <guid isPermaLink="true">https://dhsim86.github.io/programming/2019/04/25/domain_driven_design_02-post.html</guid>
        
        <category>DDD</category>
        
        <category>Domain</category>
        
        <category>Domain Driven Design</category>
        
        
        <category>Programming</category>
        
      </item>
    
      <item>
        <title>도메인 주도 설계 01 - 지식 탐구</title>
        <description>&lt;h2 id=&quot;용어&quot;&gt;용어&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;모델: 어떤 대상을 단순화하고 해석하여 문제를 해결하는 것과 관련된 측면을 추상화한 것&lt;/li&gt;
  &lt;li&gt;도메인: 소프트웨어를 사용하는 대상 영역, 사용자의 활동이나 관심사와 관련되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;모델은 개발하는 데 있어서 사용자의 활동이나 관련된 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태이다. 개발팀은 사용자의 활동과 관련된 지식 체계에 집중해야 되는데, 그 폭이 너무 위압적일 수 있다. 모델은 그러한 부담을 해소하기 위한 도구이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;도메인 모델: 어떤 특정한 다이어그램이 아니라, 다이어그램이 전달하고자 하는 아이디어이다.
    &lt;ul&gt;
      &lt;li&gt;도메인 지식을 엄격하게 구성하고 선택적으로 추상화한 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;도메인 모델링은 가능한 “사실적인” 모델을 만드는 문제가 아니며, 핵심 개념을 포착하고 선택적으로 추상화하여 반영하는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;도메인-주도-설계에서의-모델의-유용성&quot;&gt;도메인 주도 설계에서의 모델의 유용성&lt;/h2&gt;

&lt;p&gt;도메인 주도 설계에서는 아래의 세 가지 기본적인 쓰임새에 따라 모델을 선택한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;모델과 핵심 설계는 서로 영향을 주며 구체화된다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;모델을 의미있게 만들고, 모델의 분석이 최종 산출물에 적용하게끔 보장하는 것은 &lt;strong&gt;모델과 그 구현 간의 긴밀한 연결&lt;/strong&gt;이다.
        &lt;ul&gt;
          &lt;li&gt;모델과 구현의 연결의 장점으로 계속되는 기능 개선에 도움이 되고 &lt;strong&gt;모델을 이해한 바에 의해 코드를 해석할 수 있다.&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;모델은 모든 팀 구성원이 사용하는 언어의 중추이다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;모델과 구현이 연결되어 있으므로, 개발자나 도메인 전문가 간에 의사소통하는 데에 있어서 제약이 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;모델은 지식의 정수만을 뽑아낸 것이다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;모델은 도메인 지식을 조직화하고 가장 중요한 요소를 구분하는 팀의 합의된 방식이다.&lt;/li&gt;
      &lt;li&gt;모델에는 우리가 용어를 선택하고 개념을 분류하며, 분류한 지식을 서로 연관시킬 때 도메인에 관한 사고방식이 담겨 있다.&lt;/li&gt;
      &lt;li&gt;개발자와 도메인 전문가는 공유 언어를 바탕으로 갖가지 정보를 모델로 만들어낼 때 효과적으로 협업할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;소프트웨어의 본질은 소프트웨어의 사용자를 위해 &lt;strong&gt;도메인과 관련된 문제를 해결하는 능력에 있다.&lt;/strong&gt; 개발자는 업무 지식을 증진하기 위해 &lt;strong&gt;도메인 연구&lt;/strong&gt;에 몰두해야 한다. 또한 모델링 기법을 연마하여 도메인 설계에 통달해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;도메인 연구를 통하여 개발자와 도메인 전문가 간의 의사소통을 원활히 한다면, 도메인 전문가는 모델이 의미하는 바와 동작하는 소프트웨어와 모델 간의 관계를 좀더 명확히 이해할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;효과적인-모델링-요소&quot;&gt;효과적인 모델링 요소&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;모델과 구현의 연계&lt;/strong&gt;: 프로토타입을 토대로 구현과 모델의 연결고리를 만들어 개발 반복 주기 내내 유지해야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;모델을 기반으로 하는 언어 정제&lt;/strong&gt;: 도메인 전문가와 개발자가 함께 모델을 정제해나감으로써, 프로젝트가 진행되면서 누구라도 모델에서 바로 용어를 끄집어내어 모델의 구조와 일관되게 문장을 구성하고 의사소통을 할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;풍부한 지식이 담긴 모델 개발&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;모델의 정제&lt;/strong&gt;: 연속적인 개발 반복 주기를 통해 모델을 계속 정제하여 중요한 개념이 녹아들 수 있도록 해야하며, 불필요한 개념은 제거해야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;브레인스토밍과 실험&lt;/strong&gt;: 공통 언어를 통해 모델링 결과에 대한 평가와 시나리오 등을 검토하면서 모델의 타당성 여부를 검증해야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;지식-탐구&quot;&gt;지식 탐구&lt;/h2&gt;

&lt;p&gt;업무나 사용자 활동에 대한 도메인 영역을 효과적으로 모델링하기 위해 지식을 면밀히 탐구해야 한다. 수많은 모델을 만들어보고 모든 세부 사항에 들어 맞는 추상적인 개념이 나타나면 초기 도메인 모델이 만들어진 것이다.&lt;br /&gt;
지식 탐구는 혼자서 하는 활동이 아니며, 개발자와 도메인 전문가로 구성된 팀원들이 서로 협업을 해야 한다.&lt;/p&gt;

&lt;p&gt;과거 폭포수 개발 방식에서는 일방적으로 지식이 한 방향으로 흘러간다. 개발자는 업무 지식을 쌓을 기회가 제공되지 않으며 도메인에 숨겨진 원리는 알지 못한 채 애플리케이션에서 수행해야 할 사항만 습득하게 된다. 이는 기초적인 역할만 수행하는 소프트웨어를 만들어낼 뿐, 도메인 전문가의 사고방식과 긴밀히 연결되지 않는다.&lt;/p&gt;

&lt;p&gt;모든 구성원이 함께 모델을 면밀히 만들어 나가면 도메인 전문가의 피드백, 협업을 통해 &lt;strong&gt;도메인 모델을 지속적으로 정제해나갈 수 있다. 이러한 모델은 명료하게 조직화되고 추상화될 수 있으며, 구현을 용이하게 해준다.&lt;/strong&gt; 개발 과정에서 도메인 전문가의 지속적인 관여로 심층적인 업무 지식을 소프트웨어에 반영할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;지속적인-학습&quot;&gt;지속적인 학습&lt;/h2&gt;

&lt;p&gt;모든 팀 구성원이나 개발자, 도메인 전문가들이 함께 참여하는 도메인 모델링을 통해 모두 똑같이 지식을 얻고 의사소통 체계를 공유하며 구현을 거쳐 피드백 고리를 완성하는, 지식 탐구 프로세스를 궤도에 올려야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;풍부한-지식이-담긴-설계&quot;&gt;풍부한 지식이 담긴 설계&lt;/h2&gt;

&lt;p&gt;모델에 포착돼 있는 지식은 단순한 명사 찾기 이상이다. 도메인에 관련된 엔티티만큼 업무 활동과 규칙도 도메인에 매우 중요하다. 지식 탐구는 이러한 통찰력을 반영하는 모델을 만들어 낸다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;감춰진-개념-추출하기&quot;&gt;감춰진 개념 추출하기&lt;/h3&gt;

&lt;p&gt;선박 화물의 운송 예약을 위한 애플리케이션의 간단한 도메인 모델로 시작하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/programming/2019-04-14-domain_driven_design_01/00.png&quot; alt=&quot;00.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예약 애플리케이션의 책임이 각 Cargo(화물)를 하나의 Voyage(운항)와의 연관관계를 맺고, 그것을 기록/관리하는 것이라 해보자. 아마 애플리케이션에는 다음 메서드가 있을 것이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;makeBooking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cargo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cargo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Voyage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;voyage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;confirmation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orderConfirmationSequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;voyage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addCargo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cargo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;confirmation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;confirmation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;보통 해운 산업에서는 선박이 운항 중에 나를 수 있는 화물의 최대치보다 예약을 더 받아들이는 것이 관행이다. 이를 초과예약(overbooking) 이라 한다.&lt;/p&gt;

&lt;p&gt;이 요구사항을 위한 클래스 다이어그램과 코드는 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/programming/2019-04-14-domain_driven_design_01/01.png&quot; alt=&quot;01.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;makeBooking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cargo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cargo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Voyage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;voyage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxBooking&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;voyage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;capacity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;voyage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;bookedCargoSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cargo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxBooking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;confirmation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orderConfirmationSequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;voyage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addCargo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cargo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;confirmation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;confirmation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 중요한 업무 규칙이 애플리케이션 메서드의 보호절로 감춰진다. 이런 코드는 다음과 같은 문제가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;코드가 작성된 대로라면, 업무 전문가가 이 코드를 읽고 규칙을 바로 검증하지 못한다.&lt;/li&gt;
  &lt;li&gt;해당 업무에 종사하지 않고 기술적인 측면만 담당하는 사람은 코드와 요구사항을 결부시키기 어렵다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;설계를 변경하여 이러한 지식을 더 잘 담을 수 있다. 초과예약 규칙은 일종의 정책(policy)로, 전략 패턴을 통해 다르게 구현할 수 있다. 이러한 개념은 도메인 주도 설계의 중요한 동기에 해당한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/programming/2019-04-14-domain_driven_design_01/02.png&quot; alt=&quot;02.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;makeBooking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cargo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cargo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Voyage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;voyage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;overbookingPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isAllowed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cargo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;voyage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;confirmation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orderConfirmationSequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;voyage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addCargo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cargo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;confirmation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;confirmation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OverbookingPolicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isAllowed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cargo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cargo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Voyage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;voyage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cargo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;voyage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;bookedCargoSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;voyage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;capacity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 구현하면 초과예약이 별개의 정책이라는 사실을 코드를 통해 분명히 알 수 있게 되며, 이 규칙의 구현 또한 명시적으로 드러나게 된다. &lt;strong&gt;위의 예와 같이 지식을 보전하고 공유하는 데 도메인 모델과 그에 상응하는 설계를 이용할 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이러한 명시적인 설계는 다음과 같은 이점이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;설계를 이러한 수준까지 끌어올리려면 모든 이가 초과예약의 특성을 단순한 계산이 아니라, 별개의 중요한 업무 규칙임을 알아야 한다.&lt;/li&gt;
  &lt;li&gt;프로그래머는 업무 전문가에게 그들이 이해할 수 있는 수준에서 기술적 산출물, 코드까지 보여줄 수 있으며 이를 통해 피드백 고리가 완성된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;심층-모델&quot;&gt;심층 모델&lt;/h2&gt;

&lt;p&gt;유용한 모델은 겉으로 드러나 있는 경우가 거의 없다. 도메인과 애플리케이션의 요구사항을 이해하게 되면서, 처음에 중요하게 생각했던 요소들을 버리거나 관점을 바꾸는, 모델을 정제해나가면서 유용한 모델이 탄생하는 것이다.&lt;/p&gt;

&lt;p&gt;이를 위해 지속적으로 지식 탐구를 도메인 전문가와 같이 진행하면서 모델을 정제해나가야 한다.&lt;/p&gt;

</description>
        <pubDate>Sun, 14 Apr 2019 00:00:00 +0000</pubDate>
        <link>https://dhsim86.github.io/programming/2019/04/14/domain_driven_design_01-post.html</link>
        <guid isPermaLink="true">https://dhsim86.github.io/programming/2019/04/14/domain_driven_design_01-post.html</guid>
        
        <category>DDD</category>
        
        <category>Domain</category>
        
        <category>Domain Driven Design</category>
        
        
        <category>Programming</category>
        
      </item>
    
      <item>
        <title>도메인 주도 설계 00 - 서문</title>
        <description>&lt;h2 id=&quot;도메인-주도-설계&quot;&gt;도메인 주도 설계&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;성공한 프로젝트의 공통적인 특징: 반복적인 설계를 거쳐 발전하고 프로젝트의 일부분이 된 풍부한 &lt;strong&gt;도메인 모델&lt;/strong&gt;이 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;복잡성으로 생기는 한계를 극복하려면, &lt;strong&gt;도메인 로직 설계에 진지하게 접근해야 한다.&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;지속되는 요구사항에 대한 유연한 대응과 기능 확장은 계속 정제되고 표현되는 도메인 모델을 통해 이룰 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;도메인-주도-설계-ddd의-세가지-특징&quot;&gt;도메인 주도 설계 (DDD)의 세가지 특징&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;도메인 그 자체와 도메인 로직에 초점을 맞춘다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;일반적인 데이터중심의 접근법을 탈피하여 순수한 도메인의 모델과 로직에 집중한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;보편적인(ubiquitous) 언어의 사용이다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;도메인 전문가와 소프트웨어 개발자 간의 커뮤니케이션 문제를 없애고 상호가 이해할 수 있고 모든 문서와 코드에 이르기까지 동일한 표현과 단어로 단일화된 언어체계를 구축해나가는 과정을 말한다.&lt;/li&gt;
      &lt;li&gt;분석작업과 설계, 그리고 구현에 이르기까지 통일된 방식으로 커뮤니케이션이 가능해진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;소프트웨어 엔티티와 도메인 컨셉트를 가능한 가장 가까이 일치시키는 것이다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;분석 모델과 설계가 다르고 또 그것과 코드가 다른 구조가 아니라, 도메인 모델부터 코드까지 항상 함께 움직이는 구조의 모델을 지향하는 것이 DDD의 핵심 원리이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;도메인-로직에-초점을-맞춤으로써-생기는-장점&quot;&gt;도메인 로직에 초점을 맞춤으로써 생기는 장점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;각기 다른 요구사항에 유연함과 확장 능력을 토대로 대응할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;코드 안에 정제되고 표현되는 도메인 모델을 통해 이룰 수 있다.&lt;/li&gt;
      &lt;li&gt;변경이나 확장이 점점 쉬워지는 구조로 바뀐다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;도메인에 대한 새로운 통찰력을 얻으면서 모델은 깊이가 더해가고 의사소통의 품질도 향상된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;모델링과 코드의 구현이 단절되어서는 안된다. 이러면 도메인을 분석한 내용이 설계에 반영되지 못하는 결과가 발생한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;도메인 모델을 프로젝트에서 일어나는 의사소통의 중심에 놓일 때, 팀원들은 공통 언어를 사용하여 의사소통의 품질을 높이고 의사소통의 결과를 코드에 반영할 수 있게 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;복잡성이라는-도전과제&quot;&gt;복잡성이라는 도전과제&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;얼마나 복잡한 소프트웨어를 만들어 낼 수 있는가를 결정하는 주요 요인은 &lt;strong&gt;설계 접근법&lt;/strong&gt;에 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;수많은 애플리케이션에서 가장 중요한 복잡성은 사용자의 활동이나 업무에 해당하는 &lt;strong&gt;도메인&lt;/strong&gt; 그 자체이다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;대부분의 소프트웨어 프로젝트는 가장 먼저 &lt;strong&gt;도메인과 도메인 로직에 집중해야 한다.&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;복잡한 도메인 설계는 &lt;strong&gt;모델&lt;/strong&gt;을 기반으로 해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;도메인 모델은 도메인에 대한 깊은 통찰력과 핵심 개념에 집중한 바를 반영한다. 가치 있는 모델은 곧바로 나타나지 않으며, 먼저 도메인을 깊이 있기 이해해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;도메인을 이해하기 위해서는 원시적인 차원의 모델에 기반을 둔 초기 설계 내용을 구현해본 다음, 그 구현을 반복해서 변형하는 과정을 거쳐야 한다. 새로운 통찰력을 얻을 떄마다 모델은 더욱 풍부한 지식을 반영하게 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;어떤 설계 요소는 네트워크나 데이터베이스와 같은 기술과 관련이 있지만, 도메인의 복잡성을 제대로 다루지 않으면 기술을 잘 이해하더라도 무용지물이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;설계-vs-개발-프로세스&quot;&gt;설계 vs. 개발 프로세스&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;도메인 주도 개발은 &lt;strong&gt;애자일 프로세스&lt;/strong&gt;를 지향한다.
    &lt;ul&gt;
      &lt;li&gt;개발은 반복주기를 토대로 진행되어야 한다.&lt;/li&gt;
      &lt;li&gt;개발자와 도메인 전문가는 밀접한 관계에 있어야 한다.
        &lt;ul&gt;
          &lt;li&gt;도메인 주도 설계는 도메인에 대한 깊은 통찰력과 핵심 개념을 반영한 모델을 만들어내는데, 이는 도메인 전문가와 개발자의 협업의 결과이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;도메인 주도 설계를 통한 가장 큰 이익은 도메인 주도 설계 접근법을 적용하고 도메인 모델을 의사소통의 중심에 놓을 때 발생한다. 공통 언어를 통해 상호 의사소통의 품질을 높이고, 결과를 소프트웨어에 반영해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 14 Apr 2019 00:00:00 +0000</pubDate>
        <link>https://dhsim86.github.io/programming/2019/04/14/domain_driven_design_00-post.html</link>
        <guid isPermaLink="true">https://dhsim86.github.io/programming/2019/04/14/domain_driven_design_00-post.html</guid>
        
        <category>DDD</category>
        
        <category>Domain</category>
        
        <category>Domain Driven Design</category>
        
        
        <category>Programming</category>
        
      </item>
    
      <item>
        <title>Effective Java 10 - 예외</title>
        <description>&lt;h1 id=&quot;예외&quot;&gt;예외&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;69-예외는-진짜-예외-상황에만-사용하라&quot;&gt;69. 예외는 진짜 예외 상황에만 사용하라.&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;climb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ArrayIndexOutOfBoundsException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드는 무한 루프를 통해 배열을 순회 후 예외가 발생하면 끝을 내는 코드이다. 이렇게 &lt;strong&gt;예외를 일상적인 제어 흐름으로 쓰여선 안된다. 예외는 오직 예외 상황에서만 쓰라고 설계된 것이다.&lt;/strong&gt; 특히 try-catch 문안에 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한될 뿐만 아니라 코드를 헷갈리게 하고 성능을 더 떨어뜨린다. 또한 흐름 제어에 쓰인 예외가 실제 버그를 숨겨 디버깅도 훨씬 어렵게 만들 수 있다.&lt;/p&gt;

&lt;p&gt;잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;70-복구할-수-있는-상황에는-checked-예외를-프로그래밍-오류에는-unchecked-예외를-사용하라&quot;&gt;70. 복구할 수 있는 상황에는 Checked 예외를, 프로그래밍 오류에는 Unchecked 예외를 사용하라.&lt;/h2&gt;

&lt;p&gt;자바는 문제 상황을 알리는 타입으로 Checked 예외, Unchecked 예외, Error 이렇게 세 가지를 제공하는데 언제 어떤 예외를 사용할지는 지침이 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;호출하는 쪽에서 복구하리라 여겨지는 상황이라면 checked 예외를 사용한다.&lt;/strong&gt; 이 것이 checked 예외와 unchecked 예외를 구분하는 규칙이다. checked 예외를 던지면 호출자가 그 예외를 잡아 처리하거나 더 바깥으로 전달하도록 강제하게 된다. 달리 말하면 API 설계자는 API 사용자에게 &lt;strong&gt;checked 예외를 던져 그 상황에서 복구하라고 요구하는 것이다.&lt;/strong&gt; 물론 사용자는 무시할 수도 있지만 이는 보통 좋지 않은 생각이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;unchecked 예외와 Error는 프로그램에서 잡을 필요가 없거나 통상적으로 잡지 말아야 한다.&lt;/strong&gt; 프로그램에서 이를 던졌다는 것은 복구가 불가능하거나 더 실행해봐야 득이 될 것이 없다는 뜻이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;프로그래밍 오류에는 unchecked 예외를 사용해야 한다.&lt;/strong&gt; 보통 이런 예외는 전제조건을 만족하지 못했을 경우에 발생한다. 단순히 클라이언트가 API의 명세에 기록된 제약을 지키지 못했을 경우에 발생한다는 것이다.&lt;/p&gt;

&lt;p&gt;어떤 문제가 발생했을 때, 이 상황이 복구할 수 있는지 아니면 프로그래밍 오류인지가 명확히 구분되지는 않는다. 예를 들어 말도 안되는 크기의 배열을 할당해 생긴 프로그래밍 오류일 수도 있고, 자원이 부족해서 발생한 것일 수도 있는 것이다. 만약 자원이 일시적으로만 부족하거나 순간적으로 몰린 것이라면 충분히 복구할 수 있는 상황일 것이다. 따라서 이런 상황이 복구할 수 있는 것인지는 API 설계자의 판단에 달렸다. &lt;strong&gt;복구할 수 있다고 생각되면 checked 예외를, 아니면 unchecked 예외를 사용해야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Error는 보통 JVM이 자원 부족, 불변식 깨짐으로 인해 더 이상 수행할 수 없을 경우에 발생한다.&lt;/strong&gt; 그러나 Error는 애플리케이션이 던지는 것도 아니고 잡아서도 안된다. 애플리케이션 입장에서는 복구가 가능한 것도 아니기 때문이다. 따라서 Error 클래스를 상속하여 사용하는 일은 없어야 한다.&lt;/p&gt;

&lt;p&gt;Exception, RuntimeException, Error를 상속하지 않는 &lt;strong&gt;throwable&lt;/strong&gt;도 만들 수 있다. 이 것은 암묵적으로 일반적인 checked 예외처럼 다루지만 사용해봤자 이로울 게 없다. throwable은 정상적인 checked 예외와 나을게 없으면서도 API 사용자를 헷갈리게만 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;예외도 역시 어떤 메서드라도 정의할 수 있는 완벽한 객체이다.&lt;/strong&gt; 예외의 메서드는 주로 그 예외를 일으킨 상황에 관한 정보를 코드 형태로 전달하는 데 쓰인다. Checked 예외는 일반적으로 복구할 수 있는 조건에 발생하는데, 호출자가 이 예외 상황에서 벗어날 수 있도록 충분한 정보를 제공하는 것이 중요하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;71-필요없는-checked-예외-사용은-피하라&quot;&gt;71. 필요없는 Checked 예외 사용은 피하라.&lt;/h2&gt;

&lt;p&gt;Checked 예외를 싫어하는 자바 프로그래머가 많지만 제대로 활용하면 API와 프로그램의 질을 높일 수 있다. 결과를 코드로 반환하거나 unchecked 예외를 던지는 것과는 달리, &lt;strong&gt;checked 예외는 발생한 문제를 프로그래머가 처리하도록 하여 안정을 높이게끔 해준다.&lt;/strong&gt; 물론 checked 예외를 과하게 사용하면 오히려 쓰기 불편한 API가 된다.&lt;/p&gt;

&lt;p&gt;API를 제대로 사용해도 발생할 수 있는 예외이거나 프로그래머가 의미있는 조치를 취할 수 있는 경우라면 checked 예외를 사용하도록 한다. 둘 중 어디에도 속하지 않는다면 unchecked 예외를 써야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;72-표준-예외를-사용하라&quot;&gt;72. 표준 예외를 사용하라.&lt;/h2&gt;

&lt;p&gt;예외도 표준 라이브러리를 활용하는 것처럼, &lt;strong&gt;이미 있는 것을 재사용하는 것이 좋다.&lt;/strong&gt; 자바 라이브러리는 대부분 API에서 쓰기에 충분한 수의 예외를 제공한다.&lt;/p&gt;

&lt;p&gt;표준 예외를 재사용하면 얻는 게 많다. 그 중 최고는 &lt;strong&gt;API가 다른 사람이 익히고 사용하기 쉬워진다는 점이다.&lt;/strong&gt; 단, &lt;strong&gt;Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말아야 한다.&lt;/strong&gt; 이 클래스들은 추상 클래스라고 생각해야 한다. 이런 예외들은 다른 예외들의 상위 클래스라서 여려 성격들의 예외를 포괄하여 안정적으로 테스트할 수 없다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;예외&lt;/th&gt;
      &lt;th&gt;주요 쓰임&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;IllegalArgumentException&lt;/td&gt;
      &lt;td&gt;허용하지 않는 값이 인수로 건네졌을 때, 단 null은 NullPointerException으로 처리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IllegalStateException&lt;/td&gt;
      &lt;td&gt;객체가 메서드를 수행하기에 적절하지 않은 상태&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NullPointerException&lt;/td&gt;
      &lt;td&gt;null을 허용하지 않는 메서드에 null을 넘겼을 경우&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IndexOutOfBoundsException&lt;/td&gt;
      &lt;td&gt;인덱스가 범위를 넘어섰을 때&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ConcurrentModificationException&lt;/td&gt;
      &lt;td&gt;허용하지 않는 동시 수정이 발견되었을 때&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;UnsupportedOperationException&lt;/td&gt;
      &lt;td&gt;호출한 메서드를 해당 객체가 지원하지 않을 경우&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위에서 IllegalArgumentException과 IllegalStateException 예외의 주요 쓰임이 상호 배타적이 아니라서 헷갈릴 때가 있는데, 일반적인 규칙은 이렇다. &lt;strong&gt;인수 값이 무엇이든 상관없이 실패했을 경우라면 IllegalStateException을, 그렇지 않다면 IllegalArgumentException을 사용하도록 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 어떤 예외에 대한 정보를 더 제공하고 싶다면 이런 예외를 확장해서 사용하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;73-추상화-수준에-맞는-예외를-던져라&quot;&gt;73. 추상화 수준에 맞는 예외를 던져라.&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;수행하는 일과 상관없는 예외가 튀어나오면 당황스럽다.&lt;/strong&gt; 메서드가 저수준 예외를 처리하지 않고 바깥으로 전파해버릴 때 종종 일어나는 일이다. 이는 내부 구현 방식을 드러낼 뿐만 아니라 윗 계층의 API를 오염시킨다. 특히 윗 계층에서는 전혀 상관없는 예외를 처리하기 위해 알 필요도 없는 클래스나 인터페이스, 메서드를 사용해야 될 수도 있다.&lt;/p&gt;

&lt;p&gt;이 문제를 피하기 위해서는 &lt;strong&gt;상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다.&lt;/strong&gt; 이를 &lt;strong&gt;예외 번역(Exception Translation)&lt;/strong&gt; 이라고 한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LowerLevelException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;HigherLevelException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예외를 번역할 때, 저수준의 예외가 디버깅에 도움이 된다면 &lt;strong&gt;예외 연쇄(Exception Chaining)&lt;/strong&gt;을 사용할 수 있다. 예외 연쇄란 문제의 근본 원인(clause)인 저수준 예외를 고수준 예외에 실어보내는 것이다. 그러면 필요할 때 &lt;strong&gt;Throwable의 getClause&lt;/strong&gt; 메서드를 통해 저수준 예외를 꺼내어 참조할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LowerLevelException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;HigherLevelException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;고주순 예외의 생성자에서는 상위 클래스의 생성자에게 이 저수준 예외를 건네주어 최종적으로 Throwable 생성자까지 건네지게 해야 한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HigherLevelException&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;HigherLevelException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;무턱대로 예외를 전파하는 것보다는 예외 번역이 우수하지만 그렇다고 남용해서는 곤란하다.&lt;/strong&gt; 가능하다면 저수준 메서드가 반드시 성공하도록 하게하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선이다. 아니면 상위 계층에서 그 예외를 조용히 처리하여 API 호출자에게 전파하지 않는 방법도 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;74-메서드가-던지는-모든-예외를-문서화하라&quot;&gt;74. 메서드가 던지는 모든 예외를 문서화하라.&lt;/h2&gt;

&lt;p&gt;메서드가 던질 가능성이 있는 모든 예외는 문서화하는 것이 좋다. checked 예외는 unchecked 예외든, 어떤 메서드이든지 간에 모두 마찬가지이다. 문서화에는 자바 독의 @throws 태그를 통해 문서화할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;75-예외의-상세-메시지에-실패-관련-정보를-담으라&quot;&gt;75. 예외의 상세 메시지에 실패 관련 정보를 담으라.&lt;/h2&gt;

&lt;p&gt;예외를 잡지 못해 프로그램이 실패할 경우 자바 시스템은 그 예외의 스택 추적(stack trace) 정보를 자동으로 출력한다. 스택 추적은 예외 객체의 &lt;strong&gt;toString&lt;/strong&gt; 메서드를 호출해서 얻는 문자열이다. 이런 정보는 예외 발생했을 당시의 상황을 캐치해낼 수 있는 유일한 정보이다. 따라서 &lt;strong&gt;실패 원인에 관한 정보를 가능한 예외 객체에 많이 담아 반환하는 일은 아주 중요하다.&lt;/strong&gt; 특히 checked 예외일 경우, 클라이언트 쪽에서 정보를 참고하여 복구를 쉽게 할 수 있도록 별도의 getter를 통해 정보에 접근하도록 하는 것이 좋다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;실패 순간을 포착하려면 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메시지에 담아야 한다.&lt;/strong&gt; 관련된 데이터는 모두 담아야 겠지만 장황할 필요는 없다. 보통 문제를 분석하는 사람은 스택 추적 뿐만 아니라 관련 문서와 소스 코드도 들여다 보기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;예외의 상세 메시지와 최종 사용자에게 보여줄 오류 메시지를 혼동해서는 안된다.&lt;/strong&gt; 최종 사용자에게는 친절한 안내 메시지를 보여주어야 하고, 예외 메시지는 가독성보다는 담긴 내용이 중요하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;76-가능한-실패-원자적으로-만들라&quot;&gt;76. 가능한 실패 원자적으로 만들라.&lt;/h2&gt;

&lt;p&gt;작업 도중 예외가 발생하더라도 그 객체는 여전히 정상적으로 사용할 수 있는 상태라면 더욱 멋질 것이다. 특히 checked 예외일 경우 클라이언트가 오류 상태를 복구할 수 있을테니 더욱 유용할 것이다. &lt;strong&gt;호출된 메서드가 실패하더라도 관련 객체는 메서드 호출 전 상태로 유지하는 것이 좋다.&lt;/strong&gt; 이를 &lt;strong&gt;실패 원자적(failure-atomic)&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;메서드를 실패 원자적으로 만드는 방법은 다양하다. 가장 간단한 방법은 &lt;strong&gt;객체를 불변으로 만드는 것이다. 불변 객체는 태생적으로 실패 원자적이다.&lt;/strong&gt; 메서드가 실패하면 새로운 객체가 만들어질 수는 있지만 기존 객체가 불안정한 상태로 빠지는 일은 결코 없다.&lt;/p&gt;

&lt;p&gt;가변 객체의 메서드를 실패 원자적으로 만드는 법은 작업 수행에 앞서 &lt;strong&gt;매개변수의 유효성을 검사하는 것이다.&lt;/strong&gt; 객체의 내부 상태를 변경하기 전에 잠재적 예외의 가능성 대부분을 걸러낼 수 있는 방법이다. 이와 비슷하게, &lt;strong&gt;실패할 가능성이 있는 모든 코드를, 객체의 상태를 바꾸는 코드보다 앞에 배치하는 방법도 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;실패 원자성을 얻는 세 번째 방법은 &lt;strong&gt;객체의 임시 복사본에서 작업을 수행 후, 작업이 완료되면 원래 객체와 교체하는 것이다.&lt;/strong&gt; 마지막으로는 작업 도중 발생하는 실패를 가로채어 원래 상태로 되돌리는 복구 코드를 작성하는 방법도 있다.&lt;/p&gt;

&lt;p&gt;실패 원자성은 항상 달성할 수 있는 것은 아니다. 특히 두 스레드가 동기화 없이 같은 객체를 동시에 수정한다면 객체의 일관성이 깨질 수 있다. 이 때 발생하는 &lt;strong&gt;ConcurrentModificationException&lt;/strong&gt; 예외를 잡았다고 해서 그 객체아 여전히 쓸 수 있는 상태라고 봐서는 안된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Error는 애초에 애플리케이션 레벨에서 복구할 수 있는 것이 아니므로 실패 원자성을 고려할 필요가 없다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;77-예외를-무시하지-말라&quot;&gt;77. 예외를 무시하지 말라.&lt;/h2&gt;

&lt;p&gt;API 설계자가 메서드 선언에 예외를 명시하고 문서화하는 것은 그 메서드를 사용할 때 적절한 조치를 취하라는 것이다. 예외 발생시 아무것도 하지 않고 무시할 경우 &lt;strong&gt;예외가 존재할 이유가 사라진다.&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Mar 2019 00:00:00 +0000</pubDate>
        <link>https://dhsim86.github.io/java/2019/03/02/effective_java_10-post.html</link>
        <guid isPermaLink="true">https://dhsim86.github.io/java/2019/03/02/effective_java_10-post.html</guid>
        
        <category>java</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>Effective Java 09 - 일반적인 프로그래밍 원칙</title>
        <description>&lt;h1 id=&quot;일반적인-프로그래밍-원칙&quot;&gt;일반적인 프로그래밍 원칙&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;57-지역변수의-범위를-최소화하라&quot;&gt;57. 지역변수의 범위를 최소화하라.&lt;/h2&gt;

&lt;p&gt;이 원칙은 클래스와 멤버의 접근 권한을 최소화하라는 것과 비슷하다. &lt;strong&gt;지역변수의 유효범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;지역변수의 범위를 줄이는 가장 강력한 기법은 “가장 처음 쓰일 때 선언하기”이다.&lt;/strong&gt; 사용하려면 멀었는데 미리 변수를 선언부터 해두면, 코드가 어수선해져 가독성이 떨어진다. 지역변수를 생각없이 선언하다 보면 &lt;strong&gt;변수가 실제로 쓰이는 범위보다 너무 앞서 선언하건ㅏ, 다 쓴 뒤에도 여전히 살아 있게 되기 쉽다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;거의 모든 지역변수는 선언과 동시에 초기화해야 한다.&lt;/strong&gt; 초기화에 필요한 정보가 충분치 않다면 충분해질 때까지 선언을 미루어야 한다.&lt;/p&gt;

&lt;p&gt;지역변수 범위를 최소화하는 마지막 방법은 &lt;strong&gt;메서드를 작게 유지하고 한 가지 기능에 집중하는 것이다.&lt;/strong&gt; 한 메서드에서 여러 기능을 처리한다면 그중 한 기능과 연관된 지역변수라도, 다른 기능을 수행하는 코드에서 접근할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;58-전통적인-for-문보다는-for-each-문을-사용하라&quot;&gt;58. 전통적인 for 문보다는 for-each 문을 사용하라.&lt;/h2&gt;

&lt;p&gt;다음은 전통적인 for 문으로 컬렉션을 순회하는 코드이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;반복자와 인덱스 변수는 모두 코드를 지저분하게 할 뿐이고, 이 코드에서 정작 필요한 것은 원소들뿐이다.&lt;/strong&gt; 이처럼 쓰이는 요소 종류가 늘어나면 오류가 생길 가능성이 커지며 변수를 잘못 사용할 틈새가 넓어진다. 또한 컬렉션이냐 배열이냐에 따라 위 코드처럼 코드 형태가 상당히 달라진다.&lt;/p&gt;

&lt;p&gt;이상의 문제는 for-each 문을 사용하면 모두 해결된다. &lt;strong&gt;반복자와 인덱스 변수를 사용하지 않으니 코드가 깔끔해지고 오류가 날 일도 없다.&lt;/strong&gt; 하나의 코드 형태로 컬렉션과 배열을 모두 처리할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;컬렉션을 중첩해서 순회해야 한다면 for-each 문의 이점이 더 커진다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Suit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CLUB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DIAMOND&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEART&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SPADE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Rank&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ACE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DEUCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FOUR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FIVE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SIX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SEVEN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EIGHT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TEN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JACK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QUEEN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KING&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Suit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Suit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ranks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Card&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deck&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Suit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ranks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;deck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Card&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 버그&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드에서 NoSuchElementException 예외가 발생하는데, 이는 바깥 컬렉션 (suits)의 반복자에서 next 메서드가 너무 많이 불리기 때문이다. 안쪽 반복문에서 ranks 컬렉션의 수만큼 suits의 반복자 next 메서드가 호출된다.&lt;/p&gt;

&lt;p&gt;이를 회피하기 위해서는 다음과 같이 suits 컬렉션의 현재 반복자를 중간에 저장해두어야 한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Suit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Suit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ranks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;deck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Card&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;suit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()));&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 코드가 깔끔하지 않다. 대신 for-each 문을 사용함으로써 이 문제는 간단히 해결된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Suit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rank&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rank&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ranks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;deck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Card&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;suit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;코드가 놀랄만큼 간결해지지만, 모든 상황에서 for-each 문을 사용할 수 있는 것은 아니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파괴적인 필터링: 컬렉션을 순회하면서 선택된 원소를 제거할 경우 반복자의 remove 메서드를 호출해야 한다.&lt;/li&gt;
  &lt;li&gt;변형: 리스트나 배열을 순회하면서 그 원소의 값 일부 혹은 전체를 변경해야 한다면 반복자나 인덱스를 사용해야 한다.&lt;/li&gt;
  &lt;li&gt;병렬 반복: 여러 컬렉션을 병렬적으로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용하여 명시적으로 제어해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;for-each 문은 컬렉션과 배열은 물론 &lt;strong&gt;Iterable&lt;/strong&gt; 인터페이스를 구현한 객체라면 무엇이든 순회 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Iterable을 처음부터 구현하기는 힘들지만 &lt;strong&gt;원소들의 묶음을 표현하는 타입을 정의해야 한다면 Iterable을 구현하는 것도 고려할만 하다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;59-라이브러리를-익히고-사용하라&quot;&gt;59. 라이브러리를 익히고 사용하라.&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;표준 라이브러리를 적극적으로 활용하면 그 코드를 작성한 전문가의 지식과 앞서 사용한 프로그래머들의 경험을 활용할 수 있다.&lt;/strong&gt; 또한 핵심적인 일과 크게 관련없는 문제를 해결하느라 시간을 허비하지 않아도 된다. 그리고 표준 라이브러리는 성능이 지속적으로 개선되고, 기능도 점점 많아진다는 이점이 있다.&lt;/p&gt;

&lt;p&gt;마지막으로 이렇게 표준 라이브러리를 활용한 코드는 많은 사람들에게 읽히기 쉬운 낯익은 코드가 될 수 있다는 점이다. 자연스럽게 유지보수하기 좋고 재활용하기 쉬운 코드가 된다.&lt;/p&gt;

&lt;p&gt;자바 프로그래머라면 적어도 &lt;strong&gt;java.lang, java.util, java.io&lt;/strong&gt;와 그 하위 패키지들에는 익숙해져야 한다. 아주 특별한 기능이 아니라면 누군가가 이미 라이브러리 형태로 구현해놓았을 가능성이 크다. 그런 라이브러리가 있다면, 쓰면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;60-정확한-답이-필요하다면-float와-double은-피하라&quot;&gt;60. 정확한 답이 필요하다면 float와 double은 피하라.&lt;/h2&gt;

&lt;p&gt;float와 double 타입은 과학과 공학 계산용으로 설계되었다. 이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 &lt;strong&gt;‘근사치’&lt;/strong&gt;로 계산하도록 설계되었다. 따라서 &lt;strong&gt;정확한 결과가 필요할 경우 사용하면 안된다.&lt;/strong&gt; 대신에 BitDecimal이나 int 혹은 long을 사용해 결과를 구해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;61-박싱된-기본-타입보다는-일반-기본-타입을-사용하라&quot;&gt;61. 박싱된 기본 타입보다는 일반 기본 타입을 사용하라.&lt;/h2&gt;

&lt;p&gt;자바의 데이터 타입은 크게 두 가지로 나뉠 수 있는데, int및 double, boolean과 같은 기본 타입과 String, List와 같은 참조 타입으로 나눌 수 있다. 그리고 각 기본 타입에 대해 대응하는 참조 타입이 있는데 이를 &lt;strong&gt;박싱된 기본 타입&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;기본 타입과 박싱된 기본 타입의 주된 차이는 크게 세 가지이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성이라는 속성을 지닌다.
    &lt;ul&gt;
      &lt;li&gt;달리 말하면 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;언제나 기본 타입의 값은 유효한 반면, 박싱된 기본 타입은 null을 가질 수도 있다.&lt;/li&gt;
  &lt;li&gt;기본 타입이 박싱된 기본 타입에 비해 시간과 메모리 사용면에서 더 효율적이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;다음 예를 살펴보자.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Comparator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;naturalOrder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 Integer 값을 오름차순으로 정렬하는 비교자인데, 심각한 결함이 존재한다. &lt;strong&gt;naturalOrder.compare(new Integer(42), new Integer(42))&lt;/strong&gt;의 값을 출력해보면 값이 같으므로 0이 리턴해야 될 것 같지만, 실제로는 1을 리턴한다.&lt;/p&gt;

&lt;p&gt;이의 원인은 &lt;strong&gt;(i == j)&lt;/strong&gt; 비교문에 있다. 이 비교문에서 두 객체 참조의 &lt;strong&gt;식별성&lt;/strong&gt;을 검사하게 된다. 같은 값이지만 서로 다른 인스턴스이므로 이 비교의 결과는 false이며, 따라서 1을 반환하는 것이다. &lt;strong&gt;이 처럼 박싱된 기본 타입에 == 연산자를 사용하면 오류가 발생할 수도 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;다음 코드도 살펴보자.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;equals&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드의 결과로 NullPointerException 예외가 발생한다. 원인은 이 i 변수가 초기화되지 않은 Integer이며 다른 참조 타입과 마찬가지로 null이라는 데 있다. &lt;strong&gt;기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀리는데,&lt;/strong&gt; null 참조를 언박싱하면 NullPointerException 예외가 발생한다.&lt;/p&gt;

&lt;p&gt;또한 기본 타입과 연산을 혼용시, 언박싱이 자동으로 이루어지므로 성능이 느려질 수도 있다. 따라서 박싱된 기본 타입 대신 일반 기본 타입을 사용할 수 있다면 일반 기본 타입을 사용해야 한다.&lt;/p&gt;

&lt;p&gt;박싱된 기본 타입을 사용해야 하는 경우는 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;컬렉션의 원소나 키, 값으로 사용할 경우
    &lt;ul&gt;
      &lt;li&gt;컬렉션은 기본 타입을 담을 수 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로 사용할 경우
    &lt;ul&gt;
      &lt;li&gt;자바 언어는 타입 매개변수로 일반 기본 타입은 지원하지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;리플렉션을 통해 메서드를 호출할 경우&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;63-문자열-연결은-느리니-주의하라&quot;&gt;63. 문자열 연결은 느리니 주의하라.&lt;/h2&gt;

&lt;p&gt;문자열 연결 연산자 (+)는 여러 문자열을 하나로 합쳐주는 편리한 수단이다. 한 줄짜리 출력값 또는 크기가 고정된 객체의 문자열 표현을 만들 때는 괜찮지만, 남용시 성능 저하를 감내하기 어렵다. &lt;strong&gt;문자열 연결 연산자로 n개의 문자열을 잇는 시간은 n^2에 비례한다.&lt;/strong&gt; 문자열은 불변이라서 두 문자열 연결시 양쪽의 내용을 모두 복사해야 하기 때문이다.&lt;/p&gt;

&lt;p&gt;따라서 성능을 위해서는 문자열 연결시 String 대신 &lt;strong&gt;StringBuilder&lt;/strong&gt;를 사용해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;64-객체는-인터페이스를-통해-참조하라&quot;&gt;64. 객체는 인터페이스를 통해 참조하라.&lt;/h2&gt;

&lt;p&gt;메서드의 매개변수 타입으로 클래스가 아니라 인터페이스를 사용해야 된다고 했는데, 이 뿐만 아니라 &lt;strong&gt;객체 또한 클래스가 아닌 인터페이스로 참조하는 것이 좋다.&lt;/strong&gt; 적합한 인터페이스가 있다면 &lt;strong&gt;매개변수 뿐만 아니라 반환 값, 변수, 필드를 전부 인터페이스로 선언하는 것이다.&lt;/strong&gt; 객체의 실제 클래스를 사용해야 할 상황은 오직 생성자로 생성할 때 뿐이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해진다.&lt;/strong&gt; 나중에 구현 클래스를 교체하고자할 경우, 그저 새 클래스의 생성자를 호출해주기만 하면 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;만약 사용할만한 인터페이스 타입이 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인 (상위의) 클래스를 타입으로 사용하도록 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;65-리플렉션보다는-인터페이스를-사용하라&quot;&gt;65. 리플렉션보다는 인터페이스를 사용하라.&lt;/h2&gt;

&lt;p&gt;리플레션 기능을 사용하면 프로그램에서 임의의 클래스에 접근이 가능하다. 생성자 및 메서드, 필드를 조작할 수도 있다.&lt;/p&gt;

&lt;p&gt;그러나 리플렉션은 다음 단점이 존재한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;컴파일타입 타입 검사가 주는 이점을 하나도 누릴 수 없다.&lt;/li&gt;
  &lt;li&gt;리플렉션을 이용하면 코드가 장황하고 지저분해진다.&lt;/li&gt;
  &lt;li&gt;성능이 느리다.
    &lt;ul&gt;
      &lt;li&gt;리플렉션을 통한 메서드 호출은 일반적인 메서드 호출보다 훨씬 느리다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피하고 이점을 취할 수 있다.&lt;/strong&gt; 컴파일 타임에 이용할 수 없는 클래스를 사용해야 하는 프로그램은 적절한 인터페이스나 상위 클래스를 이용하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;66-네이티브-메서드는-신중히-사용하라&quot;&gt;66. 네이티브 메서드는 신중히 사용하라.&lt;/h2&gt;

&lt;p&gt;자바 네이티브 인터페이스 (JNI)는 자바 프로그램이 네이티브 메서드를 호출하는 기술이다. 여기서 네이티브 메서드란 &lt;strong&gt;C, C++과 같은 네이티브 프로그래밍 언어로 작성한 메서드를 말한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;네이티브 메서드는 플랫폼 특화된 기능을 사용하거나, 네이티브 코드로 작성된 라이브러리를 사용할 경우 또는 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성하는 경우이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;성능을 개선할 목적으로 네이티브 메서드를 사용하는 것은 거의 권장하지 않는다.&lt;/strong&gt; JVM은 그동안 엄청난 속도로 발전해 일반 자바코드로도 충분한 성능을 보여주며, 네이티브 메서드는 안전하지도 않다. 이식성이 낮고 디버깅도 어렵다. 또한 가비지 컬렉터가 네이티브 메모리를 자동 회수하지도 못하며 추적도 못한다. 마지막으로 네이티브 메서드와 자바 코드 사이에 접착 코드 (glue code)를 작성해야 하는데 귀찮은 작업이기도 하고 가독성도 떨어진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;67-최적화는-신중히-하라&quot;&gt;67. 최적화는 신중히 하라.&lt;/h2&gt;

&lt;p&gt;대부분의 최적화는 좋은 결과보다는 해로운 결과로 이어지기 쉽다. 빠르지도 않고 제대로 동작하지도 않으면서 유지보수하기는 어려운 코드를 생산하기 쉽다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;성능 때문에 견고한 구조를 희생하면 안된다. 빠른 프로그램보다는 좋은 프로그램을 작성해야 한다.&lt;/strong&gt; 신중하게 설계하여 깨끗하고 명확하고 멋진 구조를 갖춘 프로그램을 완성한 다음에야 최적화를 고려해볼 차례가 된다.&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Mar 2019 00:00:00 +0000</pubDate>
        <link>https://dhsim86.github.io/java/2019/03/01/effective_java_09-post.html</link>
        <guid isPermaLink="true">https://dhsim86.github.io/java/2019/03/01/effective_java_09-post.html</guid>
        
        <category>java</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>Effective Java 08 - 메서드</title>
        <description>&lt;h1 id=&quot;메서드&quot;&gt;메서드&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;49-매개변수가-유효한지-검사하라&quot;&gt;49. 매개변수가 유효한지 검사하라.&lt;/h2&gt;

&lt;p&gt;메서드와 생성자의 대부분은 값이 특정 조건을 만족해야 한다. 이러한 제약은 &lt;strong&gt;반드시 문서화해야 하며, 메서드 몸체가 시작되기 전에 유효한지 검사해야 한다.&lt;/strong&gt; 이는 &lt;strong&gt;“오류는 가능한 빨리 (발생한 곳에서) 잡아야 한다”&lt;/strong&gt;는 일반 원칙의 사례이기도 하다.&lt;/p&gt;

&lt;p&gt;메서드 몸체가 시작되기 전에 매개변수를 확인하여 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있다.&lt;/p&gt;

&lt;p&gt;매개변수 검사를 제대로 하지 않는다면 몇 가지 문제가 발생할 수 있다. 메서드가 수행되는 중간에 모호한 예외를 던질 수 있으며, 더 나쁜 상황은 메서드가 잘 수행되었는데 잘못된 결과를 반환할 수도 있다. 또한 메서드 수행 후 어떤 객체를 이상한 상태로 만들어 미래의 알 수 없는 시점에 이 메서드와는 관련 없는 오류를 낼 수도 있다.&lt;/p&gt;

&lt;p&gt;public과 protected 메서드는 매개변수 값이 잘못되었을 때 던지는 예외를 문서화해야 한다. 이는 &lt;strong&gt;@throws&lt;/strong&gt; 자바독 태그를 사용하면 된다. 제약을 문서화한다면 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다.&lt;/p&gt;

&lt;p&gt;공개되지 않은 메서드라면 메서드가 호출되는 상황을 통제할 수 있다. &lt;strong&gt;오직 유효한 값이 넘겨지리라는 것을 보증할 수 있고 그렇게 해야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;50-적시에-방어적-복사본을-만들라&quot;&gt;50. 적시에 방어적 복사본을 만들라.&lt;/h2&gt;

&lt;p&gt;API나 클래스를 설계할 때는 그것을 사용하는 &lt;strong&gt;클라이언트가 불변식을 깨드리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍해야 한다.&lt;/strong&gt; 어떠한 경우든 적절치 않은 클라이언트로부터 클래스를 보호하는데 충분한 시간을 투자하는 것이 좋다.&lt;/p&gt;

&lt;p&gt;어떤 객체든 그 객체의 허락없이는 외부에서 내부를 수정하는 일은 불가능하다. 하지만 주의를 기울이지 않으면 자기도 모르게 내부를 수정하도록 하는 경우가 생긴한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Period&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Period&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; after &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;얼핏 이 클래스는 불변 클래스로 보이지고, 시작 시각이 종료 시각보다 늦을 수 없다는 불변식이 어렵지 않게 지켜질 것 같다. 그러나 &lt;strong&gt;Date가 가변이라는 사실&lt;/strong&gt;을 이용하면 그 불변식을 깨뜨릴 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Period&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Period&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setYear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;78&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// p의 내부를 수정&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다행히 자바 8 이후라면 쉽게 해결할 수 있다. Date 대신에 불변인 &lt;strong&gt;Instant(혹은 LocalDateTime, ZonedDateTime)&lt;/strong&gt;를 사용하면 된다. &lt;strong&gt;Date는 낡은 API이니 새로운 코드를 작성할 떄는 더 이상 사용하면 안된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;외부 공격으로부터 Period 인스턴스의 내부를 보호하려면 &lt;strong&gt;생성자에서 받은 가변 매개변수 각각을 방어적으로 복사해야 한다.&lt;/strong&gt; 그런 다음 Period 인스턴스 안에서는 원본이 아닌 복사본을 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Period&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;end&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;가 &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;보다 늦다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 생성자를 작성하면 앞서의 공격은 위협이 되지 않는다. &lt;strong&gt;매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고, 이 복사본으로 유효성을 검사하는 것에 주목해야 한다.&lt;/strong&gt; 순서가 부자연스러워 보이지만 반드시 이렇게 작성해야 한다. 멀티스레딩 환경이라면 원본 객체의 유효성을 검사 후 복사본을 만드는 그 찰나의 취약한 순간에 다른 스레드가 원본 객체를 수정할 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;방어적 복사에 Date의 &lt;strong&gt;clone 메서드를 사용하지 않는 점에도 주목하자.&lt;/strong&gt; Date는 final이 아니므로 clone 메서드를 Date가 정의한 것이 아닐 수 있다. clone 메서드가 악의를 가진 하위 클래스의 인스턴스를 반환할 수도 있다. 하위 클래스가 start, end 인스턴스 필드의 참조를 따로 저장해두었다가 다시 접근할 수도 있다. 이런 공격을 막기 위해 &lt;strong&gt;매개변수가 제 3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 생성시 clone을 사용해서는 안된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;아직 Period 인스턴스는 변경이 가능하다. 접근자 메서드가 내부의 가변 정보를 그대로 드러내기 때문이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Period&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Period&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setYear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;78&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 내부 변경&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;두 번째 공격을 막아내려면 단순히 접근자가 가변 필드의 방어적 복사본을 반환하면 된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;새로운 접근자까지 갖추면 Period는 완전한 불변이 된다. 생성자와는 달리 &lt;strong&gt;접근자 메서드에는 방어적 복사에 clone을 사용해도 된다.&lt;/strong&gt; Period가 가진 Date 객체는 java.util.Date 임이 확실하기 때문이다.&lt;/p&gt;

&lt;p&gt;매개변수를 방어적으로 복사하는 목적이 불변 객체를 만들기 위해서만은 아니다. 메서드든 생성자든 클라이언트가 제공한 &lt;strong&gt;객체의 참조를 보관해야 할 때면 항시 그 객체가 잠재적으로 변경될 수 있는지를 생각해야 한다.&lt;/strong&gt; 확신할 수 없다면 복사본을 만들어 저장해야 한다.&lt;/p&gt;

&lt;p&gt;내부 객체를 클라이언트에 돌려줄 떄도 방어적 복사본을 만드는 이유도 마찬가지이다. 안심할 수 없다면 방어적 복사를 해야 한다. 길이가 1 이상인 배열은 무조건 가변임을 잊지 말자.&lt;/p&gt;

&lt;p&gt;방어적 복사는 성능 저하가 따르고, 또 항상 쓸 수 있는 것도 아니다. 호출자가 컴포넌트 내부를 수정하지 않는다고 확신할 수 있다면 생략할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;51-메서드-시그니처를-신중히-설계하라&quot;&gt;51. 메서드 시그니처를 신중히 설계하라.&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;메서드 이름은 신중히 짓자.&lt;/strong&gt; 항상 표준 명명 규칙을 따르고 이해할 수 있으며 같은 패키지에 속한 다른 이름들과 일관되게 지어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;편의 메서드를 너무 많이 만들지 말자.&lt;/strong&gt; 모든 메서드는 각각 자 자신의 소임을 다해야 한다. 메서드가 너무 많은 클래스는 익히고, 사용하고, 문서화하고 테스트하고 유지보수하기 힘들다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;매개변수 목록은 짧게 유지하자.&lt;/strong&gt; 4개 이하가 좋다. 특히 &lt;strong&gt;같은 타입의 매개변수 여러 개가 연달아 나오는 경우가 특히 해롭다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;과하게 긴 매개변수 목록을 줄이기 위한 방법은 3가지가 있다.
&lt;strong&gt;여러 메서드로 쪼갠 후 쪼갠 메서드 각각은 원래 매개변수 목록의 부분집합을 받도록 한다.&lt;/strong&gt; 메서드가 너무 많아질 수 있지만 &lt;strong&gt;직교성(orthogonality)&lt;/strong&gt;를 높여 오히려 메서드 수를 줄여주는 효과도 있다. java.util.List 인터페이스가 그 예이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 리스트에서 특정 범위의 부분 리스트에서 특정 값의 인덱스를 찾는 것은&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 다음과 같이 subList와 indexOf 메서드의 조합으로 가능하다.&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;valueList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;valueList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;subList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;indexOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;소프트웨어 설계 영역에서 직교성이 높다라는 것은 &lt;strong&gt;공통점이 없는 기능들이 잘 분리되어 있다.&lt;/strong&gt; 혹은 &lt;strong&gt;기능을 원자적으로 쪼개 제공한다.&lt;/strong&gt; 정도로 해석할 수 있다. 위의 subList와 indexOf 메서드는 서로 관련이 없다. 서로 관련없는 기능을 개별 메서드로 제공하면 직교성이 높다고 할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;직교성이 높다라는 것이 오히려 메서드 수를 줄여주는 효과가 있다는 뜻은 &lt;strong&gt;기본 기능에 충실한 API를 설계해놓으면 아무리 복잡한 기능도 조합하여 구현함으로써 구현해야할 메서드의 개수가 줄어든다는 것이다.&lt;/strong&gt; 예를 들어 기본 기능 3개로 조합할 수 있는 기능을 7가지가 된다. 기능을 원자적으로 쪼개다보면 자연스럽게 코드 중복이 줄어들고 결합성이 낮아져 코드를 수정하기 수월해진다. 테스트하기 쉬워짐은 물론이다. 일반적으로 직교성이 높은 설계는 가볍고 구현하기 쉽고 유연하면서 강력하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;그렇다고 너무 쪼개면 안되고 다루는 &lt;strong&gt;개념의 추상화 수준에 맞추어 조절해야 한다.&lt;/strong&gt; 특정 조합의 패턴이 자주 사용되거나 최적화하여 성능을 개선할 수 있다면 직교성이 낮아지더라도 편의 기능 하나로 제공하는 편이 나을 수 있다. 직교성은 절대적인 가치라기 보다는 &lt;strong&gt;철학과 원칙을 가지고 일관되게 적용해야 하는 설계 특성이다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;두 번째로 매개변수를 줄일 수 있는 방법은 &lt;strong&gt;매개변수 여러 개를 묶어주는 도우미 클래스를 만드는 것이다.&lt;/strong&gt; 특히 잇따른 매개변수 몇 개를 하나의 독립된 개념으로 볼 수 있을 때 추천한다.&lt;/p&gt;

&lt;p&gt;세 번째는 객체 생성 사용에 필요한 &lt;strong&gt;빌더 패턴&lt;/strong&gt;을 메서드 호출에 응용하는 것이다. 이 기법은 매개변수가 많은 데 그 중 일부는 생략해도 되는 경우가 있으며 도움이 된다. 모든 매개변수를 하나로 추상화한 객체를 정의하고 클라이언트에서는 setter를 통해 실제 매개변수를 설정 후 호출하도록 하는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;매개변수의 타입으로는 클래스보다는 인터페이스가 낫다.&lt;/strong&gt; 인터페이스 대신 클래스를 사용하면 클라이언트게 특정 구현체만 사용하도록 강제하는 꼴이 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;boolean 보다는 원소 2개짜리의 열거 타입이 매개변수 타입에 적합하다.&lt;/strong&gt; 열거 타입을 사용하면 코드 읽기가 쉬워지고 나중에 선택지를 더 추가할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;52-다중-정의-overloading은-신중히-사용하라&quot;&gt;52. 다중 정의 (Overloading)은 신중히 사용하라.&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CollectionClassifier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;classify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;집합&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;classify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;리스트&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;classify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;그 외&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collections&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(),&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BigInteger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(),&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;classify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 IDE를 사용해봐도 알겠지만, &lt;strong&gt;Collection&amp;lt;?&amp;gt; 타입의 매개변수를 받는 메서드만 호출된다.&lt;/strong&gt; 이유는 오버로딩된 메서드를 선택하는 것은 컴파일타임에 정해지기 때문이다. main 메서드 for문의 c는 항상 Collection&amp;lt;?&amp;gt; 타입이다. 런타임에는 달라지겠지만 호출할 메서드를 선택하는 데는 영향을 주지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;재정의(Overriding)한 메서드는 동적으로 선택되고, 다중정의(Overloading)한 메서드는 정적으로 선택되므로 주의가 필요하다.&lt;/strong&gt; 메서드를 재정의했다면 객체의 런타임 타입이 어떤 메서드를 호출할지의 기준이 된다.&lt;/p&gt;

&lt;p&gt;하지만 다중정의한 메서드 사이에서는 객체의 런타임 타입은 전혀 중요하지 않다. 호출할 메서드의 선택은 컴파일 타임에, 오직 매개변수의 컴파일타임 타입에 의해 정해진다. 따라서 다중정의된 API를 사용하는 사용자가 매개변수를 넘기면서 어떤 다중정의된 메서드가 호출될지를 모른다면 프로그램이 오동작하기 쉽다. &lt;strong&gt;다중정의가 혼동을 일으키는 상황은 피해야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;안전하고 보수적으로 가려면 매개변수의 수가 같은 다중정의는 만들지말자.&lt;/strong&gt; 가변인수를 사용하는 메서드라면 아예 다중정의를 하지말아야 한다. &lt;strong&gt;ObjectOutputStream&lt;/strong&gt; 클래스의 경우에는 모든 메서드에 다른 이름을 지어주는 길을 택했다. &lt;strong&gt;writeBoolean(boolean), writeInt(int), writeLong(long)&lt;/strong&gt; 같은 식이다.&lt;/p&gt;

&lt;p&gt;한편 생성자는 이름을 다르게 지을 수 없으므로 두 번째 생성자부터는 무조건 다중정의가 된다. 하지만 정적 팩터리라는 대안을 활용할 수 있다.&lt;/p&gt;

&lt;p&gt;다중정의된 메서드들이 &lt;strong&gt;함수형 인터페이스&lt;/strong&gt;를 인수로 받을 떄, 서로 다른 함수형 인터페이스라도 인수 위치가 같으면 혼란이 생길 수 있다. &lt;strong&gt;ExecutorService&lt;/strong&gt; 클래스의 submit 메서드가 그 예로, Runnable과 Callable 인터페이스를 다중 정의하여 혼란을 일으킨다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newCachedThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 컴파일 에러, Runnable을 받는 메서드를 호출하고자 했지만 Callable를 받는 메서드도 있어 혼란을 일으킨다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/java/2019-02-25-effective_java_08/00.png&quot; alt=&quot;00.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;println은 void를 반환하므로, 반환 값이 있는 Callable과 헷갈릴 리는 없다고 생각할 수도 있지만, 다중정의 메서드를 호출하는 알고리즘은 이렇게 동작하지 않는다. 따라서 메서드를 다중정의할 때 &lt;strong&gt;서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받아서는 안 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;기술적으로 말하면 System.out::println은 부정확한 메서드 레퍼런스(inexact method reference)이다. 암시적 타입 람다식이나 부정확한 메서드 레퍼런스 같은 인수 표현식은 목표 타입이 정해지기 전까지는 그 의미가 정해지지 않으므로, 적용성 테스트 때 무시된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;일반적으로 매개변수 수가 같을 때는 다중정의를 피하는 것이 좋다. 또한 다중정의시 어떤 다중정의 메서드가 호출될지 몰라도 기능은 같아야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;53-가변인수는-신중히-사용하라&quot;&gt;53. 가변인수는 신중히 사용하라.&lt;/h2&gt;

&lt;p&gt;인수 개수가 일정하지 않은 메서드를 정의해야 한다면 가변인수는 필요하다. 메서드 정의시 필수 매개변수는 가변인수 앞에 두고, 가변인수를 사용할 때는 성능 문제까지 고려해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;54-null이-아닌-빈-컬렉션이나-배열을-반환하라&quot;&gt;54. null이 아닌 빈 컬렉션이나 배열을 반환하라.&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cheese&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getCheeses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cheesesInStock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cheeseInStock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 식으로 null을 리턴하는 메서드를 사용한다면 클라이언트 입장에서는 이 null을 처리하는 코드를 추가로 작성해야 한다. 따라서 이보다는 비어 있는 컬렉션이나 배열로 리턴하는 것이 좋다.&lt;/p&gt;

&lt;p&gt;비어있는 컨테이너를 할당 후 리턴하는 것이 성능저하가 있다고 할 수는 있지만, 신경 쓸 수준이 못 된다. 그렇다하더라도 매번 같은 빈 불변 컬렉션을 반환하면 된다. &lt;strong&gt;Collections.emptyList&lt;/strong&gt; 메서드가 그 예다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;55-optional-반환은-신중히-하라&quot;&gt;55. Optional 반환은 신중히 하라.&lt;/h2&gt;

&lt;p&gt;자바 8 이전에는 특정 조건에서 값을 반환할 수 없을 때 취할 수 있는 선택지가 두 가지 있었다. 예외를 던지거나, null을 리턴하는 것이다.&lt;/p&gt;

&lt;p&gt;두 방법은 모두 헛점이 있는데, &lt;strong&gt;예외는 진짜 예외적인 상황에서만 사용해야 하며 스택 트레이스를 캡쳐하는 비용도 만만치 않다.&lt;/strong&gt; null을 반환하면 클라이언트 쪽에서는 별도의 null 처리 코드도 추가해야 한다.&lt;/p&gt;

&lt;p&gt;자바 8 이후 &lt;strong&gt;Optional&amp;lt;T&amp;gt;&lt;/strong&gt;를 통해 반환할 수 있다. 이 클래스는 원소 최대 하나를 가질 수 있는 불변 컬렉션으로서, 보통 T를 반환해야 하지만 특정 조건에서는 반환하지 못할 경우 사용할 수 있다. 이 컬렉션을 반환하는 메서드는 &lt;strong&gt;예외를 던지는 메서드보다 유연하고 사용하기 쉬우며, null을 반환하는 것보다 오류 가능성이 적다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Comparable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;빈 컬렉션&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;requireNonNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 메서드는 빈 컬렉션을 건네면 예외를 던진다. 다음은 Optional를 반환하는 메서드이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Comparable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;requireNonNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스트림의 종단 연산 중 상당수는 Optional을 반환한다. 따라서 다음과 같이 작성할 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Comparable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Comparator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;naturalOrder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 Optional을 반환하면 사용하는 클라이언트 쪽에서는 적절한 값을 받지 못했을 때의 행동을 쉽게 취할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 값이 없을 경우 orElse 메서드를 통해 대신 취할 값을 선택한다.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lastWordInLexicon&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;orElse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;단어 없음...&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lastWordInLexicon&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 Optional은 &lt;strong&gt;Checked 예외와 취지가 비슷하다.&lt;/strong&gt; 클라이언트 쪽으로 값이 없을 수도 있다는 점을 알려주고 클라이언트는 반드시 취할 행동을 선택해야 한다.&lt;/p&gt;

&lt;p&gt;없다면 다음과 같이 예외를 던지게 할 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 예와가 아닌 예외 팩터리를 사용한 것이다.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 예외가 실제로 발생하지 않는 한 예외 생성 비용은 발생하지 않는다.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Toy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myToy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;orElseThrow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;Exception:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 &lt;strong&gt;orElse&lt;/strong&gt; 메서드로 기본 값을 설정하는 비용이 크다면 &lt;strong&gt;Supplier 인터페이스&lt;/strong&gt;를 받는 &lt;strong&gt;orElseGet&lt;/strong&gt; 메서드를 사용할 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 기본 값이 필요없는 경우라도 바로 평가되므로 String 값은 매번 생성된다.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;orElse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;단어 없음...&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 기본 값이 없는 경우에 람다를 호출하여 생성하므로 매번 String 값을 생성하는 비용을 낮출 수 있다.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;orElseGet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;단어 없음...&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;반환 값으로 Optional을 사용한다고 해서 무조건 득이 되는 것은 아니다. 만약 컬렉션, 스트림, 배열과 같은 컨테이너 타입은 Optional로 감싸면 안된다. &lt;strong&gt;비어 있는 컬렉션을 반환하도록 해야 클라이언트 쪽에서 Optional 처리코드를 넣지 않아도 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;박싱된 기본 타입을 담은 Optional은 기본 타입 자체보다 무거울 수 밖에 없다. 값을 두 겹이나 감싸기 때문이다. 따라서 이를 위해 &lt;strong&gt;OptionalInt, OptionalLong, OptionalDouble&lt;/strong&gt;과 같은 클래스도 제공한다. Optional&amp;lt;Integer&amp;gt;와 같이 사용할 이유가 없다.&lt;/p&gt;

</description>
        <pubDate>Mon, 25 Feb 2019 00:00:00 +0000</pubDate>
        <link>https://dhsim86.github.io/java/2019/02/25/effective_java_08-post.html</link>
        <guid isPermaLink="true">https://dhsim86.github.io/java/2019/02/25/effective_java_08-post.html</guid>
        
        <category>java</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>Effective Java 07 - 람다와 스트림</title>
        <description>&lt;h1 id=&quot;람다와-스트림&quot;&gt;람다와 스트림&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;42-익명-클래스보다는-람다를-사용하라&quot;&gt;42. 익명 클래스보다는 람다를 사용하라.&lt;/h2&gt;

&lt;p&gt;예전에는 자바에서 함수 타입을 표현할 때 추상 메서드를 하나만 담은 인터페이스(혹은 추상 클래스)를 사용했다. 이런 인터페이스의 인스턴스를 &lt;strong&gt;함수 객체&lt;/strong&gt;라고 하여 특정 함수나 동작을 나타내는 데 썼다.&lt;/p&gt;

&lt;p&gt;JDK 1.1이 등장하면서 함수 객체를 만드는 주요 수단은 &lt;strong&gt;익명 클래스&lt;/strong&gt;가 되었다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Comparator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;전략 패턴처럼, 함수 객체를 사용하는 과거 객체 지향 디자인 패턴에서는 익명 클래스면 충분하였다. 위의 코드에서 Comparator 인터페이스가 정렬을 담당하는 &lt;strong&gt;추상 전략&lt;/strong&gt;을 뜻하여 구체적인 전략을 &lt;strong&gt;익명 클래스&lt;/strong&gt;를 통해 구현했다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;익명 클래스 방식은 코드가 너무 길어서, 이전의 자바는 함수형 프로그래밍에 적합하지 않았다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;자바 8에 와서 &lt;strong&gt;추상 메서드 하나만 가지는 인터페이스는 특별히 대우를 받게 되었다.&lt;/strong&gt; 지금은 &lt;strong&gt;함수형 인터페이스&lt;/strong&gt;라고 부르는 이 인터페이스의 인스턴스들을 &lt;strong&gt;람다식&lt;/strong&gt;을 사용해 만들 수 있게 된 것이다.&lt;/p&gt;

&lt;p&gt;람다는 함수나 익명 클래스와 개념은 비슷하지만 코드는 훨씬 간결하다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드에서 람다, 매개변수 및 반환 값의 타입은 각각 Comparator&amp;lt;String&amp;gt;, String, int이지만 코드에서는 언급이 없다. 이는 컴파일러가 &lt;strong&gt;문맥을 살펴보고 타입을 추론한 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;람다-표현식&quot;&gt;람다 표현식&lt;/h3&gt;

&lt;p&gt;참고: &lt;a href=&quot;https://multifrontgarden.tistory.com/124&quot;&gt;Java8#01.람다 표현식(Lambda Expression)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;람다의 핵심은 지울 수 있는 것은 모두 지우자는 것이