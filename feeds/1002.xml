<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by CookAtRice on Medium]]></title>
        <description><![CDATA[Stories by CookAtRice on Medium]]></description>
        <link>https://medium.com/@cookatrice?source=rss-d0b8d1e57662------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/0*xG9YOZuVPIEx9SL9.jpg</url>
            <title>Stories by CookAtRice on Medium</title>
            <link>https://medium.com/@cookatrice?source=rss-d0b8d1e57662------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Sun, 12 May 2019 23:48:14 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@cookatrice" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[awesome!]]></title>
            <link>https://medium.com/@cookatrice/awesome-7030c879b7d6?source=rss-d0b8d1e57662------2</link>
            <guid isPermaLink="false">https://medium.com/p/7030c879b7d6</guid>
            <dc:creator><![CDATA[CookAtRice]]></dc:creator>
            <pubDate>Tue, 17 Jul 2018 09:46:30 GMT</pubDate>
            <atom:updated>2018-07-17T09:46:30.488Z</atom:updated>
            <content:encoded><![CDATA[<p>awesome!</p><p>thanks~~ :)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7030c879b7d6" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[와우~!!!]]></title>
            <link>https://medium.com/@cookatrice/%EC%99%80%EC%9A%B0-5a225687841c?source=rss-d0b8d1e57662------2</link>
            <guid isPermaLink="false">https://medium.com/p/5a225687841c</guid>
            <dc:creator><![CDATA[CookAtRice]]></dc:creator>
            <pubDate>Tue, 06 Jun 2017 12:33:23 GMT</pubDate>
            <atom:updated>2017-06-06T12:33:23.459Z</atom:updated>
            <content:encoded><![CDATA[<p>와우~!!!</p><p>모든 글에 밑줄을 그어, 구구절절 되새기고 싶은 글 입니다.</p><p>아~ 좋습니다~:)</p><p>내가 진정 원하는 <strong>행복</strong>과 그런 사람이 되기위해, 나는 어떻게 살고 있는가에 대해 다시한번 생각 해 볼 수 있는 시간이 되었습니다.</p><blockquote>어떻게 단 한 번만에 인생의 과제를 찾고자 욕심내는가?</blockquote><p>저도 명심하겠습니다. 감사합니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5a225687841c" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[감사합니다 :)]]></title>
            <link>https://medium.com/@cookatrice/%EA%B0%90%EC%82%AC%ED%95%A9%EB%8B%88%EB%8B%A4-3ee3c850009f?source=rss-d0b8d1e57662------2</link>
            <guid isPermaLink="false">https://medium.com/p/3ee3c850009f</guid>
            <dc:creator><![CDATA[CookAtRice]]></dc:creator>
            <pubDate>Thu, 02 Feb 2017 00:43:39 GMT</pubDate>
            <atom:updated>2017-02-02T00:43:39.725Z</atom:updated>
            <content:encoded><![CDATA[<p>감사합니다 :)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3ee3c850009f" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[항상 좋은글 감사합니다. :)]]></title>
            <link>https://medium.com/@cookatrice/%ED%95%AD%EC%83%81-%EC%A2%8B%EC%9D%80%EA%B8%80-%EA%B0%90%EC%82%AC%ED%95%A9%EB%8B%88%EB%8B%A4-26c244384e0?source=rss-d0b8d1e57662------2</link>
            <guid isPermaLink="false">https://medium.com/p/26c244384e0</guid>
            <dc:creator><![CDATA[CookAtRice]]></dc:creator>
            <pubDate>Tue, 22 Mar 2016 08:48:41 GMT</pubDate>
            <atom:updated>2016-03-22T08:48:41.387Z</atom:updated>
            <content:encoded><![CDATA[<p>항상 좋은글 감사합니다. :)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=26c244384e0" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Upgrading apps to Angular2 using ngUpgrade]]></title>
            <link>https://medium.com/@cookatrice/upgrading-apps-to-angular2-using-ngupgrade-c0fd489bef10?source=rss-d0b8d1e57662------2</link>
            <guid isPermaLink="false">https://medium.com/p/c0fd489bef10</guid>
            <category><![CDATA[angularjs2]]></category>
            <category><![CDATA[angularjs]]></category>
            <category><![CDATA[javascript]]></category>
            <dc:creator><![CDATA[CookAtRice]]></dc:creator>
            <pubDate>Fri, 01 Jan 2016 01:47:35 GMT</pubDate>
            <atom:updated>2016-01-01T01:48:26.682Z</atom:updated>
            <content:encoded><![CDATA[<h3>Upgrading apps to Angular 2 using ngUpgrade</h3><h4>ngUpgrade를 사용하여 애플리케이션을 angular2로 업그레이드 해봅시다.</h4><blockquote>2014년 12월 15일. 드디어 angular 2 beta버전이 출시되었습니다. 이제 어느정도 안정화가 되었으니 새롭게 무엇인가를 준비한다면 angular2 버전을 사용 할 때가 된것 같네요. :) 하지만 아직까지 많은 애플리케이션이 angular1으로 작성되어있습니다. 기존 버전으로 작성된 애플리케이션을 어떻게 해야 할까요? 지난번 <a href="https://medium.com/@cookatrice/tips-to-improve-angularjs-performance-410cf42de57f#.g16cn3yts">Tips to Improve AngularJS Performance(AngularJS 성능향상을 위한 11가지팁)</a> 포스팅에서 성능향상을 언급했지만, angular2사용에 대한 아쉬운점들이 있었습니다. 그래서 다른 더 좋은 방법이 있지 않을까 찾아봤는데, angular1을 angular2로 업그레이드 하는데 도움이 되는 좋은글을 발견했습니다. 그냥 혼자만 보고 끝내면 시간은 적게 들겠지만, 여럿이 같이 보면 더 즐거울것 같아서 읽었던 글을 공유 해 봅니다.</blockquote><blockquote><em>ps. 언제나 그렇듯이 그냥 편하게 읽으시라 번역한 글이니, 정확히 이해가 되시지 않으시다면 </em><a href="http://blog.thoughtram.io/angular/2015/10/24/upgrading-apps-to-angular-2-using-ngupgrade.html"><em>원문</em></a><em>을 읽는것을 추천드립니다.</em></blockquote><blockquote><em>ps. 몇일 전 까지만 해도 ‘</em><strong><em>알아둘 사항</em></strong><em>’ 이라는 단락이 있었는데, 이 글을 포스팅 하기 전 다시 확인해 보니 사라졌네요. :0</em></blockquote><p><strong><em>알아 둘 사항 : </em></strong><em>이 문서에는 알파 상태라 정기적으로 업데이트 할 필요가있는 API를 기반으로 한 콘텐츠가 포함되어 있습니다. 여러분이 나중에 언제든지 이 글을 읽을 수 있게, 가능한 최신의 글을 유지하기 위해 노력했습니다. </em><strong><em>마지막 업데이트는 2015년 12월 12일</em></strong><em> 입니다. </em><strong><em>(원문에서 이 단락은 이제 사라졌습니다. :0)</em></strong></p><p>angular2가 다가오는 이 시점에, 기존의 angularJS 애플리케이션을 angular2로 업그레이드 하는것은 확실히 흥미로운 주제중의 하나입니다. 오랜시간동안 업그레이드하는 방법은 현시점에서 불명확해 보였습니다. angular2는 여전히 알파상태였고, API는 아직 불안정한 상태였습니다. 이것들은 어떻게 진행해야 하는지, 무엇이 가장 최선의 방법인지, 업그레이드 방법을 ‘추정하기’ 더 힘들게 만들었습니다.</p><p>그렇지만 올해 초, angular 팀은 유용한 업그레이드 전략과 두 프레임워크가 동일한 웹 사이트에서 함께 실행되기 위해서 서로작동(<a href="https://en.wiktionary.org/wiki/interoperate">interperate</a>) 해야 한다는것에 대해서 <a href="http://angularjs.blogspot.de/2015/08/angular-1-and-angular-2-coexistence.html">공식발표</a>했습니다. 하지만 블로그 포스트는 간략히 훑어 보았을 때, 어떠한 코드도 나타나있지 않았습니다. <a href="https://docs.google.com/document/d/1xvBZoFuNq9hsgRhPPZOJC-Z48AHEbIBPlOCBTSD8m0Y">설계용 문서</a>는 API를 어떻게 표현할지에 대한 더 구체적인 아이디어를 주기위해 만들어졌습니다.</p><p>그동안에 ngUpgrade의 첫번째 구현은 코드로 만들어졌고 이제 그것을 파헤쳐 볼 시간입니다. 이 문서에서는 업그레이드를 준비하기위해 무엇을 할 수 있는지 탐구해 볼 것입니다. 물론, 마지막에는 애플리케이션을 angular2로 업그레이드 하기 위해 ngUpgrade를 사용하는 방법도 알아볼 것입니다.</p><h3><strong>업그레이드는 왜 해야 할까요? ( Why upgrade? )</strong></h3><p>사람들은 여러가지 이유로 angular2로 업그레이드를 할 수 없습니다. 그 중 하나는 좋지않은 일이 발생될까 겁이나서 거절하는 경우입니다. 먼저 업그레이드가 필요한 경우에 대해 생각해 봅시다. 물론 angular2는 프레임워크의 차기 주요버전입니다. 그리고 미래에 웹 애플리케이션을 구축 할 때 틀림없이 함께 가고 싶은 버전이 될 것입니다.</p><p>하지만, 그것이 기존의 angular1 애플리케이션이 웹의 차세대에서는 더이상 살아남을 만큼 충분하지 않다는것을 의미하지는 않습니다. angular2가 출시됐다고해서 angular1이 즉시 작업을 중지해야 하는것은 아닙니다. 오래되었고 느려져 시대에 뒤떨어진것같은 거대한 웹사이트들도 여전히 존재합니다. 믿기 힘들겠지만, 이러한 웹사이트들 중에는 심지어 10년이 넘어도 여전히 돌아가는 사이트도 존재합니다. 웹의 장점이죠. 웹이 망가지는것을 누구도 원치 않기에 이전 프로그램과 호환이 되는것은 존재하지 않습니다. 그렇죠?</p><p>따라서, 프로세스 업그레이드를 살펴보기 전에 왜 업그레이드를 원하는지 스스로 진지하게 물어보고, 지금까지 구축했던 애플리케이션들이 지금 이 시점에 정말로 업그레이드가 필요한지를 생각해 보아야 합니다.</p><p>그럼에도 불구하고 업그레이드를 원하는 강력한 주장들이 있습니다. 아래에서 그 중 몇가지를 알아보겠습니다.</p><ul><li><strong>더 나은 성능</strong> — angular 2는 빠른 변경 감지 방법, 템플릿 프리컴파일(<a href="https://en.wiktionary.org/wiki/precompilation">precompilation</a>), 더 빨라진 부트스트랩 시간, 뷰 캐싱과 프레임워크를 매우 빠르게 만드는 많은 것들을 제공합니다.</li><li><strong>서버쪽 렌더링</strong> — angular의 다음 버전은 애플리케이션 레이어와 렌더 레이어 두 부분으로 분리되어 있습니다. 이것이 웹 워커들이나 심지어 서버와 같은 브라우저 이외의 환경에서도 angular를 실행 할 수 있게 해 줍니다.</li><li><strong>더 강력한 템플레이팅</strong> — 새로운 템플릿 문법은 <a href="http://blog.thoughtram.io/angular/2015/08/11/angular-2-template-syntax-demystified-part-1.html">여기</a>서 논의된 바와 같이 정적으로 분석이 가능합니다. 그리고 많은 디렉티브를 제거하고 웹 컴포넌트와 다른 엘리먼트들로 더 나은 통합을 합니다.</li><li><strong>더 나은 에코시스템</strong> — 물론, 이 글을쓰는 시점에서도 이것은 사실이 아닙니다. 하지만 angular 2의 에코시스템은 앞으로 더 나아지고 더 흥미로워 질 것입니다.</li></ul><p>angular1보다 angular2가 더 나은 확실한 이유들은 더 있습니만, 이 글에서는 업그레이드 동기에 대해서 논의하기로 했다는것을 잊지마세요. 그럼 실제 업그레이드를 위해서 미리 준비 할 수 있는 방법에 대해서 얘기 해 볼까요.</p><h3><strong>angular 2의 변경사항 ( Changes in Angular 2 )</strong></h3><p>업그레이드를 하기위해서, angular 2가 어떤점에서 다른지 이해 할 필요가 있습니다. 유감스럽게도, 프레임워크 두 버전 사이의 큰 차이를 커버하는 것은 이 글의 범위를 벗어납니다. 하지만, 여러분이 angular2를 완전 처음 접하신다면, <a href="http://blog.thoughtram.io/exploring-angular-2/">angular2 둘러보기</a>를 확인하신 후 시작하세요.</p><p>업그레이드에 대해 생각할 때 매우 결정적인 변경사항 목록이 여기에 있습니다.</p><ul><li><strong>컴포넌트 (Components)</strong> — 컴포넌트는 angular2로 애플리케이션을 만들때 사용되는 새로운 구성요소입니다. 애플리케이션 자체 및 거의 모든 것들이 컴포넌트 입니다.</li><li><strong>입/출력 (Inputs / Outputs)</strong> — 컴포넌트는 입력과 출력을 통해서 커뮤니케이션합니다. 만약 브라우저에서 실행되고 있다면, 속성과 이벤트같은 요소들 입니다. <a href="http://blog.thoughtram.io/angular/2015/08/11/angular-2-template-syntax-demystified-part-1.html">Angular 2 템플릿 문법의 애매함 제거</a>라는 글에서 어떻게 동작하는지 설명하고 있습니다.</li><li><strong>컨텐츠 투영 (Content Projection)</strong> — 기본적으로 새로운 트랜스클루전(<a href="https://en.wikipedia.org/wiki/Wikipedia:Transclusion">transclusion</a>)이지만, 웹 컴포넌트 표준과 더 잘 맞습니다.</li><li><strong>의존성 주입 (Dependency Injection)</strong> — 애플리케이션 전체를 위해 하나의 인젝터를 가지는대신에, angular 2에서는 각각의 컴포넌트들마다 자신의 인젝터를 가집니다. 이에 대한 상세 <a href="http://blog.thoughtram.io/angular/2015/05/18/dependency-injection-in-angular-2.html">문서</a>을 참고하세요.</li></ul><p>물론, angular2에는 <a href="http://blog.thoughtram.io/angular/2015/06/16/routing-in-angular-2.html">라우팅</a>, 폼, Http 계층 이외에 변경되거나 프레임워크에 새로 추가된 방법들이 더 있습니다.</p><h4><strong>어떻게 해야 할까요? ( How do we get there? )</strong></h4><p><a href="https://twitter.com/cburgdorf">Christoph</a>와 함께 thoughtram에서 다수의 리서치를 한 후, 전체 업그레이드 프로세스는 기본적으로 준비와 업그레이드 두 단계로 분류 할 수 있다는것을 알게되었습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/608/1*CI6UyBnlbJqQJYI_GDeECA.png" /></figure><h4><strong>준비</strong></h4><p>현재 우리가 시작 할 수 있는 단계입니다. 나중에 업그레이드 프로세스를 쉽게 만들기 위해 지금 무엇을 할 수 있을까요? 이것은 애플리케이션을 어떻게 구성할 것인가, 어떤 툴을 사용할 것인가, 아니면 어떤 언어로 업그레이드 할 것인가와 같은 몇가지 사항들을 포함합니다.</p><h4><strong>업그레이드</strong></h4><p>두 프레임워크를 함께 실행하는 단계입니다. ngUpgrade는 angular1과 angular2의 컴포넌트를 공동으로 이용 가능하도록 동작하게 됩니다. 동일한 웹사이트에 두 프레임워크를 실행하는것은 확실히 적합하지 않으므로, 이 단계의 목적은 가능한 한 적게 그것을 유지해야 한다는점을 꼭 기억하세요.</p><h3><strong>업그레이드 준비 ( Preparing for upgrade )</strong></h3><p>실제 업그레이드를 위해 지금 준비 할 수 있는 것에 대해서 이야기 해 봅시다.</p><h4><strong>기능이나 컴포넌트에 의한 애플리케이션 층</strong></h4><p>시간이 지나도 여전히 가치있는 방법이 있습니다. 디렉티브들은 app/directives, 서비스들은 app/services, 컨트롤러들은 app/controllers과 같은 프로젝트 구조를 사용하는 애플리케이션을 아직까지 볼 수 있습니다. 여러분들은 아이디어를 가지고 있습니다. 작은 애플리케이션이 완전히 동작할 수 있도록 업그레이드를 하는데는 많은 시간이 걸리지 않습니다. 여러분은 컴포넌트에서 컴포넌트로 업그레이드를 하기를 원 할 수 있습니다. 기능/컴포넌트 보다 타입별로 애플리케이션 레이어를 가지는것은 소스를 추출해서 업그레이드하는것을 힘들게 만듭니다.</p><p>아래와 같이 가는것이 좋습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/625/1*Iv5sFMJ-w_3yrvxRhwaWcQ.png" /></figure><p>이 구조는 productDetail을 angular2로 업그레이드 한 뒤, 나중에 애플리케이션으로 다시 통합할 수 있도록 합니다. 모든것을 한곳에서 처리하기 때문에, 어떤것들이 productDetail 코드와 관련이 있다는 것을 잊을까 걱정 할 필요가 없습니다.</p><h4><strong>.factory()대신에 .service()를 사용하세요.</strong></h4><p>만약 프레임워크 뿐만 아니라 애플리케이션이 쓰여진 언어까지 업그레이드 할 계획이라면, 잠재적으로 서비스 클래스가 될 수 있는 모든 경우에 대해 .factory() 대신 .service()를 사용하는것을 심사숙고 해야 합니다. angular2에서는 서비스는 단지 논리적인 일을 하는 하나의 클래스일 뿐입니다. .service()가 더 잘 맞는 이유에 관한 더 많은 정보는 <a href="http://blog.thoughtram.io/angular/2015/07/07/service-vs-factory-once-and-for-all.html">이 문서</a>를 읽어보세요.</p><h4><strong>ES2015나 TypeScript로 새로운 컴포넌트를 작성하세요.</strong></h4><p>이것은 흥미로운 점입니다. 맨 처음 anguar2를 접했을 때, 몇몇 사람들은 갑작스런 클래스와 데코레이터로인해 깜짝 놀랐습니다. (이문서에서 설명 한 것처럼) angular2 앱을 TypeScript로 작성하지 <strong>않은</strong> 사실에도 불구하고, ES2015는 다음 표준화된 버전입니다. 이것은 어쨌든 조만간에 그것을 사용하게 될 것임을 의미합니다.</p><p><a href="http://blog.thoughtram.io/angularjs/es6/2015/01/23/exploring-angular-1.3-using-es6.html">현재의 ES2015로 angular를 작성하는 방법에 관한 글</a>을 작성했고, 업그레이드 하기위한 계획을 가지고 있었지만, <strong>새</strong> 컴포넌트를 ES2015나 TypeScript로 정확히 작성해야 했기에 즉시 할 수는 없었습니다.</p><p>아무리 그래도, <strong>기존 코드를 ES2015나 TypeScript로 업그레이드 한다는것은 정말이지 이해 할 수 없습니다.</strong></p><p>비록 그 작업이 업그레이드를 위한 준비에 논리적인 단계가 될 것으로 보인다 하더라도, angular2로 애플리케이션을 업그레이드 하기 전, 기존의 대형 코드를 먼저 ES2015나 TypeScript로 업그레이드 할 수 있는 방법에는 전혀 도움이 되지 않습니다.</p><p>만약 angular2로 업그레이드를 해야만 한다면, 아마 기존의 코드를 건드리지 않고, 컴포넌트로 컴포넌트를 재작성하는것이 더 의미가있습니다. 그러나 물론 이것은 애플리케이션이 얼마나 거대한지에 따라서 달라집니다.</p><p>다시 말하지만, 이것은 단지 언어 업그레이드 입니다. 그리고 업그레이드 자체에는 정말 도움이 되지 않습니다. 그러나 그것은 우리와 우리 팀이 그것으로 컴포넌트를 빌딩하는것 같이, 새로운 언어의 기능에 익숙해지는데 도움이 됩니다.</p><h4><strong>angular1에서 데코레이터 사용하기</strong></h4><p>물론, TypeScript로 언어를 업그레이드 하고 angular1을 위해 특별히 만들어진 데코레이터를 사용함으로써, 우리 코드를 angular2 코드 처럼 보이게 할 수 있습니다. <a href="https://github.com/hannahhoward/a1atscript">a1atscript</a>, <a href="https://github.com/pbastowski/angular2-now">angular2-now</a>, <a href="https://github.com/mikeryan52/angular-decorators">angular-decorator</a>, <a href="https://github.com/eaze/ng-classy">ng-classy</a>외에 많은 커뮤니티들이 관련된 프로젝트를 진행하고 있습니다.</p><p>그들은 angular1에 의미상 도움이 되는 데코레이터를 추가하는 동일한 문제를 해결하기위해 노력합니다. 하지만 정말 도움이 될까요? <strong>전 그렇게 생각하지 않습니다.</strong></p><p>뜻밖에도 우리를 위해 코드를 생성하는 훌륭한 데코레이터를 사용할 수 있기 때문에 개발자의 경험을 향상시킬 수 있습니다. 하지만 애플리케이션을 angular2로 업그레이드 하는데는 도움을 주지는 않습니다. 어떤 프로젝트, ng-forward 같은 경우는 angular1에 정확히 동일한 angular2 문법을 사용할 수 있도록 합니다.</p><p>이것은 여러분과 여러분의 팀이 angular1코드를 작성하는동안 angular2 애플리케이션을 작성하는 방법에 익숙해지고 있기 때문에, 일부를 확장하는데 도움이 될 수 있습니다. 하지만 다른한편으로, angular1 체계에 angular2 개념과 문법들을 밀어 넣으면 혼동스러울 수 있습니다. 데코레이터을 사용하여 프로젝트를 시작 할 때, 얼마나 실용적인가를 볼 수 있을것입니다.</p><h3><strong>업그레이드 전략 ( Upgrade Strategies )</strong></h3><p>이제 업그레이드 준비를 위해 우리가 무엇을 할 수 있는지를 알게되었습니다. 사용할 수 있는 두가지 업그레이드 전략중, 어느것이 우리에게 더 의미가 있는지 살펴보겠습니다.</p><p>기본적으로 두가지 전략이 있습니다.</p><ul><li>빅뱅 (Big Bang) — angular2로 전적으로 시작하여 전체 애플리케이션을 한번에 바꾸기</li><li>인크리멘탈 (Incremental) — 기존의 애플리케이션을 서비스나 컴포넌트를 한번에 하나씩 업그레이드</li></ul><h4><strong>어떤 방법을 사용해야 할까요?</strong></h4><p>이건 정말로 의존적입니다! 애플리케이션이 작은편이라면 빅뱅 재작성하는 방법이 아마도 업그레이드 하는 가장 쉽고 빠른 방법입니다. 애플리케이션이 큰편이고 연속적으로 배포되어야 한다면, 단지 업그레이드만 한 번에 할 수는 없습니다. 단계적으로 컴포넌트, 서비스를 업그레이드 하는 방법이 필요합니다. 이런 상황에서 인크리멘탈(incremental) 업그레이드가 쓰입니다.</p><p>결국 마지막에 정말 문제가 되는것은 프로세스를 업그레이드하기 위해 얼마나 많은 시간을 가지고 있는가 하는 점입니다. 많은 개발자들이 어떻게 돌아가는지를 확인하고 이해하기를 원하기 때문에, 여기서는 인크리멘탈(incremental)업그레이드에 초점을 맞추겠습니다.</p><h3><strong>ngUpgrade를 이용한 업그레이드 (Upgrading using ngUpgrade)</strong></h3><p>두 프레임워크를 함께 실행하고 컴포넌트들이 상호 정보교환이 가능하게 만들기 위해서, angular 프로젝트는 ngUpgrade 모듈을 함께 제공합니다. 이 모듈은 겉으로 어댑터와 같은 역할을 합니다. 그래서 우리는 실제 두 프레임워크가 함께 동작하고 있다는것을 느낄 수 없습니다.</p><p>이렇게 동작하기 위해서 4가지 상호작용(interoperate)이 필요합니다.</p><ul><li><strong>의존성 주입 (Dependency Injection)</strong> — angular2 서비스를 angular1 컴포넌트로 노출(expose)시킵니다. 그리고 반대도 마찬가지 입니다.</li><li><strong>컴포넌트 중첩 (Component Nesting)</strong> — angular1 디렉티브는 angular2 컴포넌트로 사용할 수 있습니다. 그리고 angular2 컴포넌트는 angular1의 디렉티브로 사용할 수 있습니다.</li><li><strong>컨텐츠 투영 / 트랜스클루전 (Content Projection / </strong><a href="https://en.wikipedia.org/wiki/Wikipedia:Transclusion"><strong>Transclusion</strong></a><strong>)</strong> — angular1 컴포넌트는 angular2 컴포넌트를 트랜스클루드(<a href="https://en.wiktionary.org/wiki/transclude">transclude</a>) 합니다. 그리고 anguarl2 컴포넌트를 angular1 디렉티브에 투영시킵니다.</li><li><strong>변경감지 (Change Detection)</strong> — angular2에는 angular1의 스코프 digest와 변경탐지기(change detector)가 이미 내재되어있습니다.</li></ul><p>상호운용되는 이 네 가지를 이용하여, 우리는 이미 컴포넌트에서 애플리케이션 컴포넌트로 업그레이드를 시작할 수 있습니다.</p><p>라우팅은 도움을 줄 수 있는 또다른 부분이지만, 반드시 필요한것은 아닙니다. 그렇게 때문에 우리는 업그레이드하는 동안 어떤 angular 1 라우팅 시스템을 완전히 유지 할 수 있습니다.</p><h4><strong>전형적인 업그레이드 프로세스</strong></h4><p>일반적인 업그레이드 프로세스는 아래와 같습니다.</p><ul><li>angular2와 업그레이드 모듈을 포함 합니다.</li><li>업그레이드 할 컴포넌트를 선택합니다. 그리고 선택한 컴포넌트의 컨트롤러와 템플릿을 angular2 문법으로 바꿉니다. (이제 angular2 컴포넌트 입니다. )</li><li>angular2 컴포넌트를 angular1 애플리케이션에서 동작하도록 다운그레이드 합니다.</li><li>업그레이드 할 서비스를 선택합니다. 이 때 약간의 변경이 요구됩니다. ( 특별히 ES2015에 있어서 )</li><li>2단계와 3단계(혹은 4단계까지)를 반복합니다.</li><li>angular1의 부트스트랩을 angular2 부트스트랩으로 변경합니다.</li></ul><p>컴포넌트를 angular2로 업그레이드하기 위해 ngUpgrade를 사용해 봅시다!</p><h4><strong>ngUpgrade를 사용해 부트스트랩핑 하기</strong></h4><p>angular1 애플리케이션을 ngUpgrade로 업그레이드 하는일이 가장 먼저 필요합니다. 애플리케이션을 angular2로 업그레이드 할 때는 반드시 최상위 레벨에 angular1 부트스트랩이 <strong>항상</strong> 있어야 합니다. 이것은 업그레이드가 진행되는 동안 angular2 컴포넌트는 항상 angular1 컴포넌트 내부에서 부트스트랩 됨을 의미합니다.</p><p>업그레이드를 원하는 애플리케이션으로 시작해 봅시다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/615/1*jNZMVbwUI_HQlTVdy8NvbQ.png" /></figure><p>평범한 예전 angular1 모듈은 일반적으로 ng-app 속성을 사용하여 <a href="https://en.wiktionary.org/wiki/bootstrap">부트스트랩</a> 됩니다. 하지만 지금부터는 ngUpgrade를 사용하여 부트스트랩을 할 수 있습니다. HTML에 있는 ng-app 속성을 제거하고, 업그레이드 모듈로부터 ngUpgrade 어댑터를 생성합니다. 그리고 모듈 의존성처럼 myApp을 어댑터의 bootstrap()으로 호출합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/617/1*qmsSni0VslJfycAoVFAO6A.png" /></figure><p>좋습니다. 이제 애플리케이션은 ngUpgrade를 사용하여 부트스트랩 되었고, angular1 컴포넌트와 angular2 컴포넌트들을 섞어서 사용할 수 있습니다.</p><h3><strong>angular2 컴포넌트 다운드레이드 (Downgrading Angular 2 compontnts)</strong></h3><p>첫 번째 컴포넌트를 angular2로 업그레이드 해 보고, angular1 애플리케이션에서 이를 사용해 봅시다. 업그레이드 할 productDetail 디렉티브가 아래에 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/612/1*HqA6dYWTWfUkntu1V7DjCQ.png" /></figure><p>이것을 angular2로 업그레이드를 하면 아래와 같이 볼 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/610/1*eHfigk_YSMC6ZiQH4ympyg.png" /></figure><p><strong>참고</strong>: 간단하기 때문에 이곳에 정의 했지만, 별도의 파일에 이 컴포넌트를 정의 할 수도 있습니다.</p><p>완벽하네요! 하지만 angular2 컴포넌트를 어떻게 angular1 애플리케이션에서 사용할 수 있을까요? 우리가 만들었던 UpgradeAdapter는 downgradeNg2Component() 메소드와 함께 제공됩니다. 이것은 angular2 컴포넌트를 받아서 angular1 디렉티브를 생성합니다. angular1 세계에서 angular2 컴포넌트를 사용해 볼까요.</p><h3><strong>angular1 컴포넌트 업그레이드 (upgrading Angular1 components)</strong></h3><p>어떤 컴포넌트를 이미 angular2로 업그레이드 한 경우에도 여전히 그 템플릿에서는 angular1 디렉티브를 사용 할 경우가 있을 수 있습니다. ngUpgrade는 upgradeNg1Component()를 사용하여 업그레이드 한 angular1 디렉티브를 angular2 컴포넌트에서 사용하게 해 줍니다.</p><p>아래와 같은 ProductList 컴포넌트를 가지는 애플리케이션의 업그레이드에 대해서 계속해서 이야기 해 봅시다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/596/1*8ry5rEjj9hykrqFZWtTzww.png" /></figure><p>&lt;product-list-item&gt;은 아직 angular2로 포팅되지 않은 컴포넌트입니다. 아마도 포팅 할 수 없는 이유가 있을 수도 있습니다. 이 컴포넌트는 업그레이드가 필요한데, 어떻게 해야 할까요? 보시다시피, @Component 메타데이터에는 디렉티브 속성이 있습니다. 이 속성은 컴포넌트의 템플릿에서 사용되는 디렉티브를 정의합니다. 이제 필요한것은 &lt;product-list-item&gt;도 거기에 추가하는 방법입니다.</p><p>upgradeNg1Component()는 정확하게 우리가 그 일을 가능하게 합니다. upgradeNg1Component()는 angular1 모듈 어딘가에 등록된 디렉티브의 이름을 사용하고, angular2 컴포넌트로 그것을 업그레이드 합니다. 여기 아래코드 같이 보일꺼예요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/596/1*aRP_FKJl7KkJlvVxbWESrg.png" /></figure><p>우리가 해야할 일은 ProductList 아이템을 다운그레이드하는 것입니다. 그리고는 바로 사용할 수 있습니다.</p><h3><strong>angular2 프로바이더 추가 ( Adding Angular 2 Providers )</strong></h3><p>컴포넌트를 업그레이드하는것은, 아마도 전체 업그레이드 과정중에 가장 중요한 부분입니다. 하지만 가끔씩, 컴포넌트는 두 버전 모두에서 동작하기 위해 필요한 서비스 의존성을 가지고 있습니다. 다행히도, ngUpgrade는 그것을 위한 API를 제공합니다.</p><p>이미 angular2로 업그레이드 된 ProductDetail 컴포넌트의 ProductService 의존성에 대해 얘기 해 봅시다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/598/1*Cwnqt6tFXApFfzveUz6Z0w.png" /></figure><p>angular2에서는 컴포넌트의 인젝터를 위해 프로바이더의 환경설정을 추가해야만합니다. 하지만 angular2를 사용해 부트스트랩을 하지 않기 때문에 그렇게 할 방법이 없습니다. ngUpgrade는 이 상황을 해결하기위해 addProvider() 메소드를 사용하여 프로바이더를 추가하도록 해 줍니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/598/1*s_2Iaz4kRvcFi5LsrFgO1w.png" /></figure><p>우리가 필요한것은 이것이 전부랍니다.!</p><h3><strong>angular1 프로바이더 업그레이드 (Upgrading Angular 1 Providers)</strong></h3><p>원격서버와 통신하기위해 다른 낮은 레벨의 DataService와 의존관계에 있는 ProductService에 대해 얘기해 볼까요. DataService는 아직 angular2로 업그레이드 되어있진 않지만, 이미 angular1 애플리케이션에 구현되어 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/597/1*J-Pt0cclGF2Wfa8wIoBR5A.png" /></figure><p>보시다시피, DataService 타입을 가지고 있지 않기 때문에, DataService의 프로바이더 토큰을 명시하기 위해서 @Injector를 사용합니다. 이해하기가 힘드시다면, <a href="http://blog.thoughtram.io/angular/2015/05/18/dependency-injection-in-angular-2.html">DI in Angular2</a> 문서를 더 읽어보세요.</p><p>어쨋든, angular2에는 아직까지 DataService를 위한 프로바이더가 없습니다. upgradeNg1Provier()를 사용하여 그것을 사용할 수 있도록 해 봅시다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/595/1*St4J0C8feHF5OlahLRwmKw.png" /></figure><p>흠! 훨씬 더 낫게 만들 수 있을것 같은데요. angular1 서비스가 이미 클래스로 작성되었다고 가정해 봅시다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/602/1*5K0zHVruhhgY26svFD0VRw.png" /></figure><p>이 클래스는 angular2에서 타입이나 의존성주입을 위한 토큰으로 사용할 수 있습니다. 우리가 해야 할 일은, 그 토큰으로 서비스를 업그레이드 하는 것이 전부입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/726/1*4Ry19qtTBEfUuCaW_Ho9WQ.png" /></figure><p>이제 확실히 이전타입의 어노테이션을 사용하여 그것을 주입할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/598/1*RaR0cIPAgjWVvIi8Zk14EQ.png" /></figure><p><strong>참고</strong> : TypeScript는 메타데이터를 전달하기 위해 적어도 하나의 데코레이터를 필요로 하기 때문에 서비스에 @Injectable()을 추가했습니다. <a href="http://blog.thoughtram.io/angular/2015/09/17/resolve-service-dependencies-in-angular-2.html">Injecting Services in Services in Angular2</a> 글에서 자세히 알아보세요.</p><h3><strong>angular2 프로바이더 다운그레이드 ( Downgrading angular 2 providers )</strong></h3><p>마지막이지만 앞서 말씀 드린것들과 마찬가지로 중요한 사항인데, angular1 컴포넌트에서 angular2 서비스를 사용하는것이 필요 할 수 있습니다. 이를위해 ngUpgrade는 downgradeNg2Provider() 메소드가 제공됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/599/1*RWfgB32B9pfSduYU1wV9tw.png" /></figure><h3><strong>결론 ( Conclusion )</strong></h3><p>ngUpgrade는 유용한 API를 많이 제공합니다. 그리고 그것은 정말 angular1에서 angular2로 애플리케이션을 업그레이드 함에있어 아주 큰 성과입니다.<a href="http://angularconnect.com/"> AngularConnect</a>에서 업그레이드 워크샵을 가졌었고, 소스 <a href="https://github.com/thoughtram/angular-upgrade-demo">저장소</a>를 공개함으로써 업그레이드 준비에서 부터 지나온 모든 과정을 확인할 수 있게 했습니다. steps 브랜치를 꼭 확인하세요.</p><p>이 문서가 좀 더 확실한 전체 업그레이드 이야기를 만들 수 있기를 기대합니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c0fd489bef10" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Tips to Improve AngularJS Performance]]></title>
            <link>https://medium.com/@cookatrice/tips-to-improve-angularjs-performance-410cf42de57f?source=rss-d0b8d1e57662------2</link>
            <guid isPermaLink="false">https://medium.com/p/410cf42de57f</guid>
            <dc:creator><![CDATA[CookAtRice]]></dc:creator>
            <pubDate>Thu, 17 Dec 2015 09:16:03 GMT</pubDate>
            <atom:updated>2015-12-18T00:40:16.965Z</atom:updated>
            <content:encoded><![CDATA[<h4>AngularJS 성능향상을 위한 11가지 팁</h4><blockquote>angular를 처음 접한지도 이제 2년 가까운 시간이 흘렀습니다. 잘(?) 써야지 하면서도 아직 디테일한 부분에선 버벅거리고, 항상 <a href="https://docs.angularjs.org/api">API Docs</a>를 뒤적이고 있네요. :)</blockquote><blockquote>오늘 올리는 글은 전반적으로 angular 1.x 성능향상(얼마전 <a href="https://plus.google.com/u/0/communities/109067040035659120428">GDG Korea WebTech</a>에서 하는 <a href="https://angular.io/">angular 2</a> 스터디에 가 보았는데, 1.x와 2.x는 개념적으로 적지않게 다른듯 합니다. <a href="https://angular.io/">angular 2</a>에서는 아직 테스트 해 보진 못했어요.)을 위한 팁 입니다. 회사 프로젝트에서 만들었던 웹을<a href="https://angular.io/"> angular 2</a>로 마이그레이션 하기 전, 조금이나마 성능을 높일 수 있는 방법을 찾아보다, 다른분들과 공유하기에 괜찮은 아티클이 있어서 함께 나누고자 합니다. 짧은 글이니 한번 얼른 읽어 보시고, 한번 적용해 보시겠어요? :)</blockquote><blockquote>ps. 언제나 그렇듯이 그냥 편하게 읽으시라 번역한 글이니, 정확히 이해가 되시지 않으시다면 <a href="http://www.alexkras.com/11-tips-to-improve-angularjs-performance">원문</a>을 읽는것을 추천드립니다.</blockquote><blockquote>ps. angular 2가 이제 알파에서 베타 버전이 되었네요. 관심이 있으시다면 <a href="https://angular.io/docs/ts/latest/">이곳</a>도 한번 방문 해 보세요.</blockquote><p>웹개발이 처음은 아니지만, Angular는 처음입니다. 그래서 제가 말하는 모든것들을 쉽사리 믿을 수 없다는것을 알아요. 하지만, 이 포스트는 많은 토론을 보고, Angular의 성능에 관련된 많은 기사를 읽은 조사결과의 요약입니다.</p><p>목차:</p><ol><li>watcher를 최소화 하거나 피하세요.</li><li>ng-repeat을 피하세요. 만약 여러분이 ng-repeat을 사용해야만 한다면 무한 스크롤이나 페이지네이션을 사용해야합니다.</li><li>가능하다면 일회성 바인딩을 사용하세요.</li><li>$watch 대신에 $watchCollection을 사용하세요. (3번째 파라메터와 함께)</li><li>가능하다면 반복되는 필터와 캐시 데이터를 피하세요.</li><li>ng-model의 debounce</li><li>ng-show 대신에 ng-if를 사용하세요. ( ng-if가 실제로 사용하는데 더 나은 방법임을 보여줍니다 )</li><li>함수를 벤치마킹하기 위해서 console.time을 사용하세요.</li><li>느린 함수를 위해 네이티브 자바스크립트나 Lodash를 사용하세요.</li><li>여러분 watcher의 벤치마킹을 위해 Batarang을 사용하세요.</li><li>성능의 병목지점을 확인하기위해 크롬의 Timeline과 profiler를 사용하세요.</li></ol><h3>1. watcher를 최소화하거나 피하세요 ( Minimize / Avoid watchers )</h3><p>일반적으로 여러분들의 angular 앱이 느리다면, 그것은 watcher가 매우 많거나 그 watcher들이 할 수 있는 것보다 더 많은 일을 하는 경우를 의미합니다.</p><p>angular는 앱의 모든 변화를 기록하기 위해 지저분한 체크(dirty checking)을 사용합니다. 이것은 업데이트가 필요할 때(digest 주기 호출) 모든 watcher들을 체크하기 위해 살펴보아야 함을 의미죠. 만약 어떤 watcher가 다른 watcher와 의존관계가 있다면, angular는 모든 변경들이 전파되었음을 확인하기위해 digest 주기를 다시 실행합니다. 모든 watcher들이 업데이트되고 앱이 안정화되기 전까지 이것은 계속 반복됩니다.</p><p>현대의 브라우저들이 매우 빠르게 자바스크립트를 실행함에도 불구하고, angular에서는 여러분들의 앱을 기어갈 정도로 느리게 만들, 매우 많은 watcher를 추가하는것은 아주 쉽습니다.</p><p>angular 앱을 구현하거나 리팩토링 할 때 아래의 내용을 명심하세요.</p><p><a href="http://www.codelord.net/2014/06/17/angular-performance-101-slides/">http://www.codelord.net/2014/06/17/angular-performance-101-slides/</a></p><ol><li>watchers 설정:</li></ol><ul><li>$scope.$watch</li><li>{{}} 타입의 바인딩</li><li>대부분의 디렉티브 (예. ng-show)</li><li>스코프 변수 scope : { bar : ‘=‘ }</li><li>필터 {{ value | myFilter }}</li><li>ng-repeat</li></ul><p>2. Watchers (digest 주기) 실행:</p><ul><li>사용자 액선 (ng-click 등등). 대부분의 디렉티브 빌트에서 digest주기 완료가 $scope.apply를 호출합니다.</li><li>ng-change</li><li>ng-model</li><li>$http 이벤트( 모든 ajax 호출 )</li><li>$q 프로미스 해결</li><li>$timeout</li><li>$interval</li><li>$scope.apply와 $scope.diges 수동호출</li></ul><h3><strong>2. ng-repeat을 피하세요. 만약 여러분이 ng-repeat을 사용해야만 한다면 무한 스크롤이나 페이지네이션을 사용해야합니다. (Avoid ng-repeat. If you have to use ng-repeat use infinite scrolling or pagination)</strong></h3><p>이것은 우리 앱에서 얻을 수 있는 가장 큰 사항입니다. 이것에 대해서는 자세히 설명하지는 않을꺼예요. 대신, 이를 주장하는 매우 도움이 되는 글을 발겼했거든요.</p><p><a href="http://www.williambrownstreet.net/blog/2013/07/angularjs-my-solution-to-the-ng-repeat-performance-problem/">http://www.williambrownstreet.net/blog/2013/07/angularjs-my-solution-to-the-ng-repeat-performance-problem/</a></p><p>게다가 무한 스크롤을 위해서, 가능하다면 반듯이 추적(track)을 사용하도록 합니다.</p><p><a href="https://docs.angularjs.org/api/ng/directive/ngRepeat#tracking-and-duplicates">https://docs.angularjs.org/api/ng/directive/ngRepeat#tracking-and-duplicates</a></p><p>예를 들어, 유일한 단계별 id는 ng-repeat을 동작할 때 추적을 하기 위한 좋은 값입니다.</p><pre><em>&lt;li ng-repeat = “Task in Tasks track by Task.Id&gt;&lt;/li&gt;</em></pre><h3><strong>3. 가능하다면 일회성 바인딩을 사용하세요. ( Use Bind once when possible )</strong></h3><p>angular 1.3 버전에서는 일회용 바인딩을 허용하기위해 :: 표기법을 추가했습니다. 요약하자면, angular는 digest주기의 첫번째 시리즈 이후의 어떤 값이 변하지 않을때까지 기다립니다. 그리고 Dom 엘리먼트를 표현하기위해 그 값을 사용합니다. 그 후 angular는 바인딩에 대해서 잊고 watcher를 제거합니다.</p><p><a href="https://code.angularjs.org/1.3.15/docs/guide/expression#one-time-binding">https://code.angularjs.org/1.3.15/docs/guide/expression#one-time-binding</a></p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fcodepen.io%2Fakras14%2Fembed%2Fpreview%2FQbWJRg%3Fheight%3D600%26slug-hash%3DQbWJRg%26default-tab%3Dresult%26host%3Dhttp%253A%252F%252Fcodepen.io&amp;url=https%3A%2F%2Fcodepen.io%2Fakras14%2Fpen%2FQbWJRg&amp;image=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fi.cdpn.io%2F139083.QbWJRg.small.a39c2534-4d29-455d-b7ba-a5dca4627fe9.png&amp;key=d04bfffea46d4aeda930ec88cc64b87c&amp;type=text%2Fhtml&amp;schema=codepen" width="800" height="600" frameborder="0" scrolling="no"><a href="https://medium.com/media/5269405710336cd8e5dcdeac10147302/href">https://medium.com/media/5269405710336cd8e5dcdeac10147302/href</a></iframe><p>만약 여러분이 angular 1.3 이전버전을 사용한다면, 비슷한 결과를 위해 이 라이브러리를 사용할 수 있습니다.</p><p><a href="https://github.com/Pasvaz/bindonce">https://github.com/Pasvaz/bindonce</a></p><h3><strong>4. $watch 대신에 $watchCollection을 사용하세요. (3번째 파라메터와 함께) (Use $watchCollection instead of $watch (with a 3rd parameter))</strong></h3><p>2개의 파라미터만을 가지는 $watch는 빠릅니다. 그렇지만 angular는 이 함수에서 3번째 파라미터를 지원합니다. 그것은 $watch(‘value’, function(){}, true)와 같이 표현합니다. 3번째 파라미터는 angular에게 깊은 체크(deep checking)를 실행하라고 말하는데, 이는 오브젝트의 모든 속성들까지 체크하라는 의미입니다. 이것은 매우 많은 자원이 소비됩니다.</p><p>이 성능문제를 해결하기위해, angular는 $watchCollection(‘value’, function(){})을 추가했습니다. $watchCollection은 오브젝트의 모든 속성들의 첫번째 레이어만을 체크한다는 점만 제외하면, 3번째 파라미터가 있는 $watch와 거의 비슷하게 동작합니다. 따라서 성능이 크게 향상됩니다.</p><p>공식문서 :</p><p><a href="https://code.angularjs.org/1.3.15/docs/api/ng/type/$rootScope.Scope#$watchCollection">https://code.angularjs.org/1.3.15/docs/api/ng/type/$rootScope.Scope#$watchCollection</a></p><p>도움이되는 블로그 포스트 :</p><p><a href="http://www.bennadel.com/blog/2566-scope-watch-vs-watchcollection-in-angularjs.htm">http://www.bennadel.com/blog/2566-scope-watch-vs-watchcollection-in-angularjs.htm</a></p><h3><strong>5. 가능하다면 반복되는 필터와 캐시 데이터를 피하세요. ( Avoid repeated filters and cache data whenever possible )</strong></h3><p>one-time 바인딩은 필터와는 잘 동작하지 않는것으로 보입니다. 그것을 동작하게 만드는것을 피하며 일하는것 같습니다. 하지만 제 생각에는 그것은 말끔하고, 단순히 변수에 값을 할당하는것 보다 더 직관적입니다. ( 아니면 어떤 오브젝트의 속성으로 설정하거나, 많은 변수를 처리하는 경우 )</p><p>예를들자면, 아래의 표기 대신에</p><pre>{{ ‘DESCRIPTION’ | translate }}</pre><p>여러분은 이렇게 할 수 있습니다.</p><ul><li>자바스크립트</li></ul><pre> $scope.description : $translate.instant(‘DESCRIPTION’)</pre><ul><li>HTML</li></ul><pre> {{::description}}</pre><p>아니면 이렇게요</p><pre>{{ step.time_modified | timeFormatFilter }}</pre><ul><li>자바스크립트</li></ul><pre>var timeFormatFilter = $filter(‘timeFormatFilter’);</pre><pre>step.time_modified = timeFormatFilter(step.time_modified);</pre><ul><li>HTML</li></ul><pre> {{ step.time_modified }}</pre><h3><strong>6. ng-model의 debounce (Debounce ng-model)</strong></h3><p>만약 여러분이 어떠한 ng-model에 많은 변화가 있을 것을 알고 있다면, 입력을 디바운스(debounce, 모델 업데이트 시간제어를 의미합니다., 단위는 ms) 할 수 있습니다.</p><p>예를 들어 구글과 같은 검색 입력창이 있다면, 여러분은 ng-model의 옵션으로 디바운스를 다음과 같이 설정 할 수 있습니다.</p><pre>ng-model-options=“{debounce:250}”</pre><p>이것은 이 입력 모델 변화에 의한 digest주기가 250ms마다 한 번만 발생되는것을 보장합니다.</p><p><a href="https://docs.angularjs.org/api/ng/directive/ngModelOptions">https://docs.angularjs.org/api/ng/directive/ngModelOptions</a></p><h3><strong>7. ng-show 대신에 ng-if를 사용하세요. ( ng-if가 실제로 사용하는데 더 나은 방법임을 보여줍니다 ) (Use ng-if instead of ng-show (but confirm that ng-if is actually better for your case ))</strong></h3><p><strong>ng-show</strong>는 엘리먼트를 표현하고 <strong><em>display:none</em></strong>을 통해 그것을 숨깁니다.</p><p><strong><em>ng-if</em></strong>는 DOM의 엘리먼트를 실제로 제거하고 필요할 때 다시 생성합니다.</p><p>여러분들은 자주 off로 전환하는 엘리먼트 때문에 ng-show가 필요할 수도 있습니다. 하지만 95%의 경우가 ng-if로 가는것이 더 좋은 방법입니다.</p><h3><strong>8. 함수를 벤치마킹하기 위해서 console.time을 사용하세요. ( Use console.time to benchmark your functions )</strong></h3><p>console.time은 훌륭한 API입니다. 그리고 angular 성능과 관련된 이슈를 디버깅 할 때, 특별하게 도움이 된다는것을 발견했습니다. 저는 제 리팩토링이 성능을 개선하는것이 사실인가를 확인하는것을 돕기위해 내 코드 도처에 다수의 console.time을 배치했습니다.</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/time">https://developer.mozilla.org/en-US/docs/Web/API/Console/time</a></p><p>API는 아래와 같습니다.</p><pre>console.time(“TimerName”);</pre><pre><em>//Some code</em></pre><pre>console.timeEnd(“TimerName”);</pre><p>아래는 간단한 예제입니다.</p><pre>console.time(“TimerName”);</pre><pre>setTimeout(<strong>function</strong>(){</pre><pre>console.timeEnd(“TimerName”);</pre><pre>}, 100);</pre><pre><em>//In console $: TimerName: 100.324ms</em></pre><p>만약 console.time이 여러분들이 원하는 만큼 충분히 정확하지 않다면, performance.now()를 읽고 사용함으로써 더 정확한 결과를 얻을 수 있습니다. 이 방법을 선택하는경우라면 결과계산은 직접 하셔야 합니다.</p><p><a href="https://docs.google.com/presentation/d/15XgHRI8Ng2MXKZqglzP3PugWFZmIDKOnlAXDGZW2Djg/edit#slide=id.g10d2b49c1_0143">https://docs.google.com/presentation/d/15XgHRI8Ng2MXKZqglzP3PugWFZmIDKOnlAXDGZW2Djg/edit#slide=id.g10d2b49c1_0143</a></p><pre>totalTime = 0; count = 0;</pre><pre><strong>var</strong> someFunction = <strong>function</strong>() {</pre><pre><strong>var</strong> thisRunStartTime = performance.now();</pre><pre>count++;</pre><pre><em>// some code</em></pre><pre><em>// some more code</em></pre><pre>totalTime += performance.now() — thisRunStartTime;</pre><pre>};</pre><pre>console.log(“Average time: “ + totalTime/count);</pre><h3><strong>9. 느린 함수를 위해 네이티브 자바스크립트나 Lodash를 사용하세요. ( Use native JavaScript or Lodash for show functions )</strong></h3><p>우리 앱들은 이미 lodash를 사용하고 있습니다. 그래서 저의 최적화에서는 lodash를 사용하기위해 별다른 조치는 필요하지 않았습니다. 만약 lodash가 포함되어있지 않았다면 아마도 네이티브 자바스크립트로 모든것들을 재작성했을 것입니다.</p><p>테스트에서 angular에 내장되어있는 믿을만한 메소드들 대신에, lodash와 기본로직 일부를 재작성하여 상당한 성능향상을 얻었습니다. ( 훨씬 더 일반적인 사용 사례를 설명해야합니다. )</p><p><a href="https://jsperf.com/">https://jsperf.com/</a>의 공동제작자이자 Lodash의 관리자인 John-Dalton은 퍼포먼스의 대가입니다. 그래서 전 그를 믿고, 속도에 관해서라면 그와 그의 라이브러리를 신뢰합니다.</p><h3><strong>10. 여러분 watcher의 벤치마킹을 위해 Batarang을 사용하세요. ( Use Beatarang to benchmark your watchers )</strong></h3><p>Batarang은 디버깅하는 수고에 매우 도움을 주는, Angular팀에서 제작한 훌륭한 툴입니다. 그것은 유용한 기능을 많이 가지고 있지만, 이 사용 사례와 가장 관련있는 하나는 성능탭 입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*cc_qEZ0coJzTRggj2l6VOw.png" /></figure><p>반드시 대부분의 사용자들을 위해 동작하는 안정화 버전을 얻으세요.</p><p><a href="https://chrome.google.com/webstore/detail/angularjs-batarang-stable/niopocochgahfkiccpjmmpchncjoapek">https://chrome.google.com/webstore/detail/angularjs-batarang-stable/niopocochgahfkiccpjmmpchncjoapek</a></p><p>Batarang에 대해 좀 이해가 필요하시다면, 동영상을 시청하시구요.</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2Fq-7mhcHXSfM%3Ffeature%3Doembed&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Dq-7mhcHXSfM%26feature%3Dyoutu.be&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2Fq-7mhcHXSfM%2Fhqdefault.jpg&amp;key=d04bfffea46d4aeda930ec88cc64b87c&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/ca687243be6f971e942e8e50edf4e021/href">https://medium.com/media/ca687243be6f971e942e8e50edf4e021/href</a></iframe><h3><strong>11. 성능의 병목지점을 확인하기위해 크롬의 Timeline과 profiler를 사용하세요. ( Use Chrome Timeline and Profiler to identify performance bottlenecks )</strong></h3><p>저는 제 스스로 크롬 개발자 툴의 파워유저라고 생각하기를 좋아합니다. 단지 가끔 Timeline과 Profiler 화면을 사용하는것이 아닙니다. 이 프로젝트에서는 두가지 다 매우 유용합니다.</p><p>프로 팁 : console.time API를 사용하는 경우(팁 # 8 참조), 기간이 타임 라인 스냅 샷에서 강조 얻을 것입니다 . 그러면 여러분은 가장 관심있는 정확한 시간을 검사 할 수 있습니다.</p><p><a href="https://developer.chrome.com/devtools/docs/timeline#user-produced-timeline-events">https://developer.chrome.com/devtools/docs/timeline#user-produced-timeline-events</a></p><p>timeline 화면과 마법같은 60fps의 라인은 매우 중요합니다. 저희의 프로젝트를 시작했을 때, 애플리케이션은 사용자에게 거의 완벽히 응답하기까지 풀 스트림으로 표현하는데 15초 이상이 걸렸습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*s4dcI5yCj8xnHwF3VZ_ZFg.png" /></figure><p>성능 최적화를 한 뒤에는, 애플리케이션은 이제 완전히 표현하는데 2초 이내였고(시간축척이 다름을 유의), 비교적 짧은 지연 후에 사용자가 UI와 자유롭게 상호작용할 수 있도록 되었습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*sNAIH9X72jHUzEvEbJXaXg.png" /></figure><p>이미지를 살펴 본다면 애플리케이션을 더 최적화 할 수 있다는 것이 확실합니다. 하지만 저는 있는 그대로 사용자 경험의 발전에 매우 만족합니다.</p><p>timeline 화면으로 더 많은 경험을 얻으려면, Paul Irish의 이러한 웹 검사를 확인하시기 바랍니다.</p><p><a href="https://docs.google.com/document/d/1K-mKOqiUiSjgZTEscBLjtjd6E67oiK8H2ztOiq5tigk/pub">https://docs.google.com/document/d/1K-mKOqiUiSjgZTEscBLjtjd6E67oiK8H2ztOiq5tigk/pub</a></p><p>마지막으로, 크롬 개발 툴에 있는 Profiling탭, 특히 자바스크립트의 CPU 프로파일러의 3가지 화면에 대해서 언급해 봅니다.</p><ol><li><strong>Chart화면은 timeline화면과 비슷합니다. 하지만 chart는 좀 더 쉽게 관심있는 함수의 소스코드로 점프 할 수 있습니다.</strong></li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*7CvoCupSnw17tKs5V4kNUw.png" /></figure><p><strong>2. Heavy (Bottom up view)</strong></p><p>이 화면에서는 무거운 사용자 함수를 확인합니다. 그리고 함수의 핀포인트 시작에 도움이되는 역 호출 스택을 보여줍니다. $digest가 $apply앞에 오는 방법, 역순을 나타냅니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ievVnbIHa3-zVi7-bzxMPw.png" /></figure><p><strong>3. Tree (Top Down)</strong></p><p>무거운 소비를 일으키는 함수를 노출시키고, 문제가 되는 함수를 찾기위해 더 세부적으로 파고들 수 있습니다.</p><p>또한 “!”가 있는 노란삼각형 위에 있는경우, 잠정적인 최적화 문제를 확인할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*c803EgPpLifszdBoYgcmEQ.png" /></figure><p><a href="https://developer.chrome.com/devtools/docs/cpu-profiling">https://developer.chrome.com/devtools/docs/cpu-profiling</a></p><p>읽어주셔서 감사합니다. 에러를 발견하거나 안부를 전하실 분은 트윗터로 연락 주세요. : <a href="https://twitter.com/akras14">https://twitter.com/akras14</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=410cf42de57f" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[진심으로 좋은글 감사히 읽었습니다. :) 추후 진행하고 계시는 내용들도 공유 하시나요? 궁금하네요… :)]]></title>
            <link>https://medium.com/@cookatrice/%EC%A7%84%EC%8B%AC%EC%9C%BC%EB%A1%9C-%EC%A2%8B%EC%9D%80%EA%B8%80-%EA%B0%90%EC%82%AC%ED%9E%88-%EC%9D%BD%EC%97%88%EC%8A%B5%EB%8B%88%EB%8B%A4-%EC%B6%94%ED%9B%84-%EC%A7%84%ED%96%89%ED%95%98%EA%B3%A0-%EA%B3%84%EC%8B%9C%EB%8A%94-%EB%82%B4%EC%9A%A9%EB%93%A4%EB%8F%84-%EA%B3%B5%EC%9C%A0-%ED%95%98%EC%8B%9C%EB%82%98%EC%9A%94-%EA%B6%81%EA%B8%88%ED%95%98%EB%84%A4%EC%9A%94-48d9270087f5?source=rss-d0b8d1e57662------2</link>
            <guid isPermaLink="false">https://medium.com/p/48d9270087f5</guid>
            <dc:creator><![CDATA[CookAtRice]]></dc:creator>
            <pubDate>Wed, 18 Nov 2015 02:15:37 GMT</pubDate>
            <atom:updated>2015-11-18T02:15:37.488Z</atom:updated>
            <content:encoded><![CDATA[<p>진심으로 좋은글 감사히 읽었습니다. :) 추후 진행하고 계시는 내용들도 공유 하시나요? 궁금하네요… :)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=48d9270087f5" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Bower를 사용합시다.]]></title>
            <link>https://medium.com/@cookatrice/bower%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A9%EC%8B%9C%EB%8B%A4-898b16be5d9e?source=rss-d0b8d1e57662------2</link>
            <guid isPermaLink="false">https://medium.com/p/898b16be5d9e</guid>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[web-development]]></category>
            <dc:creator><![CDATA[CookAtRice]]></dc:creator>
            <pubDate>Fri, 11 Sep 2015 03:55:00 GMT</pubDate>
            <atom:updated>2015-09-11T05:48:02.683Z</atom:updated>
            <content:encoded><![CDATA[<h3>(부제, 운영중인 웹 프로젝트 package를 bower를 통해 관리 하도록 변경 해 보기 :)</h3><blockquote>예전에 <a href="http://bower.io/">Bower</a>에 대해서 들어는 보았지만, 이를 실제 프로젝트에 적용해 보지는 않았습니다. 새로 시작하는 프로젝트도 아니였고, 벌써 세팅 되어있는 package들을 아까운(?) 시간을 투자해서 새로이 관리 할 필요성을 느끼지 못했다는 핑계를 대 봅니다.:)</blockquote><blockquote>오래 전 시작했었던 프로젝트가 있었습니다.</blockquote><blockquote>시간이 흐르면서 여기에 사용된 package들이 bug fix(or patch) 되면서, 전반적으로 package들을 업그레이드 해야 할 필요성이 생겼습니다. :0</blockquote><blockquote>이왕 하는거 package들의 dependency, 그리고 나중에 또 있을지 모르는 버전 업그레이드를 염두해 두고, 이제는 Bower를 통해 쉽게(?) 관리 해 보기로 합니다.</blockquote><p>이 글에서는 <a href="http://blog.outsider.ne.kr/933">Bower의 소개와 기초사용법</a>은 다루지 않습니다.</p><p>다만, 운영중인 웹프로젝트에서 package management migration with Bower 정도로 보시면 도움이 되실 듯 합니다. (실제 버전업그레이드 후 일어날수 있는 side effect에 관한 부분도 패스 합니다. 그냥 Bower를 통한 버전관리 하는 방법에만 중점을 둡니다.)</p><p>아참, 그리고 효과적인 package management를 위해 <a href="https://github.com/blittle/bower-installer">bower-installer</a>라는 툴도 함께 사용하고 있습니다. 아쉽지만, <a href="https://www.npmjs.com/package/bower-installer">bower-installer의 기초 사용법</a> 또한 이 글에서는 다루지 않음을 알려드립니다. ;P</p><p>ps. 그래도 아쉬우니 간단하게나마 bower-installer에 대해서 말씀 드려봅니다. Bower만을 통해 package를 관리하면, 관리는 쉽지만 모든 entire repository들을 포함하기에 용량이 제법 큽니다. 모든 파일들을 서버에 올릴 필요는 없겠죠. 각각의 package들의 필요한 js, css 등등의 파일들만 골라내는 역할을 한다고 생각하시면 쉽습니다. 또한 대부분 xxxxx.js보다는 xxxxx.min.js를 사용하실텐데, 이 또한 bower-installer를통해 간단히 설정할 수 있습니다. 자세한 설정법은 아래에서 진행합니다. :)</p><p>작업 시작에 앞서 현재 운영중인 프로젝트 폴더 구조입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*wGZi6i5dAuMaP9IpdFvQ0Q.png" /></figure><p>사용중인 package들은 resources밑에 이렇게 대략 이런식으로 존재합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/642/1*Obehu2hGtfgDysPJpnIiEw.png" /></figure><p>package들을 크게 4가지로 분류하고 src/main/webapp/resources 아래에 각각의 그룹으로 관리하고자 합니다</p><p><strong><em>group 1. bowerAssets</em></strong></p><ul><li>Bower을 통해 관리할 수 있는 package</li><li>대부분의 package들이 이곳에 위치하게 됩니다.</li><li>bower-installer를 통해 이곳에 <em>필요한 file(js, css, font, etc)들만 추려 내는 것이 이 글의 핵심이자 나누고자 하는 사항</em>입니다. :)</li></ul><p><strong><em>group 2. extAssets</em></strong></p><ul><li>Bower search를 통해 검색되지 않아 직접 관리해야 할 package</li></ul><p><strong><em>group 3. vendorAssets</em></strong></p><ul><li>돈을 지불하고 사용해야하는 package</li></ul><p><strong><em>group 4. </em></strong><a href="https://github.com/wiseeco/dev-culture"><strong><em>wiseeco</em></strong></a><strong><em>Assets</em></strong></p><ul><li><a href="https://github.com/wiseeco/dev-culture">wiseeco</a>(우리회사 ~:)에서 소유하고 있는 package</li></ul><p>나중엔 잘(?) 정리되어 아래처럼 관리하게 될 예정입니다. :)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/560/1*IlJmwRI72t1f1yCJDbKv0g.png" /></figure><p>그럼 package management migration을 본격적으로 시작해 봅시다.</p><p>예상되는 기본 작업 순서는 아래와 같습니다.</p><p><strong><em>step0. .bowerrc 파일에 관하여</em></strong></p><p><strong><em>step1. bower install 명령으로 package 받기</em></strong></p><p><strong><em>step2. bower init 명령으로 bower.json 생성</em></strong></p><p><strong><em>step3. bower.json에 bower-installer에서 사용할 install key 생성</em></strong></p><p><strong><em>step4. bower-installer 명령</em></strong></p><p><strong><em>step5. 최종 bowerAsserts 그룹 생성 확인</em></strong></p><p><strong><em>step6. .gitignore 설정</em></strong></p><p><strong><em>step7. 작업 고고 :(</em></strong></p><h4>step0. .bowerrc파일에 관하여</h4><ul><li>.bowerrc파일은 linux에서 사용되는 여느 dotfile과 비슷한 설정파일입니다. 기본적으로 사용중인 계정의 home 폴더에 두시면 전체 적용이 되고, 프로젝트별로 조금씩 설정값이 상이하다면 해당 프로젝트의 home이 되는 폴더에 하나 더 두시면 마지막 파일 기준으로 override 된다고 생각하시면 됩니다. .bowerrc 파일이 없다면 모든 설정값들은 default로 사용됩니다. 설정값들에 대한 디테일한 설명은 <a href="http://bower.io/docs/config/">API 링크</a>로 대신합니다.</li></ul><p>저는 이렇게 사용해 보겠습니다.</p><blockquote>{</blockquote><blockquote>“directory”: “bower_components/”,</blockquote><blockquote>“analytics”: false,</blockquote><blockquote>“timeout”: 120000,</blockquote><blockquote>“color” : true</blockquote><blockquote>}</blockquote><h4>step1. bower install 명령으로 package 받기</h4><ul><li>프로젝트의 home에서 아래의 명령으로 package를 설치합니다. (기본은 최신버전을 다운 받습니다.)</li></ul><blockquote>bower install package_name</blockquote><ul><li>package의 특정 버전을 설치하고 싶으시면 package 명 뒤에 #버전 을 사용합니다.</li></ul><blockquote>bower install package_name#package_version</blockquote><ul><li>jquery와 angular를 설치 해 봅니다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*AQyWR8djkAl54AQCqzqbWw.png" /></figure><ul><li>기본 프로젝트의 home 아래에 bower_components폴더가 생성 되었고, 그 아래 jquery, angular가 다운받아짐을 확인 할 수 있습니다.</li></ul><h4>step2. bower init 명령으로 bower.json 생성</h4><ul><li>프로젝트의 home에서 bower.json을 생성하기 위해 아래의 명령을 사용합니다.</li></ul><blockquote>bower init</blockquote><ul><li>기본적으로 항목들의 값을 입력합니다. 이때 입력한 값들은 혹시나 모를 지금 생성된 bower 파일을 배포하거나 할 때 사용됩니다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*tAbzenJPq1UddyRbTAVjhA.png" /></figure><ul><li>설정 값 중에 주의깊게 보아야 할 것은 ‘set currently installed components as dependencies?’ 입니다. 이 물음은 init명령을 통해 bower.json을 생성할 때, 이전에 bower를 통해 설치한 package들을 dependencies 설정값에 넣겠느냐 확인하는것입니다. 다른 설정 값들은 몰라도 bower.json의 dependencies의 값은 설치된 package들의 관리에 꼭 필요한 값이라는것을 알아두세요. 추후 bower.json파일만 있으면 bower install 명령으로 똑같은 패키지 환경을 새로 생성할 수있습니다.</li><li>이미 bower.json이 생성 되었을 경우 package를 추가해야 할 때가 있습니다. 이때는 아래의 명령으로 package설치와 함께 dependencies에도 추가합니다.</li></ul><blockquote>bower install package_name -S</blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*iOQHLPe48QL-6xK56oDdjQ.png" /></figure><ul><li>같은 명령으로는 -S 대신 — save 옵션을 줄 수 있습니다. (참고로 dependency 종류는 위에서 알아보았던 dependencies와 devDependencies가 있습니다. 자세한 옵션은 <a href="http://bower.io/docs/api/#install-options">API 링크</a>를 걸어둡니다. :)</li></ul><blockquote>bower install package_name — save</blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*xutCIUz5s45gBxJfZKC8Hg.png" /></figure><ul><li>최종 생성된 bower.json을 확인합니다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/982/1*Mk7fKOTZn_xeW2l2DjaMIA.png" /></figure><h4>step3. bower.json에 bower-installer에서 사용할 install key 생성</h4><ul><li>이전 단계들로 부터 설치된 package들을 확인해 봅니다. 명령어는 아래와 같습니다.</li></ul><blockquote>bower list</blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*R9AJWKsoos2Mmb8xikSiew.png" /></figure><ul><li>jquery같은경우 bower list 명령으로 확인했을때 3번 나오지만, 실제로는 1번이 설치되었고 dependency는 자동으로 bower에서 관리해 주는듯 합니다. :)</li><li>설치된 package들을 확인 해 보면, 필요 이상의 파일들이 있습니다. 많은 파일 중, 해당 package를 돌리는데 필요한 파일들만 추출(?) 하는 설정을 bower.json에 입력합니다.</li><li>문서에서는 ‘Bower installer provides an easy way for the main files to be installed or moved to one or more locations. Simply add to your bower.json an <strong>install</strong> key and <strong>path attribute’</strong>라고 설명하고 있습니다. 기본 구조는 아래와 같습니다.</li></ul><blockquote>“install” : {</blockquote><blockquote>“path” : {}</blockquote><blockquote>}</blockquote><ul><li>기본 path attribute에 sources attribute를 써야지 좀 더 디테일하게 원하는 파일들만 추출할 수 있습니다. 여기서는 base attribute도 설정해서 조금더 타이핑을 줄여 봅니다. <a href="https://gist.github.com/cookatrice/c8fa43ecad146f646380">~~:)</a></li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*67FwHSZdQWZRhA2X0qEWgQ.png" /></figure><blockquote>sources에 대해서 조금 더 보충설명 드립니다. sources attribute를 사용한다면, 여기에 등록한 package들에 대해서만 bower-installer를 통해서 추출하고 나머지 package들은 <strong><em>bower list — paths</em></strong> 라는 명령어를 통해서 나오는 파일에 대해서만 path attribute에 설정된 장소로만 복사 됩니다.</blockquote><blockquote>만약 위의 sources에서 bootstrap이 없다면, jquery-ui, angular, jquery에 설정된 4개의 파일만 설정된 path로 복사되고, bootstrap package에 대한 file들은 <strong>bower list — paths</strong>명령으로 보이는 파일에 한해서만 해당 path에 이동됩니다. 여기서 주의 할 점 한가지는 파일의 확장자명으로 이동되는 장소가 결정되는데, 이는 path와 매핑되어 해당되는 곳으로 복사 됩니다. 만약 path가 없다면 기본 프로젝트폴더에 파일이 복사 됩니다. 한번 해 보시면 이해 되십니다. 실습이 꼭 필요합니다. :)</blockquote><h4>step4. bower-installer 명령</h4><ul><li>bower_components 폴더에 설치된 package의 file중에서 내가 원하는 파일들만을 추려내는 명령은 아래와 같습니다. 프로젝트의 home에서 아래의 명령을 입력합니다. :)</li></ul><blockquote>bower-installer</blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*izjtooWL--6PDY6MFKVdvg.png" /></figure><h4>step5. 최종 bowerAsserts 그룹 생성 확인</h4><ul><li>프로젝트의 home에서 bower.json의 install key의 base attribute로 설정한 bowerAsserts로 이동합니다. (./src/main/webapp/resources/bowerAsserts)</li><li>생성된 폴더와 파일들을 확인합니다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*RghSINSVmMT2D7gmRno5Bw.png" /></figure><ul><li>한가지 팁을 알려드린다면, 생성된 bowerAssets아래의 폴더 구조는 설정하는 path에 따라 구조를 바꿀 수 있습니다.</li><li>step3에서의 path를 아래와 같이 설정해 보고 bower-installer명령을 내려 봅니다.(<em>기존에 생성된 bowerAsserts를 지우고 테스트 해 보시기 바래요.</em>) <a href="https://gist.github.com/cookatrice/deef0737296394bbad60">~:)</a></li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/836/1*l0Ud8dPjWRn8qvvs5PlFmg.png" /></figure><ul><li>다시한번 bower-installer실행명령을 내려 봅니다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*fGFMctN3Gjz-HkowQMiXsg.png" /></figure><ul><li>bowerAssets폴더로 이동 후 생성된 package들을 다시 한번 확인해 봅니다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*hCo3psXM4aEg8vfYXBng0Q.png" /></figure><ul><li>어떤 구조로 package들을 묶어서 관리할지는 사용자의 선택입니다. :)</li></ul><h4>step6. .gitignore 설정과 마무리</h4><ul><li>지금까지 잘 따라 오셨다면, 아래와같은 폴더구조를 확인 하실 수 있습니다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*zVguNk8I8M-SDEv892qHGQ.png" /></figure><ul><li>새롭게 bower_components폴더가 생겼고, 그 아래 설치된 package들이 있습니다.</li><li>그리고 src/main/webapp/resources/bowerAssets 아래에 package의 file 중 필요한 file들만 추출된 것을 확인하실수 있죠.</li><li>마지막으로 하실 설정은 .gitignore에 bower_components 한 줄 만 추가하시는 작업입니다. bower-installer를 통해 package들을 추출했는데 bower_components를 통째로 올린다는건, 있을수 없는 일이니깐요. (위에 캡쳐이미지 오른쪽 참조:)</li></ul><h4>step7. 작업 고고 :(</h4><ul><li>이제 소스에서 import된 js나 css를 바꿔가며 테스트 해 보시고, 적절하게 사용하시면 됩니다. :)</li><li>maven이나 gradle을 이용해 더 편리하게 사용 할 방법을 테스트하고 공유하고 싶지만, 이 글은 여기서 마무리 짓습니다. :)</li><li>이제 저도 본격적으로 migration 테스트를 진행해 보아야 겠습니다. :(</li><li>혹시라고 수정되어야 할 부분이 있다면 cookatrice@gmail.com로 알려주시면 수정하도록 하겠습니다.</li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=898b16be5d9e" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Sublime Text2와 Gist로 깔끔하게 code snippet을 사용해 봅시다.]]></title>
            <link>https://medium.com/@cookatrice/sublime-text2%EC%99%80-gist%EB%A1%9C-%EA%B9%94%EB%81%94%ED%95%98%EA%B2%8C-code-snippet%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4-%EB%B4%85%EC%8B%9C%EB%8B%A4-2518f23ce606?source=rss-d0b8d1e57662------2</link>
            <guid isPermaLink="false">https://medium.com/p/2518f23ce606</guid>
            <category><![CDATA[sublimetext]]></category>
            <category><![CDATA[cpp]]></category>
            <dc:creator><![CDATA[CookAtRice]]></dc:creator>
            <pubDate>Thu, 03 Sep 2015 06:21:09 GMT</pubDate>
            <atom:updated>2015-09-03T06:21:09.194Z</atom:updated>
            <content:encoded><![CDATA[<blockquote>블로그에 글을 작성하거나, 여기저기에서 가끔씩 소스코드를 보여주어야 할 때가 있습니다. 이럴때는 어떻게 하시나요?</blockquote><blockquote>보여줄 snippet을 복사해서 그대로 붙여 넣거나, intelliJ에서 작성한 코드를 이쁘게 캡쳐해 필요한 부분만 크롭 후 이미지를 붙일수도 있습니다.</blockquote><blockquote>한 두 번, 빨리 작성해야 한다면야 이런방법도 좋지만, 지속적으로 snippet을 관리 하면서(그것도 git으로!!) 이미 작성된 snippet은 재작성하는 수고 없이 편하게 반복사용 할 수 있는 방법이 있다면 어떻게 하실껀가요?</blockquote><blockquote>Sublime Text2와 gist를 이용해 깔끔하게 code snippet을 관리하고 사용해 보는 방법을 알아봅시다. :)</blockquote><blockquote>이 글은 <a href="http://code.tutsplus.com/tutorials/sexy-code-snippet-management-with-gists--net-24328">Sexy Code Snippet Management With Gists</a> 영상을 보고, 저도 so sexy~ 하게 앞으로 snippet을 사용해야겠다는 생각에 먼저 적용 해 보고, 글로 남겨 공유합니다. 영상은 2012년 초경에 작성된 것 같은데 시간이 좀 지나서 gist에 접근하는 방법이 기존 id/password에서 token을 사용하는 방법으로 변경이 되었네요. 이부분 설명은 제일먼저 추가 했습니다.</blockquote><p>그럼 간단히 따라해 봅시다. ~:)</p><h3><strong>1. github token 생성</strong></h3><p>1) <a href="https://github.com/">github</a>에 접속하여 Personal settings로 이동합니다.</p><ul><li>github에서 제공되는 서비스기에, 계정이 없다면 먼저 생성 하셔야 합니다.</li></ul><p>2) Personal access tokens 메뉴를 선택하고, Generate new token 클릭합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*-YSY56AcZdcJTVyHNzxZwQ.png" /></figure><p>3) token명으로 사용할 적절한 설명을 넣고, gist체크를 확인한 후 Generate token 클릭합니다.</p><ul><li>여기서 생성된 토큰을 다른곳에서도 사용하시려면, 사용목적에 맞게 체크박스를 선택하시면 됩니다. 전 여기서 gist가 메인이라 그냥 디폴트 설정으로 진행합니다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*lCtl8Y_YQ4jZvmni-4GgKw.png" /></figure><p>4) 정상적으로 token이 생성됨을 확인합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*y7LmAZVjGbQapXIT-qIX0Q.png" /></figure><p>5) 생성된 token은 나중에 gist setting file에서 사용됩니다.</p><h3><strong>2. package control 설치</strong></h3><p>( 참고 url : <a href="https://packagecontrol.io/installation#st2">https://packagecontrol.io/installation#st2</a> )</p><p>1) sublime text2를 실행합니다.</p><p>2) 아래의 핫키를 이용해 스크립트 창을 엽니다.</p><blockquote><strong>control + `</strong></blockquote><p>3) 하단의 스크립트 창에 package control 설치 스크립트 입력합니다.</p><blockquote><strong>import urllib2,os; pf=’Package Control.sublime-package’; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),’wb’).write(urllib2.urlopen(‘</strong><a href="http://sublime.wbond.net/&#39;+pf.replace("><strong>http://sublime.wbond.net/&#39;+pf.replace(</strong></a><strong>&#39; ‘,’%20&#39;)).read()); print(‘Please restart Sublime Text to finish installation’)</strong></blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Y5wD2XEx_G9WO60m97Ua5w.png" /></figure><p>4) sublime text2를 재시작합니다.</p><h3><strong>3. package control로 gist package 설치</strong></h3><p>1) sublime text2를 실행합니다.</p><ul><li>선행단계에서 package control을 설치하면서 몇번의 notice창이 뜰 수도 있습니다. 그냥 읽어 보시고 확인을 누르시면 됩니다.</li><li>설치한 package control을 이용해 gist를 설치합니다.</li></ul><p>2) 이전 과정에서 설치한 package control 창을 엽니다. 핫키는 아래와 같습니다.</p><blockquote><strong>shift + command + p</strong></blockquote><p>3) 창을 열고 install이라는 단어를 치면, 인텔리전스하게 install package를 바로 찾을 수 있습니다.</p><ul><li>그냥 install package와 advanced가 있는데. 여기서는 첫번째 install package를 선택합니다.</li><li>저도 사용해 보지는 않았지만 아래에 있는 advanced는 좀 더 메뉴얼하게 설치하는것 같네요.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Q4uVYD07Ca_0m-KMpnvN9w.png" /></figure><p>4) 위에서 install package를 선택하고, 잠시 기다리면 또다른 창이 나옵니다. 여기서 gist를 입력하면 아래와 같이 나오는데, gist를 선택합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*5jKFCXNVl_9iTuGcwdwZFQ.png" /></figure><p>5) sublime text2를 재시작합니다.</p><p>6) 지금까지의 설치들(package Control, gist package)이 정상적으로 되었는지 sublime text2의 메뉴에서 설치를 확인해 봅니다.</p><ul><li>아래와 같이 보이시면, 정상적으로 설치되신것이 맞습니다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*quune-14FT_1lV35zzOaTw.png" /></figure><h3><strong>4. gist package 세팅</strong></h3><p>( 참고 url : <a href="https://github.com/condemil/Gist">https://github.com/condemil/Gist</a> )</p><p>1) Sublime text2 -&gt; Preferences -&gt; Browse Packages…를 클릭합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/956/1*wQ-XT3cW7CnMtFV0FPrzHg.png" /></figure><p>2) Sublime Text2 -&gt; Packages -&gt; Gist -&gt; Gist.sublime-settings 파일을 오픈합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*2BAFdUDdPPXnwc5W8kN8VQ.png" /></figure><p>3) token에 1번 과정에서 생성했던 github token 정보를 세팅합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*djpZw65c11stY9hiKMmstQ.png" /></figure><p>4) sublime text2를 재시작합니다.</p><h3><strong>4. gist 사용해 보기</strong></h3><p>1) sublime text2를 실행합니다. 그리고는 샘플 코드를 작성합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*k23mOyEhgoLFnzrfz1bOYQ.png" /></figure><p>2) syntax 정보를 설정해서 약간 컬러풀하게 가독성을 높여 봅니다. :)</p><ul><li>package control 핫키(shift + command + p)를 눌러 javas…를 입력하다보면, Set syntax:JavaScript 를 선택할 수 있습니다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*DJfwTqv3p7CVYugOnz-5Kw.png" /></figure><ul><li>선택하면 이렇게 이쁘게(?) 됩니다. :)</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*A4e9MIJHhTwBmEu4BCbV3w.png" /></figure><p>3) package control 핫키(shift + command + p)를 눌러 gist를 입력하면 나타나는 메뉴 중, Gist:Creat Public Gist를 선택합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Qh-0PqOo8jXe7ISd799u5g.png" /></figure><ul><li>선택 후, 아래에 Gist Descripttion을 쓸 수 있습니다. (나중에 gist의 제목(?)이 됩니다.)</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*XYxYAwKHj6XII0Y6RKSlJQ.png" /></figure><ul><li>Gist Description 후, Gist File Name을 입력받습니다. (snippet이 저장될 파일명입니다. 저는 doSum.js라 해 봅니다.)</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*8WlpvXdDvEhh5lELue5a1g.png" /></figure><p>4) gist 홈페이지로 가서 정상적으로 등록이 되었는지 확인해 봅니다.</p><ul><li><a href="http://gist.github.com/cookatrice">http://gist.github.com/yourId</a> 형식입니다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*eOhvvfkX-TUJ_gver6-8nQ.png" /></figure><ul><li>gists리스트에서 방금 생성한 snippet을 클릭해 봅니다. (우측 Embed URL을 나중에 사용하시면 됩니다.)</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*rzCWRnJrZoH-5-eaQogmjQ.png" /></figure><p>5) 생성된 snippet의 Embed URL을 다른 곳에서 사용해 봅니다.</p><ul><li><a href="http://fiddle.jshell.net/">fiddle</a> 에서 간단히 테스트 해 보는데, HTML 영역에 윗단계에서 복사한 URL을 그냥 붙여만 넣으시고 Run을 해 봅니다.</li><li>Result영역을 확인해 보시면 깔끔하게 나타난 code snippet을 확인하실 수 있습니다. :)</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*HkOiMH0tya0wZecheL44XA.png" /></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2518f23ce606" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[git commit —amend 사용시 vi error가 발생된다면???]]></title>
            <link>https://medium.com/@cookatrice/git-commit-amend-%EC%82%AC%EC%9A%A9%EC%8B%9C-vi-error%EA%B0%80-%EB%B0%9C%EC%83%9D%EB%90%9C%EB%8B%A4%EB%A9%B4-d6b96a184d24?source=rss-d0b8d1e57662------2</link>
            <guid isPermaLink="false">https://medium.com/p/d6b96a184d24</guid>
            <dc:creator><![CDATA[CookAtRice]]></dc:creator>
            <pubDate>Fri, 27 Feb 2015 05:07:42 GMT</pubDate>
            <atom:updated>2015-02-27T05:11:33.953Z</atom:updated>
            <content:encoded><![CDATA[<h3>git commit --amend 사용시 vi error가 발생된다면???</h3><p>git을 사용하다보면 commit을 할 일들이 많다. commit을 한지 채 1분도 되지않아, 깜빡했던 파일을 add하거나 rm했는데 또 commit을하는 일은 여간 번거롭고, 불필요한 로그를 쌓는다는 생각이 들때가 많다. git에서는 이러한 사용상의 문제를 미리 파악(?)하고, 마지막으로 commit 한 내용을 쉽게 수정할 수 있도록 기능을 제공한다.</p><p>마지막 commit 이후, missFile.txt 라는 파일을 추가하고, 마지막 commit을 수정한다고 가정해 보자. (물론 파일 추가 뿐 아니라, 수정, 다른 rm 및 기타 작업도 마찬가지다.)</p><p>먼저, git add 명령으로 파일을 추가한다. 그리고 amend옵션을 추가하여 commit 한다.</p><pre>git add.<br>git commit --amend -m &#39;new commit message.&#39;</pre><p>이렇게 한다면 new commit message로 마지막 commit 이 대체됨을 알수 있다.</p><p>같은 결과를 보여주지만, 또 다른 방법으로 이를 처리하는 방법을 알아보자. 기본적으로 commit 이전에 add하는것은 같으나, 그 뒤 -m 옵션과 message를 빼고 더 간단하게 –amend옵션만 적어보자.</p><pre>git add.<br>git commit --amend</pre><p>vi 에디터가 열리고, 기존의 message와 commit 한 간략한 정보들을 확인 할 수 있다. 이제 기존 commit message를 new commit message로 변경하고, 저장 후 창을 닫으면 자동으로 마지막 commit 이 수정된다. 정말 쉽고 간단하다. ☺</p><p>하.지.만….. 이 글에서 이야기 하고자 하는것은 이것이 아니다.</p><p>두번째 설명한 방법으로 마지막 commit 을 수정할 때, 아래와 같은 error메시지를 발견할 수 있다.</p><blockquote><em>error: There was a problem with the editor ‘vi’.<br>Please supply the message using either -m or -F option.</em></blockquote><p>이것이 무슨말인고 하면, vi에디터에 문제가 있으니 처음 설명한 방법처럼 것처럼 -m옵션을 이용하여 마지막 commit 을 수정하라는것이다. 이는 vi에디터의 bug라고 할 수 있는데, git config파일에 직접 추가 함으로써 해결 가능하다.</p><p>git에서는 크게 3개의 config파일이 존재한다. 하나는 시스템 전역, 하나는 사용자 계정, 하나는 프로젝트별. 어디에 추가해도 상관은 없지만, 일단 –global옵션으로 사용자 계정에 추가해 보자.</p><pre>git config --global core.editor `vim`</pre><p>사용자 계정에서 .gitconfig를 확인해 보자. vim이 editor로 등록됨을 확인할 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/300/0*EiTcNxz1MpxOYDIL.png" /></figure><p>이제 다시 두번째 - -amend옵션만 주는 방법을 다시한번 시도 해 보자.</p><p>잘~ 동작됨을 확인하고, 다시 열심히 git을 사용하면 오늘도 굳~~☺</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d6b96a184d24" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>