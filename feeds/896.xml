<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by 조민재 on Medium]]></title>
        <description><![CDATA[Stories by 조민재 on Medium]]></description>
        <link>https://medium.com/@mingdaejo?source=rss-7074ea5bc590------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/0*HJhYJQVEybR8HdJV.</url>
            <title>Stories by 조민재 on Medium</title>
            <link>https://medium.com/@mingdaejo?source=rss-7074ea5bc590------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Tue, 14 May 2019 03:32:58 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@mingdaejo" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[Google Cloud Vision API 사용하여 모니터링 어플리케이션 구축하는 방법[1]]]></title>
            <link>https://medium.com/@mingdaejo/google-cloud-vision-api-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B5%AC%EC%B6%95%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-1-76c746bb7cc7?source=rss-7074ea5bc590------2</link>
            <guid isPermaLink="false">https://medium.com/p/76c746bb7cc7</guid>
            <category><![CDATA[monitoring]]></category>
            <category><![CDATA[google-cloud-platform]]></category>
            <category><![CDATA[vision]]></category>
            <category><![CDATA[google-cloud-vision]]></category>
            <category><![CDATA[vision-api]]></category>
            <dc:creator><![CDATA[조민재]]></dc:creator>
            <pubDate>Sun, 23 Jul 2017 00:47:51 GMT</pubDate>
            <atom:updated>2017-07-23T00:47:51.699Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/390/1*uPbPN-fjE88O1qCBMY8yqQ.png" /><figcaption>google.com</figcaption></figure><p>딥러닝, 이미지 인식과 같은 인공지능 기술들이 요즘 제 호기심을 자극합니다. 그중 작년 이맘쯤 구글이 발표한 이미지 탐색(Image detection)이 가능한 Cloud Vision API라는 오픈 API에 대해 알아보았습니다.</p><h3>Cloud Vision API 특징</h3><p>자신이 원하는 기준에 맞게 많은 양의 이미지를 분류하는 데 매우 유용한 것 같습니다. 아래는 Cloud Vision의 주요 기능들입니다.</p><ul><li>이미지 속 사물들을 찾아주는 Label Detection ( ex. 가구, 동물, 음식등)</li><li>이미지 속 문자들을 인지하는 Text Detection (ex. 전단지)</li><li>불쾌한 콘텐츠를 식별하여 걸러내는 Safe Search Detection ( ex. 성인 컨텐츠, 폭력 컨텐츠)</li><li>이미지 속 세계 곳곳에 있는 랜드마크도 식별하여 위도/경도도 표시하는 Landmark Detection (ex. 경복궁, 피라미드, 스핑크스)</li><li>잘 알려져 있는 회사 로고들을 식별하는 Logo Detection (ex. 맥도날드, 애플, KFC)</li><li>입, 눈, 코 등의 요소 데이터를 종합하여 얼굴 표정을 식별하는 Face Detection. ( ex. 기쁨, 화남, 우울함 등)</li><li>이미지 속 개체의 색상(RGB)값을 알려주는 IMAGE_PROPERTIES</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*T-Fchs3h7GlkYDoxgN-mEA.png" /></figure><p>첫번째, 마라톤하는 이미지를 보면 Label Detection이 생각외로 높은 정확도를 가진 것을 볼 수 있습니다. running과 marathon외로도 people도 나올 수 있을 것 같네요.</p><p>두번째 예시는 사람의 표정을 잡아내고 기분의 상태와 정확도 정도를 very likely로 표시하였습니다. 또한 들고 있는 표지판의 글자도 에스파냐어인지 잘 잡았습니다.</p><p>사실 아직도 Vision API가 불안정한 것은 맞습니다만, 시간이 지날수록 더 높은 정확성을 가지기엔 틀림없어 보이네요.</p><h3>Vision API 이해하기</h3><p>Vision API는 REST API를 사용하기 쉽습니다. API는 JSON 포맷 형식으로 주어지는데 분석 할 이미지 목록과 API에서 정보를 감지하고 반환 할 이미지 기능으로 구성됩니다.</p><p>The JSON Request format은 아래와 같습니다.</p><pre>{<br> &quot;requests&quot;:[<br>   {<br>     &quot;image&quot;:{<br>       &quot;content&quot;:&quot;&lt;base64-encoded-image-bytes&gt;&quot;<br>     },<br>     &quot;features&quot;:[<br>       {<br>         &quot;type&quot;:&quot;&lt;FEATURE_TYPE&gt;&quot;,<br>         &quot;maxResults&quot;:1<br>       },<br>       {<br>         &quot;type&quot;:&quot;&lt;FEATURE_TYPE&gt;&quot;,<br>         &quot;maxResults&quot;:1<br>       }<br>     ]<br>   }<br> ]<br>}</pre><p>JSON포맷안의 image는 base64로 인코딩 되어 있고 FEATURE_TYPE (Label Detection, Text Detection, Logo Detection 등…)요청 배열로 구성되어 있습니다.</p><p>[2]에서 계속…</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=76c746bb7cc7" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[텐서플로우(TensorFlow)에 관하여]]></title>
            <link>https://medium.com/@mingdaejo/%ED%85%90%EC%84%9C%ED%94%8C%EB%A1%9C%EC%9A%B0-tensorflow-%EC%97%90-%EA%B4%80%ED%95%98%EC%97%AC-5cf03558d2b1?source=rss-7074ea5bc590------2</link>
            <guid isPermaLink="false">https://medium.com/p/5cf03558d2b1</guid>
            <category><![CDATA[tensorflow]]></category>
            <category><![CDATA[introduction]]></category>
            <category><![CDATA[deep-learning]]></category>
            <dc:creator><![CDATA[조민재]]></dc:creator>
            <pubDate>Mon, 17 Jul 2017 16:47:09 GMT</pubDate>
            <atom:updated>2017-07-17T16:47:47.152Z</atom:updated>
            <content:encoded><![CDATA[<h3>정의</h3><p>머신러닝&amp;딥러닝을 <strong>위한 </strong>고성능<strong> </strong>수치 계산 라이브러리</p><blockquote>“TensorFlow is an open source software library for numerical computation using data flow graphs”</blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/500/1*gvLPKqsJu-4OLXj72meaPw.jpeg" /></figure><h3><strong>특징</strong></h3><ul><li>그래프의 노드(Node)는 수치 연산을 나타내고 엣지(edge)는 노드 사이를 이동하는 다차원 데이터 배열(텐서) + 배열의 이동(플로우)</li><li>데이터 플로우 그래프를 통한 풍부한 표현력</li><li>코드 수정 없이 CPU/GPU 모드로 동작</li><li>아이디어 테스트에서 서비스 단계까지 이용 가능</li><li>계산 구조와 목표 함수만 정의하면 자동으로 미분 계산을 처리</li><li>Python/C++를 지원하며, SWIG를 통해 다양한 언어 지원 가능</li></ul><h3>내부동작</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/298/1*seP3CD2tkQE7nBSpE8ymsw.jpeg" /><figcaption>Data Flow graph</figcaption></figure><p>텐서플로우는 Stream Programming의 일종이다. Flow graph 형태로 구조화하고, 각 노드는 엣지를 따라 데이터를 받게되고 처리하여 출력한다.</p><p>우리 유저들은 이런 flow graph를 모르더라도 TensorBoard라는 자동으로 그려주는 모듈 덕분에 편히 사용할 수 있다.</p><h3>License</h3><p>Apache 2.0 — 연구와 상업적 목적으로 전부 프리하게 쓸 수 있다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5cf03558d2b1" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[iOS 화면 전환]]></title>
            <link>https://medium.com/@mingdaejo/ios-%ED%99%94%EB%A9%B4-%EC%A0%84%ED%99%98-b979188a1a82?source=rss-7074ea5bc590------2</link>
            <guid isPermaLink="false">https://medium.com/p/b979188a1a82</guid>
            <category><![CDATA[swift]]></category>
            <category><![CDATA[swift-3]]></category>
            <category><![CDATA[ios-10]]></category>
            <dc:creator><![CDATA[조민재]]></dc:creator>
            <pubDate>Wed, 29 Mar 2017 09:12:36 GMT</pubDate>
            <atom:updated>2017-03-29T09:12:36.671Z</atom:updated>
            <content:encoded><![CDATA[<p>특이하게 이 부분은 공부하더라도 iOS개발을 쉬면 백지화되더라구요. 저 스스로에게 개념을 다시 새기며 또 볼 일이 있을 것 같아서 이렇게 글을 씁니다.</p><p>iOS에서는 화면전환에는 크게 두가지로 나눌 수 있습니다. 하나는 소스 코드를 통해 전환하는 방식이고, 또 다른 하나는 스토리보드가 제공하는 기능을 이용하여 전환하는 방식입니다. 또 여기서 여러갈래도 나누어지게 됩니다.</p><p>전자의 방식을 ‘프로그래밍적으로 화면을 전환한다.’ 또는 ‘동적으로 화면을 전환한다’고 하고 후자의 방식을 ‘GUI 방식으로 화면을 전환한다.’ 또는 ‘정적으로 화면을 전환한다’고 합니다. 상황에 맞게 쉽게 쓰이기 때문에 섯불러 하나만 배우는 것보다 모두 배우는 것이 유리합니다.</p><h3>iOS에서의 화면 전환 개념</h3><ol><li>뷰 컨트롤러의 뷰 위에 다른 뷰를 가져와 바꿔치기하기</li><li>뷰 컨트롤러에서 다른 뷰 컨트롤러를 호출하여 화면 전환하기</li><li>내비게이션 컨트롤러를 사용하여 화면 전환하기</li><li>화면 전환용 객체 세그웨이를 사용하여 화면 전환하기</li></ol><p>1을 제외한 나머지 화면 전환은 모두 뷰 컨트롤러를 호출하는 방식으로 이루어집니다. 전환할 화면 담당 뷰 컨트롤러의 인스턴스를 생성하고, 이를 불러들여서 기존의 화면위에 <strong>덮어</strong> 화면이 전환되는 것이죠. <strong>절대! 기존의 화면을 버리는 것이 아닙니다.</strong></p><p>iOS에서 화면 전환은 ‘<strong>다음 화면으로 이동하는 방법과 이전 화면으로 되돌아가는 방법이 다름</strong>&#39; 과 ‘<strong>화면 전환 방식에 따라 이전 화면으로 되돌아가는 방법이 다름</strong>’ 이렇게 두가지 특성을 가지고 있습니다.</p><p><strong>화면 전환 개념 1번</strong>에 대해 이야기를 안했는데 이 방식은 대단히 위험한 방식입니다. 기존의 필요없는 뷰를 제거해주지 않고 뷰 위에 다른 뷰를 가져와 바꿔치기를 한다면, 메모리가 터져서 앱이 죽어버리고 말겠죠.</p><p><strong>화면 전환 개념 2번- 뷰 컨트롤러 직접 호출에 의한 화면 전환</strong></p><p>UIViewController에 정의된 present메소드를 사용하면 쉽게 해결됩니다. present메소드를 이용하면 기존 뷰 컨트롤러위에 새로운 뷰 컨트롤러를 덮어 씌워 참조하는 관계가 형성 됩니다.</p><p>먼저 ViewController에 다음view로 넘어가는 버튼을 IBAction으로 연결합니다. 이후 밑의 코드 처럼 액션 안에 넣어주면 됩니다.</p><blockquote>let ViewController인스턴스 = self.storyboard?.instantiateViewController(withIdentifier: “Storyboard ID값”)</blockquote><blockquote><em>ViewController인스턴스</em>?.modalTransitionStyle = UIModalTransitionStyle.coverVertical</blockquote><blockquote>self.present(<em>ViewController인스턴스</em>!, animated: true, completion: nil)</blockquote><p>이런식으로 한다면 버튼을 누를 경우, 지정된 뷰로 이동하게 됩니다.</p><p><strong>화면 전환 개념 3번- 내비게이션 컨트롤러를 사용하여 화면 전환하기</strong></p><p>내비게이션 컨트롤러는 2번과 크게 차이가 있지 않습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*yVTEhHzeKhGNuzicRmhYsg.png" /></figure><p>이렇게 네비게이션 컨트롤러를 연결시킨 후, 버튼에 네비게이션 연결하고 코드를 작성해주시면 됩니다.</p><blockquote>let <em>ViewController인스턴스 </em>= self.storyboard?.instantiateViewController(withIdentifier: “<em>Storyboard ID값</em>”)</blockquote><blockquote>self.navigationController?.pushViewController(<em>ViewController인스턴스</em>!, animated: true)</blockquote><p>그리고 빌드를 시켜주면, 자연스럽게 버튼을 누를 경우, 네비게이션이 연결된 뷰가 뜰 것입니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b979188a1a82" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Kitura로 서버 만들기]]></title>
            <link>https://medium.com/@mingdaejo/kitura%EB%A1%9C-%EC%84%9C%EB%B2%84-%EB%A7%8C%EB%93%A4%EA%B8%B0-faa1759d3c2?source=rss-7074ea5bc590------2</link>
            <guid isPermaLink="false">https://medium.com/p/faa1759d3c2</guid>
            <category><![CDATA[kitura]]></category>
            <category><![CDATA[server-side-swift]]></category>
            <category><![CDATA[swift-3]]></category>
            <dc:creator><![CDATA[조민재]]></dc:creator>
            <pubDate>Tue, 28 Mar 2017 17:37:22 GMT</pubDate>
            <atom:updated>2017-03-28T17:37:22.400Z</atom:updated>
            <content:encoded><![CDATA[<h3>Kitura란 무엇일까요?</h3><p>Swift is now open Source! 그래요! 스위프트는 이제 오픈소스입니다.</p><p>IBM에서는 Swift가 출시된 후, 열심히 공들이고 있습니다. <a href="https://developer.ibm.com/swift/products/ibm-swift-sandbox/">IBM Swift Sandbox</a>부터 Linux 서버에서 실행할 수 있는 서버사이드 Swift인 Kitura까지 이 모든것이 IBM에서 만든것이지요. 왜 IBM에서는 Swift에 이렇게 관심을 많이 쏟을까요? 아마 그건, IBM의 발표 자료에서 볼 수 있듯이 IBM이 자신의 클라우드 플랫폼인 Bluemix와 Swift 를 통한 환경을 지원하려는 의지가 강력하다는 것에 있지 않을까 생각합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/385/1*re_oK6l1Wf0gX8bZlRO7-A.png" /><figcaption>kitura logo</figcaption></figure><p>IBM이 발표한 <a href="https://developer.ibm.com/swift/products/kitura/">Kitura</a>는 웹 어플리케이션을 개발하기위한 프레임워크입니다. 현재의 모습은 아직은 꽤 작고 기초적인 단계라서 Perfect.org 보다 많이 부족합니다. 하지만, IBM의 전폭적인 지지를 힘입는 Kitura라면 금방 성장할 것으로 보입니다.</p><p>GitHub README에 의하면, Linux와 OS X에서 동작을 하는 Kitura는 다양한 모듈기반의 미들웨어이고, HTTP URL 라우팅(GET, POST, PUT, DELETE)을 지원하며 파라메터 파싱, 정적파일 서빙, <a href="https://github.com/IBM-Swift/Kitura/blob/master/Documentation/FastCGI.md">FastCGI</a> 서포트, SSL/TLS 서포트와 JSON 파싱 정도를 할 수 있다고 합니다. 라이센스는 Apache 2.0 입니다.</p><h3>Kitura 패키지 설치</h3><ol><li>자신이 지정한 폴더를 terminal 를 통해 열기.</li><li>swift package init --type executable 패키지 매니저를 만들기</li><li>Package.swift 안의 Dependencies에 kitura를 추가</li></ol><blockquote>import PackageDescription let package = Package(name:“AppServer”,dependencies: [.Package(url: “https://github.com/IBM-Swift/Kitura.git&quot;,majorVersion:1)])</blockquote><p>4. swift build 하기</p><h3>Kitura 실행</h3><pre>import Kitura<br><br>// Create a new router<br>let router = Router()<br><br>// Handle HTTP GET requests to /<br>router.get(&quot;/&quot;) {<br>    request, response, next in<br>    response.send(&quot;Hello, World!&quot;)<br>    next()<br>}<br><br>// Add an HTTP server and connect it to the router<br>Kitura.addHTTPServer(onPort: 8090, with: router)<br><br>// Start the Kitura runloop (this call never returns)<br>Kitura.run()</pre><ol><li>Sources/main.swift 안에 위의 코드들 붙여넣기</li><li>swift build을 통해 컴파일 하기</li><li>.build/debug/AppServer 을 통해 run시키기</li><li><a href="http://localhost:8090/">http://localhost:8090/</a>에 helloworld가 찍힌 것을 확인하기</li></ol><p>만약 로그를 찍고 싶다 싶으면, <a href="https://github.com/IBM-Swift/HeliumLogger.git">https://github.com/IBM-Swift/HeliumLogger.gi</a>t 을 위의 kitura처럼 Package.swift안에 디펜던시에 걸어주고 사용하시면 됩니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=faa1759d3c2" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[스위프트 패키지 매니저에 관하여…]]></title>
            <link>https://medium.com/@mingdaejo/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%A7%A4%EB%8B%88%EC%A0%80%EC%97%90-%EA%B4%80%ED%95%98%EC%97%AC-f2e83ead026a?source=rss-7074ea5bc590------2</link>
            <guid isPermaLink="false">https://medium.com/p/f2e83ead026a</guid>
            <category><![CDATA[swift-3]]></category>
            <category><![CDATA[package-manager]]></category>
            <category><![CDATA[swift-package-manager]]></category>
            <category><![CDATA[kitura]]></category>
            <category><![CDATA[swift]]></category>
            <dc:creator><![CDATA[조민재]]></dc:creator>
            <pubDate>Tue, 28 Mar 2017 16:35:25 GMT</pubDate>
            <atom:updated>2017-03-28T16:35:25.197Z</atom:updated>
            <content:encoded><![CDATA[<p>스위프트 패키지 매니저는 소스코드의 배포를 위한 툴입니다. 자신의 코드를 공유하고 다른 사람들의 코드를 모듈이라는 단위로 재활용하기 쉽게 도와줍니다. 이 툴은 스위프트 패키지들을 컴파일하고 링크하고, 의존성과 버전을 관리하고, 유연한 배포와 협업 모델을 지원하게 됩니다.</p><p>스위프트 패키지 매니저를 살펴보기전에, 용어에 대해서 짚고 넘어가볼까 합니다.</p><blockquote>패키지- 소프트웨어, 응용프로그램, 데이터의 ‘배포판’을 칭합니다. 또한 패키지는 메타 데이터를 포함하는 특성을 지니고 있습니다.</blockquote><blockquote>패키지 매니저- 설치, 업데이트, 설정, 삭제를 자동화해주는 툴입니다. 보통 패키지 매니저는 소프트웨어의 의존성이나 버전정보를 관리합니다.</blockquote><blockquote>패키지 컨벤션- 의존성 문제 해결과 같이 원활한 배포를 도와주는 역할을 수행합니다. 사용자 입장에서 패키지 매니저 사용방법만 알게 되면 쉽게 쓸 수 있게 되지요.</blockquote><p><em>스위프트 패키지 매니저</em>는 스위프트 소스파일과 매니페스트 파일로 구성됩니다. 매니페스트 파일은, Package.swift 이름을 가지며, 패키지의 이름과 그 콘텐트를 PackageDescription 모듈을 이용해 정의됩니다.</p><p>그럼 간단하게 실행가능한 패키지를 만들어 봅시다.</p><p>먼저 터미널에 빈 폴더를 대상으로swift package init --type executable 입력해 줍니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/984/1*vgugxlAo48dil1mde8qexw.png" /><figcaption>swift package 생성시 모습</figcaption></figure><p>매니페스트인 Package.swift부터 시작해서 소스코드가 담겨지는 Sources가 추가됩니다.</p><p>Package.swift에 디펜던시를 추가해줍니다.</p><pre><strong>import</strong> <strong>PackageDescription</strong><br><br><strong>let</strong> package <strong>=</strong> <strong>Package</strong>(<br>    name: &quot;Dealer&quot;,<br>    targets: [],<br>    dependencies: [<br>        <strong>.Package</strong>(url: &quot;https://github.com/apple/example-package-deckofplayingcards.git&quot;,<br>                 majorVersion: 1),<br>    ]<br>)</pre><p>그 이후, 쉽게 swift build 해주시면 자동으로 디펜던시와 연결이 됩니다.</p><p>하지만, 그 이후에 이와같은 에러가 뜨게 되는데 이 부분은 버전정보가 안맞아서 에러가 뜨게 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/978/1*g8Z3LLcJamf9YAfUm_zmLw.png" /></figure><p>이 경우, 다시 dependencies 안의 majorVersion을 최신버전으로 3또는 이후 버전을 지정해주면 됩니다.</p><p><strong>.Package</strong>(url:&quot;https://github.com/apple/examplepackagedeckofplayingcards.git&quot;, majorVersion: <strong><em>3</em></strong>)</p><p>그럼에도 swift build 가 안되신다면, .build 의 파일들을 rm -rf .build/* 이 명령어를 통해 날려줍니다! 그 후, 다시 swift build를 해주신다면 정상적으로 작동이 되실 겁니다.</p><pre><strong>import</strong> <strong>PlayingCard</strong><br><strong>import</strong> <strong>DeckOfPlayingCards</strong><br><br><strong>let</strong> numberOfCards <strong>=</strong> 10<br><br><strong>var</strong> deck <strong>=</strong> <strong>Deck.standard52CardDeck</strong>()<br>deck<strong>.shuffle</strong>()<br><br><strong>for</strong> _ <strong>in</strong> 1<strong>...</strong>numberOfCards {<br>    <strong>guard</strong> <strong>let</strong> card <strong>=</strong> deck<strong>.deal</strong>() <strong>else</strong> {<br>        <strong>print</strong>(&quot;No More Cards!&quot;)<br>        <strong>break</strong><br>    }<br><br>    <strong>print</strong>(card)<br>}</pre><p>이 코드를 /Sources안의 main.swift에 복사해준 후 , 빌드를 다시합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/562/1*Me9nssY_2cZ2LyRBq8qe8A.png" /></figure><p>이 후, ./.build/debug/Dealer에 이런 결과가 떴다면 성공한 것입니다.</p><p>잠깐이나마, 짧게 swift.org의 튜토리얼을 따라해보았습니다.</p><p>다음에는 swift로 돌리는 Back-End인 Kitura에 대해 알아보겠습니다.</p><blockquote>참고링크</blockquote><blockquote><a href="https://swift.org/package-manager/#conceptual-overview">https://swift.org/package-manager/#conceptual-overview</a></blockquote><blockquote><a href="https://github.com/lingostar/swift-package-manager">https://github.com/lingostar/swift-package-manager</a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f2e83ead026a" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>