<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>아내와 아들 그리고 딸밖에 모르는 남편</title>
    <link>http://sculove.github.io/blog/</link>
    <atom:link href="/blog/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>FrontEnd 개발자. JavaScript, RxJS, Angular, React 기술 경험 블로그</description>
    <pubDate>Sat, 02 Mar 2019 23:01:28 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>90년대생이 온다.</title>
      <link>http://sculove.github.io/blog/2019/03/03/newgeneration/</link>
      <guid>http://sculove.github.io/blog/2019/03/03/newgeneration/</guid>
      <pubDate>Sat, 02 Mar 2019 20:55:22 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/blog/2019/03/03/newgeneration/90come.jpg&quot; title=&quot;90년대생이 온다&quot;&gt;
&lt;p&gt;팀회식때 팀원이 나보고 ‘90년대생이 온다’ 라는 책을 봐보란다.&lt;br&gt;회식때 흘러들은 이야기들은 가급적이면 새겨(?)듣는 편이기에 바로 책을 사서 집에서 곰곰히 읽어봤다.&lt;br&gt;사실 별 공감이 되지는 않았다.&lt;br&gt;내가 이 책을 보면서 느낌 감정은 2가지 였다.&lt;br&gt;첫째, 우선 내가 공감하지 못하는 것을 안 순간부터 아 &lt;code&gt;나 진짜 꼰대였구나.&lt;/code&gt;라는 생각이 들었다.&lt;br&gt;둘째, &lt;code&gt;아 이렇게 행동하고 생각하는게 90년대생들에게는 정상이구나&lt;/code&gt; 라는 생각의 이해 정도.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/blog/2019/03/03/newgeneration/90come.jpg" title="90년대생이 온다"><p>팀회식때 팀원이 나보고 ‘90년대생이 온다’ 라는 책을 봐보란다.<br>회식때 흘러들은 이야기들은 가급적이면 새겨(?)듣는 편이기에 바로 책을 사서 집에서 곰곰히 읽어봤다.<br>사실 별 공감이 되지는 않았다.<br>내가 이 책을 보면서 느낌 감정은 2가지 였다.<br>첫째, 우선 내가 공감하지 못하는 것을 안 순간부터 아 <code>나 진짜 꼰대였구나.</code>라는 생각이 들었다.<br>둘째, <code>아 이렇게 행동하고 생각하는게 90년대생들에게는 정상이구나</code> 라는 생각의 이해 정도.</p><a id="more"></a><p>그 순간 갑자기 몇일 전에 러닝머신을 달리면서 느낀 감정들이 함께 생각이 났다.<br>러닝머신을 달리면서 티비를 보는데 <code>미스터 맘마</code>라는 옛날 영화가 나왔다.  </p><img src="/blog/2019/03/03/newgeneration/mom.jpg" title="미스터 맘마"><p>고 최진실이 나오기도 하고 해서 반가운 마음에 계속보고 있는데 지금 생각하면 납득이 안되는 장면들이 그 시대에는 당연한 모습으로 표현되고 있었다.</p><p>간단히 설명하면.<br>최민수가 아이를 홀로 키우고 있다.<br>최민수가 직장후배인 최진실에서 애를 봐달라고 부탁한다. 그리고선 자기는 회식을 가지.<br>이것도 어이가 없지만… 민수형이 밤새 연락도 없이 회식에서 술을 먹는동안,<br>아이가 아파서 진실누나가 밤새 애를 본다.<br>이때 보니 우리 애기 아팠을때 나랑 와이프가 애타게 보던게 생각나면서 셋째는 두번 다시는 안가져야지.<br>내가 저걸 다 어떻게 했을까?<br>지금 해라면 절대 못한다.<br>등등등 정말 많은 생각들이 주마간산처럼 지나갔다.<br>암튼, 진실 누나는 결국 아이를 병원 응급실로 데러간다.  </p><p>진실누나는 그때까지도 애를 보고 있는 상황도 납득이 안가지만.<br>더 가관은 최민수가 병원으로 와서는 다짜고짜 최진실 빰을 때린다.<br>세상에나<br>이게 가당키나 한 상황인가?  </p><p>그때 볼때는 정말 아무렇지도 않았는데 시간이 흐르고 이 영화를 다시보니 이렇게 시대적인 충격을 받는게 신기했다.<br>내가 아무렇지도 않게 느낀 시대가 변한 것에 놀랐고, 나도 모르게 나이가 먹은 나에게 다시 한번 놀랐다.  </p><p>난 아직도 서태지 형 노래를 따라부르는 청년이라고 생각했는데<br>생각하고 보니<br>어렸을때 무심코 따라 불렀던 서태지 형아 노래가 이제는<br>어렸을때 보았던 가요무대에서나 들릴 법한 노래가 되었다.<br>‘운동하는 사람은 빨리 죽는다’며 궁색한 변명을 늘어놓으면서 비아냥 거리던 시기는 지나고<br>이제는 운동을 안하면 몸이 아픈 나이가 되었다.<br>힘들어도 아이와 노는것이 신났던 아빠는 없고, 아이에게 궁색한 변명만 늘어놓는 중년의 아빠가 되었다.<br>개발이 잼있어서 집에가라고 해도 남아서 개발하고<br>집에 와서도 짜투리 시간에 개발하였던 내 열정도<br>이제는 일이 많아서 일만하는 꼰대가 되었다.<br>된장!</p><p>태지 형.<br>형말 아직 유효한거죠?</p><blockquote><p>우린 아직 젊기에<br>괜찮은 미래가 있기에<br>자 이제 그 차가운 눈물은 닦고<br>COME BACK HOME<br>YOU MUST COME BACK</p></blockquote><img src="/blog/2019/03/03/newgeneration/seo.png" title="서태지와아이들">]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2019/03/03/newgeneration/#disqus_thread</comments>
    </item>
    
    <item>
      <title>개발자를 어떻게 학습시키는게 효과적일까?. 자기반성 모드</title>
      <link>http://sculove.github.io/blog/2018/12/31/learn2018/</link>
      <guid>http://sculove.github.io/blog/2018/12/31/learn2018/</guid>
      <pubDate>Sun, 30 Dec 2018 18:43:20 GMT</pubDate>
      <description>
      
        &lt;p&gt;개발자를 어떻게 학습시킬것 인가?에 대한 자기성찰을 좀 해보려고 한다.&lt;/p&gt;
&lt;p&gt;이 성찰의 결정적인 계기는&lt;br&gt;애자일 컨설팅 대표로 있는 김창준님이 내놓은 책을 읽으면서 느꼈던 내 수치심으로 부터 시작되었다.&lt;/p&gt;
&lt;p&gt;연말이라 좀 시간도 있고 해서 책을 하나 사서 봤다. 김창준님이 내놓은 신간 책이다.&lt;br&gt;책 내용은 사실 지금까지 이 분이 &lt;a href=&quot;http://agile.egloos.com/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;블로그&lt;/a&gt;를 통해 이야기한 내용과 별반 다르지 않다.&lt;br&gt;좀 더 구체적으로 친절하게 정리해 놓은 책이다. 결론은 좋은 책이다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>개발자를 어떻게 학습시킬것 인가?에 대한 자기성찰을 좀 해보려고 한다.</p><p>이 성찰의 결정적인 계기는<br>애자일 컨설팅 대표로 있는 김창준님이 내놓은 책을 읽으면서 느꼈던 내 수치심으로 부터 시작되었다.</p><p>연말이라 좀 시간도 있고 해서 책을 하나 사서 봤다. 김창준님이 내놓은 신간 책이다.<br>책 내용은 사실 지금까지 이 분이 <a href="http://agile.egloos.com/" rel="external nofollow noopener noreferrer" target="_blank">블로그</a>를 통해 이야기한 내용과 별반 다르지 않다.<br>좀 더 구체적으로 친절하게 정리해 놓은 책이다. 결론은 좋은 책이다.</p><a id="more"></a><img src="/blog/2018/12/31/learn2018/book.jpg" title="함께 자라기 애자일로 가는 길"><p>새롭지 않는 내용을 읽으면서 왜 새삼스럽게 나는 수치심을 느꼈는가?<br>수치심이라는 표현이 맞는지 모르겠다.<br>아~ 진작에 이 책대로 행동했으면 좋았겠다는 후회정도로 표현해보자.</p><p>사람은 겪어보지 않으면 모른다고 했던가?<br>아마 지금의 내 상황에 가장 적합한 표현일 것이다.<br>예전에 읽을 때는 아~ 그런가보다. 좋은 내용이네. 정도의 느낌이 었다면<br>이번에는 책읽은 감동을 하나라도 놓치지 않기 위해 이렇게 새벽녘에 혼자 노트북을 켜고 글을 쓰고 있다.</p><p>이 책은 학습과 협력을 바탕으로 애자일에 대한 이야기를 약간 하고 있다. 하지만 그 중심 키워드는 항상 <code>학습</code>과 <code>협력</code>이다.<br>개발자의 입장에서 학습은 정말 정말 중요한 요소이다.<br>내가 개발자를 면접 볼때도 항상 중요하게 보는 포인트이기도 하다.<br>FE와 같이 기술의 발전속도가 굉장히 빠른 분야는 특히나 더 중요하다.<br>내가 이 책에서 <code>아하</code>라고 느꼈던 부분은 효과적인 학습 방법에 대한 내용이다.</p><p>지금까지 나는 무언가를 배울 때 <code>오~ 재미있겠다</code>라는 생각으로 시작해서 학습하고 학습한 것을 바탕으로 다시 연습하고 다시 연습한 것을 바탕으로 프로젝트에 적용해보고 다시 적용한 경험을 가지고 다시 학습하는 싸이클을 만들어 갔다.<br>하지만 이건 내가 그냥 무의식에서 했던 작업이었다.<br>그래서 내가 그러했듯이 남들도 이렇게 하겠지라는 생각이 무의식 속에 있었다.</p><h3 id="힘든-학습"><a href="#힘든-학습" class="headerlink" title="힘든 학습"></a>힘든 학습</h3><p>올해 우리팀에서 FE개발자이지만 서버영역을 배워보고 싶어하는 동료가 있었다.<br>직접 하고자하는 동기 부여도 충분해 보였고 회사 경력도 가지고 있는 분이었다.<br>팀 차원에서도 랜더 서버 운영을 위해서 필요한 영역이었기에 학습 후에 팀원들과 공유하는 자리를 가지면 개인과 팀에 서로 도움이 될것 같았다.<br>그래서 내가 지원했던 부분은 <code>집중 할수 있는 충분한 시간을 제공</code> 해주는 것이었다.</p><p>하지만, 시간이 지날 수록 처음의 내 생각과 다르게 진행하는 동료가 개인적으로 굉장히 힘들어 했다.<br>혼자 학습의 길을 잘 찾아가지 못했던 것이 보였다.<br>몇 일이 지나가도 진척이 잘 보이지 않았다.<br>중간에 몇 번이고 피드백을 주고 진척되지 않는 상황에 대한 내용을 여쭤보려고 했으나… 그러질 못했다.<br>아니 그러질 안했다.<br>결국에 시간이 더 지나고 나서야 진행하는 부분에 대해 내가 몇가지 <code>피드백</code>도 주었고 도움을 줄 수 있는 서버쪽 동료를 <code>협업자</code>로 지원해 주었다.<br>그나마 예전보다 나아졌지만 여전히 동료는 이 작업 자체를 힘들어 했다.<br>결국에는 사내에 잘 정리되어있는 가이드 문서를 참조하면서부터 학습의 속도가 높아지고 작업에 속도감이 붙었다.</p><h3 id="좋은-학습"><a href="#좋은-학습" class="headerlink" title="좋은 학습"></a>좋은 학습</h3><p>왜 이렇게 힘들게 이 과정을 겪었을까?<br>학습하려는 학습자의 학습 능력이 부족했을까?<br>아니라고 본다.</p><p>이 동료분에게 다른 과제를 주어보았다.<br>앞에와 동일하게 충분한 동기부여가 있는 FE웹관련 리서치 작업을 요청해 보았다.<br>전과 동일하게 <code>집중 할수 있는 충분한 시간을 제공</code> 해주었다.</p><p>다른게 있다면</p><ul><li>첫째. 2~3일마다 만나서 중간 중간 <code>피드백</code>을 하고 이슈들을 이야기했다. (후반부에는 일주일 정도)</li><li>둘째. 자신이 이미 알고 있는 영역 내에서의 리서치 작업이기 때문에 난이도가 적당한 수준이었다.</li></ul><p>이 둘만 다른 상황에서 결과물은 너무나 달랐다.<br>작업 기간도 짧았을 뿐만아니라 작업했던 동료의 만족도도 달랐다.<br>물론 결과물의 품질도 많이 달랐다.</p><p>왜 똑같은 사람이 한 작업의 결과물이 이렇게 달라질 수 있었을까?</p><p>지금 생각해보면 이 상황의 패착은 전적으로 <code>나의 코칭 방식</code> 때문이다.<br>학습을 위해 필요한 요소를 내가 잘 지원하지 못했던 것이다.</p><p>그냥 막연히 <code>충분한 동기</code>를 가지고 있는 동료였기 때문에 <code>충분한 시간</code>을 주면 된다고 생각했다.<br>하지만 빠진게 있었다. 바로 <code>적절한 피드백</code>이 었다.<br>첫번째 작업에서 난 적절한 피드백을 주지 못했던 것이다.<br>난 이 동료를 몰아 넣고 방관만 하고 있었던 것이 었다.<br><code>내가 내 동료를 신뢰하지 못한다</code>는 생각을 전달하는 것 같아서 <code>피드백</code>을 주지않고 바보같이 오히려 참을성을 갖고 더 기다린 것이다.<br>또한 결정적으로 내가 놓치고 있었던 점이 있었다.<br>이 분이 <code>몰입 할수 있는 환경</code>을 만들지 못했다는 점이다.<br>몰입은 <code>적절한 난이도</code>에서 가장 최적의 몰입을 할수 있다. 하지만 난 이 분을 잘 파악하지 못하고 있었다.<br>회사에서 개발 경력이 있어서 서버쪽도 쉽게 배울수 있을 것이라는 착각을 한 것이다.<br>이 분이 잘 할수 있도록 하기 위해서는 아무것도 모르는 초심자 수준에서 그에 걸맞는 과제를 던져 주어야했던 것이다.<br>그리고 그 과제를 통해 성취감을 얻으면 다음 단계의 과제를 던져주었어야만 했다.</p><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><p>그래서 개발자를 효과적으로 학습하기 위한 방법을 정리해보면 다음과 같다.</p><ul><li>학습의 동기</li><li>적절한 피드백</li><li>적절한 난이도의 학습.일</li><li>그리고 집중 할 수 있는 시간</li></ul><p>을 제공하여 개발자를 학습시킨다면 학습을 하는 당사자도 성장의 만족감을 얻을 것이고<br>코칭하는 입장에서도 보람을 얻을수 있을 것이다.</p><p>뭐~ 물론 내가 경험했던 이 일이 정답은 아니다.<br>하지만 도움은 되리라 생각한다.<br>다시 한번 제 경험을 정리할수 있도록 도와준 김창준님의 책에 감사를 표하며 이 글을 마친다.</p>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2018/12/31/learn2018/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2019년 자바스크립트 개발은 VSCODE로</title>
      <link>http://sculove.github.io/blog/2018/11/28/to-vscode-in-2019/</link>
      <guid>http://sculove.github.io/blog/2018/11/28/to-vscode-in-2019/</guid>
      <pubDate>Wed, 28 Nov 2018 01:23:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;저만 알고 오래오래 쓰고 싶었는데요.&lt;br&gt;제 개발툴 경험 및 노하우를 적어 봅니다. ㅋ (참고로 전 JavaScript 개발자입니다)&lt;/p&gt;
&lt;h3 id=&quot;SublimeText…WebStorm을-거쳐&quot;&gt;&lt;a href=&quot;#SublimeText…WebStorm을-거쳐&quot; class=&quot;headerlink&quot; title=&quot;SublimeText…WebStorm을 거쳐&quot;&gt;&lt;/a&gt;SublimeText…WebStorm을 거쳐&lt;/h3&gt;&lt;p&gt;저는 JavaScript 개발자라면 다 써본다는 SublimeText를 선호하는 개발자였습니다.&lt;br&gt;SublimeText가 가볍기도 하거니와 다양한 플러그인이 있어서 열심히 찾고 다니기만 한다면 자기가 원하는 환경을 만들수 있습니다. 하지만 SublimeText가 생각보다 설정해야 할 것이 많이 있습니다.&lt;br&gt;더불어 컴퓨터 바뀔 때마다 플러그인을 매번 설치하는 것도 까다로웠죠. 더군다나 플러그인 자체가 ruby로 되어 있어서 답답한 면이 있었습니다.&lt;/p&gt;
&lt;p&gt;이런 불편함 쯤이야…&lt;br&gt;잘~ 견대내었는데요.&lt;/p&gt;
&lt;p&gt;이거 바꿔야겠다고 생각한게 &lt;strong&gt;좀 큰 파일 (번들링된 파일을 열어서 수정하는 경우, 파일이 많은 프로젝트를 열어서 수정하는 경우…)… 버버버벅 됩니다.&lt;/strong&gt;&lt;br&gt;특히 다양한 플로그인을 설치해놓은 상태에서는 상태가 더 심각합니다.&lt;/p&gt;
&lt;p&gt;그래서 선택 한게 SublimeText보다 더 비싼 WebStorm입니다. (역시 돈이 최고얏!)&lt;br&gt;&lt;strong&gt;오~ 이거 메모리만 빠방한다면 쓸만합니다. 좋아요~&lt;/strong&gt;&lt;br&gt;하지만… &lt;strong&gt;정말 메모리를 엄청 늘려야해요. 기본적으로 JVM 에서 돌아가기 때문에 heap만 몇기가를 잡아야해요.&lt;/strong&gt;&lt;br&gt;파일이 좀 많은 프로젝트를 열어서 엔터만 치면 차한잔 마시고 와야할 정도 였죠.&lt;br&gt;전 아직도 6년 전 구시대 iMac을 쓰고 있기에 이런 단점을 몸소 체험했었습니다.&lt;/p&gt;
&lt;h3 id=&quot;VSCODE&quot;&gt;&lt;a href=&quot;#VSCODE&quot; class=&quot;headerlink&quot; title=&quot;VSCODE&quot;&gt;&lt;/a&gt;VSCODE&lt;/h3&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>저만 알고 오래오래 쓰고 싶었는데요.<br>제 개발툴 경험 및 노하우를 적어 봅니다. ㅋ (참고로 전 JavaScript 개발자입니다)</p><h3 id="SublimeText…WebStorm을-거쳐"><a href="#SublimeText…WebStorm을-거쳐" class="headerlink" title="SublimeText…WebStorm을 거쳐"></a>SublimeText…WebStorm을 거쳐</h3><p>저는 JavaScript 개발자라면 다 써본다는 SublimeText를 선호하는 개발자였습니다.<br>SublimeText가 가볍기도 하거니와 다양한 플러그인이 있어서 열심히 찾고 다니기만 한다면 자기가 원하는 환경을 만들수 있습니다. 하지만 SublimeText가 생각보다 설정해야 할 것이 많이 있습니다.<br>더불어 컴퓨터 바뀔 때마다 플러그인을 매번 설치하는 것도 까다로웠죠. 더군다나 플러그인 자체가 ruby로 되어 있어서 답답한 면이 있었습니다.</p><p>이런 불편함 쯤이야…<br>잘~ 견대내었는데요.</p><p>이거 바꿔야겠다고 생각한게 <strong>좀 큰 파일 (번들링된 파일을 열어서 수정하는 경우, 파일이 많은 프로젝트를 열어서 수정하는 경우…)… 버버버벅 됩니다.</strong><br>특히 다양한 플로그인을 설치해놓은 상태에서는 상태가 더 심각합니다.</p><p>그래서 선택 한게 SublimeText보다 더 비싼 WebStorm입니다. (역시 돈이 최고얏!)<br><strong>오~ 이거 메모리만 빠방한다면 쓸만합니다. 좋아요~</strong><br>하지만… <strong>정말 메모리를 엄청 늘려야해요. 기본적으로 JVM 에서 돌아가기 때문에 heap만 몇기가를 잡아야해요.</strong><br>파일이 좀 많은 프로젝트를 열어서 엔터만 치면 차한잔 마시고 와야할 정도 였죠.<br>전 아직도 6년 전 구시대 iMac을 쓰고 있기에 이런 단점을 몸소 체험했었습니다.</p><h3 id="VSCODE"><a href="#VSCODE" class="headerlink" title="VSCODE"></a>VSCODE</h3><a id="more"></a><p>그래서 제가 선택한게 바로 <a href="https://code.visualstudio.com/" rel="external nofollow noopener noreferrer" target="_blank">VSCODE</a> 입니다.<br>무료 오픈소스인데 이게 생각보다 엄청납니다.<br>MS의 자랑 중 하나였던 Visual Studio의 명성을 그대로 이어 받은 정말 잘 만든 에디터입니다.</p><h4 id="1-모두가-선택한-IDE"><a href="#1-모두가-선택한-IDE" class="headerlink" title="1. 모두가 선택한 IDE"></a>1. 모두가 선택한 IDE</h4><p>JavaScript 계열에서의 IDE도 춘추 전국시대가 있었습니다.<br>제가 SublimeText를 써 왔던 것처럼 많은 이들이 다양한 에디터를 써왔습니다.<br>어떤 이는 SublimeText를 쓰고, 어떤 이는 Atom을 쓰기도 했죠. 몇몇 장인들은 에디터 플러스를 쓰기도 했습니다.<br>서로 자기가 최강의 에디터라고 군림하던때였습니다. 이런 춘추전국시대를 통일한 IDE가 바로 WebStorm이었죠.<br>WebStrom은 정말 좋은 툴이지만. 몇가진 단점이 있었습니다.</p><ul><li>첫째. 비싸요</li><li>둘째. JVM 환경하에 동작하기 때문에 느렸죠 ㅠㅠ<br>이런 단점들을 커버하고 등장한게 바로 VSCODE입니다.</li></ul><p>VSCODE가 유료툴 보다 좋다? 사실 분명하게 말하기는 어렵습니다. 하지만. 많은 사람들이 VSCODE를 선택하고 있다는 것은 명백한 사실입니다.<br>대표적으로 Stackoverflow에서 공개한 JavaScript TextEditor 자료를 보면 VSCODE의 위엄을 확인 할수 있습니다.<br>stackoverflow 자료에서는 2017년 두각을 나타내기 시작해서 2018년에는 거의 압도적으로 많은 사람들이 사용하는 IDE툴이 되었습니다. 캬~<br><img src="/blog/2018/11/28/to-vscode-in-2019/2017-texteditor.png"><br><a href="https://2017.stateofjs.com/2017/other-tools/" rel="external nofollow noopener noreferrer" target="_blank">2017년 Text Editors</a><br><img src="/blog/2018/11/28/to-vscode-in-2019/2018-texteditor.png"><br><a href="https://2018.stateofjs.com/other-tools/" rel="external nofollow noopener noreferrer" target="_blank">2018년 Text Editors</a></p><h4 id="2-VSCODE가-정말-빠릅니다"><a href="#2-VSCODE가-정말-빠릅니다" class="headerlink" title="2. VSCODE가 정말 빠릅니다."></a>2. VSCODE가 정말 빠릅니다.</h4><p>초기 에디터 띄우는 데 시간이 약간 걸리지만, 그 이후 부터는 완전 쾌적해요.<br>WebStrom이나 IntelliJ와 같이 Java JVM 에서 동작하지 않고 V8기반의 Electron에서 동작하기 때문에 정말 가볍고 빠릅니다.<br>이게 최고의 장점입니다.</p><h4 id="3-개발자에게-꼭-필요한-다양한-플로그인"><a href="#3-개발자에게-꼭-필요한-다양한-플로그인" class="headerlink" title="3. 개발자에게 꼭 필요한 다양한 플로그인"></a>3. 개발자에게 꼭 필요한 다양한 플로그인</h4><p>SublimeText 처럼 인터넷을 살펴보시면 VSCODE의 추천 플러그인들은 차고 넘쳐납니다.<br>언어에 국한되지 않고 차고 넘쳐나요. 더군다나 플러그인 자체가 js이기에 간단한 플러그인도 필요에 따라 직접 만들수 있습니다.<br>(저도 간단히 <a href="http://sculove.github.io/blog/2017/12/27/createvsextension/">Translator라는 플러그인</a>이라는 것을 만들어봤었습니다. 하하하)</p><p>정말 좋은 플러그인이 많은데요.<br>그 중에 좀 특이하지만 유용한것 몇가지만 소개해 드릴께요.</p><h5 id="GithubPull-Requests"><a href="#GithubPull-Requests" class="headerlink" title="GithubPull Requests"></a><a href="https://marketplace.visualstudio.com/items?itemName=GitHub.VSCODE-pull-request-github" rel="external nofollow noopener noreferrer" target="_blank">GithubPull Requests</a></h5><p>이 플러그인은 VSCODE 내에서 코드리뷰를 쉽게 할 수 있게 도와줘요. 리뷰 할때 해당 브랜치 내용을 확인하기 위해서 checkout 받는 경우가 종종 있죠?<br>checkout 받아서 커밋별, 파일별 파일 변경사항을 볼수 있고 리뷰 커멘트를 바로 적을수 있습니다.<br><img src="/blog/2018/11/28/to-vscode-in-2019/pr-by-commit.png"><br>코드 리뷰가 훨씬 편해요.<br><a href="https://github.com/Microsoft/VSCODE-pull-request-github/blob/master/.readme/demo.gif?raw=true" rel="external nofollow noopener noreferrer" target="_blank"><img src="/blog/2018/11/28/to-vscode-in-2019/demo.gif"></a></p><h5 id="Settings-Sync"><a href="#Settings-Sync" class="headerlink" title="Settings Sync"></a><a href="https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync" rel="external nofollow noopener noreferrer" target="_blank">Settings Sync</a></h5><p>전 구형 iMac으로 개발하고 최신 MacBook Pro로 개발을합니다.<br>동일한 개발환경을 항상 유지하고 싶은 경우가 많은데요.<br>이때 마다 환경 맞추는 작업을 했었습니다. 쓰던 플러그인도 다시 깔고, 필요없다고 생각했던 플러그인도 지우고, 환경 설정도 매번 맞추는 작업을 했습니다. ㅠㅠ<br>하지만, VS Code의 Settings Sync를 이용하면 명령어 하나로 환경을 동기화할 수 있습니다.<br>이거 완전 편합니다.<br>집에서도 회사처럼 열심히 일할수 있어요 ㅡㅡ;;</p><h4 id="VS-Live-Share"><a href="#VS-Live-Share" class="headerlink" title="VS Live Share"></a><a href="https://marketplace.visualstudio.com/items?itemName=MS-vsliveshare.vsliveshare" rel="external nofollow noopener noreferrer" target="_blank">VS Live Share</a></h4><p>라이브 코딩이 됩니다. 페어프로그래밍할때 유용하게 할수 있겠죠?<br>저희 팀은 아직 이 단계까지는 프로세스로 못잡아서 시험만 해봤습니다. 구글독스의 동시편집같이 되요. 로컬이다보니 버벅임도 없이 정말 잘됩니다.<br>커서에 사용자 아이디가 보입니다. 요런식으로 ㅋ<br><a href="https://code.visualstudio.com/assets/blogs/2017/11/15/vs-code-ls-session2.png" rel="external nofollow noopener noreferrer" target="_blank"><img src="/blog/2018/11/28/to-vscode-in-2019/vscode-live.png"></a></p><p>자세한 것은 여기 링크를 봐보세요.<br><a href="https://code.visualstudio.com/blogs/2017/11/15/live-share" rel="external nofollow noopener noreferrer" target="_blank">https://code.visualstudio.com/blogs/2017/11/15/live-share</a></p><h3 id="FrontEnd-개발자라면…"><a href="#FrontEnd-개발자라면…" class="headerlink" title="FrontEnd 개발자라면…"></a>FrontEnd 개발자라면…</h3><p>저는 VSCODE를 사용하면 개발 생산성을 높이는데 많은 도움이 되었습니다.<br>저와 마찬가지로 몇몇 개발자는 이미 WebStorm에서 VSCODE로 옮겼던 경험들을 공유하기도 했습니다.</p><ul><li><a href="https://medium.com/@jawache/from-webstorm-to-vs-code-bd01ccc92aaf" rel="external nofollow noopener noreferrer" target="_blank">https://medium.com/@jawache/from-webstorm-to-vs-code-bd01ccc92aaf</a></li><li><a href="https://blog.buddyweb.fr/my-way-from-webstorm-to-vs-code-and-other-things-in-a-developers-life-fe71f0d07c59" rel="external nofollow noopener noreferrer" target="_blank">https://blog.buddyweb.fr/my-way-from-webstorm-to-vs-code-and-other-things-in-a-developers-life-fe71f0d07c59</a></li><li><a href="https://medium.com/linagora-engineering/from-webstorm-to-VSCODE-road-to-the-freedom-743eda17164a" rel="external nofollow noopener noreferrer" target="_blank">https://medium.com/linagora-engineering/from-webstorm-to-VSCODE-road-to-the-freedom-743eda17164a</a></li><li><a href="https://rationaldev.com/webstorm-vs-visual-studio-code/" rel="external nofollow noopener noreferrer" target="_blank">https://rationaldev.com/webstorm-vs-visual-studio-code/</a></li></ul><p>만약 JavaScript/TypeScript/HTML/CSS/node.js 등을 다루는 개발자라면 VSCODE로 IDE를 바꿔보시는 것도 좋은 선택이 될것 같습니다.<br>마지막으로 제가 쓰고 있는 VSCODE 플러그인을 공개합니다. 짜잔~!<br><img src="/blog/2018/11/28/to-vscode-in-2019/mylist.png"></p>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2018/11/28/to-vscode-in-2019/#disqus_thread</comments>
    </item>
    
    <item>
      <title>책을 쓰기전에 내가 이미 알았더라면 좋았을 툴</title>
      <link>http://sculove.github.io/blog/2018/07/07/know-before-you-write-book/</link>
      <guid>http://sculove.github.io/blog/2018/07/07/know-before-you-write-book/</guid>
      <pubDate>Sat, 07 Jul 2018 11:37:09 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;이번으로-2번째-책을-탈고-했다&quot;&gt;&lt;a href=&quot;#이번으로-2번째-책을-탈고-했다&quot; class=&quot;headerlink&quot; title=&quot;이번으로 2번째 책을 탈고 했다.&quot;&gt;&lt;/a&gt;이번으로 2번째 책을 탈고 했다.&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://book.naver.com/bookdb/book_detail.nhn?bid=7434247&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;첫번째 책&lt;/a&gt;은 정말로 얼떨결에 썼던 것같다.&lt;/p&gt;
&lt;p&gt;첫번째 책이 &lt;strong&gt;‘와 내가 저자가 되는거야?’&lt;/strong&gt; 라는 호기심과 영웅 심리(?)로 했었던 것이라면 이번 건은 진짜 써보고 싶어서 쓴 책이다. 그 만큼 시간도 많이 들어간 것 같고 열정도 많이 쏟았던 것 같다.&lt;br&gt;다만 아쉬움이 있다면. 생활고(?)에 힘들어서 책을 쓰는 기간이 너무 늘어났다는 것이다.&lt;br&gt;원래는 7개월 정도에 마무리 하려고 했지만 질질끌다보니 1년이 훌쩍 지나가 버렸다.&lt;br&gt;아마 처음 계획했던 것을 하려고했으면 아마 지금도 못 끝냈을 지도 모른다.&lt;/p&gt;
&lt;p&gt;책을 쓰는 것은 많이 시간이 들고 집필의 압박감에 꽤나 고단하고 피곤한 작업이다.&lt;br&gt;돈을 벌수 있는 수단도 아니다.&lt;/p&gt;
&lt;p&gt;물론, 초급자 대상의 책을 쭉쭉~ 뽑아내면 금전적으로 이득을 볼 수 있겠지만 나 같이 전문적인 기술 서적으로 돈을 번다는 것은 쉬운 일이 아니다.&lt;/p&gt;
&lt;p&gt;특히나 RxJS와 같이 이해하고 어렵고 특수한 분야의 책으로 돈을 벌기는 더더구나 힘들다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="이번으로-2번째-책을-탈고-했다"><a href="#이번으로-2번째-책을-탈고-했다" class="headerlink" title="이번으로 2번째 책을 탈고 했다."></a>이번으로 2번째 책을 탈고 했다.</h2><p><a href="http://book.naver.com/bookdb/book_detail.nhn?bid=7434247" rel="external nofollow noopener noreferrer" target="_blank">첫번째 책</a>은 정말로 얼떨결에 썼던 것같다.</p><p>첫번째 책이 <strong>‘와 내가 저자가 되는거야?’</strong> 라는 호기심과 영웅 심리(?)로 했었던 것이라면 이번 건은 진짜 써보고 싶어서 쓴 책이다. 그 만큼 시간도 많이 들어간 것 같고 열정도 많이 쏟았던 것 같다.<br>다만 아쉬움이 있다면. 생활고(?)에 힘들어서 책을 쓰는 기간이 너무 늘어났다는 것이다.<br>원래는 7개월 정도에 마무리 하려고 했지만 질질끌다보니 1년이 훌쩍 지나가 버렸다.<br>아마 처음 계획했던 것을 하려고했으면 아마 지금도 못 끝냈을 지도 모른다.</p><p>책을 쓰는 것은 많이 시간이 들고 집필의 압박감에 꽤나 고단하고 피곤한 작업이다.<br>돈을 벌수 있는 수단도 아니다.</p><p>물론, 초급자 대상의 책을 쭉쭉~ 뽑아내면 금전적으로 이득을 볼 수 있겠지만 나 같이 전문적인 기술 서적으로 돈을 번다는 것은 쉬운 일이 아니다.</p><p>특히나 RxJS와 같이 이해하고 어렵고 특수한 분야의 책으로 돈을 벌기는 더더구나 힘들다.</p><a id="more"></a><h2 id="그럼-난-왜-책을-썼는가"><a href="#그럼-난-왜-책을-썼는가" class="headerlink" title="그럼 난 왜 책을 썼는가?"></a>그럼 난 왜 책을 썼는가?</h2><p>그러게 왜 썼을까? ㅋㅋ</p><p>우선 이 책을 쓰게 된 계기는</p><h3 id="첫째-RxJS를-내가-더-잘-알고-싶었다"><a href="#첫째-RxJS를-내가-더-잘-알고-싶었다" class="headerlink" title="첫째. RxJS를 내가 더 잘 알고 싶었다."></a>첫째. RxJS를 내가 더 잘 알고 싶었다.</h3><p>강의도 마찬가지이지만 누군가에서 설명하고 가르치기 위해서는 많은 것을 확인해보고 검증해야한다. 더불어 내가 이해하지 않은 내용은 전달 자체를 할 수가 없다. 전달한다고 하더라고 듣고 있는 청자가 바로 눈치 챌 것이다. 그런데 글로 남는 책은 더더욱 그렇다. 사실 더욱 더 치밀하고 꼼꼼하게 확인해봐야한다.</p><h3 id="둘째-아내의-권유로"><a href="#둘째-아내의-권유로" class="headerlink" title="둘째. 아내의 권유로"></a>둘째. 아내의 권유로</h3><p>아내의 권유로 책을 쓰기로 마음을 먹었다. 아내 입장에서는 남편이 책을 쓴 저자라는게 꽤나 흐믓한 일인것 같았다. 아내도 책을 쓰는 시간을 도와준다고 확답(?)까지 했으니 나도 거절할 이유가 별로 없었다.</p><h3 id="셋째-내가-고민한-내용을-책으로-쓰고-싶었다"><a href="#셋째-내가-고민한-내용을-책으로-쓰고-싶었다" class="headerlink" title="셋째. 내가 고민한 내용을 책으로 쓰고 싶었다."></a>셋째. 내가 고민한 내용을 책으로 쓰고 싶었다.</h3><p>첫번째 쓴 책은 내가 <strong>경험한 것</strong>을 주로 썼던 것이라면 이번 책은 <strong>경험과 함께 고민이 함께 녹아들어간 책</strong>이다. RxJS를 비동기 처리의 한 요소로만 바라보는 분들에게 설명을 해주고 싶었고, 내가 개발하면서 느꼈던 고귀함(?)같은 것을 전달해 주고 싶었다.</p><p>암튼 곧 출판을 곧 앞둔 이 시점에서 가장 마음에 드는 것은 이제 집에가서 책을 써야한다는 강박관념이 없어서 너무 좋다. 행복하다. 오히려 뭘해야하지? 라는 공허함도 든다.</p><p>책 쓰기 전에는 유투브를 보면서도 책을 써야한다는 생각에 앉아서 걱정하며 지냈는데 지금은 집에가면 너무 편하다.</p><p>잠시 이야기를 하다보니 내가 이 글을 쓰게된 이유를 망각했다.</p><p>이 글은 내가 책을 쓰기전에 알았더라면 더 좋았을 툴들을 몇가지 이야기해보고자 한다.</p><h2 id="책을-쓰기전에-내가-이미-알았더라면-좋았을-툴"><a href="#책을-쓰기전에-내가-이미-알았더라면-좋았을-툴" class="headerlink" title="책을 쓰기전에 내가 이미 알았더라면 좋았을 툴"></a>책을 쓰기전에 내가 이미 알았더라면 좋았을 툴</h2><h3 id="1-Typora"><a href="#1-Typora" class="headerlink" title="1. Typora"></a>1. Typora</h3><p>글을 쓸 때 주로 마크다운 문서로 작성을 했다. github 나 gitlab에서 MD파일 자체를 바로 불수 있었기에 꽤 편리했다. 하지만, 아쉬웠던 점은 마크다운 문서의 아웃라인이 잘 보이지 않아서 쓴 글을 몇번이고 쳐다보면서 고쳤던 경험이 있다.<br>아마도 <a href="https://typora.io/" rel="external nofollow noopener noreferrer" target="_blank">typora</a>라는 마크업 편집기를 사전에 썼다면 훨씬 유용했을 것 같다.<br>뿐만아니라 word, pdf와 같은 다양한 포맷으로 문서를 만들수 있어서 작성한 글을 다른 플랫폼으로 이전하기가 너~무 편하다.</p><img src="/blog/2018/07/07/know-before-you-write-book/typora.png"><h3 id="2-Google-Docs"><a href="#2-Google-Docs" class="headerlink" title="2. Google Docs"></a>2. Google Docs</h3><p>이번에 베타리더들 대상으로 실시간 리뷰를 받은 적이 있는데 처음에는 github의 PR로 리뷰를 받다가 결국에는 <a href="https://docs.google.com/" rel="external nofollow noopener noreferrer" target="_blank">구글독스</a>를 이용하였다.<br>MS-WORD가 문서 이력을 관리하고 수정 첨부 등이 용이한 반면 온라인 기능을 바로 사용하기는 어렵다. 물론 MSOffice 365를 사용하면 가능하다 하지만, 유료를 굳이 구매할 필요가 있나싶다.</p><p>MSOffice 365같은 기능을 무료로 사용할 수 있는 툴이 있다. 바로 구글 독스이다.<br>구글 독스를 이용하면 실시간 문서의 리뷰가 가능하다. 베타리더의 의견을 받기에는 이것보다 좋은 것은 아직까지 못 본듯하다.</p><img src="/blog/2018/07/07/know-before-you-write-book/google-docs.png"><h3 id="3-gitbook"><a href="#3-gitbook" class="headerlink" title="3. gitbook"></a>3. gitbook</h3><p>초창기에 이것도 한번 써보려고 해봤는데… 포기.</p><p>사실 개인이 책을 쓰는 것이기 때문에 공개를 목적이 아닌 이상 gitbook은 오히려 번거로워서 사용하려다가 말았다. 만약 공개 책을 쓰거나 gitbook 유료 개정이 있다면 gitbook도 나쁘지 않은 선택인 것 같다.<br>지금은 초창기에 썼던 것보다 훨씬 더 괜찮아진 것 같다.</p><img src="/blog/2018/07/07/know-before-you-write-book/gitbook.jpeg"><h3 id="4-Jsfiddle-codepen"><a href="#4-Jsfiddle-codepen" class="headerlink" title="4. Jsfiddle, codepen"></a>4. Jsfiddle, codepen</h3><p>jsfiddle, codepen과 같은 온라인에서 소스 예제를 작성하기 좋은 사이트들이 있다. 처음에 나도 도입하려고 해봤는데 생각만큼 이력관리가 잘 안된다. 그리고 소스 수정하는게 꽤나 번거롭다.</p><p>암튼 이것도… 포기</p><img src="/blog/2018/07/07/know-before-you-write-book/codepen.png"><h2 id="다시-내가-책을-쓴다면…"><a href="#다시-내가-책을-쓴다면…" class="headerlink" title="다시 내가 책을 쓴다면…"></a>다시 내가 책을 쓴다면…</h2><p>와이프랑 아이에게 프로그래밍 가르치는 책을 한번 써보고 싶다는 생각은 있지만… 생각만 있을뿐 다음에 책을 쓸지는 모르겠다.</p><p>암튼, 만약 내가 다시 책을 쓴다면 아마 다음과 같이 작업을 할 것 같다.</p><ol><li>문서<ul><li>목차, 초안은 <strong><u>Typora</u></strong>로 로컬에서 마크다운 문서를 작성한다.</li><li>이때 작성된 문서는 <strong><u>GitHub나 gitlab</u></strong>으로 관리한다.</li><li>1차로 작성이 끝난 문서는 word형태로 변경하여 <strong><u>구글 독스</u></strong>에서 작업한다.</li><li>문서 리뷰가 필요하다면 구글 독스의 공유기능을 이용하여 베타리뷰어의 리뷰를 받는다.</li></ul></li><li>소스<ul><li>온라인 소스 공유공간을 이용하지 않고 로컬에서 자유롭게 수정할수 있도록 작성한다.</li><li><strong><u>GitHub나 gitlab</u></strong>을 이용하여 소스를 관리하고 PR을 통해 코드 리뷰를 받는다.</li></ul></li></ol><p>아니면…</p><p>그냥 돈을 주고 <strong><u>gitbook</u></strong>을 써볼 듯 하다. ^^;</p>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2018/07/07/know-before-you-write-book/#disqus_thread</comments>
    </item>
    
    <item>
      <title>아~ 드디어 탈고!</title>
      <link>http://sculove.github.io/blog/2018/04/11/complete-book/</link>
      <guid>http://sculove.github.io/blog/2018/04/11/complete-book/</guid>
      <pubDate>Tue, 10 Apr 2018 15:01:27 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;아~ 드디어 원고를 탈고했다.&lt;/p&gt;
&lt;img src=&quot;/blog/2018/04/11/complete-book/review.jpg&quot;&gt;
&lt;p&gt;인쇄를 했더니 A4 한박스가 훌러덩 다 나갔다.&lt;br&gt;많은 양을 써놓은게 뿌듯하기도 했지만 한 편으로는 무
        
      
      </description>
      
      <content:encoded><![CDATA[<p>아~ 드디어 원고를 탈고했다.</p><img src="/blog/2018/04/11/complete-book/review.jpg"><p>인쇄를 했더니 A4 한박스가 훌러덩 다 나갔다.<br>많은 양을 써놓은게 뿌듯하기도 했지만 한 편으로는 무슨 부귀영화를 누리려고 이렇게까지 살았나? 라는 생각도 들었다.</p><p>사실 책은 다 썼지만 아직 제목을 정하지는 못했다. 예제 위주로 RxJS를 익힐 수 있도록 작성한 책이긴 한데… 뭔가 임팩트 있는 제목을 아직까지 못찾았다.<br>이러다보면 결국 출판사에서 제안하는 이름을 선택 택하겠지 ^^;</p><p>책을 읽는 사람이 읽기만 해도 이해를 쉽게 할 수 있도록 가급적이면 상세히 쓰려고 노력했지만 잘 녹아들어갔는지는 원고 교정이 끝난 이후에 피드백을 좀 받아봐야겠다.</p><p>아~ 사실 더 다루고 싶은 내용도 정말 많았다. 하지만 욕심을 많이 버렸다.<br>RxJS 6.0이 나와서 전체적으로 소스도 바꾸고 하다보니 욕심부리다 보면 올해도 책을 못낼 것 같은 생각이 들어 마무리를 지었다.</p><p>담에 기회가 되면 더 많은 내용을 다루는 것을 숙제로 남기고… 그동안 하고싶었던 일들을 좀 여유롭게 해봐야겠다.</p><p>마지막으로 지금까지 묵묵히 바쁜척하는 남편을 도와준 우리 와이프와 아이들에게 마지막으로 감사를 보낸다.<br>이제 넷플릭스로 미드도 보고 게임기로 게임좀 원없이 해보자 ㅋㅋ</p>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2018/04/11/complete-book/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Typescript로 부터 얻은 것과 잃은 것</title>
      <link>http://sculove.github.io/blog/2018/01/18/typescript-axes/</link>
      <guid>http://sculove.github.io/blog/2018/01/18/typescript-axes/</guid>
      <pubDate>Thu, 18 Jan 2018 10:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;Typescript로-부터-얻은-것과-잃은-것&quot;&gt;&lt;a href=&quot;#Typescript로-부터-얻은-것과-잃은-것&quot; class=&quot;headerlink&quot; title=&quot;Typescript로 부터 얻은 것과 잃은 것&quot;&gt;&lt;/a&gt;Typescript로
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Typescript로-부터-얻은-것과-잃은-것"><a href="#Typescript로-부터-얻은-것과-잃은-것" class="headerlink" title="Typescript로 부터 얻은 것과 잃은 것"></a>Typescript로 부터 얻은 것과 잃은 것</h3><h4 id="eg-Axes-개발-경험기"><a href="#eg-Axes-개발-경험기" class="headerlink" title="eg.Axes 개발 경험기"></a><a href="https://github.com/naver/egjs-axes" rel="external nofollow noopener noreferrer" target="_blank">eg.Axes</a> 개발 경험기</h4><img src="/blog/2018/01/18/typescript-axes/typescript.png"><p>Typescript는 자바스크립트의 자유로움 속에서 타입의 안정성을 함께 추구할수 있는 언어입니다.<br>이 발표는 Typescript를 적용하면서 느낀 좋은 점과 나쁜점을 개인적인 관점에서 살펴봅니다.</p><h4 id="발표-자료"><a href="#발표-자료" class="headerlink" title="발표 자료"></a>발표 자료</h4><iframe src="http://sculove.github.io/slides/typescript_axes/" width="100%" height="500px" frameborder="0" allowfullscreen></iframe><p>자료 : <a href="http://sculove.github.io/slides/typescript_axes/">http://sculove.github.io/slides/typescript_axes/</a></p><h4 id="동영상"><a href="#동영상" class="headerlink" title="동영상"></a>동영상</h4><div class="video-container"><iframe src="//www.youtube.com/embed/3M92klkicVc" frameborder="0" allowfullscreen></iframe></div><h4 id="발표한-행사-정보"><a href="#발표한-행사-정보" class="headerlink" title="발표한 행사 정보"></a>발표한 행사 정보</h4><p>[2018.01.18] TypeScript Korea Meetup 2018-1 <a href="https://www.tumblbug.com/20180118" rel="external nofollow noopener noreferrer" target="_blank">https://www.tumblbug.com/20180118</a></p>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2018/01/18/typescript-axes/#disqus_thread</comments>
    </item>
    
    <item>
      <title>자바스크립트 비동기 처리 과정과 RxJS Scheduler</title>
      <link>http://sculove.github.io/blog/2018/01/18/javascriptflow/</link>
      <guid>http://sculove.github.io/blog/2018/01/18/javascriptflow/</guid>
      <pubDate>Wed, 17 Jan 2018 15:58:15 GMT</pubDate>
      <description>
      
        &lt;p&gt;오늘 소개할 부분은 작성 중인 책의 “부록” 중 일부이다.&lt;br&gt;이 장에서는 RxJS Scheduler를 잘 사용하기 위해서 이해해야할 &lt;code&gt;자바스크립트 비동기 처리 과정&lt;/code&gt;을 살펴본다.&lt;/p&gt;
&lt;p&gt;RxJS를 모르는 사람이라도 &lt;code&gt;자바스크립트의 비동기 처리과정&lt;/code&gt;을 이해하면 자바스크립트를 개발하는데 정말 많은 도움을 준다.&lt;br&gt;더 자세한 내용은 다음 URL을 참고하여 꼭! 읽어보기 바란다&lt;/p&gt;
&lt;h4 id=&quot;참고-URL&quot;&gt;&lt;a href=&quot;#참고-URL&quot; class=&quot;headerlink&quot; title=&quot;참고 URL&quot;&gt;&lt;/a&gt;참고 URL&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.risingstack.com/writing-a-javascript-framework-execution-timing-beyond-settimeout/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://blog.risingstack.com/writing-a-javascript-framework-execution-timing-beyond-settimeout/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;부록-RxJS-Scheduler와-자바스크립트-비동기-처리-과정의-이해&quot;&gt;&lt;a href=&quot;#부록-RxJS-Scheduler와-자바스크립트-비동기-처리-과정의-이해&quot; class=&quot;headerlink&quot; title=&quot;부록. RxJS Scheduler와 자바스크립트 비동기 처리 과정의 이해&quot;&gt;&lt;/a&gt;부록. RxJS Scheduler와 자바스크립트 비동기 처리 과정의 이해&lt;/h1&gt;&lt;p&gt;RxJS Scheduler는 RxJS에서 자바스크립트의 비동기 작업을 효과적으로 처리할수 있도록 도와주는 역할을 한다.&lt;br&gt;따라서, RxJS Scheduler를 잘 활용하기 위해서는 기본적으로 &lt;code&gt;자바스크립트 엔진이 어떻게 비동기 작업을 처리&lt;/code&gt;하는 지를 알면 RxJS Scheduler를 사용하는데 많은 도움이 된다.&lt;/p&gt;
&lt;p&gt;이 장에서는 자바스크립트 엔진이 어떻게 비동기 작업을 처리하는 지를 살펴보고, 각 비동기 작업에 해당되는 RxJS scheduler는 어떤 것이 있는지 살펴보기로 하자.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>오늘 소개할 부분은 작성 중인 책의 “부록” 중 일부이다.<br>이 장에서는 RxJS Scheduler를 잘 사용하기 위해서 이해해야할 <code>자바스크립트 비동기 처리 과정</code>을 살펴본다.</p><p>RxJS를 모르는 사람이라도 <code>자바스크립트의 비동기 처리과정</code>을 이해하면 자바스크립트를 개발하는데 정말 많은 도움을 준다.<br>더 자세한 내용은 다음 URL을 참고하여 꼭! 읽어보기 바란다</p><h4 id="참고-URL"><a href="#참고-URL" class="headerlink" title="참고 URL"></a>참고 URL</h4><ul><li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" rel="external nofollow noopener noreferrer" target="_blank">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a></li><li><a href="https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5" rel="external nofollow noopener noreferrer" target="_blank">https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5</a></li><li><a href="https://blog.risingstack.com/writing-a-javascript-framework-execution-timing-beyond-settimeout/" rel="external nofollow noopener noreferrer" target="_blank">https://blog.risingstack.com/writing-a-javascript-framework-execution-timing-beyond-settimeout/</a></li></ul><hr><h1 id="부록-RxJS-Scheduler와-자바스크립트-비동기-처리-과정의-이해"><a href="#부록-RxJS-Scheduler와-자바스크립트-비동기-처리-과정의-이해" class="headerlink" title="부록. RxJS Scheduler와 자바스크립트 비동기 처리 과정의 이해"></a>부록. RxJS Scheduler와 자바스크립트 비동기 처리 과정의 이해</h1><p>RxJS Scheduler는 RxJS에서 자바스크립트의 비동기 작업을 효과적으로 처리할수 있도록 도와주는 역할을 한다.<br>따라서, RxJS Scheduler를 잘 활용하기 위해서는 기본적으로 <code>자바스크립트 엔진이 어떻게 비동기 작업을 처리</code>하는 지를 알면 RxJS Scheduler를 사용하는데 많은 도움이 된다.</p><p>이 장에서는 자바스크립트 엔진이 어떻게 비동기 작업을 처리하는 지를 살펴보고, 각 비동기 작업에 해당되는 RxJS scheduler는 어떤 것이 있는지 살펴보기로 하자.</p><a id="more"></a><h2 id="자바스크립트-엔진"><a href="#자바스크립트-엔진" class="headerlink" title="자바스크립트 엔진"></a>자바스크립트 엔진</h2><p>자바스크립트 엔진은 기본적으로 하나의 쓰레드에서 동작한다. 하나의 쓰레드를 가지고 있다는 것은 하나의 stack을 가지고 있다는 의미와 같고, 하나의 stack이 있다는 의미는 <code>동시에 단 하나의 작업만을 할 수 있다</code>는 의미이다.</p><p>자바스크립트 엔진은 하나의 코드 조각을 하나씩 실행하는 일을 하고, 비동기적으로 이벤트를 처리하거나 Ajax 통신을 하는 작업은 사실상 Web API에서 모두 처리된다.</p><img src="/blog/2018/01/18/javascriptflow/browser-structure.png"><p>자바스크립트가 동시에 단 하나의 작업만을 한다는데 어떻게 여러가지 작업을 비동기로 작업을 할수 있을까?<br>그 비밀은 <code>바로 Event Loop와 Queue에 있다.</code></p><h2 id="Event-Loop-와-Queue"><a href="#Event-Loop-와-Queue" class="headerlink" title="Event Loop 와 Queue"></a>Event Loop 와 Queue</h2><p>Event Loop에서 Loop의 사전적인 의미는 ‘반복. 순환’이다. Event Loop는 사전적인 의미처럼 계속 반복해서 call stack과 queue 사이의 작업들을 확인하고, call stack이 비워있는 경우 queue에서 작업을 꺼내어 call stack에 넣는다.<br>자바스크립트는 이 Event Loop와 Queue들을 이용하여 비동기 작업을 수행한다.<br>직접적인 작업은 Web API에서 처리되고, 그 작업들이 완료되면 요청시 등록했던 callback이 queue에 등록된다.<br>Event Loop는 이 작업들을 Queue에서 꺼내어 처리한다.<br>Event Loop는 stack에 처리할 작업이 없을 경우 우선적으로 microtask queue를 확인한다. microtask queue에 작업이 있다면 microtask에 있는 작업을 꺼내서 call stack에 넣는다. 만약 microtask의 queue가 비어서 더 이상 처리할 작업이 없으면 이때 task queue를 확인한다. task queue의 작업도 꺼내서 call stack에 넣는다.<br>이렇게 Event Loop와 Queue는 자바스크립트 엔진이 하나의 코드 조각을 하나씩 처리할 수 있도록 작업을 스케줄하는 동시에 이러한 이유로 우리는 자바스크립트에서 비동기 작업을 할수 있도록 해준다.</p><h2 id="자바스크립트-처리-과정"><a href="#자바스크립트-처리-과정" class="headerlink" title="자바스크립트 처리 과정"></a>자바스크립트 처리 과정</h2><p>다음 코드를 바탕으로 자바스크립트 처리과정을 살펴보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"script start"</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"setTimeout"</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">requestAnimationFrame(<span class="function"><span class="keyword">function</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"requestAnimationFrame"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script end"</span>);</span><br></pre></td></tr></table></figure><p>위의 코드를 실행하면 다음과 같은 결과 화면을 얻을 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">requestAnimationFrame</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure><p>어떻게 이런 결과가 나왔을까?</p><p>간단해 보이는 이 코드는 실제 다음과 같이 처리된다.</p><ol><li>‘script 실행 작업’이 stack에 등록된다.</li><li>console.log(‘script start’)가 처리된다.</li><li>setTimeout 작업이 stack에 등록되고, Web API에게 setTimeout을 요청한다. 이때 setTimeout의 callback 함수를 함께 전달한다. 요청 이후 stack에 있는 setTimeout 작업은 제거된다.<img src="/blog/2018/01/18/javascriptflow/step1.png"></li><li>Web API는 setTimeout 작업(0초 후)이 완료되면 setTimeout callback 함수를 task queue에 등록한다.<img src="/blog/2018/01/18/javascriptflow/step2.png"></li><li>Promise 작업이 stack에 등록되고, Web API에게 Promise 작업을 요청한다. 이때 Promise.then의 callback 함수를 함께 전달한다. 요청 이후 stack에 있는 Promise 작업은 제거된다.<img src="/blog/2018/01/18/javascriptflow/step3.png"></li><li>Web API는 Promise 작업이 완료되면 Promise.then의 callback 함수를 microtask queue에 등록한다.<img src="/blog/2018/01/18/javascriptflow/step4.png"></li><li>requestAnimation 작업이 stack에 등록되고, Web API에게 requestAnimation을 요청한다. 이때 requestAnimation의 callback 함수를 함께 전달한다. 요청 이후 stack에 있는 requestAnimation 작업은 제거된다.<img src="/blog/2018/01/18/javascriptflow/step5.png"></li><li>Web API는 requestAnimation의 callback 함수를 animation frame에 등록한다.<img src="/blog/2018/01/18/javascriptflow/step6.png"></li><li>console.log(‘script end’)가 처리된다.</li><li>‘script 실행 작업’이 완료되어 stack에서 제거된다.</li><li>stack이 비워있어서 microtask queue에 등록된 Promise.then 의 callback 함수를 stack에 등록한다.<img src="/blog/2018/01/18/javascriptflow/promise-step1.png"></li><li>첫번째 Promise.then의 callback 함수가 실행되어 내부의 console.log(‘promise1’)가 처리된다.</li><li>첫번째 Promise.then 다음에 Promise.then이 있다면 다음 Promise.then의 callback 함수를 microtask queue에 등록한다.<img src="/blog/2018/01/18/javascriptflow/promise-step2.png"></li><li>stack 에서 첫번째 Promise.then의 callback 함수를 제거하고 microtask queue에서 첫번째 Promise.then의 callback 함수를 제거한다.</li><li>두번째 Promise.then의 callback 함수를 stack에 등록한다.<img src="/blog/2018/01/18/javascriptflow/promise-step3.png"></li><li>두번째 Promise.then의 callback 함수가 실행되어 내부의 console.log(‘promise2’)가 처리된다.</li><li>stack 에서 두번째 Promise.then의 callback 함수를 제거한다.</li><li>microtask 작업이 완료되면 animation frame에 등록된 callback 함수를 꺼내 실행한다.<img src="/blog/2018/01/18/javascriptflow/raf-step.png"></li><li>이후 브라우저는 랜더링 작업을 하여 UI를 업데이트한다.</li><li>stack과 microtask queue가 비워있어서 task queue에 등록된 callback 함수를 꺼내 stack에 등록한다.<img src="/blog/2018/01/18/javascriptflow/task-step.png"></li><li>setTimeout의 callback가 실행되어 내부의 console.log(‘setTimeout’)이 처리된다.</li><li>setTimeout의 callback 함수 실행이 완료되면 stack에서 제거된다.</li></ol><blockquote><p>처리 과정에 대한 자세한 사항은 다음 링크를 참조하기 바란다.<br><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" rel="external nofollow noopener noreferrer" target="_blank">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a></p></blockquote><p>꽤나 복잡한 과정이지만 꼭! 명심해야할 것이 있다.</p><ul><li>첫째. 비동기 작업으로 등록되는 작업은 task와 microtask. 그리고 animationFrame 작업으로 구분된다.</li><li>둘째. microtask는 task보다 먼저 작업이 처리된다.</li><li>셋째. microtask가 처리된 이후 requestAnimationFrame이 호출되고 이후 브라우저 랜더링이 발생한다.</li></ul><h2 id="RxJS-Scheduler와-자바스크립트-비동기-작업의-종류"><a href="#RxJS-Scheduler와-자바스크립트-비동기-작업의-종류" class="headerlink" title="RxJS Scheduler와 자바스크립트 비동기 작업의 종류"></a>RxJS Scheduler와 자바스크립트 비동기 작업의 종류</h2><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>task는 비동기 작업이 순차적으로 수행될 수 있도록 보장하는 형태의 작업 유형이다. 여기서 순차적으로 보장한다는 의미는 작업이 <code>예약되어있는 순서를 보장한다는 의미</code>이다. task 다음에 바로 다음 task가 실행된다는 의미는 아니다. 위의 예처럼 task 사이에는 브라우저 랜더링과 같은 작업이 일어 날 수 있기 때문이다.<br>RxJS에서 task와 같은 형태의 작업을 하려면 <a href="http://reactivex.io/rxjs/variable/index.html#static-variable-async" rel="external nofollow noopener noreferrer" target="_blank">Rx.Scheduler.async</a> 스케줄러를 이용하여 구현할 수 있다.<br>실제 Rx.Scheduler.async는 setInterval을 이용하여 구현되어 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected requestAsyncId(scheduler: AsyncScheduler, id?: any, <span class="attr">delay</span>: number = <span class="number">0</span>): any &#123;</span><br><span class="line">  <span class="keyword">return</span> root.setInterval(scheduler.flush.bind(scheduler, <span class="keyword">this</span>), delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Microtask"><a href="#Microtask" class="headerlink" title="Microtask"></a>Microtask</h3><p>microtask는 비동기 작업이 현재 실행되는 스크립트 바로 다음에 일어나는 작업이다. 따라서 task보다 항상 먼저 실행된다.<br>microtask로는 <a href="https://developer.mozilla.org/ko/docs/Web/API/MutationObserver" rel="external nofollow noopener noreferrer" target="_blank">MutationObserver</a>와 Promise가 이에 해당된다.<br>RxJS에서 microtask와 같은 형태의 작업을 하려면 <a href="http://reactivex.io/rxjs/variable/index.html#static-variable-asap" rel="external nofollow noopener noreferrer" target="_blank">Rx.Scheduler.asap</a> 스케줄러를 이용하여 구현할 수 있다.<br>실제 Rx.Scheduler.asap은 Promise로 구현되어 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected requestAsyncId(scheduler: AsapScheduler, id?: any, <span class="attr">delay</span>: number = <span class="number">0</span>): any &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(</span><br><span class="line">      scheduler.flush.bind(scheduler, <span class="literal">null</span>)</span><br><span class="line">    ));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">setImmediate(cb: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>): number &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> runIfPresent(handle));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2018/01/18/javascriptflow/#disqus_thread</comments>
    </item>
    
    <item>
      <title>VSCODE Extension 만든 삽질기</title>
      <link>http://sculove.github.io/blog/2017/12/27/createvsextension/</link>
      <guid>http://sculove.github.io/blog/2017/12/27/createvsextension/</guid>
      <pubDate>Wed, 27 Dec 2017 08:47:32 GMT</pubDate>
      <description>
      
        &lt;p&gt;MS에 기여한게 없어서 뭔가 해봐야겠다는 생각에&lt;br&gt;그동안 만들고 싶었던 vscode extentions을 만들어 봤다.&lt;/p&gt;
&lt;img src=&quot;/blog/2017/12/27/createvsextension/translator.png&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=sculove.translator&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://marketplace.visualstudio.com/items?itemName=sculove.translator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;한글을 번역할 때는 번역된 텍스트에 적용할 수 있는 접두사가 적용된 메서드의 이름을 보여주는 기능도 넣었다.&lt;/p&gt;
&lt;img src=&quot;/blog/2017/12/27/createvsextension/korToEn.gif&quot;&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>MS에 기여한게 없어서 뭔가 해봐야겠다는 생각에<br>그동안 만들고 싶었던 vscode extentions을 만들어 봤다.</p><img src="/blog/2017/12/27/createvsextension/translator.png"><p><a href="https://marketplace.visualstudio.com/items?itemName=sculove.translator" rel="external nofollow noopener noreferrer" target="_blank">https://marketplace.visualstudio.com/items?itemName=sculove.translator</a></p><p>한글을 번역할 때는 번역된 텍스트에 적용할 수 있는 접두사가 적용된 메서드의 이름을 보여주는 기능도 넣었다.</p><img src="/blog/2017/12/27/createvsextension/korToEn.gif"><a id="more"></a><h2 id="왜-만들었나"><a href="#왜-만들었나" class="headerlink" title="왜 만들었나?"></a>왜 만들었나?</h2><p>김지한(laziel)군과 윤종문(문)군이 이런거 있으면 좋겠다고 이야기해서 만들기 시작하긴 했는데…<br>따지고 보니 내가 더 필요한 것 같았다.</p><p>우리가 개발할 때 항상 켜놓고 보는게 사전과 번역기다.<br>change와 update, alter등 우리말로는 다 <code>변화하다</code>라는 의미인데 실제 영어는 각각이 의미하는 바가 다르다. 따라서 매번 변수명, 메소드명 짓는데 시간을 낭비한다.<br>그때 기분에 따라 또는 떠오르는 것에 따라 정하다보니 나중에 코드를 보면 의미가 불명확해서 내가 봐도 헷갈리게 된다.<br>더군다나 같이 개발하는 사람들또한 헷갈리다보니 나중에 가서는 더.더.더. 헷갈린다.</p><p>그래서 사전을 보거나 번역을 하는데. 이게 의외로 시간이 좀 걸린다.</p><h2 id="VSCode-Extention-구조에-대한-회고"><a href="#VSCode-Extention-구조에-대한-회고" class="headerlink" title="VSCode Extention 구조에 대한 회고"></a>VSCode Extention 구조에 대한 회고</h2><p>사실 만든 코드는 많지 않지만, 우선은 vscode extentions에 대한 학습이 필요했기에 틈틈히 관련 내용을 살펴봤었다.</p><p>MS가 문서화 하나는 정말 잘해 놓은것 같아서 사실 보기에는 꽤 편했다.<br>내가 참조한 문서는 여기 <a href="https://code.visualstudio.com/docs/extensions/overview" rel="external nofollow noopener noreferrer" target="_blank">overview</a> 문서를 시작으로 <a href="https://code.visualstudio.com/docs/extensionAPI/vscode-api" rel="external nofollow noopener noreferrer" target="_blank">vsdoe namespace API</a> 문서까지 봤다.<br>예상대로 vscode의 extension은 command 패턴으로 되어 있어서 커멘트 단위로 짜서 등록을 하고 쓰는 식이 었다.</p><p>약간 특이한 점은 <a href="https://code.visualstudio.com/docs/extensionAPI/extension-points" rel="external nofollow noopener noreferrer" target="_blank">contribute points</a>가 있어서 <code>템플릿 메타 프로그래밍</code>이 가능하다. 정의된 항목에 정의된 정보를 입력하면 코딩이 된다. 이것도 MS가 예전부터 지향했던 방식 중의 하나라 개발하기에는 편했다. 개인적으로는 메타 프로그래밍과 의 적정한 수준을 유지한게 좋았다.</p><p>다음으로 특이한점은 Language Server가 있었다.<br>처음에는 Language Server라 길래 언어작업을 할때 쓰는 것인가로 생각했는데 알고보니 <code>비용이 많이 발생하는 작업을 서버에서 처리 후 VSCode Language Protocol로 전달하는 형태</code>였다.<br>이건 좀 괜찮은 방식인것 같다. 내가 만들 extention과는 관련이 없지만 나중에 좀 복잡한 것 만들때는 한번 만들어봐야겠다.<br><img src="/blog/2017/12/27/createvsextension/extensibility-architecture.png"></p><h2 id="만들면서-내가-한-삽질은"><a href="#만들면서-내가-한-삽질은" class="headerlink" title="만들면서 내가 한 삽질은?"></a>만들면서 내가 한 삽질은?</h2><h3 id="아쉬운-점은-API문서가-좀-빈약했다"><a href="#아쉬운-점은-API문서가-좀-빈약했다" class="headerlink" title="아쉬운 점은 API문서가 좀 빈약했다."></a>아쉬운 점은 API문서가 좀 빈약했다.</h3><p>아마도 typescript를 이용해서 타입 정의와 설명 정도를 뽑았던것 같다.<br>사실 이 정도도 훌륭하지만 간단한 예제코드가 있었으면 더 좋았을것 같다.<br>결국 직접 코딩을 해보면서 확인해 보거나, 그것이 안된다면 github 검색을 이용해서 찾아봤다.<br>github가 의외로 좋은 코드조각들을 보여줬다.</p><img src="/blog/2017/12/27/createvsextension/github-code.png"><h3 id="vscode는…-노드입니다"><a href="#vscode는…-노드입니다" class="headerlink" title="vscode는… 노드입니다."></a>vscode는… 노드입니다.</h3><p>vscode가 electron에서 돌다보니 우선 기본적으로 node 환경이다.<br>브라우저 개발에 익숙하다보니 그냥 브라우저인가 보다 하고 작업하다가 나중에 깨닫게(?) 되서 약간 어이가 없는 삽질을 했다. (Document를 너무 설렁 설렁봤다 ㅠㅠ)<br>사실 이렇게 헷갈린 이유는 extentions이 돌아가는 곳에서 devTool를 볼수 있기 때문이다.</p><img src="/blog/2017/12/27/createvsextension/devtool.png"><p>암튼 이로 인해 브라우저 환경으로 착각하고 fetch API를 써봤지만 안되서 삽질을 좀 했다.<br>devtool에서는 분명 fetch API를 사용할 수 있는데 정작 코드에서는 에러가 나서 난감했다.</p><p>환경이 node라는 것을 알았으나, 처음에 fetch를 사용하고자 했던 마음을 접을 수가 없어서 결국 <a href="https://github.com/matthew-andrews/isomorphic-fetch" rel="external nofollow noopener noreferrer" target="_blank">isomorphic-fetch</a>을 사용했다.<br>나중에 알게된 거지만 <a href="https://www.npmjs.com/package/electron-fetch" rel="external nofollow noopener noreferrer" target="_blank">electron-fetch</a>를 썼으면 더 좋았을 뻔 했다.<br><a href="https://developer.mozilla.org/ko/docs/Web/API/FormData" rel="external nofollow noopener noreferrer" target="_blank">FormData</a>도 있고 여러가지 쓸 수 있어서 좋아보였다.<br>담에 코드 수정할때 함 바꿔봐야겠다.</p><h3 id="아-typescript"><a href="#아-typescript" class="headerlink" title="아~ typescript"></a>아~ typescript</h3><p>typscript 설정에서 좀 해멨던것 같다. 어떻게 보면 이것도 node 환경을 인지못해서 난 불상사지만 아니었다고 해도 좀 헤멜수는 있다.<br>vscode가 만들어 주는 tsconfig.ts는 <code>target</code>이 es6이고, <code>lib</code>도 es6만 명시되어있다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="string">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">        <span class="string">"target"</span>: <span class="string">"es6"</span>,</span><br><span class="line">        <span class="string">"outDir"</span>: <span class="string">"out"</span>,</span><br><span class="line">        <span class="string">"lib"</span>: [</span><br><span class="line">            <span class="string">"es6"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"sourceMap"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"rootDir"</span>: <span class="string">"src"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"exclude"</span>: [</span><br><span class="line">        <span class="string">"node_modules"</span>,</span><br><span class="line">        <span class="string">".vscode-test"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 직접적으로 <code>lib를 지정하면 문제는 딱 지정한 그것만 포함된다.</code><br>lib가 지정되어 있지 않으면 타겟에 따라 기본적으로 추가되는 lib가 다르다.</p><blockquote><p><a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.typescriptlang.org/docs/handbook/compiler-options.html</a></p><ul><li>target ES5인 경우 <code>DOM,ES5,ScriptHost</code>이 자동 추가</li><li>target ES6인 경우 <code>DOM,ES6,DOM.Iterable,ScriptHost</code>이 자동 추가</li></ul></blockquote><p>따라서 DOM 관련된 API를 사용하면 타입 에러가 난다.</p><p>그런데 문제는 fetch API를 쓰려고 DOM을 추가하면 vscode가 바로 반영이 안된다. 자꾸 타입에러가 난다.<br>이때 결론은 <code>vscode를 껐다가 다시 부르면 된다.</code><br>아~ 이것 때문에 잘못 설정한줄 알고 삽질을 많이함 ㅠㅠ</p><h2 id="소감"><a href="#소감" class="headerlink" title="소감?"></a>소감?</h2><p>개발자가 만들기에는 꽤 괜찮은 vscode extentions.<br>생각보다 쉽게 만들수 있었다.<br>좀 아쉬운 점은 custom UI를 만들수가 없다. 그냥 간단한 view를 보여주고 싶은데 사실 관련 API를 찾지 못했다.<br>아마도 정형화된 UI를 제공하기 위한 포석일수도 있을것 같다.<br>그래고 좀 뷰만 잘되는 UI라도 하나 있으면 좋겠다.</p><p>다름에 또 아이디어가 있으면 한번 더 만들어보고 싶다.</p><h2 id="참고한-예제"><a href="#참고한-예제" class="headerlink" title="참고한 예제"></a>참고한 예제</h2><ul><li><a href="https://code.visualstudio.com/docs/extensions/example-word-count" rel="external nofollow noopener noreferrer" target="_blank">https://code.visualstudio.com/docs/extensions/example-word-count</a></li><li><a href="https://github.com/Microsoft/vscode-MDTools" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Microsoft/vscode-MDTools</a> : vscode.window.showQuickPick, QuickPickItem, TextEditor 사용 예</li><li><a href="https://github.com/Microsoft/vscode-extension-samples" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Microsoft/vscode-extension-samples</a></li></ul>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2017/12/27/createvsextension/#disqus_thread</comments>
    </item>
    
    <item>
      <title>React로 레거시(?) 코드 랩핑하기</title>
      <link>http://sculove.github.io/blog/2017/11/21/wrappingReact/</link>
      <guid>http://sculove.github.io/blog/2017/11/21/wrappingReact/</guid>
      <pubDate>Tue, 21 Nov 2017 14:41:50 GMT</pubDate>
      <description>
      
        &lt;p&gt;기존에 작성한 또는 DOM 기반으로 작성한 코드를 React나 Angular, Vue와 같은 프레임워크에서 사용하고 싶은 경우가 많다.&lt;br&gt;물론, &lt;code&gt;기존 코드의 내용은 하나도 안고치고 사용하고자 한다.&lt;/code&gt;&lt;br&gt;그래서 일반적으로 기존 코드를 사용하는(랩핑) 프레임워크의 컴포넌트를 만들게 된다.&lt;/p&gt;
&lt;p&gt;JQuery plugin을 React로 랩핑하는 것은 &lt;a href=&quot;http://tech.oyster.com/using-react-and-jquery-together/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;아티클&lt;/a&gt;에 나온 것 처럼 의외로 간단하다.&lt;br&gt;하지만, DOM을 주무르듯이 계속 만져(?)주는 컴포넌트인 경우는 처음부터 상태기반으로 컴포넌트를 설계하지 않는 이상 React/Angular/Vue에 맞는 컴포넌트를 맞추는 것은 쉽지 않다.&lt;br&gt;생각 같아서는 native한 코드를 작성해서 사용하고,&lt;br&gt;이를 각 프레임워크 스타일로 랩핑만 하면 간단히 될거라고 생각했는데 만들고 보니 꽤나 부자연스러웠다.&lt;/p&gt;
&lt;p&gt;내가 주로 만들고 있는 것들이 UI 컴포넌트인데 복잡한 UI 컴포넌트는 사실 프레임워크와 엮는게 쉽지 않다.&lt;br&gt;지금 작업하고 있는게 &lt;a href=&quot;https://github.com/naver/egjs-infinitegrid&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;InfiniteGrid&lt;/a&gt;라는 컴포넌트이다.&lt;br&gt;이 컴포넌트는 꽤나 빈번하게 DOM을 조작하고 내부적으로 상태를 관리하고 있기 때문에 더욱 그러한 것 같다.&lt;br&gt;이것과 관련해서 했던 &lt;code&gt;삽질&lt;/code&gt;과 약간의 &lt;code&gt;꽁수&lt;/code&gt;를 찾게 되어 몇자 끄적여 본다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>기존에 작성한 또는 DOM 기반으로 작성한 코드를 React나 Angular, Vue와 같은 프레임워크에서 사용하고 싶은 경우가 많다.<br>물론, <code>기존 코드의 내용은 하나도 안고치고 사용하고자 한다.</code><br>그래서 일반적으로 기존 코드를 사용하는(랩핑) 프레임워크의 컴포넌트를 만들게 된다.</p><p>JQuery plugin을 React로 랩핑하는 것은 <a href="http://tech.oyster.com/using-react-and-jquery-together/" rel="external nofollow noopener noreferrer" target="_blank">아티클</a>에 나온 것 처럼 의외로 간단하다.<br>하지만, DOM을 주무르듯이 계속 만져(?)주는 컴포넌트인 경우는 처음부터 상태기반으로 컴포넌트를 설계하지 않는 이상 React/Angular/Vue에 맞는 컴포넌트를 맞추는 것은 쉽지 않다.<br>생각 같아서는 native한 코드를 작성해서 사용하고,<br>이를 각 프레임워크 스타일로 랩핑만 하면 간단히 될거라고 생각했는데 만들고 보니 꽤나 부자연스러웠다.</p><p>내가 주로 만들고 있는 것들이 UI 컴포넌트인데 복잡한 UI 컴포넌트는 사실 프레임워크와 엮는게 쉽지 않다.<br>지금 작업하고 있는게 <a href="https://github.com/naver/egjs-infinitegrid" rel="external nofollow noopener noreferrer" target="_blank">InfiniteGrid</a>라는 컴포넌트이다.<br>이 컴포넌트는 꽤나 빈번하게 DOM을 조작하고 내부적으로 상태를 관리하고 있기 때문에 더욱 그러한 것 같다.<br>이것과 관련해서 했던 <code>삽질</code>과 약간의 <code>꽁수</code>를 찾게 되어 몇자 끄적여 본다.</p><a id="more"></a><h2 id="InfiniteGrid"><a href="#InfiniteGrid" class="headerlink" title="InfiniteGrid"></a>InfiniteGrid</h2><p>사용자가 스크롤을 계속 할수록 컨텐츠는 무한으로 추가되고,<br>DOM의 개수는 화면사이즈에 맞게 동적으로 DOM을 제거하는 모듈이다.<br>한 마디로 <code>DOM 밑장 빼기</code> 기술이다. 이론은 간단하지만, 실제로는 고민할 거리가 꽤 많다.<br>더군다나 InfiniteGrid는 카드를 다양한 형태로 배치가 가능하니 더 복잡하다.<br>하지만 이 글은 이에 대한 내용이 아니니 과감히 생략하고 본론으로 이야기해보자.</p><p>이 컴포넌트의 형태는 다음과 같다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 특정 엘리먼트 기준으로 인스턴스를 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> infinite = <span class="keyword">new</span> InfinieGrid(element, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이벤트를 통해 특정 시점을 전달받는다.</span></span><br><span class="line">infinite.on(<span class="string">"append"</span>, () =&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메소드를 통해 제어한다.</span></span><br><span class="line">infinite.setLayout(GridLayout, options);</span><br><span class="line">infinite.append(items);</span><br></pre></td></tr></table></figure><blockquote><p>메소드를 통해 인스턴스에 데이터를 전달하거나 얻고, 이벤트를 통해 시점을 전달받는다.<br>인스턴스를 생성할 때는 옵션을 받아 제어할 정보를 전달받는다.</p></blockquote><p>React는 상위컴포넌트에서 하위컴포넌트로 데이터를 prop를 통해 단방향으로 전달하기 때문에 다음과 같이 간단한 형태의 React Component를 만들 수 있다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;InfiniteGrid</span><br><span class="line">  layout=&#123;&#123; <span class="attr">class</span>: GridLayout, <span class="attr">options</span>: &#123; <span class="attr">margin</span>: <span class="number">10</span> &#125; &#125;&#125;</span><br><span class="line">  options=&#123;&#123; <span class="attr">isOverflowScroll</span>: <span class="literal">true</span> &#125;&#125;</span><br><span class="line">  onAppend=&#123;<span class="keyword">this</span>.onAppend.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">  append=&#123;<span class="keyword">this</span>.state.items&#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>옵션(options)과 메소드(append), 이벤트(OnAppend) 모두 prop로 전달해주면 된다.<br>이벤트는 핸들러에서 <code>setState</code>를 이용하여 상태를 다시 상위로 전파 시키면 양방향으로 데이터 전달이 가능하다.</p><p>하지만 문제는 React는 prop가 변경되거나 내부 state가 변경되면 <code>다시 그린다(물론 비교는 한다)</code>는 것이다.<br>애써 DOM을 순환형태로 구성하면 다시 그려버리는 것이다. ㅠㅠ</p><h3 id="첫번째-꽁수-React-DOM-처리는-내가할께"><a href="#첫번째-꽁수-React-DOM-처리는-내가할께" class="headerlink" title="첫번째 꽁수! React. DOM 처리는 내가할께."></a>첫번째 꽁수! React. DOM 처리는 내가할께.</h3><p>React 컴포넌트는 라이프 사이클이 있어서 초기에 render 함수가 호출 된 이후, prop나 state가 변경되면 shouldComponentUpdate가 발생하고 그 반환값이 <code>true</code>이면 render를 호출한다.</p><img src="/blog/2017/11/21/wrappingReact/react-lifecycle.png"><p>이렇게 DOM을 React Component가 아닌 내부(egjs의 infiniteGrid)에서 다룬다면, shouldComponentUpdate의 반환값을 <code>false</code>로 바꾸면 초기 로딩 이후 render를 호출하지 않는다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React는 껍데기일뿐 DOM을 그리는 것은 infiniteGrid가 직접 그리게 된다.<br>으하하하~!</p><h3 id="두번째-꽁수-React-컴포넌트도-마크업으로-뿅"><a href="#두번째-꽁수-React-컴포넌트도-마크업으로-뿅" class="headerlink" title="두번째 꽁수! React 컴포넌트도 마크업으로 뿅!"></a>두번째 꽁수! React 컴포넌트도 마크업으로 뿅!</h3><p>native로 작성한 infiniteGrid 코드에서는 append나 prepend를 이용하여 <code>HTML string</code>이나 <code>HTMLElement 배열</code>, 또는 <code>jQuery 인스턴스</code>를 데이터로 받는다.<br><a href="https://naver.github.io/egjs-infinitegrid/release/latest/doc/eg.InfiniteGrid.html#append" rel="external nofollow noopener noreferrer" target="_blank">https://naver.github.io/egjs-infinitegrid/release/latest/doc/eg.InfiniteGrid.html#append</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infnite.append([<span class="string">"&lt;div&gt;아이템1&lt;/div&gt;"</span>, <span class="string">"&lt;div&gt;아이템2&lt;/div&gt;"</span>]);</span><br></pre></td></tr></table></figure><p>하지만, React에서는 가급적이면 React 컴포넌트를 아이템으로 받고자 한다.<br>React 컴포넌트를 아이템으로 사용하기 위해서는 내부 코드를 바꾸고 React 컴포넌트 여부를 파악 후에 별도로 render를 부르고, 어쩌고 저쩌고 하면…된다.</p><h4 id="그런데-기존-코드를-건드리지-않고-할-수-있는-방법이-있을까"><a href="#그런데-기존-코드를-건드리지-않고-할-수-있는-방법이-있을까" class="headerlink" title="그런데 기존 코드를 건드리지 않고 할 수 있는 방법이 있을까?"></a>그런데 기존 코드를 건드리지 않고 할 수 있는 방법이 있을까?</h4><p>여기서 찾은 두번째 꽁수는 React 컴포넌트를 받아서 <code>string 배열</code>로 만드는 방법이다.<br>가장 쉬운 방법은 <a href="https://reactjs.org/docs/react-dom-server.html#rendertostaticmarkup" rel="external nofollow noopener noreferrer" target="_blank">ReactDOMServer.renderToStaticMarkup</a>를 이용하여 React 컴포넌트를 string 형태로 만들 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stringInArray = items.map(<span class="function"><span class="params">v</span> =&gt;</span> ReactDOMServer.renderToStaticMarkup(v));</span><br></pre></td></tr></table></figure><p>야호! 이제 React 컴포넌트도 사용할수 있게 되었다.</p><h3 id="랩핑의-한계"><a href="#랩핑의-한계" class="headerlink" title="랩핑의 한계"></a>랩핑의 한계</h3><h4 id="껍데기만-React-컴포넌트인-아이템들"><a href="#껍데기만-React-컴포넌트인-아이템들" class="headerlink" title="껍데기만 React 컴포넌트인 아이템들"></a>껍데기만 React 컴포넌트인 아이템들</h4><p>하지만. 이렇게 만들면 문제는 <code>ReactDOMServer.renderToStaticMarkup</code> 함수에 의해 변경된 React 컴포넌트는 string으로만 변경되기 때문에 해당 React 컴포넌트에서 처리한 이벤트 핸들러 같은 것은 사라져 버린다. ㅠㅠ<br>실무에서는 아이템 상위 요소인 InfiniteGrid에 click 이벤트를 delegate해서 처리하긴 했지만…<br>꽤나 찝찝하다. 쩝쩝.</p><h4 id="내부에서-상태관리를-하는-경우라면…-뭐…-방법이-없네"><a href="#내부에서-상태관리를-하는-경우라면…-뭐…-방법이-없네" class="headerlink" title="내부에서 상태관리를 하는 경우라면… 뭐… 방법이 없네."></a>내부에서 상태관리를 하는 경우라면… 뭐… 방법이 없네.</h4><p>앞에서 DOM 관리를 native infiniteGrid에서 하기 위해서는 shouldComponentUpdate로 render를 제어 할수 있다.<br>하지만, <code>내부에서 상태관리를 하는 경우에 대해서는 마땅한 방법이 없다.</code><br>native infiniteGrid도 내부에서 자체적으로 2개의 상태를 관리한다. 실제 리스트의 내용과 화면에 보여지는 일정한 개수의 리스트를 가지고 있다. 이를 고치려면 근본적으로 infiniteGrid의 상태를 외부에서 주입하는 방식으로 변경해야만 한다.<br>infiniteGrid와 같이 append, prepend와 같은 메소드가 아니라 항상 상태에 따라 데이터가 변경될 수 있도록 변경해야한다.<br>그렇지 않는다면, 궁극적으로 상태는 React로 랩핑한 컴포넌트와 랩핑된 native 컴포넌트 둘 다 가지고 있게 될 뿐만아니라 상태 변경 상태에 대한 별도의 sync 작업도 해주어야한다.</p><p>만약 상태값을 전달하지 않고 append/prepnd와 같은 메소드의 인자로 데이터를 전달하는 방식으로 개발을 한다면 <code>외부에서 변경여부에 따라 변경된 부분(추가할거나 삭제할것)을 구분해서 랩핑한 react 컴포넌트에 전달해야만 한다.</code><br>react스럽지 않은 부자연스러움이 아주 많~이 느껴진다 ㅠㅠ</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(&#123;append&#125;) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 랩핑된 컴포넌트의 append prop로 변경될(추가될) 아이템만을 넘겨주어야한다.</span></span><br><span class="line">  <span class="keyword">const</span> elements = append.map(<span class="function"><span class="params">v</span> =&gt;</span> ReactDOMServer.renderToStaticMarkup(v));</span><br><span class="line">  <span class="keyword">this</span>._instance.append(elements);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><p>이 글을 쓴 진짜 이유는 나같은 사람이 발생하지 않길 바라는 의미이다.<br>기존의 DOM 제어 방식의 개발을 단순히 스타일만 바꾼다고 각 프레임워크에 맞는 컴포넌트가 되지는 않는다.<br>간단한 기능이라면 위에서 언급한 <code>꽁수</code> 들로 랩핑만으로 충분하겠지만.<br>꽁수는 꽁수일뿐. 해결책은 아니다.</p><h4 id="내부적으로-상태를-관리하는-native-컴포넌트라면-랩핑보다는-state에-적합한-구조로-재개발을-하는게-장기적으로-더-좋은-결과를-얻을수-있을것-같다"><a href="#내부적으로-상태를-관리하는-native-컴포넌트라면-랩핑보다는-state에-적합한-구조로-재개발을-하는게-장기적으로-더-좋은-결과를-얻을수-있을것-같다" class="headerlink" title="내부적으로 상태를 관리하는 native 컴포넌트라면 랩핑보다는 state에 적합한 구조로 재개발을 하는게 장기적으로 더 좋은 결과를 얻을수 있을것 같다."></a>내부적으로 상태를 관리하는 native 컴포넌트라면 랩핑보다는 state에 적합한 구조로 재개발을 하는게 장기적으로 더 좋은 결과를 얻을수 있을것 같다.</h4><blockquote><p>참고: 개인적으로는 Angular를 기반으로 이야기하고 싶지만, 현실은 React를 더 많이 사용하기에 React를 만들게 되었다. 내가 React를 만들면서 이런 고민을 하게 될 줄이야. ㅜㅜ</p><p>사실 React나 Angular나 Vue나 기능적인 면에서는 다 거기서 거기다. (사실 vue는 잘모름)<br>모두 <code>상태 기반</code>을 지향하기 때문에 만들어가는 방식도 유사하고 데이터 흐름제어도 유사하다.<br>따라서 이 글에서는 React를 기준으로 이야기했지만 다른 프레임워크의 랩핑 컴포넌트를 만들때도 비슷한 고민을 하게된다. 또한 처리 방식도 비슷하다.</p></blockquote>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2017/11/21/wrappingReact/#disqus_thread</comments>
    </item>
    
    <item>
      <title>RxJS 써야겠어요? 안써야겠어요?</title>
      <link>http://sculove.github.io/blog/2017/10/21/shoulduserxjs/</link>
      <guid>http://sculove.github.io/blog/2017/10/21/shoulduserxjs/</guid>
      <pubDate>Sat, 21 Oct 2017 09:17:07 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/blog/2017/10/21/shoulduserxjs/express.jpg&quot;&gt;
&lt;p&gt;RxJS는 일관된 방식으로 안전하게 데이터 흐름을 처리하는 라이브러리입니다.&lt;br&gt;이 발표는 RxJS가 본질적으로 의미하는 바를 살펴봅니다.&lt;br&gt;더불어 개발자로서 RxJS를 써야할지 안써야할지도 함께 살펴봅니다.&lt;/p&gt;
&lt;h4 id=&quot;발표-자료&quot;&gt;&lt;a href=&quot;#발표-자료&quot; class=&quot;headerlink&quot; title=&quot;발표 자료&quot;&gt;&lt;/a&gt;발표 자료&lt;/h4&gt;&lt;iframe src=&quot;https://sculove.github.io/slides/rxjs/&quot; width=&quot;100%&quot; height=&quot;500px&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;자료 : &lt;a href=&quot;https://sculove.github.io/slides/rxjs/&quot;&gt;https://sculove.github.io/slides/rxjs/&lt;/a&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/blog/2017/10/21/shoulduserxjs/express.jpg"><p>RxJS는 일관된 방식으로 안전하게 데이터 흐름을 처리하는 라이브러리입니다.<br>이 발표는 RxJS가 본질적으로 의미하는 바를 살펴봅니다.<br>더불어 개발자로서 RxJS를 써야할지 안써야할지도 함께 살펴봅니다.</p><h4 id="발표-자료"><a href="#발표-자료" class="headerlink" title="발표 자료"></a>발표 자료</h4><iframe src="https://sculove.github.io/slides/rxjs/" width="100%" height="500px" frameborder="0" allowfullscreen></iframe><p>자료 : <a href="https://sculove.github.io/slides/rxjs/">https://sculove.github.io/slides/rxjs/</a></p><a id="more"></a><h4 id="동영상"><a href="#동영상" class="headerlink" title="동영상"></a>동영상</h4><div class="video-container"><iframe src="//www.youtube.com/embed/2f09-veX4HA" frameborder="0" allowfullscreen></iframe></div><h4 id="발표한-행사-정보"><a href="#발표한-행사-정보" class="headerlink" title="발표한 행사 정보"></a>발표한 행사 정보</h4><p>[2017.10.21] FEConf 2017 <a href="https://2017.feconf.kr/" rel="external nofollow noopener noreferrer" target="_blank">https://2017.feconf.kr/</a></p>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2017/10/21/shoulduserxjs/#disqus_thread</comments>
    </item>
    
    <item>
      <title>RxJS란 무엇인가?</title>
      <link>http://sculove.github.io/blog/2017/10/07/rxjsbook4/</link>
      <guid>http://sculove.github.io/blog/2017/10/07/rxjsbook4/</guid>
      <pubDate>Sat, 07 Oct 2017 06:09:27 GMT</pubDate>
      <description>
      
        &lt;p&gt;오늘 소개할 부분은 작성 중인 책 2부의 개론에 해당하는 내용이다.&lt;br&gt;이 장을 통해 &lt;code&gt;RxJS의 개발과정의 큰 그림&lt;/code&gt;을 다시한번 살펴보기 바란다&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;1부에서는 RxJS의 본질을 알아가기 위해 RxJS가 고민했던 문제들을 살펴보았다. 2부에서부터는 RxJS 라이브러리에 대해 자세히 알아보자. 이 장을 통해서는 RxJS로 간단한 소스를 구현해보면서 RxJS의 사용법을 익혀보도록 하자.&lt;/p&gt;
&lt;h2 id=&quot;RxJS&quot;&gt;&lt;a href=&quot;#RxJS&quot; class=&quot;headerlink&quot; title=&quot;RxJS&quot;&gt;&lt;/a&gt;RxJS&lt;/h2&gt;&lt;p&gt;RxJS의 공식 사이트에서는 RxJS에 대해 다음과 같이 정의하고 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RxJS is a library for composing asynchronous and event-based programs by using observable sequences.&lt;br&gt;RxJS는 Observable를 사용하여 비동기 및 이벤트 기반 프로그램을 작성하기 위한 라이브러리이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1부에서 필자가 정의한 &lt;code&gt;범용적인 데이터 플로우 솔루션&lt;/code&gt;을 지향하는 라이브러리의 국소적인 표현이라고 할수 있다. 특이한 것은 공식 홈페이지에는 RxJS에 대해 &lt;code&gt;이벤트용 lodash 정도라고 생각해라&lt;/code&gt;라는 말도 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Think of RxJS as Lodash for events.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;앞의 용어가 RxJS의 철학에 대한 정의라면, 뒤의 정의는 실제 사용에 대한 정의라고 볼수 있다.&lt;br&gt;RxJS가 어렵다면 지금은 그냥 &lt;code&gt;비동기 Array/Collection 데이터&lt;/code&gt;를 다루는 라이브러리 정도로 생각하고 접근해보자.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>오늘 소개할 부분은 작성 중인 책 2부의 개론에 해당하는 내용이다.<br>이 장을 통해 <code>RxJS의 개발과정의 큰 그림</code>을 다시한번 살펴보기 바란다</p><hr><p>1부에서는 RxJS의 본질을 알아가기 위해 RxJS가 고민했던 문제들을 살펴보았다. 2부에서부터는 RxJS 라이브러리에 대해 자세히 알아보자. 이 장을 통해서는 RxJS로 간단한 소스를 구현해보면서 RxJS의 사용법을 익혀보도록 하자.</p><h2 id="RxJS"><a href="#RxJS" class="headerlink" title="RxJS"></a>RxJS</h2><p>RxJS의 공식 사이트에서는 RxJS에 대해 다음과 같이 정의하고 있다.</p><blockquote><p>RxJS is a library for composing asynchronous and event-based programs by using observable sequences.<br>RxJS는 Observable를 사용하여 비동기 및 이벤트 기반 프로그램을 작성하기 위한 라이브러리이다.</p></blockquote><p>1부에서 필자가 정의한 <code>범용적인 데이터 플로우 솔루션</code>을 지향하는 라이브러리의 국소적인 표현이라고 할수 있다. 특이한 것은 공식 홈페이지에는 RxJS에 대해 <code>이벤트용 lodash 정도라고 생각해라</code>라는 말도 있다.</p><blockquote><p>Think of RxJS as Lodash for events.</p></blockquote><p>앞의 용어가 RxJS의 철학에 대한 정의라면, 뒤의 정의는 실제 사용에 대한 정의라고 볼수 있다.<br>RxJS가 어렵다면 지금은 그냥 <code>비동기 Array/Collection 데이터</code>를 다루는 라이브러리 정도로 생각하고 접근해보자.</p><a id="more"></a><h2 id="RxJS-시작하기"><a href="#RxJS-시작하기" class="headerlink" title="RxJS 시작하기"></a>RxJS 시작하기</h2><h3 id="RxJS-첫번째-예제"><a href="#RxJS-첫번째-예제" class="headerlink" title="RxJS 첫번째 예제"></a>RxJS 첫번째 예제</h3><p>RxJS로 간단한 예제를 만들어보자.<br>웹 개발시 가장 빈번히 이루어지는 이벤트를 처리하는 예제를 작성해보자.</p><p>페이지를 클릭했을 경우 event.currentTarget 정보를 콘솔로 찍어보도록 하자.</p><p>다음과 같이 간단히 작성할 수 있다.<br>이벤트 핸들러를 만들고, 그 핸들러를 <code>addEventListener</code>를 통해 등록하기만 하면 우리가 원하는 코드를 작성할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventHandler = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.currentTarget);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, eventHandler);</span><br></pre></td></tr></table></figure><p>이 코드와 동일한 기능을 RxJS로 작성해 보자.<br>RxJS에서는 이벤트를 Observable로 변환하는 <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-fromEvent" rel="external nofollow noopener noreferrer" target="_blank">fromEvent</a> 메소드를 제공한다.<br>Observable의 <code>subscribe</code> 메소드를 이용하면 Observer가 Observable을 구독할 수 있다.<br>즉, Observable에서 전달된 데이터를 Observer는 소비할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> click$ = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">"click"</span>); <span class="comment">// observable</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.currentTarget);</span><br><span class="line">&#125;;</span><br><span class="line">click$.subscribe(observer);</span><br></pre></td></tr></table></figure><p>RxJS에서는 이벤트 핸들러를 만들었던 것과 같이 Observer를 만들고,<br>addEventListener를 통해 이벤트 핸들러를 등록하는 것과 같이 observer를 Observable에 구독(subscribe)하였다.<br>다른 것이 있다면 브라우저를 통해 전달되는 이벤트 정보를 Observable로 변환하는 작업을 추가적으로 하고 있다.</p><h3 id="RxJS-첫번째-예제-개선하기"><a href="#RxJS-첫번째-예제-개선하기" class="headerlink" title="RxJS 첫번째 예제 개선하기"></a>RxJS 첫번째 예제 개선하기</h3><p>앞에서 살펴본 예제를 살펴보면 실제 우리가 필요한 정보는 click이 아니라 click 될때의 currentTarget 정보이다.</p><p>Observable 인스턴스의 <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-pluck" rel="external nofollow noopener noreferrer" target="_blank">pluck</a> 메소드를 이용하면 이 의도를 코드에 더욱 명확히 나타낼 수 있다.</p><blockquote><p>pluck은 사전적으로 “~을 뽑다” 라는 의미이다.<br>추출할 속성들을 “문자열”로 지정할수 있다. 이 함수의 반환값은 새로운 Observable 인스턴스 이다.<br><code>public pluck(properties: ...string): Observable</code></p></blockquote><p>다음 코드는 pluck 메소드를 이용하여 코드의 의도를 더욱 분명하게 변경한 예이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currentTarget$ = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">"click"</span>).pluck(</span><br><span class="line">  <span class="string">"currentTarget"</span></span><br><span class="line">); <span class="comment">// observable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="function"><span class="params">currentTarget</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(currentTarget);</span><br><span class="line">&#125;;</span><br><span class="line">currentTarget$.subscribe(observer);</span><br></pre></td></tr></table></figure><p>click이 발생하는 시점에 전달된 event 객체의 currentTarget을 전달하는 currentTarget\$을 만들 수 있다.<br>Observer는 currentTarget을 구독함으로써 currentTarget 데이터를 전달받을 수 있다.</p><h3 id="RxJS-두번째-예제"><a href="#RxJS-두번째-예제" class="headerlink" title="RxJS 두번째 예제"></a>RxJS 두번째 예제</h3><p>앞의 예제가 비동기 방식을 RxJS로 구현한 것이라면 이번에는 동기적인 작업을 RxJS로 구현해보자.<br>간단한 예로 사용자 정보를 가지는 배열에서 “촉”나라 사람만 추출하여보자.</p><p>다음과 같이 작성할 수 있다.<br>array의 <code>filter</code> 메소드를 통해 원하는 사용자만을 추출할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"유비"</span>,</span><br><span class="line">    birthYear: <span class="number">161</span>,</span><br><span class="line">    nationality: <span class="string">"촉"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"손권"</span>,</span><br><span class="line">    birthYear: <span class="number">182</span>,</span><br><span class="line">    nationality: <span class="string">"오"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"관우"</span>,</span><br><span class="line">    birthYear: <span class="number">160</span>,</span><br><span class="line">    nationality: <span class="string">"촉"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"장비"</span>,</span><br><span class="line">    birthYear: <span class="number">168</span>,</span><br><span class="line">    nationality: <span class="string">"촉"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"조조"</span>,</span><br><span class="line">    birthYear: <span class="number">155</span>,</span><br><span class="line">    nationality: <span class="string">"위"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"손권"</span>,</span><br><span class="line">    birthYear: <span class="number">182</span>,</span><br><span class="line">    nationality: <span class="string">"오"</span></span><br><span class="line">  &#125;</span><br><span class="line">].filter(<span class="function"><span class="params">user</span> =&gt;</span> user.nationality === <span class="string">"촉"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> log = <span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">console</span>.log(user);</span><br><span class="line">users.forEach(log);</span><br></pre></td></tr></table></figure><p>이 코드와 동일한 기능을 RxJS로 작성해 보자.<br>RxJS에서는 Array를 Observable로 변환하는 <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-from" rel="external nofollow noopener noreferrer" target="_blank">from</a> 메소드를 제공한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users$ = Rx.Observable.from([</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"유비"</span>,</span><br><span class="line">    birthYear: <span class="number">161</span>,</span><br><span class="line">    nationality: <span class="string">"촉"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"손권"</span>,</span><br><span class="line">    birthYear: <span class="number">182</span>,</span><br><span class="line">    nationality: <span class="string">"오"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"관우"</span>,</span><br><span class="line">    birthYear: <span class="number">160</span>,</span><br><span class="line">    nationality: <span class="string">"촉"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"장비"</span>,</span><br><span class="line">    birthYear: <span class="number">168</span>,</span><br><span class="line">    nationality: <span class="string">"촉"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"조조"</span>,</span><br><span class="line">    birthYear: <span class="number">155</span>,</span><br><span class="line">    nationality: <span class="string">"위"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"손권"</span>,</span><br><span class="line">    birthYear: <span class="number">182</span>,</span><br><span class="line">    nationality: <span class="string">"오"</span></span><br><span class="line">  &#125;</span><br><span class="line">]).filter(<span class="function"><span class="params">user</span> =&gt;</span> user.nationality === <span class="string">"촉"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">console</span>.log(user);</span><br><span class="line">users$.subscribe(observer);</span><br></pre></td></tr></table></figure><p>RxJS에서는 추출된 사용자를 콘솔에 출력하기 위해 log를 만든 것과 같이 Observer를 만들고,<br>forEach를 통해 log 함수를 호출하는 것과 같이 observer를 Observable에 구독(subscribe)하였다.<br>다른 것이 있다면 Array 객체를 Observable로 변환하는 작업을 추가적으로 하고 있다.</p><p>RxJS를 이용하면 데이터 소스(이벤트, 배열)를 Observable로 만들기만 하면 <code>비동기 방식도 동기 방식도 모두 동일한 행태로 개발</code>을 할수 있다.</p><h2 id="RxJS-4대-천왕"><a href="#RxJS-4대-천왕" class="headerlink" title="RxJS 4대 천왕"></a>RxJS 4대 천왕</h2><p>RxJS에서는 다루는 중요 개념은 다음과 같다.</p><ul><li>Observable</li><li>Operator</li><li>Observer</li><li>Subscription</li><li>Subject</li><li>Scheduler</li></ul><p>이 장에서는 이 중 항상 사용하게 되는 4개 개념인 Observable, Operator, Observer, Subscription에 대해 다루기로 하자.<br>나머지 Subject와 Scheduler는 뒷 장에서 다루도록 하겠다.</p><h3 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h3><p>시간을 축으로 연속적인 데이터를 저장하는 컬렉션을 표현한 객체이다. 데이터를 제공하는 소스나 Observabler과 연결되어 데이터를 제공한다. Operator와 함께 RxJS의 핵심 중의 핵심인 개념이다. 이를 stream이라고 부른다.<br></p>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2017/10/07/rxjsbook4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Microsoft와의 인연</title>
      <link>http://sculove.github.io/blog/2017/10/07/Microsoft/</link>
      <guid>http://sculove.github.io/blog/2017/10/07/Microsoft/</guid>
      <pubDate>Sat, 07 Oct 2017 03:33:49 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;추석 고향가기전에 Microsoft로 부터 다음과 같은 메일을 받았다.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>추석 고향가기전에 Microsoft로 부터 다음과 같은 메일을 받았다.</p><p></p>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2017/10/07/Microsoft/#disqus_thread</comments>
    </item>
    
    <item>
      <title>RxJS가 해결하려고했던 문제3 - 로직 처리의 오류</title>
      <link>http://sculove.github.io/blog/2017/07/26/rxjsbook3/</link>
      <guid>http://sculove.github.io/blog/2017/07/26/rxjsbook3/</guid>
      <pubDate>Tue, 25 Jul 2017 16:55:25 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;오늘 소개할 부분은&lt;br&gt;웹어플리케이션 개발시 발생할 수 있는 &lt;code&gt;로직 오류에 대한 문제&lt;/code&gt;를 RxJS는 어떻게 접근했는지에 대한 이야기이다.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;웹어플리케이션의-로직&quot;&gt;&lt;a href=&quot;#웹어플리케이션의
        
      
      </description>
      
      <content:encoded><![CDATA[<p>오늘 소개할 부분은<br>웹어플리케이션 개발시 발생할 수 있는 <code>로직 오류에 대한 문제</code>를 RxJS는 어떻게 접근했는지에 대한 이야기이다.</p><hr><h3 id="웹어플리케이션의-로직"><a href="#웹어플리케이션의-로직" class="headerlink" title="웹어플리케이션의 로직"></a>웹어플리케이션의 로직</h3><p>웹어플리케이션은 로직에 근거하여 전달받은 입력값을 이용하여 새로운 결과를 반환하거나 표현한다.<br>여기서 로직은 산술적인 로직이 될 수 있고 비즈니스적인 로직이 될수 있다. 또는 if문과 같이 간단한 프로그램의 흐름을 담당하는 부분일 수도 있다.</p><p>화면에 사용자 정보를 표현하는 UI 작성하는 예를 생각해보자. (예제에서 사용하는 API는 스타워즈 등장인물을 조회한다)<br>DB로부터 조회한 사용자 목록 데이터가 입력값이라면 이 값을 바탕으로 우리는 다양한 처리를 한다.</p><ul><li>성별이 “남”과 “여”인 사용자만 추출한다 (스타워즈 등장인물은 로봇과 같이 성별이 없는 사용자도 있다)</li><li>사용자의 이름, 키, 몸무게를 표시한다.</li><li>사용자의 성별에 맞게 아이콘을 화면에 표시한다.</li><li>사용자의 표준 체중을 계산하여 표시한다.<blockquote><p>BROCA 방식</p><ul><li>남자 표준체중 = (키 - 100) × 0.9</li><li>여자 표준체중 = (키 - 105) × 0.9</li></ul><p>BMI 방식</p><ul><li>남자 표준체중 = 키/100 _ 키/100 _ 22</li><li>여자 표준체중 = 키/100 _ 키/100 _ 21</li></ul></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> jsonData = <span class="built_in">JSON</span>.parse(xhr.responseText);</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"users"</span>).innerHTML = process(jsonData);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">"GET"</span>, <span class="string">"http://swapi.co/api/people/"</span>);</span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터를 처리하는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">people</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> html = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> user <span class="keyword">of</span> people.results) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/male|female/</span>.test(user.gender)) &#123;</span><br><span class="line">      <span class="keyword">let</span> broca;</span><br><span class="line">      <span class="keyword">let</span> bmi;</span><br><span class="line">      <span class="keyword">if</span> (user.gender == <span class="string">"male"</span>) &#123;</span><br><span class="line">        broca = (user.height - <span class="number">100</span> * <span class="number">0.9</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">        bmi = ((((user.height / <span class="number">100</span>) * user.height) / <span class="number">100</span>) * <span class="number">22</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        broca = (user.height - <span class="number">100</span> * <span class="number">0.9</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">        bmi = ((((user.height / <span class="number">100</span>) * user.height) / <span class="number">100</span>) * <span class="number">21</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> obesityUsingBroca = (((user.mass - broca) / broca) * <span class="number">100</span>).toFixed(</span><br><span class="line">        <span class="number">2</span></span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">const</span> obesityUsingBmi = (((user.mass - bmi) / bmi) * <span class="number">100</span>).toFixed(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">      html.push(<span class="string">`&lt;li class='card'&gt;</span></span><br><span class="line"><span class="string">  &lt;dl&gt;</span></span><br><span class="line"><span class="string">      &lt;dt&gt;<span class="subst">$&#123;user.name&#125;</span> &lt;i class="fa fa-<span class="subst">$&#123;user.gender&#125;</span>"&gt;&lt;/i&gt;&lt;/dt&gt;</span></span><br><span class="line"><span class="string">      &lt;dd&gt;&lt;span&gt;키 : &lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;user.height&#125;</span> cm&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">      &lt;dd&gt;&lt;span&gt;몸무게: &lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;user.mass&#125;</span> kg&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">      &lt;dd&gt;&lt;span&gt;BROCA 표준체중 : &lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;broca&#125;</span> kg&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">      &lt;dd&gt;&lt;span&gt;BROCA 비만도 : <span class="subst">$&#123;obesityUsingBroca&#125;</span>&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">      &lt;dd&gt;&lt;span&gt;BMI 표준체중 : &lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;bmi&#125;</span> kg&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">      &lt;dd&gt;&lt;span&gt;BMI 비만도 : <span class="subst">$&#123;obesityUsingBmi&#125;</span>&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">  &lt;/dl&gt;</span></span><br><span class="line"><span class="string">      &lt;/li&gt;`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> html.join(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2017/07/26/rxjsbook3/userscreenshot.png"><p>원래 조회했던 데이터는 온데 간데 없고 그 데이터로부터 생산된 새로운 정보들을 사용하고 있다.<br>위 예제는 사용자 체중과 키를 이용하여 성별에 따라 비만도 값을 계산하고 성별 아이콘을 화면에 표시한다.</p><p>우리는 알게 모르게 데이터를 추출하고 변환하는 작업을 빈번하게 하고 있다.<br>복수 데이터를 처리하기 위해서는 반복문을 사용하고, 상황에 따라 데이터를 추출하거나 접근하기 위해서 분기문을 사용한다.<br>또한, 상황을 기억하거나 추출된 정보를 임시로 기억하기 위해서 변수를 사용한다.</p><h3 id="로직의-복잡성-그리고-오류"><a href="#로직의-복잡성-그리고-오류" class="headerlink" title="로직의 복잡성 그리고 오류"></a>로직의 복잡성 그리고 오류</h3><p>반복문과 분기문 그리고 변수는 우리 코드를 복잡하게 만든다. 반복문은 우리 코드의 가독성을 떨어뜨리고 분기문은 우리가 확인해야할 프로그램의 흐름을 여러 개로 만든다. 더군다나 우리가 기억해 놓은 변수의 값은 누군가에 의해 변경될 수 있다. 변수의 값이 변하면 우리가 의도했던대로 흐름으로 프로그램이 동작하지 않을 수 있다.<br>이렇게 반복문과 분기문 그리고 변수는 우리 코드의 복잡도를 높이고 가독성을 떨어뜨리고, 결국에는 오류의 발생 빈도를 높인다.</p><h4 id="반복문과-분기문"><a href="#반복문과-분기문" class="headerlink" title="반복문과 분기문"></a>반복문과 분기문</h4><p>로직의 복잡성을 줄이는 가장 간단한 방법으로는 기능을 쪼개는 것이다. 기능별로 쪼갠다는게 단순히 구역별로 쪼개게 되면 기능의 의미를 명확하게 드러내지 못한다. 더불어 이런 코드는 재사용성을 떨어뜨린다.</p><p>이렇게 기능을 쪼개는 일이 쉬운 일이 아닌 이유는 코드의 대다수는 다음과 같이 로직과 반복문, 분기문의 결합으로 구성되어 있기 때문이다.</p><img src="/blog/2017/07/26/rxjsbook3/logic.png"><p>코드에서 반복문과 분기문을 모두 제거한다는 것은 사실상 불가능하다. 하지만 기능 단위로 분리 할 수 있다면 기능을 추상화 할 수 있고, 이로 인해 로직의 복잡성을 줄일 수 있다.</p><h4 id="변수는-오류의-시작"><a href="#변수는-오류의-시작" class="headerlink" title="변수는 오류의 시작"></a>변수는 오류의 시작</h4><p>변수를 사용한다는 의미는 오류를 발생시킬 수 있는 확률을 높일 수 있다. 변수는 변경될 수 있는 값이기 때문에 유용하다. 반면, 의도치 않게 이 값이 바뀔 경우에 우리는 오류에 직면하게 된다.<br>브라우저 환경의 자바스크립트에서는 싱글 쓰레드 구조이기 때문에 Mutil Thread의 사용으로 인한 동시성 문제는 자주 발생하지 않는다. 하지만 DOM에 등록된 이벤트 핸들러로 인해 변수의 값이 변경되거나 비동기 행위로 인해 외부로 노출된 변수의 값들이 변경 될 수 있다.</p><blockquote><p>WebWorker와 같은 기술 스펙을 사용하면 Mutil Thread 기술을 사용할 수 있지만 브라우저는 기본적으로 하나의 메인 스레드에서 모든 작업이 이루어 진다.</p></blockquote><p>따라서, 우리는 변수의 노출 범위를 제한하거나 제거함으로써 변수의 값이 외부에 의해 변경되지 않고 개발자의 의도에 따라 정확하게 변경될 수 있도록 보장하여만 한다.</p><h3 id="자바스크립트의-솔루션"><a href="#자바스크립트의-솔루션" class="headerlink" title="자바스크립트의 솔루션"></a>자바스크립트의 솔루션</h3><p>다행히도 자바스크립트는 이런 면에서는 꽤나 훌륭한 솔루션을 제공하고 있다.<br>함수형 프로그래밍의 특성을 가진 자바스크립트 함수를 이용하면 실제 로직과 상관이 없는 반복문, 분기문을 분리할 수 있다. 더불어 변수 또한 제거해 나갈 수 있다.<br>이렇게 함으로써 로직의 의미를 더욱 명확히 할 수 있으며 재사용성을 더욱 높일 수 있다.</p><blockquote><p>자바스크립트 함수는 일급객체이다.<br>일급 객체(First-class object)는 다음과 같은 특성을 가지고 있다.</p><ul><li>변수 혹은 데이터 구조에 저장할 수 있다</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> savedFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; - 파라미터로 전달할 수 있다.</span><br><span class="line">&gt; ```js</span><br><span class="line"> function foo(f, value) &#123;&#125;;</span><br><span class="line"> foo(function() &#123;</span><br><span class="line">     console.log(&quot;함수를 파라미터로 전달 할 수 있다&quot;);</span><br><span class="line"> &#125;, &quot;값&quot;);</span><br></pre></td></tr></table></figure><blockquote><ul><li>반환값으로 사용할 수 있다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><pre><code>return function() {   console.log(&quot;함수를 반환할 수 있다&quot;);};</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 로직의 분리</span><br><span class="line">앞의 process 함수를 기능 단위의 로직과 반복문, 분기문으로 분리해보자.</span><br><span class="line">process 함수는 다음과 같은 구조로 되어 있다.</span><br><span class="line"></span><br><span class="line">&#123;% asset_img advance_logic.png %&#125;</span><br><span class="line"></span><br><span class="line">여기에서 우리의 주요 관심사는 성별에 따라 비만도를 구하는 로직과 사용자별 HTML을 만드는 로직이다.</span><br><span class="line">이 부분을 별도의 함수로 만들어보자.</span><br><span class="line"></span><br><span class="line">표준 체중과 비만도를 계산하는 함수는 height, mass, gender을 입력값으로 받아서 BROCA와 BMI 방식의 비만도와 표준 체중을 반환한다.</span><br><span class="line">```js</span><br><span class="line">// 표준 체중과 비만도를 계산하는 함수</span><br><span class="line">function logic(height, mass, gender) &#123;</span><br><span class="line">let broca = (height - (gender === &quot;male&quot; ? 100 : 105)) * 0.9;</span><br><span class="line">let bmi = height / 100 * height / 100 * (gender === &quot;male&quot; ? 22 : 21);</span><br><span class="line">if (gender == &quot;male&quot;) &#123;</span><br><span class="line">broca = (height - 100 * 0.9).toFixed(2);</span><br><span class="line">bmi = (height / 100 * height / 100 * 22).toFixed(2);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">broca = (height - 100 * 0.9).toFixed(2);</span><br><span class="line">bmi = (height / 100 * height / 100 * 21).toFixed(2);</span><br><span class="line">&#125;</span><br><span class="line">const obesityUsingBroca = ((mass - broca) / broca * 100).toFixed(2);</span><br><span class="line">const obesityUsingBmi = ((mass - bmi) / bmi * 100).toFixed(2);</span><br><span class="line">return &#123;</span><br><span class="line">broca,</span><br><span class="line">bmi,</span><br><span class="line">obesityUsingBroca,</span><br><span class="line">obesityUsingBmi</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사용자 정보별 HTML을 만드는 함수는 user 정보를 받아서 string 형태의 html을 반환한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 사용자 정보를 표현하기 위해 HTML을 만드는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeHtml</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;li class='card'&gt;</span></span><br><span class="line"><span class="string">&lt;dl&gt;</span></span><br><span class="line"><span class="string">&lt;dt&gt;<span class="subst">$&#123;user.name&#125;</span> &lt;i class="fa fa-<span class="subst">$&#123;user.gender&#125;</span>"&gt;&lt;/i&gt;&lt;/dt&gt;</span></span><br><span class="line"><span class="string">&lt;dd&gt;&lt;span&gt;키 : &lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;user.height&#125;</span> cm&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">&lt;dd&gt;&lt;span&gt;몸무게: &lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;user.mass&#125;</span> kg&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">&lt;dd&gt;&lt;span&gt;BROCA 표준체중 : &lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;user.broca&#125;</span> kg&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">&lt;dd&gt;&lt;span&gt;BROCA 비만도 : <span class="subst">$&#123;user.obesityUsingBroca&#125;</span>&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">&lt;dd&gt;&lt;span&gt;BMI 표준체중 : &lt;/span&gt;&lt;span&gt;<span class="subst">$&#123;user.bmi&#125;</span> kg&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">&lt;dd&gt;&lt;span&gt;BMI 비만도 : <span class="subst">$&#123;user.obesityUsingBmi&#125;</span>&lt;/span&gt;&lt;/dd&gt;</span></span><br><span class="line"><span class="string">&lt;/dl&gt;</span></span><br><span class="line"><span class="string">&lt;/li&gt;`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>logic, makeHtml함수를 이용하면 다음과 같이 process 함수를 작성할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">people</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> html = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> user <span class="keyword">of</span> people.results) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/male|female/</span>.test(user.gender)) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = logic(user.height, user.mass, user.gender);</span><br><span class="line">      <span class="built_in">Object</span>.assign(user, result);</span><br><span class="line">      html.push(makeHtml(user));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> html.join(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>logic, makeHtml 함수를 만듦으로서 우리는 핵심 로직을 작성는데 집중할 수 있게 되었다.<br>더불어 logic, makeHtml 함수도 재사용 할 수 있는 단위 함수가 되었다.</p><h4 id="반복문-분기문-그리고-변수와의-이별"><a href="#반복문-분기문-그리고-변수와의-이별" class="headerlink" title="반복문, 분기문, 그리고 변수와의 이별"></a>반복문, 분기문, 그리고 변수와의 이별</h4><p>위에 개선한 process도 좋은 코드이다. 우리는 구현 로직에 더 집중할 수 있게 되었다.<br>하지만, 흐름을 제어하는 반복문과 분기문은 여전히 process에 존재한다.<br>코드가 크면 클수록 process에 존재하는 반복문과 조건문은 우리 코드의 가독성을 떨어뜨릴 것이다. 더불어 html, result 같은 변수가 여전히 존재하기 때문에 우리는 항상 오류에 노출될 것이다.</p><p>이번에는 ES5에서 제공하는 Array의 filter, map, reduce와 같은 고차함수(High-order function)를 이용하여 process를 개선해 보자.</p><blockquote><h3 id="고차함수-Higher-order-function"><a href="#고차함수-Higher-order-function" class="headerlink" title="고차함수 (Higher-order function)"></a>고차함수 (Higher-order function)</h3><ul><li>다른 함수를 인자로 받거나 그 결과로 함수를 반환하는 함수.<br>출처: wikipedia <a href="https://en.wikipedia.org/wiki/Higher-order_function" rel="external nofollow noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Higher-order_function</a></li><li>고차 함수는 변경되는 주요 부분을 함수로 제공함으로서 동일한 패턴 내에 존재하는 문제를 손쉽게 해결할 수 있는 고급 프로그래밍 기법이다.</li><li>고차 함수를 이용하면 함수의 합성, 변형과 같은 작업을 손쉽게 할수 있다. 더불어 Currying, Memoization과 같은 기법도 사용할 수 있다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> twice = <span class="function">(<span class="params">f, v</span>) =&gt;</span> f(f(v));</span><br><span class="line">&gt; <span class="keyword">const</span> fn = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="number">3</span>;</span><br><span class="line">&gt; <span class="built_in">console</span>.log(twice(fn, <span class="number">7</span>)); <span class="comment">// 13</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```js</span><br><span class="line">function process(people) &#123;</span><br><span class="line">    return people.results</span><br><span class="line">        .filter(user =&gt; /male|female/.test(user.gender))</span><br><span class="line">.map(user =&gt; Object.assign(</span><br><span class="line">                               user,</span><br><span class="line">       logic(user.height, user.mass, user.gender)</span><br><span class="line">))</span><br><span class="line">.reduce((acc, user) =&gt; &#123;</span><br><span class="line">acc.push(makeHtml(user));</span><br><span class="line">return acc;</span><br><span class="line">&#125;, [])</span><br><span class="line">.join(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if문은 filter로 변환하고, 값을 변환해야하는 경우에는 map을 이용하고, 축적된 데이터를 반환해야하는 경우에는 reduce를 이용하였다.<br>각각의 고차함수에 전달되는 함수는 외부의 변수에 영향을 미치지도 않고, 영향을 받지도 않는 함수이다.<br>전달된 함수는 항상 같은 입력이 주어지면, 항상 같은 출력을 반환한다.<br>이런 함수를 함수형 프로그래밍에서는 <code>순수함수</code>라고 한다.</p><blockquote><p>순수함수와 함수형 프로그래밍에 대한 내용은 <code>부록. 함수형 프로그래밍 (Functional Programming)</code>을 참조하기 바란다.</p></blockquote><p>개선된 process에서는 반복문, 분기문, 변수가 존재하지 않는다.<br>핵심 로직은 분리되었고 코드의 흐름은 단일화되었다. 더불어 변수를 사용하지 않음으로서 오류의 발생 빈도도 크게 줄었다.</p><h2 id="RxJS는-어떻게-개선하였나"><a href="#RxJS는-어떻게-개선하였나" class="headerlink" title="RxJS는 어떻게 개선하였나?"></a>RxJS는 어떻게 개선하였나?</h2><p>RxJS 또한 ES5 Array의 고차 함수와 같은 <code>operator를 제공</code>함으로써 로직에 존재하는 분기문과 반복문, 그리고 변수를 제거하려고 하였다.</p><h3 id="Immutable-객체-Observable"><a href="#Immutable-객체-Observable" class="headerlink" title="Immutable 객체 Observable"></a>Immutable 객체 Observable</h3><p>ES5 Array의 고차함수들이 반환값으로 새로운 Array 객체를 반환하여 각각에 영향을 미치지 않도록 하는 것과 같이 RxJS의 operator는 항상 새로운 Observable을 반환함으로써 Array의 고차함수와 같이 <code>불변 객체 (Immutable Object)</code>를 반환한다.<br>불변 객체는 생성 후 그 상태를 바꿀 수 없는 객체이다. 불변 객체는 외부에서 값을 변경할 수 없기 때문에 불변 객체를 사용하는 것만으로도 프로그램의 복잡도가 줄어든다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> mappedArr = arr.map(<span class="function"><span class="params">v</span> =&gt;</span> v);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr === mappedArr); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>Array와 다른점이 있다면 Array의 경우는 새로운 Array 객체 생성 작업만 하지만 Observable은 새로운 Observable를 만들고, 그 Observable이 operator를 호출한 Observable을 내부적으로 subscribe 하는 형태를 유지한다. 즉, Linked list 형태로 기존 Observable 객체와 새롭게 만든 Observable 객체를 operator로 연결하고 있다.</p><img src="/blog/2017/07/26/rxjsbook3/rx_process.png" class="linked-observable](linked-observable.png) 한 예로 Observable.map은 다음과 같이 구현되어 있다. undefined 이런 구조를 취함으로서 `source부터 전달된 데이터, 에러, 종료여부가 Observable의 operator들을 통해 전달되거나 변경되어 구독한 Observer에게 전달할 수 있게 된다.` 앞에서 설명한 표준체중과 비만도 조회 예를 Observable로 변경해보자. undefined 이전 우리가 개선한 process 소스와 큰 차이가 없다. > 원리 설명을 위해 부득이하게 사용자 리스트를 사용자로 바꿔 전달하였다. > 일반적으로는 Ajax를 통해 전달 받은 정보를 바탕으로 operator를 적용한다. 차이라면 다음과 같이 ajax\$ Observable를 통해 전달 받은 데이터가 filter, map, reduce를 거쳐 observer에게 전달되는 구조로 되어있다는 것이다. {% asset_img"><h2 id="RxJS가-제공하는-Operator"><a href="#RxJS가-제공하는-Operator" class="headerlink" title="RxJS가 제공하는 Operator"></a>RxJS가 제공하는 Operator</h2><p>다음은 공식 홈페이지에서 제공하는 operator 목록이다.<br><a href="http://reactivex.io/rxjs/manual/overview.html#categories-of-operators" rel="external nofollow noopener noreferrer" target="_blank">http://reactivex.io/rxjs/manual/overview.html#categories-of-operators</a></p><table><thead><tr><th>카테고리</th><th>operator</th></tr></thead><tbody><tr><td>생성 operator</td><td>ajax, bindCallback, bindNodeCallback, create, defer, empty, from, fromEvent, fromEventPattern, fromPromise, generate, interval, never, of,repeat ,repeatWhen, range ,throw ,timer</td></tr><tr><td>변환 operator</td><td>buffer, bufferCount, bufferTime, bufferToggle, bufferWhen, concatMap, concatMapTo, exhaustMap, expand, groupBy, map, mapTo, mergeMap, mergeMapTo, mergeScan, pairwise, partition, pluck, scan, switchMap, switchMapTo, window, windowCount, windowTime, windowToggle, windowWhen</td></tr><tr><td>추출 operator</td><td>debounce, debounceTime, distinct, distinctKey, distinctUntilChanged, distinctUntilKeyChanged, elementAt, filter, first, ignoreElements, audit, auditTime, last, sample, sampleTime, single, skip, skipUntil, skipWhile, take, takeLast, takeUntil, takeWhile, throttle, throttleTime</td></tr><tr><td>결합 operator</td><td>combineAll, combineLatest, concat, concatAll, exhaust, forkJoin, merge, mergeAll, race, startWith, switch, withLatestFrom, zip, zipAll</td></tr><tr><td>멀티캐스팅 operator</td><td>cache, multicast, publish, publishBehavior, publishLast, publishReplay, share</td></tr><tr><td>에러 처리 operator</td><td>catch, retry, retryWhen</td></tr><tr><td>유틸리티 operator</td><td>do, delay, delayWhen, dematerialize, finally, let, materialize, observeOn, subscribeOn, timeInterval, timestamp, timeout, timeoutWith, toArray, toPromise</td></tr><tr><td>조건.참거짓 operator</td><td>defaultIfEmpty, every, find, findIndex, isEmpty</td></tr><tr><td>수학,누적 operator</td><td>count, max, min, reduce</td></tr></tbody></table><p>RxJS에서 제공하는 operator를 이용하면 Observable을 생성 할 수도 있고 전달된 데이터를 변환하거나 필요한 데이터만을 추출할 수 도 있다.<br>더불어 여러 개의 Observable을 합성하기도 하고, 하나의 Observable을 다른 여러개의 Observable로 나눌 수도 있다.</p><p>RxJS는 정말 많은 operator를 제공한다. operator의 의미에 대해 잘 아는 사람에게는 굉장히 편리하다. 반면 그 의미를 잘 알지 못하는 사람에게는 오히려 진입 장벽이 되기도 한다.<br>이 operator의 기본적인 철학은 <code>함수형 프로그래밍</code>에 그 근간을 두고 있다.<br>아마도 함수형 프로그래밍 언어를 배운 독자라면 꽤 익숙한 이름의 operator들이 있는 것 을 알 수 있다.</p><p>RxJS의 operator는 어휘와 같다.<br>내가 많은 단어와 문장을 알아서 사용하게 되면 나의 편의성이 증가하고 더불어 나의 품격도 높아질수 있다. 하지만, 다른 한편으로는 다른 사람이 내 말을 이해하기 어려워 할 수도 있다.<br>반면 내가 알고 있는 단어와 문장이 적다고 하더라도 의사소통이 될 정도의 단어와 문장을 사용한다면 생활하는데 부족함이 없다. 마찬가지로 RxJS의 모든 operator를 다 알 필요는 없다.<br>카테고리별로 자주쓰는 operator 몇 개를 잘 알고 적용할 수 있다면 충분히 RxJS의 장점을 극대화 할수 있다.<br>따라서, 이 책에서도 RxJS의 모든 Operator를 다루지는 않는다. 주요 카테고리별로 꼭! 알아야하는 RxJS의 Operator를 몇 개를 기준으로 설명을 할 예정이다.<br>자세한 내용은 다음 2부에서 진행하는 실제 프로젝트를 통해 조금씩 익혀나가 보자.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>웹어플리케이션의 로직은 반복문, 분기문, 변수에 의해 복잡도가 증가한다. 복잡도가 증가하게되면 이로 인해 코드의 가독성이 떨어지고 결국에는 오류에 직면하게 된다.<br>ES5 Array의 고차함수를 이용하면 반복문, 분기문, 변수를 로직으로부터 분리하고 제거할수 있다. 마찬가지로 RxJS는 ES5 Array의 고차함수와 같은 operator를 제공한다.<br>operator는 Immutable한 Observable를 항상 생성함으로써 외부나 내부에 영향을 미치지 않는다. 이런 구조는 오류의 발생 빈도를 낮추는 역할을 한다.</p>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2017/07/26/rxjsbook3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>RxJS가 해결하려고했던 문제2 - 상태 전파 문제</title>
      <link>http://sculove.github.io/blog/2017/07/26/rxjsbook2/</link>
      <guid>http://sculove.github.io/blog/2017/07/26/rxjsbook2/</guid>
      <pubDate>Tue, 25 Jul 2017 16:51:20 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;오늘 소개할 부분은&lt;br&gt;웹어플리케이션 개발시 발생할 수 있는 &lt;code&gt;상태 전파 문제&lt;/code&gt;를 RxJS는 어떻게 접근했는지에 대한 이야기이다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;웹어플리케이션의-상태&quot;&gt;&lt;a href=&quot;#웹어플리케이션의-상태&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>오늘 소개할 부분은<br>웹어플리케이션 개발시 발생할 수 있는 <code>상태 전파 문제</code>를 RxJS는 어떻게 접근했는지에 대한 이야기이다.</p><hr><h2 id="웹어플리케이션의-상태"><a href="#웹어플리케이션의-상태" class="headerlink" title="웹어플리케이션의 상태"></a>웹어플리케이션의 상태</h2><p>우리가 만드는 웹어플리케이션은 하나의 큰 상태 머신이고 이를 구성하고 있는 크고 작은 단위들 또한 하나의 상태머신이다.<br>각각의 상태 머신들은 각자의 상태를 가지고 있고, 상태 머신들은 각자의 역할에 따라 서로 유기적으로 연결되어 있다.</p><p>A라는 작은 상태 머신의 상태값은 B의 입력값이 될수 있고, B의 상태값은 C와 D에 관련 있는 상태값 일수 있다.<br>따라서, A의 상태 값은 B로 전달되어야하고 B의 상태값은 다시 C와 D에 전달되어야만 한다.<br>이렇게 A의 상태 변화 정보가 B에 전달되어야하고 B의 상태값이 다시 C와 D에 전달되어야하는 이유는 바로 A, B, C, D 모듈간에 <code>의존성</code>이 있기 때문이다.</p><p>간단한 예를 들어보자.<br>사용자 정보(상태)를 System 클래스가 check() 함수에서 사용하고 있는 예제이다.<br>System과 User간에는 다음과 같은 의존성이 존재한다.</p><p>이렇게한 근본적인 이유는 데이터 흐름을 단순화함으로 복잡도를 낮추고 오류 발생 빈도를 줄이기 위해서 이다.<br>물론, 데이터가 양방향으로 흐르게 되면 사용상 편리할 수는 있다. 하지만, 어플리케이션의 규모가 커지게 되면 양방향으로 흐르는 데이터의 복잡도는 통제하기 어려울 정도로 복잡해진다.</p><p>이러한 이유로 최근 등장한 프레임워크들은 모두 <code>단방향 데이터 흐름</code>을 지향한다.</p><blockquote><p>React와 Angular2+, Vue 모두 단방향 데이터 흐름을 지향한다.</p></blockquote><h3 id="Observable은-리액티브하다"><a href="#Observable은-리액티브하다" class="headerlink" title="Observable은 리액티브하다."></a>Observable은 리액티브하다.</h3><p>RxJS는 Observer 패턴과 마찬가지로 데이터가 발생하게되면 Observer에게 자동으로 그리고 빠르게 변경된 데이터를 전달한다.<br>이를 보고 <code>리액티브하다</code>고 이야기한다.<br>리액티브하다라는 의미를 이해하기 위해서는 우선 리액티브 프로그래밍(Reactive Programming)에 대한 정의 부터 살펴보자. 위키피디아에서는 다음과 같이 정의되어 있다.</p><blockquote><p>리액티브 프로그래밍은 데이터 흐름과 상태 변화 전파에 중점을 둔 프로그램 패러다임이다. 사용되는 프로그래밍 언어에서 데이터 흐름을 쉽게 표현할 수 있어야하며 기본 실행 모델이 변경 사항을 데이터 흐름을 통해 자동으로 전파한다는 것을 의미한다.</p><p>출처 : <a href="https://en.wikipedia.org/wiki/Reactive_programming" rel="external nofollow noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Reactive_programming</a></p></blockquote><p>위 정의에서 가장 핵심이 되는 단어는 <code>데이터 흐름</code>과 <code>자동으로 전파</code>이다. 즉, 상태 변화의 흐름이 자동으로 전파되는 것을 <code>리액티브</code>하다고 이야기한다.</p><p><code>리액티브</code>의 가장 흔하게 드는 예로 ‘엑셀’을 이야기할 수 있다.</p><p>A열의 값과 B열의 값의 합을 나타내는 C열은 A열이나 B열의 값이 변화되는 경우 자동으로 C열의 값이 변경된다.<br>이렇게 A나 B열의 변경사항이 데이터 흐름을 통해 자동으로 C열에 전파되도록 구조화하는 프로그래밍의 패러다임을 <code>리액티브 프로그래밍</code>이라고 한다.</p><p>이 말은 앞에서 살펴 보았던 상태 변화에 대한 우리의 고민들과 일맥 상통한다고 이야기할 수 있다.<br>이런 고민의 해결책이 Observer 패턴이고, RxJS는 이런 Observer 패턴을 개선하여 어플리케이션에서 발생하는 모든 데이터를 리액티브하게 전달 할 수 있게 해준다. 따라서, RxJS는 <code>리액티브 프로그래밍(Reactive Programming)</code>을 지향하는 라이브러리이다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>이 장에서는 웹어플리케이션의 상태가 어떻게 전파되는지를 살펴 봄으로써 상태 전파로 인해 발생할 수 있는 문제점을 살펴보았다. 또한, 이러한 문제를 효과적으로 해결했던 Observer 패턴에 대해서도 살펴보았다.<br>Observer 패턴은 느슨하게 연결되어 Subject와 Observer간의 의존도를 줄였으며, Push 방식으로 데이터를 전파함으로써 상태 전파에 대한 많은 문제를 해결했다.<br>RxJS에서는 이런 Observer 패턴을 개선하여 상태 전파 문제를 해결하려고 하였다.<br>에러상황과 종료상황에 대한 인터페이스를 확장하였고, 데이터를 단방향으로 흐를 수 있도록 개선함으로써 코드의 복잡도를 낮추었다. 이런 결과 RxJS는 궁극적으로 Reactive Programming을 지향하는 라이브러리가 되었다.</p><p>다음장에서는 RxJS가 고민한 로직 오류에 대해 살펴보기로 하자.</p>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2017/07/26/rxjsbook2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>RxJS가 해결하려고했던 문제1 - 입력 데이터의 오류</title>
      <link>http://sculove.github.io/blog/2017/06/30/rxjsbook1/</link>
      <guid>http://sculove.github.io/blog/2017/06/30/rxjsbook1/</guid>
      <pubDate>Thu, 29 Jun 2017 20:59:51 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;몇일 전에 요즘 내가 쓰고 있는 책의 초안을 일부를 공개하기로 셀프 선언한 이후, 사실 너무 바빴다 ㅠㅠ&lt;br&gt;1부 탈고일이 좀 남았지만… 마음이 급하다.&lt;br&gt;지인과는 과감히 탕수육 내기도 했으니. 더 급하다.&lt;/p&gt;
&lt;p&gt;처음이니깐 간단히 책
        
      
      </description>
      
      <content:encoded><![CDATA[<p>몇일 전에 요즘 내가 쓰고 있는 책의 초안을 일부를 공개하기로 셀프 선언한 이후, 사실 너무 바빴다 ㅠㅠ<br>1부 탈고일이 좀 남았지만… 마음이 급하다.<br>지인과는 과감히 탕수육 내기도 했으니. 더 급하다.</p><p>처음이니깐 간단히 책소개만 해보면.</p><blockquote><p>RxJS가 무엇을 위해 준비된 라이브러리인지에 대한 답을 구하는 책이다. 더불어 RxJS의 활용법도 학습하는 책이다. 참고로 rxjs5 기준으로 쓰고 있다<br><img src="/blog/2017/06/30/rxjsbook1/rxjs.png"></p></blockquote><p>오늘 소개할 부분은<br>웹어플리케이션 개발시 발생할 수 있는 <code>입력 오류</code>를 RxJS는 어떻게 접근했는지에 대한 이야기이다.</p><hr><h2 id="웹어플리케이션의-입력-데이터"><a href="#웹어플리케이션의-입력-데이터" class="headerlink" title="웹어플리케이션의 입력 데이터"></a>웹어플리케이션의 입력 데이터</h2><p>웹어플리케이션의 동작 과정을 되돌아보면 사실 몇 개의 큰 과정으로 나눌 수 있다.</p><p>간단한 게시판을 예로 생각해보자.<br>게시판은 서버에 저장된 글을 보여주는 목록화면과 게시글의 내용을 보여주는 상세화면으로 구성되어 있다.<br>서버로부터 저장된 글에 대한 정보를 받고, 받은 정보를 바탕으로 화면과 관련된 UI작업을 한다.<br>게시글의 종류나 카테고리를 셀렉트 박스로 표현할 수도 있고, 작성된 글의 내용 일부를 화면에 표현하기도 한다.</p><p>또한 사용자가 게시글을 등록. 수정하는 편집화면도 있다. 편집화면에서는 사용자가 셀렉트 박스를 선택하기도 하고, 글을 입력하기도 한다. 사용자의 입력이 잘못된 경우에는 사용자에게 메시지를 전달하기도 하기도 한다.<br>글의 작성 및 수정이 끝나면 등록한 정보를 서버에 저장한다.</p><p>이 과정을 <code>데이터가 흐르는 관점</code>으로 살펴보면</p><ul><li><ol><li>목록화면과 조회화면은 서버로부터 데이터를 불러와 브라우저에게 전달한다.</li></ol></li><li><ol start="2"><li>브라우저에 전달된 정보를 브라우저의 UI객체에 전달한다.</li></ol></li><li><ol start="3"><li>편집화면은 브라우저 UI객체를 통해 사용자 입력정보를 전달받고 이를 다시 브라우저의 다른 UI객체나 브라우저 객체에 전달한다.</li></ol></li><li><ol start="4"><li>사용자가 작성한 정보를 브라우저 UI객체나 브라우저 객체를 이용하여 서버로 전달한다.</li></ol></li></ul><p>이 과정을 다시 <code>상태머신</code> 관점에서 살펴보자.<br>1)과 2)의 과정에서 입력값은 <code>서버로부터 전달 받은 게시글 데이터</code>가 된다. 두 과정의 입력값이 동일 할지라도 입력값을 받는 브라우저와 브라우저 UI 객체는 <code>서로 다른 시점</code>에 입력값을 전달받는다.<br>예를 들어 1)과정이 Ajax로 JSON 데이터를 받아와 브라우저의 객체로 저장하는 경우라면 Ajax는 비동기(Asynchronous) 호출로 데이터를 받기 까지 시간이 걸린다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XMLHttpRequest에 의해 입력된 데이터</span></span><br><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Ajax를 통해 얻은 데이터를 result 변수에 저장한다.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &#123;</span></span><br><span class="line"><span class="comment">   *   list: [</span></span><br><span class="line"><span class="comment">   *      "게시글1번. 안녕하세요.",</span></span><br><span class="line"><span class="comment">   *      "게시글2번. 반갑습니다.",</span></span><br><span class="line"><span class="comment">   *      "게시글3번. RxJS에 대해 알아봐요."</span></span><br><span class="line"><span class="comment">   *   ]</span></span><br><span class="line"><span class="comment">   * &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  result = <span class="built_in">JSON</span>.parse(xhr.responseText);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">"GET"</span>, url);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>반면, 브라우저 UI객체는 이미 브라우저에 존재하는 JSON 데이터를 받기 때문에 동기(Synchronous) 호출로 바로 결과 데이터를 얻을수 있다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">"li"</span>)).forEach(<span class="function">(<span class="params">v, i</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Ajax의 결과인 result 변수를 이용하여 DOM에 정보를 표현한다.</span></span><br><span class="line">  v.innerText = result.list[i];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>마찬가지로 3)과 4)의 과정도 입력값은 <code>사용자의 입력</code>이 되지만, 전달된 입력값을 처리하는 시점은 상황에 따라 각각 다르다.</p><p>앞에서 설명한 내용을 간단히 정리하면 다음과 같다.</p><table><thead><tr><th>과정</th><th>데이터</th><th>데이터 흐름</th><th>전달 시점</th><th>예제</th></tr></thead><tbody><tr><td>1)</td><td>게시글</td><td>서버 -&gt; 브라우저</td><td>비동기</td><td>Ajax 통신으로 JSON 데이터를 받는다.</td></tr><tr><td>2)</td><td>게시글</td><td>브라우저 -&gt; 브라우저 UI 객체</td><td>동기</td><td>JSON 데이터를 UI에 반영한다.</td></tr><tr><td>3)</td><td>사용자가 입력한 내용</td><td>사용자 -&gt; 브라우저 UI객체</td><td>비동기</td><td>&lt;textarea&gt;를 통해 사용자 입력을 받는다.</td></tr><tr><td>4)</td><td>사용자가 입력한 내용</td><td>브라우저 UI 객체 -&gt; 브라우저 -&gt; 서버</td><td>동기, 비동기</td><td>&lt;textarea&gt;에 있는 데이터를 JSON 객체로 저장 후, 서버로 Ajax 요청을 한다</td></tr></tbody></table><h2 id="입력-데이터의-전달-시점이-다양하다"><a href="#입력-데이터의-전달-시점이-다양하다" class="headerlink" title="입력 데이터의 전달 시점이 다양하다."></a>입력 데이터의 전달 시점이 다양하다.</h2><p>앞에서 살펴본 바와 같이 입력데이터가 같을지라도 실제 각 객체들 사이로 데이터가 전달되는 시점은 다르다. 어떤 상황에서는 동기(Synchronous) 방식으로 데이터를 주고 받고, 어떤 상황에서는 비동기(Asynchronous) 방식으로 데이터를 주고 받는다.<br>이런 구조는 비단 웹어플리케이션 뿐만이 아니다. 소프트웨어 전반적으로 이와 같은 상황이 발생한다.<br>이런 이유는 두 방식의 차이점을 살펴보면 보다 명확히 알수 있다.</p><h3 id="동기-Synchronous"><a href="#동기-Synchronous" class="headerlink" title="동기(Synchronous)"></a>동기(Synchronous)</h3><p>동기방식은 작업이 들어온 순서에 맞게 차근차근 하나씩 진행되는 것을 의미한다. 호출하는 함수가 호출되는 함수의 작업 완료를 기다린 후 그 다음을 진행하는 방식이다. 이 방식의 장점은 순차적으로 진행되기 때문에 개발이 쉽다. 반면, 처리하는 작업이 많을 경우에는 전체 작업 속도가 느려진다. 특히, 웹브라우저와 같이 단일 UI쓰레드를 사용하는 경우에는 해당 작업이 끝날때까지 브라우저는 대기하고 있어야만 한다.<br><img src="/blog/2017/06/30/rxjsbook1/async-time.png" class="Synchronous](sync.png) ### 비동기(Asynchronous) 반면, 비동기 방식은 작업이 들어온 순서에 상관없이 산발적으로 진행되는 것을 의미한다. 호출하는 함수가 호출되는 함수의 작업 완료를 기다리지 않고, 그 다음을 진행하고 호출되는 함수의 작업이 완료되면 별도의 이벤트나 callback 함수를 통해 결과를 전달하는 방식이다. 이 방식의 장점은 효과적으로 작업을 진행할 수 있다는 점이다. 설사 먼저 실행된 작업의 처리시간이 오래걸리더라도 다른 작업을 진행할 수 있다. 반면, 개발은 더욱 복잡해지고 오류 확률은 높아질 우려가 있다. {% asset_img Asynchronous](async.png) ## 동기와 비동기를 함께 사용할 수 밖에 없는가? 동기 방식은 명확한 순서를 보장하면서 코드의 흐름과 프로그램의 흐름을 동일하게 처리하는 장점이 있지만, 비동기에 비해 효과적인 작업을 할 수 없다. 반면, 비동기 방식은효과적으로 작업을 할 수 있지만 호출의 순서를 보장하기가 어렵다. 이를 보장하기 위해서는 우리는 많은 작업들을 추가적으로 해야만 한다. 그렇다면 모두 동기 방식으로 개발하면 개발 생산성도 높이고, 오류의 발생빈도도 더 낮출수 있기 때문에 다른 한편으로는 더 좋은 선택이지 않는가? 틀린말은 아니다. 하지만 결론부터 이야기하면 그렇게 할수가 없다. 기반 플래폼이 제공하는 API자체가 동기 또는 비동기 방식을 제공하고 있기 때문에 본질적으로 우리는 이 문제를 피해갈 수가 없다. 특히 단일 쓰레드 기반의 브라우저 환경에서는 비동기 방식을 사용하지 않으면 성능 문제를 해결할 수 없기 때문에 우리에게는 선택의 여지가 없다. ## RxJS는 어떻게 개선하였나? RxJS가 주목했던 부분은 바로 이 입력 데이터에 대한 구조적 문제를 개선하고자 하였다. RxJS는 이런 구조적인 문제를 개선하기 위해 `단 하나의 방식`을 사용할 수 있는 구조를 제공한다. 이런 구조의 일원화는 개발을 단순화시킨다. 이런 단순화는 결국에는 오류 발생 빈도를 낮추고, 생산성 향상을 도와준다. RxJS는 동기(Synchronous)와 비동기(Asynchronous)의 차이점을 `시간`이라는 개념을 도입함으로써 해결하려고했다. 대표적인 비동기(Asynchronous) 처리방식인 이벤트(Event)를 살펴보자. Button에서 발생하는 click 이벤트를 처리하기 위해서는 다음과 같이 버튼에 이벤트 핸들러를 등록한다. undefined 한번 이벤트 핸들러가 등록되면 사용자가 버튼을 눌렀을 때마다 등록된 이벤트 핸들러가 호출된다. 이런 과정에 `시간`이라는 개념을 도입함으로써 우리는 다른 시각을 얻을 수 있다. 버튼을 누르는 행위가 우리가 원하는 데이터라면 시간 축을 기준으로 이 데이터는 다음과 같은 모습을 보일 것이다. {% asset_img"></p><p>이벤트가 아닌 동기(Synchronous) 방식인 함수호출도 <code>시간</code>이라는 개념을 도입하면 다음과 같이 표현될 수 있다.</p><img src="/blog/2017/06/30/rxjsbook1/sync-time.png"><p>결국 동기와 비동기는 시간의 축으로 봤을때는 같은 형태인 것이다.<br>또한, 이런 형태는 <code>시간을 인덱스로 둔 컬렉션</code>으로 생각할 수도 있다. RxJS에서는 이를 <code>스트림(Stream)</code>이라 표현한다.</p><img src="/blog/2017/06/30/rxjsbook1/collection-time.png"><p>RxJS에서는 이런 Stream을 표현하는 <code>Observable</code> 클래스를 제공한다.</p><h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><p>Observable은 <code>시간을 인덱스로 둔 컬렉션을 추상화한 클래스</code>이다.<br>이 클래스는 동기나 비동기의 동작 방식으로 전달된 데이터를 <code>하나의 컬렉션</code>으로 바라볼 수 있게 해준다.<br>이렇게 함으로써 개발자는 데이터가 어떤 형태로 전달되는지에 대해 더이상 고민할 필요가 없어진다.<br>단지, Observable을 통해 데이터를 전달 받기만 하면 된다.</p><blockquote><h5 id="Observable의-표준화"><a href="#Observable의-표준화" class="headerlink" title="Observable의 표준화"></a>Observable의 표준화</h5><p>RxJS의 Observable은 Rx에서 만든 라이브러리이기도 하지만, ECMAScript에 표준으로 제안된 스펙이기도하다.<br><a href="https://github.com/tc39/proposal-observable" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/tc39/proposal-observable</a></p><p>이 책에서 다루는 RxJS5는 ECMAScript에 제안된 표준 스펙을 기반으로 작성된 라이브러리이다.</p></blockquote><h2 id="모든-데이터는-Observable로-만들-수-있다"><a href="#모든-데이터는-Observable로-만들-수-있다" class="headerlink" title="모든 데이터는 Observable로 만들 수 있다."></a>모든 데이터는 Observable로 만들 수 있다.</h2><p>Observble은 모든 데이터를 다룬다.</p><ul><li>키보드를 눌러서 입력된 데이터</li><li>마우스를 이동하거나 클릭해서 입력된 데이터</li><li>Ajax/fetch 요청을 통해 얻은 데이터</li><li>Web socket을 통해 전달된 데이터</li><li>Message를 통해 전달된 데이터</li><li>…</li></ul><p></p>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2017/06/30/rxjsbook1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>요즘 일상</title>
      <link>http://sculove.github.io/blog/2017/06/25/recent/</link>
      <guid>http://sculove.github.io/blog/2017/06/25/recent/</guid>
      <pubDate>Sun, 25 Jun 2017 00:06:04 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;내가 알았던 의미있는 내용 중 정리가 필요한 부분이나, 사람들에게 공유하면 의미가 있을것 같은 자료들은 가급적 블로그로 정리하려고 한다. 하지만 생각만큼 쉽지가 않다.&lt;/p&gt;
&lt;p&gt;특히 올해는 개인적으로 &lt;code&gt;책&lt;/code&gt;을 쓴다는 작은 
        
      
      </description>
      
      <content:encoded><![CDATA[<p>내가 알았던 의미있는 내용 중 정리가 필요한 부분이나, 사람들에게 공유하면 의미가 있을것 같은 자료들은 가급적 블로그로 정리하려고 한다. 하지만 생각만큼 쉽지가 않다.</p><p>특히 올해는 개인적으로 <code>책</code>을 쓴다는 작은 목표가 있다보니 글을 올릴 여유가 없다.</p><img src="/blog/2017/06/25/recent/writing-book.jpg"><p>두아이의 아빠로 살면서 책 쓴다는게 사실 쉬운 일은 아닌것 같다.<br>아침에 일어나면 큰애 유치원 데려다주고 바로 회사 가서 열일하고<br>일많으면 야근도 한다.<br>그러면 실제 책을 쓸 수 있는 시간은 11시 부터이다.</p><p>야근 안하고 집에 빨리가더라도 우리 아이들이 10시 이후에 잠들기 때문에, 마찬가지로 11시 부터이다.<br>시간은 2시간 반이지만 웜업시간을 고려하면 많아야 <code>하루 2시간</code></p><p>하지만, 집에만 있는 아내를 배려해야하는 점을 고려하면 일주일에 투자할 수 있는 날은 많아야 2~3일 정도이다.<br>그래서 내가 일주일에 투자할수 있는 총 시간은 <code>4~6 시간</code></p><p>사실 책쓰는 작업이 집중해서 하는게 더 효과적인데, 쪼개서하다보니 실제 한 챕터를 쓰는데 시간이 더 많이 든다.<br>기존에 뭐썼지? 부터 어떤 스토리로 전개했는지에 대한 기억이 희미해지기 때문에, 다시 앞에서 부터 살펴봐야하는 문제도 있다.</p><p>암튼 요즘은 총체적인 난국을 보내고 있다.</p><p>그래서 생각해낸 방법이 3가지이다.</p><h4 id="첫번째-책쓰는-일을-좀더-작은-단위의-일로-쪼개고-있다"><a href="#첫번째-책쓰는-일을-좀더-작은-단위의-일로-쪼개고-있다" class="headerlink" title="첫번째. 책쓰는 일을 좀더 작은 단위의 일로 쪼개고 있다."></a>첫번째. 책쓰는 일을 좀더 작은 단위의 일로 쪼개고 있다.</h4><p>책을 쓰기 위한 타스크를 굉장히 작은 단위로 나눠서 스케쥴을 했다.</p><ul><li>1장 스토리 라인 만들기</li><li>1장 서론 쓰기</li><li>1장 서론과 본론 이어지는 부분 쓰기</li><li>…</li></ul><p>뭐 이런식으로 쪼개서 하고 있다.<br>그나마 진행도가 나오기때문에 그전 보다는 속도감이 붙은것 같다.</p><h4 id="두번째-주변-사람들에게-예상-탈고일을-알리고-있다"><a href="#두번째-주변-사람들에게-예상-탈고일을-알리고-있다" class="headerlink" title="두번째. 주변 사람들에게 예상 탈고일을 알리고 있다."></a>두번째. 주변 사람들에게 예상 탈고일을 알리고 있다.</h4><p>이 일이 혼자하는 일이고 살다보면 우선순위도 굉장히 낮은 작업이기 때문에 의도적으로 주변사람들에게 알림으로써 내 개인적인 우선순위를 높이고 있다.<br>아직까지는 압박감만 느끼고 스트레스만 더 받고 있는 상황이지만…<br>해볼만은 한것 같다.</p><h4 id="그리고-세번째"><a href="#그리고-세번째" class="headerlink" title="그리고 세번째."></a>그리고 세번째.</h4><p>마찬가지로 <code>책의 초안 일부분을 블로그</code>에 올려 볼 생각이다.</p><p>책을 쓰기 위한 나의 의지이기도 하지만.<br>더 큰 의도는 내가 쓰고 있는 책이 사람들의 공감을 받을수 있는 책인지?<br>내가 이 책에서 어떤 헛소리를 하고 있는지?<br>실제로 이 책에 관심을 갖는 사람들이 누구인지?</p><p>이런 걸 알면 더 좋은 책을 쓸수 있지 않을까하는 막역한 생각에 시작해볼 생각이다.</p><p>오늘은 이 책에서 다룰 내용을 간단히 적고 마무리 할려고 한다.<br>이 책은 <code>RxJS</code>에 대한 책이다.</p><img src="/blog/2017/06/25/recent/rxjs.png"><p>일반적인 RxJS 기술 서적은 아니다.</p><p>이 책은<br><blockquote><p>RxJS가 무엇을 위해 준비된 라이브러리인지에 대한 답을 구하는 책이다. 더불어 RxJS의 활용법도 학습하는 책이다.</p><footer><strong>참고로 rxjs5 기준으로 쓰고 있다</strong></footer></blockquote></p><p>말은 거창하지만 잘 나올지 모르겠다.</p><p>다시 일상으로~ 고!</p>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2017/06/25/recent/#disqus_thread</comments>
    </item>
    
    <item>
      <title>QWebview-Plus 프로젝트 회고</title>
      <link>http://sculove.github.io/blog/2017/05/08/QWebview-plus/</link>
      <guid>http://sculove.github.io/blog/2017/05/08/QWebview-plus/</guid>
      <pubDate>Mon, 08 May 2017 04:12:44 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;“내가 좋아하는 프로그래밍으로 주식을 하면 더 재미있지 않을까?” 라는 생각으로&lt;br&gt;시작한 개인 프로젝트(&lt;a href=&quot;https://github.com/sculove/QWebview-plus&quot; rel=&quot;external nofollow noo
        
      
      </description>
      
      <content:encoded><![CDATA[<p>“내가 좋아하는 프로그래밍으로 주식을 하면 더 재미있지 않을까?” 라는 생각으로<br>시작한 개인 프로젝트(<a href="https://github.com/sculove/QWebview-plus" rel="external nofollow noopener noreferrer" target="_blank">QWebview-plus</a>)가 생각 외로 스타수가 붙었다.</p><p>따로 홍보도 하지 않았는데 몇몇 사람들이 사용하고 있는 것 같다.<br>작년 3월 정도에 뚝딱 만들었던 프로젝트였는데 지금까지 버려진 채로 놓여진게 개발자로서 조금 미안한 생각마저 든다.</p><p>사실 처음에는 프로그래밍으로 system-trading을 하면 수익을 올릴 수 있을 것 같은 막연한 생각이 들어 만들기 시작했다.<br>그래서 시작한 프로젝트가 <a href="https://github.com/sculove/xing-plus" rel="external nofollow noopener noreferrer" target="_blank">xing-api</a>이다. 처음에는 열심히 만들어서 실제 매매도 해보려고 준비까지 했었다.</p><img src="/blog/2017/05/08/QWebview-plus/trading.jpg"><p>하지만, 결국은 나보다 더 잘 할수 있는 분(<a href="mailto:cheesev4@gmail.com" rel="external nofollow noopener noreferrer" target="_blank">cheesev4@gmail.com</a>)에게 xing-api 프로젝트를 넘겨 주었다.</p><p>그렇게 한 이유는</p><ul><li>첫째. python으로 하다 보니 내 주력 언어가 아니어서 언어외 로 배워야할 게 많아서 좀 버거운 면이 있었다.</li><li>둘째. 내 주력언어인 JavaScript로 가능한 방법을 찾게 되었다.</li><li>셋째. 주 증권사가 키움인데, 이베스트 증권사를 사용하는게 번거로웠다.</li><li>넷째. 키움 오픈 API가 내 기준으로는 더 좋은 인터페이스로 보였다. 특히, 실시간 처리에 대해서는 더 사용하기 편했다.</li></ul><p>하지만 정작 지금까지 QWebview-plus는 방치하고 있다.</p><p>이 프로젝트를 해보면서 개인적으로 느낀 점은 크게 3가지이다.</p><h3 id="첫째-오픈소스에-대한-경험"><a href="#첫째-오픈소스에-대한-경험" class="headerlink" title="첫째. 오픈소스에 대한 경험?"></a>첫째. 오픈소스에 대한 경험?</h3><p>개인적으로 오픈소스를 몇개 해봤지만 대중적이지 못했다. 더불어, 열정적으로 개발도 해보지 못했다. 오히려 오픈소스를 하기 위한 프로젝트를 하려고 찾다보니 잘 안되었던 것 같다.<br>지금까지 내가 진행한 주식 관련한 프로젝트는 성공한 오픈소스는 아니다.<br>하지만, 홍보도 안했고, 대중적인 수요도 굉장히 적은 분야에서 여러 개발자들과 커뮤니케이션을 해봤던 경험은 개인적으로 나를 설레게하는데 충분했다고 생각한다.<br>상투적인 경험일지 모르지만, 그냥 하고 싶은 걸 해보는 게 정답인 것 같다.</p><h3 id="둘째-주식에-대한-나의-경험"><a href="#둘째-주식에-대한-나의-경험" class="headerlink" title="둘째. 주식에 대한 나의 경험?"></a>둘째. 주식에 대한 나의 경험?</h3><p>난 프로그래밍을 통한 매매를 하면 남들보다 많은 장점이 있고, 이를 이용하면 유리한 고지에서 많은 수익을 이룰수 있을거라고 생각했다. 하지만 몇가지 간과하지 못한 점이 있다. 우선, 내가 주식을 잘 못한다.<br>주식을 한지는 오래됐지만 정작 고민해보고 분석해본 적이 몇번 없었던 것 같다. 그냥 막연히 오르겠지. 또는 그냥 감으로, 소문으로 주식을 매매했던것 같다. 원칙도 없는데 프로그래밍을 해서 무엇하리?<br>아마 개발에서도 마찬가지인 것 같다. 기술적인 성숙도가 높다고 하더라도 그 비즈니스를 완벽하게 이해하지 못한 개발자는 훌륭한 개발자가 되지 못한다. 이 부분에서 난 크게 착각하고 있었던 것 같다.<br>좋은 연장이 결코 좋은 작품을 만들지는 안듯 프로그래밍을 좀 한다고 주식 프로그래밍을 잘 만들수 있는 것은 아닌것 같다.</p><h3 id="셋째-시스템-트레이닝을-하기전에-해야할-일"><a href="#셋째-시스템-트레이닝을-하기전에-해야할-일" class="headerlink" title="셋째. 시스템 트레이닝을 하기전에 해야할 일?"></a>셋째. 시스템 트레이닝을 하기전에 해야할 일?</h3><p>주식 데이터는 단순히 데이터를 보고 바로 유추할 수 있는 형태의 데이터가 아닌 걸 확인했다. 딥러닝과 같은 복잡한 개념을 이야기 하지 않더라도 데이터가 의미하는 바를 해석하고 분석하는 능력이 선행되어야 전략이나 원칙을 세울수 있는 것을 경험했다.<br>이건 어떻게 보면 내가 주식에 대한 이해가 부족한 것도 영향이 있지만, 실제 나오는 데이터가 의미하는 바를 명확하게 나타내는 작업이 선행되어야 한다는 것을 알았다. 그래야 매매라는 것도 시작해 볼 수 있을 것 같다.</p><h2 id="그래서-앞으로-어떻게-할지에-대한-내-결론은-이렇다"><a href="#그래서-앞으로-어떻게-할지에-대한-내-결론은-이렇다" class="headerlink" title="그래서 앞으로 어떻게 할지에 대한 내 결론은 이렇다."></a>그래서 앞으로 어떻게 할지에 대한 내 결론은 이렇다.</h2><ul><li>첫째. 현재 투자하는 모든 금액을 회수하고, 가능성이 있을 경우 투자하기로 했다.</li><li>둘째. 주식 공부를 먼저 할 필요가 있을 것 같다. 좀 체계적으로 해봐야겠다. 아직 방법은 잘 모르겠지만. 이 부분에 대해서는 별도로 생각해봐야겠다.</li><li>셋째. 버려진 QWebview-plus를 매매용이 아닌 <code>분석의 목적</code>으로 활용하고 발전시킬 필요가 있을 것 같다. 이건 개인적으로 관심있는 기술 스택으로 만드면서 접근해 볼 수 있을 것 같다.</li></ul><p>주식이 본업이 아닌 이상. 취미생활로 긴 호흡으로 즐기면서 해봐야겠다.</p>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2017/05/08/QWebview-plus/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Angular4 구글은 어떻게 성능 개선을 했나?</title>
      <link>http://sculove.github.io/blog/2017/04/21/Angular4/</link>
      <guid>http://sculove.github.io/blog/2017/04/21/Angular4/</guid>
      <pubDate>Fri, 21 Apr 2017 13:01:43 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;Angular4-구글은-어떻게-성능-개선을-했나&quot;&gt;&lt;a href=&quot;#Angular4-구글은-어떻게-성능-개선을-했나&quot; class=&quot;headerlink&quot; title=&quot;Angular4 구글은 어떻게 성능 개선을 했나?&quot;&gt;&lt;/a&gt;Angular
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Angular4-구글은-어떻게-성능-개선을-했나"><a href="#Angular4-구글은-어떻게-성능-개선을-했나" class="headerlink" title="Angular4 구글은 어떻게 성능 개선을 했나?"></a>Angular4 구글은 어떻게 성능 개선을 했나?</h3><img src="/blog/2017/04/21/Angular4/angular4-icon.png"><p>Angular 2.x 대비 Angular 4.x에서 바뀐점을 살펴보고,<br>구글은 어떻게 성능 개선을 했는지에 대해 방법론적으로 살펴본다.</p><p>이 발표자료는 구글에서 공유한 <a href="https://docs.google.com/document/d/195L4WaDSoI_kkW094LlShH6gT3B7K1GZpSBnnLkQR-g/preview" rel="external nofollow noopener noreferrer" target="_blank">ViewEngine Design</a> 문서와<br>Angular4 릴리즈 소식을 전하는 <a href="http://angularjs.blogspot.kr/2017/03/angular-400-now-available.html" rel="external nofollow noopener noreferrer" target="_blank">Blog</a> 내용을 참고하여 작성하였습니다.</p><iframe src="https://sculove.github.io/slides/angular4/" width="100%" height="500px" frameborder="0" allowfullscreen></iframe><p>자료 : <a href="https://sculove.github.io/slides/angular4/">https://sculove.github.io/slides/angular4/</a></p>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2017/04/21/Angular4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>KAIST 강의. 산업에 적용된 오픈소스</title>
      <link>http://sculove.github.io/blog/2017/03/24/kaist/</link>
      <guid>http://sculove.github.io/blog/2017/03/24/kaist/</guid>
      <pubDate>Fri, 24 Mar 2017 04:57:47 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;KAIST-강의-산업에-적용된-오픈소스&quot;&gt;&lt;a href=&quot;#KAIST-강의-산업에-적용된-오픈소스&quot; class=&quot;headerlink&quot; title=&quot;KAIST 강의. 산업에 적용된 오픈소스&quot;&gt;&lt;/a&gt;KAIST 강의. 산업에 적용된 오픈소스
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="KAIST-강의-산업에-적용된-오픈소스"><a href="#KAIST-강의-산업에-적용된-오픈소스" class="headerlink" title="KAIST 강의. 산업에 적용된 오픈소스"></a>KAIST 강의. 산업에 적용된 오픈소스</h3><img src="/blog/2017/03/24/kaist/open-source-software-1.jpg"><p>KAIST 학생 대상으로 <code>산업에 적용된 오픈소스</code>라는 주제로 발표한 내용입니다.<br>학생 입장에서 <code>직장인 개발자</code>의 삶(?)과 <code>오픈 소스</code>의 가치가 무엇인지 설명하였습니다.</p><h4 id="발표-자료"><a href="#발표-자료" class="headerlink" title="발표 자료"></a>발표 자료</h4><iframe src="http://sculove.github.io/slides/university/" width="100%" height="500px" frameborder="0" allowfullscreen></iframe><p>자료 : <a href="http://sculove.github.io/slides/university/">http://sculove.github.io/slides/university/</a></p><h4 id="발표한-행사-정보"><a href="#발표한-행사-정보" class="headerlink" title="발표한 행사 정보"></a>발표한 행사 정보</h4><p>[2017.03.24] 카이스트 수업</p>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2017/03/24/kaist/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Sinon으로 JSONP 테스트하기</title>
      <link>http://sculove.github.io/blog/2016/12/30/test-jsonp-using-sinonjs/</link>
      <guid>http://sculove.github.io/blog/2016/12/30/test-jsonp-using-sinonjs/</guid>
      <pubDate>Thu, 29 Dec 2016 23:30:05 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;예전 &lt;a href=&quot;http://sculove.github.io/blog/2016/05/17/JavascriptTest/&quot;&gt;JavaScript&lt;/a&gt; 테스트 라는 글을 쓴적이 있는데, 그때 더 살펴봐야겠다라고 생각한 라이브러리가 Sinon.js
        
      
      </description>
      
      <content:encoded><![CDATA[<p>예전 <a href="http://sculove.github.io/blog/2016/05/17/JavascriptTest/">JavaScript</a> 테스트 라는 글을 쓴적이 있는데, 그때 더 살펴봐야겠다라고 생각한 라이브러리가 Sinon.js이다.</p><p>최근에는 Jasmine 테스트 프레임워크가 괜찮아 보여 등안시 하다가, 기회가 되서 Sinon.js를 쓰게 되었다.<br><img src="/blog/2016/12/30/test-jsonp-using-sinonjs/sinonjs.jpeg"></p><p>Jasmine에서 Ajax를 mocking 하려면 <code>stubRequest</code>를 만들고 <code>andReturn</code>이라는 메소드를 이용하여 직관적으로 테스트 할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jasmine.Ajax.stubRequest(<span class="string">"/another/url"</span>).andReturn(&#123;</span><br><span class="line">  responseText: <span class="string">"immediate response"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>sinon도 있지 않을까 하는 마음으로 찾다가 결국 <code>yieldsTo</code> 라는 메소드를 찾았다.<br>원래는 jQuery ajax mocking 정도는 <a href="http://sinonjs.org/docs/#server" rel="external nofollow noopener noreferrer" target="_blank">useFakeXMLHttpRequest</a> 메소드를 이용하면 되지만,<br><a href="http://sinonjs.org/docs/#json-p" rel="external nofollow noopener noreferrer" target="_blank">JSONP인 경우</a>는 호출 방식이 다르기 때문에, useFakeXMLHttpRequest으로는 mocking이 어렵다.</p><h3 id="Sinon-js로-JSONP를-테스트-하려면…"><a href="#Sinon-js로-JSONP를-테스트-하려면…" class="headerlink" title="Sinon.js로 JSONP를 테스트 하려면…"></a>Sinon.js로 JSONP를 테스트 하려면…</h3><p>stub에게 callback을 호출하도록 시키는 <code>yieldsTo</code> 메소드를 이용하여, mocking 해야만 한다.<br>물론, <code>fakeServer</code> 를 이용하여 mocking 할수 있지만,<br><code>yieldsTo</code>가 훨~~~씬 간편하다.</p><p>코드는 다음과 같다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// beforeEach</span></span><br><span class="line"><span class="keyword">let</span> stub = sinon.stub(jQuery, <span class="string">"ajax"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Given</span></span><br><span class="line">stub.yieldsTo(<span class="string">"success"</span>, &#123; <span class="attr">param</span>: <span class="string">"데이터"</span>, <span class="attr">data</span>: <span class="string">"bla bla"</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// When</span></span><br><span class="line">jQuery.ajax(</span><br><span class="line">    url: <span class="string">"http://sculove.github.io"</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"callback"</span>) &#125;,</span><br><span class="line">    dataType: <span class="string">"jsonp"</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Then</span></span><br><span class="line">expect...</span><br><span class="line"></span><br><span class="line"><span class="comment">// afterEach</span></span><br><span class="line">stub.restore();</span><br></pre></td></tr></table></figure><p>주의할 것은 ajax를 실행하기 전에 이미 yieldsTo에 대한 정보를 미리 설정해놓아야 한다.</p><ul><li>Sinon.js API : <a href="http://sinonjs.org/docs/" rel="external nofollow noopener noreferrer" target="_blank">http://sinonjs.org/docs/</a></li><li>관련 이슈 : <a href="https://github.com/sinonjs/sinon/issues/41" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/sinonjs/sinon/issues/41</a></li></ul>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2016/12/30/test-jsonp-using-sinonjs/#disqus_thread</comments>
    </item>
    
    <item>
      <title>addEventListener의 요상한 옵션들 중의 하나 Passive</title>
      <link>http://sculove.github.io/blog/2016/12/29/addEventListener-passive/</link>
      <guid>http://sculove.github.io/blog/2016/12/29/addEventListener-passive/</guid>
      <pubDate>Thu, 29 Dec 2016 06:23:24 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;iScroll contribution을 하다가 우연히 알게된 이슈가 있어 몇자 적어본다.&lt;/p&gt;
&lt;p&gt;Chrome 49부터 &lt;a href=&quot;https://github.com/WICG/EventListenerOptions/blob/gh-pages/
        
      
      </description>
      
      <content:encoded><![CDATA[<p>iScroll contribution을 하다가 우연히 알게된 이슈가 있어 몇자 적어본다.</p><p>Chrome 49부터 <a href="https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md" rel="external nofollow noopener noreferrer" target="_blank">EventListenerOptions</a> 옵션을 지원한다.</p><p>기존 addEventListener의 3번째 파라미터로 캡쳐링/버블링 여부를 제어할 수 있는 부분이 <code>EventListenerOptions</code>이라는 객체형태의 추가 옵션을 받을수 있게 되었다.</p><p>jQuery를 쓸 이유가 하나씩 줄고 있다. 허허허</p><h5 id="EventListenerOptions-사용-전"><a href="#EventListenerOptions-사용-전" class="headerlink" title="EventListenerOptions 사용 전"></a>EventListenerOptions 사용 전</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&apos;touchstart&apos;, handler, false);</span><br></pre></td></tr></table></figure><h5 id="EventListenerOptions-사용-후"><a href="#EventListenerOptions-사용-후" class="headerlink" title="EventListenerOptions 사용 후"></a>EventListenerOptions 사용 후</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"touchstart"</span>, handler, &#123;</span><br><span class="line">  capture: <span class="literal">false</span>,</span><br><span class="line">  once: <span class="literal">false</span>,</span><br><span class="line">  passive: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>현재 크롬에서 지원하는 EventListenerOptions 옵션은 다음과 같다.</p><ul><li>capture: 이벤트 캡쳐링 적용 여부. <a href="https://www.chromestatus.com/feature/5718574840676352" rel="external nofollow noopener noreferrer" target="_blank">크롬 49부터 지원</a></li><li>once: 이벤트를 한번만 호출하고 해제되는 옵션. <a href="https://developers.google.com/web/updates/2016/10/addeventlistener-once" rel="external nofollow noopener noreferrer" target="_blank">크롬 55부터 지원</a></li><li>passive: 스크롤 성능 향상을 위한 옵션으로 <code>true</code>일 경우, 스크롤을 위해 블록되는 것을 방지한다. 이 경우, <code>preventDefault</code>를 사용할 수 없다. <a href="https://developers.google.com/web/updates/2016/06/passive-event-listeners" rel="external nofollow noopener noreferrer" target="_blank">크롬 51부터 지원</a></li></ul><p>이 중, passive 속성은 성능향상을 위해, 브라우저의 기능을 프로그래밍으로 제어할수 있다.</p><h3 id="오"><a href="#오" class="headerlink" title="오~~"></a>오~~</h3><blockquote><p>passive 속성에 대한 링크<br><a href="https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md</a></p></blockquote><p>passive 속성이 <code>false</code>인 경우에 touchstart, touchmove와 같은 이벤트가 발생하면 preventDefault를 이용하여 실제 이벤트 자체를 막을 수 있기 때문에, 브라우저는 scroll을 계속 할지 안할지를 매번 감시해야만 한다.<br>하지만, passive 속성이 <code>true</code>일 경우에는 <code>preventDefault를 이용하여 scroll 이벤트를 막지 않겠다</code>고 브라우저에게 이야기하는 것과 같다. 따라서, 이 룰을 어기면 브라우저는 가차없이 다음과 같은 에러를 던진다.</p><p>다행이 passive 속성의 기본값은 <code>false</code> 이기 때문에, 기존 코드는 문제가 되지 않는다.</p><h2 id="하지만…"><a href="#하지만…" class="headerlink" title="하지만…"></a>하지만…</h2><p><code>Chrome 54+</code> 부터 EventListenerOptions의 passive 속성이 특별한 상황일 경우에는 기본값이 <code>true</code>로 설정된다.</p><blockquote><p>document또는 body에 이벤트 리스너를 추가할때, touchstart, touchmove와 같이 스크롤이 블록되는 이벤트인 경우, passive의 기본 속성값은 true가 된다.</p></blockquote><p>예를 들어 다음과 같은 코드는</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(</span><br><span class="line">  <span class="string">"touchmove"</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>아래와 같은 무시무시한 에러가 발생한다.</p><p>혹시 이런 코드가 있으면 아래 같이 수정하시면 된다. 짜잔~!</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(</span><br><span class="line">  <span class="string">"touchmove"</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;,</span><br><span class="line">  isPassive()</span><br><span class="line">    ? &#123;</span><br><span class="line">        capture: <span class="literal">false</span>,</span><br><span class="line">        passive: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    : <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>여기 사용한 isPassive 함수는 passive 속성 여부를 확인하는 유틸 함수이고, 상세 구현은 다음과 같다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPassive</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> supportsPassiveOption = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    addEventListener(</span><br><span class="line">      <span class="string">"test"</span>,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">"passive"</span>, &#123;</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">          supportsPassiveOption = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> supportsPassiveOption;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/cubiq/iscroll/blob/master/demos/demoUtils.js#L2-L12" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/cubiq/iscroll/blob/master/demos/demoUtils.js#L2-L12</a></p><p>앞으로는 브라우저 내부를 점점 프로그램으로 제어할수 있는 API들이 쏟아질 것 같다.<br>웹개발을 하는 입장에서는 굉장히 좋은 방향성 같다.</p>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2016/12/29/addEventListener-passive/#disqus_thread</comments>
    </item>
    
    <item>
      <title>console.log를 지워야하는 이유</title>
      <link>http://sculove.github.io/blog/2016/12/02/you-should-remove-consolelog/</link>
      <guid>http://sculove.github.io/blog/2016/12/02/you-should-remove-consolelog/</guid>
      <pubDate>Fri, 02 Dec 2016 05:27:43 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;서비스 개발시에, 테스트용으로 console.log를 찍으시나요?&lt;br&gt;실수로 또는 의도적으로 실서비스에서도 이런 로그가 찍힐 수도 있는데요.&lt;/p&gt;
&lt;h3 id=&quot;테스트나-디버깅용으로-쓰는-이런-로그로-인해-실서비스에서는-메모리-릭이-발생할-수
        
      
      </description>
      
      <content:encoded><![CDATA[<p>서비스 개발시에, 테스트용으로 console.log를 찍으시나요?<br>실수로 또는 의도적으로 실서비스에서도 이런 로그가 찍힐 수도 있는데요.</p><h3 id="테스트나-디버깅용으로-쓰는-이런-로그로-인해-실서비스에서는-메모리-릭이-발생할-수-있습니다"><a href="#테스트나-디버깅용으로-쓰는-이런-로그로-인해-실서비스에서는-메모리-릭이-발생할-수-있습니다" class="headerlink" title="테스트나 디버깅용으로 쓰는 이런 로그로 인해, 실서비스에서는 메모리 릭이 발생할 수 있습니다."></a>테스트나 디버깅용으로 쓰는 이런 로그로 인해, 실서비스에서는 메모리 릭이 발생할 수 있습니다.</h3><p>저도 우연히 개발 중에 알게되었답니다…</p><p>아래는 Observable 코드를 1000개 만드는 코드입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeObservable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Rx.Observable.generate(</span><br><span class="line">    performance.now(),</span><br><span class="line">    x =&gt; x &lt;= startTime + duration,</span><br><span class="line">    x =&gt; performance.now(),</span><br><span class="line">    x =&gt; (x - startTime) / duration,</span><br><span class="line">    Rx.Scheduler.animationFrame</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onMemory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"create observable"</span>, i, makeObservable());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo link : <a href="http://jsbin.com/hohoxifipu/1" rel="external nofollow noopener noreferrer" target="_blank">http://jsbin.com/hohoxifipu/1</a></p><p>makeObservable()을 통해 instance를 반환하고, onMemory에서 1000번 반복합니다.<br>코드 상으로는 instance 변수가 사용되지 않기 때문에, <code>메모리가 정상적으로 릴리즈 되어야합니다.</code></p><p>하지만, 결과는 다음과 같이 메모리 릭이 발생합니다.</p><img src="/blog/2016/12/02/you-should-remove-consolelog/before.png"><img src="/blog/2016/12/02/you-should-remove-consolelog/memoryleak.png"><p>보시는 바와 같이 System Object가 굉장히 많이 증가하는 것을 보실 수 있습니다.</p><h3 id="이유는-바로-console-log-때문입니다"><a href="#이유는-바로-console-log-때문입니다" class="headerlink" title="이유는 바로 console.log 때문입니다."></a>이유는 바로 console.log 때문입니다.</h3><p>저도 이슈 문의했다가 알게된 사항입니다.</p><p><a href="https://github.com/ReactiveX/rxjs/issues/2090#issuecomment-256844948" rel="external nofollow noopener noreferrer" target="_blank"><img src="/blog/2016/12/02/you-should-remove-consolelog/bingo.png"></a></p><blockquote><p>Chrome Devtool에서 정보를 표현하기 위해,<br>console.log를 사용할때 내부적으로 reference를 저장하게 된답니다.<br>그래서, 결국은 메모리가 해제되지 않고. 메모리 릭이 발생하게 됩니다.</p></blockquote><p>실제로 console.log만 지워보았습니다.</p><p>짜잔~!<br><img src="/blog/2016/12/02/you-should-remove-consolelog/after.png"></p><p>메모리가 정상적으로 릴리즈되는 것을 확인 할수 있습니다.</p><h2 id="우리-모두-서비스에서-찍는-console-log…-꼭-지웁시다"><a href="#우리-모두-서비스에서-찍는-console-log…-꼭-지웁시다" class="headerlink" title="우리 모두 서비스에서 찍는 console.log…. 꼭! 지웁시다~ ^^"></a>우리 모두 서비스에서 찍는 console.log…. 꼭! 지웁시다~ ^^</h2>]]></content:encoded>
      
      <comments>http://sculove.github.io/blog/2016/12/02/you-should-remove-consolelog/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Angular1 Digest Loop 개선하기</title>
      <link>http://sculove.github.io/blog/2016/12/02/improve-angular1-digestloop/</link>
      <guid>http://sculove.github.io/blog/2016/12/02/improve-angular1-digestloop/</guid>
      <pubDate>Fri, 02 Dec 2016 04:55:20 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Angular1은 높은 생산성을 갖는 좋은 프레임워크이긴 하지만, 성능 부분은 아쉬운 점이 많이 있습니다.&lt;br&gt;그 중 하나로, 데이터 동기화를 처리하는 &lt;code&gt;Digest Loop&lt;/code&gt;에 대한 이야기를 많이 합니다.&lt;br&gt;아쉽지만, 
        
      
      </description>
      
      <content:encoded><![CDATA[<p>Angular1은 높은 생산성을 갖는 좋은 프레임워크이긴 하지만, 성능 부분은 아쉬운 점이 많이 있습니다.<br>그 중 하나로, 데이터 동기화를 처리하는 <code>Digest Loop</code>에 대한 이야기를 많이 합니다.<br>아쉽지만, 이 부분은 Angular1을 만들때 챙기지 못한 부분 중에 하나죠.</p><p>이 부분에 대한 튜닝 가이드는 지금까지 굉장히 정리가 잘된 자료 들이 많이 있습니다.</p><ul><li><a href="https://www.alexkras.com/11-tips-to-improve-angularjs-performance/" rel="external nofollow noopener noreferrer" target="_blank">https://www.alexkras.com/11-tips-to-improve-angularjs-performance/</a></li><li><a href="https://speakerdeck.com/avivby/angular-performance-101" rel="external nofollow noopener noreferrer" target="_blank">https://speakerdeck.com/avivby/angular-performance-101</a></li></ul><h3 id="하지만-정작-Digest-문제가-발생했을-때-어떻게-찾아야하는-지에-대한-이야기는-아쉽지만-아무도-이야기-해주지-않습니다"><a href="#하지만-정작-Digest-문제가-발생했을-때-어떻게-찾아야하는-지에-대한-이야기는-아쉽지만-아무도-이야기-해주지-않습니다" class="headerlink" title="하지만, 정작 Digest 문제가 발생했을 때, 어떻게 찾아야하는 지에 대한 이야기는 아쉽지만 아무도 이야기 해주지 않습니다."></a>하지만, 정작 Digest 문제가 발생했을 때, 어떻게 찾아야하는 지에 대한 이야기는 아쉽지만 아무도 이야기 해주지 않습니다.</h3><p>우선 FE좀 해본 개발자라면, 성능 문제가 발생했을 때,<br>크롬의 DevTool을 열고, Timeline을 열어서 문제의 원인을 찾으려고 합니다.</p><p>짜잔. 다음과 같습니다.<br><img src="/blog/2016/12/02/improve-angular1-digestloop/hell.png"></p><p>해당 서비스 개발자가 봐도 이 많은 호출 스택에서 뭐가 문제인지를 찾아내기는 쉽지가 않습니다.<br>더군다나 저같이 잠시 지원한 입장에서 Timeline만을 갖고 이 문제의 원인을 찾기는 정말 쉬운 문제가 아닙니다.<br>단지, “Digest Loop가 많이 도는 구나” 정도를 알수는 있겠죠.</p><h3 id="Digest-Loop"><a href="#Digest-Loop" class="headerlink" title="Digest Loop"></a>Digest Loop</h3><p>Angular의 Digest Loop는 Watcher 수와 Watcher Expression의 수행시간에 비례합니다.</p><blockquote><p>Digest Loop = Wacher 수 * Wacher Expression 호출 시간</p></blockquote><h4 id="따라서-Digest-Loop에-의해-성능-문제가-발생했을때-이를-해결하는-방법은-크게-3가지-입니다"><a href="#따라서-Digest-Loop에-의해-성능-문제가-발생했을때-이를-해결하는-방법은-크게-3가지-입니다" class="headerlink" title="따라서, Digest Loop에 의해 성능 문제가 발생했을때 이를 해결하는 방법은 크게 3가지 입니다."></a>따라서, Digest Loop에 의해 성능 문제가 발생했을때 이를 해결하는 방법은 크게 3가지 입니다.</h4><ol><li>Watcher 수를 줄이는 방법</li><li>Watcher Expression 호출 시간을 줄이는 방법</li><li>Digest Loop를 호출 수를 줄이는 방법</li></ol><p>물론, Angular1의 <a href="https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk" rel="external nofollow noopener noreferrer" target="_blank">Batarang</a> 을 이용하여, Digest Loop가 어떻게 도는지 확인 할 수는 있습니다.<br>아래 보시는 것 처럼, <code>얼마나 많이 발생하고, 어떤 Watcher Expression이 많이 도는지는 확인 할수 있습니다.</code><br><img src="/blog/2016/12/02/improve-angular1-digestloop/batarang1.png"><br><img src="/blog/2016/12/02/improve-angular1-digestloop/batarang2.png"></p><h3 id="그런데-정작-이렇게-많이-발생하는-Digest-Loop가-어디서-발생하는지를-찾아내는-방법은-없습니다"><a href="#그런데-정작-이렇게-많이-발생하는-Digest-Loop가-어디서-발생하는지를-찾아내는-방법은-없습니다" class="headerlink" title="그런데, 정작, 이렇게 많이 발생하는 Digest Loop가 어디서 발생하는지를 찾아내는 방법은 없습니다."></a>그런데, 정작, 이렇게 많이 발생하는 Digest Loop가 어디서 발생하는지를 찾아내는 방법은 없습니다.</h3><h2 id="Digest-Loop를-유발하는-곳-손쉽게-찾는-방법"><a href="#Digest-Loop를-유발하는-곳-손쉽게-찾는-방법" class="headerlink" title="Digest Loop를 유발하는 곳 손쉽게 찾는 방법"></a>Digest Loop를 유발하는 곳 손쉽게 찾는 방법</h2><p>Angular는 기본적으로 <code>비동기 시점이 종료되는 시점</code>에 digest가 호출됩니다.<br>따라서, <code>Ajax call이 발생하는 부분, timeout/interval이 종료되는 부분, ng-click과 같이 사용자 이벤트</code>가 호출되는 부분에서 digest loop가 호출됩니다.</p><p>사용자 이벤트가 호출되는 부분은 사용자가 명시적으로 하는 행위이기 때문에, 발생시점과 발생하는 곳을 가급적 쉽게 찾을수 있습니다.<br>다만, Ajax call 이나, timeout/interval은 코드에 녹아 있기 때문에, 찾기가 쉽지 않습니다.</p><p>이를 쉽게 확인하는 방법은 사실 간단합니다.<br>바로, Angular 소스 코드에서 Digest Loop가 발생하는 시점에 <a href="https://developers.google.com/web/tools/chrome-devtools/console/console-reference" rel="external nofollow noopener noreferrer" target="_blank">크롬 로그</a>를 찍는 방법입니다.<br>단순 로그 출력이지만, 그 효과는 큽니다.</p><ol><li>크롬에서 console.trace 로그를 찍으면 다음과 같이 호출 스택을 확인할 수 있으며, <code>해당 소스로의 이동이 가능</code>합니다.  <img src="/blog/2016/12/02/improve-angular1-digestloop/trace.png"></li><li>크롬에서 function 을 로그로 찍으면 <code>해당 소스로의 이동이 가능</code>합니다.  <img src="/blog/2016/12/02/improve-angular1-digestloop/moveTosource.gif"></li><li>크롬에서 console.time/timeEnd를 사용하시면, Timeline 탭에서 로그를 확인 할수 있습니다.  <img src="/blog/2016/12/02/improve-angular1-digestloop/consoletime.png"></li><li>크롬에서 console.count를 사용할 경우, 몇번 호출되었는지 로그를 통해 알수 있습니다.<img src="/blog/2016/12/02/improve-angular1-digestloop/consolecount.png"></li></ol><h2 id="Angular-1-5-8-로그-추가-버전"><a href="#Angular-1-5-8-로그-추가-버전" class="headerlink" title="Angular 1.5.8 로그 추가 버전"></a>Angular 1.5.8 로그 추가 버전</h2><p>능력 부족과 시간 부족으로 툴은 못 만들었지만, Angular 1.5.8 소스에 로그를 찍어 봤습니다.<br><a href="angular.js.1.5.8.zip">angular.js.1.5.8.zip</a></p><p>개발시에 Angular.js 파일을 교체하시면 크롬 콘솔에서 로그를 바로 확인할 수 있습니다.<br><img src="/blog/2016/12/02/improve-angular1-digestloop/result.png"></p><p>그 외 angular 버전에 적용하시려면 다음 코드 조각을 참조하시기 바랍니다.</p><h4 id="ajax-httpProvider를-이용"><a href="#ajax-httpProvider를-이용" class="headerlink" title="ajax - \$httpProvider를 이용"></a>ajax - \$httpProvider를 이용</h4><p>Ajax의 경우 Angular 코드에 로그를 삽입하는게 아니라, HTTP interceptor를 등록해서 호출 여부를 확인할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$httpProvider.useApplyAsync(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP 인터셉터</span></span><br><span class="line">$httpProvider.interceptors.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    request: <span class="function"><span class="keyword">function</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.time(<span class="string">"[http] "</span>, request.url);</span><br><span class="line">      <span class="keyword">return</span> request;</span><br><span class="line">    &#125;,</span><br><span class="line">    response: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.timeEnd(<span class="string">"[http] "</span> + response.config.url);</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="timeout-angular-소스-수정"><a href="#timeout-angular-소스-수정" class="headerlink" title="timeout - angular 소스 수정"></a>timeout - angular 소스 수정</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">fn, delay, invokeApply</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//... 생략</span></span><br><span class="line">  timeoutId = $browser.defer(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// [Start] $timeout에 의해 rootScope.apply가 호출된 경우</span></span><br><span class="line">      !skipApply &amp;&amp; <span class="built_in">console</span>.warn(<span class="string">"from timeout"</span>, fn, delay);</span><br><span class="line">      <span class="comment">// [End] $timeout에 의해 rootScope.apply가 호출된 경우</span></span><br><span class="line">      deferred.resolve(fn.apply(<span class="literal">null</span>, args));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      deferred.reject(e);</span><br><span class="line">      $exceptionHandler(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">delete</span> deferreds[promise.$$timeoutId];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!skipApply) $rootScope.$apply();</span><br><span class="line">  &#125;, delay);</span><br><span class="line">  <span class="comment">//... 생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="interval-angular-소스-수정"><a href="#interval-angular-소스-수정" class="headerlink" title="interval - angular 소스 수정"></a>interval - angular 소스 수정</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function interval(fn, delay, count, invokeApply) &#123;</span><br><span class="line">  //...생략</span><br><span class="line">  function callback() &#123;</span><br><span class="line">    // [Start] $interval에 의해 rootScope.apply가 호출된 경우</span><br><span class="line">    !skipApply &amp;&amp; console.warn(&quot;from interval&quot;, fn, delay);</span><br><span class="line">    // [End] $interval에 의해 rootScope.apply가 호출된 경우</span><br><span class="line">    if (!hasParams) &#123;</span><br><span class="line">      fn(iteration);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      fn.apply(null, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="digest-함수-angular-소스-수정"><a href="#digest-함수-angular-소스-수정" class="headerlink" title="digest 함수 - angular 소스 수정"></a>digest 함수 - angular 소스 수정</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$digest: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// [Start] $digest가 호출된 경우</span></span><br><span class="line">  <span class="built_in">console</span>.trace(<span class="string">"digest trace"</span>);</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">"digest time"</span>);</span><br><span class="line">  <span class="comment">// [End] $digest가 호출된 경우</span></span><br><span class="line">  beginPhase(<span class="string">'$digest'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//... 생략</span></span><br><span class="line">  <span class="keyword">do</span> &#123; <span class="comment">// "while dirty" loop</span></span><br><span class="line">    <span class="comment">//... 생략</span></span><br><span class="line">    <span class="keyword">do</span> &#123; <span class="comment">// "traverse the scopes" loop</span></span><br><span class="line">      <span class="comment"