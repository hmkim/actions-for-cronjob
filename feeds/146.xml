<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title>Jeremy's Blog</title>
  <link rel="alternate" href="https://sungjk.github.io/"/>
  <link type="application/atom+xml" rel="self" href="https://sungjk.github.io/feed.xml"/>
  <updated>2019-05-07T14:12:36+00:00</updated>
  <id>https://sungjk.github.io/</id>
  <author>
    <name>Jeremy</name>
    <email>ajax0615@gmail.com</email>
  </author>

  
      
      <entry>
        <id>https://sungjk.github.io/2019/05/03/uml-for-java-programmers-3.html</id>
        <link type="text/html" rel="alternate" href="https://sungjk.github.io/2019/05/03/uml-for-java-programmers-3.html"/>
        <title>JAVA 프로그래머를 위한 UML - 3</title>
        <updated>2019-05-03T00:00:00+00:00</updated>
        <author>
          <name>김성중</name>
          <email>ajax0615@gmail.com</email>
        </author>
        <content type="html">&lt;h1 id=&quot;7-실천-방법-dx&quot;&gt;7. 실천 방법: dX&lt;/h1&gt;
&lt;p&gt;여러 개발자가 짧은 시간에 많은 일을 할 수 있도록 돕는 단순한 규칙의 집합을 dX라고 하자.&lt;/p&gt;

&lt;h3 id=&quot;반복적인-개발&quot;&gt;반복적인 개발&lt;/h3&gt;
&lt;p&gt;dX 핵심은 '모든 것'을 '짧은' 주기로 반복하는 것이다. 요구사항, 분석, 설계, 구현, 테스팅, 문서화 등 정말 '모든 것'이 다 포함된다. 그리고 짧은 주기는 한 주 또는 두 주를 의미한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;최초의 탐사 작업&lt;br /&gt;
요구사항 정의하기.&lt;/li&gt;
  &lt;li&gt;각 기능의 추정치 잡기&lt;br /&gt;
추정치에 대한 단위에 신경을 쓰지 않고, 오직 다른 스토리와 크기를 비교할 수 있는 상대적인 크기에만 주의를 기울인다.&lt;/li&gt;
  &lt;li&gt;스파이크&lt;br /&gt;
이틀이나 사흘 정도 시간을 내서 흥미로운 스토리를 두 세개 간략하게 구현해본다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;계획-짜기&quot;&gt;계획 짜기&lt;/h3&gt;
&lt;p&gt;계획에서는 단순히 현재 작업 속도로 주기마다 어떤 스토리들을 완수할 수 있을지 파악한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;릴리스 계획하기&lt;br /&gt;
가장 중요하고 비용 대비 효율이 높은 스토리들을 고르고, 이 스토리가 릴리스 계획이 된다.&lt;/li&gt;
  &lt;li&gt;반복 주기를 계획하기&lt;br /&gt;
비즈니스 가치가 낮고 비싼 스토리보다 비즈니스 가치가 높고 비용이 싼 스토리를 먼저 골라야 한다. 누군가 개발자에게 태스크를 맡으라고 정하는 것이 아니라, 개발자가 태스크에 스스로 사인한다. 그리고 자신이 사인하는 태스크의 양을 추정하는 것도 개발자에게 맡긴다.&lt;/li&gt;
  &lt;li&gt;중간 지점&lt;br /&gt;
지금까지 완료된 스토리 점수는 끝마친 스토리의 추정치만 모두 더해서 계산한다.&lt;/li&gt;
  &lt;li&gt;결과를 속도에 반영하기&lt;br /&gt;
주기마다 얼마나 많은 스토리 점수를 완수하는지 측정해 보고 다음 주기에는 그만큼만 사인한다. 개인마다 지난번 주기에서 얼마나 많은 인-시간(man-hours) 분량만큼 태스크를 끝마쳤는지 재보고, 다음 주기에는 오직 그만큼만 사인해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;반복-주기를-관리-단계로-조직하기&quot;&gt;반복 주기를 관리 단계로 조직하기&lt;/h3&gt;
&lt;p&gt;통합 공정(Unified Process)에 따르면 프로젝트에는 네 가지 관리 단계가 있다. 도입 단계(Inception phase)에서는 시스템이 실행될 수 있는지, 어떤 비즈니스 사례인지 결정하기 위해 노력한다. 정련 단계(Elaboration phase)에서는 시스템의 아키텍처를 결정하고 믿을 수 있는 구현 계획을 작성한다. 구축 단계(Construction phase)에서는 시스템을 구축한다. 마지막으로, 전이 단계(Transition phase)에서는 시스템을 설치하고 사용자와 협력해서 시스템을 조율한다.&lt;/p&gt;

&lt;p&gt;통합 공정의 단계마다 반복 주기가 하나 이상 있으며, 주기마다 실제로 작동하는 코드가 결과물로 나온다. 단계가 바뀐다고 프로그래머에게 달라지는 것은 없다. 모든 단계는 비슷한 구조의 반복 주기들로 구성된다. 반복 주기의 구조는 스토리들을 찾아내고, 찾아낸 스토리의 작업량을 추정하고, 어떤 스토리를 구현할지 선택하고, 그것을 구현하는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;반복-주기에서는-어떤-일이-일어나는가&quot;&gt;반복 주기에서는 어떤 일이 일어나는가&lt;/h3&gt;
&lt;p&gt;한 번의 반복주기에 우리는 요구사항을 분석하고, 해결 방안을 설계하고, 그 해결 방안을 구현한다. 그리고 관심 범위는 '스토리들에만' 한정된다. 다음 주기에 선택될지도 모르는 다른 스토리들을 고려하지 않는다.&lt;/p&gt;

&lt;p&gt;이렇게 하면 최고의 아키텍처와 매우 유연한 설계를 얻게 되고 재작업도 아주 적어진다. 우리는 언제나 그 시점에서 가장 중요한 기능을 작업하기 때문이다. 다음 반복 주기에 구현하기로 예정된 기능은, 당연히 지금 작업하는 기능보다 덜 중요하다. 그러므로 우리는 언제나 그때 가장 중요한 것에 주목하는 셈이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;짝은 이뤄 개발하기&lt;br /&gt;
키보드를 다루는 사람은 한 사람일지 몰라도, 지금 무슨 일이 진행 중인지 둘 다 정확하게 알아야 한다.&lt;/li&gt;
  &lt;li&gt;인수 테스트&lt;br /&gt;
선택된 사용자 스토리에 살을 붙여 유스케이스를 만들고 선택한 스토리를 실행해 볼 수 있는 인수 테스트를 작성한다. 이 인수테스트는 주기가 절반 이상 지나기 전에 프로그래머에게 전달된다. 이 인수 테스트야 말로 진정한 요구사항 문서다. 인수 테스트는 보통 쉽게 자동화할 수 있는 고수준의 테스트용 언어로 작성한다.&lt;/li&gt;
  &lt;li&gt;단위 테스트&lt;br /&gt;
단위 테스트를 먼저 만들고, 실제 제품에 들어갈 코드를 작성하는 것이 규칙이다. 실패하는 단위 테스트를 통과하기 위해 작성한 것이 실제 코드의 모든 줄이 된다. 테스트는 문서화의 다른 형식이기도 하다. 특정한 API 함수를 호출하는 방법을 알고 싶다면, 그것을 하는 테스트가 있으니 보면 된다. 어떤 객체를 만드는 방법을 알고 싶다면, 역시 그것을 하는 테스트가 있으니 보면 된다. 테스트는 시스템에 있는 거의 모든 프로그래밍 작업의 예제 모음처럼 사용할 수 있다. 테스트는 뜻이 모호하지 않고, 정확하고, 컴파일할 수도 있으며 실행할 수도 있는 종류의 문서다.&lt;/li&gt;
  &lt;li&gt;리팩터링&lt;br /&gt;
한 무리의 단위 테스트와 인수 테스트의 지원을 받는 한, 우리는 두려움 없이 원하는 대로 무엇이든 변경할 수 있다. 리팩터링이란 시스템의 동작에는 변화 없이 프로그램의 구조만 개선하는 행동을 말한다. 개선 작업은 작은 단계로 나뉘는데, 각 단계가 끝날 때마다 테스트를 돌려 본다.&lt;/li&gt;
  &lt;li&gt;개방된 작업 공간&lt;br /&gt;
서로 자주 상호 작용하며 부담 없이 질문하거나 충고할 수 있고, 책상 옆에 기대어 서서 다른 사람의 코드를 볼 수도 있는 한 팀으로 함께 일하는 것이다.&lt;/li&gt;
  &lt;li&gt;끊임없이 통합 작업&lt;br /&gt;
dx에서는 락을 걸지 않는(nonblocking) 소스 컨트롤 시스템을 사용한다. 이 말은 다른 사람이 체크 아웃했더라도 아무 상관 없이 누구나 모듈을 체크 아웃할 수 있다는 뜻이다. 체크 인을 하기 전 반드시 모든 단위 테스트와 인수 테스트를 통과하는 것을 보여야 한다. 즉, 여러분이 체크인하기 전 반드시 여러분이 변경한 사항을 시스템에 완전히 통합시키고, 시스템을 빌드하고, 테스트해야 한다는 뜻이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;8-패키지&quot;&gt;8. 패키지&lt;/h1&gt;
&lt;p&gt;자바 프로그래머에게 중요한 패키지는 두 종류다. 하나는 자바의 package 키워드로 나타내는 소스코드 패키지고, 다른 하나는 .jar 파일로 나타내는 바이너리 컴포넌트다.&lt;/p&gt;

&lt;p&gt;자바의 컴파일 시스템은 소스크드의 패키지 구조를 본떠 만든 디렉터리 구조 안에 생성한 이진 .class 파일들을 보관한다. 그리고 .java 파일이 아니라 .class 파일에서 외부 선언을 읽어 오므로, 컴파일러와 런타임 시스템 둘 다 애플리케이션에 포함된 패키지들의 클래스 경로(classpath)를 꼭 올바르게 알아야 한다.&lt;/p&gt;

&lt;p&gt;.jar 파일의 형태로 많은 바이너리 코드를 한데 묶어 컴포넌트로 만들고 싶을 때가 있다. 이런 컴포넌트는 여러 시스템에 배포할 때 편리하다.&lt;/p&gt;

&lt;h3 id=&quot;패키지-설계의-원칙&quot;&gt;패키지 설계의 원칙&lt;/h3&gt;
&lt;p&gt;이 원칙에 따라 나뉜 패키지의 목적은 자주 변경하는 클래스를 따로 모으고, 변경할 이유가 다른 클래스를 갈라놓는 것이다. 이 원칙들은 자주 변경하는 클래스와 그렇지 않은 클래스를 분리하려고 노력한다. 또한, 시스템의 고차원 아키텍처를 저차원의 세부사항과 분리하고, 이 고차원 아키텍처를 독립적으로 유지하려고 노력한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;패키지 릴리스/재사용 등가 원칙(The Release/Reuse Equivalency Principle, REP)&lt;/strong&gt;&lt;br /&gt;
다른 사람들이 편하게 재사용할 수 있는 패키지를 만드는 것도 클래스들을 패키지 안에 배치할 때 고려할 기준이다. 그러므로 재사용할 때 같이 몰려다니는 클래스들을 한 패키지로 묶어놓고, 이것들을 릴리스나 유지보수의 단위로 취급하면 만드는 사람이나 재사용하는 사람 모두 편하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;공통 폐쇄 원칙(The Common Closure Principle, CCP)&lt;/strong&gt;&lt;br /&gt;
단 하나의 책임 원칙(Single Responsibility Principle, SRP)에 따르면 모든 클래스는 그 클래스를 변경할 이유가 오직 하나뿐이어야 한다. 만약 어떤 것을 변경해야 한다면, 그것 때문에 바꾸어야 할 클래스들이 단 한 패키지에만 몰려 있기를 원한다. CCP의 목표는 변경 가능성이 비슷한 클래스들을 하나로 묶는 것이다. 이렇게 하면, 무엇을 바꿔야 할 경우 의존 관계 구조 안의 패키지들 가운데 매우 적은 수만 변경하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;공통 재사용 법칙(Common Reuse Principle, CRP)&lt;/strong&gt;&lt;br /&gt;
인터페이스 격리 원칙(Interface Segregation Principle, ISP)에 따르면 클래스의 클라이언트마다 따로따로 인터페이스를 만드는 것이 좋다. 한 클라이언트가 사용하는 클래스들과 다른 클라이언트가 사용하는 클래스들은 최대한 분리해야 한다. 서로 다른 클라이언트가 사용하는 클래스들이 한 패키지에 섞여 있을 경우, 패키지 안의 어떤 클래스를 바꾸면 그 변경된 클래스를 사용하지 않는 패키지들까지 그 변화의 영향을 받을 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;의존 관계 비순환 원칙(Acyclic Dependencies Principle, ADP)&lt;/strong&gt;&lt;br /&gt;
패키지 의존 관계 그래프에 순환이 있다면 빌드할 때나 개발할 때 문제가 생길 수도 있다. 순환이 있으면 어떤 클래스와 패키지들을 먼저 빌드하고 어떤 것을 다음에 할지 결정하지 못한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;안정된 의존 관계 원칙(Stable Dependencies Principle, SDP)&lt;/strong&gt;&lt;br /&gt;
SDP에 따르면 패키지는, 바뀌기 쉬워서 자신보다 불안정한 패키지들에 의존하면 안 된다. 모든 패키지 의존 관계 화살표는 언제나 화살표가 출발하는 패키지(의존하는 패키지)보다 변경하기 어려운 패키지를 가리켜야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;안정된 추상화 원칙(Stable Abstractions Principle, SAP)&lt;/strong&gt;&lt;br /&gt;
개방-폐쇄 원칙(OCP)에 따르면 모듈을 변경하지 않고도 확장할 수 있는 방법이 있다. SAP에 따르면 안정된 패키지를 쉽게 확장할 수 있도록 유지하기 위해, 안정된 패키지는 추상적이어야 한다. 패키지가 안정적일수록 더 추상적이어야 한다. 추상 클래스와 인터페이스의 비율이 높을수록 패키지의 추상도도 높아진다. SDP/SAP 조합에서는 의존 관계를 많이 받아들일수록 안정성도 증가하며, 안정성이 증가하면 추상성도 증가해야 한다고 나와있다. 그러므로 패키지가 의존 관계를 많이 받아들일수록 패키지도 더 추상적이어야 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;9-객체-다이어그램&quot;&gt;9. 객체 다이어그램&lt;/h1&gt;
&lt;p&gt;시스템의 스냅샷 사진처럼, UML 객체 다이어그램은 어떤 순간의 객체들과 그 객체 사이의 관계 그리고 그 객체들의 속성 값을 보여 준다. 객체 다이어그램은 시스템의 구조를 그 시스템에 속한 클래스의 정적인 구조에서 만들어 내는 것이 아니라 동적으로 만드는 경우 특히 유용하다.&lt;/p&gt;

&lt;h3 id=&quot;어떤-순간의-스냅샷&quot;&gt;어떤 순간의 스냅샷&lt;/h3&gt;
&lt;p&gt;시스템 내부 구조가 특정 시간에 어떤 모습인지, 또는 시스템이 특정한 상태에서 어떻게 되어 있는지 보일 필요가 있다면 객체 다이어그램이 유용하다. 객체 다이어그램은 설계자의 의도를 보여준다. 그리고 객체 다이어그램은 어떤 클래스들과 관계들이 실제로 어떻게 사용되는지, 또 시스템에 다양한 것이 입력될 때 시스템이 어떻게 변화할지 보여주기도 한다.&lt;/p&gt;

&lt;p&gt;하지만 이 다이어그램들은 자주 필요하지는 않으므로, 절대로 시스템에 들어 있는 시나리오마다 이것을 그려야 한다고 생각해서는 안 된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;references&quot;&gt;References&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9788991268937&quot;&gt;UML 실전에서는 이것만 쓴다: JAVA 프로그래머를 위한 UM&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.csd.uoc.gr/~hy252/references/UML_for_Java_Programmers-Book.pdf&quot;&gt;UML_for_Java_Programmers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
      </entry>
      
  
      
      <entry>
        <id>https://sungjk.github.io/2019/04/27/uml-for-java-programmers-2.html</id>
        <link type="text/html" rel="alternate" href="https://sungjk.github.io/2019/04/27/uml-for-java-programmers-2.html"/>
        <title>JAVA 프로그래머를 위한 UML - 2</title>
        <updated>2019-04-27T00:00:00+00:00</updated>
        <author>
          <name>김성중</name>
          <email>ajax0615@gmail.com</email>
        </author>
        <content type="html">&lt;h1 id=&quot;4-시퀀스-다이어그램&quot;&gt;4. 시퀀스 다이어그램&lt;/h1&gt;

&lt;h3 id=&quot;객체-생명선-메시지-등&quot;&gt;객체, 생명선, 메시지 등&lt;/h3&gt;
&lt;p&gt;협력에 참여하는 객체와 클래스는 맨위에 그리고, 객체는 이름 아래 밑줄이 있기 때문에 클래스와 구별된다. 왼쪽의 허수아비(액터)는 익명의 객체다. 이 객체는 협력 과정에 들어오고 나가는 모든 메시지의 시작점이자 마지막점이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/27/sequential-diagram.png&quot; alt=&quot;sequential-diagram&quot; title=&quot;sequential-diagram&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;객체와 액터 아래에 늘어뜨린 점선은 생명선(lifeline)이라고 부른다. 한 객체에서 다른 객체로 보내는 메시지는 두 생명선 사이의 화살표로 그린다. 메시지마다 이름이 붙어 있다. 인자는 이름 뒤 괄호 안에 적거나, 데이터 토큰(반대쪽 끝에 원이 그려진 작은 화살표) 아래에 적는다.&lt;/p&gt;

&lt;p&gt;LoginServlet 객체의 생명선에 있는 얇은 사각형은 활성 상자(activation)라고 부른다. 이 상자는 어떤 함수가 실행되는 시간을 나타낸다. EmployeeDB가 객체가 아니라 클래스라는 것에도 주목하라. 클래스는 객체와 비슷하지만 이름에 밑줄이 없다. 그러므로 getEmployee는 정적 메서드일 수밖에 없다.&lt;/p&gt;

&lt;h3 id=&quot;생성과-소멸&quot;&gt;생성과 소멸&lt;/h3&gt;
&lt;p&gt;이름이 붙지 않은 메시지 화살표의 끝이 객체의 생명선이 아니라 생성될 객체를 가리킨다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/27/creating-object.png&quot; alt=&quot;creating-object&quot; title=&quot;creating-object&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자바에서 객체는 명시적으로 소멸되지 않으며, 가비지 컬렉터가 우리 대신 객체를 소멸시킨다. 우리가 해제하려고 하는 객체의 생명선이 X자로 일찌감치 끊겨 있다. 이 X자를 가리키는 메시지 화살표는 객체를 해제해서 가비지 컬렉터에 넘기는 행동을 뜻한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/27/releasing-object.png&quot; alt=&quot;releasing-object&quot; title=&quot;releasing-object&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;사례와-시나리오&quot;&gt;사례와 시나리오&lt;/h3&gt;
&lt;p&gt;첫째, 무엇보다 자신에게 시퀀스 다이어그램이 정말 필요한지 물어보아라. 코드만으로 어떤 시스템의 일부분을 설명하는 것이 개발자와 설계자의 목표여야 한다. 개발팀은 표현력이 강하고 가독성 좋은 코드를 작성하기 위해 노력해야 한다. 코드만으로 설명하기 쉬울수록 필요한 다이어그램의 수도 줄어들고, 전체 프로젝트도 나아질 것이다.&lt;/p&gt;

&lt;p&gt;둘째, 시퀀스 다이어그램이 필요하다는 생각이 들면 그것을 여러 시나리오로 쪼갤 수 있는지 자신에게 물어보아라.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/27/simple-scenario.png&quot; alt=&quot;simple-scenario&quot; title=&quot;simple-scenario&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;셋째, 여러분이 무엇을 그리려고 하는지 생각해 보아라. 시스템의 전체 흐름에 대한 고차원의 개괄인가? 대개 고차원 다이어그램이 저차원 다이어그램보다 더 쓸모 있다. 고차원 다이어그램은 다이어그램을 읽는 사람이 마음속에서 시스템의 여러 요소를 하나로 연결해 볼 수 있게 해준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/27/high-level-view.png&quot; alt=&quot;high-level-view&quot; title=&quot;high-level-view&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;반복과-조건&quot;&gt;반복과 조건&lt;/h3&gt;
&lt;p&gt;별표(*)로 반복임을 표시하고 대괄호([])로 조건임을 표시 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;비동기-메시지&quot;&gt;비동기 메시지&lt;/h3&gt;
&lt;p&gt;분산 시스템이나 멀티스레드 시스템에서는 메시지를 보내는 객체가 다른 스레드의 제어 흐름에서 실행될 수도 있다. 이런 메시지 '비동기 메시지(asynchronous message)'라고 부른다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/27/asynchronous-message.png&quot; alt=&quot;asynchronous-message&quot; title=&quot;asynchronous-message&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;다중-스레드&quot;&gt;다중 스레드&lt;/h3&gt;
&lt;p&gt;비동기 메시지를 쓴다는 말은 곧 제어 흐름에서 다중 스레드를 사용한다는 뜻이다. 메시지 이름 앞에 T1 같은 식별자를  쓰고 콜론(:)을 찍어 놓은 것을 볼 수 있다. 이 식별자는 메시지를 보내는 스레드의 이름이다. 이 다이어그램에서 AsynchronousLogger 객체는 T1 스레드가 생성하고 조작한다. Log 객체 안에서 돌아가는, 실제로 메시지 로그를 수행하는 스레드는 T2라고 이름 붙어 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/27/multiple-thread.png&quot; alt=&quot;multiple-thread&quot; title=&quot;multiple-thread&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;활동적인-객체&quot;&gt;활동적인 객체&lt;/h3&gt;
&lt;p&gt;독립된 내부 스레드를 가진 객체를 표현하고 싶은 객체를 표현하고 싶은 경우도 있다. 이런 객체는 활동적인 객체(active object)로 알려져 있다. 자신만의 스레드를 만들고 제어하는 객체는 모두 활동적인 객체다. 그 객체의 메서드에 대해서는 특별한 제한이 없다. 활동적인 객체의 메서드는 그 객체의 스레드에서 돌아가도 되고, 그 메서드를 호출하는 스레드에서 돌아가도 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/27/active-objects.png&quot; alt=&quot;active-objects&quot; title=&quot;active-objects&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;5-유스케이스&quot;&gt;5. 유스케이스&lt;/h1&gt;
&lt;p&gt;유스케이스를 '단순하게 유지하는 것'이 유스케이스를 사용하는 진짜 비결이다. 정해진 형식을 맞춰야 하나 걱정하지 말고 그냥 '빈 종이'에 쓰거나, 단순한 워드프로세서로 '빈 페이지'에 작성하거나, '텅 빈 인덱스 카드'에 적어라. 모든 세부사항을 채워야 하는지 걱정할 필요도 없다. 유스케이스를 '그때그때 작성하는 요구사항'이라고 생각하라.&lt;/p&gt;

&lt;h3 id=&quot;유스케이스란-무엇인가&quot;&gt;유스케이스란 무엇인가&lt;/h3&gt;
&lt;p&gt;유스케이스는 시스템의 동작 하나를 기술한 것이다. 유스케이스는 방금 시스템에 특정한 일을 시킨 사용자의 관점에서 작성하며, 사용자가 보낸 자극 '하나'에 대한 반응으로 시스템이 진행하는 '눈에 보이는' 이벤트들의 흐름을 포착한다.&lt;/p&gt;

&lt;p&gt;눈에 보이는 이벤트란, 사용자가 볼 수 있는 이벤트를 뜻한다. 유스케이스는 사용자의 눈에 보이지 않는 동작을 전혀 기술하지 않고 시스템 안에 숨겨진 메커니즘도 다루지 않는다. 오직 사용자가 직접 볼 수 있는 것을 적어 놓을 뿐이다.&lt;/p&gt;

&lt;h3 id=&quot;기본-흐름&quot;&gt;기본 흐름&lt;/h3&gt;
&lt;p&gt;유스케이스를 구성하는 항목은 보통 두 개다. 첫째 항목은 기본 흐름(primary course)이다. 예로 판매시점관리(point of sale, POS) 시스템의 전형적인 유스케이스를 보자.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;상품 구입하기&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;점원은 상품을 스캐너 위로 통과시킨다. 스캐너가 UPC 코드를 읽는다.&lt;/li&gt;
  &lt;li&gt;상품 가격과 설명이 지금까지 통과시킨 상품 가격의 합계와 함께 고객 쪽 화면에 표시된다. 가격과 설명은 점원의 화면에도 표시된다.&lt;/li&gt;
  &lt;li&gt;가격과 설명이 영수증에 출력된다.&lt;/li&gt;
  &lt;li&gt;UPC 코드가 올바르게 읽혔는지 점원이 확인할 수 있도록 시스템이 잘 들리는 '승인' 소리를 낸다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;대체-흐름&quot;&gt;대체 흐름&lt;/h3&gt;
&lt;p&gt;유스케이스의 세부사항 가운데 일부는 일이 잘못되는 경우를 고려해야 한다. 이해관계자와 대화할 때 여러분은 실패 시나리오를 이야기해 봐야 한다. 그리고 그 유스케이스를 구현할 시간이 다가올수록 이런 대체 흐름을 더 깊게 생각해야 한다. 대체 흐름은 기본 흐름에 부록처럼 붙게 되며, 다음처럼 작성한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;lt;UPC 코드를 읽지 못할 경우&amp;gt;&lt;/strong&gt;&lt;br /&gt;
만약 스캐너가 UPC 코드를 읽는 데 실패하면 시스템은 점원이 다시 시도하도록 '다시 통과시키시오.' 소리를 낸다. 만약 세 번 시도했는데도 스캐너가 UPC 코드를 인식하지 못하면, 점원은 직접 코드를 입력해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;lt;UPC 코드가 없을 경우&amp;gt;&lt;/strong&gt;&lt;br /&gt;
상품에 UPC 코드가 없다면, 점원은 가격을 직접 입력해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;시스템-경계-다이어그램system-boundary-diagram&quot;&gt;시스템 경계 다이어그램(System Boundary Diagram)&lt;/h3&gt;
&lt;p&gt;사각형 안에 들어있는 것은 모두 개발 중인 시스템의 일부다. 사각형 바깥을 보면 시스템을 상대로 행동하는 액터를 볼 수 있다. 액터란, 시스템에 자극을 가하며 시스템 바깥에 있는 존재다. 액터는 사용자인데 대개 사람이다. 하지만 다른 시스템이나 심지어 실시간 클럭(realtime clock) 같은 장치가 액터가 될 수도 있다.&lt;/p&gt;

&lt;p&gt;경계 사각형 안을 보면 유스케이스들이 들어 있는데, 유스케이스는 타원 안에 그 유스케이스의 이름을 써서 나타낸다. 액터와 그 액터가 자극하는 유스케이스는 선으로 잇는다. 화살표는 그리지 마라. 화살표 방향이 정말로 무엇을 의미하는지 제대로 아는 사람은 아무도 없다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/27/system-boundary-diagram.png&quot; alt=&quot;system-boundary-diagram&quot; title=&quot;system-boundary-diagram&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;6-객체지향-개발의-원칙&quot;&gt;6. 객체지향 개발의 원칙&lt;/h1&gt;
&lt;p&gt;잘 설계되었다는 말은 무슨 뜻일까? 잘 설계한 시스템은 이해하기 쉽고, 바꾸기도 쉽고 재사용하기 쉽다. 개발하는 데 특별히 어렵지도 않고 단순하고 간결하며 경제적이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;나쁜 설계의 냄새&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;경직성(Rigidity)&lt;/strong&gt;: 무엇이든 하나를 바꿀 때마다 반드시 다른 것도 바꿔야 하며, 그러고 나면 또 다른 것도 바꿔야 하는 변화의 사슬이 끊이지 않기 때문에 시스템을 변경하기 힘들다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;부서지기 쉬움(Fragility)&lt;/strong&gt;: 시스템에서 한 부분을 변경하면 그것과 전혀 상관없는 다른 부분이 작동을 멈춘다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;부동성(Immobility)&lt;/strong&gt; : 시스템을 여러 컴포넌트로 분해해서 다른 시스템에서 재사용하기 힘들다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;끈끈함(Viscosity)&lt;/strong&gt;: 개발 환경이 배관용 테이프나 풀로 붙인 것처럼 꽉 달라붙은 상태다. 편집 - 컴파일 - 테스트 순환을 한 번 도는 시간이 엄청나게 길다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;쓸데없이 복잡함(Needless Complexity)&lt;/strong&gt;: 괜히 머리를 굴려서 짠 코드 구조가 굉장히 많다. 이것들은 대개 지금 당장 하나도 필요 없지만 언젠가는 굉장히 유용할지도 모른다고 기대하며 만든 것이다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;필요 없는 반복(Needless Repetition)&lt;/strong&gt;: 코드를 작성한 프로그래머 이름이 마치 '복사'와 '붙여넣기' 같다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;불투명함(Opacity)&lt;/strong&gt;: 코드를 만든 의도에 대한 설명을 볼 때 그 설명에 '표현이 꼬인다'라는 말이 잘 어울린다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;의존 관계 관리하기&lt;/strong&gt;&lt;br /&gt;
잘못 관리한 의존 관계가 많은 냄새의 원인이다. 잘못 관리한 의존 관계는 서로 단단하게 결합(coupling)하여 얽히고설킨 코드(스파게티 코드)로 나타난다.&lt;/p&gt;

&lt;p&gt;객체지향 언어(Object Oriented Programming Language)는 의존 관계를 관리하는 데 도움이 되는 도구를 제공한다. 인터페이스를 만들어 의존 관계를 끊거나 의존의 방향을 바꿀 수도 있다. 다형성을 사용하면 어떤 함수를 포함한 모듈에 의존하지 않고도 그 함수를 호출할 수 있다. 정말로 객체지향 언어는 의존 관계를 우리가 원하는 모양대로 만들 수 있는 강력한 힘을 준다.&lt;/p&gt;

&lt;h3 id=&quot;단-하나의-책임-원칙the-single-responsibility-principle-srp&quot;&gt;단 하나의 책임 원칙(The Single Responsibility Principle, SRP))&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;클래스는 오직 하나만 알아야 한다. 오직 하나의 책임만 져야 한다. 더 핵심적인 말로 바꿔 보면, 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.&lt;/p&gt;

&lt;p&gt;아래 Employee 클래스는 너무 많은 것을 알고 있다. 임금과 세금을 계산하는 방법도 알고, 자신을 디스크에 저장하거나 읽어 오는 방법도 안다. 그리고 자신을 XML로 변환하거나 XML에서 읽어 오는 방법도 알고, 다양한 보고서 형식으로 출력하는 방법도 안다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/27/class-knows-too-many.png&quot; alt=&quot;class-knows-too-many&quot; title=&quot;class-knows-too-many&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실제로는 이 모든 개념을 각기 다른 클래스로 분리하여 클래스마다 변경해야 하는 이유가 오직 하나만 있도록 만드는 것이 바람직하다. Employee 클래스는 세금과 임금만 다루고, XML 관련 클래스는 Employee 인스턴스를 XML로 바꾸거나 XML에서 읽어 들인다. 또 EmployeeDatabase 클래스는 Employee 인스턴스를 데이터베이스에 저장하거나 읽어 들이는 역할을 담당하고, 보고서 종류마다 클래스를 하나씩 만들면 좋을 것이다. 간단히 말해서, 우리는 걱정거리를 나누고 싶다(separation of concerns).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/27/separation-of-concerns.png&quot; alt=&quot;separation-of-concerns&quot; title=&quot;separation-of-concerns&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;UML 다이어그램을 보면 이 원칙을 지키지 않는 예를 무척 발견하기 쉽다. 둘 이상의 주제 영역에 의존 관계인 클래스를 찾아보면 된다. 가장 쉽게 찾을 수 있는 것이 특정 속성을 부여하는 인터페이스를 하나 또는 그 이상으로 구현하는 클래스다. 예를 들어 디스크에 저장하는 능력처럼 어떤 객체에 특정 능력을 부가하는 인터페이스를 생각해 보자. 비즈니스 로직 객체가 조심성 없이 이런 인터페이스까지 구현하면 영속성 문제와 비즈니스 규칙 사이에 필요 없는 결합을 만들기 쉽다.&lt;/p&gt;

&lt;h3 id=&quot;개방-폐쇄-원칙the-open-closed-principle-ocp&quot;&gt;개방 폐쇄 원칙(The Open Closed Principle, OCP)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;소프트웨어 엔티티(Class, Module, Functions, etc.)는 확장에 대해서는 개방되어야 하지만, 변경에 대해서는 폐쇄되어야 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 원칙의 정의는 거창하지만, 의미는 간단하다. 모듈 자체를 변경하지 않고도 그 모듈을 둘러싼 환경을 바꿀 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;아래 EmployeeDB라는 데이터베이스 퍼사드(facade)를 통해 Employee 객체를 다루는 간단한 애플리케이션이 있다. 이 퍼사드는 데이터베이스 API를 직접 다룬다. 바로 이것이 OCP를 위반하는 경우인데, EmployeeDB 클래스의 구현이 변경되면 Employee 클래스도 다시 빌드해야 할지도 모르기 때문이다. Employee는 EmployeeDB를 통해 데이터베이스 API에도 묶인 셈이다. Employee 클래스를 포함하는 시스템은 반드시 TheDatabase API까지 포함해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/27/viloation-ocp.png&quot; alt=&quot;viloation-ocp&quot; title=&quot;viloation-ocp&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;단위 테스트를 할 때는 환경에 생기는 변화를 제어하고 싶은 경우가 자주 생긴다. 예를 들어 Employee를 어떻게 테스트할지 생각해 보자. Employee 객체는 데이터베이스를 변경한다. 하지만 테스트 환경에서 실제 데이터베이스를 바꾸고 싶지 않다. 그렇다고 해서 단위 테스트를 하기 위해 테스트용 더미 데이터베이스를 만들고 싶지도 않다. 그렇자면, 테스트 환경으로 환경을 변경해서 테스트할 때 Employee가 데이터베이스에 하는 모든 호출을 가로챈 다음 이 호출들이 올바른지 검증하면 좋다.&lt;/p&gt;

&lt;p&gt;아래처럼 EmployeeDB를 인터페이스로 바꾸면 호출이 올바른지 검증할 수 있다. 이 인터페이스에서 파생한 두 가지 구현을 만들되, 하나는 진짜 데이터베이스를 호출하도록 하고 다른 하나는 우리 테스트를 지원하도록 하면 된다. 이렇게 인터페이스를 만들면 데이터베이스 API와 Employee를 분리할 수 있고, Employee를 손대지 않고도 Employee를 둘러싼 데이터베이스 환경을 변경할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/27/comforing-ocp.png&quot; alt=&quot;comforing-ocp&quot; title=&quot;comforing-ocp&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;직원 목록을 보여주는 간단한 대화상자를 예로 들어보자. 사용자는 목록에서 어떤 직원을 골라 Terminate(해고) 버튼을 누른다. 이때 직원이 아무도 선택되지 않는다면 버튼이 활성화되지 않아야 한다. 목록에서 직원을 한 명 선택하면 그때 버튼이 다시 활성화되어야 한다. 사용자가 Terminate 버튼을 누르면 해고된 직원은 목록에서 사라지고, 목록은 아무도 선택되지 않은 상태로 되돌아가야 하며 버튼도 다시 비활성화 상태로 돌아가야 한다.&lt;/p&gt;

&lt;p&gt;OCP를 지키지 않고 구현하면이 모든 행동을 GUI API를 호출하는 클래스에 넣어 놓을 것이다. 반면 OCP를 지키는 시스템이라면 GUI를 조작하는 부분과 데이터를 조작하는 부분을 구분해 놓는다.&lt;/p&gt;

&lt;p&gt;아래는 OCP를 지키는 시스템의 구조다. EmployeeTerminatorModel(직원 해고 모델)은 직원 목록을 관리하며, 사용자가 직원을 선택하거나 해고할 때 통지받는다. EmployeeTerminatorDialog(직원 해고 대화상자)는 GUI를 관리한다. 이 클래스는 표시할 직원 목록을 받아서, 선택된 항목이 바뀌거나 Terminate 버튼이 눌렸을 때 컨트롤러에 통지한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/27/isolating-gui-from-data.png&quot; alt=&quot;isolating-gui-from-data&quot; title=&quot;isolating-gui-from-data&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;EmployeeTerminatorModel은 선택된 직원을 실제로 목록에서 제거하는 책임을 맡는다. 그리고 해고 컨트롤을 활성화할지 말지 결정하는 책임도 맡는다. 이 모델은 이 컨트롤이 버튼으로 구현될지 다른 것으로 구현될지 알지 못하며, 단지 자신과 연결된 뷰에 사용자가 해고 행동을 할 수 있는지 없는지만 말해줄 뿐이다. 마찬가지로, 뷰에서 리스트 박스가 사용된다는 것을 모델이 몰라도, 지금 아무도 선택되지 않도록 하라고 뷰에 말할 수는 있다.&lt;/p&gt;

&lt;p&gt;EmployeeTerminatorDialog는 모델이 시키는 대로만 한다. 스스로 아무 결정도 내리지 않고 어떤 데이터도 관리하지 않는다. EmployeeTerminatorModel이 인형을 조작하듯 줄을 당겼다 놓았다 하면 이 대화상자는 그에 따라 움직인다. 사용자가 대화상자와 상호 작용하면 이 대화상자는 EmployeeTerminatorController(직원 해고 컨트롤러) 인터페이스의 메서드를 호출하는 방법으로 자신의 컨트롤러에 어떤 일이 벌어지는지 알리기만 한다. 이 메시지는 모델에 전달되고, 모델은 이 메시지를 해석해서 그에 따라 행동한다.&lt;/p&gt;

&lt;p&gt;어떻게 추상화를 해야 OCP를 지키는데 도움이 될까? 나는 실제 코드를 작성하기 전에 단위 테스트를 먼저 작성함으로써 OCP를 지키는 경우가 가장 많다. 각각 테스트 함수를 작성한 다음, 실제 모듈에는 이 테스트 함수를 통과할 수 있을 정도로만 코드를 작성한다.&lt;/p&gt;

&lt;h3 id=&quot;리스코프-치환-법칙the-liskov-substitution-principle-lsp&quot;&gt;리스코프 치환 법칙(The Liskov Substitution Principle, LSP)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;서브 타입은 언제나 자신의 베이스 타입으로 교체할 수 있어야 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;if 문장과 instanceof 표현식이 수없이 많은 코드를 본 적 있는가? 보통 이런 코드는 LSP를 지키지 않아서 생기는데, 이는 곧 OCP도 지키지 않았다는 말이다.&lt;/p&gt;

&lt;p&gt;LSP에 따르면 기반 클래스(base class)의 사용자는 그 기반 클래스에서 유도된 클래스를 기반 클래스로써 사용할 때, 특별한 것을 할 필요 없이 마치 원래 기반 클래스를 사용하는 양 그대로 사용할 수 있어야 한다. 더 자세히 말하면, instanceof나 다운캐스트(downcast)를 할 필요가 없어야 한다. 사용자는 파생 클래스에 대해서 아무것도 알 필요가 없어야 한다.&lt;/p&gt;

&lt;h3 id=&quot;의존-관계-역전-원칙the-dependency-inversion-principle-dip&quot;&gt;의존 관계 역전 원칙(The Dependency Inversion Principle, DIP)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;A. 고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.&lt;/strong&gt;
&lt;strong&gt;B. 추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;'자주 변경되는 concrete class에 의존하지 마라.' 만약 어떤 클래스에서 상속받아야 한다면 기반 클래스를 추상 클래스로 만들어라. 어떤 클래스의 참조(reference)를 가져야 한다면, 참조 대상이 되는 클래스를 추상 클래스로 만들어라. 만약 어떤 함수를 호출해야 한다면, 호출되는 함수를 추상 함수로 만들어라.&lt;/p&gt;

&lt;p&gt;추상 클래스와 인터페이스는 보통 자신에게서 유도된 구체적인 클래스보다 훨씬 덜 변한다. 그러므로 구체적인 것보다는 이런 추상적인 것에 의존하는 편이 낫다. 이 원칙을 지키면 변화가 일어났을 때 시스템에 미치는 영향을 줄일 수 있다.&lt;/p&gt;

&lt;p&gt;그렇다면 컨크리트 클래스인 Vector나 String을 사용하면 안 된다는 말인가? 이것을 사용하면 DIP를 어기게 되는가? 그렇지 않다. 앞으로 변하지 않을 컨크리트 클래스에 의존하는 것은 완벽하게 안전하다. Vector나 String은 다음 10년 동안에도 변하지 않을 가능성이 높다.&lt;/p&gt;

&lt;p&gt;우리가 의존하면 안 되는 것은 '자주 변경되는' 컨크리트 클래스다. 활발히 개발중인 컨크리트 클래스나 변할 가능성이 높은 비즈니스 규칙을 담은 클래스가 여기에 속한다. 이런 클래스의 인터페이스를 만든 다음, 이 인터페이스에 의존하는 것이 바람직하다.&lt;/p&gt;

&lt;p&gt;UML을 사용하면 이 원칙을 지키는지 매우 쉽게 검사할 수 있다. UML 다이어그램의 화살표마다 따라가서 모두 인터페이스나 추상 클래스를 가리키는지 확인하면 된다. 만약 컨크리트 클래스에 의존하느데 그 클래스가 자주 변경된다면 DIP를 어기는 것이며, 따라서 시스템도 변화에 민감하게 변할 것이다.&lt;/p&gt;

&lt;h3 id=&quot;인터페이스-격리-원칙the-interface-segregation-principle-isp&quot;&gt;인터페이스 격리 원칙(The Interface Segregation Principle, ISP)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 다이어그램에는 StudentEnrollment라는 클래스를 사용하는 두 클라이언트가 있다. EnrollmentReportGenerator가 prepareInvoice나 postPayment 같은 메서드는 사용하지 않으리라는 것은 명백하다. 마찬가지로 AccountsReceivable은 getName이나 getDate 같은 메서드를 호출하지 않는다고 가정해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/27/unsegregated-enrollment.png&quot; alt=&quot;unsegregated-enrollment&quot; title=&quot;unsegregated-enrollment&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 요구사항이 변해서 postPayment 메서드에 새 인자를 추가할 수 밖에 없다고 하면 무슨 일이 일어날까? StudentEnrollment의 선언을 바꾸는 이 변화 때문에 EnrollmentReportGenerator를 다시 컴파일하고 배포해야 할지도 모른다. EnrollmentReportGenerator는 postPayment 메서드와 아무 상관없는데 불행히도 이렇게 해야 한다.&lt;/p&gt;

&lt;p&gt;다음처럼 간단한 규칙을 지키면 이렇게 불행한 의존 관계를 막을 수 있다. 사용자에게 딱 필요한 메서드만 있는 인터페이스를 제공해서 필요하지 않는 메서드에서 사용자를 보호하라.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/27/segregated-enrollment.png&quot; alt=&quot;segregated-enrollment&quot; title=&quot;segregated-enrollment&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;StudentEnrollment 객체를 사용하는 사용자마다 자신이 관심 있는 메서드들만 있는 인터페이스를 제공받는다. 이렇게 하면 사용자가 관심 없는 메서드에서 생긴 변화에서 사용자를 보호할 수 있다. 그리고 사용자가 자신이 사용하는 객체를 너무 많이 알게 되는 일도 막을 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;references&quot;&gt;References&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9788991268937&quot;&gt;UML 실전에서는 이것만 쓴다: JAVA 프로그래머를 위한 UM&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.csd.uoc.gr/~hy252/references/UML_for_Java_Programmers-Book.pdf&quot;&gt;UML_for_Java_Programmers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
      </entry>
      
  
      
      <entry>
        <id>https://sungjk.github.io/2019/04/21/uml-for-java-programmers-1.html</id>
        <link type="text/html" rel="alternate" href="https://sungjk.github.io/2019/04/21/uml-for-java-programmers-1.html"/>
        <title>JAVA 프로그래머를 위한 UML - 1</title>
        <updated>2019-04-21T00:00:00+00:00</updated>
        <author>
          <name>김성중</name>
          <email>ajax0615@gmail.com</email>
        </author>
        <content type="html">&lt;h1 id=&quot;1-개요&quot;&gt;1. 개요&lt;/h1&gt;
&lt;p&gt;UML(Unified Modeling Language)은 소프트웨어 개념을 다이어그램으로 그리기 위해 사용하는 시각적인 표기법이다. 마틴 파울러(Martin Fowler)는 UML을 각각 개념(conceptual), 명세(specification), 구현(implementation)이라는 말을 붙여 구분하였다.&lt;/p&gt;

&lt;p&gt;명세 차원 다이어그램은 결국에는 소스코드로 바꾸려고 그리는 것이며, 구현 차원 다이어그램도 이미 있는 소스코드를 설명하려고 그리는 것이다. 반면, 개념 차원 다이어그램은 사람이 풀고자 하는 문제 도메인 안에 있는 개념과 추상적 개념을 기술하기 위한 속기용 기호에 가깝다. 따라서 의미론적 규칙에 그다지 얽매이지 않으며 의미하는 바도 모호하거나 해석에 따라 달라질 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;다이어그램의-유형&quot;&gt;다이어그램의 유형&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;정적 다이어그램(static diagram)&lt;/strong&gt;: 클래스, 객체, 데이터 구조와 이것들의 관계를 그림으로 표현해서 소프트웨어 요소에서 변하지 않는 논리적 구조를 보여 준다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;동적 다이어그램(dynamic diagram)&lt;/strong&gt;: 실행 흐름을 그림으로 그리거나 실체의 상태가 어떻게 바뀌는지 그림으로 표현해서 소프트웨어 안의 실체가 실행 도중 어떻게 변하는지 보여 준다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;물리적 다이어그램(physical diagram)&lt;/strong&gt;: 소스 파일, 라이브러리, 바이너리 파일, 데이터 파일 등의 물리적 실체와 이것들의관계들을 그림으로 표현해서 소프트웨어 실체의 변하지 않는 물리적 구조를 보여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TreeMap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;TreeMapNode&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Comparable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;topNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;topNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TreeMapNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;topNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Comparable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TreeMapNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LESS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GREATER&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Comparable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;itsKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;itsValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TreeMapNode&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TreeMapNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TreeMapNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Comparable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;itsKey&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;itsValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Comparable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;itsKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;itsValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findSubNodeForKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;selectSubNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;selectSubNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Comparable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;itsKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LESS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GREATER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findSubNodeForKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Comparable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Comparable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;itsKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;itsValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
      &lt;span class=&quot;nf&quot;&gt;addSubNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;selectSubNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addSubNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Comparable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TreeMapNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;클래스-다이어그램&quot;&gt;클래스 다이어그램&lt;/h3&gt;
&lt;p&gt;클래스 다이어그램(class diagram)은 프로그램 안의 주요 클래스와 주요 관계를 보여 준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/class-diagram.png&quot; alt=&quot;class-diagram&quot; title=&quot;class-diagram&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사각형은 클래스를 나타내고, 화살표는 관계를 나타낸다.&lt;/li&gt;
  &lt;li&gt;위 다이어그램에서 모든 관계는 연관(association)이다. 연관은 한쪽 객체가 다른 쪽 객체를 참조하며, 그 참조를 통해 그 객체의 메서드를 호출하는 것을 나타내는 단순한 데이터 관계다.&lt;/li&gt;
  &lt;li&gt;연관 위에 쓴 이름은 참조를 담는 변수의 이름과 대응된다.&lt;/li&gt;
  &lt;li&gt;화살표 옆에 쓴 숫자는 인스턴스의 개수를 타나낸다.&lt;/li&gt;
  &lt;li&gt;클래스 아이콘은 여러 구획으로 나뉠 수도 있다. 첫번째 구획은 언제나 클래스 이름을 쓴다. 다른 구획에는 각각 함수와 변수를 쓴다.&lt;/li&gt;
  &lt;li&gt;«interface» 표기법은 Comparable이 인터페이스임을 나타낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;객체-다이어그램&quot;&gt;객체 다이어그램&lt;/h3&gt;
&lt;p&gt;객체 다이어그램(object diagram)은 시스템 실행 중 어느 순간의 객체와 관계를 포착해서 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/object-diagram.png&quot; alt=&quot;object-diagram&quot; title=&quot;object-diagram&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;객체는 사각형과 밑줄로 표현&lt;/li&gt;
  &lt;li&gt;이 객체가 속하는 클래스의 이름은 콜론(:) 다음에 표현&lt;/li&gt;
  &lt;li&gt;객체마다 아래 구획에 그 객체의 itsKey 변수의 값이 나와 있다.&lt;/li&gt;
  &lt;li&gt;객체 사이의 관계는 연결(link)이라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;시퀀스-다이어그램&quot;&gt;시퀀스 다이어그램&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/sequence-diagram.png&quot; alt=&quot;sequence-diagram&quot; title=&quot;sequence-diagram&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;허수아비는 알려지지 않은 메서드 호출자를 나타낸다.&lt;/li&gt;
  &lt;li&gt;대괄호([ ]) 안의 불린 표현식은 '가드(gaurd)'라고 하며, 어떤 경로를 따라가야 할 지 알려 준다.&lt;/li&gt;
  &lt;li&gt;TreeMapNode 아이콘에 닿은 화살표는 '생성(construction)'을 나타낸다.&lt;/li&gt;
  &lt;li&gt;한쪽 끝에 원이 그려진 작은 화살표는 '데이터 토큰(data token)'이라고 하고, 이 경우에는 생성자의 인자를 나타낸다.&lt;/li&gt;
  &lt;li&gt;TreeMap 아래 홀쭉한 사각형은 '활성 상자(activation)'라고 부르는데, add 메서드가 실행되는 데 시간이 어느 정도 걸리는지 보여 준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;협력-다이어그램&quot;&gt;협력 다이어그램&lt;/h3&gt;
&lt;p&gt;협력 다이어그램(collaboration diagram)의 정보는 시퀀스 다이어그램에 담긴 정보와 똑같다. 하지만 시퀀스 다이어그램은 메시지를 보내고 받는 순서를 명확히 하는 것이 목적인 반면, 협력 다이어그램은 객체 사이의 관계를 명확히 하는 것이 목적이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/collaboration-diagram.png&quot; alt=&quot;Collaboration-diagram&quot; title=&quot;Collaboration-diagram&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;객체들은 연결이라고 부르는 관계로 맺어지고, 어떤 객체가 다른 객체에 메시지를 보낼 수 있다면 두 객체 사이에 연결이 있다고 말한다.&lt;/li&gt;
  &lt;li&gt;메시지는 작은 화살표로 그리며, 메시지 위에는 메시지 일므과 시퀀스 숫자, 그리고 이 메시지를 보낼 때 적용하는 모든 가드를 적는다.&lt;/li&gt;
  &lt;li&gt;호출의 계층 구조는 시퀀스 숫자에서 볼 수 있는 점(.)을 사용한 구조로 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;상태-다이어그램&quot;&gt;상태 다이어그램&lt;/h3&gt;
&lt;p&gt;아래는 지하철 개찰구를 상태 기계로 표현한 것인데, Locked(잠김)와 Unlocked(풀림)라는 두 가지 '상태'가 있고, 두 가지 '이벤트'를 받을 수 있다. coin 이벤트는 사용자가 개찰구에 표를 넣었음을 뜻하고, pass 이벤트는 사용자가 개찰구를 통해 지나감을 뜻한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/state-diagram.png&quot; alt=&quot;state-diagram&quot; title=&quot;state-diagram&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;화살표는 '전이(transition)'라고 부른다. 이 전이 화살표에는 전이를 일으키는 이벤트와 전이가 수행하는 행동을 레이블로 단다. 전이가 일어나면 시스템의 상태가 바뀐다.&lt;/p&gt;

&lt;p&gt;이런 다이어그램은 시스템의 행동 방식을 파악할 때 유용하다. 어떤 사용자가 표를 넣은 다음 아무 이유 없이 '다시 표를 넣는 것처럼' 예상하지 못한 경우에 시스템이 어떻게 행동해야 하는지 탐색할 기회를 마련해 준다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;2-다이어그램으로-작업하기&quot;&gt;2. 다이어그램으로 작업하기&lt;/h1&gt;

&lt;h3 id=&quot;왜-모델을-만들어야-하는가&quot;&gt;왜 모델을 만들어야 하는가&lt;/h3&gt;
&lt;p&gt;어떤 것이 실제로도 잘 작동하느지 알아보려고 만드는 것이 모델이다. 여기에 모델은 반드시 시험해 볼 수 있어야 한다는 의미가 함축되어 있다. 모델을 만드는 비용이 실제 물건을 만드는 비용보다 훨씬 적을 경우에 모델을 만들어서 설계를 검사해 본다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;왜 소프트웨어 모델을 만드는가&lt;/strong&gt;&lt;br /&gt;
UML 다이어그램을 그리는 일은 소프트웨어를 작성하는 일보다 비용이 적긴 하지만, 다른 분야(항공, 건축 등)의 모델처럼 훨씬 적게 드는 것은 아니다. 시험해 볼 구체적인 것이 있고, 그것을 코드로 시험해 보는 것보다 UML로 시험해 보는 쪽이 비용이 덜 들 때 UML을 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;반드시 코딩을 시작하기에 앞서 포괄적인 설계를 해야 하는가&lt;/strong&gt;&lt;br /&gt;
계획 없이 어떤 빌딩을 짓는 것보다 미리 계획을 짜는 것이 비용이 '훨씬 적게' 든다. 잘못된 청사진을 던져 버리는 일에는 비용이 별로 들지 않지만, 잘못된 빌딩을 부수려면 비용이 '엄청나게' 든다. 모델의 경우와 마찬가지로 다른 분야에 비해 소프트웨어 분야에서는 모든것이 이렇게 분명하지 않다. 코드를 작성하는 것보다 UML 다이어그램을 그리는 것이 훨씬 비용이 적은지는 명확하지 않다. 그러므로 코드를 작성하기에 앞서 포괄적인 UML 설계를 만들면 드는 비용만큼 효과가 있는지 명확하게 알 수 없다.&lt;/p&gt;

&lt;h3 id=&quot;uml을-효과적으로-사용하기&quot;&gt;UML을 효과적으로 사용하기&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;다른 사람들과 의사 소통하기&lt;/strong&gt;&lt;br /&gt;
UML은 소프트웨어 개발자끼리 설계 개념에 대한 의견을 주고 받을 때 굉장히 편리하며, 몇몇 개발자가 칠판 주위에 모여서 상당히 많은 일을 할 수 있게 해준다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;로드맵&lt;/strong&gt;&lt;br /&gt;
어떤 클래스가 다른 클래스에 의존하는지 개발자가 빨리 파악할 수 있게 해주고 전체 시스템의 구조에 대한 참조 도표로도 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;백엔드(back-end) 문서&lt;/strong&gt;&lt;br /&gt;
문서 작성을 프로젝트 막바지에 팀의 마지막 작업으로 하는 것이 가장 좋다. 그러면 작성한 문서가 팀이 프로젝트를 떠나는 마지막 시점의 사정을 잘 반영해주기 때문에 다음 프로젝트를 맡을 팀에게도 유용할 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;무엇을 보관하고 무엇을 버려야 하는가&lt;/strong&gt;&lt;br /&gt;
UML 다이어그램을 던져 버리는 습관을 길러라. 더 좋은 방법은, 다이어그램을 오랫동안 기록되는 매체에 기록하지 않는 습관을 기르는 것이다. 하지만 시스템 안에서 자주 사용되는 설계상의 해결 방법을 표현하는 것은 저장해 두는 편이 좋다. 정말로 유용한 다이어그램은 자꾸만 그리게 되는데, 누군가 귀찮게 다시 그릴 필요가 없게 다이어그램을 그려서 지속되는 매체에 저장할 것이다. 이때가 이 다이어그램을 모든 사람이 볼 수 있는 곳에 붙여 놓을 시기다.&lt;/p&gt;

&lt;h3 id=&quot;반복을-통해-다듬기&quot;&gt;반복을 통해 다듬기&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;행위를 제일 먼저&lt;/strong&gt;&lt;br /&gt;
버튼이 눌릴 때마다 다이얼을 돌리는 일을 제어하는 프로그램을 예로 들어보자. 버튼(Button) 객체와 다이얼(Dialer) 객체를 그리고, Button이 Dialer에 번호 메시지를 여러 개 보내는 것도 그린다. 별표(*)는 '여러 개'를 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/behavior-first-1.png&quot; alt=&quot;behavior-first-1&quot; title=&quot;behavior-first-1&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;번호 j메시지를 받으면 Dialer는 화면에 번호를 표시해야 하니까 아마 화면(Screen) 객체에 displayDigit 메시지를 보낼 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/behavior-first-2.png&quot; alt=&quot;behavior-first-2&quot; title=&quot;behavior-first-2&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그리고 스피커를 통해 어떤 톤을 들려주는 것도 좋다. 그러므로 Button이 스피커(Speaker) 객체에도 tone 메시지를 보내게 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/behavior-first-3.png&quot; alt=&quot;behavior-first-3&quot; title=&quot;behavior-first-3&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;숫자를 누르다가 마지막으로 사용자는 전송(Send) 버튼을 눌러서 이 번호로 전화를 걸고 싶다고 알려줄 것이다. 이 시점에서 우리는 셀 네트워크에 접속해서 사용자가 누른 전화번호를 전달하라고 휴대전화의 무선 부분(Radio)에 말해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/behavior-first-4.png&quot; alt=&quot;behavior-first-4&quot; title=&quot;behavior-first-4&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;연결이 맺어지면 Radio은 화면 객체에 사용중 지시자에 불을 켜라고 말할 수 있다. 그런데 이 메시지를 보낼 떄는 다른 제어 스레드를 사용할 가능성이 굉장히 높다. 그럴 때는 시퀀스 번호 앞에 글자를 붙여서 이 사실을 표현한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/behavior-first-5.png&quot; alt=&quot;behavior-first-5&quot; title=&quot;behavior-first-5&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;구조를 점검하기&lt;/strong&gt;&lt;br /&gt;
중요한 것은 의존 관계를 분석하는 일이다. 왜 Button이 Dialer에 의존해야 하는가?&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Button&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dialler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;itsDialler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dialler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dialler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;itsDialler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dialler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Button은 다른 맥락에서도 사용할 수 있는 클래스다. 이 문제는 Button과 Dialer 사이에 인터페이스를 하나 만들어 넣으면 해결할 수 있다. Button은 저마다 고유한 식별자 토큰을 하나씩 가진다. Button 클래스는 자기가 눌렸다는 사실을 감지하면, ButtonListener 인터페이스의 buttonPressed 메서드를 호출하면서 자기 식별자 토큰을 인자로 넘긴다. 이렇게 하면 Button이 Dialer에 의존하지 않게 할 수 있으며 버튼이 눌렸다는 사실을 알아야 하는 거의 모든 경우에 Button을 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/isolating-button.png&quot; alt=&quot;isolating-button&quot; title=&quot;isolating-button&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;불행하게도 이번에는 Dialer가 Button에 대해 알아야 한다. 어댑터를 몇 개 쓰면 이 문제를 풀 수 있으며, 덤으로 식별자 토큰 사용이라는 어설픈 아이디어도 없앨 수 있다. ButtonDialerAdapter는 ButtonListener 인터페이스를 구현한다. 이 어댑터의 buttonPressed 메서드가 호출될 때, 이 어댑터는 Dialer에 digit(n) 메시지를 보낸다. Dialer에 전달할 숫자(n)는 어댑터가 기억하고 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/adapting-button.png&quot; alt=&quot;adapting-button&quot; title=&quot;adapting-button&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;코드를 마음속으로 그려보기&lt;/strong&gt;&lt;br /&gt;
다이어그램을 그려 놓고 그 다이어그램이 나타내는 코드를 마음 속에서 그려 보지 못한다면, 공중에 누각을 짓는 것과 다를 바 없다. '지금 하는 작업을 당장 중단하고 어떻게 그 다이어그램을 코드로 바꿀 수 있는지 찾아내라.' 다이어그램 자체가 목적이 되어서는 안 된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ButtonDiallerAdapter&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ButtonListener&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;digit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dialler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dialler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ButtonDiallerAdapter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;digit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dialler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dialler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;digit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;digit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;dialler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dialler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;buttonPressed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dialler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;digit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;digit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;다이어그램의 진화&lt;/strong&gt;&lt;br /&gt;
간단한 동적인 다이어그램부터 시작해서 이런 동적인 것이 정적 관계에선느 어떤 의미인지 조사해본다. 이런 단계 하나하나는 아주 작다. 다이어그램을 아주 짧은 주기로 번갈아 보며 서로 상대를 발판 삼아 발전시킨다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/adapting-to-dynamic.png&quot; alt=&quot;adapting-to-dynamic&quot; title=&quot;adapting-to-dynamic&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;미니멀리즘&lt;/strong&gt;&lt;br /&gt;
다이어그램이 가장 유용한 때는 다른 사람과 의사 소통을 할 때와, 여러분이 설계에 관한 문제점을 푸는 일에 도움이 될 때다. UML 다이어그램은 소스코드가 아니며, 따라서 모든 메서드나 변수, 관계를 선언하는 장소로 취급해서는 안 된다.&lt;/p&gt;

&lt;h3 id=&quot;언제-어떻게-다이어그램을-그려야-하는가&quot;&gt;언제, 어떻게 다이어그램을 그려야 하는가&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;다이어그램을 그려야 할 경우&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;모두 설계에서 특정한 부분의 구조를 이해해야 할 때 그려라.&lt;/li&gt;
  &lt;li&gt;두 명 이상이 특정 요소를 어떻게 설계할지 의견을 모을 필요가 있을때 그려라.&lt;/li&gt;
  &lt;li&gt;설계 아이디어로 이것저것 시도해 보고 싶을 때 그려라.&lt;/li&gt;
  &lt;li&gt;누군가에세 코드 일부분의 구조를 설명할 때 그려라.&lt;/li&gt;
  &lt;li&gt;프로젝트 마지막에 고객이나 다른 사람을 위한 문서에 포함하기 위해 다이어그램을 요구할 때 그려라.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;다이어그램을 그리지 말아야 할 경우&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;공정에서 다이어그램을 그려야 한다고 정해서 다이어그램을 그리지는 마라.&lt;/li&gt;
  &lt;li&gt;코딩을 시작하기에 앞서 설계 단계의 포괄적인 문서를 만들기 위해서 그리지 마라.&lt;/li&gt;
  &lt;li&gt;다른 사람에게 어떻게 코딩을 해야 할지 알려 주기 위해서 다이어그램을 그리지 마라.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;하지만 문서화는 어떻게 합니까&lt;/strong&gt;&lt;br /&gt;
복잡한 통신 프로토콜은 문서화해야 한다. 복잡한 관계형 데이터베이스의 스키마도 문서화해야 한다. 재사용 가능한 복잡한 프레임워크도 마찬가지다. 백만 줄의 자바 코드로 된 프로젝트에 12명이 일하는 팀이라면, 모두 합쳐 25쪽에서 200쪽 사이의 영구 문서로 충분하다고 생각한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;3-클래스-다이어그램&quot;&gt;3. 클래스 다이어그램&lt;/h1&gt;
&lt;p&gt;클래스 다이어그램으로 소스코드에 나타내는 클래스 사이의 의존 관계를 모두 표기할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;기본-개념&quot;&gt;기본 개념&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;클래스(Class)&lt;/strong&gt;&lt;br /&gt;
클래스는 사각형으로 표시한다. 대시(-)는 private, 해시(#)는 protected, 더하기(+)는 public을 나타낸다. 변수나 함수 인자의 타입은 저마다 자기 이름 뒤에 콜론을 찍고 적는다. 함수의 반환값도 비슷하게 함수 뒤에 콜론(:)을 찍고 적는다. 세부사항은 다이어그램을 그리는 목적에 꼭 필요한 것만 사용해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/class-diagram-1.png&quot; alt=&quot;class-diagram-1&quot; title=&quot;class-diagram-1&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;연관(Association)&lt;/strong&gt;&lt;br /&gt;
클래스 사이의 연관은 다른 객체의 참조(reference)를 가지는 인스턴스 변수를 의미한다. Phonebook은 '여러 개의' PhoneNumber 객체와 '연결된다'.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/class-diagram-2.png&quot; alt=&quot;class-diagram-2&quot; title=&quot;class-diagram-2&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&quot;Phonebook은 PhoneNumber를 여러 개 가진다.&quot;라고 말할 수도 있지만 일부러 그리 하지 않았다. 자주 사용하는 객체지향(Object Oriented)  동사인 HAS-A와 IS-A 때문에 불행한 오해가 많았다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;상속(Inheritance)&lt;/strong&gt;&lt;br /&gt;
화살촉을 조심해서 그리지 않으면 상속을 표현하는지 연관을 표현하는지 구분하기 힘들 수 있다. 그래서 흔히 상속 관계는 세로로, 연관 관계는 가로로 그린다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/inheritance-1.png&quot; alt=&quot;inheritance-1&quot; title=&quot;inheritance-1&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자바 클래스와 자바 인터페이스 사이의 상속(implements) 관계를 나타내기 위해 점선을 그리기도 하지만, 칠판에 다이어그램을 그릴 때는 점선으로 그리는 것을 무시했으면 좋겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/inheritance-2.png&quot; alt=&quot;inheritance-2&quot; title=&quot;inheritance-2&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;세부사항&quot;&gt;세부사항&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;클래스 스테레오타입(Class Stereotypes)&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;«interface». 이 스테레오타입이 붙은 클래스의 메서드는 모두 추상 메서드이므로, 어떤 메서드도 구현해서는 안 된다. 인스턴스 변수를 가지지 못하고 오직 정적(static) 변수만 가질 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/class-stereotype-1.png&quot; alt=&quot;class-stereotype-1&quot; title=&quot;class-stereotype-1&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;«utility». 클래스의 모든 메서드와 변수들은 정적(static)이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/class-stereotype-2.png&quot; alt=&quot;class-stereotype-2&quot; title=&quot;class-stereotype-2&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;추상 클래스(Abstract classes)&lt;/strong&gt;&lt;br /&gt;
UML에서 추상 클래스나 추상 메서드를 표기하는 방법은 두 가지다. 이름을 이탤릭체로 적거나, {abstract} 프로퍼티를 사용하는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/abstract-class.png&quot; alt=&quot;abstract-class&quot; title=&quot;abstract-class&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;프로퍼티(Properties)&lt;/strong&gt;&lt;br /&gt;
{abstract} 같은 프로퍼티는 어떤 클래스에도 붙일 수 있다. 프로퍼티는 보통 클래스에 속하지 않는 추가 정보를 나타낸다. 프로퍼티는 다음처럼 쉼표(,)로 구분리된 이름-값 쌍으로 적는다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{author=Martin, date=20020429, file=shape.java, private}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;집합(Aggregation)&lt;/strong&gt;&lt;br /&gt;
집합은 '부분/전체' 관계를 내포하는 연관의 특별한 형태다. UML이 집합에 유일하게 제공하는 명확한 규칙은 다음 몇 가지 뿐이다. 전체는 자신의 부분이 될 수 없다. 따라서 '인스턴스'들이 집합을 통한 순환 고리를 만들 수는 없다. 어떤 객체가 자기 자신의 부분이 될수 없고, 두 객체가 서로 상대 객체의 부분이 될 수도 없고, 세 객체가 전체/부분 관계의 고리를 만들 수도 없다 등등.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/aggregation.png&quot; alt=&quot;aggregation&quot; title=&quot;aggregation&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;합성(Composition)&lt;/strong&gt;&lt;br /&gt;
합성은 집합의 특별한 형태다. 자바 프로그램에서는 이 관계가 그다지 유용하지 않다. 반면 C++ 프로그래머에게는 합성 관계가 '매우' 유용하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;다수성(Multiplicity)&lt;/strong&gt;&lt;br /&gt;
객체는 다른 객체들의 배열이나 벡터를 가질 수 있으며, 같은 종류의 객체라도 배열이 아니라 여러 인스턴스 변수에 따로 가질 수도 있다. 단순한 숫자나 숫자 범위를 사용하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/multiplicity.png&quot; alt=&quot;Multiplicity&quot; title=&quot;multiplicity&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;연관 스테레오타입(Association Stereotypes)&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;«create». 연관의 원본이 연관의 대상을 생성함을 나타낸다. 전형적인 팩터리(Factory).&lt;/li&gt;
  &lt;li&gt;«local». 원본 클래스가 대상 클래스의 인스턴스를 만들고 그 인스턴스의 참조가 지역 변수에 담길 때 사용한다.&lt;/li&gt;
  &lt;li&gt;«parameter». 원본 클래스의 멤버 함수가 호출될 때 대상 인스턴스가 인자로 넘어옴으로써 원본 클래스가 대상 클래스에 접근할 수 있게 됨을 보여준다.&lt;/li&gt;
  &lt;li&gt;«delegate». 원본 클래스의 멤버 함수가 호출될 때 이 호출을 대상 클래스에 그대로 전달해서 대상 클래스의 멤버 함수를 호출하는 경우 등에 사용된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/association-stereotypes.png&quot; alt=&quot;association-stereotypes&quot; title=&quot;association-stereotypes&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;내부 클래스(Inner Classes)&lt;/strong&gt;&lt;br /&gt;
연관의 가까운 쪽 끝에다가 내부에 십자 표시를 한 원을 덧붙여서 표현한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/inner-classes.png&quot; alt=&quot;inner-classes&quot; title=&quot;inner-classes&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;익명 내부 클래스(Anonymous Inner Classes)&lt;/strong&gt;&lt;br /&gt;
«anonymous» 스트레오타입과 자신이 구현하는 인터페이스의 이름을 가지는 중첩된 클래스로 표현한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/21/anonymous-inner-classes.png&quot; alt=&quot;anonymous-inner-classes&quot; title=&quot;anonymous-inner-classes&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;연관 클래스(Association classes)&lt;/strong&gt;&lt;br /&gt;
연관 클래스는 특정한 연관을 어떻게 구현하는지 보여 준다. 다이어그램에서 연관 클래스는 연관과 점선으로 연결된 보통 클래스로 그린다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;연관 한정사(Association Qualifiers)&lt;/strong&gt;&lt;br /&gt;
일반적인 자바 참조가 아니라 어떤 종류의 키나 토큰을 통해 연관을 구현할 경우, 연관 한정사(association qualifiers)를 사용한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;references&quot;&gt;References&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9788991268937&quot;&gt;UML 실전에서는 이것만 쓴다: JAVA 프로그래머를 위한 UM&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.csd.uoc.gr/~hy252/references/UML_for_Java_Programmers-Book.pdf&quot;&gt;UML_for_Java_Programmers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
      </entry>
      
  
      
      <entry>
        <id>https://sungjk.github.io/2019/04/16/java-performance-tuning-4.html</id>
        <link type="text/html" rel="alternate" href="https://sungjk.github.io/2019/04/16/java-performance-tuning-4.html"/>
        <title>자바 성능 튜닝 이야기 - 4</title>
        <updated>2019-04-16T00:00:00+00:00</updated>
        <author>
          <name>김성중</name>
          <email>ajax0615@gmail.com</email>
        </author>
        <content type="html">&lt;p&gt;&lt;img src=&quot;/images/2019/03/28/java_performance_tuning.jpeg&quot; alt=&quot;java_performance_tuning&quot; title=&quot;java_performance_tuning&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;16-jvm은-도대체-어떻게-구동될까&quot;&gt;16. JVM은 도대체 어떻게 구동될까?&lt;/h1&gt;
&lt;p&gt;자바를 만든 Sun에서는 자바의 성능을 개선하기 위해서 Just In Time(JIT) 컴파일러를 만들었고, 이름을 HotSpot으로 지었다. 여기서 JIT 컴파일러는 프로그램의 성능에 영향을 주는 지점에 대해서 지속적으로 분석한다. 분석된 지점은 부하를 최소화하고, 높은 성능을 내기 위한 최적화의 대상이 된다. 이 HotSpot은 자바 1.3 버전부터 기본 VM으로 사용되어 왔기 때문에, 지금 운영되고 있는 대부분의 시스템들은 모두 HotSpot 기반의 VM이라고 생각하면 된다. HotSpot VM은 세 가지 주요 컴포넌트로 되어 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;VM(Virtual Machine) 런타임&lt;/li&gt;
  &lt;li&gt;JIT(Just In Time) 컴파일러&lt;/li&gt;
  &lt;li&gt;메모리 관리자&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/06/hotspot-vm.png&quot; alt=&quot;hotspot-vm&quot; title=&quot;hotspot-vm&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;'HotSpot VM Runtime'에 'GC'와 'JIT 컴파일러'를 끼워 맞춰 사용할 수 있다. 이를 위해서 'VM 런타임'은 JIT 컴파일러용 API와 가비지 컬렉터용 API를 제공한다. 그리고, JVM을 시작하는 런처와 스레드 관리, JNI 등도 VM 런타임에서 제공한다.&lt;/p&gt;

&lt;h3 id=&quot;jit-optimizer라는게-도대체-뭘까&quot;&gt;JIT Optimizer라는게 도대체 뭘까?&lt;/h3&gt;
&lt;p&gt;모든 코드는 초기에 인터프리터에 의해서 컴파일되고, 해당 코드가 충분히 많이 사용될 경우에 JIT가 컴파일할 대상이 된다. HotSpot VM에서 이 작업은 각 메서드에 있는 카운터를 통해서 통제되며, 메서드에는 두 개의 카운터가 존재한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;수행 카운터(Invocation counter): 메서드를 시작할 때마다 증가&lt;/li&gt;
  &lt;li&gt;백에지 카운터(backedge counter): 높은 바이트 코드 인덱스에서 낮은 인덱스로 컨트롤 흐름이 변경될 때마다 증가&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;backedge counter는 메서드가 루프가 존재하는지를 확인할 때 사용되며, Invocation counter 보다 컴파일 우선순위가 높다.&lt;/p&gt;

&lt;p&gt;이 카운터들이 인터프리터에 의해서 증가될 때마다 그 값들이 한계치에 도달했는지를 확인하고, 도달했을 경우 인터프리터는 컴파일을 요청한다. Invocation counter에서 사용하는 한계치는 CompileThreashold이며, backedge counter에서 사용하는 한계치는 다음의 공식을 계산한다.&lt;/p&gt;

&lt;p&gt;CompileThreashold * OnStackReplacePercentage / 100&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이 두 개의 값들은 JVM이 시작할 때 지정 가능하며 다음과 같이 시작 옵션에 지정할 수 있다.&lt;br /&gt;
-XX:CompileThreashold=35000&lt;br /&gt;
-XX:OnStackReplacePercentage=80&lt;br /&gt;
이렇게 지정하면 메서드가 35000번 호출되었을 때 JIT에서 컴파일을 하며, backedge counter가 35000 * 80 / 100 = 28000이 되었을때 컴파일된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;컴파일이 요청되면 컴파일 대상 목록의 큐에 쌓이고, 하나 이상의 컴파일러 스레드가 이 큐를 모니터링한다. 만약 컴파일 스레드가 바쁘지 않을 때는 큐에서 대상을 빼내서 컴파일을 시작한다. 보통 인터프리터는 컴파일이 종료되기를 기다리지 않고 Invocation counter를 리셋하고 인터프리터에서 메서드 수행을 계속한다. 컴파일이 종료되면 컴파일된 코드와 메서드가 연결되어 그 이후부터는 메서드가 호출되면 컴파일된 코드를 사용하게 된다. 만약 인터프리터에서 컴파일이 종료될 때까지 기다리도록 하려면 JVM 시작시 -Xbatch나 -XX:-BackgroundCompilation 옵션을 지정하여 컴파일을 기다리도록 할 수도 있다.&lt;/p&gt;

&lt;p&gt;HotSpot VM은 OSR(On Stack Replacement)이라는 특별한 컴파일도 수행한다. 이 OSR은 인터프리터에서 수행한 코드 중 오랫동안 루프가 지속되는 경우에 사용된다. 만약 해당 코드의 컴파일이 완료된 상태에서 최적화되지 않은 코드가 수행되고 있는 것을 발견한 경우에 인터프리터에 계속 머무르지 않고 컴파일된 코드로 변경한다. 이 작업은 인터프리터에서 시작된 오랫동안 지속되는 루프가 다시는 불리지 않을 경우엔 도움이 되지 않지만, 루프가 끝나지 않고 지속적으로 수행되고 있을 경우에는 큰 도움이 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java 5 HotSpot VM이 발표되면서 새로운 기능이 추가되었다. 이 기능은 JVM이 시작될 떄 플랫폼과 시스템 설정을 평가하여 자동으로 garbage collector를 선정하고, 자바 힙 사이즈와 JIT 컴파일러를 선택하는 것이다. 이 기능을 통해서 애플리케이션의 활동과 객체 할당 비율에 따라서 garbage collector가 동적으로 자바 힙 사이즈를 조절하며, New의 Eden과 Survivor, Old 영역의 비율을 자동적으로 조절하는 것을 의미한다. 이 기능은 -XX:+UseParallelGC와 -XX:+UseParallelOldGC에서만 적용되며, 이 기능을 제거하려면 -XX:-UseAdaptiveSizePolicy라는 옵션을 적용하여 끌 수가 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;jrockit의-jit-컴파일-및-최적화-절차&quot;&gt;JRockit의 JIT 컴파일 및 최적화 절차&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/images/2019/04/06/jrockit-1.gif&quot; alt=&quot;jrockit-1&quot; title=&quot;jrockit-1&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JVM은 각 OS에서 작동할 수 있도록 자바 코드를 입력 값(정확하게는 바이트코드)으로 받아 각종 변환을 거친 후 해당 칩의 아키텍처에서 잘 돌아가는 기계어 코드로 변환되어 수행되는 구조로 되어 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/06/jrockit-2.gif&quot; alt=&quot;jrockit-2&quot; title=&quot;jrockit-2&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JRockit은 이와 같이 최적화 단계를 거치도록 되어 있으며, 각각의 단계는 다음의 작업을 수행한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;JRockit runs JIT compilation&lt;/strong&gt;&lt;br /&gt;
자바 애플리케이션을 실행하면 기본적으로는 1번 단계인 JIT 컴파일을 거친 후 실행이 된다. 이 단계를 거친 후 메서드가 수행되면, 그 다음부터는 컴파일된 코드를 호출하기 때문에 처리 성능이 빨라진다.&lt;br /&gt;
애플리케이션이 시작하는 동안 몇천 개의 새로운 메서드가 수행되며 이로 인해 다른 JVM보다 JRockit JVM이 더 느릴 수 있다. 그리고 이 작업으로 인해 JIT가 메서드를 수행하고 컴파일하는 작업은 오버헤드가 되지만, JIT가 없으면 JVM은 계속 느린 상태로 지속될 것이다. 다시 말해서 JIT를 사용하면 시작할 때의 성능은 느리겠지만, 지속적으로 수행할 때는 더 빠른 처리가 가능하다. 따라서 모든 메서드를 컴파일하고 최적화하는 작업은 JVM 시작 시간을 느리게 만들기 때문에 시작할 때는 모든 메서드를 최적화하지는 않는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;JRockit monitors threads&lt;/strong&gt;&lt;br /&gt;
JRockit에는 'sampler thread'라는 스레드가 존재하며 주기적으로 애플리케이션의 스레드를 점검한다. 이 스레드는 어떤 스레드가 동작 중인지 여부와 수행 내역을 관리한다. 이 정보들을 통해서 어떤 메서드가 많이 사용되는지를 확인하여 최적화 대상을 찾는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;JRockit JVM performs optimization&lt;/strong&gt;&lt;br /&gt;
'sampler thread'가 식별한 대상을 최적화한다. 이 작업은 백그라운드에서 진행되며 수행중인 애플리케이션에 영향을 주지는 않는다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jvm이-시작할-때의-절차는-이렇다&quot;&gt;JVM이 시작할 때의 절차는 이렇다&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;java 명령어 줄에 있는 옵션 파싱:&lt;br /&gt;
일부 명령은 자바 실행 프로그램에서 적절한 JIT 컴파일러를 선택하는 등의 작업을 하기 위해서 사용하고 다른 명령들은 HotSpot VM에 전달된다.&lt;/li&gt;
  &lt;li&gt;자바 힙 사이즈 할당 및 JIT 컴파일러 타입 지정:&lt;br /&gt;
메모리 크기나 JIT 컴파일러 종류가 명시적으로 지정되지 않은 경우에 자바 실행 프로그램이 시스템의 상황에 맞게 선정한다. 이 과정은 좀 복잡한 단계(HotSpot VM Adaptive Tuning)을 거치니 일단 넘어가자.&lt;/li&gt;
  &lt;li&gt;CLASSPATH와 LD_LIBRARY_PATH 같은 환경 변수를 지정한다.&lt;/li&gt;
  &lt;li&gt;자바의 Main 클래스가 지정되지 않았으면, Jar 파일의 manifest 파일에서 Main 클래스를 확인한다.&lt;/li&gt;
  &lt;li&gt;JNI의 표준 API인 JNI_CreateJavaVM를 사용하여 새로 생성한 non-primordial이라는 스레드에서 HotSpot VM을 생성한다.&lt;/li&gt;
  &lt;li&gt;HotSpot VM이 생성되고 초기화되면, Main 클래스가 로딩된 런처에서는 main() 메서드의 속성 정보를 읽는다.&lt;/li&gt;
  &lt;li&gt;CallStaticVoidMethod는 네이티브 인터페이스를 불러 HotSpot VM에 있는 main() 메서드가 수행된다. 이때 자바 실행 시 Main 클래스 뒤에 있는 값들이 전달된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;추가로 5.에 있는 자바의 가상 머신(JVM)을 생성하는 JNI_CreateJavaVM 단계에 대해서 더 알아보자. 이 단계에서는 다음의 절차를 거친다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;JNI_CreateJavaVM는 동시에 두개의 스레드에서 호출할 수 없고, 오직 하나의 HotSpot VM 인스턴스가 프로세스 내에서 생성될 수 있도록 보장한다. HotSpot VM이 정적인 데이터 구조를 생성하기 때문에 다시 초기화는 불가능해서 오직 하나의 HotSpot VM이 프로세스에서 생성될 수 있다.&lt;/li&gt;
  &lt;li&gt;JNI 버전이 호환성 있는지 점검하고, GC 로깅을 위한 준비도 완료한다.&lt;/li&gt;
  &lt;li&gt;OS 모듈들이 초기화된다. 예를 들면 랜덤 번호 생성기, PID 할당 등이 여기에 속한다.&lt;/li&gt;
  &lt;li&gt;커맨드 라인 변수와 속성들이 JNI_CreateJavaVM 변수에 전달되고, 나중에 사용하기 위해서 파싱한 후 보관한다.&lt;/li&gt;
  &lt;li&gt;표준 자바 시스템 속성(properties)이 초기화된다.&lt;/li&gt;
  &lt;li&gt;동기화, 메모리, safepoint 페이지와 같은 모듈들이 초기화된다.&lt;/li&gt;
  &lt;li&gt;libzip, libhpi, libjava, libthread와 같은 라이브러리들이 로드된다.&lt;/li&gt;
  &lt;li&gt;시그널 처리기가 초기화 및 설정된다.&lt;/li&gt;
  &lt;li&gt;스레드 라이브러리가 초기화된다.&lt;/li&gt;
  &lt;li&gt;출력(output) 스트림 로거가 초기화된다.&lt;/li&gt;
  &lt;li&gt;JVM을 모니터링하기 위한 에이전트 라이브러리가 설정되어 있으면 초기화 및 시작된다.&lt;/li&gt;
  &lt;li&gt;스레드 처리를 위해서 필요한 스레드 상태와 스레드 로컬 저장소가 초기화된다.&lt;/li&gt;
  &lt;li&gt;HotSpot VM의 '글로벌 데이터'들이 초기화된다. 글로벌 데이터에는 이벤트 로그(event log), OS 동기화, 성능 통계 메모리(perfMemory), 메모리 할당자(chunkPool)들이 있다.&lt;/li&gt;
  &lt;li&gt;HotSpot VM에서 스레드를 생성할 수 있는 상태가 된다. main 스레드가 생성되고, 현재 OS 스레드에 붙는다. 그러나 아직 스레드 목록에 추가되지는 않는다.&lt;/li&gt;
  &lt;li&gt;자바 레벨의 동기화가 초기화 및 활성화된다.&lt;/li&gt;
  &lt;li&gt;부트 클래스로더, 코드 캐시, 인터프리터, JIT 컴파일러, JNI, 시스템 dictionary, '글로벌 데이터' 구조의 집합인 universe 등이 초기화된다.&lt;/li&gt;
  &lt;li&gt;스레드 목록에 자바 main 스레드가 추가되고 universe의 상태를 점검한다. HotSpot VM의 중요한 기능을 하는 HotSpot VM Thread가 생성된다. 이 시점에 HotSpot VM의 현재 상태를 JVMTI에 전달한다.&lt;/li&gt;
  &lt;li&gt;java.lang 패키지에 있는 String, System, Thread, ThreadGroup, Class 클래스와 java.lang의 하위 패키지에 있는 Method, Finalizer 클래스 등이 로딩되고 초기화된다.&lt;/li&gt;
  &lt;li&gt;HotSpot VM의 시그널 핸들러 스레드가 시작되고 JIT 컴파일러가 초기화되며 HotSpot의 컴파일 브로커 스레드가 시작된다. 그리고 HotSpot VM과 관련된 각종 스레드들이 시작한다. 이때부터 HotSpot VM의 전체 기능이 동작한다.&lt;/li&gt;
  &lt;li&gt;JNIEnv가 시작되며 HotSpot VM을 시작한 호출자에게 새로운 JNI 요청을 처리할 상황이 되었다고 전달해 준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이렇게 복잡한 JNI_CreateJavaVM 시작 단계를 거치고 나머지 단계들을 거치면 JVM이 시작된다.&lt;/p&gt;

&lt;h3 id=&quot;jvm이-종료될-때의-절차는-이렇다&quot;&gt;JVM이 종료될 때의 절차는 이렇다&lt;/h3&gt;
&lt;p&gt;HotSpot VM의 종료는 다음의 DestroyJavaVM 메서드의 종료 절차를 따른다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;HotSpot VM이 작동중인 상황에서는 단 하나의 데몬이 아닌 스레드(nondaemon thread)가 수행될 때까지 대기한다.&lt;/li&gt;
  &lt;li&gt;java.lang 패키지에 있는 Shutdown 클래스의 shutdown() 메서드가 수행된다. 이 메서드가 수행되면 자바 레벨의 shutdown hook이 수행되고, finalization-on-exit이라는 값이 true일 경우에 자바 객체 finalizer를 수행한다.&lt;/li&gt;
  &lt;li&gt;HotSpot VM 레벨의 shutdown hook을 수행함으로써 HotSpot VM의 종료를 준비한다. 이 작업은 JVM_OnExit() 메서드를 통해서 지정된다. 그리고 HotSpot VM의 profiler, stat sampler, watcher, garbage collector 스레드를 종료시킨다. 이 작업들이 종료되면 JVMTI를 비활성화하며 Signal 스레드를 종료시킨다.&lt;/li&gt;
  &lt;li&gt;HotSpot의 JavaThread::exit() 메서드를 호출하여 JNI 처리 블록을 해제한다. 그리고 guard pages 스레드 목록에 있는 스레드들을 삭제한다. 이 순간부터는 HotSpot VM에서 자바 코드를 실행하지 못한다.&lt;/li&gt;
  &lt;li&gt;HotSpot VM 스레드를 종료한다. 이 작업을 수행하면 HotSpot VM에 남아 있는 HotSpot VM 스레드들을 safepoint로 옮기고 JIT 컴파일러 스레드들을 중지시킨다.&lt;/li&gt;
  &lt;li&gt;JNI, HotSpot VM, JVMTI barrier에 있는 추적(tracing) 기능을 종료시킨다.&lt;/li&gt;
  &lt;li&gt;네이티브 스레드에서 수행하고 있는 스레드들을 위해서 HotSpot의 &quot;vm exited&quot; 값을 설정한다.&lt;/li&gt;
  &lt;li&gt;현재 스레드를 삭제한다.&lt;/li&gt;
  &lt;li&gt;입출력 스트림을 삭제하고 PrefMemory 리소스 연결을 해제한다.&lt;/li&gt;
  &lt;li&gt;JVM 종료를 호출한 호출자로 복귀한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;클래스-로딩-절차도-알고-싶어요&quot;&gt;클래스 로딩 절차도 알고 싶어요&lt;/h3&gt;
&lt;p&gt;자바 클래스가 메모리에 로딩되는 절차는 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;주어진 클래스의 이름으로 class path에 있는 바이너리로 된 자바 클래스를 찾는다.&lt;/li&gt;
  &lt;li&gt;자바 클래스를 정의한다.&lt;/li&gt;
  &lt;li&gt;해당 클래스를 나타내는 java.lang 패키지의 Class 클래스의 객체를 생성한다.&lt;/li&gt;
  &lt;li&gt;링크 작업이 수행된다. 이 단계에서 static 필드를 생성 및 초기화하고 메서드 테이블을 할당한다.&lt;/li&gt;
  &lt;li&gt;클래스의 초기화가 진행되며 static 블록과 static 필드가 가장 먼저 초기화된다. 당연한 이야기지만 해당 클래스가 초기화 되기 전에 부모 클래스의 초기화가 먼저 이루어진다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이렇게 나열하니 단계가 복잡해 보이지만, loading -&amp;gt; linking -&amp;gt; initializing 로 기억하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;예외는-jvm에서-어떻게-처리될까&quot;&gt;예외는 JVM에서 어떻게 처리될까?&lt;/h3&gt;
&lt;p&gt;JVM은 자바 언어의 제약을 어겼을 때 예외(exception)라는 시그널로 처리한다. HotSpot VM 인터프리터, JIT 컴파일러 및 다른 HotSpot VM 컴포넌트는 예외 처리와 모두 관련되어 있다. 일반적인 예외 처리 경우는 아래 두 가지 경우다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예외를 발생한 메서드에서 잡을 경우&lt;/li&gt;
  &lt;li&gt;호출한 메서드에 의해서 잡힐 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;후자의 경우에는 보다 복잡하며 스택을 뒤져서 적당한 핸들러를 찾는 작업을 필요로 한다.&lt;/p&gt;

&lt;p&gt;예외는,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;던져진 바이트 코드에 의해서 초기화될 수 있으며,&lt;/li&gt;
  &lt;li&gt;VM 내부 호출의 결과로 넘어올 수도 있고,&lt;/li&gt;
  &lt;li&gt;JNI 호출로부터 넘어올 수도 있고,&lt;/li&gt;
  &lt;li&gt;자바 호출로부터 넘어올 수도 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 가장 마지막 경우는 단순히 앞의 세가지 경우의 마지막 단계에 속할 뿐이다.&lt;/p&gt;

&lt;p&gt;VM이 예외가 던져졌다는 것을 알아차렸을 때, 해당 예외를 처리하는 가장 가까운 핸들러를 찾기 위해서 HotSpot VM 런타임 시스템이 수행된다. 이 때 핸들러를 찾기 위해서는 다음의 3개 정보가 사용된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;현재 메서드&lt;/li&gt;
  &lt;li&gt;현재 바이트 코드&lt;/li&gt;
  &lt;li&gt;예외 객체&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만약 현재 메서드에서 핸들러를 찾지 못했을 때는 현재 수행되는 스택 프레임을 통해서 이전 프레임을 찾는 작업을 수행한다. 적당한 핸들러를 찾으면, HotSpot VM 수행 상태가 변경되며, HotSpot VM은 핸들러로 이동하고 자바 코드 수행은 계속된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;17-도대체-gc는-언제-발생할까&quot;&gt;17. 도대체 GC는 언제 발생할까?&lt;/h1&gt;

&lt;h3 id=&quot;자바의-runtime-data-area는-이렇게-구성된다&quot;&gt;자바의 Runtime data area는 이렇게 구성된다&lt;/h3&gt;
&lt;p&gt;자바에서 데이터를 처리하기 위한 영역에는 어떤 것들이 있는지 살펴보자. 다음은 오라클에서 제공하는 자바 스펙 관련 문서에 명시된 영역들이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PC 레지스터&lt;/li&gt;
  &lt;li&gt;JVM 스택&lt;/li&gt;
  &lt;li&gt;힙(Heap)&lt;/li&gt;
  &lt;li&gt;메서드 영역&lt;/li&gt;
  &lt;li&gt;런타임 상수(constant) 풀&lt;/li&gt;
  &lt;li&gt;네이티브 메서드 스택&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 영역 중에서 GC가 발생하는 부분이 바로 힙 영역이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/06/java-runtime-data.png&quot; alt=&quot;java-runtime-data&quot; title=&quot;java-runtime-data&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;상단에 있는 'Class Loader Subsystem'은 클래스나 인터페이스르 JVM으로 로딩하는 기능을 수행하고, 'Execution Engine'은 로딩된 크래스의 메서드들에 포함되어 있는 모든 인스트럭션 정보를 실행한다. 이 그림을 보면 좀 복잡해 보이지만, 단순하게 이야기해서 자바의 메모리 영역은 'Heap 메모리'와 'Non-Heap 메모리'로 나뉜다.&lt;/p&gt;

&lt;h3 id=&quot;heap-메모리&quot;&gt;Heap 메모리&lt;/h3&gt;
&lt;p&gt;클래스 인스턴스, 배열이 이 메모리에 쌓인다. 이 메모리는 '공유(shared) 메모리'라고도 불리며 여러 스레드에서 공유하는 데이터들이 저장되는 메모리다.&lt;/p&gt;

&lt;h3 id=&quot;non-heap-메모리&quot;&gt;Non-heap 메모리&lt;/h3&gt;
&lt;p&gt;이 메모리는 자바의 내부 처리를 위해서 필요한 영역이다. 여기서 주된 영역이 바로 메서드 영역이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Method Area&lt;/strong&gt;: 메서드 영역은 모든 JVM 스레드에서 공유한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Java Stacks&lt;/strong&gt;: 스레드가 시작할 때 JVM 스택이 생성된다. 이 스택에는 메서드가 호출되는 정보인 프레임(frame)이 저장된다. 그리고 지역 변수와 임시 결과, 메서드 수행과 리턴에 관련된 정보들도 포함된다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PC Registers&lt;/strong&gt;: 자바의 스레드들은 각자의 PC(Program Counter) 레지스터를 갖는다. 네이티브한 코드를 제외한 모든 자바 코드들이 수행될 때 JVM의 인스트럭션 주소를 PC 레지스터에 보관한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Native Method Stacks&lt;/strong&gt;: 자바 코드가 아닌 다른 언어로 된 코드들이 실행하게 될 때의 스택 정보를 관리한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;스택의 크기는 고정하거나 가변적일 수 있다. 만약 연산을 하다가 JVM의 스택 크기의 최대치를 넘어섰을 경우에는 StackOverflowError가 발생한다.
그리고 가변적일 경우 스택의 크기를 늘이려고 할 때 메모리가 부족하거나 스레드를 생성할 때 메모리가 부족한 경우에는 OutOfMemoryError가 발생한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;gc의-원리&quot;&gt;GC의 원리&lt;/h3&gt;
&lt;p&gt;GC 작업을 하는 가비지 컬렉터(Garbage Collector)는 다음의 역할을 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메모리 할당&lt;/li&gt;
  &lt;li&gt;사용 중인 메모리 인식&lt;/li&gt;
  &lt;li&gt;사용하지 않는 메모리 인식&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사용하지 않는 메모리를 인식하는 작업을 수행하지 않으면 할당한 메모리 영역이 꽉 차서 JVM에 행(Hang)이 걸리거나, 더 많은 메모리를 할당하려는 현상이 발생할 것이다. 만약 JVM의 최대 메모리 크기를 지정해서 전부 사용한 다음 GC를 해도 더 이상 사용 가능한 메모리 영역이 없는데 계속 메모리를 할당하려고 하면 OutOfMemoryError가 발생하여 JVM이 다운될 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/06/Java-Memory-Model.png&quot; alt=&quot;Java-Memory-Model&quot; title=&quot;Java-Memory-Model&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자바의 메모리 영역은 크게 Young, Old, Perm 세 영역으로 나뉜다. Perm(Permanent) 영역은 없는 걸로 치자. 이 영역은 거의 사용이 되지 않는 영역으로 클래스와 메서드 정보와 같이 자바 언어 레벨에서 사용하는 영역이 아니기 때문이다. 게다가 JDK 8부터는 이 영역이 사라진다. Young 영역은 다시 Eden 영역 및 두 개의 Survivor 영역으로 나뉘므로 우리가 고려해야 할 자바의 메모리 영역은 총 4개 영역으로 나뉜다고 볼 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;일단 메모리에 객체가 생성되면, 가장 왼쪽인 Eden 영역에 객체가 지정된다.&lt;/li&gt;
  &lt;li&gt;Eden 영역에 데이터가 꽉 차면, 이 영역에 있던 객체는 Survivor 영역으로 옮겨지거나 삭제된다. 두 개의 Survivor 영역 사이에 우선 순위가 있는 것은 아니다. 이 두 개의 영역 중 한 영역은 반드시 비어 있어야 한다. 그 비어 있는 영역에 Eden 영역에 있떤 객체 중 GC 후에 살아 남은 객체들이 이동한다.&lt;/li&gt;
  &lt;li&gt;이와 같이 Eden 영역에 있던 객체는 Survivor 영역의 둘 중 하나에 할당된다. 할당된 Survivor 영역이 차면, GC가 되면서 Eden 영역에 있는 객체와 꽉 찬 Survivor 영역에 있는 객체가 비어 있는 Survivor 영역으로 이동한다. 이러한 작업을 반복하면서 Survivor 1과 2를 왔다갔다 하던 객체들은 Old 영역으로 이동한다.&lt;/li&gt;
  &lt;li&gt;Young 영역에서 Old 영역으로 넘어가는 객체 중 Survivor 영역을 거치지 않고 바로 Old 영역으로 이동하는 객체가 있을 수 있다. 객체의 크기가 아주 큰 경우인데 예를 들어, Survivor 영역의 크기가 16MB인데 20MB를 점유하는 객체가 Eden 영역에서 생성되면 Survivor 영역으로 옮겨 갈 수 없고 바로 Old 영역으로 이동하게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;gc의-종류&quot;&gt;GC의 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Minor GC: Young 영역에서 발생하는 GC&lt;/li&gt;
  &lt;li&gt;Major GC: Old 영역이나 Perm 영역에서 발생하는 GC&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 두 가지 GC가 어떻게 상호 작용하느냐에 따라 GC 방식에 차이가 나며, 성능에도 영향을 준다.&lt;/p&gt;

&lt;p&gt;GC가 발생하거나 객체가 각 영역에서 다른 영역으로 이동할 때 애플리케이션의 병목이 발생하면서 성능에 영향을 주게 된다. 그래서 핫-스팟(Hot Spot) VM에서는 스레드 로컬 할당 버퍼(TLABs: Thread-Local Allocation Buffers)라는 것을 사용한다. 이를 통하여 각 스레드별 메모리 버퍼를 사용하면 다른 스레드에 영향을 주지 않는 메모리 할당 작업이 간으해진다.&lt;/p&gt;

&lt;h3 id=&quot;5가지-gc-방식&quot;&gt;5가지 GC 방식&lt;/h3&gt;
&lt;p&gt;JDK 7 이상에서 지원하는 GC 방식에는 다섯 가지가 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Serial Collector&lt;/strong&gt;&lt;br /&gt;
Young 영역과 Old 영역이 시리얼하게(연속적으로) 처리되며 하나의 CPU를 사용한다. Sun에서는 이 처리를 수행할 때를 Stop-the-world라고 표현한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/06/serial-collection-1.png&quot; alt=&quot;serial-collection-1&quot; title=&quot;serial-collection-1&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;살아 있는 객체들은 Eden 영역에 있다.&lt;/li&gt;
  &lt;li&gt;Eden 영역이 꽉차게 되면 To Survivor 영역(비어 있는 영역)으로 살아 있는 객체가 이동한다. 이때 Survivor 영역에 들어가기에 너무 큰 객체는 바로 Old 영역으로 이동한다. 그리고 From Survivor 영역의 살아 있는 객체는 To Survivor 영역으로 이동한다.&lt;/li&gt;
  &lt;li&gt;To Survivor 영역이 꽉 찼을 경우, Eden 영역이나 From Survivor 영역에 남아 있는 객체들은 Old 영역으로 이동한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/06/serial-collection-2.png&quot; alt=&quot;serial-collection-2&quot; title=&quot;serial-collection-2&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이후에 Old 영역이나 Perm 영역에 있는 객체들은 Mark-sweep-compact 콜렉션 알고리즘을 따른다. 이 알고리즘에 대해서 간단하게 말하면, 쓰이지 않는 객체를 표시해서 삭제하고 한 곳으로 모으는 알고리즘이다. 다음과 같이 수행된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Old 영역으로 이동된 객체들 중 살아 있는 객체를 식별(mark).&lt;/li&gt;
  &lt;li&gt;Old 영역의 객체들을 훑는 작업을 수행하여 쓰레기 객체를 식별(sweep).&lt;/li&gt;
  &lt;li&gt;필요 없는 객체들을 지우고 살아 있는 객체들을 한 곳으로 모은다(compaction).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/06/serial-collection-3.png&quot; alt=&quot;serial-collection-3&quot; title=&quot;serial-collection-3&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 작동하는 시리얼 콜렉터는 일반적으로 클라이언트 종류의 장비에서 많이 사용된다. 다시 말하면 대기 시간이 많아도 큰 문제되지 않는 시스템에서 사용된다는 의미다. 시리얼 콜렉터를 명시적으로 지정하려면 자바 명령 옵션에 -XX:+UseSerialGC를 지정하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Parallel Collector&lt;/strong&gt;&lt;br /&gt;
다른 CPU가 대기 상태로 남아 있는 것을 최소화하는 것을 목표로 한다. Serial Collector와 달리 Young 영역에서의 콜렉션을 병렬(Parallel)로 처리한다. 많은 CPU를 사용하기 때문에 GC의 부하를 줄이고 애플리케이션의 처리량을 증가시킬 수 있다.&lt;/p&gt;

&lt;p&gt;Old 영역의 GC는 Serial Collector와 마찬가지로 Mark-sweep-compact 콜렉션 알고리즘을 사용한다. 이 방법으로 GC를 지정하려면 -XX:+UseParallelGC 옵션을 추가하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/06/parallel-collection.png&quot; alt=&quot;parallel-collection&quot; title=&quot;parallel-collection&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Parallel Compacting Collector&lt;/strong&gt;&lt;br /&gt;
Parallel Collector와 다른 점은 Old 영역 GC에서 새로운 알고리즘을 사용한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Marking: 살아 있는 객체를 식별하여 표시&lt;/li&gt;
  &lt;li&gt;Summary: 이전에 GC를 수행하여 컴팩션된 영역에 살아 있는 객체의 위치를 조사하는 단계&lt;/li&gt;
  &lt;li&gt;Compaction: 컴팩션을 수행하는 단계. 수행 이후에는 컴팩션된 영역과 비어 있는 영역으로 나뉜다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;병렬 콜렉터와 동일하게 이 방식도 여러 CPU를 사용하는 서버에 적합하다. GC를 사용하는 스레드 개수는 -XX:ParallelGCThreads=n 옵션으로 조정할 수 있다. 이 방식을 사용하려면 -XX:UseParallelOldGC 옵션을 추가하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Concurrent Mark-Sweep(CMS) Collector&lt;/strong&gt;&lt;br /&gt;
힙 메모리 영역의 크기가 클 때 적합하다. Young 영역에 대한 GC는 Parallel Collector와 동일하고, Old 영역은 다음 단계를 거친다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Initial mark: 매우 짧은 대기 시간으로 살아 있는 객체를 찾는 단계&lt;/li&gt;
  &lt;li&gt;Concurrent marking: 서버 수행과 동시에 살아 있는 객체에 표시를 해놓는 단계&lt;/li&gt;
  &lt;li&gt;Remark: Concurrent marking 단계에서 표시하는 동안 변경된 객체에 대해서 다시 표시하는 단계&lt;/li&gt;
  &lt;li&gt;Concurrent sweep: 표시되어 있는 쓰레기를 정리하는 단계&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/06/cms-collector-1.png&quot; alt=&quot;cms-collector-1&quot; title=&quot;cms-collector-1&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/06/cms-collector-2.png&quot; alt=&quot;cms-collector-2&quot; title=&quot;cms-collector-2&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CMS 콜렉터 방식은 2개 이상의 프로세서를 사용하는 서버에 적당하다(웹서버). 이 방식을 사용하려면 -XX:UseConcMarkSweepGC 옵션을 추가하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;G1 Collector&lt;/strong&gt;&lt;br /&gt;
지금까지 설명한 모든 GC는 Eden과 Survivor 영역으로 나뉘는 Young 영역과 Old 영역으로 구성되어 있다. 하지만 Garage First(G1)는 지금까지의 GC와는 다른 영역으로 구성되어 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/06/g1-heap.png&quot; alt=&quot;g1-heap&quot; title=&quot;g1-heap&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각 바둑의 사각형을 region이라고 하는데, Young 영역과 Old 영역이 물리적으로 나뉘어 있지 않고 각 구역의 크기는 모두 동일하다. 이 바둑판 모양의 구역이 각각 Eden, Survivor, Old 영역의 역할을 변경해 가면서 하고, Humongous라는 영역도 포함된다. G1이 Young GC를 어떻게 하는지 살펴보자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;몇 개의 구역을 선정하여 Young 영역으로 지정한다.&lt;/li&gt;
  &lt;li&gt;이 Linear 하지 않은 구역에 객체가 생성되면서 데이터가 쌓인다.&lt;/li&gt;
  &lt;li&gt;Young 영역으로 할당된 구역에 데이터가 꽉 차면 GC를 수행한다.&lt;/li&gt;
  &lt;li&gt;GC를 수행하면서 살아있는 객체들만 Survivor 구역으로 이동시킨다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이렇게 살아 남은 객체들이 이동된 구역은 새로운 Survivor 영역이 된다. 그 다음에 Young GC가 발생하면 Survivor 영역에 계속 쌓는다. 그러면서 몇 번의 aging 작업을 통해서 Old 영역으로 승격된다.&lt;/p&gt;

&lt;p&gt;G1의 Old 영역 GC는 CMS GC의 방식과 비슷하며 아래 여섯 단계로 나뉜다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Initial mark: Old 영역에 있는 객체에서 Survivor 영역의 객체를 참조하고 있는 객체들을 표시한다.&lt;/li&gt;
  &lt;li&gt;Root region scanning: Old 영역 참조를 위해서 Survivor 영역을 훑는다. 이 작업은 Young GC가 발생하기 전에 수행된다.&lt;/li&gt;
  &lt;li&gt;Concurrent mark: 전체 힙 영역에 살아있는 객체를 찾는다. 만약 이때 Young GC가 발생하면 잠시 멈춘다.&lt;/li&gt;
  &lt;li&gt;Remark: 힙에 살아있는 객체들의 표시 작업을 완료한다. 이때 Snapshot-At-The-Beginning(SATB) 알고리즘을 사용하며 이는 CMS GC에서 사용하는 방식보다 빠르다.&lt;/li&gt;
  &lt;li&gt;Cleaning: 살아있는 객체와 비어 있는 구역을 식별하고, 필요없는 객체들을 지운다. 그리고 나서 비어있는 구역을 초기화한다.&lt;/li&gt;
  &lt;li&gt;Copy: 살아있는 객체들을 비어있는 구역으로 모은다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;G1은 CMS GC의 단점을 보완하기 위해서 만들어졌으며 성능도 매우 빠르다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;18-gc가-어떻게-수행되고-있는지-보고-싶다&quot;&gt;18. GC가 어떻게 수행되고 있는지 보고 싶다&lt;/h1&gt;

&lt;h3 id=&quot;자바-인스턴스-확인을-위한-jps&quot;&gt;자바 인스턴스 확인을 위한 jps&lt;/h3&gt;
&lt;p&gt;jps는 해당 머신에서 운영중인 JVM의 목록을 보여준다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mlvV&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Joption&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hostid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;gc-상황을-확인하는-jstat&quot;&gt;GC 상황을 확인하는 jstat&lt;/h3&gt;
&lt;p&gt;jstat는 GC가 수행되는 정보를 확인하기 위한 명령이다. jstat를 사용하면 유닉스 장비에서 vmstat나 netstat와 같이 라인 단위로 결과를 보여준다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jstat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lines&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vmid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interval&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;gc-튜닝할-때-가장-유용한-jstat-옵션은-두-개&quot;&gt;GC 튜닝할 때 가장 유용한 jstat 옵션은 두 개&lt;/h3&gt;
&lt;p&gt;jstat 명령에서 GC 튜닝을 위해서 필자가 가장 애용하는 옵션은 -gcutil과 -gccapacity이다. gccapacity 옵션은 각 영역의 크기를 알 수 있기 때문에 어떤 영역의 크기를 좀 더 늘리고 줄여야 할 지를 확인할 수 있다. gcutil 옵션은 힙 영역의 사용량을 %로 보여준다.&lt;/p&gt;

&lt;h3 id=&quot;원격으로-jvm-상황을-모니터링하기-위한-jstatd&quot;&gt;원격으로 JVM 상황을 모니터링하기 위한 jstatd&lt;/h3&gt;
&lt;p&gt;jstatd 명령어로 원격 모니터링에 사용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jstatd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rminame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;verbosegc-옵션을-이용하여-gc-로그-남기기&quot;&gt;verbosegc 옵션을 이용하여 gc 로그 남기기&lt;/h3&gt;
&lt;p&gt;jvmstat를 사용할 수 없는 상황이라면 어떻게 GC를 분석할 수 있을까? 자바 수행 시에 -verbosegc 옵션을 넣어주면 된다.&lt;/p&gt;

&lt;h3 id=&quot;어설프게-아는-것이-제일-무섭다&quot;&gt;어설프게 아는 것이 제일 무섭다.&lt;/h3&gt;
&lt;p&gt;예를 들어 메모리를 2GB로 지정한 시스템에 초당 1건의 요청이 오는 곳에서 한 번 요청이 올 때 10MB의 메모리가 생성된다고 가정하다. 이 시스템의 Old 영역이 1% 증가하려면 얼마나 기다려야 할까?&lt;/p&gt;

&lt;p&gt;한 번 요청 올 때 생성되는 10MB의 메모리는 Eden 영역에 쌓일 것이다. 이 데이터가 Survivor 영역으로 넘어가고 Old 영역으로 넘어갈 확률은 얼마나 될까? 보통의 경우 JVM이 자동으로 지정해주는 Young 영역과 Old 영역의 비율은 1:2 ~ 1:9 정도다. 그러면 2GB에서는 100~300MB 정도가 Young 영역에 할당될 것이다. 그럼 이 시스템의 Old 영역이 1% 증가하려면 얼마나 기다려야 할까? 정답은 없지만 적어도 5분에서 2시간 정도 소요될 것이다. 5분에 1%라면 한시간에 12%, 9시간 정도 되어야 100%에 도달하여 Full GC가 발생하게 될 것이다.&lt;/p&gt;

&lt;p&gt;메모리 릭이 발생하는지 확인하는 가장 확실한 방법은 verbosegc를 남겨서 보는 방법이다. 그리고 간단하게 확인할 수 있는 가장 확실한 방법은 Full GC가 일어난 이후에 메모리 사용량을 보는 것이다. 정확하게 이야기해서 Full GC가 수행된 후에 Old 영역의 메모리 사용량을 보자. 만약 사용량이 80% 이상이면 메모리 릭을 의심해야 한다. 그런데 Full GC를 한번도 하지 않은 시스템에 메모리 릭이 있다고 생각할 수 있는가? 어떤 시스템도 Full GC가 한번도 발생하지 않는 상황에서 메모리 릭이 있다고 이야기할 수 없다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;19-gc-튜닝을-항상-할-필요는-없다&quot;&gt;19. GC 튜닝을 항상 할 필요는 없다&lt;/h1&gt;
&lt;p&gt;GC 튜닝이 필요 없다는 이야기는 운영 중인 Java 기반 시스템의 옵션에 기본적으로 다음과 같은 것들은 추가되어 있을 때의 경우다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-Xms, -Xmx 옵션으로 메모리 크기를 지정했다.&lt;/li&gt;
  &lt;li&gt;-server 옵션이 포함되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그리고 시스템의 로그에는 다음과 같은 타임아웃 관련 로그가 남아있지 않아야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DB 작업과 관련된 타임아웃&lt;/li&gt;
  &lt;li&gt;다른 서버와의 통신시 타임아웃&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그래서 JVM의 메모리 크기도 지정하지 않았고, Timeout이 지속적으로 발생하고 있다면 시스템에서 GC 튜닝을 하는 것이 좋다. 그런데 명심할 것은 GC 튜닝은 가장 마지막에 하는 작업이라는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;old-영역으로-넘어가는-객체의-수-최소화하기&quot;&gt;Old 영역으로 넘어가는 객체의 수 최소화하기&lt;/h3&gt;
&lt;p&gt;Oracle JVM에서 제공하는 모든 GC는 Generational GC이다. 즉 Eden 영역에서 객체가 처음 만들어지고 Survivor 영역을 오가다가 끝까지 남아 있는 객체는 Old 영역으로 이동한다. 간혹 Eden 영역에서 만들어지다가 크기가 커져서 Old 영역으로 바로 넘어가는 객체도 있긴 하다. Old 영역의 GC는 New 영역의 GC에 비하여 상대적으로 시간이 오래 소요되기 때문에 Old 영역으로 이동하는 객체의 수를 줄이면 Full GC가 발생하는 빈도를 많이 줄일 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;full-gc-시간-줄이기&quot;&gt;Full GC 시간 줄이기&lt;/h3&gt;
&lt;p&gt;Full GC의 수행 시간은 상대적으로 Young GC에 비하여 길다. 그래서 Full GC 실행에 시간이 오래 소요되면(1초 이상) 연계된 여러 부분에서 타임아웃이 발생할 수 있다. 그렇다고 Full GC 실행 시간을 줄이기 위해 Old 영역의 크기를 줄이면 OutOfMemoryError가 발생하거나 Full GC 횟수가 늘어난다. 반대로 Old 영역의 크기를 늘리면 Full GC 횟수는 줄어들지만 실행 시간이 늘어난다. Old 영역의 크기를 적절하게 '잘' 설정해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;gc의-성능을-결정하는-옵션들&quot;&gt;GC의 성능을 결정하는 옵션들&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;구분&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;옵션&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;힙(heap) 영역 크기&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-Xms&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;JVM 시작 시 힙 영역 크기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;힙(heap) 영역 크기&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-Xmx&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;최대 힙 영역 크기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;New 영역 크기&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-XX:NewRatio&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;New 영역과 Old 영역의 비율&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;New 영역 크기&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-XX:NewSize&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;New 영역의 크기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;New 영역 크기&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-XX:SurvivorRatio&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Eden 영역과 Survivor 영역의 비율&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;GC 의 성능에 많은 영향을 주는 또 다른 옵션은 GC 방식이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;구분&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;옵션&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Serial GC&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-XX:+UseSerialGC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Parallel GC&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-XX:+UseParallelGC&lt;br /&gt; -XX:ParallelGCTHreads=value&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Parallel Compacting GC&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-XX:+UseParallelOldGC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CMS GC&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-XX:+UseConcMarkSweepGC&lt;br /&gt; -XX:+UseParNewGC&lt;br /&gt; -XX:+CMSParallelRemarkEnabled&lt;br /&gt; -XX:CMSInitiatingOccupancyFraction=value&lt;br /&gt; -XX:+UseCMSInitiatingOccupancyOnly&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;G1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-XX:+UnlockExperimentalVMOptions&lt;br /&gt; -XX:+UseG1GC&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;G1 GC를 제외하고는 각 GC 방식의 첫 번째 줄에 있는 옵션을 지정하면 GC 방식이 변경된다. Serial GC는 클라이언트 장비에 최적화되어 있기 때문에 특별히 신경쓸 필요가 없다.&lt;/p&gt;

&lt;h3 id=&quot;gc-튜닝-절차&quot;&gt;GC 튜닝 절차&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;GC 상황 모니터링&lt;/li&gt;
  &lt;li&gt;모니터링 결과 분석 후 GC 튜닝 여부 결정&lt;br /&gt;
분석 결과 GC 수행에 소요된 시간이 0.1~0.3초 밖에 안된다면 굳이 튜닝할 필요 없다. 하지만 1~3초, 심지어 10초 이상 걸리면 GC 튜닝을 진행해야 한다.&lt;/li&gt;
  &lt;li&gt;GC 방식/메모리 크기 지정&lt;/li&gt;
  &lt;li&gt;결과 분석&lt;/li&gt;
  &lt;li&gt;결과가 만족스러울 경우 전체 서버에 반영 및 종료&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;references&quot;&gt;References&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.yes24.com/Product/Goods/11261731&quot;&gt;개발자가 반드시 알아야 할 자바 성능 튜닝 이야기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://dzone.com/articles/understanding-garbage-collectorsgc-in-depth&quot;&gt;Understanding HotSpot VM Garbage Collectors (GC) in Depth&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/cd/E15289_01/JRSDK/underst_jit.htm&quot;&gt;Understanding Just-In-Time Compilation and Optimization&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf&quot;&gt;Memory Management in the Java HotSpot™ Virtual Machine&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
      </entry>
      
  
      
      <entry>
        <id>https://sungjk.github.io/2019/04/06/java-performance-tuning-3.html</id>
        <link type="text/html" rel="alternate" href="https://sungjk.github.io/2019/04/06/java-performance-tuning-3.html"/>
        <title>자바 성능 튜닝 이야기 - 3</title>
        <updated>2019-04-06T00:00:00+00:00</updated>
        <author>
          <name>김성중</name>
          <email>ajax0615@gmail.com</email>
        </author>
        <content type="html">&lt;p&gt;&lt;img src=&quot;/images/2019/03/28/java_performance_tuning.jpeg&quot; alt=&quot;java_performance_tuning&quot; title=&quot;java_performance_tuning&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;11-jsp와-서블릿-spring에서-발생할-수-있는-여러-문제점&quot;&gt;11. JSP와 서블릿, Spring에서 발생할 수 있는 여러 문제점&lt;/h1&gt;
&lt;p&gt;JSP의 라이프 사이클은 다음의 단계를 거친다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;JSP URL 호출&lt;/li&gt;
  &lt;li&gt;페이지 번역&lt;/li&gt;
  &lt;li&gt;JSP 페이지 컴파일&lt;/li&gt;
  &lt;li&gt;클래스 로드&lt;/li&gt;
  &lt;li&gt;인스턴스 생성&lt;/li&gt;
  &lt;li&gt;jspInit 메서드 호출&lt;/li&gt;
  &lt;li&gt;_jspService 메서드 호출&lt;/li&gt;
  &lt;li&gt;jspDestroy 메서드 호출&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;여기서 해당 JSP 페이지가 이미 컴파일되어 있고, 클래스가 로드외어 있고, JSP 파일이 변경되지 않았다면, 가장 많은 시간이 소요되는 2~4 프로세스는 생략된다. 서버의 종류에 따라서 서버가 기동될 때 컴파일을 미리 수행하는 Precompile 옵션이 있다. 이 옵션을 선택하면 서버에 최신 버전을 반영한 이후에 처음 호출되었을 때 응답 시간이 느린 현상을 방지할 수 있다.&lt;/p&gt;

&lt;p&gt;이번에는 서블릿의 라이프 사이클을 살펴보자. WAS의 JVM이 시작한 후에는,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Servlet 객체가 자동으로 생성되고 초기화 되거나,&lt;/li&gt;
  &lt;li&gt;사용자가 해당 Servlet을 처음으로 호출했을 때 생성되고 초기화 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/06/servlet-life-cycle.png&quot; alt=&quot;servlet-life-cycle&quot; title=&quot;servlet-life-cycle&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그 다음에는 계속 '사용 가능' 상태로 대기한다. 그리고 중간에 예외가 발생하면 '사용 불가능' 상태로 빠졌다가 다시 '사용 가능' 상태로 변환되기도 한다. 그리고 나서, 해당 서블릿이 더 이상 필요 없을 때는 '파기' 상태로 넘어간 후 JVM에서 '제거'된다.&lt;/p&gt;

&lt;p&gt;서블릿은 JVM에 여러 객체로 생성되지 않는다. 다시 말해서 WAS가 시작하고, '사용 가능' 상태가 된 이상 대부분의 서블릿은 JVM에 살아있고, 여러 스레드에서 해당 서블릿의 service() 메서드를 호출하여 공유한다.&lt;/p&gt;

&lt;p&gt;만약 서블릿 클래스의 메서드 내에 선언한 지역변수가 아닌 멤버변수(인스턴스 변수)를 선언하여 service() 메서드에서 사용하면 어떤 일이 벌어질까?&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DontUserLikeThisServlet&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HttpServlet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serialVersionUID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;successFlag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;N&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DontUserLikeThisServlet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doGet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ServletException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;successFlag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getParameter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;successFlag&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;successFlag 값은 여러 스레드에서 접근하면서 계속 바뀔 것이다. static을 사용하는 것과 거의 동일한 결과를 나타낸다. 그러므로, service() 메서드를 구현할 때는 멤버 변수나 static한 클래스 변수를 선언하여 지속적으로 변경하는 작업은 피하기 바란다.&lt;/p&gt;

&lt;h3 id=&quot;적절한-include-사용하기&quot;&gt;적절한 include 사용하기&lt;/h3&gt;
&lt;p&gt;JSP에서 사용할 수 있는 include 방식은 정적진 방식(include directive)과 동적인 방식(include action)이 있다. 정적인 방식은 JSP의 라이플 사이클 중 JSP 페이지 번역 및 컴파일 단계에서 필요한 JSP를 읽어서 메인 JSP의 자바 소스 및 클래스에 포함을 시키는 방식이다. 이와 반대로, 동적인 방식은 페이지가 호출될 때마다 지정된 페이지를 불러들여서 수행하도록 되어 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정적인 방식: &amp;lt;%@include file=&quot;FILE_URL&quot;%&amp;gt;&lt;/li&gt;
  &lt;li&gt;동적인 방식: &amp;lt;jsp:include page=&quot;FILE_URL&quot;/&amp;gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;동적인 방식이 정직인 방식보다 느릴 수밖에 없다. 정적인 방식과 동적인 방식의 응답 속도를 비교해보면 동적인 방식이 약 30배 더 느리게 나타난다. 즉, 성능을 더 빠르게 하려면 정적인 방식을 사용해야 한다는 의미다. 하지만 모든 화면을 정적인 방식으로 구성하면 잘 수행되던 화면에서 오류가 발생할 수 있다. 정적인 방식을 사용하면 메인 JSP에 추가되는 JSP가 생긴다. 이 때 추가된 JSP와 메인 JSP에 동일한 이름의 변수가 있으면 심각한 오류가 발생할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;자바-빈즈-잘-쓰면-약-못-쓰면-독&quot;&gt;자바 빈즈, 잘 쓰면 약 못 쓰면 독&lt;/h3&gt;
&lt;p&gt;자바 빈즈(Java Beans)는 UI에서 서버 측 데이터를 담아서 처리하기 위한 컴포넌트이다. 자바 빈즈를 통하여 userBean을 하면 성능에 많은 영향을 미치지는 않지만, 너무 많이 사용하면 JSP에서 소요되는 시간이 증가될 수 있다.&lt;/p&gt;

&lt;p&gt;한 두 개의 자바 빈즈를 사용하는 것은 상관없지만, 10~20개의 자바 빈즈를 사용하면 성능에 영향을 주게 된다. 그러므로 TO(Transfer Object) 패턴을 사용하도록 하자.&lt;/p&gt;

&lt;h3 id=&quot;스프링-프레임워크-간단-정리&quot;&gt;스프링 프레임워크 간단 정리&lt;/h3&gt;
&lt;p&gt;스프링의 핵심 기술은 바로 Dependency Injection, Aspect Oriented Programming, Portable Service Abstraction으로 함축할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/06/spring-triangle.png&quot; alt=&quot;spring-triangle&quot; title=&quot;spring-triangle&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Dependency Injection(의존성 주입)은 객체 간의 의존 관계를 관리하는 기술 정도로 생각하면 된다. 객체는 보통 혼자서 모든 일을 처리하지 않고, 여러 다른 객체와 협엽하여 일을 처리한다. 이때 자신과 협업하는 객체와 자신과의 의존성을 가능한 낮춰야 유리하다. 다시 말해서, 어떤 객체가 필요로 하는 객체를 자기 자신이 직접 생성하여 사용하는 것이 아니라 외부에 있는 다른 무언가로부터 필요로 하는 객체를 주입 받는 기술이다. 스프링은 이렇게 의존성을 쉽게 주입하는 틀을 제공한다. XML이나 어노테이션 등으로 의존성을 주입하는 방법을 제공하며 생성자 주입, 세터 주입, 필드 주입 등 다양한 의존성 주입 방법을 제공하고 있다.&lt;/p&gt;

&lt;p&gt;AOP(Aspect Oriented Programming)는 우리나라 말로 '관점 지향 프로그래밍'이라고 부른다. 이 기술은 OOP를 보다 더 OOP스럽게 보완해주는 기술이다. 트랜잭션, 로깅, 보완 체크 코드 등은 대부분 비슷한 코드가 중복된다. 이런 코드를 실제 비즈니스 로직과 분리할 수 있도록 도와주는 것이 바로 AOP이다. 이 기술을 잘 활용하면 핵심 비즈니스 코드의 가독성을 높여준다.&lt;/p&gt;

&lt;p&gt;마지막으로 스프링이 제공하는 핵심 기술로 PSA를 꼽을 수 있다. 사용 중인 라이브러리나 프레임워크를 바꿔야할 때 심각한 문제가 발생할 수 있어서 추상화가 중요하다. 스프링은 그런 일이 생기지 않도록 비슷한 기술을 모두 아우를 수 있는 추상화 계층을 제공하여, 사용하는 기술이 바뀌더라도 비즈니스 로직의 변화가 없도록 도와준다.&lt;/p&gt;

&lt;h3 id=&quot;스프링-프레임워크를-사용하면서-발생할-수-있는-문제점들&quot;&gt;스프링 프레임워크를 사용하면서 발생할 수 있는 문제점들&lt;/h3&gt;
&lt;p&gt;빈 설정을 잘못해서 발생하는 문제도 있을 수 있고, 스프링의 동작 원리를 이해하지 않고서는 해결되지 않는 문제도 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;스프링 프레임워크를 사용할 때 성능 문제가 가장 많이 발생하는 부분은 '프록시(proxy)'와 관련되어 있다. 스프링 프록시는 기본적으로 실행 시에 생성된다. 따라서, 개발할 때 적은 요청에는 이상이 없다가 요청량이 많은 운영 상황으로 넘어가면 문제가 나타날 수 있다. 스프링이 프록시를 사용하게 하는 주요 기능은 바로 트랜잭션이다. \@Transactional 어노테이션을 사용하면 해당 어노테이션을 사용한 클래스의 인스턴스를 처음 만들 때 프록시 객체를 만든다. 이밖에도, 개발자가 직접 스프링 AOP를 사용해서 별도의 기능을 추가하는 경우에도 프록시를 사용하는데, 이 부분에서 문제가 가장 많이 발생한다. \@Transactional처럼 스프링이 자체적으로 제공하는 기능은 이미 상당히 오랜 시간 테스트를 거치고 많은 사용자에게 검증을 받았지만, 개발자가 직접 작성한 AOP 코드는 예상하지 못한 성능 문제를 보일 가능성이 매우 높다. 따라서, 간단한 부하 툴을 사용해서라도 성능적인 면을 테스트해야만 한다.&lt;/p&gt;

&lt;p&gt;추가로, 스프링이 내부 매커니즘에서 사용하는 캐시도 조심해서 써야 한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SampleController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/member/{id}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@PathVariable&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;redirect:/member/&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 문자열 자체를 리턴하면 스프링은 해당 문자열에 해당하는 실제 뷰 객체를 찾는 매커니즘을 사용하는데, 이 때 매번 동일한 문자열에 대한 뷰 객체를 새로 찾기 보다는 이미 찾아본 뷰 객체를 캐싱해두면 다음에도 동일한 문자열이 반환됐을 때 훨씬 빠르게 뷰 객체를 찾을 수 있다. 스프링에서 제공하는 ViewResolver 중에 자주 사용되는 InternalResourceViewResolver에는 그러한 캐싱 기능이 내장되어 있다.&lt;/p&gt;

&lt;p&gt;만약 매번 다른 문자열이 생성될 가능성이 높고, 상당히 많은 수의 키 값으로 캐시 값이 생성될 여지가 있는 상황에서는 문자열을 반환하는 게 메모리에 치명적일 수 있다. 따라서 이런 상황에서는 뷰 이름을 문자열로 반환하기보다는 뷰 객체 자체를 반환하는 방법이 메모리 릭을 방지하는 데 도움이 된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SampleController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/member/{id}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;View&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@PathVariable&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RedirectView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/member/&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;12-db를-사용하면서-발생-가능한-문제점들&quot;&gt;12. DB를 사용하면서 발생 가능한 문제점들&lt;/h1&gt;

&lt;h3 id=&quot;db-connection과-connection-pool-datasource&quot;&gt;DB Connection과 Connection Pool, DataSource&lt;/h3&gt;
&lt;p&gt;JDBC 관련 API는 클래스가 아니라 인터페이스다. JDK의 API에 있는 java.sql 인터페이스를 각 DB 벤더에서 상황에 맞게 구현하도록 되어 있다. 같은 인터페이스라고 해도, 각 DB 벤더에 따라서 처리되는 속도나 내부 처리 방식은 상이하다.&lt;/p&gt;

&lt;p&gt;Connection 객체를 생성하는 부분에서 발생하는 대기 시간을 줄이고, 네트워크의 부담을 줄이기 위해서 사용하는 것이 DB Connection Pool이다.&lt;/p&gt;

&lt;p&gt;Statement와 PreparedStatement의 가장 큰 차이점은 캐시(cache) 사용 여부이다. Statement를 사용할 때와 PreparedStatement를 처음 사용할 때는 다음과 같은 프로세스를 거친다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;쿼리 문장 분석&lt;/li&gt;
  &lt;li&gt;컴파일&lt;/li&gt;
  &lt;li&gt;실행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Statement를 사용하면 매번 쿼리를 수행할 때마다 1~3 단계를 거치고, PreparedStatement는 처음 한 번만 세 단계를 거친 후 캐시에 담아서 재사용한다. 동일한 쿼리를 반복적으로 수행한다면 PreparedStatement가 DB에 훨씬 적은 부하를 주며, 성능도 좋다.&lt;/p&gt;

&lt;h3 id=&quot;db를-사용할-때-닫아야-하는-것들&quot;&gt;DB를 사용할 때 닫아야 하는 것들&lt;/h3&gt;
&lt;p&gt;ResultSet 객체가 닫히는 경우는 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;close() 메서드를 호출하는 경우&lt;/li&gt;
  &lt;li&gt;GC의 대상이 되어 GC되는 경우&lt;/li&gt;
  &lt;li&gt;관련된 Statement 객체의 close() 메서드가 호출되는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GC가 되면 자동으로 닫히고, Statement 객체가 close되면 알아서 닫히지만, 0.00001초라도 빨리 닫으면 그만큼 해당 DB 서버의 부담이 적어지게 된다.&lt;/p&gt;

&lt;p&gt;Conenction 객체는 다음 세 가지 경우에 닫히게 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;close() 메서드를 호출하는 경우&lt;/li&gt;
  &lt;li&gt;GC의 대상이 되어 GC되는 경우&lt;/li&gt;
  &lt;li&gt;치명적인 에러가 발생하는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;PreparedStatement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ResultSet&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conne&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;jdk-7에서-등장한-autoclosable-인터페이스&quot;&gt;JDK 7에서 등장한 AutoClosable 인터페이스&lt;/h3&gt;
&lt;p&gt;try 블록이 시작될 때 소괄호 안에 close() 메서드를 호출하는 객체를 생성해 주면 간단하게 처리할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;readFileNew&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fileName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;FileReader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FIle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fileName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;br&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;별도로 finally 블록에서 close() 메서드를 호출할 필요가 없어졌다. 만약 close() 메서드 호출 대상이 여러 개라면 세미콜론으로 구분하여 try-with-resources 구문에 두 개 이상의 문장을 추가하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;jdbc를-사용하면서-유의할-만한-몇-가지-팁&quot;&gt;JDBC를 사용하면서 유의할 만한 몇 가지 팁&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;setAutoCommit() 메서드는 필요할 때만 사용하자. 여러 개의 쿼리를 동시에 작업할 때 성능에 영향을 주게 되므로 되도록 자제하자.&lt;/li&gt;
  &lt;li&gt;배치성 작업은 executeBatch() 메서드를 사용하자. 여러 개의 쿼리를 한 번에 수행할 수 있기 때문에 JDBC 호출 횟수가 감소되어 성능이 좋아진다.&lt;/li&gt;
  &lt;li&gt;setFetchSize() 메서드를 사용하여 데이터를 더 빠르게 가져오자.&lt;/li&gt;
  &lt;li&gt;한 건만 필요할 때는 한 건만 가져오자.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;13-xml과-json도-잘-쓰자&quot;&gt;13. XML과 JSON도 잘 쓰자&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;데이터 개수&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;XML SAX&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;XML DOM&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;JSON&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;100&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;847&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1,395&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;245&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1,000&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3,925&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7,129&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1,379&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 결과만 보면 XML 파싱이 JSON 보다 매우 느리다고 생각할 수 있다. 그런데, 데이터를 전송하기 위해서 XML 및 JSON 데이터를 Serialize나 Deserialize 할 경우도 있다. JSON 데이터는 Serialize와 Deserialize를 처리하는 성능이 좋지 않다. XML 파서보다 JSON 파서가 더 느린 경우가 대부분이다.&lt;/p&gt;

&lt;p&gt;JSON이나 XML은 데이터가 커질수록 전송해야 하는 양도 증가하고, 파싱하는 성능도 무시할 수 없다. 그래서 protobuf, Thrift, avro 등의 오픈소스가 많이 사용되고 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;14-서버를-어떻게-세팅해야-할까&quot;&gt;14. 서버를 어떻게 세팅해야 할까?&lt;/h1&gt;

&lt;h3 id=&quot;웹-서버의-keep-alive&quot;&gt;웹 서버의 Keep Alive&lt;/h3&gt;
&lt;p&gt;웹 서버와 웹 브라우저가 연결 되었을때 KeepAlive 기능이 켜져 있지 않으면, 매번 HTTP 연결을 맺었다 끊었다 하는 작업을 반복한다. KeepAlive 기능이 켜져 있으면 두 개 정도의 연결을 열어서 끊지 않고, 연결을 계속 재사용할 수 있다. KeepAlive 설정을 할 때는 반드시 KeepAlive-Timeout 설정도 같이 해야 한다. 이 설정은 초 단위로 KeepAlive가 끊기는 시간을 설정하기 위한 부분이다. 마지막 연결이 끝난 이후에 다음 연결이 될 때까지 얼마나 기다릴지를 지정한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;KeepAliveTimeout&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;사용자가 너무 많아 접속이 잘 안될 경우, 이 설정을 5초 정도로 짧게 주는 것도 서버의 리소스를 보다 효율적으로 사용할 수 있는 방법이다.&lt;/p&gt;

&lt;h3 id=&quot;db-connection-pool-및-스레드-개수-설정&quot;&gt;DB Connection Pool 및 스레드 개수 설정&lt;/h3&gt;
&lt;p&gt;DB Connection Pool은 보통 40~50개로 지정하며, 스레드 개수는 이보다 10개 정도 더 지정한다. 가장 좋은 방법은 성능 테스트를 통해서 가장 적절한 값을 구하는 것이다.&lt;/p&gt;

&lt;p&gt;DB의 CPU 사용량이 100%에 도달했다면 CPU를 점유하는 쿼리를 찾아서 튜닝해야 한다. 인덱스가 없거나 테이블을 풀 스캔하는 쿼리가 있는건 아닌지 쿼리의 플랜을 떠서 확인해 봐야 한다.&lt;/p&gt;

&lt;p&gt;DB의 CPU 사용량이 50%도 되지 않는 상황에서 WAS의 CPU 사용량이 100%에 도달했다면 WAS의 애플리케이션을 튜닝해야 한다. 이미 튜닝된 상태라면 서버의 DB Connection Pool의 개수는 약간 여유를 두기 위해서 25~30개 정도로 지정하는 것이 좋다(서버를 늘리는 것은 가장 마지막에 해야 한다).&lt;/p&gt;

&lt;p&gt;Connection Pool의 개수만큼 중요한 값이 대기 시간(wait time)과 관련된 값이다. DB Connection Pool의 개수를 넘어 섰을 때 애플리케이션에서는 '어디 남는 Connection 없나?' 하고 두리번거리면서 기다린다. 대기 시간이 20초라면 DB 연결을 못해 기다리는 사용자들이 적어도 20초는 대기해야 한다는 말이다.&lt;/p&gt;

&lt;p&gt;대기 시간을 100ms 정도로 줄 경우에는 문제가 없을까? 필자가 경험한바로는 메모리를 1GB로 할당한 WAS에서 300ms 이하의 Full GC 시간을 만들기는 매우 어렵다. 만약 DB 연결을 하려고 대기하는 순간 Full GC가 발생하면 그 순간에 대기하고 있는 모든 스레드는 DB와 연결을 못했다고 Timeout을 내뿜을 수도 있다.&lt;/p&gt;

&lt;h3 id=&quot;was-인스턴스-개수-설정&quot;&gt;WAS 인스턴스 개수 설정&lt;/h3&gt;
&lt;p&gt;예를 들어 CPU core 개수가 모두 36개인 장비가 있다. 인스턴스가 1개 일때 500 TPS가 나오고, 인스턴스가 2개 일때 700 TPS, 인스턴스가 3개 일때 720 TPS, 4개 일때 730 TPS가 나온다고 가정하다. 필자라면 이 상황에서 인스턴스를 2~3개 정도만 띄울 것이다. 인스턴스를 더 늘린다고 해서 TPS가 증가하지 않는 상황에서는 오히려 유지보수성만 떨어지기 때문이다.&lt;/p&gt;

&lt;p&gt;만약 WAS 장비에 4GB의 여유 메모리가 있다고 하더라도 하나의 인스턴스에 4GB의 메모리를 지정하여 사용하는 것은 굉장히 좋지 않은 방법이다. 왜냐하면 Full GC가 발생할 때마다 많은 시간이 소요될 확률이 커지기 때문이다. 가급적이면 512MB~2GB 사이에서 메모리를 지정하는 것이 좋다. 예를 들어 1GB로 메모리를 지정하여 2개의 인스턴스를 사용하는 것이 좋은 방법일 것이다.&lt;/p&gt;

&lt;h3 id=&quot;session-timeout-시간-설정&quot;&gt;Session Timeout 시간 설정&lt;/h3&gt;
&lt;p&gt;WAS에서 따로 설정한 바가 없거나 세션 객체의 invalidate() 메서드가 수행되지 않으면 세션은 삭제되지 않으므로 유의하자.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;15-안드로이드-개발하면서-이것만은-피하자&quot;&gt;15. 안드로이드 개발하면서 이것만은 피하자&lt;/h1&gt;

&lt;h3 id=&quot;일반적인-서버-프로그램-개발과-안드로이드-개발은-다르다&quot;&gt;일반적인 서버 프로그램 개발과 안드로이드 개발은 다르다&lt;/h3&gt;
&lt;p&gt;안드로이드는 오라클이나 IBM에서 만든 JVM을 사용하지 않고, Dalvik VM이라는 것을 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/06/javacode.png&quot; alt=&quot;java-code&quot; title=&quot;java-code&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;첫번째 컴파일은 javac를 통해서 수행되며, 두번째 컴파일은 dex라는 구글에서 제공하는 컴파일러에서 수행한다. 자바와 문법은 같지만 컴파일러와 가상 머신(VM)은 다르다.&lt;/p&gt;

&lt;p&gt;윈도우, 맥, 리눅스 장비는 물리적인 RAM이 부족할 경우 디스크를 메모리처럼 사용하는 SWAP이 발생하지만, 안드로이드의 경우 이러한 SWAP이 존재핮 ㅣ않는다.&lt;/p&gt;

&lt;h3 id=&quot;구글에서-이야기하는-안드로이드-성능-개선&quot;&gt;구글에서 이야기하는 안드로이드 성능 개선&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Avoid Creating Unnecessary Objects&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Prefer Static Over Virtual&lt;/strong&gt;: 만약 인스턴스 변수에 접근할 일이 없을 경우엔 static 메서드를 선언하여 호출하는 것은 15~20%의 성능 개선이 발생할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Use Static Final For Constants&lt;/strong&gt;: 변하지 않는 상수를 선언할 때 static final로 선언할 경우와 static으로 선언할 때 저장되고 참조되는 위치가 달라진다. static final이 접근 속도가 훨씬 빠르다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Avoid Internal Getters/Setters&lt;/strong&gt;: 인스턴스 변수에 직접 접근하는 것이 getter나 setter 메서드를 사용하여 접근하는 것보다 빠르다. JIT 컴파일러가 적용되지 않을 경우 3배, 적용될 경우 7배 정도 빠르다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Use Enhanced For Loop Syntax&lt;/strong&gt;: Iterable 인터페이스를 사용하는 대부분의 Collection에서 제공하는 클래스들은 전통적인 for 루프를 사용하는 것보다 for-each 루프를 사용하는 방법이 더 성능상 유리하다. 하지만 ArrayList는 전통적인 for 루프가 3배 빠르다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Consider Package Instead of Private Access with Private Inner Classes&lt;/strong&gt;: 자바에서 Inner 클래스는 감싸고 있는 클래스의 private 변수를 접근할 수 있다. 그런데 VM에서는 내부 클래스와 감싸고 있는 클래스는 다른 클래스로 인식한다. 그래서 컴파일러는 감싸고 있는 클래스의 private 변수에 접근할 수 있는 메서드를 자동으로 생성해 준다. 따라서 변수에 직접 접근이 불가하므로 getter나 setter를 사용하는 것처럼 성능이 저하된다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Avoid Using Floating-Point&lt;/strong&gt;: 안드로이드 기기에서는 정수 연산보다 소수점 연산이 2배 느리다. 그리고 double이 float보다 2배의 저장 공간을 사용하므로, 가능하다면 float을 사용하는 것을 권장한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Know and User the Libraries&lt;/strong&gt;: 직접 만드는 것보다 API에서 제공하는 클래스와 메서드가 훨씬 더 빠를 수 있다. 예를 들어 배열을 복사할 때 System.arraycopy() 메서드를 사용하면 루프를 사용하는 것보다 9배 이상 빠르다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Use Native Methods Carefully&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;안드로이드에서는-이미지-처리만-잘해도-성능이-좋아진다&quot;&gt;안드로이드에서는 이미지 처리만 잘해도 성능이 좋아진다&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;이미지 크기가 얼마나 되나 확인해보자.&lt;/li&gt;
  &lt;li&gt;ImageView의 setImageResource() 메서드 사용을 자제하자. 이 메서드를 사용하면 Bitmap 이미지를 읽고 디코딩하는 작업을 UI 스레드에서 수행하기 때문에 응답 시간이 저하된다. 따라서 setImageDrawable이나 setImageBitmap 메서드를 사용하고, BitmapFactory 사용을 권장하고 있다. 추가로 ImageView를 사용하는 것보다 WebView를 사용할 경우에도 큰 효과를 볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;references&quot;&gt;References&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.yes24.com/Product/Goods/11261731&quot;&gt;개발자가 반드시 알아야 할 자바 성능 튜닝 이야기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://sridharu.wordpress.com/2016/01/31/servlet-life-cycle/&quot;&gt;Servlet Life Cycle&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://android.jlelse.eu/closer-look-at-android-runtime-dvm-vs-art-1dc5240c3924&quot;&gt;Closer Look At Android Runtime: DVM vs ART&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
      </entry>
      
  
      
      <entry>
        <id>https://sungjk.github.io/2019/04/04/game-of-life.html</id>
        <link type="text/html" rel="alternate" href="https://sungjk.github.io/2019/04/04/game-of-life.html"/>
        <title>Scala로 라이프 게임(Game of Life) 풀어보기</title>
        <updated>2019-04-04T00:00:00+00:00</updated>
        <author>
          <name>김성중</name>
          <email>ajax0615@gmail.com</email>
        </author>
        <content type="html">&lt;p&gt;라이프 게임(Game of Life)는 영국의 수학자 존 호턴 콘웨이(John Conway)가 고안해낸 세포 자동자의 일종입니다. 라이프 게임은 컴퓨터 과학에서도 의미가 있는데, 왜냐하면 라이프 게임이 범용 튜링 기계와 동등한 계산능력을 가진 세포 자동자이기 때문이다. 즉, 어떤 알고리즘에 의해 계산될 수 있는 것이라면 모두 이를 이용하여 계산할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/04/game_of_life.gif&quot; alt=&quot;game_of_life&quot; title=&quot;game_of_life&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/E8kUJL04ELA&quot;&gt;콘웨이가 직접 설명해주는 영상&lt;/a&gt;을 봐도 도움이 많이 될 것이다.&lt;/p&gt;

&lt;h1 id=&quot;규칙&quot;&gt;규칙&lt;/h1&gt;
&lt;p&gt;라이프 게임은 몇 가지 규칙(패턴)에 의해 진행되기 때문에 입력된 초기값이 게임의 모든 진행을 좌우하게 된다. 세포가 진화하는 과정처럼 다음 단계를 하나의 세대로 표현한다. 그리고 다음 세대로 넘어갈 때 세포들의 생사(生死)는 인접한 8개의 세포들을 기준으로 아래의 규칙을 통해 결정된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;살아 있는 세포에 살아 있는 이웃이 2개 미만이면 인구 부족(underpopulation)으로 죽는다.&lt;/li&gt;
  &lt;li&gt;살아 있는 세포에 살아 있는 이웃이 2개나 3개이면 다음 세대에도 살아있는다.&lt;/li&gt;
  &lt;li&gt;살아 있는 세포에 살아 있는 이웃이 3개 초과이면 인구 과잉(overpopulation)으로 죽는다.&lt;/li&gt;
  &lt;li&gt;죽어 있는 세포에 살아 있는 이웃이 정확히 3개이면 번식(reproduction)으로 다음 세대에 살아난다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;그려보기&quot;&gt;그려보기&lt;/h1&gt;
&lt;p&gt;초기에 살아있는 세포가 세로 일자(ㅣ) 모양을 하고 있다고 가정하고 그려보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/04/game_of_life_draw_2.jpeg&quot; alt=&quot;game_of_life_draw_2&quot; title=&quot;game_of_life_draw_2&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;연하게 색칠한 부분이 현재 살아있는 세포를 표현한 것이고, 숫자는 살아있는 세포의 갯수를 표시한 것이다. 그리고 다음 세대에 죽을지 살지 여부는 현재 살아있는지의 여부(색칠되어 있는지)와 살아있는 이웃 세포의 수(숫자)를 가지고 판단한다.&lt;/p&gt;

&lt;p&gt;도입부에서도 설명하였듯이 라이프 게임에서는 입력된 초기값이 게임의 모든 진행을 좌우하게 되는데, 일자 모양으로 주어졌을때 다음 세대에는 가로 일자(ㅡ) 모양을 하게 되고 그 다음 세대에는 세로 일자(ㅣ) 모양이 된다. 계속 이 패턴을 반복한다.&lt;/p&gt;

&lt;p&gt;그럼 이번에는 초기에 살아있는 세포가 십자(十) 모양을 하고 있다고 가정하고 그려보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/04/04/game_of_life_draw.jpeg&quot; alt=&quot;game_of_life_draw&quot; title=&quot;game_of_life_draw&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;8번째 세대에서는 어떤 모양을 하고 있을까 생각해보면, 처음에 그려봤던 세로 일자(ㅣ) 모양을 생각해보면 쉽다. 세로 일자(ㅣ) 모양은 가로 일자(ㅡ) 모양으로 바뀔 것이고, 가로일자 모양은 세로일자 모양으로 바뀔 것이다. 정리하자면 6, 7번째에서 나왔던 패턴이 세대를 거듭할 수록 반복된다.&lt;/p&gt;

&lt;h1 id=&quot;구현해보기&quot;&gt;구현해보기&lt;/h1&gt;
&lt;p&gt;위에서 본 규칙은 4가지가 복잡해 보일 수 있는데 그리 복잡하지 않다. 현재 세포가 살아있으면서(AND) 주위에 살아있는 이웃의 갯수가 2개이면 되고 또는(OR) 죽어있던 살아있던 상관없이 주위에 살아있는 이웃의 갯수가 3개이면 다음 세대에 살아난다. 그럼 이 규칙을 바탕으로 코드를 작성해보자.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GameOfLife&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 현재 살아있는 세포들을 기준으로 인접한 모든 세포들을 구하는 함수&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;candidates&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;cells:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cells&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 현재 살아있는 세포들을 기준으로 인접한 이웃들 중 살아있는 세포들을 구하는 함수&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alives&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;cells:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;candidate:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cells&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;candidate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;math&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;abs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;candidate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;math&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;abs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;candidate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 현재 살아있는 세포를 기준으로 다음 세대에 살아있는 세포를 구하는 함수&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;evolve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;cells:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;candidates&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cells&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;candidate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alivesCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alives&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cells&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;candidate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cells&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contains&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;candidate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alivesCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alivesCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life&quot;&gt;Conway’s Game of Life&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
      </entry>
      
  
      
      <entry>
        <id>https://sungjk.github.io/2019/03/30/java-performance-tuning-2.html</id>
        <link type="text/html" rel="alternate" href="https://sungjk.github.io/2019/03/30/java-performance-tuning-2.html"/>
        <title>자바 성능 튜닝 이야기 - 2</title>
        <updated>2019-03-30T00:00:00+00:00</updated>
        <author>
          <name>김성중</name>
          <email>ajax0615@gmail.com</email>
        </author>
        <content type="html">&lt;p&gt;&lt;img src=&quot;/images/2019/03/28/java_performance_tuning.jpeg&quot; alt=&quot;java_performance_tuning&quot; title=&quot;java_performance_tuning&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;6-static-제대로-한번-써-보자&quot;&gt;6. static 제대로 한번 써 보자&lt;/h1&gt;
&lt;p&gt;100개의 클래스의 인스턴스를 생성하더라도, static으로 선언된 변수나 메서드들은 동일한 주소의 값을 참조한다.&lt;/p&gt;

&lt;p&gt;static의 특징은 다른 JVM에서는 static으로 선언해도 다른 주소나 다른 값을 참조하지만, 하나의 JVM이나 WAS 인스턴스에서는 같은 주소에 존재하는 값을 참조한다. 그리고 GC의 대상도 되지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;static-잘-활용하기&quot;&gt;static 잘 활용하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;자주 사용하고 절대 변하지 않는 변수는 final static으로 선언하자.&lt;/li&gt;
  &lt;li&gt;설정 파일 정보도 static으로 관리하자.&lt;/li&gt;
  &lt;li&gt;코드성 데이터는 DB에서 한 번만 읽자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;static과-메모리-릭&quot;&gt;static과 메모리 릭&lt;/h3&gt;
&lt;p&gt;static으로 선언한 부분은 GC가 되지 않는다. 만약 어떤 클래스에 데이터를 Vector나 ArrayList에 담을 때 해당 Collection 객체를 static으로 선언하면 어떻게 될까? 지속적으로 해당 객체에 데이터가 쌓인다면, 더 이상 GC가 되지 않으면서 시스템은 OutOfMemoryError를 발생시킨다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;7-클래스-정보-어떻게-알아낼-수-있나&quot;&gt;7. 클래스 정보, 어떻게 알아낼 수 있나?&lt;/h1&gt;
&lt;p&gt;자바 API 중 reflection 패키지에 있는 클래스들을 사용하면 JVM에 로딩되어 있는 클래스와 메서드 정보들을 읽어 올 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;class-클래스&quot;&gt;Class 클래스&lt;/h3&gt;
&lt;p&gt;Class 클래스는 클래스에 대한 정보를 얻을 때 사용하기 좋고, 생성자는 따로 없다. ClassLoader 클래스의 defineClass() 메서드를 이용해서 클래스 객체를 만들 수도 있지만, 좋은 방법은 아니다. 그보다는 Object 클래스에 있는 getClass() 메서드를 이용하는 것이 일반적이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;String getName(): 클래스의 이름을 리턴한다.&lt;/li&gt;
  &lt;li&gt;Package getPackage(): 클래스의 패키지 정보를 패키지 클래스 타입으로 리턴한다.&lt;/li&gt;
  &lt;li&gt;Field[] getFields(): public으로 선언된 변수 목록을 Field 클래스 배열 타입으로 리턴한다.&lt;/li&gt;
  &lt;li&gt;Field getField(String name): public으로 선언된 변수를 Field 클래스 타입으로 리턴한다.&lt;/li&gt;
  &lt;li&gt;Field[] getDeclaredFields(): 해당 클래스에서 정의된 변수 목록을 Field 클래스 배열 타입으로 리턴한다.&lt;/li&gt;
  &lt;li&gt;Field getDeclaredField(String name): 해당 클래스에서 정의된 변수 목록을 Field 클래스 배열 타입으로 리턴한다.&lt;/li&gt;
  &lt;li&gt;Method[] getDeclaredField(String name): name과 동일한 이름으로 정의된 변수를 Field 클래스 타입으로 리턴한다.&lt;/li&gt;
  &lt;li&gt;Method[] getMethods(): public으로 선언된 모든 메서드 목록을 Method 클래스 배열 타입으로 리턴한다. 해당 클래스에서 사용 가능한 상속받은 메서드도 포함된다.&lt;/li&gt;
  &lt;li&gt;Method getMethod(String name, Class… parameterTypes): 지정된 이름과 매개변수 타입을 갖는 메서드를 Method 클래스 타입으로 리턴한다.&lt;/li&gt;
  &lt;li&gt;Method[] getDeclaredMethods(): 해당 클래스에서 선언된 모든 메서드 정보를 리턴한다.&lt;/li&gt;
  &lt;li&gt;Method getDeclaredMethod(String name, Class… parameterTypes): 지정된 이름과 매개변수 타입을 갖는 해당 클래스에서 선언된 메서드를 Method 클래스 타입으로 리턴한다.&lt;/li&gt;
  &lt;li&gt;Constructor[] getConstructors(): 해당 클래스에 선언된 모든 public 생성자의 정보를 Constructor 배열 타입으로 리턴한다.&lt;/li&gt;
  &lt;li&gt;Constructor[] getDeclaredConstructors(): 해당 클래스에서 선언된 모든 생성자의 정보를 Constructor 배열 타입으로 리턴한다.&lt;/li&gt;
  &lt;li&gt;int getModifiers(): 해당 클래스의 접근자(modifier) 정보를 int 타입으로 리턴한다.&lt;/li&gt;
  &lt;li&gt;String toString(): 해당 클래스 객체를 문자열로 리턴한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;현재 클래스의 이름을 알고 싶으면 다음과 같이 사용하면 된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentClassName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 getName() 메서드는 패키지 정보까지 리턴해 준다. 클래스 이름만 필요한 경우에는 getSimpleName() 메서드를 사용하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;method-클래스&quot;&gt;Method 클래스&lt;/h3&gt;
&lt;p&gt;Method 클래스를 이용하여 메서드에 대한 정보를 얻을 수 있다. 하지만 Method 클래스에는 생성자가 없으므로 Class 클래스의 getMethods() 메서드를 사용하거나 getDeclaredMethods() 메서드를 써야 한다.&lt;/p&gt;

&lt;h3 id=&quot;field-클래스&quot;&gt;Field 클래스&lt;/h3&gt;
&lt;p&gt;Field 클래스는 클래스에 있는 변수들의 정보를 제공하기 위해서 사용한다. Method 클래스와 마찬가지로 생성자가 없으므로 Class 클래스의 getFields()나 getDeclaredFields() 메서드를 써야 한다.&lt;/p&gt;

&lt;h3 id=&quot;reflection-클래스를-잘못-사용한-사례&quot;&gt;reflection 클래스를 잘못 사용한 사례&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;checkClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;java.math.BigDecimal&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 데이터 처리&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 사용할 경우 응답 속도에 그리 많은 영향을 주지는 않지만, 많이 사용하면 필요 없는 시간을 낭비하게 된다. 기본으로 돌아가서 다음과 같이 사용하면 좋다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;checkClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;math&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;BigDecimal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 데이터 처리&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;대상&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;응답 시간(마이크로초)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;instanceof 사용&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.167&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Reflection 사용&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1.022&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;instanceof를 사용했을 때와 .getClass().getName()을 사용했을 때를 비교하면 약 6배의 성능 차이가 발생한다. 어떻게 보면 시간으로 보았을 때 큰 차이는 발생하지 않지만, 작은 것부터 생각하면서 코딩하는 습관을 가지는 것이 좋다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;8-synchronized는-제대로-알고-써야-한다&quot;&gt;8. synchronized는 제대로 알고 써야 한다&lt;/h1&gt;
&lt;h3 id=&quot;프로세스와-스레드&quot;&gt;프로세스와 스레드&lt;/h3&gt;
&lt;p&gt;클래스를 하나 수행시키거나 WAS를 기동하면, 서버에서 자바 프로세스가 하나 생성된다. 하나의 프로세스에는 여러 개의 스레드가 생성된다. 단일 스레드가 생성되어 종료될 수도 있고, 여러 개의 스레드가 생성되어 수행될 수도 있다. 그러므로 프로세스와 스레드의 관계는 1:N 관계라고 보면 된다.&lt;/p&gt;

&lt;h3 id=&quot;thread-클래스-상속과-runnable-인터페이스-구현&quot;&gt;Thread 클래스 상속과 Runnable 인터페이스 구현&lt;/h3&gt;
&lt;p&gt;스레드의 구현은 Thread 클래스를 상속받는 방법과 Runnable 인터페이스를 구현하는 방법 두 가지가 있다. 기본적으로 Thread 클래스는 Runnable 인터페이스를 구현한 것이기 때문에 어느 것을 사용해도 거의 차이가 없다. 대신 Runnable 인터페이스를 구현하면 원하는 기능을 추가할 수 있다. 이는 장점이 될 수도 있지만, 해당 클래스를 수행할 때 별도의 스레드 객체를 생성해야 한다는 단점이 될 수도 있다. 또한 자바는 다중 상속을 인정하지 않는다. 따라서 스레드를 사용해야 할 때 이미 상속받은 클래스가 존재한다면 Runnable 인터페이스를 구현해야 한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RunnableImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;This is RunnableImpl.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadExtends&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;This is ThreadExtends.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그럼 이 클래스들을 어떻게 실행해야 할까? Thread 클래스를 상속받은 경우에는 start() 메서드를 호출하면 된다. 하지만 Runnable 인터페이스를 매개변수로 받는 생성자를 사용해서 Thread 클래스를 만든 후 start() 메서드를 호출해야 한다. 그렇게 하지 않고 그냥 run() 메서드를 호출하면 새로운 스레드가 생성되지 않는다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RunThreads&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;RunnableImpl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ri&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RunnableImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ThreadExtends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;te&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadExtends&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ri&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;te&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;sleep-wait-join-메서드&quot;&gt;sleep(), wait(), join() 메서드&lt;/h3&gt;
&lt;p&gt;sleep() 메서드는 명시된 시간만큼 해당 스레드를 대기시킨다. wait() 메서드도 명시된 시간만큼 해당 스레드를 대기시킨다. sleep() 메서드와 다른 점은 매개변수인데, 만약 아무런 매개변수를 지정하지 않으면 notify() 메서드 혹은 notifyAll() 메서드가 호출될 때까지 대기한다. wait() 메서드가 대기하는 시간을 설정하는 방법은 sleep() 메서드와 동일하다.&lt;/p&gt;

&lt;p&gt;join() 메서드는 명시된 시간만큼 해당 스레드가 죽기를 기다린다. 만약 아무런 매개변수를 지정하지 않으면 죽을 때까지 계속 대기한다.&lt;/p&gt;

&lt;h3 id=&quot;interrupt-notify-notifyall-메서드&quot;&gt;interrupt(), notify(), notifyAll() 메서드&lt;/h3&gt;
&lt;p&gt;앞서 명시한 세 개의 메서드를 ‘모두’ 멈출 수 있는 유일한 메서드는 interrupt 메서드다. interrupt() 메서드가 호출되면 중지된 스레드에는 InterruptedException이 발생한다. notify() 메서드와 notifyAll() 메서드는 모두 wait() 메서드를 멈추기 위한 메서드다. 이 두 메서드는 Object 클래스에 정의되어 있는데, wait() 메서드가 호출된 후 대기 상태로 바뀐 스레드를 깨운다. notify() 메서드는 객체의 모니터와 관련있는 단일 스레드를 깨우며, notifyAll() 메서드는 객체의 모니터와 관련있는 모든 스레드를 깨운다.&lt;/p&gt;

&lt;h3 id=&quot;synchronized를-이해하자&quot;&gt;Synchronized를 이해하자&lt;/h3&gt;
&lt;p&gt;메서드를 동기화하려면 메서드 선언부에 사용하면 된다. 특정 부분을 동기화하려면 해당 블록에만 선언을 해서 사용하면 된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 다음과 같은 상황에 동기화를 사용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하나의 객체를 여러 스레드에서 동시에 사용할 경우&lt;/li&gt;
  &lt;li&gt;static으로 선언한 객체를 여러 스레드에서 동시에 사용할 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;동기화를-위해서-자바에서-제공하는-것들&quot;&gt;동기화를 위해서 자바에서 제공하는 것들&lt;/h3&gt;
&lt;p&gt;JDK 5.0부터 추가된 java.util.concurrent 패키지에 대해서 간단히 알아보자. 이 패키지에는 주요 개념 네 가지가 포함되어 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Lock: 실행 중인 메서드를 간단한 방법으로 정지시켰다가 실행시킨다. 상호 참조로 인해 발생하는 데드락을 피할 수 있다.&lt;/li&gt;
  &lt;li&gt;Executors: 스레드를 더 효율적으로 관리할 수 있는 클래스들을 제공한다. 스레드 풀도 제공하므로, 필요에 따라 유용하게 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;Concurrent 컬랙션&lt;/li&gt;
  &lt;li&gt;Atomic 변수: 동기화가 되어 있는 변수를 제공한다. 이 변수를 사용하면, synchronized 식별자를 메서드에 지정할 필요 없이 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jvm-내에서는-synchronized은-어떻게-동작할까&quot;&gt;JVM 내에서는 synchronized은 어떻게 동작할까?&lt;/h3&gt;
&lt;p&gt;자바의 HotSpot VM은 '자바 모니터(monitor)'를 제공함으로써 스레드들이 '상호 배제 프로토콜(mutual exclusion protocol)'에 참여할 수 있도록 돕는다. 자바 모니터는 잠긴 상태(lock)나 풀림(unlocked) 중 하나이며, 동일한 모니터에 진입한 여러 스레드들 중에서 한 시점에는 단 하나의 스레드만 모니터를 가질 수 있다. 즉, 모니터를 가진 스레드만 모니터에 의해서 보호되는 영역(synchronized 블록)에 들어가서 작업을 할 수 있다. 모니터를 보유한 스레드가 보호 영역에서의 작업을 마치면, 모니터는 다른 대기중인 스레드에게 넘어간다.&lt;/p&gt;

&lt;p&gt;JDK 5부터는 &lt;code class=&quot;highlighter-rouge&quot;&gt;-XX:+UseBiasedLocking&lt;/code&gt;라는 옵션을 통해서 biased locking 이라는 기능을 제공한다. 그 전까지는 대부분의 객체들이 하나의 스레드에 의해서 잠기게 되었지만, 이 옵션을 켜면 스레드가 자기 자신을 향하여 bias된다. 즉, 이 상태가 되면 스레드는 많은 비용이 드는 인스트럭션 재배열 작업을 통해서 잠김과 풀림 작업을 수행할 수 있게 된다. 이 작업들은 진보된 적응 스피닝(adaptive spinning) 기술을 사용하여 처리량을 개선시킬 수 있다고 한다. 결과적으로 동기화 성능은 보다 빨라졌다.&lt;/p&gt;

&lt;p&gt;HotSpot VM에서 대부분의 동기화 작업은 fast-path 코드 작업을 통해서 진행한다. 만약 여러 스레드가 경합을 일으키는 상황이 발생하면 이 fast-path 코드는 slow-path 코드 상태로 변환된다. 참고로 slow-path 구현은 C++ 코드로 되어 있으며, fast-path 코드는 JIT compiler에서 제공하는 장비에 의존적인 코드로 작성되어 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;9-io에서-발생하는-병목-현상&quot;&gt;9. IO에서 발생하는 병목 현상&lt;/h1&gt;
&lt;p&gt;웹 애플리케이션에서 IO 처리를 하는 부분은 시스템의 응답 속도에 많은 영향을 준다.&lt;/p&gt;

&lt;h3 id=&quot;기본적인-io는-이렇게-처리한다&quot;&gt;기본적인 IO는 이렇게 처리한다&lt;/h3&gt;
&lt;p&gt;자바에서 입력과 출력은 스트림(stream)을 통해서 이루어진다. 파일을 포함해 디바이스를 통해 이뤄지는 작업을 모두 IO라고 한다. 네트워크를 통해서 다른 서버로 데이터를 전송하거나, 다른 서버로부터 데이터를 전송 받는 것도 IO에 포함된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Jeremy&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 out은 PrintStream을 System 클래스에 static으로 정의해 놓은 변수이다(이 또한 역시 IO). IO에서 발생하는 시간은 CPU를 사용하는 시간과 대기 시간 중 대기 시간에 속하기 때문에 성능에 영향을 가장 많이 미친다.&lt;/p&gt;

&lt;p&gt;자바에서 파일을 읽고 처리하는 방법은 굉장히 많다. 스트림을 읽는 데 관련된 주요 클래스는 다음과 같다. 여기에 명시된 모든 입력과 관련된 스트림들은 java.io.InputStream 클래스로부터 상속받았다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ByteArrayInputStream: 바이트로 구성된 배열을 읽어서 입력 스트림을 만든다.&lt;/li&gt;
  &lt;li&gt;FileInputStream: 이미지와 같은 바이너리 기반의 파일의 스트림을 만든다.&lt;/li&gt;
  &lt;li&gt;FilterInputStream: 여러 종류의 유용한 입력 스트림의 추상 클래스이다.&lt;/li&gt;
  &lt;li&gt;ObjectInputStream: ObjectOutputStream을 통해서 저장해 놓은 객체를 읽기 위한 스트림을 만든다.&lt;/li&gt;
  &lt;li&gt;PipedInputStream: PipedOutputStream을 통해서 출력된 스트림을 읽어서 처리하기 위한 스트림을 만든다.&lt;/li&gt;
  &lt;li&gt;SequenceInputStream: 별개인 두 개의 스트림을 하나의 스트림으로 만든다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문자열 기반의 스트림을 읽기 위해서 사용하는 클래스는 java.io.Reader 클래스의 하위 클래스들이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;BufferedReader: 문자열 입력 스트림을 버퍼에 담아서 처리한다. 일반적으로 문자열 기반의 파일을 읽을 때 가장 많이 사용된다.&lt;/li&gt;
  &lt;li&gt;CharArrayReader: char의 배열로 된 문자 배열을 처리한다.&lt;/li&gt;
  &lt;li&gt;FilterReader: 문자열 기반의 스트림을 처리하기 위한 추상 클래스이다.&lt;/li&gt;
  &lt;li&gt;FileReader: 문자열 기반의 파일을 읽기 위한 클래스이다.&lt;/li&gt;
  &lt;li&gt;InputStreamReader: 바이트 기반의 스트림을 문자열 기반의 스트림으로 연결하는 역할을 수행한다.&lt;/li&gt;
  &lt;li&gt;PipedReader: 파이프 스트림을 읽는다.&lt;/li&gt;
  &lt;li&gt;StringReader: 문자열 기반의 소스를 읽는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BufferedReader 클래스는 다른 FileReader 클래스와 마찬가지로 문자열 단위나 문자열 배열 단위로 읽을 수 있는 기능을 제공하지만, 추가로 라인 단위로 읽을 수 있는 readLine() 메서드를 제공한다. 실제 응답 속도도 약 350ms로, 약간 빨라진다. 이 속도는 파일의 크기와 비례한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;버퍼 없이 FileReader&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;버퍼 포함한 FileReader&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;BufferedReader 사용시&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;응답 속도&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2,480ms&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;400ms&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;350ms&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;nio의-원리&quot;&gt;NIO의 원리&lt;/h3&gt;
&lt;p&gt;JDK 1.4부터 새롭게 추가된 NIO가 어떤 것인지 알아보자. 자바를 사용하여 하드 디스크에 있는 데이터를 읽는다면 어떤 프로세스로 진행될까?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;파일을 읽으라는 메서드를 자바에 전달한다.&lt;/li&gt;
  &lt;li&gt;파일명을 전달받은 메서드가 운영체제의 커널에게 파일을 읽어 달라고 요청한다.&lt;/li&gt;
  &lt;li&gt;커널이 하드 디스크로부터 파일을 읽어서 자신의 커널에 있는 버퍼에 복사하는 작업을 수행한다. DMA에서 이 작업을 하게 된다.&lt;/li&gt;
  &lt;li&gt;자바에서는 마음대로 커널의 버퍼를 사용하지 못하므로, JVM으로 그 데이터를 전달한다.&lt;/li&gt;
  &lt;li&gt;JVM에서는 메서드에 있는 스트림 관리 클래스를 사용하여 데이터를 처리한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;자바에서는 3번 복사 작업과 4번 전달 작업을 수행할 때 대기하는 시간이 발생할 수 밖에 없다. 이러한 단점을 보완하기 위해 NIO가 탄생했다. NIO를 사용한다고 IO에서 발생하는 모든 병목 현상이 해결되는 것은 아니지만, IO를 위한 여러 가지 새로운 개념이 도입되었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;버퍼의 도입&lt;/li&gt;
  &lt;li&gt;채널의 도입&lt;/li&gt;
  &lt;li&gt;문자열의 인코더와 디코어 제공&lt;/li&gt;
  &lt;li&gt;Perl 스타일의 정규 표현식에 기초한 패턴 매칭 방법 제공&lt;/li&gt;
  &lt;li&gt;파일을 잠그거나 메모리 매핑이 가능한 파일 인터페이스 제공&lt;/li&gt;
  &lt;li&gt;서버를 위한 복합적인 Non-blocking IO 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;directbytebuffer를-잘못-사용하여-문제가-발생한-사례&quot;&gt;DirectByteBuffer를 잘못 사용하여 문제가 발생한 사례&lt;/h3&gt;
&lt;p&gt;NIO를 사용할 때 ByteBuffer를 사용하는 경우가 있다. ByteBuffer는 네트워크나 파일에 있는 데이터를 읽어 들일때 사용한다. ByteBuffer 객체를 생성하는 메서드에는 wrap(), allocate(), allocateDirect()가 있다. 이 중에서 allocateDirect 메서드는 데이터를 JVM에 올려서 사용하는 것이 아니라, OS 메모리에 할당된 메모리를 Native한 JNI로 처리하는 DirectByteBuffer 객체를 생성한다. 그런데 이 DirectByteBuffer 객체는 필요할 때 계속 생성해서는 안 된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;psvm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;DirectByteBuffer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;check&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DirectByteBufferCheck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDirectByteBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ByteBuffer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getDirectByteBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ByteBuffer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ByteBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;allocateDirect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;65536&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;getDirectByteBuffer 메서드를 지속적으로 호출하는 간단한 코드다. getDirectByteBuffer 메서드에서는 ByteBuffer 클래스의 allocateDirect 메서드를 호출함으로써 DirectByteBuffer 객체를 생성한 후 리턴해준다.&lt;/p&gt;

&lt;p&gt;이 예제를 실행하고 나서 GC 상황을 모니터링하기 위해 jstat 명령을 사용하여 확인해보면 거의 5~10초에 한 번씩 Full GC가 발생하는 것을 볼 수 있다. 그런데 Old 영역의 메모리는 증가하지 않는다. 왜 이러한 문제가 발생했을까?&lt;/p&gt;

&lt;p&gt;그 이유는 DirectByteBuffer의 생성자 때문이다. 이 생성자는 java.nio 에 아무런 접근 제어자가 없이 선언된(package private) Bits라는 클래스의 reserveMemory() 메서드를 호출한다. 이 reserveMemory 메서드에서는 JVM에 할당되어 있는 메모리보다 더 많으 메모리를 요구할 경우 System.gc() 메서드를 호출하도록 되어 있다.&lt;/p&gt;

&lt;p&gt;JVM에 있는 코드에 System.gc() 메서드가 있기 때문에 해당 생성자가 무차별적으로 생성될 경우 GC가 자주 발생하고 성능에 영향을 줄 수 밖에 없다. 따라서, 이 DirectByteBuffer 객체를 생성할 때는 매우 신중하게 접근해야만 하며, 가능하다면 singleton 패턴을 사용하여 해당 JVM에는 하나의 객체만 생성하도록 하는 것을 권장한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;10-로그는-반드시-필요한-내용만-찍자&quot;&gt;10. 로그는 반드시 필요한 내용만 찍자&lt;/h1&gt;

&lt;h3 id=&quot;systemoutprintln의-문제점&quot;&gt;System.out.println()의 문제점&lt;/h3&gt;
&lt;p&gt;파일이나 콘솔에 로그를 남길 경우 애플리케이션에서는 대기 시간이 발생한다. 이 대기 시간은 시스템의 속도에 의존적이다. 만약 디스크에 로그를 남긴다면, 서버 디스크의 RPM이 높을수록 로그의 처리 속도는 빨라질 것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;개션율이란 튜닝 전과 후의 차이를 수치로 나타낸 것이다. 다음의 공식으로 구한다&lt;br /&gt;
(튜닝 전 응답 속도 - 튜닝 후 응답 속도) * 100 / 튜닝 후 응답 속도 = 개선율(%)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;의미 없는 디버그용 로그를 프린트하기 위해서 아까운 서버의 리소스와 디스크가 낭비될 수 있다. 별다른 튜닝도 필요 없는 로그 제거 작업이 성능을 얼마나 많이 향상 시킬 수 있을지 다시 한 번 생각해 보고, 운영 서버의 소스에 있는 모든 시스템 로그를 제거하기 바란다.&lt;/p&gt;

&lt;h3 id=&quot;systemoutformat-메서드&quot;&gt;System.out.format() 메서드&lt;/h3&gt;
&lt;p&gt;format() 메서드는 JDK 5.0의 System 클래스에서 사용하는 out 객체 클래스인 PrintStream에 새로 추가되었다. 문자열을 사용할 경우에는 %s, int나 long과 같은 정수형을 나타낼 경우에는 %d, float이나 double을 나타낼 경우에는 %f를 사용하면 된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;repeats&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;str1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;aaa&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;bbb&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ccc&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;repeats&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;str2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forma