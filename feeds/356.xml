<?xml version='1.0' encoding='UTF-8'?><?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?><feed xmlns='http://www.w3.org/2005/Atom' xmlns:openSearch='http://a9.com/-/spec/opensearchrss/1.0/' xmlns:blogger='http://schemas.google.com/blogger/2008' xmlns:georss='http://www.georss.org/georss' xmlns:gd="http://schemas.google.com/g/2005" xmlns:thr='http://purl.org/syndication/thread/1.0'><id>tag:blogger.com,1999:blog-7695410439997503474</id><updated>2019-04-18T08:35:30.428+09:00</updated><category term="React"/><category term="App Framework"/><category term="Enact"/><category term="JavaScript"/><category term="리액트"/><category term="front-end"/><category term="Tutorial"/><category term="Async Rendering"/><category term="Conference"/><category term="Error Boundary"/><category term="NPM"/><category term="React Context"/><category term="React Suspense"/><category term="ReactEurope"/><category term="null"/><category term="null string"/><category term="web"/><category term="컨퍼런스"/><title type='text'>웹 프런트엔드 개발</title><subtitle type='html'>React 기반 웹앱 프레임워크 Enact 개발에 대한 이야기&#xa;http://enactjs.com</subtitle><link rel='http://schemas.google.com/g/2005#feed' type='application/atom+xml' href='https://devwaf.blogspot.com/feeds/posts/default'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7695410439997503474/posts/default'/><link rel='alternate' type='text/html' href='https://devwaf.blogspot.com/'/><link rel='hub' href='http://pubsubhubbub.appspot.com/'/><author><name>Seungho Park</name><uri>http://www.blogger.com/profile/16951750813615328804</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//2.bp.blogspot.com/-pHdFHG-1d1U/XLe3Xpve9CI/AAAAAAAAhWk/bLrV-WtYUHgYcXLnseFu56qKrIxhWKm2wCK4BGAYYCw/s220/IMG_6744_Profile.jpg'/></author><generator version='7.00' uri='http://www.blogger.com'>Blogger</generator><openSearch:totalResults>7</openSearch:totalResults><openSearch:startIndex>1</openSearch:startIndex><openSearch:itemsPerPage>25</openSearch:itemsPerPage><entry><id>tag:blogger.com,1999:blog-7695410439997503474.post-5057038413138430348</id><published>2019-02-20T20:38:00.001+09:00</published><updated>2019-02-20T20:43:01.886+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="App Framework"/><category scheme="http://www.blogger.com/atom/ns#" term="Enact"/><category scheme="http://www.blogger.com/atom/ns#" term="NPM"/><category scheme="http://www.blogger.com/atom/ns#" term="React"/><category scheme="http://www.blogger.com/atom/ns#" term="리액트"/><title type='text'>Enact 컴포넌트의 호환</title><content type='html'>&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Enact 컴포넌트의 호환_20190220&lt;/title&gt;  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackedit.io/style.css&quot; /&gt;&lt;/head&gt; &lt;body class=&quot;stackedit&quot;&gt;  &lt;div class=&quot;stackedit__html&quot;&gt;&lt;h1 id=&quot;enact-컴포넌트의-호환&quot;&gt;Enact 컴포넌트의 호환&lt;/h1&gt;&lt;p&gt;상호 운용성(Interoperability)은 Enact팀에게 매우 중요합니다. 오픈소스 프레임워크로서, Enact 컴포넌트를 다른 프로젝트에서 사용할 수 있다는 점과 광범위한 자바스크립트 생태계의 컴포넌트들을 Enact와 함께 사용할 수 있다는 점이 중요합니다. 결론은 Enact가 폐쇄된 생태계가 아니라는 것 입니다. 단순히 React 앱을 작성하는 통일된 방법일 뿐 입니다.&lt;/p&gt;&lt;iframe src=&quot;https://codesandbox.io/embed/z2wnj3jznx&quot; style=&quot;width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;&quot; sandbox=&quot;allow-modals allow-forms allow-popups allow-scripts allow-same-origin&quot;&gt;&lt;/iframe&gt;&lt;p&gt;CodeSandbox 에서 구동중인 Enact Moonstone UI 라이브러리&lt;/p&gt;&lt;p&gt;이와같이, Enact는 다른 React 라이브러리와 잘 동작하며, npm에서 많은 컴포넌트들을 가져와 Enact 프로젝트에서 사용할 수 있습니다. 가장 일반적인 통합 시나리오 두 가지는, Enact CLI를 이용하여 외부 패키지를 사용하거나, create-react-app 같은 다른 빌드 시스템에서 Enacgt 컴포넌트를 사용하는 것 입니다.&lt;/p&gt;&lt;h2 id=&quot;enact에서-외부-패키지-사용하기&quot;&gt;Enact에서 외부 패키지 사용하기&lt;/h2&gt;&lt;p&gt;Enact 개발을 처음 시작했을때 &lt;a href=&quot;https://facebook.github.io/create-react-app/&quot;&gt;create-react-app&lt;/a&gt;은 존재하지 않았습니다. React를 사용하여 작업하는 것을 단순화하려는 우리의 목표를 위해 Enact CLI 도구를 만들게 되었습니다. 이 도구는 현재 create-react-app이 동작하는 방식과 유사합니다. Enact 프로젝트를 쉽게 생성, 테스트 및 유지관리 할 수 있습니다. Enact CLI는 앱 개발자가 구성해야 하는  Webpack, Babel, ESLint, Jest 등의 무수히 많은 도구를 모두 처리합니다. 우리는 이러한 모든 것들이 원활하게 함께 동작하기위한 노력을 기울였습니다.&lt;/p&gt;&lt;p&gt;CLI는 &lt;a href=&quot;https://www.npmjs.com/package/@enact/template-typescript&quot;&gt;Typescript 템플릿&lt;/a&gt;을 포함하여 많은 수의 &lt;a href=&quot;https://www.npmjs.com/search?q=%40enact%2Ftemplate&quot;&gt;템플릿&lt;/a&gt;을 지원합니다. 템플릿으로 부터 작업하는 것은 새로운 앱을 시작하는 좋은 방법입니다.&lt;/p&gt;&lt;p&gt;간단한 &lt;code&gt;npm install&lt;/code&gt; 만으로 대부분의 패키지를 Enact 에서 사용할 수 있습니다. Webpack과 Babel의 default는 다양한 오픈소스 소프트웨어에서 작동하도록 신중하게 선택되었습니다.&lt;/p&gt;&lt;p&gt;특별한 Webpack 플러그인이 필요한 패키지조차도 Enact와 함께 사용할 수 있습니다. &lt;a href=&quot;http://enactjs.com/docs/developer-tools/cli/ejecting-apps/&quot;&gt;CLI eject 명령&lt;/a&gt;을 사용하여 모든 configuration option을 App 디렉토리에 복사하고 CLI 환경에서 제거하십시오. 이 시점에서 앱은 완벽하게 여러분이 제어하게 됩니다.&lt;/p&gt;&lt;h2 id=&quot;다른-빌드-시스템에서-enact-사용하기&quot;&gt;다른 빌드 시스템에서 Enact 사용하기&lt;/h2&gt;&lt;p&gt;기존 개발하고 있는 React 앱이 있는 경우 Enact를 추가하는 것도 간단히 할 수 있습니다. Enact를 pre-transpile 에 의존하지 않는 ES5와 CSS로 npm에 배포합니다. Enact 패키지는 npm의  &lt;a href=&quot;https://www.npmjs.com/search?q=%40enact%2F&quot;&gt;&lt;strong&gt;@enact&lt;/strong&gt;&lt;/a&gt; 네임스페이스에서 사용할 수 있습니다.&lt;/p&gt;&lt;p&gt;예를 들어 컴포넌트와 HOC 유틸리티가 포함된 core패키지를 설치하려면 다음을 수행하면 됩니다 : &lt;code&gt;npm install @enact/core&lt;/code&gt;. 다른 패키지도 비슷한 패턴을 따릅니다.&lt;/p&gt;&lt;p&gt;Enact의 &lt;code&gt;@enact/i18n&lt;/code&gt; 패키지가 올바르게 작동하려면 특별한  &lt;a href=&quot;https://github.com/enactjs/dev-utils/tree/master/plugins/ILibPlugin&quot;&gt;Webpack plugin&lt;/a&gt;이 필요합니다. Enact를 사용하여 국제화(i18n) 기능을 이용하려면 Webpack config에 플러그인을 추가해야 합니다. 또한, &lt;code&gt;@enact/moonstone&lt;/code&gt; 이 의존적이므로 플러그인이 없으면 국제화 기능을 사용할 수 없습니다.&lt;/p&gt;&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;&lt;p&gt;위에서 언급했듯이 Enact는 React와 현재 자바스크립트 생태계를 구성하는 다른 모든 도구위에 구축된 프레임워크 입니다. 상호 운용성(Interoperability)은 Enact의 핵심 기능입니다. 더 넓은 React 커뮤니티와 언제나 함께 하고 싶습니다. Enact가 유용하다고 생각되면 언제든지 사용할 수 있습니다.&lt;/p&gt;&lt;p&gt;마지막으로 우리가 함께 일하는 가장 좋은 방법은 참여하는 것입니다. 우리의&lt;a href=&quot;https://gitter.im/EnactJS/Lobby&quot;&gt;Gitter chat&lt;/a&gt; 이나 &lt;a href=&quot;https://github.com/enactjs/enact&quot;&gt;Enact on GitHub&lt;/a&gt;에 들러보세요. 우리는 여러분과 함께 개발하기를 기대합니다!&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;멋진 동료이자 Enact 개발자인 Roy Sutton 이 작성한 원문 &lt;a href=&quot;https://medium.com/enact-js/enact-and-interoperability-1bebfd178781&quot;&gt;Enact and Interoperability&lt;/a&gt;를 번역한 포스팅 입니다.&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;링크&quot;&gt;링크&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Enact 공식 홈페이지: &lt;a href=&quot;http://enactjs.com&quot;&gt;http://enactjs.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Enact 소스코드: &lt;a href=&quot;https://github.com/enactjs/enact&quot;&gt;https://github.com/enactjs/enact&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Enact 문의를 위한 Gitter: &lt;a href=&quot;https://gitter.im/EnactJS/Lobby&quot;&gt;https://gitter.im/EnactJS/Lobby&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt;</content><link rel='replies' type='application/atom+xml' href='https://devwaf.blogspot.com/feeds/5057038413138430348/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://devwaf.blogspot.com/2019/02/enact-20190220.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7695410439997503474/posts/default/5057038413138430348'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7695410439997503474/posts/default/5057038413138430348'/><link rel='alternate' type='text/html' href='https://devwaf.blogspot.com/2019/02/enact-20190220.html' title='Enact 컴포넌트의 호환'/><author><name>Seungho Park</name><uri>http://www.blogger.com/profile/16951750813615328804</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//2.bp.blogspot.com/-pHdFHG-1d1U/XLe3Xpve9CI/AAAAAAAAhWk/bLrV-WtYUHgYcXLnseFu56qKrIxhWKm2wCK4BGAYYCw/s220/IMG_6744_Profile.jpg'/></author><thr:total>0</thr:total><gd:extendedProperty name="commentSource" value="1"/><gd:extendedProperty name="commentModerationMode" value="FILTERED_POSTMOD"/></entry><entry><id>tag:blogger.com,1999:blog-7695410439997503474.post-8419524921832115198</id><published>2018-06-19T17:06:00.000+09:00</published><updated>2018-06-19T18:56:36.296+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Async Rendering"/><category scheme="http://www.blogger.com/atom/ns#" term="Conference"/><category scheme="http://www.blogger.com/atom/ns#" term="Error Boundary"/><category scheme="http://www.blogger.com/atom/ns#" term="React"/><category scheme="http://www.blogger.com/atom/ns#" term="React Context"/><category scheme="http://www.blogger.com/atom/ns#" term="React Suspense"/><category scheme="http://www.blogger.com/atom/ns#" term="ReactEurope"/><category scheme="http://www.blogger.com/atom/ns#" term="리액트"/><category scheme="http://www.blogger.com/atom/ns#" term="컨퍼런스"/><title type='text'>ReactEurope 2018</title><content type='html'>&lt;h2&gt;ReactEurope&amp;nbsp;2018&amp;nbsp;&lt;/h2&gt;&lt;h3&gt;주요 주제 및 샘플코드, 컴포넌트 소개&lt;/h3&gt;&lt;div&gt;ReactEurope은 프랑스 파리에서 열리는 React 개발자 행사입니다. 2016년부터 시작하여 올해로 세번째 이며, 1000여명 이상 꽤 큰 행사입니다. 이번에 좋은 기회가 생겨 참석할 수 있었네요. 본 포스팅에서는 이 행사에서 다룬 세세한 기술적 내용보다는, 여기에서 소개된 컴포넌트의 간략한 정보와 링크, 그리고 주요 아젠다에 대한 샘플코드를 소개하도록 하겠습니다. 전체 내용은 아래 참고링크 란 - 유투브 채널 - 의 링크를 들어가면 보실 수 있습니다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;h4&gt;&lt;span style=&quot;font-size: large;&quot;&gt;| 한줄요약&lt;/span&gt;&lt;/h4&gt;&lt;blockquote class=&quot;tr_bq&quot;&gt;&quot;Suspense&quot;&lt;/blockquote&gt;2016년 Hoc, 2017년 Render Prop을 거쳐 올해는 온통 Suspense 이야기네요.&lt;br /&gt;&lt;h4&gt;&lt;span style=&quot;font-size: large;&quot;&gt;| 샘플코드&amp;nbsp; Repo&lt;/span&gt;&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/FormidableLabs/react-europe-workshop&quot;&gt;https://github.com/FormidableLabs/react-europe-workshop&lt;/a&gt;&amp;nbsp;&lt;/li&gt;&lt;/ul&gt;&lt;pre style=&quot;background-color: #f6f8fa; border-radius: 3px; box-sizing: border-box; color: #24292e; font-family: SFMono-Regular, Consolas, &amp;quot;Liberation Mono&amp;quot;, Menlo, Courier, monospace; font-size: 13.6px; line-height: 1.45; margin-bottom: 16px; overflow: auto; padding: 16px; word-wrap: normal;&quot;&gt;&lt;code style=&quot;background: transparent; border-radius: 3px; border: 0px; box-sizing: border-box; display: inline; font-family: SFMono-Regular, Consolas, &amp;quot;Liberation Mono&amp;quot;, Menlo, Courier, monospace; font-size: 13.6px; line-height: inherit; margin: 0px; overflow: visible; padding: 0px; word-break: normal; word-wrap: normal;&quot;&gt;git clone https://github.com/aweary/react-europe-workshop&lt;/code&gt;&lt;/pre&gt;아래 설명에 나오는 샘플코드의 main repo는 위와 같습니다. git clone으로 코드를 내려받고 각각의 위치에서&amp;nbsp; &lt;span style=&quot;font-family: &amp;quot;courier new&amp;quot; , &amp;quot;courier&amp;quot; , monospace;&quot;&gt;npm run start&lt;/span&gt;&lt;i&gt;&amp;nbsp;&lt;/i&gt; 혹은 &lt;span style=&quot;font-family: &amp;quot;courier new&amp;quot; , &amp;quot;courier&amp;quot; , monospace;&quot;&gt;yarn start&lt;/span&gt; 를 치면 앱이 실행됩니다.&lt;br /&gt;&lt;h4&gt;&lt;span style=&quot;font-size: large;&quot;&gt;| 주요 주제&lt;/span&gt;&lt;/h4&gt;그럼 이번 컨퍼런스에서 다룬 주요 주제를 하나씩 간략하게 다뤄보도록 하겠습니다.&lt;br /&gt;&lt;h4&gt;Context&lt;/h4&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;샘플코드:&amp;nbsp;&lt;a href=&quot;https://github.com/FormidableLabs/react-europe-workshop/tree/master/exercises/context/solution&quot;&gt;https://github.com/FormidableLabs/react-europe-workshop/tree/master/exercises/context/solution&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;React 16.3 부터 새로운 버전이 릴리즈 되었습니다. Prop Drilling의 어려움을 극복하기 위해 나왔으며 성능 저하의 걱정없이 적극적으로 사용해도 됩니다.&lt;br /&gt;Context를 사용하는 대표 라이브러리는 다음과 같습니다.&lt;br /&gt;&lt;ul&gt;&lt;li&gt;react-router&lt;/li&gt;&lt;li&gt;redux&lt;/li&gt;&lt;li&gt;mobX&lt;/li&gt;&lt;li&gt;styled-component&lt;/li&gt;&lt;li&gt;etc... 사실은 다 씁니다. (Enact 에서도 많이 씁니다)&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;다음과 같은곳에서 Context를 유용하게 사용할 수 있습니다.&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;Theming&lt;/li&gt;&lt;li&gt;Data&lt;/li&gt;&lt;li&gt;Renderless Component&lt;/li&gt;&lt;li&gt;I18N (Internationalization)&lt;/li&gt;&lt;li&gt;Communication between arbitrarily nested subcomponents&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Universal Component&lt;/h4&gt;&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;샘플코드:&amp;nbsp;&lt;a href=&quot;https://github.com/FormidableLabs/react-europe-workshop/tree/master/exercises/universal-components/solution&quot;&gt;https://github.com/FormidableLabs/react-europe-workshop/tree/master/exercises/universal-components/solution&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;컴포넌트를 유니버셜하게 만들려면,&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;Uses react-primitives or react-native-web&lt;/li&gt;&lt;li&gt;Works on both web and native&lt;/li&gt;&lt;li&gt;Native first approach&lt;/li&gt;&lt;li&gt;Works by aliasing the react-native module&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div&gt;유니버셜 컴포넌트는 React와 React Native를 하나의 코드로 대응하는 방법을 제공합니다. React와 React Native의 가장 큰 차이점은 DOM 의 존재 유무입니다. 따라서 유니버셜 컴포넌트에서는 react-primitive를 통해 컴포넌트를 구성합니다.&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-c6aHJDuW2ag/WyMcFwj-KbI/AAAAAAAAa9s/6buL5Y5HrwshgiM67o5zcmhTYz90gjpHQCLcBGAs/s1600/IMG_3571.JPG&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;902&quot; data-original-width=&quot;1600&quot; height=&quot;225&quot; src=&quot;https://3.bp.blogspot.com/-c6aHJDuW2ag/WyMcFwj-KbI/AAAAAAAAa9s/6buL5Y5HrwshgiM67o5zcmhTYz90gjpHQCLcBGAs/s400/IMG_3571.JPG&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;h4&gt;Async Pattern&lt;/h4&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img alt=&quot;react asyncì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼&quot; height=&quot;480&quot; src=&quot;https://pbs.twimg.com/media/DZAJMtzVoAAFMvT.jpg&quot; width=&quot;640&quot; /&gt;&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;샘플코드:&amp;nbsp;&lt;a href=&quot;https://github.com/FormidableLabs/react-europe-workshop/tree/master/exercises/async-safe/lecture-solution&quot;&gt;https://github.com/FormidableLabs/react-europe-workshop/tree/master/exercises/async-safe/lecture-solution&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;2017년에 Fiber 엔진 소개를 통해 이미 많이 들어 보셨을 겁니다. 이번에는 바뀐 라이프 사이클을 주요내용으로 하는 Async Rendering 업데이트를 다룹니다. 관련 포스팅은&amp;nbsp;&lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;샘플코드에서 다루는 주요 내용은 다음과 같습니다.&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;async 요청을 위한 셋업은 &lt;span style=&quot;font-family: &amp;quot;courier new&amp;quot; , &amp;quot;courier&amp;quot; , monospace;&quot;&gt;componentDidMount&lt;/span&gt;에서 해야 합니다.&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-family: &amp;quot;courier new&amp;quot; , &amp;quot;courier&amp;quot; , monospace;&quot;&gt;getDerivedStateFromProps &lt;/span&gt;는 컴포넌트가 초기화 되거나 새로운 props을 받자마자 호출됩니다. &lt;span style=&quot;font-family: &amp;quot;courier new&amp;quot; , &amp;quot;courier&amp;quot; , monospace;&quot;&gt;componentDidUpdate&lt;/span&gt;와 함께쓰면 이전의 &lt;span style=&quot;font-family: &amp;quot;courier new&amp;quot; , &amp;quot;courier&amp;quot; , monospace;&quot;&gt;componentWillReceiveProps&lt;/span&gt;를 대체할 수 있습니다.&lt;/li&gt;&lt;li&gt;DOM이 업데이트 되기 전 값을 읽고 싶으면 &lt;span style=&quot;font-family: &amp;quot;courier new&amp;quot; , &amp;quot;courier&amp;quot; , monospace;&quot;&gt;getSnapshotBeforeUpdate&lt;/span&gt;를 사용하세요. &lt;span style=&quot;font-family: &amp;quot;courier new&amp;quot; , &amp;quot;courier&amp;quot; , monospace;&quot;&gt;componentDidUpdate&lt;/span&gt;와 함께쓰면 이전의 &lt;span style=&quot;font-family: &amp;quot;courier new&amp;quot; , &amp;quot;courier&amp;quot; , monospace;&quot;&gt;componentWillUpdate&lt;/span&gt;를 대체할 수 있습니다.&amp;nbsp;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div&gt;&lt;h4&gt;React Suspense&lt;/h4&gt;&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;샘플코드:&amp;nbsp;&lt;a href=&quot;https://github.com/FormidableLabs/react-europe-workshop/tree/master/exercises/suspense/exercise-solution&quot;&gt;https://github.com/FormidableLabs/react-europe-workshop/tree/master/exercises/suspense/exercise-solution&lt;/a&gt;&lt;/li&gt;&lt;li&gt;다음 링크에 소개되는 영상을 꼭 먼저 보세요.&amp;nbsp;&lt;span lang=&quot;ko&quot; style=&quot;background-color: white; color: #3572b0; font-family: &amp;quot;arial&amp;quot; , sans-serif; font-size: 14px;&quot;&gt;&lt;a class=&quot;external-link&quot; href=&quot;https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html&quot; rel=&quot;nofollow&quot; style=&quot;color: #3572b0; text-decoration-line: none;&quot;&gt;https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;데이터를 async로 받아오는 동안 렌더링을 멈출 수 있는(Suspend) 일반적인 방법을 제공합니다.&lt;/li&gt;&lt;li&gt;simple-cache-provider (&lt;a class=&quot;external-link&quot; href=&quot;https://github.com/acdlite/react/tree/suspense/packages/simple-cache-provider&quot; rel=&quot;nofollow&quot; style=&quot;background-color: white; color: #3572b0; font-family: Arial, sans-serif; text-decoration-line: none;&quot;&gt;https://github.com/acdlite/react/tree/suspense/packages/simple-cache-provider&lt;/a&gt;&lt;span style=&quot;background-color: white; color: #333333; font-family: &amp;quot;arial&amp;quot; , sans-serif;&quot;&gt;) 를 사용하는데, API는 아직 unstable 입니다.&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;background-color: white; color: #333333; font-family: &amp;quot;arial&amp;quot; , sans-serif;&quot;&gt;&amp;lt;React.Timeout/&amp;gt;을 사용하여 loading 이미지를 보일지/말지를 결정하는 기준 시간을 정할 수 있습니다.&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;span style=&quot;color: #333333; font-family: &amp;quot;arial&amp;quot; , sans-serif;&quot;&gt;샘플 코드를 실행할때, inspector를 띄우고 network를 느린상태로 시뮬레이션 하면 suspense를 더 자세히 볼 수 있습니다. 이미지 데이터가 다 내려올때 까지 렌더를 대기하고 데이터가 다 오면 한방에 그리는 것을 볼 수 있습니다.&lt;/span&gt;&lt;/div&gt;&lt;h4&gt;Error Boundaries&lt;/h4&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;샘플코드:&amp;nbsp;&lt;a href=&quot;https://github.com/FormidableLabs/react-europe-workshop/tree/master/exercises/error-boundaries/exercise-solution&quot;&gt;https://github.com/FormidableLabs/react-europe-workshop/tree/master/exercises/error-boundaries/exercise-solution&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;Error boundary는 child 컴포넌트에서 발생한 스크립트 에러를 잡아내기 위한 React 컴포넌트 입니다. JSX declarative 표현에서 try() catch() 와 같은 목적으로 사용됩니다. &lt;span style=&quot;font-family: &amp;quot;courier new&amp;quot; , &amp;quot;courier&amp;quot; , monospace;&quot;&gt;componentDidCatch()&lt;/span&gt;를 사용하며 다음 링크를 참고하세요.&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;br /&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;&lt;a class=&quot;external-link&quot; href=&quot;https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html&quot; rel=&quot;nofollow&quot; style=&quot;color: #3572b0;&quot;&gt;https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;div class=&quot;_mce_tagged_br&quot; style=&quot;padding: 0px;&quot;&gt;&lt;a href=&quot;https://github.com/bvaughn/react-error-boundary&quot;&gt;https://github.com/bvaughn/react-error-boundary&lt;/a&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;h4&gt;Compound 컴포넌트&lt;/h4&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;샘플코드:&amp;nbsp;&lt;a href=&quot;https://github.com/FormidableLabs/react-europe-workshop/tree/master/exercises/compound-components/exercise-solution&quot;&gt;https://github.com/FormidableLabs/react-europe-workshop/tree/master/exercises/compound-components/exercise-solution&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;Compound 컴포넌트는 HTML의 &amp;lt;select&amp;gt; &amp;lt;option&amp;gt;과 같이 sub-component로 이루어진 컴포넌트 디자인 패턴입니다. sub component의 순서를 바꾸거나 넣고/빼고가 자유로운 장점이 있습니다.&lt;/div&gt;&lt;/div&gt;&lt;h4&gt;&lt;span style=&quot;font-size: large;&quot;&gt;| 컨퍼런스에서 소개된 컴포넌트들&lt;/span&gt;&lt;/h4&gt;&lt;div&gt;컨퍼런스에서 정말 다양하고 많은 react-XXX 컴포넌트들이 소개되었습니다. 그 중 흥미로웠던 몇가지 컴포넌트를 링크와 함께 소개합니다.&lt;/div&gt;&lt;h4&gt;React Virtualized&lt;/h4&gt;&lt;div&gt;대용량의 list를 효과적으로 처리하기 위한 컴포넌트 입니다. grid, 테이블, 리스트등을 지원합니다. Enact 에서도 &lt;a href=&quot;http://enactjs.com/docs/developer-guide/moonstone/virtual-list-scroller/&quot; target=&quot;_blank&quot;&gt;&lt;span style=&quot;font-family: &amp;quot;courier new&amp;quot; , &amp;quot;courier&amp;quot; , monospace;&quot;&gt;VirtualList, VirtualGridList &lt;/span&gt;&lt;/a&gt;라고 하는 비슷한 컴포넌트를 지원합니다.&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;&lt;a class=&quot;external-link&quot; href=&quot;https://github.com/bvaughn/react-virtualized&quot; rel=&quot;nofollow&quot; style=&quot;background-color: white; color: #3572b0; font-family: Arial, sans-serif; font-size: 14px; text-decoration-line: none;&quot;&gt;https://github.com/bvaughn/react-virtualized&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;h4&gt;Formidable&amp;nbsp;&lt;/h4&gt;&lt;div&gt;Formidable 에서는 다양한 React 기반의 오픈소스 프로젝트를 진행합니다.&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;ul style=&quot;background-color: white; color: #333333; font-family: Arial, sans-serif; margin: 0px;&quot;&gt;&lt;li&gt;&lt;a class=&quot;external-link&quot; href=&quot;http://formidable.com/open-source/&quot; rel=&quot;nofollow&quot; style=&quot;color: #3572b0; text-decoration-line: none;&quot;&gt;http://formidable.com/open-source/&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;div style=&quot;padding: 0px;&quot;&gt;Data Visualization :&amp;nbsp;&lt;a class=&quot;external-link&quot; href=&quot;https://formidable.com/open-source/victory/&quot; rel=&quot;nofollow&quot; style=&quot;color: #3572b0; text-decoration-line: none;&quot;&gt;https://formidable.com/open-source/victory/&lt;/a&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div style=&quot;padding: 0px;&quot;&gt;Dashboard:&amp;nbsp;&lt;a class=&quot;external-link&quot; href=&quot;https://formidable.com/open-source/development-dashboards/&quot; rel=&quot;nofollow&quot; style=&quot;color: #3572b0; text-decoration-line: none;&quot;&gt;https://formidable.com/open-source/development-dashboards/&lt;/a&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;Inline styles on React Element:&amp;nbsp;&lt;a class=&quot;external-link&quot; href=&quot;https://formidable.com/open-source/radium/&quot; rel=&quot;nofollow&quot; style=&quot;color: #3572b0; text-decoration-line: none;&quot;&gt;https://formidable.com/open-source/radium/&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span style=&quot;color: #333333; font-family: &amp;quot;arial&amp;quot; , sans-serif;&quot;&gt;React Native on the web?&lt;/span&gt;&lt;/h4&gt;&lt;/div&gt;&lt;div&gt;&lt;ul style=&quot;background-color: white; color: #333333; font-family: Arial, sans-serif; margin: 0px;&quot;&gt;&lt;li&gt;&lt;div style=&quot;padding: 0px;&quot;&gt;Usable React in a web worker&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div style=&quot;padding: 0px;&quot;&gt;Natural way to restrict developers from using DOM APIs&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div style=&quot;padding: 0px;&quot;&gt;Leverage the same JS code from React Native core&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div style=&quot;padding: 0px;&quot;&gt;Ecosystem - compatible escape hatch through the native module bridge&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div style=&quot;padding: 0px;&quot;&gt;Supports advanced core features&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div style=&quot;padding: 0px;&quot;&gt;Introduce React Native DOM -&amp;nbsp;&lt;a class=&quot;external-link&quot; href=&quot;https://github.com/vincentriemer/react-native-dom&quot; rel=&quot;nofollow&quot; style=&quot;color: #3572b0; text-decoration-line: none;&quot;&gt;https://github.com/vincentriemer/react-native-dom&lt;/a&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span style=&quot;color: #333333; font-family: &amp;quot;arial&amp;quot; , sans-serif;&quot;&gt;RTL 컴포넌트 by airbnb&lt;/span&gt;&lt;/h4&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #333333; font-family: &amp;quot;arial&amp;quot; , sans-serif;&quot;&gt;airbnb 에서 아랍 로케일 지원을 위한 RTL 컴포넌트를 공개하였습니다. Enact 의 &lt;a href=&quot;http://enactjs.com/docs/developer-guide/i18n/&quot; target=&quot;_blank&quot;&gt;i18n 모듈&lt;/a&gt;도 비슷한 기능을 지원합니다.&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;ul style=&quot;background-color: white; color: #333333; font-family: Arial, sans-serif; margin: 0px;&quot;&gt;&lt;li&gt;&lt;div style=&quot;padding: 0px;&quot;&gt;&lt;a class=&quot;external-link&quot; href=&quot;https://github.com/airbnb/react-with-direction&quot; rel=&quot;nofollow&quot; style=&quot;color: #3572b0;&quot;&gt;https://github.com/airbnb/react-with-direction&lt;/a&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div style=&quot;padding: 0px;&quot;&gt;&lt;a class=&quot;external-link&quot; href=&quot;https://github.com/airbnb/react-with-styles&quot; rel=&quot;nofollow&quot; style=&quot;color: #3572b0; text-decoration-line: none;&quot;&gt;https://github.com/airbnb/react-with-styles&lt;/a&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;a class=&quot;external-link&quot; href=&quot;https://github.com/kentcdodds/rtl-css-js&quot; rel=&quot;nofollow&quot; style=&quot;color: #3572b0; text-decoration-line: none;&quot;&gt;https://github.com/kentcdodds/rtl-css-js&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;h4&gt;&lt;span style=&quot;color: #333333; font-family: &amp;quot;arial&amp;quot; , sans-serif;&quot;&gt;UI Design to React Native&lt;/span&gt;&lt;/h4&gt;&lt;div&gt;&lt;span style=&quot;color: #333333; font-family: &amp;quot;arial&amp;quot; , sans-serif;&quot;&gt;BuilderX 라고 하는 디자인툴을 소개하였습니다. 디자인을 하면 React Native 코드를 생성해 주고, Sketch 파일의 converting도 지원합니다.&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;&lt;span style=&quot;color: #333333; font-family: &amp;quot;arial&amp;quot; , sans-serif;&quot;&gt;&lt;a href=&quot;https://builderx.io/&quot;&gt;https://builderx.io/&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span style=&quot;color: #333333; font-family: &amp;quot;arial&amp;quot; , sans-serif;&quot;&gt;ReasonReact&lt;/span&gt;&lt;/h4&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #333333; font-family: &amp;quot;arial&amp;quot; , sans-serif;&quot;&gt;Reason으로 React컴포넌트를 생성하는 방법을 제공합니다. Reason은 OCaml로 만들어진 구문과 툴체인입니다.&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;ul style=&quot;background-color: white; color: #333333; font-family: Arial, sans-serif; margin: 0px;&quot;&gt;&lt;li&gt;&lt;div style=&quot;padding: 0px;&quot;&gt;&lt;a class=&quot;external-link&quot; href=&quot;https://reasonml.github.io/reason-react/&quot; rel=&quot;nofollow&quot; style=&quot;color: #3572b0; text-decoration-line: none;&quot;&gt;https://reasonml.github.io/reason-react/&lt;/a&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div style=&quot;padding: 0px;&quot;&gt;&lt;a class=&quot;external-link&quot; href=&quot;https://reasonml.github.io/docs/en/what-and-why.html&quot; rel=&quot;nofollow&quot; style=&quot;color: #3572b0; text-decoration-line: none;&quot;&gt;https://reasonml.github.io/docs/en/what-and-why.html&lt;/a&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span style=&quot;color: #333333; font-family: &amp;quot;arial&amp;quot; , sans-serif;&quot;&gt;React Navigation&lt;/span&gt;&lt;/h4&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: white; color: #333333; font-family: &amp;quot;arial&amp;quot; , sans-serif;&quot;&gt;Navigation은 웹과 모바일 환경에서 크게 다른 방식으로 동작합니다. 컨퍼런스에서는 Navigation state와 url 핸들링이 어떻게 달라지는지 살펴보고, 두 가지 use case를 관리하는 모델로 React Navigation 을 소개했습니다. React Navigation API를 통해 iOS, Android, web에서 쉽게 Navigation을 관리합니다.&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;ul style=&quot;background-color: white; color: #333333; font-family: Arial, sans-serif; margin: 0px;&quot;&gt;&lt;li&gt;&lt;div style=&quot;padding: 0px;&quot;&gt;&lt;a class=&quot;external-link&quot; href=&quot;https://reactnavigation.org/&quot; rel=&quot;nofollow&quot; style=&quot;color: #3572b0; text-decoration-line: none;&quot;&gt;https://reactnavigation.org/&lt;/a&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;h4&gt;&lt;span style=&quot;color: #333333; font-family: &amp;quot;arial&amp;quot; , sans-serif;&quot;&gt;SVGR&lt;/span&gt;&lt;/h4&gt;&lt;div&gt;&lt;span style=&quot;color: #333333; font-family: &amp;quot;arial&amp;quot; , sans-serif;&quot;&gt;SVG를 다루는 React 컴포넌트 입니다.&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;&lt;span style=&quot;color: #333333; font-family: &amp;quot;arial&amp;quot; , sans-serif;&quot;&gt;&lt;a class=&quot;external-link&quot; href=&quot;https://github.com/smooth-code/svgr&quot; rel=&quot;nofollow&quot; style=&quot;background-color: white; color: #3572b0; font-size: 14px; text-decoration-line: none;&quot;&gt;https://github.com/smooth-code/svgr&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span style=&quot;font-size: large;&quot;&gt;| 마치며&lt;/span&gt;&lt;/h4&gt;&lt;/div&gt;&lt;div&gt;간략하게 나마 React유럽 컨퍼런스에서 다루어진 주요 주제와 컴포넌트등을 소개하였습니다. 이번 워크샵/컨퍼런스에서 느낀점은 정말 많은 개발자들이 React 환경에서 다양한 목표를 가지고 개발을 하고 있으며 그 과정에서 만들어진 컴포넌트들을 react-XXX 로 공개하고 있다는 점 입니다. 네트워킹을 통해 다양한 의견을 나눌 수 있는 기회가 어찌보면 컨퍼런스 기술발표 하나 더 듣는것 보다 소중한 시간이었습니다. 여러 React컨퍼런스 중에 가장 메인 이벤트로 ReactEurope이 자리잡아 가고 있는듯 한데, 기회가 된다면 꼭 한번 참석해 보시라고 강력하게 추천 드립니다.&lt;/div&gt;&lt;h4&gt;&lt;span style=&quot;font-size: large;&quot;&gt;| 참고링크&lt;/span&gt;&lt;/h4&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;ReactEurope&amp;nbsp;홈페이지:&amp;nbsp;&lt;a href=&quot;https://www.react-europe.org/&quot; target=&quot;_blank&quot;&gt;https://www.react-europe.org&lt;/a&gt;&lt;/li&gt;&lt;li&gt;React 전체 컨퍼런스 일정:&amp;nbsp;&lt;a href=&quot;https://reactjs.org/community/conferences.html&quot; target=&quot;_blank&quot;&gt;https://reactjs.org/community/conferences.html&amp;nbsp;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/channel/UCorlLn2oZfgOJ-FUcF2eZ1A&quot; target=&quot;_blank&quot;&gt;YouTube Channel&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='https://devwaf.blogspot.com/feeds/8419524921832115198/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://devwaf.blogspot.com/2018/06/reacteurope-2018.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7695410439997503474/posts/default/8419524921832115198'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7695410439997503474/posts/default/8419524921832115198'/><link rel='alternate' type='text/html' href='https://devwaf.blogspot.com/2018/06/reacteurope-2018.html' title='ReactEurope 2018'/><author><name>Seungho Park</name><uri>http://www.blogger.com/profile/16951750813615328804</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//2.bp.blogspot.com/-pHdFHG-1d1U/XLe3Xpve9CI/AAAAAAAAhWk/bLrV-WtYUHgYcXLnseFu56qKrIxhWKm2wCK4BGAYYCw/s220/IMG_6744_Profile.jpg'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://3.bp.blogspot.com/-c6aHJDuW2ag/WyMcFwj-KbI/AAAAAAAAa9s/6buL5Y5HrwshgiM67o5zcmhTYz90gjpHQCLcBGAs/s72-c/IMG_3571.JPG" height="72" width="72"/><thr:total>0</thr:total><gd:extendedProperty name="commentSource" value="1"/><gd:extendedProperty name="commentModerationMode" value="FILTERED_POSTMOD"/></entry><entry><id>tag:blogger.com,1999:blog-7695410439997503474.post-4868107941953728191</id><published>2018-04-26T20:33:00.002+09:00</published><updated>2018-04-26T20:35:24.839+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="App Framework"/><category scheme="http://www.blogger.com/atom/ns#" term="Enact"/><category scheme="http://www.blogger.com/atom/ns#" term="front-end"/><category scheme="http://www.blogger.com/atom/ns#" term="JavaScript"/><category scheme="http://www.blogger.com/atom/ns#" term="React"/><category scheme="http://www.blogger.com/atom/ns#" term="Tutorial"/><category scheme="http://www.blogger.com/atom/ns#" term="리액트"/><title type='text'>Hello Enact #2 - CSS 추가하기</title><content type='html'>&lt;article class=&quot;markdown-body&quot;&gt;&lt;h1 id=&quot;hello-enact-2---css-추가하기&quot;&gt;Hello Enact #2 - CSS 추가하기&lt;/h1&gt;&lt;p&gt;지난 시간 &lt;a href=&quot;http://devwaf.blogspot.kr/2018/04/hello-enact-1_98.html&quot;&gt;Hello Enact! #1기본&lt;/a&gt;에서 만든 앱에 약간의 스타일을 입히겠습니다. React 에서 CSS class를 정의하고 이어서 CSS modules를 살펴 보겠습니다.&lt;/p&gt;&lt;h2 id=&quot;react-에서-css-class&quot;&gt;React 에서 CSS Class&lt;/h2&gt;&lt;p&gt;CSS 클래스는 앱에 시각적 효과를 입히는 기본적인 도구 입니다. 컴포넌트에 &lt;code&gt;clssName&lt;/code&gt;&lt;br&gt;prop을 이용해 CSS Class 를 적용합니다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;div className=&quot;customClass&quot;&amp;gt;Content&amp;lt;/div&amp;gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;아래와 같이 DOM에 비슷하게 렌더링 합니다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;customClass&quot;&amp;gt;Content&amp;lt;/div&amp;gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;JSX를 처음 접하는 분은 &lt;code&gt;className&lt;/code&gt;이 아닌&lt;code&gt;class&lt;/code&gt;를 써서 HTML에 적용되기를 기대하실 수도 있겠습니다만, JSX는 JavaScript로 트랜스파일 되고, &lt;code&gt;class&lt;/code&gt;는 예약어 이기 때문에 똑같이 사용하는 것은 불가능 합니다.  상세 내용은 React 가이드 &lt;a href=&quot;https://reactjs.org/docs/dom-elements.html&quot;&gt;DOM Elements&lt;/a&gt;를 참고하세요.&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;여러분은 하이픈으로 연결된 클래스 이름을 사용하고 싶을 수 있습니다만(&lt;code&gt;custom-clss&lt;/code&gt;), 잠시 후 다룰 &lt;a href=&quot;https://github.com/css-modules/css-modules&quot;&gt;CSS Modules&lt;/a&gt;에서는 클래스 이름에 카멜케이스를 사용하기를 권장합니다. 자세한 사항은 링크의 &lt;a href=&quot;https://github.com/css-modules/css-modules#naming&quot;&gt;Naming&lt;/a&gt; 부분을 참고하세요.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;간단한 응용 프로그램의 경우 전역 클래스 이름을 사용하는 것이 쉽습니다. 보다 복잡한 응용 프로그램의 경우 유지 보수 및 재사용 성을 개선하기 위해 CSS를 구성하는 방법이 필요할 것입니다. 이 문제에 대한 다양한 솔루션을 제공하는 몇 가지 방법론 (예 : &lt;a href=&quot;http://oocss.org/&quot;&gt;Object-Oriented CSS (OOCSS)&lt;/a&gt;, &lt;a href=&quot;http://getbem.com/&quot;&gt;Block Element&lt;br&gt;Modifier (BEM)&lt;/a&gt;) 및 사전 처리기 (예 : &lt;a href=&quot;http://sass-lang.com/&quot;&gt;SASS&lt;/a&gt;,&lt;br&gt;&lt;a href=&quot;http://stylus-lang.com/&quot;&gt;Stylus&lt;/a&gt;, &lt;a href=&quot;http://lesscss.org/&quot;&gt;LESS&lt;/a&gt;)가 있습니다.&lt;/p&gt;&lt;p&gt;CSS Modules는 모듈화에만 촛점을 맞춤으로써, 다른 툴이나 방법론과 잘 어울려 작동합니다. Enact 팀이 권장하는 방법입니다.&lt;/p&gt;&lt;h2 id=&quot;css-modules-소개&quot;&gt;CSS Modules 소개&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/css-modules/css-modules&quot;&gt;CSS Modules&lt;/a&gt;는 작성자가 여러 글로벌 스타일 시트를 사용할 때 발생할 수있는 이름 충돌을 걱정하지 않고 짧고 의미있는 클래스 이름을 사용하여 CSS (또는 SASS 또는 LESS 또는 …)를 작성할 수 있도록 도와줍니다.&lt;/p&gt;&lt;p&gt;CSS 모듈에 정의 된 모든 클래스는 기본적으로 로컬입니다. 실제로는, 클래스명이 컴파일시 고유한 문자열로 바뀝니다. 생성 된 클래스 이름을 사용하기 위하여 CSS모듈은 클래스 이름 - 생성 된 이름의 맵을 내보냅니다.&lt;br&gt;예를 들어, 아래의 CSS 모듈 :&lt;/p&gt;&lt;pre&gt;&lt;code&gt;.customClass {&lt;br /&gt; background: red;&lt;br /&gt; color: white;&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;은 다음과 같은 형태로 export 됩니다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br /&gt; customClass: &#39;_13LGdX8RMStbBE9w-t0gZ1&#39;&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;:global&lt;/code&gt; pseudo-selector를 사용하여 class를 전역으로 선언할 수 도 있습니다. 이렇게 하면 선언한 이름 그대로 export 됩니다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;:global .customClass {&lt;br /&gt; background: red;&lt;br /&gt; color: white;&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;다음과 같이 export 될 것입니다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br /&gt; customClass: &#39;customClass&#39;&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;global 클래스는 가능하면 쓰지 않아야 합니다. 이것은 여러분의 컴포넌트와 CSS 소스간에 암묵적인 종속성(implicit dependency)을 생성합니다. 이 암묵적인 종속성은 빌드툴에 의해서 추적되지 못합니다. 또한 &lt;em&gt;명시적&lt;/em&gt;으로 의존하는 리소스가 더 이상 사용되지 않으면 빠질 수 도 있습니다.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;less-파일-만들기&quot;&gt;LESS 파일 만들기&lt;/h3&gt;&lt;p&gt;스타일링 위한 파일 &lt;code&gt;./src/App/App.less&lt;/code&gt;를 생성합시다.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;enact create&lt;/code&gt;가 만들어주는 webpack config에는 LESS를 지원하는 전처리기가 포함되어 있습니다. 따라서 본 과정에서는 간단한 기본 CSS문법만 사용하지만 LESS 확장자를 사용하도록 하겠습니다.&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;.app {&lt;br /&gt; font-size: 48px;&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;css-modules-사용하기&quot;&gt;CSS Modules 사용하기&lt;/h2&gt;&lt;p&gt;컴포넌트의 관점에서 CSS 모듈은 다른 모듈과 동일하게 취급됩니다. &lt;code&gt;import&lt;/code&gt;할 수 있고, class name map에 대한 레퍼런스를 얻을 수 있습니다.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;꼭 정해진 법은 아니지만, 일관성을 위하여 우리는 스타일 시트의 컴포넌트를 import 하여 &lt;code&gt;css&lt;/code&gt;변수에 담습니다.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;app.js-수정하기&quot;&gt;App.js 수정하기&lt;/h3&gt;&lt;p&gt;우리의 App 모듈을 불러와서(&lt;code&gt;./src/App/App.js&lt;/code&gt;),  CSS모듈을 import 하고, 루트 엘리먼트에 &lt;code&gt;.app&lt;/code&gt; 스타일을 적용합시다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import React from &#39;react&#39;;&lt;br /&gt;&lt;br /&gt;import css from &#39;./App.less&#39;; //스타일 컴포넌트를 css에 담아둡니다.&lt;br /&gt;&lt;br /&gt;const App = function () {&lt;br /&gt; return (&lt;br /&gt;  &amp;lt;div className={css.app}&amp;gt; //루트 엘리먼트에 .app 스타일을 적용합니다.&lt;br /&gt;   Hello Enact!&lt;br /&gt;  &amp;lt;/div&amp;gt;&lt;br /&gt; );&lt;br /&gt;};&lt;br /&gt;&lt;br /&gt;export default App;&lt;br /&gt;export {App};&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;jsx-안에서-표현-하는-방법&quot;&gt;JSX 안에서 표현 하는 방법&lt;/h2&gt;&lt;p&gt;위 샘플의 JSX가 표준 HTML과 다르다는 것을 발견하셨나요? 특히 CSS 변수 주위에 중괄호 ({})를 사용하는 것이 중요합니다.&lt;br&gt;여기에 &lt;code&gt;&quot;app&quot;&lt;/code&gt;을 사용하게 되면 CSS모듈의 로컬 범위를 참조하는 것이 아니라 전역 CSS 클래스를 참조하게 되므로, &lt;code&gt;&quot;app&quot;&lt;/code&gt;문자열을 사용할 수 없습니다. 대신에 우리는 JSX 표현식을 사용하여 유효한 자바스크립트 문장을 JSX 마크업에 포함합니다. 아래 문장은 &lt;code&gt;css.app&lt;/code&gt;의 호출 결과값을 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;의 &lt;code&gt;className&lt;/code&gt;프라퍼티로 넘겨줍니다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;div className={css.app}&amp;gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;프라퍼티 값이나 전체 엘리먼트에 &lt;em&gt;JSX 표현식&lt;/em&gt;을 사용할 수 있지만, 컴포넌트 이름이나 프라퍼티 이름에만 사용하는 것은 불가 합니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;유효함&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;div className={a ? b : c} /&amp;gt;    // ✅ property value&lt;br /&gt; {a ? &amp;lt;span&amp;gt;A&amp;lt;/span&amp;gt; : &amp;lt;span&amp;gt;!A&amp;lt;/span&amp;gt;} // ✅ entire child of &amp;lt;div&amp;gt;&lt;br /&gt;&amp;lt;/div&amp;gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;유효하지않음&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt; &amp;lt;{a ? &#39;div&#39; : &#39;span&#39;}&amp;gt;      // ❌ component name&lt;br /&gt; &amp;lt;span {a ? b : c}=&quot;value&quot; /&amp;gt;    // ❌ property name&lt;br /&gt; &amp;lt;span {a ? b=&quot;value&quot; : c=&quot;value&quot;}   // ❌ entire property&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;&lt;p&gt;이번 시간에는 React 컴포넌트에 CSS Class를 적용하는 방법과, CSS 모듈 사용법을 알아 보았습니다. 그리고 JSX에서 동적으로 프라퍼티와 엘리먼트를 추가하는 방법에 대해 간략히 살펴 보았습니다.&lt;br&gt;다음 시간에는 Enact 에서 제공하는 React 컴포넌트에 약간의 문접적 도움을 추가한 &lt;code&gt;kind()&lt;/code&gt;에 대해서 알아 보겠습니다.&lt;/p&gt;&lt;h2 id=&quot;링크&quot;&gt;링크&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Enact 공식 홈페이지: &lt;a href=&quot;http://enactjs.com&quot;&gt;http://enactjs.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Enact 소스코드: &lt;a href=&quot;https://github.com/enactjs/enact&quot;&gt;https://github.com/enactjs/enact&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Hello Enact 전체 코드: &lt;a href=&quot;https://github.com/enactjs/samples/tree/master/tutorial-hello-enact&quot;&gt;https://github.com/enactjs/samples/tree/master/tutorial-hello-enact&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Enact 문의를 위한 Gitter: &lt;a href=&quot;https://gitter.im/EnactJS/Lobby&quot;&gt;https://gitter.im/EnactJS/Lobby&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/article&gt;</content><link rel='replies' type='application/atom+xml' href='https://devwaf.blogspot.com/feeds/4868107941953728191/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://devwaf.blogspot.com/2018/04/hello-enact-2-css.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7695410439997503474/posts/default/4868107941953728191'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7695410439997503474/posts/default/4868107941953728191'/><link rel='alternate' type='text/html' href='https://devwaf.blogspot.com/2018/04/hello-enact-2-css.html' title='Hello Enact #2 - CSS 추가하기'/><author><name>Seungho Park</name><uri>http://www.blogger.com/profile/16951750813615328804</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//2.bp.blogspot.com/-pHdFHG-1d1U/XLe3Xpve9CI/AAAAAAAAhWk/bLrV-WtYUHgYcXLnseFu56qKrIxhWKm2wCK4BGAYYCw/s220/IMG_6744_Profile.jpg'/></author><thr:total>0</thr:total><gd:extendedProperty name="commentSource" value="1"/><gd:extendedProperty name="commentModerationMode" value="FILTERED_POSTMOD"/></entry><entry><id>tag:blogger.com,1999:blog-7695410439997503474.post-9019475927504663708</id><published>2018-04-25T20:29:00.002+09:00</published><updated>2018-04-25T20:31:00.375+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="JavaScript"/><category scheme="http://www.blogger.com/atom/ns#" term="null"/><category scheme="http://www.blogger.com/atom/ns#" term="null string"/><title type='text'>JavaScript에서 false를 반환하는 값</title><content type='html'>&lt;article class=&quot;markdown-body&quot;&gt;&lt;h1 id=&quot;javascript에서-false를-반환하는-value&quot;&gt;JavaScript에서 false를 반환하는 value&lt;/h1&gt;&lt;p&gt;이제 기록을 해놓지 않으면 자꾸 잊어먹네요. 오늘은 제가 인터페이스 구현할때 자주 헷갈리는 null string(&quot;&quot;) 처리에 대해서 기록을 남겨 정리를 하려고 합니다. 왜 매번 쓸때마다 다시 찾아보는지 큰일이네요…&lt;/p&gt;&lt;h2 id=&quot;false-로-변환되는-값은-다음과-같습니다.&quot;&gt;false 로 변환되는 값은 다음과 같습니다.&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;null;&lt;/li&gt;&lt;li&gt;NaN;&lt;/li&gt;&lt;li&gt;0;&lt;/li&gt;&lt;li&gt;empty string(&quot;&quot;);&lt;/li&gt;&lt;li&gt;undefined;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;empty-string을-어떻게-체크할-것인가&quot;&gt;empty string을 어떻게 체크할 것인가?&lt;/h2&gt;&lt;p&gt;그럼 이 중에서 empty string(&quot;&quot;, 또는 ‘’)을 어떻게 체크를 하면 될까요? 정답은 없지만, if 문에서 empty string은 false 처리가 된다는 것을 꼭 기억해 두고 개발을 해야 하겠습니다. (제게 하는 말입니다 -_-)&lt;/p&gt;&lt;p&gt;여러분이 구현하는 인터페이스(함수)에서 파라미터를 받아 내부 변수에 설정하고 싶은데, 이 파라미터는 외부에서 불리는 값이므로 예외처리를 꼭 해야한다고 가정합시다.&lt;/p&gt;&lt;h3 id=&quot;첫번째-방법-&quot;&gt;첫번째 방법 &lt;code&gt;!&lt;/code&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;  const myValue = !myProp ? &#39;default string&#39; : myProp; &lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;두번째-방법--null&quot;&gt;두번째 방법 &lt;code&gt;== null&lt;/code&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt; const myValue = myProp == null ? &#39;default string&#39; : myProp;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;둘-사이의-차이점은&quot;&gt;둘 사이의 차이점은?&lt;/h3&gt;&lt;p&gt;넘어오는 myProp 값이 empty string(&lt;code&gt;param=&#39;&#39;;&lt;/code&gt;) 이라면, 첫번째 방법은 ‘default string’ 이 myValue에 어사인 될것이고, 두번째 방법은 &lt;code&gt;&#39;&#39;&lt;/code&gt; 이 어사인 될것입니다.&lt;/p&gt;&lt;h3 id=&quot;사용자가-의도적으로-empty-string을-넣고-싶다면&quot;&gt;사용자가 의도적으로 empty string을 넣고 싶다면&lt;/h3&gt;&lt;p&gt;만약 사용자가 어떤 경우에 의도적으로 empty string을 넣고 그 값을 사용하고 싶다면 반드시 &lt;code&gt;== null&lt;/code&gt; 체크를 해야 합니다.&lt;br&gt;그러면, 제가 자주 접하는 react 컴포넌트를 예로 들어 보겠습니다. 그 컴포넌트의 prop에 빈 스트링을 넘겨 리셋하고 싶은 케이스가 있습니다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;MyComponent myProp=&quot;&quot;/&amp;gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이럴경우 제가 &lt;code&gt;!&lt;/code&gt;로 구현을 하게 되면 myValue에 원하는 빈 스트링으로 리셋을 하는것이 아니라 &#39;default string’이 들어가게 됩니다. &lt;code&gt;== null&lt;/code&gt; 체크를 하게되면 제가 원하는 대로 동작할 것입니다. 만약 myProp을 넘기지 않는다면 &lt;code&gt;undefiend&lt;/code&gt; 이므로 기본값을 설정할 것이고, empty string을 넘긴다면 그 값을 변수에 잘 설정할 것입니다.&lt;/p&gt;&lt;p&gt;물론 React에는 &lt;code&gt;defaultProps&lt;/code&gt; 가 있는데 왜 저렇게 컴포넌트 내부에서 null 체크를 해서 default 값을 어사인 하냐고 질문할 수 있습니다. 그 부분까지 들어가게 되면 본 내용과 상관없는 너무 소소한 이야기로 빠지게 될 터이니, 그냥 어떠한 이유로 인하여 &lt;code&gt;defaultProps&lt;/code&gt;를 사용하지 못하고 저렇게 밖에 구현할 수 없는 상황이었다 라고 가정해 봅시다. ^^;&lt;/p&gt;&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;&lt;p&gt;오늘은 짧게 false로 변환되는 JavaScript value에 대해서 알아보았습니다. 정답은 없습니다만, 동작을 잘 이해하고 원하는대로 구현하시기 바랍니다.&lt;br&gt;본 포스팅에서는 null string을 어떻게 처리할지에 대해 초점을 맞추고 이야기를 한 것입니다. 실제 인터페이스를 구현하면서 파라미터가 비어 있는지 체크할 때에는 데이터 타입, null, undefined, space 처리 등 필요에 따라 훨씬 촘촘하게 체크를 해야할 수도 있습니다.&lt;/p&gt;&lt;h2 id=&quot;참고-링크&quot;&gt;참고 링크&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null&quot;&gt;null - JavaScript | MDN&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators&quot;&gt;Logical Operators - JavaScript | MDN&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/article&gt; </content><link rel='replies' type='application/atom+xml' href='https://devwaf.blogspot.com/feeds/9019475927504663708/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://devwaf.blogspot.com/2018/04/javascript-false_25.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7695410439997503474/posts/default/9019475927504663708'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7695410439997503474/posts/default/9019475927504663708'/><link rel='alternate' type='text/html' href='https://devwaf.blogspot.com/2018/04/javascript-false_25.html' title='JavaScript에서 false를 반환하는 값'/><author><name>Seungho Park</name><uri>http://www.blogger.com/profile/16951750813615328804</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//2.bp.blogspot.com/-pHdFHG-1d1U/XLe3Xpve9CI/AAAAAAAAhWk/bLrV-WtYUHgYcXLnseFu56qKrIxhWKm2wCK4BGAYYCw/s220/IMG_6744_Profile.jpg'/></author><thr:total>0</thr:total><gd:extendedProperty name="commentSource" value="1"/><gd:extendedProperty name="commentModerationMode" value="FILTERED_POSTMOD"/></entry><entry><id>tag:blogger.com,1999:blog-7695410439997503474.post-5316574568707905295</id><published>2018-04-12T21:23:00.002+09:00</published><updated>2018-04-12T21:30:12.272+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="App Framework"/><category scheme="http://www.blogger.com/atom/ns#" term="Enact"/><category scheme="http://www.blogger.com/atom/ns#" term="front-end"/><category scheme="http://www.blogger.com/atom/ns#" term="JavaScript"/><category scheme="http://www.blogger.com/atom/ns#" term="React"/><category scheme="http://www.blogger.com/atom/ns#" term="Tutorial"/><category scheme="http://www.blogger.com/atom/ns#" term="리액트"/><title type='text'>Hello Enact #1 - 기본</title><content type='html'>&lt;article class=&quot;markdown-body&quot;&gt;&lt;h1 id=&quot;hello-enact-1---기본&quot;&gt;Hello Enact #1 - 기본&lt;/h1&gt;&lt;p&gt;앞으로 4회에 걸쳐 Hello Enact! 앱을 만들면서 기본을 배워보는 시간을 갖도록 하겠습니다. 1편에서 우리는 모듈을 만들고 앱이 어떻게 DOM에 렌더하는지 살펴보겠습니다. 그리고 앱을 패키징하고 실행해 보겠습니다.&lt;br&gt;아직 Enact 를 설치하지 않으셨다면, &lt;a href=&quot;https://devwaf.blogspot.kr/2018/03/enact-20180329_30.html&quot;&gt;Enact 개발환경 설정&lt;/a&gt; 포스팅을 먼저 읽고, 본 튜토리얼을 따라하시기 바랍니다.&lt;/p&gt;&lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;&lt;p&gt;아래 명령으로 hello enact 프로젝트를 생성합니다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;enact create tutorial-hello-enact&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;src/views/MainPanel.js&lt;/code&gt; 파일은 본 튜토리얼에서 사용하지 않으므로 삭제합니다.&lt;/p&gt;&lt;h2 id=&quot;app-module-생성&quot;&gt;App module 생성&lt;/h2&gt;&lt;p&gt;우리가 만드는 앱의 시작 위치는 &lt;code&gt;./src/index.js&lt;/code&gt; 에 있습니다. App 컴포넌트의 홈이 될 새로운 모듈을 만들겠습니다.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;CommonJS의 모듈은 하나의 파일을 직접 참조하거나 하나의 파일로 해석할 수 있는 디렉토리를 참조할 수 있습니다. Node.js 는 &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_all_together&quot;&gt;모듈 참조를 위한 룰&lt;/a&gt;을 정의하고 있습니다. webpack 은 모듈 해석을 커스터마이즈 하기위한 &lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;설정&lt;/a&gt;을 갖고 있습니다.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Enact는 앱을 위한 모듈을 다음과 같은 방법으로 생성하기를 권장합니다:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;모듈을 위한 자신의 디렉토리를 만들고 그 안에 모듈을 위치시키세요. – e.g. &lt;code&gt;./src/App&lt;/code&gt;&lt;/li&gt;&lt;li&gt;주요 로직과 동일한 이름의 소스파일 이름을 사용하세요.  – e.g. &lt;code&gt;./src/App/App.js&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;package.json&lt;/code&gt;  파일을 디렉토리 안에 포함시키고,  &lt;code&gt;main&lt;/code&gt; 프라퍼티가 모듈 js파일을 가르키도록 하세요.&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;모듈의-package.json-파일&quot;&gt;모듈의 &lt;code&gt;package.json&lt;/code&gt; 파일&lt;/h3&gt;&lt;p&gt;대부분의 모듈에서 &lt;code&gt;package.json&lt;/code&gt; 파일은 &lt;code&gt;main&lt;/code&gt; 프라퍼티만 사용 합니다. 이 파일은 &lt;a href=&quot;http://wiki.commonjs.org/wiki/Packages/1.1#Package_Descriptor_File&quot;&gt;package descriptor file&lt;/a&gt;에서 정의하는 어떤 프라퍼티라도 가질 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;code&gt;./src/App/package.json&lt;/code&gt; 파일을 만들고 내용을 다음과 같이 채워 넣읍시다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt; {&lt;br /&gt;  &quot;main&quot;: &quot;App.js&quot;&lt;br /&gt; }&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;모듈의-소스파일&quot;&gt;모듈의 소스파일&lt;/h3&gt;&lt;p&gt;이제 실제 코드를 작성해 보겠습니다. &lt;code&gt;./src/App/App.js&lt;/code&gt; 파일을 생성하고 아래와 같이 우리의 첫번째 모듈을 만듭니다:&lt;/p&gt;&lt;pre&gt;&lt;code&gt; import React from &#39;react&#39;;&lt;br /&gt; &lt;br /&gt; const App = function () {&lt;br /&gt;  return (&lt;br /&gt;   &amp;lt;div&amp;gt;&lt;br /&gt;    Hello, Enact!&lt;br /&gt;   &amp;lt;/div&amp;gt;&lt;br /&gt;  );&lt;br /&gt; };&lt;br /&gt; &lt;br /&gt; export default App;&lt;br /&gt; export {App};&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;차근차근 한줄씩 풀어보도록 하겠습니다.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;우리는 &lt;code&gt;enact&lt;/code&gt;CLI 가 생성해준 코드의 대부분을 제거했습니만, 개념을 설명하면서 점진적으로 하나씩 추가할 것입니다.&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 id=&quot;import-와-react&quot;&gt;&lt;code&gt;import&lt;/code&gt; 와 React&lt;/h4&gt;&lt;p&gt;첫번째 단계는, 이 컴포넌트에 필요한 모듈을 &lt;code&gt;import&lt;/code&gt; 하는 것입니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; 는 ES6 모듈에서 새롭게 제공하는 기능입니다.(&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-imports&quot;&gt;spec참고&lt;/a&gt;).&lt;/p&gt;&lt;pre&gt;&lt;code&gt; import React from &#39;react&#39;;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Enact 는 Facebook의 &lt;a href=&quot;https://reactjs.org/&quot;&gt;React 라이브러리&lt;/a&gt; 기반으로 구축되어 있습니다. &lt;code&gt;react&lt;/code&gt;모듈은 컴포넌트를 생성하고 조합하는데 필요한 기능을 제공합니다. 렌더링은 다른 모듈인 &lt;code&gt;react-dom&lt;/code&gt;에 의해서 처리됩니다. 이 부분은 이후 다시 설명하겠습니다.&lt;/p&gt;&lt;h4 id=&quot;app-컴포넌트&quot;&gt;App 컴포넌트&lt;/h4&gt;&lt;p&gt;이미 눈치 채셨겠지만, &lt;code&gt;App&lt;/code&gt;도 컴포넌트 입니다. 가장 심플한 타입의 React 컴포넌트는 &lt;a href=&quot;https://facebook.github.io/react/docs/reusable-components.html#stateless-functions&quot;&gt;Stateless Function&lt;/a&gt; 입니다.  SFC라고 줄여서 부릅니다. &lt;code&gt;props&lt;/code&gt; 오브젝트를 받아 &lt;a href=&quot;https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html&quot;&gt;React element&lt;/a&gt;를 리턴합니다. 우리의 첫번째 버전 Hello Enact 에서는 argument를  생략하고, &lt;code&gt;div&lt;/code&gt; DOM 노드에 인사말을 렌더 하겠습니다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt; const App = function () {&lt;br /&gt;  return (&lt;br /&gt;   &amp;lt;div&amp;gt;&lt;br /&gt;    Hello, Enact!&lt;br /&gt;   &amp;lt;/div&amp;gt;&lt;br /&gt;  );&lt;br /&gt; };&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;React는 두 가지 타입의 컴포넌트를 지원합니다 – &lt;a href=&quot;https://facebook.github.io/react/docs/reusable-components.html#es6-classes&quot;&gt;ES6 classes&lt;/a&gt; 와 Stateless Functions 입니다. 두 가지 모두 나중에 자세히 다루겠습니다.&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 id=&quot;const-vs-let&quot;&gt;&lt;code&gt;const&lt;/code&gt; vs &lt;code&gt;let&lt;/code&gt;&lt;/h5&gt;&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const&quot;&gt;&lt;code&gt;const&lt;/code&gt;&lt;/a&gt; 와 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt; 은 ES6 (&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-let-and-const-declarations&quot;&gt;spec&lt;/a&gt;) 에서 지원하는 변수를 정의하는 새로운 표현입니다. &lt;code&gt;const&lt;/code&gt;는 참조 변경이 불가능한 변수를 생성하고 (read-only reference), &lt;code&gt;let&lt;/code&gt;은 참조 변경이 가능한 변수를(mutable reference) 생성합니다. 둘 다 &lt;a href=&quot;http://www.2ality.com/2015/02/es6-scoping.html&quot;&gt;블럭단위 스코프&lt;/a&gt; 입니다. 기존에 사용하던 &lt;code&gt;var&lt;/code&gt;는 글로벌 혹은 함수단위 스코프 입니다.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Enact  에서는, &lt;strong&gt;&lt;code&gt;const&lt;/code&gt;&lt;/strong&gt; 를 &lt;strong&gt;default&lt;/strong&gt;로 사용하고, reference를 변경할 필요가 있을 경우에만 &lt;code&gt;let&lt;/code&gt;을 사용하기를 권장합니다.&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;  const App = function () {&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이 예제에서 앱 컴포넌트를 reder 하는 함수를 참조하는 &lt;code&gt;const&lt;/code&gt; &lt;code&gt;App&lt;/code&gt;을 정의하고 있습니다.&lt;/p&gt;&lt;h5 id=&quot;컴포넌트-구성하기&quot;&gt;컴포넌트 구성하기&lt;/h5&gt;&lt;p&gt;React 에서 모든 컴포넌트의 &lt;a href=&quot;https://facebook.github.io/react/docs/component-specs.html#render&quot;&gt;render method&lt;/a&gt;는 단독 루트 엘리먼트나 &lt;code&gt;null&lt;/code&gt;을 리턴해야 합니다. (React 16 이후부터는 단독 엘리먼트가 아니어도 됩니다. 상위에 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;로 감싸는 귀찮은 짓을 더이상 안해도 됩니다. &lt;a href=&quot;https://reactjs.org/blog/2017/09/26/react-v16.0.html&quot;&gt;상세내용&lt;/a&gt;)&lt;br&gt;루트 엘리먼트는 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;와 같은 DOM 노드 이거나 커스텀 컴포넌트 이어야 합니다(곧 우리가 만들 겁니다).  루트 엘리먼트는 DOM 노드나 커스컴 컴포넌트외에도 문자열이나 숫자를 포함할 수 있습니다.&lt;/p&gt;&lt;p&gt;우리의 Hello, Enact! 앱은 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;를 루트 엘리먼트로 하고 하위에 &lt;code&gt;Hello, Enact!&lt;/code&gt; 문자열을 갖습니다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;  return (&lt;br /&gt;   &amp;lt;div&amp;gt;&lt;br /&gt;    Hello, Enact!&lt;br /&gt;   &amp;lt;/div&amp;gt;&lt;br /&gt;  );&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;return 문 안에 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;가 들어감 으로써 더이상 유효한 자바스크립트 문법이 아님을 발견하였을 겁니다. 이 HTML처럼 생긴 문장은 React 에서 제안하는 자바스크립트 구문 확장인 &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-in-depth.html&quot;&gt;JSX&lt;/a&gt;입니다. 브라우저에서 JSX를 실행 가능하게 만들려면 자바스크립트로 변환을 해야 합니다. Enact 에서는 &lt;a href=&quot;http://webpack.github.io&quot;&gt;webpack&lt;/a&gt; 과 &lt;a href=&quot;http://babeljs.io&quot;&gt;babel&lt;/a&gt;을 사용하여 빌드 프로세스 중에 처리를 합니다.&lt;/p&gt;&lt;h4 id=&quot;app-내보내기&quot;&gt;App 내보내기&lt;/h4&gt;&lt;p&gt;이제 우리의 컴포넌트를 정의 했으므로, 마지막 단계는 이것을 모듈로 내보내서 사용할 수 있도록 하는 것 입니다. 이것은 ES6 모듈 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-exports&quot;&gt;스펙&lt;/a&gt;의 새로운 기능인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export&quot;&gt;&lt;code&gt;export&lt;/code&gt;&lt;/a&gt; 명령문을 사용하여 수행됩니다. default export, 명명된 export 혹은 둘 다로 export 할 수 있습니다.&lt;/p&gt;&lt;p&gt;대부분의 경우, 각 모듈은 default export 대상이 될 단일 컴포넌트를 포함합니다. 추가 컴포넌트, 함수, 상수등을 export 할 수도 있습니다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt; export default App;&lt;br /&gt; export {App};&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;명명된 export에 대한 추가사항&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Enact 프레임워크 내에서 default export는 CommonJS 사용자와의 호환성을 위해 명명된 export 도 포함합니다. 만약, default export 만 있으면, &lt;code&gt;require()&lt;/code&gt;를 사용하는 개발자는 아래와 같은 약간 어색한 구문을 써야 합니다.&lt;/p&gt;&lt;p&gt;&lt;code&gt;var App = require(&#39;./src/App&#39;).default&lt;/code&gt;&lt;/p&gt;&lt;p&gt;명명된 export를 포함하면, 보다 직관적인 구문을 사용할 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;code&gt;var App = require(&#39;./src/App&#39;).App&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;app-렌더링&quot;&gt;App 렌더링&lt;/h2&gt;&lt;p&gt;App 컴포넌트가 준비가 되면 DOM에 렌더링할 수 있습니다. 렌더링 로직은 앱의 시작점인 &lt;code&gt;./src/index.js&lt;/code&gt;에 존재합니다. 전체 코드는 다음과 같습니다.&lt;/p&gt;&lt;h3 id=&quot;srcindex.js&quot;&gt;./src/index.js&lt;/h3&gt;&lt;pre&gt;&lt;code&gt; import React from &#39;react&#39;;&lt;br /&gt; import {render} from &#39;react-dom&#39;;&lt;br /&gt; &lt;br /&gt; import App from &#39;./App&#39;;&lt;br /&gt; &lt;br /&gt; let appElement = (&amp;lt;App /&amp;gt;);&lt;br /&gt; &lt;br /&gt; // In a browser environment, render instead of exporting&lt;br /&gt; if (typeof window !== &#39;undefined&#39;) {&lt;br /&gt;  render(&lt;br /&gt;   appElement,&lt;br /&gt;   document.getElementById(&#39;root&#39;) // provided by Enact&#39;s HTML template&lt;br /&gt;  );&lt;br /&gt; }&lt;br /&gt; &lt;br /&gt; export default appElement;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;dev 툴에서 생성해 주는 &lt;code&gt;index.js&lt;/code&gt;는 &lt;code&gt;App&lt;/code&gt; 컴포넌트를 DOM에 렌더링 하거나, 다른 컴포넌트에서 import 할 수 있게 합니다.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;react-와-reactdom&quot;&gt;React 와 ReactDOM&lt;/h3&gt;&lt;p&gt;우리의 App 모듈에서는 React import와 함께 새로운 모듈인 &lt;code&gt;react-dom&lt;/code&gt;을 import 하고 있습니다. &lt;a href=&quot;https://facebook.github.io/react/docs/top-level-api.html#reactdom&quot;&gt;ReactDOM&lt;/a&gt;은 React 컴포넌트 트리를 DOM트리로 변환해 줍니다. 대부분 &lt;a href=&quot;https://facebook.github.io/react/docs/top-level-api.html#reactdom.render&quot;&gt;&lt;code&gt;render()&lt;/code&gt; method&lt;/a&gt;를 사용합니다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt; import React from &#39;react&#39;;&lt;br /&gt; import {render} from &#39;react-dom&#39;;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;중괄호로 감싸진 &lt;code&gt;{render}&lt;/code&gt;는 &lt;code&gt;react-dom&lt;/code&gt;에서 명명된 내보내기를 import 하는데 사용됩니다. 또는 모듈 전체를 ReactDOM으로 가져와서 그 객체의 render()를 호출함으로써 동일한 결과를 가져올 수 있습니다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt; import ReactDOM from &#39;react-dom&#39;;&lt;br /&gt; ReactDOM.render( ... );&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;우리가-만든-app-import-하기&quot;&gt;우리가 만든 App import 하기&lt;/h3&gt;&lt;p&gt;다음으로, 우리가 만든 App 모듈을 가져오겠습니다. 외부 모듈과 구분하기 위하여 내부 모듈은 상대 경로(&lt;code&gt;&#39;./App&#39;&lt;/code&gt;)를 사용합니다. 앱의 &lt;code&gt;package.json&lt;/code&gt;에 정의한 내용을 기반으로 하여 소스파일 전체 경로 대신에 디렉토리 이름을 사용할 수도 있습니다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;   import App from &#39;./App&#39;;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;render&quot;&gt;render()&lt;/h3&gt;&lt;p&gt;마지막으로, &lt;code&gt;render()&lt;/code&gt;를 사용하여 우리의 App을 렌더링 합니다. 이 함수는 React 엘리먼트와 렌더링할 DOM을 파라미터로 받습니다. 우리는 JSX를 다시 사용하여 App 컴포넌트를 위한 React 엘리먼트를 만들고, &lt;code&gt;getElementById&lt;/code&gt;함수를 사용하여 DOM node를 반환합니다.&lt;br&gt;Enact 가 빌드하는 동안 기본 HTML파일을 생성합니다.  body에는 &lt;code&gt;&amp;lt;div id=&quot;root&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt; 문장이 포함될 것입니다. 우리의 앱은 여기에 렌더링 될 것 입니다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt; render(&lt;br /&gt;  &amp;lt;App /&amp;gt;,&lt;br /&gt;  document.getElementById(&#39;root&#39;)&lt;br /&gt; );&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;처음 접해보는 분은 우리가 HTML을  엘리먼트에 작성하는 것 처럼 보일 수 있습니다. 사실 그게 정확히 우리가 한 일입니다. JSX는 마크업에 삽입할 수 있는 HTML 엘리먼트처럼 우리의 App 컴포넌트를 취급합니다.&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;app-실행하기&quot;&gt;App 실행하기&lt;/h2&gt;&lt;p&gt;Enact는 여러가지 &lt;code&gt;npm&lt;/code&gt;스크립트를 제공하여 앱 작업을 쉽게 처리하도록 도와줍니다.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;npm run pack&lt;/code&gt; -  &lt;code&gt;./dist&lt;/code&gt; 디렉토리에 앱코드를 번들링 합니다.&lt;/li&gt;&lt;li&gt;&lt;code&gt;npm run pack-p&lt;/code&gt; - &lt;code&gt;./dist&lt;/code&gt; 디렉토리에 앱코드를 미니파이하고 소스맵 없이 번들링 합니다.&lt;/li&gt;&lt;li&gt;&lt;code&gt;npm run serve&lt;/code&gt; - 앱을 메모리에 번들링 하고 8080포트에서 http 서버를 시작합니다. 그 위에 번들링된 앱을 실행해 줍니다. 소스 파일이 변경 될 때마다 자동으로 다시 빌드되고 브라우저는 새로 고침됩니다. (&lt;a href=&quot;https://webpack.js.org/guides/development/#using-webpack-dev-server&quot;&gt;webpack-dev-server&lt;/a&gt;를 사용합니다).&lt;/li&gt;&lt;li&gt;&lt;code&gt;npm run clean&lt;/code&gt; - &lt;code&gt;./dist&lt;/code&gt; 와 그 내용을 지웁니다.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;지금까지 잘 따라오셨다면, &lt;code&gt;npm run serve&lt;/code&gt; 명령이 정상적으로 실행 되어야 합니다. 나머지 가이드를 진행하면서 새로운 변경사항을 저장할 때 마다 앱이 다시 로드 되는것을 볼 수 있습니다.&lt;/p&gt;&lt;h2 id=&quot;끝&quot;&gt;끝!&lt;/h2&gt;&lt;p&gt;긴 글 읽고 따라와 주시느라 수고하셨습니다! 이제 우리는 보일러 플레이트 Enact App을 구축했고, &lt;code&gt;npm run serve&lt;/code&gt; 명령을 사용하여 실행했습니다. 다음 시간에는 CSS모듈을 사용하여 스타일을 추가하는 방법을 알아 보겠습니다. Hello Enact!의 전체 코드는 아래 링크를 참조하세요.&lt;/p&gt;&lt;h2 id=&quot;링크&quot;&gt;링크&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Enact 공식 홈페이지: &lt;a href=&quot;http://enactjs.com&quot;&gt;http://enactjs.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Enact 소스코드: &lt;a href=&quot;https://github.com/enactjs/enact&quot;&gt;https://github.com/enactjs/enact&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Hello Enact 전체 코드: &lt;a href=&quot;https://github.com/enactjs/samples/tree/master/tutorial-hello-enact&quot;&gt;https://github.com/enactjs/samples/tree/master/tutorial-hello-enact&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Enact 문의를 위한 Gitter: &lt;a href=&quot;https://gitter.im/EnactJS/Lobby&quot;&gt;https://gitter.im/EnactJS/Lobby&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/article&gt;</content><link rel='replies' type='application/atom+xml' href='https://devwaf.blogspot.com/feeds/5316574568707905295/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://devwaf.blogspot.com/2018/04/hello-enact-1_98.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7695410439997503474/posts/default/5316574568707905295'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7695410439997503474/posts/default/5316574568707905295'/><link rel='alternate' type='text/html' href='https://devwaf.blogspot.com/2018/04/hello-enact-1_98.html' title='Hello Enact #1 - 기본'/><author><name>Seungho Park</name><uri>http://www.blogger.com/profile/16951750813615328804</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//2.bp.blogspot.com/-pHdFHG-1d1U/XLe3Xpve9CI/AAAAAAAAhWk/bLrV-WtYUHgYcXLnseFu56qKrIxhWKm2wCK4BGAYYCw/s220/IMG_6744_Profile.jpg'/></author><thr:total>0</thr:total><gd:extendedProperty name="commentSource" value="1"/><gd:extendedProperty name="commentModerationMode" value="FILTERED_POSTMOD"/></entry><entry><id>tag:blogger.com,1999:blog-7695410439997503474.post-545784610328371263</id><published>2018-03-30T15:19:00.002+09:00</published><updated>2018-04-12T21:28:36.463+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="App Framework"/><category scheme="http://www.blogger.com/atom/ns#" term="Enact"/><category scheme="http://www.blogger.com/atom/ns#" term="front-end"/><category scheme="http://www.blogger.com/atom/ns#" term="JavaScript"/><category scheme="http://www.blogger.com/atom/ns#" term="React"/><category scheme="http://www.blogger.com/atom/ns#" term="Tutorial"/><category scheme="http://www.blogger.com/atom/ns#" term="리액트"/><title type='text'>Enact 개발환경 설정</title><content type='html'>&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;article class=&quot;markdown-body&quot;&gt;&lt;h1 id=&quot;enact-개발환경-설정&quot;&gt;Enact 개발환경 설정&lt;/h1&gt;Enact는 App 개발을 편리하게 도와주는 커맨드라인툴(&lt;a href=&quot;https://www.npmjs.com/package/@enact/cli&quot;&gt;Enact CLI&lt;/a&gt;)을 제공합니다. 이번 포스팅에서는 CLI를 이용하여 개발환경을 설정하는 방법을 소개합니다.&lt;br /&gt; &lt;h2 id=&quot;사전-준비&quot;&gt;사전 준비&lt;/h2&gt;Enact 개발을 시작하기 앞서 몇 가지 software를 미리 설치해야 합니다. 가장 중요한 것은 &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node JavaScript runtime&lt;/a&gt; 버전 6.4 이상입니다. 터미널창에서 &lt;code&gt;node --version&lt;/code&gt; 명령으로 버전을 확인할 수 있습니다. 만약 설치되어 있지 않거나 예전버전이라면 위의 링크를 방문해서 설치해 주세요.&lt;br /&gt; &lt;h2 id=&quot;enact-cli-설치&quot;&gt;Enact CLI 설치&lt;/h2&gt;Enact CLI는 Enact 앱을 생성, 테스트, 패키지등을 할 수 있도록 명령어를 제공합니다. &lt;code&gt;npm&lt;/code&gt; 을 사용하여 설치할 수 있습니다.&lt;br /&gt; &lt;pre&gt;&lt;code&gt;npm install -g @enact/cli&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;설치하고 나면 어디서든 &lt;code&gt;enact&lt;/code&gt; 명령어를 실행할 수 있습니다. &lt;code&gt;enact -v&lt;/code&gt; 명령을 통해 잘 설치되었는지 확인해 보세요.&lt;br /&gt; &lt;blockquote&gt;enact 전체 명령어에 대한 자세한 내용에 대해서는 다음을 참고하시기 바랍니다. &lt;a href=&quot;https://github.com/enactjs/cli/blob/master/README.md&quot;&gt;package README&lt;/a&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;enact-app-구조&quot;&gt;Enact App 구조&lt;/h2&gt;새로운 앱을 생성하는데 사용하는 &lt;code&gt;enact create [&amp;lt;directory&amp;gt;]&lt;/code&gt; 명령입니다. &lt;code&gt;[&amp;lt;directory&amp;gt;]&lt;/code&gt; 는 옵션이며 기본값은 현재 디렉토리 입니다. &lt;code&gt;create&lt;/code&gt;  명령은 기본 디렉토리 구조와 앱 환경을 설정합니다.&lt;br /&gt; &lt;h3 id=&quot;디렉토리-구조&quot;&gt;디렉토리 구조&lt;/h3&gt;앱 디렉토리는 다음을 포함합니다:&lt;br /&gt; &lt;ul&gt;&lt;li&gt;&lt;code&gt;README.md&lt;/code&gt; 앱을 생성하고 빌드하는데 필요한 유용한 팁들이 있습니다.&lt;/li&gt;&lt;li&gt;&lt;code&gt;package.json&lt;/code&gt; 앱을 정의하는 파일입니다. react 앱에서 사용하는 package.json과 동일할 목적을 갖고 있습니다.&lt;/li&gt;&lt;li&gt;&lt;code&gt;node_modules&lt;/code&gt;  외부 node module을 모두 포함하는 디렉토리 입니다. (&lt;code&gt;@enact/core&lt;/code&gt;, &lt;code&gt;react&lt;/code&gt; 등)&lt;/li&gt;&lt;li&gt;&lt;code&gt;resources&lt;/code&gt; localization 파일을 포함하는 디렉토리 입니다.&lt;/li&gt;&lt;li&gt;&lt;code&gt;src&lt;/code&gt; 여러분이 개발하는 모든 소스코드를 포함하는 디렉토리 입니다. JS파일과 CSS/LESS 파일을 포함합니다.&lt;/li&gt;&lt;li&gt;&lt;code&gt;webos-meta&lt;/code&gt; webOS 디바이스에 deploy 하는데 필요한 파일을 포함합니다.&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt; App&lt;br /&gt; ├── README.md&lt;br /&gt; ├── package.json&lt;br /&gt; ├── resources&lt;br /&gt; │   └── ilibmanifest.json&lt;br /&gt; ├── src&lt;br /&gt; │   ├── App&lt;br /&gt; │   │   ├── App.js&lt;br /&gt; │   │   ├── App.less&lt;br /&gt; │   │   └── package.json&lt;br /&gt; │   ├── components&lt;br /&gt; │   │   └── README.md&lt;br /&gt; │   ├── index.js&lt;br /&gt; │   ├── iso.js&lt;br /&gt; │   └── views&lt;br /&gt; │       ├── MainPanel.js&lt;br /&gt; │       └── README.md&lt;br /&gt; └── webos-meta&lt;br /&gt;     ├── appinfo.json&lt;br /&gt;     ├── icon-large.png&lt;br /&gt;     ├── icon-mini.png&lt;br /&gt;     └── icon.png&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;앱을 패키징 하게 되면 &lt;code&gt;dist&lt;/code&gt; 디렉토리가 추가로 생성되고, 이 안에 deploy를 위한 파일들이 위치하게 됩니다. 나중에 &lt;code&gt;enact pack&lt;/code&gt; 명령에서 자세히 다루겠습니다.&lt;br /&gt; &lt;h3 id=&quot;앱-환경설정&quot;&gt;앱 환경설정&lt;/h3&gt;&lt;code&gt;package.jaon&lt;/code&gt; 파일에서 앱 환경을 설정합니다. 여기서는 자주 사용되는 필드에 대해서만 설명하겠습니다.&lt;br /&gt; &lt;ul&gt;&lt;li&gt;&lt;code&gt;&quot;name&quot;&lt;/code&gt;, &lt;code&gt;&quot;version&quot;&lt;/code&gt;, &lt;code&gt;&quot;description&quot;&lt;/code&gt;, &lt;code&gt;&quot;author&quot;&lt;/code&gt;, &lt;code&gt;&quot;license&quot;&lt;/code&gt; - Application meta-data. 앱의 상세 정보를 담고 있습니다. 이 항목들은 앱 빌드에 영향을 주지 않습니다.&lt;/li&gt;&lt;li&gt;&lt;code&gt;&quot;enact&quot;&lt;/code&gt; - The Enact-specific configuration block. Moonstone 앱을 위한 값을  default로 담고 있습니다. 빌드 시 생성되는 &lt;code&gt;index.html&lt;/code&gt; 파일에 앱 타이틀을 포함하고 싶으면, &lt;code&gt;&quot;title&quot;&lt;/code&gt; 필드를 추가 하여야 합니다.&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;package.json&lt;/strong&gt;&lt;br /&gt; &lt;pre&gt;&lt;code&gt;{&lt;br /&gt;    &quot;name&quot;: &quot;App&quot;,&lt;br /&gt;    &quot;version&quot;: &quot;1.0.0&quot;,&lt;br /&gt;    &quot;description&quot;: &quot;A general template for an Enact Moonstone application.&quot;,&lt;br /&gt;    &quot;author&quot;: &quot;&quot;,&lt;br /&gt;    &quot;main&quot;: &quot;src/index.js&quot;,&lt;br /&gt;    &quot;scripts&quot;: { [omitted] },&lt;br /&gt;    &quot;license&quot;: &quot;UNLICENSED&quot;,&lt;br /&gt;    &quot;private&quot;: true, &lt;br /&gt;    &quot;repository&quot;: &quot;&quot;,&lt;br /&gt;    &quot;enact&quot;: {&lt;br /&gt;        &quot;isomorphic&quot;: &quot;src/iso.js&quot;,&lt;br /&gt;        &quot;ri&quot;: {&lt;br /&gt;            &quot;baseSize&quot;: 24&lt;br /&gt;        }&lt;br /&gt;    },&lt;br /&gt;    &quot;eslintConfig&quot;: {&lt;br /&gt;        &quot;extends&quot;: &quot;enact&quot;&lt;br /&gt;    },&lt;br /&gt;    &quot;dependencies&quot;: { [omitted] }&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;예고&quot;&gt;예고&lt;/h2&gt;자, 이제 앱을 만들기 위한 기본 준비가 끝났습니다. 다음시간에는 Hello Enact 를 직접 만들고 빌드해 보도록 하겠습니다.&lt;br /&gt; &lt;/article&gt;&lt;article class=&quot;markdown-body&quot;&gt;&lt;br /&gt;&lt;/article&gt;&lt;article class=&quot;markdown-body&quot;&gt;&lt;h2 id=&quot;링크&quot;&gt;링크&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Enact 공식 홈페이지:&amp;nbsp;&lt;a href=&quot;http://enactjs.com/&quot;&gt;http://enactjs.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Enact 소스코드:&amp;nbsp;&lt;a href=&quot;https://github.com/enactjs/enact&quot;&gt;https://github.com/enactjs/enact&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Enact Gitter:&amp;nbsp;&lt;a href=&quot;https://gitter.im/EnactJS/Lobby&quot;&gt;https://gitter.im/EnactJS/Lobby&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/article&gt;</content><link rel='replies' type='application/atom+xml' href='https://devwaf.blogspot.com/feeds/545784610328371263/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://devwaf.blogspot.com/2018/03/enact-20180329_30.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7695410439997503474/posts/default/545784610328371263'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7695410439997503474/posts/default/545784610328371263'/><link rel='alternate' type='text/html' href='https://devwaf.blogspot.com/2018/03/enact-20180329_30.html' title='Enact 개발환경 설정'/><author><name>Seungho Park</name><uri>http://www.blogger.com/profile/16951750813615328804</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//2.bp.blogspot.com/-pHdFHG-1d1U/XLe3Xpve9CI/AAAAAAAAhWk/bLrV-WtYUHgYcXLnseFu56qKrIxhWKm2wCK4BGAYYCw/s220/IMG_6744_Profile.jpg'/></author><thr:total>0</thr:total><gd:extendedProperty name="commentSource" value="1"/><gd:extendedProperty name="commentModerationMode" value="FILTERED_POSTMOD"/></entry><entry><id>tag:blogger.com,1999:blog-7695410439997503474.post-431124354005035025</id><published>2018-03-19T15:18:00.002+09:00</published><updated>2018-03-21T09:48:13.727+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="App Framework"/><category scheme="http://www.blogger.com/atom/ns#" term="Enact"/><category scheme="http://www.blogger.com/atom/ns#" term="front-end"/><category scheme="http://www.blogger.com/atom/ns#" term="JavaScript"/><category scheme="http://www.blogger.com/atom/ns#" term="React"/><category scheme="http://www.blogger.com/atom/ns#" term="web"/><title type='text'>Enact 프레임워크를 오픈합니다.</title><content type='html'>&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;article class=&quot;markdown-body&quot;&gt; &lt;h1 id=&quot;enact-프레임워크를-오픈합니다&quot;&gt;Enact 프레임워크를 오픈합니다&lt;/h1&gt;&lt;blockquote&gt;An app development framework built atop React that’s easy to use, performant and customizable.&lt;/blockquote&gt;Enact(인액트)는 palm 과 webOS 의 프레임워크인 &lt;a href=&quot;http://enyojs.com/&quot;&gt;Enyo&lt;/a&gt;를 전신으로 하는 새로운 웹앱 프레임워크의 이름입니다. 컴포넌트화, Virtual DOM, Package Management등 Web Front-end 개발을 위한 최신 트랜드를 적용하기 위하여 &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt;를 렌더링 라이브러리로 도입하였으며, 새로운 구조에서 모든 컴포넌트를 새로 개발하였습니다. 1년여간 webOS TV 를 통해 검증을 거치고 드디어 오픈을 하게되어 매우 기쁩니다. (webOS 4.0의 일부앱은 이미 Enact로 개발이 되었습니다)&lt;br /&gt;&lt;h2 id=&quot;목표&quot;&gt;목표&lt;/h2&gt;Enact의 목표는 견고하고 유지 보수가 쉬운 App을 작성하기 위한 기본요소를 제공하는 것입니다. 이를 위해 focus management, 국제화(i18n), Accessibiltiy(a11y), linting, test 및 빌드를 위한 최상의 솔루션을 모았습니다. 이를 재사용 가능한 컴포넌트로 구성하여 제공합니다. Enact는 이러한 컴포넌트를 cli 툴을 통해 매끄럽게 결합하여 개발자가 구현에 집중할 수 있도록 합니다.&lt;br /&gt;&lt;h2 id=&quot;주요기능&quot;&gt;주요기능&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Focus Management: 4방향키 포커스 관리&lt;/li&gt;&lt;li&gt;Multi-resolution 지원&lt;/li&gt;&lt;li&gt;Internationalization: 다국어, 데이터포멧, RTL등&lt;/li&gt;&lt;li&gt;UI 컴포넌트(moonstone):&amp;nbsp;&lt;a href=&quot;http://enactjs.com/sampler&quot;&gt;Storybook&lt;/a&gt; 참고&lt;/li&gt;&lt;ul&gt;&lt;li&gt;Virtuallize된 List와 Grid 컴포넌트를 지원합니다.&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;Accessibility: 컴포넌트 레벨에 &lt;code&gt;aria&lt;/code&gt; property와 &lt;code&gt;role&lt;/code&gt; 적용&lt;/li&gt;&lt;li&gt;CLI Tool: Enact Application 생성, 빌드, 실행, 테스트등을 지원하며 Webpack, Babel, LESS, karma등을 사용합니다. npm 모듈로 제공되며 설치는 다음과 같이 입력하면 됩니다.&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt; npm install -g @enact/cli&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;링크&quot;&gt;링크&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Enact 공식 홈페이지: &lt;a href=&quot;http://enactjs.com/&quot;&gt;http://enactjs.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Enact 소스코드: &lt;a href=&quot;https://github.com/enactjs/enact&quot;&gt;https://github.com/enactjs/enact&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;article class=&quot;markdown-body&quot;&gt;&lt;br /&gt;&lt;/article&gt; 아파치2.0 입니다. 마음껏 많이 사용해 주세요 ^^ &lt;/article&gt;</content><link rel='replies' type='application/atom+xml' href='https://devwaf.blogspot.com/feeds/431124354005035025/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://devwaf.blogspot.com/2018/03/enact-20180319.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7695410439997503474/posts/default/431124354005035025'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7695410439997503474/posts/default/431124354005035025'/><link rel='alternate' type='text/html' href='https://devwaf.blogspot.com/2018/03/enact-20180319.html' title='Enact 프레임워크를 오픈합니다.'/><author><name>Seungho Park</name><uri>http://www.blogger.com/profile/16951750813615328804</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//2.bp.blogspot.com/-pHdFHG-1d1U/XLe3Xpve9CI/AAAAAAAAhWk/bLrV-WtYUHgYcXLnseFu56qKrIxhWKm2wCK4BGAYYCw/s220/IMG_6744_Profile.jpg'/></author><thr:total>0</thr:total><gd:extendedProperty name="commentSource" value="1"/><gd:extendedProperty name="commentModerationMode" value="FILTERED_POSTMOD"/></entry></feed>