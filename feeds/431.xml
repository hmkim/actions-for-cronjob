<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="https://novemberde.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://novemberde.github.io/" rel="alternate" type="text/html" /><updated>2019-04-14T10:47:55+00:00</updated><id>https://novemberde.github.io/feed.xml</id><title type="html">KH BYUN</title><subtitle>Developer khbyun's dev log</subtitle><author><name>Novemberde</name></author><entry><title type="html">Native addon을 포함하여 Node.js + Typescript + Serverless 빌드 및 배포하기</title><link href="https://novemberde.github.io/aws/2019/02/14/Ts-Serverless-Build.html" rel="alternate" type="text/html" title="Native addon을 포함하여 Node.js + Typescript + Serverless 빌드 및 배포하기" /><published>2019-02-14T00:00:00+00:00</published><updated>2019-02-14T00:00:00+00:00</updated><id>https://novemberde.github.io/aws/2019/02/14/Ts-Serverless-Build</id><content type="html" xml:base="https://novemberde.github.io/aws/2019/02/14/Ts-Serverless-Build.html">&lt;p&gt;AWSKRUG Serverless Group에서 발표한 자료입니다.
C++로 빌드한 Native addon을 Serverless 환경에서 사용할 때 빌드 및 배포하는 방법을 다루었습니다.&lt;/p&gt;

&lt;h2 id=&quot;발표자료&quot;&gt;발표자료&lt;/h2&gt;

&lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/key/A5nT0LwxOtDw5T&quot; width=&quot;595&quot; height=&quot;485&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt;
&lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;//www.slideshare.net/KyuhyunByun1/native-addon-nodejs-typescript-serverless&quot; title=&quot;Native addon을 포함하여 Node.js + Typescript + Serverless 빌드 및 배포하기&quot; target=&quot;_blank&quot;&gt;Native addon을 포함하여 Node.js + Typescript + Serverless 빌드 및 배포하기&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&quot;https://www.slideshare.net/KyuhyunByun1&quot; target=&quot;_blank&quot;&gt;Kyuhyun Byun&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/KyuhyunByun1/native-addon-nodejs-typescript-serverless&quot;&gt;https://www.slideshare.net/KyuhyunByun1/native-addon-nodejs-typescript-serverless&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Novemberde</name></author><category term="aws" /><category term="aws," /><category term="serverless," /><category term="서버리스," /><category term="typescript," /><category term="nodejs," /><category term="build," /><category term="deployment," /><category term="배포," /><category term="nativce," /><category term="addon" /><summary type="html">AWSKRUG Serverless Group에서 발표한 자료입니다. C++로 빌드한 Native addon을 Serverless 환경에서 사용할 때 빌드 및 배포하는 방법을 다루었습니다.</summary></entry><entry><title type="html">Amazon Timestream 시계열 데이터 전용 DB 소개</title><link href="https://novemberde.github.io/aws/2019/01/25/Timestream.html" rel="alternate" type="text/html" title="Amazon Timestream 시계열 데이터 전용 DB 소개" /><published>2019-01-25T00:00:00+00:00</published><updated>2019-01-25T00:00:00+00:00</updated><id>https://novemberde.github.io/aws/2019/01/25/Timestream</id><content type="html" xml:base="https://novemberde.github.io/aws/2019/01/25/Timestream.html">&lt;p&gt;“시계열 데이터 전용 DB 소개”라는 주제로 2019년 1월 25일에 &lt;a href=&quot;https://pages.awscloud.com/aws-community-day-seoul-2019.html&quot;&gt;AWSKRUG re:Invent recap 행사&lt;/a&gt;에서 발표한 자료입니다.&lt;/p&gt;

&lt;h2 id=&quot;발표자료&quot;&gt;발표자료&lt;/h2&gt;

&lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/key/F7GmlRSZZCQkKA&quot; width=&quot;595&quot; height=&quot;485&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt;
&lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;//www.slideshare.net/awskr/amazon-timestream-db&quot; title=&quot;Amazon Timestream 시계열 데이터 전용 DB 소개 :: 변규현 - AWS Community Day 2019&quot; target=&quot;_blank&quot;&gt;Amazon Timestream 시계열 데이터 전용 DB 소개 :: 변규현 - AWS Community Day 2019&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&quot;https://www.slideshare.net/awskr&quot; target=&quot;_blank&quot;&gt;AWS Korea UserGroup (AWS한국사용자모임)&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/awskr/amazon-timestream-db&quot;&gt;https://www.slideshare.net/awskr/amazon-timestream-db&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pages.awscloud.com/aws-community-day-seoul-2019.html&quot;&gt;https://pages.awscloud.com/aws-community-day-seoul-2019.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Novemberde</name></author><category term="aws" /><category term="aws," /><category term="timestream," /><category term="타임스트림," /><category term="amazon," /><category term="시계열," /><category term="데이터," /><category term="timeseries" /><summary type="html">“시계열 데이터 전용 DB 소개”라는 주제로 2019년 1월 25일에 AWSKRUG re:Invent recap 행사에서 발표한 자료입니다.</summary></entry><entry><title type="html">2017년부터 2018년까지의 회고</title><link href="https://novemberde.github.io/general/2019/01/01/Retrospect.html" rel="alternate" type="text/html" title="2017년부터 2018년까지의 회고" /><published>2019-01-01T00:00:00+00:00</published><updated>2019-01-01T00:00:00+00:00</updated><id>https://novemberde.github.io/general/2019/01/01/Retrospect</id><content type="html" xml:base="https://novemberde.github.io/general/2019/01/01/Retrospect.html">&lt;p&gt;2017부터 2018년에 대해서 회고를 남기려고 한다.
어느때보다 치열하고 열심히 달려온 한해였다.
다음은 한해동한 진행했던 일들의 대한 목록은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AWSKRUG&lt;/li&gt;
  &lt;li&gt;회사&lt;/li&gt;
  &lt;li&gt;강의 활동
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;awskrug&quot;&gt;AWSKRUG&lt;/h2&gt;

&lt;p&gt;개발자 커리어에서 가장 크게 영향력을 준 모임이다.
AWSKRUG는 Amazon Web Service Korea User Group의 약자로 AWS 한국 사용자 그룹이라고도 불린다.
이 모임에 처음으로 참여하게된 것은 2017년 4월 쯤이었다. 지난 2년여간 데이터 사이언스 그룹을 시작으로 거의 모든 모임에
참석하였다. AWSKRUG 통해 많은 것을 배울 수 있었다.&lt;/p&gt;

&lt;h3 id=&quot;시작하게-된-계기&quot;&gt;시작하게 된 계기&lt;/h3&gt;

&lt;p&gt;이전의 회사에서도 많은 개발을 맡아서 진행했는데 대표적으로 DevOps, Front-end 그리고 Back-end였다.
그냥 풀스택 개발자였다. 솔직히 풀스택은 말도 안된다고 생각을 했었는데 깊이에 대해서
어느정도 포기하면 풀스택 개발자로 될 수가 있었다.&lt;/p&gt;

&lt;p&gt;AWS를 통해 서비스가 돌아가게 설정한다.
Jenkins를 통해 자동으로 배포하는 스크립트를 짠다.
React 튜토리얼을 기반으로 연습하고 이를 프로덕션에 적용한다.
백엔드는 Spring과 Node.js를 비교하여 개발 속도를 확인해보고 Node.js를 선택한다.
그리고 제품을 만든다.
이 모든과정을 2017년에 진행했었다. 튜토리얼에 의존하였다. 이런 상황에서 
여태까지 사용했던 것들이 내부적으로 어떻게 동작하는지
이해가 부족하였다. AWS와 Docker에 대해서 어느정도 사용할 줄은 알았지만
DevOps의 대한 실전 테크닉이 부족하였다. 사내에서 성장을 하기 위해
문서와 블로그에 의존했다. 이 상황에서 같은 공부를 하는 누군가와 토론을 하고 싶었다.
Use Case들을 공유하며 새로운 방법들을 찾고 싶었다.
그런 상태로 2017 AWS Summit에 참가하였고 새로운 세상이 열렸다.&lt;/p&gt;

&lt;p&gt;커뮤니티는 새로운 세상이었다. 이전에 “나는 프로그래머다”를 가끔 들었는데, 이때 Summit의 현장에서
정도현님을 처음 만났다. 도현님이 AWSKRUG라는 모임에 대해서 설명해주었다.
누구나 참여할 수 있다고 하였다.
이때부터 모임을 시작하였다. 커뮤니티는 회사와 달리 기술에 대한 공부가 주목적이기 때문에
시간을 내어 저녁에 참여하기만 하면 되었다.
그렇게 데이터 사이언스 모임을 시작했다.
새로운 지식에 목말라 있었기 때문에, 퇴근 후 모든 모임에 참석하였다.
처음 접해보는 지식들을 흡수하기 위해 노력했다.&lt;/p&gt;

&lt;p&gt;가장 빠르게 기술을 습득하는 방법을 실제로 서비스를 사용해보는 것이다.
업무에 적용할 수 있으면 바로 테스트해보았고, 만약 업무와 상관이 없다면
발표하겠다고 먼저 말했다. 그 다음 틈나는대로 공부하고 실제로 데모를 만들면서
모르는 것에 대해서 공부하는 재미를 들였다.
이 뿐만 아니라, 워크샵이 예정되어 있다면 도우미로 참여하여 워크샵 이전에
여러번 실습을 진행했다. 그리고 당일에 한번 더 데모 시에 발생하는 문제들을 
해결하며 기술들에 대한 디테일에 대해서 공부하였다.&lt;/p&gt;

&lt;h3 id=&quot;aws-reinvent-2017&quot;&gt;AWS re:Invent 2017&lt;/h3&gt;

&lt;p&gt;이런 공부들을 발판 삼아, 2017년 AWS re:Invent 행사에 참가했다.
이때 처음으로 해외 행사에 참여해보았는데 개발을 바라보는 시선이 바뀐 계기였다.
또한 스스로 크게 성장할 수 있었다. 그 당시까지 AWS에서 나온 서비스들에 대해
그 자체만으로도 엄청난 기술이라고 생각하고 있었다. 그런데 re:Invent에서는
현재를 뛰어넘는 서비스 및 기능들이 발표되었다. 또한, netflix와 같이 대규모 
트래픽을 받는 회사의 개발자가 직접 경험을 공유하고, 실제로 AWS의 서비스를 만드는
개발자들이 직접 Q&amp;amp;A를 해주는 모습을 보았다. 이들은 개발할 때 고려한 점들, 그리고
앞으로의 진행 방향에 대해서 정확한 내용을 이해하고 구체적으로 설명해주었다.
굉장히 인상적이었다.&lt;/p&gt;

&lt;p&gt;이뿐만아니라 같이 참석한 개발자 분들에게도 많이 배울 수 있었다.
매일 저녁마다 그날 들었던 세션에 대해서 공유하고, 현재 아키텍처의
문제점 및 나아갈 방향에 대해서 토론하였다.
눈을 떠있는 시간은 거의 모두 개발에 대해서 이야기를 나누었다.
작은 부분 하나하나 이해하기 위해 밤 늦게까지 토론했던 것은 잊지못할 추억이다.&lt;/p&gt;

&lt;h3 id=&quot;서버리스-모임&quot;&gt;서버리스 모임&lt;/h3&gt;

&lt;p&gt;리인벤트를 계기로 서버리스에 대한 관심이 급증하였다. 이전까지만 해도 컨테이너가 세상을 바꿀 것이라
생각했지만 서버리스는 컨테이너 이상으로 업무를 줄여주는 내용이었다.
한국에 오자마자 모든 서비스를 AWS Lambda로 적용하였다. 그리고 사용자의 갑작스런
증가에 대비하여 대규모 아키텍처를 적용하였다.&lt;/p&gt;

&lt;p&gt;마침 2018년부터 AWSKRUG에서는 새로운 모임을 계획하고 있었다. 컨테이너 모임과 서버리스 모임이었다.
원래는 컨테이너 모임을 맡을지도 모르는 상태였다. 하지만 그 당시에 운영하는 모든 서비스가 이미
서버리스였기 서버리스 모임의 운영진이 되기로 결정하였다.&lt;/p&gt;

&lt;p&gt;서버리스 모임을 운영하는 방법은 간단했다. 발표자 한두 명, 모임 공간, 그리고 간단한 간식 준비였다.
모임을 하기전에 참가비는 5000원으로 받고 행사 준비만 하면 되었다. 귀찮지만 어렵지 않은 일이었다.
운영진이어서 좋은 점은 발표주제를 들어보고 미리 주제에 대해서 고민할 수 있는 점이었다.&lt;/p&gt;

&lt;p&gt;서버리스 모임에서는 주로 서버없이 Lambda, Glue 등의 서비스를 사용해서
운영의 리소스를 줄인 내용을 다뤘다. 각 발표자들마다 경험은 특별했고, 이에 대한
발표를 듣기위해 꾸준히 사람들이 참석했다. 한분 한분 소중한 경험을 공유해주었다.&lt;/p&gt;

&lt;p&gt;모든 발표 내용은 &lt;a href=&quot;https://github.com/awskrug/serverless-group&quot;&gt;여기&lt;/a&gt;에 정리해두었다.&lt;/p&gt;

&lt;h3 id=&quot;2018년-9회의-핸즈온&quot;&gt;2018년 9회의 핸즈온&lt;/h3&gt;

&lt;p&gt;AWSKRUG 모임에서 가장 많은 일을 맡아주시는 류한진님이 핸즈온을 계획했다.
처음에 얘기했을 때는 4회에서 6회 정도로 진행할 계획이었다.
하지만 점점 핸즈온을 진행하면서 괜찮은 주제와 진행자 분들이 생겨서
마지막까지 총 9회로 핸즈온을 마쳤다.
여름에 시작해서 초겨울까지 거의 매달 진행했다.
금, 토 일정을 모두 비워가며 진행했는데, 이 또한 성장하는데 많은 도움을 주었다.
컨테이너, 서버리스, 그리고 데이터 사이언스까지 거의 모든 장르를 아우렀다.
모두 좋은 내용이었다. 해당 내용은 &lt;a href=&quot;https://github.com/awskrug/handson-labs-2018&quot;&gt;여기&lt;/a&gt;를 참고 바란다.&lt;/p&gt;

&lt;p&gt;그중 내가 맡았던 핸즈온은 서버리스 핸즈온이었다. Todo앱과 크롤러 핸즈온을 준비했다.
이때 준비했던 자료는 현재 E-Book으로 출판 대기중이다.&lt;/p&gt;

&lt;h3 id=&quot;aws-reinvent-2018&quot;&gt;AWS re:Invent 2018&lt;/h3&gt;

&lt;p&gt;2017년에 이어 리인벤트에 참가했다. 이때 목표는 2017년과 달리 Workshop과 301/401 세션 위주로 들었다.
지난 1년간의 경험으로 어지간한 AWS 서비스를 써보았다. 하지만 각 서비스의 내용에 대해서 Deep Dive할 기회가 필요했다.
2017년과 반복된 세션은 이미 유튜브에 있기 때문에 새로운 관점에 대한 내용과 여태 다루지 않았던 내용을 위주로 세션을 들었다.&lt;/p&gt;

&lt;p&gt;가장 기억에 남는 것이라고 하면 GitOps였는데 상세 내용은 &lt;a href=&quot;https://www.youtube.com/watch?v=HCCkVz25UU4&quot;&gt;여기&lt;/a&gt;를 참고하길 바란다.
간단하게 Pull-request에 의한 운영방식이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/retrospect/Microsoft.png&quot; alt=&quot;Microsoft&quot; /&gt;&lt;/p&gt;

&lt;p&gt;리인벤트 이전에 시애틀에 들려 Microsoft 캠퍼스와 AWS 캠퍼스를 견학했다.
Microsoft에서 인상깊었던 점은 혼자서 코드를 작성하는 모습보다 여럿이서
모니터에 코드를 띄워놓고 토론하던 모습들이 많이 보였던 것이다.
그리고 Microsoft는 점심식사를 사먹어야했다. 사티아 나델리를 생각하며 카레를 먹고 싶었다.
하지만 인도음식은 없었기 때문에 몽골리안 음식을 먹고 무료로 먹을 수 있는 음료수를 열심히 마시며 다녔다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/retrospect/Spheres.png&quot; alt=&quot;AWS Spheres&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AWS 캠퍼스는 내부를 돌아보지는 않고 Spheres를 둘러보고 식당에서 식사를 했다.
AWS에서 근무하시는 안재우님이 가이드해주셨다.
Spheres는 식물원같은 느낌이었다.
돈이 많은 회사면 건물앞에 식물원도 그냥 지을 수 있다고 생각했다.
식당의 밥은 쉬는날이라 그런지 맛이없었다. 그런데 비쌌다. 한국이 이런면에서는 일하기 좋을지도 모른다.&lt;/p&gt;

&lt;p&gt;리인벤트 기간중에 재밌는 일이 있었다. CloudFront/API Gateway/Lambda를 아우르는 내용이었다.
리인벤트를 기준으로 한달 이전에는 신규서비스의 기반이되는 기능들이 추가되곤 한다.
이번에는 CloudFront의 웹소켓 지원이었다. 이걸보고 바로 API Gateway에 웹소켓이 붙을 수 있다는
생각이 들었고, 그렇다면 Lambda를 통해 웹소켓 어플리케이션을 운영할 수 있을 것이라 생각했다.
이에 대해 AWSKRUG Facebook에서 갑론을박이 있었지만 결과는 나와봐야 알 수 있었다.
리인벤트 마지막 날에 API Gateway 웹소켓 기능이 생긴 것을 확인할 수 있었고, Lambda에서
커넥션을 관리하는 데이터베이스를 통해 웹소켓을 구현한다고 문서도 공개됐다.
이것 때문에 리인벤트 첫날에 윤석찬님을 괴롭혔다. 일찍 라스베가스에 도착해서 둘이 얘기를 나누다가 Cloudfront만 웹소켓이 되면 람다도 분명히 웹소켓이 가능할거라
생각한다고 말했다. 그런데 해당 내용을 확인해보시겠다고 하면서 중간에 식사하러 가셨다.
이날 피곤했는지라 기다리다가 뻗었는데 이날 적잖이 당황했다고 말씀하셨다.&lt;/p&gt;

&lt;p&gt;*1월 7일 추가 내용&lt;/p&gt;

&lt;p&gt;API Gateway를 직접 만드시는 분에 의하면 Cloudfront의
웹소켓 지원과 API Gateway의 웹소켓 지원은 관련이 없다고 한다.
웹소켓을 Cloudfront는 전역적으로 지원하는 것과 달리, API Gateway는 
Regional endpoint에서만 지원이 된다고 한다.
위의 잘못된 내용으로 오해하는 분들이 없길 바란다.&lt;/p&gt;

&lt;h2 id=&quot;회사&quot;&gt;회사&lt;/h2&gt;

&lt;p&gt;개인적으로 회사일로 인해 크게 성장할 수 있었다.
현재 회사에서 주로 했던 일은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;서버리스 아키텍처의 적용&lt;/li&gt;
  &lt;li&gt;MongoDB 걷어내기&lt;/li&gt;
  &lt;li&gt;인증서버 걷어내고 Firebase 적용&lt;/li&gt;
  &lt;li&gt;RDS MySQL에서 Aurora MySQL로 Migration&lt;/li&gt;
  &lt;li&gt;Typescript 도입&lt;/li&gt;
  &lt;li&gt;TIPS 준비&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;서버리스-아키텍처의-적용&quot;&gt;서버리스 아키텍처의 적용&lt;/h3&gt;

&lt;p&gt;서버리스 아키텍처를 적용하는 것은 솔직히 쉽지 않았다.
먼저 Lambda의 모든 옵션을 알아야만 했다. 그리고 Redis를 사용하기 위해
VPC에 대해서 더욱 자세히 알아야만 했다. 또한 VPC에서 외부 인터넷에 접근하기 위해
NAT를 두면서 네트워크 지식을 넓혀갈 수 있었다.&lt;/p&gt;

&lt;p&gt;또한 기존 서버에서 운영하는 방식과 서버리스에서 운영하는 것의 차이점을
명확히 이해해야했다. API 응답을 한 후에 백그라운드에서 동작하는 로직을 수정했다.&lt;/p&gt;

&lt;p&gt;콜드스타트를 줄이기 위한 방법들도 많이 생각했다.&lt;/p&gt;

&lt;p&gt;이 부분에 대한 내용은 서버리스 그룹에서 주로 다룬다.&lt;/p&gt;

&lt;p&gt;관련 발표내용은 &lt;a href=&quot;https://www.slideshare.net/KyuhyunByun1/albec2-to-api-gateway-lambda&quot;&gt;여기&lt;/a&gt;을 참고 바란다.&lt;/p&gt;

&lt;h3 id=&quot;mongodb-걷어내기&quot;&gt;MongoDB 걷어내기&lt;/h3&gt;

&lt;p&gt;몽고디비는 관리형 서비스를 올리고 싶으면 Atlas를 사용하는게 최선이다. 아니면 직접 운영하는 방법밖에 없다.
직접 운영하기 위해 Sharded Cluster를 올려보았는데 생각보다 고된 작업이었다.
Config, Router, Replica set 등 서버를 한두대로 운영할 수 없었다. 처음부터 비용이 많이 나왔다.
설정하는 것도 몽고디비의 버전마다 차이가 있었기 때문에 Config 파일 관리하는 것도 귀찮았다.
저장하는 데이터들을 확인하고 걷어내기로 결심했다.&lt;/p&gt;

&lt;p&gt;기존에 MongoDB를 Token 및 통계데이터 저장소로 사용했다.
Token은 Firebase로 모두 이관했다. 또한, 통계 데이터는 RDB에 저장하고
몽고디비를 걷어내었다.&lt;/p&gt;

&lt;h3 id=&quot;인증서버-걷어내고-firebase-적용&quot;&gt;인증서버 걷어내고 Firebase 적용&lt;/h3&gt;

&lt;p&gt;Firebase를 적용하고 처음엔 좋았다. 굳이 Access Token들을 관리하지 않아도 되니 편했다.
그런데 서비스가 갑자기 성장함에 따라 구글 인증 API의 Limit에 걸려 서비스가 마비되었다.
이때 두번다시 Firebase를 사용하지 않겠다고 다짐했다. 내부적으로 Firebase와 구글 관련 기능은 인증 API를
호출하는데 이것 때문에 하루 할당량 한계를 넘었다. 토큰을 클라이언트 캐싱하고, 서버에서도 별도의 캐싱을 통해
인증 API로의 호출을 최소화하였지만 급작스런 사용자 증가로 인해 “Limit Quotas”를 초과하여 결국엔 장애가 발생했다.&lt;/p&gt;

&lt;p&gt;여기서 더욱 문제였던 점은 구글의 지원을 받는데 많은 시간이 소요됐던 점이다.
두달전부터 예상하고 Limit increase를 몇번이나 요청했지만 묵묵부답.
그리고 Firebase에서 가장 많은 Support를 받는 Blaze요금제였음에도 불구하고
Support를 통해 답변은 한참뒤에 받을 수 있었다.
답변이 왔다고 할지라도 할당량은 증가해주지 않고 모든 모니터링 내역부터
증빙자료를 요청하는 핑퐁만 하루에 메일 한번씩하였고, 문제는 해결되지 않아
총 4일동안 장애에 대해서 속수무책이었다.
결국 구글의 서비스에 대해서 재검토해보겠다는 메일 발송 후에 이틀 후에 답변을 받았다. 결국 할당량을 5배로 늘려주었다.&lt;/p&gt;

&lt;p&gt;구글의 서비스 정신을 엿볼 수 있는 경험이었다.&lt;/p&gt;

&lt;h3 id=&quot;rds-mysql에서-aurora-mysql로-migration&quot;&gt;RDS MySQL에서 Aurora MySQL로 Migration&lt;/h3&gt;

&lt;p&gt;Aurora에서 MySQL 5.7 버전 지원하는 것을 보고 바로 이전 완료하였다.
일단 프로시저같은 것들을 사용하지 않기 때문에 백서를 기준으로
어렵지 않게 마이그레이션을 할 수 있었다.&lt;/p&gt;

&lt;h3 id=&quot;typescript-도입&quot;&gt;Typescript 도입&lt;/h3&gt;

&lt;p&gt;이웅재님의 강의를 한 번 듣고 Node.js를 컴파일 언어처럼 사용해보고 싶어서
시험삼아 관리자 사이트를 모두 Typescript로 전환하였다.&lt;/p&gt;

&lt;p&gt;Typescript 덕분에 Lambda의 환경이 Node 6.10이었음에도 불구하고
Async/Await를 적용할 수 있었다.&lt;/p&gt;

&lt;p&gt;Webpack을 사용해서 기존 서버 코드를 1~3MB로 줄였는데, Lambda의 50MB의
코드 크기 제한에 많은 여유를 가져다주었다.&lt;/p&gt;

&lt;h3 id=&quot;jquery-good-bye-welcome-vuejs&quot;&gt;jQuery Good bye, welcome vue.js&lt;/h3&gt;

&lt;p&gt;기존 Legacy들은 jQuery로 되어 있었다. 여기서 데이터 바인딩이 복잡한 부분들은
모두 vue.js를 통해 재구현 하였다.&lt;/p&gt;

&lt;h3 id=&quot;tips-준비&quot;&gt;TIPS 준비&lt;/h3&gt;

&lt;p&gt;TIPS는 Tech Incubator Program for startup Korea의 약자로 스타트업을 위한
정부지원금 중 큰 금액의 프로그램이었다. 결국엔 떨어졌지만 과정속에서 많은 부분을 배울 수 있었다.
빅뱅엔젤스의 황병선 대표님과 최광선 이사님의 조언은 사업적, 기술적 관점에 대한 성장을
가져다주었다. 논문을 읽어보고 기술에 대해서 점점 깊이 빠져들때 묘한 기분이 들기도 했다.
거의 두달 간 기술의 진행방향에 대해서 몰입하며 지냈었다. 부족함을 알 수 있었고,
성장할 방향에 대해서 다시금 확인할 수 있는 경험이었다.&lt;/p&gt;

&lt;h3 id=&quot;채용&quot;&gt;채용&lt;/h3&gt;

&lt;p&gt;채용은 개발자에게 가장 힘든 일 중에 하나다. 개발만 하는 것과 같이 함께할 동료를
선택하는 것은 완전히 다른 일이기 때문이다. 안드로이드 개발자를 채용하기 위해 최소한
가이드가 되어줄 수 있는 실력을 갖추어야만 했고, 채용할 사람이 나에게 함께 일하고 싶은
선택을 내릴 수 있도록 해야했다.&lt;/p&gt;

&lt;p&gt;적절할 질문을 하고, 어떤 답변인지 고심을 해보고, 어떻게 성장할 수 있는 사람인지 상상해보고,
이 모든 것에 대한 이유를 명확히 내리는 과정을 여러번 반복했다.
4개월이 지나서야 좋은 분을 채용할 수 있었다.
함께 개발하는 즐거움을 다시금 느끼고 있다.&lt;/p&gt;

&lt;h2 id=&quot;강의-활동&quot;&gt;강의 활동&lt;/h2&gt;

&lt;p&gt;핸즈온 뿐만 아니라 개인적으로 별도의 강의도 진행했다.
양재동 코드랩의 조덕기님의 권유로 2017년 Docker강의를 시작으로 2018년에도 4회의 강의를 진행했다.&lt;/p&gt;

&lt;p&gt;2017년에는 도커 2회, 2018년에는 서버리스 강의 2회, 도커 1회, 그리고 AWS 기초 1회를 진행했다.
개인적으로는 마지막 도커 강의에 아쉬움이 남는다. 이직한 후로 도커를 이전처럼 계속 사용할 일이 줄어들었기 때문에
수강자들에게 최신의 정보를 공유해주지 못했던 것으로 기억한다.
쿠버네티스를 강의자료에 넣었지만 설명을 정확하게 하지못하고 적절한 예제가 없어서 아쉬움이 남는다.&lt;/p&gt;

&lt;p&gt;AWS 기초에 대한 강의는 12월에 진행했는데, 이전 3회의 강의에서 생각보다 초심자가 많았기 때문이었다.
예제 서비스를 실제로 배포하고 운영하는 것이 항상 마지막 단계였다. 이 과정에서 AWS를 사용했는데,
대부분의 수강자들은 AWS 계정조차 없는 경우가 많았다. 사전에 공지를 했음에도 불구하고 많은 수가 계정이 없었다.
또한 클라우드에 대한 개념을 버거워했기 때문에,
A-Z라는 생각으로 계정생성부터 서버 운영 및 설정까지 강의를 진행했다.&lt;/p&gt;

&lt;p&gt;강의는 개인적으로 공부했던 자료를 정리하는 좋은 계기가 되었다.&lt;/p&gt;

&lt;h3 id=&quot;부산-밋업&quot;&gt;부산 밋업&lt;/h3&gt;

&lt;p&gt;주민규님의 제안으로 부산에서도 강의를 진행했다. 참석자는 많지 않았다. 30명 내외정도였다.
이때는 커뮤니티때 &lt;a href=&quot;https://www.slideshare.net/KyuhyunByun1/0-121022533&quot;&gt;포털 검색어 순위에 대한 분석&lt;/a&gt;을 주제로 다루었다.
발표보다 개인적으로 여러 시니어 개발자 분들에게 많이 배웠다.
서울에서도 듣기 힘든 발표들을 먼 타지에서 열심히 들었다. 1박 2일동안 같이 다니면서
여태까지 개발했던 노하우, 그리고 개발자가 가져야할 덕목들, 업무를 진행할 때 가져야할 태도 등
강의 밖에서도 이야기를 나누면서 많은 도움을 받았다.&lt;/p&gt;

&lt;p&gt;언젠가 나도 이런 시니어가 되고 싶다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;회고는 개발자가 성장하기 위해서 필수적이라고 생각한다. 회고문을 남기는 것에 대한 강조가 아니다.
지난 생활에 대해서 반성을 해고 되짚어봐야한다는 얘기다.
지난 1년간 달려온 것들에 대해서 정리하는 것은 앞으로 나아갈 방향을 잡는데 많은 도움을 줄 것이라 생각한다.&lt;/p&gt;

&lt;p&gt;나는 개발 경력이 그렇게 오래되지 않았다.
고작 몇년이다.
그런데 돌이켜보면 정말 하루도 빠짐없이 공부했고 빠르게 성장했다고 생각한다.&lt;/p&gt;

&lt;p&gt;지하철에서는 개발 관련 블로그, 정식 문서, 그리고 유튜브에 있는 발표들을 본다.
관심있는 기술이 있으면 먼저 사용해보고 직접 올려본다. 그리고 지금까지 사용했던 기술과의 차이점에 대해서
생각해본다. AWSKRUG에서 다양한 개발자들과 관련주제에 대해서 질문을 던지고 여러 해답들을 듣는다.
잘 모르는 내용에 대한 컨퍼런스가 있으면 참가하고 지식의 폭을 넓힌다.
이런 생활의 반복이었다.&lt;/p&gt;

&lt;h3 id=&quot;다짐&quot;&gt;다짐&lt;/h3&gt;

&lt;p&gt;매번 성장하고 싶을 때마다 생각하는 것은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자신한테 모든게 달렸다.&lt;/li&gt;
  &lt;li&gt;하루도 빠짐없이 매일 반복하고 이해하기 위해 노력하면 어느새 성장해있다.&lt;/li&gt;
  &lt;li&gt;안하는 건 있어도 못하는 건 없다. 방법은 결국 찾아낼 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이런 생각을 바탕으로, 2019년에는 Low-level 및 Core 단을 이해하는 개발자가 될 것이다.
그리고 AI 및 아키텍처도. 계속 달려보자.&lt;/p&gt;</content><author><name>Novemberde</name></author><category term="general" /><category term="회고," /><category term="retrospect" /><summary type="html">2017부터 2018년에 대해서 회고를 남기려고 한다. 어느때보다 치열하고 열심히 달려온 한해였다. 다음은 한해동한 진행했던 일들의 대한 목록은 다음과 같다.</summary></entry><entry><title type="html">OWASP TOP 10</title><link href="https://novemberde.github.io/security/2018/11/02/OWASP.html" rel="alternate" type="text/html" title="OWASP TOP 10" /><published>2018-11-02T00:00:00+00:00</published><updated>2018-11-02T00:00:00+00:00</updated><id>https://novemberde.github.io/security/2018/11/02/OWASP</id><content type="html" xml:base="https://novemberde.github.io/security/2018/11/02/OWASP.html">&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;보안 취약점의 종류를 이해하고 정리한다.
보안은 개발속도를 늦추는 경우도 있지만 제품의 안정성과 신뢰성에 기여하기 때문에 필수적인 요소이다.
다음은 OWASP(The Open Web Application Security Project)의 년도별 TOP 10 취약점의 종류이다.&lt;/p&gt;

&lt;h2 id=&quot;2017&quot;&gt;2017&lt;/h2&gt;
&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Injection&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Broken Authentication&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Sensitivy Data Exposure&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XML External Entities(XXE)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Broken Access Control&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security Misconfiguration&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cross-Site Scripting(XXS)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Insecure Deserialization&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Using Component with Known Vulnerabilities&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Insufficient Logging &amp;amp; Monitoring&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2013&quot;&gt;2013&lt;/h2&gt;
&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Injection&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Broken Authentication and Session Management&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cross-Site Scripting&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Insecure Direct Object References&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security Misconfiguration&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Sensitive Data Exposure&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Missing Function Level Acess Control&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cross-Site Request Forgery(CSRF)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Using Component with Known Vulnerabilities&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Unvalidated Redirects and Forwards&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2010&quot;&gt;2010&lt;/h2&gt;
&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Injection&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cross-Site Scripting&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Broken Authentication and Session Management&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Insecure Direct Object References&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cross-Site Request Forgery(CSRF)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security Misconfiguration&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Insecure Cryptographic Storage&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Failure to Restrict URL Access&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Insufficient Transport Layer Protection&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Unvalidated Redirects and Forwards&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2007&quot;&gt;2007&lt;/h2&gt;
&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Cross Site Scripting (XSS)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Injection Flaws&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Malicious File Execution&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Insecure Direct Object Reference&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cross Site Request Forgery (CSRF)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Information Leakage and Improper Error Handling&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Broken Authentication and Session Management&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Insecure Cryptographic Storage&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Insecure Communications&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Failure to Restrict URL Access&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2004&quot;&gt;2004&lt;/h2&gt;
&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;Unvalidated Input&lt;/li&gt;
  &lt;li&gt;Broken Access Control&lt;/li&gt;
  &lt;li&gt;Broken Authentication and Session Management&lt;/li&gt;
  &lt;li&gt;Cross Site Scripting&lt;/li&gt;
  &lt;li&gt;Buffer Overflow&lt;/li&gt;
  &lt;li&gt;Injection Flaws&lt;/li&gt;
  &lt;li&gt;Improper Error Handling&lt;/li&gt;
  &lt;li&gt;Insecure Storage&lt;/li&gt;
  &lt;li&gt;Application Denial of Service&lt;/li&gt;
  &lt;li&gt;Insecure Configuration Management&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/OWASP&quot;&gt;https://ko.wikipedia.org/wiki/OWASP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Novemberde</name></author><category term="security" /><category term="security," /><category term="owasp" /><summary type="html">Summary 보안 취약점의 종류를 이해하고 정리한다. 보안은 개발속도를 늦추는 경우도 있지만 제품의 안정성과 신뢰성에 기여하기 때문에 필수적인 요소이다. 다음은 OWASP(The Open Web Application Security Project)의 년도별 TOP 10 취약점의 종류이다.</summary></entry><entry><title type="html">0원으로 시작하는 데이터 수집 및 분석</title><link href="https://novemberde.github.io/aws/2018/10/29/Potal-Analysis.html" rel="alternate" type="text/html" title="0원으로 시작하는 데이터 수집 및 분석" /><published>2018-10-29T00:00:00+00:00</published><updated>2018-10-29T00:00:00+00:00</updated><id>https://novemberde.github.io/aws/2018/10/29/Potal-Analysis</id><content type="html" xml:base="https://novemberde.github.io/aws/2018/10/29/Potal-Analysis.html">&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;https://www.onoffmix.com/event/155396&quot;&gt;부산 스마트 앱 개발자 포럼&lt;/a&gt;에서 서버리스를 활용하여 데이터를 수집 및 분석 후기를 공유하였다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/KyuhyunByun1/0-121022533&quot;&gt;발표자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/novemberde/serverless-crawler-demo&quot;&gt;Github repo.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;발표-슬라이드&quot;&gt;발표 슬라이드&lt;/h2&gt;
&lt;hr /&gt;

&lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/key/xrAl5GcoWdJ9pd&quot; width=&quot;595&quot; height=&quot;485&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt;
&lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;//www.slideshare.net/KyuhyunByun1/0-121022533&quot; title=&quot;0원으로 시작하는 서버리스 데이터 수집 및 분석&quot; target=&quot;_blank&quot;&gt;0원으로 시작하는 서버리스 데이터 수집 및 분석&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&quot;//www.slideshare.net/KyuhyunByun1&quot; target=&quot;_blank&quot;&gt;Kyuhyun Byun&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;

&lt;h2 id=&quot;고찰&quot;&gt;고찰&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;지난 여름부터 모아온 데이터를 분석하고 이 데이터를 기반으로 AWS의 데이터 처리 서비스들에 대해서 공부하는 계기였다.
실제로 현업에서 데이터를 분석할 일은 많다. 데이터를 쌓고 보기 쉽게 변환하는 과정 그리고 시각화까지 다양한 기술을 요구한다.
데이터를 다루는 역량 뿐만 아니라 전체적인 웹서비스 구축 역량을 요구한다.&lt;/p&gt;

&lt;p&gt;기본적인 시각화는 프론트엔드에 대한 역량, 데이터를 수집하고 서비스를 운영하는 것은 백엔드의 역량을 필요로 한다.
이러한 역량을 데이터사이언티스트가 모두 지니는 것은 쉽지 않다.
직접 플랫폼을 구축하고 각 데이터 분석 도구의 Configuration을 설정하는 것은 상당한 지식을 필요로 한다.
또한, 데이터 분석을 위한 클러스터를 직접 운영한다는 것은 고급 인력을 요구한다.&lt;/p&gt;

&lt;p&gt;그럼에도 불구하고 비지니스의 성장을 위해 데이터 분석을 해야한다면 관리형서비스를 적극적으로 사용해야한다.
하둡 클러스터를 띄우고 스키마를 정의하고 직접 운영하는 것보다는 AWS Glue에 카탈로그를 추가하고, 주기적인 작업을 
설정만 해두고 필요할 때 호출만 하는 것이 가장 좋을 것이다. 그리고 직접적으로 Serdes를 지정하고 데이터 스키마를 관리하는 것을
클라우드에 맡겨두고 비용은 Glue가 동작한 시간에 대해서만 지불하는 것이 낫다.&lt;/p&gt;

&lt;p&gt;QuickSight를 쓰면 직접 비주얼라이징 도구를 서버에 호스팅하지 않아도 되며,
Athena를 통해 사용하는 데이터 스캔 비용만 지불하면 상당히 적은 비용으로 데이터 분석 도구를 운영할 수 있다.&lt;/p&gt;</content><author><name>Novemberde</name></author><category term="aws" /><category term="aws," /><category term="serverless," /><category term="서버리스," /><category term="lambda," /><category term="glue," /><category term="quicksight," /><category term="athena," /><category term="analysis" /><summary type="html">Summary 부산 스마트 앱 개발자 포럼에서 서버리스를 활용하여 데이터를 수집 및 분석 후기를 공유하였다.</summary></entry><entry><title type="html">Circle CI에서 Docker Build 하기</title><link href="https://novemberde.github.io/docker/2018/09/17/Circleci-docker.html" rel="alternate" type="text/html" title="Circle CI에서 Docker Build 하기" /><published>2018-09-17T00:00:00+00:00</published><updated>2018-09-17T00:00:00+00:00</updated><id>https://novemberde.github.io/docker/2018/09/17/Circleci-docker</id><content type="html" xml:base="https://novemberde.github.io/docker/2018/09/17/Circleci-docker.html">&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;현재 Terraform으로 ECS 인프라를 생성하고, CircleCI에서 docker image를 빌드하고 ECR에 푸시하는 과정을 자동화하고 있다.
이 과정에 있어서 docker image를 빌드하는 것에서 문제가 발생했다.&lt;/p&gt;

&lt;p&gt;CircleCI에서 script를 실행하는 환경은 Container 기반으로 되어 있기 때문이다.
Docker image를 빌드하기 위해서는 docker가 설치되어 있는 환경이어야 했다.&lt;/p&gt;

&lt;p&gt;docker-in-docker라는 개념으로 docker hub에 “docker”라는 docker image가 있다.
하지만 이 이미지로는 프로덕션 이미지를 빌드하고 배포할 때 사용하는 기본 패키지가 없는데, 이러한 기본패키지를 추가하여
CircleCI에서 docker를 빌드할 수 있는 이미지 생성하는 방법 및 CircleCI 설정을 정리해보았다.&lt;/p&gt;

&lt;h2 id=&quot;dockerfile-작성하기&quot;&gt;Dockerfile 작성하기&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;Dockerfile 작성은 어렵지 않다.&lt;/p&gt;

&lt;p&gt;베이스 이미지로는 alpine linux 기반의 이미지를 사용한다. 또한 nodejs, npm, awscli, docker가 설치되어 있어야 한다.&lt;/p&gt;

&lt;p&gt;작성한 Dockerfile은 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-dockerfile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; docker:stable&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Install node&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;apk update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apk add &lt;span class=&quot;nt&quot;&gt;--update&lt;/span&gt; nodejs nodejs-npm

&lt;span class=&quot;c&quot;&gt;# Install build-essentials&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;apk add &lt;span class=&quot;nt&quot;&gt;--virtual&lt;/span&gt; build-dependencies build-base gcc wget git

&lt;span class=&quot;c&quot;&gt;# Install aws-cli&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;apk &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--update&lt;/span&gt; add &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;        python &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;        py-pip &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;        groff &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;        less &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;        mailcap &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;    pip install &lt;span class=&quot;nt&quot;&gt;--upgrade&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;awscli&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;1.14.5 &lt;span class=&quot;nv&quot;&gt;s3cmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;2.0.1 python-magic &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;    apk &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--purge&lt;/span&gt; del py-pip &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;    rm /var/cache/apk/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;ENTRYPOINT&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; []&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CMD&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; [&quot;sh&quot;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/novemberde/node-awscli/blob/master/docker/Dockerfile&quot;&gt;https://github.com/novemberde/node-awscli/blob/master/docker/Dockerfile&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;여기서 docker:stable은 alpine linux 기반으로 docker가 사전 설치된 이미지인데, docker 재단에서 공식적으로 제공한다.
“docker” image는 docker in docker를 사용하기 위한 환경을 제공한다.
그 다음, 차례대로 nodejs, npm, build-essentials, awscli 등을 설치한다.&lt;/p&gt;

&lt;p&gt;ENTRYPOINT는 docker:stable에서 Default로 docker-entrypoint.sh로 지정되어 있어 오류가 발생하기 때문에, 다시 재정의해주었다.&lt;/p&gt;

&lt;p&gt;이렇게 생성된 이미지는 현재 &lt;a href=&quot;https://hub.docker.com/r/novemberde/node-awscli/&quot;&gt;docker hub에 public&lt;/a&gt;으로 올렸다.
태그는 docker로 되어 있으며, 이미지는 다음과 같은 명령어로 받아올 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker pull novemberde/node-awscli:docker
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;circleci에서-설정하기&quot;&gt;CircleCI에서 설정하기&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;Docker가 설치되어 있는 docker image를 생성했으니 CircleCI에서 설정을 시작해보자.&lt;/p&gt;

&lt;p&gt;평소와 달라지는 부분은 ‘setup_remote_docker’ 부분이다.
이 설정을 추가하면 docker command에 대해서 격리된 새로운 환경에서 사용할 수 있게 해준다.&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;jobs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;docker&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;novemberde/node-awscli:docker&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;working_directory&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;~/repo&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;steps&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;checkout&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;### This configuration is enable to build a docker image.&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;setup_remote_docker&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;docker_layer_caching&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;###&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;docker build -t test ./&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;확인해보기&quot;&gt;확인해보기&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;CircleCI configuration을 마치고 git push를 하면 빌드가 시작된다.&lt;/p&gt;

&lt;p&gt;샘플 Dockerfile에 대해서 빌드한 결과는 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/circleci/docker-build.png&quot; alt=&quot;docker-build&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;고찰&quot;&gt;고찰&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;alpine linux를 사용하는 이유는 기타 리눅스 배포판과 기본 사이즈의 차이가 많이 나기 때문이다.
참고할 표는 다음과 같다. 적은 용량은 도커 이미지를 가져올 때의 네트워크 부하를 줄여주고,
이미지 생성 및 사용에 대해서도 속도를 향상시키는 효과를 가져올 수 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;DISTRIBUTION&lt;/th&gt;
      &lt;th&gt;VERSION&lt;/th&gt;
      &lt;th&gt;SIZE&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Debian&lt;/td&gt;
      &lt;td&gt;Jessie&lt;/td&gt;
      &lt;td&gt;123MB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CentOS&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;193MB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Fedora&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
      &lt;td&gt;231MB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ubuntu&lt;/td&gt;
      &lt;td&gt;16.04&lt;/td&gt;
      &lt;td&gt;118MB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alpine&lt;/td&gt;
      &lt;td&gt;3.6&lt;/td&gt;
      &lt;td&gt;3.98MB&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;참고자료: &lt;a href=&quot;https://nickjanetakis.com/blog/the-3-biggest-wins-when-using-alpine-as-a-base-docker-image&quot;&gt;https://nickjanetakis.com/blog/the-3-biggest-wins-when-using-alpine-as-a-base-docker-image&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;참고자료: &lt;a href=&quot;https://circleci.com/docs/2.0/building-docker-images/&quot;&gt;https://circleci.com/docs/2.0/building-docker-images/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Novemberde</name></author><category term="docker" /><category term="circleci," /><category term="docker," /><category term="build," /><category term="devops," /><category term="빌드," /><category term="도커" /><summary type="html">Summary 현재 Terraform으로 ECS 인프라를 생성하고, CircleCI에서 docker image를 빌드하고 ECR에 푸시하는 과정을 자동화하고 있다. 이 과정에 있어서 docker image를 빌드하는 것에서 문제가 발생했다.</summary></entry><entry><title type="html">2018년 AWS Serverless Hands-on 1, 손쉽게 시작하는 Serverless Architecture</title><link href="https://novemberde.github.io/aws/2018/07/02/Serverless-Handson-1.html" rel="alternate" type="text/html" title="2018년 AWS Serverless Hands-on 1, 손쉽게 시작하는 Serverless Architecture" /><published>2018-07-02T00:00:00+00:00</published><updated>2018-07-02T00:00:00+00:00</updated><id>https://novemberde.github.io/aws/2018/07/02/Serverless-Handson-1</id><content type="html" xml:base="https://novemberde.github.io/aws/2018/07/02/Serverless-Handson-1.html">&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/awskrug/handson-labs-2018&quot;&gt;2018년 AWSKRUG에서 8회에 걸쳐 진행하는 핸즈온&lt;/a&gt; 중 하나인 Serverless Hands-on 입니다&lt;/p&gt;

&lt;p&gt;제목: 손쉽게 시작하는 Serverless Architecture&lt;/p&gt;

&lt;p&gt;내용: Serverless Architecture는 말그대로 서버를 올리지 않는 아키텍처를 의미합니다. 기존에는 각 서버에 운영하는 어플리케이션들을 배포했지만, Serverless Architecture를 적용하면 운영 부담없이 비지니스 로직에만 집중할 수 있습니다. 서버없이 Web Application과 Crawler를 만들어 운영이 필요없는 데모 서비스를 구성합니다.&lt;/p&gt;

&lt;h2 id=&quot;serverless-group-first-hands-on-part-1&quot;&gt;Serverless Group First Hands-on Part 1&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;AWSKRUG Serverless Group의 첫번째 핸즈온 Part.1 웹어플리케이션 만들기입니다.😁&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/novemberde/serverless-todo-demo&quot;&gt;바로가기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;serverless-group-first-hands-on-part-2&quot;&gt;Serverless Group First Hands-on Part 2&lt;/h2&gt;

&lt;p&gt;AWSKRUG Serverless Group의 첫번째 핸즈온 Part.2 웹크롤러 만들기입니다.😁&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/novemberde/serverless-crawler-demo&quot;&gt;바로가기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.meetup.com/ko-KR/awskrug/events/251326459/&quot;&gt;https://www.meetup.com/ko-KR/awskrug/events/251326459/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/awskrug/handson-labs-2018&quot;&gt;https://github.com/awskrug/handson-labs-2018&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/novemberde/serverless-todo-demo&quot;&gt;https://github.com/novemberde/serverless-todo-demo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/novemberde/serverless-crawler-demo&quot;&gt;https://github.com/novemberde/serverless-crawler-demo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Novemberde</name></author><category term="aws" /><category term="aws," /><category term="serverless," /><category term="framework," /><category term="todo," /><category term="webapp," /><category term="handson" /><summary type="html">Summary 2018년 AWSKRUG에서 8회에 걸쳐 진행하는 핸즈온 중 하나인 Serverless Hands-on 입니다</summary></entry><entry><title type="html">AWS Configure 여러 계정으로 스위칭하며 사용하기</title><link href="https://novemberde.github.io/aws/2018/06/20/AWS-config-switching.html" rel="alternate" type="text/html" title="AWS Configure 여러 계정으로 스위칭하며 사용하기" /><published>2018-06-20T00:00:00+00:00</published><updated>2018-06-20T00:00:00+00:00</updated><id>https://novemberde.github.io/aws/2018/06/20/AWS-config-switching</id><content type="html" xml:base="https://novemberde.github.io/aws/2018/06/20/AWS-config-switching.html">&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;개인용 개발계정, 회사계정, 워크샵 전용 계정 등등 여러 계정들을 사용하다보니 Default로 Access Key ID 와 Secret Access Key를
관리하고 싶어졌다. Default로 두고 사용하다가 잘못하면 회사계정에 잘못된 인프라를 생성 및 변경할 수도 있기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;aws-configure-profile&quot;&gt;AWS Configure –profile&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;기본적인 aws cli를 설정하는 것은 어렵지 않다.
AWS Console의 IAM에서 유저를 생성하고 Access Key를 생성하면 된다.
생성된 키를 통해 로컬이 AWS의 권한을 사용하도록 설정하는 것은 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 생성된 키와 리전을 입력하면 된다.&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;aws configure
AWS Access Key ID &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;****************&lt;/span&gt;aaaa]:
AWS Secret Access Key &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;****************&lt;/span&gt;aaaa]:
Default region name &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ap-northeast-2]:
Default output format &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;json]:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그렇다면 여러 계정을 관리하려면 어떻게 해야할까?&lt;/p&gt;

&lt;p&gt;–profile 옵션을 사용하면 어렵지 않다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;aws configure &lt;span class=&quot;nt&quot;&gt;--profile&lt;/span&gt; testUser
AWS Access Key ID &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;****************&lt;/span&gt;aaaa]:
AWS Secret Access Key &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;****************&lt;/span&gt;aaaa]:
Default region name &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ap-northeast-2]:
Default output format &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;json]:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;새로운 유저의 Profile을 입력하였으니 명령어를 통해 리소스가 정말 다르게 나오는지 확인해본다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 생성한 버킷의 리스트가 출력된다.&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;aws s3 &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--profile&lt;/span&gt; testUser
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3-party도구를 사용하다보면 Default User를 피치못할 사정으로 사용하게 된다.
그런 상황에서는 Default User를 스위칭해가며 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 환경변수로 default profile을 등록하여 준다.&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;AWS_DEFAULT_PROFILE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;testUser

&lt;span class=&quot;c&quot;&gt;# 만일 윈도우 사용자라면 set을 사용한다.&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;AWS_DEFAULT_PROFILE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;testUser

&lt;span class=&quot;c&quot;&gt;# 방금 전에 --profile 옵션과 함께 출력됐던 버킷의 리스트가 출력된다.&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;aws s3 &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 현재 사용하고 있는 default profile user가 출력된다.&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;aws configure list
      Name                    Value             Type    Location
      &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt;                    &lt;span class=&quot;nt&quot;&gt;-----&lt;/span&gt;             &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt;    &lt;span class=&quot;nt&quot;&gt;--------&lt;/span&gt;
   profile                 testUser           manual    &lt;span class=&quot;nt&quot;&gt;--profile&lt;/span&gt;
access_key     &lt;span class=&quot;k&quot;&gt;****************&lt;/span&gt;aaaa shared-credentials-file
secret_key     &lt;span class=&quot;k&quot;&gt;****************&lt;/span&gt;aaaa shared-credentials-file
    region           ap-northeast-2      config-file    ~/.aws/config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 하면 당장은 되는 것처럼 보이지만 다른 Terminal을 열어서 해보면 되지 않는다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;aws s3 &lt;span class=&quot;nb&quot;&gt;ls
&lt;/span&gt;An error occurred &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;InvalidAccessKeyId&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; when calling the ListBuckets operation: The AWS Access Key Id you provided does not exist &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;our records.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;당황하지 말고 ~/.bashrc 또는 ~/.zshrc파일의 마지막 라인에
“export AWS_DEFAULT_PROFILE=testUser”를 추가한다.&lt;/p&gt;

&lt;h4 id=&quot;zshrc-또는-bashrc&quot;&gt;~/.zshrc 또는 ~/.bashrc&lt;/h4&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
...
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;AWS_DEFAULT_PROFILE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;testUser
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 재설정한다.&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; ~/.zshrc &lt;span class=&quot;c&quot;&gt;# 또는 source ~/.bashrc&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Default로 설정이 완료되었다.&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;aws s3 &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 변동 가능한 환경변수에 대한 설정정보를 bashrc에 넣는 것은 바람직해보이지 않는다.
귀찮더라도 이정도는 매번 손으로 설정하는 것이 위험 부담을 줄이는 길이라고 생각한다.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/cli/latest/reference/configure/list.html&quot;&gt;https://docs.aws.amazon.com/cli/latest/reference/configure/list.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Novemberde</name></author><category term="aws" /><category term="aws," /><category term="configure," /><category term="profile," /><category term="switching," /><category term="switch," /><category term="바꾸기" /><summary type="html">Summary 개인용 개발계정, 회사계정, 워크샵 전용 계정 등등 여러 계정들을 사용하다보니 Default로 Access Key ID 와 Secret Access Key를 관리하고 싶어졌다. Default로 두고 사용하다가 잘못하면 회사계정에 잘못된 인프라를 생성 및 변경할 수도 있기 때문이다.</summary></entry><entry><title type="html">Legacy android application, Kotlin 적용기</title><link href="https://novemberde.github.io/2018/05/28/kotlin.html" rel="alternate" type="text/html" title="Legacy android application, Kotlin 적용기" /><published>2018-05-28T00:00:00+00:00</published><updated>2018-05-28T00:00:00+00:00</updated><id>https://novemberde.github.io/2018/05/28/kotlin</id><content type="html" xml:base="https://novemberde.github.io/2018/05/28/kotlin.html">&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;안드로이드 개발 언어의 트렌드는 바뀌었다. 최근 Google I/O에서 나오는
샘플 코드들은 Kotlin으로 짜여져 있었다. 또한 안드로이드 개발 컨퍼런스의
주제는 Kotlin으로 개발한 경험담이 주를 이루고 있다.&lt;/p&gt;

&lt;p&gt;Kotlin으로 개발하는 것이 낫다는 내용을 많이 보기도 하였고 개발에 욕심이 있다보니,
이번에는 기존에 JAVA로 개발되어 있던 코드에 Kotlin을 적용하여 새로 구성하거나 변경하는
클래스를 Kotlin으로 구성해보았다.&lt;/p&gt;

&lt;p&gt;다음은 이런 과정을 거치면서 느낀 장점과 단점에 대한 고찰이다.&lt;/p&gt;

&lt;h2 id=&quot;고찰&quot;&gt;고찰&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;Kotlin의 장점을 느끼기 전에는 치명적인 단점(?)과 싸워야만 한다.&lt;/p&gt;

&lt;p&gt;무엇보다 가장 크게 힘들었던 점은 손에 익은 Java 대신에 인내하며 억지로 Kotlin으로 작성해야된다는 점이었다.
개발자가 새로운 기술을 받아들여야 할 때 나타나는 문제점이었다. 기존에 잘하는 것으로 개발하면 바로 끝낼 수 있지만
새로운 것을 받아들이면 공부하고 적용하는데까지 시간이 몇배로 들기 때문이다.
이런 경우에 기술을 받아들일지는 상황에 따라 결정하게 된다.
상급자의 명령에 따라 빠른 퍼포먼스를 보여줘야하는 경우에는 기존의 기술을 택한다.
반면에 중간중간에 공부를 해두어서 적용할 수 있는 단계가 된 경우이거나 
개발의 주체가 기술에 대한 욕심이 있고 새로운 것에 대해 무리없이 받아들이는 경우에는 새로운 기술을 택한다.
솔직히 후자라고 주장하고 싶지만 지난 몇번의 시도를 하였지만 다시 Java로 개발했었다.
편하게 살고싶은 마음을 이겨내는 것이 제일 힘들었다.&lt;/p&gt;

&lt;p&gt;이번에는 마음을 먹고 .kotlin으로 파일을 생성하여 .java는 생성하지도 않았다.
여러 언어를 접하면서, 공부하면 기본은 비슷하기 때문에 적응만 하면 배울 수 있다는 것을
깨달았기 때문이다.&lt;/p&gt;

&lt;p&gt;Kotlin을 적용하는 것은 만만하지 않았다.
Java에선 타입을 먼저 지정하고 그에 대한 private / public / protected와 같은 scope를 정하며, 객체를 통해
모든 데이터를 전달하고 Interface를 통해 메서드들을 정했었다.
여태까지 자연스러운 행위였다.&lt;/p&gt;

&lt;p&gt;Kotlin에서는 var / val를 통한 변수 선언만이 존재했다.
처음엔 익숙하지 않았다. 먼저 객체 타입을 지정하였던 이전과 비교하여 콜론 다음에 타입을 지정할 수 있었다.
게다가 콜론 다음에 타입을 지정하는 것은 필수가 아니었다. 어색했다.
하지만 이것을 이겨내는 방법은 간단하였다.
Kotlin이 이런 방식을 택한 이유에 대해 Java로 개발할 때보다 불편하게 만들기 위한 것이 아니라는 것만 생각하면 되었다.&lt;/p&gt;

&lt;p&gt;코틀린에서는 변수 선언과 동시에 값을 할당 할 때에는 타입을 지정할 필요가 없었다. 왜냐하면 바로 뒤에
해당 객체의 형을 볼 수 있기 때문이다. 만약 변수선언과 동시에 값을 할당하지 않는다면,
타입을 콜론한 다음에 지정해주면 된다.
예제는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;SOME STRING&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 할당된 값을 통해 간단히 타입을 추론할 수 있다.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 값이 할당되지 않을 때
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;변수 선언과 관련해서 바뀐점은 특별히 편하다는 생각은 많이 들지 않았다.
하지만 람다식이나 inner anonymous를 구현함에 있어서 코드를 아주 간결하게 표현할 수 있다.&lt;/p&gt;

&lt;p&gt;자바에서는 다음과 같이 표현했다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// RUN SOME CODES&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// OR&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// RUN SOME CODES&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이를 코틀린으로 작성하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// RUN SOME CODES
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;코드가 java보다 간결하게 표현된 것을 확인할 수 있다. 람다식으로 표현된 것보다도 간결해진다.
하지만 이것만으로는 간결해졌다고 볼 수 없다.&lt;/p&gt;

&lt;p&gt;무엇보다 Kotlin에서 가장 매력적으로 느꼈던 부분은 functional programming의 특징이다.
Java에서 Callback을 구현하기 위해서는 다음과 같은 프로세스로 진행해야한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;callback으로 사용할 메서드가 정의된 AInterface를 생성&lt;/li&gt;
  &lt;li&gt;Async하게 동작하는 AClass에서 AInterface를 parameter로 받는 aMethod 메서드 생성&lt;/li&gt;
  &lt;li&gt;aMethod를 호출하는 BClass에서 AInterface를 내부익명으로 새로 구현하던지 상속받아 this를 파라미터로 넘겨 실행
(물론 더 다양한 방법도 존재하지만 이게 흔한 방법이다.)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;글로 표현하기도 참 쉽지 않다. 헷갈린다. 하지만 Kotlin으로 작성하면 아주 간단하다.
파라미터를 함수로 받고 그것을 실행만 하면된다. 물론 이 함수는 별도로 정의되어 있는 인터페이스나 클래스가 아니다.
Javascript로 개발한 적이 있다면 이러한 Callback 기법이 편안하게 다가올 것이다.
상세하게 알고 싶다면 다음의 링크를 참고하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://kotlinlang.org/docs/reference/lambdas.html&quot;&gt;Higher-Order Functions and Lambdas&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위처럼 Kotlin에 적응하기 위한 일련의 과정을 거치니 점점 개발 퍼포먼스가 증가하였다.
Kotlin으로 작성하면 코드의 무게가 작아지는 것도 있고, 자잘한 Interface를
선언할 일도 줄어들었기 때문이다.
덕분에 순수하게 타자를 치는 시간도 줄었다.&lt;/p&gt;

&lt;p&gt;이렇게만 말하니 조금 안타깝지만 언어 선택이 개발에 있어서 엄청난 향상으로 나타나지 않는다는 것은 모두가 알 것이다.
웹서버 개발을 할 때에도 C, C#, PHP, JAVA, Go, Nodejs, Python 등등 다양한 방법이 있다.
그럼에도 불구하고, 우리가 최근에는 Go, Nodejs, C#, Python등으로 개발하는 이유가 있다.
C가 익은 사람이라도 이제는 C로 웹서버를 개발하지 않는다. 왜냐하면 지속적인 개발을 위한 퍼포먼스에서
크게 차이가 나타나기 때문이다. 비록 처음에는 배움에 대한 문턱이 있다 할지라도, 결국에는 유지보수의 단계에서
비용절감의 결과로 나타날 것이다.&lt;/p&gt;

&lt;p&gt;개발 속도에 문제가 생기지 않도록 유지가능한 코드를 위해 Kotlin을 적극 도입하기를 추천한다.&lt;/p&gt;</content><author><name>Novemberde</name></author><category term="java," /><category term="legacy," /><category term="kotlin," /><category term="android," /><category term="안드로이드," /><category term="자바," /><category term="코틀린," /><category term="공존" /><summary type="html">Summary 안드로이드 개발 언어의 트렌드는 바뀌었다. 최근 Google I/O에서 나오는 샘플 코드들은 Kotlin으로 짜여져 있었다. 또한 안드로이드 개발 컨퍼런스의 주제는 Kotlin으로 개발한 경험담이 주를 이루고 있다.</summary></entry><entry><title type="html">The difference among String, StringBuilder, and StringBuffer in JAVA</title><link href="https://novemberde.github.io/2018/05/24/String.html" rel="alternate" type="text/html" title="The difference among String, StringBuilder, and StringBuffer in JAVA" /><published>2018-05-24T00:00:00+00:00</published><updated>2018-05-24T00:00:00+00:00</updated><id>https://novemberde.github.io/2018/05/24/String</id><content type="html" xml:base="https://novemberde.github.io/2018/05/24/String.html">&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;If you’re a lazy JAVA developer, you concatenate Strings by using the plus sign (“Some text” + “ added text”)
 But if you want to level-up your skills as a JAVA developer, you should be more careful about the Class that you choose.
 Let’s take a glance at the use cases of String, StringBuilder and StringBuffer.&lt;/p&gt;

&lt;h2 id=&quot;feature-of-classes&quot;&gt;Feature of Classes&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;It’s necessary to be familiar with the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/&quot;&gt;Java API&lt;/a&gt; documents before getting your hands dirty.&lt;/p&gt;

&lt;p&gt;Let’s take a look at the java.lang package on &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/&quot;&gt;Java API&lt;/a&gt;. Java.lang package has a bundle of classes that does not require you to import them manually. It contains basic classes (‘WrapperClass’) like Boolean, Byte, and Integer.&lt;/p&gt;

&lt;p&gt;Among them, we are going to look into String, StringBuffer, and StringBuilder.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/java/string/java.lang.png&quot; alt=&quot;java.lang&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;String class is inherited from Serializable, CharSequence, Comparable&lt;String&gt; interfaces, and configured as 'public final class'.
In other words, String class is a sequence of characters, a comparable value, and is able to be serialized. Also, it cannot be used for the inherited class.&lt;/String&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/java/string/String.png&quot; alt=&quot;String&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;When you look up the use cases of String, you can easily find articles that suggest using StringBuffer or StringBuilder instead of String.&lt;/p&gt;

&lt;p&gt;Let’s find out why.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringValue1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;TEST 1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringValue2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;TEST 2&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stringValue1: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringValue1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stringValue2: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringValue2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;stringValue1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringValue1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringValue2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stringValue1: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringValue1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;StringBuffer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sb: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TEST StringBuffer&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sb: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;Results:&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;stringValue1:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1823841245&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;stringValue2:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1823841244&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;stringValue1:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;833872391&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;sb:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1956725890&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;sb:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1956725890&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;On the snippet above, a different reference value is created for each of the instances as a instance is created everytime a new value is assigned to the String. However, StringBuffer appends a string value on memory to concatenate and reuse the instance that was already created.
Logically, Class creates methods and variables on creating an instance, but StringBuffer does not allow this time delay on instance creation.&lt;/p&gt;

&lt;p&gt;On the above example, String instance is only created once, but if you concatenate several Strings, its instances stack on heap area of memory and it takes memories until JVM calls the Garbage Collector. This is a critical issue in managing memory of your application.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Hmm, why is String instance created every time calling ‘new’? Let’s look at the structure of String class.&lt;/p&gt;

&lt;p&gt;On the following image, you can see an array ‘value[]’ consist of character type. You should look carefully ‘value[]’ is ‘private final char’ type.&lt;/p&gt;

&lt;p&gt;A string value is saved as an array of characters, and this private array cannot be accessed from other classes. Also, ‘value[]’ is a final type, cannot be changed since initialized.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/java/string/String2.png&quot; alt=&quot;String2&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Let’s take a look at StringBuilder and StringBuffer that uses ‘append’ method for concatenation.&lt;/p&gt;

&lt;p&gt;On the following image, StringBuilder class is a mutable sequence of characters, but has no guarantee of syncronization.
StringBuffer can also by safely used in multi-thread environments. This is the main difference between StringBuilder and StringBuffer classes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/java/string/StringBuilder.png&quot; alt=&quot;StringBuilder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/java/string/StringBuffer.png&quot; alt=&quot;StringBuffer&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;On the following sample snippet, results show the difference between the two classes.
The result value of StringBuilder has a smaller value because multiple threads accessed a StringBuilder instance simultaneously.
However, StringBuffer is thread-safe unlike StringBuilder. The StringBuffer instance has a bigger and precise value
on multiple threads environment because StringBuffer supports synchronization.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;StringBuffer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringBuffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;StringBuilder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringBuilder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stringBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stringBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stringBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stringBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;StringBuffer.length: &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;StringBuilder.length: &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;Results:&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;StringBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;77780&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;StringBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;76412&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt;
&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/&quot;&gt;http://docs.oracle.com/javase/8/docs/api/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://javahungry.blogspot.com/2013/06/difference-between-string-stringbuilder.html&quot;&gt;http://javahungry.blogspot.com/2013/06/difference-between-string-stringbuilder.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Novemberde</name></author><category term="java," /><category term="string," /><category term="stringbuilder," /><category term="stringbuffer," /><category term="difference" /><summary type="html">Summary If you’re a lazy JAVA developer, you concatenate Strings by using the plus sign (“Some text” + “ added text”) But if you want to level-up your skills as a JAVA developer, you should be more careful about the Class that you choose. Let’s take a glance at the use cases of String, StringBuilder and StringBuffer.</summary></entry></feed>