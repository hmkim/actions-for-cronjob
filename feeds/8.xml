<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>01010011</title>
	<atom:link href="https://01010011.blog/feed/" rel="self" type="application/rss+xml" />
	<link>https://01010011.blog</link>
	<description></description>
	<lastBuildDate>
	Wed, 20 Mar 2019 19:32:44 +0000	</lastBuildDate>
	<language>ko-KR</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='01010011.blog' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://secure.gravatar.com/blavatar/68aaa1fd8d25b61c4777e5b01d388f8b?s=96&#038;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fbuttonw-com.png</url>
		<title>01010011</title>
		<link>https://01010011.blog</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://01010011.blog/osd.xml" title="01010011" />
	<atom:link rel='hub' href='https://01010011.blog/?pushpress=hub'/>
	<item>
		<title>도서 리뷰 &#8211; 알고리즘 산책: 수학에서 제네릭 프로그래밍까지</title>
		<link>https://01010011.blog/2018/08/29/%eb%8f%84%ec%84%9c-%eb%a6%ac%eb%b7%b0-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ec%82%b0%ec%b1%85-%ec%88%98%ed%95%99%ec%97%90%ec%84%9c-%ec%a0%9c%eb%84%a4%eb%a6%ad-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98/</link>
				<comments>https://01010011.blog/2018/08/29/%eb%8f%84%ec%84%9c-%eb%a6%ac%eb%b7%b0-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ec%82%b0%ec%b1%85-%ec%88%98%ed%95%99%ec%97%90%ec%84%9c-%ec%a0%9c%eb%84%a4%eb%a6%ad-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98/#respond</comments>
				<pubDate>Wed, 29 Aug 2018 07:18:09 +0000</pubDate>
		<dc:creator><![CDATA[bahamoth2013]]></dc:creator>
				<category><![CDATA[리뷰]]></category>

		<guid isPermaLink="false">http://01010011.blog/?p=1434</guid>
				<description><![CDATA[길벗 출판사 도서 소개 프로그래밍은 추상화(abstraction)의 연속이다. 데이터를 추상화하고 흐름을 추상화하고 모듈과 빌딩블록을 추상화하며 심지어는 서비스와 어플리케이션도 추상화한다. 헌데 추상화라는 단어만큼 추상적인 것도 없다. 누군가는 추상화라는 단어를 듣고 타입 추상화를 떠올릴 것이며 누군가는 자료구조나 객체를 떠올릴 것이다. 컴퓨터 과학에서 누군가가 추상화라는 단어를 사용한다면 이 단어가 다양한 계층에서 서로 다른 의미로 쓰인다는 것을 미리 알고 있어야 &#8230; <a href="https://01010011.blog/2018/08/29/%eb%8f%84%ec%84%9c-%eb%a6%ac%eb%b7%b0-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ec%82%b0%ec%b1%85-%ec%88%98%ed%95%99%ec%97%90%ec%84%9c-%ec%a0%9c%eb%84%a4%eb%a6%ad-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98/" class="more-link"><span class="screen-reader-text">도서 리뷰 &#8211; 알고리즘 산책: 수학에서 제네릭&#160;프로그래밍까지</span> 계속 읽기</a>]]></description>
								<content:encoded><![CDATA[<p><img class="irc_mi" src="https://i0.wp.com/image.aladin.co.kr/product/14796/61/cover/k492532258_1.jpg" alt="알고리즘 산책 수학에서 제네릭 프로그래밍까지에 대한 이미지 검색결과" width="200" height="295" /></p>
<p><a href="http://www.gilbut.co.kr/book/bookView.aspx?bookcode=BN002003&amp;page=1&amp;sernewbook=Y&amp;orderby=pdate&amp;TF=T" target="_blank" rel="noopener">길벗 출판사 도서 소개</a></p>
<p>프로그래밍은 추상화(abstraction)의 연속이다. 데이터를 추상화하고 흐름을 추상화하고 모듈과 빌딩블록을 추상화하며 심지어는 서비스와 어플리케이션도 추상화한다.</p>
<p>헌데 추상화라는 단어만큼 추상적인 것도 없다. 누군가는 추상화라는 단어를 듣고 타입 추상화를 떠올릴 것이며 누군가는 자료구조나 객체를 떠올릴 것이다. 컴퓨터 과학에서 누군가가 추상화라는 단어를 사용한다면 이 단어가 다양한 계층에서 서로 다른 의미로 쓰인다는 것을 미리 알고 있어야 이해에 도움이 될 것이다.</p>
<p>알고리즘 산책에서 다루는 추상화는 크게 두가지이다. 수학적 추상화와 제네릭 프로그래밍이다.  이 책은 제네릭 프로그래밍이 어떻게 데이터 타입을 추상화 하는지에 대하여 여러 수학적 사례를 들어 설명한다. 이를테면, 고대 이집트인들의 곱셈하는 방식으로부터 곱셈 알고리즘을 도출한 후 이를 점진적으로 개선한다. 이후 이를 일반화하여 덧셈 연산으로부터 닫혀있는 타입에서 동작하는 템플릿으로 알고리즘을 재구현한다. 이 과정은 매우 흥미롭다. 알고리즘을 개선하는 시도와 이를 어떻게 일반화하는지를 보여주면서 제네릭 프로그래밍의 목적이 무엇인지 독자에게 자연스럽게 알려준다.</p>
<p>꽤 많은 수식과 증명이 나온다. 때문에 수학과 친하지 않다면 쉽게 읽히는 책은 아니다. 허나 저자의 친절한 설명과 함께 코드 구현이 수반하기 때문에 고교 수학 과정을 성실히 이수하였다면 이해하는데 큰 무리는 없을 것이다. 틈틈이 수학과 수학자의 역사를 읽을거리로 제공하는 것도 이 책의 가치를 높인다.</p>
<p>c++처럼 type define이 자유로운 강타입 언어에서 제네릭 프로그래밍이 갖는 의미는 매우 크다. 문제 해결하는 방법을 일반화하고, 이 일반화된 문제해결 방법이 어떤 타입에 제한되는지(또는 어떤 타입에 적용 가능한지) 정의하는 방법이 어떻게 수학의 문제해결 방식과 맞닿아 있는지에 대한 설명이 탁월하다. 누군가가 제네릭 프로그래밍을 주제로 책을 추천해 달라 한다면 알고리즘 산책은 단연 선순위이다.</p>
<p>주개발 언어가 c++ 가 아닌 프로그래머라면 type에 조건을 주는 concepts 부분이 잘 이해가 가지 않을 수도 있겠다. 이번 기회에 이 책을 읽으면서 인식의 지평을 넓히는 계기가 되었으면 한다.</p>
<p><a href="https://en.cppreference.com/w/cpp/language/constraints">concepts 소개</a></p>
<p>마지막으로 이런 훌륭한 책을 리뷰할 수 있도록 출간해 주신 길벗 출판사에게 감사드린다.</p>
]]></content:encoded>
							<wfw:commentRss>https://01010011.blog/2018/08/29/%eb%8f%84%ec%84%9c-%eb%a6%ac%eb%b7%b0-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ec%82%b0%ec%b1%85-%ec%88%98%ed%95%99%ec%97%90%ec%84%9c-%ec%a0%9c%eb%84%a4%eb%a6%ad-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/bb2519f8e198b51fdc396e8a9d5f475e?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">bahamoth2013</media:title>
		</media:content>

		<media:content url="http://image.aladin.co.kr/product/14796/61/cover/k492532258_1.jpg" medium="image">
			<media:title type="html">알고리즘 산책 수학에서 제네릭 프로그래밍까지에 대한 이미지 검색결과</media:title>
		</media:content>
	</item>
		<item>
		<title>AWS summit 2017 사내전파 교육자료</title>
		<link>https://01010011.blog/2017/04/24/aws-summit-2017-%ec%82%ac%eb%82%b4%ec%a0%84%ed%8c%8c-%ea%b5%90%ec%9c%a1%ec%9e%90%eb%a3%8c/</link>
				<comments>https://01010011.blog/2017/04/24/aws-summit-2017-%ec%82%ac%eb%82%b4%ec%a0%84%ed%8c%8c-%ea%b5%90%ec%9c%a1%ec%9e%90%eb%a3%8c/#respond</comments>
				<pubDate>Mon, 24 Apr 2017 07:48:18 +0000</pubDate>
		<dc:creator><![CDATA[bahamoth2013]]></dc:creator>
				<category><![CDATA[programming]]></category>

		<guid isPermaLink="false">http://01010011.blog/?p=1430</guid>
				<description><![CDATA[]]></description>
								<content:encoded><![CDATA[<div class="jetpack-video-wrapper"><iframe src='https://www.slideshare.net/slideshow/embed_code/75340181' width='676' height='554' allowfullscreen webkitallowfullscreen mozallowfullscreen></iframe></div>
]]></content:encoded>
							<wfw:commentRss>https://01010011.blog/2017/04/24/aws-summit-2017-%ec%82%ac%eb%82%b4%ec%a0%84%ed%8c%8c-%ea%b5%90%ec%9c%a1%ec%9e%90%eb%a3%8c/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/bb2519f8e198b51fdc396e8a9d5f475e?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">bahamoth2013</media:title>
		</media:content>
	</item>
		<item>
		<title>kubernetes multi-node cluster 구성하기</title>
		<link>https://01010011.blog/2017/04/21/kubernetes-multi-node-cluster-%ea%b5%ac%ec%84%b1%ed%95%98%ea%b8%b0/</link>
				<comments>https://01010011.blog/2017/04/21/kubernetes-multi-node-cluster-%ea%b5%ac%ec%84%b1%ed%95%98%ea%b8%b0/#respond</comments>
				<pubDate>Fri, 21 Apr 2017 04:17:00 +0000</pubDate>
		<dc:creator><![CDATA[bahamoth2013]]></dc:creator>
				<category><![CDATA[devops]]></category>
		<category><![CDATA[kubernetes]]></category>

		<guid isPermaLink="false">http://01010011.blog/?p=1354</guid>
				<description><![CDATA[kubernetes 공식 문서에서는 다양한 kubernetes cluster 구성 전략 을 제공하고 있다. 그 중 docker를 이용한 cluster 구성 방식(portable multi-node)으로 multi-node cluster 를 구성하는 방법을 기술한다. 설치 후 알게 된 사실 portable multi-node 는 kubernetes developer community 에서 업데이트가 뜸하다.  대신 kubeadm 활동이 활발하다.(관련링크) 아직 alpha release 이므로 좀 더 안정화될 때까지 기다렸다가(얼마 안남은 듯) kubeadm &#8230; <a href="https://01010011.blog/2017/04/21/kubernetes-multi-node-cluster-%ea%b5%ac%ec%84%b1%ed%95%98%ea%b8%b0/" class="more-link"><span class="screen-reader-text">kubernetes multi-node cluster&#160;구성하기</span> 계속 읽기</a>]]></description>
								<content:encoded><![CDATA[<p>kubernetes 공식 문서에서는 <a href="https://kubernetes.io/docs/setup/pick-right-solution/">다양한 kubernetes cluster 구성 전략</a> 을 제공하고 있다.</p>
<p>그 중 docker를 이용한 cluster 구성 방식(<a href="https://kubernetes.io/docs/getting-started-guides/docker-multinode/">portable multi-node</a>)으로 multi-node cluster 를 구성하는 방법을 기술한다.</p>
<blockquote><p><strong>설치 후 알게 된 사실</strong></p>
<p>portable multi-node 는 kubernetes developer community 에서 업데이트가 뜸하다.  대신 kubeadm 활동이 활발하다.(<a href="http://blog.kubernetes.io/2017/01/stronger-foundation-for-creating-and-managing-kubernetes-clusters.html">관련링크</a>) 아직 alpha release 이므로 좀 더 안정화될 때까지 기다렸다가(얼마 안남은 듯) kubeadm 으로 cluster 구성하는 것을 추천한다.</p></blockquote>
<p>prerequisite<br />
docker 만 있으면 됨<br />
필자는 centos 7 에 설치하였다.</p>
<p>docker 설치<br />
docker 설치는 이 <a href="https://docs.docker.com/engine/installation/linux/centos/">사이트</a>에서 하란대로 하면 쉽게 설치가 가능하다.</p>
<p>환경에 따라 docker daemon 이 올라오지 않는 문제가 있다.<br />
필자의 경우에는 docker0 라는 가상 bridge 가 생성되지 않아서 강제로 docker0 브릿지를 생성하였다.</p>
<pre class="brush: plain; title: ; notranslate">
brctl addbr docker0
ip addr add 192.168.5.1/24 dev docker0
ip link set dev docker0 up
iptables -t nat -L -n
</pre>
<p>gnome gvfs 에서 io 를 엄청나게 점유해 버리는 문제가 있다.<br />
관련 app / service 를 모조리 uninstall 하고 reboot 하자.</p>
<p>kubernetes docker image 설치</p>
<p>이 글을 쓰는 도중 kubernetes documentation 에서 docker multi-node 구성이 지워졌다.</p>
<p>헐</p>
<p>앞으로는 kubeadm 으로 multi node 구성하면 된다. (링크 : https://kubernetes.io/docs/getting-started-guides/kubeadm/)</p>
<p>내가 이 글을 쓴 이유가 공홈 다큐멘테이션 대로 docker multi node 구성하면 설치가 안되기 때문이었는데 글 쓸 이유가 사라졌다.(ㅠㅠ)</p>
<p>글은 여기서 줄인다. 아마도 kubeadm 으로 설치하면 한방에 잘 설치 될거다.</p>
<p>&nbsp;</p>
]]></content:encoded>
							<wfw:commentRss>https://01010011.blog/2017/04/21/kubernetes-multi-node-cluster-%ea%b5%ac%ec%84%b1%ed%95%98%ea%b8%b0/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/bb2519f8e198b51fdc396e8a9d5f475e?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">bahamoth2013</media:title>
		</media:content>
	</item>
		<item>
		<title>[코딩소림사] 알고리즘 문제해결전략 #2</title>
		<link>https://01010011.blog/2017/04/14/%ec%bd%94%eb%94%a9%ec%86%8c%eb%a6%bc%ec%82%ac-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%eb%ac%b8%ec%a0%9c%ed%95%b4%ea%b2%b0%ec%a0%84%eb%9e%b5-2/</link>
				<comments>https://01010011.blog/2017/04/14/%ec%bd%94%eb%94%a9%ec%86%8c%eb%a6%bc%ec%82%ac-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%eb%ac%b8%ec%a0%9c%ed%95%b4%ea%b2%b0%ec%a0%84%eb%9e%b5-2/#comments</comments>
				<pubDate>Fri, 14 Apr 2017 05:09:24 +0000</pubDate>
		<dc:creator><![CDATA[bahamoth2013]]></dc:creator>
				<category><![CDATA[코딩 소림사]]></category>
		<category><![CDATA[programming]]></category>

		<guid isPermaLink="false">http://01010011.blog/?p=1349</guid>
				<description><![CDATA[주제 recursion 과 stack overflow 분할 정복 &#8211; 카라츠바 알고리즘]]></description>
								<content:encoded><![CDATA[<p>주제</p>
<ul>
<li>recursion 과 stack overflow</li>
<li>분할 정복 &#8211; 카라츠바 알고리즘</li>
</ul>
<div class="jetpack-video-wrapper"><iframe src='https://www.slideshare.net/slideshow/embed_code/75007939' width='676' height='554' allowfullscreen webkitallowfullscreen mozallowfullscreen></iframe></div>
]]></content:encoded>
							<wfw:commentRss>https://01010011.blog/2017/04/14/%ec%bd%94%eb%94%a9%ec%86%8c%eb%a6%bc%ec%82%ac-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%eb%ac%b8%ec%a0%9c%ed%95%b4%ea%b2%b0%ec%a0%84%eb%9e%b5-2/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/bb2519f8e198b51fdc396e8a9d5f475e?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">bahamoth2013</media:title>
		</media:content>
	</item>
		<item>
		<title>kubernetes 로 flask web app 배포하기</title>
		<link>https://01010011.blog/2017/04/11/kubernetes-%eb%a1%9c-flask-web-app-%eb%b0%b0%ed%8f%ac%ed%95%98%ea%b8%b0/</link>
				<comments>https://01010011.blog/2017/04/11/kubernetes-%eb%a1%9c-flask-web-app-%eb%b0%b0%ed%8f%ac%ed%95%98%ea%b8%b0/#respond</comments>
				<pubDate>Tue, 11 Apr 2017 00:53:21 +0000</pubDate>
		<dc:creator><![CDATA[bahamoth2013]]></dc:creator>
				<category><![CDATA[devops]]></category>
		<category><![CDATA[kubernetes]]></category>

		<guid isPermaLink="false">http://01010011.blog/?p=1178</guid>
				<description><![CDATA[kubernetes? 고대 그리스어로 조타수? 키잡이? 라는 의미라고 한다. 구글에서 개발한 container orchestration tool(vm 또는 container 관리를 자동화해주는 도구)이다. &#160; why kubernetes? 사실 이 부분은 충분한 경험이 없어서 자신있게 말을 못하겠다. 온라인에서 이것 저것 찾아보면 몇 가지 후보군이 더 있다. swarm mesos / marathon 기타(kotena, nomad &#8230;) 이 중에서 kubernetes 를 선택한 이유는 기본적으로 제공하는 기능과 &#8230; <a href="https://01010011.blog/2017/04/11/kubernetes-%eb%a1%9c-flask-web-app-%eb%b0%b0%ed%8f%ac%ed%95%98%ea%b8%b0/" class="more-link"><span class="screen-reader-text">kubernetes 로 flask web app&#160;배포하기</span> 계속 읽기</a>]]></description>
								<content:encoded><![CDATA[<h3>kubernetes?</h3>
<p>고대 그리스어로 조타수? 키잡이? 라는 의미라고 한다.<br />
구글에서 개발한 container orchestration tool(vm 또는 container 관리를 자동화해주는 도구)이다.</p>
<p>&nbsp;</p>
<h3>why kubernetes?</h3>
<p>사실 이 부분은 충분한 경험이 없어서 자신있게 말을 못하겠다.<br />
온라인에서 이것 저것 찾아보면 몇 가지 후보군이 더 있다.</p>
<ul>
<li>swarm</li>
<li>mesos / marathon</li>
<li>기타(kotena, nomad &#8230;)</li>
</ul>
<p>이 중에서 kubernetes 를 선택한 이유는<br />
기본적으로 제공하는 기능과 설계구조가 전반적으로 낫다는 평(카더라)<br />
업계의 선택 &#8211; 실무 활용 사례가 많다는 점</p>
<p>때문이다. 다른 오케스트레이션 툴 중에 더 나은 것이 있다면 얼마든지 변경할 수 있다.</p>
<p>&nbsp;</p>
<h3>설치</h3>
<p>는 생략&#8230; 공식 홈페이지에 tutorial 이 잘 나와 있다.</p>
<p>클러스터링 전략을 어떻게 가져가느냐에 따라 다양한 방법으로 설치가 가능하므로<br />
문서를 잘 읽어보고 본인의 환경에 맞게 설치하길 바란다.</p>
<p>처음 시작하는 사람들은 로컬 개발환경에 docker / minikube / kubectl 설치하면 된다.<br />
<a href="https://kubernetes.io/docs/getting-started-guides/minikube/" rel="nofollow">https://kubernetes.io/docs/getting-started-guides/minikube/</a></p>
<p>&nbsp;</p>
<h3>flask app 만들기</h3>
<p>아래와 같이 간단하게 동작하는 flask app을 만들자.</p>
<blockquote><p><span style="color:#000000;"><strong>중요!</strong></span><br />
<span style="color:#000000;"> <em>host 설정을 <span style="color:#ff0000;">0.0.0.0</span> 으로 하여야 가상 컨테이너 외부에서 별도 proxy 없이 접근 가능하다.</em></span></p></blockquote>
<pre class="brush: python; title: ; notranslate">
from flask import Flask
app = Flask(__name__)

@app.route(&quot;/&quot;)
def hello():
    return &quot;Hello!!&quot;

if __name__ == &quot;__main__&quot;:
    app.run(host='0.0.0.0')
</pre>
<p>특별한 설정 없이 실행하는 것 만으로 웹 서비스를 제공한다.</p>
<pre class="brush: bash; title: ; notranslate">
$ python3 hello.py
 * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
127.0.0.1 - - [11/Apr/2017 08:40:53] &quot;GET / HTTP/1.1&quot; 200 -
</pre>
<p>이 flask app 을 docker image 로 만들어 보자.</p>
<h3></h3>
<h3>docker image / container 만들기</h3>
<p>다음과 같이 Dockerfile 을 만들자.<br />
기존에 제공된 python image 기반으로 조금 전에 만든 flask app 을 복사/실행하도록 하자.</p>
<pre class="brush: bash; title: Dockerfile; notranslate">
FROM python:3.6
EXPOSE 5000
COPY hello.py .
RUN pip install flask
CMD [&quot;python&quot;,  &quot;./hello.py&quot;]
</pre>
<p>만든 Dockerfile로부터 docker image 를 만들자.</p>
<pre class="brush: plain; title: ; notranslate">
$ docker build -t hello-flask:v1 .
</pre>
<p>이 docker image 가 잘 동작하는지 확인해 보자.</p>
<pre class="brush: plain; title: ; notranslate">
docker run -it --rm -p 5000:5000 hello-flask:v1
 * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
172.17.0.1 - - [10/Apr/2017 23:54:50] &quot;GET / HTTP/1.1&quot; 200 -
</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>kubernetes 로 docker container(pod 또는 deployment) 만들기</h3>
<p>다음 2가지를 주의한다.<br />
kubernetes 는 Dockerfile 로부터 container를 생성하는 기능은 제공하지 않는다. docker image를 미리 만들어 두어야 한다.<br />
kubernetes 하위에서 실행되는 docker 환경은 시스템에 설치된 docker 환경과는 완전히 독립적이다. docker image / container 를 공유하지 않으므로 image를 다시 만들어야 한다.</p>
<pre class="brush: plain; title: ; notranslate">
$ eval $(minikube docker-env) //kubernetes docker 실행환경 전환
$ eval $(minikube docker-env -u) //kubernetes docker 실행환경 원복
</pre>
<p>kubernetes docker 실행환경으로 전환하여 docker image 를 만든 후, kubectl을 이용하여 다음과 같이 deployment(pod) 를 생성한다.</p>
<pre class="brush: plain; title: ; notranslate">
$ kubectl run hello-flask --image=hello-flask:v1 --port=5000
deployment &quot;hello-flask&quot; created
</pre>
<p>kubectl 을 이용해 deployment / pod 정보를 보면 아래와 같다.</p>
<pre class="brush: plain; title: ; notranslate">
$ kubectl get deployments
NAME             DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
hello-flask      1         1         1            1           24s

$ kubectl get pods
NAME                              READY     STATUS    RESTARTS   AGE
hello-flask-2475082718-xw1s3      1/1       Running   0          3m
</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>pod vs deployment ?</h3>
<p>kubernetes 는 container / container group 의 단위로 pod 를 사용한다.<br />
반면 deployment 는 pod 의 상태를 체크하여 pod 생성/재시작/scaling 을 담당한다.<br />
pod 가 Object 라면 deployment 는 Factory 나 Builder 와 같은 관계랄까.</p>
<p>위와 같은 이유로 보통 kubectl 로 container 를 생성/삭제할 때에는 deployment 로 호칭하므로 참고하기 바란다.</p>
<p>&nbsp;</p>
<h3>deployment 로 service 만들기</h3>
<p>deployment 만 생성하여서는 아직 서비스를 할 수가 없다.<br />
다음과 같이 kubectl 명령을 사용하여 deployment 를 service 로 실행한다.</p>
<pre class="brush: plain; title: ; notranslate">
kubectl expose deployment hello-flask --type=LoadBalancer --name=hello-flask
</pre>
<p>kubectl 을 이용해 service 정보를 확인해 보자</p>
<pre class="brush: plain; title: ; notranslate">
$ kubectl get service hello-flask
NAME          CLUSTER-IP   EXTERNAL-IP   PORT(S)          AGE
hello-flask   10.0.0.245   &amp;amp;amp;lt;pending&amp;amp;amp;gt;     5000:30276/TCP   &amp;amp;amp;lt;invalid&amp;amp;amp;gt;

$ kubectl describe service hello-flask
Name:                   hello-flask
Namespace:              default
Labels:                 run=hello-flask
Selector:               run=hello-flask
Type:                   LoadBalancer
IP:                     10.0.0.245
Port:                   &amp;amp;amp;lt;unset&amp;amp;amp;gt; 5000/TCP
NodePort:               &amp;amp;amp;lt;unset&amp;amp;amp;gt; 30276/TCP
Endpoints:              172.17.0.2:5000
Session Affinity:       None
No events.
</pre>
<p>다음 minikube 명령을 이용하면 flask app 이 어느 external ip 와 mapping 되어 있는지 브라우저로 확인할 수 있다. 현재 별도로 kubernetes 에게 external ip/port 할당 관련한 설정을 하지 않았으므로 아무렇게나 할 것이다.</p>
<pre class="brush: plain; title: ; notranslate">
$ minikube service hello-flask
Opening kubernetes service default/hello-flask in default browser...
</pre>
<p>다음과 같이 stdout log 도 확인 가능하다.</p>
<pre class="brush: plain; title: ; notranslate">
$ kubectl logs -f hello-flask-2475082718-xw1s3
 * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
172.17.0.1 - - [11/Apr/2017 00:36:00] &quot;GET / HTTP/1.1&quot; 200 -
172.17.0.1 - - [11/Apr/2017 00:36:00] &quot;GET /favicon.ico HTTP/1.1&quot; 404 -
172.17.0.1 - - [11/Apr/2017 00:38:15] &quot;GET / HTTP/1.1&quot; 200 -
172.17.0.1 - - [11/Apr/2017 00:40:47] &quot;GET / HTTP/1.1&quot; 200 -
172.17.0.1 - - [11/Apr/2017 00:42:22] &quot;GET / HTTP/1.1&quot; 200 -
172.17.0.1 - - [11/Apr/2017 00:47:26] &quot;GET / HTTP/1.1&quot; 200 -
172.17.0.1 - - [11/Apr/2017 00:47:27] &quot;GET / HTTP/1.1&quot; 200 -
172.17.0.1 - - [11/Apr/2017 00:47:27] &quot;GET / HTTP/1.1&quot; 200 -
172.17.0.1 - - [11/Apr/2017 00:47:27] &quot;GET / HTTP/1.1&quot; 200 -
</pre>
<blockquote><p><span style="color:#000000;"><strong>중요!</strong></span><br />
<span style="color:#000000;"> <em>container 기반 app 을 작성할 때에는 log를 반드시<span style="color:#ff0000;"> stdout</span> 으로 남기도록 한다.</em></span><br />
<span style="color:#000000;"><em> 그래야 log 를 container 와 별도로 수집 가능하다.</em></span></p></blockquote>
]]></content:encoded>
							<wfw:commentRss>https://01010011.blog/2017/04/11/kubernetes-%eb%a1%9c-flask-web-app-%eb%b0%b0%ed%8f%ac%ed%95%98%ea%b8%b0/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/bb2519f8e198b51fdc396e8a9d5f475e?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">bahamoth2013</media:title>
		</media:content>
	</item>
		<item>
		<title>코딩소림사 스터디 &#8211; 알고리즘 문제해결전략 #1</title>
		<link>https://01010011.blog/2017/04/05/%ec%bd%94%eb%94%a9%ec%86%8c%eb%a6%bc%ec%82%ac-%ec%8a%a4%ed%84%b0%eb%94%94-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%eb%ac%b8%ec%a0%9c%ed%95%b4%ea%b2%b0%ec%a0%84%eb%9e%b5-1/</link>
				<comments>https://01010011.blog/2017/04/05/%ec%bd%94%eb%94%a9%ec%86%8c%eb%a6%bc%ec%82%ac-%ec%8a%a4%ed%84%b0%eb%94%94-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%eb%ac%b8%ec%a0%9c%ed%95%b4%ea%b2%b0%ec%a0%84%eb%9e%b5-1/#comments</comments>
				<pubDate>Wed, 05 Apr 2017 02:18:01 +0000</pubDate>
		<dc:creator><![CDATA[bahamoth2013]]></dc:creator>
				<category><![CDATA[코딩 소림사]]></category>
		<category><![CDATA[programming]]></category>

		<guid isPermaLink="false">http://01010011.blog/?p=1145</guid>
				<description><![CDATA[금번 스터디는 구종만 님의 매우 명저 &#8220;알고리즘 문제해결 전략&#8221; 으로 8주간 진행합니다. 개인적으로는 분량도 짧고(!) 내용도 알찬 한주영 님의 &#8220;개미수열을 푸는 10가지 방법&#8221;으로 진행하길 원했으나 다수결에 밀려(ㅜㅜ) &#8220;알고리즘 문제해결 전략&#8221; 으로 선정되었습니다. 사실 &#8220;알고리즘 문제해결전략&#8221;은 매우 명저이고 저도 참 좋아하는 책입니다. 저자분이 그 유명한 알고스팟 운영자시기도 하구요. 많은 분들께서 아주 의욕적으로 알고리즘 주제를 깊이 있게 &#8230; <a href="https://01010011.blog/2017/04/05/%ec%bd%94%eb%94%a9%ec%86%8c%eb%a6%bc%ec%82%ac-%ec%8a%a4%ed%84%b0%eb%94%94-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%eb%ac%b8%ec%a0%9c%ed%95%b4%ea%b2%b0%ec%a0%84%eb%9e%b5-1/" class="more-link"><span class="screen-reader-text">코딩소림사 스터디 &#8211; 알고리즘 문제해결전략&#160;#1</span> 계속 읽기</a>]]></description>
								<content:encoded><![CDATA[<p>금번 스터디는 구종만 님의 매우 명저 &#8220;알고리즘 문제해결 전략&#8221; 으로 8주간 진행합니다.</p>
<p>개인적으로는 분량도 짧고(!) 내용도 알찬 한주영 님의 &#8220;개미수열을 푸는 10가지 방법&#8221;으로 진행하길 원했으나 다수결에 밀려(ㅜㅜ) &#8220;알고리즘 문제해결 전략&#8221; 으로 선정되었습니다.</p>
<p>사실 &#8220;알고리즘 문제해결전략&#8221;은 매우 명저이고 저도 참 좋아하는 책입니다. 저자분이 그 유명한 알고스팟 운영자시기도 하구요. 많은 분들께서 아주 의욕적으로 알고리즘 주제를 깊이 있게 공부하길 원한다는 의미인 듯 하여 매우 기쁩니다.</p>
<p>아래는 스터디 ppt 입니다.</p>
<div class="jetpack-video-wrapper"><iframe src='https://www.slideshare.net/slideshow/embed_code/74399906' width='676' height='554' allowfullscreen webkitallowfullscreen mozallowfullscreen></iframe></div>
]]></content:encoded>
							<wfw:commentRss>https://01010011.blog/2017/04/05/%ec%bd%94%eb%94%a9%ec%86%8c%eb%a6%bc%ec%82%ac-%ec%8a%a4%ed%84%b0%eb%94%94-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%eb%ac%b8%ec%a0%9c%ed%95%b4%ea%b2%b0%ec%a0%84%eb%9e%b5-1/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/bb2519f8e198b51fdc396e8a9d5f475e?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">bahamoth2013</media:title>
		</media:content>
	</item>
		<item>
		<title>[rxJava] Flowable 과 Observable 의 차이</title>
		<link>https://01010011.blog/2017/03/29/rxjava-flowable-%ea%b3%bc-observable-%ec%9d%98-%ec%b0%a8%ec%9d%b4/</link>
				<comments>https://01010011.blog/2017/03/29/rxjava-flowable-%ea%b3%bc-observable-%ec%9d%98-%ec%b0%a8%ec%9d%b4/#respond</comments>
				<pubDate>Wed, 29 Mar 2017 00:06:11 +0000</pubDate>
		<dc:creator><![CDATA[bahamoth2013]]></dc:creator>
				<category><![CDATA[java]]></category>
		<category><![CDATA[program language]]></category>

		<guid isPermaLink="false">http://01010011.blog/?p=1061</guid>
				<description><![CDATA[rxjava 가 메이저 버전 업(1-&#62;2)을 하면서 몇 가지 변경점이 생겼다. 변경점에 대한 자세한 내용은 아래 링크를 참조하기 바란다. rxJava Wiki : https://github.com/ReactiveX/RxJava/wiki/What&#8217;s-different-in-2.0 번역 : http://realignist.me/code/2017/01/25/rxjava2-changelog.html Flowable 이라는 base reactive class 가 추가 되었다. Observable 과의 차이는 backpressure buffer의 기본 탑재 유무이다. backpressure? 우리말로 번역하면 &#8216;등 뒤에서 떠밀리는 압박&#8217; 정도가 될 듯 하다. 이런 상황을 가정해보자. &#8230; <a href="https://01010011.blog/2017/03/29/rxjava-flowable-%ea%b3%bc-observable-%ec%9d%98-%ec%b0%a8%ec%9d%b4/" class="more-link"><span class="screen-reader-text">[rxJava] Flowable 과 Observable 의&#160;차이</span> 계속 읽기</a>]]></description>
								<content:encoded><![CDATA[<p>rxjava 가 메이저 버전 업(1-&gt;2)을 하면서 몇 가지 변경점이 생겼다.</p>
<p>변경점에 대한 자세한 내용은 아래 링크를 참조하기 바란다.</p>
<ul>
<li>rxJava Wiki : <u><a href="https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0">https://github.com/ReactiveX/RxJava/wiki/What&#8217;s-different-in-2.0</a></u></li>
<li>번역 : <u><a href="http://realignist.me/code/2017/01/25/rxjava2-changelog.html">http://realignist.me/code/2017/01/25/rxjava2-changelog.html</a></u></li>
</ul>
<p>Flowable 이라는 base reactive class 가 추가 되었다. Observable 과의 차이는 backpressure buffer의 기본 탑재 유무이다.</p>
<h3>backpressure?</h3>
<p>우리말로 번역하면 &#8216;등 뒤에서 떠밀리는 압박&#8217; 정도가 될 듯 하다.</p>
<p>이런 상황을 가정해보자. 콘서트장을 사람들이 가득 메웠다. 콘서트장에 들어오려는 사람들은 저글링 개떼처럼 밀려드는데 나가는 사람은 별로 없다. 콘서트장 출입구를 통제하는 요원이 없다면? 콘서트장이 터지던지 안에 있던 사람들이 짜부러지던지 아무튼 대형 사고가 발생할거다.</p>
<p>publish / subscribe 모델에서도 이런 비극적인 시나리오가 발생할 수 있다. 생산자는 미친듯이 element 를 생산해 내는데 소비자가 처리하는 속도가 이를 따라가지 못한다면</p>
<ol>
<li>busy waiting 또는</li>
<li>out of memory exception 이 발생할 것이다.</li>
</ol>
<p>&#8216;등 뒤에서 떠밀리는 압박&#8217; 에 대한 흐름제어를 위한 버퍼가 바로 backpressure buffer 다. 버퍼가 가득 차면 어차피 소비자는 element 를 처리할 여유가 없는 상태이므로 더 이상 publish 를 하지 않는다.</p>
<p>기존에 없던 개념이 새로 추가된 것은 아니다. 기존 rxJava 1.xx 의 경우 Observable 에 backpressure buffer 를 직접 생성해 주면 사용이 가능하다. 허나 rxJava 개발자는 초보자들이 미처 알아채지 못하는 영역에서 기대하지 않는 동작이 일어날 가능성이 있다며 Flowable 을 추가하였다.</p>
<p>다음 예제코드를 보자. 생산자의 생산 속도를 소비자가 따라가지 못하는 시나리오다.<br />
Flowable 을 사용하면 default buffer size(128) 이상 backpressure buffer 에 element 가 쌓일 경우 흐름제어를 한다.</p>
<pre class="brush: java; title: ; notranslate">
public class example01 {

    public static void main(String... args) throws InterruptedException {

        final String tmpStr = Arrays.stream(new String[10_000_000]).map(x-&gt;&quot;*&quot;).collect(Collectors.joining());
        Flowable foo = Flowable.range(0, 1000_000_000)
                .map(x-&gt; {
                    System.out.println(&quot;[very fast sender] i'm fast. very fast.&quot;);
                    System.out.println(String.format(&quot;sending id: %s %d%50.50s&quot;, Thread.currentThread().getName(), x, tmpStr));
                    return x+tmpStr;
                });

        foo.observeOn(Schedulers.computation()).subscribe(x-&gt;{
            Thread.sleep(1000);
            System.out.println(&quot;[very busy receiver] i'm busy. very busy.&quot;);
            System.out.println(String.format(&quot;receiving id: %s %50.50s&quot;, Thread.currentThread().getName(), x));
        });

        while (true) {
            Thread.sleep(1000);
        }
    }
}
</pre>
<pre class="brush: bash; title: ; notranslate">
[very fast sender] i'm fast. very fast.
sending id: main 0**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 1**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 2**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 3**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 4**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 5**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 6**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 7**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 8**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 9**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 10**************************************************

... 중략 ...

[very busy receiver] i'm busy. very busy.
receiving id: RxComputationThreadPool-1 0*************************************************
receiving id: RxComputationThreadPool-1 1*************************************************
receiving id: RxComputationThreadPool-1 2*************************************************
[very fast sender] i'm fast. very fast.
sending id: main 117**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 118**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 119**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 120**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 121**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 122**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 123**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 124**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 125**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 126**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 127**************************************************
[very busy receiver] i'm busy. very busy.
receiving id: RxComputationThreadPool-1 3*************************************************
[very busy receiver] i'm busy. very busy.
receiving id: RxComputationThreadPool-1 4*************************************************
[very busy receiver] i'm busy. very busy.
receiving id: RxComputationThreadPool-1 5*************************************************
[very busy receiver] i'm busy. very busy.
receiving id: RxComputationThreadPool-1 6*************************************************
[very busy receiver] i'm busy. very busy.
receiving id: RxComputationThreadPool-1 7*************************************************
[very busy receiver] i'm busy. very busy.
receiving id: RxComputationThreadPool-1 8*************************************************
[very busy receiver] i'm busy. very busy.
receiving id: RxComputationThreadPool-1 9*************************************************
</pre>
<p>반면, 같은 시나리오를 Observable 을 backpressure buffer 생성 없이 사용하면 OutOfMemoryException 이 발생한다.</p>
<pre class="brush: java; title: ; notranslate">
public class example02 {

    public static void main(String... args) throws InterruptedException {

        final String tmpStr = Arrays.stream(new String[10_000_000]).map(x-&gt;&quot;*&quot;).collect(Collectors.joining());
        Observable foo = Observable.range(0, 1000_000_000)
                .map(x-&gt; {
                    System.out.println(&quot;[very fast sender] i'm fast. very fast.&quot;);
                    System.out.println(String.format(&quot;sending id: %s %d%50.50s&quot;, Thread.currentThread().getName(), x, tmpStr));
                    return x+tmpStr;
                });

        foo.observeOn(Schedulers.computation()).subscribe(x-&gt;{
            Thread.sleep(1000);
            System.out.println(&quot;[very busy receiver] i'm busy. very busy.&quot;);
            System.out.println(String.format(&quot;receiving id: %s %50.50s&quot;, Thread.currentThread().getName(), x));
        });

        while (true) {
            Thread.sleep(1000);
        }
    }
}
</pre>
<pre class="brush: bash; title: ; notranslate">
[very fast sender] i'm fast. very fast.
sending id: main 0**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 1**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 2**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 3**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 4**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 5**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 6**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 7**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 8**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 9**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 10**************************************************
[very fast sender] i'm fast. very fast.

...중략...

sending id: main 198**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 199**************************************************
[very fast sender] i'm fast. very fast.
sending id: main 200**************************************************
Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space
	at java.util.Arrays.copyOfRange(Arrays.java:3664)
	at java.lang.String.&lt;init&gt;(String.java:207)
	at java.lang.StringBuilder.toString(StringBuilder.java:407)
	at example02.lambda$main$1(example02.java:24)
	at example02$$Lambda$6/123961122.apply(Unknown Source)
	at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:59)
	at io.reactivex.internal.operators.observable.ObservableRange$RangeDisposable.run(ObservableRange.java:64)
	at io.reactivex.internal.operators.observable.ObservableRange.subscribeActual(ObservableRange.java:35)
	at io.reactivex.Observable.subscribe(Observable.java:10700)
	at io.reactivex.internal.operators.observable.ObservableMap.subscribeActual(ObservableMap.java:33)
	at io.reactivex.Observable.subscribe(Observable.java:10700)
	at io.reactivex.internal.operators.observable.ObservableObserveOn.subscribeActual(ObservableObserveOn.java:45)
	at io.reactivex.Observable.subscribe(Observable.java:10700)
	at io.reactivex.Observable.subscribe(Observable.java:10686)
	at io.reactivex.Observable.subscribe(Observable.java:10589)
	at example02.main(example02.java:27)
[very busy receiver] i'm busy. very busy.
receiving id: RxComputationThreadPool-1 5*************************************************
</pre>
<p>참고로, Flowable 은 FlowableCreate 라는 builder 에서 생성되며, 특별한 설정이 없을 경우 buffer size 는 최소 16, 기본 128 로 설정한다.</p>
<pre class="brush: java; title: ; notranslate">
//FlowableCreate.java line:44

    @Override
    public void subscribeActual(Subscriber&lt;? super T&gt; t) {
        BaseEmitter&lt;T&gt; emitter;

        switch (backpressure) {
        case MISSING: {
            emitter = new MissingEmitter&lt;T&gt;(t);
            break;
        }
        case ERROR: {
            emitter = new ErrorAsyncEmitter&lt;T&gt;(t);
            break;
        }
        case DROP: {
            emitter = new DropAsyncEmitter&lt;T&gt;(t);
            break;
        }
        case LATEST: {
            emitter = new LatestAsyncEmitter&lt;T&gt;(t);
            break;
        }
        default: {
            emitter = new BufferAsyncEmitter&lt;T&gt;(t, bufferSize());
            break;
        }
        }

        t.onSubscribe(emitter);
        try {
            source.subscribe(emitter);
        } catch (Throwable ex) {
            Exceptions.throwIfFatal(ex);
            emitter.onError(ex);
        }
    }
</pre>
<pre class="brush: java; title: ; notranslate">
//Flowable.java line:61
    static final int BUFFER_SIZE;
    static {
        BUFFER_SIZE = Math.max(16, Integer.getInteger(&quot;rx2.buffer-size&quot;, 128));
    }
</pre>
]]></content:encoded>
							<wfw:commentRss>https://01010011.blog/2017/03/29/rxjava-flowable-%ea%b3%bc-observable-%ec%9d%98-%ec%b0%a8%ec%9d%b4/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/bb2519f8e198b51fdc396e8a9d5f475e?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">bahamoth2013</media:title>
		</media:content>
	</item>
		<item>
		<title>코딩소림사 정기 세미나 &#8211; 멸종하는 공룡이 되지 않으려면</title>
		<link>https://01010011.blog/2017/03/28/%ec%bd%94%eb%94%a9%ec%86%8c%eb%a6%bc%ec%82%ac-%ec%a0%95%ea%b8%b0-%ec%84%b8%eb%af%b8%eb%82%98-%eb%a9%b8%ec%a2%85%ed%95%98%eb%8a%94-%ea%b3%b5%eb%a3%a1%ec%9d%b4-%eb%90%98%ec%a7%80-%ec%95%8a%ec%9c%bc/</link>
				<comments>https://01010011.blog/2017/03/28/%ec%bd%94%eb%94%a9%ec%86%8c%eb%a6%bc%ec%82%ac-%ec%a0%95%ea%b8%b0-%ec%84%b8%eb%af%b8%eb%82%98-%eb%a9%b8%ec%a2%85%ed%95%98%eb%8a%94-%ea%b3%b5%eb%a3%a1%ec%9d%b4-%eb%90%98%ec%a7%80-%ec%95%8a%ec%9c%bc/#respond</comments>
				<pubDate>Tue, 28 Mar 2017 08:25:45 +0000</pubDate>
		<dc:creator><![CDATA[bahamoth2013]]></dc:creator>
				<category><![CDATA[협업]]></category>
		<category><![CDATA[코딩 소림사]]></category>
		<category><![CDATA[devops]]></category>
		<category><![CDATA[docker]]></category>
		<category><![CDATA[msa]]></category>

		<guid isPermaLink="false">http://01010011.blog/?p=1056</guid>
				<description><![CDATA[코딩 소림사 정기 세미나 발표자료 &#160;]]></description>
								<content:encoded><![CDATA[<p>코딩 소림사 정기 세미나 발표자료</p>
<div class="jetpack-video-wrapper"><iframe src='https://www.slideshare.net/slideshow/embed_code/73776737' width='676' height='554' allowfullscreen webkitallowfullscreen mozallowfullscreen></iframe></div>
<p>&nbsp;</p>
]]></content:encoded>
							<wfw:commentRss>https://01010011.blog/2017/03/28/%ec%bd%94%eb%94%a9%ec%86%8c%eb%a6%bc%ec%82%ac-%ec%a0%95%ea%b8%b0-%ec%84%b8%eb%af%b8%eb%82%98-%eb%a9%b8%ec%a2%85%ed%95%98%eb%8a%94-%ea%b3%b5%eb%a3%a1%ec%9d%b4-%eb%90%98%ec%a7%80-%ec%95%8a%ec%9c%bc/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/bb2519f8e198b51fdc396e8a9d5f475e?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">bahamoth2013</media:title>
		</media:content>
	</item>
		<item>
		<title>코딩 소림사 스터디 rxJava #2</title>
		<link>https://01010011.blog/2017/03/15/%ec%bd%94%eb%94%a9-%ec%86%8c%eb%a6%bc%ec%82%ac-%ec%8a%a4%ed%84%b0%eb%94%94-rxjava-2/</link>
				<comments>https://01010011.blog/2017/03/15/%ec%bd%94%eb%94%a9-%ec%86%8c%eb%a6%bc%ec%82%ac-%ec%8a%a4%ed%84%b0%eb%94%94-rxjava-2/#respond</comments>
				<pubDate>Wed, 15 Mar 2017 14:56:39 +0000</pubDate>
		<dc:creator><![CDATA[bahamoth2013]]></dc:creator>
				<category><![CDATA[코딩 소림사]]></category>
		<category><![CDATA[java]]></category>
		<category><![CDATA[programming]]></category>

		<guid isPermaLink="false">http://01010011.blog/?p=1051</guid>
				<description><![CDATA[]]></description>
								<content:encoded><![CDATA[<div class="jetpack-video-wrapper"><iframe src='https://www.slideshare.net/slideshow/embed_code/73176988' width='676' height='554' allowfullscreen webkitallowfullscreen mozallowfullscreen></iframe></div>
]]></content:encoded>
							<wfw:commentRss>https://01010011.blog/2017/03/15/%ec%bd%94%eb%94%a9-%ec%86%8c%eb%a6%bc%ec%82%ac-%ec%8a%a4%ed%84%b0%eb%94%94-rxjava-2/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/bb2519f8e198b51fdc396e8a9d5f475e?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">bahamoth2013</media:title>
		</media:content>
	</item>
		<item>
		<title>[펌] 임도형 님의 예외처리 가이드</title>
		<link>https://01010011.blog/2017/03/08/%ed%8e%8c-%ec%9e%84%eb%8f%84%ed%98%95-%eb%8b%98%ec%9d%98-%ec%98%88%ec%99%b8%ec%b2%98%eb%a6%ac-%ea%b0%80%ec%9d%b4%eb%93%9c/</link>
				<comments>https://01010011.blog/2017/03/08/%ed%8e%8c-%ec%9e%84%eb%8f%84%ed%98%95-%eb%8b%98%ec%9d%98-%ec%98%88%ec%99%b8%ec%b2%98%eb%a6%ac-%ea%b0%80%ec%9d%b4%eb%93%9c/#comments</comments>
				<pubDate>Wed, 08 Mar 2017 07:42:49 +0000</pubDate>
		<dc:creator><![CDATA[bahamoth2013]]></dc:creator>
				<category><![CDATA[programming]]></category>

		<guid isPermaLink="false">http://01010011.blog/?p=1012</guid>
				<description><![CDATA[4년 전 현재 직장입사 후 약 한 달 정도 함께 근무하였던 임도형 님의 예외처리에 대한 명 ppt 2개를 소개한다. 첫번째 ppt 는 java 예외 처리의 원칙에 대한 내용이고 두번째 ppt 는 언제 어디에 예외를 남길지에 대한 내용이다. &#160; 요약하면 발생하는 예외를 뭉개지 마라. IDE로부터 자동생성된 e.printStackTrace() 만 남기는건 아무 처리도 안하는 것 만 못하다. caller &#8230; <a href="https://01010011.blog/2017/03/08/%ed%8e%8c-%ec%9e%84%eb%8f%84%ed%98%95-%eb%8b%98%ec%9d%98-%ec%98%88%ec%99%b8%ec%b2%98%eb%a6%ac-%ea%b0%80%ec%9d%b4%eb%93%9c/" class="more-link"><span class="screen-reader-text">[펌] 임도형 님의 예외처리&#160;가이드</span> 계속 읽기</a>]]></description>
								<content:encoded><![CDATA[<p>4년 전 현재 직장입사 후 약 한 달 정도 함께 근무하였던 임도형 님의 예외처리에 대한 명 ppt 2개를 소개한다.</p>
<p>첫번째 ppt 는 java 예외 처리의 원칙에 대한 내용이고</p>
<p>두번째 ppt 는 언제 어디에 예외를 남길지에 대한 내용이다.</p>
<p>&nbsp;</p>
<p>요약하면</p>
<ul>
<li>발생하는 예외를 뭉개지 마라. IDE로부터 자동생성된 e.printStackTrace() 만 남기는건 아무 처리도 안하는 것 만 못하다.</li>
<li>caller / callee 의 경계에서 예외를 처리하면 로그의 중복/누락을 방지할 수 있다.</li>
<li>해당 상황을 인지할 수 있는 충분한 정보를 남겨라.</li>
</ul>
<p>&nbsp;</p>
<p>부연하자면</p>
<p>Exception 이란 정의되지 않은 동작을 처리하는 규약이다. 개발자가 정의한 io 의 범주를 벗어날지라도 우리는 이를 처리하는 규약을 정의할 수 있다.</p>
<p>java 에는 크게 두 가지 Exception 이 존재한다.</p>
<ul>
<li>CheckedException</li>
<li>UncheckedException(=RuntimeException)</li>
</ul>
<p>CheckedException 의 경우, 처리의 기준이 명백하고 프로그램은 복구가 가능하다. 처리에 크게 고민할 필요가 없다.</p>
<p>문제는 RuntimeException이다. RuntimeException이 발생하였다는 것은 이 프로그램이 복구 불가능한 상태에 진입하였다는 의미이다. 아래 소개된 임도형 님의 ppt 는 RuntimeException 을 어떻게 잘 처리할지에 대한 내용이다. Exception 처리같은 경우 충분한 경험이 없다면 매끄럽게 해결하기가 어려운데, 이 ppt는 실천적인 가이드를 제시해주는 매우 훌륭한 자료이므로 java 개발자라면 반드시 한번은 읽어볼 필요가 있다.</p>
<p>&nbsp;</p>
<div class="embed-slideshare"><iframe src="https://www.slideshare.net/slideshow/embed_code/key/l9D2KvuCScdjEz" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> </p>
<div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/dhrim/ss-2804901" title="예외처리가이드" target="_blank">예외처리가이드</a> </strong> from <strong><a target="_blank" href="http://www.slideshare.net/dhrim">Dohyoung Rim</a></strong> </div>
</div>
<p>&nbsp;</p>
<div class="embed-slideshare"><iframe src="https://www.slideshare.net/slideshow/embed_code/key/b3O1ukQN4yLpTm" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> </p>
<div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/dhrim/exception-log-practicalcodingguide" title="Exception log practical_coding_guide, 예외와 로그 코딩 실용 가이드" target="_blank">Exception log practical_coding_guide, 예외와 로그 코딩 실용 가이드</a> </strong> from <strong><a target="_blank" href="http://www.slideshare.net/dhrim">Dohyoung Rim</a></strong> </div>
</div>
]]></content:encoded>
							<wfw:commentRss>https://01010011.blog/2017/03/08/%ed%8e%8c-%ec%9e%84%eb%8f%84%ed%98%95-%eb%8b%98%ec%9d%98-%ec%98%88%ec%99%b8%ec%b2%98%eb%a6%ac-%ea%b0%80%ec%9d%b4%eb%93%9c/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/bb2519f8e198b51fdc396e8a9d5f475e?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">bahamoth2013</media:title>
		</media:content>
	</item>
	</channel>
</rss>
