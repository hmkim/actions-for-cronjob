<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by 홍철주 (angdev) on Medium]]></title>
        <description><![CDATA[Stories by 홍철주 (angdev) on Medium]]></description>
        <link>https://medium.com/@angdev?source=rss-4c658aab8997------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*a3-saUE7NkFyOVbQ0XHTww.jpeg</url>
            <title>Stories by 홍철주 (angdev) on Medium</title>
            <link>https://medium.com/@angdev?source=rss-4c658aab8997------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Sun, 12 May 2019 13:42:33 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@angdev" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[포켓몬 고 나왔니?]]></title>
            <link>https://medium.com/@angdev/%ED%8F%AC%EC%BC%93%EB%AA%AC-%EA%B3%A0-%EB%82%98%EC%99%94%EB%8B%88-65863f5754fb?source=rss-4c658aab8997------2</link>
            <guid isPermaLink="false">https://medium.com/p/65863f5754fb</guid>
            <category><![CDATA[twitter]]></category>
            <category><![CDATA[bots]]></category>
            <category><![CDATA[clojure]]></category>
            <category><![CDATA[pokémon-go]]></category>
            <dc:creator><![CDATA[홍철주 (angdev)]]></dc:creator>
            <pubDate>Fri, 27 Jan 2017 08:11:33 GMT</pubDate>
            <atom:updated>2017-01-27T08:11:33.694Z</atom:updated>
            <content:encoded><![CDATA[<h4>178일간의 기록</h4><p>안녕하세요. <a href="https://twitter.com/pokegostat">포켓몬 고 나왔니?</a> 봇주 <a href="https://twitter.com/angdev_">@angdev</a> 입니다. 이번에 포켓몬 고 나왔니 봇을 만들기부터 역할 완수까지의 과정이 즐거웠어서 이를 글로 남기게 되었습니다. 포켓몬 고가 나오지 않았으면 큰 감흥은 없었겠지만, 마무리를 지을 수 있어서 정말 다행입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*hFTxJvy23nplOR08KROmSQ.png" /><figcaption>봇의 마지막</figcaption></figure><h3>봇에 대해</h3><p>이 봇은 2016년 7월 29일부터 포켓몬 고 한국 출시일인 2017년 1월 23일까지 178일간 포켓몬 고가 나왔는지 트윗을 해왔습니다. 포켓몬 고가 나오면 즉시 “응” 이라는 트윗을 하고, 그렇지 않은 경우에는 “아니” 라는 트윗을 하게 되어있습니다. 사실 봇 뒤에 사람이 있는 경우도 많지만 이 봇의 경우는 <strong>자동 봇</strong>입니다.</p><p>가끔 봇이나 봇주에게 “일일이 트윗한 점에 대해 고생하셨다” 라는 멘션을 주는 분도 계셨는데 전 아무 것도 하지 않았습니다. 봇이 다 알아서 했죠. 오히려 포켓몬 고 출시에 관한 뉴스가 뜰 때마다 팔로워분들께서 알려주셔서 이런 부분은 수동으로 트윗을 하는 경우가 있었습니다. 뉴스를 알려주신 분들께 이 자리를 빌어 감사의 말을 전합니다.</p><h3>만들게 된 계기</h3><p>만들게 된 계기는 단순합니다. 제가 당시에 <a href="https://clojure.org/">Clojure</a> 라고 하는 프로그래밍 언어를 공부하고 있었습니다. 영어, 일본어도 그렇듯이 실제로 써봐야 실력이 느는 것처럼 프로그래밍 언어도 그렇기 때문에, 이걸로 뭔가 만들게 없을까 고민하다가 당시 <strong>포켓몬 고를 하러 울산 간절곶에 다녀왔던 것</strong>이<strong> </strong>계기가 되어 포켓몬 고 출시를 알려주는 봇을 만들어야겠다고 생각했습니다.</p><h3>기획 (?)</h3><p>이 봇의 존재 의의는 <strong>누구보다 빠르게 포켓몬 고를 사람들로 하여금 내려받을 수 있게 해주자 </strong>였습니다. 소식이야 전해듣고 제가 직접 트윗을 하루에 한 번씩 할 수도 있었겠지만, 그러기에는 앱 스토어에 출시되었을 시점에 제가 트윗을 할 수 있을 것이라는 보장이 없었습니다. 즉시성이 부족하죠. 그리고 제가 직접 주기적으로 앱 스토어에 들어가서 나왔나 검색해보고 트윗을 “응” 이라고 할 수는 없는 노릇이니 자동 봇으로 만들어야겠다고 생각했습니다.</p><p>봇의 컨셉은 <a href="https://twitter.com/ismyhwdone">is my homework done</a> 이라는 트위터 계정에서 가져왔습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*yDuIvwTvMp5uI25ce5P09w.png" /><figcaption>is my homework done? no</figcaption></figure><p>오랜 기간 “아니” 라고 트윗하다가 “응” 이라고 한 마디 트윗할 때의 짠한 느낌을 생각하면서 컨셉을 차용하게 되었습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*IQNa-XhT-SJvzjrT-f6IjA.png" /><figcaption>그렇게 잡힌 포켓몬 고 나왔니? 의 컨셉</figcaption></figure><p>그리고 하루에 한 번만 트윗하는 것은 트위터의 정책으로부터 결정된 것도 있습니다. 트위터에서는 똑같은 내용의 트윗을 연달아서 트윗하는 것을 허용하지 않습니다. 아래와 같이 말이죠.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*-jgeBQQpLVGJsrYFaLPtQg.png" /><figcaption>도배하지 않을게 트위터야</figcaption></figure><p>똑같은 내용의 트윗을 하고 싶으면 최소 하루의 기간을 둬야합니다. 그보다 짧은 기간 내에 같은 내용을 트윗을 쓰고 싶으면 트윗 끝에 랜덤한 문자열을 붙이는 등의 방법도 사용될 수 있는데, 그렇게까지는 할 필요가 없다고 느꼈고 하루 정도가 무난하겠다 싶었습니다.</p><h3>구현</h3><p>이 봇의 동작 원리는 매우 매우 간단합니다. 전체적인 플로우는 아래와 같습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/663/1*R3eBpHOB3PpVyTO77lTvyA.jpeg" /></figure><p>이 봇을 구현하기 위해서는 <strong>트윗하기, 작업 예약하기, 웹 페이지 가져오기 </strong>등의 작업이 필요합니다. 즉, 제가 새로이 배우는 언어로 이런 작업들을 해볼 수 있다는 것이 됩니다. 라이브러리를 쓰는 것이 많겠지만, 그 언어의 생태계를 살펴보는 것은 큰 도움이 될 것이라 생각했습니다.</p><h4>포켓몬 고 나왔는지 확인하기</h4><p>App Store 의 경우는 같은 앱이라도 국가별 출시 여부에 따라 Apple Itunes 페이지가 다르게 보입니다. 이 점을 활용해서 한국 앱스토어에 출시되었는지 확인할 수 있습니다. 포켓몬 고의 한국 앱스토어 URL 은 <a href="https://itunes.apple.com/KR/app/Pokemon-go/id1094591345">https://itunes.apple.com/<strong><em>KR</em></strong>/app/Pokemon-go/id1094591345</a> 입니다. 가운데에 KR 부분이 대한민국에 대한 코드입니다.</p><p>한국의 경우는 이제 출시되었기 때문에, 아래와 같은 페이지를 볼 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*zijikO4Bc9Lt795iRUuEUA.png" /><figcaption>한국 앱 스토어</figcaption></figure><p>반면에 포켓몬 고의 우크라이나 앱 스토어 URL은 <a href="https://itunes.apple.com/UA/app/Pokemon-go/id1094591345">https://itunes.apple.com/UA/app/Pokemon-go/id1094591345</a> 로 추정할 수 있는데, 이 페이지는 아래와 같은 모습을 보입니다. 얼마 전까지는 한국 앱 스토어도 이랬었죠.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*PQ0eH0NFD_2j-Lk7Wa0yxw.png" /><figcaption>우크라이나 앱 스토어</figcaption></figure><p>이 차이를 이용해서 출시 여부를 확인할 수 있으며, 포켓몬 고가 만약 출시된다면 <a href="https://play.google.com/store/apps/details?id=com.nianticlabs.pokemongo&amp;hl=ko">Google Play</a> 와 <a href="https://itunes.apple.com/KR/app/Pokemon-go/id1094591345?mt=8">App Store</a> 에 동시에 출시할 것이라 생각했고, 확인하기가 더 쉽기 때문에 일단 App Store 만 확인하기로 했습니다.</p><h4>트윗하기</h4><p>저는 Clojure 를 사용했기 때문에 Clojure Twitter Library 인 <a href="https://github.com/adamwynne/twitter-api">twitter-api</a> 를 사용했고, 이하 내용은 생략합니다. 트윗 시에 발생할 수 있는 예외에 대한 처리만 간단히 해주었습니다. 하루에 한 번 트윗하기 규칙에 대해서는 일단 트윗하고 에러가 나면 삼키는 식으로 구현할 수도 있었지만, 그냥 마지막 트윗 시각을 기록해두고 이를 활용해서 트윗하기 API 를 하루에 한 번만 호출하였습니다.</p><h4>작업 예약하기</h4><p>작업 예약에는 간단하게 cron 을 사용할 수도 있었지만, 비동기 처리를 Clojure 에서 어떻게 할 수 있는지 알아보고 싶었기 때문에 Clojure Scheduling Library 인 <a href="https://github.com/jarohen/chime">chime</a> 을 써서 30초 마다 포켓몬 고 출시 여부를 확인하게 했습니다.</p><h4>배포하기</h4><p>이 작업물을 매우 매우 간단하게 Dockerize 하여 (다른 의존성도 딱히 없어서 할 게 없었고, <a href="https://leiningen.org/">Leiningen</a> 이 다 알아서 해줬습니다), 한국에서는 사용할 수 없는 AWS ECS (EC2 Container Service) 에 배포를 했습니다. ap-northeast-2 region 에서 서비스를 운영하는 사람으로써 ECS 를 사용해보고 싶었기 때문입니다.. 흑흑..</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/360/1*a0vqnW6cDysc1naDYVJs2A.png" /><figcaption>So Easy</figcaption></figure><p>그러나 ECS 에 띄운 컨테이너가 애플리케이션 크래시가 난 것도 아닌데 가끔 내려갔다가 새로 올라가는 모습이 여럿 관찰되자 (ECS Agent 문제로 보이는데 자세히 살펴보지는 못했습니다) 이를 값싼 EC2 에 Docker 를 깔아서 올리는 쪽으로 방향을 바꿨습니다. 그리고 한 번도 내려가지 않고 임무를 완수해주었습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*HpI0CMCIEKq1Lb6hz5wpaw.png" /><figcaption>3일 전에 봇이 종료된 모습</figcaption></figure><h3>후기</h3><p>이렇게 간단해보이는 것 뒤에도 많은 작업이 필요하다는 것을 새삼 느끼게 되었습니다. 공부를 목적으로 시작한 것이었는데 생각보다 많은 분들께서 팔로우를 해주셔서 놀랐습니다. (그리고 Clojure 공부는 망했다고 합니다) 어느 정도의 사람들이 모이니, 포켓몬 고 출시 소식이 뜰 때마다 알려주시는 분들이 생겼습니다. 어쩌다보니 제가 소식을 사람들로부터 전해듣는 입장이 되더라구요. 그럴 때는 수동으로 트윗을 했습니다. 어쨌든 그와 관련된 소식을 전달해드리는게 이 봇의 목표였기 때문이죠.</p><style>body[data-twttr-rendered="true"] {background-color: transparent;}.twitter-tweet {margin: auto !important;}</style><blockquote class="twitter-tweet" data-conversation="none" data-align="center" data-dnt="true"><p>&quot;포켓몬고, 곧 한국 서비스 한다&quot; <a rel="nofollow" href="https://t.co/qJcSKWFrU3">https://t.co/qJcSKWFrU3</a></p><p>&#x200a;&mdash;&#x200a;<a href="https://twitter.com/pokegostat/status/797984370141212673">@pokegostat</a></p></blockquote><script src="//platform.twitter.com/widgets.js" charset="utf-8"></script><script>function notifyResize(height) {height = height ? height : document.documentElement.offsetHeight; var resized = false; if (window.donkey && donkey.resize) {donkey.resize(height); resized = true;}if (parent && parent._resizeIframe) {var obj = {iframe: window.frameElement, height: height}; parent._resizeIframe(obj); resized = true;}if (window.location && window.location.hash === "#amp=1" && window.parent && window.parent.postMessage) {window.parent.postMessage({sentinel: "amp", type: "embed-size", height: height}, "*");}if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.resize) {window.webkit.messageHandlers.resize.postMessage(height); resized = true;}return resized;}twttr.events.bind('rendered', function (event) {notifyResize();}); twttr.events.bind('resize', function (event) {notifyResize();});</script><script>if (parent && parent._resizeIframe) {var maxWidth = parseInt(window.frameElement.getAttribute("width")); if ( 500  < maxWidth) {window.frameElement.setAttribute("width", "500");}}</script><style>body[data-twttr-rendered="true"] {background-color: transparent;}.twitter-tweet {margin: auto !important;}</style><blockquote class="twitter-tweet" data-conversation="none" data-align="center" data-dnt="true"><p>단독] 내일부터 &#39;포켓몬고&#39; 국내 서비스 개시 (출처 : KBS 뉴스 | 네이버 뉴스) <a rel="nofollow" href="https://t.co/CIzPBaD1e9">https://t.co/CIzPBaD1e9</a></p><p>&#x200a;&mdash;&#x200a;<a href="https://twitter.com/pokegostat/status/823466066185568258">@pokegostat</a></p></blockquote><script src="//platform.twitter.com/widgets.js" charset="utf-8"></script><script>function notifyResize(height) {height = height ? height : document.documentElement.offsetHeight; var resized = false; if (window.donkey && donkey.resize) {donkey.resize(height); resized = true;}if (parent && parent._resizeIframe) {var obj = {iframe: window.frameElement, height: height}; parent._resizeIframe(obj); resized = true;}if (window.location && window.location.hash === "#amp=1" && window.parent && window.parent.postMessage) {window.parent.postMessage({sentinel: "amp", type: "embed-size", height: height}, "*");}if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.resize) {window.webkit.messageHandlers.resize.postMessage(height); resized = true;}return resized;}twttr.events.bind('rendered', function (event) {notifyResize();}); twttr.events.bind('resize', function (event) {notifyResize();});</script><script>if (parent && parent._resizeIframe) {var maxWidth = parseInt(window.frameElement.getAttribute("width")); if ( 500  < maxWidth) {window.frameElement.setAttribute("width", "500");}}</script><p>아무래도 포켓몬 고에 관심을 가지신 분들이 팔로우를 하다보니, 포켓몬 고가 나오고 나서 정보 전달을 해주는 계정으로 바꾸면 안되냐고 하시는 분들도 계셨지만 저는 포켓몬 고 정보를 잘 전달해주실 분들이 새로이 나오지 않을까 생각합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Dw_NPB9P_4HRSMoCtl6jww.png" /><figcaption>포켓몬 고 나왔니 봇에 대한 반응들</figcaption></figure><p>이렇게 포켓몬 고 나왔니? 에 대해서 정리를 해보았습니다. 이제 포켓몬 고도 나왔고, 봇도 할 일이 끝났고, 저도 포켓몬 고를 하러 집 앞에 있는 공원에 나갈 거기 때문에 이만 글을 줄이도록 하겠습니다. 다들 포켓몬 많이 잡으시길 바래요! 궁금한 점이 있으신 분은 <a href="https://twitter.com/angdev_">@angdev</a> 로 멘션 주시면 답변해드리도록 하겠습니다. 감사합니다 :)</p><style>body[data-twttr-rendered="true"] {background-color: transparent;}.twitter-tweet {margin: auto !important;}</style><blockquote class="twitter-tweet" data-conversation="none" data-align="center" data-dnt="true"><p>응</p><p>&#x200a;&mdash;&#x200a;<a href="https://twitter.com/pokegostat/status/823665679438004224">@pokegostat</a></p></blockquote><script src="//platform.twitter.com/widgets.js" charset="utf-8"></script><script>function notifyResize(height) {height = height ? height : document.documentElement.offsetHeight; var resized = false; if (window.donkey && donkey.resize) {donkey.resize(height); resized = true;}if (parent && parent._resizeIframe) {var obj = {iframe: window.frameElement, height: height}; parent._resizeIframe(obj); resized = true;}if (window.location && window.location.hash === "#amp=1" && window.parent && window.parent.postMessage) {window.parent.postMessage({sentinel: "amp", type: "embed-size", height: height}, "*");}if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.resize) {window.webkit.messageHandlers.resize.postMessage(height); resized = true;}return resized;}twttr.events.bind('rendered', function (event) {notifyResize();}); twttr.events.bind('resize', function (event) {notifyResize();});</script><script>if (parent && parent._resizeIframe) {var maxWidth = parseInt(window.frameElement.getAttribute("width")); if ( 500  < maxWidth) {window.frameElement.setAttribute("width", "500");}}</script><h4>글쓴이에 대해서</h4><p><a href="https://twitter.com/angdev_">🍓앙데브🍓 (@angdev_) | Twitter</a></p><p>취미로 프로그래밍 공부하는 사람입니다. 사실 전공도 컴퓨터 과학입니다. 생업으로 Ruby on Rails 를 하고 있지만 언제든지 새로운 걸 공부하고 싶어합니다. Docker 를 열심히 굴리는 중이고, AWS로 인프라 구축하는 것에 재미를 붙였습니다. Kubernetes 와 같은 Orchestration Tool 과 Ruby, Elixir, Javascript, C++ 등에 관심이 많습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=65863f5754fb" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[헉 잘못 썼군요.. 감사합니다 (_ _)]]></title>
            <link>https://medium.com/@angdev/%ED%97%89-%EC%9E%98%EB%AA%BB-%EC%8D%BC%EA%B5%B0%EC%9A%94-%EA%B0%90%EC%82%AC%ED%95%A9%EB%8B%88%EB%8B%A4-26c78fb672f?source=rss-4c658aab8997------2</link>
            <guid isPermaLink="false">https://medium.com/p/26c78fb672f</guid>
            <dc:creator><![CDATA[홍철주 (angdev)]]></dc:creator>
            <pubDate>Mon, 02 Jan 2017 10:25:59 GMT</pubDate>
            <atom:updated>2017-01-02T10:25:59.535Z</atom:updated>
            <content:encoded><![CDATA[<p>헉 잘못 썼군요.. 감사합니다 (_ _)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=26c78fb672f" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SPA 초기 로딩 속도 개선하기]]></title>
            <link>https://medium.com/little-big-programming/spa-%EC%B4%88%EA%B8%B0-%EB%A1%9C%EB%94%A9-%EC%86%8D%EB%8F%84-%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0-9db137d25566?source=rss-4c658aab8997------2</link>
            <guid isPermaLink="false">https://medium.com/p/9db137d25566</guid>
            <category><![CDATA[react]]></category>
            <category><![CDATA[front-end-development]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[webpack]]></category>
            <category><![CDATA[performance]]></category>
            <dc:creator><![CDATA[홍철주 (angdev)]]></dc:creator>
            <pubDate>Mon, 02 Jan 2017 10:17:32 GMT</pubDate>
            <atom:updated>2017-01-02T10:24:54.100Z</atom:updated>
            <content:encoded><![CDATA[<h4>Code Splitting &amp; Chunking</h4><h4>TL;DR</h4><ul><li>초기 로딩 시간 개선을 위해 Chunking 을 해보자</li><li>Webpack 을 활용하면 Code Split 을 쉽게 할 수 있다</li><li>Chunk Optimization 을 통해서 효과를 극대화시키자</li></ul><p>이 글은 이전 글인 <a href="https://medium.com/little-big-programming/spa-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9A%A9%EB%9F%89-%EC%96%B4%EB%94%94%EA%B9%8C%EC%A7%80-%EC%A4%84%EC%9D%BC-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C-69c7e05bb3b3#.pc40shp85"><strong><em>SPA 스크립트 용량 어디까지 줄일 수 있을까</em></strong></a><em> </em>의 내용 중</p><blockquote><em>초기 로딩 시간 (하얀 화면 보는 시간) 을 줄이기 위해서 스크립트 쪼개기 (Chunking) 등의 방법은 향후에 다시 논의</em>하려고 한다.</blockquote><p>라는 이야기로부터 비롯된 글입니다. 그리고 글 작성 편의상 경어를 생략한 점 알려드립니다.</p><p>스크립트 용량을 많이 줄였더라도 직접 작성한 코드 용량은 운영하면서 날로 커져만 갈 것이다. 그와 함께 초기 로딩 시간 역시 점점 길어질 것이다. 그렇다면 초기 로딩 시간을 줄이기 위해서는 <strong>화면 별로 필요한 모듈</strong>만 담아서 서빙하는 것은 어떨까 하는 생각에 도달하게 된다. 이 방법은 어찌보면 최종 스크립트 용량은 커질 수 있다. 왜냐하면 나눠진 모듈끼리 서로 중복된 모듈이 있을 수 있기 때문이다. 하지만 단일 스크립트 용량은 현저히 줄어들게 될 것이다.</p><p>모듈을 어떤 기준 (여기서는 화면) 으로 나누는 것을 <strong>Chunking</strong> 이라고 부르는데 이는 많은 곳에서 이미 사용되고 있다. 가까이서 볼 수 있는 예시 중 하나로 Instagram 이 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Crpl85SI832rREfoG2soHg.png" /><figcaption>Landing Page 소스 중 일부</figcaption></figure><p>Commons.js 에 공통 모듈 및 패키지를 담고 LandingPage.js 에는 Landing Page 와 관련된 React Component 들이 있음을 짐작해볼 수 있다.</p><p>이 글에서는 React Router + Webpack 을 사용한 케이스에 대해 코드 나누기에 대해서 다뤄보려한다. 그 전에 Static import 와 Dynamic import 에 대해서 살펴볼 필요가 있다.</p><h4>Static Import &amp; Dynamic Import</h4><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/import">Static Import</a> 는 import <em>name</em> from “<em>module-name</em>”; 과 같이 import 로 시작하는 구문이며, 모두들 잘 사용하고 있는 그것이다. 이는 빌드 타임에 정적으로 의존성이 분석되며, 만들어진 번들에 관련 모듈이 포함된다. 특히나 ES6 Native Module 을 지원하지 못하는 Webpack 1 에서는 주로 commonjs 방식에 따라 스크립트 파일 전체가 번들에 포함되게 된다. (관련 내용을 <a href="https://medium.com/little-big-programming/spa-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9A%A9%EB%9F%89-%EC%96%B4%EB%94%94%EA%B9%8C%EC%A7%80-%EC%A4%84%EC%9D%BC-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C-69c7e05bb3b3">논의한 적</a>이 있으니 참고)</p><p>Dynamic Import 의 경우는 이름 그대로 동적으로 모듈을 불러오는 것이라 생각해볼 수 있다. 이는 <em>ES6 Native 로는 사용할 수 없고</em>, Webpack 과 같은 모듈 로더에서 <a href="https://webpack.github.io/docs/code-splitting.html">정의된 방식</a>을 따르는 것으로 사용할 수 있다.</p><p>AMD (Asynchronous Module Definition) 같은 경우는 그 이름에서도 드러나듯이 비동기적으로 모듈을 불러올 수 있다. Webpack 을 통하면 commonjs 를 따르면서도 비동기적으로 모듈을 불러올 수 있게 해주니, 여기서는 commonjs 를 따르도록 하겠다.</p><blockquote>사실 Dynamic Import 표준에 대한 Draft 가 Stage 3 에 있으며 <a href="https://github.com/tc39/proposal-dynamic-import">tc39/proposal-dynamic-import</a> 에서 관련 내용을 살펴볼 수 있다. Static Import 와 다르게 Dynamic Import 는 import 라는 이름의 메서드를 호출하는 것으로 사용할 수 있게 될 전망이다. Webpack 2 에서는 System.import 구문을 사용하는 것으로 이를 사용할 수 있게 해두었지만 아직 Webpack 2 는 RC 단계에 있다.</blockquote><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/db02c37565dcdfeead19feddcb56329b/href">https://medium.com/media/db02c37565dcdfeead19feddcb56329b/href</a></iframe><p>Webpack 에서는 어떻게 Dynamic Import 를 할 수 있게 해주는가? 간단히 설명하면 아래와 같다.</p><p>commonjs manner 에서는 <strong>require.ensure </strong>의 첫 번째 인자로 모듈 리스트를 넣으면 이들 모듈 리스트가 빌드 타임에 정적으로 분석되고, 이들 모듈이 묶여서 Entrypoint 와 다른 Chunk 로 분리되어 만들어진다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f8a72f833ee94906c76dc764895c34fb/href">https://medium.com/media/f8a72f833ee94906c76dc764895c34fb/href</a></iframe><p>이를 다르게 표현해서 Code Split Point 를 정의한다고도 한다. <strong>여기서부터 코드 찢어주세요</strong> 같은 느낌으로 받아들일 수 있을 것 같다. 그 후에 require.ensure 부분은 런타임에 다음과 같은 일을 하게 된다.</p><ul><li>이 Split Point 에서 생성된 스크립트 (Chunk) 를 불러온다 (동적으로 스크립트 태그 등을 추가해서 불러오는 방식을 주로 사용)</li><li>스크립트 로딩이 끝나면 콜백을 호출해서 런타임에 require 를 통해서 모듈을 불러올 수 있게 해준다</li></ul><p>설명한 내용을 그림으로 요약하면 아래와 같다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Z2HJZ_st1GOznA1MemWbIQ.png" /></figure><h4>React Router 와 모듈 로딩</h4><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e016d73daefb79b4dae7730573200c4a/href">https://medium.com/media/e016d73daefb79b4dae7730573200c4a/href</a></iframe><p>대체적으로 React Router 를 쓰면 위와 같은 형태로 사용하게 된다. 그럼 여기서 component 는 어디서 왔는가라고 묻는다면 당연히 static import 를 통해 온 것이다. Route 의 Component 중에서 특별히 커다란 컴포넌트가 있다면 이 지점은 훌륭한 Split Point 가 될 것이다. 그런데 동적으로 모듈을 불러온다는 것은 비동기적으로 컴포넌트가 주입되어야 하는데 React Router 는 이를 허용하는가? 라고 한다면 <a href="https://github.com/ReactTraining/react-router/blob/master/docs/API.md#getcomponentnextstate-callback">다행히도 허용</a>하고 있다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/a52c93cd1c33c1668cb72995c3becdf7/href">https://medium.com/media/a52c93cd1c33c1668cb72995c3becdf7/href</a></iframe><p>getComponent 라는 props 가 있고, cb 라는 이름의 콜백에 불러온 컴포넌트를 넘겨줄 수 있도록 되어있다. 이제 일은 간단하다. 위의 getComponent 부분에 require.ensure 를 통해 불러온 모듈을 가져갈 수 있게 해주면 될 일이다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/2d3acf8444bb0878cc9de6810722cbc3/href">https://medium.com/media/2d3acf8444bb0878cc9de6810722cbc3/href</a></iframe><p>결과적으로 아래와 같이 코드를 수정하게 된다. 이렇게 해주면 Webpack 에서 Chunk 를 알아서 만들어주고, 생성되는 번들을 같이 CDN 등에 올려주면 추가적인 작업 없이도 잘 작동한다. (필자는 Webpack 2 를 beta 때부터 쓰면서 System.import 로 이를 구현했다)</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/b5b1c8a18031b33feb55eeec31b06f92/href">https://medium.com/media/b5b1c8a18031b33feb55eeec31b06f92/href</a></iframe><h4>Chunk Optimization</h4><p>단순히 Code Split Point 를 정의하는 것으로 끝나면 좋겠지만, 앞으로 더 나아가기 위해서는 Chunk 를 최적화할 필요가 있다. 다양한 최적화 요인이 있지만 몇 가지만 살펴보면 아래와 같을 것이다.</p><ul><li>각 모듈에서 자주 쓰이는 모듈들은 각 Chunk 별로 중복되어 들어있을 것이다</li><li>너무 작은 Chunk 는 쓸데없는 HTTP 요청에 따른 Overhead 를 발생시킨다</li><li>너무 큰 Chunk 는 긴 로딩 시간을 가진다</li></ul><p>Webpack 은 Chunk 최적화를 시도할 수 있도록 플러그인을 제공하고 있다. <a href="https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin">CommonsChunkPlugin</a>, <a href="https://webpack.github.io/docs/list-of-plugins.html#minchunksizeplugin">MinChunkSizePlugin</a>, <a href="https://webpack.github.io/docs/list-of-plugins.html#limitchunkcountplugin">LimitChunkCountPlugin</a>, <a href="https://webpack.github.io/docs/list-of-plugins.html#aggressivemergingplugin">AggressiveMergingPlugin</a> 등이 그것이다.</p><p>이 중에서 가장 사용하기 좋으며 간편한 것은 CommonsChunkPlugin 이다. Code Split 으로부터 생긴 Chunk 들에서 공통으로 참조하는 모듈들을 Parent Chunk 로 밀어넣는 방식이나, 이를 Parent Chunk 에 밀어넣지 않고 따로 분리하되 Children Chunk 와 동시에 로딩하도록 할 수 있다. (<a href="https://webpack.github.io/docs/list-of-plugins.html#3-move-common-modules-into-the-parent-chunk">Example 3</a>, <a href="https://webpack.github.io/docs/list-of-plugins.html#4-extra-async-commons-chunk">Example 4</a>)</p><p>Code Split 에 의해 만들어진 Chunk 들에서 자주 쓰는 라이브러리들은 명시적으로 분리해주는 것도 좋다. 예를 들어 ‘react’, ‘lodash’ 등이 이에 해당할 수 있다. (<a href="https://webpack.github.io/docs/list-of-plugins.html#2-explicit-vendor-chunk">Example 2</a>) 특히 Vendor Chunk는 거의 변하지 않을 것이기 때문에 새 버전을 배포하더라도 클라이언트에서는 이 Chunk에 대한 캐시를 활용할 수 있어 빠른 로딩이 가능할 수 있다.</p><p>그 다음에 해볼 수 있는 것으로는 minChunks 값을 설정해서 N개 이상의 모듈에서 공유된 모듈을 chunk 로 만드는 것이다. (<a href="https://webpack.github.io/docs/list-of-plugins.html#1-commons-chunk-for-entries">Example 1</a>) 이는 커다란 Entry 스크립트의 크기를 줄이는 데에 용이하다. minChunks 값은 여러 값을 테스트해보면서 생성되는 chunk 를 <a href="https://webpack.github.io/analyse/">Webpack analyzer</a> 등을 통해서 살펴보는 것이 좋다. <a href="https://github.com/th0r/webpack-bundle-analyzer">webpack-bundle-analyzer</a> 가 살펴보기는 더 편한 것 같다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/908/1*dusVhPiL44VDoS4gJHMWSg.gif" /><figcaption>webpack-bundle-analyzer</figcaption></figure><p>이외에도 MinChunkSizePlugin, LimitChunkCountPlugin 등은 사용법도 명백하고, 필자는 사용하지 않았기에 따로 언급하지는 않겠다.</p><blockquote>Chunk 최적화에 대해서 더 잘할 수 있는 방법을 알고 계신 분은 제게도 꼭 알려주시면 감사하겠습니다 (_ _)</blockquote><h4>Chunking 효과 측정</h4><p>Chunking 을 하면 단순히 entry 스크립트의 용량이 줄어드는 효과도 있지만, [entry, vendor, chunk] 를 동시에 요청할 수 있게 (load chunks parallel) 되는 것도 큰 장점이다. 모든 방면에서 최적으로 하기는 쉽지 않지만 사용자 경험 측면에 있어서는 충분히 개선을 할 수 있을 것이라 생각한다.</p><p>결과를 측정할 수 있는 방법에는 여러 가지가 있겠으나, 간단히는 Chrome Inspector 에서 Network throttling 을 주고 로딩을 해볼 수 있다. 이 때 Timeline 부분도 함께 보면 좋다. 아마 긴 로딩 막대 하나가 몇 개로 나뉘어져 동시에 로딩되는 모습을 볼 수 있을 것이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/676/1*KvBMcjApum3CzGapAF6O8Q.png" /></figure><p>그리고 실제 화면이 언제부터 그려지기 시작했나 등은 Network 탭 옆에 있는 Timeline 탭을 살펴보면 된다. Screenshots 부분을 체크하고 리로드해보면 된다. 하얀 화면이 나오다가 언제부터 그려지기 시작하는지에 유의해서 살펴보자. 그런데 아래 스크린샷을 무조건 신뢰하기는 힘들 것 같다. 제대로 원인 파악을 해보지 못했으나 캐싱이 되어있는지 실제와 다르게 나오는 경우도 있었다. 스크린샷과 함께 그래프도 유의해서 살펴볼 필요가 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*x2Fd4D6d2ZLHrWgGQlTuDw.png" /></figure><p>이와 더불어 실제 사용자가 봤을 때는 어떻게 보일지가 궁금한 경우에 <a href="https://www.webpagetest.org/">WebPageTest</a> 를 활용하면 좋다. 여러 번 사이트에 접속해서 렌더링을 수행한 후에 이에 대한 보고서 및 스크린샷, 비디오 등을 만들어준다. 아래 표의 경우에서는 <strong>Start Render</strong> 를 살펴보자. 그 이전까지는 스크립트 로딩 시간이 큰 영향을 줬을 것이다. (Parsing, Styling 등에 대한 시간인지는 타임라인 그래프가 따로 제공되니 확인할 수 있다)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*OTajGOOSKfWMH3DqKoI7bg.png" /><figcaption>WebPageTest — Performance Results</figcaption></figure><p>이 뿐만 아니라 Visual Progress, 각종 시간 지표 측정, 페이지에서 일어나는 요청 수, 요청하는 바이트 수 등까지 정리해주고 있으니 이번 기회가 아니라도 페이지 최적화에 많은 도움을 줄 것이다. 이런 정말 좋은 툴이 공짜로 사용할 수 있도록 열려있다는게 놀랍다.</p><h4>마무리</h4><p>초기 로딩 속도를 잡아먹는 요인으로는 여러 가지가 있을 수 있습니다.. 비단 스크립트 크기 뿐만 아니라, 실제 렌더링이 이루어지기 전에 foo sdk, bar sdk 초기화 라거나, 데이터가 있어야 렌더링이 되도록 코드가 작성되었다거나 등의 요인이 있을 수 있죠. 이번에는 이들 사례를 제외하고 공통적으로 적용할 수 있을 것 같은 방법에 대해 이야기를 해보았습니다. (앞의 사례는 필자가 이상하게 짜서 겪었던..) 이번 글에서 제시한 방법과 위에서 언급된 각종 멋진 성능 측정, 시각화 도구 등을 잘 활용해서 기존보다 더 나은 사용자 경험을 제공할 수 있으리라 생각합니다. 필자의 경우도 많은 실험과 삽질을 통해서 이를 개선하려고 노력해보았고, 그 때 시도해보았던 것들을 정리한 것입니다.</p><p>이 글이 많은 분들께 도움이 됐으면 좋겠습니다. 피드백은 언제나 환영합니다. <a href="http://twitter.com/angdev_">@angdev</a> 로 멘션 주시면 감사하겠습니다 (_ _) 궁금하시거나 이야기하고 싶은 점이 있으신 분은 <a href="https://gitter.im/little-big-programming/Lobby">Little Big Programming Gitter</a> 에서 이야기 나눠요!</p><p><a href="https://gitter.im/little-big-programming/Lobby">little-big-programming/Lobby</a></p><h4>글쓴이에 대해서</h4><p>이번에도 Frontend 에 대한 글을 쓰긴 했지만 원래는 Backend 에 더 힘을 쏟고 싶은 사람입니다. 생업으로 Ruby on Rails 를 하고 있습니다. Docker 를 열심히 굴리는 중이고, AWS로 인프라 구축하는 것에 재미를 붙였습니다. Kubernetes 와 같은 Orchestration Tool 과 Ruby, Elixir, Javascript, C++ 등에 관심이 많습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9db137d25566" width="1" height="1"><hr><p><a href="https://medium.com/little-big-programming/spa-%EC%B4%88%EA%B8%B0-%EB%A1%9C%EB%94%A9-%EC%86%8D%EB%8F%84-%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0-9db137d25566">SPA 초기 로딩 속도 개선하기</a> was originally published in <a href="https://medium.com/little-big-programming">little big programming</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[내가 fetch API를 쓰지 못했던 이유]]></title>
            <link>https://medium.com/little-big-programming/%EB%82%B4%EA%B0%80-fetch-api%EB%A5%BC-%EC%93%B0%EC%A7%80-%EB%AA%BB%ED%96%88%EB%8D%98-%EC%9D%B4%EC%9C%A0-3c23f0ec6b82?source=rss-4c658aab8997------2</link>
            <guid isPermaLink="false">https://medium.com/p/3c23f0ec6b82</guid>
            <category><![CDATA[fetch]]></category>
            <category><![CDATA[ajax]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[promises]]></category>
            <dc:creator><![CDATA[홍철주 (angdev)]]></dc:creator>
            <pubDate>Wed, 21 Dec 2016 06:07:32 GMT</pubDate>
            <atom:updated>2016-12-21T08:03:51.982Z</atom:updated>
            <content:encoded><![CDATA[<h4>fetch API 는 완벽한가?</h4><h4>TL;DR</h4><ul><li>많은 API 요청이 있는 SPA에선 페이지 전환 시 요청을 취소해주자</li><li>모든 라이브러리가 AJAX 요청 취소를 지원하지는 않는다</li><li>fetch API 는 요청을 취소할 수 있는 기능을 제공하지 않는다</li></ul><blockquote>글 작성 편의상 경어를 생략하였음을 미리 알려드립니다.</blockquote><p>SPA 형태의 앱은 주로 서버와 API 로 데이터를 주고 받으면서 화면을 그리게 된다. 한 페이지에서 API 요청이 끝나지 않았는데 페이지를 떠나는 경우를 생각해보자. <strong>당신이 지금 만들고 있는 앱은 기존 요청을 취소하는가?</strong> 한 페이지에서 많은 수의 요청을 부르거나 적은 수의 요청을 하더라도 응답 속도가 느린 경우에 이는 문제가 될 수 있다. MPA (Multi Page Application) 와 다르게 이전 페이지에서 끝나지 않은 요청이 다음 페이지에서 이어지기 때문인데, 일반적으로 웹 브라우저에서 동시에 요청할 수 있는 요청의 수는 6개 정도로 제한되어 있다. 다음 페이지에서 필요한 요청이 계속 Stale 되면 페이지 렌더링이 안되기 때문에 이는 사용자 경험 저하로 이어진다. (혹은 사용자로 하여금 새로고침을 하게 만들면 된다.) React 앱이라면 뒤늦게 액션이 생성되어 상태 업데이트를 해대느라 느려지기도 한다.</p><p>이 문제는 서버 관점과 클라이언트 관점 두 가지로 나누어서 해결할 수 있다. 첫 번째 방법은 서버 응답이 빨라지도록 하거나 요청 수가 적어지도록 응답 모델을 디자인하는 것이다. 하지만 우리는 서버 개발자를 괴롭히지 않는 멋진 개발자이니 원론적으로 두 번째 방법인 요청을 취소하는 것에 대해서 이야기를 해볼 것이다. 필자의 경험에 기초를 두고 글을 전개할 것이므로 <strong>React + React Router + Redux</strong> 기반으로 이를 구현하는 것에 대해 이야기를 해보려고 한다.</p><h4>문제의 파악</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/826/1*Ey9SwAlHjUr-shvCusphmg.png" /><figcaption>많은 수의 요청이 해결되지 못하고 있는 상태 (극단적인 상황이지만)</figcaption></figure><p>한 페이지에서 불리는 API 가 많은데, 많은 페이지 전환이 일어나는 경우에 위와 같은 상황이 현재 페이지에 필요한 API 요청이 끝나지 못하고 Pending 되어 있는 것을 목격할 수도 있다. 페이지 전환 시에는 전환 전에 불렸던 API 들은 취소해줄 필요가 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/848/1*bWNUYrF-BkZjoZAr3wY3tQ.png" /><figcaption>취소가 되면 바로 현재 페이지의 요청을 처리할 수 있다</figcaption></figure><h4>문제의 해결</h4><p>필자의 경우에는 아래와 같이 액션을 통해 API 를 요청하였다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/872/1*IUOvwvV0mpPxPPiP-C18Gg.png" /><figcaption>이 방식은 <a href="https://github.com/reactjs/redux/tree/master/examples/real-world">redux real-world example</a> 에서 참고할 수 있다</figcaption></figure><p>이를 redux apiMiddleware 등에서 잡아서 실제 요청을 생성하는 방식으로 구현하였다. 그렇다면 이 때 생성되는 XHRHttpRequest 에 준하는 abortable request object 를 보관하고 있다가 (Requests) 다음 페이지 로딩이 될 때 이를 순회하며 abort 후 제거하면 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*T1v7D79x17hywWu054F_tA.png" /></figure><p>react-router 와 <a href="https://github.com/reactjs/react-router-redux">react-router-redux</a> 를 쓰는 경우에는 location change 에 대한 액션을 받을 수 있기 때문에, 이에 반응하도록 구현할 수 있다. 간단히 아래와 같이 구현해볼 수 있다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/300197344515ecbee940b8cda0429bd5/href">https://medium.com/media/300197344515ecbee940b8cda0429bd5/href</a></iframe><h4>추가적인 고려사항</h4><p>API Request 액션에 대해서 Optimisitic update 를 하는 경우라면 이를 Rollback 해줘야 할 것이므로 Optimistic update rollback 을 유발하는 액션을 내보내는 등의 작업이 필요할 수 있다. 즉 side-effect 가 없을지 충분히 고려할 필요가 있다.</p><h4>혹시 fetch API를 쓰고 있다면</h4><p>API 요청의 취소는 간단하다. <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a> 에서 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/abort">abort</a> 메서드를 제공하고 있기 때문에 이를 호출하는 것으로 취소시킬 수가 있다. 혹은 라이브러리에서 제공하는 메서드를 사용하면 될 것이다.</p><p>하지만 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">fetch API</a> 에서는 요청을 취소할 방법이 없다! 놀랍게도 이는 현재 (2016년 12월) 까지 <a href="https://github.com/whatwg/fetch/issues/27">사실</a>이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/972/1*Y-ZCWcnFxBJjE_-CB5ILdA.png" /><figcaption>2015년 3월부터 현재까지 논의 중이다 (313 개의 댓글…)</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*8dW7M_lyJU3XLLvOVgh0Hg.png" /><figcaption>필자도 믿기지 않는다</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*2-c_8k6Vm3ETL5jowhM9Qw.png" /><figcaption>“fetch 스펙이 정말로 불완전하다는 것을 보여주고 있다” 라는 의견도 있다</figcaption></figure><p>기본적으로 fetch API 는 Promise 기반으로 동작하는데, 아직 Promise 를 취소할 수 있는 방법이 제시되지 못한 것도 이 문제가 빨리 풀리지 못하는데에 한몫을 하고 있다. 이는 <a href="https://github.com/tc39/proposal-cancelable-promises">Cancelable Promise</a> 가 등장하는 것으로 좀 정리가 될 수 있지 않을까 기대를 하고 있었으나 <strong>안타깝게도 2016년 12월 16일자로 이 Proposal 이 철회</strong>됐다. fetch가 아닌 다른 Promise 기반의 ajax 라이브러리인 <a href="https://github.com/mzabriskie/axios">axios</a> 는 Cancelable Promise 형태로 이를 <a href="https://github.com/mzabriskie/axios#cancellation">구현해두었다</a>.</p><p>만약 abort 를 해야할 필요성을 느낀다면 어쩔 수 없다. fetch API 에서 <a href="https://github.com/mzabriskie/axios">axios</a> 나 <a href="https://github.com/visionmedia/superagent">superagent</a> 과 같은 다른 라이브러리로 변경해야 한다.</p><h4>결론</h4><p>fetch API 는 server, client 에서 간편하게 사용이 가능하지만 요청 취소가 불가능하는 등의 아쉬운 점이 있어 요청 취소 기능이 필요한 경우가 있다면 다른 라이브러리를 고려해보는 것이 좋겠다.</p><p>이 글이 많은 분들께 도움이 됐으면 좋겠습니다. 피드백은 언제나 환영합니다. <a href="http://twitter.com/angdev_">@angdev</a> 로 멘션 주시면 감사하겠습니다 (_ _) 궁금하시거나 이야기하고 싶은 점이 있으신 분은 <a href="https://gitter.im/little-big-programming/Lobby">Little Big Programming Gitter</a> 에서 이야기 나눠요!</p><p><a href="https://gitter.im/little-big-programming/Lobby">little-big-programming/Lobby</a></p><h4>글쓴이에 대해서</h4><p>이번에도 Frontend 에 대한 글을 쓰긴 했지만 원래는 Backend 에 더 힘을 쏟고 싶은 사람입니다. 생업으로 Ruby on Rails 를 하고 있습니다. Docker 를 열심히 굴리는 중이고, AWS로 인프라 구축하는 것에 재미를 붙였습니다. Kubernetes 와 같은 Orchestration Tool 과 Ruby, Elixir, Javascript, C++ 등에 관심이 많습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3c23f0ec6b82" width="1" height="1"><hr><p><a href="https://medium.com/little-big-programming/%EB%82%B4%EA%B0%80-fetch-api%EB%A5%BC-%EC%93%B0%EC%A7%80-%EB%AA%BB%ED%96%88%EB%8D%98-%EC%9D%B4%EC%9C%A0-3c23f0ec6b82">내가 fetch API를 쓰지 못했던 이유</a> was originally published in <a href="https://medium.com/little-big-programming">little big programming</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SPA 스크립트 용량 어디까지 줄일 수 있을까]]></title>
            <link>https://medium.com/little-big-programming/spa-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9A%A9%EB%9F%89-%EC%96%B4%EB%94%94%EA%B9%8C%EC%A7%80-%EC%A4%84%EC%9D%BC-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C-69c7e05bb3b3?source=rss-4c658aab8997------2</link>
            <guid isPermaLink="false">https://medium.com/p/69c7e05bb3b3</guid>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[optimization]]></category>
            <category><![CDATA[webpack]]></category>
            <category><![CDATA[frontend]]></category>
            <category><![CDATA[sap]]></category>
            <dc:creator><![CDATA[홍철주 (angdev)]]></dc:creator>
            <pubDate>Wed, 24 Aug 2016 05:40:21 GMT</pubDate>
            <atom:updated>2016-08-26T08:51:15.963Z</atom:updated>
            <content:encoded><![CDATA[<h4>최대한 줄여보고자 하는 당신을 위한 안내서</h4><h4>TL;DR</h4><ul><li><a href="http://www.mikeperham.com/2016/02/09/kill-your-dependencies/">Kill Your Dependencies</a></li><li>닭 잡는데 소 잡는 칼을 쓰지 말자</li><li>동적 Require 가 사용되는 경우에는 힌트를 주자</li><li>ES2015+ Native Import/Export 에 대해 제대로 알고 사용하면 공짜 점심이 기다린다</li></ul><blockquote>글 작성 편의상 경어를 생략하였음을 미리 알려드립니다.</blockquote><p>요즘에 React니 Angular니 하며 SPA (Single Page Application) 가 점점 늘어가는 추세인데, 그와 함께 많은 사이트들의 스크립트 용량 역시 늘어가고 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*VBZAb9pB5_3U81vE3b61zQ.png" /><figcaption>2014.08 ~ 2016.08 JS Transfer Size &amp; JS Requests (<a href="http://httparchive.org/trends.php?s=All&amp;minlabel=Aug+1+2014&amp;maxlabel=Aug+1+2016">link</a>)</figcaption></figure><p>기존에 html 파일로 서빙되던 마크업 조차도 스크립트에 포함되어 마크업 용량을 흡수한 데에 이어, SPA의 특성상 웹앱 전체가 한 스크립트를 통해서 서빙되는 경우도 부지기수이다. 주기적으로든 서비스 오픈 전이든 클라이언트 성능 테스트를 거치게 되면서 “코드 사이즈가 이렇게 컸었나?” 하는 점을 초기 로딩 속도 등을 통해서 경험하는 경우가 많은데, 그럴 때 적용해볼 수 있는 방법과 그와 관련된 주변 지식에 대해서 다뤄보려 한다.</p><p>이 글에서는 스크립트 자체의 용량을 줄이는 것에 대해 먼저 중점적으로 다룰 것이다. <em>초기 로딩 시간 (하얀 화면 보는 시간) 을 줄이기 위해서 스크립트 쪼개기 (Chunking) 등의 방법은 향후에 다시 논의</em>하려고 한다. ES2015+를 사용하면서 Transpiler로 <em>Babel</em>, Bundler로 <em>Webpack</em>, Library로 <em>React</em>를 쓴 상황을 예시로 들어 설명할 것이지만 다른 케이스에도 유사하게 적용할 수 있는 방법이 반드시 있을 것이라 생각한다.</p><h3>상황 진단하기</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/368/1*CgmUpC-Su64q5oo1fb6VnA.png" /><figcaption>똑같은 단일 스크립트 361, 4.44s (!)</figcaption></figure><p>위 스크린샷은 no throttling 인 경우의 상황이고 아래 상황은 3G Regular (750kb/s ~ 250kb/s) 로 속도 제한을 로딩을 한 것이다. 비교적 극단적으로 상황이 꾸며졌지만 스크립트 로딩 시간 동안에 유저는 빈 화면을 보게 된다. (Server Rendering 에 대한 이야기는 잠시 접어두고 스크립트 감량에 무게를 두도록 하자)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*GobfSFBn-ej4yXMKTisSxw.png" /><figcaption>약 4초 동안 idle 상태가 유지되고 있다</figcaption></figure><p>참고로 위 스크린샷에서 361 KB 라고 나오긴 했지만 gzipped(!) 라는 점을 일러둔다. gzipped 전에는 1.3MB 정도 된다. 당신도 이런 상황을 맞이하였다면 이 글이 도움이 되길 바란다.</p><p>다른 SPA 사이트들의 상황이 궁금할 지도 모르겠다. 예시로 인스타그램은 이 정도 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*j4--5DIEyU_PTZf1VMFSJA.png" /><figcaption>인스타그램 Landing Page</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*B9g1VLOGdeKulBYfxTHK_w.png" /><figcaption>인스타그램 소스 중 일부</figcaption></figure><p>여기는 스크립트가 화면별로 쪼개져있을 것으로 예상할 수 있다. React 를 포함한 각종 공통 패키지가 Commons.js 아래에, Landing Page 와 관련된 컴포넌트가 담긴 스크립트가 LandingPage.js 아래에 있는 것으로 예상된다. 둘만의 용량만 따진다면 넉넉잡아 200KB 정도 된다.</p><p>다른 사이트의 예시도 보았고 다시 자신의 상황을 살펴보자. 내가 작성한 스크립트가 저렇게 커질리가 없는데, 그 원인이 어디 있을까? 라고 생각했다면 <strong>첫 번째로는 무분별한 패키지 사용</strong>이 있을 수 있다. <strong>두 번째는 잘못된 module import (require)</strong> 가 있을 수 있다. 그리고 이 글에서 중점적으로 다룰 것은 아니나 Webpack 빌드 설정 등이 잘못되었을 수도 있다. 먼저 무분별하게 사용한 패키지를 손보자.</p><h3>무분별하게 사용한 패키지 제거하기 혹은 대체하기</h3><p>가장 먼저 이 방법을 적용해보려면 하는 일에 비해 용량을 크게 잡아먹고 있는 패키지를 발견해내는 것이 중요하다. 다행히도 Webpack 에서는 이를 쉽게 발견할 수 있도록 분석 도구를 제공하고 있다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9dbd388b0b16402383f91df1cb6c1e20/href">https://medium.com/media/9dbd388b0b16402383f91df1cb6c1e20/href</a></iframe><p>위 명령으로 생성된 stat.json 파일을 <a href="https://webpack.github.io/analyse/">https://webpack.github.io/analyse/</a> 에 업로드하면 모듈 의존성, 청크, 빌드 경고, 빌드 에러, 모듈 리팩토링과 관련된 힌트 등에 해당하는 많은 정보를 얻을 수 있다. 여기서 먼저 주목할 부분은 Modules 에 해당하는 부분이다. 그러면 먼저 모듈 의존성 그래프와 함께 각 모듈 파일 정보에 대한 정보가 아래에 나열된 화면을 볼 수 있을 것이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*NrfxQhNlBvM-xprdY1Tatg.png" /><figcaption>거대한 모듈 의존성 그래프</figcaption></figure><p>이 화면에서 먼저 큰 파일을 찾기 위해서 ‘Kib’ 같은 키워드로 검색을 하면서 노다지 찾는 기분으로 하나씩 찾아보면 노다지를 진짜 발견할 수도 있다. 아래처럼 말이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*0msOlkx9IPrvctLjU82XgQ.png" /><figcaption>Bingo!</figcaption></figure><p>이런 모듈을 찾았을 때의 대처는 순전히 개발자의 몫이다. 예를 들어 “jquery 를 더 이상 쓰고 있지 않은데 아직 있네?” 같은 상황이면 바로 제거하면 되는 것이고, “jquery 에서 쓰는 부분이 selector 뿐이었다&quot; 같은 상황이면 jquery 와 호환성이 있는 다른 훨씬 가벼운 selector library로 대체하면 될 일이다. 혹은 라이브러리가 하는 일이 크지 않고 작성할만한 정도라면 패키지를 제거하고 그 일을 하는 코드를 직접 작성하는 것도 좋다. (<a href="http://www.mikeperham.com/2016/02/09/kill-your-dependencies/">Kill Your Dependencies</a>)</p><h3>동적 Require 에 힌트 주기</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*4lSxHI34qYJ2l5gJvLlPdA.png" /><figcaption>moment.js locales</figcaption></figure><p>위 스크린샷은 moment.js 내부의 모듈 중 일부이다. 그런데 보다시피 사용하지 않은 Locale에 대한 모듈을 잔뜩 불러오고 있음을 알 수 있는데 (관련 모듈만 약 100개에 육박한다) moment.js 의 locale 모듈은 아래와 같이 require 된다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/c08755e2553aef787b159d19ac139284/href">https://medium.com/media/c08755e2553aef787b159d19ac139284/href</a></iframe><p>8번째 줄에 있는 require(‘./locale/’ + name) 에서 동적으로 모듈을 require 하는 것을 할 수 있다. 하지만 실제로 어플리케이션 코드에서 로케일을 불러올만한 일은 없었다. 그런데 왜 모든 locale 모듈이 번들링되었는지는 Webpack 이 동적 경로에 대한 require 를 어떻게 처리하는지 알게 되면 이해를 할 수 있다. (<a href="https://github.com/webpack/docs/wiki/context">링크</a>)</p><p>간단하게 설명하면 require(‘./locale/’ + name) 에서 name 부분에 어떤 값이 올지 알 수 없으므로 webpack 에서는 locale 이라는 디렉토리에서 /^.*$/ 에 매칭되는 파일을 모두 require 될 수 있는 후보로 생각하기 때문에 이를 모두 번들에 넣을 수밖에 없다는 것이다. 여기서 <strong>디렉토리 정보와 정규표현식 정보를 연관지어 하나의 Context 라고 지칭</strong>한다.</p><p>한국어 로케일만 필요한 경우라면 <a href="https://github.com/webpack/docs/wiki/context">ContextReplacementPlugin</a> 을 통해서 locale 이라는 디렉토리에서 매칭할 파일에 대한 정규표현식을 아래와 같이 지정해줄 수도 있다. (원래 생성되려고 했던 Context 대신에 직접 생성한 Context 로 대체한다는 의미로 Context Replacement 라고 함)</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/8a88789348e93040150c3deb81d6fa93/href">https://medium.com/media/8a88789348e93040150c3deb81d6fa93/href</a></iframe><p>혹은 로케일이 필요하지 않은 경우는 <a href="https://webpack.github.io/docs/list-of-plugins.html#ignoreplugin">IgnorePlugin</a> 을 통해서 특정 디렉토리에 대한 require 를 무시할 수도 있다.</p><p>혹시나 moment.js 와 같이 locale 정보가 포함된 라이브러리를 사용하고 있다면 locale 과 관련된 스크립트 파일을 위와 같은 방법으로 번들에 포함시키지 않을 수 있다. 단, 바로 잘라도 되는지 판단하는 것은 패키지 소스 파일을 보고 난 당신의 몫이다.</p><h3>잘못된 module import 바로잡기</h3><p>그리고 찬찬히 더 보다보면 의외의 장면을 목격하게 될 수도 있다. 아래와 같이.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*3Ps0-wVwWZQb7zWK6QILwA.png" /><figcaption>import { assign } from ‘lodash’;</figcaption></figure><p>“왜 이런 일이 일어났을까? 나는 최대한 가볍게 쓰려고 모듈 단위로 불러와서 썼는데..” 라는 분들은 아래와 같이 썼을 것이다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/057f24d1d5963fd12bfaef2152933959/href">https://medium.com/media/057f24d1d5963fd12bfaef2152933959/href</a></iframe><p>그런데 왜 assign 함수만 따로 가져오지 않고 전체 모듈을 다 불러왔을지 궁금하다면 babel 과 webpack 이 module resolve 를 어떻게 하는지 살펴볼 필요가 있다. 그 전에 몇 가지 배경을 알고 넘어가면 좋을 것 같다.</p><h4>ES2015(ES6) 와 commonjs</h4><p>자바스크립트의 모듈 시스템이 발달하게 된 것은 node.js 의 등장 이후라고 여겨진다. node.js 에서는 require 함수를 통해서 다른 파일의 모듈을 불러오게 되는데, 이를테면 아래와 같이 말이다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/36658f78127eb54c0319a4ca62e426bd/href">https://medium.com/media/36658f78127eb54c0319a4ca62e426bd/href</a></iframe><p>node.js 의 라이브러리 제작자들은 (특히 lodash 와 같은 유틸리티성 라이브러리들) 사용 편의성과 단일 모듈 로딩 등을 위해 각 메서드는 여러 파일로 쪼개서 작성하되, 최종적인 메서드들은 하나의 객체로 제공하는 방식을 선호하였다. 그래야 한 번 모듈을 로딩해서 편하게 쓸 수 있을 뿐만 아니라 chaining 과 같은 테크닉을 제공하기 쉽기 때문이다.</p><p>그리고 node.js 에서는 각 모듈에서 export 된 것들을 한 번에 불러왔기에 아래와 같은 사용을 허용하였다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/954e5518c13c53b3bd840be00a86b2b4/href">https://medium.com/media/954e5518c13c53b3bd840be00a86b2b4/href</a></iframe><p>즉 모듈 단위로 export 하는 기능이 언어 레벨에서 제공되지 않았기에 Object에 담아 모듈들을 export 하는 식으로 구현이 되어 있고, 사용하는 측에서도 단순히 Object 에 접근하는 것으로 모듈을 꺼내 쓸 수 있었다. 이런 구현이니 반드시 사용하는 쪽에서는 Object 전체를 불러올 수밖에 없는 구조이다. 이렇게 구현된 모듈 시스템을 흔히 commonjs 라고 부른다. (CJS require)</p><p>다행히도 (?) commonjs 시스템을 사용하는 스크립트들은 주로 서버사이드에서만 사용되었기에 용량과 같은 문제는 크게 대두되지 않았다.</p><p>비교적 최근에 와서 ES2015 (ES6) 표준에 module import 와 export 에 대한 명세가 추가되었으나 이를 이용해서 구현한 라이브러리 코드도 적거니와 이를 각종 자바스크립트 엔진에서 곧바로 지원하지는 못했기에 babel 과 같은 transpiler 에서는 이를 기본적으로 commonjs 시스템에 따라 ES5 코드 등으로 변환해주었다. 그래서 모듈을 어떻게 resolve를 해주었는지 살펴보면-</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d0a41eae728dd14435310591c097df2a/href">https://medium.com/media/d0a41eae728dd14435310591c097df2a/href</a></iframe><p>위와 같이 해석되기 때문에 메서드 단위로 import를 해도 전체 모듈이 딸려오는 경우가 생기는 것이다. 그렇다고 하면 어떻게 해야 하는가?</p><p>lodash 의 경우는 단일 메서드를 사용하는 경우가 많아서 클라이언트에서 사용할 때는 각 메서드를 직접 import 해서 사용할 수 있도록 해두었다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/30d84ca1212fd44c3aebc300c831ecc5/href">https://medium.com/media/30d84ca1212fd44c3aebc300c831ecc5/href</a></iframe><p>이외에도 공식 홈페이지에서 es module로 제공되는 <a href="https://www.npmjs.com/package/lodash-es">lodash-es</a>, lodash 전체 import를 사용한 메서드들의 import로 변경해주는 <a href="https://www.npmjs.com/package/babel-plugin-lodash">babel-plugin-lodash</a> 등을 제공하고 있다. 이와 같이 커다란 패키지 전체를 import 하고 있는 경우는 없는지 다시 한 번 살펴볼 필요가 있다.</p><h4>Native Import와 Tree Shaking</h4><p>lodash를 lodash-es 로 대체했는데 상황이 변하지 않았다는 이야기를 하러 왔다면 이 주제에 대한 논의가 필요하다.</p><p>앞에서 babel이 기본적으로 module import 부분을 commonjs require로 바꾼다는 이야기를 했었는데 사실은 babel preset으로 es2015 등을 썼을 경우에 그렇게 된다. es2015 preset에 babel-plugin-transform-es2015-modules-commonjs 가 포함되어 있기 때문인데 아래와 같이 설정하거나 <a href="https://www.npmjs.com/package/babel-preset-es2015-native-modules">babel-preset-es2015-native-modules</a> 를 사용하면 module import를 require로 변환하지 않는다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/80017909f32971459fd24776b7145d80/href">https://medium.com/media/80017909f32971459fd24776b7145d80/href</a></iframe><p>이와 함께 ES2015+ Native Import 를 지원하는 bundler를 사용해야 (!) 메서드 단위로 import 를 할 수 있게 된다. Native Import/Export 를 Harmony Import/Export 라고도 부르는데 이는 Webpack 2 부터 지원하고 있다. 그렇기 때문에 현재 Stable 버전인 Webpack 1 에서는 이 혜택을 누릴 수가 없다고 보면 된다. 한 번 효과를 확인하고 싶으면 Webpack 2.1.0-beta.21 (2016년 8월 21일 현재 기준) 을 설치하여 번들링을 해보자. 번들링을 시도한 예제 코드는 아래와 같다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/3dc3c0803ec1c1a3b7009dc2f52bfaea/href">https://medium.com/media/3dc3c0803ec1c1a3b7009dc2f52bfaea/href</a></iframe><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/39338d1a8a455a80e2cca2a8ef5017ca/href">https://medium.com/media/39338d1a8a455a80e2cca2a8ef5017ca/href</a></iframe><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e8851b15cdee63ff8002cd561eb99df4/href">https://medium.com/media/e8851b15cdee63ff8002cd561eb99df4/href</a></iframe><figure><img alt="" src="https://cdn-images-1.medium.com/max/892/1*5tHIg1FSvvSLv-enV1UpTw.png" /></figure><p>require 를 통해서 모듈을 불러오게 되면 <strong>cjs require </strong>라는 표시와 함께 번들링이 되고, import 를 통해서 모듈을 불러오게 되면 <strong>harmony import </strong>라는 표시와 함께 모듈을 불러오는 것을 볼 수 있다. 그와 더불어 <strong>[only some exports used: foo]</strong> 라는 문구도 확인할 수 있는데 common.js 에 대해서는 <strong>hello </strong>만 사용되었다는 문구가 없다. 아래는 번들링된 스크립트이다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/469071afd2a6a68fd04fbbc5164e7da0/href">https://medium.com/media/469071afd2a6a68fd04fbbc5164e7da0/href</a></iframe><p>주목할 점은 1번 모듈의 bar 부분인데, 코드 상으로는 export 했으나 여기서는 export 조차 시켜주지 않았다는 점에 주목할 필요가 있다. 이와 같이 실제로 사용되지 않은 모듈의 import, export 구문을 없애버리는 것을 <strong>Tree Shaking </strong>이라고 부른다. 위 코드에는 남아있지만 번들링 시에 minify 플러그인을 넣으면 모두 없어지게 된다. cjs require 를 사용한 부분은 이후에도 어떤 property를 참조할지 정적 분석이 힘들기 때문에 기본적으로 Tree Shaking 되지 않는다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ed60508bcec814cada1dacb487708b81/href">https://medium.com/media/ed60508bcec814cada1dacb487708b81/href</a></iframe><p>아직 많은 라이브러리들이 ES2015+에 맞춰 제공하고 있지 않다. (일단 React.js 부터..) 그래서 아직까지는 lodash 와 같이 전체 import 를 피해갈 수 있다면 괜찮은 케이스인 것이고, 그렇지 않다면 안고 가거나 다른 가벼운 라이브러리를 찾는 것이 고작이다. 그래도 시간이 지나면 우리는 공짜 점심 (Yeah! Free lunch!) 을 먹을 수 있을 것이라 기대가 된다. (약 4개월 전에는 Webpack 2 beta 버전을 production 에 썼었으나 큰 효과를 보지는 못했다)</p><h3>혹시 이런 실수를?</h3><p>아직 용량이 많이 줄지 않았다면, 가벼운 실수를 하지 않았는지 확인해볼 필요도 있다. 예를 들어 <a href="https://webpack.github.io/docs/configuration.html#devtool">SourceMap을 소스 파일에 포함시키지는 않았는지</a> 혹은 <a href="https://facebook.github.io/react/downloads.html#npm">NODE_ENV 를 production 으로 주지 않았을 수</a>도 있다.</p><p>Webpack을 이용한 기본적인 용량 최적화에 대해서는 <a href="https://github.com/webpack/docs/wiki/optimization">https://github.com/webpack/docs/wiki/optimization</a> 에 간략하게 설명이 되어있다. <strong>Minimize</strong>, <strong>Deduplication</strong>, … 등의 기법을 적용하는 것이다. 이는 적용하기가 간단한 편에 속하니 해볼만 하다. 이 중에서 <strong>Minimize (Uglify) </strong>같은 경우는 Dead Code Elimination 을 해주기 때문에 반드시 해야한다. 향후에 Tree Shaking 을 하더라도 Minimize 를 해주지 않으면 export 되지 않은 부분이 날아가지 않기 때문에 실제 효과를 볼 수 없기 때문이다. 그리고 NODE_ENV 를 production 으로 주더라도 Minimize 를 하지 않으면 역시 감량 효과를 볼 수 없다.</p><h3>결과와 느낀 점</h3><p>이 글은 실제 작업을 하면서 배우고, 적용해보았던 내용을 토대로 쓰여졌다. 적용을 하고 나서는 아래와 같은 결과를 얻게 되었다. (스크립트 쪼개기도 포함, Chunking 을 좀 더 잘하면 좋지 않았을까 하는 아쉬움과 함께)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/257/1*hvAWbS_QtC8fmZ0yB8Be0w.png" /><figcaption>작업 이후 + Chunking</figcaption></figure><p>사이즈를 줄이는 데 사실 가장 큰 도움이 되었던 것은 기존에 있던 패키지를 대체할 수 있는 스크립트 작성하기와 훨씬 가벼운 대체 패키지를 찾는 것이었다. 스크립트 쪼개기를 하면 외부 패키지 코드 사이즈와 실제 작성한 코드의 사이즈를 명확히 알 수 있게 되는데 외부 패키지 코드가 일반적으로 실제 작성한 코드에 비해 월등히 크다는 점을 알게 된다. (다시 한 번: <a href="http://www.mikeperham.com/2016/02/09/kill-your-dependencies/">Kill Your Dependencies</a>) <strong>정말로 닭 잡는데 소 잡는 칼을 쓰지 말자.</strong></p><p>그리고 얼른 많은 패키지들이 ES2015+ 버전을 지원하고 Webpack 2도 얼른 beta 딱지를 떼면 좋겠다는 바람도 있다. CPU 클럭 수가 더 오르지 않게 되면서 프로그래머들이 공짜 점심을 못 먹나 했는데, 우리는 다른 곳 (..) 에서 공짜 점심을 먹을 수 있지 않을까 기대가 된다. (얼른 먹고 싶어서 두 번 말했다)</p><p>이 글이 많은 분들께 도움이 됐으면 좋겠습니다. 추가적으로 더 적용할 수 있는 좋은 방법을 알고 계신 분께서는 <a href="http://twitter.com/angdev_">@angdev</a> 로 알려주세요. 제가 좋아합니다. 긴 글 읽어주셔서 감사합니다.</p><h4>글쓴이에 대해서</h4><p>맨날 <a href="http://angdev.space">블로그</a>에 글 쓴다고 하다가 안 쓰다가 드디어 쓰게 되어 좋아하고 있습니다. <a href="https://github.com/angdev">Github</a>의 Contributions 부분이 초록초록 했는데 요즘에는 Private 하게 코딩하다보니 노는 것처럼 보이는데 맞습니다. 이번에 Frontend 에 대한 글을 쓰긴 했지만 원래는 Backend에 더 관심이 많은 사람입니다. RoR을 주로 쓰지만 요즘에는 Elixir, Clojure 공부도 겸하고 있습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=69c7e05bb3b3" width="1" height="1"><hr><p><a href="https://medium.com/little-big-programming/spa-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9A%A9%EB%9F%89-%EC%96%B4%EB%94%94%EA%B9%8C%EC%A7%80-%EC%A4%84%EC%9D%BC-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C-69c7e05bb3b3">SPA 스크립트 용량 어디까지 줄일 수 있을까</a> was originally published in <a href="https://medium.com/little-big-programming">little big programming</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
    </channel>
</rss>