<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>어쩐지 오늘은</title>
    <description>메모가 습관인 데이터쟁이입니다
</description>
    <link>https://zzsza.github.io/</link>
    <atom:link href="https://zzsza.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 09 May 2019 23:36:25 +0000</pubDate>
    <lastBuildDate>Thu, 09 May 2019 23:36:25 +0000</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Mac, Linux에서 Zip 파일에 password(암호) 설정하는 방법</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Mac OS와 Linux(Ubuntu)에서 Zip 파일에 암호를 설정하는 방법에 대해 작성한 글입니다
    &lt;ul&gt;
      &lt;li&gt;별도의 프로그램 설치 없이 터미널에서 진행하는 방법입니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;mac-os에서-압축시-암호-걸기&quot;&gt;Mac OS에서 압축시 암호 걸기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Mac Zip 파일로 압축할 때, 암호 설정하는 방법(Terminal)&lt;/li&gt;
  &lt;li&gt;zip 명령어를 날릴 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;-e&lt;/code&gt; 옵션을 주면 암호를 설정할 수 있음
    &lt;ul&gt;
      &lt;li&gt;약자의 의미는 encrypt(암호화)를 뜻함&lt;/li&gt;
      &lt;li&gt;입력하면 Enter password: 가 나오고 암호를 입력하면 됨(Verify password에서 1번 더 입력)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  zip -e 압축_파일.zip 압축에_사용될_파일
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;특정 확장자로 끝나는 모든 파일을 압축하고 싶은 경우엔 *를 사용하면 됨&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  zip -e 압축_파일.zip *.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;폴더째 압축하고 싶은 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;-r&lt;/code&gt; 옵션	을 주면 됨(암호까지 주려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;-er&lt;/code&gt;)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  zip -er zip_file.zip ./
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/xewt1gmz55550y7/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-05-08%2021.47.50.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;zip에 대해 궁금하면 zip을 치면 관련 명령어가 나옴&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/2fwegq5f4x0bdxw/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-05-08%2021.52.56.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;mac-os에서-압축-풀기&quot;&gt;Mac OS에서 압축 풀기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;unzip 명령어를 통해 압축을 풀 수 있음
    &lt;ul&gt;
      &lt;li&gt;암호가 설정되어 있으면 암호를 물어봄&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  unzip zip_file.zip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;unzip을 치면 관련 명령어가 나옴&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/sn688ds59n75z3e/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-05-08%2021.54.35.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;linuxubuntu에서-압축시-암호-걸기&quot;&gt;Linux(Ubuntu)에서 압축시 암호 걸기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;설치&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  apt-get update
  apt-get install zip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;zip 명령어 사용시 &lt;code class=&quot;highlighter-rouge&quot;&gt;-P&lt;/code&gt; 옵션 사용하면 암호를 설정할 수 있음
    &lt;ul&gt;
      &lt;li&gt;그러나 보안에 취약하기 때문에 비추천&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  zip -P 암호 압축_파일.zip 압축에_사용될_파일
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mac과 동일하게 &lt;code class=&quot;highlighter-rouge&quot;&gt;-e&lt;/code&gt; 옵션을 주면 암호를 설정할 수 있음&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  zip -e 압축_파일.zip 압축에_사용될_파일
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;linuxubuntu에서-압축-풀기&quot;&gt;Linux(Ubuntu)에서 압축 풀기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;설치&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  apt-get update
  apt-get install unzip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mac OS와 동일하게 사용&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  unzip 압축_파일.zip	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/development/2019/05/08/mac-zip-password/</link>
        <guid isPermaLink="true">https://zzsza.github.io/development/2019/05/08/mac-zip-password/</guid>
        
        <category>linux</category>
        
        
        <category>development</category>
        
      </item>
    
      <item>
        <title>Airflow BigQuery Operator의 이해</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Apache Airflow의 BigQuery Operator에 대한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;bigquery&quot;&gt;BigQuery&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;BigQuery는 Google Cloud Platform에서 매우 좋은 평가를 받고 있는 Managed 데이터 웨어하우스&lt;/li&gt;
  &lt;li&gt;데이터 분석용 데이터베이스로 매우 좋고, 빠른 속도가 장점&lt;/li&gt;
  &lt;li&gt;더 자세한 내용은 &lt;a href=&quot;https://cloud.google.com/bigquery/&quot;&gt;공식 문서&lt;/a&gt; 또는 &lt;a href=&quot;https://www.facebook.com/groups/bigquery/permalink/1760585197568366/&quot;&gt;Google BigQuery Users 참고 자료&lt;/a&gt; 참고!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;airflow-operator&quot;&gt;Airflow Operator&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Apache Airflow는 AWS/GCP Operator들이 잘 구현되어 있음
    &lt;ul&gt;
      &lt;li&gt;굳이 따지면 GCP 쪽 Operator가 더 잘되어 있는 편&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://airflow.apache.org/integration.html?highlight=bigquery#gcp&quot;&gt;공식 문서&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BigQuery Operator는 내부적으로 &lt;a href=&quot;http://airflow.apache.org/_api/airflow/contrib/hooks/bigquery_hook/index.html#airflow.contrib.hooks.bigquery_hook.BigQueryHook&quot;&gt;BigQueryHook&lt;/a&gt;을 사용해 Google Cloud Platform과 연결
    &lt;ul&gt;
      &lt;li&gt;처음 Operator 사용할 땐 “내부적으로 Hook을 통하는구나” 정도로 먼저 이해한 후, 사용해도 무방&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bigquery-operator&quot;&gt;BigQuery Operator&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://airflow.apache.org/integration.html?highlight=bigquery#bigquery&quot;&gt;공식 문서&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/apache/airflow/tree/master/airflow/contrib/operators&quot;&gt;Github Link&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;총 11개 Operator가 존재(1.10.1 버전 기준)
    &lt;ul&gt;
      &lt;li&gt;BigQueryCheckOperator&lt;/li&gt;
      &lt;li&gt;BigQueryIntervalCheckOperator&lt;/li&gt;
      &lt;li&gt;BigQueryValueCheckOperator&lt;/li&gt;
      &lt;li&gt;BigQueryGetDataOperator&lt;/li&gt;
      &lt;li&gt;BigQueryCreateEmptyDatasetOperator&lt;/li&gt;
      &lt;li&gt;BigQueryCreateExternalTableOperator&lt;/li&gt;
      &lt;li&gt;BigQueryDeleteDatasetOperator&lt;/li&gt;
      &lt;li&gt;BigQueryOperator&lt;/li&gt;
      &lt;li&gt;BigQueryTableDeleteOperator&lt;/li&gt;
      &lt;li&gt;BigQueryToBigQueryOperator&lt;/li&gt;
      &lt;li&gt;BigQueryToCloudStorageOperator&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용하는 사람마다 다르겠지만 제가 제일 많이 사용하는 Operator는 &lt;code class=&quot;highlighter-rouge&quot;&gt;BigQueryOperator&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;BigQueryCreateExternalTableOperator&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;BigQueryTableDeleteOperator&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;BigQueryToBigQueryOperator&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;BigQueryOperator
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://airflow.apache.org/_api/airflow/contrib/operators/bigquery_operator/index.html#airflow.contrib.operators.bigquery_operator.BigQueryOperator&quot;&gt;공식 문서&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;BigQuery SQl 쿼리를 날려주는 Operator&lt;/li&gt;
      &lt;li&gt;쿼리 결과를 Table로 저장할 수 있음&lt;/li&gt;
      &lt;li&gt;사용 예시&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from airflow import models
  from airflow.contrib.operators.bigquery_operator import BigQueryOperator
	
  default_dag_args = {
      'owner': 'zzsza',
      'start_date': datetime(2019, 4, 2),
      'email': ['your_email@gmail.com'],
      'email_on_failure': False,
      'email_on_retry': False,
      'retries': 0,
      'project_id': 'your_proeject_name'
  }

  query = &quot;&quot;&quot;
      SELECT *
      FROM `project.dataset.table`
      LIMIT 1000
  &quot;&quot;&quot;
	
  with models.DAG(
      dag_id = 'extract_feature_dag',
      schedule_interval= '30 0 * * *',
      default_args=default_dag_args) as dag:

      bq_query = bigquery_operator.BigQueryOperator(
          task_id='extract_daily_metric',
          bql=query, 
          use_legacy_sql=False,
          destination_dataset_table='dataset.table',
          write_disposition='WRITE_TRUNCATE'
          )
	
      bq_query
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;파라미터 (몇개만 설명)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  BigQueryOperator(bql=None, sql=None, destination_dataset_table=None, write_disposition='WRITE_EMPTY', \
      allow_large_results=False, flatten_results=None, bigquery_conn_id='bigquery_default', delegate_to=None, \
      udf_config=None, use_legacy_sql=True, maximum_billing_tier=None, maximum_bytes_billed=None, \
      create_disposition='CREATE_IF_NEEDED', schema_update_options=(), query_params=None, labels=None, \
      priority='INTERACTIVE', time_partitioning=None, api_resource_configs=None, cluster_fields=None, \
      location=None, *args, **kwargs)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;bql는 이제 deprecate 예정, sql 사용(.sql 파일도 사용 가능)&lt;/li&gt;
      &lt;li&gt;destination_dataset_table : &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;project&amp;gt;.&amp;lt;dataset&amp;gt;.&amp;lt;table&amp;gt;&lt;/code&gt; 형태로 사용&lt;/li&gt;
      &lt;li&gt;write_disposition : WRITE_EMPTY(빈 경우만 쓰기), WRITE_TRUNCATE(덮어 쓰기), WRITE_APPEND(데이터 Append), &lt;a href=&quot;https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs&quot;&gt;참고 문서&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;bigquery_conn_id : Connection 설정 이름&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BigQueryCreateExternalTable
    &lt;ul&gt;
      &lt;li&gt;GoogleCloudStorageToBigQueryOperator과 유사한 작업을 하는 Operator로 BigQueryCreateExternalTable은 Bigtable, Google Storage, Google Drive 등에서 데이터를 가지고 올 수 있음(더 넓은 개념)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  date = &quot;{#{ macros.ds_format(macros.ds_add(ds, -1), '%Y-%m-%d', '%Y/%m/%d') }#}&quot; # 코드에선 # 빼주세요
	
  create_table = BigQueryCreateExternalTable(bucket='bucket_name', source_objects=[f'{date}/user_log.csv'],
                                      schema_fields =[{&quot;name&quot;: &quot;user_id&quot;, &quot;type&quot;: &quot;STRING&quot;, &quot;mode&quot;: &quot;REQUIRED&quot;}, {&quot;name&quot;:&quot;purchase_amount&quot;, &quot;type&quot;: &quot;INTEGER&quot;, &quot;mode&quot;: &quot;NULLABLE&quot;}],
                                      schema_object='bigquery-schema/user_log.json' # Google Storage path,
                                      source_format='CSV',
                                      bigquery_conn_id='bigquery_default',
                                      google_cloud_storage_conn_id='storage_default'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;BigQueryDeleteDatasetOperator
    &lt;ul&gt;
      &lt;li&gt;데이터셋 삭제 Operator&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  delete_temp_data = BigQueryDeleteDatasetOperator(dataset_id = 'temp-dataset',
                                       project_id = 'temp-project',
                                       bigquery_conn_id='_my_gcp_conn_',
                                       task_id='Deletetemp',
                                       dag=dag)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;BigQueryToBigQueryOperator
    &lt;ul&gt;
      &lt;li&gt;BigQuery Table A를 B로 옮길 때 사용하는 Operator&lt;/li&gt;
      &lt;li&gt;데이터 마이그레이션시 사용&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  move_table = BigQueryToBigQueryOperator(source_project_dataset_tables='project.dataset.table',  \
                                  destination_project_dataset_talbe='project.dataset.tableb', write_disposition='WRITE_TRUNCATE', \
                                  bigquery_conn_id='bigquery_default')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zzsza.github.io/data/2018/01/04/airflow-1/&quot;&gt;Apache Airflow - Workflow 관리 도구(1)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 17 Apr 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/mlops/2019/04/17/airflow-bigquery-operator/</link>
        <guid isPermaLink="true">https://zzsza.github.io/mlops/2019/04/17/airflow-bigquery-operator/</guid>
        
        <category>airflow</category>
        
        
        <category>mlops</category>
        
      </item>
    
      <item>
        <title>Interpretable Machine Learning</title>
        <description>&lt;ul&gt;
  &lt;li&gt;패스트캠퍼스 Alumni Special Seminar, Interpretable Machine Learning 세미나를 듣고 정리한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;총평&quot;&gt;총평&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;요새 Interpretable Machine Learning의 필요성을 느끼고 LIME이나 깃북을 보며 공부하고 있었는데, 연사님의 좋은 발표 덕에 Interpretable ML의 큰 그림을 더 잘 이해할 수 있게됨&lt;/li&gt;
  &lt;li&gt;많은 사람들이 비슷한 생각을 하고 있구나- 깨달았고, 회사 업무에 어떻게 적용할 수 있을지 고민해볼 예정&lt;/li&gt;
  &lt;li&gt;추후 참고하면 좋을 컨텐츠
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://christophm.github.io/interpretable-ml-book/&quot;&gt;https://christophm.github.io/interpretable-ml-book/&lt;/a&gt; : 전반적인 내용이 잘 나와있는 Gitbook&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://people.csail.mit.edu/beenkim/papers/BeenK_FinaleDV_ICML2017_tutorial.pdf&quot;&gt;Interpretable Machine Learning, ICML 2017&lt;/a&gt; : ICML 2017 Tutorial&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://interpretable.ml/&quot;&gt;Interpretable ML Symposium&lt;/a&gt; : NIPS 2017&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://pay.modulabs.co.kr/lab_safeai/&quot;&gt;모두의 연구소 Safe AI Lab&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/marcotcr/lime&quot;&gt;LIME Github&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;Kaggle &lt;a href=&quot;https://www.kaggle.com/learn/machine-learning-explainability&quot;&gt;Machine Learning Explainability&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;Paper
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1901.04592&quot;&gt;Interpretable machine learning: definitions, methods, and applications&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://www.kdd.org/kdd2016/papers/files/rfp0573-ribeiroA.pdf&quot;&gt;Why Should I Trust You? Explaining the Prediction of Any classifier&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1709.06680&quot;&gt;Deep Lattice Networks and Partial Monotonic functions&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1610.02391&quot;&gt;Grad-CAM : Visual Explanations from Deep networks via Gradient-Based localization&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://www.nature.com/articles/s41591-018-0107-6&quot;&gt;Clinically applicable deep learning for diagnosis and referral in retinal disease&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1805.09901&quot;&gt;Boolean Decision Rules via Column Generation&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1811.12615&quot;&gt;An Interpretable Model with Globally Consistent Explanations for Credit Risk&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1811.10154&quot;&gt;Please Stop Explaining Black Box Models for High Stakes Decisions&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://papers.nips.cc/paper/8072-co-teaching-robust-training-of-deep-neural-networks-with-extremely-noisy-labels.pdf&quot;&gt;Co-teaching : Robust Training of Deep Neural Networks with Extremely Noisy Labels&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.fastcampus.co.kr/data_seminar_fcalumni/&quot;&gt;패스트캠퍼스 Alumni Special Seminar - Interpretable Machine Learning&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;연사님
    &lt;ul&gt;
      &lt;li&gt;윤상웅님
        &lt;ul&gt;
          &lt;li&gt;장병탁 교수님 연구실&lt;/li&gt;
          &lt;li&gt;SNU Robotics&lt;/li&gt;
          &lt;li&gt;해줌&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;intro&quot;&gt;Intro&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;빌리언즈라는 드라마&lt;/li&gt;
  &lt;li&gt;2명의 트레이더
    &lt;ul&gt;
      &lt;li&gt;의견 중재가 필요한 상황&lt;/li&gt;
      &lt;li&gt;얼마나 확신하는지 물어봄&lt;/li&gt;
      &lt;li&gt;이 때 답변을 못하면?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;트레이더는 곧 ML Model
    &lt;ul&gt;
      &lt;li&gt;한다면?
        &lt;ul&gt;
          &lt;li&gt;과거 데이터 /시뮬레이션에 대해서 철저히 검증됨&lt;/li&gt;
          &lt;li&gt;알고리즘이 기반한 아이디어가 말이 되고 납득이 됨&lt;/li&gt;
          &lt;li&gt;리스크가 적음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;하지 않는다면?
        &lt;ul&gt;
          &lt;li&gt;과거 데이터에 대해서만 검증(=시뮬레이션에 대해서만)&lt;/li&gt;
          &lt;li&gt;알고리즘이 작동하는 원리가 말이 안됨&lt;/li&gt;
          &lt;li&gt;리스크가 큼&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ML의 숙명 - 1
    &lt;ul&gt;
      &lt;li&gt;에러가 반드시 발생함
        &lt;ul&gt;
          &lt;li&gt;Bayes Error
            &lt;ul&gt;
              &lt;li&gt;정의 : Classification 문제에서 이론적으로 도달할 수 있는 최소한의 오분류율&lt;/li&gt;
              &lt;li&gt;각 class의 확률분포가 겹치는 만큼 발생&lt;/li&gt;
              &lt;li&gt;Bayes Error보다 오분류율을 줄일 수 없으며, 많은 경우 Bayes Error ≠ 0&lt;/li&gt;
              &lt;li&gt;새로운 정보를 가진 Feature가 추가되어야만 Bayes Error를 낮출 수 있음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;어떤 에러는 아주 치명적
        &lt;ul&gt;
          &lt;li&gt;loss(암 환자를 정상으로 분류) &amp;gt; loss(정상을 암환자로 분류)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ML의 숙명 - 2
    &lt;ul&gt;
      &lt;li&gt;예측값만 제공
        &lt;ul&gt;
          &lt;li&gt;인간을 설득시키기엔 부족함&lt;/li&gt;
          &lt;li&gt;알고리즘 작동으로 얻는 정보가 너무 적음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;일부 알고리즘은 불확실성(uncertainty) 혹은 확정도(confidence)도 함께 제공
        &lt;ul&gt;
          &lt;li&gt;그러나 항상 제공하진 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;결국 &lt;strong&gt;신뢰의 문제&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;ML 알고리즘을 믿고 의존할 수 있는가?&lt;/li&gt;
      &lt;li&gt;ML 알고리즘이 잘못되었을 때 인간이 바로잡을 수 있는가?&lt;/li&gt;
      &lt;li&gt;ML 알고리즘이 예측하지 못한 안 좋은 효과를 일으키지 않는가?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;trusthworthy-machine-learning&quot;&gt;Trusthworthy Machine Learning&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;신뢰할만한 머신러닝, 다양한 분야랑 연결됨&lt;/li&gt;
  &lt;li&gt;1) Interpretable ML&lt;/li&gt;
  &lt;li&gt;2) Causality : 상관관계가 아닌 인과관계를 학습
    &lt;ul&gt;
      &lt;li&gt;코잘리티&lt;/li&gt;
      &lt;li&gt;X로부터 Y를 예측할 수 있다고 X가 Y의 원인인 것은 아님
        &lt;ul&gt;
          &lt;li&gt;X와 Y가 상관관계(correlation)이 있을 뿐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;관측 데이터로 인과관계를 알아내는 것은 매우 어려운 일&lt;/li&gt;
      &lt;li&gt;외부 변수(Confounding variable) → 현실에선 항상 존재&lt;/li&gt;
      &lt;li&gt;당연한 것(암 걸린 사람이 항암제 처방을 받았을 것이다)을 인과관계로 정의할 수 있는데, 그럼 bias… 그러면 안됨&lt;/li&gt;
      &lt;li&gt;이론적으로 어디까지 가능한지 학회에서 연구중&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3) Fairness : 알고리즘의 공정성
    &lt;ul&gt;
      &lt;li&gt;ML 알고리즘은 편향(bias)되기 쉬움
        &lt;ul&gt;
          &lt;li&gt;예시
            &lt;ul&gt;
              &lt;li&gt;흑인 사진을 고릴라라고 인식&lt;/li&gt;
              &lt;li&gt;인도 신부 복장을 입은 사람을 댄서로 인식&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;수집한 데이터의 편향&lt;/li&gt;
          &lt;li&gt;데이터셋 제작자의 부주의&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4) Pirvacy-preserving ML : 사용자 데이터 보호
    &lt;ul&gt;
      &lt;li&gt;ML 모델 개발 과정 및 서비스 중 확인을 위해 로그 데이터를 까보는데, 민감한 개인 정보가 노출됨&lt;/li&gt;
      &lt;li&gt;암호화된 데이터로 학습할 수 있을까?&lt;/li&gt;
      &lt;li&gt;애초에 데이터 수집 단계에서 Privacy를 보존할 수 있을까?&lt;/li&gt;
      &lt;li&gt;Differential Privacy
        &lt;ul&gt;
          &lt;li&gt;설문지에 에이즈 보균자냐고 물어보면 정직하게 답변하지 않을 것&lt;/li&gt;
          &lt;li&gt;동전을 던져서 앞면이 나오면 무조건 YES, 뒷면이 나오면 솔직한 답을 적음&lt;/li&gt;
          &lt;li&gt;얻은 YES 응답률에서 0.5를 빼고 2배를 하면 실제 YES 응답 비율을 구할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;5) Adversarial attack : 해킹에 대한 보호
    &lt;ul&gt;
      &lt;li&gt;DNN의 입력에 작은 perturbation을 출력해 원하는대로 출력을 조절&lt;/li&gt;
      &lt;li&gt;왜 발생하는지? 어떻게 방어할 것인지? 고민하고 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;interpretable-machine-learning&quot;&gt;Interpretable Machine Learning&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;예측 결과에 더해서 사람이 이해할 수 있는 형태로 추가적인 정보를 제공할 수 있는 머신러닝 알고리즘을 연구하는 분야&lt;/li&gt;
  &lt;li&gt;목표
    &lt;ul&gt;
      &lt;li&gt;Interpretability란 무엇인가?&lt;/li&gt;
      &lt;li&gt;Interpretability가 가능한가? 왜 필요한가?&lt;/li&gt;
      &lt;li&gt;UI 기획으로도 풀 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;신뢰를 얻는 방법은 상황과 상대에 따라 다름
    &lt;ul&gt;
      &lt;li&gt;문제 상황, 데이터셋, 알고리즘, 사용자의 상황에 따라 다르게 접근&lt;/li&gt;
      &lt;li&gt;새로운 알고리즘만이 해결책은 아님&lt;/li&gt;
      &lt;li&gt;여러 문제에 맞는 해결책을 &lt;strong&gt;직접 고민해야 함&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;시각화는 어떻게? 등&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Interpretable ML의 효용 (From selvaragu, 2017)
    &lt;ul&gt;
      &lt;li&gt;어디에 도움이 될 것인가&lt;/li&gt;
      &lt;li&gt;(1) 연구 개발 단계의 ML
        &lt;ul&gt;
          &lt;li&gt;인간 수준 이하의 알고리즘의 경우(ex: VQA)&lt;/li&gt;
          &lt;li&gt;왜 못하는지 ⇒ 확인 후 개선&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;(2) 상용화 수준의 ML
        &lt;ul&gt;
          &lt;li&gt;인간 수준에 가깝거나 유용한 수준(ex: Image classification)&lt;/li&gt;
          &lt;li&gt;사용자들에게 신뢰를 얻고 활용도를 증진&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;(3) 인간 이상의 수준 ML
        &lt;ul&gt;
          &lt;li&gt;인간보다 압도적으로 뛰어난&lt;/li&gt;
          &lt;li&gt;Interpretability를 통해 인간을 가르칠 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;널리 퍼져 있는 믿음
    &lt;ul&gt;
      &lt;li&gt;Linear model은 interpretable ( 학계의 정설)
        &lt;ul&gt;
          &lt;li&gt;Linear Regression, Logistic Regression&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;1) 개별 가중치를 파악
    &lt;ul&gt;
      &lt;li&gt;전체적인 규칙을 알 수 있음 ⇒ Global interpretability&lt;/li&gt;
      &lt;li&gt;함정
        &lt;ul&gt;
          &lt;li&gt;다중 공선성
            &lt;ul&gt;
              &lt;li&gt;입력 feature간 상관성이 높을 경우&lt;/li&gt;
              &lt;li&gt;weight 값이 직관과 다르게 얻어질 수 있음(그래프를 뿌려보면 양의 상관관계가 보이는데 실제로 나온 계수는 음수)&lt;/li&gt;
              &lt;li&gt;상관성이 높은 feature를 제거
                &lt;ul&gt;
                  &lt;li&gt;차원 축소 혹은 feature delete ⇒ 휴리스틱&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2) 개별 Data point에 대해 예측해야되는 순간
    &lt;ul&gt;
      &lt;li&gt;나이, 거리, 등록기간에 따른 재등록 확률을 예측&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;MathJax_Preview&quot;&gt;w_{i} x_{i}&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;w_{i} x_{i}&lt;/script&gt; : log odds-ratio에 대한 기여도&lt;/li&gt;
      &lt;li&gt;Local interpretability&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3) 확률값과 신뢰구간
    &lt;ul&gt;
      &lt;li&gt;모델의 출력은 확률값 0 ~ 1&lt;/li&gt;
      &lt;li&gt;1에 가까우면 확실하게 재등록&lt;/li&gt;
      &lt;li&gt;0에 가까우면 확실히 이탈&lt;/li&gt;
      &lt;li&gt;0.5면? → ??&lt;/li&gt;
      &lt;li&gt;모델의 예측이 얼마나 확실한지 제공
        &lt;ul&gt;
          &lt;li&gt;Predictive Uncertainty / Confidence Score&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Interpretable ML의 세 방향
    &lt;ul&gt;
      &lt;li&gt;1) Global interpretability
        &lt;ul&gt;
          &lt;li&gt;모델이 전체적으로 어떤 원리로 예측하는지 설명&lt;/li&gt;
          &lt;li&gt;분산 분석, 통계 테스트&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) Local interpretability
        &lt;ul&gt;
          &lt;li&gt;개별 data point에 대해 예측의 이유 설명&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;MathJax_Preview&quot;&gt;w_{i} x_{i}&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;w_{i} x_{i}&lt;/script&gt; 항들의 값을 비교&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;3) Uncertainty
        &lt;ul&gt;
          &lt;li&gt;예측값에 얼마나 확신이 있는지?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;1)과 2)는 아직 정립된 용어는 아님&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;global-interpretability&quot;&gt;Global Interpretability&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;1) Monotonicity(단조성)
    &lt;ul&gt;
      &lt;li&gt;대출 연체를 했는데 신용등급이 올라간다?&lt;/li&gt;
      &lt;li&gt;소득이 늘었는데 신용 등급이 떨어진다?&lt;/li&gt;
      &lt;li&gt;입력 변수와 예측 변수의 단조성을 강제로 넣어줌!
        &lt;ul&gt;
          &lt;li&gt;상식과 벗어난 거동을 방지&lt;/li&gt;
          &lt;li&gt;모델의 전체적인 작동을 설명하기 쉬움&lt;/li&gt;
          &lt;li&gt;선형모델은 단조성이 보장됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;굉장히 강력한 제한조건
        &lt;ul&gt;
          &lt;li&gt;소수의 모델에만 적용 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Linear 모델은 Monotonic함&lt;/li&gt;
      &lt;li&gt;Gradient Boosting(XGB, LGBM)은 monotonic constraint option 존재
        &lt;ul&gt;
          &lt;li&gt;원래 에러를 무조건 줄이라고 하면 사인 함수로 할텐데, 모노토닉 constraint 옵션을 주면 어디는 트리를 만들지 않고 단조 증가/단조 감소 하도록 예측&lt;/li&gt;
          &lt;li&gt;실용적으론 제일 유용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Neural Networks
        &lt;ul&gt;
          &lt;li&gt;신경망과 유사한 구조를 사용하며 단조성 조건 추가&lt;/li&gt;
          &lt;li&gt;Tensorflow 구현체 공개됨
            &lt;ul&gt;
              &lt;li&gt;TensorFlow Lattice&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;https://github.com/tensorflow/lattice&quot;&gt;https://github.com/tensorflow/lattice&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;1D Lattice
            &lt;ul&gt;
              &lt;li&gt;한 레이어나 유닛&lt;/li&gt;
              &lt;li&gt;일종의 Look-up Table&lt;/li&gt;
              &lt;li&gt;5개의 점이 찍혀있는 좌표를 알면 그에 맞는 함수 생성&lt;/li&gt;
              &lt;li&gt;Key가 아닌 값(없는 좌표)을 받으면 linear interpolation&lt;/li&gt;
              &lt;li&gt;파라미터 값은 gradient descent로 학습&lt;/li&gt;
              &lt;li&gt;1차원 함수로 다 표현&lt;/li&gt;
              &lt;li&gt;Monotonicity
                &lt;ul&gt;
                  &lt;li&gt;Key1 &amp;lt; Key2이면 Value1 ≤ Value2가 되도록 constraint&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;Activation function의 역할
                &lt;ul&gt;
                  &lt;li&gt;ReLU의 선형결합과 동일&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;Exclusive or 문제
                &lt;ul&gt;
                  &lt;li&gt;Linear는 풀 수 없음&lt;/li&gt;
                  &lt;li&gt;1,3 / 2,4 같은 클래스&lt;/li&gt;
                  &lt;li&gt;단조성 강제하면 모델이 가질 수 있는 함수의 Set이 줄어드니 함수가 약해지는 것이 맞음&lt;/li&gt;
                  &lt;li&gt;단조성이 선형성은 아님&lt;/li&gt;
                  &lt;li&gt;모든 변수에 대해서 모노토릭할 필요는 없음 ⇒ partial monotonic&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;KD Lattice
            &lt;ul&gt;
              &lt;li&gt;2^{k}의 격자점&lt;/li&gt;
              &lt;li&gt;3개의 입력을 받음&lt;/li&gt;
              &lt;li&gt;격자점이 아닌 값이 들어오면 multilinear interpolation&lt;/li&gt;
              &lt;li&gt;Monotonicity가 필요할 경우 격자점들의 값에 제한조건 부여&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Deep Lattice Network
            &lt;ul&gt;
              &lt;li&gt;쌓아둠&lt;/li&gt;
              &lt;li&gt;Monotonic이라고 지정된 입력이 지나가는 layer는 모두 monotonic constraint
                &lt;ul&gt;
                  &lt;li&gt;constraint를 만족하는 파라미터를 찾는 최적화 과정이 non-trivial&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;Classification/Regression loss를 최소화하도록 SGD를 이용해 학습&lt;/li&gt;
              &lt;li&gt;단조적 연산만 하도록 강제&lt;/li&gt;
              &lt;li&gt;모노토릭한 것을 하면 반쯤은 지켜야한다는 constraint가 생김 ⇒ 더 많은 연산량&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2) Feature Importance
    &lt;ul&gt;
      &lt;li&gt;Rough한 정보지만 여러 종류 모델에 적용 가능&lt;/li&gt;
      &lt;li&gt;Feature selection과 밀접한 연관
        &lt;ul&gt;
          &lt;li&gt;변수가 너무 많을 경우 어떤 변수를 예측모형에 사용할지 선택하는 작업&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;(1) Feature Ablation
        &lt;ul&gt;
          &lt;li&gt;Feature를 제거하고 돌렸을 때 성능이 얼마나 떨어지는지 확인&lt;/li&gt;
          &lt;li&gt;성능이 많이 떨어지는 feature가 중요한 feature&lt;/li&gt;
          &lt;li&gt;장점
            &lt;ul&gt;
              &lt;li&gt;무식한 방법이지만 직관적으로 이해하기 쉬움&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;단점
            &lt;ul&gt;
              &lt;li&gt;연산이 많음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;(2) Mutual information
        &lt;ul&gt;
          &lt;li&gt;정보 이론에서 나옴&lt;/li&gt;
          &lt;li&gt;두 확률변수 X, Y가 서로에게 얼마나 정보를 가지고 있는지 나타내는 값&lt;/li&gt;
          &lt;li&gt;MI(X, Y)=0이면 X와 Y가 독립&lt;/li&gt;
          &lt;li&gt;Corr과 다른 것
            &lt;ul&gt;
              &lt;li&gt;Corr은 선형 관계만 표시하는데, 이건 비선형도 사용 가능&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;MI가 큰 feature가 중요한 feature일 확률이 높음&lt;/li&gt;
          &lt;li&gt;Nearest neighbor, kernel density estimation 등을 이용한 비모수적(non-parameter) 추정 방법 가능&lt;/li&gt;
          &lt;li&gt;MI가 아니더라도 t-statistic 등 여러 지표로 측정 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;(3) L1 constraint
        &lt;ul&gt;
          &lt;li&gt;가중치의 L1 nort으로 regularization&lt;/li&gt;
          &lt;li&gt;0이 많이 들어간 솔루션을 찾음&lt;/li&gt;
          &lt;li&gt;중요하지 않은 feature는 weight는 0이 됨, Sparse solution&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;local-interpretability&quot;&gt;Local Interpretability&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;이게 연구가 많이 됨&lt;/li&gt;
  &lt;li&gt;1) Local Surrogate
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;LIME(Local interpretable model-agnostic explanations)&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;복잡한 모형을 국지적(local)으로 근사하는 선형 모형을 만듬&lt;/li&gt;
      &lt;li&gt;특정 포인트 주변에 선형 모형을 fitting&lt;/li&gt;
      &lt;li&gt;전체에 대해선 모르지만 특정 부분 근처엔 왼쪽은 ~, 오른쪽은 ~&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/marcotcr/lime&quot;&gt;https://github.com/marcotcr/lime&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;Interpretable Data Representation
        &lt;ul&gt;
          &lt;li&gt;이것에 대해 생각해볼 수 있음&lt;/li&gt;
          &lt;li&gt;이 Feature가 항상 의미가 있을까?&lt;/li&gt;
          &lt;li&gt;해석이 불가능한 것이 있을 수 있음. 이미지에서 개별 픽셀(452번째)이 중요하다고 ???&lt;/li&gt;
          &lt;li&gt;Feature Transform : 루트, 제곱 등 ⇒ 루트는 중요한데 제곱은 중요하지 않다?&lt;/li&gt;
          &lt;li&gt;Feature 자체로 의미가 있는 경우와 없는 경우를 구분&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;LIME
        &lt;ul&gt;
          &lt;li&gt;f(x) : black-box model based on features&lt;/li&gt;
          &lt;li&gt;g(z) : local explanation based on interpretable representation&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;MathJax_Preview&quot;&gt;\pi_{x}(z)&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;\pi_{x}(z)&lt;/script&gt; : 가중치&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;MathJax_Preview&quot;&gt;\Omega (g)&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;\Omega (g)&lt;/script&gt; : regularization&lt;/li&gt;
          &lt;li&gt;g(z)가 f(x)를 잘 모사하면서 너무 복잡하지 않도록 학습&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2) Counterfactual Explanation
    &lt;ul&gt;
      &lt;li&gt;Counterfactual = What if
        &lt;ul&gt;
          &lt;li&gt;만약 이랬다면 다른 결과가 얻어졌을 것이다&lt;/li&gt;
          &lt;li&gt;가상 혹은 진짜의 데이터 포인트를 제시&lt;/li&gt;
          &lt;li&gt;입력값 중 하나, 두개 여러개를 바꿈 ⇒ 예측 결과가 달라짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Counterfactual 끝판왕 = 입력을 바꿔서 돌려볼 수 있도록 공개
        &lt;ul&gt;
          &lt;li&gt;Simulator
            &lt;ul&gt;
              &lt;li&gt;사용자가 직접 값을 바꿔보면 어떻게 되는지?&lt;/li&gt;
              &lt;li&gt;헬스장 거리를 줄여보니 예측값이 좋아짐&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;단점 : Adversarial attack 등 위험
            &lt;ul&gt;
              &lt;li&gt;classification을 모두 공개하면 attack할 수 있음&lt;/li&gt;
              &lt;li&gt;예를 들어 보험료 산정 알고리즘이면 그걸 해킹해보고.. 특정 조건을 찾아서 내 보험료를 깎을 수 있음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3) Gradient-based Explanation
    &lt;ul&gt;
      &lt;li&gt;Grad CAM
        &lt;ul&gt;
          &lt;li&gt;가장 성공적이고 널리 쓰이는 방법&lt;/li&gt;
          &lt;li&gt;Class activation 에 가장 기여하는 hidden neuron을 찾음
            &lt;ul&gt;
              &lt;li&gt;가장 윗층의 conv layer 사용
                &lt;ul&gt;
                  &lt;li&gt;가장 high level 정보&lt;/li&gt;
                  &lt;li&gt;공간적인(Spatial) 정보를 보유하고 있음&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;각 Feautre map의 기여도를 계산함(Global Average Pooling in CAM)&lt;/li&gt;
          &lt;li&gt;Class activation Map L을 얻음&lt;/li&gt;
          &lt;li&gt;L을 upsample(bilinear)하여 입력 image에 시각화&lt;/li&gt;
          &lt;li&gt;장점
            &lt;ul&gt;
              &lt;li&gt;Classification만 했는데 Detection 가능
                &lt;ul&gt;
                  &lt;li&gt;여러 object 가능&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;학습된 네트워크에 적용하기만 하면 됨
                &lt;ul&gt;
                  &lt;li&gt;재학습, 구조 변경이 없어서 예측 성능 유지&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;guided backpropagation과 함께 사용해 더 향상&lt;/li&gt;
              &lt;li&gt;ConvNet으로 시작하는 task는 모두 적용 가능&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;예측 결과에 중요한 이미지 부분을 heatmap 형태로 제공
        &lt;ul&gt;
          &lt;li&gt;일반적인 ConvNet에 대해&lt;/li&gt;
          &lt;li&gt;Image classification, captioning, visual QA 등 여러 종류의 task에 사용 가능&lt;/li&gt;
          &lt;li&gt;네트워크에 변형도 가하지 않고 어떤 성능 저하도 없음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Grad CAM 실험
        &lt;ul&gt;
          &lt;li&gt;인간 실험
            &lt;ul&gt;
              &lt;li&gt;실제 사람들에게 설문조사 같은 것을 뿌림&lt;/li&gt;
              &lt;li&gt;이 방법을 사용했을 때 더 신뢰를 느끼는가?&lt;/li&gt;
              &lt;li&gt;결론 : Grad-CAM visualization이 더 믿을만한 알고리즘을 고르는데 도움이 됨&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;모델 실패 사례 분석
            &lt;ul&gt;
              &lt;li&gt;vgg16이 잘못 예측하는 경우를 분석&lt;/li&gt;
              &lt;li&gt;어째서 잘못된 예측을 하는가?&lt;/li&gt;
              &lt;li&gt;관측된 사례
                &lt;ul&gt;
                  &lt;li&gt;Class label의 모호함&lt;/li&gt;
                  &lt;li&gt;헷갈릴만한 경우&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;잘못된 예측에 대해 엉뚱한 CAM이 나오면 모델 학습에 문제가 있다는 것&lt;/li&gt;
              &lt;li&gt;하지만 구체적 개선방안이 언제나 명확한 것은 아님&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Class 레이블의 애매한 이유
    &lt;ul&gt;
      &lt;li&gt;레이블러의 실수 때문(노이즈 때문) 이라면 통계적 접근을 할 수 있을..(딥뉴럴넷의 특징)&lt;/li&gt;
      &lt;li&gt;Co-teaching : Robust Training of Deep Neural Networks with Extremely Noisy Labels&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://papers.nips.cc/paper/8072-co-teaching-robust-training-of-deep-neural-networks-with-extremely-noisy-labels.pdf&quot;&gt;https://papers.nips.cc/paper/8072-co-teaching-robust-training-of-deep-neural-networks-with-extremely-noisy-labels.pdf&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;학습 과정 중간을 보면 레이블이 제대로 된 것부터 학습하고, 아닌 것에 나중에 fitting(나중에 training error가 줄어듬)
        &lt;ul&gt;
          &lt;li&gt;잘못달린 것 같은데? 라고 의심할 수 있고 로버스트하게.. 제안&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;이론적 근거가 확실하진 않지만 실험적으로 관찰되는 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;uncertainty&quot;&gt;Uncertainty&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;설명이 아닌 예측에 대해 얼마나 확신을 가지는지 제시할 수 있는 기법에 대해 이야기함&lt;/li&gt;
  &lt;li&gt;Class 1, 2 분류하는 알고리즘&lt;/li&gt;
  &lt;li&gt;좋은 분류기라면 확실한 것은 확실하다 말하고 경계선은 약간의 불확실성이 있다고 말할 수 있을 듯&lt;/li&gt;
  &lt;li&gt;Confidence Score
    &lt;ul&gt;
      &lt;li&gt;ML 알고리즘은 예측값만 출력하는 것이 일반적&lt;/li&gt;
      &lt;li&gt;그러나 알고리즘에 따라 내부적인 변수를 활용해 예측에 얼마나 확신을 가지고 있는지 알 수 있는 경우가 있음&lt;/li&gt;
      &lt;li&gt;“확률”의 형태를 띄고 있지 않음 → 직관적으로 이해하기 어려움
        &lt;ul&gt;
          &lt;li&gt;SVM Margin&lt;/li&gt;
          &lt;li&gt;Ensemble Methods : 개별 tree들의 예측이 일치하면 high confidence, 불일치하면 low confidence&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Predictive Probability
    &lt;ul&gt;
      &lt;li&gt;로지스틱 회귀나 뉴럴넷은 아웃풋을 확률의 형태로 출력할 수 있음
        &lt;ul&gt;
          &lt;li&gt;확률값이 1에 가까우면 high confidence, 아니면 low confidence&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;정량적으로 (Shannon) Entropy를 기준으로 판단할 수 있음
        &lt;ul&gt;
          &lt;li&gt;3개의 클래스로 예측한 후
            &lt;ul&gt;
              &lt;li&gt;결과 확률이 많이 차이가 안나는 경우 (비등비등)&lt;/li&gt;
              &lt;li&gt;결과 확률이 차이가 크게 나는 경우&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;엔트로피 계산 : 데이터가 얼마나 무질서에 가까운지 측정
            &lt;ul&gt;
              &lt;li&gt;유니폼 분포라면 엔트로피가 높고, 극단적인 분포라면 엔트로피가 낮음&lt;/li&gt;
              &lt;li&gt;엔트로피가 높으면 확신을 많이 하고있진 않겠구나..&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;응용
        &lt;ul&gt;
          &lt;li&gt;Active Learning
            &lt;ul&gt;
              &lt;li&gt;데이터셋을 수집하는 단계부터 생각&lt;/li&gt;
              &lt;li&gt;Label된 데이터가 조금 있고, 새로 취득할 때 어떤 데이터를 취득해야 모델의 학습에 도움이 될까?&lt;/li&gt;
              &lt;li&gt;Labeling은 비싼 작업이므로 최대한 효율적으로 데이터를 수집하는 것이 중요&lt;/li&gt;
              &lt;li&gt;Idea : 모델이 가장 헷갈려하는 데이터를 수집&lt;/li&gt;
              &lt;li&gt;현재 데이터로 모델 학습&lt;/li&gt;
              &lt;li&gt;Unlabeled data들에 대해 예측을 수행&lt;/li&gt;
              &lt;li&gt;예측 확률의 entropy가 가장 큰 sample들을 labeling&lt;/li&gt;
              &lt;li&gt;학습 데이터셋에 추가&lt;/li&gt;
              &lt;li&gt;&lt;strong&gt;어떤 것에 취득해야 할까 알고리즘 학습에 도움이 될까?&lt;/strong&gt;가 핵심
                &lt;ul&gt;
                  &lt;li&gt;unlabeld 데이터에 모두 예측을 한 후, 엔트로피가 높은 것을 선택&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;함정
        &lt;ul&gt;
          &lt;li&gt;최근에 Report된 현상&lt;/li&gt;
          &lt;li&gt;확률값이 부정확하단 말이 있음(not calibrated)&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;MathJax_Preview&quot;&gt;P(Y=1\vert X)&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;P(Y=1\vert X)&lt;/script&gt;가 0.5인 데이터들을 모아놓고 보면
            &lt;ul&gt;
              &lt;li&gt;
                &lt;pre class=&quot;MathJax_Preview&quot;&gt;&lt;code&gt;P(Y=1\vert X) ≠ 0.5&lt;/code&gt;&lt;/pre&gt;
                &lt;script type=&quot;math/tex; mode=display&quot;&gt;P(Y=1\vert X) ≠ 0.5&lt;/script&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;이 현상을 개선하기 위해 많은 연구가 이루어짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Bayesian Machine Learning
    &lt;ul&gt;
      &lt;li&gt;불확실성을 위해 많이 사용하는 기법&lt;/li&gt;
      &lt;li&gt;Bayesian 통계에선 확률=확신의 세기&lt;/li&gt;
      &lt;li&gt;모델의 parametere들을 distribution을 갖는 random variable로 취급&lt;/li&gt;
      &lt;li&gt;단점
        &lt;ul&gt;
          &lt;li&gt;계산이 어려움&lt;/li&gt;
          &lt;li&gt;closed-form solution이 없을 수 있어 근사가 필요&lt;/li&gt;
          &lt;li&gt;필요한 계산 양이 많음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Gaussian Process Regression
        &lt;ul&gt;
          &lt;li&gt;가장 깔끔하고 아름다운 머신러닝 알고리즘 중 한나&lt;/li&gt;
          &lt;li&gt;통계학에서 확률 과정(Stochastic Process) 중 하나인 Gaussian Process를 확장해 ML에 사용할 수 있도록 한 것&lt;/li&gt;
          &lt;li&gt;무한히 많은 개수일 때 어떻게 생각할 수 있을까?&lt;/li&gt;
          &lt;li&gt;무한개 중 아무렇게나 N개를 골라도 가우시안 분포를 가진다고 정의&lt;/li&gt;
          &lt;li&gt;머신러닝에선 예측에 쓸 수 있도록 조금 바꿈
            &lt;ul&gt;
              &lt;li&gt;학습 데이터와 예측 대상이 되는 y가 모두 하나의 Gaussian distribution을 따른다고 가정&lt;/li&gt;
              &lt;li&gt;평균이 0이고 covariance matrix가 커널 function으로 주어짐&lt;/li&gt;
              &lt;li&gt;conditional gaussian distribution의 공식에 의해 평균과 분산을 구함&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Predictive uncertainty가 closed form으로 구해지는 몇 안되는 사례&lt;/li&gt;
          &lt;li&gt;Inverse 곱해서 N^{3}이라 몇천개 넘어가면 계산 속도가 급격하게 하락&lt;/li&gt;
          &lt;li&gt;응용 : Bayesian Optimization
            &lt;ul&gt;
              &lt;li&gt;Auto ML을 시작시킨 개념&lt;/li&gt;
              &lt;li&gt;Active Learning과 유사&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;베이지안 뉴럴넷을 다루고 싶었는데 시간 관계나 난이도상 못다루긴 했는데, 관심이 있다면 더 찾아보기
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1506.02142&quot;&gt;https://arxiv.org/abs/1506.02142&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;제공되는 형태에 초점을 맞춤
    &lt;ul&gt;
      &lt;li&gt;모델 전체에 대해 interpretable을 줄 것인가? 개별에 대한 interpretable을 줄 것인가?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;애초에-interpretable-ml이-가능할까&quot;&gt;애초에 Interpretable ML이 가능할까?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;애초에 가능하면 왜 이 사단이 났을까?&lt;/li&gt;
  &lt;li&gt;데이터엔 신호와 소음으로 나눠서 생각
    &lt;ul&gt;
      &lt;li&gt;데이터마다 다 다름! 어떤 데이터는 신호가 낮고 소음이 많고 어떤 데이터는 신호가 높고 소음이 적음&lt;/li&gt;
      &lt;li&gt;낮은 신호/높은 소음 : 베이즈 에러가 높다고 볼 수 있음 ⇒ 주식/금융 데이터, 사회과학 데이터
        &lt;ul&gt;
          &lt;li&gt;단순한 모델&lt;/li&gt;
          &lt;li&gt;소음이 높으면 오버피팅을 막아야 함&lt;/li&gt;
          &lt;li&gt;데이터의 노이즈를 잘 무시하는 것이 관건&lt;/li&gt;
          &lt;li&gt;단순한 모델이니 설명할 필요가 없음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;높은 신호/낮은 소음 : 베이즈 에러가 낮다고 볼 수 있음 ⇒ 사진, 음성, 텍스트, 바둑
        &lt;ul&gt;
          &lt;li&gt;복잡한 모델&lt;/li&gt;
          &lt;li&gt;언더피팅이 문제&lt;/li&gt;
          &lt;li&gt;데이터가 많이 필요&lt;/li&gt;
          &lt;li&gt;복잡한 패턴을 포착하는 것이 목표&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;고슴도치와 여우
    &lt;ul&gt;
      &lt;li&gt;고슴도치
        &lt;ul&gt;
          &lt;li&gt;초기에 설정한 규칙을 고수, 예측을 잘 못함&lt;/li&gt;
          &lt;li&gt;근본적 아이디어가 모든 것을 결정한다고 생각&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;여우
        &lt;ul&gt;
          &lt;li&gt;사소한 생각과 증거들을 고려하고 면밀히 살핌&lt;/li&gt;
          &lt;li&gt;여러 접근 방법을 동시에 적용&lt;/li&gt;
          &lt;li&gt;한두마디로 설명할 수 없지만 예측력 상승&lt;/li&gt;
          &lt;li&gt;앙상블 알고리즘, ML 알고리즘&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Human-(in/out of)-the Loop
    &lt;ul&gt;
      &lt;li&gt;데이터를 이용해 할 수 있는 일&lt;/li&gt;
      &lt;li&gt;1) 데이터 시각화&lt;/li&gt;
      &lt;li&gt;2) 지식의 생산 (가설 검정)&lt;/li&gt;
      &lt;li&gt;3) 예측&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/99wxe8sbfrornb6/스크린샷 2019-04-14 15.45.09.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Human in the Loop이 interpretable이 중요한 듯&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;신용평가 Credit Scoring 사례
    &lt;ul&gt;
      &lt;li&gt;이 사람이 돈을 빌렸을 때 잘 갚을 수 있을까?&lt;/li&gt;
      &lt;li&gt;굉장히 큰 임팩트를 주고 있다는 것을 깨달음&lt;/li&gt;
      &lt;li&gt;역사
        &lt;ul&gt;
          &lt;li&gt;1941년 미국에서 시작&lt;/li&gt;
          &lt;li&gt;1950년대 후반 Fiar &amp;amp; Isaac에 의해 방법론 정립 후 상용화 ( Score card &amp;amp; Logistic regression)&lt;/li&gt;
          &lt;li&gt;현재 FICO는 세계 최대의 신용정보 회사
            &lt;ul&gt;
              &lt;li&gt;FICO Score가 미국인들에겐 신용등급과 동일한 단어&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;우리 나라는 NICE신용평가, KCB(Korea Credit Bureau)이 수행&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/q8hajyc0hm5uu1j/스크린샷 2019-04-14 15.49.30.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;NIPS 2018 워크샵
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://sites.google.com/view/feap-ai4fin-2018/&quot;&gt;https://sites.google.com/view/feap-ai4fin-2018/&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://community.fico.com/s/explainable-machine-learning-challenge&quot;&gt;https://community.fico.com/s/explainable-machine-learning-challenge&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;Winner : IBM 리서치팀
            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;http://papers.nips.cc/paper/7716-boolean-decision-rules-via-column-generation&quot;&gt;http://papers.nips.cc/paper/7716-boolean-decision-rules-via-column-generation&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;명시적인 룰을 뽑아내는 알고리즘을 만듬&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;2등
            &lt;ul&gt;
              &lt;li&gt;Duke 대학팀&lt;/li&gt;
              &lt;li&gt;왜 굳이 Black-Box 모델을 쓰고 그걸 설명하려고 하나?&lt;/li&gt;
              &lt;li&gt;애초부터 transparent한 white-box 모델을 쓰자&lt;/li&gt;
              &lt;li&gt;거의 유사한 성능을 낸다!&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;http://dukedatasciencefico.cs.duke.edu/&quot;&gt;http://dukedatasciencefico.cs.duke.edu/&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;웹 데모로 직관적으로 표현&lt;/li&gt;
              &lt;li&gt;히든 뉴런에 이름이 달려있음&lt;/li&gt;
              &lt;li&gt;발표자님이 이걸 좋아한 이유 : 단순히 알고리즘이 중요한 것이 아닐 수 있음! 보여주는 과정도 생각을&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Medical 사례
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://nips.cc/Conferences/2018/Schedule?showEvent=12346&quot;&gt;https://nips.cc/Conferences/2018/Schedule?showEvent=12346&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;이 부분을 보니 환자가 ~~ 병이야&lt;/li&gt;
      &lt;li&gt;영국에서 만든 어플리케이션
        &lt;ul&gt;
          &lt;li&gt;유방암 진단을 받은 사람이 얼마나 더 살 수 있는지?&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://breast.predict.nhs.uk/index.html&quot;&gt;https://breast.predict.nhs.uk/index.html&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;결과를 보여줄 때 생존 확률을 보여주고, 아이콘 형태로 100명을 가정할 때 몇명이 살아나는 확률입니다 (심리적으로 검증) 라고 보여줌&lt;/li&gt;
          &lt;li&gt;어플리케이션 자체가 신뢰를 얻어야 함&lt;/li&gt;
          &lt;li&gt;의사, 간호사, 환자, 환자 부모님, 연구자 등 다양한 이해 관계자가 설명을 얻어가는 포인트가 다름&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Communicating Uncertainty
    &lt;ul&gt;
      &lt;li&gt;생각보다 사람은 확률을 잘 인지하지 못한다&lt;/li&gt;
      &lt;li&gt;생존 확률이 0.92 → 와닿지 않음&lt;/li&gt;
      &lt;li&gt;100명 중 92명이 생존 → 와닿음&lt;/li&gt;
      &lt;li&gt;Heart Age
        &lt;ul&gt;
          &lt;li&gt;나의 심장질환 발병확률(위험)이 몇 세의 확률과 같은가?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Explainable AI는 종합예술
    &lt;ul&gt;
      &lt;li&gt;다면적인 설명이 제공될 필요가 있음
        &lt;ul&gt;
          &lt;li&gt;인간은 본능적으로 거짓이 아닌 것은 여러 각도에서 보아도 참이라는 것을 알고 있음&lt;/li&gt;
          &lt;li&gt;다양한 측면에서 제공된 정보가 모두 일치할 때 신뢰를 얻을 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;복합적인 요소가 작용
        &lt;ul&gt;
          &lt;li&gt;심리, 통계, 윤리, 디자인, 언어&lt;/li&gt;
          &lt;li&gt;사용자 스터디, 좋은 기획, 좋은 디자인이 필요&lt;/li&gt;
          &lt;li&gt;끝판왕 알고리즘 하나로 해결되는 문제가 아님!&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다하지 못한 이야기
    &lt;ul&gt;
      &lt;li&gt;Shapley Value&lt;/li&gt;
      &lt;li&gt;Bayesian Deep Learning&lt;/li&gt;
      &lt;li&gt;하나 더 있었는데 발표자료 보고 작성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;질문&quot;&gt;질문&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Self Attention과 Grad CAM의 차이는?
    &lt;ul&gt;
      &lt;li&gt;아이디어 공유되는 것이 있음&lt;/li&gt;
      &lt;li&gt;Attention 기법은 모델을 설계할 때 애초에 입력한 데이터를 중점적으로 볼지 말지 취사선택 하는 모듈을 중간에 넣는 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 14 Apr 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/data/2019/04/14/interpretable-ml-intro/</link>
        <guid isPermaLink="true">https://zzsza.github.io/data/2019/04/14/interpretable-ml-intro/</guid>
        
        <category>interpretable</category>
        
        
        <category>data</category>
        
      </item>
    
      <item>
        <title>Google Cloud Next 19 정리 및 후기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Cloud Next 19의 영상들을 보고 정리한 글입니다
    &lt;ul&gt;
      &lt;li&gt;다음엔 저도 현장에 가서 이런 내용들을 듣고 싶네요!(잘 정리하고 전파할 수 있는데..!)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정리한 영상
    &lt;ul&gt;
      &lt;li&gt;ML Ops Best Practices on Google Cloud&lt;/li&gt;
      &lt;li&gt;Accelerating Machine Learning App Development with Kubeflow Pipelines&lt;/li&gt;
      &lt;li&gt;What’s New with BigQuery ML and Using it to Assess Data Quality&lt;/li&gt;
      &lt;li&gt;Data Processing in Google Cloud: Hadoop, Spark, and Dataflow&lt;/li&gt;
      &lt;li&gt;Rethinking Business: Data Analytics With Google Cloud&lt;/li&gt;
      &lt;li&gt;AI Hub: The One Place for Everything AI&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;메모&quot;&gt;메모&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;영상 볼 수 있는 곳
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://cloud.withgoogle.com/next/sf/next-onair&quot;&gt;https://cloud.withgoogle.com/next/sf/next-onair&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;다양한 분야 중 Analyze &amp;amp; Learn archive를 중점적으로 봄&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Google Cloud 블로그 글
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/blog/products/ai-machine-learning/all-ai-announcements-from-google-next19-the-smartest-laundry-list&quot;&gt;All 29 AI announcements from Google Next ‘19: the smartest laundry list&lt;/a&gt; : AI/인공지능 기술에 대한 총 정리 글&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/blog/topics/inside-google-cloud/100-plus-announcements-from-google-cloud-next19&quot;&gt;News to build on: 122+ announcements from Google Cloud Next ‘19&lt;/a&gt; : Cloud Next 19에서 나온 모든 새로운 것 정리&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/blog/topics/inside-google-cloud/next19-recap-day1&quot;&gt;Cloud Next 1일차 정리&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/blog/topics/inside-google-cloud/day-2-next-19-working-smarter-better-and-more-securely-cloud&quot;&gt;Cloud Next 2일차 정리&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/blog/topics/inside-google-cloud/next19-recap-day3&quot;&gt;Cloud Next 3일차 정리&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이상훈님의 &lt;a href=&quot;https://www.facebook.com/phoenixlee.sh/posts/2634407856601132&quot;&gt;2일차 정리글&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;총평
    &lt;ul&gt;
      &lt;li&gt;우선 구글 클라우드의 데이터 처리 도구들(Pub/Sub, Dataflow, Dataproc, BigQuery)는 정말 강력하고 더 쉽게 사용할 수 있게 됨
        &lt;ul&gt;
          &lt;li&gt;진입 장벽이 낮아지는 중&lt;/li&gt;
          &lt;li&gt;미래엔 데이터 엔지니어링 스킬이 기본적으로 있는 머신러닝 엔지니어들도 많이 나올 것 같음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;AI Platform, Kubeflow, TFX, TFDV, TFMA 등을 보면 MLOps도 활발하게 진행되고 있는 듯?
        &lt;ul&gt;
          &lt;li&gt;Kubeflow 정복할 예정! 이걸 위해 쿠버네티스 공부중..&lt;/li&gt;
          &lt;li&gt;Tensorflow보다 PyTorch가 상승하는 것 같지만 프러덕션에선 대부분 Tensorflow를 써야할 듯
            &lt;ul&gt;
              &lt;li&gt;지향점이 다른 느낌&lt;/li&gt;
              &lt;li&gt;그냥 토치 텐서 다 상관없이 해야할 듯?&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;회사에서 BigQuery쪽은 적극적으로 사용하고 있기 때문에 최신 기능을 모두 팔로업하고 있는데, 다른 도구들도 조금씩 테스트해보고 좋은 것은 바로 사용해볼 예정!&lt;/li&gt;
      &lt;li&gt;서울 리전!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ml-ops-best-practices-on-google-cloud&quot;&gt;ML Ops Best Practices on Google Cloud&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=20h_RTHEtZI&quot;&gt;https://www.youtube.com/watch?v=20h_RTHEtZI&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;MLOps Challenges
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/kqwjascfp2tnq6c/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-12%2022.57.22.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data Validation
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.tensorflow.org/tfx/data_validation/get_started&quot;&gt;TFDV&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/8vl3uvr56wa29kb/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-12%2023.13.47.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/14kjzk2tsokql9y/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-12%2023.14.11.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Model Analyze
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.tensorflow.org/tfx/model_analysis/get_started&quot;&gt;TFMA&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;Model 정확도가 시간이 지나며 점점 낮아지고 지속적 모니터링이 불가능한 상황이 자주 오는데, 이럴 때 사용하면 좋음&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/kvvs6o4rmnwsr3c/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-12%2023.22.21.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/uaixck53fkfm208/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-12%2023.24.27.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/0ifgpk12qdlqpzf/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-12%2023.26.50.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;trip_start_hour가 특정 값일때 정확도를 알려줌
  	- 예시 : 현재 모델이 주간엔 정확도가 높고 야간엔 낮다 이런 결론이 나올 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Kubeflow
    &lt;ul&gt;
      &lt;li&gt;Kubernetes-native OSS Platform to Develop, Deploy and Manage Scalable and End-to-End ML Workloads&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Cloud AI Platform
    &lt;ul&gt;
      &lt;li&gt;A code-based intergrated development environment for data science and machine learning inside the GCP console&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ni6y9e6tasw9ma5/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2000.07.22.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/pl2qcm80z02etme/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2000.12.19.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/05tnudp8mg5axna/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2000.12.44.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;아키텍쳐
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9fbqtejea5ki416/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2000.14.25.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/0t5enhuy9q39hyv/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2000.15.50.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;accelerating-machine-learning-app-development-with-kubeflow-pipelines&quot;&gt;Accelerating Machine Learning App Development with Kubeflow Pipelines&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=TZ1lGrJLEZ0&quot;&gt;https://www.youtube.com/watch?v=TZ1lGrJLEZ0&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zzsza.github.io/data/2018/01/28/hidden-technical-debt-in-maching-learning-systems/&quot;&gt;Hidden Technical Debt in ML Systems&lt;/a&gt;를 보면 모델링이 차지하는 부분은 매우 작음&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.kubeflow.org/&quot;&gt;Kubeflow&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;A Kubernetes-native open source platform to develop, deploy and manage, scalable ML Workloads&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ML Workflow Orchestration
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/odt09jlkibamud7/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.14.16.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/rwfdrgj7fd04ad7/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.19.02.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;코드 예제
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/sb5bzxzxqj8i01m/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.19.54.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Share, Re-use &amp;amp; Compose
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/6icgiyldirc4xz6/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.21.21.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;zip 파일로 올림(람다에서도 이렇게 진행)&lt;/li&gt;
      &lt;li&gt;AI Hub도 사용 가능
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/y473qnjfrdblqh2/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.22.00.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;코드 예제
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/f8xon3c5kg4s50y/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.22.18.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rapid Reliable Experimentation
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/0f2vu12npoqd7cz/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.23.12.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/g3vet8pecqxzj3p/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.23.22.png?raw=1&quot; /&gt;
        &lt;ul&gt;
          &lt;li&gt;MlFlow랑 비교해서 어떤 우위가 있는지 궁금&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/4fow7szw0umzq7b/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.23.54.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/6dt7713assf2p3s/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.24.39.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;GOJEK
    &lt;ul&gt;
      &lt;li&gt;싱가포르, 인도네시아, 베트남, 태국에서 교통, 물류 등의 서비스를 하고 있는 기업&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/8hd7foe2s1sh9u4/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.27.01.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/hlc0rq4txo3j15v/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.27.17.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Airflow를 사용했는데, 아래 이유로 Kubeflow 도입
        &lt;ul&gt;
          &lt;li&gt;실험하기 어려움&lt;/li&gt;
          &lt;li&gt;엔지니어링 무거움&lt;/li&gt;
          &lt;li&gt;Low traceability and reproducibility&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Data pipeline은 Airflow를 쓰고, ML pipeline은 Kubeflow 사용
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/fhhps7re6g949jx/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.30.10.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/gkjzprcsd7eumbb/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.30.55.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;roc 커브도 그려줌&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/3l5a7gxtjao9qeg/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.32.51.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;TFX Taxi 예제
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/hlxdsw5vsnb9cof/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.33.27.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/2uf0du393jt7jrg/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.33.57.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/nlixphmj86t9cau/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.34.39.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;TFMA를 Static HTML로 생성해줌&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;whats-new-with-bigquery-ml-and-using-it-to-assess-data-quality&quot;&gt;What’s New with BigQuery ML and Using it to Assess Data Quality&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=DnlG4frLKmw&quot;&gt;https://www.youtube.com/watch?v=DnlG4frLKmw&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zzsza.github.io/gcp/2018/08/03/bigqueryml/&quot;&gt;BigQuery ML&lt;/a&gt;의 새로운 기능에 대해 말해줌&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/2j41htu4m7qalgz/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.38.35.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;New BigQuery UI
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/4yh9n5ln4c15bi6/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.38.58.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;현기증 납니다.. 빨리 나와주세요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Matrix Factorization
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/p82vj7wp49q6v2l/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.39.28.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NCAA 농구 3점슛 예측
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/rmldqf4v8fxxdy1/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.39.59.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TensorFlow
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/dcu87vkywus6nj5/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.40.29.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Feautre pre-processing function
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/z072npxtlpzw48o/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.40.52.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;BUCKETIZE, POLYNOMIAL_EXPAND, FEATURE_CROSS 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시연
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/groovenauts/QueryItSmart&quot;&gt;QueryItSmart&lt;/a&gt; Github 참고&lt;/li&gt;
      &lt;li&gt;BigQuery + Cloud ML engine을 사용한 웹 데모&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;K means clustering
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/daa97kxjc03q8rw/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.46.33.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Booking.com의 시연
    &lt;ul&gt;
      &lt;li&gt;빅쿼리로 kmenas 진행(클러스터 개수 21개)한 후 데이터 스튜디오로 시각화&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/lizg8uw38l6urol/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.48.30.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ptdopkb7kv04v7l/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.49.58.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;data-processing-in-google-cloud-hadoop-spark-and-dataflow&quot;&gt;Data Processing in Google Cloud: Hadoop, Spark, and Dataflow&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=GRP-cGbJSCs&quot;&gt;https://www.youtube.com/watch?v=GRP-cGbJSCs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;이미 많이 알던 내용들인데, 새롭게 알게된 내용 위주로 캡쳐&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/849mvs0cuc4evrh/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.00.17.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/7vwqbypxxsipykj/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.00.34.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/zidbjll9urrxkfm/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.00.48.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Dataflow
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/tyb9x1499xe0c5j/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.01.10.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;1년 사이에 템플릿이 정말 많아짐&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/0y2mqdo8ud4g515/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.03.50.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Dataproc
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/64ukdqwcnewieum/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.04.24.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Web interface에서 제플린 선택 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;rethinking-business-data-analytics-with-google-cloud&quot;&gt;Rethinking Business: Data Analytics With Google Cloud&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=DpngHc31a5Y&quot;&gt;https://www.youtube.com/watch?v=DpngHc31a5Y&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Platform
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/wkgkax05ww11oy6/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.54.08.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data Funsion
    &lt;ul&gt;
      &lt;li&gt;Google &lt;a href=&quot;https://cloud.google.com/data-fusion/&quot;&gt;Data Fusion&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/yy98uamifj5hyl4/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.54.37.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;코드 없이 파이프라인 생성&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/rwjb56x4dmsxdth/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.56.45.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BigQuery flat-rate with Reservations
    &lt;ul&gt;
      &lt;li&gt;예약제 요금제?&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/pppf9nul4xkdj2i/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.57.52.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BigQuery Storage API
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/flavb24cnyv3dgb/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.58.22.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BI Engine
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/lpgu8ytcklbhh4q/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.59.06.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;시각화하는 도구 같은데, Tableau를 대체할 수 있을지 궁금&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Dataproc and Composer
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/tj2ruljdtnyyryp/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2002.00.33.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Composer는 Managed Airflow인데, 사용하다보면 약간 불편한 점도 있긴함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Stream 데이터 처리하는 파이프라인
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/126rs7ebz6xh9ij/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2002.01.40.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Dataflow SQL
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/389dqh15qlgg1wr/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2002.01.57.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/aiylt1wu3hi09vd/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2002.07.18.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;빅쿼리 콘솔에서 Dataflow Engine으로 설정한 후, 아래 쿼리 날림&lt;/li&gt;
      &lt;li&gt;TUMBLE_START는 처음 보는데 신기..&lt;/li&gt;
      &lt;li&gt;쿼리 날리면 내부적으로 Beam이 데이터 읽고 전처리하는듯&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  SELECT sr.sales_region, TUMBLE_START(&quot;INTERVAL 5 SECOND&quot;) AS period_start, SUM(tr.payload.amount) as amount
  FROM `pubsub.dataflow-sql.transactions` as tr
      INNER JOIN `bigquery.dataflow-sql.opsdb.us_state_salesregions` AS sr
      ON tr.payload.state = sr.state_code
  GROUP BY sr.sales_region, TUMBLE(tr.event_timestamp, &quot;INTERVAL 5 SECOND&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/mluaams5n0o31yz/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2002.05.47.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;pubsub 토픽을 바로 넣어서 쓰는듯..?&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/637pcfwpwj51u79/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2002.08.08.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data Catalog
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/z4fegch5hwi7a2v/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.53.05.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/5r7h4my6cq57ybi/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-13%2001.53.40.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ai-hub-the-one-place-for-everything-ai&quot;&gt;AI Hub: The One Place for Everything AI&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=QMTT2ngnj9Q&quot;&gt;https://www.youtube.com/watch?v=QMTT2ngnj9Q&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Google &lt;a href=&quot;https://cloud.google.com/ai-hub/&quot;&gt;AI Hub&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;AI Hub에 대한 설명, 다른 세션과 겹치는 부분이 있는 느낌&lt;/li&gt;
  &lt;li&gt;Kubeflow, TFX에 대해 이야기함&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 13 Apr 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/gcp/2019/04/13/google-next19-review/</link>
        <guid isPermaLink="true">https://zzsza.github.io/gcp/2019/04/13/google-next19-review/</guid>
        
        <category>basic</category>
        
        
        <category>gcp</category>
        
      </item>
    
      <item>
        <title>Kotlin 기본 문법 정리</title>
        <description>&lt;ul&gt;
  &lt;li&gt;코틀린 기본 문법에 대한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;kotlin&quot;&gt;Kotlin&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;코틀린은 안드로이드나 서버 개발을 할 때 사용할 수 있는 언어&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kotlinlang.org/docs/reference/server-overview.html&quot;&gt;kotlin server overview&lt;/a&gt; 참고하면 서버 사이드에서 장점을 알 수 있음
    &lt;ul&gt;
      &lt;li&gt;자바에서 많이 쓰이는 Spring도 사용 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://engineering.vcnc.co.kr/2019/01/tada-system-architecture/&quot;&gt;VCNC 시스템 아키텍쳐&lt;/a&gt;를 보면 서버 언어를 코틀린으로 쓰는 회사가 점점 증가하는듯!
    &lt;ul&gt;
      &lt;li&gt;이 코드를 읽기 위해 코틀린을 공부합니다..!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;basic-syntax&quot;&gt;Basic Syntax&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;패키지 정의&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;demo&lt;/span&gt;
    
  &lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.*&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;함수 정의
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;fun 키워드로 정의&lt;/p&gt;

        &lt;p&gt;fun sum(a: Int, b: Int): Int {
      return a + b
  }&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;함수 몸체가 식인 경우 return 생략 가능, return type이 추론됨&lt;/p&gt;

        &lt;p&gt;fun sum(a: Int, b: Int) = a + b&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;리턴할 값이 없는 경우 Unit(Object)으로 리턴
        &lt;ul&gt;
          &lt;li&gt;자바의 void 역할&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;fun printKotlin(): Unit {
  	println(“Hello Kotlin”)
  }&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Unit은 생략 가능&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  fun printKotlin() {
  	println(&quot;Hellok Kotlin&quot;)
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;변수 정의
    &lt;ul&gt;
      &lt;li&gt;val : 읽기전용 변수&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;값의 할당이 1회만 가능, 자바의 final과 유사&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  val a: Int = 1
  val b = 2 // int type 추론
  val c: Int // 컴파일 오류, 초기화 필요(값 할당 안함)
  c = 3 // 컴파일 오류, 읽기 전용이라 추후에 할당 불가
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;var : Mutable 변수&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var x = 5
  x += 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;주석
    &lt;ul&gt;
      &lt;li&gt;자바와 자바스크립트와 동일&lt;/li&gt;
      &lt;li&gt;// : 한줄 추석&lt;/li&gt;
      &lt;li&gt;/* */ : 여러 줄 주석(여러개 중첩 가능)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;문자열 템플릿
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;String Interpolation(문자열 보간법)&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var a = 1
  val s1 = &quot;a is $a&quot;
        
  a = 2
  val s2 = &quot;${s1.replace('is', 'was')}, but now is $a&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;조건문&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  fun maxOf(a: Int, b: Int): Int {
  	if (a &amp;gt; b) {
  		return a
  	} else {
  		return b
  	}
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;조건식으로 사용 가능&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  fun maxOf(a: Int, b: Int) = if (a&amp;gt;b) a else b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;nullable
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;값이 null일 수 있는 경우 타입에 nullable 마크를 명시&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  func parseInt(str: String): Int?{
  // 정수가 아니면 null 리턴
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;nullable 타입의 변수를 접근할 땐 반드시 null 체크를 해야 함&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;그렇지 않으면 컴파일 오류 발생&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  fun printProduct(arg1: String, arg2: String) {
  	val x: Int? = parseInt(arg1)
  	val y: Int? = parseInt(args2)
        
  	if (x != null &amp;amp;&amp;amp; y!= null) {
  		println(x*y)
  	} else {
  		println(&quot;eithe '$arg1' or '$arg2' is not a number&quot;)
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자동 타입 변환
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;타입 체크만 해도 자동으로 타입 변환!!!&lt;/p&gt;

        &lt;p&gt;obj: Any는 object의 최상위 객체&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  fun getStringLength(obj: Any): Int?{
  	if (obj is String) {
  			// obj가 자동으로 string 타입으로 변환
  			return obj.length
  	}
  	return null
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;while loop&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  val items = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwi&quot;)
  var index = 0
  while (index &amp;lt; items.size) {
  	println(&quot;item at $index is ${items[index]}&quot;)
  	index ++
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;when expression&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  fun describe(obj: Any): String =
  		when (obj) {
  			1 -&amp;gt; &quot;One&quot;
  			&quot;Hello&quot; -&amp;gt; &quot;Greeting&quot;
  			is Long -&amp;gt; &quot;Long&quot;
  			!is String -&amp;gt; &quot;Not a string&quot;
  			else -&amp;gt; &quot;Unknown&quot;
  		}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;ranges
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;In 연산자를 이용해 숫자 범위 체크 가능&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  val x = 3
  if (x in 1..10) {
  	println(&quot;fits in range&quot;)
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;range를 이용한 for loop&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  for (x in 1..5) {
  	println(x)
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;collections
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;컬렉션도 in으로 loop 가능&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  val items = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwi&quot;)
  for (item in items) {
  	println(item)
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;in으로 해당 값이 collection에 포함되는지 체크 가능&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  val items = setOf(&quot;apple&quot;, &quot;banan&quot;, &quot;kiwi&quot;)
  when {
  	&quot;orange&quot; in items -&amp;gt; println(&quot;juicy&quot;)
  	&quot;apple&quot; in items -&amp;gt; println(&quot;apple is fine too&quot;)
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;람다식을 이용해 컬렉션에 filter, map 연산 가능&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  val fruits = listOf(&quot;banana&quot;, &quot;avocado&quot;, &quot;apple&quot;, &quot;kiwi&quot;)
  fruits
  			.filter { it.startsWith&quot;a&quot;) }
  			.sortedBy { it }
  			.map { it.toUpperCase() }
  			.forEach { println(it) }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;basic-types&quot;&gt;Basic Types&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;기본 타입
    &lt;ul&gt;
      &lt;li&gt;코틀린은 모두 객체&lt;/li&gt;
      &lt;li&gt;모든 것에 멤버 함수나 프로퍼티를 호출 가능!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;숫자
    &lt;ul&gt;
      &lt;li&gt;Java의 숫자와 비슷&lt;/li&gt;
      &lt;li&gt;Kotlin에서 Number는 클래스&lt;/li&gt;
      &lt;li&gt;Java에서 숫자형이던 char가 kotlin에선 숫자형이 아님&lt;/li&gt;
      &lt;li&gt;리터럴(Literal)
        &lt;ul&gt;
          &lt;li&gt;10진수 (Int, Short)&lt;/li&gt;
          &lt;li&gt;Long&lt;/li&gt;
          &lt;li&gt;Double&lt;/li&gt;
          &lt;li&gt;Float&lt;/li&gt;
          &lt;li&gt;2진수&lt;/li&gt;
          &lt;li&gt;8진수는 미지원&lt;/li&gt;
          &lt;li&gt;16진수&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Underscore in numeric literals
        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;언더스코어를 사용해 표현 가능&lt;/p&gt;

            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  val oneMillon = 1_000_000
  val creditCardNumber = 1234_5678_9012_3456L
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Representation
    &lt;ul&gt;
      &lt;li&gt;Java 플랫폼에서 숫자형은 JVM primitive type으로 저장&lt;/li&gt;
      &lt;li&gt;Nullable이나 제네릭의 경우엔 박싱&lt;/li&gt;
      &lt;li&gt;박싱된 경우엔 identity를 유지하지 않음&lt;/li&gt;
      &lt;li&gt;show bytecode → decompile하면 자바 코드로 변환&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Explicit Conversions
    &lt;ul&gt;
      &lt;li&gt;작은 타입은 큰 타입의 하위 타입이 아님&lt;/li&gt;
      &lt;li&gt;즉, 작은 타입에서 큰 타입으로 대입이 안됨
        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;숫자끼리 변화할 땐 명시적으로 변환해야 함&lt;/p&gt;

            &lt;p&gt;val i: Int = b.toInt()
  // toByte(), toShort(), toInt() …&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;문자
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Char는 숫자로 취급되지 않음&lt;/p&gt;

        &lt;p&gt;fun check(c: Char) {
  	if (c == ‘a’)
  }&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;배열
    &lt;ul&gt;
      &lt;li&gt;배열은 Array 클래스로 표현&lt;/li&gt;
      &lt;li&gt;get, set ([] 연산자 오버로딩됨)&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;size 등 유용한 멤버 함수 포함&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var array: Array&amp;lt;String&amp;gt; = arrayOf(&quot;코틀린&quot;, &quot;강좌&quot;)
  println(array.get(0))
  println(array[0])
  println(array.size)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;배열 생성
        &lt;ul&gt;
          &lt;li&gt;Array의 팩토리 함수 사용&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;arrayOf() 등의 라이브러리 함수 이용&lt;/p&gt;

            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  val b = Array(5, { i -&amp;gt; i.toString() })
            
  val a = arrayOf(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;특별한 Array 클래스
        &lt;ul&gt;
          &lt;li&gt;primitive 타입의 박싱 오버헤드를 없애기 위한 배열&lt;/li&gt;
          &lt;li&gt;IntArray, ShortArray, IntArray&lt;/li&gt;
          &lt;li&gt;Array를 상속한 클래스는 아니지만 Array와 같은 메소드, 프로퍼티를 가짐&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;size 등 유용한 멤버 함수 포함&lt;/p&gt;

            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  val x: IntArray = intArrayOf(1, 2, 3)
  x[0] = 7
  println(x.get(0))
  println(x[0])
  println(x.size)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;문자열
    &lt;ul&gt;
      &lt;li&gt;문자열은 String 클래스로 구현&lt;/li&gt;
      &lt;li&gt;String은 characters로 구성&lt;/li&gt;
      &lt;li&gt;s[i] 같은 방식으로 접근 가능&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;immutable이므로 변경은 불가&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var x: String = &quot;Kotlin&quot;
  println(x.get(0))
  println(x.length)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;문자열 리터럴
        &lt;ul&gt;
          &lt;li&gt;escape string (“Kotlin”)
            &lt;ul&gt;
              &lt;li&gt;전통적인 방식으로 Java String과 비슷&lt;/li&gt;
              &lt;li&gt;Backslash를 사용해 escaping 처리&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;raw string (“&quot;”Kotlin”””)
            &lt;ul&gt;
              &lt;li&gt;escaping 처리 필요 없음&lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;개행이나 어떤 문자 포함 가능&lt;/p&gt;

                &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  val s = &quot;Hello, world₩n&quot;
	            
  val s = &quot;&quot;&quot;
  '''이것은 코틀린의
   raw String
  입니다.'''
  &quot;&quot;&quot; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                &lt;/div&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://kotlinlang.org/docs&quot;&gt;코틀린 공식 문서&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.inflearn.com/course/코틀린-강좌-새차원&quot;&gt;인프런, 코틀린 강의&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/development/2019/04/11/kotlin-basic/</link>
        <guid isPermaLink="true">https://zzsza.github.io/development/2019/04/11/kotlin-basic/</guid>
        
        <category>kotlin</category>
        
        
        <category>development</category>
        
      </item>
    
      <item>
        <title>데이터 사이언티스트가 되기 위해 진행한 다양한 노력들</title>
        <description>&lt;ul&gt;
  &lt;li&gt;데이터 공부를 시작하고 현재까지, 제 일대기에 대해 작성한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;다양한 경로로 진로 관련 질문을 많이 받고 있습니다
    &lt;ul&gt;
      &lt;li&gt;특히 제가 자주 받는 질문은 &lt;strong&gt;“문과생”&lt;/strong&gt;이고 &lt;strong&gt;대학원&lt;/strong&gt;도 진학하지 않았는데 어떻게 공부했는지?입니다&lt;/li&gt;
      &lt;li&gt;이런 질문을 많이 받다보니 글로 남기면 좋지 않을까! 생각해서 글을 작성합니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;약 4년간 과거를 회고하려고 합니다&lt;/li&gt;
  &lt;li&gt;제가 진행한 내용이 &lt;strong&gt;답은 아니고 누군가는 저렇게 했구나&lt;/strong&gt; 정도로 이해하면 좋을 것 같습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;첫-시작&quot;&gt;첫 시작&lt;/h2&gt;
&lt;h3 id=&quot;간단한-자기소개&quot;&gt;간단한 자기소개&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;저에 대해 간략히 설명하면 경영학을 전공했고(부전공, 복수전공 없습니다) 대학 입학하고 2년간 놀다가 군대에 갔습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2013년&quot;&gt;2013년&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;전역 후엔 대학생 연합 광고동아리인 애드파워에서 “광고”, “디자인”을 공부했습니다
    &lt;ul&gt;
      &lt;li&gt;경쟁 PT나 광고 공부를 통해 자신의 생각을 어떻게 효율적으로 전달할지, 기획이란 무엇인지 등을 조금이나마 배웠습니다&lt;/li&gt;
      &lt;li&gt;광고 전반, 디자인/영상에 대해 알 수 있었고 좋은 사람들을 많이 만나서 후회하지 않는 생활이었지만, 광고를 업으로 삼을 수 없을 것 같다는 생각이 들었습니다&lt;/li&gt;
      &lt;li&gt;그나마 관심있던 직군은 미디어 플래너였습니다. 수학이나 통계학을 좋아했던 성향이 있어서 매체별 데이터를 다루는 미디어 플래너에 대해 관심이 있었습니다&lt;/li&gt;
      &lt;li&gt;실제 데이터를 보니 너무 가공된 데이터란 생각을 했고, 한단계 깊은 데이터를 보고 싶었습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;R을 활용한 데이터 분석이 궁금해 한국 RFID/USN 융합협회에서 진행한 “R 기반 빅데이터 분석 입문 과정”을 2013년 9월에 들었습니다
    &lt;ul&gt;
      &lt;li&gt;하지만 이 시기에 들은 내용 중 지금 기억나는건 전혀 없네요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2014년&quot;&gt;2014년&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2013년~2014년엔 공기업에서 계약직으로 근무했습니다
    &lt;ul&gt;
      &lt;li&gt;3학년으로 복학했지만 학교 공부에 흥미가 없어서 학점도 낮아서 그냥 회사에선 어떤 일을 하는지 알고싶어 인천도시공사에 지원했는데, 합격했습니다&lt;/li&gt;
      &lt;li&gt;간단한 사무보조부터 각종 행정처리, 건축 토목 현장 관리 등을 진행했습니다&lt;/li&gt;
      &lt;li&gt;돌이켜보니 그냥 이 시기는 멍 때리던 시기입니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공기업에 취업할 생각도 있어서 시작했지만, 결론적으로 전 조금 더 액티브한 삶을 지향한다는 것을 알게 되었습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2015년&quot;&gt;2015년&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2014년 말부터 지인들과 창업했습니다&lt;/li&gt;
  &lt;li&gt;와디즈에서 500만원 펀딩을 받으며 시작했습니다
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.wadiz.kr/web/campaign/detail/698&quot;&gt;달다쓰다 - 또 하나의 작은 게양&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;진행했던 업무는 운영, 회계, 배송, 온라인 마케팅 등 다양한 일을 했습니다. 일하던 도중 “내가 진짜 하고 싶은 일이 지금 하는 일들일까?”라는 생각에 창업팀에서 빠지고 데이터 공부를 본격적으로 시작했습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2015년은 요즘처럼 인터넷에 데이터 관련 다양한 정보가 넘치진 않던 시절입니다(참고로 우리가 많이 알고있는 알파고는 2016년에 나왔습니다)&lt;/li&gt;
  &lt;li&gt;그 당시 진행했던 것은 크게 2가지입니다
    &lt;ul&gt;
      &lt;li&gt;1) 빅데이터 동아리 BOAZ 활동&lt;/li&gt;
      &lt;li&gt;2) 오늘 밤부터 쓰는 GA 수강&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;빅데이터 동아리 보아즈 활동
    &lt;ul&gt;
      &lt;li&gt;공모전도 활성화되지 않았고, 책도 많이 없기 때문에 비슷한 지향점을 가지는 사람들을 알고 싶어 빅데이터 동아리에 지원했습니다&lt;/li&gt;
      &lt;li&gt;기반 능력이 거의 없음에도 불구하고 다행히 합격했습니다&lt;/li&gt;
      &lt;li&gt;하지만 저는 공부보단, 그냥 동아리에 출석하고 가끔 뒷풀이 가는 삶을 살았던 기억이 나네요&lt;/li&gt;
      &lt;li&gt;요새 동아리 후배분들을 보니 정말 많은 고민을 하고, 빡세게 공부를 잘 하고 있는 것 같습니다&lt;/li&gt;
      &lt;li&gt;프로젝트 진행할 때도 R과 파이썬을 거의 못했던 기억이 납니다&lt;/li&gt;
      &lt;li&gt;단, “빅데이터”란 공통된 흥미를 가진 사람들을 만났던 것이 정말 좋았습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;오늘 밤부터 쓰는 GA 수강
    &lt;ul&gt;
      &lt;li&gt;이 강의는 알렉스앤컴퍼니에서 진행한 강의입니다&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9r3dgpfb1onztsi/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-05%2022.02.33.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Google Analytics를 통해 데이터 분석할 수 있단 소식을 듣고 수강했습니다&lt;/li&gt;
      &lt;li&gt;돌이켜 보면 이 강의를 통해 하용호님을 만날 수 있었고, 계속 데이터 공부를 할 자극을 얻었습니다&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/6cwfx9buyy7tkxa/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-05%2022.04.06.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;하용호님은 어려운 내용을 정말 쉽게 설명해주시는 것으로 유명합니다! &lt;a href=&quot;https://www.slideshare.net/yongho&quot;&gt;슬라이드쉐어&lt;/a&gt;에 가면 자료를 볼 수 있습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2016년&quot;&gt;2016년&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;빅데이터 동아리 활동이 끝난 후, 4학년 2학기인 저는 깊은 고민에 빠졌습니다
    &lt;ul&gt;
      &lt;li&gt;“진짜 데이터를 더 공부하고 싶은가? 아니면 그냥 취업할까?”&lt;/li&gt;
      &lt;li&gt;“대학원에 갈까?”&lt;/li&gt;
      &lt;li&gt;아마 이런 고민들은 지금도 많은 분들이 고민할 내용이라 생각합니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;깊은 고민 끝에 내린 결론은 “연구”보단 실제로 제 능력을 갖고 싶었습니다&lt;/li&gt;
  &lt;li&gt;대학원이 아닌 다른 방법을 찾아보던 도중, 패스트캠퍼스 데이터사이언스 스쿨을 찾았고 2기를 등록했습니다
    &lt;ul&gt;
      &lt;li&gt;360만원의 학원비와 신사 고시텔 생활비 180만원, 금전적으론 약 500만원, 시간은 3개월 정도 할애해야 하는 과정이었습니다&lt;/li&gt;
      &lt;li&gt;하지만 투자할 가치를 느꼈고, 잘한 선택이라고 생각합니다&lt;/li&gt;
      &lt;li&gt;이 기간에 어떻게 코딩해야 하는지, 데이터 사이언스에 대한 전반적 지식을 얻을 수 있었습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공부한 내용을 조금씩 기록하잔 의미로 인스타그램에 공부 계정 : &lt;a href=&quot;https://instagram.com/data.scientist/&quot;&gt;data.scientist&lt;/a&gt;을 만들고 글을 꾸준히 올렸습니다. 요새도 올리고 있습니다&lt;/li&gt;
  &lt;li&gt;패스트캠퍼스
    &lt;ul&gt;
      &lt;li&gt;개발을 전혀 모르던 제게 많은 지식을 얻게 해준 과정입니다&lt;/li&gt;
      &lt;li&gt;요샌 광고가 많아서 대부분 패스트캠퍼스를 알고, 고민할 것 같습니다&lt;/li&gt;
      &lt;li&gt;요샌 인터넷에 많은 자료가 공개되었기 때문에 학원을 안 다녀도 된다는 분들이 많습니다. 맞습니다. 제가 공부하던 시기보단 자료가 많아졌습니다. 따라서 굳이 학원으로 시작을 하지 않아도 되긴 합니다&lt;/li&gt;
      &lt;li&gt;아예 초심자고, 의지를 컨트롤하기 힘들 것 같은 경우엔 학원도 나쁘진 않단 생각을 합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;많은 지식을 쌓았고, 여러 회사에 면접을 봤습니다
    &lt;ul&gt;
      &lt;li&gt;아직도 기억에 나는 면접은 “아프리카TV”의 데이터 분석가 면접입니다&lt;/li&gt;
      &lt;li&gt;데이터 분석가로 진행하는 거의 첫 면접인 동시에 사전 과제를 처음 겪은 면접입니다
        &lt;ul&gt;
          &lt;li&gt;아프리카TV의 데이터 일부분을 주고, 분석하는 문제였습니다&lt;/li&gt;
          &lt;li&gt;데이터를 보고 “왜 이런 사람이 있지? 이 데이터는 뭘까? 왜 이런 결과가 나오지?” 등을 고민하며 즐거웠습니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;사실 면접 다음 달에 1달간 어머니와 유럽 여행이 계획되어 있다고 말했고, 제 자신도 부족했기 때문에 불합격했습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;유럽에 다녀오고, 천천히 지식을 재점검하며 2016년이 지나갔습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2017년&quot;&gt;2017년&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;파이썬, 개발, 머신러닝에 대해 얼추 이해한 상태에서 다시 고민에 빠졌습니다
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;공부하면 할수록, 대학원에 가야할 것 같은데..? 공부할 것이 너무 많다&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;고민 후 결론은 &lt;strong&gt;우선 취업해서 현실의 업무를 하나씩 진행해본 후, 다시 결정하자&lt;/strong&gt;였습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;카메라에 관심이 많았는데, 카메라 어플을 만드는 “레트리카”에서 데이터 분석가를 채용하는 공고를 봤습니다
    &lt;ul&gt;
      &lt;li&gt;무언가의 끌림에 바로 지원했고, 면접을 봤습니다&lt;/li&gt;
      &lt;li&gt;면접을 보며 면접관 분이 매우 똑똑하고, 말을 잘하는 것이 인상깊었습니다&lt;/li&gt;
      &lt;li&gt;논리적인 대화로 제가 KO 완패를 받아, 오기가 생겼습니다&lt;/li&gt;
      &lt;li&gt;운이 좋게도 합격했습니다. 나중에 왜 저를 합격했는지 물어보니 다양한 지원자 중 &lt;strong&gt;데이터에 대해 이야기할 때 눈이 반짝거렸다&lt;/strong&gt;고 들었습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;레트리카
    &lt;ul&gt;
      &lt;li&gt;레트리카는 카메라 어플로 입사 당시 DAU(Daily Active User)가 약 1,000만명이었습니다&lt;/li&gt;
      &lt;li&gt;터키, 인도, 브라질 등 다양한 국가에서 사용하는 어플!&lt;/li&gt;
      &lt;li&gt;입사하니 데이터팀은 면접관이셨던 COO님, 그리고 저보다 2달 먼저 입사한 신입분, 저 이렇게 3명이었습니다&lt;/li&gt;
      &lt;li&gt;입사하고 데이터 분석이란 어떤 일인지 몸소 체험하며 다양한 시행착오를 겪었습니다&lt;/li&gt;
      &lt;li&gt;특히 기억나는 4가지를 말씀드리면,&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;1) 시니어의 부재
    &lt;ul&gt;
      &lt;li&gt;COO분은 매우 논리적이고 날카로운 분이셨지만, 데이터 분석에 풍부한 경험이 있는 분은 아니었습니다&lt;/li&gt;
      &lt;li&gt;(여전히 매우 좋아하는 분입니다)&lt;/li&gt;
      &lt;li&gt;입사 3달까진 시니어를 뽑아주길 바랬고, 시니어 면접에 참여했습니다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;어느 순간 시니어를 바라지 않고, 제가 업무를 찾아보며 시작했습니다. 책이나 인터넷 강의를 많이 들었고, 인터넷에서 경험이 많은 분들에게 페북 메세지를 보내며 궁금한 내용들을 채웠습니다&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;아마 시니어가 없던 이 상황에 제가 살아남기 위해 고민을 했던 점들이 지금 제게 큰 자양분이 된 것 같습니다&lt;/li&gt;
      &lt;li&gt;1년간 거의 12시~새벽 1시에 집에 갔습니다
        &lt;ul&gt;
          &lt;li&gt;제가 부족하다 생각했기 때문에 남아서 더 자료를 찾아보고 공부하고 일을 했습니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2) 데이터 엔지니어링 경험
    &lt;ul&gt;
      &lt;li&gt;팀 내에서 유일한 파이썬 경험자였는데(솔직히 이 당시에 잘하진 못했음) 서버 개발자분이 저를 보시더니 데이터 ETL 과정을 인수인계해주셨습니다 ^_^&lt;/li&gt;
      &lt;li&gt;완전 급하게 배워서 체하는 느낌도 살짝 있었지만, 새로운 내용을 하는 것이 너무 재밌어서 이것도 퇴근 하고 계속 공부했습니다&lt;/li&gt;
      &lt;li&gt;덕분에 Google Cloud BigQuery에 대해선 정말 많이 이해했고, ETL이 꼭 하둡/스파크를 사용하지 않아도 되는 점 등을 알게 되었습니다&lt;/li&gt;
      &lt;li&gt;서버 개발자분도 사내에 혼자셔서 바쁘셨기 때문에 제게 이런 내용을 다 넘겨주신건데, 정말 감사하게 생각하고 있습니다(여전히 자주 보고 있습니다)&lt;/li&gt;
      &lt;li&gt;2017년 말엔 아예 서버 개발자로 직군을 바꿔, 유일하게 계신 서버개발자분에게 아주 약간의 지도를 받았습니다&lt;/li&gt;
      &lt;li&gt;지도라고 해봤자 Error 디버깅하는 것을 바라본 정도인데, 그 과정을 보고 어떻게 트러블 슈팅할지 감을 익혔습니다&lt;/li&gt;
      &lt;li&gt;그리고 쉘스크립트, 파이썬으로 맵리듀스 짜는 것도 해보고, 다양한 경험을 했습니다&lt;/li&gt;
      &lt;li&gt;사내 대시보드, 다양한 데이터를 볼 수 있는 대시보드, Airflow 등을 찾아보고 사내에 도입했습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3) 오퍼레이션 업무 지원
    &lt;ul&gt;
      &lt;li&gt;사실 데이터 분석, 머신러닝/딥러닝을 공부하다보면 무언가 별도의 조직처럼 움직일 것 같지만, 회사에서 필요로 하는 것들 중 전혀 몰랐던 것도 있습니다&lt;/li&gt;
      &lt;li&gt;기술을 통해 오퍼레이션에서 진행하는 다양한 노동 활동을 자동화하는 것도 회사에 큰 도움이 되는 것을 깨달았습니다&lt;/li&gt;
      &lt;li&gt;야한 사진을 Block하는 것들을 만들며 새로운 지식을 또 습득했습니다
        &lt;ul&gt;
          &lt;li&gt;컴퓨터 비전 지식, Docker 지식&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2)와 3)에 대한 내용이 더 궁금하시면 제 발표자료 : &lt;a href=&quot;https://www.slideshare.net/zzsza/little-big-data-1&quot;&gt;바닥부터 시작하는 데이터 인프라&lt;/a&gt;를 참고하면 좋을 것 같습니다&lt;/li&gt;
  &lt;li&gt;4) 개인 업무 성향 파악
    &lt;ul&gt;
      &lt;li&gt;입사 후, 30일/60일/90일 피드백을 통해 제가 어떤 스타일로 업무를 하는지 알 수 있었습니다&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/di9g6ymhk7ijnr4/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-05%2022.37.40.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;어떤 일을 하기 전에, 다양한 고민이 많았고 뜬구름도 많이 잡았습니다. 이런 피드백을 핵직구로 받은 후 계속 개선하다보니 이젠 린한 사고 과정이 체득되었습니다&lt;/li&gt;
      &lt;li&gt;꾸준히 메모하던 습관에서, 일정 관리도 더 자세히 하게 되었습니다
        &lt;ul&gt;
          &lt;li&gt;캘린더에 시간 단위로 일정을 등록하고 있습니다&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/pti3kmcf2jgmc11/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-06%2009.12.04.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;파란색은 회사 일정, 연보라색은 개인 일정입니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zzsza.github.io/diary/2017/12/30/2017-retrospect/&quot;&gt;2017년 회고, 2018년 계획&lt;/a&gt; 블로그 글에 자세히 작성했습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2018년&quot;&gt;2018년&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;4월까지 회사를 다니다 퇴사했습니다&lt;/li&gt;
  &lt;li&gt;퇴사한 이유는 아래와 같습니다
    &lt;ul&gt;
      &lt;li&gt;1) 자신에 대해 생각할 시간이 필요해서&lt;/li&gt;
      &lt;li&gt;2) 개인 공부할 시간을 확보하기 위해서&lt;/li&gt;
      &lt;li&gt;3) 취업은 언젠가 다시 할 수 있단 긍정적 마인드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자신이 나아갈 방향을 설정하는 시간인 Gap Year를 계획적으로 보내기로 다짐했습니다&lt;/li&gt;
  &lt;li&gt;특히 앞으로 어떻게 커리어를 쌓을 것인가?에 대해 계속 고민했습니다
    &lt;ul&gt;
      &lt;li&gt;공부한 기록과 이직 과정은 &lt;a href=&quot;https://zzsza.github.io/diary/2018/10/26/gap-year-and-socar/&quot;&gt;Gap Year 및 쏘카 이직 이야기&lt;/a&gt;에 있으니 저 글을 참고하면 좋을 것 같습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 시기에 제 진로를 다시 고민한 결과, 저는 “연구”보단 현실의 문제를 푸는 “Solver”가 되고 싶어하는 성향을 발견했습니다
    &lt;ul&gt;
      &lt;li&gt;문제를 해결하는 동시에 엔지니어이고 싶었기 때문에, 문제 해결에 대한 공부와 엔지니어 성향 모두를 계속 공부하고 있습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;대학생 분들에게 고민을 나누기 위해 취업 특강을 많이 했습니다
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/zzsza/data-science-intro&quot;&gt;Data Science. Intro&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TMI) &lt;a href=&quot;https://www.slideshare.net/zzsza/ss-137831892&quot;&gt;글쓰는 개발자 모임, 글또&lt;/a&gt;를 시작해서 다른 분들이 글쓰는 것을 돕고 있습니다&lt;/li&gt;
  &lt;li&gt;데이터 진로와 관련된 책을 집필하려고 하고 있습니다. 빨리 오프라인에서 만나볼 수 있으면 좋겠네요&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zzsza.github.io/diary/2018/12/22/2018-retrospect/&quot;&gt;2018년 회고, 2019년 다짐&lt;/a&gt; 블로그 글에 자세히 나와있어요!&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;쏘카&quot;&gt;쏘카&lt;/h2&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;쏘카 입사한지 6개월이 지났습니다(글 쓰는 시간 기준)
    &lt;ul&gt;
      &lt;li&gt;2018년 9월 ~ 현재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;많은 일이 있었는데, 느낀 점 몇개 말씀드리면&lt;/li&gt;
  &lt;li&gt;1) 큰 규모의 데이터팀
    &lt;ul&gt;
      &lt;li&gt;저희 쏘카 데이터 그룹은 현재 약 20명입니다&lt;/li&gt;
      &lt;li&gt;리서치 회사를 제외한 데이터 관련 팀 중 제일 큰 규모라고 생각합니다&lt;/li&gt;
      &lt;li&gt;각자 도메인이 다르고, 다양한 경험이 있어 대화하는 것만으로도 충분히 성장하게 됩니다&lt;/li&gt;
      &lt;li&gt;문무를 겸비한 것처럼 데이터 분석/머신러닝/딥러닝/데이터엔지니어링 모두 경험있는 분들도 꽤 있습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2) 재미있는 데이터와 문제
    &lt;ul&gt;
      &lt;li&gt;모빌리티 데이터는 정말 재미있습니다&lt;/li&gt;
      &lt;li&gt;차량에서 나올 수 있는 데이터가 무엇인지? 생각해보면 좋을 것 같습니다&lt;/li&gt;
      &lt;li&gt;그리고 최근 나온 타다도 급성장하며 생기는 데이터와 문제들! 블로그에 말씀 드리긴 어렵지만, 현실의 문제를 빠르게 해결하고 있습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;저는 어떻게 지낼까요?
    &lt;ul&gt;
      &lt;li&gt;요샌 “최적화”에 대해 관심이 많습니다. Operation Research부터 시작해 휴리스틱, 메타휴리스틱, 유전 알고리즘 등 기존에 전혀 알지 못했던 내용들을 공부하고 익히고 있습니다&lt;/li&gt;
      &lt;li&gt;지리 데이터, 좌표 데이터를 많이 가공하며 새로운 도메인에 대해 적응하고 있습니다&lt;/li&gt;
      &lt;li&gt;여전히 공부 많이하고, 책도 보고 강의도 보고 그러고 있습니다&lt;/li&gt;
      &lt;li&gt;머신러닝 부분은 “시계열 예측”과 “MLOps”에 대해 계속 공부하고 있습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;좋은 문화, 좋은 팀을 만들기 위해
    &lt;ul&gt;
      &lt;li&gt;저는 제가 속한 회사가 제일 좋은 회사가 되길 원하고 있습니다. 오지랖 부리며 이것저것 하고 있는데 몇개 말씀드리면&lt;/li&gt;
      &lt;li&gt;1) 스터디 진행
        &lt;ul&gt;
          &lt;li&gt;최근에 나온 “파이선 머신러닝 완벽 가이드”를 스터디하고 있습니다&lt;/li&gt;
          &lt;li&gt;책이 너무 좋고, 팀 동료분들이 알면 좋을 내용이 많다 판단해서 제가 스터디 매니저를 자처해 스터디를 진행하고 있습니다&lt;/li&gt;
          &lt;li&gt;누가 발표하는 것이 아닌, 정해진 시간에 책을 같이 읽고 토론하고 있습니다&lt;/li&gt;
          &lt;li&gt;스터디 내용은 &lt;a href=&quot;https://github.com/zzsza/Perfect-Guide-about-Machine-Learning-Study&quot;&gt;Github&lt;/a&gt;에 올리고 있습니다&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/s0hf0qit9vabta6/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-05%2022.55.56.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;이 스터디 말고도, 스터디잼 중급반도 시작했습니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) 스터디 지원
        &lt;ul&gt;
          &lt;li&gt;쏘카에서 SQL을 사용하는 분들이 질문하시면 정성껏 답변 하고 있습니다(스터디의 QnA 봇 같은 존재..?)&lt;/li&gt;
          &lt;li&gt;기획자분들이 직접 SQL을 하는 것을 정말! 감동적인 일이라 생각해서 열심히 답변드리고 있습니다&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/2tjk0kmxobgalh6/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-05%2022.57.56.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;저 말고도 다른 데이터그룹 분들도 함께 답변을 하고 있습니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;3) Kaggle에서 홍보
        &lt;ul&gt;
          &lt;li&gt;좋은 분들을 모시기 위해 다양한 곳에서 회사 홍보를 해야한다고 생각합니다&lt;/li&gt;
          &lt;li&gt;저는 데이터에 관심있는 분들은 캐글을 많이 할 것이란 가정하에 캐글에서 [SOCAR]라는 타이틀을 달고 대회에 참가하고 있습니다&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/fh3tg35iz0f4dkn/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-02-15%2014.49.54.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;앞으로도 좋은 팀, 좋은 문화를 가질 수 있도록 계속 노력할 예정입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;미래&quot;&gt;미래&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;요새 관심사인 Operation Research, 시계열 예측, MLOps 등 다양한 내용들을 공부, 정리, 현업에서 바로 활용을 하려고 합니다&lt;/li&gt;
  &lt;li&gt;친한 분들과 유튜브 채널을 만들었습니다 : &lt;a href=&quot;https://www.youtube.com/channel/UCdLZ0MsYS4hmqFgOYCB6C9w&quot;&gt;DeepNOL!&lt;/a&gt; 데이터와 관련된 다양한 이야기를 전해드리려고 합니다
    &lt;ul&gt;
      &lt;li&gt;이와 별개로 제 개인 유튜브에 책 리뷰를 남기려고 합니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구성원들과 함께 자라기를 실천하기 위해 어떤 행동을 할까 고민하고 있습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;정리&quot;&gt;정리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;정리하면 저는 2013년부터 데이터 분석에 관심을 가지다 방황하고, 2015년부터 다시 공부하고, 2016년부턴 아예 데이터 분야에 몰입했습니다. 2018년엔 퇴사 후 제 부족한 부분을 채웠고, 현재 쏘카에서 근무하고 있습니다&lt;/li&gt;
  &lt;li&gt;이 글을 보시는 분들도 포기하지 않고, 목표를 가진 상태로 꾸준히 공부하면 좋은 결과가 있을거라 믿습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;faq&quot;&gt;FAQ&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;제 일대기를 작성했지만, 명쾌하게 답변하지 않은 부분을 정리하려 합니다&lt;/li&gt;
  &lt;li&gt;1) 대학원에 꼭 가야할까요?
    &lt;ul&gt;
      &lt;li&gt;이 고민을 하기 전에, 본인이 &lt;strong&gt;연구&lt;/strong&gt;를 하고 싶어하는지, &lt;strong&gt;현실의 문제를 풀고싶은지&lt;/strong&gt; 등을 고민하면 좋을 것 같습니다&lt;/li&gt;
      &lt;li&gt;연구를 하고 싶다면 대학원에 가는 것도 좋은 선택일 수 있고, 반면 현실의 문제를 풀고 싶다면 회사에 가는 것도 좋은 선택일 수 있습니다&lt;/li&gt;
      &lt;li&gt;본인의 목적과 미래를 생각해보면 조금 더 확실한 결정을 내릴 수 있을 것 같습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2) 비전공자인 제가 할 수 있을까요?
    &lt;ul&gt;
      &lt;li&gt;각자의 전공은 충분히 의의가 있다고 생각합니다. 저는 경영학에서 배운 커뮤니케이션 능력이 업무에 큰 도움이 되고 있습니다&lt;/li&gt;
      &lt;li&gt;비전공자일 경우 코딩이나 수학에서 어려움이 있을 수는 있지만, 꾸준히 공부하다보면 어느정도 해결될 것이라 생각합니다&lt;/li&gt;
      &lt;li&gt;전공이냐 비전공이냐기 보다 “나는 할 수 있고, 나의 페이스대로 잘 가고 있다”라는 생각을 하시며 꾸준히 하시면 좋을 것 같습니다&lt;/li&gt;
      &lt;li&gt;단, 정말 많은 노력이 수반되니 꾸준히 공부해주세요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3) 공부하시며 어려운 점이 있었나요?
    &lt;ul&gt;
      &lt;li&gt;공부할 내용이 너무 많아 어렵지만, 이런 생각을 반대로 &lt;strong&gt;새로운 내용을 배우는 것은 너무 재미있고, 하나씩 정복하는 재미가 있다&lt;/strong&gt;고 생각했습니다&lt;/li&gt;
      &lt;li&gt;어렵다고 말하면 안할 생각인지 여쭤보고 싶습니다. 정말 하고 싶다면, 어려운 점도 극복할만하다 생각합니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4) 무엇을 공부해야 할까요?
    &lt;ul&gt;
      &lt;li&gt;답이 없는 질문인 것 같습니다. 사람마다 배경이 다르기 때문에 어떤 것을 공부해야 한다!고 말하긴 어려울 것 같습니다&lt;/li&gt;
      &lt;li&gt;단, 채용공고를 정리한 내용을 토대로 어떤 능력이 필요한지는 파악할 수 있을 것 같습니다.&lt;/li&gt;
      &lt;li&gt;그 전에 어떤 직군을 하고 싶은지 고민해보시는 것을 추천합니다.제가 작성한 &lt;a href=&quot;https://github.com/Team-Neighborhood/I-want-to-study-Data-Science/wiki&quot;&gt;I-want-to-study-Data-Science&lt;/a&gt;를 참고하면 좋을 것 같습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;5) 학원을 다녀야 할까요? 국비지원을 가야할까요?
    &lt;ul&gt;
      &lt;li&gt;요샌 의지만 있다면 인터넷에 다양한 자료가 있기 때문에, 학원을 굳이 안가도 됩니다. 스터디를 꾸려도 되고, 모두의 연구소 같은 곳에서 공부해도 되고 다양한 방법이 있습니다. 어떤 곳이 있는지 찾아보시고 결정하시면 좋을 것 같습니다&lt;/li&gt;
      &lt;li&gt;단, 국비지원 중 너무 많은 범위를 다루는 수업(예를 들어 자바, 하둡, 스파크, 텐서플로, 딥러닝 등을 3~6개월에 다루는 수업)이 얼마나 좋을지는 모르겠습니다(제가 경험을 안했기 때문에 판단하기 어렵지만, 과한 느낌이 있습니다)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;6) 자격증을 따려고 하는데 도움이 될까요?
    &lt;ul&gt;
      &lt;li&gt;보통 자격증하면 ADP, ADsP, SQLD, SQLP, 사회조사 분석사, 정보처리기사 등이 있습니다. 공부의 목적으론 괜찮을 수 있지만 취업 목적으론 효용이 있는지 모르겠습닌다
        &lt;ul&gt;
          &lt;li&gt;저는 사회조사 분석사 2급, 정보처리기사가 있지만 취업할 때 도움을 받은 기억은 없습니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;이 업계는 실력이 중요하기 때문에 실제 데이터 분석을 하거나, 프로젝트 진행, 캐글 등을 참여해보는 것이 좋을 것 같습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위 질문에 대해 답변을 남긴 &lt;a href=&quot;https://github.com/Team-Neighborhood/I-want-to-study-Data-Science/wiki/FAQ&quot;&gt;FAQ&lt;/a&gt;를 참고하셔도 좋을 것 같습니다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;이력서 작성이 어려운 분들을 위해 제 이력서를 보여드립니다. 참고만 하시면 좋을 것 같습니다
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/zgrgqgu90zrs5gf/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-06%2000.33.11.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;저는 구인본님의 &lt;a href=&quot;http://woowabros.github.io/experience/2017/07/17/resume.html&quot;&gt;이직초보 어느 개발자의 이력서 만들기&lt;/a&gt;를 보고 이력서를 만들었습니다&lt;/li&gt;
      &lt;li&gt;제가 만든 이력서 템플릿도 공유드립니다(pages 파일) : &lt;a href=&quot;https://www.dropbox.com/s/tqr8szz6odfxtcy/%EC%9D%B4%EB%A0%A5%EC%84%9C-%ED%85%9C%ED%94%8C%EB%A6%BF.pages&quot;&gt;Dropbox Link&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/diary/2019/04/05/how-to-study-datascience/</link>
        <guid isPermaLink="true">https://zzsza.github.io/diary/2019/04/05/how-to-study-datascience/</guid>
        
        <category>diary</category>
        
        
        <category>diary</category>
        
      </item>
    
      <item>
        <title>Uber Kepler.gl : 지리 데이터 시각화 도구</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Uber의 데이터 시각화 도구인 Kepler.gl에 대한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;keplergl&quot;&gt;Kepler.gl&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;우버에서는 쏟아지는 GPS 데이터를 분석하기 위해 데이터 시각화팀을 만듬&lt;/li&gt;
  &lt;li&gt;이 시각화 팀은 &lt;a href=&quot;vis.gl&quot;&gt;vis.gl&lt;/a&gt;라는 홈페이지를 운영하고 있는데, 다양한 프레임워크를 제공하고 있음
    &lt;ul&gt;
      &lt;li&gt;Kepler.gl, &lt;a href=&quot;https://movement.uber.com/&quot;&gt;Movement&lt;/a&gt;, &lt;a href=&quot;http://avs.auto/&quot;&gt;AVS&lt;/a&gt; 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;csv, json, geojson 데이터 포맷을 사용할 수 있고, GPU 지원 덕분에 대용량 데이터도 쉽게 렌더링됨
    &lt;ul&gt;
      &lt;li&gt;단, 대용량(250MB 이상) 데이터를 업로드하려면 사파리를 사용하는 것을 권장하고 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기능&quot;&gt;기능&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;지원하는 기능은 Arc, Line, Hexagon, Point, Heatmap, GeoJSON, Buildings 등이 있음&lt;/li&gt;
  &lt;li&gt;Arc
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/36gak1ise6tmxxw/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2014.20.04.png?raw=1&quot; width=&quot;400&quot; height=&quot;350&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Line
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/0rkymltbu4h9cxx/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2014.20.21.png?raw=1&quot; width=&quot;400&quot; height=&quot;350&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Hexagon
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/bcs55gpd5e71lok/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2014.21.33.png?raw=1&quot; width=&quot;400&quot; height=&quot;350&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Point
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/0cdqwtr565hw6re/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2014.21.48.png?raw=1&quot; width=&quot;400&quot; height=&quot;350&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Heatmap
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/303atrade22s7nu/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2014.22.03.png?raw=1&quot; width=&quot;400&quot; height=&quot;350&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;GeoJSON
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/3t2902bx7yc209l/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2014.22.17.png?raw=1&quot; width=&quot;400&quot; height=&quot;300&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Buildings
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/dzw21i1l72729cz/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2014.22.32.png?raw=1&quot; width=&quot;400&quot; height=&quot;350&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;사용-방법&quot;&gt;사용 방법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;홈페이지 메인에서 GET STARTED 클릭
    &lt;ul&gt;
      &lt;li&gt;혹은 URL : &lt;a href=&quot;https://kepler.gl/demo&quot;&gt;https://kepler.gl/demo&lt;/a&gt;로 접속&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;데이터-추가&quot;&gt;데이터 추가&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/ns282b255ylf972/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2015.42.12.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터를 추가하는 부분&lt;/li&gt;
  &lt;li&gt;만약 자신의 데이터가 있다면, (적절히 가공한 후) 업로드하면 됨&lt;/li&gt;
  &lt;li&gt;데이터가 없다면 우선 Sample Data를 클릭&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/r1ffr880r122pew/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2015.43.19.png?raw=1&quot; width=&quot;400&quot; height=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;택시 데이터가 마음에 들기 때문에, NYC taxi trips 클릭&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;기본-ui&quot;&gt;기본 UI&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/9dq5r95qwr9sy8d/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2015.47.57.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;총 6가지 Component로 나눠봤는데(=제 마음대로), 하나씩 설명하면&lt;/li&gt;
  &lt;li&gt;1) Layers, Filters, Interactions, Base map 선택 창
    &lt;ul&gt;
      &lt;li&gt;Layers는 일단 Pass&lt;/li&gt;
      &lt;li&gt;Filters
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/bfw9ipcvu3lav6y/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2015.56.50.png?raw=1&quot; width=&quot;400&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;여기서 Filter를 설정할 수 있음&lt;/li&gt;
          &lt;li&gt;시간 관련 Filter를 걸면 4)가 생김&lt;/li&gt;
          &lt;li&gt;int나 float 컬럼을 선택하면 값을 조절할 수 있는 bar가 생김&lt;/li&gt;
          &lt;li&gt;string 컬럼은 Search box가 생김&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Interactions
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/p1mxwdvct21pz8l/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2016.01.51.png?raw=1&quot; width=&quot;400&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;Tooltip은 마우스온할 때 어떤 값들이 추가적으로 나오는지 설정하는 부분으로 쉽게 추가하거나 뺄 수 있음&lt;/li&gt;
          &lt;li&gt;Brush는 커서로 영역을 강조 표시 할 수 있음. 브러쉬가 켜지면 모든 레이어가 어두워짐
            &lt;ul&gt;
              &lt;li&gt;마우스로 커서를 올려 놓은 부분만 밝아지고 특히 아크 레이어와 잘 작동&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Tooltip or Brush 중 하나만 선택 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Base map
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/dozvzg3jz60l9ht/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2016.06.00.png?raw=1&quot; width=&quot;400&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;Map Style을 선택할 수 있고, May Layers도 설정 가능&lt;/li&gt;
          &lt;li&gt;Label, Road, Building, Water 등을 ON/OFF 할 수 있고 레이어 순서를 결정할 수 있음&lt;/li&gt;
          &lt;li&gt;Map Style을 커스텀하고 싶으면 mapbox에서 자신만의 map style을 publish한 후, access token을 입력하면 사용 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2) Layers
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/few0q422z4wcrck/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2016.08.36.png?raw=1&quot; width=&quot;400&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;이 부분엔 데이터의 타입(Point, Arc, Line, Grid, Cluster, Icon, Heatmap, H3, Polygon 등등)을 설정 가능&lt;/li&gt;
      &lt;li&gt;설정값에 따라 옵션이 세부적으로 조절 가능&lt;/li&gt;
      &lt;li&gt;레이어를 ON/OFF 가능하고 Label이 없는 경우엔 Point로 표현 가능하고, Label도 붙일 수 있음
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ucuzk0ga5000kva/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2016.11.21.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;이 부분은 백번 보는 것보다 직접 실행하는 것이 좋음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3) Layer Blending
    &lt;ul&gt;
      &lt;li&gt;레이어를 어떻게 섞을지, additive, normal, subtractive가 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4) Time Playback
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/rf53v4jom97nof4/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2016.13.49.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;시간 Filter가 걸릴 경우 활성화&lt;/li&gt;
      &lt;li&gt;Bound를 조절한 후, 재생 버튼을 누르면 시간순으로 데이터를 볼 수 있음&lt;/li&gt;
      &lt;li&gt;또한 재생 속도도 조절 가능&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9di8t3vjxoa3i7e/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2016.20.49.gif?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;5) Map View mode
    &lt;ul&gt;
      &lt;li&gt;dual map view, 3D Map, show legend 가능&lt;/li&gt;
      &lt;li&gt;Dual Map view를 한 후, visible layers를 다르게 설정할 수 있음&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/m4oguf9kap8n8wn/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-04-22%2020.42.59.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;6) Share
    &lt;ul&gt;
      &lt;li&gt;Share 옵션으로 Export Image, Export Data, Export Config, Export Map, Share Public URL(Dropbox)를 사용할 수 있음&lt;/li&gt;
      &lt;li&gt;config를 export해서 재사용 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2019-로드맵&quot;&gt;2019 로드맵&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;기능에 대한 로드맵은 아래 Github 참고
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/uber/kepler.gl/wiki/Kepler.gl-2019-Roadmap&quot;&gt;Kepler.gl 2019 Roadmap&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;faq&quot;&gt;FAQ&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Video File로 export할 수 있는지?
    &lt;ul&gt;
      &lt;li&gt;kepler에선 불가능, Quicktime Player나 Giffy 등을 사용하면 됨&lt;/li&gt;
      &lt;li&gt;참고 링크 : &lt;a href=&quot;https://it-talktalk.tistory.com/164&quot;&gt;Giphy Capture&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;지도에 추가할 수 있는 데이터 세트의 수에 제한이 있는지?
    &lt;ul&gt;
      &lt;li&gt;제한은 없지만 많을수록 성능이 저하될 가능성이 큼&lt;/li&gt;
      &lt;li&gt;레이어도 동일&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최대 파일 업로드 크기는 얼마인지?
    &lt;ul&gt;
      &lt;li&gt;250mb 이하 파일을 허용함. 사파리에선 더 큰 파일을 로드할 수는 있지만 성능은 제한됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tutorial&quot;&gt;Tutorial&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/vis-gl&quot;&gt;Vis.gl 블로그&lt;/a&gt;에 글이 많음&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/vis-gl/animating-40-years-of-california-earthquakes-e4ffcdd4a289&quot;&gt;Animating 40 years of California Earthquakes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/vis-gl/mapping-the-parisian-trees-6dc30f6aabc7&quot;&gt;Mapping the Parisian trees&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/vis-gl/visualizing-u-s-county-unemployment-with-kepler-gl-c5f2ed31c71&quot;&gt;Visualizing Unemployment for U.S. Counties with kepler.gl&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/vis-gl/movement-in-kepler-d00e843f464d&quot;&gt;Using Kepler.gl and Movement to Visualize Traffic Effects of a Rainstorm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;자체-서버에-빌드하기&quot;&gt;자체 서버에 빌드하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;별도로 빌드해서 사용해야 하는 분들을 위해 작성한 부분&lt;/li&gt;
  &lt;li&gt;Git, Node.js, Yarn이 설치되어 있어야 함&lt;/li&gt;
  &lt;li&gt;MapboxAccessToken 있어야 함
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://account.mapbox.com/&quot;&gt;홈페이지&lt;/a&gt; 가입 후 발급&lt;/li&gt;
      &lt;li&gt;역시 이런 것은 유료.. 월 499달러라..&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/uber/kepler.gl.git
cd kepler.gl
yarn --ignore-engines
export MapboxAccessToken=&amp;lt;insert_your_token&amp;gt;
npm start
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;완료된 후, &lt;code class=&quot;highlighter-rouge&quot;&gt;localhost:8080&lt;/code&gt;에 가면 아래 같은 화면이 뿅!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/4i3uv5r19avptal/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2016.40.48.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/uber/kepler.gl&quot;&gt;kepler.gl Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kepler.gl/&quot;&gt;공식 홈페이지&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/uber/kepler.gl/tree/master/docs/user-guides&quot;&gt;Kepler User Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/uber/kepler.gl/blob/master/contributing/DEVELOPERS.md&quot;&gt;Developing Kepler.gl&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/vis-gl&quot;&gt;Vis.gl Medium&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/data/2019/04/01/uber-keplergl/</link>
        <guid isPermaLink="true">https://zzsza.github.io/data/2019/04/01/uber-keplergl/</guid>
        
        <category>geographic</category>
        
        
        <category>data</category>
        
      </item>
    
      <item>
        <title>Simulated Annealing 개념과 Python 구현</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Simulated Annealing에 대한 설명과 파이썬 구현 코드를 작성한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;simulated-annealing&quot;&gt;Simulated Annealing&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Kirkpatrick이 1983년에 만듬&lt;/li&gt;
  &lt;li&gt;뜨거운 욕조에서 재료의 냉각을 시뮬레이션하는 알고리즘에 기반&lt;/li&gt;
  &lt;li&gt;더 전통적인 방법의 변형
    &lt;ul&gt;
      &lt;li&gt;Local(neighborhood) search&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;확률론적 메타휴리스틱 방법&lt;/li&gt;
  &lt;li&gt;Annealing
    &lt;ul&gt;
      &lt;li&gt;내부 강도를 제거하기 위해 금속이나 유리를 가열하고 천천히 냉각시키는 방법&lt;/li&gt;
      &lt;li&gt;금속재료를 가열한 다음 조금씩 냉각해 결정을 성장시켜 그 결함을 줄이는 작업&lt;/li&gt;
      &lt;li&gt;열에 의해서 원자는 초기의 위치(내부 에너지가 극소점에 머무르는 상태)로부터 멀어져 에너지가 더욱 높은 상태로 추이됨&lt;/li&gt;
      &lt;li&gt;천천히 냉각함으로써 원자는 초기 상태보다 내부 에너지가 한층 더 극소인 상태를 얻을 가능성이 많아짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Cooling하는 방법
    &lt;ul&gt;
      &lt;li&gt;Temperature를 낮추는 방법&lt;/li&gt;
      &lt;li&gt;Cooling rate&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Local minima/optima를 벗어나는 컨트롤된 방식으로 오르막 이동(더 나쁜 솔루션)을 허용함
    &lt;ul&gt;
      &lt;li&gt;확률로 더 나쁜 움직임을 받아들임&lt;/li&gt;
      &lt;li&gt;random number를 체크한 후, random이 적으면 나쁘게 움직이고 높으면 움직이지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/4w56bige61wyoed/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-26%2023.53.53.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/tldpmm7ds7gqneh/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-27%2000.01.01.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;해를 반복해 개선하며 현재의 해 근방에 있는 해를 임의로 찾는데, 그 때 주어진 함수의 값과 전역 인자 T가 영향을 줌
    &lt;ul&gt;
      &lt;li&gt;위에서 말한 물리 과정과 비슷한 원리로 T(온도)의 값은 서서히 작아짐&lt;/li&gt;
      &lt;li&gt;처음엔 T가 크기 때문에 해가 크게 변화하지만, T가 0에 가까워짐에 따라 변화가 줄어듬&lt;/li&gt;
      &lt;li&gt;처음은 간단하게 비탈을 올라갈 수 있으므로, 지역 최적점에 빠졌을 때 대책을 생각할 필요가 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;아이디어 자체는 모든 분야에 대하여 적용이 가능
    &lt;ul&gt;
      &lt;li&gt;임의의 경우의 수가 많은 경우 정해진 조건에서 대용량의 최적화를 찾을 때 유용하게 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;notations&quot;&gt;Notations&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/mdbt91lfzeafx4q/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-28%2020.39.11.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;빨간색이 Final Solution&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/wxuijdt6m3ig532/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-28%2020.40.42.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;방법&quot;&gt;방법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;MathJax_Preview&quot;&gt;T_{0}&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;T_{0}&lt;/script&gt;, M, N, alpha, move operator의 종류를 설정&lt;/li&gt;
  &lt;li&gt;
    &lt;pre class=&quot;MathJax_Preview&quot;&gt;&lt;code&gt;m = 1&lt;/code&gt;&lt;/pre&gt;
    &lt;script type=&quot;math/tex; mode=display&quot;&gt;m = 1&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;Search space &lt;code class=&quot;MathJax_Preview&quot;&gt;x_{i}&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;x_{i}&lt;/script&gt;에서 random point로 시작&lt;/li&gt;
  &lt;li&gt;move operator &lt;code class=&quot;MathJax_Preview&quot;&gt;x_{t}&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;x_{t}&lt;/script&gt;를 사용해 다른 장소로 이동&lt;/li&gt;
  &lt;li&gt;근처를 둘러보고 그 중 하나로 이동&lt;/li&gt;
  &lt;li&gt;더 나아졌는지 확인 후, 나아졌으면 끝. 아니면 계속
    &lt;ul&gt;
      &lt;li&gt;나아지지 않았다면 random number를 취함&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;MathJax_Preview&quot;&gt;1/(e^{(f(x_{tmp})-f(x_{i})/T_{t})}&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;1/(e^{(f(x_{tmp})-f(x_{i})/T_{t})}&lt;/script&gt;랑 비교&lt;/li&gt;
      &lt;li&gt;작다면 취하고, 작지 않다면 다른 곳을 찾고 n = n + 1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;N번 진행&lt;/li&gt;
  &lt;li&gt;m = m + 1&lt;/li&gt;
  &lt;li&gt;
    &lt;pre class=&quot;MathJax_Preview&quot;&gt;&lt;code&gt;T_{t+1} = \alpha * T_{t}&lt;/code&gt;&lt;/pre&gt;
    &lt;script type=&quot;math/tex; mode=display&quot;&gt;T_{t+1} = \alpha * T_{t}&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;1time에 5~9 스텝을 반복&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;MathJax_Preview&quot;&gt;x_{Final}&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;x_{Final}&lt;/script&gt;을 찾고 좋은 Solution으로 기록&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;flowchart&quot;&gt;Flowchart&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/repgqi2ne3n2nxu/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-28%2021.04.37.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;himmelblau-구현&quot;&gt;Himmelblau 구현&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Himmelblau%27s_function&quot;&gt;Himmelblau function&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;pre class=&quot;MathJax_Preview&quot;&gt;&lt;code&gt;z = (x^{2} + y - 11)^{2} + (x+y^{2}-7)^{2}&lt;/code&gt;&lt;/pre&gt;
    &lt;script type=&quot;math/tex; mode=display&quot;&gt;z = (x^{2} + y - 11)^{2} + (x+y^{2}-7)^{2}&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;x와 y는 -6 ~ 6&lt;/li&gt;
  &lt;li&gt;minimized z = 0.0000&lt;/li&gt;
  &lt;li&gt;1개의 극대값과 4개의 극소값을 가짐&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;himmelblau-코드&quot;&gt;Himmelblau 코드&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import numpy as np
import matplotlib.pyplot as plt


x0 = 1 # Initial solution
y0 = -1

k = 0.1
T0 = 1000
M = 300
N = 15
alpha = 0.85


z_int = ((x0**2)+y0-11)**2+(x0+(y0**2)-7)**2

print(f&quot;Initial X is {x0:.3f}&quot;)
print(f&quot;Initial Y is {y0:.3f}&quot;)
print(f&quot;Initial Z is {z_int:.3f}&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;처음엔 Z가 146으로 Optimal과 거리가 멈&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import numpy as np
import matplotlib.pyplot as plt


x0 = 1 # Initial solution
y0 = -1

k = 0.1
T0 = 1000
M = 300
N = 15
alpha = 0.85


z_int = ((x0**2)+y0-11)**2+(x0+(y0**2)-7)**2

print(f&quot;Initial X is {x0:.3f}&quot;)
print(f&quot;Initial Y is {y0:.3f}&quot;)
print(f&quot;Initial Z is {z_int:.3f}&quot;)

temp = []
min_z = []

# neighborhood search

for i in range(M):
	for j in range(N):
		xt = 0
		yt = 0
		
		# move operator
		ran_x_1 = np.random.rand()
		ran_x_2 = np.random.rand()
		ran_y_1 = np.random.rand()
		ran_y_2 = np.random.rand()
		
		if ran_x_1 &amp;gt;= 0.5:
			x1 = k*ran_x_2
		else:
			x1 = -k*ran_x_2
			
		if ran_y_1 &amp;gt;= 0.5:
			y1 = k*ran_y_2
		else:
			y1 = -k*ran_y_2
			
		xt = x0 + x1
		yt = y0 + y1
		
		of_new = ((xt**2)+yt-11)**2+(xt+(yt**2)-7)**2
		of_final = ((x0**2)+y0-11)**2+(x0+(y0**2)-7)**2
	
		ran_1 = np.random.rand()
		form = 1/(np.exp((of_new-of_final)/T0))
		
		if of_new &amp;lt;= of_final:
			x0 = xt
			y0 = yt
		elif ran_1 &amp;lt;= form:
			x0 = xt
			y0 = yt				
		else:
			x0 = x0
			y0 = y0
		
	temp = np.append(temp, T0)
	min_z = np.append(min_z, of_final)
	T0 = alpha*T0
	
print(f&quot;X is {x0:.3f}&quot;)	
print(f&quot;Y is {y0:.3f}&quot;)	
print(f&quot;Final OF is {of_final:.3f}&quot;)	

plt.plot(temp, min_z)
plt.title(&quot;Z vs Temp&quot;, fontsize=20, fornweight='bold')
plt.xlabel(&quot;Temp&quot;, fontsize=18, fornweight='bold')
plt.ylabel(&quot;Z&quot;, fontsize=18, fornweight='bold')

plt.xlim(1000, 0)
plt.xticks(np.arrange(min(temp), max(temp), 100), fornweight='bold')
plt.yticks(fontweight='bold')

plt.show()


&amp;gt;&amp;gt;&amp;gt; X is 3.584
&amp;gt;&amp;gt;&amp;gt; Y is -1.848
&amp;gt;&amp;gt;&amp;gt; Final OF is 0.000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/88bwlvqwrgpj5ki/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-29%2020.47.40.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;x0를 2로 바꾸고, y0을 1로 바꾸고 실행해보기&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;quadratic-assignment-problem&quot;&gt;Quadratic Assignment Problem&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quadratic_assignment_problem&quot;&gt;QAP Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;8개의 department와 8개의 location이 있음&lt;/li&gt;
  &lt;li&gt;objective = minimize flow costs between the placed departments&lt;/li&gt;
  &lt;li&gt;flow cost is flow * distance&lt;/li&gt;
  &lt;li&gt;optimal flow costs is 107(or 214)&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/2m64zmd3e114r2e/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-29%2020.59.07.png?raw=1&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;코드&quot;&gt;코드&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import numpy as np
from matplotlib import pyplot as plt
import pandas as pd

Dist = pd.DataFrame(
    [[0, 1, 2, 3, 1, 2, 3, 4], [1, 0, 1, 2, 2, 1, 2, 3], [2, 1, 0, 1, 3, 2, 1, 2], [3, 2, 1, 0, 4, 3, 2, 1],
     [1, 2, 3, 4, 0, 1, 2, 3], [2, 1, 2, 3, 1, 0, 1, 2], [3, 2, 1, 2, 2, 1, 0, 1], [4, 3, 2, 1, 4, 2, 1, 0]],
    columns=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;], index=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;])

Flow = pd.DataFrame(
    [[0, 5, 2, 4, 1, 0, 0, 6], [5, 0, 3, 0, 2, 2, 2, 0], [2, 3, 0, 0, 0, 0, 0, 5], [4, 0, 0, 0, 5, 2, 2, 10],
     [1, 2, 0, 5, 0, 10, 0, 0], [0, 2, 0, 2, 10, 0, 5, 1], [0, 2, 0, 2, 0, 5, 0, 10], [6, 0, 5, 10, 0, 1, 10, 0]],
    columns=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;], index=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;])

T0 = 1500
M = 250
N = 20
alpha = 0.9

X0 = [&quot;B&quot;, &quot;D&quot;, &quot;A&quot;, &quot;E&quot;, &quot;C&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;]

New_Dist_DF = Dist.reindex(columns=X0, index=X0)
New_Dist_Arr = np.array(New_Dist_DF)

# Make a dataframe of the cost of the initial solution

objfun1_start = pd.DataFrame(New_Dist_Arr * Flow)
objfun1_start_Arr = np.array(objfun1_start)

sum_start = sum(sum(objfun1_start_Arr))

print(sum_start)

Temp = []
Min_Cost = []

for i in range(M):
    for j in range(N):
        ran_1 = np.random.randint(0, len(X0))
        ran_2 = np.random.randint(0, len(X0))

        while ran_1 == ran_2:
            ran_2 = np.random.randint(0, len(X0))

        xt = []
        xf = []

        A1 = X0[ran_1]
        A2 = X0[ran_2]

        # Make a new list of the new set of departments

        w = 0
        for i in X0:
            if X0[w] == A1:
                xt = np.append(xt, A2)
            elif X0[w] == A2:
                xt = np.append(xt, A1)
            else:
                xt = np.append(xt, X0[w])
            w = w + 1

        # print(X0)
        # print(A1, A2)
        # print(xt)

        new_dis_df_init = Dist.reindex(columns=X0, index=X0)
        new_dis_init_arr = np.array(new_dis_df_init)

        new_dis_df_new = Dist.reindex(columns=xt, index=xt)
        new_dis_new_arr = np.array(new_dis_df_new)

        # Make a dataframe of the current solution
        objfun_init = pd.DataFrame(new_dis_init_arr * Flow)
        objfun_init_arr = np.array(objfun_init)

        # Make a dataframe of the new solution
        objfun_new = pd.DataFrame(new_dis_new_arr * Flow)
        objfun_new_arr = np.array(objfun_new)
        sum_init = sum(sum(objfun_init_arr))
        sum_new = sum(sum(objfun_new_arr))

        rand1 = np.random.rand()
        form = 1 / (np.exp(sum_new - sum_init) / T0)

        if sum_new &amp;lt;= sum_init:
            X0 = xt
        elif rand1 &amp;lt;= form:
            X0 = xt
        else:
            X0 = X0

        Temp.append(T0)
        Min_Cost.append(sum_init)

        T0 = alpha * T0

print()
print(&quot;Final Solution&quot;, X0)
print(&quot;Minimized Cost:&quot;, sum_init)

plt.plot(Temp, Min_Cost)
plt.title(&quot;Cost vs Temp&quot;, fontsize=20, fontweight='bold')
plt.xlabel(&quot;Temp&quot;, fontsize=18, fontweight='bold')
plt.ylabel(&quot;Cost&quot;, fontsize=18, fontweight='bold')
plt.xlim(1500, 0)

plt.xticks(np.arange(min(Temp), max(Temp), 100), fontweight='bold')
plt.yticks(fontweight='bold')
plt.show()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%8B%B4%EA%B8%88%EC%A7%88_%EA%B8%B0%EB%B2%95&quot;&gt;Simulated Annealing, SA, 담금질 기법 - 위키피디아&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.aistudy.com/neural/simulated_annealing.htm&quot;&gt;Simulated  Annealing&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://koosaga.com/3&quot;&gt;동전 뒤집기와 Simulated Annealing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/data/2019/04/01/simulated-annealing/</link>
        <guid isPermaLink="true">https://zzsza.github.io/data/2019/04/01/simulated-annealing/</guid>
        
        <category>optimization</category>
        
        
        <category>data</category>
        
      </item>
    
      <item>
        <title>Uber H3 : 육각형 계층의 인덱스</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Uber의 그리드 시스템인 H3에 대한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;그리드-시스템&quot;&gt;그리드 시스템&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Grid 시스템은 대용량 데이터를 분석하고, 지구의 영역을 구분 가능한 그리드셀로 분할할 때 중요
    &lt;ul&gt;
      &lt;li&gt;한국 같은 경우 행정 구역 단위가 있지만(시군구동…) 이 단위는 행정을 위한 단위기 때문에 분석시 유용하지 않음&lt;/li&gt;
      &lt;li&gt;강남구는 생각보다 길고, 큼. 강남역 왼쪽은 서초구&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;우버에선 ride price과 dispatch을 효율적으로 최적화하기 위해 그리드 시스템인 H3을 개발하고 오픈소스로 공개함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;유튜브-영상&quot;&gt;유튜브 영상&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=ay2uwtRO3QE&quot;&gt;H3 Youtube&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Surge Pricing 하며 겪은 이슈
    &lt;ul&gt;
      &lt;li&gt;우버에서 처음엔 도시 단위로 오퍼레이션 했는데, Boundary Effect가 생김
        &lt;ul&gt;
          &lt;li&gt;Surge Cliffs에서 취소가 생김&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Pantom Demand: 유령 수요(너무 넓은 지역)&lt;/li&gt;
      &lt;li&gt;프랑스는 도시가 매우 복잡하고 잘게 쪼개져 있음&lt;/li&gt;
      &lt;li&gt;도시보다 작은 단위가 필요함을 깨달음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;왜 육각형(헥사곤)을 사용했는가?
    &lt;ul&gt;
      &lt;li&gt;Smooth gradients of demand를 구현할 수 있음&lt;/li&gt;
      &lt;li&gt;Clear center of demand&lt;/li&gt;
      &lt;li&gt;Dynamic neighborhoods&lt;/li&gt;
      &lt;li&gt;아래 관점으로 여러 실험
        &lt;ul&gt;
          &lt;li&gt;Neighbor Traversal(이웃 순회)
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/tdcnpzxmdz1p48i/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2011.44.58.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Subdivision(재조합)
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/sabnt0g3y12umnl/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2011.45.42.png?raw=1&quot; /&gt;&lt;/li&gt;
              &lt;li&gt;사각형이 완벽하게 재조합이 되나, 헥사곤은 그렇진 않음. 우버는 완전 똑같을 필요는 없다고 함(약간의 에러를 감수)&lt;/li&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/bp9s01z4rzuwoty/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2011.46.49.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Distortion(왜곡)
            &lt;ul&gt;
              &lt;li&gt;헥사곤을 선택한 중요한 이유 중 하나&lt;/li&gt;
              &lt;li&gt;지구는 sphere(구체)고, 평평하지 않음. 그러나 grid는 평평함. Map Projection을 통해 평평해짐&lt;/li&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/7hjfjzjlh6goz1f/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2011.49.10.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/daxvn294bw4tkhc/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2011.52.21.png?raw=1&quot; height=&quot;300&quot; width=&quot;350&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;H3를 사용하면 지리 데이터를 분석해 여러 결정을 내릴 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;그리드를-사용한-분석-사례&quot;&gt;그리드를 사용한 분석 사례&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/rej9qljs0lx6ty0/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2012.01.23.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;매 순간 라이더가 라이딩을 요청하고, 운전자는 여행을 시작, 배고픈 사용자는 음식을 요청
    &lt;ul&gt;
      &lt;li&gt;각 이벤트는 특정 위치에서 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이런 이벤트를 분석해 시장에 대해 더 잘 이해하고 최적화할 수 있음&lt;/li&gt;
  &lt;li&gt;도시의 특정 지역에서 공급보다 수요가 많아 가격을 조정하거나 특정 드라이버에게 가까운 거리에 승차 요청이 있다고 알릴 수 있음&lt;/li&gt;
  &lt;li&gt;도시 전체 데이터를 분석해야 하고, 미세한 단위로 수행되어야 함&lt;/li&gt;
  &lt;li&gt;헥사곤은 quantization error를 최소화함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;h3&quot;&gt;H3&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Hexagonal global grid system의 장점 + hierarchical indexing 시스템을 결합하기 위해 H3을 만듬&lt;/li&gt;
  &lt;li&gt;지구상 3차원 위치에서 2차원 점으로 이동하려면 투영(Projection)이 필요
    &lt;ul&gt;
      &lt;li&gt;Mercator Projection이 유명한데, 크기 왜곡이 발생해 셀의 영역이 달라짐
        &lt;ul&gt;
          &lt;li&gt;정사각형 그리드는 여러 계수가 필요로 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;결국 지도 투영은 이십면체(&lt;a href=&quot;https://en.wikipedia.org/wiki/Icosahedron&quot;&gt;Icosahedron&lt;/a&gt;)를 중심으로 하는 gnomonic projection을 사용함
        &lt;ul&gt;
          &lt;li&gt;20면체는 다양한 방법으로 펼쳐져 2차원 지도를 생성할 수 있으나, H3는 전개하지 않고 20 면에 그리드를 배치해 geodesic discrete global grid 시스템을 만듬&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;육각형
    &lt;ul&gt;
      &lt;li&gt;육각형은 중심점과 이웃 점 사이에 단 하나의 거리를 가지고 있음&lt;/li&gt;
      &lt;li&gt;그라디언트에 대한 분석/스무딩을 단순화함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;H3 그리드
    &lt;ul&gt;
      &lt;li&gt;122개의 기본 셀을 지구상에 배치하고 한 면에 10개의 셀을 배치해 구성함&lt;/li&gt;
      &lt;li&gt;16개의 해상도(resolution)을 지원&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/e0l8shg4cuzx80w/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-31%2012.09.37.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;계층적 특성으로 인덱스의 해상도를 효율적으로 자르고 복구할 수 있음&lt;/li&gt;
  &lt;li&gt;육각형 색인은 64 비트 정수로 표현됨&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;h3-사용하기&quot;&gt;H3 사용하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Python&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/uber/h3-py&quot;&gt;h3-py&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cc&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;cmake&lt;/code&gt;가 깔려있는지 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  which cc
  /usr/bin/cc
  which make
  /usr/bin/make
  which cmake
  /usr/bin/cmake
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;설치&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pip3 install h3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;geo_to_h3&lt;/code&gt; 함수
    &lt;ul&gt;
      &lt;li&gt;위도, 경도, 해상도를 통해 h3 인덱스를 반환하는 함수&lt;/li&gt;
      &lt;li&gt;arg : lat 위도, lng 경도, hex resolution&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from h3 import h3
  h3_address = h3.geo_to_h3(37.3615593, -122.0553238, 5)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;h3_to_geo&lt;/code&gt; 함수
    &lt;ul&gt;
      &lt;li&gt;h3 인덱스를 통해 헥사곤의 중심점(lat, lng)을 반환하는 함수&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  hex_center_coordinates = h3.h3_to_geo(h3_address)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;h3_to_geo_boundary&lt;/code&gt; 함수
    &lt;ul&gt;
      &lt;li&gt;h3 인덱스를 통해 헥사곤의 boundary를 반환하는 함수&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  hex_boundary = h3.h3_to_geo_boundary(h3_address)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;k_ring_distance&lt;/code&gt; 함수
    &lt;ul&gt;
      &lt;li&gt;h3 인덱스를 통해 거리가 k 안에 있는 h3 인덱스를 반환하는 함수&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  h3.k_ring_distances(h3_address, 4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/uber/h3-py/blob/master/docs/Usage.ipynb&quot;&gt;Folium과 결합해 Jupyter Notebook에서 사용하는 예시&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;SQL에서 사용하고 싶으면, UDF를 만들어서 사용할 수 있음&lt;/li&gt;
  &lt;li&gt;H3를 토대로 나온 데이터를 &lt;a href=&quot;https://kepler.gl/&quot;&gt;kepler.gl&lt;/a&gt;에서 시각화할 수 있음&lt;/li&gt;
  &lt;li&gt;관련 블로그 글 : &lt;a href=&quot;https://zzsza.github.io/data/2019/04/01/uber-keplergl/&quot;&gt;Uber Kepler.gl : 지리 데이터 시각화 도구&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://eng.uber.com/h3/&quot;&gt;H3: Uber’s Hexagonal Hierarchical Spatial Index&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/uber/h3&quot;&gt;H3 Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/uber/h3-py&quot;&gt;h3-py Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=ay2uwtRO3QE&quot;&gt;H3 Youtube&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 31 Mar 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/data/2019/03/31/uber-h3/</link>
        <guid isPermaLink="true">https://zzsza.github.io/data/2019/03/31/uber-h3/</guid>
        
        <category>geographic</category>
        
        
        <category>data</category>
        
      </item>
    
      <item>
        <title>메타휴리스틱 기법과 탐색 방법, Metaheuristics and Search Technique</title>
        <description>&lt;ul&gt;
  &lt;li&gt;메타휴리스틱 이론, 메타휴리스틱 기법에 대해 작성한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/cnwnbmfvz1lbarq/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-26%2017.06.44.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;operations-research&quot;&gt;Operations Research&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;OR&lt;/li&gt;
  &lt;li&gt;수학적 모델링이나 통계 분석, 최적화 기법 등을 이용해 복잡한 &lt;strong&gt;의사결정&lt;/strong&gt; 문제에서 최적해 혹은 근사최적해를 찾아내 이익, 성능, 수익 등을 최대화하거나 손실, 위험, 비용 등을 최소화하는 현실적인 문제를 해결할 때 사용&lt;/li&gt;
  &lt;li&gt;2차 세계 대전에서 기원
    &lt;ul&gt;
      &lt;li&gt;Scheduling&lt;/li&gt;
      &lt;li&gt;Transportation&lt;/li&gt;
      &lt;li&gt;Inventory management&lt;/li&gt;
      &lt;li&gt;Warehousing&lt;/li&gt;
      &lt;li&gt;Facility allocation&lt;/li&gt;
      &lt;li&gt;Energy distribution&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예제
    &lt;ul&gt;
      &lt;li&gt;의자는 15BF, 6시간 노동력이 필요하고 식탁은 24BF, 5시간의 노동력이 필요&lt;/li&gt;
      &lt;li&gt;Maximize profit =&amp;gt; z = 12X + 10Y
        &lt;ul&gt;
          &lt;li&gt;Chair : 12달러, Table : 10달러&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Subjected to
        &lt;ul&gt;
          &lt;li&gt;15X + 24Y &amp;lt;= 300&lt;/li&gt;
          &lt;li&gt;6X + 5Y &amp;lt;= 120&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;or-구성-요소&quot;&gt;OR 구성 요소&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;목적 함수(Objective function)&lt;/li&gt;
  &lt;li&gt;결정 변수(Decision variables)
    &lt;ul&gt;
      &lt;li&gt;목적 함수식이나 제약조건에서 미지수로 나타나는 변수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;제약 조건(Constraints)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;types-of-solutions-and-constraints&quot;&gt;Types of Solutions and Constraints&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Solutions
    &lt;ul&gt;
      &lt;li&gt;Infeasible : 모든 제약조건에 만족하는 solution이 없는 경우&lt;/li&gt;
      &lt;li&gt;Feasible&lt;/li&gt;
      &lt;li&gt;Optimal&lt;/li&gt;
      &lt;li&gt;Near-Optimal&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Constraints
    &lt;ul&gt;
      &lt;li&gt;Hard constraints : 필수 제약조건&lt;/li&gt;
      &lt;li&gt;Soft constraints&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;continuous-vs-combinatorial&quot;&gt;Continuous vs Combinatorial&lt;/h2&gt;
&lt;h3 id=&quot;continuous&quot;&gt;Continuous&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;연속적 문제&lt;/li&gt;
  &lt;li&gt;결정 변수가 연속적인 문제&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;combinatorial&quot;&gt;Combinatorial&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;결정 변수가 이산적인 문제&lt;/li&gt;
  &lt;li&gt;이산적 문제, 조합 최적화 문제&lt;/li&gt;
  &lt;li&gt;정수 계획법(Integer Programming : 결정 변수가 정수인 최적화 문제)이 대표적&lt;/li&gt;
  &lt;li&gt;예시
    &lt;ul&gt;
      &lt;li&gt;Traveling Salesman Problem(TSP)&lt;/li&gt;
      &lt;li&gt;Vehicle Routing Problem(VRP)&lt;/li&gt;
      &lt;li&gt;Knapsack PRoblem(KP)&lt;/li&gt;
      &lt;li&gt;Quadratic Assignment Problem(QAP)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;p-vs-np-problems&quot;&gt;P vs NP Problems&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;P problem : 짧은 다항식 문제&lt;/li&gt;
  &lt;li&gt;NP problem : 짧은 non-deterministic 문제&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;메타휴리스틱&quot;&gt;메타휴리스틱&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;휴리스틱
    &lt;ul&gt;
      &lt;li&gt;합리적인 계산 비용으로 최적 또는 거의 최적의 솔루션을 찾는 기술&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;메타휴리스틱
    &lt;ul&gt;
      &lt;li&gt;특정 문제에 특화되지 않고 자연에서 영감을 얻은 경험적 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NP Problem은 문제가 커지면서 점점 더 어려워짐&lt;/li&gt;
  &lt;li&gt;자주 사용되는 메타휴리스틱 방법
    &lt;ul&gt;
      &lt;li&gt;Genetic Algorithm(GA)&lt;/li&gt;
      &lt;li&gt;Tabu Search(TS)&lt;/li&gt;
      &lt;li&gt;Ant Colony Optimization(ACO)&lt;/li&gt;
      &lt;li&gt;Partical Swarm Optimization(PSO)&lt;/li&gt;
      &lt;li&gt;Simulated Annealing(SA)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;search-techniques&quot;&gt;Search Techniques&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Local search vs global search
    &lt;ul&gt;
      &lt;li&gt;local : 이웃에 기반함, 그리드 서치&lt;/li&gt;
      &lt;li&gt;global : search space&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Deterministic vs stochastic
    &lt;ul&gt;
      &lt;li&gt;deterministic : non-random&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.researchgate.net/post/Difference_between_stochastic_and_deterministic_optimization_model&quot;&gt;참고 링크&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Continuous Problem
    &lt;ul&gt;
      &lt;li&gt;특정 인풋으로부터 어떤 output이 나오는 함수&lt;/li&gt;
      &lt;li&gt;Minimization or maximization 문제&lt;/li&gt;
      &lt;li&gt;Himmelblau’s function&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Combination Problem
    &lt;ul&gt;
      &lt;li&gt;discrete elements의 조합 문제&lt;/li&gt;
      &lt;li&gt;Minimization or maximization 문제&lt;/li&gt;
      &lt;li&gt;TSP 문제
        &lt;ul&gt;
          &lt;li&gt;5개의 도시 : A, B, C, D, E&lt;/li&gt;
          &lt;li&gt;minimum route : D-A-E-C-B (최소 거리)&lt;/li&gt;
          &lt;li&gt;다른 것도 가능 : A-D-C-E-B&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;neighborhood-vs-population-search&quot;&gt;Neighborhood vs Population Search&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Neighborhood search
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/pb45r9rcnld5d8c/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-26%2018.16.50.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;local search&lt;/li&gt;
      &lt;li&gt;계산적으로 어려운 최적화 문제를 해결하는 휴리스틱 방법론&lt;/li&gt;
      &lt;li&gt;잠재적 솔루션을 취하고 주변 환경(일종의 이웃)을 체크&lt;/li&gt;
      &lt;li&gt;Simulated Annealing and Tabu Search&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Population Based Search
    &lt;ul&gt;
      &lt;li&gt;각 iteration에서 솔루션의 population를 사용하는 방법&lt;/li&gt;
      &lt;li&gt;잠재성이 있는 솔루션을 Evaluate&lt;/li&gt;
      &lt;li&gt;랜덤하게 다른 솔루션을 생산하기 위한 솔루션을 선택&lt;/li&gt;
      &lt;li&gt;Genetic Aglorithm, Evolutionary Strategies, Particle Swarm Optimization&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;메타휴리스틱은-어떻게-작동하는가&quot;&gt;메타휴리스틱은 어떻게 작동하는가?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Random initial solution&lt;/li&gt;
  &lt;li&gt;Neighborhood search
    &lt;ul&gt;
      &lt;li&gt;초기 솔루션부터 근처를 돌아다니며 실행&lt;/li&gt;
      &lt;li&gt;모든 스텝을 evaluate&lt;/li&gt;
      &lt;li&gt;각 스텝의 목적 값(objective value)를 추적&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Population-Based search
    &lt;ul&gt;
      &lt;li&gt;랜덤 초기 솔루션을 여러개 생성&lt;/li&gt;
      &lt;li&gt;더 “나은” 솔루션을 생성&lt;/li&gt;
      &lt;li&gt;Diverse&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%9C%B4%EB%A6%AC%EC%8A%A4%ED%8B%B1_%EC%9D%B4%EB%A1%A0&quot;&gt;휴리스틱 이론 - 위키피디아&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/data/2019/03/26/metaheuristics/</link>
        <guid isPermaLink="true">https://zzsza.github.io/data/2019/03/26/metaheuristics/</guid>
        
        <category>optimization</category>
        
        
        <category>data</category>
        
      </item>
    
      <item>
        <title>KafkaKRU(Kafka 한국사용자 모임) 2회 미니밋업 후기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;카프카 한국자 사용자모임에서 진행한 2회 미니밋업 후기입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;행사-정보&quot;&gt;행사 정보&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.facebook.com/events/2222351638018632/&quot;&gt;Facebook Event URL&lt;/a&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  1. 제목: KafkaKRU(Kafka 한국사용자 모임) 제2회 미니밋업
	
  2. 신청: https://www.onoffmix.com/event/171028
	
  3. 날짜: 3월 26일 화요일 오후 6시 50분
	
  4. 장소: 서울특별시 송파구 올림픽로35길 125 삼성SDS 잠실 Campus 동관 지하2층 다목적홀
	
  5. 인원: 35명
	
  6. 후원:
  (1) 삼성 SDS: 장소 및 다과
  (2) 카카오: 카카오 스티커, 카카오 프렌즈 상품
  (3) 책만 출판사: &amp;lt;대시보드 설계와 데이터 시각화&amp;gt; 3권, &amp;lt;블록체인 기업으로 가는 길&amp;gt; 3권
  (4) 젯브레인
	
  7. 일정
  18:50 ~ 19:00 인사 + 네트워킹
  19:00 ~ 19:20 Kafka를 활용한 캐시 로그 처리 - 김현준(카카오)
  19:20 ~ 19:40 Kafka를 활용한 Elasticsearch 실무프로젝트 소개 - 이은학(메가존)
  19:40 ~ 19:50 브레이크 타임
  19:50 ~ 20:10 Kafka를 활용한 rabbitmq 로그 처리 - 정원빈(카카오)
  20:10 ~ 20:30 Kafka를 Microservice Architecture에 활용하기 - 이동진(Apache Software Foundation)
  20:30 ~ 20:50 Kafka 프로듀서 &amp;amp; 컨슈머 - 강한구(카카오 모빌리티)
  21:00 ~ 뒷풀이
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;인사&quot;&gt;인사&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/171e1o759mlbadb/2019-03-26%2018.52.45.jpg?raw=1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;발표 자료 : &lt;a href=&quot;https://github.com/kafkakru/meetup&quot;&gt;https://github.com/kafkakru/meetup&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;나중에 스티커를 만든다고 하심!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;kafka를-활용한-캐시-로그-처리-사례&quot;&gt;Kafka를 활용한 캐시 로그 처리 사례&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;카카오 김현준님&lt;/li&gt;
  &lt;li&gt;1도 모르는 사람이 Kafka &amp;amp; ELK로 캐시로그 처리해보기&lt;/li&gt;
  &lt;li&gt;캐시 시스템과 실시간 로그분석의 필요성
    &lt;ul&gt;
      &lt;li&gt;캐시 시스템
        &lt;ul&gt;
          &lt;li&gt;오픈소스를 활용한 구성(nginx + ATS)&lt;/li&gt;
          &lt;li&gt;자체 개발 캐시서버&lt;/li&gt;
          &lt;li&gt;img/static image(css/js), 동영상 등을 처리하기 위한 캐시 시스템&lt;/li&gt;
          &lt;li&gt;1차 Cache ⇒ 2차 Cache ⇒ 원본(Origin)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;실시간 로그 분석 필요성
        &lt;ul&gt;
          &lt;li&gt;Image size, 404, 응답 지연 등 ⇒ 하루 전 데이터를 가지고 모니터링&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;캐시 로그 분석 시스템 구축
    &lt;ul&gt;
      &lt;li&gt;운영의 니즈를 반영하고자 시스템 구축 시작&lt;/li&gt;
      &lt;li&gt;ELK로 시작, 1차 Cache에서 access_log를 그림
        &lt;ul&gt;
          &lt;li&gt;요청이 많고, 트래픽이 많음 ⇒ 로그도 많음&lt;/li&gt;
          &lt;li&gt;로컬 캐시 서버에 로그를 쌓기 싫어서, nginx에서 바로 쏨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;문제 인지와 Kafka 도입 그리고 Lag
    &lt;ul&gt;
      &lt;li&gt;키바나 그래프를 보다보니 로그가 너무 조금만 들어오고 있음!?&lt;/li&gt;
      &lt;li&gt;분석 시작&lt;/li&gt;
      &lt;li&gt;Syslog 전송 과정에서 누락? Logstash 성능?&lt;/li&gt;
      &lt;li&gt;주변에 물어보니 대용량이나 많은 트래픽은 logstash 앞단에 큐 하나!&lt;/li&gt;
      &lt;li&gt;redis나 rabbitmq를 찾아보다가 승범님이 카프카를 쓰길 권함&lt;/li&gt;
      &lt;li&gt;lag이 계속 쌓임…! lag은 처리하지 못한 수치
        &lt;ul&gt;
          &lt;li&gt;파티션을 쪼개던지, 컨슈머를 늘리거나 등등&lt;/li&gt;
          &lt;li&gt;로그 분석이 돈 버는 것은 아니라 컨슈머를 늘리기엔 눈치가 보이고.. 파티션 조정해도 효과가 적음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;logstash 설정이 잘못된 것 같으니 다시! ⇒ 모두 동일..&lt;/li&gt;
      &lt;li&gt;auto.commit.interval.ms=5000과 auto.commit= true
        &lt;ul&gt;
          &lt;li&gt;interval을 줄이니 lag이 사라짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;현재는 수백대의 cache 서버 로그를 초당 15만건 이상 처리
    &lt;ul&gt;
      &lt;li&gt;대략 30테라?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;kafka를-활용한-elasticsearch-실무프로젝트-소개&quot;&gt;Kafka를 활용한 Elasticsearch 실무프로젝트 소개&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;메가존 이은학님&lt;/li&gt;
  &lt;li&gt;빅데이터 플랫폼 구축 및 활용솔루션 개발 중&lt;/li&gt;
  &lt;li&gt;프로젝트
    &lt;ul&gt;
      &lt;li&gt;카드사&lt;/li&gt;
      &lt;li&gt;비정형 / 정형 / 외부 데이터 ⇒ 분산되어 있는데 통합!&lt;/li&gt;
      &lt;li&gt;빅데이터 허브 : 엘라스틱 서치 + 하둡&lt;/li&gt;
      &lt;li&gt;사이언스 플랫폼&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로젝트에서 Elastic Stack 활용 영역
    &lt;ul&gt;
      &lt;li&gt;비정형 데이터 분석
        &lt;ul&gt;
          &lt;li&gt;Google analytics&lt;/li&gt;
          &lt;li&gt;고객 상담데이터(STT) ⇒ RESTFul 한글 형태소 분석기(Nori)&lt;/li&gt;
          &lt;li&gt;웹/앱 로그&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;아키텍쳐
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/1jpa38uk5qyvmho/2019-03-26%2019.28.17.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;스트리밍 데이터(24시간 발생하는 웹, 고객 상담) ⇒ 카프카&lt;/li&gt;
      &lt;li&gt;GA 데이터 ⇒ Batch로 logstash&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;카프카 사용 이유
    &lt;ul&gt;
      &lt;li&gt;데이터가 많고, 다른 곳에서 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;카드사라 고객 상담 데이터 중 &lt;code class=&quot;highlighter-rouge&quot;&gt;탈퇴&lt;/code&gt;라는 단어나 &lt;code class=&quot;highlighter-rouge&quot;&gt;카드론&lt;/code&gt;은 민감 ⇒ 이 단어가 나오면 해당 부서에 Push ⇒ 대응(카드론은 수익에 연결된 단어)&lt;/li&gt;
  &lt;li&gt;프로젝트 이슈
    &lt;ul&gt;
      &lt;li&gt;사용자 쿼리 기록해야 함 ⇒ 금융감독원 감사&lt;/li&gt;
      &lt;li&gt;6.5.1부터 UserID를 남길 수 있음&lt;/li&gt;
      &lt;li&gt;xpack.security.audit.enabled; true&lt;/li&gt;
      &lt;li&gt;xpack.security.audit.outputs: logfile&lt;/li&gt;
      &lt;li&gt;통신 노드도 남음 ⇒ 제외할 ID를 설정해야함
        &lt;ul&gt;
          &lt;li&gt;kibana, 다른 id&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Audit 활용 사례
    &lt;ul&gt;
      &lt;li&gt;건수 확인 (curl)&lt;/li&gt;
      &lt;li&gt;조회(페이징)
        &lt;ul&gt;
          &lt;li&gt;주의 사항 : 엘라스틱은 기본적으로 10000건까지만 반환함. 설정 필요
            &lt;ul&gt;
              &lt;li&gt;max_result_window를 설정하고 조회한 후, 해제(null) ⇒ 해제 안하면 부담이 될 수 있음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;개인정보 비식별화
    &lt;ul&gt;
      &lt;li&gt;비정형 데이터 특정상 개인정보의 식별범위 모호&lt;/li&gt;
      &lt;li&gt;처음엔 할 수 없다고 했는데, 생각해보니 몇 패턴이 있음
        &lt;ul&gt;
          &lt;li&gt;고객 상담을 전문으로 하는 분들은 단어 선택을 또박 또박하게 함 ⇒ 음성 분석 파일을 분석하니 ~~ 회원님 ~~님이라고 정확하게 발음하는 것을 확인함 ⇒ 로직 처리&lt;/li&gt;
          &lt;li&gt;카드 번호, 주민번호 : 연속되는 숫자 체크&lt;/li&gt;
          &lt;li&gt;치환 : 주소&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Ruby Filter(str.rb) 작성 후, str.conf(logstash 적용)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;빅데이터 에코시스템 연계
    &lt;ul&gt;
      &lt;li&gt;Elasticsearch → Hadoop
        &lt;ul&gt;
          &lt;li&gt;ES Hadoop 사용&lt;/li&gt;
          &lt;li&gt;일별을 index로 지정&lt;/li&gt;
          &lt;li&gt;N번 실행시 중복 방지하도록 overwriting table&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Hadoop → Elasticsearch&lt;/li&gt;
      &lt;li&gt;명사 별도 적재 사례
        &lt;ul&gt;
          &lt;li&gt;적재된 한글 문장 데이터 중 명사만 별도 field로 적재 필요&lt;/li&gt;
          &lt;li&gt;이유 : Nori 형태소 분석 결과를 타 빅데이터 시스템에서 활용
            &lt;ul&gt;
              &lt;li&gt;REST Call이 힘드니 하둡에 적재&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;아이디어1 : 인덱스 데이터는 날짜별로 쌓임&lt;/li&gt;
          &lt;li&gt;아이디어2 : logstash를 통해 reindex가 가능&lt;/li&gt;
          &lt;li&gt;아이디어3 : Cron 형태의 배치가 가능&lt;/li&gt;
          &lt;li&gt;INDEX 조회시 source와 토큰을 동시 조회한 후, 동일 INDEX에 source와 토큰 업데이트!&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;소스도 올라와있음!&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;kafka를-활용한-rabbitmq-로그-처리&quot;&gt;Kafka를 활용한 RabbitMQ 로그 처리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;카카오, 정원빈님&lt;/li&gt;
  &lt;li&gt;RabbitMQ
    &lt;ul&gt;
      &lt;li&gt;erlang으로 구현된 AMQP 메시지 브로커&lt;/li&gt;
      &lt;li&gt;Advanced Message Queue Protocol&lt;/li&gt;
      &lt;li&gt;AMQP
        &lt;ul&gt;
          &lt;li&gt;퍼블리셔가 Exchange → 큐에 전달(메세지를 저장하는 저장소) → Consumer에서 push/pull 방식으로 가져감&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Exchange, queue가 VHOST 논리 단위로 생성&lt;/li&gt;
      &lt;li&gt;퍼블리셔가 제대로 보냈는지, 컨슈머가 제대로 받았는지 확인할 수도 있음&lt;/li&gt;
      &lt;li&gt;TCP 연결 체크하는 로직&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RabbitMQ 모니터링
    &lt;ul&gt;
      &lt;li&gt;Server resource
        &lt;ul&gt;
          &lt;li&gt;메모리를 모니터링&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;RabbitMQ LOG&lt;/li&gt;
      &lt;li&gt;AMQP OPERATION&lt;/li&gt;
      &lt;li&gt;밑에 2개를 카프카를 사용함&lt;/li&gt;
      &lt;li&gt;Kafka + Elastic Search로 로그 처리 시스템을 개발&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rabbit MQ에서 Filebeat/Worker에서 → APP Topic, AMQP Topic을 카프카로 전송 → Elastic Search로 저장 → Kibana
    &lt;ul&gt;
      &lt;li&gt;토픽 중 특정 단어가 포함되었거나 AMQP 중 확인하고 싶은 오퍼레이션을 파싱, 구별해서 관리자에게 알람이 가도록 구성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RabbitMQ? Kafka?
    &lt;ul&gt;
      &lt;li&gt;둘다 메세지 브로커
        &lt;ul&gt;
          &lt;li&gt;RabbitMQ도 멀티컨슈머가 가능하긴 한데, 추가될 때마다 큐를 추가적으로 생성해야 함
            &lt;ul&gt;
              &lt;li&gt;Exchange는 큐의 메세지만큼 복사해서 전달&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Kafka는 Consumer를 추가하면 그냥 추가하면 끝
            &lt;ul&gt;
              &lt;li&gt;하나의 동일한 메세지를 여러개의 컨슈머가 동시에 할 수 있어서 기능 확장이 용이함&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;메시지 관점에서 상세 비교
        &lt;ul&gt;
          &lt;li&gt;RabbitMQ는 큐 기반이고 메모리에 저장됨
            &lt;ul&gt;
              &lt;li&gt;Consumer가 메세지 수신시 즉시 삭제&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Kafka는 로그 기반이고 디스크에 저장
            &lt;ul&gt;
              &lt;li&gt;리텐션 설정하면 그 기간동안 상시 보관&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;메세지 처리 방식도 다름
        &lt;ul&gt;
          &lt;li&gt;RabbitMQ는 발송 확인 / 수신 확인 가능
            &lt;ul&gt;
              &lt;li&gt;Prefetch Count : Consumer에 이슈가 있을 때(제대로 수신하지 못할 떄) 다른 consumer나 다시 전송하도록 하는 설정&lt;/li&gt;
              &lt;li&gt;메모리 사용률이 높을 때 차단&lt;/li&gt;
              &lt;li&gt;Exchange를 통해 특정 큐에 라우팅 가능&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Kafka는 발송 확인 가능 / 수신 확인 불가능
            &lt;ul&gt;
              &lt;li&gt;Prefetch나 메모리 사용률 높을때 차단하는 설정 없음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RabbitMQ는 똑똑하지만 조금 느린 브로커, Kafka는 게으르지만 매우 효율적인 브로커&lt;/li&gt;
  &lt;li&gt;서비스에 따라 적당한 것이 따로 있다고 생각함
    &lt;ul&gt;
      &lt;li&gt;동시에 모두 사용도 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RabbitMQ는 제이피모건에서 많이 사용함&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;kafka-streams--interactive-queries&quot;&gt;Kafka Streams : Interactive Queries&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/4ykqy84awjik760/2019-03-26%2020.38.05.jpg?raw=1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Apache Software Foundation, 이동진님&lt;/li&gt;
  &lt;li&gt;Kafka Topic에 저장된 내용을 Microservice에서 참조하고 싶은데, 어떻게 해야 하나요?
    &lt;ul&gt;
      &lt;li&gt;Redis 같은데 저장해서 써야 하나요?
        &lt;ul&gt;
          &lt;li&gt;Producer → Kafka → Consumer → Redis → Microservice?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;이런 방법이 아니라!
        &lt;ul&gt;
          &lt;li&gt;Interactive Query 기능 또는 Queryable Store 기능!&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Kafka Streams
    &lt;ul&gt;
      &lt;li&gt;Kafka 0.10에 도입된 Stream 처리 library&lt;/li&gt;
      &lt;li&gt;Kafka Topic을 실시간으로 받아서 처리하는 루틴을 간편하게 정의 가능
        &lt;ul&gt;
          &lt;li&gt;High Level DSL : KStream, KTable&lt;/li&gt;
          &lt;li&gt;Low Level API도 지원&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;장점
        &lt;ul&gt;
          &lt;li&gt;Task 관리가 필요 없음
            &lt;ul&gt;
              &lt;li&gt;필요한만큼(=파티션 수) 알아서 작업(task)을 생성하고 thread pool에 분배&lt;/li&gt;
              &lt;li&gt;하나의 작업이 하나의 (topic, partition)에 대한 처리 전담&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;consumer group 기능을 사용해서 구현됨 → coordination이 필요 없음&lt;/li&gt;
          &lt;li&gt;프레임워크가 아닌 라이브러리 ⇒ 갖다 쓰면 됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;wordcount 예제
    &lt;ul&gt;
      &lt;li&gt;props와 topology 객체를 넣어주면 카프카 스트림즈 객체가 됨&lt;/li&gt;
      &lt;li&gt;스트림즈에 start method를 실행하면 지정한 로직대로 진행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Key-value storage
    &lt;ul&gt;
      &lt;li&gt;Kafka Streams가 처리의 효율성을 위해 내부적으로 만든 저장소&lt;/li&gt;
      &lt;li&gt;RocksDB로 구현됨(Facebook에서 만든 inmemory db)&lt;/li&gt;
      &lt;li&gt;직접 생성할 수도 있고, 사용자가 임의로 생성할 수도 있음&lt;/li&gt;
      &lt;li&gt;KTable 객체를 생성하면 반드시 하나가 함께 생김&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Interactive Query
    &lt;ul&gt;
      &lt;li&gt;Kafka Streams 내부에 생성된 key value storage의 내용과 위치를 조회할 수 있도록 해주는 기능&lt;/li&gt;
      &lt;li&gt;Queryable Store : interactive query 기능이설정된 key value storage&lt;/li&gt;
      &lt;li&gt;수정은 안됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Interactive Query 예제
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/252ca0sjobh2isq/2019-03-26%2020.45.29.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/smn7utvu9vzg3q0/2019-03-26%2020.46.08.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/nk8s2kpjzzmvhd5/2019-03-26%2020.48.37.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;결론
    &lt;ul&gt;
      &lt;li&gt;KTable을 사용하면 Kafka Topic의 내용을 표 형태로 읽어올 수 있다
        &lt;ul&gt;
          &lt;li&gt;그 내용을 Interactive Query를 사용해서 열어볼 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;kafka Streams가 해주는 것
        &lt;ul&gt;
          &lt;li&gt;현재 프로세스에서 잡고 있는 partition에 포함된 key에 대한 value 값&lt;/li&gt;
          &lt;li&gt;현재 프로세스에서 잡고 있는 partition에 포함된 포트 값&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Spark Streaming은 언제 쓸까?
    &lt;ul&gt;
      &lt;li&gt;여러 데이터 소스에서 읽고 복잡한 쿼리를 사용한다면 Spark Streaming&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;kafka-프로듀서--컨슈머&quot;&gt;Kafka 프로듀서 &amp;amp; 컨슈머&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;카카오 모빌리티, 강한구님&lt;/li&gt;
  &lt;li&gt;AB Test 플랫폼을 만들 때 Flink, Vertical Service에서 ETL을 담당&lt;/li&gt;
  &lt;li&gt;예전엔 카프카 쓰세요! Default만 해도 된다고 했는데 요새는 더 깊게 알아야 할 것 같아 자료를 만듬&lt;/li&gt;
  &lt;li&gt;Producer
    &lt;ul&gt;
      &lt;li&gt;메세지를 전송&lt;/li&gt;
      &lt;li&gt;producer객체를 생성할 때
        &lt;ul&gt;
          &lt;li&gt;Accumulator와 Network Thread가 생성됨
            &lt;ul&gt;
              &lt;li&gt;Accumulator : 사용자가 send한 reocrd를 메모리(recordbatch)에 차곡차곡 쌓아줌&lt;/li&gt;
              &lt;li&gt;Network Thread : RecordBatch를 브로커로 전송&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;For문을 돌 때
        &lt;ul&gt;
          &lt;li&gt;buffer.size, batch.size로 지정&lt;/li&gt;
          &lt;li&gt;브로커로 전송하는 속도보다 쌓이는 속도가 많으면 내부적으로 어큐물레이터에 쌓이게 될테고, 버퍼 메모리만큼 차게 되면 어플리케이션에서 블락 됨&lt;/li&gt;
          &lt;li&gt;Network Thread가 별도의 쓰레드가 떠서 계속 쉴 틈 없이 작업을 수행
            &lt;ul&gt;
              &lt;li&gt;해당 레코드 배치가 어떤 브로커로 갈지&lt;/li&gt;
              &lt;li&gt;브로커를 상태 확인&lt;/li&gt;
              &lt;li&gt;브로커별 레코드 배치를 재배열&lt;/li&gt;
              &lt;li&gt;데이터 전송&lt;/li&gt;
              &lt;li&gt;linger.ms → send 속도가 너무 느려서 레코드 배치에 쌓이는 것이 별로 없을 때 이 시간만큼 기다렸다가 가져감&lt;/li&gt;
              &lt;li&gt;max.request.size → 바이크에 탈 사람의 수로 비유&lt;/li&gt;
              &lt;li&gt;max.in.flights.requests.per.connection&lt;/li&gt;
              &lt;li&gt;(발표 자료가 아래쪽으로 되어있어서 정확히 못봄..! 자료 나중에 공개되면 확인)&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Broker
    &lt;ul&gt;
      &lt;li&gt;메세지를 저장
        &lt;ul&gt;
          &lt;li&gt;[Topic name] - [partition] 폴더 구조&lt;/li&gt;
          &lt;li&gt;confluent 블로그에서 본 내용인데, 하드 4테라 1개보다 1테라 하드 4개가 더 좋다!&lt;/li&gt;
          &lt;li&gt;Segment 단위로 파일 저장
            &lt;ul&gt;
              &lt;li&gt;*.index, *.log, *.timeindex&lt;/li&gt;
              &lt;li&gt;첫 offset이 파일명이 됨&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Consumer
    &lt;ul&gt;
      &lt;li&gt;메세지를 가지고 옴&lt;/li&gt;
      &lt;li&gt;fetcher와 coordinator&lt;/li&gt;
      &lt;li&gt;Fetcher
        &lt;ul&gt;
          &lt;li&gt;poll 함수가 실행되면 적절한 크기의 record 리턴하고, 내부에 record가 없다면 브로커에게 record드를 요청하고 저장. 그리고 적절한 크기의 record 리턴하는 역할&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Coordinator
        &lt;ul&gt;
          &lt;li&gt;fetcher가 열심히 일할 수 있도록 정보 제공&lt;/li&gt;
          &lt;li&gt;어떤 토픽, 파티션을 consume할지&lt;/li&gt;
          &lt;li&gt;Broker의 group coordinator와 통신&lt;/li&gt;
          &lt;li&gt;Heartbeat, offset, commit, consumer group join도 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;코드 예제를 통해 설명해주셨는데, 천천히 보면 좋을듯&lt;/li&gt;
      &lt;li&gt;Fetcher에 레코드가 있는 경우
        &lt;ul&gt;
          &lt;li&gt;바로 리턴&lt;/li&gt;
          &lt;li&gt;max.poll.records : 한번에 가져올 레코드 수&lt;/li&gt;
          &lt;li&gt;max.poll.interval.ms : poll이란 함수를 호출하는 최대 시간&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Fetcher에 레코드가 없는 경우
        &lt;ul&gt;
          &lt;li&gt;max.partition.fetch.bytes&lt;/li&gt;
          &lt;li&gt;fetch.min.bytes&lt;/li&gt;
          &lt;li&gt;fetch.max.wait.ms&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;부록
    &lt;ul&gt;
      &lt;li&gt;Consumer Rebalance&lt;/li&gt;
      &lt;li&gt;Consumer Group offset
        &lt;ul&gt;
          &lt;li&gt;0.9 미만에선 zookeeper에 consumer offset을 저장 ⇒ 껏다가 켰다가 ⇒ 무리가 감&lt;/li&gt;
          &lt;li&gt;0.9 이상에선 __consumer_offset 토픽을 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;후기&quot;&gt;후기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;카프카를 많이 사용하진 않고, GCP에서 Pub/Sub 정도만 사용했지만 꾸준히 관심을 가져온 카프카! 새로운 시각을 얻을 수 있었음&lt;/li&gt;
  &lt;li&gt;잠실의 삼성 SDS에서 행사가 진행되었는데, SDS 건물 처음 들어가서 신기했음..!&lt;/li&gt;
  &lt;li&gt;행사장에 가니 서브웨이 샌드위치도 준비해주시고 + 중간에 피자도 주셔서 배부르게 먹었음..! 감사합니다&lt;/li&gt;
  &lt;li&gt;Kafka는 ElasticSearch와 쓰는 조합이 정말 많은 것 같은데, 진짜일까? 확인해보기&lt;/li&gt;
  &lt;li&gt;Kafka Streams와 Machine Learning을 합쳐서 사용하는 사례도 발견 : &lt;a href=&quot;https://github.com/kaiwaehner/kafka-streams-machine-learning-examples&quot;&gt;kafka-streams-machine-learning-examples&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;오랜만에 만난 분들과 인사해서 좋았음!&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.facebook.com/groups/kafka.kru/&quot;&gt;Kafka 한국 사용자 모임&lt;/a&gt; 가입 안하셨다면 가입 필수 :)&lt;/li&gt;
  &lt;li&gt;마지막 Google 설문지 링크는 bit.ly 같은 것으로 줄여서 bit.ly/kafkakru-미니밋업-2회-설문 이렇게 하셨으면 더 좋았을 것 같음..! (사실 설문하려고 했는데 수많은 텍스트 문자 있고, 뒤에서 안보여서 시도했다가 포기..OTL)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/etc/2019/03/26/kafkakru-2nd-review/</link>
        <guid isPermaLink="true">https://zzsza.github.io/etc/2019/03/26/kafkakru-2nd-review/</guid>
        
        <category>lecture</category>
        
        
        <category>etc</category>
        
      </item>
    
      <item>
        <title>pandas-gbq에서 인증(Authentication) 설정하기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;pandas-gbq에서 인증(authentication) 하는 방법에 대해 정리한 글입니다
    &lt;ul&gt;
      &lt;li&gt;pandas-gbq는 pandas에서 Google BigQuery의 데이터를 쉽게 조회할 수 있는 파이썬 라이브러리입니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;authentication&quot;&gt;Authentication&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;1) Service Account Key 사용한 인증&lt;/li&gt;
  &lt;li&gt;2) User Account를 통한 인증&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;service-account-key&quot;&gt;Service Account Key&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Service Account Key는 &lt;a href=&quot;https://console.cloud.google.com/apis/credentials/serviceaccountkey&quot;&gt;Creation Page&lt;/a&gt;에서 쉽게 만들 수 있음
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/docs/authentication/getting-started&quot;&gt;공식 문서&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;JSON key type을 선택해 다운로드&lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;간편하게 사용 가능&lt;/li&gt;
      &lt;li&gt;Remote 서버에서 사용할 경우 매우 유용
        &lt;ul&gt;
          &lt;li&gt;Remote 서버를 위한 Key를 발급한 후, IAM을 특정 권한만 설정&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;처음엔 사용하기 쉬우나 회사에서 이 key를 통해 많은 사람들이 쿼리를 날린다면, 보안의 문제가 있을 수 있음&lt;/li&gt;
      &lt;li&gt;JSON key를 잘 관리할 수 있는지?가 핵심 이슈
        &lt;ul&gt;
          &lt;li&gt;이 이슈를 위해 2) User Account를 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용 예시
    &lt;ul&gt;
      &lt;li&gt;private key 파라미터를 사용할 경우
        &lt;ul&gt;
          &lt;li&gt;deprecated 예정&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import pandas as pd
	
  query = &quot;SELECT * FROM `dataset.table`&quot;
  pd.read_gbq(query=query, project_id=&quot;project_id&quot;, private_key=&quot;path/to/key.json&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;credentials 파라미터를 사용할 경우
        &lt;ul&gt;
          &lt;li&gt;pandas 0.24.0, pandas-gbq 0.8.0 버전부터 사용 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from google.oauth2 import service_account
  import pandas as pd
	
  credentials = service_account.Credentials.from_service_account_file('path/to/key.json')

  query = &quot;SELECT * FROM `dataset.table`&quot;
  df = pd.read_gbq(query=query, project_id=&quot;project_id&quot;, credentials=credentials)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;user-account&quot;&gt;User Account&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;이 방식은 Colab에서 Google drive 권한 획득하는 것처럼 웹을 띄운 후, G Suite 또는 Gmail 로그인으로 인증하는 방식
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pydata_google_auth&lt;/code&gt; 라이브러리 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;Key가 아닌 User Account로 인증하기 때문에 GCP의 IAM으로 관리할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;캐시된 인증이 끝난 후, 다시 작업해야 하는 점&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용 예시&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import pandas as pd
  import pydata_google_auth

  SCOPES = [
      'https://www.googleapis.com/auth/cloud-platform',
      'https://www.googleapis.com/auth/drive',
      'https://www.googleapis.com/auth/bigquery'
  ]
	
  credentials = pydata_google_auth.get_user_credentials(
  	SCOPES, auth_local_webserver=True)
	
  query = &quot;SELECT * FROM `dataset.table`&quot;
  df = pd.read_gbq(query=query, project_id=&quot;project_id&quot;, credentials=credentials)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;결론&quot;&gt;결론&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;어떤 방식이 좋은지는 “상황”에 따라 다름&lt;/li&gt;
  &lt;li&gt;각 방식의 차이점이 무엇인지 인지하고, 적절하게 사용하는 것이 핵심!&lt;/li&gt;
  &lt;li&gt;공식 google-cloud-bigquery에서 인증하는 방법이 궁금하면 &lt;a href=&quot;https://cloud.google.com/bigquery/docs/reference/libraries&quot;&gt;공식 문서&lt;/a&gt; 참고&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://pandas-gbq.readthedocs.io/en/latest/howto/authentication.html&quot;&gt;pandas_gbq&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/gcp/2019/03/17/pandas-gbq-auth/</link>
        <guid isPermaLink="true">https://zzsza.github.io/gcp/2019/03/17/pandas-gbq-auth/</guid>
        
        <category>basic</category>
        
        
        <category>gcp</category>
        
      </item>
    
      <item>
        <title>Terraform 소개 및 정리</title>
        <description>&lt;ul&gt;
  &lt;li&gt;코드로 인프라를 관리할 수 있는 테라폼에 대해 정리한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;코드로서의-인프라스트럭처&quot;&gt;코드로서의 인프라스트럭처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;“Write, Plan, and Create Infrastructure as Code”&lt;/li&gt;
  &lt;li&gt;인프라스트럭처를 코드로서 작성, 계획, 생성하는 도구&lt;/li&gt;
  &lt;li&gt;하나의 패러다임
    &lt;ul&gt;
      &lt;li&gt;Infrastructure as Code&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인프라스트럭처의 정의
    &lt;ul&gt;
      &lt;li&gt;리소스들의 집합
        &lt;ul&gt;
          &lt;li&gt;물리적 환경 : 네트워크 장비, 서버 컴퓨터 등&lt;/li&gt;
          &lt;li&gt;클라우드 : 가상 컴퓨팅 자원, 매니지드 서비스 등&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;코드로서 인프라스트럭처 IaC 도구
        &lt;ul&gt;
          &lt;li&gt;리소스를 코드로 관리하는 도구&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;관리하는 도구들
    &lt;ul&gt;
      &lt;li&gt;서버 스크립팅(Server Scripting)
        &lt;ul&gt;
          &lt;li&gt;서버에서 스크립트 실행&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;설정 관리(Configurations Management)
        &lt;ul&gt;
          &lt;li&gt;대상 : 서버의 상태&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;리소스 선언 도구(Resource Management)
        &lt;ul&gt;
          &lt;li&gt;대상 : 리소스를 정의&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;설정-관리&quot;&gt;설정 관리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;셰프, 퍼핏, 앤서블 등
    &lt;ul&gt;
      &lt;li&gt;DSL 코드로 서버의 상태를 정의하고 관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서버 명령어보다 추상회되어 있음
    &lt;ul&gt;
      &lt;li&gt;다수의 서버와 다양한 환경을 지원&lt;/li&gt;
      &lt;li&gt;완벽하지는 않지만 서버가 우리가 정의한대로 되도록 멱등성을 지원&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Chef Solo 입문 : 인프라스트럭처 자동화 프레임워크라고 되어있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;일반적인-소프트웨어-개발&quot;&gt;일반적인 소프트웨어 개발&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;코드 작성&lt;/li&gt;
  &lt;li&gt;Git 저장소로 변경 관리&lt;/li&gt;
  &lt;li&gt;Github로 협업
    &lt;ul&gt;
      &lt;li&gt;이슈 관리&lt;/li&gt;
      &lt;li&gt;풀 리퀘스트와 코드 리뷰&lt;/li&gt;
      &lt;li&gt;지속적 통합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;인프라스트럭처가-코드가-되면&quot;&gt;인프라스트럭처가 코드가 되면&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;소프트웨어처럼 개발할 수 있음!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;리소스-선언-도구&quot;&gt;리소스 선언 도구&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;테라폼 Terraform, 클라우드 포메이션 등&lt;/li&gt;
  &lt;li&gt;DSL 코드로 리소스를 선언하고 관리
    &lt;ul&gt;
      &lt;li&gt;주로 클라우드의 가상화된 리소스를 관리&lt;/li&gt;
      &lt;li&gt;물리적 장비는 대상이 아님&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;코드가 곧 아키텍처&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;테라폼&quot;&gt;테라폼&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;HashiCrop에서 만든 오픈소스 인프라 관리 도구&lt;/li&gt;
  &lt;li&gt;HCL를 사용해 인프라스트럭처를 코드로 정의&lt;/li&gt;
  &lt;li&gt;다양한 프로바이더를 지원
    &lt;ul&gt;
      &lt;li&gt;AWS, GCP, Azure&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;커맨드라인 인터페이스
    &lt;ul&gt;
      &lt;li&gt;의존성 표현도 가능&lt;/li&gt;
      &lt;li&gt;어떤 것이 먼저 필요한지 테라폼이 정의해서 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;엔터프라이즈 서비스 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hcl과-테라폼-기초&quot;&gt;HCL과 테라폼 기초&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HashiCorp Configurations Language&lt;/li&gt;
  &lt;li&gt;하시코프에서 만든 설정 전용 DSL
    &lt;ul&gt;
      &lt;li&gt;컨설, 테라폼에서 지원&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;JSON과 호환&lt;/li&gt;
  &lt;li&gt;변수, 조건문, 인터폴레이션 등 지원&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HCL: 리소스&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  resource &quot;aws_instance&quot; &quot;bastion&quot; {
      ami = &quot;${ var.ami_id }&quot;
      instance_type = &quot;${ var.type }&quot;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;aws_instance : 리소스 타입&lt;/li&gt;
      &lt;li&gt;bastion : 리소스 이름(테라폼 내부에서 참조하기 위해 사용)&lt;/li&gt;
      &lt;li&gt;ami, instance_type : 속성 이름&lt;/li&gt;
      &lt;li&gt;${ var. ~} : 속성 값&lt;/li&gt;
      &lt;li&gt;테라폼은 리소스를 계속 정의&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;테라폼-workflow&quot;&gt;테라폼 Workflow&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Write -&amp;gt; Plan -&amp;gt; Create(Apply)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Write&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  resource &quot;aws_instance&quot; &quot;bastion&quot; {
      ami = &quot;${ var.ami_id }&quot;
      instance_type = &quot;${ var.type }&quot;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;로컬에 aws_instance.bastion이 있고 AWS 계정엔 아무것도 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Plan
    &lt;ul&gt;
      &lt;li&gt;aws_instance.bastion이 생성 계획 정의&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  terraform plan
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Create
    &lt;ul&gt;
      &lt;li&gt;apply를 통해 AWS에 리소스를 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상태를 terraform.tfstate에 저장&lt;/li&gt;
  &lt;li&gt;용어
    &lt;ul&gt;
      &lt;li&gt;계획=plan&lt;/li&gt;
      &lt;li&gt;적용=apply&lt;/li&gt;
      &lt;li&gt;상태=tfstate&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;테라폼-삽질기&quot;&gt;테라폼 삽질기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;테라포밍
    &lt;ul&gt;
      &lt;li&gt;테라폼을 적용하는 두 가지 방법
        &lt;ul&gt;
          &lt;li&gt;새로 만드는 리소스를 테라폼으로 작성&lt;/li&gt;
          &lt;li&gt;운영 중인 클라우드 자원을 테라폼 코드로 작성&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기존의 리소스 임포트
    &lt;ul&gt;
      &lt;li&gt;테라폼 import 명령어
        &lt;ul&gt;
          &lt;li&gt;현재 상태만을 tfstate에 임포트&lt;/li&gt;
          &lt;li&gt;tf 파일은 생성되지 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;tfstate에만 자원이 있다면 삭제하려고 함(위험!!!)
        &lt;ul&gt;
          &lt;li&gt;로컬에 없으면(instance.tf) 없는걸 aws상에 동기화하려하니.. 삭제가 되는꼴&lt;/li&gt;
          &lt;li&gt;기존에 사용중인 인프라 가져오기 참고&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;루비의 terraforming
    &lt;ul&gt;
      &lt;li&gt;AWS 리소스를 tf / tfstate로 임포트 지원
        &lt;ul&gt;
          &lt;li&gt;리소스 타입별로 통째로 임포트&lt;/li&gt;
          &lt;li&gt;모든 리소스 타입을 지원하진 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;임포트 결과가 완벽하지 않음
        &lt;ul&gt;
          &lt;li&gt;테스트 및 수작업으로 보정&lt;/li&gt;
          &lt;li&gt;의존 관계를 표현하지 못함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구조
    &lt;ul&gt;
      &lt;li&gt;서비스 단위로 분리하고, 모듈로 서비스 리소스 분리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로젝트 별 리소스 공유
    &lt;ul&gt;
      &lt;li&gt;거대한 프로젝트를 만들면 서로 리소스를 공유할 수 있음&lt;/li&gt;
      &lt;li&gt;프로젝트간에는 리소스를 직접 공유할 수는 없고, 간접적으론 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;더 궁금하면 &lt;a href=&quot;https://www.44bits.io/ko/post/terraform_introduction_infrastrucute_as_code&quot;&gt;테라폼 기초 튜토리얼&lt;/a&gt; 참고&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://youtu.be/V5zW9MgvRi0&quot;&gt;테라폼 도입기 클라우드 인프라스트럭처 코드로 재정의하기 - 김대권
&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.44bits.io/ko/post/terraform_introduction_infrastrucute_as_code&quot;&gt;테라폼 기초 튜토리얼&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.outsider.ne.kr/1366&quot;&gt;Google Cloud Platform에 Terraform 설정하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 15 Mar 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/development/2019/03/15/terraform/</link>
        <guid isPermaLink="true">https://zzsza.github.io/development/2019/03/15/terraform/</guid>
        
        <category>devops</category>
        
        
        <category>development</category>
        
      </item>
    
      <item>
        <title>크롬 개발자 도구 Console에서 Google Play Review 크롤링하기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Crawling Google Play App Review with Developer Tools&lt;/li&gt;
  &lt;li&gt;개발자 도구를 사용해 Google Play App 리뷰 크롤링하는 과정에 대해 작성한 글입니다(정말 빠르고 쉽게 크롤링하기!)&lt;/li&gt;
  &lt;li&gt;부록으로 Word Cloud 그리는 Colab도 첨부했습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;crawling-google-play-review&quot;&gt;Crawling Google Play Review&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;구글플레이 Review 데이터를 크롤링하는 방법은 많음
    &lt;ul&gt;
      &lt;li&gt;Requests와 BeautifulSoup을 사용하는 방법&lt;/li&gt;
      &lt;li&gt;Selenium을 사용하는 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이런 방법들은 모두 “파이썬 스크립트”를 작성해, 파이썬을 실행해야 함
    &lt;ul&gt;
      &lt;li&gt;스크립트 언어라 간단한 편이지만 그래도 더 간단히 크롤링하는 방법이 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;크롬 개발자 도구를 사용한 구글 플레이 리뷰 데이터 크롤링!&lt;/li&gt;
  &lt;li&gt;이 방법이 적절한 경우 (주관적 생각)
    &lt;ul&gt;
      &lt;li&gt;시간이 없을 경우&lt;/li&gt;
      &lt;li&gt;리뷰 데이터가 생각보다 적은 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;url-확인&quot;&gt;URL 확인&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://play.google.com/store&quot;&gt;Google Play&lt;/a&gt;에 접속한 후, 리뷰를 보고 싶은 앱을 검색
    &lt;ul&gt;
      &lt;li&gt;요새 미세먼지가 너무 심해서, 많이 다운로드될 것 같은 &lt;code class=&quot;highlighter-rouge&quot;&gt;미세미세&lt;/code&gt;를 검색&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;리뷰-확인&quot;&gt;리뷰 확인&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/7bdb69ufwwpq2ia/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-11%2023.56.52.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;리뷰 모두 보기 클릭&lt;/li&gt;
  &lt;li&gt;URL은 &lt;a href=&quot;https://play.google.com/store/apps/details?id=cheehoon.ha.particulateforecaster&amp;amp;showAllReviews=true&quot;&gt;https://play.google.com/store/apps/details?id=cheehoon.ha.particulateforecaster&amp;amp;showAllReviews=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;스크롤-내리기&quot;&gt;스크롤 내리기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;개발자 도구 열고 Console로 이동
    &lt;ul&gt;
      &lt;li&gt;Mac OS에서 단축키는 command + option + i&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;처음엔 리뷰가 모두 보이진 않음&lt;/li&gt;
  &lt;li&gt;리뷰를 계속 내리거나 “더보기” 버튼을 클릭해야 함&lt;/li&gt;
  &lt;li&gt;스페이스를 계속 내리기 위해 아래 코드를 Console에서 실행
    &lt;ul&gt;
      &lt;li&gt;코드 실행하지 않고 스페이스 계속 누르고 더보기 클릭하는 수작업도 나름 빠름&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  window.scrollTo(0, document.body.scrollHeight || document.documentElement.scrollHeight);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;4번 스크롤을 내리면 “더보기” 버튼이 생기는데, 클릭하는 코드&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  document.getElementsByClassName(&quot;RveJvd snByac&quot;)[0].click()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;만약 리뷰가 너무 길 경우 “전체 리뷰” 버튼이 생기는데, 클릭하는 코드 ([0]에서 숫자값을 조절해야 할 수 있음)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  document.getElementsByClassName(&quot;LkLjZd ScJHi OzU4dc  &quot;)[0].click()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;크롤링&quot;&gt;크롤링&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;어느 정도 리뷰를 끝까지 내렸다고 가정하고 Console에서 아래 코드 실행
    &lt;ul&gt;
      &lt;li&gt;참고로 별점이랑 이름, 리뷰 등을 따로 가져올 순 있지만 한방에 HTML로 가져옴&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var reviews = document.querySelectorAll('div[class=&quot;d15Mdf bAhLNe&quot;]')
	
  var data = []
  reviews.forEach(v =&amp;gt; data.push({body: v.outerHTML}))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이제 콘솔에서 data하고 엔터를 치면 아래와 같이 나옴&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  (840) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, …]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;현재 리뷰 840개가 저장되었다는 뜻&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;copy(data)&lt;/code&gt;를 통해 클립보드에 데이터를 저장&lt;/li&gt;
  &lt;li&gt;이제 일단 데이터 크롤링 끝!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;파일-생성&quot;&gt;파일 생성&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;이제 터미널에서 아래 코드 실행&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  vi review.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;수정 모드를 위해 i를 한번 입력한 후, command + v&lt;/li&gt;
  &lt;li&gt;리뷰가 많다면 시간이 꽤 소요될 수 있음. 커피 마시고 오는거 추천&lt;/li&gt;
  &lt;li&gt;다 되었으면 ESC + :wq 로 저장하고 나오기&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;파이썬으로-데이터-전처리&quot;&gt;파이썬으로 데이터 전처리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;이미 크롤링은 끝났지만, 전처리를 쉽게 하고싶은 분들을 위한 부분&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;아래 코드로 데이터 전처리&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import pandas as pd
  df = pd.read_json(&quot;review.json&quot;)
	
  p = re.compile(r'\d+')
  def parser(body):
      bs = BeautifulSoup(body, 'html.parser')
      user_name = bs.find('span', class_='X43Kjb').text
      date = bs.find('span', class_='p2TkOb').text
      rating = bs.find('div', {'role':'img'})['aria-label']
      rating = p.findall(rating)[-1]
      review_text = bs.find('span', {'jsname':'bN97Pc'}).text
      return user_name, date, rating, review_text
	    
  df['user_name'], df['date'], df['rating'], df['review_text'] = zip(*df['body'].map(parser))
  del df[&quot;body&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;이제 user_name, date, rating, review_text를 가지는 데이터프레임이 생성됨&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;아래 코드로 date 처리&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  df['date'] = pd.to_datetime(df['date'], format='%Y년 %m월 %d일')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;rating 개수 그래프 그리기&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import seaborn as sns 
  sns.factorplot('rating',kind='count',data=df)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;word-cloud-그리기&quot;&gt;Word Cloud 그리기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;부록으로 Word Cloud 그린 &lt;a href=&quot;https://colab.research.google.com/drive/1Lr-tdDJFz_Aln-SXcoy4fEn-c8ofR7L4&quot;&gt;Colab&lt;/a&gt; 링크 공유 :)
    &lt;ul&gt;
      &lt;li&gt;전체 코드가 작성되어 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;5점 평점의 Word Cloud
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/dsdt45dtz8uqdvo/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-12%2001.11.19.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2점 이하 평점의 Word Cloud
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/24s12qytd4p59m6/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-03-12%2001.11.47.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;마무리&quot;&gt;마무리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;약간 생소하지만 간단한 개발자 도구를 통해 데이터를 수집해봤습니다!&lt;/li&gt;
  &lt;li&gt;도구는 선택의 문제이니 모두 상황에 맞는 적절한 도구를 찾으면 좋겠습니다!
    &lt;ul&gt;
      &lt;li&gt;개발자 도구로 할 수 있는 일이 더 궁금하신 분들은 &lt;a href=&quot;https://flaviocopes.com/chrome-devtools-tips/&quot;&gt;링크&lt;/a&gt;를 참고해주세요 :)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 12 Mar 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/development/2019/03/12/crawling-in-developer-tools-console/</link>
        <guid isPermaLink="true">https://zzsza.github.io/development/2019/03/12/crawling-in-developer-tools-console/</guid>
        
        <category>web</category>
        
        
        <category>development</category>
        
      </item>
    
      <item>
        <title>Flask에서 Unit Test하기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Flask에서 Unit Test 하는 방법에 대해 작성한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;test&quot;&gt;Test&lt;/h2&gt;
&lt;h3 id=&quot;테스트-자동화의-중요성&quot;&gt;테스트 자동화의 중요성&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;시스템 테스트에서 가장 중요한 것은 테스트의 자동화
    &lt;ul&gt;
      &lt;li&gt;사람이 직접 실행하는 매뉴얼 테스트만 거칠 경우, 사이드 이펙트가 생길 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;테스트를 최대한 자동화해서 테스트가 반복적으로, 자주 실행될 수 있도록 해야하며 항상 정확하게, 빠지는 부분이 없도록 테스트가 실행되도록 하는 것이 굉장히 중요함&lt;/li&gt;
  &lt;li&gt;테스트 방법
    &lt;ul&gt;
      &lt;li&gt;1) UI test / End-to-End test&lt;/li&gt;
      &lt;li&gt;2) integration test&lt;/li&gt;
      &lt;li&gt;3) unit test&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ui-test--end-to-end-test&quot;&gt;UI test / End-To-End test&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;UI Test는 시스템의 UI(User Interface)를 통해서 테스트하는 것&lt;/li&gt;
  &lt;li&gt;웹이라면 웹 브라우저를 통해 웹사이트에 접속하고, UI에 직접 입력하고 클릭하는 등을 통해 기능이 정상적으로 작동하는지 테스트&lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;사용자가 실제로 시스템을 사용하는 방시과 가장 동일하게 테스트&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;시간이 가장 많이 소요되는 테스트&lt;/li&gt;
      &lt;li&gt;프론트엔드 ~ 백엔드까지 모든 시스템을 실행시키고 연결해야 함&lt;/li&gt;
      &lt;li&gt;자동화하기 가장 까다로움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Selenium 같은 UI Test 프레임워크를 사용해 어느정도 자동화가 가능하지만 100% 자동화는 어려움
    &lt;ul&gt;
      &lt;li&gt;특히 화면 렌더링에서 문제가 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점 때문에 전체 테스트 중 대략 10% 정도만 UI test 방식을 통해 실행하는 것을 추천 ( 주로 마지막에 테스트 )&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;integration-test&quot;&gt;Integration test&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;여태까지 미니터 API를 개발하며 해왔던 방식&lt;/li&gt;
  &lt;li&gt;API 서버를 실행시키고 HTTP Request를 실행해 Response가 올바른지 파악&lt;/li&gt;
  &lt;li&gt;테스트하고자 하는 서버를 실제로 실행시키고 테스트 HTTP 요청을 실행해 테스트해보는 방식&lt;/li&gt;
  &lt;li&gt;하나의 시스템만 실행해서 UI test에 비해 테스트 설정이나 실행 시간이 더 짧고 간단&lt;/li&gt;
  &lt;li&gt;하지만 unit test에 비해 자동화에 걸리는 공수가 더 크고 실행 속도도 더 느릴 수 밖에 없음&lt;/li&gt;
  &lt;li&gt;전체 테스트 중 대략 20% 정도만 할당하는 것을 추천&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unit-test&quot;&gt;Unit test&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;시스템을 테스트한다는 개념보다는 코드를 직접 테스트하는 개념
    &lt;ul&gt;
      &lt;li&gt;즉, 코드로 코드를 테스트함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실행하기 쉬우며 실행 속도도 빠름
    &lt;ul&gt;
      &lt;li&gt;디버깅도 비교적 쉬움&lt;/li&gt;
      &lt;li&gt;함수 단위로 테스트해서 파악이 쉬울 수밖에 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점은 함수 단위로 테스트하다보니 전체적인 부분을 테스트하기엔 제한적일 수 밖에 없음
    &lt;ul&gt;
      &lt;li&gt;이런 단점을 integration test와 UI test를 통해 보완&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;전체 테스트의 70%를 unit test&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pytest&quot;&gt;pytest&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;파이썬 내장 라이브러리인 uniitest보다 사용하기 직관적인 pytest를 사용할 예정&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;설치&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pip3 install pytest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;pytest에선 test_라고 되어있는 파일들만 테스트 파일로 인식하고, 함수도 test_라고 prefix가 있어야만 test할 함수로 인식함&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;예시 (test_multiply_by_two.py)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  def multiply_by_two(x):
      return x * 2
		
  def test_multiply_by_two():
      assert multiply_by_two(4) == 7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;터미널에서 pytest를 입력해 실행하면 오류가 발생&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;미니터-api-unit-test&quot;&gt;미니터 API unit test&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;순서
    &lt;ul&gt;
      &lt;li&gt;test_endpoints.py에 unit test 코드 구현&lt;/li&gt;
      &lt;li&gt;테스트용 데이터베이스 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;config.py&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  test_db = {
  'user': 'test',
  'password': '1234',
  'host': 'localhost',
  'port': 3306,
  'database': 'test_db'
  }
	
  test_config = {
      &quot;DB_URL&quot;: f&quot;mysql+mysqlconnector://{test_db['user']}:{test_db['password']}@{test_db['host']}:{test_db['port']}/{test_db['database']}?charset=utf8&quot;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Flask는 unit test에서 엔드포인트들을 테스트할 수 있는 기능을 제공함(test_lcient)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pytest.fixture 데코레이터를 사용하면 같은 이름의 함수의 리턴값을 해당 인자에 넣어줌&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @pytest.fixture
  def api():
      app = create_app(config.test_config)
      app.config['TESTING'] = True
      api = app.test_client()
	
      return api
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;test ping&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  def test_ping(api):
      resp = api.get(&quot;/ping&quot;)
      assert b'pong' in resp.data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;test tweet
    &lt;ul&gt;
      &lt;li&gt;tweet을 생성하기 위해선 사용자가 있어야 함&lt;/li&gt;
      &lt;li&gt;해당 사용자로 인증 절차를 거친 후, access token으로 tweet 엔드포인트를 호출해야 함&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  def test_tweet(api):
      new_user = {
          &quot;email&quot;: &quot;zzsza@naver.com&quot;,
          &quot;passowrd&quot;: &quot;1234&quot;,
          &quot;name&quot;: &quot;변성윤&quot;,
          &quot;profile&quot;: &quot;test profile&quot;
      }
      resp = api.post(
          &quot;/sign-up&quot;,
          data=json.dumps(new_user),
          content_type=&quot;application/json&quot;
      )
  	assert resp.status_code == 200

      # get id fo the new uesr
      resp_json = json.loads(resp.data.decode(&quot;utf-8&quot;))
      new_user_id = resp_json[&quot;id&quot;]
	
      # login
      resp = api.post(
          &quot;/login&quot;,
          data=json.dumps({&quot;email&quot;: &quot;zzsza@naver.com&quot;, &quot;password&quot;: &quot;1234&quot;}),
          content_type=&quot;application/json&quot;
      )
      resp_json = json.loads(resp.data.decode(&quot;utf-8&quot;))
      access_token = resp_json[&quot;access_token&quot;]
	
      # tweet
      resp = api.post(
          &quot;/tweet&quot;,
          data=json.dumps({&quot;tweet&quot;: &quot;Hello World&quot;}),
          content_type=&quot;application/json&quot;,
          headers={&quot;Authorization&quot;: access_token}
      )
      assert resp.status_code == 200
	
      # tweet check
      resp = api.get(f&quot;/timeline/{new_user_id}&quot;)
      tweets = json.loads(resp.data.decode(&quot;utf-8&quot;))
	
      assert resp.status_code == 200
      assert tweets == {
          &quot;user_id&quot;: 1,
          &quot;timeline&quot; : [
              {
                  &quot;user_id&quot;: 1,
                  &quot;tweet&quot;: &quot;Hello World&quot;
              }
          ]
      }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;test에서 사용된 데이터를 테스트 종료 후 삭제해줘야 다른 테스트에 영향을 끼치지 않음
    &lt;ul&gt;
      &lt;li&gt;pytest에선 setup_function과 teardown_function을 사용하면 됨&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  def setup_function():
      ## Create a test user
      hashed_password = bcrypt.hashpw(
          b&quot;test password&quot;,
          bcrypt.gensalt()
      )
      new_users = [
          {
              'id'              : 1,
              'name'            : '변성윤',
              'email'           : 'zzsza@naver.com',
              'profile'         : 'test profile',
              'hashed_password' : hashed_password
          }
      ]
      database.execute(text(&quot;&quot;&quot;
          INSERT INTO users (
              id,
              name,
              email,
              profile,
              hashed_password
          ) VALUES (
              :id,
              :name,
              :email,
              :profile,
              :hashed_password
          )
      &quot;&quot;&quot;), new_users)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  def teardown_function():
      database.execute(text(&quot;SET FOREIGN_KEY_CHECKS=0&quot;))
      database.execute(text(&quot;TRUNCATE users&quot;))
      database.execute(text(&quot;TRUNCATE tweets&quot;))
      database.execute(text(&quot;TRUNCATE users_follow_list&quot;))
      database.execute(text(&quot;SET FOREIGN_KEY_CHECKS=1&quot;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.yes24.com/Product/goods/68713424&quot;&gt;깔끔한 파이썬 탄탄한 백엔드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/development/2019/03/05/unit-test-with-flask/</link>
        <guid isPermaLink="true">https://zzsza.github.io/development/2019/03/05/unit-test-with-flask/</guid>
        
        <category>python</category>
        
        
        <category>development</category>
        
      </item>
    
      <item>
        <title>Flask에 인증(Auth) 붙이는 방법</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Flask에 인증을 붙이는 방법(Flask with auth)를 작성한 글입니다&lt;/li&gt;
  &lt;li&gt;특히 사용자의 비밀번호 암호화에 대해 자세히 알아볼 예정&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;인증&quot;&gt;인증&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;많은 API에서 인증(Authentication)은 공통적으로 구현되는 엔드포인트들 중 하나
    &lt;ul&gt;
      &lt;li&gt;Private한 API나 Public한 API도 기본적 인증을 요구함&lt;/li&gt;
      &lt;li&gt;Private API
        &lt;ul&gt;
          &lt;li&gt;사용할 수 있는 사용자나 클라이언트를 제한&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Public API
        &lt;ul&gt;
          &lt;li&gt;사용자나 클라이언트를 제한하진 않지만 사용 횟수 제한, 남용 방지, 사용자 통계 등의 이유로 인증을 대부분 필요로 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인증은 사용자의 신원을 확인하는 절차로 일반적으로 웹사이트에서 사용자가 로그인해 아이디와 비번을 확인하는 절차를 이야기함
    &lt;ul&gt;
      &lt;li&gt;즉, 로그인 기능을 구현하는 것이 인증 엔드포인트임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;로그인-기능-구현-절차&quot;&gt;로그인 기능 구현 절차&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사용자 가입 절차를 진행해 사용자의 ID, 비밀번호를 생성해야 함&lt;/li&gt;
  &lt;li&gt;가입한 사용자의 ID, 비밀번호를 데이터베이스에 저장하고 사용자의 비밀번호는 암호화해서 저장&lt;/li&gt;
  &lt;li&gt;사용자가 로그인할 때 본인의 ID, 비밀번호를 입력&lt;/li&gt;
  &lt;li&gt;사용자가 입력한 비밀번호를 암화한 후, 암호화되어서 DB에 저장된 비밀번호와 비교&lt;/li&gt;
  &lt;li&gt;비밀번호가 일치하면 로그인 성공&lt;/li&gt;
  &lt;li&gt;로그인에 성공하면 API 서버는 access token을 프론트엔드 혹은 클라이언트에 전송&lt;/li&gt;
  &lt;li&gt;프론트엔드 서버는 로그인 성공 후 해당 사용자의 access token을 첨부해 request를 서버에 전송해 매번 로그인하지 않아도 되도록 함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;사용자-비밀번호-암호화&quot;&gt;사용자 비밀번호 암호화&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사용자의 비밀번호를 암호화해서 저장해야 하는 이유
    &lt;ul&gt;
      &lt;li&gt;1) 외부 해킹 공격에 의해 데이터베이스가 노출되었을 경우를 대비&lt;/li&gt;
      &lt;li&gt;2) 내부 인력에 의해 데이터베이스가 노출되었을 경우에 대비&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자의 비밀번호를 암화할 때는 단방향 해시 함수(one way hash function)가 일반적으로 쓰임
    &lt;ul&gt;
      &lt;li&gt;단방향 해시 함수는 복호화를 할 수 없는 알고리즘&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;단방향 해시 함수 구현&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import hashlib
  m = hashlib.sha256()
  m.update(b&quot;test password&quot;)
  m.hexdigest()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bcrypt-암호-알고리즘&quot;&gt;bcrypt 암호 알고리즘&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;단방향 해시 암호 알고리즘도 충분히 해킹할 수 있음
    &lt;ul&gt;
      &lt;li&gt;대표적으로 rainbow attack&lt;/li&gt;
      &lt;li&gt;미리 해시 값들을 계산해놓은 테이블을 생성하고 해시 함수값을 역추적해서 본래 값을 찾음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이런 해시 함수의 취약점을 보완하기 위해 2가지 방법을 사용
    &lt;ul&gt;
      &lt;li&gt;1) salting
        &lt;ul&gt;
          &lt;li&gt;음식에 간을 맞추기 위해 소금을 더하듯 비밀번호에 추가적으로 랜덤 데이터를 더해 해시 값을 계산&lt;/li&gt;
          &lt;li&gt;기존 비밀번호 + 특정 스트링을 붙이고 해싱 진행&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) key stretching
        &lt;ul&gt;
          &lt;li&gt;단방향 해시 값을 계산하고 또 해시하고, 여러번 반복하는 방법&lt;/li&gt;
          &lt;li&gt;해시 알고리즘의 실행 속도가 너무 빠르기 때문에 이런 방식을 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2가지 방법을 구현한 해시 함수 중 널리 사용되는 것이 bcrypt&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;설치&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pip3 install bcrypt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;암호화&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import bcrypt
  bcrypt.hashpw(b&quot;password&quot;, bcrypt.gensalt())
  bcrypt.hashpw(b&quot;password&quot;, bcrypt.gensalt()).hex()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;access-token&quot;&gt;Access Token&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP는 stateless라 이전에 어떤 HTTP 통신들이 실행됬는지 알지 못함
    &lt;ul&gt;
      &lt;li&gt;이전에 인증되었는지 알지 못하게 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;로그인 정보를 HTTP 요청에 첨부해서 보내야 API 서버에서 로그인된 상태를 처리
    &lt;ul&gt;
      &lt;li&gt;이런 로그인 정보를 담고있는 것이 access token&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;access token을 생성하는 방법
    &lt;ul&gt;
      &lt;li&gt;대표적으로 쓰이는 기술이 JWT(JSON Web Token)&lt;/li&gt;
      &lt;li&gt;JSON 데이터를 token으로 변환하는 방식&lt;/li&gt;
      &lt;li&gt;유저가 로그인 요청하면 API 서버가 인증 확인 후, access token을 떨굼&lt;/li&gt;
      &lt;li&gt;그 토큰을 쿠키 등에 저장했다가 요청할 때 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;가짜 JWT를 전송할 경우 백엔드 API에서 자신이 생성한 JWT인지 아닌지 확인함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jwt-구조&quot;&gt;JWT 구조&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xxxxx.yyyyy.zzzzz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;header : x
    &lt;ul&gt;
      &lt;li&gt;토큰 타입과 사용되는 해시 알고리즘을 지정&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  {
   &quot;alg&quot;: &quot;HS256&quot;,
   &quot;typ&quot;: &quot;JWT&quot;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;payload : y
    &lt;ul&gt;
      &lt;li&gt;JWT를 통해 실제로 서버 간에 전송하고자 하는 데이터&lt;/li&gt;
      &lt;li&gt;HTTP 메세제의 body와 비슷&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;signature : z
    &lt;ul&gt;
      &lt;li&gt;JWT가 원본 그대로라는 것을 확인할 떄 사용되는 부분&lt;/li&gt;
      &lt;li&gt;Base64URL 코드화된 header, payload, JWT Secret을 헤더에 지정된 암호 알고리즘으로 암호화해 전송&lt;/li&gt;
      &lt;li&gt;프론트엔드가 JWT를 백엔드 API로 전송하면 서버에서 JWT signature 부분을 복호화해 서버에서 생성했는지 확인&lt;/li&gt;
      &lt;li&gt;누구나 원본 데이터를 볼 수 있는 부분(Base64URL 코드화)이 라 민감한 데이터는 저장하지 않도록 해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pyjwt&quot;&gt;PyJWT&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;파이썬에서 JWT를 구현할 떄 사용할 수 있는 라이브러리&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;설치&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pip3 install PyJWT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용법&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import jwt
  data_to_encode = {&quot;some&quot;: &quot;payload&quot;}
  encryption_secret = &quot;secrete&quot;
  algorithm = &quot;HS256&quot;
  encoded = jwt.encode(data_to_encode, encryption_secre, algorithm=algorithm)
  jwt.decode(encoded, encryption_secret, algorithms=[algorithm])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;엔드포인트-구현&quot;&gt;엔드포인트 구현&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;/sign-up 수정 : 암호화해서 비밀번호 저장&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @app.route(&quot;/sign-up&quot;, methods=[&quot;POST&quot;])
  def sign_up():
      new_user = request.json
      new_user['password'] = bcrypt.hashpw(new_user['password'].encode('UTF-8'), bcrypt.gensalt())
        
      new_user_id = app.database.execute(text(&quot;&quot;&quot;
          INSERT INTO users (
            name,
            email,
            profile,
            hashed_password
          ) VALUES (
            :name,
            :email,
            :profile,
            :password
          )
      &quot;&quot;&quot;), new_user).lastrowid

      row = app.database.execute(text(&quot;&quot;&quot;
          SELECT
              id,
              name,
              email,
              profile
          FROM users
          WHERE id = :user_id
      &quot;&quot;&quot;), {
          &quot;user_id&quot;: new_user_id
      }).fetchone()

      create_user = {
          &quot;id&quot;: row[&quot;id&quot;],
          &quot;name&quot;: row[&quot;name&quot;],
          &quot;email&quot;: row[&quot;email&quot;],
          &quot;profile&quot;: row[&quot;profile&quot;]
      } if row else None

      return jsonify(create_user)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;인증 엔드포인트 수정&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP Post request에 JSON 데이터로 사용자의 아이디와 비밀번호를 전송받아 데이터베이스에 저장된 사용자의 비밀번호와 동일한지 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @app.route(&quot;/login&quot;, methods=[&quot;POST&quot;])
  def login():
      credential = request.json
      email = credential[&quot;email&quot;]
      password = credential[&quot;password&quot;]

      row = app.database.execute(text(&quot;&quot;&quot;
          SELECT
              id,
              hashed_password
          FROM users
          WHERE email = :email
      &quot;&quot;&quot;), {'email': email}).fetchone()

      if row and bcrypt.checkpw(password.encode(&quot;UTF-8&quot;), row[&quot;hashed_password&quot;].encode(&quot;UTF-8&quot;)):
          user_id = row[&quot;id&quot;]
          payload = {
              &quot;user_id&quot;: user_id,
              &quot;exp&quot;: datetime.utcnow() + timedelta(seconds=60 * 60 * 24)
          }

          token = jwt.encode(payload, app.config[&quot;JWT_SECRET_KEY&quot;], &quot;HS256&quot;)

          return jsonify({
              &quot;access_token&quot; : token.decode(&quot;UTF-8&quot;)
          })
      else:
          return '', 401
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;인증-절차를-다른-엔드포인트에-적용하기&quot;&gt;인증 절차를 다른 엔드포인트에 적용하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;tweet, follow, unfollow 엔드포인트에 인증을 적용&lt;/li&gt;
  &lt;li&gt;공통적인 기능을 필요로 하는 경우 파이썬의 데코레이터를 사용&lt;/li&gt;
  &lt;li&gt;functools의 wraps를 사용해 데코레이터 생성&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;인증 decorator 함수는 전송된 HTTP 요청에서 Authorization 헤더 값을 읽어 JWT access token을 읽고 복호화해서 사용자 아이디를 읽음 =&amp;gt; 로그인 여부 결정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;인증 Decorator 함수&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  def login_required(f):
      @wraps(f)
      def decorated_function(*args, **kwargs):
          access_token = request.headers.get(&quot;Authorization&quot;)
          if access_token is not None:
              try:
                  payload = jwt.decode(access_token, current_app.config[&quot;JWT_SECRET_KEY&quot;], &quot;HS256&quot;)
              except jwt.InvalidTokenError:
                  payload = None
	
              if payload is None:
                  return Response(status=401)
	
              user_id = payload[&quot;user_id&quot;]
              g.user_id = user_id
              g.user = get_user_info(user_id) if user_id else None
          else:
              return Response(status=401)
	
          return f(*args, **kwargs)
      return decorated_function
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;인증 Decorator 적용하기
    &lt;ul&gt;
      &lt;li&gt;def tweet, def follow, def unfollow 위에 아래처럼 명시하면 됨&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @app.route(&quot;/tweet&quot;, methods=[&quot;POST&quot;])
  @login_required
  def tweet():
      ~~~~
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;확인
    &lt;ul&gt;
      &lt;li&gt;이제 먼저 로그인을 해야 함, 로그인하지 않고 아래 request를 날리면 오류 발생&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  http -v POST localhost:5000/tweet tweet=&quot;Hi!&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;액세스 토큰 생성&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  http -v POST localhost:5000/login email=zzsza@naver.com password=1234
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;access_token을 복사한 후 아래와 같이 요청&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  http -v POST localhost:5000/tweet tweet=&quot;Hi!&quot; &quot;Authorization:eyJ0e~~~~~~~~~&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기존엔 tweet할 때 id도 붙여야 했는데, 이젠 인증으로 처리해서 id도 필요 없음. 코드 살짝 수정&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @app.route(&quot;/tweet&quot;, methods=[&quot;POST&quot;])
  @login_required
  def tweet():
      user_tweet = request.json
      user_tweet[&quot;id&quot;] = g.user_id # 이 부분
      tweet = user_tweet[&quot;tweet&quot;]


      if len(tweet) &amp;gt; 300:
          return &quot;300자를 초과했습니다&quot;, 400

      app.database.execute(text(&quot;&quot;&quot;
          INSERT INTO tweets (
            user_id,
            tweet
          ) VALUES (
            :id,
            :tweet
          )
      &quot;&quot;&quot;), user_tweet)

      return &quot;&quot;, 200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.yes24.com/Product/goods/68713424&quot;&gt;깔끔한 파이썬 탄탄한 백엔드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/development/2019/03/04/auth-with-flask/</link>
        <guid isPermaLink="true">https://zzsza.github.io/development/2019/03/04/auth-with-flask/</guid>
        
        <category>web</category>
        
        <category>python</category>
        
        
        <category>development</category>
        
      </item>
    
      <item>
        <title>미니 트위터에 Database 붙이기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zzsza.github.io/development/2019/03/02/mini-twitter-with-flask/&quot;&gt;Python Flask로 미니 트위터 구현하기&lt;/a&gt;에서 구현한 코드를 디벨롭하는 글입니다
    &lt;ul&gt;
      &lt;li&gt;메모리에 데이터를 올렸는데, 이젠 Database를 사용하려고 합니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;데이터베이스&quot;&gt;데이터베이스&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;데이터를 저장 및 보존하는 시스템으로 저장된 데이터를 읽거나 새로운 데이터를 저장, 기존의 데이터를 업데이트할 수 있음&lt;/li&gt;
  &lt;li&gt;관계형 데이터베이스(RDBMS)와 NoSQL로 불리는 비관계형 데이터베이스가 있음&lt;/li&gt;
  &lt;li&gt;관계형 데이터베이스
    &lt;ul&gt;
      &lt;li&gt;데이터들이 서로 상호관련성을 가진 형태로 표현한 데이터&lt;/li&gt;
      &lt;li&gt;대표적으로 MySQL, PostgreSQL&lt;/li&gt;
      &lt;li&gt;모든 데이터들이 2차원 테이블로 표현되고, 컬럼과 로우로 구성됨&lt;/li&gt;
      &lt;li&gt;csv 파일&lt;/li&gt;
      &lt;li&gt;로우는 고유 키(primay key)가 있고, 이 키를 통해 로우를 찾게 됨&lt;/li&gt;
      &lt;li&gt;정규화
        &lt;ul&gt;
          &lt;li&gt;중복을 최소화하도록 데이터를 구조화하는 프로세스&lt;/li&gt;
          &lt;li&gt;여러 테이블에 정보를 나누어 저장하고 테이블끼리 관계를 설정해 연결하는 이유
            &lt;ul&gt;
              &lt;li&gt;데이터의 중복 저장을 피할 수 있음 =&amp;gt; 디스크 공간을 효율적으로 사용&lt;/li&gt;
              &lt;li&gt;잘못된 데이터 저장을 피할 수 있음 =&amp;gt; 중복을 최소화&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;트랜잭션
        &lt;ul&gt;
          &lt;li&gt;일련의 작업들이 하나의 작업처럼 취급되어 모두 다 성공하거나 모두 다 실패하는 것&lt;/li&gt;
          &lt;li&gt;트랜잭션 기능을 위해 ACID 성질을 가짐&lt;/li&gt;
          &lt;li&gt;Atomicity, Concistency, Isolation, Durability (원자성, 일관성, 고립성, 지속성)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비관계형 데이터베이스
    &lt;ul&gt;
      &lt;li&gt;데이터를 미리 정의할 필요가 없음&lt;/li&gt;
      &lt;li&gt;스키마와 테이블 관계를 구현할 필요가 없고, 데이터가 들어오는 그대로 저장&lt;/li&gt;
      &lt;li&gt;MongoDB, Redis, Cassandra 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;rdbms-vs-nosql&quot;&gt;RDBMS vs NoSQL&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;RDBMS의 장점
    &lt;ul&gt;
      &lt;li&gt;데이터를 더 효율적이고 체계적으로 저장, 관리&lt;/li&gt;
      &lt;li&gt;데이터들의 구조를 미리 정의해 데이터의 완전성이 보장&lt;/li&gt;
      &lt;li&gt;트랜잭션 기능을 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RDBMS의 단점
    &lt;ul&gt;
      &lt;li&gt;테이블을 미리 정의해서 테이블 구조 변화 등에 덜 유연&lt;/li&gt;
      &lt;li&gt;확장이 쉽지 않음&lt;/li&gt;
      &lt;li&gt;서버를 늘려서 분산 저장하는 것이 쉽지 않음. 스케일 아웃(서버 수를 늘려서 확장)보단 스케일 업(서버의 성능을 높이는 것)으로 확장해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NoSQL의 장점
    &lt;ul&gt;
      &lt;li&gt;데이터 구조를 미리 정의하지 않아도 되서 데이터 구조 변화에 유연&lt;/li&gt;
      &lt;li&gt;시스템 확장하기가 비교적 쉽다. 스케일 아웃으로 확장 가능&lt;/li&gt;
      &lt;li&gt;유연하고 확장하기 쉬워서 방대한 데이터 저장할 떄 유리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NoSQL의 단점
    &lt;ul&gt;
      &lt;li&gt;데이터의 완전성이 덜 보장&lt;/li&gt;
      &lt;li&gt;트랜잭션이 안되거나 되더라도 비교적 불안정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;맥에서-mysql-설치하기&quot;&gt;맥에서 MySQL 설치하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zzsza.github.io/development/2018/01/18/Install-MySQL-mac/&quot;&gt;맥에서 MySQL 설치하기&lt;/a&gt; 참고&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;스키마-구현하기&quot;&gt;스키마 구현하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;mysql 접속&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DATABASE 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  CREATE DATABASE miniter;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DATABASE 사용&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  USE miniter;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Table 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  CREATE TABLE users(
  id INT NOT NULL AUTO_INCREMENT,
  name VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL,
  hashed_password VARCHAR(255) NOT NULL,
  profile VARCHAR(2000) NOT NULL,
      created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
      PRIMARY KEY (id),
      UNIQUE KEY email (email)
  );
	
  CREATE TABLE users_follow_list(
      user_id INT NOT NULL,
      follow_user_id INT NOT NULL,
      created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
      PRIMARY KEY (user_id, follow_user_id),
      CONSTRAINT users_follow_list_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(id),
      CONSTRAINT users_follow_list_follow_user_id_fkey FOREIGN KEY (follow_user_id) REFERENCES users(id)
  );
	
  CREATE TABLE tweets(
      id INT NOT NULL AUTO_INCREMENT,
      user_id INT NOT NULL,
      tweet VARCHAR(300) NOT NULL,
      created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (id),
      CONSTRAINT tweets_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(id)
  );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Table 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  show tables;
  explain users;
  explain users_follow_list;
  explain tweets;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sqlalchemy를-사용해-연결하기&quot;&gt;SQLAlchemy를 사용해 연결하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;설치&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pip3 install sqlalchemy
  pip3 install mysql-connector-python
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;설정 파일 생성(config.py)
    &lt;ul&gt;
      &lt;li&gt;설정파일을 만드는 이유는 1) 설정 정보를 따로 관리해 민감한 정보를 노출하지 않기 위해 2) 각 환경에 맞는 설정 파일을 적용(local, Staging, Production)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  db = {
  'user'     : 'root',
  'password' : '1234',
  'host'     : 'localhost',
  'port'     : 3306,
  'database' : 'miniter'
  }
	
  DB_URL = f&quot;mysql+mysqlconnector://{db['user']}:{db['password']}@{db['host']}:{db['port']}/{db['database']}?charset=utf8&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Database 연결&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  def create_app(test_config=None):
      app = Flask(__name__)
      if test_config is None:
          app.config.from_pyfile(&quot;config.py&quot;)
      else:
          app.config.update(test_config)
		
      database = create_engine(app.config[&quot;DB_URL&quot;], encoding=&quot;utf-8&quot;, max_overflow=0)
      app.database = database
		
      return app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;CustomJSONEncoder 삭제
    &lt;ul&gt;
      &lt;li&gt;이제 DB로 저장하기 때문에, SET 처리하는 Encoder가 필요없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;회원-가입&quot;&gt;회원 가입&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;기존 코드&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @app.route(&quot;/sign-up&quot;, methods=[&quot;POST&quot;])
  def sign_up():
      new_user = request.json
      new_user[&quot;id&quot;] = app.id_count
      app.users[app.id_count] = new_user
      app.id_count = app.id_count + 1
	
      return jsonify(new_user)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리팩토링&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @app.route(&quot;/sign-up&quot;, methods=[&quot;POST&quot;])
  def sign_up():
      new_user = request.json
      new_user_id = app.database.execute(text(&quot;&quot;&quot;
          INSERT INTO users (
            name,
            email,
            profile,
            hashed_password
          ) VALUES (
            :name,
            :email,
            :profile,
            :password
          )
      &quot;&quot;&quot;), new_user).lastrowid
	
      row = app.database.execute(text(&quot;&quot;&quot;
          SELECT
              id,
              name,
              email,
              profile
          FROM users
          WHERE id = :user_id
      &quot;&quot;&quot;), {
          &quot;user_id&quot;: new_user_id
      }).fetchone()
	    
      create_user = {
          &quot;id&quot;: row[&quot;id&quot;],
          &quot;name&quot;: row[&quot;name&quot;],
          &quot;email&quot;: row[&quot;email&quot;],
          &quot;profile&quot;: row[&quot;profile&quot;]
      } if row else None
	    
      return jsonify(create_user)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;실행할 파일 run.py 생성
    &lt;ul&gt;
      &lt;li&gt;책에는 별도 설명이 나와있지 않음&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from app import create_app
	
  if __name__ == '__main__':
      app = create_app()
      app.run()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;실행&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  python3 run.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http request&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  http -v POST localhost:5000/sign-up name=&quot;변성윤&quot; email=&quot;zzsza@naver.com&quot; password=&quot;1234&quot; profile=&quot;Hi&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tweet&quot;&gt;Tweet&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;저장해야 하는 데이터를 HTTP Request를 통해 받아 데이터베이스에 저장&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기존 코드&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @app.route(&quot;/tweet&quot;, methods=[&quot;POST&quot;])
  def tweet():
      payload = request.json
      user_id = int(payload[&quot;id&quot;])
      tweet = payload[&quot;tweet&quot;]

      if user_id not in app.users:
          return &quot;사용자가 존재하지 않습니다&quot;, 400

      if len(tweet) &amp;gt; 300:
          return &quot;300자를 초과했습니다&quot;, 400

      user_id = int(payload[&quot;id&quot;])

      app.tweets.append({
          &quot;user_id&quot;: user_id,
          &quot;tweet&quot;: tweet
      })

      return &quot;&quot;, 200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리팩토링 코드&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @app.route(&quot;/tweet&quot;, methods=[&quot;POST&quot;])
  def tweet():
      user_tweet = request.json
      tweet = user_tweet[&quot;tweet&quot;]

      if len(tweet) &amp;gt; 300:
          return &quot;300자를 초과했습니다&quot;, 400

      app.database.execute(text(&quot;&quot;&quot;
          INSERT INTO tweets (
            user_id,
            tweet
          ) VALUES (
            :id,
            :tweet
          )
      &quot;&quot;&quot;), user_tweet)

      return &quot;&quot;, 200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP Request&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  http -v POST localhost:5000/tweet id=1 tweet=&quot;First tweet~&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;timeline&quot;&gt;Timeline&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;SELECT 구문을 사용하는 엔드포인트&lt;/li&gt;
  &lt;li&gt;데이터를 읽어 JSON 형태로 변환해 HTTP Response로 보냄&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기존 코드&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @app.route(&quot;/timeline/&amp;lt;int:user_id&amp;gt;&quot;, methods=[&quot;GET&quot;])
  def timeline(user_id):
      if user_id not in app.users:
          return &quot;사용자가 존재하지 않습니다&quot;, 400
	
      follow_list = app.users[user_id].get(&quot;follow&quot;, set())
      follow_list.add(user_id)
      timeline = [tweet for tweet in app.tweets if tweet[&quot;user_id&quot;] in follow_list]
	
      return jsonify({
          &quot;user_id&quot;: user_id,
          &quot;timeline&quot;: timeline
      })
	
  return app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리팩토링 코드&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @app.route(&quot;/timeline/&amp;lt;int:user_id&amp;gt;&quot;, methods=[&quot;GET&quot;])
  def timeline(user_id):
      rows = app.database.execute(text(&quot;&quot;&quot;
          SELECT
              t.user_id,
              t.tweet
          FROM tweets AS t 
          LEFT JOIN users_follow_list AS ufl
          ON ufl.user_id = :user_id
          WHERE t.user_id = :user_id
          OR t.user_id = ufl.follow_user_id
      &quot;&quot;&quot;), {
          &quot;user_id&quot;: user_id
      }).fetchall()

      timeline = [{
          &quot;user_id&quot;: row[&quot;user_id&quot;],
          &quot;tweet&quot;: row[&quot;tweet&quot;]
      } for row in rows]

      return jsonify({
          &quot;user_id&quot;: user_id,
          &quot;timeline&quot;: timeline
      })

  return app

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP Request&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  http -v GET localhost:5000/timeline/1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;follow&quot;&gt;Follow&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;기존 코드&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @app.route(&quot;/follow&quot;, methods=[&quot;POST&quot;])
  def follow():
      payload = request.json
        
      user_id = int(payload[&quot;id&quot;])
      user_id_to_follow = int(payload[&quot;follow&quot;])

      if user_id not in app.users or user_id_to_follow not in app.users:
          return &quot;사용자가 존재하지 않습니다&quot;, 400

      user = app.users[user_id]
      user.setdefault(&quot;follow&quot;, set()).add(user_id_to_follow)

      return jsonify(user)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리팩토링 코드&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @app.route(&quot;/follow&quot;, methods=[&quot;POST&quot;])
  def follow():
      user_follow = request.json

      app.database.execute(text(&quot;&quot;&quot;
          INSERT INTO users_follow_list (
            user_id,
            follow_user_id
          ) VALUES (
            :id,
            :follow
          )
      &quot;&quot;&quot;), user_follow).rowcount

      return &quot;&quot;, 200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP Request&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  http -v POST localhost:5000/follow id=1 follow=3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unfollow&quot;&gt;Unfollow&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;기존 코드&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @app.route(&quot;/unfollow&quot;, methods=[&quot;POST&quot;])
  def unfollow():
      payload = request.json

      user_id = int(payload[&quot;id&quot;])
      user_id_to_follow = int(payload[&quot;unfollow&quot;])

      if user_id not in app.users or user_id_to_follow not in app.users:
          return &quot;사용자가 존재하지 않습니다&quot;, 400

      user = app.users[user_id]
      user.setdefault(&quot;follow&quot;, set()).discard(user_id_to_follow)

      return jsonify(user)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리팩토링 코드&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @app.route(&quot;/unfollow&quot;, methods=[&quot;POST&quot;])
  def unfollow():
      user_unfollow = request.json

      app.database.execute(text(&quot;&quot;&quot;
          DELETE FROM users_follow_list
          WHERE user_id = :id
          AND follow_user_id = :unfollow
      &quot;&quot;&quot;), user_unfollow).rowcount

      return &quot;&quot;, 200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP Request&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  http -v POST localhost:5000/unfollow id=1 unfollow=4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;마무리&quot;&gt;마무리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;추후 리팩토링하면 좋을 것들
    &lt;ul&gt;
      &lt;li&gt;함수화(insert, delete 하는 부분들)&lt;/li&gt;
      &lt;li&gt;ORM 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.yes24.com/Product/goods/68713424&quot;&gt;깔끔한 파이썬 탄탄한 백엔드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/development/2019/03/03/mini-twitter-with-database/</link>
        <guid isPermaLink="true">https://zzsza.github.io/development/2019/03/03/mini-twitter-with-database/</guid>
        
        <category>web</category>
        
        <category>python</category>
        
        
        <category>development</category>
        
      </item>
    
      <item>
        <title>Python Flask로 미니 트위터 구현하기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Flask로 미니 트위터를 구현하는 글입니다
    &lt;ul&gt;
      &lt;li&gt;Database를 사용하지 않고, 인증도 고려하지 않은 첫 버전입니다&lt;/li&gt;
      &lt;li&gt;코드 리팩토링하는 과정을 담은 글은 추후 작성할 예정입니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;미니터-api-시스템&quot;&gt;미니터 API 시스템&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;미니 트위터&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;핵심-기능&quot;&gt;핵심 기능&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;회원가입&lt;/li&gt;
  &lt;li&gt;로그인&lt;/li&gt;
  &lt;li&gt;트윗&lt;/li&gt;
  &lt;li&gt;다른 회원 팔로우&lt;/li&gt;
  &lt;li&gt;다른 회원 언팔로우&lt;/li&gt;
  &lt;li&gt;타임라인&lt;/li&gt;
  &lt;li&gt;단, 동시 접속이나 HTTP 요청 처리 속도를 고려한 구현은 하지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;회원-가입&quot;&gt;회원 가입&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사용자에게 이름, 이메일, 비밀번호 등의 기본 정보를 HTTP 요청을 통해 받은 후 시스템에 저장&lt;/li&gt;
  &lt;li&gt;필요한 정보
    &lt;ul&gt;
      &lt;li&gt;id&lt;/li&gt;
      &lt;li&gt;name&lt;/li&gt;
      &lt;li&gt;email&lt;/li&gt;
      &lt;li&gt;password&lt;/li&gt;
      &lt;li&gt;profile&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from flask import Flask, jsonify, request

app = Flask(__name__)
app.users = {}
app.id_count = 1


@app.route(&quot;/sign-up&quot;, methods=[&quot;POST&quot;])
def sign_up():
    new_user = request.json
    new_user[&quot;id&quot;] = app.id_count
    app.users[app.id_count] = new_user
    app.id_count = app.id_count + 1
    # 실제 구현한다면 atomic_increment operation을 사용해야 함

    return jsonify(new_user)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;아래 코드로 Flask를 실행한 후&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FLASK_ENV=development FLASK_APP=app.py flask run
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;httpie로 요청 보내기&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http -v POST localhost:5000/sign-up name=변성윤 email=zzsza@naver.com password=1234
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;300자-제한-트윗-글-올리기&quot;&gt;300자 제한 트윗 글 올리기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사용자는 300자를 초과하지 않는 글을 올릴 수 있음&lt;/li&gt;
  &lt;li&gt;만일 300자를 초과하면 엔드포인트는 400 Bad Request 응답을 보냄&lt;/li&gt;
  &lt;li&gt;사용자가 300자 이내의 글을 전송하면 엔드포인트는 사용자의 글을 저장해야 함 -&amp;gt; 타임라인 엔드포인트를 통해 읽을 수 있ㅇ므&lt;/li&gt;
  &lt;li&gt;Tweet 호출시 전송하는 JSON 데이터&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;id&quot; : 1,
  &quot;tweet&quot; : &quot;My First Tweet&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;코드&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.tweets = []

@app.route(&quot;/tweet&quot;, methods=[&quot;POST&quot;])
def tweet():
    payload = request.json
    user_id = int(payload[&quot;id&quot;])
    tweet = payload[&quot;tweet&quot;]
    
    if user_id not in app.users:
        return &quot;사용자가 존재하지 않습니다&quot;, 400
        
    if len(tweet) &amp;gt; 300:
        return &quot;300자를 초과했습니다&quot;, 400
        
    user_id = int(payload[&quot;id&quot;])
    
    app.tweets.append({
        &quot;user_id&quot; : user_id,
        &quot;tweet&quot; : tweet
    })

    return &quot;&quot;, 200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위 코드를 app.py에 넣고 아래 코드로 요청!(id=1이 없다면 오류가 발생함, 현재는 메모리에 데이터 적재)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http -v POST localhost:5000/tweet id:=1 tweet=&quot;My First Tweet&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;팔로우와-언팔로우&quot;&gt;팔로우와 언팔로우&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;팔로우 혹은 언팔로우하고 싶은 사용자의 아이디를 HTTP 요청으로 보내면 API에서 요청을 처리&lt;/li&gt;
  &lt;li&gt;팔로우 엔드포인트에 전송할 JSON 데이터는 아래와 같음&lt;/li&gt;
  &lt;li&gt;follow는 팔로우할 사용자의 id&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;id&quot; : 1,
  &quot;follow&quot; : 2
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;unfollow일 경우는 아래와 같음&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;id&quot; : 1,
  &quot;unfollow&quot; : 2
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;follow 코드&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@app.route(&quot;/follow&quot;, methods=[&quot;POST&quot;])
def follow():
    payload = request.json
    user_id = int(payload[&quot;id&quot;])
    user_id_to_follow = int(payload[&quot;follow&quot;])
    
    if user_id not in app.users or user_id_to_follow not in app.users:
        return &quot;사용자가 존재하지 않습니다&quot;, 400
        
    user = app.users[user_id]
    user.setdefault(&quot;follow&quot;, set()).add(user_id_to_follow)
    
    return jsonify(user)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setdefault&lt;/code&gt; : 키가 존재하지 않으면 default 값을 저장하고, 키가 존재하면 해당 값을 읽어들임&lt;/li&gt;
  &lt;li&gt;요청&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http -v POST localhost:5000/follow id:=1 follow:=2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;에러가 발생하는데, 이 이유는 list는 JSON으로 변경할 수 있지만 set으론 변경하지 못하기 때문&lt;/li&gt;
  &lt;li&gt;이 에러를 위해 CustomJSONEncoder를 구현해 덮어씌워야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from flask.json import JSONEncoder

class CustomJSONEncoder(JSONEncoder):
    def default(self, obj):
        if isinstance(obj, set):
            return list(obj)
        return JSONEncoder.default(self, obj)
        
app.json_encoder = CustomJSONEncoder
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;unfollow 코드&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@app.route(&quot;/unfollow&quot;, methods=[&quot;POST&quot;])
def unfollow():
    payload = request.json
    user_id = int(payload[&quot;id&quot;])
    user_id_to_follow = int(payload[&quot;unfollow&quot;])
    
    if user_id not in app.users or user_id_to_follow not in app.users:
        return &quot;사용자가 존재하지 않습니다&quot;, 400
        
    user = app.users[user_id]
    user.setdefault(&quot;follow&quot;, set()).discard(user_id_to_follow)
    
    return jsonify(user)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;discard를 사용한 이유 : 삭제하고자 하는 값이 있으면 삭제하고, 없으면 무시하기 때문&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;타임라인&quot;&gt;타임라인&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;해당 사용자의 트윗들, 팔로우하는 사용자들의 트윗을 리턴&lt;/li&gt;
  &lt;li&gt;데이터 수정 없이 받아오기만 하는 엔드포인트로 HTTP 메소드는 GET&lt;/li&gt;
  &lt;li&gt;리턴하는 JSON 데이터는 아래와 같은 형태&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;user_id&quot; : 1,
    &quot;timeline&quot; : [
      {
        &quot;user_id&quot; : 2,
        &quot;tweet&quot; : &quot;Hello world&quot;
      },
      {
        &quot;user_id&quot; : 1,
        &quot;tweet&quot; : &quot;My first tweet!&quot;
      }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;코드&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@app.route(&quot;/timeline/&amp;lt;int:user_id&amp;gt;&quot;, methods=[&quot;GET&quot;])
def timeline(user_id):
    if user_id not in app.users:
        return &quot;사용자가 존재하지 않습니다&quot;, 400
    
    follow_list = app.users[user_id].get(&quot;follow&quot;, set())
    follow_list.add(user_id)
    timeline = [tweet for tweet in app.tweets if tweet[&quot;user_id&quot;] in follow_list]
    
    return jsonify({
        &quot;user_id&quot; : user_id,
        &quot;timeline&quot; : timeline
    })
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;요청&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http -v GET localhost:5000/timeline/1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;정리&quot;&gt;정리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;전체 코드는 &lt;a href=&quot;https://github.com/zzsza/TIL/blob/master/python/flask/minitier/app.py&quot;&gt;Github&lt;/a&gt; 참고&lt;/li&gt;
  &lt;li&gt;기본적인 뼈대 코드로, 앞으로 계속 리팩토링할 예정
    &lt;ul&gt;
      &lt;li&gt;데이터를 메모리가 아닌 Database에 저장하기&lt;/li&gt;
      &lt;li&gt;인증 붙이기&lt;/li&gt;
      &lt;li&gt;Test Code 추가하기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.yes24.com/Product/goods/68713424&quot;&gt;깔끔한 파이썬 탄탄한 백엔드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 02 Mar 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/development/2019/03/02/mini-twitter-with-flask/</link>
        <guid isPermaLink="true">https://zzsza.github.io/development/2019/03/02/mini-twitter-with-flask/</guid>
        
        <category>web</category>
        
        <category>python</category>
        
        
        <category>development</category>
        
      </item>
    
      <item>
        <title>HTTP의 구조 및 핵심 요소</title>
        <description>&lt;ul&gt;
  &lt;li&gt;HTTP의 구조 및 핵심 요소에 대해 정리한 글입니다&lt;/li&gt;
  &lt;li&gt;깔끔한 파이썬 탄탄한 백엔드 책을 참고했습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;http&quot;&gt;HTTP&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HYPERTEXT TRANSFER PROTOCOL의 약자&lt;/li&gt;
  &lt;li&gt;웹상에서 서로 다른 서버간에 HTML을 서로 주고받을 수 있도록 만들어진 프로토콜, 통신 규약
    &lt;ul&gt;
      &lt;li&gt;웹상에서 네트워크를 통해 통신할 때 어떤 형식으로 통신하자고 규정해놓은 “통신 형식” 혹은 “통신 구조”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로토콜 중 가장 널리 사용되는 프로토콜이 HTTP&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;http-통신-방식&quot;&gt;HTTP 통신 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2가지 특징&lt;/li&gt;
  &lt;li&gt;1) HTTP의 요청(request)과 응답(response) 방식
    &lt;ul&gt;
      &lt;li&gt;요청을 하고 응답을 받는 구조&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @app.route(&quot;/ping&quot;, methods=[&quot;GET&quot;])
  def ping():
      return &quot;pong&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;2) stateless
    &lt;ul&gt;
      &lt;li&gt;각 HTTP 통신은 독립적이며 그 전에 처리된 HTTP 통신에 대해 전혀 알지 못함&lt;/li&gt;
      &lt;li&gt;상태를 저장할 필요가 없으므로 HTTP 통신 간의 진행이나 연결 상태의 처리, 저장을 구현 및 관리하지 않아도 됨&lt;/li&gt;
      &lt;li&gt;그저 요청에 대해 독립적으로 응답만 보내줌&lt;/li&gt;
      &lt;li&gt;단점 : stateless라 HTTP 요청시 필요한 모든 데이터를 매번 포함시켜 보내야 함
        &lt;ul&gt;
          &lt;li&gt;어떤 요청시 사용자가 로그인 되어야 한다고 가정할 때, 해당 사용자 로그인 여부를 포함해 HTTP 요청을 날려야 함&lt;/li&gt;
          &lt;li&gt;이런 점을 해결하기 위해 쿠키(cookie)나 세션(session) 등을 사용해 필요한 진행 과정이나 데이터 저장&lt;/li&gt;
          &lt;li&gt;쿠키 : 웹사이트에서 보내온 정보를 저장할 수 있도록 하는 작은 파일로 웹 브라우저(클라이언트)에 저장&lt;/li&gt;
          &lt;li&gt;세션 : 쿠키와 마찬가지로 HTTP 통신상에 필요한 데이터를 저장하는데, 웹 서버에 데이터 저장&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;http-요청-구조&quot;&gt;HTTP 요청 구조&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP 요청 메세지는 아래와 같은 형태로 되어 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST /payment-sync HTTP/1.1 #1

#2
Aceept: application/json
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: 83
Content-Type: application/json
Host: intropython.com
User-Agent: HTTPie/0.9.3

#3
{
	&quot;imp_uid&quot;: &quot;imp_1234567890&quot;,
	&quot;merchant_uid&quot;: &quot;order_id_8237352&quot;,
	&quot;status&quot;: &quot;paid&quot;
}	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;1 : Start Line&lt;/li&gt;
  &lt;li&gt;2 : Header&lt;/li&gt;
  &lt;li&gt;3 : Body&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;start-line&quot;&gt;Start Line&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP 요청의 시작줄&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;search 엔드포인트에 GET HTTP 요청을 보내면 해당 HTTP 요청의 start line은 아래와 같음&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  GET /search HTTP/1.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;구성 요소
    &lt;ul&gt;
      &lt;li&gt;HTTP 메소드
        &lt;ul&gt;
          &lt;li&gt;HTTP 요청이 의도하는 액션을 정의하는 부분으로 GET, POST, PUT, DELETE 등&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Request target
        &lt;ul&gt;
          &lt;li&gt;해당 HTTP 요청의 목표 주소, 위 예제에선 search 엔드포인트에 보내는 HTTP 요청의 request target은 /search&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;HTTP version
        &lt;ul&gt;
          &lt;li&gt;해당 요청의 HTTP 버전&lt;/li&gt;
          &lt;li&gt;현재 1.0, 1.1, 2.0이 있음&lt;/li&gt;
          &lt;li&gt;버전에 따라 요청 메세지 구조나 데이터가 다를 수 있기 때문에 버전을 명시&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;header&quot;&gt;Header&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP 요청 그 자쳉 대한 정보를 담고 있음
    &lt;ul&gt;
      &lt;li&gt;예를 들어 Request 메세지의 전체 크기(Content-Length) 같은 정보&lt;/li&gt;
      &lt;li&gt;파이썬의 dictionary처럼 key와 value로 되어 있고, :로 연결됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자주 사용되는 헤더
    &lt;ul&gt;
      &lt;li&gt;Host
        &lt;ul&gt;
          &lt;li&gt;요청이 전송되는 target의 호스트 URL 주소&lt;/li&gt;
          &lt;li&gt;Host: google.com&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;User-Agent
        &lt;ul&gt;
          &lt;li&gt;요청을 보내는 클라이언트의 정보, 예를 들면 웹 브라우저&lt;/li&gt;
          &lt;li&gt;User-Agent: Mozila/5.0&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Accept
        &lt;ul&gt;
          &lt;li&gt;해당 요청이 받을 수 있는 response body 데이터 타입&lt;/li&gt;
          &lt;li&gt;MIME(Multipurpose Internet Mail Extensions)  type이 value로 지정
            &lt;ul&gt;
              &lt;li&gt;예 : application/json, text/csv, text/html, image/jpen, application/xml&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Connection
            &lt;ul&gt;
              &lt;li&gt;해당 요청이 끝난 후에 클라이언트와 서버가 계속 네트워크 연결을 유지할지, 끊을지&lt;/li&gt;
              &lt;li&gt;매 요청마다 HTTP 연결을 새로 만드는 것은 시간이 걸리기 때문에 처음 만든 연결을 재사용하는 것을 선호하기도 함&lt;/li&gt;
              &lt;li&gt;keep-alive면 계속해서 요청을 보낼 예정이니 네트워크 연결을 유지&lt;/li&gt;
              &lt;li&gt;close면 네트워크 연결을 닫아도 된다&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Content-Type
            &lt;ul&gt;
              &lt;li&gt;메세지 Body의 타입을 알려주며 Accept 헤더와 마찬가지로 MIME type 사용&lt;/li&gt;
              &lt;li&gt;예 : Content-Type: application/json&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Content-Length
            &lt;ul&gt;
              &lt;li&gt;요청이 보내는 메세지 body의 총 사이즈&lt;/li&gt;
              &lt;li&gt;예 : Content-Length: 257&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;body&quot;&gt;Body&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP 요청이 전송하는 데이터를 담고 있는 부분&lt;/li&gt;
  &lt;li&gt;전송하는 데이터가 없으면 Body는 비어있음&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;http-응답-구조&quot;&gt;HTTP 응답 구조&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;요청 메세지처럼 응답도 크게 3부분으로 구성됨&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#1
HTTP/1.1 404 Not Found

#2
Connection: close
Content-Length: 1573
Content-Type: text/html; charset=UTF-8
Date

#3
&lt;span class=&quot;nt&quot;&gt;&amp;lt;DOCTYPE&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;lang=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;en&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
~~~~~

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;1 : Status Line&lt;/li&gt;
  &lt;li&gt;2 : Headers&lt;/li&gt;
  &lt;li&gt;3 : Body&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;status-line&quot;&gt;Status Line&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP 응답 메세지 상태를 간략히 요약해주는 부분&lt;/li&gt;
  &lt;li&gt;HTTP version, Status Code, Status Text로 나타남&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;header-1&quot;&gt;Header&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP 요청의 헤더와 동일&lt;/li&gt;
  &lt;li&gt;단, HTTP Response시에만 사용되는 헤더가 있음
    &lt;ul&gt;
      &lt;li&gt;HTTP Response엔 User-Agent 헤더 대신 Server 헤더가 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;body-1&quot;&gt;Body&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP 요청 메세지의 body와 동일&lt;/li&gt;
  &lt;li&gt;전송하는 데이터가 없으면 body 부분은 비어있게 됨&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;자주-사용되는-http-메소드&quot;&gt;자주 사용되는 HTTP 메소드&lt;/h2&gt;
&lt;h3 id=&quot;get&quot;&gt;GET&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;어떤 데이터를 서버로부터 요청(GET)할 때 주로 사용&lt;/li&gt;
  &lt;li&gt;데이터의 생성, 수정, 삭제 등의 변경사항 없이 단순히 데이터를 받아오는 경우 사용&lt;/li&gt;
  &lt;li&gt;데이터를 받아올 때 사용되서 HTTP Response의 body가 비어있는 경우가 많음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;post&quot;&gt;POST&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;데이터를 생성하거나 수정, 삭제 요청을 할 때 주로 사용되는 메소드&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;options&quot;&gt;OPTIONS&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;특정 엔드포인트에서 허용하는 메소드들이 무엇이 있는지 알고자 할 경우 사용&lt;/li&gt;
  &lt;li&gt;Flask에선 OPTIONS 메소드를 자동으로 구현해줌&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;api-엔드포인트-아키텍처-패턴&quot;&gt;API 엔드포인트 아키텍처 패턴&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;크게 2가지로 REST 방식과 GraphQL&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;restful-http-api&quot;&gt;RESTful HTTP API&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;API에서 전송하는 리소스(resource)를 URI로 표현하고 해당 리소스에 행하고자 하는 의도를 HTTP 메소드로 정의&lt;/li&gt;
  &lt;li&gt;/users라는 엔드포인트에서 사용자 정보를 받아오는 요청&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP GET /users
GET /users
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;새로운 사용자를 생성하는 엔드포인트는 URI로 /user로 정할 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST /user
{
	&quot;name&quot; : &quot;변성윤&quot;.
	&quot;email&quot; : &quot;zzsza@naver.com&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;자기 설명력 : 엔드포인트의 구조만 봐도 엔드포인트가 제공하는 리소스와 기능을 파악할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;API 구조가 특정 클라이언트에 맞춰져서 다른 클라이언트에서 사용하기엔 적합하지 않음&lt;/li&gt;
      &lt;li&gt;예 : 페이스북 웹용 API가 모바일에선 사용하기 적합하지 않아 새로 만듬&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;graphql&quot;&gt;GraphQL&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;페이스북에서 만듬&lt;/li&gt;
  &lt;li&gt;엔드포인트가 오직 하나고, 엔드ㅗ인트에 클라이언트가 필요한 것을 정의해서 요청하는 식&lt;/li&gt;
  &lt;li&gt;REST 방식과 반대!
    &lt;ul&gt;
      &lt;li&gt;서버가 정의한 틀에서 클라이언트가 요청하는것이 REST식, 클라이언트가 필요한 것을 서버에 요청하는 방식이 GraphQL&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ID가 1인 사용자 정보와 친구들의 이름 정보를 API로 받아올 경우, REST 방식에선 아래와 같이 2번 요청을 보내야 함&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  GET /users/1
  GET /users/1/friends
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;한번으로 줄이려면 아래처럼&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  GET /users/1?include=friends.name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GraphQL을 사용하면 다음과 같이 HTTP 요청&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  POST /graphql
	
  {
   user(id: 1) {
       name
       age
       friends {
         name
       }
     }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;GraphQL은 장점이 많지만 REST에 비해 오래되지 않은 기술이라 널리 사용되고 있진 않음. 백엔드 개발 입문자는 REST API를 먼저 이해하는 것이 더 좋음&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 01 Mar 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/development/2019/03/01/http-structure/</link>
        <guid isPermaLink="true">https://zzsza.github.io/development/2019/03/01/http-structure/</guid>
        
        <category>web</category>
        
        
        <category>development</category>
        
      </item>
    
      <item>
        <title>웹 시스템 아키텍쳐 및 역사 정리</title>
        <description>&lt;ul&gt;
  &lt;li&gt;웹 시스템 아키텍쳐와 웹 시스템의 발전 역사에 대해 정리한 글입니다&lt;/li&gt;
  &lt;li&gt;깔끔한 파이썬 탄탄한 백엔드 책을 참고했습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;웹-시스템의-발전-역사&quot;&gt;웹 시스템의 발전 역사&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;초기의 웹 시스템
    &lt;ul&gt;
      &lt;li&gt;1989년에 팀 버너스 리가 월드와이드웹(WWW)을 발명하고 많은 서비스가 웹을 통해 제공&lt;/li&gt;
      &lt;li&gt;단순하게 문서(text)를 웹 브라우저를 통해 보는 수준&lt;/li&gt;
      &lt;li&gt;웹 서버는 단순히 웹 브라우저가 요청하는 해당 페이지를 보내주는 정도의 기능만 수행
        &lt;ul&gt;
          &lt;li&gt;예 : /new.html 페이지를 요청하면 해당 HTML 페이지를 보내주고, 웹 브라우저는 웹 서버에서 전달받은 HTML 파일을 렌더링해 사용자에게 보여줌&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;간단하다는 장점이 있으나 굉장히 정적임(static)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자바스크립트의 역할 증대
    &lt;ul&gt;
      &lt;li&gt;사용자 인터랙션이 중요해지기 시작하며 자바스크립트의 역할이 커짐&lt;/li&gt;
      &lt;li&gt;자바스크립트는 웹 브라우저에서 실행이 가능한 프로그래밍 언어로 주로 웹상에서 동적인 기능을 제공하기 위해 사용&lt;/li&gt;
      &lt;li&gt;많은 웹사이트들이 자바스크립트를 통해 동적인 기능들을 제공하기 시작&lt;/li&gt;
      &lt;li&gt;전체 페이지를 load하지 않아도 사용자의 input을 동적으로 처리하고 새로운 데이터를 제공할 수 있음&lt;/li&gt;
      &lt;li&gt;초기엔 사용자와 동적인 상호작용 기능을 구현하는 기술이 AJAZ라는 이름으로 알려짐&lt;/li&gt;
      &lt;li&gt;데이터는 XML 구조로 전송되는 것이 일반적인 시대
        &lt;ul&gt;
          &lt;li&gt;XML : 데이터를 전송하기 위한 markup 언어로 구조는 HTML과 비슷하나 데이터를 표현하기 위해 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구별되기 시작하는 프론트엔드와 백엔드
    &lt;ul&gt;
      &lt;li&gt;자바스크립트가 주가 되어서 HTML 생성부터 프론트엔드에 관한 모든 부분을 구현해 웹사이트나 서비스들이 전체적으로 동적이 됨&lt;/li&gt;
      &lt;li&gt;SPA(Single Page Application) 방식의 프론트엔드 개발이 인기를 얻음&lt;/li&gt;
      &lt;li&gt;SPA는 단일 페이지로 모든 웹사이트/서비스의 기능을 구현하는 것으로 메인 자바스크립트가 모든 페이지 및 기능들을 동적으로 구현&lt;/li&gt;
      &lt;li&gt;이젠 웹 브라우저가 필요한 서버와 통신은 데이터 전송이나 생성 및 수정에 대한 것이 대부분이고, 렌더링할 떄 필요한 자바스크립트 코드는 최초 통신에서 1번에 다 받으므로 그 이후엔 서버와 데이터만 주고받으면 됨&lt;/li&gt;
      &lt;li&gt;그러면서 프론트엔드(페이지 렌더링에 필요한 HTML과 자바스크립트 파일을 전송하는 역할)와 백엔드(필요한 데이터 생성 및 전송을 담당)이 더욱 역할이 나뉘게 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;현대-웹-시스템들의-구조-및-아키텍처&quot;&gt;현대 웹 시스템들의 구조 및 아키텍처&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;요새는 웹 시스템의 규모가 더 커지고 처리해야 하는 동시 요청 수와 데이터 규모가 증가함&lt;/li&gt;
  &lt;li&gt;API 시스템이 너무 방대해져서 MSA(Micro Service Architecture) 같은 새로운 개념이 발생되며 API 서버들이 더 세분화되고 규모가 커짐&lt;/li&gt;
  &lt;li&gt;분석해야 하는 데이터의 양이 늘어나며 ETL(Extract, Transfer, Load) 또는 데이터 파이프라인 시스템이 발전함&lt;/li&gt;
  &lt;li&gt;최근엔 ML과 AI 기술이 발전되서 더 방대해지는 중&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/development/2019/02/27/web-system-architecture-and-history/</link>
        <guid isPermaLink="true">https://zzsza.github.io/development/2019/02/27/web-system-architecture-and-history/</guid>
        
        <category>web</category>
        
        
        <category>development</category>
        
      </item>
    
      <item>
        <title>Hash 함수를 사용한 AB Test Sampling</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Hash 함수를 사용한 AB Test Sampling에 대한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ab-test&quot;&gt;AB Test&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;AB Test는 통계적 가설 검정의 한 형태로, 단일 변수에 대한 두 가지 버전을 비교하는 방법
    &lt;ul&gt;
      &lt;li&gt;A와 B는 사용자의 행동에 영향을 미칠 수 있는 하나의 변형을 제외하면 동일&lt;/li&gt;
      &lt;li&gt;Push 메세지를 보낼 때 메세지의 워딩을 다르게 하는 것도 AB Test의 일종으로 볼 수 있고, 웹페이지에서 배너의 위치에 따른 클릭률을 비교하는 것도 AB Test로 볼 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;참고 자료
    &lt;ul&gt;
      &lt;li&gt;강규영님의 &lt;a href=&quot;https://boxnwhis.kr/2015/01/29/a_b_testing.html&quot;&gt;A/B 테스팅이란&lt;/a&gt; : AB 테스팅의 단점 언급
        &lt;ul&gt;
          &lt;li&gt;1) 테스트를 많이 할 경우 단기적으로 손해 발생 가능&lt;/li&gt;
          &lt;li&gt;2) AB Test 결과는 시간의 흐름에 따라 바뀔 수 있음&lt;/li&gt;
          &lt;li&gt;3) AB Test만 해선 Local minima에 머물게 될 위험이 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;박장시님의 &lt;a href=&quot;https://boxnwhis.kr/2016/04/15/dont_be_overwhelmed_by_pvalue.html&quot;&gt;A/B 테스트에서 p-value에 휘둘리지 않기&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;위키피디아 &lt;a href=&quot;https://ko.wikipedia.org/wiki/A/B_%ED%85%8C%EC%8A%A4%ED%8A%B8&quot;&gt;AB 테스트&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;ab-test-sampling&quot;&gt;AB Test Sampling&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;보통 실무에서 AB Test를 할 경우 user_id를 가지고 하곤 함
    &lt;ul&gt;
      &lt;li&gt;예 : 1의 자리가 홀수인 그룹 A, 1의 자리가 짝수인 그룹 B
        &lt;ul&gt;
          &lt;li&gt;단, 그룹을 나누기 전에 사용자들의 분포를 확인해야 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이런 방법은 실험이 많지 않을 경우엔 유용할 수 있지만, 다른 실험을 또 설계할 경우에 이슈가 발생
    &lt;ul&gt;
      &lt;li&gt;예 : 그럼 이번엔 10의 자리가 홀수인 그룹을 A, 10의 자리가 짝수인 그룹을 B!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이렇게 계속 만들다 보면 어느덧 user_id의 자리수를 모두 채우고, 점점 조건이 애매할 수 있음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;그래서 생각한 방법이 Hash 함수를 사용해 user_id를 숫자로 만들고, 해당 숫자를 어떤 기준점 기준으로 A와 B로 나누는 방법&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;hash-함수&quot;&gt;Hash 함수&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;해시 함수는 특정 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수&lt;/li&gt;
  &lt;li&gt;암호학적 해시 함수와 비암호학적 해시함수로 구분
    &lt;ul&gt;
      &lt;li&gt;암호학적 해시 함수 : MD5, SHA계열&lt;/li&gt;
      &lt;li&gt;비암호학적 해시 함수 : CRC32&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Salt
    &lt;ul&gt;
      &lt;li&gt;솔트는 단방향 해시 함수에서 추가하는 임의의 문자열로, 원본 메세지(여기선 user_id) 뒤에 문자 열을 추가함&lt;/li&gt;
      &lt;li&gt;실험의 관리성을 위해 실험의 이름을 솔트로 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이런 함수를 사용할 때, 백엔드쪽과 분석쪽에서 같은 결과가 나는지 꼭 확인해야 함
    &lt;ul&gt;
      &lt;li&gt;백엔드에서 user_id -&amp;gt; hash -&amp;gt; A/B에 따라 다른 API&lt;/li&gt;
      &lt;li&gt;데이터가 쌓인 곳에서 user_id -&amp;gt; hash -&amp;gt; A/B로 파악&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Hash 함수를 사용하면 균일하게 나눠질 것이라고 생각&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;코드&quot;&gt;코드&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;파이썬에서 user_id를 Hash하는 코드
    &lt;ul&gt;
      &lt;li&gt;sha1을 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  def hash_user_id(user_id, salt, ratio_threshold):
      &quot;&quot;&quot;
      user_id(int) : user_id
      salt(str) : salt 문자열
      ratio_threshold(float) : 기준 ratio. 예 : 0.5
      &quot;&quot;&quot;
      id_and_salt = user_id + salt
		
      h = hashlib.sha1()
      h.update(id_and_salt.encode('utf-8'))
		
      res_hash = h.hexdigest()
      total = pow(16, len(res_hash))
      hash_to_int = int(res_hash, 16)
      ratio = hash_to_int / total

      if ratio &amp;gt;= ratio_threshold:
          return 'A'
      else:
          return 'B'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;SQL에서 필요할 경우, 대부분 Hash 함수를 지원하기 때문에 쉽게 user_id를 Hash할 수 있음(없다면 UDF 만들어서 사용)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;salt-설정&quot;&gt;Salt 설정&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;AB Test마다 일정한 규칙 안에서 salt를 설정
    &lt;ul&gt;
      &lt;li&gt;예: 날짜-이름의 규칙을 가진다고 하면 20190223-test 이런 형식&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그리고 특정 문서에 꾸준히 기록!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;강규영님의 &lt;a href=&quot;https://boxnwhis.kr/2014/12/13/Hash-based_sampling.html&quot;&gt;해시 기반 샘플링&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/simpl-under-the-hood/deterministic-a-b-tests-via-the-hashing-trick-d1ea49483202&quot;&gt;Deterministic A/B tests via the hashing trick&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;김재석님의 &lt;a href=&quot;https://spoqa.github.io/2012/05/15/ab-testing-basic.html&quot;&gt;A/B Testing에 대한 기초적인 정보들&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;버즈빌의 &lt;a href=&quot;https://www.buzzvil.com/ko/2018/06/14/tech-industry-a-b-testing-sampling%EB%B6%80%ED%84%B0-interpretation%EA%B9%8C%EC%A7%80/&quot;&gt;Sampling부터 Interpretation까지&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/data/2019/02/23/ab-test-sampling-with-hash-function/</link>
        <guid isPermaLink="true">https://zzsza.github.io/data/2019/02/23/ab-test-sampling-with-hash-function/</guid>
        
        <category>analytics</category>
        
        
        <category>data</category>
        
      </item>
    
      <item>
        <title>시계열 예측을 위한 Facebook Prophet 사용하기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;페이스북이 만든 시계열 예측 라이브러리 Prophet 사용법에 대해 작성한 글입니다
    &lt;ul&gt;
      &lt;li&gt;Prophet은 Python, R로 사용할 수 있는데, 본 글에선 Python로 활용하는 방법에 대해서만 다룹니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;prophet&quot;&gt;Prophet&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;페이스북이 만든 시계열 예측 라이브러리
    &lt;ul&gt;
      &lt;li&gt;통계적 지식이 없어도 직관적 파라미터를 통해 모형을 조정할 수 있음&lt;/li&gt;
      &lt;li&gt;일반적인 경우 기본값만 사용해도 높은 성능을 보여줌&lt;/li&gt;
      &lt;li&gt;내부가 어떻게 동작하는지 고민할 필요가 없음
        &lt;ul&gt;
          &lt;li&gt;(개인 의견) 사실 이게 개인으로선 아쉬운 점.. 내부 알고리즘을 공개하진 않고 Linear Model이다! 정도만 알려줌&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Python, R로 사용 가능&lt;/li&gt;
      &lt;li&gt;현재 Version 0.4(2018.12.18)로 아직 1점대 미만이라 언제든 API가 변경되도 이상하지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;관련 자료
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://facebook.github.io/prophet/&quot;&gt;공식 홈페이지&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://peerj.com/preprints/3190.pdf&quot;&gt;Prophet 논문&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;영어라 읽기 힘들다면 &lt;a href=&quot;https://gorakgarak.tistory.com/1255&quot;&gt;모든이들을 위한 FACEBOOK PROPHET PAPER 쉬운 요약정리&lt;/a&gt; 참고하면 좋을 것 같음!&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;설치&quot;&gt;설치&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip3 install fbprophet
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;prophet-구성-요소&quot;&gt;Prophet 구성 요소&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Growth, Seasonality, Holidays&lt;/li&gt;
  &lt;li&gt;
    &lt;pre class=&quot;MathJax_Preview&quot;&gt;&lt;code&gt;y(t)=g(t)+s(t)+h(t)+error&lt;/code&gt;&lt;/pre&gt;
    &lt;script type=&quot;math/tex; mode=display&quot;&gt;y(t)=g(t)+s(t)+h(t)+error&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;ARIMA 같은 시계열 모델은 시간에 종속적인 구조를 가지는 반면 Prophet은 종속적이지 않고 Curve Fitting으로 문제를 해결
    &lt;ul&gt;
      &lt;li&gt;학습 속도가 빠르고, 빈 구간을 interpolate하지 않아도 됨&lt;/li&gt;
      &lt;li&gt;직관적으로 이해할 수 있는 파라미터를 통해 모형을 쉽게 조정 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;growth&quot;&gt;Growth&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Linear Growth(+Change Point)
    &lt;ul&gt;
      &lt;li&gt;Change Point는 자동으로 탐지&lt;/li&gt;
      &lt;li&gt;예측할 때는 특정 지점이 change point인지 여부를 확률적으로 결정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Non-Linear Growth(Logistic Growth)
    &lt;ul&gt;
      &lt;li&gt;자연적 상한성이 존재하는 경우, Capacity가 있음&lt;/li&gt;
      &lt;li&gt;Capacity는 시간에 따라 변할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;seasonality&quot;&gt;Seasonality&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사용자들의 행동 양식으로 주기적으로 나타나는 패턴
    &lt;ul&gt;
      &lt;li&gt;방학, 휴가, 온도, 주말 등등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;푸리에 급수(Fourier Series)를 이용해 패턴의 근사치를 찾음
    &lt;ul&gt;
      &lt;li&gt;공돌이의 수학정리노트, &lt;a href=&quot;https://wikidocs.net/4026&quot;&gt;CT Fourier Series&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;나무위키 &lt;a href=&quot;https://namu.wiki/w/%ED%91%B8%EB%A6%AC%EC%97%90%20%ED%95%B4%EC%84%9D&quot;&gt;푸리에 해석&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;holidays&quot;&gt;Holidays&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;주기성을 가지진 않지만 전체 추이에 큰 영향을 주는 이벤트가 존재&lt;/li&gt;
  &lt;li&gt;이벤트의 효과는 독립적이라 가정&lt;/li&gt;
  &lt;li&gt;이벤트 앞뒤로 window 범위를 지정해 해당 이벤트가 미치는 영향의 범위를 설정할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;model-fitting&quot;&gt;Model Fitting&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Stan을 통해 모델을 학습
    &lt;ul&gt;
      &lt;li&gt;probabilistic programming language for statistical inference&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2가지 방식
    &lt;ul&gt;
      &lt;li&gt;MAP (Maximuam A Posteriori) : Default, 속도가 빠름&lt;/li&gt;
      &lt;li&gt;MCMC (Markov Chain Monte Carlo) : 모형의 변동성을 더 자세히 살펴볼 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Analyst in the loop Modeling
    &lt;ul&gt;
      &lt;li&gt;통계적 지식이 없어도 직관적 파라미터를 통해 모형을 조정할 수 있음&lt;/li&gt;
      &lt;li&gt;일반적인 경우 기본값만 사용해도 높은 성능을 가능&lt;/li&gt;
      &lt;li&gt;내부가 어떻게 동작하는지 고민할 필요가 없음&lt;/li&gt;
      &lt;li&gt;요소
        &lt;ul&gt;
          &lt;li&gt;Capacities : 시계열 데이터 전체의 최대값&lt;/li&gt;
          &lt;li&gt;Change Points : 추세가 변화하는 시점&lt;/li&gt;
          &lt;li&gt;Holidays &amp;amp; Seasonality : 추세에 영향을 미치는 시기적 요인&lt;/li&gt;
          &lt;li&gt;Smoothing : 각각의 요소들이 전체 추이에 미치는 영향의 정도&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;prophet-사용법&quot;&gt;Prophet 사용법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;1) 데이터를 Prophet에 맞도록 가공
    &lt;ul&gt;
      &lt;li&gt;필요한 컬럼은 &lt;strong&gt;ds&lt;/strong&gt;, &lt;strong&gt;y&lt;/strong&gt; 2개!(컬럼 이름을 맞춰야함)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from fbprophet import Prophet
import pandas as pd
  df = pd.read_csv(&quot;./data/example_wp_log_peyton_manning.csv&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;예측값의 상한과 하한을 제어해야 하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;cap&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;floor&lt;/code&gt; 컬럼에 값 지정&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  df['cap'] = 6
  df['floor'] = 1.5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;2) Prophet 객체 생성하고 Fit
    &lt;ul&gt;
      &lt;li&gt;Prophet 객체는 1번만 Fit 할 수 있음. 만약 여러번 Fit 하고 싶으면 새로운 객체를 생성해야 함&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  m = Prophet() # Default growth='linear'
  m.fit(df)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;상한과 하한을 설정할 경우엔 Prophet 객체를 생성할 때 growth=’logistic’ 추가&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  m = Prophet(growth='logistic')
  m.fit(df)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3) 미래 Dataframe 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  future = m.make_future_dataframe(periods=365)
  future.tail()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;1)에서 예측값의 상한이나 하한을 설정했으면 동일하게 지정&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  future['cap'] = 6
  future['floor'] = 1.5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;4) 예측&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  forecast = m.predict(future)
  forecast.tail()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;5) forecast 결과 확인
    &lt;ul&gt;
      &lt;li&gt;yhat_lower, yhat_upper 같이 범위로 제공&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  forecase.tail()
  forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(60)
	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;6) 시각화
    &lt;ul&gt;
      &lt;li&gt;forecast 시각화&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  fig1 = m.plot(forecast)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://facebook.github.io/prophet/static/saturating_forecasts_files/saturating_forecasts_16_0.png&quot; /&gt;
        &lt;ul&gt;
          &lt;li&gt;점선들이 하한선과 상한선&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;forecast component 시각화(Trend, Weakly, Yearly)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  fig2 = m.plot_components(forecast)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://facebook.github.io/prophet/static/quick_start_files/quick_start_14_0.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;trend-change-points&quot;&gt;Trend Change Points&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Prophet에선 기본적으로 트렌드가 변경되는 지점을 자동으로 감지해 트렌드를 예측함
    &lt;ul&gt;
      &lt;li&gt;감지하는 것을 사용자가 조절할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Prophet 객체를 생성할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;changepoint_range&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;changepoint_prior_scale&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;changepoints&lt;/code&gt;을 조절
    &lt;ul&gt;
      &lt;li&gt;1) &lt;strong&gt;changepoint_range&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;기본적으로 Prophet은 시계열 데이터의 80% 크기에서 잠재적으로 ChangePoint를 지정&lt;/li&gt;
          &lt;li&gt;90%만큼 ChangePoint로 지정하고 싶다면 아래와 같이 설정&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  m = Prophet(changepoint_range=0.9)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;2) &lt;strong&gt;changepoint_prior_scale&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Change Point의 유연성을 조정하는 방법&lt;/li&gt;
          &lt;li&gt;오버피팅이 심하면 너무 유연한 그래프가 나와서 모든 값에 근접하고, 언더피팅일 경우 유연성이 부족&lt;/li&gt;
          &lt;li&gt;기본 값은 0.05&lt;/li&gt;
          &lt;li&gt;이 값을 늘리면 그래프가 유연해지고(=언더피팅 해결), 이 값을 줄이면 유연성이 감소(=오버피팅 해결)&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  m = Prophet(changepoint_prior_scale=0.05)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;3) &lt;strong&gt;changepoints&lt;/strong&gt;(list)
        &lt;ul&gt;
          &lt;li&gt;잠재적으로 change point일 수 있는 날짜들&lt;/li&gt;
          &lt;li&gt;명시하지 않으면 잠재적인 changepoint가 자동으로 설정됨&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  m = Prophet(changepoints=['2019-02-04'. '2019-02-05'])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;시각화&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from fbprophet.plot import add_changepoints_to_plot

  fig = m.plot(forecast)
  a = add.changepoints_to_plot(fig.gca(), m, forecast)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;빨간 점선 : ChangePoint&lt;/li&gt;
      &lt;li&gt;빨간 실선 : Trend&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://facebook.github.io/prophet/static/trend_changepoints_files/trend_changepoints_9_0.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;seasonality-holiday-effects-and-regressors&quot;&gt;Seasonality, Holiday Effects, And Regressors&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Modeling Holidays and Special Events
    &lt;ul&gt;
      &lt;li&gt;휴일이나 모델에 반영하고 싶은 이벤트가 있으면 Dataframe을 생성해 반영할 수 있음&lt;/li&gt;
      &lt;li&gt;이벤트는 과거 데이터와 미래 데이터가 모두 포함되어 있어야 함&lt;/li&gt;
      &lt;li&gt;주변 날짜를 포함시키기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;lower_window&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;upper_window&lt;/code&gt;를 사용해 업데이트의 영향을 조절 가능&lt;/li&gt;
      &lt;li&gt;예제는 Play Off 경기일과 SUperbowl 경기날을 Holiday로 설정&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  playoffs = pd.DataFrame({
'holiday': 'playoff',
'ds': pd.to_datetime(['2008-01-13', '2009-01-03', '2010-01-16',
                      '2010-01-24', '2010-02-07', '2011-01-08',
                      '2013-01-12', '2014-01-12', '2014-01-19',
                      '2014-02-02', '2015-01-11', '2016-01-17',
                      '2016-01-24', '2016-02-07']),
'lower_window': 0,
'upper_window': 1,
})
  superbowls = pd.DataFrame({
    'holiday': 'superbowl',
    'ds': pd.to_datetime(['2010-02-07', '2014-02-02', '2016-02-07']),
    'lower_window': 0,
    'upper_window': 1,
  })
  holidays = pd.concat((playoffs, superbowls))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;사용하는 방법은 간단, Prophet 객체를 생성할 때 holidays 인자로 넘기면 됨&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  m = Prophet(holidays=holidays)
  forecast = m.fit(df).predict(future)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;holiday effect를 아래 코드로 확인할 수 있음&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  forecast[(forecast['playoff'] + forecast['superbowl']).abs() &amp;gt; 0][
      ['ds', 'playoff', 'superbowl']][-10:]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;plot_component로 시각화할 경우 holidays의 영향도 볼 수 있음&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  fig = m.plot_components(forecast)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://facebook.github.io/prophet/static/seasonality,_holiday_effects,_and_regressors_files/seasonality,_holiday_effects,_and_regressors_13_0.png&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;만약 holidays에 오버피팅된 것 같으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;holidays_prior_scale&lt;/code&gt;을 조정해 smooth하게 변경 가능(기본값은 10)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  m = Prophet(holidays=holidays, holidays_prior_scale=0.05).fit(df)
  forecast = m.predict(future)
  forecast[(forecast['playoff'] + forecast['superbowl']).abs() &amp;gt; 0][
      ['ds', 'playoff', 'superbowl']][-10:]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Built-in Country Holidays
    &lt;ul&gt;
      &lt;li&gt;Prophet 객체를 생성한 후, m.add_country_holidays(country_name=’US’) 이렇게 작성하면 국가의 휴일을 사용할 수 있음&lt;/li&gt;
      &lt;li&gt;그러나 한국은 없음&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/facebook/prophet/blob/master/python/fbprophet/hdays.py&quot;&gt;Github&lt;/a&gt; 참고해서 만들어도 될 듯, 혹은 커스텀 이벤트를 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Fourier Order for Seasonalities
    &lt;ul&gt;
      &lt;li&gt;Seasonalities를 부분 푸리에의 합을 사용해 추정&lt;/li&gt;
      &lt;li&gt;이 부분은 논문에 자세히 나오고, &lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_series&quot;&gt;위키피디아&lt;/a&gt;도 참고하면 좋음&lt;/li&gt;
      &lt;li&gt;푸리에 급수는 주기함수를 삼각함수의 급수로 나타낸 것&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yearly_seasonality&lt;/code&gt; 파라미터의 default는 10
        &lt;ul&gt;
          &lt;li&gt;만약 시즈널리티가 자주 발생한다고 생각하면 이 값을 20으로 수정하면 됨. 단, 오버피팅 조심!&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from fbprophet.plot import plot_yearly
  m = Prophet(yearly_seasonality=10).fit(df)
  a = plot_yearly(m)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://facebook.github.io/prophet/static/seasonality,_holiday_effects,_and_regressors_files/seasonality,_holiday_effects,_and_regressors_26_0.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Specifying Custom Seasonalities
    &lt;ul&gt;
      &lt;li&gt;커스텀 시즈널리티를 생성할 수 있음&lt;/li&gt;
      &lt;li&gt;기본적으로 weekly, yearly 특성 제공&lt;/li&gt;
      &lt;li&gt;m.add_seasonality로 추가하며 인자는 name, period, fourier_order가 있음&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  m = Prophet(weekly_seasonality=False)
  m.add_seasonality(name='monthly', period=30.5, fourier_order=5)
  forecast = m.fit(df).predict(future)
  fig = m.plot_components(forecast)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://facebook.github.io/prophet/static/seasonality,_holiday_effects,_and_regressors_files/seasonality,_holiday_effects,_and_regressors_32_0.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;prior_scale&lt;/code&gt;을 조절해 강도를 조절할 수 있음&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Additional regressors
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;add_regressor&lt;/code&gt; 메소드를 사용해 모델의 linear 부분에 추가할 수 있음&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;예제에선 NFL 시즌의 일요일에 추가 효과를 더함&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  def nfl_sunday(ds):
      date = pd.to_datetime(ds)
      if date.weekday() == 6 and (date.month &amp;gt; 8 or date.month &amp;lt; 2):
          return 1
      else:
          return 0
			    
  df['nfl_sunday'] = df['ds'].apply(nfl_sunday)
		
  m = Prophet()
  m.add_regressor('nfl_sunday')
  m.fit(df)
		
  future['nfl_sunday'] = future['ds'].apply(nfl_sunday)
		
  forecast = m.predict(future)
  fig = m.plot_components(forecast)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://facebook.github.io/prophet/static/seasonality,_holiday_effects,_and_regressors_files/seasonality,_holiday_effects,_and_regressors_41_0.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;multiplicative-seasonality&quot;&gt;Multiplicative Seasonality&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;단순한 seasonality가 아닌 점점 증가하는 seasonlity를 다룰 때 사용하면 좋은 기능&lt;/li&gt;
  &lt;li&gt;데이터가 엄청 많을 경우 유용할 듯&lt;/li&gt;
  &lt;li&gt;사용하는 방법은 매우 단순. seasonality_mode의 인자로 multiplicative 지정&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;m = Prophet(seasonality_mode='multiplicative')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;uncertainty-intervals&quot;&gt;Uncertainty Intervals&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;불확실성의 범위가 나타나는 원인
    &lt;ul&gt;
      &lt;li&gt;1) Trend의 불확실성&lt;/li&gt;
      &lt;li&gt;2) Seasonality 추정의 불확실설&lt;/li&gt;
      &lt;li&gt;3) 추가 관찰되는 잡음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Uncertainty in the trend
    &lt;ul&gt;
      &lt;li&gt;예측을 하면 yhat_lower, yhat_upper가 나타나는데 이 범위도 사용자가 조절할 수 있음&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;interval_width&lt;/code&gt;의 기본 값은 80%&lt;/li&gt;
      &lt;li&gt;changepoint_prior_scale을 조절하면 예측 불확실성이 증가함&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  forecast = Prophet(interval_width=0.95).fit(df).predict(future)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Uncertainty in seasonality
    &lt;ul&gt;
      &lt;li&gt;시즈널리티의 불확실성을 알기 위해 베이지안 샘플링을 사용해야 함&lt;/li&gt;
      &lt;li&gt;mcmc.samples 파라미터를 사용. 이 값을 사용하면 최초 n일에 대해 적용한다는 뜻&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  m = Prophet(mcmc_samples=300)
  forecast = m.fit(df).predict(future)
  fig = m.plot_components(forecast)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://facebook.github.io/prophet/static/uncertainty_intervals_files/uncertainty_intervals_10_0.png&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;이제 불확실성의 범위가 보임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;outliers&quot;&gt;Outliers&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;img src=&quot;https://facebook.github.io/prophet/static/outliers_files/outliers_4_0.png&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;위와 같은 예측 그래프를 보면, 2016년부터 Uncertainty Intervals이 너무 큼&lt;/li&gt;
  &lt;li&gt;너무 튀는 값이 존재해서 예측할 때 영향이 미침
    &lt;ul&gt;
      &lt;li&gt;이런 값들은 제외하고 예측해야 함
        &lt;ul&gt;
          &lt;li&gt;NA, None로 설정&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;또는 상한선, 하한선 설정&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'ds'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'2010-01-01'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'ds'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'2011-01-01'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'y'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Prophet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;fig&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;plot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;predict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;sub-daily-data&quot;&gt;Sub-daily Data&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;여태까지 사례는 모두 Daily 데이터였는데, 더 짧은 단위도 예측할 수 있음
    &lt;ul&gt;
      &lt;li&gt;Timestamp로 YYYY-MM-DD HH:MM:SS 형태로 저장&lt;/li&gt;
      &lt;li&gt;사실 데이터 형태만 다른거고 여태와 동일함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data with regular gaps
    &lt;ul&gt;
      &lt;li&gt;정기적인 gap이 있는 데이터도 예측할 수 있음&lt;/li&gt;
      &lt;li&gt;매달 1일의 데이터만 있어도 월별로 예측 가능(부정확성이 더 늘겠지만!)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;기타&quot;&gt;기타&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;공식 문서는 Tutorial정도로만 충실하고, 추가되는 API에 대한 설명이 없음(=소스코드 까서 직접..)
    &lt;ul&gt;
      &lt;li&gt;fbprophet의 diagnostics.py엔 아래 기능이 구현되어 있음
        &lt;ul&gt;
          &lt;li&gt;cross_validation&lt;/li&gt;
          &lt;li&gt;performance_metrics
            &lt;ul&gt;
              &lt;li&gt;mse, rmse, mae, mape, coverage&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;깔끔하고 간단하게 짜여있으니 참고해도 좋을듯&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;plot.py엔 아래 기능이 구현되어 있음
        &lt;ul&gt;
          &lt;li&gt;plot_yearly, plot_weekly, plot_seasonality, plot_cross_validation_metric 등&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;마무리&quot;&gt;마무리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;시계열 분석에 대해 잘 알지는 못하지만, 예측을 해야될 경우 사용하면 좋은 라이브러리입니다&lt;/li&gt;
  &lt;li&gt;다른 방식의 접근(예를 들면 카테고리컬로 regression)과 동시에 진행하고 Stacking해도 좋을 것 같아요!&lt;/li&gt;
  &lt;li&gt;구현된 코드는 시계열 예측할 때 자주 사용될 코드들이 있어서 구현 코드를 파악해도 좋을 것 같아요!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;참고-코드&quot;&gt;참고 코드&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;fengyin123의 &lt;a href=&quot;https://github.com/fengyin123/traffic/blob/5307a79c633f109e953a851de46815a0f6fbde68/src/fbprophet.ipynb&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;AidanCooper의 &lt;a href=&quot;https://github.com/AidanCooper/Kaggle/blob/969e45ceb265135d7b78c77376478c31870acbd2/StoreItemDemand/Prophet.ipynb&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;harshitssj4의 &lt;a href=&quot;https://github.com/harshitssj4/ZS-Young-Data-Scientist-Challenge-2018/blob/34de2c46cfef96062d175929ef7404b3d58e10a8/Final_model.ipynb&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;2017년 은(Silver) 가격 Backtesting한 &lt;a href=&quot;https://github.com/Lougarou/backtestfbprophet&quot;&gt;Github&lt;/a&gt;	
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://facebook.github.io/prophet/docs/quick_start.html&quot;&gt;공식 홈페이지&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;이민호님의 &lt;a href=&quot;https://www.slideshare.net/lumiamitie/facebook-prophet&quot;&gt;Slideshare&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 06 Feb 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/data/2019/02/06/prophet/</link>
        <guid isPermaLink="true">https://zzsza.github.io/data/2019/02/06/prophet/</guid>
        
        <category>time-series</category>
        
        
        <category>data</category>
        
      </item>
    
      <item>
        <title>Kubernetes StatefulSet를 사용해 MongoDB 실행하기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;2019 클라우드 스터디 잼 입문반에서 진행하는 Kubernetes in the Google Cloud 퀵랩을 듣고 정리한 내용입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;basic&quot;&gt;Basic&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Stateless Application의 특징
    &lt;ul&gt;
      &lt;li&gt;디스크에 중요한 데이터가 없음&lt;/li&gt;
      &lt;li&gt;필요한 만큼 여러 똑같은 컨테이너를 시작, 종료할 수 있음&lt;/li&gt;
      &lt;li&gt;컨테이너가 죽으면 보관중 데이터는 사라짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Stateful Application의 특징
    &lt;ul&gt;
      &lt;li&gt;Container-specific&lt;/li&gt;
      &lt;li&gt;암호, 인증키, 설정값을 Instance에 개별 할당&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Stateful 정의
    &lt;ul&gt;
      &lt;li&gt;Stateful means the computer or program keeps track of the state of interaction, usually by setting values in a storage field designated for that purpose&lt;/li&gt;
      &lt;li&gt;컴퓨터, 프로그램이 스토리지 필드에 값을 설정하고 상호 작용에 대한 상태를 지속적으로 기록&lt;/li&gt;
      &lt;li&gt;StatefulSet은 stateful한 애플리케이션을 관리하기 위해 사용하는 workload&lt;/li&gt;
      &lt;li&gt;Pod 각각에 대해 sticky identity를 유지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;StatefulSet의 복제본은 배포, 크기 조정, 업그레이드 및 종료에 대한 정상적이고 순차적인 접근 방식을 따름
    &lt;ul&gt;
      &lt;li&gt;StatefulSet을 사용하면 복제본이 다시 예약될 때 명명 규칙, 네트워크 이름 및 저장소가 그대로 유지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기본-설정&quot;&gt;기본 설정&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;컴퓨터 영역 설정&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud config set compute/zone us-central1-f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;새 클러스터 생성&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;3개의 노드(가상 머신)가 있는 새 클러스터 생성&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud container clusters create hello-world
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;저장소-등급&quot;&gt;저장소 등급&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;저장소 등급 설정
    &lt;ul&gt;
      &lt;li&gt;MongoDB 복제본 세트를 설정하기 위해 StorageClass, Headless Service, StatefulSet 설정&lt;/li&gt;
      &lt;li&gt;예제 구성 파일 복제&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git clone https://github.com/thesandlord/mongo-k8s-sidecar.git
cd ./mongo-k8s-sidecar/example/StatefulSet/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;저장소 등급 생성
    &lt;ul&gt;
      &lt;li&gt;저장소 등급 구성 확인(SSD와 하드디스크)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cat googlecloud_ssd.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;저장소 등급 배포(kubectl apply 명령어 사용)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl apply -f googlecloud_ssd.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;headless-service-및-statefulset-배포&quot;&gt;Headless Service 및 StatefulSet 배포&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Headless Serice 구성 확인
    &lt;ul&gt;
      &lt;li&gt;clusterIP가 ‘None’으로 설정되어 있어서 Headless Service를 확인할 수 있음&lt;/li&gt;
      &lt;li&gt;StatefulSet과 함께 사용시 포등 ㅔ직접 액세스할 수 있는 DNS 주소를 제공받을 수 있음&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cat mongo-statefulset.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;StatefulSet 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cat mongo-statefulset.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  apiVersion: apps/v1beta1
  kind: StatefulSet
  metadata:
  name: mongo
  spec:
  serviceName: &quot;mongo&quot;
  replicas: 3
  template:
     metadata:
       labels:
         role: mongo
         environment: test
     spec:
       terminationGracePeriodSeconds: 10
       containers:
         - name: mongo
           image: mongo
           command:
             - mongod
             - &quot;--replSet&quot;
             - rs0
             - &quot;--smallfiles&quot;
             - &quot;--noprealloc&quot;
           ports:
             - containerPort: 27017
           volumeMounts:
             - name: mongo-persistent-storage
               mountPath: /data/db
         - name: mongo-sidecar
           image: cvallance/mongo-k8s-sidecar
           env:
             - name: MONGO_SIDECAR_POD_LABELS
               value: &quot;role=mongo,environment=test&quot;
  volumeClaimTemplates:
  - metadata:
       name: mongo-persistent-storage
       annotations:
         volume.beta.kubernetes.io/storage-class: &quot;fast&quot;
     spec:
       accessModes: [ &quot;ReadWriteOnce&quot; ]
       resources:
         requests:
           storage: 100Gi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;StatefulSet 객체에 대한 설명, 메타데이터 부분은 레이블과 복제본의 수를 지정&lt;/li&gt;
      &lt;li&gt;spec 부분엔 포드 사양을 작성. name이 mongo와 mongo-sidecar가 존재하는데, 사이드카 컨테이너가 복제본 세트를 자동으로 구성&lt;/li&gt;
      &lt;li&gt;volumnClaimTemplates는 전에 생성한 StorageClass를 호출해 볼륨을 프로비저닝하고 MongoDB 복제본당 100GB 디스크를 프로비저닝함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl apply -f mongo-statefulset.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mongodb-복제본-세트에-연결&quot;&gt;MongoDB 복제본 세트에 연결&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;아래 명령어를 출력해 DESIRED와 CURRENT 수가 동일한지 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get statefulset
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;클러스터 3개 포드 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get pods
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;첫 복제본 세트 멤버에 연결&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl exec -ti mongo-0 mongo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;MongoDB REPL에 연결됨. 기본 구성으로 복제본 세트 시작
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  rs.initiate()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;복제본 세트 구성 인쇄&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  rs.conf()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;종료&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mongodb-복제본-세트-확장&quot;&gt;MongoDB 복제본 세트 확장&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;복제본을 3개에서 5개로 늘리기&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl scale --replicas=5 statefulset mongo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;아래 명령어로 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get pods
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;5개에서 3개로 줄이기&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl scale --replicas=3 statefulset mongo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;아래 명령어로 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get pods
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mongodb-복제본-세트-활용&quot;&gt;MongoDB 복제본 세트 활용&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Headless Serivce가 지원하는 StatefulSet의 각 포드엔 안정된 DNS 이름이 존재. &lt;Pod name=&quot;&quot;&gt;.&lt;Service Name=&quot;&quot;&gt;의 형식&lt;/Service&gt;&lt;/Pod&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3개의 복제본 세트의 DNS 이름은 아래와 같음&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mongo-0.mongo
  mongo-1.mongo
  mongo-2.mongo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;연결 문자열 URI는 아래와 같음&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &quot;mongodb://mongo-0.mongo,mongo-1.mongo,mongo-2.mongo:27017/dbname_?&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;삭제하기&quot;&gt;삭제하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;StatefulSet 삭제&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl delete statefulset mongo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Headless Service 삭제&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl delete svc mongo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;볼륨 삭제&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl delete pvc -l role=mongo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;클러스터 삭제&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud container clusters delete &quot;hello-world&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://google.qwiklabs.com/quests/29?qlcampaign=1s-seoul-0219&quot;&gt;Kubernetes in the Google Cloud Qwiklabs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/tutorials/kubernetes-basics/&quot;&gt;Kubernetes Tutorial&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://bryan.wiki/298&quot;&gt;Kubernetes StatefulSet 개요 &amp;amp; Nginx Web Cluster(1/5)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/ko-kr/azure/aks/concepts-clusters-workloads&quot;&gt;Azure cluster workloads&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 27 Jan 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/development/2019/01/27/kubernetes-statefulset/</link>
        <guid isPermaLink="true">https://zzsza.github.io/development/2019/01/27/kubernetes-statefulset/</guid>
        
        <category>kubernetes</category>
        
        
        <category>development</category>
        
      </item>
    
      <item>
        <title>Kubernetes Engine을 사용한 배포 관리(with Jenkins)</title>
        <description>&lt;ul&gt;
  &lt;li&gt;2019 클라우드 스터디 잼 입문반에서 진행하는 Kubernetes in the Google Cloud 퀵랩을 듣고 정리한 내용입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;지속적 배포, Blue Green 배포, 카나리 배포 같은 배포 시나리오에 대해 배울 예정&lt;/li&gt;
  &lt;li&gt;kubectl 도구 연습&lt;/li&gt;
  &lt;li&gt;배포 yaml 파일 생성&lt;/li&gt;
  &lt;li&gt;배포 실행, 업데이트, 확장&lt;/li&gt;
  &lt;li&gt;배포 및 배포 스타일 업데이트 연습&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;배포&quot;&gt;배포&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;서로 다른 2개 이상의 인프라 환경, 지역을 연결해 기술, 운영상의 요구를 해결&lt;/li&gt;
  &lt;li&gt;배포 세부 사항에 따라 하이브리드, 멀티 클라우드, 공개-비공개 배포라고도 부름&lt;/li&gt;
  &lt;li&gt;배포가 단일 환경, 지역으로 제한될 경우 발생하는 이슈
    &lt;ul&gt;
      &lt;li&gt;리소스 한도 도달&lt;/li&gt;
      &lt;li&gt;제한된 지리적 범위
        &lt;ul&gt;
          &lt;li&gt;단일 환경이면 멀리 떨어진 사용자들이 모두 하나의 배포에 액세스해야됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;제한된 가용성&lt;/li&gt;
      &lt;li&gt;제공업체 종속&lt;/li&gt;
      &lt;li&gt;경직된 리소스&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;일회성 배포가 아닌 절차를 가진 배포를 설계해야 함
    &lt;ul&gt;
      &lt;li&gt;반복 가능하고 프로비저닝, 구성, 유지보수에 있어 검증된 방식을 사용해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시나리오는 대표적으로 멀티 클라우드 배포, 프론트엔드 내부 데이터, 지속적 통합/지속적 배포 프로세스&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;실습&quot;&gt;실습&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;샘플 코드 clone&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git clone https://github.com/googlecodelabs/orchestrate-with-kubernetes.git
  cd orchestrate-with-kubernetes/kubernetes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;5개의 n1-standard-1 노드를 갖는 클러스터 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud config set compute/zone us-central1-a
  gcloud container clusters create bootcamp --num-nodes 5 --scopes &quot;https://www.googleapis.com/auth/projecthosting,storage-rw&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;배포-객체-알아보기&quot;&gt;배포 객체 알아보기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;배포 객체 살펴보기&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl explain deployment
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 필드를 보려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;--recursive&lt;/code&gt; 옵션 추가&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl explain deployment --recursive
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포 객체의 구조와 개별 필드 이해&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl explain deployment.metadata.name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;배포-만들기&quot;&gt;배포 만들기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;image 변경&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  vi deployments/auth.yaml
  i
	
  containers:
  - name: auth
    image: kelseyhightower/auth:1.0.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포 객체 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl create -f deployments/auth.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get deployments
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포 복제본 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get replicasets
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;복제본 세트가 생성되면 단일 포드 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get pods
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;인증 배포 서비스 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl create -f services/auth.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;hello 배포 만들고 노출&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl create -f deployments/hello.yaml
  kubectl create -f services/hello.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;fronted 배포 생성하고 노출&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl create secret generic tls-certs --from-file tls/
  kubectl create configmap nginx-frontend-conf --from-file=nginx/frontend.conf
  kubectl create -f deployments/frontend.yaml
  kubectl create -f services/frontend.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;외부 IP를 선택한 후 curl로 상호 작용&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get services frontend
  curl -ks https://&amp;lt;EXTERNAL-IP&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;kubectl의 출력 템플릿을 사용해 curl을 한 줄로 사용할 수 있음&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  curl -ks https://`kubectl get svc frontend -o=jsonpath=&quot;{.status.loadBalancer.ingress[0].ip}&quot;`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;배포-확장&quot;&gt;배포 확장&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;spec.replicas&lt;/code&gt; 필드를 업데이트해 확장&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;필드 설명 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl explain deployment.spec.replicas
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl scale&lt;/code&gt; 명령을 사용해 replicas 필드 업데이트 가능&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl scale deployment hello --replicas=5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;실행 중인 인증 포드 5개인지 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get pods | grep hello- | wc -l
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션 축소 후 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl scale deployment hello --replicas=3
  kubectl get pods | grep hello- | wc -l
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;지속적-업데이트&quot;&gt;지속적 업데이트&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;이미지가 새 버전으로 업데이트 되도록 지원&lt;/li&gt;
  &lt;li&gt;배포가 새 버전으로 업데이트되면 새로운 복제본 세트가 생성되고 기존 복제본 세트의 복제본이 줄어들며 새 복제본 세트의 복제본 수가 서서히 늘어남&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포 업데이트&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl edit deployment hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;image를 kelseyhightower/hello:2.0.0로 변경&lt;/li&gt;
  &lt;li&gt;편집기에서 저장하면 업데이트된 배포가 클러스터에 저장되고 쿠버네티스에서 지속적 업데이트 시작&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;새 복제본 세트 조회&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get replicaset
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;롤아웃 내역에서 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl rollout history deployment/hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;지속적-업데이트-일시중지&quot;&gt;지속적 업데이트 일시중지&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl rollout pause deployment/hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;롤아웃 현재 상태 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl rollout status deployment/hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;포드에서 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get pods -o jsonpath --template='{range .items[*]}{.metadata.name}{&quot;\t&quot;}{&quot;\t&quot;}{.spec.containers[0].image}{&quot;\n&quot;}{end}'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;지속적-업데이트-재개&quot;&gt;지속적 업데이트 재개&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;롤아웃이 일시중지되면 일부만 새 버전이고 나머지는 기존 버전으로 유지(&lt;code class=&quot;highlighter-rouge&quot;&gt;resume&lt;/code&gt; 명령 사용)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl rollout resume deployment/hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;상태 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl rollout status deployment/hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;업데이트-롤백&quot;&gt;업데이트 롤백&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;새 버전에서 버그가 발견된 경우 새로운 포드에 연결된 사용자들이 문제를 겪음&lt;/li&gt;
  &lt;li&gt;이전 버전으로 롤백해 조사하고 다시 수정된 버전을 릴리즈&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rollout&lt;/code&gt; 명령을 사용해 롤백&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl rollout undo deployment/hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;롤백 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl rollout history deployment/hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 포드가 이전 버전으로 롤백되었는지 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get pods -o jsonpath --template='{range .items[*]}{.metadata.name}{&quot;\t&quot;}{&quot;\t&quot;}{.spec.containers[0].image}{&quot;\n&quot;}{end}'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;카나리-배포canary-releases&quot;&gt;카나리 배포(Canary Releases)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://jason-lim.tistory.com/3&quot;&gt;설명 글&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;사용자 하위 집합을 사용해 프러덕션의 새 배포를 테스트를 사용하고싶은 경우 선택하는 방법&lt;/li&gt;
  &lt;li&gt;소수의 사용자에 변경 사항을 릴리즈&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;카나리-배포-만들기&quot;&gt;카나리 배포 만들기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;새 버전의 별도 배포와 안정적인 일반 배포 및 카나리 배포로 이루어짐&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;새 버전에 해당하는 카나리 배포 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cat deployments/hello-canary.yaml
  kubectl create -f deployments/hello-canary.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get deployments
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;curl&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  curl -ks https://`kubectl get svc frontend -o=jsonpath=&quot;{.status.loadBalancer.ingress[0].ip}&quot;`/version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;blue-green-배포&quot;&gt;Blue-Green 배포&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;지속적 업데이트는 최소한 오버헤드, 성능 영향, 다운타임으로 천천히 배포할 수 있어서 이상적
    &lt;ul&gt;
      &lt;li&gt;완전히 배포된 후 새 버전을 가리키도록 부하 분산기를 수정하는 편이 유용할 경우가 존재하는데, 이 경우 Blue-Green 배포 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기존 Blue 버전과 새로운 Green 버전의 배포를 각각 하나씩 생성해 구현
    &lt;ul&gt;
      &lt;li&gt;새로운 Green 버전이 실행되면 서비스를 업데이트해 이 버전을 사용하도록 전환&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;클러스터의 리소스가 2배 이상 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스 업데이트&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl apply -f services/hello-blue.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Green 배포 버전 라벨 및 이미지 경로 업데이트&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  apiVersion: extensions/v1beta1
kind: Deployment
metadata:
name: hello-green
spec:
replicas: 3
template:
  metadata:
    labels:
      app: hello
      track: stable
      version: 2.0.0
  spec:
    containers:
      - name: hello
        image: kelseyhightower/hello:2.0.0
        ports:
          - name: http
            containerPort: 80
          - name: health
            containerPort: 81
        resources:
          limits:
            cpu: 0.2
            memory: 10Mi
        livenessProbe:
          httpGet:
            path: /healthz
            port: 81
            scheme: HTTP
          initialDelaySeconds: 5
          periodSeconds: 15
          timeoutSeconds: 5
        readinessProbe:
          httpGet:
            path: /readiness
            port: 81
            scheme: HTTP
          initialDelaySeconds: 5
          timeoutSeconds: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Green 배포 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl create -f deployments/hello-green.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;현재 버전 사용하는지 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  curl -ks https://`kubectl get svc frontend -o=jsonpath=&quot;{.status.loadBalancer.ingress[0].ip}&quot;`/version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스 업데이트&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl apply -f services/hello-green.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스가 업데이트되는 즉시 Green 배포가 사용됨&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  curl -ks https://`kubectl get svc frontend -o=jsonpath=&quot;{.status.loadBalancer.ingress[0].ip}&quot;`/version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;blue-green-롤백&quot;&gt;Blue-Green 롤백&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;기존 버전으로 업데이트&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl apply -f services/hello-blue.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스를 업데이트하면 롤백 성공&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  curl -ks https://`kubectl get svc frontend -o=jsonpath=&quot;{.status.loadBalancer.ingress[0].ip}&quot;`/version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;kubernetes-engine에서-jenkins를-사용한-지속적-통합conitnuous-delivery&quot;&gt;Kubernetes Engine에서 Jenkins를 사용한 지속적 통합(Conitnuous Delivery)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gcpstaging-qwiklab-website-prod.s3.amazonaws.com/bundles/assets/d5bfbd0f6d109df463005f1ceb195799ec68b7b4c370eb18cec470a7f1f812b1.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;젠킨스를 사용해 지속적 통합을 진행
    &lt;ul&gt;
      &lt;li&gt;빌드, 테스트, 배포의 파이프라인을 통합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;미리 선행해야 하는 일
    &lt;ul&gt;
      &lt;li&gt;쿠버네티스 엔진 클러스터에 젠킨스 Provision&lt;/li&gt;
      &lt;li&gt;젠킨스에 Helm Package Manager 설정&lt;/li&gt;
      &lt;li&gt;Feature들 탐험&lt;/li&gt;
      &lt;li&gt;젠킨스 파이프라인 생성하고 테스트&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Kubernetes Engine
    &lt;ul&gt;
      &lt;li&gt;GCP의 Managed Kbernetes&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Jenkins
    &lt;ul&gt;
      &lt;li&gt;빌드, 테스트, 배포 파이프라인을 유연하게 조절할 수 있는 도구&lt;/li&gt;
      &lt;li&gt;프로젝트를 신속하게 반복할 수 있도록 지원&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Repo 준비&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud config set compute/zone us-central1-f
  git clone https://github.com/GoogleCloudPlatform/continuous-deployment-on-kubernetes.git
  cd continuous-deployment-on-kubernetes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;provisioning-jenkins&quot;&gt;Provisioning Jenkins&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Kubernetes 클러스터 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud container clusters create jenkins-cd \
--num-nodes 2 \
--machine-type n1-standard-2 \
--scopes &quot;https://www.googleapis.com/auth/projecthosting,cloud-platform&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;완료된 Task 테스트&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud container clusters list
  gcloud container clusters get-credentials jenkins-cd
  kubectl cluster-info
  &amp;gt;&amp;gt;&amp;gt; is running at ~
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Helm 설치&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  wget https://storage.googleapis.com/kubernetes-helm/helm-v2.9.1-linux-amd64.tar.gz
  tar zxfv helm-v2.9.1-linux-amd64.tar.gz
cp linux-amd64/helm .
  # permission
  kubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin --user=$(gcloud config get-value account)
  # cluster-admin role
  kubectl create serviceaccount tiller --namespace kube-system
kubectl create clusterrolebinding tiller-admin-binding --clusterrole=cluster-admin --serviceaccount=kube-system:tiller
  ./helm init --service-account=tiller
  ./helm update
  # version 확인
  ./helm version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;젠킨스 설정 및 설치
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;설정 Deploy&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ./helm install -n cd stable/jenkins -f jenkins/values.yaml --version 0.16.6 --wait
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;젠킨스 pod 확인&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get pods
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;젠킨스 UI에서 클라우드 쉘로 포워딩 설정&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  export POD_NAME=$(kubectl get pods -l &quot;component=cd-jenkins-master&quot; -o jsonpath=&quot;{.items[0].metadata.name}&quot;)
kubectl port-forward $POD_NAME 8080:8080 &amp;gt;&amp;gt; /dev/null &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;젠킨스 서비스 확인&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get svc
  &amp;gt;&amp;gt;&amp;gt; cd-jenkins         ClusterIP   10.11.255.161   &amp;lt;none&amp;gt;        8080/TCP    4m
  cd-jenkins-agent   ClusterIP   10.11.251.179   &amp;lt;none&amp;gt;        50000/TCP   4m
  kubernetes         ClusterIP   10.11.240.1     &amp;lt;none&amp;gt;        443/TCP     27m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;젠킨스 마스터가 요청할 때 빌더 노드가 필요할 때 자동으로 실행되도록 쿠버네티스 플러그인을 사용
    &lt;ul&gt;
      &lt;li&gt;작업이 완료되면 자동으로 해제되고 리소스가 클러스터 리소스 풀에 다시 추가됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;젠킨스-연결&quot;&gt;젠킨스 연결&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;실행&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  printf $(kubectl get secret cd-jenkins -o jsonpath=&quot;{.data.jenkins-admin-password}&quot; | base64 --decode);echo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;포트 8080 생성&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;ID : admin, PW : 위에서 나온 것을 복붙&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;배포-1&quot;&gt;배포&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Production : Live&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Canary : samller-capacity site&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cd sample-app
  kubectl create ns production
  kubectl apply -f k8s/production -n production
  kubectl apply -f k8s/canary -n production
  kubectl apply -f k8s/services -n production
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Production 환경 scale up&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl scale deployment gceme-frontend-production -n production --replicas 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;fronted 설정&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get pods -n production -l app=gceme -l role=frontend
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;backend 설정&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get pods -n production -l app=gceme -l role=backend
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;외부 IP 노출&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get service gceme-frontend -n production
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Export&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  export FRONTEND_SERVICE_IP=$(kubectl get -o jsonpath=&quot;{.status.loadBalancer.ingress[0].ip}&quot; --namespace=production services gceme-frontend)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Curl&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  curl http://$FRONTEND_SERVICE_IP/version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;젠킨스-파이프라인-생성&quot;&gt;젠킨스 파이프라인 생성&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;gceme 복사하고 Cloud Source Repository에 Push&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud alpha source repos create default
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Init&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git init
  git config credential.helper gcloud.sh
  git remote add origin https://source.developers.google.com/p/$DEVSHELL_PROJECT_ID/r/default
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;config&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git config --global user.email &quot;[EMAIL_ADDRESS]&quot;
  git config --global user.name &quot;[USERNAME]&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;add, commit, push&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git add .
  git commit -m &quot;Initial commit&quot;
  git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://google.qwiklabs.com/quests/29?qlcampaign=1s-seoul-0219&quot;&gt;Kubernetes in the Google Cloud Qwiklabs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 20 Jan 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/development/2019/01/20/kubernetes-engine-deployment/</link>
        <guid isPermaLink="true">https://zzsza.github.io/development/2019/01/20/kubernetes-engine-deployment/</guid>
        
        <category>kubernetes</category>
        
        
        <category>development</category>
        
      </item>
    
      <item>
        <title>MLflow 소개 및 Tutorial</title>
        <description>&lt;ul&gt;
  &lt;li&gt;머신러닝 라이프 사이클을 관리할 수 있는 오픈소스인 MLflow에 대한 소개 및 간단한 Tutorial에 대한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;mlflow&quot;&gt;MLflow&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;MLflow는 End to End로 머신러닝 라이프 사이클을 관리할 수 있는 오픈소스
    &lt;ul&gt;
      &lt;li&gt;데이터브릭스에서 만듬&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://databricks.com/mlflow&quot;&gt;데이터브릭스 hosted version&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;주요 기능
    &lt;ul&gt;
      &lt;li&gt;1) MLflow Tracking
        &lt;ul&gt;
          &lt;li&gt;파라미터와 결과를 비교하기 위해 실험 결과를 저장&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) MLflow Projects
        &lt;ul&gt;
          &lt;li&gt;머신러닝 코드를 재사용 가능하고 재현 가능한 형태로 포장&lt;/li&gt;
          &lt;li&gt;포장된 형태를 다른 데이터 사이언티스트가 사용하거나 프러덕션에 반영&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;3) MLflow Models
        &lt;ul&gt;
          &lt;li&gt;다양한 ML 라이브러리에서 모델을 관리하고 배포, Serving, 추론&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;REST API, CLI를 통해 모든 기능에 액세스 할 수 있기 때문에 모든 라이브러리, 프로그래밍 언어에서 사용 가능&lt;/li&gt;
  &lt;li&gt;API는 Python, R, Java 존재&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;설치-및-예제-코드-준비&quot;&gt;설치 및 예제 코드 준비&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;virtualenv 설정&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  virtualenv env
  source env/bin/activate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;설치&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pip3 install mlflow
  # virtualenv 없이 pip3 install mlflow하니 [Errno 13] Permission denied: '/usr/local/man' 발생
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;예제 코드 clone&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git clone https://github.com/mlflow/mlflow
  cd mlflow/examples
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tracking&quot;&gt;Tracking&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mlflow.org/docs/latest/tracking.html#tracking&quot;&gt;Tracking Document&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Code Version
    &lt;ul&gt;
      &lt;li&gt;Git commit hash used to execute the run, if it was executed from an MLflow Project.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Start &amp;amp; End Time
    &lt;ul&gt;
      &lt;li&gt;Start and end time of the run&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Source
    &lt;ul&gt;
      &lt;li&gt;Name of the file executed to launch the run, or the project name and entry point for the run if the run was executed from an MLflow Project.
Parameters&lt;/li&gt;
      &lt;li&gt;Key-value input parameters of your choice. Both keys and values are strings.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Metrics
    &lt;ul&gt;
      &lt;li&gt;Key-value metrics where the value is numeric. Each metric can be updated throughout the course of the run (for example, to track how your model’s loss function is converging), and MLflow will record and let you visualize the metric’s full history.
Artifacts&lt;/li&gt;
      &lt;li&gt;Output files in any format. For example, you can record images (for example, PNGs), models (for example, a pickled scikit-learn model), or even data files (for example, a Parquet file) as artifacts.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;예제 코드&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # mlflow_tracking.py
  import os
  from random import random, randint
	
  from mlflow import log_metric, log_param, log_artifacts
	
  if __name__ == &quot;__main__&quot;:
      print(&quot;Running mlflow_tracking.py&quot;)
	
      log_param(&quot;param1&quot;, randint(0, 100))
	
      log_metric(&quot;foo&quot;, random())
      log_metric(&quot;foo&quot;, random() + 1)
      log_metric(&quot;foo&quot;, random() + 2)
	
      if not os.path.exists(&quot;outputs&quot;):
          os.makedirs(&quot;outputs&quot;)
      with open(&quot;outputs/test.txt&quot;, &quot;w&quot;) as f:
          f.write(&quot;hello world!&quot;)
	
      log_artifacts(&quot;outputs&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;실행&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  python3 mlflow_tracking.py
  &amp;gt;&amp;gt;&amp;gt; Running mlflow_tracking.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;웹 UI 실행
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;기본적으로 프로그램을 실행할 때마다 tracing API가 mlruns 디렉토리에 파일을 작성. 그 후 웹 UI 실행 가능&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mlflow ui
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/jzrxbe2h3z6mwvh/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-01-16%2000.18.20.png?raw=1&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mlflow-project-실행&quot;&gt;MLflow Project 실행&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mlflow.org/docs/latest/projects.html&quot;&gt;MLflow Projects Document&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;default 설정은 디펜던시가 conda에 있음&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;conda를 사용하고 싶지 않을 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;--no-conda&lt;/code&gt; 추가&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mlflow run --no-conda git@github.com:mlflow/mlflow-example.git -P alpha=5
  &amp;gt;&amp;gt;&amp;gt; Elasticnet model (alpha=5.000000, l1_ratio=0.100000):
  RMSE: 0.8594260117338262
  MAE: 0.6480675144220314
  R2: 0.046025292604596424
  
  mlflow run tutorial -P alpha=0.5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Experiments list 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mlflow experiments list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;saving-and-serving-model&quot;&gt;Saving and Serving Model&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mlflow.org/docs/latest/models.html&quot;&gt;MLflow Models Document&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;학습&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  python3 sklearn_logistic_regression/train.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # train.py
  import numpy as np
  from sklearn.linear_model import LogisticRegression

  import mlflow
  import mlflow.sklearn
	
  if __name__ == &quot;__main__&quot;:
      X = np.array([-2, -1, 0, 1, 2, 1]).reshape(-1, 1)
      y = np.array([0, 0, 1, 1, 1, 0])
      lr = LogisticRegression()
      lr.fit(X, y)
      score = lr.score(X, y)
      print(&quot;Score: %s&quot; % score)
      mlflow.log_metric(&quot;score&quot;, score)
      mlflow.sklearn.log_model(lr, &quot;model&quot;)
      print(&quot;Model saved in run %s&quot; % mlflow.active_run().info.run_uuid)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Serving
    &lt;ul&gt;
      &lt;li&gt;train.py를 실행하면 RUN ID가 나오는데, 그걸 토대로 아래처럼 serving&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mlflow pyfunc serve -r &amp;lt;RUN_ID&amp;gt; -m model --no-conda --port 1234
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;curl&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  curl -d '{&quot;columns&quot;:[&quot;x&quot;], &quot;data&quot;:[[1], [-1]]}' -H 'Content-Type: application/json; format=pandas-split' -X POST localhost:1234/invocations
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;tutorial&quot;&gt;Tutorial&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;linear regression 모델 학습&lt;/li&gt;
  &lt;li&gt;재사용, 재생산 가능하도록 패키징&lt;/li&gt;
  &lt;li&gt;간단한 HTTP 서버에 배포&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;모델-학습&quot;&gt;모델 학습&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;examples/sklearn_elasticnet_wine/train.py &amp;lt;alpha&amp;gt; &amp;lt;l1_ratio&amp;gt;&lt;/code&gt; 여러번 테스트&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import os
  import sys
	
  import pandas as pd
  import numpy as np
  from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
  from sklearn.model_selection import train_test_split
  from sklearn.linear_model import ElasticNet
	
  import mlflow
  import mlflow.sklearn
  # Run from the root of MLflow
  # Read the wine-quality csv file
  wine_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), &quot;wine-quality.csv&quot;)
  data = pd.read_csv(wine_path)
	
  # Split the data into training and test sets. (0.75, 0.25) split.
  train, test = train_test_split(data)
	
  # The predicted column is &quot;quality&quot; which is a scalar from [3, 9]
  train_x = train.drop([&quot;quality&quot;], axis=1)
  test_x = test.drop([&quot;quality&quot;], axis=1)
  train_y = train[[&quot;quality&quot;]]
  test_y = test[[&quot;quality&quot;]]
	
  alpha = float(sys.argv[1]) if len(sys.argv) &amp;gt; 1 else 0.5
  l1_ratio = float(sys.argv[2]) if len(sys.argv) &amp;gt; 2 else 0.5
	
  with mlflow.start_run():
      lr = ElasticNet(alpha=alpha, l1_ratio=l1_ratio, random_state=42)
      lr.fit(train_x, train_y)

  predicted_qualities = lr.predict(test_x)

  (rmse, mae, r2) = eval_metrics(test_y, predicted_qualities)

  print(&quot;Elasticnet model (alpha=%f, l1_ratio=%f):&quot; % (alpha, l1_ratio))
  print(&quot;  RMSE: %s&quot; % rmse)
  print(&quot;  MAE: %s&quot; % mae)
  print(&quot;  R2: %s&quot; % r2)

  mlflow.log_param(&quot;alpha&quot;, alpha)
  mlflow.log_param(&quot;l1_ratio&quot;, l1_ratio)
  mlflow.log_metric(&quot;rmse&quot;, rmse)
  mlflow.log_metric(&quot;r2&quot;, r2)
  mlflow.log_metric(&quot;mae&quot;, mae)

  mlflow.sklearn.log_model(lr, &quot;model&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;웹 서버 접속&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mlflow ui
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;웹 서버 탐색&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/n5b3yb8gzqfgm3s/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-01-16%2001.40.42.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;학습-코드-패키징&quot;&gt;학습 코드 패키징&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MLproject&lt;/code&gt;란 파일 생성해서 아래와 같이 설정&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  name: tutorial
	
  conda_env: conda.yaml
	
  entry_points:
    main:
      parameters:
        alpha: float
        l1_ratio: {type: float, default: 0.1}
      command: &quot;python train.py {alpha} {l1_ratio}&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;conda.yaml&lt;/code&gt; 작성 (pip로 할 경우 사용하지 못하는가?)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  name: tutorial
  channels:
    - defaults
  dependencies:
    - numpy=1.14.3
    - pandas=0.22.0
    - scikit-learn=0.19.1
    - pip:
      - mlflow
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mlflow run tutorial -P alpha=0.42&lt;/code&gt;으로 실행&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;만약 Github에서 올라간 소스를 바로 실행하고 싶으면 아래와 같이 사용 가능&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mlflow run git@github.com:mlflow/mlflow-example.git -P alpha=0.42
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;serving-the-model&quot;&gt;Serving the Model&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;REST API를 통한 실시간 서비스 또는 Apache Spark의 배치 inference 같은 다양한 도구에서 사용할 수 있는 형식이 존재&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;예제 코드에선 선형회귀 모델을 학습한 후 MLflow 함수가 모델을 아티팩트로 저장함&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mlflow.sklearn.log_model(lr, &quot;model&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;웹 UI에서 확인하면 설정 확인 가능&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;아래 명령어를 통해 serving&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mlflow pyfunc serve /Users/mlflow/mlflow-prototype/mlruns/0/7c1a0d5c42844dcdb8f5191146925174/artifacts/model -p 1234
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;API Test&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  curl -X POST -H &quot;Content-Type:application/json; format=pandas-split&quot; --data '{&quot;columns&quot;:[&quot;alcohol&quot;, &quot;chlorides&quot;, &quot;citric acid&quot;, &quot;density&quot;, &quot;fixed acidity&quot;, &quot;free sulfur dioxide&quot;, &quot;pH&quot;, &quot;residual sugar&quot;, &quot;sulphates&quot;, &quot;total sulfur dioxide&quot;, &quot;volatile acidity&quot;],&quot;data&quot;:[[12.8, 0.029, 0.48, 0.98, 6.2, 29, 3.33, 1.2, 0.39, 75, 0.66]]}' http://127.0.0.1:1234/invocations
  &amp;gt;&amp;gt;&amp;gt; {&quot;predictions&quot;: [6.379428821398614]}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;클라우드에서-배포&quot;&gt;클라우드에서 배포&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;AzureML&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mlflow azureml export -m &amp;lt;model path&amp;gt; -o test-output
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SageMaker&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mlflow sagemaker build-and-push-container
  mlflow sagemaker deploy &amp;lt;parameters&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mlflow.org/docs/latest/index.html&quot;&gt;MLflow Document&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://speakerdeck.com/dongjin/introducing-mlflow&quot;&gt;이동진님의 mlflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 16 Jan 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/mlops/2019/01/16/mlflow-basic/</link>
        <guid isPermaLink="true">https://zzsza.github.io/mlops/2019/01/16/mlflow-basic/</guid>
        
        <category>mlflow</category>
        
        
        <category>mlops</category>
        
      </item>
    
      <item>
        <title>Kubernetes 개요 및 애플리케이션 배포</title>
        <description>&lt;ul&gt;
  &lt;li&gt;2019 클라우드 스터디 잼 입문반에서 진행하는 Kubernetes in the Google Cloud 퀵랩을 듣고 정리한 내용입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;introduction-to-docker&quot;&gt;Introduction to docker&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Dokcer를 사용하면 인프라에서 어플리케이션을 분리하고 인프라를 managed 어플리케이션처럼 사용할 수 있음&lt;/li&gt;
  &lt;li&gt;Docker는 코드를 신속하게 제공하고 테스트, 배포 속도를 높이고 코드 작성과 실행 사이의 주기를 단축해줌&lt;/li&gt;
  &lt;li&gt;Dokcer 컨테이너는 쿠버네티스에서 쉽게 사용할 수 있음&lt;/li&gt;
  &lt;li&gt;Docker의 핵심을 배우며 쿠버네티스 및 컨테이너 응용 프로그램을 개발할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hello-world&quot;&gt;Hello World&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;hello-world docker run!&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker run hello-world
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker 이미지 출력&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker images
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker running 컨테이너 보기&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker ps
  &amp;gt;&amp;gt;&amp;gt; 처음엔 아무것도 뜨지 않음
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 docker 이미지를 보려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;-a&lt;/code&gt; 추가&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker ps -a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker run –name [container-name] hello-world&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;container 이름을 앞의 글자 3개만 사용해도 됨!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;build&quot;&gt;Build&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;test 폴더 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mkdir test &amp;amp;&amp;amp; cd test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Dockerfile 생성
    &lt;ul&gt;
      &lt;li&gt;더 궁금할 경우 &lt;a href=&quot;https://docs.docker.com/engine/reference/builder/#run&quot;&gt;Docker command reference&lt;/a&gt; 참고&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cat &amp;gt; Dockerfile &amp;lt;&amp;lt;EOF
  # Use an official Node runtime as the parent image
  FROM node:6 # 이미지 지정
  # Set the working directory in the container to /app
  WORKDIR /app # 컨테이너 작업 디렉토리 설정
  # Copy the current directory contents into the container at /app
  ADD . /app # 현재 디렉토리 내용을 컨테이너에 추가
  # Make the container's port 80 available to the outside world
  EXPOSE 80 # 80 포트를 연결을 허용
  # Run app.js using node when the container launches
  CMD [&quot;node&quot;, &quot;app.js&quot;] # node 명령을 실행해 프로그램 시작
  EOF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;app.js 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cat &amp;gt; app.js &amp;lt;&amp;lt;EOF
  const http = require('http');
	
  const hostname = '0.0.0.0';
  const port = 80;
	
  const server = http.createServer((req, res) =&amp;gt; {
      res.statusCode = 200;
        res.setHeader('Content-Type', 'text/plain');
          res.end('Hello World\n');
  });
	
  server.listen(port, hostname, () =&amp;gt; {
      console.log('Server running at http://%s:%s/', hostname, port);
  });
	
  process.on('SIGINT', function() {
      console.log('Caught interrupt signal and will exit');
      process.exit();
  });
  EOF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;build&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker build -t node-app:0.1 .
  # Dockerfile이 있는 디렉토리에서 명령어 실행
  # -t는 이미지에 태그, name:tag 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;docker images 확인&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;run&quot;&gt;Run&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Run&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker run -p 4000:80 --name my-app node-app:0.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다른 터미널에서 아래 명령어 입력&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  curl http://localhost:4000
  &amp;gt;&amp;gt;&amp;gt; Hello World
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker stop and remove&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker stop my-app &amp;amp;&amp;amp; docker rm my-app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다시 run&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker run -p 4000:80 --name my-app -d node-app:0.1
  docker ps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker logs&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker logs [container_id]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;호스트의 8080 포트를 컨테이너의 80포트로 연결&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker run -p 8080:80 --name my-app-2 -d node-app:0.2
  docker ps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;debug&quot;&gt;Debug&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;작동중 container 로그 출력&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker logs -f [container_id]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Interactive Bash session을 시작해 container로 진입&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker exec -it [container_id] bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;inspect&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;metadata 검사&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker inspect [container_id]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--format&lt;/code&gt;을 사용하면 특정 필드를 json타입으로 리턴&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker inspect --format='' [container_id]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;publish&quot;&gt;Publish&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;자신의 이미지를 &lt;a href=&quot;https://cloud.google.com/container-registry/&quot;&gt;Google Container Registry&lt;/a&gt;에 push!&lt;/li&gt;
  &lt;li&gt;gcr이 호스팅하는 비공개 레지스트리에 이미지를 푸시
    &lt;ul&gt;
      &lt;li&gt;형식 : [hostname]/[project-id]/[image]:[tag]&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Project ID 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud config list project
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker tag&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker tag node-app:0.2 gcr.io/[project-id]/node-app:0.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;push&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud docker -- push gcr.io/[project-id]/node-app:0.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 컨테이너 stop and remove&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker stop $(docker ps -q)
  docker rm $(docker ps -aq)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컨테이너 이미지 삭제&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker rmi node-app:0.2 gcr.io/[project-id]/node-app node-app:0.1
  docker rmi node:6
  docker rmi $(docker images -aq) # remove remaining images
  docker images
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gcloud docker pull&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud docker -- pull gcr.io/[project-id]/node-app:0.2
	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hello-node-kubernetes&quot;&gt;Hello Node Kubernetes&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://run-qwiklab-website-prod.s3.amazonaws.com/instructions/documents/93937/original/img/ba830277f2d92e04.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쿠버네티스
    &lt;ul&gt;
      &lt;li&gt;Notebook, 멀티노드 클러스터, 클라우드에서 내부 배포할 수 있고 다양한 환경에서 실행할 수 있는 오픈소스&lt;/li&gt;
      &lt;li&gt;Kubernetes Engine(Google의 Managed Service)를 사용해 인프라 설정보다 쿠버네티스를 경험하는 것에 집중&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/reference/kubectl/overview/&quot;&gt;kubectl document&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Node.js 애플리케이션 만들기
    &lt;ul&gt;
      &lt;li&gt;쿠버네티스 엔진에 배포할 애플리케이션 작성&lt;/li&gt;
      &lt;li&gt;server.js&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var http = require('http');
  var handleRequest = function(request, response) {
    response.writeHead(200);
    response.end(&quot;Hello World!&quot;);
  }
  var www = http.createServer(handleRequest);
  www.listen(8080);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;node server.js&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이걸 docker 컨테이너로 패키징
    &lt;ul&gt;
      &lt;li&gt;vi Dockerfile&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  FROM node:6.9.2 # docker 허브의 node 이미지로 시작
  EXPOSE 8080 # 포트 8080 노출
  COPY server.js . # 사용자가 만든 server.js를 이미지로 복사
  CMD node server.js # node 서버 시작
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;이미지 빌드&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker build -t gcr.io/PROJECT_ID/hello-node:v1 .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;Docker 컨테이너 이미지에서 포트 8080로 데몬 실행
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/run/&quot;&gt;Docker run&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; : Detached mode&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker run -d -p 8080:8080 gcr.io/PROJECT_ID/hello-node:v1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;Docker 컨테이너 중지
        &lt;ul&gt;
          &lt;li&gt;docker ps에 나오는 컨테이너 중지&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Google Container Registry로 이미지 Push
        &lt;ul&gt;
          &lt;li&gt;Container Registry는 Google Cloud 프로젝트에서 액세스 가능&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud docker -- push gcr.io/PROJECT_ID/hello-node:v1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;ul&gt;
          &lt;li&gt;이제 쿠버네티스가 접근할 수 있는 도커 이미지 만들어짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클러스터 만들기
    &lt;ul&gt;
      &lt;li&gt;Container Engine 클러스터 생성&lt;/li&gt;
      &lt;li&gt;하나의 클러스터는 쿠버네티스 마스터 API 서버와 노드로 구성, 노드는 Computer Engine 가상 머신&lt;/li&gt;
      &lt;li&gt;Kubernetes Engine에 접속&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud container clusters create hello-world \
              --num-nodes 2 \
              --machine-type n1-standard-1 \
              --zone us-central1-f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;포드 만들기
    &lt;ul&gt;
      &lt;li&gt;포드는 관리 및 네트워킹 용도로 서로 연결된 컨테이너 그룹&lt;/li&gt;
      &lt;li&gt;포드는 하나 또는 여러 개의 컨테이너를 포함할 수 있음&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl run hello-node \
  --image=gcr.io/PROJECT_ID/hello-node:v1 \
  --port=8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;deployment “hello-node” created란 문구가 나오면 배포 개체를 만든 것!&lt;/li&gt;
      &lt;li&gt;포드를 만들고 확장할 땐 배포를 사용하는게 좋음&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;배포 확인(마치 docker ps 같음)&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get deployments
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;배포 만들어진 포드 확인&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get pods
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;클러스터 정보 확인&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl cluster-info
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;클러스터 config 확인&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl config view
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;pod 로그 확인&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get events
  kubectl logs &amp;lt;pod name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;외부-트래픽-허용&quot;&gt;외부 트래픽 허용&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Pod는 클러스터에 포함된 내부 IP로만 액세스 가능
    &lt;ul&gt;
      &lt;li&gt;가상 네트워크 외부에서 컨테이너에 액세스 하려면 포드를 쿠버네티스 서비스로 노출시켜야 함&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;kubectl expose 명령에 –type=”LoadBalancer” 플래그를 사용!&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl expose deployment hello-node --type=&quot;LoadBalancer&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;직접 노출시키는 것이 아닌 배포를 노출시킴!!!!&lt;/li&gt;
      &lt;li&gt;서비스가 이 배포에서 관리하는 모든 포드에 걸쳐 트래픽의 부하를 분산&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IP 주소 확인
    &lt;ul&gt;
      &lt;li&gt;외부 부하 분산 IP 1개 보임&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get services
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;서비스-규모-확장하기&quot;&gt;서비스 규모 확장하기&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://run-qwiklab-website-prod.s3.amazonaws.com/instructions/documents/93937/original/img/587f7f0a097aaa2.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쿠버네티스의 강력한 기능은 애플리케이션을 간편하게 확장할 수 있는 것
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;갑자기 용량이 필요해졌을 경우 복제 컨트롤러에 새로운 복제를 관리하라고 명령할 수 있음&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl scale deployment hello-node --replicas=4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;배포에 관한 설명 확인&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get deployment
  kubectl get pods
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;서비스의-업그레이드-롤아웃&quot;&gt;서비스의 업그레이드 롤아웃&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;배포한 애플리케이션에 버그 수정이나 추가 기능을 적용해야 할 경우
    &lt;ul&gt;
      &lt;li&gt;server.js 하단에 response.end(“Hello Kubernetes World!”); 추가&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;빌드 및 push&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker build -t gcr.io/PROJECT_ID/hello-node:v2 . 
  gcloud docker -- push gcr.io/PROJECT_ID/hello-node:v2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;실행 중인 컨테이너의 이미지 라벨을 기존 hello-node-deployment를 수정해야 함
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gcr.io/PROJECT_ID/hello-node:v1 =&amp;gt; gcr.io/PROJECT_ID/hello-node:v2&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;이를 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl edit&lt;/code&gt; 명령 사용&lt;/li&gt;
          &lt;li&gt;kubectl edit deployment hello-node&lt;/li&gt;
          &lt;li&gt;containers의 image를 수정&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;새로운 이미지 배포&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get deployments
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;그래픽-대시보드&quot;&gt;그래픽 대시보드&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;kubernetes 클러스터 대시보드에 액세스 하려면 아래 명령어 실행&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud container clusters get-credentials hello-world \
  --zone us-central1-f --project &amp;lt;PROJECT_ID&amp;gt;
  kubectl proxy --port 8081
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;URL에서 ?authuser=0을 삭제하고 끝이 /ui를 붙임&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;근데 대시보드 안나오는데요..?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;kubernetes를-통한-클라우드-조정&quot;&gt;Kubernetes를 통한 클라우드 조정&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;kubectl을 사용해 Docker 컨테이너를 배포하고 관리&lt;/li&gt;
  &lt;li&gt;하나의 애플리케이션을 마이크로 서비스로 나눔&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;영역 설정&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud config set compute/zone us-central1-b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;클러스터 설정(시간이 좀 소요됨)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud container clusters create io
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;코드 clone&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git clone https://github.com/googlecodelabs/orchestrate-with-kubernetes.git
  cd orchestrate-with-kubernetes/kubernetes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;쿠버네티스-데모&quot;&gt;쿠버네티스 데모&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Kubernetes 시작하는 가장 쉬운 방법 : &lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl run&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ngninx 컨테이너 인스턴스 실행&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl run nginx --image=nginx:1.10.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;실행 중인 nginx 컨테이너 보기&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get pods
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Kubernetes 외부로 노출
    &lt;ul&gt;
      &lt;li&gt;공개 IP 주소로 도달한 클라이언트는 서비스 뒤에 있는 포드로 라우팅&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl expose deployment nginx --port 80 --type LoadBalancer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스 나열&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get services
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;curl http://&lt;External IP=&quot;&quot;&gt;:80 로 확인&lt;/External&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pod&quot;&gt;Pod&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://run-qwiklab-website-prod.s3.amazonaws.com/instructions/documents/92971/original/img/56124565adb6c28b.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쿠버네티스의 핵심 요소
    &lt;ul&gt;
      &lt;li&gt;하나 이상의 컨테이너가 포함된 집합&lt;/li&gt;
      &lt;li&gt;종속도가 높은 여러 컨테이너가 있을 경우 컨테이너들은 단일 포드로 패키징&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;볼륨
    &lt;ul&gt;
      &lt;li&gt;포드가 활성화되어 있어야 사용 가능한 데이터 디스크&lt;/li&gt;
      &lt;li&gt;포드는 컨텐츠에 대한 공유 네임스페이스를 제공&lt;/li&gt;
      &lt;li&gt;예제 포드에 속한 두 컨테이너가 서로 통신할 수 있으며 연결된 볼륨도 공유함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;포드는 네트워크 네임스페이스도 공유
    &lt;ul&gt;
      &lt;li&gt;포드마다 IP 주소 하나씩 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;포드-만들기&quot;&gt;포드 만들기&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pods/monolith.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;구성 파일 출력&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  apiVersion: v1
  kind: Pod
  metadata:
    name: monolith
    labels:
      app: monolith
  spec:
    containers:
      - name: monolith
        image: kelseyhightower/monolith:1.0.0
        args:
          - &quot;-http=0.0.0.0:80&quot;
          - &quot;-health=0.0.0.0:81&quot;
          - &quot;-secret=secret&quot;
        ports:
          - name: http
            containerPort: 80
          - name: health
            containerPort: 81
        resources:
          limits:
            cpu: 0.2
            memory: &quot;10Mi&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;포드는 하나의 컨테이너로 구성&lt;/li&gt;
      &lt;li&gt;시작할 때 몇 개의 인수를 컨테이너에 전달&lt;/li&gt;
      &lt;li&gt;http 트래픽을 위해 포트 80을 개방&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;kubectl을 사용해 모놀리식 포드 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl create -f pods/monolith.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;kubectl get pods를 사용해 포드 나열&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모놀리식 포드 정보 요약&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl describe pods monolith
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;포드-상호-작용&quot;&gt;포드 상호 작용&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;포드는 기본적으로 비공개 IP 주소가 할당되고 클러스터 외부에 도달할 수 없음&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl port-forward&lt;/code&gt; 명령을 사용해 로컬 포트를 모놀리식 포드의 포트로 매핑&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(새 터미널에서) 포트 전달&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl port-forward monolith 10080:80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;통신 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  curl http://127.0.0.1:10080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;로그인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  curl -u user http://127.0.0.1:10080/login
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;비밀번호 : password를 입력하면 토큰이 생성됨! 복사해서 사용&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  TOKEN=$(curl http://127.0.0.1:10080/login -u user|jq -r '.token')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;안전한 엔드포인트 도달&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  curl -H &quot;Authorization: Bearer $TOKEN&quot; http://127.0.0.1:10080/secure
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모놀리식 포드 로그 조회&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl logs monolith
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;새 터미널을 열고 실시간 로그 스트림 받기&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl logs -f monolith
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;쿠버네티스 포드의 대화형 셸 실행하기&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl exec monolith --stdin --tty -c monolith /bin/sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;서비스&quot;&gt;서비스&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://run-qwiklab-website-prod.s3.amazonaws.com/instructions/documents/92971/original/img/b8b7a35f34a77aec.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/services-networking/service/&quot;&gt;서비스 문서&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;포드는 영구적인 것이 아님
    &lt;ul&gt;
      &lt;li&gt;활성 여부나 준비 확인의 실패 등 여러 이유로 중단되거나 시작될 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;포드 집합과 통신하려고 하면?
    &lt;ul&gt;
      &lt;li&gt;다시 시작될 때는 다른 IP 주소가 할당될 수도 있는데, 이 떄 서비스를 사용함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서비스는 포드를 위한 안정적인 엔드포인트를 제공함&lt;/li&gt;
  &lt;li&gt;서비스는 라벨을 사용해 서비스가 수행될 포드를 판단
    &lt;ul&gt;
      &lt;li&gt;포드에 올바른 라벨이 있으면 서비스에서 자동으로 포드를 선택해 노출&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서비스가 포드 집합에 제공하는 액세스 수준은 서비스 유형에 따라 다름
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ClusterIP&lt;/code&gt;(내부) : 클러스터 내부에서만 볼 수 있음&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NodePort&lt;/code&gt; : 클러스터의 각 노드에 외부 액세스가 가능한 IP 제공&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LoadBalancer&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;서비스-만들기&quot;&gt;서비스 만들기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;서비스를 만들기 전에 https 트래픽을 처리할 수 있는 안전한 포드 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cd ~/orchestrate-with-kubernetes/kubernetes
  cat pods/secure-monolith.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl create secret generic tls-certs --from-file tls/
  kubectl create configmap nginx-proxy-conf --from-file nginx/proxy.conf
  kubectl create -f pods/secure-monolith.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서비스 구성 파일 탐색&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cat services/monolith.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kind: Service
  apiVersion: v1
  metadata:
    name: &quot;monolith&quot;
  spec:
    selector: # 포드를 자동으로 찾아 노출
      app: &quot;monolith&quot;
      secure: &quot;enabled&quot;
    ports:
      - protocol: &quot;TCP&quot;
        port: 443
        targetPort: 443
        nodePort: 31000 # 31000에서 443로 외부 트래픽 전송
    type: NodePort
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모놀리식 서비스 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl create -f services/monolith.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;service “monolith” created라는 출력은 포트를 사용해 서비스를 노출하고 있다는 의미&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;노출된 포트에서 트래픽 허용&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud compute firewall-rules create allow-monolith-nodeport \
--allow=tcp:31000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;curl&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  curl -k https://&amp;lt;EXTERNAL_IP&amp;gt;:31000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;시간이 초과됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;포드에-라벨-추가&quot;&gt;포드에 라벨 추가&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;현재 위 모놀리식 서비스에는 엔드포인트가 없음&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl get pods&lt;/code&gt; 명령과 라벨 쿼리를 사용해 문제를 해결할 수 있음&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get pods -l &quot;app=monolith&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;secure=enabled 추가&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get pods -l &quot;app=monolith,secure=enabled&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;누락된 secure=enabled 라벨을 포드에 추가&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl label pods secure-monolith 'secure=enabled'
  kubectl get pods secure-monolith --show-labels
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모놀리식 서비스의 엔드포인트 조회&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl describe services monolith | grep Endpoints
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이제 접근 가능&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  curl -k https://&amp;lt;EXTERNAL_IP&amp;gt;:31000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kubernetes를-사용한-애플리케이션-배포&quot;&gt;Kubernetes를 사용한 애플리케이션 배포&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;프러덕션 단계에서 컨테이너를 확장하고 관리하는 방법에 대해 배움&lt;/li&gt;
  &lt;li&gt;실행 중인 포드의 수가 사용자가 지정한 포드 개수와 일치하도록 보장&lt;/li&gt;
  &lt;li&gt;앱의 세 부분
    &lt;ul&gt;
      &lt;li&gt;1) 인증 : 인증된 사용자의 JWT 토큰 생성&lt;/li&gt;
      &lt;li&gt;2) 환영 : 인증된 사용자에게 인사&lt;/li&gt;
      &lt;li&gt;3) 프론트엔드 : 인증 및 환영 서비스로 트래픽 라우팅&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서비스마다 배포를 하나씩 생성
    &lt;ul&gt;
      &lt;li&gt;내부 서비스와 프론트엔드 배포의 외부 서비스를 정의할 예정&lt;/li&gt;
      &lt;li&gt;완료되면 모놀리식 앱에서처럼 마이크로 서비스와 상호 작용할 수 있음&lt;/li&gt;
      &lt;li&gt;각 부분의 독립적 확장 및 배포가 가능해짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포 객체 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl create -f deployments/auth.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;인증 배포 서비스 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl create -f services/auth.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;환영 배포를 만들고 노출&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl create -f deployments/hello.yaml
  kubectl create -f services/hello.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프론트엔드 배포 및 노출&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl create configmap nginx-frontend-conf --from-file=nginx/frontend.conf
  kubectl create -f deployments/frontend.yaml
  kubectl create -f services/frontend.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;외부 IP 확인 후 curl&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  kubectl get services frontend
  curl -k https://&amp;lt;EXTERNAL-IP&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;정리&quot;&gt;정리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;리소스 정리&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cat cleanup.sh
  chmod +x cleanup.sh
  ./cleanup.sh
	
  gcloud container clusters delete io --zone 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://google.qwiklabs.com/quests/29?qlcampaign=1s-seoul-0219&quot;&gt;Kubernetes in the Google Cloud Qwiklabs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 11 Jan 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/development/2019/01/11/kubernetes-and-deployment/</link>
        <guid isPermaLink="true">https://zzsza.github.io/development/2019/01/11/kubernetes-and-deployment/</guid>
        
        <category>kubernetes</category>
        
        
        <category>development</category>
        
      </item>
    
      <item>
        <title>디스크 캐싱과 레디스를 활용한 크롤링</title>
        <description>&lt;ul&gt;
  &lt;li&gt;캐싱을 사용해 크롤링하는 방법에 대해 작성한 글입니다
    &lt;ul&gt;
      &lt;li&gt;디스크 캐싱부터 레디스까지 다룹니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;관련 코드는 &lt;a href=&quot;https://github.com/zzsza/TIL/tree/master/python/crawling&quot;&gt;Github&lt;/a&gt;에 있습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;캐싱을-사용해야-하는-경우&quot;&gt;캐싱을 사용해야 하는 경우&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;캐싱 오프라인 상태(데이터 분석 또는 개발 목적)에서 웹 페이지에 접근할 수 있도록 하기 때문에 사용자에게 도움이 됨
    &lt;ul&gt;
      &lt;li&gt;가장 최신 정보나 현재 정보를 얻는 것이 최우선이면 캐싱이 적합하지 않을 수 있음&lt;/li&gt;
      &lt;li&gt;대규모 크롤링이나 반복적인 크롤링을 계획하지 않으면 매번 페이지를 스크래핑하고 싶음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;캐싱을 구현하기 전에 얼마나 자주 페이지를 스크래핑할지, 얼마나 자주 새로운 페이지를 스크래핑할지, 얼마나 자주 캐싱을 삭제해야 할지 등에 대해 생각해야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;링크-크롤러에-캐싱-기능-추가하기&quot;&gt;링크 크롤러에 캐싱 기능 추가하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;URL을 다운로드하기 전에 캐싱을 확인
    &lt;ul&gt;
      &lt;li&gt;download 함수 안, 다운로드할 경우 쓰로틀링(Throtting)을 조절&lt;/li&gt;
      &lt;li&gt;매번 다운로드할 때 매개 변수를 전달할 필요가 없도록 클래스로 구현&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;설명
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__call__&lt;/code&gt; 메소드
        &lt;ul&gt;
          &lt;li&gt;이 클래스의 객체가 함수처럼 호출되면 실행되는 함수&lt;/li&gt;
          &lt;li&gt;다운로드 전에 캐싱을 확인(캐싱은 딕셔너리)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# throttle.py
from urllib.parse import urlparse
import time


class Throttle:
    &quot;&quot;&quot; Add a delay between downloads to the same domain
    &quot;&quot;&quot;
    def __init__(self, delay):
        # amount of delay between downloads for each domain
        self.delay = delay
        # timestamp of when a domain was last accessed
        self.domains = {}

    def wait(self, url):
        domain = urlparse(url).netloc
        last_accessed = self.domains.get(domain)

        if self.delay &amp;gt; 0 and last_accessed is not None:
            sleep_secs = self.delay - (time.time() - last_accessed)
            if sleep_secs &amp;gt; 0:
                # domain has been accessed recently
                # so need to sleep
                time.sleep(sleep_secs)
        # update the last accessed time
        self.domains[domain] = time.time()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from random import choice
import requests

from throttle import Throttle


class Downloader:
    def __init__(self, delay=5, user_agent='wswp', proxies=None, cache={}, timeout=60):
        self.throttle = Throttle(delay)
        self.user_agent = user_agent
        self.proxies = proxies
        self.cache = cache
        self.num_retries = None
        self.timeout = timeout

    def __call__(self, url, num_retries=2):
        self.num_retries = num_retries
        try:
            result = self.cache[url]
            print('Loaded from cache:', url)
        except KeyError:
            result = None
        if result and self.num_retries and 500 &amp;lt;= result['code'] &amp;lt; 600:
            # 캐싱 결과가 서버 에러면 무시하고 다운로드를 재시도            
            result = None
        if result is None:
		     # 캐싱에서 결과를 로드하지 않아 다운로드
            self.throttle.wait(url)
            proxies = choice(self.proxies) if self.proxies else None
            headers = {'User-Agent': self.user_agent}
            result = self.download(url, headers, proxies)
            self.cache[url] = result
        return result['html']

    def download(self, url, headers, proxies):
        print('Downloading:', url)
        try:
            resp = requests.get(url, headers=headers, proxies=proxies,
                                timeout=self.timeout)
            html = resp.text
            if resp.status_code &amp;gt;= 400:
                print('Download error:', resp.text)
                html = None
                if self.num_retries and 500 &amp;lt;= resp.status_code &amp;lt; 600:
                    # recursively retry 5xx HTTP errors
                    self.num_retries -= 1
                    return self.download(url, headers, proxies)
        except requests.exceptions.RequestException as e:
            print('Download error:', e)
            return {'html': None, 'code': 500}
        return {'html': html, 'code': resp.status_code}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;디스크-캐싱&quot;&gt;디스크 캐싱&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;urlsplit&lt;/code&gt; 함수를 사용해 URL 파싱&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from urllib.parse import urlsplit
  component = urlsplit(&quot;https://www.google.com/webhp&quot;)
  print(component)
  &amp;gt;&amp;gt;&amp;gt; SplitResult(scheme='https', netloc='www.google.com', path='/webhp', query='', fragment='')
  print(component.path)
  &amp;gt;&amp;gt;&amp;gt; /webhp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;filename 지정&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  if not path.enswith('/'):
      path += '/index.html'
  elif path.enswith('/'):
      path += 'index.html'
  filename = component.netloc + path + components.query
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__getitem__&lt;/code&gt; 메소드
    &lt;ul&gt;
      &lt;li&gt;item을 get&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__setitem__&lt;/code&gt; 메소드
    &lt;ul&gt;
      &lt;li&gt;item을 set&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;캐싱-테스트하기&quot;&gt;캐싱 테스트하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;diskcache.py, advanced_linke_cralwer&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from diskcache import DiskCache
  from advanced_link_crawler import link_crawler
	
  link_crawler('http://example.webscraping.com/places/default', '.*/(index|view)/.*', cache=DiskCache())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;첫 실행시 2분정도 소요되지만 다시 실행하면 1초만에 종료! (캐싱!)&lt;/li&gt;
  &lt;li&gt;디스크 공간 절약하기 위해 압축(zlib 사용)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;오래된-캐싱-데이터-만료하기&quot;&gt;오래된 캐싱 데이터 만료하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;디스크 캐시의 현재 버전은 키 값을 디스크에 저장한 후 나중에 이 키를 요청할 때마다 다 값을 리턴&lt;/li&gt;
  &lt;li&gt;웹 페이지 컨텐츠가 변경되면 캐싱 데이터가 만료돼 적합하지 않을 수 있음
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__set__&lt;/code&gt; 메소드는 만료 타임 스탬프를 키로 result 딕셔너리에 저장하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;__get__&lt;/code&gt; 메소드는 현재 UTC 시간을 만료 시간과 비교&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;diskcache의-단점&quot;&gt;DiskCache의 단점&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;URL에서 지원되지 않는 문자를 사용할 경우 다른 URL이 동일한 파일 이름으로 매핑됨&lt;/li&gt;
  &lt;li&gt;서로 다른 255자가 넘는 긴 URL의 단축 버전은 동일한 파일 이름으로 매핑
    &lt;ul&gt;
      &lt;li&gt;URL 길이 제한을 피하기 위해 URL의 해시를 얻은 후 해당 해시를 파일 이름으로 사용&lt;/li&gt;
      &lt;li&gt;파일시스템이 가지는 문제, FAT32 파일시스템이면 디렉터리당 허용되는 최대 파일 수는 65,535개, 이럴 경우 디렉터리를 분할&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;레디스를-사용한-캐싱&quot;&gt;레디스를 사용한 캐싱&lt;/h2&gt;
&lt;h3 id=&quot;key-value-저장소-캐싱&quot;&gt;key-value 저장소 캐싱&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;크롤링할 때 대량의 데이터를 캐싱해야 할 경우 key-value store를 사용&lt;/li&gt;
  &lt;li&gt;파이썬 딕셔너리와 매우 흡사
    &lt;ul&gt;
      &lt;li&gt;저장소의 각 엘리먼트에는 key, value가 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;레디스 : REmote DIctionary Server의 약자&lt;/li&gt;
  &lt;li&gt;트위터에서 레디스를 대용량 스토리지로 사용&lt;/li&gt;
  &lt;li&gt;크롤링하고 추가 정보나 검색이 필요하면 ElasticSearch 또는 MongoDB 사용하는 것을 추천&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;레디스-설치&quot;&gt;레디스 설치&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# In mac
brew install redis
# python library
pip3 install redis
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;레디스 서버 실행&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  redis-server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;레디스 사용하기
    &lt;ul&gt;
      &lt;li&gt;레디스 3.0부터 dict 타입을 바로 넣을 수 없고, byte나 string으로 변경해야 들어감&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import redis
  import json
	
  r = redis.StrictRedis(host='localhost', port=6379, db=0)
  r.set('test', 'answer')
  &amp;gt;&amp;gt;&amp;gt; b'True
  r.get('test')
  &amp;gt;&amp;gt;&amp;gt; b'answer'
  url = 'http://example.webscraping.com/places/default/view/United-Kingdom-239'
  html = '...'
	
  results = {'html': html, 'code': 200}
  results = json.dumps(results).encode('utf-8')
  r.set(url, results)
  r.get(url)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컨텐츠 업데이트하기&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  r.set(url, b'{&quot;html&quot;: &quot;new html&quot;, &quot;code&quot;: 200}')
  r.get(url)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컨텐츠 살펴보고 삭제&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  r.keys()
  r.delete('test')
  r.keys()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;레디스-캐싱-구현&quot;&gt;레디스 캐싱 구현&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__getitem__&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  def __getitem__(self, url):
      record = self.client.get(url)
      if record:
          if self.compress:
              record = zlib.decompress(record)
          return json.loads(record.decode(self.encoding))
      else:
          raise KeyError(url + ' does not exist')	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__setitem__&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  def __setitem__(self, url, result):
      data = bytes(json.dumps(result), self.encoding)
      if self.compress:
          data = zlib.compress(data)
      self.client.setex(url, self.expires, data)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setex&lt;/code&gt; 메소드
    &lt;ul&gt;
      &lt;li&gt;datetime.timedelta 또는 초 값을 받음&lt;/li&gt;
      &lt;li&gt;지정된 시간 내 레코드를 자동으로 삭제할 수 있는 메소드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;캐싱 테스트&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from rediscache import RedisCache
  from advanced_link_crawler import link_crawler
	
  link_crawler('http://example.webscraping.com/places/default', '.*/(index|view)/.*', cache= RedisCache())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;requests-cache 탐색
    &lt;ul&gt;
      &lt;li&gt;경우에 따라 내부적으로 requests를 사용하는 라이브러리를 캐싱하거나 캐싱 클래스를 직접 처리하고 싶지 않을 경우 사용&lt;/li&gt;
      &lt;li&gt;requests를 통해 URL에 접근하는 모든 get 요청은 먼저 캐싱 확인하고 캐싱이 없는 경우에만 페이지 요청&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;설치&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pip3 install requests-cache
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;캐싱 여부 확인 및 만료 설정&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import requests_cache
  import requests
  from datetime import timedelta
  requests_cache.install_cache(backend='redis')
  requests_cache.clear()
		
  url = 'http://example.webscraping.com/places/default/view/239'
  resp = requests.get(url)
  resp.from_cache
  &amp;gt;&amp;gt;&amp;gt; False
  resp = requests.get(url)
  resp.from_cache
  &amp;gt;&amp;gt;&amp;gt; True
  # 만료 설정
  requests_cache.install_cache(backend='redis', expire_after=timedelta(days=30))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;레디스는 메세지를 주고받는 PubSub도 지원하니 참고하면 좋을듯 :)&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 08 Jan 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/development/2019/01/08/crawling-with-caching/</link>
        <guid isPermaLink="true">https://zzsza.github.io/development/2019/01/08/crawling-with-caching/</guid>
        
        <category>python</category>
        
        
        <category>development</category>
        
      </item>
    
      <item>
        <title>Reinforcement Learning 3강. Planning by Dynamic Programming</title>
        <description>&lt;ul&gt;
  &lt;li&gt;David Silver의 Reinforcement Learning 강의를 한국어로 해설해주는 팡요랩 영상을 보고 메모한 자료입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Planning
    &lt;ul&gt;
      &lt;li&gt;MDP에 대한 모든 정보를 알 때(=Environment, State) 더 나은 policy를 찾아가는 과정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Policy Evaluation
    &lt;ul&gt;
      &lt;li&gt;policy가 고정되었을 때 value function을 찾는 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dynamic-programming&quot;&gt;Dynamic Programming&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;복잡한 문제를 푸는 방법
    &lt;ul&gt;
      &lt;li&gt;큰 문제를 작은 문제로 나누고 작은 문제에 대해 솔루션을 찾고 다 모아서 큰 문제를 품&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;강화 학습
    &lt;ul&gt;
      &lt;li&gt;Model Free : environment가 어떤 것을 던져줄지 모를 경우(완전한 정보가 없을 경우)&lt;/li&gt;
      &lt;li&gt;Model based : environment에 대한 모델이 있는 경우
        &lt;ul&gt;
          &lt;li&gt;이 문제를 해결할 때 Planning, dynamic programming이 쓰임&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Dynamic Programming의 조건
    &lt;ul&gt;
      &lt;li&gt;1) Optimal substructure
        &lt;ul&gt;
          &lt;li&gt;작은 문제로 나뉠 수 있어야 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) Overlapping subproblems
        &lt;ul&gt;
          &lt;li&gt;한 서브 문제를 풀고 나온 솔루션을 저장해(cached) 다시 사용할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;MDP는 이 조건을 만족함
        &lt;ul&gt;
          &lt;li&gt;Bellman 방정식이 recursive&lt;/li&gt;
          &lt;li&gt;value function이 작은 문제들의 해&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;planning-by-dynamic-programming&quot;&gt;Planning by Dynamic Programming&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DP는 MDP에 대해 모두 알고 있다고 가정함
    &lt;ul&gt;
      &lt;li&gt;State transaction, reward, …&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2가지 문제가 있음&lt;/li&gt;
  &lt;li&gt;1) For prediction
    &lt;ul&gt;
      &lt;li&gt;value function을 학습하는 것&lt;/li&gt;
      &lt;li&gt;MDP가 있고 policy가 있을 때 그 policy를 따를 경우의 value function&lt;/li&gt;
      &lt;li&gt;poliy evaluation&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2) For control
    &lt;ul&gt;
      &lt;li&gt;optimal policy를 찾는 것&lt;/li&gt;
      &lt;li&gt;MDP만 있고 optimal policy를 찾음&lt;/li&gt;
      &lt;li&gt;policy iteration, value iteration&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;policy-evaluation&quot;&gt;Policy Evaluation&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;이 policy를 따라갔을 때, return을 얼마 받는가?
    &lt;ul&gt;
      &lt;li&gt;policy를 평가함 즉, value function을 찾는 문제&lt;/li&gt;
      &lt;li&gt;Bellman expectation backup을 사용해서 계속 적용&lt;/li&gt;
      &lt;li&gt;backup
        &lt;ul&gt;
          &lt;li&gt;메모리에 저장&lt;/li&gt;
          &lt;li&gt;synchronous backup&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예시
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/i3mbzubjmar4np2/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-01-06%2020.43.19.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;MDP가 있고 policy가 있을 떄 value를 찾는 prediction 문제&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/lkrwgtfzmtcatip/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-01-06%2020.50.03.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;주어진 바보같은 policy를 평가만 했을 뿐인데 평가된 value에서 greedy하게 움직이면 optimal policy가 찾을 수 있음&lt;/li&gt;
      &lt;li&gt;모든 문제에서 이게 됨! 신기&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ibqizz7r1gqyfyu/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-01-06%2020.50.12.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;무한하게 갈 필요가 없음! 평가하게 greedy하게 움직이는 것을 만들자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;policy-iteration&quot;&gt;Policy Iteration&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Evaluate the policy(value function을 찾고)&lt;/li&gt;
  &lt;li&gt;Improve the policy by acting reddily(value function에 대해 greedy하게 움직이는 새로운 policy를 만들면)&lt;/li&gt;
  &lt;li&gt;이 Evaluate, Improve를 반복하면 converge됨&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/bmhwna2bolulukt/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-01-06%2020.59.53.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;예제
    &lt;ul&gt;
      &lt;li&gt;Jack’s Car Rental&lt;/li&gt;
      &lt;li&gt;좋은 문제인진 모름..&lt;/li&gt;
      &lt;li&gt;최대 20곳의 차가 있을 수 있음&lt;/li&gt;
      &lt;li&gt;A는 포아송 분포로 차가 옴&lt;/li&gt;
      &lt;li&gt;A에서 B로 B에서 A로 자꾸 차를 옮겨야 함&lt;/li&gt;
      &lt;li&gt;하나 빌릴때 10달러&lt;/li&gt;
      &lt;li&gt;policy를 추측할 수 있음&lt;/li&gt;
      &lt;li&gt;b는 수요가 더 많음&lt;/li&gt;
      &lt;li&gt;a에서 차가 적어도 어쩔 경우엔 b로 옮기는 것이 나을 수 있음&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/cjvoof54qgcfzz6/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-01-06%2021.03.06.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;x축 : b 지점에 있는 차의 수, y축 : a 지점에 있는 차의 수&lt;/li&gt;
      &lt;li&gt;iteration하면 수렴한다! 정도의 감만 잡으면 ok&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;증명
    &lt;ul&gt;
      &lt;li&gt;무조건 이전 policy보다 좋은가?
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9p7vbp1beduchf2/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-01-06%2021.06.54.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;수렴 포인트는 optimal
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/twxdck9vnx9xwvb/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-01-06%2021.16.09.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Modified Policy Iteration
    &lt;ul&gt;
      &lt;li&gt;꼭 수렴할 때까지 해야되는가? 일찍 끝내면 안되는가&lt;/li&gt;
      &lt;li&gt;k번만 하고 evaluation, improve해도 되지 않는가?&lt;/li&gt;
      &lt;li&gt;이렇게 해도 합리적임!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;value-iteration&quot;&gt;Value Iteration&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Principle of Optimality&lt;/li&gt;
  &lt;li&gt;Deterministic Value Iteration
    &lt;ul&gt;
      &lt;li&gt;서브 프러블럼의 솔루션을 알면 Bellman Optimality Equation을 이용해 s에서의 솔루션을 구할 수 있음&lt;/li&gt;
      &lt;li&gt;바로 이전 점에서 목적지까지 최단 거리를 구함. 그 전에서 구함.. 반복&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;value만 가지고 놈(value만 이터레이티브하게 update)
    &lt;ul&gt;
      &lt;li&gt;policy 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예시
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/3j137c7ircelb0n/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-01-06%2021.30.38.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;한 스텝들은 bellman optimality equation을 이용해 품&lt;/li&gt;
      &lt;li&gt;끝이란 것을 알 수 없어서 모두 다 돌아야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/olfkhs2ru5u9luf/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-01-06%2021.34.19.png?raw=1&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;잠시-정리&quot;&gt;잠시 정리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9mm63y9c5ro56a7/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202019-01-06%2021.37.19.png?raw=1&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;asynchronous-dynamic-programming&quot;&gt;Asynchronous Dynamic Programming&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;여태 나온 DP 방법들은 모든 stete들이 parallel되게 하는 synchronous backup을 사용했음&lt;/li&gt;
  &lt;li&gt;어떤 state만 하거나 순서를 다르게 하는 asynchronous한 방법을 이용하면 computation을 줄일 수 있음&lt;/li&gt;
  &lt;li&gt;모든 state가 골고루 뽑히면 수렴&lt;/li&gt;
  &lt;li&gt;방법론
    &lt;ul&gt;
      &lt;li&gt;In-place dynamic programming
        &lt;ul&gt;
          &lt;li&gt;코딩 테크닉&lt;/li&gt;
          &lt;li&gt;state가 n개 있으면 table이 있어야 함
            &lt;ul&gt;
              &lt;li&gt;이전 step의 테이블 정보와 새로운 table&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;inplace는 하나만 가지고 있음!&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Proritised sweeping
        &lt;ul&gt;
          &lt;li&gt;순서를 중요한 친구 먼저!&lt;/li&gt;
          &lt;li&gt;중요한 정의 : bellman error가 큰 것&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Real-time dynamic programming
        &lt;ul&gt;
          &lt;li&gt;state space가 넓고 agent가 가는 곳은 한정적일 경우 agent를 움직이게 하고 정해진 곳을 방문하면 update&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Full-width Backups
    &lt;ul&gt;
      &lt;li&gt;DP는 full-width backup을 사용&lt;/li&gt;
      &lt;li&gt;큰 문제에선 DP를 사용할 수 없음(차원의 저주..)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Sample Backups
    &lt;ul&gt;
      &lt;li&gt;state가 많아도 고정된 cost로 할 수 있음&lt;/li&gt;
      &lt;li&gt;model free에서도 할 수 있음
        &lt;ul&gt;
          &lt;li&gt;오늘은 model based를 생각했었음.&lt;/li&gt;
          &lt;li&gt;model free는 어디로 갈 지 모르는 상황, 액션을 하며 샘플!&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=wYgyiCEkwC8&quot;&gt;팡요랩&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 06 Jan 2019 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/data/2019/01/06/dynamic-programming/</link>
        <guid isPermaLink="true">https://zzsza.github.io/data/2019/01/06/dynamic-programming/</guid>
        
        <category>rl</category>
        
        
        <category>data</category>
        
      </item>
    
      <item>
        <title>머신러닝 오퍼레이션 자동화, MLOps</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Euroscipy 2018에서 진행한 &lt;a href=&quot;https://axsauze.github.io/scalable-data-science/#/&quot;&gt;Scalable Data Science: The State of MLOps in 2018&lt;/a&gt; 발표 자료를 보며 정리한 내용입니다&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/EthicalML/awesome-machine-learning-operations&quot;&gt;awesome-machine-learning-operations&lt;/a&gt; Repo에 엄청 좋은 자료들이 가득합니다 :)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ML + DevOps = MLOps&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터 사이언스는 2개의 workflow로 일반화됨
    &lt;ul&gt;
      &lt;li&gt;Model Development&lt;/li&gt;
      &lt;li&gt;Model Serving(Prediction)&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/xymkubjqfhr8rv0/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-12-27%2023.38.48.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;만약 팀이 작을 경우
    &lt;ul&gt;
      &lt;li&gt;유지할 수 있는 소수의 모델&lt;/li&gt;
      &lt;li&gt;데이터 과학자들이 머리속에 모델에 대해 기억할 수 있음&lt;/li&gt;
      &lt;li&gt;각자 진행 상황을 추적할 수 있는 방법이 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그러나 팀이 점점 성장하면 생기는 이슈들
    &lt;ul&gt;
      &lt;li&gt;1) Data 흐름의 복잡도 증가
        &lt;ul&gt;
          &lt;li&gt;데이터 처리 workflow가 많음&lt;/li&gt;
          &lt;li&gt;표준화된 흔적 없이 데이터가 수정됨&lt;/li&gt;
          &lt;li&gt;flow와 스케쥴의 복잡성을 관리하는 것이 점점 힘듬&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) 각자 선호하는 도구가 다름
        &lt;ul&gt;
          &lt;li&gt;Tensorflow, R, Spark, Keras, PyTorch, MXNet 등&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;3) Serving model은 점점 어려워짐
        &lt;ul&gt;
          &lt;li&gt;다른 환경에서 실행되는 다른 모델 버전&lt;/li&gt;
          &lt;li&gt;모델 배포 및 복귀(롤백)가 더 복잡해짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;4) 무엇이 잘못되었는지 추적하기 힘듬
        &lt;ul&gt;
          &lt;li&gt;데이터 과학자들은 파이프라인 버그라고 하는데&lt;/li&gt;
          &lt;li&gt;데이터 엔지니어는 모델의 문제라고 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;직군별-task&quot;&gt;직군별 Task&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Data Scientist
    &lt;ul&gt;
      &lt;li&gt;모델 개발&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data Engineer
    &lt;ul&gt;
      &lt;li&gt;데이터 파이프라인 개발&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DEVOPS / DATAOPS / MLOPS Engineer
    &lt;ul&gt;
      &lt;li&gt;모델, 데이터 파이프라인 및 Production 부분 담당&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;컨셉&quot;&gt;컨셉&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/j0mu9jojze3pt9m/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-12-28%2000.09.36.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;모델(이나 기술)이 성장하며 인프라를 사용해야 함&lt;/li&gt;
  &lt;li&gt;ML-Ops의 2가지 원칙
    &lt;ul&gt;
      &lt;li&gt;Reproducibility ( 재현성 )&lt;/li&gt;
      &lt;li&gt;Orchestration  ( 배치/정렬 자동화 )&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;원칙-1-model--data-versioning&quot;&gt;원칙	1. MODEL &amp;amp; DATA VERSIONING&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;각 단계별 특정한 data in/out이 있고, code나 config가 존재
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/rt0r2l9n05ngu9x/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-12-28%2000.14.35.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;추상화하면
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/u8if1qukz8rtfkv/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-12-28%2000.15.18.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Data cleaning, Feature Generator, Model&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;재현성이 가능하게 해주는 것
    &lt;ul&gt;
      &lt;li&gt;오류를 디버깅할 때 추적 가능&lt;/li&gt;
      &lt;li&gt;결과가 균일&lt;/li&gt;
      &lt;li&gt;재사용할 수 있도록 컴포넌트 모듈화&lt;/li&gt;
      &lt;li&gt;여러 라이브러리를 추상화&lt;/li&gt;
      &lt;li&gt;이전 릴리즈로 되돌아 가야 할 경우 재현&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;원칙-2-model-deployment-orchestration&quot;&gt;원칙 2. MODEL DEPLOYMENT ORCHESTRATION&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Production에서 모델 serving의 복잡도를 다룸&lt;/li&gt;
  &lt;li&gt;CI / CD / 모니터링과 유사하나 완벽히 다름&lt;/li&gt;
  &lt;li&gt;모니터링
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/qpnpf4peqdmzsn8/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-12-28%2000.21.21.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;모델의 Quality Control 과정은 반드시 필수!!!!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Compliance
    &lt;ul&gt;
      &lt;li&gt;언제 무엇이 왜 어떻게 발생했는지?&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://youtu.be/eOzl-LFqYFM?t=366&quot;&gt;Guidelines for and properties of compliant ML&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/6rxn1jtaujoye95/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-12-28%2000.23.55.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;오류를 찾거나 디버깅, 중요한 이슈 report 등이 가능해짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컴퓨터 자원 할당
    &lt;ul&gt;
      &lt;li&gt;다양한 계산 그래프가 있는 경우 적절한 리소스를 할당해야 함&lt;/li&gt;
      &lt;li&gt;아래와 같은 소프트웨어에서 가능
        &lt;ul&gt;
          &lt;li&gt;ETL framework&lt;/li&gt;
          &lt;li&gt;HDFS-based service&lt;/li&gt;
          &lt;li&gt;Kubernetes cluster&lt;/li&gt;
          &lt;li&gt;Distributed framework&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;자원 할당이 만드는 차이
   	- 기존(전통) 서버 할당과 비교 가능
        &lt;ul&gt;
          &lt;li&gt;auto scale&lt;/li&gt;
          &lt;li&gt;serverless&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;existing-tools&quot;&gt;Existing Tools&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/EthicalML/awesome-machine-learning-operations&quot;&gt;Github&lt;/a&gt; 참고&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pmml&quot;&gt;PMML&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/jpmml/jpmml-sklearn&quot;&gt;sklearn2pmml Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Storage 및 serialisation을 위한 기계학습 모델 파이프라인을 표현하는 방법&lt;/li&gt;
  &lt;li&gt;여러 시스템이 이 방법으로 플랫폼간 모델 전송&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from sklearn import datasets, tree
iris = datasets.load_iris()
clf = tree.DecisionTreeClassifier()
clf = clf.fit(iris.data, iris.target)

from sklearn_pandas import DataFrameMapper
default_mapper = DataFrameMapper(
    [(i, None) for i in iris.feature_names + ['Species']])

from sklearn2pmml import sklearn2pmml
sklearn2pmml(estimator=clf,
             mapper=default_mapper,
             pmml=&quot;D:/workspace/IrisClassificationTree.pmml&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;data-version-controldvc&quot;&gt;DATA VERSION CONTROL(DVC)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://dvc.org/&quot;&gt;link&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;데이터 과학 프로젝트를 위한 버전 컨트롤 시스템&lt;/li&gt;
  &lt;li&gt;iterative.ai에 의해 빌드된 git fork는 데이터, config, 코드를 그룹화할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# add your data
dvc add images.zip

# connect data input, model output and code
dvc run -d images.zip -o modl.p ./cnn.py

# add repository location (s3)
dvc remote add myrepo s3://mybucket

# push to the location specified
dvc push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;modeldb&quot;&gt;ModelDB&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mitdbg.github.io/modeldb/&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;함수 자체를 확장해 라이브러리 수준에서 input, output, config를 추적하는 암묵적인 방법&lt;/li&gt;
  &lt;li&gt;사용된 모든 단계와 모델 결과, prediction을 저장&lt;/li&gt;
  &lt;li&gt;저장된 모델을 사용 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def fit_and_predict(data):
    model.fit_sync(data)
    preprocessor.transform_sync(data)
    model.predict_sync(data)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;pachyderm&quot;&gt;PACHYDERM&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/pachyderm/pachyderm&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;재현 가능한 파이프라인 정의를 허용하는 End to End 모델 버전 관리 프레임워크&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# create a repo
$ pachctl create-repo training
$ pachctl list-repo
NAME                CREATED             SIZE
training            2 minutes ago       0 B

# commit data (with -c flag) into the repo
$ pachctl put-file training master -c -f data/iris.csv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Build
# pytrain.py

...import dependencies

cols = [ &quot;Sepal_Length&quot;, &quot;Sepal_Width&quot;, &quot;Petal_Length&quot;, &quot;Petal_Width&quot;, &quot;Species&quot; ]
features = [ &quot;Sepal_Length&quot;, &quot;Sepal_Width&quot;, &quot;Petal_Length&quot;, &quot;Petal_Width&quot; ]

# Load training data
irisDF = pd.read_csv(os.path.join(&quot;/pfs/training&quot;, 
    &quot;iris.csv&quot;), names=cols)

svc = svm.SVC(kernel='linear', C=1.0).fit(
    irisDF[features], irisDF[&quot;Species&quot;])

# Save model to pachyderm /pfs/out
joblib.dump(svc, os.path.join(&quot;/pfs/out&quot;, 'model.pkl'))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# dockerfile
FROM ubuntu:14.04

...install dependencies 

# Add our own code.
WORKDIR /code
ADD pytrain.py /code/pytrain.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# computational pipeline 정의
{
  &quot;pipeline&quot;: {
    &quot;name&quot;: &quot;model&quot;
  },
  &quot;transform&quot;: {
    &quot;image&quot;: &quot;pachyderm/iris-train:python-svm&quot;,
    &quot;cmd&quot;: [&quot;python3&quot;, &quot;/code/pytrain.py&quot;,]
  },
  &quot;input&quot;: {
    &quot;atom&quot;: {
      &quot;repo&quot;: &quot;training&quot;,
      &quot;glob&quot;: &quot;/&quot;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/eju22ajmnzjowcj/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-12-28%2000.39.40.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;orchestration을-위한-도구&quot;&gt;ORCHESTRATION을 위한 도구&lt;/h2&gt;
&lt;h3 id=&quot;mleap&quot;&gt;MLeap&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/combust/mleap&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;모델 직렬화에 대한 깊은 다이빙&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# run the server
$ docker run \ 
    -p 65327:65327 \
    -v /tmp/models:/models \
    combustml/mleap-serving:0.9.0
    
# load a model 
curl -XPUT -H &quot;content-type: application/json&quot; \
  -d '{&quot;path&quot;:&quot;/models/&amp;lt;my model&amp;gt;.zip&quot;}' \
  http://localhost:65327/model   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;seldon-core&quot;&gt;Seldon-core&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/SeldonIO/seldon-core&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/d88xot3d4mn5o1u/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-12-28%2000.42.50.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ezeo6uaz0mz8dtb/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-12-28%2000.43.02.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/nb80xjjjuk5mvoi/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-12-28%2000.43.21.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/gsn96o6qe9kk6n1/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-12-28%2000.43.34.png?raw=1&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 28 Dec 2018 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/mlops/2018/12/28/mlops/</link>
        <guid isPermaLink="true">https://zzsza.github.io/mlops/2018/12/28/mlops/</guid>
        
        <category>basic</category>
        
        
        <category>mlops</category>
        
      </item>
    
      <item>
        <title>Reinforcement Learning 2강. MDP</title>
        <description>&lt;ul&gt;
  &lt;li&gt;David Silver의 Reinforcement Learning 강의를 한국어로 해설해주는 팡요랩 영상을 보고 메모한 자료입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2강-markov-decision-process&quot;&gt;2강. Markov Decision Process&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;MDP&lt;/li&gt;
  &lt;li&gt;강화학습이 적용되는 도메인이 다 MDP&lt;/li&gt;
  &lt;li&gt;MDP에서 최적의 Sequential한 Decision Making을 어떻게 풀어나갈 것이냐? ← 강화학습이 풀고자 하는 문제&lt;/li&gt;
  &lt;li&gt;MDP가 무엇인지, 어떤 용어와 개념이 있는지 차근차근 배울 예정&lt;/li&gt;
  &lt;li&gt;이전 history를 버리고 state만 기억하면 될 경우 markov property&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Markov Process&lt;/li&gt;
  &lt;li&gt;Markov Reward Processes&lt;/li&gt;
  &lt;li&gt;Markov Decision Processes&lt;/li&gt;
  &lt;li&gt;순으로 진행하고&lt;/li&gt;
  &lt;li&gt;Extensions to mdps는 실버 강의에서 다루지 않아서 패스!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;introduction-to-mdps&quot;&gt;Introduction to MDPs&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Markov decision process는 RL에서 환경을 표현
    &lt;ul&gt;
      &lt;li&gt;Environment는 모두 관측가능한 상황!&lt;/li&gt;
      &lt;li&gt;즉, 현재 state가 프로세스의 특징을 완전히 나타냄&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;대부분의 RL 문제는 MDP 형태로 만들 수 있음
    &lt;ul&gt;
      &lt;li&gt;Optimal control 문제를 continuous MDP로 다루고&lt;/li&gt;
      &lt;li&gt;Bandit 문제도 1 state를 가진 MDP&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;markov-property&quot;&gt;Markov Property&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;The future is independent of the past given the present&lt;/li&gt;
  &lt;li&gt;
    &lt;pre class=&quot;MathJax_Preview&quot;&gt;&lt;code&gt;P[S_{t+1}|S_{t}] = P[S_{t+1}|S_{1}, ..., S_{t}]&lt;/code&gt;&lt;/pre&gt;
    &lt;script type=&quot;math/tex; mode=display&quot;&gt;P[S_{t+1}|S_{t}] = P[S_{t+1}|S_{1}, ..., S_{t}]&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;State가 모든 관련된 정보를 가지고 있어서 state만 필요할 뿐&lt;/li&gt;
  &lt;li&gt;The state is a sufficient statistic of the future&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;state-transition-matrix&quot;&gt;State Transition Matrix&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Environment를 설명할 때 필요하는 것들&lt;/li&gt;
  &lt;li&gt;시간 t일때 s에 있고 액션이 없음. 다음 스텝으로 옮길 때 (t+1) 여러 액션으로 전이할 확률
    &lt;ul&gt;
      &lt;li&gt;s에서 s 프라임으로 갈 확률&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;markov-processor-markov-chain&quot;&gt;Markov Process(or Markov Chain)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;상태들이 N개 있음
    &lt;ul&gt;
      &lt;li&gt;discrete하게 뚝뚝 끊어지며 state를 움직임&lt;/li&gt;
      &lt;li&gt;계속 옮겨다님&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;memoryless random process
    &lt;ul&gt;
      &lt;li&gt;memoryless : 내가 어느 경로로 왔는지 상관 없이 이 곳에 도착하는 순간 미래가 정의&lt;/li&gt;
      &lt;li&gt;random process : 샘플링을 할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;S, P로 정의됨
    &lt;ul&gt;
      &lt;li&gt;S는 유한한 state들의 세트&lt;/li&gt;
      &lt;li&gt;P는 state transition probability matrix&lt;/li&gt;
      &lt;li&gt;어떤 조건을 만족하면 최종 분포가 stationary가 됨
        &lt;ul&gt;
          &lt;li&gt;1억명을 state에 두고 계속 전이하면.. staet마다 있는 수가 일정하게 됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Student Markov Chain
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/0zk2zlnlctv65dt/스크린샷 2018-12-26 23.42.39.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;에피소드를 샘플링한다는 표현을 쓸 예정&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/1vnb481bcgsgbqz/스크린샷 2018-12-27 00.36.41.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;샘플링을 한 것은 확률 변수가 있고 이벤트가 발생(시뮬레이션)&lt;/li&gt;
      &lt;li&gt;여기서 Transition Matrix로 표현하면&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/60ogvny0pjqvej8/스크린샷 2018-12-27 00.41.54.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;markov-reward-process&quot;&gt;Markov Reward Process&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Markov Process는 S, P만 있었는데 이젠 R, gamma가 추가됨&lt;/li&gt;
  &lt;li&gt;R은 reward funtion, 어떤 state에 도달하면 reward를 몇을 줘라! 이런 것을 정의
    &lt;ul&gt;
      &lt;li&gt;n개 있으면 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;gamma : discount factor, 0~1&lt;/li&gt;
  &lt;li&gt;state에만 reward를 줌&lt;/li&gt;
  &lt;li&gt;예시
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/8h3tcrmsjbcl39v/스크린샷 2018-12-27 00.54.20.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;return&quot;&gt;Return&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;강화학습은 Return을 maximize!
    &lt;ul&gt;
      &lt;li&gt;Reward랑 다름&lt;/li&gt;
      &lt;li&gt;Return은 total discounted reward from time step t&lt;/li&gt;
      &lt;li&gt;감가상각 개념! 미래..&lt;/li&gt;
      &lt;li&gt;감마가 0에 가까울수록 근시안(myopic), 1에 가까우면 큰 그림(far-sighted)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Discount를 꼭 해야 해?
    &lt;ul&gt;
      &lt;li&gt;솔직한 이유는 수학적으로 편리해서
        &lt;ul&gt;
          &lt;li&gt;Discount때문에 수렴성이 증명! 수렴해야 크고 작음을 표시할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;동물과 사람의 행동이 즉각적 리워드를 선호함&lt;/li&gt;
      &lt;li&gt;만약 모든 시퀀스가 종료되는 것이 보장되면 감마를 1로 해도 될 수 있음&lt;/li&gt;
      &lt;li&gt;문제에 따라 discount가 필요한 문제, 안 필요한 문제가 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;value-functionmrp&quot;&gt;Value Function(MRP)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Return의 기대값!&lt;/li&gt;
  &lt;li&gt;MRP에서 Value Function은 state에 왔을 때, 그 state에서 계속 샘플링하며 에피소드를 만들어감
    &lt;ul&gt;
      &lt;li&gt;에피소드마다 Return이 생김&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/zeqeb6m4y0actjb/스크린샷 2018-12-27 01.11.29.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;샘플링에 따라 return이 달라짐&lt;/li&gt;
      &lt;li&gt;return의 평균&lt;/li&gt;
      &lt;li&gt;State S에 왔을 때 G의 기대값(어느 정도의 return을 받을지 예측할 수 있음)
        &lt;ul&gt;
          &lt;li&gt;return을 &lt;code class=&quot;MathJax_Preview&quot;&gt;G_{t}&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;G_{t}&lt;/script&gt;로 표현, 확률 변수&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bellman-equation-for-mrps&quot;&gt;Bellman Equation for MRPs&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;정말 중요! Value based method에선 엄청 나옴&lt;/li&gt;
  &lt;li&gt;value funtion이 학습되는 것은 모두 벨만 방정식에 근거해서 학습&lt;/li&gt;
  &lt;li&gt;벨만 방정식
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/7hhu1dxg914pzoy/스크린샷 2018-12-27 01.20.45.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;감마로 묶어! &lt;code class=&quot;MathJax_Preview&quot;&gt;G_{t+1}&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;G_{t+1}&lt;/script&gt;이 v&lt;/li&gt;
      &lt;li&gt;점화식처럼 표현!&lt;/li&gt;
      &lt;li&gt;S에서 value는 한 스텝을 가고 + 다음 스테이트에서 value에 감마를 곱한 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;매트릭스 형태로 표현하면
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/j3yrlsfq2i6kmir/스크린샷 2018-12-27 01.32.11.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;식을 정리하면 &lt;code class=&quot;MathJax_Preview&quot;&gt;v = (1 - \gamma P)^{-1}R&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;v = (1 - \gamma P)^{-1}R&lt;/script&gt;
    &lt;ul&gt;
      &lt;li&gt;r, P, 감마가 주어지면 v를 구할 수 있음&lt;/li&gt;
      &lt;li&gt;계산 복잡도는 &lt;code class=&quot;MathJax_Preview&quot;&gt;O(n^{3})&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;O(n^{3})&lt;/script&gt;라서 비싼 연산&lt;/li&gt;
      &lt;li&gt;Direct solution은 오직 작은 MRP에서만 가능&lt;/li&gt;
      &lt;li&gt;큰 MRP의 경우 다른 방법
        &lt;ul&gt;
          &lt;li&gt;Dynamic programming&lt;/li&gt;
          &lt;li&gt;Monte-Carlo evaluation&lt;/li&gt;
          &lt;li&gt;Temporal Difference learning&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;markov-decision-process&quot;&gt;Markov Decision Process&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;MDP는 MRP에서 A(Action)이 추가됨&lt;/li&gt;
  &lt;li&gt;A : action들의 집합
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/olx2d9scqdorsnb/스크린샷 2018-12-27 22.18.36.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;action마다 reward가 주어짐&lt;/li&gt;
      &lt;li&gt;action을 하면 확률적으로 state로 가게 됨(그림에선 pub)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;state에 있으면 확률분포에 의해 넘겨줬는데, 이번엔 정책에 따라 액션이 달라짐&lt;/li&gt;
  &lt;li&gt;Policies
    &lt;ul&gt;
      &lt;li&gt;Plicy is a distribution over actions given states&lt;/li&gt;
      &lt;li&gt;
        &lt;pre class=&quot;MathJax_Preview&quot;&gt;&lt;code&gt;\pi (a|s) = P[A_{t}=a|S_{t}=s]&lt;/code&gt;&lt;/pre&gt;
        &lt;script type=&quot;math/tex; mode=display&quot;&gt;\pi (a|s) = P[A_{t}=a|S_{t}=s]&lt;/script&gt;
      &lt;/li&gt;
      &lt;li&gt;S_{t}에 있을 때 a를 할 확률&lt;/li&gt;
      &lt;li&gt;Agent의 행동을 정의해줌&lt;/li&gt;
      &lt;li&gt;현재 state만 있으면 됨(history 필요 없음)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;value-function&quot;&gt;Value Function&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;아깐 파이가 없었음
    &lt;ul&gt;
      &lt;li&gt;이젠 파이가 있어야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;어떤 스테이트에서 폴리피 파이를 끝까지 했을 때, 에피소드가 1개 나옴 ⇒ 여러개를 계속 뽑아서 샘플링 ⇒ 평균이 Value Function&lt;/li&gt;
  &lt;li&gt;State Value Function
    &lt;ul&gt;
      &lt;li&gt;input이 state 하나만 들어갈 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Action Value Function
    &lt;ul&gt;
      &lt;li&gt;input이 state, action이 들어갈 경우&lt;/li&gt;
      &lt;li&gt;
        &lt;pre class=&quot;MathJax_Preview&quot;&gt;&lt;code&gt;q_{\pi}(s,a) = E_{\pi}[G_{t}|S_{t}=s, A_{t}=a]&lt;/code&gt;&lt;/pre&gt;
        &lt;script type=&quot;math/tex; mode=display&quot;&gt;q_{\pi}(s,a) = E_{\pi}[G_{t}|S_{t}=s, A_{t}=a]&lt;/script&gt;
      &lt;/li&gt;
      &lt;li&gt;큐함수&lt;/li&gt;
      &lt;li&gt;큐러닝, DQN 모두 이걸 학습!&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/zn3or9mjt9tkcgt/스크린샷 2018-12-27 22.35.05.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bellman-expectation-equation&quot;&gt;Bellman Expectation Equation&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/7v06atucu757yqq/스크린샷 2018-12-27 22.38.41.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/44eqs973rz9kfe1/스크린샷 2018-12-27 22.49.47.png?raw=1&quot; /&gt;
    &lt;ul&gt;
      &lt;li&gt;s에서 a를 했을 떄, 파이를 따라서 게임을 끝까지 하면 얻을 return의 기대값
        &lt;ul&gt;
          &lt;li&gt;어떤 state에 떨어질지 모름. 모든 state에 갈 수 있음&lt;/li&gt;
          &lt;li&gt;각 state에 떨어질 확률가 그 state에서 value를 곱하고 더함&lt;/li&gt;
          &lt;li&gt;감마는 discount&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/d8gqa2w78uwlp42/스크린샷 2018-12-27 22.50.03.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;action을 어떻게 해야되는진 아직 배우지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;optimal-value-function&quot;&gt;Optimal Value Function&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Optimal state-value function
    &lt;ul&gt;
      &lt;li&gt;파이가 아닌 star로 표현&lt;/li&gt;
      &lt;li&gt;어떤 policy를 따르든(세상에 다양한 policy.. 무한의 value..) 그 중 제일 나은 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Optimal action-value function
    &lt;ul&gt;
      &lt;li&gt;할 수 있는 모든 policy를 따른 q 함수 중에 max&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;optimal value function을 아는 순간 MDP는 풀렸다(Solved)라고 함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;optimal-policy&quot;&gt;Optimal Policy&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;두 폴리시가 있을 때 하나가 나은지 비교&lt;/li&gt;
  &lt;li&gt;partial ordering
    &lt;ul&gt;
      &lt;li&gt;어떤 두개에 대해 이게 더 낫다고 존재한다고 할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;q star를 알고 그걸 따라가면 optimal policy다&lt;/li&gt;
  &lt;li&gt;MDP에선 deterministic optimal policy가 존재
    &lt;ul&gt;
      &lt;li&gt;deterministic! 가위바위보에 해당 ⇒ 무조건 가위만&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;solving-the-bellman-optimality-equation&quot;&gt;Solving the Bellman Optimality Equation&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;non-linear라서 closed form이 없음&lt;/li&gt;
  &lt;li&gt;많은 반복적 솔루션이 존재
    &lt;ul&gt;
      &lt;li&gt;Value Iteration&lt;/li&gt;
      &lt;li&gt;Policy Iteration&lt;/li&gt;
      &lt;li&gt;Q-learning&lt;/li&gt;
      &lt;li&gt;Sarsa&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=wYgyiCEkwC8&quot;&gt;팡요랩&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate>
        <link>https://zzsza.github.io/data/2018/12/27/mdp/</link>
        <guid isPermaLink="true">https://zzsza.github.io/data/2018/12/27/mdp/</guid>
        
        <category>rl</category>
        
        
        <category>data</category>
        
      </item>
    
  </channel>
</rss>
