<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Jitae Kim on Medium]]></title>
        <description><![CDATA[Stories by Jitae Kim on Medium]]></description>
        <link>https://medium.com/@originerd?source=rss-8b9a16d7f8ee------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*wPPdUvJ-P9e6_-Bos-kaqA.jpeg</url>
            <title>Stories by Jitae Kim on Medium</title>
            <link>https://medium.com/@originerd?source=rss-8b9a16d7f8ee------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Tue, 14 May 2019 05:37:15 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@originerd" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[재미있게 읽으셨다니 다행이네요. 감사합니다 :D]]></title>
            <link>https://medium.com/@originerd/%EC%9E%AC%EB%AF%B8%EC%9E%88%EA%B2%8C-%EC%9D%BD%EC%9C%BC%EC%85%A8%EB%8B%A4%EB%8B%88-%EB%8B%A4%ED%96%89%EC%9D%B4%EB%84%A4%EC%9A%94-%EA%B0%90%EC%82%AC%ED%95%A9%EB%8B%88%EB%8B%A4-d-e42efd5fc8a7?source=rss-8b9a16d7f8ee------2</link>
            <guid isPermaLink="false">https://medium.com/p/e42efd5fc8a7</guid>
            <dc:creator><![CDATA[Jitae Kim]]></dc:creator>
            <pubDate>Mon, 10 Apr 2017 02:48:42 GMT</pubDate>
            <atom:updated>2017-04-10T02:48:42.324Z</atom:updated>
            <content:encoded><![CDATA[<p>재미있게 읽으셨다니 다행이네요. 감사합니다 :D</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e42efd5fc8a7" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vue.js와 친해지기]]></title>
            <link>https://medium.com/@originerd/vue-js%EC%99%80-%EC%B9%9C%ED%95%B4%EC%A7%80%EA%B8%B0-ed29bb71c6c4?source=rss-8b9a16d7f8ee------2</link>
            <guid isPermaLink="false">https://medium.com/p/ed29bb71c6c4</guid>
            <category><![CDATA[react]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[vuejs]]></category>
            <category><![CDATA[frontend]]></category>
            <dc:creator><![CDATA[Jitae Kim]]></dc:creator>
            <pubDate>Thu, 06 Apr 2017 01:13:50 GMT</pubDate>
            <atom:updated>2017-04-06T04:37:41.529Z</atom:updated>
            <content:encoded><![CDATA[<h4>I loVue</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/400/1*wqYF-8Dmh7LhtLkKfERc3Q.png" /></figure><p>작년에 회사에서 서비스의 방향을 바꾸며 <a href="https://github.com/facebook/react/">React</a> 및 <a href="https://github.com/facebook/react-native/">React Native</a>를 도입했습니다. 당시에 JavaScript에 익숙하지 않은 상태였음에도, 굉장히 흥미로웠습니다. React 및 React Native를 비롯해 관련된 다양한 라이브러리들도 재미있었는데, 그 중에서 가장 인기있는 상태 관리 라이브러리인 <a href="http://redux.js.org/">Redux</a>가 인상깊습니다. 이 친구는 만만하지 않았습니다. 이름만 들어본 함수형 프로그래밍, 이뮤터블 등 새로운 개념이 마구 등장했기 때문입니다. 저 뿐만 아니라 팀원분들도 비슷한 생각이었고, 저희는 <a href="https://mobx.js.org/">MobX</a>를 대신 사용하기로 결정했습니다. <a href="https://engineering.huiseoul.com/state-management-redux-vs-mobx-a8853a7c80ea">성능이 뛰어나면서도 훨씬 쉽게 개발</a>을 할 수 있었기 때문입니다. 그러나 Redux를 접하며 알게된 함수형 프로그래밍에 관심을 가지고 <a href="https://engineering.huiseoul.com/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%85%EB%AC%B8%EA%B8%B0-14ce8f98e34e">공부</a>하게 되었고, 그 패러다임의 장점들을 습득하였습니다. 이런 이유로, 다양한 라이브러리 혹은 프레임워크 등에 더욱 흥미를 갖게 되었습니다.</p><p>React와 주변 라이브러리들을 접하는 것만으로도 재미있었는데, React와 Angular 양대산맥 사이에 Vue.js가 끼어들기 시작했습니다. 그러다 Vue.js는 결국 <a href="https://risingstars2016.js.org/">2016년 JavaScript 진영에서 가장 화젯거리</a>가 되었습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/480/1*nwAiKqHl1RAMNOxiDsvrbw.png" /><figcaption><a href="https://blog.daftcode.pl/hype-driven-development-3469fc2e9b22">https://blog.daftcode.pl/hype-driven-development-3469fc2e9b22</a></figcaption></figure><p>주변에서도 계속 Vue.js에 대한 칭찬이 이어졌고, 더욱 관심을 두게 되었습니다. 다만 바쁘다는 핑계로 계속 미뤄두고 있었는데, 늘 그렇듯 SDD(세미나 주도 개발)을 실천하기로 했습니다.</p><p>Vue.js와 다른 프레임워크 비교글을 보며 다음 문장이 가장 눈에 띄었습니다.</p><blockquote>제한된 범위 내에서 React + MobX 워크플로우는 좀 더 장황한 Vue로 생각할 수 있습니다.</blockquote><p>“대체 어떻길래 React + MobX와 비슷하다는 걸까!” 매우 궁금하였고, 추천을 받아 <a href="https://laracasts.com/">Laracasts</a>에 있는 <a href="https://laracasts.com/series/learn-vue-2-step-by-step">강의</a>를 들었습니다. 공식 사이트에 있는 <a href="https://vuejs.org/v2/guide/">문서</a>도 굉장히 정리가 잘 되어있습니다. 심지어 <a href="https://kr.vuejs.org/v2/guide/">한글</a>로 번역도 되어있으니 참고하세요.</p><p>Vue.js는 Template과 JavaScript 코드가 구분되어 있습니다. 두 가지로 나눠서 설명하는 것이 이해하기 쉬울 것 같네요.</p><blockquote>Template</blockquote><p>템플릿은 HTML을 거의 그대로 사용 가능합니다. 여기에 Vue.js만의 바인딩이 추가됩니다. 가장 기본적인 바인딩은 mustache 로 {{ data }} 와 같이 사용합니다. data 자체를 출력하는데 사용하며, JavaScript 문법을 사용할수도 있습니다. 하지만, 이 방식으로는 HTML 속성은 바인딩할 수 없습니다. 이는 디렉티브(v- 접두사를 가진 특수 속성으로, 디렉티브 속성 값은 단일 JavaScript 표현식)를 사용할 수 있습니다.</p><blockquote>JavaScript</blockquote><p>Vue.js는 ECMA Script 2015 등의 문법을 사용하거나 단일 파일 컴포넌트를 사용하기 위해서는 Babel이 필요할 수 있지만, ES5로 작성된 React는 문법 자체가 달라지는 것에 비해 Vue.js는 거의 JavaScript 자체로 사용할 수 있습니다.</p><p>Vue.js로 컴포넌트를 만드는 방법은 Vue 인스턴스를 생성하는 것입니다. Vue 인스턴스를 만들 때는 데이터, 템플릿, 마운트할 엘리먼트, 메소드 그리고 라이프사이클 콜백 등의 옵션을 포함 할 수있는 options 객체를 전달 해야합니다.</p><p>좀 더 자세한 내용은 예제와 함께 설명하도록 하겠습니다.</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fcodepen.io%2Foriginerd%2Fembed%2Fpreview%2FOpqqrM%3Fheight%3D600%26amp%3Bslug-hash%3DOpqqrM%26amp%3Bdefault-tabs%3Djs%2Cresult%26amp%3Bhost%3Dhttp%253A%252F%252Fcodepen.io%26amp%3Bembed-version%3D2&amp;url=https%3A%2F%2Fcodepen.io%2Foriginerd%2Fpen%2FOpqqrM&amp;image=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fi.cdpn.io%2F1184542.OpqqrM.small.1e9f4a15-2f0a-4ee1-b2ad-128b35161594.png&amp;key=d04bfffea46d4aeda930ec88cc64b87c&amp;type=text%2Fhtml&amp;schema=codepen" width="800" height="600" frameborder="0" scrolling="no"><a href="https://medium.com/media/91ade623744bb8fdf8fba003203f361a/href">https://medium.com/media/91ade623744bb8fdf8fba003203f361a/href</a></iframe><p>위는 Hello, Vue! 라는 문구를 출력하는 가장 기본적인 Vue.js 예제로, 데이터를 출력하고, 글 위에 마우스를 올리면 같은 데이터가 툴팁을 통해 노출됩니다.</p><p>root 라는 id를 가진 div 를 Vue 인스턴스와 연결시키고, mustache 구문을 통해 msg 값을 화면에 출력합니다. v-bind 디렉티브로 title 속성 값을 msg 값에 연결시켜 툴팁으로 보여질 수 있도록 합니다. v-bind 디렉티브는 자주 쓰이기 때문에 약어를 제공합니다. 예를 들어, v-bind:title=&quot;msg&quot; 는 :title=&quot;msg&quot; 로 줄여 쓸 수 있습니다.</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fcodepen.io%2Foriginerd%2Fembed%2Fpreview%2FLWavjY%3Fheight%3D600%26amp%3Bslug-hash%3DLWavjY%26amp%3Bdefault-tabs%3Djs%2Cresult%26amp%3Bhost%3Dhttp%253A%252F%252Fcodepen.io%26amp%3Bembed-version%3D2&amp;url=https%3A%2F%2Fcodepen.io%2Foriginerd%2Fpen%2FLWavjY&amp;image=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fi.cdpn.io%2F1184542.LWavjY.small.219498b0-d667-4a92-a5a3-6ac41506e198.png&amp;key=d04bfffea46d4aeda930ec88cc64b87c&amp;type=text%2Fhtml&amp;schema=codepen" width="800" height="600" frameborder="0" scrolling="no"><a href="https://medium.com/media/af9e5f028390274011ba83ee7a7131bf/href">https://medium.com/media/af9e5f028390274011ba83ee7a7131bf/href</a></iframe><p>위는 + 및 — 버튼을 통해 카운트를 조작할 수 있는 카운터 예제입니다.</p><p>React에서는 onClick 이라는 props로 이벤트 핸들러를 넘겨서, 엘리먼트가 클릭됐을 때에 대한 처리를 할 수 있습니다. Vue.js에서는 v-on 디렉티브로로 처리할 수 있으며, 템플릿에 v-on:click=&quot;handleClick&quot; 과 같이 작성합니다. handleClick 이 이벤트 핸들러에 대한 이름입니다. v-bind디렉티브와 같이 v-on 역시 @ 이라는 약어를 제공합니다. 즉, @click=&quot;handleClick&quot; 으로 줄여 쓸 수 있습니다.</p><p>handleClick 이라는 메소드는 Vue 인스턴스의 options 객체에 methods 에 정의합니다.</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fcodepen.io%2Foriginerd%2Fembed%2Fpreview%2FNpJZKK%3Fheight%3D600%26amp%3Bslug-hash%3DNpJZKK%26amp%3Bdefault-tabs%3Djs%2Cresult%26amp%3Bhost%3Dhttp%253A%252F%252Fcodepen.io%26amp%3Bembed-version%3D2&amp;url=https%3A%2F%2Fcodepen.io%2Foriginerd%2Fpen%2FNpJZKK&amp;image=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fi.cdpn.io%2F1184542.NpJZKK.small.7583d336-610a-45d5-93ea-1fe4a88eca43.png&amp;key=d04bfffea46d4aeda930ec88cc64b87c&amp;type=text%2Fhtml&amp;schema=codepen" width="800" height="600" frameborder="0" scrolling="no"><a href="https://medium.com/media/ee4291178f9d300f6a5e580bd45387be/href">https://medium.com/media/ee4291178f9d300f6a5e580bd45387be/href</a></iframe><p>마지막은 여러 프로젝트에서 단골로 등장하는 TODO 예제(좋은 예제라서 많이 쓰이겠죠…?)입니다. 기능은 입력창에 일정을 적고 엔터 혹은 버튼을 클릭하면 TODO 목록에 추가되고, 각 상태에 대한 개수가 변경됩니다. 또한 각 TODO를 클릭 시 완료 여부를 설정할 수 있습니다.</p><p>이번 예제에서, 드디어, 앞서 언급한 MobX와의 관련성이 나옵니다. Vue.js에서는 computed 를 자체적으로 지원합니다. 데이터가 변경될 때마다 새로운 값을 계산합니다. 물론 필요할 때마다 메소드를 실행해 값을 불러올 수 있지만, computed 는 캐시를 이용합니다. 따라서 이미 계산된 값은 캐시에서 불러오기 때문에 더 뛰어난 성능을 보입니다.</p><p>또한, 각각의 TODO를 목록으로 보여주기 위해 v-for 디렉티브를 사용했습니다. v-for=&quot;todo in todos&quot; 와 같은 형태로 사용하며, todos 의 각 값을 돌면서 엘리먼트를 출력하는 방식입니다. todos 자리에는 배열이나 객체가 와도 되고, 정수(Range)를 쓸 수 있습니다.</p><p>다음으로, 간단하게 개발환경 구축에 대해 이야기를 하고 싶습니다. React와 마찬가지로 Vue.js 역시 Chrome의 <a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd">Vue.js devtools</a> 확장 프로그램을 제공합니다. 이 확장 프로그램을 설치한 뒤 Vue.js로 개발된 사이트에 접속하면 Vue.js 아이콘이 회색에서 녹색으로 변합니다. 이 때 Chrome의 개발자 도구를 열면, Vue 탭을 볼 수 있습니다(Production인 경우는 동작하지 않습니다). 적당한 사이트를 찾지 못하셨다면, <a href="http://output.jsbin.com/jekofoy">여기</a>를 이용해보세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/927/1*6sMBOTsEZ4aAJHgZxUJk2A.png" /></figure><p>위의 스크린샷처럼 Vue 컴포넌트들의 정보를 확인할 수 있습니다. &lt;Root&gt; == $vm0 라고 적힌 부분이 있는데, console에서 $vm0 로 해당 컴포넌트에 직접 접근할 수 있습니다. 예를 들면, 이런 것도 가능합니다.</p><pre>$vm0.input = &#39;Hello world!&#39;</pre><p>위 표현식을 console에서 실행하면, 입력창에 input이 바인딩되어 있기 때문에 바로 입력이 됩니다. 즉, console에서 데이터를 직접 조작할 수 있게 됩니다. 이 기능이 참 강력하다고 생각합니다.</p><p>Vue.js devtools를 로컬에서도 사용하고 싶을 수 있는데, Chrome 확장 프로그램이 file url에 대한 접근 권한은 없기 때문에 Chrome 설정의 확장 프로그램 탭에서 Vue.js devtools의 파일 URL에 대한 액세스 허용 옵션을 켜주어야 합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/742/1*NW4R4XYTTOCAL-G0APmxwA.png" /></figure><p>다음은, <a href="https://github.com/vuejs/vue-cli">vue-cli</a> 입니다. cli 시리즈는 Ember.js가 원조라고 하고, Ember.js cli는 Ruby on Rails 컨트리뷰터가 만들었다고 합니다. React 쪽에서는 Dan Abramov가 만든 <a href="https://github.com/facebookincubator/create-react-app">create-react-app</a> 이있고, React Native는 <a href="https://www.npmjs.com/package/react-native-cli">react-native-cli</a> 가 있습니다. 이와 마찬가지로, Vue.js에서 사용할 수 있는 스캐폴딩 프로젝트입니다.</p><p>설치는 yarn 혹은 npm 등으로 할 수 있습니다.</p><pre>$ yarn global add vue-cli</pre><p>이제, Vue.js 프로젝트를 만드는 것을 알아보겠습니다.</p><pre>$ vue init &lt;template-name&gt; &lt;project-name&gt;</pre><p>위와 같은 커맨드로 프로젝트를 시작할 수 있습니다. 제공되는 템플릿은 총 다섯 가지로 webpack, webpack-simple, browserify, browserify-simple, simple 이 있습니다. 아직 webpack-simple 만 사용해봤는데, 간단하게 시작하기 좋습니다.</p><p>위 명령을 실행해 프로젝트를 시작했으면, 돌려보는 것까지는 해봐야겠죠? 먼저 해당 디렉토리로 이동한 뒤 다음 명령어를 실행합니다.</p><pre>$ yarn dev</pre><p>이 명령을 실행하면, 브라우저가 켜지면서 페이지로 연결됩니다. vue-cli 를 통해 큰 어려움없이 개발환경을 세팅할 수 있고, 실행까지 할 수 있게 됐습니다. 여기에는 또 멋진 기능이 있는데, 소스코드를 수정하면 자동으로 화면이 갱신됩니다. 단순히 갱신이 아니라 HMR(핫 모듈 리로딩)을 지원하기 때문에, 데이터의 변화없이 화면단이 교체됩니다.</p><p>공식 문서에는 <a href="https://kr.vuejs.org/v2/guide/comparison.html">다른 프레임워크와 비교하는 부분</a>이 있습니다. 사실 다른 프레임워크는 제대로 사용해보지 않아서 <a href="https://kr.vuejs.org/v2/guide/comparison.html#React">React와 비교한 부분</a>에서 중요하다고 생각하는 부분에 대해 정리해봅니다.</p><p>일반적으로 작성된 Vue.js는 최적화된 React과 비교해도 비슷하거나 더 높은 성능을 발휘한다고 합니다.</p><p>그 다음은 JSX와 Template의 비교입니다. React의 경우 모든 걸 JavaScript로 처리해 간단하고 우아한 느낌을 주지만, HTML과 CSS 문제를 해결할 때는 어렵다는 점을 강조합니다. Vue.js는 기존 웹 기술을 수용하고 그 위에 작성하여서 앞서 언급된 문제에서 보다 자유로울 수 있다고 하네요.</p><p>Template을 사용함으로써 얻는 장점은 작성하는 동안 구현 및 문법 결정을 줄이며, 항상 선언적이며, 또한 모든 유효한 HTML이 템플릿에서 유효하고, 가독성이 좋다(영어와 비슷, 자바 스크립트의 고급 버전은 가독성을 높이기 위해 요구되지 않음)이 있습니다.</p><p>그리고 큰 특징 중 하나는 생태계입니다. React의 경우 필요한 기능만 제공하고, 나머지는 커뮤니티에서 자체적으로 만들어지도록 장려하여 풍부한 생태계를 갖추고 있습니다. 이에 반해, Vue.js는 상태 관리(<a href="https://vuex.vuejs.org/">Vuex</a>), 라우팅(<a href="http://router.vuejs.org/">vue-router</a>), CLI 프로젝트 생성기(<a href="https://github.com/vuejs/vue-cli">vue-cli</a>) 등이 모두 공식적으로 제공되며 핵심 라이브러리와 함께 최신 상태로 유지됩니다.</p><p>사실 Vue.js를 접한지 일주일도 되지 않았습니다. 다만 React와 비슷한 점이 많기 때문인지, Vue.js 자체가 쉽게 쓸 수 있는건지, Larascasts의 강의가 좋았는지, Vue.js 문서가 잘 되어있는지 모르겠지만, 매우 쉽게 다가오는 것 같습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ed29bb71c6c4" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Hipstack으로 SNS 앱 만들기]]></title>
            <link>https://medium.com/@originerd/hipstack%EC%9C%BC%EB%A1%9C-sns-%EC%95%B1-%EB%A7%8C%EB%93%A4%EA%B8%B0-98b833fcd177?source=rss-8b9a16d7f8ee------2</link>
            <guid isPermaLink="false">https://medium.com/p/98b833fcd177</guid>
            <category><![CDATA[react]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[firebase]]></category>
            <category><![CDATA[react-native]]></category>
            <dc:creator><![CDATA[Jitae Kim]]></dc:creator>
            <pubDate>Sat, 04 Mar 2017 05:03:32 GMT</pubDate>
            <atom:updated>2017-03-10T05:37:01.129Z</atom:updated>
            <content:encoded><![CDATA[<h4>React Native + Redux + React Navigation + Firebase = Hipstack</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/883/1*6QBIDoArkClx6Wqm8HqbzA.png" /></figure><p>Huiseoul에서는 매주 금요일에 Geektalk을 진행합니다. Geektalk은 사내 세미나로, 구체적인 주제는 없지만 기술 위주로 진행하고 있어요. 몇 달 전부터 온오프믹스를 이용해 외부 참여자도 받고 있으며, 몇 주 전부터는 <a href="https://www.meetup.com/ko-KR/GeekTalk-with-Huiseoul/">Meetup</a>을 사용 중입니다. 어제(3월 3일)는 제가 발표할 차례였고, 주제는 Hipstack으로 SNS 앱 만들기였습니다.</p><p>몇 년 전 개인적으로 공부할 때 봤던 <a href="https://www.railstutorial.org/book">Ruby on Rails Tutorial</a>에서는 SNS 서비스를 개발하는 걸 알려줍니다. 그 때 제가 만들었던 서비스가 바로 5ns(fivens)였습니다. 다섯 글자로 이야기를 나누는 것을 숫자로 형상화하고, 숫자 5는 S와 비슷해서 나름 센스있게 만들었던 것 같습니다…. 그 당시 Heroku와 AWS S3를 이용해 서비스를 했는데, AWS에 가입한지 1년이 지나, 서비스를 접었습니다.</p><p>그러다가 요즘은 무료로 충분히 서비스를 할 수 있을 것 같다는 생각에 다시 App으로 부활시키고 싶어졌고, 기존에 사용하지 않았던 새로운 기술을 습득하려는 이유도 있었습니다.</p><p>그렇게 시작된 프로젝트입니다. 이름은 기존처럼 5ns를 할까 하다가, Surf5라는 이름을 붙였는데, ‘Share your feeling in 5 characters’ 라는 약간의 억지라고 할 수 있는 약자를 따서 만들었습니다. 시작이 반이죠.</p><p>다시 발표 주제로 넘어가서, Hipstack에 대해 설명하면, Hipster와 Stack의 합성어로, 선정한 기술들이 나름 힙해보여서 제 마음대로 붙였습니다. 실제로 <a href="http://hipstack.me/">HipStack.me</a>라는 서비스도 있고, 아무튼…. <a href="https://facebook.github.io/react-native/">React Native</a>, <a href="http://redux.js.org/">Redux</a>, <a href="https://reactnavigation.org/">React Navigation</a>, <a href="https://firebase.google.com/">Firebase</a>를 선정하였습니다.</p><p>각각의 기술들을 선택한 이유는 다음과 같습니다.</p><blockquote>React Native</blockquote><ul><li>많은 기업들에서 적용 중입니다.</li><li>Facebook, Instagram, Airbnb에서 사용하고 있습니다.</li><li>Huiseoul에서도 적용 중입니다.</li></ul><blockquote>Redux</blockquote><ul><li>상태 관리를 위한 라이브러리</li><li>Huiseoul에서는 상태 관리 라이브러리로 MobX를 사용 중입니다. (편리합니다!)</li><li>React — Redux 조합이 가장 널리 사용됩니다.</li><li>이 방식이 커뮤니티 내에서 거의 표준 수준으로 자리잡은 듯 합니다.</li><li>따라서, 사람들이 열광하는 이유를 알고 싶었습니다.</li></ul><blockquote>React Navigation</blockquote><ul><li>React Native의 Navigation 개발 중단했습니다.</li><li>Huiseoul에서는 ex-navigation 사용 중입니다.</li><li>ex-navigation도 개발 중단했습니다.</li><li>React Navigation이 새로 부상하고 있습니다.</li></ul><blockquote>Firebase</blockquote><ul><li>인증, 실시간 데이터베이스, 저장소, 클라우드 메시징, 호스팅을 모두 제공합니다.</li><li>게다가 무료! (물론 유료지만, 토이프로젝트 수준에서는…)</li></ul><p>만들려고 이것저것 생각하다보니 타임라인을 어떻게 구현할까에서 막혔습니다. RDBMS에서는 join으로 손쉽게 구현 가능하고, NoSQL 중 MongoDB에서는 in 메소드 제공하죠. 이 메소드를 이용해서 팔로우 하는 사람들의 ID로 글 목록을 얻을 수 있습니다. 그런데, Firebase는?</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/286/1*qCByDEy_6ptOPCzAwPP_kA.png" /></figure><p>생각해본 방법은 두 가지가 있습니다.</p><p>첫 번째는 팔로우 중인 유저별 글 목록에서 글 가져오기입니다. 타임라인인데… 시간별로 가져올 수 없어서 패스!</p><p>두 번째는 각 유저별로 타임라인을 가지는 방식입니다. 유저가 글을 쓰면 팔로워들의 타임라인에 모두 추가하고, 팔로우하면 그 유저의 모든 글을 타임라인에 저장합니다. 반대로, 팔로우를 끊으면 그 유저의 글을 모두 삭제해야죠…. 별로 좋아보이지는 않네요….</p><p>그런데, 이게 꽤 유명한 방식이었습니다. Pan out이라는 명칭을 가지고 있고, Firebase에서도 이를 지원합니다. 조금 찝찝한 마음은 남아있지만, 이 방식으로 결정습니다.</p><p>다음으로 할 일은? 데이터베이스 구조화죠. Firebase는 중첩을 32단계까지 허용해 웬만한 중첩은 충분히 가능하지만, 중첩 시 한 항목을 가져오면 하위 모든 데이터를 가져오게 되고, 실시간으로 처리하게 될 경우 많은 부하가 걸리게 됩니다. 따라서, 최대한 중첩을 배제해 평면화하는 것이 중요합니다. 이 원칙에 따라 데이터베이스 구조를 잡아보았습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d787b9de4d849f01ce9c0f7be287fba1/href">https://medium.com/media/d787b9de4d849f01ce9c0f7be287fba1/href</a></iframe><p>그래요, 남은 건 구현 뿐이죠!</p><p>뚝딱뚝딱.</p><p>짧은 소감을 남겨보자면,</p><blockquote>Redux</blockquote><ul><li>소규모에선 MobX로도 충분할 것 같아요.</li><li>Redux는 MobX에 비해 코드량이 많습니다.</li><li>많은 코드량이 꼭 문제는 아닐 것이라 생각했어요.</li><li>상태가 매우 투명하게 드러나는 것이 장점입니다.</li><li>Pure function 특성상 테스트가 용이합니다.</li><li>대규모에선 Redux가 확실히 강점을 가질 듯합니다.</li></ul><blockquote>React Navigation</blockquote><ul><li>전체적으로 약간 아쉬운 면들이 많았어요.</li><li>아직은 ex-navigation이 더 나을 듯 하네요.</li><li>Card / Modal 초기 설정 후 변경을 할 수 없습니다.</li><li>TabNavigation의 default tab 이동 시 트래킹 되지 않아요.</li><li>점점 나아지겠죠…</li></ul><blockquote>Firebase</blockquote><ul><li>아직은 인증, 실시간데이터 베이스 위주로 써봤어요.</li><li>역시 생각대로 매우 자연스럽고 깔끔하게 사용 가능합니다.</li><li>비교적 검색 기능이 빈약하지만 실시간 처리가 뛰어나네요.</li><li>간단한 서비스는 충분히 Firebase로 처리할 수 있을 듯 합니다.</li><li>게다가, 토이프로젝트로는 충분할 정도의 자원을 지원합니다.</li></ul><p>프로젝트는 현재 진행형으로, <a href="https://github.com/originerd/surf5">https://github.com/originerd/surf5</a> 에 공개되어 있어요.</p><p>그리고, <a href="https://prezi.com/gszsvlbxgwkx">Geektalk에서 발표했던 자료</a>를 Prezi로 만들었습니다. 처음에는 위치 잡고, 루트 정하고 하느라 오래 걸렸는데, 일단 내용을 미리 만들어두고, 위치 및 루트를 정하는 게 훨씬 나을 거라 생각했습니다. 그리고, Prezi는 서비스 특성상 이동이 많은데, 약간은 불편해 하시는 분들이 있는 것 같아요. 그런 분들을 위해서 약간의 팁을 드리자면, 이동 키를 두 번 연속으로 누르면 빠르게 이동됩니다. 굳굳 👍</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=98b833fcd177" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[정규 표현식 (좀 더) 깊이 알아보기]]></title>
            <link>https://medium.com/@originerd/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D-%EC%A2%80-%EB%8D%94-%EA%B9%8A%EC%9D%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-5bd16027e1e0?source=rss-8b9a16d7f8ee------2</link>
            <guid isPermaLink="false">https://medium.com/p/5bd16027e1e0</guid>
            <category><![CDATA[정규식]]></category>
            <category><![CDATA[regexp]]></category>
            <category><![CDATA[regular-expressions]]></category>
            <category><![CDATA[programming]]></category>
            <category><![CDATA[정규표현식]]></category>
            <dc:creator><![CDATA[Jitae Kim]]></dc:creator>
            <pubDate>Fri, 09 Dec 2016 02:03:19 GMT</pubDate>
            <atom:updated>2016-12-09T05:40:54.893Z</atom:updated>
            <content:encoded><![CDATA[<h4>(A little) Deep Dive into Regular Expressions</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/1*oGaYyDJNEZ6UL5nN-43YMg.png" /><figcaption><a href="http://xkcd.net/208">http://xkcd.net/208</a></figcaption></figure><p>글을 읽으실 분들은 대부분 <a href="https://ko.wikipedia.org/wiki/정규_표현식">정규 표현식</a>을 사용하거나, 최소한 한 번이라도 들어 보셨을 것으로 생각하지만, 정의부터 알아보면 좋을 것 같습니다.</p><blockquote>정규 표현식(正規表現式, 영어: regular expression, 간단히 regexp 또는 regex) 또는 정규식(正規式)은 특정한 규칙을 가진 문자열의 집합을 표현하는 데 사용하는 형식 언어이다.</blockquote><p>개발하면서 문자를 다룰 때, 가장 유용한 것은 바로 정규 표현식이라고 할 수 있습니다. 복잡한 패턴의 문자열을 정규 표현식을 사용하지 않고 찾아내기는 정말 상상할 수 없을 만큼 힘겨울 것 같습니다.</p><p>저 역시 정규 표현식을 사용해 다양한 문제를 해결하고 있습니다. 페이지 내의 전화번호 혹은 이메일, 링크 등을 찾거나, 에디터에서 개발하다가 특정 부분을 원하는 형태로 재가공을 하는 것 처럼 말이죠. 정규 표현식은 대부분의 프로그래밍 언어에서는 물론이고, 에디터나 터미널 유틸리티 등 폭넓게 지원하고 있습니다.</p><p>하지만, 정규 표현식을 자주, 그리고 잘 사용하고 있다고 생각하지만, 좀 더 알아보면 활용도가 더 높아지지 않을까 생각을 하게 되었습니다. 책장에 고이 잠들어있던 정규 표현식 책과 인터넷의 문서 읽으며, 다시 한번 정규 표현식의 재미를 느끼게 되었습니다.</p><p>한 단계씩 정규 표현식을 알아가는 방식이 좋을 것 같네요. <br>(*<em>참고: 정규 표현식은 일반적으로 슬래쉬(</em><em>/)문자로 감싸진 형태로 표현됩니다. 검색된 결과는 굵은 글씨로 표시하는 방식으로 표현하겠습니다. 또한 바로 확인 및 적용할 수 있도록 결과 옆에 링크를 달았습니다</em>)</p><pre># 예문<br>&quot;안녕하세요, 만나서 반갑습니다.&quot;<br>&quot;그래, 안녕?&quot;</pre><pre># 정규 표현식<br>/안녕/</pre><pre># 결과 <a href="http://rubular.com/r/i6kXOgYO9f">http://rubular.com/r/i6kXOgYO9f</a><br>&quot;<strong>안녕</strong>하세요, 만나서 반갑습니다.&quot;<br>&quot;그래, <strong>안녕</strong>?&quot;</pre><p>먼저, 가장 간단한 형태의 정규 표현식입니다. 단순하게 입력한대로 일치하는 문자를 찾습니다.</p><p>다음으로는, 정규 표현식에는 다양한 메타 문자가 존재합니다. 그 중에서도 가장 기본적인 메타 문자들을 알아보도록 하겠습니다.</p><ul><li>. : 모든 문자와 일치합니다.</li><li>[] : 대괄호 사이에 존재하는 문자들 중 하나에 일치합니다.</li><li>[^] : 대괄호 사이의 가장 첫 번째 문자로 ^ 문자가 있을 때, 그 문자 이후에 존재하는 문자들을 제외한 모든 문자와 일치합니다.</li><li>[a-z] : 대괄호 사이에서 특정문자1-특정문자2가 존재할 때, 특정문자1과 특정문자2사이의 모든 문자와 일치합니다. [a-z]의 경우, a 부터 z까지 모든 영문자 소문자와 일치합니다.</li><li>^ : 대괄호 사이에 존재할 때는 부정을 나타내지만, 대괄호 밖에서는 문자열의 시작과 일치합니다.</li><li>$ : ^와 반대로, 문자열의 끝과 일치합니다.</li><li>* : 앞에 존재하는 문자가 0번 혹은 그 이상 반복되는 문자를 찾을 때 사용합니다.</li><li>+ : 앞에 존재하는 문자가 1번 혹은 그 이상 반복되는 문자를 찾을 때 사용합니다.</li><li>? : 앞에 존재하는 문자가 있을 수도, 없을 수도 있을 때 사용합니다.</li><li>\ : . 혹은 [] 등 특수한 목적으로 사용되는 메타 문자를 문자열에서 찾고 싶을 때, 메타 문자를 문자 그대로 사용할 수 있도록 변환해주는 기호입니다. .은 모든 문자와 일치하지만, \.의 경우, .문자와 일치합니다.</li></ul><pre># 예문<br>&quot;안녕하세요, 만나서 반갑습니다.&quot;<br>&quot;그래, 안녕?&quot;</pre><pre># 정규 표현식<br>/[가-힣]+/</pre><pre># 결과 <a href="http://rubular.com/r/iwUTQOIMuN">http://rubular.com/r/iwUTQOIMuN</a><br>&quot;<strong>안녕하세요</strong>, <strong>만나서</strong> <strong>반갑습니다</strong>.&quot;<br>&quot;<strong>그래</strong>, <strong>안녕</strong>?&quot;</pre><p>이것은, 한글 가부터 힣, 즉, 모든 완성된 한글 문자와 한 개 혹은 그 이상 일치하는 문자를 찾는 정규 표현식입니다.</p><p>다음으로는, 정의되어 있는 패턴을 사용할 수 있는 방식을 알아보겠습니다.</p><ul><li>\d : 숫자와 일치합니다.</li><li>\w : 영문자 및 _ 문자와 일치합니다.</li><li>\s : 여러 가지 공백 문자와 일치합니다. (<em>* 스페이스, 탭, 기타… 공백 문자</em>)</li></ul><p>그리고 앞서 언급한 것들과 정반대의 기능을 하는 표현이 있습니다.</p><ul><li>\D : 숫자를 제외한 문자와 일치합니다.</li><li>\S : 공백 문자를 제외한 문자와 일치합니다.</li><li>\W : 영문자 및 _ 문자를 제외한 문자와 일치합니다.</li></ul><pre># 예문<br>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</pre><pre># 정규 표현식<br>\w\w\w</pre><pre># 결과 <a href="http://rubular.com/r/UfgMxPRDdi">http://rubular.com/r/UfgMxPRDdi</a><br><strong>Lor</strong>em <strong>ips</strong>um <strong>dol</strong>or <strong>sit</strong> <strong>ame</strong>t, <strong>consectet</strong>ur <strong>adipiscin</strong>g <strong>eli</strong>t.</pre><p>영문자(혹은 _) 세 개가 연달아 붙어있는 문자와 일치합니다.</p><p>앞서 본 예제에서 세 개가 연달아 붙어있는 문자를 표현했습니다. 더욱 쉬운 방법으로, 특정 문자수를 지정할 수 있습니다.</p><ul><li>{n} : 앞에 존재하는 문자가 n번 반복되는 문자와 일치합니다.</li><li>{n, m} : 앞에 존재하는 문자가 n번 이상 m번 이하 반복되는 문자와 일치합니다.</li><li>{n,} : 앞에 존재하는 문자가 n번 이상 반복되는 문자와 일치합니다.</li></ul><pre># 예문<br>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</pre><pre># 정규 표현식<br>\w{3}</pre><pre># 결과 <a href="http://rubular.com/r/x8IiwvgbG8">http://rubular.com/r/x8IiwvgbG8</a><br><strong>Lor</strong>em <strong>ips</strong>um <strong>dol</strong>or <strong>sit</strong> <strong>ame</strong>t, <strong>consectet</strong>ur <strong>adipiscin</strong>g <strong>eli</strong>t.</pre><p>바로 앞의 예제와 정확하게 일치하는 예제입니다. 더 가독성이 향상된 느낌입니다 :)</p><p>여러 문자와 반복하여 일치하는 표현식에 대해서 알아보았습니다. 특정 수가 지정되지 않고, n개 이상의 반복되는 문자와 일치하는 문자를 찾을 때, 의도치 않게 너무 많이 일치하는 경우가 발생할 수 있습니다. 기본적으로 탐욕적(Greedy) 방식으로 동작하기 때문입니다. ?문자를 해당 메타 문자 뒤에 붙이면 게으른(Lazy) 방식으로 동작합니다.</p><ul><li>*?</li><li>+?</li><li>{n,}?</li></ul><p>예를 들어보면 더 좋을 것 같네요. i로 시작하고 n으로 끝나는 모든 문자를 찾고 싶다고 가정합시다. 다음과 같이 작성할 수 있을 것 같습니다.</p><pre># 예문<br>internationalization</pre><pre># 정규 표현식<br>i\w+n</pre><pre># 결과 <a href="http://rubular.com/r/em8RaHlnq9">http://rubular.com/r/em8RaHlnq9</a><br><strong>internationalization</strong></pre><p>결과에 나온 대로, internationalization 모두가 일치했습니다. i로 시작하고 n으로 끝나는 모든 문자를 찾고 싶었지만, 일치하는 건 internationalization 통째로 하나뿐입니다.</p><p>게으른 방식으로 바꿔보겠습니다.</p><pre># 예문<br>internationalization</pre><pre># 정규 표현식<br>i\w+?n</pre><pre># 결과 <a href="http://rubular.com/r/fr6Ejzal0N">http://rubular.com/r/fr6Ejzal0N</a><br><strong>intern</strong>at<strong>ion</strong>al<strong>ization</strong></pre><p>앞의 예제와의 차이점은 단 하나 ?문자입니다. ?를 붙임으로 인해서 게으른 방식으로 동작하고 있습니다. internationalization은 i로 시작하고 n으로 끝나는 문자긴 하지만, 그 사이 사이에도 i로 시작하고 n으로 끝나는 문자가 여럿 존재합니다. 이렇게 요구에 따라 탐욕적 혹은 게으른 방식의 찾기를 할 수 있습니다.</p><p>다음으로는, 빼놓을 수 없는 그룹을 설명하도록 하겠습니다. 그룹은 () 문자로 지정할 수 있으며, 괄호 사이에 존재하는 표현식을 통해 찾은 결과를 묶음으로 처리할 수 있도록 해줍니다. 그룹을 통해 하나의 결과에서도 여러 가지 그룹으로 나눌 수 있고, 같은 문자가 반복되는 것을 찾거나, 원하는 방식으로 사용할 수 있습니다.</p><p>그룹은 일반적으로 \1과 같이 \ 문자와 그룹의 번호로 구성됩니다. 일반적으로 전체 결과가 \0이며, 앞에서 부터 나타나는 그룹의 순서에 따라 숫자가 하나씩 증가하는 방식입니다.</p><pre># 예문<br>&lt;h1&gt;이것은 첫 번째 제목&lt;/h1&gt;<br>&lt;h2&gt;이것은 두 번째 제목&lt;/h2&gt;<br>&lt;h3&gt;이것은 세 번째 제목&lt;/h3&gt;<br>&lt;h4&gt;It&#39;s also right heading&lt;/h4&gt;<br>&lt;h5&gt;이것은 올바르지 않은 제목&lt;/h6&gt;</pre><pre># 정규 표현식<br>&lt;(h[1-6])&gt;[가-힣\w\s&#39;]+&lt;\/\1&gt;</pre><pre># 결과 <a href="http://rubular.com/r/ZF58XxDYVw">http://rubular.com/r/ZF58XxDYVw</a><br><strong>&lt;h1&gt;이것은 첫 번째 제목&lt;/h1&gt;<br>&lt;h2&gt;이것은 두 번째 제목&lt;/h2&gt;<br>&lt;h3&gt;이것은 세 번째 제목&lt;/h3&gt;<br>&lt;h4&gt;It&#39;s also right heading&lt;/h4&gt;</strong><br>&lt;h5&gt;이것은 올바르지 않은 제목&lt;/h6&gt;</pre><p>HTML에서 제목을 나타내는 h 태그를 찾는 정규 표현식입니다. h 태그는 h1부터 h6까지 있으므로, h[1-6]로 표현하였습니다. 태그의 경우, 여는 태그 &lt;h1&gt; 와 닫는 태그 &lt;/h1&gt;가 일치하므로, (h[1-6])로 그룹을 만들고, 만들어진 그룹을 이용해 닫는 태그를 지정해놓고, 그 사이에 한글 및 영문자, 공백, &#39; 문자 한 개 이상 존재하는 문자를 찾도록 하였습니다. 따라서, h1에서 h4까지는 제대로 열고 닫혀서 정상적으로 찾아졌습니다. 하지만 마지막 문자열의 경우, 여는 태그는 &lt;h5&gt;로 시작했지만, 닫는 태그의 경우 &lt;/h6&gt;로, 제대로 여닫아지지 않았기 때문에 찾아지지 않았습니다. 이처럼, 그룹을 잘 활용하면 다양한 문제를 해결할 수 있습니다.</p><p>앞서 설명한 부분은 정규 표현식을 어느 정도 접해보신 분들이라면, 이미 아는 부분이어서 지루하셨거나, 훑어보며 내려오셨을 것 같습니다. 저도 주로 사용하는 부분은 이 정도였습니다. 제목처럼 (좀 더) 깊이 들어가 보도록 하겠습니다. (“<em>좀 더”입니다. 역시나 싱거울 수 있습니다</em>)</p><p>특정한 문자 앞에 일치하는 문자만 찾는 전방탐색과 특정한 문자 뒤에 일치하는 문자만 찾는 후방탐색이 있습니다. 전방탐색과 후방탐색으로 일치된 문자는 그룹처럼 보이지만 결과에는 포함되지 않습니다.</p><ul><li>(?=) : 전방탐색. 찾고자 하는 표현식 뒤에 전방탐색 표현식을 넣으며(?=와 ) 사이에 표현식을 넣습니다. 전방탐색 표현식을 통해 문자가 존재하고, 그 앞에 찾고자 하는 문자가 존재할 때 일치합니다. 특정 문자가 포함된 문자를 찾고 싶지만 결과에 포함하고 싶지는 않을 때 사용합니다.</li><li>(?&lt;=) : 후방탐색. 후방탐색 표현식 (?&lt;=와 ) 사이에 표현식을 넣고, 찾고자 하는 표현식을 작성합니다. 후방탐색 표현식을 통해 문자가 존재하고, 그 뒤에 찾고자 하는 문자가 존재할 때 일치합니다. 전방탐색과 유사하죠.</li></ul><p>이와 반대인 탐색이 있습니다.</p><ul><li>(?!) : 부정형 전방탐색. 전방탐색과 반대로, 부정형 전방탐색 내의 표현식이 일치하지 않고, 찾고자 하는 문자가 존재할 때 일치합니다.</li><li>(?&lt;!) : 부정형 후방탐색. 후방탐색과 반대로, 부정형 후방탐색 내의 표현식이 일치하지 않고, 찾고자 하는 문자가 존재할 때 일치합니다.</li></ul><p>설명이 굉장히 어렵네요. 예제를 통해서 살펴보면 더 이해하기 쉬울 것 같습니다.</p><pre># 예문<br>2400원<br>3600원<br>28392830원<br>238493엔<br>원2839283</pre><pre># 정규 표현식<br>\d+(?=원)</pre><pre># 결과 <a href="http://rubular.com/r/XrZGoLjUbm">http://rubular.com/r/XrZGoLjUbm</a><br><strong>2400</strong>원<br><strong>3600</strong>원<br><strong>28392830</strong>원<br>238493엔<br>원2839283</pre><p>원화 표기로 작성된 문자를 찾는 예제입니다. 전방탐색을 사용했고, 숫자와 원이라는 문자가 들어가야 일치하지만, 결과에는 원이 포함되지 않은 걸 확인할 수 있습니다.</p><p>깊이 들어가려면 끝이 없는 게 정규 표현식인 것 같습니다. 이 글에서의 마지막은 역참조(Backreference)입니다. ‘어떤 그룹이 있으면, 이런 문자를 찾아라.’ 같은 개념이라고 볼 수 있습니다. 수를 찾는데, 괄호로 묶여있는 수의 경우 괄호까지 찾고 싶을 때 사용할 수 있습니다. 일종의 분기문이라고 할 수 있습니다.</p><ul><li>(?(n)) : ?(n)의 n에 그룹의 번호를 넣습니다. 이 뒤에 나타나는 것은 n번 그룹이 존재할 때 일치해야 하는 표현식입니다.</li></ul><pre># 예문<br>12345<br>12.3456<br>(120.293)<br>(18729.28<br>2839283)</pre><pre># 정규 표현식<br>(\()?\d+(\.\d+)?(?(1)\))</pre><pre># 결과 <a href="http://rubular.com/r/H2pt3TCCqF">http://rubular.com/r/H2pt3TCCqF</a><br><strong>12345</strong><br><strong>12.3456<br>(120.293)</strong><br>(<strong>18729.28<br>2839283</strong>)</pre><p>위의 설명에서 언급한 내용을 예제로 만들어 보았습니다. (\()? 는 ( 문자를 그룹으로 만들었고, ? 메타 문자를 통해 있을 수도 없을 수도 있다는 것을 표현한 것입니다. 그리고, 숫자(소수점 포함)를 표현하였고, (?(1)\))를 통해 앞서 설명한 역참조를 사용하였습니다. (1)의 경우, 가장 첫 그룹인 ( 문자 유무를 판단하고, 이 그룹이 있으면 ) 문자가 있는지 찾습니다. 따라서, 결과에 나온 것처럼, 숫자들 혹은 괄호로 둘러싸인 숫자를 찾습니다. 괄호가 제대로 여닫아지지 않는 숫자들은 그냥 숫자에만 일치하는 것을 확인할 수 있습니다.</p><p>새로 알게된 내용만 적을까 하다가, 정리하는 느낌으로 쓰다보니 글이 길어졌네요. 이만큼만 알아도 문자를 다루는 데 훨씬 수월할 것이라 생각합니다. 이 글이 조금이라도 도움이 되었으면 좋겠습니다. 하지만, 여기에 나오지 않은 여러 정규 표현식들이 존재합니다. 흥미가 생겼다면, 더 많은 정규 표현식을 익히고 공유해주시면 좋을 것 같네요 :)</p><p>간단하게 짜놓은 예제를 버리기 아쉬워서… 덧붙입니다. 개미 수열이라고 불리는 <a href="https://ko.wikipedia.org/wiki/%EC%9D%BD%EA%B3%A0_%EB%A7%90%ED%95%98%EA%B8%B0_%EC%88%98%EC%97%B4">읽고 말하기 수열</a>을 정규 표현식을 이용해 <a href="http://jsbin.com/decifecasu/edit?js,console">구현</a>해보았습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/93ab95c8e2577c78cc9c776605f2565d/href">https://medium.com/media/93ab95c8e2577c78cc9c776605f2565d/href</a></iframe><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5bd16027e1e0" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[State management — Redux vs. MobX]]></title>
            <link>https://medium.com/@originerd/state-management-redux-vs-mobx-a8853a7c80ea?source=rss-8b9a16d7f8ee------2</link>
            <guid isPermaLink="false">https://medium.com/p/a8853a7c80ea</guid>
            <category><![CDATA[react]]></category>
            <category><![CDATA[mobx]]></category>
            <category><![CDATA[redux]]></category>
            <dc:creator><![CDATA[Jitae Kim]]></dc:creator>
            <pubDate>Thu, 29 Sep 2016 05:20:49 GMT</pubDate>
            <atom:updated>2016-09-29T23:36:15.116Z</atom:updated>
            <content:encoded><![CDATA[<h4>리액트 / 리액트 네이티브에서 상태 관리하기 — Redux? MobX?</h4><p>바로 얼마 전 <a href="https://github.com/facebook/react/stargazers">Github star</a>가 50,000개를 넘어설 정도로 <a href="https://facebook.github.io/react/">React</a>의 인기는 날로 높아져 가고 있습니다. 현재 <a href="http://www.huiseoul.com/">Huiseoul</a>에서는 React / <a href="http://facebook.github.io/react-native/">React Native</a>로 두 개의 웹 서비스와 한 개의 모바일 앱을 운영 / 개발 중입니다.</p><p>몇 달 전, 처음 React에 대해 스터디를 진행하며 작성했던 글(“<a href="https://engineering.huiseoul.com/mobx-with-react-native-intro-605dc3a7fe94">MobX with React Native — Intro</a>”)이 있습니다. React로 프로젝트를 진행하며 상태 관리의 필요성을 느끼게 되었고, 가장 인기 있던 <a href="http://redux.js.org/">Redux</a> 라는 라이브러리를 보았습니다.</p><p>앞서 언급한 글에서 적었듯이, Redux는 간결한 컨셉에 비해 함수형 프로그래밍 패러다임을 기반으로, Reducer와 Immutable, connect, Smart &amp; Dumb components 등 새로 익혀야 할 개념이 매우 많았습니다.</p><p>그래서 대안으로 발견한 <a href="http://mobxjs.github.io/mobx/">MobX</a>라는 라이브러리를 도입했고, 지금까지 React / React Native 프로젝트의 상태 관리에 활발하게 사용하고 있습니다. MobX는 기존에 개발하던 객체지향 프로그래밍 패러다임에서 크게 벗어나지 않은 개발 방법으로 인해 새로 접한 기술임에도 무리 없이 빠르게 개발할 수 있었습니다.</p><p>하지만, MobX를 잘 쓰고 있는 이 시점에 몇 가지 궁금증이 생겨 Redux를 다시 살펴보고 싶었습니다.</p><blockquote>MobX의 Best Practices는 어떤 것일까? 우리는 어떻게 MobX를 더 잘 쓸 수 있을까?</blockquote><p>먼저, 이 질문이 시작이었습니다.</p><p>Redux는 함수형 프로그래밍, Action, Reducer, Smart &amp; Dumb components 등 Best Practices를 명확히 하고, 구조적으로 개발할 수 있도록 합니다.</p><p>MobX는 특별한 배경지식이 없이도 쉽게 개발할 수 있는 점이 가장 큰 장점입니다. 라이브러리에서 어떤 방식을 강제하지 않습니다. 사용자는 그저 MobX가 마법을 부리는 동안 신경 쓰지 않고, 사용하면 되기 때문에, 편리합니다.</p><p>Huiseoul에서 MobX를 사용하며 도메인마다 Store를 만들었고, 그 이후 Store와 Model을 분리하는 등 점차 더 나은 방식으로 개선해나갔습니다. 그러다 보니, 다른 사람들은 MobX를 어떻게 쓰고 있을까? MobX의 Best Practices는 무엇일까? 생각하여 관련 문서들을 찾아보았는데, <a href="https://mobxjs.github.io/mobx/best/pitfalls.html">MobX 공식 문서</a>가 나왔습니다.</p><p>아직 MobX 진영에서는 Redux처럼 구체적인 Best Practices가 정의되지 않았기 때문에, 우리만의 Best Practices를 만들면 좋겠다고 생각했습니다. 그 과정에서 Redux를 다시 한 번 보고 참고하면 좋을 것 같았습니다.</p><blockquote>우리가 복잡하다고 생각한 Redux를 어떻게 그렇게 많은 사람들이 열광하고, React하면 Redux를 떠올릴까?</blockquote><p>Redux는 함수형 프로그래밍 패러다임이 기본이 되는 라이브러리입니다. 이 패러다임은 상당히 오래 전부터 존재해왔고, 많은 사람들이 알았지만, 이렇게 주목받기 시작한 건 얼마되지 않았습니다.</p><p>객체지향 프로그래밍에 비해 함수형 프로그래밍에 익숙하지 않은 사람들이 대부분일텐데, React를 사용하는 사람들은 어떻게 Redux에 열광하며 사용하고 있을까요?</p><p>처음 React를 시작했을 때, 저희 팀은 ECMA Script 2015 및 함수형 프로그래밍에 익숙하지 않았습니다. Redux는 저희가 개발하려는 것에 비해 높은 벽 혹은 배보다 배꼽이 더 큰 경우라 생각했고, 따라서, 보다 접근성이 좋은 MobX를 택했습니다.</p><p>JavaScript(ES6)로 꾸준히 개발을 하면서 익숙해졌고, 높아지는 함수형 프로그래밍에 대한 관심으로 <a href="https://engineering.huiseoul.com/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%85%EB%AC%B8%EA%B8%B0-14ce8f98e34e">공부</a>를 했습니다.</p><p>최근에 두 가지 모두 익숙해진 뒤, 사람들이 가장 많이 추천하는 Redux 강의인 Egghead 사이트에 등록된 Dan Abramov의 “<a href="https://egghead.io/courses/getting-started-with-redux">Getting Started with Redux</a>”를 처음부터 끝까지 들었습니다.</p><p>Redux를 접했을 때 앞부분만 살짝 봤었지만, 그 당시에도 강의 내용이 좋다고 생각했습니다. 그리고 이번에 JavaScript 및 함수형 프로그래밍 그리고 React에 더 많은 지식을 가지고 들으니 강의 내용이 상당히 탄탄하고, 라이브러리 자체가 매우 투명한 것을 느꼈습니다. Redux를 선택하시는 분은 강의를 듣는 것을 강력히 추천드립니다.</p><p>간단하게 요약하면, React의 상태 관리 라이브러리는 크게 두 가지( Redux와 MobX)로 압축할 수 있을 것 같습니다(Flux도 있지만…).</p><blockquote>Redux? 혹은 MobX? 어떤 걸 도입할까?</blockquote><p>Redux는 매우 투명합니다. 특성상 구조적으로 개발할 수 있고, 이에 따라 대규모 작업을 진행하더라도 크게 무리가 없을 것 같습니다. 또한 Store가 단 한 개만 존재하기 때문에, 관리 및 사용에도 용이합니다.</p><p>MobX는 사용이 간단합니다(매우 간단합니다! ). 내부적으로는 MobX가 알아서 해주는 부분이 많지만, 표면적으로는 개념적으로 알아야 할 새로운 정보들이 많지 않아 처음 접하시는 분도 빠르게 개발할 수 있습니다.</p><p>이 두 라이브러리는 추구하는 방향이 다릅니다. 따라서 어떤 라이브러리가 더 낫다를 판단할 수 없을 것 같습니다.</p><p>저희는 당분간 MobX에서 Redux로 옮겨갈 계획은 없습니다. 다만 Redux의 Best Practices 및 개념들을 알고, 이를 통해 저희만의 MobX Best Practices를 만드는 것이 단기적 목표이며, 계속 발전 시켜나려고 하고 있습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a8853a7c80ea" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[함수형 프로그래밍 입문기]]></title>
            <link>https://medium.com/@originerd/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%85%EB%AC%B8%EA%B8%B0-14ce8f98e34e?source=rss-8b9a16d7f8ee------2</link>
            <guid isPermaLink="false">https://medium.com/p/14ce8f98e34e</guid>
            <category><![CDATA[ruby-on-rails]]></category>
            <category><![CDATA[elixir]]></category>
            <category><![CDATA[programming]]></category>
            <category><![CDATA[phoenix]]></category>
            <category><![CDATA[functional-programming]]></category>
            <dc:creator><![CDATA[Jitae Kim]]></dc:creator>
            <pubDate>Fri, 08 Jul 2016 09:22:55 GMT</pubDate>
            <atom:updated>2016-07-11T07:32:02.048Z</atom:updated>
            <content:encoded><![CDATA[<h4>Functional Programming?</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/414/1*quXsoDBcRKDvJ-1sFb5Paw.png" /><figcaption><a href="http://wadler.blogspot.kr/2008/04/functional-programming-is-beautiful.html">http://wadler.blogspot.kr/2008/04/functional-programming-is-beautiful.html</a></figcaption></figure><p>함수형 프로그래밍에 대해 처음 듣게 된 것은 프로그래밍을 처음 공부하기 시작했던 2007~2008년 즈음이었습니다. 소위 <strong>언어덕후</strong>라고 불리는 일부 특이한 사람들만 사용하는 언어로 알고 있었습니다.</p><p>그리고 2년이 지나 대학교에 입학 후 <a href="http://www.yes24.com/24/goods/23951885">SICP</a>(컴퓨터 프로그램의 구조와 해석, Structure and Interpretation of Computer Programs)라는 책을 패기롭게 구매했습니다. 당시에 전공서적을 사 모으는 게 취미일 정도로 괜찮아 보이는 책들을 사던 시기였습니다. SICP에서는 <a href="https://www.google.co.kr/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwj426yRxuPNAhWBKpQKHSllAMMQFghCMAI&amp;url=https%3A%2F%2Fko.wikipedia.org%2Fwiki%2F%25EC%258A%25A4%25ED%2582%25B4_%28%25ED%2594%2584%25EB%25A1%259C%25EA%25B7%25B8%25EB%259E%2598%25EB%25B0%258D_%25EC%2596%25B8%25EC%2596%25B4%29&amp;usg=AFQjCNHiTSlYCjrsTEK0Xq_OymaBszCKrw&amp;sig2=rIHEPrvb4pZmxQynUXSlIg">Scheme</a>이라는 <a href="https://www.google.co.kr/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwiq5NCYxuPNAhXCjJQKHbPFB5YQFggjMAA&amp;url=https%3A%2F%2Fko.wikipedia.org%2Fwiki%2F%25EB%25A6%25AC%25EC%258A%25A4%25ED%2594%2584&amp;usg=AFQjCNHO2IDHOYWNd-PU0WMqHsRNbEPH-g&amp;sig2=RaydDjsWiNBTTcNsRi7M9Q&amp;bvm=bv.126130881,d.dGo">LISP</a>의 방언(변종)으로 프로그래밍하는 방법을 알려주는데, Scheme이 제 첫 함수형 언어의 시작이었습니다(<em>매번 시작하고 2장을 넘지 못하고 </em><a href="http://www.yes24.com/24/goods/2149593"><em>The Art of Computer Programming</em></a><em>과 함께 책장을 장식하고 있다고 합니다).</em></p><p>몇 년 동안 관심에서 벗어나 있었는데, 최근 들어서 새로운 기술들을 접하다보니 함수형 프로그래밍 혹은 그것의 개념에 관해 심심치 않게 들려옵니다. Java 8에도 함수형 프로그래밍 개념이 많이 들어갔습니다.</p><p>또한, 가장 좋아하는 언어인 Ruby를 처음 접하게 된 계기가 가장 기억에 남는 <a href="http://www.yes24.com/24/goods/12501565">실용주의 프로그래머</a>라는 책으로부터였는데, 이 책에서 저자들이 Ruby에 관심이 있다고 하여 일명 <a href="http://www.yes24.com/24/goods/22906810">곡괭이 책</a>으로 불리는 책을 통해 공부하였습니다. 이 책 역시 실용주의 프로그래머 저자 중 한 명(Dave Thomas)이 집필하였습니다.</p><p>Ruby 이야기를 꺼낸 이유는, 최근에 Ruby와 Rails의 비교적 느린 속도로 인해 다른 대안을 찾아보다가, Elixir라는 언어를 알게 되었습니다. Elixir는 Erlang VM 위에 돌아가는 함수형 언어입니다. 또한, Elixir로 만들어진 Phoenix라는 걸출한 웹 프레임워크도 존재하였습니다. Phoenix 사용자들의 말에 의하면 심지어 Rails에서 빠른 응답 속도를 위해서 거의 필수로 여겨지는 Caching을 하지 않아도 빠르다고 합니다. 특히 Elixir와 Phoenix에 매력을 느낀 이유는, Elixir는 Ruby에, Phoenix는 Rails에 영감을 받아 만들어졌습니다. 실제로 Ruby on Rails를 하던 사람들이 상당수 Elixir와 Phoenix로 이동하거나 관심을 두고 있습니다. 게다가 앞서 언급했던 Dave Thomas가 <a href="https://pragprog.com/book/elixir/programming-elixir">Programming Elixir</a>라는 책을 쓴 것도 하나의 이유가 되었습니다. 이 책을 통해 Elixir를 익히고 있습니다.</p><p>함수형 프로그래밍에 관심을 두게 된 계기를 적다 보니 생각보다 장황하게 서문을 적었습니다. 그렇다면 함수형 프로그래밍이 무엇일까요?</p><p>Uncle Bob은 함수형 프로그래밍을 한 마디로 이렇게 <a href="https://pragprog.com/magazines/2013-01/functional-programming-basics">정의</a>하였습니다.</p><blockquote>Functional programming is programming without assignment statements.</blockquote><blockquote>함수형 프로그래밍은 대입문 없이 프로그래밍하는 것이다.</blockquote><p>이 문구가 굉장히 심오하게 들렸습니다. 대입문 없이 프로그래밍하는 것이라?</p><p>간단하게 예를 들면, Java 등 우리가 흔히 알고있는 언어에서 거의 필수적인 반복문에서도 기본적으로 대입이 필요합니다. 대입이 된다는 것은 데이터를 변환 시키는 것으로, 반복문이 실행될 때마다 데이터의 변환이 일어납니다.</p><p>함수형 프로그래밍에서는 대입없이 상수(Constant)를 인자로 받아서 처음 메모리에 할당하고, 할당된 메모리에 데이터를 변경시키지 않습니다. 즉, 메모리 할당할 때를 제외하고는 할당된 메모리 데이터가 변경되지 않는 것이 충족된다면, 함수를 몇 번이고 호출하더라도 항상 동일한 결과를 가진다고 할 수 있습니다. 또한 데이터가 변경됨으로 인해 생기는 사이드 이펙트가 발생하지 않는다고 할 수 있습니다. 따라서, 멀티 코어가 기본이 된 개발 환경에서도 할당된 메모리를 변경시키지 않고 읽기만 하기 때문에 세마포어 등의 기술이 필요하지 않으면서도 멀티쓰레딩 프로그래밍이 가능해집니다.</p><p>그렇다면 함수형이란 이름은 왜 붙게 되었을까요? 함수형 프로그래밍 언어에서는 함수를 가장 중요하게 생각합니다. 함수를 데이터로 다루기 때문에 함수의 인자 혹은 반환값으로 함수를 사용할 수 있습니다. 이런 특성으로 기존에 생각하지 못한 방식의 프로그래밍이 가능합니다. Ruby의 Lambda나 Block 들이 이런 특성을 지닙니다. 그래서 Ruby를 사용해 보았다면, 익숙한 방식일 겁니다.</p><p>글로 설명하는 것으로는 한계가 있는 것 같습니다. 객체지향 프로그래밍과 함수형 프로그래밍으로 각각 작성된 간단한 예제를 보며 비교해보면 좋겠네요. 제가 자주 사용하는 로또 번호 추출하는 프로그램을 예제로 하겠습니다.</p><p>먼저, Java(객체지향 프로그래밍)로 작성해보겠습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/38bff6edd1209162da5a45841fe1e58f/href">https://medium.com/media/38bff6edd1209162da5a45841fe1e58f/href</a></iframe><p>미흡한 점이 있을 수 있지만, 나름 익숙한 방식이라고 생각하실 것 같습니다. 예제를 살펴보면 수많은 반복문이 있고, 대입이 많이 발생했고, <strong>Collections.shuffle</strong>이나 <strong>Arrays.sort</strong> 등에서 인자의 데이터를 직접 변경을 합니다. 이로 인해서 의도치 않은 결과가 발생할 수 있거나 변경된다는 점이 명확하게 보이지 않아서 사이드 이펙트를 만들 가능성이 있습니다.</p><p>다음으로, Elixir(함수형 프로그래밍)로 작성해보겠습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/4a023a40de672e775b7efebe8e0b5a78/href">https://medium.com/media/4a023a40de672e775b7efebe8e0b5a78/href</a></iframe><p>가장 먼저 눈에 들어온 것이 간결함일 것 같습니다. 대입문이 전혀 보이지도 않고, 의미도 훨씬 더 잘 전달되어 보입니다. 간결하니 설명하기도 좋네요. 각 줄에 대해서 알아보겠습니다.</p><ol><li>1부터 45까지 포함된 리스트를 생성합니다.</li><li>‘|&gt;’ 는 파이프라고 합니다. 이는 앞선 함수의 결과를 인자로 받는 방식입니다. Unix/Linux 쉘의 파이프를 생각하시면 좋습니다. 이 라인에서는 1부터 45까지의 리스트의 각 요소를 임의로 섞습니다.</li><li>섞인 1부터 45까지의 리스트 중 앞 6개 인자를 리스트로 뽑아냅니다.</li><li>6개 인자를 가진 리스트를 정렬합니다.</li><li>정렬된 리스트의 각 인자 사이에 ‘, ’ 문자를 집어 넣어서 문자열을 생성합니다.</li><li>생성된 로또 번호 문자열을 출력합니다.</li></ol><p>간단하게나마 객체지향 프로그래밍과 함수형 프로그래밍으로 작성된 예제를 살펴보았습니다. 이번 예제에서는 함수형 프로그래밍으로 작성한 것이 훨씬 쉽고 간결하게 된 것 처럼 보입니다. 하지만, 실제로 대입없이 순수 함수형 프로그래밍으로 프로그램을 작성하는 것이 굉장히 어려울 수 있습니다. 하지만 예측이 가능하고 더 견고한 프로그램을 작성할 수 있을 것이라 생각합니다.</p><p>입문자가 쓴 글이라 부족한 점이 많을 수 있습니다. 잘못된 점이나 추가로 포함되면 좋을 내용이 있으면 언제든 피드백 주시면 감사하겠습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=14ce8f98e34e" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[MobX with React Native — Intro]]></title>
            <link>https://medium.com/@originerd/mobx-with-react-native-intro-605dc3a7fe94?source=rss-8b9a16d7f8ee------2</link>
            <guid isPermaLink="false">https://medium.com/p/605dc3a7fe94</guid>
            <category><![CDATA[mobx]]></category>
            <category><![CDATA[react]]></category>
            <category><![CDATA[javascript]]></category>
            <dc:creator><![CDATA[Jitae Kim]]></dc:creator>
            <pubDate>Wed, 20 Apr 2016 12:49:49 GMT</pubDate>
            <atom:updated>2016-04-20T17:11:47.280Z</atom:updated>
            <content:encoded><![CDATA[<p><a href="https://facebook.github.io/react/">React</a> / <a href="https://facebook.github.io/react-native/">React Native</a>로 개발을 시작하면서 State 관리에 대한 중요성을 느끼게 되었습니다. 각 컴포넌트에서 State를 기준으로 수많은 액션과 그에 따른 변경이 매우 복잡하게 얽힐 수 있기 때문에 관리에 많은 신경을 써야 합니다.</p><p>이것을 보다 유연하게 관리할 수 있게 해주는 많은 라이브러리들이 있습니다. 커뮤니티에서 유명한 것들은 Facebook에서 자체적으로 개발한 <a href="https://facebook.github.io/flux/">Flux</a>, 그리고 Flux의 컨셉을 이어받아서 개선하고 Flux보다 더 인기가 있는 <a href="http://redux.js.org/">Redux</a>가 있습니다.</p><p>우아하지만 간결한 컨셉과 커뮤니티의 인기로 인해 Redux를 도입하려고 알아보고 공부를 하였습니다. 하지만 간결한 컨셉에 비해 Reducer와 Immutable, connect, Smart &amp; Dumb components 등 새로 익혀야할 것들이 굉장히 많았습니다.</p><p>그러던 중에 <a href="http://mobxjs.github.io/mobx/">MobX</a>를 알게되었습니다. Reactive programming 패러다임의 라이브러리로, 기존에 많이 접한 방식인 annotation 기반(ES6 및 stage-1 필요)으로 훨씬 쉽게 다가왔습니다. 심지어 Redux보다 빠른 속도를 보여주었습니다. 따라서 MobX를 프로젝트에 적용하기로 하였습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/1*d-1KKrGGmCqj1SOwMut_mw.jpeg" /><figcaption><a href="https://twitter.com/mweststrate/status/720177443521343488">https://twitter.com/mweststrate/status/720177443521343488</a></figcaption></figure><p>MobX의 Core API는 @observable, @computed, autorun, @observer이 있습니다. 각각을 살펴보겠습니다.</p><ul><li>@observable: 이것을 통해 데이터를 관찰하도록 설정합니다. 데이터를 관찰한다면, 그 데이터에 의존하는 View를 자동으로 업데이트할 수 있습니다.</li><li>@computed &amp; autorun: 이 두 항목은 모두 reactive하게 호출되지만 혼동하지 않도록 해야 합니다. @computed는 다른 observer에 의해 사용될 수 있는 새로운 값을 reactive하게 생성할 때 사용합니다. 반면에 autorun은 새로운 값을 생성하는 것이 아닌 로그를 기록하거나 네트워크 요청 등의 코드를 작성할 때 사용합니다.</li><li>@observer: 이는 React와 관련된 항목으로 React component에서 사용되는 MobX 데이터가 변경될 때마다 자동으로 업데이트합니다.</li></ul><p>이 네 가지 항목만 이해한다면 개발을 시작할 수 있습니다. 최적화한 Redux 코드와 비슷한 속도를 내면서도 쉽게 사용할 수 있는 점이 굉장히 매력적인 라이브러리입니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=605dc3a7fe94" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[주니어 개발자의 Huiseoul 적응기]]></title>
            <link>https://medium.com/@originerd/%EC%A3%BC%EB%8B%88%EC%96%B4-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98-huiseoul-%EC%A0%81%EC%9D%91%EA%B8%B0-82404728795b?source=rss-8b9a16d7f8ee------2</link>
            <guid isPermaLink="false">https://medium.com/p/82404728795b</guid>
            <category><![CDATA[huiseoul]]></category>
            <category><![CDATA[devops]]></category>
            <category><![CDATA[junior-developer]]></category>
            <dc:creator><![CDATA[Jitae Kim]]></dc:creator>
            <pubDate>Thu, 17 Mar 2016 12:55:32 GMT</pubDate>
            <atom:updated>2018-03-28T09:02:40.101Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*SGiD5SE4wd1Vi9Y_2WFY7Q.jpeg" /></figure><p>인턴 생활을 제외하고 첫 직장으로 <a href="http://trillionaire.co.kr">Trillionaire</a>에 다니게 되었습니다. 1월 4일에 입사 후 지금까지 약 2개월 간 <a href="http://huiseoul.com">Huiseoul</a>이라는 서비스를 개발하고 있습니다. 첫 직장이다 보니 적응해야 하고, 배울 점이 많았습니다. 이에 대해 간단하게 소개해보고자 합니다.</p><h4><strong>스크럼(</strong><a href="https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%81%AC%EB%9F%BC_(%EC%95%A0%EC%9E%90%EC%9D%BC_%EA%B0%9C%EB%B0%9C_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4)"><strong>Scrum</strong></a><strong>)</strong></h4><p>Huiseoul은 스크럼을 진행합니다. 스프린트(Sprint) 단위는 2주이며, 스프린트가 시작되는 월요일에 지난 스프린트에 대한 소감에 대해 이야기하고, 피드백을 합니다. 그리고 2주 간 어떤 목표를 가지고 진행을 할지 정하게 되며, 이에 맞는 작업들을 선정합니다. 각 작업들은 스토리로 나누어지며, 한 사람이 하나의 스토리를 담당하는 것을 원칙으로 합니다. 또한 각 스토리는 대략 어느 정도의 기간이 소요될 지 구성원들의 참여를 통해 포인트로 산정합니다. Huiseoul에서는 하루를 1포인트로 정했습니다. 이 스토리들의 관리는 <a href="http://trello.com">Trello</a>를 이용하고 있습니다.</p><p>매일 아침 10시 반에 스크럼 미팅을 가집니다. 한 사람씩 돌아가며 간단하게 오늘의 컨디션이나 개인적인 이야기들을 하고, 어제 어떤 작업을 했는지, 오늘 어떤 작업을 할지, 어떤 부분에서 막히는지 공유합니다.</p><h4>Git</h4><p>입사하기 전부터 Git을 사용했습니다. 팀 프로젝트도 종종하였지만, 대부분은 개인 프로젝트였습니다. 주로 branch, add, commit, push 그리고 merge 등 정말 기본적인 소스코드 관리에 필요한 기능들만 사용하였습니다. 또한 commit의 단위를 잘 조절하지 못해서 매우 여러 가지 변화를 하나의 commit으로 등록하기도 하였습니다.</p><p>입사 후에는 팀 단위로 작업하다 보니 작업한 부분이 겹치는 conflict 현상 등이 많이 발생했고, 혼자서 진행할 때는 고려하지 않아도 되었을 일들도 많아졌습니다. 따라서 Git의 기능들을 폭넓게 사용하게 되었습니다.</p><ul><li>cherry-pick</li></ul><p>Merge 되지 않은 branch에 이어서 작업을 해야할 때 유용합니다.</p><p>먼저 branch에 다시 branch2를 생성합니다. 특정 작업을 진행하다가 branch가 merge 되었을 때, 현재 작업 중인 branch2는 merge된 branch에 존재하는 부분을 중복적으로 가지고 있기 때문에 Pull Request(PR)을 올리게 되면 현재 branch2에서 작업하지 않은 내용도 노출되게 됩니다.</p><p>새로 master에 branch3을 생성하고, 위에서 작업한 branch2의 특정 commit에 대해서만 cherry-pick 명령어를 통해서 가져오면 깔끔하게 해결할 수 있습니다.</p><p>먼저 master에 새로 생성한 branch3으로 이동 후 다음 명령어를 실행하면 현재 branch인 branch3으로 원하는 commit들을 가지고 올 수 있습니다.</p><pre>$ git cherry-pick (가지고 오려는 커밋의 바로 전 커밋 해쉬키)..(가지고 오려는 마지막 커밋의 해쉬키)<br># ex) git cherry-pick a83dje2..b378eof</pre><ul><li>stash</li></ul><p>현재 작업한 내용이 존재하는데, commit은 하지 않을 상황이지만 저장은 해야할 때 유용합니다. 예를 들면, 특정 branch로 이동하거나 마지막 commit 한 시점으로 돌아갈 때가 있습니다.</p><pre>$ git add .<br>$ git stash<br># 위 작업을 실행하면 해당 내역이 저장이 되고 마지막 commit 시점으로 돌아갑니다.<br>$ git stash pop<br># 위 작업을 실행하면 저장된 변경사항이 다시 되살아납니다.</pre><p>이외에도 다양한 Git 명령어를 익히게 되었습니다.</p><h4><strong>코드리뷰</strong></h4><p>Git repository를 <a href="http://github.com">Github</a>으로 관리하고 있습니다. 각자 맡은 스토리에 대한 branch를 만들어서 작업 후 설명과 변경사항을 포함한 PR을 생성합니다. 이 PR을 실제로 반영(merge)하기 위해서는 다른 개발자로 부터 두 개의 👍(승인)을 받아야합니다. 여기서 논리적 오류 혹은 스타일 등에 대한 피드백을 받고 적용하는 과정을 거칩니다. 주니어 개발자인 저에게는 굉장히 많은 도움이 되고 있습니다.</p><h4><strong>자동배포 시스템</strong></h4><p>Huiseoul은 <a href="http://aws.amazon.com">AWS</a>을 이용해 서비스되고 있습니다. 초기에는 수작업으로 배포를 진행했습니다. 이 과정이 불필요하게 손이 많이 가며, 시간도 많이 소요되어서 업무효율에 좋지 않은 영향을 미쳤습니다. 이를 해결하고자 <a href="https://medium.com/u/54c1bc830198">Johnwook.Choi</a>님이 Meerkat으로 이름을 붙인 자동배포 시스템을 제작하였습니다.</p><p>Github에서 PR을 merge 시에 테스트가 자동으로 실행이 되며, 이것이 통과하면 Meerkat 서버에 Deploy 명령이 전달됩니다. Meerkat은 Assets를 precompile하는 등 작업을 자동으로 진행하고 최종적으로 AWS에 배포를 합니다.</p><p>이 자동화된 시스템이 초반에는 약간 우려가 있었지만, merge된 코드가 몇 분 내에 자동으로 배포되어 실제로 서비스에 적용되는 것을 경험하니 굉장히 신기하고 즐겁습니다. 다만 테스트 코드 작성에 매우 신경써야 합니다. 저 역시 중요성을 알지만 아직 많이 부족한 부분입니다.</p><h4><strong>Geek Talk</strong></h4><p>매주 한 명씩 돌아가며 금요일 점심에 Geek Talk을 진행합니다. Geek Talk은 어떠한 주제에 대한 세미나를 지칭하는 내부 용어입니다. 주제는 어떤 것이든 상관없지만, 주로 새로운 기술이나 업무에 관련된 내용이 많이 나오고 있습니다. 4명의 인원으로 진행되기 때문에 거의 한 달에 한 번 진행을 맡게 되는데 약간 부담스러울 수 있지만 듣는 건 언제나 즐겁습니다. 이를 바탕으로 <a href="http://engineering.huiseoul.com">Huiseoul Engineering</a>에 글을 쓰는 것이 또 하나의 목표입니다.</p><p>Huiseoul에서는 현재도 다양한 좋은 사내문화를 정착시키고자 많은 생각과 노력을 하고 있습니다. 이상 약 두 달간 Huiseoul과 함께한 주니어 개발자 <a href="https://medium.com/u/8b9a16d7f8ee">Jitae Kim</a>였습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=82404728795b" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>