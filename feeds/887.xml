<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Yoon's devlog</title>
 <link href="http://blog.hyeyoonjung.com/atom.xml" rel="self"/>
 <link href="http://blog.hyeyoonjung.com/"/>
 <updated>2019-04-28T15:56:00+00:00</updated>
 <id>http://blog.hyeyoonjung.com</id>
 <author>
   <name>Hyeyoon</name>
   <email></email>
 </author>

 
 <entry>
   <title>Intersection Observer API의 사용법과 활용방법</title>
   <link href="http://blog.hyeyoonjung.com/2019/01/09/intersectionobserver-tutorial/"/>
   <updated>2019-01-09T00:00:00+00:00</updated>
   <id>http://blog.hyeyoonjung.com/2019/01/09/intersectionobserver-tutorial</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API&quot;&gt;Intersection Observer API&lt;/a&gt;(교차 관찰자 API)를 들어본 적이 있나요? 크롬 51버전부터 사용할 수 있는 이 Web API는 2016년 4월 &lt;a href=&quot;https://developers.google.com/web/updates/2016/04/intersectionobserver&quot;&gt;구글 개발자 페이지&lt;/a&gt; 통해 소개되었습니다. MDN을 비롯해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Intersection Observer&lt;/code&gt;를 어떻게 활용할 수 있을지 살펴보니 생각보다 다양한 곳에 적용할 수 있고, 앞으로 유용하게 쓸 수 있을 것 같습니다. MDN에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Intersection Observer&lt;/code&gt;의 필요성을 아래와 같은 예를 들어 설명하고 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;페이지 스크롤 시 이미지를 Lazy-loading(지연 로딩)할 때&lt;/li&gt;
  &lt;li&gt;Infinite scrolling(무한 스크롤)을 통해 스크롤할 때 새로운 콘텐츠를 불러올 때&lt;/li&gt;
  &lt;li&gt;광고의 수익을 계산하기 위해 광고의 가시성을 참고할 때&lt;/li&gt;
  &lt;li&gt;사용자가 결과를 볼 것인지에 따라 애니메이션 동작 여부를 결정할 때&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;현재(2019년 1월 기준)는 웹, 모바일 크롬, 안드로이드, 파이어폭스 등에서 지원하고 있으며 &lt;del&gt;아직 사파리, 모바일 사파리에서는 지원하지 않고 있습니다. 따라서 사파리, 아이폰의 경우 예시가 제대로 동작하지 않을 수 있습니다.&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://webkit.org/blog/8582/intersectionobserver-in-webkit/&quot;&gt;WebKit&lt;/a&gt;(2019년 2월 기준)에 따르면 Safari Technology Preview, macOS 10.14.4 beta, iOS 12.2 beta 버전에서 Intersection Observer를 사용할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;기존-scroll-이벤트의-문제&quot;&gt;기존 scroll 이벤트의 문제&lt;/h2&gt;

&lt;p&gt;웹사이트를 개발할 때 특정 위치에 도달했을 때 어떤 액션을 취해야 한다면 어떻게 구현할 수 있을까요? 보통 &lt;code class=&quot;highlighter-rouge&quot;&gt;addEventListener()&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;scroll&lt;/code&gt; 이벤트가 먼저 떠오릅니다. document에 스크롤 이벤트를 등록하고, 특정 지점을 관찰하며 엘리먼트가 위치에 도달했을 때 실행할 콜백함수를 등록하는 것이죠.&lt;/p&gt;

&lt;p&gt;하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;scroll&lt;/code&gt; 이벤트는 단시간에 수백번, 수천번 호출될 수 있고 동기적으로 실행되기 때문에 메인 스레드(Main Thread) 영향을 줍니다. 또한 한 페이지 내에 여러 &lt;code class=&quot;highlighter-rouge&quot;&gt;scroll&lt;/code&gt; 이벤트(무한 스크롤, 광고 배너, 애니메이션 등)가 등록되어 있을 경우, 각 엘리먼트마다 이벤트가 등록되어 있기 때문에 사용자가 스크롤할 때마다 이를 감지하는 이벤트가 끊임없이 호출됩니다. (&lt;code class=&quot;highlighter-rouge&quot;&gt;디바운싱(Debouncing)&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;쓰로틀링(Throttling)&lt;/code&gt;을 통해 이러한 문제를 개선시킬 수도 있습니다.) 그리고 특정 지점을 관찰하기 위해서는 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/API/Element/getBoundingClientRect&quot;&gt;getBoundingClientRect()&lt;/a&gt; 함수를 사용해야 하는데, 이 함수는 &lt;code class=&quot;highlighter-rouge&quot;&gt;리플로우(reflow)&lt;/code&gt; 현상이 발생한다는 단점이 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;리플로우(reflow): 리플로우는 브라우저가 웹 페이지의 일부 또는 전체를 다시 그려야하는 경우 발생한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;예시를 통해 살펴보겠습니다. 간단한 &lt;code class=&quot;highlighter-rouge&quot;&gt;addEventListener()&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;scroll&lt;/code&gt; 이벤트를 구현했습니다. 특정 위치에 도달하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;box&lt;/code&gt;엘리먼트에 애니메이션을 동작시키는 코드입니다.&lt;/p&gt;

&lt;iframe width=&quot;100%&quot; height=&quot;400&quot; src=&quot;//jsfiddle.net/hyeyoon/g1Lrfw76/22/embedded/result,js,html,css&quot; allowfullscreen=&quot;allowfullscreen&quot; allowpaymentrequest=&quot;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 해당 요소가 viewport 내에 있는지 확인하는 함수&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 대표적인 예시로 사용되고 있는 stackoverflow의 예시를 가져왔습니다.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// https://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport/7557433#7557433&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isElementInViewport&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;rect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getBoundingClientRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;rect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;top&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;rect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;rect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bottom&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerHeight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;documentElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;clientHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;rect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerWidth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;documentElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;clientWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// scroll 이벤트를 추가하고, 해당 element에 callback 함수를 등록하는 함수&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;addEventToEl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;elList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'scroll'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;elList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;el&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isElementInViewport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;classList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'tada'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;classList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'tada'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 동작시킬 elements리스트에 이벤트를 등록&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;boxElList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;querySelectorAll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'.box'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;addEventToEl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;boxElList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 코드를 크롬 개발자 도구의 Performance 탭을 통해 확인해보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;getBoundingClientRect()&lt;/code&gt;호출하는 과정에서 Recalculate Style, 리플로우 현상이 발생하는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/hyeyoon/blog/master/public/img/4/scroll-event-example.png&quot; alt=&quot;addEventListener scroll 예시&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;intersection-observer-api의-등장&quot;&gt;Intersection Observer API의 등장&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API&quot;&gt;Intersection Observer API&lt;/a&gt;(교차 관찰자 API)를 사용하면 위와 같은 문제를 해결할 수 있습니다. 비동기적으로 실행되기 때문에 메인 스레드에 영향을 주지 않으면서 변경 사항을 관찰할 수 있습니다. 또한 &lt;code class=&quot;highlighter-rouge&quot;&gt;IntersectionObserverEntry&lt;/code&gt;의 속성을 활용하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;getBoundingClientRect()&lt;/code&gt;를 호출한 것과 같은 결과를 알 수 있기 때문에 따로 &lt;code class=&quot;highlighter-rouge&quot;&gt;getBoundingClientRect()&lt;/code&gt; 함수를 호출할 필요가 없어 리플로우 현상을 방지할 수 있습니다.&lt;/p&gt;

&lt;p&gt;아래는 위에 예시와 같은 동작을 하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;Intersection Observer API&lt;/code&gt;를 사용해서 구현한 예제입니다.&lt;/p&gt;

&lt;iframe width=&quot;100%&quot; height=&quot;400&quot; src=&quot;//jsfiddle.net/hyeyoon/og319zw6/6/embedded/result,js,html,css&quot; allowfullscreen=&quot;allowfullscreen&quot; allowpaymentrequest=&quot;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// IntersectionObserver 를 등록한다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;io&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IntersectionObserver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;entries&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 관찰 대상이 viewport 안에 들어온 경우 'tada' 클래스를 추가&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;intersectionRatio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;classList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'tada'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 그 외의 경우 'tada' 클래스 제거&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;classList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'tada'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 관찰할 대상을 선언하고, 해당 속성을 관찰시킨다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;boxElList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;querySelectorAll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'.box'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;boxElList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;observe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드 또한 개발자 도구의 Performance 탭을 통해 확인해보면, 이 코드는 위의 예제와 달리 리플로우 현상이 발생하지 않는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/hyeyoon/blog/master/public/img/4/intersectionobserver-example.png&quot; alt=&quot;intersection observer 예시&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;intersection-observer-사용-방법&quot;&gt;Intersection Observer 사용 방법&lt;/h2&gt;
&lt;p&gt;Intersection Observer의 사용법에 대해 알아보겠습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#&quot;&gt;MDN&lt;/a&gt;에서는 IntersectionObserver를 아래와 같이 정의하고 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document’s viewport.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Intersection Observer API는 타겟 엘리먼트가 조상 엘리먼트, 또는 최상위 문서의 뷰포트(브라우저에서는 보통 브라우저의 viewport)의 교차영역에서 발생하는 변화를 비동기로 관찰하는 방법을 제공합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;기본 사용 방법은 아래와 같습니다. 여러 엘리먼트에 이벤트를 한 번에 등록하고 싶다면 콜백함수에 forEach를 사용해서 선언할 수 있습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/IntersectionObserver&quot;&gt;IntersectionObserver&lt;/a&gt;를 생성하기 위해서는 교차되었을 때 실행할 callback함수를 등록해야 하고, 선택적으로 options 값을 넘겨줄 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 기본구조는 콜백함수와 옵션을 받는다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;io&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IntersectionObserver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;parameters&quot;&gt;Parameters&lt;/h3&gt;
&lt;h4 id=&quot;callback&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;callback&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;callback&lt;/code&gt;: 타겟 엘리먼트가 교차되었을 때 실행할 함수
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;entries&lt;/code&gt;: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry&quot;&gt;IntersectionObserverEntry&lt;/a&gt; 객체의 리스트. 배열 형식으로 반환하기 때문에 forEach를 사용해서 처리를 하거나, 단일 타겟의 경우 배열인 점을 고려해서 코드를 작성해야 합니다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;observer&lt;/code&gt;: 콜백함수가 호출되는 IntersectionObserver&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;options&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;options&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;default: &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 브라우저의 viewport&lt;/li&gt;
      &lt;li&gt;교차 영역의 기준이 될 root 엘리먼트. observe의 대상으로 등록할 엘리먼트는 반드시 root의 하위 엘리먼트여야 합니다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/hyeyoon/blog/master/public/img/4/root.png&quot; alt=&quot;root 예시&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rootMargin&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;default: &lt;code class=&quot;highlighter-rouge&quot;&gt;'0px 0px 0px 0px'&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;root 엘리먼트의 마진값. css에서 margin을 사용하는 방법으로 선언할 수 있고, 축약도 가능하다. px과 %로 표현할 수 있습니다. rootMargin 값에 따라 교차 영역이 확장 또는 축소된다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/hyeyoon/blog/master/public/img/4/rootmargin.png&quot; alt=&quot;rootMargin 예시&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;threshold&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;default: &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;0.0부터 1.0 사이의 숫자 혹은 이 숫자들로 이루어진 배열로, 타겟 엘리먼트에 대한 교차 영역 비율을 의미합니다. 0.0의 경우 타겟 엘리먼트가 교차영역에 진입했을 시점에 observer를 실행하는 것을 의미하고, 1.0의 경우 타켓 엘리먼트 전체가 교차영역에 들어왔을 때 observer를 실행하는 것을 의미합니다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/hyeyoon/blog/master/public/img/4/threshold.png&quot; alt=&quot;threshold 예시&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 설명을 바탕으로 실제 어떻게 사용하는지 예시를 한 번 보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// options 설정&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;options&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;querySelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'.container'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// .container class를 가진 엘리먼트를 root로 설정. null일 경우 브라우저 viewport&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;rootMargin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'10px'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// rootMargin을 '10px 10px 10px 10px'로 설정&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;threshold&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 타겟 엘리먼트가 교차영역에 진입했을 때, 교차영역에 타켓 엘리먼트의 50%가 있을 때, 교차 영역에 타켓 엘리먼트의 100%가 있을 때 observe가 반응한다.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// IntersectionObserver 생성&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;io&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IntersectionObserver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// IntersectionObserverEntry 객체 리스트와 observer 본인(self)를 받음&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 동작을 원하는 것 작성&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// entry와 observer 출력&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'entry:'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'observer:'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;methods&quot;&gt;Methods&lt;/h3&gt;
&lt;h4 id=&quot;intersectionobserverobservetargetelement&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/observe&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IntersectionObserver.observe(targetElement)&lt;/code&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;타겟 엘리먼트에 대한 IntersectionObserver를 등록할 때(관찰을 시작할 때) 사용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;intersectionobserverunobservetargetelement&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/unobserve&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IntersectionObserver.unobserve(targetElement)&lt;/code&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;타겟 엘리먼트에 대한 관찰을 멈추고 싶을 때 사용하면 됩니다. 예를 들어 Lazy-loading(지연 로딩)을 할 때는 한 번 처리를 한 후에는 관찰을 멈춰도 됩니다. 이 경우에는 처리를 한 후 해당 엘리먼트에 대해 &lt;code class=&quot;highlighter-rouge&quot;&gt;unobserve(targetElement)&lt;/code&gt;을 실행하면 이 엘리먼트에 대한 관찰만 멈출 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;intersectionobserverdisconnect&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/disconnect&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IntersectionObserver.disconnect()&lt;/code&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;다수의 엘리먼트를 관찰하고 있을 때, 이에 대한 모든 관찰을 멈추고 싶을 때 사용하면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;intersectionobservertakerecords&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/takeRecords&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IntersectionObserver.takerecords()&lt;/code&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IntersectionObserverEntry&lt;/code&gt; 객체의 배열을 리턴합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;intersectionobserverentry-객체&quot;&gt;IntersectionObserverEntry 객체&lt;/h2&gt;
&lt;p&gt;위에서 IntersectionObserver에 대해 설명했을 때 IntersectionObserver에서 반환하는 callback은 IntersectionObserverEntry 객체의 배열을 반환한다고 했는데요. IntersectionObserver를 사용할 때 반환되는 이 객체의 정보는 어떤 동작을 등록하거나 할 때 유용하게 사용할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;properties&quot;&gt;Properties&lt;/h3&gt;
&lt;h4 id=&quot;사각형의-크기를-반환하는-속성&quot;&gt;사각형의 크기를 반환하는 속성&lt;/h4&gt;
&lt;p&gt;아래 세 가지 속성은 addEventListener를 설명할 때 언급했던 &lt;code class=&quot;highlighter-rouge&quot;&gt;Element.getBoundingClientRect()&lt;/code&gt;를 실행한 것과 같은 결과를 반환합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Element.getBoundingClientRect()&lt;/code&gt; 함수의 경우 호출 시 리플로우(reflow) 현상이 나타나지만, 아래의 속성을 사용하면 리플로우 없이 정보를 알 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry/boundingClientRect&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IntersectionObserverEntry.boundingClientRect&lt;/code&gt;&lt;/a&gt;: 타겟 엘리먼트의 정보를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry/rootBounds&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IntersectionObserverEntry.rootBounds&lt;/code&gt;&lt;/a&gt;: root 엘리먼트의 정보를 반환합니다. root를 선언하지 않았을 경우 null을 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry/intersectionRect&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IntersectionObserverEntry.intersectionRect&lt;/code&gt;&lt;/a&gt;: 교차된 영역의 정보를 반환합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/hyeyoon/blog/master/public/img/4/intersectionobserverentry.png&quot; alt=&quot;`intersectionobserverentry 예시`&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;유용한-정보를-반환하는-속성&quot;&gt;유용한 정보를 반환하는 속성&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry/intersectionRatio&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IntersectionObserverEntry.intersectionRatio&lt;/code&gt;&lt;/a&gt;: IntersectionObserver 생성자의 options의 threshold와 비슷합니다. 교차 영역에 타겟 엘리먼트가 얼마나 교차되어 있는지(비율)에 대한 정보를 반환합니다. threshold와 같이 0.0부터 1.0 사이의 값을 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry/isIntersecting&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IntersectionObserverEntry.isIntersecting&lt;/code&gt;&lt;/a&gt;: 타겟 엘리먼트가 교차 영역에 있는 동안 true를 반환하고, 그 외의 경우 false를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry/target&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IntersectionObserverEntry.target&lt;/code&gt;&lt;/a&gt;: 타겟 엘리먼트를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry/time&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IntersectionObserverEntry.time&lt;/code&gt;&lt;/a&gt;: 교차가 기록된 시간을 반환합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;lazy-loading-예제&quot;&gt;Lazy-Loading 예제&lt;/h2&gt;

&lt;p&gt;이제 IntersectionObserver API에 대해 알아본 것을 바탕으로 이를 활용한 Lazy-Loading 예제를 만들어보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;example&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://picsum.photos/600/400/?random?0&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;alt=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;random image&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;image-default&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;data-src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://picsum.photos/600/400/?random?1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;alt=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;random image&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;image&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;data-src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://picsum.photos/600/400/?random?2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;alt=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;random image&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;image&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;data-src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://picsum.photos/600/400/?random?3&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;alt=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;random image&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;image&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;data-src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://picsum.photos/600/400/?random?4&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;alt=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;random image&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;image&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;data-src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://picsum.photos/600/400/?random?5&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;alt=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;random image&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;image&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;data-src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://picsum.photos/600/400/?random?6&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;alt=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;random image&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;image&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;data-src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://picsum.photos/600/400/?random?7&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;alt=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;random image&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;image&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;html의 경우 기본으로 불러올 &lt;code class=&quot;highlighter-rouge&quot;&gt;img&lt;/code&gt; 하나를 제외하고 나머지 속성은 &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt; 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;data-src&lt;/code&gt; 속성에 이미지 주소를 선언했습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;일반적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 태그는 &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt; 속성을 만나면 이미지 소스를 내려받지만, 예시에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt; 속성 대신에 &lt;code class=&quot;highlighter-rouge&quot;&gt;data-src&lt;/code&gt;에 이미지 주소를 넣고 타겟 이미지가 교차 영역에 진입했을 때 타겟의 &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;data-src&lt;/code&gt;를 설정해주도록 했습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// IntersectionObserver의 options를 설정합니다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;options&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 타겟 이미지 접근 전 이미지를 불러오기 위해 rootMargin을 설정했습니다.&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;rootMargin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'0px 0px 30px 0px'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;threshold&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// IntersectionObserver 를 등록한다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;io&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IntersectionObserver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 관찰 대상이 viewport 안에 들어온 경우 image 로드&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isIntersecting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// data-src 정보를 타켓의 src 속성에 설정&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;dataset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 이미지를 불러왔다면 타켓 엘리먼트에 대한 관찰을 멈춘다.&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;unobserve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 관찰할 대상을 선언하고, 해당 속성을 관찰시킨다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;images&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;querySelectorAll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'.image'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;images&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;observe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;자바스크립트의 경우 위와 같이 구현합니다. css의 경우 아래 jsfiddle 예제의 css 탭을 참고하시면 될 것 같습니다. 아래는 위의 코드를 구현해놓은 예제입니다. 스크롤을 내려보면, 스크롤이 해당 이미지의 위치에 도달했을 때 이미지를 로딩하고 있습니다.&lt;/p&gt;

&lt;iframe width=&quot;100%&quot; height=&quot;400&quot; src=&quot;//jsfiddle.net/hyeyoon/3yzoufem/32/embedded/result,js,html,css&quot; allowfullscreen=&quot;allowfullscreen&quot; allowpaymentrequest=&quot;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;크롬 개발자 도구의 Network 탭을 보면 순차적으로 이미지를 불러오는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/hyeyoon/blog/master/public/img/4/lazy-loading.png&quot; alt=&quot;lazyloading 예시&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;마무리&quot;&gt;마무리&lt;/h2&gt;
&lt;p&gt;이상으로 IntersectionObserver API에 대해 알아봤습니다. IntersectionObserver를 활용하면 기존에 사용하고 있던 scroll 이벤트 중 IntersectionObserver로 구현할 수 있는 경우에는 기존 코드 대비 성능을 개선할 수 있고, 그 외에도 웹에 게시된 광고의 수익을 활용하는 등 다양한 영역에 활용할 수 있을 것 같습니다. 아직 Safari에서 지원을 하지 않는다는 아쉬움이 있지만, &lt;a href=&quot;https://github.com/w3c/IntersectionObserver/tree/master/polyfill&quot;&gt;polyfill&lt;/a&gt;을 제공하고 있기 때문에 한 번 사용해보는 것도 좋을 것 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;참고문헌&quot;&gt;참고문헌&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#&quot;&gt;IntersectionObserver API MDN&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/updates/2016/04/intersectionobserver&quot;&gt;IntersectionObserver’s Coming into View&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.smashingmagazine.com/2018/01/deferring-lazy-loading-intersection-observer-api/?utm_source=frontendfocus&amp;amp;utm_medium=email&quot;&gt;Now You See Me: How To Defer, Lazy-Load And Act With IntersectionObserver&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/codepink/codepink.github.com/wiki/%EB%84%88%EB%8A%94-%EB%82%98%EB%A5%BC-%EB%B3%B8%EB%8B%A4:-%EC%A7%80%EC%97%B0-%EB%B0%A9%EB%B2%95,-%EB%A0%88%EC%9D%B4%EC%A7%80-%EB%A1%9C%EB%93%9C%EC%99%80-IntersectionObserver%EC%9D%98-%EB%8F%99%EC%9E%91&quot;&gt;너는 나를 본다: 지연 방법, 레이지 로드와 IntersectionObserver의 동작&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://tech.lezhin.com/2017/07/13/intersectionobserver-overview&quot;&gt;IntersectionObserver를 이용한 이미지 동적 로딩 기능 개선&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>초보자를 위한 깃(Git) 사용법</title>
   <link href="http://blog.hyeyoonjung.com/2017/06/01/how-to-use-git/"/>
   <updated>2017-06-01T00:00:00+00:00</updated>
   <id>http://blog.hyeyoonjung.com/2017/06/01/how-to-use-git</id>
   <content type="html">&lt;p&gt;프로그래밍 프로젝트를 진행할 때 이전 버전의 코드를 보고 싶을 때, 또는 팀원들과 함께 프로젝트를 진행할 때가 있습니다. 또 직접 작성한 코드를 회사, 타인에게 보여주고 싶을 때도 있죠. 그럴 때 유용하게 사용할 수 있는 것이 깃(Git)입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://git-scm.com/&quot;&gt;Git 공식 홈페이지&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Git-logo.svg/1200px-Git-logo.svg.png&quot; alt=&quot;깃&quot; /&gt;&lt;/p&gt;
&lt;center&gt;source: wikipedia&lt;/center&gt;

&lt;blockquote&gt;
  &lt;p&gt;깃(Git)은 프로그램 등의 소스 코드 관리를 위한 분산 버전 관리 시스템이다. 기하학적 불변 이론을 바탕으로 설계됐고, 빠른 수행 속도에 중점을 두고 있는 것이 특징이다. 최초에는 리누스 토르발스가 리눅스 커널 개발에 이용하려고 개발하였으며, 현재는 다른 곳에도 널리 사용되고 있다. - Wikipedia&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;흔히 깃(Git)과 깃허브(Github)를 동일한 것으로 생각할 때가 있는데요. 깃허브는 깃 레포지토리를 웹에 호스팅할 수 있도록 지원하는 서비스입니다. 이러한 호스팅 서비스는 깃허브를 비롯해서 깃랩(Gitlab) 등 다양한 서비스가 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/&quot;&gt;Github&lt;/a&gt; : 오픈 소스 프로젝트에 좋음. 비공개 저장소의 경우 유료로 서비스 제공&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://about.gitlab.com/&quot;&gt;Gitlab&lt;/a&gt; : 비공개 저장소를 무료로 사용할 수 있음.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;깃git-설치--설정&quot;&gt;깃(Git) 설치 &amp;amp; 설정&lt;/h2&gt;
&lt;h3 id=&quot;깃-설치하기&quot;&gt;깃 설치하기&lt;/h3&gt;
&lt;p&gt;Mac os에서는 Xcode가 설치되어 있다면 기본적으로 git이 설치되어 있습니다. 깃이 설치되었는지 확인하고 싶다면 터미널 창에 &lt;code class=&quot;highlighter-rouge&quot;&gt;git --version&lt;/code&gt;라는 깃의 버전을 확인하는 명령어를 통해서 확인할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://git-scm.com/book/ko/v1/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-Git-%EC%84%A4%EC%B9%98&quot;&gt;깃(git) 설치 가이드라인&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;깃-config-설정&quot;&gt;깃 config 설정&lt;/h3&gt;
&lt;p&gt;깃 설치를 완료했다면 git config 설정을 통해 사용 환경을 세팅할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자 설정
깃을 커밋할 때 입력되는 사용자의 이메일과 이름 정보를 등록하는 방법입니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git config &lt;span class=&quot;nt&quot;&gt;--global&lt;/span&gt; user.name &lt;span class=&quot;s2&quot;&gt;&quot;Gil Dong&quot;&lt;/span&gt;
git config &lt;span class=&quot;nt&quot;&gt;--global&lt;/span&gt; user.email example@example.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;편집기 설정
깃에서 주로 사용할 텍스트 편집기를 입력합니다. 기본 설정된 편집기는 vi, vim editor인데요. 필자는 vim 에디터가 익숙하지 않아서 기본 편집기를 주로 사용하는 atom으로 설정했습니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git config &lt;span class=&quot;nt&quot;&gt;--global&lt;/span&gt; core.editor atom
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;git config 설정 확인
git config 설정이 제대로 되었는지 확인하고 싶다면 아래와 같은 명령어를 입력하면 됩니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git config &lt;span class=&quot;nt&quot;&gt;--list&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;더 자세한 설정을 알고싶다면 공식 문서를 참고하세요.&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;&lt;a href=&quot;https://git-scm.com/book/ko/v1/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-Git-%EC%B5%9C%EC%B4%88-%EC%84%A4%EC%A0%95&quot;&gt;공식 가이드&lt;/a&gt;&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;깃-시작하기&quot;&gt;깃 시작하기&lt;/h2&gt;
&lt;p&gt;깃 설치와 세팅을 완료했다면, 이제 깃을 시작해볼까요? 깃은 레포지토리(폴더)에 깃 저장소를 만들거나 다른 서버에 있는 저장소를 클론할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;레포지토리폴더를-깃-저장소로-만들기&quot;&gt;레포지토리(폴더)를 깃 저장소로 만들기&lt;/h3&gt;
&lt;p&gt;터미널 창에서 깃 저장소 설치를 원하는 폴더로 이동한 후 아래의 명령어를 입력하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt;이라는 파일이 생성됩니다.&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git init
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt;은 기본적으로 숨김 파일이기 때문에 숨김 파일을 보이게 설정하거나 터미널 명령어에 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls -a&lt;/code&gt;를 입력하면 숨김 파일까지 포함한 폴더와 파일을 볼 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;레포지토리의-상태-확인하기&quot;&gt;레포지토리의 상태 확인하기&lt;/h3&gt;
&lt;p&gt;깃 저장소를 설치한 레포지토리는 내부에 파일이 수정거나 추가, 삭제와 같은 변경사항이 있을 때를 추적할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git status
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위의 명령어를 입력하면 변경이 있는 파일에 대해서는 빨간색(기본)으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Untracked&lt;/code&gt;상태라고 알려줍니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Tracked&lt;/code&gt; 된 파일의 경우 보통 초록색으로 표시됩니다. 만약 변경된 파일이 없을 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;nothing to commit, working directory clean&lt;/code&gt;이렇게 커밋할 파일이 없다고 나옵니다.&lt;/p&gt;

&lt;h3 id=&quot;파일을-staging-area로-올리기&quot;&gt;파일을 staging area로 올리기&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/images/about/index1@2x.png&quot; alt=&quot;git add&quot; /&gt;&lt;/p&gt;
&lt;center&gt;source: git-scm&lt;/center&gt;
&lt;p&gt;위의 그림을 보면 이해가 쉬운데요. 깃 저장소는 그림과 같이 구성되는데요. &lt;code class=&quot;highlighter-rouge&quot;&gt;untracked&lt;/code&gt;되었다는 것은 아직 working directory에 있다는 것이고, 그 파일을 &lt;code class=&quot;highlighter-rouge&quot;&gt;tracked&lt;/code&gt;되게 하려면 아래의 명령어를 통해 파일을 staging area로 옮겨줘야 합니다.&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git add 파일명     &lt;span class=&quot;c&quot;&gt;# 파일 단위로 올리는 방법&lt;/span&gt;
git add &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;# 변경된 전체 파일을 올리는 방법&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 파일을 staging area로 옮겼다면, 이제 커밋을 통해 레포지토리에 변경사항을 적용할 수 있습니다. 그리고 혹시 staging area 올린 파일을 &lt;code class=&quot;highlighter-rouge&quot;&gt;untracked&lt;/code&gt;로 변경하고 싶다면 아래의 명령어를 통해 해결할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git reset HEAD 파일명
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;commit을-통해-레포지토리에-변경사항-적용하기&quot;&gt;commit을 통해 레포지토리에 변경사항 적용하기&lt;/h3&gt;
&lt;p&gt;변경사항을 레포지토리에 적용시키기 위해서는 아래의 명령어를 입력해서 커밋하면 됩니다.&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git commit                        &lt;span class=&quot;c&quot;&gt;# 깃 에디어를 통해 커밋 메세지 입력&lt;/span&gt;
git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;commit message&quot;&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;# 인라인으로 커밋 메세지 입력하는 법&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;만약 staging area에 파일을 추가하고 커밋 메세지를 입력하는 것이 번거롭다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;-a&lt;/code&gt;옵션을 추가해서 한 번에 해결할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git commit &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;commit message&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 깃 기본 사용법에 대해 알아봤습니다. 깃을 잘 활용하면 프로젝트 관리에 유용하게 사용할 수 있는데요. 만약 터미널 환경이 익숙하지 않다면 소스트리와 같은 프로그램을 활용하는 방법도 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.sourcetreeapp.com/&quot;&gt;source tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;또한 깃에 대해 더 자세히 알고 싶다면 아래의 강의를 추천합니다. 필자는 Udacity 강의를 통해 깃을 공부했는데요. 생활코딩 또한 Git 강의를 제공하고 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://opentutorials.org/course/2708&quot;&gt;생활코딩 - 지옥에서 온 Git&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.udacity.com/course/how-to-use-git-and-github--ud775&quot;&gt;Udacity - How to Use Git and GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;참고문헌&quot;&gt;참고문헌&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://git-scm.com/&quot;&gt;Git 공식 페이지&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>마크다운(Markdown) 사용법</title>
   <link href="http://blog.hyeyoonjung.com/2017/05/30/how-to-use-markdown/"/>
   <updated>2017-05-30T00:00:00+00:00</updated>
   <id>http://blog.hyeyoonjung.com/2017/05/30/how-to-use-markdown</id>
   <content type="html">&lt;p&gt;개발을 공부하다보면, 특히 깃허브(github)를 사용하면 마크다운(Markdown)의 필요성을 느끼게 됩니다. 깃허브에 자신이 올린 레포지토리에 관한 설명을 적을 때나, 도큐멘테이션 작업을 할 때 마크다운을 사용하게 되는데요. 현재 제가 작성중인 지킬(jekyll) 또한 마크다운으로 작성합니다. 오늘은 마크다운으로 문서를 정리할 때 꼭 필요한 문법들을 정리해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;제목heading&quot;&gt;제목(Heading)&lt;/h2&gt;
&lt;p&gt;문서를 작성할 때 가장 기본이 되는 제목은 HTML의 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;~&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;h6&amp;gt;&lt;/code&gt; 태그와 유사합니다. #의 개수에 따라 글자의 크기가 달라집니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;###&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;h3&amp;gt;&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;######&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;h6&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Heading
### Heading
###### Heading
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;heading&quot;&gt;Heading&lt;/h1&gt;
&lt;h3 id=&quot;heading-1&quot;&gt;Heading&lt;/h3&gt;
&lt;h6 id=&quot;heading-2&quot;&gt;Heading&lt;/h6&gt;

&lt;h2 id=&quot;본문paragraph&quot;&gt;본문(paragraph)&lt;/h2&gt;
&lt;p&gt;HTML의 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt;와 같은 본문은 텍스트를 그대로 작성하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit&lt;/p&gt;

&lt;h2 id=&quot;인용blockquotes&quot;&gt;인용(Blockquotes)&lt;/h2&gt;
&lt;p&gt;인용은 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;를 넣어서 작성합니다.&lt;/p&gt;
&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gt&quot;&gt;&amp;gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit&lt;/span&gt;
&lt;span class=&quot;gt&quot;&gt;&amp;gt;&amp;gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;리스트&quot;&gt;리스트&lt;/h2&gt;
&lt;h3 id=&quot;순서가-없는-리스트unordered-list&quot;&gt;순서가 없는 리스트(Unordered List)&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;를 사용해서 순서가 없는 리스트를 작성할 수 있습니다. tab 또는 2칸 띄어쓰기를 통해 중첩된 항목을 작성할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; Frontend
&lt;span class=&quot;p&quot;&gt;  *&lt;/span&gt; HTML
&lt;span class=&quot;p&quot;&gt;  *&lt;/span&gt; CSS
&lt;span class=&quot;p&quot;&gt;  *&lt;/span&gt; JavaScript
&lt;span class=&quot;p&quot;&gt;    *&lt;/span&gt; Vue.js
&lt;span class=&quot;p&quot;&gt;
-&lt;/span&gt; Frondend
&lt;span class=&quot;p&quot;&gt;  -&lt;/span&gt; HTML
&lt;span class=&quot;p&quot;&gt;  -&lt;/span&gt; CSS
&lt;span class=&quot;p&quot;&gt;  -&lt;/span&gt; JavaScript
&lt;span class=&quot;p&quot;&gt;    -&lt;/span&gt; Vue.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Frontend
    &lt;ul&gt;
      &lt;li&gt;HTML&lt;/li&gt;
      &lt;li&gt;CSS&lt;/li&gt;
      &lt;li&gt;JavaScript
        &lt;ul&gt;
          &lt;li&gt;Vue.js&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Frondend
    &lt;ul&gt;
      &lt;li&gt;HTML&lt;/li&gt;
      &lt;li&gt;CSS&lt;/li&gt;
      &lt;li&gt;JavaScript
        &lt;ul&gt;
          &lt;li&gt;Vue.js&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;순서가-있는-리스트ordered-list&quot;&gt;순서가 있는 리스트(Ordered List)&lt;/h3&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;1.&lt;/span&gt; HTML
&lt;span class=&quot;p&quot;&gt;2.&lt;/span&gt; CSS
&lt;span class=&quot;p&quot;&gt;3.&lt;/span&gt; JavaScript
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;HTML&lt;/li&gt;
  &lt;li&gt;CSS&lt;/li&gt;
  &lt;li&gt;JavaScript&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;1.&lt;/span&gt; HTML
&lt;span class=&quot;p&quot;&gt;1.&lt;/span&gt; CSS
&lt;span class=&quot;p&quot;&gt;1.&lt;/span&gt; JavaScript
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;HTML&lt;/li&gt;
  &lt;li&gt;CSS&lt;/li&gt;
  &lt;li&gt;JavaScript&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;1.&lt;/span&gt; Frontend
&lt;span class=&quot;p&quot;&gt;    1.&lt;/span&gt; HTML
&lt;span class=&quot;p&quot;&gt;    2.&lt;/span&gt; CSS
&lt;span class=&quot;p&quot;&gt;    3.&lt;/span&gt; JavaScript
&lt;span class=&quot;p&quot;&gt;        1.&lt;/span&gt; Vue.js
&lt;span class=&quot;p&quot;&gt;2.&lt;/span&gt; Backend
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Frontend
    &lt;ol&gt;
      &lt;li&gt;HTML&lt;/li&gt;
      &lt;li&gt;CSS&lt;/li&gt;
      &lt;li&gt;JavaScript
        &lt;ol&gt;
          &lt;li&gt;Vue.js&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Backend&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;코드블럭code-blocks&quot;&gt;코드블럭(Code blocks)&lt;/h2&gt;
&lt;p&gt;코드블럭은 일반 문장 사이에 단어, 짧은 문장 단위로 표현할 수 있는 방법과 여러줄의 코드를 삽입하는 방법이 있습니다.&lt;/p&gt;

&lt;p&gt;단어, 한 줄의 코드를 감싸는 경우 `를 앞뒤로 감쌉니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Markdown&quot;&gt;마크다운은 코드블럭을 `&amp;lt;pre&amp;gt;`와 `&amp;lt;code&amp;gt;`로 감쌉니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;마크다운은 코드블럭을 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;code&amp;gt;&lt;/code&gt;로 감쌉니다.&lt;/p&gt;

&lt;p&gt;여러줄의 코드를 나타내는 코드블럭의 경우 코드블럭의 시작과 끝을 ```으로 감싸고 내부에 코드를 작성하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;square&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;수평선horizontal-rules&quot;&gt;수평선(Horizontal Rules)&lt;/h2&gt;
&lt;p&gt;문단과 문단 사이를 나눌 때 등 사용되는 수평선은 HTML의 &amp;lt;hr /&amp;gt;과 같이 동작합니다.&lt;/p&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;* * *
***
*****&lt;/span&gt;
&lt;span class=&quot;gh&quot;&gt;- - -
---------------------------------------
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;링크links&quot;&gt;링크(Links)&lt;/h2&gt;
&lt;p&gt;HTML의 하이퍼링크와 같은 링크는 다음과 같이 작성합니다. title은 생략이 가능합니다.&lt;/p&gt;
&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;sx&quot;&gt;http://example.com&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

검색엔진은 &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;구글&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;sx&quot;&gt;https://www.google.com&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;&quot;구글&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;을 사용합니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://example.com&quot; title=&quot;title&quot;&gt;example&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;검색엔진은 &lt;a href=&quot;https://www.google.com&quot; title=&quot;구글&quot;&gt;구글&lt;/a&gt;을 사용합니다.&lt;/p&gt;

&lt;h2 id=&quot;강조emphasis&quot;&gt;강조(Emphasis)&lt;/h2&gt;
&lt;p&gt;HTML의 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;em&amp;gt;&lt;/code&gt;과 같은 동작을 하는 강조는 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;가 있고 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;**&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;__&lt;/code&gt;를 사용합니다. 취소선은 &lt;code class=&quot;highlighter-rouge&quot;&gt;~~&lt;/code&gt;을 사용합니다.&lt;/p&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ge&quot;&gt;*강조*&lt;/span&gt;한 텍스트
&lt;span class=&quot;ge&quot;&gt;_강조_&lt;/span&gt;한 텍스트

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;강조&lt;/em&gt;한 텍스트&lt;/p&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gs&quot;&gt;**강조**&lt;/span&gt;한 텍스트
&lt;span class=&quot;gs&quot;&gt;__강조__&lt;/span&gt;한 텍스트
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;강조&lt;/strong&gt;한 텍스트&lt;/p&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~~취소~~한 텍스트
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;del&gt;취소&lt;/del&gt;한 텍스트&lt;/p&gt;

&lt;h2 id=&quot;이미지-삽입images&quot;&gt;이미지 삽입(Images)&lt;/h2&gt;
&lt;p&gt;이미지는 역시 HTML의 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;img&amp;gt;&lt;/code&gt;태그와 동일하게 작동합니다. 대체 택스트를 삽입할 수 있으며, 링크 또는 로컬의 이미지파일을 연결할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;![&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;대체 텍스트&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;sx&quot;&gt;/경로/example.jpg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;![&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;대체 텍스트&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;sx&quot;&gt;링크&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;![&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Github&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;sx&quot;&gt;./public/img/3/github.png&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.hyeyoonjung.com/public/img/3/github.png&quot; alt=&quot;Github&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;![&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Github&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;sx&quot;&gt;https://assets-cdn.github.com/images/modules/open_graph/github-octocat.png&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://assets-cdn.github.com/images/modules/open_graph/github-octocat.png&quot; alt=&quot;Github&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이상으로 마크다운의 기본 문법에 대해 알아봤습니다.&lt;/p&gt;

&lt;h2 id=&quot;참고문헌&quot;&gt;참고문헌&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://daringfireball.net/projects/markdown/syntax&quot;&gt;존 그루버의 Markdown: Syntax&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Jekyll 블로그 github를 통해 퍼블리싱하는 방법</title>
   <link href="http://blog.hyeyoonjung.com/2017/05/22/how-to-write-posts/"/>
   <updated>2017-05-22T00:00:00+00:00</updated>
   <id>http://blog.hyeyoonjung.com/2017/05/22/how-to-write-posts</id>
   <content type="html">&lt;p&gt;지난 포스트를 통해 Jekyll을 설치하고 시작하는 방법에 대해 알아봤는데요.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.hyeyoonjung.com/2017/05/04/how-to-start-jekyll/&quot;&gt;Jekyll로 시작하는 블로그&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;지난번에 만든 파일을 활용해서 Github에 연결하고 배포하는 방법을 소개해드릴게요.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
├── Gemfile
├── Gemfile.lock
├── _config.yml
├── _posts
│   └── 2017-05-06-welcome-to-jekyll.markdown
├── _site
│   ├── about
│   │   └── index.html
│   ├── assets
│   │   └── main.css
│   ├── feed.xml
│   ├── index.html
│   └── jekyll
│       └── update
│           └── 2017
│               └── 05
│                   └── 06
│                       └── welcome-to-jekyll.html
├── about.md
└── index.md

9 directories, 11 files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jekyll을 오류없이 설치했다면 생성한 블로그 폴더에 위와 같은 구조를 갖춘 폴더와 파일들이 설치됩니다.&lt;/p&gt;

&lt;h3 id=&quot;블로그-기본-설정setting&quot;&gt;블로그 기본 설정(setting)&lt;/h3&gt;

&lt;p&gt;Jekyll 설치 후 가장 먼저 해야할 일은 블로그의 타이틀을 비롯해서 필자의 정보(이메일, SNS 계정 등)을 설정하는 것인데요. 블로그 폴더 최상단에 위치한 &lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; 파일에서 블로그 기본 세팅을 할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;title: Your awesome title
email: your-email@domain.com
description: &amp;gt; # this means to ignore newlines until &quot;baseurl:&quot;
  Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
baseurl: &quot;&quot; # the subpath of your site, e.g. /blog
url: &quot;&quot; # the base hostname &amp;amp; protocol for your site, e.g. http://example.com
twitter_username: jekyllrb
github_username:  jekyll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;블로그-글-작성&quot;&gt;블로그 글 작성&lt;/h3&gt;

&lt;p&gt;Jekyll은 마크다운(markdown) 형식으로 포스트를 작성해서 Github을 통해 퍼블리싱을 하는 방식으로 블로그를 운영하는데요. &lt;code class=&quot;highlighter-rouge&quot;&gt;_post&lt;/code&gt; 폴더에 &lt;code class=&quot;highlighter-rouge&quot;&gt;.markdown&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;.md&lt;/code&gt; 형식으로 블로그 글을 작성하고 저장하면 됩니다. 여기서 지켜야 할 규칙 몇 가지가 있는데요.&lt;/p&gt;

&lt;h4 id=&quot;포스트-파일-형식&quot;&gt;포스트 파일 형식&lt;/h4&gt;

&lt;p&gt;블로그에 올릴 각각의 포스트는 일정한 이름 규칙을 따라야 합니다. Jekyll블로그를 설치했을 때 기본적으로 생성되는 예시 포스트를 보면&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2017-05-06-welcome-to-jekyll.markdown&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;위와 같은 형식을 갖는데요. &lt;code class=&quot;highlighter-rouge&quot;&gt;년-월-일-포스트 제목&lt;/code&gt; 순으로 파일 이름을 작성하면 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;포스트-기본-형식&quot;&gt;포스트 기본 형식&lt;/h4&gt;

&lt;p&gt;그리고 포스트의 내부를 보면 상단에 포스트에 관련된 정보를 작성하는 란이 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nn&quot;&gt;---&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;layout&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;post&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Welcome&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Jekyll!&quot;&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;   &lt;span class=&quot;s&quot;&gt;2017-05-06 13:45:35 +0900&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;categories&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;jekyll update&lt;/span&gt;
&lt;span class=&quot;nn&quot;&gt;---&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;글을 작성하기 전 상단에 위와 같은 형식으로 제목, 날짜, 카테고리 등을 설정해주면 퍼블리싱을 했을 때 글의 제목과 작성된 날짜 등이 포스트에 나타납니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.hyeyoonjung.com/public/img/2/jekyll_post.png&quot; alt=&quot;블로그 설정&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;github에-배포하기&quot;&gt;Github에 배포하기&lt;/h3&gt;
&lt;p&gt;이제 블로그를 온라인에 배포해야하는 단계가 남았는데요. Github을 통해 퍼블리싱을 할 경우 무료로 블로그를 배포할 수 있다는 장점이 있습니다. Github에 퍼블리싱을 하기 위해서는 일단 Github 계정이 있어야 합니다. 계정이 없을 경우 Github에서 계정을 만들어주세요.
&lt;a href=&quot;https://github.com/&quot;&gt;Github 사이트&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;github-레포지토리-만들기&quot;&gt;Github 레포지토리 만들기&lt;/h4&gt;
&lt;p&gt;회원가입 혹은 로그인을 완료했다면, 우측 상단의 +아이콘을 누르고 New Repository를 클릭하거나, 우측 하단의 New repository라는 버튼을 클릭해서 레포지토리를 생성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.hyeyoonjung.com/public/img/2/git_repository2.png&quot; alt=&quot;Github repository&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;github에-블로그-폴더-업로드&quot;&gt;Github에 블로그 폴더 업로드&lt;/h4&gt;
&lt;p&gt;레포지토리를 만드는 것까지 완료했다면, 이제 터미널 혹은 터미널이 익숙하지 않은 경우 소스트리(source tree)와 같은 프로그램을 이용해서 블로그 폴더를 Github 사이트에 업로드하면 됩니다.&lt;/p&gt;

&lt;p&gt;아래의 명령어를 순서대로 터미널에 입력하면 됩니다.&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Jekyll 블로그를 설치한 터미널로 이동 후 git 활성화&lt;/span&gt;
git init
&lt;span class=&quot;c&quot;&gt;# 블로그 폴더를 git staging 상태로 올리기&lt;/span&gt;
git add &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 커밋 메세지 작성&lt;/span&gt;
git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Add blog&quot;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# github 레포지토리 주소 연결&lt;/span&gt;
git remote add origin 본인의 레포지토리 주소
&lt;span class=&quot;c&quot;&gt;# github에 파일 업로드&lt;/span&gt;
git push &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;터미널 환경 혹은 git에 익숙하지 않다면 이 과정에서 어려움을 겪을 수 있는데요. 생활코딩과 같은 곳에서 git에 관련된 강의를 들으면 좀 더 쉽게 github를 활용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://opentutorials.org/course/2708&quot;&gt;생활코딩: 지옥에서 온 Git&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;위의 명령어가 제대로 동작했다면 아래와 같이 파일들이 올라간 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.hyeyoonjung.com/public/img/2/github.png&quot; alt=&quot;Github&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;github의-git-pages-기능으로-블로그-배포하기&quot;&gt;Github의 git pages 기능으로 블로그 배포하기&lt;/h4&gt;
&lt;p&gt;블로그 배포를 위해서는 git pages 기능을 활용해야하는데요. 정적인 웹사이트를 Github을 통해 무료로 퍼블리싱할 수 있는 기능입니다. github 레포지토리 페이지에서 상단에 Settings를 클릭합니다. 이 곳에서 레포지토리의 이름를 바꾸고 콜라보레이터를 등록하는 등의 작업을 할 수 있는데요. 아래로 내려서 Github pages라는 부분을 찾습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.hyeyoonjung.com/public/img/2/github_pages.png&quot; alt=&quot;Github pages&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그리고 source를 클릭해서 배포를 원하는 브랜치를 선택하는데요. 저는 일단 master 브랜치를 배포 대상으로 선택했습니다. 그리고 save를 클릭하면 퍼블리싱되고 있는 주소가 상단의 이미지처럼 나타납니다. 약 5~10분 정도 후에 주소를 들어가면 본인의 블로그가 퍼블리싱 된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.hyeyoonjung.com/public/img/2/github_pages2.png&quot; alt=&quot;Github pages&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jekyll로 github 블로그 만드는 방법</title>
   <link href="http://blog.hyeyoonjung.com/2017/05/04/how-to-start-jekyll/"/>
   <updated>2017-05-04T00:00:00+00:00</updated>
   <id>http://blog.hyeyoonjung.com/2017/05/04/how-to-start-jekyll</id>
   <content type="html">&lt;p&gt;Jekyll(지킬)은 Markdown(마크다운) 등으로 작성된 파일을 변환시켜서 실제 웹 상에서 읽을 수 있게 해주는 정적 사이트 생성기입니다. Github의 정적인 페이지를 호스팅할 수 있는 기능인 git pages를 통해 jekyll을 통해서 만든 블로그를 퍼블리싱할 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll 공식 사이트&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://jekyllrb-ko.github.io/&quot;&gt;Jekyll 한글 문서&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;jekyll-설치-방법&quot;&gt;Jekyll 설치 방법&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;mac Os기준으로 설명했습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;requirementsjekyll-3&quot;&gt;Requirements(Jekyll 3)&lt;/h3&gt;

&lt;p&gt;Jekyll을 설치하기 위해서는 아래의 환경이 사용자의 os에 설치되어 있어야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Linux, Unix, macOs 환경&lt;/li&gt;
  &lt;li&gt;2.0버전 이상의 &lt;a href=&quot;https://www.ruby-lang.org/en/downloads/&quot;&gt;Ruby&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://rubygems.org/pages/download&quot;&gt;RubyGems&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gcc.gnu.org/install/&quot;&gt;GCC&lt;/a&gt;, &lt;a href=&quot;https://www.gnu.org/software/make/&quot;&gt;Make&lt;/a&gt; (사용하고 있는 os에 GCC와 Make가 설치되어 있지 않은 경우에 설치 필요. 설치되었는지 확인하는 방법은 터미널에 &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc -v&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;make -v&lt;/code&gt; 를 입력해서 확인 가능)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Jekyll 2 혹은 그 이하의 버전의 경우&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Node JS 또는 다른 JavaScrupt실행환경(CoffeeScript 지원을 위해서 필요)&lt;/li&gt;
  &lt;li&gt;Python 2.7&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jekyll-설치&quot;&gt;Jekyll 설치&lt;/h3&gt;

&lt;p&gt;Jekyll을 설치하기 위한 환경세팅이 끝났다면, 아래의 명령어를 터미널에 입력해서 Jekyll을 설치할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install jekyll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jekyll을 설치할 때 에러가 발생할 경우 Jekyll의 &lt;a href=&quot;http://jekyllrb.com/docs/troubleshooting/#configuration-problems&quot;&gt;troubleshooting&lt;/a&gt; 페이지를 참고해서 문제를 해결하거나, &lt;a href=&quot;https://github.com/jekyll/jekyll/issues/new&quot;&gt;Jekyll 커뮤니티&lt;/a&gt;에 이슈 사항에 대한 리포트를 보내서 해결할 수 있습니다.&lt;/p&gt;

&lt;p&gt;필자의 경우 기존에 설치되어 있던 Ruby와 RubyGems의 버전 때문에 에러가 발생했는데 아래와 같은 방법으로 문제를 해결했습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;gem update &lt;span class=&quot;nt&quot;&gt;--system&lt;/span&gt;	// RubyGems 업데이트
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;gem install jekyll 	// &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;권한으로 설치하려 했으나 오류 발생
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;gem install &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; /usr/local/bin jekyll	// 이 방법으로 설치
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;jekyll-시작하기&quot;&gt;Jekyll 시작하기&lt;/h3&gt;

&lt;p&gt;os에 Jekyll을 설치하는 것까지 완료했다면 이제 아래의 명령어를 터미널에 입력해서 블로그를 만들면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll new blog		// blog 대신 원하는 디렉토리명&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;폴더명&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;을 설정해도 됩니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;이 과정에서 bundler 관련한 에러가 발생했을 경우, 필자는 다음과 같은 방법으로 bundler를 설치해서 에러를 해결했습니다.&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo gem install -n /usr/local/bin bundler&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;설치가 끝나면 명령어를 입력한 경로에 아래의 구조를 갖는 blog(디렉토리명)라는 폴더가 생깁니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
├── Gemfile
├── Gemfile.lock
├── _config.yml
├── _posts
│   └── 2017-05-06-welcome-to-jekyll.markdown
├── _site
│   ├── about
│   │   └── index.html
│   ├── assets
│   │   └── main.css
│   ├── feed.xml
│   ├── index.html
│   └── jekyll
│       └── update
│           └── 2017
│               └── 05
│                   └── 06
│                       └── welcome-to-jekyll.html
├── about.md
└── index.md

9 directories, 11 files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;jekyll-블로그-실행하기&quot;&gt;Jekyll 블로그 실행하기&lt;/h3&gt;

&lt;p&gt;blog 폴더로 이동한 후 아래의 명령어를 입력하면 로컬 서버(기본 주소: http://localhost:4000)에서 Jekyll로 구축한 블로그를 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;blog 	// blog 폴더로 이동
jekyll serve &lt;span class=&quot;nt&quot;&gt;--watch&lt;/span&gt;	// 로컬 서버로 블로그 실행
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.hyeyoonjung.com/public/img/1/jekyll-blog.png&quot; alt=&quot;블로그&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같은 Jekyll 기본 테마를 갖춘 블로그를 확인할 수 있습니다. 다음 포스팅을 통해 Jekyll로 만든 블로그를 Github를 통해 퍼블리싱하는 방법을 소개해드릴게요.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.hyeyoonjung.com/2017-05-22-how-to-write-posts/&quot;&gt;Jekyll 블로그 github를 통해 퍼블리싱하는 방법&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 

</feed>
