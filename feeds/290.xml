<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2017-05-05T05:28:29+00:00</updated><id>/</id><title type="html">Seize the Day!</title><subtitle>오늘도 열심히!
</subtitle><entry><title type="html">Swift - 옵셔널 체이닝과 빠른 종료</title><link href="/jekyll/update/2017/05/05/swift3-Optional-Chaining.html" rel="alternate" type="text/html" title="Swift - 옵셔널 체이닝과 빠른 종료" /><published>2017-05-05T03:00:00+00:00</published><updated>2017-05-05T03:00:00+00:00</updated><id>/jekyll/update/2017/05/05/swift3-Optional-Chaining</id><content type="html" xml:base="/jekyll/update/2017/05/05/swift3-Optional-Chaining.html">&lt;h2 id=&quot;옵셔널-체이닝optional-chaining&quot;&gt;옵셔널 체이닝(Optional Chaining)&lt;/h2&gt;

&lt;p&gt;옵셔널 체인은 현재 nil일지도 모르는 옵셔널에 속해 있는 프로퍼티, 메서드, 서브스크립션 등을 가져오거나 호출할 때 사용할 수 있는 일련의 과정입니다.&lt;/p&gt;

&lt;p&gt;옵셔널이 값을 가지고 있다면 프로퍼티, 메서드, 서브스크립트 등을 호출할 수 있고, 옵셔널이 nil이라면 프로퍼티, 메서드, 서브스클비트 등은 nil을 반환합니다.&lt;/p&gt;

&lt;p&gt;옵셔널을 반복 사용하여 옵셔널이 자전거 체인처럼 서로 꼬리를 물고 있는 모양이기 때문에 옵셔널 체이닝이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;옵셔널 체이닝은 프로퍼티, 메서드 또는 서브스크립트를 호출하고 싶은 옵셔널 변수나 상수 뒤에 물음표(?)를 붙여서 표현합니다. 중첩된 옵셔널 중 하나라도 값이 존재하지 않는다면 결과적으로 nil을 반환합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Optional chaining in Swift is similar to messaging nil in Objective-C, but in a way that works for any type, and that can be checked for success or failure.

Swift에서의 옵셔널 체이닝은 Objective-C에서의 메시징 nil과 비슷하지만 모든 유형에 대해서 작동하고 성공 또는 실패 여부를 확인할 수 있는 방식으로 작동합니다.

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;옵셔널-체이닝과-강제-추출&quot;&gt;옵셔널 체이닝과 강제 추출&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;residence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Residence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Residence&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;numberOfRooms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Residence 인스턴스는 한개의 Int 타입의 프로퍼티인 numberOfRooms를 가지고 있습니다. 그리고 Person 인스턴스는 옵셔널 형식의 residence 프로퍼티인 Residence?를 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;residence 프로퍼티는 옵셔널 형태(Residence?)이기 때문에 Person 인스턴스를 생성하려 할 때, residence 프로퍼티는 nil로 생성 됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;john&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;느낌표(exclamation mark)를 통해서 강제 추출을 하여 john 인스턴스에서 residence 프로퍼티의 numberOfRooms에 접근해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;roomCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;john&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;residence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numberOfRooms&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// this triggers a runtime error&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;residence 프로퍼티가 nil이기 때문에 강제 추출은 진행되지 않고 runtime error를 발생하게 됩니다. 하지만, &lt;code class=&quot;highlighter-rouge&quot;&gt;옵셔널 체이닝&lt;/code&gt;을 이용한다면 numberOfRooms의 접근하는 일련의 과정을 성공과 실패로 구분 지을 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;roomCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;john&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;residence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numberOfRooms&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;John's residence has &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;roomCount&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; room(s).&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Unable to retrieve the number of rooms.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Prints &quot;Unable to retrieve the number of rooms.&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;빠른-종료early-exit&quot;&gt;빠른 종료(Early Exit)&lt;/h2&gt;

&lt;p&gt;빠른 종료의 핵심 키워드는 guard입니다. guard 구문은 if 구문과 유사하게 Bool 타입의 값으로 동작하는 기능입니다. guard 뒤에 따라붙는 코드의 실행 결과가 true일 때 코드가 계속 실행됩니다. if 구문과는 다르게 guard 구문은 항상 else 구문이 뒤에 따라와야 합니다.&lt;/p&gt;

&lt;p&gt;만약 guard 뒤에 따라오는 Bool 값이 false라면 else의 블록 내부 코드를 실행하게 되는데, 이때 else 구문의 블록 내부에는 꼭 자신보다 상위의 코드 블록을 종료하는 코드가 들어가게 됩니다. return, break, continue, throw 등의 제어문 전환 명령을 사용합니다. 또는 fatalError()와 같은 비반환 함수나 메서드를 호출할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;guard-구문-사용-형식&quot;&gt;guard 구문 사용 형식&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;값&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;예외사항&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;실행문&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;제어문&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;전환&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;명령어&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Swift에서는 guard 구문을 사용하여 if 코드를 훨씬 간결하고 읽기 좋게 구성할 수 있습니다. if 구문을 쓰면 예외사항을 else 블록으로 처리해야 하지만 예외사항만을 처리하고 싶다면 guard 구문을 쓰는 것이 훨씬 간편합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// if 구문을 사용한 코드&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// guard 구문을 사용한 코드&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;guard-구문으로-옵셔널-바인딩-사용&quot;&gt;guard 구문으로 옵셔널 바인딩 사용&lt;/h4&gt;

&lt;p&gt;Bool 타입의 값으로 guard 구문을 동작시킬 수 있지만 옵셔널 바인딩의 역할도 수행할 수 있습니다. guard 뒤에 따라오는 옵셔널 바인딩 표현에서 옵셔널의 값이 있는 상태라면 guard 구문에서 옵셔널 바인딩된 상수를 guard 구문이 실행된 아래 코드부터 함수 내부의 지역상수처럼 사용할 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;greet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;location&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I Hope the weather is nice near you&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I hope the weather is nice in &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;personInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;personInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Jenny&quot;&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;greet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;personInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Hello Jenny&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// I Hope the weather is nice near you&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;personInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;location&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Korea&quot;&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;greet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;personInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Hello Jenny&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// I Hope the weather is nice near in Korea&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;guard 구문을 통해 옵셔널 바인딩 된 상수는 greet(_ :) 함수 내에서 지역 상수로 사용된 것을 볼 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;guard 구문은 if let과 마찬가지로 쉼표(,)로 추가 조건을 나열하여 옵셔널 바인딩이 가능합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;추가된 조건은 Bool 타입의 값이어야 합니다.&lt;/code&gt; 또, 쉼표로 추가된 조건은 AND 논리연산과 같은 결과를 주기 때문에 쉼표를 &amp;amp;&amp;amp;로 치환해도 같은 결과를 얻을 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;글의 일부 내용은 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html&quot;&gt;Swift Language Guide&lt;/a&gt;와 야곰님의 저서 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html&quot;&gt;스위프트 프로그래밍&lt;/a&gt;(2017, 한빛미디어)를 참고하여 작성되었습니다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">옵셔널 체이닝(Optional Chaining)</summary></entry><entry><title type="html">Swift - 옵셔널</title><link href="/jekyll/update/2017/04/13/swift3-Optional.html" rel="alternate" type="text/html" title="Swift - 옵셔널" /><published>2017-04-13T15:10:00+00:00</published><updated>2017-04-13T15:10:00+00:00</updated><id>/jekyll/update/2017/04/13/swift3-Optional</id><content type="html" xml:base="/jekyll/update/2017/04/13/swift3-Optional.html">&lt;h2 id=&quot;옵셔널optional&quot;&gt;옵셔널(Optional)&lt;/h2&gt;

&lt;p&gt;Apple Developer에서 Swift의 특징 중 &lt;code class=&quot;highlighter-rouge&quot;&gt;안전을 고려한 설계(Designed for Safety)&lt;/code&gt;라고 설명한 것을 찾아볼 수 있습니다. 옵셔널로 표현된 변수/상수에 nil 혹은 적절한 값을 할당할 수 있습니다. (일반적인 변수/상수에는 nil을 할당할 수 없습니다.)&lt;/p&gt;

&lt;p&gt;변수/상수에 옵셔널을 표현해주면 ‘해당 변수/상수에는 값이 없을 수 있다.’, ‘변수/상수가 nil일 수도 있으므로 사용에 주의하라’는 뜻으로 보면 됩니다. iOS프로그래머가 Swift로 작성된 코드를 볼 때 옵셔널을 통해 어떠한 코드 블럭 부분에 포함된 프로퍼티, 메서드, 서브스크립트가 nil일 수 있는지 한눈에 알아볼 수가 있게 됩니다. 즉, 안전성뿐만 아니라 가독성 향상도 포함되는 것 같습니다.&lt;/p&gt;

&lt;p&gt;또한, 이러한 옵셔널 처리를 Swift에서는 옵셔널 체이닝과 빠른 종료 구문으로 처리할 수 있습니다. 옵셔널 체이닝과 빠른 종료 구문은 다음 포스트에서 다루겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;nil은 Objective-C에서의 NIL(레퍼런스 타입의 값이 없는 것)과 다릅니다. Swift에서는 레퍼런스 타입의 변수/상수 뿐만이 아니라 밸류 타입의 변/상수의 값이 없는 것을 의미합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;옵셔널-개요&quot;&gt;옵셔널 개요&lt;/h3&gt;

&lt;p&gt;Swift는 컴파일러는 Compile-time error가 있는 객체를 만들거나 사용하지 못하게 합니다. 즉, 코드를 깔끔하고 안전하게 작성할 수 있게 하여 런타임 충돌을 방지할 수 있습니다. 예를 들어, 옵셔널이 아닌 변수에 nil을 설정하려하면 컴파일러는 nil값을 할당할 수 없다고 컴파일 타임에 오류를 발생시킵니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Swift is awesome!&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// OK&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// complie-time error&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;옵셔널은 “?” 오퍼레이터를 타입 선언 뒤에 추가하여 message라는 변수를 옵셔널로 표현해보면&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Swift is awesome!&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// OK&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// OK&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;또한, 옵셔널은 제네릭이 적용된 열거형임을 확인할 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Wrapped&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ExpressibleByNilLiteral&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;none&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Wrapped&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Wrapped&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;옵셔널-강제-추출forced-unwrapping&quot;&gt;옵셔널 강제 추출(Forced Unwrapping)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;옵셔널 강제 추출은 옵셔널의 값을 추출하는 가장 간단한 방법이자 위험한 방법입니다.&lt;/li&gt;
  &lt;li&gt;옵셔널 강제 추출은 런타임의 오류를 내포하고 있기 때문에 지양해야합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;  &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;namsang&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;namsang&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;namsang&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 런타임 오류!&lt;/span&gt;

  &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;옵셔널-바인딩optional-binding&quot;&gt;옵셔널 바인딩(Optional Binding)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;옵셔널 바인딩은 ‘if let / if var’ 을 통해 nil인지 아닌지 확인하는 방식입니다.&lt;/li&gt;
  &lt;li&gt;쉼표(,)를 사용하여 여러 옵셔널의 값을 추출할 수 있습니다.
    &lt;ul&gt;
      &lt;li&gt;단, 바인딩하려는 옵셔널 중 하나라도 값이 없다면 블록 내부의 명령문은 실행되지 않습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;  &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;namsang&quot;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;unWrappedName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;My name is &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unWrappedName&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;myName == nil&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


  &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;글의 일부 내용은 야곰님의 저서 &lt;a href=&quot;http://book.naver.com/bookdb/book_detail.nhn?bid=11445773&quot;&gt;스위프트 프로그래밍&lt;/a&gt;(2017, 한빛미디어)를 참고하여 작성되었습니다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">옵셔널(Optional)</summary></entry><entry><title type="html">Swift - 클로저</title><link href="/jekyll/update/2017/04/07/swift3-Closures.html" rel="alternate" type="text/html" title="Swift - 클로저" /><published>2017-04-07T06:30:00+00:00</published><updated>2017-04-07T06:30:00+00:00</updated><id>/jekyll/update/2017/04/07/swift3-Closures</id><content type="html" xml:base="/jekyll/update/2017/04/07/swift3-Closures.html">&lt;h2 id=&quot;클로저closure&quot;&gt;클로저(Closure)&lt;/h2&gt;

&lt;p&gt;클로저는 코드에서 전달되고 사용할 수 있는 기능의 self-contained block 입니다. Swift의 클로저는 C 및 Objective-C 의 블록 또는 다른 프로그래밍 언어의 Lambda와 유사합니다. 일정 기능을 하는 코드를 하나의 블록으로 모아 놓은 것을 말합니다.&lt;/p&gt;

&lt;p&gt;클로저는 정의된 컨텍스트에서 모든 상수 및 변수에 대한 참조(Reference)를 획득(Capture)하고 저장할 수 있습니다. 이는 상수나 변수에 대해 closing이라고 합니다. Swift는 획득(Capture)를 위한 모든 메모리 관리를 스스로 합니다.&lt;/p&gt;

&lt;p&gt;Swift는 함수형 프로그래밍 패러다임과 프로토콜 지향 프로그래밍 패러다임을 강조합니다. 함수를 일급 객체로 다루는 스위프트 언어는 클로저를 사용하여 프로그램을 구현할 수 있습니다.&lt;/p&gt;

&lt;p&gt;클로저를 통해 비동기 콜백 형태로 코드를 작성할 수 있습니다. 이를 통해, 클로저는 비동기 작업에 많이 사용하게 됩니다. 즉, 클로저를 잘 숙지한다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;함수형 프로그래밍 패러다임의 가장 큰 장점인 대규모 병렬처리가&lt;/code&gt;  굉장히 쉬워진다는 점입니다.&lt;/p&gt;

&lt;h4 id=&quot;클로저의-세-가지-모양&quot;&gt;클로저의 세 가지 모양&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;이름을 가지면서 어떤 값도 획득하지 않는 전역함수의 형태&lt;/li&gt;
  &lt;li&gt;이름을 가지면서 다른 함수 내부의 값을 획득할 수 있는 중첩된 함수의 형태&lt;/li&gt;
  &lt;li&gt;이름이 없고 주변 문맥에 따라 값을 획득할 수 있는 축약 문법으로 작성된 형태&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;swift-클로저의-표현-방법들&quot;&gt;Swift 클로저의 표현 방법들&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Swift’s closure expressions have a clean, clear style, with optimizations that encourage brief, clutter-free syntax in common scenarios. These optimizations include&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;클로저는 매개변수와 반환 값의 타입을 문맥을 통해 유추할 수 있기 때문에 매개변수와 반환 값의 타입을 생략할 수 있습니다.
    &lt;ul&gt;
      &lt;li&gt;Inferring parameter and return value types from context.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클로저에 단 한 줄의 표현만 들어있다면 암시적으로 이를 반환 값으로 취급합니다.
    &lt;ul&gt;
      &lt;li&gt;Implicit returns from single-expression closures.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;축약된 전달인자 이름을 사용할 수 있습니다. ($ 표시)
    &lt;ul&gt;
      &lt;li&gt;Shorthand argument names.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;후행 클로저 문법을 사용할 수 있습니다. (CompletionHandler 등과 같은 관용 표현)
    &lt;ul&gt;
      &lt;li&gt;Trailing closure syntax&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;클로저의-기본-형태&quot;&gt;클로저의 기본 형태&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parameters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;statements&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;매개변수들&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환타입&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;실행코드&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;기본-클로저&quot;&gt;기본 클로저&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 기본 클로저&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;office&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;by&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;in -&amp;gt; 매개변수 및 반환 타입과 실행 코드를 구분하기 위해 사용하는 키워드&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;후행-클로저&quot;&gt;후행 클로저&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 후행 클로저&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;office&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;함수나 메서드의 마지막 전달인자로 위치하는 클로저는 함수나 메서드의 소괄호를 닫은 후 작성해도 됩니다. 단, 후행 클로저는 맨 마지막 전달인자로 전달되는 클로저에만 해당됩니다.&lt;/p&gt;

&lt;h3 id=&quot;후행-클로저-소괄호-생략&quot;&gt;후행 클로저 소괄호 생략&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 후행 클로저, 소괄호 생략&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;office&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sorted&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;단 하나의 클로저만 전달인자로 전달하는 경우에는 소괄호를 생략해줄 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;문맥을-통한-타입-유추&quot;&gt;문맥을 통한 타입 유추&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 후행 클로저, 소괄호 생략, 문맥을 통한 타입 유추&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;office&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sorted&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;타입 생략이 가능한 이유는 전달인자로 전달될 클로저가 이미 그 타입을 준수하고 있기 때문입니다.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;단축-인자-이름&quot;&gt;단축 인자 이름&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 후행 클로저, 소괄호 생략, 단축 인자 이름&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;office&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sorted&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 단축 인자 표현을 사용하게 되면&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 매개 변수 및 반환 타입과 실행 코드를 구분지을 in 키워드는 불필요합니다.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;암시적-반환-표현&quot;&gt;암시적 반환 표현&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 후행 클로저, 소괄호 생략, 암시적 반환 표현&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;office&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sorted&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;반환 값을 갖는 클로저이고 클로저 내부의 실행문이 단 한줄이라면, 암시적으로 그 실행문이 반환 값으로 사용됩니다.&lt;/p&gt;

&lt;h3 id=&quot;탈출-클로저&quot;&gt;탈출 클로저&lt;/h3&gt;
&lt;p&gt;탈출 클로저는 함수의 동작이 끝난 후 어떠한 작업의 필요성이 있을 때 사용합니다. @escaping 키워드를 사용하여 클로저가 탈출한다는 것을 명시해줄 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;firstClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Closure A&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;secondClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Closure B&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;// first와 second 매개변수 클로저는 함수의 반환 값으로 사용될 수 있으므로 탈출 클로저입니다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;returnOneClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;shouldReturnFirstClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 전달인자로 전달받은 클로저가 함수 외부로 다시 반환되기 때문에 함수를 탈출하는 클로저입니다.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shouldReturnFirstClosure&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 함수에서 반환된 클로저가 함수 외부의 상수에 저장되었습니다.(함수는 일급객체)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 클로저는 참조 타입입니다. 이 것은 해당 클로저의 참조를 할당하는 것입니다.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;returnedClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;returnOneClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;shouldReturnFirstClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;returnedClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Closure A&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;비탈출-클로저와-탈출-클로저&quot;&gt;비탈출 클로저와 탈출 클로저&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;functionWithNoEscapeClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;closure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;closure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;functionWithEscapingClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;completionHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;completionHandler&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;SomeClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;runNoEscapeClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;functionWithNoEscapeClosure&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 비탈출 클로저에서는 해당 타입의 프로퍼티, 메서드, 서브스크립트 등에 접근할 때 self 키워드를 꼭 써주지 않아도 됩니다.&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;runEscapingClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;functionWithEscapingClosure&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 탈출 클로저에서는 명시적으로 self 키워드를 사용하여 해당 타입의 프로퍼티, 메서드, 서브스크립트 등에 접근해야 합니다.&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;SomeClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;SomeClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;runNoEscapeClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;returnedClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;runEscapingClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;returnedClosure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;글의 일부 내용은 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html&quot;&gt;Swift Language Guide&lt;/a&gt;와 야곰님의 저서 &lt;a href=&quot;http://book.naver.com/bookdb/book_detail.nhn?bid=11445773&quot;&gt;스위프트 프로그래밍&lt;/a&gt;(2017, 한빛미디어)를 참고하여 작성되었습니다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">클로저(Closure)</summary></entry><entry><title type="html">Java - Vector, List</title><link href="/jekyll/update/2017/04/04/java-vector-list.html" rel="alternate" type="text/html" title="Java - Vector, List" /><published>2017-04-04T16:30:00+00:00</published><updated>2017-04-04T16:30:00+00:00</updated><id>/jekyll/update/2017/04/04/java-vector-list</id><content type="html" xml:base="/jekyll/update/2017/04/04/java-vector-list.html">&lt;p&gt;Java에서 Vector와 ArrayList(List) 콜렉션은 내부적으로 배열로 구현되어 있으며 인덱스를 이용해 데이터 액세스가 가능합니다. Vector와 List의 차이점은 동기화(Synchronize)의 처리입니다. Vector 클래스는 자동으로 동기화를 보장해주기 때문에 멀티 스레드 환경이 아니면 ArrayList를 사용하는게 좋습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Vector는 자동으로 동기화 보장, ArrayList는 자동으로 동기화를 보장하지 않음&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;vector&quot;&gt;Vector&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Vector Class는 확장 가능한 객체 배열을 구현&lt;/li&gt;
  &lt;li&gt;배열과 마찬가지로 정수 인덱스를 사용하여 액세스 할 수 있는 구성 요소 포함&lt;/li&gt;
  &lt;li&gt;Vector를 생성한 후에도 항목을 추가하거나 제거 할 수 있도록 필요에 따라 Vector의 크기 조절 가능&lt;/li&gt;
  &lt;li&gt;각 벡터는 capacity 와 capacityIncrement를 유지하여 스토리지 관리를 최적하하려고 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Vector는 자동으로 동기화를 보장(무조건 동기화)&lt;/code&gt;됩니다. 복수의 스레드로부터 추가/삭제가 이루어지더라도 내부의 데이터 처리는 안전하게 한번에 하나의 스레드만 처리되도록 보장함으로써 데이터 처리의 안정화의 이점이 있습니다.
    &lt;ul&gt;
      &lt;li&gt;단일 스레드 처리시에는 자동 동기화 보장이 오히려 성능의 저하를 일으킬 수 있기에, 단일 처리 상에는 ArrayList가 더 효율적인 성능을 보장.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;arraylistlist&quot;&gt;ArrayList(List)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ArrayList는 List 인터페이스의 Resizable-array의 구현&lt;/li&gt;
  &lt;li&gt;모든 선택적 목록 작업을 구현하고 null을 포함하여 모든 요소를 허용&lt;/li&gt;
  &lt;li&gt;ArrayList는 비동기성을 제외하면 Vector와 거의 같습니다. 즉, 자동으로 동기화를 보장하지 않습니다.
    &lt;ul&gt;
      &lt;li&gt;복수의 thread가 동시에 ArrayList 인스턴스에 액세스하는 경우에는 외부적으로 synchronized할 필요가 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;arraylist-와-list&quot;&gt;ArrayList 와 List?&lt;/h4&gt;
&lt;p&gt;List 는 배열에 기능을 추가한거고, ArrayList 는 List에 기능을 추가 한 것입니다. 이미 크기나 데이터가 정해져 있는 경우에, List배열을 쓰는게 속도 측면에서나 typeCasting의 번거로움이 없기에 좋습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;List는 type을 지정할 수 있어서 box, unbox이 일어나지 않아 ArrayList보다 빠릅니다. 아이템 타입이 object인 ArrayList는 Reference타입이 아닌 value타입을 사용 시에 box, unbox에서 문제가 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;참고&quot;&gt;참고&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html&quot;&gt;Java Vector Reference&lt;/a&gt; / &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html&quot;&gt;Java List Reference&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">Java에서 Vector와 ArrayList(List) 콜렉션은 내부적으로 배열로 구현되어 있으며 인덱스를 이용해 데이터 액세스가 가능합니다. Vector와 List의 차이점은 동기화(Synchronize)의 처리입니다. Vector 클래스는 자동으로 동기화를 보장해주기 때문에 멀티 스레드 환경이 아니면 ArrayList를 사용하는게 좋습니다.</summary></entry><entry><title type="html">C++ - Vector, List</title><link href="/jekyll/update/2017/04/04/cplusplus-vector-list.html" rel="alternate" type="text/html" title="C++ - Vector, List" /><published>2017-04-04T15:30:00+00:00</published><updated>2017-04-04T15:30:00+00:00</updated><id>/jekyll/update/2017/04/04/cplusplus-vector-list</id><content type="html" xml:base="/jekyll/update/2017/04/04/cplusplus-vector-list.html">&lt;h3 id=&quot;vector-가변-배열&quot;&gt;vector (가변 배열)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;벡터는 크기가 변할 수 있는 배열을 나타내는 시퀀스 컨테이너&lt;/li&gt;
  &lt;li&gt;연속적인 메모리(메모리를 연속적으로 할당)&lt;/li&gt;
  &lt;li&gt;배열과 마찬가지로 벡터도 요소에 연속된 저장위치를 사용
    &lt;ul&gt;
      &lt;li&gt;요소에 대한 일반 포인터의 오프셋을 사용하여 배열에서와 마찬가지로 요소에 액세스 가능&lt;/li&gt;
      &lt;li&gt;배열과 달리 컨테이너의 크기는 동적으로 변경 될 수 있으며, 컨테이너가 컨테이너를 자동으로 처리합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내부적으로 벡터는 동적으로 할당 된 배열을 사용하여 요소를 저장합니다.
    &lt;ul&gt;
      &lt;li&gt;이 배열은 새로운 요소가 삽입 될 때 크기가 커지기 위해 재할당되어야 할 수도 있습니다.&lt;/li&gt;
      &lt;li&gt;새로운 배열을 할당하고 모든 요소를 이동한다는 의미입니다. 그러나 상대적으로 많은 비용이 드는 작업이므로 요소가 컨테이너에 추가 될 때마다 벡터가 재할당되지는 않습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;어레이에 비해 벡터는 스토리지를 관리하고 효율적, 동적으로 확장할 수 있으나 더 많은 메모리를 사용&lt;/li&gt;
  &lt;li&gt;dynamic sequence containers(deques, lists and forward_lists)와 비교할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;벡터는 배열과 마찬가지로 요소에 액세스하는 것이 효율적&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;b&gt;끝에서 요소를 추가하거나 제거하는 것이 효율적(상수 시간)&lt;/b&gt;&lt;/li&gt;
      &lt;li&gt;&lt;b&gt;끝 이외의 위치에 요소를 삽입하거나 제거하는 작업의 경우에는 상수 시간이 아니다.(선형 시간)&lt;/b&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;list-리스트&quot;&gt;list (리스트)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;list는 시퀀스 내의 임의의 위치에서 일정 시간의 삽입 및 삭제 작업을 허용하고 양방향에서 반복을 허용하는 시퀀스 컨테이너&lt;/li&gt;
  &lt;li&gt;비연속적인 메모리(메모리를 따로따로 할당)&lt;/li&gt;
  &lt;li&gt;list는 내부적으로 이중 연결 목록(doubly_linked lists)으로 구현되어 있습니다.
    &lt;ul&gt;
      &lt;li&gt;single-linked lists으로 구현되어 있는 forward_list와 흡사&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다른 기본 표준 시퀀스 (array, vector and deque)와 비교할 때, &lt;code class=&quot;highlighter-rouge&quot;&gt;list는 삽입 추출 및 이동하는 데 일반적으로 더 효과적&lt;/code&gt;이다.&lt;/li&gt;
  &lt;li&gt;다른 시퀀스 컨테이너와 비교할 때, list 및 forward_lists의 주요 단점은 요소에 직접 액세스 할 수 없다는 점입니다.
    &lt;ul&gt;
      &lt;li&gt;예를 들어, 목록의 여섯 번째 요소에 액세스하려면 시작 위치 또는 끝 위치와 같은 알려진 위치에서 해당 위치까지 반복해야 합니다.(선형 시간)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    중간에 데이터 삽입, 삭제의 빈도가 적고 랜덤 접근을 자주 해야 한다면 vector
    중간에 데이터 삽입, 삭제가 빈번하며 랜덤 접근이 필요 없으면 list
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/vector/vector/&quot;&gt;C++ vector Reference&lt;/a&gt; / &lt;a href=&quot;http://www.cplusplus.com/reference/list/list/&quot;&gt;C++ list Reference&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">vector (가변 배열) 벡터는 크기가 변할 수 있는 배열을 나타내는 시퀀스 컨테이너 연속적인 메모리(메모리를 연속적으로 할당) 배열과 마찬가지로 벡터도 요소에 연속된 저장위치를 사용 요소에 대한 일반 포인터의 오프셋을 사용하여 배열에서와 마찬가지로 요소에 액세스 가능 배열과 달리 컨테이너의 크기는 동적으로 변경 될 수 있으며, 컨테이너가 컨테이너를 자동으로 처리합니다. 내부적으로 벡터는 동적으로 할당 된 배열을 사용하여 요소를 저장합니다. 이 배열은 새로운 요소가 삽입 될 때 크기가 커지기 위해 재할당되어야 할 수도 있습니다. 새로운 배열을 할당하고 모든 요소를 이동한다는 의미입니다. 그러나 상대적으로 많은 비용이 드는 작업이므로 요소가 컨테이너에 추가 될 때마다 벡터가 재할당되지는 않습니다. 어레이에 비해 벡터는 스토리지를 관리하고 효율적, 동적으로 확장할 수 있으나 더 많은 메모리를 사용 dynamic sequence containers(deques, lists and forward_lists)와 비교할 때 벡터는 배열과 마찬가지로 요소에 액세스하는 것이 효율적 끝에서 요소를 추가하거나 제거하는 것이 효율적(상수 시간) 끝 이외의 위치에 요소를 삽입하거나 제거하는 작업의 경우에는 상수 시간이 아니다.(선형 시간)</summary></entry><entry><title type="html">Swift - 접근제어</title><link href="/jekyll/update/2017/03/27/swift3-Access-Control.html" rel="alternate" type="text/html" title="Swift - 접근제어" /><published>2017-03-27T07:30:00+00:00</published><updated>2017-03-27T07:30:00+00:00</updated><id>/jekyll/update/2017/03/27/swift3-Access-Control</id><content type="html" xml:base="/jekyll/update/2017/03/27/swift3-Access-Control.html">&lt;h2 id=&quot;접근제어란&quot;&gt;접근제어란&lt;/h2&gt;

&lt;p&gt;코드끼리 상호작용을 할 때 파일 간 또는 모듈() 간에 접근을 제한할 수 있는 기능입니다. 접근제어를 통해 코드의 상세 구현은 숨기고 허용된 기능만 사용하는 인터페이스를 제공할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;접근제어의 필요성
    &lt;ul&gt;
      &lt;li&gt;객체 지향 프로그래밍(OOP, Obejct-oriented programming)에서 캡슐화와 은닉화는 중요한 개념이고 &lt;b&gt;잘 설계된 클래스를 만드는데 사용되는 기법&lt;/b&gt;입니다.&lt;/li&gt;
      &lt;li&gt;접근제어를 통해 코드의 상세 구현은 숨기고 허용된 기능만 사용할 수 있습니다.&lt;/li&gt;
      &lt;li&gt;전체 코드를 노출하지 않고 꼭 필요한 부분만 제공하는 것을 통해 프로그래머에게 의도한 대로 코드 작성을 유도할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;접근-수준&quot;&gt;접근 수준&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;스위프트에서는 접근 수준 키워드를 통해 접근제어를 구현할 수 있습니다. 타입(클래스, 구조체, 열거형 등)에 특정 접근수준을 지정할 수 있고, 타입 내부의 프로퍼티, 메소드, 이니셜라이저, 서브스크립트 각각에도 접근수준을 지정할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;접근수준&lt;/th&gt;
      &lt;th&gt;키워드&lt;/th&gt;
      &lt;th&gt;접근도&lt;/th&gt;
      &lt;th&gt;범위&lt;/th&gt;
      &lt;th&gt;비고&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;개방접근수준&lt;/td&gt;
      &lt;td&gt;open&lt;/td&gt;
      &lt;td&gt;높음&lt;/td&gt;
      &lt;td&gt;모듈 외부까지&lt;/td&gt;
      &lt;td&gt;클래스에서만 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;공개 접근수준&lt;/td&gt;
      &lt;td&gt;public&lt;/td&gt;
      &lt;td&gt;↑&lt;/td&gt;
      &lt;td&gt;모듈 내부&lt;/td&gt;
      &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;내부 접근수준&lt;/td&gt;
      &lt;td&gt;internal&lt;/td&gt;
      &lt;td&gt;&lt;/td&gt;
      &lt;td&gt;모듈 내부&lt;/td&gt;
      &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;파일외부비공개 접근수준&lt;/td&gt;
      &lt;td&gt;fileprivate&lt;/td&gt;
      &lt;td&gt;↓&lt;/td&gt;
      &lt;td&gt;파일 내부&lt;/td&gt;
      &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;비공개 접근수준&lt;/td&gt;
      &lt;td&gt;private&lt;/td&gt;
      &lt;td&gt;낮음&lt;/td&gt;
      &lt;td&gt;기능 정의 내부&lt;/td&gt;
      &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;공개-접근수준&quot;&gt;공개 접근수준&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;public 키워드 사용&lt;/li&gt;
  &lt;li&gt;소스파일, 소스파일이 속해 있는 모듈 등 어디에서든 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;프레임워크에서 외부와 연결된 인터페이스를 구현하는데 많이 쓰입니다.&lt;/li&gt;
  &lt;li&gt;스위프트의 기본 요소는 모두 공개 접근수준으로 구현되어 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;개방-접근수준&quot;&gt;개방 접근수준&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;open 키워드 사용&lt;/li&gt;
  &lt;li&gt;클래스와 클래스의 멤버에서만 사용할 수 있습니다.
    &lt;ul&gt;
      &lt;li&gt;개방 접근수준을 제외한 다른 모든 접근수준의 클래스는 그 클래스가 정의된 모듈 안에서만 상속될 수 있습니다.&lt;/li&gt;
      &lt;li&gt;개방 접근수준을 제외한 다른 모든 접근수준의 클래스 멤버는 그 멤버가 정의된 모듈 안에서만 재정의될 수 있습니다.&lt;/li&gt;
      &lt;li&gt;개방 접근수준의 클래스는 그 클래스가 정의된 모듈 밖의 다른 모듈에서도 상속될 수 있습니다.&lt;/li&gt;
      &lt;li&gt;개방 접근수준의 클래스 멤버는 그 멤버가 정의된 모듈 밖의 다른 모듈에서도 재정의될 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;내부-접근수준&quot;&gt;내부 접근수준&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;internal 키워드 사용&lt;/li&gt;
  &lt;li&gt;기본적으로 모든 요소에 암묵적으로 저장되는 기본 접근수준입니다.&lt;/li&gt;
  &lt;li&gt;보통 외부에서 사용될 클래스나 구조체가 아니며, 모듈 내부에서 광역적으로 사용될 경우 내부 접근수준을 지정하게 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;내부 접근수준으로 접근수준이 지정된 요소는 구현된 소스파일이 속해 있는 모듈 어디에서든 쓰일 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;파일외부비공개-접근수준&quot;&gt;파일외부비공개 접근수준&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;fileprivate 키워드 사용&lt;/li&gt;
  &lt;li&gt;파일외부비공개 접근수준으로 접근수준이 지정된 요소는 그 요소가 구현된 소스파일 내부에서만 사용할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;해당 소스파일 외부에서 값이 변경되거나 함수가 호출되면 부작용이 생길 수 있는 경우에 사용하면 좋습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;비공개-접근수준-private&quot;&gt;비공개 접근수준, private&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;private 키워드 사용&lt;/li&gt;
  &lt;li&gt;비공개 접근수준으로 접근수준이 지정된 요소는 그 기능이 정의되고 구현된 범위 내에서만 사용될 수 있습니다.&lt;/li&gt;
  &lt;li&gt;비공개 접근수준으로 지정된 기능은 심지어 같은 소스파일 안에 구현된 다른 타입이나 기능에서도 사용할 수 없습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;접근제어-구현-참고사항&quot;&gt;접근제어 구현 참고사항&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;모든 타입에 적용되는 접근수준의 규칙은 &lt;code class=&quot;highlighter-rouge&quot;&gt;'상위 요소보다 하위 요소가 더 높은 접근수준을 가질 수 없다.'&lt;/code&gt;입니다.
    &lt;ul&gt;
      &lt;li&gt;비공개 접근수준으로 정의된 구조체 내부의 프로퍼티로 내부수준이나 공개수준을 가지는 프로퍼티가 정의될 수 없습니다.&lt;/li&gt;
      &lt;li&gt;함수의 매개변수로 특정 접근수준이 부여된 타입이 전달되거나 반환된다면, 그 타입의 접근수준보다 함수의 접근수준이 높게 설정될 수 없습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;글의 일부 내용은 야곰님의 저서 &lt;a href=&quot;http://book.naver.com/bookdb/book_detail.nhn?bid=11445773&quot;&gt;스위프트 프로그래밍&lt;/a&gt;(2017, 한빛미디어)를 참고하여 작성되었습니다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">접근제어란</summary></entry><entry><title type="html">Swift - 인스턴스 생성 및 소멸</title><link href="/jekyll/update/2017/03/20/swift3-Initializer.html" rel="alternate" type="text/html" title="Swift - 인스턴스 생성 및 소멸" /><published>2017-03-20T10:30:00+00:00</published><updated>2017-03-20T10:30:00+00:00</updated><id>/jekyll/update/2017/03/20/swift3-Initializer</id><content type="html" xml:base="/jekyll/update/2017/03/20/swift3-Initializer.html">&lt;h2 id=&quot;인스턴스-생성&quot;&gt;인스턴스 생성&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;저장 프로퍼티의 초깃값을 설정하는 일을 수행.&lt;/li&gt;
  &lt;li&gt;이니셜라이저를 정의하면 초기화 과정을 직접 구현 가능.
    &lt;blockquote&gt;
      &lt;p&gt;이니셜라이저는 새로운 인스턴스를 생성할 수 있는 특별한 메서드, 인스턴스의 첫 사용을 위해 초기화하는 용도이며 반환 값은 없습니다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Student {
    init() {
        // 초기화 코드
    }
}

struct Lecture {
    init() {
        // 초기화 코드
    }
}

enum Major {
    case computerScience

    init() {
        // &amp;lt;b&amp;gt;열거형은 반드시 케이스 중 하나로 초기화 되어야 합니다.&amp;lt;/b&amp;gt;
        self = .computerScience
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;프로퍼티-기본값&quot;&gt;프로퍼티 기본값&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;구조체와 클래스의 인스턴스는 처음 생성될 때 옵셔널 저장 프로퍼티를 제외한 모든 저장 프로퍼티에 적절한 초깃값이 할당되어야 합니다.&lt;/li&gt;
  &lt;li&gt;초기화 후에 값이 확정되지 않은 저장 프로퍼티는 존재할 수 없습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;이니셜라이저로-저장-프로퍼티에-초깃값-설정&quot;&gt;이니셜라이저로 저장 프로퍼티에 초깃값 설정&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct Volume {
    var size: Double

    init() {
        size =  0.0 // size의 초깃값 할당
    }
}

let volume: Volume = Volume()
print(volume.size) // 0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;저장-프로퍼티에-초깃값을-설정&quot;&gt;저장 프로퍼티에 초깃값을 설정&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct Volume {
    var size: Double = 0.0
}

let volume: Volume = Volume()
print(volume.size) // 0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;이니셜라이저도 매개변수를 가질 수 있습니다. 인스턴스를 초기화하는 과정에서 필요한 값(argument, 인수)을 전달하여 초기화할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;옵셔널-프로퍼티-타입&quot;&gt;옵셔널 프로퍼티 타입&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;인스턴스가 사용되는 동안에 값을 꼭 가지지 않아도 되는 저장 프로퍼티가 있을 경우 사용.&lt;/li&gt;
  &lt;li&gt;초기화되는 과정에서 값을 지정해주기 어려운 경우, 저장 프로퍼티를 옵셔널로 선언합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Person {
    let name: String // 상수 프로퍼티
    var age: Int?

    init(name: String) {
        // &amp;lt;b&amp;gt;상수 프로퍼티는 초기화 과정에서만 값이 할당 될 수 있습니다.&amp;lt;/b&amp;gt;
        self.name = name

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;기본-이니셜라이즈-멤버와이즈-이니셜라이저&quot;&gt;기본 이니셜라이즈, 멤버와이즈 이니셜라이저&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;기본 이니셜라이저는 프로퍼티의 기본값으로 프로퍼티를 초기화해서 인스턴스를 생성.
    &lt;ul&gt;
      &lt;li&gt;저장 프로퍼티의 기본값이 모두 지정되어 있고, 동시에 사용자 정의 이니셜라이저가 정의되지 않아야합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구조체는 사용자정의 이니셜라이저르 구현하지 않으면 프로퍼티의 이름으로 매개변수를 가지는 이니셜라이저인 &lt;b&gt;멤버와이즈 이니셜라이저&lt;/b&gt;를 기본으로 제공.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;초기화-위임&quot;&gt;초기화 위임&lt;/h3&gt;
&lt;p&gt;값 타입인 구조체와 열거형은 코드의 중복을 피하기 위하여 이니셜라이저가 다른 이니셜라이저에게 일부 초기화를 위임하는 초기화 위임을 간단하게 구현할 수 있습니다.
(초기화 위임은 최소 두 개 이상의 사용자 정의 이니셜라이저가 필요합니다.)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enum Student {
    case elemantary, middle, high
    case none

    init() {
        self = .none
    }

    init(KoreanAge: Int) {
        switch KoreanAge {
            case 8...13:
                self = .elemantary
            case 14...16:
                self = .middle
            case 17...19:
                self = .high
            default:
                self = .none
        }
    }

    init(bornAt: Int, currentYear: Int) {
        // self.init으로 사용자 정의 이니셜라이저로 초기화를 위임.
        self.init(KoreanAge: currentYear - bornAt + 1)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;실패-가능한-이니셜라이저failable-initializer&quot;&gt;실패 가능한 이니셜라이저(Failable initializer)&lt;/h3&gt;
&lt;p&gt;클래스, 구조체, 열거형에 모두 정의할 수 있으며 실패했을 때 nil을 반환합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;init 키워드 대신 init? 키워드를 사용합니다.&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;실패 가능한 이니셜라이저가 특정 값을 반환하지는 않습니다. return nil(실패), return(성공)으로 성공과 실패를 표현할 뿐입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enum Student {
    case elemantary, middle, high

    init?(KoreanAge: Int) {
        switch KoreanAge {
            case 8...13:
                self = .elemantary
            case 14...16:
                self = .middle
            case 17...19:
                self = .high
            default:
                // 초기화 실패를 표현
                return nil
        }
    }

    init?(bornAt: Int, currentYear: Int) {
        self.init(KoreanAge: currentYear - bornAt + 1)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;함수를-사용한-프로퍼티-기본값-할당&quot;&gt;함수를 사용한 프로퍼티 기본값 할당&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사용자정의 연산을 통해 저장 프로퍼티 기본값을 설정할 때 클로저나 함수를 사용.
    &lt;blockquote&gt;
      &lt;p&gt;클로저를 사용하여 프로퍼티 기본값을 설정할 때, 실행 시점은 이니셜라이즈(초기화)입니다. 따라서 다른 프로퍼티의 값이 세팅되기 전이기에 다른 프로퍼티를 사용하여 연산할 수 없습니다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct Student {
    var name: String?
    var number: Int?
}

class SchoolClass {
    var student: [Student] = {
          // 새로운 인스턴스를 생성하고 사용자정의 연산을 통한 후 반환해줍니다.
          // 반환되는 값의 타입은 [Student] 타입이어야 합니다.

          var arr: [Student] = [Student]()

          for num in 1...15 {
              var student: Student = Student(nam: nil, number: num)
              arr.append(student)
          }

          return arr
      }()
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;인스턴스-소멸&quot;&gt;인스턴스 소멸&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;클래스의 인스턴스는 디이니셜라이저(Deinitializer)를 구현할 수 있습니다. 디이니셜라이저는 인스턴스가 메모리에서 해제되기 직전 클래스 인스턴스와 관련하여 원하는 정리 작업을 구현할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;deinit 키워드를 사용하며, 클래스의 인스턴스가 메모리에서 소멸되기 바로 직전에 호출됩니다.&lt;/li&gt;
  &lt;li&gt;스위프트는 인스턴스가 더이상 필요하지 않으면 자동으로 메모리에서 소멸시킵니다.(ARC)&lt;/li&gt;
  &lt;li&gt;인스턴스 내부에서 외부 리소스를 사용했다면, 인스턴스가 소멸하기 직전에 파일을 다시 저장하고 닫아주는 등의 부가 작업이 필요한 경우에 유용하게 사용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;글의 일부 내용은 야곰님의 저서 &lt;a href=&quot;http://book.naver.com/bookdb/book_detail.nhn?bid=11445773&quot;&gt;스위프트 프로그래밍&lt;/a&gt;(2017, 한빛미디어)를 참고하여 작성되었습니다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">인스턴스 생성 저장 프로퍼티의 초깃값을 설정하는 일을 수행. 이니셜라이저를 정의하면 초기화 과정을 직접 구현 가능. 이니셜라이저는 새로운 인스턴스를 생성할 수 있는 특별한 메서드, 인스턴스의 첫 사용을 위해 초기화하는 용도이며 반환 값은 없습니다.</summary></entry><entry><title type="html">Swift - 메소드</title><link href="/jekyll/update/2017/03/19/swift3-method.html" rel="alternate" type="text/html" title="Swift - 메소드" /><published>2017-03-19T16:48:00+00:00</published><updated>2017-03-19T16:48:00+00:00</updated><id>/jekyll/update/2017/03/19/swift3-method</id><content type="html" xml:base="/jekyll/update/2017/03/19/swift3-method.html">&lt;h2 id=&quot;메서드&quot;&gt;메서드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;메서드는 특정 타입에 관련된 함수&lt;/li&gt;
  &lt;li&gt;타입(클래스, 구조체, 열거형)의 인스턴스가 특정 작업을 수행하기 위한 캡슐화된 인스턴스 메서드 구현 가능.&lt;/li&gt;
  &lt;li&gt;타입 자체와 관련된 기능을 수행하기 위해 타입 메서드 정의 가능.&lt;/li&gt;
  &lt;li&gt;구조체와 열거형이 메서드를 가질 수 있다는 것은 기존 프로그래밍 언어와 스위프트의 큰 차이점 중 하나입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;인스턴스-메서드&quot;&gt;인스턴스 메서드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;인스턴스 메서드는 특정 타입의 인스턴스에 속한 함수를 뜻합니다. 인스턴스 내부의 프로퍼티의 값을 변경하거나 특정 연산 결과를 반환하는 등 인스턴스와 관련된 기능을 수행합니다.&lt;/li&gt;
  &lt;li&gt;특정 타입 내부에 구현, 인스턴스가 존재할 때만 사용 가능함.&lt;/li&gt;
  &lt;li&gt;인스턴스 메서드에서 self가 인스턴스를 가리킴.
    &lt;blockquote&gt;
      &lt;p&gt;타입의 저장 프로퍼티의 값을 수정하는 인스턴스 메서드의 경우, 클래스가 아닌 &lt;b&gt;구조체 및 열거형은 값 타입&lt;/b&gt;이므로 메서드 앞에 &lt;b&gt;mutating 키워드&lt;/b&gt;를 붙여야합니다.(해당 인스턴스 메서드가 인스턴스 내부의 값을 변경한다는 것을 명시하는 것.)&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;self-프로퍼티&quot;&gt;self 프로퍼티&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;모든 인스턴스는 암시적으로 생성된 self 프로퍼티를 포함.&lt;/li&gt;
  &lt;li&gt;self 프로퍼티는 인스턴스를 더 명확히 지칭하고 싶을 때 사용.&lt;/li&gt;
  &lt;li&gt;클래스의 인스턴스는 참조타입이라서 self 프로퍼티에 다른 참조를 할당 불가.&lt;/li&gt;
  &lt;li&gt;구조체, 열거형은 self 프로퍼티를 사용하여 자신 자체를 치환 가능.
    &lt;blockquote&gt;
      &lt;p&gt;Swift는 자동으로 메서드 내부에 선언된 &lt;code class=&quot;highlighter-rouge&quot;&gt;지역변수를 먼저 사용하고, 그다음 메서드 매개변수, 그다음 인스턴스의 프로퍼티&lt;/code&gt;를 찾습니다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;타입-메서드&quot;&gt;타입 메서드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;타입 자체에 호출이 가능한 메서드를 타입 메서드라 지칭.&lt;/li&gt;
  &lt;li&gt;static 키워드와 class 키워드를 사용하여 정의
    &lt;ul&gt;
      &lt;li&gt;static 키워드로 정의하면 상속 후 메서드 재정의 불가&lt;/li&gt;
      &lt;li&gt;class 키워드로 정의하면 상속 후 메서드 재정의 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;타입 메서드에서 self는 타입을 가리킴.
    &lt;ul&gt;
      &lt;li&gt;타입 메서드 내부에서 타입 이름과 self는 같은 뜻.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;글의 일부 내용은 야곰님의 저서 &lt;a href=&quot;http://book.naver.com/bookdb/book_detail.nhn?bid=11445773&quot;&gt;스위프트 프로그래밍&lt;/a&gt;(2017, 한빛미디어)를 참고하여 작성되었습니다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">메서드 메서드는 특정 타입에 관련된 함수 타입(클래스, 구조체, 열거형)의 인스턴스가 특정 작업을 수행하기 위한 캡슐화된 인스턴스 메서드 구현 가능. 타입 자체와 관련된 기능을 수행하기 위해 타입 메서드 정의 가능. 구조체와 열거형이 메서드를 가질 수 있다는 것은 기존 프로그래밍 언어와 스위프트의 큰 차이점 중 하나입니다.</summary></entry><entry><title type="html">Swift - 프로퍼티의 종류</title><link href="/jekyll/update/2017/03/16/swift3-propery.html" rel="alternate" type="text/html" title="Swift - 프로퍼티의 종류" /><published>2017-03-16T14:53:00+00:00</published><updated>2017-03-16T14:53:00+00:00</updated><id>/jekyll/update/2017/03/16/swift3-propery</id><content type="html" xml:base="/jekyll/update/2017/03/16/swift3-propery.html">&lt;h3 id=&quot;프로퍼티&quot;&gt;프로퍼티&lt;/h3&gt;
&lt;p&gt;프로퍼티는 클래스, 구조체 또는 열거형 등에 관련된 값을 뜻합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;저장 프로퍼티(Stored Properties)
    &lt;ul&gt;
      &lt;li&gt;인스턴스 변수 또는 상수를 의미합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;연산 프로퍼티(Computed Properties)
    &lt;ul&gt;
      &lt;li&gt;값을 저장한 것이 아니라 특정 연산을 수행한 결과값을 의미합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;타입 프로퍼티(Type Properties)
    &lt;ul&gt;
      &lt;li&gt;특정 타입에 사용되는 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;저장-프로퍼티&quot;&gt;저장 프로퍼티&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct CoordinatePoint {
  var x: Int  //저장 프로퍼티
  var y: Int  //저장 프로퍼티
}

// 구조체는 기본적으로 저장 프로퍼티를 매개변수로 가지는 이니셜라이저가 있습니다.
// 저장 프로퍼티가 옵셔널이 아니더라도, 구조체는 저장 프로퍼티를 모두 포함하는 이니셜라이저를 자동으로 생성합니다.
let namsangPoint: CoordinatePoint = CoordinatePoint(x: 10, y: 5)

class Position {
  var point: CoordinatePoint // 저장 프로퍼티(변수) - 위치(Point)는 변경될 수 있음을 뜻합니다.
  let name: String // 저장 프로퍼티(상수)

  // 클래스의 저장 프로퍼티는 옵셔널이 아니라면 프로퍼티 기본값을 지정해주거나 사용자 정의 이니셜라이저를 통해 반드시 초기화해주어야 합니다.
  init(name: String, currentPoint: CoordinatePoint) {
    self.name = name
    self.point = currentPoint
  }
}

// 사용자정의 이니셜라이저를 호출해야만 합니다.
// 그렇지 않으면 프로퍼티 초기값을 할당할 수 없기 때문에 인스턴스 생성이 불가능합니다.
let namsangPosition: Position = Position(name: &quot;namsang&quot;, currentPoint: namsangPoint)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;클래스의 저장 프로퍼티에 초깃값을 지정해주면 따로 사용자 정의 이니셜라이저를 구현해줄 필요가 없습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct CoordinatePoint {
  var x: Int = 0 // 저장 프로퍼티
  var y: Int = 0 // 저장 프로퍼티
}

// 프로퍼티의 초깃값을 할당했다면 굳이 전달인자로 초깃값을 넘길 필요가 없습니다.
let namsangPoint: CoordinatePoint = CoordinatePoint()

class Position {
  var point: CoordinatePoint = CoordinatePoint() // 저장 프로퍼티
  var name: String = &quot;Unknown&quot; // 저장 프로퍼티
}

// 초깃값을 지정해줬다면 사용자정의 이니셜라이저를 사용하지 않아도 됩니다.
let namsangPosition: Position = Position()

// 인스턴스를 생성한 후에 값을 할당해줄 수 있습니다.
namsangPosition.point = namsangPoint
namsangPosition.name = &quot;namsang&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;옵셔널-저장-프로퍼티&quot;&gt;옵셔널 저장 프로퍼티&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct CoordinatePoint {
  // 위치는 x, y 값을 모두 가져야하므로 옵셔널이면 안됩니다.
  var x: Int
  var y: Int
}

class Position {
  // 현재 사람의 위치를 모를 수도 있습니다. - 옵셔널
  var position: CoordinatePoint?
  let name: String

  init(name: String) {
    self.name = name
  }
}

// 이름은 필수지만 위치는 모를 수 있습니다.
let namsangPosition: Position = Position(name: &quot;namsang&quot;)

// 위치를 알게되면 그 때 위치 값을 할당해줍니다.
namsangPosition.point = CoordinatePoint(x: 20, y: 10)


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;지연-저장-프로퍼티&quot;&gt;지연 저장 프로퍼티&lt;/h3&gt;

&lt;p&gt;인스턴스가 생성될 때 프로퍼티에 값이 필요 없을 경우에 옵셔널 저장 프로퍼티로 정의합니다. 그러나 호출이 있어야 값을 초기화하는 지연 저장 프로퍼티(Lazy Stored Properties)가 있습니다. 지연 저장 프로퍼티는 var 키워드로 정의된 변수에 lazy 키워드를 사용하여 정의합니다.&lt;/p&gt;

&lt;p&gt;지연 저장 프로퍼티는 &lt;code class=&quot;highlighter-rouge&quot;&gt;주로 복잡한 크래스나 구조체를 구현할 때&lt;/code&gt; 많이 사용되며 불필요한 성능저하나 공간 낭비를 줄일 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct CoordinatePoint {
  var x: Int = 0
  var y: Int = 0
}

class Position {
  lazy var point: CoordinatePoint = CoordinatePoint()
  let name: String

  init(name: String) {
    self.name = name
  }
}

let namsangPosition: Position = Position(name: &quot;namsang&quot;)

// Position 클래스의 point 지연 저장 프로퍼티를 호출(접근)했을 때 프로퍼티의 CoordinatePoint가 생성됩니다.
print(namsangPosition.point)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;연산-프로퍼티&quot;&gt;연산 프로퍼티&lt;/h3&gt;
&lt;p&gt;연산 프로퍼티는 특정 상태에 따른 값을 연산하는 프로퍼티입니다. 접근자, 설정자의 역할을 수행할 수 있으며 클래스, 구조체, 열거형에 정의할 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;메서드로 접근자, 설정자를 구현헀을 때보다 연산 프로퍼티로 구현했을 때 훨씬 더 간편하고 직관적입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;메서드로-구현된-접근자와-설정자&quot;&gt;메서드로 구현된 접근자와 설정자&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; struct CoordinatePoint {
   var x: Int // 저장 프로퍼티
   var y: Int // 저장 프로퍼티

   // 대칭점을 구하는 메서드 - 접근자
   func oppositePoint() -&amp;gt; CoordinatePoint {
     return CoordinatePoint(x: -x, y: -y)
   }

   // 대칭점을 설정하는 메서드 - 설정자
   mutating func setOppositePoint(_ opposite: CoordinatePoint) {
     x = -opposite.x
     y = -opposite.y
   }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;연산-프로퍼티의-정의&quot;&gt;연산 프로퍼티의 정의&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; struct CoordinatePoint {
   var x: Int // 저장 프로퍼티
   var y: Int // 저장 프로퍼티

   // 연산 프로퍼티
   var oppositePoint: CoordinatePoint {
     // 접근자
     get {
       return CoordinatePoint(x: -x, y: -y)
     }

     // 설정자
     set(opposite) {
       x = -opposite.x
       y = -opposite.y
     }
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;프로퍼티-감시자&quot;&gt;프로퍼티 감시자&lt;/h3&gt;

&lt;p&gt;프로퍼티 감시자(Property Observers)를 사용하면 프로퍼티의 값이 변경됨에 따라 적절한 액션을 취할 수 있습니다. 프로퍼티 감시자는 프로퍼티의 값이 새로 할당될 때마다 호출되는데 변경되는 값이 현재의 값과 같더라도 호출됩니다.&lt;/p&gt;

&lt;p&gt;프로퍼티 감시자는 일반 저장 프로퍼티에만 적용할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;willSet : 프로퍼티의 값이 변경되기 직전에 호출&lt;/li&gt;
  &lt;li&gt;didSet : 프로퍼티의 값이 변경된 직후에 호출&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;willSet 메서드에 전달되는 전달인자는 변경될 값(newValue), didSet 메서드에 전달되는 전달인자는 변경되기 전의 값(oldValue)이 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;타입-프로퍼티&quot;&gt;타입 프로퍼티&lt;/h3&gt;
&lt;p&gt;각각의 인스턴스가 아닌 타입 자체에 속하게 되는 프로퍼티를 &lt;b&gt;타입 프로퍼티&lt;/b&gt;라고 합니다. 타입 프로퍼티는 타입 자체에 영향을 미치는 프로퍼티이며 인스턴스의 생성 여부와 상관 없이 타입 프로퍼티의 값은 하나입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;해당 타입의 모든 인스턴스가 공통으로 사용하는 값&lt;/li&gt;
  &lt;li&gt;모든 인스턴스에서 공용으로 접근하고 값을 변경할 수 있는 변수&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;타입-프로퍼티와-인스턴스-프로퍼티&quot;&gt;타입 프로퍼티와 인스턴스 프로퍼티&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class TypeClass {

  // 저장 타입 프로퍼티
  static var typeProperty: Int = 0

  // 저장 인스턴스 프로퍼티
  var instanceProperty: Int = 0 {
    didSet {
      Type.typeProperty = instanceProperty + 100
    }
  }

  // 연산 타입 프로퍼티
  static var typeComputedProperty: Int {
    get {
      return typeProperty
    }
    set {
      typeProperty = newValue
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;글의 일부 내용은 야곰님의 저서 &lt;a href=&quot;http://book.naver.com/bookdb/book_detail.nhn?bid=11445773&quot;&gt;스위프트 프로그래밍&lt;/a&gt;(2017, 한빛미디어)를 참고하여 작성되었습니다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">프로퍼티 프로퍼티는 클래스, 구조체 또는 열거형 등에 관련된 값을 뜻합니다.</summary></entry><entry><title type="html">Swift - 구조체, 클래스</title><link href="/jekyll/update/2017/03/11/swift3-struct-class.html" rel="alternate" type="text/html" title="Swift - 구조체, 클래스" /><published>2017-03-11T04:40:05+00:00</published><updated>2017-03-11T04:40:05+00:00</updated><id>/jekyll/update/2017/03/11/swift3-struct-class</id><content type="html" xml:base="/jekyll/update/2017/03/11/swift3-struct-class.html">&lt;h3 id=&quot;구조체-클래스&quot;&gt;구조체, 클래스?&lt;/h3&gt;
&lt;p&gt;구조체와 클래스는 프로그래머가 데이터를 용도에 맞게 묶어 표현하고자 할 때 용이합니다. 구조체와 클래스는 프로퍼티와 메서드를 사용하여 데이터를 구조화하여 관리할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;같은점&quot;&gt;같은점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;값을 저장하기 위해 프로퍼티(저장 프로퍼티)를 정의할 수 있습니다. 연산 프로퍼티도 정의 가능합니다.&lt;/li&gt;
  &lt;li&gt;기능 수행을 위해 메서드를 정의할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;서브스크립트 문법을 통해 구조체 또는 클래스가 가지는 값(프로퍼티)에 접근하도록 서브스크립트를 정의할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;초기화될 때의 상태를 지정하기 위해 이니셜라이저를 정의할 수 있습니다.
    &lt;ul&gt;
      &lt;li&gt;구조체는 기본으로 멤버와이즈 이니셜라이저가 제공됩니다. 또, 사용자 정의 이니셜라이저도 구현이 가능합니다.&lt;/li&gt;
      &lt;li&gt;클래스도 기본 이니셜라이저 외에 사용자가 직접 이니셜라이저를 정의할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;초기 구현과 더불어 새로운 기능 추가를 위해 익스텐션을 통해 확장할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;특정 기능을 수행하기 위해 특정 프로토콜을 준수(Adopt)할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;소스파일 하나에 여러 개의 구조체와 여러 개의 클래스를 정의하고 구현 가능합니다.&lt;/li&gt;
  &lt;li&gt;중첩 함수와 마찬가지로 구조체 안에 구조체, 클래스 안에 클래스 등과 같이 중첩 타입의 정의 및 선언 가능합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;차이점&quot;&gt;차이점&lt;/h3&gt;
&lt;p&gt;데이터를 구조화하여 관리하는 구조체와 클래스는 서로 같은 점도 있지만, 서로 차이점도 있습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;구조체&lt;/th&gt;
      &lt;th&gt;클래스&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;전통적인 OOP 관점에서의 클래스&lt;/td&gt;
      &lt;td&gt;C언어 등의 구조체보다 다양한 기능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;b&gt;참조 타입&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;&lt;b&gt;값 타입&lt;/b&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;단일 상속&lt;/td&gt;
      &lt;td&gt;상속 불가&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;타입캐스팅 가능&lt;/td&gt;
      &lt;td&gt;타입캐스팅 불가&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;디이니셜라이저 가능&lt;/td&gt;
      &lt;td&gt;디이니셜라이져 불가&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iOS 프레임워크의 대부분의 큰 뼈대는 모두 클래스로 구성&lt;/td&gt;
      &lt;td&gt;Swift의 대부분의 큰 뼈대는 모두 구조체로 구성&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;가장 큰 차이는 인스턴스의 타입입니다. 클래스의 인스턴스는 참조 타입이며 구조체의 인스턴스는 값 타입입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;값 타입과 참조 타입의 가장 큰 차이는 '무엇이 전달되느냐'입니다.&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;어떤 함수의 전달인자로 값 타입의 값을 넘기면 &lt;b&gt;전달될 값이 복사&lt;/b&gt;되어 전달됩니다.&lt;/li&gt;
  &lt;li&gt;어떤 함수의 전달인자로 참조 타입의 값을 넘기면 &lt;b&gt;참조(주소)가 전달&lt;/b&gt;됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;인스턴스와 객체
흔히 다른 프로그래밍 언어에서는 클래스의 인스턴스를 객체라고 부릅니다. 물론 스위프트에서도 객체라고 표현하는 것이 틀린 것은 아니지만, 스위프트 공식 문서에는 좀 더 한정적인 인스턴스라는 용어를 사용합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;구조체와-클래스-선택해서-사용하기&quot;&gt;구조체와 클래스 선택해서 사용하기&lt;/h3&gt;

&lt;p&gt;구조체와 클래스는 모두 새로운 데이터 타입을 정의하고 기능을 추가한다는 점에서는 같습니다. 하지만 구조체 인스턴스는 항상 값 타입이고, 클래스 인스턴스는 참조 타입입니다. 그 의미는 생긴 것은 비슷하지만 용도는 다르다는 의미입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;프로젝트의 성격에 따라, 데이터의 활용 용도에 따라, 특정 타입을 구현할 때 구조체와 클래스 둘 중 하나를 선택&lt;/code&gt;해서 사용해야 합니다.&lt;/p&gt;

&lt;p&gt;애플 가이드라인에 따른 구조체 사용 조건&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;연관된 간단한 값의 집합을 캡슐화하는 것만이 목적일 때&lt;/li&gt;
  &lt;li&gt;캡슐화된 값이 참조되는 것보다 복사되는 것이 합당할 때&lt;/li&gt;
  &lt;li&gt;구조체에 저장된 프로퍼티가 값 타입이며 참조되는 것보다 복사되는 것이 합당할 때&lt;/li&gt;
  &lt;li&gt;다른 타입으로부터 상속받거나 자신이 상속될 필요가 없을 때&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;글의 일부 내용은 야곰님의 저서 &lt;a href=&quot;http://book.naver.com/bookdb/book_detail.nhn?bid=11445773&quot;&gt;스위프트 프로그래밍&lt;/a&gt;(2017, 한빛미디어)를 참고하여 작성되었습니다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">구조체, 클래스? 구조체와 클래스는 프로그래머가 데이터를 용도에 맞게 묶어 표현하고자 할 때 용이합니다. 구조체와 클래스는 프로퍼티와 메서드를 사용하여 데이터를 구조화하여 관리할 수 있습니다.</summary></entry></feed>