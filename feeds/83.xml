<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>필오의 개발일지</title>
  
  <subtitle>Frontend developer &amp; love UX, Interaction</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://feel5ny.github.io/"/>
  <updated>2019-03-17T15:48:21.824Z</updated>
  <id>http://feel5ny.github.io/</id>
  
  <author>
    <name>Joy Kim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>코드스피츠80_OOP design with game (2)- 2. 모델 (베이스 레이어)</title>
    <link href="http://feel5ny.github.io/2019/03/17/OOP_09_2/"/>
    <id>http://feel5ny.github.io/2019/03/17/OOP_09_2/</id>
    <published>2019-03-17T04:32:40.000Z</published>
    <updated>2019-03-17T15:48:21.824Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>코드스피츠 강의 정리록</p></blockquote><p>생소한 도메인으로 배우는게 좋다.<br>익숙한 도메인들은 익숙한 처리방법으로 처리하기때문에 객체지향을 배우기 어렵다.<br>때문에 80기는 게임을 통해서 진행할 예정.</p><hr><p><a name="1"></a></p><h1 id="1-저번시간의-코드에서-잘못된-점을-찾아보자"><a href="#1-저번시간의-코드에서-잘못된-점을-찾아보자" class="headerlink" title="1. 저번시간의 코드에서 잘못된 점을 찾아보자."></a>1. 저번시간의 코드에서 잘못된 점을 찾아보자.</h1><p><a name="1-1"></a></p><h2 id="1-1-베이스-클래스에-네이티브-지식이-포함되어있다"><a href="#1-1-베이스-클래스에-네이티브-지식이-포함되어있다" class="headerlink" title="1.1 베이스 클래스에 네이티브 지식이 포함되어있다."></a>1.1 베이스 클래스에 네이티브 지식이 포함되어있다.</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Block = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> GET(type = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">5</span>))&#123; <span class="keyword">return</span> <span class="keyword">new</span> Block(type);&#125;</span><br><span class="line">  <span class="keyword">constructor</span>(type) &#123;</span><br><span class="line">    <span class="keyword">this</span>._type = type;</span><br><span class="line">  &#125;</span><br><span class="line">  get image()&#123; <span class="keyword">return</span> 👉 <span class="string">`url('img/block<span class="subst">$&#123;<span class="keyword">this</span>._type&#125;</span>.png'`</span>;&#125;</span><br><span class="line">  get type()&#123; <span class="keyword">return</span> <span class="keyword">this</span>._type&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>블럭 모델에 네이티브 지식이 들어가있다. (css 지식)</li><li>베이스 레이어에 들어오면 안되는 지식이다.</li></ul><blockquote><p>아키텍처는 코드에 가질 수 있는 역할과 가질 수 없는 역할,<br>  기질 수 있는 책임과 가질수 없는 책임을 명시할 수 있고,<br>  그것으로 코드가 바른지 안바른지 판단하는 기준표가 된다.</p><ul><li>기존 모델에서 지금 아키텍처와 안 맞는 부분을 지목할 수 있다.</li></ul></blockquote><hr><p><a name="1-2"></a></p><h2 id="1-2-통제권을-가진-제왕이-존재한다-1-블럭-위치값의-지식"><a href="#1-2-통제권을-가진-제왕이-존재한다-1-블럭-위치값의-지식" class="headerlink" title="1.2 통제권을 가진 제왕이 존재한다. (1) - 블럭 위치값의 지식"></a>1.2 통제권을 가진 제왕이 존재한다. (1) - 블럭 위치값의 지식</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">👉 <span class="keyword">const</span> data = [];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="params">tid</span> =&gt;</span> &#123;</span><br><span class="line">  table = <span class="built_in">document</span>.querySelector(tid);</span><br><span class="line">  👉 <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">    <span class="keyword">const</span> r = [];</span><br><span class="line">    data.push(r);</span><br><span class="line">    👉 <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; column; j++) r[j] = Block.GET();</span><br><span class="line">  &#125;</span><br><span class="line">  table.addEventListener(<span class="string">'mousedown'</span>, down);</span><br><span class="line">  table.addEventListener(<span class="string">'mouseup'</span>, up);</span><br><span class="line">  table.addEventListener(<span class="string">'mouseleave'</span>, up);</span><br><span class="line">  table.addEventListener(<span class="string">'mousemove'</span>, move);</span><br><span class="line">  render();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="cf-1-프로시저적인-생각을-한다-를-어디서-알-수-있냐면"><a href="#cf-1-프로시저적인-생각을-한다-를-어디서-알-수-있냐면" class="headerlink" title="cf__1. 프로시저적인 생각을 한다? 를 어디서 알 수 있냐면,"></a>cf__1. 프로시저적인 생각을 한다? 를 어디서 알 수 있냐면,</h4><p>= <strong>모든 연산을 data를 갖고 하려고 한다.</strong></p><ul><li>data가 왕이다. 통제의 왕</li></ul><p>일반적으로 프로시저로 짜면 메모리를 적게 사용하게 된다.</p><ul><li>메모리의 효율성이 높아지고, 연산의 횟수가 줄어든다.</li><li>하지만 모든 복잡성을 본인이 감당해야한다. <ul><li>예를들어 현재는 2차원배열로 작업했지만,<br>요건이 만약 3차원의 개념으로 바뀐다면?<br>3차원배열로 바꿔야하는데 그럼.. 로직을 아예 바꿔야함</li></ul></li></ul><h3 id="블럭의-위치값"><a href="#블럭의-위치값" class="headerlink" title="블럭의 위치값"></a>블럭의 위치값</h3><p>2차원 배열에 들어가는데, 블럭에 X값 Y값이 들어가있나? </p><ul><li>안들어가있음. 실제 객체는(Block) 모르고 있다. </li><li>블럭은 x, y값을 모르는데 자기 스스로 move나 판정을 할 수 있을까?<br>row와 column값은(i와 j) Block의 지식일까? data의 지식일까?</li><li>현재는 data가 통제의 왕이기 때문에 data가 블럭의 판정통제권을 들고 있다.(i, j)</li></ul><p>객체지향은 내 할일이 아니면 위임하는 것이다.</p><ul><li>자기일이 아닌거는 계속 미룬다. 미룰사람이 누군지만 알고 있으면 된다.</li><li>말로만 객체지향이나 역할을 거의 수행할 수 없는 상태.<br>현재 블럭은 x,y에 대한 역할을 수행할 수 없다.</li></ul><hr><p><a name="1-3"></a></p><h2 id="1-3-통제권을-가진-제왕이-존재한다-2-선택된-블럭의-지식"><a href="#1-3-통제권을-가진-제왕이-존재한다-2-선택된-블럭의-지식" class="headerlink" title="1.3 통제권을 가진 제왕이 존재한다. (2) - 선택된 블럭의 지식"></a>1.3 통제권을 가진 제왕이 존재한다. (2) - 선택된 블럭의 지식</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selected = [], getBlock = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> down = <span class="function">(<span class="params">&#123;pageX: x, pageY: y&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(isDown) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> curr = getBlock(x,y);</span><br><span class="line">  <span class="keyword">if</span>(!curr) <span class="keyword">return</span>;</span><br><span class="line">  isDown = <span class="literal">true</span>;</span><br><span class="line">  👉 selected.length = <span class="number">0</span>; </span><br><span class="line">  👉 selected[<span class="number">0</span>] = startBlock = currBlock = curr;</span><br><span class="line">  render();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> move = <span class="function">(<span class="params">&#123; pageX: x, pageY: y &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isDown) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> curr = getBlock(x, y);</span><br><span class="line">  <span class="keyword">if</span> (!crr || curr.type !== startBlock.type || !isNext(curr)) <span class="keyword">return</span>;</span><br><span class="line">  👉 <span class="keyword">if</span> (selected.indexOf(curr) == <span class="number">-1</span>) selected.push(curr);</span><br><span class="line">  👉 <span class="keyword">else</span> <span class="keyword">if</span> (selected[selected.length - <span class="number">1</span>] == curr) selected.pop();</span><br><span class="line">  currBlock = curr;</span><br><span class="line">  render();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> up = <span class="function"><span class="params">()</span> =&gt;</span> (👉 selected.length &gt; <span class="number">2</span> ? remove() : reset());</span><br></pre></td></tr></table></figure><ol><li><p>selected를 사방에서 직접 컨트롤하고 있다. </p><ul><li>만약 선택의 조건이 현재 요건과 달라진다면?<br>down, move, up 모두 바꿔야 한다. </li></ul></li><li><p>selected도 블럭이 선택되어있는지 아닌지에 대한 지식이기 때문에<br>Block의 지식이다.</p><ul><li>선택된 그룹도 블럭이 알고 있는 것이고,</li><li>블럭이 블럭 인스턴스끼리 협력하는 코드는 블럭내의 지식이다.</li><li>블럭은 내 형제가 누군지에 대해서 블럭이라는 클래스 지식내에서 해결할 수 있다.</li></ul></li><li><p>우리는 완전히 독립되어있는 어떤 데이터를 바라보고 있는<br>프로시저를 짜서 해결하려고 한다.</p><ul><li>때문에 데이터 구조가 달라지면 다 바꿔야한다.</li></ul></li><li><p>끊임없는 상태에 대한 변화의 책임을<br>블럭이 갖고 있어야한다.</p><ul><li>가장 중요한 권한은 블럭의 type이 아니라<br><strong>끊임없는 상태에 대한 변화의 책임을 블럭이 갖고 있어야한다.</strong> </li><li>상태를 갖고 있으면 관리가 어렵기 때문에 해당 책임을 갖고 있는 객체가 알아서 하게끔 권한을 주는 것.</li><li>현재 코드에서 블럭의 상태는<br>거의 상태가 없는 객체나 마찬가지이다.</li></ul></li></ol><hr><p><a name="2"></a></p><h1 id="2-프로시저를-객체지향으로-바꿔보자"><a href="#2-프로시저를-객체지향으로-바꿔보자" class="headerlink" title="2. 프로시저를 객체지향으로 바꿔보자."></a>2. 프로시저를 객체지향으로 바꿔보자.</h1><p><a name="2-1"></a></p><h2 id="2-1-모델-feat-유틸"><a href="#2-1-모델-feat-유틸" class="headerlink" title="2.1 모델 (feat. 유틸)"></a>2.1 모델 (feat. 유틸)</h2><p><a name="2-1-1"></a></p><h3 id="2-1-1-심플한-책임"><a href="#2-1-1-심플한-책임" class="headerlink" title="2.1.1 심플한 책임"></a>2.1.1 심플한 책임</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Block = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> GET(type = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">5</span>))&#123; <span class="keyword">return</span> <span class="keyword">new</span> Block(type);&#125;</span><br><span class="line">  <span class="keyword">constructor</span>(type) &#123;</span><br><span class="line">    <span class="keyword">this</span>._type = type;</span><br><span class="line">  &#125;</span><br><span class="line">  get image()&#123; <span class="keyword">return</span> <span class="string">`url('img/block<span class="subst">$&#123;<span class="keyword">this</span>._type&#125;</span>.png'`</span>;&#125;</span><br><span class="line">  get type()&#123; <span class="keyword">return</span> <span class="keyword">this</span>._type&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👇👇👇<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UTIL = &#123;</span><br><span class="line">  el: <span class="function">(<span class="params">v: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">document</span>.querySelector(v),</span><br><span class="line">  prop: <span class="function">(<span class="params">...arg</span>) =&gt;</span> <span class="built_in">Object</span>.assign(...arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IItem &#123;</span><br><span class="line">  pos: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  select: <span class="function">(<span class="params">item: Item</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  unselect: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Item = <span class="keyword">class</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> GET(<span class="keyword">type</span>: <span class="built_in">number</span>, x: <span class="built_in">number</span>, y: <span class="built_in">number</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Item(<span class="keyword">type</span>, x, y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">_type: <span class="built_in">number</span>, _x: <span class="built_in">number</span>, _y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    prop(<span class="keyword">this</span>, &#123;_type, _x, _y, _selected: <span class="literal">false</span>, _prev: <span class="literal">null</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="keyword">type</span>()&#123; <span class="keyword">return</span> <span class="keyword">this</span>._type; &#125;</span><br><span class="line">  <span class="keyword">get</span> x()&#123; <span class="keyword">return</span> <span class="keyword">this</span>._x; &#125;</span><br><span class="line">  <span class="keyword">get</span> y()&#123; <span class="keyword">return</span> <span class="keyword">this</span>._y; &#125;</span><br><span class="line">  <span class="keyword">get</span> selected()&#123; <span class="keyword">return</span> <span class="keyword">this</span>.selected; &#125;</span><br><span class="line">  <span class="keyword">get</span> prev()&#123; <span class="keyword">return</span> <span class="keyword">this</span>._prev; &#125;</span><br><span class="line"></span><br><span class="line">  pos(x: <span class="built_in">number</span>, y: <span class="built_in">number</span>)&#123; <span class="comment">// 어디로 움직일지</span></span><br><span class="line">    <span class="keyword">this</span>._x = x;</span><br><span class="line">    <span class="keyword">this</span>._y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  select(item: Item)&#123; <span class="comment">// 어떤 아이템에 선택할지?</span></span><br><span class="line">    <span class="keyword">this</span>._selected = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>._prev = item;</span><br><span class="line">  &#125; </span><br><span class="line">  unselect()&#123;</span><br><span class="line">    <span class="keyword">this</span>._selected = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>._prev = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>싱글 노드 링크드 리스트가 완성되었다.</p><ul><li>이전에는 배열로(data) 관리했었는데, 이제는 링크드 리스트로 관리한다.<br>나의 지식은 나와 이전(prev) 정도까지밖에 모르기 때문에</li></ul></li><li><p>item 객체가 이 이상을 알게 되면, 권한 위반이 된다.</p><ul><li><strong>권한 책임을 축소하면 연산이 많이 일어난다. </strong><br>(연산이 늘어난 부분은 걱정하지 말자.)</li></ul></li><li><p>밖에는 캡슐화 된 메소드로 대화한다.</p><ul><li>블럭 상태는 밖에서 관리하지 않고,</li><li>밖에서는 pos, select, unselect만 알게하자.</li></ul></li></ol><p><a name="2-1-2"></a></p><h3 id="2-1-2-어려운-책임"><a href="#2-1-2-어려운-책임" class="headerlink" title="2.1.2 어려운 책임"></a>2.1.2 어려운 책임</h3><p>좀 더 어려운 책임을 바라보게 하자.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Item = <span class="keyword">class</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  isSelectedList(item: Item)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>._prev) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>._prev === item) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">this</span>._prev.isSelectedList(item) </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  isBorder(item: Item) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">Math</span>.abs(<span class="keyword">this</span>.x - item.x) &lt; <span class="number">2</span>) &amp;&amp;</span><br><span class="line">           (<span class="built_in">Math</span>.abs(<span class="keyword">this</span>.y - item.y) &lt; <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1-isSelectedList"><a href="#1-isSelectedList" class="headerlink" title="1. isSelectedList"></a>1. isSelectedList</h4><p>selectedList에 포함되어있냐 아니냐를 판단하는 메소드</p><ul><li>모든 상황이 안되면, 바로 이전의 item에게 물어본다.</li></ul><ul><li>책임 권한을 _prev로 제약하여 메모리와 연산을 교환하였다. (링크드 리스트)</li><li>이 모든 건 자료구조의 일부이다.</li></ul><h5 id="cf-2-객체지향에서-책임의-범위와-자료구조"><a href="#cf-2-객체지향에서-책임의-범위와-자료구조" class="headerlink" title="cf__2. 객체지향에서 책임의 범위와 자료구조"></a>cf__2. 객체지향에서 책임의 범위와 자료구조</h5><ol><li><p>책임 범위를 축소하면 연산을 많이하게 된다.</p><ul><li>타클래스의 메서드를 호출할 경우도 있고,<br>본인의 연결되어있는 클래스를 호출하는 경우가 더 많다.</li></ul></li><li><p>객체지향에서는 기본적으로 배열같은 어그리게이션(집합)을 쓰는 경우가 거의 없다.</p><ul><li>어그리게이션을 쓰면 어그리게이터에 대한 로직을 따로 짜야한다.</li><li>코디네이터를 더 만들기 싫으면 본인 안에 링크드 리스트로 연결하는 수밖에 없다.</li><li>컬렉터를 만드냐 안만드냐는 아키텍처상 중요한 요소이다.</li><li>컬렉터를 추상화하는 것은 굉장히 어려운 것이다.</li><li>통합된 자료구조를 안쓰게 되니까 다 연산으로 되어있는 자료구조를 쓰게 된다.</li></ul></li><li><p>배열을 링크드 리스트로 치환한 것이다.</p></li></ol><ul><li>같은 자료구조임에도 불구하고, 연산으로 메모리로 치환하거나 메모리를 연산으로 치환할 수 있다.<ul><li>연산을 메모리로 치환하면 속도가 빨라진다.<ul><li>메모리를 연산으로 치환하면 좋은 점이<br>하나는 메모리가 절감되는 경우가 생기고,<br>권한을 축소할 수 있는 권한이 생긴다. (프로시저)</li></ul></li><li>자바스크립트의 프로토타입체인은 대표적으로 연산을 통해서 메모리를 줄이는 시스템이다.<br>연산을 통해서 프로토타입 체인에 가져오는 것이다.<br>예전 메모리가 없던(넷스케이프)시절 개발된 자바스크립트.<ul><li>하지만 현대의 크롬브라우저는 속도가 더 중요하기 때문에 모든 프로토타입 체이닝에 잇는 것을 다 copy해서 캐시테이블을 만들어서 거기서 읽는다.<ul><li>더이상 프로토타입 체인 타고 가서 가져오지 않는다. 때문에 크롬에서 자바사크립트가 빠른 이유이다.</li><li>체인을 매번 타고 가는 연산은 귀찮기 때문에</li></ul></li></ul></li></ul></li></ul><blockquote><p>알고리즘의 태반은 자료구조로 되어있고,<br>자료구조의 태반은 다시 또 알고리즘으로 돌아가게 되어있다.<br>항상 메모리와 연산은 교환할 수 있다.</p></blockquote><h4 id="2-isBorder"><a href="#2-isBorder" class="headerlink" title="2. isBorder"></a>2. isBorder</h4><p>나의 인접 셀을 파악하는 것도 나의 권한이다.</p><ul><li>특정 아이템의 x,y가 나의 지식이기 때문에.</li><li>나의 x,y와 아이템의 x,y의 차이를 이용해서 나의 인접 셀인지 아닌지를 알 수 있다.</li></ul><h5 id="cf-3-권한-책임-역할"><a href="#cf-3-권한-책임-역할" class="headerlink" title="cf__3. 권한 + 책임 = 역할"></a>cf__3. <strong>권한 + 책임 = 역할</strong></h5><ol><li><p>우리가 책임을 부여하고 싶으면, 권한을 부여해야한다.<br>두개가 어긋나면 둘중 하나가 깨진다.</p><ul><li>객체지향에서 권한은 은닉화 되어서 내부 상태로 숨고,<br>책임은 표면화되서 외부 메소드를 드러나게 되어있다.<br>메소드는 캡슐화해서 표현된다.<br>ex_ATM기기</li><li>객체지향에서 메소드는 <code>this</code>라는 내부상태의 은닉되어있는 상태를 사용하고 있느냐,<br>추상화가 되어있는, 캡슐화 되어있는 메소드냐가 충족되어야<br>객체지향에서 메소드라고 부른다.</li></ul></li><li><p>얼만큼 캡슐화되어야하는지는 대상에 따라 다르다.</p><ul><li>어느 정도로 캡슐화되어있느냐는 공개 범위에 달려있다.</li><li>현재 Item의 기준은 게임이다. 게임이 이해할 수 있고, 몰라도 되는 기준으로 캡슐화</li><li>그게 내부 인터널에서 사용하는것?</li><li>자기들끼리 쓰는것?</li><li>부모자식간에 쓰는 것?</li></ul></li></ol><blockquote><p>내가 만약 프로그램을 짜서 공개되는 코드도 마지막에 은닉과 캡슐화를 처리하는 단계는 항상 머리속에 짱구를 그려야한다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;코드스피츠 강의 정리록&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;생소한 도메인으로 배우는게 좋다.&lt;br&gt;익숙한 도메인들은 익숙한 처리방법으로 처리하기때문에 객체지향을 배우기 어렵다.&lt;br&gt;때문에 80기는 게임을 통해서 진행할 
      
    
    </summary>
    
      <category term="02_WorkShop" scheme="http://feel5ny.github.io/categories/02-WorkShop/"/>
    
      <category term="2019 CodeSpitz" scheme="http://feel5ny.github.io/categories/02-WorkShop/2019-CodeSpitz/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
      <category term="OOP" scheme="http://feel5ny.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>코드스피츠80_OOP design with game (2)- 1. 개요</title>
    <link href="http://feel5ny.github.io/2019/03/11/OOP_09_1/"/>
    <id>http://feel5ny.github.io/2019/03/11/OOP_09_1/</id>
    <published>2019-03-11T01:20:19.000Z</published>
    <updated>2019-03-17T15:46:49.994Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>코드스피츠 강의 정리록</p></blockquote><p>생소한 도메인으로 배우는게 좋다.<br>익숙한 도메인들은 익숙한 처리방법으로 처리하기때문에 객체지향을 배우기 어렵다.<br>때문에 80기는 게임을 통해서 진행할 예정.</p><hr><p><a name="0"></a></p><h1 id="0-프로시저-프로그래밍"><a href="#0-프로시저-프로그래밍" class="headerlink" title="0. 프로시저 프로그래밍"></a>0. 프로시저 프로그래밍</h1><blockquote><p>저번시간의 프로시저 프로그래밍 복습</p></blockquote><p><a name="0-1"></a></p><h2 id="프로시저-프로그래밍의-특징"><a href="#프로시저-프로그래밍의-특징" class="headerlink" title="프로시저 프로그래밍의 특징"></a>프로시저 프로그래밍의 특징</h2><ol><li><strong>함수</strong>와 <strong>함수가 처리해야 할 데이터</strong>가 분리되어있고,<br><strong>데이터와 함수가 같이 연동되어야 하지만 프로시저가 작동된다.</strong><br>.<br>프로시저 작동에서는 행위에만 집착하게 된다. (데이터 배열에 무엇을 채웠어 무엇을 비웠어)<br>데이터를 처리했다는 행위에 집중한다.<br>.</li><li>함수형과는 다르게 프로시저들은 가리키고 있는 <strong>데이터</strong>가 있다.<br>프로시저는 <strong>상태</strong>를 지향하며,<br>(유틸리티처럼) 특정 상태를 변화시키는 것에 관심을 둔다.<br>(함수형은 인자로 받거나 지역변수만 사용하는 식으로 데이터를 처리하고 있다.)</li></ol><hr><p><a name="0-2"></a></p><h2 id="프로시저-프로그래밍의-단점"><a href="#프로시저-프로그래밍의-단점" class="headerlink" title="프로시저 프로그래밍의 단점"></a>프로시저 프로그래밍의 단점</h2><ol><li><strong>데이터의 변화</strong>와<br><strong>데이터를 처리하는 함수의 변화</strong>가 동시에 이루어지지 않는다.<br>.</li><li>데이터를 조금만 바꾸던지, 처리를 바꾸면<br>데이터가 어긋나게 되고 프로그램 전체가 깨지게 된다.<ul><li>데이터 항목 구성을 변화하거나<br>데이터 자체에 추가적인 내용이나 연결되어있는 데이터를 만드는 일은 흔하다.<br>=&gt; 이런 상황이 생기면 기존의 프로시저가 깨진다.</li><li>우리는 프로시저 프로그래밍에 익숙해져 있다.<br>ex_TDD<br>TDD를 사용하면 무조건 프로시저로 짜게 된다.<br>테스트 메소드 전체는 다 프로시져이다.<ul><li>테스트 메소드가 알 수 없는 외부상태의 것을 테스트하는 함수 <ul><li>: 프로시저</li></ul></li><li>: 객체를 바꾸면 테스트함수가 다 깨짐. 다 바꿔야함.</li><li>테스트 주도 개발을 하려면, 설계를 잘하면 할 수 있다.</li></ul></li></ul></li></ol><ul><li>프로시저로 만들면 어떤 일이 생긴냐면..<br>ex_만약에 폭발형 아이템을 만든다면?<br>=&gt; 프로시저 전체를 다 수정하는 수밖에 없다.<br>=&gt; if를 넣어서 분기하면서 수정하는 수밖에 없다.(모든 함수에 다 들어간다.)<br>=&gt; <strong>if가 추가되는 것이 문제가 아니라 기존의 모든 레거시와의 관계를 재검토해서 들어가야하는데..복잡성을 감당할 수 없다.</strong></li></ul><p>복잡성이 폭발하면 ? =&gt; 버려야합니다.</p><ul><li>프로그래밍의 수명은 복잡성 컨트롤 제어에 실패하면<br>더이상 유지보수할 수 없기 때문에<br>나머지의 모든 프로그래밍 기법들은 복잡성이 더 복잡해지지 않게 하기 위해.</li></ul><p><a name="0-3"></a></p><h2 id="엔트로피-증가법칙-😎😎"><a href="#엔트로피-증가법칙-😎😎" class="headerlink" title="엔트로피 증가법칙 😎😎"></a>엔트로피 증가법칙 😎😎</h2><p>많은 사람들의 요건추가와 변화로 엔트로피가 꾸준히 증가한다.<br>엔트로피를 증가시키는 것을 최대한 둔화시켜야한다.<br>프로그래밍 세계에서 엔트로피가 언제 증가하는지 알아가는 것이 우리 스터디에서 배워야할 것.<br>많은 장치로 엔트로피의 증가를 막을 수있다.<br>아무리 막아도 내년되면 다시 짜야한다.<br>잘못짠 프로그램은 엔트로피가 급격하게 증가해서 빨리 버리게 된다.<br>잘짠 프로그램도 버려야한다.</p><p>엔트로피 증가방향을 컨트롤해서 완화시키고<br>복잡한 환경이나 여러가지 변화상황을 잘 받아들일 수 있는 구조를 짜는것을<br>디자인이라고 하고<br>아키텍처라고 한다.</p><p>엔트로피 증가를 막으려고.</p><hr><p><a name="0-4"></a></p><h2 id="엔트로피-증가를-막자"><a href="#엔트로피-증가를-막자" class="headerlink" title="엔트로피 증가를 막자."></a>엔트로피 증가를 막자.</h2><p>객체지향에서는 어떻게 앤트로피 증가를 막느냐.<br><strong>역할</strong>이라는 것으로 분리해서 막는다.</p><p><a name="0-4-0"></a></p><h3 id="가장-중요한-변화율"><a href="#가장-중요한-변화율" class="headerlink" title="가장 중요한 변화율"></a>가장 중요한 변화율</h3><p>변화율을 기준으로 역할을 분리해서 역할별로 객체들을 만들고 싶은데,<br>그렇게 하기에는 우리가 해결해야 하는 문제가 너무 큰 덩어리로 되어있는 문제라는 것이다.</p><p>사람은 한꺼번에 복잡성 제어를 못 하기 때문에 복잡성 폭발한 프로그램은 버리게 된다.<br>너무 복잡한 것은 분석할 수 없다.<br>복잡한 문제는 나눠서 분석해야지만 분석할 수 있다.</p><p>복잡한 문제를 나눠서 분석하기 위한 도구를 <strong>추상화 도구</strong>라고 한다.<br>(<a href="https://feel5ny.github.io/2018/10/01/OOP_06/#2">다른 글</a>)</p><p><a name="0-4-1"></a></p><h3 id="1-Categorizing"><a href="#1-Categorizing" class="headerlink" title="1. Categorizing"></a>1. Categorizing</h3><p>분류를 통해서 계속 나눠가면<br>상쇄 적인 부분만 하나씩 정복해나가면 전체를 이해할 수 있다는 개념</p><ul><li>단점: 카테고리가 여러 곳에 소속되어있을 때 처리하기가 많다.</li></ul><p><a name="0-4-2"></a></p><h3 id="2-Modeling"><a href="#2-Modeling" class="headerlink" title="2. Modeling"></a>2. Modeling</h3><p>기억해야만 할 것을 정리하면 모델링이 된다.</p><ul><li>없어야 할 데이터는 없어야 한다. 없어야 할 데이터가 있는 것도 오류다.<br>.<br>현재의 모델링이 미래에 유용한 것도 아니고<br>미래를 위해서 현재의 모델링을 함부로 확장하는 것도 아니다.</li><li>모델링의 단점: 유지보수가 힘들다. 현실 세계에서는 모델이 자주 바뀐다<br>ex_학생. =&gt; 학번, 이름,</li></ul><p>데이터에 의존하고 있는 프로시저가 데이터의 변화를 따라갈 수 없기 때문에 프로시저 프로그램들이 에러가 나는 것이다.</p><ul><li>현실 세계에서 모델링을 해야 하고<br>모델링을 다루는 함수들을 강력하게 바인딩시키지 않으면<br>모델의 변화가 프로시저에 충분히 반영되지 않거나<br>프로시저의 변화가 모델에 반영되지 않아 둘이 어긋나서 프로그램이 깨지는 것.</li></ul><p><a name="0-4-3"></a></p><h3 id="3-Grouping"><a href="#3-Grouping" class="headerlink" title="3. Grouping"></a>3. Grouping</h3><p>우리가 필요해서 묶어주는 것</p><ul><li>enum을 사용하면 단일집합을 사용할 수있다.</li><li>class도 집합.<br>클리스의 인스턴스를 만드는 것도 어떤 그룹인지 마킹을 해주는 의미도 있다.<br>단지 그룹핑만을 위해서 마커를 사용할 경우에 클래스나 인터페이스를 마커 클래스나 마커 인터페이스라고 한다.<br>ex_ 페이스북에 해시태그에 ‘맛집’도 집합</li></ul><hr><hr><p><a name="1"></a></p><h1 id="1-레이어-분리-Layering"><a href="#1-레이어-분리-Layering" class="headerlink" title="1. 레이어 분리 (Layering)"></a>1. 레이어 분리 (Layering)</h1><p>(feat. 마틴 파울러의 <strong>앤터 프라이즈 디자인 패턴 책</strong>)<br>레이어라는 방법을 사용한다.<br>레이어는 일종에 카테고라이즈에 가깝다. </p><p>먼저 크게 분리한다.<br>client ←→ server<br>presentation ←→ doman ←→ data source</p><ul><li>domain: 도메인 로직</li><li>data source: 저장하는 로직</li><li>presentation: 도메인을 표현하는 로직 (앱, 웹,..)</li></ul><p><img src="/images/2019/14/01.png"></p><ol><li>레이어는 계층적이다. 레이어들간에는 호환되지 않는다! 층을 정확하게 나눠야한다.</li><li>기저레이어는 추상레이어를 모른다.<br><strong>추상레이어</strong><ul><li>기저레이어를 사용하는 레이어</li><li>기저레이어에 대한 지식을 알고 있는 레이어</li><li>OOP에 대입하면<br><strong>기저레이어: 부모클래스<br>추상레이어: 자식클래스</strong></li><li>자식이 부모를 알고 있다. 부모는 자식을 모른다.</li></ul></li><li>레이어안에 다수의 역할이 소속된다.<br>레이어안에는 다수의 역할이나 다수의 역할을 수행하는 인스턴스들이 소속된다.</li></ol><p>레이어안에는 레이어의 전체적인 레이어 가이드들을 지키고 있는 수많은 레이어들이 존제한다.</p><hr><p>인메모리에서 레이어를 나누어보자.<br>레이어를 나누는 눈이 필요하다.</p><ol><li>(함수형) 유틸리티<br>함수와 메소드의 차이는 this를 쓰냐안쓰냐.<br>OOP에는 기저 인터페이스나 기저 클래스도 유틸리티로 분류하기도 한다.</li><li>베이스 클래스</li><li>구상 클래스</li><li>호스트코드</li></ol><p>게임의 실체는 어디일까?<br>실체는 호스트 코드.</p><ul><li>구상 클래스, 베이스 클래스에 로직이 있고, 호스트코드는 사용하는 입장이다.</li><li>진짜로 일하는 애는 호스트코드</li><li>호스트코드부터 짜는 것이 좋다. 반대로 짜게 되면 사용하지 않을 것들도 만들게 됨.</li></ul><p>수업 시간에는 아키텍처를 공부하기 위해 반대로 짜볼 것이다.</p><hr><p><img src="/images/2019/14/02.png"></p><p><a name="1-0"></a></p><h3 id="0-유틸리티"><a href="#0-유틸리티" class="headerlink" title="0. 유틸리티"></a>0. 유틸리티</h3><p>함수 호출 하는 방식으로 다른 레이어와 소통한다. 모든 레이어와 소통.</p><p><a name="1-1"></a></p><h3 id="1-베이스-클래스"><a href="#1-베이스-클래스" class="headerlink" title="1. 베이스 클래스"></a>1. 베이스 클래스</h3><p>베이스 클래스와 구상 클래스의 관계는 상속되거나 소유된다.</p><hr><p><a name="1-1-1"></a></p><h4 id="1-1-기반이-되는-3가지-클래스"><a href="#1-1-기반이-되는-3가지-클래스" class="headerlink" title="1.1 기반이 되는 3가지 클래스"></a>1.1 기반이 되는 3가지 클래스</h4><ol><li>모델<br>모델링 한 것, 게임 자체를 모델링한 데이터가 존재함. (entity)</li><li>뷰<br>모델을 그림 그릴 수 있는 로직</li><li>컨트롤러<br>뷰와 대화하거나 해당 모델을 처리할 수 있는 로직이 한꺼번에 들어있음<ul><li>컨트롤러가 여러 개의 모델을 소유하게 될 것이다.</li></ul></li></ol><p>뷰가 인터렉션을 할 때 컨트롤러에게 위임하는데<br>컨트롤러에게 뷰의 책임을 위임하지 않을 것이다.<br>뷰가 컨트롤러에 그냥 위임하게 되면 컨트롤러에 뷰의 사정이 들어가게 된다.<br>(네이티브 분리가 안 된다. ex_ dom을 컨트롤하는 로직 등등..)</p><ul><li><strong>mvc패턴을 날로쓰면 컨트롤러가 반드시 특정 뷰와 강력한 바인딩이 되어서 뷰를 교체할 수 없다.</strong></li><li>강력한 바인딩을 해제하기 위해서는<br>컨트롤러에게는 <strong>순수한 데이터 관련된 요청만 시켜야하고</strong><br>나머지 인터렉션은 뷰가 가져갸아한다.<ul><li>mvp나, mvvm을 쓰면된다.</li></ul></li><li>view에서는 인터렉션 1차 처리를 한다. event listener같은 로직을 넣고,</li><li>컨트롤러에는 순수한 데이터만 보낼 것</li></ul><hr><p><a name="1-1-2"></a></p><h4 id="1-2-뷰와-컨트롤러-사이의-버퍼-메세지"><a href="#1-2-뷰와-컨트롤러-사이의-버퍼-메세지" class="headerlink" title="1.2 뷰와 컨트롤러 사이의 버퍼 = 메세지"></a>1.2 뷰와 컨트롤러 사이의 버퍼 = 메세지</h4><ul><li>뷰가 컨트롤러와 직접 대화하게 되면 뷰의 네이티브 지식을 알아야한다.<br>이것을 방지하기 위해 버퍼를 하나 둔다. (메세지)</li><li>컨트롤러는 메세지만 바라보고 있고,<br>뷰도 메세지만 바라보면서<br>메세지로만 통신한다.</li></ul><p><strong>why?</strong></p><ul><li>네이티브 요소를 완전히 제거해서<br>컨트롤러도 인메모리 객체를,<br>뷰도 인메모리 객체를 바라보게 하기 위해서 중간에 메세지라는 매개체를 둔다.</li></ul><p><strong>메세지는 중립적인 역할</strong></p><ul><li>메세지는 중립적인 역할이자, 인메모리 객체이다.<br>네이티브 지식이 전혀 없다.</li><li>컨트롤러는 이 메세지를 받아들여서 모델과 매핑을 시켜야하고,<br>뷰는 메세지를 받아들여서 네이트브 객체와 매핑을 시켜야한다.</li></ul><hr><p><a name="1-1-3"></a></p><h4 id="1-3-서브-뷰"><a href="#1-3-서브-뷰" class="headerlink" title="1.3 서브 뷰"></a>1.3 서브 뷰</h4><p>뷰도 혼자서 전부 처리하기에 힘들기때문에<br>서브뷰를 만들어서 그림그리는 체계를 나눠준다.  </p><blockquote><p>최종적으로 만들 것은 구상서브뷰와 구상모델을 만들게 된다.</p></blockquote><ul><li>서브뷰의 구상서브뷰와 뷰의 구상뷰를 만들 것이다.<ul><li>구상서브뷰는 <code>div</code>가 될 것이고</li><li>구상뷰는 <code>section</code>뷰가 될 것이다.</li></ul></li><li>모델은 아직 서브 모델이 필요없다.<br>( 블럭의 다른 종류를 만들지 않음._ 추후 폭탄만들때는 필요 )</li></ul><hr><p>베이스 클래스 까지는 인메모리 객체이다.<br>네이티브 지식이 하나도 나오지 않는다. 구상 클래스만 네이티브 지식을 갖게 된다.</p><ul><li>네이티브 지식은 횡으로도 분리하지만 종으로도 분리하게 되는데 이를 레이어링이라고 했다. </li><li>우리가 레이어링을 한 이유는 베이스 클래스에는 순수한 인메모리 객체만 두고, 구상클래스에 네이티브 지식을 두게 하기 위함이다.</li></ul><hr><hr><p><a name="1-2"></a></p><h3 id="2-구상클래스"><a href="#2-구상클래스" class="headerlink" title="2. 구상클래스"></a>2. 구상클래스</h3><ul><li>호스트 클래스는 구상클래스를 인스턴스화 하여 사용한다. </li></ul><ol><li>구상모델</li><li><del>구상컨트롤러</del><ul><li>Game이 바로 컨트롤러 역할을 수행하고 있음</li><li>게임에 있는 하나하나의 블럭이 모델.</li><li>게임이라는 컨트롤러 하나만 있으면 되기 때문에 굳이 없어도됨.</li></ul></li><li>구상뷰</li></ol><hr><hr><p><a name="1-3"></a></p><h3 id="3-호스트코드"><a href="#3-호스트코드" class="headerlink" title="3. 호스트코드"></a>3. 호스트코드</h3><ul><li>구상컨트롤러 생성 및 초기화 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;코드스피츠 강의 정리록&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;생소한 도메인으로 배우는게 좋다.&lt;br&gt;익숙한 도메인들은 익숙한 처리방법으로 처리하기때문에 객체지향을 배우기 어렵다.&lt;br&gt;때문에 80기는 게임을 통해서 진행할 
      
    
    </summary>
    
      <category term="02_WorkShop" scheme="http://feel5ny.github.io/categories/02-WorkShop/"/>
    
      <category term="2019 CodeSpitz" scheme="http://feel5ny.github.io/categories/02-WorkShop/2019-CodeSpitz/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
      <category term="OOP" scheme="http://feel5ny.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>Mac 환경에서 IE디버깅하기. (virtualBox 사용)</title>
    <link href="http://feel5ny.github.io/2019/03/10/debug_01/"/>
    <id>http://feel5ny.github.io/2019/03/10/debug_01/</id>
    <published>2019-03-10T01:20:19.000Z</published>
    <updated>2019-03-10T08:00:13.892Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>개인 삽질 정리록<br>개인이 접한 문제를 해결했던 경험을 바탕으로 적은 글이므로,<br>오류가 있는 부분은 댓글로 부탁드립니다 </p></blockquote><p>맥OS에서 프론트 개발을 하면 종종 IE 디버깅을 해야할때가 있다. ( <del>버리고 싶은 IE 🌎</del> )<br>virtual박스나 가상머신 파일 다운로드 시간이 걸리므로 미리미리 셋팅해두면 좋다.</p><p>여러가지 다른 솔루션이 있겠지만 ( Hyper-V, VirtualBox, Parallels ),<br>이번 글에서는 오라클에서 제공하는 <code>버추얼박스</code>를 활용하여<br>IE 디버깅을 하는 방법에 대해서 간단하게 적어보려고한다.<br>튜토리얼성 글이다.</p><hr><h3 id="TL-DR-짧은-설명"><a href="#TL-DR-짧은-설명" class="headerlink" title="TL;DR 짧은 설명"></a>TL;DR 짧은 설명</h3><ol><li>virtual박스 설치, windowOS 설치</li><li>가상머신 ip주소로 접근</li><li>끝</li></ol><hr><p><a name="1"></a></p><h2 id="1-virtual박스-설치-windowOS-설치"><a href="#1-virtual박스-설치-windowOS-설치" class="headerlink" title="1. virtual박스 설치, windowOS 설치"></a>1. virtual박스 설치, windowOS 설치</h2><p>virtual박스는 오라클에서 만든 가상머신 솔루션이다.</p><h3 id="1-1-virtual-machine이란"><a href="#1-1-virtual-machine이란" class="headerlink" title="1.1 virtual machine이란?"></a>1.1 virtual machine이란?</h3><p>하드웨어를 소프트웨어적으로 구현해서<br>그 위에서 운영체제가 작동하도록하는 기술이다. (<a href="https://opentutorials.org/course/173" target="_blank" rel="noopener">출처</a>)</p><hr><h3 id="1-2-virtualBox-설치-windowOS-설치"><a href="#1-2-virtualBox-설치-windowOS-설치" class="headerlink" title="1.2 virtualBox 설치, windowOS 설치"></a>1.2 virtualBox 설치, windowOS 설치</h3><p>설치는 간단하다 -! 시간만 걸릴뿐..</p><h4 id="1-2-1-버추얼박스-설치-링크"><a href="#1-2-1-버추얼박스-설치-링크" class="headerlink" title="1.2.1 버추얼박스 설치 (링크)"></a>1.2.1 버추얼박스 설치 (<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">링크</a>)</h4><p><img src="/images/2019/13/01.png"></p><ul><li>본인의 OS에 맞는 것을 설치하면 된다.</li><li>우리는 mac에서 개발하고 있으니 OS X hosts</li></ul><h4 id="1-2-2-버추얼머신-설치-링크"><a href="#1-2-2-버추얼머신-설치-링크" class="headerlink" title="1.2.2 버추얼머신 설치 (링크)"></a>1.2.2 버추얼머신 설치 (<a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/" target="_blank" rel="noopener">링크</a>)</h4><p><img src="/images/2019/13/02.png"></p><ul><li>원하는 가상머신 다운로드 후 설치한다.</li><li>다운로드 파일 실행시키면 자동으로 셋팅이 된다.</li></ul><hr><p><a name="2"></a></p><h2 id="2-가상머신-ip주소-확인"><a href="#2-가상머신-ip주소-확인" class="headerlink" title="2. 가상머신 ip주소 확인"></a>2. 가상머신 ip주소 확인</h2><p>가상머신이 실행되고 우리가 설치한 windowOS가 실행된다.</p><p><img src="/images/2019/13/03.png"></p><h3 id="ip주소를-파악한다"><a href="#ip주소를-파악한다" class="headerlink" title="ip주소를 파악한다."></a>ip주소를 파악한다.</h3><p>터미널에서(command prompt) <code>ipconfig</code>를 입력하면 정보가 나온다.<br><code>Default GateWay</code>의 ip주소를 localhost처럼 사용하면 된다.</p><h3 id="끝"><a href="#끝" class="headerlink" title="끝.."></a>끝..</h3><p>단점: 느리닷!</p><p><img src="/images/2019/13/04.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;개인 삽질 정리록&lt;br&gt;개인이 접한 문제를 해결했던 경험을 바탕으로 적은 글이므로,&lt;br&gt;오류가 있는 부분은 댓글로 부탁드립니다 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;맥OS에서 프론트 개발을 하면 종종 IE 디버깅을 해야
      
    
    </summary>
    
      <category term="01_DevTIL ✍" scheme="http://feel5ny.github.io/categories/01-DevTIL-%E2%9C%8D/"/>
    
      <category term="0_DevLog 👻" scheme="http://feel5ny.github.io/categories/01-DevTIL-%E2%9C%8D/0-DevLog-%F0%9F%91%BB/"/>
    
    
      <category term="web" scheme="http://feel5ny.github.io/tags/web/"/>
    
      <category term="debug" scheme="http://feel5ny.github.io/tags/debug/"/>
    
      <category term="IE" scheme="http://feel5ny.github.io/tags/IE/"/>
    
  </entry>
  
  <entry>
    <title>코드스피츠80_OOP design with game (1)- 2. OOAD &amp; 프로시저 P</title>
    <link href="http://feel5ny.github.io/2019/02/23/OOP_08_2/"/>
    <id>http://feel5ny.github.io/2019/02/23/OOP_08_2/</id>
    <published>2019-02-23T01:20:19.000Z</published>
    <updated>2019-03-17T15:49:59.563Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>코드스피츠 강의 정리록</p></blockquote><p>생소한 도메인으로 배우는게 좋다.<br>익숙한 도메인들은 익숙한 처리방법으로 처리하기때문에 객체지향을 배우기 어렵다.<br>때문에 80기는 게임을 통해서 진행할 예정.</p><hr><p>객체지향 프로그래밍을 배우기 전,<br><strong>프로시저 프로그래밍</strong> 형태의 코드를 알아본다.</p><p><a name="2"></a></p><h1 id="2-게임-개요-및-규칙"><a href="#2-게임-개요-및-규칙" class="headerlink" title="2. 게임 개요 및 규칙"></a>2. 게임 개요 및 규칙</h1><p><img src="/images/2019/12/01.png"></p><p><a name="2-1"></a></p><h2 id="2-1-앤티티-파악"><a href="#2-1-앤티티-파악" class="headerlink" title="2.1 앤티티 파악"></a>2.1 앤티티 파악</h2><p>아키텍트나 디자인패턴을 만드는 설계자들은<br>현상을 보고, 현상으로부터 프로그램 엔티티를 도출해서 설계를 들어간다.</p><ul><li>블럭에는 타입이 있구나.</li><li>블럭 connect의 최저 갯수 제한이 있겠구나.</li><li>스테이지의 가로 세로 갯수</li><li>선택했던 블럭들을 돌아갈 수 있다.</li><li><p>새로운 블록이 떨어진다.</p><blockquote><p>인지과학<br>  가상세계임에도 불구하고 물리력가 중력을 기대한다 ㅋ</p></blockquote></li></ul><p><a name="2-2"></a></p><h2 id="2-2-규칙"><a href="#2-2-규칙" class="headerlink" title="2.2 규칙"></a>2.2 규칙</h2><p><a name="2-2-1"></a></p><h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><ul><li>블럭타입: 5가지 (0,1,2,3,4)</li><li>cell size: 8*8</li></ul><p><a name="2-2-2"></a></p><h3 id="Core-Action"><a href="#Core-Action" class="headerlink" title="Core Action"></a>Core Action</h3><p><img src="/images/2019/12/02.png"></p><ol><li>한번에 3개 이상 같은 색으로 인접한 블록이 선택되면 </li><li>삭제됨</li><li>삭제되면 위의 블록이 내려옴.</li><li>내려온 뒤</li><li>공간의 블록이 생성되어 채워짐</li></ol><blockquote><p>cf__1 <strong>게임이야기</strong> ~<br>모바일시대에서는 복잡한 core action이 많이 들어간 게임은 상품성이 없다. (안좋은 예: 와우)<br>core action이 단순한 게임이 상품성이 좋다. 최근 rpg게임들은 단순하게 변했다. 한붓그리기도 이미 오래전에 누가 찾아낸 코어액션중에 하나이다. 재밌는 반복거리를 찾아내면 벗어나려고 하지 않는다.</p></blockquote><hr><hr><p><a name="3"></a></p><h1 id="3-어디서부터-시작할까"><a href="#3-어디서부터-시작할까" class="headerlink" title="3. 어디서부터 시작할까?"></a>3. 어디서부터 시작할까?</h1><h2 id="프로그램의-핵심은-데이터"><a href="#프로그램의-핵심은-데이터" class="headerlink" title="프로그램의 핵심은 데이터"></a>프로그램의 핵심은 데이터</h2><p>사람은 표면적인 것만 파악하려고 한다.</p><ul><li>표면적인 것과 시각적인 것</li><li>경험에 의존에 의해서 파악하기 때문에 경험한 것만 보인다.</li></ul><p>프로그램의 핵심은 데이터이다.</p><ul><li>거의 대부분의 프로그램들은 다 예쁜 데이터 view.</li><li>개발자의 눈으로 보면 프로그램의 핵심은 데이터이다. </li></ul><h2 id="entity의-종류를-미리-파악하자-👀"><a href="#entity의-종류를-미리-파악하자-👀" class="headerlink" title="entity의 종류를 미리 파악하자. 👀"></a>entity의 종류를 미리 파악하자. 👀</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">column = <span class="number">8</span>;</span><br><span class="line">row = <span class="number">8</span>;</span><br><span class="line">blockTypes = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">Block = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;&#125;;</span><br><span class="line">  isNext()&#123;&#125;;</span><br><span class="line">  isValid()&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="현실세계-entity에는-이-3가지-이외에는-발견하기-힘들다"><a href="#현실세계-entity에는-이-3가지-이외에는-발견하기-힘들다" class="headerlink" title="현실세계 entity에는 이 3가지 이외에는 발견하기 힘들다."></a>현실세계 entity에는 이 3가지 이외에는 발견하기 힘들다.</h3><ol><li>스칼라 값<ul><li>설정에 따라 자유롭게 크기를 변경할 수 있음.</li><li>단일 값 </li><li>가변적</li><li>(한번에 하나의 값만 보유할 수 있는 원자량 <a href="https://ko.wikipedia.org/wiki/%EC%8A%A4%EC%B9%BC%EB%9D%BC" target="_blank" rel="noopener">from wiki</a>)</li></ul></li><li>정의값<ul><li>미리 정해진 타입이 존재한다.</li><li>bolckTypes는 콜렉션 개념이 아니다.<br>집합을 정의한 개념이다. 하나의 값인것처럼.</li></ul></li><li>객체값<ul><li>생성되거나 삭제되고, 연결되거나 조건을 파악한다.</li><li>블록을 객체로 보는 이유는 <strong>블록이 자신만의 책임을 위임할 수 있기 때문</strong>이다.<ul><li>다음번에 올 수 있는 블록이니?</li><li>올바른 위치인 상태이니?</li><li>자신의 상태를 은닉하고 캡슐화</li></ul></li><li>블록에는 자신만의 책임을 가질 수 있기 때문에 객체로 평가하게 된다.</li></ul></li></ol><blockquote><p>UML을 깊이 공부하면 5가지 종류의 여러가지 entity과 관계가 나온다.</p></blockquote><hr><h3 id="cf-2-클래스이냐-싱글톤-객체이냐-를-항상-고민한다"><a href="#cf-2-클래스이냐-싱글톤-객체이냐-를-항상-고민한다" class="headerlink" title="cf__2. 클래스이냐? 싱글톤 객체이냐?를 항상 고민한다."></a>cf__2. 클래스이냐? 싱글톤 객체이냐?를 항상 고민한다.</h3><blockquote><p>싱글톤 객체<br>  애플리케이션이 시작될 때 어떤 클래스가 최초 한번만 메모리를 할당하고(Static) 그 메모리에 인스턴스를 만들어 사용하는 디자인패턴.<br>  생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나고<br>  최초 생성 이후에 호출된 생성자는 최초에 생성한 객체를 반환한다.<br>  싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴이다.</p></blockquote><ul><li>객체는 하나만 있거나 여러개 있다.<br>하나만 있는 것인지 여러개 있는 것인지 파악해야한다.</li><li>하나만 있는데 클래스로 정의하거나<br>여러개 있는 것인데 객체로 만들면 반드시 고우투헬..<ul><li>여러개 있는 것을 개별적으로 만들면,<br>여러개 있는 애들은 보통 변화를 한꺼번에 일으켜야하는데<br>개별적으로 만들었기 때문에 한꺼번에 수정할 수 없게 된다. </li><li>하나만 있어야 하는데 클래스로 만들면<br>인스턴스가 여러개 생길 수 있다.</li></ul></li></ul><hr><hr><p><a name="3-1"></a></p><h2 id="3-1-객체-Block"><a href="#3-1-객체-Block" class="headerlink" title="3.1 [객체] Block"></a>3.1 [객체] Block</h2><ol><li>클래스? 혹은 싱글톤 객체?<ul><li>블록은 여러개 생성되므로 <strong>클래스</strong></li></ul></li><li>책임</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Block = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(type)&#123;</span><br><span class="line">    <span class="keyword">this</span>._type = type;</span><br><span class="line">  &#125;</span><br><span class="line">  get image()&#123;<span class="keyword">return</span> <span class="string">`url('img/<span class="subst">$&#123;<span class="keyword">this</span>._type&#125;</span>.png')`</span>;&#125;</span><br><span class="line">  get type()&#123;<span class="keyword">return</span> <span class="keyword">this</span>._type;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Block.GET = <span class="function">(<span class="params">type = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random(</span>)*5)) =&gt;</span> <span class="keyword">new</span> Block(type);</span><br></pre></td></tr></table></figure><ol><li>자신만의 <strong>타입</strong>을 갖는다.<ul><li><code>parseInt(Math.random()*5)</code>: 0 ~ 4 사이의 타입을 얻게됨</li><li><strong>인자에 초기화 코드를 명시해주면<br>선언과 코드의 내용을 분리할 수 있어서 가독성이 좋아진다.</strong></li></ul></li><li>타입에 따른 <strong>이미지 경로</strong>를 반환한다.<br>(타입에 따른 블록 이미지가 다르니까.. )</li></ol><h3 id="왜-factory-함수로-Block-GET"><a href="#왜-factory-함수로-Block-GET" class="headerlink" title="왜 factory 함수로? (Block.GET)"></a>왜 factory 함수로? (<code>Block.GET</code>)</h3><ul><li>Block 클래스는 <strong>받아온 type을 자기 타입으로 기억하는데</strong>만 관심 있다. </li><li>타입을 전달하지 않았을 때 어떻게 만드는지는<br><strong>엄밀하게 따지면 블럭의 지식은 아니다.</strong><ul><li>블럭을 만드는 쪽이 관심 있다.<ul><li>만드는 쪽이 관심있는 것과<br>만들어 지는 쪽이 관심있는 것이 다르다. </li></ul></li><li>랜덤함수는 팩토리 함수가 가져야할 지식이다.</li></ul></li></ul><h3 id="팩토리-함수는-클래스-내부로-가면-안된다"><a href="#팩토리-함수는-클래스-내부로-가면-안된다" class="headerlink" title="팩토리 함수는 클래스 내부로 가면 안된다."></a>팩토리 함수는 클래스 내부로 가면 안된다.</h3><ul><li><strong>변화율</strong>때문에!</li><li>타입은 stage마다 바뀔꺼고, 아이템 추가되면 더 바뀔 것이다.</li><li>타입은 변화율이 높은 개념이므로 클래스와 분리하여 명확한 의도를 작성하게 한다.</li></ul><blockquote><p><strong>변화율을 평가하는 가장 쉬운 방법</strong><br>  변화율을 잘 디자인 했으면 책임이 없다고 생각됬던 객체는 수정되지 않아야한다.<br>  우리의 목표는 보다 더 많은 파일을 안건드리고<br>  <strong>일부파일만 건드려야한다.</strong></p></blockquote><hr><h4 id="cf-3-Factory-함수"><a href="#cf-3-Factory-함수" class="headerlink" title="cf__3. Factory 함수"></a>cf__3. Factory 함수</h4><p>객체지향할 때 클래스를 사용하는 경우 생성자를 봉인하자.<br><strong>factory함수로 클래스를 얻어가게 하자.</strong></p><ul><li><code>static</code> 키워드 써서 불러오게 해도됨.</li><li>factory 함수의 명칭은 일관되게 모든 클래스에 생성자를 대신하는 스태틱 함수를 만들자.<br>(예제에서는 <code>GET</code>)<blockquote><p>팩토리 함수 : 객체를 반환하는 함수</p></blockquote></li></ul><hr><h4 id="cf-4-단일-책임원칙-훈련하기"><a href="#cf-4-단일-책임원칙-훈련하기" class="headerlink" title="cf__4. 단일 책임원칙 훈련하기"></a>cf__4. <strong>단일 책임원칙 훈련하기</strong></h4><p>단일 책임원칙은 엄밀하게 지키려면 굉장히 어렵고,<br>섬세하게 바라보는 눈으로<br>언제나 의심해서 관리하지 않으면 실력..키워지지 않는다.<br>(빠르면 3년 늦으면 5년..ㅎ)</p><hr><p><a name="3-2"></a></p><h2 id="3-2-객체-Game"><a href="#3-2-객체-Game" class="headerlink" title="3.2 [객체] Game"></a>3.2 [객체] Game</h2><p>게임이라는 객체는 블록들을 소유하는 마스터 객체</p><ol><li>클래스이냐? 싱글톤 객체이냐?<br>게임은 하나의 객체만 있으면 된다. (바둑판 하나.)<br>구지 클래스로 선언하지 않고, 싱글톤 객체로 만든다.<br>=&gt; 싱글톤 객체</li><li><p>책임<br>2번과 3번은 내부에서만 알면된다.</p><ol><li>초기화<br>필요한 정보를 바탕으로 게임 본체를 생성</li><li>렌더링<br>그림 갱신</li><li>이벤트 걸기<br>각 블록에서 이벤트를 처리</li></ol></li><li><p>외부에서 게임의 어떤 상태만 알면 될까?</p><ul><li>게임 초기화<br>함수만 하나 노출하면 됨</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 게임은 초기화된 게임이 바로 생성되어야 하므로, 즉시실행함수로.</span></span><br><span class="line"><span class="keyword">const</span> Game = (<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> init = ...</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> init;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><hr><p><a name="4"></a></p><h1 id="4-Game-시나리오"><a href="#4-Game-시나리오" class="headerlink" title="4. Game 시나리오"></a>4. Game 시나리오</h1><ol><li>테이블 형태 정의</li><li>테이블 생성</li><li>테이블 내에 블록 데이터 채우기 (data)<br>2차원배열을 만들어야하기때문에<br>row와 column을 돌면서 생성한다.</li><li>렌더링<ul><li>data는 inMemory 객체</li><li>render를 따로 호출하는 것은 네이티브 객체이기때문에(dom의 세상..)</li></ul></li><li>렌더링 전 table에 이벤트 걸기.</li></ol><hr><p><a name="4-1"></a></p><h3 id="1-2-3-객체-스칼라값-정의값-테이블-데이터-정의"><a href="#1-2-3-객체-스칼라값-정의값-테이블-데이터-정의" class="headerlink" title="1. + 2. + 3. [객체, 스칼라값, 정의값] 테이블 데이터 정의"></a>1. + 2. + 3. [객체, 스칼라값, 정의값] 테이블 데이터 정의</h3><ol><li>테이블 형태 정의</li><li>테이블 생성</li><li>테이블 내에 블록 데이터 채우기 (data)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Game = (<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> column = <span class="number">8</span>, row = <span class="number">8</span>, blockSize = <span class="number">80</span>;</span><br><span class="line">  <span class="keyword">const</span> data = [];</span><br><span class="line">  <span class="keyword">let</span> table;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> init = <span class="function"><span class="params">tid</span> =&gt;</span> &#123;</span><br><span class="line">    table = <span class="built_in">document</span>.querySelector(tid);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">      <span class="keyword">const</span> r = [];</span><br><span class="line">      data.push(r);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; column; j++) r[j] = Block.GET();</span><br><span class="line">    &#125;</span><br><span class="line">    render();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> render = <span class="function"><span class="params">_</span> =&gt;</span> &#123;...&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><p><a name="4-4"></a></p><h3 id="4-렌더링"><a href="#4-렌더링" class="headerlink" title="4. 렌더링"></a>4. 렌더링</h3><p>데이터를 소비해서<br>표를 다시 그려주는 로직.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Game = (<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> column = <span class="number">8</span>, row = <span class="number">8</span>, blockSize = <span class="number">80</span>;</span><br><span class="line">  <span class="keyword">const</span> data = [];</span><br><span class="line">  <span class="keyword">let</span> table;</span><br><span class="line">  <span class="keyword">const</span> init = <span class="function"><span class="params">tid</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    render();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  👇👇👇</span><br><span class="line">  <span class="keyword">const</span> el = <span class="function"><span class="params">tag</span> =&gt;</span> <span class="built_in">document</span>.createElement(tag);</span><br><span class="line">  <span class="keyword">const</span> render = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    table.innerHTML = <span class="string">''</span>;</span><br><span class="line">    data.forEach(<span class="function"><span class="params">row</span> =&gt;</span> table.appendChild(</span><br><span class="line">      row.reduce(<span class="function">(<span class="params">tr, block</span>) =&gt;</span> &#123;</span><br><span class="line">        tr.appendChild(el(<span class="string">'td'</span>)).style.cssText = <span class="string">`</span></span><br><span class="line"><span class="string">          <span class="subst">$&#123;block? <span class="string">`background: <span class="subst">$&#123;block.image&#125;</span>;`</span> : <span class="string">''</span>&#125;</span></span></span><br><span class="line"><span class="string">          width: <span class="subst">$&#123;blockSize&#125;</span>px;</span></span><br><span class="line"><span class="string">          height: <span class="subst">$&#123;blockSize&#125;</span>px</span></span><br><span class="line"><span class="string">          cursor: pointer`</span>;</span><br><span class="line">        <span class="keyword">return</span> tr;</span><br><span class="line">      &#125;, el(<span class="string">'tr'</span>))</span><br><span class="line">    ));</span><br><span class="line">  &#125;;</span><br><span class="line">  👆👆👆</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>배열을 루프돌아서<br>각각의 줄을 td를 갖는 tr로 바꿔서<br>table에 넣고 싶음.</p><ul><li>td를 갖는 tr로<br><img src="/images/2019/12/04.png" style="width:20rem;"></li><li>각각의 줄을 (td를 갖는) tr로 바꿔서<br><img src="/images/2019/12/03.png" style="width:20rem;"></li></ul><hr><h5 id="cf-5-배열의-고차함수"><a href="#cf-5-배열의-고차함수" class="headerlink" title="cf__5. 배열의 고차함수"></a>cf__5. 배열의 고차함수</h5><p>배열의 고차함수를 쓰는 원리는 간단하다.</p><ul><li>루프돌고 싶으면 <code>forEach</code></li><li>배열의 원소를 바꾼 배열을 얻고 싶으면 <code>map</code></li><li>하나의 값으로 뭉치고 싶으면 <code>reduce</code><blockquote><p>여러개의 집합을 하나의 스칼라값으로 바꾸는 것</p></blockquote></li></ul><hr><p><a name="4-5"></a></p><h3 id="5-table에-이벤트-걸기"><a href="#5-table에-이벤트-걸기" class="headerlink" title="5. table에 이벤트 걸기."></a>5. table에 이벤트 걸기.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Game = (<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> column = <span class="number">8</span>, row = <span class="number">8</span>, blockSize = <span class="number">80</span>;</span><br><span class="line">  <span class="keyword">const</span> data = [];</span><br><span class="line">  <span class="keyword">let</span> table;</span><br><span class="line">  <span class="keyword">const</span> init = <span class="function"><span class="params">tid</span> =&gt;</span> &#123;</span><br><span class="line">    table = <span class="built_in">document</span>.querySelector(tid);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">      <span class="keyword">const</span> r = [];</span><br><span class="line">      data.push(r);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; column; j++) r[j] = Block.GET();</span><br><span class="line">    &#125;</span><br><span class="line">    👇👇👇</span><br><span class="line">    table.addEventListener(<span class="string">'mousedown'</span>, down);</span><br><span class="line">    table.addEventListener(<span class="string">'mouseup'</span>, up);</span><br><span class="line">    table.addEventListener(<span class="string">'mouseleave'</span>, up);</span><br><span class="line">    table.addEventListener(<span class="string">'mousemove'</span>, move);</span><br><span class="line">    👆👆👆</span><br><span class="line">    render();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="function"><span class="params">tag</span> =&gt;</span> <span class="built_in">document</span>.createElement(tag);</span><br><span class="line">  <span class="keyword">const</span> render = <span class="function"><span class="params">_</span> =&gt;</span> &#123;...&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>mousedown<ul><li>마우스를 누르는 그 순간. (click과 다르게 press하는 순간)</li></ul></li><li>mouseup<ul><li>손가락을 떼는 그 순간.</li></ul></li><li>mouseleave<ul><li>바인딩된 요소에만 이벤트가 발생하며, 해당 엘리먼트의 영역에서 마우스가 벗어날 때 발생한다.</li></ul></li><li>mousemove<ul><li>마우스가 엘리먼트에서 움직일 때 </li></ul></li></ul><hr><p><a name="4-5-1"></a></p><h3 id="5-1-이벤트-gt-블럭을-누르는-순간-down"><a href="#5-1-이벤트-gt-블럭을-누르는-순간-down" class="headerlink" title="5.1 이벤트 &gt; 블럭을 누르는 순간: down"></a>5.1 이벤트 &gt; 블럭을 누르는 순간: down</h3><ol><li><p>move는 mousedown인 상태여야 의미가 있다.<br><strong>down의 상태값</strong> 필요</p></li><li><p>현재 눌러진 블록의 위치값 알아야함.<br>event로부터 x,y값 전체좌표를 받아와서<br>x, y좌표를 이용해서 테이블 내에서 몇번째 블록인지, 데이터로 치환하게 된다.</p><p>현재 눌러진 블록이 첫 시작? 아니면 중간?</p><ol><li>시작 블록<ul><li>지금 선택이 시작되는 블록</li><li>라이언타입이면 계속 라이언 타입</li><li>시작값은 왜 알아야하지?<ul><li>돌아가기도 해야함.</li></ul></li></ul></li><li>현재 블록<ul><li>move할때마다 변함 (cursor와 같은)</li></ul></li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> down = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// down된 상태를 활성</span></span><br><span class="line">  <span class="comment">// x, y로부터 block 데이터를 얻음</span></span><br><span class="line">  <span class="comment">// 위에서 얻은 블록을 시작블록 및 현재 블록으로 설정하고 선택목록에 포함시킴.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>down의 상태값<ul><li>down이 아닐때만 down.</li></ul></li><li>어떤 블록이 선택되어있는지.</li><li>x,y값을 넣으면 몇번째인지 알아낼 수 있는 함수</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> column = <span class="number">8</span>, row = <span class="number">8</span>, blockSize = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">const</span> data = [];</span><br><span class="line"><span class="keyword">let</span> table;</span><br><span class="line">👇👇👇</span><br><span class="line"><span class="keyword">let</span> startBlock, currBlock, isDown;</span><br><span class="line"><span class="keyword">const</span> selected = [], getBlock = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> down = <span class="function">(<span class="params">&#123;pageX: x, pageY: y&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(isDown) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> curr = getBlock(x,y);</span><br><span class="line">  <span class="keyword">if</span>(!curr) <span class="keyword">return</span>;</span><br><span class="line">  isDown = <span class="literal">true</span>;</span><br><span class="line">  selected.length = <span class="number">0</span>;</span><br><span class="line">  selected[<span class="number">0</span>] = startBlock = currBlock = curr;</span><br><span class="line">  render();</span><br><span class="line">&#125;</span><br><span class="line">👆👆👆</span><br></pre></td></tr></table></figure><p>getBlock이외의 밑에나오는 로직은 전부 인메모리 로직.<br>네이티브 레이어를 다루는 방법은 즉시 인메모리 객체로 변환한다. </p><hr><h5 id="cf-6-네이티브-객체를-다룰때-가장-중요한-요령"><a href="#cf-6-네이티브-객체를-다룰때-가장-중요한-요령" class="headerlink" title="cf__6. 네이티브 객체를 다룰때 가장 중요한 요령"></a>cf__6. 네이티브 객체를 다룰때 가장 중요한 요령</h5><ul><li><strong>네이티브 레이어를 최대한 줄이는 것.</strong></li><li>네이티브의 정보 중에 필요한 핵심정보만 이용해서 즉시 인메모리 객체로 바꿈.</li><li>네이티브의 코드가 많이 퍼져있으면 퍼져있을수록<br>더욱더 다루기 어렵고<br>더욱더 컨버팅하기 어렵게 된다.</li><li>네이티브 코드중에 필요한 부분만 추출해서 =&gt; 즉시 인메모리 객체로 바꾸고</li><li>나머지 로직은 인메모리에서 수용하도록 함.</li></ul><blockquote><p>좋은 개발자<br>말하면 코드로 옮기는 것이 리얼타임이 될때까지.. 훈련하자.<br>좋은 개발자는 제어문을 잘쓰거나, 코드를 한국어로 번역하거나 한국어를 코드로 번역하는 능력에 달려있다.<br>숙련을 많이 해서 실시간으로.</p></blockquote><hr><h4 id="5-cf-네이티브-코드-gt-인메모리-객체로-변환"><a href="#5-cf-네이티브-코드-gt-인메모리-객체로-변환" class="headerlink" title="5.cf 네이티브 코드 =&gt; 인메모리 객체로 변환"></a>5.cf 네이티브 코드 =&gt; 인메모리 객체로 변환</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 네이티브 객체의 값을 =&gt; 인메모리 객체로 변환해주는 변환기 !</span></span><br><span class="line"><span class="comment">// 많이 나옴.</span></span><br><span class="line"><span class="keyword">const</span> getBlock = (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="function"><span class="params">Block</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; top: T, left: L &#125; = table.getBoundingClientRect();</span><br><span class="line">  <span class="keyword">if</span> (x &lt; L || x &gt; L + blockSize * row || y &lt; T || y &gt; T + blockSize * column)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 바둑판 범위를 넘는 경우 제외(왼쪽넘어, 오른쪽넘어, 위쪽넘어, 아래쪽 넘어)</span></span><br><span class="line">  <span class="keyword">return</span> data[<span class="built_in">parseInt</span>(y - T) / blockSize][<span class="built_in">parseInt</span>(x - L) / blockSize];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>getBoundingClientRect</code><br>Element.getBoundingClientRect() 메서드는<br>요소의 크기와 요소의 viewport에서의 상대적인 위치를 반환합니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DOMRect </span><br><span class="line">&#123; x: 0, </span><br><span class="line">  y: 0, </span><br><span class="line">  width: 0, </span><br><span class="line">  height: 0, </span><br><span class="line">  top: 0, </span><br><span class="line">  bottom: 0, </span><br><span class="line">  left: 0, </span><br><span class="line">  right: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><hr><p><a name="4-5-2"></a></p><h3 id="5-2-이벤트-gt-블럭을-떼는-순간-up"><a href="#5-2-이벤트-gt-블럭을-떼는-순간-up" class="headerlink" title="5.2 이벤트 &gt; 블럭을 떼는 순간: up"></a>5.2 이벤트 &gt; 블럭을 떼는 순간: up</h3><p>코어액션이 여기서 다 일어난다.</p><ol><li>down을 해제</li><li>선택목록이 3이상이면 삭제 실시</li><li>2이하면 리셋</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> up = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// down을 해제</span></span><br><span class="line">  <span class="comment">// 선택목록이 3이상이면 삭제 실시</span></span><br><span class="line">  <span class="comment">// 2이하면 리셋</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-0-reset"><a href="#5-2-0-reset" class="headerlink" title="5.2.0 reset"></a>5.2.0 reset</h4><p>선택항목이 2이하면 모두 초기화시킨다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> up = <span class="function"><span class="params">_</span> =&gt;</span> selected.length &gt; <span class="number">2</span> ? remove() : reset();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reset = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  startBlock = currBlock = <span class="literal">null</span>;</span><br><span class="line">  selected.length = <span class="number">0</span>;</span><br><span class="line">  isDown = <span class="literal">false</span>;</span><br><span class="line">  render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h5 id="cf-7-쉬운것부터-짜자"><a href="#cf-7-쉬운것부터-짜자" class="headerlink" title="cf__7. 쉬운것부터 짜자!"></a>cf__7. 쉬운것부터 짜자!</h5><p>쉬운 것은 의존성이 없다. 고칠 일이 적다.<br>복잡한 것부터 짜면 의존성이 많은 것부터 짜게 되고,<br>나중에 깨달은게 많을수록 더 많이 고치게 된다.</p><hr><ol><li>선택된 블록들을 지워주고 =&gt; remove</li><li>떨어뜨린 다음에 =&gt; drop</li><li>새로 생성하고 =&gt; readyToFill</li><li>다시 내려와주면서, 합쳐줘야함. =&gt; fill </li></ol><p><a name="4-5-2-1"></a></p><h4 id="5-2-1-remove-😫😫"><a href="#5-2-1-remove-😫😫" class="headerlink" title="5.2.1 remove 😫😫"></a>5.2.1 remove 😫😫</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> remove = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 데이터 내부의 row를 돌면서</span></span><br><span class="line"><span class="comment">    해당 row에 선택된 요소가 존재하면 null로 만드는 함수.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  data.forEach(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">    selected.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> i;</span><br><span class="line">      <span class="keyword">if</span> ((i = r.indexOf(v)) !== <span class="number">-1</span>) r[i] = <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  render();</span><br><span class="line">  setTimeout(drop, <span class="number">300</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>forEach는 for문보다 대화가됨.</p></blockquote><p>column을 돌면서 row를 계산해서 떨어뜨리는 일을 한다.<br>한턴에는 한칸씩 떨어진다.<br>중력에 의해 떨어지는 방향은<br>column기준이기때문에 column을 먼저 loop돌린다.<br>row는 맨 아랫줄부터 떨어지는 작업을 해야하므로.. (전체row -1) 부터 시작</p><ul><li>isNext: 윗줄에도 block이 있는 상황이라 다음 row도 검사해야하는지.</li><li>isEmpty: 떨어질 블럭이 하나의 column row들에 있는지 없는지.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> drop = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> isNext = <span class="literal">false</span>; <span class="comment">// drop을 더 해야하는지 말아야하는지.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; column; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = row - <span class="number">1</span>; i &gt; <span class="number">-1</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!data[i][j] &amp;&amp; i) &#123; <span class="comment">// 해당 구멍에 블럭이 없고, row의 인덱스가 0이 아닌(꼭대기가 아닌)</span></span><br><span class="line">        <span class="keyword">let</span> k = i, <span class="comment">// 해당 줄의 index를 복사한다.</span></span><br><span class="line">          isEmpty = <span class="literal">true</span>; <span class="comment">// data[i][j] 위에 떨어질 블럭이 비었는지 아닌지.</span></span><br><span class="line">        <span class="keyword">while</span> (k--) <span class="comment">// index를 하나씩 확인하면서</span></span><br><span class="line">          <span class="keyword">if</span> (data[k][j]) &#123; <span class="comment">// 위에 블럭이 있으면</span></span><br><span class="line">            isEmpty = <span class="literal">false</span>; <span class="comment">// 위에 떨어질 블럭이 하나라도 있다는 뜻</span></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 반복분을 끝낸다.</span></span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty) <span class="keyword">break</span>; <span class="comment">// 위에 떨어질 블럭이 하나도 없으면 row loop 종료 다음 column loop 시작</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 위에 블럭이 하나라도 있는 상황이고, </span></span><br><span class="line">        <span class="comment">// 다음 row도 검새햐아함을 flag</span></span><br><span class="line">        isNext = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 떨어뜨리기.</span></span><br><span class="line">        <span class="keyword">while</span> (i--) &#123; <span class="comment">// 해당 줄 위에</span></span><br><span class="line">          data[i + <span class="number">1</span>][j] = data[i][j]; <span class="comment">// 현재 검사한 블럭에 위의 블럭을 넣어주고,</span></span><br><span class="line">          data[i][j] = <span class="literal">null</span>; <span class="comment">// 위의 블럭은 null로 초기화</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// row loop를 종료 다음 column loop 시작</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render();</span><br><span class="line">  isNext ? setTmeout(drop, <span class="number">300</span>) : readyToFill();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>ㅋㅋㅋ ㅠㅠ 대댜냐댜..<br>머리가 좋아지는수밖에 없다.<br>잘짜고, 쉽게 짤때까지 머리로 훈련하는 수밖에 없다.<br>알고리즘, 코딩인터뷰, 자료구조, 트리구조 보다 도메인 해석 능력을 키우자.<br>어떠한 도메인에 대해서 알고리즘을 짜는 능력은 훈련밖에 없다.<br>복잡한 일이 일어나는 것을 눈으로 관찰해서 어떤 일인지 파악한 다음에<br>코드로 차근차근 푸는건 훈련밖에 없다.<br>이거 안되면 아키텍처고 디자인패턴이고 필요없다..</p></blockquote><hr><p>채울준비를 하는 것은 밖에부터 채워야하는 애들이 예쁘게 내려오게 하기 위해서.</p><ol><li>지워진 모양 그대로의 형태가 위에 형성되고 =&gt; readyToFill</li><li>해당 형태가 떨어지는 상황 =&gt; fill</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fills = [];</span><br><span class="line"><span class="comment">// fill 배열 초기화</span></span><br><span class="line"><span class="comment">// column은 똑같고, row만 계산해서 생성하면 됨.</span></span><br><span class="line"><span class="comment">// 실제 fills의 길이와 채워진 카운팅이 같게되면 다 채워졌다고 볼 예정 </span></span><br><span class="line"><span class="keyword">let</span> fillCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readyToFill = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  fills.length = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// data를 돌면서 구멍난 부분을 찾는다.</span></span><br><span class="line">  data.some(<span class="function"><span class="params">row</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row.indexOf(<span class="literal">null</span>) === <span class="number">-1</span>) <span class="keyword">return</span> ture; <span class="comment">// 구멍없는 row면 끝냄.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> r = [...row].fill(<span class="literal">null</span>); <span class="comment">// 새로운 row를 만들어서 우선 null로 채움</span></span><br><span class="line">    fills.push(r);</span><br><span class="line">    row.forEach(<span class="function">(<span class="params">v, i</span>) =&gt;</span> !v &amp;&amp; (r[i] = Block.GET())); </span><br><span class="line">    <span class="comment">// v가 없으면 해당 구멍에 block으로 채움 </span></span><br><span class="line">  &#125;);</span><br><span class="line">  fillCnt = <span class="number">0</span>; <span class="comment">// ?</span></span><br><span class="line">  setTimeout(fill, <span class="number">300</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fill = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (fillCnt &gt; fills.length) &#123; </span><br><span class="line">    <span class="comment">// fillCnt가 증가하다가 fills의 length와 일치하면 그만둘 때 </span></span><br><span class="line">    isDown = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fillCnt; i++) &#123;</span><br><span class="line">    <span class="comment">// 채워야하는 fill 배열의 row에서 해당 요소가 null이 아니라 채워져있으면(v), </span></span><br><span class="line">    <span class="comment">// data의 해당 요소에 v를 넣는다.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fills에 있는 마지막줄부터 윗줄을 채워가면 된다..</span></span><br><span class="line">    fills[fills.length - i - <span class="number">1</span>].forEach(<span class="function">(<span class="params">v, j</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (v) data[fillCnt - i - <span class="number">1</span>][j] = v;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  fillCnt++;</span><br><span class="line">  render();</span><br><span class="line">  setTimeout(fill, <span class="number">300</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><hr><p><a name="4-5-3"></a></p><h3 id="5-3-이벤트-gt-블럭을-down하면서-움직이는-상태-move"><a href="#5-3-이벤트-gt-블럭을-down하면서-움직이는-상태-move" class="headerlink" title="5.3 이벤트 &gt; 블럭을 down하면서 움직이는 상태: move"></a>5.3 이벤트 &gt; 블럭을 down하면서 움직이는 상태: move</h3><p>누른상태에서 다음(혹은 이전) 블럭으로 움직이는 상태</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> move = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// down이 아니라면 이탈</span></span><br><span class="line">  <span class="comment">// x,y 위치의 블록을 얻음</span></span><br><span class="line">    <span class="comment">// 위에서 얻은 블록이 이전 블록의 타입이 같고 인접되어있는지 검사</span></span><br><span class="line">    <span class="comment">// 위에서 얻은 블록이 선택목록에 없으면 추가</span></span><br><span class="line">    <span class="comment">// 위에서 얻은 블록이 선택목록에 있다면 전전 블록일 경우 하나 삭제</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> move = <span class="function">(<span class="params">&#123; pageX: x, pageY: y &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isDown) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> curr = getBlock(x, y);</span><br><span class="line">  <span class="keyword">if</span> (!crr || curr.type !== startBlock.type || !isNext(curr)) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (selected.indexOf(curr) == <span class="number">-1</span>) selected.push(curr);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (selected[selected.length - <span class="number">1</span>] == curr) selected.pop();</span><br><span class="line">  currBlock = curr;</span><br><span class="line">  render();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 받아오는 curr 블럭과 cache해놓은 curr 블럭을 비교하여 인접해있는지 검사.</span></span><br><span class="line"><span class="comment">// 나와 위치가 한개 차이 난다는 것. x로 하나 차이 혹은 y로 하나 차이</span></span><br><span class="line"><span class="keyword">const</span> isNext = <span class="function"><span class="params">curr</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> r0,</span><br><span class="line">    c0,</span><br><span class="line">    r1,</span><br><span class="line">    c1,</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* data에서 들어온 </span></span><br><span class="line"><span class="comment">    curr의 x인덱스, y인덱스와 </span></span><br><span class="line"><span class="comment">    currBlock의 x인덱스와 y인덱스를 구하는 방법. </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  data.some(<span class="function">(<span class="params">row, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> j;</span><br><span class="line">    <span class="keyword">if</span> ((j = row.indexOf(currBlock)) !== <span class="number">-1</span>) (r0 = i), (c0 = j), cnt++;</span><br><span class="line">    <span class="keyword">if</span> ((j = row.indexOf(curr)) !== <span class="number">-1</span>) (r1 = i), (c1 = j), cnt++;</span><br><span class="line">    <span class="keyword">return</span> cnt === <span class="number">2</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    curr !== currBlock &amp;&amp; (<span class="built_in">Math</span>.abs(r0 - r1) === <span class="number">1</span> || <span class="built_in">Math</span>.abs(c0 - c1) === <span class="number">1</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>자바스크립트에서 배열의 고차함수로 여러 제어문을 제거할 수 있다.</p><h2 id="최종-코드-및-정리"><a href="#최종-코드-및-정리" class="headerlink" title="최종 코드 및 정리"></a>최종 코드 및 정리</h2><p>프로시저 함수: 반환값이 없는 함수<br>sideEffect가 엄청 많다.<br>현재 로직들은 모두 프로시저 함수.<br>앞으로 객체지향으로 리팩토링 예정.</p><details><br><summary>최종코드 (TS ver.)</summary><br><br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Game에서 사용한 interface</span></span><br><span class="line"><span class="keyword">interface</span> IGame &#123;</span><br><span class="line">  <span class="comment">// 게임판 정보</span></span><br><span class="line">  column: <span class="built_in">number</span>;</span><br><span class="line">  row: <span class="built_in">number</span>;</span><br><span class="line">  blockSize: <span class="built_in">number</span>;</span><br><span class="line">  data: (Block | <span class="literal">null</span>)[][];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 네이티브 객체 정보</span></span><br><span class="line">  table: HTMLElement;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 상태 정보</span></span><br><span class="line">  startBlock: Block;</span><br><span class="line">  currBlock: Block;</span><br><span class="line">  isDown: <span class="built_in">boolean</span>;</span><br><span class="line">  selected: Block[];</span><br><span class="line">  isNext: <span class="function">(<span class="params">curr: Block</span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line">  getBlock: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> Block;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 이벤트 관련</span></span><br><span class="line">  down: <span class="function">(<span class="params">&#123; pageX: x, pageY: y &#125;: &#123; pageX: <span class="built_in">number</span>; pageY: <span class="built_in">number</span> &#125;</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  move: <span class="function">(<span class="params">&#123; pageX: x, pageY: y &#125;: &#123; pageX: <span class="built_in">number</span>; pageY: <span class="built_in">number</span> &#125;</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  up: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  reset: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  remove: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  drop: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  fills: (Block | <span class="literal">null</span>)[][];</span><br><span class="line">  fillCnt: <span class="built_in">number</span>;</span><br><span class="line">  readyToFill: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  fill: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// util</span></span><br><span class="line">  el: <span class="function">(<span class="params">tag: HTMLElementTagNameMap</span>) =&gt;</span> HTMLElement;</span><br><span class="line">  </span><br><span class="line">  render: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 도저히 머리가 따라가기 힘들어서 TS로 우선 변환..</span></span><br><span class="line"><span class="keyword">const</span> Game = <span class="function">(<span class="params">(<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">class</span> Block &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">static</span> GET(<span class="params"><span class="keyword">type</span> = <span class="built_in">Math</span>.random(<span class="params"></span>) * 5</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">return</span> <span class="keyword">new</span> Block(<span class="params"><span class="keyword">type</span></span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    _type: <span class="built_in">number</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    constructor(<span class="params"><span class="keyword">type</span></span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">this</span>._type = <span class="keyword">type</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">get</span> image(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">return</span> `url(<span class="params">'img/block$&#123;<span class="keyword">this</span>._type&#125;.png'</span>)`;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">get</span> <span class="keyword">type</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">return</span> <span class="keyword">this</span>._type;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> column = 8,</span></span></span><br><span class="line"><span class="function"><span class="params">    row = 8,</span></span></span><br><span class="line"><span class="function"><span class="params">    blockSize = 80;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> data: (<span class="params">Block | <span class="literal">null</span></span>)[][] = [];</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">let</span> table: HTMLElement;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">let</span> startBlock: Block, currBlock: Block, isDown: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> selected: Block[] = [];</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> getBlock = (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): Block =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> &#123; top: T, left: L &#125; = table.getBoundingClientRect(<span class="params"></span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span> (<span class="params">x &lt; L || x &gt; L + blockSize * row || y &lt; T || y &gt; T + blockSize * column</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">return</span> <span class="literal">null</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> data[(<span class="params">y - T</span>) / blockSize][(<span class="params">x - L</span>) / blockSize];</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> isNext = (<span class="params">curr: Block</span>): <span class="built_in">boolean</span> =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">let</span> r0: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      c0: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      r1: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      c1: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      cnt = 0;</span></span></span><br><span class="line"><span class="function"><span class="params">    data.some(<span class="params">(<span class="params">row: (<span class="params">Block | <span class="literal">null</span></span>)[], i: <span class="built_in">number</span></span>) =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">let</span> j: <span class="built_in">number</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">if</span> (<span class="params">(<span class="params">j = row.indexOf(<span class="params">currBlock</span>)</span>) != -1</span>) (<span class="params">r0 = i</span>), (<span class="params">c0 = j</span>), cnt++;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">if</span> (<span class="params">(<span class="params">j = row.indexOf(<span class="params">curr</span>)</span>) != -1</span>) (<span class="params">r1 = i</span>), (<span class="params">c1 = j</span>), cnt++;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">return</span> cnt == 2;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> (<span class="params"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      (<span class="params">curr != currBlock &amp;&amp; <span class="built_in">Math</span>.abs(<span class="params">r0 - r1</span>) == 1</span>) || <span class="built_in">Math</span>.abs(<span class="params">c0 - c1</span>) == 1</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    </span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> reset = (<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    startBlock = currBlock = <span class="literal">null</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    selected.length = 0;</span></span></span><br><span class="line"><span class="function"><span class="params">    isDown = <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    render(<span class="params"></span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> remove = (<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    data.forEach(<span class="params">(<span class="params">r: (<span class="params">Block | <span class="literal">null</span></span>)[]</span>) =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="comment">//데이터삭제</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      selected.forEach(<span class="params">(<span class="params">v: Block</span>) =&gt; &#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">        <span class="keyword">let</span> i: <span class="built_in">number</span>;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">        <span class="keyword">if</span> (<span class="params">(<span class="params">i = r.indexOf(<span class="params">v</span>)</span>) != -1</span>) r[i] = <span class="literal">null</span>;</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">      &#125;</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    render(<span class="params"></span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    setTimeout(<span class="params">drop, 300</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> drop = (<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">let</span> isNext = <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> (<span class="params"><span class="keyword">let</span> j = 0; j &lt; column; j++</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">for</span> (<span class="params"><span class="keyword">let</span> i = row - 1; i &gt; -1; i--</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">if</span> (<span class="params">!data[i][j] &amp;&amp; i</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">let</span> k = i,</span></span></span><br><span class="line"><span class="function"><span class="params">            isEmpty = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">while</span> (<span class="params">k--</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">if</span> (<span class="params">data[k][j]</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">              isEmpty = <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">if</span> (<span class="params">isEmpty</span>) <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">          isNext = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">while</span> (<span class="params">i--</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            data[i + 1][j] = data[i][j];</span></span></span><br><span class="line"><span class="function"><span class="params">            data[i][j] = <span class="literal">null</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">          &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    render(<span class="params"></span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    isNext ? setTimeout(<span class="params">drop, 300</span>) : readyToFill(<span class="params"></span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> fills: (<span class="params">Block | <span class="literal">null</span></span>)[][] = [];</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">let</span> fillCnt = 0;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> readyToFill = (<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    fills.length = 0;</span></span></span><br><span class="line"><span class="function"><span class="params">    data.some(<span class="params">(<span class="params">row: (<span class="params">Block | <span class="literal">null</span></span>)[]</span>) =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">if</span> (<span class="params">row.indexOf(<span class="params"><span class="literal">null</span></span>) == -1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      <span class="keyword">const</span> r: (<span class="params">Block | <span class="literal">null</span></span>)[] = [...row].fill(<span class="params"><span class="literal">null</span></span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      fills.push(<span class="params">r</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      row.forEach(<span class="params">(<span class="params">v: Block | <span class="literal">null</span>, i</span>) =&gt; !v &amp;&amp; (<span class="params">r[i] = Block.GET(<span class="params"></span>)</span>)</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    fillCnt = 0;</span></span></span><br><span class="line"><span class="function"><span class="params">    setTimeout(<span class="params">fill, 300</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> fill = (<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span> (<span class="params">fillCnt &gt; fills.length</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      isDown = <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> (<span class="params"><span class="keyword">let</span> i = 0; i &lt; fillCnt; i++</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      fills[fills.length - i - 1].forEach(<span class="params">(<span class="params">v, j</span>) =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="keyword">if</span> (<span class="params">v</span>) data[fillCnt - i - 1][j] = v;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      &#125;</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    fillCnt++;</span></span></span><br><span class="line"><span class="function"><span class="params">    render(<span class="params"></span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    setTimeout(<span class="params">fill, 300</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> down = (<span class="params">&#123; pageX: x, pageY: y &#125;: &#123; pageX: <span class="built_in">number</span>; pageY: <span class="built_in">number</span> &#125;</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span> (<span class="params">isDown</span>) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> curr = getBlock(<span class="params">x, y</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span> (<span class="params">!curr</span>) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    isDown = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    selected.length = 0;</span></span></span><br><span class="line"><span class="function"><span class="params">    selected[0] = startBlock = currBlock = curr;</span></span></span><br><span class="line"><span class="function"><span class="params">    render(<span class="params"></span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> move = (<span class="params">&#123; pageX: x, pageY: y &#125;</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span> (<span class="params">!isDown</span>) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> curr = getBlock(<span class="params">x, y</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span> (<span class="params">!curr || curr.<span class="keyword">type</span> != startBlock.<span class="keyword">type</span> || !isNext(<span class="params">curr</span>)</span>) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span> (<span class="params">selected.indexOf(<span class="params">curr</span>) == -1</span>) selected.push(<span class="params">curr</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="params">selected[selected.length - 2] == curr</span>) selected.pop(<span class="params"></span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    currBlock = curr;</span></span></span><br><span class="line"><span class="function"><span class="params">    render(<span class="params"></span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> up = (<span class="params"></span>) =&gt; (<span class="params">selected.length &gt; 2 ? remove(<span class="params"></span>) : reset(<span class="params"></span>)</span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> el = (<span class="params">tag: keyof HTMLElementTagNameMap</span>) =&gt; <span class="built_in">document</span>.createElement(<span class="params">tag</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> render = (<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    table.innerHTML = "";</span></span></span><br><span class="line"><span class="function"><span class="params">    data.forEach(<span class="params">row =&gt;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      table.appendChild(<span class="params"></span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">        row.reduce(<span class="params">(<span class="params">tr, block</span>) =&gt; &#123;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params"><span class="params">          tr.appendChild(<span class="params">el(<span class="params">"td"</span>)</span>).style.cssText = `</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params"><span class="params">        $&#123;block ? `background:$&#123;block.image&#125;;` : ""&#125;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params"><span class="params">        width:$&#123;blockSize&#125;px;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params"><span class="params">        height:$&#123;blockSize&#125;px;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params"><span class="params">        cursor:pointer`;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params"><span class="params">          <span class="keyword">return</span> tr;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params"><span class="params">        &#125;, el(<span class="params">"tr"</span>)</span>)</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"><span class="params">      </span>)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    </span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">return</span> (<span class="params">tid: <span class="built_in">string</span></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    table = <span class="built_in">document</span>.querySelector(<span class="params">tid</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> (<span class="params"><span class="keyword">let</span> i = 0; i &lt; row; i++</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> r = [];</span></span></span><br><span class="line"><span class="function"><span class="params">      data.push(<span class="params">r</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">for</span> (<span class="params"><span class="keyword">let</span> j = 0; j &lt; column; j++</span>) r[j] = Block.GET(<span class="params"></span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    table.addEventListener(<span class="params">"mousedown", down</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    table.addEventListener(<span class="params">"mouseup", up</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    table.addEventListener(<span class="params">"mouseleave", up</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    table.addEventListener(<span class="params">"mousemove", move</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    render(<span class="params"></span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>)<span class="params">()</span>;</span></span><br><span class="line"><span class="function"><span class="params">Game</span>(<span class="params">"#stage"</span>);</span></span><br></pre></td></tr></table></figure><br><br></details>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;코드스피츠 강의 정리록&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;생소한 도메인으로 배우는게 좋다.&lt;br&gt;익숙한 도메인들은 익숙한 처리방법으로 처리하기때문에 객체지향을 배우기 어렵다.&lt;br&gt;때문에 80기는 게임을 통해서 진행할 
      
    
    </summary>
    
      <category term="02_WorkShop" scheme="http://feel5ny.github.io/categories/02-WorkShop/"/>
    
      <category term="2019 CodeSpitz" scheme="http://feel5ny.github.io/categories/02-WorkShop/2019-CodeSpitz/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
      <category term="OOP" scheme="http://feel5ny.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>코드스피츠80_OOP design with game (1)- 1. 객체지향과 값지향</title>
    <link href="http://feel5ny.github.io/2019/02/17/OOP_08_1/"/>
    <id>http://feel5ny.github.io/2019/02/17/OOP_08_1/</id>
    <published>2019-02-17T01:20:19.000Z</published>
    <updated>2019-03-17T15:49:44.052Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>코드스피츠 강의 정리록</p></blockquote><p>생소한 도메인으로 배우는게 좋다.<br>익숙한 도메인들은 익숙한 처리방법으로 처리하기때문에 객체지향을 배우기 어렵다.<br>때문에 80기는 게임을 통해서 진행할 예정.</p><hr><p><a name="1"></a></p><h1 id="1-객체지향-준비운동"><a href="#1-객체지향-준비운동" class="headerlink" title="1. 객체지향 준비운동"></a>1. 객체지향 준비운동</h1><h2 id="객체지향-←→-값지향"><a href="#객체지향-←→-값지향" class="headerlink" title="객체지향 ←→ 값지향"></a>객체지향 ←→ 값지향</h2><p>객체지향의 반대말은 값지향이다.<br>객체지향과 값지향을 비교해보면서 기본개념을 잡고 넘어가자.</p><hr><p><a name="1-1"></a></p><h2 id="1-1-객체지향"><a href="#1-1-객체지향" class="headerlink" title="1.1 객체지향"></a>1.1 객체지향</h2><p><a name="1-1-1"></a></p><h3 id="1-참조값을-사용함"><a href="#1-참조값을-사용함" class="headerlink" title="1) 참조값을 사용함."></a>1) 참조값을 사용함.</h3><p>객체지향에서는<br>함수의 인자를 보내던,<br>변수에 대입을 하던,<br>연산을 하던<br>참조를 사용한다.</p><hr><h4 id="cf-1-언어마다-어떠한-타입에-대해서-값으로-처리-참조로-처리할지-결정한다"><a href="#cf-1-언어마다-어떠한-타입에-대해서-값으로-처리-참조로-처리할지-결정한다" class="headerlink" title="cf__1 언어마다 어떠한 타입에 대해서 값으로 처리, 참조로 처리할지 결정한다."></a>cf__1 언어마다 어떠한 타입에 대해서 값으로 처리, 참조로 처리할지 결정한다.</h4><p>그렇다고 오브젝트는 값이 아닐 것이다 라고 생각하면 안된돠.<br>오브젝트도 값으로 생각하는 언어들이 있다.</p><ul><li>자바스크립트에서는 스트링을 값으로 보고 있다.</li><li>자바에서는 스트링을 객체로 보고 있다.</li></ul><p>언어마다 어떠한 타입에 대해서 직접적으로 값으로 처리할지<br>참조로 처리할지 결정하는 것이다. 원래 값이고 원래 참조다 라는 개념은 없다.</p><hr><h4 id="한번-만든-객체가-전파됨"><a href="#한번-만든-객체가-전파됨" class="headerlink" title="* 한번 만든 객체가 전파됨."></a>* 한번 만든 객체가 전파됨.</h4><p>참조는 순식간에 전파된다.<br>객체 컨텍스트에서는 참조를 쓴다고 했다.<br>참조가 되면 원본은 <code>힙메모리</code>에 만들어지고<br>모든 객체는 <strong>힙메모리의 주소</strong>만 참조하고 다니는 것이다. 주소값만 복사되고 있는 것.<br>⇒ 한번 만들어진 객체는 통제권을 쉽게 벗어나서 주소의 복사가 왕창 일어난다는 것이다.</p><p>객체지향의 큰 어려움은 객체를 일단 만들고 나면<br><strong>주소값을 보호할 수 있을 것 같지만 실제로는 순식간에 퍼져나간다.</strong><br>⇒ 문제는 그 주소값을 참조하는 변수에 새로운 객체를 할당할 수 있다.</p><p>A라는 변수가 원래는 old 객체를 참조하고 있었는데,<br>A라는 변수에 new객체를 할당하면 새로운 주소가 A변수에 들어간다.<br>⇒ A는 아무 문제가 없지만, B = A, C = B의 B,C변수들이 다 바보가 된다.<br><strong>즉, A의 참조부분을 잡았던 애들이 다 바보가 된다.</strong><br>B와 C는 old를 가리키고 있지만, A는 이제 new가 되었다..</p><p>객체지향에서는 객체 참조키를 함부로 노출하지 않고 쥐고 있지 않으면<br>순식간에 오염이 전파되서 A객체도 new객체를 받아들일 수 없다. <code>겁나니까.</code></p><p>객체지향은 이러한 단점이 있다. 참조가 쉽게 전파된다.<br>참조 전파를 막는 장치가 있거나,<br>섬세하게 관리하지않으면 참조가 순식간에 전파되어서<br>참조를 전파시킨 본인조차도 새 객체를 받아들일 수 없다. 그럼.. 전체가 썪어서 망가진다..</p><h5 id="이-부분을-관리하는-것이-객체지향에서-어려운-점이다"><a href="#이-부분을-관리하는-것이-객체지향에서-어려운-점이다" class="headerlink" title="이 부분을 관리하는 것이 객체지향에서 어려운 점이다. "></a><strong>이 부분을 관리하는 것이 객체지향에서 어려운 점이다. </strong></h5><hr><p>그에 비해서 값지향은 매번 복사가된다. 전파되지 않는다는 것이다.<br>끊임없는 클론이 양산된다.<br>⇒ 메모리가 엄청나게 많이 사용된다.<br>⇒ GC에 의존할 수밖에 없다.</p><p>값으로 계속 복사가 되기때문에<br>값에 대한 컨텍스트를 이어갈 수 없고<br>컨텍스트를 포함한 새로운 값을 만드는데 성공해야한다.</p><p>값지향에서는 히스토리를 볼 수 없고 상태의 흐름을 볼 수 없다.<br>중간중간에 흔적을 따로따로 상태를 보관해줘야한다.</p><p>결과물이 복잡할수록 함수의 복잡성은 올라간다.<br>⇒ 수정은 더욱더 올라간다.<br>ex) 함수형, rx</p><p>객체지향은 싱글톤 객체나 메모리상의 유일한 객체를 참조로 전파시키고 있으니까,<br><strong>메모리상의 유리한 점이나 객체의 생성에 대한 안정성을 확보해 줄 수 있다.</strong><br>다만, 주소의 전파가 일어나면 썩어들어간다.</p><hr><h4 id="데이터를-처리하는-메소드를-내장함"><a href="#데이터를-처리하는-메소드를-내장함" class="headerlink" title="* 데이터를 처리하는 메소드를 내장함."></a>* 데이터를 처리하는 메소드를 내장함.</h4><p>본인의 상태를 본인이 책임질 수 있다.<br>class 내에 메소드들이 this가 안나오면 메소드가 아니다.</p><ul><li><code>this</code>가 없고, 인지와 지역변수만 쓰는 것은 유틸리티 함수이다.</li><li>우리는 기계적으로 class코드를 살펴보고 메소드에 this가 나오는지 안나오는지 살펴보고 안나오면 전부 유틸리티로 보내야한다.</li><li>다른 함수에서 유틸리티를 사용할지도 모르고,<br>나중에 유틸리티 함수로 분리하지 않고, 리팩토링이나 수정시<br>비슷한 함수를 사용하는 위치가 어디있는지 모르게 되며, 중복코드가 생길 가능성이 있다.</li></ul><hr><h4 id="모든-메소드는-현재-객체-컨텍스트-사용"><a href="#모든-메소드는-현재-객체-컨텍스트-사용" class="headerlink" title="* 모든 메소드는 현재 객체 컨텍스트 사용"></a>* 모든 메소드는 현재 객체 컨텍스트 사용</h4><p>리팩토링할 때 알 수 있는 것은<br>우리가 짠 클래스에 this를 사용하지 않는 메소드가 나온다는 점으로부터, </p><ul><li>이건 객체협력으로 문제를 풀고 잇지 않구나를 알 수 있다.<br><code>값 컨텍스트</code>를 섞어서 문제를 풀었다는 것을 알 수 있다.</li></ul><p>리팩토링이 끝나고 나면, <strong>this만 사용하는 클래스의 협력으로 문제가 풀리게 된다.</strong><br>그것이 우리의 궁극적인 목표이기도 하다.</p><hr><p><a name="1-1-2"></a></p><h3 id="2-각-객체는-단일한-책임을-갖음-SOLID-마틴-파울러"><a href="#2-각-객체는-단일한-책임을-갖음-SOLID-마틴-파울러" class="headerlink" title="2) 각 객체는 단일한 책임을 갖음 SOLID (마틴 파울러)"></a>2) 각 객체는 단일한 책임을 갖음 SOLID (마틴 파울러)</h3><p>우리가 알파고가 아니다. 이세돌이다.<br>사람의 한계로 인해서 한번에 하나밖에 안된다.<br>인간의 한계때문에 SOLID원칙이 있는 것이다.</p><blockquote><p>⇒ 그래서 컨벤션이 존재. </p></blockquote><ul><li>자신이 처리할 수 없는 책임은 타 객체와 협력</li><li>객체망에 참여하여 자신의 역할 수행g하도록 한다.</li></ul><hr><p><a name="1-1-3"></a></p><h3 id="3-객체지향-사고"><a href="#3-객체지향-사고" class="headerlink" title="3) 객체지향 사고"></a>3) 객체지향 사고</h3><ol><li>객체망으로 문제를 해결한다.<ul><li>혼자할 수 있는 일이 단일책임밖에 없기 때문에<br>객체망으로 해결한다.</li></ul></li><li>단일책임을 준수한다.</li><li>객체를 이용하여 문제를 해결한다.<ul><li>값으로 문제를 해결하지 않는다. </li><li>모든 처리를 객체로한다.</li><li>값을 도입하면 도입할수록 객체지향이 아니게된다.</li></ul></li><li><strong>은닉</strong>과 <strong>캡슐화</strong>를 활용하여 상태를 처리한다.<br>순식간에 전파되기 때문에.</li></ol><h4 id="은닉"><a href="#은닉" class="headerlink" title="은닉"></a><strong>은닉</strong></h4><p>왜 안보여 줄까? ⇒ 지식 (knowledge)<br>은닉을 하는 이유는 사람때문이다. 사람을 못믿기 때문에..<br>객체지향은 사람 중심의 사고로 사람을 무지하다고 생각하는..ㅋㅋ 패러다임이다.</p><h4 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a><strong>캡슐화</strong></h4><p>은닉과 전혀 다른 이야기이다. 나의 행동을 구체적으로 부여주지 않으려고 하는건 아니다.<br><strong>추상화된 수준으로 설명하고 싶은 것.</strong><br>(ex_ATM기기: 돈세는 소리로 사용자의 목적을 인지시키지만, 실제 내부에서는 많은 일이 벌어진다.)</p><p>캡슐화를 common sense로 제공한다.<br><strong>가장 설계능력이 많이 필요한 부부은 캡슐화이다. </strong><br>좋은 아키텍쳐는 캡슐화를 잘한다.<br>캡슐화를 하는 이유 중 하나는 객체망을 숨기기 위한 것도 있다.<br>아키텍쳐들이 하는 일들이다.</p><p>기계 친화적인 코드는 없다. 기계친화적인 포맷은 없다.<br>사람에게 이해가 쉬운 코드. 사람이 잘 사용할 수 있는 캡슐화. </p><p><strong>⇒ 객체지향이 지원하는 것이다.</strong></p><hr><p><a name="1-2"></a></p><h2 id="1-2-값지향"><a href="#1-2-값지향" class="headerlink" title="1.2 값지향"></a>1.2 값지향</h2><p><a name="1-2-1"></a></p><h3 id="1-값의-복사를-사용함"><a href="#1-값의-복사를-사용함" class="headerlink" title="1) 값의 복사를 사용함."></a>1) 값의 복사를 사용함.</h3><h4 id="값의-평가-방법"><a href="#값의-평가-방법" class="headerlink" title="* 값의 평가 방법"></a>* 값의 평가 방법</h4><p>값이라는 것은 어떻게 구분할까?<br>객체 간의 식별은 메모리의 주소로 한다.</p><p>값에서는 메모리의 주소는 틀리지만,<br>타입에서 인정한 동과평과방법에 의해서<br>값의 동과를 판별하는 전용식이 따로 있다. </p><p>메모리의 주소로 평가하는 것이 아니라<br>값에 따라서 평가하는 방법이 다 다르다.</p><hr><h4 id="값을-처리하는-유틸리티-함수가-존재"><a href="#값을-처리하는-유틸리티-함수가-존재" class="headerlink" title="* 값을 처리하는 유틸리티 함수가 존재"></a>* 값을 처리하는 유틸리티 함수가 존재</h4><p>값에서는 값을 평가하는 기준이 따로 있고,<br>그것으로 동과를 평가한다. (메모리의 주소로 평가하지 않는다.)<br>값이 있으면 값의 동과를 평가하는 식은 값 밖에 있다.<br>메소드도 아니다.<br>메소드로 처리하지 않고 값을 처리하는 유틸리티 함수로 값을 처리하게 된다. </p><ul><li>타입 그룹별로 존재하게 된다.</li></ul><hr><h5 id="함수가-값을-처리하는-경우-컨텍스트는-없음"><a href="#함수가-값을-처리하는-경우-컨텍스트는-없음" class="headerlink" title="* 함수가 값을 처리하는 경우 컨텍스트는 없음"></a>* 함수가 값을 처리하는 경우 컨텍스트는 없음</h5><p>메모리에 있는 값 그 자체를 사용한다.</p><blockquote><p>cf__2. 객체도 값처럼 사용하면 값 컨텍스트로 넘어간다.<br>자바같은 언어에서 객체는 생성할때 무조건 고유한 해시코드를 갖고 태어난다.<br>객체는 원래 메모리 주소로 구분해야하는데, 해시코드를 어딘가에 캐시잡아놓고, 해시코드와 해시코드를 비교해서 객체의 동과를 비교하려고 한다. 이런 경우 객체지만 값 컨택스트로 넘어간다.<br>메모리의 주소로 비교해야하는데, 특별한 값의 비교방법으로 동과를 평가하면 그 비교식들은 순식간의 값 컨텍스트로 바뀐다.</p></blockquote><hr><p><a name="1-2-2"></a></p><h3 id="2-값은-순수한-데이터로-책임의-개념이-없음"><a href="#2-값은-순수한-데이터로-책임의-개념이-없음" class="headerlink" title="2) 값은 순수한 데이터로 책임의 개념이 없음"></a>2) 값은 순수한 데이터로 책임의 개념이 없음</h3><h4 id="각-역할에-맞는-적절한-값의-타입이-존재함"><a href="#각-역할에-맞는-적절한-값의-타입이-존재함" class="headerlink" title="* 각 역할에 맞는 적절한 값의 타입이 존재함"></a>* 각 역할에 맞는 적절한 값의 타입이 존재함</h4><p>값 지향에서는 값과 독립적인 함수일가?<br>인티저를 더하는 함수는 값에 독립적일까? 독립적이다.<br><strong>단지 타입에 종속되어있다.</strong> </p><p>어떤 함수는 인티저 타입만 건드릴 수 있고,<br>어떤 함수는 더블 타입만 건드릴 수 있다.<br>이때 말한 타입은 객체타입이 아님.</p><p>타입에 따라서 값타입이냐<br>객체타입이냐는 굉장히 큰 구분점을 갖게 된다.<br>값타입에서는 그 타입이 함수를 그룹짓는 기준이 되어버린다. </p><p>값에서는 하나하나 값을 구분하는 것이 아니라<br>값의 타입만 구분할 수 있기 때문이다.<br>그 다음에는 이 값과 값의 크기만 갖는것이다.</p><p>객체는 그렇게 구분되지 않는다.<br>메모리만 있으면 독립성이 확보이다.<br>값은 복잡한 녀석들이다 의외로 </p><hr><h4 id="값을-처리하는-함수의-조합으로-문제를-해결함"><a href="#값을-처리하는-함수의-조합으로-문제를-해결함" class="headerlink" title="*  값을 처리하는 함수의 조합으로 문제를 해결함"></a>*  값을 처리하는 함수의 조합으로 문제를 해결함</h4><p>값은 계속 복사되고, 계속 역할이 없는 상태로 존재하기 때문에<br>값지향을 이용해서 문제를 처리하기 위해서는<br>값을 처리하는 함수의 조합으로 문제를 처리하는 수밖에 없다.</p><blockquote><p>HOC</p></blockquote><p>끊임없이 그 함수가 값을 만들거나 값을 받아들이면서<br>최종적으로 도메인을 해결하기 때문에<br>결국에 값을 통한 문제들은 대부분 <strong>파이프라인</strong>으로 결론을 내게된다.</p><p>ex__도자기 공정<br>도자기를 예로 들자.<br>도자기를 만드는 방법을<br>흙을 반죽하고 ⇒ 반죽한 흙을 빚어서 도자기를 만드는 과정이라고 치면.<br>과정을 유틸리티 함수로 만들어보자.</p><p>함수는 흙을 받고, 반죽을 return하게끔 만들 수 있다.<br>이런 함수는 고정상태와 고정출력이 있다.<br>어떤 과정을 순수하게 고정상태와 고정출력이 있는 상태로 구분지어서 나눌 수 있냐가 중요하다.</p><p>-<br>값지향을 하기 위해서는 상태를 구분지을 수 있냐 없냐 즉,<br>내가 처리하려는 공정을 딱딱 잘라낼 수 있는지 없는지가 굉장히 중요하다. </p><p><strong>하지만 우리 비즈니스의 요건들은 딱딱 잘라낼 수 있는 상황이 아니다.</strong><br>무조건 아닌 것은 아니고, 우리가 속해있는 도메인에 달려있다.<br>값지향으로는 가역성을 만들기 어려워서 리셋을 한다.</p><hr><p><a name="1-2-3"></a></p><h3 id="3-값-지향-사고"><a href="#3-값-지향-사고" class="headerlink" title="3) 값 지향 사고"></a>3) 값 지향 사고</h3><ol><li>연산을 통해 문제를 해결한다.</li><li>연산에 적합한 값을 정의한다(함수포함)</li><li>값을 통해 문제를 해결한다.</li><li>순수함수를 활용하여 상태를 제거한다.</li></ol><p>값과<br>immutable과<br>rx와<br>함수형으로 풀 수 있는 문제는<br>그렇게 많지 않다.</p><p>주요 도메인은 객체지향을 쓰는 이유는 사람의 마음은 기계가 아니기 때문에..<br>개발 잘 하고싶으면 인지과학, 인지심리, 뇌과학 배우면 좋다.<br>사람들이 좋아하는 것을 하면 좋은 아키텍처가 될수있다 .. :)</p><hr><p><a name="1-3"></a></p><h2 id="1-3-객체지향에서-단일-책임의-도출-기준"><a href="#1-3-객체지향에서-단일-책임의-도출-기준" class="headerlink" title="1.3 객체지향에서 단일 책임의 도출 기준"></a>1.3 객체지향에서 단일 책임의 도출 기준</h2><h3 id="객체-디자인-또는-설계"><a href="#객체-디자인-또는-설계" class="headerlink" title="객체 디자인 또는 설계"></a>객체 디자인 또는 설계</h3><p>객체의 책임을 도출하고 객체망을 구성하는 것</p><p>책임 (or 역할)을 도출하는 기준으로 사용할 수 있는 후보군<br>3가지 요령이 있다. (3번으로 갈수록 뒤로갈수록 중요성이 높다.)</p><hr><p><a name="1-3-1"></a></p><h4 id="1-도메인-의존성"><a href="#1-도메인-의존성" class="headerlink" title="1) 도메인 - 의존성"></a>1) 도메인 - 의존성</h4><p>객체디자인을 할 때 도메인에서 뽑는 것이 좋다.</p><ul><li>의존성 관리가 훨씬 쉬워진다.</li><li>객체망을 구성할때 독립적인 단위로 구성할 수 있다.</li></ul><h5 id="첫번째로-역할을-인식할때는-도메인-경계를-나누고-시작하자"><a href="#첫번째로-역할을-인식할때는-도메인-경계를-나누고-시작하자" class="headerlink" title="* 첫번째로 역할을 인식할때는 도메인 경계를 나누고 시작하자."></a>* 첫번째로 역할을 인식할때는 도메인 경계를 나누고 시작하자.</h5><p><strong>DDD 개발</strong>: 의존성때문에!</p><ul><li>의존성의 범위를 정의할 수 있기 때문에</li><li>가역성이 좋아진다.</li></ul><hr><p><a name="1-3-2"></a></p><h4 id="2-네이티브-영역-가변성"><a href="#2-네이티브-영역-가변성" class="headerlink" title="2) 네이티브 영역 - 가변성"></a>2) 네이티브 영역 - 가변성</h4><p>개발은 크게 2가지 영역을 다룬다고 생각해도된다.</p><ol><li><strong>인메모리 객체</strong><br>로직이 메모리안에서 도는 로직들이 있다.<br>-</li><li><strong>I/O</strong> (네이티브 영역)<br>통제권 밖에 잇는 것.<br>ex. DOM, 쿠키, ajax</li></ol><h5 id="인메모리와-인메모리-바깥-생태계가-주고받는-행위가-존재한다"><a href="#인메모리와-인메모리-바깥-생태계가-주고받는-행위가-존재한다" class="headerlink" title="* 인메모리와 인메모리 바깥 생태계가 주고받는 행위가 존재한다."></a>* 인메모리와 인메모리 바깥 생태계가 주고받는 행위가 존재한다.</h5><ul><li>쿠키를 읽어온다. : 하드에서 읽어옴</li><li>네트워크 통신 : 소켓으로 읽어옴</li><li>돔하고 대화..</li></ul><p>I/O를 사용하면 드득거린다.<br>쿠키를 읽을때 드득거리는 것을 볼 수 있다.<br><strong>때문에 일부러 <code>웹워커</code>같은 것을 사용한다.</strong></p><ul><li>ajax 비동기인데 왜 워커에서 띄어서 하지?<ul><li>ajax가 I/O라서 ajax가 발동하는 순간을 보면 드득거린다.</li><li>백그라운드 thread를 띄어서(웹워커) 여기서 I/O를 띄어야,<br>메인 thread에 영향을 안주게 된다.</li></ul></li></ul><h5 id="네이티브-영역-I-O영역"><a href="#네이티브-영역-I-O영역" class="headerlink" title="* 네이티브 영역: I/O영역"></a>* 네이티브 영역: I/O영역</h5><p>인메모리 영역과 네이티브 영역을 분리해서 객체를 구성해라.</p><p><strong>믹스한 경우</strong></p><ul><li>ex__<br>인메모리 객체와 돔을 믹스해서 사이트를 만들엇을 경우<br>돔말고 캔버스로 바꾸면? =&gt; 고우투 헬</li></ul><p><strong>이 두개를 분리한 사례</strong> </p><ul><li>React</li><li>리액트의 인메모리 구조체가<br>네이티브와 완전히 분리되어있기 때문에<br>.<br>리액트로 짠 코드를<br>리액트 네이티브로 바꿀 수 있고<br>리액트 캔버스로 바꿀 수 있다.<br>.<br>리액트 본체가 완전히 인메모리로 되어있기 때문에 가능한 상황.</li></ul><p>도메인보다 더 중요하다.<br>네이티브 도메인을 분리해주자.</p><hr><h5 id="정리"><a href="#정리" class="headerlink" title="정리 **"></a>정리 **</h5><p>네이티브 영역을 분리해서 프로그램을 구축하지 않으면<br>새로운 네이티브 영역과 바인딩하거나 환경이 바뀔때 비용을 든다..<br>네이티브 영역에 의존하면 안된다.<br>의존하지 않기 위해서는 인메모리, I/O 따로 만들어야한다.</p><blockquote><p>도메인 패턴<br>도메인 패턴을 따르지 않는 패턴을<br>enterprise pattern에서 <strong>transaction script pattern</strong></p></blockquote><hr><p><a name="1-3-3"></a></p><h4 id="3-변화율-유지보수"><a href="#3-변화율-유지보수" class="headerlink" title="3) 변화율 - 유지보수"></a>3) 변화율 - 유지보수</h4><p>변화율의 기준으로 나누어야한다.</p><p>예를 들어<br>고객의 <strong>비즈니스 요구사항</strong>이 바뀔때 바뀌는 부분이고<br>고객의 <strong>시장반응</strong>이 바뀔때 바뀌는 부분이라면<br>해당 변화율 기준으로 나눠놔야한다.</p><p>구간을 나눠서, 책임을 나눌 때<br>어떠한 일때문에 바뀌는지에 따라서 나눠 놓으라는 것.</p><p>모든 프로그램은 변하니까.<br>변하는 이유에 따라서 나눠놔라.<br>좋은 아키텍트가 되는 중요한 자질이다.</p><p>변화율을 꽤뚫어봐라!<br>변화율에 대한 센스가 아키텍트의 중요한 자질.</p><hr><hr><p>도메인을 기준으로 책임을 도출해보자.<br>네이티브 영역을 분리해서 책임을 도출해보자.<br>변화율을 인식해서 책임을 도출해보자.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;코드스피츠 강의 정리록&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;생소한 도메인으로 배우는게 좋다.&lt;br&gt;익숙한 도메인들은 익숙한 처리방법으로 처리하기때문에 객체지향을 배우기 어렵다.&lt;br&gt;때문에 80기는 게임을 통해서 진행할 
      
    
    </summary>
    
      <category term="02_WorkShop" scheme="http://feel5ny.github.io/categories/02-WorkShop/"/>
    
      <category term="2019 CodeSpitz" scheme="http://feel5ny.github.io/categories/02-WorkShop/2019-CodeSpitz/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
      <category term="OOP" scheme="http://feel5ny.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>(ing..) ES6 Symbol 프로퍼티</title>
    <link href="http://feel5ny.github.io/2019/02/04/JS_24/"/>
    <id>http://feel5ny.github.io/2019/02/04/JS_24/</id>
    <published>2019-02-04T01:20:19.000Z</published>
    <updated>2019-02-10T11:28:01.909Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ECMAScript6 책 (두고두고 보는 자바스크립트 표준 레퍼런스)<br>정리중 입니다.</p></blockquote><hr><p><a name="0"></a></p><h2 id="0-Well-Known-Symbol"><a href="#0-Well-Known-Symbol" class="headerlink" title="0. Well-Known Symbol"></a>0. Well-Known Symbol</h2><p>스펙에서 <code>@@iterator</code> 형태로 작성된 것을 볼 수 있는데, <code>@@</code>는 <code>Symbol</code> 대신 사용한 것이다.</p><ul><li>@@iterator === Symobl.iterator</li></ul><p>Well-Known Symbol은 스펙에서 처리 알고리즘을 구분하기 위해 부여한 이름이다.</p><ul><li>즉, 자바스크립트 엔진이 디폴트로 처리하는 알고리즘 유형 이름이다.</li></ul><p>자바스크립트 프로그램에 같은 이름의 Well-Known Symbol을 작성하면 엔진의 디폴트처리를 실행하지 않고, 프로그램에 작성된 코드를 실행한다.</p><ul><li>Well-Known Symbol이 오버라이드되는 것과 같으므로 프로그램에 같은 이름을 작성하여 Well-Known Symbol기능을 대체할 수 있다.</li><li>이런 가변성과 유용성을 제공하는 것이 Well-Known Symbol의 목적.</li></ul><p>11개의 Well-Known Symbol이 있다.</p><p><a name="1"></a></p><h2 id="1-toStringTag"><a href="#1-toStringTag" class="headerlink" title="1. toStringTag"></a>1. toStringTag</h2><p><code>[object Object]</code> 형태에서 Object를 Symbol.toStringTag 값으료 정하면 Object 문자열이 해당 값으로 출력된다.</p><ul><li>Object를 toString으로 반환할 때와 Function 오브젝트를 toString으로 반활할때 둘다 <code>[obejct Object]</code>로 출력되므로 이를 구분하기 위해 <code>Symbol.toSTringTag</code>로 구분지으면 된다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.prototype[<span class="built_in">Symbol</span>.toStringTag]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line">a.toString() <span class="comment">// "[object Object]"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; </span><br><span class="line">B.prototype[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">"나는 B"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> B()</span><br><span class="line">c.toString() <span class="comment">// "[object 나는 B]"</span></span><br></pre></td></tr></table></figure><h3 id="1-2-클래스의-메서드로-사용"><a href="#1-2-클래스의-메서드로-사용" class="headerlink" title="1-2. 클래스의 메서드로 사용"></a>1-2. 클래스의 메서드로 사용</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> aObj = <span class="keyword">new</span> a();</span><br><span class="line"><span class="built_in">console</span>.log(aObj.toString()); <span class="comment">// "[object Object]"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  get[<span class="built_in">Symbol</span>.toStringTag]()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'나는 B'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> BObj = <span class="keyword">new</span> B();</span><br><span class="line"><span class="built_in">console</span>.log(BObj.toString()); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Map</span>.prototype[<span class="built_in">Symbol</span>.toStringTag]);</span><br></pre></td></tr></table></figure><p>개발자 코드로 Well-Known Symbol 기능을 대체할 수 있다.</p><p><a name="2"></a></p><h2 id="2-isConcatSpreadable"><a href="#2-isConcatSpreadable" class="headerlink" title="2. isConcatSpreadable"></a>2. isConcatSpreadable</h2><p><a name="3"></a></p><h2 id="3-unscopables"><a href="#3-unscopables" class="headerlink" title="3. unscopables"></a>3. unscopables</h2><p><a name="4"></a></p><h2 id="4-species-개념"><a href="#4-species-개념" class="headerlink" title="4. species 개념"></a>4. species 개념</h2><p><a name="5"></a></p><h2 id="5-species"><a href="#5-species" class="headerlink" title="5. species"></a>5. species</h2><p><a name="6"></a></p><h2 id="6-다른-Class-변환"><a href="#6-다른-Class-변환" class="headerlink" title="6. 다른 Class 변환"></a>6. 다른 Class 변환</h2><p><a name="7"></a></p><h2 id="7-null-변환"><a href="#7-null-변환" class="headerlink" title="7. null 변환"></a>7. null 변환</h2><p><a name="8"></a></p><h2 id="8-toPrimitive"><a href="#8-toPrimitive" class="headerlink" title="8. toPrimitive"></a>8. toPrimitive</h2><p><a name="9"></a></p><h2 id="9-iterator"><a href="#9-iterator" class="headerlink" title="9. iterator"></a>9. iterator</h2><p>Symbol.iterator()는 이터레이터 오브젝트를 생성하며 반환한다.<br>Symbol.iterator는 String, Array, Map, Set, TypedArray 오브젝트의 prototype에 연결되어 있다.<br><strong>오브젝트의 [Symbol.iterator]를 호출하면 이터레이터 오브젝트를 생성하여 반환한다.</strong></p><h3 id="Array-prototype-Symbol-iterator"><a href="#Array-prototype-Symbol-iterator" class="headerlink" title="Array.prototype[Symbol.iterator]"></a>Array.prototype[Symbol.iterator]</h3><p>배열을 처리하기 위한 이터레이터 오브젝트를 생성하여 반환한다.<br>배열 엘리먼트를 하나씩 처리할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberArray = [<span class="number">10</span>,<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> numberArray)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iteratorObj = numberArray[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next());</span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next());</span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next());</span><br></pre></td></tr></table></figure></p><ul><li><code>for..of</code>문에서 배열이 반복되는 것은 numberArray 오브젝트에 <code>Symbol.iterator</code>가 있기 때문이다.</li><li>배열 엘리먼트를 하나씩 읽는 처리는 Symbol.iterator()를 호출하여 값을 반환하는 것에 해당한다.</li></ul><p><code>numberArray[Symbol.iterator]();</code></p><ul><li>numberArray 인스턴스의 Symbol.iterator()를 호출하는 것으로 이터레이터 오브젝트를 생성하여 반환한다.</li></ul><p><img src="/images/2019/09/01.png"><br><img src="/images/2019/09/02.png"></p><h3 id="String-prototype-Symbol-iterator"><a href="#String-prototype-Symbol-iterator" class="headerlink" title="String.prototype[Symbol.iterator]"></a>String.prototype[Symbol.iterator]</h3><p><code>Array.prototype[Symbol.iterator]</code> 와 같은 원리</p><h3 id="Object-prototype-Symbol-iterator"><a href="#Object-prototype-Symbol-iterator" class="headerlink" title="Object.prototype[Symbol.iterator]"></a>Object.prototype[Symbol.iterator]</h3><p>Object에는 Symbol.iterator가 없다. 때문에 for-of를 사용할 수 없다.<br>obj 내에 Symbol.iterator를 작성하면 반복 처리할 수 있다.</p><p><a name="10"></a></p><h2 id="10-Generator"><a href="#10-Generator" class="headerlink" title="10. Generator"></a>10. Generator</h2><p><a name="11"></a></p><h2 id="11-match-match-결과-반환"><a href="#11-match-match-결과-반환" class="headerlink" title="11. match(): match 결과 반환"></a>11. match(): match 결과 반환</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ECMAScript6 책 (두고두고 보는 자바스크립트 표준 레퍼런스)&lt;br&gt;정리중 입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0-Well-Known-Symbo
      
    
    </summary>
    
      <category term="01_DevTIL ✍" scheme="http://feel5ny.github.io/categories/01-DevTIL-%E2%9C%8D/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/01-DevTIL-%E2%9C%8D/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
      <category term="iterator" scheme="http://feel5ny.github.io/tags/iterator/"/>
    
      <category term="symbol" scheme="http://feel5ny.github.io/tags/symbol/"/>
    
  </entry>
  
  <entry>
    <title>ES6 Symbol 오브젝트</title>
    <link href="http://feel5ny.github.io/2019/02/03/JS_23/"/>
    <id>http://feel5ny.github.io/2019/02/03/JS_23/</id>
    <published>2019-02-03T14:20:19.000Z</published>
    <updated>2019-02-10T12:04:30.542Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h3><p>Symbol에 대해서 이해가 안갔는데 C언어의 enum과 비슷한 개념이라고 설명한 부분에서 살짝 감이 왔다. </p><hr><blockquote><p>ECMAScript6 책 (두고두고 보는 자바스크립트 표준 레퍼런스)<br>인프런 Javascript ES6+ 제대로 알아보기 – 중급 :: symbol</p></blockquote><hr><p>심볼은 3가지 형태로 사용할 수 있다.</p><ol><li><strong>Symbol()</strong>: Symbol 값을 생성하며 스코프 안에서 사용한다.</li><li><strong>Symbol.for()</strong>: 글로벌 Symbol registry에 저장되며 전체 프로그램에서 사용한다.</li><li><strong>Well-Known Symbol</strong>: 빌트인 Symbol 프로퍼티로 오버라이드하여 기능을 추가, 변경할 수 있다.</li></ol><p><a name="1"></a></p><h2 id="1-primitive"><a href="#1-primitive" class="headerlink" title="1. primitive"></a>1. primitive</h2><p>string, number, boolean은 레퍼(Wrapper) 오브젝트가 있다.</p><ul><li>string은 String</li><li>number는 Number</li><li>boolean은 Boolean</li><li>es6에서 symbol의 Symbol 오브젝트가 추가되었다.</li></ul><p>wrapper 오브젝트는 vlaueOf()로 프리미티브 값을 구할 수 있지만, symbol은 값을 반환하지 않는다.</p><hr><p><a name="2"></a></p><h2 id="2-Symbol"><a href="#2-Symbol" class="headerlink" title="2. Symbol()"></a>2. Symbol()</h2><p><code>Symbol([description])</code></p><ul><li>description: 설명, 주석</li><li>반환값: 유니크한 Symbol 값</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br></pre></td></tr></table></figure><ol><li>new 연산자를 사용하지 않는다.</li><li>Symbol()로 생성된 값은 프로그램 전체를 통해 유일하고, 값을 변경할 수 없다.(immutable)<ul><li><strong>C언어의 enum과 비슷한 개념이다.</strong></li></ul></li><li>생성한 Symobol에 프로퍼티를 설정할 수 없다.</li><li>반환자가 오브젝트가 아니므로, 오브젝트를 생성한다고 할 수 없다.<ul><li><strong>symbol값을 생성한다</strong>는 표현이 적절하다.</li></ul></li><li>String의 <code>&#39;&#39;</code>, Array의 <code>[]</code> 처럼 Symbol을 생성하는 리터럴이 없다.<ul><li>undefined와 null 처럼 <strong>그 자체가 값이 되는 것도 아니다.</strong></li><li><strong>함수로 호출해야 값을 생성하여 반환한다.</strong> <code>Symbol()</code></li></ul></li><li>Symbol()로 값을 생성하고 출력하면, Symbol()로 생성한 값을 반환하지 않고, Symbol 값을 생성했던 <code>형태를 반환한다.</code> 이는 symbol의 특징이다.</li><li><strong>Symbol값을 외부에 노출시키지 않는 것이 Symbol의 특징이다.</strong></li><li>Symbol()로 생성한 값의 설명이나 주석을 문자열로 작성한다.<br>Symbol값을 외부에 제공하지 않으므로 디버깅할 때 유용하다.<br>파라미터를 작성하지 않으면 <code>undefined</code>로 인식한다.</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">feature1: <span class="keyword">const</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line">feature6: sym              <span class="comment">// Symbol()</span></span><br><span class="line">feature_: <span class="keyword">typeof</span> sym       <span class="comment">// symbol</span></span><br><span class="line">feature8: <span class="built_in">Symbol</span>(<span class="string">"주석"</span>)    <span class="comment">// Symbole(주석)</span></span><br><span class="line">feature2: sym == Symbole() <span class="comment">// false</span></span><br></pre></td></tr></table></figure><hr><p><a name="3"></a></p><h2 id="3-Symbol-값-변경"><a href="#3-Symbol-값-변경" class="headerlink" title="3. Symbol 값 변경"></a>3. Symbol 값 변경</h2><ul><li>Symbol()로 생성한 Symbol값은 변경할 수 없다.</li><li>Symbol값에 문자열을 추가하고 싶을 경우 Symbol을 toString()이나 String()으로 변환한 후 연결해야한다.</li></ul><hr><p><a name="4"></a></p><h2 id="4-Symbol-오브젝트-생성"><a href="#4-Symbol-오브젝트-생성" class="headerlink" title="4. Symbol 오브젝트 생성"></a>4. Symbol 오브젝트 생성</h2><p>Object(123)처럼 Object()의 파라미터에 123을 지정하면 Number 오브젝트를 반환한다.</p><ul><li>Object() 파라미터에 Symbol 값을 지정하면 Symbol 오브젝트를 반환한다.</li><li>Symbol 오브젝트에 Symbol메서드, Symbol.prototype, protototype에 연결된 프로퍼티가 설정된다.</li></ul><hr><p><a name="5"></a></p><h2 id="5-오브젝트에서-Symbol-사용"><a href="#5-오브젝트에서-Symbol-사용" class="headerlink" title="5. 오브젝트에서 Symbol 사용"></a>5. 오브젝트에서 Symbol 사용</h2><p>유일한 값을 갖는 Symbol 특성을 활용하여<br>Symbol 값을 오브젝트의 프로퍼티 키로 사용하면 프로퍼티<br>키가 중복되지 않습니다.</p><h3 id="symbol-keyed-property"><a href="#symbol-keyed-property" class="headerlink" title="symbol-keyed property"></a>symbol-keyed property</h3><p><code>[Symbol()]</code>형태와 같이 대괄호 안에 Symbol()을 작성<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;[<span class="built_in">Symbol</span>()]: <span class="number">123</span>&#125;</span><br></pre></td></tr></table></figure></p><p>이렇게 프로퍼티 키에 작성한 Symbol()을 <strong><code>symbol-keyed property</code></strong>라고 한다.</p><ul><li><code>{ ABC: 123 }</code>에서 <code>ABC</code>에 Symbol값을 넣은 것이다.<br>여기서 Symbol값은 문자열이 아니라 그냥 <strong>Symbol값</strong>이라고 생각하면된다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">"123"</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;[sym]: <span class="string">"456"</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj);      <span class="comment">// &#123;Symbol(123): "456"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj[sym]); <span class="comment">// 456</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.sym);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>대괄호를 사용하지 않고 <code>obj.sym</code> 형태로 작성하면 에러는 안나지만 <code>undefined</code>가 반환된다.</p><ul><li>Symbol을 키로 갖는 프로퍼티를 <code>&lt;&lt;&gt;&gt;</code>형태로 표기하고 있다.</li></ul><hr><p><a name="6"></a></p><h2 id="6-Symbol-사용형태"><a href="#6-Symbol-사용형태" class="headerlink" title="6. Symbol 사용형태"></a>6. Symbol 사용형태</h2><p>for-in 문에서 symbol-keyed property는 열거되지 않는다.</p><ul><li>Symbol이 <code>[[Enumerable]]: false</code>이기 때문.<br><a href="https://feel5ny.github.io/2017/12/04/JS_05_1/">(객체의 데이터 프로퍼티에서 <code>[[Enumerable]]</code>은 기본적으로 true이다.)</a></li></ul><h3 id="6-1-for-in-문에서-Symbol-사용-외부스코프에서-의미없는-키값-gt-symbol화"><a href="#6-1-for-in-문에서-Symbol-사용-외부스코프에서-의미없는-키값-gt-symbol화" class="headerlink" title="6.1 for-in 문에서 Symbol 사용 (외부스코프에서 의미없는 키값 =&gt; symbol화)"></a>6.1 for-in 문에서 Symbol 사용 (외부스코프에서 의미없는 키값 =&gt; symbol화)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">nine</span>: <span class="number">999</span>&#125;;</span><br><span class="line">obj[<span class="built_in">Symbol</span>(<span class="string">"one"</span>)] = <span class="number">111</span>;</span><br><span class="line">obj[<span class="built_in">Symbol</span>(<span class="string">"two"</span>)] = <span class="string">"222"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;nine: 999, Symbol(one): 111, Symbol(two): "222"&#125;</span></span><br><span class="line"><span class="comment">// nine</span></span><br></pre></td></tr></table></figure><p>일반적으로 for-in문으로 객체를 순회하면서 symbol-keyd property는 접근할 수 없다.<br>때문에 객체의 고유한 식별자로써, 상수개념으로 사용한다.<br>외부 스코프에서 의미가 있지 않는 값들만 symbol화 시킨다.<br>은닉화의 목적이 있기때문에 외부 스코프에서는 접근가능하지 않아야하지만 <a href="&#39;#6-4&#39;">내부에서는 가능하도록 만들어야한다.</a></p><ul><li><code>Object.getOwnPropertySymbols()</code>를 사용하여 symbol-keyed property 키값들을 열거할 수 있다.</li><li><code>Reflect.ownKeys</code>를 사용하면 symbol-keyed property 키와 값까지 알 수 있다.</li></ul><h3 id="6-2-클래스-메서드-이름으로-Symbol-사용"><a href="#6-2-클래스-메서드-이름으로-Symbol-사용" class="headerlink" title="6.2 클래스 메서드 이름으로 Symbol 사용"></a>6.2 클래스 메서드 이름으로 Symbol 사용</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbolOne = <span class="built_in">Symbol</span>(<span class="string">"symbol one"</span>);</span><br><span class="line"><span class="keyword">const</span> symbolTwo = <span class="built_in">Symbol</span>(<span class="string">"symbol two"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sports</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [symbolOne]()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Symbol-1"</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  [symbolTwo]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Symbol-2"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Sports[symbolOne]());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> Sports();</span><br><span class="line"><span class="built_in">console</span>.log(obj[symbolTwo]());</span><br></pre></td></tr></table></figure><h3 id="6-3-JSON-stringify-에서-Symbol-사용"><a href="#6-3-JSON-stringify-에서-Symbol-사용" class="headerlink" title="6.3 JSON.stringify()에서 Symbol 사용"></a>6.3 JSON.stringify()에서 Symbol 사용</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">"key"</span>);</span><br><span class="line"><span class="keyword">let</span> result = <span class="built_in">JSON</span>.stringify(&#123;[sym]: <span class="string">"값"</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>빈 오브젝트가 반환된다.<br>이는 Symbol 값을 외부에 노출되지 않도록 하기 위한 조치이다.</p><p><a name="6-4"></a></p><h3 id="6-4-프로퍼티-은닉화"><a href="#6-4-프로퍼티-은닉화" class="headerlink" title="6.4 프로퍼티 은닉화"></a>6.4 프로퍼티 은닉화</h3><ul><li>symbol로 정의된 키값에는 바로 접근이 불가능하다.</li><li>키값이 들어있는 프로퍼티를 객체 내부에 적용해놓으면 심볼 키에 접근가능하다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [a]: <span class="number">10</span>,</span><br><span class="line">    a: a,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Symbol-for"><a href="#7-Symbol-for" class="headerlink" title="7. Symbol.for"></a>7. <code>Symbol.for</code></h2><p>public member 전역공간에서 공유되는 심볼.<br>여기저기서 많이 사용되는 공용상수를 사용할때 사용<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">Symbol</span>.for(<span class="string">'abc'</span>) </span><br><span class="line"><span class="comment">// 새로 생성해서 넣음.</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// "Symbol(abc)"</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">Symbol</span>.for(<span class="string">'abc'</span>) </span><br><span class="line"><span class="comment">// 기존에 'abc' 식별자로 되어있는 symbol을 찾아서 있으면 넣어준다.</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// "Symbol(abc)"</span></span><br><span class="line"></span><br><span class="line">a === b <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>?!<br>a와 b가 값과 타입이 같다고 나온다.<br><code>Symbol.for</code>는 for의 인자를 식별자로 사용한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> COMMON1 = <span class="built_in">Symbol</span>.for(<span class="string">'공유심볼'</span>)</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">[COMMON1]: <span class="string">'공유할 프로퍼티 키값. 어디서든 접근 가능'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">obj1[<span class="built_in">Symbol</span>.for(<span class="string">'공유심볼'</span>)]</span><br><span class="line"><span class="comment">// "공유할 프로퍼티 키값. 어디서든 접근 가능"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Comment&quot;&gt;&lt;a href=&quot;#Comment&quot; class=&quot;headerlink&quot; title=&quot;Comment&quot;&gt;&lt;/a&gt;Comment&lt;/h3&gt;&lt;p&gt;Symbol에 대해서 이해가 안갔는데 C언어의 enum과 비슷한 개념이라고 설명한 부분에서
      
    
    </summary>
    
      <category term="01_DevTIL ✍" scheme="http://feel5ny.github.io/categories/01-DevTIL-%E2%9C%8D/"/>
    
      <category term="Javascript" scheme="http://feel5ny.github.io/categories/01-DevTIL-%E2%9C%8D/Javascript/"/>
    
    
      <category term="javascript" scheme="http://feel5ny.github.io/tags/javascript/"/>
    
      <category term="symbol" scheme="http://feel5ny.github.io/tags/symbol/"/>
    
  </entry>
  
  <entry>
    <title>코드스피츠77 ES6_4회차_Abstract loop &amp; lazy execution</title>
    <link href="http://feel5ny.github.io/2019/02/03/JS_20/"/>
    <id>http://feel5ny.github.io/2019/02/03/JS_20/</id>
    <published>2019-02-03T11:20:19.000Z</published>
    <updated>2019-02-11T09:11:34.983Z</updated>
    
    <content type="html"><![CDATA[<p>🌕🌑🌑</p><h3 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h3><p>복습할때나 이 문제가 까먹었을 즈음에 풀어보기</p><ol><li>iterable객체 완성하기<br><code>???</code> 구해보기<br>(2가지 방법으로)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]()&#123;<span class="keyword">return</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">  data: [&#123;<span class="attr">a</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], <span class="attr">b</span>:<span class="string">'-'</span>&#125;, [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>], <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">  next()&#123;</span><br><span class="line">    <span class="keyword">return</span> ???</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>코드스피츠 강의 정리록입니다.</p></blockquote><hr><h3 id="4강-키워드-Generator의-지연실행-측면과-이를-위한-추상루프화"><a href="#4강-키워드-Generator의-지연실행-측면과-이를-위한-추상루프화" class="headerlink" title="4강 키워드: Generator의 지연실행 측면과 이를 위한 추상루프화"></a>4강 키워드: Generator의 지연실행 측면과 이를 위한 추상루프화</h3><hr><p><a name="1"></a></p><h2 id="1-abstract-loop-루프의-추상화"><a href="#1-abstract-loop-루프의-추상화" class="headerlink" title="1. abstract loop: 루프의 추상화"></a>1. abstract loop: 루프의 추상화</h2><p><a name="1-1"></a></p><h3 id="1-1-complex-recursion-복잡한-반복"><a href="#1-1-complex-recursion-복잡한-반복" class="headerlink" title="1.1 complex recursion 복잡한 반복"></a>1.1 complex recursion 복잡한 반복</h3><p>단순한 배열 루프인 경우 간단히 이터레이션을 작성할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]()&#123;<span class="keyword">return</span> <span class="keyword">this</span>;&#125;,</span><br><span class="line">  data:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], </span><br><span class="line">  next()&#123;</span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">       done:<span class="keyword">this</span>.data.length == <span class="number">0</span>,</span><br><span class="line">       value:<span class="keyword">this</span>.data.shift()</span><br><span class="line">    &#125;; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="복잡한-다층형-그래프는-어떻게-이터레이션-할-것인가"><a href="#복잡한-다층형-그래프는-어떻게-이터레이션-할-것인가" class="headerlink" title="복잡한 다층형 그래프는 어떻게 이터레이션 할 것인가?"></a>복잡한 다층형 그래프는 어떻게 이터레이션 할 것인가?</h4><p>es6와 es6이전의 객체 리터럴의 큰 차이점이 무엇인가 </p><ol><li>es6이전<ul><li>기존의 객체 리터럴에서는 객체 리터럴의 순서가 없다.</li><li>자바로 따지면 hash memory로 되어있다.</li></ul></li><li>es6<ul><li>es6의 객체 리터럴은에서는 객체 리터럴의 순서가 있다.</li><li><strong>linked hash memory</strong>로 되어있다.</li><li>반드시 순서대로 해석된다.</li></ul></li></ol><h4 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]()&#123;<span class="keyword">return</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">  data: [&#123;<span class="attr">a</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], <span class="attr">b</span>:<span class="string">'-'</span>&#125;, [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>], <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">  next()&#123;</span><br><span class="line">    <span class="keyword">return</span> ???</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="생각해보기-글쓴이-생각"><a href="#생각해보기-글쓴이-생각" class="headerlink" title="생각해보기 (글쓴이 생각..)"></a>생각해보기 (글쓴이 생각..)</h5><ol><li>iterable 프로토콜 유지하기 </li><li>배열 요소들의 타입 검사 <ol><li>객체일 경우<br>객체 내부 키값의 요소들의 타입 검사 <ol><li>객체일 경우</li><li>배열일 경우 </li><li>일반 값인 경우<br>=&gt; 처음 타입 검사와 같은 흐름이므로 해당 flow를 recursive 되도록 한다. <ul><li>어떻게 같은 루프를 다시 태우지..</li></ul></li></ol></li><li>배열일 경우<br>배열 요소의 타입 검사<ol><li>객체일 경우</li><li>배열일 경우 </li><li>일반 값인 경우<br>=&gt; 처음 타입 검사와 같은 흐름이므로 해당 flow를 recursive 되도록 한다. <ul><li>어떻게 같은 루프를 다시 태우지..</li></ul></li></ol></li><li>일반 값인 경우<br>값 반환 </li></ol></li></ol><hr><h5 id="cf-1-루프를-어떻게하면-잘-짤-수-있을까"><a href="#cf-1-루프를-어떻게하면-잘-짤-수-있을까" class="headerlink" title="cf__1. 루프를 어떻게하면 잘 짤 수 있을까."></a>cf__1. 루프를 어떻게하면 잘 짤 수 있을까.</h5><p>루프를 잘 짜고<br>보다 어려운 로직을 짜는 방법은<br><strong>내 머리가 선언한 변수만큼을 추적할 수 있어야 한다…</strong></p><p>기본적인 알고리즘 전략은 최대한 상태를 덜쓰는것. 내 머리가 추적할 정도로..</p><hr><h4 id="정답"><a href="#정답" class="headerlink" title="정답"></a>정답</h4><p>각각이 컨테이너 형이라면<br>그 컨테이너를 다시 해체해서 다시 배열에 붙여준다.<br>더 이상 컨테이너 형이 아닐 때까지<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 프로토콜만 맞춰주면 된다.</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   done: boolean,</span></span><br><span class="line"><span class="comment">//   value: 출력값..</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]()&#123;<span class="keyword">return</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">  data: [&#123;<span class="attr">a</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], <span class="attr">b</span>:<span class="string">'-'</span>&#125;, [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>], <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">  next()&#123;</span><br><span class="line">    <span class="keyword">let</span> v;</span><br><span class="line">    <span class="keyword">while</span>(v = <span class="keyword">this</span>.data.shift()) &#123;</span><br><span class="line">      <span class="comment">// shift가 더이상 안되면 undefined</span></span><br><span class="line">      <span class="keyword">switch</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">Array</span>.isArray(v):</span><br><span class="line">          <span class="comment">// 2번째 케이스문의 객체 타입가드 조건문이 array 타입도 포함되므로, array만을 위한 조거문을 먼저 작성한다.</span></span><br><span class="line">          <span class="keyword">this</span>.data.unshift(...v);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> v &amp;&amp; <span class="keyword">typeof</span> v === <span class="string">'object'</span>:</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> v) <span class="keyword">this</span>.data.unshift(...x);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> &#123;<span class="attr">value</span>:v, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="정답-내의-오류"><a href="#정답-내의-오류" class="headerlink" title="정답 내의 오류"></a>정답 내의 오류</h5><p><code>for(var k in v)</code></p><ol><li><p>for…in문은 <strong>prototype의 key까지 다 나오기 때문에</strong> <code>hasOwnProperty</code>를 조건에 추가해야한다.</p><ul><li>hasOwnProperty는 자신의 고유 속성, 즉 상속받은 프로퍼티가 아닌 순수 자신의 속성인 경우에만 true라는 값을 반환하는 특징이 있습니다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> v)&#123;</span><br><span class="line">  <span class="keyword">if</span>(v.hasOwnProperty(k)) <span class="keyword">this</span>.data.unshift(...x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>현재 상태에서는 순서 보장이 안된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> v) x.push(v[k])</span><br><span class="line"><span class="keyword">this</span>.data.unshift(...x);</span><br></pre></td></tr></table></figure></li></ol><hr><h5 id="한번더-리팩토링"><a href="#한번더-리팩토링" class="headerlink" title="한번더 리팩토링"></a>한번더 리팩토링</h5><p>값인 타입을 <code>v instanceof Object</code>로 판단할 수 있다!<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]()&#123;<span class="keyword">return</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">  data: [&#123;<span class="attr">a</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], <span class="attr">b</span>:<span class="string">'-'</span>&#125;, [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>], <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">  next()&#123;</span><br><span class="line">    <span class="keyword">let</span> v;</span><br><span class="line">    <span class="keyword">while</span>(v = <span class="keyword">this</span>.data.shift()) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!(v <span class="keyword">instanceof</span> <span class="built_in">Object</span>)) <span class="keyword">return</span> &#123;<span class="attr">value</span>: v&#125;;</span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(v)) v = <span class="built_in">Object</span>.values(v);</span><br><span class="line">      <span class="keyword">this</span>.data.unshift(...v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h4><p>자바스크립트 언어는 2가지로 되어있다. </p><ol><li>언어자체의 문법적인 내용, </li><li>클래스 라이브러리<br>자바스크립트의 클래스 라이브러리는 <strong>코어객체</strong> (Built-in)<br>Math, Date, RegEx…<br>=&gt; 표준으로 제공되고 있는 언어 표준의 일부<br>=&gt; 언어 스팩의 일부</li></ol><p><strong>코어객체에 있는 메서드들을 사용하는 것이<br>기본 언어자체의 문법을 사용하는 것보다 더 안전하다.</strong><br>ex. for..in보다 Object.values</p><blockquote><p><strong>재사용성 올리기</strong><br><code>unshift</code>나 <code>shift</code>로 인해서 data의 배열이 빈배열이 되는 상황이 된다.<br>클래스로 묶어서 매번 부를때마다 인스턴스를 반환하는 형태로 만들자.</p></blockquote><h5 id="cf-2-함수를-변수에-할당하자"><a href="#cf-2-함수를-변수에-할당하자" class="headerlink" title="cf__2. 함수를 변수에 할당하자."></a>cf__2. 함수를 변수에 할당하자.</h5><p>함수를 정의할때 3가지 스타일</p><ol><li>함수 표현식 </li><li>함수 선언문</li><li>Function…</li></ol><p>함수는 값이기 때문에 변수에 할당하는 형식이 맞다. 더 정확하게 호이스팅에 의존하지 않고 어느 시점에 함수를 만들었다를 명확하게 코드로 인지할 수 있기 때문에 function으로 시작하는 함수 정의방법은 아예 금지시키고 못쓰게 하는 경우가 많다. lint에도 함수선언문 금지룰이 있다.</p><p>클래스도 하나의 값이다. 변수에 할당이 된다. 변수의 할당 없이 class..로 시작하는 선언방법은 이 클래스가 언제 만들어졌는지 모호하게 만드는 관점이 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Compx = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(data) &#123;<span class="keyword">this</span>.data = data;&#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.data));</span><br><span class="line">    <span class="comment">// 완전한 복사. 가장빨리 복사하는 방법..</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next()&#123;</span><br><span class="line">        <span class="keyword">let</span> v;</span><br><span class="line">        <span class="keyword">while</span>(v = data.shift())&#123;</span><br><span class="line">          <span class="keyword">if</span>(!(v <span class="keyword">instanceof</span> <span class="built_in">Object</span>)) <span class="keyword">return</span> &#123;<span class="attr">value</span>:v&#125;;</span><br><span class="line">          <span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(v)) v = <span class="built_in">Object</span>.values(v);</span><br><span class="line">          data.unshift(...v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">true</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Compx([&#123;<span class="attr">a</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], <span class="attr">b</span>:<span class="string">'-'</span>&#125;, [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>], <span class="number">8</span>, <span class="number">9</span>]);</span><br><span class="line"><span class="built_in">console</span>.log([...a]);</span><br><span class="line"><span class="built_in">console</span>.log([...a]);</span><br></pre></td></tr></table></figure><p>shift를 사용하는 것은 data가 배열이 와야하는 조건이 있기 때문에<br>data의 사본을 만들때 아예 배열화시킨다.<br><code>const data = [JSON.parse(JSON.stringify(this.data));]</code></p><p>if절을 보면 mandatory가 아닌 optional.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Compx = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(data) &#123;<span class="keyword">this</span>.data = data;&#125;</span><br><span class="line">  *gene()&#123;</span><br><span class="line">    <span class="keyword">const</span> data = [<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.data))];</span><br><span class="line">    <span class="keyword">let</span> v;</span><br><span class="line">    <span class="keyword">while</span>(v = data.shift())&#123;</span><br><span class="line">      <span class="keyword">if</span>(!(v <span class="keyword">instanceof</span> <span class="built_in">Object</span>)) <span class="keyword">yield</span> v;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(v)) v = <span class="built_in">Object</span>.values(v);</span><br><span class="line">        data.unshift(...v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">co