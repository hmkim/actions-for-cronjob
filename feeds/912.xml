<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Cho Eun on Medium]]></title>
        <description><![CDATA[Stories by Cho Eun on Medium]]></description>
        <link>https://medium.com/@euncho?source=rss-680d76e79c0e------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*rWr6lzT5Ce1UGmteY0YPYw.jpeg</url>
            <title>Stories by Cho Eun on Medium</title>
            <link>https://medium.com/@euncho?source=rss-680d76e79c0e------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Tue, 14 May 2019 02:17:49 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@euncho" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[How I used Chrome Performance Panel (Part 1)]]></title>
            <link>https://medium.com/@euncho/how-i-used-chrome-performance-panel-part-1-765771ec0393?source=rss-680d76e79c0e------2</link>
            <guid isPermaLink="false">https://medium.com/p/765771ec0393</guid>
            <category><![CDATA[chrome-dev-tools]]></category>
            <category><![CDATA[web-development]]></category>
            <dc:creator><![CDATA[Cho Eun]]></dc:creator>
            <pubDate>Fri, 08 Feb 2019 05:25:03 GMT</pubDate>
            <atom:updated>2019-02-09T18:34:58.382Z</atom:updated>
            <content:encoded><![CDATA[<h3>How I use the Chrome Performance Panel (Part 1)</h3><p>Chrome is the most popular browser in the world. In South Korea, Still many users use Internet Explorer (include IE 10 ~), but nowadays Chrome users are increasing.</p><p>My team created a WYSYWIG editor service that can be using at NAVER blog. This is my NAVER blog: <a href="https://blog.naver.com/apes0113">https://blog.naver.com/apes0113</a>, Many Koreans are using the NAVER blog.</p><p>When we opened our renewed Editor at last December, we were touched Performance problems at Internet Explorer. However, as you know, IE DevTools is terrible.</p><p>So we are using Chrome DevTools to measure our Performance Problems.</p><h4>Performance Panel</h4><p>First, You need to open Chrome and move to your websites. Then, on your DevTools, you can open the <strong>Performance</strong> Tab.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*x-E_M0IwJclJYkaGkT0TiQ.png" /><figcaption>Figure 1. Chrome DevTools Performance Tab</figcaption></figure><p>There are some ways to record your websites speed.</p><ol><li>Record <strong>your interactions</strong> on the web application. using the 🔴 button</li><li>Record <strong>first loading performance </strong>on the web application. using the 🔄 button</li></ol><p><strong>First loading performance</strong> is essential when users are access to your web application. You can read the useful article at Google Developers like <a href="https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics">User-centric Performance Metrics</a>.</p><p>You click 🔄 button, then Chrome reloads your web applications and record page performance. For example, I measure blog editor service.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*CX9QXJuPd9BdX2KhmRPEhA.png" /><figcaption>Figure 2. Measuring example on the Performance tab</figcaption></figure><p>When you measure your web applications, may, your devices are better than real users. This is one of my big mistakes when I measure web performance. When I measure my web applications, Everything is OK because I used iMac to measure web applications. You can use CPU throttle for slow down your Web application.</p><p>Moreover, also I recommend using Secret mode because extensions will load scripts and resources that will create some confusion.</p><p>The right top side of your DevTools, You can see the ⚙ Icon. You click that, the extent layer will open. You can choose the option when you measure your web site.</p><ol><li>Disabled JavaScript Samples</li><li>Enable advanced paint instrumentation (This option can see <a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference#layers">layer Information</a> and <a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference#paint-profiler">paint profiler</a>)</li><li>Network Throttle</li><li>CPU Throttle (4x, 6x)</li></ol><p>My team was touched Performance problem at IE, So we used 6x CPU slowdown and measure performance.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*BRqohnmkHZh7zFjn6iIIxQ.png" /><figcaption>Figure 3. measure performance with 6x slowdown</figcaption></figure><p>There are four parts that can see your web page’s performance.</p><ol><li>Network</li><li>Frames</li><li>Interactions</li><li>Main</li></ol><p><strong>Network </strong>shows network request in your web application. You click Network tab and can see your network request.</p><p><strong>Frames </strong>show your pages frame information if you are using the frame.</p><p><strong>Interactions </strong>show what interactions happened when you record your web applications. That also includes <strong>Animation information</strong>.</p><p><strong>Main </strong>shows how Chrome renders your web pages, and this is the most critical part of the Performance.</p><ol><li>Loading (Loading resources)</li><li>Scripting (parse and evaluate JavaScript)</li><li>Rendering (Rendering DOM)</li><li>Painting (Paint the DOM)</li><li>Other</li><li>Idle</li></ol><p>So If you measure your websites in development, you can measure your site’s speed and can find what makes slow down your websites.</p><p>Using the 🔴 button, You can measure <strong>performance more deeply</strong>. You click 🔴 button then Chrome record your interactions on the web applications and What happened when you interact your web pages elements.</p><p>For example, I clicked some nodes on the editor service.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*qoOEDDmKuX6v50KImEikKQ.png" /><figcaption>mouse down and mouse up event happen and script work</figcaption></figure><p>You can see Mouse Down and Mouse Up events, and you can check what happened when you click nodes. Some parts are in the library (We are using React and MobX), Some parts are in my script codes.</p><p>Next Time, We will find how can we remove some unused parts and how my team could improve the Rendering speed.</p><h4>IE MAGIC</h4><p>We were using the custom cursor for showing <strong>cursor: grab</strong>. But in the Internet Explorer, When using the custom cursor, it will slow down cause using that.</p><figure><img alt="Image result for fucking css" src="https://cdn-images-1.medium.com/proxy/1*ZPlE0Td0GCO2mt3Ivrmp5g.gif" /></figure><p>So we remove custom cursor, then we improved our page speed.</p><p>If you have any question about this article, please comment that! I will reply to you. Thank you for reading and see you soon.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=765771ec0393" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Project visBug]]></title>
            <link>https://medium.com/@euncho/project-visbug-61a1b6dc1ace?source=rss-680d76e79c0e------2</link>
            <guid isPermaLink="false">https://medium.com/p/61a1b6dc1ace</guid>
            <category><![CDATA[chrome]]></category>
            <category><![CDATA[front-end-developer]]></category>
            <category><![CDATA[project-visbug]]></category>
            <category><![CDATA[web-designer]]></category>
            <category><![CDATA[chrome-extension]]></category>
            <dc:creator><![CDATA[Cho Eun]]></dc:creator>
            <pubDate>Wed, 14 Nov 2018 18:21:39 GMT</pubDate>
            <atom:updated>2018-11-15T01:17:36.518Z</atom:updated>
            <content:encoded><![CDATA[<p>#ChromeDevSummit2018</p><p>ProjectVisBug는 2018년 Chrome Dev Summit에서 공개된 Visual design Toolkit이다. 현재는 Chrome Extension으로 공개되어있으며 Firefox Extension으로도 공개될 예정이다.</p><p>Download:</p><p><a href="https://chrome.google.com/webstore/detail/visbug/cdockenadnadldjbbgcallicgledbeoc">VisBug</a></p><p>GitHub:</p><p><a href="https://github.com/GoogleChromeLabs/ProjectVisBug">GoogleChromeLabs/ProjectVisBug</a></p><p>회사에서 디자이너와 개발자가 협업을 하다보면 불협화음이 참 많이 생긴다. CSS를 한번이라도 다뤄본 사람이라면 알겠지만 스타일 하나를 수정했을 때 발생할 수 있는 사이드 이펙트는 예상하기가 힘들고 (물론 예상가능한 것도 있다), 반대로 디자이너는 본인이 디자인한 것과 다른 사이트가 나오는 것에 대해서 불만을 가지기도 한다.</p><p>Photoshop으로 디자인을 하던 시대와는 다르게 지금은 Sketch로 디자인을 해서 Zeplin으로 공유를 하는 Flow가 상당히 정착된 느낌이다. 거기에 더 나아가서 ProtoPie, Framer, Adobe XD 등 다양한 prototype 도구가 나타나면서 웹에서의 인터렉션을 어떻게 부여할 지에 대해서도 디자이너와 개발자가 면밀히 협의할 수 있게 되었다.</p><p>하지만 Zeplin을 사용하던 Pramer를 사용하던 개발자가 개발한 결과물이 디자이너가 원하던 것과 다른 경우는 흔한 일이다. Chrome DevTools에 익숙한 사람이라면 요소를 선택해서 스타일을 수정하거나 HTML을 수정하는 행위가 편리하겠지만 그렇지 않다면 요소를 선택해서 수정하는 행위는 꽤나 어려운 일이다.</p><p><strong>Project VisBug</strong>는 “만약 Sketch에서처럼 요소를 선택해서 수정할 수 있다면 어떨까?” 라는 느낌으로 접근한 Visual Design Toolkit이다. 11월 12일 Chrome Dev Summit Keynote에서 공개되었으며 현재 Chrome Web Store에서 설치 가능하다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/512/0*pP5lPK-Ax0XXSX18.png" /><figcaption>Project VisBug</figcaption></figure><p>VisBug를 웹에서 실행시키면 다른 비주얼 툴에서 나타나는 것처럼 좌측에 Toolbar가 나타나며, Toolbar의 각 기능을 통해 웹 사이트를 제어할 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*oMyB-gZpZSzktvczTIqf_Q.png" /><figcaption>NAVER 메인에서 VisBug를 실행시킨 화면</figcaption></figure><p>툴바에서 마우스를 올려두고 있으면 해당 버튼이 어떤 기능인 지 알려주는 툴팁이 노출된다. 예를 들어 첫번째 아이템은 Guides로 특정한 요소의 그리드와 정렬을 확인할 수 있게 도와준다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/912/1*qXYO9MpGc8IENSbbq-fFFw.png" /><figcaption>Guides</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/744/1*1chZPJa0wLfQIlR36tAHZw.png" /><figcaption>해당 요소의 Grid를 살펴볼 수 있다.</figcaption></figure><p>현재 Toolbar에서 제공하는 기능은 다음과 같다.</p><h4>Guides</h4><p>정렬과 Grid를 체크한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*XTB30elKmFU4wNchXtcueA.png" /><figcaption>Guides</figcaption></figure><h4><strong>Inspect</strong></h4><p>요소의 공통 &amp; 현재 적용된 스타일을 볼 수 있다. (여기가 span으로 감싸져있단 걸 오늘 처음 알았다)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/734/1*yg4ZbJ9YnnEz5Hak_HwJVg.png" /><figcaption>Instpect</figcaption></figure><h4><strong>A11y</strong></h4><p>해당 요소의 접근성과 관련된 속성 및 현재 준수 여부를 나타낸다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/392/1*GDjCfECNK8drSHnIWtY9fA.png" /><figcaption>A11y</figcaption></figure><h4><strong>Move</strong></h4><p>요소를 이동시킨다. 특정 요소를 선택 후 화살표로 이동시킬 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/696/1*6cPh6yTBlVoAJ0110emqoA.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Ki1VTEtGHhczFCuhgXY1SA.png" /><figcaption>부모 탭의 기본 그리드</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*pwFgksizvL12_MxKM_rdyQ.png" /><figcaption>이것 저것 이동시켜봤다. (찾아보시길)</figcaption></figure><h4><strong>Margins &amp; Padding</strong></h4><p>둘은 서로 다른 버튼이지만 비슷하니까 하나로 묶어서 설명하겠다. 말 그대로 Margin과 Padding을 늘리고 줄인다. 위와 동일하게 화살표로 제어한다. 참고로 Shift와 함께 제어하면 5px씩 늘어난다.</p><p>1~2px 차이로 고통받는 디자이너들에게 많은 도움이 될 거 같다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/700/1*Vj9XIB-oFT-vSZlWXVrNaQ.png" /><figcaption>Control Margins</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/700/1*DwRanS2A-mgqwb1ECpe9NQ.png" /><figcaption>Contol Padding</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*mhgPgyZKYdJbErGoAWb9UA.png" /><figcaption>Margin을 열심히 늘려보았다.</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*depfwPu56LlGxUWPmwAt6A.png" /><figcaption>Padding을 열심히 늘려보았다.</figcaption></figure><p>Padding과 Margin은 Box Model에 직접적으로 영향을 주기 때문에 위 두 속성을 제어함으로써 레이아웃을 맞추고 이상한 픽셀을 맞추는 데 도움이 될 거라 생각한다.</p><h4><strong>Flexbox Align</strong></h4><p>Flex속성을 이용하여 요소의 정렬을 수정한다. flex의 정렬, justify, direction을 수정할 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/698/1*Yqvnytq-Pn_EM4omm7aiJg.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*3KVFr-1Y61BlIMCjngf7gg.png" /><figcaption>flex-direction을 column으로 수정했다.</figcaption></figure><h4><strong>Hue Shift</strong></h4><p>HSL (Hue, Saturate, Lightness)를 제어하여 특정한 요소의 색상을 다른 색상으로 변경할 수 있다. 마찬가지로 화살표로 제어한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/688/1*SHxT2bjlG71wmH9JYPW5Hg.png" /><figcaption>Control H,S,L(Brightness), Opacity</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/718/1*pTJQhmkPJoRcsAWZgRPPQA.png" /><figcaption>원래 검은색이던 요소를 다른 색으로 변경하였다.</figcaption></figure><h4>Shadow</h4><p>그림자 (box-shadow)를 제어한다. 마찬가지로 방향키로 제어할 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/692/1*qONbwSQNH1SRUEJfaLUYYg.png" /><figcaption>Control Shadows</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/726/1*LnVcDJ2XWRGVZMEByqsy3g.png" /><figcaption>한 요소에만 Shadow를 넣어보았다. 어색하다</figcaption></figure><h4><strong>Position</strong></h4><p>특정한 요소를 이동시킨다. 마우스로 클릭 후 아무 곳에나 이동시키면 된다. 동작 방식은 <strong>position: relative</strong>에 좌표로 이동시키는 듯 하다. (코드 까봤다) 특정한 요소의 위치가 애매할 때 체크해보면 좋을 거 같다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*8kDzP5zm4cvxK-Vb82nFGQ.png" /><figcaption>수능 화이팅</figcaption></figure><h4><strong>Font Styles</strong></h4><p>font와 관련된 속성을 제어한다. font-size (Size), font-align (Alignment), line-height (Leading), letter-spacing (Kerning), font-weight (Weight)를 제어한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/694/1*7_qp3p8bJk7Rv9oe3TPVQQ.png" /><figcaption>Control Fonts</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*JKyM0Yizkli5cXmmY0SgIQ.png" /><figcaption>폰트 사이즈를 좀 키워보았다. (어디인 지 한눈에 보인다)</figcaption></figure><h4>Edit Text</h4><p>마지막으로 텍스트를 편집할 수 있다. 해당 요소를 클릭한 후 수정하면 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/548/1*5DbOrHjrcQxa8dEpioPEMg.png" /><figcaption>“마미손 매드클라운” 이라는 텍스트를 수정했다.</figcaption></figure><p>Project VisBug의 기능들을 살펴보았다. 어떤 기능들은 유용할 수도, 어떤 기능들은 이게 왜 있는 지 모를 수도 있지만 Chrome DevTools를 이용해서 각 요소들을 제어하던 사람들이라면 한번쯤 사용해보면 좋을 듯 하다.</p><p>개발자 입장에서는 이 도구를 사용한다고 해서 모든 문제가 해결되지는 않는다. 해당 요소에 대해서만 제어하기 때문에 CSS에서 특정 셀렉터를 수정했을 때 다른 요소에 미치는 영향을 체크해보기 힘들고, 해당 요소만 수정하는 행위는 페이지 전체의 짜임새를 파괴하는 경우도 있기 때문이다.</p><p>하지만 디자이너와 함께 협업할 때 어떤 지점에서 문제가 있고, 이 문제를 어떻게 해결해볼 수 있는 지 관측해보고 싶을 때 더할나위 없이 좋을 거 같고, 특정한 요소의 수정이 다른 요소에 어떻게 영향을 미치는 지에 대해서 살펴볼 때 좋을 거라 생각한다.</p><p>현재 완벽하게 개발이 완료된 상태가 아니기 때문에 더 지켜봐야겠지만, 앞으로의 업데이트가 기대되는 도구임에는 틀림 없다고 생각한다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=61a1b6dc1ace" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[CSS Filter]]></title>
            <link>https://medium.com/@euncho/css-filter-aee094d474c8?source=rss-680d76e79c0e------2</link>
            <guid isPermaLink="false">https://medium.com/p/aee094d474c8</guid>
            <category><![CDATA[css]]></category>
            <dc:creator><![CDATA[Cho Eun]]></dc:creator>
            <pubDate>Mon, 15 Oct 2018 02:47:47 GMT</pubDate>
            <atom:updated>2018-10-15T02:47:47.195Z</atom:updated>
            <content:encoded><![CDATA[<p>웹에서 이미지를 제어하는 경우는 이제 꽤나 흔한 일이다. 보통 이미지를 제어하는 경우에는 서버에서 이미지를 처리한 후 처리된 이미지를 받아서 사용하는 로직을 많이 사용하나, 일부 표현 방식에 따라서 흑백이었던 이미지를 컬러로 바꾼다던가, Blur 이미지를 Clear하게 만드는 등의 표현 방식을 사용할 수도 있다.</p><p>CSS Filter는 CSS를 이용해서 요소에 Filter를 넣어주는 속성으로 (당연히) IE에서는 지원되지 않고 모던 브라우저에서만 지원하고 있다.</p><p><strong>브라우저 호환성:</strong></p><p><a href="https://caniuse.com/#search=CSS%20Filter">Can I use... Support tables for HTML5, CSS3, etc</a></p><p>먼저 지원되는 속성을 하나하나 살펴보면서 Filter에 대해 이해해보도록 하자.</p><h4>blur</h4><p>blur 속성은 요소를 뿌옇게 만들기 위해 사용한다.</p><pre>.target {<br>  filter: blur(5px)<br>}</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/896/1*ejNj4a-uIc6VixD7cUtxSg.png" /><figcaption>blur를 주지 않은 박스와 준 박스의 차이</figcaption></figure><h4>brightness</h4><p>brightness는 이미지의 밝기를 조절한다. 숫자가 크면 클 수록 이미지가 밝아진다.</p><pre>.filter-1 {<br> filter:brightness(50%)<br>}<br>.filter-2 {<br> filter:brightness(150%)<br>}<br>.filter-3 {<br> filter:brightness(200%)<br>}</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*P6BmaIY4MhX8qMUy4YtUqg.png" /></figure><p>실제 이미지를 편집할 때에도 밝기를 저렇게 마구잡이로 조절하지는 않고 소숫점 단위로 조절하기 때문에 어두운 이미지를 활용할 때 유용하게 활용할 수 있다.</p><h4>contrast</h4><p>contrast는 이미지의 대비를 조절한다. 숫자가 커질수록 더 큰 대비를 준다.</p><pre>.filter-1 {<br> filter:contrast(50%)<br>}<br>.filter-2 {<br> filter:contrast(150%)<br>}<br>.filter-3 {<br> filter:contrast(200%)<br>}</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*3oOmw7N1aBJ4xNowlhNKEg.png" /></figure><h4>saturate</h4><p>saturate는 이미지의 채도를 조절한다. 숫자가 높을 수록 이미지의 색상이 더욱 풍부해지고, 숫자가 적을 수록 이미지의 색상이 줄어든다. saturate(0) 은 grayscale(100%)와 동일하다.</p><pre>.filter-1 {<br> filter:saturate(0%)<br>}<br>.filter-2 {<br> filter:saturate(150%)<br>}<br>.filter-3 {<br> filter:saturate(200%)<br>}</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*463wdAvoxgYPRT3J03sEmg.png" /></figure><h4>grayscale</h4><p>grayscale은 이미지의 흑백여부를 정한다. 100% 까지만 사용이 가능하며 100%인 경우 완벽한 흑백을 의미한다.</p><pre>.filter-1 {<br> filter:grayscale(25%)<br>}<br>.filter-2 {<br> filter:grayscale(50%)<br>}<br>.filter-3 {<br> filter:grayscale(100%)<br>}</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*HuPK5J0qMquZ9EEhVWGBjA.png" /></figure><h4>opacity</h4><p>opacity는 이미지의 투명도를 정한다. opacity 속성을 사용한 것과 매우 유사하게 동작한다.</p><pre>.filter-1 {<br>  filter:opacity(50%)<br>}<br>.filter-2 {<br>  filter:opacity(15%)<br>}</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*b_zwTV4C9bnCbzXiYaUphQ.png" /></figure><p>일단 여기까지 작성하고 추후에 sepia, invert 등을 소개하도록 하겠다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=aee094d474c8" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[HTML Priority hints]]></title>
            <link>https://medium.com/@euncho/html-priority-hints-6721bf45fe4b?source=rss-680d76e79c0e------2</link>
            <guid isPermaLink="false">https://medium.com/p/6721bf45fe4b</guid>
            <category><![CDATA[html]]></category>
            <dc:creator><![CDATA[Cho Eun]]></dc:creator>
            <pubDate>Sun, 14 Oct 2018 02:11:34 GMT</pubDate>
            <atom:updated>2018-10-14T02:14:37.631Z</atom:updated>
            <content:encoded><![CDATA[<p>HTML로 개발하다보면 많은 리소스를 외부에서 가져와서 사용하게 됩니다. Script, CSS, Images, Videos 등 많은 리소스를 외부에서 불러오게되고, 리소스가 많아질수록 리소스의 다운로드양이 많아지고 따라서 전체 리소스를 불러오는 데에 시간이 걸리게 됩니다.</p><p>HTML에서 모든 리소스는 동일한 레벨이기 때문에, 그 리소스가 이미지건 스크립트건 상관없이 작성된 순서대로 파일을 불러오게 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*UAJ_MilZzZs5Z6VgDxtQkw.png" /><figcaption>로딩 순서. HTML을 해석한 순서대로 리소스를 불러오게된다.</figcaption></figure><p>리소스의 로딩은 웹 어플리케이션 전체 동작과 이슈가 되는 경우가 있는데, 예를 들어 JavaScript로 구성한 SPA (Single Page Application)같은 경우에는 스크립트가 로딩되지 않은 경우 화면에 아무것도 노출되지 않을 수 있고, 서비스에 따라서 이미지나 비디오가 먼저 로딩되어야하는 경우가 있을 수도 있다.</p><p>HTML Priority hints는 리소스의 우선순위를 정하기 위해 나온 HTML 스펙이다.</p><p><a href="https://github.com/WICG/priority-hints/blob/master/EXPLAINER.md">WICG/priority-hints</a></p><p>현재는 Chrome Canary에서만 지원하고 있다. 속성값은 크게 3가지가 존재한다.</p><ul><li>high - 리소스의 우선순위를 높음으로 정한다.</li><li>low - 리소스의 우선순위를 낮음으로 정한다.</li><li>auto - 개발자가 별도로 우선순위를 정하지 않고 브라우저의 기본을 따라간다.</li></ul><p>리소스에 따라서 여러가지 조합을 이루어낼 수 있는데, 예를 들어 서비스가 SPA인 경우에는 스크립트를 먼저 호출시키는 방식도 가능하다.</p><pre>&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;<br>&lt;script src=&quot;app.bundle.js&quot; importance=&quot;high&quot;&gt;</pre><p>혹은 Carousel 같은 여러개의 이미지가 노출되는 경우에 첫번째 이미지만 우선순위를 높게 가져갈 수도 있다.</p><pre>&lt;ul class=&quot;carousel&quot;&gt;<br> &lt;img src=&quot;img/carousel-1.jpg&quot; importance=&quot;high&quot;&gt;<br> &lt;img src=&quot;img/carousel-2.jpg&quot; importance=&quot;low&quot;&gt;<br> &lt;img src=&quot;img/carousel-3.jpg&quot; importance=&quot;low&quot;&gt;<br> &lt;img src=&quot;img/carousel-4.jpg&quot; importance=&quot;low&quot;&gt;<br>&lt;/ul&gt;</pre><p>우선순위를 높게 가져갈 경우 우선순위가 높은 리소스를 먼저 요청하게 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*NTypZZwtZ-iORJyqy8j-lA.png" /></figure><p>Priority hints는 아직 많은 브라우저에서 지원을 하고있지 않다. 다만 추후에 제대로 지원한다면 여러 곳에서 유용하게 사용될 것이라 생각한다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6721bf45fe4b" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AMP Contributor Summit 후기]]></title>
            <link>https://medium.com/@euncho/amp-contributor-summit-%ED%9B%84%EA%B8%B0-192817670919?source=rss-680d76e79c0e------2</link>
            <guid isPermaLink="false">https://medium.com/p/192817670919</guid>
            <dc:creator><![CDATA[Cho Eun]]></dc:creator>
            <pubDate>Mon, 01 Oct 2018 23:43:26 GMT</pubDate>
            <atom:updated>2018-10-10T02:44:12.017Z</atom:updated>
            <content:encoded><![CDATA[<p>2012년부터 개발을 시작했고, 2015년부터 본격적으로 오픈소스에 기여하기 시작한 이래로 다양한 오픈소스에 기여했지만 현재는 AMP Project에 주로 기여하고있다. AMP는 Accelerated Mobile Pages의 약자로 더 빠른 웹 페이지를 만들기 위한 오픈소스다.</p><p>나는 2016년부터 번역으로 기여하기 시작했고, 약 30~40개 정도의 문서를 번역하였다. 그리고 코드로도 여러군데에 기여했는데 imgur를 embed 하기위한 컴포넌트인 amp-imgur를 만들었고 AMP HTML에 크고 작은 Feature들을 넣는 등의 일을 했다.</p><p>이번에 AMP Team은 큰 변화를 겪고 있다. 우선 의사결정을 Google 중심에서 Community 중심으로 돌리는 거버넌스 모델을 새롭게 구축하기로 하였고 그에 따라 Contributor들의 의사가 중요해지는 순간이 도래했다. 그 시기에 맞물려서 AMP Team은 AMP Contributor Summit을 열고 어떻게 AMP에 기여하고 왜 AMP에 기여해야하는가에 대한 이야기를 나누었다.</p><h3>Day 0 — New Contributor Day</h3><p>오픈소스에 아예 관심이 없는 개발자도 있지만 몇몇은 오픈소스에 관심은 있지만 어디서부터 시작해야할 지 몰라서 오픈소스에 기여하지 못하는 사람도 많다. 나는 어디서부터 시작해야할 지 모르는 것은 아니었지만 오랜만에 기여하려고 하는 것이어서 그동안 바뀐 점이 얼마나 있었는 지, 또 지금 AMP의 아키텍쳐가 어떤 형태인 지 궁금해서 Day 0에 참석하기로 하였다.</p><p>이벤트는 모두 Palo Alto에 있는 Google Office에서 열렸다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/773/0*gLveLskJQh5sOZ28" /></figure><p>언제 내 회사를 넣었는 지 몰랐는데 NAVER라고 되어있더라</p><p>AMP에서는 처음 시작하는 사람을 위한 <a href="https://github.com/ampproject/amphtml/blob/master/contributing/getting-started-e2e.md">End To End Guide</a>를 제공하고 있는데 이 Guide를 따라가면 자연스럽게 어디서부터 시작해야할 지 알 수 있다. End To End Guide가 얼마나 친절한 지는 직접 살펴보면 알겠지만 Git을 사용하지 못하는 상황까지 고려할 정도로 친절한 가이드를 제공하고 있다.</p><p>그렇게 AMP Project 저장소를 설정하고 나면 Issue 목록에서 <a href="https://github.com/ampproject/amphtml/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22">Good First Issue</a>를 찾을 수 있다. AMP가 아니더라도 대부분의 오픈소스에서 Good First Issue 레이블을 가지고 있는데, 이는 오픈소스에 처음 참여하는 사람들을 위해 ‘처음 하는 사람도 쉽게 할 수 있는 수준의 이슈’를 레이블해두었다고 보면 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/773/0*tGMkQXviqozBnfLT" /></figure><p>이 중에서 몇개는 이미 내가 대응한 것도 있고, 몇개는 아직 수정하지 않은 것들도 있다. (#17303번 이슈와 #18056번 이슈는 이미 해결했다) Day 0에서 정말 놀라웠던 건 참석자들을 위한 Beginner Codelab이 마련되어있었는데 이 코드랩은 말 그대로 ‘아주 간단하게 해결해서 오픈소스에 기여하는 맛만 살짝 보는’ 정도의 코드랩이었다.</p><p>예를 들어 지금 열려있는 #18080 이슈를 살펴보자.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/773/0*kCFTqlfgBBGu-tpK" /></figure><p>위 이슈의 내용은 영국 단어 “behaviour”를 미국 단어 “behavior”로 바꾸라는 것이다. 코드를 아주 조금만 다룰 수 있어도 누구나 할 수 있고 수정하는 데 오랜시간이 걸리지도 않는다. 하지만 “오픈소스에 기여하는 경험”을 준다는 점에서 그 가치가 어떤 지는 알 수 있을 것이다.</p><p>간단한 이슈였지만 나도 번호를 받아서 해당 이슈를 수정했고 PR을 날려서 Merge까지 했다.</p><p><a href="https://github.com/ampproject/amphtml/pull/18299">fix spelling favour into favor by techhtml · Pull Request #18299 · ampproject/amphtml</a></p><p>이렇듯 간단한 경험이지만 오픈소스에 기여하는 경험을 주는 Day 0였다.</p><h3>Day 1 — Talks</h3><p>Day 0가 직접 해보면서 배우는 것이라고 한다면 Day 1은 AMP의 내부 설계에 대한 Talks 위주로 진행되었다.</p><h4>AMP Stories 101</h4><p><a href="https://www.ampproject.org/stories/">AMP Story</a>는 비주얼을 더 풍부하게 보여주기 위한 포맷으로 한국에서 비슷한 포맷으로는 카드 뉴스를 생각할 수 있겠다. 비주얼 데이터를 쉽게 전달하기 위한 방식의 포맷은 예전부터 여러 군데에서 사용되었는데 AMP Story가 더 빠르고 편리한 UX를 제공한다고 보면 좋을 거 같다.</p><h4><strong>UI 챌린지 1 : Template vs Freedom</strong></h4><p><strong>amp-story</strong>를 제작하던 당시에 두가지 접근방식을 고려했다. 첫번째는 JSON으로 데이터를 만들기만 하면 어느정도 정형화된 Story를 생성해주는 <strong>Template 접근방식</strong>, 두번째는 HTML을 직접 입력하되 자유도는 더 높은 <strong>Freedom 접근방식</strong>.</p><p>결론으로는 Freemdom 접근방식을 취하되 어느정도는 Template화 시켜둬서 밸런스를 맞추는 것을 중요하게 생각했다고 한다.</p><h4>UI 챌린지 2 : 클릭을 어떻게 제어할까?</h4><p>Story라는 모델이 가지고 있는 특징 중 하나가 이전 — 다음으로 넘어갈 수 있는 네비게이션 모델을 가진다는 것이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*9P4KaJDtYgC91A7RYVgecw.png" /><figcaption>AMP Story Naviagtion Model</figcaption></figure><p>그렇다면 만약 이 상황에서 AMP Story 내부의 링크와 Navigation 클릭 영역이 겹친다면 어떻게 해결해야할까?</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*PaeDhzKzumJCmz8G3VfxtA.png" /><figcaption>Question</figcaption></figure><p>AMP 에서는 이 문제를 해결하기 위해 outlink로 나갈 수 있는 영역을 Template화 시키고, Outlink로 이동하는 방식 자체에 대해서 가이드를 제공하였다.</p><p>첫번째는 outlinks Zone을 만들어서 페이지 하단 20% 정도의 영역을 외부 링크 영역으로 사용할 수 있게 한 것.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*LDBVygTiZf4_jUvz3sIJnw.png" /><figcaption>&lt;amp-story-cta-layer&gt; 를 이용해서 outlink를 지정할 수 있다.</figcaption></figure><p>두번째는 웹표준에 맞추어 링크를 허용하되, 링크를 클릭했을 때 툴팁이 뜨게 하여 이동시키는 방식이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Fg8ctXQ0_dajROWWASfzXQ.png" /><figcaption>outlink</figcaption></figure><h4><strong>UI 챌린지 3: 스타일 격리</strong></h4><p>페이지를 개발하는 프론트엔드 개발자가 페이지의 Style을 제어할 경우 AMP-Story 내부의 Bookend나 Sharing 영역이 깨질 수 있는 문제가 있다. AMP에서는 이 문제를 Shadow DOM을 이용해서 해당 영역을 분리하는 전략을 세웠다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*EM7pK6dB7qooaWu-kbDSwA.png" /></figure><p>개인적으로 상당히 인상깊은 부분이었는데 Shadow Tree 활용은 기존에도 많이 했지만 Style 격리를 하기 위해서 Shadow DOM을 활용한 사례를 몇번 보지 못하였기 때문이다. 플러그인 등을 만들 때 유용하게 체크해볼 수 있을 거 같다.</p><p>그 외에도 AMP-Story의 로컬라이징을 진행할 때 amp-story 플러그인에 각 언어별 locale을 만들어서 처리한 점, Redux 아키텍쳐를 참고해서 State와 Actions를 생성하여 관리하는 점에 대해서도 이야기를 나누었다.</p><p>한가지 인상깊었던 점은 비디오와 오디오를 제어하는 점인데, iOS에서는 비디오 갯수 제한이 있기 때문에 비디오 태그를 4개만 두고 비디오 매니저를 이용해서 그 때 그 때 필요한 비디오 리소스를 제어한다는 점이었다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*KsM6X5ZF7m7zzqtFBwcrJA.png" /></figure><p>서비스 자체에 리소스 매니저를 두고 매니저가 외부 리소스를 제어하는 형태도 괜찮다는 생각도 들었다.</p><p>[작성중]</p><h3>Day 2 — Breakouts</h3><p>이 날이 내 영어실력에 가장 한탄을 느낀 날이다. 이 날은 AMP가 앞으로 어떻게 해나갈 지에 대한 토론을 하였는데 내가 원하는 바를 그대로 영어로 말하기 어려워서 사실상 토론에 거의 참여는 못하고 다른 사람들이 토론하는 내용을 듣기만 하였다.</p><p>다만 AMP Project가 이제 전세계에서 많이 쓰이는 오픈소스고 그렇기 때문에 하위 호환성을 고려해가면서 새로운 Feature를 넣는 것이 얼마나 어려운 것인가에 대해서 다시 생각하게 되었다. 미래를 만들어나가기 위해서는 기존 소스도 껴안을 수밖에 없는 것이다.</p><p>나는 UI What’s Next, Improving the Contributor Experience, AMP Interactivity (amp-bind, etc.), Building a stronger developer community 라는 서로 다른 주제의 Breakouts을 들어갔는데 AMP가 어떤 식으로 미래를 준비하고 있고 Contributor의 경험을 좋게 만들고 있는 지에 대해서 알 수 있었던 시간이었다. (사실 원래 토론했어야한다)</p><h4>Wrap-up</h4><p>그래서 추석 기간동안 미국까지 가서 얻어온 것이 무엇이냐고 물어본다면 나는 오픈소스로 세상에 기여하고 있다는 것의 즐거움이라고 말할 수 있을 거 같다. 앞으로 꾸준히 오픈소스에 기여해서 Core Contributor가 될 수 있는 날이 되면 좋을 거 같다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=192817670919" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AMP Project의 열린 거버넌스 모델]]></title>
            <link>https://medium.com/@euncho/amp-project%EC%9D%98-%EC%97%B4%EB%A6%B0-%EA%B1%B0%EB%B2%84%EB%84%8C%EC%8A%A4-%EB%AA%A8%EB%8D%B8-28231c87ff0b?source=rss-680d76e79c0e------2</link>
            <guid isPermaLink="false">https://medium.com/p/28231c87ff0b</guid>
            <category><![CDATA[amp]]></category>
            <dc:creator><![CDATA[Cho Eun]]></dc:creator>
            <pubDate>Wed, 19 Sep 2018 00:05:37 GMT</pubDate>
            <atom:updated>2018-09-19T00:05:37.403Z</atom:updated>
            <content:encoded><![CDATA[<p>이 포스트는 “An open governance model for AMP Project” 이라는 글을 한국어로 번역한 포스트입니다. 개인적으로 이런 변화를 긍정적으로 생각하고 있습니다.</p><p><strong>Original Posts:</strong></p><p><a href="https://amphtml.wordpress.com/2018/09/18/governance/">An open governance model for the AMP Project</a></p><p>지난 2년간 AMP는 두명의 컨트리뷰터를 가진 오픈소스 프로젝트로 시작해서 700개가 넘는 forks와 10,000개가 넘는 컨트리뷰팅을 가진, 수많은 웹사이트에서 동작하는 오픈소스가 되었습니다. AMP에 대한 거버넌스 모델 (의사 결정 방법을 설명하는 시스템)을 선택할 때 처음에는 민첩성에 초점을 두었습니다. AMP는 항상 AMP를 사용하는 개발자와 조직의 목소리와 피드백에 힘 입었습니다. 그러나 거버넌스는 항상 테크 리드인데 (이 포스트를 작성하고 있는 접니다), 궁국적으로 채택된 방법을 결정했습니다.</p><p>이런 작업방식은 소규모 프로젝트에는 적합하지만, 현재 AMP 프로젝트의 규모와는 맞지 않는 것으로 나타났습니다. 대신 우리는 최종 사용자처럼 코드 자체에 기여할 수 없는 사람을 포함한 커뮤니티의 모든 구성원들이 명시적으로 목소리를 낼 수 있는모델로 전환하고자 합니다. 우리가 제안하는 변화는 수개월간의 연구를 토대로 한 것이며 이를 통해 <a href="https://nodejs.org/en/about/governance/">Node.js 프로젝트가 주도</a>하는 합의를 추구하는 거버넌스 모델로 전환하기로 결정했습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/660/0*65s2VbC2dDWweUiP" /></figure><p>이 <a href="https://github.com/ampproject/meta/pull/1">AMP를 위한 새로운 거버넌스 모델 제안</a>을 만들 때 AMP 팀은 몇가지 목표를 염두에 뒀습니다.</p><ul><li>코드 기여도, AMP의 향후 방향 설정 및 어떤 기능을 만들 지, 버그 수정을 포함하여 모든 기여 수준에서 다양한 목소리를 내는 걸 장려합니다. 이는 코드로 기여하지는 않지만 AMP의 영향을 받는 사람들의 목소리가 들리게 하는 것을 의미합니다.</li><li>개인 및 회사가 코드 변경 승인부터 AMP의 기술 및 제품 로드맵에 이르기까지 AMP에서 어떻게 소리를 낼 수 있는 지 확실하게 합니다.</li><li>거버넌스 모델로 인해 AMP에 대한 일상적인 작업 속도 저하를 피합니다. 사람들이 AMP에서 일하는 방식 변화의 최종 효과는 생산성 측면에서 긍정적이어야 합니다.</li><li>다른 오픈 소스 프로젝트에서 효과가 있었거나 효과가 없었던 것을 배웁니다. 이를 위해 AMP 팀은 <a href="https://nodejs.org/en/">Node.js</a>나 <a href="https://kubernetes.io/">Kubernetes</a> 같은 프로젝트에서 사람들과 대화하고 <a href="https://js.foundation/">JS Foundation</a> 같은 곳의 거버넌스 철학을 살펴보고 다양한 오픈 소스 및 웹 표준 거버넌스 문서를 검토했습니다.</li></ul><p>제안서에는 상세한 내용이 포함되어있지만 새로운 모델에서 제안된 중요한 변화 중 일부는 다음과 같습니다.</p><ul><li>AMP 프로젝트에서 중요한 결정을 내릴 수 있는 힘은 단일 테크 리드에서 AMP 구축에 필요한 자원을 투입한 회사의 대표자를 포함한 기술 운영위원회 (TSC)로 이동하며 좌석의 1/3 이상이 특정 회사를 보유하지 않을 것을 목표로 합니다.</li><li>많은 AMP의 후원자로 구성된 자문위원회가 TSC에 조언할 것입니다.</li><li>UI, 인프라 스트럭쳐 및 문서화 같이 AMP의 특정 측면에 대한 소유권이 있는 워킹 그룹은 현재 존재하는 비공식 팀을 대체할 것입니다. 이러한 워킹 그룹은 명확한 의사 결정 메커니즘과 명확한 의사 결정 프로세스를 제공합니다.</li></ul><p>새로운 시스템을 만들기 위한 첫번째 과제 중 하나는 AMP 거버넌스 그룹의 초기 멤버십을 완료하는 것입니다. 이 거버넌스 그룹에 참여하고 싶다면 <a href="https://goo.gl/forms/WCUDNX23CY9LL5xC2">저희에게 알려주세요</a>. 이것은 실제 작업이며, 만약 일상적인 직업을 커버할 수 없다면 금액을 지불할 예정입니다. 만약 금액적인 지원이 필요하다면 form에서 알려주세요. 우리가 특히 관심있는 분야 중 하나는 소비자 권리 및 보호 경험이 있는 사람들입니다. 그사이 우리는 몇명의 사람들과 이야기를 나눈 것을 기쁘게 생각하며, 퍼블리셔 (El País, Washington Post and Terra), e-커머스 사이트 (AliExpress and eBay)와 플랫폼 (Cloudflare and Automattic) 및 오픈 웹 어드보케이트 (<a href="https://twitter.com/leoniewatson">Léonie Watson</a> of The Paciello Group, <a href="https://twitter.com/stubbornella">Nicole Sullivan</a> of Google/Chrome, and <a href="https://twitter.com/edent">Terence Eden</a>) 들이 지지하고 있습니다.</p><p>또한 향후 AMP를 재단으로 삼아 TSC, AC 및 커뮤니티에 대한 의견을 매달 수렴할 예정입니다. 우리는 거버넌스가 그 방향의 첫 걸음으로 변하는 과정을 볼 것입니다.</p><p>우리는 다음 주에 열리는 <a href="https://events.withgoogle.com/amp-contributor-summit/">AMP Contributor Summit</a>을 포함하여 나머지 AMP 커뮤니티와 협력하여 거버넌스 제안을 수정하기를 기대하고 있습니다. 제안서를 검토하고 의견을 제시하고 제안에 대해 논의할 예정인 <a href="https://github.com/ampproject/amphtml/issues/17924">디자인 리뷰</a>에 참석하시는 걸 권장합니다. 제안서 검토는 2018년 10월 25일까지 끝나고 조만간 새로운 거버넌스 모델을 구현할 예정입니다.</p><p>우리는 AMP 커뮤니티가 다음 단계로 나가는 것을 보게되어 매우 기쁩니다. 사용자과 개발자 모두에게 더 나은 웹을 만들어주시길 바랍니다.</p><p><em>Posted by </em><a href="https://twitter.com/cramforce"><em>Malte Ubl</em></a><em>, Tech Lead for the AMP Project at Google</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=28231c87ff0b" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[안녕하세요. 미디엄 특성상 캡션을 여러 줄로 쪼개지 못해서 해당 부분은 빠져있습니다. 원문을 읽어보시면서 읽는 걸 권장합니다.]]></title>
            <link>https://medium.com/@euncho/%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94-%EB%AF%B8%EB%94%94%EC%97%84-%ED%8A%B9%EC%84%B1%EC%83%81-%EC%BA%A1%EC%85%98%EC%9D%84-%EC%97%AC%EB%9F%AC-%EC%A4%84%EB%A1%9C-%EC%AA%BC%EA%B0%9C%EC%A7%80-%EB%AA%BB%ED%95%B4%EC%84%9C-%ED%95%B4%EB%8B%B9-%EB%B6%80%EB%B6%84%EC%9D%80-%EB%B9%A0%EC%A0%B8%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4-%EC%9B%90%EB%AC%B8%EC%9D%84-%EC%9D%BD%EC%96%B4%EB%B3%B4%EC%8B%9C%EB%A9%B4%EC%84%9C-%EC%9D%BD%EB%8A%94-%EA%B1%B8-%EA%B6%8C%EC%9E%A5%ED%95%A9%EB%8B%88%EB%8B%A4-f07103ebca71?source=rss-680d76e79c0e------2</link>
            <guid isPermaLink="false">https://medium.com/p/f07103ebca71</guid>
            <dc:creator><![CDATA[Cho Eun]]></dc:creator>
            <pubDate>Fri, 14 Sep 2018 02:16:59 GMT</pubDate>
            <atom:updated>2018-09-14T02:16:59.327Z</atom:updated>
            <content:encoded><![CDATA[<p>안녕하세요. 미디엄 특성상 캡션을 여러 줄로 쪼개지 못해서 해당 부분은 빠져있습니다. 원문을 읽어보시면서 읽는 걸 권장합니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f07103ebca71" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[오 고맙습니다. 덧글을 어떻게 다는 지 몰라서 방금 알았습니다.]]></title>
            <link>https://medium.com/@euncho/%EC%98%A4-%EA%B3%A0%EB%A7%99%EC%8A%B5%EB%8B%88%EB%8B%A4-%EB%8D%A7%EA%B8%80%EC%9D%84-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8B%A4%EB%8A%94-%EC%A7%80-%EB%AA%B0%EB%9D%BC%EC%84%9C-%EB%B0%A9%EA%B8%88-%EC%95%8C%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4-8cfc7c2b6d35?source=rss-680d76e79c0e------2</link>
            <guid isPermaLink="false">https://medium.com/p/8cfc7c2b6d35</guid>
            <dc:creator><![CDATA[Cho Eun]]></dc:creator>
            <pubDate>Tue, 11 Sep 2018 05:53:58 GMT</pubDate>
            <atom:updated>2018-09-11T05:53:58.199Z</atom:updated>
            <content:encoded><![CDATA[<p>오 고맙습니다. 덧글을 어떻게 다는 지 몰라서 방금 알았습니다.</p><p>본문의 번역이 어색한 부분이 있었군요. 제안주신 내용으로 수정했습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8cfc7c2b6d35" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[모던 웹 브라우저의 내부 살펴보기 (Part 1)]]></title>
            <link>https://medium.com/@euncho/%EB%AA%A8%EB%8D%98-%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%82%B4%EB%B6%80-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-part-1-8650c5900974?source=rss-680d76e79c0e------2</link>
            <guid isPermaLink="false">https://medium.com/p/8650c5900974</guid>
            <category><![CDATA[translation]]></category>
            <category><![CDATA[browsers]]></category>
            <dc:creator><![CDATA[Cho Eun]]></dc:creator>
            <pubDate>Mon, 10 Sep 2018 06:26:12 GMT</pubDate>
            <atom:updated>2018-09-11T05:54:48.845Z</atom:updated>
            <content:encoded><![CDATA[<p>이 글의 원 저작자는 kosamari 이며 이 글의 저작권은 모두 Google Developers에 있습니다. 저는 그냥 번역만 했습니다.</p><p>See Original :</p><p><a href="https://developers.google.com/web/updates/2018/09/inside-browser-part1">Inside look at modern web browser (part 1) | Web | Google Developers</a></p><p>4 파트로 이루어진 블로그 시리즈에서 Chrome 브라우저를 고급 아키텍처에서 렌더링 파이프 라인의 세부 사항까지 살펴볼 예정입니다. 브라우저가 코드를 동작하는 웹사이트로 변환하는 방법에 대해 궁금하거나, 성능을 높이기 위해 특정 기술들이 왜 제안되는 지 확실히 알지 못한다면 이 시리즈를 참고하세요.</p><p>이 시리즈의 첫번째 파트에서, 핵심 컴퓨팅 기술과 Chrome의 멀티 프로세스 아키텍쳐를 살펴볼 예정입니다.</p><p>Note : 만약 당신이 CPU/GPU 와 프로세스/스레드에 대해서 익숙하다면 Browser Architecture 를 생략할 수 있습니다.</p><h3>컴퓨터의 핵심에는 CPU와 GPU가 있습니다.</h3><p>브라우저가 실행되는 환경을 이해하려면 컴퓨터의 일부와 그 기능을 이해해야합니다.</p><h4>CPU</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/856/0*QDNmndeYxw3-A-mX.png" /><figcaption>Figure 1: 4개의 CPU 코어를 사무원으로 보면 사무실에 앉아서 각각 태스크를 들어오는 대로 처리합니다.</figcaption></figure><p>첫번째는 중앙 처리 장치 (<strong>C</strong>entral <strong>P</strong>rocessing <strong>U</strong>nit), 즉 <strong>CPU</strong>입니다. CPU는 컴퓨터의 두뇌라고 할 수 있습니다. 이 그림에서 사무원으로 표시된 CPU 코어는 들어오는대로 하나씩 여러 가지 작업을 처리할 수 있습니다. CPU는 고객 전화에 응대하는 방법을 알고있듯이 수학부터 예술에 이르기까지 모든 것을 처리할 수 있습니다. 과거에는 대부분의 CPU가 단일 칩으로 이루어졌습니다. 코어는 동일한 칩에 있는 다른 CPU와 같습니다. 모던 하드웨어에서는 하나 이상의 코어를 사용하여 전화기와 랩탑에서 더 많은 컴퓨팅 파워를 제공합니다.</p><p>GPU</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/856/0*jLSD9AHZHersUwFr.png" /><figcaption>Figure 2: 렌치가 있는 많은 GPU 코어는 제한된 작업을 처리합니다.</figcaption></figure><p>그래픽 처리 장치 (<strong>G</strong>raphics <strong>P</strong>rocessing <strong>U</strong>nit), 즉 GPU는 컴퓨터의 다른 부분입니다. CPU와 달리, GPU는 단순한 작업을 처리함과 동시에 여러 코어를 동시에 처리하는 데 적합합니다. 이름에서 알 수 있듯이 GPU는 그래픽을 처리하기 처음 개발되었습니다. 그래픽 콘텍스트에서 “GPU 사용&quot; 혹은 “GPU 지원&quot;이 빠른 렌더링 및 매끄러운 인터렉션과 관련되어있는 이유입니다. 최근 몇 년 동안 GPU 가속 컴퓨팅으로 인해 GPU만으로도 점점 더 많은 계산이 가능해지고 있습니다.</p><p>컴퓨터나 전화기에서 어플리케이션을 실행하면 CPU와 GPU가 어플리케이션에 전원을 공급합니다. 일반적으로 어플리케이션은 운영 체제에서 제공하는 메커니즘을 사용해 CPU와 GPU에서 실행됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/856/0*8Cq61kZbLo63fk8p.png" /><figcaption>Figure 3: 컴퓨터 아키텍쳐의 세 레이어. 하드웨어가 가장 밑에 있고, 운영 체제가 중간에, 어플리케이션이 최상단에 있다.</figcaption></figure><h3>프로세스 및 스레드에서 프로그램 실행</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/856/0*SfBlDAmESSAsZBvw.png" /><figcaption>Figure 4: 프로세스를 상자로, 프로세스 내에서 물고기가 수영하는 모습을 추상적으로 스레드로 표시</figcaption></figure><p>브라우저 아키텍쳐로 들어가기 전에 파악해야 할 또 다른 개념은 프로세스와 스레드입니다. 프로세스는 어플리케이션의 실행 프로그램으로 설명할 수 있습니다. 스레드는 프로세스 내부에 있으며 프로세스의 프로그램 중 일부를 실행하는 스레드입니다.</p><p>어플리케이션을 시작하면 프로세스가 생성됩니다. 스레드는 일을 돕기 위해 프로그램이 생성하지만, 이는 옵션입니다. 운영체제에서 프로세스에 “slab”메모리를 제공하고, 모든 어플리케이션은 전용 메모리 공간에 상태를 보관합니다. 어플리케이션을 닫으면 프로세스도 사라지고 운영체제는 메모리를 비웁니다.</p><figure><a href="https://developers.google.com/web/updates/images/inside-browser/part1/memory.svg"><img alt="" src="https://cdn-images-1.medium.com/max/865/0*h3hWyY-1qJw3vKS0.png" /></a><figcaption>Figure 5: 메모리 공간을 사용하고 어플리케이션 데이터를 저장하는 프로세스 다이어그램</figcaption></figure><p>프로세스는 운영 체제가 다른 태스크를 실행하기 위해 다른 프로세스를 시작하도록 요청할 수 있습니다. 이 경우 메모리의 다른 부분이 새 프로세스에 할당됩니다. 만약 두 프로세스가 대화할 필요가 있다면 프로세스 간 통신 (<strong>I</strong>nter <strong>P</strong>rocess <strong>C</strong>ommunication, <strong>IPC</strong>)을 사용할 수 있습니다. 많은 어플리케이션이 이러한 방식으로 동작하도록 설계되었기 때문에 워커 프로세스가 응답하지 않으면 어플리케이션의 다른 부분을 실행하는 다른 프로세스를 중단없이 다시 시작할 수 있습니다.</p><figure><a href="https://developers.google.com/web/updates/images/inside-browser/part1/workerprocess.svg"><img alt="" src="https://cdn-images-1.medium.com/max/865/0*_UXb7_kz_hG9NmBN.png" /></a><figcaption>Figure 6: IPC를 통해 통신하는 개별 프로세스의 다이어그램</figcaption></figure><h3>브라우저 아키텍쳐</h3><p>그렇다면 프로세스와 스레드를 사용하여 웹 브라우저를 어떻게 구축했을까요? IPC를 통해 통신하는 몇 개의 스레드를 가진 많은 서로 다른 프로세스 혹은 여러개의 다른 스레드를 가진 하나의 프로세스일 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/865/0*t5YWLlQ22hBmbwhL.png" /><figcaption>Figure 7: 프로세스 / 스레드 내 다어이그램의 다른 브라우저 아키텍쳐</figcaption></figure><p>여기서 중요한 점은 이러한 다른 아키텍쳐가 구현 세부사항이라는 점입니다. 웹 브라우저를 구현하는 방법에 대한 표준 스펙은 없습니다. 한 브라우저의 접근 방식은 다른 것과 완전히 다를 수 있습니다.</p><p>이 블로그 시리즈를 위해 Chrome의 최신 아키텍쳐를 아래 다이어그램에서 설명합니다.</p><p>최상단에는 브라우저 프로세스가 어플리케이션의 다른 부분을 처리하는 다른 프로세스와 조정합니다. 렌더러 프로세스에서는 여러 프로세스가 만들어져 각 탭에 지정됩니다. 아주 최근까지도 Chrome은 가능한 경우 각 탭에 프로세스를 제공했습니다. 이제는 각 사이트에 iframes를 포함한 자체 프로세스를 제공하기 위해 노력하고 있습니다. (사이트 격리를 참고하세요)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/865/0*qRtErGpnp3c_4UNp.png" /><figcaption>Figure 8: Chrome의 멀티 프로세스 아키텍쳐 다이어그램. Renderer Process 아래에 여러 레이어가 표시되어 각 탭에서 여러개의 렌더러 프로세스를 실행하는 Chrome을 나타냅니다.</figcaption></figure><h3>어떤 프로세스가 무엇을 제어하나요?</h3><p>아래 테이블은 각 Chrome 프로세스와 프로세스가 무엇을 제어하는 지 설명합니다. (역주: Medium에서 테이블을 지원하지 않아서 부득이하게 펼쳐서 이야기합니다)</p><h4>프로세스 및 프로세스가 제어하는 것</h4><p><strong>Browser</strong></p><p>주소창, 북마크, 앞으로가기 및 뒤로가기 버튼을 포함한 어플리케이션의 “chrome” 부분을 제어합니다. 네트워크 요청 및 파일 접근 같이 보이지 않고, 권한 있는 웹 브라우저의 일부분도 처리합니다.</p><p><strong>Renderer</strong></p><p>웹사이트가 표시된 탭 내의 모든 것을 제어합니다.</p><p><strong>Plugin</strong></p><p>웹사이트에서 사용되는 플러그인을 제어합니다. flash가 대표적인 예입니다.</p><p><strong>GPU</strong></p><p>GPU 작업을 다른 프로세스와 분리하여 처리합니다. GPU가 여러 앱의 요청을 처리하여 같은 화면에 그려내기 때문에 다른 프로세스로 분리되어있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/865/0*hP_BG1y0fnuT69aK.png" /><figcaption>Figure 9: 브라우저 UI의 다른 부분을 나타내는 다른 프로세스</figcaption></figure><p>Extension 프로세스나 utility 프로세스같은 다른 프로세스들이 추가로 있습니다. Chrome에서 실행 중인 프로세스의 수를 확인하려면, 오른쪽 상단의 옵션 메뉴 아이콘을 클릭하고 More Tools를 선택한 후 Task Manager를 선택합니다. 그러면 현재 실행 중인 프로세스 목록과 CPU / Memory를 얼마나 사용하고 있는 지 나타내는 윈도우가 열립니다.</p><h3>Chrome의 멀티 프로세스 아키텍쳐의 이점</h3><p>앞서 Chrome에서 여러개의 렌더러 프로세스를 사용한다고 말했습니다. 가장 간단한 케이스로는 각 탭마다 자체 렌더러 프로세스가 있다고 생각할 수 있습니다. 3개의 탭이 열려 있고 각 탭이 독립적인 렌더러 프로세스에 의해 실행되고 있다고 가정해보겠습니다. 만약 한 탭이 응답하지 않으면 응답하지 않는 탭을 닫고 다른 탭을 활성화 상태를 유지한채로 이동할 수 있습니다. 모든 탭이 하나의 프로세스에서 실행중인 경우 하나의 탭이 응답하지 않으면 모든 탭이 응답하지 않습니다. 이는 슬픈 일일 겁니다.</p><figure><a href="https://developers.google.com/web/updates/images/inside-browser/part1/tabs.svg"><img alt="" src="https://cdn-images-1.medium.com/max/865/0*PdAf-9QRfafYDCmc.png" /></a><figcaption>Figure 10: 각 탭에서 여러개의 프로세스 동작을 보여주는 다이어그램</figcaption></figure><p>브라우저의 작업을 여러개의 프로세스로 분리하는 또 다른 이점은 보안 및 샌드박싱입니다. 운영 체제가 프로세스의 권한을 제한하는 방법을 제공하기 때문에 브라우저는 특정 기능의 특정 프로세스를 샌드박스로 만들 수 있습니다. 예를 들어, Chrome 브라우저는 렌더러 프로세스 같이 임의의 사용자 입력을 처리하는 프로세스에서 파일 접근을 제한합니다.</p><p>프로세스에는 전용 메모리 공간이 있기 때문에 흔히 공통 인프라의 복사본을 포함합니다. (Chrome의 자바스크립트 엔진인 V8 같은 것들) 이는 동일한 프로세스 내부의 스레드처럼 이를 공유할 수는 없으므로 더 많은 메모리 사용을 의미합니다. 메모리를 절약하기 위해 Chrome은 구동할 수 있는 프로세스의 수를 제한합니다. 제한은 기기의 CPU 파워와 메모리에 따라 다르지만 Chrome이 한계에 도달하면 한 프로세스에서 동일한 사이트의 여러개 탭을 실행하기 시작합니다.</p><h3>더 많은 메모리 절약 — Chrome의 서비스 관리</h3><p>동일한 접근방식이 브라우저 프로세스에도 적용됩니다. Chrome은 브라우저 프로그램의 각 부분을 서비스로 실행하여 여러 프로세스로 쉽게 분할하거나 하나의 프로세스로 통합 할 수 있도록 아키텍쳐를 변경하고 있습니다.</p><p>일반적으로 강력한 하드웨어에서 Chrome을 실행하는 경우 각 서비스를 다른 프로세스로 분리하여 안정성을 높일 수 있지만 리소스 제한적인 기기에서 실행하는 경우 서비스를 메모리 풋프린트를 절약하는 하나의 프로세스로 통합합니다. 이러한 변경 이전에 Android 같은 플랫폼에서 적은 메모리 사용량으로 프로세스를 통합하는 유사한 접근법이 사용되었습니다.</p><figure><a href="https://developers.google.com/web/updates/images/inside-browser/part1/servicfication.svg"><img alt="" src="https://cdn-images-1.medium.com/max/950/0*KR71qT_kj5HRyjNZ.png" /></a><figcaption>Figure 11: 다양한 서비스를 여러 프로세스와 단일 브라우저 프로세스로 이동시키는 Chrome의 서비스 관리 다이어그램</figcaption></figure><h3>프레임 단위 렌더러 프로세스 — 사이트 격리</h3><p><a href="https://developers.google.com/web/updates/2018/07/site-isolation">사이트 격리</a>는 Chrome에 최근 도입된 기능으로 cross-site iframe에 대해 별도의 렌더러 프로세스를 동작시킵니다. 서로 다른 사이트간에 메모리 공간을 공유하면서 단일 렌더러 프로세스에서 cross-site iframe을 실행시킬 수 있는 탭 모델 당 하나의 렌더러 프로세스에 대해 이야기해왔습니다. 같은 렌더러 프로세스에서 a.com과 b.com을 실행해도 괜찮은 거 같습니다. <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">동일 출처 정책</a>은 웹의 핵심 보안 모델입니다. 동일 출처 정책은 하나의 사이트가 동의 없이 다른 사이트의 데이터에 접근 할 수 없도록 합니다. 이 정책을 우회하는 것은 보안 공격의 주요 목표입니다. 프로세스 격리는 사이트를 분리하는 가장 효율적인 방법입니다. <a href="https://developers.google.com/web/updates/2018/02/meltdown-spectre">Meltdown과 Spectre</a> 를 보면 프로세스를 사용하여 사이트를 분리해야하는 것이 더욱 분명해집니다. Chrome 67부터 기본적으로 데스크탑에서 사이트 격리를 사용하도록 설정하면, 탭의 cross-site iframe에 별도 렌더러 프로세스가 적용됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/865/0*YdW3L0od9NJ-gq0M.png" /><figcaption>Figure 12: 사이트 격리 다이어그램. 사이트의 아이프레임을 여러개의 렌더러 프로세스가 가리킨다.</figcaption></figure><p>사이트 격리는 지난 몇년간 개발자의 노력의 산물입니다. 사이트 격리는 다른 렌더러 프로세스를 할당하는 것만큼 간단하지 않습니다. iframe이 서로 이야기하는 방식을 근본적으로 바꿉니다. iframe이 다른 프로세스에서 실행되는 페이지에서 devtools를 여는 것은 devtools가 화면을 원활하게 보여주기 위해서 다른 비하인드 작업을 구현해야한다는 것을 의미합니다. 페이지에서 단어를 찾기 위해 Ctrl + F를 눌렀을 때에도 다른 렌더러 프로세스를 통틀어 검색해야합니다. 브라우저 엔지니어가 사이트 격리의 출시를 핵심 마일스톤으로 이야기하는 이유를 알 수 있었습니다.</p><h3>마무리</h3><p>이 포스트에서 브라우저 아키텍쳐에 대한 고급 관점을 다루었으며 멀티 프로세스 아키텍쳐의 이점에 대해 다루었습니다. 또한 멀티 프로세스 아키텍쳐와 깊이 관련있는 Chrome의 서비스 및 사이트 격리에 대해서도 다루었습니다. 다음 포스트에서는 웹사이트를 표시하기 위해 이러한 프로세스와 스레드간에 일어나는 일에 대해 다룰 것입니다.</p><p>재미있게 읽으셨나요? 추후 포스트에 대한 제안이나 질문이 있으시다면 의견란이나 Twitter의 <a href="https://twitter.com/kosamari">@kosamari</a> 에게 의견을 주세요.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8650c5900974" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AMP에 대한 생각]]></title>
            <link>https://medium.com/@euncho/amp%EC%97%90-%EB%8C%80%ED%95%9C-%EC%83%9D%EA%B0%81-37b7e57c048f?source=rss-680d76e79c0e------2</link>
            <guid isPermaLink="false">https://medium.com/p/37b7e57c048f</guid>
            <category><![CDATA[project-amp]]></category>
            <category><![CDATA[amp]]></category>
            <dc:creator><![CDATA[Cho Eun]]></dc:creator>
            <pubDate>Thu, 06 Sep 2018 08:07:58 GMT</pubDate>
            <atom:updated>2018-09-06T08:10:53.326Z</atom:updated>
            <content:encoded><![CDATA[<p><a href="http://ampproject.org">AMP (Accelerated Mobile Pages)</a>는 다른 어떤 기술이 그러하듯 어떠한 문제를 해결하기위한 라이브러리다. 그리고 AMP Project가 특별히 문제라고 생각한 점은 <strong>‘현대 모바일 페이지가 너무 느리다&#39;</strong> 라는 것이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/660/0*vtSx_zhyMf3Vq9Im" /><figcaption>Source: Google/SOASTA Research, 2017.</figcaption></figure><p>어떻게 생각해보면 당연한 이야기이지만, 로딩 속도가 빠르면 빠를 수록 유저들은 더 나은 사용자 경험을 겪게 된다. 그러나 우리 중 그 누가 로딩 속도를 빠르게 하기 위해서, DOM이 렌더링되는 속도를 빠르기 위해서 많은 고민을 하고 있는가?</p><p>React나 Vue, Angular 같은 Front-End 라이브러리들이 나오면서 사용자들이 더 나은 사용자 경험을 겪고있다고 이야기하지만 이런 라이브러리들을 사용하더라도 잘못된 방식으로 구현하면 bundle된 자바스크립트의 파일은 커지고 사용자들은 결국 불편한 사용자 경험을 겪게된다.</p><p>사실 그런 사용자 경험의 대표적인 예가 아이러니하게도 페이스북이라고 생각한다. 내 노트북을 기준으로 페이스북에 접속하여 데이터가 노출되기까지는 약 3.7초 정도가 소요된다. (Performance 탭으로 측정하였다)</p><p>그리고 그 중 2.3초를 Script를 해석하기 위해 사용하고 있다. 물론 Bundle된 스크립트를 최초에 불러오면 이후에는 스크립트의 실행시간만 발생할 뿐 해석하는 시간은 별도로 발생하지 않기 때문에 비용이 절약된다고 할 수 있지만 처음 유저가 접속하였을 때 만족스럽지 않은 결과를 불러일으킬 수 있다.</p><p>그리고 이 3.7초는 무엇보다 네트워크 환경이 정말 좋은 상황임을 전제로 만들어진 시간이다. 네트워크 환경이 나쁘다면 이런 속도를 기대할 수 없을 것이다.</p><h4>Mobile First</h4><p>웹 개발 산업이 그동안 Desktop이라고 불리는 환경에서 Mobile로 넘어올 때, 일부 선구자들은 Mobile 환경과 Desktop 환경은 완전히 다르기 때문에 두 영역을 별도로 바라봐야한다고 이야기하였지만 일부는 Desktop에서 구현하던 관습 그대로 Mobile 페이지를 개발한다.</p><p>Desktop과 다르게 Mobile은 보통 Viewport의 너비가 좁고, Viewport의 높이는 넓기 때문에 세로로 스크롤을 길게해서 보는 콘텐츠가 Desktop의 그것보다도 많아진다. 하지만 우리가 웹 페이지를 개발할 때 그런 기기의 특성을 고려해서 구현하고 있는가?</p><p>AMP에서는 리소스를 다운로드 할 때 Viewport에 해당 요소가 나타났는 지를 체크해서 리소스를 다운로드 받도록 하고있다. 그래서 &lt;img&gt; 요소가 아닌 &lt;amp-img&gt; 요소를 사용하게 된다.</p><p>또한 AMP에서 화면을 그릴 때에 이미지나 동영상 등 리소스의 사이즈 변경으로 인한 layout 과정을 방지하기 위해 width, height 및 layout 값을 사전에 정의하도록 한다. 그렇게 하면 리소스의 크기를 미리 알 수 있기 때문에 화면을 해석하는 과정에서 미리 해당 높이를 요소에 부여하여 브라우저가 다시 계산하는 로직을 방지할 수 있기 때문이다.</p><p>또한 대부분의 인터렉션은 Touch 인터페이스던 Mouse 인터페이스던 상관없이 동작하도록 구축되어있기 때문에 사용자가 어떤 인터페이스를 통해 접근하던 편리하게 페이지를 이용할 수 있도록 되어있다.</p><p>그 외에도 GPU 가속 애니메이션만 사용하도록 제약하고, 웹 폰트를 빠른 CDN에서만 사용할 수 있게 하는 등 웹 페이지를 빠르게 하기 위한 모든 기술을 집약적으로 다루고 있다. 이는 페이지의 속도를 빠르게 만들어줄 뿐만 아니라 사용자의 경험을 좋게 만들어주기까지 한다.</p><h4>구현자의 잘못을 AMP의 책임으로 돌리지 마라</h4><p>우리 시대에는 다양한 라이브러리를 사용해왔다. jQuery로 시작되었던 그 붐은 지금 React, Vue까지 도달했고 미래에는 어떤 상황이 올 지 잘 모르겠다. 어떤 이는 AMP가 모바일 전용 페이지로의 회귀라고 이야기하는 것을 보았다.</p><p>아이러니 하게도 AMP가 Accelerated Mobile Pages, 즉 빠른 모바일 페이지라는 프로젝트 명을 가지고 있지만 이는 반드시 모바일에만 국한되어있는 것은 아니다. 예를 들어 bmw.com 은 전체 페이지가 AMP HTML로 구현되어있음에도 불구하고 Desktop 이던 Mobile 에서던 미려한 화면을 나타내고 있다.</p><p><a href="https://bmw.com">The international BMW Website | BMW.com</a></p><p>따라서 AMP를 사용해서 개발한다는 것이 Mobile Page만을 위한 것이 아니며 우리가 HTML을 사용하듯이 페이지의 속도를 좋게 만들기 위해 확장되어있는 HTML을 사용한다는 것에 집중하면 좋을 거 같다.</p><p>그리고 AMP는 유저가 직접 작성한 JavaScript를 지원하지 않지만 AMP 자체가 가지고있는 강력한 컴포넌트들이 많기 때문에 유저가 표현하고자하는 바 대부분은 AMP 자체의 컴포넌트만으로도 표현이 가능하다.</p><h4>AMP는 정적이다라는 오해</h4><p>AMP가 처음 나왔을 때에는 주로 언론사 등 정적인 페이지에서 주로 사용되었는데 AMP가 가지고 있는 표현력이 굉장히 좋지 않았기 때문이다. 특히 자바스크립트를 이용하면 아주 간단하게 작업 가능할 것도 AMP를 이용하면 구현이 불가능하던 때도 있다.</p><p>하지만 AMP가 버전업을 거치면서 유저의 인터렉션에 따라서 반응해서 동작하는 기능들이 추가되었기 때문에 지금 AMP가 정적이다라고 말하면 그것을 잘못된 이야기이다.</p><p>JSON을 받아서 실시간으로 데이터를 화면에 뿌려주는 &lt;amp-list&gt; 혹은 &lt;amp-live-list&gt;, 유저의 선택상태에 따라서 데이터를 다르게 보여줄 수 있는 &lt;amp-state&gt; 등 다양한 요소들이 AMP에 추가되고 있다.</p><p>AMP Project에서 제공하는 Product Page 샘플을 보면 더 이해가 쉬울 것이라고 생각한다.</p><p><a href="https://ampbyexample.com/samples_templates/product_page/preview/">Product Page - AMP by Example</a></p><h4>AMP는 자유도를 낮춘다</h4><p>이는 아쉽게도 어느정도 맞는 말이다. AMP를 사용하면 수많은 제약에 갇히게 된다. 유저는 내 마음대로 Script를 작성할 수도 없고, CSS를 마음편히 작성하지도 못하며 img 요소를 하나 쓰려고 해도 width, height, layout을 정의해주어야한다.</p><p>서두에서도 이야기 했지만 AMP는 특정한 문제를 해결하기 위해서 나온 라이브러리다. 그 문제는 ‘모바일 페이지의 속도가 너무 느리다&#39; 라는 것이고 그들이 내린 결론은 ‘개발자들에게 제약은 가더라도 모바일 페이지의 속도를 빠르게 하자&#39; 라는 것을 결론으로 삼은 것이다.</p><p>그렇기 때문에 AMP를 사용할 때 고려해야하는 점은 ‘이런 제약사항을 가지고서라도 AMP를 이용해서 개발해야하는가?’ 라고 생각한다. 그리고 나는 여전히 AMP가 매력적이라고 생각하고 있다.</p><p>여러가지 이유가 있지만 이미 우리는 플러그인이나 라이브러리로 도배된 웹 페이지를 만드는 경우가 많다. 하지만 그런 플러그인을 사용할 때 가지는 제약사항들은 ‘써야만 하니까 가지는 제약사항&#39; 이 되는 경우가 많고, 그렇게 추가되는 CSS와 JS들이 웹 페이지를 느리게 만든다.</p><p>우리는 이런 개발 추이에 늘 경계해야하지만 사실상 경계하는 경우가 많지 않다. <strong>‘에이 그래봤자 플러그인 한두개 쓰는데&#39;</strong> 웹 페이지의 성능은 그 한두개가 불러오는 사이드이팩트가 부풀고 부풀어서 느리게 만든다.</p><h4>그래서 어쩌라고?</h4><p>나는 이 글을 읽은 사람이 AMP를 쓰던 안쓰던 상관없다. 하지만 AMP Project가 어떤 것인 지 제대로 알고 그것을 써야하는 지에 대해서 이야기를 해보면 좋을 거 같다.</p><p>다가오는 9월 11일에 한국에서 첫 AMP Roadshow가 열린다. 이 이벤트에 참석할 사람이 몇명이나 될 지 모르겠지만 만약 이 글을 읽고 AMP에 대해서 관심이 조금이라도 생겼다면 한번 참석해보면 좋을 거 같다.</p><p><a href="https://events.withgoogle.com/amp-roadshow-seoul/">AMP Roadshow Seoul - 홈</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=37b7e57c048f" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>