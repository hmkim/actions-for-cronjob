<?xml version='1.0' encoding='UTF-8'?><rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:openSearch="http://a9.com/-/spec/opensearchrss/1.0/" xmlns:blogger="http://schemas.google.com/blogger/2008" xmlns:georss="http://www.georss.org/georss" xmlns:gd="http://schemas.google.com/g/2005" xmlns:thr="http://purl.org/syndication/thread/1.0" version="2.0"><channel><atom:id>tag:blogger.com,1999:blog-215855746822080016</atom:id><lastBuildDate>Thu, 20 Sep 2018 08:09:22 +0000</lastBuildDate><category>컨퍼런스 정리</category><category>Front-End</category><category>Node.js</category><category>React</category><category>Typescript</category><title>KongKong 의 고군분투 개발 일기</title><description></description><link>http://kongkongdev.blogspot.com/</link><managingEditor>noreply@blogger.com (Kong Kong)</managingEditor><generator>Blogger</generator><openSearch:totalResults>4</openSearch:totalResults><openSearch:startIndex>1</openSearch:startIndex><openSearch:itemsPerPage>25</openSearch:itemsPerPage><item><guid isPermaLink="false">tag:blogger.com,1999:blog-215855746822080016.post-5578812412213731632</guid><pubDate>Tue, 23 Jan 2018 03:03:00 +0000</pubDate><atom:updated>2018-01-22T19:04:36.160-08:00</atom:updated><category domain="http://www.blogger.com/atom/ns#">Typescript</category><category domain="http://www.blogger.com/atom/ns#">컨퍼런스 정리</category><title>Typescript Meetup</title><description>&lt;h1 id=&quot;typescript-korea-meetup-2018&quot;&gt;Typescript Korea MeetUp 2018&lt;/h1&gt;&lt;p&gt;2018년 1월 18일 강남 마루180 19:00 ~ 21:10&lt;/p&gt;&lt;hr&gt;&lt;h2 id=&quot;typescript-로-부터-얻은것과-잃은-것&quot;&gt;Typescript 로 부터 얻은것과 잃은 것&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;발표자 손찬욱 (네이버) eg.js 개발중&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;typescript-사용기&quot;&gt;Typescript 사용기&lt;/h3&gt;&lt;h4 id=&quot;egjs-작업중-movablecoord&quot;&gt;egjs 작업중 movablecoord&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://d2.naver.com/helloworld/0590136&quot;&gt;참조&lt;/a&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;마우스, 터치로 이동하는것을 x,y값으로 변경후 ui로 반응&lt;/li&gt;&lt;li&gt;x,y 이동만 가능&lt;/li&gt;&lt;li&gt;줌, 키보드 , 휠 도 가능하게 요구사항 생김&lt;/li&gt;&lt;/ol&gt;&lt;h4 id=&quot;문제-발생&quot;&gt;문제 발생&lt;/h4&gt;&lt;ol&gt;&lt;li&gt;다형성의 필요성을 느낌&lt;/li&gt;&lt;li&gt;동일 형태 동일 역할이므로 인터페이스를 구현하면 됨&lt;/li&gt;&lt;li&gt;js에는 인터페이스가 없음&lt;/li&gt;&lt;li&gt;그냥 만드면서 문서화만함&lt;/li&gt;&lt;li&gt;더 많은 요구 사항 발생 (다중의 축을 적용)&lt;/li&gt;&lt;/ol&gt;&lt;h4 id=&quot;해결법&quot;&gt;해결법&lt;/h4&gt;&lt;ol&gt;&lt;li&gt;다양한 입력 타입은 인터페이스 적용&lt;/li&gt;&lt;li&gt;기능별로 implement 함&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;typescript로-얻은것&quot;&gt;Typescript로 얻은것&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;코드 의도가 분명해짐&lt;/li&gt;&lt;li&gt;definition 파일까지 자동으로 만들어줌&lt;/li&gt;&lt;li&gt;안정성&lt;/li&gt;&lt;li&gt;데이터 타입 관리 수월&lt;/li&gt;&lt;li&gt;코드 이동&lt;/li&gt;&lt;li&gt;데이터 흐름 추적(함수형으로 작성할때 특히 좋음)&lt;/li&gt;&lt;li&gt;높은 커버리지(config에서 target을 변경하면 es3까지 지원가능)&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;typescript로-잃은것&quot;&gt;Typescript로 잃은것&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;3’rd party&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;특정 라이브러리는 UMD 형식을 사용해서 es6이상으로 작동 될때 CommenJS방식으로 개발된다. 그 상황에서 babel과 es6사이에 호출방식에 차이점을 보여준다.&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;package.js에서 main에서 찾는데 module을 선언하면 es6로 불러올 수 있다.&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;3’rd party @types&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;라이브러리 내부에 옵션값으로 선언을 안 할 수 있지만 옵션값 내부에 필수 값이 있을 경우 문제가 발생&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;코드 가독성이 낮아 질 수 있다.&lt;/li&gt;&lt;/ol&gt;&lt;h4 id=&quot;qa&quot;&gt;Q&amp;amp;A&lt;/h4&gt;&lt;ol&gt;&lt;li&gt;babel로 트렌스파일 할때와 아닐때 용량 차이&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;크다&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;h2 id=&quot;코드-한-줄-없는-typescript-사용기&quot;&gt;코드 한 줄 없는 Typescript 사용기&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;김상원 (텀블벅)&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;steadio-제작기&quot;&gt;steadio 제작기&lt;/h3&gt;&lt;h3 id=&quot;typescript는-어떻게-신뢰를-주었나&quot;&gt;Typescript는 어떻게 신뢰를 주었나&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;과거의 코드를 믿을 수 있다.&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;빠른 디버깅&lt;/li&gt;&lt;li&gt;적지만 믿을 수 있는 코드&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;테스트 코드의 양이 줄어들기 때문에 결국 코드의 양이 줄어 들게됨&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;코드 자체가 문서가 되기 때문에&lt;/li&gt;&lt;li&gt;팀 협업&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;빌드 프로세스 수립과정이 복잡&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;지원하지 않는 라이브러리는 타입스크립트 컴파일후 웹팩 빌드를 해야함&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;XXX as any&lt;/li&gt;&lt;li&gt;코드와 타입이 불일치&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;타입 업데이트가 코드를 따라 가지 못한 경우&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;코드의 일부분만 선언된경우&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;타입과 코드가 다른경우&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;h2 id=&quot;react-with-typescript&quot;&gt;React with Typescript&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;발표자 최종욱 (후이서울)&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;리액트&quot;&gt;리액트&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;스스로를 UI를 위한 라이브러리&lt;/li&gt;&lt;li&gt;리액트는 간단하지만 엄격한 방식으로 한가지를 매우 잘하는 함수이다.&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;with-타입스크립트&quot;&gt;With 타입스크립트&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;self describing&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;qa-1&quot;&gt;Q&amp;amp;A&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;디렉토리 구조?&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;???&lt;/p&gt;&lt;/blockquote&gt; </description><link>http://kongkongdev.blogspot.com/2018/01/typescript-meetup.html</link><author>noreply@blogger.com (Kong Kong)</author><thr:total>0</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-215855746822080016.post-6560337794393431449</guid><pubDate>Sun, 31 Dec 2017 01:57:00 +0000</pubDate><atom:updated>2017-12-30T18:10:07.379-08:00</atom:updated><category domain="http://www.blogger.com/atom/ns#">컨퍼런스 정리</category><title>GDG 정리</title><description>&lt;h1 id=&quot;gdg-fest-171119-in-seoul-uni&quot;&gt;GDG fest 17/11/19 in Seoul UNI&lt;/h1&gt; &lt;hr&gt;   &lt;h2 id=&quot;why-typescript-with-clean-architecture&quot;&gt;Why Typescript with Clean Architecture&lt;/h2&gt; &lt;ul&gt;&lt;li&gt;발표자 장유진&lt;/li&gt;&lt;li&gt;banksalad 상품 -&amp;gt; 금융 솔루션이라 프로젝트의 사이즈가 커짐-&amp;gt; 관리가 어려움 &lt;br&gt;&lt;ol&gt;&lt;li&gt;제품관점 &lt;br&gt;  &lt;blockquote&gt;  &lt;p&gt;제품의 궁극적인 모습을 상상해보면? &lt;br&gt;  같은 주제도 여러 관점에서 다룬다. &lt;br&gt;  * Microservice Acrhitecture :: 각 기능별로 서버를 구현&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;  &lt;/ul&gt; &lt;br&gt;  클라이언트는 다양한 기능이 모이는곳이라 중요함 &lt;br&gt;  2. 협업관점 &lt;br&gt;  같은 주제도 다르게 생각한다. &lt;br&gt;  관점을 통일하지 않으면 문제가 생긴다. &lt;br&gt;  3. 개발 환경 관점 &lt;br&gt;  JS의 근본적인 문제 오류 검출이 힘들다 &lt;br&gt;  * 해결방안 typesafe 언어 지식기반으로 만든다. &lt;br&gt;  * 지식 중심의 명확한 아키택쳐 &lt;br&gt;  DDD(Domain Driven Design) &lt;br&gt;  도메인 전문가와 엔지니어가 모델을 만들어서 아키택쳐를 만든다. &lt;br&gt;  * 빠른 개발 속도       &lt;h2 id=&quot;변경이-적은-코드&quot;&gt;&amp;gt; 변경이 적은 코드&lt;/h2&gt;     &lt;h2 id=&quot;프론트엔드-프레임-워크-낱낱히-파해치기&quot;&gt;프론트엔드 프레임 워크 낱낱히 파해치기&lt;/h2&gt; &lt;ul&gt;&lt;li&gt;현재 중요 키워드 &lt;br&gt;&lt;ol&gt;&lt;li&gt;동적 랜더링&lt;/li&gt;&lt;li&gt;모듈링&lt;/li&gt;&lt;li&gt;타이핑&lt;/li&gt;&lt;li&gt;테스트 자동화&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;virtualDOM &lt;br&gt;  &lt;blockquote&gt;  &lt;p&gt;Native dom은 비싸기때문에 코드 레벨에서 비교한다 &lt;br&gt;  URL &lt;a href=&quot;https://www.slideshare.net/KennethCeyer/gdg-devfest-2017-seoul-82177288&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.slideshare.net/KennethCeyer/gdg-devfest-2017-seoul-82177288&quot;&gt;https://www.slideshare.net/KennethCeyer/gdg-devfest-2017-seoul-82177288&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;  &lt;/ul&gt;     &lt;hr&gt;      &lt;h2 id=&quot;react-django-로-만드는-progressive-web-app&quot;&gt;react, Django 로 만드는 progressive web app&lt;/h2&gt; &lt;ul&gt;&lt;li&gt;PWA 웹의 장점과 앱의 장점을 더한 개념&lt;/li&gt;&lt;li&gt;어느 브라우저를 선택하든 상관없이 점진적 기능 개선을 통해 모든 사용자에게 제공&lt;/li&gt;&lt;li&gt;반응형&lt;/li&gt;&lt;li&gt;따로 앱을 만들지 않아도 앱아이콘 푸쉬 가능&lt;/li&gt;&lt;li&gt;업데이트를 하지 않고 항상 최신화&lt;/li&gt;&lt;li&gt;service worker&lt;/li&gt;&lt;li&gt;mainjs 요청하면 서비스 워커가 가로 챈다-&amp;gt; 캐시를 확인하여 캐시가 있는지 확인 한다.-&amp;gt;(네트워크 연결X )캐시에 있으면 화면 랜더링&lt;/li&gt;&lt;li&gt;업데이트는 랜더링 다음에 한다.&lt;/li&gt;&lt;li&gt;서비스 워커는 cra에 저장 되어있음&lt;/li&gt;&lt;li&gt;파일명 해쉬도 cra가 해준다.&lt;/li&gt;&lt;li&gt;브라우저 캐시 vs 서비스 워커&lt;/li&gt;&lt;li&gt;브라우저 캐시는 일정 기간 마다 없어지는 경우가 있음 그리고 크기가 제한적(모든 사이트를 저장하기 때문에)&lt;/li&gt;&lt;/ul&gt;</description><link>http://kongkongdev.blogspot.com/2017/12/gdg.html</link><author>noreply@blogger.com (Kong Kong)</author><thr:total>0</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-215855746822080016.post-4493872253540873204</guid><pubDate>Sun, 31 Dec 2017 01:56:00 +0000</pubDate><atom:updated>2017-12-30T18:11:02.273-08:00</atom:updated><category domain="http://www.blogger.com/atom/ns#">Front-End</category><category domain="http://www.blogger.com/atom/ns#">React</category><title>Redux 정리</title><description>&lt;h1 id=&quot;redux&quot;&gt;REDUX&lt;/h1&gt; &lt;hr&gt;   &lt;h2 id=&quot;redux의-특성&quot;&gt;Redux의 특성&lt;/h2&gt;   &lt;h2 id=&quot;1-single-source-of-truth&quot;&gt;1. Single Source of Truth&lt;/h2&gt; &lt;blockquote&gt;  &lt;p&gt;어플리케이션의 state를 위해 단 한개의 store를 사용합니다. &lt;br&gt;  Flux에서는 여러개의  store를 사용합니다.&lt;/p&gt;&lt;/blockquote&gt;   &lt;h2 id=&quot;2-state-is-read-only&quot;&gt;2. State is Read-Only&lt;/h2&gt; &lt;blockquote&gt;  &lt;p&gt;어플리케이션에서는 store의 state를 직접 변경할 수 없습니다. &lt;br&gt;  state를 변경하기 위해선 무조건 action이 dispatch 되어야합니다.&lt;/p&gt;&lt;/blockquote&gt;   &lt;h2 id=&quot;3-changes-are-made-with-pure-function&quot;&gt;3. Changes are made with pure Function&lt;/h2&gt; &lt;blockquote&gt;  &lt;p&gt;action 객체를 처리하는 함수를 reducer라고 합니다. &lt;br&gt;  reducer는 정보를 받아서 상태를 어떻게 업데이트 할 지 정의합니다.&lt;/p&gt;     &lt;p&gt;&lt;strong&gt;reducer는 ‘순수함수’로 작성되어야합니다.&lt;/strong&gt;&lt;/p&gt;     &lt;blockquote&gt;    &lt;p&gt;즉 네트워크 및 DB 접근 X, 인수 변경 X &lt;br&gt;    같은 인수로 실행된 함수는 언제나 같은 결과를 반환 &lt;br&gt;    순수하지 않은 API 사용불가 &lt;/p&gt;  &lt;/blockquote&gt;&lt;/blockquote&gt;   &lt;h2 id=&quot;title&quot;&gt;&amp;gt;&lt;/h2&gt;   &lt;h2 id=&quot;구성요소&quot;&gt;구성요소&lt;/h2&gt; &lt;ul&gt;&lt;li&gt;&lt;p&gt;Action Creator&lt;/p&gt; &lt;blockquote&gt;  &lt;p&gt;어플리케이션 상태를 바꾸고 싶다면 항상 액션을 보내야 한다(무조건). &lt;br&gt;  무슨 메시지를 보낼지 알려주면 액션 생성자는 나머지 시스템이 이해할 수 있는 포맷으로 바꿔준다 &lt;br&gt;  Flux와는 다르게 Redux의 액션 생성자는 디스패쳐(dispatcher)로 액션을 보내지는 않는다. 대신, 포맷을 바꾼 뒤 액션을 돌려준다.&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Store&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt; &lt;blockquote&gt;  &lt;p&gt;모든 상태 변화는 스토어에 의해서 이루어져야 하고 스토어로 직접 요청하는 대신 액션 파이프라인을 따라가야 한다. &lt;br&gt;  Flux에서는 다수의 스토어를 가질 수 있지만 Redux에서는 한개의 Store만 가질 수 있다. &lt;br&gt;  Redux의 스토어는 상태 트리(state tree) 전체를 유지하는 책임을 진다. &lt;br&gt;  액션이 들어왔을 때 어떤 상태변화가 필요한지에 대한 일은 위임한다. &lt;br&gt;  Flux의 디스패쳐의 역활도 한다.&lt;/p&gt;&lt;/blockquote&gt; &lt;ul&gt;&lt;li&gt;Reducer&lt;/li&gt;&lt;/ul&gt; &lt;blockquote&gt;  &lt;p&gt;스토어는 액션이 어떤 상태 변화를 만드는지 알 필요가 있을 때 리듀서에게 묻는다. &lt;br&gt;  이것이 바로 Redux의 키 아이디어 중 하나이다. 상태 객체는 직접 변경되지 않는다. 대신, 각각의 상태 조각이 복사 후 변경되고 새로운 상태 객체 하나로 합쳐진다. &lt;br&gt;  리듀서는 복사되고 업데이트된 상태 객체를 루트 리듀서에게 넘겨주고, 루트 리듀서는 이 객체를 스토어로 보낸다. 그리고 스토어는 이 객체를 새로운 애플리케이션 상태로 만든다.&lt;/p&gt;&lt;/blockquote&gt; &lt;ul&gt;&lt;li&gt;View&lt;/li&gt;&lt;/ul&gt; &lt;blockquote&gt;  &lt;p&gt;똑똑한 컴포넌트와 멍청한 컴포넌트&lt;/p&gt;&lt;/blockquote&gt; &lt;table border=&quot;2px&quot;&gt;&lt;thead&gt;&lt;tr&gt;  &lt;th&gt;Smart&lt;/th&gt;  &lt;th&gt;Dumb&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;  &lt;td&gt;액션처리를 책임진다.&lt;/td&gt;  &lt;td&gt;우직한 컴포넌트는 액션에 직접 의존성을 가지지는 않는다&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;  &lt;td&gt;똑똑한 컴포넌트는 props를 통해서  멍청한 컴포넌트에 함수를 보낸다&lt;/td&gt;  &lt;td&gt;멍청한 컴포넌트는 받은 함수를 콜백으로써 단순히 호출만 한다&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;  &lt;td&gt;CSS style XX&lt;/td&gt;  &lt;td&gt;CSS style OO&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;  &lt;td&gt;DOM XX&lt;/td&gt;  &lt;td&gt;DOM OO&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;  &lt;p&gt;* View Layer Binding&lt;/p&gt; &lt;blockquote&gt;  &lt;p&gt;스토어를 뷰에 연결하기 위해서 Redux는 약간의 도움이 필요하다. 그 둘을 함께 묶어줄 무언가가 필요한데, 이걸 해주는 것이 바로 뷰 레이어 바인딩이다&lt;/p&gt;&lt;/blockquote&gt; &lt;ol&gt;&lt;li&gt;공급 컴포넌트(provider component): 컴포넌트 트리를 감싸는 컴포넌트이다. connect()를 이용해 루트 컴포넌트 밑의 컴포넌트들이 스토어에 연결되기 쉽게 만들어준다.&lt;/li&gt;&lt;li&gt;connect(): react-redux가 제공하는 함수이다. 컴포넌트가 애플리케이션 상태 업데이트를 받고 싶으면 connect()를 이용해서 컴포넌트를 감싸주면 된다. 그러면 connect()가 셀렉터(select)를 이용해서 필요한 모든 연결을 만들어준다.&lt;/li&gt;&lt;li&gt;&lt;p&gt;셀렉터(selector): 직접 만들어야 하는 함수이다. 애플리케이션 상태 안의 어느 부분이 컴포넌트에 props로써 필요한 것인지 지정한다.&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Root Component&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt; &lt;blockquote&gt;  &lt;p&gt;모든 React 애플리케이션은 루트 컴포넌트를 가진다. 이것은 단지 컴포넌트 계층 구조에서 가장 위에 위치하는 컴포넌트일 뿐이다. 하지만 Redux에서는 루트 컴포넌트는 추가로 책임져야 할 것이 존재한다. &lt;br&gt;  하지만 루트 컴포넌트는 애플리케이션을 초기화한 뒤로는 거의 하는 일이 없다. 화면을 갱신도 더는 신경 쓰지 않는다. 화면 갱신은 뷰 레이어 바인딩의 도움으로 아래의 컴포넌트들이 맡아서 처리한다.&lt;/p&gt;&lt;/blockquote&gt; &lt;hr&gt;   &lt;h2 id=&quot;setup&quot;&gt;SetUp&lt;/h2&gt; &lt;ol&gt;&lt;li&gt;Ready Store&lt;/li&gt;&lt;li&gt;Prepare communication between store and component&lt;/li&gt;&lt;li&gt;Ready Action Callback&lt;/li&gt;&lt;/ol&gt;   &lt;h2 id=&quot;dataflow&quot;&gt;DataFlow&lt;/h2&gt; &lt;ol&gt;&lt;li&gt;뷰가 액션을 요청한다. 액션 생성자가 포맷을 변환한 뒤 돌려준다&lt;/li&gt;&lt;li&gt;bindActionCreators()가 준비과정에서 사용되었으면 자동으로 액션이 보내진다. 그게 아니라면 뷰가 직접 액션을 보낸다&lt;/li&gt;&lt;li&gt;스토어가 액션을 받는다. 현재 애플리케이션 상태 트리와 액션을 루트 리듀서에게 보낸다.&lt;/li&gt;&lt;li&gt;루트 리듀서는 상태 트리를 조각으로 나눈 뒤 알맞은 서브 리듀서로 상태 조각들을 넘겨준다.&lt;/li&gt;&lt;li&gt;서브 리듀서는 받은 상태 조각을 복사한 뒤, 그 복사본을 변경한다. 루트 리듀서에게 변경된 복사본을 돌려준다.&lt;/li&gt;&lt;li&gt;모든 서브 리듀서가 변경 된 상태 조각들을 돌려주면, 루트 리듀서는 이 상태 조각들을 한데 모아 상태 트리로 만든 뒤 스토어로 돌려준다. 스토어는 새로운 상태 트리를 옛날 상태 트리와 바꾼다.&lt;/li&gt;&lt;li&gt;스토어는 뷰 레이어 바인딩에게 애플리케이션 상태가 변경되었다는 것을 알린다.&lt;/li&gt;&lt;li&gt;뷰 레이어 바인딩은 스토어에게 새로운 상태를 보내달라고 요청한다.&lt;/li&gt;&lt;li&gt;뷰 레이어 바인딩은 뷰에게 화면을 업데이트하도록 요청한다.&lt;/li&gt;&lt;/ol&gt;</description><link>http://kongkongdev.blogspot.com/2017/12/redux.html</link><author>noreply@blogger.com (Kong Kong)</author><thr:total>0</thr:total></item><item><guid isPermaLink="false">tag:blogger.com,1999:blog-215855746822080016.post-5870326520581369629</guid><pubDate>Sat, 30 Dec 2017 16:33:00 +0000</pubDate><atom:updated>2017-12-30T18:10:41.806-08:00</atom:updated><category domain="http://www.blogger.com/atom/ns#">Node.js</category><category domain="http://www.blogger.com/atom/ns#">컨퍼런스 정리</category><title>PlayNode 후기</title><description>&lt;h1 id=&quot;playnode&quot;&gt;PlayNode&lt;/h1&gt; &lt;blockquote&gt;  &lt;p&gt;17/11/09 르메디앙 호텔&lt;/p&gt;&lt;/blockquote&gt;   &lt;h2 id=&quot;graphql-relay-serverless&quot;&gt;GraphQL + Relay + Serverless&lt;/h2&gt; &lt;hr&gt; &lt;ul&gt;&lt;li&gt;발표자 박형식 @ 텀블벅&lt;/li&gt;&lt;li&gt;필요한 리소스만을 요청하고 사용하는 API 만들기&lt;/li&gt;&lt;li&gt;요즘은 컴포넌트 단위로 쪼개서 개발한다.&lt;/li&gt;&lt;li&gt;너무 많은 컴포넌트를 통신상태가 좋지 않은 상태일떄 어떻게 할까?&lt;/li&gt;&lt;/ul&gt; &lt;blockquote&gt;  &lt;p&gt;쿼리스트링 -&amp;gt; 데이터가 많을때 문제가 생긴다.&lt;/p&gt;&lt;/blockquote&gt; &lt;ul&gt;&lt;li&gt;데이터의 형태가 매번 바뀔수 있다&lt;/li&gt;&lt;li&gt;soundcloud 는 BFF 형태로 문제해결&lt;/li&gt;&lt;li&gt;BFF -&amp;gt; 프론트 엔드 위주로 백엔드가 백업해준다.&lt;/li&gt;&lt;li&gt;하지만 다양한 상황에 따른 각각의 BFF를 만들어야하는 문제가 발생&lt;/li&gt;&lt;li&gt;그렇기 때문에 GraphQL사용&lt;/li&gt;&lt;li&gt;형식은 요청은 value가 없는 JSON 응답은 value가 있는 JSON&lt;/li&gt;&lt;li&gt;요청{me{name,sex}},응답{me{name:’kong’,sex:’man’}}&lt;/li&gt;&lt;li&gt;이런식으로 인자가 있는 요청 가능{user(id=’1’){name,sex}}&lt;/li&gt;&lt;li&gt;POST/graphQL 보통 여기로 보내는게 규정&lt;/li&gt;&lt;li&gt;Type System  ????????&lt;/li&gt;&lt;li&gt;type은 기본키 같은존재 쿼리가 어디서 부터 시작하는지 알려줌 (솔직히 잘모르겠음)&lt;/li&gt;&lt;li&gt;mutation은 read write delete update 를 할수있게 함&lt;/li&gt;&lt;li&gt;너무 많은 데이터를 낭비하는 RESTAPI보다 graphQL이 더 좋을 수도 있다.&lt;/li&gt;&lt;li&gt;비지니스 로직이 너무 커질경우, 네트워크 요청이 비쌀때, 요청이 많을때 필요&lt;/li&gt;&lt;li&gt;네트워크 콜 최소화&lt;/li&gt;&lt;/ul&gt;   &lt;h2 id=&quot;relay&quot;&gt;Relay&lt;/h2&gt; &lt;ul&gt;&lt;li&gt;이미 내가 데이터가 있는지 확인 (캐싱이나 다른 걸로 받았는지 확인)하고 없으면 받는다&lt;/li&gt;&lt;li&gt;이걸로 네트워크 콜을 최소화의 최소화한다.&lt;/li&gt;&lt;li&gt;서버와 클라이언트 사이&lt;/li&gt;&lt;li&gt;응답과 답장이 가능해야한다.&lt;/li&gt;&lt;li&gt;mutation할때 테그를 붙히는데 답장에도 태그가 붙어 체이싱이 되어야한다.&lt;/li&gt;&lt;/ul&gt;   &lt;h2 id=&quot;serverless&quot;&gt;Serverless&lt;/h2&gt; &lt;ul&gt;&lt;li&gt;서버리스에서 가장 중요한것은 함수&lt;/li&gt;&lt;li&gt;함수 == event&lt;/li&gt;&lt;li&gt;서버리스는 패턴과 아키텍쳐&lt;/li&gt;&lt;li&gt;서버 관리의 모든걸 클라우드에게 맡기자!&lt;/li&gt;&lt;li&gt;이벤트가 있을때만 사용하기 때문에 비용적인 측면에서 GOOD&lt;/li&gt;&lt;li&gt;이 서버들을 함수로 연결하자&lt;/li&gt;&lt;/ul&gt; &lt;hr&gt;   &lt;h2 id=&quot;정적-타이핑&quot;&gt;정적 타이핑&lt;/h2&gt; &lt;ul&gt;&lt;li&gt;개발 파이프라인&lt;/li&gt;&lt;li&gt;코드수정 -&amp;gt; 컴파일 -&amp;gt; 커밋-&amp;gt;빌드 -&amp;gt; 배포&lt;/li&gt;&lt;li&gt;탐지 가능한 버그&lt;/li&gt;&lt;li&gt;정적 타이핑으로 테스트 한 경우 15%정도 버그를 줄였다.&lt;/li&gt;&lt;li&gt;버그를 없애는 것이 아니라 버그를 미리 발견할 수 있게 한다.&lt;/li&gt;&lt;li&gt;코드와 더 밀접히 연결된 문서화가 가능해집니다.&lt;/li&gt;&lt;li&gt;리팩토링이 용이해집니다.&lt;/li&gt;&lt;li&gt;typescript(ms) vs flow(facebook)&lt;/li&gt;&lt;li&gt;EX) const abc(a:number){}&lt;/li&gt;&lt;li&gt;제네릭도 지원&lt;/li&gt;&lt;li&gt;TS가 더 나은 결정이라고 생각한다.&lt;/li&gt;&lt;li&gt;안전함과 편리함 사이 설득력 있는 트레이드오프&lt;/li&gt;&lt;li&gt;ts랑 flow랑 근본적인 철학의 차이가 있다.&lt;/li&gt;&lt;li&gt;flow가 훨씬더 꼼꼼하다. 그래서 너무 사소한 것도 에러를 뛰어 버린다.&lt;/li&gt;&lt;li&gt;안전한 선택이 보일러플레이트가 됨&lt;/li&gt;&lt;li&gt;IDE == VSCODE&lt;/li&gt;&lt;li&gt;flow 보다 ts가 훨씬 커뮤니티가 크다&lt;/li&gt;&lt;li&gt;도입&lt;/li&gt;&lt;li&gt;점진적 타이핑을 해도 된다.&lt;/li&gt;&lt;/ul&gt; &lt;hr&gt;   &lt;h2 id=&quot;디버깅&quot;&gt;디버깅&lt;/h2&gt; &lt;ul&gt;&lt;li&gt;발표자 최준영&lt;/li&gt;&lt;li&gt;효율적인 디버깅을 위해서 전후에 확인하자&lt;/li&gt;&lt;li&gt;타입 어노테이션&lt;/li&gt;&lt;li&gt;당신의 의도를 ide 에게 잘 전달할 수 있다.&lt;/li&gt;&lt;li&gt;payload&lt;/li&gt;&lt;li&gt;여기도 ts&lt;/li&gt;&lt;li&gt;css in js&lt;/li&gt;&lt;li&gt;완벽한건 아니다 JS!&lt;/li&gt;&lt;li&gt;런타임에서 막아보자&lt;/li&gt;&lt;li&gt;인스펙터 를 이용한 디버깅&lt;/li&gt;&lt;li&gt;!!!!!!&lt;/li&gt;&lt;li&gt;중요   인스펙터 + 브레이크 포인트&lt;/li&gt;&lt;li&gt;!!!!!&lt;/li&gt;&lt;li&gt;스텝인 -&amp;gt; 함수안으로 들어오는거  오버엔 아웃&lt;/li&gt;&lt;li&gt;비동기 상황에서도 가능하다 -&amp;gt; 완벽하진 않음&lt;/li&gt;&lt;li&gt;pause in exception 이것도 키고 할것&lt;/li&gt;&lt;li&gt;VScode Inspector&lt;/li&gt;&lt;li&gt;음…..&lt;/li&gt;&lt;li&gt;TTD 챠크라 -&amp;gt; 디버깅중 과거로 돌아갈수 있다.&lt;/li&gt;&lt;/ul&gt; &lt;hr&gt;   &lt;h2 id=&quot;클라우드-시대의-node가-좋은이유&quot;&gt;클라우드 시대의 node가 좋은이유&lt;/h2&gt; &lt;ul&gt;&lt;li&gt;발표자 OKKY-허광남&lt;/li&gt;&lt;li&gt;2016년 1월 7일에 AWS KOREA 이후로 기업들이 클라우드로 넘어옴&lt;/li&gt;&lt;li&gt;PaaS 종류 : PaaS-TA,Beanstalk,AppEngine,AppService,Heroku,WebApps&lt;/li&gt;&lt;li&gt;uptime 1분마다 응답속도의 그래프를 보여줌&lt;/li&gt;&lt;li&gt;kinana 시각화&lt;/li&gt;&lt;/ul&gt;</description><link>http://kongkongdev.blogspot.com/2017/12/anguler-1.html</link><author>noreply@blogger.com (Kong Kong)</author><thr:total>0</thr:total></item></channel></rss>