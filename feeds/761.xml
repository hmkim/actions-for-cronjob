<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by 이학진 on Medium]]></title>
        <description><![CDATA[Stories by 이학진 on Medium]]></description>
        <link>https://medium.com/@plumhj?source=rss-f2187e1bd113------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*KIewebynWxqmuo7CJQgluQ.jpeg</url>
            <title>Stories by 이학진 on Medium</title>
            <link>https://medium.com/@plumhj?source=rss-f2187e1bd113------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 19:03:04 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@plumhj" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[Golang vs Rust 퍼포먼스 벤치마킹 썰]]></title>
            <link>https://blog.stibee.com/golang-vs-rust-%ED%8D%BC%ED%8F%AC%EB%A8%BC%EC%8A%A4-%EB%B2%A4%EC%B9%98%EB%A7%88%ED%82%B9-%EC%8D%B0-bac94bc26e2e?source=rss-f2187e1bd113------2</link>
            <guid isPermaLink="false">https://medium.com/p/bac94bc26e2e</guid>
            <category><![CDATA[stibee-team]]></category>
            <category><![CDATA[golang]]></category>
            <category><![CDATA[rustlang]]></category>
            <dc:creator><![CDATA[이학진]]></dc:creator>
            <pubDate>Fri, 08 Feb 2019 14:37:25 GMT</pubDate>
            <atom:updated>2019-02-19T10:22:44.548Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/960/1*V5s_gXRXS3SUQpdG5abQ4w.png" /></figure><p>나는 현재 <a href="https://stibee.com">stibee.com</a>의 백엔드 엔지니어로 일하고 있다. 초기에는 Java와 Golang을 주 언어로 사용해서 구현했고 현재는 Golang으로만 구현하고 있다.</p><p>위에서 말한바와 같이 나는 고돌이며, 편파적인 시각으로 Rust와의 벤치마킹 결과를 공유하고자 한다. (물론 내 능력이 되는대로 최대한 공정함을 유지하려고 했다.)</p><p>Go와 Rust는 C/C++정도의 퍼포먼스를 내면서 더 좋은(?) 언어를 목표로 한다고 한다.</p><p>stibee.com과 같은 스타트업에게 생산성 좋고 퍼포먼스까지 월등한 언어는 EC2 인스턴스의 타입을 낮추고 서버 수를 줄여주어 금전적인 기여를 하고, 기능 개발의 시간도 줄여주니, 주력 언어를 선택하는 것은 매우 중요하다 하겠다.</p><p>Go로 매우 만족하며 지내던 와중, Rust 퍼포먼스가 그렇게 좋다더라. 어떤 오픈소스가 Go에서 Rust로 전환했다더라 라는 말을 듣게되어 호기심이 일게 되었다. 사실 <a href="https://stibee.com">stibee.com</a> 초기에 대세는 폴리글랏이랍시고 Java/Go/Javascript(nodeJS)/Python 등 온갖 언어를 동원해 서버를 하나씩 구성하기도 했었다. 그리고 유지보수의 한계를 느끼고선 바로 Go로 대동단결 하였다. 하지만!! 그렇게 좋다면!! 아니 비교 해보지 않을 수 없지 않은가!!</p><p>신년이 도래하고, 약간의 여유가 생겨 rust-lang.org의 공식문서를 가볍게 훑어보니 오~ 하는 느낌이 생겼다. 확실히 “이놈은 퍼포먼스에 목숨정도는 아니더라도 손모가지 정도는 걸었다” 같은 느낌적인 느낌?</p><p>Rust와 Golang의 공정한 비교를 위해서 뭐를 비교할까 잠시 고민을 해보았다. 그런데 사실 퍼포먼스라는게 라이브러리를 뭘 쓰냐, 누가 어떻게 구현했냐에 따라 굉장한 차이를 내기 때문에, 뭔가 순수하게 Built-In정도의 함수만으로 벤치마킹을 해봐야하지 않을까? 라는 생각을 하게 되었고, HTTP API를 순수하게 소켓으로 짜보면 되겠다 라는 결론을 내렸다.</p><p>뭐 여기까지는 내 생각이고, 하루만에 내가 Rust로 HTTP Server를 짤 수 있겠는가!! 적어도 동시처리는 해줘야 벤치마킹 좀 했다 하는 소리를 듣지 않겠는가?! 라며 자학하던 중…rust-lang.org의 공식 도큐먼트 마지막 부분에 내가 원하던 수준의 딱 알맞은 <a href="https://doc.rust-lang.org/book/ch20-02-multithreaded.html">예제</a>가 있었다! (Thread Pool을 사용한 다중 요청처리)</p><p>이거다 싶어 바로 개발서버에 Rust를 설치,(윈도우 PC에 설치했다가 리눅스용 컴파일이 안되서…ㅠ 크로스컴파일이 잘안되는 점이 아쉬웠다) 빌드하고 실행시키는데 성공하였다. 곧장 최대한 비슷하게 Go로 해당 기능을 구현 하였다.</p><p>그러곤 저녁이면 할일없이 놀고만 있는(이메일 서비스 특성상) 발송서버들에게 임무를 부여해줬다. “ab(apache benchmark) 설치하고 저기에 부하 좀 때려봐!”</p><p>Rust에선 thread 수와 Golang에선 goroutine 수를 조정해가며 튜닝 좀 하고 각자 최대 성능을 낼 수 있는 수치에 맞춘 뒤 부하를 쏘아댔지만…서버(t2.micro) 10대를 동원해도 그를 만족시킬 순 없었다.(cpu를 20%도 안썼다.)</p><p>그래서 어쩔 수 없이 각 요청에 “cnt = cnt*cnt + cnt*2 + i” 와 같은 연산을 100만번씩 돌리는 로직을 추가했다. 사실 함수를 몇번 더 호출시켜서 Call Stack이 퍼포먼스에 영향을 주길 바랐다.</p><p>그리고 cpu를 95%까지 쥐어 짜내는 서버를 보며 흡족해 한 뒤, 결과를 비교해 보았다.</p><p>결과는??? 예상대로 Rust의 승리로 마무리 되었지만, 다시 한번 Go의 위대함을 느낄 수 있었다. 왜냐고?? 내가 실험한 환경에 국한하여 얘기하지만 Rust와 Go의 성능차이는 5%정도로 Rust가 우세하였지만, 동일한 기능을 구현하는데 작성된 코드 수는 Go는 60라인도 채 안되며, Rust는 3배정도 많았다. 그리고 goroutine과 channel의 조합은 진짜 말도 안되게 심플한 동시성 구현을 가능하게 해준다.</p><p>사실 Go로 Rust만큼 퍼포먼스를 내고자 여러가지 모드를 구현해서(goroutine pooling이나 channel을 통한 분산처리 등) 테스트 해보았지만 최근 버전의 Go는 단순 무식하게 Request Per Goroutine으로 짜도 별반 다르지 않은 퍼포먼스를 보여주었다. 뭐 말머리에서도 말한바와 같이 Go만 열심히 찬양하기 바빴는데…Rust는 Go보다 CPU를 조금 덜 먹긴 했다. cargo라는 멋진 툴도 있고, 함수형 프로그래밍도 가능하고! 뭔가 GC가 많이 발생할 것 같은 로직이 있으면 Rust의 강점이 좀 더 부각될 듯 싶다만…어려웡…단순 무식 Go가 최고!!</p><p>마지막으로 테스트한 코드를 첨부하오니 여러분들도 참고하시기 바랍니다!</p><p><a href="https://gist.github.com/plumhj/e6bf749d5ee4e020e592e15f37ad9027">https://gist.github.com/plumhj/e6bf749d5ee4e020e592e15f37ad9027</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bac94bc26e2e" width="1" height="1"><hr><p><a href="https://blog.stibee.com/golang-vs-rust-%ED%8D%BC%ED%8F%AC%EB%A8%BC%EC%8A%A4-%EB%B2%A4%EC%B9%98%EB%A7%88%ED%82%B9-%EC%8D%B0-bac94bc26e2e">Golang vs Rust 퍼포먼스 벤치마킹 썰</a> was originally published in <a href="https://blog.stibee.com">스티비 블로그</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[MySQL에서 RDS(Aurora) 로 이관하기]]></title>
            <link>https://blog.stibee.com/mysql%EC%97%90%EC%84%9C-rds-aurora-%EB%A1%9C-%EC%9D%B4%EA%B4%80%ED%95%98%EA%B8%B0-227db1da8fd8?source=rss-f2187e1bd113------2</link>
            <guid isPermaLink="false">https://medium.com/p/227db1da8fd8</guid>
            <category><![CDATA[aurora]]></category>
            <category><![CDATA[mysql]]></category>
            <category><![CDATA[migration]]></category>
            <category><![CDATA[stibee-team]]></category>
            <category><![CDATA[rds]]></category>
            <dc:creator><![CDATA[이학진]]></dc:creator>
            <pubDate>Mon, 03 Jul 2017 03:13:46 GMT</pubDate>
            <atom:updated>2019-02-19T10:04:45.269Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/857/0*E8tnPwG1Drr91fjw.png" /></figure><p>안녕하세요. 스티비팀 서버 개발자 이학진 입니다. 저희는 최근 서비스에서 사용 중이던 MySQL DB를 RDS로 이관하는 작업을 진행하였습니다. 무엇 때문에 이관을 결정하게 되었는지와 어떻게 이관을 진행하였는지에 대해 글을 써보도록 하겠습니다.</p><h3>배경</h3><p>stibee.com은 작년 11월에 정식 오픈한 새내기 이메일 마케팅 서비스 입니다. 사실 오픈 초기부터 얼마전까지만 해도 AWS EC2의 m4.large 인스턴스 하나로 운영되던 서비스였습니다.(사실 웹+API 서버 1대, 메일발송서버 1대)</p><p>그리고 이 싱글 인스턴스에 무려 6개의 서버, mysql 1개, kafka 1개, redis 1개가 돌고 있었습니다. 그럼에도 불구하고 cpu사용률은 20%를 넘지 않았습니다.</p><p>하지만 최근 사용자도 점점 늘어났고, 네이버에서 메일 수신정책을 변경하면서 메일발송서버에 대한 요청이 급증했습니다.</p><p>스티비에서 네이버로 대량메일을 발송했을 때 해당 메일의 본문 링크를 자동검사하는 것을 발견했는데요, 따라서 네이버로부터 비정상적으로 많은 요청이 들어오고 있었습니다. (어떤 기준으로 이런 검사를 하는 것인지 정확한 정책은 아직 모릅니다. 담당자분 이 글을 보신다면 연락주세요. 친하게 지냈으면 합니다 😍)</p><p>이내 곧 이메일을 마구 쏘아 되던 저희 서버는 네이버의 분노를 감당하지 못하고 cpu가 비명을 질렀습니다. (사실 네이버의 요청은 무난하게 처리하였으나, 요청 후 발생되는 이벤트 후처리에 DB를 과하게 사용하여…)</p><p>일단 네이버의 IP를 달고오는 패킷을 drop함으로써 문제를 해결하였지만 이로인해 이제 우리도 때가 왔다! 라는 판단을 하게 되었습니다.</p><p>그리하여 앞으로 대박 날 스티비를 대비하여 스케일아웃이 가능하도록 각각의 서비스를 분리하는 작업을 진행하게 되었습니다.(사실 지금도 조금씩 떼어내고 있습니다. 😱)</p><h3>준비</h3><p>앞서 RDS로 이관한다고 말씀드렸는데요. RDS는 AWS에서 제공하는 관계형 데이터베이스 서비스 입니다. RDS로 이용 가능한 DB는 Amazon Aurora, PostgreSQL, MySQL, MariaDB, Oracle, Microsoft SQL Server 등이 있습니다.</p><p>이 중 저희는 아마존에서 MySQL과 호환되며 최대 5배까지 성능을 낼 수 있다는 Aurora DB를 사용하기로 결정하였습니다.(결정권자 = 1인 = 나)</p><p>AWS의 모든 서비스가 그러하듯이 RDS를 생성하는 방법은 매우 간단합니다. RDS 콘솔로 진입하신 뒤, 메인 대쉬보드의 “Launch a DB Instance” 를 클릭 하시면 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/929/1*hEEM-stkxch6tmoOWJhcsw.png" /></figure><p>그러면 아래와 같이 사용 가능한 DB 목록들이 나타나는데 이 중 기본 값인 Aurora DB를 선택하고 “Select” 버튼을 누르시면 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*BtVktFEryms3mBUcAzjYqw.png" /></figure><p>그리고 회사의 자금사정(?)에 따라 인스턴스 타입을 결정하시면 됩니다.</p><blockquote>인스턴스 타입의 선택은 서비스의 특성에 따라 다르므로, 다양한 성능 테스트를 해보시기 바랍니다. 저희는 당시 EC2 인스턴스에서 DB가 같이 돌고 있었던 지라, EC2와 비슷한 사양이되 그 중 제일 저렴한 사양인 r3.large를 골랐습니다</blockquote><p>사양 선택에 있어 너무 고심할 필요는 없습니다. AWS에서는 클릭 한번으로 언제든 사양을 변경할 수 있으니까요~~</p><blockquote>사양을 변경하는 것은 인스턴스의 재부팅이 필요하므로 실서비스에 물리기 전에 결정하시기를 권장 드립니다.</blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*8Q4bPM7ysYOV2fYtpVAEsw.png" /></figure><p>여기서 한가지 주의하실 점은 Aurora DB는 기본적으로 클러스터로 구성됩니다. 클러스터란 쉽게 말해 여러 Aurora DB들을 하나로 묶어서 마치 하나의 DB처럼 사용가능하게 해주는 역할을 합니다.(이로인해 부하 분산, Fail-Over, 고가용성 등의 장점이 있습니다.) 앞서 저희는 하나의 인스턴스를 런칭 시키고자 하였으나, 설정페이지의 “Multi-AZ Deployment”의 기본설정을 보시면 “Create Replica In Difference Zone”으로 되어 있습니다. 이는 동일한 인스턴스를 다른 AZ에 추가적으로 둠으로써 고가용성을 보장하고 부하분산을 통해 성능향상을 해주겠다는 아마존 형님의 배려이십니다. 하지만 돈은 두배?^^ 그래서 스티비는 “No”(나중에 추가 할 수 있습니다.)</p><p>그 다음엔 DB Instance를 식별할 수 있게 이름을 부여하고 Root 역할을 할 Master Username과 패스워드를 설정해 줍니다. 그리고 “Next Step”</p><p>자! 이제 마지막 설정 페이지 입니다. 모든 옵션에 대해서 언급하고 넘어가기에는 설명이 너무 길어지니, 이것정도는 알아야 하겠다는 옵션에 대해서만 간략히 설명하도록 하겠습니다.</p><ul><li>VPC Security Group(s) : DB Instance의 인/아웃바운드 트래픽 규칙을 정할 수 있습니다. 여기에서는 이미 생성된 Security Group을 사용할지 아니면 새로 생성할 지를 정할 수 있으며, 선택된 Security Group의 세부 설정은 EC2 콘솔 페이지의 Security Group에서 할 수 있습니다.</li><li>Auto Minor Version Upgrade : Aurora DB의 마이너 패치가 나왔을 때, 자동으로 업그레이드를 할 지 여부입니다. Yes로 하면 두세달에 한번 업그레이드가 된다고 합니다. 주의하실 점은 업그레이드 시점에 DB는 사용 불가…(꺅!)</li><li>Maintenance Window : 자동으로 마이너 업그레이드를 한다면, 사용자의 이용이 가장 적은 시간대로 패치 시간을 적용할 수 있습니다.</li></ul><p>모든 설정을 마치고 “Launch DB Instance”를 클릭하면 잠시 후 Aurora DB가 뙇!!하고 모습을 드러내시니 이로써 이관에 대한 기본적인 준비를 마쳤습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/970/1*zmOmD8ugg6mxuNdb94BJ7A.png" /><figcaption>런칭된 오호라(?) DB</figcaption></figure><h3>이관</h3><p>AWS는 이관 방법에 대해 많은 정보를 문서로 제공합니다.</p><p><a href="http://docs.aws.amazon.com/ko_kr/AmazonRDS/latest/UserGuide/MySQL.Procedural.Importing.html">MySQL DB 인스턴스에서 데이터 가져오기 및 내보내기 - Amazon Relational Database Service</a></p><p>운영 중인 DB를 중단하지 않고 RDS로 이관하는 방법도 있지만 이는 이관 후 데이터의 정합성을 검증해야하고 운영 DB의 부하발생 등의 이유로 해당 방법은 사용하지 않았습니다. 비록 점검 공지를 띄우고 이관 종료까지 서비스를 사용할 수 없지만 엔지니어에게 부담없는 방법을 택했습니다.</p><p>먼저 대략적인 이관 시간을 파악하고 스티비 활성 사용자가 가장 적은 시간대를 선택하여 이관을 진행하였습니다.</p><p>이관 절차는 아래와 같았습니다.</p><ol><li>자정(0시)을 기점으로 점검 페이지 교체</li><li>DB를 사용하는 모든 서비스 종료</li><li>mysqldump를 이용한 DB백업</li><li>백업된 DB 파일을 EC2로 복사</li><li>EC2에서 mysql 명령어로 RDS 접속</li><li>source 명령어를 통한 백업파일 import</li><li>명령어 실행 종료 후, 서비스 구동 및 점검 페이지 교체</li></ol><p>이관을 진행함에 있어 EC2를 사용하는 이유는 다운타임을 최소화 하기 위해서 입니다. EC2와 RDS를 같은 VPC 내에 위치 시킴으로써 네트워크 속도가 가장 빠르기 때문입니다. (혹여나 그렇지 않을 경우 RDS가 속해 있는 VPC에 EC2를 생성해 주시기 바랍니다.)</p><p>아래는 3번부터 사용된 명령어 입니다.</p><pre>#DB 덤프 뜨기<br><strong>$ mysqldump -u db_user -p --databases db_name --single-transaction --compress --order-by-primary &gt; backup.sql</strong></pre><pre>#필요에 따라서 압축<br><strong>$ </strong><strong>tar -zcvf backup.tar.gz backup.sql </strong></pre><pre>#EC2로 덤프 파일 복사<br><strong>$ scp -r -i &lt;key pair&gt;.pem backup.sql.gz ec2-user@&lt;EC2 DNS&gt;:/&lt;target_directory&gt;/backup.sql.gz</strong><br>#덤프 파일 복사는 편하신 방법으로 진행하시면 됩니다.<br>#MySQL 서버가 EC2에서 돌고 있었다면 생략</pre><pre>#EC2에서 RDS mysql 접속<br><strong>$ mysql -h &lt;host_name&gt; -P 3306 -u &lt;db_master_user&gt; -p</strong><br>#host_name은 RDS 콘솔 페이지에서 확인 할 수 있는 Cluster Endpoint 입니다.</pre><pre>#DB 및 User 생성<br><strong>$ create database db_user;<br>$ grant all privileges on db_user.* to &#39;db_user&#39;@&#39;localhost&#39; identified by &#39;db_password&#39; with grant option;<br>$ grant all privileges on db_user.* to &#39;db_user&#39;@&#39;%&#39; identified by &#39;db_password&#39; with grant option;<br>$ flush privileges;</strong></pre><pre>#이관 시작<br><strong>$ source path/backup.sql</strong></pre><p>여기까지가 제가 진행한 이관절차의 끝 입니다. 그런데 과연 이렇게 간단하게 끝났을까요? 물론 아닙니다. 문제점 한두개 정도는 나와줘야 제맛 아니겠습니까?(사실 아씨 아씨 하면서 심장이 쫄깃 해졌습니다.)</p><h3>문제 발생 및 해결</h3><p>사실 지금까지 기술한 내용들은 AWS의 기술 문서에 매우 자세히 나와있어서 RDS를 사용하고자 하신 분들은 굳이 이 글을 읽지 않으셔도 무방하셨을거 같습니다. 하지만 저 문서들을 보고 진행 했음에도 불구하고 문제가 발생하더군요. 저희 서비스만의 문제였는지 모르겠지만 발생된 문제와 해결법을 공유해 보도록 하겠습니다.</p><h4>Timezone</h4><p>토종 한국 서비스라 Timezone이 한국표준시 였습니다. 그런데 기본 옵션으로 RDS 인스턴스를 생성하시면 국제표준시로 설정이 되어 시간값이 다르게 나왔습니다.</p><pre>DB Cluster Parameter Group의 time_zone 값을 Asia/Seoul로 변경한다.<br>기본 옵션값은 변경되지 않으므로 새로 생성한 뒤 변경하고, 인스턴스에 적용한다.</pre><h4>Import 중 ‘MySQL server has gone away’ 에러</h4><p>MySQL의 옵션중 클라이언트가 한번에 전송 할 수 있는 패킷량의 제한이 있습니다. 이관 테이블 중 Long Text 타입의 컬럼이 있었고 해당 컬럼의 데이터를 옮기지 못해 발생된 에러 입니다. (이와같은 이유로 아마존 기술 문서에 기술된 dump와 동시에 import하는 방식을 사용했을 때도 최대 1GB 밖에 전송할 수 없었습니다.)</p><pre>DB Parameter Group의 max_allowed_packet의 값을 늘린다.<br>기본 옵션값은 변경되지 않으므로 새로 생성한 뒤 변경하고, 인스턴스에 적용한다.</pre><h4>이모지 적용 안됨 😢</h4><p>스티비는 메일 제목과 본문에 이모지 사용을 적극 권장하고 있습니다. 😀 하지만 이관 후 작성된 메일의 이모지가 깨지는 현상이 발생 되었습니다. 이미 아시는 분들은 딱하고 감이 오시겠지만 네, CharacterSet 문제입니다. 그리고 이모지는 utf8mb4에서 지원됩니다.</p><pre>DB Cluster Parameter Group의 character 옵션들을 바꾼다.<br>character_set_client = utf8mb4<br>character_set_connection = utf8mb4<br>character_set_database = utf8mb4<br>character_set_filesystem = utf8mb4<br>character_set_results = utf8mb4<br>character_set_server = utf8mb4<br>collation_connection = utf8mb4_unicode_ci</pre><p>여기까지 스티비의 이관기를 모두 소개해 드렸습니다. 감사합니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=227db1da8fd8" width="1" height="1"><hr><p><a href="https://blog.stibee.com/mysql%EC%97%90%EC%84%9C-rds-aurora-%EB%A1%9C-%EC%9D%B4%EA%B4%80%ED%95%98%EA%B8%B0-227db1da8fd8">MySQL에서 RDS(Aurora) 로 이관하기</a> was originally published in <a href="https://blog.stibee.com">스티비 블로그</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
    </channel>
</rss>