<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" media="screen" href="/~d/styles/rss2full.xsl"?><?xml-stylesheet type="text/css" media="screen" href="http://feeds.feedburner.com/~d/styles/itemcontent.css"?><rss xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:feedburner="http://rssnamespace.org/feedburner/ext/1.0" version="2.0">

<channel>
	<title>생각하고 나누고 공감하기…</title>
	
	<link>https://blog.fupfin.com</link>
	<description>No man is an island, entire of itself. Every man is a piece of the continent, a part of the main.</description>
	<lastBuildDate>
	Sun, 03 Mar 2019 10:01:04 +0000	</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.1</generator>
<site xmlns="com-wordpress:feed-additions:1">69049871</site>	<atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="self" type="application/rss+xml" href="http://feeds.feedburner.com/fupfin/blog" /><feedburner:info uri="fupfin/blog" /><atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="hub" href="http://pubsubhubbub.appspot.com/" /><item>
		<title>(번역) 기술자의 히포크라테스 선서</title>
		<link>http://feedproxy.google.com/~r/fupfin/blog/~3/lpTWK9W0Enw/</link>
				<comments>https://blog.fupfin.com/?p=188#respond</comments>
				<pubDate>Sun, 03 Mar 2019 09:43:05 +0000</pubDate>
		<dc:creator><![CDATA[fupfin]]></dc:creator>
				<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://blog.fupfin.com/?p=188</guid>
				<description><![CDATA[저는 소프트웨어가 점차 사회의 핵심 요소로 사용되는 만큼 소프트웨어 개발자도 중요한 역할을 맡게 되었으니 전문가 의식을 가지고 그 역할에 맞는 행동을 해야 한다고 생각합니다. 대부분 개발자도 회사에 고용이 되어 일을 합니다. 하지만, 일반 노동자의 경우 고용자가 생산 수단을 제공하고 노동자는 단지 이 생산 수단을 운영하는데 필요한 노동력을 제공하는 것이 주인 것과 달리 소프트웨어 개발자(그리고 다른 [&#8230;]]]></description>
								<content:encoded><![CDATA[
<p>저는 소프트웨어가 점차 사회의 핵심 요소로 사용되는 만큼 소프트웨어 개발자도 중요한 역할을 맡게 되었으니 전문가 의식을 가지고 그 역할에 맞는 행동을 해야 한다고 생각합니다.</p>



<p>대부분 개발자도 회사에 고용이 되어 일을 합니다. 하지만, 일반 노동자의 경우 고용자가 생산 수단을 제공하고 노동자는 단지 이 생산 수단을 운영하는데 필요한 노동력을 제공하는 것이 주인 것과 달리 소프트웨어 개발자(그리고 다른 지식 노동자)는 자신이 가진 지식과 지능으로 제품을 만들기 때문에 그 지위도 고용인과 대등한 관계에 있다고 볼 수 있습니다. 저는 이런 상황을 &#8220;소프트웨어 개발자는 생산 시설을 들고 일터에 걸어들어가고 퇴근할 때 들고 나오는 노동자&#8221;라고 말하곤 합니다.</p>



<p>작년에 우연히 <a href="http://mariesa.me/">마리사 데일(Mariesa Dale)</a>이란 분의 <a href="https://mkdale.github.io/techoath/">기술자 히포크라테스 선서</a>라는 글을 읽었습니다.  내용을 읽고 너무나 감동했고, 오랫동안 견지하던 제 뜻과 일치하여 이 선서에 동참하기로 했습니다.</p>



<p>동료들에게도 소개하고 싶어서 번역하려 했으나 계속 미루기만 하다가 최근에 조금씩 번역해서 이렇게 공개합니다. 오역이나 어색한 부분은 알려주시면 수정하겠습니다.</p>



<span id="more-188"></span>



<hr class="wp-block-separator"/>



<h3>서문</h3>



<p>기술자들은 오늘날 강력한 도구를 휘두른다. 우리는 한 번도 만난 적 없는 사람들에게 영향을 끼치는 설계를 하고, 우선순위를 정하고, 세상에 물건을 선보인다. 우리는 그들의 손목에, 랩탑 안에, 주머니 속에 있고 따라서 그들의 머릿속에 있다. 때로는 윤리가 흑백처럼 분명하지만 때로는 조금 더 복잡할 수도 있다. </p>



<p>난 운 좋게 최근에 <a href="https://interaction18.ixda.org/program/keynote--alan-cooper/">인터랙션 18에서 진행된 앨런 쿠퍼의 강연</a>을 들은 청중 중 하나였는데, 그는 강연장을 가득 메운 기술자들에게 다음과 같은 시나리오를 상상해 보라고 요청하면서 강연을 시작했다.</p>



<ul><li> 당신은 데이터 분석가로서 거의 완벽하게 타게팅되어 십억 달러 규모의 사업을 가능케 하는 광고 플랫폼을 구축하도록 돕는다. 하지만 외국 해커는 광고 플랫폼을 대통령 선거에 영향을 미치고 대의 민주주의를 해치는 데 사용한다.</li><li> 당신은 세계 최고 수준이고 전 세계에 서비스될 기계 학습 철자 검사 알고리듬을 작성한다. 하지만 어느 날 이 알고리듬 때문에 몇 가지 처방 약 이름이 자동으로 다른 약 이름으로 수정했고 무고한 사람들이 피해를 당했다.</li></ul>



<p>이런 예는 기술이나 제작자를 비난하려는 것이 목적이 아니다. 우리가 무엇을 만들 때 짊어질 책임을 설명하려는 것이 그 목적이다. 쿠퍼가 강연에서 말했듯, 우리는 단지 현재 기술의 구멍을 땜질하기만 할 뿐 아니라, 미래 기술이 이런 식으로 오남용되는 것을 막으면서 앞으로 나아간다.</p>



<h3>선서의 배경</h3>



<p>모든 사람이 각자의 방식으로 자신의 기준을 긋는다. 그리고 아마도 영향력 있는 제품을 구현할 때 무엇인 타당한지 따지는 범위는 다양할 것이다. 이것이 바로 의도된 사용이 사용자 경험의 현실과 항상 같지는 않다는 면에서 기술자들이 자신의 심리적 영향과 그 외 성과를 이해하기 위해 자신들이 구현하는 패턴에 대해 스스로 교육할 길을 찾아야 하는 이유이다. 그뿐 아니라, 우리는 무언가 선을 넘을 때 권위를 주장할 권리가 있음을 알아야 합니다.</p>



<p>엔지니어, 디자이너, 제품 관리자, 데이터 과학자 등으로 살면서 매일 휘두르는 엄청난 힘에도 불구하고, 우리 산업에서 윤리에 대한 교육과 감독은 너무 미약하다. 그리고 이런 자아 성찰의 순간을 갖는 사람은 나뿐 아니라, <a href="https://www.fastcodesign.com/90132364/nest-founder-i-wake-up-in-cold-sweats-thinking-what-did-we-bring-to-the-world">아이폰 고안자</a>에서 <a href="http://blog.samaltman.com/tech-workers-values">와이-컴비네이터(</a><a rel="noreferrer noopener" target="_blank" href="http://blog.samaltman.com/tech-workers-values">Y Combinator)</a><a href="http://blog.samaltman.com/tech-workers-values"> 리더</a>, 그리고 <a href="http://humanetech.com/">더 많은 사람</a>이 모두 이를 느낍니다. </p>



<p>이 발견 과정에서 나는 윤리 표준을 자신들의 전문직에 통합하는 산업을 더 잘 이해하게 되었고, <a href="https://en.wikipedia.org/wiki/Hippocratic_Oath">의사의 히포크라테스 선서</a>를 본뜬 기술자를 위한 선서를 만들게 되었다. 이것이 첫 <a href="http://neveragain.tech/">기술직 종사자를 위한 서약</a>은 아니며 마지막도 아닐 것이지만, 우리가 더는 우리의 책임과 우리 작업의 잠재적 영향에 대해 무지할 수 없다는 새로운 세계의 일부이다.</p>



<p>원래 이것은 개인적인 노력이었고, 특히 중요한 설계 작업 동안 나 자신에게 충실할 수 있는 표준으로 만들었다. 하지만, 내가 이것을 공유한 동료의 범위가 점차 넓어지면서, 그중 일부도 선서의 가치를 발견했다. 어쩌면 당신도 그럴 것이다.</p>



<hr class="wp-block-separator"/>



<h2>기술자 선서</h2>



<p>나는 내 능력과 판단력을 다하여 이 서약을 이행할 것을 맹세한다.</p>



<p>나는 개인으로든 집단으로든, 사용자가 숫자나 목표가 아니라, 사람이고 존중되어야 한다는 것을 기억할 것이다.</p>



<p>나는 선배 기술자들이 어렵게 얻은 전문적이고 창의적인 성취를 존중할 것이고, 내 지식을 다가올 세대와 기꺼이 공유할 것이다.</p>



<p>나는 최종 사용자의 이익과 가치에 내 능력을 활용할 것이고, 제품의 목표가 이것과 충돌할 때 변호할 것이다.</p>



<p>기술에는 과학뿐 아니라 예술이 있고, 내가 내리는 결정의 결과에 대한 공감, 공예, 신중함이 나의 기술적 지식의 중요성이나 금전적 이득을 향한 충동이나 지위의 유혹보다 중요하다는 것을 기억할 것이다.</p>



<p>나는 &#8220;모른다&#8221;고 말하는 것을 부끄러워하지 않을 것이며, 심도 있는 비평이나 다양한 사고에 다른 사람의 실력이 필요할 때 동료들에게 도움을 청할 것이다.</p>



<p>나는 기술과 건강한 관계를 유지하기 위해 사용자가 필요함을 존중할 것이다. 내가 해결하려는 모든 문제에 대해, 나는 내가 만든 해결책의 대상자들과 직접 접속하도록 노력할 것이다.</p>



<p>나는 삶의 균형과 조작 문제에 주의를 기울이고, 윤리적 딜레마나 도덕적 무모함이 일어날 때 참여를 중단해야 한다.</p>



<p>나는 내가 만든 기술에 영향을 받은 이들의 삶에 긍정적인 영향을 주도록 노력할 것이다. 그러나 나는 삶에 심각한 결과를 초래할 부정적인 영향력이 내 힘 안에 있다는 것도 인정한다. 이 엄청난 책임은 나 자신의 한계에 대한 강한 겸손과 자각에 직면해야 한다.</p>



<p>난 내가 단지 플랫폼, 애플리케이션, 웹 사이트를 만들기만 할 뿐 아니라 내 작업이 결국 인류에게 영향을 미친다는 점을 기억할 것이다. 내 창조물을 사용할 지위나 자격이 그들의 가족, 경제적 안정성, 정신 건강에 영향을 미칠 수 있다. 내가 진정 윤리적인 제품을 만들었다고 믿는다면 내 책임에는 직접적인 관련 결과가 모두 포함되어야 한다.</p>



<p>나는 가능한 한 사용자의 착취를 막겠다. 방지하는 것이 구출하는 것보다 낫기 때문이다.</p>



<p>나는 내가 사회의 일원으로서 모든 내 동료 인간, 그들 마음의 소리와 지체부자유와 중도장애를 포함한 몸 모두에 특별한 의무가 있음을 기억할 것이다.</p>



<p>무엇보다, 나는 내가 관문을 지키는 사람임을 안다. 권위에 복종하기보다 내가 만든 기술의 결과에 훨씬 더 관심을 둔다. 내가 이 선서를 어기지 않는다면, 나는 삶과 내 기술을 즐기며, 내가 사는 동안 존중받고 그 후에는 기억될 것이다. 내가 항상 내 소명의 가장 높은 기준을 유지하기 위해 행동하기를 바라고, 내가 세상에 내놓는데 일조하는 경험과 제품을 통해 직간접적으로 내 도움을 구하는 사람들을 돕는 기쁨을 내가 오랫동안 경험하기 바란다.</p>
]]></content:encoded>
							<wfw:commentRss>https://blog.fupfin.com/?feed=rss2&amp;p=188</wfw:commentRss>
		<slash:comments>0</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">188</post-id>	<feedburner:origLink>https://blog.fupfin.com/?p=188</feedburner:origLink></item>
		<item>
		<title>OOP를 빨리 잊으라는 글에 대하여…</title>
		<link>http://feedproxy.google.com/~r/fupfin/blog/~3/yGE_5fVKwn4/</link>
				<comments>https://blog.fupfin.com/?p=179#respond</comments>
				<pubDate>Mon, 31 Dec 2018 01:16:03 +0000</pubDate>
		<dc:creator><![CDATA[fupfin]]></dc:creator>
				<category><![CDATA[Programming]]></category>

		<guid isPermaLink="false">http://blog.fupfin.com/?p=179</guid>
				<description><![CDATA[페이스북에 공유된 &#8220;[번역]OOP를 빨리 잊을 수록 여러분과 여러분의 소프트웨어에 좋습니다&#8220;라는 글의 제목을 보고 누르면서 데이크스트라 옹이 인용되었겠거니 했는데 역시나 그렇다. 데이크스트라옹은 코드의 정확성(?)을 중요하게 생각하는 사람이었고 수학처럼 증명을 하면서 엄격하게 코드를 쌓아 올라가는 편을 선호했다. 그리고 그는 OOP란 아이디어를 별로 좋아하지 않았다. 반면에 OOP를 창안한 앨런 케이는 조금 더 실용적인 편이었고 데이크스트라가 지나치게 엄격하다고 비판하기도 [&#8230;]]]></description>
								<content:encoded><![CDATA[
<p>페이스북에 공유된 &#8220;<a href="https://adhrinae.github.io/posts/the-faster-you-unlearn-oop-the-better-for-you-and-your-software-kr">[번역]OOP를 빨리 잊을 수록 여러분과 여러분의 소프트웨어에 좋습니다</a>&#8220;라는 글의 제목을 보고 누르면서 데이크스트라 옹이 인용되었겠거니 했는데 역시나 그렇다.</p>



<p>데이크스트라옹은 코드의 정확성(?)을 중요하게 생각하는 사람이었고 수학처럼 증명을 하면서 엄격하게 코드를 쌓아 올라가는 편을 선호했다. 그리고 그는 OOP란 아이디어를 별로 좋아하지 않았다. 반면에 OOP를 창안한 앨런 케이는 조금 더 실용적인 편이었고 데이크스트라가 지나치게 엄격하다고 비판하기도 했다.</p>



<p>암튼, 이 글은 유효할지 모르나 유용하진 않다.</p>



<span id="more-179"></span>



<p>글을 읽으며 들었던 세부 항목 하나하나에 대한 반론은 글 마지막에 덧붙여진 아샬님 트윗에 대부분 적혀 있다.</p>



<p>글쓴이는 글의 절반 정도를 “잘못된 OOP”를 공격하는데 할애한다. 어떤 개념을 반대하는 류의 글 대부분이 반대하려는 개념  자체보다 그 개념을 잘못 적용한 사례를 잔뜩 나열하며 해당 개념이 문제라고 공격한다. 이는 학자의 자세라기 보다는 정치인의  자세이다.</p>



<p>그럼에도 내가 유효하다고 한 이유는 사실상 OOP를 한답시고 저지르는 범죄들을 잘 나열했기 때문이다. 난  글에서 지적한 죄목들이 대부분이 유죄임을 인정한다. 그게 OOP을 오해했거나 OOP와 상관 없더라도 OOP의 이름으로 저질러지고  있다는 사실은 맞다.</p>



<p>횡단 관심사 같이 OOP에서 풀기 어려운 문제도 잘 지적했다.</p>



<p>이렇게 유효한 글이지만 유용하지 않다. 요즘은 이렇게 OOP를 까고나면 FP라도 내세우는 편인데 이 글을 대안을 딱히 얘기하지 않는다. 그런면에서 유용하지 않다.</p>



<p> 무엇보다 OOP라는 것이 역사적 이유로 인해 명확한 정의가 없어 코에 걸면 코걸이, 귀에 걸면 귀고리인데 이걸 까 봐야 뭘 어쩔 것인가? 이 또한 이 글이 유용하지 않은 이유이다.</p>



<p>이 글은 로직보다 데이터가 중요하다는 선언으로 시작한다. 이 명제는 오랫동안 프로그래머 세계에서 공리처럼 받아들여졌다. 나도  데이터 구조가 중요하다는 생각에 동의한다. 하지만 거시적인 관점으로 올라가면 시스템은 서로 정해진 인터페이스로 협력하는 하부  시스템의 집합으로 그려질 수 있다. 데이터는 모듈 속으로 숨어서 보이지 않는다.</p>



<p>OOP의 캡슐화 관점에서 프로그래밍  언어는 크게 세가지로 나눌 수 있을 것 같다. 처음부터 데이터와 로직을 분리해서 다루는 방식과 모든 프로그램을 작은 컴퓨터로  분해해서 끝까지 데이터와 로직을 함께 묶는 방식과 이 둘의 어중간한 중간으로 어느정도까지는 데이터와 로직을 묶어서 다루지만 일정  수준 이상이 되면 분리하는 방식이다.</p>



<p>비 OOP 언어 대부분이 첫번째에 해당한다. 두번째는 소위 말하는 순수 OOP  언어로서 극소수이다. OOP에 대한 관점이 다양하다보니 어떤 이는 순수 OOP 언어는 스몰톡 뿐이라고 하기도 한다. 대부분의  OOP 언어는 세번째에 속한다. 여기에서 스칼라나 오캐멀(OCaml) 같이 OOP와 FP를 결합한 언어의 기회가 생기는 것이다.</p>



<p>글쓴이는 &#8220;제 의견을 말씀드리자면 클래스와 객체는 너무 나뉘어 있고, 제대로 &#8216;격리&#8217; 나 &#8216;API&#8217; 에 신경을 쓸 수 있는  지점은 &#8216;모듈&#8217; / &#8216;컴포넌트&#8217; / &#8216;라이브러리&#8217; 의 경계라고 생각합니다&#8221;라고 말했는데 이 부분이 우리가 꼬인 실타래를 같이 풀기  시작해볼만한 실마리라고 생각한다. OOP를 난잡하게 전방위로 공격하던 이 분과 그래도 이야기를 시작해볼만한 접점이다. 세번째  부류 언어 관점의 OOP로서 말이다.</p>



<p>OOP는 좋은 코드를 작성하고자 하는 사람이 좋은 코드를 작성하는데 방법을  고민하면서 사용하면 도움이 되지만 남들이 OOP는 이러이러한 거라고 말하는 설명을 곧이곧대로 받아들여 기계적으로 따르면 자동으로  좋은 코드가 나오는 건 아니다.</p>



<p>세상에 그런 기술은 없다.</p>



<p><br></p>
]]></content:encoded>
							<wfw:commentRss>https://blog.fupfin.com/?feed=rss2&amp;p=179</wfw:commentRss>
		<slash:comments>0</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">179</post-id>	<feedburner:origLink>https://blog.fupfin.com/?p=179</feedburner:origLink></item>
		<item>
		<title>DDD 제한적 컨텍스트와 마이크로서비스의 크기</title>
		<link>http://feedproxy.google.com/~r/fupfin/blog/~3/QI0xWZrCyKY/</link>
				<comments>https://blog.fupfin.com/?p=161#respond</comments>
				<pubDate>Fri, 29 Jul 2016 13:40:18 +0000</pubDate>
		<dc:creator><![CDATA[fupfin]]></dc:creator>
				<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://blog.fupfin.com/?p=161</guid>
				<description><![CDATA[지난 6월달에 열린 DDD eXchange의 키노트에서 에릭 에반스가 도메인 주도 설계의 개요를 설명하면서 모델이란 무엇이고 책 출간 이후 기술 변천에 따라 DDD는 어떤 의미가 되었는지 발표했습니다. 모델이 무엇인지 지도를 사용해서 설명하는 데 모델은 현실을 그대로 반영하는 게 아닐 뿐 아니라 완벽할 필요도 없다는 얘기가 인상적입니다. 발표 내내 이벤트 소싱은 여러번 강조했고, 역시나  (요즘 인기있는) 마이크로서비스를 가지고 제한적 컨텍스트(Bounded [&#8230;]]]></description>
								<content:encoded><![CDATA[<p class="p1">지난<span class="s1"> 6</span>월달에 열린<a href="https://skillsmatter.com/skillscasts/8288-tackling-complexity-in-the-heart-of-software"><span class="s1"> DDD eXchange의 </span>키노트</a>에서 에릭 에반스가 도메인 주도 설계의<span class="s1"> </span>개요를 설명하면서 모델이란 무엇이고<span class="s1"> </span>책 출간 이후 기술 변천에 따라<span class="s1"> DDD</span>는 어떤 의미가 되었는지 발표했습니다<span class="s1">. </span>모델이 무엇인지 지도를 사용해서 설명하는 데 모델은 현실을 그대로 반영하는 게 아닐 뿐 아니라 완벽할 필요도 없다는 얘기가 인상적입니다<span class="s1">.</span></p>
<p class="p1">발표 내내 이벤트 소싱은 여러번 강조했고, 역시나 <span class="s1"> (</span>요즘 인기있는<span class="s1">) </span>마이크로서비스를 가지고 제한적 컨텍스트<span class="s1">(Bounded Context) </span>약 파는 것도 잊지 않았습니다<span class="s1">.</span></p>
<p class="p1">약 한 달 전에<span class="s1"> 회사 동료와 </span>마이크로서비스와 제한적 컨텍스트를 두고 가볍게 토론을 했습니다<span class="s1">. 동료의 팀에서</span> 마이크로서비스 아키텍처로 애플리케이션을 만들었는데 잘 안 풀렸고 나중에 보니 제한적 컨텍스트를 적용하지 않았기 때문이라고 말했습니다. 하지만 저는 이 의견에 동의하지 않았습니다<span class="s1">.</span></p>
<p class="p1"><span id="more-161"></span></p>
<p class="p1"> 에릭 에반스는<span class="s1"> 2003</span>년에<span class="s1"> DDD</span>를 출간한 이후에<span class="s1"> DDD</span>도 변화와 발전을 했고 그 대표가 이벤트 소스이며 제한적 컨텍스트도 중요도가 바뀌었다고 합니다. 자신이 다시 책을 쓴다면 기존처럼 제한적 컨텍스트를 책 후반부에 두지 않고 보편적 언어와 함께 핵심 요소로 강조할 거라고 했었던 것으로 기억합니다. 그러면서 마이크로서비스 마다 제한적 컨텍스트를 두고 독립된 보편적 언어를 만들어야 한다고 주장합니다.</p>
<p class="p1">제가 제 동료의 생각에 반대한 이유는 제한적 컨텍스트가 중요하지 않다고 생각해서가 아니라 마이크로서비스의 크기 때문입니다.</p>
<p class="p1">제가 알기로 동료가 말한 애플리케이션 개발 프로젝트는 잘 해야 네댓 명이 단기간에 만든 소규모 서비스인데 그 안에서 만든 마이크로서비스의 크기라는 게 독립적인 보편적 언어<span class="s1">(ubiquitous language)</span>를 갖을 정도로 크다고 판단되지 않았습니다.</p>
<p class="p3">마이크로서비스와 관련한 논란 중 대표적인 것이 마이크로서비스는 얼마나 마이크로해야 하느냐, 즉 얼마나 작아야 마이크로서비스냐는 문제입니다.</p>
<p class="p3">어떤 사람은 마이크로서비스는 컴포넌트가 아니라고 말하면서 마이크로서비스는 생각보다 크다고 말합니다.</p>
<p class="p3">한편으로 마이크로서비스는 한 스크럼 팀이 한 스프린트에 개발할 정도의 규모여야 한다고 말하는 사람도 있습니다.</p>
<p class="p3">마이크로서비스 하나는 한 팀 정도가 담당하는 규모라는 의견도 있습니다.</p>
<p class="p3">에릭 에반스가 마이크로서비스 아키텍처의 유행을 틈타서 제한적 컨텍스트가 마이크로서비스의 문제를 해결해 줄거라고 약 팔고 다닌 건 작년에 인지했습니다. 닐 포드는 마이크로서비스 아키텍처가<span class="s1"> DDD</span>를 물리적인 아키텍처로 현실화 한 것이라고 말하면서 에릭 에반스를 응원합니다.에릭 에반스의 이 주장과 함께 인터넷에는 이에 동조하는 글이 많이 생겨났습니다. 하지만 저는 이 주장에 선뜻 동의하지 못합니다<span class="s1">.</span></p>
<p class="p3">도메인 주도 설계에서 에릭 에반스는 대규모 조직에서 너무 큰 단위 모델을 일관되게 유지하는 것이 비현실적이라면서 독립적인 보편적 언어를 개발할 수 있도록 도메인 영역을 제한하도록 권합니다. 그러면서 제한적 컨텍스트라는 개념을 소개합니다. 그런데 책에서 이 때 말한 &#8220;너무 큰&#8221;의 규모는 기업 전체 규모입니다. 한 회사 전체가 단일 언어를 유지할 수 없다는 말입니다. 한 회사라는 기준도 회사의 크기가 천차 만별이라서 절대적인 기준은 아니겠지만 한 언어를 유지할 수 없을 정도로 충분히 큰 조직이라는 사실만은 분명합니다.</p>
<p class="p3">아무리 그 동안 제한적 컨텍스트를 적극적으로 활용하는 방향으로 DDD가 발전했다고 해도 소수의 인원이 단기간에 마이크로서비스 아키텍처로 개발했다는 애플리케이션의 마이크로서비스가 독립적인 보편적 언어를 갖는다는 건 지나친 적용이라고 생각합니다.</p>
<p class="p3">거꾸로 에릭 에반스의 주장을 적극 받아 들여서 마이크로서비스의 크기를 정하는 방식도 가능합니다. 어차피 마이크로서비스의 크기에 대해 합의가 안 되고 논란이 계속된다면 보편적 언어를 갖을 만큼 크고 독립적인 단위라는 기준을 사용하는 것도 나쁘지 않아 보입니다.</p>
<p class="p3">좋은 설계를 강조하는 전문가들은 너무 엄격한 기준을 제시하는 경향이 있습니다. 저는 아무리 에릭 에반스가 제한적 컨텍스트를 강조하더라도 지나치게 작은 제한적 컨텍스트를 설정함으로서 컨텍스트 매핑을 복잡하게 만들고 한 팀에서 여러 독립적인 언어(모델)를 사용하도록 해서는 안 된다고 생각합니다.</p>
<p class="p3">커뮤니케이션의 문제를 극복하는 게 DDD의 목적 중 하나인데 오히려 DDD 때문에 커뮤니케이션이 복잡해진다면 이는 DDD의 애초 목적에도 맞지 않습니다.</p>
<p class="p3">DDD 책을 보면 제한적 컨텍스트와 모듈의 차이에 대한 박스 글이 있습니다. &#8220;제한적 컨텍스트는 모듈이 아니라&#8221;라는 이 글에서 에릭 에반스는 제한적 컨텍스트 안에 여러 모듈을 둘 수 있다고 말합니다. 저는 이 모듈이 마이크로서비스로 보입니다.</p>
]]></content:encoded>
							<wfw:commentRss>https://blog.fupfin.com/?feed=rss2&amp;p=161</wfw:commentRss>
		<slash:comments>0</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">161</post-id>	<feedburner:origLink>https://blog.fupfin.com/?p=161</feedburner:origLink></item>
		<item>
		<title>자바 프로그래머에게 재귀는 왜 어려운가?</title>
		<link>http://feedproxy.google.com/~r/fupfin/blog/~3/3LyUl8WMjPs/</link>
				<comments>https://blog.fupfin.com/?p=150#comments</comments>
				<pubDate>Fri, 05 Feb 2016 13:22:12 +0000</pubDate>
		<dc:creator><![CDATA[fupfin]]></dc:creator>
				<category><![CDATA[Java]]></category>
		<category><![CDATA[Programming]]></category>

		<guid isPermaLink="false">http://blog.fupfin.com/?p=150</guid>
				<description><![CDATA[저는 컴퓨터 과학 전공자가 아닙니다. 워낙 호기심이 많고 몰입하는 성향이라서 어릴 때 애호가로 프로그래밍을 시작했다가 전공을 버리고 프로그래머로 사회생활을 시작한 사람입니다. 그래서 체계적으로 이론 먼저 배우기 보다는 몸으로 먼저 익히고 나중에 이론을 배우면 정리를 하는 편입니다. 재귀 호출도 저에게는 그와 같은 사례 중 하나 입니다. 어릴 때 이런 저런 프로그래밍 관련 지식을 배우면서 알게 되었고 [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>저는 컴퓨터 과학 전공자가 아닙니다. 워낙 호기심이 많고 몰입하는 성향이라서 어릴 때 애호가로 프로그래밍을 시작했다가 전공을 버리고 프로그래머로 사회생활을 시작한 사람입니다. 그래서 체계적으로 이론 먼저 배우기 보다는 몸으로 먼저 익히고 나중에 이론을 배우면 정리를 하는 편입니다.</p>
<p>재귀 호출도 저에게는 그와 같은 사례 중 하나 입니다. 어릴 때 이런 저런 프로그래밍 관련 지식을 배우면서 알게 되었고 자연스럽게 익혀서 쓰는 기법입니다. 어떤 문제는 재귀가 아니면 쉽게 푸는 방법을 전혀 모르기도 합니다.</p>
<p>시간이 된다면 이 문제를 하나 풀어 보십시오.</p>
<p>미국에는 1 센트, 5 센트, 10 센트, 25 센트 50 센트 등 다섯가지 동전이 있습니다. 이 동전을 무한정 확보할 수 있다고 하면 이들의 조합으로 어떤 금액도 만들 수 있습니다. 특정 금액 m이 주어졌을 때 이 다섯가지 동전을 조합해서 주어진 금액을 만들 수 있는 경우의 수는 몇가지가 있을까요?</p>
<p>꼭 완벽하기 풀지는 않더라도 몇 분 만이라도 어떻게 풀면 될지 생각해 보십시오.</p>
<p><span id="more-150"></span></p>
<p>이 문제는 &#8220;컴퓨터 프로그램의 구조와 해석”이라는 책의 1.2.2 장에서 &#8220;분기되는 재귀”를 설명하는 중에 예제로 나온 유명한 문제입니다. 저는 이 문제를 재귀가 아니면 잘 풀지 못합니다. 제가 재귀로 푼 코드는 다음과 같습니다.</p>
<p></p><pre class="crayon-plain-tag">public class ChangeCounter
{
    int cents[] = { 50, 25, 10, 5, 1 };

    public int count(int amount)
    {
        return count(amount, 0);
    }

    private int count(int amount, int idx)
    {
        if (amount == 0)
            return 1;
        else if (amount &lt; 0 || idx &gt;= cents.length)
            return 0;
        else
            return count(amount - cents[idx], idx) + count(amount, idx + 1);
    }
}</pre><p></p>
<p>어떤 분은 저와는 달리 (스택을 사용한다거나 하는 방법으로) 재귀를 사용하지 않고도 문제를 풀 수 있겠지만 이렇게 단순하게 해결되지는 않을 겁니다. 제가 말하고 싶은 건 재귀는 어떤 문제의 경우 아주 효과적인 해결 방법입니다. 그리고 놀랍게도 별로 어렵지도 않습니다.</p>
<p>저는 최근에 자바 개발자 중에 재귀를 무척 어려운 고급 기법으로 알고 일부러 외면하거나 학습하면서 어려워하는 모습을 보면서 사실 좀 놀랐습니다. 그리고 왜 그러는지 궁금했습니다. 절대 재귀를 어려워하는 분들을 조롱하고 비난한다는 얘기가 아닙니다. 저는 정말 프로그래밍에 숙달된 분 조차 재귀를 어렵게 느끼도록 하는 요인이 뭔지 궁금했습니다. 더 나아가서 그 문제를 풀어 줄 방법도 알고 싶었습니다. 아직 완벽하게 범인을 알아 낸 것은 아니지만 몇몇 용의자를 찾았고 그 중 누가 범인인지 대략 느낌이 갑니다.</p>
<h2>무혐의 용의자: 스택 오버 플로 공포증</h2>
<p>자바 개발자들과 재귀를 이야기하는 자리에는 늘 스택 오버 플로를 우려하는 목소리가 들립니다. 사실 자바 뿐 아니라 C나 다른 명령형 언어를 사용하는 사람들 가운데에도 이 도시 괴담이 떠도는 것을 보면 역사가 깊은 전설 같습니다. 많은 분들이 프로그래밍에 입문하면서 존경하는 선배나 선임자에게 재귀를 사용하면 스택 오버 플로 오류가 발생해서 프로그램이 멈출 수 있으니 절대! 예외 없이! 언제나! 누구라도! 사용해서는 안된다고 배웠고 이를 금과옥조처럼 여기며 살았던 것입니다.</p>
<p>선배의 말처럼 재귀는 대부분의 언어에서 잘못하면 스택 오버 플로가 발생할 수 있는 위험한 기법입니다. 반복문이 잘못하면 무한 루프에 빠질 수 있는 위험한 기법인 것처럼 말입니다. 사실 프로그래밍을 잘못 작성하지 않는다면 재귀로 인해 스택 오버 플로가 일어나는 일은 흔치 않으며 스택 오버 플로가 발생할 수 있는 상황을 회피하는 방법도 있습니다. 특성을 이해하고 활용하면 도움이 되는 좋은 기법이며 무조건 회피할 이유가 없습니다.</p>
<p>이 공포증이 재귀를 멀리하게 만든 원흉인 것은 맞지만 정작 재귀를 익히면서 어렵다는 생각이 들게 만드는 요인은 아닐 것입니다. 저는 재귀가 어렵지 않다고 생각하고 권했는데 실제로 많은 자바 개발자들이 익히면서 어려워하는 것을 실제로 봤습니다.</p>
<h2>첫째 용의자: 높은 난이도</h2>
<p>가장 먼저 떠오르는 용의자는 재귀가 정말 이해하기 어려운 기술이라는 주장입니다. 재귀를 별다른 노력 없이 익힌 내가 초천재일지도 모릅니다. IQ 140이 넘는 사람들은 세상 모른 사람들이 자기처럼 머리가 똑똑한 줄 안다고 하더군요. 저는 IQ가 겨우 100을 넘지만 혹시 IQ 테스트에 문제가 있던 것은 아닐까요? 알고 보면 제가 아인슈타인이나 파인만 같은 천재일지도 모릅니다.</p>
<p>하지만 이는 사실이 아닙니다. 단언하건데 저는 머리가 그리 좋지 않습니다. 학창 시절에도 성적이 좋지 않았고 사회 생활을 하면서도 늘 제 지능이 평균 수준이라는 사실은 끊임 없이 확인했습니다. 대체로 복잡한 일을 좋아하는 프로그래머 사이에서는 오히려 평균 이하라고 생각됩니다. 따라서 제가 재귀를  별 어려움 없이 습득했는데 저보다 분명히 똑똑한 많은 사람들이 습득하는 데 곤란을 격은 이유는 대단히 복잡한 어려운 개념이기 때문이 아닙니다.</p>
<h2>둘째 용의자: 분기가 일어나는 반복적 구조 경험 부족</h2>
<p>우리가 흔히 경험하는 반복적 구조는 선형적인 반복입니다. 선형적인 반복 상황에서도 재귀를 사용할 수 있고 실제로 함수형 언어에서는 선형 반복에도 재귀를 사용하지만 자바 프로그래머들은 보통 이런 반복 구조는 for나 while 같은 반복문으로 처리합니다. 여러 반복문을 중복하는 2차원, 3차원 등 다차원 반복문도 결국은 선형 반복의 변형일 뿐입니다.</p>
<p>단순한 선형 반복이 아닌, 분기가 일어나는 반복적 상황, 예를 들어 트리 구조 탐색 같은 상황은 일반적인 애플리케이션 프로그래밍, 특히 DB 의존적인 애플리케이션의 개발에는 접할 일이 별로 없습니다. 그런데 이런 형태의 반복적 상황은 선형 반복으로는 해결할 수 없습니다. 반복문과 함께 분기 지점의 상태를 임시로 보관할 스택 같은 자료구조가 별도로 동원되어야 하는데요. 재귀호출을 사용하는 방식과 스택에 할일을 보관하면서 분기를 직접 처리하는 방식은 사실상 동일합니다. 시스템의 호출 스택을 사용할 것이냐 별도의 명시적인 스택을 사용하느냐의 차이 뿐입니다.</p>
<p>선형 반복에도 주로 재귀를 사용하는 함수형 프로그래밍 언어에서는 이미 재귀에 익숙하기 때문에 분기를 처리해야 하는 문제도 큰 어려움 없이 재귀로 해결합니다. 하지만 반복문으로 선형 반복을 처리하던 자바 개발자는 분기 상황에서 갑자기 처리 방법을 재귀로 바꾸거나 스택을 도입해야 하기 때문에 난이도가 갑자기 올라가는 것으로 느낄 것입니다. 그나마 스택을 사용한 번거로운 방법을 조금 더 쉽다고 느끼는 것 같습니다.</p>
<p>이 용의자는 제가 용의자 목록에서 제외 시켰던 첫번째 용의자와 공범일 가능성이 높습니다. 좀 처럼 경험하기 힘들고 복잡한 문제를 해결하는 기술이기 때문에 낯설 뿐 아니라 더 어렵다고 주장할 수 있습니다. 만약 이것이 범인이었다면 전 보다 똑똑한 사람이어야 합니다. 그런데 그다지 똑똑하지 않다고 이미 말씀드렸으므로 성급하게 범인으로 지목하지 않겠습니다.</p>
<p>다만 자바 개발자 입장에서 컬랙션 프레임워크(Collection Framework)가 반복문으로 처리하기 좋게 만들어져있기 때문에 함수형 프로그래밍 언어를 사용하는 사람들과 달리 재귀를 경험할 기회가 별로 없고, 재귀로 풀면 좋은 문제 상황을 드물게 만나면 갑자기 사고하는 방식을 바꿔야 하기 때문에 어렵다고 느낄 수는 있습니다.</p>
<h2>셋째 용의자: 제어 흐름 추적 습관</h2>
<p>자바는 명령형 프로그래밍 언어입니다. 객체지향 언어를 표방하지만 그 기저에는 명령형 패러다임이 깔려 있습니다. 따라서 우리는 자바로 프로그래밍을 할 때 컴퓨터에게 명령을 내린다고 생각하면서 그 명령의 순서와 분기와 반복을 추적하는 습관을 무의식 중에 훈련합니다.</p>
<p>예를 들어 팩토리얼을 구하는 코드를 작성해 보겠습니다. 팩토리얼은 특정 숫자 n이 주어졌을 때 1부터 n까지의 자연수를 모두 곱한 수이고 n!이라고 표기합니다. 이를 정의하면 다음과 같은 수식으로 표현할 수 있습니다.</p>
<p><a href="http://blog.fupfin.com/wp-content/uploads/2016/02/factorial1.png"><img class="alignnone wp-image-151 size-full" src="http://blog.fupfin.com/wp-content/uploads/2016/02/factorial1.png" alt="팩토리얼 식" width="82" height="49" /></a></p>
<p>1부터 n까지의 숫자를 모두 곱한 값이므로 이를 코드로 바꾸면 다음과 같이 반복문을 사용해서 계산할 수 있습니다.</p>
<p></p><pre class="crayon-plain-tag">int factorial(int n)
{
    int fact = 1;
    for(int c = 1; c &lt;= n; c++)
        fact = fact * c;
    return fact;
}</pre><p></p>
<p>이 코드를 작성하고 읽을 때 우리는 한줄 한줄 컴퓨터가 실행하는 과정을 단계별로 추적합니다. 결국 우리는 컴퓨터가 어떻게 팩토리얼을 계산하는지 알려준다는 느낌으로 코드를 작성합니다.</p>
<p>팩토리얼을 위와 다른 형태의 식으로 정의할 수 있습니다.</p>
<p><a href="http://blog.fupfin.com/wp-content/uploads/2016/02/factorial2.png"><img class="alignnone size-medium wp-image-152" src="http://blog.fupfin.com/wp-content/uploads/2016/02/factorial2.png" alt="factorial2" width="251" height="60" /></a></p>
<p>n이 0일 때는 1이고 0보다 클 때에는 (n-1)!와 n의 곱이라는 의미입니다. 이를 코드로 표현하면 다음과 같습니다.</p>
<p></p><pre class="crayon-plain-tag">int factorial(int n)
{
    if(n == 0) return 1;
    else return factorial(n-1) * n;
}</pre><p></p>
<p>보시는 것처럼 위 식을 그대로 코드로 담았습니다. 이 코드는 어떻게 문제를 풀어야 하는지 명령을 내린다는 느낌 보다는 문제 정의 자체를 그대로 코드로 표현한다는 느낌으로 작성했습니다.</p>
<p>핵심은 이렇습니다. 우리가 프로그래밍을 하는 방법은 크게 두 가지입니다. 보통은 우리는 컴퓨터에게 명령을 내려서 문제를 풀게 제어한다는 생각으로 프로그래밍하도록 훈련 받았습니다. 그런데 고수준 언어에서는 이렇게 명령을 내리는 방식 말고 문제 정의를 코드로 표현한다는 느낌으로 코딩하는 방식도 있습니다. 이런 방식을 선언적 프로그래밍이라고 합니다.</p>
<h2>결론</h2>
<p>저는 확신하는데 재귀를 어렵게 느끼는 이유는 머리가 나빠서도 아니고, 좀 처럼 경험하기 힘든 특수한 상황에서만 필요한 고급 기법이기 때문도 아닙니다.</p>
<p>프로그램을 작성하면서 머리를 굴리는 방식이 다르기 때문입니다. 즉, 어려운 게 아니고 다른 겁니다. 다시 말해 어색한 것이지 난해한 게 아닙니다.</p>
<p>재귀 문제 몇 번 만 풀어보면 금방 감을 잡을 수 있습니다. 물론 명령형으로도 어려운 알고리듬을 만들려면 어려운 것처럼 재귀로도 어려운 알고리듬은 어렵습니다. 하지만 재귀가 어려운 건 아닙니다.</p>
<p>사실 재귀를 쉽게 이해하는 방법까지 이번 글에 담으려고 했는데 오늘은 우리가 재귀를 이해하는 데 어려움을 겪는 이유에 대해서만 적도록 하겠습니다.  다음 기회에 재귀를 설명해 보도록 하겠습니다.</p>
<p>힌트를 드리자면 재귀 코드를 보면 절대 흐름을 추적하려 마십시오. 오히려 문제를 정의한 식으로 보십시오. 그리고 어떤식으로 처리될지 머리에서 CPU를 모의 실험하지 마시고 그 정의가 무엇을 나타내는 정의인지 이해하려고 하십시오.</p>
]]></content:encoded>
							<wfw:commentRss>https://blog.fupfin.com/?feed=rss2&amp;p=150</wfw:commentRss>
		<slash:comments>4</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">150</post-id>	<feedburner:origLink>https://blog.fupfin.com/?p=150</feedburner:origLink></item>
		<item>
		<title>어려운 기술 면접을 변명함</title>
		<link>http://feedproxy.google.com/~r/fupfin/blog/~3/SupkjJuWHwA/</link>
				<comments>https://blog.fupfin.com/?p=137#comments</comments>
				<pubDate>Sun, 24 Jan 2016 06:09:40 +0000</pubDate>
		<dc:creator><![CDATA[fupfin]]></dc:creator>
				<category><![CDATA[Craftmanship]]></category>
		<category><![CDATA[Programming]]></category>

		<guid isPermaLink="false">http://blog.javawocky.org/?p=137</guid>
				<description><![CDATA[존경하는 최범균님께서 얼마 전에 &#8220;면접이 이리 어려워서야&#8220;라는 글을 쓰셨습니다. 범균님은 몇몇 회사에서 SW 개발자를 뽑으면서 지나치게 높고 폭넓은 수준의 역량을 요구하는 것 같다면서 그런 사람을 뽑고 싶은 마음은 이해하지만 그런 사람이 세상이 몇이나 되겠냐며 현실에 맞춘 기준이 필요하지 않냐고 제안하십니다. 글을 읽으면서 이 비판(나쁜 의미가 아닌)에 일부 동의하면서도 제가 비판 대상의 일부임을 솔직히 인정하지 않을 [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>존경하는 최범균님께서 얼마 전에 &#8220;<a href="https://brunch.co.kr/@madvirus/28">면접이 이리 어려워서야</a>&#8220;라는 글을 쓰셨습니다. 범균님은 몇몇 회사에서 SW 개발자를 뽑으면서 지나치게 높고 폭넓은 수준의 역량을 요구하는 것 같다면서 그런 사람을 뽑고 싶은 마음은 이해하지만 그런 사람이 세상이 몇이나 되겠냐며 현실에 맞춘 기준이 필요하지 않냐고 제안하십니다.</p>
<p>글을 읽으면서 이 비판(나쁜 의미가 아닌)에 일부 동의하면서도 제가 비판 대상의 일부임을 솔직히 인정하지 않을 수 없었습니다. 그래서 약간의 변명이 필요하다는 생각이 들었습니다. 사실 저는 이렇게 다른 사람의 주장을 논박하면서 토론하는 것을 좋아합니다. 이런 일을 단순히 즐기는 면도 있지만 이런 토론을 통해서 주제가 더욱 풍성하고 명확해진다고 생각하기 때문입니다.</p>
<p>먼저 코딩 시험에 대한 제 개인적인 의견은, 해당 코딩 문제를 풀어야만 통과하는 엄격한 시험이라면 전 낮은 수준의 문제를 내도록 해야 한다는 의견입니다. 높은 역량을 가진 기술자를 뽑기 위한 수단이라기보다는 기준 이하의 기술자를 걸러내기 위한 수단이란 뜻입니다.</p>
<p><span id="more-137"></span></p>
<p>범균님이 말한 알고리듬 수준의 코딩 시험이 어떤 것을 말하는지 불분명하지만 알고리듬 경진 대회에 나오는 어려운 문제를 꼭 풀어야 한다고 요청하거나 대학 시절에 공부하기는 했지만 일하면서 거의 접할 일이 없는 정렬이나 탐색 알고리듬을 풀어 보라는 식은 해당 직무가 그런 역량을 필요료하는 것이 아닌 이상 지나친 것일 수도 있습니다. 범균님께서 말씀하신 대로 일반 애플리케이션 개발자에게는 그런 알고리듬 능력보다는 모델링 능력과 데이터 가공 능력이 실제 업무에 더 필요하기 때문입니다.</p>
<p>하지만 어떤 코딩 시험은 꼭 풀어야만 통과한다는 기준보다는 특정 문제를 줬을 때 그 문제를 분석하고 해결해 나가는 과정을 관찰하면서 그 사람의 수준을 알아보려는 의도로 진행되는 경우도 많습니다. 질문이 모호할 때 다시 물어본다거나, 바로 세부 구현으로 넘어가지 않고 여러가지 개념적인 흐름을 탐색한다거나, 여러 가지 가설을 세우고 검증한다거나 하는 모습을 보면서 어떤 역량을 가진 사람인지 알아 보는 것이지요. 좋은 면접관이라면 적당히 도움도 주고 도전도 하면서 그 시간을 이끌 것입니다.</p>
<p>이런 차이는 대면 면접에서도 적용되는데 구현 기술이나 방법론이나 최신 기술 경향이나 과거 경험들에 대해서 여러 가지 질문들이 나올 수 있는데 이 모든 것에 하나라도 올바로 대답하지 못한다고 떨어뜨리는 회사는 아마 없을 것입니다. 완급을 조절하면서 어떤 수준의 사람인지 알아보려는 것일 뿐이죠.</p>
<p>예를 들어, (그리 중요하다고 생각하지 않지만) SOLID 원칙이나 몇몇 디자인 패턴에 대해서 질문할 경우가 있습니다. 요즘은 워낙 많은 사람이 SOLID에 대해서 알고 있어서 용어를 모르는 사람은 거의 없습니다. 대부분 다섯 가지 원칙이 무엇이고 어떤 뜻인지도 잘 얘기합니다. 하지만 교과서적인 정의를 줄줄이 읊는 사람과 한 번이라도 고민해 보고 자신의 말로 개념을 말하는 사람은 분명히 다릅니다. 제가 아는 몇 사람은 SOLID 중 몇가지 원칙 밖에 기억하지 못했지만 그 의미를 서투른 말로 떠듬떠듬 설명하는 과정에서 자신이 좋은 SW를 개발하는 데 고민하는 사람이라는 사실을 무의식중에 우리에게 알려 주었고 우리는 그분들에게 같이 일하자고 제안했었습니다. 물론 지금도 훌륭하게 기여하고 있습니다.</p>
<p>그럼 왜 이런 면접이 문제로 거론되는 걸까요?</p>
<p>몇몇 면접관들은 완장 효과 때문인지 권위적인 자세로 면접을 진행하면서 면접 대상자가 인격적으로 모욕을 느끼게 합니다. 마치 심문하듯 면접을 진행하면서 자신도 넘지 못할 수준을 요구합니다. 때로는 상대의 역량을 알아내려고 하기보다는 자신의 전문 분야에 편중된 질문을 하면서 공정하게 면접을 진행하지 않습니다. 면접이 아니라 면접관의 자기 자랑으로 흐르기도 합니다. 어떤 면접 대상자는 자신이 검증 대상이 된다는 사실 자체를 못 받아들이는 사람도 있는데, 권위적인 면접관과 이 자존감 낮은 면접자가 만나면 지옥이 펼쳐집니다. 불행한 일이지만 실제로 일어나는 상황이고 이런 안 좋은 경험이 면접이 지나치게 어렵다는 식으로 알려지는 경우가 있습니다.</p>
<p>개발자 면접은 일종의 협상입니다. 아무리 뛰어난 사람이라도 해당 시점에 필요한 적임자가 아닐 수도 있고 거꾸로 당장 일 할 수 없는 사람이라도 성장 가능성만 있으면 뽑을 수 있는 상황일 수도 있습니다. 면접 결과가 자신을 객관적으로 평가한 결과라고 생각하지 않는 게 좋습니다. 같은 사람과 다음번에 또 면접을 보게 되면 다른 결과가 나올 수도 있습니다. 당시 상황과 필요에 따라 평가의 기준은 달라지게 마련입니다. 면접 결과가 안 좋으면 그냥 상황이 안 맞았다고 생각하시는 것이 좋습니다.</p>
<p>면접은 객관적이지도 않지만 절대 평가도 아닌데, 어떤 때는 내가 부족하지만, 같이 면접을 봤던 사람들에 비해 상대적으로 낫다고 판단되어 채용이 될 수도 있고 어떤 때는 충분한 자격이 있지만 더 적합한 사람에 밀려 탈락할 수도 있습니다.</p>
<p>물론 이런 변명에도 불구하고, 면접이 지나치게 엄격하다는 소문은 도전하는 사람들의 의지를 꺾을 수 있어서 회사 입장에서는 면접에서 탈락하는 사람들이 면접 기준이 너무 높아서 탈락했다고 오해하지 않도록 사후 관리를 잘 할 필요가 있습니다. 실제로 그런 소문 때문에 구인에 어려움을 겪는 회사가 있기도 하고요.</p>
<p>몇몇 회사는 채용에서 탈락한 기록을 관리하면서 한번 떨어졌던 사람은 가능하면 면접 후보에서 제외하는 경우도 있는데 정말 바보 같은 짓입니다.</p>
<p>글이 생각보다 길어졌는데, 제가 하고 싶은 말은 하나뿐입니다. 도전했는데 떨어졌다면 자신을 다시 돌아보고 심기일전하는 계기로 삼는 것은 좋지만 절대로 포기하지 마시고 다시 도전하십시오. 절대적이지도 객관적이지도 않고 일관성도 없고 때로는 미친놈일 수도 있는 누군가의 평가에 너무 큰 의미를 부여할 필요는 없습니다.</p>
<p>그리고 사실 SW 개발자는 실력으로 공정하게 평가 받는 환경을 늘 추구합니다. 더 나아가 좋은 개발 실력이 사업의 성패에 큰 영향을 주는 사회를 간절히 원합니다. 그래서 기술을 무시한 의사 결정이나 기술자를 부품 취급하는 관행이 없어지고 기술이 세상을 더 나은 세상으로 만드는데 쓰일 수 있기를 바랍니다. 그런 관점에서 어떤 회사인가가 높은 수준의 개발자를 찾고 그들을 대우해준다는 소식이 들린다면 이는 좋은 소식이기도 합니다.</p>
]]></content:encoded>
							<wfw:commentRss>https://blog.fupfin.com/?feed=rss2&amp;p=137</wfw:commentRss>
		<slash:comments>8</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">137</post-id>	<feedburner:origLink>https://blog.fupfin.com/?p=137</feedburner:origLink></item>
		<item>
		<title>기술 조직이 사업에 걸림돌이 될 때, 정렬 함정(Alignment Trap)</title>
		<link>http://feedproxy.google.com/~r/fupfin/blog/~3/OonsLfg5X1o/</link>
				<comments>https://blog.fupfin.com/?p=127#respond</comments>
				<pubDate>Tue, 12 Jan 2016 15:45:52 +0000</pubDate>
		<dc:creator><![CDATA[fupfin]]></dc:creator>
				<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://blog.javawocky.org/?p=127</guid>
				<description><![CDATA[회사는 재화나 서비스를 고객에게 제공하고 이윤을 내야 할 사명이 있는 조직입니다. 이윤을 내지 못하는 회사는 본연의 사명을 잘 감수하지 못하는 나쁜 회사입니다. 따라서 회사의 모든 구성원은 회사의 이윤을 극대화하고 지속가능하게 하는데 기여해야 하고 모든 에너지를 그곳에 집중시켜야 하는 것은 이론의 여지가 없는 명제입니다. 이는 IT​ 조직도 예외가 아니어서 대부분의 회사는 IT 조직이 사업에 밀착해서 최적화되어 [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>회사는 재화나 서비스를 고객에게 제공하고 이윤을 내야 할 사명이 있는 조직입니다. 이윤을 내지 못하는 회사는 본연의 사명을 잘 감수하지 못하는 나쁜 회사입니다. 따라서 회사의 모든 구성원은 회사의 이윤을 극대화하고 지속가능하게 하는데 기여해야 하고 모든 에너지를 그곳에 집중시켜야 하는 것은 이론의 여지가 없는 명제입니다.</p>
<p>이는 IT​ 조직도 예외가 아니어서 대부분의 회사는 IT 조직이 사업에 밀착해서 최적화되어 일하도록 강하게 요청합니다. 사업의  목표를 이해함은 물론이고 사업의 요청에 충실해야 하며 비용 효율화를 달성해야 하고 사업과 방향성이 맞지 않는 일은 금기입니다. 심지어 중장기 R&amp;D도 배부른 짓이고 비현실적인 일이라는 비난을 받기 일쑤입니다.</p>
<p>회사에서는 가볍고 빠르게 일을 처리해서 사업에 날개를 달아 주면서도 비용은 적게 먹고 불필요한 일은 하지 않는 IT 조직을 기대합니다. 하지만 대부분의 IT 조직은 무슨 일을 하는지 모르겠지만 생각보다 비용을 많이 먹어서 부담을 가중시키고, 느리고, 늘 문제를 일으키고, 알지 못할 변명만 늘어 놓는, 필요악 같은 존재입니다. IT 투자는 늘 밑 빠진 독에 불 붓기 같고, 실력이 없는 것인지 일 안하고 놀기만 하는 것인지, 의심의 골만 깊어 갑니다.</p>
<p>MIT 슬론 경영 리뷰지 2007 가을호에는 “<a href="http://sloanreview.mit.edu/article/avoiding-the-alignment-trap-in-it/">IT의 사업 정렬 함정을 피하는 법(Avoiding the Alignment Trap in IT)</a>”라는 제목의 논문이 실렸었습니다. 이 논문에서 “정렬 함정(Alignment Trap)”이라는 재미있는 개념을 소개합니다.</p>
<p><span id="more-127"></span></p>
<p>논문에 따르면, IT로 문제를 격는 회사들이 잘못된 지침에 따라 문제를 진단 합니다. IT를 활용해서 높은 사업 성과를 내려는 회사들은 IT가 사업에 정렬해서 일하도록 하는데 초점을 맞추었는데 저자들이 관찰한 많은 회사에서는 IT와 사업의 모든 요소가 긴밀하게 연계되어야 한다고 믿었습니다. 만약 이에 벗어날 경우 IT 조직은 부적절하거나 실패했다는 판정을 받게 됩니다.</p>
<p>일반적으로 이는 맞는 말이지만 저자들은 이상한 패턴을 발견했는데요. 여러 사례를 관찰한 결과, 사업에 정렬되었음에도 불구하고 IT와 관련된 사업적 성과가 지지부진하기도 하고 오히려 하락 하는 일도 있었다는 것입니다. IT부서가 사업에 정렬하더라도 사업 성과가 쉽게 좋아지지 않을 뿐 아니라 어떤 경우에는 나빠질 수 있다는 거죠.</p>
<p>저자들은 가장 먼저 IT 조직이 사업에 정렬하고자 자원을 어떻게 사용하는지 살펴 보았는데, IT 조직들은 개별 사업의 독특한 필요에 최적화된 최고의 솔루션을 개발했지만, 표준화나 오래된 시스템를 개선해야 할 필요는 무시했습니다. 기존의 복잡한 시스템에 새로운 복잡한 로직을 얹었기 때문에 시스템을 강화하거나 인프라를 개선하는 작업은 더 어려워진 것이죠. 이로 인해 비용은 증가하고 작업 지연이 심해지고 시스템이 파편화되는 바람에 관리자는 관련 사업 부서와 조율하기 힘들어졌습니다.</p>
<p>실랙티브 보험 그룹의 부사장이면서 CIO인 리차드 F 코넬가 “효율이 나쁜  IT 조직은 올바른 사업 목표에 정렬시켰더라도 목표를 달성할 수 없다”고 했다는데 이것이 바로 &#8220;정렬 함정&#8221;입니다.</p>
<p>저자들은 정렬 함정을 시험하기 위해서 452개 업체의 504 명 사업과 기술 담당 임원들에게 설문을 했습니다. 그리고 설문 결과를 가지고 30명의 CIO와 다른 부장급 리더들에게 깊이 있는 인터뷰를 수행했습니다.</p>
<p>설문에 따르면 단지 18% 만이 회사의 IT 지출이 사업의 우선순위에 정렬되었다고 믿는다며 응답했고, 15%만이 IT 효율이 높은 수준이라고 답했습니다. 그리고 거의 75%의 응답자가 그들의 IT 조직이 사업에 긴밀하게 정렬되거나 효율적이라고 생각하지 않는다는 것을 알 수 있었답니다.</p>
<p>다음은 그 설문의 결과를 정리한 도식입니다.</p>
<p><a href="http://blog.javawocky.org/wp-content/uploads/2016/01/AlignmentTrap.png"><img class="alignnone size-full wp-image-128" src="http://blog.javawocky.org/wp-content/uploads/2016/01/AlignmentTrap.png" alt="AlignmentTrap" width="715" height="590" /></a></p>
<div> 저자들은 IT 조직과 사업의 정렬 정도를 나타내는 세로 축과 IT 조직의 효율성을 나타내는 가로 축에 따라 사분면을 만들고 설문에 응답한 회사를 배치했습니다. 그리고 각 사분면에 이름을 부여 했습니다.</div>
<p>IT 조직이 사업에 긴밀하게 정렬하면서도 효율도 높은 회사는 “IT 기반의 성장”, 효율은 높지만 사업에 정렬하지 못한 회사는 “능률적인 IT”, 효율도 낮고 사업에도 별 도움을 못 주는 회사는 “유지보수 영역”이라고 이름을 붙였습니다. 그리고 효율이 떨어지면서도 사업에 긴밀하게 정렬된 회사를 “정렬 함정”으로 분류했습니다.</p>
<p>정렬 함정에 빠진 회사는 전체의 11%에 해당 했는데, 이 회사는 평균보다 13% 더 많이 IT에 돈을 쓰지만 회사는 3년 평균 매출이 15% 하락했습니다.</p>
<p>74%의 회사는 “유지보수 영역”에 해당하고, IT 지출이 평균 수준임에도 불구하고 매출은 살짝 하락한 평균 -2% 수준이었습니다.</p>
<p>나머지 두 영역은 결과가 무척 좋아서, 8%에 해당하는 “능률적 IT”에 해당하는 회사들은 효율적인 IT 프로젝트 운영에 초점을 맞추기 때문에 예산 안에서 프로젝트가 수행되고 평균보다 15% 적은 비용을 IT에 쓰지만 매출은 오히려 평균보다 11% 높은  성장을 했습니다.</p>
<p>효율도 뛰어나고 사업과도 긴밀하게 정렬해서 일하는 7%의 회사들은 지난 3년간 평균 매출이 35% 증가했고 비용은 평균보다 6%가 적었습니다.</p>
<p>이 설문 연구를 통해서 역량이 충분하지 않은 IT 조직을 가진 회사가 성급하게 사업에 밀착해서 프로젝트를 진행하도록 했을 때 IT가 오히려 회사의 실적에 악영향을 끼칠 수 있으며 사업과 분리되었을 때보다도 안 좋은 결과를 낸다는 사실을 알 수 있습니다. 즉, 어떤 회사가 IT 역량을 기반으로 경쟁 우위를 점하고 싶다고 하면, IT 부서가 사업에 밀착해서 일하도록 하기 보다는 먼저 역량을 강화하게 하고 나서 사업에 밀착해서 기여하도록 해야 한다는 교훈을 얻을 수 있습니다.</p>
<p>논문은 IT 조직이 비록 사업을 위해 밀착해서 일하지 않더라도 역량이 뛰어나다면 15%의 비용을 절감하고 회사 매출도 11%가 증가하는 것으로 나타났으므로 섣불리 사업에 최적화해서 일하게 하기 보다는 먼저 역량을 높이는데 투자하는 것을 주저할 필요가 없다고 지적합니다.</p>
<p>논문에서는 IT 조직을 효율화 할 세가지 방안을 제시합니다.</p>
<ul>
<li>단순성 강조<br />
회사는 시스템을 복잡하지 않게 만들어야 합니다. 사업의 개별 요구사항을 빠르게 응급 처방으로 대응하다보면 시스템은 복잡해질 수 밖에 없는데, 사내 표준을 개발하고 정착시켜야 합니다. 이는 기존 시스템을 교체하거나 표준화된 인프라로 대체해야 하는 큰 작업이지만 초기 비용은 나중에 회수할 수 있습니다.</li>
<li>&#8220;올바른 소싱(rightsourcing)&#8221; 능력<br />
IT 조직은 몇몇 전문 분야에 대해서 외부에서 역량을 조달하는 편이므로 올마른 소싱 능력을 키우지 않으면 안 됩니다. 가장 먼저는 어떤 일을 외부에서 소싱할지 올바른 결정을 할 수 있어야 합니다. 전략의 핵심이거나 회사 경쟁 차별화 요소인 경우는 내부에서 하면서 외부의 값싼 솔루션이나 역량을 적절히 활용할 수 있어야 합니다.<br />
무엇보다 효과적인 아웃소싱을 위해서는 해당 업무를 먼저 이해해야 하므로 내부에서 업무를 직접 수행하여 업무의 성격을 파악하고 나서 아웃소싱을 해야 합니다.</li>
<li>완결적 책임 구축<br />
IT 조직이 주어진 예산 안에서 기대하는 결과를 내도록 책임질 수 없다면 효율성은 실현될 수 없습니다. 단순히 책임이 있다고 말하는 수준에 머물러서는 안되고 조직 변화에 반영해야 합니다. 사업 단위로 IT 조직을 구성하지 말아야 하며 사업의 지나치에 휘둘리지 않도록 제약을 가해야 합니다.</li>
</ul>
<p>우리나라 기업들은 대부분 영업 조직의 발언권이 강한 편입니다. 더구나 IT에 대한 이해가 매우 낮아서 사업을 보조하는 수단으로서만 활용될 뿐 회사의 성장을 견인하지는 못합니다. 이런 상황에서 저가의 초급 인력로 구성된 팀이나 외주 개발이라는 효율성 낮은 방식으로 사업에 밀착해서 일하고 사업의 요청을 거의 일방적으로 수용하도록 강요받고 있습니다. 그렇지 못한 기술 조직은 공격의 대상이 됩니다. 더 심각한 것은 많은 개발 조직의 구성원들이 이런 환경에 익숙해 있고 개발 조직을 관리하는 사람들이 이른 구조를 유지하는게 자기의 역할이라고 생각한다는 점입니다.</p>
<p>IT 기술이 회사의 사업에 중요한 기반이라고 생각하는데 성과가 안 좋은 회사에서는 이 &#8220;정렬 함정&#8221;에 빠지지는 않았는지 검토해 보아야 할 것입니다.</p>
]]></content:encoded>
							<wfw:commentRss>https://blog.fupfin.com/?feed=rss2&amp;p=127</wfw:commentRss>
		<slash:comments>0</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">127</post-id>	<feedburner:origLink>https://blog.fupfin.com/?p=127</feedburner:origLink></item>
		<item>
		<title>소프트웨어 개발 전문가, 골드러시, 함수형 언어</title>
		<link>http://feedproxy.google.com/~r/fupfin/blog/~3/n9o52OYlt6A/</link>
				<comments>https://blog.fupfin.com/?p=119#comments</comments>
				<pubDate>Fri, 08 May 2015 01:31:40 +0000</pubDate>
		<dc:creator><![CDATA[fupfin]]></dc:creator>
				<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://blog.javawocky.org/?p=119</guid>
				<description><![CDATA[스티브 맥코넬은 우리 컴퓨터 업계에는 주기적으로 골드 러시가 일어난다고 했다. 기술 혁신이 계속되고 새로운 기술이 부침을 거듭고 이에 따라 새로운 기회가 열리며 이 기회를 잡으려고 사람들이 우루르 달려드는 일이 반복된다는 것이다. 그러다 보니 새로운 금광이 발견되었다는 소식을 빨리 접하고 남들보다 먼저 깃발을 꼽는 것이 소프트웨어 개발자를 포함한 컴퓨터 관련 종사자의 중요한 생존 전략이 되어 버렸다. 심지어 [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>스티브 맥코넬은 우리 컴퓨터 업계에는 주기적으로 골드 러시가 일어난다고 했다. 기술 혁신이 계속되고 새로운 기술이 부침을 거듭고 이에 따라 새로운 기회가 열리며 이 기회를 잡으려고 사람들이 우루르 달려드는 일이 반복된다는 것이다.</p>
<p>그러다 보니 새로운 금광이 발견되었다는 소식을 빨리 접하고 남들보다 먼저 깃발을 꼽는 것이 소프트웨어 개발자를 포함한 컴퓨터 관련 종사자의 중요한 생존 전략이 되어 버렸다. 심지어 어떤 (전직) 개발자는 직접 금은 캐지는 않고 금을 찾으려고 혈안이 된 개발자에게 새 금광 소식을 전하거나 금광 채굴단을 모집하거나 청바지를 파는 것을 생업으로 삼기도 한다.</p>
<p><a href="http://www.amazon.com/After-Gold-Rush-Profession-Engineering/dp/0735608776"><img class=" size-full wp-image-120 alignright" src="http://blog.javawocky.org/wp-content/uploads/2015/05/after_the_gold_rush.jpg" alt="After the gold rush" width="260" height="327" /></a>골드 러시가 일어나고 새로운 기회를 찾는 거야 늘 즐거운 일이지만 이런 특성 때문에 무시되는 한가지는 소프트웨어 전문가 의식이다. 오히려 어떤 기술을 남들보다 먼저 사용하거나 더 잘 쓰는 사람을 &#8216;전문가&#8217;라고 부르는 실정이다. 스티브 맥코넬은 이에 대해 &#8220;골드 러시 이후, 진정한 소프트웨어 공학 전문직 창조(After the Gold Rush: Creating a True Pro<span class="text_exposed_show">fession of Software Engineering)&#8221;라는 책을 썼는데 아쉽게 번역이 된 것 같지는 않다.</span></p>
<p>내 머리 속에는 소프트웨어 개발의 전문성이란 주제로 두 사람이 떠오르는데, 이 스티브 맥코넬이 그 한 사람이고 요 몇년 사이에 엉클 밥(로버트 C 마틴)이 추가되었다. 스티브 맥코넬은 소프트웨어 전문가를 소프트웨어 공학자로 보았다. 아직 기예 수준에 머물러 있는 소프트웨어 개발을 공학적으로 접근해서 여러가지 소프트웨어 공학 지식을 활용하는 사람이다.</p>
<div class="text_exposed_show">
<p><a href="http://blog.javawocky.org/wp-content/uploads/2015/05/the_clean_coder.jpg"><img class=" size-full wp-image-121 alignleft" src="http://blog.javawocky.org/wp-content/uploads/2015/05/the_clean_coder.jpg" alt="The clean coder" width="1226" height="1594" /></a>반면에 엉클 밥은 소프트웨어 개발자의 윤리와 책임과 자부심에서 전문성을 찾는다. 이는 오랫동안 소프트웨어 장인 정신으로 부르던 것과 연장선에 있다.</p>
<p>재미있는 것은 이들이 전문성을 강조하던 시점인데, 스티브 맥코넬은 무어의 법칙으로 인한 소프트웨어 위기가 극에 달했던 2000 년 앞뒤로 그런 주장을 했고 엉클 밥은 무어의 법칙이 공식적으로 죽었다는 선고가 떨어진 2000년 후반에 그런 주장을 했다. 즉 공짜 점심은 끝났으니 이제 소프트웨어 개발자는 무임 승차를 끝내고 이제야 말로 진짜로 전문가로서 전문성을 찾아 나서야 한다는 말이다.</p>
<p>엉클 밥이 이 때부터 함수형 언어(특히 리스프 계열, 그중에서도 클로저)에 전착하며 떠들고 다닌 것도 같은 이유인 것으로 보인다. 그에게 새 시대에는 과거와 전혀 다른 방식으로 소프트웨어를 개발해야 하며 함수형 언어가 그 해결책이라고 본 것이다.</p>
<p>난 무어의 법칙 이후 세상에서 함수형 언어(그 중에서도 리스프 계열)만이 답이라고 생각하지는 않는다. 하드웨어 혁명의 시대가 끝나고 소프트웨어 혁명이 시작된 시대에 대응하는 방법은 다양하리라 생각한다. 함수형의 특징 중 몇가지(예를 들어 불변성)를 부분적으로 혼합하는 방식도 가능하다.</p>
<p>좌우간, 요즘 함수형 언어를 떠들고 다니는 사람들 주변에 많고 관심도 많다. 다만 이들이 새 금광 홍보꾼(보도방?)인지 전문가 의식을 찾는 사람인지 한번 확인해 볼 필요가 있다.</p>
</div>
]]></content:encoded>
							<wfw:commentRss>https://blog.fupfin.com/?feed=rss2&amp;p=119</wfw:commentRss>
		<slash:comments>2</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">119</post-id>	<feedburner:origLink>https://blog.fupfin.com/?p=119</feedburner:origLink></item>
		<item>
		<title>자바의 겉표지</title>
		<link>http://feedproxy.google.com/~r/fupfin/blog/~3/ud01odCuDMM/</link>
				<comments>https://blog.fupfin.com/?p=102#respond</comments>
				<pubDate>Tue, 24 Feb 2015 09:40:12 +0000</pubDate>
		<dc:creator><![CDATA[fupfin]]></dc:creator>
				<category><![CDATA[Java]]></category>
		<category><![CDATA[Programming]]></category>

		<guid isPermaLink="false">http://blog.fupfin.com/?p=102</guid>
				<description><![CDATA[해커와 화가의 폴 그레이엄이 2001년 4월에 쓴 &#8220;Java&#8217;s Cover&#8220;라는 글을 번역했습니다. 오해가 있을까 싶어 번역 의도를 말한다면, 저자의 자바에 대한 생각과 상관 없이, 외관으로 특정 기술을 평가하는 능력의 중요성에 대해서 동의할 뿐 아니라 이 글을 썼을 당시보다 새로운 기술이 쏟아져 나오는 속도가 훨씬 빨라졌기 때문에 이런 능력의 중요성이 더욱 커졌기 때문입니다. 15년 정도가 지난 지금 [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><em>해커와 화가의 폴 그레이엄이 2001년 4월에 쓴 &#8220;<a href="http://paulgraham.com/javacover.html">Java&#8217;s Cover</a>&#8220;라는 글을 번역했습니다. 오해가 있을까 싶어 번역 의도를 말한다면, 저자의 자바에 대한 생각과 상관 없이, 외관으로 특정 기술을 평가하는 능력의 중요성에 대해서 동의할 뿐 아니라 이 글을 썼을 당시보다 새로운 기술이 쏟아져 나오는 속도가 훨씬 빨라졌기 때문에 이런 능력의 중요성이 더욱 커졌기 때문입니다. 15년 정도가 지난 지금 자바가 어떤 길을 걸어 왔는지 정리해 보는 것도 재미있을 것 같아서 그 글을 작성해 보기 전에 이글을 먼저 번역한 측면도 있습니다. 이미 누군가가 번역했을지도 모르겠다는 생각도 들었으나 폴 그레이엄의 글을 탐독하는 사람이 자바 관련된 글을 번역했을리 없다고 단정하고 찾아보지 않았습니다.</em></p>
<hr />
<p>이 글은 내가 여러 다른 프로그래머와 자바에서 수상한 냄새가 나는 이유를 나누던 대화를 정리한 글이다. 이 글은 자바에 대한 비평이 아니다. 해커의 탐지 능력(hacker’s radar)에 대한 사례 연구이다.</p>
<p>오랜 시간 동안, 해커는 좋은 (또는 나쁜) 기술을 분별하는 코를 개발한다. 내가 자바를 수상적어 하도록 하는 이유를 찾아서 적어 보면 재미있겠다는 생각이 들었다.</p>
<p>이 글을 읽은 어떤 사람은 전에 작성된 적이 없는 어떤 것을 적어 보는 게 재미 있다고 생각한다. 다른 이들은 내가 이해 못하는 것에 대해서 쓰려는 듯 보여 곤경에 처할 거라고 말한다. 그래서,  만약의 안 좋은 상황을 대비해, 내가 여기에 (내가 한번도 써 본 적이 없는) 자바가 아닌 해커의 탐지 능력에 대해 쓰려는 걸 분명히 하고 싶다.</p>
<hr />
<p>&#8220;겉 표지만 보고는 책에 대해 말할 수 없다&#8221;는 격언은 타임스지가 구매자 고유의 취향에 맞추기 위해 보드지로 된 무지 표지의 책을 팔았던 것에서 유래했다. 당시에는 표지를 가지고 책을 논할 수 없었다. 하지만 출판은 그날 이후로 발전했고 오늘날 출판업자들은 표지로 책을 논할 수 있을 정도로 잘 만들려고 힘쓴다.</p>
<p>서점에서 시간을 많이 보내다 보니 이제는 출판업자가 책에 대해서 말하려는 의미를 전부, 어쩌면 조금 더, 이해하는 방법을 익힌 것처럼 느껴진다. 서점에서 죽 때리지 않을 때에는 대부분 컴퓨터 앞에 앉아 있는데, 어느 정도 기술의 표지를 보고도 판단하는 법을 배운 것 같이 느껴진다. 그저 운일 뿐이겠지만, 진짜 저질로 판명난 몇몇 기술에서 날 지켜 주었다.</p>
<p>지금까지는, 자바가 그런 저질로 보인다. 나는 자바로 프로그램을 작성해 보지 않았고 참고 도서도 대충 훑어본 이상은 없지만, 언어로서 그다지 성공할 것 같아 보이지 않았다. 내 실수로 판명이 날지도 모른다. 기술을 전망하는 일은 위험한 사업이다. 아무튼 얼마나 가치 있는지는 모르겠으나, 일종의 타임 캡슐이랄까, 자바가 보기 안 좋았던 이유는 이렇다.</p>
<p><strong>1. 매우 왕성히 과대 선전했다.</strong> 진정한 표준은 굳이 홍보할 필요가 없다. 아무도 C나 유닉스(Unix)나 HTML을 홍보하지 않았다. 진정한 표준은 시간이 흐름에 따라 대부분의 사람이 알게 된다고 인정되는 편이다. 매력의 강도로 봤을 때 해커의 탐지 화면에는 펄이 자바 만큼, 오히려 크게 보인다.</p>
<p><strong>2. 목표 수준이 낮다.</strong> 첫번째 자바 백서에 의하면, 고슬링은 자바를 C를 사용하던 프로그래머에게 너무 어렵지 않도록 설계했다고 노골적으로 말한다. 자바는 또 다른 C++로 설계된 것이다. C++는 C에 다른 고급 언어에서 몇가지를 아이디어를 취한 언어이다. 시트콤이나 정크 푸드나 패키지 여행을 만드는 사람처럼, 자바를 설계한 사람은 의도적으로 자기들 보다 똑똑하지 않은 사람들을 위한 제품을 설계한 것이다. 역사상, 타인이 사용하도록 만든 언어는 안 좋았다. 코볼(Cobol), PL/1, 파스칼(Pascal), 에이다(Ada), C++ 가 그랬다. 좋은 언어는 창조자 자신을 위해 설계되었다. C, 펄(Perl), 스몰토크(Smalltalk), 리스프(Lisp)이다.</p>
<p><strong>3. 동기가 엉뚱하다.</strong> 한번은 누군가 사람들이 책을 쓰고 싶어서가 아니고 뭔가 할 말이 있어서 책을 쓴다면 세상이 더 나은 곳이 될 것이라고 말했다. 이와 같이, 우리가 항상 들은 자바를 만든 이유는 프로그래밍 언어에 대해서 말하고 싶은 무엇 때문이 아니다.  자바가 썬(Sun)이 마이크로소프트의 토대를 약화시키려는 계획의 일부인 것으로 들었다.</p>
<p><strong>4. 아무도 좋아하지 않는다.</strong> C, 펄(Perl), 파이썬(Python), 스몰토크(Smalltalk), 리스프(Lisp) 프로그래머는 자신이 사용하는 언어를 사랑한다. 난 한번도 자신이 사용하는 자바를 사랑한다는 말을 듣지 못했다.</p>
<p><strong>5. 사용하도록 강요 받는다.</strong> 내가 아는 자바를 쓰는 많은 사람은 그래야 할 것 같아서 자바를 사용한다. 자금을 지원 받으려면 그래야 할 것 같아서나 고객이 원한다고 생각해서나 관리자에게서 뭔가 말을 들었기 때문이다.  그들은 똑똑한 사람이다. 기술이 좋았다면 그들은 자발적으로 그 기술을 사용했을 것이다.</p>
<p><strong>6. 요리사가 지나치게 많다.</strong> 최고의 프로그래밍 언어는 지금까지 소그룹이 개발했다. 자바는 위원회가 운영하는 것 같다. 자바가 좋은 언어라고 밝혀진다면, 역사상 처음으로 위원회가 설계한 좋은 언어가 될것이다.</p>
<p><strong>7. 관료적이다.</strong> 자바에 관한 내 짧은 지식에 따르면,  뭔가를 할 때의 따라야 할 규범이 매우 많다. 진짜 좋은 언어는 그렇지 않다. 좋은 언어는 하려고 하는 일을 할 수 있도록 하면서도 번잡한 일은 줄여준다.</p>
<p><strong>8. 진보적인 것처럼 위장되었다.</strong> 썬은 자바가 펄이나 파이썬처럼 일반 대중의 오픈소스 언어 성과인 척 한다. 이것은 거대 기업에 의해 통제되도록 일어난 일일 뿐이다. 따라서 이 언어는 큰 기업에서 만들어진 모든 것이 그렇듯 밋밋하고 투박할 것이다.</p>
<p><strong>9. 대규모 조직용으로 설계되었다.</strong> 큰  조직은 해커와 목적이 다르다.  큰 조직에서는 그저그런 프로그래머로 구성된 큰 팀이 사용하기에 적합한(적으도 그렇기 보이는) 언어를 원한다. 이런 언어는 이삿짐 센터 트럭에 있는 속도 제한기 같이 바보들이 큰 피해를 입힐 행위를 하지 못하게 하는 특징이 있다. 해커는 자신들을 펌하하는 언어를 좋아하지 않는다. 해커는 정말 힘을 원한다. 역사적으로, 큰 조직을 위해 설계된 (PL/I, 에이다 같은) 언어는 망한 반면, (C나 펄 같은) 해커 언어는 흥했다. 현재의 십대 해커는 미래의 CTO이기 때문이다.</p>
<p><strong>10. 엉뚱한 사람이 좋아한다.</strong> 내가 인정하는 프로그래머 대부분은 대체로 자바에 끌리지 않는다.  자바를 좋아하는 사람은 누구일까? 정장을 입은 사람이다. 그들이 아는 언어는 다른 사람에게 추천 받은 것은 하나도 없고 언론에서 계속 들은 자바 뿐이다. 큰 회사에 소속된 프로그래머도 있다. 그들은 C++보다 더 좋은 뭔가를 찾느라 혈안이 되어 있다.  단순한 학부생도 그렇다. 그들은 직업을 구할 수 있는 것(면접 시험에 나올 것인가?)이라면 뭐든 좋아할 준비가 되어 있다.  이 사람들은 바람이 불 때마다 생각을 바꾼다.</p>
<p><strong>11. 아버지가 위기에 몰렸다.</strong> 썬(Sun)의 사업 모델은 두 전선에서 토대가 허물어지고 있다. 데스크탑 기기에서 사용되는 것과 동일한 유형의 싸구러 인텔 프로세서는 이제 서버에서 쓰기에도 충분히 빠르다. FreeBSD는 적어도 솔라리스(Solaris) 만큼 서버용 OS로 적합해 보인다. 썬은 우리에게 고성능 애플리케이션에 썬의 서버가 필요한 것처럼 광고한다. 이것이 사실이라면, 야후는 썬을 사려고 앞장설 것이다. 하지만 내가 야후에 있었을 때, 서버는 모두 인텔 기기에 FreeBSD가 돌아갔다. 이는 썬의 미래에 좋지 않은 전조이다. 썬이 위기에 처한다면, 자바도 함께 위험해 질 수 있다.</p>
<p><strong>12. 미 국방부가 좋아한다.</strong> 국방부는 개발자들에게 자바를 사용하도록 독려한다. 이 사실이 내게는 그 무엇보다 X 같은 신호로 보인다. 국방부는 국가를 방어하는 일은 (돈을 많이 쓰지만) 잘한다. 하지만, 그들은 계획과 절차와 규범을 사랑한다. 그들의 문화는 해커 문화와 반대된다. 소프트웨어에 관한 문제에서 그들은 틀린 답에 손을 드는 편이다. 지난 번에 국방부가 진짜 좋아했던 프로그래밍 언어는 에이다였다.</p>
<p>이 글이 자바를 비평한 글이 아님을 명심하자. 하지만 자바의 표지에 대한 비판이긴 하다. 자바를 좋아하거나 싫어할 만큼 자바를 잘 알지 못하다. 그저 내가 자바를 배우려는데 적극적이지 않은 이유를 설명한 글이다.</p>
<p>프로그램을 작성해 보지도 않고 한 언어를 무시하는 건 거만해 보일 수 있으나, 모든 프로그래머가 해야만 할 일이다. 세상에는 배워야 할 기술이 너무 많다. 밖에서 보이는 신호 만으로 평가하는 방법을 배워야만 시간을 아낄 수 있다. 나는 마찬가지로 여러가지 중에 코볼, 에이다, 비쥬얼 베이직, IBM AS400, VRML, ISO 900, SET 프로토콜, VMS, 노벨 네트웨어, 코바(CORBA)를 호기롭게 무시했었다. 정말 구린내가 났다.</p>
<p>자바의 경우엔 내가 틀릴 수도 있다. 자바는 한 대기업이 경쟁사를 해치려고 촉진했고, 주류 청중을 위해 위원회가 설계했으며,하늘에 닿을 정도로 과장 광고를 하고, 국방부의 사랑을 받았음에도 내가 프로그래밍하고 싶어하는 흠 없고 아름답고, 강력한 언어 일 수도 있다. 그럴 수도 있겠지만 매우 비관적이다.</p>
]]></content:encoded>
							<wfw:commentRss>https://blog.fupfin.com/?feed=rss2&amp;p=102</wfw:commentRss>
		<slash:comments>0</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">102</post-id>	<feedburner:origLink>https://blog.fupfin.com/?p=102</feedburner:origLink></item>
		<item>
		<title>언어가 해결하려던 것들</title>
		<link>http://feedproxy.google.com/~r/fupfin/blog/~3/O7MP2GG1a94/</link>
				<comments>https://blog.fupfin.com/?p=99#respond</comments>
				<pubDate>Mon, 23 Feb 2015 12:51:51 +0000</pubDate>
		<dc:creator><![CDATA[fupfin]]></dc:creator>
				<category><![CDATA[Java]]></category>
		<category><![CDATA[Programming]]></category>

		<guid isPermaLink="false">http://blog.fupfin.com/?p=99</guid>
				<description><![CDATA[폴 그레이엄이 오래 전에 작성했던  What Languages Fix란 글을 번역했습니다. 읽어 보시면 알겠지만 그냥 재미로 읽고 넘길 내용입니다. &#160; 케빈 켈러허(Kevin Kelleher)가 프로그래밍 언어를 비교하는 재미있는 방법을 제안했다. 각 언어가 해결하려는 문제를 적어 보자는 것이다. 이 방식으로 많은 언어가 정말 잘 설명되는 것을 보고 놀랐다. 알골(Algol): 어셈블리 언어는 너무 하부 수준이야. Algol: Assembly language is [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><em>폴 그레이엄이 오래 전에 작성했던  <a href="http://paulgraham.com/fix.html">What Languages Fix</a>란 글을 번역했습니다. 읽어 보시면 알겠지만 그냥 재미로 읽고 넘길 내용입니다.<br />
</em></p>
<hr />
<p>&nbsp;</p>
<p>케빈 켈러허(Kevin Kelleher)가 프로그래밍 언어를 비교하는 재미있는 방법을 제안했다. 각 언어가 해결하려는 문제를 적어 보자는 것이다. 이 방식으로 많은 언어가 정말 잘 설명되는 것을 보고 놀랐다.</p>
<div align="justif">알골(Algol): 어셈블리 언어는 너무 하부 수준이야.<br />
Algol: Assembly language is too low-level.</div>
<p align="left">파스칼(Pascal): 알골은 데이터 타입이 부족해.<br />
Pascal: Algol doesn&#8217;t have enough data types.</p>
<p align="left">모듈라(Modula): 파스칼은 시스템 프로그래밍에 너무 취약해.<br />
Modula: Pascal is too wimpy for systems programming.</p>
<p align="left">시뮬라(Simula): 알골은 시뮬레이션에 적합하지 않아.<br />
Simula: Algol isn&#8217;t good enough at simulations.</p>
<p align="left">스몰톡(Smalltalk): 시뮬라의 모든 것이 객체가 아니야.<br />
Smalltalk: Not everything in Simula is an object.</p>
<p align="left"><span id="more-99"></span></p>
<p align="left">포트란(Fortran): 어셈블리 언어는 너무 하부 수준이야.<br />
Fortran: Assembly language is too low-level.</p>
<p align="left">코볼(Cobol): 포트란은 무서워.<br />
Cobol: Fortran is scary.</p>
<p align="left">피엘원(PL/I): 포트란은 데이터 형이 부족해.<br />
PL/I: Fortran doesn&#8217;t have enough data types.</p>
<p align="left">에이다(Ada): 모든 언어는 뭔가가 빠져있어.<br />
Ada: Every existing language is missing something.</p>
<p align="left">베이직(Basic): 포트란은 무서워.<br />
Basic: Fortran is scary.</p>
<p align="left">에이피엘(APL): 포트란은 배열을 다루는데 적당치 않아.<br />
APL: Fortran isn&#8217;t good enough at manipulating arrays.</p>
<p align="left">제이(J): APL은 고유의 문자집합이 필요해.<br />
J: APL requires its own character set.</p>
<p align="left">씨(C): 어셈블리 언어는 너무 하부 수준이야.<br />
C: Assembly language is too low-level.</p>
<p align="left">씨뿔뿔(C++): C는 너무 하부 수준이야.<br />
C++: C is too low-level.</p>
<p align="left">자바(Java): C++는 너무 잡다해. 그리고, 마이크로소프트가 우리를 박살내려고 해.<br />
Java: C++ is a kludge. And Microsoft is going to crush us.</p>
<p align="left">씨샵(C#): 자바는 썬이 다 해먹으려고 해.<br />
C#: Java is controlled by Sun.</p>
<p align="left">리스프(Lisp): 투어링 머신은 계산을 서술하기에 난해해.<br />
Lisp: Turing Machines are an awkward way to describe computation.</p>
<p align="left">스킴(Scheme): 맥리스프(MacLisp)는 너무 잡다해.<br />
Scheme: MacLisp is a kludge.</p>
<p align="left">티(T): 스킴은 라이브러리가 없어.<br />
T: Scheme has no libraries.</p>
<p align="left">커먼 리스프(Common Lisp): 리스프는 방언이 너무 많아.<br />
Common Lisp: There are too many dialects of Lisp.</p>
<p align="left">딜런(Dylan): 스킴은 라이브러리가 없고 리스프 문법은 무서워.<br />
Dylan: Scheme has no libraries, and Lisp syntax is scary.</p>
<p align="left">펄(Perl): 쉘 스크립트/awk/seed는 프로그래밍 언어라고 하기엔 부족해.<br />
Perl: Shell scripts/awk/sed are not enough like programming languages.</p>
<p align="left">파이선(Python): 펄은 너무 잡다해.<br />
Python: Perl is a kludge.</p>
<p align="left">루비(Ruby): 펄은 너무 잡다하고 리스프 문법은 무서워.<br />
Ruby: Perl is a kludge, and Lisp syntax is scary.</p>
<p align="left">프롤로그(Prolog): 프로그래밍은 논리에 비해서 부족해.<br />
Prolog: Programming is not enough like logic.</p>
]]></content:encoded>
							<wfw:commentRss>https://blog.fupfin.com/?feed=rss2&amp;p=99</wfw:commentRss>
		<slash:comments>0</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">99</post-id>	<feedburner:origLink>https://blog.fupfin.com/?p=99</feedburner:origLink></item>
		<item>
		<title>서비스에 인터페이스를 사용해야 하나?</title>
		<link>http://feedproxy.google.com/~r/fupfin/blog/~3/lEaqPBHmVho/</link>
				<comments>https://blog.fupfin.com/?p=81#comments</comments>
				<pubDate>Mon, 05 Jan 2015 12:17:29 +0000</pubDate>
		<dc:creator><![CDATA[fupfin]]></dc:creator>
				<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://blog.fupfin.com/?p=81</guid>
				<description><![CDATA[한국 스프링 사용자 모임(KSUG)의 페이스북 그룹에서 스프링으로 웹 애플리케이션을 개발하면서 서비스에 인터페이스를 사용해야 하느냐는 토론이 있었습니다. 원래 그 글의 댓글로 작성한 글인데 무슨 일인지 댓글이 등록되지 않아서 이렇게 블로그에 올립니다. 모든 프로그래밍 원칙과 장치는 &#8216;적절히 써야 한다&#8217;는 대전제 아래에서 논의돼야 한다는 점을 먼저 밝히고 제 생각을 말하고 싶습니다. 프로그래밍 원칙을 위반한다고 지구가 무너지거나 감옥에 갇히지는 [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>한국 스프링 사용자 모임(KSUG)의 페이스북 그룹에서 스프링으로 웹 애플리케이션을 개발하면서 <a href="https://www.facebook.com/groups/springkorea/permalink/622319567879676/">서비스에 인터페이스를 사용해야 하느냐는 토론</a>이 있었습니다.</p>
<p>원래 그 글의 댓글로 작성한 글인데 무슨 일인지 댓글이 등록되지 않아서 이렇게 블로그에 올립니다.</p>
<hr />
<p>모든 프로그래밍 원칙과 장치는 &#8216;적절히 써야 한다&#8217;는 대전제 아래에서 논의돼야 한다는 점을 먼저 밝히고 제 생각을 말하고 싶습니다. 프로그래밍 원칙을 위반한다고 지구가 무너지거나 감옥에 갇히지는 않죠. 누가 죽지도 않고요. 그렇다고 해도 어떤 원칙을 위반했을 때에는 원칙의 중요도 만큼 원칙을 무시한 결정이 적절했음을 설득하거나 그로 인해 생기는 문제를 해결할 책임을 위반하기로 결정한 사람(또는 조직)이 수용하고 감당하면 됩니다.</p>
<p>KSUG에서 논의된 내용을 요약하면</p>
<ul>
<li>인터페이스 없어도 AOP 잘 됨</li>
<li>인터페이스 하나에 서비스 하나 뿐임</li>
<li>인터페이스 때문에 가독성이 떨어짐</li>
<li>테스트를 하면 인터페이스 구현체를  하나 더 만들게 됨</li>
<li>테스트도 요즘 목 프레임워크 기술이 좋아서 인터페이스가 꼭 필요하지 않음</li>
<li>프로젝트 규모와 중요도에 따라 다를 듯</li>
<li>인터페이스를 나중에 추출하는 방법도 있음</li>
</ul>
<p>저도 인터페이스가 비용인 건 인정합니다. 모든 코드는 비용이죠. 다만, 그 비용을 들인 만큼 얻는 가치가 있다면 투자하면 되고 없다면 투자해서는 안 될 것입니다. 프로그래밍에서 간접화와 추상화와 관련된 코드를 비용으로 따진다면 간접비(overheads)에 해당할 것입니다. 따라서 과도한 간접화나 추상화는 피하도록 노력해야 합니다. 그렇지만 단순히 간접화나 추상화와 관련된 투자가 비용이라서 쓰면 안 된다는 식의 논리는 빈약입니다. 투자회수율(RoI)을 생각해야지 총비용만 무조건 줄이겠다는 생각은 현명하지 않습니다.</p>
<p>같은 맥락에서 <a href="http://java.ihoney.pe.kr/">@김지헌</a>님이 링크 거신 <a href="http://www.youtube.com/watch?v=tL3sB6qaIoM">동영상 강좌(?)</a>에서 문제 삼은 &#8220;모든 클래스에는 인터페이스를 만든다&#8221;는 과격하고 경직된 정책은 저도 반대입니다. 그러나 저 화자께서 한 쪽의 극단적인 상황을 예로 들면서 그 반발로 또 다른 극단으로 치우치시는 것 같아서 저 강좌의 주장을 그대로 인정하지 못하겠습니다. 저 강좌를 얼마 전에 보고 따로 글을 쓰고 싶었는데 시간이 될지는 모르겠습니다.</p>
<p><strong>OOP의 핵심, 메시징</strong></p>
<p>살짝 한 발 물러서서 객체 지향 프로그래밍(OOP)이 뭔지 생각해 보는 게 좋을 것 같습니다. 최초의 OOP 언어라고 불리우는 두 언어가 있(었)습니다. 하나는 67년도에 나온 시뮬라 67이고 또 하나는 80년도에 나온 스몰토크-80입니다. 우리나라의 많은 사람들이 (아마도 마이크로소프트 덕에) C++를 통해서 OOP를 접했는데, C++는 시뮬라 67에서 OOP의 특성을 물려 받은 언어입니다. 우리가 OOP를 생각하면 흔히 떠오르는 객체, 클래스, 상속 같은 언어적 장치는 모두 시뮬라 67에서 소개되었습니다. 시뮬라 67에서는 프로그램을 작은 여러 독립 프로그램(객체)으로 나누고 이 작은 독립 프로그램들이 병렬적으로 서로 협력하며 동작하도록 하는 프로그래밍 모델을 도입했습니다.</p>
<p><span id="more-81"></span></p>
<p>하지만 정착 &#8220;객체 지향 프로그래밍&#8221;이란 용어 자체는 스몰토크-80에서 처음 소개되었습니다. 스몰토크를 만든 사람 중 하나이고 OOP란 용어를 고안한 앨런 케이는 OOPSLA 97에서 <a href="http://www.youtube.com/watch?feature=player_detailpage&amp;v=oKg1hTOQXoY#t=633"><em>&#8220;내가 &#8216;객체 지향&#8217;이란 말을 만들 때에는 C++는 염두에 두지 않았다고 할 수 있다(Actually I made up the term &#8220;object-oriented&#8221;, and I can tell you I did not have C++ in mind)&#8221;</em></a>라고 말했고, <a href="http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en">OOP를 정의해 달라는 서신 요청에 대해서 장문의 답장</a>을 하면서<em>&#8220;나에게 OOP는 메시징과 상태 처리 과정의 지역적 보존, 보호, 은익과 모든 것의 극단적인 지연 바인딩 뿐입니다(OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things)&#8221;</em>라고 말했습니다.</p>
<p>앨런 케이는 스퀵(squeak) 커뮤니티에게 <a href="http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html">프로토타입 기반 OOP와 클래스 기반 OOP에 대한 토론이 오가는 사이에 자신이 생각하는 OOP를 설명</a>하기도 했는데, 그 글에서 자신이 객체라는 용어를 만들어 내서 사람들이 자꾸 별로 중요하지 않은 객체에 집중하게 만들었다면서 사과한다고 하고 OOP에서 가장 중요한 것은 클래스나 객체 같은 것이 아니라 메시징이라고 다시 강조했습니다.</p>
<p>앨런 케이는 메시징을 가장 유연한 추상화라고 생각했고 메시지는 모든 세부 구현과 정보를 은익한다고 생각했습니다. 그리고 메시지에 기반한 시스템 설계를 목표로 스몰토크(언어 이름에서 그가 생각한 OOP의 특징을 잘 알 수 있습니다)를 개발한 것입니다.</p>
<p>앨런 케이가 정의하거나 강조한 형태의 OOP가 35년이 지난 현 시점에서 우리에게 어떤 중요성이 있는지는 따로 논의할 문제이지만 그 용어를 만든 사람의 의도를 전혀 고려하지 않고 OOP를 논하는 것은 확실히 잘못된 것이겠죠. 무엇보다 우리는 OOP를 얘기하면서 너무 (엘런 케이가 중요하지 않다고 말한) 객체와 클래스 같은 언어적 장치에만 논의가 머물러 있다는 생각이 듭니다.</p>
<p><strong>자바의 메시징, 인터페이스</strong></p>
<p>그럼 메시징이란 뭘까요?  메시징을 따로 논하자면 메시징의 여러 요소들이 얘기될 수 있지만, 자바 입장에서 보면 메시징은 메서드 호출의 한 형태인데, 메서드 호출을 처리할 객체를 결정하는 시점이 컴파일 시점이 아닌 실행시점이라는 것이 일반 메서드 호출과 메시징을 구분하는 구별점이라고 말할 수 있습니다. 다른 말로 (함수형 언어에서 주로 사용하는) <a href="http://en.wikipedia.org/wiki/Dynamic_dispatch">동적 디스패치</a>인 거죠. 저는 OOP의 특징을 하나만 뽑으라고 한다면 동적 디스패치를 뽑아야 말합니다.</p>
<p>앨런 케이가 말한 세 가지 중 두 번째, 상태 처리 과정의 지역적 보존, 보호, 은익은 객체와 관련된 특징들 입니다. 자바에서는 객체를 표현하는 데 클래스를 사용하죠. 그리고 나머지 두 가지, 메시징과 지연 바인딩과 관련된 자바의 장치는 인터페이스입니다. 추상 클래스의 추상 메서드를 생각할 수도 있지만, 자바는 단일 상속만 허용하면서 추상 클래스와 인터페이스의 용도를 분명히 구분했습니다. 추상 클래스는 구현상의 유사성을 모듈화하는 용도이고 인터페이스는 메시지를 형식 체계(Type System) 안에서 규약화(Specification) 한 것입니다. 즉 추상 클래스는 내부 구현의 모듈화 문제, 인터페이스는 클래스 외부의 타 객체와의 협력 문제를 주로 다룹니다.</p>
<p>자바가 엄격한 정적 형식 언어라는 특성 때문에 스몰토크와 같은 수준의 동적인 메시징은 불가능하기도 하고, 전략적으로 C++와 비슷한 형태로 만들면서 시뮬라 67 형태의 OOP가 되었지만, Objective-C의 프로토콜을 참조해서 최대한 스몰토크에서 말하는 OOP를 도입하려고 노력한 흔적이 바로 인터페이스입니다.</p>
<p><strong>OOD, 인터페이스, 스프링</strong></p>
<p>이런 아이디어는 디자인 패턴에서도 강조되는데, 디자인 패턴 1장에 보면 두 가지 설계 원칙을 강조합니다. 하나는 &#8220;구현이 아닌 인터페이스로 프로그램을 짜라&#8221;는 것이고 또 하나는 &#8220;클래스 상속 보다는 객체 구성을 선호하라&#8221;는 것입니다. 이 중 첫번째는 앨런 케이의 OOP에 대한 생각과 일맥상통하는 말입니다.</p>
<p>지금은 홈페이지에서 사라졌지만 피보탈로 넘어가기 전까지도 남아 있었던 스프링의 사명 선언문의 여섯 문항 중 두번째는 이렇습니다.</p>
<blockquote><p><em>&#8220;클래스가 아닌 인터페이스로 프로그램을 작성하는 것이 최선이다. 스프링은 인터페이스를 사용함으로서 생기는 복잡성을 없앤다(It’s best to program to interfaces, rather than classes. Spring reduces the complexity of using interfaces to zero).&#8221;</em></p></blockquote>
<p>정리하면, OOP의 핵심은 메시징(동적 디스패칭)이고 자바에서 이 메시징과 가장 유사한 것은 인터페이스라는 것, 그리고 인터페이스로 설계하는 것이 OOD에서 매우 중요하며 스프링이 해결하려는 문제 중 중요한 한가지는 이 인터페이스로 프로그래밍을 할 때 생기는 복잡성을 제거하려는 것이라는 사실입니다.</p>
<p><strong>인터페이스 실효성, 응집 단위의 크기(granularity)</strong></p>
<p>이 정도로 OOP 언어인 자바에서 인터페이스의 의미와 스프링과 인터페이스의 관계는 충분히 거론되었다고 생각합니다.</p>
<p>이제 제 입장을 밝히겠습니다. (서설이 너무 길어!)</p>
<p>저는 높은 응집도와 느슨한 결합 원칙(High Cohesion, Low Coupling)에 따라서 <strong>응집도가 높아야 하는 부분</strong>에서는 인터페이스나 다른 추상화 장치를 쓰지 않고 적절한 수준에서 강한 결합을 유지하는 것이 가능하다고 생각합니다. 한 클래스 안에서는 클래스 간의 협동보다 높은 결합도가 유지될 수 있고, 한 클래스와 그 내부 클래스 간의 협동은 별도 클래스들 간의 협동보다 결합도가 높을 수 있으며, 한 패키지 안의 클래스들은 타 패키지에 있는 클래스보다 결합도가 높아도 문제가 되지 않을 수 있습니다.</p>
<p>인터페이스는 <strong>요구되는 결합 강도에 따라서 적절히 사용</strong>하면 됩니다. 클래스와 내부 클래스 사이의 협동에 불필요한 인터페이스를 쓰는 것은 과잉일 수 있습니다. (자바의 기본 가시성으로 서로의 내부를 열어 볼 수 있는 사이인) 한 패키지 안에서만 사용될 인터페이스도 과잉이라고 생각할 수 있습니다.</p>
<p>하지만 (객체 하나 이상으로 구성된 단위 기능인) <a href="http://en.wikipedia.org/wiki/Component-based_software_engineering#Software_component">컴포넌트</a>라면, 그 컴포넌트가 아무리 단순하더라도 인터페이스를 쓰는 것이 적절하다고 생각합니다. 컴포넌트의 구현이 단순하다는 사실 자체가 은익되어야 할 정보입니다. 외부에서는 해당 컴포넌트가 단순한지, 수백개의 클래스로 구성된 거대한 물건인지, 외부 클라우드 시스템의 수백개 노드로 돌아가는 원격 서비스인지 몰라야 합니다.</p>
<p><span data-ft="{&quot;tn&quot;:&quot;K&quot;}" data-reactid=".bf.1:3:1:$comment622319567879676_638557076255925:0.0.$right.0.$left.0.0.1:$comment-body"><span class="UFICommentBody" data-reactid=".bf.1:3:1:$comment622319567879676_638557076255925:0.0.$right.0.$left.0.0.1:$comment-body.0"><span data-reactid=".bf.1:3:1:$comment622319567879676_638557076255925:0.0.$right.0.$left.0.0.1:$comment-body.0.$end:0:$28:0">저는 솔직히 스몰토크처럼 모든 것을 객체로 취급한다는 철학에 약간은 회의적인 시각을 가지고 있습니다. 스몰토크는 모든 프로그래밍 요소를 객체와 메시징이라는 메타구조로 단순화하고 문제를 해결하려고 하는데, 세밀한 수준(fine-grained)에서의 OOP는 실효성이 떨어지지 않나 생각됩니다. 1 + 1 같은 작은 일은 굳이 OOP 개념을 적용할 필요가 없다는 이야기 입니다.</span></span></span></p>
<p><span data-ft="{&quot;tn&quot;:&quot;K&quot;}" data-reactid=".bf.1:3:1:$comment622319567879676_638557076255925:0.0.$right.0.$left.0.0.1:$comment-body"><span class="UFICommentBody" data-reactid=".bf.1:3:1:$comment622319567879676_638557076255925:0.0.$right.0.$left.0.0.1:$comment-body.0"><span data-reactid=".bf.1:3:1:$comment622319567879676_638557076255925:0.0.$right.0.$left.0.0.1:$comment-body.0.$end:0:$32:0">다른 이야기지만, 그런 의미에서 (순수 OOP 언어이면서 동시에 FP 언어인)스칼라에서 시도하는 함수형 OOP가 좋아 보입니다. 세밀한 문제 해결은 FP로, 큰 문제 해결은 OOP로 풀어가는 형태랄까요. 람다가 들어오면서 자바 8도 메서드 수준의 추상화가 가능해졌으니 자바도 객체의 크기(granularity)가 지금 보다는 조금 더 커질 것으로 예상됩니다.</span></span></span></p>
<p><span data-ft="{&quot;tn&quot;:&quot;K&quot;}" data-reactid=".bf.1:3:1:$comment622319567879676_638557076255925:0.0.$right.0.$left.0.0.1:$comment-body"><span class="UFICommentBody" data-reactid=".bf.1:3:1:$comment622319567879676_638557076255925:0.0.$right.0.$left.0.0.1:$comment-body.0"><span data-reactid=".bf.1:3:1:$comment622319567879676_638557076255925:0.0.$right.0.$left.0.0.1:$comment-body.0.$end:0:$36:0">제 얘기의 요점은 OOP는 응집의 단위가 클 수록 유효성이 커진다는 이야기입니다. 우리가 개발하는 애플리케이션을 구현수준, 객체 설계 수준, 애플리케이션 아키텍처 수준으로 애플리케이션을 조망하는 수준을 나눈다고 할 때, 구현 수준, 클래스 내부를 열어서 작업할 때에서는 인터페이스를 새로 생성할 일이 거의 없을 것입니다. 그리고 객체 설계 단계, 즉 마이크로 아키텍처 단계에서는 필요에 따라 인터페이스를 적절히 도입하면 됩니다. 하지만 과도하게 만들지 않도록 인터페이스가 필요한 시점에 리펙터링을 통해 클래스에서 인터페이스를 추출하는 방식을 적극적으로 적용할만 합니다.</span></span></span></p>
<p><span data-ft="{&quot;tn&quot;:&quot;K&quot;}" data-reactid=".bf.1:3:1:$comment622319567879676_638557076255925:0.0.$right.0.$left.0.0.1:$comment-body"><span class="UFICommentBody" data-reactid=".bf.1:3:1:$comment622319567879676_638557076255925:0.0.$right.0.$left.0.0.1:$comment-body.0"><span data-reactid=".bf.1:3:1:$comment622319567879676_638557076255925:0.0.$right.0.$left.0.0.1:$comment-body.0.$end:0:$40:0">마지막으로 애플리케이션 전체를 조망하는 애플리케이션 아키텍처 수준에서라면 정말 예외적인 상황이 아닌 이상 인터페이스를 먼저 만들고 그 인터페이스를 구현한 클래스를 만들 것입니다. 컴포넌트 경계의 유연성은 매우 명백하게 중요하기 때문입니다.</span></span></span></p>
<p><a href="http://en.wikipedia.org/wiki/Service_%28systems_architecture%29">서비스</a>를 컴포넌트라고 생각할지 말지는 개발하는 사람의 판단에 따라 다를 것입니다. 하지만 &#8220;일반적&#8221;으로 서비스는 컴포넌트입니다. 서비스라는 말 자체가 컴포넌트와 유의어이기도 합니다. 따라서 서비스는 &#8220;일반적&#8221;으로 인터페이스를 통해서 접근하는 것이 매우 타당합니다.</p>
<p><span data-ft="{&quot;tn&quot;:&quot;K&quot;}" data-reactid=".bf.1:3:1:$comment622319567879676_638557076255925:0.0.$right.0.$left.0.0.1:$comment-body"><span class="UFICommentBody" data-reactid=".bf.1:3:1:$comment622319567879676_638557076255925:0.0.$right.0.$left.0.0.1:$comment-body.0"><span data-reactid=".bf.1:3:1:$comment622319567879676_638557076255925:0.0.$right.0.$left.0.0.1:$comment-body.0.$end:0:$44:0">이상은 제가 따르는 제 원칙입니다. 서비스가 모두 클래스 하나로 되어 있는 컴포넌트이고 아주 작으며 앞으로 커질일도 없다면, 그건 특수한 상황이니 그 상황에 맞게 작업하겠죠. 어떤 사람은 클래스 여러 개를 합쳐서 서비스 컴포넌트의 크기를 키울지도 모르겠습니다. 어떤 사람은 정말 서비스에 인터페이스를 만들지 않겠다고 할 수도 있겠죠. 그건 그 분이 판단해서 선택할 문제입니다.<br />
</span></span></span></p>
<p><strong>프로그래밍 메타포로서의 OOP, 메타 경계</strong></p>
<p><span data-ft="{&quot;tn&quot;:&quot;K&quot;}" data-reactid=".bf.1:3:1:$comment622319567879676_638557076255925:0.0.$right.0.$left.0.0.1:$comment-body"><span class="UFICommentBody" data-reactid=".bf.1:3:1:$comment622319567879676_638557076255925:0.0.$right.0.$left.0.0.1:$comment-body.0"><span data-reactid=".bf.1:3:1:$comment622319567879676_638557076255925:0.0.$right.0.$left.0.0.1:$comment-body.0.$end:0:$48:0">하지만 저는 아무리 애플리케이션 규모가 작은 상황에도 저는 가능한 서비스에 인터페이스를 만들 것 같습니다. 왜냐하면 앞에서 말한 메시징 때문입니다. 인터페이스의 기능적인 면 외에도 OOP의 메시지와 같이 인터페이스는 제가 제 애플리케이션을 조망할 때 추상화 수준을 구분해 주는 경계를 제공해 줍니다. 저는 수시로 세부 구현을 하다가도 한 발 물러나 인터페이스 수준에서 특정 컴포넌트나 애플리케이션 전체를 바라보고 다시 특정 영역의 세부로 들어가 코딩을 합니다. 이렇게 두 세 단계의 추상화 수준을 오가면서 세부에 집중하거나 전체를 보기 때문에, 사고의 틀을 제공하는 도구로서 인터페이스가 매우 유용합니다.</span></span></span></p>
<p>OOP는 명령 한줄 한줄, 그리고 함수 하나 하나에서 더 높은 수준에서 문제를 접근하도록 해줍니다. 전 제가 모두 설계하고 구현하는 프로젝트에서도 클래스를 블랙박스로 취급하는 연습을 합니다. 일부로 세부 구현을 잊고 객체 간의 상호 구조에만 집중하는 거죠.</p>
<p>저는 세부에 집착하곤 하는 프로그래머로서 우리가 너무 큰 그림을 잊는 것은 아닌지 되돌아 봐야 한다고 생각합니다. 세부 구현은 잊고 객체라는 블랙박스와 그 객체 사이의 협력이라는 상위  영역에서 시스템을 좀 더 넓게 바라보는 시점과 세부를 바라보는 시점 모두를 균형 있게 유지하고 서로 섞이지 않게 구분할 수 있다면, 그리고 그런 방식의 개발이 가능하도록 각 객체의 책임을 분명하게 정의하고 API를 잘 설계할 수 있다면 훨씬 좋은 SW를 만들 수 있을 것입니다.  그리고 그런 식으로 일할 때 인터페이스는 매우 중요한 역할을 할 것입니다.</p>
<p><strong>정리</strong></p>
<p>다시 정리하면 서비스에 인터페이스를 적용하겠다는 이유가 결국 두 가지인데, 서비스가 인터페이스를 적용하기에 충분히 큰 애플리케이션의 구성 단위이므로 인터페이스를 적용하는 것이 매우 타당해 보인다는 것이 하나이고, OOP의 핵심 개념인 메시징의 관점에서 제가 사고하는 수준을 구분해 주기 때문에 서비스 정도라면 아무리 단순한 애플리케이션에서도 인터페이스를 사용해서 얻는 이득이 있다는 것이 또 한 이유입니다.</p>
<p>가독성 이야기가 나왔습니다. 추상화나 간접화가 구현내용까지 다가가는데 여러 단계가 있는 것을 가독성이라고 표현하신 것 같습니다. 하지만 &#8220;원칙상&#8221; 좋은 OOD라면 객체간의 협력(메시징)이라는 큰 그림으로 파악되는 수준의 내용과 개별 컴포넌트나 클래스 속 세부 구현이 잘 분리되어야 합니다. 그리고 여러 클래스의 세부 구현을 옮겨 다니면서 봐야 하는 일이 최소화되어야 하고요. 프로그래머가 모든 세부 구현과 클래스 수준의 협력 구조를 모두 머리에 담아두고 있어야 한다면 뭔가 OOP에 맞게 설계된 것이 아닐 수 있습니다.</p>
<p>한가지, 오해가 생길까봐 첨언하면, 인터페이스를 쓰자는 것이 <a href="http://en.wikipedia.org/wiki/Big_Design_Up_Front">선행 정밀 설계</a>를 의미하지 않습니다. 저는 <a href="http://en.wikipedia.org/wiki/Code_refactoring">지속적으로 개선되는 설계</a> 또는 <a href="http://en.wikipedia.org/wiki/Emergent_Design">창발적 설계</a>를 지지하는 사람입니다.</p>
<p>이상 어겨도 감옥가지 않는 &#8220;원칙&#8221;과 &#8220;일반론&#8221;에 대한 제 생각이었습니다.</p>
<ul>
<li>2015/1/6 토론 중에 추가로 쓴 내용을 합쳤습니다.</li>
<li>2015/1/8 글을 읽기 좋게 정리하고 소제목을 달았습니다.</li>
<li>2016/1/25 오타를 수정하고 몇가니 문장을 다듬었습니다.</li>
</ul>
]]></content:encoded>
							<wfw:commentRss>https://blog.fupfin.com/?feed=rss2&amp;p=81</wfw:commentRss>
		<slash:comments>4</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">81</post-id>	<feedburner:origLink>https://blog.fupfin.com/?p=81</feedburner:origLink></item>
	</channel>
</rss>
