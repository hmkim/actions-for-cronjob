<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Jeong Woo Ahn on Medium]]></title>
        <description><![CDATA[Stories by Jeong Woo Ahn on Medium]]></description>
        <link>https://medium.com/@jeongwooahn?source=rss-3d75258a9bf8------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*tLGhsTfMkfFAyRG-0I6ZMg.jpeg</url>
            <title>Stories by Jeong Woo Ahn on Medium</title>
            <link>https://medium.com/@jeongwooahn?source=rss-3d75258a9bf8------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Tue, 14 May 2019 07:07:38 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@jeongwooahn" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[Please refer to the following article.]]></title>
            <link>https://medium.com/@jeongwooahn/please-refer-to-the-following-article-7164ddfc9d5d?source=rss-3d75258a9bf8------2</link>
            <guid isPermaLink="false">https://medium.com/p/7164ddfc9d5d</guid>
            <dc:creator><![CDATA[Jeong Woo Ahn]]></dc:creator>
            <pubDate>Mon, 13 May 2019 02:05:49 GMT</pubDate>
            <atom:updated>2019-05-13T02:05:49.197Z</atom:updated>
            <content:encoded><![CDATA[<p>Please refer to the following article. <a href="https://www.codementor.io/amehjoseph/convert-html-css-content-to-a-sleek-multiple-page-pdf-file-using-jspdf-javascript-library-eyyz74hci">https://www.codementor.io/amehjoseph/convert-html-css-content-to-a-sleek-multiple-page-pdf-file-using-jspdf-javascript-library-eyyz74hci</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7164ddfc9d5d" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[vue.js] UI라이브러리 milkui 제작기]]></title>
            <link>https://medium.com/@jeongwooahn/vue-js-ui%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-milkui-%EC%A0%9C%EC%9E%91%EA%B8%B0-177dcc684b47?source=rss-3d75258a9bf8------2</link>
            <guid isPermaLink="false">https://medium.com/p/177dcc684b47</guid>
            <category><![CDATA[vuejs]]></category>
            <category><![CDATA[milkui]]></category>
            <category><![CDATA[ui-library]]></category>
            <dc:creator><![CDATA[Jeong Woo Ahn]]></dc:creator>
            <pubDate>Sun, 12 May 2019 06:47:47 GMT</pubDate>
            <atom:updated>2019-05-12T06:47:47.871Z</atom:updated>
            <content:encoded><![CDATA[<p>작년 말부터 <a href="http://ahnyuri.com/">지인 디자이너</a>와 함께 vue.js 전용 UI 라이브러리를 만들기 시작했다. 일종의 개발자 취미라고나 할까.</p><p>조금씩 컴포넌트 하나씩 추가하다가 어느 순간 개인적인 🍼거사도 있고해서 계획한 컴포넌트를 다 갖추려면 꽤 시간이 필요하다는 느낌이 왔다. 아직 갖추어진 컴포넌트가 너무 적어서 실제로 사용하기는 어려울테지만 공개하지 않으면 흐지부지 될 것 같아서 일단 <a href="https://www.npmjs.com/package/@guruahn/milkui">npm에 배포</a>하고 공개하기로 했다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*XGz5YystSpgy63evxM1agg.png" /></figure><p>이름하야 <a href="https://woo-u.github.io/milkui">milkui</a> 이다. 그렇다. 🥛 milk는 우유를 의미한다. 우유는 그냥 별 의미없고 제작자들의 이름에서 따온 단어의 조합이다. 라이브러리 소개 사이트는 깃헙 페이지로 만들었다. 발과 구글을 동원하여 영문으로 작성했다. 굳이 영어로 작성한 이유는 내가 만든 라이브러리를 단 한명이라도 사용해보면서 이슈를 남겨주길 희망하고 있는데 Vue.js 사용자는 국내는 별로 없고 외국에 많다. 실제로 <a href="https://github.com/guruahn/vue-google-oauth2">간단한 구글 로그인 Vue.js 플러그인</a>을 만들어 배포한적이 있었는데 종종 외국인들이 이슈를 남기고 풀리퀘스트도 보내주어서 발로하는 영어라도 나름 소통도 되고 내가 만든것이(보잘것 없지만)성장하는걸 경험하고 있다.</p><h4>왜 만들었나</h4><p>처음 UI 라이브러리를 만들게된것은<a href="https://medium.com/@jeongwooahn/%EC%A7%80%EB%82%9C-1%EB%85%84-%ED%9A%8C%EA%B3%A0-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EA%B8%B0-42e660951467#7233"> 2018년 회고 글</a>에서도 언급한 적이 있지만 협업과 생산성이라는 키워드 때문이다. 한 세미나에서 받은 영감으로 UI 라이브러리를 직접 제작함으로써 협업과 생산성을 증진할 수 있을거라고 생각했다. 그렇게 회사에서 구성원들을 설득하여 진행했고 결과도 좋았다.</p><p>개발자 개인의 차원에서 보더라도 많은 이득이 있었다. 사실 ReactJS나 Vue.js 같은 컴포넌트 기반의 프레임웤을 사용하여 소프트웨어를 작성할때는 컴포넌트를 어떻게 잘 만들지? 어떻게 재사용 가능하게 만들지? 컴포넌트간에 관계는 어떻게 만들지? 데이터 처리 로직과 UI로직은 왜/어떻게 분리하지? 등등의 질문에 대한 답을 찾는것이 매우 중요한 과정이 된다. 직접 UI라이브러리를 만들면서 기존의 완성도 있는 라이브러리를 많이 뜯어보게 되고 이 질문들에 대한 답을 찾을 수 있다.</p><h4>독립 창작 소스(?)</h4><p>우리가 만드는것이 공익을 위한것도 아니고 돈을 받고 하는것도 아니다. 일종의 독립출판물 처럼 약간 창작욕구 비스무리한 욕망이 섞여있는것 같다. 누군가가 사보지는 않아도 내 창의적 욕구를 출판물이라는 물질적인 결과물로 만들어낸다는것 만으로도 의미를 가지는 것처럼 말이다.</p><p>쓰고 보니 허세 조금 있는것 같다. 모든일에는 약간의 ‘좋은&#39; 허세가 양념처럼 들어가는게 좋은법이다.(뭔소리)</p><h4>앞으로..</h4><ul><li>기본적인 컴포넌트 더 추가하기: 아직 추가되어야할 컴포넌트가 많다. 매우 천천히 재미를 잃지 않은 선에서 추가해나가고 싶다. 폼과 테이블과 같은 것은 물론이고 메시지 박스나 로딩같은 컴포넌트도 필요하면 추가하고 싶다.</li><li><a href="https://github.com/woo-u/milkui">깃헙</a>에 소스도 공개되어 있으니 오셔서 ⭐별도 주시고 의견도 좀 주시면 더 멋지게 만들 수 있을것 같습니다만. 🙏</li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=177dcc684b47" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Vue.js] watch와 computed 의 차이와 사용법]]></title>
            <link>https://medium.com/@jeongwooahn/vue-js-watch%EC%99%80-computed-%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%99%80-%EC%82%AC%EC%9A%A9%EB%B2%95-e2edce37ec34?source=rss-3d75258a9bf8------2</link>
            <guid isPermaLink="false">https://medium.com/p/e2edce37ec34</guid>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[computed]]></category>
            <category><![CDATA[vuejs]]></category>
            <dc:creator><![CDATA[Jeong Woo Ahn]]></dc:creator>
            <pubDate>Fri, 22 Mar 2019 05:43:21 GMT</pubDate>
            <atom:updated>2019-03-22T05:43:21.591Z</atom:updated>
            <content:encoded><![CDATA[<p>Vue.js에서 computed 프로퍼티는 매우 유용하게 사용된다. 그러나 처음 Vue.js를 시작할때 computed와 watch가 모두 반응형이라는 키워드과 관련이 있기 때문에 이 둘을 혼동하곤 했다. Vue.js의 강점을 잘 살려서 코딩을 하기위해 이 두가지 키워드를 잘 알고 있어야 한다.</p><h3>Computed — 반응형 getter</h3><p>computed를 한마디로 얘기하자면 “반응형 getter”이다. 아래 예시를 보자. vue.js 공식가이드 문서에 나오는 예시와 동일한 로직을 옮긴것이다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/8ee27de0b767b20025ccb679520c5ec6/href">https://medium.com/media/8ee27de0b767b20025ccb679520c5ec6/href</a></iframe><p>computed 프로퍼티를 보면 reverseMessage 라는 프로퍼티에 값으로 익명함수가 할당되어있다. computed에 정의하는 이 익명함수는 반드시 값을 리턴하도록 작성되야한다.</p><h4>getter</h4><p>computed의 reverseMessage 프로퍼티가 정의될때 내부적으로는 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a>를 통해 정의되며, 이때 익명함수가 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/get">getter</a>로 설정된다. reverseMessage 를 함수가 아니라 일반 객체처럼 사용할 수 있는점과 호출될때만 계산이 이루어지고, 계산결과가 캐싱되는 특성이 생기게 된것은 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/get#%EB%98%91%EB%98%91%ED%95%9C(Smart)_%EC%8A%A4%EC%8A%A4%EB%A1%9C_%EB%8D%AE%EC%96%B4%EC%93%B0%EB%8A%94(self-overwriting)_%EB%8A%90%EA%B8%8B%ED%95%9C(lazy)_getter">getter의 특성</a>덕분이다(이는 methods와의 차이를 유발하는 지점이기도 하다). 하지만 바로 이점 때문에 값이 변하게 되어도 캐싱때문에 변경된 값을 인지하지 못하는 단점이 생기게된다.</p><h4>반응형(reactive)</h4><p>Vue.js 는 이 단점을 상쇄하고 반응형을 구현하기 위해 특별한 장치를 한다. getter 함수 내에 속한 프로퍼티의 변경여부를 추적하는 것이다.(<a href="https://mygumi.tistory.com/311">마이구미님 글 참고</a>) 위 예시에서는 message 를 감시하고 있다가 message의 값이 변경되면 reverseMessage 를 다시 계산한다. 결국, computed는 사용하기 편하고, 자동으로 값을 변경하고 캐싱해주는 아주 끝내주는 “반응형 getter”라 부를 수 있겠다. (<a href="https://kr.vuejs.org/v2/guide/reactivity.html">반응형은 Computed뿐 아니라 Vue.js 의 전반의 주요한 특징으로 볼 수 있다</a>.)</p><h3>Watch — 반응형 콜백</h3><p>변경을 감시(watch)한다는 점 때문에 computed와 watch를 혼동할 수 있다.걱정할 필요는 없다. computed에 비해 watch는 단순하고 이해하기 쉽기 때문이다. watch는 <strong>Vue 인스턴스의 특정 프로퍼티가 변경될때 지정한 콜백함수가 실행</strong>되는 기능이다. 위 예시를 응용한다면 아래와 같을 것이다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/0974e20a9d6574d1e49a5703db8aec64/href">https://medium.com/media/0974e20a9d6574d1e49a5703db8aec64/href</a></iframe><p>watch를 정의한 부분(17~21)을 보면 message 프로퍼티에 익명함수가 할당되어있다. 이 익명함수가 콜백함수 역할을 할 것이고, message 프로퍼티가 변경되면 변경된 값을 콜백함수의 첫번째 인자로 전달하고, 이전 값을 두번째 인자로 전달하여 실행한다. computed가 새 프로퍼티를 생성하고 그것의 getter 로 익명함수를 설정되는 것과는 달리 watch는 아무 프로퍼티도 생성하지 않고 익명함수는 단순히 콜백함수로의 역할을 한다. watch에 명시된 프로퍼티는 감시할 대상을 의미할 뿐이다.</p><h3>어떻게 사용할 것인가</h3><ul><li>위의 예시처럼 인스턴스의 data에 할당된 값들 사이의 종속관계를 자동으로 세팅하고자 할때는 computed로 구현하는것이 좋다. 그러니까 reverseMessage 는 message 값에 따라 결정되어진다. 이 종속관계가 조금이라도 복잡해지면 watch로 구현할 경우 중복계산이 일어나거나 코드 복잡도가 높아질 것이다. 이는 오류도 더 많이 발생시킬 것이다.</li><li>watch는 특정 프로퍼티의 변경시점에 특정 액션(call api, push route …)을 취하고자 할때 적합하다.</li><li>computed의 경우 종속관계가 복잡할 수록 재계산 시점을 예상하기 힘들기 때문에 종속관계의 값으로 계산된 결과를 리턴하는 것 외의 사이드 이펙트가 일어나는 코드를 지양해야한다.</li><li>더 쉽게 판단하는 방법: 만약 computed로 구현가능한 것이라면 watch가 아니라 computed로 구현하는것이 대게의 경우 옳다.</li></ul><h4>참고 문서</h4><ul><li><a href="https://kr.vuejs.org/v2/guide/computed.html">computed와 watch</a></li><li><a href="https://stackoverflow.com/questions/43277705/vuejs-difference-between-computed-and-watched-properties">vue.js difference between computed and watched properties</a></li><li><a href="https://mygumi.tistory.com/311">Vue.js: computed는 어떻게 동작하는가?</a></li><li><a href="https://kr.vuejs.org/v2/guide/reactivity.html">반응형에 대해 깊이 알아보기</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e2edce37ec34" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[도움되었다니 기쁘네요~ 감사합니다!]]></title>
            <link>https://medium.com/@jeongwooahn/%EB%8F%84%EC%9B%80%EB%90%98%EC%97%88%EB%8B%A4%EB%8B%88-%EA%B8%B0%EC%81%98%EB%84%A4%EC%9A%94-%EA%B0%90%EC%82%AC%ED%95%A9%EB%8B%88%EB%8B%A4-84155b4cc235?source=rss-3d75258a9bf8------2</link>
            <guid isPermaLink="false">https://medium.com/p/84155b4cc235</guid>
            <dc:creator><![CDATA[Jeong Woo Ahn]]></dc:creator>
            <pubDate>Wed, 06 Mar 2019 07:11:49 GMT</pubDate>
            <atom:updated>2019-03-06T07:11:49.851Z</atom:updated>
            <content:encoded><![CDATA[<p>도움되었다니 기쁘네요~ 감사합니다!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=84155b4cc235" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[“vm.$nextTick를 사용하면 전체가 렌더링된 상태를 보장할 수 있다.”]]></title>
            <link>https://medium.com/@jeongwooahn/vm-nexttick%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%A0%84%EC%B2%B4%EA%B0%80-%EB%A0%8C%EB%8D%94%EB%A7%81%EB%90%9C-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%B3%B4%EC%9E%A5%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4-dee414d77d6c?source=rss-3d75258a9bf8------2</link>
            <guid isPermaLink="false">https://medium.com/p/dee414d77d6c</guid>
            <dc:creator><![CDATA[Jeong Woo Ahn]]></dc:creator>
            <pubDate>Mon, 18 Feb 2019 02:27:14 GMT</pubDate>
            <atom:updated>2019-02-18T02:28:04.556Z</atom:updated>
            <content:encoded><![CDATA[<p>“<a href="https://kr.vuejs.org/v2/api/#vm-nextTick">vm.$nextTick</a>를 사용하면 전체가 렌더링된 상태를 보장할 수 있다.” 는 식의 코멘트가 mounted, updated에 있었으나 삭제하였습니다. nextTick(callback)는 정확히는 다음 돔 업데이트가 끝날때까지 callback 실행을 지연시켜주는 역할이지, 전체 렌더링 상태를 보장하는 역할을 하는 것은 아니기 때문입니다. 기존 표현이 혼란을 줄 수 있는 표현이었음을 사과드립니다.</p><p>nextTick 관련해서는 <a href="https://vuejs.org/v2/api/#Vue-nextTick">공식문서</a>를 꼭 확인해주시길 바랍니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=dee414d77d6c" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[⌈마이크로 카피⌋ 독서후기]]></title>
            <link>https://medium.com/@jeongwooahn/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%B9%B4%ED%94%BC-%EB%8F%85%EC%84%9C%ED%9B%84%EA%B8%B0-3b9f8095186e?source=rss-3d75258a9bf8------2</link>
            <guid isPermaLink="false">https://medium.com/p/3b9f8095186e</guid>
            <dc:creator><![CDATA[Jeong Woo Ahn]]></dc:creator>
            <pubDate>Wed, 23 Jan 2019 05:00:00 GMT</pubDate>
            <atom:updated>2019-01-23T05:00:00.635Z</atom:updated>
            <content:encoded><![CDATA[<p>⌈<a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=141269200&amp;start=slayer">마이크로 카피</a>⌋를 읽으면서 ‘아!’를 외치게 했던 지극히 개인적인 밑줄을 공유한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/500/1*H6ut_n9hVBYa463pYdxMog.jpeg" /></figure><h4>마이크로카피는 무엇인가?</h4><blockquote>사용자 인터페이스에서 사용자가 취하는 행동에 직접 관련된 단어 또는 문구.</blockquote><blockquote>사용자 행동 이전의 동기 부여</blockquote><blockquote>사용자 행동에 동반되는 지침</blockquote><blockquote>사용자 행동 이후의 피드백</blockquote><blockquote>— 30p</blockquote><h4>가장 훌륭한 카피라이터는 사용자다</h4><blockquote>사용자가 생각하는 것을 표현하고자 할 때는 그들이 사용하는 단어를 쓰는 것이 좋다. 사용자는 항상 더 정확하고 가장 진정성 있는 문구를 사용한다. 사용자가 사용하는 단어를 이용해 브랜드의 이점을 설명함으로써 사용자를 움직여라. — 55p</blockquote><blockquote>문어체에서는 격식을 갖춘 상황에서라도 소리 내어 말하지 않는 단어와 문구가 포함된다. 서비스 지향적이며 진정성 있는 대화의 경험을 제공하기 위해서는 격식을 차린 딱딱한 문구를 가능한 한 사용하지 말아야 한다. 규칙은, <strong>소리 내어 말하지 않는 것은 글로도 쓰지 말라. </strong>— 73p</blockquote><h4>방법이 아닌 가치에 관해 이야기 하라</h4><blockquote>글의 초점을 사용자가 혜택을 얻기 위해서 무엇을 해야 하는지가 아닌, 그들이 무엇을 얻을 수 있는가로 바꿔라. — 80p</blockquote><blockquote>제품과 서비스를 사용한 사람들은 어떻게 변할 것인가? 사용자가 이전에는 할 수 없었던 것 중 어떤 일을 할 수 있게 됐는가? 사용자를 위해 어떤 문제를 해결했는가? — 81p</blockquote><p>서비스가 원하는 것은 사용자로 하여금 어떤 행동(클릭/가입/결재)을 하도록 하는것일 텐데, 그 행동을 하는 방법을 설명하는 것으로는 행동유도가 어렵다는 것이다. 그 행동을 왜 해야하는지, 결국 그 행동을 했을때 사용자가 얻는것이 무엇인지 잘 설명할 수 있다면 행동의 동기가 생긴다는 이야기.</p><h4>사용자는 회원가입을 얼마나 싫어할까?</h4><blockquote>아주 많이 싫어한다! … 실제로 한 대기업에서 결제 전에 하던 회원 가입 절차를 생략했더니 년 매출이 3억 달러나 상승했다.(제러드 M. 스풀이 쓴 기사 <a href="https://articles.uie.com/three_hund_million_button/">The $300 Million Button</a>을 읽어보라.) — 88p</blockquote><p>백번을 강조해도 부족한 말이다. 회원가입과 같은 폼에서 장애물을 제거하는것은 나도 A/B테스트를 통해서 명백히 확인한 바도 있다. 필수 입력사항(이메일/비번) 두 가지와 부가적 입력사항 2(3가지인가?)가지를 요구하는 가입폼에서, 여러 회의끝에 부가적 입력사항을 없앤 버전을 (굳이)테스트해보기로 했다. 당연히 없앤 버전이 압도적으로 전환이 많이 일어났다.(이때의 수치들을 기록해두었어야 하는데…아쉽다)</p><h4>에러메시지</h4><blockquote>에러 또는 실패와 같은 단어를 쓰지 마라. … 전문적인 기술 용어를 사용하지 말라. 가장 최악의 경우는 기술 용어와 법적 표현이 결합한 것과 에러와 실패라는 용어다. — 140p</blockquote><blockquote><strong>개발자가 해당 에러 메시지를 작성하게 두면 안 된다.</strong> 에러 메시지 작성은 기본적으로 개발자의 업무가 아니며, 어쩌면 그 일을 잘 할 수도 있지만 못할 가능성이 더 크기 때문이다. — 143p</blockquote><p>개발자로서, 인정할 수 밖에 없다. 우리에게 메시지를 작성하게 두지 마라!</p><h4>공백상태는 좋은 서비스를 제공하는 기회</h4><blockquote>빈 장바구니는 판매를 촉진할 기회가 된다. 결과 없이 끝난 검색은 비슷한 검색 결과를 제고해 사용자가 빈손으로 떠나지 않게 함으로써 당신이 신경쓰고 있다는 것을 보여줄 기회가 된다. — 162p</blockquote><blockquote>여기에는 아무것도 없다고 말하는 대신, 여기에 있어야 할 것이나 사용자가 여기서 무엇을 할 수 있는지, 해당 기능의 역할과 그것이 사용자에게 어떤 도움이 되는 지에 대해 써라. — 164p</blockquote><h4>플레이스홀더</h4><blockquote>입력 필드 안에 레이블을 입력하는 것은 사용자의 단기 기억에 도전장을 내미는 셈이 된다. 사용자가 입력을 시작하면 해당 레이블은 사라지고, 사용자는 다시 돌아와서 어떤 정보를 입력해야 했는지 생각해 낼 방법이 없다. — 179p</blockquote><blockquote>타당한 이유가 없다면 플레이스 홀더를 넣지 마라</blockquote><blockquote>텍스트가 많아지면 이런 느낌은 바로 사라진다. 왜냐하면 사용자는 모든 단어를 읽어야 하고 그 자체가 일이므로 텍스트가 많다는 것은 할일이 많다는 것은 할일이 많다는 뜻이기 때문이다. 따라서 사용자가 태스크를 끝내야 하는 폼과 기타 영역에서의 규칙은 언제나 단어를 될 수 있으면 적게 사용하는 것이다. — 181p</blockquote><h4>버튼을 클릭하면 어떤 가치가 있는지 이야기 하라</h4><blockquote>좋은사례</blockquote><blockquote>Register &gt; Save My Seat <a href="http://www.leadpages.net">www.leadpages.net</a></blockquote><blockquote>Sign Up&gt; YES, KEEP ME INSPIRED <a href="http://www.marieforelo.com">www.marieforelo.com</a></blockquote><blockquote>Search &gt; Find Jobs <a href="http://www.indeed.com">www.indeed.com</a></blockquote><blockquote>Start &gt; Start Hanging Out</blockquote><p>이와 같이 이 책에서는 주옥같은 조언들이 넘처나며 위에서 언급한 상황 외에도 에러페이지, 대기 시간, 기타 사용성 등 다양한 상황에서의 가이드를 제공하고 있다.</p><p>이 가이드를 지침을 그대로 서비스에 반영 해볼 수도 있지만, 이 책에서 지향하는 관점을 응용해서 다양한 실험들을 해보면 좋을것 같다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3b9f8095186e" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[⌈데이터 스토리텔링⌋ 독서후기]]></title>
            <link>https://medium.com/@jeongwooahn/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8A%A4%ED%86%A0%EB%A6%AC%ED%85%94%EB%A7%81-%EB%8F%85%EC%84%9C%ED%9B%84%EA%B8%B0-b8834e072303?source=rss-3d75258a9bf8------2</link>
            <guid isPermaLink="false">https://medium.com/p/b8834e072303</guid>
            <dc:creator><![CDATA[Jeong Woo Ahn]]></dc:creator>
            <pubDate>Thu, 10 Jan 2019 13:07:56 GMT</pubDate>
            <atom:updated>2019-01-10T13:13:05.861Z</atom:updated>
            <content:encoded><![CDATA[<p>책 ⌈데이터 스토리텔링⌋을 읽고 밑줄그은 내용과 간단한 후기를 작성해 본다. 사내에서 강력한 추천을 받았고, 프론트 엔지니어로서도 필요한 내용이라는 생각이 들어 읽게 되었다. 내용이 좋아 밑줄을 팍팍 긋게되는 책이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/500/1*81tSBitrHIk51gPQpyL-yA.jpeg" /></figure><p>“프레젠테이션을 위한&quot;이라는 수식어가 붙어있긴 하지만, 시각화 일반에 대한 기초적인 기법들을 다루고 있으므로 데이터 시각화를 다루는 분야에 계신분이라면 모두 도움이 될만한 책이다.</p><blockquote>사람들은 자주 탐색용 분석이 설명용 분석의 대상이라면, 모든 탐색용 분석 과정을보여주는 것이 괜찮다고 생각하는 실수를 범한다. 즉 앞의 예제에 비유하면 2개의진주만을 보여주는 것이 바람직하지만, 데이터를 정보로 변환하는 과정을 모두 설명하기 위해 100개의 굴을 보여주는 것은 문제가 없다고 생각한다. 이러한 생각은 잘못된 것이지만 이해가 가는 부분이기는 하다. 전체 분석 작업을 마친 후에, 작업한내용 전부와 분석의 신뢰도가 높다는 점을 입증하기 위해 모든 과정을 청중에게 설명하고 싶을 것이다. 이와 같은 의지를 버려라. 여러분은 지금 청중이 쓸데없이 100개의 모든 글을 다시 열어보도록 하고 있는 실수를 범하고 있는 것이다! 청중이 꼭알아야 하는 정보인 2개의 진주에만 집중하라. — 36p</blockquote><p>되돌아보면 내가 관여했던 서비스들에서 이런적이 꽤 있었던것 같다. 정성과 노력이 들어가면 갈 수록 더 그런 경향이 높아진다. 이럴때는 애착이 독이 될 수 있다. 내가 만드는 서비스로부터 한발 물러나 사용자의 시점으로 돌아가야한다.</p><h4>영역그래프와 3D를 피하라</h4><blockquote>나는 영역 그래프를 가장 싫어한다. 인간의 눈은 2차원 공간에 수치값을 배치하는데 있어 뛰어난 능력을 발휘하지 못한다. 이는 논의했던 다른 유형의 가시적 표현보다는 읽기 어려운 영역 그래프를 표시하기 때문이다. 이와 같은 이유로 인해 한 가지 예외 상황인 상당히 다른 양의 숫자를 시각화할 필요가 있을 때를 제외하면 영역그래프의 사용을 피하도록 한다. 그림 2.20에서 볼 수 있듯이 일차원보다 간결한 방법으로 사각형을 이용한 이차원을 실행 가능하도록 한다. — 75p</blockquote><blockquote>3D를 없애버리고 원을 평평하게 만들더라도 해석은 어렵다. 인간의 눈은 정량적 값을 2차원 공간에 표현한 결과를 정확하게 인식하지 못한다. 더 간단히 말하면 파이 차트는 가독성이 떨어진다. 각 구분 영역의 크기가 유사하다고 하면 불가능하지는 않지만 어느 쪽이 큰지를 분별해내기가 어렵다. 크기가 유사하지 않더라도 크기비교만 가능할 뿐 얼마나 큰지를 판단할 수 없다. — 79p</blockquote><h4>연결성</h4><blockquote>우리가 중점적으로 살펴봐야 할 마지막 게슈탈트 원리는 연결성connection이다. 일반적으로 사람은 물리적으로 연결된 객체를 그룹의 일부로 생각하는 경향이 있다. <strong>연결된 특성은 일반적으로 유사한 색상, 크기, 모양보다 강한 연관성 있는 값을 갖는다.</strong> 그림 3.11에서 여러분은 유사 색상, 크기, 모양보다 선으로 연결된 모양을 쌍으로 인식한다. 이러한 현상은 연결성 원리가 작동하기 때문이다. 일반적으로 연결 특징은 공통성보다 약하다. 하지만 원하는 시각 계통을 만들기 위해 선의 두께와 명암을 이용해 이러한 관계에 영향을 줄 수 있다. 4장에서 사전 주목을 이끄는 속성을 설명할 때 시각계통에 대해 좀 더 많은 것을 설명하겠다. — 96p</blockquote><h4>여백</h4><blockquote>전략적으로 사용한 여백은 시각화 자료에서 그만큼 강력한 효과가 된다. 여백이 부족하면 발표 내용에 잠시 쉬어감이 없을 정도로 청중이 부담을 느낀다. 시각화 자료의 설계에 대한 청중의 부담은 피해야 하는 것이다. 여백은 전략적으로 사용해 여백이 아닌 부분에 주목하도록 하는 것이 좋다. — 101p</blockquote><h4>회색</h4><blockquote>나는 일반적으로 회색 계열로 시각화 자료를 설계하고 난 다음 원하는 부분에 주목을 끌기 위해 한 개의 진한 색상을 선택했다. 나의 기본 색상은 검정이 아닌 회색이다. 검정보다 회색에 대해 색상을 좀 더 돋보이게 할 수 있기 때문에 좀 더 두드러진 대조 효과를 얻어낼 수 있다. 여러 이유로 인해 나의 주목을 끄는 색상으로 나는자주 청색을 사용한다. — 133p</blockquote><h4>혼란스러움 제거</h4><blockquote>중요 부분을 강조하는 반면에 혼란스러운 부분을 제거 한다. 생텍쥐 베리는 그의 책 『Airman’s Odyssey』에서 유명한 말을 했다. <strong>“여러분이 추가할것이 더 이상 없을 때가 아니라 제거할 것이 더 이상 없을 때 완벽함을 이루었다는것을 깨닫게 된다(생텍쥐베리, 1943).” </strong>데이터 시각화를 설계의 완벽함과 관련해 어떤 것을 제거할지 또는 강조하지 않을 것인지에 대한 결정은 무엇을 포함시킬 것인지 또는 강조할 것인지보다 더 중요하다. — 148p</blockquote><p>어디서 많이 들어보지 않았는가. 서비스에 기능을 추가할때 많이 하는 이야기이다. 어린왕자를 쓴 생텍쥐베리가 저런 명언을 했다니, 이 부분을 읽으면서 잠시 멍해졌다.</p><blockquote>나는 종종 예측 값이 나머지 값과 구분되어 있지 않은 상태로, 한 개 라인에 예측 값과 실제 값이 모두 표시되어 있는 경우를 본다. 이러한 표시는 잘못한 경우라고 할 수있다. 시각 신호를 이용하면, 실제와 예측 데이터 간 구분할 수 있으며 정보를 쉽게 해석할 수 있다. 그림 6.2에서 실선은 실제 데이터이고 가는 점선은 예측 데이터다. 점선은 실선, 두꺼운 선보다 확실하지 않은 내용을 의미하는 정보를 제공한다. x축 아래의 실제와 예측을 명확히 표현해 이를 강조했다. 쉽게 파악하기 위해 모든 캡션을작성했다. 예측 부분은 배경으로 연한 그림자를 표현해 약간 다르게 구분했다. — 175p</blockquote><h4>헤드라인 먼저 작성하라</h4><blockquote>전체 프리젠테이션이나 커뮤니케이션의 흐름을 구성할 때, 한 가지 전략은 가장 먼저 헤드라인을 만들도록 하는 것이다. 1장에서 논의했던 스토리보딩으로 돌아가보자. 포스트잇에 각 헤드라인을 작성해보자. 명확한 흐름 전개를 만들기 위해 순서를 구성하고 각 아이디어를 연결해논리적인 흐름이 되도록 하자. 이러한 종류의 구성을 선정해 청중이 이해할 수 있는 논리순서가 되도록 하자. 각각의 개별 헤드라인을 여러분의 프리젠테이션 슬라이드의 타이틀이나 작성한 리포트의 섹션 타이틀이 되도록 하자. — 195p</blockquote><p>이 외에도 주옥같은 내용들로 가득한 책이다. 무엇보다 이 책에서 말하고 있는 “타겟에게 요구되는 핵심을 쉽고 정확하게 전달하기&quot;를 이 책 스스로 잘 실천하고 있다.</p><p>잘못된 정보나 좋은 의견이 있다면 언제든지 댓글 부탁드립니다. 박수는 글쓴이를 춤추게 합니다. 👏👏</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b8834e072303" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vue.js 구글로그인 플러그인 vue-google-oauth2]]></title>
            <link>https://medium.com/@jeongwooahn/vue-js-%EA%B5%AC%EA%B8%80%EB%A1%9C%EA%B7%B8%EC%9D%B8-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-vue-google-oauth2-184c2859c78a?source=rss-3d75258a9bf8------2</link>
            <guid isPermaLink="false">https://medium.com/p/184c2859c78a</guid>
            <category><![CDATA[oauth2]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[vuejs]]></category>
            <dc:creator><![CDATA[Jeong Woo Ahn]]></dc:creator>
            <pubDate>Fri, 26 Oct 2018 06:35:48 GMT</pubDate>
            <atom:updated>2018-11-05T07:05:17.797Z</atom:updated>
            <content:encoded><![CDATA[<p>몇 개월 전에 만들었던 패키지이다. 패키지 이름은 <a href="https://www.npmjs.com/package/vue-google-oauth2">vue-google-oauth2</a> 다. <strong>SPA 로 구현한 시스템에서</strong> 구글 로그인 api를 통해 로그인 플로우를 진행할 수 있는 간단한 자바스크립트 소스코드를 Vue로 랩핑한 것이다. 기존의 오래된 프로젝트를 fork하여 oauth2로 업그레이드하고 몇 가지 오류를 수정하였으며 프로미스 기능을 추가했다.</p><h3>플러그인 설치</h3><pre>npm install vue-google-oauth2</pre><p>or</p><pre>yarn add vue-google-oauth2</pre><p>이 플러그인을 사용하려면 아래와 같이 필요한 곳에 작성한다. 나는 앱의 시작점인 main.js 에 작성했다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ea45b61e22021fb7c678ac77b65874c5/href">https://medium.com/media/ea45b61e22021fb7c678ac77b65874c5/href</a></iframe><p>clientId 는 <a href="http://console.cloud.google.com">구글 개발자 콘솔</a>에서 발급받은 아이디이다. 자세한 설명은 생략. scope 은 얻고자하는 권한 정보이다.</p><p>(a)일회용 authorization code를 받는 경우와 (b) 프론트에서 바로accessToken 을 받아 사용하는 경우로 나누어 설명한다.</p><h3>(a) 일회용 authorization code 받기</h3><p>SPA 프로젝트의 백엔드에서 구글 사용자 권한을 사용하려면 이 방식을 사용해야한다. 아래 그림의 플로우를 구현하는것이 목표이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Rdw9UP8LJu1TGX2FZoruKQ.png" /><figcaption>구글 로그인 플로우</figcaption></figure><p>백엔드에서는 authorization code(이하authCode)가 있으면 accessToken 과 refreshToken토큰을 발급받을 수 있다. <strong>이</strong><strong>authCode는 프론트에서 발급받아 백엔드로 전달해줄 수 있다 .</strong> authCode는 한번 발행되면 재사용할 수 없다. accessToken이 재사용 목적으로 발급받는 것이다. 이 토큰은 저장해놓고 만료가 될 때까지 계속 사용할 수 있다.</p><p>이제 authCode 를 발급받아 백엔드로 넘겨주는 코드를 보자.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/7cb185f9a159031b03f2686b4f11c145/href">https://medium.com/media/7cb185f9a159031b03f2686b4f11c145/href</a></iframe><p>여기까지 잘 하시다가 잘안되서 포기하는 경우를 본적이 있다. redirect_uri: &#39;postmessage&#39; 부분때문이다. SPA 프로젝트는 벡엔드와 프론트가 분리되어있기 때문에 저 옵션이 필요한데, <strong>백엔드 코드에서도 저 옵션(</strong>redirect_uri: &#39;postmessage&#39;<strong>)을 잘 명시해주어야</strong> 한다. Go 언어로 만들어진 백엔드 코드 샘플을 간단히 보자.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/64dad9389c01db73999c4a7a2dc9a133/href">https://medium.com/media/64dad9389c01db73999c4a7a2dc9a133/href</a></iframe><p>6번째 줄에 RedirectURL: &quot;postmessage&quot; 가 보이는가? 이렇게 명시가 안되어있으면 SPA 프로젝트이기 때문에 리다이렉트 플로우를 정상적으로 진행할 수 없어서 결국 필요한 토큰을 얻을 수 없다.</p><h3>(b)프론트에서 바로 accessToken 을 받아 사용</h3><p>프론트에서 로그인한 후 accessToken을 받아오는 소스코드이다. refreshToken은 받을 수 없다. 간단히 signIn메소드를 사용하는 방법만 보면 아래와 같다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/2cc25b34b9a6abcaf19f6894f090c60d/href">https://medium.com/media/2cc25b34b9a6abcaf19f6894f090c60d/href</a></iframe><p>this.$gAuth.signIn()이 실행되면 팝업이 열려 사용자가 구글에 로그인하는 플로우가 진행되고 로그인이 완료되면 팝업이 닫히면서 2번줄의 then 이후가 진행되게 된다. 이렇게 얻은 GoogleUser 인스턴스 사용법은 <a href="https://developers.google.com/identity/sign-in/web/reference#users">구글문서</a>를 참고하면 된다.</p><p>SPA 프로젝트이기 때문에 비동기 방식으로 구글의 api 스크립트를 로딩하고 있다. 구글<strong> api가 완전히 로드되었는지 보장된 상태에서 진행하려면</strong> this.$gAuth.isLoaded()를 사용하면 된다. 깃헙문서에 샘플코드를 적어놓았으니 참고바란다.</p><h4>참고</h4><ul><li><a href="https://github.com/guruahn/vue-google-oauth2/blob/master/sample.html">sample login page HTML file</a></li><li><a href="https://developers.google.com/identity/sign-in/web/reference">sign-in web reference</a></li></ul><p>글이 좋았다면 <a href="https://www.paypal.me/guruahn">Buy me a coffee</a>! ☕</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=184c2859c78a" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[지난 1년 회고 — 프론트엔드 개발기]]></title>
            <link>https://medium.com/@jeongwooahn/%EC%A7%80%EB%82%9C-1%EB%85%84-%ED%9A%8C%EA%B3%A0-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EA%B8%B0-42e660951467?source=rss-3d75258a9bf8------2</link>
            <guid isPermaLink="false">https://medium.com/p/42e660951467</guid>
            <category><![CDATA[vuejs]]></category>
            <category><![CDATA[front-end-development]]></category>
            <category><![CDATA[javascript]]></category>
            <dc:creator><![CDATA[Jeong Woo Ahn]]></dc:creator>
            <pubDate>Mon, 01 Oct 2018 08:07:29 GMT</pubDate>
            <atom:updated>2018-10-11T12:08:42.763Z</atom:updated>
            <content:encoded><![CDATA[<p>얼마전 1년간 진행했던 프로젝트를 마무리 짓게되었다. 그래서 그 동안 배운것들을 정리해야겠다고 생각했다. 1년이라는 기간은 짧고도 길다. 지나고 보면 정말 찰나의 순간처럼 시간이 빠르게 흐르는것 같지만, 그 과정을 천천히 살펴보면 꽤 많은 것들을 할 수 있는 시간이기도 한것 같다.</p><p>조직과 서비스 차원에서도 할 얘기들이 많지만, 개발자 개인으로서 경험한 것들을 중심으로 얘기해보고자 한다.</p><h3>Vue.js</h3><p>Vue.js는 지난 1년동안 만들어온 서비스의 프론트엔드 프레임웤이었다. 이 프로젝트를 통해 처음 접해보았다. 그 전에 토이 프로젝트로 ReactJS를 다룬적은 있었다. 사실 내가 Vue.js를 하기로 선택한것은 아니다. 내가 입사했을 때에는 이미 기존 개발자가 Vue.js를 선택한 후 어느정도 사이트를 구축하기 시작한 단계(클로즈드 베타)였다. 내게 다른 프레임웤을 고민할 여지는 없었다. 그러나 지나고보니 전임자에게 잘한 선택이었다고 평가해주고 싶다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/967/1*k_q-2AePkWzczqTfuCsigw.jpeg" /></figure><p>Vue.js 는 ReactJS와 매우 비슷한 점이 많으면서도 ReactJS와는 구분되는 몇 가지 장점이 있다. 좀더 순수 HTML/CSS 코딩을 활용한 직관적인 템플릿을 제공하면서도, 순수 자바스크립트 만으로도 코딩할 수 있으며, UI 렌더링시 어느정도 자동으로 최적화를 해준다. 따라서 처음 도입할때 거부감이 적고 좀 더 쉽게 도입할 수 있다는 장점이 있다.(Vue.js : <a href="https://kr.vuejs.org/v2/guide/comparison.html">다른 프레임워크와의 비교</a>)</p><p>Vue.js는 ReactJS와 비교해서 개발자들의 생태계가 작다는 단점이 있다. 그러나 내 생각에는 JavaScript 에 대한 이해도가 높은 경우, 그것은 큰 문제가 아니다. 순수 자바스크립트로 만들어진 라이브러리를 Vue.js에 이식하는것은 어려운일이 아니다. 직접 플러그인이나 라이브러리를 제작하는 맛도 있다. 프로젝트 중간에 JavaScript 세미나도 진행했었는데, 뭔가 한 번 더 업그레이드 되는 느낌을 받았다. 좀 안다고 어렵고 응용적인 기술에 대해서만 공부하지 말고 기본 이론에 대해서도 가끔은 다시 학습하는것도 좋다.</p><p>아무튼 무슨 프레임웤을 개발 했느냐가 중요하다기 보다는 어떻게 개발했느냐가 더 중요하다. 그러나 지금 상황에서 다시 선택하라면 고민이 될것같다. 그냥 익숙한것이 장점이라면 장점이니까 Vue.js로 할것 같기도 하고 무조건 오래된 기술이라고 새로운것으로 바꾸는 것만이 능사도 아니고, 새로운 것을 선택하더라도 구성원들의 경험에 따라서 판단해야할 수도 있고 그러니까 무엇이 확실이 좋다라고 할만큼 우위의 차이가 없고 상황에 따라서 판단하는것이 좋을 것 같다.</p><h3>UI 라이브러리 제작</h3><p>작년(2017년) 12월쯤 <a href="https://medium.com/p/826a754a03a?source=your_stories_page---------------------------">OKKYCON강연(《소통, 개발에 숨을 불어넣다》</a>) 에 참가한적이 있었다. 이 강연에서 인상적이었던 발표중에 하나가 GS SHOP의 김요한 개발팀장님의 발표였다. 디자이너와 개발자들의 협업을 생산성있게 조직할 수 있는 방법에 대한 내용이었다. 요점은 React Sketch.app을 통한 디자인 시스템 개발이다. 디자이너와 개발자가 협업해서 코딩을 하면, 그것이 자동으로 sketch로 변환되고, 동시에 목업이 바로 만들어질 수 있다. 이 강연을 듣고나서 우리도 변화가 필요하다고 생각했다.</p><p>우리의 경우 디자이너 리소스가 부족한 상황에서 코딩까지 요구하기에는 무리가 있고 Sketch.app의 기술적인 한계도 있을거라고 판단했다. 하지만 UI 라이브러리 만으로도 협업과 생산성에 도움이 될거라고 판단하고 라이브러리 제작을 진행하기 시작했다.</p><p>우선 전체회의에서 디자이너가 라이브러리 필요성을 역설하는 발표를 했다. 아무래도 개발자와 디자이너의 리소스가 필요한 것이기 때문에 구성원들이 합의가 필요한 일이다. 장기적으로 투입한 리소스를 충분히 만회하고 팀 전체의 효율성도 높일거라는 것을 논리적으로 설명했다. 8개월 정도 지난 지금 그것이 옳았다는것을 우리는 강하게 느끼고 있다. UI 상의 오류가 많이 줄어들었고, 재활용 가능한 컴포넌트가 늘어감에 따라 생산성도 많이 늘어났다. 수치적으로 증명할 방법은 없다. 하지만 적어도 예전보다 UI나 기능의 변경에 대한 스트레스가 매우 적고 그것을 실행함에 있어서도 자신감도 매우 높아졌다.</p><p>수십개의 컴포넌트를 한꺼번에 설계해서 한번에 도입하는 방식이 아니라 점진적으로, 가장 필요한 것부터 하나씩 만들어 도입하는 방식으로 이루어졌다. 그리고 우리는 모든 UI의 추가/수정 등을 개발자와 디자이너가 함께 논의해서 결정하는것을 원칙으로 했다. 더불어 개방적이고 진취적인 디자이너와 구성원들의 적극적인 협조덕분에 안정적으로 도입할 수 있었고 지속적으로 업데이트 해나가고 있다.</p><h3>코드 리뷰</h3><p>내가 처음 이 프로젝트에 참가했을때, 한 동안은 배포때마다 밤 늦게까지 버그를 고치느라 야근을 하곤했다. 무언가를 수정하면 또 다른 버그가 생겨나는 악순환이 자주 연출되었다. 2주 마다 한 번 정도의 야근이니 가볍게 보거나 중요하지 않게 생각할 수도 있다. 그냥 시간이 흐르면 나아지겠지 라고 생각할 수 도 있고. 하지만 이런것이 반복되면 개발자들은 자신감이 떨어지고 수동적이고 방어적인 태도를 갖게된다. 이 상황이 극단적으로 강화되어 팀이 붕괴되는것도 본적이 있다. 이 시점에서는 이 악순환을 끊기 위한 작업을 다른 것보다 매우 중요한 작업으로 부상시켜야한다. 지금 회상해보면 이런 상황이 개선되기 시작한 것은 테스트코드와 리뷰를 하기 시작한 시점 부터인 것 같다. (물론 이것이 유일한 개선 요인은 아니었다)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*h-eSp8ffLv8TMOkCE_vE4A.jpeg" /></figure><p>10년 전에는 무엇을 배울때 책을 주로 참고했다. 하지만 요즈음은 책 말고도 배울 수 있는 소스가 많다. 코딩을 하다가 막히거나 내가 아는 지식으로 해결이 안되는 이슈가 있을때 그것을 해결한 라이브러리나 코드조각을 웹에서 찾은 다음, 그것을 하나하나 뜯어보면서 배운다. 좋은 코드는 어디에서나 쉽게 찾을 수 있다. (물론 나쁜 코드도 있다) 그런 코드를 보고 있자면 자신이 얼마나 부족한지 쉽게 깨달을 수 있다.</p><p>이것을 문장으로 표현하면 ‘코드로 코드배우기&#39;일 수 있겠다. 나는 이 과정이 팀내에서 좀 더 수월하고 더 적극적으로 하는것이 리뷰라고 생각한다. 그러니까 사실 개발자 각자는 저런 방식으로 스스로 학습하는것이 기본이다. 리뷰는 사실 그것의 부족한 점을 채우거나, 그런 습관을 유지하는데에 도움이되는 정도일 수 있다. 그리고 스스로 학습하는 것은 그 정도나 학습의 범위가 불균등하기 때문에 리뷰를 통해 그 불균등함이 해소될 수 있다.</p><p>경험이 적은 개발자는 이미 배우고자하는 열망이 많은 경우가 많이 때문에 기회만 주어지면 시간을 들여서 열심히 참여한다. 반대로 경험이 많은 개발자는 그런 열망이 적을 가능성이 높은데, 그럴경우 이런 리뷰를 진행하기가 매우 어렵다. 때문에 리뷰는 경험이 많은 개발자의 노력이 중요하다. 경험이 많은 개발자가 지식을 나누어야한다는 의미에서 노력이 중요하다고 말하는것이 아니다. 나는 경험에 무관하게 모든 개발자는 항상 배울것이 많다고 생각한다. 그러니까 다른 사람과 코드를 공유함으로서 본인이 많이 배울 수 있다는 생각이 중요하다. 그 공감대가 없다면 작게라도 시작해볼 것을 권유한다. 해보면 금방 알게될 것이다.</p><h3>테스트코드</h3><p>결론적으로 올초 부터 본격적으로 시작했고, 커버리지는 20%까지 올렸다. 그러니까 처음 본격적으로 테스트를 도입해본 것이다. 그래서 커버리지 올리는데 엄청 신경쓰지는 않았다. 물론 TDD도 아니다. 일단 테스트 코드를 짜고 있다는것에 의의를 두었고 다른 오픈소스의 잘 짜여진 테스트를 보면서 조금씩 배워나갔다.</p><p>이왕 할거면 최소한 20% 이상은 올려야 한다는 생각이 들었다. 실제로 A를 수정하고 테스트를 돌렸을때 예상하지 못했던 B의 버그를 발견할 수 있어야 하는데 커버리지가 20%정도 되었을때 이런 케이스를 발견하기 시작했다. 테스트코드의 장점은 더 많겠지만 나의 경우 가장 인상적인 장점은 두 가지이다.</p><ul><li>예상하지 못한 버그 미리 발견하기.</li><li>테스트하기 좋은 코드 만들기. TDD가 아니더라도 테스트를 염두하면서 코드를 작성하기 때문에 간결하고 명확하게 함수를 작성하게 된다.</li></ul><p>왠만한 서비스에서 테스트코드는 필수적이라는 생각을 했다. Vue.js와 같은 환경은 모듈화가 잘되어있고, 도구들도 많아 테스트코드를 작성하기에 아주 좋은 환경이다. 이제 그럴 수 있겠다는 자신감도 얻게되었다. 다양한 환경에서 다양한 방법으로 진행할 수 있을텐데 더 많이 배워야겠다.</p><h3>AB테스트</h3><p>AB테스트도 몇 차례 진행했다. <a href="https://tagmanager.google.com/">GTM</a> + <a href="https://analytics.google.com/analytics/web/">GA</a>+ <a href="https://optimize.google.com/">Optimize</a> 의 조합이었다. ga의 페이지 뷰나 이벤트를 Optimize에서 목표의 트리거로 사용할 수 있다. 2년 전쯤 구글 Analytics의 실험실에 있는 AB테스트 기능으로 진행한적이 있었다. 기능이 거의 똑같은걸로 봐서 Optimize라는 이름으로 구글이 서비스화 시킨듯하다. 실험실에 비해서는 상당히 발전했다. 내가 진행하는 테스트의 결과가 유의미한 것인지 판단하기 위해서는 사용자수와 통계치에 기반하여 별도로 계산했어야 했는데, 이제는 자동으로 계산해준다. 결과를 보여주는 보고서도 발전했다. 실험 타켓 수를 조정할 수 있다. 위험한 실험은 일부 사용자를 대상으로만 진행할 수 있다는 말이다. 서비스의 머스트해브가 분명하고, 성장하고 있다면 핵심기능에 대해서 도입을 꼭 권유하고 싶은 마음이다. 위 조합으로 Vue.js 에서도 쉽게 구현해볼 수 있다.</p><h3>마치며</h3><p>앞으로 새로운 프로젝트에 뛰어들 준비를 하고 있다. 서비스와 개발자가 모두 성장하는 프로젝트가 될 수 있을거라는 기대감과 동시에 설렘과 긴장감이 느껴지는 날들이다. 앞으로는 서비스에 대한 이야기도 이곳에서 하고 싶다는 마음이 일고 있다. 그렇게 할 수 있을지는 모르지만.</p><h4>참고</h4><ul><li>Vue.js : <a href="https://kr.vuejs.org/v2/guide/comparison.html">다른 프레임워크와의 비교</a></li><li><a href="https://joshua1988.github.io/web_dev/vue-or-react/">React인가 Vue인가</a></li><li><a href="https://medium.com/p/826a754a03a?source=your_stories_page---------------------------">OKKYCON강연《소통, 개발에 숨을 불어넣다》</a></li></ul><p>글이 좋았다면 <a href="https://www.paypal.me/guruahn">Buy me a coffee</a>! ☕</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=42e660951467" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vue.js 양방향 데이터 바인딩 활용 : 모달(레이어팝업) 컴포넌트 만들기를 통하여 알아보기(.sync)]]></title>
            <link>https://medium.com/@jeongwooahn/vue-js-%EC%96%91%EB%B0%A9%ED%96%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B0%94%EC%9D%B8%EB%94%A9-%ED%99%9C%EC%9A%A9-%EB%AA%A8%EB%8B%AC-%EB%A0%88%EC%9D%B4%EC%96%B4%ED%8C%9D%EC%97%85-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0%EB%A5%BC-%ED%86%B5%ED%95%98%EC%97%AC-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-sync-4e2a5cf70dc4?source=rss-3d75258a9bf8------2</link>
            <guid isPermaLink="false">https://medium.com/p/4e2a5cf70dc4</guid>
            <category><![CDATA[modal]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[vuejs]]></category>
            <category><![CDATA[양방향데이터바인딩]]></category>
            <dc:creator><![CDATA[Jeong Woo Ahn]]></dc:creator>
            <pubDate>Fri, 31 Aug 2018 06:17:41 GMT</pubDate>
            <atom:updated>2018-10-11T12:11:37.864Z</atom:updated>
            <content:encoded><![CDATA[<p>모달(레이어 팝업)이 뭐 별거 있겠냐고 생각될 수 있지만, vue.js에서 자유롭게 모달을 열고 닫는 로직을 구현하는게 생각보다는 단순하지 않다. 그 해법이 양방향 데이터 바인딩이다. 그리고 양방향 데이터 바인딩은 조심스럽게 사용해야하고 잘 이해하고 있어야 하는데, 모달을 제작하는 과정에서 그것을 잘 배울 수 있다. 내가 사용하는 방법을 정리해보고자 한다.</p><p>상황 : parent 컴포넌트가 있다. parent는 my-modal이라는 자식 컴포넌트를 가지고 있다. my-modal 컴포넌트는 모달이다. parent 와 모달의 관계는 부모자식 관계이기 때문에 visible이라는 props를 이용하여 모달을 띄우고 닫을 수 있을거라고 생각할 수 있다.</p><p>일단 심플한 모달을 하나 만들어보자.</p><p>my-modal.vue</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/dca1e769373f160fadbf5eadaf59191c/href">https://medium.com/media/dca1e769373f160fadbf5eadaf59191c/href</a></iframe><p>visible값을 props로 모달에게 전달하여 모달을 띄우거나 닫을 수 있다. 이제 모달을 띄우는 parent 컴포넌트를 만들어보자.</p><p>parent.vue</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9118022436fe3d3eb18abc2ace243cca/href">https://medium.com/media/9118022436fe3d3eb18abc2ace243cca/href</a></iframe><p>자 문제없이 모달이 잘 열린다. 이제 모달 헤더에 닫기 버튼을 넣고자 한다. <strong>그런데 visible은 props로 전달되므로 자식 내부에서 전달 받은 props를 변경하는건 문제가 있다.</strong> 모달전용 내부 변수를 만들어서 모달을 닫았다고 하더라도 부모가 현재 모달의 상태를 알 수 없다는 문제가 남는다.</p><h3>문제1 : 모달 컴포넌트 내부에서 모달 자신을 닫을 수 있어야 한다. 그리고 부모가 모달의 상태를 알고 있어야 한다.</h3><p>parent가 close()함수를 직접 작성하여 my-modal에게 전달하는 방법이 있는데, 번거롭다. 어디선가 my-modal을 사용할때마다 닫기함수를 위한 로직을 구현해야한다. 그러면 컴포넌트의 재활용성이 떨어진다.</p><p><strong>해법</strong> : <a href="https://kr.vuejs.org/v2/guide/components.html#sync-%EC%88%98%EC%8B%9D%EC%96%B4">양방향 데이터 바인딩 .sync</a></p><p>양방향 데이터 바인딩은 남용해서는 안된다. 이것때문에 2.0에서 sync가 삭제되었지만 2.2에서 다시 추가되었다. 재사용 가능한 컴포넌트에서 유용하다고 판단했기 때문이다.</p><p>.sync는 my-modal과 같이 잘 설계된, 재사용 가능한 컴포넌트에서 유용하게 쓰일 수 있다. 이제 .sync를 사용할 수 있도록 my-modal을 수정해보자.</p><p>my-modal.vue</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/b02b8d2ebfcc8f671c9f20d2bc4ab3c3/href">https://medium.com/media/b02b8d2ebfcc8f671c9f20d2bc4ab3c3/href</a></iframe><p>this.$emit(&#39;update:visible&#39;, false) 코드가 추가되었다. 이제 모달 바깥을 클릭해서 모달을 닫는 동작도 쉽게 구현할 수 있게 되었다.</p><p>부모에서는 이렇게 사용하면 된다.</p><p>parent.vue</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e11d83d398b7ccff908084023abaf6b1/href">https://medium.com/media/e11d83d398b7ccff908084023abaf6b1/href</a></iframe><p>트랜지션등 몇 가지 스타일을 더 작성하면 남부럽지 않은 모달을 만들 수 있게 되었다. 부모 단계에서 vuex를 활용하면, 좀 더 범용적으로 컨트롤 될 수 있는 모달을 구현해볼 수도 있다.</p><p>이렇게 짜임새 있고 심플한 컴포넌트를 제작하고, 빈틈없는 테스트코드까지 완성하면 기분이 절로 좋아진다. 다른 개발자들을 위한 다양한 옵션을 추가하고 문서까지 만든다면 금상첨화.</p><p>글이 좋았다면 <a href="https://www.paypal.me/guruahn">Buy me a coffee</a>! ☕</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4e2a5cf70dc4" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>