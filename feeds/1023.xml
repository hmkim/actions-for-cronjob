<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FELog</title>
  
  <subtitle>FrontEnd Engineer, Jbee&#39;s blog</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://jaeyeophan.github.io/"/>
  <updated>2019-01-04T09:49:58.055Z</updated>
  <id>https://jaeyeophan.github.io/</id>
  
  <author>
    <name>Jbee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Vuetorials] 7. Vuex Best Practice로 가는 여정</title>
    <link href="https://jaeyeophan.github.io/2018/11/17/Vuetorials-7-Vuex-Best-Practice/"/>
    <id>https://jaeyeophan.github.io/2018/11/17/Vuetorials-7-Vuex-Best-Practice/</id>
    <published>2018-11-17T08:09:44.000Z</published>
    <updated>2019-01-04T09:49:58.055Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vuetorials.png" alt=""></p><h1 id="Vuex-Best-Practice로-가는-여정"><a href="#Vuex-Best-Practice로-가는-여정" class="headerlink" title="Vuex Best Practice로 가는 여정"></a>Vuex Best Practice로 가는 여정</h1><p>Vuex에 대한 설명은 다음 두 글을 첨부함.</p><ul><li><a href="https://jaeyeophan.github.io/2018/11/07/Vuetorials-5-Vuex/">5. Vuex API</a></li><li><a href="https://jaeyeophan.github.io/2018/11/16/Vuetorials-6-Vuex-Module-pattern/">6. Vuex Module pattern</a></li></ul><p>진행하고 있는 프로젝트에서 Vuex를 어떻게 하면 잘 사용할 수 있을까 고민을 했고 그 과정을 기록함. 총 다섯 단계로 나누어져 있음.</p><p>관전 포인트는 다음과 같음.</p><ul><li>String을 덜 사용할 수는 없는가?<ul><li>오류 발생가능성을 낮추기 위해</li></ul></li><li>생산성이 좋은가?</li><li>가독성이 좋은가?</li><li>유지보수에는 적절한가?</li></ul><p>예제 코드는 실제 product 코드 대신 Todo application 예제를 사용함. <a href="https://github.com/JaeYeopHan/vuex-best-practice-lab/pull/1/files" target="_blank" rel="noopener">refactoring pull request</a></p><blockquote><p>Let’s Refactoring 🚧</p></blockquote><h2 id="Step-1-module-pattern-with-namespace"><a href="#Step-1-module-pattern-with-namespace" class="headerlink" title="Step 1. module pattern with namespace"></a>Step 1. module pattern with namespace</h2><p>Vuex에서 관리하게 되는 상태가 커지면 커질수록 <code>state</code>, <code>action</code>, <code>mutation</code> 관리가 제대로 이뤄지지 않음. 그렇기 때문에 Vuex 공식 문서에서도 <strong>module</strong>이란 것을 소개하고 있음. 또한 Vuex에서는 <code>namespaced</code>라는 아주 훌륭한 API를 지원하고 있기 때문에 여기까지는 대부분의 Vue application에서는 적용하고 있을 것 같음.</p><figure class="highlight js"><figcaption><span>@/store/modules/todos/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    todos,</span><br><span class="line">    <span class="comment">// other modules...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>@/store/modules/todos/</code> directory 밑에 각각 <code>state.js</code>, <code>getters.js</code>, <code>mutations.js</code>, <code>actions.js</code>를 만들어두고 <code>todos/index.js</code>에서 <code>namespaced: true</code>로 export 해줌.</p><p>컴포넌트에서 Vuex는 다음과 같이 사용할 수 있음.</p><figure class="highlight js"><figcaption><span>todo.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// state</span></span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    allItems: <span class="keyword">this</span>.$store.state.todos.items,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// getters</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  doneItems() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters[<span class="string">"todos/doneItems"</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">  activeItems() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters[<span class="string">"todos/activeItems"</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// actions</span></span><br><span class="line">method: &#123;</span><br><span class="line">  addItem() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(<span class="string">"todos/addItem"</span>, &#123; newItem &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실제 product 코드에서는 state, getter 등이 크지 않으면 <code>index.js</code> 에서 전부 처리하고 분리가 필요한 부분만 분리하여 작성하고 있음.</p><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem!"></a>Problem!</h3><ul><li>안 그래도 <code>.</code> 이 깊어지는 코드인데 <code>todos</code> 라는 <strong>namespace가 추가</strong>되면서 한 depth 또 추가됨.</li><li>Vuex에 정의된 모든 state, getters, actions에 접근이 가능함.</li><li>만약 <code>todos</code> 라는 namespace가 변경된다면…?</li><li><code>doneItems</code>, <code>addItem</code> 등등의 이름이 변경된다면…?</li></ul><p><strong>끔찍함.</strong> 위와 같은 이유로 1번은 고려하지 않음. (사실 난 중복된 string을 가만히 볼 수 없는 병에 걸려있음.)</p><h2 id="Step-2-Binding-helpers"><a href="#Step-2-Binding-helpers" class="headerlink" title="Step 2. Binding helpers"></a>Step 2. Binding helpers</h2><p>이 부분도 Vuex 공식 문서에서 나옴. 보통 <code>react-redux</code>, <code>mobx-react</code> 이런 라이브러리에서 제공하는 기능인데 Vuex에서는 자체적으로 제공함. 근데 이 helper API가 일관성이 없는게 문제임. 그리고 namespace가 들어가게 되면 작업이 추가됨.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions, mapState, mapGetters &#125; <span class="keyword">from</span> <span class="string">"vuex"</span>;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(<span class="string">"todos"</span>, &#123;</span><br><span class="line">    allItems: <span class="function">(<span class="params">&#123; items &#125;</span>) =&gt;</span> items,</span><br><span class="line">  &#125;),</span><br><span class="line">  ...mapGetters(<span class="string">"todos"</span>, &#123;</span><br><span class="line">  doneItems: <span class="string">"doneItems"</span>,</span><br><span class="line">  activeItems: <span class="string">"activeItems"</span></span><br><span class="line">&#125;),</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions(<span class="string">"todos"</span>, [</span><br><span class="line">    <span class="string">"addItem"</span>,</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>바인딩을 해줄 때, 첫번째 인자로 namespace를 추가해줘야 함. (namespace가 별도로 존재하지 않을 경우 바로 binding 객체를 넣어줌.)</p><h3 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem!"></a>Problem!</h3><ul><li>Step 1의 2번 3번 문제점과 동일</li></ul><p>이 binding helper는 depth를 줄이는 데에는 성공적이지만 아직 string 중복 처리는 이뤄지지 않음.</p><h2 id="Step-3-binding-시-사용되는-namespace를-제거하자"><a href="#Step-3-binding-시-사용되는-namespace를-제거하자" class="headerlink" title="Step 3. binding 시 사용되는 namespace를 제거하자."></a>Step 3. binding 시 사용되는 namespace를 제거하자.</h2><p>Vuex에서 제공하는 <a href="https://github.com/vuejs/vuex/blob/dev/src/helpers.js#L117" target="_blank" rel="noopener">createNamespacedHelpers</a>란 API를 사용할 수 있음,</p><figure class="highlight js"><figcaption><span>@/store/modules/todos/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span><span class="string">"vuex"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NAMESPACE &#125; <span class="keyword">from</span> <span class="string">"./types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; mapState, mapGetters, mapActions &#125; = createNamespacedHelpers(NAMESPACE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; mapState, mapGetters, mapActions &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; <span class="comment">/* namespaced, state, getters, mutations, actions */</span> &#125;</span><br></pre></td></tr></table></figure><p>컴포넌트에서 바로 정의해서 사용해도 되지만 store 단에서 정의하고 export 함. 컴포넌트 단에서 <code>NAMESPACE</code>를 import할 필요는 없다는 판단하에 진행함. 이렇게 정의해두고 이 namespace를 추가한 helper binding 함수를 사용하자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import &#123; mapActions, mapState, mapGetters &#125; from "vuex";</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapActions, mapState, mapGetters &#125; <span class="keyword">from</span> <span class="string">"@/store/modules/todos"</span>;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    allItems: <span class="function">(<span class="params">&#123; items &#125;</span>) =&gt;</span> items,</span><br><span class="line">  &#125;),</span><br><span class="line">  ...mapGetters(&#123;</span><br><span class="line">  doneItems: <span class="string">"doneItems"</span>,</span><br><span class="line">  activeItems: <span class="string">"activeItems"</span></span><br><span class="line">&#125;),</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions([</span><br><span class="line">    <span class="string">"addItem"</span>,</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>namespace 중복을 제거했음. 아직 Step 1의 3번 문제점이었던 constant들이 남아있음.</p><h2 id="Step-4-Extract-constant-in-action"><a href="#Step-4-Extract-constant-in-action" class="headerlink" title="Step 4. Extract constant in action"></a>Step 4. Extract constant in action</h2><p>Vuex 코드를 작성하다보면 <code>action</code>과 <code>mutation</code> 에서 많은 중복이 발생함. <code>mutation</code>에서 정의한 것을 그대로 <code>action</code> 에서 <code>commit</code> 해줘야 하기 때문임. (그렇다고 컴포넌트에서 commit 하면 안 됨… <a href="https://jaeyeophan.github.io/2018/11/07/Vuetorials-5-Vuex/#mutations">참고</a>) 그래서 이 부분을 상수로 추출고 이를 공통으로 사용할 수 있음.</p><p>일단 <code>action</code>과 <code>mutation</code>에서 사용되는 type을 별도 파일로 분리하자.</p><figure class="highlight js"><figcaption><span>@/store/module/todos/types.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// namespace</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NAMESPACE = <span class="string">"todos"</span>;</span><br><span class="line"><span class="comment">// actions</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_ITEM = <span class="string">"ADD_ITEM"</span>;</span><br></pre></td></tr></table></figure><p>이에 따라 정의한 <code>mutation.js</code>와 <code>actions.js</code>도 변경됨.</p><figure class="highlight js"><figcaption><span>@/store/mdules/todos/mutations.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">"./types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  [actions.ADD_ITEM](state, newItem) &#123;</span><br><span class="line">    state.items.push(newItem);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>@/store/mdules/todos/actions.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">"./types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  [actions.ADD_ITEM](&#123; commit &#125;, payload) &#123;</span><br><span class="line">    commit(actions.ADD_ITEM, payload.newItem);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 이 constant를 컴포넌트에서도 사용하자.</p><figure class="highlight js"><figcaption><span>todo.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions, mapState, mapGetters &#125; <span class="keyword">from</span> <span class="string">"@/store/modules/todos"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">"@/store/modules/todos/action-types"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      actions.ADD_ITEM,</span><br><span class="line">    ]),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Step-5-Extract-constant-in-getters"><a href="#Step-5-Extract-constant-in-getters" class="headerlink" title="Step 5. Extract constant in getters"></a>Step 5. Extract constant in getters</h2><p>나와 같은 병에 걸렸다면 <code>getters</code>에서의 중복도 불편할 것이라 생각됨. 이제 getters의 상수를 제거하자.</p><figure class="highlight js"><figcaption><span>@/store/mdules/todos/getters.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DONE_ITEMS = <span class="string">"DONE_ITEMS"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ACTIVE_ITEMS = <span class="string">"ACTIVE_ITEMS"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  [DONE_ITEMS]: <span class="function"><span class="params">state</span> =&gt;</span> state.items.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.isDone),</span><br><span class="line">  [ACTIVE_ITEMS]: <span class="function"><span class="params">state</span> =&gt;</span> state.items.filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.isDone)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>컴포넌트에서 getters를 바인딩하자.</p><figure class="highlight js"><figcaption><span>todo.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> getters <span class="keyword">from</span> <span class="string">"@/store/modules/todos/getters"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      allItems: <span class="function">(<span class="params">&#123; items &#125;</span>) =&gt;</span> items,</span><br><span class="line">    &#125;),</span><br><span class="line">    ...mapGetters(&#123;</span><br><span class="line">      doneItems: getter.DONE_ITEMS,</span><br><span class="line">      activeItems: getter.ACTIVE_ITEMS,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사실 이 getters는 이렇게도 표현 가능함. (as <code>mapActions</code>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...mapGetters([</span><br><span class="line">  getter.DONE_ITEMS,</span><br><span class="line">  getter.ACTIVE_ITEMS,</span><br><span class="line">]),</span><br></pre></td></tr></table></figure><p><code>getters</code>는 컴포넌트에서 <strong>값</strong>으로 사용되기 때문에 <code>doneItems</code>와 <code>activeItems</code>로 다시 mapping 시킴. 이게 더 깔끔해 보임. (물론 개취의 문제일 수도)<br><code>getters</code>와 <code>actions</code>를 전부 상수로 binding 했음. 이제 컴포넌트에서는 <code>this.doneItems</code> 이렇게 getter에 접근할 수 있고 <code>this[actions.ADD_ITEM]()</code> 이렇게 action에 접근할 수 있음.</p><blockquote><p>Vuex 코드를 작성하면서 발생한 문제점들을 어느정도 해결했음. :tada:</p></blockquote><h3 id="JFYI"><a href="#JFYI" class="headerlink" title="JFYI"></a>JFYI</h3><p>사실 원래 <code>getters</code>의 key값도 <code>types.js</code>에서 관리를 하려고 했으나</p><ol><li>컴포넌트 단에서 상수를 사용할 때, getters의 key값인지 action type인지 구분되지 않음.</li><li><code>getters</code>의 key 값은 <code>getters</code>에서만 사용하므로 굳이 <code>types.js</code>에 위치할 필요가 없음.</li></ol><p><code>getters.js</code> 내부에서 상수로 분리 후 export 함. 그리고 <code>getters</code>로 <code>* as</code> 하면 action type과 구분지을 수 있음.</p><h2 id="Remained-Task"><a href="#Remained-Task" class="headerlink" title="Remained Task"></a>Remained Task</h2><h3 id="1-여러-modules-바인딩"><a href="#1-여러-modules-바인딩" class="headerlink" title="1. 여러 modules 바인딩"></a>1. 여러 modules 바인딩</h3><p>한 컴포넌트에서 두 개 이상의 modules에 있는 action, getters 등을 바인딩해야 할 경우가 발생할 수 있음. 이렇게 되면 <code>mapActions</code>로 import할 수 없음. (name 충돌)</p><figure class="highlight js"><figcaption><span>my-component.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions <span class="keyword">as</span> mapActionsOfTodo &#125; <span class="keyword">from</span> <span class="string">'@/store/todo'</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapActiosn <span class="keyword">as</span> mapActiosnOfFilters &#125; <span class="keyword">from</span> <span class="string">'@store/filter'</span></span><br></pre></td></tr></table></figure><p>이럴 경우, 이렇게 <code>as</code>를 통해 <code>Of-*</code> suffix로 사용할 수 있음. 또는,</p><figure class="highlight js"><figcaption><span>my-component.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> todo <span class="keyword">from</span> <span class="string">'@store/todo'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    todo.mapState(&#123; ... &#125;),</span><br><span class="line">    todo.mapGetters(&#123; ... &#125;),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 <code>todo</code>로 묶어서 import 한 후 사용할 수 있음. 개인적으로는 두번째 방법을 사용하고 있음.</p><h3 id="2-통일되지-않은-API-형태"><a href="#2-통일되지-않은-API-형태" class="headerlink" title="2. 통일되지 않은 API 형태"></a>2. 통일되지 않은 API 형태</h3><p><code>mapState({ ... })</code>, <code>mapGetters({ ... })</code>는 <code>{}</code>로 받고 <code>mapActions([ ... ])</code>는 <code>[]</code>로 받는다. 같은 binding helper인데 일관성이 없음. 이 부분을 해결하기 위해 mapAction을 <code>{}</code>하면 다음과 같음.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  ...mapAction(&#123;</span><br><span class="line">    addNewItem: actions.ADD_ITEM,</span><br><span class="line">  &#125;),</span><br><span class="line">  addItem() &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">this</span>.addNewITem(newItem);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이게 더 좋은 것인지는 아직 잘 모르겠으나. <code>this[ADD_ITEM]</code> 형식을 사용하고 있음.</p><h3 id="3-Nested-Modules-namespace"><a href="#3-Nested-Modules-namespace" class="headerlink" title="3. Nested Modules namespace"></a>3. Nested Modules namespace</h3><p>child module에서 parent module의 namespace 상수를 import하여 <code>createNamespaceHelpers</code>에 넘겨줄 namespace를 지정해주려고 했는데, 에러가 발생함. 아직 원인을 모르겠음. 보다 자세한 내용은 <a href="https://github.com/JaeYeopHan/tip-archive/issues/35" target="_blank" rel="noopener">Vuex nested modules createNamespaceHelpers Issue</a>를 참고.</p><h2 id="Final-Step-Seperate-action-type-and-mutation-type"><a href="#Final-Step-Seperate-action-type-and-mutation-type" class="headerlink" title="Final Step. Seperate action type and mutation type"></a>Final Step. Seperate action type and mutation type</h2><p>Vuex를 계속 사용하다보니 컴포넌트에 노출되어야 하는 타입은 action type 뿐임. 또한 action에서 정의되는 type의 의미와 mutation에서 사용하는 type의 의미가 명확히 다름. 그래서 이 둘을 분리하기로 함. 분리를 하다보니 <code>types.js</code>라는 파일을 별도로 둘 필요가 없음. 컴포넌트에 노출되는 것은 action type만 노출되며 mutation type은 action에서 가져와 사용하는 방식을 취함.</p><figure class="highlight js"><figcaption><span>modules/actions.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> mutations <span class="keyword">from</span> <span class="string">'./mutations'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_TODO = <span class="string">'ADD_TODO'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  [ADD_TODO] (&#123; commit &#125;, payload) &#123;</span><br><span class="line">    commit(mutations.SET_NEW_ITEM, payload)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>modules/mutations.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_NEW_ITEM = <span class="string">'SET_NEW_ITEM'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  [SET_NEW_ITEM] (state, payload) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">item</span>: newItem &#125; = payload</span><br><span class="line">    state.items.push(newItem);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 두니 <code>actions.js</code>에서 action type이 정의되고 <code>mutations.js</code>에서 mutation type이 정의되고 getter type은 <code>getters.js</code>에서 정의되니 그 의미가 더욱 명확해졌음. 기존에 괜히 <code>types.js</code>에서 정의되고 있던 <code>NAMESPACE</code>는 <code>module/index.js</code>에서 관리하게 됨.</p><figure class="highlight js"><figcaption><span>module/indes.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">'./actions'</span></span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">'./mutations'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NAMESPACE = <span class="string">'todo'</span></span><br><span class="line"><span class="keyword">const</span> &#123; mapState, mapGetters, mapActions &#125; = createNamespacedHelpers(NAMESPACE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; mapState, mapGetters, mapActions &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespaced: <span class="literal">true</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  actions,</span><br><span class="line">  mutations,</span><br><span class="line">  getters,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScript의 <code>export</code>와 <code>export default</code>를 활용하여 보다 깔끔한 코드를 작성할 수 있음. Vuex의 모듈을 세 파일로 정의하게 됨. 이 상태들을 컴포넌트에서는 다음과 같이 사용할 수 있음.</p><figure class="highlight js"><figcaption><span>my-component.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> todoStore <span class="keyword">from</span> <span class="string">'@/store/todo'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> todoActions <span class="keyword">from</span> <span class="string">'@/store/todo'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> todoGetters <span class="keyword">from</span> <span class="string">'@/store/todo/getters'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...todoStore.mapGetters(&#123;</span><br><span class="line">      getItems: todoGetters.GET_ITEMS,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...todoStore.mapActions([</span><br><span class="line">      todoActions.ADD_ITEM,</span><br><span class="line">    ]),</span><br><span class="line">    onClick() &#123;</span><br><span class="line">      <span class="keyword">this</span>[todoActions.ADD_ITEM]</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컴포넌트 단에서 <code>NAMESPACE</code>를 전혀 모른 상태에서 올바른 상태값을 가져다 사용할 수 있고 <code>string</code>을 남발하지 않고 중복을 줄여가며 올바른 상태값을 매핑(mapping)할 수 있게 되었다.</p><h2 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h2><p>애플리케이션의 상태는 크게 두 가지로 나눌 수 있음. 도메인 영역과 UI의 상태. 이 두 가지가 하나의 모듈 안에서 구분없이 관리가 된다면 나중에 헬파티가 열림. 그래서 현재 프로젝트에서는 UI상태를 <code>view</code>로 감싸서 관리하고 있음.</p><p><em>example</em></p><figure class="highlight js"><figcaption><span>@/store/todo/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [ ... ],</span><br><span class="line">    views: &#123;</span><br><span class="line">      isPopupOpen: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 식으로 UI와 관련된 상태는 따로 <code>views</code>로 묶어 구분지어 주고 있음.</p><h2 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h2><h3 id="In-Vuex"><a href="#In-Vuex" class="headerlink" title="In Vuex"></a>In Vuex</h3><ul><li>상태 트리를 설계할 때, 기본적으로 <code>namespaced: true</code>로 진행.</li><li>디렉토리 이름과 namespace를 통일.</li><li>UI 상태와 도메인 상태 구분지어서 관리.</li><li>바인딩 헬퍼는 <code>createNamespacedHelpers</code>로 custom하여 사용.<ul><li>생성된 binding helper들을 <code>export { ... }</code>로 컴포넌트에 노출.</li><li>이를 노출하는 <code>index.js</code>에서 <code>NAMESPACE</code>를 정의.</li></ul></li><li>action, mutation, getter 의 각 타입들은 각 파일에서 정의.<ul><li>action에서 필요한 mutation type들은 <code>import * as mutations from &#39;./mutations</code>로 가져와 사용.</li></ul></li></ul><h3 id="In-Component"><a href="#In-Component" class="headerlink" title="In Component"></a>In Component</h3><p>최대 다음 세 가지를 import 하여 Vuex와 mapping 할 수 있음.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> [MODULE_NAME]Store <span class="keyword">from</span> <span class="string">'@/store/[MODULE_NAME]'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> [MODULE_NAME]Actions <span class="keyword">from</span> <span class="string">'@/store/[MODULE_NAME]'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> [MODULE_NAME]Getters <span class="keyword">from</span> <span class="string">'@/store/[MODULE_NAME]/getters'</span></span><br></pre></td></tr></table></figure><ul><li>state) arrow function + destructuring으로 분해해서 binding.<ul><li><code>...[MODULE_NAME]Store.mapState({ ... })</code></li><li><code>({ items }) =&gt; items</code></li><li>use: <code>this.items</code></li></ul></li><li>getter) <code>{ ... }</code>에 binding.<ul><li><code>...[MODULE_NAME]Store.mapGetters({ ... })</code><ul><li><code>{ key: todoGetters.[GETTER_TYPE] }</code></li><li>use: <code>this.[key]</code></li></ul></li></ul></li><li>action), <code>[...]</code>에 binding.<ul><li><code>...[MODULE_NAME]Store.mapActions([ ... ])</code></li><li><code>[ todoActions.ACTION_TYPE ]</code></li><li>use: <code>this[todoActions.ACTION_TYPE]</code></li></ul></li></ul><p>더 좋은 방법이 있다면 피드백 부탁드립니다 :)<br>관련 코드는 <a href="https://github.com/JaeYeopHan/vuex-best-practice-lab" target="_blank" rel="noopener">Vuex best practice GitHub Repository</a>에서 확인 가능합니다.</p><p><em>감사합니다.</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vuetorials.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Vuex-Best-Practice로-가는-여정&quot;&gt;&lt;a href=&quot;#Vuex-Best-Practice로-가는-여정&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Vue" scheme="https://jaeyeophan.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jaeyeophan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>[Vuetorials] 6. Vuex Module pattern</title>
    <link href="https://jaeyeophan.github.io/2018/11/16/Vuetorials-6-Vuex-Module-pattern/"/>
    <id>https://jaeyeophan.github.io/2018/11/16/Vuetorials-6-Vuex-Module-pattern/</id>
    <published>2018-11-16T00:47:02.000Z</published>
    <updated>2018-11-17T09:11:47.447Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vuetorials.png" alt=""></p><h1 id="Vuetorials-6-Vuex-Module-pattern"><a href="#Vuetorials-6-Vuex-Module-pattern" class="headerlink" title="[Vuetorials] 6. Vuex Module pattern"></a>[Vuetorials] 6. Vuex Module pattern</h1><h2 id="구조"><a href="#구조" class="headerlink" title="구조"></a><a href="https://vuex.vuejs.org/guide/structure.html" target="_blank" rel="noopener">구조</a></h2><p>Vuex 를 구성할 때 <code>action</code>, <code>mutation</code>, <code>getter</code> 이런 식으로 나누거나 각각의 module 을 기준으로 나눠 <code>index.js</code>에서 세 가지를 모두 기술할 수 있음. <code>modules</code>를 나눠 구성하는 경우 root 에서 사용하는 <code>action</code>과 <code>mutation</code>을 분리할 수 있음. <code>action</code>과 <code>mutation</code>은 <strong>actionType 을 공유</strong>하기 때문에 <code>types.js</code>로 별도 관리하기도 함.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">└── store</span><br><span class="line">    ├── index.js          # where we &apos;assemble&apos; modules and export the store</span><br><span class="line">    ├── actions.js        # root actions</span><br><span class="line">    ├── mutations.js      # root mutations</span><br><span class="line">    └── modules</span><br><span class="line">        ├── A             # A module</span><br><span class="line">        │   ├── index.js</span><br><span class="line">        │   └── types.js</span><br><span class="line">        └── B             # B module</span><br><span class="line">            ├── index.js</span><br><span class="line">            └── types.js</span><br></pre></td></tr></table></figure><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a><a href="https://vuex.vuejs.org/guide/modules.html" target="_blank" rel="noopener">Modules</a></h2><p>각각을 <code>modules</code>로 작성할 경우 다음과 같이 작성할 수 있음.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  key: &#123;</span><br><span class="line">    state: <span class="built_in">Object</span>,</span><br><span class="line">    namespaced?: <span class="built_in">Boolean</span>,</span><br><span class="line">    mutations?: <span class="built_in">Object</span>,</span><br><span class="line">    actions?: <span class="built_in">Object</span>,</span><br><span class="line">    getters?: <span class="built_in">Object</span>,</span><br><span class="line">    modules?: Module</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다른 것은 이전 포스팅에서 다 다룬 내용이고 <code>namespaced</code>라는 것이 있음.</p><h4 id="namespaced"><a href="#namespaced" class="headerlink" title="namespaced"></a>namespaced</h4><p>기본적으로 모듈에서 작성된 action, mutation, getter 들은 global namespace 에 등록됨. 이 때 <code>namespaced: true</code>로 지정을 해주면 <strong>해당 모듈의 namespace 로 제한됨.</strong> (완전 매력있는 API임.) 이 기능과 action type을 상수로 분리하여 작성을 했다면 한 가지 추가 작업이 더 필요함. 다음의 경우를 보자.</p><figure class="highlight js"><figcaption><span>todos/type.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_ITEM = <span class="string">'ADD_ITEM'</span></span><br></pre></td></tr></table></figure><p>이 action type을 action과 mutation과 <code>mapActions</code>해주는 곳에서 같이 사용한다고 가정했을 때,</p><figure class="highlight js"><figcaption><span>todos/actions.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  [ADD_ITEM](&#123; commit &#125;, payload) &#123;</span><br><span class="line">    commit(ADD_ITEM, payload.newItem);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>todos/mutations.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  [ADD_ITEM](state, newItem) &#123;</span><br><span class="line">    state.items.push(newItem);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vuex에서 바로 제공되는 <code>mapActions</code> helper를 바로 쓸 수 없음. namespace를 넣어줘야 함. 이 namespace는 module에 등록했을 때의 key 값이 됨.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions(<span class="string">"todos"</span>, [ ADD_ITEM ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 경우 저 액션은 <code>todos/ADD_ITEM</code>이 됨. 개인적으로는 <code>createNamespacedHelpers</code>를 쓰는 게 더 좋아보임.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import &#123; mapActions &#125; from 'vuex'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; mapActions &#125; = createNamespacedHelpers(<span class="string">"todos"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([ ADD_ITEM ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 modules에서 정의한 <strong>namespace로 한 번 wrapping 후</strong> <code>mapActions</code>로 binding 해야 함. 이렇게 해주면 action type에 자동으로 <code>todos</code>라는 namespace가 추가됨.</p><h4 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h4><p>중첩 모듈 작성이 가능함. <code>module</code> 내부에 트리 형식으로 또 <code>module</code>을 등록할 수 있음. 이 경우에도 <code>namespaced</code>를 지정해주면 <code>namespace</code>가 중첩되어 접근할 수 있음. namespace 중복은 <code>/</code>으로 중첩됨. (<a href="https://github.com/vuejs/vuex/blob/dev/src/module/module-collection.js#L16" target="_blank" rel="noopener">관련 코드</a>)</p><h3 id="그-외"><a href="#그-외" class="headerlink" title="그 외"></a>그 외</h3><ul><li>Vuex 생성자에 <code>strict: true</code>로 지정하면 <code>mutations</code>이외에 상태 변이에서 에러를 발생시킬 수 있음.</li><li><code>Vuex.Store</code>에서 제공하고 있는 API 가 여럿 있음. <code>subscribe</code>, <code>registerModule</code> 등. 활용하면 좋은 기능을 추가할 수 있을 것 같다는 막연한 생각.</li></ul><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p><code>redux</code>, <code>mobx</code>, <code>mobx-state-tree</code> 등의 상태 관리 라이브러리가 많음. <code>mutation</code>이란 부분은 MobX 와 비슷하고 트리 형식으로 구성하는 것은 MST 와 비슷하고 action 을 dispatch 하는 부분에 있어서는 redux 와 비슷한 듯. 그리고 다시 한 번 느끼는 거지만 Vue 쪽은 많은 편의성을 제공하려고 하다보니 그런건지 문서 상에서만 접할 수 있는 (코드 상으로는 파악이 불가능한) 그래서 꼭 읽어봐야 하는 그런 것들이 많은 듯. Vuex의 best practice에 대해서는 다음 포스팅에 이어서.</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://stackoverflow.com/questions/40390411/vuex-2-0-dispatch-versus-commit" target="_blank" rel="noopener">https://stackoverflow.com/questions/40390411/vuex-2-0-dispatch-versus-commit</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vuetorials.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Vuetorials-6-Vuex-Module-pattern&quot;&gt;&lt;a href=&quot;#Vuetorials-6-Vuex-Module-pattern&quot; class
      
    
    </summary>
    
      <category term="Vue" scheme="https://jaeyeophan.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jaeyeophan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>[Vuetorials] 5. Vuex API</title>
    <link href="https://jaeyeophan.github.io/2018/11/07/Vuetorials-5-Vuex/"/>
    <id>https://jaeyeophan.github.io/2018/11/07/Vuetorials-5-Vuex/</id>
    <published>2018-11-07T04:35:48.000Z</published>
    <updated>2018-11-16T00:57:50.470Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vuetorials.png" alt=""></p><h1 id="Vuetorials-5-Vuex-API"><a href="#Vuetorials-5-Vuex-API" class="headerlink" title="[Vuetorials] 5. Vuex API"></a>[Vuetorials] 5. Vuex API</h1><p>Vuex 가 왜 필요한지 그 배경에 대한 이야기는 과감히 스킵하겠음. 설치하는 과정도 스킵함. <a href="https://vuex.vuejs.org/installation.html" target="_blank" rel="noopener">공식 문서</a>에 아주 잘 나와 있음.</p><h2 id="Vuex-API"><a href="#Vuex-API" class="headerlink" title="Vuex API"></a>Vuex API</h2><p>Vuex 는 크게 네 가지로 볼 수 있음. <code>state</code>, <code>getter</code>, <code>action</code>, <code>mutation</code>. 그리고 컴포넌트와 연동시키기 위한 <strong>바인딩 헬퍼(Binding helper)</strong>가 있음. 이 바인딩 헬퍼는 <a href="https://github.com/reduxjs/react-redux" target="_blank" rel="noopener">react-redux</a> 나 <a href="https://github.com/mobxjs/mobx-react" target="_blank" rel="noopener">mobx-react</a> 같은 거라고 보면 됨. Vuex 에서는 아예 자체적으로 제공하고 있음.</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a><a href="https://vuex.vuejs.org/guide/state.html" target="_blank" rel="noopener">state</a></h3><p>말 그대로 Vuex 를 적용할 애플리케이션의 상태를 말함. 객체 형식으로 기술할 수 있음.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  todos: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>컴포넌트에서는 <code>this.$store.state.todos</code>로 접근하거나 바인딩 헬퍼를 통해 컴포넌트와 연결(mapping)할 수 있음. 각각의 바인딩 헬퍼 함수인 <code>map-*</code> 에서 반환되는 값이 전부 객체이기 때문에 <code>...</code>을 통해 destructuring 할 수 있음.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// computed: mapState(&#123;</span></span><br><span class="line">  <span class="comment">//   todos: state =&gt; state.todos,</span></span><br><span class="line">  <span class="comment">// &#125;);</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// component computed properties</span></span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      <span class="comment">// todos: state =&gt; state.todos</span></span><br><span class="line">      todos: <span class="function">(<span class="params">&#123; todos &#125;</span>) =&gt;</span> todos,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>각각의 바인딩 헬퍼에는 <code>String</code>, <code>String[]</code>, <code>Object</code> 등이 전달될 수 있음. 이들은 전부 <a href="https://github.com/vuejs/vuex/blob/2a67103a1f5fc1448a694e7f83a5f0c6d6bc8262/src/helpers.js#L46" target="_blank" rel="noopener">nomalizeMap</a>을 통해서 객체로 변환되어 매핑(mapping)됨.</p><h3 id="getter"><a href="#getter" class="headerlink" title="getter"></a><a href="https://vuex.vuejs.org/guide/getters.html" target="_blank" rel="noopener">getter</a></h3><p>Vue component API 중 <code>computed</code> 같은 역할을 수행함. 그냥 <code>store</code>에서 접근한 후 컴포넌트에서 <code>computed</code> 하게 되면 재사용성이 떨어지므로 Vuex 에서부터 지원을 함.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getter = &#123;</span><br><span class="line">  doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done),</span><br><span class="line">  getTodoById: <span class="function"><span class="params">state</span> =&gt;</span> id =&gt; state.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id === id)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>컴포넌트에서는 payload 가 함께 일 경우, 메소드 형태로 호출(함수를 반환하므로)하고 없을 경우 property 로 접근할 수 있음.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// helper 없이 mapping</span></span><br><span class="line">    <span class="comment">// doneTodos() &#123;</span></span><br><span class="line">    <span class="comment">//   return this.$store.getter.doneTodos;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    ...mapGetters([<span class="string">"doneTodos"</span>])</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    ...mapGetters(&#123;</span><br><span class="line">      doneTodos: <span class="string">"doneTodos"</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a><a href="https://vuex.vuejs.org/guide/mutations.html" target="_blank" rel="noopener">mutations</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  increment(state) &#123;</span><br><span class="line">    <span class="comment">// mutate state</span></span><br><span class="line">    state.count++;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// with payload (n)</span></span><br><span class="line">  increment(state, n) &#123;</span><br><span class="line">    state.count += n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>mutation</code>은 값을 변경하는 로직들이 들어감. synchronous 하게 동작해서 순차적인 로직들만 선언함. 그래서 컴포넌트에서 호출되면 안 됨. 선언된 <code>mutation</code>들은 <code>action</code>에서 <code>commit</code>되는 형태로만 호출되어야 함. <code>mapMutation</code>이라는 바인딩 헬퍼가 있긴 한데, 컴포넌트와 mapping 할 일이 없으므로 거의 사용되지 않음. (사용하는 부분이 있다면 제보 바람.)</p><h3 id="action"><a href="#action" class="headerlink" title="action"></a><a href="https://vuex.vuejs.org/guide/actions.html" target="_blank" rel="noopener">action</a></h3><p><code>action</code>은 <code>mutation</code>과 다르게 asynchronous 로 동작함. 그래서 <code>action</code>에서 비순차적 또는 비동기 처리 로직들을 선언함.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  increment(context) &#123;</span><br><span class="line">    context.commit(<span class="string">"increment"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  incrementBy(context, payload) &#123;</span><br><span class="line">    context.commit(<span class="string">"incrementBy"</span>, payload);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>action</code>에서는 여러 <code>mutation</code>을 조합하여 <code>commit</code> 할 수 있음. Promise 나 async/await 을 통해서 비동기 작업들을 순차적으로 동작하게 할 수 있음. 이 <code>action</code>은 컴포넌트에서 <code>dispatch</code>되는 형식으로 사용됨.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    triggerMethods() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.dispatch(<span class="string">"increment"</span>);</span><br><span class="line">      <span class="comment">// or</span></span><br><span class="line">      <span class="keyword">this</span>.$store.dispatch(<span class="string">"increment"</span>, &#123;</span><br><span class="line">        amount: <span class="number">10</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>with binding helper</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([<span class="string">"increment"</span>])</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      increment: <span class="string">"increment"</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>Vuex 관련 포스팅을 하나로 마무리 지으려고 했는데 너무 길어져서 두 개로 나눔. 다음 포스팅에서는 Vuex를 module pattern으로 작성하는 부분에 대해 다룰 예정임. Vuex에 대한 총체적인 느낌도 다음 포스팅에서.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vuetorials.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Vuetorials-5-Vuex-API&quot;&gt;&lt;a href=&quot;#Vuetorials-5-Vuex-API&quot; class=&quot;headerlink&quot; title=&quot;[
      
    
    </summary>
    
      <category term="Vue" scheme="https://jaeyeophan.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jaeyeophan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>[Vuetorials] 4. 내장 컴포넌트</title>
    <link href="https://jaeyeophan.github.io/2018/11/05/Vuetorials-4-Internal-Component/"/>
    <id>https://jaeyeophan.github.io/2018/11/05/Vuetorials-4-Internal-Component/</id>
    <published>2018-11-05T11:48:30.000Z</published>
    <updated>2018-11-05T11:52:13.099Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vuetorials.png" alt=""></p><h1 id="Vuetorials-4-내장-컴포넌트"><a href="#Vuetorials-4-내장-컴포넌트" class="headerlink" title="[Vuetorials] 4. 내장 컴포넌트"></a>[Vuetorials] 4. 내장 컴포넌트</h1><p>Vue 에서 제공하고 있는 컴포넌트에 대해 알아보는 포스팅.</p><h2 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a><a href="https://vuejs.org/v2/guide/components-slots.html" target="_blank" rel="noopener">Slot</a></h2><p>일단 이 <code>Slot</code> 이라는 것은 Vue 에서 특별히 만든 그런 기능이 아님. <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md" target="_blank" rel="noopener">w3c/proposals - Slots-Proposal.md</a>가 있음. 이 Slots 을 제대로 이해하려고 했더니 <code>Shadow Tree</code>까지 봐야함. 자세한 내용은 <a href="http://w3c.github.io/webcomponents/spec/shadow/" target="_blank" rel="noopener">관련 Spec 문서</a>를 봐야 함. <a href="https://kr.vuejs.org/v2/api/#slot-1" target="_blank" rel="noopener">API</a>는 별 게 없음. <a href="https://kr.vuejs.org/v2/guide/components.html#%EB%8B%A8%EC%9D%BC-%EC%8A%AC%EB%A1%AF" target="_blank" rel="noopener">공식 문서 설명</a>도 딱히 도움이 되진 않음. 일단 문법 자체가 처음 보면 익숙하지 않아서 부모-자식 이 부분이 약간 헷갈림.</p><h4 id="언제-쓰는가"><a href="#언제-쓰는가" class="headerlink" title="언제 쓰는가"></a>언제 쓰는가</h4><p>Vue 에서 component 를 등록하고 렌더링할 때 보통 <code>props</code>로 데이터를 전달하거나 함수를 전달함. 그런데 children 에 <code>HTML</code> 또는 Vue 컴포넌트를 전달해서 렌더링하고 싶을 때가 있음. 이 때 slot 을 사용할 수 있음.</p><p>사실 React 사용자에겐 ‘응? 그냥 props 로 JSX 넘겨주면 되지 않나?’ 할 수 있음. Vue 에서는 <code>components</code>에 컴포넌트를 등록해야 <code>template</code>에서 렌더링 할 수 있음. 근데 <code>props</code>로 전달함과 동시에 <code>components</code>에 등록할 수 없음.</p><p>그냥 props 로 전달하는 것보다 slot 이 더 Composability(합성 가능성)를 극대화 할 수 있는 기능이라고 하는데, 아직 감이 잘 안 잡힘.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"todo-header"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"todo-container"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"todo-filters"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"todo-footer"</span> <span class="attr">:author</span>=<span class="string">'"Jbee"'</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>slot 을 사용하는 가장 쉽고 대표적인 예제는 layout 을 잡기 위한 <code>.vue</code> 임. 위와 같이 <code>TodoLayout.vue</code>를 지정한 후,</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">todo-layout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 정의한 컴포넌트를 slot으로 배포 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">todo-title</span></span></span><br><span class="line"><span class="tag">      <span class="attr">msg</span>=<span class="string">"TODO APP"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">slot</span>=<span class="string">"todo-header"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">todo-title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 축약형 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">todo-container</span> <span class="attr">slot</span>=<span class="string">"todo-container"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- scope를 통해 전달받은 props를 렌더링 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">"todo-footer"</span> <span class="attr">slot-scope</span>=<span class="string">"props"</span>&gt;</span></span><br><span class="line">      Copyright: @&#123;&#123; props.author &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">todo-layout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이렇게 <code>todo-layout</code> 컴포넌트에 주입할 수 있음. <code>slot=&quot;A&quot;</code> 어트리뷰트와 <code>&lt;slot name=&quot;A&quot; /&gt;</code>로 부모-자식 관계를 정의함.</p><h2 id="component"><a href="#component" class="headerlink" title="component"></a><a href="https://vuejs.org/v2/api/#component" target="_blank" rel="noopener">component</a></h2><p><strong>동적 컴포넌트</strong>를 정의할 때 편리한 내장 컴포넌트 API. <code>is</code>라는 속성과 함께 사용됨.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentFilterView"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- shorten --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;component :is="currentFilterView"&gt;&lt;/component&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    component: &#123;</span></span><br><span class="line"><span class="undefined">      A,</span></span><br><span class="line"><span class="undefined">      B,</span></span><br><span class="line"><span class="undefined">      C,</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>currentFilterView</code>는 Vue 컴포넌트에서 <code>data</code>로 지정된 속성임. 이 값에 <code>A</code> 또는 <code>B</code> 또는 <code>C</code> 값(컴포넌트이름)이 들어갈 경우, <code>component</code> 태그에 <code>A</code> 또는 <code>B</code> 또는 <code>C</code>컴포넌트가 렌더링 됨. <code>component</code> 태그 하위에 렌더링 되는게 아니라 바로 그 자리에 대체됨. 언뜻보면 단순한 <code>switch statement</code> sugar syntax 같지만, <code>keep-alive</code> 라는 내장 컴포넌트로 감싸줄 경우, cache 를 타게 됨.</p><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a><a href="https://vuejs.org/v2/api/#keep-alive" target="_blank" rel="noopener">keep-alive</a></h2><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/components/keep-alive.js#L51" target="_blank" rel="noopener">무엇이 어떻게 caching 되는가</a>를 보면 인스턴스를 destroy 하지 않고 남겨둠. 즉 <code>keep-alive</code>라는 <a href="https://github.com/vuejs/vue/blob/dev/src/core/components/keep-alive.js#L55" target="_blank" rel="noopener">추상 엘리먼트</a>로 감싸져있는 컴포넌트들이 변경될 때, 사라질 인스턴스를 메모리에서 제거하지 않음. 이로 인해 불필요한 re-render 를 막고 활성화되을 때 변경되었던 상태가 비활성화 후 다시 활성화 되었을 때 유지 됨. <a href="https://kr.vuejs.org/v2/api/#keep-alive" target="_blank" rel="noopener">공식 문서</a>에서는 <code>transition</code> 내장 컴포넌트와 함께 사용하여 애니메이션 된 상태를 유지할 때 사용하기도 한다고 되어있음.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentFilterView"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>아까 <code>component</code>를 정의한 부모에 <code>keep-alive</code> 태그로 감싸주면 됨. <code>keep-alive</code> 하위에 렌더링되는 컴포넌트들은 두 가지 hook 이 mixin 으로 추가됨. <code>activated</code>, <code>deactivated</code> 두 가지 훅(hook)은 해당 컴포넌트가 활성화 될 때, 비활성화 될 때 호출됨.</p><p><code>:include</code>, <code>:exclude</code>디렉티브를 통해서 caching 을 적용할 컴포넌트와 적용하지 않을 컴포넌트를 적용할 수 있음. String, 정규식, 배열을 전달할 수 있음. (<a href="https://github.com/vuejs/vue/blob/dev/src/core/components/keep-alive.js#L51" target="_blank" rel="noopener">관련 코드</a>)</p><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p><code>transition</code>과 <code>trasition-group</code>은 animation 관련하여 함께 다루는 것이 좋을 듯하여 이번 장에서 다루지 않음. React 는 개발자 너희들이 알아서 해라 식이었다면 Vue 는 <code>computed</code>도 그렇고 <code>keep-alive</code>도 그렇고 라이브러리 자체에서 제공하고 있는 API 를 충분히 활용할 수 있을 듯 함.</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://skyronic.com/blog/vue-slots-example" target="_blank" rel="noopener">https://skyronic.com/blog/vue-slots-example</a></li><li><a href="https://daveceddia.com/pluggable-slots-in-react-components/" target="_blank" rel="noopener">https://daveceddia.com/pluggable-slots-in-react-components/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vuetorials.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Vuetorials-4-내장-컴포넌트&quot;&gt;&lt;a href=&quot;#Vuetorials-4-내장-컴포넌트&quot; class=&quot;headerlink&quot; title=&quot;[Vu
      
    
    </summary>
    
      <category term="Vue" scheme="https://jaeyeophan.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jaeyeophan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>[Vuetorials] 3. Component API</title>
    <link href="https://jaeyeophan.github.io/2018/10/23/Vuetorials-3-Component-API/"/>
    <id>https://jaeyeophan.github.io/2018/10/23/Vuetorials-3-Component-API/</id>
    <published>2018-10-23T03:01:56.000Z</published>
    <updated>2018-11-15T12:33:34.818Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vuetorials.png" alt=""></p><h1 id="Vuetorials-3-Component-API"><a href="#Vuetorials-3-Component-API" class="headerlink" title="[Vuetorials] 3. Component API"></a>[Vuetorials] 3. Component API</h1><h2 id="Component-API"><a href="#Component-API" class="headerlink" title="Component API"></a>Component API</h2><p>컴포넌트에는 여러 가지 내용들이 기술될 수 있음. 객체에 <code>[key-value]</code> 형식으로 기술됨. 성격이 다른 옵션 API 들이 아무런 그룹없이 존재할 수 있기 때문에 객체로 기술할 경우 인위적인 그룹화가 필요해보임. (내키는대로 작성하게 되면 가독성 폭망할 듯.)</p><ol><li>DOM rendering 과 관련된 내용</li><li>컴포넌트에서 사용될 data 에 대한 내용</li><li>컴포넌트의 라이프 사이클 메소드</li><li>에셋이라고 표현한 옵션들.</li><li>기타라고 표현한 옵션들</li></ol><p>각각의 내용에 대해서는 <a href="https://kr.vuejs.org/v2/api/#data" target="_blank" rel="noopener">공식 문서</a>에 잘 나와있음. 자질구레한 <strong>제한</strong>이 있고 이런 제한에 대해서는 <strong>런타임에</strong> 에러가 발생함. 몇 가지 짚고 넘어갈 API 만 살펴봄.</p><h3 id="props"><a href="#props" class="headerlink" title="props"></a><a href="https://kr.vuejs.org/v2/api/#props" target="_blank" rel="noopener">props</a></h3><p>컴포넌트가 전달받을 props 에 대해 기술하기 위한 API 임. 단순히 배열로 표현이 가능하지만 객체로 기술할 경우, 타입 체크 및 유효성 검사 로직을 추가할 수 있음. 검사 대상은 다음 네 가지 임.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 타입 체크만</span></span><br><span class="line">    height: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 타입 체크와 유효성 검사</span></span><br><span class="line">    age: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">0</span>,</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value &gt;= <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>props</code>에 추가될 수 있는 프로퍼티를 interface 로 구성하자면 다음과 같음.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PropPropertyInterface &#123;</span><br><span class="line">  <span class="keyword">type</span>?: <span class="built_in">Function</span> | <span class="built_in">Array</span>&lt;<span class="built_in">Function</span>&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">default</span>?: <span class="built_in">any</span> = <span class="literal">undefined</span>;</span><br><span class="line">  required?: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">  validator?: <span class="built_in">Function</span> = <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그 무엇하나 필수가 아님. 필수가 아니기 때문에 <code>age: {}</code>로 해도 그냥 돌아감. props 와 관련된 로직은 <a href="https://github.com/vuejs/vue/blob/dev/src/core/util/props.js#L14" target="_blank" rel="noopener">여기</a>에서 볼 수 있음. JavaScript 환경에서는 Interface 또는 type alias 를 별도로 지원하지 않으니 반쪽짜리 타입 체크가 될 수 밖에 없음. <code>validator</code> 부분과 객체로 기술 한다는 부분에서는 React 의 <a href="https://github.com/facebook/prop-types" target="_blank" rel="noopener">prop-types</a>보다 낫다고 봄. 실제로 <code>validator</code>를 쓸 지는 잘 모르겠음. (제보 부탁드림.)</p><h3 id="data"><a href="#data" class="headerlink" title="data"></a><a href="https://kr.vuejs.org/v2/api/#data" target="_blank" rel="noopener">data</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// Recommend</span></span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; ... &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// or</span></span><br><span class="line">  data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; ... &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data 는 <code>this</code>에 value 들을 바인딩(binding)해야 하기 때문에 메소드 형태나 <code>function</code> keyword 를 사용하여 함수 형태로 기술해줘야 함. 화살표 함수(arrow function)을 쓰면 this binding 이 외부 context 를 잡게 되고 undefined 가 되어 <code>data</code>로 기술한 객체에 Vue 인스턴스에서 접근할 수 없음. 이게 런타임에서 에러나는게 참 아쉬움.</p><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a><a href="https://kr.vuejs.org/v2/api/#computed" target="_blank" rel="noopener">computed</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    totalSum: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125; <span class="comment">// only getter</span></span><br><span class="line">    addTo: &#123;</span><br><span class="line">      get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.num;</span><br><span class="line">      &#125;,</span><br><span class="line">      set: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.num + val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 API 는 <a href="https://kr.vuejs.org/v2/guide/computed.html" target="_blank" rel="noopener"><strong>cache</strong></a>가 핵심임. getter 와 setter 로 접근이 가능함. 변경 사항을 반영할 때 caching 때문에 methods 를 사용하는 것보다 빠르게 계산할 수 있음. <code>cache:false</code>를 통해서 cache 기능을 끌 수도 있음. <code>data</code> API 와 마찬가지로 각각의 프로퍼티는 arrow function 을 사용하면 안 됨. (같은 이유임) 3.0에서는 Proxy를 통해 getter, setter가 구현될 예정이라고 함.</p><h3 id="render"><a href="#render" class="headerlink" title="render"></a><a href="https://kr.vuejs.org/v2/api/#render" target="_blank" rel="noopener">render</a></h3><p>React 에서 익숙하게 봐오던 API 임. Vue 컴포넌트에서는 <code>&lt;template&gt;</code> 태그로 HTML 을 기술할 수 있었음. 하지만 이 API 를 통해 React 처럼 렌더링 될 HTML 을 기술할 수 있음. <code>render</code> function 에는 <code>createElement: () =&gt; VNode</code>가 파라미터로 전달됨. 이걸 이용해서 HTML 엘리먼트를 기술할 수 있음.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(</span><br><span class="line">      <span class="string">"ul"</span>,</span><br><span class="line">      <span class="keyword">this</span>.todos.map(<span class="function"><span class="params">item</span> =&gt;</span> createElement(<span class="string">"li"</span>, item.content))</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>각각의 태그를 저렇게 명시해줘야 하는 부분이 너무 귀찮음. <a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx" target="_blank" rel="noopener">babel-plugin-transform-vue-jsx</a>를 추가하면 <code>render</code> 함수의 return value 를 JSX 로 사용할 수 있음.</p><h4 id="Stateless-Functional-Component"><a href="#Stateless-Functional-Component" class="headerlink" title="Stateless Functional Component"></a>Stateless Functional Component</h4><p>이 API 로 상태가 없는 functional component 를 만들 수 있음. (일단 React 에 비해 뭘 잔뜩 적어줘야 함.)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  functional: <span class="literal">true</span>,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; props &#125; = context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">'ul'</span>, props.todos.map(...))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue 는 기본적으로 <code>this</code>에 필요한 데이터나 메소드 등을 binding 해주는데 함수형 컴포넌트(Functional Component)일 경우, <code>this</code>에 접근하지 못하기 때문에 <code>functional: true</code>일 경우, <code>render</code> function 에 두번째 파라미터로 <code>context</code>를 넘겨줌. 이 <code>context</code>를 <strong>FunctionalRenderContext</strong>이라 하며 <code></code>data<code>,</code>props<code>,</code>listeners` 등에 접근할 수 있음. 이 함수형 컴포넌트의 경우에는 multi-root 로 렌더링 할 수 있음.</p><h4 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h4><p>다루지 않은 많은 API 들이 존재하지만 필요할 때 공식 문서에서 확인 가능함. 해당 글이 길어졌기 때문에 다뤄야 할 다른 API 가 있으면 다른 포스팅에서 다룰 예정임.</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://kr.vuejs.org/v2/api/" target="_blank" rel="noopener">Vue Official Doucument</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vuetorials.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Vuetorials-3-Component-API&quot;&gt;&lt;a href=&quot;#Vuetorials-3-Component-API&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Vue" scheme="https://jaeyeophan.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jaeyeophan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>[Vuetorials] 2. 전반적인 concept</title>
    <link href="https://jaeyeophan.github.io/2018/10/21/Vuetorials-2-Vue-concept/"/>
    <id>https://jaeyeophan.github.io/2018/10/21/Vuetorials-2-Vue-concept/</id>
    <published>2018-10-21T07:27:24.000Z</published>
    <updated>2018-11-16T01:53:05.179Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vuetorials.png" alt=""></p><h1 id="Vuetorials-2-전반적인-concept"><a href="#Vuetorials-2-전반적인-concept" class="headerlink" title="[Vuetorials] 2. 전반적인 concept"></a>[Vuetorials] 2. 전반적인 concept</h1><h2 id="Single-File-Component"><a href="#Single-File-Component" class="headerlink" title="Single File Component"></a>Single File Component</h2><p>Vue 는 <strong>싱글 파일 컴포넌트</strong>로 작성하는 것을 권장함. 처음엔 이게 무슨 말인지 몰랐음. React 에선 SFC 는 Stateless Functional Component 인데… Vue 에선 SFC 가 Single File Component 임…</p><p>뭐 그렇다 치고. SFC 는 컴포넌트 단위로 View 를 구성할 때, HTML/CSS/JavaScript 를 어떤 방식으로 작성할 것인가에 대한 내용임.</p><p>일단 React 의 경우에는 HTML 을 JSX 라는 문법으로 표현하며 자연스럽게 JavaScript 와 하나가 됨. 불쌍한 CSS 는 혼자 별도 파일에 존재하여 import 되어 사용됨. 물론 <code>CSS-in-JS</code> 로 <code>.jsx</code> 또는 <code>.tsx</code>에 CSS 코드를 포함시키기도 함.</p><p>Angular 의 경우 세 가지는 모두 별도 파일로 기술됨.</p><p>Vue 는 하나의 <code>.vue</code>라는 파일에서 HTML/CSS/JavaScript 를 모두 기술하게 함. 이게 <strong>싱글 파일 컴포넌트</strong>임. 이 세 가지 다른 언어는 <code>&lt;template&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;style&gt;</code> 이라는 태그로 구분됨. 관심사의 분리라는 측면에서는 앵귤러와 리액트의 중간쯤 단계로 타협을 본 것 같음.</p><p><strong>‘분리’</strong>를 하게 되면 <strong>“정적인 HTML 과 JavaScript 로직을 어떻게 유기적으로 연동할 것인가?”</strong> 이 부분이 이슈가 됨. 애초에 분리를 하지 않은 React 는 JSX 문법으로 HTML 을 기술하기 때문에 JavaScript 와 아주 자연스럽게 연동됨. 앵귤러와 뷰는 그렇지 못하기 때문에 ‘<strong>디렉티브</strong>‘라는 것이 있음.</p><h2 id="Directives"><a href="#Directives" class="headerlink" title="Directives"></a>Directives</h2><p>HTML 에 JavaScrpit 를 입히기 위해 추가하는 속성(attribute) 중 하나라고 생각하면 편함. <code>v-on</code>, <code>v-for</code> 등 여러 가지 디렉티브가 있고 custom directive 도 만들어서 등록할 수 있음. JSX 의 경우, onclick 을 <code>onClick</code>으로 표현했다면 Vue 의 디렉티브로는 <code>v-on:click</code> 이렇게 이벤트를 등록함. 축약형도 제공하고 있는데 이게 처음에는 조금 헷갈릴 수 있겠다 싶었음. <code>(v-on:click</code>은 <code>@click</code>으로 <code>v-bind:</code>는 <code>:</code>으로 축약 가능.) <a href="https://vuejs.org/v2/style-guide/#Directive-shorthands-strongly-recommended" target="_blank" rel="noopener">공식 스타일 가이드</a>에서는 둘 중 하나로 통일해서 작성하라고 함. 이 공식 스타일은 꼭 한 번 읽고 개발을 진행하는게 좋음.</p><h2 id="Component-를-생성"><a href="#Component-를-생성" class="headerlink" title="Component 를 생성"></a>Component 를 생성</h2><p><code>.vue</code>에서 js 로직을 기술하기 위해 <code>&lt;script&gt;</code>를 만드는 방법은 기본적으로 3 가지 정도가 있음.</p><h3 id="1-Vue-component"><a href="#1-Vue-component" class="headerlink" title="1. Vue.component"></a>1. Vue.component</h3><p>이 방식으로 컴포넌트를 선언하게 되면 그 컴포넌트는 전역 컴포넌트(Global Component)가 됨. JavaScript 를 처음 공부할 때부터 전역 공간을 오염시키지 않기 위해 <a href="http://asfirstalways.tistory.com/233" target="_blank" rel="noopener">Name space pattern</a>과 <a href="http://asfirstalways.tistory.com/234" target="_blank" rel="noopener">Module pattern</a>을 배웠던 기억이 남. 전역 컴포넌트는 다음과 같은 이슈가 있기 때문에 개인적으론 사용을 지양하고 싶음.</p><ul><li>컴포넌트 이름이 충돌할 가능성이 많음</li><li>VSCode extension 인 Vetur 는 local component 에 대해서만 prop auto-complete 을 지원함.</li><li>일단 디버깅 및 코드 구조 파악이 어려움.</li></ul><p>전역 컴포넌트를 사용하기 좋은 예가 무엇이 있을지 연구 중임.</p><h3 id="2-export-default"><a href="#2-export-default" class="headerlink" title="2. export default { }"></a>2. <code>export default { }</code></h3><p><code>.vue</code> 파일에서 <code>&lt;script&gt;</code>에 이렇게 선언을 하면 지역 컴포넌트(Local Component)로 선언됨. 객체 형식으로 기술을 하게 됨. 사용하는 측은 별도로 import 한 후 <code>components</code>에 기술 후 사용할 수 있음.</p><h3 id="3-vue-class-component-사용"><a href="#3-vue-class-component-사용" class="headerlink" title="3. vue-class-component 사용"></a>3. vue-class-component 사용</h3><p><a href="https://github.com/vuejs/vue-class-component" target="_blank" rel="noopener">vue-class-component</a>라는 라이브러리를 사용하여 component 를 기술할 수 있음. 객체의 프로퍼티로 정의해줬던 것들을 클래스의 메소드나 클래스의 프로퍼티로 정의할 수 있음.</p><ul><li><code>methods</code> -&gt; <code>class member methods</code></li><li><code>computed</code> -&gt; <code>class property accessors</code></li><li><code>data</code> -&gt; <code>class properties</code></li><li><code>life cycle hook</code> -&gt; <code>class member methods</code></li><li><code>prop</code> =&gt; <code>parameter of @Component</code> or <code>@prop</code></li><li>…</li></ul><p>단, decorator 문법을 사용하므로 다른 babel-plugin 들이 필요함. TypeScript 기반이라면 <code>tsconfig.json</code>에서 <code>--experimentalDecorators</code> 옵션을 켜줘야 함. 객체로 컴포넌트를 정의하는게 불편했는데 이 부분은 아마 3.0 에서 native 로 지원할 예정인 듯.</p><h3 id="new-Vue"><a href="#new-Vue" class="headerlink" title="+ new Vue({ ... })"></a><code>+ new Vue({ ... })</code></h3><p>처음 <code>@vue/cli</code>로 스캐폴딩하면 <code>main.js</code>에 <code>new Vue({ render: ... })</code> 이렇게 되어있음. 이 Vue 인스턴스는 컴포넌트가 아니라 MVVM 패턴에서 VM(ViewModel)임. Vue 로 SPA 를 구성한다고 했을 때 이 인스턴스는 <code>main.js</code>에 하나만 있으면 되는 거임. 마치 <code>ReactDOM.render</code>가 하나 있는 것처럼. MVVM 에 대한 자세한 내용은 <a href="https://joshua1988.github.io/web-development/vuejs/vuejs-tutorial-for-beginner/" target="_blank" rel="noopener">캡틴 판교님의 글</a>을 확인해보면 됨. (처음에 Vue 를 접했을 때 이 부분이 Vue 인스턴스랑 컴포넌트랑 많이 헷갈렸음.)</p><h2 id="나름의-장점"><a href="#나름의-장점" class="headerlink" title="나름의 장점"></a>나름의 장점</h2><ul><li><code>&lt;template&gt;</code>을 기술할 때 pure html 로도 기술할 수 있고 <a href="https://github.com/pugjs/pug" target="_blank" rel="noopener">pug(구 jade)</a>로도 기술할 수 있음.</li><li><code>&lt;style&gt;</code> 기술 시에도 <code>lang</code>으로 pure css, scss 등 선택할 수 있음.</li><li><code>&lt;style scoped&gt;</code>, <code>&lt;style module&gt;</code>을 통해 component 범위에서만 적용되는 style 을 기술 할 수 있음. (짱짱)</li><li>JSX보다 표준에 가까움.</li><li>cli가 좋음.</li></ul><h2 id="나름의-단점"><a href="#나름의-단점" class="headerlink" title="나름의 단점"></a>나름의 단점</h2><ul><li>JSX 에선 뭐든 <code>{}</code>로 감싸서 전달하면 됐는데, 문법이 약간 헷갈림.<ul><li><code>&lt;template&gt;</code>에 <code>data</code> , <code>computed</code>, <code>prop</code> 등을 기술하는데 이중 대괄호를 씀.</li><li>클래스 조작하기 위해 일반 <code>class</code> attribute 가 아니라 <code>v-bind:class</code>로 기술해야 함.</li><li>directive 에는 string 으로 기술.</li><li>삼항 연산자를 넘기려면 string 안에 <code>[]</code>로 기술.</li><li>토글을 위한 syntax 도 제공하는데 이건 <code>{}</code>로 기술.<ul><li>lint가 이러한 부분을 잡아주지 못하기 때문에 팀 내에서 약속된 규칙을 만드는 것이 중요함.</li></ul></li></ul></li><li>컴포넌트 내부에서 관리되는 data 들이 immutable 이 아닌게 조금 찝찝함.<ul><li>MobX 처음 봤을 때의 느낌임.</li><li>Redux 사용자들에겐 불편하게 다가갈 수 있을 듯 함.</li><li>3.0 에서 immutable version 의 value 가 추가된다고 하는데 어떤 형태일지 궁금함.</li></ul></li><li><code>&lt;template&gt;</code>에는 Single Root Element 가 들어가야 함.<ul><li>Vue 의 함수형 컴포넌트로 multi-root components 를 렌더링 할 수 있긴 함. (3 장에서 다룰 예정.)</li></ul></li><li>Object-based API 임.<ul><li>3.0에 Class-based API가 나온다고 하니 기대 중.</li></ul></li></ul><h2 id="개인적인-인상"><a href="#개인적인-인상" class="headerlink" title="개인적인 인상"></a>개인적인 인상</h2><p>Vue 를 홍보할 때 흔히 “러닝커브가 낮다.”라는 말을 함. 그러나 초기 접근이 쉽다는 것은 그만큼 magic(눈에 보이지 않는 로직, 라이브러리에서 처리하는 로직)이 많다는 것임. 이를 제대로 이해하지 못한다면 애플리케이션의 크기가 커졌을 경우나 복잡한 로직 디버깅이 힘들어짐. 매직이 많다는 것이 나쁘다는 것은 아님. 함께 프로젝트를 진행하는 팀원 모두가 동일하게 이 매직에 대해 이해하고 있으면 매직은 발목을 붙잡는 것이 아니라 오히려 생산성을 증대시켜주는 녀석으로 바뀜.</p><p>그리고 배우기 쉽다는 것은 es6 선행 학습 없이, npm, webpack 등의 선행 학습 없이 jQuery 쓰듯이 script 태그에 cdn에 올려놓고 바로 시작할 수 있어서 생긴 말이 아닐까 하는 생각이 들었음.</p><p><code>&lt;template&gt;</code>으로 HTML 을 분리하느냐 JSX 문법으로 HTML 을 흡수하느냐는 Vue 와 React 를 구분짓는 큰 요소 중 하나라고 생각함. 가독성 측면에서는 익숙한게 좋은 거라고 생각함. 딱히 둘 중 뭐가 더 나은지는 아직 잘 모르겠음. 아직 개발하기에는 JSX 가 편한 듯. 만약 프론트엔드 개발 인력 중 마크업을 작성하는 인력이 나뉘어져 있다면 Vue 가 더 편할지도 모르겠으나 멀티 루트를 지원하지 않는 관계로 쓸데없는 태그들이 추가될 수 있을 듯.</p><p>Vue는 기본적으로 Object-based API이다 보니 <code>,</code>(comma)를 정말 많이 쓰게 됨. 은근히 짜증남. 빨리 vue 3.0이 나와서 vue 자체적으로 지원하는 class-based API로 쓰고 싶음. 3.0이 TypeScript로 rewrite 된다고 해서 더 기대됨!</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://frontendsociety.com/why-you-shouldnt-use-vue-component-ff019fbcac2e" target="_blank" rel="noopener">https://frontendsociety.com/why-you-shouldnt-use-vue-component-ff019fbcac2e</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vuetorials.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Vuetorials-2-전반적인-concept&quot;&gt;&lt;a href=&quot;#Vuetorials-2-전반적인-concept&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Vue" scheme="https://jaeyeophan.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jaeyeophan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>[Vuetorials] 1. @vue-cli 3.0</title>
    <link href="https://jaeyeophan.github.io/2018/10/21/Vuetorials-1-vue-cli-3-0/"/>
    <id>https://jaeyeophan.github.io/2018/10/21/Vuetorials-1-vue-cli-3-0/</id>
    <published>2018-10-21T07:22:02.000Z</published>
    <updated>2018-11-16T03:01:14.735Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vuetorials.png" alt=""></p><h1 id="Vuetorials-1-vue-cli-3-0"><a href="#Vuetorials-1-vue-cli-3-0" class="headerlink" title="[Vuetorials] 1. @vue-cli 3.0"></a>[Vuetorials] 1. @vue-cli 3.0</h1><h2 id="프로젝트-세팅"><a href="#프로젝트-세팅" class="headerlink" title="프로젝트 세팅"></a>프로젝트 세팅</h2><p>일단 뭐가 됐든 프로젝트 세팅부터 할 <code>CRA(Create React App)</code> 같은게 필요함. 그게 <a href="https://cli.vuejs.org/" target="_blank" rel="noopener">@vue/cli</a> 임. 2018 년 8 월 version 3 이 release 되었음.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g @vue/cli</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vue create vue-app</span><br></pre></td></tr></table></figure><p><code>default</code> 랑 <code>Manually select features</code>를 선택할 수 있음. <code>default</code> 옵션은 말 그대로 기본적인 옵션으로 프로젝트를 생성해줌. <code>babel</code>과 <code>eslint</code> 기반임. 이렇게 <strong>선택</strong>을 할 수 있는건 CRA 보다 좋은 듯. 이전 버전에서 template 이라는 용어를 사용했다면 그 용어를 버리고 여러 옵션들을 조합하여 프로젝트를 스캐폴딩 해줌. template 으로는 여러 경우의 수를 모두 대응하기엔 한계가 있기 때문에 이러한 방법을 선택한 것 같음.</p><p>일단 처음이니 <code>default</code> 옵션으로 프로젝트를 생성해보겠음. yarn 쓸 지, npm 쓸 지도 선택할 수 있는데 npm 선택한 후 프로젝트 생성함.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> vue-app</span><br><span class="line">$ npm run serve</span><br></pre></td></tr></table></figure><p>깔끔하게 vue application 이 띄워졌음. (‘요즘것들’은 이 정도는 다 기본적으로 제공하고 있는 듯.)</p><p>스캐폴딩 된 프로젝트 구조는 다음과 같음. (VSCode 에서 해당 프로젝트를 열어보니 확장 프로그램이 권장됨. 바로 Vetur 설치함.)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── README.md</span><br><span class="line">├── babel.config.js</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   └── index.html</span><br><span class="line">└── src</span><br><span class="line">    ├── App.vue</span><br><span class="line">    ├── assets</span><br><span class="line">    │   └── logo.png</span><br><span class="line">    ├── components</span><br><span class="line">    │   └── HelloWorld.vue</span><br><span class="line">    └── main.js</span><br></pre></td></tr></table></figure><p>CRA 처럼 webpack config 등 여러 config 들을 숨겨버렸음. <code>babel.config.js</code>만 밖으로 나와있고 <code>preset</code>으로 <code>@vue/app</code>이 들어가있음. 이 녀석의 지원 범위라던가 스펙 등은 <a href="https://github.com/vuejs/vue-cli/blob/dev/packages/%40vue/babel-preset-app/README.md" target="_blank" rel="noopener">@vue/babel-preset-app</a>에서 확인할 수 있음. 그리고 다른 webpack 설정은 <a href="https://github.com/vuejs/vue-cli/blob/dev/packages/%40vue/cli-service/lib/config/base.js" target="_blank" rel="noopener">@vue/cli-service 의 lib 디렉토리</a>에서 확인할 수 있음.</p><p>babel 이 7 version 으로 올라가면서 전부 <code>@babel</code> namespace 로 들어가면서 monorepo 형식으로 운영되는데 <code>vue-cli</code> 도 <code>@vue</code> namespace 를 기반으로 monorepo 로 구성된 것을 확인할 수 있음.</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>가장 중요한 npm scripts 는 <code>vue-cli-service</code> 라는 모듈로 제공됨. 다양한 옵션들은 <a href="https://cli.vuejs.org/guide/cli-service.html#using-the-binary" target="_blank" rel="noopener">여기</a>에서 확인 가능함.</p><p><code>serve</code>, <code>build</code>, <code>lint</code> 세 가지 기본 command 를 제공함. 일단 <code>npm start</code> 가 없다는게 마음에 안 듬. 그리고 왜 <code>test</code> 커맨드가 없나 했는데 default 에서는 테스트를 위한 package 가 포함이 안 되어있음. 그래서 커맨드도 만들어주지 않음.</p><h2 id="Project-Configuration"><a href="#Project-Configuration" class="headerlink" title="Project Configuration"></a>Project Configuration</h2><p><code>@vue/cli</code>는 CRA 랑 다르게 애초에 <code>eject</code>를 지원하지 않음. CRA(1.x 기준)에서는 override 하기 위해 eject 를 하거나 <a href="https://github.com/timarney/react-app-rewired" target="_blank" rel="noopener">react-app-rewired</a> 를 썼음.</p><p>Vue 에서는 <code>vue.config.js</code>를 통해 override 하거나 필요한 loader, plugin 들을 추가하라고 함. <a href="https://github.com/survivejs/webpack-merge" target="_blank" rel="noopener">webpack-merge</a>를 사용해봤다면 익숙하게 사용할 수 있을 듯. 그냥 사용할 로더나 플러그인에 대해 <code>module.exports = { ... }</code> 형태로 작성하면 알아서 config 에 merge 함. <a href="https://github.com/neutrinojs/webpack-chain" target="_blank" rel="noopener">webpack-chain</a> 도 지원하고 있어서 chaining 문법으로도 vue.config.js 를 작성할 수도 있음. 실제로 내부 config들은 chaining 문법으로 작성되어 있음. (보기 더 편한 것 같기도 함.)</p><p>아직 config 를 추가해보지 않았고 최근에 release 된 CRA 2.x version 을 사용해보지 않았지만 Vue 쪽 지원이 더 좋은 듯.</p><p>@vue/cli 로 스캐폴딩 된 프로젝트의 webpack config 가 너무 궁금하면 해당 프로젝트에서 <code>vue inspect</code> 명령어를 치면 확인해볼 수 있음. 파일로 보고 싶으면 <code>&gt;</code>와 함께 사용하면 됨. <code>vue inspect &gt; output.js</code> 이렇게. <code>inspect</code> 명령어는 다양한 옵션도 제공하고 있으니 유용하게 사용할 수 있을 듯 함.</p><h2 id="Manually-select-features"><a href="#Manually-select-features" class="headerlink" title="Manually select features"></a>Manually select features</h2><ol><li>transpiler 로는 <strong>babel</strong>과 <strong>TypeScript</strong>를 지원함.</li><li>Unit test 로는 <strong>Mocha + chai 조합</strong>과 <strong>Jest</strong>를 지원함.</li><li>E2E test 로는 <strong>Cypress</strong>와 <strong>nightwatch</strong>를 지원함.</li><li>PWA 도 지원함.</li><li>server side renderer 라이브러리인 vue-server-renderer 를 포함하여 스캐폴딩 해주는 옵션은 없음. <a href="https://github.com/vuejs/vue-cli/issues/1034" target="_blank" rel="noopener">논의</a>는 있었던 것 같음. <a href="https://github.com/nuxt/nuxt.js" target="_blank" rel="noopener">nuxt.js</a>가 있으니 별도 지원 필요성을 느끼지 못하는 듯.</li></ol><p>babel 이랑 typescript 랑 같이 선택하면 <code>Use Babel alongside TypeScript for auto-detected polyfills?</code> 이런 메세지가 나옴. TypeScript 만 선택했을 때와 비교하면 <code>tsconfig.json</code>에서 <code>target</code> 이 다르게 설정됨. babel 과 함께 스캐폴딩할 경우 <code>esnext</code>로 target 이 지정되고 아닐 경우 es5 로 지정됨.</p><p>참고로 typescript 를 위한 loader 는 <a href="https://github.com/s-panferov/awesome-typescript-loader" target="_blank" rel="noopener">atsl</a>이 아닌 <a href="https://github.com/Realytics/fork-ts-checker-webpack-plugin" target="_blank" rel="noopener">fork-ts-checker-webpack-plugin</a>과 함께 <a href="https://github.com/TypeStrong/ts-loader" target="_blank" rel="noopener">ts-loader</a>로 스캐폴딩 됨.</p><h2 id="Add-dependency"><a href="#Add-dependency" class="headerlink" title="Add dependency"></a>Add dependency</h2><p>초기 프로젝트 세팅에서 추가하고 싶은 경우가 있을 경우, <code>vue add</code>라는 command를 통해 추가할 수 있음. dependency는 물론 npm scripts, 기본적인 scaffolding까지 해줌.</p><ul><li><a href="https://kazupon.github.io/vue-i18n/installation.html#vue-cli-3-x" target="_blank" rel="noopener"><code>vue add i18n</code></a></li><li><a href="https://www.npmjs.com/package/@vue/cli-plugin-unit-jest" target="_blank" rel="noopener"><code>vue add @vue/unit-jest</code></a></li></ul><h2 id="Support-GUI"><a href="#Support-GUI" class="headerlink" title="Support GUI"></a>Support GUI</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vue ui</span><br></pre></td></tr></table></figure><p><code>@vue/cli</code> 설치 후, 이 명령어를 실행하면 8000 포트로 Vue Project Manager 가 열림. 프로젝트를 생성하고 create 할 수 있는 GUI 를 제공함. 터미널 명령어들이 익숙하지 않거나 초심자 입장에서는 사용하기 정말 좋아보임. (아직 Beta 딱지가 붙어있음.)</p><p>딱히 사용할 일이 있겠나 싶었는데 방금 생성한 vue-app 을 import 했더니 프로젝트와 관련된 plugins, dependencies, configuration, npm tasks 를 볼 수 있음. (vue project directory 에서 <code>vue ui</code> 명령어를 입력하면 바로 해당 프로젝트의 GUI 가 나타남.)</p><h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><p>현재 설치된 <code>@vue</code>의 plugins 리스트를 보여줌. 관련된 문서로 바로 이동할 수 있음. vue 측에서 이번에 각종 옵션들을 플러그인 형태로 구성하면서 cli plugins 를 만들기도 권장하고 있는 것 같음. <a href="https://cli.vuejs.org/dev-guide/plugin-dev.html#core-concepts" target="_blank" rel="noopener">Plugin Development Guide</a>도 있음.</p><h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><p>npm version 관리를 위해 현재 설치된 version 과 wanted version, 그리고 latest version 을 보여줌. npm versioning 을 관리하기 위해 VSCode 의 extension 을 쓰거나 별도 tool 을 사용하고 있었는데 여기서도 충분할 것 같음. 마찬가지로 공식 문서로 바로 이동할 수 있음.</p><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><p>Vue 에서는 현재 프로젝트의 설정들을 override 하거나 별도로 추가하기 위해 <code>vue.config.js</code>를 제공하고 있음. 이 부분을 GUI 로도 보여줌. eslint rules 또한 GUI 상에서 끄고 켤 수 있음. (별의별 기능이 다 있음.)</p><h3 id="npm-tasks"><a href="#npm-tasks" class="headerlink" title="npm tasks"></a>npm tasks</h3><p>GUI 상에서 바로 실행할 수 있으며 각각의 명령어에 대해 output, dashboard, analyzer 까지 지원됨. 기존에 <code>webpack-bundle-analyzer</code> 나 webpack 이 내뱉는 지저분한 로그들을 정리하기 위해 <code>webpack-stylish</code> 등을 사용했던 편이라 굉장히 좋아보임. 참고로 기본으로 세팅되는 npm scripts <code>vue-cli-service</code>를 통해 <code>serve</code>하게 되면 <a href="https://github.com/geowarin/friendly-errors-webpack-plugin" target="_blank" rel="noopener">friendly-errors-webpack-plugin</a>을 기반으로 로그가 만들어짐.</p><h2 id="추가-개발-환경"><a href="#추가-개발-환경" class="headerlink" title="추가 개발 환경"></a>추가 개발 환경</h2><p>개발하기 위해서는 개발자 도구가 빠질 수 없음. Vue 역시 Chrome extension 을 제공하고 있음. <a href="https://github.com/vuejs/vue-devtools#vue-devtools" target="_blank" rel="noopener">vue-devtools</a> 이 녀석을 사용하면 됨. react의 경우 redux-devtools가 따로 있는데 Vue는 이걸로 Vuex까지 지원하고 있음.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Vue 를 시작하는데 있어서 @vue/cli 의 여러 기능 중 필요한 기본적인 것들에 대해서만 다뤘음. 보다 자세한 @vue/cli 의 3 version 정보가 필요하다면 Evan You 가 쓴 이 <a href="https://medium.com/the-vue-point/vue-cli-3-0-is-here-c42bebe28fbb" target="_blank" rel="noopener">아티클</a>을 읽어보거나 release note 를 확인해보면 좋을 듯. 회사에서 업무로 프로젝트 스캐폴딩 도구를 담당하기도 했고 생산성에 관심이 많아 재미있게 봤음. 너무 잘 만들었음.</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noopener">https://github.com/vuejs/vue-cli</a></li><li><a href="https://medium.com/the-vue-point/vue-cli-3-0-is-here-c42bebe28fbb" target="_blank" rel="noopener">https://medium.com/the-vue-point/vue-cli-3-0-is-here-c42bebe28fbb</a></li><li><a href="https://blog.logrocket.com/vue-cli-3-the-deep-dive-41dff070ac4a" target="_blank" rel="noopener">https://blog.logrocket.com/vue-cli-3-the-deep-dive-41dff070ac4a</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vuetorials.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Vuetorials-1-vue-cli-3-0&quot;&gt;&lt;a href=&quot;#Vuetorials-1-vue-cli-3-0&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Vue" scheme="https://jaeyeophan.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jaeyeophan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>[Vuetorials] 0. 들어가면서</title>
    <link href="https://jaeyeophan.github.io/2018/10/21/Vuetorials-0-intro/"/>
    <id>https://jaeyeophan.github.io/2018/10/21/Vuetorials-0-intro/</id>
    <published>2018-10-21T07:21:13.000Z</published>
    <updated>2018-11-17T08:49:15.550Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vuetorials.png" alt=""></p><h1 id="Vuetorials-0-들어가면서"><a href="#Vuetorials-0-들어가면서" class="headerlink" title="[Vuetorials] 0. 들어가면서"></a>[Vuetorials] 0. 들어가면서</h1><h2 id="구성"><a href="#구성" class="headerlink" title="구성"></a>구성</h2><p>각 내용들은 짧은 호흡으로 진행됩니다. @vue/cli 로 시작하여 Vue 에 대한 기본적인 내용을 다루고 Vue 생태계를 구성하고 있는 라이브러리들도 함께 다뤄볼 예정입니다. vuex, vue-router, vue-server-renderer, nuxt 순서가 되지 않을까 싶습니다. 그리고 React 와의 비교가 약간씩 들어갈 예정입니다.</p><p>뷰토리얼은 Vue 라는 라이브러리의 A 부터 Z 까지 전부 다루지 않습니다. Vue 의 모든 것을 처음부터 끝까지 다 보려는 목적이라면 책을 보거나 다른 강의나 튜토리얼 포스트를 보세요! 공식 문서 또한 매우 잘 되어있기 때문에 이러한 부분은 별도로 다루지 않습니다.</p><p>필자도 공부하면서 정리 중이라 모르는 것은 모른다고 하고 있습니다. (물론 알게 되면 업데이트 예정입니다.)</p><h2 id="그럼-뭘-다룰-예정인가"><a href="#그럼-뭘-다룰-예정인가" class="headerlink" title="그럼 뭘 다룰 예정인가?"></a>그럼 뭘 다룰 예정인가?</h2><ul><li>개발에 들어갈때 혼동이 될 수 있는 부분</li><li>매직이 어떻게 동작하는지</li><li>리액트와 비교</li><li>필자가 이해한 라이브러리가 추구하는 철학과 방향</li><li>…</li></ul><h2 id="이-튜토리얼을-따라가볼-대상자는-누군가"><a href="#이-튜토리얼을-따라가볼-대상자는-누군가" class="headerlink" title="이 튜토리얼을 따라가볼 대상자는 누군가?"></a>이 튜토리얼을 따라가볼 대상자는 누군가?</h2><ol><li>React 또는 다른 라이브러리로 개발을 해봤는데 Vue 도 궁금한 개발자.</li><li>Vue 로 개발 중인 개발자.</li><li>Vue 공식 문서 정도 본 개발자.</li><li>그냥 Vue 를 훑어보고 싶은 개발자.</li></ol><h2 id="‘음슴체’로-작성"><a href="#‘음슴체’로-작성" class="headerlink" title="‘음슴체’로 작성"></a>‘음슴체’로 작성</h2><p>뷰토리얼(Vuetorials)이 다른 튜토리얼과 다른 점은 음슴체로 진행된다는 점입니다.(ㅋㅋㅋ) 포스트 하나를 작성하는데 문체를 다듬거나 어순을 변경하는 등 부수적인 요소에 많은 시간이 소요됐습니다. 책을 쓰는 것도 아닌데 조금 더 편한 문체로 작성해도 되지 않나? 라는 생각에 시도해봤습니다.</p><h2 id="순서"><a href="#순서" class="headerlink" title="순서"></a>순서</h2><ol><li><a href="https://jaeyeophan.github.io/2018/10/21/Vuetorials-1-vue-cli-3-0/">@vue-cli 3.0</a></li><li><a href="https://jaeyeophan.github.io/2018/10/21/Vuetorials-2-Vue-concept/">Vue 의 전반적인 concept</a></li><li><a href="https://jaeyeophan.github.io/2018/10/23/Vuetorials-3-Component-API/">Vue 의 Component API</a></li><li><a href="https://jaeyeophan.github.io/2018/11/05/Vuetorials-4-Internal-Component/">Vue 의 내장 컴포넌트</a></li><li><a href="https://jaeyeophan.github.io/2018/11/07/Vuetorials-5-Vuex/">Vuex API</a></li><li><a href="https://jaeyeophan.github.io/2018/11/16/Vuetorials-6-Vuex-Module-pattern/">Vuex Module Pattern</a></li><li><a href="https://jaeyeophan.github.io/2018/11/17/Vuetorials-7-Vuex-Best-Practice/">Vuex Best Practice로 가는 여정</a></li></ol><blockquote><p>Let’s Vue!</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vuetorials.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Vuetorials-0-들어가면서&quot;&gt;&lt;a href=&quot;#Vuetorials-0-들어가면서&quot; class=&quot;headerlink&quot; title=&quot;[Vuetor
      
    
    </summary>
    
      <category term="Vue" scheme="https://jaeyeophan.github.io/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://jaeyeophan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>[TS] 8. enum vs const enum</title>
    <link href="https://jaeyeophan.github.io/2018/06/16/TS-8-enum-vs-const-enum/"/>
    <id>https://jaeyeophan.github.io/2018/06/16/TS-8-enum-vs-const-enum/</id>
    <published>2018-06-16T06:02:44.000Z</published>
    <updated>2018-06-16T06:14:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/typescript.png" alt=""></p><h1 id="TS-8-enum-vs-const-enum"><a href="#TS-8-enum-vs-const-enum" class="headerlink" title="[TS] 8. enum vs const enum"></a>[TS] 8. enum vs const enum</h1><p>TypeScript 문법 중 <code>enum</code> 이라는 것이 있다. 주로 상수를 선언할 때 namespace 를 줘서 상수끼리의 응집도를 높이고 그 의미를 더할 수 있으며 VSCode 의 auto complete 의 지원을 받을 때 유용하다. 이 <code>enum</code> 키워드를 사용하는 방법에는 두 가지가 존재한다. 그냥 <code>enum</code> 키워드를 사용해 선언할 수 있으며 <code>const</code> 키워드와 함께 사용하여 <code>const enum</code>으로 선언할 수 있다.</p><p>이 두 가지는 무엇이 다를까.</p><p><a href="http://www.typescriptlang.org/play/" target="_blank" rel="noopener">TypeScript Playground</a>에 가서 JavaScript 로 compile 된 모습을 먼저 살펴보자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> JustEnumNumber &#123;</span><br><span class="line">  zero,</span><br><span class="line">  one</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(JustNumber.one); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>간단한 <code>enum</code> 을 선언했다. 이 <code>JustEnumNumber</code>는 다음과 같이 transpile 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> JustEnumNumber;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">JustEnumNumber</span>) </span>&#123;</span><br><span class="line">  JustEnumNumber[(JustEnumNumber[<span class="string">"zero"</span>] = <span class="number">0</span>)] = <span class="string">"zero"</span>;</span><br><span class="line">  JustEnumNumber[(JustEnumNumber[<span class="string">"one"</span>] = <span class="number">1</span>)] = <span class="string">"one"</span>;</span><br><span class="line">&#125;)(JustEnumNumber || (JustEnumNumber = &#123;&#125;));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(JustNumber.one); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><code>enum</code>에 대해 알아본 적이 있다면 익숙한 JavaScript 형태로 transpile 되는 것을 확인할 수 있다. 사실 저 코드는 조금 복잡해보여도 다음과 같은 코드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> JustEnumNumber;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">JustEnumNumber</span>) </span>&#123;</span><br><span class="line">  JustEnumNumber[<span class="string">"zero"</span>] = <span class="number">0</span>;</span><br><span class="line">  JustEnumNumber[<span class="string">"one"</span>] = <span class="number">1</span>;</span><br><span class="line">  JustEnumNumber[<span class="number">0</span>] = <span class="string">"zero"</span>;</span><br><span class="line">  JustEnumNumber[<span class="number">1</span>] = <span class="string">"one"</span>;</span><br><span class="line">&#125;)(JustEnumNumber || (JustEnumNumber = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>이젠 <code>const enum</code>을 보자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> ConstEnumNumber &#123;</span><br><span class="line">  zero,</span><br><span class="line">  one</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ConstEnumNumber.one); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>아까와 같은 간단한 <code>enum</code>을 선언했고 플레이그라운드에서 JavaScript 도 transpile 을 해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="comment">/* one */</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><code>enum</code> 구현체는 다 사라지고 console 을 위한 코드만 남아있다. <code>const</code> 키워드를 사용하고 안 하고의 차이가 좀 큰 것 같다.</p><p>다시 <code></code>JustEnumNumber<code>코드를 보자.</code>enum`만으로 선언할 경우, namespace 를 위한 변수가 선언이 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> JustEnumNumber;</span><br></pre></td></tr></table></figure><p>그리고 선언된 변수를 객체로 우리가 원하는 상수값들을 선언하게 된다. 이 때 선언된 변수는 transpile 되어서도 남아있게 되어 우리는 <code>enum</code>으로 선언한 객체 자체에 접근할 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(JustEnumNumber); <span class="comment">// [object object]</span></span><br></pre></td></tr></table></figure><p>하지만 <code>const enum</code>으로 enum 을 선언하게 되면 compile 단계에서 namespace 가 날라가게 되므로 접근할 수 없다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(ConstEnumNumber); <span class="comment">// [ERROR] 'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment or type query.</span></span><br></pre></td></tr></table></figure><p>내부 상수값들이 전부 compile 단계에서 대치된 것이다. 내부 필드를 전부 상수로 변경하기 때문에 런타임에 의존 모듈의 영향을 받지 않게 되며, 코드 크기가 더 적기 때문에 더 선호된다고 한다.</p><p>사실 이 부분은 TypeScript Official Document 에 다음과 같이 나와있다.</p><blockquote><p>To avoid paying the cost of extra generated code and additional indirection when accessing enum values, it’s possible to use <code>const</code> enums.</p></blockquote><p>그렇다면 <code>enum</code>만으로 선언하는 경우는 언제일까.</p><p>우선 namespace 가 남아있으니 우리는 enum 을 이렇게도 사용할 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(JustEnumNumber[JustEnumNumber.one]); <span class="comment">// one</span></span><br></pre></td></tr></table></figure><p>상수만으로 로그가 찍히면 알아보기 힘드니 reverse 참조를 하여 로그를 찍을 수 있다. lookup object 로 사용하는 것이다. 하지만 이렇게 선언된 enum 은 런타임에 이 lookup object 를 통해 참조가 이루어지므로 조심해야 한다. 물론 webpack 환경에서는</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 scope 를 쳐주지만 test 환경에서는 browser 객체(ex. window…)를 참조하는 경우 에러가 발생할 수 있다.</p><p>참고한 블로그의 문장을 인용하여 해당 글을 마친다.</p><blockquote><p><code>const enum</code> is a <strong>compile-time only</strong> feature, while the original <code>enum</code> is a <strong>runtime + compile-time</strong>feature. Most projects will be well suited for <code>const enum</code>, but there may be cases where <code>enum</code> is preferred.</p></blockquote><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://www.typescriptlang.org/docs/handbook/enums.html" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/enums.html</a></li><li><a href="https://www.sitepoint.com/10-essential-typescript-tips-tricks-angular/?WT.mc_id=link-twitter-jeliknes" target="_blank" rel="noopener">https://www.sitepoint.com/10-essential-typescript-tips-tricks-angular/?WT.mc_id=link-twitter-jeliknes</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/typescript.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;TS-8-enum-vs-const-enum&quot;&gt;&lt;a href=&quot;#TS-8-enum-vs-const-enum&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="TypeScript" scheme="https://jaeyeophan.github.io/categories/TypeScript/"/>
    
    
      <category term="ts" scheme="https://jaeyeophan.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>[TS] 7. TypeScript type system</title>
    <link href="https://jaeyeophan.github.io/2018/01/10/TS-7-TypeScript-type-system/"/>
    <id>https://jaeyeophan.github.io/2018/01/10/TS-7-TypeScript-type-system/</id>
    <published>2018-01-10T04:31:30.000Z</published>
    <updated>2018-01-10T04:31:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/typescript.png" alt=""></p><h1 id="TS-7-Typescript’s-Type-System"><a href="#TS-7-Typescript’s-Type-System" class="headerlink" title="[TS] 7. Typescript’s Type System"></a>[TS] 7. Typescript’s Type System</h1><h3 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h3><ul><li>TypeScript의 Type Checking System</li><li>Type Inference</li><li>Type Assertion</li><li>Type Guards</li><li>Type Compatibility</li></ul><p><br></p><h2 id="TypeScript의-Typing-Checking-System"><a href="#TypeScript의-Typing-Checking-System" class="headerlink" title="TypeScript의 Typing Checking System"></a>TypeScript의 Typing Checking System</h2><p><code>TypeScript</code>에서의 Type System에 대한 이해를 하기 전, 기존 프로그래밍 언어의 큰 두 축인 정적 언어와 동적 언어에 대한 정의를 다시 한 번 살펴볼 필요가 있습니다.</p><h3 id="정적언어-Static-Language"><a href="#정적언어-Static-Language" class="headerlink" title="정적언어 (Static Language)"></a>정적언어 (Static Language)</h3><ul><li>변수(variables) 또는 함수(function)의 <code>Type</code>을 <strong>미리</strong> 지정해야 한다.</li><li>컴파일되는 시점에 Type Check를 수행한다.</li></ul><h3 id="동적-언어-Dynamic-Language"><a href="#동적-언어-Dynamic-Language" class="headerlink" title="동적 언어 (Dynamic Language)"></a>동적 언어 (Dynamic Language)</h3><ul><li>변수(variables) 또는 함수(function)의 <code>Type</code>을 지정하지 않는다.</li><li>Type Check는 런타임(runtime) 환경에서나 알 수 있다.</li></ul><h3 id="Duck-Typing"><a href="#Duck-Typing" class="headerlink" title="Duck Typing"></a>Duck Typing</h3><p>덕 타이핑(Duck Typing)이라고 많이 들어보셨을 텐데요, 현재 이 덕 타이핑 체계를 기반으로 동적 언어에 타입을 추론하는 언어는 GoLang과 Python 등이 있습니다. 하지만 TypeScript는 이 덕타이핑과는 조금 다른 체계로 <strong>Typing</strong>을 하고 있습니다.</p><blockquote><p>덕 타이핑에 대한 보다 자세한 내용은 <a href="https://www.google.co.kr/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;ved=0ahUKEwjj5dzEl8PYAhXCNJQKHfG9DdYQFggxMAE&amp;url=http%3A%2F%2Fwww.popit.kr%2Fgolang%25EC%259C%25BC%25EB%25A1%259C-%25EB%25A7%258C%25EB%2582%2598%25EB%25B3%25B4%25EB%258A%2594-duck-typing%2F&amp;usg=AOvVaw1dXNKFpMsVofdtJ-QOglzu" target="_blank" rel="noopener">여기</a>를 참고해주세요.</p></blockquote><h3 id="Structural-typing"><a href="#Structural-typing" class="headerlink" title="Structural typing"></a>Structural typing</h3><p>TypeScript는 <strong>Structural typing</strong> (구조적 타이핑)을 기반으로 타입 시스템을 갖추고 있습니다. 구조적 타이핑이란, <code>멤버</code>에 따라 타입을 <strong>연관짓는</strong> 방법을 말합니다. 구조적 타이핑과 반대인 방법으로 <code>nominal typing</code>이 있습니다. 우리가 알고 있는 일반적인 정적 언어인 C#, Java는 이 <code>nominal typing</code> 방식으로 <strong>type checking</strong>이 이루어집니다.</p><p><em>Official Document</em>에 나온 예제를 통해 설명드립니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Named &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;  </span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Named;</span><br><span class="line">p = <span class="keyword">new</span> Person(); <span class="comment">// Ok, because of structural typing</span></span><br></pre></td></tr></table></figure></p><p>위 코드를 C# 또는 Java의 문법에 맞게 변경한다면 동작하지 않는 잘못된 코드가 됩니다. 하지만 TypeScript에서는 정상적으로 동작합니다. <code>Named</code>와 <code>Person</code> 두 가지는 오로지 <code>name</code>이라는 프로퍼티(or 멤버)만 갖고 있는 타입이므로 서로 <code>compatibility</code> 하다고 볼 수 있습니다. 때문에 위 코드는 문제되지 않습니다. (compatibility에 대해서는 뒤에서 알아봅니다.)</p><p><br></p><h2 id="Type-Inference"><a href="#Type-Inference" class="headerlink" title="Type Inference"></a>Type Inference</h2><p>‘누가봐도 이 변수는 이 타입이다.’라는 것에 대해 TypeScript가 지원해주는 것을 <strong>타입 추론</strong> 이라고 합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">`jbee`</span>;</span><br></pre></td></tr></table></figure></p><p><code>name</code>이라는 변수는 <code>string</code> 타입의 변수가 됩니다. 그렇기 때문에 굳이 <code>: string</code>이라고 타입을 지정해주지 않아도 다음과 같이 에러가 발생합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="number">1</span>; <span class="comment">// Error: Type '1' is not assignable to type 'string'.</span></span><br></pre></td></tr></table></figure></p><p>그렇다면 다음과 같은 경우에는 어떻게 추론될까요?<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mixedArr = [<span class="number">0</span>, <span class="number">1</span>, <span class="string">`jbee`</span>];</span><br></pre></td></tr></table></figure></p><p><code>number</code>에 해당되는 value와 <code>string</code>에 해당하는 value가 공존하기 때문에 위 코드에서 <code>mixedArr</code>은 <code>(number | string)[]</code>의 타입을 갖게 됩니다. 이렇게 여러 타입이 공존하는 경우에 추론하여 지정되는 타입을 <strong>Best common type</strong>이라고 합니다.</p><p><br></p><h2 id="Type-Assertion"><a href="#Type-Assertion" class="headerlink" title="Type Assertion"></a>Type Assertion</h2><p>이 변수의 타입은 분명 <code>A</code>인데 TypeScript에서 보수적으로 처리하여 에러를 발생시키는 경우가 있습니다. 이럴 경우 해당 변수를 <code>A</code>라고 명시하여 에러를 사라지게 할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Todo = &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  text: <span class="built_in">string</span>;</span><br><span class="line">  completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Todos = Todo[];</span><br></pre></td></tr></table></figure></p><p>위와 같이 <code>Todo</code> 타입과 <code>Todos</code> 타입을 지정한 상황이라고 했을 때를 예로 들어보겠습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState: Todos = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">0</span>,</span><br><span class="line">    text: <span class="string">'Study RxJS'</span>,</span><br><span class="line">    completed: <span class="literal">false</span>,</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>위 코드에서 <code>Todos</code>에 해당하는 타입을 제대로 지정해줬지만 뭔가 아쉬움이 남을 수 있는데요, 이 때 두 가지 방법을 사용할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState: Todos = [</span><br><span class="line">  &lt;TODO&gt;&#123;</span><br><span class="line">    id: <span class="number">0</span>,</span><br><span class="line">    text: <span class="string">'Study RxJS'</span>,</span><br><span class="line">    completed: <span class="literal">false</span>,</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>위 코드처럼 <code>&lt;&gt;</code>을 사용하거나<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState: Todos = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">0</span>,</span><br><span class="line">    text: <span class="string">'Study RxJS'</span>,</span><br><span class="line">    completed: <span class="literal">false</span>,</span><br><span class="line">  &#125; <span class="keyword">as</span> Todo</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>위 코드처럼 <code>as</code> 키워드를 사용할 수 있습니다. 두 가지 모두 동일하지만 <code>tsx</code>와 함께 사용하기 위해서는 <code>as</code> 키워드를 사용하는 것이 좋습니다.</p><blockquote><p>[!] 이 Type Assertion은 Type Casting과는 다릅니다. 자세한 내용은 <a href="https://hyunseob.github.io/2017/12/12/typescript-type-inteference-and-type-assertion/" target="_blank" rel="noopener">DailyEngineering - 타입 추론과 타입 단언</a>을 참고해주세요!</p></blockquote><p><br></p><h2 id="Type-Guards"><a href="#Type-Guards" class="headerlink" title="Type Guards"></a>Type Guards</h2><p>자바스크립트에서는 <code>typeof</code> 또는 <code>instanceof</code>와 같은 오퍼레이터가 타입을 확인해주는 역할을 했었습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.state[key] !== <span class="keyword">typeof</span> newData) &#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>하지만 이 방법은 런타임에서 타입 체크를 수행하게 됩니다. 따라서 컴파일 시점에서는 올바른 타입인지 알 수 없습니다. TypeScript에서는 컴파일 시점에서 타입 체크를 수행할 수 있도록 <code>Type Guard</code>를 지원합니다.</p><p><br></p><h3 id="typeof-instanceof"><a href="#typeof-instanceof" class="headerlink" title="typeof, instanceof"></a><code>typeof</code>, <code>instanceof</code></h3><p>TypeScript에서도 마찬가지로 <code>typeof</code>와 <code>instanceof</code> 오퍼레이터를 지원합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setNumberOrString</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x.subtr(<span class="number">1</span>)); <span class="comment">// Error</span></span><br><span class="line">    <span class="built_in">console</span>.log(x.substr(<span class="number">1</span>)); <span class="comment">// OK</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(typof x); <span class="comment">// number</span></span><br><span class="line">  &#125;</span><br><span class="line">  x.substr(<span class="number">1</span>); <span class="comment">// Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 코드에서 <code>if-block</code>내에서의 <code>x</code>변수의 타입은 <code>string</code>일 수 밖에 없다는 것을 컴파일 시점에 체크하여 transpiler가 Error를 발생시키는 경우입니다. 이 예제와 비슷한 방법으로 <code>instanceof</code> 오퍼레이터를 사용할 수 있습니다. <code>instanceof</code>는 클래스를 기반으로 생성된 인스턴스의 타입을 판단하는데 사용됩니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Pet &#123;</span><br><span class="line">  name = <span class="number">123</span>;</span><br><span class="line">  common = <span class="string">'123'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Basket &#123;</span><br><span class="line">  size = <span class="number">123</span>;</span><br><span class="line">  common = <span class="string">'123'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">arg: Pet | Basket</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Pet) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.name); <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.size); <span class="comment">// Error!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Basket) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.name); <span class="comment">// Error!</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.size); <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(arg.common); <span class="comment">// OK</span></span><br><span class="line">  <span class="built_in">console</span>.log(arg.name); <span class="comment">// Error!</span></span><br><span class="line">  <span class="built_in">console</span>.log(arg.size); <span class="comment">// Error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>typeof</code>와 마찬가지로 <code>instanceof</code>로 필터링 된 block 내부에서 <strong>Type checking</strong>이 이루어집니다.</p><p><br></p><h3 id="in"><a href="#in" class="headerlink" title="in"></a><code>in</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  y: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">q: A | B</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'x'</span> <span class="keyword">in</span> q) &#123;</span><br><span class="line">    <span class="comment">// q: A</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// q: B</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>A</code> 또는 <code>B</code>를 유니온 타입으로 받을 수 있는 <code>execute</code> 함수 내에서 각각에 대해 다른 처리를 할 경우, <code>in</code>이라는 오퍼레이터를 사용할 수 있습니다. 해당 오퍼레이터는 check하고자 하는 타입에 해당 프로퍼티가 존재하는지의 유무를 판단할 수 있습니다.</p><p><br></p><h3 id="kind-Literal-Type-Guard"><a href="#kind-Literal-Type-Guard" class="headerlink" title=".kind Literal Type Guard"></a><code>.kind</code> Literal Type Guard</h3><p>사용자에 의해 <code>type</code>으로 정의된 타입에 대해서, 즉 TypeScript 내부에서 지원하는 primitive type이 아닌 <strong>사용자 정의 타입에 대해서 타입 검사를 수행할 때</strong>, <code>.kind</code>를 사용할 수 있습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = &#123;</span><br><span class="line">  kind: <span class="string">'foo'</span>, <span class="comment">// Literal type </span></span><br><span class="line">  foo: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bar = &#123;</span><br><span class="line">  kind: <span class="string">'bar'</span>, <span class="comment">// Literal type </span></span><br><span class="line">  bar: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">arg: Foo | Bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arg.kind === <span class="string">'foo'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.foo); <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.bar); <span class="comment">// Error!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 코드에서 처럼 <code>type</code> 키워드를 사용하여 별도 타입을 지정할 때, <code>kind</code>라는 프로퍼티를 추가하여 타입 검사를 수행할 수 있습니다.</p><p><br></p><h3 id="User-Defined-Type-Guards"><a href="#User-Defined-Type-Guards" class="headerlink" title="User Defined Type Guards"></a>User Defined Type Guards</h3><p>메소드를 별도로 분리하여 Type Guard를 지정할 수 있습니다. 아까 지정한 interface A로 만들어보겠습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Define Type Guard</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isA</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">arg</span> <span class="title">is</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg.x !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>arg is A</code>라는 타입으로 <code>isA</code> 메소드가 Type Guard의 역할을 수행한다는 것을 명시할 수 있습니다. if 내부에 들어가는 로직을 별도로 추출하여 보다 가독서이 좋은 코드를 작성할 수 있습니다.</p><p><br></p><h2 id="Type-Compatibility"><a href="#Type-Compatibility" class="headerlink" title="Type Compatibility"></a>Type Compatibility</h2><p>한국어로 번역하게 되면 <strong>타입 호환성</strong> 정도로 할 수 있겠는데요, TypeScript는 위에서 언급했듯이 <strong>Structural subtyping</strong>을 기반으로 Type checking을 하기 때문에 이를 기반으로 타입 간의 호환성을 고려할 수 있습니다.</p><h4 id="1-Comparing-two-Objects"><a href="#1-Comparing-two-Objects" class="headerlink" title="1. Comparing two Objects"></a>1. Comparing two Objects</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123;name: <span class="string">`Jbee`</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> y = &#123;name: <span class="string">`James`</span>, age: <span class="number">34</span>&#125;;</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// OK!</span></span><br><span class="line">y = x; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><p>위 코드에서 <code>x</code>는 <code>{name: string}</code> 타입으로 추론되며, <code>y</code>는 <code>{name: string, age: number}</code>로 추론됩니다. 이 경우 <code>x = y</code>는 <code>y</code>에 <code>name</code>이라는 속성이 있으므로 가능하지만 <code>y = x</code>의 경우, <code>x</code>에는 <code>age</code>라는 속성이 없으므로 에러가 발생합니다.</p><h4 id="2-Comparing-two-functions"><a href="#2-Comparing-two-functions" class="headerlink" title="2. Comparing two functions"></a>2. Comparing two functions</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="function">(<span class="params">b: <span class="built_in">number</span>, s: <span class="built_in">string</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// OK</span></span><br><span class="line">x = y; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>함수일 경우에는 객체인 경우와 조금 다른 것을 볼 수 있습니다. 위 코드에서 두 <code>x</code>, <code>y</code>함수는 parameter 만 다르게 정의되어 있습니다. 이 경우, <code>x</code> 함수에 전달할 수 있는 parameter의 경우의 수가 y에 모두 해당하므로 <code>y = x</code>가 정상적으로 동작합니다. 하지만 그 반대인 <code>x = y</code>는 <code>y</code> 함수에 전달할 수 있는 parameter를 <code>x</code>가 모두 포용할 수 없으므로 에러가 발생합니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;name: <span class="string">`Jbee`</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> y = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;name: <span class="string">`James`</span>, age: <span class="number">34</span>&#125;);</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// OK!</span></span><br><span class="line">y = x; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></p><p>이번에는 return value의 type이 다른 경우입니다. 이 경우에는 함수의 경우를 따르지 않고 객체인 경우를 따르게 됩니다.</p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>TypeScript의 단순한 문법을 조금 넘어서 어떻게 Type Checking이 이루어지는지 살펴봤습니다.<br>감사합니다.</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://www.typescriptlang.org/docs/handbook/type-inference.html" target="_blank" rel="noopener">TypeScript Official Document - Type Inference</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html" target="_blank" rel="noopener">TypeScript Official Document - Type Compatibility</a></li><li><a href="http://www.popit.kr/golang%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%82%98%EB%B3%B4%EB%8A%94-duck-typing/" target="_blank" rel="noopener">Golang으로 만나보는 duck typing</a></li><li><a href="https://medium.com/@thejameskyle/type-systems-structural-vs-nominal-typing-explained-56511dd969f4" target="_blank" rel="noopener">Type Systems: Structural vs Nominal typing explained</a></li><li><a href="https://basarat.gitbooks.io/typescript/docs/types/typeGuard.html" target="_blank" rel="noopener">TypeScript Deep dive - Type Guard</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/typescript.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;TS-7-Typescript’s-Type-System&quot;&gt;&lt;a href=&quot;#TS-7-Typescript’s-Type-System&quot; class=&quot;head
      
    
    </summary>
    
      <category term="TypeScript" scheme="https://jaeyeophan.github.io/categories/TypeScript/"/>
    
    
      <category term="ts" scheme="https://jaeyeophan.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>[TS] 6. Decorator</title>
    <link href="https://jaeyeophan.github.io/2018/01/09/TS-6-Decorator/"/>
    <id>https://jaeyeophan.github.io/2018/01/09/TS-6-Decorator/</id>
    <published>2018-01-09T00:59:14.000Z</published>
    <updated>2018-01-09T00:59:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/typescript.png" alt=""></p><h1 id="TS-6-Decorators"><a href="#TS-6-Decorators" class="headerlink" title="[TS] 6. Decorators"></a>[TS] 6. Decorators</h1><p>이번 포스팅에서는 현재 JavaScript에서도 <a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noopener">ts39/proposal stage-2</a>에 올라와있는 <code>Decorator</code>에 대해 알아보겠습니다.</p><h3 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h3><ul><li>Setup</li><li>Intro</li><li>Decorator to method</li><li>Decorator to class</li><li>Decorator with parameter</li></ul><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><p>자바스크립트 babel환경에서 데코레이터를 테스트해보기 위해서는 babel 플러그인이 추가적으로 필요합니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install babel-core babel-plugin-transform-decorators-legacy --save-dev</span><br></pre></td></tr></table></figure></p><p><code>babel-core</code>를 기본으로 하며, babel-plugin을 추가적으로 설치해줍니다.<br><figure class="highlight"><figcaption><span>.babelrc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  //...</span><br><span class="line">  "plugins": ["transform-decorators-legacy"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>해당 프로젝트의 babel설정을 담고 있는 <code>.babelrc</code>파일에 설치한 플러그인을 추가해줍니다. 보다 구체적인 해당 개발환경은 <a href="https://github.com/JaeYeopHan/esnext_labs" target="_blank" rel="noopener">여기</a>를 참고해주세요.</p><p>TyeScript에서는 <code>tsconfig.json</code>의 <code>compilerOption</code>을 다음과 같이 변경해줍니다.<br><figure class="highlight json"><figcaption><span>tsconfig.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"target"</span>: <span class="string">"ES5"</span>,</span><br><span class="line">        <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>TypeScript(JavaScript)에서 <code>@</code>이라는 character로 사용하는 문법을 <code>Decorator(데코레이터)</code>라고 합니다. 자바를 경험해보신 분이라면 <code>Annotation</code>인가? 라고 생각하기 쉬운데요, 조금 다릅니다. 데코레이터는 <strong>함수</strong> 라고 할 수 있습니다. 데코레이터는 말 그대로 코드 조각을 장식해주는 역할을 하며 타입스크립트에서는 그 기능을 함수로 구현할 수 있습니다.</p><p>Decorator는 클래스 선언, 메서드, 접근 제어자, 속성 또는 매개 변수에 첨부 할 수 있는 특별한 종류의 선언입니다. 데코레이터는 <code>@expression</code> 형식을 사용하는데, expression은 데코레이팅 된 선언에 대한 정보와 함께 존재하며 이는 <strong>런타임에</strong> 호출됩니다.</p><h4 id="참조-reference"><a href="#참조-reference" class="headerlink" title="참조(reference)"></a>참조(reference)</h4><p>데코레이터는 <code>@decorator</code>과 같이 사용할 수 있으며 <code>@[name]</code>의 형식일 때 <code>name</code>에 해당하는 이름의 함수를 참조하게 됩니다.</p><h4 id="실행-시점-execute-time"><a href="#실행-시점-execute-time" class="headerlink" title="실행 시점(execute time)"></a>실행 시점(execute time)</h4><p>이렇게 데코레이터로 정의된 함수는 데코레이터가 적용된 메소드가 실행되거나 클래스가 <code>new</code>라는 키워드를 통해 인스턴스화 될 때가 아닌 런타임 때 실행됩니다. 즉, 매번 실행되지 않습니다.</p><p><em>그럼 데코레이터가 메소드에 적용되는 경우, 클래스에 적용되는 경우, 프로퍼티에 적용되는 경우 이렇게 세 가지로 나누어 코드를 살펴보겠습니다.</em></p><p><br></p><h2 id="Decorator-to-Method"><a href="#Decorator-to-Method" class="headerlink" title="Decorator to Method"></a>Decorator to Method</h2><blockquote><p>메소드에 적용되는 경우</p></blockquote><p>우선 데코레이터로 사용할 <code>chaining</code>이라는 함수를 정의해줍니다.<br><figure class="highlight ts"><figcaption><span>decorator.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chaining</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(target); <span class="comment">// &#123;bark: f, constructor: f&#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// bark</span></span><br><span class="line">  <span class="built_in">console</span>.log(descriptor); <span class="comment">// &#123;value: f, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 함수는 추후 메소드에 <code>@chaining</code> 형식으로 사용될 함수입니다. <code>@</code>과 함께 함수가 호출되는 경우 받게 되는 파라미터는 다음과 같습니다.</p><blockquote><ul><li>target : 속성을 정의하고자 하는 객체</li><li>name : 속성의 이름</li><li>descriptor : 새로 정의하고자 하는 속성에 대한 설명</li></ul></blockquote><p>이는 <code>Object.defineProperty()</code>를 통해 이를 정의하고 있기 때문입니다.</p><p><code>target</code>은 해당 메소드가 속해있는 클래스 프로토타입을 가리키게 되며 <code>Pet</code>의 프로토타입에는 <code>constructor</code>와 <code>bark</code>메소드가 있는 것을 확인할 수 있습니다. <code>name</code>은 데코레이터가 적용된 메소드의 이름이 됩니다. <code>descriptor</code>는 <code>defineProperty</code>에서 정의할 수 있는 각각의 속성값들이 됩니다.</p><p>Object의 <code>defineProperty</code>에 해당하는 보다 자세한 내용은 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">여기</a>에서 살펴보실 수 있습니다. 그럼 각각을 활용해서 <code>chaining</code> 기능을 구현해보겠습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Decorator to method</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chaining</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fn: <span class="built_in">Function</span> = descriptor.value;</span><br><span class="line"></span><br><span class="line">  descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">    fn.apply(target, args);</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>descriptor의 <code>value</code>가 데코레이터가 적용된 함수, 즉 실행 대상이라고 할 수 있습니다. <code>descriptor.value</code>를 재정의(override)하기 전에 <code>fn</code>이라는 변수로 caching해둔 다음, 호출한 후의 일을 정의하기 위해 위와 같이 재정의 해줍니다. 재정의 하기 전 caching 해둔 함수를 호출하기 위해서 <code>apply</code> 함수를 사용했습니다. 어떠한 변수가 얼만큼 전달될지 모르니 rest parameter를 통해 <code>fn</code>을 호출해주는 코드입니다.</p><p>위와 같이 <code>descriptor.value</code>가 재정의 되면 <code>chaining</code>이 적용된 메소드는 재정의된대로 호출되게 됩니다.</p><blockquote><p><code>apply</code> 함수에 대한 내용은 <a href="https://www.google.co.kr/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwj9wKqt1cDYAhUBtpQKHQNvC34QFggmMAA&amp;url=https%3A%2F%2Fdeveloper.mozilla.org%2Fko%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fapply&amp;usg=AOvVaw2tqAzWzgnT49rXId1wsV11" target="_blank" rel="noopener">여기</a>를 참고해주세요.</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Pet &#123;</span><br><span class="line">  <span class="meta">@chaining</span></span><br><span class="line">  bark() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 적용해보겠습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pet = <span class="keyword">new</span> Pet();</span><br></pre></td></tr></table></figure></p><p><code>Pet</code>클래스에서 <code>bark</code>라는 메소드는 <code>Pet.prototype.bark</code>로 됩니다. class syntax 내부에서 위 코드에서는 <code>bark</code>라는 메소드가 <code>Pet</code>의 prototype의 프로퍼티로 추가되기 전에 <code>decorate</code> 함수가 실행되어 본래 <code>bark</code>라는 메소드에서 정의된 것에 추가적인 <strong>‘장식’</strong> 을 더해 prototype에 추가되도록 합니다.</p><blockquote><p>만약 compile target이 ES5보다 낮다면 <code>PropertyDescriptor</code> 값으로 <code>undefined</code>이 전달됩니다.</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pet.bark().bark();</span><br></pre></td></tr></table></figure><p>위 데코레이터의 효과로 <code>return this;</code>를 해주지 않아도 chaining 기능을 사용하여 메소드를 호출할 수 있습니다.</p><p><br></p><h2 id="Decorator-to-Class"><a href="#Decorator-to-Class" class="headerlink" title="Decorator to Class"></a>Decorator to Class</h2><p>하지만 데코레이터가 class에 적용되었을 때는 그 signature가 조금 달라집니다. 클래스 데코레이터는 클래스 선언 바로 전에 선언됩니다. 클래스 데코레이터는 클래스 생성자에 적용되며 클래스 정의를 관찰, 수정 또는 대체하는 데 사용할 수 있습니다.</p><p>클래스 데코레이터가 값을 반환하면 클래스 선언을 제공된 생성자 함수로 바꿉니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(target); <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(descriptor); <span class="comment">//undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>메소드에 데코레이터를 적용하듯이 데코레이터 함수를 선언하면 올바른 선언을 할 수 없습니다. 클래스에 적용되는 데코레이터 함수에 전달되는 인자는 <code>constructor</code>하나입니다. 제대로 된 데코레이터 선언은 다음과 같습니다.<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classDecorator</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123;<span class="keyword">new</span>(...args:<span class="built_in">any</span>[]):&#123;&#125;&#125;&gt;(<span class="keyword">constructor</span>:T) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="keyword">extends</span> <span class="keyword">constructor</span> &#123;</span><br><span class="line">    newProperty = <span class="string">"new property"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>클래스에 적용되는 데코레이터 함수 내에서 새로운 생성자 함수를 반환하면 원래 프로토타입을 유지해야 합니다. 런타임에 데코레이터를 적용하는 로직은 이를 수행하지 않기 때문입니다. 위 코드에서는 기존의 프로토타입을 유지하기 위해 적용되는 클래스의 <code>constructor</code>를 <code>extends</code> 합니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classDecorator</span></span><br><span class="line"><span class="keyword">class</span> Pet &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pet = <span class="keyword">new</span> Pet(<span class="string">"async"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pet.newProperty); <span class="comment">// new Property</span></span><br></pre></td></tr></table></figure><p><code>classDecorator</code> 데코레이터가 적용된 <code>Pet</code> 클래스의 인스턴스에는 <code>newProperty</code>가 존재하지 않지만 데코레이터 함수에서 해당 클래스의 constructor를 재정의했기 대문에 <code>newProperty</code>에 접근할 수 있습니다.</p><p><br></p><h2 id="Decorator-with-parameter"><a href="#Decorator-with-parameter" class="headerlink" title="Decorator with parameter"></a>Decorator with parameter</h2><blockquote><p>파라미터를 받는 데코레이터</p></blockquote><p>데코레이터 함수에 인자를 넘겨줄 수 있습니다. 이 인자는 무엇이든 될 수 있습니다. 예제 코드로 descriptor의 <code>enumerable</code> 속성을 변경하는 데코레이터를 만들어보겠습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enumerableToFalse</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">  descriptor.enumerable = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이렇게 정의하면 <code>enumerableToFalse</code>이 적용된 메소드의 enumerable 속성은 false가 됩니다. 위 <code>enumerableToFalse</code> 함수를 한 번 감싸서 반환하는 함수를 만들면 다음과 같습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enumerable</span>(<span class="params">value: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">    descriptor.enumerable = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 이 함수를 데코레이터 함수로 사용할 수 있습니다. <code>value</code>에 해당하는 값으로 데코레이터를 적용하는 메소드의 <code>enumerable</code>속성을 제어할 수 있습니다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Pet &#123;</span><br><span class="line">  <span class="meta">@enumerable</span>(<span class="literal">false</span>)</span><br><span class="line">  bark() &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 <code>false</code>라는 인자를 받는 데코레이터를 정의했습니다. 저 인자에는 함수도 들어갈 수 있으며 데코레이터도 들어갈 수 있습니다.</p><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>target을 ES5로 지정해야 제대로 된 데코레이터를 사용할 수 있어서 아직 한계가 있는 Decorator지만 React에서는 HOC(High-Order-Component)에 많이 사용하고 있는 Decorator 였습니다!</p><p>감사합니다.</p><p><em>6. Decorator in TypeScript end</em></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://www.typescriptlang.org/docs/handbook/generics.html" target="_blank" rel="noopener">TypeScript Official Document - Generics</a></li><li><a href="https://github.com/wycats/javascript-decorators" target="_blank" rel="noopener">https://github.com/wycats/javascript-decorators</a></li><li><a href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841" target="_blank" rel="noopener">https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841</a></li><li><a href="https://www.sitepoint.com/javascript-decorators-what-they-are/" target="_blank" rel="noopener">https://www.sitepoint.com/javascript-decorators-what-they-are/</a></li><li><a href="https://cabbageapps.com/fell-love-js-decorators/" target="_blank" rel="noopener">https://cabbageapps.com/fell-love-js-decorators/</a></li><li><a href="https://javarouka.github.io/blog/2016/09/30/decorator-exploring/#class-il-gyeongu" target="_blank" rel="noopener">https://javarouka.github.io/blog/2016/09/30/decorator-exploring/#class-il-gyeongu</a></li><li><a href="https://github.com/jayphelps/core-decorators" target="_blank" rel="noopener">https://github.com/jayphelps/core-decorators</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/typescript.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;TS-6-Decorators&quot;&gt;&lt;a href=&quot;#TS-6-Decorators&quot; class=&quot;headerlink&quot; title=&quot;[TS] 6. Decor
      
    
    </summary>
    
      <category term="TypeScript" scheme="https://jaeyeophan.github.io/categories/TypeScript/"/>
    
    
      <category term="ts" scheme="https://jaeyeophan.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>[번역] React를 본격적으로 하기 전 알면 좋은 6가지</title>
    <link href="https://jaeyeophan.github.io/2018/01/02/React-tips-for-beginners/"/>
    <id>https://jaeyeophan.github.io/2018/01/02/React-tips-for-beginners/</id>
    <published>2018-01-02T04:36:04.000Z</published>
    <updated>2018-01-03T01:50:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/react_special_1.png" alt=""></p><h1 id="I-wish-I-knew-these-before-diving-into-React"><a href="#I-wish-I-knew-these-before-diving-into-React" class="headerlink" title="I wish I knew these before diving into React"></a>I wish I knew these before diving into React</h1><p><em>해당 글은 원작자의 허가를 받고 번역한 글 입니다.</em><br><em>원본 링크 : <a href="https://engineering.opsgenie.com/i-wish-i-knew-these-before-diving-into-react-301e0ee2e488" target="_blank" rel="noopener">https://engineering.opsgenie.com/i-wish-i-knew-these-before-diving-into-react-301e0ee2e488</a></em></p><h3 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h3><ul><li>By default, setState triggers a re-render</li><li>setState updates the local state asynchronously</li><li>Component Lifecycle is important!</li><li>Use componentWillReceiveProps</li><li>Use React Developer Tools</li><li>Use CRA(Create React App)</li></ul><p><br></p><h2 id="1-By-default-setState-triggers-a-re-render"><a href="#1-By-default-setState-triggers-a-re-render" class="headerlink" title="1. By default, setState triggers a re-render"></a>1. By default, setState triggers a re-render</h2><blockquote><p>기본적으로 <code>setState</code> 메소드는 해당 컴포넌트의 재렌더링(re-render)을 발생시킨다.</p></blockquote><p>리액트의 기본 동작은 애플리케이션을 구성하고 있는 컴포넌트에서 발생하는 모든 변경사항에 대해서 다시 렌더링 하는 것이고 대부분의 경우 이 이러한 기본 동작에 맡겨도 정상적으로 동작합니다. 하지만 불필요한 re-render는 컴포넌트의 라이프 사이클 압장에서 봤을 때, Best practice일 수 없습니다.</p><p>각각의 컴포넌트들은 <code>shouldComponentUpdate</code>라는 메소드를 가지고 있고 이것은 <code>state</code>가 변경되거나 부모 컴포넌트로부터 새로운 <code>props</code>를 전달받을 때 실행됩니다. React는 이 메소드(<code>shouldComponentUpdate</code>)의 반환 값에 따라서 re-render를 할지에 대한 여부를 결정하게 됩니다.</p><p>기본적으로 <code>shouldComponentUpdate</code> 메소드는 <code>true</code>를 반환합니다. 하지만 React 개발자는 re-render를 원하지 않는 경우에, 이 return value를 <code>false</code>로 오버라이드 할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="keyword">const</span> vitalPropsChange = <span class="keyword">this</span>.props.bar !== nextProps.bar;</span><br><span class="line">    <span class="keyword">const</span> vitalStateChange = <span class="keyword">this</span>.state.foo !== nextState.foo;    </span><br><span class="line">    <span class="keyword">return</span> vitalPropsChange || vitalStateChange;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// React will not re-render the component unless vitalPropsChange</span></span><br><span class="line"><span class="comment">// or vitalStateChange is true.</span></span><br></pre></td></tr></table></figure><h3 id="important-notes"><a href="#important-notes" class="headerlink" title="important notes:"></a>important notes:</h3><ol><li><code>shouldComponentUpdate</code>를 잘못 설정하거나 이러한 설정을 잊어 버리면 구성 요소가 예상대로 업데이트되지 않아 애플리케이션에 문제가 발생할 수 있습니다.</li><li><code>shouldComponentUpdate</code>에서 계산을 실행하는 것은 성능과 노력면에서 비용이 많이들 수 있으므로 그만한 가치가 있는지 확인해야합니다. <a href="https://reactjs.org/docs/perf.html" target="_blank" rel="noopener">React ‘s Performance Tools</a>를 사용하여 <code>shouldComponentUpdate</code> 사용 전후에 낭비되는 사이클 수를 확인하는 것이 좋습니다. 아주 간단한 사용법이 있습니다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Perf.start() </span><br><span class="line"><span class="comment">// React operations in-between are recorded for analyses.</span></span><br><span class="line">Perf.stop()</span><br><span class="line">Perf.printWasted()</span><br></pre></td></tr></table></figure></li></ol><p><br></p><h2 id="2-setState-updates-the-local-state-asynchronously"><a href="#2-setState-updates-the-local-state-asynchronously" class="headerlink" title="2. setState updates the local state asynchronously"></a>2. setState updates the local state asynchronously</h2><blockquote><p><code>setState</code> 메소드는 <strong>비동기</strong>로 state를 업데이트 한다.</p></blockquote><p><code>setState</code>메소드는 즉시 실행되는, 동기적으로 실행되는 것이 아니라 하나의 <strong>요청</strong>이라고 생각해야 합니다. 즉, <code>setState</code>를 통해 상태를 변경하더라도 해당 메소드가 실행된 직후에 변경된 상태가 적용되는 것이 아닙니다.</p><p><code>setState</code>를 호출한 직후에 <code>this.state</code>에 접근하는 것은 흔한 실수 입니다. 일반적으로, <code>setState</code> 메소드 내에서 <code>this.state</code>를 사용하는 것은 신뢰할 수 없습니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this.state.value is initially 0</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</span><br><span class="line"><span class="comment">// this.state.value is 1 instead of 3</span></span><br></pre></td></tr></table></figure></p><p>만약 이전의 상태에 기반하여 상태를 변경해야 한다면 가장 좋은 방법 중 하나는 <code>updater</code> 함수를 사용하는 것입니다. <code>updater</code>함수를 <code>setState</code> 메소드의 첫번째 인자로 넘기는 방식으로 사용할 수 있습니다. ( <code>setState(updater, [callback])</code> ) 예제 코드입니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123;<span class="attr">value</span>: prevState.value + <span class="number">1</span>&#125;));</span><br></pre></td></tr></table></figure></p><p>여기서 <code>[callback]</code>은 optional argument로 <code>setState</code>의 실행이 완료된 후 실행되며 해당 <code>callback</code>이 실행된 후에 해당 컴포넌트의 re-render가 이루어집니다. <code>updater</code>에 대한 보다 자세한 내용은 다음 <a href="https://reactjs.org/docs/react-component.html#setstate" target="_blank" rel="noopener">링크</a>를 참고하세요.</p><p><br></p><h2 id="3-Component-Lifecycle-is-important"><a href="#3-Component-Lifecycle-is-important" class="headerlink" title="3. Component Lifecycle is important!"></a>3. Component Lifecycle is important!</h2><blockquote><p>컴포넌트의 라이프 사이클이 중요하다!</p></blockquote><p>React를 이해하는데 있어서 가장 첫번째로 이해해야 하는 부분이 바로 <strong>Component life cycle</strong>입니다. 각각의 React 컴포넌트는 component의 life cycle 안에서 특정 시간에 호출할 수 있는 메소드들을 내장하고 있습니다. 이 컴포넌트 내장 메소드들을 올바르게 사용하기 위해서는 해당 메소드들이 실행되는 순서를 이해해야만 합니다. 이 라이프 사이클을 세 부분으로 나눌 수 있습니다.</p><h3 id="Mounting"><a href="#Mounting" class="headerlink" title="Mounting"></a>Mounting</h3><p>React 컴포넌트의 인스턴스가 생성되고 DOM에 삽입되는 과정의 life cycle 입니다.</p><ol><li>constructor</li><li>componentWillMount</li><li>render</li><li>componentDidMount</li></ol><h3 id="Updating"><a href="#Updating" class="headerlink" title="Updating"></a>Updating</h3><p><code>prop</code> 또는 <code>state</code>의 변경으로 해당 컴포넌트가 re-render 되는 경우의 life cycle 입니다.</p><h4 id="Props-Change"><a href="#Props-Change" class="headerlink" title="Props Change"></a>Props Change</h4><ol><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>render</li><li>componentDidUpdate</li></ol><h4 id="State-Change"><a href="#State-Change" class="headerlink" title="State Change"></a>State Change</h4><ol><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>render</li><li>componentDidUpdate</li></ol><h3 id="Unmounting"><a href="#Unmounting" class="headerlink" title="Unmounting"></a>Unmounting</h3><ul><li>componentWillUnmount</li></ul><h3 id="Life-Cycle과-관련된-좋은-Article"><a href="#Life-Cycle과-관련된-좋은-Article" class="headerlink" title="Life Cycle과 관련된 좋은 Article"></a>Life Cycle과 관련된 좋은 Article</h3><ul><li>React Lifecycle Methods - how and when to use them<ul><li><a href="https://jaeyeophan.github.io/2018/01/01/React-4-Component-Life-Cycle/">번역 링크</a></li><li><a href="https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1" target="_blank" rel="noopener">원본 링크</a></li></ul></li><li><a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener">React Official Document</a></li></ul><p><br></p><h2 id="4-Use-componentWillReceiveProps"><a href="#4-Use-componentWillReceiveProps" class="headerlink" title="4. Use componentWillReceiveProps"></a>4. Use componentWillReceiveProps</h2><blockquote><p><code>componentWillReceiveProps</code> 메소드를 사용해라.</p></blockquote><p>만약 <code>props</code>의 변경에 따라서 상태를 변경해야 한다면, 이 <code>componentWillReceiveProps</code> 메소드가 필요합니다. <code>this.props</code>와 <code>nextProps</code>를 비교해서 중요한 변화(significant change)가 있다면 해당 메소드를 실행합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.foo !== nextProps.foo) &#123;</span><br><span class="line">    <span class="keyword">this</span>.whenFooChanges();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.porps.bar !== nextProps.bar) &#123;</span><br><span class="line">    <span class="keyword">this</span>.whenBarChanges();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Two-important-notes"><a href="#Two-important-notes" class="headerlink" title="Two important notes:"></a>Two important notes:</h3><ol><li><code>props</code>가 변경되지 않아도 <code>componentWillReceiveProps</code>는 실행하기 때문에 <code>this.props</code>와 <code>nextProps</code>를 비교하는 것이 중요합니다.</li><li><code>componentWillReceiveProps</code>은 해당 컴포넌트가 <strong>mounted</strong> 되기 전에 실행되어 새로운 <code>props</code>를 받습니다. 이것은 React가 mount 중에는 초기 props에 대해 <code>componentWillReceiveProps</code>를 호출하지 않는다는 것을 의미합니다.</li></ol><h3 id="추가-내용"><a href="#추가-내용" class="headerlink" title="추가 내용"></a>추가 내용</h3><p>React version 16에서 <code>componentWillReceiveProps</code>를 사용하여 상태를 변경할 때는 <strong>동기적으로</strong> 업데이트 해야 합니다.(dispatch request 또는 <code>setTimeout</code>과 같은 비동기적 요청은 해당 메소드에서 처리하면 안 됩니다.)<br><strong>React Fiber</strong> 를 사용하면 라이프 사이클이 진행되기 전에 <code>componentWill[*]</code> 메서드가 여러 번 호출 될 수 있습니다. <code>props</code>이 변경될 때 상태를 비동기적으로 업데이트하려면 <code>componentDidUpdate</code>를 사용해야 합니다.</p><p><br></p><h2 id="5-Use-React-Developer-Tools"><a href="#5-Use-React-Developer-Tools" class="headerlink" title="5. Use React Developer Tools"></a>5. Use React Developer Tools</h2><blockquote><p>각종 React 개발자 도구를 사용해라.</p></blockquote><p>React Developer Tools를 사용하면 애플리케이션을 구성하고 있는 React 컴포넌트의 계층, 컴포넌트의 <code>props</code> 및 <code>state</code>를 검사 할 수 있습니다. React는 모두 컴포넌트에 관한 것이기 때문에 많은 경우, 매우 유용합니다. 브라우저 확장 프로그램 (<a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi" target="_blank" rel="noopener">Chrome용</a> 및 <a href="https://addons.mozilla.org/ko/firefox/addon/react-devtools/" target="_blank" rel="noopener">Firefox 용</a>)과 <a href="https://github.com/facebook/react-devtools/tree/master/packages/react-devtools" target="_blank" rel="noopener">독립 실행 형 앱</a>으로 존재합니다.</p><p><br></p><h2 id="6-Use-CRA-Create-React-App"><a href="#6-Use-CRA-Create-React-App" class="headerlink" title="6. Use CRA(Create React App)"></a>6. Use CRA(Create React App)</h2><blockquote><p>CRA를 사용해라.</p></blockquote><p>Facebook의 <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a>을 사용하면 빌드 구성없이 React 앱을 만들 수 있습니다. CRA는 사용하기가 매우 쉽고 잘 갖춰진 documentation을 가지고 있습니다. Node&gt; = 6 만 있으면 되며 macOS, Windows 및 Linux에서 작동합니다. 개발 생산성을 높여주는 HRM도 해당 scaffolding 모듈에서 지원하고 있습니다. (개인적으로는 글로벌로 설치해도 아쉽지 않은 녀석입니다!)</p><p><br></p><h3 id="역자-덧붙임"><a href="#역자-덧붙임" class="headerlink" title="역자 덧붙임"></a>역자 덧붙임</h3><p>좋은 참고자료를 첨부합니다.</p><ul><li><a href="https://github.com/reactkr/learn-react-in-korean" target="_blank" rel="noopener">한국어로 배우는 리액트</a></li><li><a href="https://github.com/Microsoft/TypeScript-React-Starter" target="_blank" rel="noopener">TypeScript-React-Stater</a></li><li><a href="https://github.com/chantastic/reactpatterns.com" target="_blank" rel="noopener">react-patterns (영어)</a></li></ul><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>일부 의역이 들어갔으며 오역이 존재할 수 있습니다. 해당 사항에 대해서는 댓글로 피드백 주시면 감사하겠습니다. 더 좋은 포스팅으로 뵙겠습니다! 감사합니다.</p><p><em>해당 글은 원작자의 허가를 받고 번역한 글 입니다.</em><br><em>원본 링크 : <a href="https://engineering.opsgenie.com/i-wish-i-knew-these-before-diving-into-react-301e0ee2e488" target="_blank" rel="noopener">https://engineering.opsgenie.com/i-wish-i-knew-these-before-diving-into-react-301e0ee2e488</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/react_special_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;I-wish-I-knew-these-before-diving-into-React&quot;&gt;&lt;a href=&quot;#I-wish-I-knew-these-be
      
    
    </summary>
    
      <category term="React" scheme="https://jaeyeophan.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://jaeyeophan.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>[React] 4. Component Life Cycle</title>
    <link href="https://jaeyeophan.github.io/2018/01/01/React-4-Component-Life-Cycle/"/>
    <id>https://jaeyeophan.github.io/2018/01/01/React-4-Component-Life-Cycle/</id>
    <published>2018-01-01T08:08:03.000Z</published>
    <updated>2018-01-15T09:37:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/react_logo.png" alt=""></p><h1 id="React-Lifecycle-Methods-how-and-when-to-use-them"><a href="#React-Lifecycle-Methods-how-and-when-to-use-them" class="headerlink" title="React Lifecycle Methods - how and when to use them"></a>React Lifecycle Methods - how and when to use them</h1><p><em>해당 글은 원작자의 허가를 받고 번역한 글 입니다.</em><br><em>원본 링크 : <a href="https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1" target="_blank" rel="noopener">https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1</a></em></p><h3 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h3><ul><li>Intro</li><li>React Component Life Cycle<ul><li>componentWillMount</li><li>componentDidMount</li><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>componentDidUpdate</li><li>componentWillUnmount</li></ul></li></ul><p><br></p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p><img src="/images/react_component_life_cycle.png" alt=""></p><p>위 다이어그램은 React 컴포넌트의 출생(pre-mounting)과 사망 (unmounting)에서의 Life Cycle입니다. React의 장점은 복잡한 UI를 작은 크기로 나누는 것입니다. 따라서 앱을 각각의 컴포넌트 단위로 분류 할 수 있을 뿐만 아니라 각 컴포넌트에 대해 customize 할 수 있습니다.</p><p>React Component의 라이프 사이클 메소드를 통해 UI의 각 컴포넌트가 <strong>렌더링(rendering)</strong>, <strong>업데이트(update)</strong>, <strong>재렌더링(re-rendering)</strong> 될 때를 고려할 수 있으며 <strong>완전히 사라질 때(unmount)</strong> 일어나는 일을 제어 할 수 있습니다.</p><p><br></p><h2 id="React-Component-Life-Cycle"><a href="#React-Component-Life-Cycle" class="headerlink" title="React Component Life Cycle"></a>React Component Life Cycle</h2><p>React 컴포넌트의 생명 주기를 부분적으로 나누어 간단히 살펴보면 다음과 같습니다.</p><h3 id="Mounting"><a href="#Mounting" class="headerlink" title="Mounting"></a>Mounting</h3><p>React 컴포넌트의 인스턴스가 생성되고 DOM에 삽입되는 과정의 life cycle 입니다.</p><ol><li>constructor</li><li>componentWillMount</li><li>render</li><li>componentDidMount</li></ol><h3 id="Updating"><a href="#Updating" class="headerlink" title="Updating"></a>Updating</h3><p><code>prop</code> 또는 <code>state</code>의 변경으로 해당 컴포넌트가 re-render 되는 경우의 life cycle 입니다.</p><h4 id="Props-Change"><a href="#Props-Change" class="headerlink" title="Props Change"></a>Props Change</h4><ol><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>render</li><li>componentDidUpdate</li></ol><h4 id="State-Change"><a href="#State-Change" class="headerlink" title="State Change"></a>State Change</h4><ol><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>render</li><li>componentDidUpdate</li></ol><h3 id="Unmounting"><a href="#Unmounting" class="headerlink" title="Unmounting"></a>Unmounting</h3><ul><li>componentWillUnmount</li></ul><p>이제 각각에 대해서 살펴봅시다.</p><p><br></p><h2 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a><code>componentWillMount</code></h2><p>개발자가 정의한 컴포넌트는 눈 깜짝할 사이에 화면에 그려집니다. 이 순간 무엇을 할 수 있을까요? 그에 대한 대답은 사실 할 수 있는 것이 별로 없습니다. <code>componentWillMount</code> 메소드는 딱히 쓸모가 없습니다.</p><p><code>componentWillMount</code>에서는 아직 생성된 컴포넌트가 없으므로 DOM 관련 작업을 수행 할 수 없습니다. 또한 컴포넌트의 기본 구성(<code>props</code> or <code>state</code>)을 설정하는 생성자(constructor)가 호출된 이후에는 아무 것도 변경되지 않았습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Sidebar</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  tooltipsEnabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      analyticsOpen: <span class="literal">false</span>,</span><br><span class="line">      requirementsOpen: <span class="literal">false</span>,</span><br><span class="line">      brandInfoOpen: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>생성자가 호출되고 나면 그 상태가 바로 컴포넌트의 초기 상태가 됩니다. 추가적인 라이프 사이클 메소드를 복잡하게 사용하지 않고도 거의 모든 것이 컴포넌트 코드의 나머지 부분에서 처리되어야 합니다. 그 중에서도 예외가 있다면 초기에만 수행할 수있는 설정 즉, 외부 API에 연결하는 작업이 있을 것입니다. 예를 들어, 앱에 Firebase를 사용한다면, 앱이 처음 설치 될 때 설정을 가져와야합니다. 그러나 여기서 핵심은 이러한 작업은 앱의 최상위 컴포넌트 (루트 컴포넌트)에서 수행되어야 한다는 것입니다.</p><p>이는 컴포넌트의 99 %가 <code>componentWillMount</code>를 사용하지 않아야 함을 의미합니다. <code>componentWillMount</code>를 사용하여 컴포넌트에 대한 데이터를 로드하기 위해 AJAX 호출을 시작하는 사람들을 볼 수 있습니다. 하지만 이 글을 읽는 당신은 이러지 않았으면 좋겠습니다. 바로 다음 section인 두번째 section에서 이 부분에 대해 이야기하겠습니다.</p><h4 id="이-메소드의-가장-일반적인-사용-사례"><a href="#이-메소드의-가장-일반적인-사용-사례" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul><li>루트 컴포넌트에서 App과 관련된 외부 API를 설정할 떄.</li><li>setState 호출(?) : <code>setState</code>도 호출하지 말고 constructor에서 설정한 <code>this.state</code>를 사용하세요.</li></ul><p><br></p><h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a><code>componentDidMount</code></h2><p>이제 컴포넌트가 mount되고 사용할 준비가 되었습니다.</p><p><code>componentDidMount</code>는 가지고 놀 컴포넌트가 없을 때 할 수 없었던 것들을 모두 할 수 있는 메소드입니다. 몇 가지 예를 들면 다음과 같습니다.</p><ul><li><code>&lt;canvas&gt;</code> 에 렌더링을 수행한다.</li><li>요소 컬렉션에서 <a href="https://masonry.desandro.com/" target="_blank" rel="noopener">Masonry</a> 그리드 레이아웃을 초기화한다.</li><li>Event listener를 추가한다.</li></ul><p>기본적으로 여기에서는 DOM에 대한 접근이 필요한 모든 설정을 수행하고 필요한 데이터를 가져오기 시작합니다.</p><h4 id="이-메소드의-가장-일반적인-사용-사례-1"><a href="#이-메소드의-가장-일반적인-사용-사례-1" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul><li>Ajax 호출을 시작하여 컴포넌트에서 사용해야 하는 데이터를 로드합니다.</li><li>setState를 호출할 수 있습니다.</li></ul><p><br></p><h2 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a><code>componentWillReceiveProps</code></h2><p>컴포넌트가 정상적으로 잘 동작하고 있었는데 새로운 <code>props</code>가 전달되었습니다. 아마 상위 컴포넌트에서 <code>componentDidMount</code>에 의해 로드된 데이터 중 일부가 내려왔을 것입니다.</p><p>새로운 <code>props</code>로 어떠한 작업을 수행하기 전 이 새로운 <code>props</code>를 인자로 하여 <code>componentWillReceiveProps</code>가 호출됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">parseInt</span>(nextProps.id, <span class="number">10</span>) !== <span class="built_in">parseInt</span>(<span class="keyword">this</span>.props.id, <span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">postsLoaded</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">    <span class="keyword">this</span>.contentLoaded = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우리는 이 메소드 안에서 <code>nextProps</code>를 통해 다음의 <code>props</code>(새로운 <code>props</code>)에 접근할 수 있고 <code>this.props</code>를 통해 현재의 <code>props</code>에 접근할 수 있습니다.</p><p>이 메소드에서 우리 해야하는 것은 다음과 같습니다.</p><ol><li>props가 바뀌었는지 확인합니다. 가끔 <code>props</code>가 변경되지 않은 경우에도 호출됩니다.</li><li>만약 <code>props</code>가 변경되었다면 그에 따라 로직을 구성해야 한다.</li></ol><p>새로운 <code>props</code>를 받았을 때, 다음과 같이 처리합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.percent !== nextProps.percent) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setUpPercent(nextProps.percent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>하나 더 주의해야 할 것은 <code>componentWillReceiveProps</code>는 초기 렌더링시 호출되지 않습니다. 코드 상으로는 컴포넌트가 <code>props</code>를 받는다는 것을 의미하지만 비교할 기존의 <code>props</code>가 없으므로 로직에 포함되지 않습니다.</p><h4 id="이-메소드의-가장-일반적인-사용-사례-2"><a href="#이-메소드의-가장-일반적인-사용-사례-2" class="headerlink" title="이 메소드의 가장 일반적인 사용 사례"></a>이 메소드의 가장 일반적인 사용 사례</h4><ul><li>해당 컴포넌트의 상태 변경에 영향을 끼지는 <code>props</code>의 변경에 따라 로직을 구성합니다.</li><li>setState를 호출할 수 있습니다.</li></ul><p><br></p><h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a><code>shouldComponentUpdate</code></h2><p>컴포넌트가 불안정한(?) 상태입니다. 이 메소드가 호출되었다는 것은 현재 컴포넌트의 상태와 view에 그려진 내용, 상태가 다르다는 것을 의미하기 때문입니다.</p><p>우리에게는 새로운 <code>props</code>가 있습니다. 전형적인 React 신조에 따르면 컴포넌트가 새로운 <code>props</code>나 새로운 <code>state</code>를 받으면 업데이트해야 한다고 말합니다.</p><p><code>shouldComponentUpdate</code> 메소드는 <code>nextProps</code>를 첫 번째 인수로 사용하고 <code>nextState</code>는 두 번째 인수로 사용합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.props.engagement !== nextProps.engagement</span><br><span class="line">    || nextState.input !== <span class="keyword">this</span>.state.input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>shouldComponentUpdate</code>는 항상 <code>boolean</code>을 반환해야 합니다. 이것은 “해당 컴포넌트를 다시 렌더링(re-render)해야 하나요?”라는 질문에 대한 답이 됩니다. 해당 컴포넌트를 특별히 override하지 않는 이상 이 메소드는 기본적으로 <code>true</code>를 반환합니다.</p><p>하지만 불필요한 재렌더링(re-render)를 방지하기 위해서는 <code>shouldComponentUpdate</code>를 override 할 수 있습니다. 자세한 내용은 다음 <a href="https://engineering.musefind.com/how-to-benchmark-react-components-the-quick-and-dirty-guide-f595baf1014c" target="_blank" rel="noopener">링크</a>를 참고해주세요. (이 링크에서는 많은 필드가 있는 테이블에서 테이블이 다시 렌더링 될 때 각 필드가 다시 렌더링되어 작업속도가 느려지게 된다는 것을 보여주고 있습니다.)</p><p><code>shouldComponentupdate</code>를 사용하면 변화에 신경써야 하는 <code>props</code>의 변경에 대해서만 update를 진행할 수 있습니다. 하지만 이에 대한 설정을 잊으면 React 컴포넌트가 제대로 동작하지 않기 때문에 명심해야 합니다.</p><h4 id="이-메소드의-