<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>덕's IT Story</title>
<link>https://itstory.tk/</link>
<description>되돌아보면 웃을수 있는 즐거운 인생살기!!</description>
<language>ko</language>
<pubDate>Mon, 13 May 2019 01:11:30 +0900</pubDate>
<generator>TISTORY</generator>
<managingEditor>kkd927</managingEditor>
<image>
<title>덕's IT Story</title>
<url>http://cfile6.uf.tistory.com/image/266E5C3E58FB5E2A11BDF8</url>
<link>https://itstory.tk</link>
<description>되돌아보면 웃을수 있는 즐거운 인생살기!!</description>
</image>
<item>
<title>Spring Webflux + JDBC(혹은 blocking call) 핸들링 방법</title>
<link>https://itstory.tk/entry/Spring-Webflux-JDBC%ED%98%B9%EC%9D%80-blocking-call-%ED%95%B8%EB%93%A4%EB%A7%81-%EB%B0%A9%EB%B2%95</link>
<description>&lt;p&gt;스프링 5부터 Spring Webflux를 통해 reactive 개발이 가능하게 됐습니다. 요청당 스레드가 하나씩 차지했던 기존의 패러다임과 달리 Webflux는 non-blocking 시스템이 가능하게 해줍니다.&lt;/p&gt;

&lt;p&gt;하지만 non-blocking을 지원하지 않는 blocking persistence API (ex. jdbc)를 쓰는 경우에는 어떻게 해야할까요? non-blocking을 지원하는 nosql 데이터베이스를 사용하거나 &lt;a href=&quot;https://github.com/r2dbc&quot;&gt;r2dbc&lt;/a&gt;를 사용하는 것이 방법이 될 수 있겠으나 아직까진 mysql 등의 rdbms는 지원되지 않습니다. 이번 글에서는 Spring Webflux + JDBC 환경에서 어떤식으로 개발을 해야되는지에 대해 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;일반적인 웹 구조인 controller -&amp;gt; service -&amp;gt; repository 형태로 예를 들어보겠습니다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;@Slf4j
@RestController
public class MemoController {
    private final MemoService memoService;

    public MemoController(MemoService memoService) {
        this.memoService = memoService;
    }

    @PostMapping(&quot;/memos&quot;)
    public Mono&amp;lt;MemoResponseDTO&amp;gt; save(@Valid @RequestBody MemoRequestDTO memoRequestDTO) {
        log.info(&quot;===== MemoController 시작 =====&quot;);

        return memoService.save(memoRequestDTO)
            .map(MemoResponseDTO::of)
            .log();
    }
}&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;@Slf4j
@Service
public class MemoService {
    private final MemoRepository memoRepository;

    public MemoService(MemoRepository memoRepository) {
        this.memoRepository = memoRepository;
    }

    public Mono&amp;lt;Memo&amp;gt; save(MemoRequestDTO memoRequestDTO) {
        log.info(&quot;===== MemoService 시작 =====&quot;);

        return Mono.just(memoRepository.save(Memo.of(memoRequestDTO)))
            .log();
    }
}&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;@Slf4j
@Repository
public class MemoRepository {
    public Memo save(Memo memo) {
        log.info(&quot;===== MemoRepository 시작 =====&quot;);
        // ...blocking persistence APIs (JPA, JDBC) or networking APIs to use
        return memo;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 예에서 &lt;code&gt;MemoRepository&lt;/code&gt;는 단순히 Memo 객체를 반환하지만 blocking persistence API를 이용하는 레이어라고 생각하시면 됩니다. JPA 환경이라면 &lt;code&gt;MemoRepository extends JpaRepository&amp;lt;Memo, ID&amp;gt;&lt;/code&gt; 이런 식이 되겠지요.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MemoService&lt;/code&gt;는 blocking I/O인 &lt;code&gt;MemoRepository&lt;/code&gt;의 결과를 단순히 &lt;code&gt;Mono.just&lt;/code&gt;로 감싸서 결과를 반환하도록 구현하였습니다. 이제 실행결과를 한번 살펴볼까요?&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;2018-12-21 14:09:20.705  INFO 67826 --- [ctor-http-nio-2] c.e.demo.interfaces.MemoController       : ===== MemoController 시작 =====
2018-12-21 14:09:20.706  INFO 67826 --- [ctor-http-nio-2] c.e.demo.domain.service.MemoService      : ===== MemoService 시작 =====
2018-12-21 14:09:20.711  INFO 67826 --- [ctor-http-nio-2] c.e.d.domain.repository.MemoRepository   : ===== MemoRepository 시작 =====
2018-12-21 14:09:20.728  INFO 67826 --- [ctor-http-nio-2] reactor.Mono.CallableOnAssembly.1        : onSubscribe([Fuseable] FluxOnAssembly.OnAssemblySubscriber)
2018-12-21 14:09:20.729  INFO 67826 --- [ctor-http-nio-2] reactor.Mono.OnAssembly.2                : | onSubscribe([Fuseable] FluxOnAssembly.OnAssemblySubscriber)
2018-12-21 14:09:20.729  INFO 67826 --- [ctor-http-nio-2] reactor.Mono.OnAssembly.2                : | request(unbounded)
2018-12-21 14:09:20.729  INFO 67826 --- [ctor-http-nio-2] reactor.Mono.CallableOnAssembly.1        : request(unbounded)
2018-12-21 14:09:20.730  INFO 67826 --- [ctor-http-nio-2] reactor.Mono.CallableOnAssembly.1        : onNext(com.example.demo.domain.model.Memo@3b09310d)
2018-12-21 14:09:20.730  INFO 67826 --- [ctor-http-nio-2] reactor.Mono.OnAssembly.2                : | onNext(com.example.demo.domain.dto.MemoResponseDTO@67c2f017)
2018-12-21 14:09:20.751  INFO 67826 --- [ctor-http-nio-2] reactor.Mono.CallableOnAssembly.1        : onComplete()
2018-12-21 14:09:20.752  INFO 67826 --- [ctor-http-nio-2] reactor.Mono.OnAssembly.2                : | onComplete()&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결과를 보면 하나의 쓰레드(ctor-http-nio-2) 위에서 생산과 소비가 이루어졌습니다. 기존의 blocking 코드들과 크게 다를 바가 없어보입니다. synchronous, blocking call이 도중에 포함이 된다면 단순히 Mono, Flux를 이용하여 개발을 했다고 non-blocking이 되진 않습니다.&lt;/p&gt;

&lt;p&gt;그럼 jdbc와 같이 blocking I/O가 있는 경우에는 어떻게 처리를 해야할까요? Spring 공식 문서를 살펴보면 다음과 같이 적혀져있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A simple way to evaluate an application is to check its dependencies. If you have blocking persistence APIs (JPA, JDBC) or networking APIs to use, Spring MVC is the best choice for common architectures at least. It is technically feasible with both Reactor and RxJava to perform blocking calls on a separate thread but you would not be making the most of a non-blocking web stack.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;요약하자면, blocking call 부분을 별도의 쓰레드에서 background로 돌려라고 적혀져있습니다. 그럼 구체적으로 어떻게 쓰면 될까요? Reactor 공식 문서를 살펴보면 &lt;a href=&quot;https://projectreactor.io/docs/core/release/reference/#faq.wrap-blocking&quot;&gt;How do I wrap a synchronous, blocking call?&lt;/a&gt;라는 주제로 자세히 잘 설명을 해주고 있습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;Mono blockingWrapper = Mono.fromCallable(() -&amp;gt; { 
    return /* make a remote synchronous call */ 
}).subscribeOn(Schedulers.elastic());&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Mono.fromCallable&lt;/code&gt;를 사용하여 blocking call 부분의 실행을 미루고, 이를 &lt;code&gt;Schedulers.elastic()&lt;/code&gt;를 사용하여 blocking 자원들을 기다리는 별도의 쓰레드를 생성하여 실행시키라고 설명되어 있습니다(직접 custom scheduler를 만들어 사용하여도 무관합니다).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;reactor.core.scheduler.Schedulers&lt;/code&gt;에서 기본으로 제공하는 스케쥴러들은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Schedulers.immediate() : Current thread.&lt;/li&gt;
&lt;li&gt;Schedulers.single() : A single, reusable thread.&lt;/li&gt;
&lt;li&gt;Schedulers.newSingle() : A per-call dedicated thread.&lt;/li&gt;
&lt;li&gt;Schedulers.elastic() : An elastic thread pool. It creates new worker pools as needed, and reuse idle ones. This is a good choice for I/O blocking work for instance.&lt;/li&gt;
&lt;li&gt;Schedulers.parallel() : A fixed pool of workers that is tuned for parallel work.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그럼 이제 처음에 살펴봤던 예제 코드로 다시 돌아가 &lt;code&gt;MemoSerivce&lt;/code&gt; 부분을 변경해보겠습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;@Slf4j
@Service
public class MemoService {
    private final MemoRepository memoRepository;

    public MemoService(MemoRepository memoRepository) {
        this.memoRepository = memoRepository;
    }

    public Mono&amp;lt;Memo&amp;gt; save(MemoRequestDTO memoRequestDTO) {
        log.info(&quot;===== MemoService 시작 =====&quot;);

        return Mono.fromCallable(() -&amp;gt; memoRepository.save(Memo.of(memoRequestDTO)))
                .subscribeOn(Schedulers.elastic())
                .log();
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 다시 실행결과를 살펴봅시다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;2018-12-21 13:34:36.926  INFO 52520 --- [ctor-http-nio-2] c.e.demo.interfaces.MemoController       : ===== MemoController 시작 =====
2018-12-21 13:34:36.926  INFO 52520 --- [ctor-http-nio-2] c.e.demo.domain.service.MemoService      : ===== MemoService 시작 =====
2018-12-21 13:34:36.982  INFO 52520 --- [ctor-http-nio-2] reactor.Mono.OnAssembly.1                : | onSubscribe([Fuseable] FluxOnAssembly.OnAssemblySubscriber)
2018-12-21 13:34:36.982  INFO 52520 --- [ctor-http-nio-2] reactor.Mono.OnAssembly.2                : | onSubscribe([Fuseable] FluxOnAssembly.OnAssemblySubscriber)
2018-12-21 13:34:36.983  INFO 52520 --- [ctor-http-nio-2] reactor.Mono.OnAssembly.2                : | request(unbounded)
2018-12-21 13:34:36.983  INFO 52520 --- [ctor-http-nio-2] reactor.Mono.OnAssembly.1                : | request(unbounded)
2018-12-21 13:34:36.990  INFO 52520 --- [      elastic-2] c.e.d.domain.repository.MemoRepository   : ===== MemoRepository 시작 =====
2018-12-21 13:34:41.994  INFO 52520 --- [      elastic-2] reactor.Mono.OnAssembly.1                : | onNext(com.example.demo.domain.model.Memo@3c0aa92b)
2018-12-21 13:34:41.995  INFO 52520 --- [      elastic-2] reactor.Mono.OnAssembly.2                : | onNext(com.example.demo.domain.dto.MemoResponseDTO@1c14c9b0)
2018-12-21 13:34:42.013  INFO 52520 --- [      elastic-2] reactor.Mono.OnAssembly.1                : | onComplete()
2018-12-21 13:34:42.013  INFO 52520 --- [      elastic-2] reactor.Mono.OnAssembly.2                : | onComplete()&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;blocking call 부분인 &lt;code&gt;MemoRepository&lt;/code&gt; 호출이 별도의 스레드(elastic-2)에서 돌아가는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;Spring Webflux와 jdbc(혹은 blocking call이 포함된 로직)를 사용하고 계시다면 나의 생각과 달리 blocking으로 돌아가고 있지 않은지 잘 살펴보는 습관이 필요할 것 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-framework-choice&quot;&gt;https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-framework-choice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://spring.io/blog/2016/07/20/notes-on-reactive-programming-part-iii-a-simple-http-server-application#bridging-from-blocking-to-reactive-with-spring-mvc&quot;&gt;https://spring.io/blog/2016/07/20/notes-on-reactive-programming-part-iii-a-simple-http-server-application#bridging-from-blocking-to-reactive-with-spring-mvc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://projectreactor.io/docs/core/release/reference/#schedulers&quot;&gt;https://projectreactor.io/docs/core/release/reference/#schedulers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://projectreactor.io/docs/core/release/reference/#faq.wrap-blocking&quot;&gt;https://projectreactor.io/docs/core/release/reference/#faq.wrap-blocking&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/210&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>JDBC</category>
<category>JPA</category>
<category>Non-blocking</category>
<category>spring webflux</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/210</guid>
<comments>https://itstory.tk/entry/Spring-Webflux-JDBC%ED%98%B9%EC%9D%80-blocking-call-%ED%95%B8%EB%93%A4%EB%A7%81-%EB%B0%A9%EB%B2%95#entry210comment</comments>
<pubDate>Wed, 26 Dec 2018 15:41:03 +0900</pubDate>
</item>
<item>
<title>[macOS Mojave] Evernote (혹은 특정앱만) dark mode 해제 시키는 방법</title>
<link>https://itstory.tk/entry/macOS-Mojave-Evernote-%ED%98%B9%EC%9D%80-%ED%8A%B9%EC%A0%95%EC%95%B1%EB%A7%8C-dark-mode-%ED%95%B4%EC%A0%9C-%EC%8B%9C%ED%82%A4%EB%8A%94-%EB%B0%A9%EB%B2%95</link>
<description>&lt;p&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;macOS Mojave (10.14 버전)부터 Dark mode가 지원됩니다.&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F99CD663C5C189B25299259&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99CD663C5C189B2529&quot; filemime=&quot;image/jpeg&quot; filename=&quot;darkmode-mac.jpg&quot; height=&quot;513&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;(사진 출처: &lt;a href=&quot;https://help.evernote.com/hc/ko/articles/360002061928-Evernote%EC%97%90%EC%84%9C-%EB%8B%A4%ED%81%AC-%EB%AA%A8%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Evernote 공홈 - Evernote에서 다크 모드를 사용하는 방법&lt;/a&gt;)&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;에버노트도 mojave에 맞춰 다크모드를 지원하는 새로운 업데이트를 출시하였습니다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;하지만 글 하이라이팅의 문제로 에버노트만 다크모드를 해제하고 싶었는데요, 저만 이런 생각을 가진건 아니였나 봅니다.&lt;/p&gt;&lt;p&gt;에버노트 게시판에 누군가 &lt;a href=&quot;https://discussion.evernote.com/topic/117494-can-you-turn-off-dark-mode-in-evernote-only/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Can you turn off Dark Mode in Evernote only?&lt;/a&gt; 로 질문을 올려놨네요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;에버노트 앱 자체에 라이트 모드 사용 설정이 존재하는데요,&lt;/p&gt;&lt;p&gt;환경설정 &amp;gt; 일반 &amp;gt; 노트에 라이트 모드 사용
&lt;/p&gt;&lt;p&gt;이 설정은 노트에만 흰색 배경을 보여주는 것이라 꽤나 미려하지 못합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그럼 macOS Mojave 에서 에버노트 혹은 특정 앱만 아예 dark mode를 해제 시키는 법을 이제 살펴보겠습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;1. 터미널 앱을 실행시킵니다.&lt;/b&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:684px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F99A60F3D5C189F531AA10F&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99A60F3D5C189F531A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;전체화면_2018__12__18__오후_4_17.png&quot; height=&quot;434&quot; width=&quot;684&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. Dark Mode를 해제하려는 앱의 고유 아이디를 확인합니다.&lt;/b&gt;&lt;/p&gt;&lt;p&gt;터미널에 다음과 같이 입력하시고 엔터를 누릅니다.&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;osascript -e 'id of app &quot;evernote&quot;'&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;그럼&amp;nbsp;&lt;b&gt;com.evernote.Evernote&lt;/b&gt;&amp;nbsp;가 출력됩니다.&lt;/p&gt;&lt;p&gt;(에버노트 기준으로 한 예시이니 다른 앱의 경우 evernote 부분에 원하시는 앱이름을 기재하면 됩니다.)&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:630px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F99762A375C18A16E2ED7D9&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99762A375C18A16E2E&quot; filemime=&quot;image/jpeg&quot; filename=&quot;1__kkd927_AL01190005-2_____zsh_.png&quot; height=&quot;176&quot; width=&quot;630&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;3. 해당 앱의 Dark Mode를 해제시킵니다.&lt;/b&gt;&lt;/p&gt;&lt;p&gt;터미널에 다음과 같이 입력 후 엔터를 눌러줍니다.&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;defaults write com.evernote.Evernote NSRequiresAquaSystemAppearance -bool yes&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;에버노트가 아닌 다른 앱으로 진행하시는 경우 com.evernote.Evernote 부분을 2번에서 출력된 아이디 값으로 변경 후 입력하시면 됩니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:798px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F994EC8385C18A1C42A84A8&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/994EC8385C18A1C42A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;1__kkd927_AL01190005-2_____zsh_-2.png&quot; height=&quot;171&quot; width=&quot;798&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이제 에버노트를 끄고 다시 실행하면 에버노트만 다크모드가 해제된 기본모드로 실행되는 것을 확인하실 수 있습니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F99D4EA3E5C18A3512FB658&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99D4EA3E5C18A3512F&quot; filemime=&quot;image/jpeg&quot; filename=&quot;전체화면_2018__12__18__오후_4_32.jpg&quot; height=&quot;400&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;설정을 초기화 하고 싶으신 경우&lt;/b&gt; 터미널에서 다음과 같이 입력하시면 됩니다.&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;defaults delete com.evernote.Evernote NSRequiresAquaSystemAppearance&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/209&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>그 외</category>
<category>Dark Mode</category>
<category>evernote</category>
<category>macOS Mojave</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/209</guid>
<comments>https://itstory.tk/entry/macOS-Mojave-Evernote-%ED%98%B9%EC%9D%80-%ED%8A%B9%EC%A0%95%EC%95%B1%EB%A7%8C-dark-mode-%ED%95%B4%EC%A0%9C-%EC%8B%9C%ED%82%A4%EB%8A%94-%EB%B0%A9%EB%B2%95#entry209comment</comments>
<pubDate>Tue, 18 Dec 2018 16:37:27 +0900</pubDate>
</item>
<item>
<title>spring-boot-starter-webflux swagger 3 설정</title>
<link>https://itstory.tk/entry/springbootstarterwebflux-swagger-3-%EC%84%A4%EC%A0%95</link>
<description>&lt;p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;구성 &lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;
- spring-boot-starter-webflux (2.1.0.RELEASE) &lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;
- springfox-swagger2 (3.0.0-SNAPSHOT)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;우선 &lt;/span&gt;&lt;code&gt;&lt;span style=&quot;color: rgb(0, 0, 0); background-color: rgb(234, 234, 234);&quot;&gt;pom.xml&lt;/span&gt;&lt;/code&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;에 관련 dependency들을 추가해 줍니다.&lt;/span&gt;&lt;/p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;



&lt;/span&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1.0.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
&amp;lt;/parent&amp;gt;

&amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
    &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;swagger.version&amp;gt;3.0.0-SNAPSHOT&amp;lt;/swagger.version&amp;gt;
&amp;lt;/properties&amp;gt;

&amp;lt;dependencies&amp;gt;
    &amp;lt;!-- srping webflux --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-webflux&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- swagger 3 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${swagger.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${swagger.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;springfox-spring-webflux&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${swagger.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;

&lt;/span&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;이후 Docket 빈을 생성해주시면 됩니다.&lt;/span&gt;&lt;/p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;



&lt;/span&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;@Configuration
@EnableSwagger2WebFlux
public class SwaggerConfig {
    @Bean
    public Docket api() {
        return new Docket(DocumentationType.SWAGGER_2)
            .select()
            .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))
            .build()
            .genericModelSubstitutes(Optional.class, Flux.class, Mono.class);
    }
}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;

&lt;/span&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;spring webflux를 사용하시면 api 응답값으로 &lt;/span&gt;&lt;code&gt;&lt;span style=&quot;color: rgb(0, 0, 0); background-color: rgb(234, 234, 234);&quot;&gt;Mono&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;, &lt;/span&gt;&lt;code&gt;&lt;span style=&quot;color: rgb(0, 0, 0); background-color: rgb(234, 234, 234);&quot;&gt;Flux&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;를 사용하실 텐데요, &lt;/span&gt;&lt;code&gt;&lt;span style=&quot;color: rgb(0, 0, 0); background-color: rgb(234, 234, 234);&quot;&gt;.genericModelSubstitutes(Optional.class, Flux.class, Mono.class);&lt;/span&gt;&lt;/code&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;를 추가해주시지 않으면 아래 이미지 처럼 Response 모델이 정상적으로 보이지 않습니다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F9907A5485BFB664F319D2D&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/9907A5485BFB664F31&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Swagger_UI.png&quot; height=&quot;623&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;정상적으로 SwaggerConfig에 추가해주셨다면 아래처럼 잘 나오게됩니다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F9964844E5BFB665E279E9B&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/9964844E5BFB665E27&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Swagger_UI-2.png&quot; height=&quot;265&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;이제 api 작성을 통해 테스트를 진행하시면 됩니다.&lt;/span&gt;&lt;/p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;



&lt;/span&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;@RestController
public class PostController {
    private final PostService postService;

    public PostController(PostService postService) {
        this.postService = postService;
    }

    @ApiOperation(value = &quot;Post 생성&quot;)
    @PostMapping(&quot;/boards/{boardId}/posts&quot;)
    public Mono&amp;lt;PostDTO&amp;gt; addPost(@PathVariable Long boardId, @RequestBody PostRequestDTO postRequestDTO) {
        // ...
    }
}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;

&lt;/span&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;이제 &lt;/span&gt;&lt;code&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;http://localhost:8080/swagger-ui.html&lt;/span&gt;&lt;/code&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;에 접속하셔서 정상적으로 swagger가 동작하는지 확인하시면 됩니다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F9990A0465BFB666C2797E8&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/9990A0465BFB666C27&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Swagger_UI-3.png&quot; height=&quot;632&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;



&lt;/span&gt;&lt;h2 id=&quot;참고&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;참고&lt;/span&gt;&lt;/h2&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;

&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://springfox.github.io/springfox/docs/current/&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;https://springfox.github.io/springfox/docs/current/&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/208&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>spring webflux</category>
<category>Swagger</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/208</guid>
<comments>https://itstory.tk/entry/springbootstarterwebflux-swagger-3-%EC%84%A4%EC%A0%95#entry208comment</comments>
<pubDate>Mon, 26 Nov 2018 12:21:19 +0900</pubDate>
</item>
<item>
<title>[IT] 개발 밋업 정보 공유 달력</title>
<link>https://itstory.tk/entry/IT-%EA%B0%9C%EB%B0%9C-%EB%B0%8B%EC%97%85-%EC%A0%95%EB%B3%B4-%EA%B3%B5%EC%9C%A0-%EB%8B%AC%EB%A0%A5</link>
<description>&lt;p&gt;개발 밋업(meetup)&amp;nbsp;정보 공유 달력입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://meetup4u.com&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://meetup4u.com&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;iframely-embed&quot;&gt;&lt;div class=&quot;iframely-responsive&quot; style=&quot;padding-bottom: 75%; padding-top: 120px;&quot;&gt;&lt;a href=&quot;https://meetup4u.com&quot; data-iframely-url=&quot;//cdn.iframe.ly/VenE2zn&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;script async=&quot;&quot; src=&quot;//cdn.iframe.ly/embed.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F992C55335BFAB25801C786&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/992C55335BFAB25801&quot; filemime=&quot;image/jpeg&quot; filename=&quot;calendar.jpg&quot; height=&quot;721&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/207&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>대외활동 소식</category>
<category>Meetup Calendar</category>
<category>개발 밋업 정보</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/207</guid>
<comments>https://itstory.tk/entry/IT-%EA%B0%9C%EB%B0%9C-%EB%B0%8B%EC%97%85-%EC%A0%95%EB%B3%B4-%EA%B3%B5%EC%9C%A0-%EB%8B%AC%EB%A0%A5#entry207comment</comments>
<pubDate>Sun, 25 Nov 2018 23:41:49 +0900</pubDate>
</item>
<item>
<title>가성비 갑 전기자전거, 샤오미 HIMO V1 직구 후기</title>
<link>https://itstory.tk/entry/%EA%B0%80%EC%84%B1%EB%B9%84-%EA%B0%91-%EC%A0%84%EA%B8%B0%EC%9E%90%EC%A0%84%EA%B1%B0-%EC%83%A4%EC%98%A4%EB%AF%B8-HIMO-V1-%EC%A7%81%EA%B5%AC-%ED%9B%84%EA%B8%B0</link>
<description>&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:580px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F99C0CA3B5BC187D41FEEE0&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99C0CA3B5BC187D41F&quot; filemime=&quot;image/jpeg&quot; filename=&quot;샤오미_himo_11.png&quot; height=&quot;587&quot; width=&quot;580&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;샤오미에서&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;https://youpin.mi.com/detail?gid=102351&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot; style=&quot;font-size: 14.6667px;&quot;&gt;크라우드 펀딩&lt;/a&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;을 통해 새로운 전기자전거 HIMO V1을 출시하였습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;실물도 매우 예쁘고(실제 첫 테스트 주행 시 몇몇 분께서 어느 제품인지 여쭤보셨습니다),&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;가격도 저렴하여 전기자전거 장만을 고려하고 계시는 분들께는 좋은 기회인 것 같습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;사이즈가 작아 자동차 트렁크에 들어갈 수 있습니다. 반대로 생각해보면 180이상의 장신들이 타시기엔 다소 불편함이 있을 것 같습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;우선 스펙을 살펴보면&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;txc-textbox&quot; style=&quot;border-style: solid; border-width: 1px; border-color: rgb(238, 238, 238); background-color: rgb(238, 238, 238); padding: 10px;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;모터전력: 250w&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;최대속력: 20km/h (25km/h 으로 변경 가능)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;제품무게: 16.7kg&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;가용하중: 100kg&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;주행 모드: eco mode(PAS 방식), mid mode(스로틀 방식), high mode(스로틀 방식)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;최대 이동거리: eco mode(50km), mid/high mode(30km)&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;




&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;테스트 주행해본 결과 실제 최대속력은 eco 모드(16km/h), mid 모드(18km/h), high 모드(23km/h) 정도 입니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;크기가 큰 전기자전거 만큼 성능은 나오지 않지만 가볍게 출퇴근 용도로 사용하시기엔 크기도 작고 좋을 것 같습니다. 오르막길도 크게 무리 없이 올라가집니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;구입은 현재 국내에서 총판을 통해 판매되고 있지 않고 큐텐&amp;nbsp;직구를 통해 구매하실 수 있습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;shr_item&quot; style=&quot;position:relative; min-height:158px; margin:12px 0; padding:9px 10px; border:1px solid #dbdbdb; border-radius:1px; background-color:#fff;&quot;&gt;&lt;div class=&quot;item_dtl&quot; style=&quot;position:relative; height:158px; padding:5px; border:1px solid #f0f1f4;&quot;&gt;&lt;span class=&quot;thmb&quot; style=&quot;float:left; overflow:hidden; width:156px; height:156px; margin-right:9px; border:1px solid #e7e7e7;&quot;&gt;&lt;a href=&quot;https://qoo.tn/AD18JQ/Q130684404&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://gd.image-gmkt.com/li/696/515/1183515696.g_400-w-st_g.jpg&quot; width=&quot;156&quot; alt=&quot;&quot; style=&quot;vertical-align: middle; border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;a href=&quot;https://qoo.tn/AD18JQ/Q130684404&quot; target=&quot;_blank&quot; class=&quot;tit&quot; style=&quot;overflow:hidden; max-height:68px; margin-bottom:7px; line-height:17px; color:#000;cursor:pointer;&quot;&gt;[US$298.00](▼17%)♥ HIMO전동 조력 자전거 ♥ 실제 / 다중 모드 승차 / 휴대용 접이식/무료배송 /관부&lt;span style=&quot;font-size: 11pt;&quot;&gt;가세 포함&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;url&quot; style=&quot;position: absolute; left: 170px; bottom: 10px; display: block; font-weight: bold; color: rgb(145, 151, 163); font-size: 11pt;&quot;&gt;WWW.QOO10.COM&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;
&lt;/span&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;큐텐 쿠폰을 적용하시면 좀 더 저렴하게 구매하실 수 있으니 꼭 잊지말고 사용하시길 바랍니다. (&lt;/span&gt;&lt;a href=&quot;http://blog.naver.com/kagamlzzang/221103790385&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;큐펜 쿠폰 발급방법&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;쿠폰을 적용하시면 가격은 대략 관세포함 40만원 이하로 사실 수 있습니다. 관세를 직접 내시려면 30만원대 초반에 구매하실 수 있습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;혹시 직구가 처음이시라도 크게 겁먹을 필요없습니다. 국문 주소를 입력하셔도 집까지 무료로 배송이 되기때문에 일반 국내 쇼핑몰에서 쇼핑한다고 생각하시면 됩니다. 단 세관통관을 통해 개인통관고유부호만 추가로 입력하시면 됩니다. (&lt;/span&gt;&lt;a href=&quot;http://blog.naver.com/kagamlzzang/221103781301&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;통관부호 발급방법&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;관세의 경우 직접 납부하셔도 되고 제품 구매시 옵션을 통해 관세까지 미리 같이 결제하실 수 도 있습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F997DDA445BC18D89360CAC&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/997DDA445BC18D8936&quot; filemime=&quot;image/jpeg&quot; filename=&quot;샤오미_himo_1.jpg&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;배송은 대략 1주일 정도 걸립니다. 중국 현지 사정에 따라 더 일찍 도착할 수도, 더 늦게 도착할 수 도 있습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;박스를 개봉해보면 따로 조립할 필요없이 완제품으로 들어가 있습니다. 안장만 꼽아주시면 됩니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:960px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F9936F8495BC18E29192292&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/9936F8495BC18E2919&quot; filemime=&quot;image/jpeg&quot; filename=&quot;샤오미_himo_2.jpg&quot; height=&quot;540&quot; width=&quot;960&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;박스에서 꺼낸 샤오미 HIMO V1의 모습입니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F998B3D485BC18EA82DC2D1&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/998B3D485BC18EA82D&quot; filemime=&quot;image/jpeg&quot; filename=&quot;샤오미_himo_3.jpg&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;안장만 꼽아주고 핸들만 바로 세워주시면 됩니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F99F0C9495BC18EE4202A8A&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99F0C9495BC18EE420&quot; filemime=&quot;image/jpeg&quot; filename=&quot;샤오미_himo_4.jpg&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;기본으로 최대속력이 20km/h로 출고되지만 설정을 통해 25km/h로 변경가능합니다.&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;그럼 샤오미 HIMO V1 속도 업그레이드 방법을 알려드리겠습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;1. 우선 계기판의 화살표 버튼과 M버튼을 동시에 누르고 있으면 아래 사진처럼 숫자가 표시되게 됩니다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;2. 화살표 버튼을 눌러 숫자를 150까지 올려줍니다. (M버튼을 누르면 숫자가 줄어듭니다)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;3. 다시 화살표 버튼과 M버튼을 동시에 누르면 저장되고 기존 화면으로 돌아옵니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:960px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F9975604D5BC18F202E1AC0&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/9975604D5BC18F202E&quot; filemime=&quot;image/jpeg&quot; filename=&quot;샤오미_himo_5.jpg&quot; height=&quot;540&quot; width=&quot;960&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;야외샷입니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F9907924A5BC190A4298F7D&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/9907924A5BC190A429&quot; filemime=&quot;image/jpeg&quot; filename=&quot;샤오미_himo_6.jpg&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/206&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>그 외</category>
<category>샤오미 HIMO V1</category>
<category>샤오미 전기자전거</category>
<category>샤오미 하이모</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/206</guid>
<comments>https://itstory.tk/entry/%EA%B0%80%EC%84%B1%EB%B9%84-%EA%B0%91-%EC%A0%84%EA%B8%B0%EC%9E%90%EC%A0%84%EA%B1%B0-%EC%83%A4%EC%98%A4%EB%AF%B8-HIMO-V1-%EC%A7%81%EA%B5%AC-%ED%9B%84%EA%B8%B0#entry206comment</comments>
<pubDate>Sat, 13 Oct 2018 15:32:26 +0900</pubDate>
</item>
<item>
<title>[책 리뷰] 아무것도 모르고 시작하는 인공지능 첫걸음</title>
<link>https://itstory.tk/entry/%EC%B1%85-%EB%A6%AC%EB%B7%B0-%EC%95%84%EB%AC%B4%EA%B2%83%EB%8F%84-%EB%AA%A8%EB%A5%B4%EA%B3%A0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5-%EC%B2%AB%EA%B1%B8%EC%9D%8C</link>
<description>&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:400px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F99150D4D5B4C7C6E211D68&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99150D4D5B4C7C6E21&quot; filemime=&quot;image/jpeg&quot; filename=&quot;B3863756314_l.jpg&quot; height=&quot;514&quot; width=&quot;400&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;최근 머신러닝, 딥러닝 등 인공지능 분야에 대한 세상의 관심이 뜨겁습니다.&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;IT관련 종사자가 아닌 일반인들도 알파고 인공지능, 테슬라 자율주행, AI 스피커&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;&amp;nbsp;등을 접하고 인공지능 분야에 대해 관심을 가질 정도이니 말 다한 셈이죠.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;하지만 정작 IT 개발자라고 하더라도 인공지능, 인공지능 말만 많이 들어봤지 어떤 개념으로 어떻게 돌아가는지는 모르는 분들이 많을 것입니다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;지금까지 해오던 웹, 앱 같은 개발과는 어찌보면 전혀 다른 분야이기 때문이죠.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;그래서 대세를 따라 인공지능을 배워보고 싶지만 어디서부터 어떻게 시작해야될지 감이 안잡히는 분들도 많으실 겁니다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;한빛미디어에서 출판한 &quot;아무것도 모르고 시작하는 인공지능 첫걸음&quot; 책은 제목 그래도 아무것도 모르고 인공지능을 시작하려는 분께 딱인 책인 것 같습니다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;책을 펴고 본격적으로 읽기전 전체적으로 훑어봤을 때 예상하던 것과 달라 많이 놀랐습니다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;딥러닝 모델에 대한 이론적인 설명과&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;&amp;nbsp;텐서플로우나 케라스같은 머신러닝 프레임워크를 이용하여 실습을 진행하는 그런 일반적인(?) 기술서적일 것이라 생각했지만, 이 책에는 코드가 단 한줄도 없습니다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;당장 나는 모델에 대한 개념을 익히고 코드를 작성하면서 동작하는 것을 눈으로 돌아가는 것을 원하시는 분이라면 적성에 안맞는 책이기도 합니다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;하지만 그건 어디까지나 인공지능에 대한 대략적인 이해를 가진 분들에게 해당하는 이야기입니다.&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;결국 인공지능에 대해 제대로 학습하기 위해선 단순히 코드를 짜는 것보단 기본적인 &lt;/span&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;원리를 이해를 하는 것이 필&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;수 있습니다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;&quot;아무것도 모르고 시작하는 인공지능 첫걸음&quot; 책은 인공지능의 역사, 용어, 인공지능이 어떻게 사고하는 지와 알고리즘 등의 전반적인 이론을 그림&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;과 함께 잘 설명해줍니다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;인공지능에 대해 기초지식이 없거나&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;&amp;nbsp;인공지능에 등장하는 용어들에 대해 잘 모르시는 입문자라면 꼭 읽어볼만한 책입니다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&lt;/span&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&lt;/span&gt;&lt;a href=&quot;http://www.hanbit.co.kr/store/books/look.php?p_code=B3863756314&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&quot;&lt;/span&gt;&lt;/a&gt;&lt;a href=&quot;http://www.hanbit.co.kr/store/books/look.php?p_code=B3863756314&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;아무것도 모르고 시작하는 인공지능 첫걸음&quot;&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&lt;/span&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&lt;/span&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;의 자세한 내용은 한빛미디어 홈페이지에서 확인 하실 수 있습니다.&lt;/span&gt;&lt;/p&gt;&lt;style type=&quot;text/css&quot;&gt;
p, li { white-space: pre-wrap; }
&lt;/style&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: right;&quot;&gt;&lt;span style=&quot;color: rgb(85, 85, 85); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;이 글은 한빛미디어의 도서 리뷰 활동으로 작성된 글입니다.&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/205&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>그 외</category>
<category>아무것도 모르고 시작하는 인공지능 첫걸음</category>
<category>한빛출판사</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/205</guid>
<comments>https://itstory.tk/entry/%EC%B1%85-%EB%A6%AC%EB%B7%B0-%EC%95%84%EB%AC%B4%EA%B2%83%EB%8F%84-%EB%AA%A8%EB%A5%B4%EA%B3%A0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5-%EC%B2%AB%EA%B1%B8%EC%9D%8C#entry205comment</comments>
<pubDate>Mon, 16 Jul 2018 20:34:40 +0900</pubDate>
</item>
<item>
<title>Spring MVC Last-Modified, If-Modified-Since 캐시 설정</title>
<link>https://itstory.tk/entry/Spring-MVC-LastModified-IfModifiedSince-%EC%BA%90%EC%8B%9C-%EC%84%A4%EC%A0%95</link>
<description>&lt;p&gt;Spring MVC에서 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Last-Modified&quot;&gt;Last-Modified&lt;/a&gt;와 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/If-Modified-Since&quot;&gt;If-Modified-Since&lt;/a&gt; 헤더를 통한 캐싱방법을 살펴보겠습니다. 웹 캐싱에 대한 이론적인 부분과 종류들은 다른 설명 글들이 많기 때문에 자세한 내용은 생략하도록 하겠습니다 (&lt;a href=&quot;http://cyberx.tistory.com/9&quot;&gt;링크&lt;/a&gt;).&lt;/p&gt;&lt;p&gt;캐싱의 순서는 다음과 같이 이루어집니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;브라우저에서 필요한 리소스를 서버에 최초로 요청합니다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;서버에서 응답헤더에 &lt;code&gt;Last-Modified&lt;/code&gt; 헤더를 셋팅하여 요청한 리소스와 함께 내려보내면, 브라우저는 해당 리소스의 복사본을 생성하여 저장합니다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;브라우저에서 해당 리소스를 재요청할 경우에는 서버에서 &lt;code&gt;Last-Modified&lt;/code&gt; 헤더에 설정한 값을 &lt;code&gt;If-Modified-Since&lt;/code&gt; 헤더에 포함시켜 서버에 요청합니다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;서버에서는 &lt;code&gt;If-Modified-Since&lt;/code&gt; 헤더 값을 통해 해당 리소스가 변경되었으면 &lt;code&gt;Last-Modified&lt;/code&gt; 헤더에 최신 수정날짜를 설정하여 파일을 전달합니다. 변경되지 않았을 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/304&quot;&gt;304 HTTP 상태코드&lt;/a&gt;로 응답하면 브라우저는 기존에 저장한 값을 재사용하게 됩니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;스프링에서는 &lt;code&gt;ServletWebRequest&lt;/code&gt; 객체에 &lt;code&gt;checkNotModified()&lt;/code&gt; 메서드를 구현하여 일련의 과정들을 큰 작업없이 가능하게 해줍니다.&lt;/p&gt;&lt;p&gt;해당 메서드는 리소스의 최근 수정일을 인자로 받아 브라우저에서 요청할 때 설정해주는 &lt;code&gt;If-Modified-Since&lt;/code&gt; 헤더 값과 값을 비교하여 리소스가 변경이 없는 경우 &lt;code&gt;true&lt;/code&gt;를 반환하고 응답 값에 자동으로 304 NOT Modified를 설정해줍니다. 변경이 있는 경우에는 &lt;code&gt;false&lt;/code&gt;를 반환합니다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;boolean checkNotModified(long lastModifiedTimestamp);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;브라우저에서 test.txt 파일을 요청한다고 가정해봅시다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;@GetMapping(&quot;/test&quot;)
public ResponseEntity&amp;lt;byte[]&amp;gt; test(ServletWebRequest request) throws IOException {
    Resource resource = new ClassPathResource(&quot;test.txt&quot;);

    // test.txt 파일의 최근 수정일을 인자값으로 넣어
    // 변경이 일어났는지 여부를 확인합니다.
    if (request.checkNotModified(resource.lastModified())) {
        // 변경이 없는 경우(혹은 최초 요청인 경우)
        // 빈 본문 값과 함께 304 상태코드가 반환됩니다.
        return null;
    }

    return ResponseEntity.ok()
        .cacheControl(CacheControl.noCache())
        // Last-Modified 헤더에 파일의 최근 수정일을 넣어 응답합니다.
        .lastModified(resource.lastModified())
        .body(FileCopyUtils.copyToByteArray(resoure.getFile()));
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 실제 브라우저에서의 동작이 어떻게 되는지 살펴보겠습니다.&lt;/p&gt;&lt;p&gt;브라우저가 최초 요청 시 서버의 응답을 살펴보면 아래 이미지 처럼 200 상태코드와 함께 &lt;code&gt;Last-Modified&lt;/code&gt; 헤더에 해당 파일의 최근 수정일을 설정하여 내려보내지게 됩니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:622px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F9929963C5B434F3C1F561C&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/9929963C5B434F3C1F&quot; filemime=&quot;image/jpeg&quot; filename=&quot;cache1.png&quot; height=&quot;439&quot; width=&quot;622&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;두 번째 요청 시 아래 이미지 처럼 전에 서버에서 &lt;code&gt;Last-Modified&lt;/code&gt; 헤더에 응답해준 값을 &lt;code&gt;If-Modified-Since&lt;/code&gt; 헤더에 설정하여 요청하게 됩니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:661px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F998E32355B434F4925A9B1&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/998E32355B434F4925&quot; filemime=&quot;image/jpeg&quot; filename=&quot;cache2.png&quot; height=&quot;116&quot; width=&quot;661&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그러면 서버에서는 아래 이미지 처럼 &lt;code&gt;304 Not Modified&lt;/code&gt; 상태코드를 반환하며 해당 파일의 내용을 전달하지 않습니다. 브라우저는 로컬에 캐싱해둔 파일을 재사용하게 됩니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:594px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F99AFC03D5B434F55032B2F&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99AFC03D5B434F5503&quot; filemime=&quot;image/jpeg&quot; filename=&quot;cache3.png&quot; height=&quot;297&quot; width=&quot;594&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/204&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>If-Modified-Since</category>
<category>Last-Modified</category>
<category>Spring MVC</category>
<category>웹 캐시</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/204</guid>
<comments>https://itstory.tk/entry/Spring-MVC-LastModified-IfModifiedSince-%EC%BA%90%EC%8B%9C-%EC%84%A4%EC%A0%95#entry204comment</comments>
<pubDate>Mon, 09 Jul 2018 21:05:19 +0900</pubDate>
</item>
<item>
<title>Java10 신규 기능(특징) 정리</title>
<link>https://itstory.tk/entry/Java-10-%EC%8B%A0%EA%B7%9C-%EA%B8%B0%EB%8A%A5%ED%8A%B9%EC%A7%95-%EC%A0%95%EB%A6%AC</link>
<description>&lt;p&gt;Java SE 8이 2014년 3월에 출시되고 3년 반이 흘러 Java SE 9이 2017년 9월에 출시되었습니다. 그리고 2018년 3월에 Java SE 10이 6개월만에 출시되었습니다. Java 10이 6개월만에 출시된 이유는 오라클이 클라우드 주도 개발자(cloud-driven developer)들을 지원하기 위해 앞으로 자바의 릴리즈 주기를 6개월로 변경하였기 때문입니다. 이는 Java 9부터 적용되며 매년 3월, 9월에 새로운 릴리즈가 출시됩니다. &lt;/p&gt;
&lt;p&gt;또한 3년 단위로 엔터프라이즈 환경을 위해 안정성에 초점을 맞춘 Long-Term Support (LTS) 버전이 출시될 예정입니다. Java 11이 차세대 LTS 버전으로 2021년 9월에 출시될 예정입니다. Java Platform Group, Oracle의 Chief Architect인 Mark Reinhold는 다음과 같이 설명했습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;OpenJDK binaries become the primary channel for developers to access the latest innovation in the Java SE platform, the Oracle JDK will remain as a long term support LTS offering for Oracle’s commercial and support customers.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이제부터 Java 10에 새로 추가된 12가지 특징들을 살펴보겠습니다.&lt;/p&gt;



&lt;h3 id=&quot;1-jep-286-local-variable-type-inference&quot;&gt;1. JEP 286: Local-Variable Type Inference&lt;/h3&gt;

&lt;p&gt;Java 10의 변화 중 코드 측면에서 가장 흥미로운 점을 하나 고르라면 당연 Local Variable Type Inference 입니다. 로컬변수 선언을 &lt;code&gt;var&lt;/code&gt; 를 이용하여 기존의 엄격한 타입 선언 방식에서 탈피하여 컴파일러에게 타입을 추론하게할 수 있습니다. 기존에 lombok에서 제공하는 val/var 기능을 사용하고 계셨다면 크게 생소하진 않을 내용입니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;var list = new ArrayList&amp;lt;String&amp;gt;();  // infers ArrayList&amp;lt;String&amp;gt;
var stream = list.stream();          // infers Stream&amp;lt;String&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Local Variable Type Inference는 다음과 같은 상황에서만 사용할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;초기화된 로컬 변수 선언 시&lt;/li&gt;
&lt;li&gt;반복문에서 지역변수 선언 시 (enhanced for loop 포함)&lt;/li&gt;
&lt;/ul&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var numbers = List.of(1, 2, 3, 4, 5);

for (var number : numbers) {
    System.out.println(number);
}

for (var i = 0; i &amp;lt; numbers.size(); i++) {
    System.out.println(numbers.get(i));
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java 9에서 등장한 &lt;a href=&quot;https://docs.oracle.com/javase/9/jshell/introduction-jshell.htm#JSHEL-GUID-630F27C8-1195-4989-9F6B-2C51D46F52C8&quot;&gt;jshell&lt;/a&gt;를 이용하면 쉽게 테스트할 수 있습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;jshell&amp;gt; var a = new ArrayList&amp;lt;&amp;gt;();
a ==&amp;gt; []

jshell&amp;gt; a.add(&quot;abc&quot;)
$2 ==&amp;gt; true

jshell&amp;gt; a.add(123)
$3 ==&amp;gt; true

jshell&amp;gt; a.get(0)
$4 ==&amp;gt; &quot;abc&quot;

jshell&amp;gt; a.get(1)
$5 ==&amp;gt; 123

jshell&amp;gt; a = &quot;123&quot;
|  Error:
|  incompatible types: java.lang.String cannot be 
|  converted to java.util.ArrayList&amp;lt;java.lang.Object&amp;gt;
|  a = &quot;123&quot;
|      ^---^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고로 다이아몬드 연산자 안에 타입을 넣지 않으면 ArrayList&amp;lt;Object&amp;gt;로 추론합니다.&lt;/p&gt;
&lt;p&gt;단, 주의해야할 점은 기존에 자바의 RHS(lamda, generics, diamond)에서 이미 타입 추론을 하고 있기 때문에, 해당 표현식의 LHS에 &lt;code&gt;var&lt;/code&gt; 로 대입하면 추론이 실패될 수 있습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;jshell&amp;gt; var f = () -&amp;gt; { };
|  Error:
|  cannot infer type for local variable f
|    (lambda expression needs an explicit target-type)
|  var f = () -&amp;gt; { };
|  ^----------------^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Local Variable Type Inference에 대해 더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/286&quot;&gt;OpenJDK : JEP 286&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;
&lt;p&gt;아래 차트는 Oracle이 Java 커뮤니티에서 Local Variable Type Inference에 관해 진행한 설문 결과입니다. 대다수가 이 변화를 환영하는 분위기네요.&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:677px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F995CC1445AE6D33C2173BA&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/995CC1445AE6D33C21&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Local_Variable_Type_Inference_for_Java_-_응답___SurveyMonkey.png&quot; height=&quot;747&quot; width=&quot;677&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-jep-296-consolidate-the-jdk-forest-into-a-single-repository&quot;&gt;2. JEP 296: Consolidate the JDK Forest into a Single Repository&lt;/h3&gt;

&lt;p&gt;수많은 JDK forest 저장소들을 단일 저장소로 통합시켰다는 내용으로, 내부 유지보수에 관한 것으로 설명은 생략하겠습니다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/296&quot;&gt;OpenJDK : JEP 296&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;3-jep-304-garbage-collector-interface&quot;&gt;3. JEP 304: Garbage-Collector Interface&lt;/h3&gt;

&lt;p&gt;간결한 garbage collector(GC) 인터페이스를 새로 추가하여 서로 다른 gc들의 코드를 분리할 수 있도록 개선시켰습니다. GC 혹은 HotSpot 개발자들에게 관련된 사항으로 설명은 생략하겠습니다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/304&quot;&gt;OpenJDK : JEP 304&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;4-jep-307-parallel-full-gc-for-g1&quot;&gt;4. JEP 307: Parallel Full GC for G1&lt;/h3&gt;

&lt;p&gt;Java 9에서 default Garbage Collector인 &lt;a href=&quot;https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector.htm#JSGCT-GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573&quot;&gt;G1&lt;/a&gt;은 full GC를 피하도록 설계되었지만, concurrent GC에서 충분한 young area를 확보하지 못하면 full GC가 발생합니다. 기존 G1에서 full GC를 수행할 때 싱글 쓰레드 방식으로 동작하는 mark-sweep-compact 알고리즘을 사용하였습니다. G1 이전의 default 였던 parallel collector 처럼 G1에서도 full GC를 병렬화 시켜 G1의 최악의 케이스에서 지연 시간을 개선시켰습니다. &lt;/p&gt;
&lt;p&gt;mark-sweep-compact 알고리즘을 병렬로 수행하도록 변경되었으며, 이 때 Young 과 Mixed GC와 동일한 쓰레드 수를 이용힙니다. &lt;code&gt;-XX:ParallelGCThreads&lt;/code&gt; 옵션을 이용해 쓰레드 수를 조절할 수 있으며, 이 옵션을 수정하면 Young 과 Mixed GC에도 변경사항이 적용됩니다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/307&quot;&gt;OpenJDK : JEP 307&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;5-jep-310-application-class-data-sharing&quot;&gt;5. JEP 310: Application Class-Data Sharing&lt;/h3&gt;

&lt;p&gt;기존의 Class-Data Sharing(CDS) 기능을 확장해 애플리케이션 클래스를 공유 아카이브에 배치하고 서로 다른 자바 프로세스들이 공유함할 수 있도록 개선함으로써, startup 시간을 단축시키고 메모리 사용량을 최적화 시켰습니다. 기존에 AppCDS 기능은 상업용으로 Oracle JDK에서만 제공되었으나, 오픈소스화 되어 Open JDK에도 사용할 수 있게 되었습니다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/310&quot;&gt;OpenJDK : JEP 310&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;6-jep-312-thread-local-handshakes&quot;&gt;6. JEP 312: Thread-Local Handshakes&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html&quot;&gt;JVM safepoint&lt;/a&gt;는 Stop the World를 의미합니다. Thread-Local Handshake는 이런 safepoint가 발생하는 지점들을 줄이기 위한 프로젝트입니다. 모든 쓰레드를 동시에 멈춰야 했던 기존과 달리 쓰레드를 개별로 멈출 수 있게 되었고, VM safepoint를 수행하지 않고도 개별 Thread에서 콜백을 실행할 수 있습니다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/312&quot;&gt;OpenJDK : JEP 312&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;7-jep-313-remove-the-native-header-generation-tool-javah&quot;&gt;7. JEP 313: Remove the Native-Header Generation Tool (javah)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;${JAVA_HOME}/bin&lt;/code&gt; 디렉터리 안에는 JDK에서 제공하는 수많은 툴들이 존재합니다. javah는 그 중에 하나로, 코드에 native 메서드들을 사용할 경우 JNI 헤더 파일들을 생성해줍니다. Java 8부터 javac에서 JNI 헤더 파일 생성을 지원하기 때문에 javah이 더 이상 필요하지 않아 제거되었습니다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/313&quot;&gt;OpenJDK : JEP 313&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;8-jep-314-additional-unicode-language-tag-extensions&quot;&gt;8. JEP 314: Additional Unicode Language-Tag Extensions&lt;/h3&gt;

&lt;p&gt;Java SE 7부터 &lt;a href=&quot;https://ko.wikipedia.org/wiki/IETF_%EC%96%B8%EC%96%B4_%ED%83%9C%EA%B7%B8&quot;&gt;BCP 47 언어 태그&lt;/a&gt;를 지원하기 시작했습니다. 언어 태그는 하이픈에 따라서 나뉘는, 하나 이상의 하위 태그(subtag)로부터 구성됩니다. 일반적으로는 다음의 순서로 쓰입니다. &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;language(언어)&lt;/li&gt;
&lt;li&gt;script(문자 체계)&lt;/li&gt;
&lt;li&gt;region(지역)&lt;/li&gt;
&lt;li&gt;variant(변이형)&lt;/li&gt;
&lt;li&gt;extension(확장)&lt;/li&gt;
&lt;li&gt;private use(개인용)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;en-GB&lt;/code&gt; 와 &lt;code&gt;en-US&lt;/code&gt; 언어태그를 예로 살펴보면, en은 영어를 의미하고 GB(Great Britain)와 US(United States)는 지역을 나타냅니다. Java 9에서는 &lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/documentation/java9locales-3559485.html&quot;&gt;BCP 47 U 언어태그 확장&lt;/a&gt; ca와 nu를 지원하기 시작했습니다. 예를들어 &lt;code&gt;th-TH-u-ca-buddhist-nu-thai&lt;/code&gt;는 불교달력(buddhist)와 태국 숫자 체계(nu-thai)기반의 태국지역(TH)의 태국어(th)를 나타냅니다. Java 10에서는 다음의 추가 확장을 지원하며, 이를 지원하기 위해 java.util.Local와 관련된 API들이 보완되었습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cu (currency type)&lt;/li&gt;
&lt;li&gt;fw (first day of week)&lt;/li&gt;
&lt;li&gt;rg (region override)&lt;/li&gt;
&lt;li&gt;tz (time zone)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/314&quot;&gt;OpenJDK : JEP 314&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;9-jep-316-heap-allocation-on-alternative-memory-devices&quot;&gt;9. JEP 316: Heap Allocation on Alternative Memory Devices&lt;/h3&gt;

&lt;p&gt;JVM heap 영역을 &lt;a href=&quot;https://en.wikipedia.org/wiki/NVDIMM&quot;&gt;NVDIMM&lt;/a&gt;(비휘발성 NAND 플래시 메모리) 혹은 사용자 지정과 같은 대체 메모리 장치에 할당할 수 있게됩니다. (이제 정전 걱정은 할 필요 없는 것일까요?) 이 기능은 새로 추가된 옵션인 &lt;code&gt;-XX:AllocateHeapAt=&amp;lt;path&amp;gt;&lt;/code&gt;를 이용해 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/316&quot;&gt;OpenJDK : JEP 316&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;10-jep-317-experimental-java-based-jit-compiler&quot;&gt;10. JEP 317: Experimental Java-Based JIT Compiler&lt;/h3&gt;

&lt;p&gt;현재 HotSpot JVM에는 C1, C2라는 두개의 런타임 컴파일러를 가지고 있습니다. 이 외에도 Java 언어 기반의 &lt;a href=&quot;https://ko.wikipedia.org/wiki/JIT_%EC%BB%B4%ED%8C%8C%EC%9D%BC&quot;&gt;JIT 컴파일러&lt;/a&gt;인 &lt;a href=&quot;https://github.com/oracle/graal&quot;&gt;Graal&lt;/a&gt;이 있으며, JDK 9에 소개된 JVM compiler interface(JVMCI)를 사용하고 있습니다. Graal은 이미 JDK에 포함되어 있으며, JDK 10에서 Linux/x64 플랫폼에서 실험적으로 JIT 컴파일러로 사용할 수 있습니다. Graal을 JIT 컴파일러로 설정하기 위해선, &lt;code&gt;-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler&lt;/code&gt; 옵션을 사용하면 됩니다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/317&quot;&gt;OpenJDK : JEP 317&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;11-jep-319-root-certificates&quot;&gt;11. JEP 319: Root Certificates&lt;/h3&gt;

&lt;p&gt;HTTPS 암호화 통신에 쓰는 SSL/TLS 인증서를 발급해주는 인증기관을 Certificate Authority(CA)라고 부릅니다. 보통 브라우저는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Root_certificate&quot;&gt;최상위 인증기관(trusted root CA)&lt;/a&gt; 목록을 자체적으로 가지고 있어, 인증서가 신용있다고 판단한 CA로부터 서명된 것인지 확인합니다.&lt;/p&gt;
&lt;p&gt;Java도 root CA를 위한 저장소를 가지고 있습니다. &lt;code&gt;${JAVA_HOME}/lib/security&lt;/code&gt; 디렉터리 하위에 있는 &lt;code&gt;cacerts&lt;/code&gt; 파일로, 단순한 keystore입니다. 기존에 OpenJDK 버전은 빈파일이 기본 셋팅이었지만, JDK 10부터는 Oracle JDK 버전에만 있던 root CA 목록이 기본으로 포함됩니다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/319&quot;&gt;OpenJDK : JEP 319&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;12-jep-322-time-based-release-versioning&quot;&gt;12. JEP 322: Time-Based Release Versioning&lt;/h3&gt;

&lt;p&gt;처음에 언급한 자바의 새로운 릴리즈 주기를 위한 버저닝(versioning) 포맷을 위한 변경사항입니다. 새로 적용될 포맷은 &lt;code&gt;[1-9][0-9]*((\.0)*\.[1-9][0-9]*)*&lt;/code&gt; 형식으로 &lt;code&gt;$FEATURE.$INTERIM.$UPDATE.$PATCH&lt;/code&gt; 의미를 가집니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$FEATURE - 6개월 주기로 증가됩니다. 2018년 3월 버전은 JDK 10, 2018년 9월 버전은 JDK 11입니다.&lt;/li&gt;
&lt;li&gt;$INTERIM - 6개월 주기 릴리즈 모델에서는 interim 릴리즈가 없어 항상 0 입니다.&lt;/li&gt;
&lt;li&gt;$UPDATE - 보안 이슈, 버그 등의 수정이 업데이트된 버전을 나타내며 1달 단위로 증가됩니다. 2018년 4월 버전은 JDK 10.0.1, 5월 버전은 JDK 10.0.2 입니다.&lt;/li&gt;
&lt;li&gt;$PATCH - 치명적인 이슈를 수정하여 배포할 때만 생기는 긴급 패치 버전입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F99180F4D5AE6D35826A3A6&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99180F4D5AE6D35826&quot; filemime=&quot;image/jpeg&quot; filename=&quot;java_release.jpg&quot; height=&quot;297&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(이미지 출처: &lt;a href=&quot;https://twitter.com/java/status/969287657015664640/photo/1?tfw_site=laytoun&amp;amp;ref_src=twsrc%5Etfw&amp;amp;ref_url=http%3A%2F%2Faboullaite.me%2F10-new-features-in-java-10%2F&quot;&gt;Java 공식 트위터&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/322&quot;&gt;OpenJDK : JEP 322&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;참조&quot;&gt;참조&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://openjdk.java.net/projects/jdk/10/&quot;&gt;http://openjdk.java.net/projects/jdk/10/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blogs.oracle.com/java-platform-group/introducing-java-se-10&quot;&gt;https://blogs.oracle.com/java-platform-group/introducing-java-se-10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html&quot;&gt;http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/9/index.html&quot;&gt;https://docs.oracle.com/javase/9/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/10/index.html&quot;&gt;https://docs.oracle.com/javase/10/index.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/203&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java 10</category>
<category>JDK 10</category>
<category>new features</category>
<category>자바 10</category>
<category>특징</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/203</guid>
<comments>https://itstory.tk/entry/Java-10-%EC%8B%A0%EA%B7%9C-%EA%B8%B0%EB%8A%A5%ED%8A%B9%EC%A7%95-%EC%A0%95%EB%A6%AC#entry203comment</comments>
<pubDate>Mon, 30 Apr 2018 17:28:16 +0900</pubDate>
</item>
<item>
<title>[Gof 디자인 패턴] Strategy(전략) 패턴</title>
<link>https://itstory.tk/entry/Gof-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-Strategy%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4</link>
<description>&lt;p&gt;프로그래밍을 하다보면 비슷한 동작이지만 구현 방법(알고리즘)이 다른 경우를 많이 겪습니다. 예를 들어 외부 메일 가져오기 기능을 구현하려고 합니다. 네이버 메일, 다음 메일, 구글 메일 등을 가져온다고 가정하면 메일을 가져온다에서는 동일한 액션이지만 내부 구현을 살펴보면 호출 API 정보, 필요 파라미터 명 등이 조금씩 다를 수 있습니다. &lt;/p&gt;&lt;p&gt;처음에 네이버 메일와 구글 메일 가져오기만 지원한다면 if문 분기를 통해 다르게 처리할 수 도 있겠지만, 나중에 다음 메일과 네이트 메일 등도 추가적으로 지원한다고 하면 분기가 계속 증가할 것 입니다. 이러면 SOLID 설계 원칙의 개방-폐쇄 원칙(OCP)에 위반하는 코드가 생성될 확률이 커집니다. &lt;strong&gt;Strategy(전략) 패턴을 사용하면 이와 같이 같은 문제를 다른 방법으로도 쉽게 변경하면서 해결할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;위에서 언급한 외부 메일 가져오기 기능으로 예제를 살펴보겠습니다. 예제 프로그램의 클래스 다이어그램은 다음과 같습니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F991B3E3F5ACEF96A2771C1&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/991B3E3F5ACEF96A27&quot; filemime=&quot;image/jpeg&quot; filename=&quot;gof_strategy_pattern.jpg&quot; height=&quot;260&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;MailImporter.java&lt;/i&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public class MailImporter {
    private MailImportStrategy strategy;

    public MailImporter(MailImportStrategy strategy) {
        this.strategy = strategy;
    }

    public void changeStrategy(MailImportStrategy strategy) {
        this.strategy = strategy;
    }

    public void imports(){
        strategy.execute();
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MailImporter&lt;/code&gt; 클래스는 메일 가져오기 기능을 수행할 클래스입니다. &lt;code&gt;imports()&lt;/code&gt; 메서드에서 해당 서비스에 맞는 가져오기 기능(전략)을 구현한 &lt;code&gt;MailImportStrategy&lt;/code&gt; 클래스에 &lt;strong&gt;위임&lt;/strong&gt;하고 있습니다.&lt;/p&gt;&lt;p&gt;&lt;i&gt;MailImportStrategy.java&lt;/i&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public interface MailImportStrategy {
    void execute();
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MailImportStrategy&lt;/code&gt; 인터페이스는 해당 서비스에 맞는 외부 메일을 가져오는 기능(전략)을 위한 인터페이스입니다. 이 인터페이스를 구현하는 네이버, 구글, 다음 메일 가져오기 클래스에서 &lt;code&gt;execute()&lt;/code&gt; 메서드를 각각의 전략(각 시스템이 요구하는 정보)에 맞게 구현할 것 입니다.&lt;/p&gt;&lt;p&gt;&lt;i&gt;GoogleMailImportStrategy.java&lt;/i&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public class GoogleMailImportStrategy implements MailImportStrategy {
    @Override
    public void execute() {
        // Gmail의 필요정보에 맞게 가져오기 수행
        // ...
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;i&gt;NaverMailImportStrategy.java&lt;/i&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public class NaverMailImportStrategy implements MailImportStrategy {
    @Override
    public void execute() {
        // 네이버 메일의 필요정보에 맞게 가져오기 수행
        // ...
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;i&gt;NateMailImportStrategy.java&lt;/i&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public class NateMailImportStrategy implements MailImportStrategy {
    @Override
    public void execute() {
        // 네이트 메일의 필요정보에 맞게 가져오기 수행
        // ...
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 main 클래스에서 각 서비스 별로 메일 가져오기를 수행하여 봅시다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public class App {
    public static void main(String[] args) {
        // 구글 메일 가져오기 전략
        MailImporter mailImporter = new MailImporter(
            new GoogleMailImportStrategy()
        );

        // 메일 가져오기 수행
        mailImporter.imports();

        // 네이버 메일 가져오기로 전략 변경
        mailImporter.changeStrategy(
            new NaverMailImportStrategy()
        );

        mailImporter.imports();

        // 네이트 메일 가져오기로 전략 변경
        mailImporter.changeStrategy(
            new NateMailImportStrategy()
        );

        mailImporter.imports();
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이와 같이 Strategy 패턴을 이용하면 프로그램을 복잡하게 만드는 것처럼 보이지만 실제로는 그렇지 않습니다. 위임이라는 느슨한 연결을 사용하고 있어 전략을 용이하게 교환할 수 있습니다.&lt;/p&gt;&lt;p&gt;예를들어 현재 네이버, 구글, 네이트 메일 가져오기 기능만을 제공하고 있는데 다음 메일도 추가로 지원하는 것으로 스펙이 변경되었다고 가정합시다. 분기를 통해 서비스별 메일 가져오기를 구현하였다면 기존 가져오기 기능에 수정이 불가피하지만, 위의 Strategy 패턴에서는 &lt;code&gt;MailImportStrategy&lt;/code&gt; 인터페이스를 상속받아 &lt;code&gt;DaumMailImportStrategy&lt;/code&gt; 만 구현하면 됩니다. 기존 코드의 수정을 하여 사이드이펙트가 생길까 염려할 필요가 없게되는 것이죠. 즉, &lt;strong&gt;확장에는 열려있고 변경에는 닫혀있는 개방-폐쇄 원칙(OCP)을 수용할 수 있게 됩니다.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Strategy 패턴의 등장인물은 다음과 같습니다.&lt;/p&gt;&lt;p&gt;&lt;i&gt;Strategy&lt;/i&gt;&lt;/p&gt;&lt;p&gt;전략을 이용하기 위한 인터페이스(API)를 결정합니다. 예제에서 &lt;code&gt;MailImportStrategy&lt;/code&gt; 인터페이스가 이 역할을 합니다.&lt;/p&gt;&lt;p&gt;&lt;i&gt;ConcreteStrategy&lt;/i&gt;&lt;/p&gt;&lt;p&gt;Strategy 인터페이스를 실제로 구현한 클래스입니다. 예제에서 &lt;code&gt;NaverMailImportStrategy&lt;/code&gt;, &lt;code&gt;GoogleMailImportStrategy&lt;/code&gt;, &lt;code&gt;NateMailImportStrategy&lt;/code&gt; 클래스가 이 역할을 합니다.&lt;/p&gt;&lt;p&gt;&lt;i&gt;Context&lt;/i&gt;&lt;/p&gt;&lt;p&gt;Strategy를 이용하는 역할을 합니다. 예제에서 &lt;code&gt;MailImporter&lt;/code&gt; 클래스가 이 역할을 합니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:652px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F991D68345ACEF98F37FC74&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/991D68345ACEF98F37&quot; filemime=&quot;image/jpeg&quot; filename=&quot;strategy2.jpg&quot; height=&quot;348&quot; width=&quot;652&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/202&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Gof design pattern</category>
<category>GoF 디자인 패턴</category>
<category>Strategy 패턴</category>
<category>전략 패턴</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/202</guid>
<comments>https://itstory.tk/entry/Gof-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-Strategy%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4#entry202comment</comments>
<pubDate>Thu, 12 Apr 2018 14:52:23 +0900</pubDate>
</item>
<item>
<title>[JavaScript] 4. 함수와 프로토타입 체이닝 (3) - 프로토타입 체이닝</title>
<link>https://itstory.tk/entry/JavaScript-4-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B4%EB%8B%9D-3-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B4%EB%8B%9D</link>
<description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;자바스크립트는 기존 C++이나 자바 같은 객체지향 프로그래밍 언어와는 다른 프로토타입 기반의 객체지향 프로그래밍을 지원한다. 자바스크립트에서 객체는 자기 자신의 프로퍼티뿐만 아니라, 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티 또한 마치 자신의 것처럼 접근하는게 가능하다. 이것을 가능케 하는 게 바로 &lt;strong&gt;프로토타입 체이닝&lt;/strong&gt; 이다. 이전 글에 정리한 함수, this만 이해하면 프로토타입 체이닝은 딱히 어려운 점은 없다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://itstory.tk/entry/4-함수와-프로토타입-체이닝-1?category=969082&quot;&gt;[JavaScript] 4. 함수와 프로토타입 체이닝 (1) - 함수란&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://itstory.tk/entry/JavaScript-4-함수와-프로토타입-체이닝-2-this란?category=969082&quot;&gt;[JavaScript] 4. 함수와 프로토타입 체이닝 (2) - this란&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;객체 리터럴 방식으로 생성된 객체의 프로토타입 체이닝&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var myObject = {
    name: 'foo',
    sayName: function() {
        console.log('My name is ' + this.name);
    }
}

myObject.sayName(); // My name is foo
console.log(myObject.hasOwnProperty('name')); // true
console.log(myObject.hasOwnProperty('nickname')); // false&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;myObject.hasOwnProperty()&lt;/code&gt; 메서드는 어디서 난 것일까? 이 메서드는 인자로 넘긴 문자열 이름의 프로퍼티나 메서드가 있는지 체크하는 함수로 Object.prototype에 선언되어 있다.&lt;/p&gt;&lt;p&gt;객체 생성에서 말했듯이 객체 리터럴로 생성한 객체는 Object() 라는 내장 생성자 함수로 생성된 것이다. 그러면 아래 그림처럼 myObject 객체의 __proto__ 프로퍼티는 Object.prototype 객체를 가르키게 된다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:531px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F99112C475AC3049220A421&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99112C475AC3049220&quot; filemime=&quot;image/jpeg&quot; filename=&quot;myObject.jpg&quot; height=&quot;301&quot; width=&quot;531&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;자바스크립트에서 특정 객체의 프로퍼티나 메서드에 접근하려고 할 때, 해당 객체에 접근하려는 프로퍼티 또는 메서드가 없다면 __proto__ 링크를 다라 자신의 부모 역할을 하는 프로토 타입 객체의 프로퍼티를 차례대로 검색하며, 이를 프로토타입 체이닝이라고 한다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;생성자 함수로 생성된 객체의 프로토타입 체이닝&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;생성자 함수로 객체를 생성하는 경우도 다를 바가 없다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.setName = function(name) {
    this.name = name;
}

var foo = new Person('foo', 28);

console.log(foo.name); // foo

foo.setName('bar');

console.log(foo.name); // bar

console.log(foo.hasOwnProperty('name')); // true
console.log(foo.__proto__ === Person.prototype); // true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이전 &lt;a href=&quot;http://itstory.tk/entry/4-함수와-프로토타입-체이닝-1?category=969082&quot;&gt;함수편&lt;/a&gt;에서 살펴본 다이어그램에서 한 번더 확장만 하면된다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F991CBE445AC304B13050DB&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/991CBE445AC304B130&quot; filemime=&quot;image/jpeg&quot; filename=&quot;drawio-javascript-diagram_xml_-_draw_io.jpg&quot; height=&quot;546&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;그림에서 볼 수 있듯이 foo 객체의 __proto__는 Person.prototype 객체를 가르킨다. 따라서 프로토타입 체이닝을 통해 foo 객체는 &lt;code&gt;Person.prototype.setName&lt;/code&gt; 메서드를 사용할 수 있다.&lt;/p&gt;&lt;p&gt;여기서 프로토타입 체이닝이 끝나는 것이 아니라 recursive 하게 계속 진행된다. 즉 Person.prototype 객체의 __proto__는 Object.prototype을 가리키므로 foo 객체는 Object.prototype 속성들도 사용할 수 있게 된다. 코드에서 foo.hasOwnProperty 가 가능한 이유다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;프로토타입 체이닝의 종점&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;자바스크립트에서 Object.prototype 객체는 프로토타입 체이닝의 종점이다. 앞서 살펴봤듯이 객체 리터럴 방식이나 생성자 함수를 이용한 방식이나 결국엔 Object.prototype에서 프로토타입 체이닝이 끝나는 것을 알 수 있다.&lt;/p&gt;&lt;p&gt;자바스크립트의 숫자, 문자, 배열 등에서 사용되는 표준 메서드들의 경우, 이들의 프로토타입인 Number.prototype, String.prototype, Array.prototype 등에 정의되어있다. 물론 이러한 기본 내장 프로토타입 객체 또한 Object.prototype으로 연결된다.&lt;/p&gt;&lt;p&gt;Object.prototype, String.prototype 등과 같이 표준 빌트인 프로토타입 객체에도 사용자가 직접 정의한 메서드들을 추가하는 것을 허용한다. String.prototype에 추가한 메서드는 일반 문자열 표준 메서드처럼, 모든 문자열에서 접근 가능하다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;String.prototype.testMethod = function() {
    console.log(this.toString() + ' Go Go!');
}

var str = 'This is test.';

str.testMethod(); // This is test. Go Go!&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;프로토타입 메서드와 this 바인딩&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;위에서 살펴본 예제 코드들에서 prototype 객체에 정의한 메서드 내부에 &lt;code&gt;this&lt;/code&gt; 를 사용했다. 이전 글 &lt;a href=&quot;http://itstory.tk/entry/JavaScript-4-함수와-프로토타입-체이닝-2-this란?category=969082&quot;&gt;this편&lt;/a&gt;에서 설명한 this 바인딩 규칙이 그대로 적용된다. 결국, 메서드 호출 패턴에서의 this는 그 메서드를 호출한 객체에 바인딩된다는 것을 기억하자.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.setName = function(name) {
    this.name = name;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;디폴트 프로토타입은 다른 객체로 변경이 가능하다&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;디폴트 프로토타입 객체는 함수가 생성될 때 같이 생성되며, 함수의 prototype 프로퍼티에 연결된다. 자바스크립트에서는 이렇게 함수를 생성할 때 해당 함수와 연결되는 &lt;strong&gt;디폴트 프로토타입 객체를 다른 일반 객체로 변경하는 것이 가능하다.&lt;/strong&gt; 이러한 특징을 이용해서 객체지향의 상속을 구현한다.&lt;/p&gt;&lt;p&gt;여기서 주의할 점은 생성자 함수의 프로토타입 객체가 변경되면 변경된 시점 이후헤 생성된 객체들은 변경된 프로토 타입 객체로 연결되고, 이전에 생성된 객체들은 기존 프로토타입 객체로의 연결을 그대로 유지한다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Person(name) {
    this.name = name;
}

var foo = new Person('foo');

console.log(foo.country); // undefined

Person.prototype = {
    country: 'korea'
};

var bar = new Person('bar');

console.log(foo.country); // undefined
console.log(bar.country); // korea
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/201&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>자바스크립트</category>
<category>javascript</category>
<category>prototype</category>
<category>프로토타입 체이닝</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/201</guid>
<comments>https://itstory.tk/entry/JavaScript-4-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B4%EB%8B%9D-3-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B4%EB%8B%9D#entry201comment</comments>
<pubDate>Tue, 03 Apr 2018 13:37:25 +0900</pubDate>
</item>
<item>
<title>CSRF 공격이란? 그리고 CSRF 방어 방법</title>
<link>https://itstory.tk/entry/CSRF-%EA%B3%B5%EA%B2%A9%EC%9D%B4%EB%9E%80-%EA%B7%B8%EB%A6%AC%EA%B3%A0-CSRF-%EB%B0%A9%EC%96%B4-%EB%B0%A9%EB%B2%95</link>
<description>&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F991F41435ABE0C3920599D&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/991F41435ABE0C3920&quot; filemime=&quot;image/jpeg&quot; filename=&quot;0_RzQcEpN9HxWMDb8p.jpg&quot; height=&quot;429&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;CSRF 공격(Cross Site Request Forgery)은 웹 어플리케이션 취약점 중 하나로 인터넷 사용자(희생자)가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;CSRF를 통해 해커는 희생자의 권한을 도용하여 중요 기능을 실행하는 것이 가능합니다. 예를들어, 페이스북에 희생자의 계정으로 광고성 글을 올리는 것이 가능해 집니다. (물론 페이스북은 CSRF 공격에 대해 잘 대응을 하였겠지만, 이번 글에서 피해 서비스 = 페이스북으로 설명하겠습니다.) &lt;/p&gt;&lt;p&gt;조금 더 설명하자면, CSRF는 해커가 사용자의 컴퓨터를 감염시키거나 페이스북 서버를 해킹을 해서 이뤄지는 공격은 아닙니다. 그래서 CSRF 공격이 이뤄지려면 다음 조건이 만족되어야 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;위조 요청을 전송하는 서비스(페이스북)에 희생자가 로그인 상태&lt;/li&gt;
&lt;li&gt;희생자가 해커가 만든 피싱 사이트에 접속&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;언뜻 보면 이 두 조건을 다 만족하기가 어려울 것 같지만 생각처럼 드문 일은 아닙니다. 예를들어 페이스북, 네이버, 구글 등의 유명 사이트는 보통 PC에서 자동 로그인을 해놓은 경우가 많고 피싱 사이트는 피싱 메일, 음란 사이트(?) 등을 통해 접속될 수 있습니다. 또한 희생자가 해커가 만든 피싱 사이트를 하지 않더라도 해커가 XSS 공격을 성공한 정상 사이트를 통해 CSRF 공격이 수행될 수 도 있습니다.&lt;/p&gt;&lt;p&gt;CSRF가 행해지는 시나리오를 그림으로 그려보면 다음과 같습니다. 이미지는 직접 만들기 귀찮은 관계로 OWASP에 리더로 근무하시는 분의 블로그에서 발췌 하였습니다. (친절하진 않지만 그나마 제일 이해하기 쉬운 이미지인 것 같네요.)&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:747px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F99FF9D4B5ABE0C4933AE63&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99FF9D4B5ABE0C4933&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Csrf1.jpg&quot; height=&quot;379&quot; width=&quot;747&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;[이미지 출처 : &lt;a href=&quot;http://www.bluekaizen.org]&quot;&gt;http://www.bluekaizen.org]&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;좀 더 이해하기 쉽게 예제 CSRF 공격코드를 살펴보겠습니다. 물론 말도 안되는 이야기지만, 페이스북에 글을 쓸 때 아래 코드와 같은 폼이 전송된다고 예를 듭시다. 피싱 사이트에 똑같이 페이스북에 글쓰기를 요청하는 폼이 숨겨져 있고, 그 내용으로 가입하면 10만원을 준다는 사기성 광고를 본문으로 적혀져 있습니다. 희생자는 피싱 사이트에 접속함으로써 본인의 페이스북 계정으로 해당 글이 등록되게 됩니다.&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;br /&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;피싱 사이트에 포함된 코드&lt;/em&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;form action=&quot;http://facebook.com/api/content&quot; method=&quot;post&quot;&amp;gt;
    &amp;lt;input type=&quot;hidden&quot; name=&quot;body&quot; value=&quot;여기 가입하면 돈 10만원 드립니다.&quot; /&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;Click Me&quot;/&amp;gt;
&amp;lt;/form&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;위의 공격을 통해 희생자의 페친들은 친구가 올린 글이니 의심없이 속아 넘어갈 수도 있겠죠. 이런 끔찍한 일을 막기 위해 대표적인 CSRF 공격 방어 방법들을 몇 가지 살펴봅시다. 대표적으로 다음 2가지 방어기법이 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Referrer 검증&lt;/li&gt;
&lt;li&gt;Security Token 사용 (A.K.A CSRF Token)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;일반적으로 CSRF 공격 방어는 조회성(HTTP GET Method) 데이터에는 방어 대상에 두지 않고, 쓰기/변경이 가능한 POST, PATCH, DELETE Method에만 적용하면 됩니다. 물론 정말 중요한 데이터를 조회하거나 GET을 통해 쓰기/변경 등의 동작을 한다면 GET Method에도 방어를 해야할 수 도 있습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Referrer 검증&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Back-end 단에서 request의 referrer를 확인하여 domain (ex. *.facebook.com) 이 일치하는 지 검증하는 방법입니다. 일반적으로 referrer 검증만으로 대부분의 CSRF 공격을 방어할 수 있습니다. 하지만 같은 도메인 내의 페이지에 XSS 취약점이 있는 경우 CSRF 공격에 취약해질 수 있습니다. domain 단위 검증에서 좀 더 세밀하게 페이지 단위까지 일치하는지 검증을 하면 도메인 내의 타 페이지에서의 XSS 취약점에 의한 CSRF 공격을 방어할 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Security Token 사용 (A.K.A CSRF Token)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Referrer 검증이 불가한 환경이라면, Security Token를 활용할 수 있습니다. 우선 사용자의 세션에 임의의 난수 값을 저장하고 사용자의 요청 마다 해당 난수 값을 포함 시켜 전송시킵니다. 이후 Back-end 단에서 요청을 받을 때마다 세션에 저장된 토큰 값과 요청 파라미터에 전달되는 토큰 값이 일치하는 지 검증하는 방법입니다. 이 방법도 결국 같은 도메인 내에 XSS 취약점이 있다면 CSRF 공격에 취약해집니다. 아래는 간략한 샘플 코드입니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 로그인시, 또는 작업화면 요청시 CSRF 토큰을 생성하여 세션에 저장한다.
session.setAttribute(&quot;CSRF_TOKEN&quot;,UUID.randomUUID().toString());

// 요청 페이지에 CSRF 토큰을 셋팅하여 전송한다
&amp;lt;input type=&quot;hidden&quot; name=&quot;_csrf&quot; value=&quot;${CSRF_TOKEN}&quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 파라미터로 전달된 csrf 토큰 값
String param = request.getParameter(&quot;_csrf&quot;);

// 세션에 저장된 토큰 값과 일치 여부 검증
if (request.getSession().getAttribute(&quot;CSRF_TOKEN&quot;).equals(param)) {
    return true;
} else {
    response.sendRedirect(&quot;/&quot;);
    return false;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Double Submit Cookie 검증&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Double Submit Cookie 검증은 Security Token 검증의 한 종류로 세션을 사용할 수 없는 환경에서 사용할 수 있는 방법입니다. 웹브라우저의 Same Origin 정책으로 인해 자바스크립트에서 타 도메인의 쿠키 값을 확인/수정하지 못한다는 것을 이용한 방어 기법입니다. 스크립트 단에서 요청 시 난수 값을 생성하여 쿠키에 저장하고 동일한 난수 값을 요청 파라미터(혹은 헤더)에도 저장하여 서버로 전송합니다. 서버단에서는 쿠키의 토큰 값와 파라미터의 토큰 값이 일치하는 지만 검사하면 됩니다. 서버에 따로 토큰 값을 저장할 필요가 없어 위에서 살펴본 세션을 이용한 검증보다 개발 공수가 적은 편입니다. 피싱 사이트에서는 도메인이 달라 facebook.com 쿠키에 값을 저장하지 못하므로 (조금 전에 언급한 Same Origin 정책) 가능한 방어 기법입니다. 아래는 샘플 코드입니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * Generate 256-bit BASE64 encoded hashes
 *
 * @see https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#Synchronizer_.28CSRF.29_Tokens
 * @return {string}
 */
var generateCsrfToken = function() {
    function generateRandomString(length) {
        var text = &quot;&quot;;
        var possible = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;;
        for(var i = 0; i &amp;lt; length; i++) {
            text += possible.charAt(Math.floor(Math.random() * possible.length));
        }
        return text;
    };

    return btoa(generateRandomString(32));
}

// 쿠키 셋팅
var setCookie = function (cname, cvalue) {
    document.cookie = cname + &quot;=&quot; + cvalue + &quot;;path=/&quot;;
}

// 모든 ajax 요청 시 쿠키 및 header에 토큰 값을 같이 전달
jQuery.ajaxSetup({
    beforeSend: function(xhr, settings) {
        if (!(/^http:.*/.test(settings.url) || /^https:.*/.test(settings.url))) {
            var csrfToken = generateCsrfToken();

            setCookie('CSRF_TOKEN', encodeURIComponent(csrfToken));
            xhr.setRequestHeader(&quot;_csrf&quot;, csrfToken);
        }
    }
});&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 헤더로 전달된 csrf 토큰 값
String paramToken = request.getHeader(&quot;_csrf&quot;);

// 쿠키로 전달되 csrf 토큰 값
String cookieToken = null;

for (Cookie cookie : request.getCookies()) {
    if (&quot;CSRF_TOKEN&quot;.equals(cookie.getName())) {
        cookieToken = URLDecoder.decode(cookie.getValue(), &quot;UTF-8&quot;);

        // 재사용이 불가능하도록 쿠키 만료
        cookie.setPath(&quot;/&quot;);
        cookie.setValue(&quot;&quot;);
        cookie.setMaxAge(0);
        response.addCookie(cookie);

        break;
    }
}

// 두 값이 일치하는 지 검증
if (cookieToke.equals(paramToken)) {
    return true;
} else {
    return false;
}&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;참조&quot;&gt;&lt;br /&gt;&lt;/h3&gt;&lt;h3 id=&quot;참조&quot;&gt;참조&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)&quot;&gt;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://appsandsecurity.blogspot.kr/2012/01/stateless-csrf-protection.html&quot;&gt;http://appsandsecurity.blogspot.kr/2012/01/stateless-csrf-protection.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/200&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Web</category>
<category>CSRF Token</category>
<category>CSRF 공격</category>
<category>CSRF 방어 방법</category>
<category>Double Submit Cookie</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/200</guid>
<comments>https://itstory.tk/entry/CSRF-%EA%B3%B5%EA%B2%A9%EC%9D%B4%EB%9E%80-%EA%B7%B8%EB%A6%AC%EA%B3%A0-CSRF-%EB%B0%A9%EC%96%B4-%EB%B0%A9%EB%B2%95#entry200comment</comments>
<pubDate>Fri, 30 Mar 2018 19:08:24 +0900</pubDate>
</item>
<item>
<title>[JavaScript] 4. 함수와 프로토타입 체이닝 (2) - this란</title>
<link>https://itstory.tk/entry/JavaScript-4-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B4%EB%8B%9D-2-this%EB%9E%80</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=213715769&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/5/7/6/9/213715769h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=213715769&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;인사이드 자바스크립트&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 고현준,송형주&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 한빛미디어 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.01.02&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=213715769&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;함수-호출과-this&quot;&gt;&lt;br /&gt;함수 호출과 this&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;arguments 객체&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;C와 같은 엄격한 언어와 달리, 자바스크립트에서는 함수를 호출할 때 함수 형식에 맞춰 인자를 넘기지 않더라도 에러가 발생하지 않는다. 정의된 함수의 인자보다 적게 함수를 호출했을 경우, 넘겨지지 않은 인자에는 &lt;strong&gt;undefined&lt;/strong&gt; 값이 할당된다. 이와 반대로 정의된 인자 개수보다 많게 호출했을 경우 초과된 인수는 무시된다.&lt;/p&gt;&lt;p&gt;이러한 특성 때문에, 런타임 시에 호출된 인자의 개수를 확인하고 이에 따라 동작을 다르게 해줘야 할 경우가 있다. 이를 가능케 하는게 함수를 호출할 때 암묵적으로 전달되는 arguments 객체다. 이 객체는 실제 배열이 아닌 유사 배열 객체이다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function add(a, b) {
    console.dir(arguments);
    return a + b;
}

console.log(add(1)); // NaN
console.log(add(1, 2)); // 3
console.log(add(1, 2, 3)); // 3&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;호출 패턴과 this 바인딩&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;자바스크립트에서 함수를 호출할 때 기존 매개변수로 전달되는 인자값에 더해, 앞서 설명한 arguments 객체 및 &lt;strong&gt;this 인자가 함수 내부로 암묵적으로 전달된다.&lt;/strong&gt; this가 이해하기가 어려운 이유는 자바스크립트의 여러 가지 함수가 호출되는 방식(호출 패턴)에 따라 this가 다른 객체를 참조하기(this 바인딩) 때문이다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1. 객체의 메서드 호출할 때 this 바인딩&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;객체의 프로퍼티가 함수일 경우, 이 함수를 메서드라고 부른다. 메서드 내부 코드에서 사용된 this는 &lt;strong&gt;해당 메서드를 호출한 객체로 바인딩 된다.&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var myObject = {
    name: 'foo',
    sayName: function () {
        console.log(this.name);
    }
}

var otherObject = {
    name: 'bar'
}

otherObject.sayName = myObject.sayName;

myObject.sayName(); // foo
otherObject.sayName(); // bar&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. 함수를 호출할 때 this 바인딩&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;함수를 호출할 경우는, 해당 함수 내부 코드에서 사용된 &lt;strong&gt;this는 전역 객체에 바인딩된다.&lt;/strong&gt; 브라우저에서 자바스크립트를 실행하는 경우 전역 객체는 window 객체다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var test = 'This is test';
console.log(window.test); // 'This is test'

var sayFoo = function() {
    console.log(this.test); // 'This is test'
}

sayFoo();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이러한 함수 호출에서의 this 바인딩 특성은 &lt;strong&gt;내부 함수(inner function)를 호출했을 경우에도 동일하게 적용되므로&lt;/strong&gt; 유의해서 사용해야 한다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 전역 변수
var value = 100;

var myObject = {
    value : 1,
    func1 : function() {
        this.value += 1;
        console.log('func1() called. this.value : ' + this.value); // 2

        // func1의 내부 함수 func2
        func2 = function() {
            this.value += 1;
            console.log('func2() called. this.value : ' + this.value); // 101

            // func2의 내부 함수 func3
            func3 = function() {
                this.value += 1;
                console.log('func3() called. this.value : ' + this.value); // 102
            }

            func3();
        }

        func2();
    }
};

myObject.func1();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자바스크립트에서 &lt;strong&gt;내부 함수 호출 패턴을 정의해 놓지 않았기 때문에,&lt;/strong&gt; 함수로 취급되어 함수 호출 패턴 규칙에 따라 내부 함수의 this는 전역 객체에 바인딩된다. 그래서 흔히들 that 변수를 이용하여 this 값을 저장한다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var value = 100;

var myObject = {
    value : 1,
    func1 : function() {
        // 현 상태의 this를 that 변수에 저장
        var that = this;

        this.value += 1;
        console.log('func1() called. this.value : ' + this.value); // 2

        // func1의 내부 함수 func2
        func2 = function() {
            that.value += 1;
            console.log('func2() called. this.value : ' + that.value); // 3

            // func2의 내부 함수 func3
            func3 = function() {
                that.value += 1;
                console.log('func3() called. this.value : ' + that.value); // 4
            }

            func3();
        }

        func2();
    }
};

myObject.func1();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이와 같은 this 바인딩의 한계를 극복하려고, this 바인딩을 명시적으로 할 수 있도록 call과 apply 메서드를 제공한다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3. 생성자 함수를 호출할 때 this 바인딩&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;자바스크립트에서 &lt;strong&gt;기존 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다.&lt;/strong&gt; 일반 함수에 new를 붙여 호출하면 원치 않는 생성자 함수로 동작할 수 있기 때문에, 대부분의 자바스크립트 스타일 가이드에서는 특정 함수가 생성자 함수로 정의되어 있음을 알리려고 함수 이름의 첫 문자를 대문자로 쓰기를 권하고 있다.&lt;/p&gt;&lt;p&gt;생성자 함수에서의 this는 &lt;strong&gt;생성자 함수를 통해 새로 생성되어 반환되는 객체에 바인딩된다.&lt;/strong&gt; (이는 생성자 함수에서 명시적으로 다른 객체를 반환하지 않는 일반적인 경우에 적용됨)&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Person 생성자 함수
var Person = function(name) {
    this.name = name;
}

// foo 객체 생성
var foo = new Person('foo');
console.log(foo.name); // foo&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;객체 리터럴 방식과 생성자 함수를 통한 객체 생성 방식의 차이&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;객체 리터럴 방식으로 생성된 객체는 생성자 함수처럼 다른 인자를 넣어 형식은 같지만 다른 값을 가지는 객체를 생성할 수 없다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var foo = {
    name : 'foo'
}

function Person(name) {
    this.name = name;
}

var bar = new Person('bar');
var baz = new Person('baz');&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;또 다른 차이점은 객체 리터럴 방식으로 생성한 foo 객체의 __proto__ 프로퍼티는 Object.prototype를 가르키며, 생성자 함수를 통해 생성한 bar, baz 객체의 __proto__ 프로퍼티는 Person.prototype를 가르킨다는 점이다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;생성자 함수를 new를 붙이지 않고 호출할 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;생성자 함수를 new를 붙이지 않고 호출할 경우 위에서 살펴본 &lt;em&gt;2. 함수를 호출할 때 this 바인딩&lt;/em&gt; 규칙이 적용되어 this가 전역객체에 바인딩된다. 이런 위험성을 피하려고 널리 사용되는 패턴이 있다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function A(arg) {
    if (!(this instanceof A)) {
        return new A(arg);
    }

    this.value = arg ? arg : 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4. call과 apply 메서드를 이용한 명시적인 this 바인딩&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Function.prototype 객체의 메서드인 call()과 apply()를 통해 명시적으로 this를 바인딩 가능하다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Person 생성자 함수
function Person(name) {
    this.name = name;
}

// foo 빈 객체 생성
var foo = {};

Person.apply(foo, ['foo']);

console.log(foo.name); // foo
console.log(foo.__proto__ === Object.prototype) // true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예제에서 알 수 있듯이 apply()를 통해 호출한 경우, 생성자 함수 방식이 아닌 this 가 foo 객체에 바인딩되어 __proto__ 프로퍼티가 Person.prototype이 아닌 Object.prototype이다.&lt;/p&gt;&lt;p&gt;이처럼 apply()나 call() 메서드는 this를 원하는 값으로 명시적으로 매핑해서 특정 함수나 메서드를 호출할 수 있다는 장점이 있다. 그리고 이들의 대표적인 용도가 arguments 객체와 같은 유사 배열 객체에서 배열 메서드를 사용하는 경우이다. arguments 객체는 실제 배열이 아니므로 pop(), shift() 같은 표준 메서드를 사용할 수 없지만 apply() 메서드를 이용하면 가능하다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function myFunction() {
    // arguments.shift(); 에러 발생

    var args = Array.prototype.slice.apply(arguments);
}

myFunction();&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/199&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>자바스크립트</category>
<category>javascript</category>
<category>prototype</category>
<category>this</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/199</guid>
<comments>https://itstory.tk/entry/JavaScript-4-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B4%EB%8B%9D-2-this%EB%9E%80#entry199comment</comments>
<pubDate>Thu, 15 Mar 2018 17:29:02 +0900</pubDate>
</item>
<item>
<title>[책 리뷰] 코딩셰프의 3분 딥러닝, 케라스맛</title>
<link>https://itstory.tk/entry/%EC%BD%94%EB%94%A9%EC%85%B0%ED%94%84%EC%9D%98-3%EB%B6%84-%EB%94%A5%EB%9F%AC%EB%8B%9D-%EC%BC%80%EB%9D%BC%EC%8A%A4%EB%A7%9B</link>
<description>&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:350px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F99267B3D5AA5DB38323D3B&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99267B3D5AA5DB3832&quot; filemime=&quot;image/jpeg&quot; filename=&quot;keras.jpg&quot; height=&quot;514&quot; width=&quot;350&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt; color: rgb(0, 0, 0);&quot;&gt;코딩셰프의 3분 딥러닝, 케라스맛&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt; text-align: left;&quot;&gt;Keras 코드로 맛보는 ANN, DNN, CNN, RNN, AE, GAN, UNET&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt; text-align: left;&quot;&gt;김성진 저 |&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;gd_pub&quot; style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, &amp;quot;Malgun Gothic&amp;quot;, &amp;quot;Apple SD Gothic Neo&amp;quot;, AppleGothic, 돋움, Dotum, 굴림, Gulim, Helvetica, sans-serif; color: rgb(102, 102, 102); font-size: 12px;&quot;&gt;&lt;a style=&quot;color: rgb(51, 51, 51);&quot;&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt; color: rgb(0, 0, 0);&quot;&gt;한빛미디어&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;margin: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;font-size: 14.6667px; color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;최근 딥러닝, 머신러닝에 관심이 많아져&lt;/span&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt; color: rgb(0, 0, 0);&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt; color: rgb(0, 0, 0);&quot;&gt;코딩셰프의 3분 딥러닝 케라스맛&lt;/span&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt; color: rgb(0, 0, 0);&quot;&gt;&amp;nbsp;책을 리뷰하게 되었습니다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt; color: rgb(0, 0, 0);&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;우선 첫인상은 핸디북 처럼 작고 두껍지 않은 귀여운 형태입니다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;목차에서 확인하실 수 있듯이 ANN, DNN, CNN, RNN, AE, GAN, UNET 딥러닝 모델에 대해 케라스를 이용해서 다룹니다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;저는 딥러닝, 머신러닝에 관해 기초지식이 전무한 상태로 봤는데 이 책은 완전 입문자를 위한 책은 아니다라는 느낌을 받았습니다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;입문을 넘어선 초급자를 위한 핵심 요약 책인듯 하네요.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;케라스 코드를 통해 모델을 설명해주는데 코드별로 자세하게 설명을 해주셔서 이해하기는 쉽게 되어있습니다. 또한 각 모델별로 특징 및 장단점들을 잘 요약해주셔서 내가 하려하는 기능에 어떤 모델을 써야 적합한지 쉽게 알 수 있을 것 같아요.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;딥러닝에 기초지식이 있고&amp;nbsp;케라스에 입문 하시려는 분 혹은 각 모델들의 핵심을 정리하고 싶은 딥러닝 초급자에게 추천해드리고 싶습니다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: right;&quot;&gt;&lt;b style=&quot;color: rgb(103, 103, 103); text-align: right;&quot;&gt;&lt;span style=&quot;color: rgb(102, 102, 102); font-size: 14px;&quot;&gt;이 글은 한빛미디어의 도서 리뷰 활동으로 작성된 글입니다.&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/198&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>그 외</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/198</guid>
<comments>https://itstory.tk/entry/%EC%BD%94%EB%94%A9%EC%85%B0%ED%94%84%EC%9D%98-3%EB%B6%84-%EB%94%A5%EB%9F%AC%EB%8B%9D-%EC%BC%80%EB%9D%BC%EC%8A%A4%EB%A7%9B#entry198comment</comments>
<pubDate>Mon, 12 Mar 2018 10:54:14 +0900</pubDate>
</item>
<item>
<title>[Gof 디자인 패턴] Iterator (반복자) 패턴</title>
<link>https://itstory.tk/entry/Gof-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-Iterator-%EB%B0%98%EB%B3%B5%EC%9E%90-%ED%8C%A8%ED%84%B4</link>
<description>&lt;p&gt;Java 언어에서 배열 arr의 모든 요소를 표시하기 위해서는 다음과 같이 for문을 사용합니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;for (int i = 0; i &amp;lt; arr.length; i++) {
    System.out.println(arr[i]);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for문의 변수 i를 통해 배열 arr의 요소에 접근할 수 있습니다. Iterator 패턴은 이런 변수 i의 기능을 추상화해서 일반화 한 것 입니다.&lt;/p&gt;&lt;p&gt;Iterator 패턴의 구성은 아래와 같습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Iterator(반복자)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;요소를 순서대로 검색해가는 인터페이스(API) 입니다. 다음 요소가 존재하는지를 얻기 위한 &lt;code&gt;hasNext&lt;/code&gt; 메서드와 다음 요소를 얻기 위한 &lt;code&gt;next&lt;/code&gt; 메서드를 결정합니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ConcreteIterator(반복자 구현체)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Iterator 인터페이스의 구현체 입니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Aggregate(집합체)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Iterator 역할을 만들어내는 인터페이스(API) 입니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ConcreteAggregate(집합체 구현체)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Aggregate 인터페이스의 구현체 입니다.&lt;/p&gt;&lt;p&gt;Iterator 패턴을 클래스 다이어그램으로 표기하면 다음과 같습니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:495px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F99C8A03D5A992031198354&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99C8A03D5A99203119&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Untitled_Diagram_xml_-_draw_io.png&quot; height=&quot;305&quot; width=&quot;495&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Iterator 패턴을 사용하여 만든 예제 프로그램을 살펴봅시다. 여기에서 작성할 예제 프로그램은 서가(BookShelf) 안에 책(Book)을 넣고, 그 책의 이름을 차례대로 표시하는 프로그램입니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:501px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F99D7213B5A9921DD0DA7C9&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99D7213B5A9921DD0D&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Untitled_Diagram_xml_-_draw_io.png&quot; height=&quot;537&quot; width=&quot;501&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public interface Aggregate {
    public abstract Iterator iterator();
}

public interface Iterator {
    public abstract boolean hasNext();
    public abstract Object Next();
}&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public class Book {
    private String name;

    public Book(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public class BookShelf implements Aggregate {
    private Book[] books;
    private int last = 0;

    public BookShelf(int maxsize) {
        this.books = new Book[maxsize];
    }

    public Book getBookAt(int index) {
        return books[index];
    }

    public void appendBook(Book book) {
        this.books[last] = book;
        last++;
    }

    public int getLength() {
        return last;
    }

    public Iterator iterator() {
        return new BookShelfIterator(this);
    }
}&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public class BookShelfIterator implements Iterator {
    private BookShelf bookShelf;
    private int index;

    public BookShelfIterator(BookShelf bookShelf) {
        this.bookShelf = bookShelf;
        this.index = 0;
    }

    public boolean hasNext() {
        if (index &amp;lt; bookShelf.getLength()) {
            return true;
        } else {
            return false;
        }
    }

    public Object next() {
        Book book = bookShelf.getBookAt(index);
        index++;
        return book;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 예제를 실행시켜 봅시다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;BookShelf bookShelf = new BookShelf(4);
bookShelf.appendBook(new Book(&quot;Around the World in 80 Days&quot;));
bookShelf.appendBook(new Book(&quot;Bible&quot;));
bookShelf.appendBook(new Book(&quot;Cinderella&quot;));
bookShelf.appendBook(new Book(&quot;Baddy-Long-Legs&quot;));

Iterator it = bookShelf.iterator();
while (it.hasNext()) {
    Book book = (Book)it.next();
    System.out.println(book.getName());
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java 개발자라면 iterator를 한 번쯤 보시거나 사용해본 경험이 있을 것입니다. 배열이라면 for문을 이용해서 빙글빙글 돌리면 좋은데, 왜 집합체의 외부에 Iterator 역할 같은 것을 만들어야 할까요?&lt;/p&gt;&lt;p&gt;가장 큰 이유는 &lt;strong&gt;Iterator를 사용함으로써 구현과 분리해서 하나씩 셀 수 있기 때문&lt;/strong&gt; 입니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;while (it.hasNext()) {
    Book book = (Book)it.next();
    System.out.println(book.getName());
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 코드에서 while 루프는 BookShelf의 구현에는 의존하지 않습니다. 만약 BookShelf를 배열에서 Vector로 변경한다고 하더라도 hasNext 메서드와 next 메서드만 올바르게 수정한다면, 위의 while 루프를 전혀 변경하지 않아도 동작합니다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;즉, 클래스를 부품처럼 사용할 수 있게 하고, 하나의 부품을 수정해도 다른 부품에는 큰 영향 없이 작은 수정만으로 끝낼 수 있게 재이용화의 장점을 누릴 수 있습니다.&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/197&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>GoF 디자인 패턴</category>
<category>Iterator 패턴</category>
<category>Java</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/197</guid>
<comments>https://itstory.tk/entry/Gof-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-Iterator-%EB%B0%98%EB%B3%B5%EC%9E%90-%ED%8C%A8%ED%84%B4#entry197comment</comments>
<pubDate>Fri, 02 Mar 2018 18:59:11 +0900</pubDate>
</item>
<item>
<title>MongoDB 인증 모드 (password) 설정</title>
<link>https://itstory.tk/entry/MongoDB-%EC%9D%B8%EC%A6%9D-%EB%AA%A8%EB%93%9C-password-%EC%84%A4%EC%A0%95</link>
<description>&lt;p&gt;MongoDB를 설치하면 기본적으로 패스워드 없이 접속할 수 있습니다. 기본 설정이 MongoDB가 설치된 서버의 로컬(127.0.0.1)에서만 접근할 수 있지만, 외부 서비스와의 연동을 위해 외부 접근을 허용하면 크나큰 보안 위협에 놓이게 됩니다.&lt;/p&gt;&lt;p&gt;실제로 MongoDB의 이런 기본 설정 때문에 비밀번호 없이 외부 접근을 허용하는 전세계적으로 사용자들이 꽤나 존재했고, 2017년 1월에 이런 취약점을 노린 랜섬웨어가 발생했습니다. 물론 한국 서버들도 예외는 아니였습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이번 공격은 관리자 암호가 설정되어 있지 않은 채 인터넷을 통해 접근이 가능하도록 설치되어 있는 몽고DB를 노리고 있다 - 보안 전문가인 빅터 거브스(Victor Gerves)와 니알 메리간(Niall Merrigan)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;관련 기사 : 보안뉴스 - &lt;a href=&quot;http://www.boannews.com/media/view.asp?idx=53019&quot;&gt;급속도로 퍼지는 몽고DB 랜섬웨어 공격과 그 의미&lt;/a&gt;&lt;/p&gt;&lt;p&gt;MongoDB 설치 후 패스워드(인증 모드) 설정은 반드시 진행해야 합니다. 이제 MongoDB의 인증(Authentication) 모드 설정에 대해 살펴보겠습니다.&lt;/p&gt;



&lt;h3 id=&quot;1-mongodb-shell-접속&quot;&gt;1. MongoDB Shell 접속&lt;/h3&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;$ mongo
# MongoDB shell version v3.6.2
# connecting to: mongodb://127.0.0.1:27017&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;2-administrator-user-생성&quot;&gt;2. Administrator User 생성&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;MongoDB 2.7 이상&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;use admin
db.createUser({
    user: &quot;&amp;lt;username&amp;gt;&quot;,
    pwd: &quot;&amp;lt;password&amp;gt;&quot;,
    roles: [ &quot;root&quot; ]
})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;MongoDB 2.4 이하&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;use admin
db.addUser({ 
    user: &quot;&amp;lt;username&amp;gt;&quot;,
    pwd: &quot;&amp;lt;password&amp;gt;&quot;,
    roles: [ &quot;userAdminAnyDatabase&quot; ] 
})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결과 예시&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;Successfully added user: {
    &quot;user&quot; : &quot;&amp;lt;username&amp;gt;&quot;,
    &quot;roles&quot; : [
        {
            &quot;role&quot; : &quot;userAdminAnyDatabase&quot;,
            &quot;db&quot; : &quot;admin&quot;
        }
    ]
}&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;3-mongodb-재시작&quot;&gt;3. MongoDB 재시작&lt;/h3&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;$ mongod --auth --port 27017 --dbpath /data/db1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--port&lt;/code&gt; 와 &lt;code&gt;--dbpath&lt;/code&gt; 는 옵션 값이며 미입력 시 위의 값이 default 입니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;configuration 파일을 이용하는 경우&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;우분투의 &lt;code&gt;apt-get&lt;/code&gt; 과 같은 패키지 매니저를 통해 설치한 경우 &lt;code&gt;service mongod start&lt;/code&gt; 를 통해 시작합니다. 이 경우는 configuration 파일을 통해 실행이 됩니다. &lt;code&gt;/etc/mongod.conf&lt;/code&gt; 를 다음과 같이 수정하고 재시작하시면 됩니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;MongoDB 2.x&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;auth=true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;MongoDB 3.x&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-yml&quot;&gt;security:
   authorization: enabled&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;우분투 예시&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;$ sudo service mongod start&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;4-확인&quot;&gt;4. 확인&lt;/h3&gt;

&lt;p&gt;재시작에 성공하였으면, 다시 &lt;code&gt;mongo&lt;/code&gt; 쉘에 접속하여 정상적으로 인증이 되는지 확인을 해봅시다. &lt;code&gt;1&lt;/code&gt; 이 출력되면 성공한 것 입니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;use admin
db.auth(&quot;&amp;lt;username&amp;gt;&quot;, &quot;&amp;lt;password&amp;gt;&quot; )&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;5-데이터베이스-및-일반-사용자-생성&quot;&gt;5. 데이터베이스 및 일반 사용자 생성&lt;/h3&gt;

&lt;p&gt;위에서 진행한 어드민 계정으로 &lt;code&gt;mongo&lt;/code&gt; 쉘에 접속하여 봅시다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;mongo -u &quot;&amp;lt;username&amp;gt;&quot; -p &quot;&amp;lt;password&amp;gt;&quot; --authenticationDatabase &quot;admin&quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 처럼 &lt;code&gt;-u&lt;/code&gt; 와 &lt;code&gt;-p&lt;/code&gt; 옵션 없이 접속하신 경우 4번에서 진행한 방법으로 인증하시면 됩니다. 이제 어플리케이션 단에서 사용할 데이터베이스를 생성해보고 일반 사용자를 생성해 봅시다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;use test_db
db.createUser({
    user: &quot;&amp;lt;username&amp;gt;&quot;, 
    pwd: &quot;&amp;lt;password&amp;gt;&quot;, 
    roles: [&quot;dbOwner&quot;]
})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;use test_db&lt;/code&gt; 를 실행할때 해당 데이터베이스로 이동 할 뿐만아니라 DB가 존재하지 않을 경우 생성이 함께 진행됩니다. 더 다양하고 세분화된 role을 확인하시려면 &lt;a href=&quot;https://docs.mongodb.com/manual/reference/built-in-roles/&quot;&gt;MongoDB Built-In Roles&lt;/a&gt;을 확인하세요.&lt;/p&gt;



&lt;h3 id=&quot;참고&quot;&gt;참고&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/tutorial/enable-authentication/&quot;&gt;https://docs.mongodb.com/manual/tutorial/enable-authentication/&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://docs.mongodb.com/manual/reference/configuration-options/#security.authorization&quot;&gt;https://docs.mongodb.com/manual/reference/configuration-options/#security.authorization&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://docs.mongodb.com/manual/reference/built-in-roles/&quot;&gt;https://docs.mongodb.com/manual/reference/built-in-roles/&lt;/a&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/196&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>리눅스&amp;우분투</category>
<category>authentication</category>
<category>MongoDB</category>
<category>PASSWORD</category>
<category>비밀번호</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/196</guid>
<comments>https://itstory.tk/entry/MongoDB-%EC%9D%B8%EC%A6%9D-%EB%AA%A8%EB%93%9C-password-%EC%84%A4%EC%A0%95#entry196comment</comments>
<pubDate>Wed, 31 Jan 2018 10:42:30 +0900</pubDate>
</item>
<item>
<title>[Ubuntu] MongoDB 설치</title>
<link>https://itstory.tk/entry/Ubuntu-MongoDB-%EC%84%A4%EC%B9%98</link>
<description>&lt;p&gt;MongoDB는 우분투 64-bit LTS버전만 지원합니다. 현재 MongoDB는 12.04 LTS, 14.04 LTS, 16.04 LTS 를 지원합니다.&lt;/p&gt;



&lt;h3 id=&quot;1-mongodb-public-gpg-key-추가&quot;&gt;1. MongoDB public GPG Key 추가&lt;/h3&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 2930ADAE8CAF5059EE73BB4B58712A2291FA4AD5&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;2-mongodb-repo-추가&quot;&gt;2. MongoDB repo 추가&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Ubuntu 12.04 (deprecated)&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;echo &quot;deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu precise/mongodb-org/3.6 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.list&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Ubuntu 14.04&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;echo &quot;deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.6 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.list&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Ubuntu 16.04&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;echo &quot;deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.6 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.list&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;3-패키지-파일-업데이트&quot;&gt;3. 패키지 파일 업데이트&lt;/h3&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get update&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;4-mongodb-설치&quot;&gt;4. MongoDB 설치&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;최신 안정화 버전 설치 시&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install -y mongodb-org&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;특정 버전 설치 시&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install -y mongodb-org=3.6.2 mongodb-org-server=3.6.2 mongodb-org-shell=3.6.2 mongodb-org-mongos=3.6.2 mongodb-org-tools=3.6.2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;특정 버전 설치 시 &lt;code&gt;apt-get upgrade&lt;/code&gt; 를 하게되면 최신버전으로 업그레이드될 수 있습니다. 해당 버전으로 고정하려면 아래와 같이 입력해야 됩니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;echo &quot;mongodb-org hold&quot; | sudo dpkg --set-selections
echo &quot;mongodb-org-server hold&quot; | sudo dpkg --set-selections
echo &quot;mongodb-org-shell hold&quot; | sudo dpkg --set-selections
echo &quot;mongodb-org-mongos hold&quot; | sudo dpkg --set-selections
echo &quot;mongodb-org-tools hold&quot; | sudo dpkg --set-selections&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;5-mongodb-실행&quot;&gt;5. MongoDB 실행&lt;/h3&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo service mongod start&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;6-mongodb-정상동작-확인&quot;&gt;6. MongoDB 정상동작 확인&lt;/h3&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo service mongod status&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;tail -f /var/log/mongodb/mongod.log

# [initandlisten] waiting for connections on port 27017 와 같이 출력&lt;/code&gt;&lt;/pre&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/195&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>리눅스&amp;우분투</category>
<category>MongoDB</category>
<category>Ubuntu 14.04</category>
<category>ubuntu 16.04</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/195</guid>
<comments>https://itstory.tk/entry/Ubuntu-MongoDB-%EC%84%A4%EC%B9%98#entry195comment</comments>
<pubDate>Tue, 30 Jan 2018 11:02:08 +0900</pubDate>
</item>
<item>
<title>자바스크립트에서 메모리 누수의 4가지 형태</title>
<link>https://itstory.tk/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98%EC%9D%98-4%EA%B0%80%EC%A7%80-%ED%98%95%ED%83%9C</link>
<description>&lt;blockquote&gt;
  &lt;p&gt;이 글은 &lt;a href=&quot;https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/&quot;&gt;4 Types of Memory Leaks in JavaScript and How to Get Rid Of Them&lt;/a&gt;를 번역한 글입니다. 번역 문서를 읽는 중, 오타나 어색한 문장이 있으면 부담없이 댓글 부탁드립니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이번 글에서 클라이언트단 JavaScript 코드의 일반적인 메모리 누수 유형에 대해 살펴보겠습니다. 또한 &lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/?hl=ko&quot;&gt;크롬 개발 도구(Chrome DevTools)&lt;/a&gt;를 사용하여 메모리 누수를 찾는 방법에 대해서도 알아보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;메모리 누수(Memory leaks)는 모든 개발자들이 직면하는 문제입니다. 심지어 메모리를 관리해주는 프로그래밍 언어(Java, C# 등)를 사용하는 경우에도 메모리 누수 문제에서 벗어날 수 없습니다. 메모리 누수는 어플리케이션의 속도 저하, 충돌, 지연 시간 증가뿐만 아니라 다른 어플리케이션에게도 악영향을 끼치는 등 전반적인 문제들의 원인이 됩니다.&lt;/p&gt;



&lt;h3 id=&quot;메모리-누수란&quot;&gt;메모리 누수란?&lt;/h3&gt;

&lt;p&gt;메모리 누수는 어떠한 이유로 애플리케이션에서 더이상 사용되지 않음에도 불구하고, 운영체제나 사용가능한 메모리 풀에 반환되지 않는 메모리라고 정의할 수 있습니다. 프로그래밍 언어들은 각기 다른 방법으로 메모리를 관리합니다. 이런 프로그래밍 언어 차원에서의 메모리 관리는 메모리 누수의 가능성을 많이 줄여줍니다. 하지만 프로그래밍 언어의 메모리 관리 시스템이 특정 메모리가 실제 사용중인지 미사용중인지 완벽히 구분해내는 것은 사실상 불가능에 가깝습니다. 오직 그 코드를 작성한 개발자들만이 해당 메모리 조각을 운영체제로 반환시킬 수 있는지 여부를 명확히 알 수 있습니다. 특정 프로그래밍 언어들은 개발자들이 좀 더 편리하게 메모리 반환을 할 수 있도록 기능들을 제공하기도 합니다. 개발자들이 명시적으로 미사용 메모리를 반환해야하는 언어들도 있습니다. 위키피디아에 &lt;a href=&quot;https://en.wikipedia.org/wiki/Manual_memory_management&quot;&gt;수동&lt;/a&gt; 과 &lt;a href=&quot;https://en.wikipedia.org/wiki/Manual_memory_management&quot;&gt;자동&lt;/a&gt; 메모리 관리에 관해 잘 설명해논 글이 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;자바스크립트에서의-메모리-관리&quot;&gt;자바스크립트에서의 메모리 관리&lt;/h3&gt;

&lt;p&gt;자바스크립트는 &lt;strong&gt;garbage collected&lt;/strong&gt; 언어 중 하나입니다. Garbage collected 언어들은 이전에 할당한 메모리를 애플리케이션에서 여전히 사용 중인지를 주기적으로 검사해 개발자들이 메모리를 관리에 덜 신경쓸 수 있도록 도움을 줍니다. 다른 말로, garbage collected 언어들은 메모리 관리 문제를 “어떤 메모리가 여전히 필요한가?” 에서 “어떤 메모리가 애플리케이션의 다른 코드에서 접근할 수 있는가?”로 관점을 축소할 수 있게 해줍니다. 이 둘의 차이점은 미묘해보이지만 매우 중요합니다. 할당된 메모리가 미래에 사용되는 지의 여부는 오직 개발자만이 알지만, 다른 코드에서 더 이상 접근되지 않은 메모리는 알고리즘적으로 결정할 수 있어 OS에 반환될 수 있도록 표시할 수 있습니다.&lt;/p&gt;
&lt;p&gt;Garbage collected가 아닌 언어들은 명시적 관리라는 다른 방법으로 메모리를 관리합니다. 개발자가 메모리를 더이상 사용하지 않을 때, 컴파일러가 메모리를 회수할 수 있도록 명시적으로 선언해야합니다. 이러한 기법은 잠재적으로 메모리 누수의 위험을 가질 수 있습니다.&lt;/p&gt;



&lt;h2 id=&quot;자바스크립트에서의-메모리-누수&quot;&gt;자바스크립트에서의 메모리 누수&lt;/h2&gt;

&lt;p&gt;Garbage collected 언어에서 메모리 누수의 주요 원인은 &lt;strong&gt;예상치 못한 참조&lt;/strong&gt; 입니다. 예상치 못한 참조(unwanted references)가 무엇인지 이해하기 위해선, 먼저 garbage collector가 어떤 방식으로 해당 메모리가 다른 코드에서 접근될 수 있는지 여부를 판단하는지를 알 필요가 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;mark-and-sweep&quot;&gt;Mark-and-sweep&lt;/h3&gt;

&lt;p&gt;대부분의 garbage collector는 &lt;strong&gt;mark-and-sweep&lt;/strong&gt; 라고 알려진 알고리즘을 사용합니다. 이 알고리즘은 다음과 같은 절차를 가집니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Garbage collector는 “roots”의 목록을 생성합니다. 루트들은 일반적으로 코드에서 참조가 계속 유지되는 전연 변수들입니다. 자바스크립트에서는 “window” 객체가 root가 되는 글로벌 변수의 대표적인 예입니다. window 객체는 항상 유지되기 때문에, garbage collector는 window 객체뿐만 아니라 그 자식 객체들도 항상 유지될 것이라 판단하여 폐기되지 않도록 합니다. &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;모든 루트들을 검사해 폐기되지 않도록 활성화 상태임을 표시합니다. 루트의 자식들도 재귀적으로 검사합니다(자식의 자식… 반복). 결국 루트에서 도달될 수 있는 자식 객체들은 폐기되지 않습니다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;할성화 상태로 표시되지 않은 모든 메모리 조각들은 이제 폐기될 수 있는 것으로 판단합니다. 그래서 garbage collector는 이 메모리들을 해제하여 OS에 반환합니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;최신 garbage collector들은 이 알고리즘을 다른 형태로 더 진화시켰지만, 기본 베이스는 동일합니다. 접근될 수 있는 메모리 조각들은 할성화 상태로 표시하고 그 외는 폐기되도록 고려되어집니다.&lt;/p&gt;
&lt;p&gt;예상치 못한 참조는 개발자는 더 이상 사용되지 않을 것이라 생각했지만, 어떠한 이유로 활성화 상태인 루트 트리 안에 존재하는 메모리 조각들입니다. 자바스크립트에서 예상치 못한 참조는 더이상 사용되지 않지만 코드 상 어딘가에 유지되어 해제되지 못한 변수들입니다. 어떤 이들은 이를 개발자의 실수라고 말하기도 합니다.&lt;/p&gt;
&lt;p&gt;그래서 자바스크립트에서 발생할 수 있는 일반적인 메모리 누수 형태들을 이해하기 위해서는 흔히 까먹기 쉬운 참조들을 먼저 알 필요가 있습니다.&lt;/p&gt;



&lt;h2 id=&quot;자바스크립트-메모리-누수의-일반적인-3가지-형태&quot;&gt;자바스크립트 메모리 누수의 일반적인 3가지 형태&lt;/h2&gt;



&lt;h3 id=&quot;1-우발적으로-생성된-전역-변수&quot;&gt;1. 우발적으로 생성된 전역 변수&lt;/h3&gt;

&lt;p&gt;자바스크립트 언어의 목표 중 하나는 Java와 유사하지만 초보자들도 쉽게 사용할 수 있는 언어를 만드는 것이었습니다. 그 방법 중 하나가 자바스크립트가 선언되지 않은 변수들을 처리할 수 있도록 하는 것이었습니다. 선언되지 않은 변수는 &lt;strong&gt;global&lt;/strong&gt; 객체 내부에 새로운 변수로 생성됩니다. 브라우저 환경에서 global 객체는 &lt;code&gt;window&lt;/code&gt; 입니다.&lt;/p&gt;
&lt;p&gt;아래의 코드는&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function foo(arg) {
    bar = &quot;this is a hidden global variable&quot;;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실제 다음과 같이 동작됩니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function foo(arg) {
    window.bar = &quot;this is an explicit global variable&quot;;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 &lt;code&gt;bar&lt;/code&gt; 변수가 &lt;code&gt;foo&lt;/code&gt; 함수 범위 내에서만 참조가 유지되도록 하려고 했는데 실수로 &lt;code&gt;var&lt;/code&gt; 로 선언 하는 것을 깜빡했다면, 예상지 못한 전역 객체가 생성되어진 것입니다. 위 예제에서 이 간단한 문장이 큰 악영향을 끼치지 않을 수 도 있지만, 좋지 않은 것은 분명합니다.&lt;/p&gt;
&lt;p&gt;또 다른 우발적인 전역 객체는 &lt;code&gt;this&lt;/code&gt; 를 통해 생성될 수 있습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function foo() {
    this.variable = &quot;potential accidental global&quot;;
}

// foo 함수를 호출하면, this는 window 전역 객체를 가리키게 됩니다.
foo();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자바스크립트 파일의 시작 부분에 &lt;code&gt;'use strict';&lt;/code&gt;를 추가하여 이러한 실수를 방지할 수 있습니다. 이는 자바스크립트 엔진이 우발적인 전역 객체 생성을 방지하도록 더 엄격한 모드로 자바스크립트를 파싱하게 해줍니다.&lt;/p&gt;
&lt;p&gt;예상치 못한 전역 변수에 대해 이야기했지만, 코드 여기저기서 필요에 의해 명시적으로 전역 변수를 선언하여 사용하는 곳이 많습니다. 이들은 null로 처리하거나 재할당하지 않는 한 garbage collector에 수집되지 않습니다. 특히, 대용량 데이터를 일시적으로 저장하고 처리하기 위해 사용된 전역 변수는 더 신중하게 다뤄야합니다. 전역 변수의 사용이 끝났다면, null로 처리하거나 재할당을 반드시 해야합니다. 전역 변수와 관련하여 메모리 사용 증가를 야기하는 일반적인 원인 중 하나는 캐시입니다. 캐시는 자주 사용되는 데이터들을 저장합니다. 이를 효줄적으로 처리하기 위해 데이터가 커진다면 캐시 사이즈도 커지게 됩니다. 캐시는 수집되지 않기 때문에 캐시 사이즈가 점점 커진다면 방대한 메모리 사용을 야기시킬 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;2-잊혀진-타이머와-콜백&quot;&gt;2. 잊혀진 타이머와 콜백&lt;/h3&gt;

&lt;p&gt;자바스크립트에서 &lt;code&gt;setInterval&lt;/code&gt; 는 매우 흔하게 사용됩니다. 많은 라이브러리에서 observer를 제공하거나, callback을 가지는 기능들을 가지고 있습니다. 이러한 라이브러리의 대부분은 더 이상 사용이 안되면 자체적으로 callback에 대한 참조를 해제하도록 구현되어 있습니다. 하지만 setInterval의 경우 아래와 같은 코드 형태를 많이 사용합니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var someResource = getData();
setInterval(function() {
    var node = document.getElementById('Node');
    if(node) {
        // Do stuff with node and someResource.
        node.innerHTML = JSON.stringify(someResource));
    }
}, 1000);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 예제를 통해 타이머 내부에서 참조된 노드 혹은 데이터가 더 이상 사용되지 않을 때 발생할 수 있는 문제를 살펴보겠습니다. &lt;code&gt;node&lt;/code&gt; 는 미래에 제거되어질지도 모르는 객체를 나타냅니다. 만약 객체가 제거되어지면 interval 내부의 핸들러는 더 이상 필요가 없게 되지만, 여전히 계속 동작되어 collector에 의해 수집되지 않게 됩니다. 만약 interval 핸들러가 수집되지 않는다면, 이 핸들러에 의존되는 객체들도 수집되지 않게 됩니다. 이 말은 대량의 데이터를 저장하고 있을 수도 있는 &lt;code&gt;someResource&lt;/code&gt; 도 수집되지 않게됨을 의미합니다.&lt;/p&gt;
&lt;p&gt;이러한 observer 형태의 경우, 더 이상 사용되지 않을 때 명시적으로 제거하는 것이 중요합니다. 이는 과거의 경우, 특정 브라우저(Internet Explorer 6 같은)들이 순환 참조를 잘 관리하지 못해 매우 중요한 요소 중 하나였습니다. 현재 대부분의 브라우저들은 observer 객체가 더 이상 사용되지 않으면 명시적으로 제거하지 않더라도 수집합니다. 하지만 이러한 observer들을 명시적으로 제거하는 것이 좋은 관행으로 남아 있습니다. 예를들어 다음 코드와 같습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var element = document.getElementById('button');

function onClick(event) {
    element.innerHtml = 'text';
}

element.addEventListener('click', onClick);
// Do stuff
element.removeEventListener('click', onClick);
element.parentNode.removeChild(element);
// Now when element goes out of scope,
// both element and onClick will be collected even in old browsers that don't
// handle cycles well.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Observer와 관련 참조들은 자바스크립트 개발자들에게 골칫거리가 되곤 했습니다. 이는 Internet Explorer의 garbage collector의 버그(혹은 애초에 그렇게 설계된) 때문이었습니다. 구버전 Internet Explorer는 DOM 노드와 자바스크립트 코드 사이의 순환 참조를 탐지하지 못 했습니다. 이로 인해 메모리 누수가 발생하게 되었고 개발자들은 명시적으로 참조를 제거하기 시작했습니다. 현재의 최신 브라우저들은(Internet Explorer와 Microsoft Edge를 포함하여) 이들을 정확하게 탐지하여 수집해갑니다. 즉, 노드가 제거되기 전에 &lt;code&gt;removeEventListener&lt;/code&gt;를 호출할 필요가 없어졌습니다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;jQuery&lt;/em&gt; 와 같은 프레임워크과 라이브리러들은 노드를 폐기하기 전에 listener들을 명시적으로 제거합니다. 이는 라이브러리 내부에서 수행되며, 구버전 Internet Explorer와 같이 문제가 생길법한 브라우저에서도 메모리 누수가 발생하지 않도록 구현되어 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;3-dom-외부에서의-참조&quot;&gt;3. DOM 외부에서의 참조&lt;/h3&gt;

&lt;p&gt;종종 DOM 노드들을 자료구조 안에 저장하는 것이 유용할 때가 있습니다. 테이블에서 여러 행의 내용을 빠르게 업데이트하려는 경우를 가정합시다. 각 행의 DOM 노드들에 대한 참조를 맵이나 배열에 저장하는 것이 좋습니다. 이 경우 DOM 요소에 대한 참조는 DOM 트리와 맵, 2군데에서 유지됩니다. 만약 나중에 이 행들을 제거해야할 경우 두 참조 모두 제거를 해야합니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var elements = {
    button: document.getElementById('button'),
    image: document.getElementById('image'),
    text: document.getElementById('text')
};

function doStuff() {
    image.src = 'http://some.url/image';
    button.click();
    console.log(text.innerHTML);
    // Much more logic
}

function removeButton() {
    // The button is a direct child of body.
    document.body.removeChild(document.getElementById('button'));

    // 여기서 elements 에서 여전히 button 참조를 가지고 있습니다.
    // 이 경우 button element는 여전히 메모리에 상주하게 되며 GC에 의해 수집될 수 없습니다.
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기에 추가적으로 고려해야되는 사항은 DOM 트리 안에서 내부 혹은 말단 노드의 참조입니다. 자바스크립트 코드에서 테이블의 특정 셀( 태그)에 대한 참조를 가지고 있다고 가정합시다. 나중에 DOM으로 부터 테이블을 제거하기로 결정했지만 여전히 셀에 대한 참조를 가지고 있게 됩니다. 직관적으로 GC가 해당 셀을 제외한 나머지는 수집할 것이라 생각됩니다. 하지만 현실은 그렇지 않습니다. 셀은 테이블의 자식 노드이고 자식 노드는 부모 노드에 대한 참조를 유지합니다. 그래서 테이블의 셀에 대한 참조로 인해 테이블 전체가 메모리에 유지되게 됩니다. DOM 요소에 대한 참조를 유지할 때는 이 점을 주의해야 합니다.&lt;/p&gt;



&lt;h3 id=&quot;4-클로저closures&quot;&gt;4. 클로저(Closures)&lt;/h3&gt;

&lt;p&gt;자바스크립트 개발에서 주요 요소 중 하나는 상위 스코프의 변수에 접근가능한 클로저입니다. Meteor 개발자들은 자바스크립트 런타임의 구현 방법으로 인해 메모리 누수가 가능한 &lt;a href=&quot;https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156&quot;&gt;특정한 사례를 발견&lt;/a&gt;했습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var theThing = null;
var replaceThing = function () {
  var originalThing = theThing;
  var unused = function () {
    if (originalThing)
      console.log(&quot;hi&quot;);
  };
  theThing = {
    longStr: new Array(1000000).join('*'),
    someMethod: function () {
      console.log('someMessage');
    }
  };
  // 만약 여기에 `originalThing = null` 를 추가한다면, 메모리 누수는 사라질 것 입니다.
};
setInterval(replaceThing, 1000);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 코드에서 &lt;code&gt;replaceThing&lt;/code&gt; 이 호출될 때마다 큰 사이즈의 배열과 &lt;code&gt;someMethod&lt;/code&gt; 클로저를 생성합니다. 동시에 &lt;code&gt;unused&lt;/code&gt; 변수는 &lt;code&gt;originalThing&lt;/code&gt; 를 참조하는 클로저를 가지게 됩니다(&lt;code&gt;originalThing&lt;/code&gt;는 &lt;code&gt;replaceThing&lt;/code&gt; 선언 위에 있는 &lt;code&gt;theThing&lt;/code&gt;을 참조). 벌써 헷갈리기 시작하시죠? 중요한 것은 &lt;code&gt;unused&lt;/code&gt; 와 같은 내부 함수에서는 자신을 둘러싼 부모 함수의 스코프를 공유한다는 것입니다(스코프 체이닝). &lt;code&gt;unused&lt;/code&gt; 내부 함수가 없었다면, &lt;code&gt;replaceThing&lt;/code&gt; 함수는 매번 실행 시 길이가 큰 문자열을 매번 생성하긴 하지만 최신 자바스크립트 엔진(V8 같은)에서는 이전에 호출된 &lt;code&gt;originalThing&lt;/code&gt; 이 사용되지 않음을 파악하고 이전 값을 메모리 해제하여 일정 메모리 사용량을 유지시켜 줍니다. 하지만 위의 코드에서는 &lt;code&gt;unused&lt;/code&gt; 내부 함수 때문에 &lt;code&gt;originalThing&lt;/code&gt; 을 참조하게 되고 비록 &lt;code&gt;unused&lt;/code&gt; 가 사용하지 않더라도 이 코드가 반복적으로 실행될 때 마다 메모리 사용량이 꾸준히 증가하는 것을 관찰할 수 있습니다(요약하자면, 최신 자바스크립트 엔진은 1 depth의 미사용 클로저에 대한 스코프를 클린징 해주지만 2 depth 부터는 안된다는 뜻인듯). GC가 실행되더라도 메모리 사용량이 줄어들지 않게 됩니다. 본질적으로 클로저의 참조고리가 생성되고(&lt;code&gt;theThing&lt;/code&gt; 변수를 루트로), 이 클로저의 범위에는 큰 사이즈의 배열에 대한 간접적인 참조를 동반하기 때문에 상당한 양의 메모리 누수가 발생하게 됩니다.&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;!-- 728X90 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block; text-align:center;&quot;
     data-ad-layout=&quot;in-article&quot;
     data-ad-format=&quot;fluid&quot;
     data-ad-client=&quot;ca-pub-8876596272501347&quot;
     data-ad-slot=&quot;7399807364&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/p&gt;

&lt;h2 id=&quot;garbage-collectors의-비직관적인-동작&quot;&gt;Garbage Collectors의 비직관적인 동작&lt;/h2&gt;

&lt;p&gt;Garbage Collectors는 편리하지만 그 들만의 특정 메커니즘에 의해 동작됩니다. 그 특징 중 하나는 비결정성(nondeterminism)입니다. 이 말은 GC는 예측이 불가능하단 뜻입니다. 언제 수집이 수행되는지 정확하게 예측할 수 없습니다. 즉, 경우에 따라서 프로그램에 요구되는 메모리보다 더 많은 메모리가 사용되고 있을 수 있습니다. 또 다른 경우, 민감함 어플리케이션에서는 짧은 일시정지 현상이 보이기도 합니다. 비록 비결정성은 수집이 언제 수행될지 모른다는 것을 의미하지만, 대부분의 GC는 일반적으로 메모리 할당이 이뤄지는 경우에만 수집을 수행합니다. 만약 메모리 할당이 이뤄지지 않았으면 대부분의 GC는 유휴상태에 있게 됩니다. 아래와 같은 시나리오를 살펴봅시다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;사이즈가 큰 데이터 할당을 여러번 수행합니다.&lt;/li&gt;
&lt;li&gt;Garbage Collector에 의해 대부분(혹은 전부)은 더 이상 접근되지 않는다라고 표시가 됩니다.(더 이상 사용하지 않은 경우 null로 초기화 했다고 가정)&lt;/li&gt;
&lt;li&gt;더 이상의 할당을 수행하지 않습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 시나리오에서 대부분의 GC들은 더 이상 수집을 수행하지 않습니다. 즉, 더 이상 접근되지 않는 데이터 셋들이 남아있음에도 불구하고 수집이 일어나지 않습니다. 이는 엄격히 메모리 누수는 아니지만, 일반적인 메모리 사용량보다 더 많은 메모리를 사용하게 됩니다.&lt;/p&gt;
&lt;p&gt;구글은 이 동작에 대한 훌륭한 예제를 &lt;a href=&quot;https://developer.chrome.com/devtools/docs/demos/memory/example2&quot;&gt;JavaScript Memory Profiling docs, example #2&lt;/a&gt;에서 제공합니다.&lt;/p&gt;



&lt;h2 id=&quot;chrome-memory-profiling-tools-overview&quot;&gt;Chrome Memory Profiling Tools Overview&lt;/h2&gt;

&lt;p&gt;크롬은 자바스크립트 코드의 메모리 사용을 프로파일링할 수 있는 좋은 도구들을 제공합니다. 메모리에 관련 도구로 Performance 메뉴와 Memory메뉴가 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;performance-메뉴-구-timeline&quot;&gt;Performance 메뉴 (구 Timeline)&lt;/h3&gt;

&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F9987E04C5A559AE62F0DB4&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/9987E04C5A559AE62F&quot; filemime=&quot;image/jpeg&quot; filename=&quot;timeline.png&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Performance 메뉴는 코드에서 비정상 메모리 사용 패턴을 발견하는데 필수적입니다. 이 스크린샷에서 메모리 누수가 계속 커지는 것을 볼 수 있습니다. Major GC가 수행 후에도 메모리 사용량이 줄어들지 않습니다. 노드의 수도 점차 증가하고 있습니다. 이것들으 종합해보면 코드 어딘가에 DOM 노드의 누수임을 짐작할 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;memory-메뉴-구-profiles&quot;&gt;Memory 메뉴 (구 Profiles)&lt;/h3&gt;

&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F99B385495A559B1C2A9D8F&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99B385495A559B1C2A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;profiles.png&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;앞으로 자주 봐야할 메뉴입니다. Memory 메뉴에서 스냅샷들을 찍을 수 있고 자바스크립트 코드의 메모리 사용을 비교해볼 수 있습니다. 또한 시간에 따라 메모리 할당을 기록할 수 있습니다. summary 와 comparison 목록을 주로 살펴보시면 됩니다.&lt;/p&gt;



&lt;h2 id=&quot;크롬-개발자-도구를-이용한-메모리-누수-찾기-예제&quot;&gt;크롬 개발자 도구를 이용한 메모리 누수 찾기 예제&lt;/h2&gt;

&lt;p&gt;메모리 누수에는 크게 두 가지의 형태가 있습니다. 하나는 주기적으로 메모리 사용량이 증가하는 형태이고, 다른 하나는 단 한번만의 메모리 증가를 유발시키는 형태입니다. 일반적으로 전자를 탐지하는 것이 쉬운 편입니다. 하지만 전자 유형의 누수는 메모리가 계속 늘어나면 브라우저가 느려지거나 스크립트 실행이 중지되어 성가신 일을 야기하기도 합니다. 후자 유형인 주기적이지 않은 누수는 다른 메모리 할당에 비해 눈의 띌 정도로 큰 경우 쉽게 발견할 수 있습니다. 하지만 이런 경우들은 흔치 않기 때문에, 잘 인지못하고 넘어가는 경우가 많습니다. 하지만 주기적 메모리 누수는 버그임으로 반드시 해결해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.chrome.com/devtools/docs/demos/memory/example1&quot;&gt;Chrome 에서 제공해주는 예제&lt;/a&gt; 를 살펴보겠습니다. 전체 코드는 아래와 같습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var x = [];

function createSomeNodes() {
    var div,
        i = 100,
        frag = document.createDocumentFragment();
    for (;i &amp;gt; 0; i--) {
        div = document.createElement(&quot;div&quot;);
        div.appendChild(document.createTextNode(i + &quot; - &quot;+ new Date().toTimeString()));
        frag.appendChild(div);
    }
    document.getElementById(&quot;nodes&quot;).appendChild(frag);
}
function grow() {
    x.push(new Array(1000000).join('x'));
    createSomeNodes();
    setTimeout(grow,1000);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;grow&lt;/code&gt; 가 호출되면 div 노드들을 만들고 DOM에 추가시킵니다. 또한 큰 배열을 할당하고 이를 글로벌 변수에 참조시킵니다. 이 코드는 위에서 언급한 크롬 도구로 살펴보면 메모리가 꾸준히 증가하는 것을 확인할 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;주기적으로-메모리가-증가하는-누수-탐지&quot;&gt;주기적으로 메모리가 증가하는 누수 탐지&lt;/h3&gt;

&lt;p&gt;Performance 메뉴(구 Timeline)를 통해 쉽게 탐지할 수 있습니다. &lt;a href=&quot;https://developer.chrome.com/devtools/docs/demos/memory/example1&quot;&gt;Chrome에서 제공해주는 예제 페이지&lt;/a&gt;에 들어가서 개발자 도구를 열고 Performance 메뉴에 들어갑니다. 그리고 memory 체크박스에 체크를 한 후 record 버튼을 누릅니다. 그 후, 예제 페이지의 &lt;code&gt;The Button&lt;/code&gt; 버튼을 눌려 메모리 누수를 시작시켜 봅니다. 잠시 후 record를 정지시킨 후 결과를 살펴봅시다.&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F99B5624A5A559B5814B755&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99B5624A5A559B5814&quot; filemime=&quot;image/jpeg&quot; filename=&quot;example-timeline.png&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이 사진에서 메모리 누수가 있다는 것을 보여주는 큰 징후가 두 개 있습니다. &lt;em&gt;nodes(초록선)&lt;/em&gt; 와 &lt;em&gt;JS heap(파란선)&lt;/em&gt; 그래프입니다. 노드들이 꾸준이 증가하며 감소되지 않습니다. 이것이 가장 큰 징후입니다.&lt;/p&gt;
&lt;p&gt;JS heap 그래프도 역시 메모리 사용이 계속 증가되고 있음을 보여줍니다. 하지만 garbage collector의 영향으로 알아채기가 쉽지는 않습니다. 초기에 메모리가 증가하다가 한 번 크게 감소하고 더 증가하다가 또 감소하는 형태가 반복됨을 확인할 수 있습니다. 이 경우 핵심은, GC에 의해 메모리 사용량이 감소할 때마다 힙의 크기가 이전보다 더 크게 유지된다는 점입니다. 다시 말해서 GC가 많은 양의 메모리를 수집하는 데 성공하고 있지만, 그 중 일부가 주기적으로 누수되고 있다는 것입니다.&lt;/p&gt;
&lt;p&gt;이제 메모리 누수가 있다는 것을 확신을 가질 수 있습니다. 이제 어디서 누수가 생기는지 찾아봅시다.&lt;/p&gt;



&lt;h3 id=&quot;두-개의-스냅샷-찍기&quot;&gt;두 개의 스냅샷 찍기&lt;/h3&gt;

&lt;p&gt;어디서 메모리 누수가 생기는지 찾기 위해서 크롬 개발자 도구의 Memory 메뉴(구 Profiles)를 이용할 것입니다. 이번 단계를 수행하기 위해 위 단계에서 접속한 크롬 예제 페이지를 새로고침 합니다. 이제 &lt;em&gt;Take Heap Snapshot&lt;/em&gt; 기능을 사용할 것 입니다.&lt;/p&gt;
&lt;p&gt;페이지를 새로고침하고 페이지 로딩이 끝나면 heap 스냅샷을 생성합니다. 이 스냅샷을 기준으로 사용하겠습니다. 그런 다음 다시 &lt;code&gt;The Button&lt;/code&gt; 을 누르고 몇 초간 기다린 후에 두번째 스냅샷을 생성합시다. 스냅샷을 생성했다면 코드에 중단점을 설정하여 더 이상 누수가 되지 않게 하는 것이 좋습니다.&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F998DF3445A559B8824C84F&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/998DF3445A559B8824&quot; filemime=&quot;image/jpeg&quot; filename=&quot;example-snapshots-1.png&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;두 스냅샷의 메모리 할당을 비교할 수 있는 두가지 방법이 있습니다. &lt;em&gt;Summary&lt;/em&gt; 를 선택한 다음, 우측에 있는 &lt;code&gt;All objects&lt;/code&gt; 를 &lt;code&gt;Objects allocated between Snapshot1 and Snapshot 2&lt;/code&gt; 를 선택하거나 &lt;code&gt;Summary&lt;/code&gt; 대신 &lt;code&gt;Comparison&lt;/code&gt; 을 선택하면 됩니다. 두 방법 모두 두 스냅샷의 할당된 객체 목록이 표시됩니다.&lt;/p&gt;
&lt;p&gt;이 예제에서 메모리 누수가 크기 때문에 매우 쉽게 발견됩니다. &lt;code&gt;(string)&lt;/code&gt; Constructor의 &lt;code&gt;Size Delta&lt;/code&gt; 표를 확인 해봅시다. 58개의 객체 생성으로 8MB를 차지하고 있습니다. 의심스로운 결과입니다. 새로운 객체들이 할당되었지만 해제되지 않아 8MB의 메모리가 소비되었습니다. &lt;code&gt;(string)&lt;/code&gt; Constuctor 표를 열어보면 사이즈가 매우 큰 할당이 몇 개 있는 것을 확인하실 수 있습니다. 이 중 하나(xxxxxxxx… 로 표시된)를 선택하여 하단의 &lt;code&gt;Retainers&lt;/code&gt; 표를 살펴보면 흥미로운 점을 찾을 수 있습니다.&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F99316C495A559BBC0D4650&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99316C495A559BBC0D&quot; filemime=&quot;image/jpeg&quot; filename=&quot;example-snapshots-2.png&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;선택한 할당이 배열의 일부임을 확인할 수 있습니다. 이 배열은 전역 &lt;code&gt;window&lt;/code&gt; 객체의 &lt;code&gt;x&lt;/code&gt; 변수로 참조되어 있다고 나옵니다. 이는 수집되지 않는 루트 (window) 객체에 큰 사이즈의 객체가 참조되어 있음을 우리에게 알려줍니다. 이제 잠재적인 메모리 누수와 그 위치를 발견했습니다.&lt;/p&gt;
&lt;p&gt;꽤나 기쁜 발견이지만 우리의 예제는 매우 간단했습니다. 이 예제에서 볼 수 있는 것과 같이 큰 할당은 일반적인 경우는 아닙니다. 다행이도 우리의 예제는 작긴하지만 DOM 노드의 누수 문제도 포함하고 있었습니다. 위 스냅샷을 이용하여 이 노드들을 쉽게 찾을 수 있었지만, 규모가 큰 사이트에서는 더 복잡하여 찾기가 쉽지는 않을 것 입니다. 최신 버전의 크롬은 이런 작업에 적합한 추가적인 도구를 제공하는데, 바로 &lt;code&gt;Record Heap Allocations&lt;/code&gt; 기능입니다.&lt;/p&gt;



&lt;h3 id=&quot;recording-heap-allocations-to-find-leaks&quot;&gt;Recording heap allocations to find leaks&lt;/h3&gt;

&lt;p&gt;이전에 설정한 중단점을 제거하여 예제 페이지의 스크립트가 계속 실행되도록 한 다음 크롬 개발자 도구의 Memory 메뉴(구 Profiles)로 돌아가봅시다. 그리고 &lt;em&gt;Record allocation timeline&lt;/em&gt; 을 체크한 후 스냅샷을 찍어봅시다. 기록이 진행되는 동안 상단에 파랑색의 기둥 모양의 그래프가 생기는 것을 볼 수 있을 것입니다. 이것은 메모리 할당을 나타냅니다. 매초마다 큰 할당이 이뤄지는 것을 보실 수 있을 것입니다. 몇초동안 기록을 진행한 다음 중지합니다(중지 후 예제 코드가 메모리를 계속 잡아 먹지 않게 중단점 설정하는 것을 잊지맙시다).&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F99BE88495A559BEC2AD025&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99BE88495A559BEC2A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;example-recordedallocs-overview.png&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;위 사진에서 볼 수 있듯이 차트 타임라인의 일부를 선택하면 해당 기간 동안에 수행되는 할당만 볼 수 있습니다. 위 사진에서는 큰 할당이 있는 부분에 근접하게 설정했습니다. 목록에는 3개의 constructor만 표시되어 있습니다. 이 중 하나는 메모리 누수를 일으키는 &lt;code&gt;(string)&lt;/code&gt; 항목이고, 다른 하나는 DOM 할당에 관련된 항목, 나머지 하나는 &lt;code&gt;Text&lt;/code&gt; constructor 항목(DOM 말단 노드에 존재하는 text 요소)입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HTMLDivElement&lt;/code&gt; constructor 항목 중 하나를 선택하고 하단의 &lt;code&gt;Allocation stack&lt;/code&gt; 메뉴를 눌러봅시다(메뉴가 안보이면 우측 상단의 옵션에 들어가 &lt;code&gt;Settings &amp;gt; Record heap allocation stack traces&lt;/code&gt; 를 체크하면 됩니다).&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F99FB8E485A559C410B56D0&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99FB8E485A559C410B&quot; filemime=&quot;image/jpeg&quot; filename=&quot;example-recordedallocs-selected.png&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이제, &lt;code&gt;grow&lt;/code&gt; -&amp;gt; &lt;code&gt;createSomeNodes&lt;/code&gt; 로 참조되어 할당된 요소를 보실 수 있습니다. 각 기둥 모양의 그래프에 초점을 맞춰 살펴보면 &lt;code&gt;HTMLDivElement&lt;/code&gt; 생성자가 많이 호출되는 것을 볼 수 있습니다. 전에 살펴보았던 두 스냅샷을 비교하는 메뉴로 돌아가보면 이 &lt;code&gt;HTMLDivElement&lt;/code&gt; 생성자가 많은 할당은 하지만 삭제가 없는 것을 볼 수 있습니다. 즉, GC에서 메모리를 회수하지 않고 지속적으로 할당만 이뤄지고 있는 것입니다. 이는 메모리 누수의 징후를 보여주며, 우리는 이 객체가 어디에 할당되는지 이제 알게 되었습니다(&lt;code&gt;createSomeNodes&lt;/code&gt; 함수). 이제 다시 코드로 돌아가서, 메모리 누수를 야기하는 코드를 고치면 끝입니다.&lt;/p&gt;



&lt;h3 id=&quot;또-다른-유용한-기능&quot;&gt;또 다른 유용한 기능&lt;/h3&gt;

&lt;p&gt;위에서 살펴본 &lt;em&gt;allocation timeline&lt;/em&gt; 메뉴에서 &lt;code&gt;Summary&lt;/code&gt; 외에도 &lt;code&gt;Allocation&lt;/code&gt; 를 선택할 수 있습니다.&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F996912505A559C6012D37B&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/996912505A559C6012&quot; filemime=&quot;image/jpeg&quot; filename=&quot;example-recordedallocs-list.png&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이 메뉴는 함수 목록들과 해당 함수와 관련된 메모리 할당들을 보여줍니다. 화면에서 &lt;code&gt;grow&lt;/code&gt; 와 &lt;code&gt;createSomeNodes&lt;/code&gt; 함수가 있는 것을 바로 볼 수 있을 것입니다. 해당 함수들을 클릭하면 해당 함수와 관련된 객체 constructor 목록들을 하단에서 볼 수 있습니다. 위에서 이미 메모리 누수임을 밝혀낸 &lt;code&gt;(string)&lt;/code&gt;, &lt;code&gt;HTMLDivElement&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt; 생성자들도 있음을 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;지금까지 살펴본 도구들을 조합하면 메모리 누수를 찾는데 큰 도움을 받을 수 있습니다. 이제 이 도구들을 가지고 놀아봅시다. 실제 운영 중인 사이트를 프로파일링 해봅시다(자바스크립트 코드를 압축하거나 난독화하지 않는 것이 실습에 도움될 것 입니다). 메모리 누수나 할당되어야 하는 양보다 더 많은 메모리를 차지하는 객체들이 존재하는지 살펴봅시다.&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/194&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>자바스크립트</category>
<category>javascript</category>
<category>memory leak</category>
<category>크롬 개발자 도구</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/194</guid>
<comments>https://itstory.tk/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98%EC%9D%98-4%EA%B0%80%EC%A7%80-%ED%98%95%ED%83%9C#entry194comment</comments>
<pubDate>Wed, 10 Jan 2018 13:54:25 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙56. 일반적으로 통용되는 작명 관습을 따르라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9956-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%86%B5%EC%9A%A9%EB%90%98%EB%8A%94-%EC%9E%91%EB%AA%85-%EA%B4%80%EC%8A%B5%EC%9D%84-%EB%94%B0%EB%A5%B4%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;자바 플랫폼에는 작명 관습(naming convention)이 잘 정립되어 있으며, 그 중 상당수는 자바 언어 명세(The Java Language Specification)에도 언급되어 있다. 간단하게 말해서 자바의 작명 관습은 두 가지 범주로 나눌 수 있다. 철자에 관한 것이 하나고, 문법에 관한 것이 하나다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;철자에 관계된 작명 관습은 패키지, 클래스, 인터페이스, 메서드, 필드 그리고 자료형 변수에 관한 것으로, 그 양이 얼마 되지 않는다. 아주 그럴듯한 이유가 없이 이 규칙을 어겨서는 안된다.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;패키지 이름은 마침표를 구분점으로 사용하는 계층적 이름이어야 한다. 패키지 이름을 구성하는 각각의 컴포넌트는 알파벳 소문자로 구성하고, 숫자는 거의 사용하지 않는다. 여러분의 조직 바깥에서 이용될 패키지 이름은 해당 조직의 인터넷 도메인 이름으로 시작해야 하는데 &lt;em&gt;com.sun&lt;/em&gt;, &lt;em&gt;gov.sna&lt;/em&gt; 처럼 최상위 도메인 이름이 먼저 온다. 패키지 이름의 나머지 부분은 어떤 패키지인지 설명하는 하나 이상의 컴포넌트로 구성된다. 패키지명 컴포넌트는 짧아야 하며, 보통 여덟 문자 이하로 만들어진다. 의미가 확실한 약어를 활용하면 더 좋다.(utilities 대신 util이라고 하면 좋다)&lt;/p&gt;&lt;p&gt;enum이나 어노테이션 자료형 이름을 비롯, 클래스나 인터페이스 이름은 하나 이상의 단어로 구성된다. 각 단어의 첫 글자는 대문자다. &lt;em&gt;Timer&lt;/em&gt;나 &lt;em&gt;FutureTask&lt;/em&gt;가 그 예다. 두문자 또는 max나 min처럼 널리 쓰이는 약어를 제외하면 약어 사용은 피해야 한다. 두문자의 경우 전부 대문자로 써야하는지, 아니면 그 첫 글자만 대문자로 써야 하는지에 대해서는 합의된 것이 별로 없다.&lt;/p&gt;&lt;p&gt;메서드와 필드이름은 클래스나 인터페이스 이름과 동일한 철자 규칙을 따른다. 다만 첫 글자는 소문자로 한다. &lt;em&gt;remove&lt;/em&gt;나 &lt;em&gt;ensureCapacity&lt;/em&gt; 등이 그 예다.&lt;/p&gt;&lt;p&gt;앞서 살펴본 규칙의 유일한 예는 상수 필드(constant field)의 이름을 지을때다. 상수 필드의 이름은 하나 이상의 대문자 단어로 구성되며, 단어 사이에는 밑줄 기호(_)를 둔다. &lt;em&gt;VALUES&lt;/em&gt;나 &lt;em&gt;NEGATIVE_INFINITY&lt;/em&gt;가 그 예다. &lt;/p&gt;&lt;p&gt;지역 변수 이름은 멤버 이름과 같은 철자 규칙을 따르는데, 약어가 허용된다는 것만 다르다. &lt;/p&gt;&lt;p&gt;자료형 인자의 이름은 보통 하나의 대문자다. 가장 널리 쓰이는 것은 다섯 가지로, 임의 자료형인 경우엔 T, 컬렉션 요소 자료형인 경우에는 E, 맵의 키와 값에 대해서는 각각 K와 V, 예외인 경우에는 X를 사용한다. 임의 자료형이 연속되는 경우에는 T, U, V 처럼하거나 T1, T2, T3처럼 나열한다.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
  &lt;th&gt;식별자 자료형&lt;/th&gt;
  &lt;th&gt;예제&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
  &lt;td&gt;패키지&lt;/td&gt;
  &lt;td&gt;com.google.inject, org.joda.time.format&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;클래스나 인터페이스&lt;/td&gt;
  &lt;td&gt;Timer, FutureTask, LinkedHashMap, HttpServlet&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;메서드나 필드&lt;/td&gt;
  &lt;td&gt;remove, ensureCapacity, getCrc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;상수 필드&lt;/td&gt;
  &lt;td&gt;MIN_VALUE, NEGATIVE_INFINITY&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;지역 변수&lt;/td&gt;
  &lt;td&gt;i, xref, houseNumber&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;지료형 인자&lt;/td&gt;
  &lt;td&gt;T, E, K, V, X, T1, T2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;&lt;strong&gt;문법적(grammatical) 작명 관습은 더 가변적일 뿐만 아니라, 철자 관습에 비해 논쟁의 여지가 많다.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;enum 자료형을 비롯한 클래스에는 단수형의 명사나 명사구(noun phrase) 가 이름으로 붙는다. Timer, BufferedWriter, ChessPiece 등이 그 예다. &lt;/p&gt;&lt;p&gt;인터페이스도 클래스와 비슷한 작명 규칙을 따른다. able이나 ible 같은 형용사격 어미가 붙기도 한다. Collection, Comparator, Iterable, Accessible 등이 그 예다.&lt;/p&gt;&lt;p&gt;어떤 동작을 수행하는 메서드는 일반적으로 동사나 동사구(목적어 포함)를 이름으로 갖는다. append나 drawImage 등이 그 예다.&lt;/p&gt;&lt;p&gt;boolean 값을 반환하는 메서드의 이름은 보통 is, 드물게는 has로 시작하고 그 뒤에는 명사나 명사구 또는 형용사나 형용사구가 붙는다. isDigit, isProbablePrime, isEmpty, hasSiblings 등이 그 예다.&lt;/p&gt;&lt;p&gt;boolean 이외의 기능이나 객체 속성을 반환하는 메서드에는 보통 명사나 명사구 또는 get으로 시작하는 동사구를 이름으로 붙인다. size, hashCode, getTime 등이 그런 이름이다. 빈(bean) 클래스에 속한 메서드의 이름은 반드시 get으로 시작해야 한다.&lt;/p&gt;&lt;p&gt;특별히 주의해야 하는 메서드 이름도 있다. 객체의 자료형을 변환하는 메서드, 다른 자료형의 독립적 객체를 반환하는 메서드에는 보통 toType 형태의 이름을 붙인다. toString, toArray 같은 이름이 그 예다.&lt;/p&gt;&lt;p&gt;인자로 전달받은 객체와 다른 자료형의 뷰(view) 객체를 반환하는 메서드(규칙5)에는 asType 형태의 이름을 붙인다. asList 같은 이름이 그 예다.&lt;/p&gt;&lt;p&gt;정적 팩터리 메서드에는 valueOf, of, getInstance, newInstance, getType, newType 같은 이름을 붙인다.(규칙1)&lt;/p&gt;

&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;p&gt;요약하자면, 표준적 작명 관습을 내면화시키고 마치 제2의 천성인 것처럼 사용하라는 것이다. 철자 관습은 직관적이고 모호한 부분도 멸로 없다. 반면 문법적 관습은 좀 더 복잡하고 느슨하다.&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/193&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/193</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9956-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%86%B5%EC%9A%A9%EB%90%98%EB%8A%94-%EC%9E%91%EB%AA%85-%EA%B4%80%EC%8A%B5%EC%9D%84-%EB%94%B0%EB%A5%B4%EB%9D%BC#entry193comment</comments>
<pubDate>Sun, 07 Jan 2018 17:23:32 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙55. 신중하게 최적화하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9955-%EC%8B%A0%EC%A4%91%ED%95%98%EA%B2%8C-%EC%B5%9C%EC%A0%81%ED%99%94%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;모든 프로그래머가 알아둬야 하는 최적화 관련 격언이 세 가지 있다. 너무 많이 봐서 질릴 정도라는 분도 있겠으나, 아직 본 적이 없다면 지금 읽어보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;맹목적인 어리석음(blind stupidity)을 비롯한 다른 어떤 이유보다도, 효율성이라는 이름으로 저질러지는 죄악이 더 많다(효율성을 반드시 성취하는 것도 아니면서 말이다). &lt;br /&gt;- 윌리엄 울프(William A. Wulf)&lt;/p&gt;
  
  &lt;p&gt;작은 효율성(small effiency)에 대해서는, 말하자면 97% 정도에 대해서는, 잊어버려라. 섣부른 최적화는 모든 악의 근원이다. &lt;br /&gt;- 도널드 커누스(Donald E. Knuth)&lt;/p&gt;
  
  &lt;p&gt;최적화를 할 때는 아래의 두 규칙을 따르라. &lt;br /&gt; 규칙1: 하지마라 &lt;br /&gt; 규칙2: (전문가들만 따를 것) 아직은 하지마라 - 완벽히 명료한, 최적화되지 않은 해답을 얻을 때까지는. &lt;br /&gt;- M. A. 잭슨(M. A. Jackson)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 격언들은 자바 언어가 나오기 20년 전에 나온 것들이다. 최적화에 관한 심오한 진리를 잘 보여준다. 최적화는 좋을 때보다 나쁠 때가 더 많으며, 섣불리 시도하면 더더욱 나쁘다는 것이다.&lt;/p&gt;&lt;p&gt;성능 때문에 구조적인 원칙(architectural principle)을 희생하지마라. &lt;strong&gt;빠른 프로그램이 아닌, 좋은 프로그램을 만들려 노력하라.&lt;/strong&gt; 좋은 프로그램인데 충분히 빠르지 않다면, 좋은 구조를 갖추었기 때문에 최적화의 여지도 충분할 것이다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;설계를 할 때는 성능을 제약할 가능성이 있는 결정들을 피하라.&lt;/strong&gt; 설계 가운데 성능에 문제가 있다는 사실이 발견된 후에 고치기가 가장 까다로운 부분은 모듈간 상호작용이나 외부와의 상호작용을 명시하는 부분이다. 이런 부분은 성능 문제가 발견된 후에는 수정하기 어렵거나 수정이 불가능하다. 또한 시스템이 낼 수 있는 성능의 최대치에 큰 영향을 준다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;API를 설계할 때 내리는 결정들이 성능에 어떤 영향을 끼칠지를 생각하라.&lt;/strong&gt; public 자료형을 변경 가능하게 만들면 쓸데없이 방어적 복사를 많이 해야할 수 있다(규칙 39). 마찬가지로 구성(composition) 기법이 적절한 클래스에 계승(inheritance) 기법을 적용하면 해당 클래스는 영원히 상위 클래스에 묶이는데, 그 결과로 하위 클래스의 성능에 인위적인 계약이 가해질 수 도 있다(규칙 16). 또한 인터페이스가 적당할 API에 구현 자료형(implementation type)을 사용해 버리면 해당 API가 특정한 구현에 종속되므로 나중에 더 빠른 구현이 나와도 개선할 수 없게 된다(규칙52).&lt;/p&gt;&lt;p&gt;잘 설계된 API는 일반적으로 좋은 성능을 보인다. &lt;strong&gt;좋은 성능을 내기 위해 API를 급진적으로 바꾸는 것은 바람직하지 않다.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;최적화를 시도할 때마다, 전후 성능을 측정하고 비교하라.&lt;/strong&gt; 측정 결과로 성능이 개선되지 않거나 더 나쁘지는 일이 많기 때문이다.&lt;/p&gt;

&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;p&gt;요약하자면, 빠른 프로그램을 만들고자 애쓰지 말라는 것이다. 대신 좋은 프로그램을 짜기 위해 애쓰라. 성능은 따라올 것이다. 하지만 시스템을 설계할 때, 특히 API나 통신 프로토콜, 또는 지속성 데이터 형식을 설계할 때는 성믄 문제를 따져보라. &lt;/p&gt;&lt;p&gt;시스템 구현을 마쳤다면 그 성능을 측정해 보라. 충분히 빠르면 끝난 것이다. 그렇지 않다면 프로파일링 도구의 도움을 받아서 문제가 되는 것을 알아낸 다음에 최적화하라. 처음으로 해야할 일은 구현에 쓰인 알고리즘을 검토하는 것이다. 저수준 최적화를 아무리 해봐야, 알고리즘을 잘못 골랐다면 성능을 만회할 수 없다. 이 프로세스를 필요한 만큼 반복하고, 최적화 단계별로 성능을 측정하라. 만족스러울 때까지.&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/192&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/192</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9955-%EC%8B%A0%EC%A4%91%ED%95%98%EA%B2%8C-%EC%B5%9C%EC%A0%81%ED%99%94%ED%95%98%EB%9D%BC#entry192comment</comments>
<pubDate>Sun, 07 Jan 2018 15:31:58 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙54. 네이티브 메서드는 신중하게 사용하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9954-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C-%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-%EC%8B%A0%EC%A4%91%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;자바의 네이티브 인터페이스(Java native interface, JNI)는 C나 C++ 등의 native programming language로 작성된 native method를 호출하는 데 이용되는 기능이다. 네이티브 메서드가 수행하는 임의의 계산은 네이티브 언어로 실행되며, 자바 언어로  전달된다.&lt;/p&gt;&lt;p&gt;전통적으로 네이티브 메서드는 세 가지 용도로 쓰였다. 네이티브 메서드를 사용하면 레지스트리(registry)나 파일 락(file lock) 같은 특정 플랫폼에 고유한 기능을 이용할 수 있다.&lt;/p&gt;&lt;p&gt;또한 이미 구현되어 있는 라이브러리를 이용할 수 있으며, 그 라이브러리를 통해 기존 데이터를 활용할 수 있다.&lt;/p&gt;&lt;p&gt;마지막으로, 네이티브 메서드를 사용하면 성능이 중요한 부분의 처리를 네이티브 언어에 맡길 수 있다.&lt;/p&gt;&lt;p&gt;특정 플랫폼에만 있는 기능을 이용하는 데는 네이티브 메서드가 적당하다. 하지만 자바 플랫폼이 발전하면서, 특정 플랫폼에서만 발견할 수 있었던 기능들도 제공되기에 이르렀다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;따라서 네이티브 메서드를 통해 성능을 개선하는 것은 추천하고 싶지 않다.&lt;/strong&gt; 현재 JVM은 훨씬 빠르고 네이티브 메서드 없이도 그에 필적하는 성능을 내는 것이 가능하다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;네이티브 메서드에는 심각한 문제가 있다.&lt;/strong&gt; 네이티브 언어는 안전하지 않으므로(규칙 39), 네이티브 메서드를 이용하는 프로그램은 메모리 훼손 문제(memory corruption error)로부터 자유로울 수 없다. 게다가 네이티브 언어는 플랫폼 종속적이므로 이식성이 낮다.&lt;/p&gt;&lt;p&gt;또한 네이티브 코드를 사용하는 프로그램은 디버깅하기도 훨씬 어렵다. 네이티브 코드를 넘나드는데 필요한 기본적인 비용 때문에, 네이티브 메서드가 하는 일이 별로 없다면 오히려 성능을 떨어뜨릴 수도 있다. 게다가 네이티브 메서드를 사용하려면 이해하기도 어렵고 작성하기도 난감한 적찹코드(glue code)를 작성해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;p&gt;네이티브 메서드를 사용하는 것은 재고하라. 그럴 일이 있을지는 모르겠으나 굳이 그래야 한다면, 성능 개선 용도로만 써라. 저수준(low-level) 자원이나 기존 라이브러리(legacy library)를 이용하기 위해 네이티브 메서드를 사용해야 한다면, 네이티브 코드는 가능하면 줄이고 광범위한 테스트를 거치기 바란다. 네이티브 코드에 있는 아주 작은 버그라도 시스템 전체를 훼손시킬 수 있다.&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/191&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/191</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9954-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C-%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-%EC%8B%A0%EC%A4%91%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC#entry191comment</comments>
<pubDate>Sun, 07 Jan 2018 14:49:01 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙53. 리플렉션 대신 인터페이스를 이용하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9953-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98-%EB%8C%80%EC%8B%A0-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;java.lang.reflect의 핵심 리플렉션 기능(core reflection facility)을 이용하면 메모리에 적재된 클래스의 정보를 가져오는 프로그램을 작성할 수 있다. 하지만 이런 능력에는 대가가 따른다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;컴파일 시점에 자료형을 검사함으로써 얻을 수 있는 이점들을 포기해야 한다(exception checking 포함). 리플렉션을 통해 존재하지 않는, 또는 접근할 수 없는 메서드를 호출하면 실행 도중에 오류가 발생할 것이다. 그러니 특별히 주의해야 한다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;리플레션 기능을 이용하는 코드는 보기 싫은데다 장황하다. 영리한 코드와는 거리가 멀고, 가독성도 떨어진다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;성능이 낮다. 리플렉션을 통한 메서드 호출 성능은, 일반적인 메서드 호출에 비해 훨씬 낮다. 얼마나 낮은지 정확히 말하기는 어렵다. 고려해야할 조건들이 다양하기 때문.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;핵심 리플렉션 기능은 원래 컴포넌트 기반 응용프로그램 저작 도구(component-based application builder tool)를 위해 설계된 기능이었다. 그런 도구는 보통 요청에 따라 클래스를 메모리에 올린 다음, 리플렉션 기능을 통해 어떤 메서드와 생성자가 지원되는지를 알아낸다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;명심할 것은, 일반적인 프로그램은 프로그램 실행 중에 리플렉션을 통해 객체를 이용하려 하면 안된다는 것이다. 하지만 리플렉션을 아주 제한적으로만 사용하면 오버헤드는 피하면서 리플렉션의 다양한 장점을 누릴 수 있다.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;컴파일 시점에는 존재하지 않는 클래스를 이용해야 하는 프로그램 가운데 상당수는 해당 클래스 객체를 참조하는데 사용할 수 있는 인터페이스나 상위 클래스(규칙 52)를 컴파일 시점에 이미 갖추고 있는 경우가 많다. 그럴 때는, &lt;strong&gt;객체 생성은 리플렉션으로 하고 객체 참조는 인터페이스나 상위 클래스를 통하면 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java hljs &quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 객체 생성은 리플렉션으로, 참조와 사용은 인터페이스로&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(String[] args) {
    &lt;span class=&quot;hljs-comment&quot;&gt;// 클래스 이름을 Class 객체로 변환&lt;/span&gt;
    Class&amp;lt;?&amp;gt; cl = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;

    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
        cl = Class.forName(args[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]);
    } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt;(ClassNotFoundException e) {
        System.err.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Class not found.&quot;&lt;/span&gt;);
        System.exit(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
    }

    &lt;span class=&quot;hljs-comment&quot;&gt;// 해당 클래스의 객체 생성&lt;/span&gt;
    Set&amp;lt;String&amp;gt; s = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;

    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
        s = (Set&amp;lt;String&amp;gt;) cl.newInstance();
    } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt;(IllegalAccessException e) {
        System.err.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Class not accessible.&quot;&lt;/span&gt;);
        System.exit(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
    } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt;(InstantiationException e) {
        System.err.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Class not instantiable.&quot;&lt;/span&gt;);
        System.exit(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
    }

    &lt;span class=&quot;hljs-comment&quot;&gt;// Set 이용&lt;/span&gt;
    s.addAll(Arrays.asList(args).subList(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, args.length));
    System.out.println(s);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;장난감에 불과한 프로그램이지만, 사용한 기술은 아주 강력하다. 이 프로그램은 하나 이상의 객체를 공격적으로 조작하여 해당 구현이 Set의 일반 규약을 준수하는지 검증하는 일반적 집합 검사 도구(generic set tester)로 쉽게 변경될 수 있다.&lt;/p&gt;&lt;p&gt;한편 이 예제는 리플렉션의 두 가지 단점도 보여준다.&lt;/p&gt;&lt;p&gt;첫번째로 이 예제는 세가지 실행시점 오류(runtime error)를 발생시키는데, 리플렉션으로 객체를 만들지 않았더라면 컴파일 시점에 검사할 수 있는 오류들이다.&lt;/p&gt;&lt;p&gt;두번째로 이 예제는 이름에 대응하는 클래스의 객체를 생성하기 위해 스무줄 가량의 멍청한 코드를 사용하고 있는데, 생성자를 호출로 대신했으면 한 줄이면 되었을 코드다.&lt;/p&gt;&lt;p&gt;하지만 이런 문제는 객체를 만드는 부분에섬나 나타난다. 객체가 만들어지고 나면 다른 Set 객체와 분간할 수 없다.&lt;/p&gt;



&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;p&gt;리플렉션은 특정한 종류의 복잡한 시스템 프로그래밍에 필요한 강력한 도구다. 하지만 단점이 많다. 컴파일 시점에는 알 수 없는 클래스를 이용하는 프로그램을 작성하고 있다면, 리플렉션을 사용하되 가능하면 객체를 만들 때만 사용하고, 객체를 참조할 때는 컴파일 시 알고 있는 인터페이스나 상위 클래스를 이용하라.&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/190&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/190</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9953-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98-%EB%8C%80%EC%8B%A0-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EB%9D%BC#entry190comment</comments>
<pubDate>Sun, 07 Jan 2018 14:34:04 +0900</pubDate>
</item>
<item>
<title>[이펙트 자바] 규칙52. 객체를 참조할 때는 그 인터페이스를 사용하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8A%B8-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9952-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%B0%B8%EC%A1%B0%ED%95%A0-%EB%95%8C%EB%8A%94-%EA%B7%B8-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;만일 적당한 인터페이스 자료형이 있다면 인자나 반환값, 변수 그리고 필드의 자료형은 클래스 대신 인터페이스로 선언하자.&lt;/strong&gt; 아래와 같은 타이핑하는 습관을 들이는 것이 좋다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java hljs &quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 인터페이스를 자료형으로 사용하고 있는 바람직한 예제&lt;/span&gt;
List&amp;lt;Subscriber&amp;gt; subscribers = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Vector&amp;lt;Subscriber&amp;gt;();&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java hljs &quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 클래스를 자료형으로 사용하는 나쁜 예제&lt;/span&gt;
Vector&amp;lt;Subscriber&amp;gt; subscribers = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Vector&amp;lt;Subscriber&amp;gt;();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;인터페이스를 자료형으로 쓰는 습관을 들이면 프로