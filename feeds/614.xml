<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>HIPERCUBE</title>
<link>http://hipercube.tistory.com/</link>
<description></description>
<language>ko</language>
<pubDate>Mon, 30 May 2016 16:19:11 +0900</pubDate>
<generator>TISTORY</generator>
<managingEditor>HIPERCUBE</managingEditor>
<item>
<title>Slf4j + Log4j</title>
<link>http://hipercube.tistory.com/entry/Slf4j-Log4j</link>
<description>&lt;iframe src=&quot;//www.facebook.com/plugins/follow?href=https%3A%2F%2Fwww.facebook.com%2Fjoowonryoo&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;colorscheme=light&amp;amp;width=450&amp;amp;height=80&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:450px; height:80px;&quot; allowtransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;h1 id=&quot;slf4j-+-log4j&quot;&gt;&lt;a name=&quot;slf4j-+-log4j&quot; href=&quot;#slf4j-+-log4j&quot;&gt;&lt;/a&gt;Slf4j + Log4j&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Simple Logging Facade for Java(SLF4J)&lt;/strong&gt; provides a Java logging API by means of a simple facade pattern. The underlying logging backend is determined at runtime by adding the desired binding to the classpath and may be the standard Sun Java logging package java.util.logging. Log4j, logback or tinylong.&lt;/p&gt;
&lt;h2 id=&quot;download&quot;&gt;&lt;a name=&quot;download&quot; href=&quot;#download&quot;&gt;&lt;/a&gt;Download&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Slf4j : &lt;a href=&quot;http://www.slf4j.org/download.html&quot;&gt;http://www.slf4j.org/download.html&lt;/a&gt;&lt;br /&gt;&lt;img src=&quot;/Users/HIPERCUBE/Desktop/Screen Shot 2015-11-09 at 9.07.15 AM.png&quot; alt=&quot;Screen Shot 2015-11-09 at 9.07.15 AM.png&quot;&gt;&lt;br /&gt;Download &lt;strong&gt;slf4j-1.7.12.tar.gz&lt;/strong&gt;  or &lt;strong&gt;slf4j-1.7.12.tar.gz&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Log4j : &lt;a href=&quot;https://logging.apache.org/log4j/2.0/download.html&quot;&gt;https://logging.apache.org/log4j/2.0/download.html&lt;/a&gt;&lt;br /&gt;&lt;img src=&quot;/Users/HIPERCUBE/Desktop/Screen Shot 2015-11-09 at 9.07.23 AM.png&quot; alt=&quot;Screen Shot 2015-11-09 at 9.07.23 AM.png&quot;&gt;&lt;br /&gt;Download &lt;strong&gt;apache-log4j-2.4.1-bin.tar.gz&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;how-to-run-slf4j-+-log4j&quot;&gt;&lt;a name=&quot;how-to-run-slf4j-+-log4j&quot; href=&quot;#how-to-run-slf4j-+-log4j&quot;&gt;&lt;/a&gt;How to run Slf4j + Log4j&lt;/h2&gt;
&lt;p&gt;Write this calss and add &lt;strong&gt;Slf4j + Log4j&lt;/strong&gt; into Build Path then run.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class HelloWorld {
    public static void main(String[] args) {
    Logger logger = LoggerFactory.getLogger(HelloWorld.class);
    logger.info(&quot;Hello World&quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Maybe an error message will appeared.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is a error cannot find Logging framework to binding on the slf4j.&lt;br /&gt;Add &lt;strong&gt;slf4j-simple-1.7.12.jar&lt;/strong&gt; into Build Path then run.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 [main] INFO HelloWorld - Hello World
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The default Slf4j configuration is complete.&lt;/p&gt;
&lt;h2 id=&quot;how-to-interact-log4j-and-slf4j&quot;&gt;&lt;a name=&quot;how-to-interact-log4j-and-slf4j&quot; href=&quot;#how-to-interact-log4j-and-slf4j&quot;&gt;&lt;/a&gt;How to interact LOG4J and SLF4J&lt;/h2&gt;
&lt;p&gt;It is similar. Just add &lt;strong&gt;Log4J-1.2.16.jar&lt;/strong&gt; and &lt;strong&gt;slf4j-log4j12-1.6.1.jar&lt;/strong&gt; into Build Path.&lt;br /&gt;&lt;strong&gt;slf4j-log4j12-1.6.1.jar&lt;/strong&gt; is a slf4j and log4j’s binder and &lt;strong&gt;log4j-1.2.16.jar&lt;/strong&gt; is a jar file for log4j.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;TestCode&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import org.slf4j.LoggerFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class HelloWorld {

    private static Logger client= LoggerFactory.getLogger(&quot;client&quot;);
    private static Logger server = LoggerFactory.getLogger(&quot;server&quot;);

    public static void main(String[] args) {
            Logger logger = LoggerFactory.getLogger(HelloWorld.class);
            logger.info(&quot;{}&quot;,&quot;Hello World&quot;);  // 바뀐 부분
        client.debug(&quot;{}&quot;, &quot;client&quot;);     // 밑에서 추가 설명
        server.debug(&quot;{}&quot;, &quot;server&quot;);     // 밑에서 추가 설명
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;logger.info(&quot;{}&quot;,&quot;Hello World&quot;);&lt;/code&gt; This part is changed.&lt;br /&gt;It can be understood that the “hello world” in &lt;code&gt;{}&lt;/code&gt; is printed.&lt;br /&gt;This is why use slf4j is good.&lt;/p&gt;
&lt;h2 id=&quot;how-to-control-logging-level&quot;&gt;&lt;a name=&quot;how-to-control-logging-level&quot; href=&quot;#how-to-control-logging-level&quot;&gt;&lt;/a&gt;How to control logging level&lt;/h2&gt;
&lt;p&gt;In Log4j, There is a logging levels that are info, debug, error etc.&lt;br /&gt;Usually when developing use info or debug, and when service change logging level to error and save as file.&lt;br /&gt;This is log4j.xml usage.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?--&amp;gt;


&amp;lt;log4j:configuration&amp;gt;
    &amp;lt;appender name=&quot;stdout&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&amp;gt;
        &amp;lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&amp;gt;
            &amp;lt;param name=&quot;ConversionPattern&quot; value=&quot;[%d{yyyy-MM-dd HH:mm}] %5p [%C{1}(%M:%L)] :%m%n%n&quot;&amp;gt;
        &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;


    &amp;lt;!-- 날짜별 로그 &amp;lt;appender name=&quot;dailyout&quot; class=&quot;org.apache.log4j.DailyRollingFileAppender&quot;&amp;gt; --&amp;gt;
    &amp;lt;!-- --&amp;gt;
    &amp;lt;appender name=&quot;file&quot; class=&quot;org.apache.log4j.DailyRollingFileAppender&quot;&amp;gt;
        &amp;lt;param name=&quot;file&quot; value=&quot;./logs/dailyout.log&quot;&amp;gt;
        &amp;lt;param name=&quot;Append&quot; value=&quot;true&quot;&amp;gt;
        &amp;lt;param name=&quot;DatePattern&quot; value=&quot;'.'yyMMdd&quot;&amp;gt;
        &amp;lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&amp;gt;
            &amp;lt;param name=&quot;ConversionPattern&quot; value=&quot;%t&amp;gt; [%d{yyyy-MM-dd HH:mm:ss}] [%c{1}]
        [%L] [%p] %m %n&quot;&amp;gt;
        &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;category name=&quot;client&quot;&amp;gt;
        &amp;lt;priority value=&quot;DEBUG&quot;&amp;gt;
    &amp;lt;/priority&amp;gt;&amp;lt;/category&amp;gt;

    &amp;lt;category name=&quot;server&quot;&amp;gt;
        &amp;lt;priority value=&quot;DEBUG&quot;&amp;gt;
    &amp;lt;/priority&amp;gt;&amp;lt;/category&amp;gt;
    &amp;lt;root&amp;gt;
        &amp;lt;priority value=&quot;INFO&quot;&amp;gt;
        &amp;lt;appender-ref ref=&quot;stdout&quot;&amp;gt;
        &amp;lt;appender-ref ref=&quot;file&quot;&amp;gt;
    &amp;lt;/appender-ref&amp;gt;&amp;lt;/appender-ref&amp;gt;&amp;lt;/priority&amp;gt;&amp;lt;/root&amp;gt;
&amp;lt;/log4j:configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At the bottom of xml, there is a root.&lt;br /&gt;It is &lt;code&gt;priority value=info&lt;/code&gt;.&lt;br /&gt;Change this part to &lt;code&gt;debug or error&lt;/code&gt;, and run HelloWorld&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[2011-07-20 12:48] DEBUG [HelloWorld(main:13)] :client
[2011-07-20 12:48] DEBUG [HelloWorld(main:14)] :server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;logger.info(&quot;{}&quot;,&quot;Hello World&quot;);&lt;/code&gt; Info isn’t printed because of logging level is changed to error.&lt;/p&gt;&lt;p&gt;If project unit is big, logging is getting a lot, and It is not easy to read.&lt;br /&gt;In this case, You can make logging category.&lt;br /&gt;For example, devide logging associated with Server and logging associated with DB.&lt;br /&gt;In xml,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;category name=&quot;server&quot;&amp;gt;
&amp;lt;category name=&quot;client&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is a two category.&lt;br /&gt;You can see necessary log infomation by using server and client’s &lt;code&gt;&amp;lt;priority value=&quot;DEBUG&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Change client’s priority to error and run.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[2011-07-20 12:48] DEBUG [HelloWorld(main:14)] :server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It will be printed.&lt;/p&gt;&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/deed.ko&quot; target=&quot;_blank&quot; style=&quot;text-decoration: none&quot;&gt;
	&lt;img id=&quot;ccl-icon-23-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;img id=&quot;ccl-icon-23-1&quot; class=&quot;entry-ccl-nc&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black02.png&quot; alt=&quot;비영리&quot;/&gt;
	&lt;img id=&quot;ccl-icon-23-2&quot; class=&quot;entry-ccl-nd&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black03.png&quot; alt=&quot;변경 금지&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
	&lt;/a&gt;
&lt;/div&gt;
</description>
<category>JAVA</category>
<author>HIPERCUBE</author>
<guid>http://hipercube.tistory.com/23</guid>
<comments>http://hipercube.tistory.com/entry/Slf4j-Log4j#entry23comment</comments>
<pubDate>Sat, 02 Jan 2016 23:56:34 +0900</pubDate>
</item>
<item>
<title>Dynamic Programming</title>
<link>http://hipercube.tistory.com/entry/Dynamic-Programming</link>
<description>&lt;iframe src=&quot;//www.facebook.com/plugins/follow?href=https%3A%2F%2Fwww.facebook.com%2Fjoowonryoo&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;colorscheme=light&amp;amp;width=450&amp;amp;height=80&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:450px; height:80px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;div style=&quot;font-family: 'Lucida Grande', 'Segoe UI', 'Apple SD Gothic Neo', 'Malgun Gothic', 'Lucida Sans Unicode', Helvetica, Arial, sans-serif; font-size: 0.9em; overflow-x: hidden; overflow-y: auto; margin: 0px !important; padding: 5px 20px 26px !important; background-color: rgb(255, 255, 255);font-family: 'Hiragino Sans GB', 'Microsoft YaHei', STHeiti, SimSun, 'Lucida Grande', 'Lucida Sans Unicode', 'Lucida Sans', 'Segoe UI', AppleSDGothicNeo-Medium, 'Malgun Gothic', Verdana, Tahoma, sans-serif; padding: 20px;padding: 20px; color: rgb(34, 34, 34); font-size: 15px; font-family: 'Roboto Condensed', Tauri, 'Hiragino Sans GB', 'Microsoft YaHei', STHeiti, SimSun, 'Lucida Grande', 'Lucida Sans Unicode', 'Lucida Sans', 'Segoe UI', AppleSDGothicNeo-Medium, 'Malgun Gothic', Verdana, Tahoma, sans-serif; line-height: 1.6; -webkit-font-smoothing: antialiased; background: rgb(255, 255, 255);&quot;&gt;&lt;h1 id=&quot;동적-프로그래밍-dynamic-programming&quot; style=&quot;clear: both;font-size: 2.2em; font-weight: bold; margin: 1.5em 0px 1em;margin-top: 0px;&quot;&gt;&lt;a name=&quot;동적-프로그래밍-dynamic-programming&quot; href=&quot;#동적-프로그래밍-dynamic-programming&quot; style=&quot;text-decoration: none; vertical-align: baseline;color: rgb(50, 105, 160);&quot;&gt;&lt;/a&gt;동적 프로그래밍 Dynamic Programming&lt;/h1&gt;&lt;h2 id=&quot;dynamic-programming-기법&quot; style=&quot;clear: both;font-size: 1.8em; font-weight: bold; margin: 1.275em 0px 0.85em;border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(230, 230, 230);&quot;&gt;&lt;a name=&quot;dynamic-programming-기법&quot; href=&quot;#dynamic-programming-기법&quot; style=&quot;text-decoration: none; vertical-align: baseline;color: rgb(50, 105, 160);&quot;&gt;&lt;/a&gt;Dynamic Programming 기법&lt;/h2&gt;&lt;p style=&quot;margin-top: 0px;margin: 1em 0px; word-wrap: break-word;&quot;&gt;&lt;strong&gt;Dynamic Programming 기법&lt;/strong&gt;이란 상향식 해결법(Bottom-up Approach)을 사용하여 알고리즘을 설계하는 방법이다.&lt;br style=&quot;clear: both;&quot;&gt;Divide &amp;amp; Conquer 기법과 마차가지로 문제를 나눈 후에 나누어진 부분들을 먼저 푼다.&lt;br style=&quot;clear: both;&quot;&gt;그러나 이미 풀어서 답을 알고 있는 부분의 결과가 다시 필요한 경우에는 반복하여 계산하는 대신에 이미 계산된 결과를 그냥 사용한다.&lt;br style=&quot;clear: both;&quot;&gt;&lt;strong&gt;Divide &amp;amp; Conquer&lt;/strong&gt;는 위에서 시작하여 필요한 계산을 해 나가는 반면에, &lt;strong&gt;DP(Dynamic Programming)&lt;/strong&gt;은 밑에서 시작하여 결과를 저장하면서 원하는 답을 찾아 나간다.&lt;/p&gt;&lt;h2 id=&quot;동적-계획법-dynamic-programming&quot; style=&quot;clear: both;font-size: 1.8em; font-weight: bold; margin: 1.275em 0px 0.85em;border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(230, 230, 230);&quot;&gt;&lt;a name=&quot;동적-계획법-dynamic-programming&quot; href=&quot;#동적-계획법-dynamic-programming&quot; style=&quot;text-decoration: none; vertical-align: baseline;color: rgb(50, 105, 160);&quot;&gt;&lt;/a&gt;동적 계획법 Dynamic Programming&lt;/h2&gt;&lt;p style=&quot;margin-top: 0px;margin: 1em 0px; word-wrap: break-word;&quot;&gt;&lt;strong&gt;동적 계획법 (Dynamic Programming)&lt;/strong&gt;이란 주어진 문제를 여러 개의 작은 문제로 분할하여 각 소문제의 해결안을 바탕으로 주어진 문제를 해결하는 것이다.&lt;br style=&quot;clear: both;&quot;&gt;각 작은 문제는 다시 또 여러 개의 작은 문제로 분할 가능하다.&lt;br style=&quot;clear: both;&quot;&gt;각 작은 문제는 원래 주어진 문제오 동일한 문제이지만 입력의 크기가 작다.&lt;br style=&quot;clear: both;&quot;&gt;작은 문제의 해를 표 형식으로 저장해 놓고 이를 이용해 입력 크기가 큰 원래의 문제를 점진적으로 해결한다.&lt;br style=&quot;clear: both;&quot;&gt;작은 문제들의 해를 먼저 구하여 저장하고 더 큰 문제의 해를 구할 때 작은 문제의 해를 반복 계산하지 않고 저장된 결과를 사용하는 것이다.&lt;/p&gt;&lt;h3 id=&quot;특징&quot; style=&quot;clear: both;font-size: 1.6em; font-weight: bold; margin: 1.125em 0px 0.75em;&quot;&gt;&lt;a name=&quot;특징&quot; href=&quot;#특징&quot; style=&quot;text-decoration: none; vertical-align: baseline;color: rgb(50, 105, 160);&quot;&gt;&lt;/a&gt;특징&lt;/h3&gt;&lt;ul&gt;
&lt;li style=&quot;display: list-item; line-height: 1.4em;&quot;&gt;주어진 문제의 해를 구하기 위한 순환적인 성질(Recursive Property)을 구성하여야 한다.&lt;/li&gt;&lt;li style=&quot;display: list-item; line-height: 1.4em;&quot;&gt;상향식으로 작은 부분 문제 부터 해를 구하여야 한다.&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;장점&quot; style=&quot;clear: both;font-size: 1.8em; font-weight: bold; margin: 1.275em 0px 0.85em;border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(230, 230, 230);&quot;&gt;&lt;a name=&quot;장점&quot; href=&quot;#장점&quot; style=&quot;text-decoration: none; vertical-align: baseline;color: rgb(50, 105, 160);&quot;&gt;&lt;/a&gt;장점&lt;/h2&gt;&lt;ul&gt;
&lt;li style=&quot;display: list-item; line-height: 1.4em;&quot;&gt;프로그램을 구현할 때에는 필요한 모든 가능성을 고려해서 구현하게 된다. 따라서 Dynamic Programming을 이용하여 항상 최적의 결과를 얻을 수 있다.&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;단점&quot; style=&quot;clear: both;font-size: 1.8em; font-weight: bold; margin: 1.275em 0px 0.85em;border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(230, 230, 230);&quot;&gt;&lt;a name=&quot;단점&quot; href=&quot;#단점&quot; style=&quot;text-decoration: none; vertical-align: baseline;color: rgb(50, 105, 160);&quot;&gt;&lt;/a&gt;단점&lt;/h2&gt;&lt;ul&gt;
&lt;li style=&quot;display: list-item; line-height: 1.4em;&quot;&gt;모든 가능성에 대한 고려가 불충분할 경우 최적의 결과를 보장할 수 없다. 동적 계획법을 구현하기 위해서는 충분히 많은 가능성에 대한 고려를 해야 한다.&lt;/li&gt;&lt;li style=&quot;display: list-item; line-height: 1.4em;&quot;&gt;다른 방법론에 비해 많은 표(배열)을 이용하므로 메모리를 많이 요구한다. (과거에 메모리가 작을때는 메모리 최적화가 중요했지만, 요즘은 임베디드 프로그래밍이거나 메모리를 알고리즘이 메모리를 심하게 잡아먹지 않는 이상 크게 메모리를 신경 쓸 필요 없다.)&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;재귀적-해법의-문제점&quot; style=&quot;clear: both;font-size: 1.8em; font-weight: bold; margin: 1.275em 0px 0.85em;border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(230, 230, 230);&quot;&gt;&lt;a name=&quot;재귀적-해법의-문제점&quot; href=&quot;#재귀적-해법의-문제점&quot; style=&quot;text-decoration: none; vertical-align: baseline;color: rgb(50, 105, 160);&quot;&gt;&lt;/a&gt;재귀적 해법의 문제점&lt;/h2&gt;&lt;p style=&quot;margin-top: 0px;margin: 1em 0px; word-wrap: break-word;&quot;&gt;재귀적 해법을 사용하면 직관적으로 문제를 해결할 수 있다는 장점이 있다. 하지만 반복된 재귀호출로 인해 알고리즘의 성능이 저하될 수 있다. Quick Sort, Merge Sort 등의 &lt;strong&gt;Sort Algorithm&lt;/strong&gt;이나 &lt;strong&gt;Factorial 구하기&lt;/strong&gt;, Graph의 &lt;strong&gt;DFS&lt;/strong&gt;에서는 재귀적 해법이 바람직하지만 &lt;strong&gt;Fibonacci 수 구하기&lt;/strong&gt;나 &lt;strong&gt;행렬곱셈 최적순서 구하기&lt;/strong&gt;에서는 중복호출로 인해 재귀적 해법이 치명적이다. Fibonacci 수 구하기 문제로 Dynamic Programming의 동기와 구현에 대해 알아보도록 하자&lt;/p&gt;&lt;h2 id=&quot;fibonacci-수-구하기&quot; style=&quot;clear: both;font-size: 1.8em; font-weight: bold; margin: 1.275em 0px 0.85em;border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(230, 230, 230);&quot;&gt;&lt;a name=&quot;fibonacci-수-구하기&quot; href=&quot;#fibonacci-수-구하기&quot; style=&quot;text-decoration: none; vertical-align: baseline;color: rgb(50, 105, 160);&quot;&gt;&lt;/a&gt;Fibonacci 수 구하기&lt;/h2&gt;&lt;pre style=&quot;border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); overflow: auto; padding: 0.5em;&quot;&gt;&lt;code data-origin=&quot;&lt;pre&gt;&lt;code&gt;#include &amp;amp;lt;iostream&amp;amp;gt;

int Fibonacci(int n){
    if (n &amp;amp;lt;= 0) return 0;
    else if (n == 1) return 1;
    else return Fibonacci(n - 1) + Fibonacci(n - 2);
}
&lt;/code&gt;&lt;/pre&gt;&quot; style=&quot;border: 0px; display: block;font-family: Consolas, Inconsolata, Courier, monospace; font-weight: bold; white-space: pre; margin: 0px;border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); padding: 0px 5px; margin: 0px 2px;font-size: 1em; letter-spacing: -1px; font-weight: bold;&quot;&gt;#include &amp;lt;iostream&amp;gt;

int Fibonacci(int n){
    if (n &amp;lt;= 0) return 0;
    else if (n == 1) return 1;
    else return Fibonacci(n - 1) + Fibonacci(n - 2);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p style=&quot;margin: 1em 0px; word-wrap: break-word;&quot;&gt;위의 코드는 Fibonacci 수를 재귀적 호출로 구하는 Cpp 소스이다.&lt;br style=&quot;clear: both;&quot;&gt;이 알고리즘의 시간복잡도는 &lt;strong&gt;O(2^n)&lt;/strong&gt;이다.&lt;/p&gt;&lt;pre style=&quot;border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); overflow: auto; padding: 0.5em;&quot;&gt;&lt;code data-origin=&quot;&lt;pre&gt;&lt;code&gt;#include &amp;amp;lt;iostream&amp;amp;gt;

int Fibonacci(int n) {
    int fib[n];
    for (int i = 2; i &amp;amp;lt; n; i++) {
        fib[0] = 0;
        fib[1] = 1;
        fib[i] = fib[n-1] + fib[i-2];
    }
    return fib[n];
}
&lt;/code&gt;&lt;/pre&gt;&quot; style=&quot;border: 0px; display: block;font-family: Consolas, Inconsolata, Courier, monospace; font-weight: bold; white-space: pre; margin: 0px;border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); padding: 0px 5px; margin: 0px 2px;font-size: 1em; letter-spacing: -1px; font-weight: bold;&quot;&gt;#include &amp;lt;iostream&amp;gt;

int Fibonacci(int n) {
    int fib[n];
    for (int i = 2; i &amp;lt; n; i++) {
        fib[0] = 0;
        fib[1] = 1;
        fib[i] = fib[n-1] + fib[i-2];
    }
    return fib[n];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p style=&quot;margin: 1em 0px; word-wrap: break-word;&quot;&gt;위 코드는 Fibonacci 수를 &lt;strong&gt;Dynamic Programming&lt;/strong&gt;을 이용하여 푸는 Cpp 소스이다.&lt;br style=&quot;clear: both;&quot;&gt;재귀적 호출을 사용하는 알고리즘과 다르게 배열에 이전 값을 저장해서 가져다 사용하는 것을 알 수 있다.&lt;br style=&quot;clear: both;&quot;&gt;이 알고리즘은 O(n) 시간에 끝난다. 재귀적 호출으로 풀었을 때보다 훨씬 단축되었다.&lt;/p&gt;&lt;h2 id=&quot;dynamic-programming의-적용-요건&quot; style=&quot;clear: both;font-size: 1.8em; font-weight: bold; margin: 1.275em 0px 0.85em;border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(230, 230, 230);&quot;&gt;&lt;a name=&quot;dynamic-programming의-적용-요건&quot; href=&quot;#dynamic-programming의-적용-요건&quot; style=&quot;text-decoration: none; vertical-align: baseline;color: rgb(50, 105, 160);&quot;&gt;&lt;/a&gt;Dynamic Programming의 적용 요건&lt;/h2&gt;&lt;p style=&quot;margin-top: 0px;margin: 1em 0px; word-wrap: break-word;&quot;&gt;위에서 본것 같이 Dynamic Programming을 사용하면 훨씬 효율적인 알고리즘을 작성 할 수 있는 경우가 있다.&lt;/p&gt;&lt;ul&gt;
&lt;li style=&quot;display: list-item; line-height: 1.4em;&quot;&gt;Optimal substructure (최적 부분구조)&lt;br style=&quot;clear: both;&quot;&gt; 큰 문제의 최적 솔루션에 작은 문제의 최적 솔루션이 포함되는 경우&lt;/li&gt;&lt;li style=&quot;display: list-item; line-height: 1.4em;&quot;&gt;Overlapping recursive calls (재귀 호출시 중복)&lt;br style=&quot;clear: both;&quot;&gt;재귀적 해법으로 풀면 같은 문제에 대한 재귀호출이 심하게 중복되는 경우(ex Fibonacci)&lt;br style=&quot;clear: both;&quot;&gt;이런 경우에는 Dynamic Programming을 사용하면 된다.&lt;br style=&quot;clear: both;&quot;&gt;이제 몇몇 문제에 Dynamic Programming을 적용해 보면서 알아보도록 하자.&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;행렬-경로-문제&quot; style=&quot;clear: both;font-size: 1.8em; font-weight: bold; margin: 1.275em 0px 0.85em;border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(230, 230, 230);&quot;&gt;&lt;a name=&quot;행렬-경로-문제&quot; href=&quot;#행렬-경로-문제&quot; style=&quot;text-decoration: none; vertical-align: baseline;color: rgb(50, 105, 160);&quot;&gt;&lt;/a&gt;행렬 경로 문제&lt;/h2&gt;&lt;blockquote style=&quot;margin: 1em 20px;border-left-width: 4px; border-left-style: solid; border-left-color: rgb(230, 230, 230); padding: 0px 15px; color: rgb(119, 119, 119);&quot;&gt;
&lt;p style=&quot;margin: 1em 0px; word-wrap: break-word;margin-top: 0px;&quot;&gt;&lt;strong&gt;규칙&lt;/strong&gt;&lt;br style=&quot;clear: both;&quot;&gt;양 또는 음의 정수 원소들로 구성된 n x n 행렬이 주어지고, 행렬의 좌상단에서 시작하여 우하단까지 이동한다.&lt;br style=&quot;clear: both;&quot;&gt;오른쪽이나 아래쪽으로만 이동할 수 있다.&lt;br style=&quot;clear: both;&quot;&gt;왼쪽, 위쪽, 대각선 이동은 허용하지 않는다&lt;br style=&quot;clear: both;&quot;&gt;목표 : 행렬의 좌상단에서 시작하여 우하단까지 이동하되, 방문한 칸에 있는 수들을 더한 값이 최대화 되도록 한다.&lt;/p&gt;
&lt;p style=&quot;margin: 1em 0px; word-wrap: break-word;margin-bottom: 0px;&quot;&gt;&lt;img src=&quot;http://m1.daumcdn.net/cfile206/image/2661523F552FB23018EA7F&quot; alt=&quot;&quot; style=&quot;max-width: 100%;&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;p style=&quot;margin: 1em 0px; word-wrap: break-word;&quot;&gt;우선 먼저 재귀호출을 이용해서 풀어보자&lt;/p&gt;&lt;pre style=&quot;border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); overflow: auto; padding: 0.5em;&quot;&gt;&lt;code data-origin=&quot;&lt;pre&gt;&lt;code&gt;int matrixPath(int[][] m, int i, int j) {    // (i, j)에 이르는 최고점수
    if (i == 0 &amp;amp;amp;&amp;amp;amp; j == 0) return m[i][j];
    else if (i == 0) return matrixPath(m, 1, j - 1) + m[i][j];        // 오른쪽 수평 이동
    else if (j == 0) return matrixpath(m, i - 1, 1) + m[i][j];        // 아래로 수직 이동
    else return Math.max(matrixPath(m, i - 1, j), matrixpath(m, i, j - 1)) + m[i][j];
}
&lt;/code&gt;&lt;/pre&gt;&quot; style=&quot;border: 0px; display: block;font-family: Consolas, Inconsolata, Courier, monospace; font-weight: bold; white-space: pre; margin: 0px;border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); padding: 0px 5px; margin: 0px 2px;font-size: 1em; letter-spacing: -1px; font-weight: bold;&quot;&gt;int matrixPath(int[][] m, int i, int j) {    // (i, j)에 이르는 최고점수
    if (i == 0 &amp;amp;&amp;amp; j == 0) return m[i][j];
    else if (i == 0) return matrixPath(m, 1, j - 1) + m[i][j];        // 오른쪽 수평 이동
    else if (j == 0) return matrixpath(m, i - 1, 1) + m[i][j];        // 아래로 수직 이동
    else return Math.max(matrixPath(m, i - 1, j), matrixpath(m, i, j - 1)) + m[i][j];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p style=&quot;margin: 1em 0px; word-wrap: break-word;&quot;&gt;위 알고리즘은 반복된 재귀호출로 인해 알고리즘 성능이 저하된다.&lt;br style=&quot;clear: both;&quot;&gt;배열에 값을 저장했다가 사용하는 &lt;strong&gt;메모이제이션&lt;/strong&gt;기법을 사용해서 개선해보도록 하자&lt;/p&gt;&lt;pre style=&quot;border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); overflow: auto; padding: 0.5em;&quot;&gt;&lt;code data-origin=&quot;&lt;pre&gt;&lt;code&gt;int matrixPath(int[][] m, int i, int j, int[][] cache) {
    if(i == 0 &amp;amp;amp;&amp;amp;amp; j == 0) return cache[0][0];
    else if (i == 0) {
        cache[i][j] = (cache[0][j - 1] != 0) ? (cache[0][j - 1] + m[0][j]) : (matrixPath(m, 0, j - 1, cache) + m[0][j])
        return cache[i][j];
    }
    else if (j == 0) {
        cache[i][j] = (cache[i - 1][0] != 0) ? (cache[i - 1][0] + m[i][0]) : (matrixPath(m, i - 1, 0, cache) + m[i][0])
        return cache[i][j];
    }

    int a = (cache[i - 1][j] != 0) ? (cache[i - 1][j]) : (matrixPath(m, i - 1, j, cache));
    int b = (cache[i][j - 1] != 0) ? (cache[i][j - 1]) : (matrixPath(m, i, j - 1, cache));
    cache[i][j] = Math.max(a, b) + m[i][j];
}
&lt;/code&gt;&lt;/pre&gt;&quot; style=&quot;border: 0px; display: block;font-family: Consolas, Inconsolata, Courier, monospace; font-weight: bold; white-space: pre; margin: 0px;border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); padding: 0px 5px; margin: 0px 2px;font-size: 1em; letter-spacing: -1px; font-weight: bold;&quot;&gt;int matrixPath(int[][] m, int i, int j, int[][] cache) {
    if(i == 0 &amp;amp;&amp;amp; j == 0) return cache[0][0];
    else if (i == 0) {
        cache[i][j] = (cache[0][j - 1] != 0) ? (cache[0][j - 1] + m[0][j]) : (matrixPath(m, 0, j - 1, cache) + m[0][j])
        return cache[i][j];
    }
    else if (j == 0) {
        cache[i][j] = (cache[i - 1][0] != 0) ? (cache[i - 1][0] + m[i][0]) : (matrixPath(m, i - 1, 0, cache) + m[i][0])
        return cache[i][j];
    }

    int a = (cache[i - 1][j] != 0) ? (cache[i - 1][j]) : (matrixPath(m, i - 1, j, cache));
    int b = (cache[i][j - 1] != 0) ? (cache[i][j - 1]) : (matrixPath(m, i, j - 1, cache));
    cache[i][j] = Math.max(a, b) + m[i][j];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p style=&quot;margin: 1em 0px; word-wrap: break-word;&quot;&gt;cache의 첫번째 값인 cache[0][0] = m[0][0]이 미리 실행되어 잇고, 한번 계산된 matrixPath값들은 이 cache 배열에 저장되고, 나중에 다시 matrixPath 함수를 재귀 호출하는 대신에 사용된다. cache배열에 이전 값을 저장하고 가져다 사용하면서 불필요한 재귀호출을 막을 수 있다.&lt;/p&gt;&lt;h2 id=&quot;조약돌(pebble)-놓기&quot; style=&quot;clear: both;font-size: 1.8em; font-weight: bold; margin: 1.275em 0px 0.85em;border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(230, 230, 230);&quot;&gt;&lt;a name=&quot;조약돌(pebble)-놓기&quot; href=&quot;#조약돌(pebble)-놓기&quot; style=&quot;text-decoration: none; vertical-align: baseline;color: rgb(50, 105, 160);&quot;&gt;&lt;/a&gt;조약돌(Pebble) 놓기&lt;/h2&gt;&lt;blockquote style=&quot;margin: 1em 20px;border-left-width: 4px; border-left-style: solid; border-left-color: rgb(230, 230, 230); padding: 0px 15px; color: rgb(119, 119, 119);&quot;&gt;
&lt;p style=&quot;margin: 1em 0px; word-wrap: break-word;margin-top: 0px;&quot;&gt;&lt;strong&gt;규칙&lt;/strong&gt;&lt;br style=&quot;clear: both;&quot;&gt;3 x n 테이블의 각 칸에 양 또는 음의 정수가 기록되어 있다.&lt;br style=&quot;clear: both;&quot;&gt;각 열에는 적어도 하나의 조약돌을 놓아야 한다.&lt;br style=&quot;clear: both;&quot;&gt;가로나 세로로 인접한 두 칸에 동시에 조약돌을 놓을 수 없다.&lt;br style=&quot;clear: both;&quot;&gt;목표 : 돌이 놓인 자리에 있는 수의 합을 최대가 되도록 약돌 놓기&lt;/p&gt;
&lt;p style=&quot;margin: 1em 0px; word-wrap: break-word;margin-bottom: 0px;&quot;&gt;&lt;strong&gt;패턴&lt;/strong&gt;&lt;br style=&quot;clear: both;&quot;&gt;&lt;img src=&quot;http://postfiles2.naver.net/data44/2008/12/20/113/%B9%AB%C1%A6-1_pluulove84.jpg?type=w2&quot; alt=&quot;&quot; style=&quot;max-width: 100%;&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;pre style=&quot;border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); overflow: auto; padding: 0.5em;&quot;&gt;&lt;code data-origin=&quot;&lt;pre&gt;&lt;code&gt;int pebble(int i, int p) {
    // i열이 패턴 p로 놓일 때의 최고점수
    // w(i, p) : i열이 패턴 p로 놓일 때 i열에 돌이 놓인 곳의 점수합
    if (i == 1) return w[1, p];
    else {
        max = 0;
        for (int q = 0; q &amp;amp;lt; 4; ++q) {
            if (패턴 q과 패턴 p가 양립) { 
                tmp = pebble(i - 1, q);
                if (tmp &amp;amp;gt; max) max = tmp;
            }
        }
        return max + w(i, p);
    }
}
&lt;/code&gt;&lt;/pre&gt;&quot; style=&quot;border: 0px; display: block;font-family: Consolas, Inconsolata, Courier, monospace; font-weight: bold; white-space: pre; margin: 0px;border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); padding: 0px 5px; margin: 0px 2px;font-size: 1em; letter-spacing: -1px; font-weight: bold;&quot;&gt;int pebble(int i, int p) {
    // i열이 패턴 p로 놓일 때의 최고점수
    // w(i, p) : i열이 패턴 p로 놓일 때 i열에 돌이 놓인 곳의 점수합
    if (i == 1) return w[1, p];
    else {
        max = 0;
        for (int q = 0; q &amp;lt; 4; ++q) {
            if (패턴 q과 패턴 p가 양립) { 
                tmp = pebble(i - 1, q);
                if (tmp &amp;gt; max) max = tmp;
            }
        }
        return max + w(i, p);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p style=&quot;margin: 1em 0px; word-wrap: break-word;&quot;&gt;위 알고리즘은 제귀호출로 푼것이다.&lt;br style=&quot;clear: both;&quot;&gt;위 알고리즘에 Dynamic Programming을 적용해 보도록 하자.&lt;/p&gt;&lt;pre style=&quot;border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); overflow: auto; padding: 0.5em;&quot;&gt;&lt;code data-origin=&quot;&lt;pre&gt;&lt;code&gt;pebble(n) {
    for(p=1; p&amp;amp;lt;=4; p++)
       peb[1, p] = w[1, p];
    for(i=2; i&amp;amp;lt;=n; i++) {
       for(p=1; p&amp;amp;lt;=4; p++)
          peb[i, p] = max(peb[i-1, q]) + w[i, p];
    }
    return max(peb[n, p]);
 }
&lt;/code&gt;&lt;/pre&gt;&quot; style=&quot;border: 0px; display: block;font-family: Consolas, Inconsolata, Courier, monospace; font-weight: bold; white-space: pre; margin: 0px;border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); padding: 0px 5px; margin: 0px 2px;font-size: 1em; letter-spacing: -1px; font-weight: bold;&quot;&gt;pebble(n) {
    for(p=1; p&amp;lt;=4; p++)
       peb[1, p] = w[1, p];
    for(i=2; i&amp;lt;=n; i++) {
       for(p=1; p&amp;lt;=4; p++)
          peb[i, p] = max(peb[i-1, q]) + w[i, p];
    }
    return max(peb[n, p]);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;p style=&quot;margin: 1em 0px; word-wrap: break-word;&quot;&gt;위처럼 Dynamic Programming을 이용하면 효율적인 알고리즘을 작성 할 수 있다.&lt;/p&gt;&lt;h2 id=&quot;longest-common-subsequence(lcs)-최장공통부분순서&quot; style=&quot;clear: both;font-size: 1.8em; font-weight: bold; margin: 1.275em 0px 0.85em;border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(230, 230, 230);&quot;&gt;&lt;a name=&quot;longest-common-subsequence(lcs)-최장공통부분순서&quot; href=&quot;#longest-common-subsequence(lcs)-최장공통부분순서&quot; style=&quot;text-decoration: none; vertical-align: baseline;color: rgb(50, 105, 160);&quot;&gt;&lt;/a&gt;Longest Common Subsequence(LCS) 최장공통부분순서&lt;/h2&gt;&lt;blockquote style=&quot;margin: 1em 20px;border-left-width: 4px; border-left-style: solid; border-left-color: rgb(230, 230, 230); padding: 0px 15px; color: rgb(119, 119, 119);&quot;&gt;
&lt;p style=&quot;margin: 1em 0px; word-wrap: break-word;margin-top: 0px;margin-bottom: 0px;&quot;&gt;&lt;strong&gt;규칙&lt;/strong&gt;&lt;br style=&quot;clear: both;&quot;&gt;두 string에 공통적으로 들어있는 common subsequence들 중 가장 긴 것을 찾는다.&lt;br style=&quot;clear: both;&quot;&gt;Subsequence의 예 : &lt;bcdb&gt;는 문자열 &lt;abcbdab&gt;의 subsequence이다.&lt;br style=&quot;clear: both;&quot;&gt;Common subsequence의 예 : &lt;bca&gt;는 문자열 &lt;abcbdab&gt;와 &lt;bdcaba&gt;의 common subsequence이다.&lt;br style=&quot;clear: both;&quot;&gt;)&lt;br style=&quot;clear: both;&quot;&gt;&lt;strong&gt;Longest common subsequence(LCS)&lt;/strong&gt;&lt;br style=&quot;clear: both;&quot;&gt;Common subsequence들 중 가장 긴 것&lt;br style=&quot;clear: both;&quot;&gt;ex) &lt;bcba&gt;는 string &lt;abcbdab&gt;와 &lt;bdcaba&gt;의 LCS이다.&lt;/bdcaba&gt;&lt;/abcbdab&gt;&lt;/bcba&gt;&lt;/bdcaba&gt;&lt;/abcbdab&gt;&lt;/bca&gt;&lt;/abcbdab&gt;&lt;/bcdb&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;pre style=&quot;border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); overflow: auto; padding: 0.5em;&quot;&gt;&lt;code data-origin=&quot;&lt;pre&gt;&lt;code&gt;func lcs(x,y)
    if ( length(x)=0 or length(y)=0 ) 
       return &amp;quot;&amp;quot;

    best = lcs(x[1,n-1],y[1,m])

    if ( length(best) &amp;amp;lt; length(lcs(x[1,n],y[1,m-1])) )
       best = lcs(x[1,n],y[1,m-1])

    if ( x[n] = y[m] and length(best) &amp;amp;lt; length(lcs(x[1,n-1],y[1,m-1]) + 1 )
       best = lcs(x[1,n-1],y[1,m-1]) + x[n]

   return best
&lt;/code&gt;&lt;/pre&gt;&quot; style=&quot;border: 0px; display: block;font-family: Consolas, Inconsolata, Courier, monospace; font-weight: bold; white-space: pre; margin: 0px;border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); padding: 0px 5px; margin: 0px 2px;font-size: 1em; letter-spacing: -1px; font-weight: bold;&quot;&gt;func lcs(x,y)
    if ( length(x)=0 or length(y)=0 ) 
       return &quot;&quot;

    best = lcs(x[1,n-1],y[1,m])

    if ( length(best) &amp;lt; length(lcs(x[1,n],y[1,m-1])) )
       best = lcs(x[1,n],y[1,m-1])

    if ( x[n] = y[m] and length(best) &amp;lt; length(lcs(x[1,n-1],y[1,m-1]) + 1 )
       best = lcs(x[1,n-1],y[1,m-1]) + x[n]

   return best
&lt;/code&gt;&lt;/pre&gt;&lt;p style=&quot;margin: 1em 0px; word-wrap: break-word;&quot;&gt;위 알고리즘은 재귀호출로 푼 해법이다.&lt;br style=&quot;clear: both;&quot;&gt;Dynamic Programming을 적용하면 아래와 같다.&lt;/p&gt;&lt;pre style=&quot;border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); overflow: auto; padding: 0.5em;&quot;&gt;&lt;code data-origin=&quot;&lt;pre&gt;&lt;code&gt; func lcs(x,y)
   n = length( x ), m = length( y )
   for i from 0 to n
      for j from 0 to m
          if ( i is 0 or j is 0 )
             table[i,j] = &amp;quot;&amp;quot;
            if ( x[i] == y[j] ) table[i,j] = x[i]
         else
             /* Sentinel */
             table[i,j] = table[i-1,j]
             if ( length( table[i,j] ) &amp;amp;lt; length( table[i,j-1] ) )
                table[i,j] = table[i,j-1];
             if ( x[i] = y[j] and length( table[i,j] ) &amp;amp;lt; length( table[i-1,j-1] ) + 1 )
                table[i,j] = table[i-1,j-1] + x[i];
   return table[n][m]
&lt;/code&gt;&lt;/pre&gt;&quot; style=&quot;border: 0px; display: block;font-family: Consolas, Inconsolata, Courier, monospace; font-weight: bold; white-space: pre; margin: 0px;border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); padding: 0px 5px; margin: 0px 2px;font-size: 1em; letter-spacing: -1px; font-weight: bold;&quot;&gt; func lcs(x,y)
   n = length( x ), m = length( y )
   for i from 0 to n
      for j from 0 to m
          if ( i is 0 or j is 0 )
             table[i,j] = &quot;&quot;
            if ( x[i] == y[j] ) table[i,j] = x[i]
         else
             /* Sentinel */
             table[i,j] = table[i-1,j]
             if ( length( table[i,j] ) &amp;lt; length( table[i,j-1] ) )
                table[i,j] = table[i,j-1];
             if ( x[i] = y[j] and length( table[i,j] ) &amp;lt; length( table[i-1,j-1] ) + 1 )
                table[i,j] = table[i-1,j-1] + x[i];
   return table[n][m]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/deed.ko&quot; target=&quot;_blank&quot; style=&quot;text-decoration: none&quot;&gt;
	&lt;img id=&quot;ccl-icon-22-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;img id=&quot;ccl-icon-22-1&quot; class=&quot;entry-ccl-nc&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black02.png&quot; alt=&quot;비영리&quot;/&gt;
	&lt;img id=&quot;ccl-icon-22-2&quot; class=&quot;entry-ccl-nd&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black03.png&quot; alt=&quot;변경 금지&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
	&lt;/a&gt;
&lt;/div&gt;
</description>
<category>Algorithm</category>
<author>HIPERCUBE</author>
<guid>http://hipercube.tistory.com/22</guid>
<comments>http://hipercube.tistory.com/entry/Dynamic-Programming#entry22comment</comments>
<pubDate>Sat, 02 Jan 2016 16:13:17 +0900</pubDate>
</item>
<item>
<title>[C++] Function Object</title>
<link>http://hipercube.tistory.com/entry/C-Function-Object</link>
<description>&lt;iframe src=&quot;//www.facebook.com/plugins/follow?href=https%3A%2F%2Fwww.facebook.com%2Fjoowonryoo&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;colorscheme=light&amp;amp;width=450&amp;amp;height=80&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:450px; height:80px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;style type=&quot;text/css&quot;&gt;
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body &gt; *:first-child {
  margin-top: 0 !important; }
body &gt; *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(http://cfile25.uf.tistory.com/image/2102E23956EB248B1192BA&quot;toc_0&quot;&gt;&lt;br /&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;;height:auto;max-width:100%&quot;&gt;&lt;a href=&quot;http://hipercube.tistory.com/attachment/cfile8.uf@226950425567A30B0E4150.pdf&quot;&gt;&lt;img src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/blog/image/extension/pdf.gif&quot; alt=&quot;&quot; style=&quot;vertical-align: middle;&quot; /&gt; Function Object.pdf&lt;/a&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h1 id=&quot;toc_0&quot;&gt;Function Object&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Function Object&lt;/strong&gt; is an object action like function.
To operate Object like function, we must define operator '&lt;strong&gt;()&lt;/strong&gt;'.
That is object overloading operator '&lt;strong&gt;()&lt;/strong&gt;'.
Function objects are sometimes called &lt;strong&gt;Functor&lt;/strong&gt;.
Code below is a sample defined simple function and function object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

void print() {
    std::cout &amp;lt;&amp;lt; &quot;global function&quot; &amp;lt;&amp;lt; std::endl;
}

struct Functor {
    void operator()() {
        std::cout &amp;lt;&amp;lt; &quot;function obejct&quot; &amp;lt;&amp;lt; std::endl;
    }
};

int main() {
    Functor functor;

    print();       // call global function
    functor();     // call member function  functor.operator();
    
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Functor is a object but can be used as function(functor()).
Call the operator '()' member function.
It can create a function object having parameter.
Code below is a sample function object having parameter.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

void print(int a, int b) {
    std::cout &amp;lt;&amp;lt; &quot;global function : &quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; std::endl;
}

struct Functor {
    void operator()(int a, int b) {
        std::cout &amp;lt;&amp;lt; &quot;functino object : &quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; std::endl;
    }
};

int main() {
    Functor functor;

    print(1, 2);       // call global function
    functor(1, 2);     // call member function  functor.operator(1, 2);

    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why use function object?
As function object is an object acting like functon, It can have an another member variable and member function, and can use function not in function. And even if function object's signature is same, when object type is different, it is recognized as different type. &lt;strong&gt;Usually, Function Object is faster than general function.&lt;/strong&gt; If you pass a callback function address, this function pointer can't be inline, but function object can be inline and it can be easily optimized by compiler.
Code below is a sample to show function object's merit.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Adder {
    int total;
public:
    explicit Adder(int n = 0) : total(n) { }

    int operator()(int n) {
        return total += n;
    }
};

int main() {
    Adder add(0);

    std::cout &amp;lt;&amp;lt; add(10) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; add(20) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; add(30) &amp;lt;&amp;lt; std::endl;

    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10
30
60&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code, as function &lt;strong&gt;operator()(int n)&lt;/strong&gt; is declared in the class, it is implicitly to be inline function.
And even if operator()(int n) is same signature, other type function object can't assignment and copy to Adder class.
Code below is a function object using callback function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

/**
 * Client
 */
struct Functor1 {
    void operator()(int n) {
        std::cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &quot; &quot;;
    }
};

struct Functor2 {
    void operator()(int n) {
        std::cout &amp;lt;&amp;lt; n * n &amp;lt;&amp;lt; &quot; &quot;;
    }
};

struct Functor3 {
    void operator()(int n) {
        std::cout &amp;lt;&amp;lt; &quot;integer : &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl;
    }
};

int main() {
    int arr[5] = {10, 20, 30, 40, 50};

    std::for_each(arr, arr + 5, Functor1());
    std::cout &amp;lt;&amp;lt; std::endl;

    std::for_each(arr, arr + 5, Functor2());
    std::cout &amp;lt;&amp;lt; std::endl;

    std::for_each(arr, arr + 5, Functor3());

    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10 20 30 40 50 
100 400 900 1600 2500 
integer : 10
integer : 20
integer : 30
integer : 40
integer : 50&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;Implementation function object&lt;/h2&gt;

&lt;p&gt;In &lt;strong&gt;STL&lt;/strong&gt;, There are useful function objects. In there, typical functions are &lt;strong&gt;less&lt;/strong&gt; and &lt;strong&gt;greater&lt;/strong&gt;.
&lt;strong&gt;less&lt;/strong&gt; is operator '&amp;lt;' function object, and &lt;strong&gt;greater&lt;/strong&gt; is operator '&amp;gt;' function object. Also less and greater are predicate returning 'bool' type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

bool predLess(int a, int b) { return a &amp;lt; b; }

struct Less {
    bool operator()(int a, int b) { return a &amp;lt; b; }
};

int main() {
    Less less;

    std::cout &amp;lt;&amp;lt; predLess(10, 20) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; predLess(20, 10) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; less(10, 20) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; less(20, 10) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; Less()(10, 20) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; Less()(20, 10) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; less.operator()(10, 20) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; Less().operator()(10, 20) &amp;lt;&amp;lt; std::endl;
    
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1
0

1
0
1
0

1
1&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;toc_2&quot;&gt;STL less function object&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;functional&amp;gt;

typedef std::less&amp;lt;int&amp;gt; Less;

int main() {
    Less less;

    std::cout &amp;lt;&amp;lt; less(10, 20) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; less(20, 10) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; Less()(10, 20) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; Less()(20, 10) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; less.operator()(10, 20) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; Less().operator()(10, 20) &amp;lt;&amp;lt; std::endl;

    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1
0

1
0

1
1&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;toc_3&quot;&gt;Implementation of Greater&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;functional&amp;gt;

struct Less {
    bool operator()(int a, int b) { return a &amp;lt; b; }
};

struct Greater {
    bool operator()(int a, int b) { return a &amp;gt; b; }
};

int main() {
    std::cout &amp;lt;&amp;lt; Less()(10, 20) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; Less()(20, 10) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; Greater()(10, 20) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; Greater()(20, 10) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; std::less&amp;lt;int&amp;gt;()(10, 20) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; std::less&amp;lt;int&amp;gt;()(20, 10) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; std::greater&amp;lt;int&amp;gt;()(10, 20) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; std::greater&amp;lt;int&amp;gt;()(20, 10) &amp;lt;&amp;lt; std::endl;

    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1
0
0
1

1
0
0
1&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;toc_4&quot;&gt;Implementation of plus and minus function object&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

struct Plus {
    int operator()(int a, int b) { return a + b; }
};

struct Minus {
    int operator()(int a, int b) { return a - b; }
};

int main() {
    std::cout &amp;lt;&amp;lt; Plus()(10, 20) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; Plus()(20, 10) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; Minus()(10, 20) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; Minus()(20, 10) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; std::plus&amp;lt;int&amp;gt;()(10, 20) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; std::plus&amp;lt;int&amp;gt;()(20, 10) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; std::minus&amp;lt;int&amp;gt;()(10, 20) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; std::minus&amp;lt;int&amp;gt;()(20, 10) &amp;lt;&amp;lt; std::endl;

    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;30
30
-10
10

30
30
-10
10&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/deed.ko&quot; target=&quot;_blank&quot; style=&quot;text-decoration: none&quot;&gt;
	&lt;img id=&quot;ccl-icon-21-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;img id=&quot;ccl-icon-21-1&quot; class=&quot;entry-ccl-nc&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black02.png&quot; alt=&quot;비영리&quot;/&gt;
	&lt;img id=&quot;ccl-icon-21-2&quot; class=&quot;entry-ccl-nd&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black03.png&quot; alt=&quot;변경 금지&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
	&lt;/a&gt;
&lt;/div&gt;
</description>
<category>C++</category>
<author>HIPERCUBE</author>
<guid>http://hipercube.tistory.com/21</guid>
<comments>http://hipercube.tistory.com/entry/C-Function-Object#entry21comment</comments>
<pubDate>Fri, 29 May 2015 08:19:35 +0900</pubDate>
</item>
<item>
<title>[C++] Function Pointer</title>
<link>http://hipercube.tistory.com/entry/C-Function-Pointer</link>
<description>&lt;iframe src=&quot;//www.facebook.com/plugins/follow?href=https%3A%2F%2Fwww.facebook.com%2Fjoowonryoo&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;colorscheme=light&amp;amp;width=450&amp;amp;height=80&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:450px; height:80px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;style type=&quot;text/css&quot;&gt;
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body &gt; *:first-child {
  margin-top: 0 !important; }
body &gt; *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(http://cfile25.uf.tistory.com/image/225F913A56EB248B04568B&quot;toc_0&quot;&gt;&lt;br /&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;;height:auto;max-width:100%&quot;&gt;&lt;a href=&quot;http://hipercube.tistory.com/attachment/cfile5.uf@275A333B55665D8E2E7CD9.pdf&quot;&gt;&lt;img src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/blog/image/extension/pdf.gif&quot; alt=&quot;&quot; style=&quot;vertical-align: middle;&quot; /&gt; Function Pointer.pdf&lt;/a&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h1 id=&quot;toc_0&quot;&gt;Function Pointer&lt;/h1&gt;

&lt;p&gt;Variable is a memory space name for storing the values. Pointer is a memory space name for storing address. And &lt;strong&gt;funciton pointer&lt;/strong&gt; is a pointer for storing function start address.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int main() {
    int n = 10; // integer variable
    int *pn = &amp;amp;n; // pointer variable
    
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Function name is an address of function start, and function pointer is a pointer for storing this function's address.
The function pointer is declared like function signature. For example, function &lt;strong&gt;&lt;em&gt;int func(int a, int b)&lt;/em&gt;&lt;/strong&gt; 's pointer is &lt;strong&gt;&lt;em&gt;int (*pf)(int, int)&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

void print(int n) {
    std::cout &amp;lt;&amp;lt; &quot;integer : &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl;
}

int main() {
    void (*pf)(int);
    pf = print;

    print(10);
    pf(10);
    (*pf)(10);

    std::cout &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; print &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; pf &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; *pf &amp;lt;&amp;lt; std::endl;

    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;integer : 10
integer : 10
integer : 10

00D61276
00D61276
00D61276&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the result, &lt;strong&gt;00D61276&lt;/strong&gt; is start address of function &lt;strong&gt;print()&lt;/strong&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;pf&lt;/strong&gt; == &lt;strong&gt;*pf&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pf()&lt;/strong&gt; == &lt;strong&gt;(*pf)()&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;Type of function pointer&lt;/h2&gt;

&lt;p&gt;In C++, There are &lt;strong&gt;static function&lt;/strong&gt; and &lt;strong&gt;member function&lt;/strong&gt;. The &lt;strong&gt;static function&lt;/strong&gt; has global function, global function in namespace and static member function. The &lt;strong&gt;member function&lt;/strong&gt; can be called by object and address. There are 3 function call methods.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;static function call&lt;/li&gt;
&lt;li&gt;member function call by object&lt;/li&gt;
&lt;li&gt;member function call by address&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

void print() {
    std::cout &amp;lt;&amp;lt; &quot;static function print()&quot; &amp;lt;&amp;lt; std::endl;
}

class Point {
public:
    void print() {
        std::cout &amp;lt;&amp;lt; &quot;member function print()&quot; &amp;lt;&amp;lt; std::endl;
    }
};

int main() {
    Point pt;
    Point *p = &amp;amp;pt;

    print();        // static function call
    pt.print();     // member function call by object
    p-&amp;gt;print();     // member functino call by address

    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static function print()
member function print()
member function print()&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a static function's pointer whose return type is void and parameter is integer.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;void (*pf)(int);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

void print(int n) {
    std::cout &amp;lt;&amp;lt; &quot;global function : &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl;
}

namespace A {
    void print(int n) {
        std::cout &amp;lt;&amp;lt; &quot;namespace A global function : &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl;
    }
}

class Point {
public:
    static void print(int n) {
        std::cout &amp;lt;&amp;lt; &quot;Point class's static member function : &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl;
    }
};

int main() {
    void (*pf)(int);        // static function pointer declare

    print(10);              // call global function without namespace
    A::print(10);           // call namespace A's member function
    Point::print(10);       // call Point class's static member function

    pf = print;
    pf(10);                 // call global function without namespace by function pointer
    pf = A::print;
    pf(10);                 // call namespace A's global function by function pointer
    pf = Point::print;
    pf(10);                 // call Point class's static member function by function pointer
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global function : 10
namespace A global function : 10
Point class's static member function : 10
global function : 10
namespace A global function : 10
Point class's static member function : 10&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;toc_2&quot;&gt;Call member function by object and address&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;by &lt;strong&gt;Object pointer&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;use operator &lt;code&gt;*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;(*Object)(10)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;by &lt;strong&gt;Adress&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;use operator &lt;code&gt;-&amp;gt;*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;(Adress-&amp;gt;*pf)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Point {
    int x, y;
public:
    explicit Point(int _x = 0, int _y = 0) : x(_x), y(_y) { }

    void print() const { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; std::endl; }

    void printInt(int n) { std::cout &amp;lt;&amp;lt; &quot;test integer : &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl; }
};

int main() {
    Point pt(2, 3);
    Point *p = &amp;amp;pt;

    void (Point::*pf1)() const;     // declare member function pointer
    pf1 = &amp;amp;Point::print;

    void (Point::*pf2)(int);     // declare member function pointer
    pf2 = &amp;amp;Point::printInt;

    pt.print();
    pt.printInt(10);
    std::cout &amp;lt;&amp;lt; std::endl;

    (pt.*pf1)();                    // call member function pointer by object
    (pt.*pf2)(10);                    // call member function pointer by object
    std::cout &amp;lt;&amp;lt; std::endl;

    (p-&amp;gt;*pf1)();                    // call member function pointer by address
    (p-&amp;gt;*pf2)(10);                    // call member function pointer by address

    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2,3
test integer : 10

2,3
test integer : 10

2,3
test integer : 10&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;Client code and Server code&lt;/h2&gt;

&lt;p&gt;Code that provides service or function is called &lt;strong&gt;Server code&lt;/strong&gt;.
The code providing the function is called &lt;strong&gt;Client code&lt;/strong&gt;.
Usually, Server code is one, and Client code is several.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

/**
 * Server
 */
void printHello() {
    std::cout &amp;lt;&amp;lt; &quot;Hello&quot; &amp;lt;&amp;lt; std::endl;
}

/**
 * Client
 */
int main() {
    printHello();

    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Usually, Client code calls server and uses the function, but sometimes server have to call client.
That client call server is called '&lt;strong&gt;call&lt;/strong&gt;', and that server call client is called '&lt;strong&gt;callback&lt;/strong&gt;'.
If you use callback mechanism, You can make server more abstrative to make algorithm flexible.
And, Almost of GUI's powerful event functions are implemented by callback mechanism.
STL's many algorithms reflect client by callback.
Windows's all procedures are callback functions called by system.
Code below is callback function example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

void client();

/**
 * Server
 */
void printHello() {
    std::cout &amp;lt;&amp;lt; &quot;Hello&quot; &amp;lt;&amp;lt; std::endl;
    client();
}

/**
 * Client
 */
void client() {
    std::cout &amp;lt;&amp;lt; &quot;this is client&quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    printHello();

    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello
this is client&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;toc_4&quot;&gt;Callback mechanism using function pointer&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

/**
 * Server
 */
void for_each(int *begin, int *end, void(*pf)(int)) {
    while (begin != end) {
        pf(*begin++); // call client function
    }
}

/**
 * Client
 */
void print1(int n) {
    std::cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; ' ';
}

void print2(int n) {
    std::cout &amp;lt;&amp;lt; n * n &amp;lt;&amp;lt; &quot; &quot;;
}

void print3(int n) {
    std::cout &amp;lt;&amp;lt; &quot;integer : &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl;
}

int main() {
    int arr[5] = {10, 20, 30, 40, 50};

    for_each(arr, arr + 5, print1);         // pass print1()'s address to callback
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;

    for_each(arr, arr + 5, print2);         // pass print2()'s address to callback
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;

    for_each(arr, arr + 5, print3);         // pass print3()'s address to callback
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10 20 30 40 50 

100 400 900 1600 2500 

integer : 10
integer : 20
integer : 30
integer : 40
integer : 50&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Code below is made by using STL's for_each algorithm.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;

/**
 * Client
 */
void print1(int n) {
    std::cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; ' ';
}

void print2(int n) {
    std::cout &amp;lt;&amp;lt; n * n &amp;lt;&amp;lt; &quot; &quot;;
}

void print3(int n) {
    std::cout &amp;lt;&amp;lt; &quot;integer : &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl;
}

int main() {
    int arr[5] = {10, 20, 30, 40, 50};   

    std::for_each(arr, arr + 5, print1);         // pass print1()'s address to callback
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;

    std::for_each(arr, arr + 5, print2);         // pass print2()'s address to callback
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;

    std::for_each(arr, arr + 5, print3);         // pass print3()'s address to callback
    std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; std::endl;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10 20 30 40 50 

100 400 900 1600 2500 

integer : 10
integer : 20
integer : 30
integer : 40
integer : 50&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/deed.ko&quot; target=&quot;_blank&quot; style=&quot;text-decoration: none&quot;&gt;
	&lt;img id=&quot;ccl-icon-20-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;img id=&quot;ccl-icon-20-1&quot; class=&quot;entry-ccl-nc&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black02.png&quot; alt=&quot;비영리&quot;/&gt;
	&lt;img id=&quot;ccl-icon-20-2&quot; class=&quot;entry-ccl-nd&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black03.png&quot; alt=&quot;변경 금지&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
	&lt;/a&gt;
&lt;/div&gt;
</description>
<category>C++</category>
<author>HIPERCUBE</author>
<guid>http://hipercube.tistory.com/20</guid>
<comments>http://hipercube.tistory.com/entry/C-Function-Pointer#entry20comment</comments>
<pubDate>Thu, 28 May 2015 09:10:42 +0900</pubDate>
</item>
<item>
<title>[C++] Operator Overloading</title>
<link>http://hipercube.tistory.com/entry/C-Operator-Overloading</link>
<description>&lt;iframe src=&quot;//www.facebook.com/plugins/follow?href=https%3A%2F%2Fwww.facebook.com%2Fjoowonryoo&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;colorscheme=light&amp;amp;width=450&amp;amp;height=80&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:450px; height:80px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;style type=&quot;text/css&quot;&gt;
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body &gt; *:first-child {
  margin-top: 0 !important; }
body &gt; *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(http://cfile8.uf.tistory.com/image/2569C43856EB248B1753FB&quot;toc_0&quot;&gt;&lt;br /&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;;height:auto;max-width:100%&quot;&gt;&lt;a href=&quot;http://hipercube.tistory.com/attachment/cfile2.uf@2732194C556309EB265A25.pdf&quot;&gt;&lt;img src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/blog/image/extension/pdf.gif&quot; alt=&quot;&quot; style=&quot;vertical-align: middle;&quot; /&gt; C   Operator Overloading.pdf&lt;/a&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h1 id=&quot;toc_0&quot;&gt;C++ Operator Overloading&lt;/h1&gt;

&lt;p&gt;It is a syntax which helps user defined type to use operator.
&lt;strong&gt;Primitive Type&lt;/strong&gt; can use operator, because it is defined on compiler.
However, User defined type couldn't because it is not defined on compiler.
If you use &lt;strong&gt;Operator Overlookedading&lt;/strong&gt;, You can use operator which Undefined on compiler and make code more &lt;strong&gt;intuitional&lt;/strong&gt; and &lt;strong&gt;readable&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;Usage&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Point {
    int x;
    int y;
public:
    Point(int _x = 0, int _y = 0) : x(_x), y(_y) { }

    void Print() const { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; ',' &amp;lt;&amp;lt; y &amp;lt;&amp;lt; std::endl; }

    const Point operator+(const Point &amp;amp;arg) const {
        Point pt;
        pt.x = this-&amp;gt;x + arg.x;
        pt.y = this-&amp;gt;y + arg.y;

        return pt;
    }
};

int main() {
    Point p1(2, 3), p2(5, 5);
    Point p3;
I
    p3 = p1 + p2;
    p3.Print();
    
    p3 = p1.operator+(p2);
    p3.Print();

    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;7,8
7,8&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;Unary Operator Overloading&lt;/h2&gt;

&lt;p&gt;Operator Overloading can override &lt;strong&gt;!,&amp;amp;,~,*,+,-,++,--&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;toc_3&quot;&gt;++ Operator Overloading&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Point {
    int x;
    int y;
public:
    Point(int _x = 0, int _y = 0) : x(_x), y(_y) { }

    void print() const { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; ',' &amp;lt;&amp;lt; y &amp;lt;&amp;lt; std::endl; }

    const Point &amp;amp;operator++() {
        ++x;
        ++y;
        return *this;
    }

    const Point operator++(int) {
        Point pt(x, y);
        ++x;
        ++y;
        return pt;
    }
};

int main() {
    Point p1(2, 3), p2(2, 3);
    Point result;

    result = ++p1; // p1.operator++();
    p1.print();
    result.print();

    result = p2++; // p2.operator++(0);
    p2.print();
    result.print();
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3,4
3,4
3,4
2,3&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;toc_4&quot;&gt;-- Operator Overloading&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Point {
    int x;
    int y;
public:
    Point(int _x = 0, int _y = 0) : x(_x), y(_y) { }

    void print() const { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; ',' &amp;lt;&amp;lt; y &amp;lt;&amp;lt; std::endl; }

    const Point &amp;amp;operator--() {
        --x;
        --y;
        return *this;
    }

    const Point operator--(int) {
        Point pt(x, y);
        --x;
        --y;
        return pt;
    }
};

int main() {
    Point p1(2, 3), p2(2, 3);
    Point result;

    result = --p1; // p1.operator--();
    p1.print();
    result.print();

    result = p2--; // p2.operator--(0);
    p2.print();
    result.print();
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1,2
1,2
1,2
2,3&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;toc_5&quot;&gt;== Operator Overloading&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Point {
    int x;
    int y;
public:
    Point(int _x = 0, int _y = 0) : x(_x), y(_y) { }

    void print() const { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; ',' &amp;lt;&amp;lt; y &amp;lt;&amp;lt; std::endl; }

    bool operator==(const Point &amp;amp;arg) const {
        return x == arg.x &amp;amp;&amp;amp; y == arg.y;
    }
};

int main() {
    Point p1(2, 3), p2(5, 5), p3(2, 3);
    if (p1 == p2)
        std::cout &amp;lt;&amp;lt; &quot;p1 ==  p2&quot; &amp;lt;&amp;lt; std::endl;
    if (p1 == p3)
        std::cout &amp;lt;&amp;lt; &quot;p1 == p3&quot; &amp;lt;&amp;lt; std::endl;
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p1 == p3&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;toc_6&quot;&gt;!= Operator overloading&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Point {
    int x;
    int y;
public:
    Point(int _x = 0, int _y = 0) : x(_x), y(_y) { }

    void print() const { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; ',' &amp;lt;&amp;lt; y &amp;lt;&amp;lt; std::endl; }

    bool operator==(const Point &amp;amp;arg) const {
        return x == arg.x &amp;amp;&amp;amp; y == arg.y;
    }

    bool operator!=(const Point &amp;amp;arg) const {
        return !(*this == arg);
    }
};

int main() {
    Point p1(2, 3), p2(5, 5), p3(2, 3);
    if (p1 != p2)
        std::cout &amp;lt;&amp;lt; &quot;p1 !=  p2&quot; &amp;lt;&amp;lt; std::endl;
    if (p1 != p3)
        std::cout &amp;lt;&amp;lt; &quot;p1 != p3&quot; &amp;lt;&amp;lt; std::endl;
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p1 !=  p2&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;toc_7&quot;&gt;Operator Overloading using Global function&lt;/h2&gt;

&lt;p&gt;There are two kinds of &lt;strong&gt;Operator Overloading&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Operator Overloading using member function&lt;/li&gt;
&lt;li&gt;Operator Overloading using global function&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Usally, We use operator overloading using member function.
However, When we can't use operator overloading using member function, we use operator overloading using global function.&lt;/p&gt;

&lt;p&gt;Compiler interprets the code &quot;&lt;strong&gt;p1 == p2&lt;/strong&gt;&quot; as two kinds.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;p1.operator==(p2);&lt;/li&gt;
&lt;li&gt;operator==(p1,p2);&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_8&quot;&gt;Operator Overloading using member function&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Point {
    int x;
    int y;
public:
    Point(int _x = 0, int _y = 0) : x(_x), y(_y) { }

    void print() const { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; ',' &amp;lt;&amp;lt; y &amp;lt;&amp;lt; std::endl; }

    const Point operator-(const Point &amp;amp;arg) const {
        return Point(x - arg.x, y - arg.y);
    }
};

int main() {
    Point p1(2, 3), p2(5, 5);
    Point p3;

    p3 = p1 - p2;
    p3.print();
    
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-3,-2&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;toc_9&quot;&gt;Operator Overloading using global function&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Point {
    int x;
    int y;
public:
    Point(int _x = 0, int _y = 0) : x(_x), y(_y) { }

    void print() const { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; ',' &amp;lt;&amp;lt; y &amp;lt;&amp;lt; std::endl; }

    int getX() const { return x; }

    int getY() const { return y; }
};

const Point operator-(const Point &amp;amp;argL, const Point &amp;amp;argR) {
    return Point(argL.getX() - argR.getX(), argL.getY() - argR.getY());
}

int main() {
    Point p1(2, 3), p2(5, 5);
    Point p3;

    p3 = p1 - p2;
    p3.print();

    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-3,-2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If using global function, use &lt;strong&gt;getter&lt;/strong&gt; or &lt;strong&gt;friend function&lt;/strong&gt; because we can't access private member variable. The code above is &lt;strong&gt;getter&lt;/strong&gt; and below is &lt;strong&gt;friend function&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;friend const Point operator-(const Point &amp;amp;argL, const Point &amp;amp;argR);

const Point operator-(const Point &amp;amp;argL, const Point &amp;amp;argR) {
    return Point(argL.x - argR.x, argL.y - argR.y);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;toc_10&quot;&gt;Function Call Operator Overloading&lt;/h2&gt;

&lt;p&gt;It is operation that makes Object operate like function.
In C++, We can interpret function call &quot;print(10)&quot; as 3 kinds.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;print is &lt;strong&gt;&lt;em&gt;function name&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;print is &lt;strong&gt;&lt;em&gt;function pointer&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;print is &lt;strong&gt;&lt;em&gt;function object&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

struct FuncObject {
public:
    void operator()(int arg) const {
        std::cout &amp;lt;&amp;lt; &quot;integer : &quot; &amp;lt;&amp;lt; arg &amp;lt;&amp;lt; std::endl;
    }
};

void print1(int arg) {
    std::cout &amp;lt;&amp;lt; &quot;integer : &quot; &amp;lt;&amp;lt; arg &amp;lt;&amp;lt; std::endl;
}

int main() {
    void (*print2)(int) = print1;
    FuncObject print3;

    print1(10); // function
    print2(10); // function pointer
    print3(10); // function object
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;integer : 10
integer : 10
integer : 10&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;toc_11&quot;&gt;Function Call Operator Overloading&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

struct FuncObject {
public:
    void operator()(int arg) const {
        std::cout &amp;lt;&amp;lt; &quot;integer : &quot; &amp;lt;&amp;lt; arg &amp;lt;&amp;lt; std::endl;
    }

    void operator()(int arg1, int arg2) const {
        std::cout &amp;lt;&amp;lt; &quot;integer : &quot; &amp;lt;&amp;lt; arg1 &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; arg2 &amp;lt;&amp;lt; std::endl;
    }

    void operator()(int arg1, int arg2, int arg3) const {
        std::cout &amp;lt;&amp;lt; &quot;integer : &quot; &amp;lt;&amp;lt; arg1 &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; arg2 &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; arg3 &amp;lt;&amp;lt; std::endl;
    }
};

void print1(int arg) {
    std::cout &amp;lt;&amp;lt; &quot;integer : &quot; &amp;lt;&amp;lt; arg &amp;lt;&amp;lt; std::endl;
}

int main() {
    FuncObject print;
    print(10);
    print(10, 20);
    print(10, 20, 30);
    std::cout &amp;lt;&amp;lt; std::endl;

    print.operator()(10);
    print.operator()(10, 20);
    print.operator()(10, 20, 30);
    std::cout &amp;lt;&amp;lt; std::endl;

    FuncObject()(10);
    FuncObject()(10, 20);
    FuncObject()(10, 20, 30);
    std::cout &amp;lt;&amp;lt; std::endl;

    FuncObject().operator()(10);
    FuncObject().operator()(10, 20);
    FuncObject().operator()(10, 20, 30);
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;integer : 10
integer : 10,20
integer : 10,20,30

integer : 10
integer : 10,20
integer : 10,20,30

integer : 10
integer : 10,20
integer : 10,20,30

integer : 10
integer : 10,20
integer : 10,20,30&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;toc_12&quot;&gt;Array Index Operator Overloading&lt;/h2&gt;

&lt;p&gt;If you use array index operator overloading, you can use &lt;strong&gt;[]&lt;/strong&gt; operator to object.
&lt;strong&gt;[] operator overloading&lt;/strong&gt; is usually used on objects which save and manage many objects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Point {
    int x, y;
public:
    Point(int _x = 0, int _y = 0) : x(_x), y(_y) { }

    void print() const { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; std::endl; }

    int operator[](int idx) const {
        if (idx == 0)
            return x;
        else if (idx == 1)
            return y;
        else
            throw &quot;exception&quot;;
    }
};

int main() {
    Point pt(1, 2);

    pt.print();

    std::cout &amp;lt;&amp;lt; pt[0] &amp;lt;&amp;lt; &quot;,&quot; // pt.operator[] (0);
    &amp;lt;&amp;lt; pt[1] &amp;lt;&amp;lt; std::endl; //pt.operator[] (1);
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1,2
1,2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;[] operator overloading&lt;/strong&gt; is usally used on container object.&lt;/p&gt;

&lt;h3 id=&quot;toc_13&quot;&gt;Simple Array Class Which saves an Integer&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Array {
    int *arr;
    int size;
    int capacity;
public:
    Array(int cap = 100) : arr(0), size(0), capacity(cap) {
        arr = new int[capacity];
    }

    ~Array() {
        delete[] arr;
    }

    void add(int data) {
        if (size &amp;lt; capacity)
            arr[size++] = data;
    }

    int getSize() const {
        return size;
    }

    int operator[](int idx) const {
        return arr[idx];
    }
};

int main() {
    Array ar(10);

    ar.add(10);
    ar.add(20);
    ar.add(30);

    for (int i = 0; i &amp;lt; ar.getSize(); i++) {
        std::cout &amp;lt;&amp;lt; ar[i] &amp;lt;&amp;lt; std::endl;
    }
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10
20
30&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;toc_14&quot;&gt;[] Operator Overloading which return literal object&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Array {
    int *arr;
    int size;
    int capacity;
public:
    Array(int cap = 100) : arr(0), size(0), capacity(cap) {
        arr = new int[capacity];
    }

    ~Array() {
        delete[] arr;
    }

    void add(int data) {
        if (size &amp;lt; capacity)
            arr[size++] = data;
    }

    int getSize() const {
        return size;
    }

    int operator[](int idx) const {
        return arr[idx];
    }

    int&amp;amp; operator[](int idx) {
        return arr[idx];
    }
};

int main() {
    Array ar(10);
    ar.add(10);
    ar.add(20);
    ar.add(30);

    std::cout &amp;lt;&amp;lt; ar[0] &amp;lt;&amp;lt; std::endl; // ar.operator[] (int)
    std::cout &amp;lt;&amp;lt; std::endl;

    const Array &amp;amp;ar2 = ar;
    std::cout &amp;lt;&amp;lt; ar2[0] &amp;lt;&amp;lt; std::endl; // ar.operator[] (int) const
    std::cout &amp;lt;&amp;lt; std::endl;

    ar[10] = 100;
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10

10&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;toc_15&quot;&gt;Memory access, class member access Operator Overloading(*, -&amp;gt;)&lt;/h2&gt;

&lt;p&gt;Now we'll make a smart pointer class(&lt;strong&gt;PointPtr&lt;/strong&gt;).&lt;/p&gt;

&lt;h3 id=&quot;toc_16&quot;&gt;Point class's General Pointer&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Point {
    int x, y;
public:
    Point(int _x = 0, int _y = 0) : x(_x), y(_y) { }

    void print() const { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; std::endl; }
};

int main() {
    Point *p1 = new Point(2, 3);
    Point *p2 = new Point(5, 5);

    p1-&amp;gt;print();
    p2-&amp;gt;print();

    delete p1;
    delete p2;
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2,3
5,5&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;toc_17&quot;&gt;Smart Pointer Class&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;##include &amp;lt;iostream&amp;gt;

class Point {
    int x, y;
public:
    Point(int _x = 0, int _y = 0) : x(_x), y(_y) { }

    void print() const { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; std::endl; }
};

class PointPtr {
    Point *ptr;
public:
    PointPtr(Point *p) : ptr(p) { }

    ~PointPtr() {
        delete ptr;
    }

    // -&amp;gt; operator overloading
    Point *operator-&amp;gt;() const {
        return ptr;
    }

    // * operator overloading
    Point &amp;amp;operator*() const {
        return *ptr;
    }
};

int main() {
    std::cout &amp;lt;&amp;lt; &quot;--- -&amp;gt; Operator Test ---&quot; &amp;lt;&amp;lt; std::endl;
    PointPtr p1 = new Point(2, 3);
    PointPtr p2 = new Point(5, 5);

    p1-&amp;gt;print();
    p2-&amp;gt;print();


    std::cout &amp;lt;&amp;lt; &quot;--- * Operator Test ---&quot; &amp;lt;&amp;lt; std::endl;
    Point *p3 = new Point(2, 3); //General Pointer
    PointPtr p4 = new Point(5, 5); //Smart Pointer

    p3-&amp;gt;print(); // p3-&amp;gt;print()
    p4-&amp;gt;print(); // p4.operator-&amp;gt;()-&amp;gt;print()
    std::cout &amp;lt;&amp;lt; std::endl;

    (*p3).print(); // (*p3).print()
    (*p4).print(); // p3.operator*().print()

    delete p3;
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--- -&amp;gt; Operator Test ---
2,3
5,5
--- * Operator Test ---
2,3
5,5

2,3
5,5&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;toc_18&quot;&gt;Type casting Operator Overloading&lt;/h2&gt;

&lt;h3 id=&quot;toc_19&quot;&gt;Type casting using Constructor&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class A {

};

class B {
public:
    B() { std::cout &amp;lt;&amp;lt; &quot;B() Constructor&quot; &amp;lt;&amp;lt; std::endl; }

    B(A &amp;amp;_a) { std::cout &amp;lt;&amp;lt; &quot;B(A _a) Constructor&quot; &amp;lt;&amp;lt; std::endl; }

    B(int n) { std::cout &amp;lt;&amp;lt; &quot;B(int n) Constructor&quot; &amp;lt;&amp;lt; std::endl; }

    B(double d) { std::cout &amp;lt;&amp;lt; &quot;B(double d) Constructor&quot; &amp;lt;&amp;lt; std::endl; }
};

int main() {
    A a;
    int n = 10;
    double d = 5.5;

    B b; // B()
    b = a; // b = B(a)
    b = n; // b = B(n)
    b = d; // b = B(d)

    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;B() Constructor
B(A _a) Constructor
B(int n) Constructor
B(double d) Constructor&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Code below is &lt;strong&gt;Point&lt;/strong&gt; class's Constructor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Point {
    int x, y;
public:
    Point(int _x, int _y) : x(_x), y(_y) { }

    Point(int _x) : x(_x), y(0) { }

    Point() : x(0), y(0) { }

    void print() const { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; std::endl; }
};

int main() {
    Point pt;
    pt.print();

    pt = 10;
    pt.print();
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0,0
10,0&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to ban the code &quot;pt = 10&quot;, use &lt;strong&gt;explicit&lt;/strong&gt; keyword.&lt;/p&gt;

&lt;h3 id=&quot;toc_20&quot;&gt;Type casting using Type casting Operator Overloading&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class A {

};

class B {
public:
    operator A() {
        std::cout &amp;lt;&amp;lt; &quot;operator A()&quot; &amp;lt;&amp;lt; std::endl;
        return A();
    }

    operator int() {
        std::cout &amp;lt;&amp;lt; &quot;operator int()&quot; &amp;lt;&amp;lt; std::endl;
        return 10;
    }

    operator double() {
        std::cout &amp;lt;&amp;lt; &quot;operator double()&quot; &amp;lt;&amp;lt; std::endl;
        return 5.5;
    }
};

int main() {
    A a;
    int n;
    double d;

    B b;
    a = b; // b.operator A()
    n = b; // b.operator int()
    d = b; // b.operator double()

    std::cout &amp;lt;&amp;lt; std::endl;
    a = b.operator A();
    n = b.operator int();
    d = b.operator double();

    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;operator A()
operator int()
operator double()

operator A()
operator int()
operator double()&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code below is &lt;strong&gt;Point&lt;/strong&gt; class's type casting operator&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Point {
    int x, y;
public:
    Point(int _x, int _y) : x(_x), y(_y) { }

    void print() const { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &quot;,&quot; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; std::endl; }

    operator int() const { return x; }
};

int main() {
    int n = 10;

    Point pt(2, 3);
    n = pt; // pt.operator int()
    std::cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl;

    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Result&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/deed.ko&quot; target=&quot;_blank&quot; style=&quot;text-decoration: none&quot;&gt;
	&lt;img id=&quot;ccl-icon-19-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;img id=&quot;ccl-icon-19-1&quot; class=&quot;entry-ccl-nc&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black02.png&quot; alt=&quot;비영리&quot;/&gt;
	&lt;img id=&quot;ccl-icon-19-2&quot; class=&quot;entry-ccl-nd&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black03.png&quot; alt=&quot;변경 금지&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
	&lt;/a&gt;
&lt;/div&gt;
</description>
<category>C++</category>
<author>HIPERCUBE</author>
<guid>http://hipercube.tistory.com/19</guid>
<comments>http://hipercube.tistory.com/entry/C-Operator-Overloading#entry19comment</comments>
<pubDate>Mon, 25 May 2015 20:37:36 +0900</pubDate>
</item>
<item>
<title>[LeetCode] Algorithm 153.Find Minimum in Rotated Sorted Array</title>
<link>http://hipercube.tistory.com/entry/LeetCode-Algorithm-153Find-Minimum-in-Rotated-Sorted-Array</link>
<description>&lt;iframe src=&quot;//www.facebook.com/plugins/follow?href=https%3A%2F%2Fwww.facebook.com%2Fjoowonryoo&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;colorscheme=light&amp;amp;width=450&amp;amp;height=80&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:450px; height:80px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;style type=&quot;text/css&quot;&gt;
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body &gt; *:first-child {
  margin-top: 0 !important; }
body &gt; *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(http://cfile8.uf.tistory.com/image/2707593C56EB248B023257&quot;toc_0&quot;&gt;Find Minimum in Rotated Sorted Array&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Suppose a sorted array is rotated at some pivot unknown to you beforehand.&lt;/p&gt;
&lt;p&gt;(i.e., &lt;strong&gt;0 1 2 4 5 6 7&lt;/strong&gt; might become &lt;strong&gt;4 5 6 7 0 1 2&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;Find the minimum element.&lt;/p&gt;
&lt;p&gt;You may assume no duplicate exists in the array.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Form&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int findMin(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
                int count = nums.at(0);
        for(int a:nums){
            if(count&amp;gt;a)count=a;
        }
        return count;
    }
};&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;Solve&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

class Solution {
public:
    int findMin(std::vector&amp;lt;int&amp;gt;&amp;amp; nums){
        int count = nums.at(0);
        for(int a:nums){
            if(count&amp;gt;a)count=a;
        }
        return count;
    }
};&lt;/code&gt;&lt;/pre&gt;&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/deed.ko&quot; target=&quot;_blank&quot; style=&quot;text-decoration: none&quot;&gt;
	&lt;img id=&quot;ccl-icon-18-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;img id=&quot;ccl-icon-18-1&quot; class=&quot;entry-ccl-nc&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black02.png&quot; alt=&quot;비영리&quot;/&gt;
	&lt;img id=&quot;ccl-icon-18-2&quot; class=&quot;entry-ccl-nd&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black03.png&quot; alt=&quot;변경 금지&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
	&lt;/a&gt;
&lt;/div&gt;
</description>
<category>LeetCode</category>
<author>HIPERCUBE</author>
<guid>http://hipercube.tistory.com/18</guid>
<comments>http://hipercube.tistory.com/entry/LeetCode-Algorithm-153Find-Minimum-in-Rotated-Sorted-Array#entry18comment</comments>
<pubDate>Wed, 20 May 2015 08:59:31 +0900</pubDate>
</item>
<item>
<title>[LeetCode] Algorithm 202.Happy Number</title>
<link>http://hipercube.tistory.com/entry/LeetCode-Algorithm-202Happy-Number</link>
<description>&lt;style type=&quot;text/css&quot;&gt;
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body &gt; *:first-child {
  margin-top: 0 !important; }
body &gt; *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(http://cfile4.uf.tistory.com/image/26638F4656EB248A0ADCF2&quot;toc_0&quot;&gt;Happy Number&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Write an algorithm to determine if a number is &quot;happy&quot;.&lt;/p&gt;

&lt;p&gt;A happy number is a number defined by the following process:
Starting with any positive integer, replace the number by the sum of the squares of its digits,
and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle
which does not include 1. Those numbers for which this process ends in 1 are happy numbers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt; 19 is a happy number&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;toc_1&quot;&gt;Form&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    bool isHappy(int n) {    
    }
};&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;Solve&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;map&amp;gt;
#include &amp;lt;set&amp;gt;

class Solution {
public:
    bool isHappy(int number) {
        static std::map&amp;lt;int, bool&amp;gt; cache;
        
        std::set&amp;lt;int&amp;gt; cycle;
        while (number != 1 &amp;amp;&amp;amp; !cycle.count(number)) {
            if (cache.count(number)) {
                number = cache[number] ? 1 : 0;
                break;
            }
            cycle.insert(number);
            int newnumber = 0;
            while (number &amp;gt; 0) {
                int digit = number % 10;
                newnumber += digit * digit;
                number /= 10;
            }
            number = newnumber;
        }
        bool happiness = number == 1;
        for (std::set&amp;lt;int&amp;gt;::const_iterator it = cycle.begin();
             it != cycle.end(); it++)
            cache[*it] = happiness;
        return happiness;
    }
};

int main(int argc, const char * argv[]) {
    Solution sol;
    std::cout&amp;lt;&amp;lt;std::boolalpha;
    std::cout&amp;lt;&amp;lt;sol.isHappy(20);
    return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/deed.ko&quot; target=&quot;_blank&quot; style=&quot;text-decoration: none&quot;&gt;
	&lt;img id=&quot;ccl-icon-17-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;img id=&quot;ccl-icon-17-1&quot; class=&quot;entry-ccl-nc&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black02.png&quot; alt=&quot;비영리&quot;/&gt;
	&lt;img id=&quot;ccl-icon-17-2&quot; class=&quot;entry-ccl-nd&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black03.png&quot; alt=&quot;변경 금지&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
	&lt;/a&gt;
&lt;/div&gt;
</description>
<category>LeetCode</category>
<author>HIPERCUBE</author>
<guid>http://hipercube.tistory.com/17</guid>
<comments>http://hipercube.tistory.com/entry/LeetCode-Algorithm-202Happy-Number#entry17comment</comments>
<pubDate>Tue, 19 May 2015 10:43:44 +0900</pubDate>
</item>
<item>
<title>[LeetCode] Algorithm 189.Rotate Array</title>
<link>http://hipercube.tistory.com/entry/LeetCode-Algorithm-189Rotate-Array</link>
<description>&lt;style type=&quot;text/css&quot;&gt;
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body &gt; *:first-child {
  margin-top: 0 !important; }
body &gt; *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(http://cfile7.uf.tistory.com/image/2258393B56EB248A09813E&quot;toc_0&quot;&gt;Rotate Array&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Roate an array of &lt;strong&gt;&lt;em&gt;n&lt;/em&gt;&lt;/strong&gt; elements to the right by &lt;strong&gt;&lt;em&gt;k&lt;/em&gt;&lt;/strong&gt; steps.
For example, with &lt;strong&gt;&lt;em&gt;n&lt;/em&gt;&lt;/strong&gt; = 7 and &lt;strong&gt;&lt;em&gt;k&lt;/em&gt;&lt;/strong&gt; = 3, the array &lt;code&gt;[1,2,3,4,5,6,7]&lt;/code&gt; is rotated to &lt;code&gt;[5,6,7,1,2,3,4,]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;
Try to come up as many solutions as you can, there are at least 3 differents ways solve this problem.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;Form&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;class Solution{
public:
    void rotate(std::vector&amp;lt;int&amp;gt;&amp;amp; nums, int k){
        
    }
};&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;Solve&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;class Solution{
public:
    void rotate(std::vector&amp;lt;int&amp;gt;&amp;amp; nums, int k){
        k = k%nums.size(); //reduce unless work
        for(int i=0; i&amp;lt;k; i++){
            //insert vector's last element at first
            nums.insert(nums.begin(), nums.back());
            //remove last element
            nums.pop_back();
        }
    }
};

// Test
int main(int argc, const char * argv[]) {
    // make a vector, which rotated.
    std::vector&amp;lt;int&amp;gt; vector;
    for(int i=0; i&amp;lt;7;i++){
        vector.insert(vector.end(), i+1);
    }
    
    Solution solution;
    solution.rotate(vector, 3);
    
    //print results
    for(int i=0; i&amp;lt;vector.size();i++){
        std::cout&amp;lt;&amp;lt;vector.at(i);
    }
    return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/deed.ko&quot; target=&quot;_blank&quot; style=&quot;text-decoration: none&quot;&gt;
	&lt;img id=&quot;ccl-icon-16-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;img id=&quot;ccl-icon-16-1&quot; class=&quot;entry-ccl-nc&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black02.png&quot; alt=&quot;비영리&quot;/&gt;
	&lt;img id=&quot;ccl-icon-16-2&quot; class=&quot;entry-ccl-nd&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black03.png&quot; alt=&quot;변경 금지&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
	&lt;/a&gt;
&lt;/div&gt;
</description>
<category>LeetCode</category>
<author>HIPERCUBE</author>
<guid>http://hipercube.tistory.com/16</guid>
<comments>http://hipercube.tistory.com/entry/LeetCode-Algorithm-189Rotate-Array#entry16comment</comments>
<pubDate>Thu, 14 May 2015 08:37:33 +0900</pubDate>
</item>
<item>
<title>[WinAPI] WinAPI 정리 02.윈도우 띄우기</title>
<link>http://hipercube.tistory.com/entry/WinAPI-WinAPI-%EC%A0%95%EB%A6%AC-02</link>
<description>&lt;pre class=&quot;brush:cpp&quot;&gt;// Windows 헤더파일을 포함시킨다.
// Win32 API 구조체, 형식, 함수 선언이 들어있다.
#include &lt;windows.h&gt;

//main window의 핸들
//생성된 창을 식별하는 용도로 사용
HWND ghMainWnd = 0;

//Windows 응용 프로그램의 초기화에 필요한 코드를 감싼 함수
//초기화에 성공하면 true, 실패하면 false 리턴
bool InitWindowsApp(HINSTANCE hInstance, int show);

//메시지루프 코드를 감싼 함수
int Run();

//응용프로그램 정보를 담은 const 변수
//클래스 이름은 구조체를 채울때 값과 CreateWindow()할때의 넣는 값이 같아야한다.
const LPCWSTR TITLE = L&quot;Basic Window Program&quot;;
const LPCWSTR CLASS_NAME = L&quot;BasicWndClass&quot;;

//main window가 받은 event들을 처리하는 window 프로시저 함수
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

//Windows 응용 프로그램의 진입점.
//console 응용 프로그램의 main()과 비슷
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR pCmdLine, int nShowCmd){
	//응용 프로그램의 초기화를 위해 위에서 선언한 InitWindowsApp()를 호출한다.
	//실패시 종료
	if (!InitWindowsApp(hInstance, nShowCmd))
		return 0;

	//성공적으로 생성, 초기화되면 메시지 루프로 진입
	//메시지 루프는 프로그램 종료를 뜻하는 WM_QUIT를 받을때까지 계속 작동
	return Run();
}

bool InitWindowsApp(HINSTANCE instanceHandle, int show){
	//창을 생성할 때 가장 먼저 WNDCLASS를 채운다.
	//WNDCLASS는 window의 몇몇 속성들을 설정한다.
	WNDCLASS wc;
	wc.style = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc = WndProc;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	wc.hInstance = instanceHandle;
	wc.hIcon = LoadIcon(0, IDI_APPLICATION);
	wc.hCursor = LoadCursor(0, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
	wc.lpszMenuName = 0;
	wc.lpszClassName = FRACTAL_CLASS_NAME;

	//다음으로 WNDCLASS 인스턴스를 Windows 운영체제에 등록한다.
	if (!RegisterClass(&amp;amp;wc)){
		MessageBox(0, L&quot;RegisterClass Failed.&quot;, 0, 0);
		return false;
	}

	//WNDCLASS 인스턴스가 성공적으로 등록되면 CreateWindow함수로 창을 생성
	//CreateWindow함수는 HWND를 return한다.
	//생성이 실패하면 0인 HWND를 return한다.
	//HWND 창의 핸들은 Windows가 내부적으로 관리하는 창을 지칭하는 수단이다.
	ghMainWnd = CreateWindow(
		CLASS_NAME,//window class name 위에서 만든 const변수 넣으면된다.
		TITLE,//window 제목title
		WS_OVERLAPPEDWINDOW,//스타일 플래그들
		CW_USEDEFAULT,//x좌표
		CW_USEDEFAULT,//y좌표
		CW_USEDEFAULT,//너비
		CW_USEDEFAULT,//높이
		0,//부모창
		0,//메뉴 핸들
		instanceHandle,//응용 프로그램 인스턴스
		0);//추가 생성 플래그

	if (ghMainWnd == 0){
		MessageBox(0, L&quot;CreateWindowFailed&quot;, 0, 0);
		return false;
	}

	//마지막으로 창을 표시하고 갱신한다.
	ShowWindow(ghMainWnd, show);
	UpdateWindow(ghMainWnd);

	return true;
}

int Run(){
	MSG msg = { 0 };

	//WM_QUIR 메시지를 받을때까지 루프를 반복한다.
	//GetMessage() 함수는 WM_QUIT메시지를 받은 경우에만 0을 리턴하고 루프 종료
	//GetMessage()는 메시지 수신에서 오류가 있으면 -1을 리턴한다.
	//GetMessage()를 호출하면 메시지가 도달할떄까지 응용프로그램 스레드가 sleep된다.
	BOOL bRet = 1;
	while ((bRet = GetMessage(&amp;amp;msg, 0, 0, 0)) != 0){
		if (bRet == -1){
			MessageBox(0, L&quot;GetMessage Failed&quot;, L&quot;Error&quot;, MB_OK);
			break;
		}
		else{
			TranslateMessage(&amp;amp;msg);
			DispatchMessage(&amp;amp;msg);
		}
	}

	return (int)msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam){
	//몇가지 구체적인 메시지들을 처리한다.
	//여기서 메시지 처리하면 반드시 0반환해야한다.
	switch (msg){
	case WM_LBUTTONDOWN://마우스 좌클릭
		MessageBox(0, L&quot;Hello, World&quot;, L&quot;Hello&quot;, MB_OK);
		return 0;
	//esc키를 누르면 main window 파괴
	case WM_KEYDOWN:
		if (wParam == VK_ESCAPE)
			DestroyWindow(ghMainWnd);
		return 0;
	//파괴메시지가 오면 종료 메시지를 보낸다. -&amp;gt; 메시지 루프 종료
	case WM_DESTROY:
		PostQuitMessage(0);
		return 0;
	}
	return DefWindowProc(hWnd, msg, wParam, lParam);
}
&lt;/pre&gt;&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/deed.ko&quot; target=&quot;_blank&quot; style=&quot;text-decoration: none&quot;&gt;
	&lt;img id=&quot;ccl-icon-15-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;img id=&quot;ccl-icon-15-1&quot; class=&quot;entry-ccl-nc&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black02.png&quot; alt=&quot;비영리&quot;/&gt;
	&lt;img id=&quot;ccl-icon-15-2&quot; class=&quot;entry-ccl-nd&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black03.png&quot; alt=&quot;변경 금지&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
	&lt;/a&gt;
&lt;/div&gt;
</description>
<category>WinAPI</category>
<author>HIPERCUBE</author>
<guid>http://hipercube.tistory.com/15</guid>
<comments>http://hipercube.tistory.com/entry/WinAPI-WinAPI-%EC%A0%95%EB%A6%AC-02#entry15comment</comments>
<pubDate>Thu, 07 May 2015 09:29:01 +0900</pubDate>
</item>
<item>
<title>[WinAPI] WinAPI 정리 01.개요</title>
<link>http://hipercube.tistory.com/entry/WinAPI-WinAPI-%EC%A0%95%EB%A6%AC-01%EA%B0%9C%EC%9A%94</link>
<description>&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;1. WinAPI란?&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&lt;b&gt;WinAPI&lt;/b&gt;는 Windows API로 창(Window)를 만들고 관리하는 것이다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;Windows 응용 프로그램의 여러 구성요소들, 이를테면 응용 프로그램의 주된 창(main window)과 메뉴, 도구모음, 스크롤바, 버튼, 기타 대화상자 컨트롤 등은 모두 창(Window)이다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;따라서 &lt;u&gt;하나의 Windows 응용 프로그램은 일반적으로 여러개의 창으로 구성&lt;/u&gt;된다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;2. 자원&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&lt;u&gt;Windows에서는 Windows 응용 프로그램이 하드웨어에 직접 접근하지 못하고 WinAPI를 통해 접근하도록 한다.&lt;/u&gt;만약 응용 프로그램에서 하드웨어에 직접 접근이 가능하다고 하자. Windows에서는 여러개의 응용 프로그램이 동시에 실행될 수 있다. 이 여러 응용프로그램이 CPU, 메모리 같은 하드웨어 자원들을 각자 직접 제어하게 되면 혼란이 생길것이다. 또한 개발자가 악의적인 목적으로 하드웨어를 제어하게 되면 보안에 문제가 생길수도 있다. 이를 막기위헤 Windows에서는 응용 프로그램이 하드웨어를 직접제어하지 못하고 WinAPI를 통해 제어하도록 한다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;3. 사건, 메시지 대기열, 메시지, 메시지 루프&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;Windows 응용 프로그램은 &lt;b&gt;사건 기반&amp;nbsp;프로그래밍 모형(event-driven programming model)&lt;/b&gt;을 따른다.&lt;b&gt;사건 기반 프로그래밍(event-driven programming)&lt;/b&gt;이란 사건(event)에 따라 제어흐름이 결정되어 일을 하도록 하는 프로그래밍을 말한다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&lt;b&gt;사건(evnet)&lt;/b&gt;는 사용자가 키를 누르거나 마우스를 클릭하면 발생하고 창이 이동하거나, 닫히거나, 최소화되거나, 최대화되거나 화면에 표시되어도 발생한다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;사건이 발생하면 Windows는 그 사건의 대상이 되는 응용 프로그램에게 &lt;b&gt;메시지(message)&lt;/b&gt;를 보낸다. 그 메시지는 응용 프로그램의 &lt;b&gt;메시지 대기열(message queue, 메시지큐라고도 부른다)&lt;/b&gt;에 추가되는데, 메시지 대기열은 해당 응용 프로그램에 전달된 메시지들을 저장하는 하나의 &lt;b&gt;우선순위 대기열(priority queuee)&lt;/b&gt;이다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;응용 프로그램은 &lt;b&gt;메시지루프(message loop)&lt;/b&gt;를 돌리면서 메시지 대기열에 메시지가 새로 도착했는지를 계속 검사한다. 도착한 메시지가 있으면 메시지의 수신 대상인 창의 창 프로시저(window procedure)에 그 메시지를 보낸다.(한 프로그램이 여러개의 창으로 이루어질수 있음을 주의) 이러한 작업을 메시지 &lt;b&gt;배분(dispatch)&lt;/b&gt;라고 한다. 각각의 창에는 창 프로시저라고 부르는 함수가 연관되어 있다. 창 프로시저는 특정 메시지에 반응해서 실행할 코드를 담은 함수로, 개발자가 구현해야한다. 예를 들어 사용자가 Esc키를 누른경우 창을 파괴해야 한다면, 다음과 같은 코드를 윈도우 프로시저에 넣으면 된다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre class=&quot;brush:cpp&quot;&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;case WM_KEYDOWN:
	if (wParam == VK_ESCAPE)
		DestroyWindow(ghMainWnd);
	return 0;
&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;현재 창 프로시저가 직접 처리하지 않을 메시지는 반드시 키본 창 프로시저에 전달해서 그곳에서 처리하게 해야한다. Win32 API는 기본 창 프로시저 역활을 하는 &lt;b&gt;DefWindowProc&lt;/b&gt;이라는 함수를 제공한다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;4. GUI&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;Windows의 GUI는 주 창 하나와 메뉴, 도구 모음으로 구성되며, 그 외 여러 컨트롤(control, GUI 제어 수단)을 갖추기도 한다. 이부분은 나중에 자세히 다루도록 하겠다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;5. 유니코드&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;유니코드는 하나의 문자(character)를 16비트 값으로 표현한다. 이 덕분에 여러 나라의 문자들과 기타 기호들을 포함한 커다란 문자 집합을 표현할 수 있다. C++에서는 유니코드를 사용할때 &lt;b&gt;wchar_t&lt;/b&gt;를 사용한다. 32비트 및 64비트 Windows에서 wchar_t는 16비트이다. 넓은 문자를 사욜할때에는 문자열 리터럴 앞에 반드시 대문자&lt;b&gt; L&lt;/b&gt;을 붙어야 한다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;div class=&quot;txc-textbox&quot; style=&quot;border: 1px dashed rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;const wchar_t* wcstrPtr = L&quot;Hello, World!&quot;;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;접두사 L은 컴파일러에게 이 문자열 리터럴을 넓은 문자(즉 char가 아니라 wchar_t)들로 이루어진 문자열로 취급하라고 알려 주는 역활을 한다. 또한 넓은 문자를 사용할 때에는 그에 맞는 버전의 문자열 함수를 사용해야 한다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;table class=&quot;txc-table&quot; width=&quot;464&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; border=&quot;0&quot; style=&quot;border:none;border-collapse:collapse;;font-family:돋움;font-size:12px&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;width: 154px; height: 24px; border-width: 1px; border-style: solid; border-color: rgb(95, 142, 239) rgb(209, 223, 250) rgb(209, 223, 250) rgb(95, 142, 239); color: rgb(255, 255, 255); background-color: rgb(95, 142, 239);&quot;&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&lt;b&gt;기존&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 154px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(209, 223, 250); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(209, 223, 250); border-top-width: 1px; border-top-style: solid; border-top-color: rgb(95, 142, 239); color: rgb(255, 255, 255); background-color: rgb(95, 142, 239);&quot;&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&lt;b&gt;넓은 문자열&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 154px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(209, 223, 250); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(95, 142, 239); border-top-width: 1px; border-top-style: solid; border-top-color: rgb(95, 142, 239); color: rgb(255, 255, 255); background-color: rgb(95, 142, 239);&quot;&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&lt;b&gt;설명&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 154px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(209, 223, 250); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(209, 223, 250); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(95, 142, 239); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&amp;nbsp;strlen&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 154px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(209, 223, 250); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(209, 223, 250); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&amp;nbsp;wcslen&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 154px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(209, 223, 250); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(95, 142, 239); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&amp;nbsp;문자열 길이 구할때&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 154px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(209, 223, 250); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(209, 223, 250); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(95, 142, 239); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&amp;nbsp;strcpy&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 154px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(209, 223, 250); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(209, 223, 250); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&amp;nbsp;wcscpy&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 154px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(209, 223, 250); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(95, 142, 239); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&amp;nbsp;문자열 복사할때&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 154px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(209, 223, 250); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(209, 223, 250); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(95, 142, 239); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&amp;nbsp;strcmp&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 154px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(209, 223, 250); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(209, 223, 250); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&amp;nbsp;wcscmp&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 154px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(209, 223, 250); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(95, 142, 239); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&amp;nbsp;문자열 비교할때&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 154px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(95, 142, 239); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(209, 223, 250); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(95, 142, 239); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&amp;nbsp;char 포인터&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 154px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(95, 142, 239); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(209, 223, 250); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&amp;nbsp;wchar_t 포인터&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 154px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(95, 142, 239); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(95, 142, 239); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&amp;nbsp;포인터&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;C++표준 라이브러리 역시 넓은 문자를 위해 개별적이 ㄴ문자열 클래스를 제공한다. 바로 std::wstring이다. 또한 Windows API의 헤더 파일 WinNT.h에는 다음과 같은 정의가 있다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;div class=&quot;txc-textbox&quot; style=&quot;border: 1px dashed rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;typedef wchar_t WCHAR;&lt;/span&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&lt;/span&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&amp;nbsp; &amp;nbsp; //wc, 16bit UNICODE character&lt;/span&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/deed.ko&quot; target=&quot;_blank&quot; style=&quot;text-decoration: none&quot;&gt;
	&lt;img id=&quot;ccl-icon-14-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;img id=&quot;ccl-icon-14-1&quot; class=&quot;entry-ccl-nc&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black02.png&quot; alt=&quot;비영리&quot;/&gt;
	&lt;img id=&quot;ccl-icon-14-2&quot; class=&quot;entry-ccl-nd&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black03.png&quot; alt=&quot;변경 금지&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
	&lt;/a&gt;
&lt;/div&gt;
</description>
<category>WinAPI</category>
<author>HIPERCUBE</author>
<guid>http://hipercube.tistory.com/14</guid>
<comments>http://hipercube.tistory.com/entry/WinAPI-WinAPI-%EC%A0%95%EB%A6%AC-01%EA%B0%9C%EC%9A%94#entry14comment</comments>
<pubDate>Wed, 06 May 2015 02:01:06 +0900</pubDate>
</item>
</channel>
</rss>