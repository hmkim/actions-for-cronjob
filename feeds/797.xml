<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Dongmin Jang on Medium]]></title>
        <description><![CDATA[Stories by Dongmin Jang on Medium]]></description>
        <link>https://medium.com/@Dongmin_Jang?source=rss-348041857347------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*RBfR8MoT_zPwbzfWAGb0gw.jpeg</url>
            <title>Stories by Dongmin Jang on Medium</title>
            <link>https://medium.com/@Dongmin_Jang?source=rss-348041857347------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Sun, 12 May 2019 10:07:15 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@Dongmin_Jang" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[you could type code in frontend side and push to ‘github’ again.]]></title>
            <link>https://medium.com/@Dongmin_Jang/you-could-type-code-in-frontend-side-and-push-to-github-again-71a5c59b774b?source=rss-348041857347------2</link>
            <guid isPermaLink="false">https://medium.com/p/71a5c59b774b</guid>
            <dc:creator><![CDATA[Dongmin Jang]]></dc:creator>
            <pubDate>Mon, 06 May 2019 21:38:06 GMT</pubDate>
            <atom:updated>2019-05-06T21:38:06.842Z</atom:updated>
            <content:encoded><![CDATA[<p>you could type code in frontend side and push to ‘github’ again. then It will be updated automatically.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=71a5c59b774b" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[댓글 감사합니다.]]></title>
            <link>https://medium.com/@Dongmin_Jang/%EB%8C%93%EA%B8%80-%EA%B0%90%EC%82%AC%ED%95%A9%EB%8B%88%EB%8B%A4-950bc0db51d6?source=rss-348041857347------2</link>
            <guid isPermaLink="false">https://medium.com/p/950bc0db51d6</guid>
            <dc:creator><![CDATA[Dongmin Jang]]></dc:creator>
            <pubDate>Tue, 26 Mar 2019 11:22:53 GMT</pubDate>
            <atom:updated>2019-03-26T11:22:53.086Z</atom:updated>
            <content:encoded><![CDATA[<p>댓글 감사합니다.</p><p>저는 vs code 를 이용하고 있습니다.</p><p>아직까지는 에러로 표시 된 적은 없었습니다. 특별한 extention을 사용하고 있지는 않습니다. 혹시 에러 메세지 알려주시면 저도 찾아보겠습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=950bc0db51d6" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Javascript] 에러 처리 방법]]></title>
            <link>https://medium.com/@Dongmin_Jang/javascript-%EC%97%90%EB%9F%AC-%EC%B2%98%EB%A6%AC-%EB%B0%A9%EB%B2%95-e6cecca61974?source=rss-348041857347------2</link>
            <guid isPermaLink="false">https://medium.com/p/e6cecca61974</guid>
            <category><![CDATA[error-handling]]></category>
            <category><![CDATA[nodejs]]></category>
            <category><![CDATA[react]]></category>
            <category><![CDATA[error]]></category>
            <category><![CDATA[javascript]]></category>
            <dc:creator><![CDATA[Dongmin Jang]]></dc:creator>
            <pubDate>Sun, 10 Mar 2019 15:30:12 GMT</pubDate>
            <atom:updated>2019-03-10T15:30:12.759Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*iyVaXKUljFNJCM37UXT99g.jpeg" /><figcaption>내용과 무관합니다</figcaption></figure><p>아래 글에 대한 번역 및 정리 글입니다.</p><p><a href="https://github.com/gisderdube/graceful-error-handling">code</a> 는 링크 참조하세요.</p><p><strong><em>(솔직히 원문이 왜 이렇게 많은 관심을 받는 글인지 모르겠습니다. )</em></strong></p><p><a href="https://levelup.gitconnected.com/the-definite-guide-to-handling-errors-gracefully-in-javascript-58424d9c60e6">Handling Errors in JavaScript: The Definitive Guide</a></p><h3>I. JavaScript Errors and generic handling</h3><p>throw new Error(‘something went wrong’)</p><p>위와 같은 코드는 에러 인스턴스를 생성하고, 에러 처리를 하지 않으면 스크립트 실행을 멈춥니다. 자바스크립트 개발자로 커리어를 시작할 때, 당신은 아마도 직접 이를 처리하지 않을 것입니다. 대신에 다른 라이브러리를 통해 보게 될 것입니다.</p><p>e.g. `ReferenceError: fs is not defined`</p><h4>The Error Object</h4><p>Error object 에는 우리가 사용할 두가지 properties 가 들어있습니다. 그 중 하나는 message 입니다. 이것은 우리가 argument 로 Error 에 전달한 값 입니다.<br>아래와 같이 작성 된 코드에서 ‘please improve your code’ 에 접근 하려면, message 값을 보면 됩니다.</p><pre>const myError = new Error(‘please improve your code’)</pre><pre>console.log(myError.message) // please improve your code</pre><p>두번째는 Error stack trace 인데, 아주 중요한 요소 입니다. stack property 를 통해 접근 할 수 있습니다. error stack 은 에러를 일으킨 파일에 대한 history 를 전달해 줍니다. 또한 stack 은 메세지를 갖고 있으며, 이는 실제 stack 에서 문제가 되는 부분으로 유도하는 역할을 합니다.</p><pre>Error: please improve your code<br> at Object.&lt;anonymous&gt; (/Users/gisderdube/Documents/_projects/hacking.nosync/error-handling/src/general.js:1:79)<br> at Module._compile (internal/modules/cjs/loader.js:689:30)<br> at Object.Module._extensions..js (internal/modules/cjs/loader.js:700:10)<br> at Module.load (internal/modules/cjs/loader.js:599:32)<br> at tryModuleLoad (internal/modules/cjs/loader.js:538:12)<br> at Function.Module._load (internal/modules/cjs/loader.js:530:3)<br> at Function.Module.runMain (internal/modules/cjs/loader.js:742:12)<br> at startup (internal/bootstrap/node.js:266:19)<br> at bootstrapNodeJSCore (internal/bootstrap/node.js:596:3)</pre><h4>Throwing and Handling Errors</h4><p>이제 에러 인스턴스는 홀로 무엇인가를 발생시키지 않을 겁니다.</p><p>e.g. new Error(‘…’) ← 어느 것도 하지 않을 것입니다.</p><p>에러가 throw 와 함께 있을 때는 더 흥미로워집니다. 그땐, 전에 말한 바와 같이(원글 참조) 당신이 무엇인가를 처리하는 코드를 넣지 않는 한, 스크립트 코드는 실행을 멈출 것입니다. 잊지마세요. 당신이 Error 를 직접 throw 했다거나, 라이브러리에 의해 throw 되었거나, 런타임 시정에 스스로 생성 되었든(node or the browser)이는 중요하지 않습니다. 몇가지 시나리오에서 이러한 에러를 어떻게 다루는지 함께 보도록 합니다.</p><h4>try …. catch</h4><p>아주 간단한 예제입니다만, 종종 에러를 다루는 방법을 잊곤 합니다. async/await 때문에이는 요즘 다시 많이 사용되는 코드입니다.<br>이는 여러 종류의 에러를 잡을 때 사용되곤 합니다.</p><pre>const a = 5</pre><pre>try {<br>    console.log(b) // b is not defined, so throws an error<br>} catch (err) {<br>    console.error(err) // will log the error with the error stack<br>}</pre><pre>console.log(a) // still gets executed</pre><p>try, catch 블록으로 console.log(b) 를 감싸지 않으면, 스크립트 실행은 멈추게 됩니다.</p><h4>… finally</h4><p>때로는 에러 유무와 상관 없이 실행시키고 싶은 코드가 있을 것입니다. 그럴 때는 finally를 사용하면 됩니다. try…catch 뒤에 코드가 있는 듯하지만, 이게 아주 유용할 때가 있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/48e92546d93c577c159ef1a4dcce3061/href">https://medium.com/media/48e92546d93c577c159ef1a4dcce3061/href</a></iframe><h4>Enter asynchronity — Callbacks (비동기 콜백 함수)</h4><p>비동기, 자바스크립트로 개발하시는 분이라면 항상 고려하는 부분입니다.<br>비동기 함수가 있을 때, 그 함수안에서 에러가 발생한다해도 스크립트 코드는 계속 실행되고 있을 것입니다. 그래서 에러가 즉각적으로 나오지 않을 것입니다. 콜백함수로 에러를 핸들링 할 때( 추천하지 않아요 ), 아래 보는 바와 같이 콜백 함수로 2가지 parameters를 받을 것입니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5d2e328f1c317362103859dbfb6e5f87/href">https://medium.com/media/5d2e328f1c317362103859dbfb6e5f87/href</a></iframe><p>에러가 발생하면, err parameter 는 Error 와 동일해집니다. 만약 그렇지 않다면, parameter 는 `undefined` or `null`가 될 것입니다. if(err)에서 return 이 될지, else 에서 다른 작업을 처리할지는 중요합니다. 이에 따라 Error 가 추가로 발생할 수 있습니다. result가 undefined 이거나, 또는 result.data값을 쓰려는 상황 등에서 발생할 수 있습니다.</p><h4>Asynchronity — Promises</h4><p>비동기로 좀 더 나은 처리를 하는 방법은 promise를 사용하는 것입니다. 여기에 개선된 에러 핸들링과 함께 코드를 좀 더 남기겠습니다. catch 블럭을 사용하는 한, 우리는 더이상 정확한 Error 를 잡아내는데 집중할 필요가 없습니다. promise chaining 을 하게 되면, catch 블럭은 promise 실행과 마지막 catch 블럭 덕분에 모든 에러를 잡아낼 수 있게 됩니다. catch블럭이 없는 promise 는 스크립트를 종료시키지 않을 것이지만, 가독성 떨어지는 메세지를 던져줄 것입니다.</p><pre><em>(node:7741) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: something went wrong<br>(node:7741) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code. */</em></pre><p>그러므로 항상 catch블럭을 promise 에 넣어주세요. 아래를 보시죠.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/201e9e186c53a54e421d1f9e6fee3b91/href">https://medium.com/media/201e9e186c53a54e421d1f9e6fee3b91/href</a></iframe><h4>try … catch — again</h4><p>자바스크립트에서의 async/await 소개하면서 try…catch…finally를 이용해서 에러를 핸들링 하는 원래의 방법으로 돌아왔습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9cc5888e48cbb4a20c70a683c8091280/href">https://medium.com/media/9cc5888e48cbb4a20c70a683c8091280/href</a></iframe><p>동기 오류를 처리하는 일반적인 방법과 비슷하기에, 만약 원한다면 더 넓은 catch 구문을 사용하는 것이 처리하는데 더 쉽습니다.</p><h3>II. Generating and handling Errors in the Server</h3><p>이제 에러를 처리할 수 있는 툴이 생겼으므로, 실제 환경에서 이 툴을 가지고 무엇을 할수 있는지 봅니다. 백엔드에서 에러를 생성하고 그것들을 정상적으로 처리하는 것은 앱에서 중요한 부분입니다. 에러를 어떻게 다루느냐에 따라서 다른 몇가지 접근법들이 있습니다. 커스텀 에러 생성자와 프론트엔드( 또는 다른 api 사용자)로 쉽게 전달 할 수 있는 코드들을 가지고 접근하는 방법을 보여드리겠습니다. 백엔드를 어떻게 상세히 설계하는지는 중요하지 않습니다.</p><p>Express.js를 framework 로 사용할 것입니다. 가장 효율적인 에러 처리를 할 수 있는 구조에 대해서 생각해 봅시다.</p><p>1.포괄적인 에러 처리, 몇가지 종류의 fallback, 이런 것들은 보통 이렇게 얘기합니다. ‘ 무엇인가 잘못 되었습니다. 다시 시도 하시거나 연락주세요.’ 이것은 좋은 방법이 아닙니다. 그러나 유저에게 무한 로딩 대신에 최소한의 알림은 전달 합니다.</p><p>2. 무엇이 문제인지, 어떻게 고칠 수 있는지에 대해서 구체적인 정보를 유저에게 전달하기 위해 특정한 에러 처리 방법</p><h4>Building a custom Error constructor</h4><p>기본적인 Error 생성자를 사용할 것이고, 이것을 확장 할 것입니다. 자바스크립트에서의 상속은 위험을 띄고 있습니다만, 이런 상황에서는 아주 유용할 것입니다. 왜 그런걸까요? 우리는 디버깅을 위해서 stack trace 가 필요합니다. native 자바스크립트 에러 생성자를 확장하면 이를 그냥 가져다 쓸 수 있습니다. 우리가 유일하게 해야 할 것은 나중에 err.code 로 접근할 수 있는 code와 프론트엔드에 전달할 http status 를 작성하는 것입니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/7592a3bdc39d728450bf156777571353/href">https://medium.com/media/7592a3bdc39d728450bf156777571353/href</a></iframe><h4>How to handle routing</h4><p>커스텀 에러 사용준비와 함께 라우팅 구조를 셋팅해야 합니다.</p><p>얘기했듯이, 모든 라우트에서 동일하게 에러 핸들링을 할 수 있는 단일 포인트가 필요합니다. 일반적으로 express 는 라우트들이 캡슐화 되어있어 지원하지 않습니다.</p><p>이러한 이슈를 처리하기 위해, 라우트 핸들러와 기본적인 기능을 처리할 실제 로직을 구현할 수 있습니다. 이 때, 라우트 함수는 error 를 던질 것입니다. 그리고 프론트엔드로 전달되도록 라우트 함수에게 return 할 것입니다. 백엔드에서 에러가 날 때마다 우리는 프론트엔드에 response 가 전달 되기를 원합니다. (아래 json api 포함해서)</p><pre>{<br>    error: &#39;SOME_ERROR_CODE&#39;,<br>    description: &#39;Something bad happened. Please try again or     contact support.&#39;<br>}</pre><p>압도할 수 있도록 준비하세요. 제 학생은 제가 말 할때 저(글쓴이)에게 화를 냅니다.</p><blockquote>처음부터 모든 것을 알지 못해도 괜찮아요. 우선 사용하고 그 다음에 왜 되는 것인지 찾아보세요.</blockquote><p>이를 top-down 학습법이라 부르는데, 내가 상당히 좋아한다.(글쓴이)</p><p>아래가 당신이 스스로 확인해야 하는 라우트 핸들러이다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/270cc91dd7c875d4d953f7ccbf6e04e6/href">https://medium.com/media/270cc91dd7c875d4d953f7ccbf6e04e6/href</a></iframe><p>코드속에 주석을 읽을 수 있기를 바랍니다. 그게 아마 여기에 구구절절 설명하는 것보다 훨씬 나을 것입니다. 이제 실제 라우트 파일이 어떻게 보이는지 확인하겠습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/4e63bde124dc39338e170c343a4b6704/href">https://medium.com/media/4e63bde124dc39338e170c343a4b6704/href</a></iframe><p>이 예제에서 실제 request 에 아무것도 하지 않았습니다. 다른 에러 시나리오를 가짜로 만들고 있습니다. 예를 들면, GET /city 는 3번째 줄에서, POST /city 는 8째줄에서 끝납니다. 이것 또한 쿼리 params 와 함께 작동합니다. 예를 들면 GET /city?startsWith=R. 프론트엔드가 전달 받을 에러를 처리하지 않는 다거나, 커스텀 error 를 수동으로 전달하지 않을 것입니다.</p><pre>{<br>    error: &#39;GENERIC&#39;,<br>    description: &#39;Something went wrong. Please try again or contact support.&#39;<br>}</pre><pre>throw new CustomError(&#39;MY_CODE&#39;, 400, &#39;Error description&#39;)</pre><p>위는 아래와 같이 바뀔것입니다.</p><pre>{<br>    error: &#39;MY_CODE&#39;,<br>    description: &#39;Error description&#39;<br>}</pre><p>이제 우리는 프론트엔드에 부족한 에러 로그를 전달하는게 아닌, 언제나 무엇이 문제인지 유용한 정보를 전달하는 훌륭한 백엔드를 셋업하게 되었습니다.</p><p>전체 코드를 보고 싶다면 아래 링크로 가세요. 언제나 수정해서 사용하셔도 괜찮습니다.</p><h3>III. Displaying Errors to the User</h3><p>이제 마지막은 프론트엔드에서 error 를 처리하는 것입니다. 첫 과정에서 만들었던 툴과 함께 프론트엔드에서 만들어낸 에러를 처리할 것입니다. 그리고 백엔드로 부터 온 에러는 노출 되어야 합니다. 먼저 어떻게 에러를 노출할지 봅시다. 우리는 react 를 사용할 것입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*nidY6HBfwDaiYn_suN7P-w.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/photos/wi-vfhwCDAg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Andersen Jensen</a> on <a href="https://unsplash.com/search/photos/stop-sign?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><h4>Saving Errors in React state</h4><p>다른 데이터처럼 Error와 Error 메세지는 바뀔 수 있습니다. 그러므로 컴포넌트의 state 에 넣어둬야 합니다. 기본적으로 마운팅이 되면, error 를 리셋하려 할 것입니다. 그래야 유저가 처음 페이지를 볼 때, 에러가 보이지 않을 것입니다.</p><p>다음으로 우리가 명확히 해야 할 것은 각기 다른 타입의 에러들을 화면의 표현과 매칭 시키는 것입니다. 백엔드에는 3가지 타입이 있습니다.</p><ol><li>글로벌 에러, e.g. 백엔드로부터 오는 포괄적인 에러들 중 하나, 유저가 sign in 을 안했다거나..</li><li>백엔드로 부터 오는 특정 에러, e.g. 유저가 sign-in 정보를 백엔드에 넘겼는데, 백엔드가 패스워드가 틀렸다고 응답. 이는 프론트가 확인할 수 없으니, 백엔드로 부터 확인 되야함.</li><li>프론트엔드 스스로가 생성하는 에러, e.g. email 형식 틀림.</li></ol><p>2, 3 은 비슷하기도 하고, 같은 state로 처리할 수도 있습니다. 그러나 그 원인은 다릅니다. 다음에서 코드를 통해서 처리해 나가겠습니다.</p><p>React의 native state 를 이용할 것입니다. Mobx 나 Redux 를 사용해도 무방합니다.</p><h4>Global Errors</h4><p>보통 이러한 Error 는 가장 밖에 있는 stateful 컴포넌트에 저장합니다. 그리고 static UI Element 를 이용해서 렌더합니다. 아래 상단의 빨간 배너 처럼 디자인 구현은 당신 몫입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1002/1*xSpVDWEQ4wMHQ5kObFwf8w.jpeg" /><figcaption>Sample UI Element for global Errors</figcaption></figure><p>코드를 확인해 보겠습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/33daeedf9e945cfe356eed7d581008d3/href">https://medium.com/media/33daeedf9e945cfe356eed7d581008d3/href</a></iframe><p>보시다시피, Application.js 안에 Error 가 state 에 담겨 있습니다. 또한 error 를 리셋하거나 바꿀 수 있는 methods 도 가지고 있습니다. 우리는 error 와 리셋 method 를 GlobalError 컴포넌트로 넘겨줄 것입니다. GlobalError 컴포넌트는 메세지를 노출 시킬 것이고, x 버튼을 누르면 error 값을 리셋 시킬 것입니다. 다음 코드를 통해 GlobalError 컴포넌트를 확인해봅시다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/76c4aaa5204af4965736d891106ca9ed/href">https://medium.com/media/76c4aaa5204af4965736d891106ca9ed/href</a></iframe><p>5번째 줄을 보면, Error 가 없다면 아무런 값을 노출시키지 않을 것입니다. 이는 빈 빨간 박스가 화면에 항상 떠 있는 것을 막아줍니다. 예제를 수정해서 x 를 누르면 몇초 뒤에 error 값이 초기화 되도록 할 수 있습니다.</p><p>이제 Applications.js 로부터 _setError 를 건내 줌으로써, 당신이 원하는 아무 때나 global error state 를 사용할 수 있습니다. 그리고 global Error 를 설정할 수 있습니다. 예를 들면, 백엔드로 부터 error: ‘GENERIC’ 으로 응답이 올 경우 입니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/3b3528f7a53255a586cc17861a499d88/href">https://medium.com/media/3b3528f7a53255a586cc17861a499d88/href</a></iframe><p>만약 못마땅하다면 여기서 멈추세요. 이미 에러가 발생된다면, global error state 를 수정하고, 페이지 상단에 에러 박스를 띄울 수 있습니다. 계속해서 특정 에러를 어떻게 처리하고 노출할지에 대해서 이어질 것입니다. 왜냐구요? 먼저, 이 글은 에러를 어떻게 다루는지에 대한 글이기 때문입니다. 그래서 여기서 멈출 수가 없습니다. 그리고 UX 유저들은 모든 에러를 globally 하게 노출할지에 대해서 꽤 고민을 많이 할것입니다. … (번역 맞아?)</p><h4>Handling specific request Errors</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*bnNmuxkwSUD4JWvjw5Omng.jpeg" /></figure><p>global error 와 비슷하게 다른 컴포넌트 안에서 local error state 를 가질 수 있습니다. 다음과 같습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/dab9dd0ade0cef4a3aca6dc58b857735/href">https://medium.com/media/dab9dd0ade0cef4a3aca6dc58b857735/href</a></iframe><p>한가지 기억할 것은 error 들은 대게 다른 작업을 유발 시킨다는 것입니다. 에러를 삭제하기 위해서 ‘x’ 를 만드는 것은 상황에 맞지 않을 수 있습니다. 새로운 요청이 있을 때, error 를 지우는 것이 더 맞을 수도 있습니다. 또는 유저가 새로운 변화를 만들어 낼 때, error 를 삭제 할 수 있습니다. e.g. 입력 정보가 바뀔 때.</p><h4>Frontend origin errors</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*tpmtTom2eSmH7AnrAI55QQ.jpeg" /></figure><p>앞에서 언급했듯이, 이러한 에러들은 백엔드로부터 전달된 특정 에러들 처럼 같은 방법으로 처리 될 수 있습니다. 이번에는 input 이 한개인 예제를 이용해 봅시다. 그리고 유저는 도시를 지울 수 있습니다. 단, 입력이 허용된 도시를 입력했을 때만 입니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/cbcfebb816b356971f9a5ee67a2e3908/href">https://medium.com/media/cbcfebb816b356971f9a5ee67a2e3908/href</a></iframe><h4>Error internationalisation using the Error code</h4><p>아마도 error codes 를 사용하는 것에 대해서 궁금해 할 수 있습니다. e.g. GENERIC 우리는 단순히 백엔드로부터 전달된 에러 메세지를 노출 하였습니다. 당신의 앱이 확대 된다면, 새로운 국가로 확장하기를 희망 할 것이고, 다양한 언어들을 지원하게 되면서 몇가지 문제를 직면하게 될것입니다. 그 시점에 error code를 사용함으로써 유저의 언어에 맞게 올바른 설명을 노출 할 수 있습니다.</p><p>I hope you gained some insight as to how to deal with Errors. Quickly typed and just as quickly forgotten console.error(err) should be a thing of the past now. It is essential to use that for debugging, but it should not end up in your production build. To prevent that, I would recommend you use a logging library, I have been using <a href="https://www.npmjs.com/package/loglevel">loglevel</a> in the past and I am pretty happy with it.</p><p><em>About the Author: Lukas Gisder-Dubé co-founded and led a startup as CTO for 1 1/2 years, building the tech team and architecture. After leaving the startup, he taught coding as Lead Instructor at </em><a href="https://medium.com/u/1ff093a3da32"><em>Ironhack</em></a><em> and is now building a Startup Agency &amp; Consultancy in Berlin. Check out </em><a href="https://dube.io"><em>dube.io</em></a><em> to learn more.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e6cecca61974" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Javascript] array 중복 제거하는 방법(ES6)]]></title>
            <link>https://medium.com/@Dongmin_Jang/javascript-array-%EC%A4%91%EB%B3%B5-%EC%A0%9C%EA%B1%B0%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-es6-b5b9075361f9?source=rss-348041857347------2</link>
            <guid isPermaLink="false">https://medium.com/p/b5b9075361f9</guid>
            <category><![CDATA[set]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[arrays]]></category>
            <category><![CDATA[filters]]></category>
            <category><![CDATA[reduce]]></category>
            <dc:creator><![CDATA[Dongmin Jang]]></dc:creator>
            <pubDate>Thu, 21 Feb 2019 16:29:39 GMT</pubDate>
            <atom:updated>2019-02-22T04:35:07.413Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*_xHcYvAeg_HssKheCr469w.jpeg" /></figure><p>아래글에 대한 번역 &amp; 일부 내용 발췌한 글입니다.</p><p><a href="https://medium.com/dailyjs/how-to-remove-array-duplicates-in-es6-5daa8789641c">How to Remove Array Duplicates in ES6</a></p><pre>const array = [&#39;a&#39; , 1, 2, &#39;a&#39; , &#39;a&#39;, 3];</pre><pre><br>// 1: &#39;Set&#39;</pre><pre>[...new Set(array)];</pre><pre>// 2: &#39;Filter&#39;</pre><pre>array.filter((item, index) =&gt; array.indexOf(item) === index);</pre><pre>// 3: &#39;Reduce&#39;</pre><pre>array.reduce((unique, item) =&gt;</pre><pre>  unique.includes(item) ? unique : [...unique, item], []);</pre><pre>// RESULT:</pre><pre>// [&#39;a&#39;, 1, 2, 3]</pre><ol><li>Set</li></ol><blockquote>Set 은 ES6 에서 등장한 새로운 data object 입니다. Set 은 unique 값만 저장할 수 있도록 하기 때문에 array에 넣게 되면, 중복되는 값이 사라집니다.</blockquote><p>… spread operator 에 대해서는 다른 설명 하지 않겠습니다.</p><p>또한 array 에 Set 을 이용하는 것 대신에 Array.from 도 가능합니다.</p><pre>const array = [&#39;0&#39;, 1, 2, &#39;0&#39;, &#39;0&#39;, 3]<br>Array.from(new Set(array));</pre><pre>// [&#39;0&#39;, 1, 2, 3]</pre><p>2. Filter</p><p>이 방법을 이해하기 위해서는 fileter 와 indexOf 메소드를 이해해야 합니다.</p><p>indexOf 는 array 안에서 값을 제일 먼저 찾은 위치입니다.</p><p>filter는 array 내의 각 element 에 조건을 주어, true 값을 return 한 element 만 모아서 새로운 array 를 만드는 것입니다.</p><p>반대로 중복값만 가져올 수도 있습니다.</p><pre>const array = [&#39;0&#39;, 1, 2, &#39;0&#39;, &#39;0&#39;, 3]<br>array.filter(item, index) =&gt; array.indexOf(item) !== index);<br>// [&#39;0&#39;, &#39;0&#39;]</pre><p>3. Reduce</p><p>reduce 메소드는 array 의 각 요소를 줄여주는데 사용됩니다. 그리고 그것들을 모아 최종 array 로 결합해주는데 이 때 전달 된 reduce 함수가 사용됩니다.</p><p>이 경우에, 넘겨준 reducer 함수는 최종 array에 값이 있는지 확인합니다. 포함 되어있지 않으면 최종 array 로 푸시하고, 아니면 건너 뛰고 return 합니다.</p><p>Reduce 는 항상 이해하기가 좀 난해한데, 아래 코드와 함께 결과를 확인해 봅시다.</p><pre>const array = [&#39;0&#39;, 1, 2, &#39;0&#39;, &#39;0&#39;, 3];<br>array.reduce((unique, item) =&gt; {<br>  console.log(<br>    // a. Item<br>    item,<br>    // b. Final Array (Accumulator)<br>    unique,<br>    // c. 조건(이 조건이 false여야만 값이 푸시된다<br>    unique.includes(item),<br>    // d. Reduce Function Result<br>    unique.includes(item) ? unique : [...unique, item],<br>  );</pre><pre>  return unique.includes(item) ? unique : [...unique, item]<br>}, []); // 초기 Accumulator 는 빈 array 이다</pre><p>item | Accumulator | push to accumulator | accumulator</p><p>‘0’___[]___________yes______[‘0’]</p><p>1___[‘0’]_________yes______[‘0’, 1]</p><p>2___[‘0’, 1]_______yes______[‘0’, 1, 2]</p><p>‘0’___[‘0’, 1]_______no______[‘0’, 1, 2]</p><p>‘0’___[‘0’, 1]_______no______[‘0’, 1, 2]</p><p>3___[‘0’, 1, 2]_____yes______[‘0’, 1, 2, 3]</p><p>추가로 다른 블로거가 퍼포먼스와 관련해서 내용을 <a href="https://blog.usejournal.com/performance-of-javascript-array-ops-2690aed47a50">정리</a>한게 있어 수치만 가져와봤습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/906/1*WERa9D7IIdUBdoe4UksH0Q.png" /><figcaption>출처: <a href="https://blog.usejournal.com/performance-of-javascript-array-ops-2690aed47a50">https://medium.com/r/?url=https%3A%2F%2Fblog.usejournal.com%2Fperformance-of-javascript-array-ops-2690aed47a50</a></figcaption></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b5b9075361f9" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Thanks for article.]]></title>
            <link>https://medium.com/@Dongmin_Jang/thanks-for-article-593a90af0d22?source=rss-348041857347------2</link>
            <guid isPermaLink="false">https://medium.com/p/593a90af0d22</guid>
            <dc:creator><![CDATA[Dongmin Jang]]></dc:creator>
            <pubDate>Wed, 20 Feb 2019 04:38:05 GMT</pubDate>
            <atom:updated>2019-02-20T04:38:05.955Z</atom:updated>
            <content:encoded><![CDATA[<p>Thanks for article.</p><p>Can I translate this article into Korean?</p><p>If I could, I will leave link.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=593a90af0d22" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Vuejs] 동적 & 비동기 컴포넌트]]></title>
            <link>https://medium.com/@Dongmin_Jang/vuejs-%EB%8F%99%EC%A0%81-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-4cf1a4f7e561?source=rss-348041857347------2</link>
            <guid isPermaLink="false">https://medium.com/p/4cf1a4f7e561</guid>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[vue]]></category>
            <category><![CDATA[async]]></category>
            <category><![CDATA[components]]></category>
            <category><![CDATA[dynamics]]></category>
            <dc:creator><![CDATA[Dongmin Jang]]></dc:creator>
            <pubDate>Wed, 13 Feb 2019 17:36:03 GMT</pubDate>
            <atom:updated>2019-02-13T17:36:03.420Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*CEGdwHuTzmH65IYEl5a-Fw.jpeg" /><figcaption>grapefruit, 내용과 무관한 이미지</figcaption></figure><p>아래 Dynamic &amp; Async Components 에 대한 번역글 입니다.</p><p><a href="https://vuejs.org/v2/guide/components-dynamic-async.html">Dynamic &amp; Async Components - Vue.js</a></p><blockquote>다음 글을 숙지 하셨다는 전제하에 설명이 진행됩니다. <a href="https://vuejs.org/v2/guide/components.html">Components Basics</a>. 컴포넌트에 대해 이해가 잘 되지 않으신 상태라면 링크를 따라 먼저 숙지하세요.</blockquote><h3>keep-alive with Dynamic Components</h3><p>이전에는 탭 인터페이스에서 컴포넌트 간의 변경을 위해is attribute 를 사용했습니다.</p><pre>&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</pre><p>이러한 컴포넌트간의 변화가 있을 때, 때로는 컴포넌트의 상태를 유지하거나 성능상의 이유로 re-rendering 되는 것을 피하려 할 것입니다. 예를 들면, 앞의 탭 인터페이스를 약간 확장한다고 했을 때:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*hbeEkKGwtwmw7Vv2g6QY6Q.png" /><figcaption>[캡쳐본입니다. 참고만 하세요.]</figcaption></figure><p>포스트 하나를 선택하고나서 Archive 탭을 누르게 되면, 다시 Posts 탭을 눌렀을 때 앞에서 선택한 포스트가 선택되어 있지 않다는 것을 알 수 있을겁니다.이는 탭을 누를 때마다 Vue 가 currentTabComponent의 새로운 인스턴스를 생성하기 때문입니다.</p><p>동적 컴포넌트를 재생성하는 것은 유용한 것이긴 하지만, 이러한 상황에서는 각각의 컴포넌트가 처음 만들어지고나서 캐시 처리 되기를 바랄지도 모릅니다. 이를 해결하기 위해 우리는 &lt;keep-alive&gt;요소와 함께 동적 컴포넌트를 감쌀 수 있습니다.</p><pre>&lt;!-- 비활성 컴포넌트는 캐싱! --&gt;<br>&lt;keep-alive&gt;<br>  &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;<br>&lt;/keep-alive&gt;</pre><p>아래 결과를 확인하세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*nENSoAY0FF7mxfbDFLK-2g.png" /><figcaption>[원글에서 확인하세요]</figcaption></figure><p>이제 Posts탭은 render 되지 않아도 상태(선택한 post)를 계속 가지고 있게 됩니다. <br>전체 코드는 다음 링크에서 확인하세요. <a href="https://jsfiddle.net/chrisvfritz/Lp20op9o/">link</a></p><blockquote>&lt;keep-alive&gt;는 컴포넌트에 name option을 가지고 있거나 , 혹은 지역/전역으로 등록되어 있는 이름이 있는 컴포넌트간에 전환되어야 합니다.</blockquote><p>자세한 내용은 API 문서의 &lt;keep-alive&gt; 를 참고하세요.</p><h3>Async Components</h3><p>큰 응용프로그램에서는 앱을 작은 단위로 나누고 필요한 컴포넌트만 서버로부터 가져오는 것이 필요할 것입니다. 쉽게 말해서, Vue는 컴포넌트 정의를 비동기로 처리할 수 있도록 factory function 을 이용하게 해줍니다. Vue 는 컴포넌트가 render 되야 할 때와 re-render를 위해 캐시 할 때, factory function 을 실행합니다. 예를 들면,</p><pre>Vue.component(&#39;async-example&#39;, function (resolve, reject) {<br>  setTimeout(function () {<br>    // resolve callback 에 컴포넌트 정의를 넘겨줍니다<br>    resolve({<br>      template: &#39;&lt;div&gt;I am async!&lt;/div&gt;&#39;<br>    })<br>  }, 1000)<br>})</pre><p>factory function은 서버로부터 컴포넌트 정의를 처리할 때 실행할 resolve callback 을 받습니다. 또한 load 를 실패했을 때는 reject(reason) 로 처리 될 수 있습니다. 여기서 setTimeout 은 데모용입니다. 어떻게 컴포넌트를 가져올지는 원하는대로 해도 됩니다. 한가지 추천하는 방법은 <a href="https://webpack.js.org/guides/code-splitting/">Webpack’s code-splitting feature</a> 와 함께 비동기 컴포넌트를 사용하는 것입니다.</p><pre>Vue.component(&#39;async-webpack-example&#39;, function (resolve) {<br>  // This special require syntax will instruct Webpack to<br>  // automatically split your built code into bundles which<br>  // are loaded over Ajax requests.<br>  require([&#39;./my-async-component&#39;], resolve)<br>})</pre><p>factory function 에서 Promise을 return 할 수도 있습니다. Webpack2 와 ES2015를 이용하면 다음과 같이 가능합니다.</p><pre>Vue.component(<br>  &#39;async-webpack-example&#39;,<br>  // The `import` function returns a Promise.<br>  () =&gt; import(&#39;./my-async-component&#39;)<br>)</pre><p>지역 등록을 이용할 때는 직접 Promise를 return 하는 함수를 넣을 수 있습니다.</p><pre>new Vue({<br>  // ...<br>  components: {<br>    &#39;my-component&#39;: () =&gt; import(&#39;./my-async-component&#39;)<br>  }<br>}) </pre><p>만약에 비동기 컴포넌트를 사용하고자 하는 Browserify 사용자라면, 불행히도 제작자는 async loading 하는 것을 만들어야 합니다.( <a href="https://github.com/browserify/browserify/issues/58#issuecomment-21978224">링크 </a>참고) <br>Browserify 커뮤니티는 복잡한 응용프로그램에 도움이 될만한 <a href="https://github.com/vuejs/vuejs.org/issues/620">작업물들</a>을 발견했습니다. 다른 경우에는 비동기 처리가 기본 지원되는 Webpack을 사용하기를 추천합니다.</p><h3>Loading State 처리</h3><p>비동기 컴포넌트 factory 는 아래와 같이 object 를 return 할 수 있습니다.</p><pre>const AsyncComponent = () =&gt; ({<br>  // The component to load (should be a Promise)<br>  component: import(&#39;./MyComponent.vue&#39;),<br>  // A component to use while the async component is loading<br>  loading: LoadingComponent,<br>  // A component to use if the load fails<br>  error: ErrorComponent,<br>  // Delay before showing the loading component. Default: 200ms.<br>  delay: 200,<br>  // The error component will be displayed if a timeout is<br>  // provided and exceeded. Default: Infinity.<br>  timeout: 3000<br>})</pre><blockquote>위와 같이처리하기 위해서는 Vue Router 2.4.0 이상을 사용해야 합니다.</blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4cf1a4f7e561" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Javascript] 15가지 유용한 map, reduce, filter]]></title>
            <link>https://medium.com/@Dongmin_Jang/javascript-15%EA%B0%80%EC%A7%80-%EC%9C%A0%EC%9A%A9%ED%95%9C-map-reduce-filter-bfbc74f0debd?source=rss-348041857347------2</link>
            <guid isPermaLink="false">https://medium.com/p/bfbc74f0debd</guid>
            <category><![CDATA[js]]></category>
            <category><![CDATA[arrays]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[function]]></category>
            <dc:creator><![CDATA[Dongmin Jang]]></dc:creator>
            <pubDate>Mon, 28 Jan 2019 17:06:34 GMT</pubDate>
            <atom:updated>2019-02-21T15:18:29.479Z</atom:updated>
            <content:encoded><![CDATA[<h3>[Javascript] map, reduce, filter를 유용하게 활용하는 15가지 방법</h3><p>아래 글을 번역 및 요약한 글.</p><p><a href="https://medium.com/@alex.permyakov/15-useful-javascript-examples-of-map-reduce-and-filter-74cbbb5e0a1f">15 Useful JavaScript Examples of .map(), .reduce() and .filter()</a></p><p>[저자의 서문]</p><p>숫자의 합을 구하는 Array.reduce의 예제를 자주 볼 수 있는데, 이러한 것을 유용한것이라고 하지는 않는다. 게다가 저자는 실제 코드에서 이를 거의 보지 못했다고 한다. <br>그러나 7–8줄로 된 for-loop 코드는 많이 보았다고 한다. 이는 꽤 규칙적인 task를 처리하기 위함인데, Array,reduce를 사용하면 한줄로 끝날 수도 있는 것들이었다고 한다. <br>최근에 저자는 이러한 좋은 함수들을 이용해서 몇가지 모듈을 다시 작업했다고 한다. 그리고 코드를 간결하게 만들어 주었다고 한다. 아래에서 설명하는 것들이 그것들이다.</p><ol><li>숫자/문자열 배열에서 중복 제거하기</li></ol><p>이것은 map/reduce/filter 에 해당되지 않는 것인데, 이 리스트에서 제외시키기에는 너무 간결하다. 다음에 나올 예시들에도 나올 것이다.</p><pre>let values = [3, 1, 3, 5, 2, 4, 4, 4];<br>let uniqueValues = [...new Set(values)];</pre><pre>// uniqueValues is [3, 1, 5, 2, 4]</pre><p>2. 간단한 검색(case-sensitive)</p><p>filter()<strong> </strong>함수는 인자로 제공되는 함수에 의해 test 를 통과한 모든 요소를 새로운 array 로 만든다.</p><pre>let users = [<br>  { id: 11, name: &#39;Adam&#39;, age: 23, group: &#39;editor&#39; },<br>  { id: 47, name: &#39;John&#39;, age: 28, group: &#39;admin&#39; },<br>  { id: 85, name: &#39;William&#39;, age: 34, group: &#39;editor&#39; },<br>  { id: 97, name: &#39;Oliver&#39;, age: 28, group: &#39;admin&#39; }<br>];</pre><pre>let res = users.filter(it =&gt; it.name.includes(&#39;oli&#39;));</pre><pre>// res is []</pre><p>3. 간단한 검색(case-insensitive)</p><pre>let res = users.filter(it =&gt; new RegExp(&#39;oli&#39;, &quot;i&quot;).test(it.name));</pre><pre>// res is<br>[<br>  { id: 97, name: &#39;Oliver&#39;, age: 28, group: &#39;admin&#39; }<br>]</pre><p>4. 특정 유저가 admin 권한을 갖고 있는지 확인</p><pre>let hasAdmin = users.some(user =&gt; user.group === &#39;admin&#39;);</pre><pre>// hasAdmin is true</pre><p>5. array of arrays 펼치기</p><p>첫번째 iteration은 […[], …[1, 2, 3]] 이렇게 결과가 나오는데, 이는 [1,2,3] 으로 바뀐다. 이것은 두번째 iteration 의 acc로 위치한다.</p><pre>let nested = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];<br>let flat = nested.reduce((acc, it) =&gt; [...acc, ...it], []);</pre><pre>// flat is [1, 2, 3, 4, 5, 6, 7, 8, 9]</pre><p>여기서 명심할 것은 reduce 안에서 spread operator 는 좋은 성능을 보이지 못한다. 이 예시는 성능 측정할 때, 사용 예시로 적합하다.</p><p>아래는 Array.reduce 를 사용하지 않고 짧은 코드로 표현하는 방법이다.</p><pre>let flat = [].concat.apply([], nested);</pre><p>6. 특정 키의 빈도를 포함하는 객체를 만들기</p><pre>let users = [<br>  { id: 11, name: &#39;Adam&#39;, age: 23, group: &#39;editor&#39; },<br>  { id: 47, name: &#39;John&#39;, age: 28, group: &#39;admin&#39; },<br>  { id: 85, name: &#39;William&#39;, age: 34, group: &#39;editor&#39; },<br>  { id: 97, name: &#39;Oliver&#39;, age: 28, group: &#39;admin&#39; }<br>];</pre><pre>let groupByAge = users.reduce((acc, it) =&gt;<br>  ({ ...acc, [it.age]: (acc[it.age] || 0) + 1 }),<br>{});</pre><pre>// groupByAge is {23: 1, 28: 2, 34: 1}</pre><p>7. array of objects 인덱싱 (lookup table)</p><p>id로 유저를 찾기위해 전체 array 를 처리하는 것 대신에 user’s id 가 key로 작용하는 객체를 만들 수 있다. (일정한 검색 시간)</p><pre>let uTable = users.reduce((acc, it) =&gt; ({...acc, [it.id]: it }), {})</pre><pre>// uTable equals:<br>{<br>  11: { id: 11, name: &#39;Adam&#39;, age: 23, group: &#39;editor&#39; },<br>  47: { id: 47, name: &#39;John&#39;, age: 28, group: &#39;admin&#39; },<br>  85: { id: 85, name: &#39;William&#39;, age: 34, group: &#39;editor&#39; },<br>  97: { id: 97, name: &#39;Oliver&#39;, age: 28, group: &#39;admin&#39; }<br>}</pre><p>uTable[85].name처럼 id로 데이터에 접근할 때 유용하다.</p><p>8. 배열 안의 각각의 item에서 특정 키로 유일한 값들 뽑아내기</p><p>map()은 각 item 의 group 값만 모아서 새로운 배열을 만들것이다.</p><pre>let listOfUserGroups = [...new Set(users.map(it =&gt; it.group))];</pre><pre>// listOfUserGroups is [&#39;editor&#39;, &#39;admin&#39;];</pre><p>9. 객체 key-value map 역전</p><pre>let cities = {<br>  Lyon: &#39;France&#39;,<br>  Berlin: &#39;Germany&#39;,<br>  Paris: &#39;France&#39;<br>};</pre><pre>let countries = Object.keys(cities).reduce(<br>  (acc, k) =&gt; (acc[cities[k]] = [...(acc[cities[k]] || []), k], acc) , {});</pre><pre>// countries is<br>{<br>  France: [&quot;Lyon&quot;, &quot;Paris&quot;],<br>  Germany: [&quot;Berlin&quot;]<br>}</pre><p>이는 마치 트릭처럼 보일 수 있다. 여기에는 comma operator가 쓰였다. 이는 acc로 삽입되는부분에 마지막 값을 return 한다. 위 코드를 좀 더 읽기 편하게 쓰면 아래와 같다.</p><pre>let countries = Object.keys(cities).reduce((acc, k) =&gt; {<br>  let country = cities[k];<br>  acc[country] = [...(acc[country] || []), k];<br>  return acc;<br>}, {});</pre><p>10. 섭씨 온도를 화씨 온도로 바꾸기</p><pre>let celsius = [-15, -5, 0, 10, 16, 20, 24, 32]<br>let fahrenheit = celsius.map(t =&gt; t * 1.8 + 32);</pre><pre>// fahrenheit is [5, 23, 32, 50, 60.8, 68, 75.2, 89.6]</pre><p>11. 객체를 쿼리 스트링으로 인코딩하기</p><pre>let params = {lat: 45, lng: 6, alt: 1000};</pre><pre>let queryString = Object.entries(params).map(p =&gt; encodeURIComponent(p[0]) + &#39;=&#39; + encodeURIComponent(p[1])).join(&#39;&amp;&#39;)</pre><pre>// queryString is &quot;lat=45&amp;lng=6&amp;alt=1000&quot;</pre><p>12. 명시된 키와 함께 읽기 가능한 string 으로 유저 테이블 출력</p><pre>let users = [<br>  { id: 11, name: &#39;Adam&#39;, age: 23, group: &#39;editor&#39; },<br>  { id: 47, name: &#39;John&#39;, age: 28, group: &#39;admin&#39; },<br>  { id: 85, name: &#39;William&#39;, age: 34, group: &#39;editor&#39; },<br>  { id: 97, name: &#39;Oliver&#39;, age: 28, group: &#39;admin&#39; }<br>];</pre><pre>users.map(({id, age, group}) =&gt; `\n${id} ${age} ${group}`).join(&#39;&#39;)</pre><pre>// it returns:<br>&quot;<br>11 23 editor<br>47 28 admin<br>85 34 editor<br>97 28 admin&quot;</pre><p>13. 객체 배열에서 key-value 쌍을 찾아서 바꾸기</p><p>John의 나이를 바꾸겠다고 하면, users[1].age = 29 이렇게 하면 끝난다. 그러나 아래와 같이 다른 방식을 써보자.</p><pre>let updatedUsers = users.map(<br>  p =&gt; p.id !== 47 ? p : {...p, age: p.age + 1}<br>);</pre><pre>// John is turning 29 now</pre><p>한개 아이템을 바꾸는 것 대신에, 다른 값 하나를 포함하는 새로운 배열을 만들었다. 이제 이를 이용하여 array를 참조에 의해 비교가 가능하다. updateedUsers == users 이렇게 말이다. (<em>정말이요??</em>)<br>리액트가 reconciliation process의 속도를 올리기 위해 이러한 방법을 사용했다고 합니다.<br><a href="https://blog.logrocket.com/immutability-in-react-ebe55253a1cc">Here is some explanation.</a></p><p>14. A와 B의 합집합</p><pre>let arrA = [1, 4, 3, 2];<br>let arrB = [5, 2, 6, 7, 1];</pre><pre>[...new Set([...arrA, ...arrB])]; // returns [1, 4, 3, 2, 5, 6, 7]</pre><p>15. A와 B의 교집합</p><pre>let arrA = [1, 4, 3, 2];<br>let arrB = [5, 2, 6, 7, 1];</pre><pre>arrA.filter(it =&gt; arrB.includes(it)); // returns [1, 2]</pre><p>자세한 내용과 질문은 원문을 참고하시기 바랍니다. 원문의 댓글에 참고할 만한 링크가 있어 아래 남깁니다.</p><p><a href="https://www.zeptobook.com/eleven-ways-to-learn-javascript-array-iteration-effectively/">Eleven Ways To Learn Javascript Array Iteration Effectively - ZeptoBook</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bfbc74f0debd" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Thank you for writting.]]></title>
            <link>https://medium.com/@Dongmin_Jang/thank-you-for-writting-6c3dafd422fe?source=rss-348041857347------2</link>
            <guid isPermaLink="false">https://medium.com/p/6c3dafd422fe</guid>
            <dc:creator><![CDATA[Dongmin Jang]]></dc:creator>
            <pubDate>Tue, 27 Nov 2018 03:24:43 GMT</pubDate>
            <atom:updated>2018-11-27T03:24:43.919Z</atom:updated>
            <content:encoded><![CDATA[<p>Thank you for writting.<br>I would like to quote your article and blog on my medium. I promise involve link to yours in writting.</p><p>Are you ok? ( sorry. my english not good)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6c3dafd422fe" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Git] 어떻게 Git 전문가가 되는가? (amend, rebase)]]></title>
            <link>https://medium.com/@Dongmin_Jang/git-%EC%96%B4%EB%96%BB%EA%B2%8C-git-%EC%A0%84%EB%AC%B8%EA%B0%80%EA%B0%80-%EB%90%98%EB%8A%94%EA%B0%80-amend-rebase-3d3d31acbe5a?source=rss-348041857347------2</link>
            <guid isPermaLink="false">https://medium.com/p/3d3d31acbe5a</guid>
            <category><![CDATA[git]]></category>
            <category><![CDATA[commit]]></category>
            <category><![CDATA[merger]]></category>
            <category><![CDATA[github]]></category>
            <category><![CDATA[rebase]]></category>
            <dc:creator><![CDATA[Dongmin Jang]]></dc:creator>
            <pubDate>Mon, 26 Nov 2018 15:00:25 GMT</pubDate>
            <atom:updated>2018-11-27T00:43:20.784Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Nn2srz07QJKkV55J_9isNQ@2x.jpeg" /></figure><p><a href="https://medium.freecodecamp.org/how-to-become-a-git-expert-e7c38bf54826">How to become a Git expert</a></p><p>위 링크의 글을 보고 옮겨봅니다.</p><p>간단한 내용이지만 git 을 처음 쓰거나 협업이 처음이신 분들은 미처 알지 못하는 부분일 수도 있겠다는 생각이 듭니다.</p><p>이 글에서 중점적으로 알려주는 것은 amending commits 과 rebase 입니다.</p><p>상황1. 상당히 많은 작업을 하고 나서 명확하지 않은 내용으로 커밋을 했을 경우 아래와 같이 커밋 메세지를 바꿀 수 있습니다.</p><pre>git commit --amend -m &quot;new commit message&quot;</pre><p>-m 부분부터 명시하지 않으면 에디터 화면으로 넘어가서 메세지를 작성하게 됩니다.</p><p>상황2. 실수로 파일을 하나 빠뜨리고 커밋을 했을 경우, 파일을 추가하며 기존 커밋을 갱신할 수 있습니다.</p><pre>git add filename<br>git commit --amend --no-edit</pre><p>— no-edit 를 적어주면 커밋 메세지 수정을 안하게 됩니다.</p><p>상황3. 커밋은 작성자의 이름과 메일 주소를 포함하고 있습니다. git 초기 세팅을 하게 된다면 모든 커밋은 메일 주소를 갖게 됩니다. 만약 특정 프로젝트에 다른 메일을 쓰고 싶다면, 아래와 같이 입력하면 됩니다.</p><pre>git config user.email &quot;email address&quot;</pre><p>만약 메일 셋팅을 하기 전에 커밋을 했다면, 아래와 같이 수정이 가능합니다.</p><pre>git commit --amend --author &quot;Author Name &lt;Author Email&gt;&quot;</pre><blockquote>주의 할 점 : amend 는 로컬에서만 사용하세요. 원격 브랜치에서 사용시 문제를 일으킬 수 있습니다.</blockquote><p>상황4. 오랫동안 작업을 하는 중에 다른 사람의 작업이 원격 저장소에 올라왔습니다. 나중에 한꺼번에 내려 받게 되면 conflict가 날 수 있습니다. 자주 내려받아야겠습니다. 그런데 이번에는 잦은 pull로 많은 머지커밋이 쌓이게 되었습니다. 이렇게 되면 히스토리가 지져분하게되어 나중에 이슈들을 확인할 때 보기 좋진 않습니다.</p><p>이때 rebase를 사용합니다.</p><p>보통 작업 최신코드는 master 또는 dev에 있을 것입니다. (조직마다 다르겠죠) 그리고 기능 구현을 위한 feature branch가 있을 것입니다. 이때 아래와 같이 타이핑합니다.</p><p><em>git checkout dev</em></p><p><em>git pull oringin dev</em></p><p><em>git checkout featurebranch</em></p><p><em>git rebase dev</em></p><p>이때, conflict가 발생할 수 있습니다.</p><p>충돌난 부분을 수정하고, 다음과 같이 합니다.</p><p><em>git add filename</em></p><p><em>git rebase – – continue</em></p><p>conflict이 발생하면 위 작업을 반복합니다.</p><p>이제 feature branch는 머지커밋 없이 최신의 작업내용을 가지고 있습니다. pull request 하게 되면 머지커밋 없이 작업 내용만 히스토리에서 보일 것입니다.</p><p>그림과 함께 이해하시려면 맨위 링크를 누르세요.</p><p>이외에도 reset, stash등 알아두면 유용한 것들이 많습니다. 쉽게 이해를 도울 수 있는 글을 찾아보겠습니다.</p><p>이렇게 위 글과 같이 커밋을 다루게 되시면 git 이 좀 더 친숙하게 다가 옵니다. 아직 전문가는 아니지만, 전문가가 되고픈 의욕이 생기지 않나요?</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3d3d31acbe5a" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[네 그런거 같습니다.]]></title>
            <link>https://medium.com/@Dongmin_Jang/%EB%84%A4-%EA%B7%B8%EB%9F%B0%EA%B1%B0-%EA%B0%99%EC%8A%B5%EB%8B%88%EB%8B%A4-87f4c64e5407?source=rss-348041857347------2</link>
            <guid isPermaLink="false">https://medium.com/p/87f4c64e5407</guid>
            <dc:creator><![CDATA[Dongmin Jang]]></dc:creator>
            <pubDate>Mon, 26 Nov 2018 02:34:52 GMT</pubDate>
            <atom:updated>2018-11-26T02:34:52.424Z</atom:updated>
            <content:encoded><![CDATA[<p>네 그런거 같습니다. 너무 오래된 내용이고 추가로 작업해보고 글을 이어서 썼어야 했는데 그러지 못 했습니다. 다른 글들 검색해서 참고하시는게 좋을거 같습니다. 시간내서 vue 쪽에 있는 차트 lib 들 다시 정리해보겠습니다. 감사합니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=87f4c64e5407" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>