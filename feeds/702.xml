<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	
xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
>

<channel>
	<title>asbubam&#039;s blog</title>
	<atom:link href="https://blog.2dal.com/feed/" rel="self" type="application/rss+xml" />
	<link>https://blog.2dal.com</link>
	<description>Just enjoy the show.</description>
	<lastBuildDate>Wed, 24 Apr 2019 14:43:12 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2</generator>
<site xmlns="com-wordpress:feed-additions:1">114514939</site>	<item>
		<title>Kubernetes 03 &#8211; Kubernetes Cluster on AWS with kops</title>
		<link>https://blog.2dal.com/2019/04/24/kubernetes-03-kubernetes-cluster-on-aws-with-kops/</link>
				<comments>https://blog.2dal.com/2019/04/24/kubernetes-03-kubernetes-cluster-on-aws-with-kops/#comments</comments>
				<pubDate>Wed, 24 Apr 2019 13:39:36 +0000</pubDate>
		<dc:creator><![CDATA[asbubam]]></dc:creator>
				<category><![CDATA[AWS]]></category>
		<category><![CDATA[kops]]></category>
		<category><![CDATA[kubernetes]]></category>
		<category><![CDATA[terraform]]></category>
		<category><![CDATA[k8s]]></category>

		<guid isPermaLink="false">https://blog.2dal.com/?p=848</guid>
				<description><![CDATA[]]></description>
								<content:encoded><![CDATA[<p>지난 글 Kubernetes 02 – ReplicaSet에 이어 kops를 사용해서 AWS 환경에서 Kubernetes (이하 K8s) Cluster를 구성해보자. kops/kops_create_cluster 문서에 kops의 사용법이 쉽게 설명되어 있지만, 사내 망등의 Internal Network 위에 private topology를 사용해서 K8s Cluster를 구성하는 과정을 단계별로 설명해보고자 한다. kops는 K8s Cluster를 쉽게 생성, 관리할 수 있게 도와주는 오픈소스 프로젝트다. kops의 README 페이지에 따르면 라고 프로젝트를 설명하고 있다. 프러덕션 레벨의 K8s Cluster를 간단한 CLI 명령을 통해 생성, 관리, 업그레이드, 삭제할 수 있도록 지원한다.</p>
<p><a href="https://blog.2dal.com/2019/04/24/kubernetes-03-kubernetes-cluster-on-aws-with-kops/" rel="nofollow">Source</a></p>]]></content:encoded>
							<wfw:commentRss>https://blog.2dal.com/2019/04/24/kubernetes-03-kubernetes-cluster-on-aws-with-kops/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">848</post-id>	</item>
		<item>
		<title>AWS NAT Gateway에서 NAT instance로 전환하기</title>
		<link>https://blog.2dal.com/2018/12/31/nat-gateway-to-nat-instance/</link>
				<comments>https://blog.2dal.com/2018/12/31/nat-gateway-to-nat-instance/#comments</comments>
				<pubDate>Mon, 31 Dec 2018 14:19:29 +0000</pubDate>
		<dc:creator><![CDATA[asbubam]]></dc:creator>
				<category><![CDATA[AWS]]></category>
		<category><![CDATA[infra]]></category>
		<category><![CDATA[terraform]]></category>
		<category><![CDATA[NAT]]></category>
		<category><![CDATA[Terraform]]></category>
		<category><![CDATA[VPC]]></category>
		<category><![CDATA[테라폼]]></category>

		<guid isPermaLink="false">https://blog.2dal.com/?p=876</guid>
				<description><![CDATA[]]></description>
								<content:encoded><![CDATA[<p>2015년 12월 NAT Gateway가 출시 된 이후로 AWS에서 매니지드 NAT Gateway를 사용할 수 있게 되었다. (서울 리전은 2016년 6월에 출시) NAT Gateway가 출시되기 전에는 NAT instance (NAT용 AMI 를 통해 생성한 EC2 instance)를 사용했는데 instance 유형에 따라 대역폭이 제한되고 HA를 수동으로 구성해야하는 등 어려움이 있었다. NAT 인스턴스 및 NAT 게이트웨이 비교 페이지에서 좀 더 자세한 내용을 확인할 수 있다. 회사에서도 NAT Gateway를 사용했었고 AWS VPC Network with Terraform 등의 글에서 VPC를 설계할 때도 당연히 NAT Gateway를 사용했다. 이 때는 블로그 글을 쓰고나면 terraform...</p>
<p><a href="https://blog.2dal.com/2018/12/31/nat-gateway-to-nat-instance/" rel="nofollow">Source</a></p>]]></content:encoded>
							<wfw:commentRss>https://blog.2dal.com/2018/12/31/nat-gateway-to-nat-instance/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">876</post-id>	</item>
		<item>
		<title>Kubernetes 02 &#8211; ReplicaSet</title>
		<link>https://blog.2dal.com/2018/04/30/kubernetes-02-replicaset/</link>
				<comments>https://blog.2dal.com/2018/04/30/kubernetes-02-replicaset/#comments</comments>
				<pubDate>Sun, 29 Apr 2018 15:27:42 +0000</pubDate>
		<dc:creator><![CDATA[asbubam]]></dc:creator>
				<category><![CDATA[kubernetes]]></category>
		<category><![CDATA[k8s]]></category>
		<category><![CDATA[리플리카셋]]></category>
		<category><![CDATA[쿠버네티스]]></category>

		<guid isPermaLink="false">https://blog.2dal.com/?p=795</guid>
				<description><![CDATA[지난 글 Kubernetes 01 &#8211; Pod 에서는 K8s(Kubernetes)의 가장 작은 배포 단위인 Pod에 대해서 설명했었다. 오늘은 ReplicaSet에 대해서 이야기 해보려고 한다. 지난 글에서 K8s의 상태를 나타내는 엔티티를 Object라 하고, Object가 Spec에 정의된 상태로 유지될 수 있도록 지속적으로 변화시키는 주체를 Controller라고 설명했었는데, ReplicaSet은 Pod (Object)을 복제 생성하고, 복제된 Pod의 개수를 (Spec에 정의된 개수만큼) 지속적으로 유지하는 Controller다. [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>지난 글 Kubernetes 01 &#8211; Pod 에서는 K8s(Kubernetes)의 가장 작은 배포 단위인 Pod에 대해서 설명했었다. 오늘은 ReplicaSet에 대해서 이야기 해보려고 한다. 지난 글에서 라고 설명했었는데, ReplicaSet은 Pod (Object)을 복제 생성하고, 복제된 Pod의 개수를 (Spec에 정의된 개수만큼) 지속적으로 유지하는 Controller다. ReplicaSet 공식 문서를 보면 ReplicaSet을 ’ReplicaSet is the next-generation Replication Controller&#8217; 라고 설명하고 있다. ReplicationController는 deprecated될 예정으로...</p>
<p><a href="https://blog.2dal.com/2018/04/30/kubernetes-02-replicaset/" rel="nofollow">Source</a></p>]]></content:encoded>
							<wfw:commentRss>https://blog.2dal.com/2018/04/30/kubernetes-02-replicaset/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">795</post-id>	</item>
		<item>
		<title>Kubernetes 01 &#8211; Pod</title>
		<link>https://blog.2dal.com/2018/03/28/kubernetes-01-pod/</link>
				<comments>https://blog.2dal.com/2018/03/28/kubernetes-01-pod/#comments</comments>
				<pubDate>Tue, 27 Mar 2018 16:54:17 +0000</pubDate>
		<dc:creator><![CDATA[asbubam]]></dc:creator>
				<category><![CDATA[kubernetes]]></category>
		<category><![CDATA[pod]]></category>
		<category><![CDATA[쿠버네티스]]></category>

		<guid isPermaLink="false">https://blog.2dal.com/?p=719</guid>
				<description><![CDATA[지난 글 Kubernetes Intro 에서는 K8s(Kubernetes)의 Master와 Node(Minion)를 구성하는 주요 컴퍼넌트에 대해서 설명했었다. 이어서 K8s 클러스터의 주요 개념인 Object와 Controller에 대해서 설명하기로 예정되어 있었는데 글이 너무 늦어졌다. (근 한달 가까운 시간을 푹 쉬었&#8230;혹시 기다리셨던 분이 계시면 죄송합니다. ㅠ_ㅠ 이제 살아났어요!!) Object, Controller Object는 K8s의 상태를 나타내는 엔티티를 의미한다. 따라서 Object는 K8s API의 Endpoint로서 동작한다. 각각의 [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>지난 글 Kubernetes Intro 에서는 K8s(Kubernetes)의 Master와 Node(Minion)를 구성하는 주요 컴퍼넌트에 대해서 설명했었다. 이어서 K8s 클러스터의 주요 개념인 Object와 Controller에 대해서 설명하기로 예정되어 있었는데 글이 너무 늦어졌다. (근 한달 가까운 시간을 푹 쉬었&#8230;혹시 기다리셨던 분이 계시면 죄송합니다. ㅠ_ㅠ 이제 살아났어요!!) Object는 K8s의 상태를 나타내는 엔티티를 의미한다. 따라서 Object는 K8s API의 Endpoint로서 동작한다. 각각의 Object는 과 라는 필드를 갖게되는데 K8s는 Object의 Spec을 통해 사용자가 기대하는 상태(Desired State)가 무엇인지 알 수 있고...</p>
<p><a href="https://blog.2dal.com/2018/03/28/kubernetes-01-pod/" rel="nofollow">Source</a></p>]]></content:encoded>
							<wfw:commentRss>https://blog.2dal.com/2018/03/28/kubernetes-01-pod/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">719</post-id>	</item>
		<item>
		<title>Kubernetes Intro</title>
		<link>https://blog.2dal.com/2018/02/28/kubernetes-intro/</link>
				<comments>https://blog.2dal.com/2018/02/28/kubernetes-intro/#comments</comments>
				<pubDate>Wed, 28 Feb 2018 04:11:37 +0000</pubDate>
		<dc:creator><![CDATA[asbubam]]></dc:creator>
				<category><![CDATA[infra]]></category>
		<category><![CDATA[kubernetes]]></category>
		<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[쿠버네티스]]></category>

		<guid isPermaLink="false">https://blog.2dal.com/?p=611</guid>
				<description><![CDATA[작년 봄에 Kubernetes 에 대해 간단히 설명하는 글을 썼었는데, 그때는 컨테이너 오케스트레이션 플랫폼을 한번도 써본적이 없는 상태에서 스터디 발표주제를 Kubernetes로 정하고, 생소한 개념들을 조사하고 정리했었다. 당시에는 오케스트레이션 플랫폼이 왜 필요한지 아직 크게 와닿지 않았었는데 작년에 다니던 회사에서 Amazon ECS 를 처음 써보게 되면서 어렴풋이나마 컨테이너 오케스트레이션의 필요/중요성에 대해서 알게된 것 같다. 컨테이너는 stateless, immutable, mortal [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>작년 봄에 Kubernetes 에 대해 간단히 설명하는 글을 썼었는데, 그때는 컨테이너 오케스트레이션 플랫폼을 한번도 써본적이 없는 상태에서 스터디 발표주제를 Kubernetes로 정하고, 생소한 개념들을 조사하고 정리했었다. 당시에는 오케스트레이션 플랫폼이 왜 필요한지 아직 크게 와닿지 않았었는데 작년에 다니던 회사에서 Amazon ECS 를 처음 써보게 되면서 어렴풋이나마 컨테이너 오케스트레이션의 필요/중요성에 대해서 알게된 것 같다. 는 개념을 기반으로 아키텍처를 구성하다 보면 운영에 앞서 반드시 필요한 것이 컨테이너 오케스트레이션이라고 생각한다. 컨테이너 오케스트레이션은 다수의 컨테이너를 다수의 호스트(클러스터)에 적절하게 분산 실행하고, 원하는 상태(desired state)로 실행상태를 유지해...</p>
<p><a href="https://blog.2dal.com/2018/02/28/kubernetes-intro/" rel="nofollow">Source</a></p>]]></content:encoded>
							<wfw:commentRss>https://blog.2dal.com/2018/02/28/kubernetes-intro/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">611</post-id>	</item>
	</channel>
</rss>
