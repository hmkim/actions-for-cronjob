<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Min Seo Park on Medium]]></title>
        <description><![CDATA[Stories by Min Seo Park on Medium]]></description>
        <link>https://medium.com/@minseopark?source=rss-93e6ff058dd2------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/0*S6hYMJg6xHZnRHSw.</url>
            <title>Stories by Min Seo Park on Medium</title>
            <link>https://medium.com/@minseopark?source=rss-93e6ff058dd2------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Sun, 12 May 2019 21:27:22 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@minseopark" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[JavaScript로 블록체인 만들기 #0]]></title>
            <link>https://medium.com/@minseopark/javascript%EB%A1%9C-%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-0-2ee795169362?source=rss-93e6ff058dd2------2</link>
            <guid isPermaLink="false">https://medium.com/p/2ee795169362</guid>
            <category><![CDATA[cauclink]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[blockchain-technology]]></category>
            <category><![CDATA[blockchain-tutorial]]></category>
            <category><![CDATA[blockchain]]></category>
            <dc:creator><![CDATA[Min Seo Park]]></dc:creator>
            <pubDate>Thu, 18 Apr 2019 02:04:51 GMT</pubDate>
            <atom:updated>2019-04-18T02:04:51.976Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*_PQ1E97Wov22MN6eeLGoWQ.png" /></figure><p>JavaScript 로 블록체인을 만들어보는 tutorial 입니다</p><p>저번 <a href="https://medium.com/caulink/파이썬으로-블록체인-만들기-part-1-4386dbc735e">파이썬으로 블록체인 만들기</a>에 이어서 이번에는 JavaScript 로 블록체인 만들기 시리즈를 연재하게 되었습니다.</p><p>개발에 관심있는 분들은 다 같이 따라해보시면 좋을 것 같아요</p><p>원저자 : <a href="https://github.com/lhartikk">Lauri Hartikka</a> <br>원본 : <a href="https://lhartikk.github.io">https://lhartikk.github.io</a></p><h3>#0 시작</h3><p>이번 튜토리얼에서 우리는 작동하는 암호화폐를 위한 간단한 기본 개념부터 짚고 코딩해나가려고 한다. 모두 따라할 수 있게 최대한 쉽고 간단한 방법으로 구현할 예정이다.</p><p>이번 튜토리얼에서 우리가 만드는 프로젝트의 이름은 “Naivecoin” 이다. 프로그래밍 언어는 Typescript 이다. Naivecoin 은 <a href="https://medium.com/@lhartikk/a-blockchain-in-200-lines-of-code-963cc1cc0e54">Naivechain — blockchain in 200 lines of code</a> 의 확장판이라고 보면 된다.</p><p>Naivecoin Tutorial 은 실제로 통용될 수 있는 암호화폐를 만드는 것이 아니라 암호화폐의 기본적인 개념을 구현해 보는 것이다.</p><p>이번 튜토리얼을 통해서 암호화폐의 기술적 부분에 대한 이해도가 더 높아지기를 바란다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2ee795169362" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Do you “Really” need a Blockchain?]]></title>
            <link>https://medium.com/caulink/do-you-really-need-a-blockchain-64559d2da824?source=rss-93e6ff058dd2------2</link>
            <guid isPermaLink="false">https://medium.com/p/64559d2da824</guid>
            <category><![CDATA[public-blockchain]]></category>
            <category><![CDATA[doyouneedblockchain]]></category>
            <category><![CDATA[permissionless]]></category>
            <category><![CDATA[blockchain]]></category>
            <category><![CDATA[permissioned]]></category>
            <dc:creator><![CDATA[Min Seo Park]]></dc:creator>
            <pubDate>Fri, 11 Jan 2019 09:07:26 GMT</pubDate>
            <atom:updated>2019-01-14T12:07:21.889Z</atom:updated>
            <content:encoded><![CDATA[<h3>1_Do you “Really” need a Blockchain?</h3><p>당신은 블록체인이 정말 필요한가요?</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*VIEATQ7TM49lXCiSb5vRAg.png" /></figure><p><strong>시리즈 연재 시작</strong></p><p>과연 블록체인이라는 분야가 많은 일반 소비자들에게 큰 호응을 받지 못하고, 신뢰를 주지 못하는 그 원인은 무엇일까? 블록체인 프로젝트의 낮은 성공률 , 블록체인 사업 종사자의 도덕적 해이, 그리고 일반 대중들의 블록체인에 대한 낮은 이해도가 가장 큰 이유라고 생각한다.</p><p>블록체인 씬에 입문한지 6개월이 넘어가는 이 시점에서 필자도 내가 왜 블록체인을 공부하는지, 어떻게 하면 잘 활용할 수 있고 가치 확산을 할 수 있을지에 대해서 고민을 하고 있었다.</p><p>그래서 나 자신에게도 해답을 주고 씬에 있는 많은 사람들과도 의견을 나눌 수 있음과 동시에 씬에 갓 입문한 사람들이 읽으면 좋을 만한 그리고 고민하면 좋을 만한 주제를 10개를 가지고 있는 논문 및 아티클 선정해서 그에 대한 분석하는 글을 시리즈 형식으로 연재 하려고 한다.</p><p><strong>0 — Abstract</strong></p><p>블록체인 코어 ,dapp 기획 및 개발을 진행하다보면 다양한 종류의 난관에 부딪히게 된다. 그 중 많은 입문자들 그리고 개발자들이 곤욕을 치루는 질문은 바로 “why blockchain, 블록체인이 정말 그 곳에 필요한가 이다.” 이 질문에 대한 적절한 답을 제시하지 못하면 그 프로젝트는 블록체인을 굳이 쓸 필요가 없는 프로젝트인 것이다.</p><p>혹자는 비즈니스 분야에서는 더 이상 why blockchain 이라는 질문은 던지지 않는다고 한다. 실제 BM 이 작동하는지 그것이 파괴력 있게 작동할 것인지에 대해 더 집중한다고 한다.</p><p>하지만 특정 프로젝트에서 블록체인이 아닌 다른 기술을 사용하는 것이 훨씬 더 효과적인데, 블록체인을 왜 사용하는가 라는 질문에 대한 답을 명확하게 제시하지 못한다면, 그 당위성은 현저하게 떨어질 것이다.</p><p>그래서 첫번째 주제는 Do you “Really” need a blockchain? 로 선정했다. 제목부터 메세지를 던지는 이 글에서는 크게 5가지에 대해서 논의해보려고 한다.</p><ol><li>블록체인에서 사용되는 용어에 대한 간단한 설명</li><li>용어들과 조건에 따른 블록체인의 종류 구분</li><li>시스템에서 중시 여겨지는 6가지의 요소들을 제시</li><li>조건에 따라 구별된 각 시스템에서 요소들이 어떻게 활용되고 어떤 의미를 가지고 있는지 설명</li><li>6요소와 5가지 질문을 통해서 정말 블록체인이 필요한가, 필요하면 어떤 종류의 블록체인을 사용해야하는가에 대한 해답을 플로우 차트로써 제시</li></ol><p>본 글에서 제시된 방법론은 어디까지나 제안사항일 뿐, 정답은 아니다.</p><h3><strong>1 — Introduction</strong></h3><p>비트코인 및 이더리움과 같은 permissionless blockchain 에 참여하는 주체들은 상호 미신뢰관계(mutually mistrusting)를 유지하면서 TTP (trusted third party) 즉, 중앙화 된 제 3의 세력에 의지하지 않는다. 이러한 특성들 때문에 블록체인은 많은 주목을 받았다. 또한 IoT, 금융거래, SCM 등 다양한 분야로의 진출에도 가능성을 보여왔다.</p><p>이러한 permissionless blockchain 과는 다르게 permissioned blockchain 도 존재한다. 이러한 블록체인 시스템에는 오직, 허가된(permissioned) 주체만이 정보를 읽고 쓸 수 있는 권한이 주어진다.</p><p>그러나 permissioned blockchain에는 과연 현재 사용되고 있는 중앙화된 데이터베이스 시스템과 어떤 점이 다르고 더 뛰어난가라는 근본적인 질문을 던질 수 있을 것이다.</p><p>본 글에서는 시스템에서 제공하는 주요 요소들에 대해서 설명하고 시스템을 permissioned, permissionless blockchain 그리고 centrally managed database 로 나누어서 각 시스템에서 요소가 어떻게 작용하는지와 각 시스템의 특징에 대해서 구분하고 설명하려고 한다.</p><h3><strong>2 — Background on blockchain</strong></h3><p>블록은 자료를 저장하는 자료구조이고, 블록체인은 그 블록들을 연결해 놓은 체인이자 분산원장 형태의 데이터 베이스이다.</p><p>블록에는 다양한 종류의 정보가 들어 있다. 보통 블록은 블록의 헤더와 바디로 이루어져 있다.</p><p>보통 블록의 바디에는 여러가지의 트랜잭션들이 들어 있고, 블록 헤더는 해당 블록의 메타 데이터를 포함하고 있다.</p><p>블록의 구조는 다음과 같이 되어 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/295/1*-aHqG_7YTtnjLmZvkkvFqw.png" /><figcaption>&lt;그림 — 1&gt;</figcaption></figure><p>그림 — 1 에서 볼 수 있는 것과 같이 <strong>블록의 헤더에는</strong> 주로 <strong>블록 헤더 해쉬, 버전, 머클루트, 이전 블록 헤더 해쉬, 타임스탬프, 논스 값</strong> 등이 들어 있고, <strong>블록의 바디에는</strong> 주로 <strong>거래 정보들</strong>이 있다.</p><p>블록 해쉬 (블록 헤더 해쉬)는 블록 헤더의 각 정보가 모여서 만들어지는 해쉬 값이고 머클해쉬는 바디에 있는 거래 내역들의 모든 정보를 모아 놓은 해쉬 값이다. 즉, 블록 헤더의 정보 중 하나라도 변하게 된다면, 블록 헤더 해쉬가 변하게 된다. 이런 상황이 오면, 블록체인에 문제가 생기게 되는 것이다. 또, 블록체인이 유지가 되는 이유이기도 하다. 정확히 해쉬 값이 어떻게 생성되는지 그리고 블록체인이 유지되는 이유를 확률적으로 계산하는 내용은 시리즈의 다음 글에서 소개될 것이다.</p><p>이번에는 블록체인의 구조를 살펴보도록 하겠다. 블록 체인의 구조는 다음과 같이 되어 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*fcSQsSIo-vhk1f7f" /><figcaption>&lt;그림 — 2&gt;</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*RQSOv89lE7y9joF3" /><figcaption>&lt;그림 — 3&gt;</figcaption></figure><p>그림 — 2 에서 볼 수 있는 것과 같이 이전 블록에 대한 정보(Previous Hash)로 블록들은 독립적으로 존재하지 않고 하나의 체인으로서 존재하게 된다. 만약에, 특정 부분이 임의로 변하게 된다면 그에 따라 블록 헤더 해시가 변하게 된다. 이런 상황에서는, 결국 그림 — 3 처럼 블록들의 체인이 깨지게 되는 것이다.</p><p>블록의 헤더 해시가 완성되는 과정 및 정보의 무결성이 지켜지는 것을 확률로서 증명하는 내용은 시리즈의 다음 글에서 더 정확하게 설명 될 것이다.</p><p>본격적으로 주제에 들어가기 전에 글에서 지속적으로 사용될 단어인 writer 와 reader 의 의미부터 한번 명확하게 짚고 넘어갈 필요가 있을 것 같다.</p><p>writer는 데이터베이스에 state(상태)를 작성하는 모든 주체를 의미한다. 블록체인에서 writer(POW) 는 consensus protocol 에 직접적인 참여를 하고 블록체인 확장(성장)에 도움을 주는 주체이다. 블록에 거래 내역을 담고 채굴을 하여 체인에 연결하는 주체이다. writer 는 POW 에서는 Miner, POS 에서는 Validator 라고 불리운다.</p><blockquote><strong>Writer는 블록체인에 정보를 기록하는 사람 (Miner)</strong></blockquote><p>reader 는 블록체인 확장(extending)에는 역할을 맡고 있지 않지만, 거래 생성 프로세스에 참여만 하거나 단순히 정보를 읽는 주체를 의미한다.</p><blockquote><strong>Reader는 블록체인의 정보를 읽는 사람 (거래 참여자 or 단순 internet user)</strong></blockquote><p>비트코인을 예로 들면 writer 는 채굴자 , reader 는 단순 사용자를 의미한다고 보면 된다.(regulator 와 software maintainer 는 이 글의 범위에서 벗어나기에 언급하지 않겠다.)</p><p>그렇다면 이제부터는 blockchain 을 종류에 따라 구분해보도록 하겠다.</p><h3><strong>3 — Types of Blockchain</strong></h3><p>블록체인이라고 모두 다 같은 블록체인은 아니다. 설립자 혹은 설립 집단이 추구하는 목표와 담으려는 그 특징에 따라 블록체인은 조금씩 다른 형태로 구현된다. 그리고 그 형태에 따라 구분되어진다.</p><p>필자도 그렇고 독자들 역시, 추후에 특정 아이디어를 가지고 블록체인 프로젝트를 시작하고 싶을 때 어떤 형태의 블록체인이 본인의 아이디어에 어울리는지에 대한 선택을 잘 하는 것이 중요하다.</p><p>블록체인을 분류하자면 다양한 기준에 따라 분류될 수 있지만, 가장 많이 쓰이는 것은 Permissioned &amp; Permissionless 그리고 Public &amp; Private 이다. 이 구분이 어떤 기준에 의해서 나누어지는지에 대해서 정확히 알아보겠다.</p><h4><strong>Permissionless &amp; Permissioned Blockchain</strong></h4><p>먼저, permissionless blockchains, permissioned blockchains 으로 나눌 수 있을 것이다. permissionless 의 예시로는 비트코인, 이더리움이 있고 permissioned 의 예시로는 R3 corda 와 Hyperledger Fabric가 있다.</p><p>그렇다면 permissioned &amp; permissionless blockchain 기준이 무엇일까?</p><p>permissionless 한 블록체인은 모든 peer가 언제든 reader 나 writer로서 허가 없이 (permissionless) 네트워크에 참여하고 떠날 수 있는(join &amp; leave) 블록체인이다. 그리고 체인에 등록된 모든 정보를 누구나 읽을 수 있다.</p><p>permissioned 한 블록체인에서는 오직 허가받은 제한된 reader 와 writer 만이 정보를 읽고 쓸 수 있다.</p><p>Reader , Writer 둘 중 하나라도 허가없이 될 수 없다면 그것은 Permissioned 라고 구분된다.</p><p>즉, permissioned , permissionless blockchain 의 가장 큰 차이점은 누구나 reader 그리고 writer 가 될 수 있는가이다. permissionless blockchain 에는 누가 reader 그리고 writer 될 지를 결정하는 중앙화된 주체가 없는 것이고 permissioned 에는 권한을 부여하는 주체가 있다.<br>(peer 들을 관리하는 주체 및 규칙의 존재 여부)</p><p>permissionless 는 누구나 reader, writer 로서 생태계에 참여할 수 있다는 장점이 있는 반면, 동시에 시스템의 안정성과 보안성을 갖추기 위해 거래 내역에 대한 유효성을 작업 증명 방식으로 보증한다. 즉, permissioned 시스템에 비해서 finality의 속도가 늦어진다는 단점이 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*B4G3Dz1Cpo2-QF0tG40VTQ.png" /><figcaption>&lt;표 — 1&gt;</figcaption></figure><h4><strong>Public &amp; Private Blockchain</strong></h4><p>이번엔 permissioned , permissionelss blockchain 만큼 많이 쓰이는 public &amp; private blockchain 을 구분하는 기준에 대해서 알아보겠다.</p><p>permissionless, permissioned 블록체인을 구분하는 기준은 reader 그리고 writer 가 될 권리를 결정하는 주체 혹은 그룹의 존재여부였다. public , private 블록체인을 구분하는 기준은 조금 다르다.</p><p>public 블록체인과 permissionless 블록체인의 종류 그리고 private 블록체인과 permissioned 블록체인의 종류가 상당 부분 겹쳐서 사실상 public 과 permissionless blockchain 이 거의 동의어로 사용되고 있다. 하지만 그 차이는 분명히 존재한다.</p><p>public 과 private blockchain의 구분 기준은 reader 가 될 수 있는 권리가 모든 사람들에게 주어 지느냐의 여부이다. reader 의 권리가 주어지지 않는 자에게는 당연히 write 할 권리 역시 주어지지 않는다.</p><p>public 과 private 이라는 단어에서 보면 알 수 있듯이, blockchain 의 정보가 public 하느냐 private 하느냐에 따라서 구분이 된다. public 하다면 누구나(관계자 및 참가자가 아니더라도) blockchain 의 정보를 읽을 수 있는 것이고 private 하다면, 모든 사람이 blockchain의 정보를 읽을 수 있는 것은 아니다.</p><p>즉, public &amp; private blockchain 의 차이를 한문장으로 정리하자면, 특정 blockchain 의 이해 관계자가 아닌 일반인도 blockchain 의 정보를 읽을 수 있느냐 이다.</p><h4><strong>Public Permissionless / Public Permissioned Blockchain</strong></h4><p>Public Permissionless Blockchain 은 누구나 blockchain 의 정보를 읽을 수 있고, reader 혹은 writer 가 되는데 있어서 특정 주체 혹은 그룹의 허가 혹은 규칙을 만족 시킬 필요가 없는 블록체인이다.</p><p>그리고 그 대표적인 예시로는 Bitcoin 등이 있다.</p><p>Public Permissioned Blockchain 은 EOS 가 대표적 일 것이다. EOS(혹자는 EOS는 블록체인이 아니다 라고 하기도 하지만, 여기서는 그렇게 깊이 들어가지는 않겠다)는 21개의 BP 집단이 있다. BP 의 역할은 블록을 만들어서 블록체인을 형성시키는 것이다. 즉, 오직 그들만이 Writer 가 될 수 있는 것이다. 하지만, 누구나 EOS 의 블록구조 및 내부의 내용은 들여다 볼 수 있다. 전형적인, 특정 주체들만 Writer 가 될 수 있고 그런 권한을 부여하는 주체가 존재하는 Public Permissioned Blockchain 인 것이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dOVkhnAH0IbyYYRnhyr64w.png" /><figcaption>&lt;표 — 2&gt;</figcaption></figure><p>표- 2에서 볼 수 있듯이 EOS, Bitcoin 모두 Public 블록체인 이기에 모두가 Reader 가 될 수 있지만, EOS 는 Permissioned 이기 때문에 Writer 는 오직 21개의 BP 만이 될 수 있다. 그리고 그 BP 는 투표를 통해서 선출된다. (Writer가 될 수 있는 상위 21개를 선정하기 위해 투표하는 집단이 존재) 하지만, Bitcoin 은 Public 이면서 Permissionless 한 블록체인 이기에 누구나 Reader 그리고 Writer 가 될 수 있다.</p><h4><strong>Permissionless &amp; Permissioned / Public &amp; Private Blockchain</strong></h4><p>앞서 언급하였듯이, public permissioned 는 누구나 reader 는 될 수 있지만, writer 가 될 권리는 특정 주체에게만 주어지는 체인을 의미한다. private permissioned 블록체인은 reader 될 권리도 모두에게 주어지지 않고 writer 도 reader 가 된 특정 주체 안에서도 조건을 맞춘 자들만 될 수 있는 체인을 의미한다.</p><p>그렇다면, 모순처럼 보일 수 있겠지만 private permissionless blockchain 은 어떠한 모습일까?</p><p>private 하지만, 즉 체인과 관련된 이해관계자들만 reader 가 될 수 있고 모든 reader 가 writer 될 수 있는 형태의 blockchain 이다. 비유를 해보자면, 단체 톡방이라고 볼 수 있을 것 같다. 그 톡방에 있지 않은 사람들은 그 내용을 볼 수 없지만, 그 톡방에 초대가 된 모두는 읽을 수 있고 채팅을 할 수 있는 것이다.</p><p>public, private, permissionless, permissioned 블록체인을 표로써 정리해보면 표-3같다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*4z-GqAs6PfDa8t899Bc8uQ.png" /><figcaption>&lt;표-3&gt;</figcaption></figure><p>표 — 3은 일반인이 reader, writer 가 특정체인에서 될 수 있는가에 따른 분류를 해 놓은 것이다.</p><p>그리고 위의 4가지 blockchain 종류에서 내가 모두 reader 와 writer 가 될 수 있느냐는 2가지 질문으로 정리 될 수 있을 것이다.</p><p>특정 chain 의 이해 관계자입니까? , <br>Writer 가 되기 위한 특정 조건을 만족 하였습니까?</p><p>Public — Permissionless 에서는 2가지 질문 모두 아니오 라고 답해도 reader, writer 가 될 수 있다.</p><p>Public — Permissioned 에서는 특정 이해관계자가 아니어도 Reader 가 될 수 있고 Writer 가 되기 위해서는 특정 조건을 만족 하였습니까 라는 질문에 예라고 대답할 수 있어야 가능하다.</p><p>Private — Permissionless 에서는 특정 chain 의 이해 관계자이어야만 reader 로 될 수 있고 reader 가 된 상태에서는 특정 조건을 만족하지 않아도 writer 가 될 수 있다.</p><p>Private — Permissioned 에서는 특정의 chain 의 이해관계자이어야만 reader 가 될 수 있고, reader 가 되었더라도 특정 조건까지 만족해야만 writer 가 될 수 있는 것이다.</p><h4><strong>Permissionless &amp; Permissioned Blockchain &amp; Central Database</strong></h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*iEDqHEa2PSevwc60" /><figcaption>&lt;표 — 4_1&gt;</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Qb6HE5s9t3uTJTsfqmFcUg.png" /><figcaption>&lt;표 — 4_2&gt;</figcaption></figure><p>표 — 4_1에 permissionless, permissioned blockchain 그리고 central database 이 각 특성에서 어떤 성능을 보이는지 분리해놓았고 표 — 4_2에는 각 특성들의 정의에 대해서 정리해놓았다.</p><p>centralized system 에서는 latency 와 throughput 이 전반적으로 blockchain system 보다는 나은 편이다. (블록체인 시스템은 그들의 합의 알고리즘에 그 복잡성이 더해지기 때문임).</p><p>예를 들어, 비트코인은 현재 오직 매초 대략 7개의 거래를 유지해 낼 수 있다. 중앙화된 비자는 15,000 개 이상의 거래를 1초에 처리할 수 있다. 탈중앙의 정도와 throughput 에는 tradeoff 가 존재한다. (how well a system scales to a large number of writers without mutual trust, and throughput, how many state updates a system can handle in a given amount of time) 그래서 블록체인을 사용할지 말지, 어떤 종류의 블록체인을 사용할 지 의사결정을 내릴 때, 이 tradeoff 역시 고려 대상 중 하나로 넣어야 한다.</p><h4><strong>6 Properties of System</strong></h4><p>이제부터는 시스템이 제공하는 6개의 요소에 대해서 각각의 정의를 설명하고 시스템별로 그 요소들이 어떻게 적용되는지 비교해보려고 한다.</p><p><strong>A. properties</strong></p><p><strong>public verifiability(공개 검증) :</strong></p><p>공개검증은 시스템의 상태가 올바른지(correctness of the state) 누구든 판단 가능한가에 대한 요인이다. 분산원장 시스템에서는 verifier 에 의해 시스템의 상태가 확인 된다. 모든 관찰자가 원장이 프로토콜에 의해 정확하게 바뀌었는지 확인할 수 있고 결국 모든 사람이 같은 원장을 보게 된다.</p><p>중앙화된 시스템에서는 사람에 따라서 다른 상태(state)를 보이게 할 수 있다. 그렇기에 모든 상태 변환이 적절하게 이루어지고 있는지에 대한 판단을 할 수가 없다. 중앙화된 권력을 믿어야만 하기 때문이다.</p><p><strong>transparency(투명성) :</strong></p><p>public verifiability 를 위해서는 데이터의 투명성은 필수이다. 그러나 observer 에게 보이는 투명한 정보의 양은 다를 수 있고 모든 참여자들이 정보의 접근 권한을 가질 필요는 없다.</p><p><strong>privacy(프라이버시) :</strong></p><p>privacy 역시 모든 시스템에서 중요한 요인 중 하나이다. 그런데, privacy 와 transparency은 상호 반비례 관계에 있다. 프라이버시 요인에 집중하게 되면 투명성을 놓치게 되고 투명성에 집중하게 되면 프라이버시를 놓치게 된다. 그렇기에, 중앙화된 시스템에서는 privacy 를 가지기 쉽다. transparency 와 public verifiability 를 가질 필요가 없기 때문이다.</p><p><strong>integrity(무결성) :</strong></p><p>정보의 integrity 는 검증되지 않은 집단이 정보를 변경시키는것으로부터 안전한가 이다. 정보의 integrity 역시 public verifiability 와 긴밀한 관계가 있다. 시스템이 public verifiability를 제공하면 데이터의 integrity 를 보장할 수 있다.</p><p>시스템에서 데이터의 공개 검증을 제공한다면, 시스템의 참여자 모두가 시스템의 상태를 확인할 수 있게 된다. 즉, 검증되지 않은 집단이 특정 정보를 임의대로 변경한다면 시스템의 상태를 지켜본 모든 참여자가 알게될 것이기에 함부로 변경을 할 수 없게 된다. 자연스럽게 정보의 무결성 역시 지킬 수 있게 된다. 중앙화된 시스템에서도 시스템이 손상되지만 않았다면 무결성을 제공할 수 있다.</p><p><strong>redundancy(중복성)</strong></p><p>redundancy 즉, 데이터의 중복성 역시 많은 사례들에서 중요한 요인으로 꼽힌다.</p><p>블록체인에서는 redundancy 는 선천적으로 제공된다. 분산원장을 기본으로 하고 있기에, peer 들간 같은 원장을 공유 즉, writer(full node) 간 replication 을 통해서 이루어진다.</p><p>중앙화된 시스템에서도 데이터의 중복성은 보장된다. 물리적으로 다른 서버간 replication 과 백업을 통해서 이루어진다.</p><p>/** 사실 redundancy 는 학문별로 다른 의미를 가지고 있다. 신뢰성 공학에서는 시스템의 일부가 오작동을 일으켜도 전체 시스템에는 영향이 가지 않는 긍정적인 의미를 가지고 있으나 행정학에서는 가외성이라고 불리운다. 가외성은 조직의 비효율의 원인이고 정리의 대상으로 여겨지고 있었다. 최근에는, 오히려 전체적으로 조직의 신뢰도와 안정성을 높여주는 순기능을 한다는 의견도 있다. **/</p><p><strong>trust anchor(대표자)</strong></p><p>Trust anchor 는 시스템에서 누가 가장 높은 권위를 가지고 있느냐를 의미한다. 즉, peer 중 누가 reader 혹은 writer 가 될 지 결정하는 권위를 누가 가지고 있는가이다.</p><p>permissioned blockchain 에서는 특정 세력을 지칭하는 것이고 permissionless 에서는 존재하지 않는 요인이라고 볼 수 있다.</p><p><strong>B. Tensions between transparency and privacy</strong></p><p>Transparency 와 privacy 이 둘 사이에는 내재된 tradeoff 가 있다. 완벽하게 투명한 시스템은 프라이버시를 제공할 수 없고 완벽하게 프라이버시한 시스템은 투명성을 제공하지 않는다.</p><p>하지만, cryptographic 한 방법을 이용한다면, privacy 와 transparency 를 동시에 충족시킬 수 있다. 물론 가격적인 측면에서 효율성이 낮기는 하지만, public system 에서도 완벽에 가까운 privacy를 제공하는 블록체인 프로젝트 중 대표적인 것은 바로 ZeroCash 이다.</p><p>‘영지식 증명’이라는 방법을 사용하여 privacy 를 제공한다. 영지식 증명은 추후에 다시 설명하겠지만, 여기서 간단히만 설명하고 가자면, 특정 사실을 증명하는데 있어서 prover(증명하려는 자) 의 정보가 전혀 유출되지 않은 상태에서 verifier(검증하는 자) 에게 인정받을 수 있는 방법을 의미한다.</p><h3><strong>4 — Where does a blockchain make sense?</strong></h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*eGP2ED0R7xwpL9sx" /><figcaption>&lt;표 — 5 ; 인용 : Do you need a blockchain?&gt;</figcaption></figure><p>그래서 블록체인은 언제 필요하고 효과적일까?</p><p>블록체인 프로젝트를 구상하는 모든 사람이 정확하게 여기에 블록체인이 사용될 만한지, 혹은 어떤 종류의 블록체인이 어울리는지에 대해서 판단하기 쉽지 않다. 그래서 본 글(논문에서 인용 : Do you need a blockchain?)에서는 독자들에게 플로우 차트(&lt; 표— 5&gt;)를 제공하여 의사결정을 도와준다.</p><p>public 블록체인은 모든 이가 블록체인의 정보를 볼 수 있다 (모두 reader가 될 수 있다.) 그리고 규칙여부에 따라 permissioned 혹은 permissionless 가 될 수 있다. 모두 reader 가 될 수 있다는 것은 대중이 이 블록체인의 정보를 보고 감시할 수 있다는 것이다.</p><p>그리고 규칙이 없어 permissionless 한 형태라면 누구나 writer 가 될 수 있는것이다. 누구나 writer 가 될 수 있다는 것은 동시에 그 writer 집단에 대한 낮은 신뢰도와 정보를 의미한다.</p><p>반대로 내가 설계하고자 하는 블록체인 시스템에서 writer 의 정보를 모든 사람이 알 필요없다면 혹은 그것을 추구한다면 public permissionless blockchain 을 선택하면 된다.</p><p>하지만, 누구나 reader 가 될 수는 있지만, 속도와 효율성 등의 이유로 일정한 풀의 writer 만 허가한다면 public permissioned blockchain 을 선택하면 된다.</p><p>그런데 여기서 blockchain 의 정보가 공개적 검증(public verifiability)을 필요로 하지 않는다면 즉, 일반 대중에게는 공개할 의무 혹은 필요가 없게 된다면 public 이 아닌 private blockchain 이 되는 것이다.</p><p>Public blockchain 은 누구나 reader 가 될 수 있는 블록체인이자 공개 검증이 보장된다. 그렇다면, Public blockchain 은 언제 쓰일까? 보통 public blockchain은 다수의 주체가 상호 비신뢰적인 관계이지만 서로 interact 하고 시스템의 state 를 change 하고 싶으나 online trusted third party 에게 의존하고 싶지는 않을 때만 사용된다.</p><p>이제부터 질문을 한가지씩 던져보려고 한다.</p><p><strong>i) 데이터 저장을 해야하는가?</strong></p><p>만약 데이터가 저장될 필요가 없다면 데이터베이스가 필요없을 것이고 그렇다면 블록체인은 필요하지 않다.</p><p><strong>ii) Writer 의 숫자가 몇인가?</strong></p><p>Writer 의 숫자에 따라서도 블록체인의 필요성 여부가 결정된다. 만약 오직, 1명 혹은 1개 주체의 Writer 만 필요로 한다면, 오히려 기존의 중앙화된 시스템이 더 효율적이기에 블록체인이 필요하지 않다.</p><p><strong>iii) TTP (Trusted Third Party)</strong></p><p>TTP 를 도입하려고 한다면 2가지 상황이 있을 것이다. TTP 가 항상 online 인가 아니면 주로 offline인가 이다.</p><p><strong>iii — 1) TTP가 항상 online 인 경우인가?</strong></p><p>TTP 가 항상 online 이라면 write operation 은 그 주체에게 전가될 수 있고 동시에, state transition 을 검증하는 verifier 로써 작동할 수 있다. 믿을 만한 주체가 항상 online 이고 write operation 을 수행할 수 있기에, 블록체인은 이 상황에서는 필요하지 않다.</p><p><strong>iii — 2) TTP가 offline 인 경우인가?</strong></p><p>TTP 가 주로 offline 인 경우이라면 특정 중앙화된 주체가 writer 가 될 수 없는 상황이다. 즉, 다수의 writer 가 블록을 생성하고 블록체인을 형성하는 상황이다. 본격적으로, blockchain 의 필요성이 대두되는 단계인 것이다.</p><p><strong>iv) Writer 의 정보 공개 및 상호관계</strong></p><p>writer 의 정보를 모두 알고 있는 상황 그렇지 않은 상황과 또, writer 간의 관계에 따라서 요구되는 blockchain 의 형태는 각각 다르다.</p><p><strong>iv — 1) Writer 가 모두 알려져 있는가?</strong></p><p>모든 writer 의 정보가 알려져 있지 않다면, Public Permissionless Blockchain 이 적합할 것이다. Permissionless 이기에 누구나 Reader 그리고 Writer 가 될 수 있고 Public 이기에 Writer 의 범위는 이해관계자가 아닌 모든 Internet User 까지로 확장된다.</p><p>즉, 모든 Writer 의 정보를 알리지 않아도 되는 혹은 알려지지 않은 경우에는 누구나 블록을 형성할 수 있고 블록체인의 정보를 읽을 수 있는 Public Permissionless Blockchain 이 가장 적합한 해답이 될 것이다.</p><p><strong>iv — 2) 모든 Writer 를 신뢰할 수 있는가?</strong></p><p>그러나 만약 모든 writer 의 정보를 다 아는 상황이라면, 즉, 일정 풀의 writer 만 존재하고 그 존재를 시스템의 참여자 모두가 아는 형태라면 Permissioned Blockchain 이 적합할 것이다.</p><p>모든 writer 들의 정보가 다 알려져 있고 그들 서로가 상호신뢰 관계에 있다면 (그 어느 writer도 악의를 가지고 있지 않음) 블록체인 대신, shared write access 를 가진 데이터 베이스가 가장 좋은 솔루션일 것이다.</p><p>그러나 만약 writer 간의 관계가 상호신뢰 관계가 아니라면(어느 writer 가 악의를 가지고 있을지도 모르는 상황이라면), permissioned blockchain 이 가장 좋은 솔루션일 것이다.</p><p><strong>v) 공개 검증이 필요한가?</strong></p><p>permissioned blockchain 에서도 public verifiability 가 제공되어야 한다면 누구나 reading 할 수 있는 public permissioned blockchain 그렇지 않다면, 특정 이해관계자들만 reading 할 수 있는 private permissioned blockchain 이 어울릴 것이다.</p><h3><strong>5 — Conclusion</strong></h3><p>이번 글에서는 블록 및 Blockchain 의 간단한 정의부터 Public / Private / Permissioned / Permissionless 로 그 종류를 나누어 보았고 시스템에서 제공하는 6요소로 Permissioned / Permissionless / Central Database 의 각각의 특징에 대해서 논의해 보았다.</p><p>특히, Public / Permissionless Blockchain , Private / Permissioned Blockchain 간의 미묘한 차이에 대해서 알아보았고 정의 내려 보았다.</p><p>또한, 설계하려는 시스템의 특징상 blockchain 이 필요한가, 또 어떤 종류의 블록체인이 필요한가에 대한 해답을 5가지 질문으로 구성된 플로우 차트로써 제시해 보았다.</p><p>블록체인에 대한 개괄적인 정보와 프로젝트의 조건에 따라서 요구되는 블록체인의 종류를 제시함으로써, 블록체인 씬에 입문하려는 초심자와 프로젝트를 구성하고 있는 집단 그리고 진행 중인 집단에게 도움이 될 것으로 사료된다.</p><p><strong>Reference</strong></p><p>[1] Karl Wust , Arthur Gervais , Do you need a Blockchain? , 2017.</p><p>[2] Satoshi Nakamoto , Bitcoin : A peer-to-peer electronic cash system , 2009.</p><p>[3] Joseph Poon and Thaddeus Dryja , The bitcoin lightning network: Scalable off-chain instant payments, 2015.</p><p>[4] Eli Ben Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza , Zerocash: Decentralized anonymous payments from bitcoin , 2014.</p><p>[5] Vitalik Buterin , Virgil Griffith , Casper the Friendly Finality Gadget , 2017.</p><p>[6]<a href="https://medium.com/datadriveninvestor/do-i-really-need-blockchain-4-important-factors-to-consider-57b06e4ffbb6">https://medium.com/datadriveninvestor/do-i-really-need-blockchain-4-important-factors-to-consider-57b06e4ffbb6</a></p><p>[7]<a href="https://devopedia.org/types-of-blockchains#Wagenaarm-2018">https://devopedia.org/types-of-blockchains#Wagenaarm-2018</a></p><p>[8]<a href="https://medium.com/@lkolisko/in-depth-on-differences-between-public-private-and-permissioned-blockchains-aff762f0ca24">https://medium.com/@lkolisko/in-depth-on-differences-between-public-private-and-permissioned-blockchains-aff762f0ca24</a></p><p>[9]<a href="https://medium.com/@pavelkravchenko/ok-i-need-a-blockchain-but-which-one-ca75c1e2100">https://medium.com/@pavelkravchenko/ok-i-need-a-blockchain-but-which-one-ca75c1e2100</a></p><p>[10]<a href="https://www.coindesk.com/information/what-is-the-difference-between-open-and-permissioned-blockchains">https://www.coindesk.com/information/what-is-the-difference-between-open-and-permissioned-blockchains</a></p><p>[11]<a href="https://medium.com/datadriveninvestor/do-i-really-need-blockchain-4-important-factors-to-consider-57b06e4ffbb6">https://medium.com/datadriveninvestor/do-i-really-need-blockchain-4-important-factors-to-consider-57b06e4ffbb6</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=64559d2da824" width="1" height="1"><hr><p><a href="https://medium.com/caulink/do-you-really-need-a-blockchain-64559d2da824">Do you “Really” need a Blockchain?</a> was originally published in <a href="https://medium.com/caulink">CauLink</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Medium 에 Gist 코드 삽입하기]]></title>
            <link>https://medium.com/@minseopark/medium-%EC%97%90-gist-%EC%BD%94%EB%93%9C-%EC%82%BD%EC%9E%85%ED%95%98%EA%B8%B0-5fe9fa74bb35?source=rss-93e6ff058dd2------2</link>
            <guid isPermaLink="false">https://medium.com/p/5fe9fa74bb35</guid>
            <category><![CDATA[github]]></category>
            <category><![CDATA[깃허브]]></category>
            <category><![CDATA[medium]]></category>
            <category><![CDATA[미디엄]]></category>
            <category><![CDATA[gist]]></category>
            <dc:creator><![CDATA[Min Seo Park]]></dc:creator>
            <pubDate>Tue, 14 Aug 2018 06:11:31 GMT</pubDate>
            <atom:updated>2018-08-14T06:11:31.916Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*L-ChtTG0jArJQEOYb5uvdg.png" /></figure><p>Medium에 코드를 직접 삽입 하고자하는 에디터들이 많을 것이다.</p><p>실제로 그렇게 하고있는 에디터들도 많이 계신다. 필자 역시, 필자가 공유하고자 하는 코드를 직접 삽입하고 싶었는데 처음에는 그 방법을 몰라서 상당히 애를 먹었다.</p><p>이미 하는 방법을 아는 분들이 많을 것 같긴 하지만, 그래도 혹시 나처럼 헤매고 있는 다른 에디터분들을 위해서 캡쳐와 함께 코드를 삽입하는 법을 이번 게시물에서 보여주고자 한다.</p><h4>1. Gist</h4><p>먼저 gist 에 들어간다.(github 말고 gist 이다.) gist 도 github 와 같이 코드를 작성하는 곳이다.(다들 아시겠지만….)</p><p>본인이 삽입하고자 하는 코드를 작성하고 등록한다.</p><p>필자는 최근에 필자가 <a href="https://medium.com/caulink/파이썬으로-블록체인-만들기-part-1-4386dbc735e">작성한</a> <a href="https://medium.com/caulink/파이썬으로-블록체인-만들기-part-2-633bb0555221">게시물</a>에서 사용되었던 블록체인 관련 코드를 작성하였다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*5G57PKf_H84JLEAp2mIJsQ.png" /><figcaption>&lt;blockchain.py 라고 이름과 확장자를 작성한 후, 코드를 작성한다.&gt;</figcaption></figure><h4>2. Create</h4><p>작성하고 나면 create를 눌러 생성한다. 생성하고 나면 다음과 같은 화면이 보일 것이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*alVWyqZ7DWKYqPthnA4cRA.png" /><figcaption>&lt;gist에 등록된 후의 화면&gt;</figcaption></figure><h4>3. Clone via HTTPS</h4><p>gist 에 작성한 코드를 등록한 후, 코드 오른쪽 윗부분을 살펴보면, Embed가 보일 것이다. 그 부분을 누르면 4개의 선택지가 뜨는데, 거기서 Clone via HTTPS 를 선택하다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*fTWQtRRlEYz-zpRsFuKvcw.png" /><figcaption>&lt;Embed 부분을 누르면 Clone via HTTPS 가 보인다.&gt;</figcaption></figure><h4>4. Copy and Paste</h4><p>그 부분을 누르면 안의 링크가 변경된다. 변경된 링크의 오른쪽에 버튼이 하나 있는데 그 버튼이 바로 복사하는 버튼이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ocnUiJfWJM5I1ZLFWixOfA.png" /><figcaption>&lt;변화한 링크 그리고 그 오른쪽의 서류 모양의 복사 버튼&gt;</figcaption></figure><p>복사를 하고 난 후, 미디엄으로 돌아오자. 미디엄에서 사진을 삽입할 때 누르는 + 버튼을 누르면 &lt; &gt; 모양의 버튼을 볼 수 있을 것이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*98baz07JNnxyI-zNYpwkPA.png" /><figcaption>&lt; &lt;&gt; 모양 위에 커서를 올려두면 Add an embed 라는 글씨를 볼 수 있을 것이다. &gt;</figcaption></figure><h4>5. Add an embed</h4><p>그 후에, gist 에서 Clone via HTTPS 의 링크를 복사한 후에 Add an embed 에 넣으면 최종적으로 코드 삽입에 성공하게 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*JQaWfaX_DER1ruH3bT5jlg.png" /><figcaption>&lt;링크를 복사한 후에 삽입한다.&gt;</figcaption></figure><p>링크를 복사한 후에, 엔터를 치면 아래와 같이 코드가 삽입된다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f4d86f4c51f10158576aa80496b48799/href">https://medium.com/media/f4d86f4c51f10158576aa80496b48799/href</a></iframe><p>성공! 코드가 삽입되었다.</p><p>알고나면 참 간단하지만 모른다면 고달픈 과정이다.</p><p>본 게시물이 조금이나마 다른 에디터분들에게 도움이 되면 좋겠다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5fe9fa74bb35" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[파이썬으로 블록체인 만들기 Part 2]]></title>
            <link>https://medium.com/caulink/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-part-2-633bb0555221?source=rss-93e6ff058dd2------2</link>
            <guid isPermaLink="false">https://medium.com/p/633bb0555221</guid>
            <category><![CDATA[blockchain]]></category>
            <category><![CDATA[coding]]></category>
            <category><![CDATA[technology]]></category>
            <category><![CDATA[blockchain-coding]]></category>
            <category><![CDATA[blockchain-technology]]></category>
            <dc:creator><![CDATA[Min Seo Park]]></dc:creator>
            <pubDate>Mon, 06 Aug 2018 02:03:11 GMT</pubDate>
            <atom:updated>2018-09-05T05:24:56.058Z</atom:updated>
            <content:encoded><![CDATA[<p><em>원본은 </em><a href="https://hackernoon.com/learn-blockchains-by-building-one-117428612f46"><em>https://hackernoon.com/learn-blockchains-by-building-one-117428612f46</em></a></p><p><em>원저자 : Daniel Van Flymen , </em><a href="https://twitter.com/van_flymen"><em>https://twitter.com/van_flymen</em></a></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*YEt9b9-l9ZTzbPr7_2GWcg.png" /></figure><p><a href="https://medium.com/caulink/파이썬으로-블록체인-만들기-part-1-4386dbc735e">part 1</a> 에 이어서 계속 구현해 나가도록 하겠습니다.</p><h3><strong>Step 3 : 블록체인 시스템 상에서 거래하기</strong></h3><p>이제 우리가 구현한 API 로 거래를 진행해 보려고 한다. 클래식한 방법인 cURL을 쓸 수도 있고, Postman 을 사용해도 된다.</p><p>서버를 만든다 :</p><pre>$ pyhton blockchain.py</pre><pre>* Running on <a href="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a> (Press CTRL+C to quit)</pre><p>이제 GET 요청을 이용하여 블록을 채굴해보자</p><pre>http://localhost:5000/mine</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*MU5Fp8ayTy10RCJlVPFpcA.png" /><figcaption>&lt;New Block Forged 라는 메세지와 함께 블록이 채굴 되었다.&gt;</figcaption></figure><p>transaction 으로는 오직 1개 밖에 없다. 왜냐하면 이 블록은 새로 채굴된 블록이기에 블록 채굴자에 대한 보상으로 발생한 거래 밖에 없기 때문이다. Part 1에서 잠깐 언급했듯이 보상에 대한 거래는 recipient 만 존재하고 sender 는 존재하지 않게 된다.</p><p>이번에는 새로운 거래를 기존에 정해놓은 거래의 형식에 맞추어 아래의 명령어를 사용하고 POST 요청을 통해서 만들어보자.</p><pre>http://localhost:5000/transactions/new</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*YMSiAqRBSxOTpGwMIhx8jg.png" /><figcaption>&lt;sender 와 recipient 의 주소를 넣어서 거래를 진행한다.&gt;</figcaption></figure><p>만약에 Postman 을 이용하지 않는다면, 아래의 명령을 이용하여 똑같이 요청을 할 수 있다.</p><pre>$ curl -X POST -H “Content-Type: application/json” -d’{<br> “sender” : “d4ee26eee15148ee92c6cd394edd974e”,<br> “recipient” : “someone-other-address”,<br> “amount” : 5<br>}’ “<a href="http://localhost:5000/transactions/new">http://localhost:5000/transactions/new</a>”</pre><p>거래 요청을 보낸 후에, 수번의 채굴을 다시 하고 난 후, 전체 체인을 http://localhost:5000/chain: 에 요청하여 살펴보자. 7번 블록의 transactions 부분에 거래 내역이 담겨 있음을 확인할 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*oUAcLnAT0SnO8RILoV05WA.png" /><figcaption>&lt;7번 블록에 거래내역이 담겨있다.&gt;</figcaption></figure><h3>Step 4 : 합의 (Consensus)</h3><p>이 부분이 많은 것들이 일어나는 부분이다. 우리는 이제 거래를 승낙하고 새로운 블록을 캘 수 있는 기본적인 블록체인을 갖게 되었다. 그런데, 블록체인에 있어서 가장 중요한 점은 ‘탈중앙화’ 되어야 한다는 것이다. 그리고 만약에 그것이 탈중앙화 되었다면 어떻게 우리가 모든 노드들이 같은 체인을 가지고 있는지 그리고 누구의 노드가 유효한 노드인지 확인할 수 있을까? 그 문제를 해결하는 것이 바로 ‘합의 알고리즘’ 이다.</p><h4>새로운 노드 등록하기</h4><p>합의 알고리즘을 적용하기 전에 우리는 네트워크에 있는 이웃 노드들이 누군지를 알아내는 방법이 필요하다. 우리 네트워크의 각 노드들은 네트워크 내 다른 노드들의 정보를 가지고 있어야 한다. 그러므로 우리는 몇가지 endpoint 들이 필요하다:</p><ul><li>/nodes/register : URL 형태로 새로운 노드들을 등록하고 노드 리스트를 받아냄</li><li>/nodes/resolve : 가장 긴 체인을 가지고 있는 노드가 정확한 체인을 가지고 있다는 가정아래, 모든 분쟁을 해결할 수 있는 합의 알고리즘을 적용함</li></ul><p>위의 2가지 기능을 이제 구현해 보자 :</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/6846d83b2f3165bd4139e101892a090b/href">https://medium.com/media/6846d83b2f3165bd4139e101892a090b/href</a></iframe><p>set() 는 노드의 리스트를 포함하기 위해서 사용됨을 알 수 있다. 이것이 새로운 노드가 멱등원임을 보증하는 가장 쉬운 방법이다 - 즉, 아무리 많이 특정 노드를 더해도 오직 한번만 추가되어 나타난 다는 것이다.</p><h4>합의 알고리즘 적용하기</h4><p>Part 1에서도 잠깐 언급했다싶이, 한 노드가 다른 노드와 서로 각기 다른 체인을 가지고 있을 때, 이 문제를 해결하기 위해 가장 긴 검증된 체인이 권위적이다 라는 규칙을 만들자. 다르게 말하면, 네트워크의 가장 긴 체인이 사실상의 체인이라는 것이다. 이 알고리즘을 이용하면, 우리의 네트워크 내의 노드들 간 서로 다른 체인을 보유하고 있을 시 합의 할 수 있게 된다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/790d425604d8587a1afa7ee4482e2513/href">https://medium.com/media/790d425604d8587a1afa7ee4482e2513/href</a></iframe><p>첫 번째 함수 valid_method() 는 노드가 보유하고 있는 체인이 유효한지를 체크하는 역할을 한다. ( 각각의 블록의 hash 와 proof 값이 맞는지를 확인하면서)</p><p>resolve_conflicts()는 모든 이웃 노드들로 하여금, 그들의 체인을 다운 받고 위의 규칙에 의거(가장 긴 체인이 맞는 체인이다)하여 유효한 체인(가장 긴 체인을 보유하고 있는지)인지를 확인하는 함수이다. 만약에 valid chain 이 우리의 것보다 더 길다면, 우리 것은 대체된다.</p><p>우리의 API 에 2개의 endpoint 를 등록하자, 하나는 이웃 노드들을 더하기 위함 다른 하나는 체인 길이가 서로 다를 때, 유효한 체인등록을 하여 모든 모드가 같은 체인을 갖게 하기 위함이다.</p><p>여기서 다른 기계를 사용해도 되고 그냥 하나의 네트워크에서 여러 노드들을 돌아가게 해도 된다. nodes/register을 통하여 다른 노드들을 등록한다. 필자는 3개의 노드를 돌리고 있었으므로, 5000번에 5001, 5002 번을 등록하였다. (5001, 5002번에도 똑같이 해준다.)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*0oQgnMlNV3MoVhVdFnkZ-g.png" /><figcaption>&lt;New nodes have been added 라는 메세지와 함께 이웃노드로서 등록된다.&gt;</figcaption></figure><p>1번째 노드(5000번) 에서 새로운 블록들을 많이 채굴한다, 그리고 이 체인이 2,3(5001, 5002번)번째 보다 더 긴 것임을 확인한다.</p><p>그런 후에, GET/nodes/resolve을 사용하여 컨센서스 알고리즘에 의해서 체인이 대체될 2,3번 노드에서 요청한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*2XbZTpv3rBK2CaxowHPSPw.png" /><figcaption>&lt;”Our chain was replaced” 라는 메세지와 함께 체인이 교체되었다.&gt;</figcaption></figure><p>더 짧은 체인을 가지고 있었던 5002번의 체인은 교체가 되고 Our chain was replaced 라는 메세지와 함께 체인이 바뀌게 된다. <br>(필자가 글을 쓰면서 이것저것 많이 시도해봤었기 때문에, 모든 스크린샷이 하나의 상황을 대표하고 있다고는 할 수없다. 하지만, 이웃 노드들 보다 더 짧은 체인을 가지고 있는 노드가 체인을 더 긴 것으로 교체하는 상황임은 잘 알 수있다.)</p><p>위의 튜토리얼을 그대로 따라해보고 연습한다면, 블록체인을 이해하고 추가로 개발하는데 있어서 훨씬 편해질 것이다. 본 게시물에서 보여지는 블록체인은 Bitcoin 계열의 블록체인이고 그 구현과정에서 보여지는 기능이 모두 Bitcoin 에도 있다는 것을 알 수 있다.</p><p>물론, 위의 블록체인이 완벽하다고 할 수는 없다. 예를 들면, merkle tree 구조나 난이도 조정 문제 잔고에 따른 거래 거부 등은 포함하고 있지 않다. 하지만, 본 게시물만큼 직관적이고 기본적이면서 강력한 게시물은 찾기 힘들 것이라고 자신 할 수 있다.</p><p>다시 한번, 번역하여 재배포를 허락해준 원 저자 Daniel Van Flymen , <a href="https://twitter.com/van_flymen">https://twitter.com/van_flymen</a> 에게 감사하다는 말을 전하고 싶다.</p><p>본 블록체인에 대한 구현 동영상 강의도 중앙대학교 블록체인 학회 C-Link 의<a href="http://www.facebook.com/cauclink"> 페이스북 페이지</a>, <a href="http://medium.com/caulink">미디엄</a> 그리고 <a href="https://www.youtube.com/channel/UCaTS8bDdsyV13c0UIJ-YF-Q?view_as=subscriber">유투브 채널</a>에 올라갈 것이다. 글을 보고 이해가 안된 부분은 동영상을 보면서 보완할 수 있을 것이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=633bb0555221" width="1" height="1"><hr><p><a href="https://medium.com/caulink/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-part-2-633bb0555221">파이썬으로 블록체인 만들기 Part 2</a> was originally published in <a href="https://medium.com/caulink">CauLink</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[파이썬으로 블록체인 만들기 Part 1]]></title>
            <link>https://medium.com/caulink/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-part-1-4386dbc735e?source=rss-93e6ff058dd2------2</link>
            <guid isPermaLink="false">https://medium.com/p/4386dbc735e</guid>
            <category><![CDATA[coding]]></category>
            <category><![CDATA[blockchain-technology]]></category>
            <category><![CDATA[causes]]></category>
            <category><![CDATA[blockchain]]></category>
            <category><![CDATA[caublockchain]]></category>
            <dc:creator><![CDATA[Min Seo Park]]></dc:creator>
            <pubDate>Wed, 25 Jul 2018 08:38:08 GMT</pubDate>
            <atom:updated>2018-09-05T05:23:40.613Z</atom:updated>
            <content:encoded><![CDATA[<p><em>원본 : </em><a href="https://hackernoon.com/learn-blockchains-by-building-one-117428612f46"><em>https://hackernoon.com/learn-blockchains-by-building-one-117428612f46</em></a></p><p><em>원저자 : Daniel Van Flymen , </em><a href="https://twitter.com/van_flymen"><em>https://twitter.com/van_flymen</em></a></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*O-v-jJfTg6rPQoce3nLT9Q.png" /><figcaption>파이썬으로 블록체인 만들기</figcaption></figure><p>수많은 사람들은 암호화폐의 부상에 대해 큰 관심을 가지고 있다.</p><p>그리고 많은 사람들은 블록체인이 어떻게 작동하는지 알고 싶어할 것이다. 그 이름 뒤에 있는 기본적인 기술에 대해서 말이다. 그러나 블록체인을 이해하기는 쉽지 않다. 적어도 필자에게는 그러하였다.</p><p>다양한 비디오들과 튜토리얼을 따라 공부하면서 노력하였지만, 너무 예시들이 적어서 좌절을 하곤 하였다. 필자는 무언가를 만들면서 배우는 것을 좋아한다. 이렇게 하면, 코드 레벨에서 문제점을 해결할 수 있게 된다.</p><p>이 가이드를 따라하고 복습한다면 당신도 결국 블록체인이 어떻게 작동하는지도 알게 될 것이고 당신만의 블록체인을 만들 수 있게 될 것이다.</p><h4><strong>시작하기 전에</strong></h4><p>블록체인은 변경불가능하고 블록이라고 불리우는 기록의 연속된 체인이다. 블록체인에는 거래 , 파일 그리고 당신이 원하는 데이터(그게 뭐든지) 들을 포함할 수 있다. 중요한 것은 “해쉬”를 이용해서 다 같이 “연결되어져” 있다는 것이다.</p><p>만약에 해쉬가 정확하게 무엇인지 모르겠으면<a href="https://learncryptography.com/hash-functions/what-are-hash-functions"> 이곳</a>을 클릭하라.</p><p>이 가이드는 파이썬에 대한 기본지식이 있고 다루는 것에 크게 불편함을 느끼지 않는 사람들을 대상으로 작성된 글이다.또한, HTTP 를 통하여 블록체인이 어떻게 작동하는지 설명할 것이기 때문에 HTTP에 대한 기본 지식이 있어야 읽고 이해하는데 편할 것이다.</p><p><strong>준비물 : Python 3.6+ 와 Flask 라는 라이브러리를 사전에 설치해야한다.</strong></p><p><strong>&gt;&gt;&gt; pip install Flask==0.12.2 requests==2.18.4</strong></p><p><strong>&gt;&gt;&gt; pip install - -upgrade pip</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*sRMmuDc1XfGDn21r" /></figure><h3><strong>Step 1 : 블록체인 만들기</strong></h3><p>개인적으로 선호하는 IDE(VS Code, Pycharm, Jupyter Notebook 등등) 를 틀고 새로운 파일을 만들자.</p><p>blockchain.py 라는 이름으로 말이다. 사실 다른 이름으로 해도 되기는 한다.</p><p>우리는 하나의 파일만 쓸 것이다. 하지만 중간에 헷갈리거나 진도를 놓치게 된다면<a href="https://github.com/dvf/blockchain"> 소스코드</a>를 참고하라.</p><h4><strong>블록체인 표현하기</strong></h4><p>자 이제 Blockchain 클래스를 만들자. 이 클래스에는 초기의 비어있는 리스트(우리의 블록체인을 저장할 곳) , 그리고 다른 거래들이 저장된다. 아래에 코드로 클래스의 청사진이 제시되어 있다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f4d86f4c51f10158576aa80496b48799/href">https://medium.com/media/f4d86f4c51f10158576aa80496b48799/href</a></iframe><p>Blockchain클래스는 체인을 관리하는 역할을 한다. 블록체인 클래스에는 거래와 체인에 새로운 블록 추가하는 기능들이 있다. 자 그럼 이제 그 기능들을 한번 구현해보자.</p><p><strong>블록은 어떻게 생겼는가?</strong></p><p>각 블록은 인덱스, 타임스탬프(UNIX Time), 거래 내역, 증명 그리고 이전 블록의 해쉬를 가지고있다.</p><p>아래에 블록이 어떻게 생겼는지에 대한 예시가 나와있다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/fcded10fcd8cc68c5c47ce646e1afecc/href">https://medium.com/media/fcded10fcd8cc68c5c47ce646e1afecc/href</a></iframe><p>위 코드를 보면 블록과 체인에 대한 구조를 더 정확하게 이해할 수 있게 될 것이다. 각 블록은 그 이전 블록의 해쉬를 모두 포함하고 있다.(previous_hash). 이 특징은 상당히 중요하다. 왜냐하면 <strong>위 코드가 바로 블록체인에 변경 불가능성(immutabiltiy) 을 넣어주기 때문</strong>이다. 만약 공격자가 체인에서 특정 블록의 정보를 변경시키려고 한다면, 그에 부속된 모든 블록들이 잘못된 해쉬를 갖게 될 것이다.</p><p><strong>블록에 거래 더하기</strong></p><p>블록에 거래를 추가할 방법이 필요하다. new_transaction( )이 이를 위해서 필요하다. 이제 부터 이 부분을 추가로 구현해보자.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/a2ce1ea0e6dbb1892bdbd3fac748355b/href">https://medium.com/media/a2ce1ea0e6dbb1892bdbd3fac748355b/href</a></iframe><p>new_transaction()가 리스트에 거래를 추가하고 나면, 거래가 추가 될 블록의 인덱스를 반환한다.</p><p><strong>새로운 블록 만들기</strong></p><p>우리 Blockchain이 인스턴스화 되었을 때, 반드시 ‘genesis block’ 이 필요하다. — 이전 블록이 없는 최초의 블록. 또한 ‘genesis block’ 에 ‘proof(증명)’ 을 추가해야 한다. 채굴은 추후에 더 얘기하도록 하자.</p><p>추가로 ‘genesis block’ 을 만드는 것 이외로, new_block(), new_transaction(), hash() 을 구현하려고 한다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/4d29bdfbcc48beb9b19c5cd0dee3b822/href">https://medium.com/media/4d29bdfbcc48beb9b19c5cd0dee3b822/href</a></iframe><p>여기까지는 크게 어렵지 않다 — 코드 옆에 원작자가 설명을 주석으로 달아 놓았다. 우리의 블록체인을 표현하는 것에 있어서는 거의 작업이 마무리 되었다. 그러나 이 시점에서, 어떻게 새로운 블록들이 만들어지고 저장되고 채굴 되는지 궁금할 것이다.</p><p><strong>작업 증명에 대한 이해</strong></p><p>작업 증명 알고리즘(PoW) 는 어떻게 새 블록이 생성되고 채굴되는지를 보여주는 알고리즘이다. PoW 의 목표는 문제를 푸는 숫자 즉, 답을 찾는 것이다. 그 숫자는 찾기는 어렵지만 네트워크 내의 누구에 의해서 라도 증명은 쉬워야 할 것이다. 이것이 PoW 의 핵심 아이디어이다.</p><p>이해를 하기 위해서 정말 간단한 예시를 하나 들어보겠다.</p><p>특정 인수 x의 hash가 다른 인수 y 에 의해서 곱해지는데 반드시 0으로 끝난다고 가정해보자. 그러니까 hash(x * y) = ac23dc...0 .이렇게 말이다. 그리고 간편화된 예시에서 x 는 5로 고정하자. 그리고 이것을 파이썬으로 구현해보자 :</p><pre>from hashlib import sha256</pre><pre>x = 5<br>y = 0  # We don&#39;t know what y should be yet...</pre><pre>while sha256(f&#39;{x*y}&#39;.encode()).hexdigest()[-1] != &quot;0&quot;:<br>    y += 1</pre><pre>print(f&#39;The solution is y = {y}&#39;)</pre><p>y = 21 로 결과가 나올 것이다. 그리고 해쉬의 끝은 0이 되야 하기 때문에,</p><pre>hash(5 * 21) = 1253e9373e...5e3600155e860</pre><p>이처럼 나오게 될 것이다.</p><p>비트코인에서 PoW 알고리즘은<a href="https://en.wikipedia.org/wiki/Hashcash"> Hashcash</a> 라고 불리운다. 그리고 이것은 위의 예시와 그렇게 다르지 않다.이것이 바로 채굴자들이 새로운 블록을 생성하기 위해서 경쟁적으로 푸는 그 알고리즘이다. 일반적으로, 난이도는 string 에서 보여지는 문자의 개수(비트코인에서는 0의 개수)로 정해진다. 채굴자들은 그 해답에 대한 보상으로 코인을 받게 된다.</p><p>그리고 나면 이제 네트워크는 그들의 결과물을 쉽게 검증할 수 있다.</p><p><strong>간단한 PoW 구현하기</strong></p><p>우리의 블록체인에서 간단한 알고리즘을 구현해보자. 여기에서의 규칙 역시 위의 예시와 비슷할 것이다</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f638f00b616b33724ab154622a6f3fc0/href">https://medium.com/media/f638f00b616b33724ab154622a6f3fc0/href</a></iframe><p>난이도를 조정하려면 0 의 개수를 바꾸면 된다(원래 비트코인은 그렇게 작동된다). 그런데 여기서 구현할 때는 0 의 개수를 고정하여 난이도를 고정 시켜놨다. 4 정도면 충분하다.</p><p>0 이 앞에 1개라도 더 붙으면 엄청나게 달라지고 그에 따라서 해답을 찾는데 소요되는 시간도 엄청나게 달라지게 된다.</p><p>이제 구현은 거의 끝났고 HTTP 요청을 이용하여 상호 거래를 해보려고 한다.</p><h3><strong>Step 2 : API 로서의 블록체인</strong></h3><p>이제 Python Flask 프레임워크를 쓰려고 한다. Python Flask 프레임워크는 micro — framework 이고 파이썬 함수의 endpoint 설계하는데 유용하다. 그리고 HTTP 요청을 사용하여 웹 기반으로 우리가 짠 블록체인에게 명령을 내릴 수 있게 해준다.</p><p>여기서 3가지 방법을 사용하고자 한다 :</p><ul><li>/transactions/new 블록에 새로운 거래를 만드는 방법</li><li>/mine 서버에게 새로운 블록을 채굴하라고 명령하는 방법</li><li>/chain 전체 블록체인을 받아내는 방법</li></ul><p><strong>플라스크 설치</strong></p><p>우리의 “서버”는 블록체인 네트워크에서 단일 노드를 생성할 것이다. 자 그럼 이제 상용구 코드를 한 번 짜보자 :</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9bdaa2a7b07930b131c15df9deaca5e8/href">https://medium.com/media/9bdaa2a7b07930b131c15df9deaca5e8/href</a></iframe><p>위의 코드들에 대해서 간단하게 추가 설명을 하고자 한다</p><ul><li>15번째 줄 : 우리의 노드를 인스턴스화한다. 자세한 사항은 여기 <a href="http://flask.pocoo.org/docs/0.12/quickstart/#a-minimal-application">플라스크에 관한 글</a>에서 보라.</li><li>18번째 줄 : 우리의 노드의 이름을 임의로 설정한다.</li><li>21번째 줄 : Blockchain 클래스를 인스턴스화한다.</li><li>24–26번째 줄 : /mine 의 endpoint를 만든다. (요청을 GET 하는 곳이다.)</li><li>28–30번째 줄 : /transactions/new 의 endpoint를 만든다. (여기에 우리가 데이터를 보내고 요청을 POST하는 곳이다.)</li><li>32–38번째 줄 : /chain 의 endpoint를 만든다. (전체 블록체인을 반환하는 곳이다.)</li><li>40–41번째 줄 : 포트 5000번에서 서버를 돌리는 것이다.</li></ul><p><strong>거래의 endpoint</strong></p><p>아래에 거래 요청의 생김새가 묘사되어 있다. 이것이 바로 유저가 서버에게 보내는 형태이다.</p><pre>{<br> &quot;sender&quot;: &quot;my address&quot;,<br> &quot;recipient&quot;: &quot;someone else&#39;s address&quot;,<br> &quot;amount&quot;: 5<br>}</pre><p>블록에 거래를 추가하기 위해서 사용되는 클래스 메소드는 이미 있기 때문에, 나머지는 쉽다. 거래 추가를 위한 함수를 코드로 구현하자 :</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/93966176b6271411eec0ba3a6adb9239/href">https://medium.com/media/93966176b6271411eec0ba3a6adb9239/href</a></iframe><p><strong>채굴의 endpoint</strong></p><p>채굴의 endpoint, 이곳이 바로 많은 것들이 일어나는 곳이다. 이 부분에서는 3가지 일을 수행한다.</p><ol><li>PoW 를 계산한다.</li><li>채굴자에게 거래를 추가한 것에 대한 보상으로 1코인을 준다.</li><li>새 블록을 체인에 추가한다.</li></ol><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f1951b57ce40572d1bb3a0eef766fdd6/href">https://medium.com/media/f1951b57ce40572d1bb3a0eef766fdd6/href</a></iframe><p>sender 의 주소가 0으로 되어있다. 블록체인에서 새로운 블록을 채굴하면 그에 대한 보상을 받는다. 그렇기에, 채굴을 통해서 받은 코인은 sender 가 존재하지 않는다. 채굴된 블록에 대한 보상의 수신자가 우리 노드(채굴한 노드)의 주소이다.</p><p>블록체인의 기본적인 구조를 코드로서 하나하나 구현해 보았다. 거래 및 합의 과정에 대한 구현은 <a href="https://medium.com/caulink/파이썬으로-블록체인-만들기-part-2-633bb0555221">Part 2</a> 에서 설명될 것이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4386dbc735e" width="1" height="1"><hr><p><a href="https://medium.com/caulink/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-part-1-4386dbc735e">파이썬으로 블록체인 만들기 Part 1</a> was originally published in <a href="https://medium.com/caulink">CauLink</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[블록체인을 어떻게 받아들일 것인가?]]></title>
            <link>https://medium.com/caulink/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8%EC%9D%84-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%B0%9B%EC%95%84%EB%93%A4%EC%9D%BC-%EA%B2%83%EC%9D%B8%EA%B0%80-c19d4d1ca3fd?source=rss-93e6ff058dd2------2</link>
            <guid isPermaLink="false">https://medium.com/p/c19d4d1ca3fd</guid>
            <category><![CDATA[university]]></category>
            <category><![CDATA[cryptocurrency]]></category>
            <category><![CDATA[blockchain-technology]]></category>
            <category><![CDATA[cauclink]]></category>
            <category><![CDATA[blockchain]]></category>
            <dc:creator><![CDATA[Min Seo Park]]></dc:creator>
            <pubDate>Thu, 07 Jun 2018 07:55:34 GMT</pubDate>
            <atom:updated>2018-06-13T16:09:57.100Z</atom:updated>
            <content:encoded><![CDATA[<p>By 박민서 , C-Link</p><p><strong>블록체인 입문</strong></p><p>필자는 작년 가을에 암호화폐 광풍이 불기 시작할 때부터 블록체인, 암호화폐에 관심을 가지기 시작했다. 투자엔 성공했지만 상당히 불편하고 찝찝했다. 이게 뭔지도 모르겠고, 값이 오르는 이유는 더더욱 몰랐기 때문이다. 가치에 대해 생각하게 되면서, 자연스럽게 각 코인에 대한 공부를 하기 시작했고 블록체인에 입문하게 되었다. 많은 사람들이 이렇게 블록체인에 입문했을 것이다. 하지만, 그렇게 입문한 만큼 큰 의문이 생길 것이다. ‘사람들이 블록체인을 어떻게 받아들이고 있는가?’ 그리고 ‘나는 어떻게 받아들여야 하는가?’</p><p><strong>블록체인 현재 상황</strong></p><p>지금 블록체인 분야가 핫한 것은 맞다. 뉴스만 보고 있자면 블록체인이 마치, 온갖 산업분야에 당장이라도 적용될 것 같다. 하지만, 실제로 그 기술을 똑바로 구현하는 회사나 집단은 찾아보기 힘들고 언제 적용될 수 있을지에 대해서도 미지수다. 단지 계획과 전망에 대해서만 논할 뿐 그 계획에 상응하는 성과를 내는 곳은 거의 없다.</p><p>블록체인 분야를 한마디로 표현하자면 ‘무법지대’이다. 용어에 대한 제대로 된 정의나 분야의 특별한 권위자가 있다고 보기 힘들다. 그렇기에 대부분의 사람들은 대기업과 글로벌 컨설팅 회사의 블록체인을 도입하면 ‘비용을 반으로 절감할 수 있다’, ‘소요시간을 10분의 1로 줄일 수 있다’ 등의 보고서와 SNS에 블록체인 관련 게시물 몇 개 올려놓고 전문가라고 자청하는 사람들의 정보들을 비판적 시각과 필터링 없이 그대로 받아들이고 있다. 이러한 현상은 올바른 블록체인 생태계 정착에 아주 좋지 않을 것이다.</p><p>온갖 곳에서 수 많은 보고서와 검증되지 않은 정보들이 쏟아지고 있는 정신없는 현 상황에서 우리는 어떻게 행동 해야할까?</p><p><strong>블록체인 분야의 발전을 위해</strong></p><p>블록체인을 정확하게 이해하고 기존의 정보들을 곧이 곧대로 받아들이면 안된다. 필요한 것들은 취사선택하고, 옳지 않은 것들에 대해서는 끊임없이 문제제기를 해야 한다. 그렇게 생태계가 올바른 방향으로 흘러갈 수 있게 자정작용을 해야한다. 또 올바른 정의를 내리고 새로운 기술을 구현함으로써 발전시켜야 한다.</p><p>블록체인이 발전하기 위해서는 기술의 실용화가 되어야 하는데 그것이 현재로서는 가장 큰 문제이다. 대표적으로 탈중앙화에 대한 얘기를 할 때, 같이 나오는 문제점은 바로 속도와 효율성이다.</p><p>속도에 관한 고민을 하기 시작하면 자연스럽게 이런 질문들을 하게 된다. 비트코인의 TPS는 얼마인가? 이더리움은? 이더리움이 그 문제를 해결하기 위해 샤딩을 도입한다고 하던데? 속도 차이는 합의 알고리즘 때문에 생기는거야? 샤딩은 무엇인가? 근데 TPS가 뭐야? 소위 말하는 1,2,3 세대 코인은 어떤 차이점이 있지?</p><p>저 질문들에 대한 답 모두가 곧 블록체인의 발전과 실용화를 앞당기는 해결 방법이 될 것이고 우리는 바로 이러한 질문들에 대한 답을 찾기 위한 노력을 해야한다.</p><p><strong>비판적 시각과 필터링</strong></p><p>블록체인에 대한 다양한 정보들을 접할 때는 비판적 시각으로 바라보고 자체 필터링을 해야한다. 예를 들어, 특정 분야에 블록체인을 새로 도입하겠다는 내용의 글을 읽을 때 필자는 항상 이 질문을 한다. ‘여기에 꼭 블록체인을 도입해야 하는가?’</p><p>문제 해결 과정의 첫 번째는 문제가 있음을 인지하는 것이다. 그렇기에, 현 시스템에서 어떤 부분이 문제인지 과연 그 부분을 어떤 식으로 해결할 수 있는 지에 대한 분석이 필요하다. 문제점을 정확하게 파악했다면 알맞는 해결책을 찾아야 한다. 여기서 만약 블록체인 말고도 더 효율적으로 문제해결을 할 수 있는 방안이 있다면 굳이 블록체인을 적용하지 않아도 된다. 다양한 문제해결 방법에 따른 결과를 비교해 봤을 때 블록체인이 가장 효율적이라는 결론이 나면 비로소 그 때 블록체인을 적용할 만한 가치가 있는 분야라고 판단한다.</p><p>이렇게 자체적으로 성립한 일련의 필터링 과정없이 그대로 받아들이게 된다면 그 정보의 진위 판별도 못할 뿐 아니라, 잘못된 정보를 그대로 받아들이는 문제가 생기게 된다. 그렇다면 정보가 옳고 그름은 어떻게 판별할까? 블록체인의 본질에 집중하고 공부해야 한다.</p><p><strong>그래서 블록체인을 어떻게 받아들여야 하는가?</strong></p><p>블록체인이 만능열쇠라고 생각하지 말자. 또 암호화폐를 대박 터뜨릴 수 있는 투기의 대상으로 보지 말자. 블록체인 그 본질에 집중하자. 본질에 집중하여 정확하게 이해하고 기존의 정보들을 비판적인 시각으로 바라보아야 하며, 본질을 최대한 해치지 않는 선에서 실용화 방안을 생각해야 한다.</p><p>블록체인을 공부하는 사람들의 학회, 집단에 들어가서 같이 연구하고 의견을 주고 받으며 실력을 키워야 하고 기존의 컨텐츠에 대해서 잘못된 점은 날카롭게 비판하고 끊임없이 블록체인의 문제점을 제기하며 그 해결방법에 대해서 연구해야 한다. 분야에 제대로 된 전문가가 없다는 것은 곧 기회가 많다는 것이다. 독자들도 이 기회를 놓치지 말고 이 분야에 파고들어 새로운 길을 여는 선구자가 되길 바란다.</p><p>필자도 학회원들과 함께 현재 짙게 껴있는 투기성을 걷어내고 블록체인 그 본질에 집중하고 현재 대두되고 있는 문제점들을 하나하나 풀어가고자 한다.</p><p><em>“우리는 블록체인의 본질을 이해하고 공부, 직접 개발하여 사회문제를 해결하고 다양한 분야로 진출하여 사회 발전에 이바지하고 올바른 블록체인 생태계 구축에 앞서고자 한다.” (C-Link 학회 비전 및 목표)</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c19d4d1ca3fd" width="1" height="1"><hr><p><a href="https://medium.com/caulink/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8%EC%9D%84-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%B0%9B%EC%95%84%EB%93%A4%EC%9D%BC-%EA%B2%83%EC%9D%B8%EA%B0%80-c19d4d1ca3fd">블록체인을 어떻게 받아들일 것인가?</a> was originally published in <a href="https://medium.com/caulink">CauLink</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
    </channel>
</rss>