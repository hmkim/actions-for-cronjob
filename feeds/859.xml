<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by 철학자(philosopher) on Medium]]></title>
        <description><![CDATA[Stories by 철학자(philosopher) on Medium]]></description>
        <link>https://medium.com/@soonhyungjung?source=rss-a1d81cba82b0------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*K7N7DmgBXF8vUvUWdBFZpw.png</url>
            <title>Stories by 철학자(philosopher) on Medium</title>
            <link>https://medium.com/@soonhyungjung?source=rss-a1d81cba82b0------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Sun, 12 May 2019 13:32:43 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@soonhyungjung" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[춤추는 철학자의 문제, 검증 게임 그리고 사이드 체인과 데이터 가용성(Dancing philosophers problem, verification game, sidechain…]]></title>
            <link>https://medium.com/@soonhyungjung/%EC%B6%A4%EC%B6%94%EB%8A%94-%EC%B2%A0%ED%95%99%EC%9E%90%EC%9D%98-%EB%AC%B8%EC%A0%9C-%EA%B2%80%EC%A6%9D-%EA%B2%8C%EC%9E%84-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%B2%B4%EC%9D%B8%EA%B3%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B0%80%EC%9A%A9%EC%84%B1-dancing-philosophers-problem-verification-game-sidechain-a196f3547841?source=rss-a1d81cba82b0------2</link>
            <guid isPermaLink="false">https://medium.com/p/a196f3547841</guid>
            <category><![CDATA[sidechains]]></category>
            <category><![CDATA[ethereum]]></category>
            <category><![CDATA[philosophers-game]]></category>
            <category><![CDATA[plasma]]></category>
            <category><![CDATA[플라즈마]]></category>
            <dc:creator><![CDATA[철학자(philosopher)]]></dc:creator>
            <pubDate>Sun, 14 Oct 2018 20:03:32 GMT</pubDate>
            <atom:updated>2018-10-14T20:03:32.239Z</atom:updated>
            <content:encoded><![CDATA[<h3>춤추는 철학자의 문제, 검증 게임 그리고 사이드 체인과 데이터 가용성(Dancing philosophers problem, verification game, sidechain and data availability)</h3><blockquote>“컴퓨터가 생각할 수 있다는 것은 잠수함이 수영할 수 있다는 것과 같다” — 에츠허르 다익스트라</blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*qVkFAWh3w0ZXZyu3.jpg" /><figcaption>의외로 섹시한(?) 철학자들</figcaption></figure><h3>들어가는글</h3><p>안녕하세요. <a href="https://medium.com/u/a1d81cba82b0">철학자(philosopher)</a>입니다.</p><p>춤추는 철학자의 문제(dancing philosophers problem)란 <a href="https://www.facebook.com/OntherInc/videos/1606518396119470/?fref=mentions&amp;hc_location=group">온더의 지난 플라즈마 살펴보기 세미나[01:19:07]</a>에서 트루빗(Truebit)이 제안 했던 검증 게임(verification game)을 즐겁게 설명하기 위해 만들어낸 예시입니다.(철학자가 만든 철학자네요)</p><p>손쉬운 논리 문제를 통해서 블록체인(사이드 체인) 기술자들 사이에서 논란의 중심이자 난제인 <strong>데이터 가용성(Data Availability)</strong> 문제가 발생한 맥락에 대한 힌트를 얻어가시기를 바랍니다.(이게 가능하면 여러분은 초고수를 넘어보린 초굇수! 이크요잇!)</p><h3>상황 정의(1)— 카메라 앞에서 춤추는 철학자들</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*vJ9_IZJPcl4j8n5i2UZl5A.png" /><figcaption>그림1 : 카메라 앞에서 춤추는 철학자들</figcaption></figure><p>춤추는 철학자의 문제에는 총 다섯 종류의 주인공이 나옵니다. <em>i)</em><strong><em>규칙(Rule)</em></strong><em>, ii)</em><strong><em>심판(Judge)</em></strong><em>, iii)</em><strong><em>벽</em></strong><em>, iv)</em><strong><em>카메라</em></strong><em>, v)</em><strong><em>철학자</em>들</strong>로 구성되어 있습니다.</p><p>무대에는 철학자 두명이 <strong>규칙</strong>이 정의된 춤을 반복하고 있습니다. 그리고 <strong>카메라</strong>가 그들을 찍고 있습니다. <strong>심판</strong>은 <strong>벽</strong> 뒤에 있고, <em>벽 너머의 상황을 알 수 없습니다.</em> 두 철학자는 같은 (ㅁㅊㄴ처럼)춤을 반복 하는데, 심판은 벽 너머의 상황을 직접 볼 수 없습니다. 그럼에도 불구하고 심판은 벽 밖의 상황을 판단해야 합니다. 더해서 심판의 책상이 매우 작은 데다가 신중한 사람이라 <strong>한번에 2컷씩 밖에 비교하지 못한다고 가정</strong>합시다. 따라서 전체 필름을 가져와서 검토받는 것이 아니라, 필름을 짤라서 가져가야 합니다. 춤은 항상 같은 동작으로 시작하는데, <strong>때때로 두 사람의 춤이 엇갈립니다</strong>. 게다가 두 사람은 서로 자기가 맞다고 우기고 있죠!<em>춤추는 철학자의 문제</em>란 이 두 사람 중 <strong>누가 틀렸는지 최소한으로 심판이 판단하는 방법과 결과</strong>에 관한 문제입니다.</p><p>안무의 “<strong><em>규칙(Rule)</em></strong><em>”</em>을 다음과 같이 정의해보겠습니다.</p><blockquote>1.한 박자의 단 하나의 동작만 할 수 있다</blockquote><blockquote>2.손을 위로 뻗거나, 아래로 뻗는 동작만 할 수 있다</blockquote><blockquote>3.이전 박자의 동작과 동일한 동작을 할 수 없다. 즉 계속 바꿔야 한다.</blockquote><p>음악이 시작되고 철학자 A와 B는 같은 동작으로 안무를 시작합니다. 그런데 15박자가 지났는데 두 사람의 동작이 엇갈렸습니다.</p><p>이때, 과연 A와 B중 1)<strong>누가</strong>, 2)<strong>언제 </strong>틀렸으며<strong> </strong>이를<strong> 3)최소한의 심판 횟수</strong>만으로 알아낼 수 있을까요? 이제부터 안무에 대한 <strong>검증 게임(verification game)</strong>이 시작됩니다.</p><h3>상황 정의(2) — 댄싱 검증 게임</h3><p>춤은 항상 같은 동작으로 시작한다 가정했고, 마지막 동작은 틀린 상황이 찍힌 필름을 그림으로 나타내면 다음과 같습니다. 둘의 동작이 같으면 녹색, 다르면 붉은색으로 표시했습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*4-Vy9DGfvnIvZyGiPOJzQg.png" /><figcaption>그림2 : ,,어떤자식이냐?</figcaption></figure><p>위의 색인은 필름 번호이고(카메라 감독님이 <em>컴퓨터 공학</em>을 전공한 모양이군요. 인덱스가 0부터 시작합니다)</p><p>이 상황만을 가지고는 누가 틀렸는지 알기 어렵습니다. 이 상황을 타개하는 몇 가지 방법이 있습니다.</p><h3><strong>첫번째 알고리즘 : 처음부터 하나씩 다 들고간다</strong></h3><p>이 방법은 필름을 <strong>맨 앞부터 두 컷씩 잘라서 심판에게 계속 가져가는</strong> 방법입니다.</p><p>순서는 이렇습니다.</p><blockquote>[0,1] 두컷씩 가져가 비교 합니다.</blockquote><blockquote>[1,2] 두컷씩 가져가 비교 합니다.</blockquote><blockquote>[2,3] 두컷씩 가져가 비교 합니다.</blockquote><blockquote>…</blockquote><blockquote>[13,14] 두컷씩 가져가 비교 합니다.</blockquote><p><em>비교 과정 중 다행스럽게도</em> 끝까지 가지 않고, 7번째에 B철학자가 틀린걸 발견했습니다. 왈라~!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*wt2tFcto0yiqhrY5XgvAAQ.png" /><figcaption>그림3 : EXID 춤에 중독된 철학자들, 그리고 심판은 — “이ㅂㅅ들.. 계속 가지고 오네 귀찮게”</figcaption></figure><p>이때 심판은 <strong>몇 번 판단</strong>을 했나요? 그림에도 적어 뒀지만,<strong> 7번을 비교</strong>했습니다. 사실, 7번째라서 다행이지 만약 13번 인덱스에서 안무가 틀렸다면, <strong>최악의 상황에는 14번</strong>을 비교해야 합니다!</p><h3>두번째 알고리즘 : 계속 중간쯤 찍어서 계속 심판에게</h3><p>이 문제를 풀던 또 다른 빛나는 한 사람(국문명:참빛 , 영문명:Truebit — 이라 불리는 형님)은 또 다른 규칙을 제시 합니다.</p><blockquote>일단 필름 중간쯤을 대충 찍어서</blockquote><blockquote>그 부분을 가지고 와봐, 심판이 비교해줄게</blockquote><blockquote>if)만약 거기까지 이상이 없으면 다시 남은 필름의 중간을 찍어서 다시 심판한테 가져오고</blockquote><blockquote>else) 뭔가 이상하면 거기서 심판은 판단을 끝내버리면 된다. 잘못한 사람이 확실해졌으니까.</blockquote><p>만약 위와 같이 인덱스7에서 B가 두번찌른 상황과 같다면, 이 상황에서 심판은 몇 번 판단하는지 확인 해보겠습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*zrLL7ha1oEnrTJXdl67JAw.png" /><figcaption>그림4 : 심판한테 대충 넣었는데, 한방에 “싸보렸다”..</figcaption></figure><p>규칙에 의해서 일단 대충 중간쯤인 7번을 찍고, [6, 7] 필름을 심판에게 들고갑니다. 철학자 A는 (위-아래)동작으로 규칙을 정확히 지켰고, 철학자 B는 (위-위) 동작을 함으로써 규칙을 어겼습니다. B가 잘못한 것으로 검증(verify)되었습니다.</p><p>얼핏 보기에 이 상황은 따로 심판에게 들고 가기 민망할 정도로, 직관적이고 명약관화(明若觀火)해 보이지만, 그렇게 보는 이유는 우리가 제3자의 시선으로 이 문제를 바라보기 때문입니다. 당사자 입장에서는 억울할 수도 있습니다.(사실..<em>뭐가 억울해.. 한명이 우기는건데</em>)</p><blockquote>세상에는 제3자가 보기에는 명확해 보이지만, 당사자의 입장에서는 논란인 상황이 매우 많습니다. 예를 들어 ICO를 한 프로젝트 입장에서는 선택한 플랫폼에서 발행한 토큰의 유동성이 떨어졌을 때 플랫폼을 바꿔 토큰을 더 찍어내는게 최선의 선택으로 보일 수 있지만, 그렇게 막(ㅁㄷㅂㄹㅊㄹ) <strong>귀뚜라미같이</strong> 점프 뛰는게 유행하면 <strong>떳다방 작전 플랫폼</strong>이 생겨나 결국 다른 영역에서 투자자의 피해가 생길 수 있죠. 사람사는 세상에는 이처럼 객관적인 상황보다 주관적인 상황이 더 많습니다.</blockquote><p>마침 우리 현실에는 사법제도라는 수백년 간 다듬어진, 완벽하지는 않지만 매우 발전된 제도가 있습니다. 양측이 서로 우기는 과정, 즉 송사가 일어나면 제3자인 재판관이 개입해 판단합니다.</p><p>마찬가지로 이러한 방식을 이 문제에 적용하면, <strong>심판은 [6,7]컷 딱 한번만</strong> 비교하면 됩니다. 이는 마치 법원에서 재판관이 논란이 되는 곳 중간쯤 찍어서 잘잘못을 판단하는 것과 같습니다. 좀 이상해 보입니다만, 이런 판단이 가능한 이유는 이 게임은 잘못을 했느냐 마느냐의 <strong>이분법적 판단</strong>이 필요할 뿐, 누가 얼마나 잘못했는지 잘못의 정도를 판단하는 것은 아니기 때문입니다. 거기다가 춤은 잘못한 순간을 제외하고는 규칙적으로 반복되고 있죠. 마치 <strong>컴퓨터</strong>처럼..</p><p>다시 문제로 돌아가서 이번에도 최악의 상황을 가정 해 볼까요? 철학자 B의 13번 동작이 틀린 상황에서 이 알고리즘이 동작하는 과정입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*pZgAHjXrq6rT-DhcXdb9fw.png" /><figcaption>그림5 : 네 번만에 결단났다. 중간에 하얀거 몰라도 된다.</figcaption></figure><p>CP는 체크포인트(Check Point)의 약자입니다. 처음 7번을 찍어서 판단을 받아봤는데 이상이 없었고, 그래서 남은 필름의 중간쯤 11번 CP를 찍었습니다. 그것도 이상 없어서 다시 중간쯤인 13번을 찍고, 그것도 이상없어서 14번을 마지막으로 검토받고 이 “<strong>게임</strong>”이 마무리 됩니다.(<strong>게임</strong>.. 소오름..제목참조)</p><p>이번에 <strong>단 4번의 판단</strong>만으로 이 논란을 종결시켰습니다. 사실 심판 입장에서 벽 <strong>우측에 하얀 물음표로 된 필름에서 일어났던 일이야 알바 아니고</strong>, 본인한테 들고온 필름만 판단하면 되는 것이죠. 앞의 방법보다 업무 부담도 많이 줄어듭니다. 부담이 줄어들었을 뿐만 아니라, 결과도 확실히 내었죠.</p><h3>첫번째와 두번째 알고리즘 비교</h3><p>두 알고리즘을 비교하면 다음 표와 같습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*KYKkUvnJr5bPpa7u09hSzg.png" /><figcaption>그림6 : 최악의 상황이 생긴다믄 두번째 알고리즘이 훨씬 낫쥬~</figcaption></figure><p>이를 컴퓨터 과학의 <a href="https://ko.wikipedia.org/wiki/%EA%B3%84%EC%82%B0_%EB%B3%B5%EC%9E%A1%EB%8F%84_%EC%9D%B4%EB%A1%A0">계산복잡도이론</a>에 근거해 표현하면 심판 입장에서 최악의 경우 첫번째 알고리즘은 O(N)의 시간 복잡도를 가지고 있고, 두번째 알고리즘은 O(logN)의 시간복잡도를 가지고 있다고 볼 수 있습니다. <a href="https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%EA%B2%80%EC%83%89_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">이진 탐색(Binary Search)</a>이라고도 하죠.</p><p>상황 정의(1)에 따르면 우리는 <strong>심판의 판단을 최소화하는</strong> 방법을 필요로 했으므로, 두번째 알고리즘이 더 적합하다고 할 수 있습니다.</p><p>이 두번째를 블록체인에 적용시킨 “참빛”형.. 그 형이 바로 <a href="https://people.cs.uchicago.edu/~teutsch/papers/truebit.pdf">Truebit</a>입니다. 그들은 이걸<strong> 트루빗 프로토콜(Truebit Protocol) </strong>혹은<strong> 검증게임(Verification Game)</strong>이라고 부릅니다.(오오오..! 드디어 나옴)</p><p>트루빗이 해결하고자 하는 문제는 온체인에서 일어나는 연산 부담을 오프체인으로 옮겨서 해결하면서도, 계산 과정이 아무런 문제 없이 이뤄지게 하는 데에 있습니다. 찾다보면 위의 필름 그림과 비슷하지만 다른 그림을 보게 되는데, 이 글 내용을 참조하시면 도움이 많이 됩니다. 트루빗에 대한 자세한 프로젝트의 목적과 방법 및 구현은 <a href="https://medium.com/decipher-media/truebit-681181846d93">문건기 님이 작성하신 글</a>과 <a href="https://medium.com/onther-tech/truebit-scrypt-interactive-implementation-502032ac173a">온더의 Carl Park(4000D)님께서 작성하신 글</a> 혹은 <a href="https://people.cs.uchicago.edu/~teutsch/papers/truebit.pdf">트루빗 백서</a>를 참조하시면 되고, 저는 조금만 더 철학자의 몹쓸 몸동작을 좀 더 지켜 보도록 하겠습니다. 이번에는 이더리움이라는 옷을 입고 춤을 춥니다. 옷입기 전에, <strong>와꾸</strong>를 좀 보고 가야 될 것 같습니다.</p><h3>이더리움 사이드체인과 검증게임</h3><h4>이더리움..뭐하는 놈이냐?</h4><p>이더리움은 거대한 컴퓨터입니다. 매우 느리고, 구성 요소는 느슨하게 연결되었다가 끊어지기를 반복 하지만, 한치의 오차도 없이 작동하는 완벽한 컴퓨터죠. <a href="https://ethereum.github.io/yellowpaper/paper.pdf">이더리움 황서</a>를 작성한 이더리움의 (집나간)아빠, 가빈 우드는 이더리움을 이렇게 정의합니다.</p><blockquote>진정한 글로벌 싱글톤 컴퓨터(Truely Global Singleton Computer)</blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*9I9Md4onWt2ptKSdLK2aCw.png" /><figcaption>그림7 : 데브콘1에서 발표중인 가빈우드. 그래.. 이때가 좋았다. — 가빈우드는 이후 이더리움 재단을 떠나 패러티 테크놀리지를 설립한다. 그리고 얼마 뒤, “<a href="https://github.com/paritytech/parity-ethereum/blob/4d08e7b0aec46443bf26547b17d10cb302672835/js/src/contracts/snippets/enhanced-wallet.sol#L4">본인의 실수</a>”로 당시 가격으로 3500억원을 허공에 고이 접어 나빌레리옹!</figcaption></figure><p><a href="https://ko.wikipedia.org/wiki/%EC%8B%B1%EA%B8%80%ED%84%B4_%ED%8C%A8%ED%84%B4">싱글톤(패턴)</a>이란 소프트웨어 디자인에서 쓰이는 용어인데, 뭐 직감적으로 받아들이시면 됩니다. 싱글.. 외로워 보이는 단어죠.(외로워 마세요) 이더리움은 노드가 수만개일지라도, 연산의 종류는 하나입니다.(그래서 여러분은 혼자가 아닙니다) 느리죠. 네트워크 참여자 누구든, 수가 많고 적든지 간에 모두가 같은 연산 결과를 내놓아야 합니다. 사실 그래서 <strong>논리적으로는 중앙화(Logically Centralized)</strong> 되어 있지만, <strong>구조적-정치적으로는 탈중앙화(Architectural, Politically Decentralized)</strong> 되어 있다고 말을 합니다.[<a href="https://medium.com/hashed-kr/decentralization-that-matters-kr-5b6f4ff5ef74">탈중앙화의 진정한 의미(해시드 번역</a>)<a href="https://medium.com/hashed-kr/decentralization-that-matters-kr-5b6f4ff5ef74"> — 비탈릭 뷰테린</a> 참조] 서로 합의된 공통의 강력한 룰이 있고, 이를 따르지 않으면 왕따가 되어 이지메(いじめ; 집단구타)를 당하는 구조이기 때문에 결국 <strong>대의 안에 모여</strong>있는거죠.(샤딩+캐스퍼 = 샤스퍼는 더 잔인합니다. 칼로 긋다(slash)라는 단어가 등장합니다. 온더의 <a href="https://medium.com/onther-tech/casper-ffg-overview-e09fbe4f7d2c">4000D님의 캐스퍼 FFG 설명글</a> 참조)</p><blockquote>“<strong>난 사람이 아니라 조직에 충성합니다</strong>”라고 했던 분이 문득 생각나네요..</blockquote><p>아무튼 이더리움은 컴퓨터이기 때문에 각각의 연산 과정을 모두 뜯어볼 수 있습니다. 그리고 컴퓨터이기 때문에 거기에 소프트웨어를 올릴 수 있습니다. <a href="https://en.wikipedia.org/wiki/Smart_contract">스마트 컨트렉트</a>가 그것입니다. 심지어 <strong>컴퓨터 위에 컴퓨터</strong>를 모델링 할 수 있습니다. 마치 사람이 만든 컴퓨터가, 다시 사람을 만들듯(인공지능) 말이에요.</p><p>퍼블릭 블록체인도 컴퓨터입니다. 다만 체인의 종류와 스펙에 따라 기능이 다양한 것 뿐입니다. 비트코인이라는 zola 느린 mungChung한 컴퓨터는 <strong>장부 관리</strong>밖에 못합니다.</p><ul><li><strong>이더리움은 컴퓨터다.</strong></li><li><strong>비트코인도 (</strong>zola 느리고 mungChung하지만<strong>) 컴퓨터다.</strong></li><li><strong>블록체인도 컴퓨터다.</strong></li></ul><p>일단 이걸 받아들이시고 다음으로 넘어가겠습니다.</p><h4>사이드 체인? 숨겨진 진짜 이름은 기생 체인(parasite chain)!</h4><p>요즘 여기 저기서 개념 없이 사이드체인(sidechain)이라는 말을 막 쓰시던데, 사실 “<em>옆(side)에 있다</em>” 보다는 오히려 “<strong><em>기생한다</em></strong>”는 말이 더 잘어울립니다.(옆에 있으면 서로 평등한 것 같잖아!)</p><p>온더의 <a href="https://docs.google.com/presentation/d/1FeJU9RLUUi108I53GgKS9rQYHvQIsduSPjjLCQLuIUI/edit?usp=sharing">박정원(aiden) 연구원의 일반상태 플라즈마에 관한 발표 자료</a>를 보시면 사이드체인(이더리움에서는 이걸 플라즈마라고 부릅니다)을 이렇게 정의하죠.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*nKBM8mPOXDunSP-egB4KBg.png" /><figcaption>그림8 : 그래.. 내새끼들이 다 ㅂㅅ되더라도 난 정신 차려야지.</figcaption></figure><p>사람 사는게 다 비슷합니다. 두 사람이 있는데, 한명이 정신 못차리고 있어도 나머지 한명만 정신 차리면 지내는데 지장이 없습니다. 그리고 우린 그걸 <strong>삶(life)</strong>이라 부르죠.(여러분의 지난 연애나 결혼 생활을 돌아보시면 될 것 같습니다.)</p><p>앞선 정의에 의하면 이더리움 체인은 하나의 컴퓨터이고, 사이드 체인에 동작하는 블록체인도 하나의 컴퓨터입니다. 그리고 이런 호기심이 <strong>지구를 잠시 방문한 두 외계인</strong>의 가슴에 불을 붙입니다.(지구인들은 이런 고민 안해요)</p><blockquote>“하나의 컴퓨터가 다른 컴퓨터에 기생할 수 있는 방법은 과연 뭘까?”</blockquote><p>이 두 남자, 한명은 비트코인 진영에서 라이트닝 네트워크(Lightning network)를 연구하던 조샙 푼과 이더리움의 수장 비탈릭 뷰테린이죠.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/550/0*kZ12Io_qtZz_BTqr.png" /><figcaption>그림9 : 외계인 두마리</figcaption></figure><h4>플라즈마(Plasma) : 이더리움 진영에서 제시한 사이드 체인 솔루션</h4><p>둘은 꿍짝이 매우 잘 맞았습니다. 만난지 얼마 되지도 않아서 수십장짜리 페이퍼를 후다닥 써갈깁니다. 맞습니다.. 이게 그 유명한 <a href="https://plasma.io/plasma.pdf">플라즈마(Plasma)</a>입니다.[<a href="https://github.com/Onther-Tech/plasma-korea">온더에서 번역한 플라즈마 백서</a>]</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/825/1*z4wK21dAevfRmTCrttMX6g.png" /><figcaption>그림10 : 고인물 페이퍼. 2017년 8월에 발간되었다.</figcaption></figure><p>엄청난 페이퍼이긴 하지만, 사실 내용은 페이퍼의 초록(Abstract)보다 더 추상적(more abstract)입니다</p><blockquote>Plasma Whitepaper.. the content of this paper is <strong>more abstract</strong> than its <strong>Abstract</strong> — philosopher</blockquote><p>그래서 링크를 걸어드리긴 했지만,<strong> 페이퍼를 따로 읽을 필요는 없습니다</strong>. 제목, 저자, 그리고 그림 하나씩만 보면 되는데 방금 보고오신 <strong>[그림8,9,10]</strong>이 바로 그겁니다.</p><p>왜냐하면 너무 허공에 뜬구름이라 그 내용을 아무도 구체화 하지 못해 플라즈마에 아브라 카다브라(주: 해리포터에 등장하는 죽음의 주문)가 시전되기 직전 외계인이 연금술 쇼가 펼칩니다.<strong> 갑자기 비탈릭이 구체적인 스펙을 작성해 버리죠.</strong> 2018년 1월에 쓰여진 <a href="https://ethresear.ch/t/minimal-viable-plasma/426">최소 기능 플라즈마(Minimal Viable Plasma)</a>가 바로 그것입니다.</p><blockquote>— 참고자료</blockquote><blockquote>[온더 철학자의 MVP 분석 자료]</blockquote><blockquote>[<a href="https://docs.google.com/presentation/d/1ebaFufMnhYb8iu7WYXn7jLmWU4IaRC1GIBWUeZbExt8/edit">온더 철학자의 MVP컨트렉트 오딧 자료와 영상</a>]</blockquote><p>외계인은 두 친구를 더(more) 지구로 소환합니다. 둘은 오미세고라는 포탈(portal)을 타고 왔는데, <a href="https://github.com/DavidKnott">David Knot</a>과 <a href="https://github.com/kfichter">Kelvin Flecher</a>라는 개발자 녀석 둘이 비탈릭의 스펙을 바탕으로 코드를 <a href="https://github.com/omisego/plasma-mvp">만들어 버립니다</a>. (<a href="https://github.com/omisego/plasma-mvp/commit/c8b130f61e1f68b2739821c3ac2868cd0ba6ec9a">첫 커밋</a>이 비탈릭이 글을 써 올린날과 같은걸 보니 미리 준비하고 있었나봅니다.)</p><p>그리고 플라즈마는 거의 최근까지 이더리움 리서치 채널의 최근 쓰레드를 싹 쓸어갑니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*F9glIzpDEBbVDPChM1FpFQ.png" /><figcaption>그림11 : 최근(2018.10.14)까지 리서치 채널 “플라즈마” 태그 글 순위. 맨 아래 온더의 플라즈마EVM이 유독 눈에 띈다. 온더는 이 수많은 외계종들이 우글거리는 가디언즈 오브 갤럭시에서 변변찮은 지원 없이 외롭게 싸우고 있다. 그래도 행복하다. 이 외계인들과 같은 시대에 같은 땅을 밝고 있다는 사실이.</figcaption></figure><h4>플라즈마는 어떻게 다른 체인을 기생시키나?</h4><p>이야기가 좀 돌았습니다만, 플라즈마의 역사는 이 정도면 충분한 것 같습니다. 다시 기생수 얘기로 돌아가 보면, 플라즈마라는 기생수는 생각보다 단순한 구조로 이루어져 있습니다. 어렵게 설명할 수도 있지만, 다음 그림 두장이랑 몇마디 설명이면 충분합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*5C3MMYsrZD-KmH4JD1arag.png" /><figcaption>그림12 : 출처 — <a href="https://docs.google.com/presentation/d/1XeP64Gol1VqENz0J_J1ruLdxTvGeDOKvJm8vgr9gcug/edit?usp=sharing">누구나 쉽게 이해하는 플라즈마 EVM</a></figcaption></figure><p>카지노에 들어가는 상황을 생각 해 보면, 카지노에 진입 전 (현금 → 칩)간의 교환이 일어납니다. 반면에 퇴장할 때는 (칩 → 현금)간 교환이 일어나죠. 이더리움 부모체인과 오퍼레이터(체인운영자)가 만든 자식체인의 관계도 비슷합니다. 유저는 부모체인에 암호자산을 <strong>예치 </strong>해둔 뒤, 자식체인으로 <strong>진입(Enter)</strong>합니다. 진입시 <strong>플라즈마 자산(P-asset)</strong>이 생겨납니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*_0RSO1LHmYCy89qJRdMTiA.png" /><figcaption>그림13 : 이번엔 진짜 블록체인이다</figcaption></figure><p>진입 이후에는 칩의 소유권 교환이 계속 일어나게 되는데(블록체인에서는 이를 <strong>트랜잭션(Transaction)</strong>이라고 부릅니다), 그런 교환들이 모여서 마지막 상태를 형성하면(나오기 직전 마지막으로 남은 칩), 해당 상태(칩 잔액)를 근거로 카지노를 빠져나오게 됩니다. 남은 칩과 현금의 교환이 일어나죠.</p><p>여기까지는 매우 착한 사람들만 등장했는데, 현실은 약간 더 나쁜 사람도 있을 수 있습니다. 1)<strong>칩을 복사</strong>한다던지, <strong>2)슬롯머신 기록</strong>을 위조 당하는 일을 대비해야 됩니다. 그런 일을 하는 주체가 카지노 운영자건 이용자건 상관없이, 괜찮은 시스템이라면 이를 대비할 수 있어야 합니다.</p><p>이때 필요한 개념이 <strong>커밋(commit)</strong>입니다. 카지노의 모든 데이터를 <a href="https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%ED%8A%B8%EB%A6%AC">머클트리(merkle tree)</a>라 불리는 틀을 이용해서 데이터를 매우 압축해 카지노 밖에 주기적으로 기록을 남깁니다. 그리고 이 압축된 기록을 바탕으로 카지노 내부의 기록이 조작되는 불상사가 생기면 <strong>이의신청(challenge)</strong>이라고 불리는 과정을 통해서 <strong>재판</strong>이 이뤄집니다.</p><p><strong>심판</strong>이 하는일은 역할은 매우 분명합니다. 이런식이죠.</p><blockquote>사전에 <strong>정해진 규칙</strong>대로, 장부관리를 했습니까?</blockquote><p>만약 사전에 얘기되지 않은 방식으로 장부관리가 이뤄진다면(=유효하지 안않은 트랜잭션이 발생했다면), <strong>이의신청(challenge)</strong> 과정에서 이것이 주어진 규칙 이내에서 이뤄졌던 일인지 아닌지 여부를 판단하게 됩니다. 그리고 이러한 룰을 지키지 않았다면, 엄청난 <strong>경제적 불이익(disincentive)</strong>을 받게 됩니다. 카지노는 커밋과 이의신청이라는 두가지 외부 제약에 걸려 올바른 상태가 강제(enforce)될 수밖에 없습니다. 다시 말하면 카지노의 안정성은 본인 스스로가 아니라 외부에 남긴 <strong>커밋과 이의신청이란 과정에 의존 혹은 기생</strong>하게 되는 것이죠.</p><blockquote>“카지노는 커밋과 이의신청이라는 두가지 외부 제약에 걸려 올바른 상태가 강제(enforce)될 수밖에 없습니다. 다시 말하면 카지노의 안정성은 본인 스스로가 아니라 외부에 남긴 <strong>커밋과 이의신청이란 과정에 의존 혹은 기생</strong>하게 되는 것이죠.”</blockquote><p>눈치 채셨을지 모르겠지만 이 이의신청(challenge) 과정과 상황은 앞서 말씀드렸던 <strong>춤추는 철학자의 문제 상황과 매우 유사</strong>합니다. 유사한 정도가 아니라, 그냥 그 상황 자체입니다. (왜 그럴까요? 춤추는 철학자의 문제가 그러한 상황을 설명하기 위해서 만들어진 것이니까요..ㅋㅋ)</p><h4>생각하는 인간 vs 생각하는 컴퓨터 vs 생각하는 체인</h4><p>카지노의 사례에서 이의신청(challenge) 과정을 더 들여다보면, 이 과정의 최종 판단은 결국 카지노 밖에 있는 제3자인, <strong>심판 역할을 하는 사람</strong>이 하게 됩니다. 요약본을 통해서 원본 장부의 진위여부를 판단하고 잘잘못은 가리는 일을 하게 되죠. 그런데 만약 이 관계가 A컴퓨터와 B컴퓨터간의 관계로 확장되어도 가능할까요?</p><p>A컴퓨터가 B컴퓨터를 판단하기 위해서는 <strong>A컴퓨터 안에 B가 할 수 있는 행동규칙을 미리 정의</strong>해 두면 됩니다. 여기에 매우 유용한 도구가 있죠. 바로 <strong>소프트웨어</strong>입니다. 만약 <strong>A컴퓨터 내부에 B컴퓨터를 완벽하게 소프트웨어를 이용해 시뮬레이션</strong>을 하고, 이를 이의제기(challenge) 과정을 통해 B에서 잘못된 계산이 일어났을 때 중지,취소, 재실행을 시킬 수 있도록 강제(enforce) 한다면, <strong>B컴퓨터는 A컴퓨터에 시뮬레이션된 규칙만을 따르는, 기생수의 모습</strong>을 띄게 됩니다. 즉, B는 A의 노예가 됩니다. A컴퓨터는 프로그램을 통해 B컴퓨터의 생각을 알 수 있기 때문에 가능한 일입니다.</p><p>더해서 이 관계는 체인과 체인으로도 확장할 수 있습니다. 왜냐구요? 혹시 앞에서 했던 이야기를 기억하고 계신지 모르겠습니다.</p><blockquote><strong>블록체인도 컴퓨터다.</strong></blockquote><p>컴퓨터간 관계가 체인간 관계로 확장 될 수 있는 이유는, 체인이 컴퓨터이기 때문입니다. 계속 반복해서 말씀드렸지만, <strong>블록체인은 컴퓨터</strong>에요.</p><p>그리고 그 블록체인 위에 프로그램을 만듭니다</p><blockquote>블록체인 컴퓨터에 올라가는 프로그램을 뭐라고 부를까요?</blockquote><blockquote><strong>스마트 계약 — Smart Contract</strong></blockquote><blockquote>매우 유명한 단어인데 개념은 그보다 덜 알려져 있습니다.</blockquote><p>그냥 만든 프로그램이 아니라 상황을 판단할 수 있는 규칙을 담습니다. 바로 <strong>다른 체인이 동작하는 구조와 원리를 담은 프로그램</strong>을 만듭니다. 그리고 이러한 프로그램은 앞서 A — B컴퓨터의 관계처럼, A — B체인 관계를 형성합니다.</p><p>B체인이 노예가 되는 겁니다. 그리고 B체인이 잘못된 행위(전문가들은 이를 <strong>유효하지 않은 트랜잭션(invalid transaction)이 발생</strong>했다라고 하거나 혹은 <strong>이중 지불(double spending),</strong> 혹은 그것이 체인 운영자의 문제라면 <strong>비잔틴 상황(Byzantine)</strong>이 되었다라고 부릅니다)가 이뤄질 경우 누군가 그걸 발견하면 증거를 들고 이의제기(challenge)를 하게 되고, A체인에 만들어둔 심판 프로그램이 B체인의 상태를 판단하게 됩니다. 그리고 이러한 관계가 형성되어 있고, 이러한 절차가 마련된 체인을 <strong>사이드체인 </strong>혹은<strong> 플라즈마체인</strong>이라고 부릅니다.</p><blockquote>A — B관계가 형성된 체인을 <strong>사이드체인 혹은 플라즈마체인</strong>이라고 부릅니다</blockquote><h4>철학자들, 카지노 그리고 사이드체인(플라즈마체인)</h4><p>많이 돌아왔습니다. 글 서두에서 다뤘던 카메라 앞에서 춤추던 철학자들을 이제부터 이더리움 블록체인에서 쓰인 개념으로 치환해보도록 하겠습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*BlAzeIiHkLoYXRYjyU7w9g.png" /><figcaption>그림14 : 철학자들과 카지노 그리고 사이드체인</figcaption></figure><p>표에 대해서는 많은 설명이 필요하지는 않을 것 같습니다. 춤추는 철학자의 문제와 카지노 문제는 충분히 위쪽에 서술되어 있고, 플라즈마체인 자체에 관한 내용은 <a href="https://www.facebook.com/OntherInc/videos/1606518396119470">2018.10.12 온더의 미니세미나 영상과 자료</a>를 참조해 주시면 될 것 같습니다. 단순히 내용을 읽고 넘어가기 보다는 차분히 알고 계시는 개념들을 떠올려보면서 각각의 행렬을 오버랩 해보시면 될 것 같습니다. 궁금하신 점이 생기실 경우 댓글을 달아주시면 보충하도록 하겠습니다.</p><h3>데이터 가용성(Data Availability)</h3><p>데이터 가용성 문제는 갑자기 튀어 나온 것처럼 보이지만, 사실 앞서 계속 설명했던 내용와 매우 긴밀한 관계가 있습니다.</p><p>춤추는 철학자 문제를 풀다 보면 이런 상황이 발생할 수 있습니다.</p><blockquote>“만약 카메라(감독)가 필름을 내어주지 않을 경우 어떻하지?”</blockquote><p>우리는 앞의 철학자들의 검증게임의 사례를 다루면서 암묵적으로 특정한 필름의 내용을 요구하면 카메라는 언제든지 그 내용을 꺼내 줄 것이다라는 가정을 해버렸습니다(순진한 녀석들 같으니..)</p><p>철학자 A와 카메라 감독이 만약 서로 고용관계가 있다면 어떻게 될까요? 그리고 올바른 카메라 촬영을 위해서 심판에게 많은 돈을 예치해두고 잘못했을 경우 예치금을 까이겠다고 서명까지 해버렸다면 어떨까요? 만약 철학자 A가 비위(필름조작)등을 했을 때, 과연 카메라에 있는 필름을 순순히 내어줄까요?</p><p>사실 카메라 감독이 필름을 꺼내는 그 순간 바로 철학자 A는 본인이 이 게임에서 지게될지 이기게 될지 알게 될 것입니다. 그럼 바로 꺼낸 <strong>필름을 본인 주머니에 숨겨</strong>버리겠죠. 필름이 가용하지 않은(unavailable) 상황이 되어버리는 겁니다.</p><p>데이터 가용성 문제란 바로 이러한 상황을 묘사하는 개념입니다.</p><p>진실의 공판에 올라기기 위해서는 진실의 진위여부를 판단할 수 있는 증거가 필요한데 주어진 역할과 상황에 의해서 이러한 <strong>증거가 제출되지 않을 가능성</strong>이 매우 높다는 것이죠.</p><p>게다가 더 큰 문제가 도사리고 있습니다. 만약 필름을 받는사람 입장에서는 받지 않았는데, “<strong>본인이 받지 않았다</strong>”는걸 어떻게 증명할 수 있을까요? 그리고 만약, “<strong>받았는데 받지 않았다고 우기는 상황</strong>”은 어떠합니까?</p><p>앞에 멀리 걸아가고 있는 친구를 소리를 질러 부르는 상황이 있다고 가정 해 봅시다. 멀리있는 친구를 B, 소리치는 친구를 A라고 해보겠습니다. A는 아무말도 안했지만 B를 나무랍니다.</p><blockquote>A : “너 내가 불렀는데 왜 안돌아봤어?”</blockquote><p>B입장에서는 황당할 수 있지만, 여기서 당사자들끼리 불편하게 왈가왈부 하지 않고, 제3자 C를 불렀다고 가정해봅시다. 이러한 문제를 객관적으로 판단하게 하기 위해서는 증거가 필요한데, C는 B에게 이런말을 합니다.</p><blockquote>C : “A가 당신을 부르지 않았다는 것을 증명해보세요”</blockquote><blockquote>B : “..?????”</blockquote><p>법률에도 <a href="https://namu.wiki/w/%EC%A6%9D%EB%AA%85%EC%B1%85%EC%9E%84">증명책임</a>이라는 비슷한 개념이 있습니다만, 중요한 점은 문제를 제기한 사람이 그러한 증명을 해야 하는데, 상황의 특수성 때문에 이러한 부존재증명을 하기가 매우 어렵다는 것이죠. 그래서 블록체인 연구자들 사이에서 이러한 데이터 가용성 문제는<strong> 난제로 분류</strong>되어 있으며, 이 이슈는 샤딩(sharding), 플라즈마(plasma)와 같은 블록체인의 성능(scalability)를 해결하기 위한 솔루션들이 진척되어 가는 과정에서 연구자들을 엄청나게 괴롭히고 있습니다.</p><p>지금까지는 계속 비유를 통해 데이터 가용성 문제를 설명드렸지만, 블록체인 쪽에서 조금 더 기술적인 설명과 배경이 필요하신 분들은 온더의 <a href="https://medium.com/onther-tech/%ED%94%8C%EB%9D%BC%EC%A6%88%EB%A7%88%EC%99%80-data-availability-%EB%AC%B8%EC%A0%9C-894d66eb2080">연구원 JAKE님이 쓰신 데이터 가용성 연재글</a>과 앞으로 작성될 예정인 온더의 박정원(aiden) 연구원님이 작성하실 글을 참조하시면 더 깊은 이해에 도움이 되실 것 같습니다.</p><h3>앞선 모든 모든것은 무엇을 위해 존재할까?</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/0*02i-OJ2Y--vUPwfQ" /><figcaption>그림15 : 우리는 언제나 나침반이 필요하다</figcaption></figure><p>정글에서는 수많은 나무가 시야를 가려 방향을 잃기 쉽기 때문에 종종 높은 곳으로 올라가 멀리 보고 내가 가는 방향이 어느 곳인지 파악할 필요가 있습니다. 블록체인 연구도 비슷한데, 너무나 빠르고 많은 연구과 개발산출물들이 매일 쏟아지다 보니 각각의 결과들만 미시적으로 살펴 보다가는 방향을 잃고 엉뚱한 곳으로 나아갈 가능성이 매우 높습니다.</p><p>사실은 앞에서 다뤄던 사이드체인(플라즈마체인), 검증게임(춤추는 철학자 문제), 그리고 데이터 가용성까지의 도구들을 관통하는 거대한 사상이 하나 있습니다. 공학에서는 설계 철학 혹은 설계 목표라고 불리기도 하는 것이죠. 짧은 한 단어입니다.</p><blockquote>탈중앙화(Decentralization)</blockquote><p>가장 중요하면서도, 가장 혼란스럽고, 가장 논쟁적인 이 사상은 그러한 명성에 걸맞게 실무를 하는 <strong>시스템 설계자와 개발자 입장에서 매우 성가시고</strong> 또 그래서 타협하기 좋은 녀석입니다. 설계와 개발 과정에서 어려움에 봉착 할 때마다 매 순간 어디선가 탈중앙화를 포기하라는 섹시한 목소리가 사이렌의 노래처럼 울려오는데, 그 목소리를 따라가보면 여지없이 <strong>중앙화(Centralization)</strong>라는 늪에 빠지게 됩니다.</p><p>그래서 많은 프로젝트들이 이 늪에 빠져 <strong>노드 숫자를 줄이거나</strong>, 스스로의 높은 <strong>신뢰성을 강조</strong>하거나,<strong> 투자자의 이익을 대변</strong>했다던지 혹은 과감하게 거버넌스가 <strong>민주주의라는 거짓 선동, </strong>혹은<strong> 이의제기(challenge) 절차 없이 구축해 놓고 사이드체인이라 광고</strong>하면서까지 마치 본인들 스스로는 아무일 없는 것처럼 행동하지만, 조금만 가까이 가서 살펴봐도 악취가 진동하는걸 알 수 있죠.</p><p>사실 블록체인은 기술이고, 기술은 인간의 삶을 윤택하게 하고 세상을 지금보다 조금 더 낫게 만들기 위한 수단이자 도구입니다. 그리고 각각의 도구는 그것의 고유한 목적과 특징을 가지고 있으며, 그러한 목적달성을 위해서 쓰여질 때 가장 빛을 냅니다.</p><p>기존 중앙화된 시스템 입장에서 봤을 때, 기존의 문제를 해결해 왔던 도구들 관점에서 봤을 때, 이 블록체인이라는 도구는 매우 비효율적이고 또 너무 쓸때 없는 곳에 많은 신경을 쓰는 것처럼 보입니다. 이는 일견 사실이고 또 실제로도 그렇습니다. 기존 데이터베이스 시스템 관점에서 블록체인이란 오히려 퇴보한 형태라고 보시는 분도 있었으니까요. 그런데 그것은 보는 각도를 약간 틀어보면 이는 오히려 엄청난 진일보가 되게 됩니다. <strong>블록체인이 만들어낸 서로간의 신뢰</strong>, <strong>의미가 사라진 금융 국경</strong>, <strong>공격받기 힘들고 멈추지 않는 시스템</strong>, <strong>힘들어진 담합</strong> 등 유아기 단계의 산업(infant stage industry)이 이뤄낸 것이라고 믿기 어려운 현재까지의 결과만으로도 이미 혁명이라고 부르기에 부족함이 없어 보입니다.</p><p>지금도 탈중앙화 진영에서는 <strong>이 소중한 가치를 지키기 위해서</strong> 수 많은 분야에서 수많은 연구자가 밤새 노트북 모니터를 밝히며 조금씩 기술의 한계를 깨 나가고 있습니다. 이 글이 그분들의 연구개발을 진행해 나가는 과정에서 도움말과 같은 작은 이정표가 되길 바라며 이만 글을 마칩니다.</p><p>감사합니다.</p><blockquote>온더에서는 이 글에서 다뤘던 거의 모든 개념에 대한 구체적인 설계/개발/연구를 진행하고 있습니다. 사이드체인과 플라즈마 체인에 관심을 가지고 계시는 기업, 이를 실제 서비스에 적용하고자 하는 팀, 여기에 기여하고 함께 연구하고 발전시키고자 하시는 연구자 분들이 계시면 아래의 채널을 통해 언제든지 연락,질문, 제안을 해주시기 바랍니다. 온더는 문은 열려있습니다^^</blockquote><blockquote>Github : <a href="https://github.com/onther-tech">https://github.com/onther-tech</a></blockquote><blockquote>Facebook : <a href="https://www.facebook.com/OntherInc">https://www.facebook.com/OntherInc</a></blockquote><blockquote>Telegram : <a href="http://t.me/onther_blockchain">@onther_blockchain</a></blockquote><blockquote>Blog : <a href="https://medium.com/onther-tech">https://medium.com/onther-tech</a></blockquote><blockquote>E-mail : <a href="mailto:info@onther.io">info@onther.io</a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a196f3547841" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[변장한 늑대 — 스마트하지 못한 스마트 계약]]></title>
            <link>https://medium.com/@soonhyungjung/%EB%B3%80%EC%9E%A5%ED%95%9C-%EB%8A%91%EB%8C%80-%EC%8A%A4%EB%A7%88%ED%8A%B8%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%9C-%EC%8A%A4%EB%A7%88%ED%8A%B8-%EA%B3%84%EC%95%BD-c1a8b09f59ef?source=rss-a1d81cba82b0------2</link>
            <guid isPermaLink="false">https://medium.com/p/c1a8b09f59ef</guid>
            <category><![CDATA[이더리움]]></category>
            <category><![CDATA[ico]]></category>
            <category><![CDATA[스마트-계약]]></category>
            <category><![CDATA[컨트렉트]]></category>
            <category><![CDATA[블록체인]]></category>
            <dc:creator><![CDATA[철학자(philosopher)]]></dc:creator>
            <pubDate>Wed, 13 Dec 2017 11:38:12 GMT</pubDate>
            <atom:updated>2017-12-13T14:49:29.072Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/459/0*-HdklZLoZZpGI1-_." /><figcaption>양의 탈을 쓴 늑대</figcaption></figure><p>안녕하세요. 철학자입니다.</p><p>리서치를 하다가 근래에 <strong>탈중앙화 되어있지도 않고(non-decentralized), 자율적이지도 못한(non-autonomous) 황당한 계약 코드</strong>들을 보게 되어 여기에 대해서 이야기를 하고자 글을 남깁니다.</p><p>코드를 모르는 분들도 이해할 수 있도록 쉽게 작성했습니다. 궁금하신 점은 언제든지 댓글을 달아주세요.</p><h3>ICO 전성시대</h3><p>토큰 크라우드세일이 엄청난 붐을 이루고 있습니다. ICO(Initial Coin Offering) 혹은 TGE(Token Generation Event)라고도 불리는 이 과정은, 프로젝트의 초기 단계에서 이 프로젝트의 미래가치를 높게 평가하는 기여자(contributor)들이 보유한 이더리움(혹은 비트코인)등을 주고(contribute) 해당 프로젝트 토큰을 받아가는 과정을 거칩니다.</p><blockquote>ICO = Crowdsale = TGE</blockquote><p>프로젝트는 이러한 방식의 크라우드세일을 통해 초기 펀딩 자금을 확보할 수 있고, 해당 플랫폼의 주주격인 기여자를 여럿 확보하여 프로젝트의 열렬한 지지자도 확보할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*kSuPlGQ0AsIn7Xsuq2gyUA.png" /><figcaption>월별 ICO펀딩규모 — 출처 : 코인데스크</figcaption></figure><p>2017년 11월 31일 기준으로 ICO는 누적투자액 37억달러(한화 4조원)를 기록하고 있으며, 11월에만 7억달러(한화 8천억원)를 모금했습니다.(<a href="https://www.coindesk.com/ico-tracker/">https://www.coindesk.com/ico-tracker/</a>) 이는 이미 전 세계적인 엔젤투자 및 초기 시드투자 규모를 훨씬 상회한 수준이고(<a href="https://www.cnbc.com/2017/08/09/initial-coin-offerings-surpass-early-stage-venture-capital-funding.html">https://www.cnbc.com/2017/08/09/initial-coin-offerings-surpass-early-stage-venture-capital-funding.html</a>), 한해 미국에서 일어난 벤처케피털 총 투자규모인 600억달러의 약 6퍼센트에 해당하는 수준입니다.</p><p>ICO 시장의 규모가 급격히 커져가는 과정에서 초기 스타트업 및 프로젝트 수준의 회사가 받는 시드투자 위주에서, 어느정도 규모와 자본을 가진 기업들이 신규사업을 위해 자금을 조달하고자 참여하는 시장으로 확대되어가는 양상을 보이고 있고, 이 과정에서 ICO를 중개하는 여러 플랫폼이 탄생했습니다.(kickico, blockstarter 등)</p><p>파생서비스 또한 많이 등장했습니다. 토큰과 크라우드세일의 템플릿을 만들어주는 서비스도 등장했고, ICO의 전후 6개월의 총 과정을 집중 케어해주는 서비스를 제공해주는 곳도 있으며(tokenmarket 등), 만들어진 토큰과 크라우드세일 소스코드에 문제가 없는지 진단해주는 비즈니스(audit) 또한 성행하고 있습니다. 그 과정에서 이러한 진단과정(auditing) 전체를 블로그에 공개하고 토큰과 크라우드세일에 집중된 라이브러리를 제공해 슈퍼스타가 된 zeppelin과 같은 팀도 만들어졌습니다.</p><h3>문제는..</h3><p>관련 서비스와 사업이 성행하는 것이 나쁜것은 아닙니다. 돈이 있는 곳에 비즈니스가 생기는건 당연한 것이죠. 그런데 요즘 이러한 암호경제(crypto-economy)의 인기에 단순 편승해 탈중앙화에 대한 진지한 고민 없이 양산되는 <strong><em>질이 안좋은 소스코드</em>들이 나타나</strong>고 있습니다.</p><h3>빨간모자, 소녀 그리고 늑대</h3><p><a href="https://ko.wikipedia.org/wiki/%EB%B9%A8%EA%B0%84_%EB%91%90%EA%B1%B4">빨간모자</a>라는 동화가 있습니다. 빨간 모자를 쓴 소녀가 할머니에게 드릴 음식을 가지고 숲속을 지나던 중 늑대를 만납니다. 늑대는 소녀를 손쉽게 잡아먹기 위해 할머니를 잡아먹고 “할머니 변장”을 한 채, 소녀를 잡아먹습니다.</p><p>ICO를 하기 위해 프로젝트팀은 (1)<strong>그럴싸한 백서를 작성</strong>합니다. (2)<strong>개발진들 및 운영진들의 이력도 그럴듯하게 포장</strong>합니다. 여기저기 (3)<strong>제휴와 파트너십</strong>도 맺습니다. 그리고 (4)<strong>토큰과 크라우드세일의 소스코드를 공개</strong>하죠.</p><p>1,2,3,4에 대한 평가는 모두 투자자의 몫입니다. 프로젝트에 대한 평가를 해주는 서비스들도 있지만 돈을 얼마나 주느냐에 의해 A등급, B등급 등으로 나오는 프로젝트 평가결과들은 믿기 힘듭니다.</p><p>이제 막 거래소에 가입해서 사고팔고 하시던 분들 혹은 더 공부 하셔서 이더리움을 마이이더월렛으로 보낼 줄 아는 정도 분들에게 (1) 백서의 참신성 (4)소스코드의 이상유무 등을 파악하는 것은 불가능에 가깝습니다. 그래서 보통 깃헙에 (4)크라우드세일과 토큰 컨트렉트 코드가<strong> 단순히 “올라와 있기만 해도” 어느정도 신뢰성을 갖춘 프로젝트라고 여기는 것 같습니다.</strong>(심지어 크라우드세일 소스코드를 열어두지 않은 프로젝트도 있습니다. 설마,, 보낸 이더로 무슨짓을 할지도 모르는 주소 — 코드가 공개되어 있지 않은 ICO — 에 큰돈을 보내시는건 아니죠??)</p><p>백서는 정말 그럴듯합니다. 탈중앙화에 가치에 대한 신봉과 이에 대한 극찬, 블록체인 기술에 대한 설명, 본인들의 프로젝트가 세상을 어떻게 바꿀 것인가에 대한 장밋빛 미래, 여태까지의 성과등을 멋지게 적어 놓죠.</p><blockquote>문제는 이러한 도구들이 모두 변장을 한 늑대와 같다는 점입니다. 투자자는 교묘하게 짜여진 백서와 소스코드에 속아 잡아먹히고 있습니다.</blockquote><p>왜냐하면 백서에서 말하는 것과 소스코드에서 말하는 것이 다르기 때문입니다.</p><h3>payable(지불가능한, 이더를 받을 수있는)</h3><p>이더리움체인 위에서 만들어지는 토큰과 크라우드세일 코드는 현 시점에 가장 유행하는 탈중앙화 어플리케이션(dapp)의 일종이라고 볼 수있습니다.</p><p>이더리움 플랫폼 위에서 토큰과 크라우드세일 개발이란 사실 별게 없습니다. 토큰이란 <strong>이더리움 계정을 가진 사용자들의 잔액을 관리해주는 프로그램</strong>이고, <strong>크라우드세일이란 이더를 받아서 일정 배수를 곱해 새로운 토큰을 발행하는 프로그램</strong>입니다. 다만 그 모든 기록이 이더리움 블록체인에 기록되고, 이러한 기록을 남기기 위해 이더를 수수료로 내야 한다는 점이 다르죠.</p><p>이러한 프로그램도 <strong>이더를 보유할 수 있습니다. </strong>꼭 마이이더월렛에서 만들어진 사용자 계정만 이더 잔액을 가지고 있는것은 아닙니다. 이더리움 블록체인에 올라가는 객체이자 프로그램인 컨트렉트 계정(Contract Account; CA)또한 잔액을 가지고 있고, 일정한 규칙에 의해 이를 주고받을 수 있습니다.</p><p>크라우드세일 컨트렉(ICO 컨트렉)을 개발한다는 것은, <strong>이더를 받아 토큰을 발행하는 로직을 가지고 있는 프로그램</strong>이라고 볼 수 있습니다.</p><p>컨트렉이 이더를 받기 위해서 소스코드에는 특별한 키워드를 집어넣어야 합니다. payable이라는 키워드입니다.</p><p>payable이 없는 컨트렉트 소스코드는 이더를 받을 수 없습니다.</p><blockquote>그런데.. 리서치를 하던 도중에 <strong>payable이 없는 ICO 소스코드</strong>를 발견했습니다.</blockquote><p><strong>이더를 받을 수 없는 크라우드세일(???)</strong>.. 이게 무슨 말일까요?</p><h3>관리자가 발행하는 토큰의 문제(1)</h3><p>payable이 없는 크라우드세일 코드는 일관된 특징이 있습니다. 이러한 크라우드세일 전체를 통제하는 <strong>막강한 관리자 계정</strong>이 명시 되어 있습니다.</p><p>관리자는 거의 독재자의 가깝습니다. 토큰을 찍어낼수도, 없앨 수도 있고, ICO를 맘대로 시작할수도, 마음대로 끝낼 수도 있습니다. 전체 토큰 전송을 중단시킬 수도 있고, 이런 컨트렉 자체를 없애버릴수도 있죠. 백서에 세일기간이 몇 일이라고 적히건 말건, 기여자들에게 무슨 약속을 했건 말건, 관리자는 이에 구속되지 않고 마음대로 토큰을 주무를 수 있습니다.</p><p>payable이 없는 채 발행되는 크라우드세일 컨트렉을 이용한 ICO는 보통 다음의 과정을 거칩니다. 사실 보통이 아니라, 이러한 방법밖에 없습니다.</p><p>(1) ICO주소를 관리자의 개인주소로 공개한다(external account)</p><p>(2)관리자는 눈으로 들어온 이더 내역을 본인지갑에서 확인하고, 사전에 신청받은 database에 기록된 기여자들의 주소에 수동으로 토큰을 발행한다.</p><p>얼핏 보면 아무 문제 없어 보입니다. 다만 아주 강력한 가정을 해야하죠.</p><blockquote>관리자는 매우 투명하고, 건실하며, 진실되고, 공평하다.</blockquote><h3>보통 계약과 스마트 계약</h3><blockquote>What is needed is an electronic payment system based on cryptographic proof instead of trust, allowing any two willing parties to transact directly with each other <strong>without the need for a trusted third party</strong></blockquote><blockquote>Bitcoin: A Peer-to-Peer Electronic Cash System by Satoshi Nakamoto</blockquote><p>블록체인의 성서와 같은 사토시 나카모토의 논문의 첫장에 있는 문장입니다. <strong>두 주체가 전자거래를 하기 위해서 우리는 신뢰할 필요가 있는 제3자를 필요로 하는 것이 아니라, 이에 대한 암호학적 증거만를 요하는 시스템이 필요하다(trustless)</strong></p><p>블록체인은 두 사람이 어떠한 계약이 이뤄지는 과정에서, 제3자의 개입이나 서로간의 신뢰를 필요로 하지 않는 것을 특징으로 하고 있습니다.</p><p>특히나 이더리움 베이스로 만들어지는 토큰과 크라우드세일 코드는 더 그렇습니다. 스마트 계약의 구현체인 이더리움 컨트렉은 코드가 계약의 이행을 강제합니다. 다시 한번 강조하면 이 문장이 가장 중요합니다.</p><blockquote><strong>“코드가 계약의 이행을 강제한다”</strong></blockquote><p>블록체인 상에서 이뤄지는 계약과 스마트 계약이 다른점은, 바로 이 점입니다. 계약의 이행을 당사자나 혹은 신뢰할 수 있는 제3자에게 두지 않고, 블록체인 규칙 자체가 계약의 이행을 강제하는 것이죠. 그렇기에 계약의 당사자는 다른 중개자를 두지 않고 거래가 가능합니다. 마치 비트코인의 거래기록을 은행 등의 데이터베이스에 저장하지 않고, 비트코인 블록체인에 기록 함으로써 신뢰할 수 있는 제3자를 필요로 하지 않게 된 것 처럼요. 그렇기에 블록체인을 신뢰해야하는 중개자가 필요없는(trustless)시스템이라고 부릅니다.</p><p>그렇지만 코드가 계약의 이행을 강제하는 코드를 만들기 위해서는, <strong>그렇게 설계를 해야 합니다. 코드를 만드는 것은 설계자(프로그래머)의 판단이기 때문입니다.</strong></p><blockquote><strong>이더리움 컨트렉트 아키텍트는 계약의 어떠한 부분을 코드로써 강제할 수 있을지를 결정할 수 있습니다.</strong></blockquote><p>이더리움으로 만들어진 토큰과 크라우드세일일지라도, 설계자가 이행해야할 계약의 조항을 코드로 만들어 두지 않으면, 스마트 계약이 아니라 그냥 보통의 계약이 됩니다.</p><h3>관리자가 발행하는 토큰의 문제(2) — 늑대 컨트렉트</h3><p>다시 관리자가 발행하는 토큰의 문제로 돌아가겠습니다.</p><p>ICO도 일종의 계약입니다. 다만 계약의 내용이 “이더를 받아, 토큰을 발행”하는 스마트계약일 뿐입니다. 만약 관리자가 계약의 내용을 백서에만 명시해놓고, 본인 마음대로 토큰을 발행한다면(즉, 코드가 계약의 이행을 강제하지 못한다면) 그게 진정한 스마트 계약일까요?</p><p>전 이러한 코드를 늑대 컨트렉트(wolf contract)라고 부릅니다. 탈중앙화와 스마트 계약의 탈을 쓰고 기여자의 이더를 잡아먹는 늑대같은 존재입니다.</p><h3>깨끗한 관리자 vs 계약 코드 그리고 일관성</h3><blockquote>제3자를 필요로 하지 않는다.</blockquote><p>이것은 사실 특징(spec)인 동시에 가치( value)의 문제이기도 합니다. 가치란 처한 상황과 시대와 맥락에 따라서 사실 다르게 해석되어질 여지가 있습니다.</p><p>블록체인이 제3자를 없애고, 규칙과 프로토콜이 그 역할을 대신하게 만들었지만, 때때로 초인적인 관리자가 필요한 상황이 있을 수 있습니다. 악한 목적의 계약코드 보다는 성인(saint)에 가까운 관리자가 더 나을수도 있겠죠. 사실 이러한 부분에 대하서 무엇이 옳다, 무엇이 그르다 라고 말하고자 하는 것은 아닙니다.(물론 블록체인 사이드에 계시는 분들이 대부분 비슷한 가치관을 가지고 있는 경우가 많습니다만^^)</p><p>제가 지적하고자 하는 것은 일관성입니다.</p><p>앞에 얘기되었던 스마트 계약과 탈중앙화, 블록체인의 기술 가치는 대부분 백서(whitepaper)의 첫번째 장에 명시되어 있습니다. 보통의 백서는 이 프로젝트가 인지하는 문제는 무엇무엇이며, 우리는 어떠한 가치를 따르고 있고, 그렇기에 그것을 이렇게 해결하고자 한다고 적습니다.</p><p>만약 창립자와 팀이 어떠한 가치를 지향한다면, 목적달성을 위한 수단도 이에 맞춰서 만들어져야 합니다.</p><p><strong>백서는 탈중앙화, 스마트계약을 강조 하면서, 그 프로젝트의 첫단추를 꿰는 ICO와 토큰 발행 로직을 스마트하지 않게 만드는 것은 일관되지 않습니다.</strong></p><h3>소스코드로 ICO평가하기 : 스마트 계약의 정도</h3><p>개발 관점에서 다음의 몇 가지 기준을 ICO를 진행하는 프로젝트를 하는 평가의 잣대로 제시하고자 합니다.</p><ol><li>토큰과 크라우드세일 컨트렉트 코드의 공개 여부</li><li>payable모디파이어의 사용 여부</li><li>관리자의 자의적 토큰 발행 여부와 가능성</li><li>(자의적 발행 로직이 있다면)백서를 통해 이를 명시하고, 이에 대한 이유를 설명했는지에 대한 여부</li><li>토큰과 크라우드 세일 이외의 프로젝트와 연관된 산출물 및 코드 존재여부</li><li>토큰과 크라우드세일 코드 검토(audit) 횟수 및 검토결과공개 유무</li><li>vault컨트렉트의 사용 유무 : 크라우드세일이 끝날 때 까지 이더를 빼서 사용하지 못하게 하는 코드</li></ol><p>1번의 경우가 가장 기본입니다. 보낸 이더가 어떠한 로직으로 처리되는지도 모르는 곳에 투자해서는 안됩니다.</p><p>2번은 계속 말씀드렸던 스마트 계약의 존재 여부입니다. ICO라는 것이 이더를 받아 토큰을 만들어내는 “계약”이라면, 이러한 계약은 코드에 명시되어야 합니다. payable이 없는 컨트렉이 만들어져서는 안됩니다.</p><p>3번은 컨트렉에 payable키워드가 있다고 해도, 일부 영역에서 자의적으로 토큰을 발행할 수 있는 로직에 대한 존재유무입니다. 프라이빗 세일이라는 명목으로 관리자가 따로 자금을 받아서, 수동으로 발행하는 로직이 숨어있기도 합니다.</p><p>4번의 경우, 어쩔수 없는 상황에 의해서 자의적 발행 로직이 들어갔다면, 이에 대해서 기여자에게 투명하고 명확하게 설명해야 합니다.</p><p>5번의 경우 프로젝트를 수행하는 팀이 해당 백서에 적혀있는 비전의 일부라도 보여줄 수 있는 수준에 올라와 있는지 확인할 수 있는 잣대가 될 수 있습니다. 자본을 긁어모아놓고, 개발이 진척되지 않는 경우가 종종 발생하고 있습니다.</p><p>6번의 경우 토큰과 크라우드세일 과정에서 혹여나 생길 수 있는 큰 문제를 사전에 예방할 수 있습니다. 마치 감기에 걸리기 전에 예방주사를 맞듯이, 이더를 다루는 모든 컨트렉트코드는 전문팀의 감수(audit)를 거쳐야 됩니다.</p><p>7번의 경우 이러한 로직이 없다면 심각한 문제를 낳을 수 있습니다. 크라우드세일 도중 이더를 빼서 다른곳에 사용할 수 있다면, 2차 3차 크라우드세일로 이어지는 요즘 ICO의 트렌드를 볼때, 미니멈캡이나 맥시멈캡을 충족하기 위해서 받은 이더를 재활용할 수 있는 여지를 줄 수 있습니다.</p><h3>그렇지만..</h3><p>이러한 기준이 만능이 되는 잣대는 아닙니다. 2~3년 이상을 바라보는 프로젝트의 비전에서 토큰과 크라우드세일은 첫걸음일 뿐 전부는 아닙니다. 급하게 시작해서 다 신경 못썼을 수도 있습니다. 문제는 그러한 부분에 대해서 문제라고 인식하고 이에 대해서 언급하고 이야기할 수 있는 용기와 자신감의 문제일지도 모르죠.</p><p>다만 옛말에 <strong>될성 부른 나무는 떡잎부터 알아본다</strong>는 말이 있습니다. 시작부터 거짓말을 하는 프로젝트는 그만한 경고를 받아야 마땅합니다. 기술을 마케팅 수단으로 여기고, 근본 가치를 무시한 채 컨트렉트의 탈을 쓰고 자금을 조달받는 프로젝트는 한번 다시 돌아볼 필요가 있습니다.</p><h3>해야 하는 일</h3><p>기여자들이 속지 않기 위해서는 이러한 코드를 선별해 경고할 수 있는 커뮤니티와 프로그래머들이 많아져야 합니다. 문제가 있으면 문제가 있다고 짚고 넘어갈 수 있는 문화가 필요합니다.</p><p>프로젝트팀은 본인들의 프로젝트가 얼만큼의 리스크를 가지고 있고, 어떠한 구조로 만들어져 있는지에 대해 용기있게 말할 수 있어야 합니다.</p><p>이를 통해 ICO 가 깨끗하고 공평하게 이뤄질 수 있는 기반이 만들어져야 합니다.</p><p>이 글을 통해 늑대 컨트렉의 존재가 더욱 알려져 암호경제가 성숙해지기를 바라며 글을 마칩니다.</p><p>감사합니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c1a8b09f59ef" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[블록체인 공부 자료 정리 v0.9]]></title>
            <link>https://medium.com/@soonhyungjung/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EA%B3%B5%EB%B6%80-%EC%9E%90%EB%A3%8C-%EC%A0%95%EB%A6%AC%EC%99%80-%EC%88%9C%EC%84%9C-5c390b5323fa?source=rss-a1d81cba82b0------2</link>
            <guid isPermaLink="false">https://medium.com/p/5c390b5323fa</guid>
            <category><![CDATA[비트코인]]></category>
            <category><![CDATA[블록체]]></category>
            <category><![CDATA[이더리움]]></category>
            <dc:creator><![CDATA[철학자(philosopher)]]></dc:creator>
            <pubDate>Thu, 08 Dec 2016 17:15:06 GMT</pubDate>
            <atom:updated>2016-12-12T04:00:33.147Z</atom:updated>
            <content:encoded><![CDATA[<blockquote>이 내용은 개인의 경험에 기초하여 매우 주관적으로 작성 된 것임을 미리 알립니다. 추가적으로 더해져야 할 내용이 있으면 댓글을 부탁드립니다.</blockquote><h3>기반지식</h3><ol><li><a href="https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/">타원곡선 알고리즘 이해하기</a>(영문) — 타원곡선을 이해하면 왜 비트코인의 공개키를 통해 해킹이 불가능한지 이해하게 된다.</li><li><a href="http://m.blog.naver.com/tpinlab/10121820313">SHA 함수 이해하기</a> (국문)— 국내 블로그 중에서는 가장 SHA함수를 잘 설명하고 있다. 해시 알고리즘을 잘몰라도 블록체인을 이해하는 데 지장 없을 수도 있지만, 하나쯤은 바이트 레벨에서 이해하는 것이 향후 지식을 확장하는데 도움이 된다. <a href="http://www.righto.com/2014/09/mining-bitcoin-with-pencil-and-paper.html">연필로 SHA를 풀어내는 미친사람도 있다…</a></li><li>암호학— 시중에 암호학 개론책을 간략히 훑는 것이 가장 좋으나, 시간이 안된다면 해시함수, 공개키 암호화 방식 부분만 집중적으로 볼 것을 추천.</li></ol><h3><strong>비트코인과 블록체인 기초</strong></h3><ol><li><a href="https://bitcoin.org/bitcoin.pdf">Bitcoin: A Peer-to-Peer Electronic Cash System</a>(영문) : 블록체인의 성서와도 같은 논문. 블록체인은 여기서부터 시작됬다고 볼 수 있다. 처음은 조금 추상적이지만 읽을수록 이해가 깊어진다. 학문적으로 접근한다면 레퍼런스로 참조된 논문까지 읽으면 더 좋다.(특히 b-money, hashcash, bitstring, timestamp server등은 블록체인의 핵심 개념이 어떤 역사적인 맥락에서 파생되었는지 이해하는데 도움이 된다). <a href="http://www.ddengle.com/?module=file&amp;act=procFileDownload&amp;file_srl=562739&amp;sid=bab2e975f54a25b6d0406cd2a6506ecf">한글판</a></li><li><a href="http://book.naver.com/bookdb/book_detail.nhn?bid=9685493">비트코인, 블록체인과 금융의 혁신</a>(국문), 안드레아스 M.안토노폴리스, 최은실 김도훈 송주환 옮김. 고려대학교 출판문화원 — 국문 자료가 매우 부족한 현실에서, 번역도 괜찮고 기술적인 정리도 잘 된 책이다. 여러번 곱씹으면서 읽으면 좋다. 앞부분은 실제로 비트코인을 사용하는 방법으로 시작하여, 뒷부분은 기본적인 이론을 하나하나 훑고 있다. 특히 ‘스크립트(script)’에 대한 그림과 설명은 감동적.. <a href="http://uplib.fr/w/images/8/83/Mastering_Bitcoin-Antonopoulos.pdf">영문판</a>은 무료</li><li><a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html">Bitcoin hardway : Using Bitcoin Raw Protocol </a>(영문)— 트랜잭션을 파이썬을 이용해 하드코딩한다. ‘바이트 레벨’에서 이해할 수 있다. 코드 실습을 이해하면서 따라해보면 비트코인 트랜잭션에 대한 이해가 높아진다. 처음 공부할 때 여기있는 파이썬 코드를 크게 프린트해서 한줄 한줄 파라미터에 넘어가는 바이트를 화이트보드에 써가면서 공부했던 기억이 있다..</li><li><a href="http://www.righto.com/2014/02/bitcoin-mining-hard-way-algorithms.html">Bitcoin Mining the Hardway</a>(영문) — 앞과 동일한 블로거. 마찬가지로 채굴의 원리를 바이트 레벨에서 이해 할 수 있다. 코드 따라해보면 참 좋음.</li></ol><h3>이더리움(Ethereum)</h3><h4>원리 및 개괄</h4><ol><li><a href="https://github.com/ethereum/wiki/wiki/White-Paper">이더리움 백서(영문판)</a> — 비탈릭 뷰테린이 직접 쓴 이더리움의 개론문서. 상태 변화 함수로써의 비트코인과 이를 튜링 완전하게 만들고 이를 통해 어떠한 서비스 혹은 제품이 등장할 것인지를 예측한 비탈릭의 통찰이 가득하다. 코드레벨에서 공부하는 데에는 크게 도움이 안될 수 있지만, 기술이 생겨 뭔가 만들어 보려고 할 때 이 문서를 참조하지 않을 수 없다.<a href="https://github.com/ethereum/wiki/wiki/%5BKorean%5D-White-Paper"> 한글판</a>도 있다</li><li><a href="http://paper.gavwood.com/">이더리움 황서</a>(영문) — 가빈 우드가 만든 이더리움의 설계서. 비탈릭이 이더리움의 아버지라면, 가빈 우드는 어머니 같은 존재라고 볼 수 있다. 이더리움의 구체적인 스펙이 담겨있고, 이더리움 가상 머신(Ethereum Virtual Machine)의 저수준 스펙을 이해하는데 도움이 된다.</li><li><a href="http://www.ethdocs.org/en/latest/">홈스티드 독(영문)</a> — 최신버전인 홈스티드의 스펙과 주요 라이브러리에 대한 설명이 있다. 블록체인에 대한 기초적인 내용부터 응용 부분까지 상당히 방대한 내용을 담고 있다.</li></ol><h4>솔리디티</h4><ol><li><a href="https://solidity.readthedocs.io/en/develop/#">솔리디티 공식 독</a>(영문)</li><li><a href="https://monax.io/docs/tutorials/solidity/">모낙스 솔리디티 튜토리얼</a>(영문)</li><li><a href="https://github.com/fivedogit/solidity-baby-steps">solidity baby step</a>(영문)</li><li><a href="https://ggs134.gitbooks.io/solidityguide/content/">솔리디티 코딩 가이드</a>(국문) — 공식독을 번역중.. 완성본은 아니다.</li></ol><h4>솔리디티 보안</h4><h4>도구</h4><ol><li><a href="https://github.com/ethereum/go-ethereum">go-ethereum</a></li><li><a href="http://truffleframework.com/">truffle</a></li></ol><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5c390b5323fa" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[이더리움 스마트 계약(3)—블록체인에 은행 만들기]]></title>
            <link>https://medium.com/@soonhyungjung/%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80-%EC%8A%A4%EB%A7%88%ED%8A%B8-%EA%B3%84%EC%95%BD-3-%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EC%9D%80%ED%96%89-%EB%A7%8C%EB%93%A4%EA%B8%B0-44a9d58d687a?source=rss-a1d81cba82b0------2</link>
            <guid isPermaLink="false">https://medium.com/p/44a9d58d687a</guid>
            <category><![CDATA[smart-contracts]]></category>
            <category><![CDATA[ethereum]]></category>
            <category><![CDATA[blockchain]]></category>
            <category><![CDATA[스마트]]></category>
            <category><![CDATA[이더리움]]></category>
            <dc:creator><![CDATA[철학자(philosopher)]]></dc:creator>
            <pubDate>Sat, 03 Dec 2016 05:15:29 GMT</pubDate>
            <atom:updated>2016-12-03T09:05:02.004Z</atom:updated>
            <content:encoded><![CDATA[<p>1편에서 구성했던 개발환경과 2편에 논의 되었던 개념을 바탕으로 이더리움 블록체인 위에 은행을 만들어보자.</p><p><a href="https://medium.com/@soonhyungjung/%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80-%EC%8A%A4%EB%A7%88%ED%8A%B8-%EA%B3%84%EC%95%BD-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0-1-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD-f8e675e26e9d#.ddya7pyn7">1편 이더리움 스마트 계약(1) — 개발환경구성</a></p><p><a href="https://medium.com/@soonhyungjung/%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80-%EC%8A%A4%EB%A7%88%ED%8A%B8-%EA%B3%84%EC%95%BD-2-%EA%B0%9C%EB%85%90-fbdb597ad60b#.enp8wonxy">2편 이더리움 스마트 계약(2) — 분산자율조직개념</a></p><h3>설계</h3><p>은행은 예금을 받고 대출을 하여 그 사이에 예대마진을 가져가는 비즈니스 모델을 가지고 있다. 스마트 계약을 작성하기 위해서 이러한 업무의 핵심을 짚은 뒤 이를 묘사하는 일련의 상태와 행위로 추상화 하는 과정을 거쳐야 한다.</p><h4>은행의 핵심 비즈니스</h4><ul><li>예금업무</li><li>대출업무</li></ul><p>여기서는 대출업무는 배제하고, 예금업무만을 수행하는 은행을 가정한다.</p><p>예금업무를 추상화하면 다음과 같다.</p><h4>예금업무 주요특성</h4><ol><li>(상태)총예금액</li><li>(상태)고객별예금액</li><li>(행위)은행으로 예금</li><li>(행위)은행에서 출금</li></ol><p>2가지의 상태를 가지고 2개의 행위를 하는 단순화된 은행을 가정했다. 이를 <a href="https://medium.com/@soonhyungjung/%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80-%EC%8A%A4%EB%A7%88%ED%8A%B8-%EA%B3%84%EC%95%BD-2-%EA%B0%9C%EB%85%90-fbdb597ad60b#.enp8wonxy">자율분산조직개념</a>을 통해 나타내면 다음과 같다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*uU1y-EnOUWurbXPey0J-Qw.png" /><figcaption>분산화된 자율 은행(decentralized autonomous bank)</figcaption></figure><p>스마트 계약을 통해 어떠한 업무를 블록체인을 통해 구현하고자 할 때에는 업무를 수행하는 주체의 특징을 명확히 한정 하는 것이 매우 중요하다. 또한 이를 컨트랙트 객체로 구체화 하는 과정에서 업무의 핵심을 담는 상태와 행위를 식별해 낼 수 있어야 한다.</p><h3>코드구현</h3><p>앞에서 설계된 자율분산조직의 상태는 변수로, 행위는 함수로 나타낼 수 있다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/784d3c1be9b7f7de8a35685adcbc20aa/href">https://medium.com/media/784d3c1be9b7f7de8a35685adcbc20aa/href</a></iframe><ul><li>라인 1 : <a href="https://solidity.readthedocs.io/en/develop/layout-of-source-files.html">버전 프래그마</a>. 향후 컴파일러의 업그레이드로 인해 소스가 다르게 해석되는 것을 방지한다.</li><li>라인3 : Bank라는 이름의 컨트랙트 객체를 선언하고 있다.</li><li>라인4 : <a href="https://solidity.readthedocs.io/en/develop/types.html#integers">uint타입</a>의 ‘총예금액’ 상태를 담을 수 있는 totalDeposit변수를 선언하고 있다.</li><li>라인5 : <a href="https://solidity.readthedocs.io/en/develop/types.html#address">address타입</a>을 키(key)로, uint타입을 값(value)으로 받는 <a href="https://solidity.readthedocs.io/en/develop/types.html#mappings">mapping타입</a>의 balanceOf변수를 선언하고 있다. 이 변수를 통해 <a href="https://ethereum.gitbooks.io/frontier-guide/content/account_types.html">계정</a>별로 구분된 잔액 상태를 담을 수 있다.</li><li>라인7~10 : deposit이란 이름의 함수를 선언하고 <a href="http://solidity.readthedocs.io/en/develop/frequently-asked-questions.html?highlight=payable#what-happens-if-you-send-ether-along-with-a-function-call-to-a-contract">payable</a> 변환자를 통해 이 함수 호출을 통해 이더를 받을 수 있도록 했다. msg.sender를 이용해 발생된 <a href="http://solidity.readthedocs.io/en/develop/units-and-global-variables.html?highlight=msg.sender#block-and-transaction-properties">트랜잭션의 프로퍼티</a> 중 보낸사람(송신자)의 정보를 키(key)로, 트랜잭션에 담긴 이더리움 액수(msg.value)를 값(value)로 매핑하고 있다. 이어서 라인 9에서는 그렇게 전송된 액수를 총 예금에 더한다.</li><li>라인 12~15 : 출금 코드는 입금 코드와 비슷하다. 다만 라인15를 통해 콘트랙트 어카운트에 쌓인 잔액을 msg.sender에게 보내고 있다. “주소형.call”에 대한 설명은 다음 링크를 참조. <a href="http://solidity.readthedocs.io/en/develop/frequently-asked-questions.html?highlight=call.value#what-does-p-recipient-call-value-p-amount-p-data-do">address.call.value</a></li><li>라인 18~20 : 총 예금을 조회하는 함수. constant로 리턴하는 함수는 블록체인 상에 트렌잭션을 일으키지 않고도 컨트랙트 상태를 조회할 수 있다. <a href="http://ethereum.stackexchange.com/questions/765/what-is-the-difference-between-a-transaction-and-a-call">message와 call의 차이점</a></li><li>라인 22~24 : 계정 별 잔액을 조회</li></ul><p><a href="http://solidity.readthedocs.io/en/develop/index.html">솔리디티 공식독</a>에 보면 기본적인 예제에서 시작되어 타입, 조건문, 분기문 등 문법적인 내용이 잘 정리되어 있다.</p><h3>배포</h3><p>솔리디티 코드가 바이트 코드로 변환되는 것을 컴파일이라 하고, 컴파일된 바이트 코드가 블록체인 네트워크에 자리 잡는 것을 배포라 한다. Bank.sol을 여러 방법으로 컴파일 및 배포 테스트를 할 수 있는데, 여기서는 browser solidity를 사용해보자. [<a href="http://ethereum.stackexchange.com/questions/2835/how-to-quickly-test-a-solidity-function">솔리디티 테스트 할 수 있는 다양한 방법</a>]</p><p><a href="https://ethereum.github.io/browser-solidity/#version=soljson-v0.4.6+commit.2dabbdf0.js">browser solidity링크</a></p><p>Bank.sol의 소스 내용을 브라우저 솔리디티에 붙여 넣으면 실시간으로 컴파일을 하게 된다. 우측에 Bytecode와 Interface필드를 메모장에 복사해 놓자.</p><p><a href="https://medium.com/@soonhyungjung/%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80-%EC%8A%A4%EB%A7%88%ED%8A%B8-%EA%B3%84%EC%95%BD-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0-1-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD-f8e675e26e9d#.8w2v4odgq">1편 개별환경구성</a>에서 만들었던 execute_geth.sh를 실행해 1번 노드를 구동시키고, attach_geth.sh를 실행해 콘솔창을 연다.</p><p>앞으로 콘솔을 통해 진행되는 배포 과정을 요약하면 다음과 같다.</p><ol><li>외부 어카운트 2개를 생성</li><li>마이닝을 통해 외부 계정1번에 잔액을 쌓음</li><li>외부계정 1번으로 컨트랙트 계정을 생성하는 트랜잭션 작성</li><li>생성된 트랜잭션을 마이닝</li><li>마이닝 결과 생성된 컨트랙트 주소를 메모</li></ol><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/50ba192e37acbe1728038890240fa517/href">https://medium.com/media/50ba192e37acbe1728038890240fa517/href</a></iframe><p>콘솔 실행 과정에서 eth, personal, miner등의 geth javascript API가 사용되었다. 각 API에 대한 상세한 설명은 <a href="https://github.com/ethereum/wiki/wiki/JavaScript-API">공식문서</a> 참조.</p><ul><li>라인40 : 이 줄을 실행하고 1번 노드의 표준출력을 살펴보면 외부계정 주소와 동일한 형식의 컨트랙트 계정 주소가 생성된 것을 확인할 수 있다. 메모장에 복사 해 놓자. (혹은 eth.getTransactionReceipt(“트랜잭션해시”)명령을 통해 조회 할 수 있다)</li></ul><h3>은행에 입금, 조회하기</h3><p>이번 단계를 진행하기 위해서 앞에서 생성된 ‘콘트랙스 주소’와 브라우저 솔리디티에서 복사한 ‘인터페이스 정보’가 필요하다.</p><p>수록된 코드는 다음 과정으로 요약할 수 있다.</p><ol><li>콘솔에 배포된 컨트랙트와 커뮤니케이션 하는 객체 생성</li><li>배포된 컨트렉트에 외부 계정이 예금</li><li>마이닝</li><li>예금 내역을 조회</li></ol><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9ee1eca3646e3f46a1b7e6ef5342628b/href">https://medium.com/media/9ee1eca3646e3f46a1b7e6ef5342628b/href</a></iframe><ul><li>라인 28~29 : 이 줄을 통해서 배포된 컨트랙트의 잔액 정보를 확인할 수 있다. getBalance명령은 콘트렉트 주소 뿐 아니라, 외부계정 주소의 잔액도 확인하는 데에도 쓰인다.</li><li>라인 33 : call을 통해 처음 생성한 1번 계정의 잔액을 조회한다.</li></ul><h3><strong>한계점 및 주의사항</strong></h3><p>Bank.sol 테스트 코드로써, 실제 배포해서 사용할 경우 심각한 문제를 일으키게 된다. 이는 다음과 같은 문제 때문이다.</p><ol><li>예금에 대한 출금은 예금을 한 ‘당사자’만 할 수 있어야 하는데, 현재 코드에서는 그렇지 않다. 출금 함수 초입에 조건문이나 modifier등을 통해서 출금 가능한 계정을 제한해야 한다.</li><li>value를 0으로 한 허위 예금 트랜잭션이 다량 생성될 수 있다. 최소 입금 조건을 설정해서 이러한 공격을 방지해야 한다.</li><li>call.value을 위처럼 작성할 경우 reentrant공격을 당하게 된다. 이를 방지하기 위해서는 <a href="http://solidity.readthedocs.io/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern">Checks-Effects-Iterations</a>패턴을 적용한 시큐어 코딩이 필요하다.</li><li>기타 <a href="http://www.blunderingcode.com/writing-secure-solidity/">여러 보안 조치</a> 부재</li></ol><p>제시한 문제를 해결하는 Bank.sol을 만들어 보는 것도 solidity를 공부하는 데에 의미있을 것이다.</p><p>그렇지만 공식 문서에는 코드 자체로 문제가 없더라도 이더리움 플랫폼 자체에 대한 발견되지 않은 취약점이 존재할 수 있으므로, <a href="http://solidity.readthedocs.io/en/develop/security-considerations.html#formal-verification">신중해야 한다는 내용</a>이 포함되어 있다. 얼마전에 발생한 옵코드 Dos공격이 대표적인 예다. (<a href="https://www.reddit.com/r/ethereum/comments/56f6we/explaining_eip_150/">설명</a>)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=44a9d58d687a" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[이더리움 스마트 계약(2) — 분산자율조직개념]]></title>
            <link>https://medium.com/@soonhyungjung/%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80-%EC%8A%A4%EB%A7%88%ED%8A%B8-%EA%B3%84%EC%95%BD-2-%EA%B0%9C%EB%85%90-fbdb597ad60b?source=rss-a1d81cba82b0------2</link>
            <guid isPermaLink="false">https://medium.com/p/fbdb597ad60b</guid>
            <category><![CDATA[dac]]></category>
            <category><![CDATA[ethereum]]></category>
            <category><![CDATA[smart-contracts]]></category>
            <category><![CDATA[블록체인]]></category>
            <category><![CDATA[스마트]]></category>
            <dc:creator><![CDATA[철학자(philosopher)]]></dc:creator>
            <pubDate>Thu, 01 Dec 2016 10:51:10 GMT</pubDate>
            <atom:updated>2016-12-08T17:41:56.499Z</atom:updated>
            <content:encoded><![CDATA[<h3>계약 : 권리-의무의 교환</h3><p>계약이란 당사자 간 의사표시 일치의 산물이다. (위키:<a href="https://ko.wikipedia.org/wiki/%EA%B3%84%EC%95%BD">계약</a>) 대부분의 계약은 권리와 의무의 교환을 하게 된다. 미시경제학에서는 기업을 생산요소의 수요 자로써 가계로 부터 노동과 자본 등의 생산요소를 사들여, 재화와 서비스 등의 제품을 판매하는 주체로 정의된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*G0ExGb5QPA5W66xoC5hIEw.png" /><figcaption>권리-의무 교환의 중개자로써의 회사</figcaption></figure><p>이 권리와 의무의 교환 과정에서 계약이 체결되는데, 사회의 모든 경제활동의 대부분은 모두 일련의 계약의 집합이라고 볼 수 있다. 회사는 원자재 공급자로 부터 원자재를 사들이고(회사의 권리) 그에 대한 댓가로 자금을 지불(회사의 의무)하게 된다. 회사는 그렇게 만들어진 상품(재화와 서비스)를 고객들에게 전달(회사의 의무)하는데, 이 댓가로 고객들은 비용을 지불(회사의 권리)하게 된다.</p><p>문제는 이 계약이 때때로 불이행되거나, 그 과정에서 많은 비용이 드는 경우가 있다는 것이다. 권리,의무의 불균형을 막기 위해 이를 감시하고 강제하고 중개할 사법당국이 생겨나게 되었다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*u_nTA0ECEr3Dc1vh6NlNlg.png" /><figcaption>계약 이행의 강제자</figcaption></figure><p>이렇게 보면 마치 계약을 위한 최소한의 당사자는 3명 이상이 되어야 하는 상황이 된다. 위 그림에서도 생산 요소 시장에서는 당사자는 공급자-회사-사법당국, 생산물 시장에서는 회사-수요자-사법당국으로 나타나있다. 권리-의무가 교환되는 당사자는 2명인데, 현실에서는 이를 관리,감시,중개할 제3자의 존재로 인해 계약의 비용이 높아지게 된다. 만약 계약의 특정 조건이 만족되면, 자동으로 이행되는 특별한 계약이 있다면, 이러한 비용을 줄일 수 있지 않을까? 닉 사보의 <a href="https://en.wikipedia.org/wiki/Smart_contract">스마트 계약(위키)</a>은 이러한 맥락에서 시작되었다.</p><h3>사례 : 우버와 한국은행</h3><p>우버는 자차를 이용한 운송 서비스를 중개한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*M8gi3DIGy_Qw9CEf8Gt9-w.png" /><figcaption>권리-의무 중개 중개자로써의 우버</figcaption></figure><p>우버는 이 권리-의무 교환의 과정에서 적극적인 역할을 한다. 예를 들어 승객이 과도한 권리를 행사하면(예를 들어 차량에 낙서를 한다던가, 토를 한다던가), 승객에가 더 큰 의무(더 큰 비용)를 부과하는 식이다.</p><p>우버가 있는 이유는, 운송서비스 계약의 중개인이 필요하기 때분이다. 결제를 하기 위해서 신용카드 회사 등과 연계가 필요하고, 여러 법적인 권리-의무의 불균형을 신뢰할만한 누군가가 중개해야 하기 때문이다. 재밌는건 이러한 중개인을 감시할 중개가 또 필요하고(사법), 그 중개인의 중개인을 감시할 중개기구 또 필요하다는 것이다(민주주의).</p><p>애초에 계약이 특정 조건을 만족할 경우 자동으로 실행된다면, 이렇게 꼬리무는 중개자로 인해 발생하는 비용을 극적으로 줄일 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*VTzYHtsVJMhrOOwgLuS-kQ.png" /><figcaption>이더리움 스마트 운송 계약</figcaption></figure><p>이더리움 스마트 계약을 이용해 우버를 통째로 재구성 하면 위와 같은 그림이 나온다. 권리-의무의 교환을 모두 스마트 계약(smart contract)으로 처리하면, 우버라는 회사는 블록체인 상에 존재하는 코드 만으로 구성될 수 있다. 감시자가 계약의 불이행을 강제할 필요가 없다.</p><p>원화를 발행하는 한국은행의 사례를 살펴보면 스마트 계약이 더욱 명확해질 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*LOEgEUv9c46FlaXzG5gkvQ.png" /><figcaption>한국은행의 권리-의무 교환</figcaption></figure><p>대한민국의 국민은 국가화폐로 원화를 사용하는데, 이 원화는 중앙은행이 발행한다. 여기서 국민은 국가에 세금(의무)를 내고, 한국은행은 지불 수단인 원화의 ‘위조 방지 서비스’를 제공하는 것으로 볼 수 있다. 이를 통해 거래를 하는 당사자는 신뢰할 수 있는 ‘중앙은행’을 통해 원활한 경제활동을 할 수 있게 된다. 비트코인은 위폐 방지 서비스를 블록체인을 통해 해결했다고 볼 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*jWY3K7JiUBPii7SxNCt9SQ.png" /><figcaption>비트코인과 스마트 계약</figcaption></figure><p>비트코인을 사용하는 개인은 수수료를 제공하고 위조 방지 서비스를 이용하고, 여기서 발생한 수수료는 엄청난 연산을 통해 거래내역에 대한 합의(consensus)를 만들어내는 채굴자(miner)들에게 돌아간다.</p><p>이는 마치 비트코인 프로토콜이 마치 채굴자들을 고용하여 임금을 지불하고, 비트코인 이용자들에게 비용을 청구하는 것처럼 보인다. 비트코인 프로토콜 자체가 블록체인 네트워크 상에 상주하는 자율 조직(autonomous company)의 모습을 띄고 있는 것이다.</p><h3>이더리움 스마트 계약(smart contract) 일반화</h3><p>이더리움 스마트 계약은 단순히 “위조지폐방지” 목적으로만 사용되는 비트코인 블록체인의 경직성을 개선하여, 이를 일반적인 계약까지 확장하고자 하는 데에 있다. 컴퓨터 공학의 용어를 빌리면, 튜링 불완전한 스마트 계약의 조건 생성 방식을 튜링 완전하게 만들고자 하는 것이다.</p><p>이더리움 스마트 계약의 일반적인 모습을 그리면 다음과 같다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Qb4w_HhQAl6ZjsgYXzRrQg.png" /><figcaption>일반적인 스마트 계약</figcaption></figure><p>현실에 존재하는 중개자를 블록체인 위에 통째로 올렸다.</p><p>때때로 중개자 없는, 신뢰 불필요한(Trustless)와 같은 말들이 블록체인에 따라오는 경우가 많다. 이 개념에 약간의 설명을 덧붙이면 “(사람인)중개자가 없는”- 결국 중개자는 있다-, “(신뢰를 공개된 규칙으로 만들었기 때문에)신뢰가 불필요하다”가 된다.</p><h3>스마트 콘트렉트 코드 예제 : SimpleStorage</h3><p>어떠한 데이터를 저장해주는 중개자가 있다고 가정하자. 데이터는 256비트의 길이를 가질 수 있다. 공급자는 어떠한 데이터를 저장하고자 한다. 데이터를 저장하는 대신(권리), 이에대한 비용(이더리움)을 지불해야 한다. 수요자는 데이터를 조회해야 하고, 조회가 이뤄졌을 경우(권리), 비용을 지불(이더리움)해야 한다. 이를 위의 개념도를 통해 나타내면 다음과 같다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*bbJFblf4ZJPvhGGVoHY80A.png" /><figcaption>스마트한 데이터 저장 계약</figcaption></figure><p>이 스마트 계약을 이더리움이 제공하는 솔리디티(solidity)언어로 표현하면 다음처럼 작성된다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f982eca68407b21a77a2b742cf4c7470/href">https://medium.com/media/f982eca68407b21a77a2b742cf4c7470/href</a></iframe><p>이 계약은 storedData라는 하나의 “상태”와 set, get등 두개의 “행위”를 담고있다. 각각의 실행을 위해서는 이더리움을 네트워크 수수료로 지불해야 한다. (엄밀히 여기서 get함수는 constant형 리턴을 하기 때문에 수수료를 소모하지 않는다.)</p><h3>스마트 계약과 분산화된 자율 기업(Decentralized Autonomous Company: DAC)</h3><p>이러한 계약을 여러 계층으로 복잡하게 묶고 사물인터넷(IoT)등과 결합할 경우, 앞에서 이야기 되었던 우버와 같은 기업은 블록체인 위에서 단 한명의 운영조직도 없이 운영될 수 있다.</p><p>Slock의 <a href="https://en.wikipedia.org/wiki/The_DAO_(organization)">The DAO</a>는 밴처케피탈이라는 비즈니스를 블록체인에 구체화한 최초의 프로젝트라고 볼 수 있다(비록 해킹으로 인해 비극적 결말을 맞았지만).</p><p>마치 이러한 회사는 블록체인 상에 “살아있는 것”처럼 느껴질 때가 있는데, 필자는 이러한 특성 때문에 블록체인을 집단적 “약인공지능(semi-artificial inteligence)”으로 파악하고 있다. 기존의 인공지능이 고도의 수학연산과 중앙집중적인 서버의 연산능력을 통해 현실 문제를 해결하고자 한다면, 블록체인은 사람과 사람간의 합의 규칙을 공개적으로 정의함으로써 앞의 업무를 수행하고 있기 때문이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fbdb597ad60b" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[이더리움 스마트 계약(1) — 개발환경구성]]></title>
            <link>https://medium.com/@soonhyungjung/%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80-%EC%8A%A4%EB%A7%88%ED%8A%B8-%EA%B3%84%EC%95%BD-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0-1-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD-f8e675e26e9d?source=rss-a1d81cba82b0------2</link>
            <guid isPermaLink="false">https://medium.com/p/f8e675e26e9d</guid>
            <category><![CDATA[이더리움]]></category>
            <category><![CDATA[스마트]]></category>
            <category><![CDATA[ethereum]]></category>
            <category><![CDATA[smart-contracts]]></category>
            <dc:creator><![CDATA[철학자(philosopher)]]></dc:creator>
            <pubDate>Thu, 24 Nov 2016 03:05:53 GMT</pubDate>
            <atom:updated>2016-11-27T10:14:24.753Z</atom:updated>
            <content:encoded><![CDATA[<p>개발 환경은 아마존 EC2인스턴스(<strong>Ubuntu Server 16.04 LTS</strong>)를 기초로 한다. 아마존 웹 서비스의 기초적인 사용법은 아래 배경지식의생활코딩 강좌 링크 참조.</p><p>일단 AWS인스턴스에 접속 한 후에 geth설치를 시작하자.</p><h3>배경지식</h3><ul><li><a href="https://opentutorials.org/course/608/3002">생활코딩 아마존 웹 서비스 강좌</a>(인스턴스 생성 까지만 보면 사용하는데 지장 없음)</li><li><a href="http://gongdoo.tistory.com/241">쉘스크립트기초</a> (작성방법, 실행법 등)</li><li><a href="http://www.morenice.kr/25">VIM기초사용법</a> (텍스트 에디터로써, <a href="http://studymake.blogspot.kr/2015/06/nano.html">nano</a>등을 써도 상관없으나, 익숙해지면 여러모로 편리)</li><li>아래 등장하는 모든 쉘파일에 실행 권한을 부여해야 한다.($chmod +x “파일.sh”)</li></ul><h3>geth(go-ethereum) 설치</h3><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/3b35fdc19ffc88afcf5f4eb1356eeec2/href">https://medium.com/media/3b35fdc19ffc88afcf5f4eb1356eeec2/href</a></iframe><p>install_geth.sh는 go-ethereum 클라이언트의 소스를 받아와 빌드한다.</p><ul><li><em>라인2 : 우분투 패키지업데이트 &amp;&amp; 업그레이드</em></li><li><em>라인3 : 깃헙에 go-ethereum소스를 현재 디렉토리로 클론. go-ethereum이라는 디렉토리가 생성</em></li><li><em>라인4 : 코드 빌드에 필요한 go언어 및 빌드 패키지를 설치</em></li><li><em>라인5~6 : 소스를 빌드</em></li></ul><h3>geth 노드 실행</h3><p>아래의 쉘을 실행하면 geth가 실행된다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/49b44bdbfadd021197cc9a4034ca1dec/href">https://medium.com/media/49b44bdbfadd021197cc9a4034ca1dec/href</a></iframe><ul><li>라인3 : 빌드 된 geth의 실행파일 경로</li><li>라인4 : 데이터 디렉토리 경로; 향후에 개인키, 블록데이터 등이 담긴다. 꼭 이 위치가 아니어도 된다</li><li>라인6~7 : 개발모드로 geth노드 실행하기. 여러가지 실행옵션이 있는데 각각의 내용은 다음과 같다.</li></ul><ol><li>datadir : 데이터 렉토리 경로를 지정. 개인키와 블록데이터를 저장할 곳을 지정한다.</li><li>dev : 개발옵션. 이 옵션을 지정할 경우 메인 네트워크가 아닌 독립적인 제네시스 블록을 생성하고, 채굴도 매우 빠르게 이뤄진다.</li><li>rpc : 현재의 노드에 rpc 접속을 허용한다.</li><li>rpcapi : rpc접속 후에 사용 가능한 geth의 api를 지정한다. 위 쉘에서는 “eth, web3, personal”를 허용하고 있다.</li><li>rpccorsdomain : rpc접속시, corsdomain 문제를 해결한다. 개발 환경이기에 *로 지정했지만, 서비스 환경에는 머신의 실제 ip를 적어주는 것이 안전하다. 이 옵션을 주면 외부에서 해당 노드로 rpc접속 가능하다.</li></ol><p>자세한 옵션 정보는<a href="https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options"> geth command line option</a> 페이지 참조</p><h3>geth콘솔 사용하기</h3><p>앞서 실행된 geth 노드 자체만으로는 아무 것도 할 수 없고, 노드에 명령을 줄 수 있는 콘솔이 필요하다. 여러가지 방법이 있지만, 개인적으로 선호하는 방법은 SSH 접속을 하나 더 해서 터미널 세션을 한개 더 만든 후, 새로운 세션에서 기존 geth노드에 attach시키는 것이다.</p><p>새로운 세션 생성 후 아래의 스크립트를 실행하면 기존 노드에 attach된 콘솔이 실행된다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/846c02d68efc3b5da41a65fc53dc92a0/href">https://medium.com/media/846c02d68efc3b5da41a65fc53dc92a0/href</a></iframe><ul><li>라인 7 : geth에 attach명령어가 붙었다. attach명령어는 기존에 동작하는 geth노드에 접속하는 명령이다. 상호간 통신 규약은 ipc를 사용하고, 데이터 디렉토리의 geth.ipc를 브릿지로 사용한다. 원격에서 접속할 때에는 rpc접속을 사용하는 것이 좋다. 자세한 사용법은 <a href="https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options">geth command line option</a> 의 attach부분 참조</li></ul><p>접속 후에 “&gt;” 프롬프트가 나타나면 성공한 것이다. 이제 자바스크립트 명령을 노드1로 줄 수 있다. 노드1이 동작하는 세션으로 돌아가 표준 출력을 확인해 다음 메시지가 출력 되었는지 확인해보자.</p><p>IPC endpoint opened: /home/ubuntu/go-ethereum/build/bin/data/geth.ipc</p><p>위 메시지가 있으면 성공적으로 attach된 것이다.</p><h3>solidity컴파일러 설치</h3><p>solidity컴파일러 solc는 솔리디티 언어로 작성된 코드를 블록체인에 배포 가능한 바이트코드를 생성한다. 설치 방법은 3가지 정도가 있다.</p><ol><li><a href="https://ethereum.github.io/browser-solidity/">브라우저 솔리디티</a> 사용하기</li><li><a href="https://github.com/ethereum/solc-js">solc-js</a> 사용하기</li><li><a href="https://github.com/ethereum/solidity/releases">직접설치</a></li></ol><p>간편하게 쓰기엔 1번이 좋고, 자바스크립트와 web3에 붙여서 작업하는데는 2번이 좋다. 3번은 개인적으로 잘 안쓴다. 1번은 그냥 접속해서 사용하면 된다(다음 포스트에서 자세히 설명). 아래의 스크립트는 2,3번을 진행한다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/35a738ce72fb72b41bc2ef8d4f114c97/href">https://medium.com/media/35a738ce72fb72b41bc2ef8d4f114c97/href</a></iframe><ul><li>라인 4~7 : ethereum ppa를 등록하고 solc를 설치한다.</li><li>라인 10 : node package manager(npm)을 설치한다.</li><li>라인 11 : solc를 전역옵션(-g)을 통해 설치한다.</li></ul><h3>Web3.js 설치</h3><p>Web3.js는 자바스크립트 기반의 프로그램이 이더리움 노드와 통신을 가능하도록 만들어주는 라이브러리다. npm(node package manager)을 통해 서버, bower를 통해 클라이언트단 모두에 설치할 수 있고, meteor에도 쓸 수 있다. 아래 스크립트는 npm을 기준으로 설치한다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/135dd946d716a7840ee9ae32f8c3ad8f/href">https://medium.com/media/135dd946d716a7840ee9ae32f8c3ad8f/href</a></iframe><p>web3.js를 전역옵션(-g)을 주고 설치했다. 다른 설치방법은 아래 링크 참조</p><p><a href="https://www.npmjs.com/package/web3">web3</a></p><h3>아톰(Atom) 에디터를 쓰고 있다면..</h3><p>VIM으로 콘트렉트를 코딩하기는 조금 힘들 수 있다. 로컬 노트북과 리모트 EC2인스턴스를 FTP등을 이용해 연결해 놓고 아톰에서 코딩 후 우분투로 포워딩하면 편하다. 그렇지만 여기서 그 부분은 다루지 않는다. FTP서버 설정, 아톰을 이용한 원격 FTP연결 등은 검색 해보시길..</p><p>순정 아톰 IDE는 솔리디티 코드를 감지 못한다. 그래서 알록달록하게 나오거나(LINT), 자동 들여쓰기 등이 안되기에 개발 생산성이 떨어진다.</p><p>아래의 아톰 플러그인을 사용하면 조금 간편하게 솔리디티 코딩을 할 수 있다.</p><p><a href="https://github.com/gmtDevs/atom-ethereum-interface">gmtDevs/atom-ethereum-interface</a></p><h3>VIM덕후라면..</h3><p>꼭 VIM을 써야겠다면, 아래의 VIM 솔리디티 플러그인을 사용해보자. 신텍스 하이라이팅, 오토 인덴트 등등 여러모로 편리하다.</p><p><a href="https://github.com/tomlion/vim-solidity">tomlion/vim-solidity</a></p><h3>개발루틴</h3><p>위에서 구축된 환경에서 기본적인 개발루틴은 다음과 같다.</p><ol><li>execute_geth.sh로 1번 노드 실행</li><li>attach_geth.sh로 2번 콘솔 노드 실행</li><li>솔리디티 코딩 &amp; 컴파일 (browser solidity 혹은 solc 컴파일러 이용)</li><li>배포(web3.js혹은 2번 콘솔노드를 이용)</li><li>채굴</li><li>테스트 ( 오류 발생시 다시 3번부터 반복)</li></ol><p>3~5과정은 자바스크립트를 이용해 스크립트로 만들어 놓으면 빠르게 작업할 수 있다.</p><h3>truffle</h3><p><a href="https://github.com/ConsenSys/truffle">https://github.com/ConsenSys/truffle</a> 이더리움 개발 프레임워크</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f8e675e26e9d" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>