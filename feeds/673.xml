<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by 이상문 on Medium]]></title>
        <description><![CDATA[Stories by 이상문 on Medium]]></description>
        <link>https://medium.com/@moony211?source=rss-f074edbc70c4------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*PdFTYwkEj-ebxhH52VWJ8w.png</url>
            <title>Stories by 이상문 on Medium</title>
            <link>https://medium.com/@moony211?source=rss-f074edbc70c4------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Sun, 12 May 2019 09:38:22 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@moony211" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[CMake 설치하기를 보면서 새롭게 알게된 내용]]></title>
            <link>https://medium.com/@moony211/cmake-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0%EB%A5%BC-%EB%B3%B4%EB%A9%B4%EC%84%9C-%EC%83%88%EB%A1%AD%EA%B2%8C-%EC%95%8C%EA%B2%8C%EB%90%9C-%EB%82%B4%EC%9A%A9-1aa6cb81bde2?source=rss-f074edbc70c4------2</link>
            <guid isPermaLink="false">https://medium.com/p/1aa6cb81bde2</guid>
            <category><![CDATA[cmake]]></category>
            <category><![CDATA[wget]]></category>
            <category><![CDATA[art]]></category>
            <dc:creator><![CDATA[이상문]]></dc:creator>
            <pubDate>Wed, 17 Apr 2019 17:47:34 GMT</pubDate>
            <atom:updated>2019-04-17T17:47:34.325Z</atom:updated>
            <content:encoded><![CDATA[<p><a href="https://cliutils.gitlab.io/modern-cmake/chapters/intro/installing.html">Installing CMake · Modern CMake</a></p><p>cmake를 사용하기 전에 어떻게 설치할 수 있을까를 설명한 내용이다. cmake 자체에 대한 내용은 없지만, 새로운 스킬을 익힐 수 있었다.</p><p>먼저, wget 의 한 가지 유용한 개념이다. 내 경우에는 보통 wget은 웹서버나 ftp서버로부터 파일을 다운로드 받을 때 주로 사용했다. 그러나, -O-를 사용하면 표준출력으로 보낼 수 있고, 이것을 다시 파이프를 통해 다른 프로그램의 입력으로 보낼 수 있다. 이 방법을 파악하면, 다음 명령이 무슨 의도인지 명확해진다.</p><pre>wget -qO- &quot;https://cmake.org/files/v3.14/cmake-3.14.1-Linux-x86_64.tar.gz&quot; | tar --strip-components=1 -xz -C ~/.local</pre><p>같은 명령에서, tar 에 strip-components 라는 자주 볼 수 없었던 옵션을 발견했다. 이것을 이용하면, 압축파일의 디렉토리를 한 겹 더 벗겨서 해제할 수 있다. cmake-3.14.1-Linux-x86_64.tar.gz 을 실제로 받아서 tar로 풀어보자. 확장자만 제외한 cmake-3.14.1-Linux-x86_64 라는 디렉토리 내에 파일들을 풀어낸다. strip-components 를 1로 지정하게 되면 한 겹 더 벗겨서 풀어내어 cmake-3.14.1-Linux-x86_64 안에 있던 bin, doc, man, share, 디렉토리를 바로 내놓는다.</p><p>왜 .local이라는 디렉토리에 압축을 해제했을까. 리눅스에서는 “.”으로 시작하는 디렉토리는 숨긴다는 의미이다. 이런 형태로 환경 설정이나 상태 저장용으로 많이 사용하는 것 같다. “.git” 과 같은 디렉토리로 말이다. “~/.local”에 파일 시스템 계층구조 표준(Filesystem Hierachy Standard, FHS)과 같은 형태로 입력해주니, 다음 번 로그인 시에, 이 디렉토리를 자동으로 path 환경 변수에 추가한다. /usr/bin이나 /usr/local/bin 같은 경우는 이 시스템을 사용하는 모슨 사용자에게 노출을 시켰다. 이것은 현재 사용자에게만 적용할 수 있는 효과를 얻을 수 있겠다.</p><p>pip를 이용해서 cmake를 설치할 수도 있는 것 같다. 개인적으로는 python을 거의 사용하고 있지 않아 pip 마저도 설치가 되어 있지 않은 관계로 실제로 시도해보지는 않았다.</p><p><a href="https://lmod.readthedocs.io/en/latest/">Lmod: A New Environment Module System - Lmod 8.0.5 documentation</a></p><p>Lmod는 Lua를 기반으로 한 모듈 시스템이라고 설명이 되어 있다. 역시 Lua는 아직은 파악하지 않은, 관심이 미치지 않은 스크립트 언어이므로, 더 깊은 조사는 이번엔 넘어간다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1aa6cb81bde2" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Don’t Repeat Yourself]]></title>
            <link>https://medium.com/@moony211/dont-repeat-yourself-cbbdb1c56ce4?source=rss-f074edbc70c4------2</link>
            <guid isPermaLink="false">https://medium.com/p/cbbdb1c56ce4</guid>
            <dc:creator><![CDATA[이상문]]></dc:creator>
            <pubDate>Mon, 25 Mar 2019 23:35:10 GMT</pubDate>
            <atom:updated>2019-03-25T23:35:10.404Z</atom:updated>
            <content:encoded><![CDATA[<p>Don’t Repeat Yourself</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=cbbdb1c56ce4" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[성가신]]></title>
            <link>https://medium.com/@moony211/%EC%84%B1%EA%B0%80%EC%8B%A0-b55b910b4ac7?source=rss-f074edbc70c4------2</link>
            <guid isPermaLink="false">https://medium.com/p/b55b910b4ac7</guid>
            <dc:creator><![CDATA[이상문]]></dc:creator>
            <pubDate>Mon, 25 Mar 2019 23:33:17 GMT</pubDate>
            <atom:updated>2019-03-25T23:33:17.005Z</atom:updated>
            <content:encoded><![CDATA[<p>성가신</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b55b910b4ac7" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[블록 레벨 요소와 인라인 요소]]></title>
            <link>https://medium.com/@moony211/%EB%B8%94%EB%A1%9D-%EB%A0%88%EB%B2%A8-%EC%9A%94%EC%86%8C%EC%99%80-%EC%9D%B8%EB%9D%BC%EC%9D%B8-%EC%9A%94%EC%86%8C-3a7cd4fa8eb6?source=rss-f074edbc70c4------2</link>
            <guid isPermaLink="false">https://medium.com/p/3a7cd4fa8eb6</guid>
            <category><![CDATA[블록레벨]]></category>
            <category><![CDATA[block-level-element]]></category>
            <category><![CDATA[인라인요소]]></category>
            <category><![CDATA[inline-element]]></category>
            <dc:creator><![CDATA[이상문]]></dc:creator>
            <pubDate>Sat, 02 Feb 2019 06:04:30 GMT</pubDate>
            <atom:updated>2019-02-11T02:36:50.146Z</atom:updated>
            <content:encoded><![CDATA[<p>HTML 소스를 자주 보지는 않지만, 자주 보이는 요소를 바탕으로 블록 레벨 요소와 인라인 요소로 나눠 보고자 합니다.</p><p>블록 레벨 요소로는 &lt;div&gt;, &lt;form&gt;, &lt;h1&gt; 계열, &lt;header&gt;, &lt;hr&gt;, &lt;li&gt;, &lt;nav&gt;, &lt;ol&gt;, &lt;p&gt;, &lt;pre&gt;, &lt;table&gt;, &lt;ul&gt; 등이 있습니다.</p><p>인라인 요소로는 &lt;b&gt;, &lt;i&gt;, &lt;a&gt;, &lt;br&gt;, &lt;img&gt;, &lt;span&gt; 등이 있습니다.</p><p>직관적으로 보이는 차이점은 전자는 하나의 태그가 완료가 되면, 줄바꿈이 일어나는 반면, 후자는 그대로 유지가 된다는 점입니다. 줄바꿈이 일어난다는 자체가 블록이라는 개념으로 대표가 되고, 그 줄이 유지된다는 의미로 인라인이라는 용어를 사용한 듯 합니다.</p><p>이 요소는 display라는 특성에 속합니다. 즉, display라는 속성에 block과 inline이라는 구분이 존재한다고 할 수 있습니다.</p><p>CSS를 통해서 요소의 display 속성을 변경해서 다르게 동작하도록 만들 수 있습니다. 풀어서 얘기하면, &lt;h1&gt;을 인라인 요소로, &lt;a&gt;를 블록 레벨 요소로 동작하도록 만들 수 있다는 의미입니다. 각 요소에 display 속성이 디폴트 값으로 정해져 있을 뿐, 상황에 따라 변경해서 사용할 수 있다는 말이 됩니다.</p><p>CSS를 이용해서 h1과 a 태그에 대해 영역을 표시하도록 해 봤습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/4e852b2973536bd794edc12409bf4f74/href">https://medium.com/media/4e852b2973536bd794edc12409bf4f74/href</a></iframe><p>h1 태그의 범위는 한 줄 전체를 나타내는 반면, a 태그의 범위는 그것 내에 컨텐츠에만 국한해서 나타납니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/564/1*EAV_FKwdqa-O1zVTPlWCSA.png" /></figure><p>두 태그에 대해 display 속성에 대한 값을 바꿔보도록 하겠습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/eb501591d99409006c6916bf0def9898/href">https://medium.com/media/eb501591d99409006c6916bf0def9898/href</a></iframe><p>결과 화면은 재미있습니다. 선택 범위에서 이제 h1이 컨텐츠 범위까지만, a는 한 줄 전체를 덮는 결과를 보여줍니다. 특히, h1 태그가 인라인 요소로 바뀌는 바람에 다음 줄에 나타나던 문장이 붙어서 표현됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/567/1*PjDvuQOv8SWcyTKix6za3Q.png" /></figure><p>이 정도면 블록 레벨 요소와 인라인 요소의 차이를 알 수 있을 것 같습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3a7cd4fa8eb6" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Your writing was very helpful. So I translated it into Korean. May I make this public?]]></title>
            <link>https://medium.com/@moony211/your-writing-was-very-helpful-so-i-translated-it-into-korean-may-i-make-this-public-349b2325689?source=rss-f074edbc70c4------2</link>
            <guid isPermaLink="false">https://medium.com/p/349b2325689</guid>
            <dc:creator><![CDATA[이상문]]></dc:creator>
            <pubDate>Sun, 04 Nov 2018 12:45:39 GMT</pubDate>
            <atom:updated>2018-11-04T12:45:39.397Z</atom:updated>
            <content:encoded><![CDATA[<p>Your writing was very helpful. So I translated it into Korean. May I make this public?</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=349b2325689" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[C ++ 모듈로 Native Node.js 만들기 튜토리얼 . 1 부 — Nan 소개]]></title>
            <link>https://medium.com/@moony211/c-%EB%AA%A8%EB%93%88%EB%A1%9C-native-node-js-%EB%A7%8C%EB%93%A4%EA%B8%B0-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-1-%EB%B6%80-nan-%EC%86%8C%EA%B0%9C-e5350cb2b5f7?source=rss-f074edbc70c4------2</link>
            <guid isPermaLink="false">https://medium.com/p/e5350cb2b5f7</guid>
            <dc:creator><![CDATA[이상문]]></dc:creator>
            <pubDate>Sun, 04 Nov 2018 01:04:24 GMT</pubDate>
            <atom:updated>2018-11-04T12:51:43.884Z</atom:updated>
            <content:encoded><![CDATA[<h3>C ++ 모듈로 Native Node.js 만들기 튜토리얼 . 1 부 — Nan 소개</h3><p>이 글은 “<a href="https://medium.com/netscape/tutorial-building-native-c-modules-for-node-js-using-nan-part-1-755b07389c7c">Tutorial to Native Node.js Modules with C++. Part 1 — An Introduction to Nan</a>” 을 번역한 글입니다.</p><p>연산 비용이 많이 들거나 메모리 사용량이 많은 작업을 하기 위한 모듈을 만들고 싶다고 가정해봅시다. 분명, 자바스크립트는 이러한 용도에는 적합한 언어는 아닙니다. 또 다른 상황을 가정해봅시다. 이번에는 자바스크립트와 함께 좋아하는 C++ 라이브러리를 사용하려고 합니다. 두 경우 모두에 대해서, Node.js를 이용해서 자바스크립트로 어떠한 C++코드나 라이브러리와 연결(바인딩)할 수 있습니다.</p><p>그러한 작업을 하는 이유는 여러 가지가 있습니다. 다음은 내가 OpenCV C++ 라이브러리와 자바스크립트 바인딩으로 <strong>npm 패키지</strong>를 작성하게 된 이유입니다.</p><ul><li>웹 응용 프로그램에서 OpenCV 사용하기 위해서</li><li>OpenCV로 electron 응용 프로그램을 만들기 위해서(QT에서 골머리를 앓느니 HTML과 CSS 또는 React로 멋진 GUI를 만드는 것을 선호함)</li><li>Mocha와 Chai로 단위 테스트를 하기 위해서</li><li>자바 스크립트 코딩 작업은 멋지다 — 가장 분명한 이유입니다.</li></ul><p>그래서, 네이티브 바인딩을 개발하는 것으로부터 시작하고 싶지만, 어디에서 시작해야할 지 모르겠다라면 걱정 없어요. 몇 분 만에 방법을 가르쳐 드릴겁니다.</p><h4>또 다른 v8과 Nan 튜토리얼이 있나요?</h4><p>네이티브 node 애드온을 개발하는 방법에 대한 튜토리얼을 읽은 후에도 여전히 많은 의문이 있었습니다. 이 글을 쓰는 와중에도 v8과 Nan에 처음 마주쳤을 때 머리를 감싸고 이해하는 데 어려움을 겪었던 문제들에 주력을 해야 했습니다. 다행히도 이 방법으로 쉽게 시작할 수 있습니다. 언제나 그렇듯, 이 예제의 소스 코드는 내 <a href="https://github.com/justadudewhohacks/node-addon-tutorial"><strong>github 저장소</strong></a>에 있습니다.</p><h3>프로젝트 설정</h3><p>이 예제에서는 헤더 파일의 집합인 Nan (Native Abstractions for Node.js)을 사용합니다. Nan는 헤더 파일의 집합이며, node 애드온을 더 쉽게 개발할 수 있게 하고, 다른 node 버전 간에 호환성을 유지할 수 있게 해주는 헬퍼와 매크로들을 제공합니다. package.json은 다음과 같습니다:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9d195dc76d2ef3acb92f70d800f98cdf/href">https://medium.com/media/9d195dc76d2ef3acb92f70d800f98cdf/href</a></iframe><p>Nan을 dependency로 지정하고 node-gyp build와 node-gyp rebuild 스크립트 (깨끗하게 다시 빌드를 위한)를 추가합니다. Node-gyp은 컴파일 된 C ++ 코드를 JS 애플리케이션에 필요할 수있는 .node 파일로 묶을 수있게 해주는 모듈입니다. 최소한 우분투에서 최신 버전의 node.js가 있어야 합니다. 그렇지 않다면 간단히 npm i -g node-gyp만 입력하면됩니다. Windows 사용자는 시스템에 msvc14 (Visual Studio 2015) 빌드 도구를 설치해야합니다. 다행스럽게도 같은 목적으로 npm 패키지가 있습니다. npm i -g windows-build-tools 을 실행합니다.</p><p>또한 패키지의 엔트리 파일이 bindings.js 이라는 것에 주의할 필요가 있습니다. 이 파일에서 .node 모듈로의 경로를 지정하게 됩니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/3ee9023eb7c1a5e422ab2e77d20f18e1/href">https://medium.com/media/3ee9023eb7c1a5e422ab2e77d20f18e1/href</a></iframe><p>node-gyp으로 모듈을 빌드하기 위해서는 binding.gyp 파일로 관련 설정을 하면 됩니다.</p><p>모든 헤더와 소스 파일을 src 폴더에 넣고 node_modules에 설치된 Nan 헤더를 include 경로에 추가합니다. 소스 아래에서 모듈로 컴파일 할 각 .cc 파일을 지정해야합니다. 여기에서 해 볼 간단한 예제에서는 Vector 클래스를 만들고 index.cc 에서 이 클래스를 표출할 것입니다. 일반적으로 index.cc에서 모든 클래스와 cc 모듈을 포함하고 초기화합니다. 이 모듈은 “Init” 메소드를 구현해서, 인터페이스를 모듈에 노출시킵니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/3518534e4f856e5eae8d069a48ce21ec/href">https://medium.com/media/3518534e4f856e5eae8d069a48ce21ec/href</a></iframe><p>C ++ 모듈을 빌드하고 공개하기 위한 설정 작업이 끝났습니다. 이제는 구현 작업을 시작하기만 하면 됩니다!</p><h3>첫 번째 클래스 구현</h3><p>아마도 처음 시작할 때 가장 중요한 것은 네이티브 측 상에 클래스를 작성하는 방법과 자바스크립트 어플리케이션에서 그것을 사용하는 방법을 이해하는 것입니다. 다음을 실행할 수 있는 간단한 Vector 클래스를 구현한다고 가정하겠습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/c6a9b06914cf2f3a071a4e4bc46b1089/href">https://medium.com/media/c6a9b06914cf2f3a071a4e4bc46b1089/href</a></iframe><p>이제 x, y, z 좌표로 새로운 벡터를 초기화하려고 합니다. 새로운 값을 할당하여 좌표를 변경하고 마지막에는 다른 벡터와의 합을 구하려고 합니다.</p><h4>클래스 선언</h4><p>Vector 클래스를 정의하기 위해 다음과 같은 내용으로 헤더 파일 “Vector.h”를 만듭니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/363423716db50b51d9698c2698bed14e/href">https://medium.com/media/363423716db50b51d9698c2698bed14e/href</a></iframe><p>Vector가 Nan :: ObjectWrap 클래스를 상속하고 있다는 것을 알 수 있습니다. 자바 스크립트 앱과 네이티브 모듈을 래핑하여 JS 측으로 넘기고 그것을 풀어서 네이티브 측에서 검색하기 때문에, 이 클래스의 인스턴스를 앱과 모듈 간에 전달하는 데에 필요합니다. 이 튜토리얼 뒤에서 객체 래핑에 대해 알아볼 것입니다.</p><p>또한 클래스에는 x, y, z의 세 가지 속성과 값에 대한 getter 및 setter가 있습니다. 이것은 <strong><em>NAN_GETTER</em></strong> 및 <strong><em>NAN_SETTER</em></strong> 매크로를 사용하여 선언합니다. <strong><em>Init</em></strong>, <strong><em>New</em></strong> 및 <strong><em>Add</em></strong> 메소드도 선언합니다. 이름에서 알 수 있듯이 <strong><em>New</em></strong> 함수는 생성자가 되고, <strong><em>Init</em></strong> 함수는 앱에서 모듈을 요청할 때 가장 먼저 호출되는 것인, “module.exports” 가 됩니다. 기본적으로 Vector 클래스를 모듈에 노출시키고 <strong><em>NAN_MODULE_INIT</em></strong> 매크로로 선언합니다. 자바스크립트에서 접근할 수있는 메소드는 <strong><em>NAN_METHOD</em></strong>로 선언됩니다. 자바스크립트에서 호출할 수 있는 것은 모두 정적으로 선언해야합니다.</p><p>클래스 헤더에서 마지막으로 정의해야 할 것은 생성자에 대한 핸들을 유지하는 것입니다. 핸들의 수명을 결정하는 로컬 핸들과 영속적 핸들을 일반적으로 다루게 될 것입니다. 영속적 핸들과 대조적으로, 로컬 핸들 (나중에 많이 보게 될 것입니다)은 선언된 범위를 벗어난 후에는 가비지 콜렉트되어 처리됩니다. 하지만 핸들과 범위에 대해서는 걱정하지 마십시오. <strong><em>NAN_METHOD</em></strong>가 친절하게도 이미 이 처리를 해주기 때문에 자바스크립트에서 접근 가능한 메소드 내에서 <strong><em>HandleScopes</em></strong>를 선언하는 것조차 필요가 없습니다.</p><h4>클래스 메소드 구현하기</h4><p>클래스를 선언 했으므로 이제 Vector.cc 파일에 추가할 메서드를 구현할 차례입니다.</p><p><strong>Init:</strong></p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5509065c5dc6f776149597df01931b79/href">https://medium.com/media/5509065c5dc6f776149597df01931b79/href</a></iframe><p>이것은 새로운 클래스를 초기화하기 위해 튜토리얼에서 채택한 기본 패턴입니다. 먼저 생성자에 대한 FunctionTemplate을 만듭니다. 이 함수를 선언한 <strong><em>New</em></strong> 메서드에 할당하고 <strong><em>Reset</em></strong>을 호출하여 이 핸들을 영구적인 생성자에 할당합니다.</p><p>또한 클래스 이름, 접근자 및 프로토타입 메소드를 설정합니다. <strong><em>SetClassName</em></strong>과 <strong><em>Nan::SetAccessor</em></strong>는 속성 이름이 자바스크립트 문자열인 <strong><em>v8::Local&lt;v8::String&gt;</em></strong>이 ​​될 것으로 기대합니다. <strong><em>Nan::New</em></strong>가 <strong><em>v8::Local</em></strong> 핸들러를 싸고 있는 래퍼인 <strong><em>MaybeLocal</em></strong>을 반환하기 때문에 우리가 <strong><em>Nan::New</em></strong>로 생성한 모든 JS 객체 상에서 <strong><em>ToLocalChecked()</em></strong>를 호출해야하는 이유가 있습니다. JS 객체는 비어있을 수 있습니다. <strong><em>MaybeLocals</em></strong>는 <strong><em>IsEmpty()</em></strong>를 호출하여 확인해서 예외를 먼저 잡을 수 있습니다. 이 경우에는 핸들을 직접 만들어 <strong><em>ToLocalChecked()</em></strong>를 안전하게 호출하여 <strong><em>v8::Local </em></strong>핸들을 반환 할 수 있습니다. 마지막으로 클래스를 모듈에 표출합니다 (대상은 <strong><em>NAN_MODULE_INIT</em></strong> 매크로에서 가져옵니다).</p><p><strong>생성자:</strong></p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f9f9d0ca6513d93e25c2eba74d728e12/href">https://medium.com/media/f9f9d0ca6513d93e25c2eba74d728e12/href</a></iframe><p>여기서 가장 먼저 얘기할 내용은 <strong><em>NAN_METHOD</em></strong> 매크로의 <strong><em>info </em></strong>객체는 기본적으로 그 함수에 전달된 인수에 대한 정보를 담고있는 객체입니다. 주목해야 할 정보 객체의 일부 속성은 다음과 같습니다.</p><ul><li>함수 호출에 대한 인자 수: <strong><em>info.Length()</em></strong></li><li>인자 접근: <strong><em>info[0], info[1], … info[n]</em></strong></li><li>함수 호출에 대한 반환값 설정: <strong><em>info.GetReturnValue().set(…)</em></strong></li><li><strong><em>new</em></strong>로 호출된 생성자인가?: <strong><em>info.IsConstructCall()</em></strong></li><li>프로토타입 메소드 호출의 인스턴스:<strong><em> info.This()</em></strong></li><li>생성자에서 사용해야하는 “this”: <strong><em>info.Holder()</em></strong></li></ul><p>생성자에서 우리는 3개의 인자를 갖는 새로운 인스턴스를 생성하는 것과 같은 조건을 검사합니다. 각각의 인스턴스는 숫자가 아닌 문자열이고, 정의되지 않은 것입니다. 주의할 것은 <strong><em>Nan :: ThrowError</em></strong>는 JS 측에서 catch 될 수 있는 오류를 발생시키지만, C++ 함수는 종료되지 않도록 명시적으로 반환합니다.</p><p>더 흥미로운 일은 18 번째 줄에서 즉, 새로운 인스턴스를 만드는 곳에서 일어납니다. 우리는 새로운 Vector를 생성하고 <strong><em>info.Holder()</em></strong>로부터 JS 인스턴스로 Vector 상에서 <strong><em>Wrap</em></strong>을 호출합니다. Vector 클래스는 <strong><em>Wrap</em></strong><em> </em>메서드를 제공하는 <strong><em>Nan::ObjectWrap</em></strong>을 상속한다는 것을 떠올려 봅시다. 그런 다음 벡터의 필드 값을 초기화하고 JS 쪽으로 반환합니다.</p><p>Add:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f9f5108a35534466fe8036d570d6eecc/href">https://medium.com/media/f9f5108a35534466fe8036d570d6eecc/href</a></iframe><p>Add 메서드의 구현에서는 <strong><em>Nan :: ObjectWrap::Unwrap</em></strong>을 호출하여 풀어내는 작업이 어떻게 수행되는지 확인할 수 있습니다. ‘vecSum = vec1.add(vec2)’와 같은 메소드를 호출하고자 했습니다. 3행에서 인스턴스를 풀어내어 (vec1) 상에 메소드를 호출합니다. 이 인스턴스는 <strong><em>info.This()</em></strong>에서 가져옵니다. Vec2는 인수 0으로 전달되므로 9 행의 <strong><em>info[0]</em></strong>에서 풀어냅니다. 생성자를 사용하여 <strong><em>v8::Value</em></strong> 가 실제로 클래스의 인스턴스인지를 확인할 수 있습니다.</p><p>네이티브 측에서 새로운 인스턴스를 생성하기 위해서, 인자 갯수인 argc와 인자의 배열로 생성자를 호출해야 합니다. 그러므로 생성자 함수인 Nan::NewInstance를 호출 할 것이고 argc와 두 Vector의 x, y, z 의 합을 v8::Values의 배열(22 행)으로 해서 호출할 것입니다. 그러면 Vector의 JS 인스턴스를 래핑할 수 있습니다. 그런 다음 새 JS 인스턴스를 반환할 수 있습니다.</p><p><strong>접근자:</strong></p><p>마지막으로 접근자를 구현합니다. <strong><em>NAN_GETTER</em></strong> 및 <strong><em>NAN_SETTER</em></strong>에서는 <strong><em>v8::String</em></strong>으로 전달 된 <strong><em>property</em></strong> 객체로부터 대상 속성 이름을 검색 할 수 있습니다. 이 속성 개체는 <strong><em>std::string</em></strong>으로 변환됩니다. getter 핸들러 안에서 단순히 어떤 속성이 대상으로 되어 있는지 확인하고 값을 반환합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/58fabc20bad824c687d0227561257e9f/href">https://medium.com/media/58fabc20bad824c687d0227561257e9f/href</a></iframe><p>setter 핸들러도 거의 비슷합니다. 유일한 차이점은 값이 v8::Value로 전달된다는 것입니다. 이것은 인스턴스의 값을 설정하기 전에 타입을 확인할 수 있습니다.</p><p>취향에 따라 각 속성에 대한 getter 및 setter를 별도로 구현할 수도 있습니다. 이 경우에는 속성이 암시적으로 결정되므로 속성 이름을 확인할 필요가 없습니다.</p><h3>빌드하고 실행하세요!</h3><p>이미 구현을 완료했습니다. 이제는 실행할 시간.</p><pre>npm install &amp;&amp;npm start</pre><p>작은 js 예제를 실행하면 예상되는 결과가 나오게 됩니다.</p><pre>&gt; node ./index.js</pre><pre>vec1 Vector { z: 0, y: 10, x: 20 }<br>vec2 Vector { z: 100, y: 0, x: 30 }<br>vecSum Vector { z: 100, y: 10, x: 50 }</pre><p>배열, JSON 객체 및 콜백을 처리하는 방법을 알고 싶습니까? <a href="https://medium.com/@muehler.v/tutorial-to-node-js-native-c-modules-part-2-arrays-json-and-callbacks-9b81f09874cd">파트 2</a>를 계속하십시오.</p><p>비동기 node 모듈을 구축하고 싶습니까? <a href="https://medium.com/@muehler.v/tutorial-to-native-node-js-df4118efb678">파트 3</a>을 확인하십시오.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e5350cb2b5f7" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SSD 용량이 모자란다]]></title>
            <link>https://medium.com/@moony211/ssd-%EC%9A%A9%EB%9F%89%EC%9D%B4-%EB%AA%A8%EC%9E%90%EB%9E%80%EB%8B%A4-af6fcb2aa925?source=rss-f074edbc70c4------2</link>
            <guid isPermaLink="false">https://medium.com/p/af6fcb2aa925</guid>
            <category><![CDATA[용량]]></category>
            <category><![CDATA[하드디스크]]></category>
            <category><![CDATA[ssd]]></category>
            <dc:creator><![CDATA[이상문]]></dc:creator>
            <pubDate>Tue, 03 Apr 2018 07:37:23 GMT</pubDate>
            <atom:updated>2018-04-03T07:37:23.423Z</atom:updated>
            <content:encoded><![CDATA[<p>집에 웹서핑용으로 마련해둔 노트북이 하나 있다. 굳이 저장 공간이 클 필요가 없다고 생각해서, 128GB SSD 하나가 들어 있는 것으로 선택했다. 윈도우를 처음 설치했을 때, 특별히 크기가 큰 영화 파일들을 저장하지만 않는다면, 여유롭다고 생각했다.</p><p>그러나, 그 예상은 빗나가고 말았다. 윈도우 업데이트가 진행이 되고, 필요한 몇 개의 프로그램을 설치하고 나니, 금새 SSD가 배불러 터지기 직전이 되고 말았다. 좀 더 용량을 늘릴 수 있는 방법이 없을지 구글신에게 물어봤다. SSD를 사용하기 때문에 크기를 좀 줄여도 될 듯한 부분과 사용하지 않을 것이기 때문에 줄일 수 있는 방법을 기록해 두고자 한다.</p><p>최대 절전모드에 대해서는 다음 사이트에서 설명을 확인할 수 있다.</p><p><a href="http://thisblogbusy.tistory.com/entry/%EC%A0%88%EC%A0%84-%EB%AA%A8%EB%93%9C%EC%99%80-%EC%B5%9C%EB%8C%80-%EC%A0%88%EC%A0%84-%EB%AA%A8%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90">절전 모드와 최대 절전 모드의 차이점</a></p><p>결과적으로 열려 있는 문서와 프로그램을 하드디스크에 저장한 다음 컴퓨터를 끄는 동작으로 전력 소모를 최대로 줄인다는 얘기다. 가끔 노트북을 끄지 않고 방치해두긴 하지만, 상태를 저장해야 할 프로그램은 거의 사용하지 않는다고 봐야 하고, 문서도 일반적으로 자동 저장되는 형태가 대부분이니… 굳이 최대 절전모드를 사용해야 하나 싶다. 그래서 이 기능을 끄기로 결정했다. 그 전에 정말 이 기능을 위한 저장 파일의 크기가 얼마나 되는지 확인해 보고 싶었다. 그 파일의 정체는 hiberfil.sys. 무려 3GB가 넘고 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*C_9izaCOGXYmBOqgmRrEpw.png" /><figcaption>용량이 큰 파일을 확인하자.</figcaption></figure><p>최대 절전모드를 끄는 방법은 다음과 같다. cmd를 관리자 권한으로 실행한 후에 명령을 주면 된다.</p><blockquote>powercfg.exe /hibernate off</blockquote><p>메모리가 추가로 확보되었으니, 프로그램 하나 더 설치해볼까나~</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=af6fcb2aa925" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[av_frame_free에 대한 고찰]]></title>
            <link>https://medium.com/@moony211/av-frame-free%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0-8c0b416e2082?source=rss-f074edbc70c4------2</link>
            <guid isPermaLink="false">https://medium.com/p/8c0b416e2082</guid>
            <category><![CDATA[av-frame-free]]></category>
            <category><![CDATA[ffmpeg-programming]]></category>
            <category><![CDATA[프레임]]></category>
            <category><![CDATA[ffmpeg-free]]></category>
            <dc:creator><![CDATA[이상문]]></dc:creator>
            <pubDate>Wed, 20 Dec 2017 00:06:59 GMT</pubDate>
            <atom:updated>2017-12-20T00:06:59.567Z</atom:updated>
            <content:encoded><![CDATA[<h3>av_frame_free() 가 처리하는 범위</h3><pre>AVFrame *frame = av_frame_alloc();<br>int ret = av_image_alloc(frame-&gt;data, frame-&gt;linesize, 1920, 1080, AV_PIX_FMT_RGBA, 32);</pre><p>av_frame_alloc() 에서는 AVFrame 크기의 메모리를 할당하고 기본값을 설정한다. 실제 sizeof(AVFrame) 을 통해서 크기를 알아보면 384 바이트이다.</p><p>av_image_alloc() 에서는 frame-&gt;data 가 가리키는 메모리 배열에 format 에 따라 영상 데이터 크기만큼 메모리를 할당한다. AV_PIX_FMT_RGBA 의 경우에는 data 의 메모리 배열에서 하나만 사용한다. 한 라인의 데이터 크기값은 linesize 배열에 data 메모리 배열에 매핑하여 저장된다. 현재 설정대로라면, 한 라인에 1920 pixel 에, RGBA 형태로 한 pixel 당 4 바이트를 차지하므로, 1920 x 4 = 7680 이 linesize[0] 에 저장될 것이다.</p><pre>av_frame_free(&amp;frame);</pre><p>이 함수는 av_frame_alloc() 으로 할당된 부분만 해제 및 정리를 해준다. frame-&gt;data 를 같이 해제해주면 좋겠지만, 그렇지 않다. 해주지 않을 경우에는 당연히 memory leak이 발생한다.</p><pre>av_freep(&amp;frame-&gt;data[0]);</pre><p>av_frame_free() 를 호출하기 전에 data 메모리 배열부터 해제해줘야 한다. av_frame_free() 는 data 메모리 배열을 해제하는 작업을 하지 않는다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8c0b416e2082" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[avformat_seek_file 좀 더 파기]]></title>
            <link>https://medium.com/@moony211/avformat-seek-file-%EC%A2%80-%EB%8D%94-%ED%8C%8C%EA%B8%B0-6b5006375c3e?source=rss-f074edbc70c4------2</link>
            <guid isPermaLink="false">https://medium.com/p/6b5006375c3e</guid>
            <category><![CDATA[미디어재생검색]]></category>
            <category><![CDATA[avformat-seek-file]]></category>
            <category><![CDATA[ffmpeg-seek]]></category>
            <dc:creator><![CDATA[이상문]]></dc:creator>
            <pubDate>Wed, 20 Dec 2017 00:03:03 GMT</pubDate>
            <atom:updated>2017-12-20T00:03:03.665Z</atom:updated>
            <content:encoded><![CDATA[<pre>avformat_seek_file(m_pAVFormatCtx, -1, seek_min, seek_target, seek_max, m_seekFlags);</pre><p>두번째 인자는 time base 참조로 사용할 stream index 이다. -1을 주게 되면 AV_TIME_BASE 단위로 검색을 하게 된다. 즉, micro second 을 기준으로 하는 값이다.</p><p>세번째와 다섯번째 인자는 검색할 영역을 지정한다. 두번째 인자로 지정한 stream index 의 time base 단위로 값이 지정되어야 한다.</p><p>네번째 인자가 목표로 하는 시간값이다. 역시 두번째 인자로 지정된 time base 단위의 값이다.</p><p>다섯번째는 flag 인데, 영상을 기준으로 찾는다면, AVSEEK_FLAG_FRAME 가 가장 효율적인 방법일 것 같다. AVSEEK_FLAG_BACKWARD 는 무시가 되고, 그 외는 차이를 잘 모르겠다.</p><p>두번째 인자로 -1 이 아닌 특정 stream index를 지정하게 되면, 세번째부터 다섯번째 인자는 그 스트림에 기반한 timestamp 값으로 지정해줘야 한다. 이 값은 av_rescale 함수와 stream 의 time_base 값을 이용해서 구할 수 있다.</p><pre>int64_t seek_target = av_rescale(m_seekPos / 1000),<br>	m_pAVFormatCtx-&gt;streams[0]-&gt;time_base.den,<br>	m_pAVFormatCtx-&gt;streams[0]-&gt;time_base.num)<br>	/ 1000;</pre><p>m_seekPos 값이 AV_TIME_BASE 단위의 값이라고 했을 때, 사용한 함수 사용법이다. AV_TIME_BASE 를 단위로 한 값이 micro second 값이므로 그 값이 매우 큰 값이 될 수 있다. 그래서, 1000으로 나눈 값을 이용해서 변환했다. 오차를 줄이기 위한 tip 이라고 볼 수 있다. 계산한 뒤 다시 1000으로 나누는 것은 seek_target 값은 초단위 값에서 stream 의 time base로 변환한 값을 이용해야 하기 때문이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6b5006375c3e" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[리눅스 배포판 버전 확인]]></title>
            <link>https://medium.com/@moony211/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%B0%B0%ED%8F%AC%ED%8C%90-%EB%B2%84%EC%A0%84-%ED%99%95%EC%9D%B8-ad5e353e8daf?source=rss-f074edbc70c4------2</link>
            <guid isPermaLink="false">https://medium.com/p/ad5e353e8daf</guid>
            <category><![CDATA[리눅스버전]]></category>
            <category><![CDATA[distribution-version]]></category>
            <category><![CDATA[배포판버전]]></category>
            <category><![CDATA[linux-version]]></category>
            <dc:creator><![CDATA[이상문]]></dc:creator>
            <pubDate>Tue, 19 Dec 2017 23:59:22 GMT</pubDate>
            <atom:updated>2017-12-19T23:59:22.307Z</atom:updated>
            <content:encoded><![CDATA[<p>리눅스를 직접 설치하지 않고 사용하는 경우, 특히 요즘은 클라우드를 통해서 리눅스 환경을 제공받기 때문에, 어떤 배포판인지 확인하는 것이 필요할 때가 있다.</p><pre>cat /etc/*release</pre><p>/etc 디렉토리에 os-release 와 lsb-release 와 같은 파일이 있다. 이 내용 안에 배포판과 버전 정보를 확인할 수 있다.</p><p>lsb 는 Linux Standard Base 의 약자이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ad5e353e8daf" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>