<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Martin</title>
  
  <subtitle>Martin</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://blog.martinwork.co.kr/"/>
  <updated>2019-04-14T04:16:16.907Z</updated>
  <id>http://blog.martinwork.co.kr/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Naver Tech Concert 리뷰</title>
    <link href="http://blog.martinwork.co.kr/review/2019/04/11/2019-04-11-naver-tech-review.html"/>
    <id>http://blog.martinwork.co.kr/review/2019/04/11/2019-04-11-naver-tech-review.html</id>
    <published>2019-04-10T15:50:51.000Z</published>
    <updated>2019-04-14T04:16:16.907Z</updated>
    
    <content type="html"><![CDATA[<p>2019년 4월 11일, 네이버의 사옥 그린팩토리에서 네이버 테크 콘서트가 열렸다. 주제는 프론트 엔드 개발 전반적인 기술과 경험, 그리고 개발 문화에 대한 공유였다. 일단은 컨퍼런스의 대상은 대학생 대상으로 주최된 행사였으나, 막상 가서 보니 실무자들 참여율이 높은 편이었다. 아무래도 대학생을 대상으로 하는 컨퍼런스이기 때문에 실무자들에게는 이미 익숙해져 있는 이야기도 있었지만, 개인적으로 컨퍼런스의 전체적인 내용에 아주 만족스러웠다. 그 중 인상 깊었던 내용들에 대한 리뷰를 남기고자 한다. </p><h3 id="플랫폼-UI-개발-전략"><a href="#플랫폼-UI-개발-전략" class="headerlink" title="플랫폼 UI 개발 전략"></a>플랫폼 UI 개발 전략</h3><p>첫번째는 이주용님의 <code>플랫폼 UI 개발 전략의 모든 것</code> 이라는 주제의 세션이었다. </p><p><img src="/images/review/NAVER-TECH-CONCERT01.png" alt="/images/review/NAVER-TECH-CONCERT01.png"></p><p>내용은 스마트에디터의 UI를 개발하면서 생겼던 이슈 및 해결 과정에 대한 것들을 풀어나가는 시간이었다. 모든 개발의 시작은 좋은 설계에서 시작한다고 생각한다. 개인적으로 생각했을 때, 중요한 것은 새로운 비지니스가 추가될 때, 그러한 요구 사항을 수용할 수 있느냐와 두번째는 유지 운영의 용이성이라고 생각한다. </p><p>스마트 에디터의 설계를 하면서 가장 중요하게 생각했던 것의 첫번째는 UI 컴포넌트의 공통화는 디자인 중심이 아닌 기능 중심으로 설계를 했다는 점이다. 디자인은 템플릿 요소의 관점에서 접근하며, 실제 UI 컴포넌트를 공통화를 고민할 때는 기능 중심의 분석을 거쳐 설계를 했다고 한다. </p><p>두번째는 조건 및 상태에 따라 다른 스타일 적용했다는 점이다. 우리가 생각하는 CSS는 Javascript와 같이 동적인 언어가 아닌 <code>정적인 언어</code>이다. 하지만 비지니스의 니즈에 따라 조건이나 상태에 따라 UI의 화면이 수도없이 바뀐다. 마치 아래와 같은 스타일을 작성하는 이유이다.</p><pre><code class="scss"><span class="selector-class">.button</span> {  <span class="comment">// ...</span>  <span class="selector-class">.has-text</span> {    <span class="comment">// ...</span>  }  <span class="selector-class">.has-icon</span> {    <span class="comment">// ...</span>  }}</code></pre><p>이러한 상황을 고려하여 CSS는 정적인 언어이지만 설계는 동적으로 이뤄져야 한다는 것이다. </p><p><img src="/images/review/NAVER-TECH-CONCERT02.png" alt="/images/review/NAVER-TECH-CONCERT02.png"></p><p>이와 동시에 중요한 것은 모듈화와 공통 요서 분리 작업이다. 위와 같이 상태나 조건에 따라 컴포넌트의 스타일이 동적으로 변경될 수 있으려면 제일 먼저 비지니스의 니즈를 분석한 후, 공통 분모를 도출 해야한다. 무엇보다 이러한 공통점을 찾을 때는 단순하게 디자인만 고려하는 것이 아니라 꼭 기능도 함께 고려를 해야 한다. 디자인이 비슷하다고 해도 기능이 다른 경우가 존재하기 때문이다. </p><p><img src="/images/review/NAVER-TECH-CONCERT03.png" alt="/images/review/NAVER-TECH-CONCERT03.png"></p><p>이러한 고민들을 해결해나가는 과정에서 스마트 에디터의 팀은 개발 방법론과 CSS Preprocessor도입했다고 한다. 개발 방법론은 BEM, SMASS, OOCSS 등과 너무도 유명한 3가지 방법이 있다. 이 중에서는 대표적으로 BEM 방식이 가장 인기 있는 방법이지만, OOCSS를 선택했다고 한다. 혹시나 스마트 에디터 팀에서 OOCSS를 선택했다고 꼭 OOCSS 방법만 선택할 필요는 없다. 위의 3가지 방법은 각각의 장단점이 있기 때문에 꼭 하나의 방법을 고수하는 것보다는 상황에 따라 선택하면 될 것 같다. </p><p>첫번째 세션에서 제일 인상 깊었던 말은 <code>플랫폼은 만능이 아니다</code>라는 말이었다. 내가 만든 코드가 모든 요구사항을 다 소화할 수 없으며, 플랫폼은 지속적으로 발전하기 때문에 코드 역시 변화해야 한다. 소프트웨어 장인 이라는 책에서는 <code>개발자는 건축가와 같이 설계하고 끝나버리는 직업이 아니라, 정원사와 같이 꾸준히 관리를 해줘야하는 직업이다</code> 라고 한다. 그렇기 때문에 개발자로서 살아가는 우리들이 꾸준히 리펙토링과 클린코드에 관심을 갖는 게 아닐까?</p><p> <img src="/images/review/NAVER-TECH-CONCERT04.png" alt="/images/review/NAVER-TECH-CONCERT04.png"></p><h3 id="회사에서-성장하기"><a href="#회사에서-성장하기" class="headerlink" title="회사에서 성장하기"></a>회사에서 성장하기</h3><p>두번째로 인상 깊었던 내용은 한재엽님의 <code>주니어 개발자의 성장에 대한 뻔하지만 뻔하지않은 이야기</code> 였다. </p><p><img src="/images/review/NAVER-TECH-CONCERT05.png" alt="/images/review/NAVER-TECH-CONCERT05.png"></p><p>개발자라면 한번쯤 스스로의 위치와 앞으로 내가 얼마나 나아갈 수 있을지에 대한 고민을 한번쯤을 해보았을 것이다. 이러한 고민을 재엽님의 경험기에 빗대자면, 많은 시간을 투자하여 다음의 것들을 공부하면 된다.</p><ol><li>출근 전후 그리고 주말 내내 시간을 투자해서 공부를 한다.</li><li>사이드 프로젝트를 진행한다.</li><li>개발 관련 뉴스레터를 통해 꾸준하게 개발에 관심을 놓지 않는다.</li><li>개발 관련 서적을 독파하여 기본기에 충실한 공부를 한다.</li><li>블로그를 운영한다.</li><li>알고리즘을 하루에 한 문제씩 풀어 논리적인 사고 방식에 대한 감을 잃지 않는다. </li></ol><p>만약 이런 것들을 하루에 한다고 하면 우리는 누구나 노력형 천재 개발자가 될 수 있다. 하지만 안타깝게도 우리의 인생은 개발자로서의 성장만 꿈꾸기에는 너무나 많은 이벤트들이 있다. 가족 혹은 애인과 시간도 보내야 하고, 가끔 번아웃된 나 자신을 위해 스스로르 보듬어줘야하기도 하며, 회사를 다닌다면 야근과 같이 불가피한 상황에 놓일 수도 있을 것이다. 그렇다면 빠른 성장을 포기해야 할까?</p><p>재엽님의 주제가 제일 마음에 와닿는 것은 이러한 현실적, 물리적 제약을 해결해나간 방법에 있다. 바로 <code>회사에서 성장하기</code>이다. 언젠가 누군가에게 했던 말 중 제일 와닿는 말이 하나가 있다. <code>개발자의 실력이 궁금하다면 그 사람의 비지니스의 코드를 보면 알 수 있다.</code> 회사는 나와 함께 동반 성장을 해나가야할 파트너이다. 개인은 정체되어 있지만 회사만 성장을 하거나 혹은 개인은 성장을 하지만 회사가 정체되어 있는 불균형은 일하고 있는 환경이 좋지 않은 상황일 가능성이 크다. 그러한 의미에서 우리는 회사라는 환경을 잘 이용하여 동반 성장을 꿈꿔야 한다. </p><p>물론 사이드 프로젝트를 통해 회사에서 채우지 못한 개발적 욕구를 채울 수도 있다. 하지만 사이드 프로젝트를 진행하다보면 모든 욕구를 다 채울 수 없다는 것을 느낄 수 있다. </p><p><img src="/images/review/NAVER-TECH-CONCERT06.png" alt="/images/review/NAVER-TECH-CONCERT06.png"></p><p>재엽님이 말씀하신 간헐적 버그에 대한 무시, 버그 제보에 대한 무시, 디바이스 이슈를 제외하고도 가장 큰 것은 유저풀이다. 하루에도 수십개의 사이드 프로젝트가 탄생하며 사라진다. 정말 성공한 사이드 프로젝트를 제외하고는 유저풀이 1000명 넘는 플랫폼이 있을까? 물론 적은 수더라도 내가 사이드 프로젝트로 만든 플랫폼을 이용해준다는 것은 정말 고마운 일이지만 개발적 욕구를 모두 채우기엔 유저풀이 적은 것은 사실이다. 많은 유저풀이 있다는 것은 내가 만든 플랫폼에 대한 자부심을 갖기에도 충분하지만, 더 많은 사용자의 데이터를 통해 사용자들의 플랫폼에 대한 니즈가 점점 더 커져 플랫폼을 발전시키는 계기가 되기도 한다. 그러한 점에서 개인적으로는 유저풀 역시 꾸준한 플랫폼의 발전에 없어서는 안되는 요소라고 생각한다. 사이드 프로젝트를 통한 플랫폼에서는 이러한 것을 채울 수 없지만, 회사에서 만드는 플랫폼의 경우에는 상황이 다르다. </p><p>일단은 회사의 플랫폼의 경우, 작은 스타트업의 경우 회사의 사활이 걸려 있을 수도 있고, 큰 회사더라도 플랫폼 사업 하나에 걸려있는 비용이 천문학적인 비용인 경우가 많다. 그런 만큼 회사에서는 더 많은 관심을 가질 수 밖에 없으며, 간헐적 버그, 디바이스 이슈 등의 사소한 것 하나하나도 전문적인 QA 검증 과정을 거쳐 완벽하게 만들고자 노력한다. 이러한 환경은 개발자가 성장을 하기에 좋은 환경이라고 생각한다. 우리에게 주어진 환경 안에서 이러한 환경을 잘 이용하여 설장하는 계기가 되었으면 한다.</p><h3 id="똑똑한-질문하기"><a href="#똑똑한-질문하기" class="headerlink" title="똑똑한 질문하기"></a>똑똑한 질문하기</h3><p>일을 하다보면 스스로 혹은 동료에게 수없이 많은 질문을 하게 된다. 하다못해, 스택오버플로우만 가도 수없이 많은 개발자들의 질문과 답변이 존재한다. 커뮤니티의 수많은 질문과 답변을 통해 우리는 스스로 성장하기도 하지만 때때로 성의없는 질문들도 있다. 질문의 내용만 살펴봐도 질문을 하기에 충분한 고민을 하지 않았다는 것을 유추할 수 있다. 스스로 해결하려 하는 것이 아니라 질문을 남의 시간을 통해 해결하려고 하는 아주 괘씸한 질문들이다. </p><p>반대로 회사에서 동료에게 이러한 질문을 던지게 된다면, 나의 시간 뿐만 아니라 동료의 시간까지도 빼앗는 상황이 되기도 한다. 그리고 이렇게 몇번 성의 없는  질문을 하다보면 동료에게서 미움을 살수도 있다. 그렇다면 성의 없는 질문은 무엇일까?</p><p>일단 먼저 질문을 하기 전에 충분하게 검색을 해보자. 우리에게는 구글이라는 훌륭한 플랫폼과 스택오버플로우라는 훌륭한 선배 개발자들이 많다. 뿐만 아니라 체계가 잡혀있는 회사 내에는 트러블 슈팅을 다룬 문서가 존재하기도 하다. 대부분의 질문들은 다 그안에서 찾을 수 있다. 하지만 가끔 어떠한 키워드로 찾아야 할지 조차 감을 못 잡을 때가 있다. 그러한 경우에는 동료에게 어떠한 질문을 해야 하는지, 사전 준비를 거쳐야 한다. </p><p>일단 첫번째로 발생 상황을 정리를 한다. 예를 들어 ‘하위 IE 브라우저에서 특정 컴포넌트에서 문제가 발생한다.’ 와 같을 것이다. 물론 조금 더 상세하면 좋다. ‘하위 IE 브라우저 중 IE8에서만 유저의 데이터를 노출시켜주는 UserInformation 컴포넌트에서 x라는 문구와 함께 랜더되지 않는다’ 와 같을 것이다. 다음으로 그러한 문제를 해결하기 위해 어떠한 시도를 했는지도 함께 전달을 해주면 좋다. 상대방 역시 내가 했던 삽질을 그대로 반복해서 시간을 낭비할 수 있기 때문이다. 물론 동료 역시 나의 질문에 답변을 못할 수도 있다. 그런 경우는 차라리 덕 디버깅과 같이 내가 생각하고 있는 바를 논리적으로 토론해보는 것도 좋다. 이러한 방식 역시 상대방과 이야기를 하다보면 스스로 논리에 구멍이 있는 것을 찾기도 혹은 동료가 찾아주기도 한다. 고로 현명한 질문을 통해 서로 발전하는 계기가 되어야 할 것이다.</p><h3 id="성능-최적화"><a href="#성능-최적화" class="headerlink" title="성능 최적화"></a>성능 최적화</h3><p>최근에 회사에서 오픈한 마이티몬의 프로젝트가 안정화 단계에 들어선 후, 플랫폼의 성능에 대한 고민을 하고 있었다. TTI(Time to interaction) 수치 라던지 초기 화면이 그려지는 로딩의 속도 혹은 리소스 절감 등이 포함이 될 것이다. 그러던 중 손찬욱님의 강연이 그러한 고민을 해결할 수 있는 하나의 빛과 같았다.</p><p><img src="/images/review/NAVER-TECH-CONCERT07.png" alt="/images/review/NAVER-TECH-CONCERT07.png"></p><p>일단 클라이언트에서 성능을 개선한다고 하면 우리가 흔히 생각하는 것들이 있다. 일단 제일 간단한 것은 css는 head 안에, js는 body태그가 끝나는 바로 상단에 넣어 준다던지, 혹은 레이지 로딩 적용, 요청수 줄이기 등이 있을 것이다. 하지만 제일 중요한 것은 현재의 상태를 분석하는 것이다. 현재의 상태를 알아야 분석을 통해 어떠한 부분을 개선할 수 있는지, 어떻게 개선하면 좋을지 등에 대한 해답을 찾을 수 있기 때문이다. 그러한 성능 분석은 아래와 같이 Chrome devtools의 Network 안에 있는 Waterfall 그래프를 통해 확인할 수 있다.</p><p><img src="/images/review/NAVER-TECH-CONCERT08.png" alt="/images/review/NAVER-TECH-CONCERT08.png"></p><p>이렇게 나온 그래프를 높이는 낮게, 오른쪽에 가깝게, 그래프 하나당 길이는 짧게 줄이는 것이 성능을 최적화할 수 있는 방법이다. 조금 더 풀어서 설명을 하면, 일단 그래프의 높이가 낮으려면 요청하는 리소스의 갯수가 적어야 한다. 그 말인즉, 모든 리소스를 청킹(Chunking)한다고 성능이 좋아진다는 것은 아니라는 말이다. 두번째로 오른쪽에 가깝다는 것은 리소스 간의 다운로드 수를 줄인다는 것이다. 이러한 두번째의 경우에는 브라우저의 랜더링에 대한 배경이 있어야 한다. 이 부분에 대해서는 추후 다른 포스팅에서 깊이 다루도록 하겠다. 마지막으로 세번째는 사실 클라이언트의 이슈보다는 서버쪽의 이슈에 가까운 경우가 많다. 그래프가 길다는 것은 서버에서 비지니스 로직을 처리하는데 시간이 오래 걸리기 때문이다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019년 4월 11일, 네이버의 사옥 그린팩토리에서 네이버 테크 콘서트가 열렸다. 주제는 프론트 엔드 개발 전반적인 기술과 경험, 그리고 개발 문화에 대한 공유였다. 일단은 컨퍼런스의 대상은 대학생 대상으로 주최된 행사였으나, 막상 가서 보니 
      
    
    </summary>
    
      <category term="Review" scheme="http://blog.martinwork.co.kr/categories/review/"/>
    
    
      <category term="Naver Tech Concert" scheme="http://blog.martinwork.co.kr/tags/naver-tech-concert/"/>
    
      <category term="네이버콘서트" scheme="http://blog.martinwork.co.kr/tags/%EB%84%A4%EC%9D%B4%EB%B2%84%EC%BD%98%EC%84%9C%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>소프트 스킬에 대한 리뷰</title>
    <link href="http://blog.martinwork.co.kr/review/2019/03/17/soft-skill-review.html"/>
    <id>http://blog.martinwork.co.kr/review/2019/03/17/soft-skill-review.html</id>
    <published>2019-03-16T15:50:51.000Z</published>
    <updated>2019-03-18T09:31:46.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="들어가기전"><a href="#들어가기전" class="headerlink" title="들어가기전"></a>들어가기전</h2><blockquote><p>책에 대한 리뷰를 시작하기 전에 미리 이야기를 하자면 이 책에 대한 리뷰 작성은 누구한테 부탁받은 것도 아니며 개인의 돈으로 책을 구매하여 읽은 후 작성하였습니다. 그러므로 맹목적인 책에 대한 긍정적인 리뷰가 아닌 개인적인 의견임을 미리 밝힙니다. </p></blockquote><p>들어가기전에 바쁘신 분들을 위해 책에 대한 한줄평을 남기자면 <code>책의 모든 내용이 나에게 도움이 될순 없겠지만 내가 부족한 부분과 앞으로의 성장을 위해 필요한 것에 대한 가이드가 되기에는 충분했다.</code> 라고 할 수 있다. 필자의 경우 이 책을 지인에게 추천을 의향도 있으며, 실제로 이 글을 작성하는 날에도 지인에게 이 책에 대해서 추천을 했다. 그럼 어떠한 부분들이 좋았는지 어떠한 부분이 아쉬웠는지에 대해서 상세하게 설명을 시작해보겠다.</p><h3 id="과연-이-책은-어떠한-점의-나의-구미를-땡겼는가"><a href="#과연-이-책은-어떠한-점의-나의-구미를-땡겼는가" class="headerlink" title="과연 이 책은 어떠한 점의 나의 구미를 땡겼는가?"></a>과연 이 책은 어떠한 점의 나의 구미를 땡겼는가?</h3><p>역시 보기 좋은 떡이 먹기도 좋다고 빼놓을 수 없는 것은 책의 표지가 아닐 수 없다. 한달에 평균적으로 15만원 정도의 책을 사는 필자로서는 서점에서 모든 책의 내용을 파악하고 사기보단 일단 표지가 읽고 싶게 생긴 책을 무작정 선정 후 내용을 살펴본 후 구입 여부를 판단한다. 고로 필자에게 책의 표지는 책 구매 의사 여부에 대한 영향도가 크다고 할 수 있다. 그런 의미에서 소프트 스킬이라는 책의 표지는 개인적으로 합격이었다:)</p><p><img src="/images/review/soft-skill-review01.jpeg" alt="/images/review/soft-skill-review01.jpeg"></p><p>엠포싱이 들어간 표지 뿐만 아니라 무채색을 좋아하는 필자에게는 너무나 마음에 드는 색상이었다. 그리고 너무 개발자스럽지 않은 표지가 대중교통을 이용하면서도 읽기에 부담되지 않았다:) 무엇보다 <code>평범한 개발자</code> 라는 책의 부제에서 이것은 나같은 평범한 개발자를 위한 책이다!라는 생각이 들었다. 그러고나서 책의 첫장을 펼지면 다음과 같이 이 책에 대한 저자의 철학을 바로 살필 수 있다.</p><p><img src="/images/review/soft-skill-review02.jpeg" alt="/images/review/soft-skill-review02.jpeg"></p><p>언젠가 지인이 “요즘은 집필되는 책은 내용에 대한 깊이나 몰입도가 예전에 출판된 읽기 좋은 책에 비해 아쉬운 경우가 많다.” 라는 이야기를 한적이 있다. 사실 필자의 경우에도 막상 사오고나서 마음 잡고 책을 읽으려고 앉았다가 실망한 적이 한두번이 아니다. 그런 의미에서 이 책에 대한 필자의 철학은 또다른 감동을 주기에 충분했다:)  </p><p>이러한 감동을 가지고 책의 내용을 한글자 한글자 마음에 새기며 살펴보았다. </p><h3 id="책의-내용이-나에게는-어떠한-의미였지"><a href="#책의-내용이-나에게는-어떠한-의미였지" class="headerlink" title="책의 내용이 나에게는 어떠한 의미였지?"></a>책의 내용이 나에게는 어떠한 의미였지?</h3><p>첫번째로 와닿는 말은 <code>소프트 스킬은 생각보다 중요하다</code> 였다. </p><p><img src="/images/review/soft-skill-review02_1.jpeg" alt="/images/review/soft-skill-review02_1.jpeg"></p><p>어느 한 포스팅에서 기술 업계에 대한 독성 말투에 대해서 써놓은 글을 보았다. (궁금하신 분은 <a href="https://edykim.com/ko/post/tech-has-a-toxic-tone-problem-lets-fix-it/" target="_blank" rel="noopener">기술 업계의 독성 말투 문제, 고칩시다!</a>에서 확인 할 수 있습니다.) 지금까지 짧게 다닌 회사를 제외하고 최소 1년 이상 다녔던 회사는 3개, 짧은 회사까지 포함한다면 5군데의 회사에 있었지만 어느 단 한곳 인간 관계에서 상처받지 않은 사람이 없었던 곳이 없었다. 위의 독성 말투에 대한 포스팅에서도 강조를 하고 있지만 우리가 하는 모든 일이 다양한 사람들의 참여로 인해 일어나기 때문에 이 책에서도 역시 소프트 스킬이 아주 중요하다고 강조한다. </p><p><img src="/images/review/soft-skill-review02_2.jpeg" alt="/images/review/soft-skill-review02_2.jpeg"></p><p>여기까지만 본다면 아마 ‘뭐야, 그건 어디서나 볼 수 있는 내용이잖아.’ 라는 생각을 할수 있을 것이다. 하지만 이 책에서 <code>문제아 다루기</code> 라는 내용으로 정말 마음 속 깊은 곳을 찌르는 말이 등장한다. 아마 포스팅에서도 이야기 하는 <code>습관적 반대론자</code>도 이 안에 포함되지 않을까 싶다. 새로운 시도하려고 했을 때, 맹목적인 비난을 통해 의욕을 꺾어놓으려고 하거나 혹은 새로운 시도를 하려는 사람을 깎아내리려는 사람은 어느 집단에나 꼭 한명 이상씩은 있지 않을까 싶다. 이 사람들을 이 책에서는 <code>문제아</code> 라고 표현하며 <code>그 사람들과 만났을 때는 바꾸려고 하거나 잘 지내보려고 하지 말아라</code> 라는 이야기를 한다. 말 그대로 교류를 최소화하며 되도록이면 피해야하는 사람을 굳이 내 사람 혹은 눈 안에 들려고 노력할 필요는 없다는 의미이다. 개인적으로도 이러한 사람들은 어느 집단에 가나 약간의 말만 주고받아도 충분히 파악이 되기 떄문에 되도록이면 피하는 것을 추천한다:) </p><p>두번째로 와닿는 말은 <code>이루고 싶은 게 있다면 이미 이룬 것처럼 연기하라</code>이다. 예전 어디선가 구글러들은 구글에 입사해서 구글러가 아니라, 이미 구글러였기 때문에 구글에 입사한 것이다라는 식의 글을 읽은 적이 있다. 정확하게 이러한 맥락을 아니였는데, 비슷한 의미였던 것으로 기억한다. (아무리 찾고자해도 너무 오래전이라 저는 검색에 실패했지만 혹시나 이 글을 읽는 분 중에 정확하게 아시는 분은 메일 주시면 조그마한 성의 표시라도 하고 싶습니다:) 아시는 분은 연락 바랍니다!) 이 글을 보고 구글러가 일하는 방식에 대해서 연구하고 실제 그들처럼 되고자 연기했던 적이 있었다 껄껄:) </p><p><img src="/images/review/soft-skill-review02_3.jpeg" alt="/images/review/soft-skill-review02_3.jpeg"></p><p>여기에서 이야기하고자 하는 핵심은 거짓 연기를 하라는 것이 아니라 그러한 태도로 살려고 노력한다면 원하는 것을 이룰 수 있다라는 것이다. 잠깐이나마의 연기를 통해 이러한 행동 및 마음가짐은 스스로가 프로패셔널이라는 생각을 불어넣어줄 뿐만 아니라 개개인에게 책임감과 의지를 불어넣기에 충분하다는 생각을 하게 되었다. 다만 중요한 것은 오만함과 자신감은 꼭 구분하여 그로 인해 본인 스스로를 과대평가하는 실수는 저지르지 않길 바란다.</p><p>세번째는 <code>셀프 마케팅</code>이라는 말이었다. 개발자 스스로 본인의 가치를 증명하며 재능을 돋보이게 해야한다는 의미이다. 요즘 우리는 자기 PR의 시대 속에 살고 있다고 말을 하면서도 실제로는 쑥쓰러워서 남들 앞에 나서는 걸 꺼려한다. 하지만 꼭 셀프 마케팅이라는 것을 거창하게 생각할 필요는 없다. 꼭 남들 앞에 나서지 않더라도, 이미 우리는 셀프 마케팅을 하고 있다. </p><p><img src="/images/review/soft-skill-review02_4.jpeg" alt="/images/review/soft-skill-review02_4.jpeg"></p><p>이력서 또한 지원한 회사에 ‘나는 귀사에 입사해서 이러한 것들을 해낼 수 있어요’ 라는 의미의 셀프 마케팅이 된다. 혹은 필자와 같이 소소하게나마 블로그를 운영하는 것 역시 셀프 마케팅일 수 있다. 필자의 경우 블로그를 운영하며 회사들의 러브콜을 받기도, 책 집필에 대한 제안을 받기도 했던 경험이 있어 개인적으로는 블로그를 운영하는 것에 대해서 적극 추천한다:) (형편없는 제 글을 보고 연락주신 담당자분들에게 굉장히 감사하다는 말씀을 드립니다 하하하:) ) 물론 우리가 알면서도 당하는 허위 광고식의 마케팅이나, 과대 포장이 이뤄져서는 안된다.</p><p><img src="/images/review/soft-skill-review03.png" alt="/images/review/soft-skill-review03.jpeg"></p><p>아마 한번쯤 당해본 사람이라면 막상 그 포장을 뜯어본 후, 엄청난 분노를 느꼈을 것이다 :(((( 이러한 분노를 또다른 누군가에게 전파하는 일이 없도록 조심하도록 하자 </p><p>네번째는 <code>학습 방법 익히기</code>이다. 책에서는 학습 방법에는 10단계의 과정을 통해 학습 방법에 대해서 표현하지만 본 포스팅에서 이야기하고자 하는 것은 그런 것이 아니다. 얼마 전 한 커뮤니티에서 고민 상담글로 이러한 글을 본적이 있다. ‘6개월동안 국비 지원 학원에서 열심히 공부한 후 신입으로 막상 취직해서 보니 자기가 너무 부족함을 깨달아서 다시 국비 지원을 통해 학원에서 학습을 하고자 한다.’ </p><p><img src="/images/review/soft-skill-review04.jpeg" alt="/images/review/soft-skill-review04.jpeg"></p><p>스스로가 부족하다는 고민은 개발자라면 공통적으로 하는 고민일 것이다. 여기에서 중요한 것은 학원에서 6개월 배우고도 부족함을 느꼈는데 다시 학원으로 돌아가려고 하는 글쓴이가 안타까웠다. 사실 필자의 경우 한번도 개발 관련해서 한번도 학원에서 배워본적이 없어 주관적인 의견일 수는 있겠지만 <code>학원은 앞으로 내가 공부해야할 것들에 대해 방향성만 제시</code>해준다고 생각한다. 그 이후부터는 지식에 대한 갈증은 스스로 해결해야 한다고 생각한다. </p><p>만약 위의 고민과 같이 시간이 지남에 따라 과거를 돌아보았는데 과거의 나와 현재의 내가 별 차이가 없다면 학습의 방법이 잘못된 것이 아닌가를 고민해보길 바란다.</p><p><img src="/images/review/soft-skill-review05.jpeg" alt="/images/review/soft-skill-review05.jpeg"></p><p>다섯번째는 <code>멘토</code>에 대한 내용이다. 멘토에 대한 사전적인 의미를 살펴보면 <code>정신적으로나 내면적으로 신뢰할 수 있는 상담 상대, 지도자, 스승님, 선생</code>이라는 뜻을 가진다. 많은 사람들이 멘토에 대한 의미를 헷갈려서 스승이라고 생각한다. </p><blockquote><p>멘토는 현명하고 신뢰할 수 있는 상담 상대, 지도자, 스승, 선생의 의미이다. 하지만 그렇다고 <code>멘토 = 스승</code>인 것은 아니다. 보통 스승이라고 하면 자신보다 나이가 많은 사람을 떠올리지만, 멘토의 경우는 동갑내기 친구가 될 수도 있다. 심지어는 자신보다 어린 사람이 멘토가 될 수 있다. 다시 말해 스승이 무엇인가를 <code>직접 가르쳐주는 사람</code>이라고 한다면 멘토는 <code>이끌어 주는 사람</code> 이라는 뜻이 강하다.</p></blockquote><p>[출처: <a href="https://namu.wiki/w/%EB%A9%98%ED%86%A0" target="_blank" rel="noopener">나무위키-멘토</a>]</p><p>물론 멘토가 기술적으로 뛰어나서 멘토에게 직접적으로 배울 수 있다면 굉장히 좋을 수 있다. 하지만 필자가 생각하는 멘토란 꼭 기술적으로 월등히 뛰어나서 직접적으로 기술을 가르쳐주는 사람보단 방향을 제시해줄 수 있는 사람이라고 생각한다. 물론 기술적으로도 가르침을 받으면서 방향을 제시해줄 수 있는 멘토를 만난다면 더할 나위 없이 좋을 것이다. 필자의 경우 지금까지 6명 정도의 멘토를 만났다. 그분들 중 필자와 고등학교 동창인 사람도 있고, 전직장 동료인 사람도 있으며 혹은 학교에서 우연치 않게 만난 분 그리고 같은 이커머스 종사자인 분도 있다. 지금까지 2년 가까이 거의 매주 뵙고 있는 멘토님 같이 기술적으로 뿐만 아니라 충분한 방향성을 제시해주셨던 분도 계시지만 앞에서 언급한 모든 분들이 기술적으로 월등히 뛰어나서 멘토인 것은 아니다. 물론 지금은 웹 개발로 전향하시긴 했지만 이분들 중에는 아예 웹 개발을 하지 않았던 분도 계신다. 이 분들을 만나면서 필자의 경우는 기술적인 성장도 성장이지만, 기본적인 마음 가짐에 대한 성장에 많은 도움을 받았다고 생각한다. 기술적으로 성장하는 것은 멘토가 없이도 성장이 가능하지만, 마음 가짐에 대한 성장은 혼자서 바꾸기가 쉽지 않다. 누군가의 본보기가 되여 ‘나도 언젠가는 저 사람의 모습처럼 누군가에게 비춰지고 싶다’라는 귀감을 사기란 정말 제대로 된 멘토가 없다면 쉽지 않다. 아마 이 글을 읽는 여러분이라면 한번쯤은 그런 사람을 만나보지 않았을까란 생각을 한다. 반대로 말하자면 꼭 기술적으로 월등하지 않아도 되지 우리 모두 누군가의 멘토가 될 수 있다는 의미이기도 하다. 누군가의 귀감이 되어 닮고 싶은 사람이 된다는 것이 멋진 일이 아닐 수 없다:) </p><iframe width="560" height="315" src="https://www.youtube.com/embed/SQmSI82vbIM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>개인적으로 추천하는 멘토 관련된 동영상이다. 혹시나 궁금 하신 분은 한번 보시는 것도 추천한다.</p><p>여섯번째는 <code>탈진 극복</code>에 대한 내용이다. 필자의 경우 회사에서 일하는 시간 40시간을 제외하더라도 평균적으로 주 30시간 정도는 관련 지식을 쌓기 위해 공부를 하고 있다. 물론 프로젝트로 인해 야근을 하는 경우는 주에 15시간을 못 채우는 경우도 있지만, 정시 퇴근해서 한두시간 저녁 먹고 늦장부린다는 가정하에 대략적으로 30시간이다. 그리고 주변을 살펴보면 필자 뿐만 아니라 대부분의 개발자들이 그렇게 하고 있다. (개인적으로 이러한 개발자들과 함께 한다는 것이 얼마나 행복한 것인지를 깨달았다) 하지만 이러다보면 제일 중요한 것이 바로 컨디션 조절이다. 그리고 이러한 컨디션 조절에 실패한 경우 흔희 번아웃(Burn out)에 빠졌다고 표현한다.</p><p><img src="/images/review/soft-skill-review06.jpeg" alt="/images/review/soft-skill-review06.jpeg"></p><p>제일 위험한 것이 바로 이 번아웃 증후군에 걸린 경우이다. 이러한 증후근을 <code>정신적 탈진</code> 이라는 표현을 한다. 이러한 정신적 탈진을 극복하기란 쉽지 않다. 책에서는 정신적 탈진을 <code>벽</code>이라고 표현하며 벽 너머에는 좋은 보상이 존재하며 탈진이라는 고통을 견뎌야지만 더 강한 에너지와 성취 동기가 생긴다고 이야기 한다. 누구나 한번쯤은 이러한 번아웃 상태에 빠져본 경험이 있을 것이며, 그 벽의 높이는 개개인에게 다르게 와닿을 수 있다. 누군가에게는 별것 아닌 것처럼 비춰져보일 수 있지만 나에게는 그 벽이 마치 오르지 못할 산보다 더 높을 수도 있다.</p><p> <img src="/images/review/soft-skill-review07.jpeg" alt="/images/review/soft-skill-review07.jpeg"></p><p>책에서도 <code>그냥 넘으면 된다</code>고 표현하지만 목표를 성취하고 나서의 성취감은 그 산을 넘을 수 있는 충분한 이유가 되지 않을까란 생각을 한다. 마치 과거 우리가 엄청 큰 고민이라고 여겼던 것이 시간 지나고 보면 별것 아닌 것처럼 웃어넘기듯, 사실 <code>벽</code>을 넘고나면 별거 아니었을 수도 있다. 그러한 사실은 벽을 넘어본 사람들만 알 수 있는 또다른 특권이지 않을까? :-)</p><p> <img src="/images/review/soft-skill-review08.jpeg" alt="/images/review/soft-skill-review08.jpeg"></p><h3 id="이-책의-모든-것이-다-만족스웠을까"><a href="#이-책의-모든-것이-다-만족스웠을까" class="headerlink" title="이 책의 모든 것이 다 만족스웠을까?"></a>이 책의 모든 것이 다 만족스웠을까?</h3><p>앞에서 설명했듯 책의 모든 내용이 만족스러울 수 없고 도움이 되지는 않았다. 하지만 그런 부분들은 부동산이나 주식 등과 같이 저자와 같이 미국에 사는 사람들에게는 도움이 될 수 있을 내용이다. 이런 부분을 제외한다면 대체적으로 필자에게는 또다른 영감과 열의를 일으켜준 책이었다. 앞에서도 말했듯이 이러한 아쉬운 부분들은 개인적인 견해일 뿐 읽는 사람에 따라서는 또다른 영감과 느낌을 줄 수 있을 것 같다라는 생각을 한다. 만약 나에게 앞에서 설명했던 멘토가 없다고 생각된다면 이 책을 또다른 정신적 멘토로 삼고 천천히 읽어보는 것도 굉장히 좋을 것 같다.</p><p> <img src="/images/review/soft-skill-review09.jpeg" alt="/images/review/soft-skill-review09.jpeg"></p><p>끝으로 책의 한 부분에서 표현하듯 이 책은 스스로의 발전을 원하는 사람에게 또다른 성장을 가져다 주기에 충분한 책이라는 생각을 한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;들어가기전&quot;&gt;&lt;a href=&quot;#들어가기전&quot; class=&quot;headerlink&quot; title=&quot;들어가기전&quot;&gt;&lt;/a&gt;들어가기전&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;책에 대한 리뷰를 시작하기 전에 미리 이야기를 하자면 이 책에 대한 리뷰 작성은 
      
    
    </summary>
    
      <category term="Review" scheme="http://blog.martinwork.co.kr/categories/review/"/>
    
    
      <category term="소프트스킬" scheme="http://blog.martinwork.co.kr/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%8A%A4%ED%82%AC/"/>
    
      <category term="인생전략71가지" scheme="http://blog.martinwork.co.kr/tags/%EC%9D%B8%EC%83%9D%EC%A0%84%EB%9E%B571%EA%B0%80%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>티모니언으로 살아가기</title>
    <link href="http://blog.martinwork.co.kr/review/2019/03/07/be-a-tmonian.html"/>
    <id>http://blog.martinwork.co.kr/review/2019/03/07/be-a-tmonian.html</id>
    <published>2019-03-06T15:50:51.000Z</published>
    <updated>2019-03-15T12:49:11.162Z</updated>
    
    <content type="html"><![CDATA[<h2 id="들어가기전"><a href="#들어가기전" class="headerlink" title="들어가기전"></a>들어가기전</h2><blockquote><p>글을 시작하기에 앞서 미리 밝히자면, 이 글은 글쓴이의 아주 주관적인 의견이며 팀에 따라 혹은 시간에 따라 달라질 수 있음을 미리 밝힌다. 글쓴이의 경우 과거 <a href="https://blog.martinwork.co.kr/review/2018/12/29/remembrance-in-2018.html">2018년의 회고</a>에서도 밝혔듯 회사에 대한 만족도가 높은 상태에서 작성했을테니 너무 회사의 분위기나 글쓴이의 리뷰를 모두 신뢰하지 않길 바란다.</p></blockquote><p>지금 현재 글쓴이의 경우 티켓몬스터의 표준화 랩에서 배송 파트의 Typescript와 React를 이용하여 프론트 개발을 담당하고 있습니다. 아직은 부족한 점이 많은 개발자이지만, 좋은 프로덕트를 만들기 위해 온갖 잔머리를 굴리며 얼마 있지 않은 지식을 쥐어짜고 있습니다. 구매 내역 개편 프로젝트 이후 최근에는 서비스의 안정을 위해 최대한 테스트 코드를 빡세게 작성하여 커버리지를 올리기 위해 고군분투하고 있습니다. </p><h3 id="티켓몬스터에-합류하기"><a href="#티켓몬스터에-합류하기" class="headerlink" title="티켓몬스터에 합류하기"></a>티켓몬스터에 합류하기</h3><p>티몬의 채용 절차는 홈워크 통과 후 1차 기술 면접, 2차 CTO 면접 그리고 티몬만의 특별한 면접인 써드아이 면접 이렇게 3가지 면접으로 이루어진다. 글쓴이의 경우 1차 기술 면접에 총 3분이 들어왔고, 면접은 그동안 해왔던 업무에 대한 이야기와 그 업무 속에서 어떠한 점을 개선해갔는지에 대한 이야기를 주로 했다. 개인적으로는 편안한 분위기에서 진행되었다. 1차를 합격하고 나면 바로 그 유명한 2차 면접인 CTO 면접을 보게 된다. 이미 면접을 들어가기 전부터 2차 면접에 대한 분위기에 대해 익히 들어 마음의 준비를 하고 갔다고 생각했었지만 막상 닥치고 보니.. 정말 쉽지 않았다. (분위기에 대해 궁금하신 분은 잡X래닛에 면접 관련 후기를 보면 많이 나와있다.) </p><p><img src="/images/review/be-a-tmonian01.png" alt="/images/review/be-a-tmonian01.png"></p><p>질문에 대한 대답을 거의 하지 못했다. 그렇게 대략 30-40분 정도의 2차 면접이 끝나면 바로 써드아이 면접을 보게 된다. 써드 아이는 같은 직군의 사람이 들어와서 보는 면접이 아니라 다른 직군 사람과의 면접으로 쉽게 생각해서 회사의 문화에 어울리는 사람인지 등을 보는 면접이라고 생각하면 될 것 같다. 나중에 들은 이야기이지만 2차 면접에서 멘탈이 깨진 많은 사람들이 써드 아이 면접에 임할 때 이미 떨어졌다고 가정하고 면접에 임하는 경우가 많다고 한다. 하지만 걱정할 필요 없다:) 입사하여 만난 대부분의 티모니언들이 2차에서 여러분과 똑같은 생각을 했다고 하니, 써드아이 면접에 임할 때도 최선을 다하길 바란다. 글쓴이 역시 마찬가지였다. 면접을 여러번 본 경험이 있다면 면접에서의 분위기만 봐도 내가 떨어졌는지 알 수 있는데, 이때가 바로 내가 떨어졌다고 생각된 때였다. 하지만 면접 끝나고 1시간도 채 되지 않아 최종 합격 전화를 받게 되었다. 여러분은 모두 뛰어난 사람이니 2차 면접에서 너무 기죽지 않았으면 하는 바램이다 :-) </p><p>최종 처우 협의 후 2018년 10월 15일, 티모니언으로 티켓몬스터에 합류하게 되었다. </p><p><img src="/images/review/be-a-tmonian02.png" alt="/images/review/be-a-tmonian02.png"></p><p>참고로 덧붙이자면 티켓몬스터의 임직원을 티모니언이라고 부른다. 입사 첫 날 업무 지원 센터에서 기다리게 되는데 그때 마주칠 수 있는 광경이다. </p><p><img src="/images/review/be-a-tmonian03.png" alt="/images/review/be-a-tmonian03.png"></p><p>그렇게 기다리다보면 인사팀과의 계약서 작성 후, 앞으로 일하게 될 자리를 배치 받게 되며 그 자리에는 웰컴 키트가 놓여 있다.</p><p><img src="/images/review/be-a-tmonian04.png" alt="/images/review/be-a-tmonian04.png"></p><p>사실 티몬이라는 회사를 좋아했던 가장 큰 이유는 바로 이러한 브랜딩이었던 것 같다. 문방사우 세트와 티몬 케릭터 나노 블럭과 티셔츠, 임시 사원증 등등이 들어있지만 개인적으로 제일 마음에 드는 것은 티셔츠였다. 물론 입사할 때가 아직은 반팔을 입을 때가 아니라 티셔츠를 입어보진 못했지만 여름이 되면 교복과 같이 입고 다니지 않을까 싶다 :-)/images/review/be-a-tmonian02.png</p><p>그리고 그 자리에는 윈도우 데스크탑이 놓여있다. 이 때 굉장히 괴리감이 들 수 있다. 맥북도 아니고 윈도우에 데스크탑이라니…. </p><p><img src="/images/review/be-a-tmonian05.png" alt="/images/review/be-a-tmonian05.png"></p><p>하지만 걱정 안해도 된다. 13인치의 맥북을 하나 더 준다. 윈도우는 처음 끄적끄적하다보면 킬일이 거의 없다. 물론 윈도우에서 개발하는 경우는 예외로 한다. </p><h3 id="티모니언이-누릴-수-있는-복지"><a href="#티모니언이-누릴-수-있는-복지" class="headerlink" title="티모니언이 누릴 수 있는 복지"></a>티모니언이 누릴 수 있는 복지</h3><p>아마 많은 분들이 궁금해 하는 것이 티모니언이 되면 누릴 수 있는 복지가 무엇인지에 대한 궁금점이지 않을까 싶다. </p><p>첫번째는 지하에 티모니언들만 이용할 수 있는 저렴한 카페가 있다는 점이다. 아메리카노가 1,000원 정도로 굉장히 저렴한 편이다.</p><p><img src="/images/review/be-a-tmonian06.png" alt="/images/review/be-a-tmonian06.png"></p><p>이전 회사에서도 사내 카페가 있었지만, 전 회사의 사내 카페보단 티몽 카페가 훨씬 넓고, 그 옆에 조그만하게나마 간단한 간식 거리를 살 수 있는 공간도 있다. </p><p>두번째는 헬스장에 대한 지원이다. 물론 하루에 한번으로 제한되어 있지만 듣기로는 회원권만 해도 가격이 어마어마하다고 한다. </p><p><img src="/images/review/be-a-tmonian07.png" alt="/images/review/be-a-tmonian07.png"></p><p>사실 글쓴이의 경우 운동을 좋아하지 않아 헬스장이 무슨 의미가 있거나 싶었지만, 그 헬스장과 함께 운영되는 사우나가 가고 나서 생각이 바뀌었다. 사우나의 시설이 엄청 좋아 점심시간에 식사를 일찍 하고 가서 피로를 푸는 사람들도 있으니 ‘아, 난 운동도 안하는데 이게 무슨 복지람’ 이라고 생각하시는 분들에게는 사우나를 추천한다:)</p><p>세번째로는 <code>슈퍼패스</code> 라는 특이한 형태의 휴가이다. 이러한 형태의 휴가를 운영하는 회사들도 종종 있는 것 같다. 이 휴가는 연차와는 별개로 지급되는 또다른 복지로서 반반차와 같이 2시간 휴가권이라고 보면 된다. 처음 입사했을 때는 상/하반기 각각 4개 정도였으나 지금은 현재 상/하반기 각각 6개로 변경되었다. 당일 바로 사용해도 무방하며 늦게 출근하든 조기 퇴근 하던 자유롭게 이용할 수 있다. 팀에 따라 다르겠지만 휴가 사용에 있어 큰 제약이 없기 때문에 언제든 편하게 사용할 수 있다. </p><p>네번째는 재택 근무이다. 개인적으로는 이 복지가 제일 마음에 든다. 아마 부서별로 다르겠지만 이 복지의 경우 CTO 조직에만 적용된다. 휴가와는 다르게 워킹데이로 2일전에는 미리 신청을 해야 하며, 재택 근무 후에는 별도의 보고서를 제출해야 한다. 종종 월요병이나 연휴로의 피로감으로 인해 회사까지 출근하기가 귀찮다라는 게 예상되는 날이면 미리 재택 근무를 신청하여 어디서든 편하게 근무를 할 수 있다:) 다만 한달에 2회라는 제약점이 있다는 것은 아쉽다. </p><p>이 외에도 화요일에 한해 모닝빵 제공이라던지, 명절 귀성버스 제공 등의 복지가 있지만 객관적으로 생각했을 때, 복지가 많다고 생각되진 않는다. 하지만 이러한 복지보다는 함께 일하는 동료들이 회사에서 제공해주는 최고의 복지가 아닐까란 생각을 한다. 물론 이또한 주관적이기 때문에 강조하지는 않는다:-)</p><h3 id="티몬의-개발-문화"><a href="#티몬의-개발-문화" class="headerlink" title="티몬의 개발 문화"></a>티몬의 개발 문화</h3><p>개인적으로 티몬의 개발 문화는 굉장히 자유로우며 기술 선택에 있어서도 제약이 많이 따른다고 생각하진 않는다. 물론 이러한 점은 팀에 따라서 다를 수 있다. 또한 팀에 따라서 사용하는 기술이 다를 수 있지만 스스로 책임을 질 수 있다면 새로운 기술을 도입함에 있어 큰 제약이 따르지 않는다. 자신의 도메인과 프로덕트에 대한 책임감은 당연하다는 입장에서 이정도의 제약은 새로운 기술의 도입에 큰 제약이라고 생각하진 않는다. 참고로 필자의 경우에는 프론트 개발팀 내에서 처음으로 타입스크립트를 도입하여 개발을 했다. 물론 새로운 기술을 도입함에 있어 같은 코드를 보는 팀원들간의 도입의 타당성에 대해서는 이야기를 해본 후 도입을 해야겠지만, 성장을 추구하는 티몬의 개발 문화에서 논리 없는 반대 의견에 부딪히는 경우는 거의 없었던 것 같다. 글쓴이가 속한 팀의 전체 연령이 타팀에 비해 전체적으로 연령대가 낮다보니 아마 더 열정에 넘쳐서 일수도 있을 것이다.</p><h3 id="끝으로"><a href="#끝으로" class="headerlink" title="끝으로.."></a>끝으로..</h3><p>이 글은 전 직장 동료의 <a href="https://jybaek.tistory.com/708" target="_blank" rel="noopener">위드이노베이션에 합류해서 젊은이로 살아가기</a> 라는 글을 본 후, 동의를 구하여 또다른 버전의 젊은이로 살아가기를 작성하게 되었습니다. 아마 회사에 입사하기 전 저와 같이 회사에 대해 궁금한 점이 많은 분들을 위해 조금이나마 도움이 되었으면 좋겠습니다. 혹은 그 전까지는 별 생각이 없다가 이 글을 본 후, <code>나도 한번 티모니언이 되어볼까?</code> 라는 생각을 하게 된다면 언제든 지원을 해보시는 것도 좋을 것 같습니다:) 이 외에도 이야기하지 못한 회사의 이야기들이 많을 테지만.. 지금 이 글을 작성하는 시간이 새벽이라 병든 닭처럼 졸며 쓰기 때문에 기억이 나질 않습니다… 혹시나 이 글에 나와있는 내용 혹은 이외에 궁금한 점이 있다면 메일 혹은 댓글 혹은 SNS을 통해 연락주시면 친절하게 답변드리도록 하겠습니다. 채용 공고에 대한 자세한 내용은 <a href="https://recruit.tmon.co.kr/recruit/list/000#page=1" target="_blank" rel="noopener">티켓몬스터 채용 공고 홈페이지</a>에서 확인 가능합니다. 긴 글 읽어주셔서 감사합니다:)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;들어가기전&quot;&gt;&lt;a href=&quot;#들어가기전&quot; class=&quot;headerlink&quot; title=&quot;들어가기전&quot;&gt;&lt;/a&gt;들어가기전&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;글을 시작하기에 앞서 미리 밝히자면, 이 글은 글쓴이의 아주 주관적인 의견이며 팀
      
    
    </summary>
    
      <category term="Review" scheme="http://blog.martinwork.co.kr/categories/review/"/>
    
    
      <category term="티켓몬스터" scheme="http://blog.martinwork.co.kr/tags/%ED%8B%B0%EC%BC%93%EB%AA%AC%EC%8A%A4%ED%84%B0/"/>
    
      <category term="TMON" scheme="http://blog.martinwork.co.kr/tags/tmon/"/>
    
      <category term="티모니언" scheme="http://blog.martinwork.co.kr/tags/%ED%8B%B0%EB%AA%A8%EB%8B%88%EC%96%B8/"/>
    
  </entry>
  
  <entry>
    <title>초보자의 GCP 사용기</title>
    <link href="http://blog.martinwork.co.kr/devops/2019/01/21/gcp-services-for-web-system.html"/>
    <id>http://blog.martinwork.co.kr/devops/2019/01/21/gcp-services-for-web-system.html</id>
    <published>2019-01-20T15:50:51.000Z</published>
    <updated>2019-03-15T12:49:11.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="들어가기-전"><a href="#들어가기-전" class="headerlink" title="들어가기 전"></a>들어가기 전</h2><p>본 포스팅은 구글 클라우드 플랫폼 사용자 그룹의 운영진인 <a href="https://www.facebook.com/WeGuardia?fref=gs&amp;__tn__=%2CdlC-R-R&amp;eid=ARCD0Yd6Ytb1Y_d63Sa9ZLatHm8yuJM-JFfwTq4CSs20_yszNcEoNYbFsKhrOUVjqYvwO5QD4a_65lAd&amp;hc_ref=ARTEl1G9KE36EgnIEOPf1tdGMjPLdlWR6m4ZGvEq0KgsRIf-qL3KY0ZE6WRqihAb8Us&amp;dti=540095029455098&amp;hc_location=group" target="_blank" rel="noopener">Jaeyeon Baek</a> 님과의 스터디에 대한 기록입니다. 또한 이 글은 <a href="http://www.yes24.com/24/goods/59229108" target="_blank" rel="noopener">구글 클라우드 플랫폼 입문</a> 이라는 도서에 대한 리뷰 및 개인적인 스터디 기록임을 미리 밝힙니다. </p><h3 id="Google-Compute-Engine-GCE"><a href="#Google-Compute-Engine-GCE" class="headerlink" title="Google Compute Engine(GCE)"></a>Google Compute Engine(GCE)</h3><p>GCE는 GCP에서 제공 하는 가상 머신 서비스이다. 일반적인 클라우드 환경에 비해 가상머신의 기동이 빠르고 초 단위로 청구가 과금이 되기 때문에 사용한 컴퓨팅 시간에 대해서만 요금을 지불하면 된다. 가상 머신의 두가지 타입의 메모리 인스턴스를 제공하는데 첫번째는 <code>사전 정의된 머신 유형</code>이다. 해당 유형을 사용하는 경우 마이크로 인스턴스에서부터 3.75TB까지 용도에 따라 사전 정의된 가상 머신 인스턴스를 사용할 수 있다. 두번째 타입은 <code>커스텀 머신 유형</code>이다. 이러한 경우는 사전 정의 머신 유형과는 다르게 vCPU나 메모리 등 구체적인 요구사항을 조정하여 이용할 수 있다. 만약 운용하려고 하는 서비스의 스펙에 대해서 명확하다면 커스텀 머신 유형을 이용하는 것이 비용 절감에도 도움이 된다. </p><p>GCE에서는 가상 머신에 접속이 가능한 두가지 종류의 저장소를 제공해준다. 첫번째는 최대 10TB의 <code>네트워크 저장소인 영구 디스크</code>이다. 영구 디스크는 SSD나 HDD 형식 중 하나를 선택해서 만들 수 있으며 해당 VM 인스턴스가 종료되어도 영구 디스크에 데이터가 유지가 되며 다른 가상머신 인스턴스에서 접근을 해도 이용할 수 있다. 두번째는 로컬 SSD이다. 로컬 SSD는 가상 머신 인스턴스를 호스팅하는 서버에 실제로 연결되므로 영구 디스크와 비교하여 IOPS(입출력 초당 작업수)가 매우 높고 레이턴시(지연시간)가 매우 낮다. vCPU가 1개 이상인 가상 머신에 최대 3TB의 로컬 SSD를 사용할 수 있다. </p><p>Debian, CentOS, CoreOS, Ununtu, Red Hat, Windows 등 원하는 OS를 실행시킬 수 있으며, 뿐만 아니라 GCP 커뮤니티에서 얻은 이미지나 혹은 스스로 만든 이미지를 사용할 수 있다. 이러한 GCE 가상 머신의 각각의 인스턴스는 독립된 네트워크로 접속된다. 물리적으로 다른 지역에 속한 인스턴스더라도 같은 네트워크에 접속되어있다면 내부 IP 주소를 통해 통신할 수 있다. </p><p>또한 GCE에서는 라이브 마이그레이션 지원한다. 라이브 마이그레이션은 말 그대로 어떤 물리 서버에서 운용 중인 가상머신을 다른 물리서버로 서비스 중단 없이 이동하는 기술이다. 만약 물리 서버의 유지 보수와 같이 데이터 센터 안에서 물리 서버를 정지해야하는 경우에는 해당 머신은 라이브 마이그레이션을 사용하여 다른 호스트 머신에 자동으로 이동된다.</p><h3 id="Google-Cloud-Storage"><a href="#Google-Cloud-Storage" class="headerlink" title="Google Cloud Storage"></a>Google Cloud Storage</h3><p>Cloud Storage는 높은 가용성과 내구성을 가진 오브젝트 저장소이다. 전 세계에 엣지 캐시를 가지기 때문에 사용자가 어디에 있든 빠르게 접근할 수 있다. Google App Engine이나 GCE로 동작하는 어플리케이션이나 BigQuery, Cloud Dataflow, Cloud Dataproc 등과 같은 데이터 처리 서비스의 백엔드 저장소로도 이용할 수 있다. 이러한 서비스는 아래의 4가지 저장소 등급의 가격의 서비스를 제공하니 목적에 따라 원하는 서비스를 선택하면 좋다.</p><p><img src="/images/devops/gcp-services-for-web-system01.png" alt="/images/devops/gcp-services-for-web-system01.png"></p><p>해당 서비스에서는 2가지 중요한 단어가 나온다. </p><h4 id="버킷이란-무엇인가"><a href="#버킷이란-무엇인가" class="headerlink" title="버킷이란 무엇인가"></a>버킷이란 무엇인가</h4><p>버킷이란 데이터를 담는 기본 컨테이너이다. Cloud Storage에 저장되는 모든 데이터는 버킷 안에 포함된다는 의미이기도 하다.</p><h4 id="오브젝트란-무엇인가"><a href="#오브젝트란-무엇인가" class="headerlink" title="오브젝트란 무엇인가"></a>오브젝트란 무엇인가</h4><p>Object는 Cloud Storage에 저장되는 개별 데이터 조각이다.</p><h3 id="Google-Cloud-SQL"><a href="#Google-Cloud-SQL" class="headerlink" title="Google Cloud SQL"></a>Google Cloud SQL</h3><p>Cloud SQL은 앞서 설명했던 RDBMS의 한 종류인 MySQL을 제공하는 완전 관리형 서비스이다. 해당 서비스에서는 MySQL의 실행 환경이 자동으로 만들어지고 백업이나 유지보수도 자동으로 이뤄진다.<br>MySQL의 완전 관리형 서비스<br>유지보수<br>어플리케이션에서 이용</p><hr><h2 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h2><ul><li><a href="https://cloud.google.com/gcp/?hl=ko&amp;utm_source=google&amp;utm_medium=cpc&amp;utm_campaign=japac-KR-all-ko-dr-bkws-all-super-trial-e-dr-1003987&amp;utm_content=text-ad-none-none-DEV_c-CRE_249736095777-ADGP_Hybrid%20%7C%20AW%20SEM%20%7C%20BKWS%20~%20T1%20%7C%20EXA%20%7C%20General%20%7C%201:1%20%7C%20KR%20%7C%20ko%20%7C%20cloud%20platform%20%7C%20google%20cloud%20platforms%20%7C%20en-KWID_43700030027797675-kwd-141425403689&amp;userloc_1009871&amp;utm_term=KW_google%20cloud%20platforms&amp;gclid=EAIaIQobChMI0O_h_L2A4AIVjRsqCh1TlgUqEAAYASAAEgKSiPD_BwE" target="_blank" rel="noopener">Google Cloud 공식홈페이지</a></li><li><a href="https://cloud.google.com/storage/docs/key-terms?hl=ko#buckets" target="_blank" rel="noopener">Google Cloud 공식홈페이지-Google Cloud Storage</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;들어가기-전&quot;&gt;&lt;a href=&quot;#들어가기-전&quot; class=&quot;headerlink&quot; title=&quot;들어가기 전&quot;&gt;&lt;/a&gt;들어가기 전&lt;/h2&gt;&lt;p&gt;본 포스팅은 구글 클라우드 플랫폼 사용자 그룹의 운영진인 &lt;a href=&quot;https://www.f
      
    
    </summary>
    
      <category term="Devops" scheme="http://blog.martinwork.co.kr/categories/devops/"/>
    
    
      <category term="Google Cloud Platform" scheme="http://blog.martinwork.co.kr/tags/google-cloud-platform/"/>
    
  </entry>
  
  <entry>
    <title>초보자의 GCP 사용기</title>
    <link href="http://blog.martinwork.co.kr/devops/2019/01/21/what-kind-of-web-service.html"/>
    <id>http://blog.martinwork.co.kr/devops/2019/01/21/what-kind-of-web-service.html</id>
    <published>2019-01-20T15:50:51.000Z</published>
    <updated>2019-03-15T12:49:11.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="들어가기-전"><a href="#들어가기-전" class="headerlink" title="들어가기 전"></a>들어가기 전</h2><p>본 포스팅은 구글 클라우드 플랫폼 사용자 그룹의 운영진인 <a href="https://www.facebook.com/WeGuardia?fref=gs&amp;__tn__=%2CdlC-R-R&amp;eid=ARCD0Yd6Ytb1Y_d63Sa9ZLatHm8yuJM-JFfwTq4CSs20_yszNcEoNYbFsKhrOUVjqYvwO5QD4a_65lAd&amp;hc_ref=ARTEl1G9KE36EgnIEOPf1tdGMjPLdlWR6m4ZGvEq0KgsRIf-qL3KY0ZE6WRqihAb8Us&amp;dti=540095029455098&amp;hc_location=group" target="_blank" rel="noopener">Jaeyeon Baek</a> 님과의 스터디에 대한 기록입니다. 또한 이 글은 <a href="http://www.yes24.com/24/goods/59229108" target="_blank" rel="noopener">구글 클라우드 플랫폼 입문</a> 이라는 도서에 대한 리뷰 및 개인적인 스터디 기록임을 미리 밝힙니다. </p><h3 id="웹-서비스의-종류"><a href="#웹-서비스의-종류" class="headerlink" title="웹 서비스의 종류"></a>웹 서비스의 종류</h3><p>우리가 주로 이용하는 클라우드 서비스, 예를 들어 AWS나 GCP 혹은 Azure와 같은 서비스를 이용하기 전에 기본적으로 알아야 할 것이 있다. 그것이 바로  어플리케이션의 종류와 동작하는 방식 등이다. 그 안에는 웹 어플리케이션과 앱 어플리케이션, HTTP 통신 규약 혹은 데이터베이스에 대한 것들이 포함되어 있다. 이러한 대부분의 것들이 앞으로 학습할 GCP 공부에 도움이 되길 바라며 간단히 정리를 해보았다.</p><p>우리가 주로 사용하는 많은 서비스들은 거의 대부분 웹 어플리케이션이나 앱 어플리케이션에 포함되는 경우가 많다. 쇼핑을 위한 이커머스 서비스, 정보 검색을 위한 포털 서비스, 숙박을 위한 배달 앱 서비스 등등 편의를 위한 서비스를 제공해주는 많은 훌륭한 회사들이 많다. 우리가 PC나 모바일 웹에서 도메인을 기반으로 검색하고 들어가는 사이트들은 거의 <code>웹 어플리케이션</code>인 경우가 많다. 반대로 앱스토어에서 다운받은 어플리케이션의 경우에는 <code>네이티브 어플리케이션</code>인 경우가 많다. 하지만 앱스토어에서 받았다고 하더라도 모든 어플리케이션이 네이티브 어플리케이션은 아니다. 요즘은 네이티브 어플리케이션과 반응형 웹을 이용하여 <code>하이브리드 형태</code>로 제작하는 경우도 많다. 그러한 경우는 물론 여러가지 이유가 있겠지만, 개인적으로 생각했을 때 가장 큰 이유 중 하나는 <code>플랫폼 별 리소스</code> 를 집중적으로 관리하기 위해서가 아닐까란 생각을 한다. 네이티브 앱 개발자도 IOS 개발자가 있고 Android 개발자가 있다. 물론 각자 사용하는 프레임워크도 다르고 언어도 다를 수 있다. 이런식으로 플랫폼 별로 리소스를 별도로 관리를 해준다면 버전 관리, 동일한 사용자 경험 부여 등의 문제가 생길 수 있다. </p><p><img src="/images/devops/what-kind-of-web-service01.png" alt="/images/devops/what-kind-of-web-service01.png"></p><p>이러한 여러 가지 플랫폼들을 공통적으로 백엔드(Back-end)서버 혹은 API 서버라고 불리는 웹 서버와 요청(Request)와 응답(Response)을 주고 받는다. </p><p><img src="/images/devops/what-kind-of-web-service02.png" alt="/images/devops/what-kind-of-web-service02.png"></p><h3 id="URL와-Method의-종류"><a href="#URL와-Method의-종류" class="headerlink" title="URL와 Method의 종류"></a>URL와 Method의 종류</h3><p>이러한 API 서버는 상황에 따라서는 여러 대일수도 있습니다. 클라이언트에서는 어떠한 자원이 필요한지를 알고 원하는 자원에 대한 요청을 합니다. 그러한 원하는 자원은 URL(Uniform Resource Locator)을 지정하게 됩니다.  </p><p><img src="/images/devops/what-kind-of-web-service03.png" alt="/images/devops/what-kind-of-web-service03.png"></p><p>위의 URL 중 사용자 이름(user)와 비밀번호(password), 그리고 포트번호(port) 등 아마 생소한 것들도 있을 것이다. 우리가 URL을 통해 이용하는 많은 웹 사이트들의 경우 사용자 이름이나 비밀번호 같은 경우 생략 되어져있다. 또는 포트번호와 같이 기본 포트(80)로 지정이 되어있거나 포트 포워딩을 통해 우리가 URL만 보고는 쉽게 유추할 수 없는 경우도 많다.</p><p>단순히 이러한 URL만 있다고 해서 모든 요청을 API서버에서 알아서 할 순 없습니다. 그래서 우리는 요청에 대한 메소드(Method)와 함께 요청을 보냅니다. 보통 많이 사용하는 Method는 <code>Get, Post, Put, Delete</code> 등이 있으며 종종 <code>Option</code> 메소드도 볼 수 있다. 이러한 메소드와 URI(Uniform Resource Identifier)을 통해 RESTful API 설계를 많이 한다. RESTful API에 대한 이야기는 해당 포스팅 주제가 아니므로 별도로 다루진 않는다. 궁금한 경우는 <a href="https://blog.martinwork.co.kr/theory/2017/11/11/what-is-restful-api.html">여기</a>에서 확인할 수 있다.</p><p>각 메소드들에 대해서 간단히 설명을 하면 다음과 같이 설명할 수 있다.</p><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Description              </th></tr></thead><tbody><tr><td style="text-align:left">Get</td><td style="text-align:left">해당 자원을 조회할 때 사용</td></tr><tr><td style="text-align:left">Post</td><td style="text-align:left">해당 자원을 생할 때 사용 </td></tr><tr><td style="text-align:left">Put</td><td style="text-align:left">해당 자원을 수정할 때 사용 </td></tr><tr><td style="text-align:left">Delete</td><td style="text-align:left">해당 자원을 삭제할 때 사용 </td></tr><tr><td style="text-align:left">Option</td><td style="text-align:left">Preflight(사전 전달)의 역할을 함으로써 해당 요청 전 해당 자원에 대한 지원여부를 확인할 때 사용</td></tr></tbody></table><p>이러한 요청에 대한 결과값은 상태(Status)와 함께 응답을 준다.</p><h3 id="Status-규약"><a href="#Status-규약" class="headerlink" title="Status 규약"></a>Status 규약</h3><p>HTTP Request status codes HTTP 상태 코드는 특정 HTTP 요청에 대한 상태를 나타내준다. HTTP 표쥰 규약의 경우 3자리수로 이루어져 있으며 각자 대역별로 추상적인 의미를 가지게 된다.</p><h4 id="Success-status-2XX"><a href="#Success-status-2XX" class="headerlink" title="Success status(2XX)"></a>Success status(2XX)</h4><p>해당 상태들은 클라이언트에서 요청한 동작을 수신하여 이해해서 성공적으로 처리했음을 의미 한다. </p><table><thead><tr><th style="text-align:left">Status</th><th style="text-align:left">Message</th><th style="text-align:left">Information</th></tr></thead><tbody><tr><td style="text-align:left">200</td><td style="text-align:left">OK</td><td style="text-align:left">요청 성공(단, HTTP method에 따라 성공 의미는 다름)</td></tr><tr><td style="text-align:left">201</td><td style="text-align:left">Created</td><td style="text-align:left">요청이 성공하여, 새로운 리소스가 생성(put, post methods에 해당)</td></tr><tr><td style="text-align:left">202</td><td style="text-align:left">Accepted</td><td style="text-align:left">요청을 성공적으로 수신하였으나 처리되지 않음. 비동기 처리에서 사용하며 response 에는 결과가 포함되지 않을 수도 있음.</td></tr></tbody></table><h3 id="Redirect-status-3xx"><a href="#Redirect-status-3xx" class="headerlink" title="Redirect status(3xx)"></a>Redirect status(3xx)</h3><p>해당 상태들을 클라이언트에서 요청을 한 후, 그 요청을 마무리하기 추가적인 액션을 취해야 함을 의미한다.</p><table><thead><tr><th style="text-align:left">Status</th><th style="text-align:left">Message</th><th style="text-align:left">Information</th></tr></thead><tbody><tr><td style="text-align:left">301</td><td style="text-align:left">Moved Permanently</td><td style="text-align:left">요청한 리소스의 URI가 영구적으로 변경되었음을 의미하며, 새로운 URI를 response 에 포함.</td></tr><tr><td style="text-align:left">302</td><td style="text-align:left">Found</td><td style="text-align:left">요청한 리소스의 URI가 임시적으로 변경되었으며, 이후에는 요청한 리소스의 URI 로 돌아올 예정임. </td></tr></tbody></table><h3 id="Error-in-client-status-4xx"><a href="#Error-in-client-status-4xx" class="headerlink" title="Error in client status(4xx)"></a>Error in client status(4xx)</h3><p>해당 상태는 클라이언트의 요청에 뭔가의 오류가 있음을 의미한다.</p><table><thead><tr><th style="text-align:left">Status</th><th style="text-align:left">Message</th><th style="text-align:left">Information</th></tr></thead><tbody><tr><td style="text-align:left">400</td><td style="text-align:left">Bad Request</td><td style="text-align:left">클라이언트에 보낸 요청을 서버에서 이해할 수 없음</td></tr><tr><td style="text-align:left">401</td><td style="text-align:left">Unauthorized</td><td style="text-align:left">요청한 리소스에 대한 권한이 없음을 의미(인증되지 않은 경우) </td></tr><tr><td style="text-align:left">403</td><td style="text-align:left">Forbidden</td><td style="text-align:left">요청한 리소스에 대한 접근 권한이 없음을 의미하며 401과 다른점은 서버에서는 요청자를 알고 있으나, 인증여부 상관없이 비공개인 경우</td></tr><tr><td style="text-align:left">404</td><td style="text-align:left">Not Found</td><td style="text-align:left">요청한 리소스의 URI가 없음을 의미</td></tr><tr><td style="text-align:left">405</td><td style="text-align:left">Method Not Allowed</td><td style="text-align:left">요청한 리소스의 URI에 요청한 메소드가 정의되어 있지 않을 경우</td></tr></tbody></table><h3 id="Error-in-server-status-5xx"><a href="#Error-in-server-status-5xx" class="headerlink" title="Error in server status(5xx)"></a>Error in server status(5xx)</h3><p>4xx는 클라이언트의 오류일 경우라고 한다면, 해당 상태는 서버에 오류가 있음을 의미한다.</p><table><thead><tr><th style="text-align:left">Status</th><th style="text-align:left">Message</th><th style="text-align:left">Information</th></tr></thead><tbody><tr><td style="text-align:left">500</td><td style="text-align:left">Internal Server Error</td><td style="text-align:left">서버 내부에 오류가 있어 요청을 수행할 수 없음 </td></tr><tr><td style="text-align:left">502</td><td style="text-align:left">Bad Gateway</td><td style="text-align:left">서버가 게이트웨이나 프록시 역할을 하고 있거나 또는 업스트림 서버에서 잘못된 응답을 받음</td></tr><tr><td style="text-align:left">503</td><td style="text-align:left">Service Unavailable</td><td style="text-align:left">서버가 가부하에 걸렸거나, 유지보수를 위하여 접근이 거부</td></tr></tbody></table><h3 id="데이터-베이스"><a href="#데이터-베이스" class="headerlink" title="데이터 베이스"></a>데이터 베이스</h3><p>이전까지 클라이언트와 API서버와의 커뮤니케이션 과정을 살펴보았다. 이제는 어플리케이션의 보다더 뒷단을 살펴볼 필요가 있다. 클라이언트와 API서버가 서로 리소스에 대한 커뮤니케이션 하는 과정에서 일어나는 대부분의 행동은 데이터 베이스에 저장이 된다.</p><p><img src="/images/devops/what-kind-of-web-service04.png" alt="/images/devops/what-kind-of-web-service04.png"></p><p>이러한 데이터 베이스에는 크게 두가지 종류가 있다. </p><h3 id="관계형-데이터-베이스-관리-시스템-RDBMS"><a href="#관계형-데이터-베이스-관리-시스템-RDBMS" class="headerlink" title="관계형 데이터 베이스 관리 시스템 RDBMS"></a>관계형 데이터 베이스 관리 시스템 RDBMS</h3><p>아마 데이터베이스를 사용할 때 제일 많이 이용하는 데이터 베이스가 아닐까 싶다. 데이터베이스 하면 대표적으로 생각나는 Mysql도 이 안에 해당한다. RDBMS는 Relational Database Management System의 약자로서 스프레드시트 같은 형태의 데이터 베이스를 생각하면 이해하기 쉽다. RDBMS는 IBM 산호세 연구소의 <a href="https://ko.wikipedia.org/wiki/%EC%97%90%EB%93%9C%EA%B1%B0_F._%EC%BB%A4%EB%93%9C" target="_blank" rel="noopener">에드거 F. 커드</a>가 도입한 관계형 모델을 기반으로 한다. 관계형 데이터 베이스는 만들거나 이용하기가 쉽다. 처음 데이터 베이스는 만든 후 관련되는 응용 프로그램들은 변경하지 않고, 새로운 데이터 항목을 데이터 베이스에 추가 할 수 있다(파일이나 네트웍 데이터베이스 등, 그 이전의 데이터베이스들은 항목이 수정되면, 그 데이터베이스를 사용하는 모든 응용 프로그램도 함께 수정해야하는 어려움이 있었다). </p><p>관계형 데이터베이스는 미리 정의된 내용에 따라 테이블들이 구성되는데, 각 테이블은 데이터 종류나 성격에 따라 여러 개의 컬럼(column)이 포함될 수 있다. 예를 들어, 주문거래 데이터베이스에는 <code>성명, 주소, 전화번호</code> 등의 컬럼 항목으로 구성된 테이블과 또한 주문내용(제품, 고객, 일자, 판매가격 등)을 나타내는 테이블이 포함될 수 있다. 이러한 데이터는 사용자의 필요에 맞는 형태로 데이터베이스의 내용을 볼 수 있다. 또한, 관계형 데이터베이스를 구축할 때 데이터 컬럼이 가질 수 있는 값의 범위(domain)나, 그 값에 적용될 수 있는 제한사항(constraint)을 정의할 수 있다. 예를 들어, 고객의 성명을 빈 칸으로 남겨 놓지 못하게 한다거나, 판매가격에는 마이너스(-) 값이 올 수 없도록 제한할 수 있다. 관계형 데이터베이스를 정의하게 되면 그 테이블이나 컬럼, 도메인 및 제한사항에 대한 내용을 가진 메타 데이터(metadata) 테이블이 함께 만들어진다. 이러한 RDBMS를 GCP에서는 <code>Cloud SQL</code>이라는 서비스를 통해 이용할 수 있다.</p><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>관계형 데이터 베이스와는 전혀 다른 형태의 데이터 베이스이다. NoSQL은 오랫동안 사용되어진 관계형 데이터와는 다르게 2000년대 초반부터 떠오르기 시작하였다. 과거 빅데이터의 등장에 따라 RDBMS만을 이용해서는 데이터를 처리하는 데 드는 비용의 증가를 막을 수 없었다. 데이터의 양과 트래픽을 한 대에서 실행되도록 설계된 RDBMS의 <code>Scale-up 비용</code>이 기하급수적으로 증가했기 때문이다. 이러한 상황에서 <code>Scale-out</code>을 목표로 등장한 데이터 베이스가 바로 NoSQL이다. 대표적인 데이터베이스로는 Redis나 MongoDB가 포함된다. 주된 데이터 모델의 방식은 KVS(Key-Value Store) 방식이다. </p><p>NoSQL은 대규모의 데이터와 트래픽을 위해 설계되었기 때문에 많은 양의 데이터를 다뤄야하는 채팅 데이터나 로그 데이터를 저장하는 데 용이하다. NoSQL은 관계형 데이터 베이스에 비해 유연한 데이터 모델을 사용하며  비정형 데이터를 다룰 때 그 빛을 바랄 수 있다. 또한 key-value 방식의 데이터 모델을 사용하기에 응답 속도나 처리 효율에 있어 뛰어난 성능을 보여준다. 이러한 NoSQL을 GCP에서는 Cloud DataStore와 Cloud Bigtable을 통해 서비스하고 있다.</p><h3 id="SQL문"><a href="#SQL문" class="headerlink" title="SQL문"></a>SQL문</h3><p>위에서 살펴본 SQL문을 통해 데이터에 접근할 수 있습니다.</p><ol><li>데이터 정의 언어(DDL: Data Definition Language)<br><code>데이터를 저장하는 구조를 정의</code>하기 위한 명령어로서 <code>CREATE문(생성)</code>, <code>DROP문(삭제)</code>, <code>ALERT문(변경)</code>이 이에 해당한다.</li><li>데이터 조작 언어(DML: Data Manipulation Language)<br><code>데이터를 조작</code>하기 위한 명령어로서, <code>UPDATE문(변경)</code>, <code>DELETE문(삭제)</code>, <code>INSERT문(추가)</code>, <code>SELECT문(조회)</code>가 이에 해당한다.</li><li>데이터 제어 언어(DCL: Data Control Language)<br><code>데이터베이스에 접근 권한 제어나 상태 관리</code>를 하기 위한 명령어로서, 사용자에게 권한을 부여하거나 트랜잭션을 처리할 때 주로 사용합니다.</li></ol><p>사실 SQL문 자체를 많이 쓸 일이 없어서일 수도 있겠지만 다른 명령어는 익숙해도 트랜잭션이라는 것이 굉장히 생소했다. 그렇다면 트랜잭션이란 무엇일까?</p><h3 id="트랜잭션-Transaction-이란"><a href="#트랜잭션-Transaction-이란" class="headerlink" title="트랜잭션(Transaction)이란?"></a>트랜잭션(Transaction)이란?</h3><p>위키 백괴에 따르면 데이터베이스 트랜젝션은 <code>데이터베이스 관리 시스템 또는 유사한 시스템에서 상호 작용의 단위</code> 라고 표현하고 있다. 어려운 이 문장을 풀어서 설명하면 <code>데이터베이스 안의 데이터를 변경할 때 하나의 단위로 묶어서 관리하는 구조</code>를 일컫는다. 많은 블로그들과 책에서도 은행의 계좌 시스템이라는 굉장히 좋은 예시로 들어 표현하고 있어 필자도 그림으로 그려 가며 표현해보고자 한다. </p><p>만약 다음의 그림과 같이 Man이 Woman에게 $10를 계좌이체 해준다고 가정해보자. </p><p><img src="/images/devops/what-kind-of-web-service05.png" alt="/images/devops/what-kind-of-web-service05.png"></p><p>그렇다면 Man의 계좌에 대한 데이터는 -$10에 대한 변경이 일어날 것이고, Woman의 계좌 데이터에서는 +$10에 대한 변경이 일어날 것이다. 이러한 일련의 과정이 하나의 단위로 묶여서 일어나야 한다. 이러한 구조를 트랜잭션이라고 표현한다. 이러한 일련의 과정이 모두 성공적으로 처리가 완료되어 완료된 경우를 <code>COMMIT</code>이라고 표현하고, 만약 하나라도 실패하여 모든 처리를 되돌리는 과정을 <code>ROLLBACK</code>이라고 표현한다. 이러한 특성으로 인해 RDBMS는 아래의 ACID 특성을 필요하다.</p><ol><li>Atomicity(원자성)<br>트랜잭션에 포함된 처리가 모두 처리가 되거나 혹은 모두 취소가 되어야 한다.</li><li>Consistency(일관성)<br>트랜잭셕 처리 전후로, 모든 데이터의 정합성이 지켜지며, 모순이 없어야 한다.</li><li>Isolation(독립성)<br>트랜잭션 안에서 처리 중인 처리가 다른 처리에 영향을 미치지 않아야 한다.</li><li>Durability(내구성)<br>트랜잭션이 끝났다면 시스템 장애가 생겨도 데이터를 잃지 않아야 한다.</li></ol><h3 id="가상화-서버"><a href="#가상화-서버" class="headerlink" title="가상화 서버"></a>가상화 서버</h3><p>아마도 MacOS를 사용하는 사용자라면 쉽게 이러한 가상화 서버를 접할 수 있을 것이다. 혹은 다양한 OS에서 어플리케이션을 테스트해야하는 경우에도 접해볼 수 있다. 이러한 가상화 서버는 한 대의 물리 서버를 여러 개의 가상 서버로 나눠서 이용하는 것을 일컫는다. 이러한 가상화 서버는 3개지 형태로 분류할 수 있다.</p><h4 id="1-호스트형-가상화"><a href="#1-호스트형-가상화" class="headerlink" title="1. 호스트형 가상화"></a>1. 호스트형 가상화</h4><p><img src="/images/devops/what-kind-of-web-service06.png" alt="/images/devops/what-kind-of-web-service06.png"></p><p>호스트형 가상화는 하드웨어 위의 기반이 되는 호스트 OS(Window, Mac 등)가 존재하며 그 호스트 OS에 가상화 소프트웨어를 설치한다. 이렇게 설치된 가상화 소프트웨어를 통해 서버 하드웨어를 에뮬레이션하는 것이다. 서버 하드웨어를 에뮬레이트하기 때문에 필요한 여분의 CPU 자원,디스크 용량, 메모리 사용량 등과 같은 오버헤드가 커질 수 있지만 게스트 OS에 대한 제약이 없어 대부분의 OS를 동작시킬 수 있다. 이러한 소프트 웨어는 VMware, VirtualBox, Parallels 등이 포함된다.</p><h4 id="2-하이퍼바이저형-가상화"><a href="#2-하이퍼바이저형-가상화" class="headerlink" title="2. 하이퍼바이저형 가상화"></a>2. 하이퍼바이저형 가상화</h4><p><img src="/images/devops/what-kind-of-web-service07.png" alt="/images/devops/what-kind-of-web-service07.png"></p><p>하이퍼바이저형 가상화는 VMM(Virtual Machine Monitor)을 하드웨어 위에서 직접 동작시키기 떄문에 호스트OS 설치가 필요 없다. 호스트 OS에 할당할 리소스가 없기에 호스트형 가상화보다는 오버헤드가 적은게 특징이며 하이퍼바이저가 하드웨어를 직접 제어하기 때문에 리소르르 효율적으로 사용할 수 있습니다. Linux KVM이나 Hyper-v 등이 해당합니다.</p><h4 id="3-컨테이너형-가상화"><a href="#3-컨테이너형-가상화" class="headerlink" title="3. 컨테이너형 가상화"></a>3. 컨테이너형 가상화</h4><p><img src="/images/devops/what-kind-of-web-service08.png" alt="/images/devops/what-kind-of-web-service08.png"></p><p>마지막은 컨테이너형 가상화이다. 앞의 두 가상화 서버와는 다르게 각자의 가상환경에 게스트 OS가 존재하지 않기 때문에 오버헤드가 적으며 가볍고 빠르게 동작하는 것이 특징이다. 호스트 OS위에 컨테이너 기반으로 분리해두고 각가에 독립된 OS 환경을 제공해준다. 이러한 컨테이너는 HostOS를 다른 컨테이너들과 공유한다. Docker가 대표적인 컨테이너 가상화 기술을 사용합니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;들어가기-전&quot;&gt;&lt;a href=&quot;#들어가기-전&quot; class=&quot;headerlink&quot; title=&quot;들어가기 전&quot;&gt;&lt;/a&gt;들어가기 전&lt;/h2&gt;&lt;p&gt;본 포스팅은 구글 클라우드 플랫폼 사용자 그룹의 운영진인 &lt;a href=&quot;https://www.f
      
    
    </summary>
    
      <category term="Devops" scheme="http://blog.martinwork.co.kr/categories/devops/"/>
    
    
      <category term="Google Cloud Platform" scheme="http://blog.martinwork.co.kr/tags/google-cloud-platform/"/>
    
  </entry>
  
  <entry>
    <title>최고의 집합 알고리즘</title>
    <link href="http://blog.martinwork.co.kr/theory/2019/01/19/top-group-algorithm.html"/>
    <id>http://blog.martinwork.co.kr/theory/2019/01/19/top-group-algorithm.html</id>
    <published>2019-01-18T15:50:51.000Z</published>
    <updated>2019-03-15T12:49:11.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>본 문제는 <a href="http://programmers.co.kr" target="_blank" rel="noopener">프로그래머스</a>라는 알고리즘 사이트에서 가져온 문제입니다. 알고리즘을 푸는 모든 과정은 자바스크립트로 이뤄졌습니다. </p><p>먼저 이 문제는 다음과 같다.</p><blockquote><p>자연수 n 개로 이루어진 집합 중에 다음 두 조건을 만족하는 집합을 최고의 집합이라고 합니다. 최고의 집합은 n개의 원소의 합은 S가 되는 수의 집합입니다. 이러한 조건을 만족하며 n개의 수의 곱이 최대가 되는 집합입니다.</p></blockquote><p>예를 들어 각각의 원소 갯수 n을 2라고 가정하고 원소의 합 S를 9라고 가면 하면 경우의 수는 [1, 8], [2,7], [3,6], [4,5] 등으로 총 4개가 될 수 있다. 그 중에서 최고의 집합은 [4,5]인 집합이다. 예시를 하나 더 들어보자. 원소의 갯수 n은 2이라고 가정하고 원소의 합 S를 13이라고 가정하면 경우의 수는 [1,12], [2,11], [3,10], [4,9], [5,8], [6,7] 이다. 6개의 집합 중 최고의 집합은 [6,7]이 해당한다. </p><h3 id="문제-해결-방법-유추"><a href="#문제-해결-방법-유추" class="headerlink" title="문제 해결 방법 유추"></a>문제 해결 방법 유추</h3><p>위에서의 두가지 공통점으로는 최고의 집합은 두수의 차가 최소일 경우이다 라는 가정을 얻을 수 있다. </p><p>그러한 가정은 다음과 같은 방법으로 증명할 수 있다. 간단하게 예시를 들기 위해 n은 2개라고 가정한다. 자연수 a와 b의 합이 S라고 가정했을 때, a와 b의 관계를 구하기 위해 a-b과 a+b를 비교를 한다. </p><p><img src="/images/algorithm/top-to-group01.png" alt="/images/algorithm/top-to-group01.png"></p><p>두 값중 a+b의 제곱근이 a-b의 제곱근보다는 큰 값일 테니 전자에서 후자의 값을 빼준다.</p><p><img src="/images/algorithm/top-to-group02.png" alt="/images/algorithm/top-to-group02.png"></p><p>두 값을 서로 비교해서 빼면 결국에 다음과 같이 나온다.</p><p><img src="/images/algorithm/top-to-group03.png" alt="/images/algorithm/top-to-group03.png"></p><p>우리가 구하고자 하는 ab 값을 구하기 위해 오른쪽과 왼쪽의 값을 4로 나누어 준다.</p><p><img src="/images/algorithm/top-to-group04.png" alt="/images/algorithm/top-to-group04.png"></p><p>그렇게 나누고 나면 우리가 원하는 ab의 값이 나오고 다음의 그림과 같이 a-b 의 값이 작을 수록 ab의 값이 커지는 것을 알 수 있다.</p><p><img src="/images/algorithm/top-to-group05.png" alt="/images/algorithm/top-to-group05.png"></p><p>결국 이 문제에서 최다의 ab 값을 구하기 위해서는 n개의 수의 차가 적을수록 원하는 최대값을 구할 수 있다.</p><h3 id="문제-해결"><a href="#문제-해결" class="headerlink" title="문제 해결"></a>문제 해결</h3><p>먼저 n개의 자연수가 n개의 자연수의 합 S 보다 클 경우를 대비하는 방어코드를 추가했다. n개의 자연수의 합이 S보다 작을 경우는 문제에서 주어진 경우와 같이 -1에 해당하는 배열을 반환해준다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">n, s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> answer = [];</span><br><span class="line">  <span class="keyword">if</span> (n &gt; s) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우리는 합이 S인 서로 차이가 적은 n개의 자연수를 찾는 것이기 때문에 S를 n으로 나누어 준다. 나눈 값을 그대로 넣어주면 소수점이 나온다. 하지만 우리가 구하고자 하는 값은 자연수 이기에 반올림 혹은 내림 등 중 하나를 선택해야 한다. 여기에서 주목할 것은 우리가 구하고자 하는 값은 올림차순으로 이루어진 집합이기 때문에 여기에서는 내림을 선택해준다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">n, s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> answer = [];</span><br><span class="line">  <span class="keyword">if</span> (n &gt; s) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// 하나씩 구해서 answer이라는 배열에 넣으면 구해야할 자연수 n개의 갯수는 점점 줄어든다.</span></span><br><span class="line">    <span class="keyword">const</span> number = <span class="built_in">Math</span>.floor(s/(n-i));</span><br><span class="line">    <span class="comment">// 구한 값을 answer 배열에 담아준다.</span></span><br><span class="line">    answer.push(number);</span><br><span class="line">    <span class="comment">// 전체의 갯수에서 구한 값을 제외시켜준후, 다시 배열을 시작한다.</span></span><br><span class="line">    s = s - number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>만약 내림차순으로 이루어진 집합을 구하고자 한다면 다음과 같이 구할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">n, s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> answer = [];</span><br><span class="line">  <span class="keyword">if</span> (n &gt; s) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> number = <span class="built_in">Math</span>.round(s/(n-i));</span><br><span class="line">    answer.push(number);</span><br><span class="line">    s = s - number;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;문제-설명&quot;&gt;&lt;a href=&quot;#문제-설명&quot; class=&quot;headerlink&quot; title=&quot;문제 설명&quot;&gt;&lt;/a&gt;문제 설명&lt;/h2&gt;&lt;p&gt;본 문제는 &lt;a href=&quot;http://programmers.co.kr&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
      <category term="Theory" scheme="http://blog.martinwork.co.kr/categories/theory/"/>
    
    
      <category term="프로그래머스" scheme="http://blog.martinwork.co.kr/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
      <category term="최고의집합" scheme="http://blog.martinwork.co.kr/tags/%EC%B5%9C%EA%B3%A0%EC%9D%98%EC%A7%91%ED%95%A9/"/>
    
  </entry>
  
  <entry>
    <title>Typescript에서 ImmutableJS 사용해보기</title>
    <link href="http://blog.martinwork.co.kr/typescript/2019/01/06/apply-immutablejs-with-typescript.html"/>
    <id>http://blog.martinwork.co.kr/typescript/2019/01/06/apply-immutablejs-with-typescript.html</id>
    <published>2019-01-05T15:50:51.000Z</published>
    <updated>2019-03-15T12:49:11.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ImmutableJS-도입하기까지"><a href="#ImmutableJS-도입하기까지" class="headerlink" title="ImmutableJS 도입하기까지"></a>ImmutableJS 도입하기까지</h2><p>현재 회사에서 진행하는 프로젝트에 ImmutableJS 의 도입을 결정한 것은 갑작스러운 결정은 아니었다. 물론 React 를 사용하면서 혹은 Redux 를 사용하면서 불변성만 유지된다고 한다면 ImmutableJS 는 필수가 아니라고 생각한다. 사용을 필요한 시점은 데이터의 구조의 깊이가 점점 깊어지면서였다. </p><p><img src="/images/react/immutable-with-typescript-image01.png" alt="/images/react/immutable-with-typescript-image01.png"></p><p>위에 코드처럼 깊이가 깊지 않은 경우에는 변경하기가 어렵지 않다.</p><p><img src="/images/react/immutable-with-typescript-image02.png" alt="/images/react/immutable-with-typescript-image02.png"></p><p>그냥 간단하게 전개 연산자를 사용한다면 문제가 되지 않는다. 하지만 만약 그 깊이가 점점 더 깊어진다면 위와 같이 썼을 경우 점점 더 코드가 읽기 힘들어 질 것이다.</p><p><img src="/images/react/immutable-with-typescript-image03.png" alt="/images/react/immutable-with-typescript-image03.png"></p><p>이와 같은 이유에서 ImmutableJS 를 도입을 결정하였고, 그에 따라 간단한 TodoMVC 를 이용하여 하나씩 예제 코드를 작성해보았다. 이 글에서 사용한 코드는 <a href="https://github.com/MartinYounghoonKim/react-typescript-redux-saga" target="_blank" rel="noopener">Github 레파지토리</a> 에서 확인할 수 있다. </p><h3 id="ImmutableJS-와-Typescript-함께-사용하기"><a href="#ImmutableJS-와-Typescript-함께-사용하기" class="headerlink" title="ImmutableJS 와 Typescript 함께 사용하기"></a>ImmutableJS 와 Typescript 함께 사용하기</h3><blockquote><p>일단 예제 코드를 작성하기에 앞서 예제 코드는 비지니스 코드에 도입하기 전 사용성 테스트를 하기 위해 최대한 회사에서 사용하는 기술 스택과 동일하게 가져가야 했다. 다른 라이브러리는 동일할 필요는 없지만 제일 중요한 것은 Typescript 에 적용이 되어야 한다는 것이다. 그래서 이 포스팅에서는 ImmutableJS 의 사용을 Typescript 와 함께 사용한 예제에 대해서 설명을 하고 있다. </p></blockquote><p>ImmutableJS 의 사용성을 테스트하기에 앞서 제일 중요하게 생각한 것은 Immutable 객체의 <code>타입에 대한 검증</code> 이었다. 다행이도 ImmutableJS 는 Flow 뿐만 아니라 Typescript 에 대한 호환성에 대해서는 공식 홈페이지에서도 기재되어 있을 정도로 믿을 수 있었다. 먼저 ImmutableJS 를 Typescript로 작성하기 위해서 필자의 경우에는 ImmutableJS 에서 제공해주는 Record 객체를 이용하기로 결정했다. Record 객체를 이용하면 좋은 점은 다음과 같다.</p><ul><li><code>각자의 Record 객체 자체의 기본값을 설정할 수 있으며, 설정되지 않은 값은 추가할 수 없다</code>: Record 객체만 사용하는 경우에 정의 되지 않은 키의 값을 추가하려고 하면 무시된다. 하지만 타입스크립트를 사용하는 경우에는 타입 검증을 통해 바로 알 수 있다.</li><li><code>Record 의 기본값을 설정하면서 자체적으로 문서의 기능도 가진다</code>: Record 객체는 앞에서 설명했듯 기본값을 설정할 수 있으며 이는 마치 인터페이스와 같은 역할을 한다. 자바스크립트를 사용하는 경우에는 타입스크립트와는 다르게 인터페이스가 없기 때문에 이는 엄청난 감정이 될 수 있다. </li><li><code>Getter 함수를 작성할 수 있다</code>: Record 객체는 팩토리 형태의 함수이지만, Javascript 의 class 형태로 작성되며 이에 따라 원한다면 자체적인 getter 함수를 추가해서 사용할 수 있다. </li><li><code>Javascript 의 객체에 접근하듯 Record 객체에도 접근할 수 있다</code>: Record 객체를 이용하면 get() 을 통하지 않더라도 Javascript의 객체와 같이 접근할 수 있다. 다만 IE8 에서는 get() 을 이용해야 한다.</li></ul><p>이 포스팅을 읽는 사람들이라면 대부분 TodoMVC 가 구체적으로 어떻게 동작하는지는 다들 알거라고 믿어 의심치 않는다 :-) 혹시나 모르더라도 걱정 안해도 된다. 위의 레파지토리에 모든 코드는 다 올라가져 있으니 코드를 확인하면서 하나씩 읽어나가면 된다.</p><p>일단 먼저 Todo 의 아이템을 먼저 Record 객체로 선언을 한다.</p><p><img src="/images/react/immutable-with-typescript-image04.png" alt="/images/react/immutable-with-typescript-image04.png"></p><p>위와 같이 Record 객체를 Todo 의 인터페이스를 props 로 주입한 후 생성한다. 만약 아래와 같이 정의 되지 않은 프로퍼티를 추가하게 되면 어떻게 될까 ?</p><p><img src="/images/react/immutable-with-typescript-image05.png" alt="/images/react/immutable-with-typescript-image05.png"></p><p>그렇게 되면 아래의 그림과 같이 타입스크립트 빌드 과정에서 에러를 내뱉어준다.</p><p><img src="/images/react/immutable-with-typescript-image06.png" alt="/images/react/immutable-with-typescript-image06.png"></p><p>마찬가지로 제일 중요하게 생각한 타입 검증도 역시 테스트를 해보았다. </p><p><img src="/images/react/immutable-with-typescript-image07.png" alt="/images/react/immutable-with-typescript-image07.png"></p><p>임의의 타입을 변경해도 이전의 테스트와 마찬가지로 검증을 해준다.</p><p><img src="/images/react/immutable-with-typescript-image08.png" alt="/images/react/immutable-with-typescript-image08.png"></p><p>이렇게 검증된 state 는 이제 reducer 에서 쉽고 편하게 사용할 수 있다. 아래의 사진은 reducer 의 전체 코드이다.</p><p><img src="/images/react/immutable-with-typescript-image09.png" alt="/images/react/immutable-with-typescript-image09.png"></p><p>이쯤되면 마지막으로 궁금한 것이 생길 것이다. 과연 타입이 일치하지 않는 값을 대입할 때 역시 타입 검증을 제대로 해줄 것인가? </p><p><img src="/images/react/immutable-with-typescript-image10.png" alt="/images/react/immutable-with-typescript-image10.png"></p><p>역시나 reducer 에서 state 의 값과 일치하지 않을 때 역시 탄탄하게 검증을 해준다.</p><p><img src="/images/react/immutable-with-typescript-image11.png" alt="/images/react/immutable-with-typescript-image11.png"></p><p>추가로 말하자면 Record 를 선언하는 방식은 위와 같은 방식 말고도 class 형태로 선언하는 방식도 있다. 위에서 장점으로 말했던 4가지 중 3번째 항목 중 <code>자체적인 getter 함수를 작성할 수 있다</code> 에 해당하는 방식인데, 그러한 경우는 아래와 같이 선언을 하면 된다.</p><p><img src="/images/react/immutable-with-typescript-image12.png" alt="/images/react/immutable-with-typescript-image12.png"></p><p>이상으로 ImmutableJS 의 Record 객체에 타입스크립트를 적용하는 것을 살펴보았다. 물론 아직은 조금 더 사용성에 대해서 살펴본 후, 실 서비스에 적용을 하겠지만 지금까지 살펴본 바로는 큰 학습 비용 없이 적용이 가능하다는 것이 큰 장점인 것 같다.  </p><hr><h2 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h2><ul><li><a href="https://facebook.github.io/immutable-js/" target="_blank" rel="noopener">ImmutableJS 공식 홈페이지</a></li><li><a href="https://facebook.github.io/immutable-js/docs/#/Record" target="_blank" rel="noopener">ImmutableJS 공식 홈페이지- Record 객체</a></li><li><a href="https://medium.com/azendoo-team/immutable-record-react-redux-99f389ed676" target="_blank" rel="noopener">immutable-record-react-redux</a></li><li><a href="https://tonyhb.gitbooks.io/redux-without-profanity/content/using_immutablejs_records.html" target="_blank" rel="noopener">tonyhb’s Gitbook</a></li><li><a href="https://blog.mgechev.com/2018/01/18/react-typescript-redux-immutable/" target="_blank" rel="noopener">블로그</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ImmutableJS-도입하기까지&quot;&gt;&lt;a href=&quot;#ImmutableJS-도입하기까지&quot; class=&quot;headerlink&quot; title=&quot;ImmutableJS 도입하기까지&quot;&gt;&lt;/a&gt;ImmutableJS 도입하기까지&lt;/h2&gt;&lt;p&gt;현재 회사에
      
    
    </summary>
    
      <category term="Typescript" scheme="http://blog.martinwork.co.kr/categories/typescript/"/>
    
    
      <category term="ImmutableJS" scheme="http://blog.martinwork.co.kr/tags/immutablejs/"/>
    
      <category term="Typescript" scheme="http://blog.martinwork.co.kr/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>2018년의 회고</title>
    <link href="http://blog.martinwork.co.kr/review/2018/12/29/remembrance-in-2018.html"/>
    <id>http://blog.martinwork.co.kr/review/2018/12/29/remembrance-in-2018.html</id>
    <published>2018-12-28T15:50:51.000Z</published>
    <updated>2019-03-15T12:49:11.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2018년을-돌아보며"><a href="#2018년을-돌아보며" class="headerlink" title="2018년을 돌아보며"></a>2018년을 돌아보며</h2><p>얼마전 페이스북에서 한 개발자의 회고를 감명 깊게 있었던 적이 있다. 그 글을 보고 나서 필자도 한해를 돌아보며 올 한해에 대한 반성과 내년에 대한 목표를 세워보기로 했다. 2018년의 큰 이벤트는 크게 2가지였던 것 같다. 첫번째는 <code>새로운 회사로의 이직</code>과 두번째는 <code>전문 서적에 대한 집필</code>이다. </p><h3 id="첫번째-이야기-이직하기-까지의-과정"><a href="#첫번째-이야기-이직하기-까지의-과정" class="headerlink" title="첫번째 이야기. 이직하기 까지의 과정"></a>첫번째 이야기. 이직하기 까지의 과정</h3><p>2018 년 1월 당시 재직 중인 회사에서 리뉴얼을 준비 중인 플랫폼에 대해서 VueJS 를 이용해서 계속해서 개발을 진행하고 있었다. 이 프로젝트는 큰 이벤트 역시 5월에 무사 오픈을 했다. 이 프로젝트를 진행하며 VueJS 관련한 조언을 듣고자 외부의 개발자들을 많이 찾아다녔다. 사실 이 프로젝트를 들어가기 전까지만 해도 VueJS 라는 존재 조차 모르고 있었기에 혼자 진행하기에는 두려움이 굉장히 컸다. 그렇게 외부 활동을 하며 우연치 않게 좋은 개발자들과 교류를 하게 되었고, 이를 계기로 사이드 프로젝트 팀에 합류하게 되었다. (이에 대해서는 뒤에서 자세히 설명하겠다.) 이 프로젝트를 5월에 오픈한 후, 1주일 정도 휴가를 낸 후 샌프란시스코의 컨퍼런스를 다녀왔다. </p><p>스피커들이 이야기 하는 모든 것을 이해할 수 있었던 것은 아니지만, 그들의 열정과 노력을 느끼며 스스로를 돌이켜볼 수 있었던 계기가 된 시간이었다.</p><p>한국에 돌아온 후에는 다시 프로젝트에 투입되었다. 바로 직전 프로젝트를 진행을 하며, 아쉬었던 부분 중 하나가 <code>어플리케이션이 예측이 힘들다</code>는 것이 가장 컸다.</p><p><img src="/images/review/remembrance-in-2018-01.png" alt="/images/review/remembrance-in-2018-01.png"></p><p>블랙박스 안에 무언가의 옵션값을 넣어주면 그에 따라 결과를 받는데 그 값들이 무엇인지 전혀 예측할 수 없었고 이에 따라 개발의 퍼포먼스가 오히려 지연되었다. 실제 개발한 개발자 역시 일주일이 지나면 잊어버리는 것을 새로운 누군가가 온다면 아마 그에 대한 고민이 더 커질 것 같았다. 이런 점을 보완하기 위해 타입스크립트를 도입하였다. </p><p><img src="/images/review/remembrance-in-2018-02.png" alt="/images/review/remembrance-in-2018-02.png"></p><p>물론 타입스크립트가 진입 장벽이 낮은 것은 아니였지만, 당시 진행하던 프로젝트와 같이 방대한 양의 데이터가 오가며 그에 따라 적당한 비지니스가 존재하는 어플리케이션에서는 최적이라고 판단하였다. 물론 그에 따라 혹시나 익숙하지 않은 개발자와의 협업을 위해 옵션 자체를 빡세게 잡지도 않았고 별도의 스터디를 주도하기도 하였다. 그렇게 프로젝트를 오픈하고 안정화가 되어갈 무렵, 한 회사의 리쿠르팅 팀에서의 메일을 받게 되었다. </p><p> <img src="/images/review/remembrance-in-2018-03.png" alt="/images/review/remembrance-in-2018-03.png"></p><p>이전부터 굉장히 가고 싶었던 회사로부터 연락을 받은 것이다 (이 때의 기분이란 정말 엄청났다 !) 그렇게 서류, 1차 면접, 2차 면접 그리고 3차 면접(이 회사만의 특별한 채용 절차이다.) 을 끝으로 최종적으로 합격을 받았다.</p><p><img src="/images/review/remembrance-in-2018-04.png" alt="/images/review/remembrance-in-2018-04.png"></p><p>그렇게 10월 새로운 회사로의 출근을 하게 되었다. 새로운 회사에서의 개발기는 현재 오픈 예정인 프로젝트가 오픈한 후, 다른 포스팅에서 작성할 생각이다. (프로젝트를 진행하며 우여곡절이 많았다.)</p><h3 id="두번째-이야기-책-집필하게-된-과정"><a href="#두번째-이야기-책-집필하게-된-과정" class="headerlink" title="두번째 이야기. 책 집필하게 된 과정"></a>두번째 이야기. 책 집필하게 된 과정</h3><p>2018년의 두번째 큰 이벤트는 바로 책 집필에 대한 문의였다. VueJS 와 타입스크립트를 이용한 전 회사에서의 프로젝트가 안정화 되가는 중 갑작스러운 메일을 받았다.</p><p><img src="/images/review/remembrance-in-2018-05.png" alt="/images/review/remembrance-in-2018-05.png"></p><p>갑작스러운 메일에 처음에는 신종사기인가 싶기도 했다..ㅎㅎ 하지만 감사하게도 별볼일 없던 필자를 누군가가 좋게 평가를 하여 그에 대한 집필 제안을 주었던 것이다. 처음 제안을 받고나서 깊은 고민 없이 선뜻 수락해버렸다. 그 이유는 새로운 경험이 개발자로서의 또다른 동기부여를 해주지 않을까라는 것과 부족하지만 누군가와 지식을 공유하고 싶다라는 것 마음이 컸다. 수락을 한 후 바로 걱정이 앞섰다. 사실 초보 개발자인 나로서는 누군가에게 지식을 전달할 정도로 똑똑한 것도 아니였고, 경험이 많은 것도 아니였기 때문이다.   </p><p><img src="/images/review/remembrance-in-2018-06.png" alt="/images/review/remembrance-in-2018-06.png"></p><p>그러다 앞서 사이드 프로젝트 팀에 합류한 후 함께 개발을 하던 한 동료 개발자가 생각이 났다. 이 친구와 함께 한다면 서로 부족한 부분에 대해서 보완해줄 수 있지 않을까 라는 생각이 들어 공동 집필을 문의하였고, 고맙게도 그 친구 역시도 흔쾌히 수락하였다. 그렇게 9월달 부터 계속해서 집필하는 해왔고, 지금도 계속해서 달려가고 있는 중이다. 책을 집필하는 과정에서 좋은 또 다른 사람들과 교류를 하게 되었고, 지금은 현재 그 사람들과의 스터디를 진행하며 계속해서 책을 집필해나가고 있다. (책 집필에 대한 회고는 출판 이후에 자세히 하겠다.)</p><h3 id="끝으로"><a href="#끝으로" class="headerlink" title="끝으로"></a>끝으로</h3><p>지금 돌이켜보면 2018년은 필자에게 과분한 행운이 따랐던 한 해가 아니였나라는 생각을 한다. 새로운 사람들과의 교류와 직장 동료들간의 교류를 통해 좁은 시야에만 갖혀있던 필자를 더 넓게 볼 수 있게 해주었다. </p><p>내년에는 어제보다 더 나은 오늘, 오늘보다 더 나은 내일이 될 수 있도록 더 노력하는 사람이 되길 빌며, 고생한 2018년의 나에게. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2018년을-돌아보며&quot;&gt;&lt;a href=&quot;#2018년을-돌아보며&quot; class=&quot;headerlink&quot; title=&quot;2018년을 돌아보며&quot;&gt;&lt;/a&gt;2018년을 돌아보며&lt;/h2&gt;&lt;p&gt;얼마전 페이스북에서 한 개발자의 회고를 감명 깊게 있었던 적이
      
    
    </summary>
    
      <category term="Review" scheme="http://blog.martinwork.co.kr/categories/review/"/>
    
    
      <category term="TMON" scheme="http://blog.martinwork.co.kr/tags/tmon/"/>
    
      <category term="티모니언" scheme="http://blog.martinwork.co.kr/tags/%ED%8B%B0%EB%AA%A8%EB%8B%88%EC%96%B8/"/>
    
      <category term="2018회고" scheme="http://blog.martinwork.co.kr/tags/2018%ED%9A%8C%EA%B3%A0/"/>
    
  </entry>
  
  <entry>
    <title>스타트업은 어떻게 일하는가?</title>
    <link href="http://blog.martinwork.co.kr/review/2018/12/15/how-to-work.html"/>
    <id>http://blog.martinwork.co.kr/review/2018/12/15/how-to-work.html</id>
    <published>2018-12-14T15:50:51.000Z</published>
    <updated>2019-03-15T12:49:11.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="우리는-어떻게-일하는가"><a href="#우리는-어떻게-일하는가" class="headerlink" title="우리는 어떻게 일하는가?"></a>우리는 어떻게 일하는가?</h2><p>본 글의 경우 필자가 다녔거나 혹은 다니고 있는 회사에서 일하는 방식에 더해 주변에 스타트업에서 일하는 사람들과 한 이야기를 바탕으로 썼을 뿐, 각자의 회사마다 일하는 방식이 다르기 때문에 일하는 방식에 대한 절대적인 가이드나 표준은 절대 아님을 밝힌다. 혹시나 스타트업에서 더 나은 문화를 추구하거나 혹은 내부적인 문화를 만들려고 노력하는 분들에게 도움이 되길 바라는 마음에 글을 쓴다. 아마 대부분의 회사는 아래의 사진과 같은 업무 프로세스를 가질 것이다.</p><p><img src="/images/review/how-to-work01.png" alt="/images/review/how-to-work01.png"></p><p>회사에 따라 부분적인 과정을 스킵하고 넘어가는 경우도 있고 별도의 QA 인원을 둘 수 없는 경우에는 개발자가 QA를 진행할 수도 있다. 이렇게 우리는 하나의 서비스 혹은 하나의 기능을 만들기 위해 이렇게 길고 다양한 과정을 거친다. 만약 이러한 과정에서 만약 조금이라도 미스 커뮤니케이션이 일어난다면 아마 유관부서는 그만큼 다시 이 과정을 거쳐야 한다. 그래서 많은 서비스 회사에서는 커뮤니케이션에 많은 비용을 투자하기도 한다. </p><h3 id="문제-도출-및-일정-산정"><a href="#문제-도출-및-일정-산정" class="headerlink" title="문제 도출 및 일정 산정"></a>문제 도출 및 일정 산정</h3><p><img src="/images/review/how-to-work02.png" alt="/images/review/how-to-work02.png"></p><p>모든 과정의 첫번째는 문제 도출이다. 우리에게 필요한 서비스 혹은 필요한 기능이 무엇인지를 먼저 파악을 해야 한다. 이 과정에서는 많은 부서와 깊은 연관을 가진다. 사업부, 영업 조직, CS 조직, 혹은 마케팅 조직 등등 다양한 유관 부서와의 커뮤니케이션을 통한 새로운 기능이 추가될 수도 있고, 혹은 분기별 사업 목표일 수도 있다. 이 과정에서 진행해야할 프로젝트의 우선 순위를 정하게 된다. 그렇게 정해진 우선 순위에 따라 프로젝트 별 일정을 산정을 하며, 그에 따라 필요한 인력을 투입하게 된다. 만약 프로젝트의 기능이 큰 경우나 우선순위 여부에 따라서는 별도의 TF 팀을 꾸리기도 한다.</p><h3 id="기획"><a href="#기획" class="headerlink" title="기획"></a>기획</h3><p><img src="/images/review/how-to-work03.png" alt="/images/review/how-to-work03.png"></p><p>기획 단계에서 서비스에 대한 기획이 이뤄지며, 이 과정에서 기획자들은 개발자 혹은 디자이너와 꾸준한 커뮤니케이션을 한다. 이 역시 회사에 따라 다를 수 있지만, 보통 이 과정에서 필요한 이슈들을 Jira 나 Trello 와 같은 협업 도구를 이용하여 이슈 번호를 생성하기 시작한다.</p><p><img src="/images/review/how-to-work04.png" alt="/images/review/how-to-work04.png"></p><p>물론 이러한 협업 도구를 이용하지 않고 칸반 보드를 이용하여 포스트잇을 붙여 스케줄을 관리하는 경우도 있다.</p><blockquote><p>현재 진행 중인 프로세스에 대해서는 가볍게는 Backlog, In progress, Review, Done 등으로 나뉘게 된다. Backlog 등은 앞으로 우리가 해야할 일들에 대한 이슈들을 모아둔 과정이다. 여기에 있는 이슈들은 우선순위에 따라 In progress 로 옮겨지게 된다. In progress 는 현재 진행 중인 업무들에 해당하며, 이 과정을 지나 Review 과정을 거쳐 Done 처리가 된다.</p></blockquote><p><img src="/images/review/how-to-work05.png" alt="/images/review/how-to-work05.png"></p><p>기획 단계에서의 산출물은 PDF 혹은 PPT 등으로 나오기도 하며, 일부 회사에서는 Confluence 에 문서화 하는 경우도 있다.</p><h3 id="디자인"><a href="#디자인" class="headerlink" title="디자인"></a>디자인</h3><p><img src="/images/review/how-to-work06.png" alt="/images/review/how-to-work06.png"></p><p>디자인 단계에서는 기획 단계에서 나온 기획 문서에서 정의한 <code>프로토 타입</code>을 토대로 시각화 하는 과정을 거친다.</p><blockquote><p>위키 백과에 따르면 프로토 타입을 <code>정보시스템의 미완성 버전 또는 중요한 기능들이 포함되어 있는 시스템의 초기모델</code> 으로 정의하고 있다. </p><blockquote><p><img src="/images/review/how-to-work07.png" alt="/images/review/how-to-work07.png"></p></blockquote></blockquote><p>이 과정에서 디자이너들은 Adobe 사의 Photoshop이나 XD 를 이용하거나 Sketch, Zeplin 등을 이용한다. 아마 많은 사람들에게 포토샵은 익숙하지만 XD 나 Sketch, Zeplin 는 익숙하지 않을 것이다. Sketch 는 UI 디자인을 하기에 유용한 툴이고, Zeplin 은 그에 따라 산출물을 보여주기 위한 것이라고 생각하면 된다.</p><h3 id="개발"><a href="#개발" class="headerlink" title="개발"></a>개발</h3><p><img src="/images/review/how-to-work08.png" alt="/images/review/how-to-work08.png"></p><p>개발 단계는 크게는 프론트엔드 개발, 백엔드 개발 두가지로 나뉘어진다. 또 프론트 엔드는 흔히 자바스크립트를 이용하는 프론트 개발 과 HTML, CSS 를 이용하는 마크업을 개발하는 마크업 개발이 있다. </p><p><img src="/images/review/how-to-work09.png" alt="/images/review/how-to-work09.png"></p><p>회사에 따라 마크업 개발자가 별도로 분리되어 있는 경우가 있지만 프론트 엔드 개발자가 마크업과 자바스크립트 개발을 같이 하는 경우도 있다. 마크업 개발자는 디자이너에게 받은 디자인 산출물을 HTML 과 CSS 를 기반으로 하여 화면을 그리는 역할을 한다. 자바스크립트 개발자는 개발이 완료된 마크업에 백엔드 개발자로부터 받은 API 데이터를 연동한다. 이때 주로 자바스크립트 프레임워크를 많이 이용한다.</p><p>이 과정에서 사용하는 것 다양한 툴이 있다.</p><h4 id="API-문서화"><a href="#API-문서화" class="headerlink" title="API 문서화"></a>API 문서화</h4><p>백엔드 개발자와 프론트 엔드 개발자는 보통 API 를 기반으로 커뮤니케이션을 한다. 그러기 위해서는 제일 중요한 것은 문서화가 중요하다. 물론 일부 정적인 문서를 작성하는 경우가 있지만 그러한 경우는 보통 히스토리 관리가 안되어 작성하고 나서 한달만 지나고 나면 레거시가 되는 경우가 허다하다. 제일 중요한 것은 실제의 API 를 확인할 수 있는 것이 제일 중요하다. 그때 보통 사용하는 것이 <a href="https://www.getpostman.com/" target="_blank" rel="noopener">Postman</a>, <a href="http://apidocjs.com/" target="_blank" rel="noopener">API Doc</a>, <a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a> 등을 사용한다. </p><h4 id="개발-관련-문서화"><a href="#개발-관련-문서화" class="headerlink" title="개발 관련 문서화"></a>개발 관련 문서화</h4><p>개발을 하다보면 개발 관련해서 문서화를 해야하는 경우가 굉장히 많다. 보편적으로 이슈 트래킹, 컨벤션 혹은 개발 과정의 히스토리를 기록한다. 이때 보통 이용하는 것이 <a href="https://ko.atlassian.com/software/confluence" target="_blank" rel="noopener">Confluence</a> 이다. 기타 여러개의 다른 플랫폼과 호환성 역시 좋아 많은 기업에서 애용한다.</p><h4 id="형상-관리-도구"><a href="#형상-관리-도구" class="headerlink" title="형상 관리 도구"></a>형상 관리 도구</h4><p>개발을 할때 앞의 2가지는 빼놓을 수 있지만 제일 중요하면서도 빼먹을 수 없는 것이 바로 형상 관리 도구이다. 아마 어떠한 형태로든 개발자라면 한번씩은 접해봤을 도구일 것이다. 과거에는 SVN 을 많이 이용을 했었고, 현재는 Git 을 많이 이용한다. (아직도 SVN 을 이용하는 곳도 있다.) 그리고 그 Git 이라는 시스템을 지원 해주는 플랫폼으로는 <a href="http://github.com" target="_blank" rel="noopener">Github</a>, <a href="https://about.gitlab.com/" target="_blank" rel="noopener">Gitlab</a>, <a href="http://bitbucket.org" target="_blank" rel="noopener">Bitbucket</a> 등이 있다. 오픈 소스도 마찬가지이지만, 이 과정에서 개발자들끼리 서로 코드리뷰를 진행하며, 만약 리뷰를 해야 하는 소스가 중요한 소스라고 하면 별도의 회의 시간을 가질 정도로 중요한 과정이다.</p><p>이러한 과정을 거쳐 개발을 하게 되고, QA 과정으로 들어가기 전 새니티 테스트를 진행하게 된다. 그리고 새니티 테스트가 완료가 되면 전문 테스터에게 리뷰를 받은 후 배포하는 과정이 이뤄진다.</p><hr><h2 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h2><ul><li><a href="https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85" target="_blank" rel="noopener">프로토 타입의 정의</a></li><li><a href="http://www.jidum.com/jidums/view.do?jidumId=612" target="_blank" rel="noopener">새니티 테스트란?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;우리는-어떻게-일하는가&quot;&gt;&lt;a href=&quot;#우리는-어떻게-일하는가&quot; class=&quot;headerlink&quot; title=&quot;우리는 어떻게 일하는가?&quot;&gt;&lt;/a&gt;우리는 어떻게 일하는가?&lt;/h2&gt;&lt;p&gt;본 글의 경우 필자가 다녔거나 혹은 다니고 있는 회
      
    
    </summary>
    
      <category term="Review" scheme="http://blog.martinwork.co.kr/categories/review/"/>
    
    
      <category term="스타트업" scheme="http://blog.martinwork.co.kr/tags/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85/"/>
    
      <category term="애자일" scheme="http://blog.martinwork.co.kr/tags/%EC%95%A0%EC%9E%90%EC%9D%BC/"/>
    
  </entry>
  
  <entry>
    <title>ReactJS 의 생명주기</title>
    <link href="http://blog.martinwork.co.kr/reactjs/2018/11/17/reactjs-lifecycle.html"/>
    <id>http://blog.martinwork.co.kr/reactjs/2018/11/17/reactjs-lifecycle.html</id>
    <published>2018-11-16T15:50:51.000Z</published>
    <updated>2019-03-15T12:49:11.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ReactJS-의-생명주기"><a href="#ReactJS-의-생명주기" class="headerlink" title="ReactJS 의 생명주기"></a>ReactJS 의 생명주기</h2><p>거의 대부분의 언어에 메모리를 할당하는 과정이 있듯 ReactJS 에도 생명 주기(Life cycle)라는 것이 있다. 필수적으로 알고 있어야 하는 것은 아니지만, 각각의 훅에서 어떠한 일이 벌어지는 지 정도는 알고 있어야 어느 훅에서 API 를 패치해와야하는지, 어떤 훅에서 DOM 자체의 이벤트 바인딩을 해제 해줘야 하는지에 대한 가이드가 생길 수 있다. 또한 ReactJS 의 경우 특정 훅을 이용하여 컴포넌트의 최적화를 할 때 역시 유용하게 사용할 수 있으므로, 자주 사용하는 생명 주기의 경우는 알고 있는 것을 추천한다.</p><p>먼저 Javascript 의 모든 생명 주기는 비슷한 흐름을 가지고 있다.</p><p><img src="/images/react/react-lifecycle01.png" alt="/images/react/react-lifecycle01.png"></p><p>컴포넌트가 마운트가 되기 전의 훅들이 존재하며 마운트가 된 후에는 데이터의 변화에 따라 컴포넌트가 다시 랜더링 된다. 그 후, 컴포넌트의 역할이 끝남에 따라 컴포넌트가 사라지게 된다. 필자는 개인적으로는 각 생명주기에서 브레이크 포인트를 찍어서 하나 하나 확인하는 것을 추천한다.</p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>React 의 경우 하나 하나의 컴포넌트가 class 기반으로 되어 있다. Class 에는 기본적으로 <code>constructor</code> 가 존재하듯 마찬가지로 React 의 컴포넌트에서도 constructor 가 존재한다. 이 훅은 우리가 만든 컴포넌트가 처음 브라우저에 생성될 떄 가장 최초로 실행되는 함수로서, 보통 컴포넌트가 가질 state 를 초기화할 때 사용한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h3><p>Props 로 받은 데이터를 state 에 동기화를 시키려할 때 사용하는 훅으로서, Props 가 변화할 때마다 실행된다. 만약 state 의 값을 변경할 필요가 없다면 null 값을 반환해주면 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps (nextProps, nextState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextProps !== nextState) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: nextProps.value</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>render 함수는 어떠한 DOM 을 만들지, 내부 태그에는 어떠한 값이 들어갈지에 대한 것을 결정하는 함수이다. React 컴포넌트에 Stateless Component 와 Stateful Component, 두 가지로 나뉘는데 두 종류의 컴포넌트 모두 해당 훅은 필수적으로 가지고 있어야 할 정도로 React 컴포넌트에서는 필수적인 메소드이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps (nextProps, nextState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextProps !== nextState) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: nextProps.value</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render () &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            &lt;p&gt;MyComponent1 :&#123;<span class="keyword">this</span>.props.value&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt;MyComponent1 :&#123;this.state.value&#125;&lt;/</span>p&gt;</span><br><span class="line">          &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><p>우리가 정의한 컴포넌트가 브라우저상에 DOM 으로 나타나게 되면 실행되는 함수이다. 이 훅에서는 D3, Chart 같은 DOM 에 해당 라이브러리에서 제공하는 UI 를 그려야할 때 그 요청을 실행하는 훅이다. 이 뿐만 아니고 API 서버에 데이터를 호출하는 함수를 해당 훅에서 실행시켜주며, 어떠한 DOM 에 이벤트를 바인딩할 때 역시 해당 훅에서 실행된다. 필자의 경우 이 훅은 인피니티 스크롤을 만들 때 사용하였다. window 자체에 onScroll 이벤트를 해당 훅에서 바인딩을 해주어 스크롤 이벤트가 발생할 때 일정 조건을 충족할 경우 API 의 데이터를 받아오도록 하였다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">"scroll"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Do something</span></span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            &lt;p&gt;MyComponent1 :&#123;<span class="keyword">this</span>.props.value&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt;MyComponent1 :&#123;this.state.value&#125;&lt;/</span>p&gt;</span><br><span class="line">          &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><p>컴포넌트가 업데이트 되는 성능을 최적화할 때 사용하는 훅으로서, 개인적으로는 생명 주기 중에 중요한 훅 중 하나라고 생각한다. 부모 컴포넌트가 랜더함수가 실행되면 자식 컴포넌트도 랜더함수가 실행된다. 부모 컴포넌트가 업데이트 되더라도 일부 자식 컴포넌트의 props 는 업데이트 되지 않는 경우가 있다. DOM 에 그리는 것이 아니라 vitual dom 에 그리는 것이라 화면에는 따로 보여지지 않지만 props가 업데이트 되지 않아도 모든 자식 컴포넌트들이 render 함수를 실행한다. 이럴 때 해당 훅을 이용하여 랜더링 함수 실행되지 않도록 막을 수 있다.</p><pre><code class="js"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>{  state = {    value: <span class="number">0</span>,  };  shouldComponentUpdate (nextProps, nextState) {    <span class="keyword">if</span> (nextProps === nextState)      <span class="keyword">return</span> <span class="literal">false</span>;    } <span class="keyword">else</span> {      <span class="keyword">return</span> <span class="literal">true</span>;        }  }  render () {      <span class="keyword">return</span> (          &lt;div&gt;            &lt;p&gt;MyComponent1 :{<span class="keyword">this</span>.props.value}&lt;<span class="regexp">/p&gt;</span><span class="regexp">            &lt;p&gt;MyComponent1 :{this.state.value}&lt;/</span>p&gt;          &lt;<span class="regexp">/div&gt;</span><span class="regexp">      )</span><span class="regexp">    }</span><span class="regexp">}</span></code></pre><h3 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h3><p>해당 훅은 랜더 함수 실행 후, 랜더링한 결과물이 브라우저에 반영되기 바로 직전에 실행되는 함수이다. 랜더링 후 업데이트 전 스크롤의 위치 혹은 해당 돔의 크기를 가져올때 해당 훅에서 사용한다.</p><pre><code class="js"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>{  state = {    value: <span class="number">0</span>,  };  getSnapshotBeforeUpdate (prevProps, prevState) {    <span class="comment">// Do something</span>  }  render () {      <span class="keyword">return</span> (          &lt;div&gt;            &lt;p&gt;MyComponent1 :{<span class="keyword">this</span>.props.value}&lt;<span class="regexp">/p&gt;</span><span class="regexp">            &lt;p&gt;MyComponent1 :{this.state.value}&lt;/</span>p&gt;          &lt;<span class="regexp">/div&gt;</span><span class="regexp">      )</span><span class="regexp">    }</span><span class="regexp">}</span></code></pre><h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h3><p>브라우저에 랜더링된 직후 실행되는 함수이다. 이전의 페이지와 현재의 페이지가 서로 다를 경우 해당 훅에서 특정 작업을 할 수 있다. 해당 훅에서는 랜더링 된 후에 실행되는 함수이므로 DOM 을 제어하는 등의 일 또한 추가해도 무방하다.</p><pre><code class="js"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>{  state = {    value: <span class="number">0</span>,  };  componentDidUpdate (prevProps, prevState, snapshot) {    <span class="comment">// Do something</span>  }  render () {      <span class="keyword">return</span> (          &lt;div&gt;            &lt;p&gt;MyComponent1 :{<span class="keyword">this</span>.props.value}&lt;<span class="regexp">/p&gt;</span><span class="regexp">            &lt;p&gt;MyComponent1 :{this.state.value}&lt;/</span>p&gt;          &lt;<span class="regexp">/div&gt;</span><span class="regexp">      )</span><span class="regexp">    }</span><span class="regexp">}</span></code></pre><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><p>componentDidMount 훅에서 DOM 에 이벤트를 바인딩했을 때 그 이벤트를 해제시켜줄때 해당 훅에서 시켜주면 된다. 위의 componentDidMount 훅에서 필자처럼 window 에 scroll 이벤트를 바인딩했다면 해당 훅에서 제거하면 된다.</p><pre><code class="js"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>{  state = {    value: <span class="number">0</span>,  };  componentWillUnmount () {    widnow.removeEventListener(<span class="string">"scroll"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{      <span class="comment">// Do something</span>    })  }  render () {      <span class="keyword">return</span> (          &lt;div&gt;            &lt;p&gt;MyComponent1 :{<span class="keyword">this</span>.props.value}&lt;<span class="regexp">/p&gt;</span><span class="regexp">            &lt;p&gt;MyComponent1 :{this.state.value}&lt;/</span>p&gt;          &lt;<span class="regexp">/div&gt;</span><span class="regexp">      )</span><span class="regexp">    }</span><span class="regexp">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ReactJS-의-생명주기&quot;&gt;&lt;a href=&quot;#ReactJS-의-생명주기&quot; class=&quot;headerlink&quot; title=&quot;ReactJS 의 생명주기&quot;&gt;&lt;/a&gt;ReactJS 의 생명주기&lt;/h2&gt;&lt;p&gt;거의 대부분의 언어에 메모리를 할당하는 
      
    
    </summary>
    
      <category term="ReactJS" scheme="http://blog.martinwork.co.kr/categories/reactjs/"/>
    
    
      <category term="ReactJS" scheme="http://blog.martinwork.co.kr/tags/reactjs/"/>
    
      <category term="ReactJS lifecycle" scheme="http://blog.martinwork.co.kr/tags/reactjs-lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>ImmutableJS 이란 무엇인가?</title>
    <link href="http://blog.martinwork.co.kr/reactjs/2018/11/17/immutable-js.html"/>
    <id>http://blog.martinwork.co.kr/reactjs/2018/11/17/immutable-js.html</id>
    <published>2018-11-16T15:50:51.000Z</published>
    <updated>2019-03-15T12:49:11.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ReactJS-의-불변성과-immutableJS"><a href="#ReactJS-의-불변성과-immutableJS" class="headerlink" title="ReactJS 의 불변성과 immutableJS"></a>ReactJS 의 불변성과 immutableJS</h2><p>원래 필자의 경우는 VueJS 를 이용하여 프론트 개발을 해왔었다. VueJS 에서는 데이터의 불변성에 대해서 ReactJS 만큼 개발자에게 중요하지 않다. (VueJS 에 대한 자세한 설명은 이 포스팅에서 따로 설명하지 않는다.) 하지만 ReactJS 를 조금이라도 공부를 했더라면 불변성이라는 단어를 한번쯤이면 들어봤을 것이다. ReactJS 에서는 state 의 불변성이 보장되어야 컴포넌트의 최적화 및 리렌더링을 보장받을 수 있다.</p><p>ReactJS 에서 불변성을 관리해주는 써드 파티 라이브러리로는 <a href="https://github.com/mweststrate/immer#readme" target="_blank" rel="noopener">immerJS</a> 혹은 <a href="http://facebook.github.io/immutable-js/" target="_blank" rel="noopener">immutableJS</a> 가 대표적으로 많이 이용한다. 그 중에서 필자의 경우 immutableJS 를 선택하였는데 그 이유는 ReactJS 와 마찬가지로 페이스북에서 만들었다라는 큰 장점이 있다. 그리고 무엇보다 2018년 11월 18일 기준 다운로드의 수 역시 약 5배 이상 차이가 난다.</p><p><img src="/images/react/immutablejs01.png" alt="/images/react/immutablejs01.png"></p><p>immutableJS 의 다운로드 수</p><p><img src="/images/react/immutablejs02.png" alt="/images/react/immutablejs02.png"></p><p>immerJS 의 다운로드 수</p><p>이제 본격적으로 immutableJS 에 대해서 살펴보도록 하자. 아래의 예제와 관련된 레파지토리는 <a href="https://github.com/MartinYounghoonKim/immutable-usability-test" target="_blank" rel="noopener">여기</a> 에서 살펴볼 수 있다.</p><h3 id="ImmutableJS-시작하기"><a href="#ImmutableJS-시작하기" class="headerlink" title="ImmutableJS 시작하기"></a>ImmutableJS 시작하기</h3><p>먼저 immutableJS 를 사용하기 위해서는 다른 라이브러리와 마찬가지로 해당 모듈을 설치해주면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install immutable</span><br></pre></td></tr></table></figure><p>그 후 아래와 같이 필요한 메소드를 이용해서 이용하면 된다.</p><h4 id="fromJS"><a href="#fromJS" class="headerlink" title="fromJS"></a>fromJS</h4><p>밑에서도 하나씩 설명을 하겠지만 ReactJS 로 개발을 하다보면 제일 많이 하는 것이 API 의 데이터를 받아와 View 에 알맞게 데이터를 가공해주는 일이다. 하지만 API 의 데이터를 받아와서 하나씩 immutableJS 의 데이터 구조에 맞는 객체로 만들어 주기도 힘들거니와 데이터 타입 역시 추적하기가 힘들다. 그럴 때 제일 많이 쓰는 메소드로서, 쉽게 이야기해서 안의 구조는 어떻게 돠어있는 지 모르고 있더라도 쉽게 immutable 객체로 만들어 준다. </p><p><img src="/images/react/immutablejs03.png" alt="/images/react/immutablejs03.png"></p><p>기본적으로 immutable 의 메소드를 사용하기 위해서는 꼭 immutable 객체가 여야 하니, API 를 이용하여 데이터를 받아온다면 굉장히 유용한 메소드가 될 수 있다. 이렇게 생성된 immutable 객체의 getter 함수부터 하나씩 살펴보도록 하자.</p><h4 id="get-메소드"><a href="#get-메소드" class="headerlink" title="get 메소드"></a>get 메소드</h4><p>get 메소드는 우리가 원하는 값을 받아오는 데 유용한 메소드이다. immutable 의 Map 이든 List 이든 둘다 get 메소드를 이용해서 읽어올 수 있다. </p><p><img src="/images/react/immutablejs04.png" alt="/images/react/immutablejs04.png"></p><p>만약 Map 형태의 경우 아래와 같이 두번째 인자로 default 값을 설정해주면 해당 키에 해당 하는 데이터가 없는 경우 설정한 default 값이 반환된다. </p><p><img src="/images/react/immutablejs11.png" alt="/images/react/immutablejs11.png"></p><h4 id="getIn-메소드"><a href="#getIn-메소드" class="headerlink" title="getIn 메소드"></a>getIn 메소드</h4><p>위처럼 get 메소드만 이용해서 이렇게 쉽게 끝난다면 우리는 굳이 ImmutableJS 라이브러리를 사용할 필요가 없다. 아마 개발을 하다보면 위처럼 간단한 구조의 데이터 구조를 이용하는 경우보다 깊이가 깊은 복잡한 데이터를 이용하는 경우가 더 많을 것이다. </p><p><img src="/images/react/immutablejs05.png" alt="/images/react/immutablejs05.png"></p><h4 id="set-메소드"><a href="#set-메소드" class="headerlink" title="set 메소드"></a>set 메소드</h4><p>위에 처럼 이제 가져왔다면 데이터를 아마 추가 해야 하는 경우도 생길 것이다. 그런 경우는 immutable 객체를 이용하고 있다는 것만 기억하면 된다. </p><p><img src="/images/react/immutablejs06.png" alt="/images/react/immutablejs06.png"></p><p>set 메소드는 기존의 데이터를 바꾸는 것이 아니라, 기존 데이터를 그대로 둔 채 사본을 반환해주기 때문에 기존의 값을 변경할 경우는 위와 같이 기존 값을 재할당 해주면 된다.</p><p>List 의 경우는 마찬가지로 insert 라는 메소드를 이용할 수도 있다.</p><p><img src="/images/react/immutablejs09.png" alt="/images/react/immutablejs09.png"></p><h4 id="setIn-메소드"><a href="#setIn-메소드" class="headerlink" title="setIn 메소드"></a>setIn 메소드</h4><p>getIn 과 마찬가지로 아마 set 에서도 복잡한 구조에 대한 setter 에 대한 것은 setIn 을 이용해서 사용할 수 있다.</p><p><img src="/images/react/immutablejs07.png" alt="/images/react/immutablejs07.png"></p><h4 id="unshift-메소드-와-push-메소드"><a href="#unshift-메소드-와-push-메소드" class="headerlink" title="unshift 메소드 와 push 메소드"></a>unshift 메소드 와 push 메소드</h4><p>아마도 Javascript 개발자라면 Javascript 에서 기본적으로 제공해주는 unshift 와 push 메소드의 편의성을 잘 알고 사용하고 싶은 욕구가 생길 것이다. ImmutableJS 에서도 친절하게 Immutable 의 List 객체에 대해서 동일한 API 를 제공해준다.  List 맨 앞에 요소를 추가하고 싶을 경우는 unshift 메소드를 사용하면 되고, 뒤에 요소를 추가하고 싶으면 push 메소드를 사용하면 된다.</p><p><img src="/images/react/immutablejs08.png" alt="/images/react/immutablejs08.png"></p><h4 id="shift-메소드와-pop-메소드"><a href="#shift-메소드와-pop-메소드" class="headerlink" title="shift 메소드와 pop 메소드"></a>shift 메소드와 pop 메소드</h4><p>친절하게 위와 같이 마찬가지로 shift 와 pop 메소드도 지원한다. 다만 기존의 Javascript 에서는 원본의 데이터에서 제거된 대상을 return 해주지만, immutableJS 는 제거되고 남은 카피 데이터를 리턴해준다. (우리는 Immutable 객체를 이용하고 있다는 것을 잊지 말아야 한다.)</p><p><img src="/images/react/immutablejs10.png" alt="/images/react/immutablejs10.png"></p><h3 id="first-메소드-와-last-메소드"><a href="#first-메소드-와-last-메소드" class="headerlink" title="first 메소드 와 last 메소드"></a>first 메소드 와 last 메소드</h3><p>위와 같이 List 의 경우는 쉽게 첫번째 값을 가져오고 뺄 수 있듯 Map 에도 그러한 게 존재한다. 만약 첫번째 키의 값을 가져오려면 first 메소드를 사용하면 된다. 반대로 마지막 키의 값을 가져오려면 last 메소드를 사용해주면 된다.</p><p><img src="/images/react/immutablejs12.png" alt="/images/react/immutablejs12.png"></p><h3 id="has-메소드"><a href="#has-메소드" class="headerlink" title="has 메소드"></a>has 메소드</h3><p>만약 Map 객체에서 해당 키를 가지고 있는지 여부를 확인하려면 has 메소드를 이용하면 된다. 그러면 그 여부에 따라 boolean 값을 반환한다. </p><p><img src="/images/react/immutablejs13.png" alt="/images/react/immutablejs13.png"></p><p>위와 같이 간단하게 나마 ImmutableJS 에 대해서 알아보았다. 개인적으로는 API 만 제대로 숙지한다면 어려움이 없는 라이브러리라 생각된다. </p><hr><h2 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h2><ul><li><a href="http://untangled.io/immutable-js-all-the-examples-youll-ever-need-to-get-set-and-delete-data-from-lists/" target="_blank" rel="noopener">http://untangled.io/immutable-js-all-the-examples-youll-ever-need-to-get-set-and-delete-data-from-lists/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ReactJS-의-불변성과-immutableJS&quot;&gt;&lt;a href=&quot;#ReactJS-의-불변성과-immutableJS&quot; class=&quot;headerlink&quot; title=&quot;ReactJS 의 불변성과 immutableJS&quot;&gt;&lt;/a&gt;ReactJS 
      
    
    </summary>
    
      <category term="ReactJS" scheme="http://blog.martinwork.co.kr/categories/reactjs/"/>
    
    
      <category term="ReactJS" scheme="http://blog.martinwork.co.kr/tags/reactjs/"/>
    
      <category term="ImmutableJS" scheme="http://blog.martinwork.co.kr/tags/immutablejs/"/>
    
  </entry>
  
  <entry>
    <title>ReactJS 와 VueJS 에 대한 주관적인 비교</title>
    <link href="http://blog.martinwork.co.kr/review/2018/11/01/between-vuejs-and-reactjs.html"/>
    <id>http://blog.martinwork.co.kr/review/2018/11/01/between-vuejs-and-reactjs.html</id>
    <published>2018-10-31T15:50:51.000Z</published>
    <updated>2019-03-15T12:49:11.162Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VueJS-와-ReactJS-사용성"><a href="#VueJS-와-ReactJS-사용성" class="headerlink" title="VueJS 와 ReactJS 사용성"></a>VueJS 와 ReactJS 사용성</h2><p>많은 블로그들에서 이미 VueJS 와 ReactJS 에 대해서 성능까지 측정하며 비교를 자세히 한게 많아서 사실 그러한 부분에 대해서는 굳이 적지 않는다. 혹시나 성능 관련해서 궁금하신 분은 다른 블로그를 보는 것을 추천한다. 다른 블로그들에서 굉장히 잘 설명하고 있다 :D<br>필자는 전 직장에서는 VueJS 를 이용하여 프론트 개발을 하였고, 현 직장에서는 React 를 이용해서 개발을 진행하고 있다. 요즘 핫한 두가지의 프레임워크를 사용하면서 개발자로서 느낀 굉장히 주관적인 리뷰를 작성해볼까 한다.</p><p><img src="/images/vue/vue-review00.png" alt="/images/vue/vue-review00.png"></p><p>먼저 VueJS 의 장점으로는 기본적으로 개인적으로 굉장히 쉽다는 점이 있다. 일단 Vue 같은 경우는 Reactive programming 을 기반으로 코드를 작성하기 때문에 React 에서처럼 Call by reference 에 대한 개념이 크게 있지 않더라도 개발을 하는데 무리는 없다. Call by value 와 Call by reference 에 대해서 잘 모르시는 분은 <a href="https://blog.martinwork.co.kr/javascript/2017/07/23/callbyreference-callbyvalue.html">여기</a> 에서 확인할 수 있다.</p><p>이것에 대한 차이점은 크게 데이터를 헨들링할 때 알 수 있다. 아래의 예제는 Array 타입의 데이터를 헨들링 하는 코드이다.</p><p>만약 Array 타입의 데이터에 값을 추가하는 경우, Vue 를 이용할 때는 아래와 같이 array 의 내장 메소드인 push 메소드를 이용하면 쉽게 추가할 수 있다.</p><p><img src="/images/vue/vue-review01.png" alt="/images/vue/vue-review01.png"></p><p>하지만 React 의 경우에는 기존의 배열의 깊은 복사를 이용하여 setState 에서 값을 변경 해주어야 한다.</p><p><img src="/images/vue/vue-review02.png" alt="/images/vue/vue-review02.png"></p><p>두번째는 가독성에 있다. 두번째 이유에 대해서는 주관적인 의견이기 때문에 보는 사람의 입장에 따라 다를 수도 있다. 일단 Vue 컴포넌트의 가장 큰 특징으로는 SFC(Single File Component) 라는 점이다. SFC는 하나의 파일 안에 DOM, Script, Style 을 포함하고 있다는 특징이 있다.</p><p><img src="/images/vue/vue-review03.png" alt="/images/vue/vue-review03.png"></p><p>하지만 반대로 React 의 경우는 다음과 같다.</p><p><img src="/images/vue/vue-review04.png" alt="/images/vue/vue-review04.png"></p><p>만약 필자와 같이 마크업에 익숙해져있는 경우에는 Vue 의 형태가 눈에 잘 들어올 수 있다는 것을 확연히 알 수 있다.</p><p>그리고 세번째의 특징으로는 Vue 의 경우에는 개발자로 하여금 코딩을 하는 데에 집중을 할 수 있도록 많은 것을 지원해주는 프레임워크이다. 이게 무슨 말이냐 하면 Vue 로 개발을 하면서 성능 개선에 대해서 React 만큼 고민을 하지 않아도 비지니스를 진행하는데는 큰 무리가 없다. 반대로 React 의 경우 사실 굉장히 개발자로 하여금 많은 고민을 하게 만든다. 많은 React 에 대한 글을 보면 React 의 경우 불필요한 Render 함수가 호출될 경우를 대비해서 <code>shouldComponentUpdate</code> 훅을 잘 이용을 해야 한다. Vue 를 이용해서 개발을 했던 개발자라면 왜 굳이 이걸 자체적으로 지원해주지 않지? 라고 생각할 법하다.</p><p>쓰다보니 굉장히 Vue 찬양적인 글로 바뀌었지만, 사실 React 를 한지 얼마 안되었지만 Vue 보다 React 에 대해 더한 매력을 느끼고 있다. Vue 를 사용하며 느낀 점은 양날의 칼이라는 느낌이 들었다. Vue 자체적으로 많은 것을 지원해주는 것이 장점이지만 반대로는 코드만 치는 바보가 되가는 느낌을 느꼈다. 하지만 React 에는 그러한 Low level 까지 개발자 스스로 고민할 수 있도록 만들어주는 장점이 있다. 오히려 React 로 개발을 하면서 잠시 잊고 있던 Javascript 언어 자체에 대한 공부를 하게 되었달까.. 다시 주니어 개발자로 하여금 초심으로 돌아갈 수 있는 계기가 되었다. </p><p>종종 커뮤니티들에 Vue 와 React 중 어떠한 것을 선택을 해서 개발을 하는 게 좋겠냐라는 질문이 올라온다. 물론 비지니스의 특성에 따라서일수도 있겠지만, 개인적으로는 프로젝트를 진행할 작업자들의 역량에 따라 선택을 하는 것이 좋지 않을까 라는 생각이 든다. Vue 의 경우 Javascript 언어 자체에 대한 깊은 이해가 없더라도 개발을 하는데 전혀 방해가 되지 않는다. 이게 Vue 의 가장 큰 장점인 <code>진입 장벽이 낮다</code> 라는 점이다. 또한 학습을 하기 좋게 공식 문서가 한글화되어 굉장히 잘 되어 있다. 물론 이것은 고마운 한국의 여러 개발자들이 번역을 해주었기에 가능한 일이다. </p><p>반대로 작업자들이 Javascript 에 대한 지식이 있다면 React 를 이용하는 것이 훨씬 좋은 퍼포먼스를 내지 않을까 싶다. React 가 역시 Facebook 이라는 비지니스를 하는 IT 기업에서 만들어서 그런지 개인적으로는 비지니스를 진행하기에 굉장히 탄탄한 라이브러리 라는 생각이 든다. 필자에게는 React 가 익숙하지 않아서 그런지 쉽지 않다. 다만 그에 따라 많은 레퍼런스를 찾기가 쉽고 같은 고민을 하는 개발자가 스택오버플로우에 많아, 문제 해결을 하는데 도움이 된다. 프레임워크를 선택함에 있어서 얼마나 많은 레퍼런스가 있는지 또한 무시할 수 없을 정도로 중요한 일이다.</p><p>Vue 에 대한 트렌드나 사용성이 점점 많아진다는 글을 이미 글로 많이 읽었지만, 사실 이직을 하기 전이나 이직을 한 후를 전후로 느끼는 점으로는 아직도 많은 회사에서 React 를 사용하고 있으며 앞으로도 React 를 많이 사용하지 않을까라는 생각이 든다. 이미 엔터프라이즈급에서는 React 를 많이 사용을 하고 있으며, 문제가 있지 않으면 굳이 리스크를 안고 프레임워크를 변경할 이유가 없다고 생각한다. 그리고 무엇보다는 Vue 개발자 시장이 아직은 넓지 않다. 주변에서도 Vue 를 이용해서 큰 프로젝트를 진행하는 경우를 보는 것이 흔치는 않다. 주변 프론트 엔드 개발자를 봐도 React 를 이용하여 개발을 하는 사람들의 수가 월등히 많은 것은 사실이다. </p><p>아직은 React 보다는 Vue 가 익숙해서인지 React 는 필자에게 쉽지 않다. 다만 React 로 개발을 하면서 깊게 고민을 할 수 있다는 점에서는 많은 보람을 느낄 수 있다. 고로 결론을 내려보자면 Vue 는 가볍게 토이 프로젝트로 개발 혹은 작은 단위의 프로젝트를 함에 있어서는 굉장히 스트레스 받지 않고 개발을 할 수 있는 아주 좋지만, 큰 프로젝트를 진행함에 있어서는 React 로 개발하는 것이 훨씬 더 체계적으로 개발할 수 있지 않을까 하는 굉장히 주관적인 견해이다. </p><p>이 글은 굉장히 주관적인 견해이기 때문에 참고만 하되 만약 지금 회사에 프레임워크를 도입하려고 한다면 많은 요인을 고려해서 고민한 후 신중하게 선택하는 것을 추천한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;VueJS-와-ReactJS-사용성&quot;&gt;&lt;a href=&quot;#VueJS-와-ReactJS-사용성&quot; class=&quot;headerlink&quot; title=&quot;VueJS 와 ReactJS 사용성&quot;&gt;&lt;/a&gt;VueJS 와 ReactJS 사용성&lt;/h2&gt;&lt;p&gt;많은
      
    
    </summary>
    
      <category term="Review" scheme="http://blog.martinwork.co.kr/categories/review/"/>
    
    
      <category term="VueJS" scheme="http://blog.martinwork.co.kr/tags/vuejs/"/>
    
      <category term="ReactJS" scheme="http://blog.martinwork.co.kr/tags/reactjs/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 는 브라우저에서 어떻게 동작하는가?</title>
    <link href="http://blog.martinwork.co.kr/javascript/2018/10/13/how-js-works-in-browser.html"/>
    <id>http://blog.martinwork.co.kr/javascript/2018/10/13/how-js-works-in-browser.html</id>
    <published>2018-10-12T15:50:51.000Z</published>
    <updated>2019-03-15T12:49:11.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="들어가기-전"><a href="#들어가기-전" class="headerlink" title="들어가기 전"></a>들어가기 전</h2><p>지금까지 자바스크립트를 이용하여 프론트 개발을 진행해오면서 많이 들어본 단어들이 있다. 콜스택, 스택 오버플로우, V8 등등.. 이 중 스택 오버플로우는 콜백 함수를 잘 못해서 실제 직면한 적도 있었다. 모르는 걸 알면서도 모른 척 넘어간 불편한 진실이었지만… 이제라도 늦게나마 브라우저 위에서 돌아가는 자바스크립트에 대해서 자세히 공부를 해보기로 했다. 일단 본격적으로 글을 보기 전에 아래의 동영상을 보는 것을 추천한다. 아래의 동영상은 4년 전인 2014 년 JSconf 에서 나왔던 내용으로 이제서야 공부하는 내 자신이 얼마나 늦게 알았는지를 깨닫게 하는 영상이기도 하다.</p><iframe width="560" height="315" src="https://www.youtube.com/embed/8aGhZQkoFbQ?autoplay=1&rel=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><p>우리가 사용하는 자바스크립트 는 자바스크립트 엔진 위에서 동작한다. 물론 당연한 소리이다. 자바스크립트 엔진이란 결국 자바스크립트 코드를 실행시키는 프로그램이기 때문이다. 웹킷, V8 등등 많이 들어봤지만 이러한 것들이 자바스크립트 엔진 종류 중 하나이다. 웹킷 같은 경우는 사파리용으로 애플에서 개발하였고, V8 같은 경우는 구글에서 개발하여 크롬의 일부가 되었다.</p><p>이러한 엔진에는 Memory Heap 과 Call stack 으로 구성되어 있다. 여기에 대한 설명은 <code>브라우저 콜스택</code> 이라고 검색하면 다른 블로그들에서 많이 설명을 하고 있기 때문에 해당 포스팅에서는 설명을 하지 않는다. (혹은 원문을 보고 싶으신 분은 <a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf" target="_blank" rel="noopener">여기</a>를 누르시면 됩니다.) 사실 필자가 궁금했던 것은 콜스택과 Web API 그리고 콜백큐 였다. 그래서 여기에서는 3가지에 대해서만 설명을 한다. 일단 구조는 다음과 같다.</p><p><img src="/images/javascript/javascript-engine-image01.png" alt="/images/javascript/javascript-engine-image01.png"></p><p>각자의 역할은 다음과 같다.</p><blockquote><ul><li>콜스택(Call stack): 동기적으로 순차적으로 실행되는 이벤트</li><li>웹 API(Web API): 브라우저에서 제공하는 API</li><li>콜백큐(Call Queue): 비동기 이벤트 혹은 onclick 와 같은 DOM 이벤트</li></ul></blockquote><p>아래에서 자세히 살펴보도록 하겠다.</p><h3 id="콜스택-Call-stack-이란"><a href="#콜스택-Call-stack-이란" class="headerlink" title="콜스택(Call stack) 이란?"></a>콜스택(Call stack) 이란?</h3><p>MDN 에 따르면 콜 스택은 <code>여러 함수들을 호출하는 스크립트에서 해당 위치를 추적하는 인터프린터를 위한 메커니즘</code> 으로 정의하고 있다. 해당 위치를 추적한다는 말이 조금 어려울 수 있지만, 쉽게 설명해서 현재 실행되고 있는 함수와 그 다음에 실행될 함수들의 정보를 가지고 있다. 한 예로 아래의 코드를 보면 이해할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visitor</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  there();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'visitor'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">there</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  hi();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'there'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hi</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">visitor();</span><br></pre></td></tr></table></figure><p>위의 함수를 실행 시켜보면 순차적으로 ‘hi there visitor’ 이라는 문구가 노출된다. 위의 함수들에 대해서 콜스택으로 표현을 하면 아래와 같다.</p><p><img src="/images/javascript/javascript-engine-image02.png" alt="/images/javascript/javascript-engine-image02.png"></p><p>먼저 vistor 이라는 함수가 실행이 되면서 해당 함수가 콜스택에 쌓인다.</p><p><img src="/images/javascript/javascript-engine-image03.png" alt="/images/javascript/javascript-engine-image03.png"></p><p>그 위에 쌓인 것이 없기 때문에 visitor 함수를 실행시킨다. 함수를 실행시키다 보니 there 이라는 함수가 콜스택에 추가된다.</p><p><img src="/images/javascript/javascript-engine-image04.png" alt="/images/javascript/javascript-engine-image04.png"></p><p>그 후 there 이라는 함수를 실행시키다 보니 이전과 마찬가지로 hi 라는 함수가 콜스택에 추가된다. </p><p><img src="/images/javascript/javascript-engine-image05.png" alt="/images/javascript/javascript-engine-image05.png"></p><p>그 후 hi 라는 함수를 실행시키는 hi 안에 드디어 첫 단어인 ‘hi’ 를 출력한다.</p><p><img src="/images/javascript/javascript-engine-image06.png" alt="/images/javascript/javascript-engine-image06.png"></p><p>실행되고나면 아래의 스택 순서(LIFO)에 맞게 하나씩 실행되며 우리가 원하는 문장을 출력한다.</p><p><img src="/images/javascript/javascript-engine-image07.png" alt="/images/javascript/javascript-engine-image07.png"><br><img src="/images/javascript/javascript-engine-image08.png" alt="/images/javascript/javascript-engine-image08.png"><br><img src="/images/javascript/javascript-engine-image09.png" alt="/images/javascript/javascript-engine-image09.png"></p><hr><h2 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h2><ul><li><a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coMTExKTsgICAgCiAgICB9LCAxMDAwKTsKfSk7CgoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coMjIyKTsKfSwgMTAwMDApOw%3D%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" target="_blank" rel="noopener">Loupe</a></li><li><a href="https://developer.mozilla.org/ko/docs/Glossary/Call_stack" target="_blank" rel="noopener">MDN 호출 스택</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;들어가기-전&quot;&gt;&lt;a href=&quot;#들어가기-전&quot; class=&quot;headerlink&quot; title=&quot;들어가기 전&quot;&gt;&lt;/a&gt;들어가기 전&lt;/h2&gt;&lt;p&gt;지금까지 자바스크립트를 이용하여 프론트 개발을 진행해오면서 많이 들어본 단어들이 있다. 콜스택, 
      
    
    </summary>
    
      <category term="Javascript" scheme="http://blog.martinwork.co.kr/categories/javascript/"/>
    
    
      <category term="콜스택" scheme="http://blog.martinwork.co.kr/tags/%EC%BD%9C%EC%8A%A4%ED%83%9D/"/>
    
      <category term="스택오버플로우" scheme="http://blog.martinwork.co.kr/tags/%EC%8A%A4%ED%83%9D%EC%98%A4%EB%B2%84%ED%94%8C%EB%A1%9C%EC%9A%B0/"/>
    
  </entry>
  
  <entry>
    <title>하노이 탑 알고리즘</title>
    <link href="http://blog.martinwork.co.kr/theory/2018/10/07/hanoi-algorithm.html"/>
    <id>http://blog.martinwork.co.kr/theory/2018/10/07/hanoi-algorithm.html</id>
    <published>2018-10-06T15:50:51.000Z</published>
    <updated>2019-03-15T12:49:11.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="하노이-탑-알고리즘"><a href="#하노이-탑-알고리즘" class="headerlink" title="하노이 탑 알고리즘"></a>하노이 탑 알고리즘</h2><p>하노의 탑 알고리즘은 많은 기업에서도 입사 문제로 많이 나올 정도로 유명한 알고리즘 중 하나이다. 아무런 지식 없이 바로 이 문제를 받는 다고 한다면 굉장히 주관적으로는 풀기가 불가능할 정도로 굉장히 어려운 문제이다. 하노이는 대표적인 재귀함수를 이용한 풀이 문제이다. 문제는 다음과 같다.</p><blockquote><p>세 개의 기둥과 이 기동에 꽂을 수 있는 크기가 서로 다른 원판들이 있다. 퍼즐을 시작하기 전에는 한 기둥에 원판들이 큰 것에서부터 작은 것 순서대로 큰 원판이 아래로 작은 원판이 위로 순서대로 쌓여있다. 이 원판을 다른 원판으로 옮겨야 한다.</p></blockquote><p>문제만 봤을 때는 자체가 어려워 보이지 않는다. 하지만 역시 쉽지 않게 다음과 같은 조건들이 붙는다.</p><ol><li>한 번에 하나의 원판만 옮길 수 있다. </li><li>큰 원판이 작은 원판 위에 있어서는 안된다.</li><li>1번에는 n개의 원판이 있고 이 n개의 원판을 3번 원판으로 최소 횟수로 옮겨야 한다.</li></ol><p>위의 조건을 만족하면서 문제를 한번 풀어보기 전에 먼저 그림으로 대략적으로 확인을 해보면 어느 정도 길이 보인다.</p><h3 id="그림으로-풀이하기"><a href="#그림으로-풀이하기" class="headerlink" title="그림으로 풀이하기"></a>그림으로 풀이하기</h3><p>아래의 그림과 같이 1번 원반이 있을 경우에 옮기기가 쉽다.</p><p><img src="/images/algorithm/hanoi01.png" alt="/images/algorithm/hanoi01.png"></p><p>그냥 A 기둥에 있는 원판 1번을 옮기면 된다.</p><p><img src="/images/algorithm/hanoi02.png" alt="/images/algorithm/hanoi02.png"></p><p>그럼 하나를 더 추가해서 A 기둥에 하나의 더 원판을 추가해서 옮겨보도록 하겠다.</p><p><img src="/images/algorithm/hanoi03.png" alt="/images/algorithm/hanoi03.png"></p><p>일단 먼저 2번 원판을 C 기둥으로 옮기기 위해서는 먼저 위에 쌓여 있는 1번 원판을 먼저 옮겨야 한다. 그래서 1번 원판을 B 기둥으로 먼저 옮겨둔다.</p><p><img src="/images/algorithm/hanoi04.png" alt="/images/algorithm/hanoi04.png"></p><p>그 후에 목표인 2번 원판을 C 기둥으로 옮기면 된다.</p><p><img src="/images/algorithm/hanoi05.png" alt="/images/algorithm/hanoi05.png"></p><p>마지막으로 2번 원판 위에 1번 원판을 옮겨주면 된다.</p><p><img src="/images/algorithm/hanoi06.png" alt="/images/algorithm/hanoi06.png"></p><p>2개일때도 마찬가지로 어렵지 않게 풀 수 있다.</p><p>그럼 원판을 하나더 추가해서 총 3개의 원판을 이동시켜보겠다.</p><p><img src="/images/algorithm/hanoi07.png" alt="/images/algorithm/hanoi07.png"></p><p>일단 먼저 1번 원판을 먼저 C 기둥으로 이동시킨다. 2개의 원판을 이동시킬 때는 1번 원판을 B 기둥으로 먼저 이동시켰는데, 3개의 원판을 이동시킬때는 C 기둥으로 옮겨놓았다는 것을 기억해야한다.</p><p><img src="/images/algorithm/hanoi08.png" alt="/images/algorithm/hanoi08.png"></p><p>1번 원판을 옮기면 그 다음은 2번 원판을 옮길 차례다. 2번 원판은 비어있는 B 기둥으로 이동시킨다.</p><p><img src="/images/algorithm/hanoi09.png" alt="/images/algorithm/hanoi09.png"></p><p>그 후에는 3번 원판이 마지막으로 옮겨질 C 기둥을 비워줘야 한다. 현재 C 기둥에 있는 1번 원판을 2번 원판이 있는 B 기둥으로 이동시킨다.</p><p><img src="/images/algorithm/hanoi10.png" alt="/images/algorithm/hanoi10.png"></p><p>그 후 3번 원판을 우리가 목표했던 C 기둥으로 이동시킨다.</p><p><img src="/images/algorithm/hanoi11.png" alt="/images/algorithm/hanoi11.png"></p><p>일단 우리가 목표하는 C 기둥으로 마지막 원판을 이동시켰다. 그 후에는 앞에서 했던 방법과 동일하게 A 기둥을 이용하여 1번 원판과 2번 원판을 순서대로 C 기둥으로 이동시켜주면 된다.</p><p>먼저 1번 원판을 A 기둥으로 옮겨준다.</p><p><img src="/images/algorithm/hanoi12.png" alt="/images/algorithm/hanoi12.png"></p><p>그 후, 2번 원판을 C 기둥으로 이동시켜준다.</p><p><img src="/images/algorithm/hanoi13.png" alt="/images/algorithm/hanoi13.png"></p><p>마지막으로 1번 원판을 C 기둥으로 옮겨주면 된다.</p><p><img src="/images/algorithm/hanoi14.png" alt="/images/algorithm/hanoi14.png"></p><p>여기까지만 해도 충분히 쉽다. 원판이 하나더 추가되었을 때부터 많은 어려움을 느낄 수 있다.</p><p><img src="/images/algorithm/hanoi15.png" alt="/images/algorithm/hanoi15.png"></p><p>먼저 1번 원판을 B 기둥으로 이동시킨다.</p><p><img src="/images/algorithm/hanoi16.png" alt="/images/algorithm/hanoi16.png"></p><p>1번 원판을 이동시킨 후에는 2번 원판을 C 기둥으로 이동시킨다.</p><p><img src="/images/algorithm/hanoi17.png" alt="/images/algorithm/hanoi17.png"></p><p>2번 원판까지 옮긴후에는 앞에서 3개의 원판을 옮길 때와 마찬가지로 1번을 2번 위로 옮긴다.</p><p><img src="/images/algorithm/hanoi18.png" alt="/images/algorithm/hanoi18.png"></p><p>그 후 비어있는 B 기둥으로 3번 원판을 옮긴다.</p><p><img src="/images/algorithm/hanoi19.png" alt="/images/algorithm/hanoi19.png"></p><p>3번까지의 원판을 옮기는 데까지는 이전 3개의 원판과 동일하다. 1번 원판과 2번 원판을 을 A 기둥을 이용하여 순서대로 B 기둥으로 옮겨준다.</p><p>앞과 동일하게 먼저 1번 원판을 A 기둥으로 옮긴다. </p><p><img src="/images/algorithm/hanoi20.png" alt="/images/algorithm/hanoi20.png"></p><p>옮겨진 후에는 2번 원판과 1번 원판을 순서대로 B 기둥으로 옮긴다.</p><p><img src="/images/algorithm/hanoi21.png" alt="/images/algorithm/hanoi21.png"><br><img src="/images/algorithm/hanoi22.png" alt="/images/algorithm/hanoi22.png"></p><p>그 후에는 먼저 A 기둥에 있는 4번 원판을 비어있는 C 기둥으로 이동시킨다. </p><p><img src="/images/algorithm/hanoi23.png" alt="/images/algorithm/hanoi23.png"></p><p>옮긴 후, 1번 원판을 C 기둥으로 2번 원판을 A 기둥으로 이동시킨다.</p><p><img src="/images/algorithm/hanoi24.png" alt="/images/algorithm/hanoi24.png"><br><img src="/images/algorithm/hanoi25.png" alt="/images/algorithm/hanoi25.png"></p><p>그 후, A 기둥과 B 기둥을 이용하여 순차적으로 원판을 쌓아나간다.</p><p><img src="/images/algorithm/hanoi26.png" alt="/images/algorithm/hanoi26.png"><br><img src="/images/algorithm/hanoi27.png" alt="/images/algorithm/hanoi27.png"><br><img src="/images/algorithm/hanoi28.png" alt="/images/algorithm/hanoi28.png"><br><img src="/images/algorithm/hanoi29.png" alt="/images/algorithm/hanoi29.png"><br><img src="/images/algorithm/hanoi30.png" alt="/images/algorithm/hanoi30.png"></p><p>여기까지 그림으로 먼저 하노이 탑 알고리즘 옮기는 것을 봤다.</p><h3 id="하노이-탑-연관성-찾기"><a href="#하노이-탑-연관성-찾기" class="headerlink" title="하노이 탑 연관성 찾기"></a>하노이 탑 연관성 찾기</h3><p>위에서 그림으로 기둥으로 옮기는 것을 확인했다. 이제 코드로 풀이하기 위해 먼저 연관성을 찾아보자.</p><p><strong>원판이 1개만 있었을 때</strong></p><blockquote><ol><li>A 기둥에 있는 원판을 C 기둥으로 이동한다.</li></ol></blockquote><p><strong>원판이 2개만 있었을 때</strong></p><blockquote><ol><li>A 기둥에 있는 원판을 B 기둥으로 이동한다.</li><li>A 기둥에 있는 원판을 C 기둥으로 이동한다.</li><li>B 기둥에 있는 원판을 C 기둥으로 이동한다.</li></ol></blockquote><p><strong>원판이 3개만 있었을 때</strong></p><blockquote><ol><li>A 기둥에 있는 원판을 C 기둥으로 이동한다.</li><li>A 기둥에 있는 원판을 B 기둥으로 이동한다.</li><li>C 기둥에 있는 원판을 B 기둥으로 이동한다.</li><li>A 기둥에 있는 원판을 C 기둥으로 이동한다.</li><li>B 기둥에 있는 원판을 A 기둥으로 이동한다.</li><li>B 기둥에 있는 원판을 C 기둥으로 이동한다.</li><li>A 기둥에 있는 원판을 C 기둥으로 이동한다.</li></ol></blockquote><p><strong>원판이 4개만 있었을 때</strong></p><blockquote><ol><li>A 기둥에 있는 원판을 B 기둥으로 이동한다.</li><li>A 기둥에 있는 원판을 C 기둥으로 이동한다.</li><li>B 기둥에 있는 원판을 C 기둥으로 이동한다.</li><li>A 기둥에 있는 원판을 B 기둥으로 이동한다.</li><li>C 기둥에 있는 원판을 A 기둥으로 이동한다.</li><li>C 기둥에 있는 원판을 B 기둥으로 이동한다.</li><li>A 기둥에 있는 원판을 C 기둥으로 이동한다.</li><li>B 기둥에 있는 원판을 C 기둥으로 이동한다.</li><li>B 기둥에 있는 원판을 A 기둥으로 이동한다.</li><li>C 기둥에 있는 원판을 A 기둥으로 이동한다.</li><li>B 기둥에 있는 원판을 C 기둥으로 이동한다.</li><li>A 기둥에 있는 원판을 B 기둥으로 이동한다.</li><li>A 기둥에 있는 원판을 C 기둥으로 이동한다.</li><li>B 기둥에 있는 원판을 C 기둥으로 이동한다.</li></ol></blockquote><p>그렇다면 n 개의 원판을 이동하는 경우는 어떻게 될까?</p><p><strong>원판이 n개 있었을 때</strong></p><blockquote><ol><li>A 기둥에 있는 n-1 번째 원판을 B 기둥으로 이동한다.</li><li>A 기둥에 있는 n 번째 원판을 C 기둥으로 이동한다.</li><li>B 기둥에 있는 n-1 번째 원판을 C 기둥으로 이동한다.</li></ol></blockquote><p>위의 내용을 종합해보건데, 하노의 알고리즘의 계산은 다음과 같다.</p><blockquote><ol><li>n-1 개의 원반은 A 기둥에서부터 B 기둥으로 옮기는 데 <code>Hanoi(n-1)</code> 이 걸린다.</li><li>n 개의 원반은 A 기둥에서부터 C 기둥으로 옮기는 데 <code>Hanoi(1)</code> 이 걸린다. (Hanoi(1) 은 한번만 이동하면 되므로 1 로 계산한다.) </li><li>n-1 개의 원반은 다시 B 기둥에서부터 C 기둥으로 옮기는 <code>Hanoi(n-1)</code> 이 걸린다.</li></ol></blockquote><p>그러므로 총 계산해보면 알고리즘의 수식은 <code>2Hanoi(n-1) + 1</code> 이다.</p><p>아래의 코드는 프로그래머스(programmers)에 나오는 하노이 탑 알고리즘에 대한 해답이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> answer = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">hanoi</span> (<span class="params">n, from, to</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> by = <span class="number">6</span>-<span class="keyword">from</span>-to;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">      answer.push([<span class="keyword">from</span>, to]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      hanoi(n<span class="number">-1</span>, <span class="keyword">from</span>, by);</span><br><span class="line">      answer.push([<span class="keyword">from</span>, to]);</span><br><span class="line">      hanoi(n<span class="number">-1</span>, by, to);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hanoi(n, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 에제의 경우 재귀함수를 이용하여 풀었지만 이에 대한 문제점으로는 재귀함수의 고질점인 문제, 스택오버플로우(stack flow) 에 대한 문제가 해결 되지 않았다. 이후 스택을 이용하여 이에 대한 해결 방법을 찾도록 하겠다.<br>이상으로 하노이 알고리즘에 대한 포스팅을 마치겠다.</p><p>아래는 위에서 이야기한 재귀함수의 고질적인 문제를 해결하기 위해 비재귀 방식인 스택을 이용하여 문제를 풀어보겠다. 많은 블로그에서 재귀함수에 대해서 많이 다루고 있으나, 비재귀방식으로 하노이 알고리즘을 푸는 글들이 없어서 소스를 첨부한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = []; </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">hanoi</span> (<span class="params">n, from, to</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [];</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> by = <span class="number">6</span>-<span class="keyword">from</span>-to;</span><br><span class="line">    <span class="keyword">while</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (n &gt;<span class="number">1</span>) &#123;</span><br><span class="line">        arr.push(to);</span><br><span class="line">        arr.push(by);</span><br><span class="line">        arr.push(<span class="keyword">from</span>);</span><br><span class="line">        arr.push(n);</span><br><span class="line">        n--;</span><br><span class="line">        arr.push(to);</span><br><span class="line">        to = by;</span><br><span class="line">        by = arr.pop();</span><br><span class="line">      &#125;</span><br><span class="line">      result.push([<span class="keyword">from</span>, to]);</span><br><span class="line">      <span class="keyword">if</span> (arr.length <span class="number">-1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n = arr.pop();</span><br><span class="line">        <span class="keyword">from</span> = arr.pop();</span><br><span class="line">        by = arr.pop();</span><br><span class="line">        to = arr.pop();</span><br><span class="line">        result.push([<span class="keyword">from</span>, to]);</span><br><span class="line">        n --;</span><br><span class="line">        arr.push(<span class="keyword">from</span>);</span><br><span class="line">        <span class="keyword">from</span> = by;</span><br><span class="line">        by = arr.pop();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hanoi (n, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h2><ul><li><a href="http://programmers.co.kr" target="_blank" rel="noopener">programmers 알고리즘 사이트</a></li><li>[알고리즘 도감 - 이시다 모리테루, 미야자키 쇼이치 저자]</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;하노이-탑-알고리즘&quot;&gt;&lt;a href=&quot;#하노이-탑-알고리즘&quot; class=&quot;headerlink&quot; title=&quot;하노이 탑 알고리즘&quot;&gt;&lt;/a&gt;하노이 탑 알고리즘&lt;/h2&gt;&lt;p&gt;하노의 탑 알고리즘은 많은 기업에서도 입사 문제로 많이 나올 정도로 
      
    
    </summary>
    
      <category term="Theory" scheme="http://blog.martinwork.co.kr/categories/theory/"/>
    
    
      <category term="프로그래머스" scheme="http://blog.martinwork.co.kr/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
      <category term="하노이탑알고리즘" scheme="http://blog.martinwork.co.kr/tags/%ED%95%98%EB%85%B8%EC%9D%B4%ED%83%91%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
  </entry>
  
  <entry>
    <title>JWT 토큰 인증 방식 살펴보기</title>
    <link href="http://blog.martinwork.co.kr/theory/2018/09/26/what-is-jwt-token.html"/>
    <id>http://blog.martinwork.co.kr/theory/2018/09/26/what-is-jwt-token.html</id>
    <published>2018-09-25T15:50:51.000Z</published>
    <updated>2019-03-15T12:49:11.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JWT-Token-이란-무엇인가"><a href="#JWT-Token-이란-무엇인가" class="headerlink" title="JWT Token 이란 무엇인가?"></a>JWT Token 이란 무엇인가?</h2><p>Facebook, Github, Google 등의 외국계 회사들의 Open API 를 통한 회원인증을 구현해봤다던가 혹은 카카오 API 등을 이용해본적이 있다면 한번쯤은 JWT Token 에 대해서 들어봤을 것이다. JWT Token 은 JSON Web Token 의 약자로서, 자체의 토큰은 Base64로 인코딩한 평범한 String 으로 이루어져 있다. 이 JWT Token 은 access token 을 만들기 위해 사용된다. 물론 여기에서 이야기 하는 access token 이란 단순하게 우리가 분류하는 자원에 접근하는 access token 만을 이야기 하는 것이 아니라, 권한/인증에 대한 token 을 말한다. JWT Token 은 그 자체만으로도 권한과 인증의 역할을 가질 수 있다.</p><h3 id="JWT-Token-의-구조"><a href="#JWT-Token-의-구조" class="headerlink" title="JWT Token 의 구조"></a>JWT Token 의 구조</h3><p>JWT Token 은 위에서 말했듯이 평범한 String 인데 어떻게 권한/인증을 체크할 수 있을까? JWT Token 자체를 보면 아래와 같이 마침표를 기준으롤 3가지 영역으로 나뉘어져 있다.</p><p><img src="/images/jwt/jwt01.png" alt="/images/jwt/jwt01.png"></p><p>각자의 영역은 사진과 같이 각자의 영역이 있다. 아래의 사진은 위의 JWT Token 을 Decoding 했을 때의 결과다.</p><p><img src="/images/jwt/jwt02.png" alt="/images/jwt/jwt02.png"></p><h4 id="Header-영역"><a href="#Header-영역" class="headerlink" title="Header 영역"></a>Header 영역</h4><p><img src="/images/jwt/jwt03.png" alt="/images/jwt/jwt03.png"></p><p>Header 영역에는 <code>해당 Token 에 대한 유형</code> 과 <code>알고리즘에 대한 정보</code>가 포함되어 있다. 위의 Token 은 <a href="https://jwt.io/" target="_blank" rel="noopener">JWT 공식 홈페이지</a> 에서 가져온 Token 으로서 Token 의 알고리즘은 <code>HS256</code> 이고, 유형은 <code>JWT</code> 이다. 알고리즘은 HS256, HS384, HS512, RS256, RS384, RS512, ES256, ES384, ES512 등 각 언어별로 지원하는 알고리즘이 있으니 공식 홈페이지에서 확인해서 선택하면 된다.</p><h4 id="Payload-영역"><a href="#Payload-영역" class="headerlink" title="Payload 영역"></a>Payload 영역</h4><p><img src="/images/jwt/jwt04.png" alt="/images/jwt/jwt04.png"></p><p>Payload 영역은 기본적인 유저에 대한 정보와 함께 추가한 유저의 정보가 포험되어 있다. JWT Token 에서는 이미 정해져있는 이름을 가진 아래의 7개에 대한 정보를 담을 수 있다. </p><ol><li><strong>iss</strong>: Token 발행자(Issuer) 으로서 해당 필드는 문자열 혹은 URI 로 이뤄지면 선택사항이다.</li><li><strong>sub</strong>: Token 의 제목 (Subject) 으로서 해당 필드의 값은 문자열 혹은 URI 로 이루어져 있다. 해당 값은 전역적으로나, 발행자 범위에서 유일한 값이어야 한다.</li><li><strong>aud</strong>: Token 의 대상자 (Audience) 로서 해당 값에 대한 인증이 이뤄지지 않으면 해당 Token 을 이용한 접근이 거부 된다. 해당 필드는 문자열 혹은 URI 로 이루어져 있다.</li><li><strong>exp</strong>: Token 의 유효한 날짜 정보(Expiration time) 으로서, 해당 Token 을 가지고 요청을 했을 때 현재의 시간을 지났다면 해당 Token 을 이용한 접근이 거부된다. 일반적으로는 몇 분 이내로 설정을 하며 해당 값은 숫자로만 이루어져야 한다.</li><li><strong>nbf</strong>: Token 의 유효 시작 날짜 정보 (Not before) 으로서, 해당 Token 을 이용하려면 현재의 시간이 이 정보에 기재된 시간과 같거나 지났어야 한다. <code>exp</code> 와 마찬가지로 일반적으로는 몇 분 이내로 설정하며 해당 값은 숫자로만 이루어져야 한다.</li><li><strong>iat</strong>: Token 의 발행된 날짜 정보(Issued At) 으로서, JWT 이 발행된 시간에 대한 정보를 담고 있다. 위의 <code>exp</code> 혹은 <code>nbf</code> 와 마찬가지로 숫자로만 이뤄져야 한다.</li><li><strong>jti</strong>: Token 의 고유 식별자(JWT ID) 로서, 해당 값은 고유한 식별자에 대한 값이 할당되어야 한다. 해당 값은 대소문자를 구별하는 문자열로 구성되어져 있다.</li></ol><h4 id="Signature-영역"><a href="#Signature-영역" class="headerlink" title="Signature 영역"></a>Signature 영역</h4><p><img src="/images/jwt/jwt05.png" alt="/images/jwt/jwt05.png"></p><p>Signature 영역은 각 Header, Payload 에 해당 하는 정보와 서명키에 대한 정보가 들어가져 있다. 이 영역은 Header 에서 지정한 알고리즘으로 만들어져 있으며, 인증에 대한 정보 확인 및 변조 여부를 확인하는데 사용된다.</p><h3 id="JWT-Token-의-특징"><a href="#JWT-Token-의-특징" class="headerlink" title="JWT Token 의 특징"></a>JWT Token 의 특징</h3><p>JWT Token 은 다음과 같은 특징이 있다. </p><h4 id="JWT-Token-은-Stateless-하다"><a href="#JWT-Token-은-Stateless-하다" class="headerlink" title="JWT Token 은 Stateless 하다"></a>JWT Token 은 Stateless 하다</h4><p>기존의 웹 어플리케이션은 대체적으로 세션 기반으로 인증 처리를 많이 구현을 했다. 세션을 이용하면 단점이 어딘가에 그러한 세션 정보를 저장을 해야한다는 것이다. 그러한 정보는 대체적으로 서버의 메모리 에 저장을 하는 경우가 많다. 서버의 메모리에 저장을 하고 있다가 갑자기 유저의 수가 늘어난다면 여기에서 또 서버를 증설할 것이다. 그렇게 되면 문제점이 두가지가 생긴다. 첫번째는 늘어난 수만큼 서버의 메모리를 계속 사용을 해야한다는 점이 있을 것이고, 두번째는 세션 정보가 서버 간에 공유 되지 않는다는 점이다.</p><p><img src="/images/jwt/jwt06.png" alt="/images/jwt/jwt06.png"></p><p>위의 사진과 같이 어떠한 유저가 A 서버로 접속해서 로그인을 했다고 가정해보겠다. 로그인을 하면 A 서버에는 해당 유저에 대한 세션 정보를 저장할 것이다. </p><p><img src="/images/jwt/jwt07.png" alt="/images/jwt/jwt07.png"></p><p>그러다가 만약 유저가 B 서버로 접속이 됐다면 B 서버에는 세션 정보가 없어 로그인일 풀릴 것이다.(로드밸런싱에 대한 개념은 위 주제와는 벗어남으로 추후 따로 설명하도록 하겠다.) 그렇게 되면 로그인을 하고 나서도 계속 로그인을 하라고 나올 것이다. 실제 필자도 위의 경우에 직면한 적이 있었다. 물론 그러한 해결 방안으로는 Sticky session 을 이용했지만, 사실 근본적인 해결방법은 아니었다. (여기에서의 관점은 session 이 주제가 아님으로 따로 이야기하지 않고 넘어가도록 하겠다.) 물론 위와 같은 방법을 우회하는 방법도 있다. 자체 세션 서버를 따로 두는 것도 하나의 방법일 수 있다. 하지만 그렇게 몰아넣는 것 역시 서버에서는 부하가 걸릴 수 있다. 이와 같은 stateful 한 방법은 요즘과 같이 서버를 스케일 아웃(Scale-out)할 때 문제가 생길 수 있다. 이러한 stateful 과 상반되는 개념이 stateless 이다. JWT Token 은 서버 입장에서 요청을 받았을 때 그때그때 인증과 권한 체크를 하기 때문에 세션 처럼 따로 저장할 필요는 없다. 위와 같이 A 서버로 접속했다가 B 서버로 요청을 한다고 해도 문제 생길 것이 없다. 쉽게 이야기 해서 <code>수평으로 쉽게 확장이 가능하다는 의미</code>가 된다.</p><h4 id="JWT-Token-은-무결성이-보장된다"><a href="#JWT-Token-은-무결성이-보장된다" class="headerlink" title="JWT Token 은 무결성이 보장된다."></a>JWT Token 은 무결성이 보장된다.</h4><p>공식 홈페이지에 메인에서 테스트를 해보면 예시로 보여주고 있는 JWT Token 의 secret 키를 하나라도 입력을 하게 되면 JWT Token 에서 Signature 영역의 글자가 바로 바뀌는 것을 알 수 있다. 이처럼 JWT Token 은 변조가 되었을 때, 바로 알아차릴 수가 있다.</p><hr><h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h3><ul><li><a href="https://jwt.io/" target="_blank" rel="noopener">JWT 공식 홈페이지</a></li><li><a href="https://tools.ietf.org/html/rfc7519#section-4.1" target="_blank" rel="noopener">RFC 7519 홈페이지</a></li><li><a href="https://auth0.com/docs/jwt" target="_blank" rel="noopener">Auth 홈페이지</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JWT-Token-이란-무엇인가&quot;&gt;&lt;a href=&quot;#JWT-Token-이란-무엇인가&quot; class=&quot;headerlink&quot; title=&quot;JWT Token 이란 무엇인가?&quot;&gt;&lt;/a&gt;JWT Token 이란 무엇인가?&lt;/h2&gt;&lt;p&gt;Facebook
      
    
    </summary>
    
      <category term="Theory" scheme="http://blog.martinwork.co.kr/categories/theory/"/>
    
    
      <category term="JWT Token" scheme="http://blog.martinwork.co.kr/tags/jwt-token/"/>
    
      <category term="Authenticate" scheme="http://blog.martinwork.co.kr/tags/authenticate/"/>
    
  </entry>
  
  <entry>
    <title>Withinnovation 회사를 떠나며</title>
    <link href="http://blog.martinwork.co.kr/review/2018/09/23/withinnovation-corp-review.html"/>
    <id>http://blog.martinwork.co.kr/review/2018/09/23/withinnovation-corp-review.html</id>
    <published>2018-09-22T15:50:51.000Z</published>
    <updated>2019-03-15T12:49:11.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="이-글을-쓰는-이유"><a href="#이-글을-쓰는-이유" class="headerlink" title="이 글을 쓰는 이유"></a>이 글을 쓰는 이유</h2><p>과거 위드이노베이션(이하 여기어때, 사명보단 여기어때가 더 익숙하기도 하고, 내부적으로 회사명보단 서비스명으로 부를때가 있다)에서 기술 블로그를 잠깐 운영했던 적이 있다. 그 기술 블로그에는 글이 몇개 없긴 했지만 새로운 개발자가 궁금해 할법한 회사의 분위기를 느낄 수 있던 글이 있었고, 또 그 기술 블로그를 통해 입사한 동료 개발자도 있었다. 하지만 지금은 안타깝게도 여기어때의 기술 블로그가 폐지가 되었고, 혹시라도 궁금해할 여기어때의 분위기를 타기업 정보 플랫폼에서만 볼 수 있다. 하지만 타기업 플랫폼에서의 정보는 한정되어 있어 새로 입사를 원하는 사람들에게는 정보를 주기에 부족하다는 생각이 들었다. 무엇보다 내가 이직을 결정한 회사를 결정하기에 결정적으로 한몫했던 것이 그 회사의 몇몇 개발자들이 회사를 나오면서 썼던 내부 문화에 대한 글이었기 때문에 더더욱 나도 여기어때 라는 회사에 대한 글을 쓰고 싶었다. 이 글은 개인적인 견해와 그 동안의 경험을 토대로 썼을 뿐 누구의 부탁을 받고 쓰는 것도 아니다. </p><h3 id="여기어때에-입사하기"><a href="#여기어때에-입사하기" class="headerlink" title="여기어때에 입사하기"></a>여기어때에 입사하기</h3><p>2017년 7월 12일 여기어때에 입사하여 2018월 9월 21일까지 근무를 하며 참 많은 추억과 좋은 경험을 했던 것 같다. 처음에 여기어때에 입사하기 전에는 에이전시에서 근무를 했다. 그 때의 이직 사유는 자사 서비스를 하는 회사를 다니겠다라는 의지였던 것 같다. 꼭 자사 서비스를 하는 회사를 들어가야겠다라는 의지가 컸고 당시 W사, M사, H사 그리고 여기어때 등에 지원을 했다. 그 중 회사 분위기 및 복지 그리고 거리가 여기어때가 제일 좋았던 것 같다. 필자 같은 경우는 처우를 관련해서 면접을 총 3번에 걸쳐서 보긴 했다. 우여곡절 끝에 여기어때에 입사했다. 처음 여기어때에는 8-9명 정도의 개발자로만 구성되어 있던 작은 조직이었다.(데이터, 인프라팀은 별도로 서비스 개발팀만) 처음에는 굉장히 놀랐다. 여기어때가 작은 회사가 아니었는데도, 개발자가 이렇게 적을 수 있다니.. 그런 놀라움 반, 설렘 반으로 처음 입사를 했다.</p><h3 id="여기어때에서-일을-하면서"><a href="#여기어때에서-일을-하면서" class="headerlink" title="여기어때에서 일을 하면서"></a>여기어때에서 일을 하면서</h3><p>여기어때라는 회사 그리고 그 안에서 만났던 소중한 동료들은 나에게 잊지 못할 추억과 성장 그리고 기회를 주었다. 입사해서 처음 프론트 개발을 접했고, 처음 내가 만든 서비스를 사내적으로 혹은 외부에 오픈을 했던 경험을 했다. 물론 과거 에이전시에서 근무했을 때도 정말 한달 걸러 찍어내듯이 만들었지만, 실제 개발다운 개발을 해서 오픈하는 것과는 그 감동이 달랐다. 무엇보다 처음 VueJS를 사용해서 개발을 한다고 했을 때 정말 우여곡절이 많았던 것 같다. 어떻게 보면 기존의 2 tier 형식의 구조를 가지고 있던 여기어때에서 3 tier 이상의 구조를 가져간다고 했을 때, 그 사이드 이펙트가 예측이 안가는 것도 사실이였긴 했다. 물론 동료들도 함께 고민을 해주었지만, 실제 그렇게 서비스를 구현하고 있는 회사에서의 방식 역시 파악하는 게 중요했다. 그렇게 한달 정도를 외부의 개발자들을 굉장히 많이 찾아다녔던 것 같다. 그리고 나서도 확신히 안들어 당시의 개발팀장님, 시니어 개발자들에게 리뷰 요청도 엄청 많이 했다. 지금 나를 돌이켜보면 엄청 귀찮게 했던 사람이지 않았나 라는 생각이 들기도 하다. 하지만 처음 무엇인가를 도전함에 있어서 다른 개발자들 역시 두려움보단 도전이라는 것에 큰 의의를 두고, 같이 고민해주는 점이 개인적으로는 힘이 굉장히 많이 되지 않았나라는 생각이 든다.</p><h4 id="여기어때에서-일하면서의-장점-4가지"><a href="#여기어때에서-일하면서의-장점-4가지" class="headerlink" title="여기어때에서 일하면서의 장점 4가지"></a>여기어때에서 일하면서의 장점 4가지</h4><ol><li><p>수평적인 조직 문화<br>여기어때의 회사 홈페이지에도 나와있지만 여기어때에서는 영어 호칭을 사용하고 있다. 그래서 회사의 조직 문화 역시 딱딱하지도 않고 나와 같은 주니어 개발자가 의견을 제시함에 있어서도 자유롭다. 그만큼 회의에서 뭔가 주도적으로 일하고자 한다면 본인의 것을 많이 챙겨갈 수 있을 것이라고 생각한다.</p></li><li><p>기회가 많은 문화<br>이 문화는 사람에 따라서 많이 갈릴 것이다. 일을 주도적으로 찾아서 하는 사람과 수동적으로 하는 사람의 차이가 있을 것이다. 수동적인 사람에게는 ‘왜 기회가 많다고 하지?’ 라고 할 수도 있다. 물론 모든 사람에게 해당되는 것은 아니다. 하지만 자율적으로 찾아서 한다고 하면 사실 기회가 많이 주어진다고 생각한다. 사실 이 장점 같은 경우는 꼭 여기어때 만의 장점은 아니기도 하다. 어느 회사나 하고자 한다면 기회를 주는 건 마찬가지이기 때문에…</p></li><li><p>복지가 좋은 회사<br>정말 이번에 이직을 결정했을 때도 복지 때문에 많은 고민을 했을 정도로 회사의 복지가 좋다. 아침, 점심, 저녁를 다 지원해주고 심지어 저녁은 야근을 안하더라도 먹고 퇴근해도 된다. 그리고 월요일 오후 출근은… 정말 포기할 수 없을 정도로 좋다. 그 뿐만 아니고도 사내적으로 카페테리아가 있다는 점과 도서 무제한 구매 가능이라는 점이 굉장히 큰 복지다. 개발자에게 도서 무제한 구매가 가능하다는 것은 기술 서적을 얼마든지 사도 된다라는 장점이 있다. (물론 이걸 악용해서 읽지도 않을 책을 사는 사람도 있지만..) 물론 이외에도 많지만 필자 같은 경우는 운동을 하는 것도, 렌트카를 빌렸던 것도 아니라서 모르겠다.</p></li><li><p>공유 문화<br>최근 RND 조직을 이끄는 사람이 달라지면서 좋은 개발자 들 또한 많이 들어왔다. 그로 인해 파트별로 공유 문화가 이전보다 더 활성화가 되었으며 그로 인해 개발자들끼리의 지식 공유가 이전보다는 더 원활해 졌다. 외부에선 공유 받기 힘든 지식 공유가 많아 참 좋은 것 같다.</p></li></ol><h4 id="여기어때에서-일하면서의-단점-2가지"><a href="#여기어때에서-일하면서의-단점-2가지" class="headerlink" title="여기어때에서 일하면서의 단점 2가지"></a>여기어때에서 일하면서의 단점 2가지</h4><ol><li><p>코드 리뷰 문화<br>아직 코드 리뷰에 대한 문화가 정착하지 않았다. 물론 일부 프로젝트에서는 형상 관리 툴에서 머지리퀘스트를 날려서 리뷰를 요청하는 경우도 있고, 팀별로 리뷰를 하는 팀도 있지만 아직 문화적으로 코드 리뷰가 공식적으로 정착되어 있지는 않다.</p></li><li><p>잦은 조직 개편<br>이 것은 타기업 정보 플랫폼에서 후기로 볼 수 있긴 하지만 조직 개편이 잦긴하다.. 한달 혹은 두달에 한번씩은 꼭 자리를 옮기는 것 같다. 어떠한 의도에서 자꾸 자리를 바꾸고 하는지는 이해되긴 하지만, 매번 자리를 옮기는 것은 정말 힘들긴 하다…</p></li></ol><h3 id="나에게-있어서-여기어때란"><a href="#나에게-있어서-여기어때란" class="headerlink" title="나에게 있어서 여기어때란?"></a>나에게 있어서 여기어때란?</h3><p>외부에서 봤을 때 여기어때는 급성장한 회사, 성공한 회사 라고 많이들 생각한다. 물론 그 것이 틀렸다라는 것을 말 하려는 것이 아니라, 앞으로도 계속 성장할 회사가 아닐까라는 생각을 한다. 일단 무엇보다 회사가 직원을 이정도까지 위한다 라는 것은 복지를 보면 볼 수 있다. 여기어때는 월요일은 오전에는 출근을 안한다. 처음에는 ‘과연 정말 그럴까?’ 했는데, 정말 아침에 일찍오면 사람 없다.. 또한 식사 역시 아침 점심 저녁 다 제공해주고 무엇보다 저녁은 야근 안하더라도 그냥 먹고 퇴근해도 된다. 하지만 이것보다 더 좋은 것은 좋은 동료가 있다는 것이다. 물론 타 유명 기업에 있는 개발자에 비해 뛰어난 개발자가 아닐 수도 있다. 내가 이야기하는 좋은 동료는 뛰어난 동료를 이야기하는 것이 아니라 같이 일하고 싶은 동료이다. 일을 함에 있어 함께 고민해주고, 개발을 일로 하는 것이 아니라 즐길 수 있는 동료 개발자 들이 좋은 것 같다. (물론 아닌 사람들도 분명이 존재한다) </p><p>아직 여기어때가 성장하려면 나아가야할 산이 많다. 하지만 처음 2017년 7월 입사했을 때 10명도 안되는 개발자가 1년 정도가 지난 퇴사하기 직전에는 4배 이상의 사람들이 들어와서 일을하는 것 보면 앞으로 이 성장 속도는 점점 더 빨라지지 않을까 라는 생각이 든다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;이-글을-쓰는-이유&quot;&gt;&lt;a href=&quot;#이-글을-쓰는-이유&quot; class=&quot;headerlink&quot; title=&quot;이 글을 쓰는 이유&quot;&gt;&lt;/a&gt;이 글을 쓰는 이유&lt;/h2&gt;&lt;p&gt;과거 위드이노베이션(이하 여기어때, 사명보단 여기어때가 더 익숙하기도
      
    
    </summary>
    
      <category term="Review" scheme="http://blog.martinwork.co.kr/categories/review/"/>
    
    
      <category term="Withinnovation" scheme="http://blog.martinwork.co.kr/tags/withinnovation/"/>
    
      <category term="여기어때" scheme="http://blog.martinwork.co.kr/tags/%EC%97%AC%EA%B8%B0%EC%96%B4%EB%95%8C/"/>
    
      <category term="호텔타임" scheme="http://blog.martinwork.co.kr/tags/%ED%98%B8%ED%85%94%ED%83%80%EC%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>자료구조, 트리(Tree)</title>
    <link href="http://blog.martinwork.co.kr/theory/2018/09/22/what-is-tree.html"/>
    <id>http://blog.martinwork.co.kr/theory/2018/09/22/what-is-tree.html</id>
    <published>2018-09-21T15:50:51.000Z</published>
    <updated>2019-03-15T12:49:11.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tree-란-무엇인가"><a href="#Tree-란-무엇인가" class="headerlink" title="Tree 란 무엇인가?"></a>Tree 란 무엇인가?</h2><p>위키 백과에 따르면 <code>트리 구조 란 그래프의 일종으로 여러 노드가 한 노드를 가리킬 수 없는 구조이다.</code> 라고 표현을 하고 있다. 이 말을 조금 더 자세히 풀어 보면 노드가 하나 이상의 자식이 있는 경우를 Tree 라 하며, 임의의 노드에서 다른 어떠한 노드로의 경로가 하나 밖에 존재하지 않는 데이터의 구조를 가진 것을 트리 구조라고 부른다. 인터넷에 자료구조 트리 라고 치면 바로 나오는 데이터 구조의 형태가 아래와 같이 노출된다. </p><p><img src="/images/datastructure/tree01.png" alt="/images/datastructure/tree01.png"></p><p>트리 구조 에서 최상위 노드 A 를 <code>Root Node</code> 라 표현한다. 노드 B는 <code>Root Node 의 Child Node 이자, 노드 C 의 Parent Node</code> 이다. 노드 C 와 같이 Child 노드가 없는 노드의 경우를 <code>Leaf Node</code> 라 부른다.</p><h3 id="이진-트리-Binary-Tree"><a href="#이진-트리-Binary-Tree" class="headerlink" title="이진 트리 - Binary Tree"></a>이진 트리 - Binary Tree</h3><p>자료 구조 Tree 에 대해서 공부를 한다고 하면 대부분이 이진 트리 혹은 이진 탐색 트리에 대해서 공부를 할 정도로 많은 사람들이 관심을 가장 많이 보이는 트리 자료 구조이다. 이진 트리 같은 경우는 <code>각각의 노드가 최대 2개의 자식 노드</code>를 가질 수 있다. 3개의 자식 노드를 가지는 트리 구조로는 <code>Ternary Tree</code> 가 있지만, 해당 블로그에서는 이진 트리에 대해서만 다룬다. 혹시라도 관심 있는 사람은 개인적으로 찾아보는 것을 추천한다.</p><h4 id="균형-이진-트리-Balanced-Binary-Tree-와-불균형-이진-트리-Unbalanced-Binary-Tree"><a href="#균형-이진-트리-Balanced-Binary-Tree-와-불균형-이진-트리-Unbalanced-Binary-Tree" class="headerlink" title="균형 이진 트리(Balanced Binary Tree) 와 불균형 이진 트리(Unbalanced Binary Tree)"></a>균형 이진 트리(Balanced Binary Tree) 와 불균형 이진 트리(Unbalanced Binary Tree)</h4><p>균형 이진 트리(Balanced Binary Tree) 는 각자의 모든 노드가 가지는 Child Node 의 깊이가 1 이상 차이 나지 않는 이진 트리를 일컫는다.</p><p><img src="/images/datastructure/tree02.png" alt="/images/datastructure/tree02.png"></p><h4 id="이진-트리-모양에-따른-종류"><a href="#이진-트리-모양에-따른-종류" class="headerlink" title="이진 트리 모양에 따른 종류"></a>이진 트리 모양에 따른 종류</h4><p>모양에 따른 분류는 대표적으로 포화 이진 트리(Full Binary Tree), 완전 이진 트리(Complete Binary Tree) 그리고 포화 이진 트리(Perfect Binary Tree) 등 총 3가지로 나누어서 볼 수 있다.</p><h5 id="포화-이진-트리-Full-Binary-Tree"><a href="#포화-이진-트리-Full-Binary-Tree" class="headerlink" title="포화 이진 트리(Full Binary Tree)"></a>포화 이진 트리(Full Binary Tree)</h5><p>포화 이진 트리는 모든 노드가 자식 노드를 0개 혹은 2개를 갖는 구조를 말한다.</p><p><img src="/images/datastructure/tree03.png" alt="/images/datastructure/tree03.png"></p><h5 id="완전-이진-트리-Complete-Binary-Tree"><a href="#완전-이진-트리-Complete-Binary-Tree" class="headerlink" title="완전 이진 트리(Complete Binary Tree)"></a>완전 이진 트리(Complete Binary Tree)</h5><p>완전 이진 트리는 Leaf Node 를 제외하고 모든 노드가 2개의 자식 노드를 가지거나 마지막 노드는 가능한 가장 왼쪽에 있는 트리 구조를 말한다.</p><p><img src="/images/datastructure/tree04.png" alt="/images/datastructure/tree04.png"></p><h5 id="포화-이진-트리-Perfect-Binary-Tree"><a href="#포화-이진-트리-Perfect-Binary-Tree" class="headerlink" title="포화 이진 트리(Perfect Binary Tree)"></a>포화 이진 트리(Perfect Binary Tree)</h5><p>완전 이진 트리와 조금 헷갈릴 수 있는 트리 구조로서, 모든 내부 노드가 두개의 자식 노드를 가지고, 깊이 역시 동일한 트리 구조를 말한다.</p><p><img src="/images/datastructure/tree05.png" alt="/images/datastructure/tree05.png"></p><h3 id="이진-탐색-트리-Binary-Search-Tree-특징"><a href="#이진-탐색-트리-Binary-Search-Tree-특징" class="headerlink" title="이진 탐색 트리(Binary Search Tree) 특징"></a>이진 탐색 트리(Binary Search Tree) 특징</h3><p>이진 탐색 트리는 이진 트리 자료 구조로서 다음과 같은 특징을 가진다.</p><ol><li>각 노드에는 값이 존재한다.</li><li>노드의 왼쪽에는 타겟 노드 보다 작은 값들로 이루어져 있다.</li><li>노드의 오른쪽에는 타겟 노드와 같은 값이거나 큰 값들로 이루어져 있다.</li><li>좌우 하위 트리는 다시 이진 탐색 트리 여야 한다.</li></ol><h3 id="이진-탐색-트리-Binary-Search-Tree-구현"><a href="#이진-탐색-트리-Binary-Search-Tree-구현" class="headerlink" title="이진 탐색 트리(Binary Search Tree) 구현"></a>이진 탐색 트리(Binary Search Tree) 구현</h3><p>아래와 같은 데이터가 각각의 노드로 들어가 있다고 가정을 해보겠다.  </p><p><img src="/images/datastructure/tree06.png" alt="/images/datastructure/tree06.png"></p><p>위에서 설명 했듯이, 노드의 왼쪽은 타겟 노드보다 작은 값이, 오른쪽으로는 타겟의 노드보다 큰 값이 있다. 이러한 특성을 이용하여 최소값과 최대값에 쉽게 접근할 수 있다. 아래의 사진과 같이 빨간 선을 따라 자식 노드의 왼쪽으로 이동하면 최소값 5 에 접근이 가능하고, 파랑선을 따라 자식 노드의 오른쪽으로 이동하면 최대값 49 에 접근할 수 있다.</p><p><img src="/images/datastructure/tree07.png" alt="/images/datastructure/tree07.png"></p><p>그렇다면 이러한 트리에 노드를 추가하는 경우는 어떻게 될까?</p><p><img src="/images/datastructure/tree08.png" alt="/images/datastructure/tree08.png"></p><p>위에서의 규칙과 마찬가지의 규칙을 적용한다고 하면 쉽게 추가가 된다.</p><p><img src="/images/datastructure/tree09.png" alt="/images/datastructure/tree09.png"></p><p>새로운 노드 ‘4’ 를 기존의 이진 탐색 트리에 삽입을 하려고 한다. 일단 노드 4는 루트 노드 30 보다는 작은 값이라 왼쪽으로 이동시킬 것이다. 루트 노드 30 왼쪽의 자식 노드로는 15 가 있다. 이진 탐색 트리의 특징 중에는 <code>좌우 하위 트리는 다시 이진 탐색 트리여야 한다</code> 라는 것이 있다. 그렇다면 루트 노드인 30 의 하위 자식 노드 15 로 이동했을 때도 마찬가지로 이진 탐색 트리의 규칙을 따라야 한다. 4는 15보다 작은 수 이기 때문에 왼쪽으로 이동한다.</p><p><img src="/images/datastructure/tree10.png" alt="/images/datastructure/tree10.png"></p><p>Leaf Node 에 해당하는 5 에 도달했을 때, 4 는 5 보다 작으므로 마찬가지로 왼쪽으로 이동된다. 그 후에는 하위에 더 이상 자식 노드가 없기 때문에 5 의 왼쪽 자식 노드로 추가된다. </p><p><img src="/images/datastructure/tree11.png" alt="/images/datastructure/tree11.png"></p><p>삭제에 대한 기능은 하위 Leaf Node 인 경우에는 큰 문제 없이 삭제 된다. 만약 Leaf Node 인 34 를 삭제 하려고 한다면 그냥 삭제를 해주면 된다. </p><p><img src="/images/datastructure/tree12.png" alt="/images/datastructure/tree12.png"></p><p>반대로 46과 같은 하위에 자식 노드가 있더라도 깊이가 1이 넘지 않은 경우는 왼쪽 자식 노드를 위로 올리면 된다.</p><p><img src="/images/datastructure/tree13.png" alt="/images/datastructure/tree13.png"><br><img src="/images/datastructure/tree14.png" alt="/images/datastructure/tree14.png"></p><p>그렇다면 위와 같은 방법으로 삭제를 하되 조금더 복잡한 이진 탐색 트리의 구조는 어떠할까?</p><p><img src="/images/datastructure/tree15.png" alt="/images/datastructure/tree15.png"></p><p>위와 같은 구조에서 만약 중간에 껴있는 15를 삭제할 경우는 다른 것보다는 더 복잡하다. 방법은 두가지가 있다. 첫번째는 15의 왼쪽 자식 노드 중 최대값을 위로 올리는 방법이고, 두번째는 오른쪽 자식 노드 중 최소값을 위로 올리는 방법이 있다. 아래의 예제에서는 오른쪽 자식 노드의 최소값을 올리는 방식으로 진행해보겠다.</p><p><img src="/images/datastructure/tree16.png" alt="/images/datastructure/tree16.png"></p><p>삭제된 15를 기준으로 오른쪽 노드를 살펴보면 17이 있다. 그리고 그 17 아래로 최소값 노드인 15가 있다. 이 값을 지원 타겟으로 이동시키면 된다.</p><p><img src="/images/datastructure/tree17.png" alt="/images/datastructure/tree17.png"></p><p>이상으로 대략적인 이진 탐색 트리에 대해서 알아보았다.</p><hr><h2 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h2><ul><li><a href="https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%A6%AC_%EA%B5%AC%EC%A1%B0" target="_blank" rel="noopener">위키 백과-트리</a></li><li><a href="https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC" target="_blank" rel="noopener">위키 백과-이진 트리</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Tree-란-무엇인가&quot;&gt;&lt;a href=&quot;#Tree-란-무엇인가&quot; class=&quot;headerlink&quot; title=&quot;Tree 란 무엇인가?&quot;&gt;&lt;/a&gt;Tree 란 무엇인가?&lt;/h2&gt;&lt;p&gt;위키 백과에 따르면 &lt;code&gt;트리 구조 란 그래프의 일종
      
    
    </summary>
    
      <category term="Theory" scheme="http://blog.martinwork.co.kr/categories/theory/"/>
    
    
      <category term="Tree" scheme="http://blog.martinwork.co.kr/tags/tree/"/>
    
      <category term="Tree Node" scheme="http://blog.martinwork.co.kr/tags/tree-node/"/>
    
      <category term="Binary Search" scheme="http://blog.martinwork.co.kr/tags/binary-search/"/>
    
  </entry>
  
  <entry>
    <title>자료구조, 리스트(List) 와 배열(Array)</title>
    <link href="http://blog.martinwork.co.kr/theory/2018/09/22/what-is-difference-between-list-and-array.html"/>
    <id>http://blog.martinwork.co.kr/theory/2018/09/22/what-is-difference-between-list-and-array.html</id>
    <published>2018-09-21T15:50:51.000Z</published>
    <updated>2019-03-15T12:49:11.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Array-란-무엇인가"><a href="#Array-란-무엇인가" class="headerlink" title="Array 란 무엇인가?"></a>Array 란 무엇인가?</h2><p>배열이란 간단히 이야기하면 여러개의 데이터의 묶음이라고 할 수 있다. 많은 개발자들이 배열하면 굉장히 익숙하게 와닿을 수 있는 것은 어느 언어에나 있는 배열이라는 자료구조가 존재하기 때문이다. 그래서 한번이라도 사용해본 경험이 있다면 인덱스 번호로 원하는 배열에 접근하는 것을 볼 수 있을 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'Apple'</span>, <span class="string">'Banana'</span>, <span class="string">'Pineapple'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>]); <span class="comment">// Apple</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">1</span>]); <span class="comment">// Banana</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">2</span>]); <span class="comment">// Pineapple</span></span><br></pre></td></tr></table></figure><p>그래서 배열은 한 문장으로 표현한다고 한다면 <code>고유한 식별자(Index 번호) 와 그 식별자에 대응하는 데이터의 묶음</code> 으로 표현할 수 있다. 다른 한편으로는 고유한 식별자를 <code>첨자</code> 라고도 부른다.</p><h3 id="Array-의-특성"><a href="#Array-의-특성" class="headerlink" title="Array 의 특성"></a>Array 의 특성</h3><p>위에서 Javascript 코드로 봤듯 배열은 접근에 굉장히 용이하다. 데이터들이 연속된 메모리 영역에 <code>순서대로</code> 저장되기 때문이다. 그러한 연속된 저장으로 인해 인덱스 번호를 이용해서 빠르게 접근을 할 수 있다. 이 것은 <code>임의 접근(Random access)</code> 이라고 표현한다. </p><p>반대로 추가나 삭제를 해야하는 경우는 배열에서는 용이하지 않다. 위에서 설명한 예제를 가지고 데이터의 추가를 그림으로 표현한다면 아래와 같이 나온다.</p><p><img src="/images/datastructure/array01.png" alt="/images/datastructure/array01.png"></p><p>만약 새로운 배열 <code>Melon</code> 을 Apple와 Banana 사이에 추가를 하려고 하는 경우 현재는 배열의 공간이 없다. 그래서 공간을 추가를 위해 맨 마지막에 새로운 공간을 추가했다.</p><p><img src="/images/datastructure/array02.png" alt="/images/datastructure/array02.png"></p><p>그 후, Pineapple 부터해서 Banana 까지 차례로 오른쪽으로 하나씩 이동시킨다.</p><p><img src="/images/datastructure/array03.png" alt="/images/datastructure/array03.png"></p><p>그렇게 공간이 남으면 해당 공간에다가 원하는 Melon을 추가할 수 있게 된다.</p><p><img src="/images/datastructure/array04.png" alt="/images/datastructure/array04.png"></p><p>삭제 역시 위와 같이 쉽지 않다. 만약 위에서 추가한 Melon 을 다시 삭제하려고 한다면 아래와 같이 일단 먼저 Melon을 지운다.</p><p><img src="/images/datastructure/array05.png" alt="/images/datastructure/array05.png"></p><p>배열은 연속된 메모리 영역에 순서대로 저장된다는 특성 때문에 위처럼 지우고 나면 해당 공간으로 다시 데이터들을 밀어줘야 한다. </p><p><img src="/images/datastructure/array06.png" alt="/images/datastructure/array06.png"></p><p><img src="/images/datastructure/array07.png" alt="/images/datastructure/array07.png"></p><p>위처럼 다 지워주고 나면 남은 공간을 제거 해주면 된다.</p><h2 id="List-란-무엇인가"><a href="#List-란-무엇인가" class="headerlink" title="List 란 무엇인가?"></a>List 란 무엇인가?</h2><p>위키 백과에서는 같은 값이 한 번 이상 존재할 수 있는 일련의 값이 모여있는 추상적 자료형이라고 정의 하고 있다. 나와 같은 Javascript 로 개발을 처음 접한 개발자에게는 List 와 Array 에 대한 차이를 단번에 이해하기 힘들 수도 있다.(물론 필자만 그럴 수도 있고..) list 역시 array 와 마찬가지로 데이터가 일직선으로 나열되어 있는 형태로 되어 있다. 그럼 array 와의 차이점이 무엇일까? 리스트는 array 와는 다르게 <code>연속된 위치가 아닌 떨어진 영역에 저장된다는 점</code>이다. </p><p><img src="/images/datastructure/list01.png" alt="/images/datastructure/list01.png"></p><p>List 의 자료 구조는 위와 같이 생겼다. list 의 경우 pointer 라는 개념이 있는 데 이 pointer 란 <code>다음 메모리의 위치</code>를 가르키고 있다. List 를 대략적으로 알기 위해서는 보물 찾기를 생각하면 좋을 것 같다. 1번 목적지에서 다음 2번 목적지에 대한 하는 힌트 혹은 지도를 얻은 후, 2번에서는 다음 목적지를 찾는 것과 같다. 보물찾기를 해본 사람은 알겠지만 목적지에 다다르기 위해서는 차례로 1번 목적지부터 2번,3번.. n번 까지 다 거쳐서 목적지에 들려야함을 알 수 있다. 물론 당연히 1번 목적지를 거치지 않고 처음부터 2번으로 도전할 수 없듯이 말이다.</p><h3 id="List-의-특성"><a href="#List-의-특성" class="headerlink" title="List 의 특성"></a>List 의 특성</h3><p>위에서 보물찾기와 같이 설명했듯 리스트 의 경우 배열과 다르게 임의 접근(Random access) 을 할 수 없다. 리시트 의 경우에는 순차 접근 혹은 시퀀셜 엑세스(Sequential access)를 이용해야 한다. 위의 리스트의 자료 구조에 대한 이미지를 보면 알 수 있 듯 만약 사용자가 <code>Pineapple</code> 에 접근하려 한다면 Apple 을 거쳐 Banana 를 거쳐서 접근을 해야 한다. 다만 리스트의 장점은 배열과는 다르게 공간이 한정되어 있는 것이 아니라 <code>동적 자료 구조</code> 여서 시시각각 데이터의 크기가 변할 수 있으며, 추가와 삭제가 배열과 다르게 훨씬 편하게 가능하다. 배열의 경우는 위에서 봤듯 요소를 추가할 때마다 공간을 확보해서 나머지 요소를 미루는 등의 성능을 저해하는 작업들이 많지만, 리스트의 경우 포인터 만 변경해주면 된다.</p><p>만약 위에 처럼 Melon 이라는 요소를 추가해주려고 한다면 어떻게 하면 될까?</p><p><img src="/images/datastructure/list02.png" alt="/images/datastructure/list02.png"></p><p>그런 경우라면 Apple의 포인터만 바꿔주면 될 것이다. 위에서 말했듯 리스트의 포인터는 다음 메모리의 위치를 가르키고 있다.</p><p><img src="/images/datastructure/list03.png" alt="/images/datastructure/list03.png"></p><p>마찬가지로 삭제 역시 포인터만 변경해주면 된다. 만약 Banana 에 대한 요소를 제거하려고 하면 포인터만 Melon 의 포인터만 변경해주면 된다.</p><p><img src="/images/datastructure/list04.png" alt="/images/datastructure/list04.png"></p><p>Banana 의 포인터는 따로 제거할 필요가 없다. 왜냐하면 어차피 해당 데이터에 접근을 할 때는 Apple 이라는 Head 에서부터 접근을 해야하기 때문에 Banana 로 접근할 수 없기 때문이다. 또한 이 영역 역시 이후에 재사용할 때는 덮어쓰기가 되기 때문에 별도로 삭제해줄 필요 역시 없다.</p><h3 id="Array-와-List-의-각각-시간-계산"><a href="#Array-와-List-의-각각-시간-계산" class="headerlink" title="Array 와 List 의 각각 시간 계산"></a>Array 와 List 의 각각 시간 계산</h3><p>위에서처럼 Array 와 List 에는 각각의 차이점이 있다. 물론 필자와 같이 Javascript 로만 개발을 하는 경우에는 그 어떤 데이터를 선택해야 하는지에 대한 고민을 안해도 되지만 그 외의 서버 개발자에게는 아마 필요에 따라 데이터를 잘 선택하는 것이 중요하다. 아래는 Array 와 List 의 시간 계산에 대한 표이다. 아래의 표를 참고해서 상황과 목적에 맞는 데이터를 선택해서 사용하길 바란다.</p><table><thead><tr><th>Type</th><th>Read</th><th>Write/Update/Delete</th></tr></thead><tbody><tr><td><strong>Array</strong></td><td>O(1)</td><td>O(n)</td></tr><tr><td><strong>List</strong></td><td>O(n)</td><td>O(1)</td></tr></tbody></table><hr><h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h3><p><a href="https://ko.wikipedia.org/wiki/%EB%A6%AC%EC%8A%A4%ED%8A%B8_(%EC%BB%B4%ED%93%A8%ED%8C%85" target="_blank" rel="noopener">위키백과</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Array-란-무엇인가&quot;&gt;&lt;a href=&quot;#Array-란-무엇인가&quot; class=&quot;headerlink&quot; title=&quot;Array 란 무엇인가?&quot;&gt;&lt;/a&gt;Array 란 무엇인가?&lt;/h2&gt;&lt;p&gt;배열이란 간단히 이야기하면 여러개의 데이터의 묶음이
      
    
    </summary>
    
      <category term="Theory" scheme="http://blog.martinwork.co.kr/categories/theory/"/>
    
    
      <category term="List" scheme="http://blog.martinwork.co.kr/tags/list/"/>
    
      <category term="Array" scheme="http://blog.martinwork.co.kr/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>자료구조, 해쉬 테이블(Hash table)</title>
    <link href="http://blog.martinwork.co.kr/theory/2018/09/22/what-is-hashtable.html"/>
    <id>http://blog.martinwork.co.kr/theory/2018/09/22/what-is-hashtable.html</id>
    <published>2018-09-21T15:50:51.000Z</published>
    <updated>2019-03-15T12:49:11.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hash-table-란-무엇인가"><a href="#Hash-table-란-무엇인가" class="headerlink" title="Hash table 란 무엇인가?"></a>Hash table 란 무엇인가?</h2><p>해쉬 테이블은 자료 구조 중 제일 중요하다고 손꼽힐 정도로 기본적이면서도 실제 실무에서도 자주 쓰이는 자료 구조 중 하나이다. 가장 쉽게 표현할 수 있는 예제가 도서관에서의 책장을 표현할 수 있다. 총 9 칸으로 이뤄진 책장이라고 생각을 했을 때, 만약 도서관 사서 라면 책을 어떻게 구분을 할 수 있을까? 아마도 필자라면 ㄱ으로 시작하면 첫번째칸, ㄷ으로 시작하면 3번째칸 과 같은 규칙으로 한글 자음 순서대로 구분을 할 것이다.</p><p><img src="/images/datastructure/hashmap01.png" alt="/images/datastructure/hashmap01.png"></p><p>이렇게 분류를 하게 되면 새로 추가를 할 때도 혹은 책을 찾을 때도 정해진 규칙대로 찾을 수 있어 쉬워질 것이다. 이처럼 해시 테이블은 <code>데이터 검색을 효율적</code>으로 하기 위해 사용되는 자료 구조이다.</p><h2 id="Hash-table-의-구조"><a href="#Hash-table-의-구조" class="headerlink" title="Hash table 의 구조"></a>Hash table 의 구조</h2><p>해쉬 테이블은 키(key)와 값(value)이 한 쌍이 되는 데이터들의 집합체이다. 해쉬 테이블 은 아래의 사진과 같이 데이터를 hash function 을 통해 해싱을 한 후, 배열 안에 저장을 하는 형태이다.</p><p><img src="/images/datastructure/hashmap02.png" alt="/images/datastructure/hashmap02.png"></p><p>위에서 배열 안에 저장을 하려면 미리 배열의 크기가 지정이 되어있어야 한다. 다른 한편으로는 해시 테이블의 성능은 공간을 팔아 얻어낸 성능이라