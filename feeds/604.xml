<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Yoo Young-mo on Medium]]></title>
        <description><![CDATA[Stories by Yoo Young-mo on Medium]]></description>
        <link>https://medium.com/@SlackBeck?source=rss-dd736b47f7d7------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*aItDUYmkuRWP79UUsgHSbQ.jpeg</url>
            <title>Stories by Yoo Young-mo on Medium</title>
            <link>https://medium.com/@SlackBeck?source=rss-dd736b47f7d7------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Tue, 14 May 2019 11:03:19 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@SlackBeck" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[REST 기반의 간단한 분산 트랜잭션 구현 — 1편]]></title>
            <link>https://medium.com/@SlackBeck/rest-%EA%B8%B0%EB%B0%98%EC%9D%98-%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B5%AC%ED%98%84-1%ED%8E%B8-a9bde62f4365?source=rss-dd736b47f7d7------2</link>
            <guid isPermaLink="false">https://medium.com/p/a9bde62f4365</guid>
            <category><![CDATA[microservices]]></category>
            <category><![CDATA[spring]]></category>
            <category><![CDATA[tcc]]></category>
            <category><![CDATA[rest]]></category>
            <category><![CDATA[trasnsacion]]></category>
            <dc:creator><![CDATA[Yoo Young-mo]]></dc:creator>
            <pubDate>Tue, 14 May 2019 04:14:11 GMT</pubDate>
            <atom:updated>2019-05-14T04:14:11.559Z</atom:updated>
            <content:encoded><![CDATA[<h3>REST 기반의 간단한 분산 트랜잭션 구현 — 1편</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*6xVxAsqdge0xHRyh.png" /></figure><ul><li><strong>REST 기반의 간단한 분산 트랜잭션 구현 -1편 TCC 개관</strong></li><li><a href="https://www.popit.kr/rest-%EA%B8%B0%EB%B0%98%EC%9D%98-%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B5%AC%ED%98%84-2%ED%8E%B8-tcc-cancel-timeout/">REST 기반의 간단한 분산 트랜잭션 구현 — 2편 TCC Cancel, Timeout</a></li><li><a href="https://www.popit.kr/rest-%EA%B8%B0%EB%B0%98%EC%9D%98-%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B5%AC%ED%98%84-3%ED%8E%B8-tcc-confirmeventual-consistency/">REST 기반의 간단한 분산 트랜잭션 구현 — 3편 TCC Confirm(Eventual Consistency)</a></li><li><a href="https://www.popit.kr/rest-%EA%B8%B0%EB%B0%98%EC%9D%98-%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B5%AC%ED%98%84-4%ED%8E%B8-rest-retry/">REST 기반의 간단한 분산 트랜잭션 구현 — 4편 REST Retry</a></li></ul><p><a href="https://www.popit.kr/author/tony/">안영회</a> 님은 <a href="http://www.popit.kr/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B3%B5%EB%B6%80%ED%95%98%EA%B2%8C-%EC%B1%85-%ED%95%98%EB%82%98-%EC%B6%94%EC%B2%9C%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94/">마이크로 서비스 공부하게 책 하나 추천해주세요</a> 글에서 마이크로 서비스 간 일관성을 유지하는 방법 중 하나로 TCCTry-Confirm/Cancel를 언급했다.</p><blockquote>How to become eventually consistent.</blockquote><blockquote>오호… 지옥(?)에 오신 것을 환영한다. 내 모듈에 처리된 내용이 다른 모듈과 일관성을 유지하려면 어떻게 해야 하나? 알려진 방법으로 <a href="https://dzone.com/articles/transactions-for-the-rest-of-us">TCC<strong>Try-Confirm/Cancel </strong></a>같은 것이 있고, <a href="http://microservices.io/">크리스 리차드슨</a>처럼 상태를 데이터로 저장하지 않고, 이벤트를 저장하는 방법이 있다. 방법은 설명할 수 없으니 왜 이렇게 하는지만 간단히 설명해본다. 여러분이 여행자를 위한 앱을 만든다 생각해보자. 항공권과 렌트카 혹은 호텔까지 묶어서 예약을 해주고 싶다. 항공사와 연결하고, 렌트카 시스템과 연결하고, 호텔 시스템과 연결해야 한다. 이들을 모두 데이터베이스 트랜잭션<strong>Transcation</strong>으로 처리할 수는 없다.[6]</blockquote><p>이 글은 필자가 스프링 부트Spring Boot로 TCC를 구현해 본 것으로 부제를 달자면 ‘스프링 부트로 구현하는 TCC’이다.</p><p>TCC 이외에 이벤트를 사용하여 구현하는 방법은 <a href="https://www.popit.kr/author/babokim/">김형준</a> 님의 글 <a href="https://www.popit.kr/%EB%8C%80%EC%9A%A9%EB%9F%89-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EA%B7%B8%EB%9F%AD%EC%A0%80%EB%9F%AD-%EB%8F%8C%EC%95%84%EA%B0%80%EB%8A%94-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%A7%8C%EB%93%A4%EA%B8%B0/">대용량 환경에서 그럭저럭 돌아가는 서비스 만들기</a>에 일부가 나와 있으니 참고하길 바란다.</p><h3>나의 REST 시스템 시나리오</h3><p>마이크로 서비스로 만들어진 온라인 쇼핑몰에서 아래와 같은 순서로 주문이 처리된다고 가정해보자.[1]</p><ul><li>1 단계 : 클라이언트는 주문 서비스(OrderService)에 주문을 요청한다.</li><li>2 단계 : 주문 서비스는 재고 서비스(StockService)에 재고 차감을 요청한다.</li><li>3 단계 : 주문 서비스는 결제 서비스(PaymentService)에 결제 요청한다.</li><li>4 단계 : 주문 서비스는 구매 주문을 생성한다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/911/0*AUQeIi_3K-XBMCbU.png" /></figure><p>주문을 처리하는 과정에서 재고를 차감(2단계)하고 결제 처리(3단계)는 성공했지만 구매 주문 생성(4단계)하다가 실패했다면 어떻게 될까? 모두 롤백Rollback 되지 않으면 일관성이 깨지고 만다.</p><p>분산 형태로 처리되는 주문 처리 단계가 모두 성공하거나 하나라도 실패하게 된다면 모두 롤백 되어야 한다(all-or-nothing). 주문처리 단계에 대해 흔히 말하는 트랜잭션[2] 처리에 대한 보장이 필요하다.</p><h3>데이터베이스 트랜잭션의 한계</h3><p>모노리틱 아키텍처Monolithic Architecture에서는 일반적으로 데이터베이스 트랜잭션에 의존한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/717/0*MzuOoJDo94r0HK02.png" /><figcaption>출처 : <a href="http://microservices.io/patterns/monolithic.html">http://microservices.io/patterns/monolithic.html</a></figcaption></figure><p>하지만 마이크로 서비스의 경우 각 서비스마다 다른 데이터베이스를 사용하는 것이 일반적이고 이를 하나의 데이터 베이스 트랜잭션으로 처리하는 것은 기술적으로 어렵고(이 기종 데이터베이스일 수도 있고) 처리한다 해도 긴 트랜잭션(long trasaction)이 발생하기 때문에 효용도 적다.[3]</p><h3>TCCTry-Confirm/Cancel</h3><p>TCC는 <a href="https://dzone.com/">DZone</a>에 올라온 <a href="https://dzone.com/articles/transactions-for-the-rest-of-us">Transactions for the REST of Us</a> 글에서 나온 것으로 분산된 REST 시스템들 간의 트랜잭션을 HTTP와 REST 원칙으로 접근하여 해결하는 방법이다.</p><p>관계형 데이터베이스 경우 SQL 트랜잭션 구문을 사용하여 트랜잭션을 제어한다.</p><pre>START TRANSACTION;<br>SELECT @A:=SUM(salary) FROM table1 WHERE type=1;<br>UPDATE table2 SET summary=@A WHERE type=1;<br>COMMIT;</pre><p>START TRANSACTION 키워드로 트랜잭션을 시작하고 정상적으로 작업이 끝나는 경우 COMMIT 키워드를 그렇지 않은 경우 ROLLBACK 키워드를 사용한다.</p><p>TCC에서 트랜잭션을 제어하는 방법은 관계형 데이터베이스에서 트랜잭션을 제어하는 방법과 유사하다.</p><p>앞서 ‘나의 REST 시스템 시나리오’에서 주문 처리를 TCC 방식으로 변경하게 되면 아래처럼 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/950/0*nprXd-AKSriyYFQt.png" /></figure><p>REST API 호출(2단계, 3단계)은 한 번에 끝내는 것이 아니라 2번(Try, Confirm)에 걸쳐 하게 된다.</p><p>트랜잭션의 all-or-nothing을 TCC는 REST API를 호출을 시도(Try)하고 전부 확정(Confirm)하거나 전부 취소(Cancel) 하는 것으로 구현한다.</p><p>본격적으로 코드를 보자.</p><h3>TCC REST API Consumer : OrderService</h3><p>API Consumer인 OrderService는 placeOrder 메서드로 주문을 처리한다. 여기가 바로 트랜잭션 지점이다.</p><p>다른 서비스(StockService, PaymentService)와의 TCC REST 커뮤니케이션 책임은 TccRestAdapter가 가진다.</p><p>먼저 TccRestAdapter로 재고 차감과 결제 요청을 Try하고 오류가 없는 경우 Confirm 요청한다.</p><pre>@Service<br><strong>public</strong> <strong>class</strong> <strong>OrderServiceImpl</strong> <strong>implements</strong> <strong>OrderService</strong> {<br>    <strong>private</strong> TccRestAdapter tccRestAdapter;<br>    @Autowired<br>    <strong>public</strong> <strong>void</strong> <strong>setTccRestAdapter</strong>(TccRestAdapter tccRestAdapter) {<br>        <strong>this</strong>.tccRestAdapter = tccRestAdapter;<br>    }<br>    @Override<br>    <strong>public</strong> <strong>void</strong> <strong>placeOrder</strong>(<strong>final</strong> Order order) {<br>        // 재고 차감(Try)<br>        ParticipantLink stockParticipantLink = reduceStock(order);<br>        // 결제 요청(Try)<br>        ParticipantLink paymentParticipantLink = payOrder(order);<br>        // ...<br>        // 확정(Confirm)<br>        tccRestAdapter.confirmAll(stockParticipantLink.getUri(), paymentParticipantLink.getUri());<br>    }<br>    <strong>private</strong> ParticipantLink <strong>reduceStock</strong>(<strong>final</strong> Order order) {<br>        <strong>final</strong> String requestURL = &quot;http://localhost:8081/api/v1/stocks&quot;;<br>        Map&lt;String, Object&gt; requestBody = <strong>new</strong> HashMap&lt;&gt;();<br>        requestBody.put(&quot;adjustmentType&quot;, &quot;REDUCE&quot;);<br>        requestBody.put(&quot;productId&quot;, order.getProductId());<br>        requestBody.put(&quot;qty&quot;, order.getQty());<br>        <strong>return</strong> tccRestAdapter.doTry(requestURL, requestBody);<br>    }<br>    <strong>private</strong> ParticipantLink <strong>payOrder</strong>(<strong>final</strong> Order order) {<br>        <strong>final</strong> String requestURL = &quot;http://localhost:8082/api/v1/payments&quot;;<br>        Map&lt;String, Object&gt; requestBody = <strong>new</strong> HashMap&lt;&gt;();<br>        requestBody.put(&quot;orderId&quot;, order.getOrderId());<br>        requestBody.put(&quot;paymentAmt&quot;, order.getPaymentAmt());<br>        <strong>return</strong> tccRestAdapter.doTry(requestURL, requestBody);<br>    }<br>}</pre><p>TCC REST 커뮤니케이션을 HTTP 관점에서 상세하게 표현하면 아래와 같다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/994/0*L_l16V0IW5RdFodN.png" /></figure><p>TccRestAdapter doTry 메서드는 Spring <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html">RestTemplate</a>을 사용하여 HTTP 요청(POST)을 한다.</p><pre>@Component<br><strong>public</strong> <strong>class</strong> <strong>TccRestAdapterImpl</strong> <strong>implements</strong> <strong>TccRestAdapter</strong> {<br>    <strong>private</strong> RestTemplate restTemplate = <strong>new</strong> RestTemplate();<br>    @Override<br>    <strong>public</strong> ParticipantLink <strong>doTry</strong>(<strong>final</strong> String requestURL, <strong>final</strong> Map&lt;String, Object&gt; requestBody) {<br>        HttpHeaders headers = <strong>new</strong> HttpHeaders();<br>        headers.setContentType(MediaType.APPLICATION_JSON);<br>        ResponseEntity&lt;ParticipantLink&gt; response = restTemplate.postForEntity(requestURL, <strong>new</strong> HttpEntity(requestBody, headers), ParticipantLink.class);<br>        <strong>if</strong>(response.getStatusCode() != HttpStatus.CREATED) {<br>            <strong>throw</strong> <strong>new</strong> RuntimeException(String.format(&quot;TRY Error[URI : %s][HTTP Status : %s]&quot;,<br>                    requestURL, response.getStatusCode().name()));<br>        }<br>        <strong>return</strong> response.getBody();<br>    }<br>    //...<br>}</pre><p>Try 요청의 경우 정상적인 HTTP 응답(HttpStatus.CREATED) 받으면 HTTP BODY에는 JSON 형태로 Confirm 하거나 Cancel할 수 있는 URI이 담겨 있다. 이를 ParticipantLink로 변환하여 반환한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*qqgWzYICHB13Ct0A.png" /></figure><pre><strong>public</strong> <strong>class</strong> <strong>ParticipantLink</strong> {<br>    <strong>private</strong> URI uri;<br>    <strong>private</strong> Date expires;<br>    // ...<br>}</pre><p>TccRestAdapter confirmAll 메서드는 Try 요청 시 받았던 ParticipantLink의 URI로 Confirm HTTP 요청(PUT)을 한다.</p><pre>@Component<br><strong>public</strong> <strong>class</strong> <strong>TccRestAdapterImpl</strong> <strong>implements</strong> <strong>TccRestAdapter</strong> {<br>    <strong>private</strong> RestTemplate restTemplate = <strong>new</strong> RestTemplate();<br>    @Override<br>    <strong>public</strong> <strong>void</strong> <strong>confirmAll</strong>(<strong>final</strong> URI... uris) {<br>        <strong>for</strong> (URI uri : uris) {<br>            <strong>try</strong> {<br>                restTemplate.put(uri, <strong>null</strong>);<br>            } <strong>catch</strong> (RestClientException e) {<br>                cancelAll(uris);<br>                <strong>throw</strong> <strong>new</strong> RuntimeException(String.format(&quot;Confirm Error[URI : %s]&quot;,<br>                        uri.toString()), e);<br>            }<br>        }<br>    }<br>    //...<br>}</pre><h3>TCC REST API Provider : StockService/PaymentService</h3><p>StockService를 대표로 API Provider 입장에서 TCC 처리 과정을 살펴보자.</p><h3>TCC — Try</h3><p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html">Spring Rest Controller</a>를 사용하여 HTTP POST Method와 연결하였다. Controller는 Spring Service로 처리를 위임한다.</p><p>Spring Service에서 반환받은 ReservedStock의 id를 사용하여 Confirm 하거나 Cancel할 수 있는 URI을 만들고(buildParticipantLink) 이를 HTTP 응답 BODY로 반환 한다.</p><p>여기서 중요한 것은 실제로 재고를 차감하는 것이 아니라는 점이다. 재고 차감은 API Consumer가 Confirm 요청 시 처리 된다.</p><pre>@RestController<br>@RequestMapping(&quot;/api/v1/stocks&quot;)<br><strong>public</strong> <strong>class</strong> <strong>StockRestController</strong> {<br>    <strong>private</strong> StockService stockService;<br>    @Autowired<br>    <strong>public</strong> <strong>void</strong> <strong>setStockService</strong>(StockService stockService) {<br>        <strong>this</strong>.stockService = stockService;<br>    }<br>    @PostMapping<br>    <strong>public</strong> ResponseEntity&lt;ParticipantLink&gt; <strong>tryStockAdjustment</strong>(@RequestBody StockAdjustment stockAdjustment) {<br>        <strong>final</strong> ReservedStock reservedStock = stockService.reserveStock(stockAdjustment);<br>        <strong>final</strong> ParticipantLink participantLink = buildParticipantLink(reservedStock.getId(), reservedStock.getCreated());<br>        <strong>return</strong> <strong>new</strong> ResponseEntity&lt;&gt;(participantLink, HttpStatus.CREATED);<br>    }<br>    <strong>private</strong> ParticipantLink <strong>buildParticipantLink</strong>(<strong>final</strong> Long id, <strong>final</strong> Date created) {<br>        URI location = ServletUriComponentsBuilder.fromCurrentRequest().path(&quot;/{id}&quot;).buildAndExpand(id).toUri();<br>        <strong>final</strong> <strong>long</strong> expires = created.getTime() + TIMEOUT;<br>        <strong>return</strong> <strong>new</strong> ParticipantLink(location, <strong>new</strong> Date(expires));<br>    }<br>    // ...<br>}</pre><p>Spring Service의 reserveStock 메서드는 StockAdjustment을 생성자로 전달하여 ReservedStock 엔티티를 생성하고 JPAJava Persistence API를 사용하여 데이터베이스에 저장한다.</p><pre>@Service<br><strong>public</strong> <strong>class</strong> <strong>StockServiceImpl</strong> <strong>implements</strong> <strong>StockService</strong> {<br>    <strong>private</strong> ReservedStockRepository reservedStockRepository;<br>    @Autowired<br>    <strong>public</strong> <strong>void</strong> <strong>setReservedStockRepository</strong>(ReservedStockRepository reservedStockRepository) {<br>        <strong>this</strong>.reservedStockRepository = reservedStockRepository;<br>    }<br>    @Override<br>    <strong>public</strong> ReservedStock <strong>reserveStock</strong>(<strong>final</strong> StockAdjustment stockAdjustment) {<br>        ReservedStock reservedStock = <strong>new</strong> ReservedStock(stockAdjustment);<br>        reservedStockRepository.save(reservedStock);<br>        log.info(&quot;Reserved Stock :&quot; + reservedStock.getId());<br>        <strong>return</strong> reservedStock;<br>    }<br>    // ...<br>}</pre><pre><strong>public</strong> <strong>interface</strong> <strong>ReservedStockRepository</strong> <strong>extends</strong> <strong>JpaRepository</strong>&lt;<strong>ReservedStock</strong>, <strong>Long</strong>&gt; {<br>}</pre><p>ReservedStock은 Try 시 요청 내용(HTTP Request Body)을 JSON 문자열로 직렬화하여 resources에 필드에 저장한다.[4]</p><pre>@Entity<br><strong>public</strong> <strong>class</strong> <strong>ReservedStock</strong> {<br>    @Id<br>    @GeneratedValue(strategy = GenerationType.AUTO)<br>    <strong>private</strong> Long id;<br>    <strong>private</strong> String resources;<br>    @Enumerated(EnumType.STRING)<br>    <strong>private</strong> Status status;<br>    @Temporal(TemporalType.TIMESTAMP)<br>    <strong>private</strong> Date created;<br>    <strong>public</strong> <strong>ReservedStock</strong>() {<br>    }<br>    <strong>public</strong> <strong>ReservedStock</strong>(StockAdjustment stockAdjustment) {<br>        ObjectMapper objectMapper = <strong>new</strong> ObjectMapper();<br>        <strong>try</strong> {<br>            <strong>this</strong>.resources = objectMapper.writeValueAsString(stockAdjustment);<br>        } <strong>catch</strong> (JsonProcessingException e) {<br>            e.printStackTrace();<br>        }<br>        <strong>this</strong>.created = <strong>new</strong> Date();<br>    }<br>    <strong>public</strong> StockAdjustment <strong>getResources</strong>() {<br>        ObjectMapper objectMapper = <strong>new</strong> ObjectMapper();<br>        <strong>try</strong> {<br>            <strong>return</strong> objectMapper.readValue(<strong>this</strong>.resources, StockAdjustment.class);<br>        } <strong>catch</strong> (IOException e) {<br>            e.printStackTrace();<br>            <strong>return</strong> <strong>null</strong>;<br>        }<br>    }<br>    // ...<br>}</pre><p>Try 처리가 끝나면 데이터베이스에는 아래처럼 저장 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*p49RiABj_q_N6YCh.png" /></figure><p>이렇게 저장된 데이터의 id는 ParticipantLink의 URI로 API Consumer에게 전달된다.</p><p>그리고 API Consumer가 Confirm 요청 시에 id를 이용하여 Try 시 요청했던 데이터를 조회 후 실제 재고 차감을 처리하게 된다.</p><h3>TCC — Confirm</h3><p>Spring Controller에서는 @PutMapping을 사용하여 HTTP PUT Method를 연결하였다. PathVariable로 id를 매개변수로 받아 처리를 Spring Service로 위임한다.</p><pre>@RestController<br>@RequestMapping(&quot;/api/v1/stocks&quot;)<br><strong>public</strong> <strong>class</strong> <strong>StockRestController</strong> {<br>    <strong>private</strong> StockService stockService;<br>    @Autowired<br>    <strong>public</strong> <strong>void</strong> <strong>setStockService</strong>(StockService stockService) {<br>        <strong>this</strong>.stockService = stockService;<br>    }<br>    @PutMapping(&quot;/{id}&quot;)<br>    <strong>public</strong> ResponseEntity&lt;Void&gt; <strong>confirmStockAdjustment</strong>(@PathVariable Long id) {<br>        <strong>try</strong> {<br>            stockService.confirmStock(id);<br>        } <strong>catch</strong>(IllegalArgumentException e) {<br>            <strong>return</strong> <strong>new</strong> ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);<br>        }<br>        <strong>return</strong> <strong>new</strong> ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT);<br>    }<br>}</pre><p>Spring Service는 id를 사용하여 Try시 저장된 ReservedStock을 조회한다.</p><p>ReservedStock의 resources 필드(JSON 문자열)를 역직렬화(reservedStock.getResources())) 하고 이를 사용하여 실제로 재고 차감 처리를 한다.</p><p>마지막으로 재처리 되지 않도록 ReservedStock 상태를 변경한다.</p><pre>@Service<br><strong>public</strong> <strong>class</strong> <strong>StockServiceImpl</strong> <strong>implements</strong> <strong>StockService</strong> {<br>    <strong>private</strong> ReservedStockRepository reservedStockRepository;<br>    <strong>private</strong> StockRepository stockRepository;<br>    @Autowired<br>    <strong>public</strong> <strong>void</strong> <strong>setReservedStockRepository</strong>(ReservedStockRepository reservedStockRepository) {<br>        <strong>this</strong>.reservedStockRepository = reservedStockRepository;<br>    }<br>    @Autowired<br>    <strong>public</strong> <strong>void</strong> <strong>setStockRepository</strong>(StockRepository stockRepository) {<br>        <strong>this</strong>.stockRepository = stockRepository;<br>    }<br>    @Transactional<br>    @Override<br>    <strong>public</strong> <strong>void</strong> <strong>confirmStock</strong>(Long id) {<br>        ReservedStock reservedStock = reservedStockRepository.findOne(id);<br>        validateReservedStock(reservedStock);<br>        <strong>if</strong>(reservedStock.getResources().getAdjustmentType().equals(&quot;REDUCE&quot;)) {<br>            // 상품 재고 조회<br>            Stock stock = stockRepository.findByProductId(reservedStock.getResources().getProductId());<br>            // 재고 차감<br>            stock.decrease(reservedStock.getResources().getQty());<br>            stockRepository.save(stock);<br>        }<br>        // ReservedStock 상태 변경<br>        reservedStock.setStatus(Status.CONFIRMED);<br>        reservedStockRepository.save(reservedStock);<br>        log.info(&quot;Confirm Stock :&quot; + id);<br>    }<br>    // ...<br>}</pre><p>Confirm 처리가 끝나면 최종적으로 데이터베이스에는 아래와 같이 저장된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*xAZnnTKUIZITFuvm.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/578/0*1Ao_gEGMUF5QhO1L.png" /></figure><h3>마치며</h3><p>이번 글은 TCC 개념과 기본적인 흐름에 대해 다루었다. TCC를 적용하다 보면 예외적으로 아래와 같은 상황이 발생할 수 있다.</p><ul><li>Try 후 Confirm 하기 전에 실패하는 경우</li><li>Confirm 중 실패하는 경우</li></ul><p>다음 글에서는 이런 상황에 대해 다룬다.</p><h3>GitHub</h3><p>전체 코드는 필자의 <a href="https://github.com/YooYoungmo/article-tcc">GitHub 저장소</a>에서 확인할 수 있다.</p><h3>주석</h3><p>[1] 실무에서는 훨씬 많은 단계가 있다. 이 글에서는 이해를 돕기 위해 간단하게 표현 하였다.</p><p>[2] (소프트웨어) 트랜잭션은 다음과 같은 ACID 속성을 가진다.</p><blockquote>원자성Atomicity : 트랜잭션의 경계 안에서 수행되는 각 작업의 단계는 모두 성공적으로 완료되거나 롤백돼야 한다. 부분 완료는 트랜잭션의 개념이 아니다.</blockquote><blockquote>일관성Consistency : 시스템의 자원은 트랙잭션의 시작과 완료 시점에 모두 일관성 있고 손상되지 않은 상태여야 한다.</blockquote><blockquote>격리성Isolcation : 개별 트랜잭션의 결과는 트랙잰션이 성공적으로 커밋하기 전까지 다른 열려 있는 트랙잭션에서 볼 수 없어야 한다.</blockquote><blockquote>지속성Durability : 커밋된 트랜잭션의 결과는 영구적이어야 한다.</blockquote><blockquote>출처 : <a href="https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420">Patterns of Enterprise Application Architecture</a></blockquote><p>[3] <em>처리량을 극대화하기 위해 최신 트랜잭션 시스템은 트랜잭션을 최대한 짧게 유지하도록 설계된다. 따라서 여러 요청에 걸친 트랜잭션을 만들지 말아야 한다. — </em><a href="https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420"><em>Patterns of Enterprise Application Architecture</em></a></p><p>[4] JSON의 경우 데이터 구조가 중첩 될 수 있으며 가변적이기 때문이다.</p><h3>이어지는 글</h3><ul><li><a href="https://www.popit.kr/rest-%EA%B8%B0%EB%B0%98%EC%9D%98-%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B5%AC%ED%98%84-2%ED%8E%B8-tcc-cancel-timeout/">REST 기반의 간단한 분산 트랜잭션 구현 — 2편 TCC Cancel, Timeout</a></li></ul><h3>참고 자료</h3><ul><li><a href="https://dzone.com/articles/transactions-for-the-rest-of-us">https://dzone.com/articles/transactions-for-the-rest-of-us</a></li><li><a href="http://www.inf.usi.ch/faculty/pautasso/talks/2012/soa-cloud-rest-tcc/rest-tcc.html#/title">http://www.inf.usi.ch/faculty/pautasso/talks/2012/soa-cloud-rest-tcc/rest-tcc.html#/title</a></li><li><a href="http://www.enterpriseintegrationpatterns.com/patterns/conversation/TryConfirmCancel.html">http://www.enterpriseintegrationpatterns.com/patterns/conversation/TryConfirmCancel.html</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a9bde62f4365" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[IntelliJ에서 코드 한 줄 안 짜고 JPQL 실행하기]]></title>
            <link>https://medium.com/@SlackBeck/intellij%EC%97%90%EC%84%9C-%EC%BD%94%EB%93%9C-%ED%95%9C-%EC%A4%84-%EC%95%88-%EC%A7%9C%EA%B3%A0-jpql-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0-44629ff0179f?source=rss-dd736b47f7d7------2</link>
            <guid isPermaLink="false">https://medium.com/p/44629ff0179f</guid>
            <category><![CDATA[hibernate]]></category>
            <category><![CDATA[intellij]]></category>
            <category><![CDATA[jpql]]></category>
            <category><![CDATA[jpa]]></category>
            <category><![CDATA[java]]></category>
            <dc:creator><![CDATA[Yoo Young-mo]]></dc:creator>
            <pubDate>Sat, 16 Mar 2019 05:31:06 GMT</pubDate>
            <atom:updated>2019-03-16T05:31:06.751Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*P02YQ_78OgRpJyia.png" /></figure><p>관계형 데이터베이스를 사용하는 애플리케이션을 개발할 때 <a href="https://en.wikipedia.org/wiki/SQL">SQLStructured Query Language</a>을 짜는 것은 피할 수 없는 일이다. Java 표준 <a href="https://en.wikipedia.org/wiki/Object-relational_mapping">ORMObject-Relational Mapping</a>인 <a href="https://en.wikipedia.org/wiki/Java_Persistence_API">JPAJava Persistence API</a>의 경우에도 다양한 조회를 위한 <a href="https://en.wikipedia.org/wiki/Java_Persistence_Query_Language">JPQLJava Persistence Query Language</a>를 정의하고 있다.</p><p>SQL 경우 데이터베이스 클라이언트 도구로 실행하고 결과를 확인할 수 있어서 애플리케이션 코드에서 SQL만 떼어 검증하기 쉽다. 반면 JPQL은 JPQL만 따로 떼어 실행하고 결과를 확인할 수 있는 도구를 찾기가 쉽지가 않다.[1]</p><p>Java IDEIntegrated Development Environment 중 하나인 <a href="https://www.jetbrains.com/idea/">IntelliJ(Ultimate)</a>는 JPQL만 따로 실행 가능한 <a href="https://www.jetbrains.com/help/idea/jpa-console-tool-window.html">JPA Console</a>을 10 버전부터 지원하고 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*XTUibkY08iI2X1tf.png" /></figure><p>이 글은 JPA Console에서 JPQL을 실행하는 방법을 소개한다.</p><h3>1 단계 — 예제 프로젝트 준비</h3><p>JPA Console을 시작하기 앞서 먼저 JPA를 사용하는 프로젝트가 필요하다.</p><p>요즘은 JPA만 단독으로 사용하는 경우보다는 Spring Boot + Spring Data JPA로 많이 사용 있기 때문에 예제 프로젝트를 Spring Data JPA GETTING STARTED 페이지(<a href="https://spring.io/guides/gs/accessing-data-jpa/">Accessing Data with JPA</a>)에서 가져왔다.</p><p>Spring Data JPA가 익숙하지 않은 분은 따라 하면서 프로젝트를 구성해도 되고 이미 익숙한 분은 필자의 <a href="https://github.com/YooYoungmo/article-intellij-jpa-console">GitHub</a>에서 체크아웃 받아도 된다.</p><p>예제 프로젝트는 살펴보면, 별도 데이터베이스 설치가 필요 없는 <a href="http://www.h2database.com/html/main.html">H2 데이터베이스</a>와 JPA 구현체로는 <a href="http://hibernate.org/">Hibernate</a>를 사용하고 있다. 그리고 애플리케이션 실행 시 Customer 엔티티로 데이터를 생성하고 있다.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;<br>    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;<br>    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;<br>    &lt;parent&gt;<br>        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;<br>        &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;<br>    &lt;/parent&gt;<br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.h2database&lt;/groupId&gt;<br>            &lt;artifactId&gt;h2&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        // ...<br>    &lt;/dependencies&gt;<br>    // ...<br>&lt;/project&gt;</pre><pre>@Entity<br><strong>public</strong> <strong>class</strong> <strong>Customer</strong> {<br>    @Id<br>    @GeneratedValue(strategy=GenerationType.AUTO)<br>    <strong>private</strong> Long id;<br>    <strong>private</strong> String firstName;<br>    <strong>private</strong> String lastName;<br>    //...<br>}</pre><pre>@SpringBootApplication<br><strong>public</strong> <strong>class</strong> <strong>Application</strong> {<br>    // ...<br>    @Bean<br>    <strong>public</strong> CommandLineRunner <strong>demo</strong>(CustomerRepository repository) {<br>        <strong>return</strong> (args) -&gt; {<br>            // save a couple of customers<br>            repository.save(<strong>new</strong> Customer(&quot;Jack&quot;, &quot;Bauer&quot;));<br>            repository.save(<strong>new</strong> Customer(&quot;Chloe&quot;, &quot;O&#39;Brian&quot;));<br>            repository.save(<strong>new</strong> Customer(&quot;Kim&quot;, &quot;Bauer&quot;));<br>            repository.save(<strong>new</strong> Customer(&quot;David&quot;, &quot;Palmer&quot;));<br>            repository.save(<strong>new</strong> Customer(&quot;Michelle&quot;, &quot;Dessler&quot;));<br>            // ...<br>        };<br>    }<br>}</pre><p><a href="https://spring.io/guides/gs/accessing-data-jpa/">Accessing Data with JPA</a> 코드를 그대로 사용할 경우 애플리케이션 실행이 끝나는 시점에 데이터베이스에 있던 데이터가 다 없어지기 때문에 필자는 이를 방지하기 위해 application.properties를 추가하였다.</p><p>(spring.jpa.hibernate.naming.physical-strategy는 마지막에 따로 설명할 예정이므로. 지금은 설명하지 않고 넘어간다)</p><pre># H2 file 모드를 사용한다<br>spring.datasource.url=jdbc:h2:~/test<br>spring.jpa.hibernate.ddl-auto=create<br>spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl</pre><p>애플리케이션 실행 후에 데이터베이스 테이블을 조회해 보면 5건의 데이터가 생성된 것을 확인할 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*dzygxUmmn0RbaVeQ.png" /></figure><h3>2 단계 — IntelliJ 설정</h3><p>이제 만들어진 프로젝트에서 JPA Console을 사용하기 위한 설정을 해보자.</p><p>1 Database 창를 연다(View|Tools Windows|Database)</p><p>2 Datasource를 추가한다.(H2 데이터베이스)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/510/0*mBfXzF46WnF-EuYi.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*t1ilCQdZymCj2kh4.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/586/0*5CSW9PCZsMRv7uyF.png" /></figure><p>3 Project Structure 창을 연다(File|Project Structure)</p><p>4 JPA Module을 추가한다</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*AwkAVodpBX_-qWrh.png" /></figure><p>5 Persistence 창을 연다(View|Tools Windows|Persistence)</p><p>6 Datasource를 할당한다</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/571/0*UjxK7f70E3KCoHUc.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/566/0*TTMFxfxGINUh2dre.png" /></figure><h3>3 단계 — JPQL 실행</h3><p>1 Persistence 창에서 JPA Console 창을 연다</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*q8Tso5jC4JGWcqMm.png" /></figure><p>2. JPQL을 실행한다</p><p>(주의. H2 데이터베이스 파일 모드는 기본적으로 하나의 Connection만을 허용하기 때문에 Database 창에 H2 데이터 베이스가 연결되어 있다면 연결을 종료하고 시도해야 한다)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*kbqqzASsOfja6dGB.png" /></figure><h3>더 상세한 사용법은</h3><p>아래 IntelliJ 공식 사이트에 상세한 사용법이 공개되어 있다.</p><ul><li><a href="https://www.jetbrains.com/help/idea/working-with-the-jpa-console.html">https://www.jetbrains.com/help/idea/working-with-the-jpa-console.html</a></li><li><a href="https://www.jetbrains.com/help/idea/jpa-console-tool-window.html">https://www.jetbrains.com/help/idea/jpa-console-tool-window.html</a></li></ul><h3>spring.jpa.hibernate.naming.physical-strategy</h3><p>데이터베이스는 관례상 언더 스코어(_)로 단어와 단어를 구분하는데 반해 Java 코드(엔티티)에서는 <a href="https://en.wikipedia.org/wiki/Camel_case">카멜Camel</a> 표기법을 따른다. JPA 구현체인 Hibernate는 이러한 문제를 해결하기 위해 <a href="https://docs.jboss.org/hibernate/orm/5.1/userguide/html_single/chapters/domain/naming.html">이름 매핑 전략Naming Strategy</a>을 제공한다.</p><p>Spring Boot에서는 기본적으로 이름 매핑 전략이 <a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/orm/jpa/hibernate/SpringPhysicalNamingStrategy.html">SpringPhysicalNamingStrategy</a>이다.</p><blockquote>By default, Spring Boot configures the physical naming strategy with SpringPhysicalNamingStrategy. <strong>This implementation provides the same table structure as Hibernate 4: all dots are replaced by underscores and camel casing is replaced by underscores as well.</strong> By default, all table names are generated in lower case, but it is possible to override that flag if your schema requires it. - <a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/html/howto-data-access.html#howto-configure-hibernate-naming-strategy">https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/html/howto-data-access.html#howto-configure-hibernate-naming-strategy</a></blockquote><p><a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/orm/jpa/hibernate/SpringPhysicalNamingStrategy.html">SpringPhysicalNamingStrategy</a>는 Java 코드의 카멜 표기를 언더스코어로 자동 변경해 준다.</p><p>문제는 IntelliJ JPA Console에서는 Spring Boot 기본 이름 매핑 전략(<a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/orm/jpa/hibernate/SpringPhysicalNamingStrategy.html">SpringPhysicalNamingStrategy</a>)을 사용할 경우 오류가 난다는 것이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*Bm8qV_V785beUNqG.png" /></figure><p>이 문제를 해결하기 위해 필자가 찾은 방법 중 하나는 이름 매핑 전략 <a href="https://docs.jboss.org/hibernate/orm/5.2/javadocs/org/hibernate/boot/model/naming/PhysicalNamingStrategyStandardImpl.html">PhysicalNamingStrategyStandardImpl</a>으로 변경하는 것이었다. <a href="https://docs.jboss.org/hibernate/orm/5.2/javadocs/org/hibernate/boot/model/naming/PhysicalNamingStrategyStandardImpl.html">PhysicalNamingStrategyStandardImpl</a>은 Java 코드의 카멜 표기법을 언더스코어로 변경하지 않는다.</p><pre>spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl</pre><p>이름 매핑 전략을 변경하지 않고 JPA Console을 사용하는 방법은 @Column을 사용하여 엔티티에 데이터베이스 테이블 컬럼명을 직접 선언해 주는 것이다.</p><pre>@Entity<br><strong>public</strong> <strong>class</strong> <strong>Customer</strong> {<br>    @Id<br>    @GeneratedValue(strategy=GenerationType.AUTO)<br>    <strong>private</strong> Long id;<br>    @Column(name = &quot;FIRST_NAME&quot;)<br>    <strong>private</strong> String firstName;<br>    @Column(name = &quot;LAST_NAME&quot;)<br>    <strong>private</strong> String lastName;<br>    ...<br>}</pre><h3>덧붙여</h3><p>JPA Console 기능을 사용하지 않더라도 IntelliJ에 JPA 설정하면 JPQL을 코딩할 때 코드 자동 완성 기능이 활성화되어 편리하다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*a-yMG-tHE_4zTds2.png" /></figure><h3>주석</h3><p>[1] 추정컨대 JPQL은 엔티티 코드와 함께 동작하는데 엔티티 코드는 애플리케이션 코드의 일부로 존재하기 때문일 것이다.</p><p>[2] 답변을 받긴 했으나, StackOverFlow나 Spring 커뮤니티에 문의하라는 내용이었다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=44629ff0179f" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[JavaBean Validation과 Hibernate Validator 그리고 Spring Boot]]></title>
            <link>https://medium.com/@SlackBeck/javabean-validation%EA%B3%BC-hibernate-validator-%EA%B7%B8%EB%A6%AC%EA%B3%A0-spring-boot-3f31aee610f5?source=rss-dd736b47f7d7------2</link>
            <guid isPermaLink="false">https://medium.com/p/3f31aee610f5</guid>
            <category><![CDATA[hibernate]]></category>
            <category><![CDATA[spring-boot]]></category>
            <category><![CDATA[validator]]></category>
            <category><![CDATA[javabean]]></category>
            <category><![CDATA[validation]]></category>
            <dc:creator><![CDATA[Yoo Young-mo]]></dc:creator>
            <pubDate>Sat, 16 Mar 2019 05:22:00 GMT</pubDate>
            <atom:updated>2019-03-16T05:22:00.990Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*32XrpPPtiYuNXz4r.png" /></figure><p>이 글은 JavaBean Validation(이하 Bean Validation)의 기본 개념과 Hibernate Validator와의 관계 그리고 Spring Boot에서 간단한 사용법을 소개한다.</p><h3>Bean Validation</h3><p>Bean Validation은 JavaBean 유효성 검증을 위한 메타데이터 모델과 API에 대한 정의이며 여기서 언급하고 있는 JavaBean은 직렬화 가능하고 매개변수가 없는 생성자를 가지며, Getter 와 Setter Method를 사용하여 프로퍼티에 접근이 가능한 객체라고 위키피디아는 정의한다.</p><blockquote><strong>Bean Validation</strong> defines a metadata model and API for <a href="https://en.wikipedia.org/wiki/JavaBean">JavaBean</a> validation — <a href="https://en.wikipedia.org/wiki/Bean_Validation">https://en.wikipedia.org/wiki/Bean_Validation</a> <strong>JavaBeans</strong> are classes that encapsulate many <a href="https://en.wikipedia.org/wiki/Object_(computer_science)">objects</a> into a single object (the bean). They are <a href="https://en.wikipedia.org/wiki/Serialization">serializable</a>, have a <a href="https://en.wikipedia.org/wiki/Nullary_constructor">zero-argument constructor</a>, and allow access to properties using <a href="https://en.wikipedia.org/wiki/Mutator_method">getter and setter methods</a>. The name “Bean” was given to encompass this standard, which aims to create <a href="https://en.wikipedia.org/wiki/Code_reuse">reusable</a> <a href="https://en.wikipedia.org/wiki/Component-based_software_engineering">software components</a> for <a href="https://en.wikipedia.org/wiki/Java_(programming_language)">Java</a>. — <a href="https://en.wikipedia.org/wiki/JavaBeans">https://en.wikipedia.org/wiki/JavaBeans</a></blockquote><p>그렇다면 ‘메타데이터 모델’은 무엇일까?</p><p>힌트는 <a href="https://jcp.org/en/jsr/detail?id=303">JSRJava Specification Requests 303</a> 문서에서 찾을 수 있다.(Bean Validation은 최초에 JSR 303으로 제안되었다)</p><blockquote>Validating data is a common task that occurs throughout an application, from the presentation layer to the persistence layer. Often the same validation logic is implemented in each layer, proving to be time consuming and error prone. To avoid duplication of these validations in each layer, developers often bundle validation logic directly into the domain model, cluttering domain classes with validation code that is, in fact, metadata about the class itself. This JSR defines a metadata model and API for JavaBean validation. The default metadata source is annotations, with the ability to override and extend the meta-data through the use of XML validation descriptors. — <a href="https://jcp.org/en/jsr/detail?id=303">JSR 303</a></blockquote><p>한 문장씩 살펴보자.</p><p><em>데이터 검증은 애플리케이션의 여러 계층(Presentation Layer, Business Layer, Data Access Layer)에 전반에 걸쳐 발생하는 흔한 작업이다. 종종 동일한 데이터 검증 로직이 각 계층에 구현되는데, 이는 오류를 일이 키기 쉽고, 시간을 낭비하는 일이 된다.</em></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*Iuo-76uQ5sMXc_II.png" /><figcaption>출처 : <a href="https://docs.jboss.org/hibernate/validator/5.4/reference/en-US/html_single/">https://docs.jboss.org/hibernate/validator/5.4/reference/en-US/html_single/</a></figcaption></figure><p><em>개발자는 이런 것을 피하기 위해 도메인 클래스들 사이에 퍼져 있는 </em><strong><em>유효성 검증 로직(실제로 클래스 자신의 메타데이터)</em></strong><em>을 도메인 모델로 묶는다.</em></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*emYychQXuUvMXwA7.png" /><figcaption>출처 : <a href="https://docs.jboss.org/hibernate/validator/5.4/reference/en-US/html_single/">https://docs.jboss.org/hibernate/validator/5.4/reference/en-US/html_single/</a></figcaption></figure><p>위의 내용을 종합하여 필자가 이해한 데로 풀어 보면</p><ul><li>애플리케이션을 개발할 때 데이터를 각 계층으로 전달하게 된다. 이러한 데이터는 JavaBean의 형태를 띠게 된다.</li><li>데이터 유효성 검증을 위해 사용하게 되는 것이 데이터에 대한 데이터 즉 어떤 목적을 가지고 만들어진 데이터(Constructed data with a purpose) 바로 메타데이터이다.[1]</li><li>Java에서는 메타데이터를 표현할 수 있는 대표적인 방법이 애노테이션Annotation이다.</li><li>애노테이션(기본적으로는)을 이용하여 메타데이터를 정의하고 이를 통해 JavaBean의 유효성을 검증하는 것에 대한 명세가 Bean Validation이다.</li></ul><p>Bean Validation 명세서Specification는 계속 발전하여 현재 2.0까지 나와 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*j6GAYwfrtd3E5BACMhttEw.png" /><figcaption>출처 : <a href="http://beanvalidation.org/">http://beanvalidation.org/</a></figcaption></figure><h3>Bean Validation과 Hibernate Validator</h3><p>Bean Validation은 명세일 뿐 동작하는 코드가 아니다. 애플리케이션에 적용하기 위해서는 이를 구현한 코드가 필요하다.</p><p>Bean Validation을 실제 동작하도록 구현Implementation한 것이 바로 <a href="http://hibernate.org/validator/">Hibernate Validator</a>[2]이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*wng4zQXqKlzxe-pq.png" /></figure><p>Bean Validation 버전에 따른 Hibernate Validator 버전은 아래와 같다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/704/1*n5dN3TrmILE4iFKfHZ6HuA.png" /><figcaption>출처 : <a href="http://beanvalidation.org/">http://beanvalidation.org/</a></figcaption></figure><h3>Bean Validation과 Spring Boot</h3><p><a href="https://projects.spring.io/spring-boot/">Spring Boot</a>(1.5.9 RELEASE 기준)는 Bean Validation을 Validation 모듈로 제공하고 있으며, Web 모듈에는 Validation 모듈을 포함하고 있다.</p><p>Spring Boot Web 모듈(spring-boot-starter-web-1.5.9.RELEASE.pom)을 자세히 살펴보면 Hibernate Validator(5.3.6.Final)를 사용하는 것을 확인할 수 있다.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;<br>    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br>    &lt;name&gt;Spring Boot Web Starter&lt;/name&gt;<br>    ...<br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br>            &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        ...<br>    &lt;/dependencies&gt;<br>&lt;/project&gt;</pre><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;<br>    &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;<br>    &lt;packaging&gt;pom&lt;/packaging&gt;<br>    ...<br>    &lt;properties&gt;<br>        &lt;hibernate-validator.version&gt;5.3.6.Final&lt;/hibernate-validator.version&gt;<br>    &lt;/properties&gt;<br>    ...<br>&lt;/project&gt;</pre><p>정리하면 Spring Boot 버전에 따라 다르겠지만 1.5.9 RELEASE 기준으로 보면 BeanValidation의 구현체로 Hibernate Validator를 사용하고 Hibernate Validator 버전이 5.3.6 Final이기 때문에 BeanValidation 1.1을 지원한다.</p><h3>Spring Boot + Hibernate Validator 맛보기</h3><p>Hibernate Validator의 여러 쓰임새 중에서도 이 글에서는 REST 개발할 때 HTTP Reqeust Body 검증에 초점을 맞춰 소개한다.</p><p>검증 로직이 없는 코드부터 시작해 보자.</p><pre>@RestController<br>@RequestMapping(&quot;/api/v1/members&quot;)<br><strong>public</strong> <strong>class</strong> <strong>MemberRestController</strong> {<br>    @PostMapping<br>    <strong>public</strong> ResponseEntity&lt;Void&gt; <strong>registerMember</strong>(@RequestBody <strong>final</strong> MemberRegistration registration) {<br>        // ...<br>        <strong>return</strong> <strong>new</strong> ResponseEntity&lt;&gt;(HttpStatus.OK);<br>    }<br>}</pre><pre><strong>public</strong> <strong>class</strong> <strong>MemberRegistration</strong> {<br>    <strong>private</strong> String name;<br>    <strong>private</strong> String password;<br>    <strong>private</strong> String email;<br>    <strong>private</strong> String phoneNumber;<br>    // getter<br>}</pre><p>지금 코드에는 아무런 검증 로직이 없기 때문에 Request Body에 빈 값을 넣어 요청해도 HTTP Response Code를 200(OK)을 반환한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*CcVDo9k60_PapGU4.png" /></figure><p>이제 하나씩 검증 로직을 추가해 보자.</p><p><strong>Validation 1 — ‘name’은 필수이어야 한다.</strong></p><p>name 필드에 @NotEmpty 붙이고 검증 로직이 통과하지 못했을 때 메시지를 기술해 준다.</p><pre><strong>import</strong> org.hibernate.validator.constraints.NotEmpty;<br><strong>public</strong> <strong>class</strong> <strong>MemberRegistration</strong> {<br>    @NotEmpty(message = &quot;이름은 필수 입니다&quot;)<br>    <strong>private</strong> String name;<br>    // ...<br>    // getter, setter<br>}</pre><p>마지막으로 Validation을 실행하는 Trigger[3]로써 @Valid를 MemberRegistration에 붙여준다.</p><pre><strong>import</strong> javax.validation.Valid;<br>@RestController<br>@RequestMapping(&quot;/api/v1/members&quot;)<br><strong>public</strong> <strong>class</strong> <strong>MemberRestController</strong> {<br>    @PostMapping<br>    <strong>public</strong> ResponseEntity&lt;Void&gt; <strong>registerMember</strong>(@Valid @RequestBody <strong>final</strong> MemberRegistration registration) {<br>        // ...<br>    }<br>}</pre><p>이전과 동일하게 HTTP Request Body 빈 값으로 REST API를 호출해 보자.</p><p>HTTP Response Code로 400(Bad Request)로 그리고 ResponseBody로 @NotEmpty message에 기술했던 부분을 반환한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*E6Gr1CF4QBj6eKR8.png" /></figure><p><strong>Validation 2 — ‘password’는 필수이면서 6~20자리로 숫자와 특수 문자가 포함된 영문 대소문자로 문자열이어야 한다</strong></p><p>password 필드에 @NotEmpty을 붙이고, @Pattern을 사용하여 비밀번호 제약 조건을 정규식으로 기술해 준다.</p><pre><strong>import</strong> org.hibernate.validator.constraints.NotEmpty;<br><strong>import</strong> javax.validation.constraints.Pattern;<br><strong>public</strong> <strong>class</strong> <strong>MemberRegistration</strong> {<br>    // ...<br>    @NotEmpty(message = &quot;비밀번호는 필수 입니다&quot;)<br>    @Pattern(regexp = &quot;((?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%]).{6,20})&quot;, message = &quot;비밀 번호는 6~20자리로 숫자와 특수 문자가 포함된 영문 대소문자로 입력해 주세요&quot;)<br>    <strong>private</strong> String password;<br>    // getter, setter<br>}</pre><p>Request Body의 password 가 빈값이 아니면 정규식으로 제약 조건을 검증 후 통과하지 못 하면 일전과 동일하게 HTTP Response Code로 400(Bad Request)로 그리고 ResponseBody로 @NotEmpty message에 기술했던 부분을 반환한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*qTZSvh6ehw5lJxMy.png" /></figure><p><strong>Validation 3 — ‘email’ 또는 ‘phoneNumber’ 둘 중 하나는 필수이어야 한다</strong></p><p>@ScriptAssert를 사용하면 필드 수준이 아닌 클래스 수준에서 검증이 가능하다.</p><pre><strong>import</strong> org.hibernate.validator.constraints.ScriptAssert;<br>@ScriptAssert(lang = &quot;javascript&quot;,<br>        script = &quot;(_.email != null &amp;&amp; _.email.length() &gt; 0) || (_.phoneNumber != null &amp;&amp; _.phoneNumber.length() &gt; 0)&quot;,<br>        alias = &quot;_&quot;, message = &quot;이메일 혹은 전화 번호 둘 중 하나는 필수 입니다&quot;)<br><strong>public</strong> <strong>class</strong> <strong>MemberRegistration</strong> {<br>    // ...<br>    <strong>private</strong> String email;<br>    <strong>private</strong> String phoneNumber;<br>    // getter, setter<br>}</pre><p><strong>Validation 4 — ‘email’에 값이 있다면 email 형식에 따라야 한다</strong></p><pre><strong>import</strong> org.hibernate.validator.constraints.ScriptAssert;<br><strong>import</strong> org.hibernate.validator.constraints.Email;<br>@ScriptAssert(lang = &quot;javascript&quot;,<br>        script = &quot;(_.email != null &amp;&amp; _.email.length() &gt; 0) || (_.phoneNumber != null &amp;&amp; _.phoneNumber.length() &gt; 0)&quot;,<br>        alias = &quot;_&quot;, message = &quot;이메일 혹은 전화 번호 둘 중 하나는 필수 입니다&quot;)<br><strong>public</strong> <strong>class</strong> <strong>MemberRegistration</strong> {<br>    // ...<br>    @Email(message = &quot;이메일 형식으로 입력해 주세요&quot;)<br>    <strong>private</strong> String email;<br>    <strong>private</strong> String phoneNumber;<br>    // getter, setter<br>}</pre><p><strong>Validation 5 — ‘phoneNumber’에 값이 있다면 10자리 이하여야 한다.</strong></p><pre><strong>import</strong> org.hibernate.validator.constraints.ScriptAssert;<br><strong>import</strong> org.hibernate.validator.constraints.Email;<br><strong>import</strong> org.hibernate.validator.constraints.Length;<br>@ScriptAssert(lang = &quot;javascript&quot;,<br>        script = &quot;(_.email != null &amp;&amp; _.email.length() &gt; 0) || (_.phoneNumber != null &amp;&amp; _.phoneNumber.length() &gt; 0)&quot;,<br>        alias = &quot;_&quot;, message = &quot;이메일 혹은 전화 번호 둘 중 하나는 필수 입니다&quot;)<br><strong>public</strong> <strong>class</strong> <strong>MemberRegistration</strong> {<br>    // ...<br>    @Email(message = &quot;이메일 형식으로 입력해 주세요&quot;)<br>    <strong>private</strong> String email;<br>    @Length(min = 1, max = 10, message = &quot;전화 번호는 10자리 이하로 입력해 주세요&quot;)<br>    <strong>private</strong> String phoneNumber;<br>    // getter, setter<br>}</pre><h3>GitHub</h3><p>전체 코드는 필자의 <a href="https://github.com/YooYoungmo/article-bean-validation">GitHub</a>에서 확인 가능하다.</p><h3>주석</h3><p>[1] <a href="https://ko.wikipedia.org/wiki/%EB%A9%94%ED%83%80%EB%8D%B0%EC%9D%B4%ED%84%B0">https://ko.wikipedia.org/wiki/메타데이터</a></p><p>[2] Hibernate 이름에서 ORM을 떠올리는 경우가 많은데 ORM과는 별개이다.</p><p>[3] <a href="https://spring.io/blog/2009/11/17/spring-3-type-conversion-and-validation/">https://spring.io/blog/2009/11/17/spring-3-type-conversion-and-validation/</a></p><blockquote>Validation It is common to validate a model after binding user input to it. Spring 3 provides support for declarative validation with JSR-303. This support is enabled automatically if a JSR-303 provider, such as Hibernate Validator, is present on your classpath. When enabled, you can trigger validation simply by annotating a Controller method parameter with the @Valid annotation</blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3f31aee610f5" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[cURL 명령어로 하는 초간단 CORS 테스트]]></title>
            <link>https://medium.com/@SlackBeck/curl-%EB%AA%85%EB%A0%B9%EC%96%B4%EB%A1%9C-%ED%95%98%EB%8A%94-%EC%B4%88%EA%B0%84%EB%8B%A8-cors-%ED%85%8C%EC%8A%A4%ED%8A%B8-4b48080c1c9b?source=rss-dd736b47f7d7------2</link>
            <guid isPermaLink="false">https://medium.com/p/4b48080c1c9b</guid>
            <category><![CDATA[testing]]></category>
            <category><![CDATA[curl]]></category>
            <category><![CDATA[cors]]></category>
            <dc:creator><![CDATA[Yoo Young-mo]]></dc:creator>
            <pubDate>Sat, 16 Mar 2019 05:10:15 GMT</pubDate>
            <atom:updated>2019-03-16T05:10:15.686Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*L7IfbUByKOmzzFDs.png" /></figure><p>요즘은 굳이 <a href="https://martinfowler.com/articles/microservices.html">MSAMicroservices Architecture</a> 가 아니더라도 프론트엔드Front-end와 백엔드Back-end를 구분하여 프론트 엔드는 Anguler나 React로 개발하고 백엔드는 프론트엔드에서 사용할 API를 제공하는 것을 흔히 찾아 볼 수 있다.</p><p>이때 부딪치게 되는 문제가 <a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Access_control_CORS">CORSCross Origin Resource Sharing</a>이다. CORS 개념에 대한 자세한 설명은 <a href="http://www.popit.kr/author/babokim/">김형준</a>님의 <a href="http://www.popit.kr/cors-preflight-%EC%9D%B8%EC%A6%9D-%EC%B2%98%EB%A6%AC-%EA%B4%80%EB%A0%A8-%EC%82%BD%EC%A7%88/">글(CORS, Preflight, 인증 처리 관련 삽질)</a>에 잘 나와 있다.</p><p>프론트엔드에서 API 호출 시 CORS 문제가 생기지 않도록 API 서버 개발자는 CORS 관련 설정을 해주어야 한다.</p><p>API 서버 개발자는 CORS 설정이 제대로 되었는지 어떻게 확인할 수 있을까? 가능하면 실제 운영하는 서버에 코드를 배포하기 전에 개발자 자신의 로컬 환경에서..</p><h3>cURL 명령어로 CORS 테스트</h3><p>테스트 시나리오는 <a href="http://www.popit.kr/author/babokim/">김형준</a>님의 <a href="http://www.popit.kr/cors-preflight-%EC%9D%B8%EC%A6%9D-%EC%B2%98%EB%A6%AC-%EA%B4%80%EB%A0%A8-%EC%82%BD%EC%A7%88/">글(CORS, Preflight, 인증 처리 관련 삽질)</a>을 예시를 그대로 사용하겠다.(만약 글을 보지 않았다면 CORS 관련 부분만 보고 다시 읽기를 권한다)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*ZqmIGPdBkIpd6HXG.png" /><figcaption>출처 : http://www.popit.kr/cors-preflight-인증-처리-관련-삽질/</figcaption></figure><p>위의 그림에서 CORS 테스트 대상은 sales.popit.kr이다.</p><p>sales.popit.kr의 개발자(API 서버 개발자)는 자신의 로컬 개발 환경에 서버(localhost)를 구동하고 아래 cURL 명령어를 실행하면 CORS 여부를 확인할 수 있다.</p><pre>curl \<br>--verbose \<br>--request OPTIONS \<br>&#39;http://localhost/sales&#39; \<br>--header &#39;Origin: http://sales-front.popit.kr&#39; \<br>--header &#39;Access-Control-Request-Headers: Origin, Accept, Content-Type&#39; \<br>--header &#39;Access-Control-Request-Method: GET&#39;</pre><p>CORS 설정(sales-front.popit.kr 허용)이 정상적 되었다면 HTTP Response Code가 200(OK)이 반환되며</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/385/0*Se1SCaltaLllapzJ.png" /></figure><p>아니라면 405(Method Not Allowed)로 반환된다.(API 서버에 따라 403으로 반환되는 경우도 있다)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/394/0*CM_ArYP7ZedEV5wz.png" /></figure><p>로컬 개발 환경이 아닌 실제 배포된 운영 서버를 확인하려면 cURL 명령어 매개 변수 중 <a href="http://localhost/sales">http://localhost/sales</a> 를 운영 URL(본 글 예시에서는 <a href="http://sales.popit.kr/">http://sales.popit.kr</a>/sales)로 변경하면 된다.</p><p>결국 필자가 사용한 cURL 명령어는 웹 브라우저의 Pre-flight 요청을[1] 대신하는 것이다.</p><h3>cURL</h3><p>cURL 명령어는 cURL에서 지원하는 여러 프로토콜Protocols 중 특정 프로토콜 하나를 사용하여 데이터를 서버로 전달하는 도구라고 MAN 페이지에서 설명하고 있다.</p><blockquote>curl is a tool to transfer data from or to a server, using one of the supported protocols (DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET and TFTP). The command is designed to work without user interaction.</blockquote><blockquote>curl offers a busload of useful tricks like proxy support, user authentication, FTP upload, HTTP post, SSL connections, cookies, file transfer resume, Metalink, and more. As you will see below, the number of features will make your head spin!</blockquote><blockquote>curl is powered by libcurl for all transfer-related features. Seelibcurl(3)for details. — <a href="https://curl.haxx.se/docs/manpage.html">https://curl.haxx.se/docs/manpage.html</a></blockquote><p>cURL은 HTTP(S) 프로토콜을 지원한다. 그래서 웹 브라우저 없이도 cURL 명령어를 통해 HTTP Reqeust를 만들어 서버로 전달하는 것이 가능하다.</p><h3>만약 윈도우즈를 사용하고 있다면</h3><p><a href="https://curl.haxx.se/download.html">https://curl.haxx.se/download.html</a>에서 cURL 윈도우즈 버전을 제공한다.</p><p>만약 <a href="https://chocolatey.org/">Chocolatey</a>를 사용하고 있다면 아래 명령어를 사용하여 설치해도 된다.</p><pre>choco install curl</pre><h3>주석</h3><p>[1] <a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Access_control_CORS">https://developer.mozilla.org/ko/docs/Web/HTTP/Access_control_CORS</a> ‘사전 요청’절 참조</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4b48080c1c9b" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Java 개발자를 위한 Maven + SonarQube + Docker로 시작하는 코드 정적 분석]]></title>
            <link>https://medium.com/@SlackBeck/java-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-maven-sonarqube-docker%EB%A1%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EC%BD%94%EB%93%9C-%EC%A0%95%EC%A0%81-%EB%B6%84%EC%84%9D-1d6a33f27dc?source=rss-dd736b47f7d7------2</link>
            <guid isPermaLink="false">https://medium.com/p/1d6a33f27dc</guid>
            <category><![CDATA[sonarqube]]></category>
            <category><![CDATA[java]]></category>
            <category><![CDATA[docker]]></category>
            <category><![CDATA[static-code-analysis]]></category>
            <category><![CDATA[maven]]></category>
            <dc:creator><![CDATA[Yoo Young-mo]]></dc:creator>
            <pubDate>Sat, 16 Mar 2019 05:04:51 GMT</pubDate>
            <atom:updated>2019-03-16T05:04:51.653Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*fGxJer9qDDnrGI1i.png" /></figure><p>켄트 벡Kent Beck은 자신의 책 <a href="http://www.yes24.com/24/goods/2126201?scode=032&amp;OzSrank=1">익스트림 프로그래밍Extreme Programming</a>에서 5 가치[1] 를 이야기 했는데 그중 하나가 피드백Feedback이다.</p><blockquote>한번에 완벽하게 해결하기를 바라는 것보다 점진적 개선에 만족하기 때문에 우리는 피드백을 이용해 목표에 점점 더 가까이 다가간다. 피드백은 여러 가지 형식으로 우리에게 들어온다. — 익스트림 프로그래밍 47 쪽</blockquote><p>더 나은 코드를 만들기 위해서는 피드백이 필수이다. 어떻게 하면 효과적인 피드백을 받을 수 있을까?</p><p>필자는 코드 정적 분석 도구의 사용이 효과적인 피드백 중 하나라고 생각한다.</p><p>정적 분석 도구는 코드를 분석하여 여러 가지로 지적(?)을 한다. 개발자는 정적 분석 도구로부터의 피드백을 통해 자신의 코드를 뒤돌아 볼수 있는 계기를 가질 수 있으며 더 나아가 개선까지 이어질 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*RZGP5lCTikjFmWpt.png" /><figcaption>이미지 출처 : <a href="http://www.yeahwrite.org/?p=3322">http://www.yeahwrite.org/?p=3322</a></figcaption></figure><p>정적 분석 도구의 종류는 프로그래밍 언어만큼이나 많다.[2] 이 글은 그중에서도 <a href="https://www.sonarqube.org/">SonarQube</a>를 소개한다.</p><h3><a href="https://www.sonarqube.org/">SonarQube</a></h3><p>예전에는 Sonar라고 했지만 지금은 SonarQube로 이름을 바꾸었다.[3]</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*L5ITyvwKYN0fs5aK.png" /><figcaption><a href="https://www.sonarqube.org/">https://www.sonarqube.org/</a></figcaption></figure><p><a href="https://www.sonarsource.com/">SonarSouce</a>에서 만든 <a href="https://www.sonarqube.org/">SonarQube</a>는 코드를 분석하여 중복, 테스트 커버리지, 코드 복잡도, 버그, 보안 취약성 등을 리포팅 해주며, IDE(<a href="https://en.wikipedia.org/wiki/Eclipse_(software)">Eclipse</a>, <a href="https://en.wikipedia.org/wiki/Microsoft_Visual_Studio">Visual Studio</a>, <a href="https://en.wikipedia.org/wiki/IntelliJ_IDEA">IntelliJ IDEA</a>), 빌드 도구(<a href="https://en.wikipedia.org/wiki/Apache_Maven">Maven</a>, <a href="https://en.wikipedia.org/wiki/Apache_Ant">Ant</a>, <a href="https://en.wikipedia.org/wiki/Gradle">Gradle</a>, <a href="https://en.wikipedia.org/wiki/MSBuild">MSBuild</a>), CIContinuous Integration 도구(<a href="https://en.wikipedia.org/wiki/Bamboo_(software)">Atlassian Bamboo</a>, <a href="https://en.wikipedia.org/wiki/Jenkins_(software)">Jenkins</a>, <a href="https://en.wikipedia.org/wiki/Hudson_(software)">Hudson</a>)와 통합하여 사용할 수 있다. 이에 더해 단일 프로그래밍 언어만 분석 가능한 것이 아니라 다양한 프로그래밍 언어로 만든 코드를 분석할 수 있다.[4]</p><p>자세한 SonarQube 리포팅 결과는 아래 체험 사이트에서 확인할 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*wEK9cCmWTuPYxLXj.png" /><figcaption><a href="https://sonarcloud.io/explore/projects">https://sonarcloud.io/explore/projects</a></figcaption></figure><h3><a href="https://www.docker.com/">Docker</a>로 SonarQube 서버 설치 하기</h3><p>Docker 개념이 생소하다면 <a href="http://www.popit.kr/author/babokim/">김형준</a>님의 글(<a href="http://www.popit.kr/%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EC%B2%98%EC%9D%8C-docker-%EC%A0%91%ED%95%A0%EB%95%8C-%EC%98%A4%EB%8A%94-%EB%A9%98%EB%B6%95-%EB%AA%87%EA%B0%80%EC%A7%80/">개발자가 처음 Docker 접할때 오는 멘붕 몇가지</a>)을 읽어 보기를 권한다.</p><p>Docker가 설치되어 있지 않다면 아래 URL에서 다운로드해 설치한다.</p><ul><li><a href="https://docs.docker.com/install/">https://docs.docker.com/install/</a></li></ul><p><a href="https://hub.docker.com/_/sonarqube/">SonarQube는 Docker 이미지</a>를 제공한다. Docker 이미지를 다운로드하여 SonarQube 서버를 시작해 보자.</p><pre>// SonarQube Docker 이미지 다운로드<br>$ docker pull sonarqube<br>// SonarQube 서버 시작<br>$ docker run -d --name sonarqube -p 9000:9000 -p 9092:9092 sonarqube</pre><p>정상적으로 SonarQube 서버가 시작되었다면 <a href="http://localhost:9000/">http://localhost:9000/</a>에 접속해 보면 아래와 같은 화면이 나타난다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*hMd0uwIa2dQmUCC1.png" /></figure><h3>Java <a href="http://maven.apache.org/">Maven</a> 프로젝트를 SonarQube 정적 분석하기</h3><p>이 글에서는 <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">Java 언어(1.8)</a>로 만든 코드를 분석하며, 빌드 도구로는 Maven을 사용한다.</p><p>먼저 분석할 Java 코드를 준비해 보자.</p><p><a href="https://github.com/YooYoungmo/gs-spring-boot">필자의 GitHub</a>에 올라가 있는 <a href="https://spring.io/guides/gs/spring-boot/">Spring Boot 프로젝트(Building an Application with Spring Boot)</a> 체크아웃 받는다.(참고로 Spring Boot를 몰라도 된다. 이 글에서는 정적 분석 예제 코드로만 쓸 뿐이다)</p><ul><li><a href="https://github.com/YooYoungmo/gs-spring-boot.git">https://github.com/YooYoungmo/gs-spring-boot.git</a></li></ul><p>이제 Maven으로 SonarQube로 정적 분석을 실행해 보자.</p><p>Maven이 설치되어 있지 않다면 아래 URL을 참고하여 설치한다.</p><ul><li><a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></li></ul><p>Maven의 <a href="http://maven.apache.org/settings.html">settings.xml</a> 파일에 SonarQube 서버 설정을 추가한다.</p><p>참고로 settings.xml 파일 위치는 2개다. 둘 중 하나에 추가하면 된다.(해당 디렉토리에 settings.xml 파일이 없다면 새로 만들면 된다.)</p><ul><li>Maven 설치 디렉토리 : ${maven.home}/conf/settings.xml</li><li>사용자 홈 디렉토리 : ${user.home}/.m2/settings.xml</li></ul><pre>&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;<br>      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>      xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0<br>                          https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;<br>    &lt;pluginGroups&gt;<br>        &lt;pluginGroup&gt;org.sonarsource.scanner.maven&lt;/pluginGroup&gt;<br>    &lt;/pluginGroups&gt;<br>    &lt;profiles&gt;<br>        &lt;profile&gt;<br>            &lt;id&gt;sonar&lt;/id&gt;<br>            &lt;activation&gt;<br>                &lt;activeByDefault&gt;<strong>true</strong>&lt;/activeByDefault&gt;<br>            &lt;/activation&gt;<br>            &lt;properties&gt;<br>                &lt;!-- Optional URL to server. Default value is http://localhost:9000 --&gt;<br>                &lt;sonar.host.url&gt;<br>                  http://localhost:9000<br>                &lt;/sonar.host.url&gt;<br>            &lt;/properties&gt;<br>        &lt;/profile&gt;<br>     &lt;/profiles&gt;<br>&lt;/settings&gt;</pre><p>체크아웃 받은 프로젝트 디렉토리(pom.xml 이 존재하는 디렉토리)에서 Maven Goal을 실행한다.</p><pre>mvn sonar:sonar</pre><p>오류 없이 실행되었다면 SonarQube 서버(<a href="http://localhost:9000/">http://localhost:9000</a>)에서 예제 프로젝트(gs-spring-boot)가 분석된 것을 확인할 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*_M9-t1pT-o4G9I9c.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*HmLzIzXp9uH_t1m9.png" /></figure><h3>IntelliJ와 SonarQube 서버 통합</h3><p><a href="https://www.sonarsource.com/">SonarSouce</a>는 SonarQube 서버와 IDE와 통합해서 사용할 수 있는 <a href="https://www.sonarlint.org/">SonarLint</a>를 IDEIntegrated Development Environment의 플러그인Plugin 형태로 제공한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*IPCT4YKHKVZs9Ng_.png" /><figcaption><a href="https://www.sonarlint.org/">https://www.sonarlint.org/</a></figcaption></figure><p>SonarLint를 사용하면 IDE에서 정적 분석을 실행할 수 있고 코드 편집창에서 정적 분석 결과 확인할 수 있어 편하다.</p><p>IDE 중 하나인 IntelliJ에 SonarLint를 설치해 보고, SonarQube 서버와 통합해 보자.</p><h3>SonarLint 설치</h3><p>1 Preferences 창을 연다</p><p>2 SonarLint Plugin을 인스톨한다(Plugins | Browse repositories.. | SonarLint)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/464/0*b2aMoKmmVJbwBkDF.png" /></figure><h3>SonarLint와 SonarQube 서버 연결</h3><p>1 SonarLint 창을 연다(View|Tools Windows|SonarLint)</p><p>2 SonarQube서버와 연결한다</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*L62dDZpPVW0NlqUt.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*nBtigWPQuSR0AieW.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*3YTuQvrLUoL57qYG.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*lQeHJGhwU86gzG16.png" /></figure><h3>SonarLint로 정적 분석 실행</h3><p>컨텍스트 메뉴에서 Analyze|Analyze All File with SonarLint 선택하면 전체 파일을 분석한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*4Fsn5uPoT-S5E2tm.png" /></figure><p>분석 결과는 SonarLint 창에서 확인할 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*a_zmqmWLg133FyeX.png" /></figure><h3>Maven 멀티 모듈로 프로젝트가 구성되어 있다면</h3><p>Maven 멀티 모듈일 경우 테스트 커버리지가 측정되지 않는 경우가 있다. 이 경우에는 아래와 같이 설정해 주면 된다.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;<br>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br>    &lt;groupId&gt;ymyoo&lt;/groupId&gt;<br>    &lt;artifactId&gt;article-<strong>module</strong>-root&lt;/artifactId&gt;<br>    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br>    &lt;modules&gt;<br>        &lt;<strong>module</strong>&gt;...&lt;/<strong>module</strong>&gt;<br>        &lt;<strong>module</strong>&gt;...&lt;/<strong>module</strong>&gt;<br>        &lt;<strong>module</strong>&gt;...&lt;/<strong>module</strong>&gt;<br>    &lt;/modules&gt;<br>    &lt;packaging&gt;pom&lt;/packaging&gt;<br>    &lt;properties&gt;<br>        &lt;sonar.java.coveragePlugin&gt;jacoco&lt;/sonar.java.coveragePlugin&gt;<br>        &lt;sonar.dynamicAnalysis&gt;reuseReports&lt;/sonar.dynamicAnalysis&gt;<br>        &lt;sonar.jacoco.reportPath&gt;${project.basedir}/../target/jacoco.exec&lt;/sonar.jacoco.reportPath&gt;<br>        &lt;sonar.language&gt;java&lt;/sonar.language&gt;<br>    &lt;/properties&gt;<br>    &lt;build&gt;<br>        &lt;plugins&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.jacoco&lt;/groupId&gt;<br>                &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt;<br>                &lt;configuration&gt;<br>                    &lt;destFile&gt;${sonar.jacoco.reportPath}&lt;/destFile&gt;<br>                    &lt;append&gt;<strong>true</strong>&lt;/append&gt;<br>                &lt;/configuration&gt;<br>                &lt;executions&gt;<br>                    &lt;execution&gt;<br>                        &lt;id&gt;agent&lt;/id&gt;<br>                        &lt;goals&gt;<br>                            &lt;goal&gt;prepare-agent&lt;/goal&gt;<br>                        &lt;/goals&gt;<br>                    &lt;/execution&gt;<br>                &lt;/executions&gt;<br>            &lt;/plugin&gt;<br>        &lt;/plugins&gt;<br>    &lt;/build&gt;<br>&lt;/project&gt;</pre><h3>주석</h3><p>[1] <a href="http://www.extremeprogramming.org/values.html">5 개 가치(Value)</a>는 단순성(Simplicity), 의사소통(Communication), 피드백(Feedback), 존중(Respect), 용기(Courage)이다.</p><p>[2] <a href="https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis">https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis</a></p><p>[3] 일반적으로 Sonar 라고 하면 음향탐지장비로 알려져 있다.(<a href="https://ko.wikipedia.org/wiki/%EC%86%8C%EB%82%98">https://ko.wikipedia.org/wiki/소나</a>)</p><p>[4] <a href="https://en.wikipedia.org/wiki/SonarQube">https://en.wikipedia.org/wiki/SonarQube</a></p><h3>참고 자료</h3><ul><li><a href="https://abstracta.us/blog/software-testing/code-analysis-part-2-analyzing-code-with-sonarqube/">https://abstracta.us/blog/software-testing/code-analysis-part-2-analyzing-code-with-sonarqube/</a></li><li><a href="https://abstracta.us/blog/software-testing/sonarqube-alternatives/">https://abstracta.us/blog/software-testing/sonarqube-alternatives/</a></li><li><a href="https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+Maven">https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+Maven</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1d6a33f27dc" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[JUnit Assertion에서 AssertJ로 갈아탈 때 소소한 팁]]></title>
            <link>https://medium.com/@SlackBeck/junit-assertion%EC%97%90%EC%84%9C-assertj%EB%A1%9C-%EA%B0%88%EC%95%84%ED%83%88-%EB%95%8C-%EC%86%8C%EC%86%8C%ED%95%9C-%ED%8C%81-4d1ba5245942?source=rss-dd736b47f7d7------2</link>
            <guid isPermaLink="false">https://medium.com/p/4d1ba5245942</guid>
            <category><![CDATA[migration]]></category>
            <category><![CDATA[assertj]]></category>
            <category><![CDATA[junit]]></category>
            <category><![CDATA[java]]></category>
            <category><![CDATA[shell-script]]></category>
            <dc:creator><![CDATA[Yoo Young-mo]]></dc:creator>
            <pubDate>Sat, 16 Mar 2019 04:55:14 GMT</pubDate>
            <atom:updated>2019-03-16T04:55:14.727Z</atom:updated>
            <content:encoded><![CDATA[<p>필자는 현재 참여 중인 프로젝트에서 <a href="https://junit.org/junit4/">JUnit</a>으로 테스트 코드를 작성하였다.</p><p>그 와중에 JUnit 보다 직관적인 Assert 구문과 풍부한 Assertion[1]을 제공하는 <a href="http://joel-costigliola.github.io/assertj/index.html">AssertJ</a>를 알게 되었고 AssertJ로 테스트 코드를 리펙토링하고 싶었다.</p><p>기존에 작성된 <a href="https://github.com/junit-team/junit4/wiki/Assertions">JUnit Assertion</a> 코드를 자동으로 AssertJ 코드로 바꿀 수는 없을까?</p><h3>AssertJ 마이그레이션Migration 도구</h3><p>AssertJ 사이트에서는 JUnit Assertion을 AssertJ 코드로 바꿔주는 마이그레이션 도구로 쉘 스크립트를 제공한다.[2]</p><p>(참고로 Windows 경우 <a href="https://gitforwindows.org/">git bash</a> 같은 bash console 설치 후 실행하면 된다)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*xgwxIIM43EJXdtnO.png" /><figcaption>출처 : <a href="http://joel-costigliola.github.io/assertj/assertj-core-converting-junit-assertions-to-assertj.html">http://joel-costigliola.github.io/assertj/assertj-core-converting-junit-assertions-to-assertj.html</a></figcaption></figure><p>쉘 스크립트는 <a href="https://ko.wikipedia.org/wiki/Sed_(%EC%9C%A0%ED%8B%B8%EB%A6%AC%ED%8B%B0)">sed</a>와 정규식을 기반으로 만들어졌으며 *Test.java 파일을 찾아서 Assertion 구문을 대치한다.</p><h3>쉘 스크립트 사용해 보기</h3><p>먼저 변경 전 JUnit Assertions 코드를 보자.</p><p><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/language/static-import.html">Static Import</a>를 사용하였고, JUnit에서 제공하는 Assertion이 사용되었다.</p><pre><strong>import</strong> <strong>static</strong> org.junit.Assert.*;<br><strong>public</strong> <strong>class</strong> <strong>AssertTest</strong> {<br>    @Test<br>    <strong>public</strong> <strong>void</strong> <strong>testAssertArrayEquals</strong>() {<br>        <strong>byte</strong>[] expected = &quot;trial&quot;.getBytes();<br>        <strong>byte</strong>[] actual = &quot;trial&quot;.getBytes();<br>        assertArrayEquals(&quot;failure - byte arrays not same&quot;, expected, actual);<br>    }<br>    @Test<br>    <strong>public</strong> <strong>void</strong> <strong>testAssertEquals</strong>() {<br>        assertEquals(&quot;failure - strings are not equal&quot;, &quot;text&quot;, &quot;text&quot;);<br>    }<br>    @Test<br>    <strong>public</strong> <strong>void</strong> <strong>testAssertFalse</strong>() {<br>        assertFalse(&quot;failure - should be false&quot;, <strong>false</strong>);<br>    }<br>    @Test<br>    <strong>public</strong> <strong>void</strong> <strong>testAssertNotNull</strong>() {<br>        assertNotNull(&quot;should not be null&quot;, <strong>new</strong> Object());<br>    }<br>    @Test<br>    <strong>public</strong> <strong>void</strong> <strong>testAssertNotSame</strong>() {<br>        assertNotSame(&quot;should not be same Object&quot;, <strong>new</strong> Object(), <strong>new</strong> Object());<br>    }<br>    @Test<br>    <strong>public</strong> <strong>void</strong> <strong>testAssertNull</strong>() {<br>        String str = <strong>null</strong>;<br>        assertNull(&quot;should be null&quot;, str);<br>    }<br>    @Test<br>    <strong>public</strong> <strong>void</strong> <strong>testAssertSame</strong>() {<br>        Integer aNumber = Integer.valueOf(768);<br>        assertSame(&quot;should be same&quot;, aNumber, aNumber);<br>    }<br>    @Test<br>    <strong>public</strong> <strong>void</strong> <strong>testAssertTrue</strong>() {<br>        assertTrue(&quot;failure - should be true&quot;, <strong>true</strong>);<br>    }<br>}</pre><p>쉘 스크립트를 실행해 보자.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*ySoHOr6nj4DOLWH6.png" /></figure><p>JUnit Assertion 코드가 AssertJ 코드로 변경된 것을 확인할 수 있다.</p><pre><strong>import</strong> <strong>static</strong> org.assertj.core.api.Assertions.*;<br><strong>public</strong> <strong>class</strong> <strong>AssertTest</strong> {<br>    @Test<br>    <strong>public</strong> <strong>void</strong> <strong>testAssertArrayEquals</strong>() {<br>        <strong>byte</strong>[] expected = &quot;trial&quot;.getBytes();<br>        <strong>byte</strong>[] actual = &quot;trial&quot;.getBytes();<br>        assertThat(actual).as(&quot;failure - byte arrays not same&quot;).isEqualTo(expected);<br>    }<br>    @Test<br>    <strong>public</strong> <strong>void</strong> <strong>testAssertEquals</strong>() {<br>        assertThat(&quot;text&quot;).as(&quot;failure - strings are not equal&quot;).isEqualTo(&quot;text&quot;);<br>    }<br>    @Test<br>    <strong>public</strong> <strong>void</strong> <strong>testAssertFalse</strong>() {<br>        assertThat(<strong>false</strong>).as(&quot;failure - should be false&quot;).isFalse();<br>    }<br>    @Test<br>    <strong>public</strong> <strong>void</strong> <strong>testAssertNotNull</strong>() {<br>        assertThat(<strong>new</strong> Object()).as(&quot;should not be null&quot;).isNotNull();<br>    }<br>    @Test<br>    <strong>public</strong> <strong>void</strong> <strong>testAssertNotSame</strong>() {<br>        assertThat(<strong>new</strong> Object()).as(&quot;should not be same Object&quot;).isNotSameAs(<strong>new</strong> Object());<br>    }<br>    @Test<br>    <strong>public</strong> <strong>void</strong> <strong>testAssertNull</strong>() {<br>        String str = <strong>null</strong>;<br>        assertThat(str).as(&quot;should be null&quot;).isNull();<br>    }<br>    @Test<br>    <strong>public</strong> <strong>void</strong> <strong>testAssertSame</strong>() {<br>        Integer aNumber = Integer.valueOf(768);<br>        assertThat(aNumber).as(&quot;should be same&quot;).isSameAs(aNumber);<br>    }<br>    @Test<br>    <strong>public</strong> <strong>void</strong> <strong>testAssertTrue</strong>() {<br>        assertThat(<strong>true</strong>).as(&quot;failure - should be true&quot;).isTrue();<br>    }<br>}</pre><h3>주석</h3><p>[1] <a href="http://joel-costigliola.github.io/assertj/assertj-core-features-highlight.html">AssertJ Core features highlight</a></p><p>[2] <a href="http://joel-costigliola.github.io/assertj/assertj-core-converting-junit-assertions-to-assertj.html">Converting your JUnit assertions to AssertJ</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4d1ba5245942" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[도커 초보의 우분투 Cron 삽질기]]></title>
            <link>https://medium.com/@SlackBeck/%EB%8F%84%EC%BB%A4-%EC%B4%88%EB%B3%B4%EC%9D%98-%EC%9A%B0%EB%B6%84%ED%88%AC-cron-%EC%82%BD%EC%A7%88%EA%B8%B0-b3c288c86eab?source=rss-dd736b47f7d7------2</link>
            <guid isPermaLink="false">https://medium.com/p/b3c288c86eab</guid>
            <category><![CDATA[cron]]></category>
            <category><![CDATA[java]]></category>
            <category><![CDATA[batch-processing]]></category>
            <category><![CDATA[ubuntu]]></category>
            <category><![CDATA[docker]]></category>
            <dc:creator><![CDATA[Yoo Young-mo]]></dc:creator>
            <pubDate>Fri, 15 Mar 2019 00:18:25 GMT</pubDate>
            <atom:updated>2019-03-15T00:18:25.896Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*8xj5jJaFMIfWZtnH.png" /></figure><p>필자가 도커 초보인 동시에 우분투 초보라는 점을 감안하여 읽어 주셨으면 좋겠습니다. :)</p><p>이 글은 필자가 도커화Dockerize된 우부투에서 배치Batch 애플리케이션을 주기적으로 실행시키는 과정에서 겪었던 시행착오 과정을 정리한 것이다.</p><h3>Cron과 Cron Job 그리고 Crontab</h3><p>필자가 우분투에서 배치 애플리케이션을 주기적으로 실행 시키기 위해 선택한 것은 <a href="http://manpages.ubuntu.com/manpages/trusty/en/man8/cron.8.html">Cron</a>이었다.</p><p>Cron은 리눅스 계열(이 글에서는 우부투) OS에서 제공하는 시간을 기반으로 하는 Job 스케줄러이다.[1] Job은 실행의 단위이며, Cron에 의해 주기적으로 실행되는 Job을 Cron Job이라고 한다.</p><p>이 글에서 Cron Job은 배치 애플리케이션을 실행을 의미한다.</p><p>Contab(Cron table) 파일은 Cron job과 실행 시간을 기술한 설정 파일이다. Cron은 Crontab 파일을 참조하여 Cron Job을 실행한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*cir9lQ28c_cWSMTI.png" /><figcaption>Crontab 파일 [출처 : <a href="https://en.wikipedia.org/wiki/Cron]">https://en.wikipedia.org/wiki/Cron]</a></figcaption></figure><h3>도커화된 우분투에서 Cron job 실행하기</h3><p>맨땅에서 시작하기보다는 <a href="https://www.ekito.fr/people/run-a-cron-job-with-docker/">Run a cron job with Docker</a> 글을 참고하여 시작했다.</p><p>Crontab 파일에 등록한 Cron job은 1분마다 수행되며, <a href="http://manpages.ubuntu.com/manpages/trusty/en/man1/echo.1plan9.html">echo</a> 명령어로 “Hello world”를 출력하고 이를 리다이렉션Redirection(&gt;&gt;)으로 /var/log/cron.log에 파일로 기록한다.</p><pre>* * * * * root echo &quot;Hello world&quot; &gt;&gt; /var/log/cron.log<br># An empty line is required at the end of <strong>this</strong> file <strong>for</strong> a valid cron file.</pre><p>도커 이미지를 만드는데 필요한 <a href="https://docs.docker.com/engine/reference/builder/">Dockerfile</a>은 우분투(ubuntu 14.04)를 기본 이미지로 작성하였다.</p><pre>FROM ubuntu:14.04<br># crontab 파일을 cron 디렉토리에 추가<br>ADD crontab /etc/cron.d/hello-cron<br># 실행 권한 부여<br>RUN chmod 0644 /etc/cron.d/hello-cron<br># Cron 실행<br>CMD cron</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/488/0*qYx6WcAtBma8MB_5.png" /></figure><p>도커 <a href="https://docs.docker.com/engine/reference/commandline/build/">build</a> 명령어로 도커 이미지를 만들고, 도커 <a href="https://docs.docker.com/engine/reference/run/#general-form">run</a> 명령어로 도커 컨테이너를 -d 옵션(Detached mode : 보통 데몬 모드라고 부르며 컨테이너가 백그라운드로 실행 한다)로 실행시켰다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/669/0*yquw3z9rBaOr6xnI.png" /></figure><p>도커 <a href="https://docs.docker.com/engine/reference/commandline/ps/">ps</a> 명령어로 도커 컨테이너 잘 실행되고 있는지 확인해 보았는데…</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/772/0*VHf7r1hzifFppnVU.png" /></figure><p>실행 중인 컨테이너가 없다?!</p><p>ps 명령어에 -a 옵션(Show all containers — default shows just running)을 추가하여 전체 컨테이너 상태를 확인해 보면..</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/999/0*gTPnQE1BST7S8UYw.png" /></figure><p><strong><em>컨테이너가 종료(Exited) 되었다?!</em></strong></p><p>왜 그럴까? 답은 <a href="http://www.popit.kr/author/babokim/">김형준</a> 님의 글(<a href="http://www.popit.kr/%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EC%B2%98%EC%9D%8C-docker-%EC%A0%91%ED%95%A0%EB%95%8C-%EC%98%A4%EB%8A%94-%EB%A9%98%EB%B6%95-%EB%AA%87%EA%B0%80%EC%A7%80/">개발자가 처음 Docker 접할때 오는 멘붕 몇가지</a>)에 잘 나와 있다.</p><blockquote>Docker 컨테이너에서 실행되는 애플리케이션 서버(DB 서버 포함)은 back ground 모드가 아닌 fore ground 모드로 실행해야 한다.</blockquote><p><strong>그렇다. cron은 기본적으로 Backgroud 모드였던 것이었다. cron을 Foreground 모드로 실행하려면 -f 옵션 추가하여 실행해 주어야 한다.</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/999/0*1JY3BW8N0b6D1DM3.png" /><figcaption>출처 : <a href="http://manpages.ubuntu.com/manpages/trusty/en/man8/cron.8.html">http://manpages.ubuntu.com/manpages/trusty/en/man8/cron.8.html</a></figcaption></figure><p>Dockerfile을 수정하여 컨테이너를 다시 실행하면 컨테이너가 종료되지 않고 실행된다.</p><pre># ...<br># Cron 실행<br>CMD cron -f</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/860/0*5qBGMV6Q3SjbAhk2.png" /></figure><p>실제로 Crontab 파일에 등록한 Cron Job이 잘 수행되고 있는 확인하기 위해 필자는 실행 중인 도커 컨테이너에 도커 <a href="https://docs.docker.com/engine/reference/commandline/exec/">exec</a> 명령어로 우분투에 직접 접속하여 로그 파일을 확인하였다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/604/0*MEs-8IwiH_psZtvP.png" /></figure><h3>로그는 도커 logs 명령어로 확인할 수 있도록 변경하기</h3><p>도커 컨테이너에서 애플리케이션 로그는 파일로 기록하는 것이 아니라 표준 출력 또는 표준 에러로 출력해야 한다. 이 또한 <a href="http://www.popit.kr/author/babokim/">김형준</a> 님의 글에서 그 이유를 찾을 수 있다.</p><blockquote>Docker 는 컨테이너에서 STDOUT나 STDERR로 출력하는 모든 메시지를 Host OS의 특정 디렉토리에 저장하고 이를 쉽게 조회할 수 있는 명령도 제공한다(docker logs 명령). 따라서 모든 로그를 표준 출력으로 보내면 쉽게 로그에 접근할 수 있게 된다.이 방식도 문제가 존재하는데 이 로그 파일을 하나의 파일로 관리하게 되면 파일이 너무 커지게 되어 스토리지를 모두 차지하게 되는 문제가 있다. 최근 버전의 Docker에서는 로그 파일을 롤링할 수 있는 기능을 제공하는데 이 방식을 사용할 경우 반드시 이 옵션을 사용하는 것을 권장한다. — <a href="http://www.popit.kr/%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EC%B2%98%EC%9D%8C-docker-%EC%A0%91%ED%95%A0%EB%95%8C-%EC%98%A4%EB%8A%94-%EB%A9%98%EB%B6%95-%EB%AA%87%EA%B0%80%EC%A7%80/">개발자가 처음 Docker 접할때 오는 멘붕 몇가지</a> 중 일부 발췌</blockquote><p>Cron Job에서 리다이렉션을 사용하여 파일로 남기던 부분을 제거하였다.</p><pre># * * * * * root echo &quot;Hello world&quot; &gt;&gt; /var/log/cron.log<br>* * * * * root echo &quot;Hello world&quot;</pre><p>컨테이너를 다시 실행하고 도커 <a href="https://docs.docker.com/engine/reference/commandline/logs/">logs</a> 명령어로 실행 중인 컨테이너의 로그를 확인해 보면..</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/533/0*aCgq9f_5Erfxcagx.png" /></figure><p>필자가 기대했던 것과는 달리 아무것도 나오지 않는다.</p><p>분명히 echo 명령어는 표준 출력(standard output) 인데 왜 도커 logs 명령어에는 나오지 않을까?</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*orJtyzoQoYFlkOWE.png" /><figcaption>출처 : <a href="http://manpages.ubuntu.com/manpages/trusty/en/man1/echo.1plan9.html">http://manpages.ubuntu.com/manpages/trusty/en/man1/echo.1plan9.html</a></figcaption></figure><p>가설을 세워 보았다.</p><blockquote>docker logs 명령어는 Forgound로 실행된 프로세스의 표준 출력만 보여 주는 것은 아닐까?</blockquote><p>증명해 보자.</p><p>Dockerfile을 보면 Forground 프로세스는 Cron이다. crontab 파일을 Cron이 사용하는 표준 출력으로 리다이렉션 하도록 변경하였다.</p><pre>* * * * * root echo &quot;Hello world&quot; &gt; /proc/1/fd/1 2&gt;/proc/1/fd/2<br># An empty line is required at the end of <strong>this</strong> file <strong>for</strong> a valid cron file.</pre><p>리다이렉션 부분을 아래처럼 변경 후 컨테이너를 다시 실행하면 로그를 확인할 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/500/0*JRJaPY8UQypk9TVQ.png" /></figure><h3>배치 애플케이션을 Cron job으로</h3><p>Cron Job에서 “Hello World”를 출력하던 것을 배치 애플리케이션 실행하는 것으로 변경할 차례다.</p><p>배치 애플리케이션은 Java로 만들었으며, 실행 가능한 <a href="https://ko.wikipedia.org/wiki/JAR_(%ED%8C%8C%EC%9D%BC_%ED%8F%AC%EB%A7%B7)">JAR</a>Java ARchive(batch-sample.jar)로 패키징 하였다. 그리고 Cron Job에서 실행할 수 있도록 쉘 스크립트를 만들었다.</p><pre>#!/bin/bash<br>java -jar /app/batch-sample.jar</pre><p>crontab 파일 역시 이에 맞추어 변경해 주었다.</p><pre>* * * * * root . /app/batch-start.sh &gt; /proc/1/fd/1 2&gt;/proc/1/fd/2<br># An empty line is required at the end of <strong>this</strong> file <strong>for</strong> a valid cron file.</pre><p>JAR로 패키징된 배치 애플리케이션을 실행하기 위해서는 <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">JDK</a>Java Development Kit가 필요하다.</p><p>JDK를 따로 설치하지는 않고 우분투 이미지에 JDK가 더해진 이미지(<a href="https://hub.docker.com/r/pangpanglabs/java8/">pangpanglabs/java8</a>)를 Dockerfile 기본 이미지로 변경하였다.</p><pre>FROM pangpanglabs/java8<br># Batch 애플리케이션<br>ADD ./batch-sample.jar /app/batch-sample.jar<br>ADD ./batch-start.sh /app/batch-start.sh<br>RUN chmod 755 /app/batch-start.sh<br># cron<br>ADD crontab /etc/cron.d/batch-sample-cron<br>RUN chmod 0644 /etc/cron.d/batch-sample-cron<br>CMD cron -f</pre><p>컨테이너를 다시 실행하고 로그를 확인해 보면..</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/618/0*l2NJtlbBnNn5Zlg-.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/496/0*pK2OIXKHintmQ0KQ.png" /></figure><p><em>java: not found</em></p><p>왜 java 명령어를 찾지 못하는 걸까?</p><p>batch-start.sh에서 java 명령어를 사용했다. 이렇게 사용하기 위해서는 JDK bin 디렉토리(<a href="https://hub.docker.com/r/pangpanglabs/java8/">pangpanglabs/java8</a> 도커 이미지에서는 /usr/java/latest/bin)가 우부투 PATH 환경 변수에 추가되어 있어야 한다.</p><p>도커 <a href="https://docs.docker.com/engine/reference/commandline/exec/">exec</a> 명령어로 실행 중인 컨테이너에 접속하여 PATH 환경 변수를 확인해 보면…</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/660/0*K8RjdeJK8-qnjQqg.png" /></figure><p>JDK bin 디렉토리가 PATH 환경 변수에 추가되어 있다.</p><p>왜 Cron Job에서는 java 명령어를 찾지 못하는 걸까?</p><p>다시 가설을 세워 보았다.</p><blockquote>Cron Job 실행 할 때 PATH가 다른것은 아닐까?</blockquote><p>증명해 보자. Crontab 파일을 변경하여 Cron Job이 실행될 때 PATH 환경 변수를 출력해 보았다.</p><pre>* * * * * root echo $PATH &gt; /proc/1/fd/1 2&gt;/proc/1/fd/2<br># An empty line is required at the end of <strong>this</strong> file <strong>for</strong> a valid cron file.</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/484/0*d_8sY_AULg8WcGuH.png" /></figure><p><strong>PATH 환경 변수가 다르다!</strong></p><p>java 명령어를 아래처럼 절대 경로로 사용하면 손쉽게(?) 해결할 순 있겠지만 여전히 문제는 남아 있다.</p><pre>#!/bin/bash<br>/usr/java/latest/bin/java -jar /app/batch-sample.jar</pre><h3>애플리케이션 환경 변수</h3><p>애플리케이션이 실행되기 위해서 필요한 정보(예. 데이터베이스 접속 정보)는 일반적으로 설정 파일로 분리하여 관리한다. 이러한 애플리케이션 설정 파일은 애플리케이션이 배포되는 서버 환경(개발, 테스트, 스테이징, 운영 등)에 따라 달라진다.</p><p>일반적으로 서버 환경별로 설정 파일을 만들고 애플리케이션에서는 배포되는 서버 OS 환경 변수에 값에 따라 동적으로 설정 파일을 적용한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/682/0*JE0tXV6daDze-Q-f.png" /><figcaption>이미지 출처 : <a href="https://stackoverflow.com/questions/43295904/spring-boot-always-using-the-same-profile">https://stackoverflow.com/questions/43295904/spring-boot-always-using-the-same-profile</a></figcaption></figure><p>도커를 사용하는 경우 환경 변수를 도커 컨테이너 실행 시 -e 옵션으로 추가할 수 있다.</p><pre>docker run -d --name batch-sample -e &quot;APPLICATION_PROFILE=production&quot; batch-sample:latest</pre><p>이렇게 하면 도커 이미지를 애플리케이션이 배포되는 서버 환경마다 만들 필요 없이 환경 변수만 달리 설정하여 컨테이너를 실행하면 된다.</p><h3>도커 명령어로 설정한 환경 변수를 Cron Job에서 사용하기</h3><p>배치 애플케이션은 OS 환경 변수를 참조하여 애플리케이션 설정 파일을 동적으로 사용하고 있다. 그리고 Cron Job으로 배치 애플리케이션을 실행한다.</p><p>앞서 Cron job을 실행할 때 환경 변수가 다르다는 것을 확인하였다.</p><p>아래와 같이 애플리케이션 환경 변수를 추가하여 컨테이너를 실행하였을 때 Cron Job에서 ‘APPLICATION_PROFILE’ 값을 어떻게 참조할 수 있을까?</p><pre>docker run -d --name batch-sample -e &quot;APPLICATION_PROFILE=production&quot; batch-sample:latest</pre><p><a href="https://ypereirareis.github.io/blog/2016/02/29/docker-crontab-environment-variables/">Access environment variables from crontab into a docker container</a>에서 답을 찾을 수 있다.</p><p>도커 이미지를 만들 때 모든 환경 변수를 export 하여 쉘 스크립트로 만든다.(/root/envs.sh)</p><pre>#!/bin/bash<br># export all environment variables to use in cron<br>env | sed &#39;s/^\(.*\)$/export \1/g&#39; &gt; /root/envs.sh<br>chmod +x /root/envs.sh<br>cron -f</pre><p>envs.sh를 Cron Job에서 함께 실행시켜준다.</p><pre>* * * * * root . /root/envs.sh;/app/batch-start.sh &gt; /proc/1/fd/1 2&gt;/proc/1/fd/2<br># An empty line is required at the end of <strong>this</strong> file <strong>for</strong> a valid cron file.</pre><p>이렇게 되면 java 명령어를 절대 경로로 기술해 줄 필요도 없게 된다.</p><pre>#!/bin/bash<br>java -jar /app/batch-sample.jar</pre><p>최종 Dockerfile은 아래와 같다.</p><pre>FROM pangpanglabs/java8<br># Batch 애플리케이션<br>ADD ./batch-sample.jar /app/batch-sample.jar<br>ADD ./batch-start.sh /app/batch-start.sh<br>RUN chmod 755 /app/batch-start.sh<br># cron<br>ADD crontab /etc/cron.d/batch-sample-cron<br>RUN chmod 0644 /etc/cron.d/batch-sample-cron<br>ADD bootstrap.sh /app/bootstrap.sh<br>RUN chmod +x /app/bootstrap.sh<br>CMD [&quot;/app/bootstrap.sh&quot;]</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*fb4x_LKIwYIHerw4.png" /></figure><h3>GitHub</h3><p>이 글에서 사용한 모든 코드는 필자의 <a href="https://github.com/YooYoungmo/article-docker-ubuntu-cron">GitHub</a>에서 확인할 수 있다.</p><h3>덧붙여</h3><p>필자가 사용해 보진 않았지만 <a href="https://kubernetes.io/">쿠버네이트</a>Kubernetes 를 사용하고 있다면 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/">쿠버네이트 CronJob</a> 사용을 검토해 보는 것도 좋을 것 같다.</p><h3>주석</h3><p>[1] <a href="https://en.wikipedia.org/wiki/Cron">https://en.wikipedia.org/wiki/Cron</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b3c288c86eab" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ID로 다른 애그리게잇을 참조하라]]></title>
            <link>https://medium.com/@SlackBeck/id%EB%A1%9C-%EB%8B%A4%EB%A5%B8-%EC%95%A0%EA%B7%B8%EB%A6%AC%EA%B2%8C%EC%9E%87%EC%9D%84-%EC%B0%B8%EC%A1%B0%ED%95%98%EB%9D%BC-4d64f1591e60?source=rss-dd736b47f7d7------2</link>
            <guid isPermaLink="false">https://medium.com/p/4d64f1591e60</guid>
            <category><![CDATA[domain-driven-design]]></category>
            <category><![CDATA[hibernate]]></category>
            <category><![CDATA[jpa]]></category>
            <category><![CDATA[aggregates]]></category>
            <category><![CDATA[spring]]></category>
            <dc:creator><![CDATA[Yoo Young-mo]]></dc:creator>
            <pubDate>Thu, 07 Mar 2019 04:58:10 GMT</pubDate>
            <atom:updated>2019-03-08T04:10:34.807Z</atom:updated>
            <content:encoded><![CDATA[<p>필자는 <a href="https://www.popit.kr/%EC%97%90%EA%B7%B8%EB%A6%AC%EA%B2%8C%EC%9E%87-%ED%95%98%EB%82%98%EC%97%90-%EB%A6%AC%ED%8C%8C%EC%A7%80%ED%86%A0%EB%A6%AC-%ED%95%98%EB%82%98/">지난 글</a> 전반부에서 <a href="http://www.yes24.com/Product/goods/5312881?scode=032&amp;OzSrank=1">도메인 주도 설계Domain-Driven Design</a>에서 말하는 <a href="https://en.wikipedia.org/wiki/Domain-driven_design#Building_blocks">구조물 중 하나</a>인 조립물AGGREGATE[1]에 대해 이야기했다. 조립물을 구현하다 보면 다른 조립물을 참조해야 할 때가 있다. 이를 구현하는 방식은 크게 조립물의 루트 엔터티Root Entity 객체를 참조(포인터) 하는 것과 식별자로 어디서든 쓸 수 있는 값을 사용하는 방법(ID)이 있다.</p><p><a href="http://www.yes24.com/24/Goods/25100510?Acode=101">도메인 주도 설계 구현Implementing Domain-Driven Design</a>의 저자 반 버논Vernon, Vaughn은 <strong><em>“ID로 다른 애그리게잇을 참조하라”</em></strong>라고 말했다. 이 글은 <a href="https://www.popit.kr/%EC%97%90%EA%B7%B8%EB%A6%AC%EA%B2%8C%EC%9E%87-%ED%95%98%EB%82%98%EC%97%90-%EB%A6%AC%ED%8C%8C%EC%A7%80%ED%86%A0%EB%A6%AC-%ED%95%98%EB%82%98/">지난 글</a>에 이어 주문 도메인 예시를 통해 ID로 다른 조립물을 참조하는 방식에 대해 설명한다.</p><h3>주문 예시</h3><p>아래와 같이 Order 조립물과 Customer 조립물이 존재하고 Order 조립물이 Customer 조립물을 참조한다고 생각해보자.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*i90qsZmdRnCDsbN4.png" /></figure><p>Customer 조립물은 <a href="https://en.wikipedia.org/wiki/Java_Persistence_API">JPAJava Persistence API</a> 코드로 아래와 같이 구현할 수 있다.(Order 코드는 <a href="https://www.popit.kr/%EC%97%90%EA%B7%B8%EB%A6%AC%EA%B2%8C%EC%9E%87-%ED%95%98%EB%82%98%EC%97%90-%EB%A6%AC%ED%8C%8C%EC%A7%80%ED%86%A0%EB%A6%AC-%ED%95%98%EB%82%98/">이전 글</a>을 참조하라)</p><pre>@Entity<br>@Table(name = &quot;customers&quot;)<br><strong>public</strong> <strong>class</strong> <strong>Customer</strong> {<br>  @Id<br>  @GeneratedValue<br>  <strong>private</strong> Long id;<br>  <strong>private</strong> String name;<br>  @OneToMany(mappedBy = &quot;customer&quot;, cascade = CascadeType.ALL)<br>  <strong>private</strong> List&lt;BillingAddress&gt; billingAddresses = <strong>new</strong> ArrayList&lt;&gt;();<br>  // ...<br>}<br>@Entity<br>@Table(name = &quot;billing_addresses&quot;)<br><strong>public</strong> <strong>class</strong> <strong>BillingAddress</strong> {<br>  @Id<br>  @GeneratedValue<br>  <strong>private</strong> Long id;<br>  <strong>private</strong> String zipCode;<br>  @ManyToOne<br>  @JoinColumn(name = &quot;customer_id&quot;, referencedColumnName = &quot;id&quot;)<br>  <strong>private</strong> Customer customer;<br>  // ...<br>}</pre><h3>객체 참조</h3><p>객체 참조(포인터) 방식은 Order 조립물 루트 엔터티에 참조할 Customer 조립물 루트 엔터티를 추가함으로써 구현할 수 있다.</p><pre>@Entity<br>@Table(name = &quot;orders&quot;)<br><strong>public</strong> <strong>class</strong> <strong>Order</strong> {<br>  // ...<br>  @ManyToOne<br>  @JoinColumn(name = &quot;customer_id&quot;, referencedColumnName = &quot;id&quot;)<br>  <strong>private</strong> Customer customer;<br>  // ...<br>}</pre><p>Order 조립물과 Customer 조립물은 직접 연결되기 때문에 Order 조립물을 생성, 수정할 때 Customer 조립물 객체 참조가 필요하다.</p><pre>Customer customer = customerRepository.findById(customerId);<br>Order order = <strong>new</strong> Order.Builder()<br>    .customer(customer)<br>    .shippingAddress(<strong>new</strong> ShippingAddress(&quot;12345&quot;, &quot;Yoo Young-mo&quot;))<br>    .addLineItem(<strong>new</strong> LineItem(&quot;P-0001&quot;, &quot;상품 A&quot;, 1000l, 2))<br>    .addLineItem(<strong>new</strong> LineItem(&quot;P-0002&quot;, &quot;상품 B&quot;, 2000l, 1))<br>    .addOrderPayment(<strong>new</strong> CreditCardPayment(2000l, &quot;1234-123&quot;))<br>    .addOrderPayment(<strong>new</strong> CreditCardPayment(2000l, &quot;010-0000-0000&quot;))<br>    .build();</pre><p>데이터베이스에서 Order 조립물 객체 인스턴스를 가져올 때[2] Customer 조립물을 함께 가져오기 때문에 Order 조립물만 가져오는 것보다 더 많은 시간과 메모리를 사용한다.</p><p>또한, Order 조립물은 언제 참조하게 될지 모르는 Customer 조립 객체 참조를 항상 가지고 있어야 한다. 이 글에서는 이해를 위해 단순하게 Order 조립물이 하나의 객체 참조만 가지고 있지만 실제로는 여러 개의 조립물 객체 참조를 가지는 경우가 많다.</p><h3>전역 고유 식별자 참조</h3><p>반 버논은 그의 책에서 전역 고유 식별자를 이용하여 다른 애그리게잇을 참조하라고 말했다.</p><blockquote>외부 애그리게잇보다는 참조를 사용하되, 객체 참조(포인터)를 직접 사용하지 말고 전역 고유 식별자를 이용하자. — 도메인 주도 설계 구현, 465 쪽</blockquote><p>이전 코드를 아래와 같이 리팩토링 할 수 있다.</p><pre>@Entity<br>@Table(name = &quot;orders&quot;)<br><strong>public</strong> <strong>class</strong> <strong>Order</strong> {<br>  // ...<br>  <strong>private</strong> Long customerId;<br>}</pre><pre>Order order = <strong>new</strong> Order.Builder()<br>      .customerId(customerId)<br>      .shippingAddress(<strong>new</strong> ShippingAddress(&quot;12345&quot;, &quot;Yoo Young-mo&quot;))<br>      .addLineItem(<strong>new</strong> LineItem(&quot;P-0001&quot;, &quot;상품 A&quot;, 1000l, 2))<br>      .addLineItem(<strong>new</strong> LineItem(&quot;P-0002&quot;, &quot;상품 B&quot;, 2000l, 1))<br>      .addOrderPayment(<strong>new</strong> CreditCardPayment(2000l, &quot;1234-123&quot;))<br>      .addOrderPayment(<strong>new</strong> CreditCardPayment(2000l, &quot;010-0000-0000&quot;))<br>      .build();</pre><p>객체 참조에 비해 조립물 간의 경계가 명확해지며, 성능 면에서 이점이 있다.</p><blockquote>추론 객체 참조inferred object reference를 가진 애그리게잇은 참조를 즉시 가져올 필요가 없기 때문에 당연히 더 작아진다. 인스턴스를 가져올 때 더 짧은 시간과 메모리가 필요하기 때문에, 모델의 성능도 나아진다. — 도메인 주도 설계 구현, 466 쪽</blockquote><h3>모델 탐색</h3><p>Order 조립물에서 주문(placeOrder)을 하려면 Customer 조립물 객체 참조가 필요하다고 가정해 보자. ID로 참조하고 있는 상황에서 어떻게 Customer 조립 객체 참조를 찾을까?</p><blockquote>애그리게잇의 행동을 호출하기에 앞서 리파지토리나 도메인 서비스를 통해 의존 관계에 있는 객체를 조회하는 방법도 추천할 만하다. 클라이언트 에플리케이션 서비스는 이를 제어하며 애그리게잇으로 디스패치할 수 있게 된다. — 도메인 주도 설계 구현, 467 쪽</blockquote><p>아래와 같은 코드로 구현할 수 있다. 애플리케이션 서비스에서 Order 조립물의 placeOrder 메서드(행동)를 호출하기 앞서 리파지토리REPOSITORY를 사용하여 Customer 조립 객체를 얻는다.</p><pre>@Service<br><strong>public</strong> <strong>class</strong> <strong>OrderService</strong> {<br>  // ... <br>  @Transactional<br>  <strong>public</strong> <strong>void</strong> <strong>placeOrder</strong>(<strong>final</strong> Long orderId) {<br>    Order order = orderRepository.findById(orderId);<br>    // ID를 사용하여 Customer 획득<br>    <strong>final</strong> Long customerId = order.getCustomerId();<br>    Customer customer = customerRepository.findById(customerId);<br>    // 주문<br>    order.placeOrder(customer);<br>    // ...<br>  }<br>}</pre><h3>주석</h3><p>[1] 조립물이라는 표현은 글을 검토해 주신 <a href="https://www.popit.kr/author/tony">안영회</a> 님이 제안한 애그리게잇을 대신하는 우리말 표현이다. 자세한 내용은 <a href="https://www.popit.kr/aggregate%EB%A5%BC-%EC%95%A0%EA%B7%B8%EB%A6%AC%EA%B2%8C%EC%9E%87-%EB%8C%80%EC%8B%A0-%EC%A1%B0%EB%A6%BD%EB%AC%BC%EB%A1%9C-%EC%93%B4-%EC%82%AC%EC%97%B0/">Aggregate를 애그리게잇 대신 조립물로 쓴 사연</a> 참고하라.</p><p>[2] 도메인 주도 설계에서는 이를 재구성reconstiution이라고 부른다.</p><h3>참고 자료</h3><ul><li><a href="http://www.yes24.com/Product/Goods/25100510?Acode=101">도메인 주고 설계 구현 — 반 버논</a> 저</li><li><a href="http://www.yes24.com/24/goods/5312881?scode=032&amp;OzSrank=1">도메인 주도 설계 — 에릭 에반스</a> 저</li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4d64f1591e60" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Java 8 Date(Time) 와 JPA 그리고 스프링 부트]]></title>
            <link>https://medium.com/@SlackBeck/java-8-date-time-%EC%99%80-jpa-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8-7a02eea23d29?source=rss-dd736b47f7d7------2</link>
            <guid isPermaLink="false">https://medium.com/p/7a02eea23d29</guid>
            <category><![CDATA[datetime]]></category>
            <category><![CDATA[jpa]]></category>
            <category><![CDATA[spring-boot]]></category>
            <category><![CDATA[java8]]></category>
            <category><![CDATA[hibernate]]></category>
            <dc:creator><![CDATA[Yoo Young-mo]]></dc:creator>
            <pubDate>Fri, 01 Feb 2019 01:11:36 GMT</pubDate>
            <atom:updated>2019-02-01T01:11:36.735Z</atom:updated>
            <content:encoded><![CDATA[<p>악평(?)이 자자하던 Java 날짜와 시간Date and Time 라이브러리[1]는 <a href="http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html">Java 8 버전부터 완전히 새로워졌다.</a> 이 글은 새로워진 Java 날짜와 시간(이하 Java8 날짜와 시간)을 <a href="https://spring.io/projects/spring-boot">스프링 부트Spring Boot</a>+ <a href="https://en.wikipedia.org/wiki/Java_Persistence_API">JPAJava Persistence API</a>(<a href="http://hibernate.org/orm/">Hibernate</a>) 환경에서 사용하는 방법을 다룬다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*wN7iIMT1ii4N5kyV.png" /></figure><h3>기대와 다른 결과</h3><p>예시 코드는 스프링 부트 1.5 으로 작성하였고 JPA (spring-boot-starter-data-jpa) 의존성을 추가하였다.[2]</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;<br>    //...<br>    &lt;parent&gt;<br>        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;<br>        &lt;version&gt;1.5.14.RELEASE&lt;/version&gt;<br>        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;<br>    &lt;/parent&gt;<br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        //...<br>    &lt;/dependencies&gt;<br>&lt;/project&gt;</pre><p>데이터베이스에 저장될 Member 엔티티Entitiy는 아래와 같다. createdTimeAt, createdDateAt에 Java8 날짜와 시간 객체인 LocalDate, LocalDateTime을 사용하였다.</p><pre>//...<br><strong>import</strong> java.time.LocalDate;<br><strong>import</strong> java.time.LocalDateTime;<br>@Entity<br><strong>public</strong> <strong>class</strong> <strong>Member</strong> {<br>    @Id<br>    @GeneratedValue<br>    <strong>private</strong> Long id;<br>    <strong>private</strong> LocalDateTime createdTimeAt;<br>    <strong>private</strong> LocalDate createdDateAt;<br>    <strong>public</strong> <strong>Member</strong>() {<br>        createdDateAt = LocalDate.now();<br>        createdTimeAt = LocalDateTime.now();<br>    }<br>    // ...<br>}</pre><p>JPA로 Member 엔티티 데이터베이스에 저장하면 Java8 LocalDate와 LocalDateTime는 JDBC Type인 Date와 Timestamp로 변환 되어 저장될까?</p><p>코드를 실행하면 실제 데이터베이스에는 <strong>기대했던 Date와 Timestamp가 아닌 Binary로 저장</strong>된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*BQNSFlWc7fJmrNnX.png" /><figcaption>갈무리. Binary로 저장된 LocalDate, LocalDateTime</figcaption></figure><p>하이버네이트에서 자동 생성한 <a href="https://en.wikipedia.org/wiki/Data_definition_language">DDLData Definition Language</a>을 확인해 보면[3] 데이터 타입을 Binary로 생성하고 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/378/0*P1cqQF4lxpDKrUzn.png" /><figcaption>갈무리. 하이버네이트 DDL SQL 로그</figcaption></figure><h3>JPA 2.2 명세Specification</h3><p>JPA는 명세일 뿐이고 실제로 명세를 구현하는 구현체는 따로 있다. 스프링 부트는 기본적으로 JPA 구현체를 하이버네이트를 사용한다. Java 8 날짜와 시간은 JPA 2.2 명세[3]에 추가되었으며 하이버네이트는 5.3부터 JPA 2.2를 지원한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/854/0*nNdpNW06miT0sJlb.png" /><figcaption>출처 : <a href="http://hibernate.org/orm/releases/5.3/">http://hibernate.org/orm/releases/5.3/</a></figcaption></figure><p>현재 스프링 부트 최근 릴리즈(2.0.2)는 하이버네이트 5.2(JPA 2.1)를 그리고 이전 릴리즈인 1.5는 하이버네이트 5.0(JPA 2.1)을 사용한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/644/1*Bc9UKCOCS7Whd9EAzhs56g.png" /></figure><p>스프링 부트 + JPA 환경에서 Java 8 날짜와 시간을 사용하려면 스프링 부트가 하이버네이트 5.3(JPA 2.2)을 지원하기를 기다려야 하는 걸까?</p><p><strong>결론부터 말하자면 JPA 2.2를 지원하지 않더라도 사용할 수 있다.</strong></p><h3>명세는 명세일 뿐</h3><p>관점을 좁혀서 하이버네이트만 살펴보자. <strong>하이버네이트는 5.0부터 JPA 명세와 상관없이 Java 8 날짜와 시간을 지원</strong>한다. 다만 버전에 따라 사용법이 조금 다르다.</p><p>하이버네이트 5.0, 5.1의 경우 Java 8 날짜와 시간을 사용하기 위해서는 classpath에 hibernate-java8 라이브러리를 추가해 주어야 한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*HKDajcyOeRG0BVYL.png" /><figcaption>출처 : <a href="http://docs.jboss.org/hibernate/orm/5.0/userguide/html_single/Hibernate_User_Guide.html#basic">http://docs.jboss.org/hibernate/orm/5.0/userguide/html_single/Hibernate_User_Guide.html#basic</a></figcaption></figure><p>아래는 스프링 부트가 아닌 하이버네이트만 사용하는 프로젝트에 hibernate-java8 라이브러리 의존성을 추가한 것이다.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;<br>         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;<br>    //...<br>    &lt;properties&gt;<br>        &lt;hibernate.version&gt;5.0.12.Final&lt;/hibernate.version&gt;<br>    &lt;/properties&gt;<br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br>            &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;<br>            &lt;version&gt;${hibernate.version}&lt;/version&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br>            &lt;artifactId&gt;hibernate-java8&lt;/artifactId&gt;<br>            &lt;version&gt;${hibernate.version}&lt;/version&gt;<br>        &lt;/dependency&gt;<br>        //...<br>    &lt;/dependencies&gt;<br>&lt;/project&gt;</pre><p>이렇게 hibernate-java8 라이브러리 의존성을 추가 후 위의 Member 엔티티를 JPA로 저장하면 아래와 같이 Date와 Timestamp로 저장되는 것을 확인할 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/602/0*EsjERyuaOT9D0XH2.png" /><figcaption>갈무리. Date와 Timestamp로 저장된 LocalDate, LocalDateTime</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/794/0*MV9oIDMCwVs2vovM.png" /><figcaption>갈무리. 하이버네이트 DDL SQL 로그</figcaption></figure><p>하이버네이트 5.2부터 hibernate-java8 의존성 추가 필요 없이 Java 8 날짜와 시간을 사용할 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*Fc2k6mknzCXJrqDk.png" /><figcaption><a href="https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#basic">https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#basic</a></figcaption></figure><p>코드는 아래와 같다.[5]</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;<br>         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;<br>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br>    &lt;properties&gt;<br>        &lt;hibernate.version&gt;5.2.8.Final&lt;/hibernate.version&gt;<br>    &lt;/properties&gt;<br>    &lt;dependencies&gt;<br>        &lt;!-- JPA --&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br>            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;<br>            &lt;version&gt;${hibernate.version}&lt;/version&gt;<br>        &lt;/dependency&gt;<br>        //...<br>    &lt;/dependencies&gt;<br>    //...<br>&lt;/project&gt;</pre><p>왜 하이버네이트 5.0, 5.1는hibernate-java8 라이브러리 추가해야 하고 5.2는 필요 없는 것일까?</p><p>하이버네이트 5.0과 5.1의 최소 Java 버전은 6이고, 5.2의 최소 Java 버전은 8이다. 따라서 필자의 추측으로는 하이버네이트 5.0, 5.1는 Java 8을 사용하지 않는(6,7 버전) 프로젝트를 위해서 따로 분리한 것으로 보인다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/786/0*7IJxuxwzbEaNi8Kf.png" /><figcaption><a href="http://hibernate.org/orm/releases/5.2/">http://hibernate.org/orm/releases/5.2/</a></figcaption></figure><h3>그렇다면 스프링 부트 + JPA 에서는?</h3><h3>스프링 부트 1.5</h3><p>1.5는 Hibernate 5.0을 사용하고 있다. 따라서 hibernate-java8 모듈 의존성을 추가해 주면 된다. 이미 스프링 부트 부모 Maven <a href="https://maven.apache.org/pom.html#What_is_the_POM">POMProject Object Model</a>에 버전이 선언되어 있기 때문에 버전 선언은 필요 없다.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;<br>    //...<br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br>            &lt;artifactId&gt;hibernate-java8&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        //...<br>    &lt;/dependencies&gt;<br>&lt;/project&gt;</pre><h3>스프링 부트 2.0</h3><p>2.0은 Hibernate 5.2를 사용하고 있다. 따라서 추가 설정 필요 없이 JPA 엔티티에 Java8 날짜와 시간을 그냥 쓰면 된다.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;<br>    //...<br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        //...<br>    &lt;/dependencies&gt;<br>&lt;/project&gt;</pre><h3>왜 스프링 부트에는 기본적으로 hibernate-java8 의존성이 추가되어 있지 않나?</h3><p>이 역시 하이버네이트와 마찬가지로 Java 버전 때문일 것이라고 추정된다. 스프링 부트 1.5는 최소 Java 7이고 2.0은 Java 8이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ybLzqrd3dYxXo-aN.png" /><figcaption>스프링 부트 1.5 System Requirements 출처 : <a href="https://docs.spring.io/spring-boot/docs/1.5.13.RELEASE/reference/htmlsingle/#getting-started-system-requirements">https://docs.spring.io/spring-boot/docs/1.5.13.RELEASE/reference/htmlsingle/#getting-started-system-requirements</a></figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*PwGuv3ZfnbaitQn-.png" /><figcaption>스프링 부트 2.0 System Requirements 출처 : <a href="https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/htmlsingle/#getting-started-system-requirements">https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/htmlsingle/#getting-started-system-requirements</a></figcaption></figure><h3>One more thing…</h3><p>엔티티를 사용하다 보면 생성일(createdTimeAt)과 수정일(updateTimeAt)을 관리해 주어야 할 때가 많다. 각 엔티티마다 객체가 생성되거나 수정될 때 현재 시간을 설정하는 코드를 작성해야 하는 것은 번거로운 일이다.</p><pre><strong>import</strong> java.time.LocalDate;<br><strong>import</strong> java.time.LocalDateTime;<br>@Entity<br><strong>public</strong> <strong>class</strong> <strong>Member</strong> {<br>    @Id<br>    @GeneratedValue<br>    <strong>private</strong> Long id;<br>    <strong>private</strong> LocalDateTime createdTimeAt;<br>    <strong>private</strong> LocalDateTime updateTimeAt;<br>    <strong>public</strong> <strong>Member</strong>() {<br>        <strong>final</strong> LocalDateTime now = LocalDateTime.now();<br>        createdTimeAt = now;<br>        updateTimeAt = now;<br>    }<br>    //...<br>}</pre><p>하이버네이트 5.2 이상을 사용하고 있다면 Java8 날짜와 시간에 <a href="https://docs.jboss.org/hibernate/orm/5.2/javadocs/org/hibernate/annotations/CreationTimestamp.html">CreationTimestamp</a>과 <a href="https://docs.jboss.org/hibernate/orm/5.2/javadocs/org/hibernate/annotations/UpdateTimestamp.html">UpdateTimestamp</a>을 추가해 주면 시간 설정을 하이버네이트가 알아서 해준다.[6]</p><pre><strong>import</strong> org.hibernate.annotations.CreationTimestamp;<br><strong>import</strong> org.hibernate.annotations.UpdateTimestamp;<br><strong>import</strong> java.time.LocalDate;<br><strong>import</strong> java.time.LocalDateTime;<br>@Entity<br><strong>public</strong> <strong>class</strong> <strong>Member</strong> {<br>    @Id<br>    @GeneratedValue<br>    <strong>private</strong> Long id;<br>    @CreationTimestamp<br>    <strong>private</strong> LocalDateTime createdTimeAt;<br>    @UpdateTimestamp<br>    <strong>private</strong> LocalDateTime updateTimeAt;<br>    //...<br>}</pre><h3>주석</h3><p>[1] 자세한 Java의 날짜와 시간 라이브러리의 역사는 <a href="https://d2.naver.com/helloworld/645609">https://d2.naver.com/helloworld/645609</a> 에서 확인할 수 있다.</p><p>[2] 스프링 부트 골격이 되는 코드는 <a href="https://start.spring.io/">SPRING INITIALIZR</a>에서 생성하였다.</p><p>[3] 스프링 부트 설정 파일인 application.properties에 아래와 같이 추가하면 SQL 로그를 확인할 수 있다</p><pre><br>spring.jpa.properties.hibernate.show_sql=<strong>true</strong><br>spring.jpa.properties.hibernate.use_sql_comments=<strong>true</strong><br>spring.jpa.properties.hibernate.format_sql=<strong>true</strong></pre><p>[4] <a href="https://www.infoq.com/news/2018/01/improvements-jpa-22">Handy Improvements in JPA 2.2</a> — Java 8 date and time support</p><p>[5] 하이버네이트 5.0, 5.1과 5.2에 의존성 모듈이 다른 이유는 5.2 이전에는 JPA support 모듈이 분리되어 있었지만 5.2 부터 core 모듈로 합쳐졌기 때문이다.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;<br>         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;<br>    //...<br>    &lt;dependencies&gt;<br>        &lt;!-- Hibernate 5.0, 5.1 --&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br>            &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;<br>            &lt;version&gt;${hibernate.version}&lt;/version&gt;<br>        &lt;/dependency&gt;<br>        &lt;!-- Hibernate 5.2 --&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br>            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;<br>            &lt;version&gt;${hibernate.version}&lt;/version&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br>    //...<br>&lt;/project&gt;</pre><p>[6] 하이버네이트 5.0, 5.1의 경우 LocalDate와 LocalDateTime을 CreationTimestamp/UpdateTimestamp에서 지원하지 않는다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*nPHV8xSIth4gp8oO.png" /><figcaption><a href="https://docs.jboss.org/hibernate/orm/5.1/javadocs/org/hibernate/annotations/CreationTimestamp.html">https://docs.jboss.org/hibernate/orm/5.1/javadocs/org/hibernate/annotations/CreationTimestamp.html</a></figcaption></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7a02eea23d29" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[스프링 부트 Auto-configuration과 JPA(하이버네이트) SQL문 로깅]]></title>
            <link>https://medium.com/@SlackBeck/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8-auto-configuration%EA%B3%BC-jpa-%ED%95%98%EC%9D%B4%EB%B2%84%EB%84%A4%EC%9D%B4%ED%8A%B8-sql%EB%AC%B8-%EB%A1%9C%EA%B9%85-424de95ed171?source=rss-dd736b47f7d7------2</link>
            <guid isPermaLink="false">https://medium.com/p/424de95ed171</guid>
            <category><![CDATA[sql]]></category>
            <category><![CDATA[hibernate]]></category>
            <category><![CDATA[spring-boot]]></category>
            <category><![CDATA[jpa]]></category>
            <category><![CDATA[logging]]></category>
            <dc:creator><![CDATA[Yoo Young-mo]]></dc:creator>
            <pubDate>Wed, 30 Jan 2019 00:07:03 GMT</pubDate>
            <atom:updated>2019-01-30T00:07:03.665Z</atom:updated>
            <content:encoded><![CDATA[<p>JPA(하이버네이트)로 개발하다 보면 JPA가 자동으로 만들어 실행하는 SQL문을 확인하고 싶을 때가 있다. 이 글은 스프링 부트와 JPA를 함께 사용하는 환경에서 SQL문을 로깅Logging하는 방법을 소개한다.</p><h3>예제 프로젝트</h3><p>이해를 돕기 위해 간단한 스프링 부트 + JPA 예제 프로젝트를 만들고 SQL문 로깅을 추가해 보자.</p><p>예제 프로젝트는 스프링 부트에서 제공하는 부트스트랩Bootstrap 도구인 <a href="https://start.spring.io/">SPRING INITIALIZR</a>로 프로젝트를 만든다. 의존성으로 JPA와 별도로 데이터베이스 설치하지 않고 사용할 수 있는 <a href="http://www.h2database.com/html/main.html">H2</a>를 추가하여 프로젝트를 생성한다.[1]</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*I_hmvVNGWOoTunQ8.png" /><figcaption>갈무리. <a href="https://start.spring.io/">https://start.spring.io/</a></figcaption></figure><p>생성된 예제 프로젝트의 <a href="https://maven.apache.org/pom.html#What_is_the_POM">Maven POMProjectObjectModel</a> 파일은 아래와 같다.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;<br>    //...<br>    &lt;parent&gt;<br>        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;<br>        &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;<br>        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;<br>    &lt;/parent&gt;<br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.h2database&lt;/groupId&gt;<br>            &lt;artifactId&gt;h2&lt;/artifactId&gt;<br>            &lt;scope&gt;runtime&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br>    //...<br>&lt;/project&gt;</pre><p>데이터베이스에 저장될 Member 엔티티Entitiy와 이를 수행할 MemberRepository를 아래와 같이 작성한다.</p><pre>@Entity<br><strong>public</strong> <strong>class</strong> <strong>Member</strong> {<br>    @Id<br>    @GeneratedValue(strategy = GenerationType.AUTO)<br>    <strong>private</strong> Long id;<br>    <strong>private</strong> String name;<br>    <strong>private</strong> String addr;<br>    <strong>public</strong> <strong>Member</strong>() {<br>    }<br>    <strong>public</strong> <strong>Member</strong>(String name, String addr) {<br>        <strong>this</strong>.name = name;<br>        <strong>this</strong>.addr = addr;<br>    }<br>    //...<br>}<br><strong>public</strong> <strong>interface</strong> <strong>MemberRepository</strong> <strong>extends</strong> <strong>JpaRepository</strong>&lt;<strong>Member</strong>, <strong>Long</strong>&gt; {<br>}</pre><p>마지막으로 Member 엔티티 생성하고 데이터베이스에 저장하는 코드를 스프링 부트 구동 시점에 실행 되도록 <a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/CommandLineRunner.html">CommandLineRunner</a>에 작성한다.</p><pre>@SpringBootApplication<br><strong>public</strong> <strong>class</strong> <strong>HibernateSqlLoggingApplication</strong> {<br>    // ...<br>    @Bean<br>    <strong>public</strong> CommandLineRunner <strong>initData</strong>(MemberRepository repository) {<br>        <strong>return</strong> (args) -&gt; {<br>            repository.save(<strong>new</strong> Member(&quot;ymyoo&quot;, &quot;Seoul&quot;));<br>        };<br>    }<br>}</pre><p>작성이 완료되면 프로젝트 구조는 아래와 같이 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/377/0*515Br11FSuvwfjpq.png" /><figcaption>갈무리. 예제 프로젝트 구조</figcaption></figure><p>이제 애플리케이션을 실행해 보자.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*LTyyT8SsojESTuj9.png" /></figure><p>스프링 애플리케이션이 시작되고 곧바로 종료되었다. 무슨 일이 있었을까? Member 엔티티는 데이터베이스에 저장되긴 했을까?</p><p>SQL문 로깅으로 확인해 보자.</p><h3>spring.jpa.properties.hibernate.show_sql</h3><p>application.properties 파일에 아래와 같이 추가하고 애플리케이션을 다시 실행해 보자.</p><pre>spring.jpa.properties.hibernate.show_sql=<strong>true</strong></pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*F8QrduYiEP-nkFcR.png" /><figcaption>갈무리. spring.jpa.properties.hibernate.show_sql=true 설정 후 애플리케이션 로그</figcaption></figure><h3>스프링 부트 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html">Auto-configuration</a>과 하이버네이트</h3><p>application.properties 파일에 spring.jpa.properties.hibernate.show_sql=true 한 줄을 추가했을 뿐인데 SQL문이 콘솔에 출력되었다. 어떻게 된 일인지 좀 더 상세히 알아보자.</p><p>스프링 부트가 나오기 이전에는 스프링을 사용하기 위해서 많은 설정이 필요했다. 스프링 부트는 기존 스프링 설정을 보다 적게 할 수 있도록 Auto-configuration을 도입하였다. 예제 프로젝트에서는 Maven 의존성 라이브러리로 spring-boot-starter-data-jpa와 h2 데이터베이스가 추가되어있다. 스프링 부트 AutoConfiguration은 스프링 애플리케이션을 실행하면서 추가된 라이브러리(<a href="https://en.wikipedia.org/wiki/JAR_(file_format)">JAR</a>)를 인식하여 JPA(하이버네이트)와 H2 데이터베이스 설정을 <strong>스프링 부트 기본 설정값으로 자동 설정</strong>해 준다. 그래서 예제 프로젝트에는 하이버네이트와 H2 데이터베이스 관련 설정을 찾아볼 수 없다.</p><p>위에서 콘솔에 출력된 SQL문은 하이버네이트에 의해 출력된 것이다. 하이버네이트 문서에 따르면 하이버네이트 ‘hiberante.show_sql’을 ‘true’로 설정하면 하이버네이트가 실행하는 모든 SQL문을 콘솔로 출력해 준다.</p><blockquote><strong>hibernate.show_sql (e.g. true or false (default value))</strong> Write all SQL statements to the console. This is an alternative to setting the log category org.hibernate.SQL to debug.<a href="https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#_sql_statement_logging">https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#_sql_statement_logging</a></blockquote><p><strong>결국 스프링 부트 설정 파일인 application.properties에 spring.jpa.properties.hibernate.show_sql=true 추가한다는 것은 스프링 부트가 하이버네이트 자동 설정 시 하이버네이트 ‘hiberante.show_sql’을 ‘true’로 설정해 달라는 의미이다.</strong></p><p>그렇다면 출력된 <a href="https://en.wikipedia.org/wiki/Data_definition_language">DDLData Definition Language</a>은 무엇일까? 여기에도 역시 스프링 부트 Auto-configuration이 있다.</p><p>하이버네이트에는 작성된 엔티티를 기준으로 데이터베이스 스키마를 자동으로 생성해 주는 기능이 있다.</p><blockquote><strong>hibernate.hbm2ddl.auto (e.g. none (default value), create-only, drop, create, create-drop, validate, and update)</strong> Setting to perform SchemaManagementTool actions automatically as part of the SessionFactory lifecycle. Valid options are defined by the externalHbm2ddlName value of the Action enum:</blockquote><ul><li>none No action will be performed.</li><li>create-only Database creation will be generated.</li><li>drop Database dropping will be generated.</li><li>create Database dropping will be generated followed by database creation.</li><li>create-drop Drop the schema and recreate it on SessionFactory startup. Additionally, drop the schema on SessionFactory shutdown.</li><li>validate Validate the database schema</li><li>update Update the database schema</li></ul><blockquote><a href="https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#configurations-hbmddl">https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#configurations-hbmddl</a></blockquote><p>예제 프로젝트에서는 별도의 데이터베이스 설치하지 않고 사용하기 위해서 H2 데이터베이스를 <a href="http://www.h2database.com/html/features.html#in_memory_databases">In-Memory</a> 모드로 사용하고 있다. <strong>스프링 부트 Auto-configuration은 H2 데이터베이스 </strong><a href="http://www.h2database.com/html/features.html#in_memory_databases"><strong>In-Memory</strong></a><strong> 모드와 같이 데이터베이스를 애플리케이션에 내장Embedded 되어 사용하는 경우 하이버네이트 ‘hibernate.hbm2ddl.auto’을 ‘create-drop’으로 설정한다</strong>. ‘create-drop’으로 설정하면 애플리케이션 시작 시 하이버네이트가 스키마를 자동 생성하고 종료 시 삭제한다.</p><p>위에서 spring.jpa.properties.hibernate.show_sql=true로 설정했기 때문에 하이버네이트 스키마 자동 생성/삭제 DDL이 함께 출력된 것이다.</p><h3>spring.jpa.properties.hibernate.format_sql</h3><p>하이버네이트 ‘hibernate.format_sql’을 ‘true’로 설정하면 SQL문을 보기 좋게 출력해 준다.</p><blockquote><strong>hibernate.format_sql (e.g. true or false (default value))</strong> Pretty-print the SQL in the log and console.<a href="https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#_sql_statement_logging">https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#_sql_statement_logging</a></blockquote><p>스프링 부트 application.properties에는 아래와 같이 설정해 주면 된다.</p><pre>spring.jpa.properties.hibernate.show_sql=<strong>true</strong><br>spring.jpa.properties.hibernate.format_sql=<strong>true</strong></pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*FZTmQ71oPJ8C_LG6.png" /><figcaption>갈무리. spring.jpa.properties.hibernate.format_sql=true 설정 후 애플리케이션 로그</figcaption></figure><p>이전에는 한 줄로 출력 되었던 INSERT문이 읽기 좋게 출력된 것을 확인할 수 있다.</p><h3>spring.jpa.properties.hibernate.use_sql_comments</h3><p>하이버네이트 ‘hibernate.use_sql_comments’을 ‘true’로 설정하면 디버깅이 용이하도록 SQL문 이외에 추가적인 정보를 출력해 준다.</p><blockquote><strong>hibernate.use_sql_comments (e.g. true or false (default value))</strong> If true, Hibernate generates comments inside the SQL, for easier debugging.<a href="https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#_sql_statement_logging">https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#_sql_statement_logging</a></blockquote><p>스프링 부트 application.properties에는 아래와 같이 설정해 주면 된다.</p><pre>spring.jpa.properties.hibernate.show_sql=<strong>true</strong><br>spring.jpa.properties.hibernate.format_sql=<strong>true</strong><br>spring.jpa.properties.hibernate.use_sql_comments=<strong>true</strong></pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/920/0*NBPMnBbNoSDYW9hq.png" /><figcaption>갈무리. spring.jpa.properties.hibernate.use_sql_comments=true 설정 후 애플리케이션 로그</figcaption></figure><p>SQL문 이외에 엔티티 정보를 함께 출력된 것을 확인할 수 있다.</p><h3>logging.level.org.hibernate.type.descriptor.sql</h3><p>위의 출력된 SQL문 중 물음표로 표기된 부분을 하이버네이트에서는 바인드 파라미터Bind Parameter라고 한다.</p><p>스프링 부트 application.properties에는 아래와 같이 설정해 주면 바인드 파라미터를 출력해 준다.</p><pre>spring.jpa.properties.hibernate.show_sql=<strong>true</strong><br>spring.jpa.properties.hibernate.format_sql=<strong>true</strong><br>spring.jpa.properties.hibernate.use_sql_comments=<strong>true</strong><br>logging.level.org.hibernate.type.descriptor.sql=trace</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*-oswaYc2r-o38Qyq.png" /><figcaption>갈무리. logging.level.org.hibernate.type.descriptor.sql=trace 설정 후 애플리케이션 로그</figcaption></figure><h3>GitHub</h3><p>전체 코드는 필자의 <a href="https://github.com/YooYoungmo/article-spring-boot-hibernate-sql-logging">GitHub 저장소</a>에서 확인할 수 있다.</p><h3>주석</h3><p>[1] 예제를 단순화하기 위해 웹 관련 의존성은 제외하였다.</p><h3>참고 자료</h3><ul><li><a href="https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html">https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=424de95ed171" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>