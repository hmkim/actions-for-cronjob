<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by 유인동 on Medium]]></title>
        <description><![CDATA[Stories by 유인동 on Medium]]></description>
        <link>https://medium.com/@indongyoo?source=rss-8f6f43b6a5c2------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*_jMJZsDeuQD2794TjfneHw.jpeg</url>
            <title>Stories by 유인동 on Medium</title>
            <link>https://medium.com/@indongyoo?source=rss-8f6f43b6a5c2------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Tue, 14 May 2019 10:25:45 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@indongyoo" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[2010년의 카카오에서 있었던 일 2]]></title>
            <link>https://medium.com/@indongyoo/2010%EB%85%84%EC%9D%98-%EC%B9%B4%EC%B9%B4%EC%98%A4%EC%97%90%EC%84%9C-%EC%9E%88%EC%97%88%EB%8D%98-%EC%9D%BC-2-1e1cb0b173c2?source=rss-8f6f43b6a5c2------2</link>
            <guid isPermaLink="false">https://medium.com/p/1e1cb0b173c2</guid>
            <dc:creator><![CDATA[유인동]]></dc:creator>
            <pubDate>Sat, 14 Apr 2018 13:45:25 GMT</pubDate>
            <atom:updated>2018-04-26T02:43:12.411Z</atom:updated>
            <content:encoded><![CDATA[<h4>제품의 차이</h4><p>이전 글: <a href="https://medium.com/@indongyoo/2010%EB%85%84%EC%9D%98-%EC%B9%B4%EC%B9%B4%EC%98%A4%EC%97%90%EC%84%9C-%EC%9E%88%EC%97%88%EB%8D%98-%EC%9D%BC-1-f29428291e7a">2010년의 카카오에서 있었던 일 1</a></p><p>‘카카오에서 있었던 일’이라는 주제로 글을 쓰고 있고, 이 글은 두 번째 글이다. 꽤 오래전의 일이고 기억에 의존해서 작성하는 글이라 정확하지 않을 수 있지만 고쳐나가겠다.</p><p>2010년에 카카오의 사명은 아이위랩이었다. 아이위랩은 브라이언(김범수 의장님)이 2006년 12월에 창업한 회사다. 카카오는 갑자기 성공한 회사가 아니다. 아이위랩은 2006년 부터 2010년 카카오톡이 런칭되기까지 수많은 서비스를 만들고 실패하기를 반복했다.</p><p>2010년 6월에 갤럭시S가 출시 되었다. 카카오에서는 카카오톡 안드로이드 버전을 준비하고 있었다. 안드로이드 개발은 브랜든(박창희님)과 에반(김인수님)이 맡았다. 당시 브랜든과 에반은 원래 각각 다른 두 개의 아이폰 앱을 개발하고 운영하고 있었다. 회사 내부에서는 카카오톡에 집중할 것인가에 대한 논의가 계속 되고 있었고, 카카오톡의 초기 기획자였던 폴(이운학님)이 카카오톡 안드로이드 버전 개발을 제안했다. 카카오톡 안드로이드 버전 개발이 정해지자 바로 팀 배치, 프로젝트 계획 등을 수립하고 개발에 들어갔다.</p><p>안드로이드 역시 책도 문서도 구글 검색도 좋은 라이브러리들도 별로 나오지 않을 때였다. 개발이 진행되고 있던 중 어느날 “안드로이드 푸시 왔다~~!” 라고 누군가 소리쳤던 기억이 난다. 아마 내 기억에 서버 개발자이자 CSO였던 스캇(이상혁님)이었던 것 같다.</p><p>당시 안드로이드에는 많은 문제가 있었다. 기기의 성능도 상대적으로 좋지 않았고, OS의 완성도도 떨어졌다. 어떤 상황에서는 로컬 디비에서 데이터를 읽고 쓰는 것보다 서버에서 데이터를 읽고 쓰는게 빠르기도 했다고 했다. 브랜든은 그런 상황을 해결하고 최대한 좋은 성능과 안정성을 확보하기 위해, 앱이 구동되면 데이터들을 안드로이드 메모리에 다 올려놓고, 서버, 로컬디비, 메모리를 상황에 맞춰 적절히 이용했다고 했다. 마치 Redis처럼 안드로이드 메모리에 띄워놓은 데이터들을 메인 스토리지 삼고, 그것을 이용해 뷰 등을 갱신하고, 백그라운드에서는 로컬 디비에 데이터를 싱크를 맞추는 식이었다. 이런 시도는 실제로 제품의 성능과 사용자 경험에 영향을 끼쳤다.</p><p>브랜든은 안드로이드 카카오톡을 만들 때, 사용자에게 최대한 메신저의 경험을 줄 수 있도록 여러가지 면에서 신경을 썼다고 했다. 개발을 시작하기 전에는 이런 문제들을 아무도 예측하지도 못했을 것이고 생각한적도 없었을 것이다. 문제를 처음 본 것도 브랜든과 에반이었을 것이고, 해결한 것도 브랜든과 에반이었을 것이다. 그렇게 만들어진 안드로이드 카카오톡은 실시간성, 채팅, 그룹 채팅, 멀티미디어 전송 등의 기능들이 완성도 있고 의미 있게 동작했다. 그리고 2010년 8월에 처음 사용자들을 만났다.</p><p>당시 안드로이드 카카오톡이 오픈하기전에도 여러 개의 안드로이드 무료 메시지 앱들이 있었다. 특별히 브랜드로 자리 잡은 메신저도 없었고 카카오톡도 마찬가지였기 때문에, 아마도 자기 주변의 친구들이 먼저 쓰기 시작한 메시지 서비스를 쓰게 되었을 것이다. 많은 사용자들은 친구들과 소통하기위해 여러 개의 무료 메시지 앱을 받아 놓고 여기로도 보내보고 저기로도 보내보고 했다. 실제로 여러 메신저앱을 비교하는 동영상 리뷰들도 올라왔었다.</p><p>카카오톡 안드로이드 버전은 다른 앱들 보다 매끄럽게 동작했고, 메신저에 걸맞는 느낌과 사용 경험을 주었다. 점점 많은 사람들이 카카오톡 안드로이드 앱을 사용하기 시작했고, 어느 순간 카카오톡은 스마트폰을 개통하자마자 설치해야하는 필수 앱이 되었다. 가입자수 역시 증가하기 시작하더니 얼마 되지 않아 아이폰/안드로이드 카카오톡 가입자 수는 100만명이 되었다.</p><p>아이위랩은 이때 쯤 카카오로 사명을 변경했고, 얼마 안되서 200만 명의 가입자가 되었고, 하루 가입자 수는 4~5만 명이 되었고, 거의 모든 회원이 액티브 유저였다. 사용자들은 카카오톡을 쓰는 친구들이 많아지자 더 많은 메시지를 쓰기 시작했다. 그렇게 한 명 평균 메시지 전송량이 증가하더니 하루 총 메시지 전송량도 천 만건을 넘어섰다.</p><p>완성도 있는 기획/디자인 그리고 잘 구현된 아이폰/안드로이드 클라이언트는 사용자를 카카오톡을 선택하게 했다. 그리고 많은 동시 접속자를 견뎌낸 서버와 시스템은 사용자들을 머무르게 했다. 다음 글은 카카오톡을 지탱한 서버 개발자들과 시스템 엔지니어의 이야기를 쓰고 싶다 :)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*lYonn8BP836FTqjSmBaNcg.png" /></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1e1cb0b173c2" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2010년의 카카오에서 있었던 일 1편]]></title>
            <link>https://medium.com/@indongyoo/2010%EB%85%84%EC%9D%98-%EC%B9%B4%EC%B9%B4%EC%98%A4%EC%97%90%EC%84%9C-%EC%9E%88%EC%97%88%EB%8D%98-%EC%9D%BC-1-f29428291e7a?source=rss-8f6f43b6a5c2------2</link>
            <guid isPermaLink="false">https://medium.com/p/f29428291e7a</guid>
            <dc:creator><![CDATA[유인동]]></dc:creator>
            <pubDate>Sat, 07 Apr 2018 10:13:31 GMT</pubDate>
            <atom:updated>2018-04-26T02:51:30.944Z</atom:updated>
            <content:encoded><![CDATA[<h4>개발자의 덕목</h4><p>‘카카오에서 있었던 일’이라는 주제로 몇 개의 글을 쓰고자 한다. 이 글은 그 중 첫 번째 글이다. 나는 카카오톡 프로젝트를 꽤 초기에 참여했지만 주역은 아니었고 돕는 개발자였다. 카카오톡 초기 개발자들에 대한 이야기가 어디에도 없는거 같아 옆에서 그들을 바라본 입장에서 글을 써보기로 했다. 기억에 의존해서 작성하는 글이라 정확하지 않을 수 있지만 고쳐나가겠다.</p><p>2010년 4월에 카카오에 입사했었는데, 지금 생각하면 그때 나는 정말 많이 부족했었다. 아마도 발전 가능성을 보고 채용해주었던 것 같다. 그때 카카오톡은 아이폰 버전만 있었고, 국내에 아이폰이 출시된지 5개월이 안되었었고, 갤럭시S는 출시 전이었다.</p><p>2010년 여름 전에 사수였던 루니(정상영님)와 카카오톡 아이폰 개발을 하고 있었다. 주요 과제는 2010년 3월에 런칭되었던 카카오톡의 디자인을 변경하는 것과 이후 발전을 위해 리팩토링하는 것이었다.</p><p>루니는 로컬 디비 설계를 변경하고, 데이터를 다루는 코드를 Core Data로 변경하고, Core Data에 최적화된 코드 세트들로 UITableView, UISearchBar 등을 다시 작성하고, 데이터의 변화에 따라 뷰를 변경하는 등 효과적으로 앱의 상태를 관리하자고 제시했다. API 통신은 자체적으로 구현한 라이브러리로 적용하고 싶어했고, 최대한 iOS SDK 그대로를 사용하고 싶어했다.</p><p>루니는 가장 어렵고 중요한 부분인 로컬 디비 설계와 마이그레이션, 그리고 채팅탭과 메시징을 전부 다시 작성했다. 나는 그것을 제외한 친구 목록, 연락처 동기화, 친구 차단, 프로필 변경, 대화 내용 백업 등을 다시 작성했고, 밥이 새로 디자인해준 이미지들을 적용했다.</p><p>잘 동작하는 루니의 코드를 루니가 이미 충분히 검증한 스택으로 변경하는 일이었고, 아이폰 SDK가 워낙 잘 만들어져 있었기 때문에, 내 몫은 그리 어려운 것이 아니었다. (그때 난 정말 어려웠지만…)</p><p>당시 나는 코딩을 정말 못했다. 그냥 생각없이 돌아가게만 막 ‘키보드 타이핑’을 했었다. 어느날 내가 커밋한 코드를 루니가 보고서는 내게 따끔한 충고를 했다.</p><blockquote>이 기능을 구현할 때 <strong>이 메서드를 쓰는게 가장 적합하다고 생각해?</strong> 대충하지 말고 가장 어울리는 메서드가 뭔지 고민해서 적용하라구!</blockquote><blockquote>3개월 짜리 프로젝트를 1달 반 동안 급하게 개발하고 테스트 및 버그 수정을 1달 반 동안 하는 개발자들이 많은데, 난 그렇게하지 않아. 3개월 동안 <strong>천천히 집중해서 개발하고 버그 없는 제품을 만들어서 결과적으로 ‘테스트 기간’이 필요 없게 만들지. </strong>고민안하고 대충 빨리 만들어서 ‘디버깅 기간’을 따로 써야한다면 결과적으로 빠른게 아니야. <strong>난 개발자의 최고 덕목이 이해력이나 센스나 빨리 만드는 능력이 아니라 꼼꼼함이라고 생각해.</strong></blockquote><blockquote>코딩을 할 때 가장 적합하고 잘 맞는 메서드와 기법을 사용하려고 애쓰란 말야.</blockquote><blockquote>넌 iOS SDK 코드 읽어봤어? 난 다 읽어봤어. <strong>얼마나 아름다운지 알아?</strong></blockquote><p>이런 충고를 처음 듣고 너무나 맞는 말이라고 생각했지만, 프로젝트를 진행하는 동안에는 그냥 충고 정도로 생각했었다. 얼마 되지 않아 2010년 여름에 리팩토링 된 카카오톡이 완성됐다. 루니의 말처럼 별도의 ‘테스트 기간’없이 카카오톡 아이폰 앱은 업데이트가 되었고, 사용자들은 문제 없이 메시지를 주고 받았다. 거의 전체 코드가 다시 작성되었음에도 불구하고 말이다. 그것을 눈으로 보고나니 앞선 충고가 정말 깊이 들어왔고, 맘속에 큰 동요가 있었다. 동시에 좌절도 있었다.</p><p>“와.. 저 사람.. 그리고 저 사람들 다 너무 멋있다. 난 뭐냐 정말..”</p><p>루니는 iOS SDK 구조와 동작, 그리고 컨셉에 대한 정확한 이해를 토대로 코드를 작성했다. 라이브러리를 가져다쓰기보다는 충분히 검증된 기본 SDK의 조합을 통해 문제를 해결하려고 했다. 남의 코드를 어떻게 믿냐고 했다. 당시엔 아이폰 개발 시장은 초기 단계였고, 라이브러리들이 검증되었다고 보기도 어려웠던 것도 사실이다. 책도 별로 없었고 검색해도 많은 아티클이 나오지 않았다. 그런 상황에서도 루니는 정말 좋은 코드를 작성했다. 간결하고 군더더기 없고 안전한 코드로 여러 문제들을 관리했다.</p><p>그 때의 루니의 충고는 아직도 내게 중요하고 큰 기준으로 남아있다. 그 후 혼자서 아이폰 개발을 할 때 iOS SDK를 천천히 읽어보게 되었고, 아름답다는 말이 어떤 말이었는지도 느끼게 되었었다. 라이브러리나 프레임워크 등을 가져다 써보기전에 반드시 선행되어야하는 것은, 내가 다루어야 하는 것들에 대해 정확히 이해하는 것이다.</p><p>지금 같이 일하는 친구들과도 종종 루니가 이런 말을 했었다며 얘기한다. 이게 가장 적합한 메서드였냐고. 혹시 루니 귀가 가려울까. 크크.</p><p>함수형을 하고나서도 비슷하다. 가장 어울리는 함수인지. 가장 간결한 해결책인지. 가장 효과적으로 동작하는지. 믿을 수 있는지. 안전한지.</p><p>무엇을 사용하는지가 개발자의 수준을 가르지 않는다. 사용자에게 전달되는 가치가 없다면 그 코드의 생산성은 제로이며, 일정 내에 잘 동작하는 제품을 만드는 것이 동료와 조직을 진정으로 위하는 길이다. 꼼꼼함. 늘 기억하는 단어다. 루니에게 계속 고마움을 가지고 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*lYonn8BP836FTqjSmBaNcg.png" /></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f29428291e7a" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Functional.es - 부록. 클래스 없이 코딩하기]]></title>
            <link>https://medium.com/@indongyoo/functional-es-%EB%B6%80%EB%A1%9D-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%97%86%EC%9D%B4-%EC%BD%94%EB%94%A9%ED%95%98%EA%B8%B0-f79d5781391b?source=rss-8f6f43b6a5c2------2</link>
            <guid isPermaLink="false">https://medium.com/p/f79d5781391b</guid>
            <category><![CDATA[functional-programming]]></category>
            <category><![CDATA[es6]]></category>
            <category><![CDATA[functional-javascript]]></category>
            <dc:creator><![CDATA[유인동]]></dc:creator>
            <pubDate>Sat, 31 Mar 2018 16:50:50 GMT</pubDate>
            <atom:updated>2018-04-05T09:23:33.031Z</atom:updated>
            <content:encoded><![CDATA[<h4>함수형 자바스크립트와 ES6+</h4><p><a href="https://github.com/Functional-JavaScript/functional.es/blob/master/articles/ES6%2C%20%ED%95%A8%EC%88%98%ED%98%95%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%2C%20%EB%B9%84%EB%8F%99%EA%B8%B0%2C%20%EB%8F%99%EC%8B%9C%EC%84%B1%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EB%B6%80%EB%A1%9D.%20%ED%81%B4%EB%9E%98%EC%8A%A4%20%EC%97%86%EC%9D%B4%20%EC%BD%94%EB%94%A9%ED%95%98%EA%B8%B0.md">원본 글 Github에서 보기</a></p><h3>목차</h3><ul><li>나머지 매개변수와 전개 연산자, 그리고 부분 적용</li><li>장바구니</li><li>정리</li></ul><h3>나머지 매개변수와 전개 연산자, 그리고 부분 적용</h3><p>함수형 프로그래밍에서 로직을 구체화하는 기법에는 크게 세 가지가 있습니다.</p><ol><li>함수들이 연속적으로 실행되도록 조합</li><li>보조 함수를 고차 함수에 적용</li><li>부분 적용</li></ol><p>위 세 가지 중에 1과 2는 앞서 어느정도 확인했었습니다. 그렇다면 3은 무엇일까요. 3은 커링 혹은 부분 적용을 통해 인자들에 함수를 부분적으로 적용시키는 것을 말합니다. ES6+에서 부분 적용은 어떻게 할까요? ES6+은 나머지 매개 변수와 전개 연산자, 그리고 화살표 함수 등의 문법이 간결하고 강력하여 굉장히 다양한 경우의 부분 적용을 구현할 수 있습니다.</p><p>기본적인 사례를 보면 다음과 같습니다.</p><pre>function sub(a, b) {<br>  return a - b;<br>}</pre><pre>const sub10 = _ =&gt; sub(_, 10);<br>console.log( sub10(15) ); // 5<br>console.log( sub10(30) ); // 20</pre><p>화살표 함수를 이용하여 항상 10을 빼는 함수를 만들었습니다. sub의 두 번째 인자에 항상 10이 전달되게 됩니다.</p><p>이번엔 subAll을 만든 후 부분 적용을 해보겠습니다.</p><pre>function sub(a, b) {<br>  return a - b;<br>}</pre><pre>const subAll = (...args) =&gt; reduce(sub, args);</pre><pre>console.log( subAll(30, 10, 5) );<br>// 15</pre><pre>const subAllAndSub5 = (..._) =&gt; subAll(..._, 5);</pre><pre>console.log( subAllAndSub5(30, 10) );<br>// 15<br>console.log( subAllAndSub5(30, 10, 5) );<br>// 10</pre><p>나머지 매개 변수와 전개 연산자를 활용하면 위와 같이 유연한 부분 적용이 가능합니다.</p><p>다음은 나올 수 있는 다양한 부분 적용 패턴들을 확인하기 위한 예제입니다.</p><pre>const f1 = _ =&gt; console.log(1);<br>f1();<br>// 1</pre><pre>const f2 = (..._) =&gt; console.log(1, ..._);<br>f2(2, 3);<br>// 1 2 3</pre><pre>const f3 = (..._) =&gt; console.log(1, ..._, 4);<br>f3(2, 3);<br>// 1 2 3 4<br>f3(2);<br>// 1 2 4<br>f3();<br>// 1 4</pre><pre>const f4 = (..._) =&gt; console.log(..._, 4, 5);<br>f4(1, 2, 3);<br>// 1 2 3 4 5<br>f4();<br>// 4 5</pre><pre>const f5 = (..._1) =&gt; (..._2) =&gt; console.log(..._1, 4, ..._2, 7);<br>f5(1, 2, 3)(5, 6);<br>// 1 2 3 4 5 6 7</pre><p>위 문법들을 확인했다면, 다른 함수들과의 조합을 통해 더 많은 것들을 할 수 있습니다.</p><h3>장바구니</h3><p>장바구니의 담긴 상품들의 정보를 계산하는 로직을 클래스/객체 조합이 아닌 함수 조합으로 구현하면서 모듈화해보는 예제입니다. 함수 조합의 아이디어를 확인하기위해 최대한 작고 잘게 조개는 코드로 작성된 예제입니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/276d19ade89ffa4bfca64824f675e471/href">https://medium.com/media/276d19ade89ffa4bfca64824f675e471/href</a></iframe><p>위 price는 const price = p =&gt; p.price와 같습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/06a8df2a6f11c50526d814dd1013e010/href">https://medium.com/media/06a8df2a6f11c50526d814dd1013e010/href</a></iframe><p>baseCalcF는 세 번째 실행에서 받은 인자인 5를, 두 번째 실행에서 받은 함수들을 적용한 배열로 만든 후, 해당 배열을 첫 번째 실행에서 받은 add 함수로 축약합니다.</p><pre>const subF = baseCalcF(sub);<br>const multF = baseCalcF(mult);</pre><pre>subF(a =&gt; a + 10, a =&gt; a + 20)(0);<br>// -10<br>multF(a =&gt; a + 10, a =&gt; a + 20)(0);<br>// 200<br>multF(a =&gt; a + 10, a =&gt; a + 20)(10);<br>// 600</pre><p>baseCalcF에서 축약에 사용할 함수를 전달하여 위와 같이 사용할 수 있습니다.</p><p>아래는 상품 하나를 다루는 함수들입니다.</p><pre>// 네임 스페이스 - 상품에 대한 함수들<br>const pdt = {};</pre><pre>// 할인된 금액<br>pdt.discountedPrice = subF(price, discount);<br>console.log( pdt.discountedPrice(p1) ); // 10000</pre><pre>// 기본 금액 x 수량<br>pdt.totalPrice = multF(price, quantity);<br>console.log( pdt.totalPrice(p1) ); // 36000</pre><pre>// 할인된 금액 x 수량<br>pdt.discountedTotalPrice = multF(pdt.discountedPrice, quantity);<br>console.log( pdt.discountedTotalPrice(p1) ); // 30000</pre><p>pdt 네임 스페이스에 필요한 함수들을 subF와 multF를 이용해 만들었습니다. subF(price, discount)의 결과인 pdt.discountedPrice 함수는 p1로부터 p1.price과 p1.discount를 추출한 배열을 만든 후 sub로 축약하며, multF도 동일하게 동작합니다. pdt.discountedTotalPrice는 동일 로직을 중첩하여 조합하였습니다.</p><p>아래는 상품 목록을 다루는 함수들입니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/517498a43da4f83f0510d3362e8a9381/href">https://medium.com/media/517498a43da4f83f0510d3362e8a9381/href</a></iframe><p>위에서는 pdts.total를 만든 후 해당 함수에 원하는 함수를 조합하면서, 모든 상품에 해당하는 각각의 값들을 계산하는 함수들을 함수 조합을 통해 만들었습니다.</p><p>아래는 pdts.total에 before를 전달하거나, pipe를 이용하여 선택된 상품들에 해당하는 각각의 값들을 계산하는 함수들을 만들었습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/48d7344fc2eda3640db5face542d97b9/href">https://medium.com/media/48d7344fc2eda3640db5face542d97b9/href</a></iframe><p>일반적으로는 ...before보다는 pipe를 이용하지만 ...before와 같은 기법을 이용하면 원하는 특정 위치에 함수들을 추가할 수 있는 함수를 준비할 수 있습니다.</p><p>아래는 좀 더 복잡한 문제들을 위에 있던 함수들의 조합을 통해 해결한 사례입니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/633c2bb09f6759e9ac30e45c8ca58b79/href">https://medium.com/media/633c2bb09f6759e9ac30e45c8ca58b79/href</a></iframe><h3>정리</h3><p>객체지향 프로그래밍에서 추상화의 단위가 클래스라면, 함수형 프로그래밍에서는 추상화의 단위가 함수입니다. 위에서 살펴본 것처럼 함수형 ES6+에서는 고차 함수, 전개 연산자, 나머지 매개변수, 화살표 함수, 구조 분해 등을 활용하여 함수의 조합성을 높일 수 있습니다. 함수만으로도 높은 수준의 모듈화가 가능하며, 인자와 리턴값만으로 소통하는 함수들은 조합성이 좋고 테스트하기도 쉽습니다.</p><p>값의 형을 표기하지 않는 자바스크립트에서는 코드에서 사용하는 값이 어떤 명세를 가졌는지를 알기 어렵습니다. IDE를 이용하더라도 코드를 분석하는 것에 한계가 있습니다. 인터프리터 언어인 자바스크립트에서는 class, this, super, 메서드를 이용한 프로그래밍이 어려우며, 모듈화를 세밀하게 할수록 오히려 코드 분석 및 유지 보수가 더 어려워 질 수 있습니다.</p><p>하지만 기본 객체를 중심으로한 함수형 프로그래밍은 IDE를 통해 함수를 찾아다니는 것도 쉽고, 값들의 명세 역시 명확하게 되며, 테스트가 쉬워집니다. 이것은 팀 단위 프로젝트의 생산성을 높이며, 유지 보수 및 기획 변경에 대한 대응 및 배포를 쉽게 합니다. 함수는 라이프 사이클이 단순합니다. 언제 선언했는지와 언제 평가되었는지만 중요합니다. 함수라는 값은 상태가 없으며, 콘솔에서 확인하기도 쉽고, 테스트 단위도 명확합니다. ES6+에서 함수를 통한 모듈화는 효율적이며 안전합니다.</p><h3>모든 예제 코드</h3><ul><li><a href="https://github.com/Functional-JavaScript/functional.es">https://github.com/Functional-JavaScript/functional.es</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f79d5781391b" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Functional.es - 6. 예외 처리]]></title>
            <link>https://medium.com/@indongyoo/functional-es-6-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC-1f867900def7?source=rss-8f6f43b6a5c2------2</link>
            <guid isPermaLink="false">https://medium.com/p/1f867900def7</guid>
            <category><![CDATA[functional-javascript]]></category>
            <category><![CDATA[functional-programming]]></category>
            <category><![CDATA[es6]]></category>
            <dc:creator><![CDATA[유인동]]></dc:creator>
            <pubDate>Sat, 31 Mar 2018 16:49:22 GMT</pubDate>
            <atom:updated>2018-04-03T12:46:05.212Z</atom:updated>
            <content:encoded><![CDATA[<h4>함수형 자바스크립트와 ES6+</h4><p><a href="https://github.com/Functional-JavaScript/functional.es/blob/master/articles/ES6%2C%20%ED%95%A8%EC%88%98%ED%98%95%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%2C%20%EB%B9%84%EB%8F%99%EA%B8%B0%2C%20%EB%8F%99%EC%8B%9C%EC%84%B1%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/6.%20%EC%98%88%EC%99%B8%20%EC%B2%98%EB%A6%AC.md">원본 글 Github에서 보기</a></p><h3>목차</h3><ul><li>ES6+의 3가지 예외</li><li>pipe().nullable()</li><li>pipe().error()</li><li>pipe().exception() ()</li><li>여러가지 달기</li><li>pipe().error().complete()</li><li>다른 컬렉션 조작 함수들과의 조합</li><li>비동기를 지원하지 않는 함수에서 발생한 예외 처리 실패</li><li>동기/비동기를 함께 지원하는 함수의 필요성</li><li>정리</li></ul><p>자바스크립트는 런타임에 코드를 해석하는 언어이고, 동적 타입 언어입니다. 동적 타입 언어에서 함수 합성을 안전하게 하려면 어떻게 해야할까요. 하스켈은 대수 구조, 모나드를 통해 순수한 세상을 만들고, Kleisli 화살표와 강력한 타입 시스템에 힘입어 안전한 합성을 가능케 합니다. 하스켈의 Functor, Applicative Functor, Maybe, Either 등은 강력하고 우아합니다. 그런데 자바스크립트에는 모나드도 없고, 타입 시스템이 강력하지도 않고, 컴파일단에서 타입을 검증할 수도 없습니다.</p><p>그럼 모나드가 없는 다른 함수형 프로그래밍 언어들은 예외 처리를 어떻게 할까요? 대표적인 함수형 프로그래밍 언어인 클로저와 엘릭서는 모나드가 없습니다. 엘릭서는 강력한 패턴 매칭을 활용하여 예외를 다룹니다. 클로저는 다른 언어들과 비슷한 방식으로 예외를 다룹니다.</p><p>어쨌든 모든 함수형 프로그래밍 언어들은 공통적으로 예외를 최대한 만들지 않는 경향을 가지고 있습니다. 이를테면 어떤 함수가 무언가를 찾지 못했다고 에러를 발생시키지는 않습니다. 예로 find, reduce, filter 같은 함수들은 약간 예외적인 상황을 만나더라도 Maybe를 리턴하거나, nil, null, undefined, [], 0 등을 리턴합니다. 그 외에도 많은 함수들이 이러한 전략을 갖습니다. 가능하다면 예외를 만들지 않고, 자연스럽게 흘려보내는 방향으로 프로그래밍을 한다는 점이 특징입니다.</p><p>함수형 프로그래밍에서 함수 합성은 가장 중요한 개념 중 하나입니다. 그것이 pipe이든 compose이든 말이죠. 함수 합성에서 가장 중요한 점은 안전한 합성입니다. 그런데 프로그래밍 세상은 안전하지 않습니다. 예외가 발생할 수 있는 세상에서 어떻게 하면 안전하게 함수를 합성할 수 있을까요.</p><p>어떤 함수형 언어이든지간에 공통적인 부분은 흘려보내는 아이디어를 가졌다는 것입니다. 예를 들어 <em>(f · g)(x) = f(g(x))</em> 라고 가정했을 때, <em>g(x)</em> 에서 오류가 나면 <em>(f · g)(x) = g(x)</em> 가 되도록 만드는 것입니다.</p><p>이것을 해결하기 위해 하스켈의 모나드를 자바스크립트에 가져오는 방법도 있겠지만, 자바스크립트에서 커스텀 타입은 성능 저하, JSON 직렬화/역직렬화 추가 비용 발생 등의 이슈가 있고, 컴파일단에서 체크해주지 못하는 문제 등으로 인해 그 가치가 떨어집니다. 그렇다면 ES6+에 어울리는 예외 처리 방식은 무엇일까요?</p><h3>ES6+의 3가지 예외</h3><p>우선 ES6+ 에서 일어날 예외가 무엇인지 살펴보면 크게 2가지로 에러(throw, Promise.reject), Nullable(null, undefined)가 있습니다. 한 가지 더 있을 수 있는데, 개발자가 직접 정의한 커스텀 에러가 있을 수 있습니다.</p><ul><li>에러 — throw, Promise.reject</li><li>Nullable — null || undefined</li><li>개발자 정의 에러</li></ul><h3>pipe().nullable()</h3><p>pipe 함수는 pipe()()와 같이 실행하면 아무런 예외 처리를 하지 않습니다. 들어온 모든 함수가 순수 함수일 것이라고 가정합니다.</p><p>pipe().nullable()와 같이 실행하면 함수들이 실행되는 과정에서 undefined나 null을 만났을 때 함수 실행을 중단하고 nullable()을 정의한 곳으로 이동합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f9edbe079c23a393a4b795bfbf7bc329/href">https://medium.com/media/f9edbe079c23a393a4b795bfbf7bc329/href</a></iframe><p>비동기적으로 결과가 내려와도 동일하게 처리됩니다.</p><pre>const log = then(console.log);</pre><pre>const f3 = pipe(<br>  a =&gt; a + 10,<br>  a =&gt; Promise.resolve(null),<br>  a =&gt; a + 100 // &lt;--- null 온 경우 실행되지 않음<br>).nullable(<br>  _ =&gt; &#39;이런!&#39;<br>);</pre><pre>log(f3(1)); // 이런!</pre><h3>pipe().error()</h3><p>pipe().error()와 같이 실행하면 함수들이 실행되는 과정에서 에러가 던져졌을 때 함수 실행을 중단하고 error()를 정의한 곳으로 이동합니다. 역시 동기/비동기 에러 모두 검출합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/859d467bca2c6190cecc6f8d3be505fc/href">https://medium.com/media/859d467bca2c6190cecc6f8d3be505fc/href</a></iframe><h3>pipe().exception() ()</h3><p>pipe().exception() ()과 같이 실행하면 함수들이 실행되는 과정에서 사용자 정의 예외를 리턴했을 때 함수 실행을 중단하고 exception() ()을 정의한 곳으로 이동합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/847add575ec7face3b4311378675e1c1/href">https://medium.com/media/847add575ec7face3b4311378675e1c1/href</a></iframe><h3>여러가지 달기</h3><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/b307892f5a0795bb46aef802fe0d062e/href">https://medium.com/media/b307892f5a0795bb46aef802fe0d062e/href</a></iframe><p>error 부분에서 더 복잡하게 분기를 하고자 한다면 앞서 소개했던 match 함수를 조합할 수 있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/eadf828d27ada233de9f02db1dfdebf8/href">https://medium.com/media/eadf828d27ada233de9f02db1dfdebf8/href</a></iframe><h3>pipe().error().complete()</h3><p>성공한 경우에 추가로 실행해야하는 일이 있을 수 있습니다. 그럴 때는 pipe().error().complete()와 같이 실행하면 됩니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e019eb472a5de47c7ae2995dab388cf7/href">https://medium.com/media/e019eb472a5de47c7ae2995dab388cf7/href</a></iframe><h3>다른 컬렉션 조작 함수들과의 조합</h3><p>파이프라인안에서 고차 함수를 사용했을 때, 안쪽 함수에서 예외가 발생할 경우 바깥으로 .error로 넘어오게 됩니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/97086bf51e7ada3370e50067946871eb/href">https://medium.com/media/97086bf51e7ada3370e50067946871eb/href</a></iframe><p>여기까지는 콜 스택 덕분에 동기적인 try/catch로도 충분히 해결이 가능하여, Array.prototype.map이나 비동기를 다루지 않는 다른 컬렉션 조작 라이브러리들의 함수를 사용해도 예외 처리가 가능합니다.</p><h3>비동기를 지원하지 않는 함수에서 발생한 예외 처리 실패</h3><p>만일 이와 같은 코드에서 비동기적인 예외가 발생되면 어떻게 될까요?</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e4984cb4f8a5ae7af2439120dda2ad9e/href">https://medium.com/media/e4984cb4f8a5ae7af2439120dda2ad9e/href</a></iframe><p>동기적 상황만 고려한 Array.prototype.map은 위와 같은 상황에서 예외가 발생할 뿐아니라, 예외처리를 하지 못하게 됩니다.</p><h3>동기/비동기를 함께 지원하는 함수의 필요성</h3><p>아래는 Function.es의 map, some으로 변경한 코드입니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/2a6586eca0ac4a8b5b042d255b6b2269/href">https://medium.com/media/2a6586eca0ac4a8b5b042d255b6b2269/href</a></iframe><p>Functional.es의 함수들은 기본적으로 동기와 비동기 상황을 함께 지원하도록 구현되어있기 때문에 동기/비동기와 상관없이 성공과 실패를 안전하게 제어할 수 있습니다.</p><h3>정리</h3><p>pipe는 기본적으로는 동기/비동기 상황의 함수 합성을 처리해주는 함수입니다. 여기서 pipe가 동기와 비동기를 구분 짓는 규칙은 ES6+의 내장 값인 Promise를 기준으로 합니다. 추가로 개발자가 원하는대로 nullable/error/exception 규칙을 심어줄 수 있고, 이 역시 자바스크립트의 기본 에러 값들을 다룹니다. 이를 통해 자바스크립트의 내장 값만을 이용해도 안전한 함수 합성을 가능하도록 합니다.</p><p>자바스크립트는 동적 언어이자 인터프리터 언어입니다. prototype 기반으로 다양한 사용자 정의 클래스를 만들 수 있지만 인터프리터 언어의 특성상 타입을 강하게 지원하지 못합니다. 메서드나 함수가 처리되는 과정에서 타입을 파악하기 때문에 안전한 조합을 보장하기 어렵습니다. 복잡한 타입들을 도입하거나 많은 수의 사용자 정의 클래스를 만들게 되면 IDE의 지원을 받아도 너무나 복잡한 세상들의 조합을 네비게이션하기조차 힘들어지기도 합니다.</p><p>그렇다면 자바스크립트는 안전할 수 없는 걸까요? 사용자 정의 클래스를 만들지 않고 자바스크립트의 기본 값들을 기준으로 프로그래밍을 하게되면 안전하게 프로그래밍이 가능합니다. 서로 다른 세상을 살펴볼 필요도 없습니다. 어떤 함수든 기본 값을 리턴하기 때문에 그 기본 값을 잘 다루는 함수들을 조합하면서 안전하게 프로그래밍 해나갈 수 있습니다.</p><h3>모든 예제 코드</h3><ul><li><a href="https://github.com/Functional-JavaScript/functional.es">https://github.com/Functional-JavaScript/functional.es</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1f867900def7" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Functional.es - 5. 비동기, 동시성, 병렬성 프로그래밍]]></title>
            <link>https://medium.com/@indongyoo/functional-es-5-%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%B3%91%EB%A0%AC%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-1143df919b68?source=rss-8f6f43b6a5c2------2</link>
            <guid isPermaLink="false">https://medium.com/p/1143df919b68</guid>
            <category><![CDATA[es6]]></category>
            <category><![CDATA[functional-programming]]></category>
            <category><![CDATA[functional-javascript]]></category>
            <dc:creator><![CDATA[유인동]]></dc:creator>
            <pubDate>Sat, 31 Mar 2018 16:47:44 GMT</pubDate>
            <atom:updated>2018-04-03T12:35:08.899Z</atom:updated>
            <content:encoded><![CDATA[<h4>함수형 자바스크립트와 ES6+</h4><p><a href="https://github.com/Functional-JavaScript/functional.es/blob/master/articles/ES6%2C%20%ED%95%A8%EC%88%98%ED%98%95%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%2C%20%EB%B9%84%EB%8F%99%EA%B8%B0%2C%20%EB%8F%99%EC%8B%9C%EC%84%B1%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/5.%20%EB%B9%84%EB%8F%99%EA%B8%B0%2C%20%EB%8F%99%EC%8B%9C%EC%84%B1%2C%20%EB%B3%91%EB%A0%AC%EC%84%B1%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.md">원본 글 Github에서 보기</a></p><h3>목차</h3><ul><li>들어가기 앞서 Promise, async/await에 대해</li><li>Promise는 콜백 지옥을 해결한 것일까?</li><li>promise.then(f)의 규칙</li><li>Promise 체인</li><li>then :: Promise p =&gt; (a -&gt; b | p b) -&gt; a | p a -&gt; b | p b</li><li>then에 커링 적용하기</li><li>파이프라인</li><li>이미지 동시에 모두 불러온 후 DOM에 반영하기</li><li>mapC와 limit</li><li>쇼트트랙 계주 — 순서대로 실행하기</li><li>동시적으로 혹은 순차적으로</li><li>async/await는 은총알인가?</li><li>병렬적으로 동작할 수 없는 async/await</li><li>더 많은 함수들</li></ul><h3>들어가기 앞서 Promise, async/await에 대해</h3><p>Promise, async, await는 ES6+에서 비동기 프로그래밍을 지탱하는 기술입니다. 자바스크립트에 현재까지 준비된 비동기 관련 Helpers를 통해 해결할 수 있는 일은 다음과 같습니다.</p><h3>1. then의 연속 사용으로 순차적으로 코드를 정리하기</h3><pre>then<br>then<br>then<br>then</pre><h3>2. reject, catch</h3><pre>then<br>then<br>reject --<br>then    |<br>then    |<br>catch &lt;--</pre><h3>3. Promise.all, Promise.race</h3><pre>Promise.all(imgUrls.map(loadImage)).then(console.log);<br>// [img1, img2, img3] (완성된 모든 결과)</pre><pre>Promise.race(imgUrls.map(loadImage)).then(console.log);<br>// img2 (제일 먼저 완성된 결과 하나)</pre><h3>4. 명령형 코드와 async await 사용하기</h3><pre>async function f(a) {<br>  for (var i = 0; i &lt; a.length; i++) {<br>    if (i &lt; ...) {<br>      var b = await get();<br>    } else {<br>      b = ...<br>      ...<br>    }<br>    for (var j = 0; j &lt; i; j++) {<br>      ...<br>      if (j == b) var c = await();<br>    }<br>  }<br>}</pre><p>ES6+는 Promise, async/await를 통해 비동기 프로그래밍을 더욱 잘 다룰 수 있도록 발전했습니다. 하지만 Promise와 async/await를 명령적으로 다루게되면 명령형 프로그래밍에서 만날 수 있는 문제들에 다시 직면하게 됩니다. 아무리 동기 코드와 동일한 코드가 가능하더라도 for, if, i++, j++ 등을 이용한 코드는 어렵습니다.</p><h3>Promise는 콜백 지옥을 해결한 것일까?</h3><p>Promise는 콜백 지옥을 해결한 것이 아닙니다. Promise는 콜백 지옥을 해결할 기반입니다. Promise는 ‘결과 값이 만들어지기로 약속된 값’이자 일급 객체입니다. Promise가 컨텍스트가 아니라 값이라는 것은 인자와 리턴값으로 소통할 수 있다는 중요한 차이를 가집니다.</p><p>이 글에서는 함수를 값으로 다루면서 원하는 시점에 평가하고, Promise를 인자와 리턴값으로 다루면서 비동기/동시성/병렬성 문제를 해결해볼 것입니다. 비동기/동시성/병렬성 프로그래밍은 함수형 프로그래밍의 특기입니다.</p><h3>promise.then(f)의 규칙</h3><p>Promise는 비동기적으로 성공과 실패를 다루는데, 성공했다면 promise.then(f)와 같이 인자로 함수를 전달하여 값을 받을 수 있습니다. 이때 f가 인자로 받는 값은 절대 Promise가 아니라는 규칙이 있습니다. 이것은 Promise가 연속적으로 적용되어도 된다는 중요한 규칙이며, 연속성은 함수형 프로그래밍과 연관이 깊은 성질입니다.</p><pre>new Promise(function(resolve) {<br>  resolve(Promise.resolve(Promise.resolve(&#39;hi&#39;)));<br>}).then(function(a) {<br>  console.log(a); // hi<br>});</pre><h3>Promise 체인</h3><pre>function num(a) {<br>  return a;<br>}</pre><pre>function add10(a) {<br>  return a + 10;<br>}</pre><pre>console.log(add10(add10(num(0))));<br>// 20</pre><p>위 코드는 정상 동작했지만 아래는 정상동작하지 않습니다.</p><pre>function numP(a) {<br>  return new Promise(function(resolve) {<br>    setTimeout(function() {<br>      resolve(a);<br>    }, 1000);<br>  });<br>}</pre><pre>console.log(add10(add10(numP(2))));<br>// [object Promise]1010</pre><p>Promise를 다루는 가장 기본적인 방법은 아래와 같습니다.</p><pre>numP(1)<br>  .then(add10)<br>  .then(add10)<br>  .then(console.log); // 1초 뒤 21</pre><p>반대로 num을 사용하면서 위와 동일한 패턴으로 코딩을 할 경우 에러가 나게되므로 아래와 같이 해야합니다.</p><pre>Promise.resolve(num(2))<br>  .then(add10)<br>  .then(add10)<br>  .then(console.log); // 22 (hi보다 아래 출력)</pre><pre>console.log(&#39;hi&#39;);</pre><p>그런데 위와 같은 방식은 성능적으로 문제가 있습니다. 반드시 비동기가 일어나기 때문입니다. 간혹 라이브러리들이 동기와 비동기를 같은 코드로 제어하기 위해 무조건 Promise 혹은 비동기를 관리하는 모나드로 감싸서 제어하는 경우가 있습니다. 이런 방식은 성능적으로도 문제가 있을 뿐 아니라, 특히 브라우저에서는 콜 스택과 렌더링이 연관성 때문에 부자연스러운 렌더링, 성능 등의 여러가지 문제를 야기합니다.</p><h3>then :: Promise p =&gt; (a -&gt; b | p b) -&gt; a | p a -&gt; b | p b</h3><p>아주 작은 함수로 동기와 비동기를 색다르게 다루는 방법을 소개합니다.</p><pre>function then(f, a) {<br>  return a instanceof Promise ? a.then(f) : f(a);<br>}</pre><p>then은 인자로 들어온 a가 Promise라면 a.then(f)를, 아니라면 f(a)를 하는 단순한 함수입니다.</p><pre>function add100(a) {<br>  return then(a =&gt; a + 100, a);<br>}<br>function log(a) {<br>  return then(console.log, a);<br>}</pre><pre>log(add100(add100(num(3)))); // 즉시 203 (ho 전에 출력)<br>console.log(&#39;ho&#39;); // ho<br>log(add100(add100(numP(4)))); // 1초 뒤 204</pre><p>log(add100(add100(num(3))))은 즉시 결과를 만들었고, 정상동작하지 않았던 console.log(add10(add10(numP())))와 동일한 형태로 코드를 작성했지만 위 코드는 정상 동작했습니다.</p><h3>then에 커링 적용하기</h3><p>then 함수가 커링을 지원하면 더욱 간결하게 표현할 수 있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f43f57efd167e347eb4eb843d3b7b38f/href">https://medium.com/media/f43f57efd167e347eb4eb843d3b7b38f/href</a></iframe><p>아주 작은 함수 then을 통해 동기와 비동기를 하나의 함수로 다루는 패턴을 확인해보았습니다. 더 복잡한 동기와 비동기를 동일한 코드로 지원하고자 한다면 함수형 프로그래밍으로 간결하게 해결할 수 있습니다.</p><h3>파이프라인</h3><p>pipe 함수를 사용하면 프로미스 체인을 간결하게 표현할 수 있고, 더 안전합니다.</p><pre>// Functional<br>const f2 = pipe(add10, add10, add10, console.log);<br>f2(num(7)); // 즉시 37<br>f2(numP(7)); // 1초 뒤 37</pre><pre>// Vanilla<br>const f1 = p =&gt; p.then(add10).then(add10).then(add10).then(console.log);<br>f1(num(8)); // err<br>f1(numP(8)); // 1초 뒤 38</pre><p>functional.es의 pipe는 중간에 Promise를 만난다면 즉시 Promise를 리턴한 후 비동기적인 상황들을 동기적으로 제어하고, 중간에 Promise를 만나지 않는다면 즉시 값를 리턴합니다.</p><h3>이미지 동시에 모두 불러온 후 DOM에 반영하기</h3><p>자바스크립트에서 이미지를 다루는 일에 있어서 비동기 상황은 원래 중요했지만, HTTP2 시대가 오면서 더욱 중요해졌습니다. 단순히 비동기 상황을 동기적으로 제어하는 것을 넘어, 한 번에 많은 양의 이미지를 동시적으로 요청하고 로딩할 수 있기 때문에 다양한 동시성 로직을 구현할 수 있게 되었고, 어떻게 코딩하느냐에 따라 굉장히 다른 결과를 만들 수 있게 되었습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/915e7f7c943ecb1b0658d193f46980a0/href">https://medium.com/media/915e7f7c943ecb1b0658d193f46980a0/href</a></iframe><p>두 코드 모두 동일한 결과를 만들지만, Functional한 코드가 더욱 간결하고 읽기 좋습니다. 위에서부터 아래로 읽어내려가면 됩니다. Promise.all을 쓴 코드의 경우 코드가 순서대로 읽히지는 않습니다.</p><p>mapC를 간단하게 구현하면 다음과 같습니다. mapC는 비동기 상황 모드를 동시에 출발 시킨 후 결과를 완성해갑니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/42fa6f1edabadc90a93202e82505ca28/href">https://medium.com/media/42fa6f1edabadc90a93202e82505ca28/href</a></iframe><h3>mapC와 limit</h3><p>크기가 아주 큰 배열을 가지고 부하가 큰 작업을 mapC로 돌리게되면 문제가 생길 수 있습니다. Functional.es의 mapC는 limit을 통해 mapC가 동시에 처리할 크기를 정할 수 있습니다. 이러한 로직이 꼭 필요한 상황이 있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ad8ac15a63e9c013dbc6fcafbc789ea6/href">https://medium.com/media/ad8ac15a63e9c013dbc6fcafbc789ea6/href</a></iframe><p>mapC의 세 번째 인자인 limit만 정해주면 매우 간단하게 부하 정도를 조절할 수 있습니다. 이와 같은 코드를 명령형으로 작성하게되면, Promise, async/await를 사용하여도 매번 재귀, i++, if 등을 만나야합니다. 그에 비해 mapC는 매우 쉽고 안전하며, 다형성을 지원하여 배열 외에도 모든 컬렉션을 병렬적으로 다룰 수 있습니다.</p><p>자바스크립트에서 왠 병렬이냐고 생각하실 수 있습니다. 하지만 실무에서는 데이터베이스도 사용하고, 이미지 처리(crop, resize …) 등 네트워크를 기반으로한 다양한 기술을 사용하게 됩니다. 요즘에는 서비스 하나에서 두 개 이상의 데이터베이스를 사용하는 것도 일반적입니다. NodeJS 프로그래밍을 할 때, 다양한 처리를 동시적으로 안전하게 위임할 수 있다면, 빠른 사용자 응답을 보다 쉽게 구현할 수 있습니다.</p><h3>쇼트트랙 계주 — 순서대로 실행하기</h3><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/734d4c1b3069dbc4881977d0df71e1cf/href">https://medium.com/media/734d4c1b3069dbc4881977d0df71e1cf/href</a></iframe><p>한국과 이탈리아가 쇼트트랙 계주를 하는 화면을 구현한다고 가정해봅시다. skater는 자신의 평균 기록(time)과 기복(und)을 가지고 있습니다. 두 팀은 동시에 출발을 해야하고, 앞 선수가 다 돌아야 다음 선수가 출발할 수 있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/b39f9c9a6c5a1a1fc9208d8102bd5bb0/href">https://medium.com/media/b39f9c9a6c5a1a1fc9208d8102bd5bb0/href</a></iframe><p>모두 함께 실행해보면 다음과 같습니다.</p><pre>setTimeout(function() {<br>  console.log(&#39;올림픽 시작!&#39;);<br>  each(f =&gt; f([team1, team2]), [<br>    quarterfinal,<br>    semifinal,<br>    final]);<br>}, 7000);</pre><pre>// 올림픽 시작!<br>// ...<br>// ...<br>// 준준결승 종료<br>// ...<br>// ...<br>// 준결승 종료<br>// i1 출발<br>// k1 출발<br>// i2 출발<br>// k2 출발<br>// k3 출발<br>// i3 출발<br>// korea팀 결승선 통과!<br>// italy팀 결승선 통과!<br>// 결승 종료!</pre><h3>동시적으로 혹은 순차적으로</h3><p>concurrency와 series는 원하는 자료구조를 함수 실행을 통해 만들기 위해 사용합니다. 특히 비동기 상황에서 실용적으로 사용될 수 있습니다. 데이터베이스에서 두 개의 테이블을 통해 값을 얻어온다던지 할 때 사용하면 용이합니다.</p><p>concurrency와 series가 푸는 문제는 서로 약간은 다릅니다. 개발자는 이것을 선택하기만 하면 됩니다. concurrency와 series도 각각 mapC와 map으로 구현되어있습니다. 함수형 프로그래밍은 이미 해결한 문제와 조금은 다른 문제들을 기존의 구현된 함수와 새로운 함수의 조합으로 해결해나갑니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/96ff17f8019d8d904f2fa29b2e3af001/href">https://medium.com/media/96ff17f8019d8d904f2fa29b2e3af001/href</a></iframe><h3>async/await는 은총알인가?</h3><p>자바스크립트에는 이미 Array.prototype.map이 있는데, 왜 map을 구현해야할까요. 혹은 async/await가 있는데 비동기를 제어하는 함수들을 왜 또 구현을 해야할까요. 혹은 다른 함수형 라이브러리의 map도 있는데 왜 굳이 functional.es의 map이 필요할까요.</p><p>async/await는 명령적입니다. 명령형 코드는 헷갈립니다. async/await가 명시적으로 모든 비동기 코드를 동기적으로 만들어주는 것 같지만 그렇지 않습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/09ffce38efccb5a0040c889b54221aeb/href">https://medium.com/media/09ffce38efccb5a0040c889b54221aeb/href</a></iframe><p>숫자들이 출력되길 기대했으나, 위 코드는 원하는 결과를 얻지 못했습니다. 아참 list.map 앞에도 await를 넣어야 하겠네요. 맨 바깥쪽의 익명함수도 async를 달아주었습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/1509471d85767281796430d18d146121/href">https://medium.com/media/1509471d85767281796430d18d146121/href</a></iframe><p>위 코드는 빠짐 없이 async/await를 넣은 것 같지만 원하는 결과가 나오지는 않았습니다. Array.prototype.map이 Promise를 지원하지 않기 때문입니다. async/await는 자바스크립트의 forEach, map, filter, find 등과 사용될 수 없습니다. 대부분의 함수형 자바스크립트 라이브러리들의 map, filter, reduce, find와도 사용할 수 없습니다. 명령형 코드들인 for, while 등과 사용해야만 비동기 제어가 가능합니다.</p><p>비동기를 지원하는 함수를 async/await로 만들면 되지 않을까요? async/await만을 사용해서 만들게되면 성능 최적화가 될 수 없습니다. async/await를 만날 때마다 비동기가 일어나기 때문입니다.</p><p>Functional.es의 방식은 다릅니다. Functional.es는 비동기가 일어나는 상황에만 선택적으로 비동기를 제어하고, 아닌 경우는 계속해서 동기적으로 동작합니다. 컬렉션에 담긴 값들 중 비동기를 일으킨 구간에선 비동기가 일어나지만 아닌 구간에선 하나의 콜 스택에서 동작합니다. 이런 전략은 많은 곳에서 훨씬 나은 결과를 만들 수 있게 합니다. 특히나 브라우저에서는 렌더링과 콜 스택이 연관이 있어, 더욱 중요합니다.</p><p>위 코드의 list.map을 Functional.es의 map으로 바꾸기만하면 원하는 결과를 얻을 수 있습니다. map의 첫 번째 인자인 f가 Promise를 리턴하면 해당 작업을 기다리도록 되어 있기 때문입니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/1d9457ce73efc46f4abda1f7b67de06f/href">https://medium.com/media/1d9457ce73efc46f4abda1f7b67de06f/href</a></iframe><p>그런데 사실 map을 사용하면 위와 같이 복잡할 필요도 없습니다.</p><pre>// Functional<br>go([5, 6, 7, 8], map(add2), console.log);</pre><p>명시적으로 비동기가 일어나는 구간을 표시하고 싶다면, 아래와 같이 가능합니다.</p><pre>// Functional<br>go([5, 6, 7, 8], map(async n =&gt; await add2(n)), console.log);</pre><p>물론 표시할 수 있다는 점은 장점입니다. Array.prototype.map은 표시를 해도 동작하지 않습니다. 하지만 굳이 필요하지는 않다고 생각합니다.</p><p>실무에서는 비동기가 일어날 상황이 보통 코드에서 보이기 때문입니다.</p><pre>go(userId,<br>  or(<br>    cachedUser, // 여기서 찾아지면 아래는 안가도 되고, 비동기 안일어남<br>    fetchUser), // 비동기 일어남<br>  renderUser,<br>  ...<br>  ...);</pre><p>async/await를 표시하고나면 반드시 비동기가 일어나게 된다는 문제도 있습니다.</p><h3>병렬적으로 동작할 수 없는 async/await</h3><p>async/await는 병렬적으로 일어나는 일을 처리하지 못합니다. 하나씩 순차적으로 기다리는 경우에만 사용할 수 있습니다. 동시성 프로그래밍을 하기 위해서는 헬퍼 함수가 반드시 필요합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9b54e4c39a5282fa94e3c62213305059/href">https://medium.com/media/9b54e4c39a5282fa94e3c62213305059/href</a></iframe><h3>더 많은 함수들</h3><p>Functional.es는 다음의 함수 등이 모두 동시성을 다룹니다.</p><ul><li>map, filter, reduce</li><li>go, pipe</li><li>or, and</li><li>match</li><li>mapC, concurrency, series</li><li>find, findVal, some, every, none</li><li>findC, findValC, someC, everyC, noneC</li><li>…</li></ul><h3>or, and, match</h3><p>or, and는 || 와 &amp;&amp;를 함수적/비동기적으로 다루어야할 때 용이합니다. match는 비동기가 제어되고 조건부와 실행부에서 파이프라인을 간결하게 표현 가능하여 비동기 상황을 포함한 복잡한 분기를 간결하게 정리할 수 있습니다.</p><h3>find 계열</h3><p>find, some, evey, none 등은 데이터베이스의 쿼리를 최소한으로 날려볼 수 있게 합니다. 하나씩 요청해보다가 결과를 만들어지면 바로 그 후 함수들은 평가하지 않습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/572d456920a0b571b4febbe8bc834cf0/href">https://medium.com/media/572d456920a0b571b4febbe8bc834cf0/href</a></iframe><p>findC, someC, everyC, noneC는 find, some, evey, none와 거의 같지만, 모두 동시에 출발 시킨 후 먼저 온 결과들 중에 원하는 결과를 얻으면 나머지 결과는 기다리지 않고 끝냅니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/8f5057813ba68e03662c720849e2bee0/href">https://medium.com/media/8f5057813ba68e03662c720849e2bee0/href</a></iframe><p>find, some, evey, none과 findC, someC, everyC, noneC는 상황에 따라 다르게 필요합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d81fe09a84f4d218110a279d09b54050/href">https://medium.com/media/d81fe09a84f4d218110a279d09b54050/href</a></iframe><h3>정리</h3><p>함수형 프로그래밍은 평가 시점이 상관 없는 순수한 함수를 원하는 시점에 평가하는식으로 복잡한 문제를 해결하면서도 효율성을 얻습니다. 안전하게 동작하는 효율적인 함수를 조합하여 만든 해결책은, 역시 안전하고 효율적일 가능성이 높습니다. 함수형 프로그래밍을 하면 안전하면서도 최적화된 로직을 훨씬 쉽게 구현할 수 있습니다.</p><h3>모든 예제 코드</h3><ul><li><a href="https://github.com/Functional-JavaScript/functional.es">https://github.com/Functional-JavaScript/functional.es</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1143df919b68" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Functional.es - 4. 코드를 컬렉션으로 다루기]]></title>
            <link>https://medium.com/@indongyoo/functional-es-4-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%BB%AC%EB%A0%89%EC%85%98%EC%9C%BC%EB%A1%9C-%EB%8B%A4%EB%A3%A8%EA%B8%B0-6fa9dc397968?source=rss-8f6f43b6a5c2------2</link>
            <guid isPermaLink="false">https://medium.com/p/6fa9dc397968</guid>
            <category><![CDATA[functional-programming]]></category>
            <category><![CDATA[es6]]></category>
            <category><![CDATA[functional-javascript]]></category>
            <dc:creator><![CDATA[유인동]]></dc:creator>
            <pubDate>Sat, 31 Mar 2018 16:42:42 GMT</pubDate>
            <atom:updated>2018-04-03T12:19:55.943Z</atom:updated>
            <content:encoded><![CDATA[<h4>함수형 자바스크립트와 ES6+</h4><p><a href="https://github.com/Functional-JavaScript/functional.es/blob/master/articles/ES6%2C%20%ED%95%A8%EC%88%98%ED%98%95%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%2C%20%EB%B9%84%EB%8F%99%EA%B8%B0%2C%20%EB%8F%99%EC%8B%9C%EC%84%B1%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/4.%20%EC%BD%94%EB%93%9C%EB%A5%BC%20%EC%BB%AC%EB%A0%89%EC%85%98%EC%9C%BC%EB%A1%9C%20%EB%8B%A4%EB%A3%A8%EA%B8%B0.md">원본 글 Github에서 보기</a></p><h3>목차</h3><ul><li>pipe, go</li><li>match</li><li>함수를 값으로 다루면서 원하는 시점에 평가하기</li><li>or, and</li></ul><p>앞서 컬렉션을 다루는 함수들을 살펴보았습니다. 그런데 ‘코드를 컬렉션으로 다루기’란 무엇을 말하는 것일까요. 보통은 데이터베이스의 정보나, 앱의 상태 정보, 돔 엘리먼트 등을 컬렉션으로 다룹니다. 함수형 프로그래밍에서는 이것들 외에도 자주 사용하는 값이 하나 더 있습니다. 바로 함수입니다.</p><h3>pipe, go</h3><p>함수형 프로그래밍에서는 함수도 값으로 다룹니다. 다음은 함수를 값으로 다루는 함수 중 하나인 pipe입니다.</p><pre>const { pipe } = Functional;</pre><pre>var f1 = pipe(<br>  _ =&gt; 1,<br>  a =&gt; a + 10,<br>  a =&gt; a + 100,<br>  a =&gt; a + 1000,<br>  console.log);<br>//1111</pre><pre>f1();</pre><p>첫 번째 함수의 결과는 두 번째 함수의 인자로 전달됩니다. 두 번째 함수의 결과는 세 번째 함수의 인자로 전달됩니다. 반복되어 마지막 console.log에게 전달됩니다. 함수를 원소로 가진 컬렉션을 만들어서 pipe를 통해 함수를 합성했습니다.</p><pre>const { go } = Functional;</pre><pre>go(2,<br>  a =&gt; a + 20,<br>  a =&gt; a + 200,<br>  a =&gt; a + 2000,<br>  console.log);<br>// 2222</pre><p>go는 자바스크립트의 매력과 잘 어울립니다. 배열에 여러가지 타입의 값이 들어갈 수 있는 것을 활용합니다. go의 첫 번째 인자는 두 번째 인자인 함수를 적용할 인자입니다. 두 번째 함수의 결과는 세 번째 함수의 인자로 전달됩니다. 반복되어 마지막 console.log에게 전달됩니다.</p><p>go와 pipe 함수는 코드 라인들을 컬렉션(값)으로 다루면서 원하는 시점에 함수를 실행하면서 원하는 결과를 만들어가는 함수입니다. 이와 같이 함수를 값으로 다루는 함수를 고차 함수라고 합니다. 고차 함수는 함수를 리턴하거나, 함수를 실행하는 함수입니다. 앞서 확인했었던 map, reduce, find 등도 고차 함수 입니다.</p><h3>match</h3><p>match 함수는 복잡한 분기를 다루는 함수입니다. 함수들과 값들을 컬렉션으로 다루어서 분기를 구현합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/7fbb216e7de9d35b19e7e6679c97a28b/href">https://medium.com/media/7fbb216e7de9d35b19e7e6679c97a28b/href</a></iframe><p>match의 괄호에 함수 컬렉션을 넣으면 pipe로 동작합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e0834fd3ae859002ef484f9b170a5a8a/href">https://medium.com/media/e0834fd3ae859002ef484f9b170a5a8a/href</a></iframe><p>case는 내부적으로 isMatch처럼 동작합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/54e33b56b039c9bea7a5227a3081c8ab/href">https://medium.com/media/54e33b56b039c9bea7a5227a3081c8ab/href</a></iframe><h3>함수를 값으로 다루면서 원하는 시점에 평가하기</h3><p>순수 함수는 언제 평가해도 동일한 결과를 만듭니다. 이러한 법칙을 이용하여 함수형 프로그래밍에서는 비동기/동시성/병렬성/지연성 등을 훌륭하게 다룹니다. 고차 함수를 이용하여 함수 평가를 원하는 만큼 미루거나, 동시적으로 평가를 하거나, 원하는 순서대로 평가를 하면서 정확한 로직을 구현해갑니다.</p><p>함수를 원하는 시점에 평가하기는 함수형 프로그래밍의 최적화 기법입니다. 다양한 로직을 사람이 이해하고 외우기 좋은 많은 함수들로 만들고, 각 상황에 최적화된 함수를 선택하는 것이 함수형 프로그래밍이 가진 최적화 전략입니다. 함수들을 인자로 다루면서 목적에 따라 즉시 평가하기도, 미뤄서 평가하기도, 동시에 평가하기도, 필요 없는 경우엔 함수를 평가하지 않게도 합니다.</p><p>데이터와 도메인에 맞는 보조 함수를 만든 후 구현하고자 하는 로직에 최적화된 함수를 선택하는 것으로 자원 사용과 연산을 줄입니다. 함수를 값으로 다루는 것은 함수형 프로그래밍에서 가장 중요한 개념입니다.</p><p>[3. 컬렉션 중심 프로그래밍]에서 설명했던 some 함수는 컬렉션에 map을 적용한 다음, 하나라도 true로 평가될 수 있는 값이 있는지 확인하는 함수입니다. 아래와 같이 구현할 수 있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ae42363335f2a98dfde6eed19f4048d4/href">https://medium.com/media/ae42363335f2a98dfde6eed19f4048d4/href</a></iframe><p>위 코드는 4개의 숫자 값을 모두 불리언으로 변경한 다음, true가 있는지 확인하고 있습니다. 위 코드는 정상적으로 동작하지만 f의 평가시점이 최적화 되어있지 않아 f가 4번 실행됩니다.</p><p>some1과 동일한 로직을 최적화하면 아래와 같습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ca9e2c5428a03575d3110b0c34c7b755/href">https://medium.com/media/ca9e2c5428a03575d3110b0c34c7b755/href</a></iframe><p>some2는 f를 평가하는 시점을 true가 있는지를 알아보는 곳으로 좀 더 미뤘습니다. 위 상황에서 some2는 2개의 숫자 값만 불리언으로 변경하게 됩니다. f를 두 번만 실행합니다.</p><p>some1과 some2는 동일한 일을 하지만 some2는 함수를 가장 알맞는 시점에 평가하여 자원 사용과 연산 비용을 줄였습니다.</p><p>[3. 컬렉션 중심 프로그래밍]에서 구현했던 some 역시 some2와 같이 평가시점을 최적화하도록 하면서, 함수조합을 통해 더욱 간결하게 구현되어있습니다.</p><pre>const some = map(a =&gt; a !== undefined, find);</pre><h3>or, and</h3><p>or와 and는 ||와 &amp;&amp;의 함수 버전이며 코드 대신 함수를 받습니다. ||와 &amp;&amp;는 평가를 지연하여 효율적으로 처리합니다. 함수로 구현된 or와 and 역시 동일하게 효율적으로 동작합니다.</p><pre>const { or, and } = Functional;</pre><pre>or(<br>  _=&gt; null,  // (평가)<br>  _=&gt; false, // (평가)<br>  _=&gt; 10     // (평가)<br>)(); // 10</pre><pre>or(<br>  _=&gt; null,  // (평가)<br>  _=&gt; true,  // (평가)<br>  _=&gt; 10     // (X)<br>)(); // true</pre><pre>and(<br>  _=&gt; null,  // (평가)<br>  _=&gt; 10,    // (X)<br>  _=&gt; false, // (X)<br>  _=&gt; 12     // (X)<br>)(); // null</pre><pre>and(<br>  _=&gt; true,  // (평가)<br>  _=&gt; 10,    // (평가)<br>  _=&gt; false, // (평가)<br>  _=&gt; 12     // (X)<br>)(); // false</pre><pre>and(<br>  _=&gt; true,  // (평가)<br>  _=&gt; 10,    // (평가)<br>  _=&gt; 11,    // (평가)<br>  _=&gt; 12     // (평가)<br>)(); // 12</pre><p>‘함수를 값으로 다루면서 원하는 시점에 평가하기’는 함수형 프로그래밍에서 가장 중요한 개념이자 본질적인 부분입니다. 이 글에서 살펴본 some은 함수만으로 만들어진 함수이며, or와 and 예제에도 함수만 등장합니다. 함수형 프로그래밍은 이와 같이 함수를 값으로 사용하며, 함수를 언어 그 자체로 바라봅니다. 추상화의 단위로 함수를 사용하며, 작은 문제를 해결한 함수들을 조합하여 복잡한 문제를 해결해갑니다. 이때 함수 평가의 시점을 최적화하여 우아함과 성능이라는 두마리 토끼를 노립니다.</p><p>다음 글에서는 ‘함수를 값으로 다루면서 원하는 시점에 평가하기’를 가지고 실무에서 굉장히 중요한 문제인 비동기/동시성/병렬성 문제를 해결해볼 것입니다. 이것은 함수형 프로그래밍의 특기이기도 합니다.</p><h3>모든 예제 코드</h3><ul><li><a href="https://github.com/Functional-JavaScript/functional.es">https://github.com/Functional-JavaScript/functional.es</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6fa9dc397968" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Functional.es - 3. 컬렉션 중심 프로그래밍]]></title>
            <link>https://medium.com/@indongyoo/functional-es-3-%EC%BB%AC%EB%A0%89%EC%85%98-%EC%A4%91%EC%8B%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-937955971fcb?source=rss-8f6f43b6a5c2------2</link>
            <guid isPermaLink="false">https://medium.com/p/937955971fcb</guid>
            <category><![CDATA[es6]]></category>
            <category><![CDATA[functional-javascript]]></category>
            <category><![CDATA[functional-programming]]></category>
            <dc:creator><![CDATA[유인동]]></dc:creator>
            <pubDate>Sat, 31 Mar 2018 16:41:31 GMT</pubDate>
            <atom:updated>2018-04-03T12:08:42.571Z</atom:updated>
            <content:encoded><![CDATA[<h4>함수형 자바스크립트와 ES6+</h4><p><a href="https://github.com/Functional-JavaScript/functional.es/blob/master/articles/ES6%2C%20%ED%95%A8%EC%88%98%ED%98%95%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%2C%20%EB%B9%84%EB%8F%99%EA%B8%B0%2C%20%EB%8F%99%EC%8B%9C%EC%84%B1%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/3.%20%EC%BB%AC%EB%A0%89%EC%85%98%20%EC%A4%91%EC%8B%AC%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.md">원본 글 Github에서 보기</a></p><h3>목차</h3><ul><li>컬렉션</li><li>3개의 대표 함수 map, reduce, findVal</li><li>functional.es의 함수 계층</li><li>map 함수</li><li>map :: Functor f =&gt; (a -&gt; b) — f a -&gt; f b</li><li>대표 타입 5가지</li><li>서브 타입</li><li>map을 적용할 수 없지만 안전하게 흘려주는 타입</li><li>Functor로 보기 적합하지 않는 형</li><li>Currying</li><li>reduce 함수</li><li>reduce :: Collection c =&gt; ((a, b) -&gt; a) -&gt; a -&gt; c b -&gt; a</li><li>Currying</li><li>findVal 함수</li><li>findVal :: Collection c =&gt; (a -&gt; Any | undefined) -&gt; c a -&gt; Any | undefined</li><li>find :: Collection c =&gt; (a -&gt; Boolean) -&gt; c a -&gt; a | undefined</li><li>some, none, every</li></ul><h3>컬렉션</h3><p>앞서 다음의 열거 가능한 값들을 ‘컬렉션’이라고 정의했습니다.</p><ol><li>JSON 데이터 타입 내의 object</li><li>Array, Map, Set …</li><li>그 외 [Symbol.iterator]()가 구현된 모든 iterable과 iterator</li><li>Generator를 실행한 결과 값</li></ol><p>Functional.es의 map, filter, reduce 등은 위에 정의된 컬렉션을 지원합니다. functional.es의 주요 함수들을 확인하면서 ‘함수형 ES6+’의 기반이 될 ‘함수형 관점에서의 ES6+의 타입’에 대해 구체화해보도록 하겠습니다.</p><h3>3개의 대표 함수 map, reduce, findVal</h3><p>map, reduce, findVal를 이용하면 컬렉션을 다루는 거의 대부분의 로직을 구현할 수 있습니다.</p><h3>functional.es의 함수 계층</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*qmbgXaqIet_V26fxmvO1bQ.png" /></figure><h3>map 함수</h3><h4>map :: Functor f =&gt; (a -&gt; b) — f a -&gt; f b</h4><p>map은 함수 하나와 Functor를 받는 함수입니다. 여기서의 Functor는 ADT의 Functor는 아닙니다. ES6+에서 Functor 혹은 Collection으로 바라볼 수 있는 값들을 말합니다.</p><h3>대표 타입 5가지</h3><p>그 중 Functor로 바라보는 값은 다음과 같습니다.</p><ul><li>[]</li><li>{}</li><li>Map</li><li>Promise</li><li>Function</li></ul><p>위 5개의 타입은 인자로 들어온 형과 동일한 형으로 리턴합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/6fb914696fdd74411cb697b9dad8aadb/href">https://medium.com/media/6fb914696fdd74411cb697b9dad8aadb/href</a></iframe><p>map의 구현은 다음과 같고 함수 계층에 나와있는 것처럼 reduce로 구현되어있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/cce24603ba48605df5052721710b8cb6/href">https://medium.com/media/cce24603ba48605df5052721710b8cb6/href</a></iframe><h3>서브 타입</h3><p>map에 coll로 서브 타입이 들어오면 항상 배열을 리턴하도록 되어있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/26260206158a9cafeea304a792a10366/href">https://medium.com/media/26260206158a9cafeea304a792a10366/href</a></iframe><p>map이 Iterator를 받을 수 있다면, 할 수 있는 일이 많아집니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/29f1c2a19ed28abefac3096e6ce057ac/href">https://medium.com/media/29f1c2a19ed28abefac3096e6ce057ac/href</a></iframe><p>ES6+에서 지원하는 Iterator를 리턴하는 함수들이나 여러가지 Helper들을 활용하여 map과 조합하면 위와 같은 일이 가능합니다. 위 코드는 구조 분해와 Iterator를 리턴하는 Map.prototype.entries를 활용하여 key를 함께 받는 map으로 응용했습니다.</p><p>functional.es의 map은 ES6+의 Iterable/Iterator 프로토콜을 잘 따르고 있어, ES6+과 브라우저의 많은 Native Helpers나 그 외 자바스크립트 진영의 많은 라이브러리들과 조합성이 좋습니다.</p><h3>map을 적용할 수 없지만 안전하게 흘려주는 타입</h3><pre>console.log(map(v =&gt; v + 1, 1));<br>// []</pre><pre>console.log(map(v =&gt; v + 1, null));<br>// []</pre><pre>console.log(map(v =&gt; v + 1, undefined));<br>// []</pre><h3>Functor로 보기 적합하지 않는 형</h3><p>Set은 결과의 크기가 변경될 수 있기 때문에 map에서 사용하기는 적합하지 않습니다.</p><pre>console.log( map(a =&gt; a % 2, new Set([1, 2, 3, 4])) );<br>// [1, 0, 1, 0]</pre><pre>console.log( new Set([1, 0, 1, 0]) );<br>// Set(2) {1, 0}</pre><h3>Currying</h3><p>map을 실행하면서 인자로 함수 하나만을 전달하면 map은 부분 적용됩니다.</p><pre>const users = [<br>  {id: 1, name: &#39;AA&#39;}, <br>  {id: 10, name: &#39;BB&#39;}, <br>  {id: 5, name: &#39;CC&#39;}<br>];</pre><pre>const getIds = map(a =&gt; a.id);</pre><pre>console.log( getIds(users) );<br>// [1, 10, 5]</pre><h3>reduce 함수</h3><h3>reduce :: Collection c =&gt; ((a, b) -&gt; a) -&gt; a -&gt; c b -&gt; a</h3><p>reduce가 받는 Collection은 다음과 같습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/09962ebbb83489ee67418f95fbf4a074/href">https://medium.com/media/09962ebbb83489ee67418f95fbf4a074/href</a></iframe><p>reduce 역시 자바스크립트의 값들과 다양한 응용이 가능합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/37849a7cf819447da300359e1cbd183c/href">https://medium.com/media/37849a7cf819447da300359e1cbd183c/href</a></iframe><h3>Currying</h3><p>reduce의 커링은 함수 하나를 받았을 때만 동작합니다.</p><pre>const addAll = reduce(add);</pre><pre>console.log( addAll([1, 2, 3, 4]) );<br>// 10</pre><p>자바스크립트에서 커링을 엄격히 하기에는 어려움이 있고, 자바스크립트와 커링은 잘 어울리지 않는 편입니다. 커링은 첫 번째 인자만을 부분 적용하는 curry2 정도로만 지원하고, 필요할 때는 화살표 함수를 이용하여 부분 적용을 하는식으로 활용하는 것이 실용적입니다. curry2의 2는 최소 인자 개수를 말하며, 인자 개수가 2보다 작으면 커링을 하고, 인자 개수가 2개 이상 채워졌을 때 바로 실행한다는 의미입니다.</p><pre>const addAllWith10 = _ =&gt; reduce(add, 10, _);</pre><pre>console.log( addAllWith10([1, 2, 3, 4]) );<br>// 20</pre><p>화살표 함수를 이용한 다양한 부분 적용은 이후 글에서 더 소개하도록 하겠습니다.</p><h3>findVal 함수</h3><h4>findVal :: Collection c =&gt; (a -&gt; Any | undefined) -&gt; c a -&gt; Any | undefined</h4><p>findVal 함수는 f가 undefined가 아닌 값을 리턴하면 그 값을 findVal의 결과로 리턴하는 함수입니다.</p><pre>const { findVal } = Functional;</pre><pre>log(<br>  findVal(a =&gt; a.dream, [<br>    { name: &#39;AA&#39; },<br>    { name: &#39;BB&#39;, dream: &#39;rap&#39; },<br>    { name: &#39;CC&#39; }<br>  ])<br>);<br>// rap</pre><p>함수의 인자와 리턴 값의 타입을 정하면, 그에 따른 함수 계층을 만들 수 있고, 그것은 안전합니다. 다음은 findVal을 통해 만들 수 있는 함수들입니다.</p><h4>find :: Collection c =&gt; (a -&gt; Boolean) -&gt; c a -&gt; a | undefined</h4><pre>const find = (f, coll) =&gt; findVal(a =&gt; f(a) ? a : undefined, coll);</pre><pre>log(<br>  find(a =&gt; a.dream, [<br>    { name: &#39;AA&#39; },<br>    { name: &#39;BB&#39;, dream: &#39;rap&#39; },<br>    { name: &#39;CC&#39; }<br>  ])<br>);<br>// { name: &#39;BB&#39;, dream: &#39;rap&#39; }</pre><h3>some, none, every</h3><p>find 함수와 작은 함수들을 조합하면, some, none, every 등을 만들 수 있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/6e78453a375fcdc245747c2312431945/href">https://medium.com/media/6e78453a375fcdc245747c2312431945/href</a></iframe><p>some, none, every는 문(statments) 없이 함수의 조합으로만 구성되어있습니다. 함수형 프로그래밍에서는 위 코드처럼 합수의 조합으로 문제를 해결합니다. 작은 문제를 해결하고, 해결책의 조합을 통해 더 복잡한 문제들을 해결해나갑니다.</p><p>아래 글은 <a href="https://haskellschool.wordpress.com/2016/10/19/%EC%99%9C-%ED%95%98%EC%8A%A4%EC%BC%88%EC%9D%84-%EB%B0%B0%EC%9B%8C%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80">서광열님의 글</a>에서 발췌했습니다.</p><blockquote><em>프로그래밍의 본질은 한 번에 풀 수 없는 크고 복잡한 문제를 작은 문제들로 나누어서 해결하고 그렇게 나온 결과물들을 조합하여 다른 문제를 해결하는 것을 말합니다.</em></blockquote><blockquote><em>여기서 좋은 프로그램의 가장 중요한 특성으로 조합성(composability)이 등장합니다. 우리는 계속해서 크고 복잡한 문제를 풀어야 하고, 또한 비슷하지만 조금은 다른 문제들을 풀어야 합니다. 앞서 만들어 놓은 산출물을 쉽게 조합하여 새로운 문제를 해결할 수 있다면 프로그래머의 생산성은 비약적으로 늘 수 있기 때문입니다.</em></blockquote><h3>모든 예제 코드</h3><ul><li><a href="https://github.com/Functional-JavaScript/functional.es">https://github.com/Functional-JavaScript/functional.es</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=937955971fcb" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Functional.es - 2. 함수형 프로그래밍 관점에서 바라본 자바스크립트의 값]]></title>
            <link>https://medium.com/@indongyoo/functional-es-2-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EB%B0%94%EB%9D%BC%EB%B3%B8-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EA%B0%92-703ebd418bc?source=rss-8f6f43b6a5c2------2</link>
            <guid isPermaLink="false">https://medium.com/p/703ebd418bc</guid>
            <category><![CDATA[functional-javascript]]></category>
            <category><![CDATA[es6]]></category>
            <category><![CDATA[functional-programming]]></category>
            <dc:creator><![CDATA[유인동]]></dc:creator>
            <pubDate>Sat, 31 Mar 2018 16:40:26 GMT</pubDate>
            <atom:updated>2018-04-03T11:56:50.335Z</atom:updated>
            <content:encoded><![CDATA[<h4>함수형 자바스크립트와 ES6+</h4><p><a href="https://github.com/Functional-JavaScript/functional.es/blob/master/articles/ES6%2C%20%ED%95%A8%EC%88%98%ED%98%95%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%2C%20%EB%B9%84%EB%8F%99%EA%B8%B0%2C%20%EB%8F%99%EC%8B%9C%EC%84%B1%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2.%20%ED%95%A8%EC%88%98%ED%98%95%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C%20%EB%B0%94%EB%9D%BC%EB%B3%B8%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98%20%EA%B0%92.md">원본 글 Github에서 보기</a></p><h3>목차</h3><ul><li>자바스크립트에서의 함수형 프로그래밍을 위한 타입과 값</li><li>JSON 데이터 타입</li><li>undefined</li><li>열거 가능한 값, 컬렉션</li><li>컬렉션 순회</li><li>불변성</li><li>함수와 화살표 함수</li><li>Promise</li></ul><h3>자바스크립트에서의 함수형 프로그래밍을 위한 타입과 값</h3><p>자바스크립트에서 함수형 프로그래밍을 하기 위해서는 타입과 값에 대한 추상을 정확히 해둘 필요가 있습니다. 또한 어떠한 전략을 취할 것인지를 정의해야합니다. 이것을 통해 다양한 함수 합성을 더 안전하게 할 수 있다는 믿음을 가질 수 있게 되며, 이것은 복잡성을 정복하고 안정성을 얻기 위한 중요한 기초가 됩니다.</p><p>좋은 전략을 정하기 위해서는 먼저 자바스크립트의 내장 타입과 값들의 특징에 대해 정확히 이해하는 것이 필요하고, 그 위에 함수형 프로그래밍 언어들이 가진 전략들을 잘 취사하여 올려야 합니다. 자바스크립트는 멀티패러다임 언어이며, 다른 함수형 언어들이 갖는 뼈대 전략이 없는 편입니다. 그렇지만 걱정하지는 않아도 됩니다. 자바스크립트는 높은 수준의 함수형 코드를 작성할 수 있게 하는 많은 기능을 지원합니다.</p><p>함수형 프로그래밍에서 데이터 타입에 대한 컨셉은 크게 두 가지 계열이 있고, 하스켈과 클로저를 통해 생각해볼 수 있습니다. 두 언어 모두 데이터 타입에 대한 명확한 철학을 지니며, 그 뼈대 위에 안전하게 합성하기, 모듈화 수준 높이기, 부수 효과를 없애거나 구분하기, 불변성 이루기, 동시성/병렬성 잘 다루기 등의 목적을 이루고 있습니다.</p><p>하스켈은 ADT와 타입 클래스를 통해 개발자가 새로운 타입이나 함수를 만들 때에도 안전한 합성을 가능하게 하며, 모나드를 통해 부수 효과를 철저히 관리하고, 강력한 타입 시스템을 통해 견고한 프로그램을 작성할 수 있게 합니다. 클로저는 적은 종류의 데이터 구조와 추상, 그리고 영속성(Persistent data structure)을 통해 높은 다형성/불변성을 지원하여 문구(form)/함수 조합을 극대화 할 수 있게 합니다.</p><p>그렇다면 자바스크립트에서의 함수형 프로그래밍에서는 어떤 전략을 취할 수 있을까요. 결론은 하스켈이나 클로저 스타일을 자바스크립트 위에 적용하는 것이겠지만 ADT, 지연성, 불변성, head, tail 등을 엄격하게 구현할수록 불필요한 자원 사용이 많아져 성능이 떨어지게 되기도 하고, 자바스크립트만이 가진 일부 장점이 사라지게도 되고, 다른 자바스크립트 세상과의 조합성이 낮아지게 되기도 하니, 균형을 잘 찾는 것이 필요합니다.</p><h3>JSON 데이터 타입</h3><p>JSON으로 표현 가능한 값인 string, number, object, array, true, false, null은 자바스크립트에서 다루기 매우 좋고 빠릅니다. 이 값들은 JSON.strigify()를 하기 위해 myObj.toJSON() 등의 작업을 할 필요가 없어, 중첩된 데이터를 다루거나 다른 환경으로 전송하거나 저장하고 꺼내쓸 때 매우 쉽습니다. 자바스크립트는 JSON을 만들기 위해 별도의 작업을 할 필요가 없다는 특별한 장점을 가지고 있습니다.</p><p>JSON을 중심으로 프로그래밍을 할 경우 적은 종류의 데이터 구조와 추상 전략을 취할 수 있습니다. 이는 조합성을 높이고, 함수의 재사용성을 높일 수 있게 합니다. 만일 백엔드 프로그래밍을 NodeJS로 하고 있다면, 프론트엔드와 백엔드에서 공유할 코드도 얻을 수 있습니다.</p><pre>const json = {<br>  string: &quot;text&quot;,<br>  number: 1,<br>  object: {<br>    key1: &#39;val1&#39;,<br>    key2: &#39;val2&#39;<br>  },<br>  array: [1, 2, 3],<br>  others: [true, false, null]<br>}</pre><h3>undefined</h3><p>undefined는 정의되지 않은 변수나, 리턴 값이 없는 함수, 객체에 정의되지 않은 key 접근을 통해 얻게 됩니다. undefined는 DB에 저장할 수도 없고, JSON으로 전달할 수도 없습니다. 서버 API를 통해 undefined 받게될 가능성도, undefined를 다른 컴퓨터로 전달할 방법도 없습니다. 때문에 자바스크립트 외부 세상으로 부터 전달 받을 수 있는 값이 아닙니다.</p><p>런타임에서 직접 undefined를 할당하지만 않는다면 undefined를 &#39;함수를 실행해서 아무것도 찾지 못했거나, 아무것도 하지 못했을 때&#39;를 나타내는 구분자로 사용하기에 적합합니다. 실제로 이렇게 쓰이는 내장 함수나 라이브러리들이 많으며, 나머지 매개 변수의 구분자도 undefined입니다.</p><pre>[1, 2, 3].find(a =&gt; a &gt; 3);<br>// undefined</pre><pre>const sub = (a = 0, b = 0) =&gt; a - b;<br>console.log(sub(10, 5)); // 5<br>console.log(sub(10)); // 10<br>console.log(sub(10, undefined)); // 10</pre><p>Maybe, Just, Nothing의 모든 가치를 담아올 수는 없지만, 자바스크립트의 값을 undefined와 아닌 것으로 바라볼 수 있기 때문에 Nothing의 역할을 대신할 수 있습니다. 대표적으로 find 같은 함수가 Maybe를 리턴하는데, 자바스크립트에서 find와 같은 함수를 구현할 경우, 아무것도 찾지 못했을 때 undefined를 리턴하는 식으로 약속할 수 있습니다.</p><p>이 글에서 작성하는 함수형 코드에서는 ‘아무것도 찾지 못했거나, 아무일도 하지 못했을 때’를 구분하기 위한 값으로 undefined를 사용하고자 합니다.</p><h3>열거 가능한 값, 컬렉션</h3><p>함수형 프로그래밍에서는 컬렉션을 많이 다룹니다. 특히 실무적으로는 더욱 그렇습니다. 컬렉션을 다루는 대표적인 함수인 map, filter, reduce, find에서 사용할 수 있는 값들을 아래와 같이 정할 수 있습니다. iterator 혹은 Generator를 실행한 결과 값을 이용하면 무한 수열도 표현할 수 있습니다.</p><ol><li>JSON 데이터 타입 내의 object</li><li>Array, Map, Set …</li><li>그 외 [Symbol.iterator]()가 구현된 모든 iterable과 iterator</li><li>Generator를 실행한 결과 값</li></ol><h3>컬렉션 순회</h3><p>for, while, i++, j++, length 등을 이용한 루프는 명령적이고 코드가 복잡합니다. i++등을 직접 다루거나 순회하는 객체의 값을 변경하면 영향을 받기도 합니다. 스코프와 실행 컨텍스트와 관련된 실수도 일어나게도 됩니다. 게다가 비동기 상황 등을 고려하면 파편화가 심해집니다. 그렇다고 head, tail로 추상화하기에는 성능 이슈가 만만치 않습니다.</p><p>ES6의 for...of를 사용하면 이런 문제를 최소화할 수 있고 for...of 문은 상당히 선언적입니다. for...of 문은 Iterable/Iterator 프로토콜을 따르기 때문에 다형성이 높고, 비동기 상황에서의 재귀등의 복잡한 로직을 파편화 없이 구현할 수 있습니다. 따라서 자바스크립트에서 순회를 해야할 때는 for...of를 사용하면 좋습니다. 그렇게하면 상대적으로 안전한 명령형 프로그래밍을 할 수 있게 되고, 함수형 프로그래밍에 사용될 함수들을 간결한 코드로 구현할 수 있습니다.</p><pre>function map(f, coll) {<br>  const res = [];<br>  for (const val of coll) res.push(f(val));<br>  return res;<br>}<br>console.log(<br>  map(a =&gt; a + 10, [1, 2])<br>);</pre><h3>불변성</h3><p>함수형 프로그래밍에서 불변성은 매우 중요한 키워드입니다. 자바스크립트에는 불변성을 지원하는 값이 존재하지 않습니다. Object.freeze는 객체를 불변하도록 만들지만, 객체의 값이 변하지 않는 것은 불변성의 일부일 뿐입니다. 불변성에서 더 중요한 내용이자 목적은 불변적으로 데이터를 &#39;변형&#39;하는 것입니다. 이것은 한 번 정의한 값을 직접 변경하지 않고, 변형된 새로운 값으로 만드는 것을 말합니다. 자바스크립트에서 이것을 달성하기 위해 잘 숙지해야 할 것은, 값이 전달/할당될 때 원시 값의 경우는 복사를, 객체의 경우는 레퍼런스 사본을 생성한다는 규칙입니다. 이 규칙들을 각기 다르게 다루는 함수와 연산자 등을 잘 조합하여 불변성을 지켜야 합니다.</p><h4>불변적으로 배열 변형하기</h4><pre>const list = [1, 2];<br>console.log([...list, 3]);<br>// [1, 2, 3]<br>console.log(list);<br>// [1, 2]</pre><h4>불변적으로 객체 변형하기</h4><pre>const object = { a: 1, b: 2 };<br>const object2 = { ...object, ...{ b: 3 } };<br>console.log(object2, object2.b); // {a: 1, b: 3} 3<br>console.log(object, object.b); // {a: 1, b: 2} 2</pre><pre>const object3 = Object.assign({}, object, { a: 2 });<br>console.log(object3, object3.a); // {a: 2, b: 2} 2<br>console.log(object, object.a); // {a: 1, b: 2} 1</pre><h3>함수와 화살표 함수</h3><p>자바스크립트의 함수는 매우 강력하고, 화살표 함수는 간결합니다. 일급 함수, 클로저, 전개 연산자, 기본 매개 변수, 나머지 매개 변수, 구조 분해 등의 기능으로 무장한 자바스크립트의 함수는 높은 수준의 함수형 프로그래밍을 가능하게 하고, 멋진 표현력을 갖고 있습니다.</p><pre>const curry2 = f =&gt; (..._) =&gt; <br>  _.length &lt; 2 ? (..._2) =&gt; f(..._, ..._2) : f(..._);</pre><pre>const add = curry2((a = 0, b = 0) =&gt; a + b);</pre><pre>const add10 = add(10);</pre><pre>console.log(add10(5)); // 15<br>console.log(add10(10)); // 20<br>console.log(add10(undefined)); // 10</pre><h3>Promise</h3><p>Promise는 보통 소개된 것보다 훨씬 많은 가능성을 지닌 값이며, 자바스크립트에서의 동시성/비동기 프로그래밍을 지탱하는 기반입니다. ES6+에서는 */yield, async/await와 함께 사용될 수 있습니다.</p><p>자바스크립트에서 비동기 프로그래밍은 매우 중요하며, bluebird, js-csp, co, RxJS 등의 다양한 비동기 해법들이 제시되고 있습니다. 이 글에서는 일급 객체로서의 Promise 활용을 통해 다양한 함수의 인자와 결과 값으로 전달하면서 높은 수준의 동시성 프로그래밍을 구현하는 사례들을 다룰 것입니다.</p><h3>모든 예제 코드</h3><ul><li><a href="https://github.com/Functional-JavaScript/functional.es">https://github.com/Functional-JavaScript/functional.es</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=703ebd418bc" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Functional.es - 1. 타입과 값]]></title>
            <link>https://medium.com/@indongyoo/functional-es-1-%ED%83%80%EC%9E%85%EA%B3%BC-%EA%B0%92-4fc73d4b7023?source=rss-8f6f43b6a5c2------2</link>
            <guid isPermaLink="false">https://medium.com/p/4fc73d4b7023</guid>
            <category><![CDATA[es6]]></category>
            <category><![CDATA[functional-javascript]]></category>
            <category><![CDATA[functional-programming]]></category>
            <dc:creator><![CDATA[유인동]]></dc:creator>
            <pubDate>Sat, 31 Mar 2018 16:28:16 GMT</pubDate>
            <atom:updated>2018-04-03T08:18:28.333Z</atom:updated>
            <content:encoded><![CDATA[<h4>함수형 자바스크립트와 ES6+</h4><p><a href="https://github.com/Functional-JavaScript/functional.es/blob/master/articles/ES6%2C%20%ED%95%A8%EC%88%98%ED%98%95%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%2C%20%EB%B9%84%EB%8F%99%EA%B8%B0%2C%20%EB%8F%99%EC%8B%9C%EC%84%B1%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/1.%20%ED%83%80%EC%9E%85%EA%B3%BC%20%EA%B0%92.md">원본 글 Github에서 보기</a></p><h3>목차</h3><ul><li>7가지 내장 타입으로 바라보기</li><li>자바스크립트에서의 객체</li><li>JSON 데이터 타입</li><li>Iterable, Iterator</li><li>Symbol.iterator</li><li>ES6의 Iterable/Iterator 프로토콜 맞추기, 그리고 Generator</li><li>iterator[Symbol.iterator]() == iterator, 그리고 Generator</li><li>유사 배열</li><li>Promise</li></ul><p>이 글에서는 함수형 프로그래밍에 대해 다루기 앞서 자바스크립트의 타입들과 ES6의 값들에 대해 다뤄봅니다. 자바스크립트의 타입과 값의 특성과 함수형 프로그래밍과 연관 있는 부분들을 살펴봅니다.</p><h3>7가지 내장 타입으로 바라보기</h3><p>자바스크립트에는 7가지 내장 타입이 있습니다.</p><ul><li>null</li><li>undefined</li><li>boolean</li><li>number</li><li>string</li><li>object</li><li>symbol</li></ul><p>위 타입은 다시 크게 두 가지로 나눌 수 있습니다. 객체(object)와 객체가 아닌 것입니다. 위 7가지 타입에서 객체를 제외한 모든 값은 원시 값이며, 원시 값의 경우 인자로 전달하거나 할당할 때 항상 값 복사가 이루어지고, 객체의 경우는 항상 레퍼런스 사본을 만듭니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/28e706af5e43798f3c177d78a9a1caac/href">https://medium.com/media/28e706af5e43798f3c177d78a9a1caac/href</a></iframe><p>원시타입과 객체의 전달/할당이 위와 같이 이루어지는 것을 잘 인지하고 다루는 것이 중요합니다. 이는 자바스크립트로 함수형 프로그래밍을 할 때 중요하며, 특히 불변성을 다루는 기초가 됩니다.</p><h3>자바스크립트에서의 객체</h3><p>자바스크립트에서의 Array, Map, WeakMap, Set, WeakSet, Promise 등은 모두 object의 하위 타입입니다.</p><pre>log(typeof {}); // &quot;object&quot;<br>log(typeof []); // &quot;object&quot;<br>log(typeof new Map); // &quot;object&quot;<br>log(typeof new Set); // &quot;object&quot;<br>log(typeof new Promise(a =&gt; a)); // &quot;object&quot;</pre><h3>JSON 데이터 타입</h3><p><a href="https://www.json.org/json-ko.html">JSON 데이터 타입</a>은 다음과 같습니다.</p><ul><li>string</li><li>number</li><li>object</li><li>array</li><li>true, false, null</li></ul><p>JSON은 경량의 DATA-교환 형식이면서, 현대 프로그래밍에서 가장 많이 사용되는 DATA-교환 언어입니다.</p><p>위 값에 해당하지 않는 모든 값은 JSON으로 직렬화가 불가능합니다. 예를 들면 undefined도 JSON으로 직렬화할 수 없습니다.</p><pre>JSON.stringify(undefined);<br>// undefined &lt;--- 이건 JSON String이 된 것이 아니라 함수가 실패해서 undefined가 리턴된 것입니다.</pre><pre>JSON.stringify({ a: undefined });<br>// &quot;{}&quot;</pre><pre>JSON.stringify([undefined]);<br>// [null]</pre><p>Map이나 Set 역시 JSON으로 직렬화할 수 없습니다.</p><pre>JSON.stringify(new Set([1,2,3]));<br>// {}<br>JSON.stringify(new Map([[&#39;a&#39;, 1]]));<br>// {}</pre><p>이처럼 자바스크립트에서는 JSON으로 직렬화할 수 있는 값과 그렇지 않은 값으로, 다시 두 가지로 나누어 데이터를 바라볼 수 있습니다.</p><h3>Iterable, Iterator</h3><p>ES6에는 Iterable/Iterator에 대한 프로토콜이 있고, 그것은 ES6에서 매우 중요합니다. 자바스크립트에서 Iterable, Iterator, Symbol.iterator, Generator 등은 자바스크립트의 for...of 문이나 전개 연산자 등과 사용됩니다. 이것들은 ES6에서 함수형 프로그래밍을 하는 것에 있어서도 아주 중요한 역할을 합니다.</p><p>ES6의 String, Array, Map, Set 등은 아래와 같이 사용가능하도록 Symbol.iterator 프로퍼티를 가진 객체입니다.</p><pre>for (const val of [1, 2]) log(val);<br>// 1<br>// 2</pre><pre>for (const val of new Set([3, 4])) log(val);<br>// 3<br>// 4</pre><pre>log( [...[1, 2], ...new Set([3, 4])] );<br>// [1, 2, 3, 4]</pre><h3>Symbol.iterator</h3><h3>ES6의 Iterable/Iterator 프로토콜 맞추기, 그리고 Generator</h3><p>자바스크립트에서 for...of나 전개 연산자(...)와 잘 동작하려면 Symbol.iterator를 잘 사용해야합니다.</p><ol><li>iterable은 iterable[Symbol.iterator](); 메서드를 가져야하고, 결과는 iterator여야합니다.</li><li>iterator는 iterator.next() 메서드를 가져야하고, 결과는 { value: someting, done: true/false } 여야 합니다.</li></ol><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9f616c53d8e5b2d642328719ee419bb3/href">https://medium.com/media/9f616c53d8e5b2d642328719ee419bb3/href</a></iframe><h3>iterator[Symbol.iterator]() == iterator, 그리고 Generator</h3><ol><li>iterator도 iterator[Symbol.iterator]();를 갖도록 하고, iterator[Symbol.iterator]() == iterator라면 더욱 잘 만들어진 iterator라고 할 수 있습니다.</li><li>자바스크립트의 내장 iterables의 ‘iterator를 리턴하는 메서드’를 실행하여 얻은 iterator는 모두 iterator[Symbol.iterator]() == iterator와 같은 규약을 지키고 있습니다.</li><li>Generator를 통해 만든 iterator 역시 iterator[Symbol.iterator]() == iterator을 지킵니다.</li></ol><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/4e96edba3130e5d0d7cd73fbd8863bd7/href">https://medium.com/media/4e96edba3130e5d0d7cd73fbd8863bd7/href</a></iframe><p>앞서 for (const val of reverseIterator([1, 2])) log(val);에서는 에러가 발생했지만, iterator에 [Symbol.iterator]()를 구현하여 for...of에서 정상동작하게 되었습니다. 3, 4, 5를 잘 응용하면 for...of와 잘 동작하는 것을 넘어, 데이터 순회에 대한 매우 재밌고 새로운 해법들을 만들 수 있어 매우 중요합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/a2ea0a72100c33a906e2ac1fe27ceacf/href">https://medium.com/media/a2ea0a72100c33a906e2ac1fe27ceacf/href</a></iframe><h3>유사 배열</h3><p>유사 배열은 { 0: 10, 1: 20, length: 2 }와 같은 객체를 말합니다. 다음과 같은 유사 배열은 전개 연산자나 for...of와 사용될 수 없습니다.</p><pre>const arrayLike = { 0: 10, 1: 20, length: 2 };<br>for (const val of arrayLike) log(val);<br>// Uncaught TypeError: arrayLike is not iterable</pre><p>물론 유사 배열을 순회할 수 있게 하는 generator를 만든다면 for...of 에서 사용할 수 있겠지만, ES6부터는 iterable이 아닌 유사 배열을 사용하지 않는 방향으로 가야합니다. 자바스크립트 3rd party library의 값들 중에는 아직 iterable/iterator 프로토콜을 따르지 않는 유사 배열도 있지만, 모두 ES6의 프로토콜에 맞게 변경될 것입니다.</p><p>대표적인 유사 배열로는 arguments, NodeList 등이 있습니다. 최신 환경에서 해당 값들은 iterable이 되었습니다. [Symbol.iterator]()가 구현되어있어, for...of나 전개 연산자와 사용할 수 있습니다.</p><pre>!function() {<br>  for (const val of arguments) log(val);<br>  // 3<br>  // 4</pre><pre>  log(1, 2, ...arguments);<br>  // 1 2 3 4<br>} (3, 4);</pre><p>최신 브라우저의 열거 가능한(enumerable) 속성이 있는 값들은 Iterable/Iterator 프로토콜을 잘 따르고 있습니다.</p><p>Iterable/Iterator 프로토콜에 대한 재밌는 아이디어들은 이후 글에서 더 소개하겠습니다.</p><h3>Promise</h3><p>Promise는 비동기적으로 대기(Pending) / 성공(Fulfilled, resolve) / 실패(Rejected, reject)를 다루는 값입니다. ES6+에서는 Promise와 관련하여 new Promise, then, catch, race, Promise.all, Promise.resolve, Project.reject 등을 지원합니다. Promise를 활용한 다양한 사례는 이후 글에서 더 소개하겠습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/602f935cbc84908e2f86823b09e8485e/href">https://medium.com/media/602f935cbc84908e2f86823b09e8485e/href</a></iframe><h3>모든 예제 코드</h3><ul><li><a href="https://github.com/Functional-JavaScript/functional.es">https://github.com/Functional-JavaScript/functional.es</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4fc73d4b7023" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Functional.es - 0. 들어가며]]></title>
            <link>https://medium.com/@indongyoo/functional-es-0-%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0-33a02f549061?source=rss-8f6f43b6a5c2------2</link>
            <guid isPermaLink="false">https://medium.com/p/33a02f549061</guid>
            <category><![CDATA[functional-javascript]]></category>
            <category><![CDATA[functional-programming]]></category>
            <category><![CDATA[es6]]></category>
            <dc:creator><![CDATA[유인동]]></dc:creator>
            <pubDate>Sat, 31 Mar 2018 15:55:57 GMT</pubDate>
            <atom:updated>2018-04-01T17:24:48.516Z</atom:updated>
            <content:encoded><![CDATA[<h4>함수형 자바스크립트와 ES6+</h4><p><a href="https://github.com/Functional-JavaScript/functional.es/blob/master/articles/ES6%2C%20%ED%95%A8%EC%88%98%ED%98%95%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%2C%20%EB%B9%84%EB%8F%99%EA%B8%B0%2C%20%EB%8F%99%EC%8B%9C%EC%84%B1%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/0.%20%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0.md">원본 글 Github에서 보기</a></p><h3>ES6, 함수형 프로그래밍, 비동기/동시성 프로그래밍</h3><p>자바스크립트는 많은 발전 끝에 ES6+가 되었습니다. 자바스크립트가 동작하는 많은 최신 환경들에서는 ES6 이후의 기술들도 빠르게 적용되고 있습니다. 이 글에서는 ES6을 기반으로한 자바스크립트에서의 함수형 프로그래밍과 비동기/동시성 프로그래밍에 대한 이야기를 다룹니다.</p><h3>ES6+</h3><p>이 글에서는 ES6+의 다음의 기술들을 사용할 것입니다.</p><ul><li>함수, 화살표 함수</li><li>전개 연산자, 구조 분해, 나머지 매개 변수</li><li>for of</li><li>Iterable, Iterator, Symbol.iterator, Generator</li><li>Set, Map, WeakMap</li><li>Promise</li><li>async/await</li></ul><h3>함수형 프로그래밍</h3><p>‘자바스크립트와 함수형 프로그래밍’ 혹은 ‘함수형 ES6+’라는 느낌으로 글을 써보려고 합니다. 자바스크립트에서의 타입, 함수, ES6 스펙 등의 특성을 살펴보면서 Vanilla JS 혹은 ES6과 잘 어울리고 잘 어우러지는 함수형 프로그래밍 스타일을 소개하고자 합니다.</p><h3>비동기/동시성 프로그래밍</h3><p>더 많고 다양해지는 데이터 통신, 실시간성, 애니메이션이 가미된 UI/UX 등으로 인해 소프트웨어 개발의 복잡도는 증가하고 있고, 자바스크립트에서의 비동기/동시성 프로그래밍은 점점 더 중요해지고 있습니다. 함수형 프로그래밍 기법을 잘 사용하면 위와 같은 문제들을 잘 해결할 수 있습니다. 동시적으로 동작해야하는 복잡한 로직을 간결하게 작성하는 방법들에 대해 소개하고자 합니다.</p><h3>모든 예제 코드</h3><ul><li><a href="https://github.com/Functional-JavaScript/functional.es">https://github.com/Functional-JavaScript/functional.es</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=33a02f549061" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>