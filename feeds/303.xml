<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>노태환의 블로그</title>
    <description>기술과 개발 그리고 그 외의 것들에 대한 개인적인 경험, 생각을 담아냅니다.
</description>
    <link>https://taehwanno.github.io/</link>
    <atom:link href="https://taehwanno.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 26 Jan 2017 05:28:38 +0000</pubDate>
    <lastBuildDate>Thu, 26 Jan 2017 05:28:38 +0000</lastBuildDate>
    <generator>Jekyll v3.3.1</generator>
    
      <item>
        <title>스타트업 개발자 1년 그리고 2016년 회고</title>
        <description>&lt;p&gt;&lt;img src=&quot;/assets/16-12/lawoafactory-logo.png&quot; alt=&quot;lawoafactory logo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;해당 글은 작년 12월부터 시작해서 이제 갓 1년을 꽉 채운 주니어 개발자가 2016년 1년동안 스타트업에서 생활하면서 느낀 점을 적은 글입니다. “이렇게 느낄 수도 있겠다!”라며 가볍게 봐주시면 감사하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;“어제 그거 봤어? 내가 보기엔 좋아보이더라”&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;개발자의 성향에 따라 다르게 받아들일 수 있지만 내가 원하는 건 지금 도입하자가 아니라 그냥 대화를 원한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프론트엔드의 세계는 급속히 발전하고 있으며 내일이 되면 또 다른 개념과 도구가 등장한다. 개인적인 생각으로는 새로운 기술이 만들어지는 것은 자연스러운 현상이라고 생각하고 그 기술이 만들어질 때 배경이 중요하다고 생각한다. 개발한 동기는 무엇인지, 어떤 문제를 해결하려고 하는 것인지, 그 문제는 어떤 상황에서 문제가 되는지 말이다. “어제 그거 봤어? 내가 보기엔 좋아보이더라”와 같은 질문을 동료 개발자에게 할 때 내가 새로운 기술에 대해 개방적인 것을 아는 개발자분이 스트레스를 받을 가능성이 있다는 걸 알게되었다. 처음에 이런 사실을 깨달았을 때 내가 잘못된 걸까라는 생각을 했지만 지금 생각으로는 새로운 기술을 배워야한다는 부담감과 시장에서 경쟁력있는 개발자가 될 수 있을까에 대한 걱정이 겹쳐서 생겨난 일종의 방어기제라고 생각하고 있다. 새로운 기술에 대해 반감을 가지는 사람도 있을 수 있는데 안정적인 기술 스택이 요구되는 상황에서 생활해오셨다면 충분히 그럴 수 있다고 생각한다. 정리한다면, 내 잘못도 아니며 개발자의 성향에 따라 달라질 수 있다는 것. 내가 이런 질문을 한다면 단지 대화를 원한다는 것.&lt;/p&gt;

&lt;h1 id=&quot;git-github------&quot;&gt;git, github 사용이 자유로워지고 오픈소스를 바라보는 시각이 변했다.&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;도구로부터 최대한 자유로워지려 노력하자. 문화를 보려하자.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;git, github을 오래전부터 사용했는데 브랜치를 생성해서 커밋을 남기고 마스터에 병합도 해봤고 &lt;code class=&quot;highlighter-rouge&quot;&gt;bisect&lt;/code&gt;를 통해 디버깅도 해봤고 fork를 통해 저장소를 만들고 로컬로 내려받아서 수정 후 pull request를 제출해서 기여도 해봤는데 자유롭게 활용하고 있지는 않다는 느낌을 계속해서 받아오고 있었다. 커밋 하나하나 남기는 것 자체가 고된 일이 되고 스트레스가 되고 있다는 것을 깨닫는 순간 왜 이런 문제가 생기고 있는지 혼자 생각하기 시작했다.
커밋을 남길 때 스트레스가 받는 이유는 커밋을 생성한 후 해당 커밋을 수정해야할 상황이 큰 부담으로 다가왔고 &lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt;를 정확히 이해하지 못해서 커밋을 하게 되면 가장 최근 커밋을 제외하고는(&lt;code class=&quot;highlighter-rouge&quot;&gt;--amend&lt;/code&gt;) 불가역적인 커밋이 된다고 생각한 것이다. 이런 문제를 인식하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt;를 내가 생각할 수 있는 모든 상황에 대해 적용하고 연습한 결과 지금은 정말 자유로워졌다. 이제는 부담을 가지기 보다는 “좋은 커밋을 작성하려면 어떻게 해야할까?”, “issue와 pull request의 작성은 어떻게 해야할까?”, “github flow, git flow 등 브랜치 전략은 왜, 어떻게 가져야할까?”로 이어졌다.&lt;/p&gt;

&lt;p&gt;그리고 github을 통해 여러 오픈소스를 바라보는 시각이 변화했다. 하나의 예를 든다면 angular.js가 digest loop라는 이벤트 루프를 만들어서 dirty checking을 통해 뷰와 모델을 동기화한다는 것을 알게 되고나서 처음 든 생각은 “자바스크립트 자체가 이벤트 루프 기반인데 거기에 자신들만의 가상의 루프를 만든거야? 어떻게 한거지?” 같은 호기심 때문에 어떻게 구현했는지 코드를 보고싶을 때는 해당 코드 부분을 디렉토리 내부에서 찾아서 보기만 했을 것이다. 하지만 지금은 &lt;code class=&quot;highlighter-rouge&quot;&gt;README.md&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;CONTRIBUTING.md&lt;/code&gt;를 읽고 issue와 pull request, label, milestone, 대화, CI 등을 보면서 자리잡고 있는 문화를 보려하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;CHANGELOG.md&lt;/code&gt;를 참고해서 배포 주기는 어떤지, breaking changes는 많은지 살펴볼 능력도 생겼다.&lt;/p&gt;

&lt;p&gt;또 다른 시각의 변화는 오픈소스는 실질적으로 무료가 아니며 만능이 아니라는 것이다. 하나의 오픈소스를 도입해야할 때는 어떤 도구가 더 우위를 선점하고 있는지, 왜 우위를 선점하고 있는지 각 도구의 장단점은 무엇인지 현재 상황에 더 알맞는 도구는 무엇인지 판단을 내리는 과정에 적지 않은 리소스가 투자된다. 또한 그 오픈소스를 도입한다고 결정을 했더라도 개발자 개인의 학습비용, 도입시 발생한 문제에 대해 해결방법이 존재하지 않을때 직접 기여를 해야하는 상황이 존재할 가능성이 충분히 존재하며 더 이상 메인테이닝되지 않을때 다른 도구로 이전하거나 최악의 경우 직접 메인테이닝해야하는 위험까지 수반될 수 있다. 즉, 의존성을 가진다는 것은 어떤 특정 기술에 의지한다는 것을 의미하고 이는 어떤 상황에서 발생하는 문제점을 해결해줄 수 있지만 자칫 잘못하면 뒷통수를 쎄게 맞을 수 있다는 것을 의미한다. 기술에 적당히 의존하자.&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;프레임워크와 라이브러리를 선택할 때 고려해야할 사항&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;어떤 문제를 해결하려고 하는 것인가?&lt;br /&gt;
그 문제는 어떤 상황에서 문제인가?&lt;br /&gt;
나도 그 문제에 직면한 것인가? 직면했던 것인가? 직면할 것인가?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;“react.js를 배워야할 거 같아. 근데 redux도 보통 같이 쓰네? 나도 써야겠다.”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;위에서는 뷰 라이브러리인 react.js와 데이터 컨테이너인 redux를 예로 들었지만 단어만 바꿔서 다른 기술에 대입해서 생각해보면 된다. 개발자 개인이 자신의 기술 스펙트럼을 넓히기 위해 새로 배우는 기술 문서의 튜토리얼을 따라해본다던지 제너레이터를 이용해서 프로젝트 구조를 살펴본다던 지 할 수 있다. 현재 내가 새로운 기술을 배울 때 거치는 과정을 의식적으로 생각해봤을 때 아래 같은 과정으로 습득하는 것 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;처음에는 프레임워크이든 라이브러리던지 간에 대략적인 개념만 머리에 잡는다.&lt;/li&gt;
  &lt;li&gt;튜토리얼에 존재하는 코드를 따라 치면서 해당 섹션을 통해 무엇을 가르쳐주려는지 핵심만 이해하려 노력한다.&lt;/li&gt;
  &lt;li&gt;내 개인적인 생각을 정리해본다.&lt;/li&gt;
  &lt;li&gt;구글을 통해 여러 가지 글을 살펴본다. (옹호하는 글과 비판하는 글 양쪽 입장을 반드시 골고루 읽는다.)&lt;/li&gt;
  &lt;li&gt;다시 내 개인적인 생각을 정리해본다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이렇게 해오고 있는데 요즘드는 생각은 간단한 토이 프로젝트를 만들 수 있는 수준이 되었을 때 몇가지 질문이 해결되지 않으면 정확히 말해서 고민을 해본 시도 자체가 없다면 실제 프로젝트에 도입했을 때 문제를 해결하려고 도입했던 기술이 오히려 문제를 발생시키는 순환참조같은 상황이 발생할 수 있다는 것을 알게 되었다.&lt;/p&gt;

&lt;p&gt;해당 섹션의 처음 3가지 질문은 요즘들어 내 자신에게도 자주 하고 있는 질문이다.&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;오픈소스 커스터마이징을 진행하면서&lt;/h1&gt;

&lt;p&gt;처음에는 단지 좋아보여서 사용했던 기술이 지금 내 환경에는 맞지 않는 부분이 하나, 둘 보이기 시작했고 마감기한은 다가오지만 핵심 기술로 자리잡은지 오래였다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;“그래, 커스터마이징하자”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 큰 결정이 너무나 패기로운 결정을 할 때 현재 프론트엔드 프레임워크 및 라이브러리 상황은 이렇고 아키텍쳐 흐름은 어떻고 내 상황은 이렇고 HTML, CSS 구조는 어떻다..라는건 하나도 없는 비논리적인 결정이었다. 일을 시작한지 4, 5개월 정도 되었을 무렵에 커스터마이징을 한다는 결정을 혼자서 내렸다. 팀원과 대화를 할 생각조차 못할 정도로 짐을 혼자 짊어진 것 마냥 부담감을 가지고 있었고 그 부담감은 곧바로 조급함으로 이어져 몇번이나 코드를 다시 작성했는지 모르겠다. 어려운 점은 다음과 같았다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;전체 코드 스타일 및 구조 파악 필요&lt;/li&gt;
  &lt;li&gt;전체 빌드 과정의 이해 필요&lt;/li&gt;
  &lt;li&gt;원래 저장소의 기여 절차 및 방법 이해 필요 (문화에 대한 이해)&lt;/li&gt;
  &lt;li&gt;upstream의 수정된 사항들에 대한 반영 방법 고려 및 시기 조정&lt;/li&gt;
  &lt;li&gt;커스터마이징한 코드의 versioning 문제&lt;/li&gt;
  &lt;li&gt;API 문서화 미흡으로 인해 프로젝트를 코드 레벨에서 이해 필요&lt;/li&gt;
  &lt;li&gt;객체지향 및 디자인 패턴에 대한 이해도 부족&lt;/li&gt;
  &lt;li&gt;raw 데이터를 다뤘던 경험 부족&lt;/li&gt;
  &lt;li&gt;각 레이어 사이에 전달되는 메시지 흐름 파악과 worker 사용으로 인한 테스크 큐의 높은 이해도 필요&lt;/li&gt;
  &lt;li&gt;하…..&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;진행을 하면 할수록 나는 정말 한참 부족한 개발자구나 내가 멍청하게 결론내렸던 이 결정이 어쩌면 나 하나만의 문제로 끝나지 않고 회사에 영향을 줄 수도 있겠다는 생각이 들었고 미친듯이 공부하기 시작했다. 결론적으로 말하면 내 실력이 성장하는데 가장 큰 영향을 준 것은 커스터마이징이다. 그 누구와도 이 부분에 대해 대화를 나눠본적이 없지만 확실하게 말할 수 있다.&lt;/p&gt;

&lt;p&gt;6번의 경우 정말 지옥이었는데 코드는 정말 예술적인데 문서화가 안되어 있어서 개발자를 몇번 욕한지 모르겠다. 보통 관심가는 오픈소스에 기여하고 싶을 때 시작점을 어디서 잡을지 감이 안오는 상황과 비슷한데 이 때는 해당 기술을 직접 호출하는 부분부터 타고 내려갔다. 어떤 함수가 될 수 있고 어떤 객체의 메소드가 될 수도 있다. 코드를 읽으면서 왜 이런 과정을 거치는지 이해하려 했고 특히 비동기 코드의 향연은 인간 두뇌 성능의 한계점을 절실히 느꼈다. &lt;del&gt;프라미스가 프라미스를 프라미스해서 프라미스를 프라미스한다.&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;9번의 경우 테스크 큐의 HTML의 스펙, ECMAScript의 스펙을 동시에 확인해야했다. 무슨 &lt;code class=&quot;highlighter-rouge&quot;&gt;context&lt;/code&gt;는 왜 이렇게 많으며 내가 알던 웹이 맞는지 단어 하나가 바뀔 때 의미는 왜 이렇게 변하는지 내가 평소에 읽던 영어가 맞는지 나는 왜 이렇게 영어를 못하는지 읽어도 이해가 되지 않는지 참.. 큐와 마이크로 테스크 큐로 나뉜 것에서 왜 또 그 큐가 또 나눠져야하는지 worker의 종류는 또 나뉘고 이벤트 루프는 따로 있고 아몰랑!!! 문서를 계속 읽으면서 이벤트 리스너, 이벤트 루프에 대해 0.1%는 이해한 거 같다.&lt;/p&gt;

&lt;p&gt;기술은 그냥 뚝딱만들어지지 않는다는 것. 인하우스 개발시 개발자 개인 그리고 회사의 입장에서 고려해야할 여러가지 요소가 존재한다는 것. 나는 떠나겠지만 내가 만든 문화와 코드는 남는다는 것. 좋은 경험이었으며 아직 진행중이므로 더욱 좋은 경험이 되도록 노력해야겠다.&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;화성에서 온 개발자 금성에서 온 비개발자&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;같은 언어를 사용해서 의사소통을 하지만 우리의 시각은 다르다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;회사 내에서 기술적으로 서비스가 어떻게 구성되어 있는지 이해하고 있는 사람은 개발자이다. Multi Page 혹은 SPA(Single Page Application)로 구성되어 있는지 모를 가능성이 매우 높고 단어 자체를 들어봤다고 해도 어렴풋이 아는 사람들이 대부분일 것이다. 마케팅과 관련된 지표를 수집하기 위해 애널리틱스 코드를 넣어야할 때 “해당 스크립트만 넣어주시면 되요.”, “어떤 상황에서 코드만 실행해주면 된데요.”에서 여러가지 요소 때문에 “어떤 상황”과 “코드만 실행” 한다는 게 비개발자가 보기에는 간단해보이지만 개발자가 보기에는 다를 수 있다는 것을 경험했다.&lt;/p&gt;

&lt;p&gt;또한 기획자가 서비스의 어떤 기능을 수정, 추가하려할 때 개발자가 보기에 “왜 그렇게 해야되는지 모르겠다”는 생각이 들 때는 보통 기획 의도를 이해하려고 노력하기보다는 기술 부채를 쌓고 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;문을 남발하는 것 외에는 방법이 없을 것 같거나 코드 변경이 많아질 가능성이 높아서 이에 대한 반작용으로 나올 때가 많았다.&lt;/p&gt;

&lt;p&gt;각자의 시각이 다르니 서로가 &lt;code class=&quot;highlighter-rouge&quot;&gt;endpoint&lt;/code&gt;가 되어 대화를 통해 시각의 차이를 줄여서 진행을 한다면 더 매끄럽게 진행할 수 있지 않을까 생각한다. 이런 시각의 차이는 기획, 디자인, 마켓팅, 개발 등 모든 팀에서 가지며 심지어 팀 내부에서도 가질 수 있다. 그 말은 회사에 사람이 많아질수록 의사소통이 중요하며 회사에 자리잡힌 문화가 중요하며 문화를 형성하는 실질적인 멤버들의 생각 하나하나가 너무나 중요해진다고 생각한다. 근데 내가 그 멤버가 됐을 때 그럴 능력이 있을지는 여전히 의문이다. 과연 옳다고 생각하는 문화가 왜 옳은지 설명할 수 있을지 나의 생각에 대해 비판을 하는 팀원의 생각을 수용할 수 있을 그릇의 크기가 되어있을지 개발팀의 문화만을 챙기지는 않을지 이미 자리잡힌 문화에 대해 계약 구조상 상급자에게 의문을 제기할 수 있을지 누구의 잘잘못을 따지거나 격한 말로 감정을 상하게 하기보다는 건전한 토론을 이끌어 낼 수 있을지는 정말정말 의문이다.&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;마무리&lt;/h1&gt;

&lt;p&gt;2015년 12월 28일부터 시작해서 정신없이 1년이 지나갔다. 자료구조 기말고사 이틀전에 마음먹고 지원해서 면접을 본 회사에서 이렇게 생활하고 있을줄이야 상상도 못했는데 그냥 나름 잘지내고 있는거 같다. 다만 너무 앞에 놓인 일들에만 집중해서 살지 않았나 반성하게 된다. 내년에는 평소처럼 GDG Busan 스터디 참여하고 사내 스터디도 참여하고 개인적인 개발 공부와 더불어서 제이펍 베타리더스 활동까지 진행할 예정이다.  관심있는 오픈소스에도 기여를 해보고 싶다. 너무 욕심부리지말고 즐기면서 개발을 했으면 좋겠다. 긴글 읽어주셔서 감사합니다.&lt;/p&gt;
</description>
        <pubDate>Sat, 31 Dec 2016 11:35:00 +0000</pubDate>
        <link>https://taehwanno.github.io/post/2016/12/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85-%EA%B0%9C%EB%B0%9C%EC%9E%90-1%EB%85%84-%ED%9A%8C%EA%B3%A0</link>
        <guid isPermaLink="true">https://taehwanno.github.io/post/2016/12/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85-%EA%B0%9C%EB%B0%9C%EC%9E%90-1%EB%85%84-%ED%9A%8C%EA%B3%A0</guid>
        
        
        <category>developer</category>
        
      </item>
    
      <item>
        <title>git push --force를 통한 히스토리 관리</title>
        <description>&lt;p&gt;git, github을 사용한 지는 꽤 오래되었다. 학교 과제를 진행할 때도 코딩에 시간을 쏟는 것보다 프로젝트 관리에 소모되는 비용이 적지않은 것 같아 사용해왔었는데 최근에 유명한 오픈소스를 github을 통해 볼 때 커밋 개수가 생각보다 많지 않다는 것에 작지않은 충격을 계속해서 받아왔었다. 그리고 코어 개발자나 중심을 담당하는 개발자의 커밋 개수가 생각보다 많지 않다는 사실에 커밋 히스토리 관리를 잘못하고 있다는 느낌이 들었다.&lt;/p&gt;

&lt;p&gt;특히 내가 모르는 어떤 점이 있다고 느꼈을 때는 개발자가 pull request(이하 PR)를 올렸을 때 메인테이너로부터 바꿔달라는 요청이 들어오면 “불필요한 지역 변수 삭제”처럼 하나같이 또 다른 단일 커밋 히스토리로 다 남긴다면 커밋 히스토리가 파편화되고 장황해질 가능성이 높은데 한번 제출된 PR은 살아있으면서 대화 내용은 삭제되지 않고 커밋 개수는 늘어나지 않은 채 수정사항은 반영이 되는 이런 상황이 어떤 과정을 통해 가능한지 알고 싶었다.&lt;/p&gt;

&lt;p&gt;해당 글은 제가 실험적으로 진행해본 하나의 방법이며 피해야 할 방법일 수도 혹은 실제 활용되고 있는 방법일 수도 있습니다. git, github, github-flow를 사용한다고 가정하고 진행하도록 하겠습니다. 피드백 환영합니다!&lt;/p&gt;

&lt;h2 id=&quot;force-----&quot;&gt;–force는 사용할만한 가치가 있을 “수”도 있다.&lt;/h2&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git push -f &amp;lt;remote-repository&amp;gt; &amp;lt;branch-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/16-10/git-push-force1.png&quot; alt=&quot;git-push-force1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PR은 해당 issue를 참조했으며 각 커밋은 커밋 메시지를 통해 이슈 #1에 대한 참조를 “Fixes #1”과 같이 각각 남겼으며 총 3개의 커밋이 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/16-10/git-push-force2.png&quot; alt=&quot;git-push-force2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;메인테이너로부터 마음에 들지만 2개의 커밋이 나눠져 있다고 합쳐달라고 하는 상황이라고 하자.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git rebase -i HEAD~3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pick c50e820 Add angular.js 1
squash f6587db Add angular.js 2
pick da90224 Add react.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;다음과 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;f6584db&lt;/code&gt; 커밋을 squash해서 이전의 커밋 c50e820에 합쳐지도록 한다. interactive 리베이스 진행 후 커밋 히스토리는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git log --oneline

bd0ca01 Add react.js
b308479 Add angular.js &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1, 2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
300dac7 Add README.md
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;원래 브랜치에 존재했던 2개의 커밋 모두 해시값이 변경되었다. 그리고 angular.js에 대한 커밋은 커밋 메시지도 변화했다.
여기서 옵션 없이 &lt;code class=&quot;highlighter-rouge&quot;&gt;git push&lt;/code&gt;만 실행하면 푸시가 되지 않는데 만약 &lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt; 옵션을 통해 동일한 브랜치에 푸쉬를 한다면 PR에 존재했던 커밋과 대화, 이슈에 대한 참조들은 어떻게 처리될지 궁금했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/16-10/git-push-force3.png&quot; alt=&quot;git-push-force3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이전에 존재했던 커밋 &lt;code class=&quot;highlighter-rouge&quot;&gt;c50e820&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;f6587db&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;da90224&lt;/code&gt;는 해시값이 변경되었으므로 PR에서는 존재하지 않고 코멘트는 남아있다. 그리고 해시값이 변경된 커밋이 푸쉬되어 새로운 커밋으로 인식하므로 미리 남긴 코멘트 이후에 변경 이력이 보이게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/16-10/git-push-force4.png&quot; alt=&quot;git-push-force4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이슈로 넘어가면 PR에서 존재하지 않았던 커밋들이 살아있다. 이유는 커밋 메세지를 통해 &lt;code class=&quot;highlighter-rouge&quot;&gt;Fixes #1&lt;/code&gt;와 같이 참조를 해서 이력이 삭제되지 않고 유지되고 있다는 것을 알 수 있다. 해시값이 변경되어 추가된 커밋들도 새롭게 참조가 되고 있다는 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;해당 글에서는 2개의 커밋을 합치는 작업을 리베이스를 통해 진행했는데 합치지 않고 불필요한 지역 변수 삭제와 같이 추가적인 작업을 하고 해당 커밋은 유지해야하는 작업을 PR 생성 후 해야한다면 커밋 개수는 증가시키지 않고 issue, PR 내부에서 이루어진 대화, 이력은 살아있으면서 히스토리를 관리할 수 있게 된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--force&lt;/code&gt; 옵션은 위험한 옵션이라 주의해서 사용되어야 함을 의미&lt;/li&gt;
  &lt;li&gt;github에서만 가능한 시나리오일 가능성이 존재&lt;/li&gt;
  &lt;li&gt;다른 플로우 에서의 위험성 (&lt;code class=&quot;highlighter-rouge&quot;&gt;git-flow&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;feature&lt;/code&gt;가 규모가 커서 작은 단위로 나눠 진행할 때의 위험성)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;실험을 하고 나서 내가 원한 결과는 맞지만 올바른 방법인지는 확신을 하지 못하겠다.&lt;/p&gt;
</description>
        <pubDate>Sat, 01 Oct 2016 05:55:00 +0000</pubDate>
        <link>https://taehwanno.github.io/post/2016/10/git-push-force</link>
        <guid isPermaLink="true">https://taehwanno.github.io/post/2016/10/git-push-force</guid>
        
        
        <category>VCS</category>
        
      </item>
    
      <item>
        <title>객체지향의 사실과 오해</title>
        <description>&lt;p&gt;&lt;img src=&quot;/assets/16-09/object-orientated-programming-langs.png&quot; alt=&quot;oop-languages&quot; /&gt;
&lt;a href=&quot;http://www.kamyacademy.com/en/starting-point-object-oriented-programming/&quot;&gt;그림 출처&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;해당 글은 &lt;a href=&quot;http://book.naver.com/bookdb/book_detail.nhn?bid=9145968&quot;&gt;객체지향 사실과 오해: 역할, 책임, 협력 관점에서 본 객체지향&lt;/a&gt;을 읽으며 남긴 메모입니다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;협력하는 객체들의 공동체&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;시너지를 생각하라. 전체는 부분의 합보다 크다. - 스티븐 코비 (Stephen R. Covey)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체지향이란 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고 객체를 이용해서 시스템을 분할하는 방법이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;자율적인 객체란 상태와 행위를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력한다. 각 객체는 협력 내에서 정해진 역할을 수행하며 역할은 관련된 책임의 집합이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체는 다른 객체와 협력하기 위해 메세지를 전송하고, 메세지를 수신한 객체는 메세지를 처리하는 데 적합한 메서드를 자율적으로 선택한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;훌륭한 객체지향 설계자가 되기 위해 거쳐야 할 첫 번째 도전은 코드를 담는 클래스의 관점에서 메시지를 주고받는 객체의 관점으로 사고의 중심을 전환하는 것이다.
중요한 것은 어떤 클래스가 필요한가가 아니라 어떤 객체들이 어떤 메시지를 주고받으며 협력하는가다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-1&quot;&gt;이상한 나라의 객체&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체지향 패러다임은 지식을 추상화하고 지식을 객체 안에 캡슐화함으로써 실세계 문제에 내재된 복잡성을 관리하려고 한다.
객체를 발견하고 창조하는 것은 지식과 행동을 구조화하는 문제다. - 레베카 워프스브록 (Rebecca Wirts-Brock)[Wirts-Brock 1990]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;많은 사람들이 객체지향을 직관적이고 이해하기 쉬운 패러다임이라고 말하는 이유는 객체지향이 세상을 자율적이고 독립적인 객체들로
분해할 수 있는 인간의 기본적인 인지 능력에 기반을 두고 있기 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체가 주변 환경과의 상호작용에 어떻게 반응하는가는 그 시점까지 객체에 어떤 일이 발생했느냐에 좌우된다. … 
어떤 행동의 결과는 어떤 행동들이 일어났었느냐에 의존한다는 것이다. … 
일반적으로 과거에 발생한 행동의 이력을 통해 현재 발생한 행동의 결과를 판단하는 방식은 복잡하고 번거로우며 이해하기 어렵다.
따라서 인간은 행동의 과정과 결과를 단순하게 기술하기 위해 상태라는 개념을 고안했다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;상태는 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현한다. 객체의 상태는 객체에 존재하는 정적인 프로퍼티와
동적인 프로퍼티 값으로 구성된다. 객체의 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;행동이란 외부의 요청 또는 수신된 메세지에 응답하기 위해 동작하고 반응하는 활동이다. 행동의 결과로 객체는 자신의 상태를 변경하거나
다른 객체에게 메세지를 전달할 수 있다. 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이어야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체지향에 갓 입문한 사람들이 가장 쉽게 빠지는 함정은 상태를 중심으로 객체를 바라보는 것이다. …
협력에 참여하는 훌륭한 객체 시민을 양성하기 위한 가장 중요한 덕목은 상태가 아니라 행동에 초점을 맞추는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;협력 안에서 객체의 행동은 결국 객체가 협력에 참여하면서 완수해야 하는 책임을 의미한다.
따라서 어떤 책임이 필요한가를 결정하는 과정이 전체 설계를 주도해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;책임 - 주도 설계 (Responsibility-Driven Design, RDD)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;행동이 상태를 결정한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체지향 세계는 현실 세계의 단순한 모방이 아니다.
모방과 추상화라는 개념만으로는 현실 객체와 소프트웨어 객체 사이의 관계를 깔끔하게 설명하지 못한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;현실 세계와 객체지향 세계 사이의 관계를 좀 더 정확하게 설명할 수 있는 단어는 은유(metaphor)다.
… 은유의 본질은 한 종류의 사물을 다른 종류의 사물 관점에서 이해하고 경험하는 데 있다.
… 현실 속의 객체의 의미 일부가 소프트웨어 객체로 전달되기 때문에 프로그램 내의 객체는 현실 속의 객체에 대한 은유다.
… 은유는 표현적 차이(representational gap) 또는 의미적 차이(semantic gap)라는 논점과 관련성이 깊다.
여기서 차이란 소프트웨어에 대해 사람들이 생각하는 모습과 실제 소프트웨어의 표현 사이의 차이를 의미한다.
은유 관계에 있는 실제 객체의 이름을 소프트웨어 객체의 이름으로 사용하면 표현적 차이를 줄여 소프트웨어의 구조를 쉽게 예측할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-2&quot;&gt;타입과 추상화&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;일단 컴퓨터를 조작하는 것이 추상화를 구축하고, 조작하고, 추론하는 것에 관한 모든 것이라는 것을 깨닫고 나면 
(훌륭한) 컴퓨터 프로그램을 작성하기 위한 중요한 전제 조건은 추상화를 정확하게 다루는 능력이라는 것이 명확해진다. - 키스 데블린 (Keith Devlin)[Devlin 2003]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;… 진정한 의미에서 추상화란 현실에서 출발하되 불필요한 부분을 도려내가면서 사물의 놀라운 본질을 드러나게 하는 과정이라고 할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;… 추상화의 수준, 이익, 가치는 목적에 의존적이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;추상화란 어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;복잡성을 다루기 위해 추상화는 두 차원에서 이뤄진다. 첫 번째 차원은 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게
만드는 것이다. 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;모든 경우에 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화하는 것이라는 점을 기억하라.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;그룹으로 나누어 단순화하기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;명확한 경계를 가지고 서로 구별할 수 있는 구체적인 사람이나 사물을 객체지향 패러다임에서는 객체라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;공통점을 기반으로 객체들을 묶기 위한 그릇을 개념(concept)이라고 한다.
개념을 이용하면 객체를 여러 그룹으로 분류(classification)할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체란 특정한 개념을 적용할 수 있는 구체적인 사물을 의미한다. 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;분류란 객체에 특정한 개념을 적용하는 작업이다. 객체에 특정한 개념을 적용하기로 결심했을 때 우리는 그 객체를 특정한 집합의 멤버로 분류하고 있는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;개념의 세 가지 관점 : 심볼(symbol), 내연(intension), 외연(extension)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;타입은 개념이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;메모리의 세상에는 타입이라는 질서가 존재하지 않는다. …
어떤 메모리 조각에 들어 있는 값의 의미는 그 값을 가져다 자신의 용도에 맞게 사용하는 외부의 해석가에 의해 결정된다.
흔히 우리가 애플리케이션이라고 부르는 프로그램이 바로 그런 해석가의 일종이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;타입 없는 무질서가 초래한 혼돈의 세상에 질려버린 사람들은 급기야 메모리 안의 데이터에 특정한 의미를 부여하기 시작했다.
사람들은 자신이 다뤄야 하는 데이터의 용도와 행동에 따라 그것들을 분류했다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;타입은 데이터가 어떻게 사용되느냐에 관한 것이다. … 
데이터가 어떤 타입에 속하는지를 결정하는 것은 데이터에 적용할 수 있는 작업이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터 타입은 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터다.
데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동이다.
어떤 객체들이 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류될 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체의 내부적인 표현은 외부로부터 철저하게 감춰진다.
객체의 행동을 가장 효과적으로 수행할 수만 있다면 객체 내부의 상태를 어떤 방식으로 표현하더라도 무방하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;행동이 우선이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;다형성이란 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력을 뜻한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체를 결정하는 것은 행동이다. 데이터는 단지 행동을 따를 뿐이다.
이것이 객체를 객체답게 만드는 가장 핵심적인 원칙이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;타입은 시간에 따라 동적으로 변하는 앨리스의 상태를 시간과 무관한 정적인 모습으로 다룰 수 있게 해준다.
결국 타입은 … 앨리스의 상태에 복잡성을 부과하는 시간이라는 요소를 제거함으로써 시간에 독립적인 정적인 모습으로 앨리스를 생각할 수 있게 해준다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;그래서 결국 타입은 추상화다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체지향 애플리케이션을 설계하고 구현하기 위해서는 객체 관점의 동적 모델과 객체를 추상화한 타입 관점의 정적 모델을 적절히 혼용해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;타입은 객체를 분류하기 위해 사용하는 개념이다. 반면 클래스는 단지 타입을 구현할 수 있는 여러 구현 메커니즘 중 하나일 뿐이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-3&quot;&gt;역할, 책임, 협력&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;우리 모두를 합친 것보다 더 현명한 사람은 없다. - 켄 블랜차드 (Ken Blanchard)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;최후통첩 게임은 인간을 바라보는 두 가지 관점의 충돌을 잘 설명해 준다. 인간이 가지고 있는 본연의 특성이라는 관점에서 인간은 이기적이고 합리적인 존재다.
그러나 타인과 관계를 맺는 과정 속에서 인간은 본연의 특성을 배제하고 자신의 이익을 최소화하는 불합리한 선택을 하게 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;결론적으로 인간이 어떤 본질적인 특성을 지니고 있느냐가 아니라 어떤 상황에 처해 있느냐가 인간의 행동을 결정한다.
즉, 각 개인이 처해 있는 정황 또는 문맥(context)이 인간의 행동 방식을 결정한다는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;어떤 협력에 참여하는지가 객체에 필요한 행동을 결정하고, 필요한 행동이 객체의 상태를 결정한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;협력은 한 사람이 다른 사람에게 도움을 요청할 때 시작된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;결국 어떤 등장인물들이 특정한 요청을 받아들일 수 있는 이유는 그 요청에 대해 적절한 방식으로 응답하는 데 필요한 지식과 행동 방식을 가지고 있기 때문이다.
그리고 요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체지향의 세계에서는 어떤 객체가 어떤 요청에 대해 대답해 줄 수 있거나, 적절한 행동을 할 의무가 있는 경우 해당 객체가 책임을 가진다고 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;책임은 객체에 의해 정의되는 응집도 있는 행위의 집합으로, 객체가 알아야 하는 정보와 객체가 수행할 수 있는 행위에 대해 개략적으로 서술한 문장이다.
즉, 객체의 책임은 ‘객체가 무엇을 알고 있는가(knowing)’와 ‘무엇을 할 수 있는가(doing)’로 구성된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체의 책임을 이야기할 때는 일반적으로 외부에서 접근 가능한 공용 서비스의 관점에서 이야기한다. 
즉, 책임은 객체의 외부에 제공해 줄 수 있는 정보(아는 것의 측면)와 외부에 제공해 줄 수 있는 서비스(하는 것의 측면)의 목록이다.
따라서 책임은 객체의 공용 인터페이스(public interface)를 구성한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체가 다른 객체에게 전송된 요청은 그 요청을 수신한 객체의 책임이 수행되게 한다.
이처럼 객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것을 메시지 전송(message-send)이라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;한 가지 주의할 점은 책임과 메시지의 수준이 같지는 않다는 점이다.
책임은 객체가 협력에 참여하기 위해 수행해야 하는 행위를 상위 수준에서 개략적으로 서술한 것이다.
책임을 결정한 후 실제로 협력을 정제하면서 이를 메시지로 변환할 때는 하나의 책임이 여러 메시지로 분할되는 것이 일반적이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체지향 설계는 협력에 참여하기 위해 어떤 객체가 어떤 책임을 수행해야 하고 어떤 객체로부터 메시지를 수신할 것인지를 결정하는 것으로부터 시작된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;결론적으로 어떤 객체가 수행하는 책임의 집합은 객체가 협력 안에서 수행하는 역할을 암시한다.
… 역할이 재사용 가능하고 유연한 객체지향 설계를 낳는 매우 중요한 구성요소이기 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;… 따라서 ‘판사와 ‘증인’이라는 역할(role)을 사용하면 세 가지 협력을 모두 포괄할 수 있는 하나의 협력으로 추상화할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;역할은 협력 내에서 다른 객체로 대체할 수 있음을 나타내는 일종의 표식이다.
협력 안에서 역할은 “이 자리는 해당 역할을 수행할 수 있는 어떤 객체라도 대신할 수 있습니다”라고 말하는 것과 같다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;역할을 대체할 수 있는 객체는 동일한 메시지를 이해할 수 있는 객체로 한정된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;역할의 가장 큰 가치는 하나의 협력 안에 여러 종류의 객체가 참여할 수 있게 함으로써 협력을 추상화할 수 있다는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체가 역할에 주어진 책임 이외에 다른 책임을 수행할 수도 있다는 사실에 주목하라&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;요약하면 역할의 대체 가능성은 행위 호환성을 의미하고, 행위 호환성은 동일한 책임의 수행을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;책임-주도 설계(Responsibility-Driven Design)는 객체의 역할, 책임, 협력을 고안하기 위한 방법과 절차를 제시한다.
반면 디자인 패턴(Design Pattern)은 책임-주도 설계의 결과를 표현한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;만약 특정한 상황에 적용 가능한 디자인 패턴을 잘 알고 있다면 책임-주도 설계의 절차를 순차적으로 따르지 않고도 시스템 안에
구현할 객체들의 역할과 책임, 협력 관계를 빠르고 손쉽게 포착할 수 있을 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;테스트-주도 개발은 테스트를 작성하는 것이 아니라 책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이 메시지를 수신할 때
어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대를 코드의 형태로 작성하는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-4&quot;&gt;책임과 메시지&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;의도는 “메시징”이다. 훌륭하고 성장 가능한 시스템을 만들기 위한 핵심은 모듈 내부의 속성과 행동이 어떤가보다는
모듈이 어떻게 커뮤니케이션하는가에 달려 있다. - 앨런 케이 [Kay 1998]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;요청을 처리하기 위해 객체가 수행하는 행동을 책임이라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;… 여기서 문제는 이 책임들이 모자 장수가 증언하기 위해 선택할 수 있는 자유의 범위를 지나치게 제한한다는 점이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;… 상세한 수준의 책임은 증언이라는 협력의 최종 목표는 만족시킬지 몰라도 모자 장수가 누려야 하는 선택의 자유를 크게 훼손하고 만다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;포괄적이고 추상적인 책임을 선택한다고 해서 무조건 좋은 것은 아니다.
책임이 수행 방법을 제한할 정도로 너무 구체적인 것도 문제지만 협력의 의도를 명확하게 표현하지 못할 정도로 추상적인 것 역시 문제다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;추상적이고 포괄적인 책임은 협력을 좀 더 다양한 환경에서 재사용할 수 있도록 유연성이라는 축복을 내려준다.
그러나 책임은 협력에 참여하는 의도를 명확하게 설명할 수 있는 수준 안에서 추상적이어야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;어떤 책임이 자율적인지를 판단하는 기준은 문맥에 따라 다르다는 사실에 유의하라.
재판이라는 협력 안에서는 ‘증언하라’라는 책임이 모자 장수의 자율권을 보장하는 가장 적절한 수준의 책임이지만 
다른 상황에서는 오히려 ‘설명하라’라는 책임이 자율권을 보장하는 최선의 선택이 될 수 있다.
어떤 책임이 가장 적절한가는 설계 중인 협력이 무엇인가에 따라 달라진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;자율적인 책임의 특징은 객체가 ‘어떻게(how)’ 해야 하는가가 아니라 ‘무엇(what)’을 해야 하는가를 설명한다는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;책임을 자극하는 메시지&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;… 따라서 객체가 자신에게 할당된 책임을 수행하도록 만드는 것은 외부에서 전달되는 요청이다. … 이 요청을 우리는 메시지라 부른다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;메시지 전송이 수신자, 메시지 이름, 인자의 조합으로 구성된다는 것을 기억하는 것이 중요하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;… 따라서 객체가 수신할 수 있는 메시지의 모양이 객체가 수행할 책임의 모양을 결정한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;모자 장수가 메시지를 처리하기 위해 내부적으로 선택하는 방법을 메서드라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;메시지는 ‘어떻게’ 수행될 것인지는 명시하지 않는다. 메시지는 단지 오퍼레이션을 통해 ‘무엇’이 실행되기를 바라는지만 명시하며,
어떤 메서드를 선택할 것인지는 전적으로 수신자의 결정에 좌우된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미한다.
좀 더 구체적으로 말해 서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메서드를 이용해
메시지를 처리할 수 있는 메커니즘을 가리킨다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;… 따라서 다형성을 하나의 메시지와 하나 이상의 메서드 사이의 관계로 볼 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;다형성은 역할, 책임, 협력과 깊은 관련이 있다.
서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;다형성에서 중요한 것은 메시지 송신자의 관점이다.
… 송신자의 관점에서 다형적인 수신자들을 구별할 필요가 없으며 자신의 요청을 수행할 책임을 지닌다는 점에서 모두 동일하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;기본적으로 다형성은 동일한 역할을 수행할 수 있는 객체들 사이의 대체 가능성을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;다형성을 사용하면 송신자가 수신자의 종류를 모르더라도 메시지를 전송할 수 있다.
즉, 다형성은 수신자의 종류를 캡슐화한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체지향 애플리케이션은 클래스를 이용해 만들어지지만 메시지를 통해 정의된다 [Metz 2012].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;클래스는 단지 동적인 객체들의 특성과 행위를 정적인 텍스트로 표현하기 위해 사용할 수 있는 추상화 도구일 뿐이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;메시지가 아니라 데이터를 중심으로 객체를 설계하는 방식은 객체의 내부 구조를 개체 정의의 일부로 만들기 때문에 객체의 자율성을 저해한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터에 대한 결정을 뒤로 미루면서 객체의 행위를 고려하기 위해서는 객체를 독립된 단위가 아니라 협력이라는 문맥 안에서 생각해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;훌륭한 객체지향 설계는 어떤 객체가 어떤 메시지를 전송할 수 있는가와 어떤 객체가 어떤 메시지를 이해할 수 있는가를 중심으로
객체 사이의 협력 관계를 구성하는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;사실 협력이라는 문맥에서 벗어나 독립적인 객체에 관해 고민하는 것은 클래스에 초점을 맞추는 것과 별다른 차이가 없다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;책임-주도 설계의 핵심은 어떤 행위가 필요한지를 먼저 결정한 후에 이 행위를 수행할 객체를 결정하는 것이다.
이 과정을 흔히 What/Who 사이클 [Budd 2001]이라고 한다.
What/Who 사이클이라는 용어가 의미하는 것은 객체 사이의 협력 관계를 설계하기 위해서는 먼저 ‘어떤 행위(what)’를 수행할 것인지를 결정한 후에
‘누가(who)’ 그 행위를 수행할 것인지를 결정해야 한다는 것이다. 여기서 ‘어떤 행위’가 바로 메시지다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;협력이라는 문맥 안에서 객체의 책임을 결정하는 것은 메시지다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;묻지 말고 시켜라 (Tell, Don’t Ask)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;What/Who 사이클은 어떤 객체가 필요한지를 생각하지 말고 어떤 메시지가 필요한지를 먼저 고민하라고 조언한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체지향의 세계에서 내부 구조와 작동 방식을 가리키는 고유의 용어는 구현(implementation)이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;과거의 전통적인 개발 방법은 데이터와 프로세스를 엄격하게 구분하지만 객체지향에서는 데이터와 프로세스를 객체라는 하나의 틀 안으로
묶어 놓음으로써 객체의 자율성을 보장한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체를 자율적인 존재로 바라보는 것은 결국 객체의 내부와 외부를 엄격하게 분리한다는 것을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;… 그것은 어떤 협력이 다른 협력보다 이해하기 쉽고 변경에 유연하기 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;… 결과적으로 책임이 얼마나 자율적인지가 전체적인 협력의 설계 품질을 결정하게 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;… 변경의 파급효과가 객체 내부로 캡슐화되기 때문에 두 객체 간의 결합도가 낮아진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;… 책임이 자율적일수록 객체의 응집도를 높은 상태로 유지하기가 쉬워진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-5&quot;&gt;객체지도&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;유일하게 변하지 않는 것은 모든 것이 변한다는 사실뿐이다. - 헤라클레이토스 (Heraclitus of Ephesus)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;지도 은유의 핵심은 기능이 아니라 구조를 기반으로 모델을 구축하는 편이 좀 더 범용적이고 이해하기 쉬우며 변경에 안정적이라는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;자주 변경되는 “기능”이 아니라 안정적인 “구조”를 따라 역할, 책임, 협력을 구성하라&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;안타깝게도 미래의 변경에 대비할 수는 있지만 미래의 변경을 예측할 수는 없다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;미래에 대비하는 가장 좋은 방법은 변경을 예측하는 것이 아니라 변경을 수용할 수 있는 선택의 여지를 설계에 마련해 놓는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;좋은 설계는 나중에라도 변경할 수 있는 여지를 남겨 놓는 설계다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;설계를 하는 목적은 나중에 설계하는 것을 허용하는 것이며, 설계의 일차적인 목표는 변경에 소요되는 비용을 낮추는 것이다 [Metz 2012].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;일반적으로 기능을 수집하고 표현하기 위한 기법을 유스케이스 모델링이라고 하고 구조를 수입하고 표현하기 위한 기법을 도메인 모델링이라고 한다.
쉽게 예상할 수 있는 것처럼 두 가지 모델링 활동의 결과물을 각각 유스케이스와 도메인 모델이라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;… 사용자가 프로그램을 사용하는 대상 분야를 도메인이라고 한다 [Evans 2003].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;모델은 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다 [Evans 2003].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;도메인 모델이란 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;… 결과적으로 객체지향을 이용하면 도메인에 대한 사용자 모델, 디자인 모델, 시스템 이미지 모두가 유사한 모습을 유지하도록 만드는 것이 가능하다.
객체지향의 이러한 특징을 연결완전성 [Walden 1995], 또는 표현적 차이 [Larman 2001]라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;… 이처럼 소프트웨어 객체와 현실 객체 사이의 의미적 거리를 가리켜 표현적 차이 또는 의미적 차이라고 한다 [Larman 2001].
핵심은 은유를 통해 현실 객체와 소프트웨어 객체 사이의 차이를 최대한 줄이는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;가상의 세계를 창조하는 작업에서 현실 객체를 은유하라는 목소리는 공허한 메아리일 수 밖에 없다.
그렇다면 우리가 은유를 통해 투영해야 하는 대상은 무엇인가? 그것은 바로 사용자가 도메인에 대해 생각하는 개념들이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;불안정한 기능을 담는 안정적인 도메인 모델&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;불안정한 재료: 기능&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;… 사용자의 목표를 달성하기 위해 사용자와 시스템 간에 이뤄지는 상호작용의 흐름을 텍스트로 정리한 것을 유스케이스라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;유스케이스의 가치는 사용자들의 목표를 중심으로 시스템의 기능적인 요구사항들을 이야기 형식으로 묶을 수 있다는 점이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;… 그러나 유스케이스 안에 도메인 모델을 구축할 수 있는 모든 정보가 포함돼 있다는 착각에 빠지지 말기 바란다.
유스케이스 안에는 영감을 불러일으킬 수 있는 약간의 힌트만이 들어 있을 뿐이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;… 사실 협력의 출발을 장식하는 첫 번째 메시지는 시스템의 기능을 시스템의 책임으로 바꾼 후 얻어진 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;스몰토크의 설계 - 그리고 실제 모습 - 는 우리가 설명할 수 있는 모든 것이 상태와 처리 과정을 내부로 은닉하는 행위적인 빌딩블록의
재귀적인 합성(recursive composition)으로 표현할 수 있으며, 메시지의 교환을 통해서만 이 빌딩블록들을 처리할 수 있다는 통찰에서 기인한다.
… 처음에 나는 전체(whole)를 완전한 하나의 컴퓨터로 간주했고, 사람들이 왜 컴퓨터를 자료 구조와 프로시저라는 더 약한 개념으로
분할하려고 하는지 그 이유가 궁금했다. 시분할(time sharing)이 시작한 것처럼 왜 컴퓨터를 더 작은 컴퓨터로 나누지 않는가 [Kay 1993]?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-6&quot;&gt;함께 모으기&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;코드와 모델을 밀접하게 연관시키는 것은 코드에 의미를 부여하고 모델을 적절하게 한다. - 에릭 에반스 (Eric Evans)[Evans 2003]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체지향 설계의 첫 번째 목표는 훌륭한 객체를 설계하는 것이 아니라 훌륭한 협력을 설계하는 것이라는 점을 잊지 말자.
훌륭한 객체는 훌륭한 협력을 설계할 때만 얻을 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;협력을 설계할 때는 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 한다.
이 말은 메시지를 먼저 선택하고 그 후에 메시지를 수신하기에 적절한 객체를 선택해야 한다는 것을 의미한다. (215p)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;인터페이스는 객체가 다른 객체와 직접적으로 상호작용하는 통로다.
인터페이스를 통해 실제로 상호작용을 해보지 않은 채 인터페이스의 모습을 정확하게 예측하는 것은 불가능에 가깝다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;설계를 간단히 끝내고 최대한 빨리 구현에 돌입하라.
머릿속에 객체의 협력 구조가 번뜩인다면 그대로 코드를 구현하기 시작하라.
설계가 제대로 그려지지 않는다면 고민하지 말고 실제로 코드를 작성해가면서 협력의 전체적인 밑그림을 그려보라.
테스트-주도 설계로 코드를 구현하는 사람들이 하는 작업이 바로 이것이다. 그들은 테스트 코드를 작성해 가면서 협력을 설계한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;코드는 세 가지 관점(개념 관점, 명세 관점, 구현 관점)을 모두 제공해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;최대한 변화에 안정적인 인터페이스를 만들기 위해서는 인터페이스를 통해 구현과 관련된 세부 사항이 드러나지 않게 해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;인터페이스와 구현을 분리하라. 명세 관점과 구현 관점이 뒤섞여 여러분의 머릿속을 함부로 어지럽히지 못하게 하라.
명세 관점은 클래스의 안정적인 측면을 드러내야 한다. 구현 관점은 클래스의 불안정한 측면을 드러내야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;a&quot;&gt;부록 A&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;세상에 존재하는 객체에 개념을 적용하는 과정을 분류라고 한다 [Martin 1998].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;사람들은 분류를 통해 개별 현상을 하나의 개념으로 다룬다. 이때 ‘수많은 개별적인 현상들’을 객체라고 하고, ‘하나의 개념’을 타입이라고 한다.
다시 말해 분류는 객체를 타입과 연관시키는 것이다. 분류의 역은 타입에 해당하는 객체를 생성하는 과정으로 인스턴스화 또는 예시라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체지향의 세계에서 개념을 가리키는 표준 용어는 타입이다 [Martin 1998].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;대부분의 객체지향 프로그래밍 언어들은 단일 분류만을 지원한다.
대부분의 언어에서 한 객체는 오직 한 클래스의 인스턴스여야만 하며 동시에 두 개의 클래스의 인스턴스일 수는 없다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;다중 분류를 다중 상속과 혼동해서는 안 된다 [Fowler 2003].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;다중 상속은 하나의 타입이 다수의 슈퍼타입을 가질 수 있도록 허용하지만 타입 정의를 생략할 수는 없다.
반면 다중 분류는 특정한 타입을 정의하지 않고도 하나의 객체가 서로 다른 타입의 인스턴스가 되도록 허용한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우 이를 동적 분류(dynamic classification)라고 한다.
객체가 자신의 타입을 변경할 수 없는 경우 이를 정적 분류(static classification)라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;is-a 관계의 본질은 서브타입이 슈퍼타입의 부분집합이라는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;상속은 서브타이핑(subtyping)과 서브클래싱(subclassing)의 두 가지 용도로 사용될 수 있다.
서브클래스가 슈퍼클래스를 대체할 수 있는 경우 이를 서브타이핑이라고 한다.
서브클래스가 슈퍼클래스를 대체할 수 없는 경우에는 서브클래싱이라고 한다.
서브타이핑은 설계의 유연성이 목표인 반면 서브클래싱은 코드의 중복 제거와 재사용이 목적이다.
흔히 서브타이핑을 인터페이스 상속(interface inheritance)이라고 하고, 서브클래싱을 구현 상속(implementation inheritance)이라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;여러 클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법은 클래스 간의 위임(delegation)을 사용하는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;복잡성은 ‘계층’의 형태를 띤다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;단순한 형태로부터 복잡한 형태로 진화하는 데 걸리는 시간은 그 사이에 존재하는 ‘안정적인 형태’의 수와 분포에 의존한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;안정적인 형태의 부분으로부터 전체를 구축하는 행위를 집합이라고 하고 집합과 반대로 전체를 부분으로 분할하는 행위를 분해라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;전체와 부분 간의 일관된 계층 구조는 재귀적인 설계를 가능하게 한다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 26 Sep 2016 05:31:00 +0000</pubDate>
        <link>https://taehwanno.github.io/post/oop/2016/09/객체지향의-사실과-오해</link>
        <guid isPermaLink="true">https://taehwanno.github.io/post/oop/2016/09/객체지향의-사실과-오해</guid>
        
        
        <category>OOP</category>
        
      </item>
    
      <item>
        <title>JSCONF:16 URBAN JAVASCRIPT 후기</title>
        <description>&lt;p&gt;&lt;img src=&quot;/assets/16-09/jsconf.jpeg&quot; alt=&quot;자바스크립트 컨퍼런스 사진&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;개인적인 욕구로 인해&lt;/h2&gt;
&lt;p&gt;부산에서 개발을 하다 보니 자바스크립트에 대해 대화를 할 기회는 사실상 적다. 물론 팀원들과 대화를 할 수 있지만 
팀원이 아닌 타인들과 대화를 하고 싶다는 욕구는 항상 존재해왔다. 마침 &lt;a href=&quot;http://www.jscon.io/&quot;&gt;JSCONF:16&lt;/a&gt;가
열린다는 것을 이상한 모임 슬랙을 통해 접하게 되었고 회사의 지원으로 신청하게 되었다. 회사에 들어오고 나서 
처음으로 자발적으로 요구한 컨퍼런스이며 회사 내에서 혼자 가게 되어 설렘 반 걱정 반은 무슨 설렘 백으로 행사 
전날에 올라와 컨퍼런스 장소 주변에서 하룻밤을 잤다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;세션에 대해 내 생각은&lt;/h2&gt;
&lt;p&gt;개인적으로 제삼자에게 얻게 되는 개발과 관련된 정보는 비판적인 자세로 보게 되며 직접 경험해보지도 못했거나 
개발해보지 못한 사람이 전달해주는 정보는 잘못된 관점을 가질 수 있어서 너무 위험하고 시간은 더 들지만 당연하게 
표준 스펙은 기본이며 github을 issue, pull request를 참고 또는 활용하는 게 더 나은 방법이라고 생각해왔다. 
이번 JSCONF:16 컨퍼런스 세션 타임 테이블을 봤을 때 처음 든 생각은 하나하나 버릴 것 없이 자신의 경험을 기반으로
실제 현업의 개발자분들이 발표를 진행하기에 더 좋았고 특히 아래 2가지 세션을 가장 기대했다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Reactive, Component 그리고 AngularJS 2.0&lt;/li&gt;
  &lt;li&gt;ECMAScript Inside&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그 이유로는 angular.js 1.XX를 회사 서비스 프론트엔드 프레임워크로 사용하고 있었고 서비스의 복잡도가 높아지고 
있는 상황에서 힘겨워하는 모습을 보며 &lt;strong&gt;“내가 잘못 이해하고 사용하는 부분이 있나?”&lt;/strong&gt;라는 생각이 들었고 모바일을 
지원해야 하는 상황과 HTML 웹 컴포넌트 표준 그리고 angular.js 2와 react.js에서 지향하고 있는 컴포넌트 기반 
아키텍쳐를 보면서 &lt;strong&gt;지금 짜는 코드가 마지못해 짜는 건가? 답이 아닌 걸 답이라 주문을 외우고 있나?&lt;/strong&gt; 라는 생각이 
조금씩 들었다. 그리고 순수하게 프로그래밍 언어 자체에 대한 이해도를 높이고 싶은 욕심도 존재했기 때문이다.&lt;/p&gt;

&lt;h3 id=&quot;reactive-component--angularjs-20&quot;&gt;Reactive, Component 그리고 Angular.js 2.0&lt;/h3&gt;
&lt;p&gt;angular.js 1에 가지고 있던 문제점들이 화면에 나올 때 하나같이 피부로 느끼고 있었기에 엄청난 공감을 했다. 
&lt;code class=&quot;highlighter-rouge&quot;&gt;$scope&lt;/code&gt; 그리고 지옥의 디렉티브를 이해하려고 머리를 싸맸던 시간이 생각났다. 
(&lt;del&gt;디렉티브를 처음 공부할 때는 정말 얼마나 지옥 같은 하루였는지.. 근데 아직도 디렉티브는 어려운 게 함정&lt;/del&gt;)&lt;/p&gt;

&lt;p&gt;RC6 버젼이기에 곧 정식버젼 릴리즈가 임박한 것 같으며 &lt;a href=&quot;https://github.com/angular/angular-cli&quot;&gt;CLI&lt;/a&gt;는 
편해 보이지만 beta 버젼이라서 편하려고 사용하는 도구가 오히려 불편하게 만들어주는 아이러니한 상황이 나타날 
가능성이 높아 보이고 발표자분도 만약 실제 제품에 도입하려고 할 때 지금 상황으로는 너무 고생하면서 사용할 것까지는
없으며 사용 여부를 검토해보고 선택적인 활용이 권장된다고 한다. 스캐폴딩, 빌드, 번들링 등 알아서 해주는 작업이 
많지만, 발표 데모 진행 시 타입스크립트 버젼 때문에 터지는 것을 보고 아주 무서운 도구라 생각됐다.&lt;/p&gt;

&lt;p&gt;발표가 끝나고 머릿속을 맴돌았던 사실은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;직접 DOM을 조작했던 방식의 변화&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/angular/universal&quot;&gt;Universal&lt;/a&gt;을 통한 서버 사이드 렌더링 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DOM에 대한 악명은 높은데 (&lt;del&gt;생각해보니 너무 안 좋다는 소리를 많이 들어서 DOM에 대한 비판적인 관점을 가지는 
것은 당연하다고 생각해서 찾아볼 생각도 안했는 데 관점 없는 관점을 가지고 있는 것을 깨달았다. 왜 악명이 높은지 
조사해봐야겠다.&lt;/del&gt;) 이 녀석을 angular.js 1은 직접 건드리다보니 성능 저하의 원인이 되는데 react.js가 접근했던
방법과 비슷하게 메모리상에 AST를 만들어 처리하며 Universal을 활용하면 서버사이드 isomorphic 렌더링도 
가능하다. 즉, 런타임이든 컴파일 타임이든 렌더링에 대한 선택이 가능하다. react.js에 대한 스펙을 대충 훑고 
튜토리얼을 손수 다 해본 리액트 개발 경험이 없는 초보자인 내가 느끼기에는 뭔가 리액트스럽게 변화한다는 느낌적인 
느낌을 지울 수가 없다. &lt;code class=&quot;highlighter-rouge&quot;&gt;angular-eact.js&lt;/code&gt; (?)&lt;/p&gt;

&lt;p&gt;마지막 파트로 Reactive Programming에 대해 발표를 했었는데 앞부분 파트 발표 데모 때문에 시간상 급하게 설명해
주셨는 데 정말 정말 굉장히 아쉬웠다. &lt;a href=&quot;http://reactivex.io/&quot;&gt;ReactiveX&lt;/a&gt;가 소개됐고 프로그래밍 패러다임의 
하나이며 &lt;code class=&quot;highlighter-rouge&quot;&gt;Observables&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;를 비교하면서 multiple, single에 대한 언급을 했고 연속적인 stream 
데이터를 비동기적으로 처리가 가능하다는 나의 에버노트에 적힌 노트가 내 이해도의 한계였다. 
차후에 따로 공부해봐야겠다.
(&lt;a href=&quot;http://www.slideshare.net/haibane84/reactive-component-angular2&quot;&gt;발표 자료&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id=&quot;webpack---&quot;&gt;Webpack 실무 적용 전략&lt;/h3&gt;

&lt;p&gt;grunt에서 점차 webpack으로 넘어갈 때 경험했던 것들을 발표해주셨다. 간단히 정리해본다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;*.js&lt;/code&gt;만이 아닌 다른 
assets까지 번들링 가능하며 grunt, gulp를 사용하지 않고 webpack과 npm script로 기존의 테스크 자동화가 
가능하며 캐싱을 통해 빠른 번들링이 가능하지만, 러닝 커브가 크며 웹팩 내부적으로 진행하는 최적화 때문에 골치 
아파질 가능성이 존재한다. config 설정을 통해 다양한 상황에 맞춰 번들링을 진행할 수 있으며 의존성에 대한 
시각화, 최적화가 가능하다. 웹팩에 활용할 수 있는 모듈이 많이 존재한다.&lt;/p&gt;

&lt;p&gt;현재 grunt를 사용하고 있는데 웹팩으로의 마이그레이션을 고려해봐야겠다. (&lt;del&gt;먼산…&lt;/del&gt;) 발표 이 후 사운드
플레이로 들었던 피드백은 “활용할 수 있는 모듈이 저렇게 다양한 줄 몰랐다.”가 다수였으므로 webpack 도입 시기에
초기 러닝 커브를 극복하고! 스태미너를 불태워 활용할 수 있는 바퀴에 대해 조사가 필요하다고 생각된다.&lt;/p&gt;

&lt;p&gt;그리고 발표 도중 문득 든 생각은 package management 도구 중 bower에 대해 몇몇 문제점이 제기되다 보니 
npm으로 프론트엔드 의존성까지 모두 관리하는 추세인 것은 알고 있었는데 무슨 문제가 있는 건지, bower와 npm의 
차이는 무엇인지를 조사해서 한번 정리해봐야겠다. 바퀴를 관리하는 방법에 무지했다니 반성해야겠다. 느낌상 
recursive dependency에 대한 내용과 관련 있을 거 같은데 앞의 질문들을 이해하고 나서 프론트엔드는 bower 
백엔드는 npm으로 의존성을 관리하는 현재 서비스에서 프로덕션 과정을 거쳐 유저에게 딜리버리되는 script의 용량을 
비교, 분석해봐야겠다. (발표자분의 webpack sample github 저장소는 
&lt;a href=&quot;https://github.com/odyss009/webpack-sample&quot;&gt;여기에&lt;/a&gt;, 
&lt;a href=&quot;http://slides.com/odyss/webpack#/&quot;&gt;발표자료&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id=&quot;ecmascript-2015-inside&quot;&gt;ECMAScript 2015 Inside&lt;/h3&gt;

&lt;p&gt;사실 프로그래밍 언어 자체에 대한 관심이 많아 표준 명세, 컴파일러의 구조 및 처리 과정 등을 틈틈이 공부하고 있는데
해당 세션도 기대가 되었다.&lt;/p&gt;

&lt;p&gt;간단히 정리해보면 ECMAScript 6가 아닌 ECMAScript 2015로 정식 명칭으로 수정되었으며 ES5의 상위 집합으로
점진적인 적용이 가능하지만, 하위 호환성으로 인해 예전 버젼의 단점을 그대로 가진다. 비동기 제어와 관련하여
&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Generator&lt;/code&gt;를 설명했고 최종적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Generator + Promise&lt;/code&gt;를 설명했다. 
&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;는 “약속”이며 한 문장으로 요약하면 &lt;strong&gt;“내가 값이 생기면 넘겨 줄게. 그러면 실행해줘”&lt;/strong&gt;로 
표현할 수 있으며 ES2015에 추가된 &lt;code class=&quot;highlighter-rouge&quot;&gt;Job Queue&lt;/code&gt;를 알아야 제대로 활용할 수 있으며 예외 처리, 단일 귀결, 
취소 불가에 대한 문제점이 존재한다. 또한 &lt;code class=&quot;highlighter-rouge&quot;&gt;Generator&lt;/code&gt;는 &lt;strong&gt;“호출하면 이터레이터를 반환한다.
“&lt;/strong&gt;로 표현할 수 있으며 새롭게 추가된 &lt;code class=&quot;highlighter-rouge&quot;&gt;Symbol.iterator&lt;/code&gt; 프로퍼티, Function 이름 앞의 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;, 제어권을 
넘기는 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt; 예약어가 활용된다. 예외처리가 강력한 기능 중 하나다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Generator + Promise&lt;/code&gt;를 통해 비동기 
제어시 콜백이 아닌 &lt;code class=&quot;highlighter-rouge&quot;&gt;try ~ catch&lt;/code&gt;를 통해 예외 처리를 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;는 대체로 다 알던 내용이었는 데 &lt;code class=&quot;highlighter-rouge&quot;&gt;Generator&lt;/code&gt;는 추가되었다는 사실만 알았지 정확히 어떤 기능인지
전혀 파악하지 못했었는데 처음으로 자바스크립트에서 쓰레드가 존재한다는 느낌을 받았다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;idMaker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;gen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;idMaker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;Generator { }&quot;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 0&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Generator#예시&quot;&gt;출처 - Mozilla Developer Network: Generators&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt; 예약어가 나오기 전까지 로직이 실행되며 만날 경우 컨텍스트는 유지된 채로 제어권이 넘어가고 
(컨텍스트 스위칭) &lt;code class=&quot;highlighter-rouge&quot;&gt;Generator&lt;/code&gt; 인터페이스에 의해 로직이 미세하게 제어된다. (쓰레드 스케줄링) 
지금 다시 보니 뭔가 끼워 맞춘 듯한 느낌이 드는데 발표를 들을 때는 정말 그랬다. 
&lt;code class=&quot;highlighter-rouge&quot;&gt;Generator + Promise&lt;/code&gt; 발표의 경우 제대로 이해하지 못했는데 &lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;의 약점을 &lt;code class=&quot;highlighter-rouge&quot;&gt;Generator&lt;/code&gt;가 
채워줄 수 있을 것 같다는 느낌이 든다. 차후 다시 공부를 해봐야겠다.&lt;br /&gt;
(발표자분의 비동기 제어에 대한 저장소는 &lt;a href=&quot;https://github.com/shallaa/async&quot;&gt;여기에&lt;/a&gt;, 
&lt;a href=&quot;http://www.slideshare.net/shallaa/ecma2015-inside-65652426&quot;&gt;발표자료&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id=&quot;lets-with-lunch&quot;&gt;Lets with Lunch&lt;/h3&gt;

&lt;p&gt;혼자 가는 컨퍼런스였고 90분이라는 긴 점심시간 동안 뭐 하고 놀지 고민하던 찰나에 주최 측으로부터 동일한 주제를 
선택한 사람끼리 이야기를 할 수 있도록 기회를 제공해주길래 자바스크립트의 미래에 바로 신청을 했었다. 놀라운 사실은 
그냥 이야기하고 밥을 먹겠다고 선택한 사람들이 너무 압도적으로 많았다는 사실. 이렇게 적은 인원이 신청했을 
것이라고는 예상하지 못해 당황스러웠지만, 초면인 사람들과 특정 주제에 관해 이야기를 나누기 위해서는 7~8명의 소수도 
괜찮다고 생각됐다. angular.js 1.XX와 react.js를 실제 사용해본 개발자분의 경험담, 조언 그리고 타입스크립트에 
대한 생각, 이미지 프로세싱에 대한 패턴, 각자 회사의 이야기까지 내년에 열리게 될 JS:CONF에도 Lets를 신청할 
가치가 있어 보인다.&lt;/p&gt;

&lt;h3 id=&quot;reactjs--&quot;&gt;React.js 실서비스 적용하기&lt;/h3&gt;

&lt;p&gt;동일하게 정리해본다면 angular.js 1과 비교했을 때 react.js는 그 자체만으로 사용할 수 없으며 babel과 같은
도구들이 필요하다. CDN으로 외부 의존성 라이브러리를 처리하여 필요한 코드만을 번들링했으며 react.js에 대한 
Dev tools가 있어 손쉬운 디버깅이 가능하다. 컴포넌트별 재사용성을 높였으며 트리 형태로 컴포넌트를 구성하니 
어디서 코드를 고쳐야 할 지가 명확해졌다.&lt;/p&gt;

&lt;p&gt;angular.js 1.5.X, 2버젼에서 컴포넌트 아키텍쳐를 지원, 채택한 상황에서 MVW와 비교했을 때 어떤 장점 때문에
결정을 하게 되었을 지 감이 잡히질 않았다. 하지만 발표를 보고 난 후에는 어떤 컴포넌트를 수정해야 할 지 명확해서 
어떤 코드를 수정해야 할 지도 명확해졌다는 점이 좋았다. 그리고 컴포넌트별로 정리된 사내 문서를 보고 문서화에 대해 
깊은 고민을 해볼 필요가 있다고 생각했다. 
(&lt;a href=&quot;http://slides.com/roto/react-js-live-service#/&quot;&gt;발표자료&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id=&quot;react-native-in-production&quot;&gt;React Native in Production&lt;/h3&gt;

&lt;p&gt;2명의 개발자가 주어진 기간 3주 안에 안드로이드, iOS 앱을 개발해야 하는 상황에서 시작해서 지금까지 
React Native를 통해 개발하면서 겪고 느꼈던 부분들에 대해 발표를 해주셨다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cordova + React.js&lt;/li&gt;
  &lt;li&gt;NativeScript&lt;/li&gt;
  &lt;li&gt;React Native&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 3개의 선택지가 있었으며 Cordova는 느렸고 NativeScript는 공룡이 아니라 믿음직스럽지 못했고 react.js 
경험이 있는 개발자라 React Native를 선택했다고 한다. 하지만 아직 0.XX 버젼이라 각 버젼별로 바뀌는 부분이 
많고 그냥 다 breaking changes라고 말씀하시는 모습이 얼마나 고생을 했을까 하는 측은한 마음이 생겼다.
(&lt;a href=&quot;http://www.slideshare.net/analogstyle/react-native-in-production-65682613&quot;&gt;발표자료&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id=&quot;spring-nodejs--2&quot;&gt;spring과 node.js의 공존 &lt;시즌2&gt;&lt;/시즌2&gt;&lt;/h3&gt;

&lt;p&gt;세션 중 백엔드와 관련된 유일한 세션이었는 데 
&lt;strong&gt;“서버사이드에서 주류가 되기 힘든 상황에서 자바에 빌붙혀 살아보자”&lt;/strong&gt;가 컨셉이었다. J2V8을 사용해서 Java에서 
V8을 바인딩시켜 사용할 수 있으며 Java 8에 기본적으로 자바스크립트를 돌릴 수 있는 모듈이 존재한다. J2V8을 
사용함으로써 얻는 효과는 npm에 존재하는 수많은 모듈을 &lt;code class=&quot;highlighter-rouge&quot;&gt;require&lt;/code&gt;를 통해 그대로 사용할 수 있다는 점이다.&lt;/p&gt;

&lt;p&gt;백엔드에 대한 지식이 부족하다 보니 “아 저렇게 생각할 수도 있겠다.”라며 구경하듯이 봤다.
(&lt;a href=&quot;http://www.slideshare.net/iolo/javaspring-nodejs-2?from_m_app=ios&quot;&gt;발표자료&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;끝으로&lt;/h2&gt;
&lt;p&gt;angular.js 1.XX과 grunt를 통해 개발해본 경험이 존재하고 react.js 및 백엔드에 대한 개발 경험이 부족하다 
보니 오전, 오후 세션에 대한 후기가 나뉘는 것 같다. 피로도 누적과 오전 세션까지는 발표 자료 공유에 대한 불확실함 
때문에 에버노트에 정리했지만 공유를 해준다는 소식을 듣고 개인적인 감상만을 적었다고 핑계를 대본다.&lt;/p&gt;

&lt;p&gt;사람을 만나면서 서로를 소개하고 명함을 주고받고 알아가는 것들이 익숙하지 않다 보니 많은 사람을 만나보지는 못했지만
새로운 지식, 관점을 얻을 수 있고 현재 개발에 대해 반성을 할 수 있다는 것에 만족할 수 있었다. 발표 자료가 
공유되는 대로 해당 후기를 조금씩 업데이트해봐야겠다.&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Sep 2016 10:58:00 +0000</pubDate>
        <link>https://taehwanno.github.io/post/javascript/2016/09/jsconf-16</link>
        <guid isPermaLink="true">https://taehwanno.github.io/post/javascript/2016/09/jsconf-16</guid>
        
        
        <category>javascript</category>
        
      </item>
    
  </channel>
</rss>
