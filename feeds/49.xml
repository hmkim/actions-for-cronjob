<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>덕's IT Story</title>
<link>https://itstory.tk/</link>
<description>되돌아보면 웃을수 있는 즐거운 인생살기!!</description>
<language>ko</language>
<pubDate>Sun, 12 May 2019 14:50:03 +0900</pubDate>
<generator>TISTORY</generator>
<managingEditor>kkd927</managingEditor>
<image>
<title>덕's IT Story</title>
<url>http://cfile6.uf.tistory.com/image/266E5C3E58FB5E2A11BDF8</url>
<link>https://itstory.tk</link>
<description>되돌아보면 웃을수 있는 즐거운 인생살기!!</description>
</image>
<item>
<title>Spring Webflux + JDBC(혹은 blocking call) 핸들링 방법</title>
<link>https://itstory.tk/entry/Spring-Webflux-JDBC%ED%98%B9%EC%9D%80-blocking-call-%ED%95%B8%EB%93%A4%EB%A7%81-%EB%B0%A9%EB%B2%95</link>
<description>&lt;p&gt;스프링 5부터 Spring Webflux를 통해 reactive 개발이 가능하게 됐습니다. 요청당 스레드가 하나씩 차지했던 기존의 패러다임과 달리 Webflux는 non-blocking 시스템이 가능하게 해줍니다.&lt;/p&gt;

&lt;p&gt;하지만 non-blocking을 지원하지 않는 blocking persistence API (ex. jdbc)를 쓰는 경우에는 어떻게 해야할까요? non-blocking을 지원하는 nosql 데이터베이스를 사용하거나 &lt;a href=&quot;https://github.com/r2dbc&quot;&gt;r2dbc&lt;/a&gt;를 사용하는 것이 방법이 될 수 있겠으나 아직까진 mysql 등의 rdbms는 지원되지 않습니다. 이번 글에서는 Spring Webflux + JDBC 환경에서 어떤식으로 개발을 해야되는지에 대해 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;일반적인 웹 구조인 controller -&amp;gt; service -&amp;gt; repository 형태로 예를 들어보겠습니다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;@Slf4j
@RestController
public class MemoController {
    private final MemoService memoService;

    public MemoController(MemoService memoService) {
        this.memoService = memoService;
    }

    @PostMapping(&quot;/memos&quot;)
    public Mono&amp;lt;MemoResponseDTO&amp;gt; save(@Valid @RequestBody MemoRequestDTO memoRequestDTO) {
        log.info(&quot;===== MemoController 시작 =====&quot;);

        return memoService.save(memoRequestDTO)
            .map(MemoResponseDTO::of)
            .log();
    }
}&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;@Slf4j
@Service
public class MemoService {
    private final MemoRepository memoRepository;

    public MemoService(MemoRepository memoRepository) {
        this.memoRepository = memoRepository;
    }

    public Mono&amp;lt;Memo&amp;gt; save(MemoRequestDTO memoRequestDTO) {
        log.info(&quot;===== MemoService 시작 =====&quot;);

        return Mono.just(memoRepository.save(Memo.of(memoRequestDTO)))
            .log();
    }
}&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;@Slf4j
@Repository
public class MemoRepository {
    public Memo save(Memo memo) {
        log.info(&quot;===== MemoRepository 시작 =====&quot;);
        // ...blocking persistence APIs (JPA, JDBC) or networking APIs to use
        return memo;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 예에서 &lt;code&gt;MemoRepository&lt;/code&gt;는 단순히 Memo 객체를 반환하지만 blocking persistence API를 이용하는 레이어라고 생각하시면 됩니다. JPA 환경이라면 &lt;code&gt;MemoRepository extends JpaRepository&amp;lt;Memo, ID&amp;gt;&lt;/code&gt; 이런 식이 되겠지요.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MemoService&lt;/code&gt;는 blocking I/O인 &lt;code&gt;MemoRepository&lt;/code&gt;의 결과를 단순히 &lt;code&gt;Mono.just&lt;/code&gt;로 감싸서 결과를 반환하도록 구현하였습니다. 이제 실행결과를 한번 살펴볼까요?&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;2018-12-21 14:09:20.705  INFO 67826 --- [ctor-http-nio-2] c.e.demo.interfaces.MemoController       : ===== MemoController 시작 =====
2018-12-21 14:09:20.706  INFO 67826 --- [ctor-http-nio-2] c.e.demo.domain.service.MemoService      : ===== MemoService 시작 =====
2018-12-21 14:09:20.711  INFO 67826 --- [ctor-http-nio-2] c.e.d.domain.repository.MemoRepository   : ===== MemoRepository 시작 =====
2018-12-21 14:09:20.728  INFO 67826 --- [ctor-http-nio-2] reactor.Mono.CallableOnAssembly.1        : onSubscribe([Fuseable] FluxOnAssembly.OnAssemblySubscriber)
2018-12-21 14:09:20.729  INFO 67826 --- [ctor-http-nio-2] reactor.Mono.OnAssembly.2                : | onSubscribe([Fuseable] FluxOnAssembly.OnAssemblySubscriber)
2018-12-21 14:09:20.729  INFO 67826 --- [ctor-http-nio-2] reactor.Mono.OnAssembly.2                : | request(unbounded)
2018-12-21 14:09:20.729  INFO 67826 --- [ctor-http-nio-2] reactor.Mono.CallableOnAssembly.1        : request(unbounded)
2018-12-21 14:09:20.730  INFO 67826 --- [ctor-http-nio-2] reactor.Mono.CallableOnAssembly.1        : onNext(com.example.demo.domain.model.Memo@3b09310d)
2018-12-21 14:09:20.730  INFO 67826 --- [ctor-http-nio-2] reactor.Mono.OnAssembly.2                : | onNext(com.example.demo.domain.dto.MemoResponseDTO@67c2f017)
2018-12-21 14:09:20.751  INFO 67826 --- [ctor-http-nio-2] reactor.Mono.CallableOnAssembly.1        : onComplete()
2018-12-21 14:09:20.752  INFO 67826 --- [ctor-http-nio-2] reactor.Mono.OnAssembly.2                : | onComplete()&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결과를 보면 하나의 쓰레드(ctor-http-nio-2) 위에서 생산과 소비가 이루어졌습니다. 기존의 blocking 코드들과 크게 다를 바가 없어보입니다. synchronous, blocking call이 도중에 포함이 된다면 단순히 Mono, Flux를 이용하여 개발을 했다고 non-blocking이 되진 않습니다.&lt;/p&gt;

&lt;p&gt;그럼 jdbc와 같이 blocking I/O가 있는 경우에는 어떻게 처리를 해야할까요? Spring 공식 문서를 살펴보면 다음과 같이 적혀져있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A simple way to evaluate an application is to check its dependencies. If you have blocking persistence APIs (JPA, JDBC) or networking APIs to use, Spring MVC is the best choice for common architectures at least. It is technically feasible with both Reactor and RxJava to perform blocking calls on a separate thread but you would not be making the most of a non-blocking web stack.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;요약하자면, blocking call 부분을 별도의 쓰레드에서 background로 돌려라고 적혀져있습니다. 그럼 구체적으로 어떻게 쓰면 될까요? Reactor 공식 문서를 살펴보면 &lt;a href=&quot;https://projectreactor.io/docs/core/release/reference/#faq.wrap-blocking&quot;&gt;How do I wrap a synchronous, blocking call?&lt;/a&gt;라는 주제로 자세히 잘 설명을 해주고 있습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;Mono blockingWrapper = Mono.fromCallable(() -&amp;gt; { 
    return /* make a remote synchronous call */ 
}).subscribeOn(Schedulers.elastic());&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Mono.fromCallable&lt;/code&gt;를 사용하여 blocking call 부분의 실행을 미루고, 이를 &lt;code&gt;Schedulers.elastic()&lt;/code&gt;를 사용하여 blocking 자원들을 기다리는 별도의 쓰레드를 생성하여 실행시키라고 설명되어 있습니다(직접 custom scheduler를 만들어 사용하여도 무관합니다).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;reactor.core.scheduler.Schedulers&lt;/code&gt;에서 기본으로 제공하는 스케쥴러들은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Schedulers.immediate() : Current thread.&lt;/li&gt;
&lt;li&gt;Schedulers.single() : A single, reusable thread.&lt;/li&gt;
&lt;li&gt;Schedulers.newSingle() : A per-call dedicated thread.&lt;/li&gt;
&lt;li&gt;Schedulers.elastic() : An elastic thread pool. It creates new worker pools as needed, and reuse idle ones. This is a good choice for I/O blocking work for instance.&lt;/li&gt;
&lt;li&gt;Schedulers.parallel() : A fixed pool of workers that is tuned for parallel work.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그럼 이제 처음에 살펴봤던 예제 코드로 다시 돌아가 &lt;code&gt;MemoSerivce&lt;/code&gt; 부분을 변경해보겠습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;@Slf4j
@Service
public class MemoService {
    private final MemoRepository memoRepository;

    public MemoService(MemoRepository memoRepository) {
        this.memoRepository = memoRepository;
    }

    public Mono&amp;lt;Memo&amp;gt; save(MemoRequestDTO memoRequestDTO) {
        log.info(&quot;===== MemoService 시작 =====&quot;);

        return Mono.fromCallable(() -&amp;gt; memoRepository.save(Memo.of(memoRequestDTO)))
                .subscribeOn(Schedulers.elastic())
                .log();
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 다시 실행결과를 살펴봅시다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;2018-12-21 13:34:36.926  INFO 52520 --- [ctor-http-nio-2] c.e.demo.interfaces.MemoController       : ===== MemoController 시작 =====
2018-12-21 13:34:36.926  INFO 52520 --- [ctor-http-nio-2] c.e.demo.domain.service.MemoService      : ===== MemoService 시작 =====
2018-12-21 13:34:36.982  INFO 52520 --- [ctor-http-nio-2] reactor.Mono.OnAssembly.1                : | onSubscribe([Fuseable] FluxOnAssembly.OnAssemblySubscriber)
2018-12-21 13:34:36.982  INFO 52520 --- [ctor-http-nio-2] reactor.Mono.OnAssembly.2                : | onSubscribe([Fuseable] FluxOnAssembly.OnAssemblySubscriber)
2018-12-21 13:34:36.983  INFO 52520 --- [ctor-http-nio-2] reactor.Mono.OnAssembly.2                : | request(unbounded)
2018-12-21 13:34:36.983  INFO 52520 --- [ctor-http-nio-2] reactor.Mono.OnAssembly.1                : | request(unbounded)
2018-12-21 13:34:36.990  INFO 52520 --- [      elastic-2] c.e.d.domain.repository.MemoRepository   : ===== MemoRepository 시작 =====
2018-12-21 13:34:41.994  INFO 52520 --- [      elastic-2] reactor.Mono.OnAssembly.1                : | onNext(com.example.demo.domain.model.Memo@3c0aa92b)
2018-12-21 13:34:41.995  INFO 52520 --- [      elastic-2] reactor.Mono.OnAssembly.2                : | onNext(com.example.demo.domain.dto.MemoResponseDTO@1c14c9b0)
2018-12-21 13:34:42.013  INFO 52520 --- [      elastic-2] reactor.Mono.OnAssembly.1                : | onComplete()
2018-12-21 13:34:42.013  INFO 52520 --- [      elastic-2] reactor.Mono.OnAssembly.2                : | onComplete()&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;blocking call 부분인 &lt;code&gt;MemoRepository&lt;/code&gt; 호출이 별도의 스레드(elastic-2)에서 돌아가는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;Spring Webflux와 jdbc(혹은 blocking call이 포함된 로직)를 사용하고 계시다면 나의 생각과 달리 blocking으로 돌아가고 있지 않은지 잘 살펴보는 습관이 필요할 것 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-framework-choice&quot;&gt;https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-framework-choice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://spring.io/blog/2016/07/20/notes-on-reactive-programming-part-iii-a-simple-http-server-application#bridging-from-blocking-to-reactive-with-spring-mvc&quot;&gt;https://spring.io/blog/2016/07/20/notes-on-reactive-programming-part-iii-a-simple-http-server-application#bridging-from-blocking-to-reactive-with-spring-mvc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://projectreactor.io/docs/core/release/reference/#schedulers&quot;&gt;https://projectreactor.io/docs/core/release/reference/#schedulers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://projectreactor.io/docs/core/release/reference/#faq.wrap-blocking&quot;&gt;https://projectreactor.io/docs/core/release/reference/#faq.wrap-blocking&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/210&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>JDBC</category>
<category>JPA</category>
<category>Non-blocking</category>
<category>spring webflux</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/210</guid>
<comments>https://itstory.tk/entry/Spring-Webflux-JDBC%ED%98%B9%EC%9D%80-blocking-call-%ED%95%B8%EB%93%A4%EB%A7%81-%EB%B0%A9%EB%B2%95#entry210comment</comments>
<pubDate>Wed, 26 Dec 2018 15:41:03 +0900</pubDate>
</item>
<item>
<title>[macOS Mojave] Evernote (혹은 특정앱만) dark mode 해제 시키는 방법</title>
<link>https://itstory.tk/entry/macOS-Mojave-Evernote-%ED%98%B9%EC%9D%80-%ED%8A%B9%EC%A0%95%EC%95%B1%EB%A7%8C-dark-mode-%ED%95%B4%EC%A0%9C-%EC%8B%9C%ED%82%A4%EB%8A%94-%EB%B0%A9%EB%B2%95</link>
<description>&lt;p&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;macOS Mojave (10.14 버전)부터 Dark mode가 지원됩니다.&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F99CD663C5C189B25299259&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99CD663C5C189B2529&quot; filemime=&quot;image/jpeg&quot; filename=&quot;darkmode-mac.jpg&quot; height=&quot;513&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;(사진 출처: &lt;a href=&quot;https://help.evernote.com/hc/ko/articles/360002061928-Evernote%EC%97%90%EC%84%9C-%EB%8B%A4%ED%81%AC-%EB%AA%A8%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Evernote 공홈 - Evernote에서 다크 모드를 사용하는 방법&lt;/a&gt;)&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;에버노트도 mojave에 맞춰 다크모드를 지원하는 새로운 업데이트를 출시하였습니다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;하지만 글 하이라이팅의 문제로 에버노트만 다크모드를 해제하고 싶었는데요, 저만 이런 생각을 가진건 아니였나 봅니다.&lt;/p&gt;&lt;p&gt;에버노트 게시판에 누군가 &lt;a href=&quot;https://discussion.evernote.com/topic/117494-can-you-turn-off-dark-mode-in-evernote-only/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Can you turn off Dark Mode in Evernote only?&lt;/a&gt; 로 질문을 올려놨네요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;에버노트 앱 자체에 라이트 모드 사용 설정이 존재하는데요,&lt;/p&gt;&lt;p&gt;환경설정 &amp;gt; 일반 &amp;gt; 노트에 라이트 모드 사용
&lt;/p&gt;&lt;p&gt;이 설정은 노트에만 흰색 배경을 보여주는 것이라 꽤나 미려하지 못합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그럼 macOS Mojave 에서 에버노트 혹은 특정 앱만 아예 dark mode를 해제 시키는 법을 이제 살펴보겠습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;1. 터미널 앱을 실행시킵니다.&lt;/b&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:684px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F99A60F3D5C189F531AA10F&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99A60F3D5C189F531A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;전체화면_2018__12__18__오후_4_17.png&quot; height=&quot;434&quot; width=&quot;684&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. Dark Mode를 해제하려는 앱의 고유 아이디를 확인합니다.&lt;/b&gt;&lt;/p&gt;&lt;p&gt;터미널에 다음과 같이 입력하시고 엔터를 누릅니다.&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;osascript -e 'id of app &quot;evernote&quot;'&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;그럼&amp;nbsp;&lt;b&gt;com.evernote.Evernote&lt;/b&gt;&amp;nbsp;가 출력됩니다.&lt;/p&gt;&lt;p&gt;(에버노트 기준으로 한 예시이니 다른 앱의 경우 evernote 부분에 원하시는 앱이름을 기재하면 됩니다.)&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:630px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F99762A375C18A16E2ED7D9&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99762A375C18A16E2E&quot; filemime=&quot;image/jpeg&quot; filename=&quot;1__kkd927_AL01190005-2_____zsh_.png&quot; height=&quot;176&quot; width=&quot;630&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;3. 해당 앱의 Dark Mode를 해제시킵니다.&lt;/b&gt;&lt;/p&gt;&lt;p&gt;터미널에 다음과 같이 입력 후 엔터를 눌러줍니다.&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;defaults write com.evernote.Evernote NSRequiresAquaSystemAppearance -bool yes&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;에버노트가 아닌 다른 앱으로 진행하시는 경우 com.evernote.Evernote 부분을 2번에서 출력된 아이디 값으로 변경 후 입력하시면 됩니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:798px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F994EC8385C18A1C42A84A8&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/994EC8385C18A1C42A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;1__kkd927_AL01190005-2_____zsh_-2.png&quot; height=&quot;171&quot; width=&quot;798&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이제 에버노트를 끄고 다시 실행하면 에버노트만 다크모드가 해제된 기본모드로 실행되는 것을 확인하실 수 있습니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F99D4EA3E5C18A3512FB658&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99D4EA3E5C18A3512F&quot; filemime=&quot;image/jpeg&quot; filename=&quot;전체화면_2018__12__18__오후_4_32.jpg&quot; height=&quot;400&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;설정을 초기화 하고 싶으신 경우&lt;/b&gt; 터미널에서 다음과 같이 입력하시면 됩니다.&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;defaults delete com.evernote.Evernote NSRequiresAquaSystemAppearance&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/209&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>그 외</category>
<category>Dark Mode</category>
<category>evernote</category>
<category>macOS Mojave</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/209</guid>
<comments>https://itstory.tk/entry/macOS-Mojave-Evernote-%ED%98%B9%EC%9D%80-%ED%8A%B9%EC%A0%95%EC%95%B1%EB%A7%8C-dark-mode-%ED%95%B4%EC%A0%9C-%EC%8B%9C%ED%82%A4%EB%8A%94-%EB%B0%A9%EB%B2%95#entry209comment</comments>
<pubDate>Tue, 18 Dec 2018 16:37:27 +0900</pubDate>
</item>
<item>
<title>spring-boot-starter-webflux swagger 3 설정</title>
<link>https://itstory.tk/entry/springbootstarterwebflux-swagger-3-%EC%84%A4%EC%A0%95</link>
<description>&lt;p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;구성 &lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;
- spring-boot-starter-webflux (2.1.0.RELEASE) &lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;
- springfox-swagger2 (3.0.0-SNAPSHOT)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;우선 &lt;/span&gt;&lt;code&gt;&lt;span style=&quot;color: rgb(0, 0, 0); background-color: rgb(234, 234, 234);&quot;&gt;pom.xml&lt;/span&gt;&lt;/code&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;에 관련 dependency들을 추가해 줍니다.&lt;/span&gt;&lt;/p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;



&lt;/span&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1.0.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
&amp;lt;/parent&amp;gt;

&amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
    &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;swagger.version&amp;gt;3.0.0-SNAPSHOT&amp;lt;/swagger.version&amp;gt;
&amp;lt;/properties&amp;gt;

&amp;lt;dependencies&amp;gt;
    &amp;lt;!-- srping webflux --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-webflux&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- swagger 3 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${swagger.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${swagger.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;springfox-spring-webflux&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${swagger.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;

&lt;/span&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;이후 Docket 빈을 생성해주시면 됩니다.&lt;/span&gt;&lt;/p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;



&lt;/span&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;@Configuration
@EnableSwagger2WebFlux
public class SwaggerConfig {
    @Bean
    public Docket api() {
        return new Docket(DocumentationType.SWAGGER_2)
            .select()
            .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))
            .build()
            .genericModelSubstitutes(Optional.class, Flux.class, Mono.class);
    }
}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;

&lt;/span&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;spring webflux를 사용하시면 api 응답값으로 &lt;/span&gt;&lt;code&gt;&lt;span style=&quot;color: rgb(0, 0, 0); background-color: rgb(234, 234, 234);&quot;&gt;Mono&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;, &lt;/span&gt;&lt;code&gt;&lt;span style=&quot;color: rgb(0, 0, 0); background-color: rgb(234, 234, 234);&quot;&gt;Flux&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;를 사용하실 텐데요, &lt;/span&gt;&lt;code&gt;&lt;span style=&quot;color: rgb(0, 0, 0); background-color: rgb(234, 234, 234);&quot;&gt;.genericModelSubstitutes(Optional.class, Flux.class, Mono.class);&lt;/span&gt;&lt;/code&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;를 추가해주시지 않으면 아래 이미지 처럼 Response 모델이 정상적으로 보이지 않습니다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F9907A5485BFB664F319D2D&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/9907A5485BFB664F31&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Swagger_UI.png&quot; height=&quot;623&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;정상적으로 SwaggerConfig에 추가해주셨다면 아래처럼 잘 나오게됩니다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F9964844E5BFB665E279E9B&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/9964844E5BFB665E27&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Swagger_UI-2.png&quot; height=&quot;265&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;이제 api 작성을 통해 테스트를 진행하시면 됩니다.&lt;/span&gt;&lt;/p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;



&lt;/span&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;@RestController
public class PostController {
    private final PostService postService;

    public PostController(PostService postService) {
        this.postService = postService;
    }

    @ApiOperation(value = &quot;Post 생성&quot;)
    @PostMapping(&quot;/boards/{boardId}/posts&quot;)
    public Mono&amp;lt;PostDTO&amp;gt; addPost(@PathVariable Long boardId, @RequestBody PostRequestDTO postRequestDTO) {
        // ...
    }
}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;

&lt;/span&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;이제 &lt;/span&gt;&lt;code&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;http://localhost:8080/swagger-ui.html&lt;/span&gt;&lt;/code&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;에 접속하셔서 정상적으로 swagger가 동작하는지 확인하시면 됩니다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F9990A0465BFB666C2797E8&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/9990A0465BFB666C27&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Swagger_UI-3.png&quot; height=&quot;632&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;



&lt;/span&gt;&lt;h2 id=&quot;참고&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;참고&lt;/span&gt;&lt;/h2&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;

&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://springfox.github.io/springfox/docs/current/&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;https://springfox.github.io/springfox/docs/current/&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/208&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>spring webflux</category>
<category>Swagger</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/208</guid>
<comments>https://itstory.tk/entry/springbootstarterwebflux-swagger-3-%EC%84%A4%EC%A0%95#entry208comment</comments>
<pubDate>Mon, 26 Nov 2018 12:21:19 +0900</pubDate>
</item>
<item>
<title>[IT] 개발 밋업 정보 공유 달력</title>
<link>https://itstory.tk/entry/IT-%EA%B0%9C%EB%B0%9C-%EB%B0%8B%EC%97%85-%EC%A0%95%EB%B3%B4-%EA%B3%B5%EC%9C%A0-%EB%8B%AC%EB%A0%A5</link>
<description>&lt;p&gt;개발 밋업(meetup)&amp;nbsp;정보 공유 달력입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://meetup4u.com&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://meetup4u.com&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;iframely-embed&quot;&gt;&lt;div class=&quot;iframely-responsive&quot; style=&quot;padding-bottom: 75%; padding-top: 120px;&quot;&gt;&lt;a href=&quot;https://meetup4u.com&quot; data-iframely-url=&quot;//cdn.iframe.ly/VenE2zn&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;script async=&quot;&quot; src=&quot;//cdn.iframe.ly/embed.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F992C55335BFAB25801C786&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/992C55335BFAB25801&quot; filemime=&quot;image/jpeg&quot; filename=&quot;calendar.jpg&quot; height=&quot;721&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/207&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>대외활동 소식</category>
<category>Meetup Calendar</category>
<category>개발 밋업 정보</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/207</guid>
<comments>https://itstory.tk/entry/IT-%EA%B0%9C%EB%B0%9C-%EB%B0%8B%EC%97%85-%EC%A0%95%EB%B3%B4-%EA%B3%B5%EC%9C%A0-%EB%8B%AC%EB%A0%A5#entry207comment</comments>
<pubDate>Sun, 25 Nov 2018 23:41:49 +0900</pubDate>
</item>
<item>
<title>가성비 갑 전기자전거, 샤오미 HIMO V1 직구 후기</title>
<link>https://itstory.tk/entry/%EA%B0%80%EC%84%B1%EB%B9%84-%EA%B0%91-%EC%A0%84%EA%B8%B0%EC%9E%90%EC%A0%84%EA%B1%B0-%EC%83%A4%EC%98%A4%EB%AF%B8-HIMO-V1-%EC%A7%81%EA%B5%AC-%ED%9B%84%EA%B8%B0</link>
<description>&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:580px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F99C0CA3B5BC187D41FEEE0&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99C0CA3B5BC187D41F&quot; filemime=&quot;image/jpeg&quot; filename=&quot;샤오미_himo_11.png&quot; height=&quot;587&quot; width=&quot;580&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;샤오미에서&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;https://youpin.mi.com/detail?gid=102351&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot; style=&quot;font-size: 14.6667px;&quot;&gt;크라우드 펀딩&lt;/a&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;을 통해 새로운 전기자전거 HIMO V1을 출시하였습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;실물도 매우 예쁘고(실제 첫 테스트 주행 시 몇몇 분께서 어느 제품인지 여쭤보셨습니다),&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;가격도 저렴하여 전기자전거 장만을 고려하고 계시는 분들께는 좋은 기회인 것 같습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;사이즈가 작아 자동차 트렁크에 들어갈 수 있습니다. 반대로 생각해보면 180이상의 장신들이 타시기엔 다소 불편함이 있을 것 같습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;우선 스펙을 살펴보면&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;txc-textbox&quot; style=&quot;border-style: solid; border-width: 1px; border-color: rgb(238, 238, 238); background-color: rgb(238, 238, 238); padding: 10px;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;모터전력: 250w&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;최대속력: 20km/h (25km/h 으로 변경 가능)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;제품무게: 16.7kg&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;가용하중: 100kg&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;주행 모드: eco mode(PAS 방식), mid mode(스로틀 방식), high mode(스로틀 방식)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;최대 이동거리: eco mode(50km), mid/high mode(30km)&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;




&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;테스트 주행해본 결과 실제 최대속력은 eco 모드(16km/h), mid 모드(18km/h), high 모드(23km/h) 정도 입니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;크기가 큰 전기자전거 만큼 성능은 나오지 않지만 가볍게 출퇴근 용도로 사용하시기엔 크기도 작고 좋을 것 같습니다. 오르막길도 크게 무리 없이 올라가집니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6667px;&quot;&gt;구입은 현재 국내에서 총판을 통해 판매되고 있지 않고 큐텐&amp;nbsp;직구를 통해 구매하실 수 있습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;shr_item&quot; style=&quot;position:relative; min-height:158px; margin:12px 0; padding:9px 10px; border:1px solid #dbdbdb; border-radius:1px; background-color:#fff;&quot;&gt;&lt;div class=&quot;item_dtl&quot; style=&quot;position:relative; height:158px; padding:5px; border:1px solid #f0f1f4;&quot;&gt;&lt;span class=&quot;thmb&quot; style=&quot;float:left; overflow:hidden; width:156px; height:156px; margin-right:9px; border:1px solid #e7e7e7;&quot;&gt;&lt;a href=&quot;https://qoo.tn/AD18JQ/Q130684404&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://gd.image-gmkt.com/li/696/515/1183515696.g_400-w-st_g.jpg&quot; width=&quot;156&quot; alt=&quot;&quot; style=&quot;vertical-align: middle; border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;a href=&quot;https://qoo.tn/AD18JQ/Q130684404&quot; target=&quot;_blank&quot; class=&quot;tit&quot; style=&quot;overflow:hidden; max-height:68px; margin-bottom:7px; line-height:17px; color:#000;cursor:pointer;&quot;&gt;[US$298.00](▼17%)♥ HIMO전동 조력 자전거 ♥ 실제 / 다중 모드 승차 / 휴대용 접이식/무료배송 /관부&lt;span style=&quot;font-size: 11pt;&quot;&gt;가세 포함&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;url&quot; style=&quot;position: absolute; left: 170px; bottom: 10px; display: block; font-weight: bold; color: rgb(145, 151, 163); font-size: 11pt;&quot;&gt;WWW.QOO10.COM&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;
&lt;/span&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;큐텐 쿠폰을 적용하시면 좀 더 저렴하게 구매하실 수 있으니 꼭 잊지말고 사용하시길 바랍니다. (&lt;/span&gt;&lt;a href=&quot;http://blog.naver.com/kagamlzzang/221103790385&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;큐펜 쿠폰 발급방법&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;쿠폰을 적용하시면 가격은 대략 관세포함 40만원 이하로 사실 수 있습니다. 관세를 직접 내시려면 30만원대 초반에 구매하실 수 있습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;혹시 직구가 처음이시라도 크게 겁먹을 필요없습니다. 국문 주소를 입력하셔도 집까지 무료로 배송이 되기때문에 일반 국내 쇼핑몰에서 쇼핑한다고 생각하시면 됩니다. 단 세관통관을 통해 개인통관고유부호만 추가로 입력하시면 됩니다. (&lt;/span&gt;&lt;a href=&quot;http://blog.naver.com/kagamlzzang/221103781301&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;통관부호 발급방법&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;관세의 경우 직접 납부하셔도 되고 제품 구매시 옵션을 통해 관세까지 미리 같이 결제하실 수 도 있습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F997DDA445BC18D89360CAC&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/997DDA445BC18D8936&quot; filemime=&quot;image/jpeg&quot; filename=&quot;샤오미_himo_1.jpg&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;배송은 대략 1주일 정도 걸립니다. 중국 현지 사정에 따라 더 일찍 도착할 수도, 더 늦게 도착할 수 도 있습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;박스를 개봉해보면 따로 조립할 필요없이 완제품으로 들어가 있습니다. 안장만 꼽아주시면 됩니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:960px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F9936F8495BC18E29192292&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/9936F8495BC18E2919&quot; filemime=&quot;image/jpeg&quot; filename=&quot;샤오미_himo_2.jpg&quot; height=&quot;540&quot; width=&quot;960&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;박스에서 꺼낸 샤오미 HIMO V1의 모습입니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F998B3D485BC18EA82DC2D1&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/998B3D485BC18EA82D&quot; filemime=&quot;image/jpeg&quot; filename=&quot;샤오미_himo_3.jpg&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;안장만 꼽아주고 핸들만 바로 세워주시면 됩니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F99F0C9495BC18EE4202A8A&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99F0C9495BC18EE420&quot; filemime=&quot;image/jpeg&quot; filename=&quot;샤오미_himo_4.jpg&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;기본으로 최대속력이 20km/h로 출고되지만 설정을 통해 25km/h로 변경가능합니다.&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;그럼 샤오미 HIMO V1 속도 업그레이드 방법을 알려드리겠습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;1. 우선 계기판의 화살표 버튼과 M버튼을 동시에 누르고 있으면 아래 사진처럼 숫자가 표시되게 됩니다.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;2. 화살표 버튼을 눌러 숫자를 150까지 올려줍니다. (M버튼을 누르면 숫자가 줄어듭니다)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;3. 다시 화살표 버튼과 M버튼을 동시에 누르면 저장되고 기존 화면으로 돌아옵니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:960px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F9975604D5BC18F202E1AC0&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/9975604D5BC18F202E&quot; filemime=&quot;image/jpeg&quot; filename=&quot;샤오미_himo_5.jpg&quot; height=&quot;540&quot; width=&quot;960&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;야외샷입니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F9907924A5BC190A4298F7D&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/9907924A5BC190A429&quot; filemime=&quot;image/jpeg&quot; filename=&quot;샤오미_himo_6.jpg&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/206&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>그 외</category>
<category>샤오미 HIMO V1</category>
<category>샤오미 전기자전거</category>
<category>샤오미 하이모</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/206</guid>
<comments>https://itstory.tk/entry/%EA%B0%80%EC%84%B1%EB%B9%84-%EA%B0%91-%EC%A0%84%EA%B8%B0%EC%9E%90%EC%A0%84%EA%B1%B0-%EC%83%A4%EC%98%A4%EB%AF%B8-HIMO-V1-%EC%A7%81%EA%B5%AC-%ED%9B%84%EA%B8%B0#entry206comment</comments>
<pubDate>Sat, 13 Oct 2018 15:32:26 +0900</pubDate>
</item>
<item>
<title>[책 리뷰] 아무것도 모르고 시작하는 인공지능 첫걸음</title>
<link>https://itstory.tk/entry/%EC%B1%85-%EB%A6%AC%EB%B7%B0-%EC%95%84%EB%AC%B4%EA%B2%83%EB%8F%84-%EB%AA%A8%EB%A5%B4%EA%B3%A0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5-%EC%B2%AB%EA%B1%B8%EC%9D%8C</link>
<description>&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:400px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F99150D4D5B4C7C6E211D68&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99150D4D5B4C7C6E21&quot; filemime=&quot;image/jpeg&quot; filename=&quot;B3863756314_l.jpg&quot; height=&quot;514&quot; width=&quot;400&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;최근 머신러닝, 딥러닝 등 인공지능 분야에 대한 세상의 관심이 뜨겁습니다.&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;IT관련 종사자가 아닌 일반인들도 알파고 인공지능, 테슬라 자율주행, AI 스피커&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;&amp;nbsp;등을 접하고 인공지능 분야에 대해 관심을 가질 정도이니 말 다한 셈이죠.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;하지만 정작 IT 개발자라고 하더라도 인공지능, 인공지능 말만 많이 들어봤지 어떤 개념으로 어떻게 돌아가는지는 모르는 분들이 많을 것입니다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;지금까지 해오던 웹, 앱 같은 개발과는 어찌보면 전혀 다른 분야이기 때문이죠.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;그래서 대세를 따라 인공지능을 배워보고 싶지만 어디서부터 어떻게 시작해야될지 감이 안잡히는 분들도 많으실 겁니다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;한빛미디어에서 출판한 &quot;아무것도 모르고 시작하는 인공지능 첫걸음&quot; 책은 제목 그래도 아무것도 모르고 인공지능을 시작하려는 분께 딱인 책인 것 같습니다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;책을 펴고 본격적으로 읽기전 전체적으로 훑어봤을 때 예상하던 것과 달라 많이 놀랐습니다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;딥러닝 모델에 대한 이론적인 설명과&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;&amp;nbsp;텐서플로우나 케라스같은 머신러닝 프레임워크를 이용하여 실습을 진행하는 그런 일반적인(?) 기술서적일 것이라 생각했지만, 이 책에는 코드가 단 한줄도 없습니다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;당장 나는 모델에 대한 개념을 익히고 코드를 작성하면서 동작하는 것을 눈으로 돌아가는 것을 원하시는 분이라면 적성에 안맞는 책이기도 합니다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;하지만 그건 어디까지나 인공지능에 대한 대략적인 이해를 가진 분들에게 해당하는 이야기입니다.&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;결국 인공지능에 대해 제대로 학습하기 위해선 단순히 코드를 짜는 것보단 기본적인 &lt;/span&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;원리를 이해를 하는 것이 필&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;수 있습니다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;&quot;아무것도 모르고 시작하는 인공지능 첫걸음&quot; 책은 인공지능의 역사, 용어, 인공지능이 어떻게 사고하는 지와 알고리즘 등의 전반적인 이론을 그림&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;과 함께 잘 설명해줍니다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;인공지능에 대해 기초지식이 없거나&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;&amp;nbsp;인공지능에 등장하는 용어들에 대해 잘 모르시는 입문자라면 꼭 읽어볼만한 책입니다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&lt;/span&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&lt;/span&gt;&lt;a href=&quot;http://www.hanbit.co.kr/store/books/look.php?p_code=B3863756314&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&quot;&lt;/span&gt;&lt;/a&gt;&lt;a href=&quot;http://www.hanbit.co.kr/store/books/look.php?p_code=B3863756314&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;아무것도 모르고 시작하는 인공지능 첫걸음&quot;&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&lt;/span&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&lt;/span&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;의 자세한 내용은 한빛미디어 홈페이지에서 확인 하실 수 있습니다.&lt;/span&gt;&lt;/p&gt;&lt;style type=&quot;text/css&quot;&gt;
p, li { white-space: pre-wrap; }
&lt;/style&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: right;&quot;&gt;&lt;span style=&quot;color: rgb(85, 85, 85); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;이 글은 한빛미디어의 도서 리뷰 활동으로 작성된 글입니다.&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/205&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>그 외</category>
<category>아무것도 모르고 시작하는 인공지능 첫걸음</category>
<category>한빛출판사</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/205</guid>
<comments>https://itstory.tk/entry/%EC%B1%85-%EB%A6%AC%EB%B7%B0-%EC%95%84%EB%AC%B4%EA%B2%83%EB%8F%84-%EB%AA%A8%EB%A5%B4%EA%B3%A0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5-%EC%B2%AB%EA%B1%B8%EC%9D%8C#entry205comment</comments>
<pubDate>Mon, 16 Jul 2018 20:34:40 +0900</pubDate>
</item>
<item>
<title>Spring MVC Last-Modified, If-Modified-Since 캐시 설정</title>
<link>https://itstory.tk/entry/Spring-MVC-LastModified-IfModifiedSince-%EC%BA%90%EC%8B%9C-%EC%84%A4%EC%A0%95</link>
<description>&lt;p&gt;Spring MVC에서 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Last-Modified&quot;&gt;Last-Modified&lt;/a&gt;와 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/If-Modified-Since&quot;&gt;If-Modified-Since&lt;/a&gt; 헤더를 통한 캐싱방법을 살펴보겠습니다. 웹 캐싱에 대한 이론적인 부분과 종류들은 다른 설명 글들이 많기 때문에 자세한 내용은 생략하도록 하겠습니다 (&lt;a href=&quot;http://cyberx.tistory.com/9&quot;&gt;링크&lt;/a&gt;).&lt;/p&gt;&lt;p&gt;캐싱의 순서는 다음과 같이 이루어집니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;브라우저에서 필요한 리소스를 서버에 최초로 요청합니다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;서버에서 응답헤더에 &lt;code&gt;Last-Modified&lt;/code&gt; 헤더를 셋팅하여 요청한 리소스와 함께 내려보내면, 브라우저는 해당 리소스의 복사본을 생성하여 저장합니다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;브라우저에서 해당 리소스를 재요청할 경우에는 서버에서 &lt;code&gt;Last-Modified&lt;/code&gt; 헤더에 설정한 값을 &lt;code&gt;If-Modified-Since&lt;/code&gt; 헤더에 포함시켜 서버에 요청합니다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;서버에서는 &lt;code&gt;If-Modified-Since&lt;/code&gt; 헤더 값을 통해 해당 리소스가 변경되었으면 &lt;code&gt;Last-Modified&lt;/code&gt; 헤더에 최신 수정날짜를 설정하여 파일을 전달합니다. 변경되지 않았을 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/304&quot;&gt;304 HTTP 상태코드&lt;/a&gt;로 응답하면 브라우저는 기존에 저장한 값을 재사용하게 됩니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;스프링에서는 &lt;code&gt;ServletWebRequest&lt;/code&gt; 객체에 &lt;code&gt;checkNotModified()&lt;/code&gt; 메서드를 구현하여 일련의 과정들을 큰 작업없이 가능하게 해줍니다.&lt;/p&gt;&lt;p&gt;해당 메서드는 리소스의 최근 수정일을 인자로 받아 브라우저에서 요청할 때 설정해주는 &lt;code&gt;If-Modified-Since&lt;/code&gt; 헤더 값과 값을 비교하여 리소스가 변경이 없는 경우 &lt;code&gt;true&lt;/code&gt;를 반환하고 응답 값에 자동으로 304 NOT Modified를 설정해줍니다. 변경이 있는 경우에는 &lt;code&gt;false&lt;/code&gt;를 반환합니다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;boolean checkNotModified(long lastModifiedTimestamp);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;브라우저에서 test.txt 파일을 요청한다고 가정해봅시다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;@GetMapping(&quot;/test&quot;)
public ResponseEntity&amp;lt;byte[]&amp;gt; test(ServletWebRequest request) throws IOException {
    Resource resource = new ClassPathResource(&quot;test.txt&quot;);

    // test.txt 파일의 최근 수정일을 인자값으로 넣어
    // 변경이 일어났는지 여부를 확인합니다.
    if (request.checkNotModified(resource.lastModified())) {
        // 변경이 없는 경우(혹은 최초 요청인 경우)
        // 빈 본문 값과 함께 304 상태코드가 반환됩니다.
        return null;
    }

    return ResponseEntity.ok()
        .cacheControl(CacheControl.noCache())
        // Last-Modified 헤더에 파일의 최근 수정일을 넣어 응답합니다.
        .lastModified(resource.lastModified())
        .body(FileCopyUtils.copyToByteArray(resoure.getFile()));
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 실제 브라우저에서의 동작이 어떻게 되는지 살펴보겠습니다.&lt;/p&gt;&lt;p&gt;브라우저가 최초 요청 시 서버의 응답을 살펴보면 아래 이미지 처럼 200 상태코드와 함께 &lt;code&gt;Last-Modified&lt;/code&gt; 헤더에 해당 파일의 최근 수정일을 설정하여 내려보내지게 됩니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:622px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F9929963C5B434F3C1F561C&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/9929963C5B434F3C1F&quot; filemime=&quot;image/jpeg&quot; filename=&quot;cache1.png&quot; height=&quot;439&quot; width=&quot;622&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;두 번째 요청 시 아래 이미지 처럼 전에 서버에서 &lt;code&gt;Last-Modified&lt;/code&gt; 헤더에 응답해준 값을 &lt;code&gt;If-Modified-Since&lt;/code&gt; 헤더에 설정하여 요청하게 됩니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:661px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F998E32355B434F4925A9B1&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/998E32355B434F4925&quot; filemime=&quot;image/jpeg&quot; filename=&quot;cache2.png&quot; height=&quot;116&quot; width=&quot;661&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그러면 서버에서는 아래 이미지 처럼 &lt;code&gt;304 Not Modified&lt;/code&gt; 상태코드를 반환하며 해당 파일의 내용을 전달하지 않습니다. 브라우저는 로컬에 캐싱해둔 파일을 재사용하게 됩니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:594px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F99AFC03D5B434F55032B2F&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99AFC03D5B434F5503&quot; filemime=&quot;image/jpeg&quot; filename=&quot;cache3.png&quot; height=&quot;297&quot; width=&quot;594&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/204&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>If-Modified-Since</category>
<category>Last-Modified</category>
<category>Spring MVC</category>
<category>웹 캐시</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/204</guid>
<comments>https://itstory.tk/entry/Spring-MVC-LastModified-IfModifiedSince-%EC%BA%90%EC%8B%9C-%EC%84%A4%EC%A0%95#entry204comment</comments>
<pubDate>Mon, 09 Jul 2018 21:05:19 +0900</pubDate>
</item>
<item>
<title>Java10 신규 기능(특징) 정리</title>
<link>https://itstory.tk/entry/Java-10-%EC%8B%A0%EA%B7%9C-%EA%B8%B0%EB%8A%A5%ED%8A%B9%EC%A7%95-%EC%A0%95%EB%A6%AC</link>
<description>&lt;p&gt;Java SE 8이 2014년 3월에 출시되고 3년 반이 흘러 Java SE 9이 2017년 9월에 출시되었습니다. 그리고 2018년 3월에 Java SE 10이 6개월만에 출시되었습니다. Java 10이 6개월만에 출시된 이유는 오라클이 클라우드 주도 개발자(cloud-driven developer)들을 지원하기 위해 앞으로 자바의 릴리즈 주기를 6개월로 변경하였기 때문입니다. 이는 Java 9부터 적용되며 매년 3월, 9월에 새로운 릴리즈가 출시됩니다. &lt;/p&gt;
&lt;p&gt;또한 3년 단위로 엔터프라이즈 환경을 위해 안정성에 초점을 맞춘 Long-Term Support (LTS) 버전이 출시될 예정입니다. Java 11이 차세대 LTS 버전으로 2021년 9월에 출시될 예정입니다. Java Platform Group, Oracle의 Chief Architect인 Mark Reinhold는 다음과 같이 설명했습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;OpenJDK binaries become the primary channel for developers to access the latest innovation in the Java SE platform, the Oracle JDK will remain as a long term support LTS offering for Oracle’s commercial and support customers.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이제부터 Java 10에 새로 추가된 12가지 특징들을 살펴보겠습니다.&lt;/p&gt;



&lt;h3 id=&quot;1-jep-286-local-variable-type-inference&quot;&gt;1. JEP 286: Local-Variable Type Inference&lt;/h3&gt;

&lt;p&gt;Java 10의 변화 중 코드 측면에서 가장 흥미로운 점을 하나 고르라면 당연 Local Variable Type Inference 입니다. 로컬변수 선언을 &lt;code&gt;var&lt;/code&gt; 를 이용하여 기존의 엄격한 타입 선언 방식에서 탈피하여 컴파일러에게 타입을 추론하게할 수 있습니다. 기존에 lombok에서 제공하는 val/var 기능을 사용하고 계셨다면 크게 생소하진 않을 내용입니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;var list = new ArrayList&amp;lt;String&amp;gt;();  // infers ArrayList&amp;lt;String&amp;gt;
var stream = list.stream();          // infers Stream&amp;lt;String&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Local Variable Type Inference는 다음과 같은 상황에서만 사용할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;초기화된 로컬 변수 선언 시&lt;/li&gt;
&lt;li&gt;반복문에서 지역변수 선언 시 (enhanced for loop 포함)&lt;/li&gt;
&lt;/ul&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var numbers = List.of(1, 2, 3, 4, 5);

for (var number : numbers) {
    System.out.println(number);
}

for (var i = 0; i &amp;lt; numbers.size(); i++) {
    System.out.println(numbers.get(i));
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java 9에서 등장한 &lt;a href=&quot;https://docs.oracle.com/javase/9/jshell/introduction-jshell.htm#JSHEL-GUID-630F27C8-1195-4989-9F6B-2C51D46F52C8&quot;&gt;jshell&lt;/a&gt;를 이용하면 쉽게 테스트할 수 있습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;jshell&amp;gt; var a = new ArrayList&amp;lt;&amp;gt;();
a ==&amp;gt; []

jshell&amp;gt; a.add(&quot;abc&quot;)
$2 ==&amp;gt; true

jshell&amp;gt; a.add(123)
$3 ==&amp;gt; true

jshell&amp;gt; a.get(0)
$4 ==&amp;gt; &quot;abc&quot;

jshell&amp;gt; a.get(1)
$5 ==&amp;gt; 123

jshell&amp;gt; a = &quot;123&quot;
|  Error:
|  incompatible types: java.lang.String cannot be 
|  converted to java.util.ArrayList&amp;lt;java.lang.Object&amp;gt;
|  a = &quot;123&quot;
|      ^---^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고로 다이아몬드 연산자 안에 타입을 넣지 않으면 ArrayList&amp;lt;Object&amp;gt;로 추론합니다.&lt;/p&gt;
&lt;p&gt;단, 주의해야할 점은 기존에 자바의 RHS(lamda, generics, diamond)에서 이미 타입 추론을 하고 있기 때문에, 해당 표현식의 LHS에 &lt;code&gt;var&lt;/code&gt; 로 대입하면 추론이 실패될 수 있습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;jshell&amp;gt; var f = () -&amp;gt; { };
|  Error:
|  cannot infer type for local variable f
|    (lambda expression needs an explicit target-type)
|  var f = () -&amp;gt; { };
|  ^----------------^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Local Variable Type Inference에 대해 더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/286&quot;&gt;OpenJDK : JEP 286&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;
&lt;p&gt;아래 차트는 Oracle이 Java 커뮤니티에서 Local Variable Type Inference에 관해 진행한 설문 결과입니다. 대다수가 이 변화를 환영하는 분위기네요.&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:677px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F995CC1445AE6D33C2173BA&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/995CC1445AE6D33C21&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Local_Variable_Type_Inference_for_Java_-_응답___SurveyMonkey.png&quot; height=&quot;747&quot; width=&quot;677&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-jep-296-consolidate-the-jdk-forest-into-a-single-repository&quot;&gt;2. JEP 296: Consolidate the JDK Forest into a Single Repository&lt;/h3&gt;

&lt;p&gt;수많은 JDK forest 저장소들을 단일 저장소로 통합시켰다는 내용으로, 내부 유지보수에 관한 것으로 설명은 생략하겠습니다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/296&quot;&gt;OpenJDK : JEP 296&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;3-jep-304-garbage-collector-interface&quot;&gt;3. JEP 304: Garbage-Collector Interface&lt;/h3&gt;

&lt;p&gt;간결한 garbage collector(GC) 인터페이스를 새로 추가하여 서로 다른 gc들의 코드를 분리할 수 있도록 개선시켰습니다. GC 혹은 HotSpot 개발자들에게 관련된 사항으로 설명은 생략하겠습니다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/304&quot;&gt;OpenJDK : JEP 304&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;4-jep-307-parallel-full-gc-for-g1&quot;&gt;4. JEP 307: Parallel Full GC for G1&lt;/h3&gt;

&lt;p&gt;Java 9에서 default Garbage Collector인 &lt;a href=&quot;https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector.htm#JSGCT-GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573&quot;&gt;G1&lt;/a&gt;은 full GC를 피하도록 설계되었지만, concurrent GC에서 충분한 young area를 확보하지 못하면 full GC가 발생합니다. 기존 G1에서 full GC를 수행할 때 싱글 쓰레드 방식으로 동작하는 mark-sweep-compact 알고리즘을 사용하였습니다. G1 이전의 default 였던 parallel collector 처럼 G1에서도 full GC를 병렬화 시켜 G1의 최악의 케이스에서 지연 시간을 개선시켰습니다. &lt;/p&gt;
&lt;p&gt;mark-sweep-compact 알고리즘을 병렬로 수행하도록 변경되었으며, 이 때 Young 과 Mixed GC와 동일한 쓰레드 수를 이용힙니다. &lt;code&gt;-XX:ParallelGCThreads&lt;/code&gt; 옵션을 이용해 쓰레드 수를 조절할 수 있으며, 이 옵션을 수정하면 Young 과 Mixed GC에도 변경사항이 적용됩니다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/307&quot;&gt;OpenJDK : JEP 307&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;5-jep-310-application-class-data-sharing&quot;&gt;5. JEP 310: Application Class-Data Sharing&lt;/h3&gt;

&lt;p&gt;기존의 Class-Data Sharing(CDS) 기능을 확장해 애플리케이션 클래스를 공유 아카이브에 배치하고 서로 다른 자바 프로세스들이 공유함할 수 있도록 개선함으로써, startup 시간을 단축시키고 메모리 사용량을 최적화 시켰습니다. 기존에 AppCDS 기능은 상업용으로 Oracle JDK에서만 제공되었으나, 오픈소스화 되어 Open JDK에도 사용할 수 있게 되었습니다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/310&quot;&gt;OpenJDK : JEP 310&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;6-jep-312-thread-local-handshakes&quot;&gt;6. JEP 312: Thread-Local Handshakes&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html&quot;&gt;JVM safepoint&lt;/a&gt;는 Stop the World를 의미합니다. Thread-Local Handshake는 이런 safepoint가 발생하는 지점들을 줄이기 위한 프로젝트입니다. 모든 쓰레드를 동시에 멈춰야 했던 기존과 달리 쓰레드를 개별로 멈출 수 있게 되었고, VM safepoint를 수행하지 않고도 개별 Thread에서 콜백을 실행할 수 있습니다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/312&quot;&gt;OpenJDK : JEP 312&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;7-jep-313-remove-the-native-header-generation-tool-javah&quot;&gt;7. JEP 313: Remove the Native-Header Generation Tool (javah)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;${JAVA_HOME}/bin&lt;/code&gt; 디렉터리 안에는 JDK에서 제공하는 수많은 툴들이 존재합니다. javah는 그 중에 하나로, 코드에 native 메서드들을 사용할 경우 JNI 헤더 파일들을 생성해줍니다. Java 8부터 javac에서 JNI 헤더 파일 생성을 지원하기 때문에 javah이 더 이상 필요하지 않아 제거되었습니다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/313&quot;&gt;OpenJDK : JEP 313&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;8-jep-314-additional-unicode-language-tag-extensions&quot;&gt;8. JEP 314: Additional Unicode Language-Tag Extensions&lt;/h3&gt;

&lt;p&gt;Java SE 7부터 &lt;a href=&quot;https://ko.wikipedia.org/wiki/IETF_%EC%96%B8%EC%96%B4_%ED%83%9C%EA%B7%B8&quot;&gt;BCP 47 언어 태그&lt;/a&gt;를 지원하기 시작했습니다. 언어 태그는 하이픈에 따라서 나뉘는, 하나 이상의 하위 태그(subtag)로부터 구성됩니다. 일반적으로는 다음의 순서로 쓰입니다. &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;language(언어)&lt;/li&gt;
&lt;li&gt;script(문자 체계)&lt;/li&gt;
&lt;li&gt;region(지역)&lt;/li&gt;
&lt;li&gt;variant(변이형)&lt;/li&gt;
&lt;li&gt;extension(확장)&lt;/li&gt;
&lt;li&gt;private use(개인용)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;en-GB&lt;/code&gt; 와 &lt;code&gt;en-US&lt;/code&gt; 언어태그를 예로 살펴보면, en은 영어를 의미하고 GB(Great Britain)와 US(United States)는 지역을 나타냅니다. Java 9에서는 &lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/documentation/java9locales-3559485.html&quot;&gt;BCP 47 U 언어태그 확장&lt;/a&gt; ca와 nu를 지원하기 시작했습니다. 예를들어 &lt;code&gt;th-TH-u-ca-buddhist-nu-thai&lt;/code&gt;는 불교달력(buddhist)와 태국 숫자 체계(nu-thai)기반의 태국지역(TH)의 태국어(th)를 나타냅니다. Java 10에서는 다음의 추가 확장을 지원하며, 이를 지원하기 위해 java.util.Local와 관련된 API들이 보완되었습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cu (currency type)&lt;/li&gt;
&lt;li&gt;fw (first day of week)&lt;/li&gt;
&lt;li&gt;rg (region override)&lt;/li&gt;
&lt;li&gt;tz (time zone)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/314&quot;&gt;OpenJDK : JEP 314&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;9-jep-316-heap-allocation-on-alternative-memory-devices&quot;&gt;9. JEP 316: Heap Allocation on Alternative Memory Devices&lt;/h3&gt;

&lt;p&gt;JVM heap 영역을 &lt;a href=&quot;https://en.wikipedia.org/wiki/NVDIMM&quot;&gt;NVDIMM&lt;/a&gt;(비휘발성 NAND 플래시 메모리) 혹은 사용자 지정과 같은 대체 메모리 장치에 할당할 수 있게됩니다. (이제 정전 걱정은 할 필요 없는 것일까요?) 이 기능은 새로 추가된 옵션인 &lt;code&gt;-XX:AllocateHeapAt=&amp;lt;path&amp;gt;&lt;/code&gt;를 이용해 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/316&quot;&gt;OpenJDK : JEP 316&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;10-jep-317-experimental-java-based-jit-compiler&quot;&gt;10. JEP 317: Experimental Java-Based JIT Compiler&lt;/h3&gt;

&lt;p&gt;현재 HotSpot JVM에는 C1, C2라는 두개의 런타임 컴파일러를 가지고 있습니다. 이 외에도 Java 언어 기반의 &lt;a href=&quot;https://ko.wikipedia.org/wiki/JIT_%EC%BB%B4%ED%8C%8C%EC%9D%BC&quot;&gt;JIT 컴파일러&lt;/a&gt;인 &lt;a href=&quot;https://github.com/oracle/graal&quot;&gt;Graal&lt;/a&gt;이 있으며, JDK 9에 소개된 JVM compiler interface(JVMCI)를 사용하고 있습니다. Graal은 이미 JDK에 포함되어 있으며, JDK 10에서 Linux/x64 플랫폼에서 실험적으로 JIT 컴파일러로 사용할 수 있습니다. Graal을 JIT 컴파일러로 설정하기 위해선, &lt;code&gt;-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler&lt;/code&gt; 옵션을 사용하면 됩니다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/317&quot;&gt;OpenJDK : JEP 317&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;11-jep-319-root-certificates&quot;&gt;11. JEP 319: Root Certificates&lt;/h3&gt;

&lt;p&gt;HTTPS 암호화 통신에 쓰는 SSL/TLS 인증서를 발급해주는 인증기관을 Certificate Authority(CA)라고 부릅니다. 보통 브라우저는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Root_certificate&quot;&gt;최상위 인증기관(trusted root CA)&lt;/a&gt; 목록을 자체적으로 가지고 있어, 인증서가 신용있다고 판단한 CA로부터 서명된 것인지 확인합니다.&lt;/p&gt;
&lt;p&gt;Java도 root CA를 위한 저장소를 가지고 있습니다. &lt;code&gt;${JAVA_HOME}/lib/security&lt;/code&gt; 디렉터리 하위에 있는 &lt;code&gt;cacerts&lt;/code&gt; 파일로, 단순한 keystore입니다. 기존에 OpenJDK 버전은 빈파일이 기본 셋팅이었지만, JDK 10부터는 Oracle JDK 버전에만 있던 root CA 목록이 기본으로 포함됩니다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/319&quot;&gt;OpenJDK : JEP 319&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;12-jep-322-time-based-release-versioning&quot;&gt;12. JEP 322: Time-Based Release Versioning&lt;/h3&gt;

&lt;p&gt;처음에 언급한 자바의 새로운 릴리즈 주기를 위한 버저닝(versioning) 포맷을 위한 변경사항입니다. 새로 적용될 포맷은 &lt;code&gt;[1-9][0-9]*((\.0)*\.[1-9][0-9]*)*&lt;/code&gt; 형식으로 &lt;code&gt;$FEATURE.$INTERIM.$UPDATE.$PATCH&lt;/code&gt; 의미를 가집니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$FEATURE - 6개월 주기로 증가됩니다. 2018년 3월 버전은 JDK 10, 2018년 9월 버전은 JDK 11입니다.&lt;/li&gt;
&lt;li&gt;$INTERIM - 6개월 주기 릴리즈 모델에서는 interim 릴리즈가 없어 항상 0 입니다.&lt;/li&gt;
&lt;li&gt;$UPDATE - 보안 이슈, 버그 등의 수정이 업데이트된 버전을 나타내며 1달 단위로 증가됩니다. 2018년 4월 버전은 JDK 10.0.1, 5월 버전은 JDK 10.0.2 입니다.&lt;/li&gt;
&lt;li&gt;$PATCH - 치명적인 이슈를 수정하여 배포할 때만 생기는 긴급 패치 버전입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F99180F4D5AE6D35826A3A6&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99180F4D5AE6D35826&quot; filemime=&quot;image/jpeg&quot; filename=&quot;java_release.jpg&quot; height=&quot;297&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(이미지 출처: &lt;a href=&quot;https://twitter.com/java/status/969287657015664640/photo/1?tfw_site=laytoun&amp;amp;ref_src=twsrc%5Etfw&amp;amp;ref_url=http%3A%2F%2Faboullaite.me%2F10-new-features-in-java-10%2F&quot;&gt;Java 공식 트위터&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://openjdk.java.net/jeps/322&quot;&gt;OpenJDK : JEP 322&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;참조&quot;&gt;참조&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://openjdk.java.net/projects/jdk/10/&quot;&gt;http://openjdk.java.net/projects/jdk/10/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blogs.oracle.com/java-platform-group/introducing-java-se-10&quot;&gt;https://blogs.oracle.com/java-platform-group/introducing-java-se-10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html&quot;&gt;http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/9/index.html&quot;&gt;https://docs.oracle.com/javase/9/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/10/index.html&quot;&gt;https://docs.oracle.com/javase/10/index.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/203&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java 10</category>
<category>JDK 10</category>
<category>new features</category>
<category>자바 10</category>
<category>특징</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/203</guid>
<comments>https://itstory.tk/entry/Java-10-%EC%8B%A0%EA%B7%9C-%EA%B8%B0%EB%8A%A5%ED%8A%B9%EC%A7%95-%EC%A0%95%EB%A6%AC#entry203comment</comments>
<pubDate>Mon, 30 Apr 2018 17:28:16 +0900</pubDate>
</item>
<item>
<title>[Gof 디자인 패턴] Strategy(전략) 패턴</title>
<link>https://itstory.tk/entry/Gof-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-Strategy%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4</link>
<description>&lt;p&gt;프로그래밍을 하다보면 비슷한 동작이지만 구현 방법(알고리즘)이 다른 경우를 많이 겪습니다. 예를 들어 외부 메일 가져오기 기능을 구현하려고 합니다. 네이버 메일, 다음 메일, 구글 메일 등을 가져온다고 가정하면 메일을 가져온다에서는 동일한 액션이지만 내부 구현을 살펴보면 호출 API 정보, 필요 파라미터 명 등이 조금씩 다를 수 있습니다. &lt;/p&gt;&lt;p&gt;처음에 네이버 메일와 구글 메일 가져오기만 지원한다면 if문 분기를 통해 다르게 처리할 수 도 있겠지만, 나중에 다음 메일과 네이트 메일 등도 추가적으로 지원한다고 하면 분기가 계속 증가할 것 입니다. 이러면 SOLID 설계 원칙의 개방-폐쇄 원칙(OCP)에 위반하는 코드가 생성될 확률이 커집니다. &lt;strong&gt;Strategy(전략) 패턴을 사용하면 이와 같이 같은 문제를 다른 방법으로도 쉽게 변경하면서 해결할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;위에서 언급한 외부 메일 가져오기 기능으로 예제를 살펴보겠습니다. 예제 프로그램의 클래스 다이어그램은 다음과 같습니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F991B3E3F5ACEF96A2771C1&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/991B3E3F5ACEF96A27&quot; filemime=&quot;image/jpeg&quot; filename=&quot;gof_strategy_pattern.jpg&quot; height=&quot;260&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;MailImporter.java&lt;/i&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public class MailImporter {
    private MailImportStrategy strategy;

    public MailImporter(MailImportStrategy strategy) {
        this.strategy = strategy;
    }

    public void changeStrategy(MailImportStrategy strategy) {
        this.strategy = strategy;
    }

    public void imports(){
        strategy.execute();
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MailImporter&lt;/code&gt; 클래스는 메일 가져오기 기능을 수행할 클래스입니다. &lt;code&gt;imports()&lt;/code&gt; 메서드에서 해당 서비스에 맞는 가져오기 기능(전략)을 구현한 &lt;code&gt;MailImportStrategy&lt;/code&gt; 클래스에 &lt;strong&gt;위임&lt;/strong&gt;하고 있습니다.&lt;/p&gt;&lt;p&gt;&lt;i&gt;MailImportStrategy.java&lt;/i&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public interface MailImportStrategy {
    void execute();
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MailImportStrategy&lt;/code&gt; 인터페이스는 해당 서비스에 맞는 외부 메일을 가져오는 기능(전략)을 위한 인터페이스입니다. 이 인터페이스를 구현하는 네이버, 구글, 다음 메일 가져오기 클래스에서 &lt;code&gt;execute()&lt;/code&gt; 메서드를 각각의 전략(각 시스템이 요구하는 정보)에 맞게 구현할 것 입니다.&lt;/p&gt;&lt;p&gt;&lt;i&gt;GoogleMailImportStrategy.java&lt;/i&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public class GoogleMailImportStrategy implements MailImportStrategy {
    @Override
    public void execute() {
        // Gmail의 필요정보에 맞게 가져오기 수행
        // ...
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;i&gt;NaverMailImportStrategy.java&lt;/i&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public class NaverMailImportStrategy implements MailImportStrategy {
    @Override
    public void execute() {
        // 네이버 메일의 필요정보에 맞게 가져오기 수행
        // ...
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;i&gt;NateMailImportStrategy.java&lt;/i&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public class NateMailImportStrategy implements MailImportStrategy {
    @Override
    public void execute() {
        // 네이트 메일의 필요정보에 맞게 가져오기 수행
        // ...
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 main 클래스에서 각 서비스 별로 메일 가져오기를 수행하여 봅시다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public class App {
    public static void main(String[] args) {
        // 구글 메일 가져오기 전략
        MailImporter mailImporter = new MailImporter(
            new GoogleMailImportStrategy()
        );

        // 메일 가져오기 수행
        mailImporter.imports();

        // 네이버 메일 가져오기로 전략 변경
        mailImporter.changeStrategy(
            new NaverMailImportStrategy()
        );

        mailImporter.imports();

        // 네이트 메일 가져오기로 전략 변경
        mailImporter.changeStrategy(
            new NateMailImportStrategy()
        );

        mailImporter.imports();
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이와 같이 Strategy 패턴을 이용하면 프로그램을 복잡하게 만드는 것처럼 보이지만 실제로는 그렇지 않습니다. 위임이라는 느슨한 연결을 사용하고 있어 전략을 용이하게 교환할 수 있습니다.&lt;/p&gt;&lt;p&gt;예를들어 현재 네이버, 구글, 네이트 메일 가져오기 기능만을 제공하고 있는데 다음 메일도 추가로 지원하는 것으로 스펙이 변경되었다고 가정합시다. 분기를 통해 서비스별 메일 가져오기를 구현하였다면 기존 가져오기 기능에 수정이 불가피하지만, 위의 Strategy 패턴에서는 &lt;code&gt;MailImportStrategy&lt;/code&gt; 인터페이스를 상속받아 &lt;code&gt;DaumMailImportStrategy&lt;/code&gt; 만 구현하면 됩니다. 기존 코드의 수정을 하여 사이드이펙트가 생길까 염려할 필요가 없게되는 것이죠. 즉, &lt;strong&gt;확장에는 열려있고 변경에는 닫혀있는 개방-폐쇄 원칙(OCP)을 수용할 수 있게 됩니다.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Strategy 패턴의 등장인물은 다음과 같습니다.&lt;/p&gt;&lt;p&gt;&lt;i&gt;Strategy&lt;/i&gt;&lt;/p&gt;&lt;p&gt;전략을 이용하기 위한 인터페이스(API)를 결정합니다. 예제에서 &lt;code&gt;MailImportStrategy&lt;/code&gt; 인터페이스가 이 역할을 합니다.&lt;/p&gt;&lt;p&gt;&lt;i&gt;ConcreteStrategy&lt;/i&gt;&lt;/p&gt;&lt;p&gt;Strategy 인터페이스를 실제로 구현한 클래스입니다. 예제에서 &lt;code&gt;NaverMailImportStrategy&lt;/code&gt;, &lt;code&gt;GoogleMailImportStrategy&lt;/code&gt;, &lt;code&gt;NateMailImportStrategy&lt;/code&gt; 클래스가 이 역할을 합니다.&lt;/p&gt;&lt;p&gt;&lt;i&gt;Context&lt;/i&gt;&lt;/p&gt;&lt;p&gt;Strategy를 이용하는 역할을 합니다. 예제에서 &lt;code&gt;MailImporter&lt;/code&gt; 클래스가 이 역할을 합니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:652px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F991D68345ACEF98F37FC74&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/991D68345ACEF98F37&quot; filemime=&quot;image/jpeg&quot; filename=&quot;strategy2.jpg&quot; height=&quot;348&quot; width=&quot;652&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/202&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Gof design pattern</category>
<category>GoF 디자인 패턴</category>
<category>Strategy 패턴</category>
<category>전략 패턴</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/202</guid>
<comments>https://itstory.tk/entry/Gof-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-Strategy%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4#entry202comment</comments>
<pubDate>Thu, 12 Apr 2018 14:52:23 +0900</pubDate>
</item>
<item>
<title>[JavaScript] 4. 함수와 프로토타입 체이닝 (3) - 프로토타입 체이닝</title>
<link>https://itstory.tk/entry/JavaScript-4-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B4%EB%8B%9D-3-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B4%EB%8B%9D</link>
<description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;자바스크립트는 기존 C++이나 자바 같은 객체지향 프로그래밍 언어와는 다른 프로토타입 기반의 객체지향 프로그래밍을 지원한다. 자바스크립트에서 객체는 자기 자신의 프로퍼티뿐만 아니라, 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티 또한 마치 자신의 것처럼 접근하는게 가능하다. 이것을 가능케 하는 게 바로 &lt;strong&gt;프로토타입 체이닝&lt;/strong&gt; 이다. 이전 글에 정리한 함수, this만 이해하면 프로토타입 체이닝은 딱히 어려운 점은 없다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://itstory.tk/entry/4-함수와-프로토타입-체이닝-1?category=969082&quot;&gt;[JavaScript] 4. 함수와 프로토타입 체이닝 (1) - 함수란&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://itstory.tk/entry/JavaScript-4-함수와-프로토타입-체이닝-2-this란?category=969082&quot;&gt;[JavaScript] 4. 함수와 프로토타입 체이닝 (2) - this란&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;객체 리터럴 방식으로 생성된 객체의 프로토타입 체이닝&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var myObject = {
    name: 'foo',
    sayName: function() {
        console.log('My name is ' + this.name);
    }
}

myObject.sayName(); // My name is foo
console.log(myObject.hasOwnProperty('name')); // true
console.log(myObject.hasOwnProperty('nickname')); // false&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;myObject.hasOwnProperty()&lt;/code&gt; 메서드는 어디서 난 것일까? 이 메서드는 인자로 넘긴 문자열 이름의 프로퍼티나 메서드가 있는지 체크하는 함수로 Object.prototype에 선언되어 있다.&lt;/p&gt;&lt;p&gt;객체 생성에서 말했듯이 객체 리터럴로 생성한 객체는 Object() 라는 내장 생성자 함수로 생성된 것이다. 그러면 아래 그림처럼 myObject 객체의 __proto__ 프로퍼티는 Object.prototype 객체를 가르키게 된다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:531px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F99112C475AC3049220A421&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99112C475AC3049220&quot; filemime=&quot;image/jpeg&quot; filename=&quot;myObject.jpg&quot; height=&quot;301&quot; width=&quot;531&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;자바스크립트에서 특정 객체의 프로퍼티나 메서드에 접근하려고 할 때, 해당 객체에 접근하려는 프로퍼티 또는 메서드가 없다면 __proto__ 링크를 다라 자신의 부모 역할을 하는 프로토 타입 객체의 프로퍼티를 차례대로 검색하며, 이를 프로토타입 체이닝이라고 한다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;생성자 함수로 생성된 객체의 프로토타입 체이닝&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;생성자 함수로 객체를 생성하는 경우도 다를 바가 없다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.setName = function(name) {
    this.name = name;
}

var foo = new Person('foo', 28);

console.log(foo.name); // foo

foo.setName('bar');

console.log(foo.name); // bar

console.log(foo.hasOwnProperty('name')); // true
console.log(foo.__proto__ === Person.prototype); // true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이전 &lt;a href=&quot;http://itstory.tk/entry/4-함수와-프로토타입-체이닝-1?category=969082&quot;&gt;함수편&lt;/a&gt;에서 살펴본 다이어그램에서 한 번더 확장만 하면된다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F991CBE445AC304B13050DB&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/991CBE445AC304B130&quot; filemime=&quot;image/jpeg&quot; filename=&quot;drawio-javascript-diagram_xml_-_draw_io.jpg&quot; height=&quot;546&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;그림에서 볼 수 있듯이 foo 객체의 __proto__는 Person.prototype 객체를 가르킨다. 따라서 프로토타입 체이닝을 통해 foo 객체는 &lt;code&gt;Person.prototype.setName&lt;/code&gt; 메서드를 사용할 수 있다.&lt;/p&gt;&lt;p&gt;여기서 프로토타입 체이닝이 끝나는 것이 아니라 recursive 하게 계속 진행된다. 즉 Person.prototype 객체의 __proto__는 Object.prototype을 가리키므로 foo 객체는 Object.prototype 속성들도 사용할 수 있게 된다. 코드에서 foo.hasOwnProperty 가 가능한 이유다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;프로토타입 체이닝의 종점&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;자바스크립트에서 Object.prototype 객체는 프로토타입 체이닝의 종점이다. 앞서 살펴봤듯이 객체 리터럴 방식이나 생성자 함수를 이용한 방식이나 결국엔 Object.prototype에서 프로토타입 체이닝이 끝나는 것을 알 수 있다.&lt;/p&gt;&lt;p&gt;자바스크립트의 숫자, 문자, 배열 등에서 사용되는 표준 메서드들의 경우, 이들의 프로토타입인 Number.prototype, String.prototype, Array.prototype 등에 정의되어있다. 물론 이러한 기본 내장 프로토타입 객체 또한 Object.prototype으로 연결된다.&lt;/p&gt;&lt;p&gt;Object.prototype, String.prototype 등과 같이 표준 빌트인 프로토타입 객체에도 사용자가 직접 정의한 메서드들을 추가하는 것을 허용한다. String.prototype에 추가한 메서드는 일반 문자열 표준 메서드처럼, 모든 문자열에서 접근 가능하다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;String.prototype.testMethod = function() {
    console.log(this.toString() + ' Go Go!');
}

var str = 'This is test.';

str.testMethod(); // This is test. Go Go!&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;프로토타입 메서드와 this 바인딩&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;위에서 살펴본 예제 코드들에서 prototype 객체에 정의한 메서드 내부에 &lt;code&gt;this&lt;/code&gt; 를 사용했다. 이전 글 &lt;a href=&quot;http://itstory.tk/entry/JavaScript-4-함수와-프로토타입-체이닝-2-this란?category=969082&quot;&gt;this편&lt;/a&gt;에서 설명한 this 바인딩 규칙이 그대로 적용된다. 결국, 메서드 호출 패턴에서의 this는 그 메서드를 호출한 객체에 바인딩된다는 것을 기억하자.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.setName = function(name) {
    this.name = name;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;디폴트 프로토타입은 다른 객체로 변경이 가능하다&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;디폴트 프로토타입 객체는 함수가 생성될 때 같이 생성되며, 함수의 prototype 프로퍼티에 연결된다. 자바스크립트에서는 이렇게 함수를 생성할 때 해당 함수와 연결되는 &lt;strong&gt;디폴트 프로토타입 객체를 다른 일반 객체로 변경하는 것이 가능하다.&lt;/strong&gt; 이러한 특징을 이용해서 객체지향의 상속을 구현한다.&lt;/p&gt;&lt;p&gt;여기서 주의할 점은 생성자 함수의 프로토타입 객체가 변경되면 변경된 시점 이후헤 생성된 객체들은 변경된 프로토 타입 객체로 연결되고, 이전에 생성된 객체들은 기존 프로토타입 객체로의 연결을 그대로 유지한다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Person(name) {
    this.name = name;
}

var foo = new Person('foo');

console.log(foo.country); // undefined

Person.prototype = {
    country: 'korea'
};

var bar = new Person('bar');

console.log(foo.country); // undefined
console.log(bar.country); // korea
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/201&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>자바스크립트</category>
<category>javascript</category>
<category>prototype</category>
<category>프로토타입 체이닝</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/201</guid>
<comments>https://itstory.tk/entry/JavaScript-4-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B4%EB%8B%9D-3-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B4%EB%8B%9D#entry201comment</comments>
<pubDate>Tue, 03 Apr 2018 13:37:25 +0900</pubDate>
</item>
<item>
<title>CSRF 공격이란? 그리고 CSRF 방어 방법</title>
<link>https://itstory.tk/entry/CSRF-%EA%B3%B5%EA%B2%A9%EC%9D%B4%EB%9E%80-%EA%B7%B8%EB%A6%AC%EA%B3%A0-CSRF-%EB%B0%A9%EC%96%B4-%EB%B0%A9%EB%B2%95</link>
<description>&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F991F41435ABE0C3920599D&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/991F41435ABE0C3920&quot; filemime=&quot;image/jpeg&quot; filename=&quot;0_RzQcEpN9HxWMDb8p.jpg&quot; height=&quot;429&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;CSRF 공격(Cross Site Request Forgery)은 웹 어플리케이션 취약점 중 하나로 인터넷 사용자(희생자)가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;CSRF를 통해 해커는 희생자의 권한을 도용하여 중요 기능을 실행하는 것이 가능합니다. 예를들어, 페이스북에 희생자의 계정으로 광고성 글을 올리는 것이 가능해 집니다. (물론 페이스북은 CSRF 공격에 대해 잘 대응을 하였겠지만, 이번 글에서 피해 서비스 = 페이스북으로 설명하겠습니다.) &lt;/p&gt;&lt;p&gt;조금 더 설명하자면, CSRF는 해커가 사용자의 컴퓨터를 감염시키거나 페이스북 서버를 해킹을 해서 이뤄지는 공격은 아닙니다. 그래서 CSRF 공격이 이뤄지려면 다음 조건이 만족되어야 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;위조 요청을 전송하는 서비스(페이스북)에 희생자가 로그인 상태&lt;/li&gt;
&lt;li&gt;희생자가 해커가 만든 피싱 사이트에 접속&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;언뜻 보면 이 두 조건을 다 만족하기가 어려울 것 같지만 생각처럼 드문 일은 아닙니다. 예를들어 페이스북, 네이버, 구글 등의 유명 사이트는 보통 PC에서 자동 로그인을 해놓은 경우가 많고 피싱 사이트는 피싱 메일, 음란 사이트(?) 등을 통해 접속될 수 있습니다. 또한 희생자가 해커가 만든 피싱 사이트를 하지 않더라도 해커가 XSS 공격을 성공한 정상 사이트를 통해 CSRF 공격이 수행될 수 도 있습니다.&lt;/p&gt;&lt;p&gt;CSRF가 행해지는 시나리오를 그림으로 그려보면 다음과 같습니다. 이미지는 직접 만들기 귀찮은 관계로 OWASP에 리더로 근무하시는 분의 블로그에서 발췌 하였습니다. (친절하진 않지만 그나마 제일 이해하기 쉬운 이미지인 것 같네요.)&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:747px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F99FF9D4B5ABE0C4933AE63&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99FF9D4B5ABE0C4933&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Csrf1.jpg&quot; height=&quot;379&quot; width=&quot;747&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;[이미지 출처 : &lt;a href=&quot;http://www.bluekaizen.org]&quot;&gt;http://www.bluekaizen.org]&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;좀 더 이해하기 쉽게 예제 CSRF 공격코드를 살펴보겠습니다. 물론 말도 안되는 이야기지만, 페이스북에 글을 쓸 때 아래 코드와 같은 폼이 전송된다고 예를 듭시다. 피싱 사이트에 똑같이 페이스북에 글쓰기를 요청하는 폼이 숨겨져 있고, 그 내용으로 가입하면 10만원을 준다는 사기성 광고를 본문으로 적혀져 있습니다. 희생자는 피싱 사이트에 접속함으로써 본인의 페이스북 계정으로 해당 글이 등록되게 됩니다.&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;br /&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;피싱 사이트에 포함된 코드&lt;/em&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;form action=&quot;http://facebook.com/api/content&quot; method=&quot;post&quot;&amp;gt;
    &amp;lt;input type=&quot;hidden&quot; name=&quot;body&quot; value=&quot;여기 가입하면 돈 10만원 드립니다.&quot; /&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;Click Me&quot;/&amp;gt;
&amp;lt;/form&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;위의 공격을 통해 희생자의 페친들은 친구가 올린 글이니 의심없이 속아 넘어갈 수도 있겠죠. 이런 끔찍한 일을 막기 위해 대표적인 CSRF 공격 방어 방법들을 몇 가지 살펴봅시다. 대표적으로 다음 2가지 방어기법이 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Referrer 검증&lt;/li&gt;
&lt;li&gt;Security Token 사용 (A.K.A CSRF Token)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;일반적으로 CSRF 공격 방어는 조회성(HTTP GET Method) 데이터에는 방어 대상에 두지 않고, 쓰기/변경이 가능한 POST, PATCH, DELETE Method에만 적용하면 됩니다. 물론 정말 중요한 데이터를 조회하거나 GET을 통해 쓰기/변경 등의 동작을 한다면 GET Method에도 방어를 해야할 수 도 있습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Referrer 검증&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Back-end 단에서 request의 referrer를 확인하여 domain (ex. *.facebook.com) 이 일치하는 지 검증하는 방법입니다. 일반적으로 referrer 검증만으로 대부분의 CSRF 공격을 방어할 수 있습니다. 하지만 같은 도메인 내의 페이지에 XSS 취약점이 있는 경우 CSRF 공격에 취약해질 수 있습니다. domain 단위 검증에서 좀 더 세밀하게 페이지 단위까지 일치하는지 검증을 하면 도메인 내의 타 페이지에서의 XSS 취약점에 의한 CSRF 공격을 방어할 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Security Token 사용 (A.K.A CSRF Token)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Referrer 검증이 불가한 환경이라면, Security Token를 활용할 수 있습니다. 우선 사용자의 세션에 임의의 난수 값을 저장하고 사용자의 요청 마다 해당 난수 값을 포함 시켜 전송시킵니다. 이후 Back-end 단에서 요청을 받을 때마다 세션에 저장된 토큰 값과 요청 파라미터에 전달되는 토큰 값이 일치하는 지 검증하는 방법입니다. 이 방법도 결국 같은 도메인 내에 XSS 취약점이 있다면 CSRF 공격에 취약해집니다. 아래는 간략한 샘플 코드입니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 로그인시, 또는 작업화면 요청시 CSRF 토큰을 생성하여 세션에 저장한다.
session.setAttribute(&quot;CSRF_TOKEN&quot;,UUID.randomUUID().toString());

// 요청 페이지에 CSRF 토큰을 셋팅하여 전송한다
&amp;lt;input type=&quot;hidden&quot; name=&quot;_csrf&quot; value=&quot;${CSRF_TOKEN}&quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 파라미터로 전달된 csrf 토큰 값
String param = request.getParameter(&quot;_csrf&quot;);

// 세션에 저장된 토큰 값과 일치 여부 검증
if (request.getSession().getAttribute(&quot;CSRF_TOKEN&quot;).equals(param)) {
    return true;
} else {
    response.sendRedirect(&quot;/&quot;);
    return false;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Double Submit Cookie 검증&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Double Submit Cookie 검증은 Security Token 검증의 한 종류로 세션을 사용할 수 없는 환경에서 사용할 수 있는 방법입니다. 웹브라우저의 Same Origin 정책으로 인해 자바스크립트에서 타 도메인의 쿠키 값을 확인/수정하지 못한다는 것을 이용한 방어 기법입니다. 스크립트 단에서 요청 시 난수 값을 생성하여 쿠키에 저장하고 동일한 난수 값을 요청 파라미터(혹은 헤더)에도 저장하여 서버로 전송합니다. 서버단에서는 쿠키의 토큰 값와 파라미터의 토큰 값이 일치하는 지만 검사하면 됩니다. 서버에 따로 토큰 값을 저장할 필요가 없어 위에서 살펴본 세션을 이용한 검증보다 개발 공수가 적은 편입니다. 피싱 사이트에서는 도메인이 달라 facebook.com 쿠키에 값을 저장하지 못하므로 (조금 전에 언급한 Same Origin 정책) 가능한 방어 기법입니다. 아래는 샘플 코드입니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * Generate 256-bit BASE64 encoded hashes
 *
 * @see https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#Synchronizer_.28CSRF.29_Tokens
 * @return {string}
 */
var generateCsrfToken = function() {
    function generateRandomString(length) {
        var text = &quot;&quot;;
        var possible = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;;
        for(var i = 0; i &amp;lt; length; i++) {
            text += possible.charAt(Math.floor(Math.random() * possible.length));
        }
        return text;
    };

    return btoa(generateRandomString(32));
}

// 쿠키 셋팅
var setCookie = function (cname, cvalue) {
    document.cookie = cname + &quot;=&quot; + cvalue + &quot;;path=/&quot;;
}

// 모든 ajax 요청 시 쿠키 및 header에 토큰 값을 같이 전달
jQuery.ajaxSetup({
    beforeSend: function(xhr, settings) {
        if (!(/^http:.*/.test(settings.url) || /^https:.*/.test(settings.url))) {
            var csrfToken = generateCsrfToken();

            setCookie('CSRF_TOKEN', encodeURIComponent(csrfToken));
            xhr.setRequestHeader(&quot;_csrf&quot;, csrfToken);
        }
    }
});&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 헤더로 전달된 csrf 토큰 값
String paramToken = request.getHeader(&quot;_csrf&quot;);

// 쿠키로 전달되 csrf 토큰 값
String cookieToken = null;

for (Cookie cookie : request.getCookies()) {
    if (&quot;CSRF_TOKEN&quot;.equals(cookie.getName())) {
        cookieToken = URLDecoder.decode(cookie.getValue(), &quot;UTF-8&quot;);

        // 재사용이 불가능하도록 쿠키 만료
        cookie.setPath(&quot;/&quot;);
        cookie.setValue(&quot;&quot;);
        cookie.setMaxAge(0);
        response.addCookie(cookie);

        break;
    }
}

// 두 값이 일치하는 지 검증
if (cookieToke.equals(paramToken)) {
    return true;
} else {
    return false;
}&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;참조&quot;&gt;&lt;br /&gt;&lt;/h3&gt;&lt;h3 id=&quot;참조&quot;&gt;참조&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)&quot;&gt;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://appsandsecurity.blogspot.kr/2012/01/stateless-csrf-protection.html&quot;&gt;http://appsandsecurity.blogspot.kr/2012/01/stateless-csrf-protection.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/200&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Web</category>
<category>CSRF Token</category>
<category>CSRF 공격</category>
<category>CSRF 방어 방법</category>
<category>Double Submit Cookie</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/200</guid>
<comments>https://itstory.tk/entry/CSRF-%EA%B3%B5%EA%B2%A9%EC%9D%B4%EB%9E%80-%EA%B7%B8%EB%A6%AC%EA%B3%A0-CSRF-%EB%B0%A9%EC%96%B4-%EB%B0%A9%EB%B2%95#entry200comment</comments>
<pubDate>Fri, 30 Mar 2018 19:08:24 +0900</pubDate>
</item>
<item>
<title>[JavaScript] 4. 함수와 프로토타입 체이닝 (2) - this란</title>
<link>https://itstory.tk/entry/JavaScript-4-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B4%EB%8B%9D-2-this%EB%9E%80</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=213715769&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/5/7/6/9/213715769h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=213715769&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;인사이드 자바스크립트&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 고현준,송형주&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 한빛미디어 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.01.02&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=213715769&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;함수-호출과-this&quot;&gt;&lt;br /&gt;함수 호출과 this&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;arguments 객체&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;C와 같은 엄격한 언어와 달리, 자바스크립트에서는 함수를 호출할 때 함수 형식에 맞춰 인자를 넘기지 않더라도 에러가 발생하지 않는다. 정의된 함수의 인자보다 적게 함수를 호출했을 경우, 넘겨지지 않은 인자에는 &lt;strong&gt;undefined&lt;/strong&gt; 값이 할당된다. 이와 반대로 정의된 인자 개수보다 많게 호출했을 경우 초과된 인수는 무시된다.&lt;/p&gt;&lt;p&gt;이러한 특성 때문에, 런타임 시에 호출된 인자의 개수를 확인하고 이에 따라 동작을 다르게 해줘야 할 경우가 있다. 이를 가능케 하는게 함수를 호출할 때 암묵적으로 전달되는 arguments 객체다. 이 객체는 실제 배열이 아닌 유사 배열 객체이다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function add(a, b) {
    console.dir(arguments);
    return a + b;
}

console.log(add(1)); // NaN
console.log(add(1, 2)); // 3
console.log(add(1, 2, 3)); // 3&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;호출 패턴과 this 바인딩&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;자바스크립트에서 함수를 호출할 때 기존 매개변수로 전달되는 인자값에 더해, 앞서 설명한 arguments 객체 및 &lt;strong&gt;this 인자가 함수 내부로 암묵적으로 전달된다.&lt;/strong&gt; this가 이해하기가 어려운 이유는 자바스크립트의 여러 가지 함수가 호출되는 방식(호출 패턴)에 따라 this가 다른 객체를 참조하기(this 바인딩) 때문이다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1. 객체의 메서드 호출할 때 this 바인딩&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;객체의 프로퍼티가 함수일 경우, 이 함수를 메서드라고 부른다. 메서드 내부 코드에서 사용된 this는 &lt;strong&gt;해당 메서드를 호출한 객체로 바인딩 된다.&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var myObject = {
    name: 'foo',
    sayName: function () {
        console.log(this.name);
    }
}

var otherObject = {
    name: 'bar'
}

otherObject.sayName = myObject.sayName;

myObject.sayName(); // foo
otherObject.sayName(); // bar&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. 함수를 호출할 때 this 바인딩&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;함수를 호출할 경우는, 해당 함수 내부 코드에서 사용된 &lt;strong&gt;this는 전역 객체에 바인딩된다.&lt;/strong&gt; 브라우저에서 자바스크립트를 실행하는 경우 전역 객체는 window 객체다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var test = 'This is test';
console.log(window.test); // 'This is test'

var sayFoo = function() {
    console.log(this.test); // 'This is test'
}

sayFoo();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이러한 함수 호출에서의 this 바인딩 특성은 &lt;strong&gt;내부 함수(inner function)를 호출했을 경우에도 동일하게 적용되므로&lt;/strong&gt; 유의해서 사용해야 한다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 전역 변수
var value = 100;

var myObject = {
    value : 1,
    func1 : function() {
        this.value += 1;
        console.log('func1() called. this.value : ' + this.value); // 2

        // func1의 내부 함수 func2
        func2 = function() {
            this.value += 1;
            console.log('func2() called. this.value : ' + this.value); // 101

            // func2의 내부 함수 func3
            func3 = function() {
                this.value += 1;
                console.log('func3() called. this.value : ' + this.value); // 102
            }

            func3();
        }

        func2();
    }
};

myObject.func1();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자바스크립트에서 &lt;strong&gt;내부 함수 호출 패턴을 정의해 놓지 않았기 때문에,&lt;/strong&gt; 함수로 취급되어 함수 호출 패턴 규칙에 따라 내부 함수의 this는 전역 객체에 바인딩된다. 그래서 흔히들 that 변수를 이용하여 this 값을 저장한다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var value = 100;

var myObject = {
    value : 1,
    func1 : function() {
        // 현 상태의 this를 that 변수에 저장
        var that = this;

        this.value += 1;
        console.log('func1() called. this.value : ' + this.value); // 2

        // func1의 내부 함수 func2
        func2 = function() {
            that.value += 1;
            console.log('func2() called. this.value : ' + that.value); // 3

            // func2의 내부 함수 func3
            func3 = function() {
                that.value += 1;
                console.log('func3() called. this.value : ' + that.value); // 4
            }

            func3();
        }

        func2();
    }
};

myObject.func1();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이와 같은 this 바인딩의 한계를 극복하려고, this 바인딩을 명시적으로 할 수 있도록 call과 apply 메서드를 제공한다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3. 생성자 함수를 호출할 때 this 바인딩&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;자바스크립트에서 &lt;strong&gt;기존 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다.&lt;/strong&gt; 일반 함수에 new를 붙여 호출하면 원치 않는 생성자 함수로 동작할 수 있기 때문에, 대부분의 자바스크립트 스타일 가이드에서는 특정 함수가 생성자 함수로 정의되어 있음을 알리려고 함수 이름의 첫 문자를 대문자로 쓰기를 권하고 있다.&lt;/p&gt;&lt;p&gt;생성자 함수에서의 this는 &lt;strong&gt;생성자 함수를 통해 새로 생성되어 반환되는 객체에 바인딩된다.&lt;/strong&gt; (이는 생성자 함수에서 명시적으로 다른 객체를 반환하지 않는 일반적인 경우에 적용됨)&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Person 생성자 함수
var Person = function(name) {
    this.name = name;
}

// foo 객체 생성
var foo = new Person('foo');
console.log(foo.name); // foo&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;객체 리터럴 방식과 생성자 함수를 통한 객체 생성 방식의 차이&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;객체 리터럴 방식으로 생성된 객체는 생성자 함수처럼 다른 인자를 넣어 형식은 같지만 다른 값을 가지는 객체를 생성할 수 없다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var foo = {
    name : 'foo'
}

function Person(name) {
    this.name = name;
}

var bar = new Person('bar');
var baz = new Person('baz');&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;또 다른 차이점은 객체 리터럴 방식으로 생성한 foo 객체의 __proto__ 프로퍼티는 Object.prototype를 가르키며, 생성자 함수를 통해 생성한 bar, baz 객체의 __proto__ 프로퍼티는 Person.prototype를 가르킨다는 점이다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;생성자 함수를 new를 붙이지 않고 호출할 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;생성자 함수를 new를 붙이지 않고 호출할 경우 위에서 살펴본 &lt;em&gt;2. 함수를 호출할 때 this 바인딩&lt;/em&gt; 규칙이 적용되어 this가 전역객체에 바인딩된다. 이런 위험성을 피하려고 널리 사용되는 패턴이 있다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function A(arg) {
    if (!(this instanceof A)) {
        return new A(arg);
    }

    this.value = arg ? arg : 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4. call과 apply 메서드를 이용한 명시적인 this 바인딩&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Function.prototype 객체의 메서드인 call()과 apply()를 통해 명시적으로 this를 바인딩 가능하다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Person 생성자 함수
function Person(name) {
    this.name = name;
}

// foo 빈 객체 생성
var foo = {};

Person.apply(foo, ['foo']);

console.log(foo.name); // foo
console.log(foo.__proto__ === Object.prototype) // true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예제에서 알 수 있듯이 apply()를 통해 호출한 경우, 생성자 함수 방식이 아닌 this 가 foo 객체에 바인딩되어 __proto__ 프로퍼티가 Person.prototype이 아닌 Object.prototype이다.&lt;/p&gt;&lt;p&gt;이처럼 apply()나 call() 메서드는 this를 원하는 값으로 명시적으로 매핑해서 특정 함수나 메서드를 호출할 수 있다는 장점이 있다. 그리고 이들의 대표적인 용도가 arguments 객체와 같은 유사 배열 객체에서 배열 메서드를 사용하는 경우이다. arguments 객체는 실제 배열이 아니므로 pop(), shift() 같은 표준 메서드를 사용할 수 없지만 apply() 메서드를 이용하면 가능하다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function myFunction() {
    // arguments.shift(); 에러 발생

    var args = Array.prototype.slice.apply(arguments);
}

myFunction();&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/199&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>자바스크립트</category>
<category>javascript</category>
<category>prototype</category>
<category>this</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/199</guid>
<comments>https://itstory.tk/entry/JavaScript-4-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B4%EB%8B%9D-2-this%EB%9E%80#entry199comment</comments>
<pubDate>Thu, 15 Mar 2018 17:29:02 +0900</pubDate>
</item>
<item>
<title>[책 리뷰] 코딩셰프의 3분 딥러닝, 케라스맛</title>
<link>https://itstory.tk/entry/%EC%BD%94%EB%94%A9%EC%85%B0%ED%94%84%EC%9D%98-3%EB%B6%84-%EB%94%A5%EB%9F%AC%EB%8B%9D-%EC%BC%80%EB%9D%BC%EC%8A%A4%EB%A7%9B</link>
<description>&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:350px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F99267B3D5AA5DB38323D3B&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99267B3D5AA5DB3832&quot; filemime=&quot;image/jpeg&quot; filename=&quot;keras.jpg&quot; height=&quot;514&quot; width=&quot;350&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt; color: rgb(0, 0, 0);&quot;&gt;코딩셰프의 3분 딥러닝, 케라스맛&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt; text-align: left;&quot;&gt;Keras 코드로 맛보는 ANN, DNN, CNN, RNN, AE, GAN, UNET&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt; text-align: left;&quot;&gt;김성진 저 |&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;gd_pub&quot; style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, &amp;quot;Malgun Gothic&amp;quot;, &amp;quot;Apple SD Gothic Neo&amp;quot;, AppleGothic, 돋움, Dotum, 굴림, Gulim, Helvetica, sans-serif; color: rgb(102, 102, 102); font-size: 12px;&quot;&gt;&lt;a style=&quot;color: rgb(51, 51, 51);&quot;&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt; color: rgb(0, 0, 0);&quot;&gt;한빛미디어&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;margin: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;font-size: 14.6667px; color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif;&quot;&gt;최근 딥러닝, 머신러닝에 관심이 많아져&lt;/span&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt; color: rgb(0, 0, 0);&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt; color: rgb(0, 0, 0);&quot;&gt;코딩셰프의 3분 딥러닝 케라스맛&lt;/span&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt; color: rgb(0, 0, 0);&quot;&gt;&amp;nbsp;책을 리뷰하게 되었습니다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt; color: rgb(0, 0, 0);&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;우선 첫인상은 핸디북 처럼 작고 두껍지 않은 귀여운 형태입니다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;목차에서 확인하실 수 있듯이 ANN, DNN, CNN, RNN, AE, GAN, UNET 딥러닝 모델에 대해 케라스를 이용해서 다룹니다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;저는 딥러닝, 머신러닝에 관해 기초지식이 전무한 상태로 봤는데 이 책은 완전 입문자를 위한 책은 아니다라는 느낌을 받았습니다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;입문을 넘어선 초급자를 위한 핵심 요약 책인듯 하네요.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;케라스 코드를 통해 모델을 설명해주는데 코드별로 자세하게 설명을 해주셔서 이해하기는 쉽게 되어있습니다. 또한 각 모델별로 특징 및 장단점들을 잘 요약해주셔서 내가 하려하는 기능에 어떤 모델을 써야 적합한지 쉽게 알 수 있을 것 같아요.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: &amp;quot;맑은 고딕&amp;quot;, sans-serif; font-size: 11pt;&quot;&gt;딥러닝에 기초지식이 있고&amp;nbsp;케라스에 입문 하시려는 분 혹은 각 모델들의 핵심을 정리하고 싶은 딥러닝 초급자에게 추천해드리고 싶습니다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 5px 0px; font-size: 12px; color: rgb(103, 103, 103); line-height: 21.6px; text-align: justify; overflow: hidden; zoom: 1; font-family: 돋움, dotum, Helvetica, sans-serif;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: right;&quot;&gt;&lt;b style=&quot;color: rgb(103, 103, 103); text-align: right;&quot;&gt;&lt;span style=&quot;color: rgb(102, 102, 102); font-size: 14px;&quot;&gt;이 글은 한빛미디어의 도서 리뷰 활동으로 작성된 글입니다.&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/198&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>그 외</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/198</guid>
<comments>https://itstory.tk/entry/%EC%BD%94%EB%94%A9%EC%85%B0%ED%94%84%EC%9D%98-3%EB%B6%84-%EB%94%A5%EB%9F%AC%EB%8B%9D-%EC%BC%80%EB%9D%BC%EC%8A%A4%EB%A7%9B#entry198comment</comments>
<pubDate>Mon, 12 Mar 2018 10:54:14 +0900</pubDate>
</item>
<item>
<title>[Gof 디자인 패턴] Iterator (반복자) 패턴</title>
<link>https://itstory.tk/entry/Gof-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-Iterator-%EB%B0%98%EB%B3%B5%EC%9E%90-%ED%8C%A8%ED%84%B4</link>
<description>&lt;p&gt;Java 언어에서 배열 arr의 모든 요소를 표시하기 위해서는 다음과 같이 for문을 사용합니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;for (int i = 0; i &amp;lt; arr.length; i++) {
    System.out.println(arr[i]);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for문의 변수 i를 통해 배열 arr의 요소에 접근할 수 있습니다. Iterator 패턴은 이런 변수 i의 기능을 추상화해서 일반화 한 것 입니다.&lt;/p&gt;&lt;p&gt;Iterator 패턴의 구성은 아래와 같습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Iterator(반복자)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;요소를 순서대로 검색해가는 인터페이스(API) 입니다. 다음 요소가 존재하는지를 얻기 위한 &lt;code&gt;hasNext&lt;/code&gt; 메서드와 다음 요소를 얻기 위한 &lt;code&gt;next&lt;/code&gt; 메서드를 결정합니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ConcreteIterator(반복자 구현체)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Iterator 인터페이스의 구현체 입니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Aggregate(집합체)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Iterator 역할을 만들어내는 인터페이스(API) 입니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ConcreteAggregate(집합체 구현체)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Aggregate 인터페이스의 구현체 입니다.&lt;/p&gt;&lt;p&gt;Iterator 패턴을 클래스 다이어그램으로 표기하면 다음과 같습니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:495px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F99C8A03D5A992031198354&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99C8A03D5A99203119&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Untitled_Diagram_xml_-_draw_io.png&quot; height=&quot;305&quot; width=&quot;495&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Iterator 패턴을 사용하여 만든 예제 프로그램을 살펴봅시다. 여기에서 작성할 예제 프로그램은 서가(BookShelf) 안에 책(Book)을 넣고, 그 책의 이름을 차례대로 표시하는 프로그램입니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:501px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F99D7213B5A9921DD0DA7C9&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99D7213B5A9921DD0D&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Untitled_Diagram_xml_-_draw_io.png&quot; height=&quot;537&quot; width=&quot;501&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public interface Aggregate {
    public abstract Iterator iterator();
}

public interface Iterator {
    public abstract boolean hasNext();
    public abstract Object Next();
}&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public class Book {
    private String name;

    public Book(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public class BookShelf implements Aggregate {
    private Book[] books;
    private int last = 0;

    public BookShelf(int maxsize) {
        this.books = new Book[maxsize];
    }

    public Book getBookAt(int index) {
        return books[index];
    }

    public void appendBook(Book book) {
        this.books[last] = book;
        last++;
    }

    public int getLength() {
        return last;
    }

    public Iterator iterator() {
        return new BookShelfIterator(this);
    }
}&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public class BookShelfIterator implements Iterator {
    private BookShelf bookShelf;
    private int index;

    public BookShelfIterator(BookShelf bookShelf) {
        this.bookShelf = bookShelf;
        this.index = 0;
    }

    public boolean hasNext() {
        if (index &amp;lt; bookShelf.getLength()) {
            return true;
        } else {
            return false;
        }
    }

    public Object next() {
        Book book = bookShelf.getBookAt(index);
        index++;
        return book;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 예제를 실행시켜 봅시다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;BookShelf bookShelf = new BookShelf(4);
bookShelf.appendBook(new Book(&quot;Around the World in 80 Days&quot;));
bookShelf.appendBook(new Book(&quot;Bible&quot;));
bookShelf.appendBook(new Book(&quot;Cinderella&quot;));
bookShelf.appendBook(new Book(&quot;Baddy-Long-Legs&quot;));

Iterator it = bookShelf.iterator();
while (it.hasNext()) {
    Book book = (Book)it.next();
    System.out.println(book.getName());
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java 개발자라면 iterator를 한 번쯤 보시거나 사용해본 경험이 있을 것입니다. 배열이라면 for문을 이용해서 빙글빙글 돌리면 좋은데, 왜 집합체의 외부에 Iterator 역할 같은 것을 만들어야 할까요?&lt;/p&gt;&lt;p&gt;가장 큰 이유는 &lt;strong&gt;Iterator를 사용함으로써 구현과 분리해서 하나씩 셀 수 있기 때문&lt;/strong&gt; 입니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;while (it.hasNext()) {
    Book book = (Book)it.next();
    System.out.println(book.getName());
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 코드에서 while 루프는 BookShelf의 구현에는 의존하지 않습니다. 만약 BookShelf를 배열에서 Vector로 변경한다고 하더라도 hasNext 메서드와 next 메서드만 올바르게 수정한다면, 위의 while 루프를 전혀 변경하지 않아도 동작합니다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;즉, 클래스를 부품처럼 사용할 수 있게 하고, 하나의 부품을 수정해도 다른 부품에는 큰 영향 없이 작은 수정만으로 끝낼 수 있게 재이용화의 장점을 누릴 수 있습니다.&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/197&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>GoF 디자인 패턴</category>
<category>Iterator 패턴</category>
<category>Java</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/197</guid>
<comments>https://itstory.tk/entry/Gof-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-Iterator-%EB%B0%98%EB%B3%B5%EC%9E%90-%ED%8C%A8%ED%84%B4#entry197comment</comments>
<pubDate>Fri, 02 Mar 2018 18:59:11 +0900</pubDate>
</item>
<item>
<title>MongoDB 인증 모드 (password) 설정</title>
<link>https://itstory.tk/entry/MongoDB-%EC%9D%B8%EC%A6%9D-%EB%AA%A8%EB%93%9C-password-%EC%84%A4%EC%A0%95</link>
<description>&lt;p&gt;MongoDB를 설치하면 기본적으로 패스워드 없이 접속할 수 있습니다. 기본 설정이 MongoDB가 설치된 서버의 로컬(127.0.0.1)에서만 접근할 수 있지만, 외부 서비스와의 연동을 위해 외부 접근을 허용하면 크나큰 보안 위협에 놓이게 됩니다.&lt;/p&gt;&lt;p&gt;실제로 MongoDB의 이런 기본 설정 때문에 비밀번호 없이 외부 접근을 허용하는 전세계적으로 사용자들이 꽤나 존재했고, 2017년 1월에 이런 취약점을 노린 랜섬웨어가 발생했습니다. 물론 한국 서버들도 예외는 아니였습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이번 공격은 관리자 암호가 설정되어 있지 않은 채 인터넷을 통해 접근이 가능하도록 설치되어 있는 몽고DB를 노리고 있다 - 보안 전문가인 빅터 거브스(Victor Gerves)와 니알 메리간(Niall Merrigan)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;관련 기사 : 보안뉴스 - &lt;a href=&quot;http://www.boannews.com/media/view.asp?idx=53019&quot;&gt;급속도로 퍼지는 몽고DB 랜섬웨어 공격과 그 의미&lt;/a&gt;&lt;/p&gt;&lt;p&gt;MongoDB 설치 후 패스워드(인증 모드) 설정은 반드시 진행해야 합니다. 이제 MongoDB의 인증(Authentication) 모드 설정에 대해 살펴보겠습니다.&lt;/p&gt;



&lt;h3 id=&quot;1-mongodb-shell-접속&quot;&gt;1. MongoDB Shell 접속&lt;/h3&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;$ mongo
# MongoDB shell version v3.6.2
# connecting to: mongodb://127.0.0.1:27017&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;2-administrator-user-생성&quot;&gt;2. Administrator User 생성&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;MongoDB 2.7 이상&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;use admin
db.createUser({
    user: &quot;&amp;lt;username&amp;gt;&quot;,
    pwd: &quot;&amp;lt;password&amp;gt;&quot;,
    roles: [ &quot;root&quot; ]
})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;MongoDB 2.4 이하&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;use admin
db.addUser({ 
    user: &quot;&amp;lt;username&amp;gt;&quot;,
    pwd: &quot;&amp;lt;password&amp;gt;&quot;,
    roles: [ &quot;userAdminAnyDatabase&quot; ] 
})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결과 예시&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;Successfully added user: {
    &quot;user&quot; : &quot;&amp;lt;username&amp;gt;&quot;,
    &quot;roles&quot; : [
        {
            &quot;role&quot; : &quot;userAdminAnyDatabase&quot;,
            &quot;db&quot; : &quot;admin&quot;
        }
    ]
}&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;3-mongodb-재시작&quot;&gt;3. MongoDB 재시작&lt;/h3&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;$ mongod --auth --port 27017 --dbpath /data/db1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--port&lt;/code&gt; 와 &lt;code&gt;--dbpath&lt;/code&gt; 는 옵션 값이며 미입력 시 위의 값이 default 입니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;configuration 파일을 이용하는 경우&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;우분투의 &lt;code&gt;apt-get&lt;/code&gt; 과 같은 패키지 매니저를 통해 설치한 경우 &lt;code&gt;service mongod start&lt;/code&gt; 를 통해 시작합니다. 이 경우는 configuration 파일을 통해 실행이 됩니다. &lt;code&gt;/etc/mongod.conf&lt;/code&gt; 를 다음과 같이 수정하고 재시작하시면 됩니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;MongoDB 2.x&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;auth=true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;MongoDB 3.x&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-yml&quot;&gt;security:
   authorization: enabled&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;우분투 예시&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;$ sudo service mongod start&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;4-확인&quot;&gt;4. 확인&lt;/h3&gt;

&lt;p&gt;재시작에 성공하였으면, 다시 &lt;code&gt;mongo&lt;/code&gt; 쉘에 접속하여 정상적으로 인증이 되는지 확인을 해봅시다. &lt;code&gt;1&lt;/code&gt; 이 출력되면 성공한 것 입니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;use admin
db.auth(&quot;&amp;lt;username&amp;gt;&quot;, &quot;&amp;lt;password&amp;gt;&quot; )&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;5-데이터베이스-및-일반-사용자-생성&quot;&gt;5. 데이터베이스 및 일반 사용자 생성&lt;/h3&gt;

&lt;p&gt;위에서 진행한 어드민 계정으로 &lt;code&gt;mongo&lt;/code&gt; 쉘에 접속하여 봅시다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;mongo -u &quot;&amp;lt;username&amp;gt;&quot; -p &quot;&amp;lt;password&amp;gt;&quot; --authenticationDatabase &quot;admin&quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 처럼 &lt;code&gt;-u&lt;/code&gt; 와 &lt;code&gt;-p&lt;/code&gt; 옵션 없이 접속하신 경우 4번에서 진행한 방법으로 인증하시면 됩니다. 이제 어플리케이션 단에서 사용할 데이터베이스를 생성해보고 일반 사용자를 생성해 봅시다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;use test_db
db.createUser({
    user: &quot;&amp;lt;username&amp;gt;&quot;, 
    pwd: &quot;&amp;lt;password&amp;gt;&quot;, 
    roles: [&quot;dbOwner&quot;]
})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;use test_db&lt;/code&gt; 를 실행할때 해당 데이터베이스로 이동 할 뿐만아니라 DB가 존재하지 않을 경우 생성이 함께 진행됩니다. 더 다양하고 세분화된 role을 확인하시려면 &lt;a href=&quot;https://docs.mongodb.com/manual/reference/built-in-roles/&quot;&gt;MongoDB Built-In Roles&lt;/a&gt;을 확인하세요.&lt;/p&gt;



&lt;h3 id=&quot;참고&quot;&gt;참고&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/tutorial/enable-authentication/&quot;&gt;https://docs.mongodb.com/manual/tutorial/enable-authentication/&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://docs.mongodb.com/manual/reference/configuration-options/#security.authorization&quot;&gt;https://docs.mongodb.com/manual/reference/configuration-options/#security.authorization&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://docs.mongodb.com/manual/reference/built-in-roles/&quot;&gt;https://docs.mongodb.com/manual/reference/built-in-roles/&lt;/a&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/196&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>리눅스&amp;우분투</category>
<category>authentication</category>
<category>MongoDB</category>
<category>PASSWORD</category>
<category>비밀번호</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/196</guid>
<comments>https://itstory.tk/entry/MongoDB-%EC%9D%B8%EC%A6%9D-%EB%AA%A8%EB%93%9C-password-%EC%84%A4%EC%A0%95#entry196comment</comments>
<pubDate>Wed, 31 Jan 2018 10:42:30 +0900</pubDate>
</item>
<item>
<title>[Ubuntu] MongoDB 설치</title>
<link>https://itstory.tk/entry/Ubuntu-MongoDB-%EC%84%A4%EC%B9%98</link>
<description>&lt;p&gt;MongoDB는 우분투 64-bit LTS버전만 지원합니다. 현재 MongoDB는 12.04 LTS, 14.04 LTS, 16.04 LTS 를 지원합니다.&lt;/p&gt;



&lt;h3 id=&quot;1-mongodb-public-gpg-key-추가&quot;&gt;1. MongoDB public GPG Key 추가&lt;/h3&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 2930ADAE8CAF5059EE73BB4B58712A2291FA4AD5&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;2-mongodb-repo-추가&quot;&gt;2. MongoDB repo 추가&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Ubuntu 12.04 (deprecated)&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;echo &quot;deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu precise/mongodb-org/3.6 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.list&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Ubuntu 14.04&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;echo &quot;deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.6 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.list&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Ubuntu 16.04&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;echo &quot;deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.6 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.list&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;3-패키지-파일-업데이트&quot;&gt;3. 패키지 파일 업데이트&lt;/h3&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get update&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;4-mongodb-설치&quot;&gt;4. MongoDB 설치&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;최신 안정화 버전 설치 시&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install -y mongodb-org&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;특정 버전 설치 시&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install -y mongodb-org=3.6.2 mongodb-org-server=3.6.2 mongodb-org-shell=3.6.2 mongodb-org-mongos=3.6.2 mongodb-org-tools=3.6.2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;특정 버전 설치 시 &lt;code&gt;apt-get upgrade&lt;/code&gt; 를 하게되면 최신버전으로 업그레이드될 수 있습니다. 해당 버전으로 고정하려면 아래와 같이 입력해야 됩니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;echo &quot;mongodb-org hold&quot; | sudo dpkg --set-selections
echo &quot;mongodb-org-server hold&quot; | sudo dpkg --set-selections
echo &quot;mongodb-org-shell hold&quot; | sudo dpkg --set-selections
echo &quot;mongodb-org-mongos hold&quot; | sudo dpkg --set-selections
echo &quot;mongodb-org-tools hold&quot; | sudo dpkg --set-selections&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;5-mongodb-실행&quot;&gt;5. MongoDB 실행&lt;/h3&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo service mongod start&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;6-mongodb-정상동작-확인&quot;&gt;6. MongoDB 정상동작 확인&lt;/h3&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo service mongod status&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;tail -f /var/log/mongodb/mongod.log

# [initandlisten] waiting for connections on port 27017 와 같이 출력&lt;/code&gt;&lt;/pre&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/195&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>리눅스&amp;우분투</category>
<category>MongoDB</category>
<category>Ubuntu 14.04</category>
<category>ubuntu 16.04</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/195</guid>
<comments>https://itstory.tk/entry/Ubuntu-MongoDB-%EC%84%A4%EC%B9%98#entry195comment</comments>
<pubDate>Tue, 30 Jan 2018 11:02:08 +0900</pubDate>
</item>
<item>
<title>자바스크립트에서 메모리 누수의 4가지 형태</title>
<link>https://itstory.tk/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98%EC%9D%98-4%EA%B0%80%EC%A7%80-%ED%98%95%ED%83%9C</link>
<description>&lt;blockquote&gt;
  &lt;p&gt;이 글은 &lt;a href=&quot;https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/&quot;&gt;4 Types of Memory Leaks in JavaScript and How to Get Rid Of Them&lt;/a&gt;를 번역한 글입니다. 번역 문서를 읽는 중, 오타나 어색한 문장이 있으면 부담없이 댓글 부탁드립니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이번 글에서 클라이언트단 JavaScript 코드의 일반적인 메모리 누수 유형에 대해 살펴보겠습니다. 또한 &lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/?hl=ko&quot;&gt;크롬 개발 도구(Chrome DevTools)&lt;/a&gt;를 사용하여 메모리 누수를 찾는 방법에 대해서도 알아보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;메모리 누수(Memory leaks)는 모든 개발자들이 직면하는 문제입니다. 심지어 메모리를 관리해주는 프로그래밍 언어(Java, C# 등)를 사용하는 경우에도 메모리 누수 문제에서 벗어날 수 없습니다. 메모리 누수는 어플리케이션의 속도 저하, 충돌, 지연 시간 증가뿐만 아니라 다른 어플리케이션에게도 악영향을 끼치는 등 전반적인 문제들의 원인이 됩니다.&lt;/p&gt;



&lt;h3 id=&quot;메모리-누수란&quot;&gt;메모리 누수란?&lt;/h3&gt;

&lt;p&gt;메모리 누수는 어떠한 이유로 애플리케이션에서 더이상 사용되지 않음에도 불구하고, 운영체제나 사용가능한 메모리 풀에 반환되지 않는 메모리라고 정의할 수 있습니다. 프로그래밍 언어들은 각기 다른 방법으로 메모리를 관리합니다. 이런 프로그래밍 언어 차원에서의 메모리 관리는 메모리 누수의 가능성을 많이 줄여줍니다. 하지만 프로그래밍 언어의 메모리 관리 시스템이 특정 메모리가 실제 사용중인지 미사용중인지 완벽히 구분해내는 것은 사실상 불가능에 가깝습니다. 오직 그 코드를 작성한 개발자들만이 해당 메모리 조각을 운영체제로 반환시킬 수 있는지 여부를 명확히 알 수 있습니다. 특정 프로그래밍 언어들은 개발자들이 좀 더 편리하게 메모리 반환을 할 수 있도록 기능들을 제공하기도 합니다. 개발자들이 명시적으로 미사용 메모리를 반환해야하는 언어들도 있습니다. 위키피디아에 &lt;a href=&quot;https://en.wikipedia.org/wiki/Manual_memory_management&quot;&gt;수동&lt;/a&gt; 과 &lt;a href=&quot;https://en.wikipedia.org/wiki/Manual_memory_management&quot;&gt;자동&lt;/a&gt; 메모리 관리에 관해 잘 설명해논 글이 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;자바스크립트에서의-메모리-관리&quot;&gt;자바스크립트에서의 메모리 관리&lt;/h3&gt;

&lt;p&gt;자바스크립트는 &lt;strong&gt;garbage collected&lt;/strong&gt; 언어 중 하나입니다. Garbage collected 언어들은 이전에 할당한 메모리를 애플리케이션에서 여전히 사용 중인지를 주기적으로 검사해 개발자들이 메모리를 관리에 덜 신경쓸 수 있도록 도움을 줍니다. 다른 말로, garbage collected 언어들은 메모리 관리 문제를 “어떤 메모리가 여전히 필요한가?” 에서 “어떤 메모리가 애플리케이션의 다른 코드에서 접근할 수 있는가?”로 관점을 축소할 수 있게 해줍니다. 이 둘의 차이점은 미묘해보이지만 매우 중요합니다. 할당된 메모리가 미래에 사용되는 지의 여부는 오직 개발자만이 알지만, 다른 코드에서 더 이상 접근되지 않은 메모리는 알고리즘적으로 결정할 수 있어 OS에 반환될 수 있도록 표시할 수 있습니다.&lt;/p&gt;
&lt;p&gt;Garbage collected가 아닌 언어들은 명시적 관리라는 다른 방법으로 메모리를 관리합니다. 개발자가 메모리를 더이상 사용하지 않을 때, 컴파일러가 메모리를 회수할 수 있도록 명시적으로 선언해야합니다. 이러한 기법은 잠재적으로 메모리 누수의 위험을 가질 수 있습니다.&lt;/p&gt;



&lt;h2 id=&quot;자바스크립트에서의-메모리-누수&quot;&gt;자바스크립트에서의 메모리 누수&lt;/h2&gt;

&lt;p&gt;Garbage collected 언어에서 메모리 누수의 주요 원인은 &lt;strong&gt;예상치 못한 참조&lt;/strong&gt; 입니다. 예상치 못한 참조(unwanted references)가 무엇인지 이해하기 위해선, 먼저 garbage collector가 어떤 방식으로 해당 메모리가 다른 코드에서 접근될 수 있는지 여부를 판단하는지를 알 필요가 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;mark-and-sweep&quot;&gt;Mark-and-sweep&lt;/h3&gt;

&lt;p&gt;대부분의 garbage collector는 &lt;strong&gt;mark-and-sweep&lt;/strong&gt; 라고 알려진 알고리즘을 사용합니다. 이 알고리즘은 다음과 같은 절차를 가집니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Garbage collector는 “roots”의 목록을 생성합니다. 루트들은 일반적으로 코드에서 참조가 계속 유지되는 전연 변수들입니다. 자바스크립트에서는 “window” 객체가 root가 되는 글로벌 변수의 대표적인 예입니다. window 객체는 항상 유지되기 때문에, garbage collector는 window 객체뿐만 아니라 그 자식 객체들도 항상 유지될 것이라 판단하여 폐기되지 않도록 합니다. &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;모든 루트들을 검사해 폐기되지 않도록 활성화 상태임을 표시합니다. 루트의 자식들도 재귀적으로 검사합니다(자식의 자식… 반복). 결국 루트에서 도달될 수 있는 자식 객체들은 폐기되지 않습니다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;할성화 상태로 표시되지 않은 모든 메모리 조각들은 이제 폐기될 수 있는 것으로 판단합니다. 그래서 garbage collector는 이 메모리들을 해제하여 OS에 반환합니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;최신 garbage collector들은 이 알고리즘을 다른 형태로 더 진화시켰지만, 기본 베이스는 동일합니다. 접근될 수 있는 메모리 조각들은 할성화 상태로 표시하고 그 외는 폐기되도록 고려되어집니다.&lt;/p&gt;
&lt;p&gt;예상치 못한 참조는 개발자는 더 이상 사용되지 않을 것이라 생각했지만, 어떠한 이유로 활성화 상태인 루트 트리 안에 존재하는 메모리 조각들입니다. 자바스크립트에서 예상치 못한 참조는 더이상 사용되지 않지만 코드 상 어딘가에 유지되어 해제되지 못한 변수들입니다. 어떤 이들은 이를 개발자의 실수라고 말하기도 합니다.&lt;/p&gt;
&lt;p&gt;그래서 자바스크립트에서 발생할 수 있는 일반적인 메모리 누수 형태들을 이해하기 위해서는 흔히 까먹기 쉬운 참조들을 먼저 알 필요가 있습니다.&lt;/p&gt;



&lt;h2 id=&quot;자바스크립트-메모리-누수의-일반적인-3가지-형태&quot;&gt;자바스크립트 메모리 누수의 일반적인 3가지 형태&lt;/h2&gt;



&lt;h3 id=&quot;1-우발적으로-생성된-전역-변수&quot;&gt;1. 우발적으로 생성된 전역 변수&lt;/h3&gt;

&lt;p&gt;자바스크립트 언어의 목표 중 하나는 Java와 유사하지만 초보자들도 쉽게 사용할 수 있는 언어를 만드는 것이었습니다. 그 방법 중 하나가 자바스크립트가 선언되지 않은 변수들을 처리할 수 있도록 하는 것이었습니다. 선언되지 않은 변수는 &lt;strong&gt;global&lt;/strong&gt; 객체 내부에 새로운 변수로 생성됩니다. 브라우저 환경에서 global 객체는 &lt;code&gt;window&lt;/code&gt; 입니다.&lt;/p&gt;
&lt;p&gt;아래의 코드는&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function foo(arg) {
    bar = &quot;this is a hidden global variable&quot;;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실제 다음과 같이 동작됩니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function foo(arg) {
    window.bar = &quot;this is an explicit global variable&quot;;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 &lt;code&gt;bar&lt;/code&gt; 변수가 &lt;code&gt;foo&lt;/code&gt; 함수 범위 내에서만 참조가 유지되도록 하려고 했는데 실수로 &lt;code&gt;var&lt;/code&gt; 로 선언 하는 것을 깜빡했다면, 예상지 못한 전역 객체가 생성되어진 것입니다. 위 예제에서 이 간단한 문장이 큰 악영향을 끼치지 않을 수 도 있지만, 좋지 않은 것은 분명합니다.&lt;/p&gt;
&lt;p&gt;또 다른 우발적인 전역 객체는 &lt;code&gt;this&lt;/code&gt; 를 통해 생성될 수 있습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function foo() {
    this.variable = &quot;potential accidental global&quot;;
}

// foo 함수를 호출하면, this는 window 전역 객체를 가리키게 됩니다.
foo();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자바스크립트 파일의 시작 부분에 &lt;code&gt;'use strict';&lt;/code&gt;를 추가하여 이러한 실수를 방지할 수 있습니다. 이는 자바스크립트 엔진이 우발적인 전역 객체 생성을 방지하도록 더 엄격한 모드로 자바스크립트를 파싱하게 해줍니다.&lt;/p&gt;
&lt;p&gt;예상치 못한 전역 변수에 대해 이야기했지만, 코드 여기저기서 필요에 의해 명시적으로 전역 변수를 선언하여 사용하는 곳이 많습니다. 이들은 null로 처리하거나 재할당하지 않는 한 garbage collector에 수집되지 않습니다. 특히, 대용량 데이터를 일시적으로 저장하고 처리하기 위해 사용된 전역 변수는 더 신중하게 다뤄야합니다. 전역 변수의 사용이 끝났다면, null로 처리하거나 재할당을 반드시 해야합니다. 전역 변수와 관련하여 메모리 사용 증가를 야기하는 일반적인 원인 중 하나는 캐시입니다. 캐시는 자주 사용되는 데이터들을 저장합니다. 이를 효줄적으로 처리하기 위해 데이터가 커진다면 캐시 사이즈도 커지게 됩니다. 캐시는 수집되지 않기 때문에 캐시 사이즈가 점점 커진다면 방대한 메모리 사용을 야기시킬 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;2-잊혀진-타이머와-콜백&quot;&gt;2. 잊혀진 타이머와 콜백&lt;/h3&gt;

&lt;p&gt;자바스크립트에서 &lt;code&gt;setInterval&lt;/code&gt; 는 매우 흔하게 사용됩니다. 많은 라이브러리에서 observer를 제공하거나, callback을 가지는 기능들을 가지고 있습니다. 이러한 라이브러리의 대부분은 더 이상 사용이 안되면 자체적으로 callback에 대한 참조를 해제하도록 구현되어 있습니다. 하지만 setInterval의 경우 아래와 같은 코드 형태를 많이 사용합니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var someResource = getData();
setInterval(function() {
    var node = document.getElementById('Node');
    if(node) {
        // Do stuff with node and someResource.
        node.innerHTML = JSON.stringify(someResource));
    }
}, 1000);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 예제를 통해 타이머 내부에서 참조된 노드 혹은 데이터가 더 이상 사용되지 않을 때 발생할 수 있는 문제를 살펴보겠습니다. &lt;code&gt;node&lt;/code&gt; 는 미래에 제거되어질지도 모르는 객체를 나타냅니다. 만약 객체가 제거되어지면 interval 내부의 핸들러는 더 이상 필요가 없게 되지만, 여전히 계속 동작되어 collector에 의해 수집되지 않게 됩니다. 만약 interval 핸들러가 수집되지 않는다면, 이 핸들러에 의존되는 객체들도 수집되지 않게 됩니다. 이 말은 대량의 데이터를 저장하고 있을 수도 있는 &lt;code&gt;someResource&lt;/code&gt; 도 수집되지 않게됨을 의미합니다.&lt;/p&gt;
&lt;p&gt;이러한 observer 형태의 경우, 더 이상 사용되지 않을 때 명시적으로 제거하는 것이 중요합니다. 이는 과거의 경우, 특정 브라우저(Internet Explorer 6 같은)들이 순환 참조를 잘 관리하지 못해 매우 중요한 요소 중 하나였습니다. 현재 대부분의 브라우저들은 observer 객체가 더 이상 사용되지 않으면 명시적으로 제거하지 않더라도 수집합니다. 하지만 이러한 observer들을 명시적으로 제거하는 것이 좋은 관행으로 남아 있습니다. 예를들어 다음 코드와 같습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var element = document.getElementById('button');

function onClick(event) {
    element.innerHtml = 'text';
}

element.addEventListener('click', onClick);
// Do stuff
element.removeEventListener('click', onClick);
element.parentNode.removeChild(element);
// Now when element goes out of scope,
// both element and onClick will be collected even in old browsers that don't
// handle cycles well.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Observer와 관련 참조들은 자바스크립트 개발자들에게 골칫거리가 되곤 했습니다. 이는 Internet Explorer의 garbage collector의 버그(혹은 애초에 그렇게 설계된) 때문이었습니다. 구버전 Internet Explorer는 DOM 노드와 자바스크립트 코드 사이의 순환 참조를 탐지하지 못 했습니다. 이로 인해 메모리 누수가 발생하게 되었고 개발자들은 명시적으로 참조를 제거하기 시작했습니다. 현재의 최신 브라우저들은(Internet Explorer와 Microsoft Edge를 포함하여) 이들을 정확하게 탐지하여 수집해갑니다. 즉, 노드가 제거되기 전에 &lt;code&gt;removeEventListener&lt;/code&gt;를 호출할 필요가 없어졌습니다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;jQuery&lt;/em&gt; 와 같은 프레임워크과 라이브리러들은 노드를 폐기하기 전에 listener들을 명시적으로 제거합니다. 이는 라이브러리 내부에서 수행되며, 구버전 Internet Explorer와 같이 문제가 생길법한 브라우저에서도 메모리 누수가 발생하지 않도록 구현되어 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;3-dom-외부에서의-참조&quot;&gt;3. DOM 외부에서의 참조&lt;/h3&gt;

&lt;p&gt;종종 DOM 노드들을 자료구조 안에 저장하는 것이 유용할 때가 있습니다. 테이블에서 여러 행의 내용을 빠르게 업데이트하려는 경우를 가정합시다. 각 행의 DOM 노드들에 대한 참조를 맵이나 배열에 저장하는 것이 좋습니다. 이 경우 DOM 요소에 대한 참조는 DOM 트리와 맵, 2군데에서 유지됩니다. 만약 나중에 이 행들을 제거해야할 경우 두 참조 모두 제거를 해야합니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var elements = {
    button: document.getElementById('button'),
    image: document.getElementById('image'),
    text: document.getElementById('text')
};

function doStuff() {
    image.src = 'http://some.url/image';
    button.click();
    console.log(text.innerHTML);
    // Much more logic
}

function removeButton() {
    // The button is a direct child of body.
    document.body.removeChild(document.getElementById('button'));

    // 여기서 elements 에서 여전히 button 참조를 가지고 있습니다.
    // 이 경우 button element는 여전히 메모리에 상주하게 되며 GC에 의해 수집될 수 없습니다.
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기에 추가적으로 고려해야되는 사항은 DOM 트리 안에서 내부 혹은 말단 노드의 참조입니다. 자바스크립트 코드에서 테이블의 특정 셀( 태그)에 대한 참조를 가지고 있다고 가정합시다. 나중에 DOM으로 부터 테이블을 제거하기로 결정했지만 여전히 셀에 대한 참조를 가지고 있게 됩니다. 직관적으로 GC가 해당 셀을 제외한 나머지는 수집할 것이라 생각됩니다. 하지만 현실은 그렇지 않습니다. 셀은 테이블의 자식 노드이고 자식 노드는 부모 노드에 대한 참조를 유지합니다. 그래서 테이블의 셀에 대한 참조로 인해 테이블 전체가 메모리에 유지되게 됩니다. DOM 요소에 대한 참조를 유지할 때는 이 점을 주의해야 합니다.&lt;/p&gt;



&lt;h3 id=&quot;4-클로저closures&quot;&gt;4. 클로저(Closures)&lt;/h3&gt;

&lt;p&gt;자바스크립트 개발에서 주요 요소 중 하나는 상위 스코프의 변수에 접근가능한 클로저입니다. Meteor 개발자들은 자바스크립트 런타임의 구현 방법으로 인해 메모리 누수가 가능한 &lt;a href=&quot;https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156&quot;&gt;특정한 사례를 발견&lt;/a&gt;했습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var theThing = null;
var replaceThing = function () {
  var originalThing = theThing;
  var unused = function () {
    if (originalThing)
      console.log(&quot;hi&quot;);
  };
  theThing = {
    longStr: new Array(1000000).join('*'),
    someMethod: function () {
      console.log('someMessage');
    }
  };
  // 만약 여기에 `originalThing = null` 를 추가한다면, 메모리 누수는 사라질 것 입니다.
};
setInterval(replaceThing, 1000);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 코드에서 &lt;code&gt;replaceThing&lt;/code&gt; 이 호출될 때마다 큰 사이즈의 배열과 &lt;code&gt;someMethod&lt;/code&gt; 클로저를 생성합니다. 동시에 &lt;code&gt;unused&lt;/code&gt; 변수는 &lt;code&gt;originalThing&lt;/code&gt; 를 참조하는 클로저를 가지게 됩니다(&lt;code&gt;originalThing&lt;/code&gt;는 &lt;code&gt;replaceThing&lt;/code&gt; 선언 위에 있는 &lt;code&gt;theThing&lt;/code&gt;을 참조). 벌써 헷갈리기 시작하시죠? 중요한 것은 &lt;code&gt;unused&lt;/code&gt; 와 같은 내부 함수에서는 자신을 둘러싼 부모 함수의 스코프를 공유한다는 것입니다(스코프 체이닝). &lt;code&gt;unused&lt;/code&gt; 내부 함수가 없었다면, &lt;code&gt;replaceThing&lt;/code&gt; 함수는 매번 실행 시 길이가 큰 문자열을 매번 생성하긴 하지만 최신 자바스크립트 엔진(V8 같은)에서는 이전에 호출된 &lt;code&gt;originalThing&lt;/code&gt; 이 사용되지 않음을 파악하고 이전 값을 메모리 해제하여 일정 메모리 사용량을 유지시켜 줍니다. 하지만 위의 코드에서는 &lt;code&gt;unused&lt;/code&gt; 내부 함수 때문에 &lt;code&gt;originalThing&lt;/code&gt; 을 참조하게 되고 비록 &lt;code&gt;unused&lt;/code&gt; 가 사용하지 않더라도 이 코드가 반복적으로 실행될 때 마다 메모리 사용량이 꾸준히 증가하는 것을 관찰할 수 있습니다(요약하자면, 최신 자바스크립트 엔진은 1 depth의 미사용 클로저에 대한 스코프를 클린징 해주지만 2 depth 부터는 안된다는 뜻인듯). GC가 실행되더라도 메모리 사용량이 줄어들지 않게 됩니다. 본질적으로 클로저의 참조고리가 생성되고(&lt;code&gt;theThing&lt;/code&gt; 변수를 루트로), 이 클로저의 범위에는 큰 사이즈의 배열에 대한 간접적인 참조를 동반하기 때문에 상당한 양의 메모리 누수가 발생하게 됩니다.&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;!-- 728X90 --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block; text-align:center;&quot;
     data-ad-layout=&quot;in-article&quot;
     data-ad-format=&quot;fluid&quot;
     data-ad-client=&quot;ca-pub-8876596272501347&quot;
     data-ad-slot=&quot;7399807364&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/p&gt;

&lt;h2 id=&quot;garbage-collectors의-비직관적인-동작&quot;&gt;Garbage Collectors의 비직관적인 동작&lt;/h2&gt;

&lt;p&gt;Garbage Collectors는 편리하지만 그 들만의 특정 메커니즘에 의해 동작됩니다. 그 특징 중 하나는 비결정성(nondeterminism)입니다. 이 말은 GC는 예측이 불가능하단 뜻입니다. 언제 수집이 수행되는지 정확하게 예측할 수 없습니다. 즉, 경우에 따라서 프로그램에 요구되는 메모리보다 더 많은 메모리가 사용되고 있을 수 있습니다. 또 다른 경우, 민감함 어플리케이션에서는 짧은 일시정지 현상이 보이기도 합니다. 비록 비결정성은 수집이 언제 수행될지 모른다는 것을 의미하지만, 대부분의 GC는 일반적으로 메모리 할당이 이뤄지는 경우에만 수집을 수행합니다. 만약 메모리 할당이 이뤄지지 않았으면 대부분의 GC는 유휴상태에 있게 됩니다. 아래와 같은 시나리오를 살펴봅시다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;사이즈가 큰 데이터 할당을 여러번 수행합니다.&lt;/li&gt;
&lt;li&gt;Garbage Collector에 의해 대부분(혹은 전부)은 더 이상 접근되지 않는다라고 표시가 됩니다.(더 이상 사용하지 않은 경우 null로 초기화 했다고 가정)&lt;/li&gt;
&lt;li&gt;더 이상의 할당을 수행하지 않습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 시나리오에서 대부분의 GC들은 더 이상 수집을 수행하지 않습니다. 즉, 더 이상 접근되지 않는 데이터 셋들이 남아있음에도 불구하고 수집이 일어나지 않습니다. 이는 엄격히 메모리 누수는 아니지만, 일반적인 메모리 사용량보다 더 많은 메모리를 사용하게 됩니다.&lt;/p&gt;
&lt;p&gt;구글은 이 동작에 대한 훌륭한 예제를 &lt;a href=&quot;https://developer.chrome.com/devtools/docs/demos/memory/example2&quot;&gt;JavaScript Memory Profiling docs, example #2&lt;/a&gt;에서 제공합니다.&lt;/p&gt;



&lt;h2 id=&quot;chrome-memory-profiling-tools-overview&quot;&gt;Chrome Memory Profiling Tools Overview&lt;/h2&gt;

&lt;p&gt;크롬은 자바스크립트 코드의 메모리 사용을 프로파일링할 수 있는 좋은 도구들을 제공합니다. 메모리에 관련 도구로 Performance 메뉴와 Memory메뉴가 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;performance-메뉴-구-timeline&quot;&gt;Performance 메뉴 (구 Timeline)&lt;/h3&gt;

&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F9987E04C5A559AE62F0DB4&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/9987E04C5A559AE62F&quot; filemime=&quot;image/jpeg&quot; filename=&quot;timeline.png&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Performance 메뉴는 코드에서 비정상 메모리 사용 패턴을 발견하는데 필수적입니다. 이 스크린샷에서 메모리 누수가 계속 커지는 것을 볼 수 있습니다. Major GC가 수행 후에도 메모리 사용량이 줄어들지 않습니다. 노드의 수도 점차 증가하고 있습니다. 이것들으 종합해보면 코드 어딘가에 DOM 노드의 누수임을 짐작할 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;memory-메뉴-구-profiles&quot;&gt;Memory 메뉴 (구 Profiles)&lt;/h3&gt;

&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F99B385495A559B1C2A9D8F&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99B385495A559B1C2A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;profiles.png&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;앞으로 자주 봐야할 메뉴입니다. Memory 메뉴에서 스냅샷들을 찍을 수 있고 자바스크립트 코드의 메모리 사용을 비교해볼 수 있습니다. 또한 시간에 따라 메모리 할당을 기록할 수 있습니다. summary 와 comparison 목록을 주로 살펴보시면 됩니다.&lt;/p&gt;



&lt;h2 id=&quot;크롬-개발자-도구를-이용한-메모리-누수-찾기-예제&quot;&gt;크롬 개발자 도구를 이용한 메모리 누수 찾기 예제&lt;/h2&gt;

&lt;p&gt;메모리 누수에는 크게 두 가지의 형태가 있습니다. 하나는 주기적으로 메모리 사용량이 증가하는 형태이고, 다른 하나는 단 한번만의 메모리 증가를 유발시키는 형태입니다. 일반적으로 전자를 탐지하는 것이 쉬운 편입니다. 하지만 전자 유형의 누수는 메모리가 계속 늘어나면 브라우저가 느려지거나 스크립트 실행이 중지되어 성가신 일을 야기하기도 합니다. 후자 유형인 주기적이지 않은 누수는 다른 메모리 할당에 비해 눈의 띌 정도로 큰 경우 쉽게 발견할 수 있습니다. 하지만 이런 경우들은 흔치 않기 때문에, 잘 인지못하고 넘어가는 경우가 많습니다. 하지만 주기적 메모리 누수는 버그임으로 반드시 해결해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.chrome.com/devtools/docs/demos/memory/example1&quot;&gt;Chrome 에서 제공해주는 예제&lt;/a&gt; 를 살펴보겠습니다. 전체 코드는 아래와 같습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var x = [];

function createSomeNodes() {
    var div,
        i = 100,
        frag = document.createDocumentFragment();
    for (;i &amp;gt; 0; i--) {
        div = document.createElement(&quot;div&quot;);
        div.appendChild(document.createTextNode(i + &quot; - &quot;+ new Date().toTimeString()));
        frag.appendChild(div);
    }
    document.getElementById(&quot;nodes&quot;).appendChild(frag);
}
function grow() {
    x.push(new Array(1000000).join('x'));
    createSomeNodes();
    setTimeout(grow,1000);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;grow&lt;/code&gt; 가 호출되면 div 노드들을 만들고 DOM에 추가시킵니다. 또한 큰 배열을 할당하고 이를 글로벌 변수에 참조시킵니다. 이 코드는 위에서 언급한 크롬 도구로 살펴보면 메모리가 꾸준히 증가하는 것을 확인할 수 있습니다.&lt;/p&gt;



&lt;h3 id=&quot;주기적으로-메모리가-증가하는-누수-탐지&quot;&gt;주기적으로 메모리가 증가하는 누수 탐지&lt;/h3&gt;

&lt;p&gt;Performance 메뉴(구 Timeline)를 통해 쉽게 탐지할 수 있습니다. &lt;a href=&quot;https://developer.chrome.com/devtools/docs/demos/memory/example1&quot;&gt;Chrome에서 제공해주는 예제 페이지&lt;/a&gt;에 들어가서 개발자 도구를 열고 Performance 메뉴에 들어갑니다. 그리고 memory 체크박스에 체크를 한 후 record 버튼을 누릅니다. 그 후, 예제 페이지의 &lt;code&gt;The Button&lt;/code&gt; 버튼을 눌려 메모리 누수를 시작시켜 봅니다. 잠시 후 record를 정지시킨 후 결과를 살펴봅시다.&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F99B5624A5A559B5814B755&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99B5624A5A559B5814&quot; filemime=&quot;image/jpeg&quot; filename=&quot;example-timeline.png&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이 사진에서 메모리 누수가 있다는 것을 보여주는 큰 징후가 두 개 있습니다. &lt;em&gt;nodes(초록선)&lt;/em&gt; 와 &lt;em&gt;JS heap(파란선)&lt;/em&gt; 그래프입니다. 노드들이 꾸준이 증가하며 감소되지 않습니다. 이것이 가장 큰 징후입니다.&lt;/p&gt;
&lt;p&gt;JS heap 그래프도 역시 메모리 사용이 계속 증가되고 있음을 보여줍니다. 하지만 garbage collector의 영향으로 알아채기가 쉽지는 않습니다. 초기에 메모리가 증가하다가 한 번 크게 감소하고 더 증가하다가 또 감소하는 형태가 반복됨을 확인할 수 있습니다. 이 경우 핵심은, GC에 의해 메모리 사용량이 감소할 때마다 힙의 크기가 이전보다 더 크게 유지된다는 점입니다. 다시 말해서 GC가 많은 양의 메모리를 수집하는 데 성공하고 있지만, 그 중 일부가 주기적으로 누수되고 있다는 것입니다.&lt;/p&gt;
&lt;p&gt;이제 메모리 누수가 있다는 것을 확신을 가질 수 있습니다. 이제 어디서 누수가 생기는지 찾아봅시다.&lt;/p&gt;



&lt;h3 id=&quot;두-개의-스냅샷-찍기&quot;&gt;두 개의 스냅샷 찍기&lt;/h3&gt;

&lt;p&gt;어디서 메모리 누수가 생기는지 찾기 위해서 크롬 개발자 도구의 Memory 메뉴(구 Profiles)를 이용할 것입니다. 이번 단계를 수행하기 위해 위 단계에서 접속한 크롬 예제 페이지를 새로고침 합니다. 이제 &lt;em&gt;Take Heap Snapshot&lt;/em&gt; 기능을 사용할 것 입니다.&lt;/p&gt;
&lt;p&gt;페이지를 새로고침하고 페이지 로딩이 끝나면 heap 스냅샷을 생성합니다. 이 스냅샷을 기준으로 사용하겠습니다. 그런 다음 다시 &lt;code&gt;The Button&lt;/code&gt; 을 누르고 몇 초간 기다린 후에 두번째 스냅샷을 생성합시다. 스냅샷을 생성했다면 코드에 중단점을 설정하여 더 이상 누수가 되지 않게 하는 것이 좋습니다.&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F998DF3445A559B8824C84F&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/998DF3445A559B8824&quot; filemime=&quot;image/jpeg&quot; filename=&quot;example-snapshots-1.png&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;두 스냅샷의 메모리 할당을 비교할 수 있는 두가지 방법이 있습니다. &lt;em&gt;Summary&lt;/em&gt; 를 선택한 다음, 우측에 있는 &lt;code&gt;All objects&lt;/code&gt; 를 &lt;code&gt;Objects allocated between Snapshot1 and Snapshot 2&lt;/code&gt; 를 선택하거나 &lt;code&gt;Summary&lt;/code&gt; 대신 &lt;code&gt;Comparison&lt;/code&gt; 을 선택하면 됩니다. 두 방법 모두 두 스냅샷의 할당된 객체 목록이 표시됩니다.&lt;/p&gt;
&lt;p&gt;이 예제에서 메모리 누수가 크기 때문에 매우 쉽게 발견됩니다. &lt;code&gt;(string)&lt;/code&gt; Constructor의 &lt;code&gt;Size Delta&lt;/code&gt; 표를 확인 해봅시다. 58개의 객체 생성으로 8MB를 차지하고 있습니다. 의심스로운 결과입니다. 새로운 객체들이 할당되었지만 해제되지 않아 8MB의 메모리가 소비되었습니다. &lt;code&gt;(string)&lt;/code&gt; Constuctor 표를 열어보면 사이즈가 매우 큰 할당이 몇 개 있는 것을 확인하실 수 있습니다. 이 중 하나(xxxxxxxx… 로 표시된)를 선택하여 하단의 &lt;code&gt;Retainers&lt;/code&gt; 표를 살펴보면 흥미로운 점을 찾을 수 있습니다.&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F99316C495A559BBC0D4650&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99316C495A559BBC0D&quot; filemime=&quot;image/jpeg&quot; filename=&quot;example-snapshots-2.png&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;선택한 할당이 배열의 일부임을 확인할 수 있습니다. 이 배열은 전역 &lt;code&gt;window&lt;/code&gt; 객체의 &lt;code&gt;x&lt;/code&gt; 변수로 참조되어 있다고 나옵니다. 이는 수집되지 않는 루트 (window) 객체에 큰 사이즈의 객체가 참조되어 있음을 우리에게 알려줍니다. 이제 잠재적인 메모리 누수와 그 위치를 발견했습니다.&lt;/p&gt;
&lt;p&gt;꽤나 기쁜 발견이지만 우리의 예제는 매우 간단했습니다. 이 예제에서 볼 수 있는 것과 같이 큰 할당은 일반적인 경우는 아닙니다. 다행이도 우리의 예제는 작긴하지만 DOM 노드의 누수 문제도 포함하고 있었습니다. 위 스냅샷을 이용하여 이 노드들을 쉽게 찾을 수 있었지만, 규모가 큰 사이트에서는 더 복잡하여 찾기가 쉽지는 않을 것 입니다. 최신 버전의 크롬은 이런 작업에 적합한 추가적인 도구를 제공하는데, 바로 &lt;code&gt;Record Heap Allocations&lt;/code&gt; 기능입니다.&lt;/p&gt;



&lt;h3 id=&quot;recording-heap-allocations-to-find-leaks&quot;&gt;Recording heap allocations to find leaks&lt;/h3&gt;

&lt;p&gt;이전에 설정한 중단점을 제거하여 예제 페이지의 스크립트가 계속 실행되도록 한 다음 크롬 개발자 도구의 Memory 메뉴(구 Profiles)로 돌아가봅시다. 그리고 &lt;em&gt;Record allocation timeline&lt;/em&gt; 을 체크한 후 스냅샷을 찍어봅시다. 기록이 진행되는 동안 상단에 파랑색의 기둥 모양의 그래프가 생기는 것을 볼 수 있을 것입니다. 이것은 메모리 할당을 나타냅니다. 매초마다 큰 할당이 이뤄지는 것을 보실 수 있을 것입니다. 몇초동안 기록을 진행한 다음 중지합니다(중지 후 예제 코드가 메모리를 계속 잡아 먹지 않게 중단점 설정하는 것을 잊지맙시다).&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F99BE88495A559BEC2AD025&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99BE88495A559BEC2A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;example-recordedallocs-overview.png&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;위 사진에서 볼 수 있듯이 차트 타임라인의 일부를 선택하면 해당 기간 동안에 수행되는 할당만 볼 수 있습니다. 위 사진에서는 큰 할당이 있는 부분에 근접하게 설정했습니다. 목록에는 3개의 constructor만 표시되어 있습니다. 이 중 하나는 메모리 누수를 일으키는 &lt;code&gt;(string)&lt;/code&gt; 항목이고, 다른 하나는 DOM 할당에 관련된 항목, 나머지 하나는 &lt;code&gt;Text&lt;/code&gt; constructor 항목(DOM 말단 노드에 존재하는 text 요소)입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HTMLDivElement&lt;/code&gt; constructor 항목 중 하나를 선택하고 하단의 &lt;code&gt;Allocation stack&lt;/code&gt; 메뉴를 눌러봅시다(메뉴가 안보이면 우측 상단의 옵션에 들어가 &lt;code&gt;Settings &amp;gt; Record heap allocation stack traces&lt;/code&gt; 를 체크하면 됩니다).&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F99FB8E485A559C410B56D0&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99FB8E485A559C410B&quot; filemime=&quot;image/jpeg&quot; filename=&quot;example-recordedallocs-selected.png&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이제, &lt;code&gt;grow&lt;/code&gt; -&amp;gt; &lt;code&gt;createSomeNodes&lt;/code&gt; 로 참조되어 할당된 요소를 보실 수 있습니다. 각 기둥 모양의 그래프에 초점을 맞춰 살펴보면 &lt;code&gt;HTMLDivElement&lt;/code&gt; 생성자가 많이 호출되는 것을 볼 수 있습니다. 전에 살펴보았던 두 스냅샷을 비교하는 메뉴로 돌아가보면 이 &lt;code&gt;HTMLDivElement&lt;/code&gt; 생성자가 많은 할당은 하지만 삭제가 없는 것을 볼 수 있습니다. 즉, GC에서 메모리를 회수하지 않고 지속적으로 할당만 이뤄지고 있는 것입니다. 이는 메모리 누수의 징후를 보여주며, 우리는 이 객체가 어디에 할당되는지 이제 알게 되었습니다(&lt;code&gt;createSomeNodes&lt;/code&gt; 함수). 이제 다시 코드로 돌아가서, 메모리 누수를 야기하는 코드를 고치면 끝입니다.&lt;/p&gt;



&lt;h3 id=&quot;또-다른-유용한-기능&quot;&gt;또 다른 유용한 기능&lt;/h3&gt;

&lt;p&gt;위에서 살펴본 &lt;em&gt;allocation timeline&lt;/em&gt; 메뉴에서 &lt;code&gt;Summary&lt;/code&gt; 외에도 &lt;code&gt;Allocation&lt;/code&gt; 를 선택할 수 있습니다.&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F996912505A559C6012D37B&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/996912505A559C6012&quot; filemime=&quot;image/jpeg&quot; filename=&quot;example-recordedallocs-list.png&quot; height=&quot;461&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이 메뉴는 함수 목록들과 해당 함수와 관련된 메모리 할당들을 보여줍니다. 화면에서 &lt;code&gt;grow&lt;/code&gt; 와 &lt;code&gt;createSomeNodes&lt;/code&gt; 함수가 있는 것을 바로 볼 수 있을 것입니다. 해당 함수들을 클릭하면 해당 함수와 관련된 객체 constructor 목록들을 하단에서 볼 수 있습니다. 위에서 이미 메모리 누수임을 밝혀낸 &lt;code&gt;(string)&lt;/code&gt;, &lt;code&gt;HTMLDivElement&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt; 생성자들도 있음을 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;지금까지 살펴본 도구들을 조합하면 메모리 누수를 찾는데 큰 도움을 받을 수 있습니다. 이제 이 도구들을 가지고 놀아봅시다. 실제 운영 중인 사이트를 프로파일링 해봅시다(자바스크립트 코드를 압축하거나 난독화하지 않는 것이 실습에 도움될 것 입니다). 메모리 누수나 할당되어야 하는 양보다 더 많은 메모리를 차지하는 객체들이 존재하는지 살펴봅시다.&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/194&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>자바스크립트</category>
<category>javascript</category>
<category>memory leak</category>
<category>크롬 개발자 도구</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/194</guid>
<comments>https://itstory.tk/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98%EC%9D%98-4%EA%B0%80%EC%A7%80-%ED%98%95%ED%83%9C#entry194comment</comments>
<pubDate>Wed, 10 Jan 2018 13:54:25 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙56. 일반적으로 통용되는 작명 관습을 따르라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9956-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%86%B5%EC%9A%A9%EB%90%98%EB%8A%94-%EC%9E%91%EB%AA%85-%EA%B4%80%EC%8A%B5%EC%9D%84-%EB%94%B0%EB%A5%B4%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;자바 플랫폼에는 작명 관습(naming convention)이 잘 정립되어 있으며, 그 중 상당수는 자바 언어 명세(The Java Language Specification)에도 언급되어 있다. 간단하게 말해서 자바의 작명 관습은 두 가지 범주로 나눌 수 있다. 철자에 관한 것이 하나고, 문법에 관한 것이 하나다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;철자에 관계된 작명 관습은 패키지, 클래스, 인터페이스, 메서드, 필드 그리고 자료형 변수에 관한 것으로, 그 양이 얼마 되지 않는다. 아주 그럴듯한 이유가 없이 이 규칙을 어겨서는 안된다.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;패키지 이름은 마침표를 구분점으로 사용하는 계층적 이름이어야 한다. 패키지 이름을 구성하는 각각의 컴포넌트는 알파벳 소문자로 구성하고, 숫자는 거의 사용하지 않는다. 여러분의 조직 바깥에서 이용될 패키지 이름은 해당 조직의 인터넷 도메인 이름으로 시작해야 하는데 &lt;em&gt;com.sun&lt;/em&gt;, &lt;em&gt;gov.sna&lt;/em&gt; 처럼 최상위 도메인 이름이 먼저 온다. 패키지 이름의 나머지 부분은 어떤 패키지인지 설명하는 하나 이상의 컴포넌트로 구성된다. 패키지명 컴포넌트는 짧아야 하며, 보통 여덟 문자 이하로 만들어진다. 의미가 확실한 약어를 활용하면 더 좋다.(utilities 대신 util이라고 하면 좋다)&lt;/p&gt;&lt;p&gt;enum이나 어노테이션 자료형 이름을 비롯, 클래스나 인터페이스 이름은 하나 이상의 단어로 구성된다. 각 단어의 첫 글자는 대문자다. &lt;em&gt;Timer&lt;/em&gt;나 &lt;em&gt;FutureTask&lt;/em&gt;가 그 예다. 두문자 또는 max나 min처럼 널리 쓰이는 약어를 제외하면 약어 사용은 피해야 한다. 두문자의 경우 전부 대문자로 써야하는지, 아니면 그 첫 글자만 대문자로 써야 하는지에 대해서는 합의된 것이 별로 없다.&lt;/p&gt;&lt;p&gt;메서드와 필드이름은 클래스나 인터페이스 이름과 동일한 철자 규칙을 따른다. 다만 첫 글자는 소문자로 한다. &lt;em&gt;remove&lt;/em&gt;나 &lt;em&gt;ensureCapacity&lt;/em&gt; 등이 그 예다.&lt;/p&gt;&lt;p&gt;앞서 살펴본 규칙의 유일한 예는 상수 필드(constant field)의 이름을 지을때다. 상수 필드의 이름은 하나 이상의 대문자 단어로 구성되며, 단어 사이에는 밑줄 기호(_)를 둔다. &lt;em&gt;VALUES&lt;/em&gt;나 &lt;em&gt;NEGATIVE_INFINITY&lt;/em&gt;가 그 예다. &lt;/p&gt;&lt;p&gt;지역 변수 이름은 멤버 이름과 같은 철자 규칙을 따르는데, 약어가 허용된다는 것만 다르다. &lt;/p&gt;&lt;p&gt;자료형 인자의 이름은 보통 하나의 대문자다. 가장 널리 쓰이는 것은 다섯 가지로, 임의 자료형인 경우엔 T, 컬렉션 요소 자료형인 경우에는 E, 맵의 키와 값에 대해서는 각각 K와 V, 예외인 경우에는 X를 사용한다. 임의 자료형이 연속되는 경우에는 T, U, V 처럼하거나 T1, T2, T3처럼 나열한다.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
  &lt;th&gt;식별자 자료형&lt;/th&gt;
  &lt;th&gt;예제&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
  &lt;td&gt;패키지&lt;/td&gt;
  &lt;td&gt;com.google.inject, org.joda.time.format&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;클래스나 인터페이스&lt;/td&gt;
  &lt;td&gt;Timer, FutureTask, LinkedHashMap, HttpServlet&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;메서드나 필드&lt;/td&gt;
  &lt;td&gt;remove, ensureCapacity, getCrc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;상수 필드&lt;/td&gt;
  &lt;td&gt;MIN_VALUE, NEGATIVE_INFINITY&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;지역 변수&lt;/td&gt;
  &lt;td&gt;i, xref, houseNumber&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;지료형 인자&lt;/td&gt;
  &lt;td&gt;T, E, K, V, X, T1, T2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;&lt;strong&gt;문법적(grammatical) 작명 관습은 더 가변적일 뿐만 아니라, 철자 관습에 비해 논쟁의 여지가 많다.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;enum 자료형을 비롯한 클래스에는 단수형의 명사나 명사구(noun phrase) 가 이름으로 붙는다. Timer, BufferedWriter, ChessPiece 등이 그 예다. &lt;/p&gt;&lt;p&gt;인터페이스도 클래스와 비슷한 작명 규칙을 따른다. able이나 ible 같은 형용사격 어미가 붙기도 한다. Collection, Comparator, Iterable, Accessible 등이 그 예다.&lt;/p&gt;&lt;p&gt;어떤 동작을 수행하는 메서드는 일반적으로 동사나 동사구(목적어 포함)를 이름으로 갖는다. append나 drawImage 등이 그 예다.&lt;/p&gt;&lt;p&gt;boolean 값을 반환하는 메서드의 이름은 보통 is, 드물게는 has로 시작하고 그 뒤에는 명사나 명사구 또는 형용사나 형용사구가 붙는다. isDigit, isProbablePrime, isEmpty, hasSiblings 등이 그 예다.&lt;/p&gt;&lt;p&gt;boolean 이외의 기능이나 객체 속성을 반환하는 메서드에는 보통 명사나 명사구 또는 get으로 시작하는 동사구를 이름으로 붙인다. size, hashCode, getTime 등이 그런 이름이다. 빈(bean) 클래스에 속한 메서드의 이름은 반드시 get으로 시작해야 한다.&lt;/p&gt;&lt;p&gt;특별히 주의해야 하는 메서드 이름도 있다. 객체의 자료형을 변환하는 메서드, 다른 자료형의 독립적 객체를 반환하는 메서드에는 보통 toType 형태의 이름을 붙인다. toString, toArray 같은 이름이 그 예다.&lt;/p&gt;&lt;p&gt;인자로 전달받은 객체와 다른 자료형의 뷰(view) 객체를 반환하는 메서드(규칙5)에는 asType 형태의 이름을 붙인다. asList 같은 이름이 그 예다.&lt;/p&gt;&lt;p&gt;정적 팩터리 메서드에는 valueOf, of, getInstance, newInstance, getType, newType 같은 이름을 붙인다.(규칙1)&lt;/p&gt;

&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;p&gt;요약하자면, 표준적 작명 관습을 내면화시키고 마치 제2의 천성인 것처럼 사용하라는 것이다. 철자 관습은 직관적이고 모호한 부분도 멸로 없다. 반면 문법적 관습은 좀 더 복잡하고 느슨하다.&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/193&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/193</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9956-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%86%B5%EC%9A%A9%EB%90%98%EB%8A%94-%EC%9E%91%EB%AA%85-%EA%B4%80%EC%8A%B5%EC%9D%84-%EB%94%B0%EB%A5%B4%EB%9D%BC#entry193comment</comments>
<pubDate>Sun, 07 Jan 2018 17:23:32 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙55. 신중하게 최적화하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9955-%EC%8B%A0%EC%A4%91%ED%95%98%EA%B2%8C-%EC%B5%9C%EC%A0%81%ED%99%94%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;모든 프로그래머가 알아둬야 하는 최적화 관련 격언이 세 가지 있다. 너무 많이 봐서 질릴 정도라는 분도 있겠으나, 아직 본 적이 없다면 지금 읽어보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;맹목적인 어리석음(blind stupidity)을 비롯한 다른 어떤 이유보다도, 효율성이라는 이름으로 저질러지는 죄악이 더 많다(효율성을 반드시 성취하는 것도 아니면서 말이다). &lt;br /&gt;- 윌리엄 울프(William A. Wulf)&lt;/p&gt;
  
  &lt;p&gt;작은 효율성(small effiency)에 대해서는, 말하자면 97% 정도에 대해서는, 잊어버려라. 섣부른 최적화는 모든 악의 근원이다. &lt;br /&gt;- 도널드 커누스(Donald E. Knuth)&lt;/p&gt;
  
  &lt;p&gt;최적화를 할 때는 아래의 두 규칙을 따르라. &lt;br /&gt; 규칙1: 하지마라 &lt;br /&gt; 규칙2: (전문가들만 따를 것) 아직은 하지마라 - 완벽히 명료한, 최적화되지 않은 해답을 얻을 때까지는. &lt;br /&gt;- M. A. 잭슨(M. A. Jackson)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 격언들은 자바 언어가 나오기 20년 전에 나온 것들이다. 최적화에 관한 심오한 진리를 잘 보여준다. 최적화는 좋을 때보다 나쁠 때가 더 많으며, 섣불리 시도하면 더더욱 나쁘다는 것이다.&lt;/p&gt;&lt;p&gt;성능 때문에 구조적인 원칙(architectural principle)을 희생하지마라. &lt;strong&gt;빠른 프로그램이 아닌, 좋은 프로그램을 만들려 노력하라.&lt;/strong&gt; 좋은 프로그램인데 충분히 빠르지 않다면, 좋은 구조를 갖추었기 때문에 최적화의 여지도 충분할 것이다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;설계를 할 때는 성능을 제약할 가능성이 있는 결정들을 피하라.&lt;/strong&gt; 설계 가운데 성능에 문제가 있다는 사실이 발견된 후에 고치기가 가장 까다로운 부분은 모듈간 상호작용이나 외부와의 상호작용을 명시하는 부분이다. 이런 부분은 성능 문제가 발견된 후에는 수정하기 어렵거나 수정이 불가능하다. 또한 시스템이 낼 수 있는 성능의 최대치에 큰 영향을 준다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;API를 설계할 때 내리는 결정들이 성능에 어떤 영향을 끼칠지를 생각하라.&lt;/strong&gt; public 자료형을 변경 가능하게 만들면 쓸데없이 방어적 복사를 많이 해야할 수 있다(규칙 39). 마찬가지로 구성(composition) 기법이 적절한 클래스에 계승(inheritance) 기법을 적용하면 해당 클래스는 영원히 상위 클래스에 묶이는데, 그 결과로 하위 클래스의 성능에 인위적인 계약이 가해질 수 도 있다(규칙 16). 또한 인터페이스가 적당할 API에 구현 자료형(implementation type)을 사용해 버리면 해당 API가 특정한 구현에 종속되므로 나중에 더 빠른 구현이 나와도 개선할 수 없게 된다(규칙52).&lt;/p&gt;&lt;p&gt;잘 설계된 API는 일반적으로 좋은 성능을 보인다. &lt;strong&gt;좋은 성능을 내기 위해 API를 급진적으로 바꾸는 것은 바람직하지 않다.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;최적화를 시도할 때마다, 전후 성능을 측정하고 비교하라.&lt;/strong&gt; 측정 결과로 성능이 개선되지 않거나 더 나쁘지는 일이 많기 때문이다.&lt;/p&gt;

&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;p&gt;요약하자면, 빠른 프로그램을 만들고자 애쓰지 말라는 것이다. 대신 좋은 프로그램을 짜기 위해 애쓰라. 성능은 따라올 것이다. 하지만 시스템을 설계할 때, 특히 API나 통신 프로토콜, 또는 지속성 데이터 형식을 설계할 때는 성믄 문제를 따져보라. &lt;/p&gt;&lt;p&gt;시스템 구현을 마쳤다면 그 성능을 측정해 보라. 충분히 빠르면 끝난 것이다. 그렇지 않다면 프로파일링 도구의 도움을 받아서 문제가 되는 것을 알아낸 다음에 최적화하라. 처음으로 해야할 일은 구현에 쓰인 알고리즘을 검토하는 것이다. 저수준 최적화를 아무리 해봐야, 알고리즘을 잘못 골랐다면 성능을 만회할 수 없다. 이 프로세스를 필요한 만큼 반복하고, 최적화 단계별로 성능을 측정하라. 만족스러울 때까지.&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/192&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/192</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9955-%EC%8B%A0%EC%A4%91%ED%95%98%EA%B2%8C-%EC%B5%9C%EC%A0%81%ED%99%94%ED%95%98%EB%9D%BC#entry192comment</comments>
<pubDate>Sun, 07 Jan 2018 15:31:58 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙54. 네이티브 메서드는 신중하게 사용하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9954-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C-%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-%EC%8B%A0%EC%A4%91%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;자바의 네이티브 인터페이스(Java native interface, JNI)는 C나 C++ 등의 native programming language로 작성된 native method를 호출하는 데 이용되는 기능이다. 네이티브 메서드가 수행하는 임의의 계산은 네이티브 언어로 실행되며, 자바 언어로  전달된다.&lt;/p&gt;&lt;p&gt;전통적으로 네이티브 메서드는 세 가지 용도로 쓰였다. 네이티브 메서드를 사용하면 레지스트리(registry)나 파일 락(file lock) 같은 특정 플랫폼에 고유한 기능을 이용할 수 있다.&lt;/p&gt;&lt;p&gt;또한 이미 구현되어 있는 라이브러리를 이용할 수 있으며, 그 라이브러리를 통해 기존 데이터를 활용할 수 있다.&lt;/p&gt;&lt;p&gt;마지막으로, 네이티브 메서드를 사용하면 성능이 중요한 부분의 처리를 네이티브 언어에 맡길 수 있다.&lt;/p&gt;&lt;p&gt;특정 플랫폼에만 있는 기능을 이용하는 데는 네이티브 메서드가 적당하다. 하지만 자바 플랫폼이 발전하면서, 특정 플랫폼에서만 발견할 수 있었던 기능들도 제공되기에 이르렀다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;따라서 네이티브 메서드를 통해 성능을 개선하는 것은 추천하고 싶지 않다.&lt;/strong&gt; 현재 JVM은 훨씬 빠르고 네이티브 메서드 없이도 그에 필적하는 성능을 내는 것이 가능하다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;네이티브 메서드에는 심각한 문제가 있다.&lt;/strong&gt; 네이티브 언어는 안전하지 않으므로(규칙 39), 네이티브 메서드를 이용하는 프로그램은 메모리 훼손 문제(memory corruption error)로부터 자유로울 수 없다. 게다가 네이티브 언어는 플랫폼 종속적이므로 이식성이 낮다.&lt;/p&gt;&lt;p&gt;또한 네이티브 코드를 사용하는 프로그램은 디버깅하기도 훨씬 어렵다. 네이티브 코드를 넘나드는데 필요한 기본적인 비용 때문에, 네이티브 메서드가 하는 일이 별로 없다면 오히려 성능을 떨어뜨릴 수도 있다. 게다가 네이티브 메서드를 사용하려면 이해하기도 어렵고 작성하기도 난감한 적찹코드(glue code)를 작성해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;p&gt;네이티브 메서드를 사용하는 것은 재고하라. 그럴 일이 있을지는 모르겠으나 굳이 그래야 한다면, 성능 개선 용도로만 써라. 저수준(low-level) 자원이나 기존 라이브러리(legacy library)를 이용하기 위해 네이티브 메서드를 사용해야 한다면, 네이티브 코드는 가능하면 줄이고 광범위한 테스트를 거치기 바란다. 네이티브 코드에 있는 아주 작은 버그라도 시스템 전체를 훼손시킬 수 있다.&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/191&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/191</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9954-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C-%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-%EC%8B%A0%EC%A4%91%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC#entry191comment</comments>
<pubDate>Sun, 07 Jan 2018 14:49:01 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙53. 리플렉션 대신 인터페이스를 이용하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9953-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98-%EB%8C%80%EC%8B%A0-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;java.lang.reflect의 핵심 리플렉션 기능(core reflection facility)을 이용하면 메모리에 적재된 클래스의 정보를 가져오는 프로그램을 작성할 수 있다. 하지만 이런 능력에는 대가가 따른다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;컴파일 시점에 자료형을 검사함으로써 얻을 수 있는 이점들을 포기해야 한다(exception checking 포함). 리플렉션을 통해 존재하지 않는, 또는 접근할 수 없는 메서드를 호출하면 실행 도중에 오류가 발생할 것이다. 그러니 특별히 주의해야 한다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;리플레션 기능을 이용하는 코드는 보기 싫은데다 장황하다. 영리한 코드와는 거리가 멀고, 가독성도 떨어진다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;성능이 낮다. 리플렉션을 통한 메서드 호출 성능은, 일반적인 메서드 호출에 비해 훨씬 낮다. 얼마나 낮은지 정확히 말하기는 어렵다. 고려해야할 조건들이 다양하기 때문.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;핵심 리플렉션 기능은 원래 컴포넌트 기반 응용프로그램 저작 도구(component-based application builder tool)를 위해 설계된 기능이었다. 그런 도구는 보통 요청에 따라 클래스를 메모리에 올린 다음, 리플렉션 기능을 통해 어떤 메서드와 생성자가 지원되는지를 알아낸다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;명심할 것은, 일반적인 프로그램은 프로그램 실행 중에 리플렉션을 통해 객체를 이용하려 하면 안된다는 것이다. 하지만 리플렉션을 아주 제한적으로만 사용하면 오버헤드는 피하면서 리플렉션의 다양한 장점을 누릴 수 있다.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;컴파일 시점에는 존재하지 않는 클래스를 이용해야 하는 프로그램 가운데 상당수는 해당 클래스 객체를 참조하는데 사용할 수 있는 인터페이스나 상위 클래스(규칙 52)를 컴파일 시점에 이미 갖추고 있는 경우가 많다. 그럴 때는, &lt;strong&gt;객체 생성은 리플렉션으로 하고 객체 참조는 인터페이스나 상위 클래스를 통하면 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java hljs &quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 객체 생성은 리플렉션으로, 참조와 사용은 인터페이스로&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(String[] args) {
    &lt;span class=&quot;hljs-comment&quot;&gt;// 클래스 이름을 Class 객체로 변환&lt;/span&gt;
    Class&amp;lt;?&amp;gt; cl = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;

    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
        cl = Class.forName(args[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]);
    } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt;(ClassNotFoundException e) {
        System.err.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Class not found.&quot;&lt;/span&gt;);
        System.exit(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
    }

    &lt;span class=&quot;hljs-comment&quot;&gt;// 해당 클래스의 객체 생성&lt;/span&gt;
    Set&amp;lt;String&amp;gt; s = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;

    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
        s = (Set&amp;lt;String&amp;gt;) cl.newInstance();
    } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt;(IllegalAccessException e) {
        System.err.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Class not accessible.&quot;&lt;/span&gt;);
        System.exit(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
    } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt;(InstantiationException e) {
        System.err.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Class not instantiable.&quot;&lt;/span&gt;);
        System.exit(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
    }

    &lt;span class=&quot;hljs-comment&quot;&gt;// Set 이용&lt;/span&gt;
    s.addAll(Arrays.asList(args).subList(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, args.length));
    System.out.println(s);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;장난감에 불과한 프로그램이지만, 사용한 기술은 아주 강력하다. 이 프로그램은 하나 이상의 객체를 공격적으로 조작하여 해당 구현이 Set의 일반 규약을 준수하는지 검증하는 일반적 집합 검사 도구(generic set tester)로 쉽게 변경될 수 있다.&lt;/p&gt;&lt;p&gt;한편 이 예제는 리플렉션의 두 가지 단점도 보여준다.&lt;/p&gt;&lt;p&gt;첫번째로 이 예제는 세가지 실행시점 오류(runtime error)를 발생시키는데, 리플렉션으로 객체를 만들지 않았더라면 컴파일 시점에 검사할 수 있는 오류들이다.&lt;/p&gt;&lt;p&gt;두번째로 이 예제는 이름에 대응하는 클래스의 객체를 생성하기 위해 스무줄 가량의 멍청한 코드를 사용하고 있는데, 생성자를 호출로 대신했으면 한 줄이면 되었을 코드다.&lt;/p&gt;&lt;p&gt;하지만 이런 문제는 객체를 만드는 부분에섬나 나타난다. 객체가 만들어지고 나면 다른 Set 객체와 분간할 수 없다.&lt;/p&gt;



&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;p&gt;리플렉션은 특정한 종류의 복잡한 시스템 프로그래밍에 필요한 강력한 도구다. 하지만 단점이 많다. 컴파일 시점에는 알 수 없는 클래스를 이용하는 프로그램을 작성하고 있다면, 리플렉션을 사용하되 가능하면 객체를 만들 때만 사용하고, 객체를 참조할 때는 컴파일 시 알고 있는 인터페이스나 상위 클래스를 이용하라.&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/190&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/190</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9953-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98-%EB%8C%80%EC%8B%A0-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EB%9D%BC#entry190comment</comments>
<pubDate>Sun, 07 Jan 2018 14:34:04 +0900</pubDate>
</item>
<item>
<title>[이펙트 자바] 규칙52. 객체를 참조할 때는 그 인터페이스를 사용하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8A%B8-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9952-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%B0%B8%EC%A1%B0%ED%95%A0-%EB%95%8C%EB%8A%94-%EA%B7%B8-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;만일 적당한 인터페이스 자료형이 있다면 인자나 반환값, 변수 그리고 필드의 자료형은 클래스 대신 인터페이스로 선언하자.&lt;/strong&gt; 아래와 같은 타이핑하는 습관을 들이는 것이 좋다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java hljs &quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 인터페이스를 자료형으로 사용하고 있는 바람직한 예제&lt;/span&gt;
List&amp;lt;Subscriber&amp;gt; subscribers = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Vector&amp;lt;Subscriber&amp;gt;();&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java hljs &quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 클래스를 자료형으로 사용하는 나쁜 예제&lt;/span&gt;
Vector&amp;lt;Subscriber&amp;gt; subscribers = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Vector&amp;lt;Subscriber&amp;gt;();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;인터페이스를 자료형으로 쓰는 습관을 들이면 프로그램은 더욱 유연해진다.&lt;/strong&gt; 가령 성능 개선, 기능 추가 등의 이유로 객체의 실제 구현을 다른 것으로 바꿀 때 유연하게 바꿔치기할 수가 있다.&lt;/p&gt;&lt;p&gt;물론 적당한 인터페이스가 없는 경우에는 객체를 클래스로 참조하는 것이 당연하다.&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/189&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/189</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8A%B8-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9952-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%B0%B8%EC%A1%B0%ED%95%A0-%EB%95%8C%EB%8A%94-%EA%B7%B8-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC#entry189comment</comments>
<pubDate>Sat, 06 Jan 2018 22:51:27 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙51. 문자열 연결 시 성능에 주의하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9951-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%97%B0%EA%B2%B0-%EC%8B%9C-%EC%84%B1%EB%8A%A5%EC%97%90-%EC%A3%BC%EC%9D%98%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;문자열 연결(concatenation) 연산자 +는 여러 문자열을 하나로 합하는 편리한 수단이다. 하지만 n개의 문자열에 연결 연산자를 반복 적용해서 연결하는데 드는 시간은 n^2에 비례한다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java hljs &quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;statement&lt;/span&gt;() {
    String result = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; numItems(); i++) {
        result += lineForItem(i);   &lt;span class=&quot;hljs-comment&quot;&gt;// String concatenation&lt;/span&gt;
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; result;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만족스런 성능을 얻으려면 String 대신 StringBuiler를 써야된다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java hljs &quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;statement&lt;/span&gt;() {
    StringBuilder b = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StringBuilder(numItems() * LINE_WIDTH);
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; numItems(); i++) {
        b.append(lineForItem(i));
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; b.toString();
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;(JDK 1.5 부터는 String을 사용하더라도 컴파일 시 내부적으로 StringBuilder로 변경되어 성능차이가 없어졌습니다.)&lt;/strong&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/188&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/188</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9951-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%97%B0%EA%B2%B0-%EC%8B%9C-%EC%84%B1%EB%8A%A5%EC%97%90-%EC%A3%BC%EC%9D%98%ED%95%98%EB%9D%BC#entry188comment</comments>
<pubDate>Sat, 06 Jan 2018 22:40:59 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙50. 다른 자료형이 적절하다면 문자열 사용은 피하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9950-%EB%8B%A4%EB%A5%B8-%EC%9E%90%EB%A3%8C%ED%98%95%EC%9D%B4-%EC%A0%81%EC%A0%88%ED%95%98%EB%8B%A4%EB%A9%B4-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%82%AC%EC%9A%A9%EC%9D%80-%ED%94%BC%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;문자열은 텍스트 표현과 처리에 걸맞도록 설계되었다. 그런데 문자열은 워낙 흔한 데다 자바의 문자열 지원도 아주 훌륭하기 때문에 원래 설계된 목적 외의 용도로 많이 활용하는 경향이 있다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;문자열은 값 자료형(value type)을 대신하기에 부족하다.&lt;/strong&gt; 적절한 값 자료형이 있다면 그것이 기본 자료형이건 아니면 객체 자료형이건 상관없이 해당 자료형을 사용해야 한다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;문자열은 enum 자료형을 대신하기에는 부족하다.&lt;/strong&gt; enum은 문자열보다 훨씬 좋은 열거 자료형 상수들을 만들어 낸다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;문자열은 혼합 자료형(aggregate type)을 대신하기엔 부족하다.&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java hljs &quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 문자열을 혼합 자료형으로 써먹은 부적절한 사례&lt;/span&gt;
String compoundKey = className + &lt;span class=&quot;hljs-string&quot;&gt;&quot;#&quot;&lt;/span&gt; + i.next();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;문자열은 권한(capability)을 표현하기엔 부족하다.&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java hljs &quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 문자열 권한으로 사용하는 잘못된 예제&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ThreadLocal&lt;/span&gt; {&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ThreadLocal&lt;/span&gt;() {}

    &lt;span class=&quot;hljs-comment&quot;&gt;// 주어진 이름이 가리키는 스레드 지역 변수의 값 설정&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;set&lt;/span&gt;(String key, Object value);

    &lt;span class=&quot;hljs-comment&quot;&gt;// 주어진 이름이 가리키는 스레드 지역 변수의 값 반환&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; Object &lt;span class=&quot;hljs-title&quot;&gt;get&lt;/span&gt;(String key);
}&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java hljs &quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 다음과 같이 변경하자&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ThreadLocal&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt; {&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ThreadLocal&lt;/span&gt;();
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;set&lt;/span&gt;(T value);
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; T &lt;span class=&quot;hljs-title&quot;&gt;get&lt;/span&gt;();
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/187&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/187</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9950-%EB%8B%A4%EB%A5%B8-%EC%9E%90%EB%A3%8C%ED%98%95%EC%9D%B4-%EC%A0%81%EC%A0%88%ED%95%98%EB%8B%A4%EB%A9%B4-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%82%AC%EC%9A%A9%EC%9D%80-%ED%94%BC%ED%95%98%EB%9D%BC#entry187comment</comments>
<pubDate>Sat, 06 Jan 2018 22:32:43 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙49. 객체화된 기본 자료형 대신 기본 자료형을 이용하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9949-%EA%B0%9D%EC%B2%B4%ED%99%94%EB%90%9C-%EA%B8%B0%EB%B3%B8-%EC%9E%90%EB%A3%8C%ED%98%95-%EB%8C%80%EC%8B%A0-%EA%B8%B0%EB%B3%B8-%EC%9E%90%EB%A3%8C%ED%98%95%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;모든 기본 자료형에는 대응되는 참조 자료형이 있는데, 이를 &lt;strong&gt;객체화된 기본 자료형(boxed primitive type)&lt;/strong&gt; 이라 부른다. int, double, boolean의 객체화된 기본 자료형은 각각 Integer, Double, Boolean이다.&lt;/p&gt;&lt;p&gt;릴리스 1.5부터 자동 객체화(autoboxing)와 지동 비객체화(auto-unboxing)가 언어의 일부가 되었다. 이 기능들은 기본 자료형과 그 객체 표현형 간의 차이를 희미하게 만든다.&lt;/p&gt;&lt;p&gt;그런데 그 둘 사이에는 실질적인 차이가 있으므로, 둘 가운데 무엇을 사용하고 있는지를 아는 것이 중요하며, 어떤 것을 사용할지 신중하게 결정해야 한다.&lt;/p&gt;&lt;p&gt;기본 자료형과 객체화된 기본 자료형 사이에는 세 가지 큰 차이점이 있다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;기본 자료형은 값만 가지지만 객체화된 기본 자료형은 값 외에도 신원(identity)을 가진다는 것이다.&lt;/strong&gt; 따라서 객체화된 기본 자료형 객체가 두 개 있을 때, 그 값은 같더라도 신원은 다를 수 있다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;기본 자료형에 저장되는 값은 전부 기능적으로 완전한 값(fully functional value)이지만, 객체화된 기본 자료형에 저장되는 값에는 그 이외에 아무 기능도 없는 값, 즉 null이 하나 있다는 것이다.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;기본 자료형은 시간이나 공간 요구량 측면에서 일반적으로 객체 표현형보다 효율적이라는 것이다.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;주의하지 않으면 이런 차이 때문에 곤란을 겪게 될 것이다. 관련 예제들을 살펴보자.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;Comparator&amp;lt;Integer&amp;gt; naturalOrder = new Comparator&amp;lt;Integer&amp;gt;() {
    public int compare(Integer first, Integer second) {
        return first &amp;lt; second ? -1 : (first == second ? 0 : 1);
    }
}

naturalOrder.compare(new Integer(42), new Integer(43)); // 1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 예에서, 두 Integer 객체는 42라는 동일한 값을 나타내므로, 반환 값은 0이 되어야 하지만 실제 반환되는 값은 1이다. 연산자 ==는 객체 참조를 통해 두 객체의 신원을 비교하기 때문이다. &lt;strong&gt;객체화된 기본 자료형에 == 연산자를 사용하는 것은 거의 항상 오류라고 봐야한다.&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;Comparator&amp;lt;Integer&amp;gt; naturalOrder = new Comparator&amp;lt;Integer&amp;gt;() {
    public int compare(Integer first, Integer second) {
        int f = first; // Auto-unboxing
        int s = second; // Auto-unboxing
        return first &amp;lt; second ? -1 : (first == second ? 0 : 1); // No unboxing
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같이 지역 int 변수를 통해 문제가 되는 신원 비교를 피할 수 있다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public class Unbelievable {
    static Integer i;

    public static void main(String[] args) {
        if (i == 42) {
            System.out.println(&quot;Unbelievable&quot;);
        }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 프로그램은 Unbelievable을 출력하지 않고 NullPointerException을 발생시킨다. 거의 모든 경우에, 기본 자료형과 객체화된 기본 자료형을 한 연산 안에 엮어 놓으면 객체화된 기본 자료형은 자동으로 기본 자료형으로 변환한다. null인 객체 참조를 기본 자료형으로 변환하려 시도하면 NullPointerException이 발생한다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
    Long sum = 0L;
    for (long i = 0; i &amp;lt; Integer.MAX_VALUE; i++) {
        sum += i;
    }
    System.out.println(sum);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 프로그램은 예상보다 훨씬 더 느리다. 오류나 경고 없이 컴파일되는 프로그램이지만 변수가 계속해서 객체화와 비객체화를 반복하기 때문에 성능이 느려진다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;그렇다면 객체화된 기본 자료형은 언제 사용해야 하나?&lt;/strong&gt; 컬렌션의 요소, 키 값으로 사용할 때다. 컬렉션에는 기본 자료형을 넣을 수 없으므로 객체화된 자료형을 써야 한다. 또한 형인자 자료형의 형인자로는 객체화된 기본 자료형을 써야한다는 일반 규칙의 특수한 형태다.&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/186&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/186</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9949-%EA%B0%9D%EC%B2%B4%ED%99%94%EB%90%9C-%EA%B8%B0%EB%B3%B8-%EC%9E%90%EB%A3%8C%ED%98%95-%EB%8C%80%EC%8B%A0-%EA%B8%B0%EB%B3%B8-%EC%9E%90%EB%A3%8C%ED%98%95%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EB%9D%BC#entry186comment</comments>
<pubDate>Sat, 06 Jan 2018 17:25:36 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙48. 정확한 답이 필요하다면 float와 double은 피하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9948-%EC%A0%95%ED%99%95%ED%95%9C-%EB%8B%B5%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%98%EB%8B%A4%EB%A9%B4-float%EC%99%80-double%EC%9D%80-%ED%94%BC%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;float와 double은 기본적으로 과학 또는 엔지니어링 관련 계산에 쓰일 목적으로 설계된 자료형이다. &lt;/p&gt;&lt;p&gt;이 자료형들은 &lt;em&gt;이진 부동 소수점 연산(binary floating-point arithmetic)&lt;/em&gt; 을 수행하는데, 이것은 넓은 범위의 값(magnitude)에 대해 정확도가 높은 근사치를 제공할 수 있도록 세심하게 설계된 연산이다. 하지만 정확한 결과를 제공하지는 않기 때문에 정확한 결과가 필요한 곳에는 사용하면 안 된다. &lt;/p&gt;&lt;p&gt;&lt;strong&gt;float와 double은 특히 돈과 관계된 계산에는 적합하지 않다.&lt;/strong&gt; 돈 계산을 할 때는 BigDecimal, int 또는 long을 사용한다는 원칙을 지켜야 한다.&lt;/p&gt;&lt;p&gt;하지만 BigDecimal을 쓰는 방법에는 두 가지 문제가 있다. 기본 산술연산 자료형(primitive arithmetic type)보다 사용이 불편하며, 느리다. 대안으로 int나 long을 사용할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;관계된 수치들이 신진수 아홉 개 이하로 표현이 가능할 때는 int를 쓰라. 18개 이하로 표현 가능할 때는 long을 쓰라. 그 이상일 때는 BigDecimal을 써야 한다.&lt;/strong&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/185&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/185</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9948-%EC%A0%95%ED%99%95%ED%95%9C-%EB%8B%B5%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%98%EB%8B%A4%EB%A9%B4-float%EC%99%80-double%EC%9D%80-%ED%94%BC%ED%95%98%EB%9D%BC#entry185comment</comments>
<pubDate>Sat, 06 Jan 2018 16:21:10 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙47. 어떤 라이브러리가 있는지 파악하고, 적절히 활용하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9947-%EC%96%B4%EB%96%A4-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EA%B0%80-%EC%9E%88%EB%8A%94%EC%A7%80-%ED%8C%8C%EC%95%85%ED%95%98%EA%B3%A0-%EC%A0%81%EC%A0%88%ED%9E%88-%ED%99%9C%EC%9A%A9%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;표준 라이브러리(standard library)를 사용하면 그 라이브러리를 개발한 전문가의 지식뿐만 아니라 여러분보다 먼저 그 라이브러리를 사용한 사람들의 경험을 활용할 수 있다. 실제로 하려는 일과 큰 관련성도 없는 문제에 대한 해결 방법을 임의로 구현하느라 시간을 낭비하지 않아도 된다는 것이다.&lt;/p&gt;&lt;p&gt;또한 별다른 노력을 하지 않아도 그 성능이 점차로 개선되며, 시간이 흐르면 새로운 기능들도 추가된다. &lt;/p&gt;&lt;p&gt;아울러 표준 라이브러리를 사용하면 주류(mainstream) 개발자들과 같은 코드를 만들게 된다. 그런 코드는 가독성이 높고, 유지보수가 쉬우며, 다른 개발자들이 재사용하기도 좋다.&lt;/p&gt;&lt;p&gt;중요한 새 릴리스(new major releas)가 나올 때마다 많은 기능이 새로 추가되는데, 그때마다 어떤 것들이 추가되었는지를 알아두는 것이 좋다. 자바 프로그래머라면 java.lang, java.util 안에 있는 내용은 잘 알고 있어야 하며, java.io의 내용도 어느 정도 알고 있어야 한다.&lt;/p&gt;&lt;p&gt;때로 라이브러리가 제공하는 기능이 만족스럽지 않을 때가 있다. 원하는 기능이 구체적일수록 그런 일이 자주 생긴다. 라이브러리에 담긴 기능을 우선적으로 고려해야 한다는 것은 맞지만, 그것이 원하는 기능을 구현하기에 충분치 않다면 대안을 찾아봐야 한다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;요약하자면, 바퀴를 다시 발명하지 말라는 것이다.&lt;/strong&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/184&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/184</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9947-%EC%96%B4%EB%96%A4-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EA%B0%80-%EC%9E%88%EB%8A%94%EC%A7%80-%ED%8C%8C%EC%95%85%ED%95%98%EA%B3%A0-%EC%A0%81%EC%A0%88%ED%9E%88-%ED%99%9C%EC%9A%A9%ED%95%98%EB%9D%BC#entry184comment</comments>
<pubDate>Sat, 06 Jan 2018 16:07:02 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙46. for 문보다는 for-each 문을 사용하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9946-for-%EB%AC%B8%EB%B3%B4%EB%8B%A4%EB%8A%94-foreach-%EB%AC%B8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;릴리스 1.5 전에는 컬렉션을 순회할 때 아래의 숙어를 따르는 것이 바람직했다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 컬렉션 순회를 위해 한동안 많이 썼던 숙어
for (Iterator i = c.iterator(); i.hasNext();) {
    doSomething((Element) i.next());
}

// 배열을 순회할 때 한동안 많이 사용한 숙어
for (int i = 0; i &amp;lt; a.length; i++) {
    doSomething(a[i]);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;릴리스 1.5부터 도입된 for-each 문은 성가신 코드를 제거하고 반복자나 첨자 변수를 완전히 제거해서 오류 가능성을 없앤다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 컬렉션이나 배열을 순회할 때는 이 숙어를 따르자
for (Element e : elements) {
    doSomething(e);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for-each 문의 장점은 여러 컬렉션에 중첩되는 순환문을 만들어야 할 때 더 빛난다. for-each 문으로는 컬렉션과 배열뿐 아니라 Iterable 인터페이스를 구현하는 어떤 객체도 순회할 수 있다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public interface Iterable&amp;lt;E&amp;gt; {
    // 이 Iterable 안에 있는 원소들에 대한 반복자 반환
    Iterator&amp;lt;E&amp;gt; iterator();
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;요약하자면, for-each 문은 전통적인 for 문에 비해 명료하고 버그 발생 가능성도 적으며, 성능도 for 문에 뒤지지 않는다. 그러니 가능하면 항상 사용해야 한다. 그러나 불행히도 아래의 세 경우에 대해서는 for-each 문을 적용할 수 없다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;필터링(filtering) - 컬렉션을 순회하다가 특정 원소를 삭제할 필요가 있다면, 반복자를 명시적으로 사용해야 한다. 반복자의 remove 메서드를 호출해야 하기 때문이다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;변환(transforming) - 리스트나 배열을 순회하다가 그 원소 가운데 일부 또는 전부의 값을 변경해야 한다면, 원소의 값을 수정하기 위해서 리스트 반복자나 배열 첨자가 필요하다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;병렬 순회(parallel iteration) - 여러 컬렉션을 병렬적으로 순회해야 하고, 모든 반복자나 첨자 변수가 발맞춰 나아가도록 구현해야 한다면 반복자나 첨자 변수를 명시적으로 제어할 필요가 있을 것이다.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/183&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/183</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9946-for-%EB%AC%B8%EB%B3%B4%EB%8B%A4%EB%8A%94-foreach-%EB%AC%B8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC#entry183comment</comments>
<pubDate>Sat, 06 Jan 2018 15:41:01 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙45. 지역 변수의 유효범위를 최소화하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9945-%EC%A7%80%EC%97%AD-%EB%B3%80%EC%88%98%EC%9D%98-%EC%9C%A0%ED%9A%A8%EB%B2%94%EC%9C%84%EB%A5%BC-%EC%B5%9C%EC%86%8C%ED%99%94%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;지역 변수의 유효범위를 최소화하면 가독성(readability)과 유지보수성(maintainability)이 좋아지고, 오류 발생 가능성도 줄어든다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;지역 변수의 유효범위를 최소화하는 가장 강력한 기법은, 처음으로 사용하는 곳에서 선언하는 것이다.&lt;/strong&gt; 사용하기 전에 선언하면 프로그램의 의도를 알고자 소스 코드를 읽는 사람만 혼란스럽게 할 뿐이다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;거의 모든 지역 변수 선언에는 초기값(initializer)이 포함되어야 한다.&lt;/strong&gt; 변수를 적절히 초기화하기에 충분한 정보가 없다면, 그때까지는 선언을 미뤄야 한다.&lt;/p&gt;&lt;p&gt;지역 변수의 유효범위를 최소화하는 숙어를 하나 살펴보면,&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;for (int i = 0, n = expensiveComputation(); i &amp;lt; n; i++) {
    doSomething(i);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;두 번째 변수 n은 i 값의 범위를 제한하는 용도로 쓰이고 있는데, 그 값을 계산하는 비용이 꽤 크다면, 미리 계산해 두고 사용하면 매번 재계산할 필요가 없다.&lt;/p&gt;&lt;p&gt;지역 변수의 유효범위를 최소화하는 마지막 전략은 메서드의 크기를 줄이고 특정한 기능에 집중하라는 것이다. 두 가지 서로 다른 기능을 한 메서드 안에 넣어두면 한 가지 기능을 수행하는데 필요한 지역 변수의 유효범위가 다른 기능까지 확장되는 문제가 생길 수 있다.&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/182&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/182</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9945-%EC%A7%80%EC%97%AD-%EB%B3%80%EC%88%98%EC%9D%98-%EC%9C%A0%ED%9A%A8%EB%B2%94%EC%9C%84%EB%A5%BC-%EC%B5%9C%EC%86%8C%ED%99%94%ED%95%98%EB%9D%BC#entry182comment</comments>
<pubDate>Sat, 06 Jan 2018 15:00:05 +0900</pubDate>
</item>
<item>
<title>[JavaScript] 4. 함수와 프로토타입 체이닝 (1) - 함수란</title>
<link>https://itstory.tk/entry/4-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B4%EB%8B%9D-1</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=213715769&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/5/7/6/9/213715769h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=213715769&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;인사이드 자바스크립트&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 고현준,송형주&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 한빛미디어 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.01.02&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=213715769&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;함수-정의&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;/span&gt;&lt;br /&gt;함수 정의&lt;/h2&gt;

&lt;p&gt;자바스크립트에서 함수를 생성하는 방법은 3가지가 있다. 이들 방식은 모두 같은 함수를 생성하지만, 각각의 방식에 따라 함수 동작이 미묘하게 차이가 난다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;함수 선언문(function statement)&lt;/li&gt;
&lt;li&gt;함수 표현식(function expression)&lt;/li&gt;
&lt;li&gt;Function() 생성자 함수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;함수 선언문이나 함수 표현식 방법은 함수 리터럴 방식으로 함수를 생성한다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1. 함수 선언문 방식&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function add(x, y) {
    return x + y;
}

console.log(add(3, 4)); // 7&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. 함수 표현문 방식&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var add = function (x, y) {
    return x + y;
}

var plus = add;

console.log(add(3, 4)); // 7
console.log(plus(5, 6)); // 11&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;함수 표현식에서 사용된 함수 이름은 정의된 함수 내부에서 재귀적으로 호출하거나, 디버거 등에서 함수를 구분할 때 사용되며 외부 코드에서 접근이 불가능 하다. &lt;strong&gt;함수 선언문&lt;/strong&gt; 형식으로 정의된 add() 함수는 자바스크립트 엔진에 의해 다음과 같이 함수 표현식 형태로 변경된다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 익명 함수 표현식(기명 함수도 가능)
var add = function add(x, y) {
    return x + y;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3. Function() 생성자 함수 방식&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var add = new Function('x', 'y', 'return x + y');

console.log(add(3, 4)); // 7&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;함수 선언문이나 함수 표현식 방식도 결국 내부적으로는 Fuction() 생성자 함수로 함수가 생성된다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;함수 호이스팅&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;위에서 살펴본 함수를 생성하는 3가지 방식(함수 선언문, 함수 표현식, 생성자 함수) 사이에는 약간씩 차이가 있다. 그 중의 하나가 함수 호이스팅(Function Hoisting) 이다.&lt;/p&gt;&lt;p&gt;자바스크립트 Guru로 알려진 더글라스 크락포드는 함수 생성에 있어서 그의 저서 더글라스 크락포드의 자바스크립트 핵심가이드 에서 함수 호이스팅은 코드의 구조를 엉성하게 만들 수도 있다고 지적하며, &lt;strong&gt;함수 표현식만을 사용할 것을 권하고 있다.&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;add(2, 3); //5

// 함수 선언문 형태로 add() 함수 정의
function add(x, y) {
    return x + y;
}

add(3, 4); //7&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 예제처럼 함수가 자신이 위치한 코드에 상관없이 &lt;strong&gt;함수 선언문 형태로 정의한 함수의 유효 범위는 코드의 맨 처음부터 시작한다.&lt;/strong&gt; 이것을 &lt;strong&gt;함수 호이스팅&lt;/strong&gt;이라고 부른다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;add(2, 3); // uncaught type error

// 함수 표현식 형태로 add() 함수 정의
var add = function(x, y) {
    return x + y;
}

add(3, 4); // 7&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 예제는 함수 표현식 형태로 정의되어 있어 호이스팅이 일어나지 않는다. 이러한 함수 호이스팅이 발생하는 원인은 &lt;strong&gt;자바스크립트의 변수 생성(Instantiation) 과 초기화(Initialization) 의 작업이 분리돼서 진행&lt;/strong&gt;되기 때문이다(chap5에서 다룸).&lt;/p&gt;

&lt;h2 id=&quot;함수-객체-함수도-객체다&quot;&gt;함수 객체: 함수도 객체다&lt;/h2&gt;

&lt;p&gt;자바스크립트에서 함수도 객체이므로 일반 객체처럼 취급될 수 있다. 또한 함수는 다음과 같은 동작이 가능하다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;리터럴에 의해 생성&lt;/li&gt;
&lt;li&gt;변수나 배열의 요소, 객체의 프로퍼티 등에 할당 가능&lt;/li&gt;
&lt;li&gt;함수의 인자로 전달 가능&lt;/li&gt;
&lt;li&gt;함수의 리턴값으로 리턴 가능&lt;/li&gt;
&lt;li&gt;동적으로 프로퍼티를 생성 및 할당 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이와 같은 특징이 있으므로 자바스크립트에서는 함수를 일급 객체 라고 부르며, 이런 특성으로 함수형 프로그래밍이 가능하다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 함수 선언 방식응로 add() 함수 정의
function add(x, y) {
    return x + y;
}

add.result = add(2, 3);
add.status = 'OK';

console.log(add.result); // 5
console.log(add.status); // 'OK'&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 예제는 함수에 동적으로 프로퍼티를 생성할 수 있다는 것을 보여준다. &lt;strong&gt;함수 코드는 함수 객체의 [[Code]] 내부 프로퍼티 에 자동으로 저장된다(ECMAScript 명세).&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;함수는 일반 객체와는 다르게 추가로 함수 객체만의 표준 프로퍼티가 정의되어 있다. ECMA5 스크립트 명세서에는 &lt;strong&gt;모든 함수가 length와 prototype 프로퍼티를 가져야 한다고&lt;/strong&gt; 기술하고 있다. 그 외에 name, caller, arguments, __proto__ 프로퍼티가 있으나 이들은 ECMA 표준이 아니다. ECMA 표준에서는 arguments 프로퍼티와 같은 이름으로 arguments 객체를 정의하고 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;name : 함수의 이름&lt;/li&gt;
&lt;li&gt;caller : 자신을 호출한 함수&lt;/li&gt;
&lt;li&gt;arguments : 함수를 호출할 때 전달된 인자값&lt;/li&gt;
&lt;li&gt;__proto__ : 객체 자신이 가리키는 프로토타입&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모든 함수들의 부모 객체는 Function Prototype 객체이다. 그런데 ECMA 명세서에는 Function.prototype도 역시 함수라고 정의하고 있다. 대신, 예외적으로 Function.prototype 함수 객체의 부모는 자바스크립트의 모든 객체의 조상격인 Object.prototype 객체라고 설명하고 있다. Function.prototype 객체가 가지는 프로퍼티나 메서드는 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;constructor 프로퍼티&lt;/li&gt;
&lt;li&gt;toString() 메서드&lt;/li&gt;
&lt;li&gt;apply(thisArg, argArray) 메서드&lt;/li&gt;
&lt;li&gt;call(thisArg, [,arg1 [,arg2, ]]) 메서드&lt;/li&gt;
&lt;li&gt;bind(thisArg, [,arg1 [,arg2, ]]) 메서드&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;함수 객체의 length 프로퍼티는 앞서 설명했듯이 ECMAScript에서 정한 모든 함수가 가져야 하는 표준 프로퍼티로서, 함수가 정상적으로 실행될 때 기대되는 인자의 개수를 나타낸다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function func0() {}
function func1(x) { return x; }
function func2(x, y) { return x + y; }
function func3(x, y, z) { return x + y + z; }

console.log(func0.length); // 0
console.log(func1.length); // 1
console.log(func2.length); // 2
console.log(func3.length); // 3&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;모든 객체에 있는 내부 프로퍼티인 [[Prototype]]는 객체 입장에서 자신의 부모 역할을 하는 프로토타입 객체를 가리키는 반면에, 함수 표준 prototype 프로퍼티는 이 함수가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 프로토타입 객체를 가리킨다.&lt;/p&gt;&lt;p&gt;prototype 프로퍼티는 함수가 생성될 때 만들어지며, constructor 프로퍼티 하나만 있는 객체를 가리킨다. 그리고 constructor 프로퍼티는 자신과 연결된 함수를 가리킨다. 즉, 자바스크립트에서는 함수를 생성할 때, 함수 자신과 연결된 프로토타입 객체를 동시에 생성하며, 이 둘은 prototype과 constructor라는 프로퍼티로 서로를 참조하게 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;함수의 prototype 프로퍼티가 가리키는 프로토타입 객체는 일반적으로 따로 네이밍하지 않고, 자신과 연결된 함수의 prototype 프로퍼티 값을 그대로 이용한다. 가령 add() 함수의 프로토타입 객체는 add.prototype이 된다.&lt;/p&gt;
&lt;/blockquote&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function myFunction() {
    return true;
}

console.dir(myFunction.prototype); // myFunction 함수의 프로토타입 객체
console.dir(myFunction.prototype.constructor); // myFunction 함수&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;지금까지의 내용을 도식화하면 다음과 같다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:761px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F99579D415AA8E76E1243AF&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99579D415AA8E76E12&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Untitled_Diagram_xml_-_draw_io.jpg&quot; height=&quot;391&quot; style=&quot;&quot; width=&quot;761&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;



&lt;h2 id=&quot;함수의-다양한-형태&quot;&gt;함수의 다양한 형태&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1. 콜백 함수&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;자바스크립트 함수 표현식에서 함수 이름은 꼭 붙이지 않아도 되는 선택 사항이다. 이러한 익명 함수의 대표적인 용도가 바로 콜백 함수이다. 대표적인 콜백 함수의 사용의 예가 자바스크립트에서의 이벤트 핸들러 처리이다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;script&amp;gt;
        // 페이지 로드 시 호출될 콜백 함수
        window.onload = function() {
            alert('This is the callback function.');
        };
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. 즉시 실행 함수&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;함수를 정의함과 동시에 바로 실행하는 함수를 즉시 실행 함수(immediate functions)라고 한다. 최초 한 번의 실행만을 필요로 하는 초기화 코드 부분 등에 사용할 수 있다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;(function (name) {
    console.log('This is the immediate function --&amp;gt; ' + name);
    // This is the immediate function --&amp;gt; foo
})('foo');&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jQuery와 같은 자바스크립트 라이브러리에 종종 익명함수가 사용되는 것을 볼 수 있다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;(function( window, undefined) {
    // ...
})( window );&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;기본적으로 자바스크립트는 변수를 선언할 경우 프로그램 전체에서 접근할 수 있는 전역 유효 범위를 가지게 된다. 그러나 함수 내부에서 정의된 매개변수와 변수(var로 선언된)들은 함수 코드 내부에서만 유효할 뿐 함수 밖에서는 유효하지 않다.&lt;/p&gt;&lt;p&gt;따라서 라이브러리 코드를 이렇게 즉시 실행 함수 내부에 정의해두게 되면, 라이브러리 내의 변수들은 함수 외부에서 접근할 수 없다. &lt;strong&gt;전역 네임스페이스를 더럽히지 않으므로, 다른 자바스크립트 라이브러리들이 동시에 로드가 되더라도 라이브러리 간 변수 이름 충돌 같은 문제를 방지할 수 있다.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3. 내부 함수&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;자바스크립트에서는 함수 코드 내부에서도 다시 함수 정의가 가능하다. 이렇게 함수 내부에 정의된 함수를 내부 함수(inner function) 라고 부른다. 내부 함수는 자바스크립트의 기능을 보다 강력하게 해주는 클로저를 생성하거나 부모 함수 코드에서 외부에서의 접근을 막고 독립적인 헬퍼 함수를 구현하는 용도 등으로 사용한다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// parent 함수 정의
function parent() {
    var a = 100;
    var b = 200;

    // child 내부 함수 정의
    function child() {
        var b = 300;

        console.log(a);
        console.log(b);
    }

    child();
}

parent();   // 100 300
child();    // Uncaught ReferenceError: child is not defined&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이것이 가능한 이유는 자바스크립트의 &lt;strong&gt;스코프 체이닝&lt;/strong&gt; 때문이다.&lt;/p&gt;&lt;p&gt;부모 함수에서 내부 함수를 외부로 리턴하면, 부모 함수 밖에서도 내부 함수를 호출하는 것이 가능하다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function parent() {
    var a = 100;

    // child 내부 함수
    var child = function() {
        console.log(a);
    }

    // child 함수 반환
    return child;
}

var inner = parent();
inner(); // 100&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이와 같이 실행이 끝난 parent()와 같은 부모 함수 스코프의 변수를 참조하는 inner()와 같은 함수를 &lt;strong&gt;클로저&lt;/strong&gt;라고 한다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4. 함수를 리턴하는 함수&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;자바스크립트에서는 함수도 일급 객체이므로 일반 값처럼 함수 자체를 리턴할 수도 있다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var self = function() {
    console.log('a');

    return function() {
        console.log('b');
    }
}

self = self(); // a
self(); // b&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/181&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>자바스크립트</category>
<category>javascript</category>
<category>체이닝</category>
<category>프로토타입</category>
<category>함수</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/181</guid>
<comments>https://itstory.tk/entry/4-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B4%EB%8B%9D-1#entry181comment</comments>
<pubDate>Tue, 02 Jan 2018 14:47:53 +0900</pubDate>
</item>
<item>
<title>[Java 8] Optional.orElse() vs Optional.orElseGet()</title>
<link>https://itstory.tk/entry/Java-8-OptionalorElse-vs-OptionalorElseGet</link>
<description>&lt;p&gt;Java 8에서 지원하는 &lt;code&gt;Optional&lt;/code&gt;를 사용하면 NullPointerException에 대한 방어코드를 functional하게 처리할 수 있습니다. Optional 내부 객체가 null 일 때 기본 값을 반환하기 위해 &lt;code&gt;orElse()&lt;/code&gt;와 &lt;code&gt;orElseGet()&lt;/code&gt;를 사용할 수 있습니다. Optional이 생기기 이전에는 다음과 유사한 코드를 작성했을 것 입니다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public void method(Object o) {
    if (o == null) {
        // null value handling
    }

    // to do something
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 예시를 통해 두 메서드가 어떻게 동작하는지 살펴보겠습니다.&lt;/p&gt;



&lt;h3 id=&quot;optionalorelse&quot;&gt;Optional.orElse()&lt;/h3&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;private static String wontRunThis() {
    System.out.println(&quot;Won't run this&quot;);
    return &quot;foo&quot;;
}

public void optional1() {
    String o = Optional.of(&quot;Hello World!&quot;).orElse(wontRunThis());
    System.out.println(&quot;Result : &quot; + o);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Result&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;Won't run this
Result : Hello World!&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;optionalorelseget&quot;&gt;Optional.orElseGet()&lt;/h3&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public void optional2() {
    String o = Optional.of(&quot;Hello World!&quot;).orElseGet(() -&amp;gt; wontRunThis());
    System.out.println(&quot;Result : &quot; + o);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Result&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;Result : Hello World!&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결과에서 확인할 수 있듯이 두 메서드 모두 내부 객체가 null이 아니기 때문에 &lt;code&gt;foo&lt;/code&gt;는 반환하지 않고 &lt;code&gt;Hello World!&lt;/code&gt;를 반환합니다. 하지만 &lt;code&gt;orElse()&lt;/code&gt;는 Optional 내부 객체의 상태와 상관없이 무조건 실행되어 &lt;code&gt;Won't run this&lt;/code&gt;를 출력하며, &lt;code&gt;orElseGet()&lt;/code&gt;은 내부 객체가 null인 경우에만 실행됩니다. 그 이유는 &lt;code&gt;orElse()&lt;/code&gt;의 인자로 &lt;code&gt;T other&lt;/code&gt;를 받기 때문입니다. 때문에 예상치 못한 사이드 이펙트가 생길 수 있으므로, 상황에 맞는 알맞은 선택이 필요합니다.&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/180&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>java 8</category>
<category>optional</category>
<category>orElse</category>
<category>orElseGet</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/180</guid>
<comments>https://itstory.tk/entry/Java-8-OptionalorElse-vs-OptionalorElseGet#entry180comment</comments>
<pubDate>Fri, 29 Dec 2017 16:09:41 +0900</pubDate>
</item>
<item>
<title>Spring Boot + Vue.js 연동하기</title>
<link>https://itstory.tk/entry/Spring-Boot-Vuejs-%EC%97%B0%EB%8F%99%ED%95%98%EA%B8%B0</link>
<description>&lt;p&gt;Backend 프레임워크인 Spring Boot와 Frontend 프레임워크인 Vue.js의 연동방법에 대해 살펴보겠습니다. Vue.js와 Backend 프레임워크와의 연동방법은 다양하게 있으며 현재 프로젝트 상황에 맞게 연동하면 됩니다.&lt;/p&gt;&lt;p style=&quot;margin-top: 0px; margin-right: 0px; margin-bottom: 0px;&quot;&gt;&lt;br /&gt;일반적인 방법으로 빌드시 생성되는 index.html 파일 하나만 두고 사용자 인증, 데이터 가져오기 등 모든 서버와의 통신은 WEB API 통신(REST API, GrapQL 등)으로 연동하는 방법입니다. 이 경우 기존의 렌더링 형태인 controller -&amp;gt; view(jsp, ejs 등 템플릿 엔진) 형태가 아니기 때문에 url 라우팅은 vue-router 등을 통해 처리해야 합니다.&lt;!--EndFragment--&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프로젝트-구조&quot;&gt;프로젝트 구조&lt;/h2&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;.
├── src/                        # Spring 소스코드 디렉터리
│   └── main/
│       ├── java/
│       └── resources/
│           ├── static/
│           ├── templates/
│           └── application.properties
├── target/                     # Spring 빌드 디렉터리
│   └── ...
├── frontend/                   # Vue.js 루트 디렉터리
│   ├── src/                    
│   └── ...
└── pom.xml                  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vue.js 파일들을 관리의 편의성을 위해 &lt;code&gt;frontend&lt;/code&gt; 디렉터리 하위에 두어 Spring 파일들과 분리시켜 줍니다. Vue.js를 신규 셋팅을 하는 상황이라면, vue-cli를 이용하여 &lt;code&gt;vue init webpack frontend&lt;/code&gt;와 같이 명령어를 입력하시면 됩니다. Vue.js 개발환경 셋팅에 대한 자세한 내용은 &lt;a href=&quot;http://itstory.tk/entry/vuecli-Webpack-템플릿으로-vuejs-개발환경-구축하기&quot;&gt;[vue-cli] Webpack 템플릿으로 vue.js 개발환경 구축하기&lt;/a&gt;를 참조하세요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이제 Webpack 빌드 시 생성되는 &lt;code&gt;index.html&lt;/code&gt; 파일이 스프링의 static 디렉터리에 위치하도록 vuejs conf 파일의 build 속성을 다음과 같이 수정합니다.&lt;/p&gt;&lt;p&gt;&lt;code&gt;frontend/config/index.js&lt;/code&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;build: {
    // Template for index.html
    index: path.resolve(__dirname, '../../src/main/resources/static/index.html'),&lt;br /&gt;
    // Assets Paths
    assetsRoot: path.resolve(__dirname, '../../src/main/resources/static'),
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;추가적인 config 설정 방법은 &lt;a href=&quot;http://itstory.tk/entry/vuecli-Webpack-템플릿으로-vuejs-개발환경-구축하기#backend-프레임워크와-통합하기&quot;&gt;Backend 프레임워크와 통합하기&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;&lt;p&gt;이제 &lt;code&gt;npm run build&lt;/code&gt;를 실행하면 Webpack의 빌드 결과물들이 Spring Boot의 &lt;code&gt;src/main/resources/static&lt;/code&gt; 하위에 생성될 것 입니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;cd frontend
npm run build&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빌드를 실행하면 다음과 같은 화면이 나오면 정상적으로 빌드가 이루어진 것 입니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;Hash: fa1c05ca567f976f2bb4
Version: webpack 3.10.0
Time: 9372ms
                                                  Asset       Size  Chunks             Chunk Names
               static/js/vendor.5973cf24864eecc78c48.js     112 kB       0  [emitted]  vendor
                  static/js/app.e3f37e373a7b0be800ee.js    11.4 kB       1  [emitted]  app
             static/js/manifest.8c2c40900403ccd0117f.js    1.49 kB       2  [emitted]  manifest
    static/css/app.40074a31a2d49e73485cdf8ca0ded531.css  432 bytes       1  [emitted]  app
static/css/app.40074a31a2d49e73485cdf8ca0ded531.css.map  828 bytes          [emitted]
           static/js/vendor.5973cf24864eecc78c48.js.map     548 kB       0  [emitted]  vendor
              static/js/app.e3f37e373a7b0be800ee.js.map    21.3 kB       1  [emitted]  app
         static/js/manifest.8c2c40900403ccd0117f.js.map     7.8 kB       2  [emitted]  manifest
                                ../templates/index.html  510 bytes          [emitted]

  Build complete.

  Tip: built files are meant to be served over an HTTP server.
  Opening index.html over file:// won't work.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Spring은 기본적으로 root url (&quot;/&quot;) 접속 시 static 디렉터리의 index.html 파일을 렌더링 해주기 때문에&amp;nbsp;URL 설정을 따로 하실 필요가 없습니다. 웹팩 빌드 시 index.html 파일명 외에 다른 파일명으로 설정하셨다면 Nginx 혹은 Apache 와 같은 web 서버 설정에서 해당 url로 설정해주시면 됩니다. 이제 Spring Boot를 띄우고 localhost:8080 에 접속하면 Vue.js 화면이 나오는 것을 확인하실 수 있습니다. 예제 소스 코드는 &lt;a href=&quot;https://github.com/kkd927/spring-boot-vuejs-example&quot;&gt;GitHub&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:574px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F993CE84E5A45C9001D1530&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/993CE84E5A45C9001D&quot; filemime=&quot;image/jpeg&quot; filename=&quot;frontend.png&quot; height=&quot;501&quot; width=&quot;574&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/179&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>spring boot</category>
<category>thymeleaf</category>
<category>vue.js</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/179</guid>
<comments>https://itstory.tk/entry/Spring-Boot-Vuejs-%EC%97%B0%EB%8F%99%ED%95%98%EA%B8%B0#entry179comment</comments>
<pubDate>Fri, 29 Dec 2017 13:48:03 +0900</pubDate>
</item>
<item>
<title>[Vue.js] UI Libraries (css framework) 비교</title>
<link>https://itstory.tk/entry/Vuejs-UI-Librariesframework-%EB%B9%84%EA%B5%90</link>
<description>&lt;h3 id=&quot;1-vuetify&quot;&gt;1. Vuetify&lt;/h3&gt;

&lt;p&gt;7천개 이상의 star를 받은 프로젝트로, &lt;a href=&quot;https://vuetifyjs.com/&quot;&gt;Vuetifyjs&lt;/a&gt;는 메터리얼 디자인(material design) 스펙에 따른 UI 레이아웃을 제공합니다. v1.0 알파 버전은 80개의 재사용 가능한 컴포넌트들을 제공합니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F99EF08445A445BA90D7734&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99EF08445A445BA90D&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Google_Contacts_example___Vuetify_js.png&quot; height=&quot;403&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;



&lt;h3 id=&quot;2-element&quot;&gt;2. Element&lt;/h3&gt;

&lt;p&gt;2만 1천개 이상의 star를 받은 가장 인기가 많은 프로젝트 중 하나로, &lt;a href=&quot;http://element.eleme.io/#/en-US&quot;&gt;Element&lt;/a&gt;는 다양한 커스터마이징 가능한 컴포넌트들을 제공합니다. 또한 다양한 생태계를 가지고 있어 차기 Vue UI 라이브러리로 선택해볼만 합니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F99EF1A425A445BBF32B2BF&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99EF1A425A445BBF32&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Component___Element.png&quot; height=&quot;418&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;



&lt;h3 id=&quot;3-keen-ui&quot;&gt;3. Keen UI&lt;/h3&gt;

&lt;p&gt;3천개 이상의 star를 받은 &lt;a href=&quot;https://josephuspaye.github.io/Keen-UI/#/ui-alert&quot;&gt;Keen UI&lt;/a&gt;는 Material UI에 영감을 받아 만들어진 프로젝트로, 실제 Material UI 라이브러리는 아닙니다. CSS 프레임워크가 아니며 grid system 혹은 typography styles를 포함하고 있지 않습니다. 오직 Javascript만을 요구하는 컴포넌트들을 제공합니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F9920B5455A445BF3215F04&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/9920B5455A445BF321&quot; filemime=&quot;image/jpeg&quot; filename=&quot;UiIconButton___Keen_UI_-_A_lightweight_collection_of_essential_UI_components_written_with_Vue_and_inspired_by_Material_Design_.png&quot; height=&quot;434&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;



&lt;h3 id=&quot;4-buefy&quot;&gt;4. Buefy&lt;/h3&gt;

&lt;p&gt;대략 2천개의 star를 받은 &lt;a href=&quot;https://buefy.github.io/#/documentation/dropdown&quot;&gt;Buefy&lt;/a&gt;는 Vue.js와 &lt;a href=&quot;https://bulma.io/&quot;&gt;Bulma&lt;/a&gt;로 만들어진 컴포넌트들을 제공합니다. 컴포넌트 선택 폭이 다소 제한적이긴 하지만, 한번 시도해볼만 라이브러리입니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F99A2753F5A445C642CBD1E&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99A2753F5A445C642C&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Buefy__lightweight_UI_components_for_Vue_js_based_on_Bulma.png&quot; height=&quot;406&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;



&lt;h3 id=&quot;5-boostrap-vue&quot;&gt;5. Boostrap-Vue&lt;/h3&gt;

&lt;p&gt;3천개의 star를 받은 &lt;a href=&quot;https://bootstrap-vue.js.org/&quot;&gt;bootstrap-vue&lt;/a&gt;는 Vue.js와 익히 알고있는 Bootstrap 4기반으로 만들어졌으며, 모바일 친화적이고 반응형 UI를 제공합니다. Vue.js 2.4+ 에서 사용 가능합니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F99DAE5465A445C072D9930&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99DAE5465A445C072D&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Navbar_-_BootstrapVue.png&quot; height=&quot;368&quot; style=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/178&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>자바스크립트</category>
<category>css framework</category>
<category>UI Libraries</category>
<category>vue.js</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/178</guid>
<comments>https://itstory.tk/entry/Vuejs-UI-Librariesframework-%EB%B9%84%EA%B5%90#entry178comment</comments>
<pubDate>Thu, 28 Dec 2017 11:45:49 +0900</pubDate>
</item>
<item>
<title>[Ubuntu 16.04] node.js 와 npm 설치</title>
<link>https://itstory.tk/entry/Ubuntu-1604-nodejs-%EC%99%80-npm-%EC%84%A4%EC%B9%98</link>
<description>&lt;p&gt;우분투에서 Node.js 설치를 할 수 있는 방법은 여러가지 있습니다. &lt;/p&gt;&lt;p&gt;4.x 버전을 설치하려면 아래 1번 방법을 통해 손쉽게 설치할 수 있으며, 그 이상의 버전을 설치하기 위해선 2번 방법을 통해 설치할 수 있습니다. 또는 여러 버전의 Node.js를 설치 및 관리하기 위해 &lt;code&gt;nvm&lt;/code&gt;을 이용하는 3번의 방법으로도 설치할 수 있습니다. &lt;br /&gt;
설치하려는 환경에 맞게 방법을 선택하여 설치하시기 바랍니다.&lt;/p&gt;

&lt;h2 id=&quot;1-우분투-저장소의-distro-stable-버전-설치&quot;&gt;1. 우분투 저장소의 Distro-Stable 버전 설치&lt;/h2&gt;

&lt;p&gt;우분투 16.04의 패키지 저장소에 Node.js가 기본으로 들어가져 있습니다. 이 글을 쓰는 현 시점에 v4.2.6 버전이 저장소에 올려져있습니다.&lt;/p&gt;&lt;p&gt;&lt;code&gt;apt&lt;/code&gt; 패키지 매니저를 통해 손쉽게 설치할 수 있습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get update
sudo apt-get install nodejs&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;추가로 &lt;code&gt;npm&lt;/code&gt;을 설치하기 위해서는 다음과 같이 입력하면 됩니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install npm&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다른 패키지와의 충돌을 방지하기 위해, 우분투 저장소의 Node.js는 &lt;code&gt;node&lt;/code&gt; 대신 &lt;code&gt;nodejs&lt;/code&gt; 명령어를 사용합니다.&lt;/p&gt;&lt;p&gt;다음 명령어로 정상적으로 Node.js가 설치되었는 지 확인할 수 있습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;nodejs -v
# v4.2.6&lt;/code&gt;&lt;/pre&gt;



&lt;h2 id=&quot;2-ppa를-이용한-최신버전-설치&quot;&gt;2. PPA를 이용한 최신버전 설치&lt;/h2&gt;

&lt;p&gt;Node.js 최신 버전을 설치하기 위해서는 NodeSource에서 운영되는 PPA (personal package archive)를 추가하여 설치할 수 있습니다. PPA를 이용하면 우분투 저장소에서 제공하는 4.x 버전(2017년 4월까지 지워하는 예전 LTS 버전)뿐만 아니라 6.x 버전(2018년 4월까지 지원하는 최신 LTS 버전)와 7.x 버전(현재 개발 버전)까지 선택하여 설치할 수 있습니다.&lt;/p&gt;&lt;p&gt;이 예제에서는 &lt;code&gt;6.x&lt;/code&gt; 버전을 설치할 것 입니다. 다른 버전을 설치하기 위해선 아래 &lt;code&gt;curl&lt;/code&gt; 명령어의 &lt;code&gt;6.x&lt;/code&gt; 문자를 원하는 버전으로 수정하여 다운로드 받으시면 됩니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;cd ~
curl -sL https://deb.nodesource.com/setup_6.x -o nodesource_setup.sh&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sudo&lt;/code&gt; 권한으로 다음 명령어를 실행하면 PPA를 추가하고 업데이트까지 자동으로 실행됩니다. 이후 작업은 첫번째 Distro-Stable 버전 설치 방법과 동일합니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo bash nodesource_setup.sh
sudo apt-get install nodejs&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PPA를 통해 Node.js를 설치하면 &lt;code&gt;nodejs&lt;/code&gt; 뿐만 아니라 &lt;code&gt;npm&lt;/code&gt;까지 같이 설치되므로 따로 &lt;code&gt;npm&lt;/code&gt;을 설치할 필요가 없습니다. 하지만 &lt;code&gt;npm&lt;/code&gt;이 제대로 동작하기 위해선 &lt;code&gt;build-essential&lt;/code&gt; 패키지를 설치해야 합니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install build-essential&lt;/code&gt;&lt;/pre&gt;



&lt;h2 id=&quot;3-nvm을-이용한-설치&quot;&gt;3. NVM을 이용한 설치&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;apt&lt;/code&gt; 패키지 매니저 대신, &lt;strong&gt;Node.js version manager&lt;/strong&gt;인 &lt;code&gt;nvm&lt;/code&gt;을 이용하여 설치할 수 도 있습니다.&lt;/p&gt;&lt;p&gt;&lt;code&gt;nvm&lt;/code&gt;을 이용하면 Node.js의 여러 버전을 설치하고 쉽게 환경 관리를 할 수 있습니다.&lt;/p&gt;&lt;p&gt;우선 우분투 저장소에서 nvm 설치에 필요한 패키지들을 설치합니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get update
sudo apt-get install build-essential libssl-dev&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음으로 nvm 설치 스크립트를 다운로드 후 실행시켜 줍니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;curl -sL https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh -o install_nvm.sh
bash install_nvm.sh
source ~/.profile&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;설치가 완료되면 home 디렉터리에 &lt;code&gt;~/.nvm&lt;/code&gt; 폴더가 생성됩니다.&lt;/p&gt;&lt;p&gt;설치 가능한 Node.js 버전 목록을 확인하기 위해서 다음과 같이 입력하면 됩니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;nvm ls-remote&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;# 결과

v5.8.0
v5.9.0
v5.9.1
v5.10.0
v5.10.1
v5.11.0
v6.0.0&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;원하는 버전을 선택한 후 다음과 같이 설치하면 됩니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;nvm install 6.0.0&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여러 버전의 Node.js를 설치했다면 다음과 같이 특정 버전으로 변경하여 사용할 수 있습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;nvm use 6.0.0&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nvm을 이용하여 Node.js를 설치하면 1, 2번 방법과 달리 &lt;code&gt;node&lt;/code&gt; 명령어를 사용해야 합니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;node -v
# v6.0.0&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;설치된 Node.js 버전 목록을 보려면 다음과 같이 입력하면 됩니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;nvm ls&lt;/code&gt;&lt;/pre&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/177&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>리눅스&amp;우분투</category>
<category>Node.js</category>
<category>npm</category>
<category>ubuntu</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/177</guid>
<comments>https://itstory.tk/entry/Ubuntu-1604-nodejs-%EC%99%80-npm-%EC%84%A4%EC%B9%98#entry177comment</comments>
<pubDate>Tue, 26 Dec 2017 18:05:32 +0900</pubDate>
</item>
<item>
<title>[thymeleaf] legacy html5 모드 설정</title>
<link>https://itstory.tk/entry/thymeleaf-legacy-html5-%EB%AA%A8%EB%93%9C-%EC%84%A4%EC%A0%95</link>
<description>&lt;p&gt;thymeleaf 템플릿 엔진을 사용 중에 meta, link, input 태그 등을 닫지 않으면 아래와 유사한 에러 메시지가 뜹니다.&lt;/p&gt;&lt;p&gt;org.xml.sax.SAXParseException: Open quote is expected for attribute “charset” associated with an  element type  “meta”.&lt;/p&gt;&lt;p&gt;thymeleaf의 기본 설정이&amp;nbsp;아래 처럼 HTML5로 설정되어 있기 때문입니다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;spring.thymeleaf.mode = HTML5&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;html 파일들을 webpack 등을 이용해 빌드를 하는 경우 등 수작업으로 맞춰주기가 귀찮거나 번거로운 경우에는 thymeleaf 모드를 legacy html5 모드로 변경해주면 됩니다.&lt;/p&gt;&lt;p&gt;thymeleaf를 legcay html5 모드로 사용하기 위해선 다음와 같이 설정하면 됩니다.&lt;/p&gt;



&lt;h4 id=&quot;applicationproperties&quot;&gt;application.properties&lt;/h4&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;spring.thymeleaf.mode=LEGACYHTML5&lt;/code&gt;&lt;/pre&gt;



&lt;h4 id=&quot;pomxml&quot;&gt;pom.xml&lt;/h4&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;net.sourceforge.nekohtml&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;nekohtml&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/176&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>legacy html5 mode</category>
<category>meta tag</category>
<category>thymeleaf</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/176</guid>
<comments>https://itstory.tk/entry/thymeleaf-legacy-html5-%EB%AA%A8%EB%93%9C-%EC%84%A4%EC%A0%95#entry176comment</comments>
<pubDate>Tue, 26 Dec 2017 15:05:43 +0900</pubDate>
</item>
<item>
<title>[JavaScript] ES6 문법 정리</title>
<link>https://itstory.tk/entry/JavaScript-ES6-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC</link>
<description>&lt;h1 id=&quot;ecmascript-6&quot;&gt;ECMAScript 6&lt;/h1&gt;

&lt;p&gt;이 문서는 &lt;a href=&quot;https://github.com/lukehoban/es6features&quot;&gt;https://github.com/lukehoban/es6features&lt;/a&gt; 를 번역한 내용입니다. 번역 문서를 읽는 중, 오타나 어색한 문장이 있으면 &lt;a href=&quot;https://github.com/kkd927/til/issues/new?title=%5bECMAScript%206%20Features%5d&quot;&gt;이슈&lt;/a&gt;를 등록해주세요!&lt;/p&gt;



&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;ECMAScript 2015로도 알려져 있는 ECMAScript 6는 ECMAScript 표준의 가장 최신 버전입니다. ES6는 새로운 언어 기능이 포함된 주요 업데이트이며, 2009년도에 표준화된 ES5 이후로 언어 기능에 대한 첫 업데이트이기도 합니다. 현재 주요 JavaScript 엔진들에서 &lt;a href=&quot;http://kangax.github.io/compat-table/es6/&quot;&gt;ES6 기능들을 구현 중&lt;/a&gt;에 있습니다.&lt;/p&gt;
&lt;p&gt;ECMAScript 6 언어의 전체 스펙을 확인하시려면 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ES6 Standard&lt;/a&gt;를 확인하세요.&lt;/p&gt;
&lt;p&gt;ES6는 아래의 새로운 기능들을 포함하고 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#arrows&quot;&gt;arrows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#classes&quot;&gt;classes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#enhanced-object-literals&quot;&gt;enhanced object literals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#template-strings&quot;&gt;template strings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#destructuring&quot;&gt;destructuring&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#default--rest--spread&quot;&gt;default + rest + spread&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#let--const&quot;&gt;let + const&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#iterators--forof&quot;&gt;iterators + for..of&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#generators&quot;&gt;generators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#unicode&quot;&gt;unicode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#modules&quot;&gt;modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#module-loaders&quot;&gt;module loaders&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#map--set--weakmap--weakset&quot;&gt;map + set + weakmap + weakset&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#proxies&quot;&gt;proxies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#symbols&quot;&gt;symbols&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#subclassable-built-ins&quot;&gt;subclassable built-ins&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#promises&quot;&gt;promises&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#math--number--string--array--object-apis&quot;&gt;math + number + string + array + object APIs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#binary-and-octal-literals&quot;&gt;binary and octal literals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#reflect-api&quot;&gt;reflect api&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tail-calls&quot;&gt;tail calls&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;



&lt;h2 id=&quot;ecmascript-6-에-추가된-기능&quot;&gt;ECMAScript 6 에 추가된 기능&lt;/h2&gt;



&lt;h3 id=&quot;arrows&quot;&gt;Arrows&lt;/h3&gt;

&lt;p&gt;Arrows(화살표) 함수는 &lt;code&gt;=&amp;gt;&lt;/code&gt; 문법을 사용하는 축약형 함수입니다. C#, Java 8, CoffeeScript의 해당 기능과 문법적으로 유사합니다. Arrows는 표현식의 결과 값을 반환하는 표현식 본문(expression bodies)뿐만 아니라 상태 블럭 본문(statement block bodies)도 지원합니다. 하지만 일반 함수의 자신을 호출하는 객체를 가리키는 &lt;code&gt;dynamic this&lt;/code&gt;와 달리 arrows 함수는 코드의 상위 스코프(lexical scope)를 가리키는 &lt;code&gt;lexical this&lt;/code&gt;를 가집니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var evens = [2, 4, 6, 8,];

// Expression bodies (표현식의 결과가 반환됨)
var odds = evens.map(v =&amp;gt; v + 1);   // [3, 5, 7, 9]
var nums = evens.map((v, i) =&amp;gt; v + i);  // [2, 5, 8, 11]
var pairs = evens.map(v =&amp;gt; ({even: v, odd: v + 1})); // [{even: 2, odd: 3}, ...]

// Statement bodies (블럭 내부를 실행만 함, 반환을 위해선 return을 명시)
nums.forEach(v =&amp;gt; {
  if (v % 5 === 0)
    fives.push(v);
});

// Lexical this
// 출력결과 : Bob knows John, Brian
var bob = {
  _name: &quot;Bob&quot;,
  _friends: [&quot;John, Brian&quot;],
  printFriends() {
    this._friends.forEach(f =&amp;gt;
      console.log(this._name + &quot; knows &quot; + f));
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;printFriends() 함수의 서브루틴은 다음과 문법상 동일하게 동작합니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;this._friends.forEach(function (f) {
    console.log(this._name + &quot; knows &quot; + f));
}.bind(this));&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;화살표 함수의 더 자세한 설명은 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98&quot;&gt;MDN Arrow Functions&lt;/a&gt;를 참고하세요. printFriends() 함수의 선언 표기법이 궁금하시면 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Object_initializer&quot;&gt;MDN Object Initializer&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h3 id=&quot;classes&quot;&gt;Classes&lt;/h3&gt;

&lt;p&gt;ES6 클래스는 프로토타입 기반 객체지향 패턴을 더 쉽게 사용할 수 있는 대체재입니다. 클래스 패턴 생성을 더 쉽고 단순하게 생성할 수 있어서 사용하기도 편하고 상호운용성도 증가됩니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;class SkinnedMesh extends THREE.Mesh {
  constructor(geometry, materials) {
    super(geometry, materials);

    this.idMatrix = SkinnedMesh.defaultMatrix();
    this.bones = [];
    this.boneMatrices = [];
    //...
  }
  update(camera) {
    //...
    super.update();
  }
  get boneCount() {
    return this.bones.length;
  }
  set matrixType(matrixType) {
    this.idMatrix = SkinnedMesh[matrixType]();
  }
  static defaultMatrix() {
    return new THREE.Matrix4();
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 자세한 설명은 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/class&quot;&gt;MDN Classes&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h3 id=&quot;enhanced-object-literals&quot;&gt;Enhanced Object Literals&lt;/h3&gt;

&lt;p&gt;ES6에서 객체 리터럴은 선언문에서 프로토타입 설정, &lt;code&gt;foo: foo&lt;/code&gt; 선언을 위한 단축 표기법, 메서드 정의, super 클래스 호출 및 동적 속성명을 지원하도록 향상 되었습니다. 그에 따라 객체 리터럴 및 클래스 선언이 더 밀접되어져, 객체기반 설계가 더 편리해졌습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var obj = {
    // __proto__
    __proto__: theProtoObj,

    // ‘handler: handler’의 단축 표기
    handler,

    // Methods
    toString() {
     // Super calls
     return &quot;d &quot; + super.toString();
    },

    // Computed (dynamic) property names
    [ 'prop_' + (() =&amp;gt; 42)() ]: 42
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 자세한 설명은 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Values,_variables,_and_literals#객체_리터럴&quot;&gt;MDN Grammar and types: Object literals&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h3 id=&quot;template-strings&quot;&gt;Template Strings&lt;/h3&gt;

&lt;p&gt;Template Strings(ES6 부터는 Template literals라 부름)는 문법적으로 더 편하게 string을 생성할 수 있게 합니다. 이는 Perl, Python 등의 문자열 보간(string interpolation)과 유사합니다. Tagged template literals는 인젝션 공격 방어 혹은 문자열로 부터 상위 데이터 구조체 재조립 등을 위해 string 생성을 커스터마이징이 가능하게끔 해줍니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Basic literal string creation
`In JavaScript '\n' is a line-feed.`

// Multiline strings
`In JavaScript this is
 not legal.`

// String interpolation
var name = &quot;Bob&quot;, time = &quot;today&quot;;
`Hello ${name}, how are you ${time}?`

// Construct an HTTP request prefix is used to interpret the replacements and construction
POST`http://foo.org/bar?a=${a}&amp;amp;b=${b}
     Content-Type: application/json
     X-Credentials: ${credentials}
     { &quot;foo&quot;: ${foo},
       &quot;bar&quot;: ${bar}}`(myOnReadyStateChangeHandler);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 자세한 설명은 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Template_literals&quot;&gt;MDN Template literals&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h3 id=&quot;destructuring&quot;&gt;Destructuring&lt;/h3&gt;

&lt;p&gt;Destructuring는 배열과 객체에 패턴 매칭을 통한 데이터 바인딩을 제공합니다. Destructuring는 할당 실패에 유연하며, 실패 시 &lt;code&gt;undefined&lt;/code&gt; 값이 자동할당 됩니다. 또한 &lt;code&gt;foo[&quot;bar&quot;]&lt;/code&gt;와 같이 객체의 속성 값도 자동으로 검색하여 바인딩해줍니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// list matching
var [a, , b] = [1,2,3];

// object matching
var { op: a, lhs: { op: b }, rhs: c }
       = getASTNode()

// object matching 단축 표기
// binds `op`, `lhs` and `rhs` in scope
var {op, lhs, rhs} = getASTNode()

// parameter에서도 사용 가능
function g({name: x}) {
  console.log(x);
}
g({name: 5})

// Fail-soft destructuring
var [a] = [];
a === undefined;

// Fail-soft destructuring with defaults
var [a = 1] = [];
a === 1;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 자세한 설명은 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;MDN Destructuring assignment&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h3 id=&quot;default-rest-spread&quot;&gt;Default + Rest + Spread&lt;/h3&gt;

&lt;p&gt;파라미터에 기본 값을 설정할 수 있습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function f(x, y=12) {
  // y is 12 if not passed (or passed as undefined)
  return x + y;
}
f(3) // 15&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;가변인자를 사용가능하며, 배열로 치환시켜 줍니다. Rest parameters는 &lt;code&gt;arguments&lt;/code&gt; 보다 직관성을 제공합니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function f(x, ...y) {
  // y is an Array [&quot;hello&quot;, true]
  return x * y.length;
}
f(3, &quot;hello&quot;, true) // 6&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;함수 호출 시 배열을 일련의 인자에 나누어 주입시켜 줍니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function f(x, y, z) {
  return x + y + z;
}
// Pass each elem of array as argument
f(...[1,2,3]) // 6&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 자세한 설명은 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/Default_parameters&quot;&gt;Default parameters&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/rest_parameters&quot;&gt;Rest parameters&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;Spread Operator&lt;/a&gt;를 참고하세요.&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;!-- 728X90 --&gt;
&lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:inline-block;width:728px;height:90px&quot; data-ad-client=&quot;ca-pub-8876596272501347&quot; data-ad-slot=&quot;1477393585&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/p&gt;

&lt;h3 id=&quot;let-const&quot;&gt;Let + Const&lt;/h3&gt;

&lt;p&gt;블록 유효 범위를 갖는 새로운 변수 선언 방법을 지원합니다. &lt;code&gt;let&lt;/code&gt;은 &lt;code&gt;var&lt;/code&gt;와 유사하게 동작합니다. &lt;code&gt;const&lt;/code&gt;는 재할당 및 재선언이 불가능합니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function f() {
  {
    let x;
    {
      // okay, block scoped name
      const x = &quot;sneaky&quot;;
      // error, const
      x = &quot;foo&quot;;
    }
    // error, already declared in block
    let x = &quot;inner&quot;;
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;var&lt;/code&gt;의 유효 범위는 전체 외부 함수까지이지만 &lt;code&gt;let&lt;/code&gt;은 변수를 선언한 블록과 그 내부 블록들에서 유효합니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function varTest() {
    var x = 31;
    if (true) {
        var x = 71;  // same variable!
        console.log(x);  // 71
    }
    console.log(x);  // 71
}

function letTest() {
    let x = 31;
    if (true) {
        let x = 71;  // different variable
        console.log(x);  // 71
    }
    console.log(x);  // 31
}&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function varTest() {
    if (true) {
        var x = 71;
        console.log(x);  // 71
    }
    console.log(x);  // 71
}

function varTest() {
    let x = 71;
    if (true) {
        console.log(x);  // 71
    }
    console.log(x);  // 71
}

function varTest() {
    if (true) {
        let x = 71;
        console.log(x);  // 71
    }
    console.log(x);  // Uncaught ReferenceError: x is not defined
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 자세한 설명은 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;let statement&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/const&quot;&gt;const statement&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h3 id=&quot;iterators-forof&quot;&gt;Iterators + For..Of&lt;/h3&gt;

&lt;p&gt;Iterator 객체는 CLR의 IEnumerable 혹은 Java의 Iterable처럼 사용자 정의의 반복을 가능하게 해줍니다. &lt;code&gt;for..of&lt;/code&gt; 반복문이 ES6에서 추가 되었으며 &lt;code&gt;for..in&lt;/code&gt; 반복문과 달리 iterator 기반의 컬렉션 전용 반복문입니다. &lt;code&gt;for in&lt;/code&gt; 반복문과의 차이점은 &lt;a href=&quot;http://itstory.tk/entry/Javascript-for-in-vs-for-of-반복문&quot;&gt;for in vs for of&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;let fibonacci = {
    [Symbol.iterator]() {
        let pre = 0, cur = 1;

        return {
            next() {
                [pre, cur] = [cur, pre + cur];
                return { done: false, value: cur }
            }
        }
    }
}

for (var n of fibonacci) {
    // truncate the sequence at 1000
    if (n &amp;gt; 1000)
        break;
    console.log(n); // 1, 2, 3, 5, 8, ...987
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Iteration은 아래의 duck-type 인터페이스를 기반으로 합니다. (설명을 위해 &lt;a href=&quot;http://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt;의 타입 문법을 사용하였습니다)&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;interface IteratorResult {
    done: boolean;
    value: any;
}
interface Iterator {
    next(): IteratorResult;
}
interface Iterable {
    [Symbol.iterator](): Iterator
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 자세한 설명은 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;MDN for…of&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h3 id=&quot;generators&quot;&gt;Generators&lt;/h3&gt;

&lt;p&gt;Generators는 &lt;code&gt;function*&lt;/code&gt;와 &lt;code&gt;yield&lt;/code&gt; 키워드를 이용하여 iterator 선언을 단순하게 작성할 수 있게 도와줍니다. &lt;code&gt;function*&lt;/code&gt;로 선언한 함수는 Generator 객체를 반환합니다. Generators는 iterator의 하위 타입이며 &lt;code&gt;next&lt;/code&gt;와 &lt;code&gt;throw&lt;/code&gt; 메서드를 가지고 있습니다. 이 메서드들로 인해 &lt;code&gt;yield&lt;/code&gt; 키워드로 반환된 값은 다시 generator에 주입거나 예외처리를 할 수 있게 되었습니다.&lt;/p&gt;
&lt;p&gt;참고: 해당 키워드는 비동기 프로그래밍의 ‘await’ 같은 기능이 가능하게끔 기반이 되었습니다. ES7의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-async-function-definitions&quot;&gt;&lt;code&gt;await&lt;/code&gt; 제안서&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var fibonacci = {
    [Symbol.iterator]: function*() {
        var pre = 0, cur = 1;
        for (;;) {
            [pre, cur] = [cur, pre + cur];
            yield cur;
        }
    }
}

for (var n of fibonacci) {
    // truncate the sequence at 20
    if (n &amp;gt; 20)
        break;
    console.log(n); // 1, 2, 3, 5, 8, 13
}&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function* gen(){
  yield* [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
}

var a = gen();

a.next(); // { value: &quot;a&quot;, done: false }
a.next(); // { value: &quot;b&quot;, done: false }
a.next(); // { value: &quot;c&quot;, done: false }
a.next(); // { value: undefined, done: true }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generator 인터페이스는 다음과 같습니다. (설명을 위해 &lt;a href=&quot;http://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt;의 타입 문법을 사용하였습니다)&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;interface Generator extends Iterator {
    next(value?: any): IteratorResult;
    throw(exception: any);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 자세한 설명은 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;MDN Iteration protocols&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h3 id=&quot;unicode&quot;&gt;Unicode&lt;/h3&gt;

&lt;p&gt;완전한 유니코드를 지원하기 위해 문자열에 새로운 유니코드 리터럴과 정규표현식에 &lt;code&gt;u&lt;/code&gt; 모드가 추가되었습니다. 또한 21비트 형식까지 처리하기 위한 신규 API가 추가되었습니다. 이 추가된 기능은 JavaScript로 글로벌 앱을 만들 수 있도록 지원합니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// same as ES5.1
&quot; &quot;.length == 2

// new RegExp behaviour, opt-in ‘u’
&quot; &quot;.match(/./u)[0].length == 2

// new form
&quot;\u{20BB7}&quot; == &quot; &quot;  == &quot;\uD842\uDFB7&quot;

// new String ops
&quot; &quot;.codePointAt(0) == 0x20BB7

// for-of iterates code points
for(var c of &quot; &quot;) {
    console.log(c); //  
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 자세한 설명은 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/RegExp&quot;&gt;MDN RegExp.prototype.unicode&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h3 id=&quot;modules&quot;&gt;Modules&lt;/h3&gt;

&lt;p&gt;언어 차원에서 컴포넌트 정의를 위한 모듈을 지원합니다. 유명한 JavaScript 모듈 로더들(AMD, CommonJS)의 패턴을 적용시켰습니다. 런타임 동작은 호스트에 정의된 기본 로더에 의해 정의됩니다. 묵시적 비동기 형태로 요구되는 모듈들이 정상적으로 로드되기 전까지 코드가 실행되지 않습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// lib/math.js
export function sum(x, y) {
    return x + y;
}
export var pi = 3.141593;&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// app.js
import * as math from &quot;lib/math&quot;;
console.log(&quot;2π = &quot; + math.sum(math.pi, math.pi)); // 2π = 6.283186&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// otherApp.js
import {sum, pi} from &quot;lib/math&quot;;
console.log(&quot;2π = &quot; + sum(pi, pi)); // 2π = 6.283186&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;export default&lt;/code&gt;와 &lt;code&gt;export *&lt;/code&gt; 문법도 제공합니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// lib/mathplusplus.js
export * from &quot;lib/math&quot;;
export var e = 2.71828182846;
export default function(x) {
    return Math.log(x);
}&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// app.js
import ln, {pi, e} from &quot;lib/mathplusplus&quot;;
console.log(&quot;2π = &quot; + ln(e)*pi*2);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;import statement&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/export&quot;&gt;export statement&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h3 id=&quot;module-loaders&quot;&gt;Module Loaders&lt;/h3&gt;

&lt;p&gt;Module Loaders는 다음을 지원합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;동적 로딍(Dynamic loading)&lt;/li&gt;
&lt;li&gt;상태 격리(State isolation)&lt;/li&gt;
&lt;li&gt;전역 네임스페이스 격리(Global namespace isolation)&lt;/li&gt;
&lt;li&gt;컴파일 훅(Compilation hooks)&lt;/li&gt;
&lt;li&gt;중첩 가상화(Nested virtualization)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기본으로 사용할 모듈 로더를 설정할 수 있으며, 로더를 새로 생성하여 격리되거나 제한된 맥락에서 코드를 로드할 수 있습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 동적 로딩 – ‘System’ is default loader
System.import('lib/math').then(function(m) {
    console.log(&quot;2π = &quot; + m.sum(m.pi, m.pi));
});

// 실행 샌드박스 생성 – new Loaders
var loader = new Loader({
    global: fixup(window) // replace ‘console.log’
});
loader.eval(&quot;console.log('hello world!');&quot;);

// 모듈 캐시 직접 조작
System.get('jquery');
System.set('jquery', Module({$: $})); // WARNING: not yet finalized&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;map-set-weakmap-weakset&quot;&gt;Map + Set + WeakMap + WeakSet&lt;/h3&gt;

&lt;p&gt;일반 알고리즘을 위한 효율적인 데이터 구조를 제공합니다. WeakMap과 WeakSet는 메모리 누수로 부터 자유롭게 해줍니다. 이들 내 저장된 객체에 다른 참조가 없는 경우, garbage collection 될 수 있습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Sets
var s = new Set();
s.add(&quot;hello&quot;).add(&quot;goodbye&quot;).add(&quot;hello&quot;);
s.size === 2;
s.has(&quot;hello&quot;) === true;

// Maps
var m = new Map();
m.set(&quot;hello&quot;, 42);
m.set(s, 34);
m.get(s) == 34;

// Weak Maps
var wm = new WeakMap();
wm.set(s, { extra: 42 });
wm.size // undefined (사용된 곳이 없기 때문)

// Weak Sets
var ws = new WeakSet();
ws.add({ data: 42 });
wm.size // undefined (사용된 곳이 없기 때문)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 자세한 내용은 MDN &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;Map&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Set&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/WeakMap&quot;&gt;WeakMap&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/WeakSet&quot;&gt;WeakSet&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h3 id=&quot;proxies&quot;&gt;Proxies&lt;/h3&gt;

&lt;p&gt;프록시(Proxy)를 사용하면 호스트 객체에 다양한 기능을 추가하여 객체를 생성할 수 있습니다. interception, 객체 추상화, 로깅/수집, 값 검증 등에 사용될 수 있습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Proxying a normal object
var target = {};
var handler = {
  get: function (receiver, name) {
    return `Hello, ${name}!`;
  }
};

var p = new Proxy(target, handler);
p.world // 'Hello, world!';&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Proxying a function object
var target = function () { return 'I am the target'; };
var handler = {
  apply: function (receiver, ...args) {
    return 'I am the proxy';
  }
};

var p = new Proxy(target, handler);
p() // 'I am the proxy';&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;let validator = {
    set: function(obj, prop, value) {
        if (prop === 'age') {
            if (!Number.isInteger(value)) {
                throw new TypeError('The age is not an integer');
            }
            if (value &amp;gt; 200) {
                throw new RangeError('The age seems invalid');
            }
        }

        // The default behavior to store the value 
        obj[prop] = value;
    }
};

let person = new Proxy({}, validator);

person.age = 100;
console.log(person.age); // 100
person.age = 'young'; // Throws an exception
person.age = 300; // Throws an exception&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;proxy의 &lt;code&gt;handler&lt;/code&gt;가 가질 수 있는 트랩(trap)들입니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var handler =
{
  get:...,
  set:...,
  has:...,
  deleteProperty:...,
  apply:...,
  construct:...,
  getOwnPropertyDescriptor:...,
  defineProperty:...,
  getPrototypeOf:...,
  setPrototypeOf:...,
  enumerate:...,
  ownKeys:...,
  preventExtensions:...,
  isExtensible:...
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 자세한 내용은 MDN &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy&quot;&gt;Proxy&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h3 id=&quot;symbols&quot;&gt;Symbols&lt;/h3&gt;

&lt;p&gt;심볼(Symbol)은 객체 상태의 접근 제어를 가능하게 합니다. Symbol은 새로운 원시 타입으로 이름 충돌의 위험 없이 속성(property)의 키(key)로 사용할 수 있습니다. 옵션 파라미터인 &lt;code&gt;description&lt;/code&gt;는 디버깅 용도로 사용되며 식별 용도는 아닙니다. Symbol은 고유(unique)하며, &lt;code&gt;Object.getOwnPropertySymbols&lt;/code&gt;와 같은 reflection 기능들로 접근할 수 있기 때문에 private 하진 않습니다(&lt;code&gt;for in&lt;/code&gt;나 &lt;code&gt;Object.keys()&lt;/code&gt;로는 접근 불가).&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var map = {};
var a = Symbol('a');

map[a] = 123;
map[&quot;b&quot;] = 456;

console.log(map[a]); // 123
console.log(map[&quot;b&quot;]); // 456

for (let key in map) {
    console.log(key); // b
}

Object.keys(map); // [&quot;b&quot;]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;http://hacks.mozilla.or.kr/2015/09/es6-in-depth-symbols/&quot;&gt;ES6 In Depth: 심볼 (Symbol)&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h3 id=&quot;subclassable-built-ins&quot;&gt;Subclassable Built-ins&lt;/h3&gt;

&lt;p&gt;ES6에서 &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Date&lt;/code&gt;, DOM &lt;code&gt;Element&lt;/code&gt; 같이 내장 객체들은 상속이 가능합니다. 객체 생성 시 호출되는 &lt;code&gt;Ctor&lt;/code&gt; 함수는 다음의 2단계를 가집니다.(둘다 가상적으로 실행)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;객체 할당을 위해 &lt;code&gt;Ctor[@@create]&lt;/code&gt; 호출하여 &lt;/li&gt;
&lt;li&gt;새로운 인스턴스의 생성자를 호출해 초기화 진행&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아시다싶이 &lt;code&gt;@@create&lt;/code&gt; 심볼은 &lt;code&gt;Symbol.create&lt;/code&gt;를 통해 만들어졌습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Pseudo-code of Array
class Array {
    constructor(...args) { /* ... */ }
    static [Symbol.create]() {
        // Install special [[DefineOwnProperty]]
        // to magically update 'length'
    }
}

// User code of Array subclass
class MyArray extends Array {
    constructor(...args) { super(...args); }
}

// Two-phase 'new':
// 1) Call @@create to allocate object
// 2) Invoke constructor on new instance
var arr = new MyArray();
arr[1] = 12;
arr.length == 2&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;math-number-string-array-object-apis&quot;&gt;Math + Number + String + Array + Object APIs&lt;/h3&gt;

&lt;p&gt;core Math 라이브러리, Array 생성 helper, String helper, 복사를 위한 Object.assign 등 많은 라이브러리들이 추가되었습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;Number.EPSILON
Number.isInteger(Infinity) // false
Number.isNaN(&quot;NaN&quot;) // false

Math.acosh(3) // 1.762747174039086
Math.hypot(3, 4) // 5
Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2

&quot;abcde&quot;.includes(&quot;cd&quot;) // true
&quot;abc&quot;.repeat(3) // &quot;abcabcabc&quot;

Array.from(document.querySelectorAll('*')) // Returns a real Array
Array.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior
[0, 0, 0].fill(7, 1) // [0,7,7]
[1, 2, 3].find(x =&amp;gt; x == 3) // 3
[1, 2, 3].findIndex(x =&amp;gt; x == 2) // 1
[1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2]
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() // iterator [0, &quot;a&quot;], [1,&quot;b&quot;], [2,&quot;c&quot;]
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() // iterator 0, 1, 2
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() // iterator &quot;a&quot;, &quot;b&quot;, &quot;c&quot;

Object.assign(Point, { origin: new Point(0,0) })&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Number&quot;&gt;Number&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Math&quot;&gt;Math&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/from&quot;&gt;Array.from&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/of&quot;&gt;Array.of&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin&quot;&gt;Array.prototype.copyWithin&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Object.assign&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h3 id=&quot;binary-and-octal&quot;&gt;Binary and Octal&lt;/h3&gt;

&lt;p&gt;2진법 (&lt;code&gt;b&lt;/code&gt;), 8진법 (&lt;code&gt;o&lt;/code&gt;) numeric 리터럴 형식이 추가되었습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;0b111110111 === 503 // true
0o767 === 503 // true&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;promises&quot;&gt;Promises&lt;/h3&gt;

&lt;p&gt;Promise는 비동기 프로그래밍을 위한 라이브러리입니다. Promise는 미래에 생성되는 값을 나타내는 일급 객체입니다. Promise는 현존하는 많은 JavaScript 라이브러리에 사용되고 있습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function timeout(duration = 0) {
    return new Promise((resolve, reject) =&amp;gt; {
        setTimeout(resolve, duration);
    })
}

var p = timeout(1000).then(() =&amp;gt; {
    return timeout(2000);
}).then(() =&amp;gt; {
    throw new Error(&quot;hmm&quot;);
}).catch(err =&amp;gt; {
    return Promise.all([timeout(100), timeout(200)]);
})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;MDN Promise&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h3 id=&quot;reflect-api&quot;&gt;Reflect API&lt;/h3&gt;

&lt;p&gt;Reflection API는 런타임 시 객체에 대해 작업을 수행할 수 있습니다. 프록시 트랩(proxy traps)와 같은 메타 함수들을 가지고 있습니다. Reflection은 프록시를 구현하는데 유용합니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;class Greeting {
    constructor(name) {
        this.name = name;
    }

    greet() {
      return `Hello ${name}`;
    }
}

function greetingFactory(name) {
    return Reflect.construct(Greeting, [name], Greeting);
}

greetingFactory('a'); // Greeting {name: &quot;a&quot;}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Reflect&quot;&gt;MDN Reflect&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h3 id=&quot;tail-calls&quot;&gt;Tail Calls&lt;/h3&gt;

&lt;p&gt;마지막에 호출되는 함수가 호출 스택이 초과되게 하지 않습니다. 재귀 알고리즘을 매우 큰 입력 값에서도 안전하게 만듭니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function factorial(n, acc = 1) {
    'use strict';
    if (n &amp;lt;= 1) return acc;
    return factorial(n - 1, n * acc);
}

// 현재 대부분의 자바스크립트 엔진에서 스택 오버플로우가 일어나지만,
// ES6에서는 입력 값이 커도 안전하다
factorial(100000);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/175&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>자바스크립트</category>
<category>ES6</category>
<category>javascript</category>
<category>자바스크립트</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/175</guid>
<comments>https://itstory.tk/entry/JavaScript-ES6-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC#entry175comment</comments>
<pubDate>Fri, 15 Dec 2017 16:01:16 +0900</pubDate>
</item>
<item>
<title>[Javascript] for in vs for of 반복문</title>
<link>https://itstory.tk/entry/Javascript-for-in-vs-for-of-%EB%B0%98%EB%B3%B5%EB%AC%B8</link>
<description>&lt;h3 id=&quot;foreach-반복문&quot;&gt;foreach 반복문&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;foreach&lt;/code&gt; 반복문은 오직 Array 객체에서만 사용가능한 메서드입니다.(ES6부터는 Map, Set 등에서도 지원됩니다) 배열의 요소들을 반복하여 작업을 수행할 수 있습니다. &lt;code&gt;foreach&lt;/code&gt; 구문의 인자로 callback 함수를 등록할 수 있고, 배열의 각 요소들이 반복될 때 이 callback 함수가 호출됩니다. callback 함수에서 배열 요소의 인덱스와 값에 접근할 수 있습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var items = ['item1', 'item2', 'item3'];

items.forEach(function(item) {
    console.log(item);
});
// 출력 결과: item, item2, item3&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;for-in-반복문&quot;&gt;for …in 반복문&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;for in&lt;/code&gt; 반복문은 객체의 속성들을 반복하여 작업을 수행할 수 있습니다. 모든 객체에서 사용이 가능합니다. &lt;code&gt;for in&lt;/code&gt; 구문은 객체의 key 값에 접근할 수 있지만, value 값에 접근하는 방법은 제공하지 않습니다. 자바스크립트에서 객체 속성들은 내부적으로 사용하는 숨겨진 속성들을 가지고 있습니다. 그 중 하나가 &lt;code&gt;[[Enumerable]]&lt;/code&gt;이며, &lt;code&gt;for in&lt;/code&gt; 구문은 이 값이 &lt;code&gt;true&lt;/code&gt;로 셋팅되어 속성들만 반복할 수 있습니다. 이러한 속성들을 열거형 속성이라고 부르며, 객체의 모든 내장 메서드를 비롯해 각종 내장 프로퍼티 같은 비열거형 속성은 반복되지 않습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var obj = {
    a: 1, 
    b: 2, 
    c: 3
};

for (var prop in obj) {
    console.log(prop, obj[prop]); // a 1, b 2, c 3
}&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;for-of-반복문&quot;&gt;for …of 반복문&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;for of&lt;/code&gt; 반복문은 ES6에 추가된 새로운 컬렉션 전용 반복 구문입니다. &lt;code&gt;for of&lt;/code&gt; 구문을 사용하기 위해선 컬렉션 객체가 &lt;code&gt;[Symbol.iterator]&lt;/code&gt; 속성을 가지고 있어야만 합니다(직접 명시 가능).&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var iterable = [10, 20, 30];

for (var value of iterable) {
  console.log(value); // 10, 20, 30
}&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;for-in-반복문과-for-of-반복문의-차이점&quot;&gt;for in 반복문과 for of 반복문의 차이점&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;for in 반복문 : 객체의 모든 열거 가능한 속성에 대해 반복&lt;/li&gt;
&lt;li&gt;for of 반복문 : &lt;code&gt;[Symbol.iterator]&lt;/code&gt; 속성을 가지는 컬렉션 전용&lt;/li&gt;
&lt;/ul&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;Object.prototype.objCustom = function () {};
Array.prototype.arrCustom = function () {};

var iterable = [3, 5, 7];
iterable.foo = &quot;hello&quot;;

for (var key in iterable) {
  console.log(key); // 0, 1, 2, &quot;foo&quot;, &quot;arrCustom&quot;, &quot;objCustom&quot;
}

for (var value of iterable) {
  console.log(value); // 3, 5, 7
}&lt;/code&gt;&lt;/pre&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/174&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>자바스크립트</category>
<category>for in</category>
<category>for of</category>
<category>forEach</category>
<category>javascript</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/174</guid>
<comments>https://itstory.tk/entry/Javascript-for-in-vs-for-of-%EB%B0%98%EB%B3%B5%EB%AC%B8#entry174comment</comments>
<pubDate>Thu, 14 Dec 2017 14:48:48 +0900</pubDate>
</item>
<item>
<title>[Vue.js] Event Bus를 이용한 컴포넌트 간 통신</title>
<link>https://itstory.tk/entry/Vuejs-Event-Bus%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EA%B0%84-%ED%86%B5%EC%8B%A0</link>
<description>&lt;p&gt;Vue.js로 만든 어플리케이션이 규모가 커지게 되면 컴포넌트들을 분리함으로써 복잡성을 제어할 수 있습니다. 이를 통해 재사용성, 테스트 및 유지보수 용이라는 장점을 누릴 수 있습니다. 하지만 컴포넌트를 분리하면 각 컴포넌트 간의 통신은 더 불편해지게 됩니다. 이제 이벤트 버스(event bus)를 통해 이벤트 기반의 컴포넌트 간의 통신하는 방법을 살펴보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;vuejs-이벤트-인터페이스&quot;&gt;Vue.js 이벤트 인터페이스&lt;/h3&gt;

&lt;p&gt;Vue.js에는 다음과 같은 &lt;a href=&quot;https://kr.vuejs.org/v2/api/#%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8&quot;&gt;이벤트 인터페이스&lt;/a&gt;가 존재합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$on(eventName) : 이벤트 감지&lt;/li&gt;
&lt;li&gt;$emit(eventName) : 이벤트 트리거&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;동일 컴포넌트 내에서는 &lt;code&gt;$on&lt;/code&gt;과 &lt;code&gt;$emit&lt;/code&gt;을 이용하여 이벤트를 주고 받을 수 있습니다. 하지만 부모-자식 관계에서 &lt;code&gt;$on&lt;/code&gt;을 이용하여 자식 컴포넌트에서 호출한 이벤트는 감지할 수 없습니다. 부모 컴포넌트의 템플릿에서 &lt;code&gt;v-on&lt;/code&gt;을 사용하여 자식 컴포넌트에서 보내진 이벤트를 청취할 수 있습니다. 아래는 공홈에서 제공하는 예제입니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div id=&quot;counter-event-example&quot;&amp;gt;
  &amp;lt;p&amp;gt;{{ total }}&amp;lt;/p&amp;gt;
  &amp;lt;button-counter v-on:increment=&quot;incrementTotal&quot;&amp;gt;&amp;lt;/button-counter&amp;gt;
  &amp;lt;button-counter v-on:increment=&quot;incrementTotal&quot;&amp;gt;&amp;lt;/button-counter&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;Vue.component('button-counter', {
  template: '&amp;lt;button v-on:click=&quot;incrementCounter&quot;&amp;gt;{{ counter }}&amp;lt;/button&amp;gt;',
  data: function () {
    return {
      counter: 0
    }
  },
  methods: {
    incrementCounter: function () {
      this.counter += 1
      this.$emit('increment')
    }
  },
})

new Vue({
  el: '#counter-event-example',
  data: {
    total: 0
  },
  methods: {
    incrementTotal: function () {
      this.total += 1
    }
  }
})&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;비-부모-자식-컴포넌트-간의-통신&quot;&gt;비 부모-자식 컴포넌트 간의 통신&lt;/h3&gt;

&lt;p&gt;컴포넌트가 서로 부모/자식 관계가 아닐 경우, 간단한 시나리오에서는 &lt;strong&gt;비어있는 Vue 인스턴스를 중앙 이벤트 버스로 사용&lt;/strong&gt;할 수 있습니다. 아래의 예제는 공홈에서 제공하는 예제입니다. 대규모의 어플리케이션의 경우 &lt;a href=&quot;https://vuex.vuejs.org/kr/intro.html&quot;&gt;상태 관리 패턴(Vuex)&lt;/a&gt; 도입을 고려해보시는 것도 좋습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var bus = new Vue()

// 컴포넌트 A의 메소드
bus.$emit('id-selected', 1)

// 컴포넌트 B의 created 훅
bus.$on('id-selected', function (id) {
  // ...
})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 본격적인 사용법을 살펴보겠습니다. 프로젝트의 구조는 &lt;a href=&quot;http://itstory.tk/entry/vuecli-Webpack-템플릿으로-vuejs-개발환경-구축하기&quot;&gt;webpack 템플릿&lt;/a&gt;으로 생성된 기본 구조라고 가정하겠습니다. 전체 구조는 &lt;a href=&quot;http://itstory.tk/entry/vuecli-Webpack-템플릿으로-vuejs-개발환경-구축하기#프로젝트-구조&quot;&gt;링크&lt;/a&gt;를 참조하세요.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;.
├── src/
│   ├── main.js                 # app entry file
│   ├── App.vue                 # main app component
│   ├── components/             # ui components
│   │   └── A.vue               
│   │   └── B.vue
│   └── assets/                 # module assets (processed by webpack)
...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A.vue와 B.vue간의 통신이 필요하다고 가정합시다. 우선 &lt;code&gt;main.js&lt;/code&gt;에서 EventBus를 Vue prototype에 등록합니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;Vue.prototype.$EventBus = new Vue();

new Vue({
  el: '#app',
  router,
  template: '&amp;lt;App/&amp;gt;',
  components: { App },
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;A.vue&lt;/code&gt; 컴포넌트에 있는 버튼을 클릭할 때마다 &lt;code&gt;B.vue&lt;/code&gt;에 있는 dom이 토글되도록 이벤트를 전달하도록 하겠습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;// A.vue
&amp;lt;template&amp;gt;
    &amp;lt;button v-on:click=&quot;$EventBus.$emit('click-icon')&quot;&amp;gt;
        button
    &amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;&lt;/pre&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;// B.vue
&amp;lt;template&amp;gt;
    &amp;lt;div v-if=&quot;drawer&quot;&amp;gt;
        이제 나를 볼 수 있어요
    &amp;lt;/div&amp;gt;
    &amp;lt;div v-else&amp;gt;
        이제는 안보입니다
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        data() {
            return {
            drawer: true,
            };
        },
        created() {
            this.$EventBus.$on('click-icon', () =&amp;gt; {
                this.drawer = !this.drawer;
            });
        },
    };
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;App.vue&lt;/code&gt;에서 생성한 &lt;code&gt;A.vue&lt;/code&gt;와 &lt;code&gt;B.vue&lt;/code&gt;를 import하여 사용해 봅시다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;// App.vue
&amp;lt;template&amp;gt;
    &amp;lt;div id=&quot;app&quot;&amp;gt;
        &amp;lt;AA&amp;gt;&amp;lt;/AA&amp;gt;
        &amp;lt;BB&amp;gt;&amp;lt;/BB&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
    import AA from './components/A';
    import BB from './components/B';

    export default {
        name: 'app',
        components: {
            AA,
            BB,
        },
    };
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 dev server를 실행시켜 제대로 동작하는지 확인하는 일만 남았습니다. &lt;code&gt;npm run dev&lt;/code&gt;를 실행하면 다음과 같이 버튼을 클릭하면 글자가 토글되는 것을 확인하실 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/kkd927/vuejs-event-bus-example/master/doc/eventbus.gif&quot; alt=&quot;결과화면&quot; title=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;전체 코드는 &lt;a href=&quot;https://github.com/kkd927/vuejs-event-bus-example&quot;&gt;GitHub&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://itstory.tk/entry/vuecli-Webpack-템플릿으로-vuejs-개발환경-구축하기#프로젝트-구조&quot;&gt;[vue-cli] Webpack 템플릿으로 vue.js 개발환경 구축하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kr.vuejs.org/v2/guide/components.html#v-on%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A7%80%EC%A0%95-%EC%9D%B4%EB%B2%A4%ED%8A%B8&quot;&gt;v-on을 이용한 사용자 지정 이벤트&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kr.vuejs.org/v2/api/#%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8&quot;&gt;이벤트 인터페이스&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kr.vuejs.org/v2/guide/components.html#%EB%B9%84-%EB%B6%80%EB%AA%A8-%EC%9E%90%EC%8B%9D%EA%B0%84-%ED%86%B5%EC%8B%A0&quot;&gt;비 부모-자식간 통신&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://devblog.digimondo.io/building-a-simple-eventbus-in-vue-js-64b70fb90834&quot;&gt;Building a Simple Event Bus in Vue.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/173&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>자바스크립트</category>
<category>Event Bus</category>
<category>vue.js</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/173</guid>
<comments>https://itstory.tk/entry/Vuejs-Event-Bus%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EA%B0%84-%ED%86%B5%EC%8B%A0#entry173comment</comments>
<pubDate>Tue, 12 Dec 2017 17:19:02 +0900</pubDate>
</item>
<item>
<title>[vue-cli] Webpack 템플릿으로 vue.js 개발환경 구축하기</title>
<link>https://itstory.tk/entry/vuecli-Webpack-%ED%85%9C%ED%94%8C%EB%A6%BF%EC%9C%BC%EB%A1%9C-vuejs-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0</link>
<description>&lt;p&gt;이 글은 vue-cli 2버전에 대해서 다룹니다. 현재&amp;nbsp;webpack 4가 탑재된 &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;vue-cli 3버전&lt;/a&gt;이 나왔지만 베타(RC)버전입니다.&lt;/p&gt;


&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;이 환경 설정은 대형 프로젝트에 적합하며, Webpack 과 &lt;code&gt;vue-loader&lt;/code&gt;에 대한 사전지식이 있다고 가정하에 진행됩니다. 시작하기 전에 &lt;a href=&quot;https://vue-loader.vuejs.org/kr/start/spec.html&quot;&gt;vue-loader 문서&lt;/a&gt;를 먼저 읽어보는 것을 추천합니다.&lt;/p&gt;&lt;p&gt;Vue 프로젝트 템플릿은 빠르게 어플리케이션 코드를 작성할 수 있도록 대부분의 기능을 갖춘 개발 도구 설정을 제공합니다. &lt;code&gt;vue list&lt;/code&gt;를 실행하여 사용가능한 공식 템플릿을 확인할 수 있습니다. &lt;/p&gt;&lt;p&gt;현재 사용할 수 있는 템플릿 목록은 다음과 같으며 이 튜토리얼에서는 &lt;strong&gt;webpack 템플릿&lt;/strong&gt;을 이용하여 진행합니다. 만약 단순히 vue-loader를 경험하려고 하거나 빠른 프로토타입을 만드려는 상황이라면 &lt;a href=&quot;https://github.com/vuejs-templates/webpack-simple&quot;&gt;webpack-simple&lt;/a&gt; 템플릿을 사용하길 추천드립니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/vuejs-templates/webpack&quot;&gt;webpack&lt;/a&gt; - hot-reload, linting, 테스트 및 CSS 추출 기능을 갖춘 대부분의 기능을 갖추고 있는 Webpack + vue-loader 설정입니다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/vuejs-templates/webpack-simple&quot;&gt;webpack-simple&lt;/a&gt; - 단순히 Webpack과 vue-loader만 포함합니다. 빠르게 프로토타입을 만들 때 사용합니다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/vuejs-templates/browserify&quot;&gt;browserify&lt;/a&gt; - hot-reload, linting 및 단위 테스팅 등 대부분의 기능을 갖춘 Browserify + vueify 설정입니다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/vuejs-templates/browserify-simple&quot;&gt;browserify-simple&lt;/a&gt; 단순히 Browserify와 vueify만 포함합니다. 빠르게 프로토타입을 만들 때 사용합니다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/vuejs-templates/simple&quot;&gt;simple&lt;/a&gt; - 가장 단순하게 한 HTML 파일에 Vue 설정을 담고 있습니다.&lt;/li&gt;
&lt;/ul&gt;



&lt;h2 id=&quot;quickstart&quot;&gt;Quickstart&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;vue-cli&lt;/a&gt;를 이용하여 스캐폴딩을 진행할 것 입니다. 안정적인 디펜던시를 위해서 npm 3+를 사용하는 것을 추천합니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;$ npm install -g vue-cli
$ vue init webpack my-project
$ cd my-project
$ npm install
$ npm run dev&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;쉘에서 &lt;code&gt;vue init webpack my-project&lt;/code&gt;를 입력하면 아래와 같이 설정 인터페이스 화면이 나옵니다. 본인의 프로젝트에 맞게 설정하시면 됩니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;bash$ vue init webpack vue-test

? Project name vue-test
? Project description A Vue.js project
? Author kkd927@gmail.com
? Vue build standalone
? Install vue-router? Yes
? Use ESLint to lint your code? Yes
? Pick an ESLint preset Airbnb
? Set up unit tests Yes
? Pick a test runner karma
? Setup e2e tests with Nightwatch? Yes

   vue-cli · Generated &quot;vue-test&quot;.

   To get started:

     cd vue-test
     npm install
     npm run dev

   Documentation can be found at https://vuejs-templates.github.io/webpack&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;npm run dev&lt;/code&gt; 까지 실행하였다면 기본 준비는 모두 끝납니다. 커맨드 화면에 &lt;code&gt;Your application is running here: http://localhost:8080&lt;/code&gt;가 출력되는 것을 확인하실 수 있습니다. 브라우저에서 &lt;code&gt;http://localhost:8080&lt;/code&gt;에 접속하면 자동으로 구성된 화면이 뜨는 것을 볼 수 있습니다. 이제부터 추가설명을 진행할 것입니다.&lt;/p&gt;



&lt;h2 id=&quot;프로젝트-구조&quot;&gt;프로젝트 구조&lt;/h2&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;.
├── build/                      # webpack config files
│   └── ...
├── config/
│   ├── index.js                # main project config
│   └── ...
├── src/
│   ├── main.js                 # app entry file
│   ├── App.vue                 # main app component
│   ├── components/             # ui components
│   │   └── ...
│   └── assets/                 # module assets (processed by webpack)
│       └── ...
├── static/                     # pure static assets (directly copied)
├── test/
│   └── unit/                   # unit tests
│   │   ├── specs/              # test spec files
│   │   ├── eslintrc            # config file for eslint with extra settings only for unit tests
│   │   ├── index.js            # test build entry file
│   │   ├── jest.conf.js        # Config file when using Jest for unit tests
│   │   └── karma.conf.js       # test runner config file when using Karma for unit tests
│   │   ├── setup.js            # file that runs before Jest runs your unit tests
│   └── e2e/                    # e2e tests
│   │   ├── specs/              # test spec files
│   │   ├── custom-assertions/  # custom assertions for e2e tests
│   │   ├── runner.js           # test runner script
│   │   └── nightwatch.conf.js  # test runner config file
├── .babelrc                    # babel config
├── .editorconfig               # indentation, spaces/tabs and similar settings for your editor
├── .eslintrc.js                # eslint config
├── .eslintignore.js            # eslint ignore rules
├── .gitignore                  # sensible defaults for gitignore
├── .postcssrc.js               # postcss config
├── index.html                  # index.html template
├── package.json                # build scripts and dependencies
└── README.md                   # Default README file&lt;/code&gt;&lt;/pre&gt;



&lt;h4 id=&quot;buld&quot;&gt;&lt;code&gt;buld/&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;이 디렉터리는 개발용 서버와 배포용 웹팩 빌드에 대한 설정 파일들이 위치합니다. 웹팩 로더를 커스터마이징하지 않는다면 일반적으로 이 설정파일들 건들 필요가 없습니다. 필요하다면 &lt;code&gt;build/webpack.base.conf.js&lt;/code&gt; 파일을 확인해보시면 됩니다.&lt;/p&gt;



&lt;h4 id=&quot;configindexjs&quot;&gt;&lt;code&gt;config/index.js&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;이 파일은 빌드 단계에 대한 대부분의 설정들을 포함하고 있는 메인 설정 파일입니다.&lt;/p&gt;&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;#개발-환경에서의-api-proxy-설정&quot;&gt;개발 환경에서의 API Proxy 설정&lt;/a&gt;와 &lt;a href=&quot;#backend-프레임워크와-통합하기&quot;&gt;Backend 프레임워크와 통합하기&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h4 id=&quot;src&quot;&gt;&lt;code&gt;src/&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;여러분의 어플리케이션 소스 코드가 들어갈 디렉터리입니다. 이 디렉터리 하위의 구조를 어떻게 설계할지는 여러분 마음입니다. Vuex를 사용하려면 &lt;a href=&quot;https://vuex.vuejs.org/en/structure.html&quot;&gt;Vuex 어플리케이션을 위한 권고사항&lt;/a&gt;을 참고하세요.&lt;/p&gt;



&lt;h4 id=&quot;static&quot;&gt;&lt;code&gt;static/&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;이 디렉터리는 Webpack에 의해 처리될 필요가 없는 정적 파일들을 두는 곳입니다. 이 파일들은 웹펙이 파일들을 빌드할 때 같은 디렉터리로 단순히 복사만 됩니다.&lt;/p&gt;&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;#정적-자원-처리&quot;&gt;정적 자원 처리&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h4 id=&quot;testunit&quot;&gt;&lt;code&gt;test/unit&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;유닛 테스트 파일들이 위치하는 디렉터리입니다. 자세한 내용은 &lt;a href=&quot;https://vuejs-templates.github.io/webpack/unit.html&quot;&gt;Unit Testing&lt;/a&gt;을 참고하세요.&lt;/p&gt;



&lt;h4 id=&quot;teste2e&quot;&gt;&lt;code&gt;test/e2e&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;e2e 테스트 파일들이 위치하는 디렉터리입니다. 자세한 내용은 &lt;a href=&quot;https://vuejs-templates.github.io/webpack/e2e.html&quot;&gt;End-to-end Testing&lt;/a&gt;을 참고하세요.&lt;/p&gt;



&lt;h4 id=&quot;indexhtml&quot;&gt;&lt;code&gt;index.html&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;SPA(Single Page Application)을 위한 &lt;code&gt;index.html&lt;/code&gt; 템플릿입니다. 개발과 빌드를 진행할 때, 웹팩이 어플리케이션에 필요한 파일들을 생성하고 해당 파일들에 대한 URL들을 자동으로 이 템플릿 파일에 주입하여 최종 HTML 파일을 생성합니다.&lt;/p&gt;



&lt;h4 id=&quot;packagejson&quot;&gt;&lt;code&gt;package.json&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;빌드 디펜던시와 &lt;a href=&quot;#빌드-명렁어&quot;&gt;빌드 명령어&lt;/a&gt;들이 포함되는 NPM 패키지 메타 파일입니다.&lt;/p&gt;&lt;p&gt;&lt;script async=&quot;&quot; src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block; text-align:center;&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-8876596272501347&quot; data-ad-slot=&quot;7399807364&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/p&gt;

&lt;h2 id=&quot;빌드-명령어&quot;&gt;빌드 명령어&lt;/h2&gt;

&lt;p&gt;빌드 명령어는 &lt;a href=&quot;https://docs.npmjs.com/misc/scripts&quot;&gt;NPM Scripts&lt;/a&gt;를 통해 실행됩니다.&lt;/p&gt;



&lt;h4 id=&quot;npm-run-dev&quot;&gt;&lt;code&gt;npm run dev&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;Node.js 로컬 개발 서버를 실행시킵니다. 자세한 내용은 &lt;a href=&quot;#개발-환경에서의-api-proxy-설정&quot;&gt;개발 환경에서의 API Proxy 설정&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h4 id=&quot;npm-run-build&quot;&gt;&lt;code&gt;npm run build&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;배포를 위한 빌드. 자세한 내용은 &lt;a href=&quot;#backend-프레임워크와-통합하기&quot;&gt;Backend 프레임워크와 통합하기&lt;/a&gt;를 참고하세요.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UglifyJS v3를 이용한 Javascript 압축&lt;/li&gt;
&lt;li&gt;html-minifier를 이용한 HTML 압축&lt;/li&gt;
&lt;li&gt;각 컴포넌트에 존재하는 CSS들을 하나의 파일로 병합 후 cssnano를 이용한 압축&lt;/li&gt;
&lt;li&gt;효율적인 캐싱을 위해 모든 정적 파일들을 버전 해슁을 통해 컴파일하여 해당 URL들을 index.html에 자동 적용&lt;/li&gt;
&lt;/ul&gt;



&lt;h4 id=&quot;npm-run-unit&quot;&gt;&lt;code&gt;npm run unit&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;유닛 테스트를 실행. 자세한 내용은 &lt;a href=&quot;https://vuejs-templates.github.io/webpack/unit.html&quot;&gt;Unit Testing&lt;/a&gt;을 참고하세요.&lt;/p&gt;



&lt;h4 id=&quot;npm-run-e2e&quot;&gt;&lt;code&gt;npm run e2e&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;Nightwatch를 이용하여 end-to-end 테스트 실행. 자세한 내용은 &lt;a href=&quot;https://vuejs-templates.github.io/webpack/e2e.html&quot;&gt;End-to-end Testing&lt;/a&gt;을 참고하세요.&lt;/p&gt;



&lt;h4 id=&quot;npm-run-lint&quot;&gt;&lt;code&gt;npm run lint&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;eslint를 실행하여 코드의 린트 에러를 보여줍니다. 자세한 내용은 &lt;a href=&quot;https://vuejs-templates.github.io/webpack/linter.html&quot;&gt;Linter Configuration&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h2 id=&quot;정적-자원-처리&quot;&gt;정적 자원 처리&lt;/h2&gt;

&lt;p&gt;프로젝트 구조를 보면 정적 자원들을 위한 &lt;code&gt;src/assets&lt;/code&gt;와 &lt;code&gt;static/&lt;/code&gt; 2개의 디렉터리가 잇는 것을 확인할 수 있습니다. 이 둘의 차의점은 웹펙에 의해 처리되느냐 안되느냐의 차이점입니다.&lt;/p&gt;



&lt;h4 id=&quot;웹팩에-처리되는-자원들&quot;&gt;웹팩에 처리되는 자원들&lt;/h4&gt;

&lt;p&gt;우선 웹팩이 정적 자원들을 어떻게 처리하는지 이해할 필요가 있습니다. &lt;code&gt;*.vue&lt;/code&gt; 컴포넌트 안에서 모든 html 템플릿과 CSS들은 URL 경로를 찾기 위해 &lt;code&gt;vue-html-loader&lt;/code&gt;와 &lt;code&gt;css-loader&lt;/code&gt;에 의해 분석됩니다. 예를들어 &lt;code&gt;&amp;lt;img src=&quot;./logo.png&quot;&amp;gt;&lt;/code&gt;, &lt;code&gt;background: url(./logo.png)&lt;/code&gt;에서 &lt;code&gt;&quot;./logo.png&quot;&lt;/code&gt;는 상대 경로를 나타내며 모듈 디펜던시로 웹팩에 의해 처리됩니다.&lt;/p&gt;&lt;p&gt;왜냐하면 &lt;code&gt;logo.png&lt;/code&gt;는 자바스크립트가 아니기 때문에 모듈 디펜던시로 취급되어 &lt;code&gt;url-loader&lt;/code&gt;와 &lt;code&gt;file-loader&lt;/code&gt;로 처리할 필요가 있습니다. 이 로더들은 기본적으로 탑재되어 있기 때문에 배포를 위해 상대/모듈 경로를 신경쓸 필요가 없습니다.&lt;/p&gt;



&lt;h4 id=&quot;실제-정적-자원들&quot;&gt;실제 정적 자원들&lt;/h4&gt;

&lt;p&gt;위와는 반대로 &lt;code&gt;static/&lt;/code&gt;에 위치하는 파일들은 웹팩에 의해 처리되지 않습니다. 이들은 최종 경로에 같은 이름으로 복사됩니다. &lt;code&gt;config.js&lt;/code&gt;에 있는 &lt;code&gt;build.assetsPublicPath&lt;/code&gt;와 &lt;code&gt;build.assetsSubDirectory&lt;/code&gt;에 의해 결정되어지는 절대경로를 이용하여 이 파일들에 접근할 수 있습니다.&lt;/p&gt;&lt;p&gt;아래는 기본 값으로 설정되어 있는 예시입니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// config/index.js
module.exports = {
  // ...
  build: {
    assetsPublicPath: '/',
    assetsSubDirectory: 'static'
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 구성을 따르면 &lt;code&gt;static/&lt;/code&gt;에 위치하는 파일들은 절대 경로인 &lt;code&gt;/static/[filename]&lt;/code&gt;으로 접근할 수 있습니다. 만약 &lt;code&gt;assetsSubDirectory&lt;/code&gt;를 assets으로 바꾼다면 &lt;code&gt;/assets/[filename]&lt;/code&gt;으로 파일에 접근할 수 있습니다.&lt;/p&gt;&lt;p&gt;자세한 내용은 &lt;a href=&quot;#backend-프레임워크와-통합하기&quot;&gt;Backend 프레임워크와 통합하기&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h2 id=&quot;환경-변수&quot;&gt;환경 변수&lt;/h2&gt;

&lt;p&gt;보통 test, development, production 환경에 따라 다른 구성이 필요할 때가 많습니다. 자바 개발자라면 maven profile와 같다고 생각하시면 됩니다.&lt;/p&gt;&lt;p&gt;예를들어 아래와 같이 설정하면&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// config/prod.env.js
module.exports = {
  NODE_ENV: '&quot;production&quot;',
  DEBUG_MODE: false,
  API_KEY: '&quot;...&quot;' // this is shared between all environments
}

// config/dev.env.js
module.exports = merge(prodEnv, {
  NODE_ENV: '&quot;development&quot;',
  DEBUG_MODE: true // this overrides the DEBUG_MODE value of prod.env
})

// config/test.env.js
module.exports = merge(devEnv, {
  NODE_ENV: '&quot;testing&quot;'
})&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;주의: string 변수는 &lt;code&gt;'&quot;...&quot;'&lt;/code&gt;로 사용해야합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위의 설정은 다음과 같이 해석됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Production &lt;br /&gt;
&lt;ul&gt;&lt;li&gt;NODE_ENV = ‘production’,&lt;/li&gt;
&lt;li&gt;DEBUG_MODE = false,&lt;/li&gt;
&lt;li&gt;API_KEY = ‘…’&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Development &lt;br /&gt;
&lt;ul&gt;&lt;li&gt;NODE_ENV = ‘development’,&lt;/li&gt;
&lt;li&gt;DEBUG_MODE = true,&lt;/li&gt;
&lt;li&gt;API_KEY = ‘…’&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Testing &lt;br /&gt;
&lt;ul&gt;&lt;li&gt;NODE_ENV = ‘testing’,&lt;/li&gt;
&lt;li&gt;DEBUG_MODE = true,&lt;/li&gt;
&lt;li&gt;API_KEY = ‘…’&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉, &lt;code&gt;test.env&lt;/code&gt;는 &lt;code&gt;dev.env&lt;/code&gt;를 상속받으며, &lt;code&gt;dev.env&lt;/code&gt;는 &lt;code&gt;prod.env&lt;/code&gt;를 상속 받습니다.&lt;/p&gt;&lt;p&gt;코드에서 다음과 같이 환경 변수를 사용할 수 있습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;Vue.config.productionTip = process.env.NODE_ENV === 'production'&lt;/code&gt;&lt;/pre&gt;



&lt;h2 id=&quot;backend-프레임워크와-통합하기&quot;&gt;Backend 프레임워크와 통합하기&lt;/h2&gt;

&lt;p&gt;만약 정말 순수한 정적앱(backend API와 독립적인)을 만든다면, &lt;code&gt;config/index.js&lt;/code&gt;를 수정할 필요가 없습니다. 만약 Rails/Django/Laravel/Spring 같이 자신만의 프로젝트 구조를 갖는 backend 프레임워크와 통합한다면, frontend 파일들을 backend 프로젝트에 넣기 위해서는 &lt;code&gt;config/index.js&lt;/code&gt;를 수정해야합니다.&lt;/p&gt;&lt;p&gt;아래는 &lt;code&gt;config/index.js&lt;/code&gt;의 기본 값입니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// config/index.js
'use strict'
const path = require('path')

module.exports = {
  dev: {
    // Paths
    assetsSubDirectory: 'static',
    assetsPublicPath: '/',
    proxyTable: {},

    // Various Dev Server settings
    host: 'localhost',
    port: 8080, 

    // skipping other options as they are only convenience features
  },
  build: {
    // Template for index.html
    index: path.resolve(__dirname, '../dist/index.html'),

    // Paths
    assetsRoot: path.resolve(__dirname, '../dist'),
    assetsSubDirectory: 'static',
    assetsPublicPath: '/',

    productionSourceMap: true,

    // skipping the rest ...
  },
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;build&lt;/code&gt; 부분에는 아래와 같은 옵션 값들을 가집니다.&lt;/p&gt;



&lt;h4 id=&quot;buildindex&quot;&gt;&lt;code&gt;build.index&lt;/code&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;로컬 파일시스템의 절대경로이어야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;index.html&lt;/code&gt; (asset URL이 주입되는) 템플릿이 생성되는 위치를 지정합니다.&lt;/p&gt;&lt;p&gt;만약 backend 프레임워크와 함께 사용중이라면, backend 앱의 view 파일들을 두는 디렉터리 안으로 수정해야 합니다. 예들들어, Rails의 경우 &lt;code&gt;app/views/layouts/application.html.erb&lt;/code&gt;와 같이 변경해야되고, Laravel의 경우 &lt;code&gt;resources/views/index.blade.php&lt;/code&gt;입니다.&lt;/p&gt;



&lt;h4 id=&quot;buildassetsroot&quot;&gt;&lt;code&gt;build.assetsRoot&lt;/code&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;로컬 파일시스템의 절대경로이어야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앱의 모든 정적 자산들을 포함하는 최상위 디렉터리 경로입니다. 예를들어, Rails/Laravel의 경우 &lt;code&gt;public/&lt;/code&gt;이 되어야 합니다.&lt;/p&gt;



&lt;h4 id=&quot;buildassetssubdirectory&quot;&gt;&lt;code&gt;build.assetsSubDirectory&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;build.assetsRoot&lt;/code&gt;의 하위에 위치하는 웹팩에 의해 처리되는 자원들의 경로입니다. 예를들어, &lt;code&gt;build.assetsRoot&lt;/code&gt;를 &lt;code&gt;/path/to/dist&lt;/code&gt;로 설정하고 &lt;code&gt;build.assetsSubDirectory&lt;/code&gt;를 &lt;code&gt;static&lt;/code&gt;으로 설정하면, 웹팩에 의해 처리되는 자원들은 &lt;code&gt;path/to/dist/static&lt;/code&gt;에 위치하게 됩니다.&lt;/p&gt;&lt;p&gt;이 디렉터리는 항상 빌드 되기전에 내용이 전부 비워지고 빌드에 의해 생성되는 자원들이 새로 들어가게 됩니다.&lt;/p&gt;&lt;p&gt;&lt;code&gt;static/&lt;/code&gt;에 위치하는 정적 자원들은 빌드 시 이 디렉터리로 복사 되어집니다. 그래서 만약 이 설정을 바꾼다면, &lt;code&gt;static/&lt;/code&gt; 하위에 있는 정적 자원들에 접근하기 위한 모든 절대 경로들도 수정해줘야 합니다. 자세한 내용은 &lt;a href=&quot;#정적-자원-처리&quot;&gt;정적 자원 처리&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h4 id=&quot;buildassetspublicpath&quot;&gt;&lt;code&gt;build.assetsPublicPath&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;HTTP를 통해 &lt;code&gt;build.assetsRoot&lt;/code&gt; 자원들에 접근할 수 있는 경로를 설정하는 옵션입니다. 대부분의 경우 &lt;code&gt;/&lt;/code&gt;를 사용하면 됩니다. 만약 여러분이 사용하고 있는 backend 프레임워크가 정적 자원들의 접근하기 위해 별도의 경로 prefix를 가지는 경우에만 수정하세요.&lt;/p&gt;



&lt;h4 id=&quot;buildproductionsourcemap&quot;&gt;&lt;code&gt;build.productionSourceMap&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;배포용 빌드에 대한 소스 맵을 생성할지 여부입니다.&lt;/p&gt;



&lt;h4 id=&quot;devport&quot;&gt;&lt;code&gt;dev.port&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;개발용 서버의 포트를 지정합니다.&lt;/p&gt;



&lt;h4 id=&quot;devproxytable&quot;&gt;&lt;code&gt;dev.proxyTable&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;개발용 서버를 위한 proxy 규칙들을 정의합니다. 자세한 내용은 &lt;a href=&quot;#개발-환경에서의-api-proxy-설정&quot;&gt;개발 환경에서의 API Proxy 설정&lt;/a&gt;를 참고하세요.&lt;/p&gt;



&lt;h2 id=&quot;개발-환경에서의-api-proxy-설정&quot;&gt;개발 환경에서의 API Proxy 설정&lt;/h2&gt;

&lt;p&gt;이미 backend가 구축되어 있는 상황에서 이 보일러플레이트(webpack 템플릿)를 통합할 때는 개발서버에서 backend API에 접근해야하는 경우가 일반적입니다. 이를 위해서는 개발서버가 실제 backend를 바라볼 수 있도록 proxy 설정을 진행해야 합니다. (보통 backend 개발용 서버를 별도로 구축하는 것이 일반적이기 때문에, node.js 개발 서버가 backend 개발 서버를 바라보도록 proxy 설정을 하면 됩니다.)&lt;/p&gt;&lt;p&gt;proxy 룰을 설정하기 위해서는 &lt;code&gt;config/index.js&lt;/code&gt;에 있는 &lt;code&gt;dev.proxyTable&lt;/code&gt; 옵션을 수정해야 합니다. 개발서버는 &lt;a href=&quot;https://github.com/chimurai/http-proxy-middleware&quot;&gt;http-proxy-middleware&lt;/a&gt;를 이용하여 proxy를 처리하기 때문에 상세내용은 해당 문서를 참고할 필요가 있습니다. 간단한 예는 다음와 같습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// config/index.js
module.exports = {
  // ...
  dev: {
    proxyTable: {
      // proxy all requests starting with /api to jsonplaceholder
      '/api': {
        target: 'http://jsonplaceholder.typicode.com',
        changeOrigin: true,
        pathRewrite: {
          '^/api': ''
        }
      }
    }
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 예제에서 &lt;code&gt;/api/posts/1&lt;/code&gt;에 대한 요청은 &lt;code&gt;http://jsonplaceholder.typicode.com/posts/1&lt;/code&gt;로 프록시 처리되게 됩니다.&lt;/p&gt;



&lt;h4 id=&quot;url-매칭&quot;&gt;URL 매칭&lt;/h4&gt;

&lt;p&gt;추가적으로 정적 url에 &lt;code&gt;/api/**&lt;/code&gt;와 같은 glob 패턴을 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://github.com/chimurai/http-proxy-middleware#context-matching&quot;&gt;Context Matching&lt;/a&gt;을 참고하세요. 추가적으로 프록시가 처리되어할 요청을 결정하기 위해 &lt;code&gt;filter&lt;/code&gt; 옵션을 통해 custom 함수를 제공할 수 있습니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;proxyTable: {
  '**': {
    target: 'http://jsonplaceholder.typicode.com',
    filter: function (pathname, req) {
      return pathname.match('^/api') &amp;amp;&amp;amp; req.method === 'GET'
    }
  }
}&lt;/code&gt;&lt;/pre&gt;



&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://vuejs-templates.github.io/webpack/&quot;&gt;https://vuejs-templates.github.io/webpack/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/vuejs-kr/vue-cli&quot;&gt;https://github.com/vuejs-kr/vue-cli&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://vue-loader.vuejs.org/kr/start/spec.html&quot;&gt;https://vue-loader.vuejs.org/kr/start/spec.html&lt;/a&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/172&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>자바스크립트</category>
<category>vue-cli</category>
<category>vuejs</category>
<category>webpack</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/172</guid>
<comments>https://itstory.tk/entry/vuecli-Webpack-%ED%85%9C%ED%94%8C%EB%A6%BF%EC%9C%BC%EB%A1%9C-vuejs-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0#entry172comment</comments>
<pubDate>Tue, 05 Dec 2017 16:02:02 +0900</pubDate>
</item>
<item>
<title>[IntelliJ] ESLint autofix 단축키</title>
<link>https://itstory.tk/entry/IntelliJ-ESLint-autofix-%EB%8B%A8%EC%B6%95%ED%82%A4</link>
<description>&lt;p&gt;JetBrains에서 제공하는 IDE에서 ESLint의 설정된 룰에 맞게 자동으로 보정해주는&amp;nbsp;ESLint autofix 기능을 제공합니다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;IntelliJ 혹은 WebStrom에서 사용할 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;b&gt;ESLint 경고가 뜨는 곳에서 ALT + ENTER 키&lt;/b&gt;를 누르면 다음과 같은 화면이 뜹니다.&lt;/p&gt;&lt;p&gt;그리고 &lt;b&gt;ESLint: Fix current file&lt;/b&gt; 을 눌러주면 끝입니다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:728px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F99950C335A1FCB58309502&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99950C335A1FCB5830&quot; filemime=&quot;image/jpeg&quot; filename=&quot;eslint_autofix.png&quot; height=&quot;298&quot; width=&quot;728&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;그러면 다음과 같이 설정에 맞게 알아서 수정이 됩니다.&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:593px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F99AA7F335A1FCBD91F87A7&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99AA7F335A1FCBD91F&quot; filemime=&quot;image/jpeg&quot; filename=&quot;eslint_autofix2.png&quot; height=&quot;300&quot; width=&quot;593&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;참고로 WebStrom은 2016.3 버전 이상에서만 기본으로 탑재되어 있다고 합니다.&lt;/p&gt;&lt;p&gt;WebStrom 2016.3 이하의 버전에서 ESLint autofix 기능을 사용하고 싶으면 다음의 링크를 통해 설정하시면 됩니다.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.jetbrains.com/webstorm/2016/08/using-external-tools/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://blog.jetbrains.com/webstorm/2016/08/using-external-tools/&lt;/a&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/171&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>자바스크립트</category>
<category>ESLint autofix</category>
<category>IntelliJ</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/171</guid>
<comments>https://itstory.tk/entry/IntelliJ-ESLint-autofix-%EB%8B%A8%EC%B6%95%ED%82%A4#entry171comment</comments>
<pubDate>Thu, 30 Nov 2017 18:16:02 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙27. 가능하면 제네릭 메서드로 만들 것</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9927-%EA%B0%80%EB%8A%A5%ED%95%98%EB%A9%B4-%EC%A0%9C%EB%84%A4%EB%A6%AD-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C-%EB%A7%8C%EB%93%A4-%EA%B2%83</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;제네릭화(genericfication)&lt;/strong&gt;로 혜택을 보는 것은 클래스뿐만 아니다. 메서드도 혜택을 본다. static 유틸리티 메서드는 특히 제네릭화하기 좋은 후보다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 무인자 자료형 사용 - 권할 수 없는 방법(규칙23)
public static Set union(Set s1, Set s2) {
  Set result = new HashSet(s1);
  result.addAll(s2);
  return result;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;형인자를 선언하는 &lt;strong&gt;형인자 목록(type parameter list)&lt;/strong&gt;은 메서드의 수정자(modifier)와 반환값 자료형 사이에 둔다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 제네릭 메서드
public static &amp;lt;E&amp;gt; Set&amp;lt;E&amp;gt; union(Set&amp;lt;E&amp;gt; s1, Set&amp;lt;E&amp;gt; s2) {
  Set&amp;lt;E&amp;gt; result = new HashSet&amp;lt;E&amp;gt;(s1);
  result.addAll(s2);
  return result;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;컴파일러는 union에 전달된 두 인자의 자료형으로 E의 자료형을 알아낼 수 있다. 이 과정을 &lt;strong&gt;자료형 유추(type inference)&lt;/strong&gt;라 한다.&lt;/p&gt;&lt;p&gt;제네릭 생성자를 호출할 때는 형인자를 명시적으로 전달해야되는데, 성가신 일일 수 있다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 생성자를 통한 형인자 자료형 객체 생성
Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; anagrams =
  new HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이런 번거로움을 피하려면, 사용할 생성자마다 제네릭 정적 팩터리 메서드(generic static factory method)를 만들면 된다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 제네릭 정적 팩터리 메서드
public static &amp;lt;K,V&amp;gt; HashMap&amp;lt;K,V&amp;gt; newHashMap() {
  return new HashMap&amp;lt;K,V&amp;gt;();
}

// 사용
Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; anagrams = newHashMap();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자바 1.7부터는 제네릭 자료형의 생성자에도 자료형 추론이 지원된다(&lt;a href=&quot;http://www.javaworld.com/article/2074080/core-java/jdk-7--the-diamond-operator.html&quot;&gt;다이아몬드 연산자&lt;/a&gt;).&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 다이아몬드 연산자
Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; anagrams = new HashMap&amp;lt;&amp;gt;();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;상대적으로 사용 빈도가 낮긴 하나, 형인자가 포함된 표현식으로 형인자를 한정하는 것도 가능하다. 이런 용볍을 &lt;strong&gt;재귀적 자료형 한정(recursive type bound)&lt;/strong&gt;이라 한다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 재귀적 자료형 한정
public interface Comparable&amp;lt;T&amp;gt; {
  int compareTo(T o);
}&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;제네릭 자료형이나 제네릭 메서드는 클라이언트가 직접 입력 값과 반환값의 자료형을 형변환해야 하는 메서드보다 사용하기 쉽고 형 안정성도 높다&lt;/li&gt;
&lt;li&gt;자료형을 만들 때처럼, 새로운 메서드를 고안할 때는 형변환 없이도 사용할 수 있을지 살펴보라 &lt;br /&gt;
(제네릭으로 만드는 것이 좋겠다는 판단을 내리게 될 때가 많을 것이다)&lt;/li&gt;
&lt;li&gt;자료형의 경우와 마찬가지로, 시간 날 때 기존 메서드를 제네릭 메서드로 확장해 높으면 기존 클라이언트 코드를 깨지 않고도 새 사용자에게 더 좋은 API를 제공할 수 있게 될 것이다&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/169&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/169</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9927-%EA%B0%80%EB%8A%A5%ED%95%98%EB%A9%B4-%EC%A0%9C%EB%84%A4%EB%A6%AD-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C-%EB%A7%8C%EB%93%A4-%EA%B2%83#entry169comment</comments>
<pubDate>Tue, 28 Nov 2017 17:48:57 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙26. 가능하면 제네릭 자료형으로 만들 것</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9926-%EA%B0%80%EB%8A%A5%ED%95%98%EB%A9%B4-%EC%A0%9C%EB%84%A4%EB%A6%AD-%EC%9E%90%EB%A3%8C%ED%98%95%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4-%EA%B2%83</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;제네릭 자료형을 직접 만드는 것은 까다로운데, 배워둘 만한 가치는 있다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// Object를 사용한 컬렉션 - 제네릭을 적용할 중요 후보
public class Stack {
  private Object[] elements;
  private int size = 0;
  private static final int DEFAULT_INITIAL_CAPACITY = 16;

  public stack() {
    elements = new Object[DEFAULT_INITIAL_CAPACITY];
  }

  public void push(Object e) {
    ensureCapacity();
    elements[size++] = e;
  }

  public Object pop() {
    if (size == 0)
      throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null; // 만기 참조 제거
    return result;
  }

  public boolean isEmpty() {
    return size == 0;
  }

  private void ensureCapacity() {
    if (elements.length == size)
      elements = Arrays.copyOf(elements, 2 * size + 1);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;클래스를 제네릭화하는 첫 번째 단계는 선언부에 형인자(type parameter)를 추가하는 것이다. 관습적으로 이름은 E라고 붙인다(규칙56). 다음 단계는 Object를 자료형으로 사용하는 부분들을 전부 찾아서, 형인자 E로 대체하고 컴파일해 보는 것이다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 제네릭을 사용해 작성한 최초 Stack 클래스 - 컴파일되지 않는다
public class Stack&amp;lt;E&amp;gt; {
  private E[] elements;
  private int size = 0;
  private static final int DEFAULT_INITIAL_CAPACITY = 16;

  public stack() {
    elements = new E[DEFAULT_INITIAL_CAPACITY];
  }

  public void push(E e) {
    ensureCapacity();
    elements[size++] = e;
  }

  public E pop() {
    if (size == 0)
      throw new EmptyStackException();
    E result = elements[--size];
    elements[size] = null; // 만기 참조 제거
    return result;
  }

  // ... 이하 동일
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;보통 하나 이상의 오류나 경고 메시지를 만나게 될 것이다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 오류
  Stack.java:8: generic array creation
          elements = new E[DEFAULT_INITIAL_CAPACITY];&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;규칙25에서 설명한 대로, &lt;strong&gt;E&lt;/strong&gt; 같은 실체화 불가능 자료형으로는 배열을 생성할 수 없다.&lt;/p&gt;&lt;p&gt;첫번째 해결책은 Object의 배열을 만들어서 제네릭 배열 자료형으로 형변환하는 방법이다. 문법적으로는 문제는 없지만, 일반적으로 형 안정성을 보장하는 방법은 아니다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;무점검 형변환(unchecked cast)을 하기 전에 개발자는 반드시 그런 형변환이 프로그램의 형 안정성을 해치지 않음을 확실히 해야 한다. 무점검 형변환이 안전함을 증명했다면, 경고를 억제하되 범위는 최소한으로 줄여야 한다.(규칙24)&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// elements 배열에 push(E)를 통해 전달된 E 형의 객체만 저장된다.
// 이 정도면 형 안전성은 보장할 수 있지만, 배열의 실행시간 자료형은 E[]가
// 아니라 항상 Object[]이다!
@SuppressWarnings(&quot;unchecked&quot;)
public Stack() {
  elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;두번째 해결책은 elements의 자료형을 E[]에서 Object[]로 바꾸는 것이다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 오류
Stack.java:19: incompatible types
found   : Object,   required: E
      E result = elements[--size];
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;배열에서 꺼낸 원소의 자료형을 Object에서 E로 변환하도록 코드를 수정하면, 이 오류는 경로 바뀐다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;Stack.java:19: warning: [unchecked] unchecked cast
found   : Object,  required: E
        E result = (E) elements[--size];&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E는 실체화 불가능 자료형이므로 컴파일러는 이 형변환을 실행 중에 검사할 수 없다. 하지만 위의 무점검 형변환이 안전하다는 것, 그래서 경고를 억제해도 좋다는 것은 개발자 스스로 쉽게 입증할 수 있다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 무점검 경고를 적절히 억제한 사례
public E pop() {
  if (size == 0)
    throw new EmptyStackException();

  // 자료형이 E인 원소만 push하므로, 아래의 형변환은 안전하다.
  @SuppressWarnings(&quot;unchecked&quot;) E result = (E) elements[--size];

  elements[size] = null; // 만기 참조 제거
  return result;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;제네릭 배열 생성 오류를 피하는 두 방법 가운데 어떤 것을 쓸지는 대체로 취향 문제다. 첫 번째 해법을 적용하면 E[]로 한 번만 형변환을 하면 되겠지만, 두 번째 해법을 쓰면 코드 여기저기서 E로 형변환을 해야한다. 그래서 첫 번째 방법이 좀 더 보편적으로 쓰이는 이유다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 제네릭 Stack의 사용 예
public static void main(String[] args) {
  Stack&amp;lt;String&amp;gt; stack = new Stack&amp;lt;String&amp;gt;();
  for (String arg : args)
    stack.push(arg);
  while (!stack.isEmpty())
    System.out.println(stack.pop().toUpperCase());
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;방금 살펴본 Stack과 같은 제네릭 자료형 거의 대부분은 형인자에 어떤 자료형도 쓸 수 있다. Stack&amp;lt;Object&amp;gt;, Stack&amp;lt;int[]&amp;gt;, Stack&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; 등, 객체 참조에 사용할 수 있는 자료형이면 아무것이나 된다. &lt;/p&gt;&lt;p&gt;기본 자료형은 자바 제네릭 자료형 시스템의 근본적 한계 때문에 사용이 불가능하지만, 이런 제약을 피하려면 객체화된 기본 자료형(boxed primitive type)을 사용하면 된다(규칙49).&lt;/p&gt;



&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;제네릭 자료형은 클라이언트가 형변환을 해야만 사용할 수 있는 자료형보다 안전할 뿐 아니라 사용하기도 쉽다&lt;/li&gt;
&lt;li&gt;새로운 자료형을 설계할 때는 형변환 없이도 사용할 수 있도록 하라 (그러려면 제네릭 자료형으로 만들어야할 때가 많을 것이다)&lt;/li&gt;
&lt;li&gt;시간 있을 때마다 기존 자료형을 제네릭 자료형으로 변환하라&lt;/li&gt;
&lt;li&gt;기존 클라이언트 코드를 깨지 않고도 새로운 사용자에게 더 좋은 API를 제공할 수 있게 될 것이다(규칙23).&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/168&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/168</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9926-%EA%B0%80%EB%8A%A5%ED%95%98%EB%A9%B4-%EC%A0%9C%EB%84%A4%EB%A6%AD-%EC%9E%90%EB%A3%8C%ED%98%95%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4-%EA%B2%83#entry168comment</comments>
<pubDate>Tue, 28 Nov 2017 16:29:25 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙25. 배열 대신 리스트를 써라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9925-%EB%B0%B0%EC%97%B4-%EB%8C%80%EC%8B%A0-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%8D%A8%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;배열은 제네릭 자료형과 두 가지 중요한 차이점을 갖고 있다.&lt;/p&gt;

&lt;h4 id=&quot;1-배열은-공변-자료형convariant인-반면-제네릭은-불변-자료형invariant이다&quot;&gt;1. 배열은 공변 자료형(convariant)인 반면, 제네릭은 불변 자료형(invariant)이다&lt;/h4&gt;

&lt;p&gt;Sub가 Super의 하위 자료형(subtype)이면 Sub[]도 Super[]의 하위 자료형이다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 실행 중에 문제를 일으킴
Object[] objectArray = new Long[1];
objectArray[0] = &quot;I don't fit in&quot; // ArrayStoreException 예외 발생&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Type1과 Type2가 있을 때, List&amp;lt;Type1&amp;gt;은 List&amp;lt;Type2&amp;gt;의 상위 자료형이나 하위 자료형이 될 수 없다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 컴파일 되지 않는 코드
List&amp;lt;Object&amp;gt; ol = new ArrayList&amp;lt;Long&amp;gt;(); // 자료형 불일치
ol.add(&quot;I don't fit in&quot;);&lt;/code&gt;&lt;/pre&gt;



&lt;h4 id=&quot;2-배열은-실체화reification가-되는-자료형인-반면-제네릭은-삭제erasure-과정을-통해-구현된다&quot;&gt;2. 배열은 실체화(reification)가 되는 자료형인 반면, 제네릭은 삭제(erasure) 과정을 통해 구현된다&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;배열의 각 원소의 자료형은 실행시간(runtime)에 결정된다. &lt;/li&gt;
&lt;li&gt;제네릭의 자료형에 관계된 조건들은 컴파일 시점에만 적용되고, 그 각 원소의 자료형 정보는 프로그램이 실행될 때는 삭제된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이런 기본적인 차이점 때문에 배열과 제네릭은 섞어 쓰기 어렵다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 제네릭 배열 생성이 허용되지 않는 이유 - 아래의 코드는 컴파일되지 않는다
List&amp;lt;String&amp;gt;[] stringLists = new List&amp;lt;String&amp;gt;[1];
List&amp;lt;Integer&amp;gt; intList = Arrays.asList(42);
Object[] objects = stringLists;
objects[0] = intList;
String s = stringLists[0].get(0);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;제네릭 자료형에 담긴 원소들의 자료형으로&amp;nbsp;만든 배열을 반환하는 것은 일반적으로 불가능하다(규칙29에 부분적인 해결방안을 제시했다)&lt;/p&gt;&lt;p&gt;제네릭 배열 생성 오류에 대한 가장 좋은 해결책은 보통 E[] 대신 List&amp;lt;E&amp;gt;를 쓰는 것이다. 성능이 저하되거나 코드가 길어질 수는 있겠으나, 형 안전성과 호환성은 좋아진다.&lt;/p&gt;



&lt;h4 id=&quot;요약&quot;&gt;요약&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;제네릭과 배열이 따르는 자료형 규칙은 서로 많이 다르다 &lt;br /&gt;
&lt;ul&gt;&lt;li&gt;배열은 공변 자료형이자 실체화 가능 자료형이다&lt;/li&gt;
&lt;li&gt;제네릭은 불변 자료형이며, 실행시간에 형인자의 정보는 삭제된다&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;배열은 컴파일 시간에 형 안정성을 보장하지 못하며, 제네릭은 그 반대다&lt;/li&gt;
&lt;li&gt;일반적으로 배열과 제네릭은 쉽게 혼용할 수 없다&lt;/li&gt;
&lt;li&gt;만일 배열과 제네릭을 뒤섞어 쓰다가 컴파일 오류나 경고 메시지를 만나게 되면, 배열을 리스트로 바꿔야겠다는 생각이 본능적으로 들어야 한다&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/167&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/167</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9925-%EB%B0%B0%EC%97%B4-%EB%8C%80%EC%8B%A0-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%8D%A8%EB%9D%BC#entry167comment</comments>
<pubDate>Tue, 28 Nov 2017 16:04:49 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙24. 무점검 경고(unchecked warning)를 제거하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9924-%EB%AC%B4%EC%A0%90%EA%B2%80-%EA%B2%BD%EA%B3%A0unchecked-warning%EB%A5%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;제네릭으로 프로그램하다 보면 많은 컴파일러 경고 메시지를 보게 된다. &lt;/p&gt;&lt;p&gt;무점검 형변환 경고(unchecked cast warning), 무점검 메서드 호출 경고(unchecked method invocation warning), 무점검 제네릭 배열 생성 경고(unchecked generic array creation warning), 그리고 무점검 변환 경고(unchecked conversion warning) 등이 있다.&lt;/p&gt;&lt;p&gt;코드의 형 안전성(typesafe) 보장을 위해 모든 무점검 경고는, 가능하다면 없애야 한다. 제거할 수 없는 경고 메시지는 형 안정성이 확실할 때만 &lt;strong&gt;@SuppressWarnings(“unchecked”)&lt;/strong&gt; 어노테이션(annotation)을 사용해 억제해야 한다.&lt;/p&gt;&lt;p&gt;SuppressWarnings 어노테이션은 개별 지역 변수 선언부터 클래스 전체에까지, 어떤 크기의 단위에도 적요할 수 있지만 가능한 작은 범위에 적용해야 한다. (중요한 경고 메시지를 놓치게 될 수 도 있다)&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// @SuppressWarnings범위는 항상 최소한으로
public &amp;lt;T&amp;gt; T[] toArray(T[] a) {
  if (a.length &amp;lt; size) {
    // 아래의 형변환은 배열의 자료형이 인자로 전달되 자료형인 T[]와 같으므로 정확하다
    @SuppressWarnings(&quot;unchecked&quot;) T[] result = (T[]) Arrays.copyOf(elements, size, a.getClass());
    return result;
  }

  System.arraycopy(elements, 0, a, 0, size);
  if (a.length &amp;gt; size)
    a[size] = null;

  return a;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@SuppressWarnings(“unchecked”) 어노테이션을 사용할 때마다, 왜 형 안전성을 위반하지 않는지 밝히는 주석을 반드시 붙여야 한다.&lt;/p&gt;



&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;무점검 경고(unchecked warning)는 중요하다&lt;/li&gt;
&lt;li&gt;모든 무점검 경고는 프로그램 실행 도중에 ClassCastException이 발생할 가능성을 나타낸다&lt;/li&gt;
&lt;li&gt;무점검 경고 메시지는 최선을 다해 제거하라&lt;/li&gt;
&lt;li&gt;경고를 제거할 수 없으나 형 안전성을 보장한다는 사실을 입증할 수 있다면, @SuppressWarnings(“unchecked”) 어노테이션을 사용하되, 적용 범위는 최소화해야 한다&lt;/li&gt;
&lt;li&gt;경고 메시지를 억제한 경우, 그 이유를 반드시 주석에 써야 한다&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/166&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/166</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9924-%EB%AC%B4%EC%A0%90%EA%B2%80-%EA%B2%BD%EA%B3%A0unchecked-warning%EB%A5%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EB%9D%BC#entry166comment</comments>
<pubDate>Tue, 28 Nov 2017 15:48:33 +0900</pubDate>
</item>
<item>
<title>[JSTL] JSP 커스텀 태그 만들기</title>
<link>https://itstory.tk/entry/JSTL-JSP-%EC%BB%A4%EC%8A%A4%ED%85%80-%ED%83%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0</link>
<description>&lt;p&gt;JSTL 태그를 통해 JSP 페이지에서 반복, 상태제어, 국제화(i18n), SQL 등을 사용할 수 있습니다. 하지만 때로는 이것들이 충분하지 않기 때문에 JSP페이지에서 약간의 작업을 수행하기 위해 자바스크립트를 쓰려는 유혹에 빠질 수 있습니다. 다행히도 JSP는 확장 가능하며 특정 작업을 수행할 수 있도록 고유한 사용자 지정 태그를 생성할 수 있습니다.&lt;/p&gt;



&lt;h4 id=&quot;jsp-커스텀-태그-jsp-custom-tag&quot;&gt;JSP 커스텀 태그 (JSP Custom Tag)&lt;/h4&gt;

&lt;p&gt;예를들어, 우리는 숫자가 콤마와 소수점 2번째 자리까지만 보여지도록 하고싶다고 가정합시다. 이는 숫자가 매우 길때 유용할 수 있습니다. 그래서 다음과 같은 커스텀 태그를 만들면 편하게 사용할 수 있을 것입니다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-jsp&quot;&gt;&amp;lt;mytags:formatNumber number=&quot;100050.574&quot; format=&quot;#,###.00&quot;/&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 커스텀 태크를 통해 number에 입력된 숫자가 format 형식에 맞게 &lt;code&gt;100,050.57&lt;/code&gt;를 JSP 페이지에 출력하게끔 할 수 있습니다.&lt;/p&gt;
&lt;p&gt;JSTL에서는 위와 같이 동작하는 태그를 지원하지 않으므로, 우리는 우리만의 커스텀 태그를 구현하여 JSP 페이지에 사용할 것입니다. 아래는 이 예시 프로젝트의 최종 구조입니다.&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:392px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F991A41335A1CEAFA11E5EB&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/991A41335A1CEAFA11&quot; filemime=&quot;image/jpeg&quot; filename=&quot;JSP-Custom-Tag-Project.png&quot; height=&quot;306&quot; width=&quot;392&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;



&lt;h4 id=&quot;jsp-커스텀-태그-핸들러-jsp-custom-tag-handler&quot;&gt;JSP 커스텀 태그 핸들러 (JSP Custom Tag Handler)&lt;/h4&gt;

&lt;p&gt;첫 번째 단계에서 JSP 커스텀 태그를 만들어볼 것입니다. &lt;code&gt;javax.servlet.jsp.tagext.SimpleTagSupport&lt;/code&gt; 클래스를 상속받아 &lt;strong&gt;doTag()&lt;/strong&gt; 메서드를 override를 하면됩니다.&lt;/p&gt;
&lt;p&gt;중요한 점은 태그에 사용될 속성들의 setter 메서드를 만들어야 합니다. 그래서 &lt;strong&gt;setFormat(String format)&lt;/strong&gt; 과 &lt;strong&gt;setNumber(String number)&lt;/strong&gt; 두 개의 setter 메서드를 정의할 것입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SimpleTagSupport&lt;/code&gt;는 JspWriter 객체를 얻고 response에 값을 쓸 수 있는 방법을 제공합니다. DecimalFormat 클래스를 이용하여 형식화된 string을 생성하고 이를 response에 보낼 것입니다. 최종 구현은 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NumberFormatterTag.java&lt;/code&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;package tk.itstory.jsp.customtags;

import java.io.IOException;
import java.text.DecimalFormat;

import javax.servlet.jsp.JspException;
import javax.servlet.jsp.SkipPageException;
import javax.servlet.jsp.tagext.SimpleTagSupport;

public class NumberFormatterTag extends SimpleTagSupport {

    private String format;
    private String number;

    public NumberFormatterTag() {
    }

    public void setFormat(String format) {
        this.format = format;
    }

    public void setNumber(String number) {
        this.number = number;
    }

    @Override
    public void doTag() throws JspException, IOException {
        System.out.println(&quot;Number is:&quot; + number);
        System.out.println(&quot;Format is:&quot; + format);
        try {
            double amount = Double.parseDouble(number);
            DecimalFormat formatter = new DecimalFormat(format);
            String formattedNumber = formatter.format(amount);
            getJspContext().getOut().write(formattedNumber);
        } catch (Exception e) {
            e.printStackTrace();
            // stop page from loading further by throwing SkipPageException
            throw new SkipPageException(&quot;Exception in formatting &quot; + number
                    + &quot; with format &quot; + format);
        }
    }

}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;try catch 구문에서 format() 메서드에서 던져진 예외를 잡아 JSP 페이지가 더 로딩되지 않게 SkipPageException을 던지도록 처리한 점을 살펴보세요.&lt;/p&gt;



&lt;h4 id=&quot;jsp-custom-tag-library-descriptor-tld-생성&quot;&gt;JSP Custom Tag Library Descriptor (TLD) 생성&lt;/h4&gt;

&lt;p&gt;태그 핸들러 클래스를 구현했다면, 어플리케이션이 배포될 때 컨테이너가 해당 핸들러를 로드할 수 있도록 WEB-INF 디렉터리 하위에 TLD 파일을 정의할 필요가 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;numberformatter.tld&lt;/code&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;

&amp;lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot;
    version=&quot;2.0&quot;&amp;gt;
&amp;lt;description&amp;gt;Number Formatter Custom Tag&amp;lt;/description&amp;gt;
&amp;lt;tlib-version&amp;gt;2.1&amp;lt;/tlib-version&amp;gt;
&amp;lt;short-name&amp;gt;mytags&amp;lt;/short-name&amp;gt;
&amp;lt;uri&amp;gt;http://itstory.tk/jsp/tlds/mytags&amp;lt;/uri&amp;gt;
&amp;lt;tag&amp;gt;
    &amp;lt;name&amp;gt;formatNumber&amp;lt;/name&amp;gt;
    &amp;lt;tag-class&amp;gt;tk.itstory.jsp.customtags.NumberFormatterTag&amp;lt;/tag-class&amp;gt;
    &amp;lt;body-content&amp;gt;empty&amp;lt;/body-content&amp;gt;
    &amp;lt;attribute&amp;gt;
    &amp;lt;name&amp;gt;format&amp;lt;/name&amp;gt;
    &amp;lt;required&amp;gt;true&amp;lt;/required&amp;gt;
    &amp;lt;/attribute&amp;gt;
    &amp;lt;attribute&amp;gt;
    &amp;lt;name&amp;gt;number&amp;lt;/name&amp;gt;
    &amp;lt;required&amp;gt;true&amp;lt;/required&amp;gt;
    &amp;lt;/attribute&amp;gt;
&amp;lt;/tag&amp;gt;
&amp;lt;/taglib&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TLD 파일에 URI 요소를 정의해야합니다. 또한 format과 number 속성이 필수 속성임을 표시해야합니다(required: true). body-content의 empty는 태그가 body를 가지고 있지 않다는 것을 의미합니다.&lt;/p&gt;



&lt;h4 id=&quot;jsp-custom-tag-deployment-descriptor-설정&quot;&gt;JSP Custom Tag Deployment Descriptor 설정&lt;/h4&gt;

&lt;p&gt;우리는 아래의 예시처럼 jsp-config와 taglib 요소를 이용하여 jsp 커스텀 태그를 웹 어플리케이션에 포함시킬 것입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;web.xml&lt;/code&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&amp;gt;
  &amp;lt;display-name&amp;gt;JSPCustomTags&amp;lt;/display-name&amp;gt;
  &amp;lt;welcome-file-list&amp;gt;
    &amp;lt;welcome-file&amp;gt;index.jsp&amp;lt;/welcome-file&amp;gt;
  &amp;lt;/welcome-file-list&amp;gt;

  &amp;lt;jsp-config&amp;gt;
  &amp;lt;taglib&amp;gt;
    &amp;lt;taglib-uri&amp;gt;http://itstory.tk/jsp/tlds/mytags&amp;lt;/taglib-uri&amp;gt;
    &amp;lt;taglib-location&amp;gt;/WEB-INF/numberformatter.tld&amp;lt;/taglib-location&amp;gt;
  &amp;lt;/taglib&amp;gt;
  &amp;lt;/jsp-config&amp;gt;
&amp;lt;/web-app&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;taglib-uri 값은 TLD 파일에 정의된 것과 동일해야 합니다. 이로써 모든 설정이 완료되었고 이제 JSP 페이지에서 커스텀 태그를 사용할 수 있습니다.&lt;/p&gt;



&lt;h4 id=&quot;jsp-페이지에서-jsp-custom-tag-사용하기&quot;&gt;JSP 페이지에서 JSP Custom Tag 사용하기&lt;/h4&gt;

&lt;p&gt;우리가 만든 number formatter 커스텀 태그를 JSP 페이지에 사용한 예제입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;index.jsp&lt;/code&gt;&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=US-ASCII&quot;
    pageEncoding=&quot;US-ASCII&quot;%&amp;gt;
&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=US-ASCII&quot;&amp;gt;
&amp;lt;title&amp;gt;Custom Tag Example&amp;lt;/title&amp;gt;
&amp;lt;%@ taglib uri=&quot;http://itstory.tk/jsp/tlds/mytags&quot; prefix=&quot;mytags&quot;%&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;h2&amp;gt;Number Formatting Example&amp;lt;/h2&amp;gt;

&amp;lt;mytags:formatNumber number=&quot;100050.574&quot; format=&quot;#,###.00&quot;/&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;

&amp;lt;mytags:formatNumber number=&quot;1234.567&quot; format=&quot;$# ###.00&quot;/&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;

&amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;Thanks You!!&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;웹 어플리케이션을 실행시키면 JSP 페이지는 다음과 같은 화면을 보여줄 것 입니다.&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:450px;;height:auto;max-width:100%&quot;&gt;&lt;img srcset=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F99C3DE335A1CEB4617B03B&quot; src=&quot;https://t1.daumcdn.net/cfile/tistory/99C3DE335A1CEB4617&quot; filemime=&quot;image/jpeg&quot; filename=&quot;JSP-Custom-Tag-Example-450x195.png&quot; height=&quot;195&quot; width=&quot;450&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;JSP 응답 페이지에는 포맷된 숫자가 표시됩니다. 이와 유사하게, 더 많은 jsp 사용자 지정 태그 핸들러 클래스를 생성할 수 있습니다. 태그 라이브러리에 여러개의 태그를 정의할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;만약 커스텀 태그 핸들러가 매우 많거나 다른 사용자들에게 JAR 파일로 제공하길 원한다면, JAR 파일의 META-INF 디렉터리에 TLD 파일들을 포함시키고, JAR 파일을 웹 어플리케이션의 lib 디렉터리에 포함시키면 됩니다. JSP 컨테이너가 이들을 자동으로 로드하기 때문에 web.xml에 추가적으로 설정할 필요는 없습니다.&lt;/p&gt;
&lt;p&gt;이것이 우리가 JSP 표준 태그(JSTL)을 사용할 때 web.xml에 따로 설정할 필요 없이 JSP에서 사용할 수 있는 이유입니다. 만약 믿지 못하겠다면, JSTL Tomcat stardard.jar 파일을 압축 해제하면 META-INF 디렉터리에 수많은 TLD 파일들이 있는 것을 확인하실 수 있을 것입니다.&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/165&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring</category>
<category>JSP Custom Tag</category>
<category>JSP 커스텀 태그</category>
<category>JSTL</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/165</guid>
<comments>https://itstory.tk/entry/JSTL-JSP-%EC%BB%A4%EC%8A%A4%ED%85%80-%ED%83%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0#entry165comment</comments>
<pubDate>Tue, 28 Nov 2017 13:51:48 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙23. 새 코드에는 무인자 제네릭 자료형을 사용하지 마라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9923-%EC%83%88-%EC%BD%94%EB%93%9C%EC%97%90%EB%8A%94-%EB%AC%B4%EC%9D%B8%EC%9E%90-%EC%A0%9C%EB%84%A4%EB%A6%AD-%EC%9E%90%EB%A3%8C%ED%98%95%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%88%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;선언부에 형인자(type parameter)가 포함된 클래스나 인터페이스는 제네릭(generic) 클래스나 인터페이스라 부르고, 이 둘은 &lt;strong&gt;제네릭 자료형(generic type)&lt;/strong&gt;이라 부른다.&lt;/p&gt;&lt;p&gt;각 제네릭 자료형은 &lt;strong&gt;형인자 자료형(parameterized type)&lt;/strong&gt; 집합을 정의한다. List&amp;lt;String&amp;gt;는 원소 자료형이 String인 리스트를 나타내는 형인자 자료형이다.&lt;/p&gt;&lt;p&gt;또한 각 제네릭 자료형은 &lt;strong&gt;무인자 자료형(raw type)&lt;/strong&gt;을 정의할 수 도있다. List&amp;lt;E&amp;gt;의 무인자 자료형은 List다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 무인자 컬렉션 자료형
private final Collection stamps = ...;

// 실수로 넣은 Coin 객체
stamps.add(new Coin( ... ));

for (Iterator i = stamps.iterator(); i.hasNext(); ) {
  Stamp s = (Stamp) i.next(); // ClassCastException 발생
  ...
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같이 무인자 자료형 stamps에 잘 못 들어간 Coin 객체 때문에 실행시간에 예외가 발생할 수 있다. 제네릭을 쓰면, 컴파일러에게 컬렉션에 담길 객체의 자료형이 무엇인지 선언할 수 있다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 형인자 컬렉션 자료형 - 형 안전성(typesafe) 확보
private final Collection&amp;lt;Stamp&amp;gt; stamps = ...;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;형인자 자료형으로 선언하면, 엉뚱한 자료형의 객체를 넣는 코드를 컴파일 할 때 무엇이 잘못됐는지 확인할 수 있는 오류 메시지가 출력된다. 게다가 컬렉션에서 원소를 꺼낼 때 형변환을 하지 않아도 된다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 형변환 불필요
for (Stamp s : stamps) {
  ...
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;무인자 자료형을 쓰면 형 안전성이 사라지고, 제네릭의 장점 중 하나인 표현력(expressiveness) 측면에서 손해를 보게 된다.&lt;/p&gt;&lt;p&gt;List와 같은 무인자 자료형을 쓰면 안 되지만, 아무 객체나 넣을 수 있는 List&amp;lt;Object&amp;gt; 같은 자료형은  써도 좋다. List와 같은 무인자 자료형을 사용하면 형 안정성을 읽게 되지만, List&amp;lt;Object&amp;gt;와 같은 형인자 자료형을 쓰면 그렇지 않다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
  List&amp;lt;String&amp;gt; strings = new ArrayList&amp;lt;String&amp;gt;();
  unsafeAdd(strings, new Integer(42));
  String s = strings.get(0); // 에러 발생
}

// 실행 도중 오류를 일으키는 무인자 자료형
private static void unsafeAdd(List list, Object o) {
  list.add(o);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;List를 List&amp;lt;Object&amp;gt;로 바꾼 다음 다시 컴파일 해 보면, 더 이상 컴파일이 되지 않는다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;private static void unsafeAdd(List&amp;lt;Object&amp;gt; list, Object o) {
  list.add(o);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;버전 1.5부터 자바는 &lt;strong&gt;비한정적 와일드카드 자료형(unbounded wildcard type)&lt;/strong&gt;이라는 좀더 안전한 대안을 제공한다. 실제 형 인자가 무엇인지는 모르거나 신경 쓰고 싶지 않을 때는 형 인자로 &lt;strong&gt;‘?’&lt;/strong&gt; 를 쓰면 된다.&lt;/p&gt;&lt;p&gt;비한정적 와일드카드 자료형을 쓰면 null 이외에 다른 타입의 원소를 넣을 수 없다. (예를 들어 List&amp;lt;?&amp;gt;에 처음 String 객체가 들어갔다면 null과 String 이외의 다른 타입의 원소가 들어갈 수 없다.)&lt;/p&gt;&lt;p&gt;이런 제약이 불만이라면 제네릭 메서드(규칙27)를 사용하거나, &lt;strong&gt;한정적 와일드카드 자료형(bounded wildcard types)&lt;/strong&gt;을 쓰면 된다(규칙28).&lt;/p&gt;

&lt;h3 id=&quot;예외&quot;&gt;예외&lt;/h3&gt;

&lt;p&gt;새로 만든 코드에는 무인자 자료형을 쓰면 안 된다고 했지만, 그 규칙에도 사소한 예외 두가지가 있다.&lt;/p&gt;&lt;p&gt;첫 번째는 클래스 리터럴(class literal)에는 반드시 무인자 자료형을 사용해야 한다는 것이다. 클래스 리터럴에는 형인자 자료형을 쓸 수 없다. (List.class, String[].class, int.class는 가능하지만 List&amp;lt;String&amp;gt;.class나 List&amp;lt;?&amp;gt;.class는 불가)&lt;/p&gt;&lt;p&gt;두 번째는 제네릭 자료형 정보는 프로그램이 실행될 때는 지워지기 때문에, instanceof 연산자는 비한정적 와일드카드 자료형 이외의 형인자 자료형에 적용할 수 없다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;if (o instanceof Set) {
  Set&amp;lt;?&amp;gt; m = (Set&amp;lt;?&amp;gt;) o;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;제네릭 자료형에 instanceof 연산자를 적용할 때는 위와 같이 무인자 자료형을 통해 객체의 타입를 확인한 후 와일드카드 자료형으로 형변환 하는 것이 좋다.&lt;/p&gt;



&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
  &lt;th&gt;용어&lt;/th&gt;
  &lt;th&gt;예&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
  &lt;td&gt;형인자 자료형(parameterized type)&lt;/td&gt;
  &lt;td&gt;List&amp;lt;String&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;실 형인자(actual parameter)&lt;/td&gt;
  &lt;td&gt;String&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;제네릭 자료형(generic type)&lt;/td&gt;
  &lt;td&gt;List&amp;lt;E&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;형식 형인자(formal type parameter)&lt;/td&gt;
  &lt;td&gt;E&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;비한정적 와일드카드 자료형(unbounded wildcard type)&lt;/td&gt;
  &lt;td&gt;List&amp;lt;?&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;한정적 와일드카드 자료형(bounded wildcard type)&lt;/td&gt;
  &lt;td&gt;List&amp;lt;? extends Number&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;무인자 자료형(raw type)&lt;/td&gt;
  &lt;td&gt;List&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;한정적 형인자(bounded type parameter)&lt;/td&gt;
  &lt;td&gt;&amp;lt;E extends Number&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;재귀적 형 한정(recursive type bound)&lt;/td&gt;
  &lt;td&gt;&amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;제네릭 메서드(generic method)&lt;/td&gt;
  &lt;td&gt;static &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; asList(E[] a)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;자료형 토큰(type token)&lt;/td&gt;
  &lt;td&gt;String.class&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/164&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/164</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9923-%EC%83%88-%EC%BD%94%EB%93%9C%EC%97%90%EB%8A%94-%EB%AC%B4%EC%9D%B8%EC%9E%90-%EC%A0%9C%EB%84%A4%EB%A6%AD-%EC%9E%90%EB%A3%8C%ED%98%95%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%88%EB%9D%BC#entry164comment</comments>
<pubDate>Tue, 28 Nov 2017 10:38:46 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙22. 멤버 클래스는 가능하면 static으로 선언하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9922-%EB%A9%A4%EB%B2%84-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EA%B0%80%EB%8A%A5%ED%95%98%EB%A9%B4-static%EC%9C%BC%EB%A1%9C-%EC%84%A0%EC%96%B8%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;중첩 클래스(nested class)는 다른 클래스 안에 정의된 클래스다. 중첩 클래스에는 정적 멤버 클래스), 비-정적 멤버 클래스, 익명 클래스, 지역 클래스 이렇게 네 가지 종류가 있다. 첫 번째를 제외한 나머지는 전부 내부 클래스(inner class)다.&lt;/p&gt;

&lt;h3 id=&quot;정적-멤버-클래스-static-member-class&quot;&gt;정적 멤버 클래스 (static member class)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;바깥 클래스의 모든 멤버에(private로 선언된 것까지도) 접근할 수 있다&lt;/li&gt;
&lt;li&gt;바깥 클래스의 정적 멤버이며, 다른 정적 멤버와 동일한 접근 권한 규칙(accessibility rule)을 따른다&lt;/li&gt;
&lt;li&gt;바깥 클래스와 함께 사용할 때만 유용한 public 도움 클래스(helper class)를 정의하는데 자주 사용&lt;/li&gt;
&lt;/ul&gt;



&lt;h3 id=&quot;비-정적-멤버-클래스-nonstatic-member-class&quot;&gt;비-정적 멤버 클래스 (nonstatic member class)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;바깥 클래스 객체와 자동적으로 연결된다&lt;/li&gt;
&lt;li&gt;비-정적 멤버 클래스 안에서 바깥 클래스의 메서드를 호출할 수 있고, this 한정(qualified this) 구문을 통해 바깥 객체에 대한 참조를 획득할 수도 있다&lt;/li&gt;
&lt;/ul&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;class Envelope {
  void x() { System.out.println(&quot;Hello, World!&quot;); }

  class Enclosure {
    void x() { 
      // this 한정 구문
      Envelope.this.x();
    }
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;비-정적 멤버 클래스의 객체는 바깥 클래스 객체 없이는 존재할 수 없다&lt;/li&gt;
&lt;li&gt;비-정적 멤버 클래스 객체와 바깥 객체와의 연결을 비-정적 멤버 클래스의 객체가 만들어지는 순간에 확립되고, 그 뒤에는 변경할 수 없다&lt;/li&gt;
&lt;li&gt;&lt;p&gt;보통 연결은 바깥 클래스의 객체 메서드(instance method) 안에서 비-정적 멤버 클래스의 생서자를 호출하는 순간 자동으로 만들어진다&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;어댑터(Adapter)를&amp;nbsp;정의할 때 많이 쓰인다&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// 비-정적 멤버 클래스의 전형적 용례
public class MySet&amp;lt;E&amp;gt; extends AbstractSet&amp;lt;E&amp;gt; {
  ...

  public Iterator&amp;lt;E&amp;gt; iterator() {
    return new MyIterator();
  }

  private class MyIterator implements Iterator&amp;lt;E&amp;gt; {
    ...
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;바깥 클래스 객체에 접근할 필요가 없는 멤버 클래스를 정의할 때는 항상 선언문 앞에 static을 붙여서 비-정적 멤버 클래스 대신 정적 멤버 클래스로 만들어야 한다&lt;/li&gt;
&lt;li&gt;private 정적 멤버 클래스는 바깥 클래스 객체의 컴포넌트(component)를 표현하는 데 흔히 쓰인다 (ex. Map 구현 클래스의 Entry 객체)&lt;/li&gt;
&lt;/ul&gt;



&lt;h3 id=&quot;익명-클래스-anonymous-class&quot;&gt;익명 클래스 (anonymous class)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;익명 클래스는 바깥 클래스의 멤버가 아니다&lt;/li&gt;
&lt;li&gt;사용하는 순간에 선언하고 객체를 만든다&lt;/li&gt;
&lt;li&gt;비-정적 문맥(nonstatic context) 안에서 사용될 때만 바깥 객체를 갖는다&lt;/li&gt;
&lt;li&gt;&lt;p&gt;정적 문맥(static context) 안에서 사용된다 해도 static 멤버를 가질 수 없다&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;함수 객체(규칙21)를 정의할 때 널리 쓰인다&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Runnable, Thread, TimerTask 객체 같은 프로세스 객체(process object)를 만드는 데도 널리 쓰인다&lt;/li&gt;
&lt;li&gt;정적 팩터리 메서드 안에서도 많이 쓰인다&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;http://itstory.tk/entry/이펙티브-자바-규칙21-전략을-표현하고-싶을-때는-함수-객체를-사용하라&quot; target=&quot;_blank&quot;&gt;2017/11/22 - [프로그래밍/Java] - [이펙티브 자바] 규칙21. 전략을 표현하고 싶을 때는 함수 객체를 사용하라&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;ul&gt;
&lt;/ul&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;static List&amp;lt;Integer&amp;gt; intArrayAsList(final int[] a) {
    if (a == null) {
        throw new NullPointerException();
    }

    return new AbstractList&amp;lt;Integer&amp;gt;() {
        public Integer get(int i) {
            return a[i];
        }

        @Override
        public Integer set(int i, Integer val) {
            int oldVal = a[i];
            a[i] = val;
            return oldVal;
        }

        public int size() {
            return a.length;
        }
    }
}&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;지역-클래스-local-class&quot;&gt;지역 클래스 (local class)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;네 종류의 중첩 클래스 가운데 사용 빈도가 가장 낮다&lt;/li&gt;
&lt;li&gt;지역 변수(local variable)가 선언될 수 있는 곳이라면 어디서든 선언할 수 있으며, 지역변수와 동일한 유효범위 규칙(scoping rule)을 따른다&lt;/li&gt;
&lt;li&gt;익명 클래스처럼 비-정적 문맥에서 정의했을 때만 바깥 객체를 갖는다&lt;/li&gt;
&lt;li&gt;static 멤버는 가질 수 없다&lt;/li&gt;
&lt;li&gt;길어지면 가독성을 해치므로, 익명 클래스처럼 짧게 작성해야 한다&lt;/li&gt;
&lt;/ul&gt;



&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;중첩 클래스에는 네 가지 종류가 있고, 그 각각은 어울리는 자리가 다르다&lt;/li&gt;
&lt;li&gt;중첩 클래스를 메서드 밖에서 사용할 수 있어야 하거나, 메서드 안에 놓기에는 너무 길 경우에는 &lt;strong&gt;멤버 클래스&lt;/strong&gt;로 정의하라&lt;/li&gt;
&lt;li&gt;멤버 클래스의 객체 각각이 바깥 객체에 대한 참조를 가져야 하는 경우에는 &lt;strong&gt;비-정적 멤버 클래스&lt;/strong&gt;로 만들어라 &lt;br /&gt;
&lt;ul&gt;&lt;li&gt;그렇지 않은 경우에는 &lt;strong&gt;정적 멤버 클래스&lt;/strong&gt;로 만들면 된다&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;중첩 클래스가 특정한 메서드에 속해야 하고, 오직 한 곳에서만 객체를 생성하며, 해당 중첩 클래스의 특성을 규정하는 자료형이 이미 있다면 &lt;strong&gt;익명 클래스&lt;/strong&gt;로 만들어라 &lt;br /&gt;
&lt;ul&gt;&lt;li&gt;그렇지 않을 때는 &lt;strong&gt;지역 클래스&lt;/strong&gt;로 만들면 된다&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/163&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>규칙22</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/163</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9922-%EB%A9%A4%EB%B2%84-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EA%B0%80%EB%8A%A5%ED%95%98%EB%A9%B4-static%EC%9C%BC%EB%A1%9C-%EC%84%A0%EC%96%B8%ED%95%98%EB%9D%BC#entry163comment</comments>
<pubDate>Wed, 22 Nov 2017 15:30:58 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙21. 전략을 표현하고 싶을 때는 함수 객체를 사용하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9921-%EC%A0%84%EB%9E%B5%EC%9D%84-%ED%91%9C%ED%98%84%ED%95%98%EA%B3%A0-%EC%8B%B6%EC%9D%84-%EB%95%8C%EB%8A%94-%ED%95%A8%EC%88%98-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;프로그래밍 언어 가운데는 함수 포인터(function pointer), 대리자(delegate), 람다(lamda expression) 처럼, 특정 함수를 호출할 수 있는 능력을 저장하고 전달할 수 있도록 하는 것들이 있다. &lt;/p&gt;&lt;p&gt;예를 들어 C 표준 라이브러리에 포함되어 있는 qsort 함수는 비교자(comparator) 함수에 대한 포인터를 인자로 받아 정렬할 요소들을 비교한다. 이것은 전략(strategy) 패턴의 한 사례로 비교자 함수를 통해 정렬 전략을 표현하는 것이다.&lt;/p&gt;&lt;p&gt;자바는 함수 포인터를 지원하지 않는다. 하지만 객체 참조를 통해 비슷한 효과를 달성할 수 있다. 가지고 있는 메서드가 다를 객체에 작용하는 메서드 하나 뿐인 객체는 해당 메서드의 포인터 구실을 한다. 이런 객체를 &lt;strong&gt;함수 객체(function object)&lt;/strong&gt;라고 부른다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;class StringLengthComparator {
  public int compare(String s1, String s2) {
    return s1.length() - s2.length();
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 예제는 문자열을 비교하는 데 사용될 수 있는, 실행 가능 전략(concrete strategy)이다. 필드가 없고 그 모든 객체는 기능적으로 동일한 무상태(stateless) 클래스다. 싱글턴 패턴(singleton pattern)을 따르면 쓸데없는 객체 생성은 피할 수 있다.(규칙3, 규칙5)&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://itstory.tk/entry/이펙티브-자바-규칙3-private-생성자나-enum-자료형은-싱글턴-패턴을-따르도록-설계하라&quot; target=&quot;_blank&quot;&gt;2017/11/21 - [프로그래밍/Java] - [이펙티브 자바] 규칙3. private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://itstory.tk/entry/이펙티브-자바-규칙5-불필요한-객체는-만들지-말라&quot; target=&quot;_blank&quot;&gt;2017/11/21 - [프로그래밍/Java] - [이펙티브 자바] 규칙5. 불필요한 객체는 만들지 말라&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;class StringLengthComparator {
  private StringLengthComparator() {}
  public static final StringLengthComparator INSTANCE = new StringLengthComparator();

  public int compare(String s1, String s2) {
    return s1.length() - s2.length();
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;실행 가능 전략 클래스(concrete strategy class)&lt;/strong&gt; 객체를 메서드에 전달하기 위해서는 인자의 자료형이 맞아야 한다. 따라서 클래스에 어울리는 &lt;strong&gt;전략 인터페이스(strategy interface)&lt;/strong&gt;를 정의할 필요가 있다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// T를 형식 자료형 인자(formal type parameter)라고 부른다
public interface Comparator&amp;lt;T&amp;gt; {
  public int compare(T t1, T t2);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실행 가능 전략 클래스는 익명 클래스(anonymouse class)로 정의하는 경우도 많다(규칙22).&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://itstory.tk/entry/이펙티브-자바-규칙22-멤버-클래스는-가능하면-static으로-선언하라&quot; target=&quot;_blank&quot;&gt;2017/11/22 - [프로그래밍/Java] - [이펙티브 자바] 규칙22. 멤버 클래스는 가능하면 static으로 선언하라&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;Arrays.sort(stringArray, new Comparator&amp;lt;String&amp;gt;() {
  public int compare(String s1, String s2) {
    return s1.length() - s2.length();
  }
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여러번 수행되는 클래스라면 함수 객체를 private static final 필드에 저장하고 재사용하는 것을 고려해야 한다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;// java.lang.String 
public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence {
  public static final Comparator&amp;lt;String&amp;gt; CASE_INSENSITIVE_ORDER = new CaseInsensitiveComparator();

  // 대소문자 구별 없는 문자열 비교자
  private static class CaseInsensitiveComparator implements Comparator&amp;lt;String&amp;gt;, java.io.Serializable {
    private static final long serialVersionUID = 8575799808933029326L;

    public int compare(String s1, String s2) {
      int n1 = s1.length();
      int n2 = s2.length();
      int min = Math.min(n1, n2);
      for (int i = 0; i &amp;lt; min; i++) {
        char c1 = s1.charAt(i);
        char c2 = s2.charAt(i);
        if (c1 != c2) {
          c1 = Character.toUpperCase(c1);
          c2 = Character.toUpperCase(c2);
          if (c1 != c2) {
              c1 = Character.toLowerCase(c1);
              c2 = Character.toLowerCase(c2);
              if (c1 != c2) {
                // No overflow because of numeric promotion
                return c1 - c2;
              }
          }
        }
      }
      return n1 - n2;
    }
  }

  ...
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;전략 인터페이스는 실행 가능 전략 객체들의 자료형 구실을 한다. 따라서 실행 가능 전략 클래스는 굳이 public으로 만들어 공개할 필요가 없다. 대신, 전략 인터페이스가 자료형인 public static 필드들을 갖는 &lt;strong&gt;호스트 클래스(host class)&lt;/strong&gt;를 정의하는 것도 방법이다.&lt;/p&gt;

&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;함수 객체의 주된 용도는 전략 패턴(strategy pattern)을 구현하는 것&lt;/li&gt;
&lt;li&gt;이 패턴을 구현하기 위해서는 전략을 표현하는 인터페이스를 선언하고, 실행 가능 전략 클래스가 전부 해당 인터페이스를 구현하도록 해야 한다&lt;/li&gt;
&lt;li&gt;실행 가능 전략이 한 번만 사용되는 경우에는 보통 그 전략을 익명 클래스 객체로 구현한다&lt;/li&gt;
&lt;li&gt;반복적으로 사용된다면 private static 멤버 클래스로 전략을 표현한 다음, 전략 인터페이스가 자료형인 public static final 필드를 통해 외부에 공개하는 것이 바람직&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/162&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>규칙21</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/162</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9921-%EC%A0%84%EB%9E%B5%EC%9D%84-%ED%91%9C%ED%98%84%ED%95%98%EA%B3%A0-%EC%8B%B6%EC%9D%84-%EB%95%8C%EB%8A%94-%ED%95%A8%EC%88%98-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC#entry162comment</comments>
<pubDate>Wed, 22 Nov 2017 15:03:13 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙20. 태그 달린 클래스 대신 클래스 계층을 활용하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9920-%ED%83%9C%EA%B7%B8-%EB%8B%AC%EB%A6%B0-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%8C%80%EC%8B%A0-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B3%84%EC%B8%B5%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;때로 두 가지 이상의 기능을 가지고 있으며, 그중 어떤 기능을 제공하는지 표시하는 태그(tag)가 달린 클래스를 만날 때가 있다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;class Figure {
  enum Shape { RECTANGLE, CIRCLE };

  // 어떤 모양인지 나타내는 태그 필드
  final Shape shape;

  // 태그가 RECTANGLE일 때만 사용되는 필드
  double length;
  double width;

  // 태그가 CIRCLE일 때만 사용되는 필드
  double radius;

  // 원을 만드는 생성자
  Figure(double radius) {
    shape = Shape.CIRCLE;
    this.radius = radius;
  }

  // 사각형을 만드는 생성자
  Figure(double length, double width) {
    shape = Shape.RECTANGLE;
    this.length = length;
    this.width = width;
  }

  double area() {
    switch(shape) {
      case RECTANGLE:
        return length * width;
      case CIRCLE:
        return Math.PI * (radius * radius)
      default:
        throw new AssertionError();
    }
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;태그 달린 클래스는 enum 선언, 태그 필드, switch 문 등의 상투적 코드가 반복되며 생성자에서 관련 없는 필드를 초기화하지 않는 한, 필드들을 final로 선언할 수도 없으므로 상투적인 코드(boilerplate)는 더 늘어난다.&lt;/p&gt;&lt;p&gt;태그 기반 클래스(tagged class)는 너저분한데다 오류 발생 가능성이 높고, 효율적이지도 않는다. 태그 기반 클래스는 클래스 계층을 얼기설기 흉내 낸 것일 뿐이다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;abstract class Figure {
  abstract double area();
}

class Circle extends Figure {
  final double radius;

  Circle(double radius) { ... }

  double area() { ... }
}

class Rectangle extends Figure {
  final double length;
  final double width;

  Rectangle(double length, double width) {
    ...
  }

  double area() { ... }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;클래스 계층으로 변환한 결과, 단순하고 명료하며 원래 클래스에 있던 난잡하고 상투적인 코드도 없다.&lt;/p&gt;&lt;p&gt;또한 자료형 간의 자연스로운 계층 관계를 반영할 수 있어서 유연성이 높아지고 컴파일 시에 형 검사(type checking)를 하기 용이하다.&lt;/p&gt;



&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;태그 기반 클래스 사용은 피해야 한다&lt;/li&gt;
&lt;li&gt;태그 필드가 있는 클래스를 만나게 되면, 리팩터링을 통해 클래스 계층으로 변환할 방법이 없는지 고민&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/161&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>규칙20</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/161</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9920-%ED%83%9C%EA%B7%B8-%EB%8B%AC%EB%A6%B0-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%8C%80%EC%8B%A0-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B3%84%EC%B8%B5%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%98%EB%9D%BC#entry161comment</comments>
<pubDate>Wed, 22 Nov 2017 14:34:24 +0900</pubDate>
</item>
<item>
<title>[이펙티브 자바] 규칙19. 인터페이스는 자료형을 정의할 때만 사용하라</title>
<link>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9919-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8A%94-%EC%9E%90%EB%A3%8C%ED%98%95%EC%9D%84-%EC%A0%95%EC%9D%98%ED%95%A0-%EB%95%8C%EB%A7%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC</link>
<description>&lt;table class=&quot;tt-plugin-interpark&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; style=&quot;background: #fff; border: 1px solid #e0e0e0; width: 408px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td width=&quot;70&quot; style=&quot;vertical-align: top; padding: 10px 0 10px 10px;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://bimage.interpark.com/goods_image/8/5/3/1/222558531h.jpg&quot; width=&quot;66&quot; height=&quot;90&quot; style=&quot;border: 0 none;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align: top; padding: 10px 10px 10px 15px;&quot;&gt;&lt;dl style=&quot;margin: 0; padding: 2px 0 0 0; list-style: none; font: 11px dotum, sans-serif; letter-spacing: -1px; color: #777;&quot;&gt;&lt;dt style=&quot;padding: 0; margin: 0;&quot;&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;font-size: 12px; color: #444 !important; font-weight: bold; text-decoration: none !important;&quot;&gt;이펙티브 자바 Effective Java 2/E&lt;/a&gt;&lt;/dt&gt;&lt;dd style=&quot;padding: 7px 0 0 0; margin: 0; color: #a0a0a0;&quot;&gt;국내도서&lt;/dd&gt;&lt;dd style=&quot;padding: 17px 0 0 0; margin: 0;&quot;&gt;저자 : 조슈아 블로크(Joshua Bloch) / 이병준역&lt;/dd&gt;&lt;dd style=&quot;padding: 4px 0 0 0; margin: 0;&quot;&gt;출판 : 인사이트 &lt;span style=&quot;letter-spacing: normal&quot;&gt;2014.09.01&lt;/span&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;a href=&quot;http://book.interpark.com/blog/integration/product/itemDetail.rdo?prdNo=222558531&amp;amp;refererType=8303&amp;amp;bookblockname=bpmain_in&amp;amp;booklinkname=wg_search_F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&amp;amp;key=F5D38091A47066E57DF508CBA39A5FA23227E5049FED9F394458320740BA09AC&quot; target=&quot;_blank&quot; style=&quot;float: right; width: 44px; height: 11px; background: url(//t1.daumcdn.net/tistory_admin/static/images/icon_ipark_detail.gif) no-repeat; overflow: hidden; display: block; text-indent: -1000em;&quot;&gt;상세보기&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;인터페이스를 구현하는 클래스를 만들게 되면, 그 인터페이스는 해당 클래스의 객체를 참조할 수 있는 자료형(type) 역할을 하게 된다. 그 외 다른 목적으로 인터페이스를 정의하고 사용하는 것은 적절치 못하다.&lt;/p&gt;&lt;p&gt;이 기준에 미달하는 사례로 소위 상수 인터페이스(constant interface)라는 것이 있다.&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public interface ObjectStreamConstants {
    short STREAM_MAGIC = -21267;
    short STREAM_VERSION = 5;
    byte TC_BASE = 112;
    byte TC_NULL = 112;
    ...
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자바 플랫폼 라이브러리의 java.io. ObjectStreamConstants 같은 것이다. 상수 인터페이스 패턴은 인터페이스를 잘못 사용한 것이다.&lt;/p&gt;&lt;p&gt;다음번 릴리스에 더 이상 그런 상수를 사용하지 않도록 클래스를 변경할 것이라 가정하면, 이진 호환성(binary compatibility)을 보장하려면 그 인터페이스를 계속 구현해야 한다.&lt;/p&gt;&lt;p&gt;상수를 API 일부로 공개하고 싶을 때는, 해당 상수가 이미 존재하는 클래스나 인터페이스에 강하게 연결되어 있을 때는 그 상수들을 해당 클래스나 인터페이스에 추가해야 한다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public final class Integer extends Number implements Comparable&amp;lt;Integer&amp;gt; {
    /**
     * A constant holding the minimum value an {@code int} can
     * have, -2&amp;lt;sup&amp;gt;31&amp;lt;/sup&amp;gt;.
     */
    @Native public static final int   MIN_VALUE = 0x80000000;

    /**
     * A constant holding the maximum value an {@code int} can
     * have, 2&amp;lt;sup&amp;gt;31&amp;lt;/sup&amp;gt;-1.
     */
    @Native public static final int   MAX_VALUE = 0x7fffffff;

    ...
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;기본 자료형의 객체 표현형들(Integer나 Double)에는 MIN_VALUE와 MAX_VALUE 상수가 공개되어 있다.&lt;/p&gt;&lt;p&gt;이런 상수들이 enum 자료형의 멤버가 되어야 바람직할 때는 enum 자료형(규칙 30)과 함께 공개해야 한다. 그렇지 않을 때는 해당 상수들을 객체 생성이 불가능한 유틸리티 클래스(&lt;a href=&quot;/chap1/rule4.md&quot;&gt;규칙 4&lt;/a&gt;)에 넣어서 공개해야 한다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;package com.test.java.science;

public class PysicalConstants {
    private PysicalConstants() {}

    public static final double AVOGADROS_NUMBER = 6.1231432423e23;
    public static final double BOLTZMANN_CONSTANT = 1.2342352e-13;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;유틸리니 클래스에 포함된 상수를 이용할 일이 많다면, JDK 1.5부터 도입된 정적 임포트(static import) 기능을 사용하면 클래스 이름을 제거할 수 있다.&lt;/p&gt;



&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;import static com.test.java.science.PysicalConstants.*;

public class Test {
    double atoms(double mols) {
        return AVOGADROS_NUMBER * mols;
    }
}&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;p&gt;인터페이스는 자료형을 정의할 때만 사용해야 한다. 특정 상수를 API의 일부로 공개할 목적으로는 적절치 않다.&lt;/p&gt;&lt;div style=&quot;text-align:center; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://itstory.tk/160&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>규칙19</category>
<category>이펙티브 자바</category>
<author>kkd927 kkd927</author>
<guid>https://itstory.tk/160</guid>
<comments>https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9919-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8A%94-%EC%9E%90%EB%A3%8C%ED%98%95%EC%9D%84-%EC%A0%95%EC%9D%98%ED%95%A0-%EB%95%8C%EB%A7%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC#entry160comment</comments>
<pubDate>Tue, 21 Nov 2017 17:38:26 +0900</pubDate>
</item>
</channel>
</rss>