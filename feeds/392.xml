<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>Jins' Dev Inside</title>
<link>https://jins-dev.tistory.com/</link>
<description>진스팍의 데브인사이드</description>
<language>ko</language>
<pubDate>Tue, 14 May 2019 17:47:39 +0900</pubDate>
<generator>TISTORY</generator>
<managingEditor>진스팍</managingEditor>
<item>
<title>Software Oriented Architecture(SOA) 의 정의와 Micro Service Architecture</title>
<link>https://jins-dev.tistory.com/entry/Software-Oriented-ArchitectureSOA-%EC%9D%98-%EC%A0%95%EC%9D%98%EC%99%80-Micro-Service-Architecture</link>
<description>&lt;div class=&quot;tt_adsense_top&quot; style=&quot;margin-bottom:30px&quot;&gt;&lt;/script&gt;
	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: &quot;ca-pub-4036633281122262&quot;,
          enable_page_level_ads: true
     });
&lt;/script&gt;&lt;/div&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;SOA(Software Oriented Architecture) 란, 2000년대 초반부터 IT 업계 전반에 걸쳐 녹아든 IT System 의 패러다임이다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;고전의 Client-Server Architecture 에서 EJB 로 대표되는 n-Tier Model Architecture 로 진화한 웹 아키텍쳐는 2000년대 이후부터 비즈니스 요구사항에 발빠르게 대처하기 위한 구조로 Service-Oriented Architecture 라는 아키텍쳐로 진화한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;SOA 란, 그전까지의 Application 의 Massive 한 기능들을 비즈니스적인 용도로 분류하고 기능 단위로 묶어서 하나의 표준 Interface 를 통해 각각을 &quot;서비스&quot; 로써 조합하는 Software Architecture 이다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;IT 업계의 요구사항이 많아지고 변화가 빨라짐에 따라 이에 대처하기 위해 나타난 Architecture 이고, 구성요소를 3가지로 분류한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;1. &lt;b&gt;Service Consumer&lt;/b&gt; - 서비스의 사용자. 사용자는 실제 클라이언트(End-User) 또는 다른 서비스가 될 수 있다.&lt;/p&gt;
&lt;p&gt;2. &lt;b&gt;Service Provider&lt;/b&gt; - 서비스 사용자에 요청에 맞는 서비스를 제공. Provider 는 다른 Service 의 Consumer 가 될 수도 있다.&lt;/p&gt;
&lt;p&gt;3. &lt;b&gt;Service Registry&lt;/b&gt; - 서비스의 정보를 저장한다. Provider 가 Registry 를 통해 Consumer 에게 서비스를 제공한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;여기서 중요한건 Service Provider 와 Service Consumer 로, 이들은 실제 서비스의 유저 뿐 아니라 소프트웨어 아키텍처 내부의 &quot;모듈&quot; 도 대상이 될 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;즉, SOA 는 비즈니스적으로 구분된 Service 들을 느슨하게 연결하며, 각 컴포넌트를 독립적으로 운용하여 조립이 가능하게끔 한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;일반적으로 Service 를 위해 서비스 기능별로 모듈을 분리하고, 각 모듈이 다른 모듈과 상호작용할 수 있도록 만들어진 Architecture 를 SOA 라고 이해하면 된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;여기까지 이해했으면 떠오르는 최근의 Architecture 모델이 있을 수 있다.&lt;/p&gt;
&lt;p&gt;바로 Micro Service Architecture(MSA) 이다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Micro Service Architecture 역시 각 서비스를 독립적으로 운용하며 서비스들을 조합하여 End User 에게 서비스를 제공하는 형태로 이루어진다. 그렇다면 이는 SOA 와 같은 아키텍처인가?&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;결론부터 말하자면, Micro Service Architecture 는 SOA 의 부분집합이라고 할 수 있다.&lt;/p&gt;
&lt;p&gt;정확히는 SOA 는 패러다임이며, 그를 위한 Architecture 의 초안이고, Micro Service Architecture 는 SOA 의 패러다임을 따르되, 그 아키텍처를 따르지 않는다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;SOA 와 MSA 의 차이점&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;1. SOA 는 모듈의 의존성은 줄이되 모듈 내에서 공유할 수 있는건 최대한 공유하는 정책을 사용한다.&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;반면, MSA 는 가능한 공유하지 않고 모듈들이 독립적으로 운용될 수 있도록 아키텍처를 디자인 한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;2. SOA 는 서비스의 Flow 를 유지하려하지만, MSA 는 Flow 의 구별을 요구한다.&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;가령, 서비스 내에서 결제를 하고자 할때, SOA 는 관련된 루틴을 수행하여 결제를 지원함으로써, 유저에게 제공해주는 &quot;서비스&quot; 를 1차 목적으로 한다.&lt;/p&gt;
&lt;p&gt;반면, MSA 는 유저에게 관련된 루틴과 결제 루틴을 별도로 이용하게끔 한다. 즉 서비스 내의 독립이 아닌 독립된 서비스를 지향한다.&lt;/p&gt;
&lt;p&gt;그렇다보니 SOA 아키텍처는 대게 어느정도 업격한 Protocol 과 Message 체계를 운용하게 되고, MSA 의 경우 별도의 체계가 없이 경량화된 프로토콜을 통해 운용되게 된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;3. SOA 는 서비스들의 재사용에 중점을 두지만 MSA 는 서비스들의 독립을 추구한다.&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;이는 블로그 내 다른 포스팅에서 언급한 적 있는 Monolithic Architecture 와 유사한 부분으로, SOA 는 MSA 에 비해 보다 Monolithic Architecture 에 가깝다.&lt;/p&gt;
&lt;p&gt;(참조 :&amp;nbsp;&lt;a href=&quot;https://jins-dev.tistory.com/entry/%EC%A0%84%ED%86%B5%EC%9D%98-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%AA%A8%EB%8D%B8-%EB%AA%A8%EB%86%80%EB%A6%AC%EC%8B%9DMonolithic-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98&quot;&gt;https://jins-dev.tistory.com/entry/%EC%A0%84%ED%86%B5%EC%9D%98-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%AA%A8%EB%8D%B8-%EB%AA%A8%EB%86%80%EB%A6%AC%EC%8B%9DMonolithic-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;아키텍처를 디자인하는 일은 늘 어려운 일이고, 실무에서의 경험을 상당히 요하는 일이다.&lt;/p&gt;
&lt;p&gt;아키텍처의 디자인과 이해를 위해서는 최신 트렌드 뿐 아니라 과거의 모델까지도 숙지해두는 것이 필요하겠다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;좀 더 자세한 설명은 다음 링크를 참조해보자.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dzone.com/articles/microservices-vs-soa-2&quot;&gt;https://dzone.com/articles/microservices-vs-soa-2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bmc.com/blogs/microservices-vs-soa-whats-difference/&quot;&gt;https://www.bmc.com/blogs/microservices-vs-soa-whats-difference/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- MobileAd --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-4036633281122262&quot;
     data-ad-slot=&quot;8116949665&quot;
     data-ad-format=&quot;auto&quot;
     data-full-width-responsive=&quot;true&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jins-dev.tistory.com/188&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Computer Engineering</category>
<category>Architecture</category>
<category>MSA</category>
<category>SOA</category>
<category>software</category>
<category>아키텍처</category>
<author>널디한 진스팍</author>
<guid>https://jins-dev.tistory.com/188</guid>
<comments>https://jins-dev.tistory.com/entry/Software-Oriented-ArchitectureSOA-%EC%9D%98-%EC%A0%95%EC%9D%98%EC%99%80-Micro-Service-Architecture#entry188comment</comments>
<pubDate>Sun, 12 May 2019 18:39:36 +0900</pubDate>
</item>
<item>
<title>알고리즘 풀이 시 자주 사용되는 bit 연산 모음</title>
<link>https://jins-dev.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-%EC%8B%9C-%EC%9E%90%EC%A3%BC-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-bit-%EC%97%B0%EC%82%B0-%EB%AA%A8%EC%9D%8C</link>
<description>&lt;div class=&quot;tt_adsense_top&quot; style=&quot;margin-bottom:30px&quot;&gt;&lt;/script&gt;
	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: &quot;ca-pub-4036633281122262&quot;,
          enable_page_level_ads: true
     });
&lt;/script&gt;&lt;/div&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;실무에서 bit 연산을 사용할 때에는 주로 플래그 값들을 미리 정의해놓고 마스킹 하는 용도로 사용하지만,&lt;/p&gt;
&lt;p&gt;알고리즘 문제를 풀 때에는 조합을 만들어낼 때에나, check 배열 또는 인덱스 값을 값싸게 저장하기 위한 용도로 많이 사용하게 된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;그래서 자주 사용하지 않으면 헷갈리기 쉬운 bit 연산들을 몇가지 정리해보았다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/cYareR/btqu9QayIjj/tD75fl5RXBbyEgIP7DOvC1/img.png' data-lightbox='lightbox' data-alt=''&gt;&lt;img src='https://k.kakaocdn.net/dn/cYareR/btqu9QayIjj/tD75fl5RXBbyEgIP7DOvC1/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FcYareR%2Fbtqu9QayIjj%2FtD75fl5RXBbyEgIP7DOvC1%2Fimg.png' &gt;&lt;/span&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;주로 사용되는 연산은 위와 같고, 해당 연산만 이용해도 비트 연산을 이용한 알고리즘의 상당수는 해결할 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;자주 쓰지않는 내용이라 까먹기 쉽지만, 필요할 때 쓸 수 있도록 잘 익혀두자.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- MobileAd --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-4036633281122262&quot;
     data-ad-slot=&quot;8116949665&quot;
     data-ad-format=&quot;auto&quot;
     data-full-width-responsive=&quot;true&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jins-dev.tistory.com/186&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Algorithm</category>
<category>Algorithm</category>
<category>bit operation</category>
<author>널디한 진스팍</author>
<guid>https://jins-dev.tistory.com/186</guid>
<comments>https://jins-dev.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-%EC%8B%9C-%EC%9E%90%EC%A3%BC-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-bit-%EC%97%B0%EC%82%B0-%EB%AA%A8%EC%9D%8C#entry186comment</comments>
<pubDate>Sat, 11 May 2019 21:22:09 +0900</pubDate>
</item>
<item>
<title>자바스크립트 호이스팅(Hoisting)</title>
<link>https://jins-dev.tistory.com/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85Hoisting</link>
<description>&lt;div class=&quot;tt_adsense_top&quot; style=&quot;margin-bottom:30px&quot;&gt;&lt;/script&gt;
	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: &quot;ca-pub-4036633281122262&quot;,
          enable_page_level_ads: true
     });
&lt;/script&gt;&lt;/div&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Javascript 의 기본적인 내용이자 Scope 와 관련된 중요한 개념이다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Javascript 는 많은 프로그래밍 언어와 다르게 Block-level Scope 가 아닌 Function-level Scope 를 따른다.&lt;/p&gt;
&lt;p&gt;Block-level Scope 가 모든 코드 블록의 유효성 판단을 선언된 코드 블록({}) 단위로 하는 데 반면, Function-level Scope 는 함수 단위로 Scope 의 기준을 잡는다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Function-level Scope 의 중요한 특징은, 함수 내부에서 봤을 때 함수 외부는 Nested Scope 의 Outer function 이라 할지라도 Global 영역으로 취급된다는 점이다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Hoisting 이란, Javascript 내에서 해당 변수 또는 함수의 &quot;선언&quot; 을 끌어올린다는 점이다.&lt;/p&gt;
&lt;p&gt;여기서 주의할 점은 함수의 선언과 변수의 선언이 조금 다르다는 점이다.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/mDxm2/btqvbIQCdad/KxAqj68QX5Nnx3IWT5TC2K/img.png' data-lightbox='lightbox' data-alt=''&gt;&lt;img src='https://k.kakaocdn.net/dn/mDxm2/btqvbIQCdad/KxAqj68QX5Nnx3IWT5TC2K/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FmDxm2%2FbtqvbIQCdad%2FKxAqj68QX5Nnx3IWT5TC2K%2Fimg.png' &gt;&lt;/span&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;위의 경우에 inner1 함수의 경우 정상적으로 호출이 된다. 해당 함수의 선언이 아래 있음에도 호출될 수 있는 이유는 해당 함수가 Hoisting 되기 때문이다.&lt;/p&gt;
&lt;p&gt;반면 inner2 함수의 경우 Hoisting 되지 않는다. 그 이유는 변수의 선언과 함수의 선언이 다른 의미를 지니기 때문이다.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/x2NDB/btqvb5EzwTF/pVxYKjtq41sKtMSS1Tc3K0/img.png' data-lightbox='lightbox' data-alt=''&gt;&lt;img src='https://k.kakaocdn.net/dn/x2NDB/btqvb5EzwTF/pVxYKjtq41sKtMSS1Tc3K0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fx2NDB%2Fbtqvb5EzwTF%2FpVxYKjtq41sKtMSS1Tc3K0%2Fimg.png' &gt;&lt;/span&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;위와 같이 함수의 선언은 단순히 함수를 정의하면 되는데 반해 변수의 선언은 선언과 할당이 다르다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;이 때 의문이 생길 수 있다.&lt;/p&gt;
&lt;p&gt;inner2 예제의 경우 &quot;변수를 선언하고 함수를 할당한 것&quot;이 아닌가?&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;정답은 &quot;아니다.&quot; 이다. 정확히 예제의 inner2 의 경우 함수리터럴을 할당했다고 표현한다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;함수 리터럴이란 함수의 이름없이 구현체만 연결시키는 방식으로, 이 경우에 Javascript Engine 은 이를 호이스팅시키지 않는다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- MobileAd --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-4036633281122262&quot;
     data-ad-slot=&quot;8116949665&quot;
     data-ad-format=&quot;auto&quot;
     data-full-width-responsive=&quot;true&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jins-dev.tistory.com/185&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>hoisting</category>
<category>javascript</category>
<author>널디한 진스팍</author>
<guid>https://jins-dev.tistory.com/185</guid>
<comments>https://jins-dev.tistory.com/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85Hoisting#entry185comment</comments>
<pubDate>Sat, 11 May 2019 12:26:15 +0900</pubDate>
</item>
<item>
<title>자바스크립트의 Closure 에 대한 이해</title>
<link>https://jins-dev.tistory.com/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-Closure-%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4</link>
<description>&lt;div class=&quot;tt_adsense_top&quot; style=&quot;margin-bottom:30px&quot;&gt;&lt;/script&gt;
	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: &quot;ca-pub-4036633281122262&quot;,
          enable_page_level_ads: true
     });
&lt;/script&gt;&lt;/div&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Javascript 의 클로저는 보통 Scope 와 같이 기술되는 특징적인 개념이다.&lt;/p&gt;
&lt;p&gt;그 이유는 Closure 라는 개념이 Javascript 의 특징적인 Nested Scope 개념을 이용하기 때문이다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;다음 예제를 확인해보자.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/vBTAX/btqvdlGSVpb/u97vOUW7VN0sj95spd1qA1/img.png' data-lightbox='lightbox' data-alt=''&gt;&lt;img src='https://k.kakaocdn.net/dn/vBTAX/btqvdlGSVpb/u97vOUW7VN0sj95spd1qA1/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FvBTAX%2FbtqvdlGSVpb%2Fu97vOUW7VN0sj95spd1qA1%2Fimg.png' &gt;&lt;/span&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;위의 예제에서 함수 foo 는 innerFoo 의 실행 결과를 반환한다. outerFoo() 함수가 nestedFunction 을 return 해주고 있기 때문이다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;이런 방식의 호출을 클로저(Closure) 라고 하며, 클로저로 정의된 innerFoo 함수는 외부 함수인 outerFoo 의 변수에 접근할 수 있기 때문에 &lt;b&gt;Side effect 관리가 용이하며 정보 은닉(Private) 의 특성&lt;/b&gt;을 지닌다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;아울러 이렇게 정의된 &lt;b&gt;outerFoo 는 innerFoo 를 위한 언어적 환경(Lexical environment) 를 제공&lt;/b&gt;하게 되기 때문에, 디자인 패턴적으로 높은 유연도를 가질 수 있게 된다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;가령, outerFoo 를 innerFoo 를 위한 Factory 처럼 사용하거나 outerFoo 에 Parameter 를 받아 &quot;독립적인 객체&quot; 와 같은 환경을 만들거나 Singleton 처럼 사용할 수도 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;클로저의 중요한 특징 중 하나는 Scope Chain 을 이해하는 것이다.&lt;/p&gt;
&lt;p&gt;근본적으로 Nested Scope 로 정의되는 Closure 는 3가지 종류의 Scope 를 가질 수 있으며 이를 순차적으로(Chaining) 접근하게 된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/GX3Br/btqvceBhKjr/VANM8rwKCfFj3LkqlGBOcK/img.png' data-lightbox='lightbox' data-alt=''&gt;&lt;img src='https://k.kakaocdn.net/dn/GX3Br/btqvceBhKjr/VANM8rwKCfFj3LkqlGBOcK/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FGX3Br%2FbtqvceBhKjr%2FVANM8rwKCfFj3LkqlGBOcK%2Fimg.png' &gt;&lt;/span&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;코드를 위와 같이 조금 변경해보았다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;(1) Local scope&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;(2) Outer function scope&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;(3) Global scope&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;위의 코드에서 Closure 는 위와 같은 3가지의 Scope 를 전부 가질 수 있으며,&lt;/p&gt;
&lt;p&gt;동일한 이름의 변수에 대해서는 우선순위에 따라 다른 Scope 의 변수를 가리는(Hide) 모습을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;위와 같이 Closure 함수의 실행은 Scope 에서 Scope 로 전이되며 Scope 내에서 Scope 를 다시 선언하는 Scope chain 을 생성하는 과정이라 할 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;클로저를 이해하는 건 어렵지않으며, 중요한 것은 Scope chaining 을 이해하는 것이다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;주로 Javascript 의 유사한 동작을 패턴화 시키고, 그에 따른 독립적인 환경의 격리(private)가 필요할 때 사용하곤 한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- MobileAd --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-4036633281122262&quot;
     data-ad-slot=&quot;8116949665&quot;
     data-ad-format=&quot;auto&quot;
     data-full-width-responsive=&quot;true&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jins-dev.tistory.com/184&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Javascript + HTML</category>
<author>널디한 진스팍</author>
<guid>https://jins-dev.tistory.com/184</guid>
<comments>https://jins-dev.tistory.com/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-Closure-%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4#entry184comment</comments>
<pubDate>Sat, 11 May 2019 11:52:53 +0900</pubDate>
</item>
<item>
<title>자바스크립트의 Scope 에 대한 이해</title>
<link>https://jins-dev.tistory.com/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-Scope%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4</link>
<description>&lt;div class=&quot;tt_adsense_top&quot; style=&quot;margin-bottom:30px&quot;&gt;&lt;/script&gt;
	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: &quot;ca-pub-4036633281122262&quot;,
          enable_page_level_ads: true
     });
&lt;/script&gt;&lt;/div&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;다른 언어들과 마찬가지로 Javascript 역시 Scope 를 갖고 있으며, 이를 기본적으로 이해하는 것이 아주 중요하다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Javascript 의 Scope 에는 다음 2가지가 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;(1) Local scope&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;지역 스코프를 말하며, Braclet({}) 안에서 정의되는 항목으로 정의된 해당 범위 내에서만 변수의 사용을 허용한다.&lt;/p&gt;
&lt;p&gt;다른 범위에서 참조가 불가능하다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;(2) Global scope&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;전역 스코프를 말하며, 바닐라 자바스크립트에서 일반적으로 Braclet({}) 에 포함되지 않도록 정의된다.&lt;/p&gt;
&lt;p&gt;전역으로 선언된 변수는 Window 객체로 포함되어 웹페이지 내에서 어디서든 참조가 가능하다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;그리고 응용된 Scope 로 Javascript 에서는 Nested Scope 라는 개념을 가질 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;(3) Nested Scope&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;Scope 내에서 별도의 Scope 를 정의한 경우 바깥쪽 Scope 에서 안쪽 Scope 에 접근이 불가능하지만 안쪽 Scope 에서는 바깥쪽 Scope 의 변수에 접근이 가능하다. 가령 다음과 같은 경우를 보자.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/pz1qU/btqu89IoqAR/cYrTzLWpFDruMStyK16kNK/img.png' data-lightbox='lightbox' data-alt=''&gt;&lt;img src='https://k.kakaocdn.net/dn/pz1qU/btqu89IoqAR/cYrTzLWpFDruMStyK16kNK/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fpz1qU%2Fbtqu89IoqAR%2FcYrTzLWpFDruMStyK16kNK%2Fimg.png' &gt;&lt;/span&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;outerFoo() 함수의 출력 결과는 함수 내에서 innerFoo를 호출하기 때문에 70이 된다. innerFoo 함수에서 outerFoo 의 변수에 접근해서 곱하고 있는 모습이다. Nested Scope 에 의해 그 역은 성립되지 않는다.&lt;/p&gt;
&lt;p&gt;이를 Lexical Scope 라고 하는데, 이는 변수나 함수가 문맥적으로 정의된 곳(Callee) 의 Context 를 참조한다는 일종의 원칙이다.&lt;/p&gt;
&lt;p&gt;(이에 대한 대칭점으로 오래된 언어들에는 Dynamic Scope 라는 개념이 있고, 이는 변수나 함수가 불려진 곳(Caller) 의 Context 를 참조하는 개념이다.)&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Javascript 의 Scope 는 기본적인 개념이라 익숙하면서도 자바스크립트의 특징적인 개념 중 하나이며, 중요한 개념인 Closure 를 이해하는 데 필수적이므로 잘 익혀두도록 하자.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- MobileAd --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-4036633281122262&quot;
     data-ad-slot=&quot;8116949665&quot;
     data-ad-format=&quot;auto&quot;
     data-full-width-responsive=&quot;true&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jins-dev.tistory.com/183&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Javascript + HTML</category>
<category>javascript</category>
<category>scope</category>
<author>널디한 진스팍</author>
<guid>https://jins-dev.tistory.com/183</guid>
<comments>https://jins-dev.tistory.com/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-Scope%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4#entry183comment</comments>
<pubDate>Sat, 11 May 2019 11:03:18 +0900</pubDate>
</item>
<item>
<title>Google Protobuf 사용 시 알아두어야 할 몇가지 Tip 들 정리</title>
<link>https://jins-dev.tistory.com/entry/Google-Protobuf-%EC%82%AC%EC%9A%A9-%EC%8B%9C-%EC%95%8C%EC%95%84%EB%91%90%EC%96%B4%EC%95%BC-%ED%95%A0-%EB%AA%87%EA%B0%80%EC%A7%80-Tip-%EB%93%A4-%EC%A0%95%EB%A6%AC</link>
<description>&lt;div class=&quot;tt_adsense_top&quot; style=&quot;margin-bottom:30px&quot;&gt;&lt;/script&gt;
	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: &quot;ca-pub-4036633281122262&quot;,
          enable_page_level_ads: true
     });
&lt;/script&gt;&lt;/div&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;구글 Protobuf 는 강력한 데이터구조이며 환경간 이식성이 뛰어나고 패킷으로 사용할 때, 자체의 성능(통신 속도 및 작은 패킷 크기)이 뛰어나지만, 정해진 형식이 있다보니 사용에 있어서 알아두어야할 점들이 몇가지 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;실무에서 사용하면서 알아두어야 했던 점들 및 특징적인 점들 몇가지를 정리해보았다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;b&gt;1.&amp;nbsp;protobuf&amp;nbsp;는&amp;nbsp;패킷간&amp;nbsp;상속과&amp;nbsp;추상화를&amp;nbsp;지원하지않는다. &lt;/b&gt;&lt;/p&gt;
&lt;p&gt;프로토버프를 도입하기 가장 꺼려지는 이유인데, protobuf 의 Data Structure는 상속과 추상화와 같은 생산성을 위한 개발자들의 구조를 부정한다.&lt;/p&gt;
&lt;p&gt;Protobuf 는 애초에 범용(?) 목적으로 설계되었다기 보다는 확실한 단일 목적에 대해 Compact 하게 설계된 Data Structure 이다.&lt;/p&gt;
&lt;p&gt;즉, 확실히 의미를 갖는 필요한 데이터만 저장할 수 있게 되어있으며, 그렇기 때문에 Stream 으로 사용할 시 필요한 정보만 주고받는 효율성을 이점으로 취할 수 있는 반면, 데이터를 담는 데 있어서 유연하지 못하다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;그렇기 때문에 프로토콜 버퍼를 패킷으로 통신을 해야 한다면 모든 패킷에 필요한 정보들을 분류해서 정의해주는 것이 필요하다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;b&gt;2.&amp;nbsp;protobuf&amp;nbsp;의&amp;nbsp;패킷&amp;nbsp;넘버링은&amp;nbsp;생각보다&amp;nbsp;엄격하지않다.&amp;nbsp;하지만&amp;nbsp;패킷의&amp;nbsp;순서는&amp;nbsp;매우&amp;nbsp;중요하다.&lt;/b&gt; &lt;/p&gt;
&lt;p&gt;다음과 같은 에러 처리를 위한 프로토콜 버퍼 Data Structure가 있다고 가정해보자.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/N6S4d/btqu13tAXew/Qfp6lY5BxQtRkV0JVKsSik/img.png' data-lightbox='lightbox' data-alt=''&gt;&lt;img src='https://k.kakaocdn.net/dn/N6S4d/btqu13tAXew/Qfp6lY5BxQtRkV0JVKsSik/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FN6S4d%2Fbtqu13tAXew%2FQfp6lY5BxQtRkV0JVKsSik%2Fimg.png' &gt;&lt;/span&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;위의 데이터 구조에서 time_stamp 패킷의 넘버링을 4로 바꿔도 무방하다. 프로토콜 버퍼에서 구조 내에서 중요한 것은 패킷들의 순서를 지키는 일이다.&lt;/p&gt;
&lt;p&gt;다만, Protocol Buffer 를 enum 형태로 정의해서 쓰는 경우라면 조금 얘기가 다른데,&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/b4rUgZ/btqu05y8Qo3/BGH3RTD2cMWHHJEfuGKKRK/img.png' data-lightbox='lightbox' data-alt=''&gt;&lt;img src='https://k.kakaocdn.net/dn/b4rUgZ/btqu05y8Qo3/BGH3RTD2cMWHHJEfuGKKRK/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fb4rUgZ%2Fbtqu05y8Qo3%2FBGH3RTD2cMWHHJEfuGKKRK%2Fimg.png' &gt;&lt;/span&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;위와 같은 Enum 패킷에서는 numbering 이 의미를 갖는다. enum 의 경우 넘버링이 Enum 클래스의 ordinal 과 동치되기 때문에, Compile 해서 사용할 경우 패킷이 다르다면 예기치 못한 에러가 발생할 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;3. Protobuf 구조가 프로토콜로 정해졌다면 데이터 구조는 변경하지 않는 것이 좋다.&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;통신에 있어서 Protobuf 를 사용하는데, 기존 데이터 구조가 삭제 또는 변경된다면 그 구조를 삭제 &amp;amp; 변경하는 것이 아니라 새로 패킷을 추가하는 편이 좋다.&lt;/p&gt;
&lt;p&gt;그 이유는 하위호환성 때문으로, 통신하는 양쪽의 Protobuf 빌드가 항상 동기화가 완벽하다면 문제가 없지만, 개발을 하다보면 버전이 달라질 수밖에 없다.&lt;/p&gt;
&lt;p&gt;이 때 문제를 방지하기 위해 데이터 구조의 크기를 늘리는 방법을 선택해야 한다.&lt;/p&gt;
&lt;p&gt;하지만 패킷의 크기가 커질지는 염려하지 않아도 된다. Protobuf 의 특징 상 입력되지않는 패킷은 보내지않도록 퍼포먼스 측면에서 최적화가 지원된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;b&gt;4.&amp;nbsp;구글이&amp;nbsp;지원해주는&amp;nbsp;protobuf&amp;nbsp;라이브러리가&amp;nbsp;있으며,&amp;nbsp;이를&amp;nbsp;사용하면&amp;nbsp;프로토버프의&amp;nbsp;사용이&amp;nbsp;매우&amp;nbsp;편리해진다.&amp;nbsp;&lt;/b&gt; &lt;/p&gt;
&lt;p&gt;다음 링크를 참조하자.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/protocolbuffers/protobuf&quot;&gt;https://github.com/protocolbuffers/protobuf&lt;/a&gt;&lt;/p&gt;
&lt;figure id=&quot;og_1557135047956&quot; contenteditable=&quot;false&quot; data-ke-type=&quot;opengraph&quot;&gt;&lt;a href=&quot;https://github.com/protocolbuffers/protobuf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-original-url=&quot;https://github.com/protocolbuffers/protobuf&quot;&gt;
&lt;div class=&quot;og-image&quot; style=&quot;background-image: url('https://scrap.kakaocdn.net/dn/bkDelk/hyA1QgCUS7/k4v9KEYSdcyEp6YXmpOdt1/img.png?width=420&amp;amp;height=420&amp;amp;face=0_0_420_420');&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;div class=&quot;og-text&quot;&gt;
&lt;p class=&quot;og-title&quot;&gt;protocolbuffers/protobuf&lt;/p&gt;
&lt;p class=&quot;og-desc&quot;&gt;Protocol Buffers - Google's data interchange format - protocolbuffers/protobuf&lt;/p&gt;
&lt;p class=&quot;og-host&quot;&gt;github.com&lt;/p&gt;
&lt;/div&gt;
&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;&lt;span style=&quot;color: #333333;&quot;&gt;protobuf 라이브러리는 언어별로 필요한 기능들을 유틸리티 형태로 지원한다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #333333;&quot;&gt;아주 방대하니 전체를 쓸 생각보다는 환경에 맞게 필요한 만큼만 모듈을 가져다 쓰는 것이 좋다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #333333;&quot;&gt;또한 protobuf&amp;nbsp;라이브러리에는&amp;nbsp;proto&amp;nbsp;파일&amp;nbsp;내에서&amp;nbsp;사용할&amp;nbsp;수&amp;nbsp;있는&amp;nbsp;공통&amp;nbsp;protobuf&amp;nbsp;형식들도 정의되어 있으므로 참고하는 것이 좋다.&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: #333333;&quot;&gt;가령&amp;nbsp;proto&amp;nbsp;파일&amp;nbsp;내에서&amp;nbsp;Collection&amp;nbsp;이나&amp;nbsp;timestamp&amp;nbsp;등의&amp;nbsp;기능을&amp;nbsp;사용할&amp;nbsp;수&amp;nbsp;있도록&amp;nbsp;정리되어있다.&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;5.&amp;nbsp;당연한&amp;nbsp;얘기지만&amp;nbsp;proto&amp;nbsp;파일의&amp;nbsp;주석조차&amp;nbsp;compile&amp;nbsp;결과로&amp;nbsp;빌드된&amp;nbsp;소스에&amp;nbsp;포함&amp;nbsp;된다.&lt;/b&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;만약&amp;nbsp;소스&amp;nbsp;자체로&amp;nbsp;어떤&amp;nbsp;스크립트가&amp;nbsp;실행되어야&amp;nbsp;한다면&amp;nbsp;환경에&amp;nbsp;주의하자.&lt;/p&gt;
&lt;p&gt;주석에 한글 특수문자가 포함된 proto 파일을 자동화 스크립트로 돌리다가 문제가 생기는 일이 더러 있었다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;프로토콜 버퍼는 구글이 지원하고 있는 직렬화방식이고 강력하며 쓰임새도 다양하다.&lt;/p&gt;
&lt;p&gt;하지만 현재로써는 아는만큼 사용할 수 있는 도구임이 분명하다. 사용에 있어 유의하고 항상 공식 지원을 참고하는 것이 좋겠다.&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- MobileAd --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-4036633281122262&quot;
     data-ad-slot=&quot;8116949665&quot;
     data-ad-format=&quot;auto&quot;
     data-full-width-responsive=&quot;true&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jins-dev.tistory.com/182&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Computer Engineering</category>
<category>data</category>
<category>Google</category>
<category>Protobuf</category>
<category>server</category>
<category>web</category>
<category>통신</category>
<author>널디한 진스팍</author>
<guid>https://jins-dev.tistory.com/182</guid>
<comments>https://jins-dev.tistory.com/entry/Google-Protobuf-%EC%82%AC%EC%9A%A9-%EC%8B%9C-%EC%95%8C%EC%95%84%EB%91%90%EC%96%B4%EC%95%BC-%ED%95%A0-%EB%AA%87%EA%B0%80%EC%A7%80-Tip-%EB%93%A4-%EC%A0%95%EB%A6%AC#entry182comment</comments>
<pubDate>Mon, 06 May 2019 18:34:45 +0900</pubDate>
</item>
<item>
<title>Access performances in Computer</title>
<link>https://jins-dev.tistory.com/entry/Access-performances-in-Computer</link>
<description>&lt;div class=&quot;tt_adsense_top&quot; style=&quot;margin-bottom:30px&quot;&gt;&lt;/script&gt;
	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: &quot;ca-pub-4036633281122262&quot;,
          enable_page_level_ads: true
     });
&lt;/script&gt;&lt;/div&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;면접에서 단골처럼 등장하는 질문이자, 컴퓨터 공학과 시험에서 한번쯤은 보았을 법한 CS 기본 지식을 정리하고자 한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;컴퓨터는 데이터를 저장할 수 있는 몇가지 종류의 공간들을 갖고 있고, 해당 공간들은 쓰임새가 다르고 만들어진 이유가 다르기 때문에 각각 I/O 작업에 있어서 다른 퍼포먼스를 낸다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;그 중에서도 Access 에 대한 다음 Computing Operation 의 속도 비교는 알아두어야 한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;- CPU Register&lt;/p&gt;
&lt;p&gt;&amp;nbsp;- Context Switch&lt;/p&gt;
&lt;p&gt;&amp;nbsp;- Memory Access (RAM)&lt;/p&gt;
&lt;p&gt;&amp;nbsp;- Disk Seek (HDD)&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;위의 Operation 들에 대한 속도 비교 결과는 빠른 순서대로 다음과 같다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;1. CPU Register Access&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;2. Memory Access&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;3. Context Switching&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;4. Disk Seek&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;(1) CPU 레지스터에 대한 접근은 단 한번의 CPU 사이클만으로 이루어지기 때문에 즉각적으로 이루어진다.&lt;/p&gt;
&lt;p&gt;한 사이클이라는 것은 말그대로 번개와 같은 속도로 이루어진다는 뜻이다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;(2) Memory Access 는 일반적으로 RAM 에서 데이터를 읽어내는 것을 말하며, 당연히 RAM 의 목적에 맞게 HDD 로부터 읽어오는 것보다 빠르다.&lt;/p&gt;
&lt;p&gt;일반적인 상태에서의 작업은 레지스트리에 접근하는 것에 비견될만큼 빠를 수 있지만 논리 구조 위에서 동작하기 때문에 Virtual Memory Swapping 과 같은 작업에서 자유로울 수 없으며 이런 경우에는 Disk Access 만큼 느려질 수도 있다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;(3) Context Switching 는 대체적으로 빠른 접근이 보장이 된다. 하지만 여러개의 프로세스가 동시에 실행되며 스위칭이 빈번하게 이뤄질 경우 굉장히 느려질 수도 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;(4) Disk Seek. HDD 에 대한 Disk Seek 은 위에 언급한 Operation 들에 비해 빠를 수가 없는 작업이지만 캐싱을 통해 비약적인 성능 향상이 가능하다.&lt;/p&gt;
&lt;p&gt;BUS 에서의 병목을 피할 수 있으며 캐싱을 통해 Main Memory 에 Access 하는 것 만큼의 퍼포먼스를 기대할 수도 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;면접에서 갑작스레 질문받은 내용이라 당황했던 적이 있었다.&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #333333;&quot;&gt;알고있었던 내용이라 답변은 잘 했으나...&lt;span&gt;&amp;nbsp;끝나고나서 다시 점검해볼만큼 기본기가 아직 충분치 못한 것 같아 정리해둔다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- MobileAd --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-4036633281122262&quot;
     data-ad-slot=&quot;8116949665&quot;
     data-ad-format=&quot;auto&quot;
     data-full-width-responsive=&quot;true&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jins-dev.tistory.com/181&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Computer Engineering</category>
<category>computer</category>
<category>Computer Scient</category>
<category>cs</category>
<category>Engineer</category>
<category>memory</category>
<category>Process</category>
<author>널디한 진스팍</author>
<guid>https://jins-dev.tistory.com/181</guid>
<comments>https://jins-dev.tistory.com/entry/Access-performances-in-Computer#entry181comment</comments>
<pubDate>Mon, 06 May 2019 17:42:25 +0900</pubDate>
</item>
<item>
<title>브라우저(Browser) 에서의 CSS 상속(Inheritance)</title>
<link>https://jins-dev.tistory.com/entry/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80Browser-%EC%97%90%EC%84%9C%EC%9D%98-CSS-%EC%83%81%EC%86%8DInheritance</link>
<description>&lt;div class=&quot;tt_adsense_top&quot; style=&quot;margin-bottom:30px&quot;&gt;&lt;/script&gt;
	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: &quot;ca-pub-4036633281122262&quot;,
          enable_page_level_ads: true
     });
&lt;/script&gt;&lt;/div&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Frontend 에 익숙하지않은 많은 개발자들이 과제 이상의 어느정도 규모있는 Frontend 를 작업하게 되면 HTML 과 CSS 의 구조에 대해 놀라는 경향이 있다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;HTML 과 CSS 는 생각보다 정교한 구조를 이루고 있고, 초보 수준 이상의 Frontend 실력을 갖기 위해서는 필수적으로 구조에 대해 이해하고 어떻게 브라우저가 웹(Web)을 스타일링하는 지 알아야 한다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;이해해야할 잘 갖춰진 Frontend 의 특징 중 하나로, &quot;HTML 문서의 모든 프로퍼티(properties) 들은 상속가능하다&quot; 는 점이 있다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;계층적으로 구조화된 DOM 모델에서 한 Element 는 Parent Element 의 속성을 지니며, 모든 element 들의 root parent 는 &amp;lt;html&amp;gt; 이 된다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;HTML 태그의 DOM 모델들 간 상속은 다른 포스팅에서 다루도록 하고, 본 포스팅에서는 CSS 의 상속에 대해 다루기로 한다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;복잡한 종류의 UI 를 구조할 때, 비슷한 CSS 스타일링을 중복해서 사용하게 되는 경우가 많이 있다.&lt;/p&gt;
&lt;p&gt;가령, 웹페이지 전체의 UI 는 어느정도 일관성이 있어야 하기 때문에, 검색을 위한 검색바(Bar)와 검색 추천을 위한 표시바(Bar) 가 있는데 이 둘의 스타일을 비슷하게 가져가되 하이라이트 컬러 정도만 바꾸고자 한다고 해보자.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;이 때, 세세하게 작업된 모든 디자인 스타일을 복사해서 사용하는 것은 비효율적인 일이다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;이럴 때에는 다음과 같이 CSS 상속을 이용해 쉽게 해결할 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/nI0Gq/btqu0TZyPX0/pZcZ1fE2kCCAu1sv1IYwiK/img.png' data-lightbox='lightbox' data-alt=''&gt;&lt;img src='https://k.kakaocdn.net/dn/nI0Gq/btqu0TZyPX0/pZcZ1fE2kCCAu1sv1IYwiK/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FnI0Gq%2Fbtqu0TZyPX0%2FpZcZ1fE2kCCAu1sv1IYwiK%2Fimg.png' &gt;&lt;/span&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;위의 코드에서 bar-focus 라는 CSS 스타일은 bar 스타일을 차용하되 background-color 에 특징을 입힌다.&lt;/p&gt;
&lt;p&gt;위의 마크업은 다음과 같은 페이지를 나타내게 된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/enzHhM/btqu1sUvgJZ/walijDgU3odCnb6SLnPj40/img.png' data-lightbox='lightbox' data-alt=''&gt;&lt;img src='https://k.kakaocdn.net/dn/enzHhM/btqu1sUvgJZ/walijDgU3odCnb6SLnPj40/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FenzHhM%2Fbtqu1sUvgJZ%2FwalijDgU3odCnb6SLnPj40%2Fimg.png' &gt;&lt;/span&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;색배합이 끔찍하지만, 스타일을 재활용할 수 있다는 점정도는 쉽게 알 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;쉽지않은가? 이런식으로 스타일의 재활용을 통해 노가다로 여겨질 수 있는 Frontend 의 디자인 코드를 확연하게 정리할 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;하지만 CSS 의 상속과 관련되어 알아야할 성질들은 조금 더 있다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;먼저 브라우저가 상속을 처리하는 순서이다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;브라우저는&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;CSS&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;상속을 &lt;span&gt;Inline &amp;gt; Internal &amp;gt; External&lt;span&gt;&amp;nbsp;순서로 처리한다.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;여기서 Inline, Internal, External 은 CSS를 정의하는 방법에 대한 분류를 말하며, 다음과 같다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;&amp;nbsp;- Inline :&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;해당 태그 안에&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;style=&amp;rdquo;&amp;rdquo;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;속성을 통해 정의&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;&amp;nbsp;- Internal :&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;해당 파일 안에&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&amp;lt;css&amp;gt; &amp;lt;/css&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;태그를 작성하고 해당&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;Scope&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;내에 정의&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;&amp;nbsp;- External :&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;별도의 파일로&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;CSS&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;를 분리하고 해당 파일을&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;HTML&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;에서&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;import&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;즉, CSS를 적용할 때에 위의 순서를 유의해야 해당 스타일이 반영될 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;letter-spacing: 0px;&quot;&gt;또 당신이 프론트엔드 개발자라면 주의해야할 사항으로 태그의 속성 관리 부분이 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;만약, CSS&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;가 적용된 태그의 속성이&lt;span&gt;&lt;span&gt;&amp;nbsp;&quot;&lt;/span&gt;float&quot;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;을 가지고 있는 경우 해당&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;DOM&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;은 상속관계 및 레이아웃에 영향을 받지않는 붕&lt;span&gt;-&lt;/span&gt;뜬 상태가 된다&lt;span&gt;.&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;해당 요소에 상속성을 적용시키기 위해서는&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;overflow&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;속성의 적용이 필요하다&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- MobileAd --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-4036633281122262&quot;
     data-ad-slot=&quot;8116949665&quot;
     data-ad-format=&quot;auto&quot;
     data-full-width-responsive=&quot;true&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jins-dev.tistory.com/180&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Javascript + HTML</category>
<category>CSS</category>
<category>Design</category>
<category>html</category>
<category>Style</category>
<category>UI</category>
<author>널디한 진스팍</author>
<guid>https://jins-dev.tistory.com/180</guid>
<comments>https://jins-dev.tistory.com/entry/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80Browser-%EC%97%90%EC%84%9C%EC%9D%98-CSS-%EC%83%81%EC%86%8DInheritance#entry180comment</comments>
<pubDate>Sun, 05 May 2019 18:15:07 +0900</pubDate>
</item>
<item>
<title>최대공약수(GCD)와 최소공배수(LCM) 를 위한 유클리드 알고리즘</title>
<link>https://jins-dev.tistory.com/entry/%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98GCD%EC%99%80-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98LCM-%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</link>
<description>&lt;div class=&quot;tt_adsense_top&quot; style=&quot;margin-bottom:30px&quot;&gt;&lt;/script&gt;
	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: &quot;ca-pub-4036633281122262&quot;,
          enable_page_level_ads: true
     });
&lt;/script&gt;&lt;/div&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;유클리드 알고리즘은 어렸을적부터 접하는 익숙한 알고리즘이지만, 수학적인 부분이 포함되어 있어 막상 구현하고자 한다면 기억해내기가 쉽지 않다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;그 중에서도 알고리즘 문제 해결 시 심심치않게 등장하면서도 중요한 최대공약수(GCD) 와 최소공배수(LCM) 를 구하기 위한 유클리드 알고리즘을 정리해보았다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;가장 원시적인(Naive) 방법으로 GCD와 LCM을 구하는 방법으로는, 브루트포스(Bruteforce) 알고리즘이 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;이는 숫자 목록을 전부 순회하면서 해당 숫자가 주어진 숫자 세트의 최대공약수 / 최소공배수 인지를 판별하는 알고리즘이다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;이 방법 자체가 복잡하다거나 한 것은 아니지만, 불필요한 값들의 조회가 많이 일어나는 비효율적인 알고리즘이다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;유클리드 알고리즘은 &quot;유클리드 호제법&quot; 이라는 방식을 통해 최대공약수를 구해내고, 이를 바탕으로 최소공배수를 구해낸다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;이 원론은 숫자 A와 B에 대하여 A를 B로 나눈 나머지 R에 대해 A와 B의 최대공약수가 B와 R의 최대공약수와 같음을 이용하며, 이 나머지 연산을 나머지가 0이 될때까지 반복함으로써 최대공약수를 구해낸다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;최소공배수를 구하는 데 있어서는 다음 성질을 이용한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;A와 B의 최대공약수 G에 대해서 최소공배수 L = A * B / G 를 만족한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;이를 통해 알고리즘적으로 구현하면 다음과 같이 구해낼 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/YCptn/btqu14FAgxu/eAf94gfnWuUk6A351mvNQ0/img.png' data-lightbox='lightbox' data-alt=''&gt;&lt;img src='https://k.kakaocdn.net/dn/YCptn/btqu14FAgxu/eAf94gfnWuUk6A351mvNQ0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FYCptn%2Fbtqu14FAgxu%2FeAf94gfnWuUk6A351mvNQ0%2Fimg.png' &gt;&lt;/span&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;좀 더 자세한 수학적 원리는 다음을 참고하자.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://staff.www.ltu.se/~larserik/applmath/chap10en/part3.html&quot;&gt;(http://staff.www.ltu.se/~larserik/applmath/chap10en/part3.html)&lt;/a&gt;&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- MobileAd --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-4036633281122262&quot;
     data-ad-slot=&quot;8116949665&quot;
     data-ad-format=&quot;auto&quot;
     data-full-width-responsive=&quot;true&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jins-dev.tistory.com/179&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Algorithm</category>
<category>Algorithm</category>
<category>Euclid</category>
<category>math</category>
<author>널디한 진스팍</author>
<guid>https://jins-dev.tistory.com/179</guid>
<comments>https://jins-dev.tistory.com/entry/%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98GCD%EC%99%80-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98LCM-%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98#entry179comment</comments>
<pubDate>Sun, 05 May 2019 17:26:18 +0900</pubDate>
</item>
<item>
<title>Java 를 이용한 Lazy Evaluation</title>
<link>https://jins-dev.tistory.com/entry/Java-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Lazy-Evaluation</link>
<description>&lt;div class=&quot;tt_adsense_top&quot; style=&quot;margin-bottom:30px&quot;&gt;&lt;/script&gt;
	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: &quot;ca-pub-4036633281122262&quot;,
          enable_page_level_ads: true
     });
&lt;/script&gt;&lt;/div&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Lazy Evaluation 이란 프로그래밍이 동작하는 데 사용되는 계산 전략의 한 종류를 말한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;일반적인 프로그래밍에서 계산식이 즉발적으로 수행되는데 비해 Lazy Evaluation 은 해당 계산식의 실제 수행을 필요할 때까지 늦춘다.&lt;/p&gt;
&lt;p&gt;이렇게 되면 장점으로는 필요하지 않은 시점에서 해당 식의 &quot;불필요한 수행&quot; 을 막을 수 있으며 어떤 경우에는 실제 수행되는 시점에조차 수행 과정에서의 불필요한 동작들을 최적화시킬 수 있다.&lt;/p&gt;
&lt;p&gt;다음의 예시를 확인해보자.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/bbCfNK/btquSzMY8Pi/Hyz9UR1PAlRyT9v6HbbCT1/img.png' data-lightbox='lightbox' data-alt=''&gt;&lt;img src='https://k.kakaocdn.net/dn/bbCfNK/btquSzMY8Pi/Hyz9UR1PAlRyT9v6HbbCT1/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbbCfNK%2FbtquSzMY8Pi%2FHyz9UR1PAlRyT9v6HbbCT1%2Fimg.png' &gt;&lt;/span&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;위의 코드에서 일반적인 수행이라면 checked 의 값은 무조건 먼저 계산이 된다.&lt;/p&gt;
&lt;p&gt;foo 함수가 얼마만큼의 비용을 수반하더라도, foo(val) 의 Return 값이 checked 가 가져야할 값이므로 일반적인 수행에서 checked 값은 foo 함수의 결과를 저장하며 그에 따라 아래의 조건식을 수행하게 된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;만약 위의 코드가 Lazy 하게 동작한다면 흐름은 조금 다르다.&lt;/p&gt;
&lt;p&gt;먼저 변수 checked 는 &lt;b&gt;foo 메서드가 val 을 argument 로 전달받아서 수행하게된 &quot;어떤 값&quot; 이라고 간주&lt;/b&gt;되고, 이를 이후 필요한 시점, 즉 조건문을 체크하는 아래 로직에서 실제로 사용하게 된다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;첫번째 조건문인 if(true &amp;amp;&amp;amp; checked) 조건문에서 foo 함수는 호출되게 된다. checked 가 true 여야지만 해당 조건이 참이되기 때문이다.&lt;/p&gt;
&lt;p&gt;하지만 &lt;b&gt;두번째 조건문에서는 foo 함수는 호출되지 않는다&lt;/b&gt;. 알다시피 true 가 이미 or 의 조건문에 포함되어 있기 때문에 compiler 는 최적화를 통해 이를 수행하지 않는다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&amp;lt;참고로 위의 예제코드는 이해를 돕기 위해 작성한 것일 뿐 실제로 Lazy 하게 동작하지 않음을 주의한다.&amp;gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;이러한 Lazy Evaluation 은 프로그래밍에서 종종 사용되는 개념이며 실제로 많은 경우에 퍼포먼스의 향상을 가져올 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Java에서도 Lazy Evaluation 을 사용할 수 있으며 보통 Java8 의 Lambda 를 이용해 이를 지원한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;이제 위의 메서드를 Lambda 식을 이용해서 Lazy Evaluation 형태로 바꾸어 보고 비교해보자.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/ydR1o/btquTjpnifn/0MUvneVV38rIi24uWeynfK/img.png' data-lightbox='lightbox' data-alt=''&gt;&lt;img src='https://k.kakaocdn.net/dn/ydR1o/btquTjpnifn/0MUvneVV38rIi24uWeynfK/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FydR1o%2FbtquTjpnifn%2F0MUvneVV38rIi24uWeynfK%2Fimg.png' &gt;&lt;/span&gt;&lt;/figure&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/DdgXV/btquRcyE9Rt/FY1CI2Kl9cZ1lTNvay4c2K/img.png' data-lightbox='lightbox' data-alt=''&gt;&lt;img src='https://k.kakaocdn.net/dn/DdgXV/btquRcyE9Rt/FY1CI2Kl9cZ1lTNvay4c2K/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FDdgXV%2FbtquRcyE9Rt%2FFY1CI2Kl9cZ1lTNvay4c2K%2Fimg.png' width=&quot;630&quot; height=&quot;520&quot;&gt;&lt;/span&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;위의 예제를 변형한 코드이다.&lt;/p&gt;
&lt;p&gt;코드에서는 Lazy Evaluation 을 함수형 인터페이스의 Supplier 메서드를 이용해 구현한 모습으로,&lt;/p&gt;
&lt;p&gt;&lt;b&gt;위의 main 동작에서 가장 마지막 조건문의 수행 시, foo 함수는 호출되지 않는다.&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;이와 같은 Lazy Evaluation 을 이용하면 사소한 부분이지만 만약 foo 함수의 비용이 막대한 경우에 큰 성능 상 이점을 가져올 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;특히 Lambda 가 대중화되고 Lazy Evaluation 과 같은 처리가 익숙해진 최근의 추세에서 확실히 개념을 이해하고 사용하는 것이 중요하겠다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;div class=&quot;tt_adsense_bottom&quot; style=&quot;margin-top:30px&quot;&gt;	&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;
&lt;!-- MobileAd --&gt;
&lt;ins class=&quot;adsbygoogle&quot;
     style=&quot;display:block&quot;
     data-ad-client=&quot;ca-pub-4036633281122262&quot;
     data-ad-slot=&quot;8116949665&quot;
     data-ad-format=&quot;auto&quot;
     data-full-width-responsive=&quot;true&quot;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;&lt;/div&gt;&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://jins-dev.tistory.com/177&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Java</category>
<category>lambda</category>
<category>lazy evaluation</category>
<category>Programming</category>
<author>널디한 진스팍</author>
<guid>https://jins-dev.tistory.com/177</guid>
<comments>https://jins-dev.tistory.com/entry/Java-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Lazy-Evaluation#entry177comment</comments>
<pubDate>Mon, 29 Apr 2019 00:28:40 +0900</pubDate>
</item>
</channel>
</rss>