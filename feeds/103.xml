<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>東Woo. KIM</title>
	<atom:link href="https://dongwoo.blog/feed/" rel="self" type="application/rss+xml" />
	<link>https://dongwoo.blog</link>
	<description>Some kind of engineer</description>
	<lastBuildDate>Wed, 07 Jun 2017 14:23:59 +0000</lastBuildDate>
	<language>en</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='dongwoo.blog' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://s0.wp.com/i/buttonw-com.png</url>
		<title>東Woo. KIM</title>
		<link>https://dongwoo.blog</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://dongwoo.blog/osd.xml" title="東Woo. KIM" />
	<atom:link rel='hub' href='https://dongwoo.blog/?pushpress=hub'/>
	<item>
		<title>[번역] 잘가요, 조</title>
		<link>https://dongwoo.blog/2019/04/29/%eb%b2%88%ec%97%ad-%ec%9e%98%ea%b0%80%ec%9a%94-joe/</link>
				<comments>https://dongwoo.blog/2019/04/29/%eb%b2%88%ec%97%ad-%ec%9e%98%ea%b0%80%ec%9a%94-joe/#respond</comments>
				<pubDate>Sun, 28 Apr 2019 15:44:06 +0000</pubDate>
		<dc:creator><![CDATA[동우]]></dc:creator>
				<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://dongwoo.blog/?p=557</guid>
				<description><![CDATA[평소엔 번역할 때 개인적인 생각을 별로 쓰지 않는 편인데, 이번엔 기술적인 내용이 아니라서 앞부분에 개인적인 감상을 좀 끄적여 보았다. 번역문만 보고싶은 분들은 영문 제목이 나올 때까지 스크롤을 내리시길 🙂 얼마 전 트위터를 보다가 문득 조 암스트롱(Joe Armstrong)이 세상을 떠났다는 소식을 들었다. 조 암스트롱은 프로그래밍 언어인 얼랭(erlang)을 설계한 사람 중 한 명으로, 위키피디아에 의하면 올해로 68세로 &#8230; <a href="https://dongwoo.blog/2019/04/29/%eb%b2%88%ec%97%ad-%ec%9e%98%ea%b0%80%ec%9a%94-joe/" class="more-link">Continue reading <span class="screen-reader-text">[번역] 잘가요, 조</span> <span class="meta-nav">&#8594;</span></a>]]></description>
								<content:encoded><![CDATA[
<blockquote class="wp-block-quote"><p>평소엔 번역할 때 개인적인 생각을 별로 쓰지 않는 편인데, 이번엔 기술적인 내용이 아니라서 앞부분에 개인적인 감상을 좀 끄적여 보았다. 번역문만 보고싶은 분들은 영문 제목이 나올 때까지 스크롤을 내리시길 <img src="https://s0.wp.com/wp-content/mu-plugins/wpcom-smileys/twemoji/2/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /><br></p></blockquote>



<p>얼마 전 트위터를 보다가 문득 <a href="https://twitter.com/FrancescoC/status/1119596234166218754">조 암스트롱(Joe Armstrong)이 세상을 떠났다는 소식</a>을 들었다. 조 암스트롱은 프로그래밍 언어인 <a href="https://ko.wikipedia.org/wiki/%EC%96%BC%EB%9E%AD">얼랭(erlang)</a>을 설계한 사람 중 한 명으로, <a href="https://en.wikipedia.org/wiki/Joe_Armstrong_(programmer)">위키피디아</a>에 의하면 올해로 68세로 아주 많지는 않은 나이지만, 폐섬유증으로 인한 감염으로 인해 조금 일찍 세상을 떠나게 된 것 같다.</p>



<p>사실 나는 프론트엔드 개발을 주로 하기 때문에 얼랭에 대해서는 별로 접할 기회가 없었다. 그나마 알고 있는 사실은 <a href="https://www.wired.com/2015/09/whatsapp-serves-900-million-users-50-engineers/">WhatsApp의 백엔드가 얼랭으로 되어 있다</a>는 것과, 병행성 프로그래밍에 특화된 언어라는 정도였다. 하지만 함수형 프로그래밍에 관심이 많다보니 여기저기서 조 암스트롱의 글이나 강의 영상을 볼 수 있었고, &#8220;백발이 되어서도 열심히 활동하시는 멋진 개발자 할아버지&#8221; 정도로 생각하고 있었다. (2018년에도 조 암스트롱이 강연하는 영상을 <a href="https://www.youtube.com/watch?v=TTM_b7EJg5E">여기</a>, <a href="https://www.youtube.com/watch?v=rmueBVrLKcY">저기</a>서 쉽게 찾을 수 있다)<br></p>



<p>이 날 트위터에는 많은 추모글들이 올라왔고, 심지어 조 암스트롱의 강의를 담은 예전 유튜브 영상에도 많은 추모의 댓글이 달렸다. 대부분 조 암스트롱으로부터 많은 감명을 받았던 사람들의 감사의 마음이 담긴 글들이었다. 그러다 문득 <a href="https://ferd.ca/goodbye-joe.html">Good bye Joe</a> 라는 추모글을 보고는, 여러 가지 생각이 떠올라 굳이 시간을 내서 번역을 하기로 했다.</p>



<p>사실 이 글을 생각없이 읽다가 감자기 큰 감명을 받아서 번역을 하게 되었는데, 처음에는 나 스스로도 이유를 잘 몰랐다. 하지만 곰곰히 생각해보니 아마도 아쉬움과 부러움의 감정이 교차하고 있었던 것 같다.</p>



<p>나는 프로그래머로서 지금 시대에 살고 있는 건 큰 행운이라고 생각한다. 그 이유는 첫째로 컴퓨터가 엄청난 속도로 세상을 변화시키고 있는 모습을 거의 처음부터 눈으로 지켜볼 수 있기 때문이고, 둘째는 그럼에도 불구하고 그 시대를 처음 열었던 전설과 같은 프로그래머들이 아직 살아있기 때문이다. 내가 사랑해 마지않는 LISP를 처음 만든 <a href="https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)">존 매커시</a>가 세상을 떠난 것도 겨우 8년 전이고, <a href="https://en.wikipedia.org/wiki/Smalltalk">스몰토크</a>를 만든 <a href="https://en.wikipedia.org/wiki/Alan_Kay">앨런 케이</a>나 <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">스킴</a>을 만든 <a href="https://en.wikipedia.org/wiki/Guy_L._Steele">가이 스틸</a> 등의 노장들은 지금까지도 활발하게 활동하며 젊은 프로그래머들에게 많은 영감을 주고 있다.</p>



<p>아마 부러움의 감정은 이런 전설같은 분들을 직접 만나서 프로그래밍에 대한 이야기를 할 수 있는 경험 때문인 것 같다. 한국은 아직 IT의 역사가 짧기 때문에 이런 전설적인 프로그래머가 거의 없기도 하거니와, 있다손 치더라도 조 암스트롱처럼 컨퍼런스에 나와서 젊은 프로그래머들과 격없이 어울리는 모습은 쉽게 상상하기가 힘들다. 물론 언어나 거리의 장벽만 극복한다면 직접 외국으로 찾아갈 수도 있겠지만, 아무래도 그런 문화를 자연스럽게 접해온 사람들이 부러운 것은 사실이다.</p>



<p>아쉬움의 감정은 이러한 전설같은 프로그래머들이 이제 하나 둘 세상을 떠나고 있다는 사실과, 국내에서는 이런 추모의 광경을 보기가 힘들다는 사실 때문인 것 같다. 이제 프로그래머가 40대에 은퇴해서 치킨집 사장이 된다는 이야기는 옛말이 되었지만, 여전히 한국에서는 롤 모델로 삼을만한 60대 이상의 프로그래머를 찾기 어려운 게 사실이다. 그럼 면에서 조 암스트롱처럼 70이 다 된 나이에도 끊임없이 열정적으로 새로운 아이디어를 생각해내고 탐구하는 모습이야말로 프로그래머들이 롤 모델로 삼을 수 있는 가장 이상적인 모습이 아닐까 싶다. 국내 개발자 커뮤니티에서도 기술적인 내용 외에 이런 훌륭한 프로그래머들에 이야기을 많이 나누면서, 프로그래머의 미래에 대해 좀 더 긍정적인 이야기들이 많이 오갔으면 하는 바람이다. </p>



<p>한동안은 아쉬운 마음에 조 암스트롱 할아버지의 강연들을 찾아서 보게될 것 같다. 잘가요. 조.<br></p>



<hr class="wp-block-separator" />



<h2>Goodbye Joe</h2>



<p>원문 주소 : <a href="https://ferd.ca/goodbye-joe.html">https://ferd.ca/goodbye-joe.html</a></p>



<p>조 암스트롱은 얼랭(earlang)의 아버지로 잘 알려져 있고, 얼랭 커뮤니티는 비교적 작은 규모로 친밀하게 유지되어 왔다. 조가 참석한 얼랭 컨퍼런스(얼랭 팩토리, 얼랭 사용자 컨퍼런스, CodeBEAM)를 처음 가 보면 누구나 비슷한 반응을 보인다. 이 커뮤니티가 얼마나 열려 있는지(accessible)를 보고 경탄하게 되는 것이다. 조나 로버트 같은 (누구나 이름만 들어도 알 수 있는) 유명인들이 나와 같은 공간에서, 친근하게, 기꺼이 모든 참석자들과 대화하고 있는 분위기에서, 마치 내가 누구든지 상관없이 환영받고 있다는 느낌을 받게 된다.</p>



<p>오늘, 조가  세상을 떠났다는 소식을 들었다. 나는 조와 아주 친한 사이는 아니었지만, 지난 십여년 동안 알고 지내며 여러 컨퍼런스에서 만날 때마다 대화를 나누곤 했다. 조가 나의 커리어에 커다란 영향을 끼쳤음은 두말할 것도 없었기에, 나는 조에 대해, 그리고 그가 남긴 영향력에 대해 작은 글이라도 써야겠다고 생각했다. 내 글이 감히 그에 대한 정당한 평가가 될 수는 없겠지만, 이 글을 꼭 써야만 할 것 같았다.</p>



<p>십여년 전, 나는 PHP를 사용해서 데이팅 사이트를 만들고 있었고, 대학에서 멀티미디어 프로그램을 갓 마친 상태였다. 그 이전에 나는 C, Python, Scheme, Javascript 등을 조금씩 사용했었고, 이후 몇 개의 언어들을 재미로 사용해 본 정도였다. 나는 채팅 시스템을 새로 만들 방법을 찾아야 했는데, 당시 페이스북이 그들의 첫 번째 채팅 시스템을 얼랭으로 만들었고(다시 C++로 작성한 이후 왓츠앱을 인수하기 전에), 팀장님이 조 암스트롱의 &#8220;프로그래밍 얼랭(초판)&#8221; 사본을 내 책상 위에 던져놓았다. </p>



<p>이것이 나와 얼랭의 첫 만남이었고, 그 인연은 지금까지 계속되고 있다. 조의 책은 마치 본인처럼 친근하고 이해하기 쉬웠다. 조는 얼랭의 기본 철학이 무엇인지, 왜 이런 설계를 했는지, 그리고 얼랭이 실현하고자 하는 장애 허용(Fault tolerance)을 위한 핵심 접근 방식이 무엇인지를 자신만의 방법으로 설명했다. 이 책은 특정 언어에 대한 책 중에서, 독자로 하여금 코드를 작성할 수 있게 해 줄 뿐 아니라 &#8220;왜&#8221; 이런 방식으로 코드를 작성해야 하는지를 이해시켜주는 보기 드문 책이다. 얼랭에 있는 기능은 단지 멋진 기능이기 때문이 아니라, 장애 허용에 필요하기 때문에 존재했다. 조가 말한 것은 어디에든 적용 가능했다. </p>



<p>나는 조가 쓴 글이라면 뭐든 찾아서 읽었던 것 같다. 그 중 몇 가지는 다음과 같다.</p>



<ul><li>프로그래밍 얼랭</li><li>세부적인 모든 원칙들과, 언어에 대한 더 많은 확장을 포함한 그의 <a href="http://erlang.org/download/armstrong_thesis_2003.pdf">박사 논문(thesis)</a>. 장애 허용을 목표로 하는 사람이라면 꼭 읽어야 할 통합적인 시도이다.</li><li><a href="https://joearms.github.io/#Index">최근 블로그</a></li><li><a href="http://armstrongonsoftware.blogspot.com/">오래된 블로그</a></li><li><a href="https://pdfs.semanticscholar.org/57d3/1ca47fa9688089b9b7e7c19c199aa03aff1e.pdf">프롤로그로 구현된 첫 얼랭의 첫 번 째 버전이 담겨 있는 오래된 연구 논문(Paper)</a></li><li>얼랭 메일링 리스트에 있는 많은 글들</li></ul>



<p>조의 글에서 언급된 내용 중에서 내가 읽은 다른 어떤 것보다 멋진 말은, &#8220;개발자들은 실수를 하게 마련이며, 그것을 완전히 막으려고 하면 안된다&#8221;는 말이다. 대신 우리는 그 실수들을 &#8220;잘 대응해야(cope with)&#8221; 한다. 조는 단지 언어에 대한 이야기를 하는 것이 아니라, 전체 시스템을 작성하는 방법을 가르쳐 주는 길 위에 우리를 내려놓았다. 하지만 조의 조언과 글은 여기서 멈추지 않는다. 조는 항상 시스템적 단순성(systematic simplicity), 독립적인 명료함(self-contained straightforwardness), 그리고 모든 것에 대한 새로운 관점을 주는 오랜 컴퓨팅 역사 이야기의 열렬한 팬이었다. </p>



<p>조는 영원히 완성될 수 없는 소프트웨어에 대해 생각하는 대신, 너무나 간단해서 실제로 완성될 수 있는 소프트웨어를 원했다. 우리가 작성하는 프로그램의 가치는 얼마나 확장 가능하고 조합 가능한가로 판단되어야 하며, 얼마나 실현 불가능한가로 판단되어선 안된다. 뿐만 아니라, 조는 영원히 동작하는 코드를 원했다. </p>



<p>조의 블로그 포스트 중, &#8220;<a href="https://joearms.github.io/#2013-11-21%20My%20favorite%20Erlang%20Program">내가 가장 좋아하는 얼랭 프로그램</a>&#8220;은 이 생각을 완벽하게 담고 있다. 조는 단순한 아이디어로 시작해서, 그 아이디어를 최대한 밀어붙여서 그 안에 숨겨져 있던 엄청난 통찰을 발견해내는 사람이었다.  그리고 조는 모든 사람들과 그 통찰을 나누었다.</p>



<p>조는 하루에도 수천 가지의 아이디어를 생각해내는 사람이었다. 아마 그 중 몇 가지는 좋거나 실용적일 수도 있다. 이들 각각의 아이디어에 잠재된 원칙들을 찾아내고, 실제 세상에서 사용 가능하도록 만들려면 아마 제대로 된 팀을 구성해야 할 것이다. 하지만 조는 전혀 개의치 않고, 항상 활기차고 행복하게 새로운 아이디어와 개념들을 탐구했다.  몇 가지는 나쁜 아이디어일 수도 있고, 몇 가지는 훌륭한 아이디어일 수도 있다. 실제 결과가 어떻게 될 지는 아무도 모르지만, 최소한 열정을 갖고 훌륭한 논의를 하게 될 것이다.  PDF가 코드 조각에 대한 문서이면서, 동시에 컴파일 된 결과물이어야 하는가? 만약 어떤 코드 조각도 이름을 갖지 않고, 단지 전역적으로 유니크한 해시만을 사용하면 어떨까? 모든 사람이 하던 일을 멈추고 프로그램간 조합성(inter-program composability)를 위해서 노력하면 얼마나 좋을까!</p>



<div class="wp-block-image"><figure class="aligncenter"><img src="https://ferd.ca/static/img/joe-fred.jpg" alt="Joe and I debugging some AV setup" /><figcaption>2014년 시카고 얼랭. 조와 내가 발표 준비를 하고 있는 모습<br>Photo by <a href="https://www.dropbox.com/sh/18w4l9vbmgu98ov/AAAiTRknnIBbJAOEmn72INRfa?dl=0">Brian Troutwine</a></figcaption></figure></div>



<p>컨퍼런스에서 모두가 원을 그리고 서서 대화를 나누고 있을 때, 만약 당신이 갑자기 조의 주의를 끌게 된다면, 그는 당신에게 한 걸음 한 걸음, 완전하게 집중된 상태로, 결국 얼굴을 맞닿을 만큼 다가갈 것이고 , 그로 인해 원이 망가지게 될 것이다. 당신은 큰 소리의 웃음과 함께 한동안 조의 온전한 관심을 독차지할 것이다. 그는 항상 이런 식이다. 당신이 어떤 주제에 대해 이야기하기 위해 조를 불렀더라도, 그가 처음 생각하던 것보다 더 흥미로운 것을 발견했다면, 그는 당신의 주제와 상관없는 새로운 것에 대해 계속해서 이야기할 지도 모른다. 하지만 아무도 그것을 싫어하지 않는다. 왜냐하면 그게 바로 조이기 때문이다. 그리고 그의 이야기는 언제나 재미있기 때문이다.</p>



<p>좀 더 개인적인 이야기를 하자면, 조는 내가 얼랭에 처음으로 기여했을 때 매우 열정적인 관심을 보여주었다. 그는 Learn You Some Erlang의 서문을 써 주었고, 항상 이야기 상대가 되어 주었다. 조는 나의 커리어에 가장 중요한 영향을 끼쳤고, 그에게서 많은 것을 받았다. 그는 자신도 모르게 나에게 길을 알려주었고, 나는 지금도 기꺼이 그 길을 걷고 있다.</p>



<p>조는 소프트웨어 외에도 음악, 조판(typesetting), 창의적 글쓰기를 너무나 좋아했고, 이것들에 대해 이야기하는 것을 즐겼다. 물론 소프트웨어만큼 전문적인 것은 아니었지만, 조는 이런 일들을 할 때에도 항상 똑같은 열정과 즐거움을 갖고 있었다.</p>



<p>조는 얼랭 세상의 한 부분이었으며, 항상 사람들이 어떤 말을 해야 하는지에 관심을 가졌다. 기술에 대한 조의 열정과 즐거움은, 심지어 그가 60대일 때에도 여전히 아주 높았으며, 나는 내가 평생 그 정도의 열정과 즐거움을 가질 수 있을 지도 잘 모르겠다. 그런 의미에서 나는 솔직히 조가 부럽다. 나는 그가 없는 커뮤니티가 어떤 느낌일 지 상상하기가 힘들다. 조는 겸손했다. 조는 모두에게 열려 있었다. 조는 활기찬 사람이었다. 조는 창의적이었다. 조의 업적은 단지 코드에만 있는 것이 아니라, 항상 그가 중심이 되어 이끌던 커뮤니티에 있다. 조가 그리울 것이다.</p>



<p>안녕 마이크,<br>안녕 로버트,<br>잘 가요 조.</p>



<p><br></p>



<p><br></p>



<p><br></p>
]]></content:encoded>
							<wfw:commentRss>https://dongwoo.blog/2019/04/29/%eb%b2%88%ec%97%ad-%ec%9e%98%ea%b0%80%ec%9a%94-joe/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/530c8460562d2041af30cba4cf26b3d0?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">gaekkr</media:title>
		</media:content>

		<media:content url="https://ferd.ca/static/img/joe-fred.jpg" medium="image">
			<media:title type="html">Joe and I debugging some AV setup</media:title>
		</media:content>
	</item>
		<item>
		<title>리액트 HOC 집중 탐구 (2)</title>
		<link>https://dongwoo.blog/2018/05/01/%eb%a6%ac%ec%95%a1%ed%8a%b8-hoc-%ec%a7%91%ec%a4%91-%ed%83%90%ea%b5%ac-2/</link>
				<comments>https://dongwoo.blog/2018/05/01/%eb%a6%ac%ec%95%a1%ed%8a%b8-hoc-%ec%a7%91%ec%a4%91-%ed%83%90%ea%b5%ac-2/#comments</comments>
				<pubDate>Tue, 01 May 2018 11:55:24 +0000</pubDate>
		<dc:creator><![CDATA[동우]]></dc:creator>
				<category><![CDATA[프로그래밍]]></category>
		<category><![CDATA[자바스크립트]]></category>

		<guid isPermaLink="false">http://dongwoo.blog/?p=533</guid>
				<description><![CDATA[이 글은 NHNEnt 의 기술블로그인 토스트 밋업에 총 2부로 연재된 ‘리액트 HOC 집중 탐구’의 두번째 글이다. 원문은 http://meetup.toast.com/posts/144에서, 영문 버전은 Medium에서 확인할 수 있다. 1부에서는 HOF(Higher Order Function)의 개념부터 시작해서 HOC(Higher Order Component)의 개념이 무엇인가와 어떤 상황에 이용될 수 있는지에 대해 알아보았다. 하지만 1부의 내용만 읽어서는 HOC를 실제 프로젝트에 어떻게 활용할 수 있는지에 대한 감이 잘 &#8230; <a href="https://dongwoo.blog/2018/05/01/%eb%a6%ac%ec%95%a1%ed%8a%b8-hoc-%ec%a7%91%ec%a4%91-%ed%83%90%ea%b5%ac-2/" class="more-link">Continue reading <span class="screen-reader-text">리액트 HOC 집중 탐구&#160;(2)</span> <span class="meta-nav">&#8594;</span></a>]]></description>
								<content:encoded><![CDATA[
<blockquote class="wp-block-quote"><p><em>이 글은 NHNEnt 의 기술블로그인 </em><a href="http://meetup.toast.com"><em>토스트 밋업</em></a><em>에 총 2부로 연재된 ‘리액트 HOC 집중 탐구’의 두번째 글이다. 원문은 <a href="http://meetup.toast.com/posts/144">http://meetup.toast.com/posts/144</a>에서, 영문 버전은 <a href="https://medium.com/@toastui/a-deep-dive-into-the-react-hoc-2-3e8ed18b848b">Medium</a>에서 확인할 수 있다.</em></p></blockquote>



<p><a href="https://dongwoo.blog/2018/03/01/%eb%a6%ac%ec%95%a1%ed%8a%b8-hoc-%ec%a7%91%ec%a4%91-%ed%83%90%ea%b5%ac-1/">1부</a>에서는 HOF(Higher Order Function)의 개념부터 시작해서 HOC(Higher Order Component)의 개념이   무엇인가와 어떤 상황에 이용될 수 있는지에 대해 알아보았다. 하지만 1부의 내용만 읽어서는 HOC를 실제 프로젝트에 어떻게  활용할  수 있는지에 대한 감이 잘 잡히지 않았을 것이다.</p>



<p>2부에서는 실제로 간단한 HOC를 만들어보고, 그 과정에서 발생할 수 있는 문제들과 이를 어떤 식으로 해결하는지, 그리고 지켜야할 컨벤션에 어떤 것들이 있는지에 대해 살펴보도록 하겠다.</p>



<h2>기본 예제: window의 스크롤 추적하기</h2>



<p>간단한 예제로 시작해보자. 먼저 윈도우의 스크롤 위치가 변경될 때마다 해당 위치를 화면에 출력하는 컴포넌트를 만들어보겠다. 이를 위해서는 컴포넌트가 mount 될 때와 unmount 될 때 <code>window</code>의 <code>scroll</code> 이벤트 핸들러를 각각 등록, 해제해 주는 과정이 필요하다.</p>



<pre class="wp-block-preformatted">class WindowScrollTracker extends React.Component {<br>  state = {<br>    x: 0,<br>    y: 0<br>  }<br><br>  scrollHandler = () =&gt; {<br>    this.setState({<br>      x: window.pageXOffset,<br>      y: window.pageYOffset<br>    });<br>  };<br><br>  componentDidMount() {<br>    window.addEventListener('scroll', this.scrollHandler);<br>  }<br> <br>  componentWillUnmount() {<br>    window.addEventListener('scroll', this.scrollHandler);<br>  }<br><br>  render() {<br>    return (       <div>      X: {this.state.x},</div>      Y: {this.state.y}<br>    );<br>  }<br>}</pre>



<p>좀 번거롭긴 하지만, 그리 길지 않은 코드로 간단하게 구현할 수 있다. 하지만 만약 윈도우의 스크롤 위치가 변경될 때마다 
반응해야 하는 컴포넌트가 여러 개 있다면 어떨까? 이 경우 동일한 형태의 로직이 각 컴포넌트에 중복해서 들어가게 될 것이다. 
이러한 로직을 보통 횡단 관심사(Cross-Cutting Concerns)라고 하는데, HOC를 활용하면 코드 중복을 효율적으로 
제거할 수 있다.</p>



<p>자, 그럼 위의 컴포넌트 코드를 활용해서 HOC를 만들어 보도록 하겠다. 무엇부터 해야 할까? 먼저 HOC의 정의가 무엇인지 다시 기억해보자.</p>



<pre class="wp-block-preformatted">const compY = HOC(compX);</pre>



<p>HOC는 컴포넌트를 인자로 받아서 새로운 컴포넌트를 반환하는 함수이다. 즉, 가장 먼저 할 일은 함수를 만드는 일이다.</p>



<pre class="wp-block-preformatted">function withWindowScroll(WrappedComponent) {<br>  return class extends React.Component {<br>    // ...<br>  }<br>}</pre>



<p>새롭게 반환되는 컴포넌트 클래스는 <code>render</code> 메소드를 제외하고는 처음에 만들었던 <code>WindowScrollTracker</code>와 동일하다. <code>render</code> 메소드에서는 <code>withWindowScroll</code> 함수에서 인자로 받은 <code>WarppedComponent</code>를 렌더링하면서, <code>state</code>로 관리하고 있는 <code>x</code>와 <code>y</code> 정보를 props로 내려주면 된다.</p>



<p>여기서 주의할 점은, <code>x</code>, <code>y</code> 외에도 <code>WrappedComponent</code>가 사용하는 자신만의 props가 있을 것이므로, 해당 props도 모두 전달해 주어야 한다는 점이다.</p>



<pre class="wp-block-preformatted">function withWindowScroll(WrappedComponent) {<br>  return class extends React.Component {<br>    // ... 나머지 코드는 WindowSizeTracker 와 동일<br>    render() {<br>      return &lt;WrappedComponent {...this.props} x={this.state.x} y={this.state.y} /&gt;<br>    }<br>  }<br>}</pre>



<p>자, 그럼 이 <code>withWindowScroll</code> HOC 함수를 이용해서 처음에 만들었던 <code>WindowSizeTracker</code>를 다시 정의해보자.
기존 로직에서 <code>render</code> 메소드만 남기고 모두 제거한 다음 HOC를 호출해서 새로운 컴포넌트를 정의하면 된다.
이제 <code>render</code> 메소드에서는 <code>this.state</code> 대신에 <code>withWindowScroll</code>통해 내려받은 props를 이용하면 된다.</p>



<pre class="wp-block-preformatted">function PositionTracker({x, y}) {<br>  return (<br>    X: {x}, Y: {y}<br>  )<br>} <br><br>const WindowScrollTracker = withWindowScroll(PositionTracker);</pre>



<p>이렇게 만들어진 HOC는 이제 윈도우의 스크롤 위치를 반영해야 하는 어떠한 컴포넌트에도 사용될 수 있다. 예를 들어, 
스크롤이 최상단에 위치할 때만 &#8220;Top&#8221; 이라는 문자를 화면에 출력하는 컴포넌트가 있다면 다음과 같이 간단하게 구현할 수 있다.</p>



<pre class="wp-block-preformatted">function TopStatus({y}) {<br>  return (<br><div>    <div></div>      {y === 0 && "It's on Top!!"}<br>    </div><br>  )<br>}<br><br>const WindowScrollTopStatus = withWindowScroll(TopStatus);</pre>



<h2>HOC 커스터마이징 1 : 파라미터 추가하기</h2>



<p>이제, 위의 예제를 좀 더 발전시켜보자. 만약, <code>withWindowScroll</code>를 사용하는 컴포넌트가 스크롤 이벤트를 throttle 시켜서 사용하고 싶다면 어떻게 해야 할까? 컴포넌트마다 원하는 <code>wait</code> 값이 다를 수 있으므로, 추가적인 인자를 받아야만 처리할 수 있을 것이다. 그럼 두 번째 인자를 객체 형태로 받아서, 원하는 커스텀 값을 받을 수 있도록 기존 코드를 수정해 보자.</p>



<pre class="wp-block-preformatted">import {throttle} from 'lodash-es'; <br><br>function withWindowScroll(WrappedComponent, {wait = 0} = {}) {<br>  return class extends React.Component {<br>    // 나머지 코드는 동일<br><br>    // 코드를 단순화하기 위해, wait 값이 0인 경우에도 throttle 함수를 이용하도록 하자.     <br>    scrollHandler = throttle(() =&gt; {<br>      this.setState({<br>        x: window.pageXOffset,<br>        y: window.pageYOffset<br>      });  <br>    }, wait);<br><br>    render() {<br>      return &lt;WrappedComponent {...this.props} x={this.state.x} y={this.state.y}<br>    }<br>  }<br>}</pre>



<p>이제, 다음과 같이 각 컴포넌트가 원하는 throttle 값을 넘겨서 사용할 수 있게 되었다.</p>



<pre class="wp-block-preformatted">const WindowScrollTracker = withWindowScroll(PositionTracker, {wait: 30}); <br>const WindowScrollTopStatus = withWindowScroll(TopStatus, {wait: 100});</pre>



<h2>HOC 커스터마이징 2: props mapper</h2>



<p>현재 <code>withWindowScroll</code> 함수 통해 반환되는 컴포넌트는 <code>x</code>, <code>y</code>를 props 로 주입받고 있다. 이 때 동일한 이름의 props를 주입시켜 주는 또 다른 HOC를 중첩해서 사용한다면 어떻게 될까? 예를 들어 마우스의 위치를 <code>x</code>, <code>y</code>라는 이름으로 주입시켜 주는 <code>withMousePosition</code> 라는 HOC를 다음과 같이 사용한다고 가정해보자.</p>



<pre class="wp-block-preformatted">const SinglePositionTracker = withMousePosition(withWindowScroll(PositionTracker));</pre>



<p>이 경우, <code>withWindowScroll</code>을 통해 주입된 <code>x</code>, <code>y</code>는 <code>withMousePosition</code>에서 주입되는 <code>x</code>, <code>y</code>에 의해 덮어씌워질 것이다.
이렇듯, 중첩된 HOC의 props 이름이 충돌할 수 있다는 점이 HOC의 단점으로써 종종 언급되곤 하는데, 이는 mapper 함수를 제공함으로써 간단하게 해결될 수 있다.</p>



<p>아마 많은 사람들에게 익숙할 react-redux 라이브러리의 <code>connect</code> 함수에서 사용하는 <code>mapStateToProps</code>을 떠올려 보면 쉽게 이해할 수 있을 것이다. <code>connect</code> 함수의 역할 중 하나는 스토어에 저장된 <code>state</code>를 컴포넌트로 주입시켜 주는 것인데,
이 때 <code>mapStateToProps</code> 함수를 이용해 컴포넌트가 사용하고 싶은 <code>state</code>만 선택할 수 있고 원하는 props의 이름도 지정할 수 있다.</p>



<pre class="wp-block-preformatted">const mapStateToProps = (state) =&gt; ({<br>  userName: state.user.name,<br>  userScore: state.user.score<br>}); <br><br>const ConnectedComponent = connect(mapStateToProps)(MyComponent);</pre>



<p>이렇게 하면 <code>MyComponent</code>에서는 전체 state 대신 <code>userName</code>과 <code>userScore</code> 라는 이름의 props 만을 전달받게 된다. 마찬가지 방식으로 HOC 함수를 호출할 때, 주입받고 싶은 props를 객체로 반환하는 mapper 함수를 전달할 수 있도록 하면 이름 충돌을 해결할 수 있게 된다. <code>withWindowScroll</code>, <code>withMousePosition</code> 함수에 이를 적용해보면 다음과 같이 사용할 수 있을 것이다.</p>



<pre class="wp-block-preformatted">function PositionTracker({scrollX, scrollY, mouseX, mouseY}) {<br>  return (<br>    <div><br><div>      ScrollX: {scrollX},</div>      ScrollY: {scrollY},<br>      mouseX: {mouseX},<br>      mouseY: {mouseY}<br>    </div><br>  )<br>} <br><br>const windowScrollOptions = {<br>  wait: 30,<br>  mapProps: ({x, y}) =&gt; ({<br>    scrollX: x,<br>    scrollY: y<br>  })<br>}<br><br>const mousePositionOptions = {<br>  mapProps: ({x, y}) =&gt; ({<br>    mouseX: x,<br>    mouseY: y<br>  })<br>} <br><br>const EnhancedPositionTracker = withMousePotision(<br>  withWindowScroll(PositionTracker, windowScrollOptions),<br>  mousePositionOptions<br>);</pre>



<p>그럼 이제 <code>withWindowScroll</code> 함수도 조금 수정해서, <code>mapProps</code> 함수를 지원할 수 있도록 해 보자.</p>



<pre class="wp-block-preformatted">import {throttle, identity} from 'lodash-es'; <br><br>function withWindowScroll(WrappedComponent, {wait = 0, mapProps = identity} = {}) { <br>  return class extends React.Component {<br>    render() {<br>      const {x, y} = this.state;<br>      const passingProps = mapProps({x, y});<br>      <br>      return &lt;WrappedComponent {...this.props} {...passingProps} /&gt;<br>    }<br>  }<br>}</pre>



<p>이 <code>mapProps</code>를 이용하면 연산을 통해 전혀 다른 데이터를 props로 전달할 수도 있다. 예를 들어 위에서 구현했던 <code>TopStatus</code>의 경우 스크롤의 Y값이 0인지의 여부만 알면 되는데, 이 경우 <code>mapProps</code>를 활용하면 다음과 같이 더 효율적으로 구현할 수 있다.</p>



<pre class="wp-block-preformatted">class TopStatus extends React.PureComponent {<br>  render() {<br>    return (<br>      <div><br>        {this.props.isScrollOnTop && "It's on Top!!"}<br>      </div><br>    )<br>  }<br>} <br><br>const ScrollTopStatus = withWindowScroll(TopStatus, {<br>  wait: 30,<br>  mapProps: ({y}) =&gt; ({<br>    isScrollOnTop: y === 0<br>  })<br>});</pre>



<p>위의 코드에서 <code>TopStatus</code>가 <code>PureComponent</code>인 것을 볼 수 있을 것이다. 사실 <code>TopStatus</code>는 스크롤 Y값이 0인지 아닌지의 여부만 확인하면 되는데, 기존 구현에서는 스크롤 값이 변경될 때마다 항상 새로운 props를 전달받기 때문에 불필요한 렌더링이 계속해서 발생하고 있었다. 변경된 코드에서는 <code>isScrollOnTop</code> 값이 변경될 때에만 props로 전달받으므로, <code>PureComponent</code>를 이용해 불필요한 렌더링을 방지할 수 있다.</p>



<h2>HOC 중첩 &#8211; compose</h2>



<p>위에서 <code>withMousePosition</code>와 <code>withWindowScroll</code>를 중첩해서 사용하는 경우 코드를 다시 한 번 살펴보자.</p>



<pre class="wp-block-preformatted">const EnhancedPositionTracker = withMousePotision(<br>  withWindowScroll(PositionTracker, windowScrollOptions),<br>  mousePositionOptions<br>);</pre>



<p>함수의 호출과 각각의 인자값이 중첩되어 있어 한눈에 알아보기가 힘들 것이다. 만약 여기서 몇가지 HOC를 더 중첩해서 사용하게 된다면, 코드는 점점 알아보기 힘들게 된다.</p>



<p>이러한 문제를 해결하기 위해 리액트에서는 HOC를 위한 <a href="https://reactjs.org/docs/higher-order-components.html#convention-maximizing-composability">컨벤션</a>을 제안하고 있다. 컨벤션은 react-redux의 <code>connect</code> 함수와 같은 형태라고 볼 수 있는데, 아래에서 볼 수 있듯이 <code>connect</code> 함수는 사실 HOC가 아니고 HOC를 반환하는 함수이다.</p>



<pre class="wp-block-preformatted">// 추가 인자가 적용된 HOC를 생성한다 <br>const enhance = connect(mapStateToProps, mapDispatchToProps); <br><br>// HOC는 하나의 인자(컴포넌트)만 받는다.<br>const EnhancedComponent = enhance(MyComponent);</pre>



<p>즉, HOC 함수가 항상 하나의 인자(컴포넌트)만을 받을 수 있도록 하고, 이를 위한 또다른 함수를 제공하는 것이다. 이 형식에 맞게 <code>withWindowScroll</code>의 API를 변경하면 다음과 같을 것이다.</p>



<pre class="wp-block-preformatted">const windowScrollOptions = {<br>  wait: 30,<br>  mapProps: ({y}) =&gt; ({<br>    isScrollOnTop: y === 0<br>  })<br>}; <br><br>const enhance = withWindowScroll(windowScrollOptions); <br>const EnhancedComponent  = enhance(MyComponent);</pre>



<p>이렇게 모든 HOC가 하나의 동일한 인자만을 받게 되면, <code>Component =&gt; Component</code> 와 같은 형식이 되므로 lodash의 <code>flow</code>나 redux의 <code>compose</code> 함수 등 함수의 조합을 도와주는 라이브러리를 이용해서 좀 더 우아하게 중첩된 HOC를 처리할 수 있다. 예를 들어, 기존의 중첩 HOC 예제에서 react-redux의 <code>connect</code> 함수까지 더해 총 세 개의 HOC를 중첩해서 사용한다고 해 보자. 이 경우 <code>compose</code> 함수를 활용한다면 다음과 같이 간결하게 구현할 수 있다.</p>



<pre class="wp-block-preformatted">import {compose} from 'redux'; <br>import {connect} from 'react-redux'; <br><br>// ... <br><br>const enhance = compose(<br>  withMousePosition(mousePositionOptions),<br>  withWindowScroll(windowScrollOptions),<br>  connect(mapStateProps, mapDispatchToProps)<br>); <br><br>const EnhancedComponent = enhance(MyComponent);</pre>



<p><code>withWindowScroll</code> 함수에서 이를 지원하는 방법은 어렵지 않다. 기존의 컴포넌트를 반환하던 로직을 함수로 한 번 더 감싸면 된다.</p>



<pre class="wp-block-preformatted">function withWindowScroll({wait = 0, mapProps = identity} = {}) {   <br>  return function(WrappedComponent) {<br>    return class extends React.Component {<br>      // 클래스 코드는 기존과 동일<br>    }<br>  }<br>}</pre>



<h2>디버깅 &#8211; Display Name</h2>



<p>마치기 전에 한 가지만 더 언급해야 할 것 같다. 어떻게 보면 HOC의 단점 중의 하나라고 볼 수 있는데, 위의 예제와 같이
 코드를 작성할 경우 실제 HOC에 의해 반환되는 컴포넌트는 이름 없는 익명 컴포넌트가 된다. 이를 리액트 개발자 도구를 통해 
확인해 보면 다음과 같이 보일 것이다.</p>



<figure class="wp-block-image"><img data-attachment-id="537" data-permalink="https://dongwoo.blog/37006868-c988f954-211d-11e8-93ed-5aa7919babd7/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2019/02/37006868-c988f954-211d-11e8-93ed-5aa7919babd7.png?w=1100" data-orig-size="624,204" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="37006868-c988f954-211d-11e8-93ed-5aa7919babd7" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2019/02/37006868-c988f954-211d-11e8-93ed-5aa7919babd7.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2019/02/37006868-c988f954-211d-11e8-93ed-5aa7919babd7.png?w=1100?w=624" src="https://dongwoodotblog.files.wordpress.com/2019/02/37006868-c988f954-211d-11e8-93ed-5aa7919babd7.png?w=1100" alt="" class="wp-image-537" srcset="https://dongwoodotblog.files.wordpress.com/2019/02/37006868-c988f954-211d-11e8-93ed-5aa7919babd7.png 624w, https://dongwoodotblog.files.wordpress.com/2019/02/37006868-c988f954-211d-11e8-93ed-5aa7919babd7.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2019/02/37006868-c988f954-211d-11e8-93ed-5aa7919babd7.png?w=300 300w" sizes="(max-width: 624px) 100vw, 624px" /></figure>



<p>이처럼 <code>_class3</code>, <code>_class2</code> 같은 이름으로는 디버깅 할 때 어떤 컴포넌트인지 정확한 정보를 알기가 쉽지 않다. 그래서 리액트에서는 HOC에서 반환하는 컴포넌트에 대해 <code>displayName</code>을 지정하도록 컨벤션을 정해놓고 있다.</p>



<p>위의 그림에서 react-redux의 <code>connect</code> 함수가 반환하는 컴포넌트는 <code>Connect(_class3)</code> 라는 이름을 갖고 있는 것이 보일 것이다. 이렇게 대문자로 시작하는 HOC의 이름과 괄호 안에 적용되는 컴포넌트의 <code>displayName</code> 을 합쳐서 표시하는 것이 컨벤션이다. <code>withWindowScroll</code> 함수에 적용하려면 다음과 같이 작성하면 된다.</p>



<pre class="wp-block-preformatted">// 컴포넌트의 displayName이 지정되어 있을 수도 있고, 아닌 경우도 있기 때문에  // 이런 헬퍼 함수가 별도로 필요하다. <br>function getDisplayName(WrappedComponent) {<br>  return WrappedComponent.displayName || WrappedComponent.name || 'Component'; <br>} <br><br>function withWindowScroll({wait = 0, mapProps = identity} = {}) {<br>  return function(WrappedComponent) {<br>    return class extends React.Component {<br>      // 현재 static 필드 문법은 Stage 2 상태이다.<br>      // 사용할 수 없는 환경에서는 외부에서 클래스의 static 멤버를 직접 지정하면 된다.<br>      static displayName = `WithWindowScroll(${getDisplayName(WrappedComponent)})`;<br>      // 나머지 코드는 기존과 동일<br>    }<br>  }<br>}</pre>



<p>뭔가 코드가 좀 더 복잡해진 것 같긴 한데, 사실 이를 지키지 않아도 상관은 없다. 하지만 추후 디버깅을 쉽게 하기 위해서는 컨벤션을 따르는 것이 도움이 될 것이다. 이렇게 수정하고 나면 개발자 도구에서 다음과 같이 보이게 된다.</p>



<figure class="wp-block-image"><img data-attachment-id="536" data-permalink="https://dongwoo.blog/37006866-c83ac9ce-211d-11e8-8bb6-95ef5e07e28f/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2019/02/37006866-c83ac9ce-211d-11e8-8bb6-95ef5e07e28f.png?w=1100" data-orig-size="624,203" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="37006866-c83ac9ce-211d-11e8-8bb6-95ef5e07e28f" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2019/02/37006866-c83ac9ce-211d-11e8-8bb6-95ef5e07e28f.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2019/02/37006866-c83ac9ce-211d-11e8-8bb6-95ef5e07e28f.png?w=1100?w=624" src="https://dongwoodotblog.files.wordpress.com/2019/02/37006866-c83ac9ce-211d-11e8-8bb6-95ef5e07e28f.png?w=1100" alt="" class="wp-image-536" srcset="https://dongwoodotblog.files.wordpress.com/2019/02/37006866-c83ac9ce-211d-11e8-8bb6-95ef5e07e28f.png 624w, https://dongwoodotblog.files.wordpress.com/2019/02/37006866-c83ac9ce-211d-11e8-8bb6-95ef5e07e28f.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2019/02/37006866-c83ac9ce-211d-11e8-8bb6-95ef5e07e28f.png?w=300 300w" sizes="(max-width: 624px) 100vw, 624px" /></figure>



<h2>2부를 마치며</h2>



<p>2부에서는 간단한 HOC로 시작해서 조금씩 기능을 추가해 가면서 몇가지 기법들과 컨벤션들에 대해서 설명해 보았다.
여기서 다룬 내용만 잘 숙지하고 있으면, 실제 프로젝트에서 HOC를 활용하는 데에 크게 문제가 없을 것이다.</p>



<p>사실, 지금까지는 대부분 HOC를 어떻게 활용하는지와 장점에 대해서만 주로 설명했지만 HOC에는 여러가지 단점도 있다. shallow 렌더링을 중첩된 HOC를 테스트 하는 경우에도 추가적인 작업이 필요하고, <code>WrappedComponent</code>의 정적 멤버들을 사용하려고 할 때에도 추가작업이 필요하며, 렌더링 시에 <code>WrappedComponent</code> 에서 필요한 정보를 전달받아 처리하기도 쉽지 않다.</p>



<p>이런 이유로 인해 최근에는 Render Props에 대한 관심이 높아지고 있는데, 얼마전 리액트 공식 홈페이지에도  <a href="https://reactjs.org/docs/render-props.html">Render Props 관련 문서</a>가 추가되었다. 심지어 16.3.0에서 새롭게 변경된 <a href="https://github.com/acdlite/rfcs/blob/new-version-of-context/text/0000-new-version-of-context.md#basic-example">Context API</a>가 Render Props 형식을 사용하면서 더 힘을 얻기도 했다.</p>



<p>(관심있는 분들은 이전에 NHNEnt FE 위클리에서 번역했던 글 &#8211; <a href="https://github.com/nhnent/fe.javascript/wiki/January-1---January-5,-2018">Render Props을 이용하자</a> &#8211; 을 읽어보면 좋을 것 같다)</p>



<p>하지만, 개인적으로 Render Props는 단지 HOC보다 더 나은 개념이 아니며, 두 기법은 각각의 장단점을 갖고 있다고
 생각한다. HOC를 적절히 잘 사용한다면 리액트에서의 중복 코드를 깔끔하게 제거할 수 있으며, 컴포넌트 조합을 통해 좀더 유연한
 구조를 만들 수 있을 것이다.</p>
]]></content:encoded>
							<wfw:commentRss>https://dongwoo.blog/2018/05/01/%eb%a6%ac%ec%95%a1%ed%8a%b8-hoc-%ec%a7%91%ec%a4%91-%ed%83%90%ea%b5%ac-2/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/530c8460562d2041af30cba4cf26b3d0?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">gaekkr</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2019/02/37006868-c988f954-211d-11e8-93ed-5aa7919babd7.png" medium="image" />

		<media:content url="https://dongwoodotblog.files.wordpress.com/2019/02/37006866-c83ac9ce-211d-11e8-8bb6-95ef5e07e28f.png" medium="image" />
	</item>
		<item>
		<title>리액트 HOC 집중 탐구 (1)</title>
		<link>https://dongwoo.blog/2018/03/01/%eb%a6%ac%ec%95%a1%ed%8a%b8-hoc-%ec%a7%91%ec%a4%91-%ed%83%90%ea%b5%ac-1/</link>
				<comments>https://dongwoo.blog/2018/03/01/%eb%a6%ac%ec%95%a1%ed%8a%b8-hoc-%ec%a7%91%ec%a4%91-%ed%83%90%ea%b5%ac-1/#comments</comments>
				<pubDate>Thu, 01 Mar 2018 09:30:04 +0000</pubDate>
		<dc:creator><![CDATA[동우]]></dc:creator>
				<category><![CDATA[프로그래밍]]></category>
		<category><![CDATA[자바스크립트]]></category>

		<guid isPermaLink="false">http://dongwoo.blog/?p=530</guid>
				<description><![CDATA[이 글은 NHNEnt 의 기술블로그인 토스트 밋업에 총 2부로 연재된 ‘리액트 HOC 집중 탐구’의 첫번째 글이다. 원문은 http://meetup.toast.com/posts/137에서, 영문 버전은 Medium에서 확인할 수 있다. 리액트가 정식으로 릴리즈된 지도 벌써 4년이 훌쩍 지났다. 얼마전 나온 16.0 버전에 이르기까지 내부적으로도 많은 발전이 있었고, 수 많은 리액트 관련 라이브러리들이 나오는 등 외부적으로도 많은 발전이 있었다. 지금은 거의 대세가 되어 &#8230; <a href="https://dongwoo.blog/2018/03/01/%eb%a6%ac%ec%95%a1%ed%8a%b8-hoc-%ec%a7%91%ec%a4%91-%ed%83%90%ea%b5%ac-1/" class="more-link">Continue reading <span class="screen-reader-text">리액트 HOC 집중 탐구&#160;(1)</span> <span class="meta-nav">&#8594;</span></a>]]></description>
								<content:encoded><![CDATA[
<blockquote class="wp-block-quote"><p><em>이 글은 NHNEnt 의 기술블로그인 </em><a href="http://meetup.toast.com"><em>토스트 밋업</em></a><em>에 총 2부로 연재된 ‘리액트 HOC 집중 탐구’의 첫번째 글이다. 원문은 <a href="http://meetup.toast.com/posts/137">http://meetup.toast.com/posts/137</a>에서, 영문 버전은 <a href="https://medium.com/@toastui/a-deep-dive-into-the-react-hoc-1-fb431c131866">Medium</a>에서 확인할 수 있다.</em></p></blockquote>



<p>리액트가 정식으로 릴리즈된 지도 벌써 4년이 훌쩍 지났다. 얼마전 나온 16.0 버전에 이르기까지 내부적으로도 많은 발전이 
있었고, 수 많은 리액트 관련 라이브러리들이 나오는 등 외부적으로도 많은 발전이 있었다. 지금은 거의 대세가 되어 버린 
리액트이기에 장점을 나열하자면 지루한 내용이 되겠지만, 꼭 짚고 넘어가고 싶은 장점은 4년이 넘게 지나도록 핵심 개념이나 중요 
API가 거의 그대로 유지되고 있다는 것이다. 나는 이것이 리액트가 처음부터 추구했던 가치가 시간이 지나도 퇴색되지 않을만큼 
의미있다는 것을 입증하고 있다고 생각한다.</p>



<p>비록 리액트의 핵심 개념에는 큰 변화가 있지 않았지만, 리액트를 사용하는 방식에는 꽤 많은 변화가 있었다. 특히 2015년 등장한 <a href="https://redux.js.org/">리덕스</a>로 인해 단일 불변 스토어 사용, 컴포넌트와 컨테이너의 구분, Redux-Thunk / Redux-Saga 등을 이용한 비동기 처리 등의 개념은 이제 거의 관용적인 패턴으로 자리잡았다고 볼 수 있다.</p>



<p>그리고 사실상의 표준으로 자리잡은 또 하나의 중요한 개념이 바로 Higher Order Component(이하 HOC)를 이용한 코드 재사용 패턴이다. 기존의 <a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html">믹스인을 사용한 패턴이 점차 안티 패턴으로 인식</a>되고, 리액트나 리덕스를 만든 유명 프로그래머들의 지지에 힘입어 이제 HOC는 코드 재사용을 위한 <a href="https://reactjs.org/docs/higher-order-components.html">리액트의 표준 방식</a>으로
 자리잡았다. 하지만 다른 모든 패턴들과 마찬가지로, HOC는 모든 경우를 위한 만병통치약이 아니며 잘못 사용할 경우에는 오히려 
기존의 믹스인 방식보다도 더 나쁜 코드를 만들어낼 수 있다. 특히 리액트에 처음 입문하는 사람들에게 HOC는 생소하고 어색한 
개념이기 때문에, HOC의 핵심 개념을 제대로 이해하지 못한 채 잘못 사용하는 경우가 많다.</p>



<p>나름 리액트로 1년 넘게 <a href="https://drive.toast.com/">꽤 큰 규모의 복잡한 어플리케이션</a>을
 만들어 오면서, 어느 정도 HOC에 대해 정리해볼 만큼의 경험이 쌓인 것 같다. 아직 부족하긴 하지만 개인적인 정리를 위해서, 또
 경험의 공유를 위해서 야심차게 HOC 집중 탐구 시리즈를 시작해볼까 한다. 이 글에서는 HOC가 무엇인지부터 시작해서, 사용시 
주의해야 할 점, 다른 패턴들과의 차이점 등에 대해서 상세하게 설명해 보도록 하겠다.</p>



<h2>함수형 프로그래밍
</h2>



<p>리액트에서 가장 중요한 개념 중의 하나임에도 불구하고 개발자들이 주로 간과하는 부분이 있는데, 그건 바로 리액트가 함수형 
프로그래밍을 지향한다는 것이다. 리액트의 공식 홈페이지에 함수형 프로그래밍이라는 단어가 정확하게 명시되어 있지 않기 때문에, 무슨
 소리냐고 반문하는 사람도 있을 것이다. 하지만 리액트의 많은 곳에 함수형 프로그래밍의 철학이 묻어 있으며, 가장 인기있는 스토어
 관리 라이브러리인 리덕스 또한 순수 함수와 불변 스토어를 강조하며 함수형에 가까운 프로그래밍 스타일을 권장하고 있다.</p>



<blockquote class="wp-block-quote"><p>리액트는 조단 워크(Jordan Walke)가 개발했는데, 처음 만들 때 <a href="https://www.reactiflux.com/transcripts/jordan-walke/">함수형 언어인 ML기반 언어들에서 많은 영향을 받았다</a>고 한다. 또한 조단 워크는 페이스북에서 최근에 발표한 언어인 <a href="https://reasonml.github.io/">Reason</a>을 개발하기도 했는데, 이 역시 ML 언어인 Ocaml을 기반으로 해서 자바스크립트에 친숙한 형식으로 발전시킨 언어이다. 사실 <a href="https://www.reactiflux.com/transcripts/cheng-lou/">Reason의 개발이 리액트보다 먼저 시작되었고, 그 과정에서 리액트가 개발되었다</a>고 한다. 즉, 어떻게 보면 리액트는 함수형 언어로 프론트엔드 개발을 하기 위한 중간 과정에서 나온 자바스크립트 라이브러리라고도 할 수 있는 것이다.</p></blockquote>



<p>여기서 어떤 부분이 함수형에 가까운지를 하나하나 설명하기는 어려울 것 같지만, HOC를 설명하기 위해 꼭 하나 짚고 
넘어가야할 특징이 있다. 이 부분이 앵귤러(Angular)나 뷰(Vue)같은 다른 라이브러리들과 가장 차별화되는 부분인데, 바로 
컴포넌트가 (순수)함수라는 점이다.</p>



<h2>컴포넌트는 (순수)함수이다
</h2>



<p>리액트의 컴포넌트는 기본적으로 함수이다. 그것도 순수 함수. 좀더 자세히 이야기하자면 입력값으로 <code>props</code> 를 받고, <code>ReactElement</code> 트리를 반환하는 순수 함수이다. 리액트는 실제로 순수 함수로 컴포넌트를 생성할 수 있으며, 리액트 공식 홈페이지에서도 볼드체로 다음과 같이 명시하고 있다.</p>



<blockquote class="wp-block-quote"><p>All React components must act like pure functions with respect to their props.</p></blockquote>



<p>&#8220;그럼 <code>React.Component</code> 를 상속받는 클래스 컴포넌트는 뭐란 말인가&#8221; 라고 궁금해할 
사람들이 있을지도 모르겠다. 물론 컴포넌트의 상태를 관리하거나 생명주기(Life Cycle)에 훅(Hook)을 걸어 원하는 시점에
 특정 함수를 실행하려면 순수 함수만으로는 구현이 어려울 것이다. 그렇기 때문에 처음 리액트가 나왔을 때는 <code>createClass</code> 함수를 이용하여 컴포넌트를 생성하도록 API가 설계되었다.</p>



<p>하지만 엄밀히 말하면 컴포넌트의 상태 관리는 함수의 클로저를 사용해서 관리할 수 있고 (이 경우 순수 함수는 아니다), 
생명주기 관련 함수들은 맵(Map)의 형태로 묶거나, 컴포넌트 함수의 프라퍼티 형태로 관리할 수 있다. 즉, 컴포넌트가 함수라는 
기본 개념을 유지한 채로도 얼마든지 어플리케이션을 만들 수 있는 것이다. 다만, 기존 객제지향 개발자들에게 함수형 프로그래밍은 
익숙하지 않기 때문에 좀더 익숙한 클래스 형태의 API를 제공한 것이다. 클래스 컴포넌트의 경우에도 render 메소드 자체를 
컴포넌트라고 여긴다면 컴포넌트가 함수라는 개념은 여전히 유효하다.</p>



<p>실제로 리액트의 컴포넌트는 다른 객체지향 방식의 컴포넌트와는 다르게 동작한다. 객체간의 직접 참조나 메소드 호출을 통해서 
서로간의 메시지를 주고받는 것이 아니며, 데이터의 흐름은 함수 호출처럼 오직 부모(호출하는 함수)에서 자식(호출되는 함수)을 향해
 단방향으로 진행된다. 즉, 복잡한 ReactElement 트리를 구성하기 위해 컴포넌트 내부에서 다른 컴포넌트를 함수처럼 
호출해서 결과값(ReactElement)를 받은 후 조합해서 반환할 뿐인 것이다.</p>



<p>사실, 기존에 사용되던 믹스인에 대한 비판들은 단순히 리액트에서의 문제만은 아니다. 믹스인을 통한 코드 재사용 방식에 대한 문제점은 리액트를 굳이 언급하지 않더라도 <a href="http://raganwald.com/2016/07/16/why-are-mixins-considered-harmful.html">기존 객체 지향 방식에서도 이미 존재하고 있었다</a>. 물론 객체 지향으로도 <a href="http://raganwald.com/2016/07/20/prefer-composition-to-inheritance.html">이를 해결할 수 있는 방법</a>이
 없는 건 아니지만, 애초에 함수형 방식을 지향하는 라이브러리가 기존 객체 지향 방식의 문제까지 같이 끌어안고 해결하려는 것은 
굳이 먼 길을 돌아가는 일일 것이다. 각자에게 맞는 옷이 있듯이, 함수형의 세계에서는 그 세계에 맞는 해결 방식이 있는 것이다.</p>



<h2>Higher Order Function
</h2>



<p>사실 함수형 프로그래밍에 익숙한 사람들은 HOC라는 이름을 보았을 때 어떤 역할을 하는지를 바로 유추할 수 있었을 것이다. 함수형 프로그래밍에서는 <a href="https://en.wikipedia.org/wiki/Higher-order_function">Higher Order Function</a>(이하 HOF)라는 아주 유사한 개념이 있기 때문이다. 이름에서 알 수 있듯이 HOC라는 이름은 바로 HOF에서 유래한 것이다. 그러니 HOC에 대해 알아보기 앞서, 먼저 HOF에 대해 알아보는 것이 도움이 될 것이다.</p>



<p>HOF는 함수를 인자로 받아서 새로운 함수를 반환하는 함수이다. 한 문장에 &#8216;함수&#8217;라는 단어가 세 번이나 나와서 난해하게 느껴질 수도 있는데, 다음과 같이 코드로 표현해보면 이해가 좀더 쉬울 것이다.</p>



<pre class="wp-block-preformatted">const fy = HOF(fx);</pre>



<p>즉, fx를 인자로 받아서 fy를 반환하는 함수라고 볼 수 있다. 사실 자바나 C#처럼 함수가 일급객체가 아닌 언어에서는 이해하기 힘든 개념일 수도 있지만, 자바스크립트와 같이 함수가 일급객체인 언어에서는 나름 익숙한 패턴이다. <a href="https://lodash.com/">Lodash</a>와 같은 함수형 라이브러리에 익숙하다면 많이 사용해 보았을 <code>_.throttle</code>, <code>_.debounce</code>, <code>_.partial</code>, <code>_.flip</code>, <code>_.once</code> 등의 함수들도 모두 HOF이다. 예를 들어 <code>_.partial</code> 함수는 다음과 같이 기존 함수의 인자를 고정시킨 새로운 함수를 반환해준다.</p>



<pre class="wp-block-preformatted">const add = (v1, v2) =&gt; v1 + v2; <br>const add3 = _.partial(add, 3); <br>const add5 = _.partial(add, 5); <br><br>console.log(add3(10)); // 13 <br>console.log(add5(10)); // 15</pre>



<p>HOF의 장점은 함수에 기능을 추가하는 코드를 재사용 할 수 있다는 것이다. 만약 <code>add</code> 함수를 이용해서 <code>partial</code> 함수가 없이 <code>add3</code> 과 <code>add5</code> 함수를 만드려면 다음과 같이 직접 두 개의 함수를 만들어야 할 것이다.</p>



<pre class="wp-block-preformatted">const add3 = v =&gt; add(v + 3); <br>const add5 = v =&gt; add(v + 5);</pre>



<p>하지만 HOF를 이용하면 기능 단위로 새로운 함수를 만들어내는 코드를 재사용할 수 있게 된다. 위의 예제는 너무 간단해서 
체감이 잘 안될 수도 있지만, 좀더 복잡한 형태의 HOF인 경우 많은 양의 중복 코드를 제거할 수 있을 것이다.</p>



<p>이해를 돕기 위해 위의 <code>_.partial</code> 함수를 직접 구현해 보도록 하자. 구현을 쉽게 하기 위해 
인자 2개를 받는 함수의 첫번째 인자만 고정하도록 제한하면, 다음과 같이 간단하게 구현할 수 있다. 단순한 형태의 경우 화살표 
함수를 사용하는 것이 더 직관적이므로, 화살표 함수를 사용해서 구현해 보았다.</p>



<pre class="wp-block-preformatted">const partial = (f, v1) =&gt; v2 =&gt; f(v1, v2); <br>const add3 = partial(add, 3); <br>const add5 = partial(add, 5); <br><br>console.log(add3(10)); // 13 <br>console.log(add5(10)); // 15</pre>



<p>위의 <code>_.partial</code> 예제와 동일하게 동작하는 것을 볼 수 있을 것이다.</p>



<p>다음으로 넘어가기 전에 좀더 유용한 HOF를 만들어보자. 앞서 말했듯이 함수의 클로저를 이용하면 내부 상태를 갖는 함수를 
만들 수 있다. 간단한 예로 함수의 반환값을 0부터 계속 누적시켜서 적용된 값을 반환하도록 하는 HOF를 만들어 보자. 복잡한 
형태에서는 화살표 함수에 익숙하지 않으면 더 알아보기가 어려울 수도 있으므로 여기서부터는 <code>function</code> 키워드를 사용하도록 하겠다.</p>



<pre class="wp-block-preformatted">function acc(f) {   <br>  let v = 0;   <br>  return function() {     <br>    v = f(v);<br>    return v;<br>  }<br>} <br><br>const acc3 = acc(add3); <br>console.log(acc3()); // 3 <br>console.log(acc3()); // 6 <br>console.log(acc3()); // 9</pre>



<p>HOF를 이용하면 부수효과를 만들어낼 수도 있다. 간단한 예제로, 결과값을 반환하기 전에 <code>console.log</code> 콘솔에 로그를 출력하도록 하는 HOF를 만들어보자. 이번에도 구현을 간단하게 하기 위해 인자 하나를 받는 함수만 이용하도록 제한하도록 하겠다.</p>



<pre class="wp-block-preformatted">function logger(f) {   <br>  return function(v) {<br>    const result = f(v);<br>    console.log(result);   <br>    return result;<br>  }<br>}<br><br>const add3Log = logger(add3); <br><br>console.log(add3Log(10)); // 13, 13 <br>console.log(add3Log(15)); // 18, 18</pre>



<p>실행 결과 로그가 두 번씩 찍히는 것을 볼 수 있다. 즉, 내부적으로 로그를 남긴 후 결과값도 제대로 반환해준다는 것을 확인할 수 있다.</p>



<p>지금껏 3개의 HOF를 직접 만들었다. 이제 이들 HOF를 한 번에 조합해서 새로운 함수를 만들어보자. <code>partial</code>, <code>acc</code>, <code>logger</code> 를 모두 사용하면 다음과 같이 0부터 시작해서 3씩 더한 결과값을 누적시키면서 로그를 남기는 함수를 만들 수 있을 것이다.</p>



<pre class="wp-block-preformatted">const acc3Log = logger(acc(partial(add, 3))); <br><br>acc3Log(); // 3 <br>acc3Log(); // 6  <br>acc3Log(); // 9</pre>



<p>함수형 프로그래밍은 기본적으로 작은 단위의 범용적인 함수를 만들고 이들을 조합해 가면서 프로그램을 만들어나가는 방식을 
취한다. HOF는 이러한 기능 단위의 함수들을 조합해서 재사용할 수 있는 패턴을 제공함으로써 함수형 프로그래밍에서 아주 중요한 
역할을 하고 있다.</p>



<h2>Higher Order Component
</h2>



<p>앞서 잠깐 언급했듯이, HOC는 바로 HOF에서 유래한 단어이다. 즉, 컴포넌트를 인자로 받아서 컴포넌트를 반환하는 함수를 뜻한다. 위에서 언급한 HOF의 정의와 동일하게 표현하자면, 다음과 같이 표현할 수 있을 것이다.</p>



<pre class="wp-block-preformatted">const compY = HOC(compX);</pre>



<blockquote class="wp-block-quote"><p>사실 HOC라는 이름에는 약간의 허점이 있다. HOF가 함수를 인자로 받아 함수를 반환하는 함수(문장에 함수가 세 번 
들어가고 있음에 주목)라면 HOC는 컴포넌트를 인자로 받아 컴포넌트를 반환하는 컴포넌트인 것이 자연스러울 것이다. 하지만 HOC는
 사실 컴포넌트가 아닌 함수를 지칭한다. 이 이름에 대한 비판의 목소리도 있지만, HOF와 유사한 개념이라는 것이 더 강조되는 
효과도 있으므로, 관대하게 넘어가도록 하자.</p></blockquote>



<p>그럼 이 HOC를 어떤 식으로 사용할 수 있을까? 이왕 HOF에서 시작했으니 앞의 예제를 그대로 컴포넌트에 적용해 보도록 하자. 먼저 <code>partial</code> 함수처럼, Props를 고정한 형태의 컴포넌트를 반환하게 할 수 있을 것 같다. 한번 만들어보자.</p>



<pre class="wp-block-preformatted">function withProps(Comp, props) {<br>  return function(ownProps) {<br>    return &lt;Comp {...props} {...ownProps} /&gt;<br>  }<br>}</pre>



<p><code>partial</code> 의 예제와 다른 점이 몇가지 있는데, 먼저 컴포넌트는 열거된 인자가 아닌 props라는
 객체를 입력값으로 받는다는 점이다. 즉, 특정 props를 고정하고 싶다면 해당 Props를 객체로 받은 다음, 반환되는 
컴포넌트의 Props에 합쳐주는 식으로 구현해야 한다. 또하나의 다른점은 컴포넌트는 단순히 값을 반환하는 것이 아닌 
ReactElement 를 반환한다는 점이다. 그러므로 반환되는 컴포넌트는 인자로 넘어온 컴포넌트를 ReactElement화 
시켜서(JSX 이용) 반환해 주어야 한다.</p>



<p>이제, 이 <code>withProps</code> HOC를 사용하는 예제를 살펴보자.</p>



<pre class="wp-block-preformatted">function Hello(props) {<br>  return <div>Hello, {props.name}. I am {props.myName}</div><br>}<br><br>const HelloJohn = withProps(Hello, {name: 'John'}); <br>const HelloMary = withProps(Hello, {name: 'Mary'}); <br><br>const App = () =&gt; (<br>  <div><br>    <br>    <br>  </div><br>)</pre>



<p><code>Hello</code> 컴포넌트는 props로 <code>name</code> 과 <code>myName</code> 을 입력받는다. <code>withProps</code> 를 이용해 <code>name</code> 을 고정한 형태의 컴포넌트인 HelloJohn 과 HelloMary 컴포넌트를 만들어내면, 이들 컴포넌트는 <code>myName</code> 만 넘겨주어도 미리 고정된 <code>name</code> 값을 이용할 수 있게 된다.</p>



<p>한가지만 하면 아쉬우니, 위의 <code>logger</code> 도 HOC에 맞게 다시 구현해보자. 컴포넌트는 결과값을 로그로 남기는 것에 큰 의미가 없으니, 넘겨받은 props를 콘솔에 출력하도록 하겠다. <code>withProps</code> 를 만들때와 마찬가지로 Props와 반환값에만 유의하면 된다. logger는 굳이 props를 받을 필요가 없으니, 좀더 간단하게 구현할 수 있다.</p>



<pre class="wp-block-preformatted">function logger(Comp) {
  return function(props) {
    console.log(props);
    return &lt;Comp {...props} /&gt;
  }
}</pre>



<p>HOF와 마찬가지로 HOC도 여러개의 HOC를 동시에 조합해서 하나의 컴포넌트를 만들어낼 수 있다. 자, 그럼 이제 위의 두 HOC를 조합해서 사용해보자.</p>



<pre class="wp-block-preformatted">const HelloJohn = withProps(logger(Hello), {name: 'John'});
const HelloMary = withProps(logger(Hello), {name: 'Mary'});</pre>



<p>이제, <code>HelloJohn</code> 와 <code>HelloMary</code> 는 렌더링을 할때마다 현재 넘겨받은 props를 콘솔에 출력하게 된다. 위의 App 컴포넌트를 렌더링해 보면 각 컴포넌트의 <code>name</code> 과 <code>myName</code> props가 모두 콘솔에 출력되는 것을 확인할 수 있을 것이다.</p>



<h2>HOC로 할 수 있는 것들
</h2>



<p>지금껏 HOC의 개념을 익히기 위해 간단한 HOC들을 작성해 보았는데, 이런 단순한 형태의 HOC만 가지고는 그리 유용하다는
 느낌이 들지 않을 것이다. 하지만 HOC로 할 수 있는 일들은 이보다 훨씬 다양하며, 기존의 믹스인 방식에서 할 수 있던 거의 
모든 것들을 할 수 있다. 가장 많이 쓰이는 형태가 아마 스토어와 컴포넌트를 연결시켜 주는 HOC일 것이다. 일단 가장 널리 
쓰이는 react-redux의 <code>connect</code> 함수 이를 위한 함수인데, 엄밀히 HOC를 생성해주는 헬퍼 함수라고 할 수 있다. <code>connect</code> 함수는 스토어의 상태를 Props으로 주입시켜주는 <code>mapStateToProps</code> 와 액션 생성 함수를 스토어의 dispatch와 연결시켜 props로 주입시켜 주는 <code>mapDispatchToProps</code> 를 인자로 받아서 새로운 HOC를 반환한다.</p>



<pre class="wp-block-preformatted">import {connect} from 'react-redux'; <br>import {PersonComponent} from './person'; <br><br>const mapStateToProps = state =&gt; ({<br>  name: state.name,<br>  age: state.age<br>});<br>const mapDispatchToProps = {<br>  setName: (name) =&gt; {type: 'SET_NAME', name},<br>  setAge: (age) =&gt; {type: 'SET_AGE', age} <br>}; <br><br>// HOC 생성 <br>const connectHOC = connect(mapStateToProps,mapDispatchToProps); <br><br>// HOC가 적용된 컴포넌트 생성 <br>const ConnectedComponent = connectHOC(PersonComponent);</pre>



<p>이 외에도 몇가지 HOC로 할 수 있는 중요한 기능들을 나열하면 다음과 같다.</p>



<ul><li>생명주기 메소드 주입</li><li>State 및 이벤트 핸들러 주입</li><li>Props 변환 및 주입</li><li>Render 함수 확장</li></ul>



<p>생명주기 메소드나 State를 다루기 위해서는 함수 컴포넌트가 아닌 클래스 컴포넌트를 이용해야 하는데, 다음 글에서 이들을 
이용해 좀더 유용한 HOC를 만들어보도록 하겠다. 만약 함수 컴포넌트만으로 위의 기능들을 구현하고 싶은 분들이 있다면 <a href="https://github.com/acdlite/recompose">Recompose</a> 라이브러리를 확인해보기 바란다. Recompose는 자칭 리액트 컴포넌트를 위한 Lodash로서, 범용적으로 쓰일 수 있는 HOC의 모음이라고 할 수 있다. Recompose의 <code>withState</code> 나 <code>lifecycle</code> 함수를 사용하면 함수 컴포넌트 만으로도 State나 생명주기 함수들을 주입할 수 있다. 또한 수많은 유용한 HOC 헬퍼를 제공하고 있기 때문에, <a href="https://github.com/acdlite/recompose/blob/master/docs/API.md">API</a>를 한번 훑어보기만 해도 HOC가 어떻게 사용될 수 있는지 파악하는 데에 큰 도움이 될 것이다.</p>



<h2>1부 정리
</h2>



<p>이상으로 HOC에 대한 기본 개념과 간단한 사용법에 대해 살펴보았다. 보통은 기존 믹스인으로 구현한 코드를 어떻게 HOC 
변경하는지를 보여주면서 설명을 많이 하는데, 이 글에서는 일부러 함수형 프로그래밍에 대한 설명부터 시작해서 HOF를 거쳐 
HOC까지 개념을 확장해 보았다. 개인적으로 리액트가 함수형 프로그래밍을 지향한다는 사실을 계속 염두에 두고 있는 것이 좀더 
자연스러운 코드를 작성하는 데에 도움이 될 것이라 생각하기 때문이다. 어쩌다보니 HOF에 대한 설명이 HOC보다 길어진 
느낌이지만, HOC에 대한 내용은 2부에서 좀더 상세히 다룰테니, 양해를 바란다.</p>



<p><a href="https://dongwoo.blog/2018/05/01/%eb%a6%ac%ec%95%a1%ed%8a%b8-hoc-%ec%a7%91%ec%a4%91-%ed%83%90%ea%b5%ac-2/">2부</a>에서는 좀더 유용한 HOC를 만들어보면서 실제 HOC가 사용되는 패턴들과 사용시 주의해야 할 점들에 대해 좀더 자세하게 알아보도록 하겠다.</p>
]]></content:encoded>
							<wfw:commentRss>https://dongwoo.blog/2018/03/01/%eb%a6%ac%ec%95%a1%ed%8a%b8-hoc-%ec%a7%91%ec%a4%91-%ed%83%90%ea%b5%ac-1/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/530c8460562d2041af30cba4cf26b3d0?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">gaekkr</media:title>
		</media:content>
	</item>
		<item>
		<title>자바스크립트에서 타임존 다루기 (2)</title>
		<link>https://dongwoo.blog/2017/10/22/%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8%ec%97%90%ec%84%9c-%ed%83%80%ec%9e%84%ec%a1%b4-%eb%8b%a4%eb%a3%a8%ea%b8%b0-2/</link>
				<comments>https://dongwoo.blog/2017/10/22/%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8%ec%97%90%ec%84%9c-%ed%83%80%ec%9e%84%ec%a1%b4-%eb%8b%a4%eb%a3%a8%ea%b8%b0-2/#respond</comments>
				<pubDate>Sat, 21 Oct 2017 15:17:45 +0000</pubDate>
		<dc:creator><![CDATA[동우]]></dc:creator>
				<category><![CDATA[자바스크립트]]></category>
		<category><![CDATA[타임존]]></category>

		<guid isPermaLink="false">http://dongwoo.blog/?p=506</guid>
				<description><![CDATA[1부에서 자바스크립트의 타임존 지원은 다른 언어에 비해 상당히 부족한 편이라고 이야기했다. 하지만 미약하나마 자바스크립트에서도 타임존을 다룰 수 있는 방법을 제공하고는 있다. 2부에서는 자바스크립트에서 지원하는 타임존 관련 API들과 이들의 한계에 대해 좀더 자세히 알아보고, 이를 보완할 수 있는 방법을 찾아보도록 하겠다.]]></description>
								<content:encoded><![CDATA[<p><em>NHNEnt의 기술블로그인 Toast Meetup에 연재된 &#8216;자바스크립트에서 타임존 다루기&#8217;의 두 번째 글이다. 1부에서는 타임존과 오프셋에 대한 개념과 IANA timezone Database 등에 대해 자세히 설명하고 있다. 이 글은 1부에서 다룬 내용을 바탕으로 자바스크립트에서의 타임존에 대해 설명하고 있으므로, 1부를 읽지 않은 분들은 꼭 먼저 읽어보길 권한다.</em></p>
<ul>
<li><em>원문 : <a href="http://meetup.toast.com/posts/130">http://meetup.toast.com/posts/130</a></em></li>
<li><em>이전 글 : <a href="https://dongwoo.blog/2017/10/22/자바스크립트에서-타임존-다루기-1/" target="_blank" rel="noopener">자바스크립트에서 타임존 다루기 (1)</a></em></li>
</ul>
<p>1부에서 자바스크립트의 타임존 지원은 다른 언어에 비해 상당히 부족한 편이라고 이야기했다. 하지만 미약하나마 자바스크립트에서도 타임존을 다룰 수 있는 방법을 제공하고는 있다. 2부에서는 자바스크립트에서 지원하는 타임존 관련 API들과 이들의 한계에 대해 좀더 자세히 알아보고, 이를 보완할 수 있는 방법을 찾아보도록 하겠다.</p>
<h2>서버 &#8211; 클라이언트 환경에서의 타임존</h2>
<p>먼저 타임존을 고려해야 하는 간단한 시나리오를 생각해보자. 시간 정보를 다루어야 할테니 간단한 일정 관리 프로그램이 어울릴 것 같다. 먼저, 클라이언트 환경에서 사용자가 등록 페이지에서 입력박스에 일정(날짜 및 시간) 입력하면, 그 정보를 서버로 전송해서 DB에 저장된다. 그리고 목록 페이지에서는 클라이언트가 다시 서버로부터 등록된 일정의 정보를 받아와서 화면에 보여주게 된다.</p>
<p>이때 유의할 점은, 서버에 저장된 동일한 데이터에 접근하는 클라이언트들이 서로 다른 타임존을 갖고 있을 수 있다는 점이다. 즉, 서울에서 2017년 3월 10일 오전 11시 30분이라는 일정을 등록하고, 뉴욕에서 해당 일정을 조회한다면 2017년 3월 10일 오후 9시 30분이라고 표시되어야 한다. 이런식으로 다양한 타임존의 클라이언트 환경을 지원하기 위해서는 서버에 저장되는 데이터가 타임존에 영향을 받지 않는 절대값이어야 한다. 서버에서 이러한 절대값을 어떤 데이터 형태로 저장하는지는 각 서버나 데이터베이스 환경에 따라 다를 것이며, 이 글의 주제를 벗어나는 내용이므로 깊게 다루지 않겠다. 다만, 이를 위해서는 클라이언트에서 서버에 전달하는 날짜 및 시간 정보가 동일한 오프셋(보통 UTC)에 맞추어진 값이거나, 해당 클라이언트 환경의 타임존 정보까지 포함된 값이어야 할 것이다.</p>
<p>일반적으로 이런 데이터는 UTC를 기준으로 한 <a href="https://en.wikipedia.org/wiki/Unix_time" target="_blank" rel="noopener">유닉스 시간</a>이나 오프셋 정보가 포함된 <a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener">ISO-8601</a>와 같은 형태로 전송하게 된다. 위의 예시에서 서울의 2017년 3월 10일 오후 9시 30분은 유닉스 시간을 이용한다면 숫자 타입의 <code>1489113000</code> 이 될 것이고, ISO-8601을 이용한다면 문자열 타입의 <code>2017-03-10T11:30:00+09:00</code> 가 될 것이다.</p>
<p>브라우저 환경에서 자바스크립트를 이용해 이러한 처리를 해야 한다면, 우리는 사용자의 입력 값을 위와 같은 형식으로 변환하는 작업과, 위와 같은 형식의 데이터를 받아서 사용자의 타임존에 맞게 변환하는 작업 두 가지를 모두 고려해야 한다. 흔히 사용하는 용어로 표현하자면 앞의 작업은 파싱(Parsing), 그리고 뒤의 작업은 포맷팅(Formatting)이라고 할 수 있을 것이다. 그러면, 자바스크립트에서 이들을 어떻게 처리하는지 하나씩 살펴보도록 하자.</p>
<blockquote><p>Node.js를 이용한 서버 환경에서 자바스크립트를 사용할 때에도 경우에 따라 클라이언트로부터 전달받은 데이터를 파싱해야 하는 등의 작업이 필요할 때가 있다. 하지만, 보통 서버 환경의 타임존은 데이터베이스와 동일하게 설정되어 있고, 포맷팅을 주로 클라이언트에게 위임하는 경우가 많기 때문에 브라우저 환경보다는 고려할 요소가 적을 것이다. 이 글에서는 브라우저 환경을 중심으로 설명하도록 하겠다.</p></blockquote>
<h2>자바스크립트의 Date 객체</h2>
<p>자바스크립트에서 날짜나 시간과 관련된 모든 작업은 Date 객체를 이용해서 처리한다. Array나 Function과 같이 ECMAScript 스펙에 정의되어 있는 네이티브 객체이며, 주로 C++과 같은 네이티브 코드로 구현된다. API는 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noopener">MDN 문서</a>에 잘 정리되어 있는데, Java의 <a href="https://docs.oracle.com/javase/7/docs/api/java/util/Date.html" target="_blank" rel="noopener">java.util.Date</a> 클래스에서 영향을 많이 받았다고 한다. 그래서 불변(Immutable) 데이터가 아니라는 점이나, Month가 0으로 시작하는 등의 안좋은 특징까지 같이 공유하고 있다.</p>
<p>자바스크립트의 Date 객체는 내부적으로 유닉스 시간과 같은 절대값으로 시간 데이터를 관리한다. 하지만 생성자나 <code>parse()</code> 함수, <code>getHour()</code>, <code>setHour()</code> 등의 메소드들은 모두 클라이언트의 로컬 타임존 (정확히는 브라우저가 실행되는 운영체제에 설정된 타임존)에 영향을 받는다. 그러므로 사용자가 입력한 데이터를 이용해 그대로 Date 객체를 생성하거나 값을 지정한다면 그 데이터는 클라이언트의 로컬 타임존을 그대로 반영하게 될 것이다.</p>
<blockquote><p>1부에서 잠깐 언급했듯이, 자바스크립트는 임의로 타임존을 변경할 수 있는 방법을 제공하지 않는다. 그러므로, 일단 브라우저의 타임존 설정을 그대로 반영해도 되는 상황이라고 가정하고 설명을 이어가도록 하겠다.</p></blockquote>
<h2>사용자의 입력값을 이용한 Date 객체 생성</h2>
<p>처음의 예시를 계속 이어가 보자. 사용자가 타임존이 서울로 설정된 기기에서 2017년 3월 11일 오전 11시 30분을 입력했다. 이 입력값을 년도, 월, 일, 시, 분 단위로 각각 숫자 형태의 2017, 2, 11, 11, 30 로 저장했다고 가정해보자. (월은 0부터 시작하기 때문에 3에서 1을 뺀 2가 되어야 한다). 생성자를 이용하면, 각 단위별 숫자값을 이용해서 간단하게 Date 객체를 생성할 수 있다.</p>
<pre>var d1 = new Date(2017, 2, 11, 11, 30);
d1.toString(); // Sat Mar 11 2017 11:30:00 GMT+0900 (KST)
</pre>
<p><code>d1.toString()</code> 이 반환하는 값을 보면 생성된 객체의 절대값은 오프셋 +09:00 (KST) 기준의 2017년 3월 11일 11시 30분인 걸 알 수 있다.</p>
<p>생성자를 이용하는 또 하나의 방법은 문자열 데이터를 이용하는 것이다. Date 객체의 생성자에 문자열 타입의 값을 사용하면, 내부적으로 <code>Date.parse()</code>를 호출하여 적절한 값을 계산해내며, 이 함수는 <a href="https://tools.ietf.org/html/rfc2822#section-3.3" target="_blank" rel="noopener">RFC2888</a> 스펙과 <a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener">ISO-8601</a> 스펙을 지원한다. 하지만 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse" target="_blank" rel="noopener">MDN의 Date.parse() 문서</a>에도 나와있듯이, 이 메소드의 결과값은 브라우저마다 구현상태가 다르고, 문자열의 형태에 따라 정확한 값을 예측하기 어렵기 때문에 사용하지 않기를 권장하고 있다.</p>
<p>예를 들어 <code>2015-10-12 12:00:00</code> 같은 문자열은 사파리나 IE의 경우 <code>NaN</code> 을 반환하고, 크롬이나 파이어폭스의 경우 로컬 타임존의 값을 반환하며, 경우에 따라 다른 환경에서는 UTC 기준의 값을 반환하기도 한다.</p>
<h2>서버 데이터를 이용한 Date 객체 생성</h2>
<p>이제, 서버로부터 데이터를 전달받는 경우를 생각해보자. 만약 데이터가 숫자형의 유닉스 시간값이라면, 간단하게 생성자를 이용해서 Date 객체를 생성할 수 있다. 앞에서는 설명을 생략했지만, <code>Date</code> 생성자는 인자로 숫자 하나만을 받으면 년도값으로 생각하지 않고, 밀리초 단위의 유닉스 시간으로 인식한다. (주의: 자바스크립트는 유닉스 시간값을 밀리초 단위로 다룬다. 즉, 초 단위로 계산된 값이라면 1000을 곱해주어야 한다) 아래의 예제를 보면 이전 예제와 동일한 결과값을 반환하는 것을 볼 수 있다.</p>
<pre>var d1 = new Date(1489199400000);
d1.toString(); // Sat Mar 11 2017 11:30:00 GMT+0900 (KST)
</pre>
<p>그러면 유닉스 시간이 아닌 ISO-8601과 같은 문자열 타입은 어떨까? 앞 절에서 설명했듯이 <code>Date.parse()</code> 메소드는 결과를 신뢰할 수 없기 때문에 사용하지 않는 것을 권장하고 있다. 하지만 ECMAScript 5판부터 ISO-8601 을 지원하도록 명시되어 있기 때문에, ECMAScript 5판을 지원하는 IE9 이상의 브라우저에서는 주의해서 사용하면 ISO-8601 형식의 문자열을 Date 생성자에 사용할 수 있다.<br />
여기서 주의할 점은, 최신 브라우저가 아닌 경우 마지막에 Z 문자가 없으면 UTC 기준으로 해석해야 함에도 불구하고 로컬 타임을 기준으로 해석하는 경우가 있다는 점이다. 아래의 예제는 IE10 에서 실행시킨 결과이다.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> d1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">'2017-03-11T11:30:00'</span>);
<span class="hljs-keyword">var</span> d2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">'2017-03-11T11:30:00Z'</span>);
d1.toString(); <span class="hljs-comment">// "Sat Mar 11 11:30:00 UTC+0900 2017"</span>
d2.toString(); <span class="hljs-comment">// "Sat Mar 11 20:30:00 UTC+0900 2017"</span>
</code></pre>
<p>스펙에 따르면 두 결과값이 같아야 함에도 불구하고, <code>d1.toString()</code>과 <code>d2.toString()</code>의 결과값이 다른 것을 볼 수 있다. 최신 브라우저에서는 두 결과가 동일할 것이므로, 브라우저 버전별로 다르게 해석되는 문제를 막기 위해서는 타임존 데이터가 없는 경우 문자열의 마지막에 항상 <code>Z</code>를 추가해 주어야 한다.</p>
<h2>서버로 전달할 데이터 생성</h2>
<p>이제 앞서 생성된 Date 객체를 이용하면 로컬 타임존을 기준으로 날짜나 시간을 더하거나 빼는 등의 연산을 자유롭게 할 수 있다. 하지만 마지막에 다시 서버로 데이터를 전송하기 위해서는 데이터를 변환하는 과정이 필요하다.</p>
<p>먼저 유닉스 시간 형식의 경우 <code>getTime()</code> 메소드를 이용해서 간단하게 수행할 수 있다. (앞에서와 마찬가지로 밀리초 단위라는 것에 유의하자)</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> d1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2017</span>, <span class="hljs-number">2</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">30</span>);
d1.getTime(); <span class="hljs-comment">// 1489199400000</span>
</code></pre>
<p>ISO-8601 형식의 문자열은 어떨까? 앞서 말했듯이 ECMAScript 5판 이상을 지원하는 IE9 이상의 브라우저는 ISO-8601 형식을 지원하며, <code>toISOString()</code> 나 <code>toJSON()</code> 메소드를 이용하면 ISO-8601 형식의 문자열을 생성할 수 있다. (<code>toJSON()</code> 은 <code>JSON.stringify()</code>등에서 재귀적으로 호출될 때도 사용될 수 있다) 두 메소드의 결과값은 동일한데, 다만 다음과 같이 유효하지 않은 데이터에 대한 처리만 조금 다르다.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> d1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2017</span>, <span class="hljs-number">2</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">30</span>);
d1.toISOString(); <span class="hljs-comment">// "2017-03-11T02:30:00.000Z"</span>
d1.toJSON();      <span class="hljs-comment">// "2017-03-11T02:30:00.000Z"</span>

<span class="hljs-keyword">var</span> d2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">'Hello'</span>);
d2.toISOString(); <span class="hljs-comment">// Error: Invalid Date</span>
d2.toJSON();      <span class="hljs-comment">// null</span>
</code></pre>
<p>이 외에도 UTC 기준의 문자열을 생성할 수 있는 <code>toGMTString()</code>과 <code>toUTCString()</code> 메소드가 있는데, 이들은 <a href="https://tools.ietf.org/html/rfc1123" target="_blank" rel="noopener">RFC-1123</a> 표준에 맞는 문자열을 반환하므로 필요에 따라 사용할 수 있을 것이다.</p>
<p>Date 객체에는 <code>toString()</code>, <code>toLocaleString()</code> 및 이들의 확장 메소드들이 더 있지만, 주로 로컬 타임존 기준의 문자열을 반환하는 목적으로 사용되고, 특히 브라우저나 OS 환경에 따라 같은 결과가 보장되지 않기 때문에 사실상 별로 유용하지 않다.</p>
<h2>로컬 타임존 변경하기</h2>
<p>지금까지 살펴본 바에 의하면 자바스크립트에서도 어느정도 타임존 지원이 이뤄지고 있는 것 같다. 하지만 만약, OS의 타임존 설정을 따르지 않고, 어플리케이션 내에서 로컬 타임존을 직접 변경하고 싶다면 어떻게 해야 할까? 아니면, 다양한 타임존에서의 시간을 하나의 어플리케이션에서 동시에 보여주어야 한다면? 여러 번 말했듯이, 자바스크립트에서는 로컬의 타임존을 직접 변경할 수 없다. 유일하게 할 수 있는 방법은 원하는 타임존의 오프셋 값을 알고 있는 경우, 오프셋값을 더하거나 빼서 직접 날짜를 계산하는 것이다. 안된다고 무작정 포기하지 말고, 일단 자바스크립트가 할 수 있는 최선의 방법에 대해 살펴보자.</p>
<p>먼저, 앞선 예시에서 처럼 현재 브라우저의 타임존 설정이 서울이라고 가정하자. 사용자는 서울 기준의 2017년 3월 11일 오전 11시 30분 데이터를 뉴욕의 타임존 기준으로 볼 수 있기를 원한다. 그리고 서버에서는 해당 데이터를 밀리초 단위의 유닉스 시간으로 전송해 주면서, (친절하게도) 뉴욕의 오프셋이 -05:00 이라는 것도 알려주었다. 자, 그럼 현재 로컬 타임존의 오프셋만 알면 데이터를 변환할 수 있을 것이다.</p>
<p>이 때 사용할 수 있는 메소드가 바로 <code>getTimeZoneOffset()</code> 메소드이다. 이 메소드는 자바스크립트에서 로컬 타임존 정보를 알 수 있는 유일한 API라고 할 수 있는데, 현재 타임존의 오프셋을 분 단위의 숫자로 반환한다.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> seoul = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1489199400000</span>);
seoul.getTimeZoneOffset(); <span class="hljs-comment">// -540</span>
</code></pre>
<p>반환값 <code>-540</code> 은 타임존이 540분 앞서 있다는 의미이다. 서울의 오프셋이 +09:00 이란 걸 생각해보면 부호가 반대로 되어 있는 걸 알 수 있는데, 왜 그런지 모르겠지만 암튼 주의해야 한다. 이 방식을 기준으로 뉴욕의 오프셋 -05:00 을 계산해 보면 <code>60 * 5 = 300</code> 이 될 것이다. 이 <code>840</code> 만큼의 차이를 밀리초로 단위로 보정해서 새로운 Date 객체를 만들면, 그 객체의 <code>getXX</code> 메소드들을 이용해서 원하는 형태의 데이터를 만들어낼 수 있을 것이다. 간단한 포매터 함수를 만들어 결과를 비교해 보자.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatDate</span>(<span class="hljs-params">date</span>) </span>{
  <span class="hljs-keyword">return</span> date.getFullYear() + <span class="hljs-string">'년 '</span> + 
    (date.getMonth() + <span class="hljs-number">1</span>) + <span class="hljs-string">'월 '</span> + 
    date.getDate() + <span class="hljs-string">'일 '</span> + 
    date.getHours() + <span class="hljs-string">'시 '</span> + 
    date.getMinutes() + <span class="hljs-string">'분'</span>;
}

<span class="hljs-keyword">var</span> seoul = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1489199400000</span>);
<span class="hljs-keyword">var</span> ny = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1489199400000</span> - (<span class="hljs-number">840</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>));

formatDate(seoul);  <span class="hljs-comment">// 2017년 3월 11일 11시 30분</span>
formatDate(ny);     <span class="hljs-comment">// 2017년 3월 10일 21시 30분</span>
</code></pre>
<p><code>formatDate()</code> 의 결과에서 서울과 뉴욕의 시간대에 맞게 날짜가 잘 표시되고 있는 걸 볼 수 있다. 의외로 간단하게 해결된 것 같다. 자, 그러면 해당 지역의 오프셋만 알고 있다면 로컬 타임존을 변경할 수 있다는 것일까? 아쉽게도 답은 ‘아니오’다. 1부에서 타임존이 단순히 오프셋이 아니라 모든 오프셋 변경의 히스토리를 담고 있는 일종의 데이터베이스라고 했던 것이 기억나는가? 정확한 타임존 계산을 위해서는 단순히 현재 시점의 오프셋이 아닌, 해당 날짜가 가르키는 시점의 오프셋을 알아야 한다.</p>
<h2>로컬 타임존 변경의 문제</h2>
<p>위의 예제를 조금만 더 발전시키면 쉽게 문제를 발견할 수 있을 것이다. 사용자가 뉴욕의 시간대에서 해당 시간을 확인한 후에 날짜를 11일에서 15일로 변경하려고 한다. Date 객체의 <code>setDate()</code> 메소드를 이용하면 다른 항목들은 유지한 채로 날짜 값만 변경할 수 있다.</p>
<pre><code class="lang-js">ny.setDate(<span class="hljs-number">15</span>);
formatDate(ny);    <span class="hljs-comment">// 2017년 3월 15일 21시 30분</span>
</code></pre>
<p>간단히 해결되는 것 처럼 보이지만, 여기에는 함정이 있다. 먼저, 이 데이터를 다시 서버로 전송해야 한다면 어떻게 해야 할까? 우리는 데이터 자체를 변경했기 때문에, <code>getTime()</code> 이나 <code>getISOString()</code> 등의 메소드를 사용할 수 없다. 그러므로 서버로 전송하기 위해서는 앞에서 했던 계산을 역으로 해서 원래 데이터를 연산해야만 한다.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> time = ny.getTime() + (<span class="hljs-number">840</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>);  <span class="hljs-comment">// 1489631400000</span>
</code></pre>
<blockquote><p>어차피 반환할 때 역으로 계산해야 하는데, 왜 굳이 변환된 데이터에서 날짜를 더하는지 궁금한 사람들이 있을 것이다. 그냥 기존 데이터에 연산을 하고, 포맷팅을 할 때만 임시로 변환된 Date 객체를 생성해도 될 것 같다. 하지만, 만약 서울기준의 Date 객체에서 날짜로 15로 변경했다면 11일에서 15일이 되었으므로 4일 <code>(24 *  4 * 60 * 60 * 1000)</code>이 추가된 것이고, 뉴욕 기준에서는 10일에서 15일이 되었으므로 5일 <code>(24* 5 * 60 * 60 * 1000)</code>이 추가된 것이다. 즉, 날짜 연산을 할 때에도 해당 오프셋을 기준으로 진행해야만 정확한 연산이 가능하다.</p></blockquote>
<p>하지만 더 중요한 문제는, 단순히 오프셋을 더하고 빼는 것만으로는 해결되지 않는 문제가 있다는 것이다. 뉴욕의 타임존은 3월 12일부터 서머타임(DST)이 적용되기 때문에 2017년 3월 15일은 오프셋이 -05:00 이 아닌 -04:00 이 되어야 한다. 즉 역으로 연산할 때에는 현재보다 60분이 적은 780분 만큼만 더해주어야 하는 것이다.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> time = ny.getTime() + (<span class="hljs-number">780</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>);  <span class="hljs-comment">// 1489627800000</span>
</code></pre>
<blockquote><p>반대로 사용자의 로컬 타임존이 뉴욕일 때 서울의 타임존 기준으로 날짜 연산을 하려고 하면, 불필요하게 서머타임이 적용되어 계산이 잘못되는 문제가 발생할 것이다.</p></blockquote>
<p>결론적으로 단순히 전달받은 오프셋 값만 가지고는 원하는 타임존 기준으로 날짜 연산을 할 수가 없다. 뿐만 아니라, 1부의 내용을 다시 기억해보면 서머타임이 적용되는 규칙까지 안다고 해도 여전히 허점이 있다는 것을 알 것이다. 즉, 정확한 날짜 연산을 위해서는 <a href="https://www.iana.org/time-zones" target="_blank" rel="noopener">IANA timezone Database</a>와 같이 타임존 변경 히스토리가 담긴 전체 데이터가 필요한 것이다.</p>
<p>해결을 위해서는 전체 타임존 데이터베이스를 저장하고 있다가, Date 객체에서 날짜나 시간 데이터를 가져올 때마다 데이터베이스에서 해당 날짜와 타임존에 맞는 오프셋을 알아낸 다음, 위와 같은 연산을 통해 결과를 반환해야 할 것이다. 물론 이론적으로 가능은 하겠지만, 이를 위해서는 너무 많은 노력이 필요하고, 실제 변환된 데이터가 정확한지 테스트를 하기도 쉽지가 않을 것이다. 하지만, 너무 낙심은 말자. 이제 우리는 자바스크립트 타임존에 어떤 문제가 있는지, 그리고 어떻게 해결할 수 있는지를 알았다. 이제, 잘 만들어진 라이브러리를 찾아서 사용해도 되는 자격을 갖춘 것이다.</p>
<h2>Moment Timezone</h2>
<p><a href="https://momentjs.com/" target="_blank" rel="noopener">Moment</a>는 자바스크립트에서 날짜 연산을 할 때 거의 표준처럼 자리잡은 라이브러리이다. 다양한 날짜 연산 및 포맷팅 API를 제공하며, 최근 많은 사용자들에 의해 널리 사용되면서 안정성도 검증받았다고 할 수 있다. 또한 <a href="https://momentjs.com/timezone/" target="_blank" rel="noopener">Moment Timezone</a> 이라는 확장 모듈을 이용하면 위에서 말한 문제들을 간단하게 해결할 수 있다. 이 확장 모듈은 실제 IANA timezone Database 의 데이터를 내장하여 실제 오프셋을 정확히 계산해주며, 타임존을 변경하고 포맷팅 할 수 있는 다양한 API를 제공한다.</p>
<blockquote><p>이 글에서는 라이브러리의 사용법이나 구조에 대해 깊이 다루지는 않을 것이다. 다만, 위에서 우리가 발견했던 문제들을 얼마나 간단하게 해결할 수 있는지만 살펴보도록 하겠다. 관심 있는 분들은 해당 <a href="https://momentjs.com/timezone/docs/" target="_blank" rel="noopener">Moment Timezone의 문서</a>를 참고하길 바란다.</p></blockquote>
<p>자, 그럼 위의 문제를 Moment Timezone 을 이용해서 해결해 보자.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> seoul = moment(<span class="hljs-number">1489199400000</span>).tz(<span class="hljs-string">'Asia/Seoul'</span>);
<span class="hljs-keyword">var</span> ny = moment(<span class="hljs-number">1489199400000</span>).tz(<span class="hljs-string">'America/New_York'</span>);

seoul.format(); <span class="hljs-comment">// 2017-03-11T11:30:00+09:00</span>
ny.format();    <span class="hljs-comment">// 2017-03-10T21:30:00-05:00</span>

seoul.date(<span class="hljs-number">15</span>).format();  <span class="hljs-comment">// 2017-03-15T11:30:00+09:00</span>
ny.date(<span class="hljs-number">15</span>).format();     <span class="hljs-comment">// 2017-03-15T21:30:00-04:00</span>
</code></pre>
<p>결과를 보면, <code>seoul</code>의 오프셋은 그대로인 반면에, <code>ny</code>의 오프셋은 -05:00 에서 -04:00 으로 변경된 것을 볼 수 있다. 또한, <code>format()</code> 함수를 이용하면 해당 오프셋이 정확히 반영된 ISO-8601 문자열을 얻을 수 있다. 앞의 절에서 들였던 노력에 비해 얼마나 간단한지 한눈에 체감이 될 것이다.</p>
<h2>결론</h2>
<p>지금까지 자바스크립트에서 지원하는 타임존 관련 API들과, 관련된 문제점들을 살펴보았다. 로컬 타임존을 직접 변경할 필요가 없다면, IE9 이상의 브라우저에 한해서 기본 API 만으로도 필요한 기능들을 구현할 수 있을 것이다. 하지만, 로컬 타임존을 직접 변경해야 한다면 문제는 복잡해진다. 서머 타임이 없고, 타임존 정책에 변경이 거의 없는 지역에 대해서는 위에서 설명한 것 처럼 <code>getTimezoneOffset()</code> 을 활용한 데이터 변환으로 불완전하게나마 구현이 가능하다. 하지만, 다양한 지역에 대한 타임존을 제대로 지원하고 싶다면, 직접 구현하려는 욕심을 버리고 Moment Timezone과 같은 라이브러리를 활용하는 것이 나을 것이다.</p>
<p>사실 1부의 서두에서도 밝혔듯이, 이 글은 타임존을 제대로 구현해 보겠다는 노력의 실패담으로 시작되었고, 예정된 결론은 “라이브러리를 사용하라” 였다. 하지만, 글을 쓰다보니 처음 예정했던 결론과는 조금 다르게 글을 마치게 되는 것 같다. 결론적으로, 실제 자바스크립트에서 타임존 관련 기능을 얼마나 지원하는지와 어떤 문제점이 있는지를 모른 채 무작정 외부 라이브러리에 의존하는 것은 결코 바람직한 접근이 아니라고 생각한다. 항상 그렇듯이, 각자의 상황에 맞게 적절한 도구를 선택하는 것이 중요하다. 이 글이 그런 판단을 내리는 데에 조금이나마 도움이 되었기를 바란다.</p>
<h2>참고 링크</h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noopener">MDN : Date API</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Date.html" target="_blank" rel="noopener">java.util.Date API</a></li>
<li><a href="https://momentjs.com/timezone/" target="_blank" rel="noopener">Moment Timezone</a></li>
<li><a href="https://en.wikipedia.org/wiki/Unix_time" target="_blank" rel="noopener">Unix Time</a></li>
<li><a href="https://tools.ietf.org/html/rfc1123" target="_blank" rel="noopener">RFC-1123</a></li>
<li><a href="https://tools.ietf.org/html/rfc2822#section-3.3" target="_blank" rel="noopener">RFC2888</a></li>
<li><a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener">ISO-8601</a></li>
<li><a href="https://www.iana.org/time-zones" target="_blank" rel="noopener">IANA timezone Database</a></li>
</ul>
]]></content:encoded>
							<wfw:commentRss>https://dongwoo.blog/2017/10/22/%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8%ec%97%90%ec%84%9c-%ed%83%80%ec%9e%84%ec%a1%b4-%eb%8b%a4%eb%a3%a8%ea%b8%b0-2/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/530c8460562d2041af30cba4cf26b3d0?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">gaekkr</media:title>
		</media:content>
	</item>
		<item>
		<title>자바스크립트에서 타임존 다루기 (1)</title>
		<link>https://dongwoo.blog/2017/10/22/%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8%ec%97%90%ec%84%9c-%ed%83%80%ec%9e%84%ec%a1%b4-%eb%8b%a4%eb%a3%a8%ea%b8%b0-1/</link>
				<comments>https://dongwoo.blog/2017/10/22/%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8%ec%97%90%ec%84%9c-%ed%83%80%ec%9e%84%ec%a1%b4-%eb%8b%a4%eb%a3%a8%ea%b8%b0-1/#respond</comments>
				<pubDate>Sat, 21 Oct 2017 15:06:09 +0000</pubDate>
		<dc:creator><![CDATA[동우]]></dc:creator>
				<category><![CDATA[자바스크립트]]></category>
		<category><![CDATA[타임존]]></category>

		<guid isPermaLink="false">http://dongwoo.blog/?p=489</guid>
				<description><![CDATA[최근 나는 팀에서 관리하는 자바스크립트 캘린더 라이브러리에 타임존 기능을 추가하는 작업을 한 적이 있다. 자바스크립트의 타임존 지원이 다른 언어에 비해 부실하다는 얘기는 이미 들어 알고 있었지만, 기존 Date 객체를 잘 추상화하면 어렵지 않게 구현할 수 있을거라 생각했다.

하지만 작업을 진행할수록 자바스크립트에서 타임존을 다루는 것이 결코 쉬운 일이 아니란 것을 깨달았다. 특히 단순히 시간 정보를 포맷팅하는 정도가 아니라, 캘린더처럼 시간 정보에 대한 복잡한 연산이 더해지게 되면 타임존은 더욱 더 골칫덩어리가 된다. 덕분에 오랜만에 문제를 해결할 때마다 새로운 문제가 쏙 쏙 생겨나는 심장 쫄깃한 경험을 할 수 있었다.]]></description>
								<content:encoded><![CDATA[<p><em>이 글은 NHNEnt 의 기술블로그인 <a href="http://meetup.toast.com">토스트 밋업</a>에 총 2부로 연재된 &#8216;자바스크립트에서 타임존 다루기&#8217;의 첫번째 글이다. 원문은 <a href="http://meetup.toast.com/posts/125">http://meetup.toast.com/posts/125</a> 에서 확인할 수 있다.</em></p>
<ul>
<li><em>다음 글 : 자바스크립트에서 타임존 다루기 (2)</em></li>
</ul>
<p>&nbsp;</p>
<p>최근 나는 팀에서 관리하는 자바스크립트 캘린더 라이브러리에 타임존 기능을 추가하는 작업을 한 적이 있다. 자바스크립트의 타임존 지원이 다른 언어에 비해 부실하다는 얘기는 이미 들어 알고 있었지만, 기존 Date 객체를 잘 추상화하면 어렵지 않게 구현할 수 있을거라 생각했다.</p>
<p>하지만 작업을 진행할수록 자바스크립트에서 타임존을 다루는 것이 결코 쉬운 일이 아니란 것을 깨달았다. 특히 단순히 시간 정보를 포맷팅하는 정도가 아니라, 캘린더처럼 시간 정보에 대한 복잡한 연산이 더해지게 되면 타임존은 더욱 더 골칫덩어리가 된다. 덕분에 오랜만에 문제를 해결할 때마다 새로운 문제가 쏙 쏙 생겨나는 심장 쫄깃한 경험을 할 수 있었다.</p>
<p>이 글은 이러한 개인적인 경험을 바탕으로 자바스크립트에서 타임존을 다룰 때의 문제와 해결방법을 정리해 볼 예정이다. 글을 쓰면서 (왜 글이 점점 길어질까 고민하다가)알게 된 사실인데, 이 고난의 가장 큰 원인은 타임존이라는 도메인에 대한 이해가 부족했기 때문이라고 생각한다. 그래서 글을 1, 2부로 나누어 1부에서는 타임존과 관련 표준에 대해 자세히 알아보고 2부에서 본격적으로 자바스크립트와 관련된 내용을 풀어보도록 하겠다.</p>
<h2>타임존이란?</h2>
<p>타임존은 동일한 로컬 시간을 따르는 지역을 의미하며, 주로 해당 국가에 의해 법적으로 지정된다. 보통 국가별로 각자의 고유한 타임존을 사용하고 있으며, 미국이나 캐나다처럼 면적이 넓은 나라인 경우 지역별로 각기 다른 타임존을 사용하기도 한다. (반면 중국은 그 넓은 면적에도 불구하고 하나의 타임존을 이용하고 있는데, 이로 인해 중국 서쪽 지역에서는 오전 10시는 되어야 해를 볼 수 있다)</p>
<h2>GMT, UTC 그리고 오프셋(Offset)</h2>
<h3>GMT</h3>
<p>한국의 타임존은 보통 GMT+09:00 으로 표현된다. 여기서 GMT는 Greenwich Mean Time의 약자로서 경도 0도에 위치한 영국 그리니치 천문대를 기준으로 하는 태양 시간을 의미한다. GMT 시간은 1925년 2월 5일부터 사용하기 시작하였으며, 1972년 1월 1일까지 세계 표준시로 사용되었다.</p>
<h3>UTC</h3>
<p>GMT는 또한 UTC라고도 불리는데, 두 용어가 혼용되어서 사용되고 있기는 하지만 엄밀히 구분하자면 둘은 다른 의미를 가진다. UTC는 지구 자전주기의 흐름이 늦어지고 있는 문제를 해결하기 위해 1972년에 세슘 원자의 진동수에 기반한 국제 원자시를 기준으로 다시 지정된 시간대이다. 즉, UTC는 좀더 정확한 시간측정을 위해서 GMT를 대체하기 위해 제정된 새로운 표준이며, 시간적으로는 둘 사이에 아주 미세한 차이밖에 없지만, 소프트웨어에서 사용할 때는 UTC라고 하는 것이 더 정확한 표현일 것이다.</p>
<blockquote><p>UTC라는 약자가 탄생한 배경은 좀 재미있는데, 처음에 영어권에서는 CUT(Coordinated Universal Time)를, 프랑스어권에서는 TUC(Temps Universel Coordonn)를 사용하기를 원했다고 한다. 하지만 결국 한쪽이 이기지는 못하고, 두 언어 모두 C, T, U로 되어 있으니 중재안으로 UTC가 채택되었다고 한다.</p></blockquote>
<h3>오프셋</h3>
<p>UTC+09:00 에서 +09:00 의 의미는 UTC의 기준시간보다 9시간이 빠르다는 의미이다. 즉 UTC 기준으로 현재 낮 12시라면 한국시간으로는 오후 9시가 될 것이다. 이렇게 UTC와의 차이를 나타낸 것을 오프셋이라고 하며, +09:00 혹은 -03:00 등과 같이 표현된다.</p>
<p>보통 국가나 지역들마다 자신들이 사용하는 타임존에 대해 고유의 이름을 부여한다. 예를 들어 대한민국의 타임존은 KST(Korea Standard Time)이라고도 불리는데, 이는 앞서 설명했듯이 특정 오프셋을 지칭하므로 KST = UTC+09:00 이라고 이해하면 된다. 하지만 +09:00 오프셋은 한국 뿐만 아니라 일본, 인도네시아 등 여러 지역에서 사용하고 있으므로, 오프셋과 타임존 이름들의 관계는 1:1 관계가 아닌 1:N 관계이다. +09:00를 사용하는 국가 혹은 지역의 목록은 <a href="https://en.wikipedia.org/wiki/UTC%2B09:00" target="_blank" rel="noopener">UTC+09:00</a>에서 확인할 수 있다.</p>
<p>오프셋은 한시간 단위가 아닌 경우도 있다. 예를 들어 북한은 +08:30을 기준시로 사용하고 있고, 호주의 경우 지역에 따라 +08:45, 혹은 +09:30을 기준시로 이용하고 있다.</p>
<blockquote><p>전체 UTC 오프셋 및 이들 이름의 목록은 <a href="https://en.wikipedia.org/wiki/List_of_UTC_time_offsets" target="_blank" rel="noopener">List of UTC Time offsets</a>에서 확인할 수 있다.</p></blockquote>
<h2>타임존 !== 오프셋?</h2>
<p>앞서 말했듯이 우리가 타임존을 말할 때는 보통 KST, JST(Japan Standard Time) 등과 같이 오프셋과 동일한 의미로 쓰인다. 하지만, 특정 지역의 타임존을 단순히 오프셋이라고 지칭하기는 어려운데, 이는 아래의 두 가지 이유 때문이다.</p>
<h3>서머 타임 (DST)</h3>
<p>국내에서는 여전히 생소한 개념이지만, 해외 여러 국가에서는 서머 타임(summer time)이 존재한다. 사실 서머 타임은 주로 영국에나 유럽에서 쓰이는 용어인데, 좀더 범용적인 용어로는 일광 시간 절약제, 즉 DST(Daylight Saving Time)라고 불린다. 이는 하절기에 표준시를 원래 시간보다 한 시간 앞당긴 시간으로 이용하는 것을 의미한다.</p>
<blockquote><p><a href="https://ko.wikipedia.org/wiki/%ED%95%9C%EA%B5%AD_%ED%91%9C%EC%A4%80%EC%8B%9C" target="_blank" rel="noopener">위키피디아</a>에 따르면 국내에서도 1948 ~ 1951, 1955 ~ 1960, 1987 ~ 1988년에 DST가 시행된 적이 있다고 한다.</p></blockquote>
<p>예를 들어 미국의 캘리포니아 지역은 평소에는 PST(Pacific Standard Time)을 기준시로 이용하고, 하절기에는 PDT(Pacific Daylight Time, UTC-07:00)를 기준시로 이용한다. 두 시간대를 사용하는 타임존을 묶어서 Pacific Time(PT)라고 부르기도 하며, 미국의 여러 지역 및 캐나다 일부 지역에서도 사용하고 있다.</p>
<p>그러면 이 DST가 적용되는 하절기는 정확히 언제를 의미하는걸까? 사실 DST 적용에는 보편적인 규칙이 있는 것이 아니고, 국가나 지역의 법에 따라서 다르게 적용된다. 예를 들어 미국과 캐나다는 2006년까지 각 지역시간 기준으로 4월의 첫 일요일 오전 2시에 시작하여 10월의 마지막 일요일 오전 12시에 해제하였지만, 2007년부터는 3월의 두 번째 일요일 오전 2시에 시작하여 11월 첫 일요일 2시에 해제하도록 변경되었다. 그리고 유럽에서는 DST가 일괄적으로 적용되는 반면, 미국에서는 각 지역의 시간대별로 순차적으로 적용된다.</p>
<h3>타임존은 변한다?</h3>
<p>앞에서도 잠깐 언급했었지만, 각 지역이 어떤 타임존을 이용할 지는 해당 지역 혹은 국가가 법적으로 결정하기 때문에, 정치적 혹은 경제적 이유로 변경될 수 있다. 예를 들어, 미국에서 2007년부터 DST의 적용시점이 변경된 것은 미국 2005년에 조지 부시 대통령이 서명한 에너지 정책법에 의해서였다. 또한 이집트나 러시아는 기존에 DST를 이용했었지만, 2011년부터 DST를 이용하지 않기로 결정했다.</p>
<p>DST 뿐만 아니라 국가의 표준시가 변경되기도 하는데, 예를 들어 사모아 섬의 경우 원래 UTC-10:00 의 오프셋을 기준시로 사용했었지만, 2011년에 오스트레일리아, 뉴질랜드와의 무역에서 날짜 차이에 따른 손실을 줄이기 위해 UTC+14:00 로 변경하면서 하루를 앞당겼고, 이로 인해 2011년 12월 30일이 사라지게 되면서 크게 뉴스가 되기도 했었다. (<a href="http://news.sbs.co.kr/news/endPage.do?news_id=N1001057775" target="_blank" rel="noopener">뉴스 링크</a>)</p>
<p>네덜란드의 경우에는 1909년부터 +0:19:32.13 이라는 필요 이상으로 정확한 오프셋을 사용하고 있었는데, 1937년부터 +00:20 으로 변경했다가, 1940년부터는 +01:00 을 기준시로 사용하고 있다.</p>
<h2>타임존 1 : 오프셋 N</h2>
<p>위에서 살펴본 내용을 정리해보자면, 한 지역의 타임존은 하나 혹은 그 이상의 오프셋을 가지며, 어느 시점에 어떤 오프셋을 기준시로 이용할지는 해당 지역의 정치/경제적 상황에 따라 계속해서 달라진다고 할 수 있다.</p>
<p>일상 생활에서는 이런 상황이 큰 문제가 없을지도 모르지만, 이를 규칙에 따라 시스템화 시키려고 하면 문제가 발생한다. 내 스마트폰의 기준시를 오프셋을 이용해서 지정한다고 생각해보자. 만약 내가 DST가 적용되는 지역에 살고 있다면 스마트폰의 기준시를 DST가 적용되고 해제될 때마다 변경해 주어야 할 것이다. 이런 경우 위에서 언급했던 Pacific Time 처럼 표준시와 DST를 묶어서 하나의 타임존으로 인식할 수 있는 또 다른 개념이 필요할 것이다.</p>
<p>하지만, 이를 단순히 몇가지 규칙으로 지정하기는 어렵다. 예를 들어 미국의 경우 2007년을 기준으로 DST 를 적용하는 시점이 변경되었기 때문에, 2006년 3월 31일은 PDT(-07:00)가 기준시가 되지만, 2007년 3월 31일은 PST(-08:00)가 기준시가 되어야 할 것이다. 즉, 특정 지역의 타임존을 지칭하기 위해서는 역사적으로 표준시간대 혹은 DST 적용 룰이 언제 변경되었는지에 대한 데이터를 모두 갖고 있어야만 정확한 시간을 계산할 수 있는 것이다.<br />
즉, 우리는 &#8220;뉴욕의 타임존은 PST(-08:00)야&#8221; 라고 말할 수 없다. 약간 더 정확히 말하자면 &#8220;뉴욕의 타임존은 <strong>현재</strong> PST야&#8221; 라고 할 수 있을 것이다. 하지만 시스템의 관점에서 더 엄밀하게 말하자면 타임존이라는 단어 없이 &#8220;뉴욕은 현재 PST를 기준시로 사용하고 있어&#8221; 라고 말하는 것이 가장 정확할 것이다.</p>
<p>그러면 우리는 특정 지역의 타임존을 오프셋이 아닌 무엇으로 지칭해야 할까? 바로 지역명이다. 정확히 이야기하면 <strong>역사적으로 표준시간대나 DST의 변경이 동일하게 적용되었던 지역</strong>을 하나의 타임존으로 묶어서 지칭할 수 있을 것이다. 앞서 잠깐 언급했던 PT(Pacific Time)과 같은 명칭이 이용될 수도 있겠지만, 이는 현재의 표준시와 DST만을 묶어놓은 개념이기 때문에 역사적인 변경내역을 모두 포함한다고 할 수는 없을 것이다. 또한 PT는 미국/캐나다 지역에서만 사용되는 이름이기 때문에, 소프트웨어에서 범용적으로 사용하기 위해서는 신뢰할 수 있는 기관에서 관리되는 표준이 필요하게 된다.</p>
<h2>IANA time zone database</h2>
<p>사실 타임존에 대한 표준은 단순히 규칙이기 보다는 데이터베이스에 가까운데, 역사적인 변경 내역을 모두 저장하고 있어야 하기 때문이다. 이러한 표준 데이터베이스는 여럿이 있지만, 현재로서 가장 신뢰할 수 있는 표준은 바로 <a href="https://www.iana.org/time-zones" target="_blank" rel="noopener">IANA time zone database</a> 이다. IANA time zone database는 보통 tz database (혹은 tzdata) 라고 불리며, 전 세계 모든 지역의 표준시와 DST 변경 내역을 담고 있다. 현재 역사적으로 확인할 수 있는 모든 데이터가 들어있다고 볼 수 있는데, UNIX 시간(1970.01.01 00:00:00) 이후의 데이터의 정확도를 보장하도록 정리되었다. (즉, 1970년 이전의 데이터도 있지만 이 시기의 데이터는 완벽한 정확성을 보장하지는 않는다)</p>
<p>이름은 Area / Location 의 규칙을 이용하는데, Area 는 보통 대륙이나 대양명 (Asia, America, Pacific 등)을 지정하며, Location 은 주로 국가명보다는 큰 도시 위주 (Seoul, New_York 등)로 지정된다. (도시명이 국가명보다는 더 영구적인데, 국가의 수명은 생각보다 짧다)<br />
예를 들어 대한민국의 타임존은 Asia/Seoul 이고, 일본의 경우 Asia/Tokyo 인데, 현재 두 지역 모두 UTC+09:00을 표준시로 사용하고 있지만, 실제 역사적인 변경 내역이 다르고 현재 다른 국가에 속해있기에, 별도의 타임존으로 관리되는 것이다.</p>
<p>IANA time zone database는 많은 개발자들과 역사학자들의 커뮤니티들에 의해 관리되고 있으며, 역사적 발견이 추가되거나 정부 정책이 바뀌는 경우 바로 갱신되기 때문에 신뢰도가 가장 높다. 또한 리눅스, macOS등 유닉스 기반의 OS들이나 자바, PHP 등 유명 프로그래밍 언어들 등 이미 많은 시스템에서 이 데이터베이스를 내부적으로 사용하고 있다.</p>
<blockquote><p>위의 지원 환경 목록에 Windows가 없는 것을 눈치챈 사람이 있을 것이다. 사실, Windows는 별도의 데이터베이스를 내장하고 있는데, 이를 <a href="https://support.microsoft.com/en-us/help/22803/daylight-saving-time" target="_blank" rel="noopener">Microsoft Time Zone Database</a>라 부른다. 하지만 여기에는 역사적인 변경 내역들이 누락된 부분이 많고, Microsoft라는 회사에 의해서만 관리되기 때문에, 정확도나 신뢰도 면에서 IANA에 비해 떨어진다고 볼 수 있다.</p></blockquote>
<h3>자바스크립트와 IANA time zone database</h3>
<p>서두에서 잠깐 언급했지만, 자바스크립트는 사실 타임존 지원이 미약한 편이다. 기본적으로는 현재 지역의 (좀더 정확히 이야기하자면 설치된 OS에 설정된 타임존)을 따르게 되어 있기 때문에, 명시적으로 타임존을 변경할 수 있는 방법이 없다. 뿐만 아니라 데이터베이스 표준에 대한 명세도 명확하지 않은데, 실제 ES2015의 스펙을 살펴보면 로컬 타임존과 DST의 적용에 대해 두세 줄 정도의 모호한 정의만 되어 있을 뿐이다. 예를 들면 DST의 경우 다음과 같이 정의되어 있다. <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-daylight-saving-time-adjustment" target="_blank" rel="noopener">링크 : ECMAScript 2015 &#8211; Daylight Saving Time Adjustment</a></p>
<blockquote><p>An implementation dependent algorithm using best available information on time zones to determine the local daylight saving time adjustment DaylightSavingTA(t), measured in milliseconds. An implementation of ECMAScript is expected to make its best effort to determine the local daylight saving time adjustment.</p></blockquote>
<p>뭔가… 그냥 최선을 다해서 정확히 구현하라는 의미로만 보인다 (-_-). 즉, 구현하는 브라우저 벤더마다 구현이 달라질 수도 있다는 의미이다. 이런 무책임한! 이라는 생각이 들 때쯤 바로 밑에 NOTE 한 줄이 추가되어 있는 것이 눈에 보인다.</p>
<blockquote><p>NOTE : It is recommended that implementations use the time zone information of the IANA Time Zone Database <a href="http://www.iana.org/time-zones/" target="_blank" rel="noopener">http://www.iana.org/time-zones/</a>.</p></blockquote>
<p>그렇다. ECMA 스펙은 이 한 줄로 책임을 살짝 피해가려 했겠지만, 결론적으로 자바스크립트에서는 사실상 명시된 표준 데이터베이스가 없고, 단지 IANA Time Zone Database가 권장될 뿐이다. 당연한 이야기지만 이로 인해 실제로 브라우저마다 타임존 연산이 다르게 동작하는 경우도 있다. 나중에 국제화 API를 위한 ECMA-402 스펙의 <code>Intl.DateTimeFormat</code>에서 IANA timezone을 사용하는 옵션이 추가되긴 했지만, 여전히 다른 언어에 비해서는 신뢰할만한 타임존 지원이 많이 부족하다고 볼 수 있다.</p>
<h2>1부를 정리하며</h2>
<p>지금까지 살펴본 것처럼, 타임존은 생각보다 복잡한 개념이며 이를 정확하게 계산하기 위해서는 단순한 연산 뿐만 아니라 표준화된 데이터베이스가 필요하다. 이러한 작업을 언어 차원의 지원 없이 직접 구현하기는 쉽지 않은데, 안타깝게도 자바스크립트는 이러한 지원이 상당히 적은 편이다. 2부에서는 실제 자바스크립트에서 타임존을 다룰 때 발생하는 문제와 이를 어떻게 해결할 수 있을지를 알아보도록 하겠다.</p>
<h2>참고 링크</h2>
<ul>
<li>Wikipedia &#8211; timezone : <a href="https://en.wikipedia.org/wiki/Time_zone" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Time_zone</a></li>
<li>Wikipedia &#8211; DST : <a href="https://en.wikipedia.org/wiki/Daylight_saving_time" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Daylight_saving_time</a></li>
<li>위키피디아 &#8211; 한국 표준시 : <a href="https://ko.wikipedia.org/wiki/%ED%95%9C%EA%B5%AD_%ED%91%9C%EC%A4%80%EC%8B%9C" target="_blank" rel="noopener">https://ko.wikipedia.org/wiki/한국_표준시</a></li>
<li>IANA time zone &#8211; <a href="http://www.iana.org/time-zones/" target="_blank" rel="noopener">http://www.iana.org/time-zones/</a></li>
<li>MS DST 블로그 : <a href="https://blogs.technet.microsoft.com/dst2007" target="_blank" rel="noopener">https://blogs.technet.microsoft.com/dst2007</a></li>
</ul>
]]></content:encoded>
							<wfw:commentRss>https://dongwoo.blog/2017/10/22/%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8%ec%97%90%ec%84%9c-%ed%83%80%ec%9e%84%ec%a1%b4-%eb%8b%a4%eb%a3%a8%ea%b8%b0-1/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/530c8460562d2041af30cba4cf26b3d0?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">gaekkr</media:title>
		</media:content>
	</item>
		<item>
		<title>[번역] 웹어셈블리의 현재 위치와 미래</title>
		<link>https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%ec%9d%98-%ed%98%84%ec%9e%ac-%ec%9c%84%ec%b9%98%ec%99%80-%eb%af%b8%eb%9e%98/</link>
				<comments>https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%ec%9d%98-%ed%98%84%ec%9e%ac-%ec%9c%84%ec%b9%98%ec%99%80-%eb%af%b8%eb%9e%98/#comments</comments>
				<pubDate>Tue, 06 Jun 2017 11:55:42 +0000</pubDate>
		<dc:creator><![CDATA[동우]]></dc:creator>
				<category><![CDATA[자바스크립트]]></category>
		<category><![CDATA[번역]]></category>
		<category><![CDATA[브라우저]]></category>
		<category><![CDATA[웹]]></category>
		<category><![CDATA[웹어셈블리]]></category>

		<guid isPermaLink="false">http://dongwoo.blog/?p=407</guid>
				<description><![CDATA[2월 28일, 4개의 주요 브라우저들은 웹어셈블리의 MVP가 완료되었다는 합의에 이르렀다고 발표했다. 이는 브라우저들이 탑재를 시작할 수 있는 최초의 안정적인 버전을 제공한다.
이는 브라우저가 탑재할 수 있는 안정적인 코어를 제공한다. 이 코어는 커뮤니티 그룹이 계획하고 있는 모든 기능을 포함하고 있지는 않지만, 웹어셈블리를 빠르고 사용가능하도록 만들기에는 충분하다.]]></description>
								<content:encoded><![CDATA[<p><em>이 글은 모질라 Hacks의 웹어셈블리 시리즈 중 마지막 글인 <a href="https://hacks.mozilla.org/2017/02/where-is-webassembly-now-and-whats-next/" target="_blank" rel="noopener noreferrer">Where is WebAssembly now and what’s next?</a>의 번역글이다. 전 시리즈에 걸쳐 웹어셈블리 뿐만 아니라 JIT나 어셈블리 등에 대해서도 체계적으로 잘 설명하고 있고, 카툰까지 곁들여서 이해하기도 쉽다.</em></p>
<p><em>총 6부로 되어 있으며, 원작자의 허가를 얻어 전체 시리즈를 모두 번역했으니 처음부터 차례대로 모두 읽어보길 권한다.</em></p>
<ol>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%b9%b4%ed%88%b0%ec%9c%bc%eb%a1%9c-%ec%86%8c%ea%b0%9c%ed%95%98%eb%8a%94-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac/">카툰으로 소개하는 웹어셈블리</a></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%a0%80%ec%8a%a4%ed%8a%b8-%ec%9d%b8-%ed%83%80%ec%9e%84jit-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/">저스트-인-타임(JIT) 컴파일러 집중 코스</a></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/">어셈블리 집중 코스</a></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%eb%aa%a8%eb%93%88%ec%9d%98-%ec%83%9d%ec%84%b1%ea%b3%bc-%eb%8f%99%ec%9e%91/">웹어셈블리 모듈의 생성과 동작</a></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%8a%94-%ec%99%9c-%eb%b9%a0%eb%a5%bc%ea%b9%8c/">웹어셈블리는 왜 빠를까?</a></li>
<li><strong>웹어셈블리의 현재 위치와 미래 (현재글)</strong></li>
</ol>
<hr />
<p>&nbsp;</p>
<p>2월 28일, 4개의 주요 브라우저들은 웹어셈블리의 MVP가 완료되었다는 <a href="https://lists.w3.org/Archives/Public/public-webassembly/2017Feb/0002.html" target="_blank" rel="noopener noreferrer">합의에 이르렀다고 발표</a>했다. 이는 브라우저들이 탑재를 시작할 수 있는 최초의 안정적인 버전을 제공한다.</p>
<div></div>
<p><img data-attachment-id="414" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%ec%9d%98-%ed%98%84%ec%9e%ac-%ec%9c%84%ec%b9%98%ec%99%80-%eb%af%b8%eb%9e%98/logo_party01-500x169/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/logo_party01-500x169.png?w=1100" data-orig-size="500,169" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="logo_party01-500&#215;169" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/logo_party01-500x169.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/logo_party01-500x169.png?w=1100?w=500" class=" size-full wp-image-414 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/logo_party01-500x169.png?w=1100" alt="logo_party01-500x169.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/logo_party01-500x169.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/logo_party01-500x169.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/logo_party01-500x169.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">이는 브라우저가 탑재할 수 있는 안정적인 코어를 제공한다. 이 코어는 커뮤니티 그룹이 계획하고 있는 모든 기능을 포함하고 있지는 않지만, 웹어셈블리를 빠르고 사용가능하도록 만들기에는 충분하다.</span></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">이것을 이용하면, 개발자들은 웹어셈블리 코드를 탑재할 수 있다. 이전 버전의 브라우저를 위해서 개발자들은 asm.js 버전의 코드를 내려보낼 수 있다. asm.js는 자바스크립트의 서브셋이기 때문에, 모든 JS 엔진이 이를 실행할 수 있다. Emscripten을 이용하면 동일한 앱을 웹어셈블리와 asm.js로 컴파일 할 수 있다.</span></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">최초 버전임에도 불구하고, 웹어셈블리는 빠를 것이다. 하지만 수정과 새로운 기능들이 더해지면, 앞으로는 더 빨라질 것이다.</span></p>
<div>
<h2><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">브라우저에서 웹어셈블리 성능 향상시키기</span></h2>
</div>
<div></div>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">브라우저들이 엔진상의 웹어셈블리 지원을 개선할수록 속도는 더 빨리질 것이다. 브라우저 벤더들이 이러한 이슈들을 위해 독자적으로 노력하고 있다.</span></p>
<h3><span class="ace-all-bold-hthree"><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">JS와 웹어셈블리 간의 더 빠른 함수 호출</span></span></h3>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">현재 JS 코드에서 웹어셈블리 함수를 호출하는 것은 필요 이상으로 느리다. 이는</span> <span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn h-ldquo">“</span><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">트램폴린(trampolining)”이라는 것이 필요하기 때문이다. JIT는 웹어셈블리를 직접 어떻게 다루어야 할 지 모르기 때문에, 그 역할을 하는 것에게 웹어셈블리를 전달해야 한다. 이것은 엔진 내부에 있는 코드중 느린 부분인데, 최적화된 웹어셈블리 코드를 실행하기 위한 셋업 작업을 한다.</span></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn"><img data-attachment-id="419" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%ec%9d%98-%ed%98%84%ec%9e%ac-%ec%9c%84%ec%b9%98%ec%99%80-%eb%af%b8%eb%9e%98/06-02-trampoline01-500x399/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/06-02-trampoline01-500x399.png?w=1100" data-orig-size="500,399" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="06-02-trampoline01-500&#215;399" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/06-02-trampoline01-500x399.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/06-02-trampoline01-500x399.png?w=1100?w=500" class="aligncenter size-full wp-image-419" src="https://dongwoodotblog.files.wordpress.com/2017/06/06-02-trampoline01-500x399.png?w=1100" alt="06-02-trampoline01-500x399.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/06-02-trampoline01-500x399.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/06-02-trampoline01-500x399.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/06-02-trampoline01-500x399.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></span></p>
<p>이 작업은 JIT가 웹어셈블리를 직접 어떻게 다룰지 아는 경우에 비해 100배 이상 느릴 수 있다.</p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">만약 당신이 웹어셈블리 모듈에게 하나의 큰 작업만 넘겨준다면 이러한 오버헤드를 눈치채지 못할 수도 있다. 하지만 만약 웹어셈블리와 JS간에 빈번한 교류가 발생한다면(작은 여러개의 작업을 이용해서) 이 오버헤드가 두드러질 것이다.</span></p>
<h3><span class="ace-all-bold-hthree"><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn"><b>더 빠른 로딩 시간</b></span></span></h3>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">JIT는 더 빠른 로딩 시간과 더 빠른 실행 시간 사이의 트레이드-오프를 관리해야 한다. 만약 당신이 미리 컴파일하고 최적화하는 데에 더 많은 시간을 사용한다면, 실행 시간은 빨라질 수 있겠지만, 초기 구동 시간은 느려지게 된다.</span></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">코드가 한 번 실행된 후에 더 이상 끊김이 없도록 보장하기 위해 미리 컴파일을 하는 것과 대부분의 코드는 충분히 자주 실행되지 않기 때문에 최적화하는 것이 큰 의미가 없다는 사실 사이의 균형을 유지하기 위해 많은 작업들이 진행되고 있다.</span></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">웹어셈블리는 어떤 타입들이 사용될 지 추측할 필요가 없기 때문에, 실행 시점에 어떤 타입들이 사용되는지를 엔진이 모니터링할 필요가 없다. 이는 엔진에게 더 많은 선택지를 주는데, 예를 들면 컴파일을 실행과 병행해서 진행할 수도 있다.</span></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">게다가, 최근에 추가된 자바스크립트 API는 스트림을 이용해서 웹어셈블리를 컴파일할 수 있도록 해 준다. 즉, 바이트를 다운로드 받는 동안에 엔진이 컴파일을 시작할 수 있게 된다.</span></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">파이어폭스에서 우리는 두가지의 컴파일러 시스템을 작업하고 있다. 하나는 미리 실행되어 꽤 괜찮은 수준까지 코드를 최적화한다. 코드가 실행되는 동안에는 다른 컴파일러가 백그라운드에서 완벽하게 최적화를 한다. 완전히 최적화된 코드가 준비되면 기존 코드와 교체되어 들어간다.</span></p>
<div>
<h2><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">MVP 이후 스펙에 추가될 기능들</span></h2>
</div>
<div></div>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">웹어셈블리의 목표 중 하나는 모든 것을 한 번에 디자인하는 것보다는, 작은 조각으로 나누어 구체화하면서 계속해서 테스트하는 것이다.</span></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">즉, 기대되는 기능들이 있긴 하지만, 이들이 미리 100% 완벽하게 구체화되지는 않았다는 의미이다. 이들은 모든 브라우저 벤더들이 참여해서 스펙화하는 과정을 거쳐야만 할 것이다.</span></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">이 기능들은 미래 기능(future features)이라 불린다. 몇 가지만 살펴보겠다. </span></p>
<h3><span class="ace-all-bold-hthree"><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">DOM 직접 다루기</span></span></h3>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">현재로선 DOM과 상호작용할 수 있는 방법이 존재하지 않는다. 즉, 웹어셈블리에서는  </span><strong><span class="inline-code author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">element.innerHTML</span></strong><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">과 같은 식으로 노드를 갱신할 수 없다는 의미이다. </span></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">대신에, JS를 통해서 값을 설정하도록 해야 한다. 이 말은 자바스크립트 호출자(caller)에게 값을 다시 전달한다는 의미가 될 수도 있다. 아니면, 웹어셈블리 내부에서 자바스크립트 함수를 호출한다는 의미가 될 수도 있다.</span> <span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn h-lparen">(</span><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">자바스크립트와 웹어셈블리 함수 모두 웹어셈블리 모듈에서 임포트해서 사용할 수 있다)</span></p>
<div><img data-attachment-id="430" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%ec%9d%98-%ed%98%84%ec%9e%ac-%ec%9c%84%ec%b9%98%ec%99%80-%eb%af%b8%eb%9e%98/06-03-dom01-500x418/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/06-03-dom01-500x418.png?w=1100" data-orig-size="500,418" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="06-03-dom01-500&#215;418" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/06-03-dom01-500x418.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/06-03-dom01-500x418.png?w=1100?w=500" class=" size-full wp-image-430 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/06-03-dom01-500x418.png?w=1100" alt="06-03-dom01-500x418.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/06-03-dom01-500x418.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/06-03-dom01-500x418.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/06-03-dom01-500x418.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></div>
<div></div>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">어느 방법이든, 자바스크립트를 통하는 것은 직접 접근하는 것보다는 느릴 것이다. 일부 웹어셈블리 어플리케이션들은 이 문제가 해결될 때까지 기다려야 할 수도 있을 것이다.</span></p>
<h3><span class="ace-all-bold-hthree"><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">공유 메모리의 동시성</span></span></h3>
<p>코드의 속도를 향상시키는 한가지 방법은 코드의 다른 부분들이 동시에 병렬적으로 실행될 수 있게 만드는 것이다. 하지만 이 방법은 가끔 역효과를 일으키는데, 쓰레드간의 커뮤니케이션으로 인한 오버헤드가 원래 하려는 작업보다 더 많은 시간이 걸릴 수 있기 때문이다.</p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">하지만 쓰레드간에 메모리를 공유할 수 있다면 이러한 오버헤드를 줄일 수 있다. 이를 위해 웹어셈블리는 자바스크립트에서 새롭게 추가된 SharedArrayBuffer를 사용할 것이다. 이 기능이 브라우저에서 제공되기 시작하면 웹어셈블리가 어떻게 이를 다룰지에 대해 작업 그룹이 스펙을 구체화할 수 있을 것이다.</span></p>
<h3><span class="ace-all-bold-hthree"><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">SIMD</span></span></h3>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">만약 웹어셈블리에 대한 다른 글을 읽거나 발표를 본 적이 있다면, 아마도 SIMD 지원에 대해서 들어보았을 것이다. SIMD는 단일 명령, 다중 데이터</span> <span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn h-lparen">(</span><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">single instruction, multiple data)의 약자이다. 이는 병렬 실행을 위한 또다른 방법이다.</span></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">SIMD는 여러 수들로 이루어진 벡터와 같은 대량의 데이터 구조를 취해서, 각기 다른 부분에 동일한 명령을 동시에 적용할 수 있도록 해 준다. 이 방식으로 게임이나 VR에 필요한 복잡한 연산에 대한 성능을 급격하게 향상시킬 수 있다.</span></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">보통의 웹 앱 개발자들에게는 이것이 크게 중요하지 않을 것이다. 하지만 게임과 같은 멀티미디어 관련 개발자들에게 이 기능은 아주 중요하다.</span></p>
<h3><span class="ace-all-bold-hthree"><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">예외 처리</span></span></h3>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">C++과 같은 언어들의 많은 코드 베이스는 예외(exception)를 사용한다. 하지만 예외는 웹어셈블리의 일부로써 정의되어 있지 않다.</span></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">만약 Emscripten을 이용해 코드를 컴파일한다면, 컴파일러 최적화 단계에서 예외 처리를 에뮬레이트 해 줄 것이다. 하지만 꽤나 느리기 때문에, </span><strong><span class="inline-code author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">DISABLE_EXCEPTION_CATCHING</span></strong><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn"> 플래그를 이용해서 이 기능을 끄고 싶을 수도 있을 것이다. </span></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">웹어셈블리에서 직접 예외 처리를 지원하게 된다면 이러한 에뮬레이션은 더이상 필요없을 것이다.</span></p>
<h3><span class="ace-all-bold-hthree"><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">그 외에 개발자 편의를 위한 개선들</span></span></h3>
<div></div>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">몇가지 미래 기능들은 성능에 영향을 끼치지는 않지만, 개발자들이 웹어셈블리를 다루기 쉽게 만들어 줄 것이다.</span></p>
<ul class="listtype-bullet listindent1 list-bullet1">
<li><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn"><b>일급 소스 레벨 개발자 도구</b></span><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">. 현재 브라우저에서 웹어셈블리를 디버깅 하는 것은 순수 어셈블리를 디버깅하는 것이나 마찬가지일 것이다. 하지만 아주 소수의 개발자들만이 머릿속에서 자신의 코드를 어셈블리로 맵핑할 수 있다. 우리는 개발자들이 소스코드를 디버깅하는 것을 지원하는 도구를 어떻게 개선할 수 있을지 조사하고 있다.</span></li>
<li><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn"><b>가비지 컬렉션. </b></span><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">만약 타입을 미리 정의할 수 있다면, 그 코드를 웹어셈블리로 변환할 수도 있어야만 한다. 그러므로 타입스크립트 등을 이용한 코드는 웹어셈블리와 호환 가능해야만 한다. 하지만 현재 딱 한가지 걸림돌이 있는데, 그것은 바로 웹어셈블리가 JS 엔진에 내장된 것과 같은 기존의 가비지 컬렉터와 어떻게 상호작용해야 하는지를 모른다는 점이다. 이 미래 기능의 아이디어는, 웹어셈블리에게 내장된 GC에 대한 일급 접근 권한과 하위 레벨 GC 원시 타입 및 연산을 제공하는 것이다.</span></li>
<li><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn"><b>ES6 모듈 통합. </b></span><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">브라우저는 현재 </span><strong><span class="inline-code author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">script</span></strong><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn"> 태그를 이용해서 자바스크립트 모듈을 로딩할 수 있도록 지원을 추가하고 있다. 이 기능이 추가된 후에는 </span><strong><span class="inline-code author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">&lt;script src=url type=</span><span class="inline-code">&#8220;</span><span class="inline-code author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">module</span><span class="inline-code">&#8220;</span><span class="inline-code author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">&gt;</span></strong><span class="inline-code author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">와</span><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn"> 같은 태그에서 <strong>url</strong>이 웹어셈블리 모듈을 가리킨다고 해도 동작할 수 있을 것이다.</span></li>
</ul>
<div>
<h2><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">결론</span></h2>
</div>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">웹어셈블리는 지금도 빠르지만, 브라우저가 새로운 기능과 개선 사항을 구현하고 나면 더욱 더 빨라질 것이다.</span></p>
<h2><a href="http://code-cartoons.com/">Lin Clark</a> 에 대해</h2>
<p>Lin은 모질라 개발자 관계 팀의 엔지니어이다. 그녀는 자바스크립트, 웹어셈블리, Rust, Servo 등을 끄적거리며, 코드 카툰을 그린다.</p>
<p>코드카툰 : <a href="http://code-cartoons.com/" target="_blank" rel="noopener noreferrer">http://code-cartoons.com/<br />
</a>트위터 : <a href="http://twitter.com/linclark" target="_blank" rel="noopener noreferrer">@linclark</a></p>
<div></div>
<div></div>
<div></div>
]]></content:encoded>
							<wfw:commentRss>https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%ec%9d%98-%ed%98%84%ec%9e%ac-%ec%9c%84%ec%b9%98%ec%99%80-%eb%af%b8%eb%9e%98/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/530c8460562d2041af30cba4cf26b3d0?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">gaekkr</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/logo_party01-500x169.png" medium="image">
			<media:title type="html">logo_party01-500x169.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/06-02-trampoline01-500x399.png" medium="image">
			<media:title type="html">06-02-trampoline01-500x399.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/06-03-dom01-500x418.png" medium="image">
			<media:title type="html">06-03-dom01-500x418.png</media:title>
		</media:content>
	</item>
		<item>
		<title>[번역] 웹어셈블리는 왜 빠를까?</title>
		<link>https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%8a%94-%ec%99%9c-%eb%b9%a0%eb%a5%bc%ea%b9%8c/</link>
				<comments>https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%8a%94-%ec%99%9c-%eb%b9%a0%eb%a5%bc%ea%b9%8c/#comments</comments>
				<pubDate>Tue, 06 Jun 2017 11:38:49 +0000</pubDate>
		<dc:creator><![CDATA[동우]]></dc:creator>
				<category><![CDATA[자바스크립트]]></category>
		<category><![CDATA[번역]]></category>
		<category><![CDATA[브라우저]]></category>
		<category><![CDATA[웹]]></category>
		<category><![CDATA[웹어셈블리]]></category>

		<guid isPermaLink="false">http://dongwoo.blog/?p=354</guid>
				<description><![CDATA[이전 글에서 나는 웹어셈블리와 자바스크립트는 양자택일의 문제가 아니라는 점을 설명했다. 우리는 너무 많은 개발자들이 웹어셈블리만을 이용해 코드를 작성하기를 바라지 않는다.

그러므로 개발자들이 어플리케이션을 개발할 때 웹어셈블리와 자바스크립트 사이에서 하나를 선택할 필요는 없다. 다만, 자바스크립트 코드의 일부를 웹어셈블리로 교체할 수는 있을 것이다.

예를 들어, 리액트를 개발하고 있는 팀은 그들의 리콘사일러(reconciler) 코드 (일명 Virtual DOM) 를 웹어셈블리 버전으로 교체할 수 있을 것이다. 리액트를 사용하는 사람들은 아무것도 할 필요가 없다. 그들의 앱은 웹어셈블리의 장점을 취한다는 것 빼고는 이전과 정확하게 똑같을 것이다.]]></description>
								<content:encoded><![CDATA[<p><em>이 글은 모질라 Hacks의 웹어셈블리 시리즈 중 다섯 번째 글인 <a href="https://hacks.mozilla.org/2017/02/what-makes-webassembly-fast/" target="_blank" rel="noopener noreferrer">What makes WebAssembly fast?</a>의 번역글이다. 전 시리즈에 걸쳐 웹어셈블리 뿐만 아니라 JIT나 어셈블리 등에 대해서도 체계적으로 잘 설명하고 있고, 카툰까지 곁들여서 이해하기도 쉽다.</em></p>
<p><em>총 6부로 되어 있으며, 원작자의 허가를 얻어 전체 시리즈를 모두 번역했으니 처음부터 차례대로 모두 읽어보길 권한다.</em></p>
<ol>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%b9%b4%ed%88%b0%ec%9c%bc%eb%a1%9c-%ec%86%8c%ea%b0%9c%ed%95%98%eb%8a%94-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac/">카툰으로 소개하는 웹어셈블리</a></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%a0%80%ec%8a%a4%ed%8a%b8-%ec%9d%b8-%ed%83%80%ec%9e%84jit-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/">저스트-인-타임(JIT) 컴파일러 집중 코스</a></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/">어셈블리 집중 코스</a></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%eb%aa%a8%eb%93%88%ec%9d%98-%ec%83%9d%ec%84%b1%ea%b3%bc-%eb%8f%99%ec%9e%91/">웹어셈블리 모듈의 생성과 동작</a></li>
<li><strong>웹어셈블리는 왜 빠를까? (현재글)</strong></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%ec%9d%98-%ed%98%84%ec%9e%ac-%ec%9c%84%ec%b9%98%ec%99%80-%eb%af%b8%eb%9e%98/">웹어셈블리의 현재 위치와 미래</a></li>
</ol>
<hr />
<p>&nbsp;</p>
<p><a href="https://hacks.mozilla.org/2017/02/creating-and-working-with-webassembly-modules/">이전 글</a>에서 나는 웹어셈블리와 자바스크립트는 양자택일의 문제가 아니라는 점을 설명했다. 우리는 너무 많은 개발자들이 웹어셈블리만을 이용해 코드를 작성하기를 바라지 않는다.</p>
<p>그러므로 개발자들이 어플리케이션을 개발할 때 웹어셈블리와 자바스크립트 사이에서 하나를 선택할 필요는 없다. 다만, 자바스크립트 코드의 일부를 웹어셈블리로 교체할 수는 있을 것이다.</p>
<p>예를 들어, 리액트를 개발하고 있는 팀은 그들의 리콘사일러(reconciler) 코드 (일명 Virtual DOM) 를 웹어셈블리 버전으로 교체할 수 있을 것이다. 리액트를 사용하는 사람들은 아무것도 할 필요가 없다. 그들의 앱은 웹어셈블리의 장점을 취한다는 것 빼고는 이전과 정확하게 똑같을 것이다.</p>
<p>리액트 팀과 같은 개발자들이 이런 식의 교체를 할 만한 이유는 바로 웹어셈블리가 빠르기 때문이다. 그런데, 웹어셈블리는 왜 빠른걸까?</p>
<h2><a id="user-content-오늘날의-자바스크립트-성능은-어떨까" class="anchor" href="https://github.com/nhnent/fe.javascript/wiki/March-20-March-24,-2017#%EC%98%A4%EB%8A%98%EB%82%A0%EC%9D%98-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%84%B1%EB%8A%A5%EC%9D%80-%EC%96%B4%EB%96%A8%EA%B9%8C"></a>오늘날의 자바스크립트 성능은 어떨까?</h2>
<p>자바스크립트와 웹어셈블리의 성능차이를 이해하려면, 먼저 자바스크립트 엔진이 하는 일을 이해해야 한다.</p>
<p>이 다이어그램은 오늘날 어플리케이션의 시작(start-up) 성능을 간략하게 보여준다.</p>
<blockquote><p>자바스크립트 엔진이 각각의 작업들을 진행할 때 걸리는 시간은 해당 페이지가 사용하는 자바스크립트에 따라 다를 것이다. 이 다이어그램은 정확한 성능 수치를 나타내지 않는다. 대신, 같은 기능을 하는 자바스크립트와 웹어셈블리가 어떤 성능차이를 갖는지에 대한 고차원의 모델을 의미한다.</p></blockquote>
<p><img data-attachment-id="358" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%8a%94-%ec%99%9c-%eb%b9%a0%eb%a5%bc%ea%b9%8c/05-01-diagram_now01-500x129/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-01-diagram_now01-500x129.png?w=1100" data-orig-size="500,129" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="05-01-diagram_now01-500&#215;129" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-01-diagram_now01-500x129.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-01-diagram_now01-500x129.png?w=1100?w=500" class=" size-full wp-image-358 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/05-01-diagram_now01-500x129.png?w=1100" alt="05-01-diagram_now01-500x129.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/05-01-diagram_now01-500x129.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/05-01-diagram_now01-500x129.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/05-01-diagram_now01-500x129.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p>각각의 막대는 특정 작업을 할 때 걸리는 시간을 나타낸다.</p>
<ul>
<li>구문해석 (Parsing) &#8211; 소스코드를 인터프리터가 실행할 수 있는 형태로 가공하는데 걸리는 시간</li>
<li>컴파일 + 최적화 &#8211; 기본(baseline) 컴파일러와 최적화(optimizing) 컴파일러에서 걸리는 시간. 일부 최적화 컴파일러의 작업은 메인 스레드에서 진행되지 않기 때문에 여기에서 제외된다.</li>
<li>재-최적화 (Re-optimizing) &#8211; JIT(Just in time Compiler)가 그들의 가정이 틀렸을 때 재조정하는데 걸리는 시간. 이는 다시 최적화를 하거나, 기본코드로 되돌리는 작업을 모두 포함한다.</li>
<li>실행 &#8211; 코드를 실행하는 데 걸리는 시간</li>
<li>가비지 컬렉션 &#8211; 불필요한 메모리를 비우는 데 걸리는 시간</li>
</ul>
<p>한가지 중요한 사실 : 이 작업들은 구분된 단위를 갖거나 특정한 순서로 진행되지 않고, 서로 맞물려서 진행된다. 구문 해석이 일부 진행된 후, 일부 실행, 일부 컴파일, 다시 일부 구문 해석, 일부 실행 등의 형태로 진행된다.</p>
<p>이렇게 작은 단위로 분해함으로써, 다음 다이어그램과 같았던 초기 자바스크립트의 성능으로부터 큰 개선을 이룰 수 있었다.</p>
<p><img data-attachment-id="359" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%8a%94-%ec%99%9c-%eb%b9%a0%eb%a5%bc%ea%b9%8c/05-02-diagram_past01-500x147/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-02-diagram_past01-500x147.png?w=1100" data-orig-size="500,147" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="05-02-diagram_past01-500&#215;147" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-02-diagram_past01-500x147.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-02-diagram_past01-500x147.png?w=1100?w=500" class=" size-full wp-image-359 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/05-02-diagram_past01-500x147.png?w=1100" alt="05-02-diagram_past01-500x147.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/05-02-diagram_past01-500x147.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/05-02-diagram_past01-500x147.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/05-02-diagram_past01-500x147.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p>단순히 자바스크립트를 실행하는 인터프리터였던 초기에는 실행속도가 상당히 느렸다. JIT가 도입된 이후로 실행속도는 급격하게 증가했다.</p>
<p>트레이드-오프는, 코드를 감지하고 컴파일할 때 부하가 발생한다는 점이다. 만약 자바스크립트 개발자들이 지금까지 해왔던 방식으로만 코드를 작성한다면 구문해석과 컴파일 시간은 아주 작을 것이다. 하지만 자바스크립트의 성능이 개선될수록 개발자들은 자바스크립트로 더 복잡한 어플리케이션을 개발하게 될 것이다. 즉, 좀 더 개선할 여지가 있다는 의미이다.</p>
<h2><a id="user-content-웹어셈블리는-어떻게-다를까" class="anchor" href="https://github.com/nhnent/fe.javascript/wiki/March-20-March-24,-2017#%EC%9B%B9%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8B%A4%EB%A5%BC%EA%B9%8C"></a>웹어셈블리는 어떻게 다를까?</h2>
<p>아래 다이어그램은 웹어셈블리가 전형적인 웹 어플리케이션과 어떻게 다른지를 보여준다.</p>
<p><img data-attachment-id="362" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%8a%94-%ec%99%9c-%eb%b9%a0%eb%a5%bc%ea%b9%8c/05-03-diagram_future01-500x214/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-03-diagram_future01-500x214.png?w=1100" data-orig-size="500,214" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="05-03-diagram_future01-500&#215;214" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-03-diagram_future01-500x214.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-03-diagram_future01-500x214.png?w=1100?w=500" class=" size-full wp-image-362 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/05-03-diagram_future01-500x214.png?w=1100" alt="05-03-diagram_future01-500x214.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/05-03-diagram_future01-500x214.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/05-03-diagram_future01-500x214.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/05-03-diagram_future01-500x214.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p>각각의 단계를 어떻게 다루는지는 브라우저마다 조금씩 다르다. 여기서는 SpiderMonky를 모델로 설명하겠다.</p>
<h2><a id="user-content-가져오기-fetching" class="anchor" href="https://github.com/nhnent/fe.javascript/wiki/March-20-March-24,-2017#%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0-fetching"></a>가져오기 (Fetching)</h2>
<p>다이어그램에는 나오지 않았지만, 단순히 서버에서 파일을 가져오는 일에도 시간이 소모된다.</p>
<p>웹어셈블리는 자바스크립트보다 더 간결하기 때문에 데이터를 가져오는 속도가 더 빠르다. 압축 알고리즘이 자바스크립트 번들 파일의 사이즈를 상당히 줄일 수 있을지는 몰라도, 압축된 바이너리 형태의 웹어셈블리가 여전히 더 작을 것이다.</p>
<p>즉, 서버에서 클라이언트로 전송하는 시간이 더 적게 걸리게 된다. 느린 네트워크 환경에서는 더 의미가 있을 것이다.</p>
<h2><a id="user-content-구문해석" class="anchor" href="https://github.com/nhnent/fe.javascript/wiki/March-20-March-24,-2017#%EA%B5%AC%EB%AC%B8%ED%95%B4%EC%84%9D"></a>구문해석 (Parsing)</h2>
<p>자바스크립트 소스가 브라우저에 전달되게 되면, 추상 구문 트리(AST : Abstract Syntax Tree)로 변환된다.</p>
<p>브라우저는 종종 이 작업을 지연해서 실행하는데, 초기 실행에 필요한 부분만 먼저 해석하고 아직 호출되지 않은 함수들은 스텁(stub)만 만들어 둔다. 이때 AST는 중간 표현 형식(바이트코드라고 불리는)으로 변환되는데, 이는 각 자바스크립트 엔진에 따라 다르다. 반면, 웹어셈블리는 그 자체로 이미 중간 표현 형식이기 때문에 이 변환 작업을 거칠 필요가 없다. 웹어셈블리는 단지 해독된(decoded) 이후에 에러가 없는지만 검증되면(validated) 된다.</p>
<p><img data-attachment-id="364" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%8a%94-%ec%99%9c-%eb%b9%a0%eb%a5%bc%ea%b9%8c/05-04-diagram_compare02-500x169/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-04-diagram_compare02-500x169.png?w=1100" data-orig-size="500,169" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="05-04-diagram_compare02-500&#215;169" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-04-diagram_compare02-500x169.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-04-diagram_compare02-500x169.png?w=1100?w=500" class=" size-full wp-image-364 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/05-04-diagram_compare02-500x169.png?w=1100" alt="05-04-diagram_compare02-500x169.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/05-04-diagram_compare02-500x169.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/05-04-diagram_compare02-500x169.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/05-04-diagram_compare02-500x169.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<h2><a id="user-content-컴파일--최적화" class="anchor" href="https://github.com/nhnent/fe.javascript/wiki/March-20-March-24,-2017#%EC%BB%B4%ED%8C%8C%EC%9D%BC--%EC%B5%9C%EC%A0%81%ED%99%94"></a>컴파일 + 최적화</h2>
<p><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%a0%80%ec%8a%a4%ed%8a%b8-%ec%9d%b8-%ed%83%80%ec%9e%84jit-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/">JIT</a>에 대한 글에서 설명했듯이, 자바스크립트는 코드를 실행하는 도중에 컴파일된다. 런타임에 어떤 타입이 사용되는지에 따라 동일한 코드가 다양한 버전으로 컴파일되기도 한다.</p>
<p>브라우저들은 웹어셈블리를 각자 다른 방식으로 컴파일한다. 일부 브라우저들은 실행하기 전에 기본 컴파일 단계를 거치고, 다른 브라우저들은 JIT를 사용한다.</p>
<p>어떤 방식이든, 웹어셈블리는 기계 코드와 훨씬 가까운 상태에서 시작한다. 예를 들면 프로그램의 일부로써 타입이 포함되어 있는데, 이는 다음의 몇가지 이유로 더 빠르다.</p>
<ol>
<li>최적화된 코드를 컴파일하기 전에, 어떤 타입이 사용되었는지 확인하기 위해 코드를 실행해볼 필요가 없다.</li>
<li>같은 코드에서 대해서 여러가지 타입들이 사용되고 있을 때, 여러가지 버전으로 컴파일할 필요가 없다.</li>
<li>LLVM 에서 이미 많은 최적화가 진행된 상태이기 때문에, 컴파일이나 최적화에 필요한 작업이 적다.</li>
</ol>
<p><img data-attachment-id="382" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%8a%94-%ec%99%9c-%eb%b9%a0%eb%a5%bc%ea%b9%8c/05-05-diagram_compare03-500x175/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-05-diagram_compare03-500x175.png?w=1100" data-orig-size="500,175" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="05-05-diagram_compare03-500&#215;175" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-05-diagram_compare03-500x175.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-05-diagram_compare03-500x175.png?w=1100?w=500" class=" size-full wp-image-382 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/05-05-diagram_compare03-500x175.png?w=1100" alt="05-05-diagram_compare03-500x175.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/05-05-diagram_compare03-500x175.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/05-05-diagram_compare03-500x175.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/05-05-diagram_compare03-500x175.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<h2>재-최적화 (Reoptimizing)</h2>
<p>JIT는 가끔 최적화된 버전을 버리고, 다시 최적화해야한다.</p>
<p>이는 JIT가 코드 실행에 기초하여 만들어낸 가정이 잘못된 것으로 판명될 때 발생한다. 예를 들어 순환문 내부에서 사용되는 변수에 이전 주기와는 다른 값이 할당되거나, 프로토타입 체인내부에 다른 함수가 추가되면, 역최적화(deoptimization)가 발생한다.</p>
<p>역최적화에는 두가지 비용이 따른다. 첫째로, 최적화된 코드를 내버리고 기본 코드로 되돌릴 때 시간이 소모된다. 둘째로, 해당 함수가 여전히 많은 빈도로 호출되고 있다면 JIT는 해당 함수를 다시 최적화 컴파일러에게 보내기로 결정할 수도 있는데, 여기에서 컴파일을 두 번 하는 것에 따른 비용이 발생한다.</p>
<p>웹어셈블리에서는 타입과 같은 것들이 명시적이기 때문에, JIT가 런타임에 데이터를 수집해서 타입을 추론할 필요가 없다. 즉, 재-최적화 단계가 필요없다는 의미이다.</p>
<p><img data-attachment-id="386" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%8a%94-%ec%99%9c-%eb%b9%a0%eb%a5%bc%ea%b9%8c/05-06-diagram_compare04-500x201/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-06-diagram_compare04-500x201.png?w=1100" data-orig-size="500,201" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="05-06-diagram_compare04-500&#215;201" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-06-diagram_compare04-500x201.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-06-diagram_compare04-500x201.png?w=1100?w=500" class=" size-full wp-image-386 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/05-06-diagram_compare04-500x201.png?w=1100" alt="05-06-diagram_compare04-500x201.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/05-06-diagram_compare04-500x201.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/05-06-diagram_compare04-500x201.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/05-06-diagram_compare04-500x201.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<h2><a id="user-content-실행" class="anchor" href="https://github.com/nhnent/fe.javascript/wiki/March-20-March-24,-2017#%EC%8B%A4%ED%96%89"></a>실행</h2>
<p>자바스크립트가 빠르게 실행될 수 있도록 작성하는 것은 가능하다. 이를 위해서는 JIT가 어떻게 최적화하는지에 대해서 알고 있어야 한다. 예를 들어 <a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%a0%80%ec%8a%a4%ed%8a%b8-%ec%9d%b8-%ed%83%80%ec%9e%84jit-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/">JIT</a>에 관한 예전 글에서 설명했던 것 처럼, 컴파일러가 타입을 특수화(type specialize : 타입이 항상 동일하다고 가정하고 코드를 최적화하는 과정)를 하도록 만드려면 어떻게 코드를 작성해야하는지를 알아야 한다.</p>
<p>하지만, 대부분의 개발자들은 JIT 내부에 대해서 알지 못한다. 심지어 JIT 내부에 대해서 알고 있는 개발자들도, 정확한 개선 포인트를 알기는 쉽지 않다. 코드를 읽기 쉽게 만들기 위해 사용되는 코딩 패턴들(공통 작업을 추상화해서 타입에 관계없이 동작하는 함수로 만드는 작업 등)은 컴파일러가 코드를 최적화하는 것을 방해한다.</p>
<p>게다가 JIT가 사용하는 최적화는 브라우저마다 달라서, 특정 브라우저에 맞추어 코딩을 하면 다른 브라우저에서는 성능이 느릴수도 있다.</p>
<p>이러한 이유로, 웹어셈블리로 작성된 코드를 실행하는 것은 일반적으로 더 빠르다. 자바스크립트를 위해 JIT가 하는 많은 최적화 작업들(타입 특수화와 같은)은 웹어셈블리에서는 전혀 필요없다.</p>
<p>뿐만 아니라 웹어셈블리는 컴파일러를 목표로 디자인되었다. 즉, 인간 프로그래머가 작성하는 용도가 아닌, 컴파일러가 생성해내는 용도로 디자인 되었다는 의미이다.</p>
<p>인간 프로그래머가 직접 프로그래밍할 필요가 없기 때문에, 웹어셈블리는 기계에게 더 이상적인 명령(instruction) 셋을 제공할 수 있다. 코드가 어떤 종류의 작업을 하느냐에 따라 이러한 명령들은 10% 부터 800% 까지 더 빠를 수 있다.</p>
<p><img data-attachment-id="397" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%8a%94-%ec%99%9c-%eb%b9%a0%eb%a5%bc%ea%b9%8c/05-07-diagram_compare05-500x171/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-07-diagram_compare05-500x171.png?w=1100" data-orig-size="500,171" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="05-07-diagram_compare05-500&#215;171" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-07-diagram_compare05-500x171.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-07-diagram_compare05-500x171.png?w=1100?w=500" class=" size-full wp-image-397 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/05-07-diagram_compare05-500x171.png?w=1100" alt="05-07-diagram_compare05-500x171.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/05-07-diagram_compare05-500x171.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/05-07-diagram_compare05-500x171.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/05-07-diagram_compare05-500x171.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<h2><a id="user-content-가비지-컬렉션" class="anchor" href="https://github.com/nhnent/fe.javascript/wiki/March-20-March-24,-2017#%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98"></a>가비지 컬렉션</h2>
<p>자바스크립트에서 개발자들은 더이상 필요없는 오래된 변수들을 메모리에서 제거하는 작업에 대해 신경쓸 필요가 없다. 대신에 자바스크립트 엔진이 가비지 컬렉터를 이용해 이러한 작업을 자동으로 해 준다.</p>
<p>하지만 만약 예측가능한 성능을 원한다면, 이는 문제가 될 수도 있다. 가비지 컬렉터가 언제 작동할 지 제어할 수 없기 때문에, 안좋은 타이밍에 실행될 지도 모른다. 대부분의 브라우저들은 이를 잘 스케쥴링해 주고 있지만, 여전히 코드 실행을 방해하는 요인이 될 수도 있다.</p>
<p>최소한 현재까지는, 웹어셈블리는 가비지 컬렉션을 전혀 지원하지 않는다. 메모리는 수동으로 (C나 C++와 같이) 관리된다. 이로 인해 개발자들이 프로그래밍 하기는 더 어려울 수도 있지만, 성능에 있어서는 더 안정된 결과를 만들어낼 수 있을 것이다.</p>
<p><img data-attachment-id="399" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%8a%94-%ec%99%9c-%eb%b9%a0%eb%a5%bc%ea%b9%8c/05-08-diagram_compare06-500x204/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-08-diagram_compare06-500x204.png?w=1100" data-orig-size="500,204" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="05-08-diagram_compare06-500&#215;204" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-08-diagram_compare06-500x204.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/05-08-diagram_compare06-500x204.png?w=1100?w=500" class=" size-full wp-image-399 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/05-08-diagram_compare06-500x204.png?w=1100" alt="05-08-diagram_compare06-500x204.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/05-08-diagram_compare06-500x204.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/05-08-diagram_compare06-500x204.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/05-08-diagram_compare06-500x204.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<h2><a id="user-content-결론" class="anchor" href="https://github.com/nhnent/fe.javascript/wiki/March-20-March-24,-2017#%EA%B2%B0%EB%A1%A0"></a>결론</h2>
<p>웹어셈블리는 많은 경우에 자바스크립트보다 더 빠르다. 왜냐하면 :</p>
<ul>
<li>웹어셈블리 코드가 자바스크립트보다 더 간결하기 때문에 (압축된 경우에도 마찬가지), 코드를 가져오는 데에 더 적은 시간이 걸린다.</li>
<li>웹어셈블리 코드를 해독(decode)하는 시간이 자바스크립트의 구문을 해석 (parse) 하는 시간보다 적게 걸린다.</li>
<li>웹어셈블리 코드는 자바스크립트 코드보다 더 머신 코드에 가깝고, 서버단에서 미리 최적화가 되어 있기 때문에 컴파일하고 최적화하는 시간이 적게 걸린다.</li>
<li>웹어셈블리는 타입이나 다른 정보가 미리 내장되어 있기 때문에, 자바스크립트 엔진이 실행시점에 분석할 필요가 없어서 재-최적화하는 시간이 필요없다.</li>
<li>웹어셈블리 코드는 성능을 위해 컴파일러를 느리게 만드는 요인들에 대해 개발자들이 미리 알고 있을 필요가 없으며, 머신에 적합한 명령어 셋을 갖고 있기 때문에 실행시간도 주로 더 적게 걸린다.</li>
<li>메모리를 직접 관리하기 때문에 가비지 컬렉션이 필요없다.</li>
</ul>
<p>이것이 바로 같은 작업을 할 때 웹어셈블리가 자바스크립트보다 더 좋은 성능을 내는 이유이다.</p>
<p>몇몇 경우에는 기대한 것 만큼 웹어셈블리가 빠르지 않을 때도 있지만, 머지않아 이를 개선할 변화가 있을 것이다. <a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%ec%9d%98-%ed%98%84%ec%9e%ac-%ec%9c%84%ec%b9%98%ec%99%80-%eb%af%b8%eb%9e%98/">다음 글</a>에서 이런 내용들을 다루도록 하겠다.</p>
<h2><a href="http://code-cartoons.com/">Lin Clark</a> 에 대해</h2>
<p>Lin은 모질라 개발자 관계 팀의 엔지니어이다. 그녀는 자바스크립트, 웹어셈블리, Rust, Servo 등을 끄적거리며, 코드 카툰을 그린다.</p>
<p>코드카툰 : <a href="http://code-cartoons.com/" target="_blank" rel="noopener noreferrer">http://code-cartoons.com/<br />
</a>트위터 : <a href="http://twitter.com/linclark" target="_blank" rel="noopener noreferrer">@linclark</a></p>
]]></content:encoded>
							<wfw:commentRss>https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%8a%94-%ec%99%9c-%eb%b9%a0%eb%a5%bc%ea%b9%8c/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/530c8460562d2041af30cba4cf26b3d0?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">gaekkr</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/05-01-diagram_now01-500x129.png" medium="image">
			<media:title type="html">05-01-diagram_now01-500x129.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/05-02-diagram_past01-500x147.png" medium="image">
			<media:title type="html">05-02-diagram_past01-500x147.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/05-03-diagram_future01-500x214.png" medium="image">
			<media:title type="html">05-03-diagram_future01-500x214.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/05-04-diagram_compare02-500x169.png" medium="image">
			<media:title type="html">05-04-diagram_compare02-500x169.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/05-05-diagram_compare03-500x175.png" medium="image">
			<media:title type="html">05-05-diagram_compare03-500x175.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/05-06-diagram_compare04-500x201.png" medium="image">
			<media:title type="html">05-06-diagram_compare04-500x201.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/05-07-diagram_compare05-500x171.png" medium="image">
			<media:title type="html">05-07-diagram_compare05-500x171.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/05-08-diagram_compare06-500x204.png" medium="image">
			<media:title type="html">05-08-diagram_compare06-500x204.png</media:title>
		</media:content>
	</item>
		<item>
		<title>[번역] 웹어셈블리 모듈의 생성과 동작</title>
		<link>https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%eb%aa%a8%eb%93%88%ec%9d%98-%ec%83%9d%ec%84%b1%ea%b3%bc-%eb%8f%99%ec%9e%91/</link>
				<comments>https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%eb%aa%a8%eb%93%88%ec%9d%98-%ec%83%9d%ec%84%b1%ea%b3%bc-%eb%8f%99%ec%9e%91/#comments</comments>
				<pubDate>Tue, 06 Jun 2017 11:18:18 +0000</pubDate>
		<dc:creator><![CDATA[동우]]></dc:creator>
				<category><![CDATA[자바스크립트]]></category>
		<category><![CDATA[번역]]></category>
		<category><![CDATA[브라우저]]></category>
		<category><![CDATA[웹]]></category>
		<category><![CDATA[웹어셈블리]]></category>

		<guid isPermaLink="false">http://dongwoo.blog/?p=275</guid>
				<description><![CDATA[웹어셈블리는 자바스크립트가 아닌 프로그래밍 언어를 웹페이지에서 실행하기 위한 방법이다. 예전에는 웹페이지 내의 다른 부분들과 상호작용하기 위해 브라우저에서 코드를 실행시키기 위한 유일한 선택지가 자바스크립트였다.

그래서 사람들이 웹어셈블리가 빠르다고 이야기할 때, 유일한 비교대상은 자바스크립트다. 하지만 그것이 웹어셈블리와 자바스크립트 중에서 하나만 선택해서 사용해야 한다는 의미는 아니다.

사실, 우리는 개발자들이 같은 어플리케이션 내에서 웹어셈블리와 자바스크립트를 모두 사용하길 바란다. 심지어 웹어셈블리를 직접 작성하지 않더라도, 그 이점을 누릴 수 있다.]]></description>
								<content:encoded><![CDATA[<p><em>이 글은 모질라 Hacks의 웹어셈블리 시리즈 중 네 번째 글인 <a href="https://hacks.mozilla.org/2017/02/creating-and-working-with-webassembly-modules/" target="_blank" rel="noopener noreferrer">Creating and working with WebAssembly modules</a>의 번역글이다. 전 시리즈에 걸쳐 웹어셈블리 뿐만 아니라 JIT나 어셈블리 등에 대해서도 체계적으로 잘 설명하고 있고, 카툰까지 곁들여서 이해하기도 쉽다.</em></p>
<p><em>총 6부로 되어 있으며, 원작자의 허가를 얻어 전체 시리즈를 모두 번역했으니 처음부터 차례대로 모두 읽어보길 권한다.</em></p>
<ol>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%b9%b4%ed%88%b0%ec%9c%bc%eb%a1%9c-%ec%86%8c%ea%b0%9c%ed%95%98%eb%8a%94-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac/">카툰으로 소개하는 웹어셈블리</a></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%a0%80%ec%8a%a4%ed%8a%b8-%ec%9d%b8-%ed%83%80%ec%9e%84jit-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/">저스트-인-타임(JIT) 컴파일러 집중 코스</a></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/">어셈블리 집중 코스</a></li>
<li><strong>웹어셈블리 모듈의 생성과 동작 (현재글)</strong></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%8a%94-%ec%99%9c-%eb%b9%a0%eb%a5%bc%ea%b9%8c/">웹어셈블리는 왜 빠를까?</a></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%ec%9d%98-%ed%98%84%ec%9e%ac-%ec%9c%84%ec%b9%98%ec%99%80-%eb%af%b8%eb%9e%98/">웹어셈블리의 현재 위치와 미래</a></li>
</ol>
<hr />
<p>&nbsp;</p>
<p>웹어셈블리는 자바스크립트가 아닌 프로그래밍 언어를 웹페이지에서 실행하기 위한 방법이다. 예전에는 웹페이지 내의 다른 부분들과 상호작용하기 위해 브라우저에서 코드를 실행시키기 위한 유일한 선택지가 자바스크립트였다.</p>
<p>그래서 사람들이 웹어셈블리가 빠르다고 이야기할 때, 유일한 비교대상은 자바스크립트다. 하지만 그것이 웹어셈블리와 자바스크립트 중에서 하나만 선택해서 사용해야 한다는 의미는 아니다.</p>
<p>사실, 우리는 개발자들이 같은 어플리케이션 내에서 웹어셈블리와 자바스크립트를 모두 사용하길 바란다. 심지어 웹어셈블리를 직접 작성하지 않더라도, 그 이점을 누릴 수 있다.</p>
<p>웹어셈블리 모듈은 자바스크립트에서 사용될 수 있는 함수들을 정의한다. 그러므로 오늘날 npm 을 이용해서 lodash와 같은 모듈을 다운로드 받아서 API 에 있는 함수를 호출하듯이, 나중에는 웸어셈블리 모듈을 다운로드 받을 수 있게 될 것이다.</p>
<p>그러면, 웹어셈블리 모듈을 어떻게 생성할 수 있고, 어떻게 자바스크립트에 이용할 수 있는지를 살펴보자.</p>
<h2>웹어셈블리는 어디에 어울릴까?</h2>
<p><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/">어셈블리에 대해 설명한 글</a>에서, 나는 컴파일러가 상위 레벨 프로그래밍 언어들을 어떻게 읽어들여서 기계 코드로 번역하는지에 대해서 이야기했다.</p>
<p><img data-attachment-id="279" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%eb%aa%a8%eb%93%88%ec%9d%98-%ec%83%9d%ec%84%b1%ea%b3%bc-%eb%8f%99%ec%9e%91/04-01-langs09-500x306/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-01-langs09-500x306.png?w=1100" data-orig-size="500,306" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="04-01-langs09-500&#215;306" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-01-langs09-500x306.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-01-langs09-500x306.png?w=1100?w=500" class="aligncenter size-full wp-image-279" src="https://dongwoodotblog.files.wordpress.com/2017/06/04-01-langs09-500x306.png?w=1100" alt="04-01-langs09-500x306.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/04-01-langs09-500x306.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/04-01-langs09-500x306.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/04-01-langs09-500x306.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p>이 그림에서 웹어셈블리는 어떤 역할을 할까?</p>
<p>어쩌면 웹어셈블리가 또 하나의 대상 어셈블리 언어라고 생각할지도 모르겠다. 어느 정도는 사실이지만, 이들 각각의 언어들 (x86, ARM)은 특정한 기계의 아키텍쳐와 연관된다는 점에서 차이가 있다.</p>
<p>사용자의 기계에서 실행될 코드를 웹을 통해서 전달할 때, 당신은 코드가 실행될 대상 아키텍쳐가 무엇인지를 알 수가 없다.</p>
<p>그러므로 웹어셈블리는 다른 종류의 어셈블리와는 약간 다르다. 웹어셈블리는 실제의 물리적인 기계가 아닌 개념상의 기계를 위한 언어이다.</p>
<p>이러한 이유로, 웹어셈블리의 명령(instruction)들은 가끔 가상 명령(virtual instruction)이라고도 불린다. 이들은 자바스크립트 코드보다는 훨씬 더 기계 코드와 직접적으로 맵핑된다. 이들은 공통적으로 널리 쓰이는 하드웨어에서 효과적으로 사용될 수 있는 일종의 교집합을 나타낸다. 하지만 이들이 특정한 하드웨어를 위한 특정 기계 코드에 직접적으로 맵핑되는 것은 아니다.</p>
<p><img data-attachment-id="282" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%eb%aa%a8%eb%93%88%ec%9d%98-%ec%83%9d%ec%84%b1%ea%b3%bc-%eb%8f%99%ec%9e%91/04-02-langs08-500x326/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-02-langs08-500x326.png?w=1100" data-orig-size="500,326" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="04-02-langs08-500&#215;326" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-02-langs08-500x326.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-02-langs08-500x326.png?w=1100?w=500" class=" size-full wp-image-282 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/04-02-langs08-500x326.png?w=1100" alt="04-02-langs08-500x326.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/04-02-langs08-500x326.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/04-02-langs08-500x326.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/04-02-langs08-500x326.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p>브라우저는 웹어셈블리를 다운로드한다. 그러면 브라우저는 웹어셈블리로부터 대상 기계의 어셈블리 코드를 위한 짧은 홉(hop)을 만들어낼 수 있다.</p>
<h2>.wasm 으로 컴파일하기</h2>
<p>현재 웹어셈블리를 가장 잘 지원하는 컴파일러 도구 모음(toolchain)은 LLVM이라 불린다. 많은 수의 프론트엔드와 백엔드가 LLVM으로 변환이 가능하다.</p>
<p><em>Note: 대부분의 웹어셈블리 모듈 개발자들은 C나 Rust 등의 언어들로 개발한 후 웹어셈블리로 컴파일하지만, 웹어셈블리 모듈을 생성하기 위한 다른 방법도 있다. 예를 들면, 타입스크립트를 이용해 웹어셈블리 모듈을 생성할 수 있는 실험적인 도구도 존재하고, 직접 텍스트 형태로 코드를 작성할 수도 있다.</em></p>
<p>우리가 C를 이용해 웹어셈블리를 작성한다고 가정하자. 우리는 clang 프론트엔드를 이용해서 C를 LLVM 중간 표현 방식으로 변환할 수 있을 것이다. LLVM의 IR로 변환하고 나면, LLVM이 그것을 이해할 수 있으므로 LLVM이 몇가지 최적화를 할 수 있게 된다.</p>
<p>LLVM의 IR(intermidiate representation)에서 웹어셈블리로 변환하기 위해서 우리는 백엔드가 필요하다. 현재 LLVM 프로젝트에서 하나가 진행되고 있다. 이 백엔드는 대부분의 사항이 완료되었고, 곧 완성될 예정이다. 하지만, 지금 당장 사용하기에는 약간 어려울 수도 있다.</p>
<p>지금 당장 사용하기에 좀더 쉬운 Emscripten 이라는 또다른 도구도 있다. 이는 자신만의 백엔드를 갖고 있는데, 이 백엔드는 또다른 대상 (asm.js)으로 컴파일한 후에 그것을 웹어셈블리로 변환하는 방식으로 웹어셈블리를 생성할 수 있다. 하지만 내부적으로는 LLVM을 사용하고 있기 때문에, Emscripten를 이용하면 두개의 백엔드 사이를 전환할 수 있다.</p>
<p><img data-attachment-id="304" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%eb%aa%a8%eb%93%88%ec%9d%98-%ec%83%9d%ec%84%b1%ea%b3%bc-%eb%8f%99%ec%9e%91/04-03-toolchain07-500x411/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-03-toolchain07-500x411.png?w=1100" data-orig-size="500,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="04-03-toolchain07-500&#215;411" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-03-toolchain07-500x411.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-03-toolchain07-500x411.png?w=1100?w=500" class=" size-full wp-image-304 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/04-03-toolchain07-500x411.png?w=1100" alt="04-03-toolchain07-500x411.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/04-03-toolchain07-500x411.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/04-03-toolchain07-500x411.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/04-03-toolchain07-500x411.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p>Emscripten은 전체 C/C++ 코드베이스를 변환할 수 있게 해 주는 많은 추가적인 도구와 라이브러리를 포함하기 때문에, 컴파일러라고 하기 보다는 소프트웨어 개발자 킷 (SDK: Software Developer Kit)에 가깝다. 예를 들어 시스템 개발자들은 주로 쓰기와 읽기를 할 수 있는 파일시스템을 갖고 있는데, Emscripten은 IndexedDB를 이용해서 파일 시스템을 시뮬레이트할 수 있다.</p>
<p>당신이 어떤 도구 모음을 사용했는지와는 관계 없이, 최종 결과는 .wasm 으로 끝나는 파일이 된다. 아래에서 .wasm의 구조에 대해 좀 더 설명하도록 하겠다. 먼저 이것을 자바스크립트에서 어떻게 사용할 수 있는지부터 살펴보자.</p>
<h2>자바스크립트에서 .wasm 모듈 로딩하기</h2>
<p>.wasm 파일은 웹어셈블리 모듈이며, 자바스크립트에서 로드될 수 있다. 이 시점부터 로딩 과정은 약간 복잡해진다.</p>
<pre class="brush: jscript; gutter: false; title: ; notranslate">
function fetchAndInstantiate(url, importObject) {
  return fetch(url).then(response =&amp;amp;amp;amp;amp;amp;amp;gt;
    response.arrayBuffer()
  ).then(bytes =&amp;amp;amp;amp;amp;amp;amp;gt;
    WebAssembly.instantiate(bytes, importObject)
  ).then(results =&amp;amp;amp;amp;amp;amp;amp;gt;
    results.instance
  );
}
</pre>
<p>여기에 대한 더 깊은 설명은 <a href="https://developer.mozilla.org/en-US/docs/WebAssembly" target="_blank" rel="noopener noreferrer">우리 문서</a>에서 확인할 수 있다.</p>
<p>우리는 이 과정을 좀더 쉽게 만들기 위해 작업하고 있다. 우리는 도구 모음을 좀더 발전시키고, 현존하는 webpack과 같은 모듈 번들러나 SystemJS와 같은 로더들을 통합할 수 있게 되길 기대한다. 우리는 웹어셈블리 모듈을 로딩하는 것이 자바스크립트 모듈을 로딩하는 것만큼 쉬워질 수 있다고 믿는다.</p>
<p>하지만, 웹어셈블리 모듈과 JS 모듈 사이에는 중요한 차이점이 있다. 현재, 웹어셈블리의 함수들은 파라미터나 반환값으로 오직 숫자형(정수 혹은 부동소수)만을 사용할 수 있다.</p>
<p><img data-attachment-id="313" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%eb%aa%a8%eb%93%88%ec%9d%98-%ec%83%9d%ec%84%b1%ea%b3%bc-%eb%8f%99%ec%9e%91/04-04-memory04-500x93/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-04-memory04-500x93.png?w=1100" data-orig-size="500,93" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="04-04-memory04-500&#215;93" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-04-memory04-500x93.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-04-memory04-500x93.png?w=1100?w=500" class=" size-full wp-image-313 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/04-04-memory04-500x93.png?w=1100" alt="04-04-memory04-500x93.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/04-04-memory04-500x93.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/04-04-memory04-500x93.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/04-04-memory04-500x93.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p>문자열과 같은 더 복잡한 데이터 형을 위해서는, 웹어셈블리 모듈의 메모리를 사용해야만 한다.</p>
<p>만약 당신이 대부분의 작업을 자바스크립트로 해 왔다면, 메모리에 직접 접근하는 것이 그리 익숙하지는 않을 것이다. C나 C++ 혹은 Rust와 같은 더 고성능의 언어들은 주로 메모리를 직접 관리한다. 웹어셈블리 모듈의 메모리는 이러한 언어들에서 찾을 수 있는 힙(heap)을 시뮬레이트한다.</p>
<p>이를 위해서, 웹어셈블리 모듈은 자바스크립트에서 배열 버퍼라 불리는 것을 사용한다. 배열 버퍼는 바이트의 배열이다. 그러므로 배열의 인덱스들은 메모리의 주소의 용도로 사용된다.<br />
당신이 자바스크립트와 웹어셈블리 사이에서 문자열을 전달하려고 한다면, 해당 문자들을 동등한 문자 코드로 변환해야만 한다. 그리고 그 코드를 메모리 배열에 저장한다. 인덱스들이 정수형이기 때문에 인덱스 하나를 웹어셈블리 함수로 전달할 수 있다. 그러므로 해당 문자열의 첫번째 문자에 해당하는 인덱스가 포인터로써 사용될 수 있다.</p>
<p><img data-attachment-id="315" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%eb%aa%a8%eb%93%88%ec%9d%98-%ec%83%9d%ec%84%b1%ea%b3%bc-%eb%8f%99%ec%9e%91/04-05-memory12-500x400/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-05-memory12-500x400.png?w=1100" data-orig-size="500,400" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="04-05-memory12-500&#215;400" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-05-memory12-500x400.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-05-memory12-500x400.png?w=1100?w=500" class=" size-full wp-image-315 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/04-05-memory12-500x400.png?w=1100" alt="04-05-memory12-500x400.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/04-05-memory12-500x400.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/04-05-memory12-500x400.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/04-05-memory12-500x400.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p>아마 웹개발자들에 의해 사용될 웹어셈블리 모듈을 개발하는 사람은 누구나 해당 모듈 주변에 래퍼를 생성해 줄 것이다. 그렇게 되면 모듈을 사용하는 입장에서는 메모리 관리에 대해 알 필요가 없게 된다.<br />
만약 좀더 배우고 싶다면, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/WebAssembly/Memory" target="_blank" rel="noopener noreferrer">웹어셈블리의 메모리 다루기</a>에 대한 우리의 문서를 확인해보기 바란다.</p>
<h2>.wasm 파일의 구조</h2>
<p>만약 당신이 상위 레벨 언어로 코드를 작성한 후에 웹어셈블리로 컴파일한다면, 웹어셈블리 모듈이 어떻게 구성되는지에 대해서는 알 필요가 없다. 하지만 기본을 이해하는 것은 도움이 될 것이다.</p>
<p>아직 읽어보지 않았다면, <a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/">어셈블리에 대한 글</a>을 읽어보길 권한다. (이 시리즈의 3부)<br />
다음은 웹어셈블리로 변환할 C 함수이다.</p>
<pre class="brush: cpp; gutter: false; title: ; notranslate">
int add42(int num) {
  return num + 42;
}
</pre>
<p><a href="http://mbebenita.github.io/WasmExplorer/" target="_blank" rel="noopener noreferrer">WASM Explorer</a>를 이용하면 이 함수를 컴파일 할 수 있다.</p>
<p>.wasm 파일을 열어보면 (만약 에디터가 지원한다면), 다음과 같은 것을 보게 될 것이다.</p>
<pre>00 61 73 6D 0D 00 00 00 01 86 80 80 80 00 01 60
01 7F 01 7F 03 82 80 80 80 00 01 00 04 84 80 80
80 00 01 70 00 00 05 83 80 80 80 00 01 00 01 06
81 80 80 80 00 00 07 96 80 80 80 00 02 06 6D 65
6D 6F 72 79 02 00 09 5F 5A 35 61 64 64 34 32 69
00 00 0A 8D 80 80 80 00 01 87 80 80 80 00 00 20
00 41 2A 6A 0B</pre>
<p>이것은 모듈의 “바이너리” 표현 방식이다. 따옴표로 강조한 이유는 보통은 16진법으로 표시되기 때문인데, 이는 쉽게 바이너리 형태나 인간이 읽을 수 있는 형태로 변환이 가능하다.</p>
<p>예를 들어 <strong>num + 42</strong> 는 다음과 같을 것이다.</p>
<p><img data-attachment-id="331" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%eb%aa%a8%eb%93%88%ec%9d%98-%ec%83%9d%ec%84%b1%ea%b3%bc-%eb%8f%99%ec%9e%91/04-06-hex_binary_asm01-500x254/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-06-hex_binary_asm01-500x254.png?w=1100" data-orig-size="500,254" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="04-06-hex_binary_asm01-500&#215;254" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-06-hex_binary_asm01-500x254.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-06-hex_binary_asm01-500x254.png?w=1100?w=500" class=" size-full wp-image-331 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/04-06-hex_binary_asm01-500x254.png?w=1100" alt="04-06-hex_binary_asm01-500x254.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/04-06-hex_binary_asm01-500x254.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/04-06-hex_binary_asm01-500x254.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/04-06-hex_binary_asm01-500x254.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<h2>코드의 작동 방식 : 스택 기계</h2>
<p>궁금해할 것 같아서 설명하자면, 이들 명령들은 아래와 같이 동작할 것이다.</p>
<p><img data-attachment-id="334" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%eb%aa%a8%eb%93%88%ec%9d%98-%ec%83%9d%ec%84%b1%ea%b3%bc-%eb%8f%99%ec%9e%91/04-07-hex_binary_asm02-500x175/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-07-hex_binary_asm02-500x175.png?w=1100" data-orig-size="500,175" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="04-07-hex_binary_asm02-500&#215;175" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-07-hex_binary_asm02-500x175.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/04-07-hex_binary_asm02-500x175.png?w=1100?w=500" class=" size-full wp-image-334 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/04-07-hex_binary_asm02-500x175.png?w=1100" alt="04-07-hex_binary_asm02-500x175.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/04-07-hex_binary_asm02-500x175.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/04-07-hex_binary_asm02-500x175.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/04-07-hex_binary_asm02-500x175.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p><em>그림 번역 :</em><br />
<em>get_local 0 -&gt; 첫번째 파라미터의 값을 읽어서 스택에 추가한다</em><br />
<em>i32.const 42 -&gt; 상수값을 스택에 추가한다</em><br />
<em>i32.add -&gt; 스택의 최상위에 있는 두 값을 더해서 결과값을 스택에 추가한다</em></p>
<p><strong>add</strong> 연산이 어디에서 값을 가져와야 하는지에 대해서는 전혀 언급이 없는 것을 눈치챘을지도 모르겠다. 그 이유는 웹어셈블리가 스택 기계라고 불리는 것의 일종이기 때문이다. 이는 한 연산이 실행되기 전에 그 연산이 필요로 하는 모든 값들이 스택에 쌓여 있다는 의미이다.</p>
<p><strong>add</strong>와 같은 연산들은 스스로 몇 개의 값이 필요한지를 알고 있다. <strong>add</strong>는 두 개를 필요로 하기 때문에, 스택의 최상단에서 두 개의 값을 가져올 것이다. 이는 <strong>add</strong> 명령이 출처나 대상 레지스터를 지정할 필요가 없으므로 short 형(단일 바이트)이 될 수 있다는 것을 의미한다. 이는 .wasm 파일의 사이즈를 줄여주는데, 이로 인해 다운로드에 걸리는 시간도 줄어들게 된다.</p>
<p>비록 웹어셈블리가 스택 기계의 특징을 갖고있긴 하지만, 물리적 기계에서도 똑같이 동작하는 것은 아니다. 브라우저가 웹어셈블리를 자신이 구동되고 있는 기계를 위한 기계 코드로 번역할 때는 레지스터를 사용할 것이다. 하지만 웹어셈블리 코드는 레지스터를 명시하지 않기 때문에, 브라우저로 하여금 해당 기계에 맞는 최선의 레지스터 할당을 할 수 있도록 유연성을 제공해 준다.</p>
<h2>모듈의 섹션</h2>
<p>.wasm 파일에는 <strong>add42</strong> 함수 자신 이외에도 다른 부분이 존재한다. 이들을 섹션이라고 한다. 어떤 섹션들은 어떤 모듈에 필수 요건이며, 어떤 섹션들은 선택 요건이다.</p>
<p>필수 요건 :</p>
<ol>
<li><strong>타입</strong>. 이 모듈에 정의된 함수들이나 임포트한 함수들을 위한 함수 서명(signatures)을 포함한다.</li>
<li><strong>함수</strong>. 이 모듈에 정의된 각 함수에 대한 인덱스를 제공한다.</li>
<li><strong>코드</strong>. 이 모듈의 각 함수에 대한 실제 함수 본문.</li>
</ol>
<p>선택 요건 :</p>
<ol>
<li><strong>익스포트(export)</strong>. 다른 어셈블리 모듈이나 자바스크립트에서 사용가능한 함수, 메모리, 테이블, 전역 등을 생성한다.</li>
<li><strong>임포트(import)</strong>. 다른 어셈블리 모듈이나 자바스크립트에서 임포트한 함수, 메모리, 테이블, 전역 등을 지정한다.</li>
<li><strong>시작</strong>. 웹어셈블리 모듈이 로드되었을 때 자동으로 실행될 함수 (기본적으로 메인 함수와 유사함)</li>
<li><strong>전역</strong>. 모듈을 위한 전역 변수들을 선언한다.</li>
<li><strong>메모리</strong>. 이 모듈이 사용할 메모리를 정의한다.</li>
<li><strong>테이블</strong>. 자바스크립트 객체와 같이 웹어셈블리 모듈 외부에 있는 값들을 맵핑할 수 있도록 해 준다. 이는 간접적으로 함수를 호출할 수 있도록 할 때 특히 유용하다.</li>
<li><strong>데이터</strong>. 임포트된 메모리나 로컬 메모리를 초기화한다.</li>
<li><strong>요소</strong>. 임포트된 테이블이나 로컬 테이블을 초기화한다.</li>
</ol>
<p>섹션에 대한 추가적인 설명을 원한다면 <a href="https://rsms.me/wasm-intro" target="_blank" rel="noopener noreferrer">이들 섹션들이 어떻게 동작하는지에 대한 설명</a>을 참고하길 바란다.</p>
<h2>다음 주제</h2>
<p>이제 웹어셈블을 어떻게 사용하는지 알았으니, <a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%8a%94-%ec%99%9c-%eb%b9%a0%eb%a5%bc%ea%b9%8c/">왜 어셈블리가 빠른지</a>에 대해 알아보자.</p>
<h2><a href="http://code-cartoons.com/">Lin Clark</a> 에 대해</h2>
<p>Lin은 모질라 개발자 관계 팀의 엔지니어이다. 그녀는 자바스크립트, 웹어셈블리, Rust, Servo 등을 끄적거리며, 코드 카툰을 그린다.</p>
<p>코드카툰 : <a href="http://code-cartoons.com/" target="_blank" rel="noopener noreferrer">http://code-cartoons.com/<br />
</a>트위터 : <a href="http://twitter.com/linclark" target="_blank" rel="noopener noreferrer">@linclark</a></p>
]]></content:encoded>
							<wfw:commentRss>https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%eb%aa%a8%eb%93%88%ec%9d%98-%ec%83%9d%ec%84%b1%ea%b3%bc-%eb%8f%99%ec%9e%91/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/530c8460562d2041af30cba4cf26b3d0?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">gaekkr</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/04-01-langs09-500x306.png" medium="image">
			<media:title type="html">04-01-langs09-500x306.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/04-02-langs08-500x326.png" medium="image">
			<media:title type="html">04-02-langs08-500x326.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/04-03-toolchain07-500x411.png" medium="image">
			<media:title type="html">04-03-toolchain07-500x411.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/04-04-memory04-500x93.png" medium="image">
			<media:title type="html">04-04-memory04-500x93.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/04-05-memory12-500x400.png" medium="image">
			<media:title type="html">04-05-memory12-500x400.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/04-06-hex_binary_asm01-500x254.png" medium="image">
			<media:title type="html">04-06-hex_binary_asm01-500x254.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/04-07-hex_binary_asm02-500x175.png" medium="image">
			<media:title type="html">04-07-hex_binary_asm02-500x175.png</media:title>
		</media:content>
	</item>
		<item>
		<title>[번역] 어셈블리 집중 코스</title>
		<link>https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/</link>
				<comments>https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/#comments</comments>
				<pubDate>Tue, 06 Jun 2017 10:44:39 +0000</pubDate>
		<dc:creator><![CDATA[동우]]></dc:creator>
				<category><![CDATA[자바스크립트]]></category>
		<category><![CDATA[번역]]></category>
		<category><![CDATA[브라우저]]></category>
		<category><![CDATA[웹]]></category>
		<category><![CDATA[웹어셈블리]]></category>

		<guid isPermaLink="false">http://dongwoo.blog/?p=248</guid>
				<description><![CDATA[웹어셈블리가 어떻게 작동하는지를 이해하기 위해서는, 어셈블리가 무엇이고 컴파일러가 어떻게 그것을 생성해내는지를 이해하는 것이 도움이 될 것이다.

JIT에 대해 설명한 글에서 나는 기계와 의사소통을 하는 것이 마치 외계인과 의사소통을 하는 것과 비슷하다고 설명했다.

03-01-alien03-500x286.png

이제 나는 그 외계인의 뇌가 어떻게 작동하는지를 - 즉, 기계의 뇌가 들어오는 정보를 해석하고 이해하는지 - 를 살펴보도록 하겠다.]]></description>
								<content:encoded><![CDATA[<p><em>이 글은 모질라 Hacks의 웹어셈블리 시리즈 중 세 번째 글인 <a href="https://hacks.mozilla.org/2017/02/a-crash-course-in-assembly/" target="_blank" rel="noopener noreferrer">A crash course in assembly</a>의 번역글이다. 전 시리즈에 걸쳐 웹어셈블리 뿐만 아니라 JIT나 어셈블리 등에 대해서도 체계적으로 잘 설명하고 있고, 카툰까지 곁들여서 이해하기도 쉽다.</em></p>
<p><em>총 6부로 되어 있으며, 원작자의 허가를 얻어 전체 시리즈를 모두 번역했으니 처음부터 차례대로 모두 읽어보길 권한다.</em></p>
<ol>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%b9%b4%ed%88%b0%ec%9c%bc%eb%a1%9c-%ec%86%8c%ea%b0%9c%ed%95%98%eb%8a%94-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac/">카툰으로 소개하는 웹어셈블리</a></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%a0%80%ec%8a%a4%ed%8a%b8-%ec%9d%b8-%ed%83%80%ec%9e%84jit-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/">저스트-인-타임(JIT) 컴파일러 집중 코스</a></li>
<li><strong>어셈블리 집중 코스 (현재글)</strong></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%eb%aa%a8%eb%93%88%ec%9d%98-%ec%83%9d%ec%84%b1%ea%b3%bc-%eb%8f%99%ec%9e%91/">웹어셈블리 모듈의 생성과 동작</a></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%8a%94-%ec%99%9c-%eb%b9%a0%eb%a5%bc%ea%b9%8c/">웹어셈블리는 왜 빠를까?</a></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%ec%9d%98-%ed%98%84%ec%9e%ac-%ec%9c%84%ec%b9%98%ec%99%80-%eb%af%b8%eb%9e%98/">웹어셈블리의 현재 위치와 미래</a></li>
</ol>
<hr />
<p>&nbsp;</p>
<p>웹어셈블리가 어떻게 작동하는지를 이해하기 위해서는, 어셈블리가 무엇이고 컴파일러가 어떻게 그것을 생성해내는지를 이해하는 것이 도움이 될 것이다.</p>
<p><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%a0%80%ec%8a%a4%ed%8a%b8-%ec%9d%b8-%ed%83%80%ec%9e%84jit-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/?iframe=true&amp;theme_preview=true">JIT에 대해 설명한 글</a>에서 나는 기계와 의사소통을 하는 것이 마치 외계인과 의사소통을 하는 것과 비슷하다고 설명했다.</p>
<p><img data-attachment-id="253" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/03-01-alien03-500x286/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-01-alien03-500x286.png?w=1100" data-orig-size="500,286" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="03-01-alien03-500&#215;286" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-01-alien03-500x286.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-01-alien03-500x286.png?w=1100?w=500" class=" size-full wp-image-253 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/03-01-alien03-500x286.png?w=1100" alt="03-01-alien03-500x286.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/03-01-alien03-500x286.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/03-01-alien03-500x286.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/03-01-alien03-500x286.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p>이제 나는 그 외계인의 뇌가 어떻게 작동하는지를 &#8211; 즉, 기계의 뇌가 들어오는 정보를 해석하고 이해하는지 &#8211; 를 살펴보도록 하겠다.</p>
<p>기계의 뇌에는 생각을 위해 존재하는 부분이 있으며 더하기, 빼기 혹은 논리 연산 등을 수행한다. 또한 그와 가까운 곳에 단기 기억을 제공하는 부분과 장기 기억을 제공하는 부분도 있다.</p>
<p>이들 각각의 부분은 이름을 갖는다.</p>
<ul>
<li>생각을 담당하는 부분은 산술 논리 장치 (ALU : Arithmetic Logic Unit)이다.</li>
<li>단기 기억은 레지스터에 의해 제공된다.</li>
<li>장기 기억은 랜덤 억세스 메모리 (RAM : Random Access Memory)이다.</li>
</ul>
<p><img data-attachment-id="256" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/03-02-computer_architecture09-500x302/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-02-computer_architecture09-500x302.png?w=1100" data-orig-size="500,302" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="03-02-computer_architecture09-500&#215;302" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-02-computer_architecture09-500x302.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-02-computer_architecture09-500x302.png?w=1100?w=500" class=" size-full wp-image-256 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/03-02-computer_architecture09-500x302.png?w=1100" alt="03-02-computer_architecture09-500x302.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/03-02-computer_architecture09-500x302.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/03-02-computer_architecture09-500x302.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/03-02-computer_architecture09-500x302.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p>기계 코드 내에서의 문장들은 명령(instruction)이라고 불린다.</p>
<p>이러한 명령들 중 하나가 뇌 속으로 들어오면 어떤 일이 벌어질까? 그 명령은 각기 다른 의미를 가진 부분으로 나누어진다.</p>
<p>이 명령이 나누어지는 방식은 뇌의 회로에 의해 특정지어진다.</p>
<p>예를 들어 이런 식으로 구성된 회로를 갖는 뇌는 항상 처음 여섯 비트를 ALU 로 전송할 것이다. ALU는 1과 0의 위치를 기반으로, 두 값을 함께 더해야 한다는 것을 알아낸다.</p>
<p>이 조각은 “opcode” 혹은 연산 코드(operation code)라고 불리는데, 왜냐하면 이것이 ALU에게 어떤 연산을 수행할지를 말해주기 때문이다.</p>
<p><img data-attachment-id="258" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/03-03-computer_architecture12-500x354/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-03-computer_architecture12-500x354.png?w=1100" data-orig-size="500,354" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="03-03-computer_architecture12-500&#215;354" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-03-computer_architecture12-500x354.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-03-computer_architecture12-500x354.png?w=1100?w=500" class=" size-full wp-image-258 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/03-03-computer_architecture12-500x354.png?w=1100" alt="03-03-computer_architecture12-500x354.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/03-03-computer_architecture12-500x354.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/03-03-computer_architecture12-500x354.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/03-03-computer_architecture12-500x354.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p>그 후에 뇌는 덧셈을 할 두 개의 수가 무엇인지 알아내기 위해 세 개의 비트로 이루어진 다음 두 조각을 읽어온다. 이들은 레지스터의 주소일 것이다.</p>
<p><img data-attachment-id="261" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/03-04-computer_architecture17-500x352/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-04-computer_architecture17-500x352.png?w=1100" data-orig-size="500,352" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="03-04-computer_architecture17-500&#215;352" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-04-computer_architecture17-500x352.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-04-computer_architecture17-500x352.png?w=1100?w=500" class=" size-full wp-image-261 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/03-04-computer_architecture17-500x352.png?w=1100" alt="03-04-computer_architecture17-500x352.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/03-04-computer_architecture17-500x352.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/03-04-computer_architecture17-500x352.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/03-04-computer_architecture17-500x352.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p>기계 코드 위에 있는 주석을 잘 살펴보자. 이를 통해 우리 인간이 기계 코드를 좀더 쉽게 이해할 수 있는데, 이것이 바로 어셈블리이다. 상징적(symbolic) 기계 코드라고도 불린다. 이것이 인간이 기계의 코드를 이해할 수 있는 방법이다.</p>
<p>여기서 어셈블리와 기계 코드 사이에는 꽤 직접적인 관계가 있는 것을 볼 수 있을 것이다. 이 때문에 여러 종류의 기계 아키텍쳐에 맞는 각기 다른 어셈블리가 존재한다. 다른 아키텍쳐의 머신에게는 그 머신에게만 통용되는 별도의 어셈블리가 필요하다.</p>
<p>즉, 번역의 목표 대상이 하나만 있는 것이 아니다. 단순히 하나의 기계 코드가 있는 것이 아니다. 아주 다양한 종류의 기계 코드가 있다. 사람들이 각자 다른 언어로 이야기하듯이, 기계들도 각자 다른 언어로 이야기한다.</p>
<p>인간의 언어를 외계인에게 번역한다면, 아마 영어나 러시아어 혹은 중국어를 외계인 언어 A 혹은 외계인 언어 B로 번역하게 될 것이다. 프로그래밍 용어로 말하자면 C, C++, Rust 등을 x86 이나 ARM으로 번역하는 것이 될 것이다.</p>
<p>이들 상위 레벨 프로그래밍 언어들 중의 하나를 어셈블리 언어들 중 하나로 번역한다고 해 보자. 가능한 한 가지 방법은 각 언어에서 각 어셈블리로 번역할 수 있는 각기 다른 모든 번역기를 만드는 것이다.</p>
<p><img data-attachment-id="264" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/03-05-langs05-500x308/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-05-langs05-500x308.png?w=1100" data-orig-size="500,308" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="03-05-langs05-500&#215;308" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-05-langs05-500x308.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-05-langs05-500x308.png?w=1100?w=500" class=" size-full wp-image-264 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/03-05-langs05-500x308.png?w=1100" alt="03-05-langs05-500x308.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/03-05-langs05-500x308.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/03-05-langs05-500x308.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/03-05-langs05-500x308.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p>이 방법은 꽤나 비효율적이다. 이를 해결하기 위해 대부분의 컴파일러는 둘 사이에 최소한 하나의 레이어를 둔다. 컴파일러는 상위 레벨 프로그래밍 언어를 읽어서, 너무 상위 레벨도 아니면서 기계 코드의 레벨에서 동작하지도 않는 무언가로 번역한다. 이것을 중간 표현 형식 (IR: Intermediate representation) 이라고 한다.</p>
<p><img data-attachment-id="266" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/03-06-langs06-500x317/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-06-langs06-500x317.png?w=1100" data-orig-size="500,317" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="03-06-langs06-500&#215;317" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-06-langs06-500x317.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-06-langs06-500x317.png?w=1100?w=500" class=" size-full wp-image-266 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/03-06-langs06-500x317.png?w=1100" alt="03-06-langs06-500x317.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/03-06-langs06-500x317.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/03-06-langs06-500x317.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/03-06-langs06-500x317.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p>이 말은 곧 컴파일러가 이들 상위 레벨 언어들 중 어떤 것이든 읽어서 단일 IR 언어로 번역할 수 있다는 의미이다. 여기서부터 컴파일러의 다른 부분이 이 IR을 읽어서 특정 대상의 아키텍쳐에 맞게 컴파일할 수 있게 된다.</p>
<p>컴파일러의 프론트엔드는 상위 레벨 프로그래밍 언어를 IR로 번역한다. 컴파일러의 백엔드는 IR을 대상 아키텍쳐의 어셈블리 코드로 번역한다.</p>
<p><img data-attachment-id="269" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/03-07-langs09-500x306/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-07-langs09-500x306.png?w=1100" data-orig-size="500,306" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="03-07-langs09-500&#215;306" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-07-langs09-500x306.png?w=1100?w=300" data-large-file="https://dongwoodotblog.files.wordpress.com/2017/06/03-07-langs09-500x306.png?w=1100?w=500" class=" size-full wp-image-269 aligncenter" src="https://dongwoodotblog.files.wordpress.com/2017/06/03-07-langs09-500x306.png?w=1100" alt="03-07-langs09-500x306.png" srcset="https://dongwoodotblog.files.wordpress.com/2017/06/03-07-langs09-500x306.png 500w, https://dongwoodotblog.files.wordpress.com/2017/06/03-07-langs09-500x306.png?w=150 150w, https://dongwoodotblog.files.wordpress.com/2017/06/03-07-langs09-500x306.png?w=300 300w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<h2>결론</h2>
<p>지금까지 어셈블리가 무엇이고, 컴파일러가 상위 레벨 프로그래밍 언어를 어떻게 어셈블리로 번역하는지를 살펴보았다. <a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%eb%aa%a8%eb%93%88%ec%9d%98-%ec%83%9d%ec%84%b1%ea%b3%bc-%eb%8f%99%ec%9e%91/">다음 글</a>에서는 웹어셈블리가 여기에 어떻게 적용되는지를 살펴보겠다.</p>
<h2><a href="http://code-cartoons.com/">Lin Clark</a> 에 대해</h2>
<p>Lin은 모질라 개발자 관계 팀의 엔지니어이다. 그녀는 자바스크립트, 웹어셈블리, Rust, Servo 등을 끄적거리며, 코드 카툰을 그린다.</p>
<p>코드카툰 : <a href="http://code-cartoons.com/" target="_blank" rel="noopener noreferrer">http://code-cartoons.com/<br />
</a>트위터 : <a href="http://twitter.com/linclark" target="_blank" rel="noopener noreferrer">@linclark</a></p>
]]></content:encoded>
							<wfw:commentRss>https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/530c8460562d2041af30cba4cf26b3d0?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">gaekkr</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/03-01-alien03-500x286.png" medium="image">
			<media:title type="html">03-01-alien03-500x286.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/03-02-computer_architecture09-500x302.png" medium="image">
			<media:title type="html">03-02-computer_architecture09-500x302.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/03-03-computer_architecture12-500x354.png" medium="image">
			<media:title type="html">03-03-computer_architecture12-500x354.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/03-04-computer_architecture17-500x352.png" medium="image">
			<media:title type="html">03-04-computer_architecture17-500x352.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/03-05-langs05-500x308.png" medium="image">
			<media:title type="html">03-05-langs05-500x308.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/03-06-langs06-500x317.png" medium="image">
			<media:title type="html">03-06-langs06-500x317.png</media:title>
		</media:content>

		<media:content url="https://dongwoodotblog.files.wordpress.com/2017/06/03-07-langs09-500x306.png" medium="image">
			<media:title type="html">03-07-langs09-500x306.png</media:title>
		</media:content>
	</item>
		<item>
		<title>[번역] 저스트-인-타임(JIT) 컴파일러 집중 코스</title>
		<link>https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%a0%80%ec%8a%a4%ed%8a%b8-%ec%9d%b8-%ed%83%80%ec%9e%84jit-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/</link>
				<comments>https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%a0%80%ec%8a%a4%ed%8a%b8-%ec%9d%b8-%ed%83%80%ec%9e%84jit-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/#comments</comments>
				<pubDate>Tue, 06 Jun 2017 09:16:48 +0000</pubDate>
		<dc:creator><![CDATA[동우]]></dc:creator>
				<category><![CDATA[자바스크립트]]></category>
		<category><![CDATA[번역]]></category>
		<category><![CDATA[브라우저]]></category>
		<category><![CDATA[웹]]></category>
		<category><![CDATA[웹어셈블리]]></category>

		<guid isPermaLink="false">http://dongwoo.blog/?p=174</guid>
				<description><![CDATA[자바스크립트는 태생이 느렸지만, JIT라고 불리는 무언가 덕분에 빨라지게 되었다. 그런데 JIT는 어떻게 동작하는걸까?

자바스크립트는 브라우저에서 어떻게 실행될까

개발자로서 자바스크립트를 페이지에 추가하면, 당신은 목표와 문제를 갖게 된다.

목표 : 당신은 컴퓨터에게 무엇을 할지 말하고 싶다.

문제 : 당신과 컴퓨터는 다른 언어를 사용해서 이야기한다.

당신은 인간의 언어를 사용하고, 컴퓨터는 기계의 언어를 사용한다. 비록 당신이 자바스크립트나 다른 상위레벨 프로그래밍 언어들이 인간의 언어가 아니라고 생각할 지라도, 이들은 실제로 인간의 언어이다. 이들 언어는 기계가 아닌 인간이 이해하기 위해 디자인되었다.]]></description>
								<content:encoded><![CDATA[<p><em>이 글은 모질라 Hacks의 웹어셈블리 시리즈 중 두 번째 글인 <a href="https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/" target="_blank" rel="noopener noreferrer">A crash course in just-in-time (JIT) compilers</a>의 번역글이다. 전 시리즈에 걸쳐 웹어셈블리 뿐만 아니라 JIT나 어셈블리 등에 대해서도 체계적으로 잘 설명하고 있고, 카툰까지 곁들여서 이해하기도 쉽다.</em></p>
<p><em>총 6부로 되어 있으며, 원작자의 허가를 얻어 전체 시리즈를 모두 번역했으니 처음부터 차례대로 모두 읽어보길 권한다.</em></p>
<ol>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%b9%b4%ed%88%b0%ec%9c%bc%eb%a1%9c-%ec%86%8c%ea%b0%9c%ed%95%98%eb%8a%94-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac/">카툰으로 소개하는 웹어셈블리</a></li>
<li><strong>저스트-인-타임(JIT) 컴파일러 집중 코스 (현재글)</strong></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/">어셈블리 집중 코스</a></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%eb%aa%a8%eb%93%88%ec%9d%98-%ec%83%9d%ec%84%b1%ea%b3%bc-%eb%8f%99%ec%9e%91/">웹어셈블리 모듈의 생성과 동작</a></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%eb%8a%94-%ec%99%9c-%eb%b9%a0%eb%a5%bc%ea%b9%8c/">웹어셈블리는 왜 빠를까?</a></li>
<li><a href="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%9b%b9%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%ec%9d%98-%ed%98%84%ec%9e%ac-%ec%9c%84%ec%b9%98%ec%99%80-%eb%af%b8%eb%9e%98/">웹어셈블리의 현재 위치와 미래</a></li>
</ol>
<div>
<hr />
</div>
<p>&nbsp;</p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">자바스크립트는 태생이 느렸지만, JIT라고 불리는 무언가 덕분에 빨라지게 되었다. 그런데 JIT는 어떻게 동작하는걸까?</span></p>
<div>
<h2><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">자바스크립트는 브라우저에서 어떻게 실행될까</span></h2>
</div>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">개발자로서 자바스크립트를 페이지에 추가하면, 당신은 목표와 문제를 갖게 된다.</span></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">목표 : 당신은 컴퓨터에게 무엇을 할지 말하고 싶다.</span></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">문제 : 당신과 컴퓨터는 다른 언어를 사용해서 이야기한다.</span></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">당신은 인간의 언어를 사용하고, 컴퓨터는 기계의 언어를 사용한다. 비록 당신이 자바스크립트나 다른 상위레벨 프로그래밍 언어들이 인간의 언어가 아니라고 생각할 지라도, 이들은 실제로 인간의 언어이다. 이들 언어는 기계가 아닌 인간이 이해하기 위해 디자인되었다.</span></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">그러므로 자바스크립트 엔진의 임무는 당신이 사용하는 인간 언어를 기계가 이해할 수 있는 무언가로 변경시키는 것이다.</span></p>
<p><span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn">나는 이 상황이 영화</span> <span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z9z84zl5y7z70zz65z9yz66zsz72zx5z77z5z80zmbmz90zz78zjr6z88zz70zz76zz122zn"><a href="https://en.wikipedia.org/wiki/Arrival_(film)" target="_blank" rel="noopener noreferrer">Arrival</a> 에서 인간과 외계인이 서로 대화하려고 하는 장면과 비슷하다고 생각한다.</span></p>
<p><img data-attachment-id="181" data-permalink="https://dongwoo.blog/2017/06/06/%eb%b2%88%ec%97%ad-%ec%a0%80%ec%8a%a4%ed%8a%b8-%ec%9d%b8-%ed%83%80%ec%9e%84jit-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%ec%a7%91%ec%a4%91-%ec%bd%94%ec%8a%a4/02-01-alien03-500x286/" data-orig-file="https://dongwoodotblog.files.wordpress.com/2017/06/02-01-alien03-500x286.png?w=1100" data-orig-size="500,286" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="02-01-alien03-500&#215;286" data-image-description="" data-medium-file="https://dongwoodotblog.files.wordpress.com/2017/06/02-01-alien03-500x286.png?w=1100?w=300" data-large-file="https: