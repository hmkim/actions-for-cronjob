<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Jiwon Bae - Medium]]></title>
        <description><![CDATA[Jiwon Bae’s tech blog - Medium]]></description>
        <link>https://medium.com/jiwon-bae?source=rss----1d61fa697319---4</link>
        <image>
            <url>https://cdn-images-1.medium.com/proxy/1*TGH72Nnw24QL3iV9IOm4VA.png</url>
            <title>Jiwon Bae - Medium</title>
            <link>https://medium.com/jiwon-bae?source=rss----1d61fa697319---4</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 18:12:45 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/jiwon-bae" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[테스트 코드에 대한 나의 생각]]></title>
            <link>https://medium.com/jiwon-bae/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%9C-%EB%82%98%EC%9D%98-%EC%83%9D%EA%B0%81-c9b1ee47eeae?source=rss----1d61fa697319---4</link>
            <guid isPermaLink="false">https://medium.com/p/c9b1ee47eeae</guid>
            <dc:creator><![CDATA[Jiwon Bae]]></dc:creator>
            <pubDate>Wed, 30 May 2018 06:07:58 GMT</pubDate>
            <atom:updated>2018-05-31T06:39:24.362Z</atom:updated>
            <content:encoded><![CDATA[<p>단위 테스트를 하는 것이 왜 중요할까?</p><p>나는 왜 지금까지 단위테스트 기반으로 개발을 했고, 그렇게 해서 어떤 이점이 있었는지 이번 기회에 정리해보고자 한다.</p><h3>내가 경험 했던 테스트 코드의 장점</h3><h4>개발 생산성 향상됨을 경험했다.</h4><p>하나의 기능을 담당하는 메소드를 작성하고 그 기능이 제대로 동작 하는지 테스트코드를 통해서 굉장히 빠르게 확인할 수 있었기 때문에 테스트가 통과하면 해당기능이 제대로 동작한다는 확신을 가지고 다음 기능을 구현할 수 있었고, 테스트가 실패하게 되면 테스트코드에 브레이크 포인트를 걸어 디버깅을 쉽게 할 수 있었다.</p><p>또한 깔끔한 코드 그리고 객체 지향적인 코드를 짜는것에 집중을 했었기 때문에 리팩토링을 자주 했었는데 그 때마다 테스트코드가 있어서 코드를 변경한 후에 테스트코드를 실행시켜 리팩토링을 거친 코드가 제대로 동작하는지를 확인할 수 있어서 결과적으로는 개발 생산성을 높이는 데에 도움을 줬다고 할 수 있다.</p><h4>테스트 코드를 짜려고 노력하다보니 자연스럽게 프로덕션 코드를 객체지향적인 코드로 짤 수 있었다.</h4><p>테스트 코드를 쉽게 작성하기 위해서 메소드가 한 가지 기능만을 담당하도록 하도록 하다보니(코드의 모듈화) 객체지향 설계 원칙 중 <strong>단일 책임 원칙</strong>을 자연적으로 지킬 수 있었다.</p><p>테스트 코드를 짜도 수정해야하는 일이 많은데 오히려 개발 생산성이 떨어지지 않느냐고 반문할 수도 있겠다.</p><p>내 경험으로는 테스트코드를 수정해야 하는 상황은 대부분 프로젝트 규모가 커지고 기능이 확장되어 기존의 코드들을 그에 맞게 리팩토링 할 때 테스트 코드도 그에 맞춰서 리팩토링이 필요한 경우였다. 나는 이런 경우 비용을 들여서라도 필수적으로 테스트코드를 수정해야 한다고 생각한다.</p><p>왜냐하면 기능을 확장할 때는 기존에 잘 동작하던 기능들이 여전히 잘 동작하는지에 대한 확신이 있어야 하고 이를 위해서 테스트 코드 수정은 필수라고 생각한다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c9b1ee47eeae" width="1" height="1"><hr><p><a href="https://medium.com/jiwon-bae/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%9C-%EB%82%98%EC%9D%98-%EC%83%9D%EA%B0%81-c9b1ee47eeae">테스트 코드에 대한 나의 생각</a> was originally published in <a href="https://medium.com/jiwon-bae">Jiwon Bae</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[왜 객체지향적으로 짜는 것이 중요할까?]]></title>
            <link>https://medium.com/jiwon-bae/%EC%99%9C-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%A7%9C%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%A4%91%EC%9A%94%ED%95%A0%EA%B9%8C-d027780d081f?source=rss----1d61fa697319---4</link>
            <guid isPermaLink="false">https://medium.com/p/d027780d081f</guid>
            <dc:creator><![CDATA[Jiwon Bae]]></dc:creator>
            <pubDate>Wed, 30 May 2018 05:34:55 GMT</pubDate>
            <atom:updated>2018-05-30T05:36:33.449Z</atom:updated>
            <content:encoded><![CDATA[<pre>&#39;스프링 입문을 위한 자바 객체지향의 원리와 이해&#39; 를 읽고 정리한 내용입니다.</pre><p>나는 개발경험이 많지않기 때문에 어떤 소프트웨어가 잘 설계된 소프트웨어인지 아직 정확하게 모르겠다.</p><p>그러나 여러 글과 책을 통해서 얻은 결과로 좋은 소프트웨어 설계를 위해서는</p><blockquote>‘결합도(coupling)을 낮추고 응집도(cohesion)을 높이는 것’</blockquote><p>이 중요하다는 것을 알게 되었다.</p><blockquote>여기서 결합도(coupling)를 낮춘다는 말은 <strong>클래스간의 상호 의존성을 낮춘다는 말</strong>인데, 이를 낮춤으로써 객체를 재사용하기가 쉬워지고, 코드를 수정, 유지보수하기가 쉬워진다.</blockquote><blockquote>응집도(cohesion)을 높인다는 말은 <strong>하나의 클래스안에 관련있는 메소드들을 몰아 넣어서</strong> 해당 클래스가 하나의 책임에 집중하고 독립성을 높일 수 있도록 한다는 말이다. 이렇게 함으로써 역시 결합도를 낮추는 것과 같은 효과로 코드의 재사용, 수정, 유지보수의 용이성을 경험할 수 있다.</blockquote><p>이 원칙에 기반해서 객체지향 프로그래밍 분야에서는 SOLID라는 객체 지향 설계 원칙을 발표했는데 이것을 정리해보고자 한다.</p><h3>SOLID</h3><p>SOLID 원칙은 다음 5가지 원칙으로 이루어져 있다.</p><pre>1. SRP(Single Responsibility Principle): 단일 책임 원칙</pre><pre>2. OCP(Open Closed Principle): 개방 폐쇄 원칙</pre><pre>3. LSP(Liskov Substitution Principle): 리스코프 치환 원칙</pre><pre>4. ISP(Interface Segregation Principle): 인터페이스 분리 원칙</pre><pre>5. DIP(Dependency Inversion Principle): 의존 역전 원칙</pre><p>하나씩 소개해보려고 한다.</p><h4><strong>SRP(Single Responsibility Principle): 단일 책임 원칙</strong></h4><pre>하나의 속성, 메서드, 패키지, 모듈, 컴포넌트, 프레임워크는 <strong>하나의 역할과 책임만을 담당</strong>해야 한다.</pre><p>이것이 단일 책임 원칙이다.</p><p>단일 책임 원칙은 데이터베이스에서 정규화의 목적에도 녹아있다. 하나의 속성이 하나의 값만 가지도록 해야 한다는 것. 이것이 제 1 정규화의 규칙이다.</p><p>구체적으로 코드를 짤때 SRP 를 지키지 않는 경우에 나타나는 현상으로는 메소드 내에 if 문이 등장하는 것이다. 이는 해당 메소드가 두 가지 역할을 담당하고 있기 때문에 발생하는 것으로 해결책은 추상 클래스를 새로 생성하고 해당 메소드를 추상 메소드로 만들어 추상클래스를 상속하는 두 클래스에서 추상 메소드를 다르게 구현하면 if문을 않게 되고 <strong>해당 메소드는 단 한가지의 역할만 담당하게 된다.</strong></p><h4>OCP(Open Closed Principle): 개방 폐쇄 원칙</h4><p>개방 폐쇄 원칙은 다음과 같다.</p><pre>자신의 <strong>확장에는 열려 있고</strong>, 주변의 <strong>변화에 대해서는 닫혀 </strong>있어야 한다.</pre><p>나는 이것을 이렇게도 해석했다.</p><p>‘내가 나를 확장하는 것은 괜찮지만 남이 나를 변화시키면 안된다.’</p><p>OCP는 내가 자바 백엔드 개발을 하면서 수없이 접해왔던 데이터베이스에 접근하여 SQL문을 실행하기 위한 자바 라이브러리인 JDBC에 적용이 되어있다.</p><p>JDBC 라이브러리는 인터페이스로 존재해 자바 애플리케이션은 그 인터페이스를 사용하고 JDBC 인터페이스는 각각 데이터베이스 종류에 따라 JDBC 드라이버 구현 클래스로 구현되어있기 때문에 JDBC 를 사용하는 클라이언트 입장인 자바 애플리케이션은 데이터베이스 종류에 아무런 영향을 받지 않는다.</p><p>이를 구조도로 나타내면 다음과 같다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/792/1*4umG4dZNG8uYYgVFBKaksA.png" /></figure><p>이 구조를 OCP 원리와 연관해 표현한다면,</p><pre>JDBC는 확장을 통해 여러 종류의 DB를 수용했고,<br>Java application 은 주변의 변화에 영향받지 않았다.</pre><p>OCP는 또한 JVM에도 적용이 되어있다. Java 애플리케이션이 운영체제 종류에 상관없이 실행될 수 있는것도 JVM이 인터페이스 역할을 해주기 때문이다.</p><h4>LSP(Liskov Substitution Principle): 리스코프 치환 원칙</h4><pre>서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다. </pre><p>그러니까 상위클래스를 상속하고 있는 하위클래스나, 인터페이스를 구현하는 구현 클래스의 인스턴스는 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다는 뜻이다.</p><p>동물 분류도의 경우에 이를 완벽하게 만족하고 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/746/1*_vUP_xHrU8N6hyO_iPcTdw.png" /></figure><h4>ISP(Interface Segregation Principle): 인터페이스 분리 원칙</h4><p>SRP 의 대체법이라고 할 수 있지만 되도록이면 SRP 를 적용하는 것이 더 좋은 해결책이라고 할 수 있다.</p><h4>DIP(Dependency Inversion Principle): 의존 역전 원칙</h4><pre>&quot;자신보다 변하기 쉬운 것에 의존하지 마라&quot;</pre><p>라는 것이 의존 역전 원칙이다.</p><p>상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높기에 하위 클래스나 구체 클래스가 아닌 상위클래스, 인터페이스, 추상 클래스에 의존하라는 것이 이 원칙의 의미이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d027780d081f" width="1" height="1"><hr><p><a href="https://medium.com/jiwon-bae/%EC%99%9C-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%A7%9C%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%A4%91%EC%9A%94%ED%95%A0%EA%B9%8C-d027780d081f">왜 객체지향적으로 짜는 것이 중요할까?</a> was originally published in <a href="https://medium.com/jiwon-bae">Jiwon Bae</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[정규화 (Normalization)]]></title>
            <link>https://medium.com/jiwon-bae/%EC%A0%95%EA%B7%9C%ED%99%94-normalization-272d8a88b49?source=rss----1d61fa697319---4</link>
            <guid isPermaLink="false">https://medium.com/p/272d8a88b49</guid>
            <category><![CDATA[database]]></category>
            <dc:creator><![CDATA[Jiwon Bae]]></dc:creator>
            <pubDate>Wed, 23 May 2018 08:01:35 GMT</pubDate>
            <atom:updated>2018-05-23T08:01:35.532Z</atom:updated>
            <content:encoded><![CDATA[<p>관계형 데이터베이스의 개념에 대해 찾아보니 이렇게 설명이 나온다.</p><blockquote>“관계형 데이터베이스의 특징을 한 문장으로 요약하면, <a href="http://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%A0%95%EA%B7%9C%ED%99%94">정규화(Normalization)</a> 이론을 활용하여 데이터 이상 현상을 제거하고, 데이터 중복을 최소화하여 데이터를 관리하는 것이다.”</blockquote><p>그렇다. 정규화라는 개념은 관계형 데이터베이스에서 핵심적인 개념이다.</p><p>그렇다면 정규화가 무엇이고, 정규화를 왜 하는걸까?</p><h3>정규화의 개념</h3><p>정규화를 하는 목적은 한마디로 말하자면 <strong>데이터의 중복을 최소한으로 줄이기 위해서</strong>이다.</p><p>데이터들간에 중복을 줄여야 하는 이유는 우리가 객체지향 프로그래밍에서 중복코드를 줄여야 하는 이유와 같은 맥락이라고 할 수 있다.</p><p>코드의 변경이 생기면 중복된 부분을 모두 고쳐야한다는 문제점이 있는것과 같이, 중복 데이터가 존재하면 다음과 같은 여러가지 문제가 발생한다. (물론 기본적으로 중복 데이터가 존재하면 저장공간이 낭비되기 때문에 중복을 없애야 한다는 것은 너무나 당연하다.)</p><p><strong>불필요한 데이터를 함께 삽입</strong>하지 않으면 어떤 데이터를 삽입하는 것이 불가능하고 (삽입 이상),</p><p>중복된 데이터 가운데 일부만 수정되어 <strong>데이터의 불일치</strong>가 발생할 수도 있고 (수정 이상),</p><p>어떤 데이터를 삭제하면 <strong>유용한 데이터도 함께 삭제</strong>가 될 수도 있다 (삭제 이상).</p><p>이렇게 데이터의 중복이 존재해 발생하는 문제를 통틀어서 <strong>갱신 이상(Update Anomaly)</strong>라고 한다.</p><h3>정규화의 구분</h3><p>정규화 단계에 따라 제 1 정규화, 제 2 정규화 그리고 제 3 정규화로 구분된다.</p><h4>제 1 정규형 (1NF; First Normal Form)</h4><p>1NF 의 규칙은 아래와 같다.</p><pre>1. 열은 원자적 값만을 포함해야 한다.</pre><pre>2. 같은 데이터가 여러 열에 반복되지 말아야 한다.</pre><p>역시 글로는 이해가 어려워 그림으로 직접 나타내보면 아래와 같다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*nb86cYqttt4dvd7O4_6bbA.png" /><figcaption>(출처 : <a href="http://futurists.tistory.com/15?category=587334">http://futurists.tistory.com/15?category=587334</a>)</figcaption></figure><p>첫번째 my_toy1는 1번 규칙을 위반한 것이고, my_toy2는 2번 규칙을 위반한 것을 알 수 있을 것이다.</p><p>원래는 1, 2 번 규칙을 위반한 사례를 모두 다뤄야 하지만 이글에서는 1번 규칙을 위반한 예만 들어서 정규화가 어떻게 진행되는지 살펴보고자 한다.</p><p>찾아봤더니 쉽게 설명해 놓은 글이 있어서 예제를 참고했다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/244/1*MLCmwtyP0wOZlLhvzlof3w.png" /></figure><p>위와 같이 주문 엔티티가 구성되어있다고 생각할 때, 내가 ‘jiwon’ 이라는 아이디로 인터넷 쇼핑몰에서 옷 두벌을 구매했다고 생각해보자.</p><p>한번에 주문했기 때문에 주문번호는 동일하지만 <strong>두개의 옷은 품목코드와 품목 단가 등이 다르다</strong>.</p><p>실 데이터로 나타내면 다음과 같이 데이터베이스에 저장되는 상황이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/988/1*KVf2HPTOjGJbR9QvXYIA0Q.png" /><figcaption>(생략한 부분이 있다.)</figcaption></figure><p>이렇게 되면, PK 인 주문번호를 가지고 이 둘을 구분할 수가 없다.</p><p>제1정규형의 규칙에 맞추어서 표현하자면, 주문번호가 350 인 레코드에 대해 품목코드 속성과 품목단가 <strong>속성이 2개의 값</strong>을 가지고 있기 때문에 1번 규칙인 <em>“열은 원자적 값만을 포함해야 한다.”</em> 를 위반하고 있다.</p><p>이게 문제가 되는 이유는 계속 반복적으로 말하고 있지만 당연히 <strong>중복 데이터가 발생하기 때문</strong>이다. 아래와 같이 몇개의 속성들에 대해서 중복 데이터가 발생하고 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/244/1*WBP629x4Gf_UnIMdg4p1lA.png" /></figure><p>이를 해결하는 방법은 명확하다.</p><p>중복 데이터를 발생시키는 원인이 되는 것들을 <strong>자식 엔티티로 분리해버리는 것!</strong></p><p>아래와 같이 원인이 되는 품목코드, 품목단가, 주문수량을 자식 엔티티의 속성으로 분리하고, 부모 테이블의 기본키인 주문번호를 외래키이자 기본키를 이루는 구성으로 두었다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/541/1*wvKNoTy1oHxyIkAFKrqWEQ.png" /></figure><h4>제 2 정규형 (2NF; Second Normal Form)</h4><p>2NF 의 규칙은 다음과 같다.</p><pre>1. 제 1 정규형이어야 한다.</pre><pre>2. 부분적 함수 의존이 없어야 한다.</pre><p>이해를 돕기 위해 제 2 정규화를 위반한 사례를 살펴보자.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/244/1*_9NLzLmjycTwY0njFBX1SQ.png" /></figure><p>이 주문품목 엔티티는 위에서 제 1정규화를 진행한 결과로 나온 엔티티이다.</p><p>그러므로 제 1정규화의 기준은 충족시켰으나, 부분적인 함수 의존이 존재하기 때문에 제 2 정규화 기준에 만족하지 못했다.</p><p>좀 더 설명하자면, 주문수량은 주문번호가 변경되어도, 품목코드가 변경되어도 변경이 되어야 하므로 두 개의 키에 대해서 모두 종속적인 관계를 가지지만,</p><p>품목단가의 경우, <strong>품목코드가 변경이 되면 변경이 되어야 하지만 주문번호가 바뀐다고 해도 변경될 이유는 없기 때문에</strong> 여기서 부분적 함수 종속 관계가 발생하게 된다.</p><p>부분적 함수 종속이 문제가 되는 이유 역시 데이터의 중복이 발생하기 때문이다. 생각해보면, 품목 코드가 같아도 주문번호가 다르면 동일한 품목단가 데이터는 중복되어서 나타나게 되기 때문이다.</p><p>제 2 정규화 위반을 해결하는 방법은 여러가지가 있는듯하다.</p><p>기존에 사용하던 합성키 대신에 하나의 열로 이루어진 새 <a href="http://futurists.tistory.com/15?category=587334">기본키를 추가</a>하거나, 부분적 함수 종속 관계의 원인이 되는 속성을 제거하는 방법이 있다.</p><p>아래는 후자의 방법으로 제 2 정규화를 만족시킨 사례이다.</p><p>부분적 함수 종속 관계의 원인이 되는 품목 단가 속성을 부모 엔티티를 따로 생성해 분리하였다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/744/1*TngmgqFPXRI7fGFRvTqQ5Q.png" /></figure><p>어떤 방법이 더 많이 쓰이는지는 아직 모르겠다.</p><h4>제 3 정규형 (3NF; Third Normal Form)</h4><p>일반적으로 개발할때는 인위적으로 만든 기본키가 있고, 합성키는 존재하지 않도록 테이블을 설계하는 경우가 대부분이므로 거의 모든 경우 제 2 정규형은 만족하게 된다.</p><p>제 3 정규화 조건을 맞추는 것이 관건인데, 그 규칙부터 알아보자.</p><pre>1. 제 2 정규형이어야 한다.</pre><pre>2. 이행적 함수 종속 관계가 존재하지 않아야 한다.</pre><p>2번규칙을 다른 말로 하면, <strong>식별자 이외의 속성간에 종속 관계가 존재하면 안된다</strong>라고 해도 이해하는 데에 어렵지 않을 것이다.</p><p>제 3 정규화를 위반한 경우 역시 해결법은 동일하다. 그 원인이 되는 속성을 제거하여 다른 엔티티의 속성으로 빼는 것.</p><p>실제 예를 들어서 설명해보자.</p><p>아까 예로 들었던 엔티티들 중 주문 엔티티는 제 3 정규화 기준을 위반하고 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/244/1*w9xrTznfWT_Oxl8l5ndh8g.png" /></figure><p>기본키가 하나의 속성으로 이루어져 있으므로 제 2 정규형까지는 만족하지만, 고객번호가 달라지면 고객명, 고객주소가 달라지는 이행적 종속 관계가 존재하기 때문에 제 3 정규형은 만족하지 않는다.</p><p>이에 대한 해결방법으로 <strong>‘고객’</strong> 이라는 부모 엔티티를 만들고 이행적 종속 관계와 연관된 속성들을 그 엔티티로 분리하면 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/245/1*DrUBRhMP19o1wTsBpK3Wig.png" /></figure><h3>참고</h3><ul><li><a href="http://blog.naver.com/PostView.nhn?blogId=mjsolar&amp;logNo=130109454313">http://blog.naver.com/PostView.nhn?blogId=mjsolar&amp;logNo=130109454313</a></li><li><a href="http://blog.ngelmaum.org/entry/lab-note-sql-join-method">http://blog.ngelmaum.org/entry/lab-note-sql-join-method</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=272d8a88b49" width="1" height="1"><hr><p><a href="https://medium.com/jiwon-bae/%EC%A0%95%EA%B7%9C%ED%99%94-normalization-272d8a88b49">정규화 (Normalization)</a> was originally published in <a href="https://medium.com/jiwon-bae">Jiwon Bae</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Web] TEST A REST API WITH JAVA]]></title>
            <link>https://medium.com/jiwon-bae/web-test-a-rest-api-with-java-f29060f1fcc3?source=rss----1d61fa697319---4</link>
            <guid isPermaLink="false">https://medium.com/p/f29060f1fcc3</guid>
            <category><![CDATA[rest-api-testing]]></category>
            <category><![CDATA[web]]></category>
            <dc:creator><![CDATA[Jiwon Bae]]></dc:creator>
            <pubDate>Sun, 15 Apr 2018 13:51:17 GMT</pubDate>
            <atom:updated>2018-04-15T13:51:17.365Z</atom:updated>
            <content:encoded><![CDATA[<h3>TEST A REST API WITH JAVA</h3><p>Integration Tests를 이용해 REST API 를 테스트 하는 방법을 공부해봤다.</p><p>테스트를 통해서 확인되어야 할 요소는 3가지가 있었다.</p><pre>1. The HTTP response code (HTTP 응답 코드)</pre><pre>2. Other HTTP header in the response (응답 메세지의 다른 HTTP 헤더)</pre><pre>3. The payload (Json, XML)</pre><p>payload 라는 용어가 쉽게 와닿지 않아 찾아보았다.</p><blockquote>payload 라는 것은 <strong>클라이언트가 서버에 실제로 요구한, 결과적으로 받길 원하</strong></blockquote><blockquote><strong>는 데이터</strong> 라고 할 수 있다.</blockquote><p>각각을 테스트하는 예제코드가 나와있어서 이해하는데에 도움이 되었다.</p><p>첫번째로, status code 에 대한 테스트 코드이다.</p><pre>@Test<br>public void givenUserDoesNotExists_whenUserInfoIsRetrieved_then404IsReceived()<br>  throws ClientProtocolException, IOException {<br>​<br>   // Given<br>   String name = RandomStringUtils.randomAlphabetic( 8 );<br>   HttpUriRequest request = new HttpGet( &quot;https://api.github.com/users/&quot; + name );<br>​<br>   // When<br>   HttpResponse httpResponse = HttpClientBuilder.create().build().execute( request );<br>​<br>   // Then<br>   assertThat(<br>     httpResponse.getStatusLine().getStatusCode(),<br>     equalTo(HttpStatus.SC_NOT_FOUND));<br>}</pre><p>위 테스트 코드는 user 가 존재하지 않는데 해당 user 를 검색했을 때 <strong>404 에러가 나는 것을 테스트</strong> 하는 코드이다.</p><p>클라이언트로부터 이름으로 해당하는 user 를 찾아달라는 get 요청이 왔을 때, 서버에서 처리하고 보낸 응답메세지인 HttpResponse 에서 상태 코드를 비교하여 404 NOT FOUND 인지 확인하고 있다.</p><p>다음은, 응답으로 온 데이터의 타입이 일치하는지를 테스트 한다.</p><pre>@Test<br>public void<br>givenRequestWithNoAcceptHeader_whenRequestIsExecuted_thenDefaultResponseContentTypeIsJson()<br>  throws ClientProtocolException, IOException {<br>​<br>   // Given<br>   String jsonMimeType = &quot;application/json&quot;;<br>   HttpUriRequest request = new HttpGet( &quot;https://api.github.com/users/eugenp&quot; );<br>​<br>   // When<br>   HttpResponse response = HttpClientBuilder.create().build().execute( request );<br>​<br>   // Then<br>   String mimeType = ContentType.getOrDefault(response.getEntity()).getMimeType();<br>   assertEquals( jsonMimeType, mimeType );<br>}<br>​</pre><p>마지막으로, 응답메세지에서 리소스를 검색해 예상하던 결과와 일치하는 리소스인지를 확인한다.</p><p>아래 테스트 코드 같은 경우, 응답으로 온 JSON 데이터가 예상했던 데이터와 동일한 데이터인지를 테스트하는 코드이다.</p><pre>@Test<br>public void<br>  givenUserExists_whenUserInformationIsRetrieved_thenRetrievedResourceIsCorrect()<br>  throws ClientProtocolException, IOException {<br>​<br>    // Given<br>    HttpUriRequest request = new HttpGet( &quot;https://api.github.com/users/eugenp&quot; );<br>​<br>    // When<br>    HttpResponse response = HttpClientBuilder.create().build().execute( request );<br>​<br>    // Then<br>    GitHubUser resource = RetrieveUtil.retrieveResourceFromResponse(<br>      response, GitHubUser.class);<br>    assertThat( &quot;eugenp&quot;, Matchers.is( resource.getLogin() ) );<br>}<br>​</pre><h3>Reference</h3><p><a href="http://www.baeldung.com/integration-testing-a-rest-api">http://www.baeldung.com/integration-testing-a-rest-api</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f29060f1fcc3" width="1" height="1"><hr><p><a href="https://medium.com/jiwon-bae/web-test-a-rest-api-with-java-f29060f1fcc3">[Web] TEST A REST API WITH JAVA</a> was originally published in <a href="https://medium.com/jiwon-bae">Jiwon Bae</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Java-ims] 인증기반 개발 (2)]]></title>
            <link>https://medium.com/jiwon-bae/java-ims-%EC%9D%B8%EC%A6%9D%EA%B8%B0%EB%B0%98-%EA%B0%9C%EB%B0%9C-2-33ae1ffaa0a1?source=rss----1d61fa697319---4</link>
            <guid isPermaLink="false">https://medium.com/p/33ae1ffaa0a1</guid>
            <category><![CDATA[issue-managing-system]]></category>
            <category><![CDATA[projects]]></category>
            <dc:creator><![CDATA[Jiwon Bae]]></dc:creator>
            <pubDate>Sun, 15 Apr 2018 13:29:54 GMT</pubDate>
            <atom:updated>2018-05-21T02:39:10.028Z</atom:updated>
            <content:encoded><![CDATA[<h4>중복 제거, clean code, 쿼리 보기 설정</h4><h3>중복 제거, Clean code</h3><p>회원정보를 수정하는 기능을 구현한 후에 수많은 중복코드가 생긴 것을 확인했다.</p><p>중복코드가 발생한 부분은</p><pre>1. 사용자가 로그인을 했는지 안했는지 판단하는, 즉, session 에 담긴 데이터가 null 값인지 아닌지를 판단하는 부분</pre><pre>2. 로그인한 사용자와 수정 대상이 되는 사용자가 동일한 사용자인지 판단하는 부분</pre><p>이었다.</p><p>모두 session 과 관련된 처리를 하는 부분이라 HttpSessionUtils 라는 클래스를 새로 생성하여 관련 처리는 이 클래스에서 하도록 구현했다.</p><p>되도록 getter 메소드를 쓰지 않고, 해당 변수를 상태변수로 가지고 있는 클래스 내에서 관련 처리를 하도록 구현했다.</p><p>예를 들어, 위에서 2번에 해당하는 부분을 구현할때 사용자들의 id 값 비교를 통해 같은 사용자인지 아닌지를 판단했는데</p><p>이때, 이 비교하는 처리를 id 라는 상태변수를 가지고 있는 user 클래스에 위임하여 좀 더 객체지향적인 코드를 짜도록 했다.</p><h3>쿼리 보기 설정</h3><p>JPA 에 대해서 아직 잘 모르지만 데이터베이스와 관련해서 <em>쿼리문을 자동으로 생성해 주어서</em> 좀 더 손쉽게 데이터베이스를 사용할 수 있도록 하는 듯한 느낌을 받았다.</p><p>직접 쿼리문을 작성하는 것이 아니다 보니, 생성과정을 보기 위해서는 별도의 설정을 해주어야 했는데,</p><pre>spring.jpa.show-sql=true<br>spring.jpa.properties.hibernate.format_sql=true</pre><p>위 코드를 application.properties 파일에 명시해줌으로서 쿼리문 생성과정을 확인할 수 있게 되었다.</p><h3>질문하기, 질문 목록 기능 구현</h3><p>질문하기 기능은 기존에 구현한 것에서 “<em>로그인한 사용자만이 질문을 작성할 수 있다”</em> 는 제약 조건이 새로 생기면서 질문작성 form 에 접근하기 전에 login 을 한 상태인지 아닌지 체크하는 로직을 추가해야 했다.</p><p>질문 목록 기능 구현에 대해서는 기존에 구현하던 것과 별다른점이 없어 어렵지 않게 구현을 마쳤다.</p><h3>실습에서 배운 점들</h3><p>이번 실습에서 좀 생소했던 것들을 정리해보자면,</p><ul><li>현재 실습에서 JPA 를 이용해 객체와 데이터베이스를 매핑해주고 있는데, 이때 객체에 무조건 default 생성자(기본 생성자) 가 있어야 한다.</li><li>데이터베이스에 데이터를 저장하기 위해 사용한 변수 QuestionRepository, UserRepository 를 선언할 때 Spring 프레임워크 annotation 인 @Autowired 을 사용했는데, 이 annotation 에 대해 조금 더 자세히 알게 되었다.</li><li>Spring 프레임워크는 repository 를 관리하고 있는데, 사실 우리가 인터페이스로 구현한 이 repository 를 프레임워크 내부에서는 실제로 구현하여 new 를 이용해 생성까지 해준다.</li></ul><blockquote>&quot;그 생성한 값을 우리가 controller 에 정의한 repository 변수에 할당해줘야 해&quot;</blockquote><blockquote>라는 사실을 Spring 프레임워크에게 알려주는 annotation 이 바로</blockquote><blockquote>@Autowired 이다.</blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=33ae1ffaa0a1" width="1" height="1"><hr><p><a href="https://medium.com/jiwon-bae/java-ims-%EC%9D%B8%EC%A6%9D%EA%B8%B0%EB%B0%98-%EA%B0%9C%EB%B0%9C-2-33ae1ffaa0a1">[Java-ims] 인증기반 개발 (2)</a> was originally published in <a href="https://medium.com/jiwon-bae">Jiwon Bae</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Java-ims] 인증 기반 개발 (1)]]></title>
            <link>https://medium.com/jiwon-bae/java-ims-%EC%9D%B8%EC%A6%9D-%EA%B8%B0%EB%B0%98-%EA%B0%9C%EB%B0%9C-9dd522a2f418?source=rss----1d61fa697319---4</link>
            <guid isPermaLink="false">https://medium.com/p/9dd522a2f418</guid>
            <category><![CDATA[projects]]></category>
            <category><![CDATA[issue-managing-system]]></category>
            <dc:creator><![CDATA[Jiwon Bae]]></dc:creator>
            <pubDate>Sun, 15 Apr 2018 13:19:58 GMT</pubDate>
            <atom:updated>2018-05-21T02:39:28.014Z</atom:updated>
            <content:encoded><![CDATA[<h4>자기 자신에 한해 개인정보 수정</h4><p>사용자가 로그인 후 <em>개인정보 수정</em> 버튼을 누르면 <strong>자기 자신의</strong> 개인정보 수정 페이지로 넘어가야 한다.</p><p>UserController 클래스의 updateForm() 메소드가 이 역할을 기존에 하고 있었는데, 에러가 웹 페이지를 로드해보니 에러가 발생했다.</p><p>에러의 원인은 앞에서 로그인 하여 session 에 데이터를 넣어줄때 데이터의 이름을 updateForm() 메소드에서 model 에 데이터를 넣어줄때의 이름과 일치했기 때문이다.</p><p>그래서 session 에 넣는 데이터의 이름을 <em>sessionedUser</em> 라고 이름을 변경해 에러를 해결할 수 있었다.</p><h4>다음 두가지의 해결해야 하는 이슈가 있었다.</h4><blockquote>하나는, 로그인을 하지 않더라도 수정 페이지로 이동하는 url 에 직접 접근을 통해 개인정보 수정을 할 수 있는 이슈.</blockquote><blockquote>다른 하나는, 로그인만 되어 있으면 또 역시 url을 통해 다른 사용자의 개인정보 수정 화면으로 넘어갈 수 있는 이슈.</blockquote><p>첫번째 이슈를 해결하기 위해서 세션에 저장된 데이터를 가져와 그 값이 null 이면 로그인 화면으로 리다이렉트 시켰다.</p><p>두번째 이슈는 세션에 저장되어 있던 user 데이터의 id 값과 이전 페이지로부터 전달받은 id 값이 일치하는지 확인해야 했는데</p><p>즉, 현재 로그인한 사용자와 개인정보 수정 대상이 되는 사용자가 같은 사용자인지 확인해 그렇지 않으면 IllegalStateException() 을 발생시켜 자기 자신만 자신의 정보를 수정할 수 있다는 에러메세지를 출력하도록 만듦으로써 해결하였다.</p><p>기능 구현은 했으나 구현 후에 보니 중복되는 코드가 많았다. 중복코드가 많은채로 계속 개발을 하면 프로그램의 복잡도가 높아진다고 한다. 다음 포스트 에서는 중복 코드를 제거하는 과정을 작성해 보려고 한다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9dd522a2f418" width="1" height="1"><hr><p><a href="https://medium.com/jiwon-bae/java-ims-%EC%9D%B8%EC%A6%9D-%EA%B8%B0%EB%B0%98-%EA%B0%9C%EB%B0%9C-9dd522a2f418">[Java-ims] 인증 기반 개발 (1)</a> was originally published in <a href="https://medium.com/jiwon-bae">Jiwon Bae</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Algorithm] 프로그래머스 Lv.1 문자열 내림차순 배치]]></title>
            <link>https://medium.com/jiwon-bae/algorithm-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-lv-1-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%B4%EB%A6%BC%EC%B0%A8%EC%88%9C-%EB%B0%B0%EC%B9%98-7b95819a6200?source=rss----1d61fa697319---4</link>
            <guid isPermaLink="false">https://medium.com/p/7b95819a6200</guid>
            <category><![CDATA[algorithms]]></category>
            <dc:creator><![CDATA[Jiwon Bae]]></dc:creator>
            <pubDate>Wed, 11 Apr 2018 00:43:18 GMT</pubDate>
            <atom:updated>2018-04-11T00:43:18.785Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*9fTtcQWk8VNgp7zniEjRIQ.png" /><figcaption><strong>프로그래머스 Lv.1 문자열 내림차순 배치</strong></figcaption></figure><p>풀이법은 입력으로 들어온 String 을 char[] 로 변환 후, 오름차순으로 정렬하여 다시 reverse() 를 통해 내림차순으로 정렬하는 풀이법을 사용했다.</p><p>Java 의 다양한 라이브러리를 사용해서 풀었던 문제였다.</p><ul><li>java.util.Arrays.sort(char[]) : 문자를 <strong>사전순으로 오름차순</strong>, 그리고 <strong>대문자는 소문자보다 더 큰것</strong>으로 간주하고 정렬한다. Java 의 sort() 는 내부적으로 quickSort 를 사용해 구현하고 있다.</li><li>java.lang.StringBuilder.reverse() : 문자열 순서를 거꾸로 뒤집어준다.</li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7b95819a6200" width="1" height="1"><hr><p><a href="https://medium.com/jiwon-bae/algorithm-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-lv-1-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%B4%EB%A6%BC%EC%B0%A8%EC%88%9C-%EB%B0%B0%EC%B9%98-7b95819a6200">[Algorithm] 프로그래머스 Lv.1 문자열 내림차순 배치</a> was originally published in <a href="https://medium.com/jiwon-bae">Jiwon Bae</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Algorithm] 프로그래머스 Lv1. 수박수박수박수박수박수?]]></title>
            <link>https://medium.com/jiwon-bae/algorithm-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-lv1-%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98-a3e84622cabc?source=rss----1d61fa697319---4</link>
            <guid isPermaLink="false">https://medium.com/p/a3e84622cabc</guid>
            <category><![CDATA[algorithms]]></category>
            <dc:creator><![CDATA[Jiwon Bae]]></dc:creator>
            <pubDate>Tue, 10 Apr 2018 01:05:34 GMT</pubDate>
            <atom:updated>2018-04-10T01:05:34.801Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*neXX6QkEZBRVwXBjAQ1f3A.png" /><figcaption><strong>프로그래머스 Lv1. 수박수박수박수박수박수?</strong></figcaption></figure><p>인덱스가 짝수일때는 ‘수&#39; 를, 홀수일때는 ‘박&#39;을 넣어주었다.</p><p>문제 난이도는 어렵지 않았지만 기억해야 할 라이브러리가 있어 정리해보려고 한다.</p><h4><strong>char[] 를 </strong><strong>String 으로 변환할 때 쓰는 라이브러리</strong></h4><ul><li>valueOf() : 넘겨진 인자에 대한 String 표현을 반환한다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*N7pSCML9byZWCfC1Ir-1tg.png" /><figcaption><strong>valueOf()</strong></figcaption></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a3e84622cabc" width="1" height="1"><hr><p><a href="https://medium.com/jiwon-bae/algorithm-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-lv1-%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98-a3e84622cabc">[Algorithm] 프로그래머스 Lv1. 수박수박수박수박수박수?</a> was originally published in <a href="https://medium.com/jiwon-bae">Jiwon Bae</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Algorithm] 프로그래머스 Lv.1 평균구하기]]></title>
            <link>https://medium.com/jiwon-bae/algorithm-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-lv-1-%ED%8F%89%EA%B7%A0%EA%B5%AC%ED%95%98%EA%B8%B0-fd9c88e9d8a?source=rss----1d61fa697319---4</link>
            <guid isPermaLink="false">https://medium.com/p/fd9c88e9d8a</guid>
            <category><![CDATA[algorithms]]></category>
            <dc:creator><![CDATA[Jiwon Bae]]></dc:creator>
            <pubDate>Mon, 09 Apr 2018 00:55:04 GMT</pubDate>
            <atom:updated>2018-04-09T00:55:04.853Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*zgsvHUNoIzthH44FR_6u3Q.png" /><figcaption><strong>프로그래머스 Lv1. 평균구하기</strong></figcaption></figure><p>아주 쉬운 문제였다. 풀이에 대해서는 딱히 할 말이 없고, 코드를 람다식을 이용해 짜보려다 안된다는 것을 알았다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*pNCpny60jqM9iEijuSQfWA.png" /><figcaption><strong>Lambda 식을 이용한 코드</strong></figcaption></figure><p>람다식에서 local variable 을 사용할 경우 이 변수는 final 이 되어야만 하므로 z위 코드에서 변수 m 의 값은 끝까지 0이다.</p><p>그래서 이 경우에는 람다식 적용이 불가능하다.</p><p>이 개념에 대해서는 한번 더 정리를 해봐야겠다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fd9c88e9d8a" width="1" height="1"><hr><p><a href="https://medium.com/jiwon-bae/algorithm-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-lv-1-%ED%8F%89%EA%B7%A0%EA%B5%AC%ED%95%98%EA%B8%B0-fd9c88e9d8a">[Algorithm] 프로그래머스 Lv.1 평균구하기</a> was originally published in <a href="https://medium.com/jiwon-bae">Jiwon Bae</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Algorithm] 프로그래머스 Lv1. 행렬의 덧셈]]></title>
            <link>https://medium.com/jiwon-bae/algorithm-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-lv1-%ED%96%89%EB%A0%AC%EC%9D%98-%EB%8D%A7%EC%85%88-1078fa5fd7c2?source=rss----1d61fa697319---4</link>
            <guid isPermaLink="false">https://medium.com/p/1078fa5fd7c2</guid>
            <category><![CDATA[algorithms]]></category>
            <dc:creator><![CDATA[Jiwon Bae]]></dc:creator>
            <pubDate>Fri, 06 Apr 2018 01:20:16 GMT</pubDate>
            <atom:updated>2018-04-06T01:20:16.945Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*x20VLw_2Zj_Ugn-K01Fhlw.png" /><figcaption><strong>프로그래머스 Lv1. 행렬의 덧셈</strong></figcaption></figure><p>문제를 볼때 행과 열이 같은 두 행렬이라 그래서 처음에는 정방행렬(n x n) 인 줄 알았는데 그게 아니라 두 행렬의 행의 길이가 같고, 열의 길이가 동일하다는 뜻이었다. 즉, 어떤 n x m 크기의 두 개의 행렬을 더하는 것이었다. 사소한 것이지만 문제를 읽을 때 주의해야 하는 점 같다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1078fa5fd7c2" width="1" height="1"><hr><p><a href="https://medium.com/jiwon-bae/algorithm-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-lv1-%ED%96%89%EB%A0%AC%EC%9D%98-%EB%8D%A7%EC%85%88-1078fa5fd7c2">[Algorithm] 프로그래머스 Lv1. 행렬의 덧셈</a> was originally published in <a href="https://medium.com/jiwon-bae">Jiwon Bae</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
    </channel>
</rss>