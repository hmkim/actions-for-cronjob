<?xml version='1.0' encoding='UTF-8'?><?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?><feed xmlns='http://www.w3.org/2005/Atom' xmlns:openSearch='http://a9.com/-/spec/opensearchrss/1.0/' xmlns:blogger='http://schemas.google.com/blogger/2008' xmlns:georss='http://www.georss.org/georss' xmlns:gd="http://schemas.google.com/g/2005" xmlns:thr='http://purl.org/syndication/thread/1.0'><id>tag:blogger.com,1999:blog-7179839488892896723</id><updated>2019-05-12T01:12:02.412+09:00</updated><category term="algorithm"/><category term="javascript"/><category term="자바"/><category term="python"/><category term="clojuredocs"/><category term="clojure"/><category term="java"/><category term="lisp"/><category term="파이썬"/><category term="잡소리"/><category term="hackerrank"/><category term="리뷰"/><category term="c"/><category term="design pattern"/><category term="jvm"/><category term="book review"/><category term="haskell"/><category term="machine learning"/><category term="robotics"/><category term="udacity"/><category term="하스켈"/><category term="JBoss"/><category term="compiler"/><category term="django"/><category term="haskel"/><category term="html"/><category term="ie"/><category term="linux"/><category term="oracle"/><category term="워크숍"/><title type='text'>?Nam의 IT세상</title><subtitle type='html'>끼적끄적긁적</subtitle><link rel='http://schemas.google.com/g/2005#feed' type='application/atom+xml' href='http://www.whynam.com/feeds/posts/default'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default'/><link rel='alternate' type='text/html' href='http://www.whynam.com/'/><link rel='hub' href='http://pubsubhubbub.appspot.com/'/><link rel='next' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default?start-index=26&amp;max-results=25'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><generator version='7.00' uri='http://www.blogger.com'>Blogger</generator><openSearch:totalResults>245</openSearch:totalResults><openSearch:startIndex>1</openSearch:startIndex><openSearch:itemsPerPage>25</openSearch:itemsPerPage><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-8078752393506282275</id><published>2019-05-12T01:12:00.001+09:00</published><updated>2019-05-12T01:12:02.351+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="리뷰"/><title type='text'>[책리뷰] 익스트림 프로그래밍 - 켄트벡 -</title><content type='html'>최근 Object Thinking 이라는 책을 한 반정도 읽다가 포기했다. 수 많은 메타포들과 마치 어학영수시절 글쓰기 시절의 글처럼 한 문장을 지나갈 때마다 의미가 동일해도 무슨 토플 시험 보듯, 단어가 계속 바뀌고 바뀌다 보니 점점 읽어가는 속도가 느려졌다. 그러면서 포기를 하게 되었다. 나중에 읽어야지...&lt;br /&gt;&lt;br /&gt;하지만 읽으면서 느꼈던 것이 객체지향 프로그래밍은 애자일/익스트림 프로그래밍이 태어날 때, 함께 자라난 개념이라는 것이었다. 객체지향 시뮬라에서 파생된 C++와 스몰토크에서 스몰토크는 시뮬라의 디자인을 따라가려 했으며, C++는 디자인을 따라가기에는 너무 속도가 느리다고 판단, 시뮬라의 디자인을 완벽하게 구현하지는 않았다고 한다.(Object Thinking 참고)&lt;br /&gt;&lt;br /&gt;그후로 계속 익스트림 프로그래밍과 애자일에 대해서 이야기를 한다. 자바,객체지향 책을 읽어서는 객체지향의 진수를 알 수 없고, 겉에 보여지는 것만 알게 될 것이라고 그는 말한다. 그러니까 우리는 겉모습만 따라하고 실재로 무엇이 중요한지 모른다는 말 같다.&lt;br /&gt;&lt;br /&gt;마치, 짝프로그래밍을 한다고는 하지만, 정확이 이것으로 무엇을 성취하는지는 모르는... 그런 것일까나?&lt;br /&gt;그리고 자주 언급되는 사람들이 있었다. 나는 Object thinking이라는 책을 덮고 일단 그 사람들에 대해서 그리고 그 언어들에 대해서 공부를 해볼까 한다.&lt;br /&gt;&lt;br /&gt;일단 나는 켄트벡 아저씨에 대해 알아보려고 한다. 그는 책을 정말 많이 썼다. 게다가 이분 책을 읽어 본 적이 있다. 바로 [익스트림 프로그래밍] 이다. &lt;br /&gt;처음 개발을 시작할 때, 읽었던 책이다. 그 당시 중간 정도 읽다가 대체 무엇이 중요한 거지? 라는 생각과 기억에 남은 거라곤, 도요타 공장라인에 대한 이야기 뿐이었다. 문제가 생기는 것을 보면 줄을 잡아당겨 모든 생산라인을 정지시키고 모두 함께 문제를 해결하는 것. 그리고 필요한 만큼만 준비하고 생산하는 효율이라는 마인드. 그것뿐이었다. &lt;br /&gt;&lt;br /&gt;나는 이전에 봤던 그 책을 한번 다시 보기로 했다.&lt;br /&gt;요즘은 도서관에 갈 필요도 없이 나랑 멀리있는 도서관도 내 집 근처 역으로 배송을 해준다. &lt;br /&gt;나는 익스트림 프로그래밍 책을 빌렸다.&lt;br /&gt;&lt;br /&gt;그리고 다시 읽으면서 아... 그때 아무생각 없이 읽었던 내용들이 이런 것들이었구나... 하는 것을 느겼다.&lt;br /&gt;그래도 아마 나는 제대로 이해한 것이 아닐 것이다. 정말로 해보기 전까진 모를 것이다. 정말 닥치기 전까지 자신이 어떤 행동을 할지 모르듯이...&lt;br /&gt;&lt;br /&gt;하지만 정말 멋진 방법같다.&lt;br /&gt;&lt;br /&gt;계속 하나의 프로그램을 작게 쪼개면서 개발을 하는데, 차라리 쪼갠 부분이 하나의 프로그램이라면, 어떨까.&lt;br /&gt;그렇다면 그것을 하나의 프로그램으로 보고 테스트해보고 확인하고 개선하고 또 새로운 프로그램이 탄생하고.&lt;br /&gt;그런 주기를 계속 이어간다는 것.&lt;br /&gt;&lt;br /&gt;그럼으로 몇주일 단위로 배포되던 것들이, 일주일 단위로 그리고 하루 단위로 배포가 되면서 눈 앞에 살아있는 생명처럼 보이기 시작한다면,&lt;br /&gt;우리는 무엇을 만드는지 알 수 있고, 무엇을 개선해야 하는지 빠르게 알 수 있을 것이다.&lt;br /&gt;&lt;br /&gt;정말 이런 개발이 가능할까.&lt;br /&gt;정말 이런 문화가 가능한 것일까.&lt;br /&gt;&lt;br /&gt;이런 문화를 한번쯤은 겪어보고 싶은 생각이 있다.&lt;br /&gt;&lt;br /&gt;켄트벡 아저씨의 책을 더 읽어보고 싶다. 도서관에서 구할 수 없는 책들은 구매도 하고 싶다. 하지만 지금 집에 쌓인게 책들이라... 책을 구매하는 것은 집에 있는 책들을 다 치우고 생각해봐야겠다.&lt;br /&gt;&lt;br /&gt;이 책은 개발자만을 위한 책은 아닌 것 같다. 무언가 계획을 관리함에 있어, 익스트림 프로그래밍의 철학과 맞닿는 분야라면 가능하다고 생각한다.&lt;br /&gt;특히 요구사항이 생명체처럼 변하는 세상의 부름처럼 자연스레 바뀌어야 하는 상화이라면 익스트림 프로그래밍이라는 책 읽어볼만 하다고 생각한다.</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/8078752393506282275/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/05/blog-post.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/8078752393506282275'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/8078752393506282275'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/05/blog-post.html' title='[책리뷰] 익스트림 프로그래밍 - 켄트벡 -'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-464639718281976021</id><published>2019-04-26T10:48:00.002+09:00</published><updated>2019-04-26T10:48:44.142+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="lisp"/><category scheme="http://www.blogger.com/atom/ns#" term="리뷰"/><title type='text'>[리뷰][scheme] Programming and Meta-Programming in Scheme 을 읽고</title><content type='html'>&lt;a href=&quot;https://www.amazon.com/Programming-Meta-Programming-Undergraduate-Computer-Science/dp/1461272432&quot;&gt;https://www.amazon.com/Programming-Meta-Programming-Undergraduate-Computer-Science/dp/1461272432&lt;/a&gt;&lt;br /&gt;이 책은 얼떨결에 읽게 되었다.&lt;br /&gt;&lt;br /&gt;Scheme 관련 책을 골라보려고 샘플을 받았는데 페이지를 넘기다가 얼떨결에 구매해 버린것이다!&lt;br /&gt;게다가 만원 2만원도 아닌 60달러 이상이 되는 책이었다.&lt;br /&gt;Scheme에 대해 꽤나 자세하게 되어있고, SICP에서 설명하는 강의의 내용과 꽤나 비슷한 내용들이 많았다.&lt;br /&gt;&lt;br /&gt;SICP를 읽기 위한 전과정이라 생각해도 될 것 같다는 생각을 했다.&lt;br /&gt;일단 Scheme책이기 때문에 Scheme에 대한 깊은 내용이 나올 때도 있다. 관심이 없지만 아마 다른 Lisp들도 비슷한 컨셉으로 만들어져있지 않을까 하는 마음이 들어서 계속 읽었다.&lt;br /&gt;&lt;br /&gt;매크로에 대한 내용은 생각보다 많이 나오진 않았다.&lt;br /&gt;오히려 개발에 대한 일반철학을 설명할 때가 좋았다. 아마 그런 걸 더 느끼고 싶어서 SICP를 읽어보려는 걸지도 모르겠다.&lt;br /&gt;&lt;br /&gt;아쉬운 점은 해당 사이트를 찾아보려고 했는데 잘 작동하는 것 같지 않았다.&lt;br /&gt;&lt;a href=&quot;http://www.cs.sjsu.edu/faculty/pearce/scheme/index.html&quot;&gt;http://www.cs.sjsu.edu/faculty/pearce/scheme/index.html&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;읽으면서 가장 기억에 남는 것은 heap을 구현해보는 것이었다.&lt;br /&gt;아직도 좀 난해한데 나중에 시간 나면 그 부분만 다시 따라쳐보면서 이해해볼까 한다.&lt;br /&gt;&lt;br /&gt;글로는 대충 느낌이 오는데 소스코드가 난해하다.&lt;br /&gt;그래서 타입체크 하는 부분을 좀 줄이고 한가지 타입만 저장가능하도록 줄여서 구조를 이해해볼까 한다.&lt;br /&gt;&lt;br /&gt;다음은 How to Design Program을 도서관에서 빌려 볼까 한다.</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/464639718281976021/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/04/scheme-programming-and-meta-programming.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/464639718281976021'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/464639718281976021'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/04/scheme-programming-and-meta-programming.html' title='[리뷰][scheme] Programming and Meta-Programming in Scheme 을 읽고'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-846673243259361375</id><published>2019-04-18T22:21:00.001+09:00</published><updated>2019-04-19T18:01:10.200+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="javascript"/><category scheme="http://www.blogger.com/atom/ns#" term="lisp"/><category scheme="http://www.blogger.com/atom/ns#" term="잡소리"/><title type='text'>[SICP][scheme][javascript] 아무것도 없는 것에서 무언가를 추상화할 수 있을까?</title><content type='html'>출처 : &lt;a href=&quot;https://youtu.be/ymsbTVLbyN4&quot;&gt;https://youtu.be/ymsbTVLbyN4&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;심심할 때마다 SICP의 강의를 들어보고 있다.&lt;br /&gt;내 재주로는 사실 제대로 이해를 할 수 없는 경지임이 틀림없다. 그럼에도 조용히 넘어가다가 엄청난 것을 발견해 버렸다.&lt;br /&gt;&lt;br /&gt;바로 아래의 코드이다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(define (cons a b)&lt;br /&gt;  (lambda (pick)&lt;br /&gt;    (cond ((= pick 1) a)&lt;br /&gt;          ((= pick 2) b))))&lt;br /&gt;&lt;br /&gt;(define (car x) (x 1))&lt;br /&gt;(define (cdr x) (x 2))&lt;br /&gt;&lt;br /&gt;;; 설명을 위해 더해진 것.&lt;br /&gt;(define A (cons 1 2))&lt;br /&gt;(print (car A))&lt;br /&gt;(print (cdr A))&lt;br /&gt;&lt;/pre&gt;이 비디오를 보는 사람들 중 몇몇은 이미 이 내용을 설명할 때, 경악을 금치 못했다.&lt;br /&gt;이 코드가 왜 이리 신기한 것일까?&lt;br /&gt;그것은 이 영상의 시작부터 알아봐야 한다.&lt;br /&gt;&lt;br /&gt;이 영상의 주제는 추상화이다. 그 중에서도 데이터를 추상화하는 것인데 데이터를 추상화하면 우리에게 많은 특징(이점)이 있다.&lt;br /&gt;1. 개념적으로 부를 수 있게 된다. 우리는 그 데이터에 이름지음으로써 그것을 머릿속으로 다룰 수 있게 된다. 그것은 마치 마술사가 주문에 이름을 부여하는 것처럼 마법과 같다.&lt;br /&gt;2. 우리는 이 개념의 정확한 정의를 나중에 내릴 수 있게 된다. 일단 이름을 부름으로써 나중에 해당 개념에 대한 정의가 바뀌면 그 정의만 바꾸면 되는 것이다.&lt;br /&gt;3. (추가적인 특징) 우리는 이 추상화된 데이터를 강제할 수 있다.&lt;br /&gt;&lt;br /&gt;이 책에서 설명하는 rational number에 대해 알아보자.&lt;br /&gt;우리는 일단 데이터를 추상화 해야 한다. 분자 n, 분모 d가 있다. 이것들을 make-rat에 넣어서 하나의 패키지를 생성하는 것이다. 이것을 추상화&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(make-rat n d) =&gt; rational-number (n,d의 저장형태는 알 필요없음)&lt;br /&gt;(numer rational-number) =&gt; numerator 분자&lt;br /&gt;(denom rational-number) =&gt; denominator 분모&lt;br /&gt;&lt;/pre&gt;여기서 make-rat는 constructor, numer/denom은 selector라고 불린다.&lt;br /&gt;하나의 데이터는 이렇게 constructor와 selector로 추상화될 수 있다.&lt;br /&gt;&lt;br /&gt;이렇게 유리수를 make-rat, numer, denom으로 추상화 하였다.&lt;br /&gt;한번 더하기를 해보자.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(define (+rat x y)&lt;br /&gt;  (make-rat&lt;br /&gt;    (+ (* (numer x) (denom y))&lt;br /&gt;       (* (numer y) (denom x)))&lt;br /&gt;    (* (denom x) (denom y))))&lt;br /&gt;&lt;/pre&gt;여기서 x,y는 rational-number이다. 우리는 x,y가 어떻게 구현되어 있는지는 모르지만, make-rat으로 유리수를 만들 수 있고, numer/denom으로 꺼낼 수 있는 것은 알고 있다.&lt;br /&gt;곱하기도 만들자.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(define (*rat x y)&lt;br /&gt;  (make-rat)&lt;br /&gt;  (* (number x) (number y))&lt;br /&gt;  (* (denom x) (denom y)))&lt;br /&gt;&lt;/pre&gt;자 이제 유리수를 구현해보자. 어떻게 담아야 할까?&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(define (make-rat n d) (cons n d))&lt;br /&gt;(define (numer x ) (car x))&lt;br /&gt;(define (denom x) (cdr x))&lt;br /&gt;&lt;/pre&gt;이렇게 cons를 이용하여 pair(리스트)를 만든다.&lt;br /&gt;그러니 rational-number란 무엇인가? 이것은 사실 pair일 뿐이다. 첫번째와 두번째라는 박스가 있는 자료구조일 뿐이다.&lt;br /&gt;그렇다면 pair라는 것은 무엇인가? 이것도 또한 추상적인 개념이다. 바로!&lt;br /&gt;cons라는 constructor와 car, cdr이라는 selector가 있는 것이다. &lt;br /&gt;그렇다면 pair라는 것이 추상적인 개념이라는 무엇을 기반으로 만들어진 개념일까?&lt;br /&gt;여기서 저자는 아무것도 없는 곳에서 생성된다고 한다.&lt;br /&gt;&lt;br /&gt;그리고 등장하는 코드 (위에서 보여줬지만 다시 한번 적자. 중요하니까)&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(define (cons a b)&lt;br /&gt;  (lambda (pick)&lt;br /&gt;    (cond ((= pick 1) a)&lt;br /&gt;          ((= pick 2) b))))&lt;br /&gt;&lt;br /&gt;(define (car x) (x 1))&lt;br /&gt;(define (cdr x) (x 2))&lt;br /&gt;&lt;/pre&gt;여기에 데이터가 보이는가? 어떤 자료구조가 보이는가? &lt;br /&gt;쌩뚱맞게 lambda가 보인다. cons는 일단 procedure를 다시 리턴한다. &lt;br /&gt;그리고 pick이라는 변수를 받는데 그것이 1이면 a를 리턴하고, 2이면 b를 리턴하는 함수를 리턴한다.&lt;br /&gt;&lt;br /&gt;car를 보자. (x 1)라는 함수가 있는데, 여기서 1이 매개변수 pick에 매핑될 것이다. 첫번째 값(즉 a)이 리턴&lt;br /&gt;cdr에서는 (x 2)로써, pick=2가 되고 두번째 값(b)가 리턴된다.&lt;br /&gt;&lt;br /&gt;대체 어디에 a,b는 어떤 자료구조로 저장되는 건가? 아무것도 아닌 것에 저장되는 느낌이다.&lt;br /&gt;closure를 이해한다고 생각했는데 이 코드를 보자마자 &#39;이해한다는 것이 무엇인지조차 모르고 있었구나&#39; 라는 생각이 들었다.&lt;br /&gt;&lt;br /&gt;공부를 하면 할 수록, 항상 겸손해야 한다는 생각을 할 수 밖에 없다.&lt;br /&gt;겸손하지 않으면, 배울 수가 없으니...&lt;br /&gt;&lt;br /&gt;강의 교수님이 한 말씀을 여기 기록하지 않을 수가 없다.&lt;br /&gt;&lt;blockquote&gt;So in some sense, we don&#39;t need data at all to build these data abstractions.&lt;br /&gt;We can do everything in terms of procedures.&lt;br /&gt;&lt;br /&gt;procedures are not just the act of doing something.&lt;br /&gt;procedures are conceptual entities, objects.&lt;br /&gt;&lt;/blockquote&gt;&lt;br /&gt;강의가 끝나고 한 지적인 학생이 엄청난 질문은 하는데 그것은 바로 &lt;br /&gt;(cons 1 2)의 값과 1초 후 동일한 프로시저호출인(cons 1 2)는 동일한 녀석인가? 이다.&lt;br /&gt;&lt;br /&gt;이 말은 (+ 2 2)와 4는 동일한 녀석인가?&lt;br /&gt;&lt;br /&gt;를 고민하는 문장인데, 한시간의 수업에서 대체 이런 질문이 어떻게 나올 수 있었을까? 라는 생각이 든다.&lt;br /&gt;이 질문에 대해 교수님은 당장은 대답할 수 없지만, 곧 하게 될 것이라는 말을 하며 끝낸다.&lt;br /&gt;&lt;br /&gt;언제 저 답을 알 수 있을까? 빨리 다음을 알고 싶다.&lt;br /&gt;&lt;br /&gt;여담으로 아래 scheme코드를 js로 변경해보자.&lt;br /&gt;&lt;pre class=&#39;prettyprint lang-js&#39;&gt;function cons (a , b) {&lt;br /&gt;  return function(pick) {&lt;br /&gt;    switch(pick) {&lt;br /&gt;    case 1 : &lt;br /&gt;      return a;&lt;br /&gt;    case 2 :&lt;br /&gt;      return b;&lt;br /&gt;    default:&lt;br /&gt;      return;&lt;br /&gt;    }&lt;br /&gt;  }&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;function car(x) { return x(1); }&lt;br /&gt;function cdr(x) { return x(2); }&lt;br /&gt;&lt;br /&gt;var procedure = cons(10,20);&lt;br /&gt;&lt;br /&gt;car(procedure);&lt;br /&gt;cdr(procedure);&lt;br /&gt;&lt;/pre&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/846673243259361375/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/04/sicp.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/846673243259361375'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/846673243259361375'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/04/sicp.html' title='[SICP][scheme][javascript] 아무것도 없는 것에서 무언가를 추상화할 수 있을까?'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-2349913596076462913</id><published>2019-03-20T14:46:00.000+09:00</published><updated>2019-03-20T14:46:00.272+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="리뷰"/><category scheme="http://www.blogger.com/atom/ns#" term="잡소리"/><title type='text'>[리뷰][Coursera] 코세라의 [Concurrent Programming in Java] 수강을 마치며</title><content type='html'>Coursera에서 수강할 수 있는 Concurrent Programming의 수강을 마쳤다.&lt;br /&gt;&lt;br /&gt;이번에는 lock와 readwritelock에 대해 배웠으며, Actor의 개념도 살짝 나왔다.&lt;br /&gt;&lt;br /&gt;실제로 Actor를 제대로 구현해서 사용하는 것은 아니지만 개념정도 알고 어떻게 사용되는&lt;br /&gt;지만 알아도 Actor가 좀 더 친근해진 느낌이다.&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-Ch98EbvSZ6I/XJHS9yhj6MI/AAAAAAAABh8/Uupo5fkIz6gV13eOi6UUDDHVliQ16XIqQCLcBGAs/s1600/coursera.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;341&quot; data-original-width=&quot;710&quot; height=&quot;307&quot; src=&quot;https://4.bp.blogspot.com/-Ch98EbvSZ6I/XJHS9yhj6MI/AAAAAAAABh8/Uupo5fkIz6gV13eOi6UUDDHVliQ16XIqQCLcBGAs/s640/coursera.png&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;조금 어려운 내용이 나오기도 했지만 프로젝트 자체는 어렵지 않고, 친절하게 프로젝트 자체를 설명해주기 때문에, 잘 넘길 수 있었다. 내 생각에 이 코스에서 중요한 부분은 프로젝트 어사인먼트가 아니라 QUIZ인 것 같다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;개념을 잘 이해해야 하는 경우가 있으며, 내가 어떤 부분을 헷갈려 하는지 알 수 있기 때문에 같은 부분을 계속 듣고 확인하게 만들어 준다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;괜찮은 강의였으나, 좀 더 설명이 길었으면 하는 아쉬움이 있다.&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/2349913596076462913/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/03/coursera-concurrent-programming-in-java.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/2349913596076462913'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/2349913596076462913'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/03/coursera-concurrent-programming-in-java.html' title='[리뷰][Coursera] 코세라의 [Concurrent Programming in Java] 수강을 마치며'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://4.bp.blogspot.com/-Ch98EbvSZ6I/XJHS9yhj6MI/AAAAAAAABh8/Uupo5fkIz6gV13eOi6UUDDHVliQ16XIqQCLcBGAs/s72-c/coursera.png" height="72" width="72"/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-8881856864731369185</id><published>2019-03-05T14:23:00.000+09:00</published><updated>2019-04-26T11:25:22.173+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="javascript"/><title type='text'>[javascript] 그래서 커리를 어떻게 쓰려고?</title><content type='html'>내가 처음 커리를 써야겠다고 생각했던 것은 로직이 계속 겹치고 있었기 때문이다.&lt;br /&gt;&lt;br /&gt;예를들어보자. 인풋별로 유효성을 체크하는데 유효성을 체크할 때마다 하는일이 조금씩 다르다.&lt;br /&gt;&lt;br /&gt;&lt;pre class=&#39;prettyprint lang-js&#39;&gt;// 핸드폰 인풋 묶음 3개 유효성검사&lt;br /&gt;var phone_1 = trim($(&quot;#phone_1&quot;).val());&lt;br /&gt;var phone_2 = trim($(&quot;#phone_2&quot;).val());&lt;br /&gt;var phone_3 = trim($(&quot;#phone_3&quot;).val());&lt;br /&gt;&lt;br /&gt;if (phone_1 &lt; 3 &amp;&amp; phone_1 ...) { // 여러 and문과 유효성검사&lt;br /&gt;  $(&quot;#phone_1&quot;).focus();&lt;br /&gt;  alert(&quot;휴대폰 유효성검사실패&quot;);&lt;br /&gt;  return;&lt;br /&gt;}&lt;br /&gt;... phone_2, phone_3&lt;br /&gt;&lt;br /&gt;$(&quot;#hidden_phone_&quot;).val(phone_1 + &quot;-&quot; phone_2 + &quot;-&quot; + phone_3);&lt;br /&gt;&lt;/pre&gt;이런 코드가 있다. 익숙하다. 일단 커리를 쓰기 전에 여기서 if문에 있는 모든 유효성검사는 하나의 함수로 추상화 해놓자. &lt;pre class=&#39;prettyprint lang-js&#39;&gt;if (validate(phone_1) { // 여러 and문과 유효성검사&lt;br /&gt;  $(&quot;#phone_1&quot;).focus();&lt;br /&gt;  alert(&quot;휴대폰 유효성검사실패&quot;);&lt;br /&gt;  return;&lt;br /&gt;}&lt;br /&gt;if (validate(phone_2) {&lt;br /&gt;  $(&quot;#phone_2&quot;).focus();&lt;br /&gt;  alert(&quot;휴대폰 유효성검사실패&quot;);&lt;br /&gt;  return;&lt;br /&gt;}&lt;br /&gt;if (validate(phone_3) {&lt;br /&gt;  $(&quot;#phone_3&quot;).focus();&lt;br /&gt;  alert(&quot;휴대폰 유효성검사실패&quot;);&lt;br /&gt;  return;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;이런 코드를 본 적 없는가? 여기서 분명 우리는 뭔가 더 할 수 있을 것 같다. 어떻게 해야 할까? 맞다 객체를 넘기는 것이다.  &lt;pre class=&#39;prettyprint lang-js&#39;&gt;function validateAndFocus(phone, $phone) {&lt;br /&gt;  if (!validatePhone(phone) {&lt;br /&gt;    alert(&quot;휴대폰 유효성검사 실패&quot;);  &lt;br /&gt;    $phone.focus();&lt;br /&gt;    return false;&lt;br /&gt;  }&lt;br /&gt;  return true;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;이제 이걸 사용해보자 &lt;pre class=&#39;prettyprint lang-js&#39;&gt;if(!validateAndFocus(phone_1, $(&quot;#phone_1&quot;)) {&lt;br /&gt;  return;&lt;br /&gt;}&lt;br /&gt;if(!validateAndFocus(phone_2, $(&quot;#phone_2&quot;)) {&lt;br /&gt;  return;&lt;br /&gt;}&lt;br /&gt;if(!validateAndFocus(phone_3, $(&quot;#phone_3&quot;)) {&lt;br /&gt;  return;&lt;br /&gt;}&lt;br /&gt;...&lt;br /&gt;&lt;/pre&gt;뭔가 여기도 겹치는 것 같다. &lt;pre class=&#39;prettyprint lang-js&#39;&gt;if (!(validateAndFocus(phone_1, $(&quot;#phone_1&quot;)) &amp;&amp;&lt;br /&gt;      validateAndFocus(phone_2, $(&quot;#phone_2&quot;)) &amp;&amp;&lt;br /&gt;      validateAndFocus(phone_3, $(&quot;#phone_3&quot;))) {&lt;br /&gt;  return;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;undersocre.js의 and가 있다면 더 좋을 것 같다. 끝이 없을 것 같으니 여기서 넘어가자. underscore를 쓸 수 없어서 curry만 임시 사용하는 것이다. 이정도만 깔끔해보인다.  그런데 여기 주민번호와 카드번드까지 추가되었다. &lt;pre class=&#39;prettyprint lang-js&#39;&gt;var card1 = $(&quot;#card1&quot;);&lt;br /&gt;var card2 = $(&quot;#card2&quot;);&lt;br /&gt;var card3 = $(&quot;#card3&quot;);&lt;br /&gt;var card4 = $(&quot;#card4&quot;);&lt;br /&gt;&lt;br /&gt;var national_id_1 = $(&quot;#national_id&quot;);&lt;br /&gt;var national_id_2 = $(&quot;#national_id&quot;);&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;우리는 validateAndFocus를 사용할 수 있는가? 사용할 수 없다.  1. 휴대폰번호의 유효성과 아이디의 유효성은 다르다. (predicate의 분리 필요) 2. 유효성 검사 이후 하는 일이 각각 다를 것이다.  하지만 형태는 동일하다.  1. 주어진 값의 유효성을 검사한다. 2. 통과하면 true 실패하면 false를 리턴한다. 3. 유효성검사에 실패하여 false를 리턴하기 전에 각각 해야하는 일이 있다.  &lt;pre class=&#39;prettyprint lang-js&#39;&gt;// 동일한 형태의 일을 하는 함수 템플릿 정의&lt;br /&gt;function validateTemplate(pred, func, obj1, obj2, obj3) {&lt;br /&gt;  if (pred(obj1, obj2, obj3)) {&lt;br /&gt;    func(obj1, obj2, obj3);&lt;br /&gt;    return false;&lt;br /&gt;  }&lt;br /&gt;  return true;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;자 이 형태를 만들었다. 이제 어떻게 사용할지 보자. 유효성 검사를 분리해서 넣을 것이다. 그렇다면 이렇게 될 것이다. &lt;pre class=&#39;prettyprint lang-js&#39;&gt;var curried = curry(validateTemplate);&lt;br /&gt;var validatePhoneCurried = curried(function(n) {&lt;br /&gt;  return validatePhone(n);&lt;br /&gt;});&lt;br /&gt;var validateCardCurried = curreid(function(n) {&lt;br /&gt;  return validatePhone(n);&lt;br /&gt;});&lt;br /&gt;var validateNationalidCurreid = curried(function(n) {&lt;br /&gt;  return validateNationalid(n);&lt;br /&gt;});&lt;br /&gt;&lt;/pre&gt;뭐 대충 이렇게 코딩했다. 현재까지는 pred를 커리하고 이제는 각 pred마다 할일을 다르게 넣을 수 있겠다. 첫번째 인자를 _로 한 이유는 focus나 val(&quot;&quot;) 등 DOM조작을 위한 객체를 따로 넘긴다고 하자.  &lt;pre class=&#39;prettyprint lang-js&#39;&gt;var validatePhoneFinal = validatePhoneCurried(function(_, $dom) {&lt;br /&gt;  alert(&quot;헨드폰문제!&quot;);&lt;br /&gt;  $dom.focus();&lt;br /&gt;});&lt;br /&gt;&lt;br /&gt;var validateCardFinal = validateCardCurried(function(_, $dom) {&lt;br /&gt;  alert(&quot;카드문제&quot;);&lt;br /&gt;  $dom.focus();&lt;br /&gt;});&lt;br /&gt;&lt;br /&gt;var validateNationalidFinal = validateNationalidCurreid (function(_, $dom) {&lt;br /&gt;  alert(&quot;주민번호문제&quot;);&lt;br /&gt;  $dom.focus();&lt;br /&gt;});&lt;br /&gt;&lt;/pre&gt;이렇게 만들었다 치자. 이제 위에 코드를 저것들로 바꾸면 된다.  &lt;pre class=&#39;prettyprint lang-js&#39;&gt;if (!(validatePhoneFinal(phone_1, $(&quot;#phone_1&quot;)) &amp;&amp;&lt;br /&gt;      validatePhoneFinal(phone_2, $(&quot;#phone_2&quot;)) &amp;&amp;&lt;br /&gt;      validatePhoneFinal(phone_3, $(&quot;#phone_3&quot;))) {&lt;br /&gt;  return;&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;....&lt;br /&gt;if (!(validateCardFinal(card_1, $(&quot;#card_1&quot;)) &amp;&amp;&lt;br /&gt;      validateCardFinal(card_2, $(&quot;#card_2&quot;)) &amp;&amp;&lt;br /&gt;      validateCardFinal(card_3, $(&quot;#card_3&quot;)) &amp;&amp;&lt;br /&gt;      validateCardFinal(card_4, $(&quot;#card_4&quot;))) {&lt;br /&gt;  return;&lt;br /&gt;}&lt;br /&gt;...&lt;br /&gt;if (!(validateNationalidFinal(national_id_1 , $(&quot;#national_id_1&quot;)) &amp;&amp;&lt;br /&gt;      validateNationalidFinal(national_id_2 , $(&quot;#national_id_2&quot;))) {&lt;br /&gt;  return;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;여기서 map이나 every 같은 것을 이용하는 것이 큰 도움이 될 것 같지만 그러진 않겠다. 오늘의 주제는 커리니까.&lt;br /&gt;curry라는 함수 한번 가지고 놀아봤다.</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/8881856864731369185/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/03/javascript.html#comment-form' title='1개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/8881856864731369185'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/8881856864731369185'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/03/javascript.html' title='[javascript] 그래서 커리를 어떻게 쓰려고?'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-1699128134452574565</id><published>2019-03-05T10:11:00.001+09:00</published><updated>2019-03-05T10:11:34.774+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="javascript"/><title type='text'>[javascript]자바스크립트 curry 구현소스를 파악해보자.</title><content type='html'>출처 : &lt;br /&gt;https://edykim.com/ko/post/writing-a-curling-currying-function-in-javascript/&lt;br /&gt;https://medium.com/@kevincennis/currying-in-javascript-c66080543528&lt;br /&gt;&lt;br /&gt;커링이라는 개념은 하스켈을 공부할 당시 알게 되었다.&lt;br /&gt;clojure의 partial과 비슷한 개념이다. (동일한가?)&lt;br /&gt;&lt;br /&gt;여튼 자바스크립트로 curry를 쓰고 싶은 욕구가 강했지만, underscore.js같은 라이브러리를 사용할 수 없는 제약이 있어,&lt;br /&gt;다른 누군가가 어떻게 curry만을 구현했는지 확인하고 복붙을 하기로 하였다.&lt;br /&gt;&lt;br /&gt;그 중에 위의 링크를 확인했고 하나하나 파고들어갔다. 아래 내용은 위 블로그를 읽고 나만의 부연설명을 추가한 것이다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;pre class=&#39;prettyprint lang-js&#39;&gt;function curry(fn) {&lt;br /&gt; var arity = fn.length; // 함수의 필요 인자&lt;br /&gt; // 매번 curry된 함수를 호출할 때마다 새로운 인자를 배열에 넣어 클로저 내에 저장한다.&lt;br /&gt; // 배열의 길이는 fn.length와 동일해야 한다. (실행될 때)&lt;br /&gt; // 혹여 인자의 수가 동일하지 않으면 새로운 함수로 반환한다.&lt;br /&gt; &lt;br /&gt; // 인자 목록을 가지는 클로저가 필요하다 (함수로 둘러쌓아야 한다 &lt;br /&gt; // 또 여기서 개별의 클로저가 생성되야 하니까 즉시 실행함수로 만든다.)&lt;br /&gt; // 전체인자(배열)과 fn.length를 확인&lt;br /&gt; // 인자의 수가 부족하면 부분적으로 적용된 함수를 반환 &lt;br /&gt; // 인자의 수가 충족하면 fn에 모든 인자를 적용,호출하여 리턴&lt;br /&gt; return (function resolver() {&lt;br /&gt;  // 지금까지 받은 인자를 복사한다.  // 이전 클로저가 오염되지 말게&lt;br /&gt;  var memory = Array.prototype.slice.call(arguments);&lt;br /&gt;  // resolver는 익명함수를 반환한다. &lt;br /&gt;  // resolver는 인자가 부족할 때 반환한다.&lt;br /&gt;  // resolver가 새로 반환되는 이유는 클로저를 위한 것같다.&lt;br /&gt;  &lt;br /&gt;  // resolver는 바로 실행되고 익명함수를 하나 리턴한다.&lt;br /&gt;  // resolver가 이전까지 모은 인자를 가지고 있다. (memory)&lt;br /&gt;  // 이걸 변수에 담았다가 나중에 실행시킬 것이다.&lt;br /&gt;  // 실행시키면 arguments에서 인자를 memory와 합체한다.&lt;br /&gt;  // 그리고 원래 실행되어야할 함수(fn)이 필요로 하는 인자의 갯수와 비교&lt;br /&gt;  // 지금까지 모은 인자(local)과 arity의 길이가 맞다면&lt;br /&gt;  // 원래함수를 호출(fn), 그렇지 않으면 resolver를 다시 반환 (인자를 더 받는다)&lt;br /&gt;  return function() {  &lt;br /&gt;   var local = memory.slice();&lt;br /&gt;   Array.prototype.push.apply(local, arguments);&lt;br /&gt;   next = local.length &gt;= arity ? fn : resolver;&lt;br /&gt;   return next.apply(null, local);&lt;br /&gt;  };&lt;br /&gt; }());&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;한번 생성한 커리에 함수를 넣어보자. 지금 함수를 넣으면 인자 fn에 들어가는 것이다.&lt;br /&gt;====&lt;br /&gt;&lt;pre class=&#39;prettyprint lang-js&#39;&gt;function volume(l, w, h) {&lt;br /&gt;  return l * w * h;&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;var curried = curry(volume);&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;이제 아래 코드를 보면서 어떻게 되는지 보자.&lt;br /&gt;&lt;pre class=&#39;prettyprint lang-js&#39;&gt;function curry(fn) {&lt;br /&gt; var arity = fn.length; // 1. 숫자 3이 저장된다.&lt;br /&gt; return (function resolver() {&lt;br /&gt;  var memory = Array.prototype.slice.call(arguments); // 2. resolver를 인자없이 실행하였다.(현재는 커리만 되는 상태)&lt;br /&gt;  &lt;br /&gt;  return function() {&lt;br /&gt;   var local = memory.slice();&lt;br /&gt;   Array.prototype.push.apply(local, arguments);&lt;br /&gt;   next = local.length &gt;= arity ? fn : resolver;  // 3. arity가 부족하므로 함수를 리턴.&lt;br /&gt;   return next.apply(null, local);&lt;br /&gt;  };&lt;br /&gt; }());&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;함수를 리턴받아서 curried에 넣었다. 여기에 다른 인자들을 넣어보자. &lt;br /&gt;일단 2를 넣을 것인데 l, w, h 총 3개가 필요한 함수에게는 부족한 인자 갯수이다.&lt;br /&gt;&lt;pre class=&#39;prettyprint lang-js&#39;&gt;var length = curried(2);&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;어떤 일이 일어나는지 아래를 보자.&lt;br /&gt;&lt;pre class=&#39;prettyprint lang-js&#39;&gt;function curry(fn) {&lt;br /&gt; var arity = fn.length; &lt;br /&gt; return (function resolver() {&lt;br /&gt;  var memory = Array.prototype.slice.call(arguments);&lt;br /&gt;  &lt;br /&gt;  return function() {  // 1. resolver로 반환된 익명함수가 실행됨. &lt;br /&gt;   var local = memory.slice();  // 2. memory는 현재 0개의 인자를 가지고 있다. &lt;br /&gt;   Array.prototype.push.apply(local, arguments);  // 3.이번에 추가된 2가 local에 push된다.&lt;br /&gt;   next = local.length &gt;= arity ? fn : resolver;  // 4.아직 인자가 1개이기 때문에 다시 resolver를 반환한다.&lt;br /&gt;   return next.apply(null, local);  // 4. 알다시피 이번에 던져지는 resolver는 또한 새로운 클로저와 함께하는 새로운 함수다.&lt;br /&gt;  };&lt;br /&gt; }());&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;한번 더&lt;br /&gt;&lt;pre class=&#39;prettyprint lang-js&#39;&gt;var lengthAndWidth = length( 3 );&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;pre class=&#39;prettyprint lang-js&#39;&gt;function curry(fn) {&lt;br /&gt; var arity = fn.length; &lt;br /&gt; return (function resolver() {&lt;br /&gt;  var memory = Array.prototype.slice.call(arguments);&lt;br /&gt;  &lt;br /&gt;  return function() {  &lt;br /&gt;   var local = memory.slice();  // 1. 새로운 클로저에 들어있는 memory는 [2] 이다. local에 복사한다. (이전 클로저에 해를 끼치지 않게)&lt;br /&gt;   Array.prototype.push.apply(local, arguments);  // 2. 새로운 인자 3을 추가한다. [2,3]&lt;br /&gt;   next = local.length &gt;= arity ? fn : resolver;  // 3.아직 인자가 2개이기 때문에 다시 resolver를 반환한다.&lt;br /&gt;   return next.apply(null, local);  // 4. 알다시피 이번에 던져지는 resolver는 또한 새로운 클로저와 함께하는 새로운 함수다.&lt;br /&gt;  };&lt;br /&gt; }());&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;이제 마지막으로 하나의 인자만 더 넣으면 실행될 것이다.&lt;br /&gt;&lt;pre class=&#39;prettyprint lang-js&#39;&gt;console.log( lengthAndWidth( 4 ) ); // 24&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;왜 그렇게 되는지 아래를 보자.&lt;br /&gt;&lt;pre class=&#39;prettyprint lang-js&#39;&gt;function curry(fn) {&lt;br /&gt; var arity = fn.length; &lt;br /&gt; return (function resolver() {&lt;br /&gt;  var memory = Array.prototype.slice.call(arguments);&lt;br /&gt;  &lt;br /&gt;  return function() {  &lt;br /&gt;   var local = memory.slice();  // 1. 새로운 클로저에 들어있는 memory는 [2,3] 이다. local에 복사한다. (이전 클로저에 해를 끼치지 않게)&lt;br /&gt;   Array.prototype.push.apply(local, arguments);  // 2. 새로운 인자 4을 추가한다. [2,3,4]&lt;br /&gt;   next = local.length &gt;= arity ? fn : resolver;  // 3.아직 인자가 3개이기 때문에 fn을 넣는다. (fn은 지금까지 변경된 적도 사용된 적도 있다. 하지만 이날을 위해 기다렸다)&lt;br /&gt;   return next.apply(null, local);  // 4. 이번에는 함수를 던지지 않고 fn의 리턴값이 실행될 것이다. (하지만 fn이 리턴하는게 함수라면... 음...)&lt;br /&gt;  };&lt;br /&gt; }());&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/1699128134452574565/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/03/javascript-curry.html#comment-form' title='2개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/1699128134452574565'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/1699128134452574565'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/03/javascript-curry.html' title='[javascript]자바스크립트 curry 구현소스를 파악해보자.'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-285315439930578296</id><published>2019-02-15T12:02:00.002+09:00</published><updated>2019-02-15T12:02:19.308+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="clojure"/><category scheme="http://www.blogger.com/atom/ns#" term="잡소리"/><title type='text'>[clojure] 4clojure easy버전 0에서 50까지 문제 풀고 중간점검</title><content type='html'>clojure로 뭘 할지 감이 잡히지 않아서, 그냥 4clojure나 가끔씩 풀어보기로 했다.&lt;br /&gt;elementary, easy부분만 풀었는데 괜찮았다. 글자그대로 쉬웠지만 어떤 것들은 꽤나 생각을 해야 했다.&lt;br /&gt;4clojure를 풀다보면 내 뇌의 생각하는 방식이 바뀌어야 한다는 느낌이 든다. 운동을 할 때도 가동범위가 중요한데, 사용하지 않던 뇌부분을 사용한 느낌이 들면서, 나의 뇌 가동범위가 부족한 것이 아닌가 싶었다.&lt;br /&gt;&lt;br /&gt;clojure로 언젠가 개발을 하지 않더라도, 이 문제를 풀면서 뭔가 개발을 할 때 생각하는 방식이 늘어나는 느낌을 받을 것 같다. (좀더 난이도가 올라가면 말이다)&lt;br /&gt;&lt;br /&gt;결과적으로 4clojure를 풀기로 결심한 것은 만족이다.&lt;br /&gt;&lt;a href=&quot;https://github.com/ssisksl77/clj-web-demo/blob/master/src/web_demo/4clojure/elementary.clj&quot;&gt;https://github.com/ssisksl77/clj-web-demo/blob/master/src/web_demo/4clojure/elementary.clj&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;51~100도 금방 가자.</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/285315439930578296/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/02/clojure-4clojure-easy-0-50.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/285315439930578296'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/285315439930578296'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/02/clojure-4clojure-easy-0-50.html' title='[clojure] 4clojure easy버전 0에서 50까지 문제 풀고 중간점검'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-4150474332220079634</id><published>2019-02-14T10:28:00.003+09:00</published><updated>2019-02-14T11:06:48.036+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="리뷰"/><category scheme="http://www.blogger.com/atom/ns#" term="잡소리"/><title type='text'>[리뷰][Coursera] 코세라의 [Parallel Programming in Java] 수강을 마치며</title><content type='html'>코세라에서 수강할 수 있는 병렬프로그램의 첫번째 코스를 마쳤다.&lt;br /&gt;생각보다 어렵지 않았다.&lt;br /&gt;&lt;br /&gt;1. 병렬프로그램 개발을 하기 이전에 나의 코드를 분석할 수 있는 기본적인 방법을 알려준다. WORK, SPAN 등등&lt;br /&gt;2. Fork/Join Framework에 대해서 설명한다.&lt;br /&gt;3. Future에 대해서 배운다.&lt;br /&gt;4. Barrier를 배운다.&lt;br /&gt;5. Phaser를 배운다.&lt;br /&gt;6. Phaser를 이용한 다양한 예시를 배운다.&lt;br /&gt;&lt;br /&gt;사실 이번 강의에서 인상깊었던 것은 4주차에서 배운 Phaser라는 기능이다. 이 기능은 정말 멋지다. 동기화에 대한 많은 생각을 해주게 하는 기능이다. 아니 Latch와 Barrier 이상으로 뭔가 더 동기화 해야할 일이 있단 말인가?&lt;br /&gt;&lt;br /&gt;여기에선 있다고 말한다. 아쉬웠던 점은 project assignment가 너무 쉽다. 그냥 수강한 걸보고 배운데로 하면 된다. 좀 더 어려웠으면 하기도 하지만, 그러면 다 fail을 할 수도 있겠다고 생각한 걸까? 예시로 동기화를 하는 기능은 정말 많은 이해가 되었지만, 비동기 통신을 하는 것 자체는 전부 주어진 메소드로 실행해야 하기 때문에 처음부터 만들지는 않는다.&lt;br /&gt;&lt;br /&gt;코스가 끝나면 아래처럼 링크드인에 Certificate을 넣을 수 있다.&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://2.bp.blogspot.com/-U8Y_v4qn05o/XGTB6ch8gkI/AAAAAAAABhA/kwKJewbRNi0_B3ynYm_6XgEnXh3B5JNAQCLcBGAs/s1600/%25EC%2582%25AC%25EC%259D%25B4%25ED%258A%25B8%25ED%2598%2584%25ED%2599%25A9.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;219&quot; data-original-width=&quot;721&quot; height=&quot;120&quot; src=&quot;https://2.bp.blogspot.com/-U8Y_v4qn05o/XGTB6ch8gkI/AAAAAAAABhA/kwKJewbRNi0_B3ynYm_6XgEnXh3B5JNAQCLcBGAs/s400/%25EC%2582%25AC%25EC%259D%25B4%25ED%258A%25B8%25ED%2598%2584%25ED%2599%25A9.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;그리고 주어진 값을 넣으면 링크드인의 자격증명에 보이기 시작한다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;&lt;a href=&quot;https://www.linkedin.com/in/ssisksl77/&quot;&gt;https://www.linkedin.com/in/ssisksl77/&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;4주 짜리긴 한데 2주만에 끝났다. 이외로 내용이 길지 않았다.&lt;br /&gt;꽤나 후련하다.&lt;br /&gt;3월 쯔음에나 두번째 코스로 들어가지 않을까 싶다.&lt;br /&gt;&lt;br /&gt;꽤나 기대된다. 두번째 코스도 내용이 긴 것 같지는 않다.&lt;br /&gt;하지만 액터모델이라는 것이 꽤나 기대된다.&lt;br /&gt;&lt;br /&gt;이러다가 스칼라를 공부해야 하는 지도 모르겠다.&lt;br /&gt;사실 스칼라에 손을 대지 않은 이유는 온전히 나의 고집이었다.&lt;br /&gt;그저 Clojure가 더 낫지 않을까 하는 나의 근거없는 확신 때문에 가끔씩 4Clojure나 풀면서 &quot;나는 괜찮은 개발자야&quot; 라고 자위했다.&lt;br /&gt;&lt;br /&gt;하지만 둘 다 한다고 더 많은 시간을 들일 것 같지도 않고, 함수형 프로그래밍에 Clojure와 하스켈 맛보기만으로는 아직 잘 모르겠다. (사실 하스켈은 이제... 모나드나 어플리커티브 펑터를 배운 이후로 별로 하고 싶지 않다. 그래도 모나드를 배운 것은 정말 유용했다.)&lt;br /&gt;&lt;br /&gt;일단 바로 할지는 모르겠고, Coursera에서 스칼라를 이용한 함수형 프로그래밍 강의가 있는데 함수형 프로그래밍에 대해 더 알기 위해서라도 익혀놔야겠다.</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/4150474332220079634/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/02/coursera-parallel-programming-in-java.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/4150474332220079634'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/4150474332220079634'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/02/coursera-parallel-programming-in-java.html' title='[리뷰][Coursera] 코세라의 [Parallel Programming in Java] 수강을 마치며'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://2.bp.blogspot.com/-U8Y_v4qn05o/XGTB6ch8gkI/AAAAAAAABhA/kwKJewbRNi0_B3ynYm_6XgEnXh3B5JNAQCLcBGAs/s72-c/%25EC%2582%25AC%25EC%259D%25B4%25ED%258A%25B8%25ED%2598%2584%25ED%2599%25A9.png" height="72" width="72"/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-2137260670698661882</id><published>2019-02-07T20:35:00.001+09:00</published><updated>2019-02-13T17:11:29.722+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="java"/><category scheme="http://www.blogger.com/atom/ns#" term="리뷰"/><category scheme="http://www.blogger.com/atom/ns#" term="자바"/><category scheme="http://www.blogger.com/atom/ns#" term="잡소리"/><title type='text'>코세라에서 병렬프로그래밍을 배우기 시작했다 (1주차)</title><content type='html'>코세라에서 제공하는 Parallel Programming in Java 라는 코스를 듣게 되었다.&lt;br /&gt;1주차 내용을 Fork/Join 프레임워크에 대한 설명이었다. 사실 프레임워크를 설명하는 것보다는 병렬프로그래밍을 할 때 사용하는 기본적인 패턴을 가르쳐주었으며,&lt;br /&gt;우리가 나중에 만들 병렬프로그램 설계를 분석하는 방법을 알려준다.(암달의 법칙을 빠지지 않는다.)&lt;br /&gt;&lt;br /&gt;1주차를 들으면서 든 생각은 [생각보다 괜찮다]였다. 내용이 잘 짜여져 있고, 가르쳐주는 강사님(교수님?) 또한 아주 잘 가르쳐주신다. (한글 자막은 없다, 코세라는 재능기부를 기다리고 있다.)&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-x8e-cjMpjCs/XFwXOxIV4nI/AAAAAAAABgY/cRLviMhET1M3ekJGqNJa6iHrzxxW5SpMQCLcBGAs/s1600/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%2B2019-02-07%2B%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE%2B8.23.12.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;826&quot; data-original-width=&quot;1597&quot; height=&quot;206&quot; src=&quot;https://1.bp.blogspot.com/-x8e-cjMpjCs/XFwXOxIV4nI/AAAAAAAABgY/cRLviMhET1M3ekJGqNJa6iHrzxxW5SpMQCLcBGAs/s400/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%2B2019-02-07%2B%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE%2B8.23.12.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;또한 괜찮은 것은 바로 assignment다 직접 코딩을 하고 점수를 받는 것이다. 필자는 이것을 푸는데 꽤나 오랜시간이 걸렸다. 1시간 정도 걸린 것 같다. 풀고 보니 별 것 아니었다. 병렬프로그래밍이나 Fork/Join 프레임워크에 익숙하다면 풀기 쉬울 것이다. 그렇지 않다면 약간 버벅이면서 풀 수 있는 정도였다.&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-EWvgx7Fs0gU/XFwXACVTcZI/AAAAAAAABgQ/HrmC9kUIRSwqNwGHV3qZXC5Qfeezwpd8ACLcBGAs/s1600/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%2B2019-02-07%2B%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE%2B8.22.53.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;737&quot; data-original-width=&quot;1555&quot; height=&quot;190&quot; src=&quot;https://3.bp.blogspot.com/-EWvgx7Fs0gU/XFwXACVTcZI/AAAAAAAABgQ/HrmC9kUIRSwqNwGHV3qZXC5Qfeezwpd8ACLcBGAs/s400/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%2B2019-02-07%2B%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE%2B8.22.53.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;2주차가 기대된다.&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;/div&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/2137260670698661882/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/02/1.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/2137260670698661882'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/2137260670698661882'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/02/1.html' title='코세라에서 병렬프로그래밍을 배우기 시작했다 (1주차)'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://1.bp.blogspot.com/-x8e-cjMpjCs/XFwXOxIV4nI/AAAAAAAABgY/cRLviMhET1M3ekJGqNJa6iHrzxxW5SpMQCLcBGAs/s72-c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%2B2019-02-07%2B%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE%2B8.23.12.png" height="72" width="72"/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-2501945764332353049</id><published>2019-01-17T13:56:00.001+09:00</published><updated>2019-01-17T13:56:29.967+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="lisp"/><title type='text'>[on lisp] 5.6 Recursion on Subtrees </title><content type='html'>5.6 Recursion on Subtrees&lt;br /&gt;리스프 프로그램에서 흔히 볼 수 있는 또 다른 재귀 패턴이 있다. 서브트리의 재귀&lt;br /&gt;이 패턴은 중첩 리스트로 시작하여 car와 cdr을 모두 재귀적으로 사용하려는 경우에 나타남.&lt;br /&gt;&lt;br /&gt;lisp 리스트는 다재다능한 구조이다. 리스트는 시퀀스, 세트, 매핑, 배열 및 트리를 나타낼 수 있다.&lt;br /&gt;리스트를 트리로 해석하는 몇 가지 방법이 있다. 가장 보편적인 것은 왼쪽 가지가 car이고 오른쪽 가지가 cdr인 이진 트리로 간주하는 것이다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;;; Figure 5.7: Lists as trees.&lt;br /&gt;(a . b) &lt;br /&gt;(a b c) &lt;br /&gt;(a b (c d))&lt;br /&gt;&lt;/pre&gt;만약 리스트가 아래와 같은 형태로 고려되면 쉽게 해석할 수 있다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(a b c) = (a . (b . (c . nil))) &lt;br /&gt;(a b (c d)) = (a . (b . ((c . (d . nil)) . nil)))&lt;br /&gt;&lt;/pre&gt;어떠한 형태의 리스트도 2진트리로 해석될 수 있다. copy-list와 copy-tree와 같은 공통 리스프 함수의 쌍 간의 구별을 돕는다.&lt;br /&gt;전자는 리스트를 시퀀스로 간주하고 복사한다. 만약 리스트에 서브리스트(sublists)를 보유한다면, 그것이 해당 리스트의 요소일 뿐이라도 복사되지 않는다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(setq x &#39;(a b) listx (list x 1))&lt;br /&gt;((A B) 1)&lt;br /&gt;(eq x (car (copy-list listx)))&lt;br /&gt;T&lt;br /&gt;;; copy-list구현을 다시 보자.&lt;br /&gt;;; copy-list&lt;br /&gt;(lrec #&#39;(lambda (x f) (cons x (funcall f))))&lt;br /&gt;;; Figure 5.5: Function to deﬁne ﬂat list recursers&lt;br /&gt;;; 이전에 본 소스임.&lt;br /&gt;;; 특이하게 함수를 리턴함&lt;br /&gt;(defun lrec (rec &amp;optional base) &lt;br /&gt;  (labels ((self (lst) &lt;br /&gt;    (if (null lst) &lt;br /&gt;     (if (functionp base) &lt;br /&gt;      (funcall base) &lt;br /&gt;   base) &lt;br /&gt;  (funcall rec (car lst) &lt;br /&gt;               #&#39;(lambda () (self (cdr lst))))))) &lt;br /&gt; #&#39;self))&lt;br /&gt;&lt;br /&gt;;; 반대로 copy-tree는 리스트를 트리로 간주한다.&lt;br /&gt;;; 서브리스트들 전부 복사된다.&lt;br /&gt;(eq x (car (copy-tree listx)))&lt;br /&gt;NIL&lt;br /&gt;&lt;/pre&gt;copy-tree구현체를 봐보자.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(defun our-copy-tree (tree)&lt;br /&gt;  (if (atom tree)&lt;br /&gt;      tree&lt;br /&gt;      (cons (our-copy-tree (car tree))&lt;br /&gt;            (if (cdr tree) (our-copy-tree (cdr tree))))))&lt;br /&gt;&lt;/pre&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/2501945764332353049/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-56-recursion-on-subtrees.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/2501945764332353049'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/2501945764332353049'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-56-recursion-on-subtrees.html' title='[on lisp] 5.6 Recursion on Subtrees '/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-742594658228457442</id><published>2019-01-17T10:13:00.000+09:00</published><updated>2019-01-17T10:13:02.208+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="lisp"/><title type='text'>[on lisp] 5.2 Orthogonality (직교성)</title><content type='html'>5.2 Orthogonality (직교성)&lt;br /&gt;&lt;br /&gt;An orthogonal language is one in which you can express a lot by combining a small number of operators a lot of different ways.&lt;br /&gt;직교 언어는 많은 다른 방식으로 소수의 연산자를 결합하여 많은 것을 표현할 수 있는 언어이다.&lt;br /&gt;&lt;br /&gt;장난감 블록은 서로 직각이다. 플라스틱 모델 키트는 전혀 직각이 아니다. &lt;br /&gt;complement의 가장 큰 장점을 언어를 보다 직관적으로 만든다.&lt;br /&gt;complement 이전, Common Lisp는 remove-if, remove-if-not 혹은 subst-if, subst-if-not 같은 함수 쌍들이 있었다.&lt;br /&gt;이제는 complement를 통해 그들 중 절반이 없어도 일이 가능하다.&lt;br /&gt;&lt;br /&gt;setf 매크로 또한 Lisp의 직교성을 향상시킨다.&lt;br /&gt;이전의 Lisp방언은 종종 데이터 읽기와 쓰기를 위한 함수 쌍을 가지고 있었다.&lt;br /&gt;예를들어, property-lists에서는 속성을 설정하는 한 가지 기능과 그 속성에 대해 질의 하는 다른 기능이 있다.&lt;br /&gt;Common Lisp에는 후자만 있다. 속성을 설정하려면 setf와 함께 사용하면 된다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;;; Figure 5.1: Returning destructive equivalents.&lt;br /&gt;(setf (get &#39;ball &#39;color) &#39;red)&lt;br /&gt;&lt;br /&gt;(defvar *!equivs* (make-hash-table))&lt;br /&gt;&lt;br /&gt;(defun ! (fn)&lt;br /&gt;  (or (gethash fn *!equivs*) fn))  ;; 해시맵에 들어간 함수를 가져온다.&lt;br /&gt;&lt;br /&gt;(defun def! (fn fn!) &lt;br /&gt;  (setf (gethash fn *!equivs*) fn!))  ;; 파괴적인 해시맵을 가져와서 fn의 키값에 fn!를 넣는다.&lt;br /&gt;&lt;/pre&gt;우리는 Common Lisp를 더 작게 만들지는 못하겠지만, 거의 비슷한 것을 할 수 있다: use a smller subset of it(더 작은 부분 집합을 사용하라)&lt;br /&gt;complement함수와 setf함수 같이 새로운 operator(연산자)를 정의하면 이 목표를 달성하는데 도움이 될까?&lt;br /&gt;기능을 쌍으로 그룹화하는 방법은 적어도 한 가지 더 있다.(반대기능을 하는 걸로 그룹핑하는 것 외에 다른방식으로 그룹핑할 수도 있다.)&lt;br /&gt;remove-if와 delete-if, reverse와 nreverse, append와 nconc와 같이 많은 기능이 파괴적인 버전(desctructive version)을 쌍으로 제공한다.&lt;br /&gt;이렇게 파괴적인,비파괴적인 함수를 대응(쌍)으로 연산자를 정의함으로써, 파괴함수를 직접 참조하지 않아도 된다.&lt;br /&gt;&lt;br /&gt;Figure 5.1은 파괴적인 대응(쌍) 개념을 지원하는 코드를 포함하고있다.&lt;br /&gt;일단 *!equivs*는 글로벌 변수이며 (make-hash-table)로 파괴적인 함수에 매핑된다.&lt;br /&gt;느낌표(!)는 파괴적인 동등을 반환한다.&lt;br /&gt;def!는 그것들을 설정한다. &lt;br /&gt;!(bang)연산자의 이름은 Scheme규약에 따온 것인데 !가 사이드이펙트를 생성한다는 것이다.&lt;br /&gt;자 이제 우리가 정의를 해보자.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(def! #&#39;remove-if #&#39;delete-if)&lt;br /&gt;;; 이제 아래처럼 할 필요없이&lt;br /&gt;(delete-if #&#39;oddp lst)&lt;br /&gt;;; 아래처럼 사용한다.&lt;br /&gt;(funcall (! #&#39;remove-if) #&#39;oddp lst)&lt;br /&gt;;; 여기 Common Lisp의 어색함(awkwardness)는 &lt;br /&gt;;; Scheme에서 더 잘 볼 수 있는 생각의 우아함을 숨긴다.&lt;br /&gt;;; 아래가 스킴이 생각하는 무언가인듯. 꽤나 우아하다.&lt;br /&gt;((! remove-if) oddp lst)&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;특이하게 조립을 한다.&lt;br /&gt;더 큰 직교성 뿐만 아니라, !연산자는 몇 가지 다른 이점을 가지고 있다.&lt;br /&gt;프로그램을 더 선명하게 만든다. 왜냐하면 우리는 즉시 (! #&#39;foo)가 foo와 같지만(여기에는 호출방식도 같고) 파괴적인 것을 볼 수 있다.&lt;br /&gt;또한, 파괴적인 연산자는 소스코드에서 뚜렷하고 인지할 수 있는 형태로 나타나는데,&lt;br /&gt;이것은 우리가 버그를 찾을 때 특별한 주의를 기울여야 하기 때문에 좋다.&lt;br /&gt;&lt;br /&gt;function과 destructive counterpart사이의 관계는 일반적으로 런타임 이전에 알려 지므로 정의하는 것이 가장 효율것이다,&lt;br /&gt;&#39;!&#39; 연산자를 정의할 때 매크로로 정의하던가, 혹은 !를 위한 read macro를 제공한다. </content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/742594658228457442/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-52-orthogonality.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/742594658228457442'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/742594658228457442'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-52-orthogonality.html' title='[on lisp] 5.2 Orthogonality (직교성)'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-3765932528550464277</id><published>2019-01-15T13:00:00.001+09:00</published><updated>2019-01-15T13:00:19.028+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="lisp"/><title type='text'>[on lisp] 5.5 Recursion on Cdrs 재귀함수</title><content type='html'>5.5 Recursion on Cdrs&lt;br /&gt;재귀 함수는 lisp에서 매우 중요하기 때문에 이것들 빌드하는 유틸리티가 있어야할 가치가 있다.&lt;br /&gt;이 섹션과 다음 섹션에서는 가장 일반적인 두 가지 유형을 작성하는 함수에 대해 알아보자.&lt;br /&gt;Common Lisp에서 이 함수들을 살짝 어색하게 사용된다.&lt;br /&gt;일단 우리가 매크로의 주제로 들어가게 되면, 우리는 이 기계에 좀 더 우아한 면을 넣는 방법을 알게 될 것이다.&lt;br /&gt;&#39;recursers&#39;를 만드는 매크로는 섹션 15.2, 15.3에서 논의된다.&lt;br /&gt;&lt;br /&gt;프로그램에서 반복되는 패턴은 높은 수준의 추상화로 작성될 수 있다는 신호다.&lt;br /&gt;반복되는 패턴은 높은 수준의 추상화로 작성되었을 수 있었다는 신호다.&lt;br /&gt;Lisp에서 일반적으로 이와 같은 함수보다 일반적으로 보이는 패턴은 아래와 같다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(defun our-length (lst)&lt;br /&gt;    (if (null lst)&lt;br /&gt;        0&lt;br /&gt;        (1+ (our-length (cdr lst)))))&lt;br /&gt;;; or this&lt;br /&gt;(defun our-every (fn lst)&lt;br /&gt;    (if (null lst)&lt;br /&gt;        t&lt;br /&gt;        (and funcall fn (car lst))&lt;br /&gt;        (our-every fn (cdr lst))))&lt;br /&gt;&lt;/pre&gt;구조적으로 이 두 함수는 공통점이 많다.&lt;br /&gt;둘 다 리스트에 cdr를 재귀로 반복 연산을 하고, 동일한 표현식을 각 스텝에 실행한다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;;; Figure 5.5: Function to define flat list recursers.&lt;br /&gt;;; rec 요소별로 실행되어야 할 녀석&lt;br /&gt;;; base 디폴트값.&lt;br /&gt;(defun lrec (rec &amp;optional base)  ;; 함수를 리턴한다.&lt;br /&gt;    (labels ((self (lst)  ;; 재귀함수 이름 self&lt;br /&gt;                   (if (null lst)  ;; lst가 없으면&lt;br /&gt;                       (if (functionp base)  ;; 함수인지 확인하고 실행 후 리턴한다.&lt;br /&gt;                           (funcall base)  ;; 함수실행&lt;br /&gt;                           base)  ;; 그냥 리턴&lt;br /&gt;                           (funcall rec (car lst)  ;; lst의 첫번째를 가져오고 rec를 실행&lt;br /&gt;                                    #&#39;(lambda () ;; 그다음 내용을 함수에 감싼다.&lt;br /&gt;                                              (self (cdr lst)))))))&lt;br /&gt;            #&#39;self))                     &lt;br /&gt;&lt;/pre&gt;이 패턴은 경험 많은 프로그래머가 생각하기를 멈추지 않고 읽고 사용할 수 있게하는 리스프 프로그램에서 자주보임(?)&lt;br /&gt;패턴을 새로운 추상화에 묶는 방법에 문자는 발생하지 않는다.&lt;br /&gt;하지만 패턴은 모두 동일하다. 이러한 함수를 직접 작성하는 대신 우리를 위해 생성해줄 함수를 작성할 수 있어야 한다.&lt;br /&gt;Figure 5.5는 함수빌더(function-builder)가 있다. lrec(&quot;list recurser&quot;)&lt;br /&gt;이 빌더는 리스트에서 연속적으로 cdrs를 사용하는데 이렇게 반복되는 부분을 생성할 수 있어야 한다.&lt;br /&gt;&lt;br /&gt;lec의 첫번째 인수는 현재 리스트의 car와 두번째 인수는 재귀로 계속 호출 될 수 있는 함수이다.&lt;br /&gt;lrec를 사용하여 our-length를 다음처럼 표현할 수 있다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(lrec #’(lambda (x f) (1+ (funcall f))) 0)&lt;br /&gt;&lt;/pre&gt;리스트의 길이를 찾는데 요소를 확인할 필요나 중간에 멈출 필요가 없으므로 x는 항상 무시되고 f는 항상 호출된다.&lt;br /&gt;그러나 our-every함수를 표현할 수 잇는 두 가지를 모두 가능성을 모두 표현해야 한다.&lt;br /&gt;예를 들어 oddp&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(lrec #’(lambda (x f) (and (oddp x) (funcall f))) t)&lt;br /&gt;&lt;/pre&gt;lrec의 정의에서는 label를 사용하여 self라는 로컬 재귀 함수를 작성한다.&lt;br /&gt;재귀적일 경우 함수 rec에 두개의 매개변수가 전달된다. 리스트의 현재 car와 재귀 호출을 구현하는 함수를 전달한다.&lt;br /&gt;&lt;br /&gt;재귀케이스가 &#39;our-every&#39;와 같은 함수에서 첫번째 인자가 false를 반환하면 바로 그곳에서 멈추고 싶다.&lt;br /&gt;즉, 재귀적일 경우에 전달 된 인수는 값이 아니라 값이어야 하는 함수여야 한다.(값을 원하는 경우)&lt;br /&gt;&lt;br /&gt;Figure 4.5는 lrec로 정의된 기존의 Common Lisp함수를 보여준다. &lt;br /&gt;lrec를 호출하면 주어진 함수를 가장 효율적으로 구현할 수 있는 것은 아니다.&lt;br /&gt;사실 이 장에서 정의된 lrec와 다른 재발생(재귀) 생성기(recurser generators)는 꼬리 재귀랑은 다르다.&lt;br /&gt;이러한 이유로 그들은 초기 버전의 프로그램이나 속도가 중요하지 않은 부분에서 사용하기에 가장 적합하다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;Figure 5.6: Functions expressed with lrec.&lt;br /&gt;; copy-list&lt;br /&gt;(lrec #’(lambda (x f) (cons x (funcall f))))&lt;br /&gt;; remove-duplicates&lt;br /&gt;(lrec #’(lambda (x f) (adjoin x (funcall f))))&lt;br /&gt;; find-if, for some function fn&lt;br /&gt;(lrec #’(lambda (x f) (if (fn x) x (funcall f))))&lt;br /&gt;; some, for some function fn&lt;br /&gt;(lrec #’(lambda (x f) (or (fn x) (funcall f))))&lt;br /&gt;&lt;/pre&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/3765932528550464277/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-55-recursion-on-cdrs.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/3765932528550464277'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/3765932528550464277'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-55-recursion-on-cdrs.html' title='[on lisp] 5.5 Recursion on Cdrs 재귀함수'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-4498277588914244806</id><published>2019-01-11T12:11:00.003+09:00</published><updated>2019-01-11T12:11:57.809+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="lisp"/><title type='text'>[on lisp] 5.4 Composing Functions 함수 조합(되게 유익)</title><content type='html'>5.4 Composing Functions &lt;br /&gt;함수 f의 보수는 ∼f로 표기된다.&lt;br /&gt;&lt;br /&gt;5.1절에서 closure가 ∼을 Lisp 함수로 정의할 수 있게 함을 보였다.&lt;br /&gt;함수에 대한 또 다른 공통 연산은 연산자 ◦로 표시되는 &#39;합성&#39;입니다.&lt;br /&gt;f와 g가 함수라면, f ◦g는 함수이고 f ◦g (x) = f (g (x))이다. &lt;br /&gt;클로저는 또한 ◦을 Lisp 함수로 정의하는 것을 가능하게합니다&lt;br /&gt;아래 Figure5.3은 여러 함수를 취해 그 혼합물을 리턴하는 compose함수를 정의한다. &lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;;; Figure 5.3: An operator for functional composition.&lt;br /&gt;(defun compose (&amp;rest fns) ;; &amp;rest는 복수의 함수를 매개변수를 받겠다.&lt;br /&gt;    (if fns ;; 함수가 존재한다면&lt;br /&gt;        (let ((fn1 (car (last fns))) ;; 리스트의 마지막 함수 가져오기(compose는 오른쪽부터 합쳐진다)&lt;br /&gt;                   (fns (butlast fns))) ;; 마지막 함수를 제외한 함수 리스트&lt;br /&gt;              #&#39;(lambda (&amp;rest args) ;; fn1 함수가 어떤 매개변수를 받을지 모르니 args로 다 받음&lt;br /&gt;                        (reduce #&#39;funcall fns ;; 하나하나 함수를 누산한다.&lt;br /&gt;                                :from-end t ;; 아 뒤에서 부터 실행하라는 뜻&lt;br /&gt;                                :initial-value (apply fn1 args)))) ;; 첫번째 함수를 초기값으로 실행 &lt;br /&gt;             #&#39;identity)) ;; 함수가 없으면 identity 리턴&lt;br /&gt;              &lt;br /&gt;;; 사용법&lt;br /&gt;(compose #&#39;list #&#39;1+) ;; 아래 값과 같다.&lt;br /&gt;#&#39;(lambda (x) (list 1+ x))&lt;br /&gt;&lt;/pre&gt;compose에 대한 인수로 주어진 모든 함수는 마지막 인수를 제외하고, 모두 하나의 인수를 받는 녀석들이어야 한다.&lt;br /&gt;마지막 함수는 아무런 제약이 없다. 무엇이든지 인수가 주어지면 compose에 의해 함수가 초깃값으로 반환될 것이다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (funcall (compose #’1+ #’find-if) #’oddp ’(2 3 4))&lt;br /&gt;4&lt;br /&gt;&lt;/pre&gt;위에 내용은 함수들을 closure로 감싼 함수를 리턴한 것과 같다. &lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;;; Figure 5.4: More function builders.&lt;br /&gt;(defun fif (if then &amp;optional else)&lt;br /&gt;    #&#39;(lambda (x)&lt;br /&gt;              (if (funcall if x)&lt;br /&gt;                  (funcall then x)&lt;br /&gt;                  (if else (funcall else x)))))&lt;br /&gt;(defun fint (fn &amp;rest fns)&lt;br /&gt;    (if (null fns)&lt;br /&gt;        fn&lt;br /&gt;        (let ((chain (apply #&#39;fint fns)))&lt;br /&gt;             #&#39;(lambda (x)&lt;br /&gt;                       (and (funcall fn x) (funcall chain x))))))&lt;br /&gt;&lt;br /&gt;(defun fun (fn &amp;rest fns)&lt;br /&gt;    (if (null fns)&lt;br /&gt;        fn&lt;br /&gt;        (let ((chain (apply #&#39;fun fns)))&lt;br /&gt;             #&#39;(lambda (x)&lt;br /&gt;                       (or (funcall fn x) (funcall chain x))))))&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;not은 리스프 함수이기 때문에, complement는 compose의 특별한 경우이다.&lt;br /&gt;이녀석은 이렇게 정의될 수 있다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(defun complement (pred)&lt;br /&gt;  (compose #&#39;not pred))&lt;br /&gt;&lt;/pre&gt;함수들을 조합(composing)하는 것 이외의 다른 방법으로 기능을 결합(combine)할 수 있다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(mapcar #&#39;(lambda (x)&lt;br /&gt;                  (if (slave x) ; 노예면&lt;br /&gt;                      (owner x) ; 오너를&lt;br /&gt;                      (employer)) ; 아니면 고용주를&lt;br /&gt;                      people) ; 사람 , 노예 아니면 직장인&lt;br /&gt;&lt;/pre&gt;위와 같은 함수를 자동으로 생성하는 연산자를 정의할 수 있다.&lt;br /&gt;Figure 5.4의 fif를 사용하면 다음과 같은 효과를 얻을 수 있다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(mapcar (fif #&#39;slave #&#39;owner #&#39;employer)&lt;br /&gt;        people)&lt;br /&gt;;; 코드리뷰&lt;br /&gt;(defun fif (if then &amp;optional else)&lt;br /&gt;    #&#39;(lambda (x) ; if, then, else를 담은(closure) 람다함수 리턴&lt;br /&gt;              (if (funcall if x) ; if 함수가 참이면&lt;br /&gt;                  (funcall then x) ; then 함수 실행&lt;br /&gt;                  (if else (funcall else x))))) ; else 함수 실행&lt;br /&gt;&lt;/pre&gt;Figure 5.4는 일반적으로 발생하는 유형의 함수에 대한 몇 가지 다른 생성자를 포함합니다.&lt;br /&gt;두 번째, fint는 다음과 같은 경우입니다. &lt;br /&gt;트루이면 그 상태에서 멈추는 거니까 거기까지만 일을 했다는 것! 특이한 건 그때그때 함수를 실행할 것이겠지?&lt;br /&gt;and이니까 그럴 것이다.(and는 매크로로 보임)&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(find-if #&#39;(lambda (x)&lt;br /&gt;                   (and (signed x) (sealed x) (delivered x)))&lt;br /&gt;         docs)&lt;br /&gt;&lt;/pre&gt;find-if의 인수로 주어진 predicate(술어)는 그 안에서 호출되는 세 개의 predicates의 교차점(intersection)이다.&lt;br /&gt;&quot;function intersection&quot;을 뜻하는 fint를 사용하여 다음과 같이 쓸 수 있다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(find-if (fint #&#39;signed #&#39;sealed #&#39;delivered) docs)&lt;br /&gt;&lt;/pre&gt;이렇게 유사한 연산자를 정의하여 predicate집합의 합집합을 반환 할 수 있따.&lt;br /&gt;fun 함수는 fint와 비슷하지만 and 대신에 or를 사용한다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/4498277588914244806/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-54-composing-functions.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/4498277588914244806'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/4498277588914244806'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-54-composing-functions.html' title='[on lisp] 5.4 Composing Functions 함수 조합(되게 유익)'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-6050974734908076484</id><published>2019-01-10T18:27:00.002+09:00</published><updated>2019-01-11T11:03:44.205+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="lisp"/><title type='text'>[on lisp] 5.3 Memoizing 캐싱,메모</title><content type='html'>5.3 Memoizing &lt;br /&gt;어떤 함수가 계산하는데 비용이 많이 들고, 때로는 같은 호출을 두 번 이상하는 경우가 있다.&lt;br /&gt;이전의 모든 호출의 반환 값을 캐싱하고 함수가 호출 될 때마다 다음과 같이 memoize하는 것이 좋다.&lt;br /&gt;값이 저장되었는지 확인하려면 먼저 캐시를 살펴보십시오.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;그림 5.2는 일반화 된 memoizing  유틸리티입니다.&lt;br /&gt;memoize 함수를 제공하고, 이전 호출 결과를 저장하는 해시테이블을 포함하는(closure)를 반환한다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;;; Figure 5.2: Memoizing utility.&lt;br /&gt;(defun memoize (fn)&lt;br /&gt;  (let ((cache (make-hash-table :test #&#39;equal)))&lt;br /&gt;    #&#39;(lambda (&amp;rest args)&lt;br /&gt;     (multiple-value-bind (val win) (gethash args cache)  ;; 구조분해 같은 것인듯&lt;br /&gt;    (if win  ;; 값이 있으면&lt;br /&gt;     val  ;; 해당 값 리턴&lt;br /&gt;     (setf (gethash args cache)  ;; 값이 없는 경우 setf로 해시에 가져온 키값에 설정한 값을 넣음&lt;br /&gt;        (apply fn args))))))) ;; setf는 넣은 값 리턴으로 보임.&lt;br /&gt;     &lt;br /&gt;     &lt;br /&gt;&gt; (setq slowid (memoize #&#39;(lambda (x) (sleep 5) x)))&lt;br /&gt;Interpreted-Function C38346&lt;br /&gt;&gt; (time (funcall slowid 1))&lt;br /&gt;Elapsed Time = 5.15 seconds&lt;br /&gt;1&lt;br /&gt;&gt; (time (funcall slowid 1))&lt;br /&gt;Elapsed Time = 0.00 seconds&lt;br /&gt;1    &lt;br /&gt;&lt;/pre&gt;memoized 함수를 사용하면, 반복 호출은 해시 테이블 조회 일뿐이다.&lt;br /&gt;물론 초기 호출마다 조회 비용이 추가되지만, 계산하기에 충분히 비싼 함수를 메모하는 것이므로 비용은 비교할 때 중요하지 않다고 가정하는 것이 합리적이다.&lt;br /&gt;대부분의 용도에 적합하지만, memoize의 구현에는 몇 가지 제한이 있다.&lt;br /&gt;이 함수는 동일한 인수 목록이 있으면 동일하게 리턴값이 나와야 한다.&lt;br /&gt;만약 함수에 키워드 파라미터가 있으면 너무 엄격할 수 있다.&lt;br /&gt;또한 단일 값 함수에만 사용되며 여러 값을 저장하거나 반환 할 수 없다.&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/6050974734908076484/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-53-memoizing.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/6050974734908076484'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/6050974734908076484'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-53-memoizing.html' title='[on lisp] 5.3 Memoizing 캐싱,메모'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-5081821723083958570</id><published>2019-01-10T16:55:00.002+09:00</published><updated>2019-01-11T11:06:03.808+09:00</updated><title type='text'>[on lisp] 5. Returning Functions 함수 리턴(클로저)</title><content type='html'>5. Returning Functions &lt;br /&gt;이전 장에서는 함수를 인수로 전달하는 기능이 추상화 가능성을 어떻게 증가시키는지 보았다.&lt;br /&gt;우리는 함수로 더 많은 것을 할수록, 우리는 더 많은 가능성을 취할 수 있다.&lt;br /&gt;새로운 함수를 구축하고 새로운 함수를 리턴함으로써, 그리는 함수를 인수로 이용하는 유틸리티의 효과를 확대할 수 있다.&lt;br /&gt;&lt;br /&gt;이 장에서 유틸리티는 함수를 실행한다.&lt;br /&gt;커먼리습에서 매크로처럼 표현식에 적용하기 위해 많은 것을 작성하는 것은 자연스러운 것이다.&lt;br /&gt;매크로 계층은 15장의 일부 연산자와 중첩된다. 하지만 우리가 매크로를 통해서만 이러한 함수를 호출할지라도, 함수로 수행할 수 있는 작업의 부부능ㄹ 아는 것은 중요하다.&lt;br /&gt;&lt;br /&gt;5.1 Common Lisp Evolves &lt;br /&gt;커먼리습은 본래 몇 쌍의 보완 함수(Complementary functions)를 제공한다.&lt;br /&gt;remove-if, remove-if-not 함수가 이런 한 쌍이다. 만약 pred가 하나의 인수인 predicate(술어)라면&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(remove-if-not #&#39;pred lst)&lt;br /&gt;;; 이건 아래와 같다.&lt;br /&gt;(remove-if #&#39;(lambda (x) (not (pred x))) lst)&lt;br /&gt;&lt;/pre&gt;하나의 인자로 주어진 함수를 다양화함으로써, 우리는 다른 하나의 효과를 복제할 수 있다.&lt;br /&gt;CLTL2에서는 다음과 같은 경우를 위한 새로운 함수를 포함한다.&lt;br /&gt;complement함수는 predicate(술어)p를 취하여 항상 반대값을 반환하는 함수를 반환한다.&lt;br /&gt;p가 true를 반환하면, complement(보수)는 false를 반환하고 그 반대도 마찬가지이다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(remove-if-not #&#39;pred lst)&lt;br /&gt;;; 아래와 같다.&lt;br /&gt;(remove-if (complement #&#39;pred) lst)&lt;br /&gt;&lt;/pre&gt;complement함수오 함께라면 if-not함수를 계쏙 사용할 이유가 없다.&lt;br /&gt;실제로 CLTL(p.391)에서 deprecated 되었다고 말한다. 그들이 커먼리습에 남아있다면 오로지 호환성을 위해서일 것이다.&lt;br /&gt;새로운 complement 연산자는 중요한 빙산의 일각이다. : (함수를 반환하는 함수: functions which return functions)&lt;br /&gt;&lt;br /&gt;이것은 오랫동안 Scheme의 관용구에서 중요한 부분이었다.&lt;br /&gt;Scheme은 함수를 lexcial closure로 만드는 첫번째 리스프였고, 리턴 값으로 함수를 가지는 것을 흥미롭게 보았다.&lt;br /&gt;dynamically scoped Lisp가 함수를 반환 할 수 없는 것은 아니다.&lt;br /&gt;아래의 함수는 dynamic이나 lexcial scope 둘다 동일하게 작동한다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(defun joiner (obj)&lt;br /&gt;  (typecase obj&lt;br /&gt;    (cons #&#39;append)&lt;br /&gt;    (number #&#39;+)))&lt;br /&gt;&lt;/pre&gt;객체를 취하고, 이것의 타입에 따라 객체를 더하는 함수를 반환한다.&lt;br /&gt;우리는 숫자들이나, 리스트들에 작동하는 join 함수를 다형성을 적용시켜 작동하게 할 수 있을 것이다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(defun join (&amp;rest args)&lt;br /&gt;  (apply (joiner (car args)) args))&lt;br /&gt;&lt;/pre&gt;그러나 상수 함수(constant functions)를 반환하는 것은 동적스코프가 수행 할 수 있는 작업의 한계다.&lt;br /&gt;동적스코프가 할 수 없는 것은 런타임에 함수를 빌드하는 것이다. &lt;br /&gt;joiner는 두 가지 함수 중 하나를 반환 할 수 있지만 두 가지 선택으로 고정되어 있다.&lt;br /&gt;이전에 우리는 렉시컬 스코프를 사용하여 함수를 리턴하는 함수를 본 적이 있다. &lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(defun make-adder (n)&lt;br /&gt;  #&#39;(lambda (x) (+ x n)))&lt;br /&gt;&lt;/pre&gt;make-adder를 호출하면 인수로 주어진 값에 따라 동작(바뀌는!) 클로저(closure)가 생성된다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (setq add3 (make-adder 3))&lt;br /&gt;#Interpreted-Function BF1356&lt;br /&gt;function to add such objects together. We could use it to define a polymorphic join function that worked for numbers or lists: &lt;br /&gt;(defun join (&amp;rest args)&lt;br /&gt;  (apply (joiner (car args)) args))&lt;br /&gt;However, returning constant functions is the limit of what we can do with dynamic scope. What we can&#39;t do (well) is build functions at runtime; joiner can return one of two functions, but the two choices are fixed. &lt;br /&gt;On page 18 we saw another function for returning functions, which relied on lexical scope: &lt;br /&gt;(defun make-adder (n)&lt;br /&gt;  #&#39;(lambda (x) (+ x n)))&lt;br /&gt;Calling make-adder will yield a closure whose behavior depends on the value originally given as an argument: &lt;br /&gt;&gt; (setq add3 (make-adder 3))&lt;br /&gt;#Interpreted-Function BF1356&lt;br /&gt;&gt; (funcall add3 2)&lt;br /&gt;5&lt;br /&gt;&lt;/pre&gt;렉시컬 소코프(Lexical scope)에서, 단순히 상수 함수 그룹을 선택하는 대신!, 런타임에서 새로운 클로저를 생성할 수 있다.&lt;br /&gt;동적 스코프(Dynamic scope)를 사용하면 이런건 불가능하다.&lt;br /&gt;complement가 어떻게 작성될 것인지를 생각해보면, 이것 역시 closure를 리턴해야 한다는 것을 알 수 있다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(defun complement (fn)&lt;br /&gt;  #&#39;(lambda (&amp;rest args) (not (apply fn args))))&lt;br /&gt;;; not을 안에 붙여서 함수를 생성 하도록하는데 fn을 머금는 클로저로 함수를 뱉는다. &lt;br /&gt;;; (이것은 렉시컬 스코프라 가능한 것)&lt;br /&gt;&lt;/pre&gt;complement에 의해 반환되는 함수는 complement가 호출될 때 변수 fn의 값을 사용한다.&lt;br /&gt;그러므로, 상수 함수 그룹을 선택하는 대신 &#39;complement&#39;는 모든 함수의 역함수를 사용자-정의(custom-build) 할 수 있다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (remove-if (complement #&#39;oddp) &#39;(1 2 3 4 5 6))&lt;br /&gt;(1 3 5)&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;함수를 인수로 전달할 수 있다는 것은 추상화를 위한 강력한 도구입니다.&lt;br /&gt;함수를 반환하는 함수를 작성하는 기능으로 우리는 함수를 최대한 활용할 수 있다.&lt;br /&gt;나머지 절에서는 기능을 리턴하는 유틸리티의 몇 가지 예를 제시한다.</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/5081821723083958570/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-5-returning-functions.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/5081821723083958570'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/5081821723083958570'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-5-returning-functions.html' title='[on lisp] 5. Returning Functions 함수 리턴(클로저)'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-8142460978833027368</id><published>2019-01-09T14:46:00.001+09:00</published><updated>2019-01-09T14:46:03.903+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="lisp"/><title type='text'>[on lisp] 4.8 Density</title><content type='html'>4.8 Density &lt;br /&gt;&lt;br /&gt;만약 당신이 코드가 많은 새로운 유틸리티를 사용한다면, 일부 독자들은 그것이 이해하기 어렵다고 불평할지도 모른다.&lt;br /&gt;&lt;br /&gt;아직 Lisp에 능숙하지 않은 사람들은 raw Lisp를 읽는 데만 익숙해질 것이다.&lt;br /&gt;사실 그들은 아직 확장 가능한 언어에 전혀 익숙하지 않을 수도 있다.&lt;br /&gt;그들이 &#39;utility&#39;에 크게 의존하는 프로그램을 볼 때마다&lt;br /&gt;이 언어의 순수한 괴팍함에 작성자가 사적인 언어로 이 프로그램을 쓰기로 결정한 것처럼 보인다.&lt;br /&gt;&lt;br /&gt;새로운 연산자(operators)는, 논란이 될 수도 있지만, 프로그램을 읽기 어렵게 만든다.&lt;br /&gt;프로그램을 읽기 전에 그것들을 모두 이해해야 한다.&lt;br /&gt;왜 이런 주장이 잘못되었는지 알기 위해서, 페이지 41을 고려해라.(?? 유틸리티 함수를 만드는 섹션 가라는 말인듯, 왜냐하면 find2가 있음)&lt;br /&gt;만약 당신이 find2를 사용하여 프로그램을 작성했다면, 누군가가 당신의 프로그램을 읽기 전에 이 새로운 유틸리티의 정의를 이해해야 한다고 불평할 수 있다.&lt;br /&gt;글쎄, 만약 당신이 find2를 사용하지 않았다고 가정해보자.&lt;br /&gt;그렇다면, find2의 정의를 이해해야 하는 대신에, 이해해야 할 것이 있을 것이다.&lt;br /&gt;그러면 코드를 읽는 사람은 find2의 기능과 함께 다른 특정한 기능이 있는 함수를 한꺼번에 이해해야 한다.&lt;br /&gt;(서점에서 책을 찾는다 해보면, 서점 도메인에 정의되어 있는 내용과 find2를 한 곳에서 이해해야 한다)&lt;br /&gt;그리고 정확한건 이렇게 섞이면 분리된 것보다 이해하기 어렵다.&lt;br /&gt;&lt;br /&gt;그리고 알아야 할 점이 있다.&lt;br /&gt;우리는 지금 예제를 만든 것이기 때문에 새로 만든 유틸리티를 한 번밖에 사용하지 않았따. 유틸리티는 반복적으로 사용하기 위해 만들어진다.&lt;br /&gt;실제 프로그램에서 find2 같은 것과 3~4가지 특수(특정 도메인에만 작동)한 검색 루틴을 이해해야 할 필요가 있을 수 있다.&lt;br /&gt;확실히 전자가 더 쉽다.&lt;br /&gt;&lt;br /&gt;그렇다, 상향식-프로그램을 읽으려면 저자에 의해 정의된 모든 새로운 연산자(operator)를 이해해야 한다.&lt;br /&gt;그러나 이거 없이 요구를 충족하며 만들어진 모든 코드를 이해해야 하는 것보다 더 적은 작업일 것이다.&lt;br /&gt;&lt;br /&gt;만약 사람들이 &#39;유틸리티&#39;를 사용하면 코드를 읽기가 어렵게 만든다고 불평한다면, 코드를 사용하지 않았다면 어떻게 보일지 알지 못한 것이다.&lt;br /&gt;상향식-프로그래밍은 큰 프로그램인 거와 달리, 작고 심플하게 보이게 한다.&lt;br /&gt;이것은 프로그램이 별로 일을 하지 않는다는 인상을 주고 그것은 읽기 쉽게 보일 수 있다.&lt;br /&gt;경험없는 독자가 더 가까이에서 보았을 때, 이것이 그렇지 않다는 것을 알게되면, 그들은 충격을 받는다.&lt;br /&gt;&lt;br /&gt;우리는 다른 분야에서도 동일한 현상을 발견한다. 잘 설계된 기계는 부품을 더적게 차지할 수 있지만, 더 작은 공간에 포장되기 때문에 더 복잡해 보인다.&lt;br /&gt;상향식 프로그램은 개념적으로 밀도가 높다. 그것들을 읽으려면 노력이 필요할지도 모르지만, 상향식으로 짜여지지 않은 것들 만큼은 아니다.&lt;br /&gt;&lt;br /&gt;유틸리티 사용을 의도적으로 피할 수 있는 경우가 있다: 작은 프로그램을 짜서 독립적으로 나머지 코드에 배포되야할 녀석입니다.&lt;br /&gt;유틸리티는 일반적으로 2~3회 사용후 자체적으로 비용을 지불하지만(2,3회 쓰이면 괜찮음 만들라) 작은 프로그램에서 유틸리티를 만들어 작성해봤자&lt;br /&gt;그걸 여러번 얼마나 쓸지 장담할 수 없으니 정당화 될 수 없다.</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/8142460978833027368/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-48-density.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/8142460978833027368'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/8142460978833027368'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-48-density.html' title='[on lisp] 4.8 Density'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-4071263265436270480</id><published>2019-01-09T10:48:00.002+09:00</published><updated>2019-01-09T10:48:13.856+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="lisp"/><title type='text'>[on lisp] 4.7 Symbols and Strings 심볼과 문자열 사이</title><content type='html'>4.7 Symbols and Strings &lt;br /&gt;심볼과 문자열은 밀접한 관련이 있다.&lt;br /&gt;&lt;br /&gt;reading,printing 함수에 따라 우리는 두 표현을 왔다갔다 할 수 있다.&lt;br /&gt;Figure 4.8은 이 경계에서 작동하는 유틸리티 함수의 예를 보여준다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;;; Figure 4.8: Functions which operate on symbols and strings.&lt;br /&gt;(defun mkstr (&amp;rest args)&lt;br /&gt;  (with-output-to-string (s)&lt;br /&gt;    (dolist (a args) (princ a s))))&lt;br /&gt;&lt;br /&gt;(defun symb (&amp;rest args)&lt;br /&gt;  (values (intern (apply #&#39;mkstr args))))&lt;br /&gt;&lt;br /&gt;(defun reread (&amp;rest args)&lt;br /&gt;  (values (read-from-string (apply #&#39;mkstr args))))&lt;br /&gt;&lt;br /&gt;(defun explode (sym)&lt;br /&gt;  (map &#39;list #&#39;(lambda (c)&lt;br /&gt;           (intern (make-string 1&lt;br /&gt;                   :initial-element c)))&lt;br /&gt;             (symbol-name sym)))&lt;br /&gt;&lt;/pre&gt;첫번째 mkstr 함수는 많은 수의 인수를 취하여 출력된 표현을 문자열로 묶는다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (mkstr pi &quot; pieces of &quot; &#39;pi)&lt;br /&gt;&quot;3.1415926535897932385L0 peices of PI&quot;&lt;br /&gt;&lt;/pre&gt;출력가능한 표현을 할 수 있는 아무 객체가 가능하다. : symbols, strings, numbers even lists&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (mkstr pi &quot; pieces of &quot; &#39;pi)&lt;br /&gt;&gt; (symb &#39;ar &quot;Madi&quot; #\L #\L 0)&lt;br /&gt;|ARMadiLL0|&lt;br /&gt;&lt;/pre&gt;mkstr로 모든 인수들을 묶으라고 한 후, symb는 그 결과 문자열을 intern에게 보낸다.&lt;br /&gt;intern 함수는 Lisp의 전통적인 기호제작자(symbol-builder): 문자열을 받아 그 문자열을 인쇄하는 심볼을 찾거나 새로운 심볼을 생성한다.&lt;br /&gt;&lt;br /&gt;모든 문자열은 심볼의 출력이름(print-name)이 될 수 있으며, 심지어 소문자나 매크로 문자(괄호)같은 것들도 포함된다.&lt;br /&gt;심볼이름이 이런 기괴한 것들이 포함되어 있을 경우, 아래와 같이 수직 막대 내에서 출력된다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (let ((s (symb &#39;(a b))))&lt;br /&gt;(and (eq s &#39;|(A B)|) (eq s &#39;\(A\ B\))))&lt;br /&gt;T&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;reread는 symb의 일반화이다. 여러 객체를 한번에 받아 출력하고 다시 읽는다.&lt;br /&gt;symb와 같이 심볼을 리턴할 수 있지만 읽을 수 있는 다른 무언가를 리턴할 수도 있다.&lt;br /&gt;&lt;br /&gt;Read-macro는 심볼의 이름의 일부로 취급되는 대신, (예를들어)|a:b|를 보면 현재 패키지 안에 |a:b|라는 심볼을 찾는 것이 아니라.&lt;br /&gt;|a:b|는 a 패키지 안에 b라고 읽어진다. 또한 보다 일반적인 함수는 더 까다롭다. &#39;reread&#39;는 해당 Lisp구분이 적절하지 않으면 에러를 생성한다.&lt;br /&gt;&lt;br /&gt;마지막 함수 explode는 함수를 받아서 심볼 리스트를 반환한다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (explode &#39;bomb)&lt;br /&gt;(B O M B)&lt;br /&gt;&lt;/pre&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/4071263265436270480/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-47-symbols-and-strings.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/4071263265436270480'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/4071263265436270480'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-47-symbols-and-strings.html' title='[on lisp] 4.7 Symbols and Strings 심볼과 문자열 사이'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-6553495848003984683</id><published>2019-01-08T14:07:00.003+09:00</published><updated>2019-01-08T14:07:32.302+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="lisp"/><title type='text'>[on lisp] 4.6 I/O  입출력</title><content type='html'>4.6 I/O &lt;br /&gt;Figure 4.7은 I/O 유틸리티의 세 가지 예를 보여준다.&lt;br /&gt;이러한 유틸리티의 필요성은 프로그램마다 다르다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;;; Figure 4.7: I/O functions.&lt;br /&gt;(defun readlist (&amp;rest args)&lt;br /&gt;  (values (read-from-string&lt;br /&gt;       (concatenate &#39;string &quot;(&quot; &lt;br /&gt;                         (apply #&#39;read-line args)&lt;br /&gt;                      &quot;)&quot;))))&lt;br /&gt;&lt;br /&gt;(defun prompt (&amp;rest args)&lt;br /&gt;  (apply #&#39;format *query-io* args)&lt;br /&gt;  (read *query-io*))     &lt;br /&gt;&lt;br /&gt;(defun break-loop (fn quit &amp;rest args)&lt;br /&gt;  (format *query-io* &quot;Entering break-loop.~%&quot;)&lt;br /&gt;  (loop&lt;br /&gt;    (let ((in (apply #&#39;prompt args)))&lt;br /&gt;      (if (funcall quit in)&lt;br /&gt;       (return)&lt;br /&gt;          (format *query-io* &quot;~A~%&quot; (funcall fn in))))))&lt;br /&gt;&lt;/pre&gt;여기 4.7은 대표적인 샘플일 뿐이다. 첫 번째는 사용자가 괄호없이 표현식을 입력 할 수 있게 하려는 경우다.&lt;br /&gt;입력 행(a line of input)을 읽고 그것을 리스트로 리턴한다.&lt;br /&gt;&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt;(readlist)&lt;br /&gt;Call me &quot;Ed&quot;&lt;br /&gt;(CALL ME &quot;Ed&quot;)&lt;br /&gt;&lt;/pre&gt;값을 호출하면 하나의 값만 반환.&lt;br /&gt;&lt;br /&gt;prompt 함수는 질문, 읽기, 대답을 결합한다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (prompt &quot;Enter a number between ~A and ~A.~%&gt;&gt; &quot; 1 10)&lt;br /&gt;Enter a number between 1 and 10.&lt;br /&gt;&gt;&gt; 3&lt;br /&gt;3&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;마지막으로 break-loop는 리습의 toplevel(REPL같은거)을 모방한 것이다.&lt;br /&gt;두 개의 함수과 &amp;rest 인수를 취하여, 프롬프트에 반복적으로 제공된다.&lt;br /&gt;두 번째 함수가 입력에 대해 false를 반환하면 첫 번째 함수가 입력에 적용된다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (break-loop #&#39;eval #&#39;(lambda (x) (eq x :q)) &quot;&gt;&gt; &quot;)&lt;br /&gt;Entering break-loop.&lt;br /&gt;&gt;&gt; (+ 2 3)&lt;br /&gt;5&lt;br /&gt;&gt;&gt; :q&lt;br /&gt;:Q&lt;br /&gt;&lt;/pre&gt;이것이 커먼리습 벤더들이 일반적으로 런타임 라이센스를 주장하는 이유이다.&lt;br /&gt;만약 eval을 런타임에 실행할 수 있는 경우, 어떤 Lisp프로그램에도 Lisp가 포함될 수 있다.&lt;br /&gt;(If you can call eval at runtime, then any Lisp program can include Lisp.)&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/6553495848003984683/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-46-io.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/6553495848003984683'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/6553495848003984683'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-46-io.html' title='[on lisp] 4.6 I/O  입출력'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-7091061922247836145</id><published>2019-01-08T11:54:00.002+09:00</published><updated>2019-01-08T14:07:46.172+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="lisp"/><title type='text'>[on lisp] 4.5 Mapping  매핑</title><content type='html'>4.5 Mapping &lt;br /&gt;리습에서 또 널리 사용되는 녀석들이 있다. 이걸 매핑 함수라고 한다. 일련의 인수(시퀀스)에 함수를 적용시키는 함수다.&lt;br /&gt;Figure 4.6은 새로운 매핑 함수의 몇가지 예를 보여준다.&lt;br /&gt;&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(defun map0-n (fn n)&lt;br /&gt;  (mapa-b fn 0 n))&lt;br /&gt;  &lt;br /&gt;(defun map1-n (fn n)&lt;br /&gt;  (mapa-b fn 1 n))&lt;br /&gt;&lt;br /&gt;(defun mapa-b (fn a b &amp;optional (step 1))&lt;br /&gt;  (do ((i a (+ i step))&lt;br /&gt;       (result nil))&lt;br /&gt;      ((&gt; i b) (nreverse result))&lt;br /&gt;   (push (funcall fn i) result)))&lt;br /&gt;&lt;br /&gt;(defun map-&gt; (fn start test-fn succ-fn)&lt;br /&gt;  (do ((i start (funcall succ-fn i))&lt;br /&gt;       (result nil))&lt;br /&gt;      ((funcall test-fn i) (nreverse result))&lt;br /&gt;    (push (funcall fn i) result)))&lt;br /&gt; &lt;br /&gt;(defun mappend (fn &amp;rest lsts)&lt;br /&gt;  (apply #&#39;append (apply #&#39;mapcar fn lsts)))&lt;br /&gt;&lt;br /&gt;(defun mapcars (fn &amp;rest lsts)&lt;br /&gt;  (let ((result nil))&lt;br /&gt;    (dolist (lst lsts)&lt;br /&gt;   (dolist (obj lst)&lt;br /&gt;     (push (funcall fn obj) result)))&lt;br /&gt; (nreverse result)))&lt;br /&gt;&lt;br /&gt;(defun rmapcar (fn &amp;rest args)&lt;br /&gt;  (if (some #&#39;atom args)&lt;br /&gt;      (apply fn args)&lt;br /&gt;   (apply #&#39;mapcar&lt;br /&gt;          #&#39;(lambda (&amp;rest args)&lt;br /&gt;              (apply #&#39;rmapcar fn args))&lt;br /&gt;    args)))&lt;br /&gt;&lt;/pre&gt;하... 보기만 해도 머리가 지끈하다. 하나하나 봐보자.&lt;br /&gt;처음 세개의 함수는 편하게 사용하기 위해 만든 것인가보다.&lt;br /&gt;(The first three are for applying a function to a range of numbers without having to cons up a list to contain them.)&lt;br /&gt;보아하니 매개변수로 넘겨주기 귀찮아서, 0부터 n까지의 range를 매개변수로 줄 때 사용한다는 것 같다.&lt;br /&gt;잘 보면 map0-n는 0부터 n까지 map1-n는 1부터 n까지임을 확인할 수 있다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (map0-n #&#39;1+ 5)&lt;br /&gt;(1 2 3 4 5 6)&lt;br /&gt;&gt; (map1-n #&#39;1+ 5)&lt;br /&gt;(2 3 4 5 6)&lt;br /&gt;&lt;/pre&gt;이 주 map0-n과 map1-n는 사실 mapa-b를 이용하여 숫자 범위가 만들어지고 있다. &lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (mapa-b #&#39;1+ -2 0 .5) ;; -2부터 0까지 .5 단위로 커지는 range&lt;br /&gt;(-1 -0.5 0.0 0.5 1.0)&lt;br /&gt;&lt;br /&gt;;; 코드구경&lt;br /&gt;(defun mapa-b (fn a b &amp;optional (step 1))&lt;br /&gt;  (do ((i a (+ i step))  ;; do (i::인덱스 a::시작점 (+ i step)::업데이트&lt;br /&gt;       (result nil))     ;; 끝나면 리턴할 녀석 nil은 초기값&lt;br /&gt;      ((&gt; i b) (nreverse result)) ;; 시작할 index의 값이 b(마지막)값보다 크면 반대로 돌아야 하니까 result를 nreverse&lt;br /&gt;   (push (funcall fn i) result)))  ;; result 값에 반복문 돌면서 함수 실행후 result에 넣음.&lt;br /&gt;&lt;/pre&gt;mapa-b보다 더 일반적인 map-&gt;가 있다. 이 매핑은 숫자만이 아닌 모든 종류의 객체 시퀀스에 사용할 수 있다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(defun map-&gt; (fn start test-fn succ-fn)&lt;br /&gt;  (do ((i start (funcall succ-fn i)) ;; succ-fn로 인덱스를 바꿈&lt;br /&gt;       (result nil)) ;; 리턴값&lt;br /&gt;      ((funcall test-fn i) (nreverse result)) ;; test-fn로 끝났는지 확인하고 result 리턴&lt;br /&gt;    (push (funcall fn i) result))) ;; result에 fn를 실행하여 넣는다.&lt;br /&gt;&lt;/pre&gt;보면 알겠지만 인덱싱을 하던 i가 꼭 숫자일 필요조차 없다. 업데이트나 터미널인지 확인하는 것도 따로 함수를 넣는다.&lt;br /&gt;그렇다면 mapa-b또한 이 유틸리티 함수를 이용하여 재구현해보자.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(defun mapa-b (fn a b &amp;optional (step 1))&lt;br /&gt;  (map-&gt; fn  ;; 요소별로 실행할 함수&lt;br /&gt;         a   ;; 시작숫자&lt;br /&gt;   #&#39;(lambda (x) (&gt; x b))  ;; 끝날 숫자 확인 &lt;br /&gt;   #&#39;(lambda (x) (+ x step)))  ;; 인덱스 업데이트 방법&lt;br /&gt;&lt;/pre&gt;효율성을 위하여, 빌트인 mapcan함수는 파괴적이다(수정을한다).&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(defun our-mapcan (fn &amp;rest lsts)&lt;br /&gt;  (apply #&#39;nconc (apply #&#39;mapcar fn lsts)))&lt;br /&gt;&lt;/pre&gt;mapcan은 nconc와 함께 리스트를 연결하기 때문에, 첫번째 인수에서 리턴된 리스트를 새로 만들거나, 다음에 변경할 때 해당 리스트가 변경될 수 있다.&lt;br /&gt;단순히 다른 곳에 저장된 리스트을 반환했다면 mapcan을 사용하는 것은 안전하지 않았을 것이다.&lt;br /&gt;대신 우리는 리턴된 리스트를 append로 연결해야 했다. 이러한 경우 mappend는 비파괴적인 mapcan의 대안을 제공한다.&lt;br /&gt;&lt;br /&gt;다음 유틸리티, mapcars 함수,는 여러 목록에 함수를 매핑하는 경우사용된다.&lt;br /&gt;우리에게 두 개의 숫자리스트가 있고, 제곱근의 단일 리스트를 얻고 싶다면?&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(mapcar #&#39;sqrt (append list1 list2))&lt;br /&gt;&lt;/pre&gt;하지만 여기서 실행되는 conses는 불필요한 일이다. 우리는 list1, list2를 append하여 즉시 결과를 폐기한다.&lt;br /&gt;mapcars를 사용하면 다음과 같은 결과를 어등ㄹ 수 있다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(mapcars #&#39;sqrt list1 list2)&lt;br /&gt;&lt;br /&gt;;; 코드를 보자.&lt;br /&gt;(defun mapcars (fn &amp;rest lsts)&lt;br /&gt;  (let ((result nil)) ;; 일단 리턴할 result를 nil로&lt;br /&gt;    (dolist (lst lsts) ;; lsts를 lst란 이름으로 순회&lt;br /&gt;   (dolist (obj lst)  ;; lst를 obj란 이름으로 순회&lt;br /&gt;     (push (funcall fn obj) result)))  ;; funcall로 fn에 obj를 넣어서 실행 후 result에 push&lt;br /&gt; (nreverse result)))  ;; 뒤집어서 던짐.&lt;br /&gt;&lt;/pre&gt;이러면 우리는 매개변수를 던질때 굳이 cons를 하여 던질 필요가 없다.&lt;br /&gt;&lt;br /&gt;Figure4.6의 마지막 함수는 tree를 위한 mapcar다.&lt;br /&gt;rmapcar는 &quot;recursive mapcar&quot;의 줄인말이다. mapcar는 평평한 리스트에서 작동하며, 이녀석은 tree에서 작동한다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(rmapcar #&#39;princ &#39;(1 2 (3 4 (5) 6) 7 (8 9))) &lt;br /&gt;123456789&lt;br /&gt;(1 2 (3 4 (5) 6) 7 (8 9))&lt;br /&gt;&lt;br /&gt;&gt; (rmapcar #&#39;+ &#39;(1 (2 (3) 4)) &#39;(10 (20 (30) 40)))&lt;br /&gt;(11 (22 (33) 44))&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;;; 코드구경&lt;br /&gt;(defun rmapcar (fn &amp;rest args)  ;; args가 트리 (&amp;rest인걸보니 여러개 들어올 수 있음)&lt;br /&gt;  (if (some #&#39;atom args)  ;; 하나만 들어왔다면&lt;br /&gt;      (apply fn args)  ;; 바로 하나만 실행해버림&lt;br /&gt;   (apply #&#39;mapcar  ;; 아니라면 mapcar 실행&lt;br /&gt;          #&#39;(lambda (&amp;rest args)&lt;br /&gt;              (apply #&#39;rmapcar fn args))  ;; 재귀를 실행할 람다 생성&lt;br /&gt;    args)))  ;; apply는 마지막 매개변수가 list여야 한다. 이 list들은 추가적인 매개변수들로 적용된다.&lt;br /&gt;;; http://n-a-n-o.com/lisp/cmucl-tutorials/LISP-tutorial-20.html apply 내용출처&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;나중에 이것들을 실제로 쓸 것이다.&lt;br /&gt;CLTL2에서 소개된 새로운 시리즈의 매크로들은 기존의 리스트 매핑 기능을 어느 정도 쓸모없게 만들었따.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(mapa-b #&#39;fn a b c)&lt;br /&gt;&lt;/pre&gt;이녀석은 아래처럼 바뀐다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(collect (#Mfn (scan-range :from a :upto b :by c)))&lt;br /&gt;&lt;/pre&gt;뭐야 Mfn는 모나드를 말하는 건가?&lt;br /&gt;뭐 여튼 이런게 있다고 한다.&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/7091061922247836145/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/01/on-list-45-mapping.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/7091061922247836145'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/7091061922247836145'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/01/on-list-45-mapping.html' title='[on lisp] 4.5 Mapping  매핑'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-5781820001789847383</id><published>2019-01-07T16:45:00.000+09:00</published><updated>2019-01-07T16:45:00.788+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="lisp"/><title type='text'>[on lisp] 4.4 Search 탐색</title><content type='html'>4.4 Search &lt;br /&gt;&lt;br /&gt;이 절에는 리스트를 탐색하는 함수의 몇 가지 예가 수록되어있다.&lt;br /&gt;커먼리습은 이것을 위해 풍부한 빌트인 연산자를 제공하지만, 일분 작업들은 여전히 어렵거나, 적어도 효율적으로 수행하기 어렵다.&lt;br /&gt;&lt;br /&gt;일단 우리는 그 전에 리스트 안에 리스트들을 모두 순회하는 함수들을 알아보자. 이전에는 최상위 리스트 (1차원)만을 매개변수로 받았지만&lt;br /&gt;이번에는 다르다. 아래처럼 실행이 될 것이다.&lt;br /&gt;flatten은 평평하게 만드는 것이고, prune(가지치다) evenp인 녀석은 없애버린다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (flatten &#39;(a (b c) ((d e) f)))&lt;br /&gt;(A B C D E F)&lt;br /&gt;&gt; (prune #&#39;evenp &#39;(1 2 (3 (4 5) 6) 7 8 (9)))&lt;br /&gt;(1 (3 (5)) 7 (9))&lt;br /&gt;&lt;/pre&gt;유틸리티 코드의 소스를 보자.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;Figure 4.3: Doubly-recursive list utilities.&lt;br /&gt;&lt;br /&gt;(defun flatten (x)&lt;br /&gt;  (labels ((rec (x acc)&lt;br /&gt;  (cond ((null x) acc)  ;; x가 끝나면 acc리턴&lt;br /&gt;        ((atom x) (cons x acc))  ;; x가 cons가 아닌 요소 하나라면 acc와 cons로 합침. 그리고 리턴&lt;br /&gt;        (t (rec (car x) (rec (cdr x) acc))))))  ;; 나머지: 나머지요소와 acc를 마저 재귀돌리고 다 돌리면 첫번째 요소와 합친다.&lt;br /&gt;    (rec x nil)))  ;; acc 는 nil로 시작한다.&lt;br /&gt;;; 보면 알겠지만 안으로 계속 들어가면서 car으로 빼내서 acc에 계속 더한다.&lt;br /&gt;&lt;br /&gt;(defun prune (test tree)&lt;br /&gt;  (labels ((rec (tree acc)&lt;br /&gt;  (cond ((null tree) (nreverse acc)) ;; 1. tree가 더이상 없다면 리턴&lt;br /&gt;        ((consp (car tree))  ;; 2. tree가 cons다 더 있다.&lt;br /&gt;         (rec (cdr tree)  ;; 2.2 나머지 트리를 남겨서 재귀를 돌림.&lt;br /&gt;       (cons (rec (car tree) nil) acc))) ;; 2.1 하나짜리는 따로 (rec (car tree) nil) 로 보내서 (funcall test...) 에 들어가도록 하여 테스트를 진행한다. &lt;br /&gt;        (t (rec (cdr tree)&lt;br /&gt;         (if (funcall test (car tree))&lt;br /&gt;      acc  ;; 테스트에 맞으면 누산기 리턴&lt;br /&gt;    (cons (car tree) acc))))))) ;; 틀리면 누산기에 더해서 리턴&lt;br /&gt;    (rec tree nil)))&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;이제 다음 유틸리티 소스들을 구경해보자.&lt;br /&gt;before함수는 리스트에서 한 개체가 다른 개체보다 먼저 발견되는지 여부를 알려준다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (before &#39;b &#39;d &#39;(a b c d))&lt;br /&gt;(B C D)  ;; b가 d앞에 있는지&lt;br /&gt;&lt;br /&gt;;; 아래처럼 적당히 얼버무려서 raw Lisp로 풀 수도 있다.&lt;br /&gt;&gt; (&lt; (position &#39;b &#39;(a b c d)) (position &#39;d &#39;(a b c d)))&lt;br /&gt;&lt;/pre&gt;하지만 뒤에 코드는 비효율적이며 에러가 나기 쉽다. 비효율적인 이유: 우리는 두 객체를 모두 찾을 필요가 없다. 둘 다 순회하다가 한놈만 찾으면 게임은 끝난다. 에러나기 쉬운 이유: 만약 객체가 리스트가 아닌 경우, nil이 &#39;&lt;&#39;계산을 위한 매개변수로 들어올 것이다. before의 특이한 점은 옵셔널 값이 있다는 점이다. 그래서 값이 없으면 기본값으로 비교를 하고 커스텀을 하려면  다른 함수를 넣으면 된다. 이 녀석은 test라는 이름에 매핑된다. &lt;pre class=&#39;prettyprint&#39;&gt;&lt;br /&gt;(defun find2 (fn lst)&lt;br /&gt;  (if (null lst)&lt;br /&gt;    nil&lt;br /&gt;    (let ((val (funcall fn (car lst))))&lt;br /&gt;      (if val&lt;br /&gt;     (values (car lst) val)&lt;br /&gt;     (find2 fn (cdr lst))))))&lt;br /&gt;&lt;br /&gt;(defun before (x y lst &amp;key (test #&#39;eql))&lt;br /&gt;  (and lst&lt;br /&gt;    (let ((first (car lst)))&lt;br /&gt;   (cond ((funcall test y first) nil)&lt;br /&gt;         ((funcall test x first) lst)&lt;br /&gt;         (t (before x y (cdr lst) :test test))))))&lt;br /&gt;     &lt;br /&gt;(defun after (x y lst &amp;key (test #&#39;eql))&lt;br /&gt;  (let ((rest (before y x lst :test test)))&lt;br /&gt;    (and rest (member x rest :test test))))&lt;br /&gt;&lt;br /&gt;;; :test -- a designator for a function of two arguments that returns a generalized boolean.&lt;br /&gt;(defun duplicate (obj lst &amp;key (test #&#39;eql))&lt;br /&gt;  (member obj (cdr (member obj lst :test test)) &lt;br /&gt;   :test test))&lt;br /&gt;&lt;br /&gt;(defun split-if (fn lst)&lt;br /&gt;  (let ((acc nil))&lt;br /&gt;    (do ((src lst (cdr src)))&lt;br /&gt; ((or (null src) (funcall fn (car src)))&lt;br /&gt;  (values (nreverse acc) src))&lt;br /&gt;      (push (car src) acc))))&lt;br /&gt;&lt;/pre&gt;before에 첫번째 인수가 두번째 인수보다 먼저 나오면 참이다. (원래 그러려고 만든거다)&lt;br /&gt;즉, 두번째 인수가 리스트에서 전혀 보이지 않아도 참이다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (before &#39;a &#39;b &#39;(a))&lt;br /&gt;(A)&lt;br /&gt;&lt;/pre&gt;after를 호출하면 정확히 알 수 있다. 이 테스트에서는 두 인수가 모두 리스트안에 있어야 한다.&lt;br /&gt;일단 이걸 이해하려면 member에 대해 알아야 한다. 아래처럼 동작한다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(member 2 &#39;(1 2 3)) ; (2 3)&lt;br /&gt;(member 2 &#39;((1 . 2) (3 . 4)) :test-not #&#39;= :key #&#39;cdr) ; ((3 . 4))&lt;br /&gt;&lt;br /&gt;&gt; (after &#39;a &#39;b &#39;(b a d))&lt;br /&gt;(A D)&lt;br /&gt;&gt; (after &#39;a &#39;b &#39;(a))&lt;br /&gt;NIL&lt;br /&gt;&lt;/pre&gt;duplicate함수는 중복되는 것이 생기면 그곳에서 멈추고 cons를 뱉는다. 그러면 뒤에 연결된 아이들도 보일 것이다.&lt;br /&gt;&lt;br /&gt;좀 더 까다로운 언어 디자이너들은 Common Lisp가 거짓과 빈 리스트를 모두 나타내기 위해 nil을 사용한다는 것에 충격을 받는다.&lt;br /&gt;때로는 문제를 일으키기도 하지만(14.2 참조, 나중에 보자), 중복과 같은 기능에서 편리하다.&lt;br /&gt;&lt;br /&gt;마지막의 member함수는 어떤 조건에 따라 리스트를 나눈다. &lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (split-if #&#39;(lambda (x) (&gt; x 4)) &#39;(1 2 3 4 5 6 7 8 9 10))&lt;br /&gt;(1 2 3 4)&lt;br /&gt;(5 6 7 8 9 10)&lt;br /&gt;&lt;/pre&gt;리턴이 2개가 되고 하나를 출력하려 하면 첫번째 것만 보인다. &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;Figure4.4를 넘어가서 Figure4.5 를 보자.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;;; Figure 4.5: Search functions which compare elements.&lt;br /&gt;(defun most (fn lst)&lt;br /&gt;  (if (null lst)&lt;br /&gt;    (values nil nil)&lt;br /&gt;    (let* ((wins (car lst))&lt;br /&gt;        (max (funcall fn wins)))&lt;br /&gt;      (dolist (obj (cdr lst))&lt;br /&gt;     (let ((score (funcall fn obj)))&lt;br /&gt;       (when (&gt; score max)&lt;br /&gt;         (setq wins obj&lt;br /&gt;            max score))))&lt;br /&gt;      (values wins max))))&lt;br /&gt;&lt;br /&gt;(defun best (fn lst)&lt;br /&gt;  (if (null lst)&lt;br /&gt;    nil&lt;br /&gt;    (let ((wins (car lst)))&lt;br /&gt;      (dolist (obj (cdr lst))&lt;br /&gt;     (if (funcall fn obj wins)&lt;br /&gt;       (setq wins obj)))&lt;br /&gt;      wins)))&lt;br /&gt;&lt;br /&gt;(defun mostn (fn lst)&lt;br /&gt;  (if (null lst)&lt;br /&gt;      (values nil nil)&lt;br /&gt;    (let ((result (list (car lst)))&lt;br /&gt;       (max (funcall fn (car lst))))&lt;br /&gt;      (dolist (obj (cdr lst))&lt;br /&gt;     (let ((score (funcall fn obj)))&lt;br /&gt;     (cond ((&gt; score max)&lt;br /&gt;            (setq max score&lt;br /&gt;                  result (list obj)))&lt;br /&gt;        ((= score max)&lt;br /&gt;            (push obj result)))))&lt;br /&gt;      (values (nreverse result) max))))&lt;br /&gt;&lt;/pre&gt;Figure4.5 에는 다른 종류의 검색 기능을 포함한다.&lt;br /&gt;&lt;br /&gt;첫번째, most함수, 한 번에 하나의 요소만 확인한다. 리스트와 점수를 매길함수를 주면, 가장큰 스코어를 낸 요소를 리턴한다.&lt;br /&gt;아래 테스트에서는 중복된 값이 있으면 먼저된 녀석이 리턴된다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (most #&#39;length &#39;((a b) (a b c) (a) (e f g)))&lt;br /&gt;(A B C)&lt;br /&gt;3&lt;br /&gt;&lt;br /&gt;;; 코드를 구경하자.&lt;br /&gt;(defun most (fn lst)&lt;br /&gt;  (if (null lst)  ;; lst가 없으면, nil nil을 뱉는다.&lt;br /&gt;      (values nil nil)&lt;br /&gt;    (let* ((wins (car lst))     ;; lst의 첫번째를 뽑는다.&lt;br /&gt;    (max (funcall fn wins)))   ;; 첫번째의 값을 점수매겨서 max에 넣어본다.&lt;br /&gt;      (dolist (obj (cdr lst))     ;; lst의 나머지를 반복문 돌린다.&lt;br /&gt;     (let ((score (funcall fn obj)))  ;; 나머지 값 하나하나를 점수 매긴다.(score)&lt;br /&gt;       (when (&gt; score max)     ;; 만약 max보다 score가 크면&lt;br /&gt;         (setq wins obj        ;; wins에는 큰 녀석의 요소와&lt;br /&gt;            max score))))   ;; max에는 score값는 넣는다.&lt;br /&gt;      (values wins max))))        ;; 끝나면 리턴한다.&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;좀 더 일반적인 검색은 best에서 보여주고 있다.&lt;br /&gt;이 유틸리티는 함수와 리스트를 받는다. 그런데 여기서 함수는 꼭 두개의 인수를 받는 predicate이어야 한다.&lt;br /&gt;이 predicate으로 나머지를 이긴 녀석을 리턴한다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (best #&#39;&gt; &#39;(1 2 3 4 5))&lt;br /&gt;5&lt;br /&gt;&lt;br /&gt;;;역시 코드를 파보자.&lt;br /&gt;(defun best (fn lst)&lt;br /&gt;  (if (null lst)  ;; 없으면 nil&lt;br /&gt;    nil&lt;br /&gt;    (let ((wins (car lst)))  ;; lst의 첫번째 값을 일단 받아서 시작할 거다.&lt;br /&gt;      (dolist (obj (cdr lst))  ;; lst의 나머지를 obj라는 요소에 하나하나 담아서 반복문 실행&lt;br /&gt;     (if (funcall fn obj wins)  ;; fn(predicate)에 obj,wins를 넣어서&lt;br /&gt;       (setq wins obj)))  ;; 트루면 값을 바꾼다.&lt;br /&gt;      wins)))  ;; 이긴놈을 리턴한다.&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;마지막으로 mostn을 보자. &lt;br /&gt;함수와 리스트를 받아서 가장큰 스코어를 가진 요소들을 리스트로 리턴한다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (mostn #&#39;length &#39;((a b) (a b c) (a) (e f g)))&lt;br /&gt;((A B C) (E F G))&lt;br /&gt;&lt;br /&gt;;; 코드구경&lt;br /&gt;(defun mostn (fn lst)&lt;br /&gt;  (if (null lst)  ;; 없으면 nil&lt;br /&gt;      (values nil nil)&lt;br /&gt;    (let ((result (list (car lst)))  ;; 첫번째 값을 리스트로 감쌈&lt;br /&gt;       (max (funcall fn (car lst)))) ;; 첫번째 값의 점수를 매기고 그걸 임시로 max에 넣음&lt;br /&gt;      (dolist (obj (cdr lst))  ;; 나머지부터 dolist로 실행 &lt;br /&gt;     (let ((score (funcall fn obj)))  ;; 요소를 점수매겨 score에 넣음&lt;br /&gt;     (cond ((&gt; score max)  ;; score가 max보다 크면&lt;br /&gt;            (setq max score  ;; max를 score로 대체&lt;br /&gt;                  result (list obj)))  ;; result를 (list obj)로 대체&lt;br /&gt;        ((= score max)  ;; score == max 면&lt;br /&gt;            (push obj result)))))  ;; result에 값을 추가.&lt;br /&gt;      (values (nreverse result) max))))&lt;br /&gt;&lt;/pre&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/5781820001789847383/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-44-search.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/5781820001789847383'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/5781820001789847383'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-44-search.html' title='[on lisp] 4.4 Search 탐색'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-7960544673116937432</id><published>2019-01-07T11:33:00.003+09:00</published><updated>2019-01-07T11:33:33.913+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="lisp"/><title type='text'>[on lisp] 4.3 Operations on Lists 리스트 연산자</title><content type='html'>4.3 Operations on Lists &lt;br /&gt;&lt;br /&gt;&quot;Lisp&quot;는 &quot;List Processing&quot;이라는 유래처럼 list는 lisp의 메인 자료구조이다.&lt;br /&gt;그러나 이 역사설 사실에 현혹되지 말자. Polo셔츠가 Polo를 위한 것이 아닌 것처럼 고도로 최적화된 Common Lisp프로그램에서 리스트는 더이상 볼 수 없다.&lt;br /&gt;&lt;br /&gt;적어도 컴파일 타임에는 여전히 리스트일 것이다.&lt;br /&gt;가장 정교한 프로그램(리스트를 런타임에 적게 사용하는 것)은 매크로 확장을 생성할 때 컴파일 시간에 (줄어든 런타임시간에 비례하여) 더 많이 사용한다.&lt;br /&gt;그러므로 비록 현대 방언에서 리스트의 역할이 줄어들지라도, 리스트 연산은 여전히 리습에서 큰 부분을 차지한다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;;; Figure 4.1: Small functions which operate on lists.&lt;br /&gt;(proclaim &#39;(inline last1 single append1 conc1 mklist))&lt;br /&gt;&lt;br /&gt;(defun last1 (lst)&lt;br /&gt;  (car (last lst)))&lt;br /&gt;&lt;br /&gt;(defun single (lst)&lt;br /&gt;  (and (consp lst) (not (cdr lst))))&lt;br /&gt;&lt;br /&gt;(defun append1 (lst obj)&lt;br /&gt;  (append lst (list obj)))&lt;br /&gt;&lt;br /&gt;(defun conc1 (lst obj)&lt;br /&gt;  (nconc lst (list obj)))&lt;br /&gt;&lt;br /&gt;(defun mklist (obj)&lt;br /&gt;  (if (listp obj) obj (list obj)))&lt;br /&gt;&lt;/pre&gt;첫번째로 last1, 리스트의 마지막 요소를 반환한다. 빌트인 함수는 마지막 요소가 아니라 목록의 마지막 cons를 반환한다.&lt;br /&gt;대부분의 경우 마지막 요소를 얻기 위해 (car (last ...))를 사용한다. 그런 경우를 위해 새로운 유틸리티를 쓸 가치가 잇는가?&lt;br /&gt;있다!, 빌트인 연산자 중 하나를 효과적으로 대체할 수 있다면 그렇다!&lt;br /&gt;last은 오류 검사를 하지 않는다. 일반적으로 이 책의 코드는 오류검사를 하지 않는다. 부분적으로 이것이 예제를 더 명확하게 만든다.&lt;br /&gt;그리고 짧은 유틸리티의 경우 오류 검사를 하지 않는 것이 합리적이다. 만약 아래와 같은 문제를 만났다 하자.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (last1 &quot;blub&quot;)&lt;br /&gt;&gt;&gt;Error: &quot;blub&quot; is not a list.&lt;br /&gt;Broken at LAST...&lt;br /&gt;&lt;/pre&gt;에러는 last에서 잡힐 것이다. 유틸리티가 작을 때, 추상화된 레이어가 너무 얇아서 투명 해지기까지 한다.&lt;br /&gt;얇은 얼음층을 통해 그 밑에 일어난 일을 알 수 있듯이, last1같은 유틸리티 또한 그 밑에 있는 함수에서 발생하는 오류를 보는데 문제가 없다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;함수 single은 리스트의 요소가 하나인지 아닌지를 확인한다.&lt;br /&gt;리습 프로그램에선 이 테스트를 꽤 자주 할 필요가 있다. 아래처럼 쓰다보나, 처음에는 영어로 된 자연스러운 벙역으로 바꾸고 싶었을 것이다. &lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(= (length lst) 1)&lt;br /&gt;&lt;/pre&gt;이런 식으로 쓰여 있으면, 이 테스트는 아주 비효율적일 것이다.&lt;br /&gt;우리는 첫 번째 요소를 지나치자마자 이것이 하나만 있는지 아닌지 알 수 있다. 그런데 length를 쓰다니? 아주 비효율적이다. single이 훨씬 낫다.&lt;br /&gt;&lt;br /&gt;다음으로 append1과 conc1이다.&lt;br /&gt;둘다 새로운 요소를 리스트 마지막에 붙인다. conc1는 파괴적으로 (수정한다는 말)&lt;br /&gt;이러한 함수는 아주 작지만 자주 필요하기 때문에 정의할 가치가 있다. 실제로, append1은 이전의 lisp방언에 미리 정의되어 있다.&lt;br /&gt;&lt;br /&gt;(적어도) Interlisp에는 미리 정의되어 있는 mklist라는 것도 있다.&lt;br /&gt;이녀석은 어떤 것이 정말로 list인지 확인한다. 많은 리습 함수는 단일 값 또는 리스트로 반환하기 위해 작성된다.&lt;br /&gt;그런데 이 모든 것들을 리스트로 반환하도록 하는 것이다. (괜찮다)&lt;br /&gt;&lt;br /&gt;만약에 lookup이라는 함수가 있다고 하자. 데이터라고 불리는 리스트의 모든 요소에 대해 조회를 호출하여 결과를 수집한다고 하자.&lt;br /&gt;우린 다음처럼 쓸 것이다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(mapcan #&#39;(lambda (d) (mklist (lookup d)))&lt;br /&gt; data)&lt;br /&gt;&lt;/pre&gt;이러면 전부 리스트로 반환되서 수집될 것이다.&lt;br /&gt;&lt;br /&gt;좀 더 긴 예제를 둘러보자.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;;; Figure 4.2: Larger functions that operate on lists.&lt;br /&gt;(defun longer (x y)&lt;br /&gt;  (labels ((compare (x y)&lt;br /&gt;      (and (consp x)&lt;br /&gt;    (or (null y)&lt;br /&gt;        (compare (cdr x) (cdr y))))))&lt;br /&gt;    (if (and (listp x) (listp y))&lt;br /&gt; (compare x y)&lt;br /&gt;      (&gt; (length x) (length y)))))&lt;br /&gt;&lt;br /&gt;(defun filter (fn lst)&lt;br /&gt;  (let ((acc nil))&lt;br /&gt;    (dolist (x lst)&lt;br /&gt;      (let ((val (funcall fn x)))&lt;br /&gt; (if val (push val acc))))&lt;br /&gt;    (nreverse acc)))&lt;br /&gt;&lt;br /&gt;(defun group (source n)&lt;br /&gt;  (if (zerop n) (error &quot;zero length&quot;))&lt;br /&gt;  (labels ((rec (source acc)&lt;br /&gt;  (let ((rest (nthcdr n source)))&lt;br /&gt;    (if (consp rest)&lt;br /&gt;        (rec rest (cons (subseq source 0 n) acc))&lt;br /&gt;      (nreverse (cons source acc))))))&lt;br /&gt;    (if source (rec source nil) nil)))&lt;br /&gt;&lt;/pre&gt;그림 4.2에서는 좀 더 큰 리스트 유틸리티의 예제가 주어졌다.&lt;br /&gt;&lt;br /&gt;첫 번째는, longer 함수, 추상화뿐만 아니라 효율성의 관점에서도 유용하다.&lt;br /&gt;두 시퀀스를 비교하여 더 길 경우에 참을 리턴한다.&lt;br /&gt;우리가 두 리스트를 비교할 때, 아래처럼 적는 경우가 있다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(&gt; (length x) (length y))&lt;br /&gt;&lt;/pre&gt;위 코드는 두 리스트의 전체 길이를 전부 순회해야 하기 때문에 비효율적이다.&lt;br /&gt;한 리스트가 다른 리스트보다 훨씬 더 길다면, 그 길이의 차이를 건너는 만큼 그 노력이 낭비가 될 것이다.&lt;br /&gt;병렬로 두개의 리스트가 넘어가면서 비교하는 것이 더 빠르다.&lt;br /&gt;longer 안에는 재귀가 실행되고 있다. compare라는 lambda가 labels로 이름 붙여져 있다. &lt;br /&gt;이녀석으로 하나하나 비교하고 재귀로 그 다음 요소를 비교한다.&lt;br /&gt;longer함수는 길이를 비교하는 함수이기 때문에, 길이를 인수로 줄 수 있는 모든 것에 대해 작동해야 한다.&lt;br /&gt;하지만 길이를 병렬로 비교할 수 있는 녀석은 리스트인 경우에만 적용된다. 내부 함수(internal function)는 두 인수가 모두 목록인 경우에만 호출된다.&lt;br /&gt;&lt;br /&gt;다음 함수, filter를 알아보자.&lt;br /&gt;&lt;br /&gt;빌트인 remove-if-not은 연속적인 cdrs에서 동일한 기능을 가진 find-if를 호출했을 때 반환될 수 있는 모든 값을 반환하지 않는다.&lt;br /&gt;이와 유사하게 필터는 목록의 연속 cdrs에 대해 일부 반환된 것을 반환한다. &lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(remove-if-not #&#39;evenp &#39;(1 2 3 4 5 6))&lt;br /&gt;;; (2 4 6)&lt;br /&gt;&lt;br /&gt;(filter #&#39;(lambda (x) (if (numberp x) (1+ x))) &#39;(a 1 2 b 3 c d 4))&lt;br /&gt;; (2 3 4 5)&lt;br /&gt;&lt;/pre&gt;filter함수에게 함수와 리스트를 주면, 매개변수로 받는 함수가 리스트의 요소 하나하나에 적용되면서 그 값이 non-nil이 아닌 것들의 리스트를 리턴받는다. &lt;br /&gt;filter함수는 섹션2.8에서본 &quot;tail-recursive functions&quot;가 사용한 누산기(acccumulator)를 사용하고 있다는 것을 유의하자.&lt;br /&gt;잠깐 2.8을 구경해보자.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;;; 2.8 Tail Recursion&lt;br /&gt;(defun our-length (lst)&lt;br /&gt;  (labels ((rec (lst acc)&lt;br /&gt;  (if (null lst)&lt;br /&gt;      acc&lt;br /&gt;    (rec (cdr lst) (1+ acc)))))&lt;br /&gt;    (rec lst 0)))&lt;br /&gt;&lt;/pre&gt;사실, tail-recursive한 함수를 작성하는 목적은 컴파일러가 filter 형태의 코드를 생성하도록 하는 것이다.&lt;br /&gt;필터의 경우, 간단한 반복 정의는 꼬리 재현보다 더 간단하다. &lt;br /&gt;필터의 정의에서 push와 nreverse의 조합은 리스트를 누적하는(accumulate) 표준 lisp 관용구이다.&lt;br /&gt;코드를 자세히 봐보자. filter 코드에는 신기하게 재귀가 없다.&lt;br /&gt;컴파일러는 이렇게 변경을 시도 한다는 것 같다.&lt;br /&gt;누산기 acc를 정의하고, dolist를 이용하여 lst의 요소들을 순회한다.&lt;br /&gt;funcall을 이용하여 요소(x) 하나하나를 순회하여 실행하여 val로 지정하고, &lt;br /&gt;if 문으로 val이 non-nil인지 확인 하면 누산기 acc에 push한다.&lt;br /&gt;그리고 뒤집는다. nreverse는 값을 파괴적으로 뒤집는다. 꽤나 빠르게&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(defun filter (fn lst)&lt;br /&gt;  (let ((acc nil))&lt;br /&gt;    (dolist (x lst)&lt;br /&gt;      (let ((val (funcall fn x)))&lt;br /&gt; (if val (push val acc))))&lt;br /&gt;    (nreverse acc)))&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Figure 4.2의 마지막 함수를 보자. group함수는 리스트를 그룹핑하여 서브리스트에 넣는것이다.&lt;br /&gt;group함수에게 리스트 l과 숫자n을 보내면, l의 요소가 길이 n의 서브리스트로 분류된 새로운 리스트가 반환된다.&lt;br /&gt;나머지는 마지막 서브리스트에 들어간다.&lt;br /&gt;따라서 두 번째 인수로 2를 지정하면 다음과 같은 목록이 나온다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;&gt; (group &#39;(a b c d e f g) 2)&lt;br /&gt;((A B) (C D) (E F) (G))&lt;br /&gt;&lt;/pre&gt;이 함수는 tail-recursive한 함수를 만들기 위해 다소 복잡한 방식으로 짜졌다.&lt;br /&gt;신속한 프로토타이핑의 원칙은(The principle of rapid prototyping)은 개별 기능뿐만 아니라 전체 프로그램에도 적용된다.&lt;br /&gt;flatten같은 함수를 작성할 때 가장 간단한 구현으로 시작하는 것이 좋다.&lt;br /&gt;그 다음, 간단한 버전이 작동하면 필요에 따라 효율적인 tail-recursive나 iterative 버전으로 바꿀수 있다.&lt;br /&gt;만약 초기 버전으로 충분하다면, 초기 버전은 그것의 행위를 코멘트로 남겨놓아야 하며, 이것이 무엇을 대체하는 행위인지 코멘트를 남겨야 한다.&lt;br /&gt;&lt;br /&gt;group의 정의는 하나 이상의 오류를 검사한다는 점에서 일반적이지 않다. 이렇게 체크하지 않으면 두번째 인수에 0이 오면 무한 재귀로 보내버린다.&lt;br /&gt;&lt;br /&gt;어떤 면에서, 이 책의 예들은 일반적인 Lisp 예제와 다르다. 각장을 서로 독립적으로 만들기 위해서, 코드의 예들은 가능한 한 원시 Lisp로 쓰여졌다.&lt;br /&gt;group 함수는 매크로를 정의하는데 매우 유용하기 때문에 이후 여러 장에서 다시 나타난다.&lt;br /&gt;나가기전에 group을 파해쳐보자.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(defun group (source n)&lt;br /&gt;  (if (zerop n) (error &quot;zero length&quot;))  ;; 1. 길이 0이면 끝&lt;br /&gt;  (labels ((rec (source acc)&lt;br /&gt;  (let ((rest (nthcdr n source)))  ;; 자르고 남은 뒷부분을 rest로 &lt;br /&gt;    (if (consp rest)  ;; rest가 cons인지 확인 &lt;br /&gt;        (rec rest (cons (subseq source 0 n) acc))  ;; acc(누산기)에 앞에 자른 n개의 그룹을 cons로 더한다. 그리고 rest와 acc를 재귀돌린다.&lt;br /&gt;      (nreverse (cons source acc))))))  ;; 마지막에 파괴적인 reverse로 반대로 리턴&lt;br /&gt;    (if source (rec source nil) nil)))  ;; 2. source가 없으면 nil&lt;br /&gt;&lt;br /&gt;;; cons와 nreverse를 좀 더 확인해보자.&lt;br /&gt;(cons &#39;(1 2 3) &#39;((a b c)))&lt;br /&gt;; ((1 2 3) (A B C))&lt;br /&gt;(nreverse (cons &#39;(1 2 3) &#39;((a b c))))&lt;br /&gt;; ((A B C) (1 2 3))&lt;br /&gt;&lt;/pre&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/7960544673116937432/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-43-operations-on-lists.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/7960544673116937432'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/7960544673116937432'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-43-operations-on-lists.html' title='[on lisp] 4.3 Operations on Lists 리스트 연산자'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-3990198601231553651</id><published>2019-01-06T14:59:00.001+09:00</published><updated>2019-01-07T11:33:48.125+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="lisp"/><title type='text'>[on lisp] 4.2 Invest in Abstraction (추상화에 투자)</title><content type='html'>4.2 Invest in Abstraction (추상화에 투자)&lt;br /&gt;&lt;br /&gt;간결함이 지혜 영혼이라면, 그것은 효율성과 함께 좋은 소프트웨어의 본질이다.&lt;br /&gt;&lt;br /&gt;프로그램의 작성,유지보수의 비용은 그 길이에 따라 증가한다.&lt;br /&gt;만약 다른 부분이 동일하다면, 프로그램은 짧은 수록 좋다.&lt;br /&gt;&lt;br /&gt;이런 관점에서 보면, 유틸리티의 작성은 자본지출로 간주되어야 한다.&lt;br /&gt;find-books를 유틸리지 find2로 교체함으로써, 우리는 많은 코드 라인을 직면하게 된다.&lt;br /&gt;&lt;br /&gt;하지만 우리는 더 짧게 만들었다고 말할 수도 있게 되는데, 유틸리티 코드의 길이는 현재 프로그램에 자본지출로 부과되지 않을 것이다.&lt;br /&gt;(왜냐하면 범용적이기 때문이라고 생각함)&lt;br /&gt;이것은 단순히 Lisp의 확장을 자본지출로 취급하는 것은 단지 회계속임수가 아니다.&lt;br /&gt;유틸리티들은 다른 파일로 분리될 수 있다. 이것들은 우리가 프로그램 작업을 할 때, 우리의 시각을 혼란스럽게 만들지 않을 것이고, &lt;br /&gt;우리가 나중에 돌아와서 프로그램의 어떤 곳을 변경하려 할 때, 참여하지 않을 것이다.(다시 한번, 유틸리티는 범용적이다)&lt;br /&gt;&lt;br /&gt;자본 지출로서, 유틸리티는 더 많은 관심이 필요하다.&lt;br /&gt;잘 짜는 것이 중요하다. 이것들은 반복적으로 사용될 것이기 때문에, 부정확성이나 비효율성이 배가 될 것이다.(잘못짜면)&lt;br /&gt;이런 추가적인 관심은 디자인에 반영되어야 한다. (설계시 주의해야 한다.)&lt;br /&gt;유틸리티는 당면한 문제가 아니라 일반적인(범용) 경우를 위해 만들어져야 한다.&lt;br /&gt;&lt;br /&gt;마지막으로, 여타 다른 자본 지출과 마찬가지로, 우리는 유틸리티를 만드는데 서두를 필요가 없다.&lt;br /&gt;새로운 연산자로 사용하려고 생각하고 있지만, 그것을 정말로 원하는건지 확신하지 못한다면, &lt;br /&gt;일단 작성하되, 현재 사용하고 있는 (도메인에)특정한 프로그램 또한 남겨놔라.&lt;br /&gt;나중에 다른 프로그램에서 새 연산자를 사용하면 서브루틴에서 유틸리티로 승격하여 일반적으로 접근 가능하도록 할 수 있다.&lt;br /&gt;(뭐 헬퍼 펑션을 만든다는 말인듯?)&lt;br /&gt;&lt;br /&gt;유틸리티 &#39;find2는 좋은 투자로 보입니다.&lt;br /&gt;7줄을 자본지출하여, 즉시 7줄의 비용절감을 한다.&lt;br /&gt;유틸리티는 처음 사용했을 때 이미 그 대가를 치뤘다.&lt;br /&gt;&lt;br /&gt;가이스틸은 다음과 같이 썼다.&lt;br /&gt;&quot;간결성에 대한 우리의 자연스러운 경향에 협력해라&quot;&lt;br /&gt;&quot;cooperate with our natural tendency towards brevity&quot; &lt;br /&gt;&lt;br /&gt;&#39;우리는 프로그래밍 구성의 비용은 그것이 서경(書痙: 글씨를 너무 많이 써서 생기는 손의 통증)의 양에 비례한다고 믿는다.&lt;br /&gt;(그러니까 우리가 키보드질 많이 하는 것이 비용이라고 하는 것 / 여기서 &#39;믿는다&#39;는 열렬한 신념이 아니라 무의식적인 경향을 말한다)&lt;br /&gt;사실 이것이 언어설계자가 염두해야할 나쁜 심리 원칙은 아니다. &lt;br /&gt;우리는 덧셈이 저렵하다고 생각한다. 왜냐하면 우리는 &quot;+&quot;라는 한글자로 구분할 수 있기 때문이다.&lt;br /&gt;아무리 어떤 A의 구성이 비싸다고 믿어라도, 그것이 우리의 작문 노력을 반으로 줄인다면, 싼 구성보다 A의 구성을 선호할 것이다.&lt;br /&gt;&lt;br /&gt;모든 언어에서 &quot;간결성을 향한 경향&quot;은 새로운 유틸리티로 배출하지 않으면 문제를 일으킬 것이다. (요구를 말하는지 욕구를 말하는지?)&lt;br /&gt;가장 짧은 숙어가 가장 효율적인 숙어는 이기는 드물다.&lt;br /&gt;만약 당신이 한 리스트가 다른 리스트보다 긴지 여부를 알고 싶다면, 원시 Lisp는 우리에게 뭔가 작성하기를 유혹할 것.(아래처럼)&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(&gt; (length x) (length y))&lt;br /&gt;&lt;/pre&gt;여러 리스트에 함수를 매핑하려면, 먼저 함수를 다음처럼 결합해야 한다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(mapcar fn (append x y z))   ;; append로 결합&lt;br /&gt;&lt;/pre&gt;이런 예는 우리가 비효율적으로 처리하는 상황이 오면 유틸리티를 작성하는 것이 중요하다는 것을 알려준다.&lt;br /&gt;적잘한 유틸리티로 강화된 언어는 우리가 더 많이 추상화하여 프로그램을 만들 수 있다.&lt;br /&gt;이러한 유틸리티가 적절히 정의되면, 보다 효율적인 유틸리티를 작성하게 될 것이다.&lt;br /&gt;&lt;br /&gt;유틸리티 모음을 사용하면 확실히 프로그래밍이 쉬워진다. 하지만 이것들은 그 이상을 할 수 있다: 더 나은 프로그램으로 만들 수 있다.&lt;br /&gt;요리사 같은 뮤즈(예술가)들은 재료가 보이면 바로 행동을 취한다.&lt;br /&gt;이것이 예술이들이 그들의 스튜디오에 많은 도구와 재료를 갖고 싶어하는 이유다.&lt;br /&gt;그들은 (가지고 오는데) 준비가 필요한 것을 가까이에 가지고 있다면 새로운 것을 시작할 가능성이 많다는 것을 안다.&lt;br /&gt;상향식 프로그래밍에도 동일한 현상이 나타난다.&lt;br /&gt;일단 당신이 새로운 유틸리티를 짰다면, 당신은 그것을 생각했던 것보다 더 많이 사용하고 있는 당신을 발견할 것이다.&lt;br /&gt;&lt;br /&gt;다음 섹션에서는 유틸리티 함수의 여러 클래스를 설명한다.&lt;br /&gt;이것들이 lisp에 추가될 수 있는 모든 종류의 기능을 대표하지는 않는다.&lt;br /&gt;그러나 예로서 주어진 모든 유틸리티는 실제로 그들의 가치를 증명한 것들이다.</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/3990198601231553651/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/01/42-invest-in-abstraction.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/3990198601231553651'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/3990198601231553651'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/01/42-invest-in-abstraction.html' title='[on lisp] 4.2 Invest in Abstraction (추상화에 투자)'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-2319474238317730725</id><published>2019-01-04T12:01:00.004+09:00</published><updated>2019-01-04T12:01:32.371+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="lisp"/><title type='text'>[on lisp] 4. Utility Functions 유틸리티 함수</title><content type='html'>4. Utility Functions &lt;br /&gt;리스프 연산자에는 세 가지 유형이 있다.&lt;br /&gt;1. 함수 2. 매크로 3. special form (우리가 쓸 수 없는 것)&lt;br /&gt;이번 장에서 우리는 새로운 함수를 이용하여 리스프를 확장하는 기술을 설명한다.&lt;br /&gt;여기서 기술은 보통 하던 것과 다르다. &lt;br /&gt;이런 함수들에 대해 알아야할 중요한 점은 이것들이 어떻게 짜여지는 것이 아니라 어디에서 왔는가 이다.(어떤 생각에서 만들어지는지)&lt;br /&gt;&lt;br /&gt;리스프의 확장은 여타 다른 리습 함수를 만드는 것과 동일한 기술을 이용한다.&lt;br /&gt;이 확장에서 어려운 부분은 어떻게 쓸지를 결정하는 것이 아니라. 어떤 녀석을 확장할 지다.&lt;br /&gt;&lt;br /&gt;4.1 Birth of a Utility &lt;br /&gt;간단한 형태로, 상향식 프로그래밍은 누가 당신의 리스프를 설계했던간에 사후평가하는 것을 의미한다.(??)&lt;br /&gt;당신이 프로그램을 짜는 동시에, 당신의 프로그램을 쉽게 쓸 수 있게 해주는 연산자를 또한 추가한다.&lt;br /&gt;이런 연산자(operator)를 유틸리티라고 한다.&lt;br /&gt;&lt;br /&gt;&quot;유틸리티&quot;라는 용어는 정확한 정의를 가지고 있지 않다.&lt;br /&gt;코드의 한 부분이 별도의 어플리케이션이라고 보기에는 너무 작고, 어떤 특정 프로그램의 부분으로 고려하기에는 너무 범용적인 경우 &quot;유틸리티&quot;라 한다.&lt;br /&gt;예를들어, 데이터베이스 프로그램은 유틸리티가 아니라 목록에서 단일작업을 수행하는 기능이 될 수 있다.&lt;br /&gt;&lt;br /&gt;대부분 유틸리티는 리습이 이미 가지고 있는 매크로와 함수와 닮았다.(범용적이니까)&lt;br /&gt;실제로 많은 커먼리습의 빌트인 오퍼레이터는 유틸리티로 시작된 녀석들이다.&lt;br /&gt;함수 remove-if-not 같이 목록(리스트)에서 특정 predicate을 만족하는 모든 요소를 삭제하는 기능 또한 개별 프로그래머에게 정의되었던 녀석이다.&lt;br /&gt;&lt;br /&gt;유틸리티를 쓰는 법을 배우는 것은 그것을 쓰는 기술이라기보다는 그것을 쓰는 습관을 배우는 것으로 더 잘 설명될 것이라 한다.&lt;br /&gt;상향식 프로그래밍(Bottom-up programming)은 프로그램을 짜는 것과 동시에 프로그래밍 언어를 짜는 것이다.&lt;br /&gt;이것을 잘하려면 어던 오퍼레이터가 현재 프로그램에 부족한지 알아내는 섬세한 감각을 개발해야 한다.&lt;br /&gt;당신은 프로그램을 보고 이렇게 말할 수 있어야 한다. &quot;Ah, what you really mean to say is this&quot;&lt;br /&gt;직관적으로 이해할 수 있어야 한다는 말인듯?&lt;br /&gt;&lt;br /&gt;예를들어보자, nicknames라는 함수가 있다고 하자. 이름을 매개변수로 받아서 이것에서 파생되는 모든 닉네임들을 리스트로 뱉는다 해보자.&lt;br /&gt;어떻게 우리는 리스트에 있는 모든 이름들의 닉네임을 받을 수 있을까?&lt;br /&gt;우린리습을 배웠으니 아래처럼 할 것이다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(defun all-nicknames (names)&lt;br /&gt;  (if (null names)&lt;br /&gt;      nil&lt;br /&gt;   (nconc (nicknames (car names))&lt;br /&gt;          (all-nicknames (cdr names)))))&lt;br /&gt;&lt;/pre&gt;좀 더 경험있는 리스프 프로그래머라면, &quot;mapcan&quot;이라는 걸 쓸 것이다.&lt;br /&gt;====&lt;br /&gt;mapcan - function &amp;rest lists+ =&gt; concatenated-result&lt;br /&gt;====&lt;br /&gt;출처 http://www.lispworks.com/documentation/HyperSpec/Body/f_mapc_.htm&lt;br /&gt;이제 위에 &quot;mapcan&quot;을 쓰면 아래식으로 끝난다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(mapcan #&#39;nicknames people)&lt;br /&gt;&lt;/pre&gt;일전에 정의했던 all-nicknames는 바퀴를 재발명한 것이다. 하지만 그것만이 문제는 아니다.&lt;br /&gt;범용연산자로 할 수 있는 일이 특정 함수에 묻혀버린 것이다.&lt;br /&gt;여기서 &quot;mapcan&quot;은 이미 존재하는 녀석이다. 이걸 아는 사람들은 &quot;all-nicknames&quot;라는 함수를 보기 불편할 것이다.&lt;br /&gt;상향식 프로그래밍에 능숙하다는 것은 누락된 연산자가 아직 만들어지지 않았을 때 똑같이 불편함을 느끼는 것이다.&lt;br /&gt;당신은 &quot;당신이 원하는 것은 x다&quot;라고 말할 수 있어야 하고, 동시에 x가 무엇이어야 하는지 알 수 있어야 한다.&lt;br /&gt;&lt;br /&gt;리스프 프로그래밍은 필요로 하는 새로운 유틸리티를 분리하는 일도 포함된다.&lt;br /&gt;이 절의 목적은 이러한 유틸리티가 어떻게 생성되는지 보여주는 것이다.&lt;br /&gt;&lt;br /&gt;아래 코드를 보자. &#39;towns심볼은 근처에 있는 town들을 리스트로 가지고 있다. 그리고 가까운 것이 먼저나오는 순서로 정렬되어 있다.&lt;br /&gt;#&#39;bookshops 함수는 도시 안에 bookshop의 리스트를 리턴한다. 만약 우리는 서점이 있는 가장가까운 도시를 찾는다면 &lt;br /&gt;지은이는 이렇게 적을거라 한다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(let ((town (find-if #&#39;bookshops towns))) ;; bookshops 함수 한번&lt;br /&gt;  (values town (bookshops town)))  ;; bookshops 함수 두번&lt;br /&gt;&lt;/pre&gt;하지만 위 코드는 아름답지 않다. find-if가 #&#39;bookshops의 리턴값이 non-nil인 것을 찾는다. 이 리턴값에 따라 재.계.산. 된다.&lt;br /&gt;만약 #&#39;bookshops이 아주 비싼(시간이 걸리는) 호출이라면, 이 코드는 문제가 있다. 이런 불필요한 일을 없애기 위해 아래처럼 바꾸자.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(defun find-books (towns)&lt;br /&gt;  (if (null towns)&lt;br /&gt;      nil&lt;br /&gt;      (let ((shops (bookshops (car towns))))  ;; let으로 이제 bookshops는 한번만 실행된다.&lt;br /&gt;           (if shops  ;; 내용이 있는지 확인&lt;br /&gt;     (values (car towns) shops)  ;; 있으면 바로 리턴&lt;br /&gt;        (find-books (cdr towns))))))  ;; 없으면 리스트의 다음 타자로 재귀&lt;br /&gt;&lt;/pre&gt;이제는 필요 이상의 계산이 없이 원하는 것을 얻을 수 있다.&lt;br /&gt;&lt;br /&gt;그런데 이런종류의 검색을 종종 할 것같은 생각이 든다. (이럴때 유틸리티로 분리를 하는 것)&lt;br /&gt;여기서 우리가 원하는 건 find-if와 some을 이 합쳐진 것이다. 성공적인 요소와 테스트 함수에서 반환한 값을 리턴하는 녀석!&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(defun find2 (fn lst)&lt;br /&gt;  (if (null lst)&lt;br /&gt;      nil&lt;br /&gt;      (let ((val (funcall fn (car lst))))&lt;br /&gt;           (if val&lt;br /&gt;        (values (car lst) val)&lt;br /&gt;        (find2 fn (cdr lst))))))&lt;br /&gt;&lt;/pre&gt;잘보면 find-books와 find2는 아주 비슷하다.&lt;br /&gt;find2가 find-books의 골격이라고 보면 될 것 같다.&lt;br /&gt;이제 사용해보자.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(find2 #&#39;bookshops towns)&lt;br /&gt;&lt;/pre&gt;이것이 리습의 독특한 특징중 하나이다. 함수가 매개변수로 중요한 역할을 하는 것.&lt;br /&gt;이것이 왜 리습이 상향식 프로그래밍(bottom-up programming)에 잘 맞는지 말할 수 있는 이유 중 하나다.&lt;br /&gt;함수를 매개변수로 던져서 어떤 함수의 살을 붙일 수 있다면, 함수의 골격을 추상화 하는것이 쉬워진다.&lt;br /&gt;&lt;br /&gt;프로그래밍을 입문 할 때, 추상화를 하면 중복된 노력을할 필요가 없다고 한다.&lt;br /&gt;첫번째 레슨은 : Don&#39;t wire in behavior&lt;br /&gt;예를들어 하나 또는 두 개의 상수에 대해 동일한 작업을 수행하는 두 함수를 정의하는 대신 단일 함수를 정의하고 상수를 인수로 전달하라.&lt;br /&gt;&lt;br /&gt;lisp에서는 함수를 매개변수로 전달할 수 있기 때문에 아이디어를 더 잘 수행할 수 있다.&lt;br /&gt;앞서 보여준 두 예제 모두. 특정 기능을 위한 함수에서 좀 더 일반적인 함수로 변형되었다. (함수를 매개변수로 넘기는 방식을 이용하여)&lt;br /&gt;&lt;br /&gt;첫번째경우에는 미리 정의된 mapcan을 이용하였고, 두번째 경우에는 find2를 이용하였다. 둘다 원칙은 같다.&lt;br /&gt;&lt;br /&gt;&quot;범용 함수와, 구체적인 함수를 혼합하는 대신 범용함수를 정의하고 구체적인 것을 매개변수로 넣어라.&quot;&lt;br /&gt;&lt;br /&gt;이 내용을 신중하게 적용하면 원칙에 따라 훨씬 더 우아한 프로그램을 만들어낼 수 있다.&lt;br /&gt;이것이 상향식 디자인(bottom-up design)을 강요하는 유일한 이유는 아니지만, 주요한 이유중 하나이다.&lt;br /&gt;이 챕터에서 정의되는 32개의 유틸리티에서 18개는 함수형 매개변수를 받는다.</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/2319474238317730725/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-4-utility-functions.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/2319474238317730725'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/2319474238317730725'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-4-utility-functions.html' title='[on lisp] 4. Utility Functions 유틸리티 함수'/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-5239265247293269868</id><published>2019-01-03T14:46:00.002+09:00</published><updated>2019-01-03T14:46:39.107+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="lisp"/><title type='text'>[on lisp] 3.4 Interactive Programming </title><content type='html'>3.4 Interactive Programming &lt;br /&gt;&lt;br /&gt;함수형 방식은 단순히 이뻐보여서 제시하는 것이 아니라. 일을 더 쉽게 할 수 있도록 한다.&lt;br /&gt;리습의 동적 환경에서 함수형 프로그램은 비정상적인 속도로 작성되며 동시에 매우 신뢰할 수 있는 코드를 생산한다.&lt;br /&gt;&lt;br /&gt;리스프에서 디버그는 비교적 쉽다.&lt;br /&gt;오류의 원인을 추적하는 많은 정보를 런타임에서 이용할 수 있다.&lt;br /&gt;하지만 더 중요한 것은 테스트를 쉽게 할 수 있다는 것이다.&lt;br /&gt;컴파일 후 테스트를 하는 작업을 항상 같이 한번에 해야 할 필요가 없다.&lt;br /&gt;toplevel 루프에서 함수를 개별적으로 호출해서 테스트를 할 수 있다.&lt;br /&gt;&lt;br /&gt;Incremental testing은 리스프 스타일이 그것을 이용하기 위해 진화해왔기 때문에 아주 귀중하다.&lt;br /&gt;함수형 스타일로 짜여진 프로그램은 하나의 함수가 하나의 기능으로 이해될 수 있으며, &lt;br /&gt;읽는 사람의 관점에서 이것은 아주 큰 장점이다.&lt;br /&gt;&lt;br /&gt;하지만 함수형 스타일은 또한 incremental testing에 아주 잘 맞는다.&lt;br /&gt;(아까 위에서 설명했듯이) 함수형 스타일로 짜여진 프로그램은 한번에 한가지의 함수(기능)을 테스트할 수 있다.&lt;br /&gt;&lt;br /&gt;함수가 외부 상태를 조회하거나 수정하지 않으면, 버그는 즉시 나타난다.(바로 알 수 있다는 말)&lt;br /&gt;이런 기능은 오로지 리턴값으로만 바깥 세상에 영향을 미친다.&lt;br /&gt;그러므로 우리는 우리가 짠 코드를 더 믿을 수 있게 된다.&lt;br /&gt;&lt;br /&gt;순련된 리스프 프로그래머는 실제로 테스트하기 쉽게 프로그램을 설계한다.&lt;br /&gt;1. 그들은 몇가지 side-effect를 분리하려고 노력한다. 많은 부분을 순수 함수형 스타일로 작성할 수 있도록 한다.&lt;br /&gt;2. 만약 side-effect를 수행해야 하는 함수의 경우, 최소한 함수적 인터페이스(functional interfaces)로 제공한다.&lt;br /&gt;3. 각 기능에 잘 정의된 단일 목적을 제공한다.&lt;br /&gt;&lt;br /&gt;리스프에서는 테스트가 단일로 toplevel loop로 즉각 알 수 있기 때문에 피드백이 아주 빠르다.&lt;br /&gt;리스프에서 개발은 (다른 언어와 마찬가지로) 쓰기와 테스트의 순환이다.&lt;br /&gt;하지만 리스프는 그 주기가 아주 짧다. 하나의 함수 혹은 여러 함수들의 부분이라해도 그렇다.&lt;br /&gt;&lt;br /&gt;만약 해당 함수를 짜고 테스트를 돌려서, 에러가 나면 어디서 발생했는지 바로 안다. (마지막으로 쓴 곳)&lt;br /&gt;간단하게 들리겠지만, 이 원칙은 상향식 프로그래밍을 가능하게 하는 것이다.&lt;br /&gt;이것은 리습 프로그래머들이 기존 개발 방식에서 자유와 자신감을 준다. (오래된 계획 후 구현의 하향식 개발방식)&lt;br /&gt;&lt;br /&gt;1.1절에서 상향식 설계가 진화하는 과정이라 강조했다. 당신은 그 안에 프로그램을 짜면서 언어를 만들어내는 것이다. (쌓아 올라가는 것)&lt;br /&gt;이런 접근법은 당신이 낮은 수준의 코드를 신뢰하는 경우에만 작동할 수 있다. (아래부분이 믿을만해야 한다는 말)&lt;br /&gt;당신이 마주치는 모든 버그는 언어 자체가 아니라 당신의 어플리케이션에서 발생한 버그라고 가정할 수 있어야 한다.&lt;br /&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/5239265247293269868/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-34-interactive-programming.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/5239265247293269868'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/5239265247293269868'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-34-interactive-programming.html' title='[on lisp] 3.4 Interactive Programming '/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7179839488892896723.post-6265459682360473264</id><published>2019-01-03T11:57:00.002+09:00</published><updated>2019-01-03T11:57:34.717+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="lisp"/><title type='text'>[on lisp] 3.3 Functional Interfaces  </title><content type='html'>3.3 Functional Interfaces &lt;br /&gt;&lt;br /&gt;어떤 사이드이팩트는 다른 것들보다 나쁘다.&lt;br /&gt;예를들자. 이 함수는 nconc를 호출한다.&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(defun qualify (expr)&lt;br /&gt;  (nconc (copy-list expr) (list &#39;maybe)))&lt;br /&gt;&lt;/pre&gt;이것은 참조 투명성을 유지한다. 같은 인수를 넣으면 항상 같은 값을 반환할 것이다. (리스트를 수정하고 있다고는 하지만 새로 복사를 하기 때문에 상관없다.)&lt;br /&gt;그러므로 호출자의 관점에서는 이건 순수 함수형 코드일 것이다.&lt;br /&gt;우리는 이전에서 본 bad-reverse와 같다고 할 수 없다. (실제 매개변수를 변경하고 있는 녀석과는 다르다.)&lt;br /&gt;&lt;br /&gt;모든 사이드이팩트를 나쁘게 다루는 것 보다. 이런 경우들과는 구별이 되도록 해야겠다.&lt;br /&gt;비공식적으로, 아무도 소유하지 않은 것을 수정하는 것은 무해하다 말할 수 있다.&lt;br /&gt;예를 들어, 위에 nconc는 무해하다. 왜냐하면 매개변수로 받은 expr는 새롭게 만들어져서 더해졌기 때문이다.&lt;br /&gt;새롭게 만들어진 이 녀석은 아무도 소유할 수 없었다.&lt;br /&gt;&lt;br /&gt;일반적으로, 우리는 소유권에 대해 함수가 아닌, 함수의 호출에 대해 이야기 해야 한다.&lt;br /&gt;아래 코드에서 아무도 변수 x를 소유하지 않고 있다&lt;br /&gt;&lt;pre class=&#39;prettyprint&#39;&gt;(let ((x 0))&lt;br /&gt;  (defun total (y)&lt;br /&gt;    (incf x y)))&lt;br /&gt;&lt;/pre&gt;이 호출의 영향은 다음 호출에서 나타날 것이다.&lt;br /&gt;따라서 다음의 규칙을 따라야 한다: 주어진 호출은 고유하게 소유하는 것을 안전하게 수정할 수 있어야 한다. (나머지 내용은 그냥 넘어...)&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.whynam.com/feeds/6265459682360473264/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-33-functional-interfaces.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/6265459682360473264'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7179839488892896723/posts/default/6265459682360473264'/><link rel='alternate' type='text/html' href='http://www.whynam.com/2019/01/on-lisp-33-functional-interfaces.html' title='[on lisp] 3.3 Functional Interfaces  '/><author><name>남그롬</name><uri>http://www.blogger.com/profile/10868775178963275993</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry></feed>