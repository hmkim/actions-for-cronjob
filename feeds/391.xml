<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Park Ji Hong , ggikko on Medium]]></title>
        <description><![CDATA[Stories by Park Ji Hong , ggikko on Medium]]></description>
        <link>https://medium.com/@ggikko?source=rss-a9f7c0ecc750------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*XGuvFKcmJ4zFSzqMDAeJFg.jpeg</url>
            <title>Stories by Park Ji Hong , ggikko on Medium</title>
            <link>https://medium.com/@ggikko?source=rss-a9f7c0ecc750------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Tue, 14 May 2019 10:10:38 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@ggikko" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[제가 설명하는거보다 위키에 더 정확한 글이 있어서 링크로 답을 대신합니다..]]></title>
            <link>https://medium.com/@ggikko/%EC%A0%9C%EA%B0%80-%EC%84%A4%EB%AA%85%ED%95%98%EB%8A%94%EA%B1%B0%EB%B3%B4%EB%8B%A4-%EC%9C%84%ED%82%A4%EC%97%90-%EB%8D%94-%EC%A0%95%ED%99%95%ED%95%9C-%EA%B8%80%EC%9D%B4-%EC%9E%88%EC%96%B4%EC%84%9C-%EB%A7%81%ED%81%AC%EB%A1%9C-%EB%8B%B5%EC%9D%84-%EB%8C%80%EC%8B%A0%ED%95%A9%EB%8B%88%EB%8B%A4-af5ee58cc5d3?source=rss-a9f7c0ecc750------2</link>
            <guid isPermaLink="false">https://medium.com/p/af5ee58cc5d3</guid>
            <dc:creator><![CDATA[Park Ji Hong , ggikko]]></dc:creator>
            <pubDate>Wed, 30 Aug 2017 02:50:39 GMT</pubDate>
            <atom:updated>2017-08-30T02:50:39.148Z</atom:updated>
            <content:encoded><![CDATA[<p>제가 설명하는거보다 위키에 더 정확한 글이 있어서 링크로 답을 대신합니다..</p><p><a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure-(2.0)">https://github.com/ReactiveX/RxJava/wiki/Backpressure-(2.0)</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=af5ee58cc5d3" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[얼마나 올바르게 써야하는걸까]]></title>
            <link>https://medium.com/@ggikko/%EC%96%BC%EB%A7%88%EB%82%98-%EC%98%AC%EB%B0%94%EB%A5%B4%EA%B2%8C-%EC%8D%A8%EC%95%BC%ED%95%98%EB%8A%94%EA%B1%B8%EA%B9%8C-bfe6634c5582?source=rss-a9f7c0ecc750------2</link>
            <guid isPermaLink="false">https://medium.com/p/bfe6634c5582</guid>
            <dc:creator><![CDATA[Park Ji Hong , ggikko]]></dc:creator>
            <pubDate>Sat, 24 Jun 2017 14:38:11 GMT</pubDate>
            <atom:updated>2017-06-24T14:38:11.807Z</atom:updated>
            <content:encoded><![CDATA[<p>가끔 코드를 보다보면 recyclerView에서 onBindViewHolder에 setOnClickListener를 해주는 코드를 볼 수 있다. 개인적으로 이 코드는 잘못되었다고 생각이 든다.(불가피하게 적어야할 수 도 있겠지만,, 예시로 listener가 데이터에 따라 변경되야 하는 경우 등)</p><p>첫 번째로 가장 큰 이유는 말 그대로 onBindViewHolder() 메소드는 구체적인 아이템을 데이터에 따라 레이아웃에 반영하는 곳이다.</p><p>둘째로 고정된 layout listener 자체는 data에 따라 변하는 것이 아니기 때문에 ViewHolder에 있어야한다고 생각한다. (여기서 주의해야할 점은 getLayoutPosition과 getAdapterPosition를 정확히 숙지해야한다. 이유는 전자가 후자보다 13ms정도 늦게 반영되기 때문에 layoutPosition은 해당 레이아웃에서 정확한 position값을 받아낼 수 없다.)</p><p>반박하는 사람들은 물론 있을 수 있다. 예를들어,,</p><p>얼마나 차이있다고 그래? 그냥 해줘도 되잖아. 어짜피 똑같아. 오히려 바로 바로 할 수 있고 헷갈리지 않아서 좋다 등등.. 라고 반박할 수 있다.</p><p>실제로 setOnClickListener같은 메소드들은 너무 간단하게도 콜백 메소드를 등록하는 과정 밖에 없기 때문에 (등록하고 null체크해주고 call해주는 역할 밖에 없음) 따로 비용이 들지 않는다.</p><p>개인적으로 관심사, 해당 메소드가 바라보는 관점과 의미에 맡게 써야 협업 또는 개인이 추후에 수정할 때에도 실수하지 않고 고칠 수 있다.</p><p>이렇게 사소한 것들이 생각보다 많다.. 굳이 그렇게까지 해야되? 라고 말한다면 강요는 하지 않지만 권장은..! 회사 분 중에 자신이 꽉막힌 사람이니 그렇게 하라고 하시는 분이 있는데 멋진것이라고 생각한다.</p><p>그 이유는 이런 사소한 것이 당장 바로 앞은 별로 차이가 없겠지만.. 두달 세달 네달 지나고 나중에 돌이켜보면 하기를 잘했다 생각하는 경우가 거의 대부분이기 때문이다.</p><p>개발은 정답이 없다고 생각하지만 API를 구글이 만들었기 때문에 구글이 만든 API의 의미를 정확히 파악하고 충분히 이해하는 것이 전문가가 되는 길이라고 생각한다.</p><p>항상 1등과 2등이 차이가 많이 나는 것처럼 사소한 차이가 정말 중요해 져야한다. 그것이 시발점이 될 수 있기 때문이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bfe6634c5582" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[글 잘 읽었습니다!! 아래 글 보고 코멘트 남겨요.]]></title>
            <link>https://medium.com/@ggikko/%EA%B8%80-%EC%9E%98-%EC%9D%BD%EC%97%88%EC%8A%B5%EB%8B%88%EB%8B%A4-%EC%95%84%EB%9E%98-%EA%B8%80-%EB%B3%B4%EA%B3%A0-%EC%BD%94%EB%A9%98%ED%8A%B8-%EB%82%A8%EA%B2%A8%EC%9A%94-2d9a5f97a661?source=rss-a9f7c0ecc750------2</link>
            <guid isPermaLink="false">https://medium.com/p/2d9a5f97a661</guid>
            <dc:creator><![CDATA[Park Ji Hong , ggikko]]></dc:creator>
            <pubDate>Sun, 07 May 2017 09:17:30 GMT</pubDate>
            <atom:updated>2017-05-07T09:17:30.122Z</atom:updated>
            <content:encoded><![CDATA[<p>글 잘 읽었습니다!! 아래 글 보고 코멘트 남겨요.</p><p>하단에 Type 추론이 정상적으로 작동하지 않습니다. 라고 적힌 부분은 코드가 메서드로 다 박혀있던 타입이 iterator사용해서 내부적으로 for문을 돌도록 변경되어서 그런것 같아요. 코드를 보면..(하단에 첨부하였어요)</p><p>기존에는 method가 T1, T2, T3… 해당하는 메소드에 args가 타입별로 모두 메서드들이 있었는데 이제는 Iterator로 바뀌었어요. 동일한 레거시 메서드가 반복적으로 있는게 조금.. 그래서 바꾼 것 같아요 (물론 여러가지 이유가 있지만)</p><p>조금 다른 이야기지만 Observable, Flowable도 이러한 유사한 method이 있어요. (Reator는 varargs를 사용하고 있어요) 과거에는 Fun1, Fun2 등등이었지만 이제는 나름 java 8+ 에 친화적으로 BiFunction이 들어갔지만.. Func3, Func4… 는 뭔가 눈에 거슬리네요. 뭔가 안 이뻐서 제가 예전에 제안했었는데 거절당했네요. 이유는 여러가지가 있는데 jake랑 akanokd, 기타.. 친절하게 답해줬네요.</p><p><a href="https://github.com/ReactiveX/RxJava/issues/5239">https://github.com/ReactiveX/RxJava/issues/5239</a></p><p>1.x</p><pre>public static &lt;T1, T2, R&gt; Single&lt;R&gt; zip(<br>        Single&lt;? extends T1&gt; s1,<br>         Single&lt;? extends T2&gt; s2,<br>         final Func2&lt;? super T1, ? super T2, ? extends R&gt; zipFunction) {<br>    return SingleOperatorZip.zip(new Single[]{s1, s2}, new FuncN&lt;R&gt;() {<br>        @Override<br>        public R call(Object... args) {<br>            return zipFunction.call((T1) args[0], (T2) args[1]);<br>        }<br>    });<br>}</pre><p>2.x</p><pre>public static &lt;T, R&gt; Single&lt;R&gt; zip(<br>        final Iterable&lt;? extends SingleSource&lt;? extends T&gt;&gt; sources,<br>        Function&lt;? super Object[], ? extends R&gt; zipper) {<br>    ObjectHelper.requireNonNull(zipper, &quot;zipper is null&quot;);<br>    ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);<br>    return RxJavaPlugins.onAssembly(new SingleZipIterable&lt;T, R&gt;(sources, zipper));<br>}</pre><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2d9a5f97a661" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rxjava 2.x 에 대한 생각]]></title>
            <link>https://medium.com/@ggikko/rxjava-2-x-%EC%97%90-%EB%8C%80%ED%95%9C-%EC%83%9D%EA%B0%81-e11c7ca008d1?source=rss-a9f7c0ecc750------2</link>
            <guid isPermaLink="false">https://medium.com/p/e11c7ca008d1</guid>
            <dc:creator><![CDATA[Park Ji Hong , ggikko]]></dc:creator>
            <pubDate>Sun, 09 Apr 2017 12:21:32 GMT</pubDate>
            <atom:updated>2017-04-10T01:18:07.390Z</atom:updated>
            <content:encoded><![CDATA[<p>![alt tag] (<a href="https://d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-blue-left.png">https://d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-blue-left.png</a>)</p><p><strong>Rxjava 2.x에 대한 생각</strong></p><p>요즘 RxJava 코드를 보면서 조금씩 커밋해보고있다. ReactiveX에 대해서 우선 느낀점으로는 하나의 패러다임임과 동시에 모든 언어가 비슷한 스펙으로 유사한 구현방식을 따라가고 있다고 느낀다.(물론 구현방식은 조금씩 다르겠지만..) 이것만으로도 큰 장점을 갖는다고 생각하는 부분은 Java 개발자가 굳이 Swift를 알지 못하더라도 RxSwift 코드를 보고 이해할 수 있고 반대로 Swift 개발자들은 Java를 알지 못해도 Rxjava코드를 보고 흐름을 파악할 수 있다. 로직을 모두가 볼 수 있게 통합하는 느낌이 든다..</p><p>그렇다면,, RxJava 1.x는 왜 deprecated되고 RxJava 2.x를 만들고 있는가. 물론 RxJava 1.x는 UI이벤트와 같은 hot source들에 대한 backpressure가 잘되지 않아서 이기도 하지만 RxJava 2.x는 [reactive-streams](<a href="http://www.reactive-streams.org/">http://www.reactive-streams.org/</a>)와 유사하게 구현하고 있다는 것에 큰 의미가 있다고 생각한다. 그 이유는 reactive-streams가 java 8 + 에 친화적이고 java 9의 flow를 지원하기 위함이다. 안드로이드에서는 java 버전이 낮기 때문에 여러가지 제약사항이 있는데 이렇게 모든 것에 호환시키려다보니 조금의 미래를 바라보지 못한 것 같다. 변경된 점으로는 기존에 Rxjava 1.x function들도 Java 8+에 친화적으로 변경되었다. Action1, Action2… 그리고 Func0, Func1… 이런 메소드들이 Consumer, Function, Predicate java 8+ 메소드 명으로 변경되었다. 즉 안드로이드가 java 8 + 를 지원해도 문제 없이 포팅되도록 유도하려는 의도인 것 같다.</p><p>- 1.x에서 backpressure에 왜 실패한걸까(추측..)</p><p>이 외에도 다양한 이유가 있는데 의존성이 적다,가볍다 등등 다양한 이유로 reactive-streams를 따라가고 있다. (아래 링크 참조)</p><p>여기서 이해가 안될 수 있다. 아니 왜 굳이 라이브러리를 둘로 나누어서 서로 시간낭비하고 있는걸까 하나만들면 더 좋은 라이브러리가 되지 않겠어? 라고 생각할 수 있지만 reactive streams는 java 8+에 친화적이다. 즉 android developer에게는 러닝커브가 존재하고 아직 안드로이드는 1.6(물론 이제 1.7 본격지원한다하지만..)을 기본으로 지원하고 있기 때문에 그러하다.(이미 라이브러리 개발자들도 알고 있음)</p><p>[RxJava wiki](<br><a href="https://github.com/ReactiveX/RxJava/wiki/Reactive-Streams">https://github.com/ReactiveX/RxJava/wiki/Reactive-Streams</a>)</p><p>reactive streams 알아보면 일관성을 갖기 위해 manifesto도 존재한다 어떤 방식으로 구현해나가자 라는 방법론도 있고 매력있다.</p><p>1. Responsive<br>2. Resilient<br>3. Elastic<br>4. Message Driven</p><p>이렇게 4가지의 기준이 있다.</p><p>궁금해하실 분도 있을 것 같아 1.x가 왜 backpressure에 실패했는지 간략히 적으면 구현하면서 뒤늦게 backpressure을 도입하고 operator들도 급하게 만들어지다보니 어떤 거는 도입되고 어떤거는 도입하지 못하는 구조가 되어버렸다. 즉 크게 아키텍처를 설계하고 작업한게 아니라 하나씩 추가되다보니 돌이킬 수 없어 아에 전체 구조를 변경하고 2.x로 간 것 같다.</p><p>## RxJava 2.x는..?<br>RxJava2를 보면 Observable, Flowable을 나누어 놓았다. 위에서 잠깐 언급했다시피 hot source들에 대한 backpressure가 잘되지 않아서이다. 그래서 공식적으로는 `io.reactivex.Observable`은 non-backpressured 이고 `io.reactivex.Flowable`은 backpressure base다. Observable은 계속해서 새롭게 새롭게 짜여지고있다. 여러가지 커스텀 타입을 쓰다보니 backPressure(이는 매우 중요하다. 위에 reactive Streams manifesto의 4번째의 주된 이유이기도 하다)도 구현이 안되있고, 이를 구현하는것이 현재로서 구조를 많이 변경해야 하기 때문이다.</p><p>3.x가 나오지 않을까 생각해본다.</p><p>이미 Rxjava issue thread에서는 3.x에 대한 언급이 나오고 있다.<br>JakeWharton이 다음과 같은 차트[(Jakewharton’s naming chart)](<a href="https://github.com/ReactiveX/RxJava/issues/4044#issuecomment-238066355">https://github.com/ReactiveX/RxJava/issues/4044#issuecomment-238066355</a>)를 작성하였는데 이 또한 불분명하고 타입을 막 만들고 쓰다보니 backpressure를 적용하기에 모호하다는 것..</p><p>아직 모든 소스를 보지 못했지만 조금씩 조금씩.. 보려한다 시간날때마다 :) RxJava의 내부 소스를 보면 Reactive streams 기반으로 모두 Observable, Disposable을 상속받아서 돌려돌려 쓰기 하고 있다. 음.. 구현방법이나 앞으로 나아가는 방향, 어떻게 써야할지 등에 다음 글을 적을까한다. 시간나면..ㅠ</p><p>p.s. 이 글은 기록용입니다. 개인적으로 쓴 글이기에 잘못된 정보가 있을 수 잇습니다. 있으면 바로 코멘트 주시면 수정하겠습니다. :)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e11c7ca008d1" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[CustomView 에 대한 생각]]></title>
            <link>https://medium.com/@ggikko/customview-%EC%97%90-%EB%8C%80%ED%95%9C-%EC%83%9D%EA%B0%81-200dde5ab2ad?source=rss-a9f7c0ecc750------2</link>
            <guid isPermaLink="false">https://medium.com/p/200dde5ab2ad</guid>
            <dc:creator><![CDATA[Park Ji Hong , ggikko]]></dc:creator>
            <pubDate>Sun, 18 Dec 2016 06:42:53 GMT</pubDate>
            <atom:updated>2016-12-18T06:45:10.320Z</atom:updated>
            <content:encoded><![CDATA[<p>CustomLayout, CustomView, CustomWidget 모두 다르지만 일반적으로 View를 고려해서 작성,, 요약</p><p>일단 순서가 매우 중요함, 이를 이용해서 뷰를 재활용할 수도 있고 뷰가다시 그려지는 것을 막을 수도 있고 이상한 행동을 할 수 있음</p><p>불리는 순서대로 생각을 정리하겠습니다..</p><p>CustomView는 다양하게 장난칠 수 있다. Attribute, touch, size, style, draw 등등..</p><ol><li><strong>Constructor(init)</strong></li></ol><p>(파라미터를 넘긴다.) 말그대로 생성자이다. Context는 필수 arg입니다. 물론 ContextWrapper를 이용하여 style도 넘길 수 있고 Context안에 담아서 넘긴다음 이를 이용할 수 있습니다. 그러므로 중요한 부분입니다(사실 안중요한 부분이 없음). attribute, defstyle 등등 말 그대로 기존에 적용되어있는 것을 새로 쓸 수 있음</p><p><strong>2. onMeasure(dimension)</strong></p><p>뷰와 컨텐츠를 측정함 가로 세로 결정해야하기 때문입니다. 여기서도 숫자로 장난을 칠 수 있겠지요</p><p><a href="https://developer.android.com/reference/android/view/View.html#onMeasure(int,">https://developer.android.com/reference/android/view/View.html#onMeasure(int,</a> int)</p><p><strong>3. onSizeChanged(size Changed)</strong></p><p>onMeasure가 불림. 뷰의 Size가 변경될때 불리게된다. 쉽게 설명해서 예를 onMeasure안에서 호출하면 계속 뺑글뺑글 도는거</p><p><a href="https://developer.android.com/reference/android/view/View.html#onSizeChanged(int,">https://developer.android.com/reference/android/view/View.html#onSizeChanged(int,</a> int, int, int)</p><p><strong>4. onLayout</strong></p><p>child View Layout을 결정할 때 쓰임</p><p>첫번째 boolean은 사이즈가 변경됬어? 아니면 옮겨졌어? 에 따라 이 값이 옴</p><p>나머지 int 4개는 부모의 상대적인 포지션임</p><p><a href="https://developer.android.com/reference/android/view/View.html#onLayout(boolean,">https://developer.android.com/reference/android/view/View.html#onLayout(boolean,</a> int, int, int, int)</p><p><strong>5. onDraw(View render)</strong></p><p>가장 많이 쓰는 듯. 왜냐면 invalidate() 또는 사용자의 interaction에 따라서 상태 변화에 따라 이 메서드가 불리기 때문에</p><p><a href="https://developer.android.com/reference/android/view/View.html#onDraw(android.graphics.Canvas)">View | Android Developers</a></p><p>정리하면</p><ol><li>생성자</li><li>onMeasure</li><li>onSizeChanged</li><li>onLayout</li><li>onDraw</li></ol><p>생각 :</p><p>여러 상황이 있겠지만 CustomView는 코드를 깔끔하게 만드는가? 반복적인 뷰, 복잡한 xml코드들을 줄일 수 있나? 어느정도가 적당한 선인가.. 커버할 수 있는 범위는? 유지보수 쉽다? 재활용성은? 이미 정해진 레이아웃을 Style로(ContextWrapper에 담아서) 일괄적으로 뷰를 변경할 수 있지 않을까(큰 변화 없고 dimen, color, line 등)? Component 단위로 묶어서 작동시킬 수 있나? 고민이 된다. addView, Cache, 어느정도가 답일까. 많은 사람들이 CustomView로 생성되서 addView하고 RecyclerView의 하나의 Row 또는 각 뷰의 일부로 많이 사용하지만.. 뭔가 더 좋은 방법이 있을 것 같은데.. 음….</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=200dde5ab2ad" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Optimize view hierarchy]]></title>
            <link>https://medium.com/@ggikko/optimize-view-hierarchy-ab3054d8fbe6?source=rss-a9f7c0ecc750------2</link>
            <guid isPermaLink="false">https://medium.com/p/ab3054d8fbe6</guid>
            <dc:creator><![CDATA[Park Ji Hong , ggikko]]></dc:creator>
            <pubDate>Sun, 23 Oct 2016 04:43:05 GMT</pubDate>
            <atom:updated>2016-10-24T02:46:19.887Z</atom:updated>
            <content:encoded><![CDATA[<p>View를 최적화 해보자.</p><p>내가 알고 있는 말들..</p><ol><li>hierarchy viewer 를 사용하라.</li><li>merge를 사용하라. 이는 view hierarchy 를 단조롭게 할 수 있다.</li><li>될 수 있으면 relative layout을 사용하라. (= view 구조를 단조롭게 가져가라)</li></ol><h3><strong>+ hierarchy viewer 를 사용하라.</strong></h3><p>참고로 hierarchy viewer은 매우 불편하다.</p><p>이유는 instant run을 못 사용하기 때문.. hierarchy viewer는 전체 decorview부터 차근차근 모두 보여준다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*3zP-IvZcbvxXIGEwiaTG8g.png" /><figcaption>Android Device Monitor</figcaption></figure><p>프로젝트의 뷰 레벨을 파악하고 수정하면서 어디가 복잡도가 높고 많은 비용을 먹고 있는지 판단할 수 있다. (솔직히 너무 복잡함)</p><h3>+ merge를 사용하라.</h3><p>merge는 view tree의 레이아웃 레벨을 낮출 수 있다. 왜냐하면</p><p>&lt;merge&gt;자체가 말 그대로 같은 레벨의 layout에 붙이는 거기 때문에..</p><p>include는 ++ 하는 것이기에 흔히들 merge는 하나의 view를 더하거나 layout을 쪼개서 붙여야할 때 쓰이고</p><p>include는 layout 단위로 반복되는 작업을 덧붙일때 쓰인다.</p><p>무식하게 예제를 만들어보았습니다.</p><p>merge안하고 레이아웃을 잡으면</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*1Xrzcnf_-UzTQ9yotQqoUA.png" /></figure><p>이런식..</p><p>merge 하면 그냥 바로 customLinear에 붙는</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/516/1*lZC0pHvMYPq2DVjlUTPzQA.png" /></figure><p>이런 그림이 된다.</p><h3>+ 될 수 있으면 relative layout을 사용하라. (= view 구조를 단조롭게 가져가라)</h3><p>일반적인 사람들의 오해 : relative layout이 가벼워서 우선 시 써야해(?)</p><p>테스트 한것 부터</p><p>LinearLayout (Button, TextView)</p><p>2번씩 불린다..? linear -&gt; button -&gt; text -&gt; linear -&gt; button -&gt; text</p><p>RelativeLayout (Button, TextView)</p><p>4번씩 불린다. relative -&gt; button -&gt; text -&gt; relative -&gt; button -&gt; text -&gt; relative -&gt; button -&gt; text -&gt; relative -&gt; button -&gt; text</p><p>FrameLayout (Button, TextView)</p><p>2번씩 불린다. frame -&gt; button -&gt; text -&gt; frame -&gt; button -&gt; text</p><p>음..? 내가 알기로는 Linear는 1번씩 불려야 정상 아닌가? 왜 2번씩 불러지지</p><p>어디선가 자식의 뷰를 측정하는데 2번 사용하는 것 같다.(정확한 이유를 모르겠음) Appcompat 문제는 아닌거같다</p><p>Appcompat을 사용하면 contentframelayout이 껴들기는 하는데</p><p><a href="https://android.googlesource.com/platform/frameworks/support/+/refs/heads/master/v7/appcompat/src/android/support/v7/widget/ContentFrameLayout.java">https://android.googlesource.com/platform/frameworks/support/+/refs/heads/master/v7/appcompat/src/android/support/v7/widget/ContentFrameLayout.java</a></p><p>코드를 보면 그런 코드가 없다. 실제로 Appcompat을 빼더라도 2번 불린다. 음.. 나중에 해결하기로</p><p>일단 정리하자면</p><p>View level을 낮추는게 엄청난 성능 효과를 가져온다는 이유는 이렇게 비용이 곱하기가 되기 때문이다. 예시를 하나 보여주겠다.</p><p>예를 들어보면</p><p>구조가</p><p>frame ( linear (button, text) ) 이렇게 뷰를 그릴 때는</p><p>frame -&gt; linear -&gt; button -&gt; text -&gt; frame -&gt; linear -&gt; button -&gt; text 이고,</p><p>반면에</p><p>frame ( linear (button, relative (text) ) 이렇게 뷰를 그리면</p><p>frame -&gt; linear -&gt; button -&gt; relative -&gt; text -&gt; text -&gt; frame -&gt; linear -&gt; button -&gt; relative -&gt; text -&gt; text</p><p>만약에 relative를 4개를 쓰고 거기에 textview를 그릴 경우 2⁴ 만큼 불리게 된다. (비용이 커짐)</p><p>그래서 일반적으로 잘못된 생각을 가지고 있는 것은 RelativeLayout을 자주 쓰면 좋다! 라고 말하는데 그게 아니라..</p><p>RelativeLayout을 적절하게 잘써서 View tree를 간편하게 만드는게 중요한 거다.</p><p>만약 linear ( text, text ) vs relative (text , text) 라면</p><p>linear (text, text) 가 퍼포먼스 측면에서 승이다. (물론 코드 가독성이나 기타 등등 에서는 또 다르게 고려해봐야함. (for performance vs for maintenance)</p><p>하지만 여기서 예외가 있다.</p><p>LinearLayout에서는 이런 코드들이 있다.</p><p>float childExtra = lp.weight;</p><p>if(childExtras &gt; 0) { // 자식들 measure Spec 구하기 }</p><p>즉 weight설정이 default가 0인데 default가 아니면 자식의 크기를 한번 더 구하게 된다.</p><p>weight을 사용하게되면 relativeLayout처럼 2번 구한다는 것</p><p>정리하자면..</p><p>상황에 따라 맞게 써야하는데 view tree는 가장 낮게 하는게 퍼포먼스 측면에서 제일 좋고 Linear와 Relative는 상황에 따라 적절하게 쓰면 된다. merge, include도 마찬가지.</p><p>코드분석 : onMeasure에서 child의 spec을 계산하는데 비용이 많이 듬.</p><p>onMeasure 안에 child의 spec을 요구하는 코드가 있음.</p><p>일반적으로 onMeasure의 패턴은 비슷함.</p><ol><li>부모 아이들 리스트(뷰가 담겨있는 ArrayList)를 clear</li><li>자식이 있는지 for문으로 돌림.</li><li>max width, height계산함.</li><li>drawable, padding, 기타 등등을 함</li><li>그 다음 자식 뷰들의 measure를 요구함</li></ol><p>각 Layout마다 차이가 조금 씩 있음.</p><p>아래의 글을 참조하면 더 효율적으로 그릴 수 있다.</p><p><a href="https://sriramramani.wordpress.com/2015/05/06/custom-viewgroups/">Custom ViewGroups</a></p><p>그 외에..</p><p><a href="https://developer.android.com/training/custom-views/optimizing-view.html">https://developer.android.com/training/custom-views/optimizing-view.html</a></p><p>onDraw 를 최대한 적게.. payback이 큼(비용이 많이 듬)</p><p>onDraw 하면 invalidate가 불리기 때문에 invalidate()도 적게 사용하라</p><p>requestLayout() 도 적게..</p><p>참조</p><p>[android blogspot]</p><p><a href="http://android-developers.blogspot.kr/2009/03/android-layout-tricks-3-optimize-by.html">Android Layout Tricks #3: Optimize by merging</a></p><p>[optimizing layout google developer]</p><p><a href="https://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect">Optimizing Layout Hierarchies | Android Developers</a></p><p>[layout efficient]</p><p><a href="http://stackoverflow.com/questions/4069037/android-is-a-relativelayout-more-expensive-than-a-linearlayout">Android: Is a RelativeLayout more expensive than a LinearLayout?</a></p><p>[Google I/O 2013 Custom Views for Android]</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FNYtB6mlu7vA%3Ffeature%3Doembed&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DNYtB6mlu7vA&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FNYtB6mlu7vA%2Fhqdefault.jpg&amp;key=d04bfffea46d4aeda930ec88cc64b87c&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/bb6539c1c0239f2168f8d0ebf61f76c8/href">https://medium.com/media/bb6539c1c0239f2168f8d0ebf61f76c8/href</a></iframe><p>[뷰는 어떻게 그려지는 걸까?]</p><p><a href="https://developer.android.com/guide/topics/ui/how-android-draws.html?hl=zh-tw">How Android Draws Views | Android Developers</a></p><p>[Android 최적화 팁 40가지]</p><p><a href="https://opensignal.com/blog/2013/07/30/40-developer-tips-for-android-optimization/">https://opensignal.com/blog/2013/07/30/40-developer-tips-for-android-optimization/</a></p><p>[Custom View]</p><p><a href="https://sriramramani.wordpress.com/2015/05/06/custom-viewgroups/">Custom ViewGroups</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ab3054d8fbe6" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GA, Mixpanel, ELK 비교]]></title>
            <link>https://medium.com/@ggikko/ga-mixpanel-elk-%EB%B9%84%EA%B5%90%ED%95%B4%EB%B3%B4%EC%9E%90-5a27aad7b548?source=rss-a9f7c0ecc750------2</link>
            <guid isPermaLink="false">https://medium.com/p/5a27aad7b548</guid>
            <dc:creator><![CDATA[Park Ji Hong , ggikko]]></dc:creator>
            <pubDate>Sat, 27 Aug 2016 14:44:51 GMT</pubDate>
            <atom:updated>2016-08-28T04:43:36.262Z</atom:updated>
            <content:encoded><![CDATA[<p>재미로 해보는 비교, 제 개인적인 견해가 많이들어가 부정확한 정보가 많다는 점을 인지해 주시기 바랍니다.(mixpanel 위주로)</p><p>공식 홈페이지에 따르면,,</p><p>사람들이 모바일이나 웹 애플리케이션 취하는 행동을 트래킹합니다.</p><p>실시간 데이터 분석이 가능합니다(GA는 lagging이 발생하는 경우가 종종 있음)</p><p>Retroactive funnel analysis(<a href="https://mixpanel.com/funnels/)">https://mixpanel.com/funnels/)</a> <br>funnel analysis란 무엇일까요? 몰라서 검색해보니 말그대로 깔때기 분석입니다. 서비스 안에서 겪게 되는 단계별로 문제점을 파악하고 이를 개선하기 위해 사용하는 분석이라 할 수 있는데.. 짧게 요약하면 단계별 구분하고, 유저가 어떤 행동을 하면서 유출을 했는지 등을 파악하고 트래킹하여 원인을 파악하고 개선시키는 방법이라고 생각이 듭니다.(정확하지 않음 — 부분만 보고 생각해본..)<br>이 부분을 실제로 해보니 정말 편한 것 같습니다. 단계별로 유입, 유출 숫자와 퍼센트를 얻을 수 있습니다. 원하는 스텝별로 여러가지 경우의 수를 만들 수 있고 이를 기반으로 홈페이지나 앱의 개선 여지점을 찾을 수 있을 것이라 생각합니다.</p><p>Comprehensive cohort or retention analysis — 새로온 유저나, 자주 사용하는 유저를 체킹하거나, 앱을 사용하는 유저의 빈번함 등 행동패턴을 분석할 수 있습니다. (GA는 안된다고 나와있습니다)</p><p>mixpanel에서 서포트 해준다고..</p><p>GA는 cookie에 값을 넣어 트래킹함 따라서 쿠키의 평균 만료시간은 30일입니다. 하지만 믹스패널은 user_id를 가지고 트래킹하기때문에 쿠키보다 더 오래 트래킹이 가능합니다</p><p>비개발자에게도 A/B 테스팅이 쉽도록 지원해줍니다.</p><p>GA와 달리 절대 광고 목적으로 데이터를 사용하지 않음. Mixpanel의 목적은 당신의 비지니스를 돕는게 목적입니다.</p><p>GA : Page를 트래킹합니다.</p><p>ELK<br>Elastic search — 실시간 분석 <br>Logstash — 각종 로그 json형태로 elastic search에 전송<br>Kibana — elastic search에 저장된 데이터를 사용자에게 Dash board 형태로 제공합니다.</p><p>GA는 커스텀이 힘듬.<br>로그로 받기 때문에 신뢰도 높음<br>커스텀을 마음대로 할 수 있음.<br>오픈소스이다.<br>믹스 패널은 돈을 내야함(유료 — 정책에 따라) 구체적으로 어느정도 해야 어느정도 가격이 나오는지 계산해보고 싶지만.. 음</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*3q8K7_vCyigHtSVc4-2_0A.png" /><figcaption>공식홈페이지 가격표</figcaption></figure><p>여기서 Data point란, 모든 이벤트 트래킹을 말합니다.</p><p>사용하는데까지 1분이면 충분, 기본적인거 학습은 10분정도 소요된다고 생각합니다. GA써보신분이라면 더 쉽게.</p><p>우선 mixpanel 의존성 추가해주고, gcm이나 fcm추가 internet, networkcheck, bluetooth(이거 왜 추가해야하는지 모르겠음 내부적으로 사용하나봄) manifest에 퍼미션 준다.</p><p>(코드 조금 보고 판단하는거니 정확하지 않습니다..)개인적인 생각입니다만..<br>믹스패널 라이브러리 내부 코드를 조금 보자면,, java websocket있고, handshake 클래스 있고 memory cache하는 코드 있는거보니 그냥 네트워크 체킹하고 소켓 프로그래밍하여 로깅 찍는 느낌이 강함. 개인적인 생각으로는 ELK랑 비슷한 로직일듯.. 그냥 access하는 로깅은 다 찍어서 분석하는 듯함. 물론 로직을 태우는 면에서는 조금씩 커스텀하고 dash board를 커스텀하는게 힘든거겟지만..</p><ul><li>Initializing the library</li></ul><pre>MixpanelAPI mixpanel = MixpanelAPI.<em>getInstance</em>(context, MIXPANEL_TOKEN);</pre><p>Dagger를 쓰고 있기 때문에 앱 모듈에서 인스턴스 하나 생성해서 필요한 부분만 inject사용하면 편합니다.</p><ul><li>Flushing events</li></ul><pre>flushing event - mixpanel.flush();</pre><ul><li>Sending events</li></ul><pre>JSONObject props = new JSONObject();<br>props.put(&quot;Gender&quot;, &quot;Female&quot;);<br>    props.put(&quot;Plan&quot;, &quot;Premium&quot;);<br><br>    mixpanel.track(&quot;Plan Selected&quot;, props);</pre><ul><li>Event timing</li></ul><pre>// start the timer for the event &quot;Image Upload&quot;<br>mixpanel.timeEvent(&quot;Image Upload&quot;);<br><br>// stop the timer if the imageUpload() method returns true<br>    if(imageUpload()){<br>    mixpanel.track(&quot;Image Upload&quot;);<br>    }</pre><ul><li>Super properties</li></ul><p>말 그대로 super.. 중요한 정보 이 사람에 대해 꼭 알고 싶은 정보를 superProperty로 등록해주면 모든 이벤트에 걸리게 된다. 말그대로 부모에다가 달아 놓는것</p><pre>// Send a &quot;User Type: Paid&quot; property will be sent<br>// with all future track calls.<br>    JSONObject props = new JSONObject();<br>props.put(&quot;User Type&quot;, &quot;Paid&quot;);<br>    mixpanel.registerSuperProperties(props);</pre><p>참고로 Mixpanel은 default로 super properties를 갖고 있음. 이는 다음과 같다. <br>City, Region, Country, Timezone, Android App Version, Android App Version Code, Android Lib Version, Android Operating System, Android Os Version, Android Brand, Android Model, Android Manufacturer, Last Seen.</p><ul><li>Managing user identity</li></ul><p>distinct_id를 지속적으로 디바이스에 저장된다.</p><pre>// Associate all future events sent from<br>// the library with the distinct_id 13793<br>mixpanel.identify(&quot;13793&quot;);</pre><ul><li>Storing user profiles</li></ul><p>Mixpanel’s People Analytics product 에서 저장할 수 있다.</p><pre>// identify must be called before<br>// people properties can be set<br>mixpanel.getPeople().identify(&quot;13793&quot;);<br><br>// Sets user 13793&#39;s &quot;Plan&quot; attribute to &quot;Premium&quot;<br>    mixpanel.getPeople().set(&quot;Plan&quot;, &quot;Premium&quot;);</pre><p>13793가 없으면 생성됨.</p><p>이외에도 기타 등등이 있으나.. 여기까지만 해보려합니다. 추가적으로 더 해보고 싶으면 다음 포스팅에 적겠습니다.</p><p>두서없이.. Mixpanel 코드를 조금 더 봐야겠습니다.(그냥 궁금해서)<br>모든 코드가 null check로 방어코드가 되어있고, SharedPreferences에 token을 넣어서 사용하는군요. 맵을 사용하고 이벤트들 사이에는 동기화를 걸어놨습니다. Sqlite를 이용하여 event property를 add하고, 지우고 등등 관리합니다. GCM도 등록하는군요. 결국은 로그를 앱 내부적으로 관리도 하고 푸쉬도하고 마지막에는 SSLSocketFactory를 이용하여 소켓통신을 하고 있습니다. event endpoint는 MPConfig 클래스안에서 관리하고 있습니다.</p><p>요약하면,, Sqlite, shared preference를 이용하여 token 및 property를 관리하고 이를 통해 socket통신으로 서버에 쏴서 서버에 로그를 남기고 이를 관리하는 것 같습니다. 서버쪽은 ELK랑 비슷하게 관리되고 있겠죠..?(어디까지나 추측입니다.)</p><p>Data point 계산해보기</p><p>1회(로그인 하는 과정 포함)<br>5분에 20회, 15 ~ 20분 가정하면 60 ~ 80회 1인</p><p>2회(로그인 중)<br>신규 채권 5개라고 가정해보고 <br>5분 22회, 15 ~ 20분 가정하면 66회 ~ 88회 1인</p><p>하루에 평균 얼마나 이용할까?</p><p>유저수가 500명일경우 <br>3000 ~ 4000 data point 하루. -&gt; 90000 ~ 120000 한달은</p><p>+ 유저수 + 이벤트 -&gt; 곱하기 하는 등..</p><p>ref :<br><a href="http://thinktank13.tistory.com/13">http://thinktank13.tistory.com/13</a> <br><a href="https://mixpanel.com/help/reference/android">https://mixpanel.com/help/reference/android</a> <br><a href="https://www.digitalocean.com/community/tutorials/how-to-install-elasticsearch-logstash-and-kibana-elk-stack-on-ubuntu-14-04">https://www.digitalocean.com/community/tutorials/how-to-install-elasticsearch-logstash-and-kibana-elk-stack-on-ubuntu-14-04</a> <br><a href="http://blog.embian.com/18">http://blog.embian.com/18</a> <br><a href="https://www.google.com/analytics/">https://www.google.com/analytics/</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5a27aad7b548" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code Conventions for the Java Programming Language]]></title>
            <link>https://medium.com/@ggikko/code-conventions-for-the-java-programming-language-3ccafe6663ce?source=rss-a9f7c0ecc750------2</link>
            <guid isPermaLink="false">https://medium.com/p/3ccafe6663ce</guid>
            <category><![CDATA[programming]]></category>
            <category><![CDATA[java]]></category>
            <dc:creator><![CDATA[Park Ji Hong , ggikko]]></dc:creator>
            <pubDate>Sat, 20 Aug 2016 17:16:29 GMT</pubDate>
            <atom:updated>2016-08-22T02:53:54.920Z</atom:updated>
            <content:encoded><![CDATA[<p>Oracle 공식 홈페이지 자바 document</p><ul><li>80% of the lifetime cost of a piece of software goes to maintenance.</li><li>Hardly any software is maintained for its whole life by the original author.</li><li>Code conventions improve the readability of the software, allowing engineers to understand new code more quickly and thoroughly.</li><li>If you ship your source code as a product, you need to make sure it is as well packaged and clean as any other product you create.</li></ul><p>이 4가지의 공통점은 틀린 말이 하나 없다..?</p><p>하지만 꾸준히 업데이트 되고 있는 google guide 기준으로..(sun과 google guide는 조금씩 다르지만 유사한 점이 많은것 같습니다.)</p><p>필요성을 느낍니다. 현재 진행하고 있는 프로젝트에서 은행에서 바로 내려줘서 그런지.. json key값이 cz18210**** 이런 식으로 데이터가 내려오고 있는데,, 이런 필드들이 다수이기 때문에 코드 이름짓기가 너무 힘듭니다. 그래서 조금 더 공부해보고 적용하려합니다. 나의 코드를 일관성있게 만들기 위해.</p><p>— — — — — — — — — — — — — — 꾸준히 업데이트 할 부분</p><p>5. Naming</p><p>5.2.1 Package names<br>all lowercase, with consecutive words simply concatenated together (no underscores)<br>ex) com.example.deepspace</p><p>5.2.2 Class names<br>Class names are written in UpperCamelCase.<br>명사 or 명사구. <br>인터페이스 이름은 명사 또는 명사구지만 때때로 형용사나 형용사 구.<br>어노테이션 타입을 위한 구체적인 룰은 없음.<br>테스트 케이스는 Test로 끝나야함. <br>ex) HashTest or HashIntegrationTest.</p><p>5.2.3 Method names<br>lowerCamelCase.<br>메서드 이름은 일반적으로 동사나 동사구이다. 예를들어, sendMessage or stop.<br>밑줄은 Junit test에서 논리적인 컴포넌트들의 이름을 분리하기 위해 사용할 수 있다. <br>하나의 패턴은 test&lt;MethodUnderTest&gt;_&lt;state&gt; 이고, <br>예시로는 testPop_emptyStack 가 있다.<br>테스트 메서드 네이밍은 정답은 없다.</p><p>5.2.4 Constant names<br>all uppercase letters, with words separated by underscores<br>Constant는 static final 필드 지만 모든 static final 필드들이 constant한건 아니다. constant case를 선택하기 전에 정말 constant인지 고려해야한다. 예를들어 만약 인스턴스의 옵저버블 상태가 변화가 있다면 그건 확실히 constant가 아니다. <br>다음은 예시이다.</p><pre>// Constants<br>static final int NUMBER = 5;<br>static final ImmutableList&lt;String&gt; NAMES = ImmutableList.of(&quot;Ed&quot;, &quot;Ann&quot;);<br>static final Joiner COMMA_JOINER = Joiner.on(&#39;,&#39;); // because Joiner is immutable<br>static final SomeMutableType[] EMPTY_ARRAY = {};<br>enum SomeEnum { ENUM_CONSTANT }<br><br>// Not constants<br>static String nonFinal = &quot;non-final&quot;;<br>final String nonStatic = &quot;non-static&quot;;<br>static final Set&lt;String&gt; mutableCollection = new HashSet&lt;String&gt;();<br>static final ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);<br>static final Logger logger = Logger.getLogger(MyClass.getName());<br>static final String[] nonEmptyArray = {&quot;these&quot;, &quot;can&quot;, &quot;change&quot;};</pre><p>5.2.5 Non-constant field names<br>lowerCamelCase이고 일반적으로 명사나 명사구<br>ex) computedValue or index</p><p>5.2.6 Parameter names<br>lowerCamelCase이고 a,b같이 one-character parameter는 피해야한다.</p><p>5.2.7 Local variable names<br>지역변수는 lowerCamelCase이고 final 또는 immutable일 때 조차 로컬변수는 constant로 고려되지 않는다.<br>따라서 constant 스타일을 따르지 않는다.</p><p>5.2.8 Type variable names<br>Generic을 쓰거나 타입 변수의 이름은<br>A single capital letter, optionally followed by a single numeral (such as E, T, X, T2) 와 같이 쓰고<br>name form은 class부분을 따른다. <br>ex) RequestT, FooBarT</p><p>협업이 많이 있는 경우 자체적으로 코드 스타일을 정해서 IDE에서 제공하는 코드 formatter를 사용한다고 합니다. 그래서 저는아래 링크의 google style을 적용해보기로 했습니다.</p><ul><li>google style</li></ul><p>sudo git clone <a href="https://github.com/google/styleguide.git">https://github.com/google/styleguide.git</a></p><p>다운받고, 안드로이드 스튜디오 적용 시키고 cmd + shift + L 하면 적용됩니다.</p><p>적용이 정확히 되었다. 하지만.. 믿을 수 없다. 정말 내가 만든 코드가 google code guide를 따라가고 있는지.</p><p>그래서 CheckStyle-IDEA의 힘을 빌려봤습니다. plugins에서 이 plugin을 설치하고 restart합니다. 그리고 google code style를 적용하여 실행시켜보면..</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*7L8_28siRN5wyKJGi_GIHA.png" /></figure><p>다음과 같이 나옵니다.</p><p>IDEA의 힘을 빌려 code formatting을 했지만 몇개의 조항이 맞지 않는 것을 볼 수 있습니다. 그럼 이제 수정을..</p><p>수정을 완료하면 다음과 같이 clear 된 모습을 확인할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*e-vEROquIpUk6VZjbREkEw.png" /></figure><p>CheckStyle found no problems in the file!</p><p>문서가 옛날 페이지들도 있지만 최신 업데이트 된 페이지를 조금씩 읽어나가면서 변경해보려합니다.</p><ul><li>참고하고 있는 google code check style</li></ul><p><a href="https://github.com/checkstyle/checkstyle">https://github.com/checkstyle/checkstyle</a></p><ul><li><a href="https://source.android.com/source/code-style.html">Code Style for Contributors | Android Open Source Project</a></li><li><a href="https://google.github.io/styleguide/javaguide.html">Google Java Style Guide</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3ccafe6663ce" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Hashmap vs Sparse Array]]></title>
            <link>https://medium.com/@ggikko/hashmap-vs-sparse-array-49fe0fdc56b1?source=rss-a9f7c0ecc750------2</link>
            <guid isPermaLink="false">https://medium.com/p/49fe0fdc56b1</guid>
            <dc:creator><![CDATA[Park Ji Hong , ggikko]]></dc:creator>
            <pubDate>Fri, 19 Aug 2016 17:14:11 GMT</pubDate>
            <atom:updated>2016-08-19T17:36:35.535Z</atom:updated>
            <content:encoded><![CDATA[<p>Sparse Array의 장점:</p><ol><li>auto boxing 비용 안듦</li><li>할당 이점</li></ol><p>Sparse Array의 단점 :</p><ol><li>안드로이드 프로젝트가 아닌 곳에서 작동안함.</li><li>큰 collection에 바람직 하지 않다.</li><li>int형 key 값 제약 사항</li></ol><p>아래 3번 째 링크를 보면, 맵으로서 2개의 액션은 같지만 다른 실행 방식을 보인다.</p><ul><li>sparse array of &lt;int, String&gt; vs an HashMap of &lt;Integer,String&gt;</li></ul><p>jvm에 의존하기에 Integer는 16bytes, premitive type의 int는 4bytes 이다.</p><p>코드를 한번 열어 보면,</p><ul><li>Sparse Array 일부</li></ul><pre>private int[] mKeys;<br>private Object[] mValues;<br>private int mSize;</pre><pre>public SparseArray(int initialCapacity) {<br>    if (initialCapacity == 0) {<br>        mKeys = EmptyArray.INT;<br>        mValues = EmptyArray.OBJECT;<br>    } else {<br>        mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);<br>        mKeys = new int[mValues.length];<br>    }<br>    mSize = 0;<br>}</pre><p>key자체가 primitive type으로 선언되어있고, 모두 boxing을 하지 않는다. 반면에 Hashmap의 경우</p><pre>public V put(K key, V value) {<br>    throw new RuntimeException(&quot;Stub!&quot;);<br>}</pre><p>Object, Object로 받고 Auto boxing되야 하는 과정이 들어있다. 따라서 overhead가 발생. int형 type의 키 값은 장점이자 단점이 될 수 있다.</p><p>다음으로 메모리 할당이다.</p><ul><li>처음 개발 공부를 시작할 때는 자료구조는 다 만들어 보고 적용해보고 비교도 해봤는데 머리속에서 잊혀져버렸다. 더 노력해야겠다</li></ul><p>ref -</p><p><a href="https://www.javacodegeeks.com/2012/07/android-performance-tweaking-parsearray.html">https://www.javacodegeeks.com/2012/07/android-performance-tweaking-parsearray.html</a></p><p><a href="http://log.hanjava.net/post/30231660090/map-hashmap-%EA%B7%B8%EB%A6%AC%EA%B3%A0-sparsearray">http://log.hanjava.net/post/30231660090/map-hashmap-%EA%B7%B8%EB%A6%AC%EA%B3%A0-sparsearray</a></p><p><a href="https://edgblog.wordpress.com/2013/05/07/sparsearray-vs-hashmap/">https://edgblog.wordpress.com/2013/05/07/sparsearray-vs-hashmap/</a></p><p><a href="http://stackoverflow.com/questions/25560629/sparsearray-vs-hashmap">SparseArray vs HashMap</a></p><p>code : <a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/2.2_r1.1/android/util/SparseArray.java">http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/2.2_r1.1/android/util/SparseArray.java</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=49fe0fdc56b1" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[(Reading)]]></title>
            <link>https://medium.com/@ggikko/reading-982ebc9cb277?source=rss-a9f7c0ecc750------2</link>
            <guid isPermaLink="false">https://medium.com/p/982ebc9cb277</guid>
            <dc:creator><![CDATA[Park Ji Hong , ggikko]]></dc:creator>
            <pubDate>Thu, 18 Aug 2016 23:57:40 GMT</pubDate>
            <atom:updated>2016-08-19T00:10:21.260Z</atom:updated>
            <content:encoded><![CDATA[<p>(Reading)</p><p>Process, 복잡도, Hash, Tree, Overriding, Overloading, JVM, Operating System, JVM, mutate, getDrawable, Clear, Code naming, fragment null(activity, fragment)기본</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=982ebc9cb277" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>