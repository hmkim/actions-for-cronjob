<?xml version='1.0' encoding='UTF-8'?><?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?><feed xmlns='http://www.w3.org/2005/Atom' xmlns:openSearch='http://a9.com/-/spec/opensearchrss/1.0/' xmlns:blogger='http://schemas.google.com/blogger/2008' xmlns:georss='http://www.georss.org/georss' xmlns:gd="http://schemas.google.com/g/2005" xmlns:thr='http://purl.org/syndication/thread/1.0'><id>tag:blogger.com,1999:blog-1365591944722180079</id><updated>2019-05-05T01:23:41.442-07:00</updated><category term="분석/요구사항"/><category term="소프트웨어공학"/><category term="SWEBOK(소프트웨어 지식체계)"/><category term="문화/조직/회사"/><category term="코딩"/><category term="프로세스"/><category term="기반시스템"/><category term="소프트웨어 공학"/><category term="실리콘밸리"/><category term="정부 정책"/><category term="ATP"/><category term="Outsourcing"/><category term="계약"/><category term="방법론"/><category term="설계"/><category term="영어"/><category term="인수테스트"/><title type='text'>김익환의 &quot;소프트웨어 지혜&quot;</title><subtitle type='html'>실리콘밸리에서 20년 글로벌 소프트웨어 회사에서의 경험과 한국에서의 18년 정부,학계,산업계를 컨설팅한 경험을 바탕으로 한국 소프트웨어 업계가 필요로 하는 &quot;소프트웨어 지혜&quot;를 얘기합니다.&#xa;&lt;br&gt; * 당분간 한국 Software 업계에서 가장 취약한 분야인 &quot;분석&quot;에 관해 연재합니다.&#xa;</subtitle><link rel='http://schemas.google.com/g/2005#feed' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/posts/default'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/'/><link rel='hub' href='http://pubsubhubbub.appspot.com/'/><link rel='next' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default?start-index=26&amp;max-results=25'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><generator version='7.00' uri='http://www.blogger.com'>Blogger</generator><openSearch:totalResults>40</openSearch:totalResults><openSearch:startIndex>1</openSearch:startIndex><openSearch:itemsPerPage>25</openSearch:itemsPerPage><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-1248765825541946280</id><published>2019-01-10T05:56:00.000-08:00</published><updated>2019-01-10T06:07:25.845-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="ATP"/><category scheme="http://www.blogger.com/atom/ns#" term="계약"/><category scheme="http://www.blogger.com/atom/ns#" term="분석/요구사항"/><category scheme="http://www.blogger.com/atom/ns#" term="소프트웨어공학"/><category scheme="http://www.blogger.com/atom/ns#" term="인수테스트"/><title type='text'>분석 #10. 잘못된 국내 Outsourcing 계약 방식과 글로벌 계약 방식</title><content type='html'>&lt;br /&gt;이 기사는 일전에 게재한 기사인 “분할발주의 허구와 진실” 과 바로 앞 기사인 베트남의 Outsourcing 회사에 관한 기사와 연관되어 있다. 국내 개발 Outsourcing 생태계의 도전적인 숙제이자 염원이기도 한 “분할 발주”도 하고 싶고 글로벌 고객을 상대로 개발 Outsourcing 비지니스도 하고 싶겠지만 열정과 의지만으로 되는 것은 아니고 그를 수행할 수 있는 기본 역량부터 있고 다양한 고객을 상대할 수 있는 경험도 있어야 한다. &lt;br /&gt;&lt;br /&gt;대부분의 국내 회사는 거의 미신과 같은 국내의 기존 관행에 몇십년을 젖어 있었기 때문에 우물안 개구리의 문제점을 눈치 채기도 어렵다. 이 기사를 읽어도 눈치 챌 수 있는 사람은 극히 소수일 것이다. 꿈속에서 사는 삶이 있고 현실의 삶이 따로 있는데 이런 추상적인 문제에서는 계속 꿈속에서 사는 것이 통상적이다. 영화 매트릭스에서 얘기한 빨간 약을 먹으면 계속 행복한 환상의 세계에서 살고 파란 약을 먹으면 고통스러운 진실과 마주한다는 것과 같다. 현실에서는 진실을 모르는 것이 더 좋은 경우가 더 많다. 어느 쪽을 택할 지는 순전한 각자의 선택이다.&lt;br /&gt;&lt;br /&gt;먼저 소프트웨어 외주 개발 계약의 방식부터 간단히 살펴보자. 필자의 저서와 블로그에서 여러 번 언급했듯이 계약에는 Time and Material(T&amp;M)과 Turn-key 의 두 가지 방식이 있다. &lt;br /&gt;&lt;br /&gt;T&amp;M은 인력의 노동시간(Time)으로 비용을 지불하는 방식이다. 발주자나 인력 업체나 간단하다. 인력을 어떻게 사용할지는 발주자가 알아서 관리한다. 계약한 숫자의 인력만 제대로 공급해주면 법적인 소송의 여지도 없다. 주로 개발 앞쪽의 분석 단계에서 사용된다.  산출물에 대한 객관적인 기준을 정할 수 없는 경우에는 T&amp;M 방식이 가장 좋다.  정확하게 말하면 인력의 시간외에 실제 들어가는 장비나 물품((Material)이 포함한다.&lt;br /&gt;&lt;br /&gt;반면에 Turn-key 방식은 서로 약속한 제품을 미리 정해진 가격(Fixed Price)과 일정에 개발해 주기로 하는 것이다. 즉 한 사람이 개발하건 10명이 개발해 주건 상관할 필요가 없다. 예를 들어 책상을 주문했는데 몇 명이 만들 건 상관이 없다. 원하는 제품을 만들어 주면 되는 것이다. 자동차를 주문해도 마찬가지이다. 몇 명이 만들었는지도 모르고 알 필요도 없다. 그런 자유가 있는 반면에 책임도 크다. Turn-key 방식은 약속한 물품을 제 일정에 배달하지 못하면 당연히 피해 보상등 법적 소송의 문제가 발생한다. &lt;br /&gt;&lt;br /&gt;소송에서 시시비비를 판단하려면 제품에 대한 정확한 스펙(SRS)이 있어야만 가능하다. 정확한 스펙을 작성하는 것이 얼마나 어려운 지는 그 동안 필자가 누누히 설명했다. 정밀도의 문제와 같다. 1센티를 따지는 스펙과 1밀리미터를 따지는 스펙은 양과 질에서 차이가 난다. 소프트웨어도 홈페이지 만드는 정밀도와 금융 소프트웨어를 만드는 정밀도가 다르다. 간단한 홈페이지 프로젝트는 적당한 계약에 애자일 방법론도 좋고 주먹구구식으로 개발해도 큰 문제가 없다. 문제가 있으면 별 피해 없이 고치면 된다. 금융 소프트웨어는 1분만 다운되어도 피해보상 소송이 빗발치니 처음부터 문제 없도록 개발해야 한다.&lt;br /&gt;&lt;br /&gt;스펙에 대해서는 여러 곳에서 충분히 설명했기 때문에 여기서 생략하고 Turn-Key 계약에 스펙보다 더 핵심인 인수테스트(Acceptance Test Plan, ATP)를 추가로 소개한다. 회사마다 용어가 약간 다를 수 있으나 가장 혼란 없이 이해하는 용어인 ATP를 사용하기로 한다.&lt;br /&gt;&lt;br /&gt;위에서 말한 T&amp;M 방식의 계약에는 인력 공급 내용만 있지 산출물은 정해지지 않았기 때문에 검증할 인수 조건이 없다. 쉽게 말해 일당으로 비용이 계산되는 일용직 고급 근로자라고 보면 적절하다. 통상적으로 분석이나 설계 작업과 같이 하루에 수천불 가격인 매우 비싼 직업이다. 개발의 첫 단계에서는 계약에 명시할 스펙도 없고 인수 조건도 나올 수 없다. 이런 비싼 고급 전문가를 잘 사용하고 관리하는 것은 전적으로 발주자의 역할이다. 전문성이 높은 분석가나 아키텍트인 만큼 대부분은 발주자를 리드하고 주도해서 일을 할 수 있는 능력이 있다. 그런 능력 때문에 비싼 값을 지불한다.&lt;br /&gt;&lt;br /&gt;Turn-Key 방식의 핵심이 스펙이라고 이전에 필자가 계속 말해 왔는데 일부만 사실이다. 진짜 핵심은 인수조건이다. 인수테스트로 대표되는 인수조건이 핵심이다. 하지만 인수테스트만 가지고는 개발을 할 수 없기 때문에 개발할 내용을 설명하는 스펙이 필요한 것이지 법적인 상황에서는 스펙보다는 ATP로 시비를 가린다. 근본적으로 ATP를 통과하면 계약은 종료된 것이고 ATP 중에 하나라도 실패하면 계약이 종료되지 않은 것이다. 개발사가 폭포수 모델로 개발하건, 애자일방식으로 개발하건 반복적모델로 개발하건 상관이 없다. 100개가 넘는 시중의 개발방법론, 또 수만개는 되는 다양한 종류의 템플릿 중에 어떤 것을 사용하건 상관할 필요가 없다. 그냥 약속한 일정에 ATP를 통과한 물품을 배달하기만 하면 된다. 이상적인 상황이라면 중간에 서로 대화를 할 필요도 없다. 배달 날자까지 기다렸다가 인수를 하든지 피해보상 소송을 하든지 둘 중의 하나이다. 이 부분은 명백한 흑백논리가 적용된다. 예를 들어 ATP에 포함된 10,000개의 테스트 케이스 중에서 1개라도 실패하면 실패한 것이다. &lt;br /&gt;&lt;br /&gt;Turn-key 계약의 인수조건은 아주 명백하지만 아무나 이렇게 하기 어려운 두가지 이유가 있다. ATP에 포함되는 테스트 케이스를 만들기 어렵다. 국내에서 ATP를 이용해서 계약을 한 회사는 필자는 본 적이 없다. 대부분은 엉성한 스펙만으로도 몇 백억짜리 프로젝트도 계약 한다. 성공하면 기적이다. &lt;br /&gt;&lt;br /&gt;누가 테스트 하느냐에 따라서 ATP에 들어가는 테스트 케이스의 개수는 10배도 더 차이가 난다. 회사의 내부에서 제품도 잘 알고 늘 테스트 해 오던 사람들이 하는 경우와 외부의 인력이 테스트 할 경우에 테스트 케이스의 숫자가 10배 정도의 차이가 날 수 있다. 전혀 모르는 사람에게 스펙을 적어 줄 때도 마찬가지이다. 내부 인력이라면 10 페이지 적으면 되는 양을 외주 계약을 위해서는 100 페이지를 적어야 하는 경우가 전혀 이상한 것이 아니다.  필자에게 “스펙이나 ATP를 얼마나 자세히 적어야 됩니까?” 라는 질문을 많이 하는데 고객과 상황에 따라 다르다는 답 밖에 없다. 이런 상황에 따른 유연성이 진정한 소프트웨어 공학의 영역이다. 건강에 좋은 음식이 사람에 따라 다른 것과 마찬가지이다. 만약 누가 정형화된 답을 준다면 그것은 이론이며 가짜 소프트웨어 공학인 것이다.&lt;br /&gt;&lt;br /&gt;우여 곡절 끝에 많은 시간을 들여서 외부 사람들을 위한 방대한 ATP 테스트 케이스를 작성했다고 가정하자. 그렇다고 개발업체만 믿고 계약 마지막 날에 완성이 될 것이라고 기다리기에는 불안하다. 100만원에 1주일짜리 프로젝트라면 그렇게 해도 괜찮겠지만 100억에 1년 걸리는 프로젝트를 하는데 그렇게 할 수는 없다. 그래서 ATP는 완료 평가의 척도는 되지만 중간에 개발이 제대로 진행되는지 확인하기 위해서는 다른 방법이 필요하다. 그래서 Design Review, Integration Test, 몇 번의 Iteration등 중간 중간에  진행 상황을 검증할 수 있어야 한다. 물론 여기에서도 몇 명이 개발하는지는 중요하지 않다. 천재 1명이 개발하든 초급개발자 100명이 개발하든 그건 개발업체의 선택이다. &lt;br /&gt;&lt;br /&gt;정확한 스펙과 ATP도 없이 수행하는 Turn-key 계약은 근본적으로 거대한 위험성을 내포하고 있다. 성공할 가능성은 없다고 보면 된다. 나중에 그냥 서로 눈감고 대충 넘어가거나 소송으로 가거나 둘 중의 하나이다. 거대한 제품을 개발했는데 인수를 거절해서 소송이 벌어진 경우도 있다. 정확한 스펙과 ATP 없이 계약하려고 하니까 뭔가 안전장치를 만들어야 하고 담당자는 책임도 회피해야 하니 투입할 인력을 명시하게 된다. 더군다나 발주자가 확인할 수 있는 장소에 상주하도록 요구한다. 그러다 보니 Turn-key 계약에 액수, 일정, 인력까지 명시하는 것이다. 상식적으로 말이 안되지만 담당자가 책임을 회피하기 위해서는 가장 쉬운 방법이 인력이다. 그러니 원래 어려운 원격 개발은 이래저래 더 어렵다.&lt;br /&gt;&lt;br /&gt;그래서 T&amp;M 방식도 아니고 Turn-key 방식도 아닌 비상식적인 계약이 그동안 국내에서 멀쩡하게 사용되어 왔다. 그럴 수 밖에 없는 근본적인 원인은 스펙의 부정확성,  ATP의 부족이나 부재, 그리고 중간에 Monitoring 할 수 있는 역량이 부족하기 때문이다. 국내에서는 이런 식의 계약에도 거부감을 느끼지 못하겠지만 이런 비상식적인 계약은 소프트웨어 선진국의 정상적인 상황에서는 존재할 수 없다. 발주자인 갑의 역량부족으로 인해서 생긴 계약의 횡포일 뿐이다. 이 모든 문제를 해결하려면 ATP를 작성할 수 있는 역량이 있어야 하는데 ATP를 만들기 위해서는 정확한 스펙이 있다는 가정하에서만 가능하다.&lt;br /&gt;&lt;br /&gt;진정한 Turn-key로 계약하고 관리할 수 없는 회사에서 과연 훌륭한 소프트웨어를 만들어 낼 수 있을까? 없다고 생각한다. 전략 없는 숙련공들의 혼란스러운 개발이 될 수 밖에 없다. 스펙을 개발 도중에 변경하는 일도 빈번하고 따라서 회의나 번잡스러운 일이 많아지고 관리비용이 엄청나게 추가된다. 개발보다는 관리에 더 집중하기 쉽다. 그래서 관리를 잘해 보겠다고 또 새로운 시스템을 도입하거나 PMO니 하는 얘기가 나오는데 방향을 잘못 잡는 것이다. 합리화 하기 위한 방법으로 실리콘밸리의 영웅담 같은 얘기는 꼭 인용한다. 악순환이 계속된다. 대부분의 문제는 관리로 해결될 수 있는 문제가 아니기 때문이다. 좌절한 개발자가 중간에 사라지는 것도 늘 보는 현상이고 납기 지연은 너무 당연하다. 종종 나오는 뉴스가 알만한 큰 프로젝트들이 지연되었다는 기사이다.  &lt;br /&gt;&lt;br /&gt;국내는 인간 관계로 적당히 실패를 덮어 버릴 수 있다. 그러나 그럴 수 없는 국제간의 심각한 계약을 한다고 생각해 보면 ATP를 작성할 수 있는 역량이 없으면 T&amp;M 방식으로 계약하는 방법 밖에 없다. 글로벌 회사에서는 발주자나 개발업체나 둘 다 엉성한 Turn-key 계약은 할 수 있는 근거도 없고 그런 위험하고 무책임한 계약은 하지도 않는다.&lt;br /&gt;&lt;br /&gt;거의 모든 국내 소프트웨어 관련 소송은 이 부류에 속한다. 소송 당사자들은 국내 관행대로 했는데 왜 소송을 당했는지를 이해하지 못한다. ATP와 같은 객관적인 평가 기준이 없으니 자신들 유리한 대로 해석하고 서로 상대방만 비난한다. 개발업체는 몰상식한 악덕 발주자를 만나서 억울하다고 하고 발주자는 회사에 손해를 끼친 엉터리 개발업체라고 분에 차있다. 처음부터 사기를 치려고 하지 않았다면  대부분의 경우 둘 다 50% 씩 잘못이다. 이 모두 ATP만 있었다면 소송에 갈 필요도 없다.&lt;br /&gt;&lt;br /&gt;분할 발주, 원격 개발, 탄력있는 근무 시간등 아주 듣기 좋은 말들이다. 정부가 강제로 계약에 관련된 이런  정책을 법제화 하려고 하는 것은 좋지만 생태계가 준비되지 않은 상태에서는 더 큰 문제를 불러 올 수 있다. 근본적인 이해 없이 눈 앞의 증상만을 치료해 보고자 하는 단세포적인 정책은 또 다른 문제를 불러온다. 극히 조심해야 한다.&lt;br /&gt;&lt;br /&gt;스펙이나 ATP 작성 역량은 계약을 위한 역량뿐은 아니고 소프트웨어를 제대로 개발하기 위해 꼭 필요한 역량이다. 이런 기초 체력 없이 소프트웨어 강국이 되려는 생각은 허황된 망상에 불과하다. 그냥 국내에서 국내 고객을 위해 국내용 소프트웨어를 개발하는 정도로 만족해야 한다. 그것도 하나의 훌륭한 성공이다. 많은 시간과 경험이 필요한 이런 역량을 교육으로 해결하겠다는 생각을 하는 사람들도 많이 봤는데 태권도를 이론 교육으로 가르치려는 것과 같다. 이는 학교에서는 절대 가르칠 수 없는 현실의 문제이고 바로 진정한 소프트웨어 공학 역량이다.&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/1248765825541946280/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=1248765825541946280' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/1248765825541946280'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/1248765825541946280'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2019/01/10-outsourcing.html' title='분석 #10. 잘못된 국내 Outsourcing 계약 방식과 글로벌 계약 방식'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-1701372106707851450</id><published>2018-11-10T02:27:00.002-08:00</published><updated>2018-11-15T03:29:37.283-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Outsourcing"/><category scheme="http://www.blogger.com/atom/ns#" term="분석/요구사항"/><category scheme="http://www.blogger.com/atom/ns#" term="소프트웨어공학"/><category scheme="http://www.blogger.com/atom/ns#" term="영어"/><title type='text'>분석 #9. 글로벌 SW Outsourcing 시장, 분석과 영어 역량</title><content type='html'>&lt;br /&gt;필자가 15년 전에 &quot;대한민국에는 소프트웨어가 없다&quot; 라는 책을 썼다. 그동안 여기저기 사람들을 만나다 보면 &quot;지금은 소프트웨어가 있습니까?&quot; 하고 나에게 물어본다. 변한 것이 없다고 대답한다. 마치 엄청난 발전을 이룬 것 같지만 잘 보면 하나도 잘 된 것이 없다. 마치 &quot;15년 전보다 세상이 행복해 졌습니까?&quot; 라고 묻는 것과 같다.  문명은 엄청난 발전을 했지만 정신적인 행복은 변한 것이 없다. 아마 더 불행해 졌을지도 모른다. SW도 마찬가지이다. 수 많은 새로운 도구와 기술이 생겨났지만 그런 것은 이 세상 누구나가 다 사용하는 것이다. 즉 경쟁력에서 도움이 되지도 않고 그냥 모든 사람들에게 편리한 도구가 생긴 것 뿐이다. 그런 것을 사용한다고 더 경쟁력이 생기는 것도 아니고 당연히 때에 따라 편리하니까 사용하는 것일 뿐이다. 유행에 따라 잠깐 생겼다가 없어지는 것이 대부분이다. 동서고금을 통해 진짜 중요한 도구들은 이미 필자가 경험한 40년 전부터 존재해 왔다. 예를 들어 소스코드관리 시스템이나 이슈관리 시스템 같은 것이다. 많은 진화를 거듭해서 편리한 점이 많아 졌지만 그 사상에는 큰 차이는 없다. Git이나 Jira가 없었던 과거에도 다른 도구들이 있어 왔고 똑같이 사용해 왔다. 글로벌 대기업들은 내부적으로 그런 도구들을 자체 개발해서 사용하기도 한다. 하지만 사상은 변하지 않았다.&lt;br /&gt;&lt;br /&gt;SW 역량을 평가할 때 여러가지 관점이 있지만 여기서는 SW Outsourcing 중에서도 SW 개발 Outsourcing 역량에 대해서 얘기하기로 한다. SW 개발 Outsourcing,은 국내에서는 소프트웨어 개발의 약 70%를 차지한다는 통계가 있다. 30%는 자체 제품이나 인프라 개발이다. 그 만큼 무시할 수 없는 비중을 차지하고 있기도 하고 SW 산업이 3D 업종이라고 불리는 중요한 원인이기도 하다. SW에서 생기는 모든 문제는 결국은 분석역량이 최초의 원인으로 도달하게 된다. 그 다음은 설계 역량이 중요할 텐데 궁금해 하는 사람들을 위해 숫자로 표현하자면 분석에 비해 1/10 정도의 중요성이다. 숫자는 상징적인 의미를 위해 사용했지 컨설팅업체라면 만들어 내는 재주가 있을지 모르지만 어디에도 이런 근거는 있을 수 없다. 그러니 설계를 귀신같이 한다고 해도 10% 밖에 안되는 것을 잘하는 것이다. 난이도도 1/10 정도이다. 바둑을 두는데 프로가 되는 것이 아마추어의 최고가 되는 것과는 열 배 이상 더 어렵다. 분석을 잘하는 것과 설계를 잘하는 것은 프로와 아마추어의 관계라고 비교할 수 있다. &lt;br /&gt;&lt;br /&gt;전세계 SW 개발 Outsourcing business는 몇십년 전부터 cross-border라고 국가의 경계를 넘어 진행되어 왔다. 거리가 먼 나라인 경우 Offshore, 몇시간 정도 거리를 near-shore, 바다를 넘어기지 않고 가까운 경우 on-shore라고 부르기도 한다. 현재 전 세계 SW 개발 Outsourcing business에서 인도와 베트남이 가장 중요한 나라이다. 인도는 미국에게서 배웠고 베트남은 인도에게 배워서 따라 하는 상황이기 때문에 베트남이 인도에 비해 10년 이상은 뒤떨어져 있다고 본다. TCS나 Wipro같은 인도의 글로벌 Outsourcing회사는 인건비도 비싸지만 이제는 지저분한 고객과는 상대를 하지 않는다. 그런 인도 회사들이 떠나는 자리를 베트남이 메꾸기 시작해 결과적으로 인도와 베트남이 이제는 전 세계 Outsourcing 시장의 양대 산맥이 되었다.&lt;br /&gt;&lt;br /&gt;인터넷에서 &quot;Software Outsourcing India&quot;, &quot;Software outsourcing Vietnam&quot;과 &quot;Software Outsourcing Korea&quot;로 비교해 보기 바란다. 국내 SW의 70%를 차지한다고 하는 국내 개발 회사들은 글로벌에는 존재가 전무하다. 반대로 Vietnam에 관한 자료는 연구논문이 있을 정도로 수를 셀수 없이 많다. 베트남에서 가장 큰 SW 회사라고 하면 FPT Software인데 개발인력만 만명이 넘는다. 고객의 대부분이 미국, 일본, 유럽의 글로벌 회사들이다. FPT 이외에도 규모는 작지만 수천명의 개발인력을 가진 회사들이 수십개가 넘는다. 제조업이 많지 않은 베트남의 국내 사정상 국내 고객은 극히 적다. 모두 처음부터 외국의 고객들을 대상으로 생겨났다. 글로벌 회사들을 상대로 10년 이상을 개발해 왔기 때문에 엄청난 기술과 함께 소프트웨어 공학 역량도 축적이 되었다. 베트남의 중요한 외화벌이 산업이기도 한다.&lt;br /&gt;&lt;br /&gt;위에서 말한 인도의 회사들이 피하는 &quot;지저분한 고객&quot;은 바로 주먹구구식으로 계약을 하는 회사들이다. &quot;주먹구구식&quot;과 똑같은 단어가 &quot;분석역량이 없다&quot;는 것이다. 국내 회사가 10페이지 짜리 스펙을 적을 때 글로벌 회사들은 100페이지 짜리 스펙을 적는다. 그런 두 회사가 계약을 하거나 파트너십을 얘기할 때 잘 되지 않을 것은 너무 당연하다. 프로와 아마추어의 차이이다. 프로는 프로를 찾아서 놀기 마련이다. 그래서 인도의 회사들이 국내 회사들을 상대하지 않는 이유이기도 하다. 그런 국내 회사들을 베트남 회사들은 지금은 기꺼이 고객으로 상대해 준다. 워낙 인건비가 저렴하니 위험을 감수해도 이익을 창출할 수 있다고 생각한다. 소위 갑질이라고 하는 &quot;고객의 사양 변경하기&quot;를 당해도 자존심 버리고 저비용으로 버틸 수 있다. 자존심이 없거나 몰라서 당하는 것이 아니다. 하지만 인건비 비싸고 마진이 작은 국내 SI 회사들은 버티기 어렵다. &lt;br /&gt;&lt;br /&gt;베트남의 Outsourcing 회사들은 미국, 일본, 유럽의 고객들과 경험이 있기 때문에 당연히 국내 회사들의 차이와 문제점을 잘 알고 있다. 또 베트남이 글로벌시장에서 성공할 수 있었던 가장 중요한 이유중의 하나가 영어 역량이다. 내가 만났던 베트남회사의 모든 임원들은 영어를 실리콘밸리에서 만나서 회의하는 것과 같은 정도로 편안하게 구사한다. FPT Software의 경우 모든 직원들이 email과 문서는 영어로 적는 것으로 규정하고 있다. 또 일년에 한 번씩 모든 임직원이 예외 없이 TOEIC 시험을 봐서 점수를 공개한다. 또 FPT가 설립한 베트남의 최고 기술대학 중의 하나인 FPT University의 입학 조건이 TOEIC 800점이다. 국내에서 직원의 TOEIC 평균이 800 점을 넘는 회사는 아마 한두 군데 뿐일 것이다. 일본의 대기업들도 영어만 사용하도록 규정을 바꾼 회사들이 점점 더 많이 생기고 있다. 일본의 최대 인터넷 쇼핑몰 회사인 라쿠텐이 2010년에 회사의 공식 내부 언어는 영어로 한다고 해서 직원들을 쇼크상태로 몰아가기도 했다. 하지만 지금은 감사해 하는 직원들이 많다. 언어에 관한 한 가장 폐쇄적인 나라였던 일본 회사들도 글로벌 환경에 적응하기 위해 그만큼 변하고 있다.&lt;br /&gt;&lt;br /&gt;베트남의 소프트웨어 산업은 이런 소프트웨어 공학과 영어의 역량을 기반으로 글로벌 회사들과 같이 일을 하면서 빠르게 성장하고 있다. 반면에 국내의 상황은 암울하다. 앞으로 10년이 지나도 오늘 현재 베트남이 글로벌에서 가지고 있는 수준을 넘어가지 못할 것이다. 그냥 국내용 숙련공들만 많이 생기는 생태계이다. 필자가 볼 때 20년 전의 상황이나 지금 상황이나 소프트웨어공학 역량이나 영어역량은 변한 것이 없다. 그냥 보호무역적이고 폐쇄적인 상황에서 국내용으로 안주해 왔을 뿐이다. 국내의 온라인 쇼핑몰 중에 외국인이 구매할 수 있는 곳은 없다. 필자가 늘 얘기하듯이 국내에서만 살아가겠다면 식당을 하든, 술집을 하든, 소프트웨어 회사를 하든 참견할 일은 아니다. 하지만 식당을 열어 놓고 외국고객을 상대로 장사를 하겠다고 주장한다면 변해야 한다.&lt;br /&gt;&lt;br /&gt;지난 20년 이상 그랬듯이 지금도 국내에서 정부, 산업계, 학계, 연구소에서 수 많은 탁상공론들이 얘기되고 있다. 아직도 무엇이 핵심인지도 모르고 이론과 용어만 가지고 메뉴만 바꾼 시행착오를 하고 있다. 진정한 분석이 무엇인지 본 적도 없으니 100페이지를 10페이지로 적고 껍데기에 불과한 방법론이나 운운하며 자아도취에 빠져서는 앞으로 영원히 발전할 수도 없고 베트남에게도 점점 더 뒤떨어 질 것이다. 세계에 내 세울만한 소프트웨어는 하나도 없고 외국 대학 수업의 숙제 수준의 소프트웨어를 만들어 정부 보조금 받아 생존하며 자화자찬 하면서 세계적인 소프트웨어를 만들었다고 주장하는 상황이 20년 전이나 신기할 정도로 전혀 변한 것이 없다. 마치 데자뷰를 보는 것 같다. 베트남이 많은 글로벌 회사들을 고객으로 개발을 하면서 성장했다는 사실도 모르는 우물안 개구리로 살고 있다. 자아도취와 자화자찬이 현재의 국내 상황이다. 그러면서 글로벌 흉내를 낸다고 국내 실정에 맞지도 않는 것을 따라 하려고 하는 것도 20년 동안 전혀 변하지 않았다. 바로 &quot;아니면 말고&quot;이다. 장님 코끼리 만지듯 주워들은 실리콘밸리의 영웅담 얘기는 모든 사람이 빼놓지 않고 한다. 서울 안가본 사람이 서울을 더 잘아는 척하는 얘기와 같다.&lt;br /&gt;&lt;br /&gt;차라리 가짜 소프트웨어 공학으로 그동안 시행착오 했을 동안에 영어공부라도 했으면 국내 사이트의 가짜 정보 대신에 글로벌 사이트에서 영어로 된 정보를 접하는 것이 더 좋았을 수도 있다. 소프트웨어 개발은 단순하다. 분석-&gt;설계-&gt;구현-&gt;테스트 이다. 하지만 단순하지만 어렵다. 노래를 잘하려면 음정과 박자를 맞추면 된다는 것과 비슷하다. 단순하지만 혼자서 배우기는 어렵다. 누군가에게 배워야 한다. 철학자인 니체가 &quot;세상에는 진짜보다 가짜가 더 많다&quot;라고 했다. 국내에서 진짜를 거의 찾아보기 힘든 분야가 소프트웨어 공학분야이다. &lt;br /&gt;&lt;br /&gt;적어도 20년 이상을 이런 생태계로 지내면서 이해 집단도 많아져 진짜가 살아가기 어려운 생태계가 되어버렸다. 먼저 개발자들이 더 이상 속아 넘어가지 않는 것이 중요하다. 그러는 순간 길이 보이기 시작할 것이다. 적어도 20년 이상을 반복해 온 역사에서 배울 것이 있다. 또 &quot;촘스키처럼 생각하는 법&quot;이라는 책에서 말하는 것 처럼 남에게 이용 당하지 않으려면 가짜로부터의 지적인 자기방어가 필요하다.&lt;br /&gt;&lt;br /&gt;필자의 경우에도 이제는 웬만하면 베트남 개발 인력을 사용하려고 하고 있다. 베트남이 SW Outsourcing에서 성공할 수 있었던 이유는 도메인 지식도 아니고 영어를 기반으로 인도에게서 배운 소프트웨어 공학 역량이었다.  그 중에서도 계약을 가능하게 하는 것은 바로 분석 역량이다. 혹은 Software Requirements Specification(스펙)을 작성할 수 있는 능력이다. 인도는 똑같이 미국에게서 배웠다. 베트남에게서 배워야 한다는 것을 인정하기 힘들겠지만 너무 수준 차이가 나는 미국이나 인도보다도 베트남에게서 배울 점이 있다는 것을 쉽게 인지할 수 있다.&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/1701372106707851450/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=1701372106707851450' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/1701372106707851450'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/1701372106707851450'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2018/11/9-sw-outsourcing.html' title='분석 #9. 글로벌 SW Outsourcing 시장, 분석과 영어 역량'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-3685153110562518880</id><published>2017-07-15T02:13:00.000-07:00</published><updated>2017-07-16T22:19:29.732-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="방법론"/><category scheme="http://www.blogger.com/atom/ns#" term="분석/요구사항"/><category scheme="http://www.blogger.com/atom/ns#" term="소프트웨어공학"/><title type='text'>분석 #8 애자일은 죽었다</title><content type='html'>&quot;애자일&quot;이라고 하면 국내 소프트웨어 업계에서는 보통 &quot;스크럼&quot;으로 알고 있다. 여기서 스크럼을 자세히 설명하는 것은 의미가 없고 대충 설명하자면 10명 정도의 한 팀에서 스프린트라고 불리는 2주일 개발주기로 개발하면서 매일 아침 서서 회의를 한다는 것이다. 필자는 이 말을 듣고 농담하는줄 알았다고 책에서 적은 적이 있다.&lt;br /&gt;&lt;br /&gt;하여튼 형식과 체계를 싫어하는 자유로운 영혼의 개발자들에게는 무척 희소식이다. 어차피 아무런 체계없이 주먹구구식으로 계속 개발할 수는 없다. 명분도 없고 어딘가 찜찜할 수 밖에 없다. 그런 와중에 아주 쉽게 적용할 수 있는 애자일이라는 방법이 있으니 반가울 수 밖에 없다. 이제는 자랑스럽게 방법론에 의해서 개발을 하고 있다고 말할 수가 있게 되었다. 일단 주먹구구식에서 벗어났다고는 할 수 있다. 그 길이 옳은지 아닌지는 별개의 문제이다.&lt;br /&gt;&lt;br /&gt;&quot;애자일&quot;은 추상적인 단어이고 그 종류가 많지만 이 글에서는 애자일이라는 단어를 방법론 중에서 가장 자유로운 스크럼 방법론이라고 가정하고 진행한다. 그 반대 극단은 한번 결정한 것을 변경하지 않는다는 가장 엄격한 방법론인 폭포수모델이다. 요구사항의 변경을 수용하기 위한 반복적인 개발모델의 필요성이 의논된 것은 소프트웨어의 탄생 얼마 후인 1957년이었다. 지금부터 60년 전이다. 그리고 폭포수모델의 병폐와 애자일 방법론의 필요성에 대한 본격적인 논쟁은 거의 30년 전인 1990년에 출간된 &quot;Wicked Problems and Righteous Solution&quot; 이라는 책에서 벌어졌다. 마치 애자일방법론이라는 비법을 최근에 발견한 것 처럼 착각하는데 스크럼이 탄생한 1995년에도 애자일은 이미 퀘퀘묵은 논쟁이었다. 폭포수모델이 필요한 곳에서는 폭포수모델을 계속 사용할테고 절대 폭포수모델을 사용하지 않는 곳도 있고 너무 당연한 종교적인 논쟁일 뿐이다. 중요한 것은 어떤 방법론이 우리가 개발하는 제품에 적당할 것인가이다. &lt;br /&gt;&lt;br /&gt;필자가 실리콘밸리에서 20년 동안 사용한 방법론은 방위산업체에서의 수년간의 폭포수모델과 그 나머지는 애자일 방법론이었다. 물론 애자일이라는 용어가 생겨나기도 전이었기 때문에 스크럼은 당연히 아니고 &quot;빨리 개발하는 방법론&quot; 이라는 의미에서의 애자일방법론이다. 회사마다 빨리 개발하는 방법이 다 달랐다. 당연할 수 밖에 없다. 프로젝트가 다른데 폭포수나 스크럼이 만병통치약이 안되듯이 한 가지 방법론으로 다 통할 수가 없다. 경직도로 봤을 때 폭포수와 애자일 중간에는 수십개의 알려졌던 방법론이 있고 비공식적으로는 회사마다 다른 수만개의 방법론이 있다.&lt;br /&gt;&lt;br /&gt;애자일의 공식적인 생애는 1995년 ~ 2014년까지 20년이다. 그래도 다른 방법론에 비하면 오래 생존한 편이다. 애자일을 창시한 사람들이 애자일은 잘못되었다고 선언했다. 인터넷에서 &#39;Agile is dead&quot;를 검색하면 많은 기사들이 많이 나온다. 그렇다고 애자일을 창시한 사람들이 소프트웨어 개발의 근본 원칙을 부정한 것이 아니라 간단한 규칙을 만들어 준 것이었다. 그 규칙을 누가 어떻게 해석하고 이용하는 가에 따라 좋은 것이 될 수도 있고 나쁜 것이 될 수도 있는데 대부분은 애자일을 만든 사람의 의도와는 다르게 사용되었기 때문에 실패했다고 공식적으로 선언한 것이다. 수 많은 방법론의 역사에서 보면 심각한 일도 아니고 하나의 해프닝으로 볼 수 있다.&lt;br /&gt;&lt;br /&gt;결국 애자일이 되었던 폭포수가 되었던 수 많은 실리콘밸리회사들이 사용하는 방법론의 원칙을 이해하는 것이 중요하다. 그 진리는 분석, 설계, 구현이다. 이 단계를 잘 이해하고 적용하는 것이 중요하지 방법론의 규칙이 중요한 것이 아니다. 어차피 극히 소수만 사용하는 폭포수방법론이 아닌 경우에는 모두 반복적인 방법론이다. 이미 몇십년 전에 공식적으로 반복적인 방법론이 나왔기 때문에 새로운 것이 아니다. 스크럼이 하나의 방법론으로 눈에 띄기 위해서는 어떤 매력적인 규칙을 정해야 하는데 그 중에  하나가 2주 주기 개발이다. 기존의 방법론과 차별화가 안되니 2주를 강조했다. 거기에다가 Sprint라고 멋진 이름을 붙였다. 또 Daily Standing Meeting이라는 용어를 만들어 냈다. 앉아서 회의를 하면 기존의 방식과 전혀 다를 것이 없으니까 일어서서해야 한다는 것을 강조했다. 결국 스크럼방법론은 이미 기존의 회사들이 하고 있었던 방법과 별로 다를 것이 없는 것이다. 새로운 것도 아니고 나쁜 것도 아니다. 마케팅의 성공일 뿐이다. 그 덕택에 20년간 인기를 누리면서 혜택을 받은 사람들이 있었다.&lt;br /&gt;&lt;br /&gt;지금도 어떤 프로젝트에서는 폭포수가 적절할 수도 있고 스크럼이 적절할 수도 있다. 그럼 분석이라는 측면에서 보면 어떤 것이 더 적당할까? 완벽을 추구하는 폭포수나 2주일 만의 기능을 명시하는 스크럼이나 필자가 볼때는 대부분의 프로젝트에서는 적절하지 않다. 그럼 무슨 방법론이 적절할까? 방법론을 찾아서 떠도는 순간 영원히 방법론을 찾지 못할 것이다. 왜냐하면 그런 방법론은 없기 때문이다. 마치 나에게 가장 좋은 음식이 무엇일까를 찾는 것과 같다. 좋은 음식이 사람마다 다른 것 같이 프로젝트마다 다르다. 한 회사 안에서도 프로젝트 마다 다르다. 하나의 틀에 억매이지 않고 원칙을 알고 잘 응용하는 것이 중요하다.&lt;br /&gt;&lt;br /&gt;소프트웨어는 외부 고객이건 내부 고객이건 혹은 자기 자신이건 누군가의 요구에 의해서 개발하는 것이다. 이런 고객요구사항이 변하는 것은 소프트웨어 탄생부터 있어 왔던 변하지 않는 현상이다. 이 현상 때문에 폭포수가 잘못되었다고 말할 수는 없다. 그런 환경까지 고려해서 만들어진 것이 폭포수이기 때문이다. 핵심은 고객요구사항이 변하는 상황에서 컨트롤할 수 있어야 한다는 것이다. 그 방법이 한번에 완벽히 작성해서 확인하는 방법일 수도 있고 매일 고객과 물어보면서 작성할 수도 있고 2주일에 한번씩 보여주면서 얘기할 수도 있다.  같은 프로젝트 안에서도 어떤 경우는 매일 의논이 필요하고 어떤 경우는 1달 동안 얘기할 필요가 없는 경우도 있다. 현실에서 벌어지는 모든 프로젝트는 비규칙적이고 반복적인 협의를 필요로 한다. &lt;br /&gt;&lt;br /&gt;결국 모든 방법론의 형식은 항상 변화해 왔지만 그 내용이 중요하다. 어떤 방법론에서도 결국 성공하려면 코딩을 잘 해야 하는 것처럼 설계도 잘 해야하고 분석도 잘 해야 한다.  &quot;잘&quot; 이라는 용어가 &quot;완벽하게&quot;를 의미하지도 않고 &quot;2주일마다&quot;를 의미하지도 않는다. &lt;br /&gt;&lt;br /&gt;드디어 가장 중요한 결론이 나온다. 자연의 불변하는 진리인 열역학 제2의 법칙은 &quot;자연계에서 자발적인 진화방향은 혼란도(엔트로피)가 증가하는 방향으로 진화한다&quot;는 것이다. 즉 열은 뜨거운 곳에서 낮은 곳으로 흐르고 흐르고 반대방향은 일어나지 않는다. 이를 비가역성이라고 한다. 최초에 열을 높은 곳으로 올려 놓는 것은 자연적이 아니라 인위적으로 해야 한다. 폭포수가 가장 안정된 상태이고 주먹구구식이 가장 엔트로피가 높은 상태이다. 자신이 최초에 원하는 수준에 가려면 그 수준을 가진 회사에 가서 배워야 한다. 폭포수를 해 본 사람은 그 아래의 어떤 방법론도 응용해서 할 수가 있다. 할 수 있는 것을 안하는 선택만 하면 된다. 하지만 애자일만 해 본 사람은 폭포수를 절대 할 수가 없다. 해 본 적이 없는 것을 할 수는 없다. 혼란한 곳에서 안정된 곳으로 갈 수 없는 자연의 진리 때문이다.&lt;br /&gt;&lt;br /&gt;모든 규칙을 다 터득한 사람은 모든 규칙에서 벗어나 완전한 자유를 누릴 수 있다. 어려운 육체적인 고통의 수행을 거쳐 진리를 깨달은 사람을 해탈했다고 하는 것이 혼란하지 않은 마음의 안정을 얻었기 때문이다. 엔트로피가 가장 낮은 안정된 상태를 만드는 것은 어려울 수 밖에 없고 그래서 가치가 있다. 엔트로피가 가장 높은 방법론인 애자일을 배웠다면 움직일 수 있는 선택의 폭은 그 보다 다 자유로운 주먹구구식방법 밖에 없다. 물은 절대로 거꾸로 흐리지 않는다. 누가 인위적으로 올려다 주기 전에는 아래로만 갈 수 있다.&lt;br /&gt;&lt;br /&gt;어떤 프로젝트에도 응용할 수 있는 방법론을 배우려면 가장 엔트로피가 낮은 폭포수모델을 배우는 것이다. 이런 방식이 미국의 60여년의 소프트웨어 역사가 지나온 방향이다. 그렇기 때문에 실리콘밸리에는 다양한 엔트로피를 가진 회사들이 다 존재하고 자신이 일했던 회사보다 엔트로피가 높은 프로젝트는 모두 일할 수 있다. 반면에 한국에는 엔트로피가 안정된 회사들이 없다. 내용은 없고 형식만 흉내내는 혼란스러운 회사가 있을 뿐이다. &lt;br /&gt;&lt;br /&gt;소프트웨어 개발을 잘 하기 위해 애자일방법론이 전혀  중요한 것도 아니고 가치도 제한적이라는 것을 이해하는 것이 미래 발전을 위한 첫 걸음이다. 지금 나에게 적절하다고 확신한다면 사용하면 된다. 하지만 맹목적으로 사용하는 것은 파괴적이라고 애자일의 창시자들이 말을 하니 &quot;해봐서 손해 볼 것 없다&quot;는 생각은 금물이다. 엄청난 기회비용을 상실하게 되니 신중하게 결정할 일이다. &lt;br /&gt;&lt;br /&gt;애자일로 인해 역사가 되풀이 된다는 것도 알게 되었고 유행에 민감한 국내 개발 환경이 잘못된 리더들에 의해 핵심을 놓치고 미신에 빠져 국내 소프트웨어 발전에 큰 피해가 올 수 있다는 것은 항상 조심할 일이다.&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/3685153110562518880/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=3685153110562518880' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/3685153110562518880'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/3685153110562518880'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2017/07/8.html' title='분석 #8 애자일은 죽었다'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-5599343571529481425</id><published>2016-07-31T02:28:00.001-07:00</published><updated>2016-07-31T02:36:17.582-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="문화/조직/회사"/><category scheme="http://www.blogger.com/atom/ns#" term="분석/요구사항"/><title type='text'>분석 #7 회사가 문제다 - Monotasker 와 Multitasker</title><content type='html'>&lt;br /&gt;&lt;br /&gt;SW는 인류 역사상 가장 복잡한 지식산업이다. 반대로 말하면 노동산업적인 요소가 가장 적다는 것이다. 지식산업의 특성상 인해전술이나 열정만으로는 성공하기 어렵다는 것이 문제이다. 한국회사의 경영관리체계는 과거의 노동산업적인 요소가 뿌리깊게 내려 있고 이는 한국 소프트웨어 발전의 가장 큰 장애물이다.  &lt;br /&gt;&lt;br /&gt;얼마 전에 삼성전자가 &quot;삼성 소프트웨어 경쟁력 백서&quot; 라는 프로그램에서 자사의 역량을 평가했다. “자사의 SW 개발자 중에서 구글의 SW 개발자 역량을 가진 사람이 1-2% 밖에 안 된다”는 내용과  &quot;30층 짜리 건물을 지어야 하는데 삼성은 지금 초가집 짓는 수준이다.&quot;  라는 놀랄만한 내용이지만 사실이다. 10여년 전에 “대한민국에는 소프트웨어가 없다” 라는 책을 발간했고 지금도 상황이 전혀 변하지 않았다는 필자의 생각과 정확하게 일치한다. 이는 전문성 위주인 미국 SW 회사와 달리 관리 중심인 한국 SW 회사의 필연적인 결과이다. 그런데 이 문제는 증상이 개발자의 역량에서 나타났을 뿐 개발자의 잘못이 아니고 전적으로 회사와 경영진의 책임이다.&lt;br /&gt;&lt;br /&gt;지금까지는 막연하게 SW 선진국과의 형상 비교만으로 근거 없이 한국 SW회사의 관리자나 경영진의 문제점을 지적하고 비판하는 내용이 많았는데 과학적인 근거가 나왔다. 스탠포드 대학에서 연구한 결과인데 다중작업자(Multitasker) 와 단일작업자(Monotasker) 의 차이점에 대한 연구이다. 다중작업자는 여러 가지 일을 동시에 하는 사람을 말하고 단일작업자는 한가지 일을 집중해서 하는 사람을 말한다. 다중작업자들은 자신이 다른 사람들을 인터럽트 하기도 하고 자신도 인터럽트를 당한다. MRI 조사 결과 다중작업자는 다른 일이 끼어들 때마다 흥분과 쾌락의 호르몬인 도파민이 나오고 그 쾌락에 서서히 중독되어 간다는 것이다. 중독이 심해지면서 간섭 받기를 즐기며 또 기다린다. 더 놀라운 결과는 그렇게 중독이 되면 뇌세포가 손상을 입고 IQ가 낮아져 다시는 단일작업자로 다시는 돌아갈 수 없는 불치의 상태가 된다. 결국은 간섭하고 간섭 받는 것을 즐기다 보면 집중력이 필요한 일을 하는 전문 능력은 영원히 없어진다. &lt;br /&gt;&lt;br /&gt;한국회사의 임원이나 관리자는 하루 종일 수 많은 회의와 보고에 시간을 보내는 전형적인 다중작업자들이다. 또 개발자도 경력이 몇 년만 되면 팀장과 같은 관리 업무를 하게 된다. 이는 다중작업자가 되기 시작하는 출발점이다. 어차피 관리자들은 이미 전문 능력이 없어진 다중작업자이기 때문에 다중작업자가 되어도 상관이 없다. 하지만 개발자들은 한 번 관리를 하게 되면 영원히 개발 전문가로 되돌아 오기 힘들다. 도파민과 권력욕의 쾌락에 빠져 회사생활을 즐기며 산다. 여기까지는 문제가 없다. 어차피 관리자도 필요하기 때문이다. 하지만 관리자들의 본연의 업무가 전문가들이 제대로 전문가의 길로 갈 수 있게 환경을 만드는 일이며 다행히도 그런 작업에는 집중력이 필요하지 않다. 하지만 그런 본연의 업무보다는 표면적인 지식으로 전문성 있는 일에 쓸데없는 간섭을 하고 잘못된 결정을 내리는 것이 한국 관리자의 고질적인 문제이며 개발자들의 의욕을 감소시킨다.&lt;br /&gt;&lt;br /&gt;지식산업인 SW 개발은 집중이 필요하다. 특히 초기단계인 분석과 설계 단계는 고도의 집중력을 필요로 한다. 이미 오래 전에 SW 개발자가 가장 많이 보는 블로그를 가지고 있고 마이크로소프트의 엑셀팀장이기도 했던 Joel Spolsky가 자신의 책에서 얘기 했다. 한 번 전화로 인터럽트를 당하면 다시 집중하기까지 30분의 시간이 소요된다고 했다. 모차르트가 음악을 작곡할 때나 작가가 글을 쓸 때  30분 마다 전화가 온다면 일을 제대로 할 수 없다. 바둑에서도 수를 읽고 있는 중에 누가 말을 걸면 처음부터 다시 시작해야 한다. 전체를 보는 일체성이 중요하기 때문이다. 그래서 버클리대의 전산학과 교수가 자기는 프로그래밍을 할 때 휴대폰, 이메일, 메신저 등 모든 통신수단을 다 꺼놓는다고 한다. 학생들에게도 수업시간에 학생들 자신을 위해 휴대폰을 꺼놓으라고 지시한다. 필자도 일주일에 이틀 정도는 아무에게도 간섭 받지 않는 조용한 환경에서 일을 하도록 노력한다. 나의 전문성을 지속적으로 유지할 수 있는 최소한의 귀중한 시간이다. &lt;br /&gt;&lt;br /&gt;반면에 삽질, 망치질과 같은 단순 노동작업 일은 중간에 인터럽트를 당해도 다시 시작하는 데 문제가 없다. 일체성과 연속성이 없기 때문이다. 그래서 개발 중에 인터럽트의 영향이 가장 심각한 부분이 분석이고 그 다음이 설계이다. 가장 영향을 적게 받는 부분이 코딩이다. 코딩 단계는 국지적이고 설계한 결과가 있기 때문에 언제든지 코딩이 중단되어도 다시 시작하는 데 문제가 없다. 이런 얘기를 하면 코딩을 우습게 본다고 반론을 제기하는 국내 개발자들이 많은데 그 이유는 분석과 설계 없이 코딩을 하기 때문이다. 혹은 애자일 방법론을 잘못 이해하고 생각 없이 코딩으로 뛰어들어가는 애자일을 빙자한 무모한 방식이기 때문이다. 애자일의 미신 문화에 대해서는 다음에 자세히 얘기하겠지만 분석, 설계, 그리고 코딩을 동시에 하고 있다면 어려울 수 밖에 없다. &lt;br /&gt;&lt;br /&gt;참고로 필자는 개발 시에 분석과 설계에 비해 코딩 단계에 극히 일부분의 시간만을 소비한다. 이는 1시간 짜리 프로젝트나 1일 프로젝트나 1개월짜리 프로젝트나 같다. 코딩은 거의 타이핑하는 수준이다. 그러니 단순한 오타 외에는 고칠 것도 없다. 코드를 적으면서 설계를 하는 것은 공사를 먼저 시작하고 빌딩 디자인을 하는 것과 같다. 이러한 방식은 개 집 만들 때나 가능한 방식이다. 모차르트가 작곡할 때 악보에 고친 흔적이 없다는 전설적인 얘기도 같은 맥락이다. 분석이 가장 극단적인 지식산업이고 코딩은 가장 노동 산업에 가깝다. 그 중간에 설계단계가 있다. &quot;분석&quot;은 모든 요소를 한번에 다 고려해서 일체성 있게 생각을 해야 하기 어렵다. 머리가 복잡해져서 아파오기 시작해도 중지할 수가 없다. 그만 두면 어차피 처음부터 다시 시작해야 하기 때문이다. 그래서 여러 명이 할 수 도 없다. 여러 명이 나누어서 할 수 있는 일은 노동산업 쪽에 가깝다.&lt;br /&gt;&lt;br /&gt;번잡하게 일하면 열심히 일하는 것처럼 인정을 받는 한국 회사에서는 점점 더 많은 인터럽트가 발생하게 된다.  미국회사에서는 심지어 관리자마저도 자기 시간의 50% 이상 회의를 하고 있으면 도대체 언제 일하냐고 농담의 대상이 되는데 한국은 거의 80 - 90% 를 회의로 보낸다. 대부분이 계획과 분석 없이 정리가 되지 않은 상태에서 다중작업으로 인해 뇌 손상이 되고 기억력이 감퇴되니 묻고 또 묻고 하는 중복적인 보고가 벌어진다. 전문성이 없으니 근무 시간이 고과 평가에서 중요시 될 수 밖에 없다. &quot;넓고 얕은 지식&quot; 으로 무장한 한국의 관리자나 경영진들이 전문성이 없기 때문에 평가도 제대로 하지 못하는 상황에서 필연적인 결과이다. 소프트웨어 용어나 표면 지식으로는 전 세계의 어느 누구한테도 뒤지지 않는 것이 한국의 관리자나 경영진들이다. 용어에 관한 한은 박사 수준이다. 지식으로는 모를 것이 없겠지만 선수나 코치가 될 수 있는 것은 아니다. 그냥 관중 수준일 뿐이다. CTO라는 명함을 가지고 있어도 마찬가지다.&lt;br /&gt;&lt;br /&gt;한국이 자랑하는 인천대교와 영종대교의 핵심 설계를 한국이 하지 못하고 일본의 조다이(長大)라는 업체가 맡았다. 한국의 토목 설계 전문가는 &quot;이 회사의 하마지라는 기술자 한 명이 보유한 경험과 기술이 우리나라 교량 설계업체 전체를 합친 것 이상이라고 해도 과언이 아닐 것&quot;이라고 했다. 이런 고부가가치 전문가는 다중작업자 환경에서는 절대 나올 수 없다. 그래서 페이스북의 창업자인 주커버그가 &quot;개발자 한 명이 백 명보다 가치가 있다&quot;라고 했다.&lt;br /&gt;&lt;br /&gt;한국 회사의 근무환경은 수 많은 회의와 보고로 인해 단일작업자의 환경이 원천적으로 불가능하고 당연히 전문가는 나오기 어렵다. 그래서 한국 회사에서는 40세가 넘으면 연구결과대로 뇌가 손상을 입고 전문성 역량은 없어져 감원 우선순위가 되는 반면에 단일작업자인 실리콘밸리의 SW 개발자는 40세가 넘으면 회사의 핵심 인력이 된다. 회사에서의 감원 대상은 도파민에 중독된 &quot;넓고 얕은 지식&quot;의 다중작업자이다. 그렇게 된 데는 다중작업 환경을 만든 회사의 시스템과 그런 시스템을 만든 경영진이 전적으로 책임을 져야 한다. 실리콘밸리와 같이 백발이 성성한 개발자인 전문가가 존재하고 그들의 의견을 존중하고 전적으로 따르는 관리자들의 문화와는 전혀 다른 한국회사의 문화는 SW와 같은 극단적인 지식산업과는 궁합이 맞지 않는다.&lt;br /&gt;&lt;br /&gt;조용한 환경에서만 생겨날 수 있는 단일작업자만이 진정한 SW 전문가가 될 수 있고 그런 근무환경을 만드는 것이 경영진이 해야 할 일이며 한국 SW 산업이 발전할 수 있는 핵심 필요조건이다. 그러기 위해서는 회사 문화뿐 아니라 분석 능력의 향상 그리고 조용한 개발환경에 필수불가결한 기반 시스템 구축이 우선되어야 한다.&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/5599343571529481425/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=5599343571529481425' title='1개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/5599343571529481425'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/5599343571529481425'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2016/07/monotasker-multitasker.html' title='분석 #7 회사가 문제다 - Monotasker 와 Multitasker'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-4606137117819576156</id><published>2016-06-26T00:30:00.000-07:00</published><updated>2019-03-31T18:43:38.365-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="분석/요구사항"/><title type='text'>분석 #6 왜 삼성개발자의 1-2%만 구글 개발자의 역량에 불과한가?</title><content type='html'>&lt;br /&gt;&lt;br /&gt;요새 삼성전자에서 SW 개발자 역량에 대한 자기 성찰의 기사가 나와서 화제거리가 되었다. 지금쯤이면 다 읽어 보았겠지만 &lt;br /&gt;&lt;br /&gt;&quot;삼성전자 SW 엔지니어는 문제해결 능력에 대한 훈련을 많이 한 것 같지 않다. 지금 당장 문제해결 평가 방식으로 구글 입사를 시도 한다면 1~2%만 제외하고는 어렵지 않을까 생각한다.&quot; 라는 기사이다. &lt;br /&gt;&lt;br /&gt;이는 너무 당연한 결론이며 삼성전자가 아닌 한국 소프트웨어 전체의 현상을 보여주는 것이다. 지금까지는 자아도취에 동키호테식 열정으로 진실을 외면하고 살아왔다면 이제 심각한 상황이 되면서 조금 눈치는 챘다고 볼 수 있다. 이는 개발자 자신들의 책임은 절대 아니다. 대부분은 회사와 경영진의 책임이긴 하지만 개발자들도 조금만 더 현명하게 기득권층과 선동가들에게 현혹되지 않았다면 지금보다는 나아질 수 있었다. &lt;br /&gt;&lt;br /&gt;미국 SW 회사에서는 어려워져서 개발자 감원을 시킬 때 경력이 적은 사람부터 시킨다. 이름하여 오랜 경력자를 지키겠다는 정책으로 &quot;Seniority&quot;라고 한다. 그 이유는 상식적으로 너무 당연하다. 실력이 있기 때문이다. 회사에 오래 있었으니까 충성심을 고려해서 그런다고 생각하면 세상을 너무 모르는 순진한 생각이다. 그런 순수성은 존경할 만 하지만 세상 살아가는 요령은 약하다. CEO의 입장으로 바꾸어 놓고 생각하면 쉽게 이해가 갈 것이다. 어렵게 CEO가 되어서 자기도 실적을 내어야 살아남는데 실력없는 개발자를 단순히 회사에 오래 있었기 때문에 불쌍해서 살려주겠다고 생각할 CEO는 세상에 없다. 여기서 다양한 인사 정책을 논할 수는 없지만 기본적으로 핵심은 실력이다. 그 이외의 모든 인사 정책은 극히 작은 부분을 차지한다.&lt;br /&gt;&lt;br /&gt;상황을 이해하기 쉽도록 인사 정책을 흑백논리로 생각해 보자. 모든 개발자를 40대 이후의 그룹과 40대 이전의 그룹으로 나누어 보자. 회사가 어려워져서 두 그룹 중 한 그룹을 감원시켜야 한다고 가정하자. 미국에서는 당연히 40 이전의 젊은 그룹을 감원시킨다. 40대 이후의 개발자가 다 없어지면 회사는 망한다. 한국 SW 회사에서는 40대 이후를 감원시키는 것이 옳다. 한국에서 40대 이후면 개발자가 아니고 거의 개발자의 탈을 쓴 관리자이다. 그러니 더욱 더 감원해도 문제가 안된다. 상식적으로 그렇고 사실이 그렇다. 그래서 필자가 개발자를 채용할 때도 대기업의 고참 개발자는 조심해서 본다. 개발자도 아닌 직원을 뽑아서는 할 일이 없을 뿐만 아니라 방해만 된다. 실제로 한국 회사에서 대부분의 젊은 개발자들은 위의 관리자나 임원들이 회사에 가치가 있다고 보지 않는다. 그들 만의 국지적인 관점일 수도 있지만 전세계 회사 평가 사이트인 glassdoor.com 에서 외국인들이 내린 평가를 보아도 한국회사들의 임원이나 관리자들에 대한 평가는 최악이다. 무지한 상태에서 엉뚱한 지시만 내린다는 평이다. 또 CEO를 인정하는가를 묻는 &quot;Approve CEO&quot;는 대부분 부정적이다. 이것은 필자의 추측도 아니고 부정할 수 없는 엄연한 사실이다. 전문성보다는 관리위주로 경영할 수 밖에 없는 최고경영진부터 회사가 그렇게 설정되어 있기 때문이다. 어떤 경우는 개발을 해 본 적도 없는 사람이 연구소장이나 CTO라는 직함을 가지고 있기도 하다. 외국에 나가서 어떻게 상대방과 대화를 할 수 있을지 의문이다.&lt;br /&gt;&lt;br /&gt;필자도 지금까지 미국과 한국에서 기술자 경로에 있어 왔지만 미국 회사에서 개발자 경로에 있다보면 자기보다 나은 고수들의 공력을 느끼고 감탄하며 배운다. 반대로 30대가 되면 20대 신입이었을 때가 세상모르고 열정과 자신감으로 보낸 젊음의 시절이고, 40대가 되면 30대를 보고 이제 조금 SW를 알겠구나 하는 생각을 하게 되고, 50대가 되면 40대를 보고 이제 조금만 가이드해주면 일을 믿고 맡길 수가 있겠구나 하는 생각이 든다. 그래도 1,000명이 개발하는 거대한 제품은 백발이 성성한 개발자가 지휘해야 할 것이다. 한국이 자랑하는 인천대교와 영종대교의 핵심 설계를 일본의 조다이(長大)라는 업체가 맡았다. 1968년에 설립된 이래 전 세계적으로 20여개의 대형 교량을 설계한 경험이 있는 회사다. 한 토목 설계 전문가는 &quot;이 회사의 하마지라는 기술자 한 명이 보유한 경험과 기술이 우리나라 교량 설계 업체 전체를 합친 것 이상이라고 해도 과언이 아닐 것&quot;이라고 했다. 이런 기술자를 회사가 어렵다고 감원시키겠는가? 절대 아니다. 이게 바로 백발이 성성한 개발자의 실력에서 나오는 Power인 것이다. 애플 창업자인 스티브 워즈니악, 전 마이크로소프트의 Chief Scientist였던 레이 오지, 하둡의 창시자인 더그 커팅등 기술로는 전세계에서 누구도 따라갈 수 없는 기술자들이다. 다 60대 전후이지만 실리콘밸리에 가보면 이런  사람들이 수도 없이 많다. 그들이 바로 실리콘밸리의 숨은 힘이다. 요새 알파고로 갑자기 유행이 된 인공지능 분야에서도 세계적인 대가인 Geoffrey Hinton, Ray Kurzweil, Yann Lecun도 다 백발이 성성한 상태에서 구글과 페이스북의 인공지능 기술을 이끌어 가고 있다. 관리자가 아니다. 한국의 관료중심과 정치적인 환경에서는 절대 생겨날 수 없는 사람들이다. 조금만 유명해 지면 이런 저런 정부회의나 프로젝트등에 기웃기웃해서는 일단 시간이 모자란다. 기술은 멀어지고 점점 더 정치꾼으로 변해간다. &lt;br /&gt;&lt;br /&gt;실리콘밸리의 기술자들은 서로 많은 기술 정보를 공유하고 협력하면서 실력이 급속히 늘어간다. 백발이 되어가면서 그들의 실력은 임계치를 넘은 폭발력으로 점점 더 가파르게 증가한다. 물론 육체적인 능력은 떨어지지만 종합적인 판단력이나 기술적인 결정은 회사의 운명을 좌우한다. 타이핑하는 속도는 20대를 따라갈 수 없다. 생각하는 시간이 많아지고 타이핑하는 시간이 줄어들기 때문이다. 그에 반해 한국은 조금만 경력이 생기면 팀장이라든가 해서 기술력의 전문성은 떨어지기 시작한다. 바로 죽도 밥도 아닌 Generalist가 탄생하는 순간이며 팀장이나 관리자의 권위를 즐기며 살아가는 것도 잠깐일 뿐 조금만 지나면 생존을 염려해야 한다. 회사가 관리위주의 경영을 하기 위해 개발자를 관리직으로 내몰면서 가치를 감소시켜 놓고 연봉은 높아지고 그러니까 감원의 첫째 대상이 된다. 이렇게 된 원인은 최고경영진부터 임원 등 그 위에 있는  사람들이 역시 비슷한 사람들이기 때문에 그들에게 업무 보고하고 지시 받기 위해서는 상대가 같이 &quot;무지한&quot; 수준이어야 하기 때문이다. 깊이가 없으니 똑같은 얘기를 반복적으로 하기도 하고 답하기도 한다. 그러니 보고가 많아지게 된다. 필자가 누누이 얘기 하지만 보고가 많다는 것은 망가진 회사의 전형적인 증상 중의 하나이다. &lt;br /&gt;&lt;br /&gt;기술자가 일하는 환경은 번잡스러운 회의가 없는 조용하고 집중할 수 있는 환경이어야 한다. 이 점을 또 오해하는 경우가 많은데 고립해서 일하는 것은 절대 아니다. 개발자들이 마음대로 개발하는 환경을 만들어 주었다고 자랑하는 한국 회사들도 있는데 대부분의 그런 회사는 관리위주의 회사보다 더 빨리 망한다. 공유와 협업을 조용하게 할 수 있는 기반 시스템이 마련되어 있지 않은 상태에서는 일인회사에서나 적합한 방식이기 때문이다.&lt;br /&gt;&lt;br /&gt;한국회사의 두가지 문제인 관리위주 혹은 고립된 연구 스타일 모두 글로벌 개발자가 생겨나기에는 열악한 환경이다. 구글로 대변되는 글로벌 회사에서의 &quot;문제해결(Problem Solving) 능력&quot;이라는 것은 한국에서 생각하는 코딩 능력도 아니고, 프로그래밍 언어를 많이 아는 것도 아니고, 프로세스도 아니고, MVC와 같은 Framework를 많이 아는 것도 아니고, 많은 도구를 사용한 경험도 아니고, Agile과 같은 개발방법론을 아는 것도 아니다. 이런 잡다한 기법들이 이력서에 잔뜩 적혀 있는 것이 한국 개발자들의 통상적인 이력서인데 그런 것들은 놀랍게도 미국회사의 인터뷰시에 물어보지도 않는다. 그런 것들은 어차피 수시로 생겨나고 없어지고 하는 것이기 때문에 가치도 없고 신경도 쓰지 않는다. 진정으로 필요한 장기적이고 영속적인 문제해결 능력을 보는 것이다. 한국에서 그토록 맹신하는 Agile 방식도 이미 &quot;Agile is dead&quot; 라고 Agile을 창시한 사람들 조차도 문제점을 지적하면서 죽었다고 선언한다. 그런 것들은 필요에 따라 혹은 유행따라 어차피 순식간에 배워서 사용하다가 생명이 다하면 버리고 하는 것이 개발자의 인생이기 때문에 핵심 가치는 절대 아니다.  &quot;문제해결능력&quot;에는 핵심은 아니지만 그런 것들을 순식간에 배워서 사용할 수 있는 능력이 당연히 포함되어 있다. 어떤 컴퓨터 과목에서는 한 학기에 전혀 모르는 여러가지 언어를 사용해서 숙제를 해야 하는 경우도 많다. 초보때나 기본적인 개념을 배우기 위해 프로그래밍 언어를 한 과목에서 배우지 그 다음에는 하루 이틀안에 배워서 교과 과정을 따라가야 한다. 필자도 Coursera에서 Machine Learning 코스를 들었을때 Matlab 프로그래밍을 처음 접했지만 몇시간 교육 후에 전혀 문제없이 교과 과정을 따라갔다. 물론 경험자보다는 약간 시간이 더 걸리겠지만 그 정도는 역량의 차별화가 되지 않는다. 삽들고 땅파는 능력이 중요한 것이 아닌 지식산업이기 때문이다.&lt;br /&gt;&lt;br /&gt;그럼 그런 국지적인 기법이 실력의 차이가 아니라면 그렇게 글로벌 회사들이 주장하는 &quot;문제해결능력&quot;이란 무엇인가? 여기서 글로 답을 주기는 쉽지 않다. 불가지론이나 형이상학과 같이 차원이 다른 것을 이해하기가 어렵기 때문이다. 모든 사람들에게 쉽게 이해시킬 수 있었다면 한국 소프트웨어가 과거 20년을 이렇게까지 열악한 환경이 되도록 허송세월 하지는 않았을 것이다. 바로 베스트셀러였던 칩 히스의 &quot;지식의 저주&quot; 이다. 먼저 깨달은 사람이 깨닫지 못한 사람에게 설명하는 것은 너무 어렵다는 것이다. 예를 들어 5년전 만 해도 SVN이나 Git와 같은 소스코드관리시스템을 사용하지 않고도 개발하는데 전혀 문제가 없다고 주장하는 개발자들이 많았다. 지금은 개발자들이 거의 깨달았겠지만 소스코드관리시스템 없이 개발한다는 것은 불가능하다. 너무 어처구니 상황이지만 깨닫지 못한 본인들은 전혀 눈치를 못채고 있었을 뿐이다. 그런데 지금도 이슈만 바뀌었지 똑같은 상황이 계속되고 있다.&lt;br /&gt;&lt;br /&gt;&quot;문제해결 능력&quot; 이라는 것은 해결해야 할 문제가 주어졌을 때 종합적으로 여러가지 관점에서 생각하고 또 생각해서 가장 좋고 빠른 방법을 찾아내서 개발하는 것이다. 즉 Top-down으로 생각하는 능력이 기본이다. 이것을 바로 분석역량이라고 한다. 분석을 잘하기 위해서는 수 많은 기법을 동원해서 할 수도 있고 전혀 기법이 없이 수행할 수도 있다. 기법을 몰라서 분석을 못하거나 문제해결을 못하겠다면 그건 Technician이다. 템플릿이나 형식과 같은 기법으로 생각하는 순간 분석은 물 건너 갔다. 시간만 낭비하고 그냥 잘 되어야 숙련공일 뿐이다. &lt;br /&gt;&lt;br /&gt;문제해결 능력을 테스트하는데 프로그래밍 언어 테스트는 당연히 하지 않는다. 사실 프로그래밍은 개발에서 마지막 단계에 위치해 있는 시공 능력이다. 필자는 학교숙제를 비롯해 어떤 개발을 하더라도 코딩 시간을 20% 이상 할애하지 않으려고 한다. 가끔 전혀 모르는 언어를 사용해서 개발하거나 생소한 분야의 개발을 해야 할때는 50% 까지도 코딩 시간이 늘어날 수 있지만 기본적으로 대부분의 시간을 분석, 그 다음에 설계에 시간을 들인다. 이 방법이 가장 빠르고 품질 좋은 제품을 만들어 낼 뿐 아니라 1,000명의 개발자가 같이 개발을 해야 하는 경우에는 필수적이기 떄문이다. 한국에 Agile이 소개되었을 때 Top-Down에 대한 악영향을 걱정했었는데 역시 Top-Down 방식에 대한 반론을 위한 합리화에 많이 사용되고 결국은 한국 소프트웨어 역사에서 좋은 결과를 가져오지는 않았다. 그런 면에서 실리콘밸리에서는 대부분의 개발자들이 용어조차도 모르는 CMMI도 한국에 와서 좋은 점 보다는 나쁜 영향을 주었다. 1% 도 아니고 0.1% 의 회사에서나 필요한 것을 모든 회사에 적용할 수는 없다. 시금치가 건강에 좋다고 온 국민 식단에 시금치를 사용한 것과 다를 바 없다.&lt;br /&gt;&lt;br /&gt;이런 문제해결 능력은 좋은 환경에서 지식을 공유하면서 점점 더 성장하게 되는데 소프트웨어에 관한한 &quot;구경꾼&quot; 수준에 불과한 Generalist 경영진들과 그런 회사에서 성장한 개발자들이 그런 능력을 가지기는 어렵다. 그래서 &quot;1-2% 밖에 없다&quot; 라는 평가가 나오는 것은 너무나 당연한데 필자가 보기에는 현재 상태에서는 1-2%도 발견하기 어렵다. 차라리 문제해결 능력은 관리와 기법위주의 대기업보다는 벤처기업에서 아직 물들지 않은 개발자 중에서 찾기가 더 쉽다. 스스로가 아키텍트이며 고급 개발자라는 것을 증명하려면 Coursera 같은 곳에서 자기가 관심있는 분야의 강좌를 다른 개발자보다 몇 배 빨리 끝낼 수 있어야 한다. 한국 회사에서 &quot;팀장&quot;, &quot;부서장&quot; 등 &quot;장&#39;이라는 직함을 가지고 있는 사람들은 관리자이지 SW 개발자가 아니다. &lt;br /&gt;&lt;br /&gt;소프트웨어 개발자의 최고 능력은 바로 분석능력이며 그게 바로 글로벌 회사에서 가장 중요한 가치인 &#39;문제해결 능력&quot; 이다. 경험하기 전에는 이해하기도 어렵고 교육으로 가르치기는 불가능한 형이상학의 영역이다. 삼성이 고맙게도 자체평가를 통해 공식적으로 이슈를 알게 했으니 이 기회에 깨닫고 실천하는 중요한 계기가 되기를 바란다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/4606137117819576156/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=4606137117819576156' title='1개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/4606137117819576156'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/4606137117819576156'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2016/06/6-1-2.html' title='분석 #6 왜 삼성개발자의 1-2%만 구글 개발자의 역량에 불과한가?'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-7309099783627949400</id><published>2016-05-05T23:26:00.002-07:00</published><updated>2016-05-05T23:27:34.981-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="분석/요구사항"/><category scheme="http://www.blogger.com/atom/ns#" term="소프트웨어공학"/><title type='text'>분석 #5 Coursera에서 소프트웨어 공학 최고의 스승을 만나보자</title><content type='html'>&lt;br /&gt;요즈음 교육 방법으로 매우 편리한 MOOC(Massive Open Online Course) 라는 방식이 있다. 언제 어디서나 원하는 강의를 들을 수 있는 온라인 강좌서비스인데 강좌 자료만 올려 놓는 가장 원시적인 것부터 실제 전세계 최고의 대학 강좌와 거의 비슷하게 체험할 수 있는 것까지 다양한 수준이 있다.&lt;br /&gt;&lt;br /&gt;전세계 MOOC중에서 가장 유명한 사이트가 Coursera (https://www.coursera.org) 이다. Coursera 에서 가장 많이 듣는 강좌가 Stanford 교수인 Andrew Ng의 기계학습(Machine Learning) 코스이다. Andrew Ng 교수는 Coursera의 창시자이기도 하고 인공지능 분야의 대가 중의 한 명인데 얼마 전에 구글에서 바이두로 옮겨 인공지능의 책임자인 Chief Scientist로 있다. 이 강좌는 Stanford 대학원의 정규 코스이기도 하다.&lt;br /&gt;&lt;br /&gt;필자가 수년 전에 Market Segmentation으로 Machine Learning을 했었는데 알파고의 홍보효과로 한국에서는 갑자기 대중에게 유행이 되었지만 이미 전세계에서 미래의 핵심 기술로 자리 잡은지 오래이다. 구글, 페이스북, 마이크로소프트, 애플, 바이두 등 전세계 모든 기업들이 사운을 걸고 엄청나게 투자를 하는 분야이다. 필자가 Stanford에 입학할 당시에는 인공지능의 실현 가능성에 문제가 제기되던 시절이라 전공으로 선택하지는 않았는데 그 후 30년이 흐르면서 많은 변화가 있었다. 특히 Geoffrey Hinton 교수의 획기적인 발견과 GPU 연산능력의 발전으로 과거의 문제들이 해결되면서 이제는 의심의 여지없이 미래 모든 산업의 핵심기술이 되었다.&lt;br /&gt;&lt;br /&gt;필자도 이 기회에 여러가지 목적으로 Andrew Ng 교수의 Machine Learning 강좌를 들었다. 가장 큰 목적은 한국의 개발자들이 이 코스를 들을 때 직면할 문제점을 발견하고 조언을 하기 위해서 였다. 이전에 학생이었을 때 듣던 거의 유사한 교육 방식의 코스이기 때문에 필자는 전혀 거부감이나 당황감 없이 들을 수 있었다. 주중에는 시간이 없으므로 주말에 밤새우다시피 하면서 11주 코스를 6주만에 빨리 끝냈다. 하지만 쉽게 통과하기 쉽지 않은 코스라는 것을 밝혀둔다.&lt;br /&gt;&lt;br /&gt;이 강좌의 가치는 &amp;nbsp;Machine Learning을 배우는 것 이외에도 다음과 같은 3가지 혜택이 있다.&lt;br /&gt;&lt;br /&gt;첫째, 대학 교육방법의 Role Model을 보여준다.&lt;br /&gt;둘째, 실리콘밸리 회사에서 어떻게 일하는 지를 가르쳐 준다.&lt;br /&gt;셋째, 분석이 무엇인지를 몸에서 느끼게 저절로 가르쳐 준다.&lt;br /&gt;&lt;br /&gt;이 강좌를 듣는 방법에는 3가지가 있는데 첫째로 그냥 동영상 강의만 듣는 것이다. 즉 청강이다. Class당 1시간 20분 정도의 동영상 11개 이니까 동영상만 듣는다면 대충 15시간이면 끝난다. 둘째 방식은 가끔 나오는 Quiz를 이해하고 풀면서 듣는 것인데 강좌을 다시 듣고 잘 이해해야 하는 부분이 있으므로 조금 시간이 더 걸린다. 20시간으로 잡자. 거의 모든 개발자가 기초만 있으면 통과할 수 있는 수준이다. 마지막 셋째는 프로그래밍 숙제를 해야 하는 방식이다. 숙제를 모두 끝내야 Course Certificate을 발행해 준다. Certificate만 받지 않으면 모두 무료 강좌이다. 개발자의 수준에 따라 다르겠지만 필자의 경우에는 약 100시간 걸렸다. 시간으로 보면 Quiz까지 푸는 방식과 숙제까지 하는 방식에서 5배의 차이가 난다. 하지만 배우는 역량은 5배가 아니라 10배, 100배의 가치가 있다. 청강이나 Quiz를 푸는 방식으로는 진정으로 개발자가 배워야 하는 것은 전혀 배울 수 없다. 그냥 얉은 표면적인 지식만 임시적으로 쌓일 뿐이다. 즉 골프는 쳐보지도 않고 골프 동영상 강좌만 들은 것과 같다.&lt;br /&gt;&lt;br /&gt;그럼 이 강좌의 Certificate을 받기 위한 과정에서 개발자들에게 어떤 중요한 가르침을 줄 수 있는지 보자. 핵심은 프로그래밍 숙제이다. 프로그래밍 숙제를 모두 통과하지 못한다면 이 코스를 완성했다고 인정할 수 없다. 훈수나 두는 잡다한 지식 수준이다. 그럼 프로그래밍 숙제가 어떻게 나오는 지를 살펴보자. 한국의 대학교수들이 꼭 배워야 할 점이기도 하다.&lt;br /&gt;&lt;br /&gt;첫째, 모든 숙제의 설명이 양적으로 작은 책자처럼 나온다. 그것을 다 읽고 완전히 이해해야 한다. 한 부분이라도 이해하지 못한 상태에서 대충 어떻게 되겠지하고 숙제를 하려고 시작하면 고생은 고생대로 하고 시간이 더 든다. 여기서 개발자가 배워야 할 기본 원칙이 나온다. &quot;무엇을 할 지를 모르면서는 코딩을 시작하지 말라&quot;는 것이다. 백가지 이유를 들면서 일찌감치 코딩에 뛰어드는 한국의 통상적인 개발자는 아무리 얘기해도 실감하기 어려운 것인데 강좌를 들어보고 경험해 보면 백문이 불여일견이라고 이해가 갈 것이다. 즉 &quot;코딩을 일찍 시작하면 개발시간이 더 걸린다&quot; 는 소프트웨어 공학의 #1 원칙을 배울 기회이다. 폭포수모델이니 애자일 방법론과는 전혀 상관이 없는 기본 원칙이니 방법론과 착각하지 말기 바란다.&lt;br /&gt;&lt;br /&gt;숙제가 정의되어 있는 상세함을 보면 무엇을 프로그램해야 하는 지 정확하게 정의되어 있다. 숙제 설명 중에 쓸데 없는 단어도 없고 모든 단어가 필요한 만큼 잘 사용되어 있다. 바로 &quot;완벽한 SRS&quot;인 것이다. SRS의 형식이 중요한 것이 아니라 문제를 정확히 정의하는 것을 확실히 볼 수 있다. 이 숙제 설명 중에 한 부분이라도 이해 없이 넘어가면 꼭 문제가 되고 결국 다시 와서 이해하기 전에는 숙제를 완성할 수 없다. 이런 식으로 매 과목마다 완벽한 SRS를 기반으로 숙제를 하고 교육을 받다 보면 SRS를 어떻게 작성해야 하는 것을 저절로 배우게 된다. 자신이 다른 사람에게 어떤 일을 부탁할 때나 개발 프로젝트 발주를 할 때도 그렇게 적어야 한다는 것이 몸에 배게 되는 것이다. 자신도 모르는 사이에 문제를 정의하는 방법, 즉 &quot;분석&quot; 능력을 배우게 된다.&lt;br /&gt;&lt;br /&gt;문제를 정확히 정의하는 것과 창의성과는 전혀 별개의 문제이고 둘 다 모두 가장 중요한 개발자의 역량이지만 여기서는 창의성을 설명하지는 않는다. 정확히 정의된 문제 안에서 창의성을 발휘하는 것 정도로 알아 두자.. 불행히도 한국에는 이런 수준의 숙제를 디자인하고 만들수 있는 교수가 거의 없다. 학교에서 잘 가르쳐야 한다고 요구해야 정치교수, 관리교수들 처럼 실무 역량을 상실한 교수들에게는 이런 코스 디자인 역량이 있을 수 없고 공허한 메아리만 될 뿐이다.&lt;br /&gt;&lt;br /&gt;또 중요한 것이 숙제를 채점하는 방식이다. 온라인 사이트로 숙제를 프로그램 채점기에 제출하면 즉시 자동으로 채점이 되어 나온다. 채점은 항목별로 Pass/Fail (통과/실패)로 나온다. 모든 항목을 100% Pass 해야만 숙제가 통과된다. 여기서 소프트웨어 개발 프로세스에서 나오는 Acceptance Test Plan(ATP, 인수테스트) 라고 하는 핵심 개념이 나온다. ATP만 통과하면 개발이 완료되고 계약은 종료된다. 발주시 미리 약속한 ATP만 통과하면 발주자가 어떤 트집도 잡을 수 없다. 이런 정교한 ATP가 없는 한국에서는 절대 경험해 볼 수 없는 것이다. 대학의 과목에서도 따라하는 소프트웨어 개발의 기본을 한국의 소프트웨어 업계에서는 한 번도 경험해 본 적이 없다는 것은 슬픈 현실이다. 그러면서 소프트웨어 공학을 논할 자격이 있는지도 의문이다.&lt;br /&gt;&lt;br /&gt;프로그래밍 숙제의 내용에 대해 정확히 정의되어 있고, 채점도 Pass와 Fail이 자동으로 나온다. 무슨 편법을 사용하더라도 채점 프로그램만 통과하면 통과한 것이다. 하지만 하드코딩을 한다거나 편법으로 채점기를 속이는 것은 불가능하게 디자인 되어 있다. 프로그램을 제대로 하지 않는 이상은 절대 채점기를 통과할 수 없게 만들어져 있으니 시간 낭비 하지 말고 처음부터 제대로 하는 것이 현명하다. 여기서 주지할 것은 채점기가 얼마나 정교하게 잘 되어있는지도 중요하지만 더 중요한 것은 숙제 설명과 함께 동시에 채점기가 나온다는 것이다. 이것을 소프트웨어 산업에서 비교하자면 숙제의 정의는 SRS이고 채점기는 ATP (인수테스트)인 것이다. 소프트웨어 공학에서 당연하게 SRS와 ATP(인수 테스트)가 동시에 나오는 기본 원칙을 보여주는 것이다. SRS와 ATP 있어야만 합리적이고 정상적인 개발 계약이 가능하다. 이런 기본적인 프로세스를 한 번도 해 본 적이 없다는 것은 한국 소프트웨어 업계의 실체와 수준을 적나라하게 보여준다.&lt;br /&gt;&lt;br /&gt;한국에서의 프로젝트 발주와 수주의 기본 프로세스인 &quot;RFP (제안 요청서) -&amp;gt; Proposal(제안서) -&amp;gt; 우선협상대상자 계약 -&amp;gt; 개발범위 논의 -&amp;gt; 등등&quot; 의 어디에서 과연 내가 돈을 주고 발주를 하든 돈을 받고 수주계약을 하던 계약 전에 무엇을 개발하는 지와 인수테스트를 정확히 알 수 있는 시점이 없다는 점이다. 무슨 근거로 애초에 이런 개발방식이 생겨났는지는 안타까운 과거의 행위이지만 앞으로 한국 소프트웨어 업계가 넘어가야할 가장 큰 장애물이다. 하여튼 이 잘못된 관행은 프로젝트 규모의 문제가 아니라 기본이 안 되어 있기 때문인 것이다. 규모가 크기 때문에 학교의 과목보다도 더 정확히 하지 않으면 재앙은 더 커진다.&lt;br /&gt;&lt;br /&gt;마지막으로 말하고 싶은 것은 이 과목에서는 Matlab 이라는 프로그래밍 언어를 사용한다. 필자는 이 전에 한 번도 Matlab을 사용해 본 적이 없다. 하지만 배워서 이 숙제를 해야 한다. 강좌에서도 한 30분 정도 가르쳐 준다. 다른 과목에서는 Python으로 숙제를 해야 한다. 이 역시 학생들이 알아서 배워야 한다. 이런 프로그래밍 언어는 학원에서는 가르칠지 모르지만 학교에서 귀중한 학점을 낭비하면서 따로 가르치지는 않는다. 중요한 것은 문제해결 능력이지 프로그래밍 언어의 Syntax가 아니기 때문이다. 이런 Syntax를 가르칠 만큼 한가한 학교라면 그 학교에서는 많은 것을 배우지 못할 것이다. 한국 개발자의 이력서에 빼곡히 적힌 프로그래밍 언어 목록에 대해 필자는 그렇게 가치를 두지 않는다. 실리콘밸리에서 개발자를 뽑을 때도 그랬고 지금도 그렇다. 이런 모든 상황 때문에 한 학기에 프로그래밍이 숙제로 있는 코스를 1개 이상 수강한다는 것은 거의 사생활을 포기한 것이나 다름 없다. 그래서 전산학을 하면서 Full-time 학점인 학기당 12학점 이상을 듣는다는 것도 거의 불가능하다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;이 강좌 하나에 한국의 정부, 학교, 회사, 개발자등 소프트웨어 업계가 배워야 하는 Role Model이 모두 들어 있다. 과연 이런 강좌를 한국에서 언제 보게 될 수 있을 지가 궁금하다. 그 때가 아마 한국의 소프트웨어 업계가 진정으로 소프트웨어를 이해하는 시점이고 글로벌 소프트웨어를 위해 나갈 수 있는 시작점이라고 본다. 그 때까지는 한국의 갈라파고스 섬에서 자화자찬하며 살아갈 것이다.&lt;br /&gt;&lt;br /&gt;미래의 핵심 역량인 Machine Learning을 배우면서 추가로 소프트웨어 공학의 핵심을 저절로 배우는 기회를 위해 필자가 개발자들에게 꼭 추천하는 강좌이다.</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/7309099783627949400/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=7309099783627949400' title='5개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/7309099783627949400'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/7309099783627949400'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2016/05/5-coursera.html' title='분석 #5 Coursera에서 소프트웨어 공학 최고의 스승을 만나보자'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>5</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-8717410771777279954</id><published>2016-02-20T20:26:00.003-08:00</published><updated>2016-02-21T00:08:16.525-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="분석/요구사항"/><title type='text'>분석 #4 잘못된 이름으로 인한 치명적인 착각</title><content type='html'>&lt;h2&gt;&lt;/h2&gt;&lt;div class=&quot;MsoNormalCxSpFirst&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;필자가 미국에 처음 갔을 때 한국교포&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; 2&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;세와 얘기를 하다가&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;잘못보았다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;란 말을 영어로 해야 하는데 도저히 생각이 나지 않아서 영어로 뭐라고 하느냐고 물어보니까 그 교포도 고개를 갸우뚱하더니 똑같은 말이 없다고 한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;즉&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;자동차로 잘못 보았다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;는 말은&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; &quot;I thought it was a car&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;라고 하는 표현으로 대체 된다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;즉 한 언어에서 다른 언어로 직역할 수 없는 것들이 많다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그래서 외국어를 배울 때 분석하지 말고 그냥 외우는게 가장 빨리 배운다는 격언이 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;인간이 어떤 행위를 하면 결과물이 나온다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;분석&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이라는 행위를 하면 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;SRS&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;라는 산출물이 나온다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;행위를 했는데 산출물이 나오지 않으면 다른 사람에게는 행위를 하지 않은 것으로 간주된다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &amp;nbsp;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;미국의 소프트웨어 회사에서 통상적으로&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; SRS &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;라고 하는 것이 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;Software Requirements Specification&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;의 줄인 말이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;한국에서는 당연히 한글로 번역을 한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그런데 이 잘못된 번역 때문에 한국 소프트웨어 업계가 시작부터 잘못된 원인이 되었다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;직역할 수 없는 단어 하나 때문에 소프트웨어 개발에 대한 문화가 갈라파고스 섬으로 가버렸다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;일단 문자를 풀어서 해석하자면 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;Software&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;의&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; Requirements&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;를 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;Specify&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;한 것이라고 할 수 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;당연히&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;Requirements&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;와&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; &quot;Specification&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이 다르다는 것을 의미한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;여기서 언어가 문제가 된다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. Requirement&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;와&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; Specification&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;을 둘 다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;사양&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이라고 번역한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;완전히 다른 것을 이름을 같이 붙여 놓으니 문제가 없을 수가 없다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;이런 번역의 오류가 생기는 예로 특허 문서에 사용하는 용어 중에 영어로는&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; Compise&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;와&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; Consist&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;가 있는데 완전히 다른 의미로 사용된다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그런데 한글로 번역을 하면 둘 다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;구성하다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;라는 똑같은 용어로 해석된다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그래서 한국에서 특허를 내고 나중에 외국에서 특허를 내려고 할 때 문제가 된다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;중국어도 한글로 번역되지 않는 경우가 많이 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;해도 된다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;혹은&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;할 수 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;는 조동사가&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; &quot;neng&quot;, &quot;hui&quot;, &quot;yinggai&quot;, &quot;dei&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;등과 같이 한글로는 다 똑같이 번역되지만 중국어에서는 다르게 사용되는 단어들이 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;한국에서는&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; SRS&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;를 나름대로 추측해서 어떻게 부르는지 몇 개만 나열해 보자&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;요구사항&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;, &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;요구사항 명세서&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;, &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;기능 명세서&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;, &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;고객요구사항&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;등이 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이 모두 완전히 잘못된 번역이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;지금 나열한 문서의 제목은&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; &quot;Requirements&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;에 가깝다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;즉 기능명세서를 적어 놓고&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;SRS&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;를 작성했다고 주장하는 것은 착각이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;요구사항 명세서&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;가&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&amp;nbsp; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그래도 비슷한 편인데 요구사항을 적는 것이라고 생각한다면 잘못된 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;정확하게 말하면 첫째로 요구사항을 적고 그 다음에 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;Specify&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;라는 행위를 하고 나서 그 결과물인 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;Specification &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;문서를 적는 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. Requirements &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;가 있고 나서 그것을 기반으로&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; Specify &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;해야 비롯&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; SRS&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;가 작성되는 것인데&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;Requirements&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;만 적었지 아직&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; Specify&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;하는 행위는 시작하지도 않았다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그런 이유로 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;SRS&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;를 간단히 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;Specification&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;혹은 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;Spec&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이라고 부른다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;그러면 그게 그거지 뭐 이렇게 문서를 많이 적어야 하는 지 짜증이 들지도 모르겠지만 그 것도 착각이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;고객의 요구사항을 가져 오는 것은 개발자의 업무가 아니다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;즉 개발자들이 전문성도 없고 자기 업무도 아닌 엉뚱한 일을 하고 있었던 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;고객의&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;Requirements&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;를 정리하고 가져오는 것은 마케팅부서의 핵심 업무이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;보통 마케팅부서의 업무를 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;4P&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;라고 표현한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. Product, Price, Placement, Promotion &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이라는&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; 4&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;개의 용어가 모두&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; P&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;로 시작하기 때문에 붙여진 이름이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그 중의&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; Product&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이 바로 제품을 정의하는 업무이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;즉&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; Requirements&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;를 작성하는 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;마지막에&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;Promotion&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;홍보&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;인데 한국에서는&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;마케팅&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이라고 하면&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;홍보&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;를 의미할 정도로 완전히 잘못 사용하고 있는 용어이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;미국에서는&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; Promotion&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;을 담당하는 분서는 마케팅부서 중에서&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; &quot;Marketing Communication&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이라고 한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;결국 개발자들이 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;요구사항 명세서&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;라는 것을 작성하는데 자기 일도 아닌 마케팅부서의 일을 하고 있는 것이고 그 것을&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; SRS &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;를 적었다고 착각하는&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; 2&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;가지 오류를 범하고 있는 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;왜 그런 상황이 되었는지는 이유가 있지만 나중에 얘기하기로 하자&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그나마 개발방법론을 조금 안다고 주장하는 사람들이 뭔가를 적지만 아예&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; Requirements&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;도 없이 추상적인 기획이나 비전만 가지고 코딩으로 뛰어드는 용감무쌍한 개발자들도 많이 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;그래도 거대방법론을 도입한 회사&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;(&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;주로 대기업&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;들은 방법론이 요구하는 문서를 보고 적다 보면 그 와중에 형식적으로는&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; Specify &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;라는 행위의 결과물을 적는 흉내를 내게 된다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;하지만 본질을 모르는 상태에서 템플릿에 적는 방식으로는 한계가 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;제대로 충실한 내용이 적힐 수가 없다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;어떤 방법론을 사용해도 마찬가지이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;나중에 설명하겠지만&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;일체성&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;(Integrity)&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이라는 핵심 특성이 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;진정한&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; SRS&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;가 완성되기 위해 꼭 고려되어야 하는 특성이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;도대체 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;SRS&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;가 무엇인지 궁금증을 약간 해소하기 위해 여기서는 매우 간단히&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; SRS&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;에 적어야 하는 대표적이고 핵심적인 일부 항목들만 나열해 보자&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. IEEE&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;에서&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; SRS&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;에 대해 전세계 전문가들이 만들어 놓은 바이블과 같은 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;Template&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;에서 가져온 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;혼란을 피하기 위해 영어를 같이 사용한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 40.0pt; mso-add-space: auto;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- Purpose (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;목적&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 40.0pt; mso-add-space: auto;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- Prodcut Scope (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;범위&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 40.0pt; mso-add-space: auto;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- Product Perspective (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;제품조망&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 40.0pt; mso-add-space: auto;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- Overall System Onfiguration (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;전체 시스템 구성&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 40.0pt; mso-add-space: auto;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- Overall Operation (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;전체 동작방식&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 40.0pt; mso-add-space: auto;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- Product Functions (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;제품주요기능&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 40.0pt; mso-add-space: auto;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- Assumptions and Dependencies (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;가정과 종속관계&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 40.0pt; mso-add-space: auto;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- Apportioning Requirements (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;단계별 요구사항&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 40.0pt; mso-add-space: auto;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- Backwards Compatibility (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;하위호환성&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 40.0pt; mso-add-space: auto;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- Operating Environment (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;운영환경&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 40.0pt; mso-add-space: auto;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- Development Environment (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;개발환경&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 40.0pt; mso-add-space: auto;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- Test Environment (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;테스트 환경&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 40.0pt; mso-add-space: auto;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- Configuration Management (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;형상관리&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 40.0pt; mso-add-space: auto;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- External Interface (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;외부 인터페이스&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 40.0pt; mso-add-space: auto;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- User Interface (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;유저 인터페이스&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 40.0pt; mso-add-space: auto;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- Peformance Requirements (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;성능요구사항&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 40.0pt; mso-add-space: auto;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- Non-functional Requirements (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;비기능요구사항&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 40.0pt; mso-add-space: auto;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- Functional Requirements (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;기능요구사항&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 40.0pt; mso-add-space: auto;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- Change Management Process (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;변경관리 프로세스&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;어떤 방법론을 사용하든 이와 비슷한 용어들은 많이 들어 보게 된다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;모든 방법론이 나온 근원이고 여기에 포장만 입혀 놓은 것이기 때문에 너무 당연하다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이것을 다 작성한다고 생각하면 기겁을 할 수도 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;실리콘밸리나 한국이나 개발자의 성향은 같다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;재미없는 일을 하는 것은 인간이면 다 싫어한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그런데 재미를 모르는 것이지 재미 없는 것은 아니다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;분석을 하고 이런 문서를 적는 것이 코딩보다 더 재미있는 일이라는 것을 인식하게 될 때 바로 훌륭한 개발자가 되었다고 자부해도 된다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이렇게 많은 문서를 다 적는 것이 아니다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그렇게 해왔다면 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;SRS&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;의 본질을 이해하지 못하고 있다는 것을 증명한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. SRS&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;의 본질은 가장 빠르게 개발하는 것이 목적이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그레서 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;SRS&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;가 적히는 방법은 모든 프로젝트가 다 다르다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;학교숙제를 할 때도 이 모든 문서를 일단 다 생각해 본다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;생각하는 시간은&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; 1&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;분이면 충분하다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; 1&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;분 동안 무슨 문서를 얼마나 작성할 것인가를 직감적으로 결정한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;별로 작성할 문서가 많지 않다는 것을 알게 된다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;학교숙제의 경우 이 중에서 한두개만 작성할 수도 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;학교숙제가 아니고 한 달 짜리 프로젝트라고 해 보자&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그러면 어떤 문서를 얼마나 작성할 지를 결정하는데 역시 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;1&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;분 이면 충분하다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;문서&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; 2-3&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;개 쯤 될 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;필자가 일했던&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;General Electiric&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;의 원자력 발전소 소프트웨어를 개발한다고 해 보자&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그러면 모든 문서를 작성해야 한다는 것을&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; 1&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;분 안에 직감으로 결정할 수 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;단 어떤 문서를 얼마나 적어야 할지는 모든 프로젝트마다 다르다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;필자가 해 본 수백개의 프로젝트도 다 달랐다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;즉 어떤 규칙으로서 적용할 수 없는 예술적인 판단이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그래서 소프트웨어가 극단적인 지적산업인 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;주어진 템플릿보고 채워나가는 일을 하고 있다면&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;개발 노동&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;을 하고 있는 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;위에 나열한 것 중에서 전체 작성하는 문서의 양 중에서 어떤 경우는&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; &#39;Functional Requirements&#39;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;가&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; 90%&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;를 차지하기도 하고&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; &quot; User Interface (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;유저 인터페이스&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;가&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; 90%&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;를 차지하기도 하고&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;, External Interface (&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;외부 인터페이스&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;가&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; 90%&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;를 차지하기도 한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그를 조절하는 것 역시 어려운 판단이며 예술의 영역이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;다시 한 번 강조하지만 어렵기 때문에 연봉을 많이 받는 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;템플릿이나 채우고 있는 개발 노동자들에게 높은 연봉을 주는 바보 경영진은 없다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;다시 정리하자면&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; Requirements&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;와&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; Specification&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;은 완전히 다른 영역이며&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; Requirements&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;는 마케팅의 업무이고 개발자의 업무가 아니다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;통상적으로 개발자가 수행해왔는데 비효율적인 것은 말할 것도 없거니와 그것을&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; SRS&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;를 적었다고 착각하는 것도 큰 착각이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;결론적으로 한국에서 벌어지는 거의 모든 프로젝트는&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; SRS&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;가 제대로 적히지 않은 상태에서 개발을 해 왔다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;주먹구구식이거나 혹은 대형 방법론의 경우 형식적으로 적힌 가치가 없는 문서가 대부분이었다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;경험자들은 이런 사실을 잘 알고 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;애자일 방법론은 미국에서는 이미 유행이 지나갔지만 그냥 방법론의 하나일 뿐이지 개발의 원칙을 벗어난 예외가 될 수는 없다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;.&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;또 다른 관점에서 볼 때 가치있는 문서를 적&lt;span style=&quot;font-family: inherit;&quot;&gt;었다면 오래동안 생존해야 한다&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-family: inherit;&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;나중에 보지 않는 문서라면 당연히 가치가 없는 문서이다. SRS는 제품이 단종이 될 때까지 살아남는 문서이다.&amp;nbsp;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;앞으로 진행하면서 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;SRS&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;의 다양한 실체를 보게 되겠지만 소프트웨어 개발에서 가장 정교하고 어려운 행위라는 것을 명심하기 바란다&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span style=&quot;font-family: inherit;&quot;&gt;.&lt;/span&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/8717410771777279954/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=8717410771777279954' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/8717410771777279954'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/8717410771777279954'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2016/02/4.html' title='분석 #4 잘못된 이름으로 인한 치명적인 착각'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-6108215576064720049</id><published>2016-02-13T23:43:00.000-08:00</published><updated>2016-02-13T23:43:56.915-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="분석/요구사항"/><title type='text'>분석 #3 분할 발주의 허구와 진실</title><content type='html'>&lt;div class=&quot;MsoNormalCxSpFirst&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;소프트웨어는 이론적인 개발 단계가 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이론이라고 무시하려고 할지 모르지만 이론이 아닌 실전에서 가장 중요한 개념이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;, &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;단계적인 개발 방식을 외부의 개발사와 계약으로 할 때 분할 발주가 된다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이 용어는 다 이해하겠지만 제대로 &amp;nbsp;따라하지는 않는다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;역량 때문일 수도 있고 의지 때문일 수도 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;여기서는 외주 개발사를 가정하고 분할 발주로 얘기하자&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;하지만 개발단계의 핵심은 동일하다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;먼저 분할 발주의 목적을 알아야 한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;목적도 모르고 무조건 분할 발주를 하겠다는 것은 방향도 모르고 눈 감고 길을 가는 것과 같다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;분할 발주의 목적 중의 하나는 개발 단계를 나누어서 각 단계의 발주를 다른 회사에게도 줄 수 있게 하는 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;분할발주를 하려면 당연히 분할을 해야 한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;잠깐 여기서&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; IEEE&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;의&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; SWEBOK (SW &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;지식체계&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;에서 세계 최고의 실전 전문가 수백명들이 말하는 분할의 첫 단계인 분석의 목적을 몇 개만 나열해 보자&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot; style=&quot;margin-left: 36.0pt; mso-add-space: auto;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;개발에 드는 비용을 정확하게 산정하기 위함이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;정확한 개발 일정을 알고 싶다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;설계를 위한 기초가 된다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;여기서 보면 분할 발주의 목적이나 분석의 목적이 같다는 것을 알 수 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;결국 분할 발주의 목적을 이루기 위해서는 분석을 잘해야 한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;프로세스도 아니고 오직 분석이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;진리는 가까운 곳에 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;반면에 지옥으로 가는 길은 매력적으로 포장되어 있다는 격언이 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;유행따라 멋있어 보이는 프로세스&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;, &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;기법&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;, &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;방법론들이 매력적으로 보이지만 결국은 대부분 사라지고 분석이라는 추상적인 원칙 만이 영원히 살아남는다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;대부분의 새로운 것들은 마케팅 천재들이 만들어 낸 멋진 마케팅 패션용어에 불과했다는 것을 나중에 깨닫게 된다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. Big Data, IOT, Machine Learning&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;등도 갑자기 생겨난 기적이 아니고 과거에 있었던 것들이 환경에 맞게 필요해 진 것 뿐이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;때에 맞추어 &amp;nbsp;새로운 이름을 붙이니 매력적으로 보이는 것 뿐이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;국내에서 늦은 감이 있지만 분할 발주가 중요하다는 것을 깨달았다고 하고 법으로까지 만든다는 것은 나쁘지 않다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;하지만 법으로는 충분하지 않다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;법을 바꾸는 것은 쉽지만 사람들의 마음 속에서 편견을 없애는 것이 훨씬 어렵다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;전세계에서 인종에 대한 차별이 법으로는 거의 다 없어졌다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;하지만 사람들의 마음 속에는 아직도 뿌리 깊은 편견이 남아 있고 행동에서도 나타난다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;법은 한계가 있고 마음속으로 받아 들여야만 진정한 변화가 올 수 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;지금까지는 신도 얼마짜리 인지 알 수 없는 몇백억짜리 계약을 용감하게 해 왔다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그렇게 하는 방식 외에는 본 적이 없으니 그런 방식이 인생인 줄 안다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;마치 처음 알에서 깨어난 오리새끼가 최초에 본 물체가 자기 어미인줄 알고 평생을 따라 다니는 것과 같다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;.&amp;nbsp; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;한국에서 벌어지고 있는 갈라파고스 신드럼 중의 하나이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;필자가 실리콘밸리에 있었을 때 한국회사가 와서 이런 방식으로 미국회사와 계약하고 사업을 하려다 소송 당하고 철수한 적도 있었다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;필자가 아직도 의아하게 생각하는 것은 미국회사가 어떻게 애초부터 그런 계약을 했을가 하는 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;정상적인 미국 회사라면 그런 비상식적인 계약을 했을 리가 없다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;아마도 한국 회사의 브랜드와 파격적인 약속을 믿고 계약했을지 모르지만 결국 두 회사 모두 피해를 입었다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;실리콘밸리에서는 한국처럼 엉터리 계약후 적당히 넘어가는 것은 문화적으로 불가능하다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;게약은 외부 회사와의 계약서만 계약이 아니다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;내부에서 개발 프로젝트를 하겠다고 하는 것도 똑같은 계약이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;내부라고 계약 없이 대충하는 것은 주먹구구식으로 일하는 회사라는 것을 증명한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;혹시나 친구끼리 시작한 신생업체인 경우 개발 계획도 없이 열정으로 열심히 해 볼 수는 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;운이 좋아 한탕은 가능할 지 모르겠지만 지속적인 성장은 불가능하다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;혼자서 열심히 연습해서 세계적인 피아니스트가 되겠다는 것과 다를 바 없다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;그러면 구체적으로 정상적인 경우에 어떻게 계약이 진행되는 지를 살펴보자&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;가장 먼저 확실히 인식해야 할 &amp;nbsp;진리는 개발시작 당시에는 소프트웨어를 개발하는 데 드는 일정과 비용을 신도 모른다는 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;전지전능한 신도 모르니 아는 척 하지 말기 바란다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그러면 결국 단 하나 남은 선택은 얼마를 줄테니까 알아서 개발해 달라는 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그래서 소위 우선협상대상자라는 것을 선정하고 정해진 계약비용안에서 무엇을 해 줄 것인가를 협상한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;아주 그럴듯하게 보이지만 역시 엉터리이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이런 방법 외에 어떤 방법도 없어 보이지만 실리콘밸리에서 계약은 그렇게 진행되지 않는다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;오리새끼처럼 처음부터 잘못된 길에 들어서 한국에 뿌리깊게 자리잡은 잘못된 방법일 뿐이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;그러면 과연 어떻게 진행되는 지 진실을 보자&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;실제 경험 없이는 지금은 이해할 수 없는 미묘한 것들이 있지만 먼저 설명할 수 밖에 없다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. 1&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;인 회사나 글로벌 대기업이나 마찬가지로 소프트웨어 개발은 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;(1) &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;비전&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; -&amp;gt; (2) &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;기획&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; -&amp;gt; (3) &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;분석&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; -&amp;gt; (4) &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;설계&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; -&amp;gt; (5) &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;구현 으로 진행된다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;아니 진행되어야 한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이는 폭포수 이론처럼 들릴지 모르지만 극히 현실적인 방법이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;폭포수에 대한 이해를 잘못하고 있는 사람들이 많지만 실리콘밸리는 그렇게 한가하고 이론적인 곳이 아니다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;실리콘밸리는 경쟁이 극심한 곳이고 가장 현실적인 방법론을 사용하는 곳이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이 중에서 통상적으로 비전은 경영진의 역할이고 기획은 기획부서 혹은 마케팅부서의 업무이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;여기서 첫 단추가 잘못 끼워지면 뒷 부분에서 제대로 되기는 힘들다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;한국에서 필자가 본 기획은 대부분 비전에 가까운 추상적인 문서이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;즉 분석을 수행할 만한 충분한 정보가 없다는 이야기이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;일단 제대로 된 기획이 있다는 가정하에서 진행해 보자&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그러면 개발팀이 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;분석&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;+&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;설계&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;+&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;구현&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;을 해야 한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;외부냐 내부냐에 상관 없이 얼마에 계약을 해야 하는 문제가 생긴다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이게 비로 불가능한 일이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그래서 먼저 계약후 우선협상대상자를 선정해서 개발범위를 얘기해 봐야 역시 무지에서의 토론일 뿐이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;무지에서의 토론이니 어떤 협상도 신빙성이 없다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그것은 절대적으로 잘못된 방법이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;그러면 옳은 방법을 보자&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;개발 일정은 전지전능한 신도 모르지만 희망하는 목표 일정은 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그 목표 일정의&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; 30% &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;정도를 나누어서 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;분석&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;업무에 관한 계약을 한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그러면 다음과 같은 질문이 생긴다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;분석에 대한 계약 금액은 얼마로 할까&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;? &lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;어떤 결과를 원할까&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;? &lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;- &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;분석의 결과물 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;(&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;총칭해서 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;SRS&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;라고 한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;)&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;의 내용과 품질은 어떻게 장담할 수 있을까&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;? &lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;이 문제들은 분할 없이 전체를 계약할 때 생기는 문제와 동일해 보인다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;하지만 큰 차이가 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;해법도 단순하다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이 계약은 결과물을 정하는 것이 아니라 분석에 소비하는 시간에 대한 비용으로 계약을 한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이를 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;Time and Material&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이라고 한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;즉 계약한 시간 동안 일을 하는 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;나중에 얘기할 다른 방식은 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;Turn-key&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;라고 한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;목표 일정이 완전히 엉터리가 아니라면 약&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; 30% &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;정도의 시간을 들여서 분석의 목적은 이룰 수 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. 20%&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;를 하든&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; 30%&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;를 하든&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; 40%&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;를 하든 그 목적을 이룰 수 있게 진행하는 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;목적은 다음 단계인 설계와 구현에 필요한 일정과 비용을 정하기에 충분한 정보를 명시하는 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;제품 개발을 완성하는 것이 아니기 때문에&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; 30%&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이건&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; 40%&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이건 목적에 맞게 분석을 완성할 수 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;분석의 결과는 유연하게 조절이 가능하다는 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;얼마나 자세하게 명시하는 가에 따라 시간을 조절할 수 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;분석가로서의 경험이 있다면 당연히 그 정도는 조정할 줄 알아야 한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;이 분석의 결과물의 논리적인 이름은 총칭해서&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;SRS&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;라고 한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;물리적인 문서 이름은 천차만별이고 회사마다 다르다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;문서의 종류와 갯수도 다르다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;하지만 똑 같은 원칙에 의해서 작성된다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;필자가 몇십년동안 수행했던 크고 작은 수백개의 프로젝트가 똑같은 형식의 결과물이 나온 적은 한번도 없었다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;여기서는 아직 어떤 결과물이 나오는 지 궁금해 할 수는 있지만 나중으로 미룬다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;하여튼 분석이 완료된 이 시점에서는 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;설계&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;+&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;구현&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot; &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;단계에서 해야 할 일이 얼마나 되는지 알 수 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;즉 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;설계&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;+&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;구현&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;을 얼마에 계약을 할 지를 비로서 아는 시점이 온 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;여기에서의 계약은&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;Turn-key &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;게약이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;몇 명의 개발자가 일을 하는 가는 전혀 신경쓰지 않는다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. SRS&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;에 명시된 대로 개발해 주는지 아닌지가 핵심이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이미 개발내용이 명시된 상태에서 하기 때문에 우선협상 같은 것은 당연히 필요 없다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;즉 분할 발주를 한다면 계약은 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;(1) &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;분석&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;과 &lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;(2) &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;설계&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;+&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;구현&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;의 두단계로 나눈다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;또 분석의 중요한 목적의 하나인 이 프로젝트를 계속할 것인다 포기할 것인가도 여기서 결정할 수 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. 30%&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;의 비용을 들여서 분석을 했다고 해도 과감히 매몰비용&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;(Sunken Cost)&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;으로 버리는 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. 30%&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;의 투자가 아까와서 안해야 할 프로젝트에 남은&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; 70%&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;를 투자하는 것은 바보같은 직이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;설계와 구현 단계는 계약에서는 나누지 않는다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;연속성이 훨씬 더 중요하기 때문이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;그리고 설계와 구현의 경계선을 긋는다는 것은 거의 불가능하다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;설계에 참여하지 않은 상태에서 코딩을 할 수 있게 하려면 엄청난 양의 문서가 필요하다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;설계와 구현을 분할하겠다는 생각은 그럴듯해 보이지만 현실과는 거리가 멀고 착각에 불과하다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;단계는 나눌지 모르지만 대부분의 개발자는 연속적으로 투입된다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;설계와 구현을 나누어 계약하는 경우는 필자의 실리콘밸리 경험상 본 적도 없을 뿐더러 가능하다고 해도 엄청난 시간의 낭비이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;설계까지 나간다는 것은 이미 개발을 포기하지는 않는다는 전제를 가지고 있다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;즉 어차피 구현까지 계속 한다는 가정인 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;설계까지 했다면 거의&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; 70%&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;를 진행한 것인데 이제 와서 포기한다는 것은 애초부터 계획이 심각하게 잘못되었다는 것을 의미한다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;여기까지 오다 보면 마치 거대한 프로젝트를 대상으로 얘기하는 것 같지만 이 원칙은 학교숙제할 때도 적용된다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;규모에 상관 없이 가장 빨리 그리고 효율적으로 개발하기 위한 원칙은 동일하다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;단 같은 원칙하에서 프로젝트에 따라 응용법은 달라지며 이 응용역량이 높은 연봉을 받는 진정한 분석 역량인 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;이제 두 단계로 계약을 하는 목적과 그 단계의 경계는 절대적으로&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt; &quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;분석&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&quot;&lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이 끝나는 시점이 되어야 한다는 것을 이해할 수 있을 것이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;이런 진리를 확실히 이해했다면 그 목적에 적합한 역량을 키우는 것이 다음에 해야 할 일이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;. &lt;/span&gt;&lt;span lang=&quot;KO&quot;&gt;분석을 수행하면서도 항상 기억해야 하는 것이 분석의 목적이다&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;.&amp;nbsp;&amp;nbsp;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/6108215576064720049/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=6108215576064720049' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/6108215576064720049'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/6108215576064720049'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2016/02/3.html' title='분석 #3 분할 발주의 허구와 진실'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-7970175439089825385</id><published>2016-01-30T02:22:00.002-08:00</published><updated>2016-01-30T06:37:32.399-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="분석/요구사항"/><title type='text'>분석 #2 개발자가 분석을 잘해야 하는 극히 세속적인 이유</title><content type='html'>&lt;div class=&quot;MsoNormalCxSpFirst&quot;&gt;TV &lt;span lang=&quot;KO&quot;&gt;프로그램 중에 동물농장이라는 프로가 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;외국&lt;/span&gt; TV&lt;span lang=&quot;KO&quot;&gt;에서도&lt;/span&gt; &quot;&lt;span lang=&quot;KO&quot;&gt;위험한 구출&lt;/span&gt;(&quot;Dangerous Resque&quot;)&lt;span lang=&quot;KO&quot;&gt;라는 프로그램을 방영한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;위험에 닥친 동물을 구조하려는 것인데 구조에 협조하는 동물은 보지 못했다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;도망가려고 기를 쓰고 심지어는 구출대원을 공격하기도 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;자신을 위한 일인데도 이해를 하지 못하니 그럴 수 밖에 없다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;인간도 그렇게 다르지 않다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;소크라테스가&lt;/span&gt; &quot;&lt;span lang=&quot;KO&quot;&gt;유일한 악은 무지이다&lt;/span&gt;&quot; (The only evil is ignorance)&lt;span lang=&quot;KO&quot;&gt;라는 말을 했고 아인슈타인도&lt;/span&gt; &quot;&lt;span lang=&quot;KO&quot;&gt;너 자신의 무지를 과소평가하지 말라&lt;/span&gt;&quot;&lt;span lang=&quot;KO&quot;&gt;고 했다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;소크라테스가 살던&lt;/span&gt; 2500&lt;span lang=&quot;KO&quot;&gt;년 전이나 지금이나 인간은 무지에 관한한 개선되지 않았다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;찬란한 과학문명의 발전에 비하면 생각하는 방식은 진화하지 않았다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;과학의 발전에 상관 없이 무지와의 싸움은 영원히 끝나지 않을 것이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;언젠가는 지구를 떠나 우주로 날아가서 살 정도로 과학이 발전하겠지만 그렇다고 인간의 생각이 바뀌기는 어려울 것이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;무지가 좋은 점은 현명한 자는 무지에서 벗어나 다른 사람들과 차별화할 수 있는 기회가 있다는 것이다&lt;/span&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;어떤 행동을 유도하기 위해 이론적이나 추상적으로 좋은 이유를 말하기 보다는 현실적으로 왜 분석이 중요할 까 하는 얘기를 세속적으로 돈과 관련해서 해 보려고 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;가치를 돈과 연결하는 것이 세속적이기는 하지만 인간의 속성상 설득하기에 가장 좋은 방법이 아닐까 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;사실 필자가 국내에서 가치를 가질 수 있었던 것도 세속적인 차이점을 부각시킬 수 있었기 때문이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;분석을 이해하기도 전에 먼저 왜 중요한지 그리고 왜 해야하는 지에 대해 동기를 부여해 보도록 한다&lt;/span&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;소프트웨어의 모든 용어는 건축에서 시작되었다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;설계라는 말을 가장 쉽게 이해할 수 있는 분야가 건축이다&lt;/span&gt;.&amp;nbsp; &lt;span lang=&quot;KO&quot;&gt;건물을 건축하려면 두 단계가 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;설계와 시공이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그런데 건축과 소프트웨어와는 용어가 약간 다르다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;건축은 두 단계가 있지만 소프트웨어에서 말하는 설계는 시공 쪽에 가깝다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;즉 소프트웨어에서는 분석&lt;/span&gt;, &lt;span lang=&quot;KO&quot;&gt;설계&lt;/span&gt;, &lt;span lang=&quot;KO&quot;&gt;구현의&lt;/span&gt; 3 &lt;span lang=&quot;KO&quot;&gt;단계가 있다&lt;/span&gt;. &amp;nbsp;&lt;span lang=&quot;KO&quot;&gt;소프트웨어의 분석은 건축에서의 설계와 같고 설계와 구현을 합쳐서 건축에서의 시공과 비슷하다&lt;/span&gt;. &amp;nbsp;&lt;span lang=&quot;KO&quot;&gt;이 점이 이상스럽게 생각될지 모르지만&lt;/span&gt; 2&lt;span lang=&quot;KO&quot;&gt;단계와&lt;/span&gt; 3&lt;span lang=&quot;KO&quot;&gt;단계를 매핑하려니 그렇게 보는 것이 가장 가깝다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;나중에 그 이유를 잘 알 게 될 것이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;소프트웨어에서 규모에 따라 비효율성을 피하기 위해 한 단계를 없애고 두 단계로 축소한다면 &lt;/span&gt;&quot;&lt;span lang=&quot;KO&quot;&gt;분석&lt;/span&gt;&quot;&lt;span lang=&quot;KO&quot;&gt;과&lt;/span&gt; &quot;&lt;span lang=&quot;KO&quot;&gt;구현&lt;/span&gt;&quot; &lt;span lang=&quot;KO&quot;&gt;이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;지금은 추상적인 단계이니 현실적으로 분석이 왜 중요한가는 이해하기가 어렵다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;세속적으로 돌아와서 건축에서 설계를 담당하는 설계가와 시공하는 인부중 누가 더 임금을 많이 받겠는가&lt;/span&gt;? &lt;span lang=&quot;KO&quot;&gt;나의 가치를 올리자면 &amp;nbsp;다른 사람들과 차별화된 기술을 가져야지만 임금을 많이 줄 것이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;이것은 세상의 진리이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;차별화된 가치가 없으면 누구도 돈을 많이 주지 않는다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;차별화된 가치를 가지고 있으면 누군가가 그 가치에 해당하는 비용을 지불하고 사용할 것이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;반대의 입장이 되어서 생각해 보면 너무 당연하다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;손자병법에서도 나를 알고 적을 알아야 한다고 했다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;소프트웨어 개발자의 임금을 올려야 한다고 근거 없이 주장할 것이 아니라 내가 다른 사람이 인정하는 그만한 가치를 가지고 있으면 저절로 올라간다&lt;/span&gt;. &amp;nbsp;&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;공사장의 인부가&lt;/span&gt; 30&lt;span lang=&quot;KO&quot;&gt;년 경험이 있으니까 임금을 많이 달라고 해야 한계가 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;노동 산업이기 때문에 육체적으로 절정에 있고 숙련된 기술이 있을 때 가장 가치가 높다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;아마&lt;/span&gt; 30&lt;span lang=&quot;KO&quot;&gt;대가 전성기일 가능성이 많다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;바로 소프트웨어에서 코딩이 그렇다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;물론 코딩도 수준이 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;하지만 그건 숙련도이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;구글에서 나이 많은 나이 많은&lt;/span&gt; 50,60&lt;span lang=&quot;KO&quot;&gt;대의 개발자가 밤도 못 세우는데 왜 임금을 많이 받으면서 일을 할 수 있을까를 생각해 보아야 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;바로 건축에서의 설계이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;설계시에는 시공은 시작도 하지 않았다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;시공은 나중에 누가 하든 할 사람이 많다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;새벽시장의 인부도 얼마든지 구할 수 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;소프트웨어 개발자로서 새벽시장의 인부가 되기를 원하는 사람은 없을 것이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그런데 새벽 인부시장에서 구출하는 방법을 가르쳐 주어도 절대 나오려고 하지 않는다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;인부들에게 설계를 할 줄 알아야 한다고 말해야 현실적이 아니다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;오랜시간이 걸리고 지금와서 공부를 시작할 수도 없고 너무 어렵다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그렇게 때문에 조금이라도 일찍 인부가 아닌 설계가가 되도록 노력해야 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;옷을 만들 때도 디자이너가 디자인을 하고 수공작업은 중국과 같이 값싼 인부를 사용한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;소프트웨어라고 다르다고 생각하면 거대한 착각이며 스스로의 가치를 결정짓는 데 엄청난 잘못을 하게 된다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;일단은 소프트웨어나 하드웨어나 옷 만드는 것이나 다 같다라는 관점에서 생각해야 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;다른 점은 나중에 발견하도록 한다&lt;/span&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;여기서 요새 유행하는 애자일 방법론으로 시공을 미화하고 합리화하지 않기 바란다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;애자일을 잘못 해석하여 영원히 인부의 길로 확실히 자리매김하는 불행한 경우를 많이 보았다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;모짜르트는 곡을 쓸 때 머리로 작곡하고 실제 종이에 적는 것은 순식간에 했다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;생각없이 처음부터 종이에 적어야 좋은 곡이 나올 수 없다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;다른 산업에서의 설계는 소프트웨어에서의 분석단계와 같으니 여기서부터는 분석이라는 용어를 사용할 때 다른 산업에서의 설계를 연상하면 된다&lt;/span&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;분석해서 나온 결과를 다른 사람에게 보여 줄수 있어야 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;모든 지식산업에서는 머리로 생각을 해야 하고 생각의 결과가 기록되는 문서가 있어야 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;생각만 하고 문서를 적지 않고 공사를 해야 한다면 생각의 가치가 없이 또 인부로 전락하고 많다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;역시 임금을 많이 받을 수 없다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;보여줄 수 없으면 사기꾼이나 다름 없다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;모짜르트가 생각만 하고 악보를 적지 않았자면 무슨 가치가 있는가&lt;/span&gt;?&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;소프트웨어 개발자로서의 가치를 높이고 임금을 많이 받으려면 그에 해당하는 기술을 가져야 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그것이 코딩은 아니다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그렇다면 분석이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;현실에서는 분석의 결과가 너무 다양한 상태로 나타나기 때문에 운이 좋아 분석의 결과물을 본 적이 있다고 해도 별 것 아닌 것 같이 보이기도 하고 언제든지 따라할 수 있을 것 같지만 착각이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;손자병법이&lt;/span&gt; A4 &lt;span lang=&quot;KO&quot;&gt;용지에 가득 적으면 두 장 밖에 안되는&lt;/span&gt; 6&lt;span lang=&quot;KO&quot;&gt;천여자에 불과 하지만 어떻게 응용하는 가에 따라 손자병법이 될 수도 있고 그냥 평범한 글자의 집합이 될 수도 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;대부분의 사람들에게는 후자가 될 것이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;추상적인 것에서 원칙을 지키면서 현실에서 응용하는 것이 가장 어렵다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;천재라면 혼자서 그 원리를 파악할 수도 있지만 배우는 것이 효율적이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;춘추전국시대 때 &lt;/span&gt;6&lt;span lang=&quot;KO&quot;&gt;천자에 불과한 손자병법만을 보고 손자를 오나라의 대장군에 임명한 오나라 왕 합려도 대단한 통찰력을 가진 사람이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;천재는 천재를 알아보는 것이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그 후에 모든 사람이 손자 병법을 읽었지만 읽은 장군이나 안 읽은 장군이나 적군인 초나라는&lt;/span&gt; 3&lt;span lang=&quot;KO&quot;&gt;배나 많은 군사를 가지고도 모든 전쟁에서 다 패했다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;손자가 병졸들 같이 칼을 잘 쓴 것은 아니다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;병졸보다 칼 싸움은 못하지만 대장군으로서 인정받아 부귀와 영화를 누리면서 살았다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;병졸들이 칼 싸움을 아무리 잘한다고 한들 한계가 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;숙련된 인부도 인부의 한계를 벗어나지 못한다&lt;/span&gt;. &amp;nbsp;&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;내가 개발자로서 차별화 할 수 있는 가치가 무엇인지를 상식적으로 생각해 보아야 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;수 많은 인부 중의 한 사람으로 살겠다면 그건 너무 쉽다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;옆에 있는 수 많은 개발자들이 하는 것과 똑같이 하면 된다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그러면 모든 개발자는 똑 같은 대우를 받을 것이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;자신은 머리가 좋다고 생각할지 모르지만 인부세계에서 조금 기술이 더 좋다고 해서 숙련공으로 인정받을 뿐이지 &lt;/span&gt;10&lt;span lang=&quot;KO&quot;&gt;배&lt;/span&gt;, 100&lt;span lang=&quot;KO&quot;&gt;배의 가치가 생기지는 않는다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그 사람이 없더라도 더 싼 숙련공을 여러명 투입해도 된다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;손자는 여러 명의 병졸로 대체할 수 있는 사람이 아니다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그렇기 때문에 가치가 있는 것이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;어렵지 않으면 차별화 하기 어려운 인부에 불과하다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;보기에 쉬워 보인다면 다른 사람도 마찬가지이고 &amp;nbsp;차별화 할 수 있는 가치는 아닌 것이 분명하다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;일단 어려워야 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그리고 역설적으로 왜 그런 식으로 시작해야 하는지 이해가 되지 않아야 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;모든 사람이 쉽게 설득되어서 시작하게 된다면 또 가치가 작아진다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;오나라와 합려와 손자를 추천한 오자서 두 사람만이 손자병법을 이해했다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그 후에도 다른 사람들은 대부분 손자를 시기하고 방해했다&lt;/span&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;자신의 가치를 극대화 해서 돈을 많이 받기 위해서는 세 단계가 어려워야 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;먼저 왜 해야하는 지를 이해하기가 어려워야 하고&lt;/span&gt;, &lt;span lang=&quot;KO&quot;&gt;이해했다고 하더라도 원칙을 잘 이해해야 하고&lt;/span&gt;, &lt;span lang=&quot;KO&quot;&gt;그랬다고 해도 실전에 응용하기가 어려워야 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그래야만 최고의 가치가 있는 것이고 쉽게 할 수 있다고 한다면 이론적인 방법론에 불과하거나 착각일 뿐이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;실리콘밸리는 회사에서 그런 환경을 만들어 주어 자신도 모르는 사이에 그런 기술을 쌓아간다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그러면서 오랜 경험과 함께 어렵게 습득한 가치로 인해 실리콘밸리의 백발이 성성한 개발자들이 많은 임금을 받으면서 회사에서 중요한 사람으로 인정을 받으며 절대 감원시키지 않은 안전한 직업으로 미국에서 가장 인기 있는 직종으로 꼽히는 것이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;코딩만 열심히 해서는 차별화가 불가능하고 그런 대접을 절대 받을 수 없다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;무엇인가로 차별화를 해야 하는데 그것은 분석 밖에 없다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;분석을 잘하기 위해 첫 단계가 먼저 설계를 잘하는 것이라는 개념만 알려주고 나중에 현실에서 벌어지는 분석과 설계의 미묘하고 애매모호한 경계에 대해서 자세히 설명하겠다&lt;/span&gt;.&amp;nbsp;&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/7970175439089825385/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=7970175439089825385' title='1개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/7970175439089825385'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/7970175439089825385'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2016/01/blog-post_30.html' title='분석 #2 개발자가 분석을 잘해야 하는 극히 세속적인 이유'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-1318761108376900300</id><published>2016-01-24T03:19:00.003-08:00</published><updated>2016-01-24T03:19:59.388-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="분석/요구사항"/><title type='text'>분석  #1  소프트웨어의 분석의 본질은 무엇인가?</title><content type='html'>&lt;div class=&quot;MsoNormalCxSpFirst&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpFirst&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;이 포스트는 필자가 이제 시작하려는 실전 소프트웨어&lt;/span&gt;&quot;&lt;span lang=&quot;KO&quot;&gt;분석&lt;/span&gt;&quot; &lt;span lang=&quot;KO&quot;&gt;시리즈의 첫 번째 포스트이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;이전에 포스트한&lt;/span&gt; SWEBOK&lt;span lang=&quot;KO&quot;&gt;의 분석단계에 대한 번역을 하면서 소개를 했지만 이 시리즈에서는 현실에 더 가깝고 실리콘밸리에서의 경험을 바탕으로 실무에서 도움이 될 자세한 내용을 적으려고 한다&lt;/span&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;소프트웨어는 인류역사상 가장 복잡한 지식산업이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;지식산업의 특징은 한 사람이 여러 사람을 모은 것 보다도 뛰어날 수 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;페이스북의 주커버그가 개발자&lt;/span&gt; 1&lt;span lang=&quot;KO&quot;&gt;명이&lt;/span&gt; 100&lt;span lang=&quot;KO&quot;&gt;명보다 더 뛰어날 수 있다고 했다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;바둑이나 체스와 같은 지식 활동에서도 상급자 한 명이 하급자&lt;/span&gt; 100&lt;span lang=&quot;KO&quot;&gt;명이 합한 것을 이길 수 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;이런 지적차이가 없이 백명을 합해서 한명을 이길 수 있다면 노동산업일 것이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그럼 소프트웨어의 어떤 부분이 이렇게 큰 차이를 만들어 낼까를 항상 염두에 두면서 지적인 생각을 많이 해야 하는 단계가 언제일까 하는 답을 스스로 찾기 바란다&lt;/span&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpLast&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;소프트웨어를 개발할 때 분석&lt;/span&gt;, &lt;span lang=&quot;KO&quot;&gt;설계&lt;/span&gt;, &lt;span lang=&quot;KO&quot;&gt;구현 단계가 있다는 것은 누구나 다 들어 보았을 것이다&lt;/span&gt;.. &lt;span lang=&quot;KO&quot;&gt;그런데 현실에서 제대로 행하기는 쉽지 않다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;분석이라는 단어가 너무 추상적이기 때문이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;분석을 항상 하면서도 자기는 분석을 안한다고 생각하는 실리콘밸리의 개발자도 있고 분석이 무엇인지도 모르면서 자기는 분석 잘한다고 하는 국내의&lt;/span&gt;&amp;nbsp; &lt;span lang=&quot;KO&quot;&gt;개발자도 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;마치 야구선수에게 만류인력법칙을 아냐고 물어보면 모른다고 할 것이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;하지만 공이 떨어지는 궤도를 가장 잘 파악해서 잡아내는 것을 보면 만류인력을 몸으로 잘 실행하고 있는 것이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;실행면에서 는 물리학교수보다 더 잘한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;증기기관차를 발명한 사람들도 열역학이 생기기도 전에 발명했다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그 만큼 분석이라는 단어는 극히 추상적인데다 이론과 현실의 착각에서 부터 모든 사람들이 다르게 해석하고 평가할 수 있는 위험한 단어이기도 하다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;각자 생각하는 분석의 정확한 정의가 다를 수 밖에 없지만 여기서는 실리콘밸리에서 행하는 통상적인 분석을 가정하고 진행한다&lt;/span&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;분석을 제대로 하지 않고도 지금까지 소프트웨어 개발자로서 개발하는 데 지장이 없다면 분석이 꼭 필요한 것인가&lt;/span&gt;? &lt;span lang=&quot;KO&quot;&gt;이는 내가 인생을 살아가는데 있어서 학교는 꼭 가야하는가&lt;/span&gt;? &lt;span lang=&quot;KO&quot;&gt;라는 질문과 비슷하다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;학교를 가지 않아도 생존하는 데는 문제가 없었고 가끔 크게 성공하기도 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;결국은 필수냐 아니냐의 문제가 아니고 선택의 문제라고 할 수도 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그런데 경쟁을 해야 한다면 얘기가 다르다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;취미생활이라면 적당히 해도 되고 잘하든 안하든 문제가 없지만 다른 사람과 경쟁을 해서 이겨야 한다면 최선의 방법을 택해야 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;필요하다 아니다의 문제가 아니고 경쟁에서는 최선의 방법이 필수가 된다&lt;/span&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;소프트웨어를 개발한다는 것은 지적산업이라는 점에서 자동차를 만드는 것이나 그림을 그리는 것과 같다&lt;/span&gt;.&lt;span lang=&quot;KO&quot;&gt;하는데 그렇다면 개발하는데 지식산업다운 모습을 가져야 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그림을 그리기 전에 스케치를 해야 한다거나 자동차를 만들기 전에 설계를 해야 한다거나 심지어는 옷을 만들기 위해서도 디자인을 해야 한다면 아무도 이의를 제기하지 않는다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;너무 당연하기 때문이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그런데 소프트웨어에서 분석을 해야 한다고 하면 안하기 위해 핑계를 대며 노력하는 것이 국내의 현실이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;억지로 시켜야 할 수 없이 대충 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;물론 제대로 잘 하고 있는 가는 나중에 얘기할 또 다른 큰 이슈이기 때문에 여기서는 넘어간다&lt;/span&gt;. TV&lt;span lang=&quot;KO&quot;&gt;를 보다보면 동물농장이라는 프로에서 가끔 위험에 처한 동물을 구조하려는 경우가 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그런데 동물들이 자신을 위한 것인데도 순순히 구조를 받아들이는 것이 아니라 구조를 당하지 않으려고 갖은 발악을 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;이 경우와 비슷하다&lt;/span&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;폭포수방법론이니 애자일 방법론이니등 방법론과 분석의 필요성을 연관지어서 생각하는 것은 원칙과 방법론을 혼동해서이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;폭포수나 애자일 벙법론이 좋다 나쁘다 할 수 있는 것은 아니다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;잘못 해석하면 해악을 끼칠 수가 있다&lt;/span&gt;. &amp;nbsp;&lt;span lang=&quot;KO&quot;&gt;애자일 경우에는 분석을 하지 않아도 된다는 착각을 심어주기 딱 좋은 사상을 가지고 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;마크 트웨인의 말처럼 건강에 관한 책은 오타로 인해 죽을 수도 있다는 말처럼 착각을 불러 일으켜 해를 끼치기 좋게 되어 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;분석의 본질을 이해하기 위해서는 당분간 방법론에 대한 생각을 하지 않는 것이 좋다&lt;/span&gt;. &quot;Unteach&quot; &lt;span lang=&quot;KO&quot;&gt;라고 생각을 비워보자&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;어렵지만 방법론을 배웠더라도 잠시 안 배운 것처럼 머리에서 지우도록 하자&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;구글에서도 분석작업을 하지 않고 설계부터 하는 경우도 많다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;많다기 보다는 겉으로 그렇게 보인다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;필자도 이전에 그랬었다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그래서 겉으로 보기에 분석작업을 하지 않는다고 생각한다면&lt;/span&gt;&amp;nbsp; &lt;span lang=&quot;KO&quot;&gt;착각이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;하기는 하되 경우에 따라 방법이 다른 것이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;지금까지 필자가 평생동안 수 백번의 프로젝트를 해 왔지만 똑같은 정형화돤 기법으로 분석을 하는 경우는 없었다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;즉 어떤 샘플이나 템플릿을 보고 작성할 수 는 없다는 것이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;원칙을 이해해야 하기 때문에 추상적이고 혼란이 생긴다&lt;/span&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;분석의 본질은 무엇인가를 실행하기 전에 전체적으로 생각해 보는 것이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;방법은 그 다음 문제이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;학교숙제와 같이 한번만 하고 끝날 프로젝트는 굳이 분석에 많은 투자를 하지 않아도 규모가 작기 때문에 큰 피해가 없다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;구동만 되면 된다는 사상이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;하지만 피해는 크지 않지만 비효율적인 것은 사실이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;필자는 학교숙제를 비롯헤 간단한 문제를 풀 때로 분석을 하고 설계를 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;형식은 때에 따라 다르다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;하지만 아무리 간단해도 분석을 해야 더 빠르다는 것을 몸으로 알고 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;국내 개발은 대부분 한탕주의 식으로 진행한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;미래에 대한 고려를 할 필요가 없는 &lt;/span&gt;&quot;&lt;span lang=&quot;KO&quot;&gt;이번만 끝내면 된다&lt;/span&gt;&quot;&lt;span lang=&quot;KO&quot;&gt;는 환경에서는 당연할 수도 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;이 세상 모든 일에는 좋은 점과 나쁜 점이 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;외국 속담에 어떤 남자가 마음에 드는 예쁜 여자와 결혼을 하고 싶은데 그 여자와 결혼을 하려면 추한 쌍동이 자매를 같이 데려가야 한다는 조건이 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;국내에서 문화적으로 성행하게 된 한탕주의 개발이 좋은 점은 다음 차세대 프로젝트를 금방 다시 할 수 있기 때문이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;개발자들의 수요가 더 많이 필요하고 돈이 잘 도니 경제가 잘 돌아간다고 미화할 수 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그러나 그런 모순적인 방법은 곧 냉혹하고 무서운 현실에 부딪치게 된다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;바로 국제 경쟁력이다&lt;/span&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;국내 경쟁력은 별 문제가 없다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;잘못한다고 해도 회사가 개발비용이 조금 많이 들고 품질이 나빠서 고객이 떨어져 나갈 것이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;하지만 경쟁자도 그렇다면 큰 문제가 아니다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;도토리 키재기이기 때문이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그렇지만 치명적인 한계가 온다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그 한계는 바로 글로벌 경쟁애서 뒤떨어지는 것이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그러다 보면 소프트웨어 산업이 황폐화 되고 장기적으로 개발자나 회사나 국가나 모두 피해를 입는다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;그 이유도 모르니 문제를 엉뚱한 데서 찾고 많은 노력을 기울여도 한계가 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;지적산업의 특성을 모르기 때문이다&lt;/span&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;구글 같은 글로벌 기업에 가 보면 젊은 개발자나 &lt;/span&gt;5,60&lt;span lang=&quot;KO&quot;&gt;대의 나이 많은 개발자가 똑같이 많다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;감원을 시킬때는&lt;/span&gt; Seniority &lt;span lang=&quot;KO&quot;&gt;라는 방식으로 젊은 사람부터 내보내는 것이 통상적이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;젊은 사람들은 다시 구할 수 있지만 경력자는 다시 구하기가 어렵고 회사에서 리더가 없어지는 것이기 때문에 타격이 크다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;경력이 많을 수록 전체를 보는 통찰력이 있고 오랜 경험으로 시행착오를 줄인다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;젊은 병졸이 힘이 좋을 지는 모르지만 전쟁을 수행할 수는 없다&lt;/span&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;백발이 성성할 때 까지 오래 일하고 연봉이 높아지려면 코딩을 줄이고 전체를 보는 지적인 분석과 설계를 해야 한다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;코딩하는 인력은 나이가 들면 젊은 개발자들에게 떨어질 수 밖에 없다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;믿기 싫더라도 인간의 신체가 그렇게 되어 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;젊었을 때 잘 할 수 있는 것이 있고 나이가 들어 잘 할 수 있는 것이 있다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;젊은 사람의 기술만으로는 그 가치가 오래 가지 않는다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;지적으로 성숙해 지고 전체를 볼 수 있는 역량이 바로 백발 개발자의 가치이다&lt;/span&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;분석을 &lt;/span&gt;&quot;&lt;span lang=&quot;KO&quot;&gt;요구사항 분석&lt;/span&gt;&quot;&lt;span lang=&quot;KO&quot;&gt;등과 같은 단편적인 용어로 표현하면&lt;/span&gt; 100% &lt;span lang=&quot;KO&quot;&gt;잘못된 상상을 하게 된다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;분석은 절대로 남을 따라하거나 어떤 것을 흉내 내서 되는 것이 아니다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;대충해서도 안된다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;바둑을 대충 두면서 이기기를 바란다면 망상이다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;목적에 따라 적절한 수준으로 해야 중요한 가치가 있다&lt;/span&gt;. &quot;&lt;span lang=&quot;KO&quot;&gt;적절히&lt;/span&gt;&quot;&lt;span lang=&quot;KO&quot;&gt;와&lt;/span&gt;&quot;&lt;span lang=&quot;KO&quot;&gt;적당히&lt;/span&gt;&quot;&lt;span lang=&quot;KO&quot;&gt;는 다르다&lt;/span&gt;. &quot;&lt;span lang=&quot;KO&quot;&gt;적절히&lt;/span&gt;&quot;&lt;span lang=&quot;KO&quot;&gt;는 현실을 고려한 유연성을 의미하지만 &lt;/span&gt;&quot;&lt;span lang=&quot;KO&quot;&gt;적당히&lt;/span&gt;&quot;&lt;span lang=&quot;KO&quot;&gt;는 소프트웨어에서 만병의 근원이다&lt;/span&gt;. &quot;&lt;span lang=&quot;KO&quot;&gt;행동하기 전에 충분히 생각하고 적어서 정확히 표현해라&lt;/span&gt;.&quot; &lt;span lang=&quot;KO&quot;&gt;하는 것이 지금의 추상적인 수준에서 분석의 본질에 대해 말할 수 있는 표현이다&lt;/span&gt;.&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;여기서는 지식산업의 핵심과 소프트웨어에서의 어떤 부분이 지식산업의 핵심일까 하는 것을 생각해 보는 기회로 하자&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;앞으로의 포스트에서는 여러 관점에서 구체적으로 들어가 보자&lt;/span&gt;.&amp;nbsp;&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoListParagraph&quot;&gt;&lt;br /&gt;&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/1318761108376900300/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=1318761108376900300' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/1318761108376900300'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/1318761108376900300'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2016/01/1.html' title='분석  #1  소프트웨어의 분석의 본질은 무엇인가?'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-2204726851557494867</id><published>2016-01-24T02:16:00.001-08:00</published><updated>2016-01-24T02:18:05.600-08:00</updated><title type='text'></title><content type='html'>&lt;br /&gt;&lt;br /&gt;구독하고 계신 독자들께 감사드립니다.&lt;br /&gt;&lt;br /&gt;&lt;span lang=&quot;KO&quot;&gt;지금까지 블로그 호스팅을 개인적으로 하다가 관리의 시간을 줄이고 블로그 기사를 쓸 수 있는 시간을 조금이라도 더 가지기 위해 구글&lt;/span&gt; Blogger&lt;span lang=&quot;KO&quot;&gt;로 옮겼습니다&lt;/span&gt;. &lt;span lang=&quot;KO&quot;&gt;모양도 변경되고 기능이 조금 다른 점이 있으나 앞으로 가면서 정리하고 또 자주 포스팅하려고 합니다&lt;/span&gt;.&lt;br /&gt;&lt;div class=&quot;MsoNormalCxSpFirst&quot;&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;span lang=&quot;KO&quot;&gt;당분간은 소프트웨어 개발에서 가장 중요하고 국내 소프트웨어 역량 중에서 가장 취약한&lt;/span&gt; &quot;&lt;span lang=&quot;KO&quot;&gt;분석&lt;/span&gt;&quot;&lt;span lang=&quot;KO&quot;&gt;에 대한 기사를 계속하려고 합니다&lt;/span&gt;.&lt;o:p&gt;&lt;/o:p&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;MsoNormalCxSpMiddle&quot;&gt;&lt;br /&gt;&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/2204726851557494867/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=2204726851557494867' title='1개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/2204726851557494867'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/2204726851557494867'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2016/01/blog-post.html' title=''/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-7835132248135384839</id><published>2015-07-26T07:00:00.000-07:00</published><updated>2015-11-28T23:55:05.504-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="SWEBOK(소프트웨어 지식체계)"/><category scheme="http://www.blogger.com/atom/ns#" term="소프트웨어공학"/><category scheme="http://www.blogger.com/atom/ns#" term="프로세스"/><title type='text'>SWEBOK - SW 프로세스 #3 프로세스 관리</title><content type='html'>SWEBOK 해설 SW Process #3 프로세스 관리 - 2015-07-26&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(*** 필자주석) 이번 번역을 시작하기 전에 회사에서의 상황에 대해 한마디.&lt;br /&gt;회사에서 프로세스를 정의하고 구체적으로 프로세스를 따라서 일을 하기 위해서는 &quot;프로세스 다이어그램&quot; 이라는 것을 만들게 된다. 프로세스를 관리하기 위해서는 핵심적인 문서이다. 프로세스 다이어그램은 벤처회사인 경우 10 페이지 일 수도 있고 대기업인 경우 수천 페이지 일 수도 있다. 그 만큼 회사에 따라 프로세스의 숫자와 상세도가 다양하지만 수십 명의 개발자가 일하는 회사에서 프로세스 다이어그램 하나 없이 개발을 하고 있는 경우는 아직은 프로세스의 중요성과 필요성을 인식하지 못하는 상태라고 할 수 있다. 천재라고 하더라도 프로세스 다이어그램이 필요 없다고 생각하는 것은 총 잘 쏘는 병사가 전쟁을 수행하겠다는 것과 비슷하다. 회사에서 회계관리를 머리로 하는 것과 비슷하다. 새 직원이 들어왔을 때 가르쳐 주기도 어렵다. 프로세스라는 용어에 대해 과거의 잘못된 경험에서 온 거부감을 고집하기 보다는 모든 사람이 체계적이고 편안하게 일하는 기본 규칙이라고 생각하기 바란다. 물론 더 위험한 것은 이론가들이 만들어 놓은 과도한 프로세스이다. 소크라테스가 말한 &#39;무지한 사람이 하는 행위는 절대 선이 될 수 없다 (The only evil is ignorance)&quot;가 잘 적용되는 경우이다. 소프트웨어 공학이라는 용어자체가 &quot;현실&quot; 이라는 의미를 가지고 있듯이 본질적으로 이론가들이 가이드 하기에는 매우 위험한 분야이다. &lt;/div&gt;&lt;br /&gt;&lt;br /&gt;8장 Software Engineering Process (소프트웨어 공학 프로세스)&lt;br /&gt;1. 소프트웨어 프로세스 정의 ( 이전 포스트)&lt;br /&gt;1.1 소프트웨어 프로세스 관리 (Software Process Management)&lt;br /&gt;&lt;br /&gt;소프트웨어 프로세스 관리의 2가지 목적은 프로세스를 새로 도입할 때나 개선을 하려고 할 때 효율성(Efficiency)과 효과(Effectiveness)를 높이기 위한 것이다. 프로세스는 개인, 프로젝트, 조직 수준에서 벌어지는 모든 프로세스를 포함한다. &lt;br /&gt;&lt;br /&gt;통상적으로 제품을 개발하는 있어서 효율성과 효과를 증가시킨다는 기대에서 프로세스를 도입하거나 개선을 하게 된다. 최종 목표는 개발비용, 개발일정, 제품품질을 향상시키는 것이다. 그를 위한 프로세스의 도입, 조직의 변경, 그리고 인프라구조의 변경(새로운 기술 도입이나 도구의 변경 등)은 모두 밀접하게 연관되어 있다. 프로세스 변경은 소프트웨어의 제품뿐 아니라 조직의 변경도 유발한다. 프로세스 변경은 전 조직에 파급효과(Ripple Effect)를 가져온다. 예를 들면 IT의 도구나 기술의 변경은 대부분 프로세스의 변경을 요구한다.&lt;br /&gt;&lt;br /&gt;일부 과정에서 신규 프로세스가 도입될 때 다른 기존 프로세스가 변경될 지도 모른다. 예를 들면 개발과정에 새로운 검사 프로세스를 도입하면 테스트 프로세스가 변경될 가능성이 높다. 이런 현상을 &quot;프로세스 진화(Process Evolution)&quot;라고 한다. 이런 진화가 대규모인 경우에는 조직의 문화와 비지니스 모델도 프로세스의 변화를 수용할 수 있도록 같이 변화해야 한다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(*** 필자주석) 회사의 변화는 의도적인 프로세스의 변화로 일어나기도 하지만 어떤 도구를 도입할 때도 일어난다. 예를 들어 빌드 도구, 정적분석기, SVN이나 Git와 같은 소스코드관리도구의 변경 등으로 항상 벌어진다. 그럴 때 가장 많이 하는 실수가 단순한 도구의 도입으로만 생각하는 것이다. 도구의 도입은 항상 크고 작은 프로세스의 변경으로 이어진다. 그럴 때 기존 프로세스를 처음부터 끝까지 검토해보는 것이 중요하다. 이런 경우를 위해 체계적으로 작성된 프로세스 다이어그램과 같은 문서가 필수적으로 필요하다.&lt;br /&gt;&lt;br /&gt;프로세스의 변화는 많은 비용을 초래하게 된다. 실리콘밸리와 같이 오랜 공력이 쌓인 회사에서 조차 변화는 위험하기 때문에 조심해서 수행해야 한다. 현실적으로 대규모의 급진적인 변화는 거의 없고(또 그럴 필요성도 거의 없다) 대부분은 조그만 변경을 간헐적으로 한다. 그런 조그만 변화에도 개발자들의 준법정신이 성공에 큰 역할을 차지한다. 프로세스는 모든 사람이 규칙을 따를 때 효과가 있는 것인데 독불장군이 있다면 프로세스가 제대로 정착하기는 어렵다. 특히 프로세스는 형식적인 면과 내용적인 면이 있는데 형식적인 면에서는 억지로 따라 할 지 모르지만 내용적인 면은 강제화하기도 어렵고 평가하기도 어려운 부분이다. 예를 들어 동료 검토 같은 것이 그렇다. 하는 흉내는 낼지 모르지만 시간 낭비하는 경우가 많다. 그래서 내용을 충실하게 만들 수 있는 역량이 없다면 준비된 다음에 하는 것이 좋다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;121 소프트웨어 프로세스 인프라구조 (Software Process Infrastructure)&lt;br /&gt;&lt;br /&gt;소프트웨어 프로세스의 도입, 구현, 관리는 각 단위 프로젝트에서 시작한다. 그렇지만 프로세스는 모든 조직에서 같이 일사분란 하게 도입할 때 조직의 모든 소프트웨어에 혜택을 줄 수 있다. 소프트웨어 프로세스 인프라구조(Software Process Infrastructure)는 프로세스의 정의, 프로세스의 해석, 프로세스의 정책, 그리고 프로세스를 적용하기 위한 절차를 제공한다. 더 나아가서는 투자비용, 도구, 교육, 프로세스 도입과 유지보수에 필요한 인력을 제공한다.&lt;br /&gt;&lt;br /&gt;소프트웨어 프로세스 인프라구조는 프로젝트의 규모와 조직의 규모에 따라 다르다. 소규모의 간단한 조직과 프로젝트는 간단한 프로세스 인프라구조가 필요하다. 반대로 크고 복잡한 규모의 조직과 프로젝트는 크고 복잡한 프로세스 인프라구조가 필요하다. 큰 규모의 경우에는 프로세스의 구현과정이나 개선활동을 가이드하는 소프트웨어공학 그룹이나 운영 위원회 같은 조직이 만들어 질 수도 있다. &lt;br /&gt;&lt;br /&gt;가장 흔하게 벌어지는 잘못된 착각은 소프트웨어 프로세스의 도입이 소프트웨어 프로젝트에 추가적인 시간과 비용을 더한다는 생각이다. 당연히 프로세스의 도입과 개선에 들어가는 비용이 있다. 하지만 조직적인 프로세스의 개선이 높은 생산성, 비용절감, 재작업의 감소, 품질 좋은 제품의 혜택이 있다는 것을 경험이 보여주었다. 프로세스의 성능이 소프트웨어 제품의 품질에 영향을 미친다고 볼 수 있다. &lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(*** 필자주석) 간단하면 간단한 프로세스, 복잡하면 복잡한 프로세스가 필요하다는 너무 당연한 얘기이지만 실제로 따라 하기는 힘들다. 간단하다고 아예 안 하는 경우도 많고 큰 규모를 한 번에 하려는 경우도 많다. 변화에는 Big bang(한번에)과 Phased Approach(단계별)가 있는데 프로세스에도 Big bang이 좋은 경우도 있고 Phased Approach가 좋은 경우도 있다. 예를 들어 이슈관리시스템은 형식으로는 Big bang으로 도입하지만 내용은 Phased Approach로 서서히 향상시켜 가야 한다. 내용과 같이 경험이 쌓여야지만 제대로 수행될 수 있는 것을 Big Bang으로 수행하는 것은 불가능하다. 도구는 한 번에 준비를 해 주지만 사용은 천천히 해야 현실적이다. 골프를 하루에 다 배우겠다는 것과 같다. 단 골프채는 시작할 때 사 주어야 한다.&lt;br /&gt;&lt;br /&gt;또 얼마나 간단한가를 판단하는 것이 중요하다. 필자가 가장 많이 본 실수는 원칙을 알고 적용하는 대신에 자신이 하고 있는 잘못된 관행을 진리로 알고 프로세스로 옮기는 것이다. 원칙을 정확히 아는 것이 중요하다.  프로세스가 다른 개발방법론이 100개가 넘게 있지만 모두 원칙은 동일하다는 것을 깨닫기 바란다. 어느 날 갑자기 획기적인 방법론을 발견했다고 도입해서 사용한다면 성공할 확률은 없다. 그런 금방망이는 존재하지 않는다. 건강식품 판매자 들의 과대선전으로 생각하면 된다. 건강식품과 같이 판단 실수와 오류를 건전한 시행착오로 미화하면 안 된다. 어떤 시행착오는 성장에 꼭 필요한 경험이기도 하지만 어떤 시행착오는 조직과 자신을 회복이 불가능한 파멸로 이끄는 경우도 있다. 모든 배움이 그렇지만 소프트웨어에서도 훌륭한 스승의 역할이 그래서 중요하다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;다음 포스트의 순서는 다음과 같다.&lt;br /&gt;2. 소프트웨어 생명주기 (SW Life Cycles)&lt;br /&gt;2.1 소프트웨어 프로세스의 분류 (Categories)&lt;br /&gt;2.2 소프트웨어 생명주기 모델 (Life Cycle Models)&lt;br /&gt;2.3 소프트웨어 프로세스 적용 (Adaptation)&lt;br /&gt;2.4 현실적인 고려 (Practical Considerations)&lt;br /&gt;&lt;br /&gt;3. 소프트웨어 프로세스 평가와 개선( SW Process Assessment and Improvement)&lt;br /&gt;3.1 소프트웨어 프로세스 평가 모델 (Assessment Models)&lt;br /&gt;3.2 소프트웨어 프로세스 평가 방법 (Assessment Method)&lt;br /&gt;3.3 소프트웨어 프로세스 개선 모델 (Improvement Models)&lt;br /&gt;3.4 연속적, 단계적 소프트웨어 프로세스 등급 (Continuous and Staged SW Process Ratings)&lt;br /&gt;&lt;br /&gt;4. 소프트웨어 측정 (SW Measurement)&lt;br /&gt;4.1 소프트웨어 프로세스와 제품 측정 (Process and Product Measurement)&lt;br /&gt;4.2 평가결과의 품질 (Quality of Measurement Results)&lt;br /&gt;4.3 소프트웨어 정보 모델 (SW Information Models)&lt;br /&gt;4.4 소프트웨어 프로세스 측정 기술 (Measurement Techniques)&lt;br /&gt;&lt;br /&gt;5 소프트웨어 공학 프로세스 도구들 (SW Engineering Process Tools)</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/7835132248135384839/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=7835132248135384839' title='2개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/7835132248135384839'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/7835132248135384839'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2015/07/swebok-sw-3.html' title='SWEBOK - SW 프로세스 #3 프로세스 관리'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-3926390220267211637</id><published>2015-07-12T12:32:00.000-07:00</published><updated>2015-11-28T23:58:32.901-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="SWEBOK(소프트웨어 지식체계)"/><category scheme="http://www.blogger.com/atom/ns#" term="소프트웨어 공학"/><category scheme="http://www.blogger.com/atom/ns#" term="프로세스"/><title type='text'>SWEBOK - SW 프로세스 #2 정의</title><content type='html'>8장 Software Engineering Process (소프트웨어 공학 프로세스)&lt;br /&gt;&lt;br /&gt;1. 소프트웨어 프로세스 정의&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(*** 필자주석) 프로세스의 정의는 매우 중요한 주제이다. 잘못 이해함으로써 소프트웨어 회사에 막대한 피해를 끼칠 수 있다. 실제 국내 소프트웨어 회사에서 많은 비용과 시간을 낭비하는 것을 보아 왔다. 프로세스라는 용어는 매우 추상적인 단어이다. 이 정의는 아무리 잘 한다고 해도 역시 추상적이다. 결과적으로 모든 사람이 &quot;프로세스&quot; 라는 용어를 다르게 해석한다. 혹은 다르게 느낀다. 각자 자신이 경험한 범위 내에서만 이해가 가능하다. 경험하지 않은 것을 정확하게 이해할 수 있는 최고의 통찰력은 극히 소수의 사람만이 가지고 있는 역량이다. 여기 SWEBOK에서도 정확한 정의를 주기 위해 많은 노력을 한 흔적이 보인다. 하지만 글자가 현실을 설명할 수 있는 한계가 있다. 필자는 많은 개발 경험으로 프로세스라는 용어에 대한 거부감도 전혀 없고 1인 회사를 해도 프로세스를 적용한다. 반면에 잘못된 프로세스를 경험한 대부분의 국내 개발자들은 프로세스 혹은 더 나아가 소프트웨어 공학에 대한 느낌이 부정적으로 되었다. 이런 감정을 바꾸기에는 많은 시간이 필요할 것이다.&lt;br /&gt;&lt;br /&gt;국내 대부분의 개발자들은 자수성가하거나 이론가들로부터 프로세스를 이론적으로 접하게 된다. 미국회사가 프로세스가 잘되어 있거나 소프트웨어 공학에서 중요하다고 하는 등 이런 저런 단편적인 사실을 잘못 이해하고 결과적으로 잘못된 프로세스를 경험하게 된다. 여기서 조심해야 할 것은 옳은 프로세스도 없지만 틀린 프로세스도 없다. 잘못된 프로세스는 잘못 적용된 프로세스이다. 즉 아무리 잘 만들어진 미국 국방부의 프로세스라고 해도 대부분의 회사에게는 나쁜 프로세스이다. 필자는 실리콘밸리의 2개 회사에서 거대한 프로세스를 경험했다. 그 프로세스가 그 회사들에는 적합하다고 생각하지만 나는 그런 회사에서 일하기를 선호하지는 않는다. 다행히도 실리콘밸리의 99% 회사와 국내 회사들은 그런 거대한 프로세스를 따라 할 필요가 없다. 그런데 이론적으로 접근하다 보면 자연적으로 거대한 프로세스가 만들어지기 쉽다. 그 것이 가장 그럴듯하게 보이기 때문이다. 그래서 필자가 말하기를 한국 소프트웨어에 독약으로 작용할 수 있는 것이 바로 프로세스이다. 적당히 사용한다는 것도 가장 추상적인 단어이기 때문에 구체적인 케이스는 불가능하다. 이런 경험의 영역이야 말로 진정한 소프트웨어 공학의 영역이며 건강식품과 같이 사기꾼들이 성행하는 분야이라는 것을 항상 주지하여야 한다.&lt;br /&gt;&lt;/div&gt;&lt;br /&gt;이 주제는  소프트웨어 프로세스, 소프트웨어 프로세스 관리와 소프트웨어 프로세스 기반시스템과 관련되어 있다.&lt;br /&gt;&lt;br /&gt;소프트웨어 프로세스는 입력되는 산출물을 다른 출력되는 산출물로 변형시키는 일련의 행위와 업무이다. 최소한도의 경우에도 필수 입력물, 변화시키는 행위, 생성되는 산출물이 있다. 약간 복잡해 지면 entry와  exit criteria, 그리고 행위(Activity)를 잘게 쪼갠 task 로 나눈다. Task는 관리의 대상이 되는 가장 작은 단위이다. 프로세스는 Event에 의해서 시작될 수도 있고 다른 프로세스의 Output이 이 프로세스의 Input이 될 수도 있다. 프로세스가 시작하기 위해서는 초기 전제조건(Input Criteria)이 만족되어야 한다. Output 산출물의 완수조건을 포함한 모든 조건이 만족되어야지만 프로세스가 완료되었다고 말할 수 있다. &lt;br /&gt;&lt;br /&gt;프로세스는 하위프로세스(Sub-Process)를 포함하기도 한다. 예를 들면 Requirement Validation(검증)은 소프트웨어 개발을 시작하기 위해 충분한 정보가 있는지를 검증하는 프로세스인데 이는 Requirement Analysis의 하위 프로세스이다. Requirement Validation 프로세스의 Input은 Software Requirement Specification(SRS) 와 validation을 수행하기 위한 인력과 시간, Validation을 위해 사용할 도구이다. Requirement Validation 활동은 SRS의 검토, 프로토타이핑, 모델 검증 등을 포함할 수 있다. 이런 활동은 개인이나 팀 같이 행위의 주체에게 업무가 할당될 것이다. Validation 프로세스의 Output은 검증된 SRS이며 이런 SRS는 다음 프로세스인 설계와 테스트 단계에 사용된다.&lt;br /&gt;&lt;br /&gt;(*** 필자주석) 마지막 문장 중에 눈치 채기는 어렵지만 매우 중요한 내용이 들어 있다. &quot;검증된 SRS가 설계와 테스트 단계에 사용된다&quot; 라는 말에서 보면 테스트 단계가 설계단계와 함께 진행된다는 것을 인식해야 한다. 나중에 테스트 chapter에서 부가적으로 설명하겠지만 V-Model에서 보면 가장 위쪽에 SRS와 같은 수준에 Acceptance Test Plan이 위치해 있다. 결론만 간단히 얘기하자면 SRS (1page건 1000page이건 어떤 형태가 되었던 상관없다)가 있으면 테스트계획과 테스트 케이스를 만들 수 있어야 한다. SRS가 부실하면 필연적으로 테스트도 부실해 진다. 여기서 인과의 법칙에 예외를 적용하는 실수를 하지 않기 바란다.&lt;br /&gt;&lt;br /&gt;Requirement Analysis의 하위프로세스인 Requirement Validation이나 다른 하위 프로세스들은 흔히 겹치기도 하고 반복되기도 한다. 즉 하위 프로세스들은 입구와 출구를 드나들면서 몇 번 씩 되풀이 되기도 한다. &lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(*** 필자주석) 이 한 문장이 바로 Iterative 개발 방법론 또는 Agile 개발방법론과 같은 의미를 얘기한다. 실리콘밸리의 99%의 프로젝트는 Water Fall 방법론을 사용하지 않는다. 즉 완벽하게 SRS를 적고 한 번의 프로세스 만에 개발하려는 환상적인 생각은 용과 같이 거의 전설 속에서만 존재하는 것이다. 그런 면에서 혹시라도 미국 소프트웨어 회사는 거대한 프로세스를 사용하고 있다는 근거 없는 착각은 하지 말기 바란다. 가장 실용적인 방법으로 개발하고 있는 실리콘밸리가 상식적으로 Water Fall 방법론을 사용할 리가 없다. 실리콘밸리가 Agile 방법을 가장 잘하고 있는 것이다. 또 관련 주제가 나왔을 때 자세히 설명하겠지만 빨리 개발하겠다고 Agile 방법론이라는 이름으로 엉터리로 개발하는 것을 합리화하지 말기 바란다. &quot;프로세스&quot; 와 마찬가지로 &quot;Agile 방법론&quot;, &quot;Lean 개발&quot;도 매우 조심해야 적용해야 할 단어이다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;소프트웨어 프로세스를 더 자세히 부연해서 설명하자면 IT 지원조직의 유무, 소프트웨어공학 기법과 도구, 업무 환경, 프로세스 수행의 효율성을 측정하기 위한 평가지수(KPI) 등과 같이 보조 역할과 역량까지도 포함된다. 더 나아가 여기저기 기술적 역량이 필요하기도 하고 다른 부서와 협력해야 하기도 하고 관리하기 위한 활동도 포함될 수 있다. 표기법은 자연어 텍스트의 형태로 설명한 활동들의 목록, Data Flow Diagram, State Charts, BPMN, IDEF0, Petri nets and UML activity 다이어그램 등으로 표현된다.&lt;br /&gt;&lt;br /&gt;프로세스내의 변환(Transforming) 업무는 Checklist와 같이 순서적으로 정의된 Procedure의 집합으로 정의된다. &lt;br /&gt;&lt;br /&gt;항상 강조해야 할 점은 &quot;가장 좋은 프로세스&quot;는 없다는 것이다. 소프트웨어 프로세스는 선택되어야 하고 조정되어야 하고 각 프로젝트와 조직의 목적에 맞게 적절히 응용되어야 한다. 이상적인 프로세스는 존재하지 않는다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(*** 필자주석) 추상적이긴 하지만 위에서 열심히 정의해 놓고 여기 와서 이상적인 프로세스는 없고 적절히 사용해야 한다는 말을 한다. 결국 따라 해야 할 수 있는 구체적인 방법은 얘기하지 못한다. 그게 현실이고 본질이다. 결국 경험한 만큼만 이해한다는  지식의 저주와 비슷하다. &lt;/div&gt;&lt;br /&gt;&lt;br /&gt;다음 포스트에서는 아래 1.1.과 1.2.를 적는다.&lt;br /&gt;&lt;br /&gt;1.1 소프트웨어 프로세스 관리 (Management)&lt;br /&gt;1.2 소프트웨어 프로세스 구조 (Infrastructure)&lt;br /&gt;&lt;br /&gt;2. 소프트웨어 생명주기 (SW Life Cycles)&lt;br /&gt;2.1 소프트웨어 프로세스의 분류 (Categories)&lt;br /&gt;2.2 소프트웨어 생명주기 모델 (Life Cycle Models)&lt;br /&gt;2.3 소프트웨어 프로세스 적용 (Adaptation)&lt;br /&gt;2.4 현실적인 고려 (Practical Considerations)&lt;br /&gt;&lt;br /&gt;3. 소프트웨어 프로세스 평가와 개선( SW Process Assessment and Improvement)&lt;br /&gt;3.1 소프트웨어 프로세스 평가 모델 (Assessment Models)&lt;br /&gt;3.2 소프트웨어 프로세스 평가 방법 (Assessment Method)&lt;br /&gt;3.3 소프트웨어 프로세스 개선 모델 (Improvement Models)&lt;br /&gt;3.4 연속적, 단계적 소프트웨어 프로세스 등급 (Continuous and Staged SW Process Ratings)&lt;br /&gt;&lt;br /&gt;4. 소프트웨어 측정 (SW Measurement)&lt;br /&gt;4.1 소프트웨어 프로세스와 제품 측정 (Process and Product Measurement)&lt;br /&gt;4.2 평가결과의 품질 (Quality of Measurement Results)&lt;br /&gt;4.3 소프트웨어 정보 모델 (SW Information Models)&lt;br /&gt;4.4 소프트웨어 프로세스 측정 기술 (Measurement Techniques)&lt;br /&gt;&lt;br /&gt;5 소프트웨어 공학 프로세스 도구들 (SW Engineering Process Tools)</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/3926390220267211637/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=3926390220267211637' title='1개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/3926390220267211637'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/3926390220267211637'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2015/07/swebok-sw-2.html' title='SWEBOK - SW 프로세스 #2 정의'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-8339452892470718371</id><published>2015-01-18T05:57:00.000-08:00</published><updated>2016-01-19T17:04:23.139-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="분석/요구사항"/><category scheme="http://www.blogger.com/atom/ns#" term="소프트웨어공학"/><category scheme="http://www.blogger.com/atom/ns#" term="실리콘밸리"/><category scheme="http://www.blogger.com/atom/ns#" term="정부 정책"/><title type='text'>소프트웨어 분할발주를 위해 선행해야 할 일</title><content type='html'>&lt;script type=&quot;text/javascript&quot;&gt;// &lt;![CDATA[&lt;br/&gt;(function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,&#39;script&#39;,&#39;//www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);   ga(&#39;create&#39;, &#39;UA-50709339-1&#39;, &#39;ikwisdom.com&#39;);   ga(&#39;send&#39;, &#39;pageview&#39;);&lt;br/&gt;// ]]&gt;&lt;/script&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;요새 정부에서 분할발주를 하겠다는 정책이 있다. 정책의 방향은 100% 찬성한다. 하지만 방법이 문제다. 정책의 자세한 내용을 가지고 왈가왈부해 봐야 탁상공론식으로 찬성, 반대, 우려, 상황론에 의한 합리화등 너무 많은 이슈가 얽혀 있어 쉽게 결론이 나지 않는다. 진실의 이슈가 아니라 이 이슈도 정치적인 이슈가 되어 버렸기 때문이다. 정치적인 이슈의 특징은 아무리 오랜 세월이 지나도 모양만 변형될 뿐 노블리스 오블리제는 없이 각자 이득을 취하기 위한 본질은 변하지 않는다. 일단 올바른 정책을 펴기 위해서는 먼저 본질을 정확히 파악하고 있어야 한다. 또 역량도 없이 증상만을 치료하기 위해 인기영합적인 정책을 수립한다면 필연적으로 다른 문제가 생긴다.  &lt;br /&gt;&lt;br /&gt;아래에 필자의 저서인 &quot;글로벌 소프트웨어를 말하다, 지혜 (2014/06)&quot;에서 쓴 &quot;인도에 개발 외주 주는 방법&quot; 이 있다. 이 글이 분할발주에 대한 실리콘밸리 소프트웨어 회사에서의 기본적인 원칙과 방법론을 말해준다. 원칙에 어긋나는 정책은 시행착오를 일으키며 또 몇 년의 세월을 낭비할 것이다. 또 역량이 없으면 방법이 원칙에 맞더라도 실패할 수 밖에 없다. 불행이도 국내에는 개발 앞 단계의 분석을 등한시 하는 문화가 오랫동안 진행되어 왔기 때문에 먼저 분석역량의 제고에 신경써야 할 것이다. 또 분석과 설계를 한 덩어리로 묶어서 얘기하는 경우가 있는데 이 둘은 완전히 다른 역량을 필요로 한다. IEEE SWEBOK의 분석부분을 번역해 놓은 것이 이 블로그의 SWEBOK 카테고리의 Post에 있으니 참고하기 바란다. &lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;font-size: 20px;&quot;&gt;&lt;strong&gt;34장 인도에 개발 외주 주는 방법&lt;/strong&gt;&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;실리콘밸리를 미국이라고 하니까 백인들이 많을 것이라고 생각한다. 실리콘밸리에는 동양인들이 백인들보다 많다. 버클리 대학에도 인종으로는 동양인이 가장 많다. 특히 실리콘밸리같이 IT 분야에는 중국 개발자와 인도 개발자가 전체 개발자의 반 정도 된다. 중국이야 원래 인구가 많아 캘리포니아에 많이 살고 있었고 따라서 중국인 회사도 많았다. 필자가 1980년도에 실리콘밸리에 도착했을 때도 중국 식당이 가장 많았었다. 그러면서 미국의 전문인력 이민(H1B) 정책으로 전세계 인재들이 몰려들면서 중국과 인도의 개발자들이 대거 채용되어 왔다. 이것도 연쇄작용이라 그렇게 온 이민자들이 또 동료들을 불러오고 하니까 점점 더 많아진 것이다. 인도는 또 영어권이라는 장점 때문에 미국 회사의 외주 프로젝트를 많이 수행하면서 소프트웨어 산업이 발전하고 강국이 되었다. 그렇게 된 원인은 단 두가지이다. 싼 임금과 영어권이라는 것이다. 특별히 머리가 좋아서도 아니고 원래 소프트웨어에 적당한 문화라서도 아니다. 솔직히 정직성이나 책임감은 인도나 중국보다는 상대적으로 한국 개발자들이 더 좋다고 생각한다. 성공의 원인은 미국에서 배운 개발방식이다.&lt;br /&gt;&lt;br /&gt;미국 회사는 영어가 잘 통하고 임금이 싸다는 장점으로 인도에 많은 소프트웨어 프로젝트를 주었다. 그래서 TCS, Infosys, Wipro, Sapient 같은 세계적인 거대 시스템통합업체가 발전했다. 그러면서 미국의 소프트웨어 개발방식을 배워 강국이 되었다. 소프트웨어 개발을 맡길때 정직성을 믿고 시스템 없이 맡기는 것과 모든 개발자를 믿을 수 없는 인간이라고 가정하고 시스템을 믿고 개발하는 것과 어느 것이 좋을까?  즉 사회를 통치할 때 성선설로 보는 것과 성악설로 보는 것 중 어떤 방법이 사회를 더 평화롭게 만들 수 있을 까? 미국은 근본적으로 소프트웨어 개발은 성악설에 기반한 개발 문화이다. 누가 무슨 일을 하는 지 명확하게 정의하고 진행하는 과정에 대해서도 투명하게 돌아간다. 투명 그 자체이다. 비밀스럽게 일하는 사람들에게는 무척 거북한 시스템이다. 이런 방식은 인도와의 관계 때문이 아니고 미국 회사 내부에서도 똑같은 방식이 사용된다. 일년 365일 내가 어느날 몇 줄의 소스코드를 고쳤는지를 누구나 항상 알 수 있다. 즉 인도 때문에 개발방식이 바뀐 것은 없다. 그러면서도 창조성이 필요한 곳은 허용해 준다. 창조도 투명하게 하는 것이지 창조성이 몰래 하라고 내버려두는 무정부상태가 아니다. 법과 질서를 잘 지키는 것이 창조성과는 아무런 관계가 없다. 참견하지 않는 것은 창조성이 아니라 무책임한 것이다.&lt;br /&gt;&lt;br /&gt;국내 소프트웨어 회사에서 내부 프로젝트를 수행할 때나 외주를 줄 때나 상대가 인도라고 가정해보자. 과연 계약서에 서명을 하고 인도에 프로젝트를 줄 수 있는가? 물론 영어는 문제가 아니라는 가정하에서다. 필자가 보기에 인도에 프로젝트를 줄 수 있는 회사는 거의 없다. 국내 소프트웨어 회사는 대충 개발하는데 너무 익숙해져 있어서 그렇게 사는 게 인생인 줄 안다. 그리고 합리화를 할 수 있는 무기는 많이 있다. 대충 몇 개만 나열해 보면 다음과 같다.&lt;br /&gt;&lt;br /&gt;?	계약시에는 그렇게 자세한 내용은 알 수가 없어서 진행하면서 정해가야 합니다.&lt;br /&gt;?	새로운 제품이라서 먼저 대충 화면이 나오고 사용자 평가를 받아보면서 조정해야 합니다.&lt;br /&gt;?	시간이 없어서 대충 계약하고 일단 시작해야 합니다.&lt;br /&gt;&lt;br /&gt;필자가 귀가 따갑도록 들은 앵무새 같은 소리들이다. 한국에 처음 왔을 때는 신기했지만 이제는 그런 소리를 들으면 안타까울 뿐이다. 새로운 혁신적인 프로젝트는 한국보다는 미국이 훨씬 더 많다. 그리고 자세한 것을 모르는 상태나 시간이 없는 상태는 전 세계 모든 소프트웨어 회사의 공통점이다. 이제는 착각에서 깨어날 때도 되었다.&lt;br /&gt;&lt;br /&gt;인도와 외주 계약을 한다고 가정하면 계약금액이 있고 일정이 있고 사양이 있어야 한다. 계약이 성립하려면 발주자나 수주자나 개발종료에 대한 확실한 기준이 있어야 한다. 대부분의 소프트웨어 방법론에서는 인수테스트(Acceptance Test Plan)라고 한다. 한국의 방식에서는 수주자가 개발이 종료했다고 선언한 다음에 발주자가 인수를 위한 검증을 수행한다는 희안한 과정이 들어 있다. 전혀 잘못이 없어 보이는 이 과정은 발주자인 갑의 무소불휘의 권리이자 최후의 방어선이기도 하다. 이 인수 검증이 바로 모든 문제의 원인이다. 이런 식의 발주자의 주관적인 검증은 미국이나 인도 회사가 도저히 받아들일 수 없는 계약조건이다. 프로젝트 계약이 성립할 수 없는 근본 원인이다. &lt;br /&gt;&lt;br /&gt;인도의 수주한 개발자도 스스로 제품에 하자가 있다 없다는 것을 개발이 끝나기 전에 알고 있어야 한다. 개발자도 모르는 상태에서 발주자의 주관적인 판단에 맡긴다는 것은 엄청난 리스크이다. 그런 상태에서라면 계약을 하지 않는다. 대부분의 국내 발주자 같은 진상고객을 만나면 낭패다. 추가 비용만이 문제가 아니라 다음 프로젝트 일정도 망가지고 회사 계획이 엉망이 된다. 즉 결론은 납품할 제품이 검증을 통과할지 안할지를 개발자가 명확히 알 수 있는 내용이 있어야지만 계약이 성립된다. 그렇기 때문에 구체적으로 적힌 인수테스트를 통과하면 그냥 개발종료된 것이다. 발주자가 이의를 제기할 수가 없는 것이다. 발주자의 검증은 개발자가 자체적으로 인수 테스트를 수행할 때 옆에서 지켜보는 것으로 끝나기도 한다. 발주자가 인수테스트를 수행한다는 것은 똑같은 테스트를 두 번 하는 것으로 시간낭비이다.&lt;br /&gt;&lt;br /&gt;그래서 개발자들은 발주자와는 대화 한번 없이도 약속한 날자에 인수테스트를 통과한 제품을 납품함으로써 끝난다. 발주자가 강심장이라면 납품일자까지 가만히 있다가 인수테스트를 통과했으면 끝난 것이고 아니면 소송해서 위약금을 받아내면 된다. 통상적으로는 리스크를 줄이기 위해 중간에 점검을 하지만 계약서가 바뀌는 것은 아니다. 이런 시나리오가 성립되려면 무엇이 필요할까 하는 것은 방법의 문제이다. 이 책의 이 부분 저 부분을 다 엮으면 방법이 나올 것이다. 이것이 바로 실리콘밸리 회사에서 개발이 진행되는 기본 원리이다. 먼저 이 원리를 확실히 이해하고 그 다음에 방법을 찾아가기 바란다. 방법까지 찾고 실행까지 할 수 있다면 개발역량 만큼은 글로벌 회사 수준이다. 생각을 도와주기 위한 시나리오를 준다면 다음과 같다.&lt;br /&gt;&lt;br /&gt;1.	계약서에 사인을 하고는 나중에 결과물을 인수받을 때까지 서로 간에 얘기할 필요가 없다.&lt;br /&gt;2.	그러려면 계약시에 납품 통과 기준을 인수테스트 목록으로 명확히 알려주어야 한다.&lt;br /&gt;3.	인수테스트 목록만 패스하면 그 외에 아무리 오류가 많아도 그대로 제품을 인수 받아야 한다.&lt;br /&gt;4.	개발자는 스스로 모든 인수테스트 목록이 통과할 때 까지 개발을 계속한다.&lt;br /&gt;5.	약속한 날자에 제품과 인수테스트 결과보고서를 첨부해서 납품하면 끝이다.&lt;br /&gt;6.	발주자가 검증한다는 것은 인수여부를 위해서가 아니라 자기들이 미처 생각하지 못한 것이 있나를 검증하는 것이다. 있다면 자기 잘못이다. 미리 계약때 포함시켰어야 한다.&lt;br /&gt;7.	납품받으면 끝이다. 그 때 필요한 추가 기능이 생각나서 인간적으로 해주세요 빌어도 안 해준다. 잔금으로 협박하지 말고 깨끗이 추가 계약을 하는 수 밖에 없다. 한국식으로는 했다가는 소송걸려서 이자와 재판비용까지 물어야 한다.&lt;br /&gt;8.	그럼 인수테스트를 그렇게 잘 적으려면 무엇이 필요할까? SRS가 필요하다.&lt;br /&gt;9.	SRS에는 인수테스트를 위한 기능목록은 기본이고 성능사양, 비기능 사양등 원하는 모든 것이 포함되어 있어야 한다. &lt;br /&gt;10.	결국 SRS를 잘 적어야 한다. 보통 국내회사에서 생각하는 것과는 상상을 초월할 만큼 양이 많다.&lt;br /&gt;11.	SRS를 잘 적기 위해서 누가 적으며 어떻게 해야 잘 적을까? 이게 문제이다. 또 다시 제1원인에 도달했다.&lt;br /&gt;&lt;br /&gt;여기까지는 쉽게 제1원인을 찾아서 올 수 있었으나 여기서부터가 문제다. 요약하자면 미국 회사와 인도회사는 한 쪽은 SRS와 인수테스트를 잘 적고 한 쪽은 내용이 충분한지 검토한 다음 계약을 한다는 것이다. 이 과정에서 인도 회사들은 SRS를 읽고 개발을 해주는 역량부터 기르기 시작해서 서당개 3년이면 풍월을 읇는다고 SRS를 적을 수 있는 역량도 서서히 생겨난 것이다. 이런 SRS를 템플릿이나 샘플보고 적는다고 생각하는 것은 국내 개발자들의 망상이다. 차라리 책보고 골프배우는 것이 훨씬 쉽다. 이것이 바로 소프트웨어 개발에서 가장 어렵다는 분석역량이라는 것이고 수 많은 경험이 필요한 것이다. &lt;br /&gt;&lt;br /&gt;지금 이 시나리오는 모든 소프트웨어 개발의 가장 기본 원리를 설명한 것이다. 방법론이나 프로젝트의 종류에 따라 응용에 차이가 있을 지는 모르나 이것은 소프트웨어 회사라면 절대적으로 가져야 하는 역량이다. 이 역량이 없는 이상 영원히 소프트웨어 선진국이 될 수 없다. 예외 중의 하나는 연구 프로젝트이다. 연구 프로젝트는 어차피 결과에 대한 약속도 없이 버리는 돈이라고 생각하고 서로 상대방과 미래의 파트너가 될 수 있을까 하는 탐색전 정도이기 때문에 이 시나리오에는 해당되지 않는다. 국내에서는 대부분 제품 프로젝트를 연구 프로젝트처럼 진행한다.&lt;br /&gt;&lt;br /&gt;국내회사 중에 영어 문제가 없다고 했을 때 인도에 외주를 줄 수 있는 회사가 있을까? 그럴 수 있는 회사는 없다 라고 말할 수 있다. 인도와 외주계약을 할 수 있는 역량이 없다면 내부프로젝트도 제대로 할 수 없다. 문서의 양의 차이이지 생각하는 방식은 똑같아야 한다. 망쳐도 소송만 걸리지 않는다 뿐이지 혼란스럽고 일정연기, 사양변경, 품질저하는 필연적이다. 결국 국내 소프트웨어 회사는 이런 외주 역량이 없이 한국말을 한다는 편리성과 약자인 을을 잔금이라는 치졸한 무기를 동원해서 마음대로 부릴 수 있다는 생각으로 엉터리 외주 혹은 내부 프로젝트를 진행한다. 미국과 인도의 계약에서는 갑도 없고 을도 없다. 계약서 대로만 수행하면 되는 것이다.&lt;br /&gt;&lt;br /&gt;위에서 말한 외주 방식을 Turn-Key 방식이라고 한다. 반면에 그냥 개발자 몇 명이 필요해서 임시직원처럼 사용하는 Time-and-Material (시간제 임금) 방식으로도 원격으로 인도 인력을 사용할 수는 있다. 필자가 선호하는 방식이다. 이런 경우에도 당연히 SRS도 있어야 하고 인사관리도 해야 하고 업무배분도 해야하고 프로젝트 관리능력이 있어야 한다. 인도에다 Turn-key로 모든 것을 맡기기에는 역량은 없고 불안하니 리스크를 조금 줄이는 방식이다. &lt;br /&gt;&lt;br /&gt;앞 부분에서 말한 대로 소프트웨어 개발방식은 어떤 특정한 문화나 어떤 민족성에 상관없이 최악의 상황에서도 개발할 수 있는 방식으로 진화되어 왔다. 인도나 중국사람들이 전세계 소프트웨어 업계에 가장 많은 개발자를 가질 수 있는 것은 인종이 훌륭해서가 아니라 실리콘밸리의 개발방식때문이다. 한국과 같이 인정이 많고 인간적인 유대관계로 서로 믿고 개발하다가 소송하는 방식으로는 절대 선진국이 될 수 없다. 아는 사람한테 일을 맡긴다고 대충하려면 하지 않는 것이 현명하다. 믿는 사람과 대충하는 것보다는 시스템으로 일을 할 수 있는 모르는 상대방이 훨씬 안전하다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/8339452892470718371/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=8339452892470718371' title='4개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/8339452892470718371'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/8339452892470718371'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2015/01/blog-post.html' title='소프트웨어 분할발주를 위해 선행해야 할 일'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>4</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-5071684021838552989</id><published>2014-11-30T05:49:00.000-08:00</published><updated>2015-11-28T01:29:47.904-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="정부 정책"/><title type='text'>금융보안과 한국 소프트웨어 미래의 심각성</title><content type='html'>&lt;script type=&quot;text/javascript&quot;&gt;// &lt;![CDATA[&lt;br/&gt;(function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,&#39;script&#39;,&#39;//www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);   ga(&#39;create&#39;, &#39;UA-50709339-1&#39;, &#39;ikwisdom.com&#39;);   ga(&#39;send&#39;, &#39;pageview&#39;);&lt;br/&gt;// ]]&gt;&lt;/script&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;아래 기사는 필자가 안철수연구소의 부사장/CTO 였던 거의 9년전인 2006년에 연두기자회견때 기자들과 인터뷰했던 내용이었다. 필자도 금융권을 해킹할 수 있다는 내용일 만큼 파격적이어서 그 당시에는 여러군데 기사가 나왔었다.  당시에 잠깐 큰 이슈가 되었었지만 내용의 심각성때문인지 곧 덮어졌다. 아마도 이해관계가 얽힌 다양한 기득권층에게 이익이 되지 않기 때문이었으리라고 추측한다.&lt;br /&gt;&lt;br /&gt;요새 농협의 증발해 버린 돈 사건에서 처럼 중국 해커들이 돈을 인출해 가는 것은 필자가 기자회견에서 예견했듯이 너무 뻔한 인과의 결과이기 때문에 앞으로도 계속 발생할 것이며 억울한 피해자가 속출할 것이다. 금융보안의 문제는 고객의 편리함을 제공한다는 명분아래 필연적인 보안의 취약점이기에 피하기도 어렵다. 시작이 잘못된 것이다. &lt;br /&gt;&lt;br /&gt;금융권에서의 보안 불감증의 문제보더도 더 중요한 것이 소프트웨어 산업의 멸망이다. 사회에 만연된 불감증으로 지금대로 가다가는 한국 소프트웨어 산업도 금융 문제와 같이 깊은 늪에 빠질 것이다. 필자가 그동안 여러 저서를 통해 얘기해 왔지만 8년 전의 금융 보안에 대한 경고와 같이 미래 10년 후의 한국 소프트웨어가 암울해 보이는 것은 사실이다. 근본적인 변화는 없이 얼굴화장이나 하는 정도의 소극적인 변화로는 현재 처한 한국 소프트웨어의 문제는 해결되지 않는다.&lt;br /&gt;&lt;br /&gt;아인슈타인이 다음과 같이 말했다.&lt;br /&gt;&quot;같은 일을 반복해서 되풀이하면서 다른 기대를 소망하는 것은 미친 짓이다.&quot;&lt;br /&gt;&quot;Insanity: doing the same thing over and over again and expecting different results.&quot;&lt;br /&gt;&lt;br /&gt;이제 탁상공론은 그만하고 기득권도 내려놓고 근원적인 개혁을 시작하지 않으면 한국 소프트웨어는 없다.  &lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;아래는 8년전 기사이다.&lt;br /&gt;&lt;br /&gt;안철수 연구소 “대한민국은 사이버전쟁 전야…중국해커에 노출 무방비”  &lt;a href=&quot;http://news.naver.com/main/read.nhn?mode=LSD&amp;amp;mid=sec&amp;amp;oid=143&amp;amp;aid=0000018996&amp;amp;sid1=001&quot; style=&quot;color: red;&quot; target=&quot;_blank&quot;&gt; [기사원본가기]&lt;/a&gt;&lt;br /&gt;기사입력 2006-03-20 21:28 | 최종수정 2006-03-20 21:28 0 &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;[쿠키인터넷] “대한민국은 사이버전쟁 전야같다.”&lt;br /&gt;&lt;br /&gt;안철수연구소의 김익환 최고기술책임자(CTO) 겸 부사장은 20일 서울 세종로 프레스센터에서 열린 ‘안철수연구소 창립 11주년 기념’ 기자간담회에서 “보안불감증이 심각하다”며 이같이 말했다. &lt;br /&gt;&lt;br /&gt;김 부사장은 “기업이나 은행,기관 모두 마음만 먹으면 공격할 수 있고 막을 방법은 없다”며 “나 역시도 지금 당장 해킹할 수 있을 만큼 보안이 취약하다”고 덧붙였다. &lt;br /&gt;&lt;br /&gt;그는 중국 해커들이 가장 두려운 대상이라고 언급한 뒤 “한국은 아직까지 폐쇄적인 구조라 금전적 이득을 얻기 힘들기 때문에 공격을 감행하지 않고 있는 것 같다”고 설명했다. 인터넷뱅킹을 예로 들면 미국은 외화의 송금 및 반입이 자유로운 오픈타입인 반면 한국은 외화 거래가 자유롭지 않은 폐쇄타입이라는 것. &lt;br /&gt;&lt;br /&gt;공개키기반구조(PKI)와 관련해서도 의문을 제시했다. 일각에서 PKI는 공격할 수 없는 최상의 장치라고 얘길 하지만 실제로는 ‘뚫린다’는 게 김부사장의 얘기다. 그는 “PKI는 숫자 두개를 곱해서 나온 조합으로 얼마든지 해킹할 수 있다”며 “다만 시간이 오래 걸려 못 뚫는다는 얘기가 나오는 것”이라고 덧붙였다.&lt;br /&gt;&lt;br /&gt;그는 또 “10년전만 해도 재미로 해킹하던 ‘매시브 어택(massive attack)’이 주를 이룬 반면 현재는 금전적 이득을 얻기 위한 피싱 등 무작위 공격이 기승을 부리고 있다”며 “미래에는 특정대상을 겨냥한 전세계 어떤 업체도 못 막는 공격이 자행될 것”이라고 경고했다.&lt;br /&gt;&lt;br /&gt;2004년 3월 안철수 연구소에 영입된 김 부사장은 서울대 공대를 나와 미국 산호세주립 대학에서 전산학을 공부한뒤 실리콘밸리의 모체인 스탠포드 대학에서 컴퓨터공학 석사 학위를 받았다. 그는 GE를 거쳐 선마이크로시스템즈에서 현재 구글의 최고경영자인 에릭 슈미트와 함께 근무하는 등 쟁쟁한 IT전문가들과 함께 실무 경력을 쌓았으며 1995년부터 9년간 실리콘밸리에 소프트웨어 회사인 스탠포드 소프트웨어사를 설립해 운영했다. 저서로는 ‘대한민국에는 소프트웨어가 없다’가 있다. &lt;br /&gt;&lt;br /&gt;국민일보 쿠키뉴스 이경선 기자 bokyung@kmib.co.kr&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/5071684021838552989/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=5071684021838552989' title='2개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/5071684021838552989'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/5071684021838552989'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2014/11/blog-post.html' title='금융보안과 한국 소프트웨어 미래의 심각성'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-568297487846045892</id><published>2014-11-23T10:59:00.000-08:00</published><updated>2015-11-28T01:50:18.000-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="문화/조직/회사"/><category scheme="http://www.blogger.com/atom/ns#" term="정부 정책"/><title type='text'>SW 개발자 대우 - 10년 전과 달라졌나?</title><content type='html'>&lt;script type=&quot;text/javascript&quot;&gt;// &lt;![CDATA[&lt;br/&gt;(function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,&#39;script&#39;,&#39;//www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);   ga(&#39;create&#39;, &#39;UA-50709339-1&#39;, &#39;ikwisdom.com&#39;);   ga(&#39;send&#39;, &#39;pageview&#39;);&lt;br/&gt;// ]]&gt;&lt;/script&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;아래 글 &quot;SW 개발자가 우대받는 사회를 만들자&quot;는 필자가 10년 전인 2004년에 정부의 요청으로 기고한 기사였다. 필자가 &quot;대한민국에는 소프트웨어가 없다&quot;라는 책을 출판 한 때가 2003년 이었으니까 그 다음 해이다. 그 때도 SW 개발자를 우대하자는  취지였는데 10년 동안 전혀 변한 것이 없다는 것을 증명한다. 지금도 필자가 비슷한 기사를 쓰는 것을 보면 10년 전과 복사판이다. 전체적인 분위기는 더 악화된 것 같은 생각도 든다. 그만큼 정부, 학계, 기업이 전혀 변하지 않았다. 10년 동안 우리는 무엇을 했는가? 그럼 앞으로 10년이 더 지난다고 변할 수 있는가? 공자님이 2천년 전에 하신 말씀도 아직까지도 따라하지 못하는데 과연 무엇을 바랄 수 있을까 하는 생각도 든다. 지금도  수 많은 탁상공론들이 난무한다. 10년 동안 변하지 않았다는 것을 명심하고 공멸하지 않기 위해서는 모두 기득권을 내려놓고 진심으로 변화하기를 바란다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: red;&quot;&gt;&lt;/div&gt;&lt;h3&gt;SW 개발자가 우대받는 사회를 만들자&lt;/h3&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;한국의 소프트웨어 산업이 발전하기 위해서는 여러 가지 요소가 필요하다. 현실감 있는 정부의 정책도 있어야 하고, 회사도 적합한 환경을 제공해야 되고 소프트웨어 개발자들의 열정도 있어야 한다. 그 중에 개발자들의 열정은 회사나 정부정책에 많은 영향을 받을 수 밖에 없다. 현재는 여러 가지 이유로 소프트웨어에 종사하는 개발자들이 좋은 대우를 받지 못한다. 개발자들이 좋은 대우를 받지 못하니 그 길을 선호할 리 없다. IT 거품이 일어났을 때 몇 년간을 제외하고는 모두가 기피하고 희망이 없는 직종이 되어 버렸다. IT 거품이 꺼지면서 시장수요가 줄었다고는 하나 근본 원인은 다른 곳에 있다.&lt;br /&gt;&lt;br /&gt;필자가 소프트웨어분야에 오랫동안 기술자로 근무하면서 새로운 기술을 습득하기 위한 방법중의 하나가 컨퍼런스나 세미나에 가는 것이다. 지금부터 수년 전 미국에서 돌아온 지 얼마 되지 않았을 때였다.  어느 소프트웨어 신기술 세미나에 참석한 적이 있는데 20대나 30대로 보이는 젊은 층밖에 없는 것이었다. 나와 같은 연령대의 사람은 한명도 없었다. 왜 40대, 50대의 기술자는 없는 것인가 생각해 보았다. 미국과 같은 분위기를 생각하고 갔다가 앉아 있기가 민망해서 중간에 나와 버렸다. 그러면서 생각해 보니 미국에서는 빌 게이츠 같은 최고 경영자들이 제품데모도 하고 프리젠테이션도 직접 하는데 한국에서는 최고경영자가 직접 프리젠테이션 하는 경우를 본적이 없다. 그럴 수 있는 능력도 없을 것이다. 높은 직위에 있는 사람들은 보고 받고 결정만 하지 실제 경험은 하지 않기 때문이다. &lt;br /&gt;&lt;br /&gt;사회에 잘못된 통념이 있다. 어느 회사나 왜 승진하려면 꼭 관리가 되어야 하는 것일까. 나이 들면 젊은 사람들과 신기술에서 경쟁하기 어렵다고 한다. 나는 동의하지 않는다. 이유는 다른 곳에 있다. 기술습득에 시간을 소비하지 않고 관리업무에 시간을 소비하기 때문이다. 관리업무도 하고 기술습득도 하려면 뒤떨어 질 수 밖에 없다. 실제 소프트웨어 회사의 현황을 살펴보자. 회사의 종류를 살펴보면 단발성의 프로젝트를 주로 하는 SI 업체를 제외하면 정말 경쟁력 있는 패키지 소프트웨어를 만드는 기업은 몇 손가락에 꼽힌다. SI 업체는 수 많은 단발성의 프로젝트를 하므로 관리쪽이 더 중요하다. 기술자는 찬밥신세가 되기 쉽다. SI 업체가 아니고 패키지를 개발하는 소프트웨어회사에서도 소프트웨어 엔지니어로 시작해서 능력 있는 사람들은 대부분이 서서히 관리직으로 넘어가게 된다. 관리직으로 넘어가지 못하면 도태되어 회사를 그만 두는 수 밖에 없다. 사농공상의 전통문화와 굴뚝산업에 익숙한 경영진들의 경영방식 때문에 소프트웨어산업은 악순환을 거듭할 수 밖에 없다. 전문가의 가치를 모르니 전문가가 생겨나기 어렵고 전문가가 없으니 좋은 제품을 만들 수가 없고 그러니 경쟁력이 떨어져 장기적으로 성공하기 어렵게 된다.&lt;br /&gt;&lt;br /&gt;미국의 소프트웨어회사를 방문하게 되면 주시해 볼 것이 있다. 주요 기술직에 있는 사람을 만나게 될 때 잘 주시해 보면 대개 나이가 많은 사람들임을 알게 될 것이다. 40대에서 50대 60대 까지도 있다. 그런 사람들의 명함에는 보통 “Fellow Engineer”, “Chief Engineer”, “Chief Scientist” 라고 쓰여 있다. 이러한 사람들이 회사에서 하는 역할은 기술적 업무와 중요한 결정을 담당하게 되는데 관리쪽 일은 전혀 안 하는 경우가 대부분이다. 관리쪽 일을 하게 되면 이미 기술자로서의 능력을 조금씩 상실하게 된다. 회의에서 만나더라도 이런 사람들의 결정이 가장 중요하다는 것을 명심해야 한다. 새 제품을 기안하는 사람은 마케팅부서 같은 기획조직에서 시작할 지 모르나 그 기안을 승인하는 것은 기술적인 면에서는 이런 최고 기술자가 한다. 기술적으로 승인이 안 나면 프로젝트는 취소될 수 밖에 없다. 기술적으로 안 된다는데 무대포로 밀어 붙일 수는 없다. 이런 기술자는 회사의 운명을 좌우할 수 있는 직위이다. 비슷한 명칭으로는 기술이사나 아키텍트라고도 할 수 있다.&lt;br /&gt;&lt;br /&gt;요새 한국에서 아키텍트라는 말을 많이 사용한다. 사람마다 의미를 조금씩 다르게 사용한다. 한가지 경우를 살펴보자. 소프트웨어분야에는 많은 요소기술이 있다 J2EE, 닷넷, CBD 등등 많다. 이러한 요소기술 전문가라는 뜻으로 아키텍트라는 명칭을 붙인다. 요소기술 아키텍트는 양성되기가 상대적으로 쉽다. 경험보다는 지식적인 부분이 더 많기 때문에 교육으로 쉽게 양성될 수 있다. 이러한 요소기술 아키텍트보다는 전체 개발 프로세스를 이해하고 어떠한 제품도 처음부터 끝까지 개발할 수 있는 체계와 정책을 수립할 수 있는 경험과 지식을 균형되게 소유한 확장형 아키텍트가 바로 최고의 기술자이며 또 필요한 것이 한국 소프트웨어의 현실이다. 이론적인 요소기술 지식으로서는 세계 어느 나라에도 뒤지지 않는다. 소프트웨어 엔지니어들을 보면 열심히 공부하는 사람들이 많다. 소프트웨어 엔지니어링, UML 방법론 등 책에서 다 익힐 수 있다. 하지만 오케스트라의 지휘자같이 전체적인 측면에서 바라볼 수 있는 경험과 지식을 두루 갖춘 안목있는 확장형 아키텍트가 필요한 것이다.&lt;br /&gt;&lt;br /&gt;소프트웨어기술자들이 언론매체에서 앤티 IT라는 말을 만들어 절망적인 상황을 표현했듯이 지금과 같은 기업문화에서는 소프트웨어 엔지니어들의 희망도 없고 아키텍트나 Chief Engineer와 같은 국가발전의 원동력이 될 기술자도 양성되기 어렵다. 모두 관리자의 길로 빠질 수 밖에 없고 전문지식 없이 기술적인 판단을 할 수 밖에 없다. 그렇게 해서는 올바른 결정이 나올 수도 없고 기술적으로 경쟁력 있는 제품이 생산될 리 만무하다. SI 업체와 같이 수주를 받아서 개발해 주는 회사는  되도록이면 저렴한 임금의 초급엔지니어들을 사용해서 이윤을 남기는 것이 최대의 목적이니까 하청업체에다가 헐 값에 넘기게 되고 하청업체는 당연히 값싼 엔지니어를 고용할 수 밖에 없는 것이 소프트업계에 종사하면 누구나 다 아는 현실이다. 이러한 환경에서 회사에서 최고의 연봉과 지위를 보장 받는 아키텍트들을 고용한다는 것은 어려울 수 밖에 없다.&lt;br /&gt;&lt;br /&gt;이러한 소프트웨어 문화 때문에 아키텍트라고 불리는 전문기술자 숫자가 절대적으로 부족하다. 이제부터라도 아키텍트를 양성하는 것도 중요하고 그러한 아키텍트들이 살아남을 수 있는 기업의 문화가 중요함은 두말할 나위도 없다. 소프트웨어 기술자들이 기술직에 전념할 수 있는 환경을 기업이 제공해 줄 수 있다면 소프트웨어발전의 기초는 세워진 것이다. 동시에 정부의 정책도 이런 기술자들을 정부관리에 등용할 수 있는 기회를 만들면 현실에 맞는 정책이 수립되지 않을까 생각된다. 소프트웨어가 발전하기 위해서는 천재 경영자가 필요한 것이 아니고 소프트웨어 기술자가 우대 받고 존경 받는 문화가 가장 중요하다. 그러면 좋은 소프트웨어는 저절로 나온다.&lt;br /&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/568297487846045892/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=568297487846045892' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/568297487846045892'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/568297487846045892'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2014/11/sw-10.html' title='SW 개발자 대우 - 10년 전과 달라졌나?'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-4332853246202540711</id><published>2014-11-02T07:59:00.000-08:00</published><updated>2015-11-28T01:32:19.701-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="SWEBOK(소프트웨어 지식체계)"/><category scheme="http://www.blogger.com/atom/ns#" term="소프트웨어공학"/><category scheme="http://www.blogger.com/atom/ns#" term="프로세스"/><title type='text'>SWEBOK - SW 프로세스 #1 소개</title><content type='html'>&lt;script type=&quot;text/javascript&quot;&gt;// &lt;![CDATA[&lt;br/&gt;(function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,&#39;script&#39;,&#39;//www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);   ga(&#39;create&#39;, &#39;UA-50709339-1&#39;, &#39;ikwisdom.com&#39;);   ga(&#39;send&#39;, &#39;pageview&#39;);&lt;br/&gt;// ]]&gt;&lt;/script&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;SWEBOK SW Process #1 - 2014-11-02&lt;br /&gt;&lt;br /&gt;8장 Software Engineering Process (소프트웨어 공학 프로세스)&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(*** 필자주석) 1장의 &quot;Requirements&quot;를 끝내고 2장 설계를 설명하는 것이 순서이긴 하지만 국내 소프트웨어 산업에서 가장 많이 유행했던 용어가 &quot;프로세스&quot; 이었기 때문에 순서를 바꾸어 이 Chapter를 먼저 설명하기로 한다. 프로세스는 효용성 면에서 가장 논쟁적인 이슈이기도 하다. 프로세스라는 일반 용어는 수천 년간 사용되어 왔다. 어떤 일을 체계적인 단계를 정해서 각 단계에 시작 상태가 있고, 정해진 행위를 하고, 산출물이 나오는 것을 표준화하는 것이다. 요리를 해도 프로세스가 있고 골프를 치러가도 프로세스가 있다. 하지만 천재 물리학자인 스티븐 호킹이 말하기를 &quot;인간에게 표준은 없다.&quot; 라고 했다. 과학에서도 똑같은 시험결과가 나오지 않는 것과 같이 인간 사회에서의 행동 패턴을 어떤 하나의 표준 프로세스로 정의할 수는 없다는 것이다. 인생에도 생로병사의 표준 프로세스가 있다고 생각하면 있는 것이지만 모든 사람의 인생이 다르기 때문에 표준이 없다 라고 말할 수도 있다. 프로세스라는 용어 자체가 극도로 추상적인 단어이기 때문에 증명도 어렵고 반증도 어려운 세계이다. 이런 추상화된 세계의 특성에 따라 자연히 사기꾼들이 성행하게 되니 매우 조심할 일이다.&lt;br /&gt;&lt;br /&gt;프로세스에 관한 한 국내 소프트웨어 업계에서는 미국의 CMMI나 유럽의 SPICE와 같은 인증위주로 진행되어 왔다. 사실 이런 인증들은 돈만 들이고 문서만 적당히 만들어 내면 누구나 인증을 받을 수 있다는 것은 업계의 관계자들이라면 모두 알고 있다. 현실을 반영하기 보다는 조작에 가까운 문서를 작성해서 인증을 받는 경우도 비일비재하다. 그렇게 인증을 받았다고 자랑스럽게 언론기사에 광고할 수도 있지만 그런 인증들은 ISO와 같은 국제 표준도 아니고 사실은 인증도 아닌 등급일 뿐이다. 아래 문장을 읽어보면 그 실체를 조금 더 객관적으로 이해할 수 있다.&lt;br /&gt;&amp;nbsp;&lt;em&gt;&lt;br /&gt;&lt;/em&gt;&lt;/div&gt;&lt;div style=&quot;color: red;&quot;&gt;&lt;em&gt;&lt;br /&gt;Organizations can be “Rated” at a Capability or Maturity Level based on over 300 discreet “Specific” and “Generic” Practices. Intended to be broadly interpreted, the CMMI is not a “Standard” (ala ISO), so achieving a “Level” of CMMI is not a certification, but a “rating.”&lt;/em&gt;&lt;/div&gt;&lt;em&gt;&lt;br /&gt;&amp;nbsp;&lt;/em&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;CMMI의 경우 SEI가 자기들이 정한 어떤 기준에 맞으면 그 수준을 인정하는 것이고 그런 인증을 요구하는 소수의 업체들과 비지니스를 하려면 필요하긴 한다. 하지만 인증이 실력으로 가치가 있는지 아닌지를 판단하기 위해서는 자기 이력서에 인증 경험을 적어서 취업에 도움이 된다면 가치가 있다고 보면 된다. 국내 이력서에서 프로세스 경험을 적은 것을 심심치 않게 보았다. 국방이나 자동차산업과 같은 특수한 분야에서는 도움이 될 수 있다. 하지만 실리콘밸리에서는 취업에 도움이 되기 보다는 그게 뭔지를 설명하느라 시간만 낭비할 것이다. 실리콘밸리의 회사에서 면접 시에 프로세스에 대한 질문은 하지 않는다. &lt;br /&gt;&lt;br /&gt;프로세스의 진정한 가치는 체크리스트와 같은 형식이 아닌 산출물의 내용에 있고, 그 내용의 충실성을 지속할 수 있는 현실적인 프로세스에 있다. 국내에서는 이벤트용으로 인증 받았으니 언론에 자랑스럽게 내는 것은 이해하지만 그 속을 들여다 보면 대부분 실속은 없고 결론적으로 보면 언론에 기사 내는 것이 가장 큰 혜택 중의 하나이다. 이런 관행이 국내 SW 업계 경영자들의 맹목적인 경영방침을 반영하기도 한다. 이런 점이 기업평가 사이트인 glassdoor.com에서 보듯이 국내 기업의 경영진들이 외국인 엔지니어들에게 전문성이 없다는 평가를 받는 이유이다. 인증을 받고 외국 파트너와 얘기를 시작할 수는 있지만 결국은 품질을 확보할 수 있는 현실적인 프로세스여야 가치가 있다. 실리콘밸리에 가서 SW 엔지니어들에게 CMMI나 SPICE를 아는지 물어보면 대부분 용어도 들어본 적도 없다는 것에 놀랄 것이다. 더욱 놀라운 것은 실리콘밸리의 벤처회사도 국내에서 CMMI의 최고 등급을 받은 회사보다 훨씬 더 현실적으로 좋은 프로세스를 가지고 있고 개발도 더 잘한다는 것이다.&lt;br /&gt;&lt;br /&gt;국내에서 생각하는 프로세스와 실리콘밸리에서 경험하는 프로세스는 겉모습과 용어는 같을 지 모르지만 속을 들여다 보면 완전히 다르다. 같은 용어라도 모든 회사에게 다 다르게 적용된다. 옳은 것도 아니고 틀린 것도 아니고 적용을 잘해야 하는 것이 프로세스의 어려운 점이다. 손자병법을 읽는 것은 쉬우나 현실에 적용하는 것은 완전히 다르다. 많은 사람들이 손자병법을 읽었지만 손무가 되기는 어렵다. 즉 손자병법을 읽었다는 인증은 받을 수 있지만 소프트웨어 개발이라는 전쟁은 수행하기 쉽지 않다. 아무튼 국내는 소프트웨어 프로세스가 극단적으로 형식적인 면에 치우쳐 적용되고 있는 갈라파고스 섬이다. 대부분의 회사는 프로세스 정립에 돈과 시간을 낭비할 확률이 높지만 시행착오를 하면서 배운다고 위안을 해보자. 단 국내 소프트웨어 산업이 돈과 시간 낭비하다가 외국 경쟁사에 뒤떨어지지 않을 정도만 시행착오를 해 보는 것이 좋겠다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;소개 - SW 공학 프로세스&lt;br /&gt;&lt;br /&gt;공학 프로세스는 Resource를 투자해 어떤 Input을 Output으로 변환시키기 위한 일련의 행위를 의미한다. 전기, 기계, 토목, 화학과 같은 전통적인 공학에서는 에너지와 물리적인 형태를 다른 형태로 변환시키는 것이다. 소프트웨어 공학에서는 소프트웨어 엔지니어가 요구사항분석, 설계, 구현, 테스트, 형상관리와 같이 소프트웨어를 개발하고 유지보수하는 일련의 행위와 관련되어 있다. 여기서는 가독성을 위해 &quot;소프트웨어 공학 프로세스&quot;를 그냥 &quot;소프트웨어 프로세스&quot;라고 부르기로 한다.&lt;br /&gt;&lt;br /&gt;소프트웨어 공학 프로세스는 다음과 같은 여러 목적을 위해 이용된다.&lt;br /&gt;  * 사람들간의 이해, 소통, 협업을 돕고,&lt;br /&gt;  * 소프트웨어 프로젝트의 관리를 돕고,&lt;br /&gt;  * 소프트웨어 품질을 측정하고 향상시키고&lt;br /&gt;  * 프로세스 자체의 개선을 돕고&lt;br /&gt;  * 프로세스 실행을 자동화하기 위한 기반으로 이용된다. &lt;br /&gt;&lt;br /&gt;소프트웨어 공학 프로세스 지식영역은 다음과 같이 나누어 진다.&lt;br /&gt;&lt;br /&gt;1. 소프트웨어 프로세스 정의 (Definition)&lt;br /&gt;1.1 소프트웨어 프로세스 관리 (Management)&lt;br /&gt;1.2 소프트웨어 프로세스 구조 (Infrastructure)&lt;br /&gt;&lt;br /&gt;2. 소프트웨어 생명주기 (SW Life Cycles)&lt;br /&gt;2.1 소프트웨어 프로세스의 분류 (Categories)&lt;br /&gt;2.2 소프트웨어 생명주기 모델 (Life Cycle Models)&lt;br /&gt;2.3 소프트웨어 프로세스 적용 (Adaptation)&lt;br /&gt;2.4 현실적인 고려 (Practical Considerations)&lt;br /&gt;&lt;br /&gt;3. 소프트웨어 프로세스 평가와 개선( SW Process Assessment and Improvement)&lt;br /&gt;3.1 소프트웨어 프로세스 평가 모델 (Assessment Models)&lt;br /&gt;3.2 소프트웨어 프로세스 평가 방법 (Assessment Method)&lt;br /&gt;3.3 소프트웨어 프로세스 개선 모델 (Improvement Models)&lt;br /&gt;3.4 연속적, 단계적 소프트웨어 프로세스 등급 (Continuous and Staged SW Process Ratings)&lt;br /&gt;&lt;br /&gt;4. 소프트웨어 측정 (SW Measurement)&lt;br /&gt;4.1 소프트웨어 프로세스와 제품 측정 (Process and Product Measurement)&lt;br /&gt;4.2 평가결과의 품질 (Quality of Measurement Results)&lt;br /&gt;4.3 소프트웨어 정보 모델 (SW Information Models)&lt;br /&gt;4.4 소프트웨어 프로세스 측정 기술 (Measurement Techniques)&lt;br /&gt;&lt;br /&gt;5 소프트웨어 공학 프로세스 도구들 (SW Engineering Process Tools)&lt;br /&gt;&lt;br /&gt;위의 5개의 Topic을 다음 Post 부터 하나씩 설명하기로 한다.&lt;br /&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/4332853246202540711/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=4332853246202540711' title='1개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/4332853246202540711'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/4332853246202540711'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2014/11/swebok-sw-1.html' title='SWEBOK - SW 프로세스 #1 소개'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-7464595620958032021</id><published>2014-08-30T08:39:00.000-07:00</published><updated>2015-11-28T01:53:35.345-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="SWEBOK(소프트웨어 지식체계)"/><category scheme="http://www.blogger.com/atom/ns#" term="분석/요구사항"/><category scheme="http://www.blogger.com/atom/ns#" term="소프트웨어 공학"/><title type='text'>SWEBOK - 소프트웨어 요구사항 #9 (최종)</title><content type='html'>&lt;script type=&quot;text/javascript&quot;&gt;// &lt;![CDATA[&lt;br/&gt;(function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,&#39;script&#39;,&#39;//www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);   ga(&#39;create&#39;, &#39;UA-50709339-1&#39;, &#39;ikwisdom.com&#39;);   ga(&#39;send&#39;, &#39;pageview&#39;);&lt;br/&gt;// ]]&gt;&lt;/script&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;SWEBOK 해설 Software Requirements #9 (최종)&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 이번 포스트가 Software Requirements의 마지막 포스트인 도구에 관한 꼭지이다. 이제 Requirements를 끝내고 다음은 설계(Software Design)에 대한 포스트를 시작될 것이다. 이 꼭지는 양이 많지 않으니 먼저 번역을 하고 주석을 달도록 하겠다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;1장 Software Requirements (소프트웨어 요구사항)&lt;br /&gt;1. Software Requirements Fundamentals (소프트웨어 요구사항의 본질)&lt;br /&gt;2. Requirement Process (요구사항 프로세스)&lt;br /&gt;3. Requirement Elicitation (요구사항 도출) &lt;br /&gt;4. Requirements Analysis (분석) &lt;br /&gt;5. Requirements Specification (명시) &lt;br /&gt;6. Requirements Validation (검증)&lt;br /&gt;7. Practical Considerations (현실적인 고려사항)&lt;br /&gt;8. Software Requirements Tools (도구)  &lt;br /&gt;&lt;br /&gt;Software Requirements와 관련된 도구는 크게 두 가지로 나누어 진다. &quot;모델링 도구&quot;와 &quot;요구사항 관리도구&quot; 이다.&lt;br /&gt;&lt;br /&gt;요구사항 관리도구는 문서화(Documentation), 추적(Tracing), 변경관리(Change Management) 등이 있는데 실제 개발에 큰 영향을 미친다. 사실 요구사항 추적이나 변경관리는 도구가 없이 수행하기는 비현실적이다. 요구사항 관리도구는 요구사항 관련 업무에 핵심적이기 때문에 많은 회사들이 요구사항 관리도구에 투자를 했다. 반면에 훨씬 더 많은 회사들은 만족스럽지는 않지만 스프레드시트와 같은 임시변통(Ad hoc)의 방법으로 관리한다. &lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 국내에는 도구에 대한 맹신이 있다. 사실 SWEBOK에서도 도구에 대해서 마지막에 몇 줄로 간단히 언급했듯이 그렇게 많은 비중을 들이지 않았다. 필자는 국내 회사들이 필요 없는 도구에 대한 광적인 집착을 보이는 경우를 많이 보아왔기 때문에 주의를 주고 싶다. 괜히 필요 없는 건강식품을 믿고 먹다가 돈과 건강을 잃는 피해를 입지 않기 바란다. 거의 대부분의 국내 회사는 도구에 신경쓰기에 앞서서 도구를 이용할 내용을 잘 적는 것에 먼저 모든 노력을 하기 바란다. 지금까지 SWEBOK에서 얘기한 것이 바로 내용을 잘 적기 위한 원리를 설명한 것이다. 도구는 내용이 있을 때 마지막으로 걱정할 문제이고 또 그래야지만 자신에게 맞는 적절한 도구를 분별하고 현명하게 구입할 수 있는 능력이 생긴다. &lt;br /&gt;&lt;br /&gt;SWEBOK에서 언급한 2가지 도구 중 모델링 도구에 관해서 많이 언급하지 않았지만 예를 들면 UML의 유스케이스 다이어그램을 만들어 주는 도구가 그 중의 하나이다. UML의 많은 다이어그램 중에 유스케이스 다이어그램은 Requirements를 명시하는 방법 중의 하나이다. 모든 프로젝트의 경우에 이용할 수 있는 방식은 아니지만 많은 경우에 사용되기는 한다.&lt;br /&gt;&lt;br /&gt;요구사항 관리도구는 양날의 칼이다. 마치 타이거 우즈의 골프채 같은 것이다. 일반 아마추어 골퍼들이 타이거 우즈의 골프채가 좋다고 똑같은 골프채를 사서 친다면 재앙일 것이다. 비싸기만 하고 손해 본다. 그러지 않아도 요새 골프존마켓의 광고에서 고객과 골프상점 점원이 골프채를 서로 잡고 고객은 가져가려고 하고 점원은 안 뺏기려고 티격태격 한다. 고객 말은 &quot;유소연이 이거 들고 일등 했거든요&quot; 점원 말은 &quot;당신은 유소연이 아니거든요. 손님한테 맞는 채를 사셔야 하거든요&quot;. 이 광고의 교훈은 비싼 도구와 나에게 맞는 좋은 도구는 다르다 이다. 물론 골프채의 경우는 비싼 채를 들고 다녀야 남들한테 졸부의 과시도 되고 하니까 전혀 가치가 없는 것은 아니다. 마찬가지로 회사의 경우에도 잘 알지는 못하니까 비싼 도구라도 사서 혹시라도 실패 시에 책임도 면하고 자기 과시도 하는 대기업 경영진들도 있다. 왜 비싸고 좋다는 도구를 샀는데 개발이 잘 안될까 하는 것을 필립 그린스펀은 유치원생이 비행기에 올라타서 이 버튼 저 버튼 눌러보면서 왜 비행기가 안 뜨지 하는 것과 같다고 말했다.&lt;br /&gt;&lt;br /&gt;추적 관리도구 같은 경우가 어설프게 사용했다가 큰 피해를 입는 경우이다. 요구사항 내용을 적는 능력이 충분히 있고 그런 상태에서 요구 사항을 추적을 하겠다면 필수적인 도구이다. 스프레드시트를 사용하겠다는 경우는 매우 간단한 경우에 해당한다. 수십 명이 개발하는 규모 정도의 프로젝트만 해도 요구사항을 스프레드시트로 관리하기에는 어려울 수 있다. 특히 변경이 자주 일어난다면 변경관리는 거의 불가능하다. 하지만 아무리 도구가 좋다고 한들 내용이 제대로 적혀 있지 않으면 관리하는데 쓸데 없는 비용만 든다. 차라리 추적이나 변경 관리를 하지 않는 것이 좋을 수도 있다. &lt;br /&gt;&lt;br /&gt;그럼 언제 도구가 효용성을 발휘할까? 이 답은 글을 쓰는 것과 비교해서 얘기할 수 있다. 내가 글을 쓰려고 하는 데 원고지에다 연필로 쓸까? 간단한 노트패드로 쓸까? 비싼 MS 워드로 쓸까? 하는 질문과 같다. 어떤 도구를 사용하든 먼저 글을 쓸 내용이 준비 되어 있어야 한다. 즉 생각하는 역량이 있은 다음에야 도구가 도와주는 것이다. 도구는 지원하는 도구일 뿐이지 글을 적는 데 핵심은 아니다. 뭘 적을 지도 모르는데 워드 띄워 놓고 쓰레기나 타이핑한다고 글은 나오지 않는다. 요구사항의 내용을 잘 적을 수 있을 때 편리성을 도와 주는 것이 도구인 것이다. 도구가 내용을 도출하는데는 도움이 되지 않는다. 내용을 도출하는 것은 전적으로 두뇌가 하는 행위이기 때문이다. 도구는 마지막에 기록하는데 도움이 되는 것이다.&lt;br /&gt;&lt;br /&gt;결론을 말하자면 요구사항관리도구를 사용해서 혜택을 받을 수 있기 위해서는 어느 정도 수준에 올라야만 한다. 아직 국내의 SI 프로젝트나 회사내부 프로젝트의 경우나 다 SRS를 제대로 작성하고 개발하는 경우가 거의 없다. 앞 장에서 말한 대로 인수테스트를 적을 수 있는가 없는가 로도 그 판단을 할 수 있다. 그런 상태에서는 도구를 사용하는 것이 거추장스러운 존재가 될 가능성이 크다. 반대로 SRS를 잘 적을 수 있는 데 도구가 없다면 문제가 될까? 아마 약간의 효율성 저하가 있을 수는 있겠지만 실리콘밸리의 대부분의 벤처기업이나 중소기업들은 요구사항 관련 도구가 없이도 웬만한 규모의 프로젝트는 잘 수행하고 있다. 도구에 관한 문제는 미리 걱정할 필요도 없고 스스로 SRS 작성 역량이 늘어가면 필요한 도구를 선택할 수 있는 역량이 생긴다. 그 때까지는 도구 영업사원들의 과대광고에 현혹되어 피해를 입지 않기 바란다.&lt;br /&gt;&lt;br /&gt;SRS를 잘 적는데 실패하는 프로젝트는 보기 어렵다. 반대로 SRS를 잘 적지 않고 성공하는 프로젝트도 보기 어렵다. 그래서 SW 프로젝트는 처음부터 이미 성공할지 실패할 지를 알 수 있다. 이렇게 SW 산업의 성공 조건은 간단하다. 하지만 &quot;간단한 것이 더 어렵다&quot;는 격언처럼 SW 전 생명주기에서 가장 중요하고 어려운 것이 바로 SRS이라고 SW 공학에서 강조한다.&lt;br /&gt;&lt;br /&gt;그리고 다음부터 포스트할 설계에 관한 내용도 SRS를 잘 알고 있어야 이해가 쉽다. 필자도 읽고 이해하는  수준이 아니라 머리 속에서 이 원리를 습관적으로 이용하기 위해서 수 없이 반복해서 읽곤 한다. SWEBOK도 여러 번 숙지하면서 읽었어도 항상 새롭게 깨닫는 내용들이 있다. 독자들도 가능하다면 처음부터 다시 한 번 읽어보기를 권장한다.&lt;/div&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/7464595620958032021/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=7464595620958032021' title='1개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/7464595620958032021'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/7464595620958032021'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2014/08/swebok-9.html' title='SWEBOK - 소프트웨어 요구사항 #9 (최종)'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-3599381572112569461</id><published>2014-08-17T12:07:00.000-07:00</published><updated>2015-11-28T01:55:52.166-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="SWEBOK(소프트웨어 지식체계)"/><category scheme="http://www.blogger.com/atom/ns#" term="분석/요구사항"/><category scheme="http://www.blogger.com/atom/ns#" term="소프트웨어공학"/><title type='text'>SWEBOK - 소프트웨어 요구사항 #8</title><content type='html'>&lt;script type=&quot;text/javascript&quot;&gt;// &lt;![CDATA[&lt;br/&gt;(function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,&#39;script&#39;,&#39;//www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);   ga(&#39;create&#39;, &#39;UA-50709339-1&#39;, &#39;ikwisdom.com&#39;);   ga(&#39;send&#39;, &#39;pageview&#39;);&lt;br/&gt;// ]]&gt;&lt;/script&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;SWEBOK 해설 Software Requirements #8&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 앞 포스트에서 인수테스트라는 얘기를 했다. 인수테스트를 작성해야 한다는 것은 소프트웨어 공학에서 많이 들었기 때문에 반론의 여지가 없겠지만 언제 작성하는지가 핵심이다. 지금까지 한국의 소프트웨어 회사에서 한번도 본 적이 없는 것이 인수테스트를 가지고 계약하는 것이다. 계약 시에 인수테스트를 충분히 적을 만큼 요구사항이 자세히 나와 있지도 않거니와 설령 나와 있다고 해도 계약을 위해 인수테스트를 작성한다는 생각을 하지 않을 것이다. 인수테스트를 어느 시점에 작성할 수 있는 역량과 현실에서 언제 작성하는가의 이슈는 다르다. SRS 와 함께 완성할 수 있는 역량이 있다면 언제든지 원하는 시점에 완성할 수 있다. 필자가 실리콘밸리에서 록히드와 계약을 하고 개발을 해주었을 때 SRS보다 더 중요한 것이 인수테스트였다. SRS의 내용은 다르게 해석할 여지가 조금 남아 있지만 인수테스트는 100% 통과해야지만 계약을 준수하는 것이다. 하나라도 통과하지 못하면 계약위반이다. 반대로 인수테스트만 통과하면 계약은 종료된다.&lt;br /&gt;&lt;br /&gt;물론 실리콘밸리의 회사가 모든 계약에서 이렇게 하는 것은 물론 아니다. 하지만 그렇게 해야 될 때는 그렇게 한다. 할 수 있는 역량은 있지만 필요에 따라 하기도 하고 안하기도 한다. SRS를 잘 적을 수 있어야만 가능하다. 특히 국방부나 원자력발전소와 같이 대규모의 정교하고 안정된 소프트웨어를 개발할 때 중요해진다. 국내에서는 거의 모든 대규모의 프로젝트가 지연된다. 대규모 프로젝트일수록 인수테스트가 중요해지는데 SRS도 정확하지 않은 상태에서 계약시에 인수테스트를 작성한다는 것은 불가능하다. &lt;br /&gt;&lt;br /&gt;역량과 이론과 현실의 삼각 관계에서 어떤 선택을 해야 하는가는 항상 어려운 이슈이다. 무모한 동키호테가 될 수도 있고 이론의 늪 속에 빠져 버릴 수도 있다. 하여튼 이론에서는 인수테스트가 SRS 같이 나와야 하지만 여러 가지 이유로 그렇지 않은 경우가 훨씬 많다. 이 쪽지의 주제가 바로 이론과 다를 수 있는 현실적인 고려사항이다. 현실에서는 고려해야 사항들도 이론과 마찬가지로 중요하다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;1장 Software Requirements (소프트웨어 요구사항)&lt;br /&gt;1. Software Requirements Fundamentals (소프트웨어 요구사항의 본질)&lt;br /&gt;2. Requirement Process (요구사항 프로세스)&lt;br /&gt;3. Requirement Elicitation (요구사항 도출) &lt;br /&gt;4. Requirements Analysis (분석) &lt;br /&gt;5. Requirements Specification (명시) &lt;br /&gt;6. Requirements Validation (검증)&lt;br /&gt;7. Practical Considerations (현실적인 고려사항)&lt;br /&gt;&lt;br /&gt;이 전체 챕터의 제목인 &quot;요구사항 지식영역&quot;에서 지금까지 진행한 소제목들이 순서적으로 진행하는 것처럼 보이지만 그것은 편의상 단순하게 나열한 순서일 뿐이다. 요구사항은 전체 소프트웨어 생명주기에 관계된다. 미래에 개발될 제품을 위한 요구사항을 위한 변경 관리와 이미 개발된 제품에 대한 요구사항의 유지의 두 가지가 소프트웨어 공학 프로세스의 성공의 핵심이다. &lt;br /&gt;&lt;br /&gt;모든 회사가 요구사항을 작성하고 유지하는 문화를 가지고 있는 것은 아니다. 특히 제품에 목숨을 걸고 한정된 자원 밖에 없는 역동적인 신생기업의 경우 이런 문서작업을 불필요한 오버헤드라고 생각하는 것이 통상적이다. 하지만 이런 회사들이 성장하고 고객이 늘고 제품이 진화함에 따라 과거의 요구사항에 대한 내용을 파악함으로써 미래를 위한 변경에 따른 영향과 파급효과를 이해할 수 있다. 그래서 요구사항문서와 변경관리는 성공적인 요구사항 관리 프로세스에서 핵심적인 역할을 한다. &lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 요구사항의 문서가 없이 제품만 가지고 있는 경우는 사상누각과 같다. 더 이상 발전할 수가 없고 기존 제품만 유지보수 하는 것이 최선의 결과이다. 마치 빌딩을 지었는데 설계문서가 없는 것과 같다. 과거의 기억을 되살리면서 겨우 유지보수는 하겠지만 더 큰 빌딩을 지으라고 하면 머리의 기억만으로 지금까지 겪었던 경험과 시행착오를 기억할 수는 없다. 또 인력이 변경되면서 그런 과거의 배움은 사라지고 결과물만 남아있다. 새 제품을 개발하면서 적어도 과거에 개발할 때 결정한 사항이나 기술의 선택에 대한 배경이나 이론을 문서 없이 기억하기는 어렵다. 실제로 개발할 때 보면 복잡한 이슈의 경우 며칠 전에 정한 결정사항도 결과만 기억하지 결정에 이른 복잡한 과정은 기억하지 못하는 경우도 많다. 1,2년이 지나서 비슷한 상황이 생겼을 때 시행착오를 하지 않으려면 과거의 정보는 필수이다. 기억에 의존해서 소프트웨어를 장기간 개발하려고 한다면 소프트웨어를 너무 쉽게 생각한 것이거나 동호회 수준의 제품을 개발을 하고 있는 것이다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;7.1 Iterative Nature of the Requirements Process (요구사항 프로세스의 반복적인 특성)&lt;br /&gt;&lt;br /&gt;경쟁적이고 시장 주도의 소프트웨어 영역에서는 점점 더 신속한 개발에 대한 압박이 크다. 더군다나 이미 개발되어 있는 아키텍처(구조) 위에서 업그레이드도 해야 하고 새 제품도 만들어야 하고 기존 제품도 유지해야 하는 동시에 벌어지는 다양한 일이 있다. 그래서 요구사항을 도출하고, 기준선(Baseline)을 긋고, 개발팀에게 넘기는 이론적인 순서로 차례로 수행한다는 것은 현실의 요구사항 프로세스에서는 거의 불가능하다. 그래서 대규모 소프트웨어 프로젝트에서 실제 요구사항이 처음에 완벽하게 이해되고 명시된다는 것은 신화적인 얘기이다. &lt;br /&gt;&lt;br /&gt;대신에 요구사항은 설계가 가능할 만한 수준의 품질과 상세도로 반복적인 작업을 통해 정리되어 간다. 어떤 프로젝트에서는 모든 특성을 이해하기 전에라도 기준선을 긋고 개발을 하기도 한다. 물론 잘못된 요구사항이 나중에 발견되면 엄청난 피해를 입는 리스크가 있다. 하지만 소프트웨어 엔지니어들은 프로젝트 관리에 의한 일정을 따라야 하는 제약하에서 움직인다. 그런 환경하에서 주어진 자원으로 작성할 수 있는 최고 품질의 요구사항을 만들어야 한다. 예를 들어 요구사항에 대한 어떤 가정도 분명한 근거가 있어야 하고 알려진 문제에 대해서도 확실히 해결할 수 있다는 근거하에서 가정을 해야 한다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) SRS를 작성하는 과정에서 가장 어려운 부분이 바로 Assumptions and Dependencies (가정과 의존) 부분이다. 통상적인 국내 개발에서 보면 엄청나게 많은 가정을 가지고 프로젝트를 시작한다. 만약에 가정을 모두 미리 해결할 수만 있다면 프로젝트는 주어진 일정에 정확하게 끝나야 한다. 일정이 지연되는 이유는 알건 모르건 어떤 가정이 생각대로 진행되지 않았기 때문이다. 가정에는 기술적인 이슈도 있지만 인사관리의 이슈도 있고 외주 회사나 플랫폼과 같은 타 회사의 일정에 관계되기도 한다. 그런 경우 가정과 함께 의존성도 생긴다. 이 수 많은 가정을 얼마나 잘 인식하고 도출해 내는 것이 첫번째 필요한 역량이고 그 다음에 어떤 가정을 언제 해결하는가 하는 것을 결정하는 것이 두번째 중요한 이슈이다. 대부분의 국내 회사에서는 거의 희망에 가까운 가정을 하고 해결 계획도 부족한 상태에서 프로젝트에 뛰어든다. 수 많은 가정이 깨어지면서 프로젝트는 아수라장이 된다. 사실은 많은 가정은 아예 초기에 인식조차도 못한다. 이런 상황에서 프로젝트가 제 일정에 끝날 확률은 거의 없다. 프로젝트의 리스크 관점에서는 기능요구사항보다도 훨씬 더 중요하다. 기능요구사항보다 중요한 것이 비기능요구사항이고 그보다 더 중요한 부분이 바로 &quot;가정과 의존&quot; 부분이다. 가정을 모두 해결하고 프로젝트에 들어가는 것은 현실적으로 불가능하다. 그래서 어떤 가정은 해결하고 어떤 가정은 리스크를 택하게 되는데 여기서 인간의 지혜와 경험으로 인한 현명한 결정이 핵심이다. 이 부분이 경험의 차이가 가장 큰 부분이다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;이런 반복적인 모델로 개발하기로 한 프로젝트에서는 요구사항 분석가는 현재 반복주기에 필요한 요구사항의 기준선을 긋고 그 기준선에 기반해서 개발팀은 설계와 구현을 함과 동시에 요구사항 분석가는 다음 반복주기를 위한 요구사항의 기준선을 긋기 위해 분석 작업을 한다. 이 개발모델은 고객에게 제품을 빨리 제공함과 동시에 재작업을 최소화하는 방법이다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 대충 보면 이런 방식이 바로 애자일 방식의 개념과 비슷하다. SWEBOK의 저자들이 폭포수 모델을 중심으로 적었을 것이라고 생각한다면 착각이다. 이미 20년 전에도 폭포수 모델의 장단점과 애자일 모델의 필요성에 대한 논쟁도 있었다. 필자도 실리콘밸리의 회사 중 GE와 GTE Government System을 제외하고는 모두 애자일 개념을 사용했다. 물론 그 당시에는 &quot;애자일&quot; 이라는 용어를 사용하지는 않았다. 나중에 만들어진 용어일 뿐이지 그런 행위는 이미 과거 수십 년 전에도 존재하고 있었다. 마치 애자일 방식이 소프트웨어 개발을 잘하는 최신 비법이라고 생각한다면 거대한 착각이다. 소프트웨어 개발의 핵심은 변하지 않았고 그냥 언저리 편법이 건강식품처럼 유행을 타기는 한다. 먼저 정통을 알고 그 다음에 상황에 따라 응용하는 것은 좋지만 정통은 해본 적도 없으면서 편법만 배워서 해결하려고 한다면 100% 실패할 수 밖에 없다. &lt;/div&gt;&lt;br /&gt;&lt;br /&gt;거의 모든 경우에 요구사항의 이해는 기준선에서 끝나지 않고 설계와 구현단계까지 진화하며 계속된다. 이는 당연히 개발주기의 후반부에서 요구사항의 변경을 초래한다. 소프트웨어 요구사항에서 꼭 이해해야 할 가장 중요한 점은 요구사항의 많은 부분의 변경된다는 것이다. 이유로는 분석 과정에서의 오류도 있지만 많은 경우에 환경의 변화 때문이다. 환경에는 고객의 운영환경, 비지니스 환경, 정부의 규정 변경, 시장의 변화 등이 있다. 무슨 이유든지 간에 요구사항은 변경될 것이라는 것을 인정하고 그 영향을 최소화하도록 불가피하게 준비작업을 해야 한다는 것이다. 변경할 사항은 공식 검토와 승인 프로세스를 따라야 하며 요구사항 추적, 영향력평가, 형상관리와 같은 세심한 관리를 해야 한다. 그래서 요구사항 분석은 생명주기의 전반부에만 한정된 것이 아니라 전체 생명주기에 다 관련된 행위이다. 통상적인 프로젝트에서 소프트웨어 분석 행위는 최초의 도출 과정부터 변경관리의 마지막 단계까지 시간에 따라 계속 진화한다. Top-down 분석과 디자인 모델링의 상위기법과 Bottom-up 구현과 Refactoring 방식의 하위기법의 두 가지 방식이 중간 지점에서 만나도록 해서 두 방식의 좋은 점만을 이용할 수도 있다. 그러나 현실적으로 이런 두 가지 방식의 조합은 소프트웨어 엔지니어들의 경험과 성숙도가 최대한도로 요구되므로 어렵다. &lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 앞 쪽에서 필자가 걱정한 것 중의 하나가 SWEBOK이 요구사항이 변할 수 있다고 하는 것이다. 여기서는 한 술 더 떠서 변경 가능성이 아니라 요구사항은 필연적으로 변경된다고 얘기한다. 그럼 변경은 기정사실화 하고 변경이 되기 때문에 요구사항 분석을 대충 하는 것이 좋은가 하는 착각을 하게 된다. 반대로 생각하면 변경이 될 것이기 때문에 그에 대비해서 먼저 분석을 잘해 놓고 나중에 변경 추적, 영향력 분석 등 중요한 이슈들을 분석하고 변경에 대한 대책을 세울 수 있어야 한다. 최초의 SRS가 없다면 변경 시에 더 어려운 일을 당하게 된다. 만약에 요구사항이 전혀 변하지 않고 차라리 문서를 작성하지 않아도 피해가 적다. 결론은 변경이 벌어질 것이기 때문에 SRS를 더 잘 작성해 놓아야 한다. &lt;/div&gt;&lt;br /&gt;&lt;br /&gt;7.2 Change Management (변경관리)&lt;br /&gt;&lt;br /&gt;변경관리는 요구사항 관리의 중심이 되는 토픽이다. 이 토픽은 변경관리의 역할, 프로세스, 변경 내용에 대한 분석 방법에 대한 이슈를 다룬다. Software Configuration Management KA 에서 관련 내용을 다룬다.&lt;br /&gt;&lt;br /&gt;7.3 Requirements Attributes (요구사항 속성)&lt;br /&gt;&lt;br /&gt;SRS는 요구되는 사양만을 포함하는 것이 아니라 그 외 부수적인 정보들도 포함한다. 부수적인 정보는 요구사항을 관리하고 이해하는 것을 돕는 역할을 한다. 그 중에는 여러 관점에서 본 분류체계(Section 4.1 Requirements Classification), 검증 방법, 관련된 인수테스트계획 등이 있다. 또 각 요구사항이 나온 배경, 요구사항의 근원, 변경 이력 등도 포함된다. 그 중에서도 가장 중요한 속성은 각 요구사항을 식별할 수 있는 고유한 아이디(ID)이다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 결국은 나올 수 있는 것은 다 나온다. 각 요구사항을 추적하려면 당연히 고유한 ID가 있어야 한다. 하지만 이런 행위도 요구사항이 적절한 단위로 세세히 나누어지고 잘 분류되어 있을 때 유용한 것이지 수시로 변하거나 대충 큰 단위로 분류를 해 놓았다면 얻는 것보다 시간 낭비할 가능성이 크다. 결국 기본이 되어 있지 않으면 소프트에어 공학에서 말하는 기법을 무조건 사용하는 것은 혜택보다는 피해가 크다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;7.4 Requirements Tracing (요구사항 추적)&lt;br /&gt;&lt;br /&gt;요구사항 추적은 요구사항의 근원이 무엇이고 어느 곳에 영향을 미치는 가를 알게 한다. 특히 요구사항이 변경될 때의 영향도 평가에 필수적이다. 요구사항은 뒤로는 시스템 요구사항과 같이 생성의 근원과 요구한 이해관계자들을 인식할 수 있도록 한다. 반대로 앞으로는 그 요구사항을 만족시키는 설계, 소스코드, 테스트 케이스, 심지어는 사용자 매뉴얼의 어떤 부분과 관련이 있는지 까지 추적할 수 있어야 한다.&lt;br /&gt;&lt;br /&gt;요구사항 추적은 통상적으로 복잡한 Directed Acyclic Graph(비순환 방향성 그래프, DAG) (Computing Foundation KA참조) 를 형성한다. 이런 DAG나 추적 매트릭스를 관리하는 행위는 전체 생명주기에서 필수적으로 고려해야 하는 행위이다. 만약에 추적표가 제대로 갱신되지 않는다면 영향도 평가를 신뢰할 수 없다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 요구사항 추적이 필요하다고 얘기하지만 현실적으로 국내에서 요구사항 추적을 할 정도로 SRS를 잘 적을 수 있는 회사가 있을 까 궁금하다. 기능요구사항은 비기능요구사항에 비해 상대적으로 쉬운 편이다. 실리콘밸리에서도 제대로 하기 어렵고 그래서 잘 이용하지 않는 것이 요구사항 추적이다. 추적을 하라고 하기도 난감하고 하지 말라고 말하기도 난감하다. 특히 대기업일 경우 소프트웨어 공학의 도입에 따라 비싼 도구를 이용해서 시도를 하기도 하지만 그 신뢰성과 효과는 미지수이다. 추적을 하느냐 안하느냐를 결정하기 전에 먼저 SRS를 제대로 적으면서 수 년의 경험을 한 다음에서야 추적을 시도할 것을 권장한다. 프로세스가 요구하니까 무조건 시도했다가는 시간만 낭비하기 딱 좋은 주제이다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;7.5 Measuring Requirements (요구사항 측정)&lt;br /&gt;&lt;br /&gt;소프트웨어의 프로젝트에서 어떤 요구사항이 있으면 Volume(&quot;양&quot;) 에 관한 개념을 가져야 한다. 이 개념은 개발에 드는 비용, 유지보수에 드는 비용, 변경에 드는 비용의 규모를 측정하는데 필요하다. 또 다른 요구사항과 상대적으로 비교할 필요가 있을 때도 유용하다. Functional Size Measurement (FSM, 기능크기측정)이 Function의 규모를 측정하는 기법이다. 이와 관련된 정보는 Software Engineering Process KA에서 다룬다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 어떤 요구사항이 있을 때 개발비용과 일정이 얼마나 걸릴까 하는 것은 경영진과 관리자의 최고 관심사이다. 그러니 이 토픽이 소프트웨어 공학에서 없어질 수가 없다. 하지만 이론적이고 수학적인 방법이 과연 가능할까 하는 회의가 든다. 이론적인 소프트웨어 공학자들이 측정이론을 주장해도 일단 필자는 믿지 않는다. 이 부분은 인간의 고유 영역이라고 본다. 규모를 측정하고 일정을 산정할 때의 가장 큰 변수는 누가 개발하는 것이냐 이다. 모든 개발자들의 역량이 다른데 그 상황에 따라서 산정을 다르게 해야 한다. 개발이 끝난 후에 SLOC(소스코드 라인수)나 Function Point를 이용해서 비교하기도 하지만 난이도를 고려하지도 않고 코딩 스타일에 따라 천차만별이기 때문에 큰 의미를 부여할 수 없다. 그럼에도 불구하고 휴대폰에 들어간 소스코드가 몇백만 라인이다 라는 식으로 말할 때는 대충 규모를 판단하는 데 도움이 된다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: red;&quot;&gt;&lt;br /&gt;8. Software Requirements Tools (도구)  - 다음 Post에서 다룬다&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/3599381572112569461/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=3599381572112569461' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/3599381572112569461'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/3599381572112569461'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2014/08/swebok-8.html' title='SWEBOK - 소프트웨어 요구사항 #8'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-6480004322041460139</id><published>2014-08-10T05:35:00.000-07:00</published><updated>2015-11-28T01:54:04.778-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="SWEBOK(소프트웨어 지식체계)"/><category scheme="http://www.blogger.com/atom/ns#" term="분석/요구사항"/><category scheme="http://www.blogger.com/atom/ns#" term="소프트웨어공학"/><title type='text'>SWEBOK - 소프트웨어 요구사항 #7</title><content type='html'>&lt;script type=&quot;text/javascript&quot;&gt;// &lt;![CDATA[&lt;br/&gt;(function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,&#39;script&#39;,&#39;//www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);   ga(&#39;create&#39;, &#39;UA-50709339-1&#39;, &#39;ikwisdom.com&#39;);   ga(&#39;send&#39;, &#39;pageview&#39;);&lt;br/&gt;// ]]&gt;&lt;/script&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;SWEBOK 해설 Software Requirements #7&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 지금까지 요구사항의 도출, 분석을 지나 명시(Specification) 했다. 이제는 내가 명시한 것이 맞는 것인지를 어떻게 증명하는 검증단계에 왔다. 여기서 대충 넘어가면 재앙이 벌어진다. 바로 소프트웨어공학의 1:10:100 법칙에 따른 피해가 벌어진다. 이 단계를 게을리 하면 잘못된 정보를 가지고 다음 단계인 설계를 열심히 하게 된다. 잘못 명시된 요구사항을 설계 단계에서 발견하면 그나마 다행히도 10배의 피해만 입게 된다. 즉 오류를 수정하는 데 들어가는 비용이 10배가 든다. 그 다음 단계인 코딩 단계에서 발견되면 100배의 비용이 들어 간다. 테스트 단계에서 발견되면 1000배의 비용이 들어간다. &lt;br /&gt;&lt;br /&gt;쉽게 이해하려면 건축을 생각하면 된다. 건물을 설계단계의 종이에서 고칠 때와 다 만들어 놓고 고칠 때를 상상해 보면 된다. 이론으로 아는 사람은 많지만 실제 벌어지는 국내 프로젝트에서는 똑같은 시행착오를 지금까지 일이십년을 반복해 오고 있다. 그 이유에는 수십가지가 있지만 모두 다 잘못된 핑계에 불과하다. 필자의 책에서도 누누이 얘기하지만 고쳐지지는 않는다. 유일하게 키움증권의 차세대 프로젝트가 제대로 된 SRS를 작성하고 필자가 아는 한 국내에서 처음으로 제 일정에 완성한 프로젝트였다. 필자의 주장을 증명한 케이스이기도 하다.  이에 관해 지디넷(zdnet)에 실린 기사이다.&lt;br /&gt;&lt;br /&gt;http://www.zdnet.co.kr/news/news_view.asp?artice_id=20140728162641&amp;amp;type=xml &lt;/div&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;&lt;br /&gt;지금까지의 국내 관행대로 똑같은 방법으로 진행한 프로젝트는 모두 일정연기라는 똑같은 결과를 가져왔고 필자의 주장대로 수행한 유일한 프로젝트는 성공했다. 사실은 필자의 주장이 아니라 IEEE의 전문가들 혹은 실리콘밸리의 회사들의 평범한 관행일 뿐이다. 기본을 무시하고는 어떤 것도 잘 될 수는 없다는 것을 보여준다. 건축, 자동차, 전자, 소프트웨어나 모두 다 같다.&lt;br /&gt;&lt;br /&gt;앞 단계의 명시단계에서 오류를 범했더라도 아직도 늦지 않았다. 아직은 종이 서류에 불과하고 공사는 시작하지 않았으니 피해 없이 고칠 수 있는 마지막 기회다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;1장 Software Requirements (소프트웨어 요구사항)&lt;br /&gt;1. Software Requirements Fundamentals (소프트웨어 요구사항의 본질)&lt;br /&gt;2. Requirement Process (요구사항 프로세스)&lt;br /&gt;3. Requirement Elicitation (요구사항 도출) &lt;br /&gt;4. Requirements Analysis (분석) &lt;br /&gt;5. Requirements Specification (명시) &lt;br /&gt;&lt;strong&gt;6. Requirements Validation (검증)&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;작성된 요구사항 문서(SRS)는 검증(Validation)과 테스트(Verification)을 해야 한다. 즉 작성한 소프트웨어 엔지니어가 요구사항을 제대로 이해했다는 것을 검증해야 한다. 더 나아가 문서가 회사의 표준에 맞게 작성되어 있고, 이해할 수 있고, 일관성 있고, 완성도 있게 작성되었다는 것을 검증하는 것도 중요하다. 회사의 표준 용어가 외부의 표준 용어와 다르게 사용된다면 그 두 용어 사이의 매핑 테이블을 만들어야 한다. 이런 점에서 누구나 다 이해하는 표준인 공식적인 표기법(Formal Notation)의 방식을 이용해서 작성했다면 매핑 테이블 같은 것을 만들지 않아도 되는 장점이 있다. 고객과 개발자 등을 포함한 모든 이해관계자들이 문서를 검토해야 한다. 이 문서는 소프트웨어 생명주기에 나오는 모든 산출물(설계문서, 소스코드등) 과 동일한 수준으로 그리고 동일한 방법으로 형상관리를 해야 한다. 요구사항관리도구를 이용해서 요구사항 문서를 만드는 경우에도 마찬가지의 형상관리를 해야 한다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 형상관리를 소스코드 관리로 한정해서 생각하는 개발자들이 많지만 사실은 요구사항문서(SRS)가 소스코드만큼 중요하기 때문에 철저한 형상관리(여기서는 버전관리를 의미) 해야 한다. 하지만 대부분의 국내 프로젝트는 SRS는 버전관리를 할 만큼 정확하게 적히지도 않고 소스코드와 내용이 일치되지도 않기 때문에 버전관리를 하나 안하나 의미가 없다. SWEBOK에서 말하는 SRS를 형상관리하라는 말은 글로벌 수준의 회사를 기준으로 말하는 것이고 그렇지 않은 회사는 형상관리 하느라 노력한 대가도 없고 그냥 관리비용만 늘어가니 국내에서는 적당히 형식적으로만 하면 될 것이다. 항상 그렇지만 내용이 충실하면 관리가 중요해 지지만 내용이 부실하면 관리를 해도 의미가 없다. 그냥 형식적인 회사 프로세스에서 형상관리를 요구한다면 역시 형식적으로 흉내만 내면 된다. 그래서 기초가 부족한 상태에서 프로세스를 도입한다고 해야 시간과 비용만 들고 피해만 입는다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;적어도 한 번 이상의 검증을 해야 하고 그 검증을 위한 회의 일정을 공식적으로 미리 정해 놓고 하는 것이 정상이다. 근본적인 목적은 개발자원이 투입되기 전에 문제가 있는 지를 찾아내는 것이다. 다시 말하지만 검증(Validation)은 요구사항문서가 우리가 원하는 소프트웨어를 정확하게 제대로 정의했는지를 조사하는 것이다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) SRS는 필자의 경험으로 Full Review를 적어도 2번 이상은 해야 한다. 한 번에 통과한다는 것은 기적이다. 아직까지 한 번도 본 적이 없다. 가장 잘 적은 경우의 시나리오는 한 번 검토하고, 검토한 결과에 따라 수정하고, 두 번 째 회의에 모여 모든 이해관계자가 승인해 주는 경우이다. 두 번에 통과하기도 매우 어렵다. 여기서 통과하느냐 마느냐 하는 것도 SRS 내용을 자세히 적었을 때 어려운 것이다. 차라리 내용이 대충 추상적으로 제목 정도만 적혀 있으면 통과하기는 쉽다. 대충 적힌 문서는 시비를 걸기 어렵기 때문이다. 나중에 문제가 생겨서 그렇지 일단 SRS는 통과한다. 나중에 수백 배의 피해를 입는 조삼모사이다. 국내 기준으로 보면 RFP 혹은 기획서 정도의 내용이 적힌 문서가 계약에서 통과된다. 그런 것을 SRS 검증이라고 얘기 할 수는 없다. 결국 진정한 SRS는 한 번도 검증되지 않은 상태에서 설계나 코딩이 벌어지게 되는 것이 국내 현실이다. SWEBOK이 가정한 개발 환경과 실제 국내 환경과는 갭이 크니 그걸 감안해서 잘 해석해야 한다.  &lt;/div&gt;&lt;br /&gt;&lt;br /&gt;6.1 Requirement Review (요구사항 검토)&lt;br /&gt;&lt;br /&gt;검증에서 가장 많이 사용되는 방법은 조사(Inspection) 혹은 검토(Review)이다. 여러 명의 검토자 들에게 오류, 잘못된 가정, 불명확한 설명, 비표준적인 내용 등을 찾도록 부탁한다. 검토자 그룹의 멤버가 중요한데 예를 들어 적어도 한 명의 고객대표가 참석해야 한다. 검토하기 쉽도록 체크리스트 같은 가이드가 도움이 되기도 한다. 통상적으로 검토는 시스템 정의서 (System Definition), 시스템 사양서(System Specification), SRS(Software Requirements Specification) 이 완성된 다음에 진행된다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) SWEBOK에서 체크리스트가 있으면 도움이 될지도 모른다고 했는데 이 부분을 잘못 해석하면 체크리스트에 있는 Yes/No 형식의 답을 한다고 생각하면 오산이다. 체크리스트가 제공해 주는 것은 검토를 해야 할 주제를 혹시라도 빼먹지 않도록 하는 것이지 검토 자체를 도와주는 것이 아니다. 예를 들어 &quot;문서의 가독성&quot;을 검토해야 하는데 Yes/No 로 대답한다면 잘못된 것이다. 체크리스트는 올바른 검토를 하기 위해 필요한 가이드이지 체크리스트가 없어서 검토를 못하는 것도 아니고 체크리스트가 있다고 해도 검토를 제대로 하는 것은 더군다나 아니다. 여행 준비물 체크리스트 정도의 의미라고 생각하면 된다. 필자에게 템플릿과 체크리스트를 보여달라고 하는 개발자들이 많은데 검증의 품질과는 거의 관계가 없다는 것을 알기 바란다.  &lt;/div&gt;&lt;br /&gt;&lt;br /&gt;6.2 Prototyping (프로토타이핑)&lt;br /&gt;&lt;br /&gt;프로토타이핑은 개발자가 어떻게 사양을 이해했는가를 검증하는 방법이다. 겸사겸사 눈에 잘 보이니 새로운 요구를 추가하기 쉽기도 하다. 요구사항 도출(Elicitation) 때와 마찬가지로 프로토타입이 효율적으로 사용될 수 있는 부분이 있다. 프로토타입의 장점은 개발자가 어떻게 이해했는가를 볼 수 있는 가장 좋은 방법이고 동시에 무엇이 잘못되었는지를 발견하고 의견을 주기에도 적합하다. 동적인 유저인터페이스를 글로 설명하기는 어렵운 반면에 동적인 애니메이션이 훨씬 더 잘 설명할 수 있다. 프로토타입으로 검증된 요구사항이 수정될 가능성은 매우 낮은 것이 장점이다. 안전요구사항이나 중요한 핵심적인 기능들은 프로토타이핑을 해보는 것이 중요하다. 하지만 프로토타이핑의 단점도 있다. 사용자들이 미적인 이슈에 사로 잡혀 진정한 기능을 게을리 볼 수 있는 위험성도 있고 프로토타이핑의 품질이 나쁘다는 데 있다. 그래서 프로토타이핑 보다는 시나리오북 (Flip-chart based mockup) 같은 방식을 선호하기도 한다. 프로토타입은 개발비용이 많이 든다. 그렇더라도 나중에 잘못된 소프트웨어를 개발하는 것보다는 프로토타이핑을 하는 것이 좋을 수도 있다. 만약 프로토타입이 최종 제품과 비슷한 모습을 가지고 있다면 꼭 버릴 필요는 없다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) SWEBOK에서 프로토타이핑한 결과를 100% 버려야 한다고 주장할 수는 없는 상황이기 때문에 프로토타입을 실제 제품에 사용할 수도 있다고 하지만 필자의 경험으로는 프로토타입은 버리는 것이 옳다. 프로토타입은 가장 신속히 개발해서 SRS를 검증하는 것이 목표이기 때문에 한가하게 아키텍처 생각하고, 주석 달고, 공통코드 추출하고, 에러처리하고, 등등 할 시간이 없다. 그런 코드를 나중에 그대로 써 먹는다는 것은 얻는 것보다 잃는 것이 많다. 물론 프로토타입에 사용한 코드의 일부분을 사용하는 것은 문제가 없지만 프로토타입은 말 그대로 모형이다. 아파트 모델하우스를 고쳐서 실제 살 집을 만들지 않는 것과 같이 프로토타입은 100% 버린다고 생각해라.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;6.3 Model Validation (모델 검증)&lt;br /&gt;&lt;br /&gt;분석과정 중에 모델 기법을 사용했다면 모델의 품질을 검증하는 것이 필요하다. 예를 들어 객체모델(Object Model)인 경우 정적 분석(Static Analysis)을 통해 객체간에 어떤 데이터가 움직이는 지와 같은 것을 검증할 수 있다.  만약 공식표기법(Formal Notation)이 사용되었다면 공식적인 로직에 기반한 검증방법을 사용하는 것이 가능하다. 이 부분은 Software Engineering Models and Methods KA 와 밀접하게 관련되어 있다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 이 꼭지는 대부분의 독자는 건너 뛰어도 된다고 생각한다. 그 이유는 통상적인 SRS에서는 설계의 상위부분을 다루게 되는데 그럴 경우에 Modeling 기법도 사용하고 Formal Notation도 도입할 수 있는데 국내에서는 SRS 단계에서 그 정도까지 생각하는 경우가 거의 없기 때문에 이 꼭지는 거의 의미가 없다. 모델링은 설계단계에서 수행하는 것이라는 흑백논리의 오류인 것이다. 이 점은 앞 단계에서도 이미 언급되었지만 분석이나 설계단계에서 할 일이 흑백논리로 정해지는 것이 아니고 경우에 따라 원칙을 잘 적용하는 것이 실용주의인 소프트웨어공학을 잘하는 것이다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;6.4 Acceptance Tests (인수 테스트)&lt;br /&gt;&lt;br /&gt;소프트웨어 요구사항의 필수적인 단계는 개발이 요구사항에 적힌 그대로 개발이 완료되었냐는 것을 확인하는 것이다. 확인될 수 없는 요구사항은 희망사항(Wishes)에 불과하다. 그러므로 확인하기 위해서 꼭 필요한 일은 어떻게 확인할(Verify) 지를 계획하는 것이다. 대부분의 경우에 인수테스트(Acceptance Test)를 사용한다. &lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 확인(Verify)하기 위해서는 확인할 대상이 정확이 명시되어 있어야 한다. 확인할 대상이 대충 적혀 있다면 확인을 아무리 잘한다고 한들 의미가 없다. 그래서 필자가 책에서도 말했지만 세계적인 테스트팀이 와도 SRS가 잘 적혀있지 않다면 소프트웨어 품질이 좋아지지 않는다고 하는 이유이다. 하여튼 일단 테스트를 잘 하는 것은 일부라도 품질을 높이기 위해서는 중요하다. 근래 많이 사용하는 테스트 방법론인 V-Model 혹은 V-testing model을 보면 인수테스트 외에도 많은 종류의 테스트가 있다. 확실한 것은 SRS에 대응되는 테스트는 인수테스트이고 인수테스트가 바로 계약에 사용되는 문서이다. 다른 테스트는 계약에 필요한 것이 아니고 개발을 진행하면서 중간에 필요한 테스트들이다. 고객에게 약속한 최종사양은 인수테스트에서 모두 명시되어야 하고 인수테스트만 통과하면 계약은 종료된다.  &lt;/div&gt;&lt;br /&gt;&lt;br /&gt;인수테스트를 도출하고 설계하는 것이 비기능요구사항 (Nonfunctional Requirements) 의 경우에 매우 어렵다. 검증이 가능하려면 먼저 충분히 분석되고 작은 컴포넌트로 나누어지고 숫자적으로 표현될 수 있어야 한다. Software Testing KA 에서 인수테스트에 관한 추가정보를 얻을 수 있다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) SRS를 적성할 때 요구사항 종류에는 기능요구사항과 비기능요구사항이 있는데 비기능요구사항은 생각해 내기도 쉽지 않다. 생각해 내기도 어려운 데 테스트 하기도 어렵다. 특히 초보자들은 잘 모르니까 &quot;빨리&quot; &quot;사용하기 용이한&quot; 등 추상적인 용어를 사용하게 된다. 그런 용어는 SRS를 적을 때 절대 사용하면 안 되는 감점요인이다. 그리고 프로젝트 실패 중에서도 큰 실패의 원인은 대부분 비기능요구사항의 부족에서 발생한다. 조금이라도 비기능요구사항의 완성도를 높이기 위해서는 많은 실무 경험이 있어야 한다. 비기능요구사항은 템플릿이나 체크리스트조차 만들기 어렵다. 비싼 상용도구를 사용하더라도 도움이 될 수준까지 자세히 가르쳐 줄 수가 없다.  그러다 보니 국내 대부분의 프로젝트는 아예 비기능요구사항을 적지도 않고 진행하기도 한다. 하여튼 비기능요구사항을 충분히 자세히 적을 수 있다면 이미 글로벌 개발 역량을 가지고 있는 것이다. 즉 SWEBOK을 읽을 것이 아니라 SWEBOK을 작성할 수 있는 수준일 것이다. 그만큼 어려운 것이 비기능요구사항의 작성이다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: red;&quot;&gt;&lt;br /&gt;7. Practical Considerations (현실적인 고려사항) - 다음 Post에서 다룬다&lt;/div&gt;&lt;br /&gt;8. Software Requirements Tools (도구)&lt;br /&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/6480004322041460139/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=6480004322041460139' title='2개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/6480004322041460139'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/6480004322041460139'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2014/08/swebok-7.html' title='SWEBOK - 소프트웨어 요구사항 #7'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-6335225728089980011</id><published>2014-07-26T09:32:00.000-07:00</published><updated>2015-11-28T01:01:19.991-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="SWEBOK(소프트웨어 지식체계)"/><category scheme="http://www.blogger.com/atom/ns#" term="소프트웨어 공학"/><title type='text'>SWEBOK - 소프트웨어 요구사항 #6</title><content type='html'>&lt;script type=&quot;text/javascript&quot;&gt;// &lt;![CDATA[&lt;br/&gt;(function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,&#39;script&#39;,&#39;//www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);   ga(&#39;create&#39;, &#39;UA-50709339-1&#39;, &#39;ikwisdom.com&#39;);   ga(&#39;send&#39;, &#39;pageview&#39;);&lt;br/&gt;// ]]&gt;&lt;/script&gt;&lt;br/&gt;&lt;br/&gt;&amp;nbsp;&lt;br/&gt;SWEBOK 해설 Software Requirements #6&lt;br/&gt;&amp;nbsp;&lt;br/&gt;&lt;p style=&quot;color: blue;&quot;&gt;&lt;br/&gt;(***필자주석) 요구사항의 도출, 분석을 지나 명시(Specification)하는 단계에 왔다. 여기에서 SWEBOK의 본질이 무엇인지를 다시 회상해 보자. SWEBOK은 가이드이다. 방법을 가르쳐 주는 문서가 아니다. 가이드 없이 방법을 준다면 시행착오는 필연적이다. 필자의 경험으로 보면 SWEBOK과 같은 가이드는 인생의 가이드와 같다. 그 가이드 아래에서 학교를 가야겠다든지 전공을 전산학을 하겠다든지 하는 큰 골격이 생긴다. 그 골격을 따라가다 보면 실제 실행할 자세한 내용이나 따라 할 모델이 필요하다. 그런 모델이 소프트웨어 요구사항에서는 템플릿이나 샘플이라고 할 수 있다. 하지만 모델이 있다고 혼자서 배울 수 있는 것은 아니고 학교와 같이 스승이 필요하다. &lt;br/&gt;&amp;nbsp;&lt;br/&gt;SWEBOK은 방법이 아니라 가이드이다. 매우 중요한 가이드이지만 경험 없이 SWEBOK이 말하는 문장이나 단어를 공감하고 가슴으로 느끼기는 쉽지 않다. 그렇지만 지속적으로 인식하고 있어야 나중에 경험을 할 때 진정으로 도움이 된다. Chicken-and-Egg 문제이다. 필자도 실리콘밸리에서 많은 경험을 먼저 하고 나서 SWEBOK을 나중에 접했기 때문에 진정으로 공감을 할 수 있었지만 독자의 경험의 정도에 따라서 별 도움이 되지 않을 수도 있다는 생각을 한다. 특히 1,2년 경험의 개발자들에게 SWEBOK이 도움이 될지는 회의적이다. 마치 유치원생에게 명심보감을 가르치는 상황과 같다. 그런 경우에 지속적으로 가르쳐서 외우게 하여 인생관을 형성한 것이 선조들의 지혜로운 교육방법이었다. 경험이 없는 상태에서 &quot;왜&quot; 해야 하는 지를 이해하기 어려운 상황에서는 외우는 것이 가장 좋은 가르침의 방법이다. 필자가 태극권을 배우면서 초보자들은 &quot;왜&quot; 를 물어보지 않고 관장님이 시키는 대로 그냥 따라 하는 것이 가장 좋은 배움의 방법이라는 것을 나중에 깨달았다. 경험의 정도에 상관 없이 혹은 지금 얼마나 공감하는 지에 상관없이 SWEBOK을 읽고 또 읽고 하는 것은 결국은 누구에게나 도움이 된다고 생각한다.&lt;br/&gt;&amp;nbsp;&lt;br/&gt;&lt;/p&gt;&lt;br/&gt;1. Software Requirements Fundamentals (소프트웨어 요구사항의 본질)&lt;br/&gt;2. Requirement Process (요구사항 프로세스)&lt;br/&gt;3. Requirement Elicitation (요구사항 도출) &lt;br/&gt;4. Requirements Analysis (분석) &lt;br/&gt;5. Requirements Specification (명시) &lt;br/&gt;&amp;nbsp;&lt;br/&gt;대부분의 엔지니어링 전문가들에게는 &quot;명시(Specification)&quot; 라는 용어는 제품의 목표를 숫자로 표현하는 것을 의미한다. 소프트웨어 공학에서는 Software Requirements Specification(SRS)는 &quot;시스템적으로 검토될 수 있고 평가될 수 있고 승인될 수 있는 문서&quot; 를 의미한다. 하드웨어 컴포넌트를 포함하는 복잡한 시스템에서는 System Definition (시스템 정의서), System Requirements (시스템 요구사항), 그리고 Software Requirements(소프트웨어 요구사항)과 같은 3가지 종류의 문서가 작성되기도 한다. 간단한 소프트웨어 제품의 경우에는 세 번 째 문서인 소프트웨어 요구사항만 작성이 된다. 이 꼭지에서는 이 3가지 종류의 문서가 적절히 조합해서 사용될 수 있도록 모두에 대해서 설명한다. System Engineering은 SWEBOK의 다른 챕터인 &quot;Related Disciplines of Software Engineering&quot; 에서 설명된다.&lt;br/&gt;&amp;nbsp;&lt;br/&gt;&lt;p style=&quot;color: blue;&quot;&gt;&lt;br/&gt;(***필자주석) 위에서 3가지 종류의 문서라고 말하는데 그 문서들을 하나씩의 파일로 착각하기 쉽다. 아주 간단한 소프트웨어의 경우에는 하나의 파일로 충분할 수도 있지만 보통은 하나의 파일이 아니라 여러 개의 단위 문서가 집합해서 만들어진 문서의 집합을 말한다. 예를 들어 SRS만 해도 비행기와 같은 거대한 시스템을 만들 때에는 수십개, 수백개, 수천개의 문서로 만들어 지기도 한다. 그 중의 한 부류가 필자가 계속 SRS와 다르다고 언급하는 기능명세서(Functional Description)이다. 기능명세서는 SRS의 극히 일부분일 뿐이다. 각 회사나 정부기관마다 SWEBOK이 말하는 원칙은 모두 동일하게 따르지만 실제 문서의 이름들은 다 다를 수 있다. 실제로 필자는 문서 이름까지 같은 회사는 경험해 본 적이 없다. 즉 모든 회사마다 사용하는 템플릿은 다 상이하다는 얘기이다. 하지만 원칙과 내용은 동일하니 한 회사에서 SRS를 적을 수 있으면 다른 회사에 가서도 SRS를 무난히 적을 수 있다.&lt;br/&gt;&lt;/p&gt;&lt;br/&gt;&amp;nbsp;&lt;br/&gt;&lt;br/&gt;5.1 System Definition Document (시스템 정의)&lt;br/&gt;&amp;nbsp;&lt;br/&gt;가끔 &quot;사용자 요구사항 문서 (User Requirements Document)&quot; 혹은 &quot;운영문서(Operations Document)&quot;이라고 부르기도 하는 문서인데 시스템의 요구사항을 적는 문서이다.&lt;br/&gt;&amp;nbsp;&lt;br/&gt;이 문서는 산업 도메인의 관점에서 상위 수준의 시스템 요구사항을 적는다. 이 문서는 시스템 사용자나 고객 혹은 회사의 마케팅부서(대중에게 파는 소프트웨어인 경우)의 관점을 대표한다. 그러므로 여기에 사용하는 용어도 기술이 아닌 산업 도메인의 관점에서 사용해야 한다. 다음과 같은 내용이 적힌다.&lt;br/&gt;&amp;nbsp;&lt;br/&gt;* 시스템 요구사항&lt;br/&gt;* 목표와 배경&lt;br/&gt;* 운영될 환경 (Target Environment)&lt;br/&gt;* 제약 사항 (Constraints)&lt;br/&gt;* 가정 (Assumptions)&lt;br/&gt;* 비기능 요구사항 (Non-Functional Requirements)&lt;br/&gt;* 시스템 전체를 이해할 수 있는 개념 모델(Conceptual Model)&lt;br/&gt;* 사용 시나리오 (Usage Scenario)&lt;br/&gt;* 주요 조직과 사용 워크플로어(Workflow)&lt;br/&gt;&amp;nbsp;&lt;br/&gt;&lt;p style=&quot;color: blue;&quot;&gt;&lt;br/&gt;(***필자주석) 개발자 경험에 따라 각 항목에 무슨 내용을 적어야 할지 모르는 경우가 많다. 첫번째 항목인 시스템 요구사항은 기능을 적는다고 가정하고 나머지 항목들은 왜 필요한지 조차도 인식하기가 쉽지 않다. 하지만 현실에서 큰 문제가 생기고 외국에서 소송의 대상이 되는 것들은 기능이 아니고 기능 외의 것들이다. 기능은 모든 사람들이 신경 쓰고 있기 때문에 빠뜨리기가 어렵다. 하지만 다른 것들은 무엇을 적는 것인지도 잘 모르는 상태에서 실제 적어야 할 것의 극히 일부분만 적는 경우도 생긴다. 불행히도 책에서는 원칙적인 가이드를 줄 수 있을 뿐 구체적인 항목을 나열해 줄 수는 없다. 모든 소프트웨어가 다르기 때문이다. 그래서 원칙을 특정한 자신의 환경에 적용할 수 있는 응용 능력이 필요하고 그 응용능력은 경험에서 나온다. 이런 역량을 학교나 학원이나 정부기관에서 가르칠 수는 없는 것이다.&lt;br/&gt;&lt;/P&gt;&lt;br/&gt;&amp;nbsp;&lt;br/&gt;5.2 System Requirements Document (시스템 요구사항)&lt;br/&gt;&amp;nbsp;&lt;br/&gt;비행기와 같이 소프트웨어와 하드웨어가 같이 필요한 시스템을 개발하는 사람들은 소프트웨어 요구사항과 시스템 요구사항을 따로 적는 것이 통상적이다. 이런 방식에서는 시스템 요구사항을 먼저 적고 거기서 소프트웨어 요구사항이 파생되어 나온다. 엄격하게 말하면 System Requirements Specification은 시스템공학(System Engineering)의 분야이고 소프트웨어 가이드인 SWEBOK의 영역 밖이다.&lt;br/&gt;&amp;nbsp;&lt;br/&gt;&lt;p style=&quot;color: blue;&quot;&gt;&lt;br/&gt;(***필자주석) 바로 위에서 &quot;엄격히 말하면 System은 SWEBOK의 영역이 아니다&quot;라고 말하지만 사실은 System이나 Hardware나 Software나 모두 Requirements나 Specification을 적는 원칙도 같고 유사한 분석 역량을 필요로 한다. 다만 도메인 영역이 다르므로 거기서 특성의 차이가 있기 때문에 다르다고 할 수 있지만 현실적으로는 90% 이상이 같다. Template도 비슷하고 문서의 구조도 비슷하고 많은 경우에 똑같은 Template을 사용하기도 한다. 필자의 이전 책인 &quot;글로벌 소프트웨어를 꿈꾸다(2010년)&quot;에서 차이점과 유사점에 대해 설명한 적이 있다.&lt;br/&gt;&lt;/p&gt;&lt;br/&gt;&amp;nbsp;&lt;br/&gt;5.3 Software Requirements Specification (SRS, 소프트웨어 요구사항 명세서)&lt;br/&gt;&amp;nbsp;&lt;br/&gt;이 Specification 행위가 끝나면 나오는 산출물이 바로 SRS이다. 이 SRS는 다음의 행위를 하기 위한 기반으로 이용된다.&lt;br/&gt;&amp;nbsp;&lt;br/&gt;* 고객과 개발자와 계약에 사용된다. 대중에게 파는 제품을 만드는 경우에는 회사의 마케팅부서와 동의를 해야 한다. 제품에서 구현 할 것과 구현하지 않을 것을 명시한다.&lt;br/&gt;&amp;nbsp;&lt;br/&gt;&lt;p style=&quot;color: blue;&quot;&gt;&lt;br/&gt;(***필자주석) 여기서 무엇을 구현할 것을 적는 것은 당연한데 무엇을 구현하지 않겠다는 것이 생소해 보일 지 모르나 무척이나 중요하다. 개발외주 소송의 원인의 많은 부분을 차지하는 것이 무엇을 안 하겠다는 것을 계약서에 확실히 얘기하지 않았기 때문이다. 예를 들어 우리 제품은 &quot;한글, 영어, 중국어를 지원한다&quot;라고 적으면 정확한 의미를 전달하지 못한다. &quot;한글, 영어, 중국어 외에는 어떤 언어도 절대 지원하지 않는다&quot; 라고 적어야 조금은 더 정확한 의미를 전달할 수 있다. 이 문장만 해도 아직 더 자세히 적어야 할 것이 많지만 나중에 SRS 작성법을 가르치게 되면 그 때에 설명하기로 하고 이것은 가이드인 만큼 여기서 중단한다.&lt;br/&gt;&lt;/p&gt;&lt;br/&gt;&amp;nbsp;&lt;br/&gt;* 설계가 시작되기 전에 철저한 평가를 통해 나중에 재설계가 벌어지는 일을 줄인다.&lt;br/&gt;&amp;nbsp;&lt;br/&gt;&lt;p style=&quot;color: blue;&quot;&gt;&lt;br/&gt;(***필자주석) 분석과 설계를 대충하고 날코딩으로 들어갈 때의 문제가 바로 재설계와 재구현이다. 잘못된 관행을 고치는 방법도 모르고 관행적으로 그렇게 하고 있는 것이 불행한 현실이다. 열심히는 일하지만 비효율적이고 품질도 낮아진다.&lt;br/&gt;&lt;/p&gt;&lt;br/&gt;&amp;nbsp;&lt;br/&gt;* 검증(Verification)과 테스트(Validation)를 위한 목적으로 사용한다.&lt;br/&gt;&amp;nbsp;&lt;br/&gt;&lt;p style=&quot;color: blue;&quot;&gt;&lt;br/&gt;(***필자주석) 용어의 혼동을 피하기 위해 설명하자면 Verification은 무엇을 구현할 것인가를 검증하는 것이고 Validation은 구현하기로 약속한 것을 제대로 구현했는지를 검증하는 것이다. 즉 Verification은 스펙검토이고 Validation은 테스트이다.&lt;br/&gt;&lt;/p&gt;&lt;br/&gt;&amp;nbsp;&lt;br/&gt;* 소프트웨어 제품을 고객에게 설명하는 목적으로 사용한다.&lt;br/&gt;&amp;nbsp;&lt;br/&gt;&lt;p style=&quot;color: blue;&quot;&gt;&lt;br/&gt;(***필자주석)  이 문장이 너무 당연한 것처럼 보일지 모르나 이 원칙을 지키면서 SRS를 작성하는 경우를 국내에서는 본 적이 없다. 구체적으로 말하자면 SRS가 완성되면 개발자들은 개발을 시작하지만 마케팅 부서는 SRS를 기반으로 카탈로그도 만들고 언론기사도 작성하고 영업활동도 준비할 수 있다. 기술문서 부서는 SRS를 보고 사용자 매뉴얼을 작성하기 시작한다. 물론 완성하기 위해서는 화면 이미지와 같이 나중에 나오는 것도 있지만 대부분의 내용은 SRS에 나와 있다. 만약 발주자인 고객이라면 SRS를 보고 자기가 원하는 제품인지를 알 수 있어야 하고 나중에 분란의 소지가 전혀 없을 정도로 자세히 적혀야 한다. 그러니까 국내에서 통상적으로 벌어지는 현상인 개발한 다음에 보고 나서 이것 저것 고쳐 달라고 하는 것은 이 꼭지의 원칙을 지키지 않은 것이다. 단 한 줄의 원칙이지만 해야 할 일로 보면 지금 하고 있는 일의 몇 배의 일을 해야 할 지 모른다. &lt;br/&gt;&lt;/p&gt; &lt;br/&gt;&amp;nbsp;&lt;br/&gt;* 마지막으로 제품 향상을 위한 기반으로 사용된다.&lt;br/&gt;&amp;nbsp;&lt;br/&gt;&lt;p style=&quot;color: blue;&quot;&gt;&lt;br/&gt;(***필자주석)  SRS는 항상 제품이 진화함에 따라 같이 진화한다. 새 제품이 나온다고 처음부터 SRS를 다시 적는 것은 잘못된 것이다. 제품과 소스코드와 SRS는 항상 같은 버전을 최신으로 유지해야 한다.&lt;br/&gt;&lt;/p&gt;&lt;br/&gt;&amp;nbsp;&lt;br/&gt;SRS는 보통은 자연언어(Natural Language)로 적는다. 하지만 정규식(Formal)이나 준정규식(Semi-Formal)을 이용한 설명이 보충되게 된다. 아키텍처의 설명이나 어떤 특정한 내용을 자세히 쉽게 설명하기 위해 필요한 적절한 표기법의 선택이 필요하기도 하다. 특정한 표기법이 좋다 나쁘다가 아니고 일반적인 원칙은 Requirements를 정확히 표현하는 표기법을 사용하라는 것이다. 안전 요구사항(Safety Requirements)이나 법규(Regulation)와 같이 외적인 요소가 치명적일 경우에 특히 정확하게 명시할 수 있어야 한다. 하지만 표기법 선택은 직원들의 교육 유무, 보유스킬, 작성자의 선호도, 검토할 사람들의 선호도에 따라 결정되기도 한다.&lt;br/&gt;&amp;nbsp;&lt;br/&gt;SRS를 프로젝트 비용, 인수조건, 성능, 일정, 재사용성 등의 수치를 측정하는 품질 지표(Quality Indicator)가 이미 개발되어 있다. 그리고 SRS에 적히는 각 문장의 품질을 측정하는 지표에는 꼭 할 것 (Imperative), 불충분한 문장, 선택적인 문장 등의 특성이 있다. 그리고 전체 SRS 문서의 품질을 측정하는 지표에는 문서의 양, 가독성, 명시화, 깊이, 문장 구조 등이 있다.&lt;br/&gt;&amp;nbsp;&lt;br/&gt;&lt;p style=&quot;color: blue;&quot;&gt;&lt;br/&gt;(***필자주석) 여기에서 말하는 품질지표(Quality Indicator)는 필자가 요구공학을 가르칠 때 채점을 하기 위한 항목이기도 한데 예를 들어 가독성만 해도 관련자들이 읽어서 쉽게 이해하지 못한다면 가독성이 낮은 것이다. 작성자만 이해하는 SRS는 잘 작성된 것이 아닌 것이다. 또 불충분한 문장의 경우에는 너무 많은 잘못된 경우가 있다. &quot;빨리&quot;, &quot;사용자 친화적&quot;, &quot;안정적인&quot; 이런 용어들은 모두 다 감점이 되는 용어들이며 SRS에서는 사용하면 안 되는 용어이다. 이런 용어들은 이전 단계인 고객요구사항 문서에서는 어느 정도 허용될 수도 있지만 SRS에서는 이런 용어를 변경해서 정량적으로 정확히 명시해야 한다.&lt;br/&gt;&lt;/p&gt;&lt;br/&gt;&amp;nbsp;&lt;br/&gt;이 꼭지까지 도출, 분석, 명시(즉 SRS를 작성)하는 가이드까지 설명했지만 현실적으로 작성할 수 있는 능력이 생길 수는 없다. 일단 여기서는 SRS가 자신이 생각하고 있던 것과는 다르다는 것 정도만 인식해도 많은 도움이 된다.&lt;br/&gt;&amp;nbsp;&lt;br/&gt;6. Requirements Validation (검증) - 다음 Post에서 다룬다&lt;br/&gt;7. Practical Considerations (현실적인 고려사항)&lt;br/&gt;8. Software Requirements Tools (도구)</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/6335225728089980011/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=6335225728089980011' title='3개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/6335225728089980011'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/6335225728089980011'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2014/07/swebok-6.html' title='SWEBOK - 소프트웨어 요구사항 #6'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-1958806036599119485</id><published>2014-07-21T14:39:00.000-07:00</published><updated>2015-11-28T01:54:14.601-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="SWEBOK(소프트웨어 지식체계)"/><category scheme="http://www.blogger.com/atom/ns#" term="분석/요구사항"/><category scheme="http://www.blogger.com/atom/ns#" term="소프트웨어공학"/><title type='text'>SWEBOK - 소프트웨어 요구사항 #5</title><content type='html'>&lt;script type=&quot;text/javascript&quot;&gt;// &lt;![CDATA[&lt;br/&gt;(function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,&#39;script&#39;,&#39;//www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);   ga(&#39;create&#39;, &#39;UA-50709339-1&#39;, &#39;ikwisdom.com&#39;);   ga(&#39;send&#39;, &#39;pageview&#39;);&lt;br/&gt;// ]]&gt;&lt;/script&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;SWEBOK 해설 Software Requirements #5&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 이 꼭지는 &quot;분석&quot; 이라는 행위에 대한 설명인데 가장 핵심적인 행위인 &quot;Specification(명시)&quot;는 다음 꼭지에 있다. 지금까지 요구사항 도출도 하고 이 꼭지에서 분석을 한 다음에야 마지막 단계인 &quot;Specification(명시)&quot;를 한다. 도출, 분석, 명시란 단어가 다 비슷하게 들리는 이런 것들의 차이가 무엇인지는 사실 어느 정도 경험해 보기 전에는 이해하기가 어려울지 모른다. 진정한 이해를 위해서 경험이 있으면 좋겠지만 경험이 없어도 이해하고 행동할 수 있는 선각자들도 있으니 IEEE에서 SWEBOK을 출간했을 것이라고 믿는다. 필자는 SWEBOK을 읽으면서 그 동안의 경험을 회상하며 다시 한 번 정리를 할 수 있는 기회가 되었으니 SWEBOK의 가치를 가슴 깊이 느낀다. &lt;br /&gt;&lt;br /&gt;SWEBOK에서도 말했지만 필자가 책이나 기사에서 수 없이 얘기한 &quot;SRS는 기능명세서(Functional Specification)가 아니다&quot; 라고 했음에도 불구하고 아직도 기능명세서가 SRS라고 착각하고 있는 독자들도 있다. &quot;기능명세서는 작성할 필요가 없을지도 모르나 SRS는 꼭 작성해야 한다&quot; 라고 말한다면 더 착각을 불러일으킬지 모르지만 나중에 SRS에 관한 것을 다 이해하고 나면 저절로 이해가 될 것이다. 하지만 지금은 이해는 가지 않더라도 앞 꼭지에서도 여러 번 설명했듯이 더 이상 착각은 하지 않았으면 하는 바램이다.&lt;br /&gt;&lt;br /&gt;그리고 이 꼭지를 이해하기 위해서는 앞 꼭지들에서 언급한 기초적인 용어와 지식을 확실히 알고 있어야 한다. 앞 꼭지들을 소화하지 않고 이 꼭지를 이해한다는 것은 불가능하다. 아마도 실용가치 없는 표면적인 지식만 습득할 수 있을 뿐이다. 앞 꼭지들에서 소개된 많은 용어들이 나오니까 다시 한번 읽어 보는 것도 좋을 것이다. 필자도 SWEBOK을 여러 번 읽었지만 읽을 때마다 새로 느끼는 것이 있다. 그만큼 심오한 문서이다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;1장 Software Requirements (소프트웨어 요구사항)&lt;br /&gt;&lt;br /&gt;1. Software Requirements Fundamentals (소프트웨어 요구사항의 본질)&lt;br /&gt;&lt;br /&gt;2. Requirement Process (요구사항 프로세스)&lt;br /&gt;&lt;br /&gt;3. Requirement Elicitation (요구사항 도출) &lt;br /&gt;&lt;br /&gt;4. Requirements Analysis (요구사항 분석) &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;이 꼭지는 요구사항의 분석(Analysis)를 하기 위해 필요한 프로세스를 설명하며 그 목적은 다음과 같다&lt;br /&gt;&lt;br /&gt;* 요구사항들 간에 상충되는 부분을 발견하고 조율한다.&lt;br /&gt;&lt;br /&gt;* 소프트웨어가 어떤 조직과 어떤 운영환경에서 사용되는 지에 대한 범위를 명확히 한다.&lt;br /&gt;&lt;br /&gt;* 소프트웨어 요구사항을 추출하기 위해 상위의 시스템 요구사항을 자세히 명시한다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 대부분의 소프트웨어는 시스템의 일부분으로 동작된다. 예를 들어 휴대폰이나 자동차 등과 같이 하드웨어를 컨트롤하는 임베디드 소프트웨어뿐만 아니라 대부분의 소프트웨어는 알게 모르게 소프트웨어가 사용되는 전체 환경 즉 시스템이 요구하는 요구사항에 따라서 소프트웨어 요구사항이 나오게 된다. 그러기 위해서는 시스템 요구사항을 먼저 정확히 도출하는 것이 필수이다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;전통적으로 요구사항 분석(Requirements)은 구조분석방법(Structured Analysis Method)과 같은 구조적인 분석을 이용한 개념모델을 만드는 것이었다. 그런 구조분석방법으로 명시하는 것도 중요하지만 그 전에 상충되는 요구사항을 먼저 조율해야 하고 조율을 위한 요구사항 협상(Requirements Negotiation)시에 각 이해관계자의 손익관계를 계산하기 쉽도록 먼저 요구사항 분류(Requirements Classification)에 대한 설명을 하기로 한다.&lt;br /&gt;&lt;br /&gt;결론적으로 요구사항은 다음 목적을 위해서 정확히 명시되도록 모든 노력을 기울여야 한다.&lt;br /&gt;&lt;br /&gt;- 요구사항이 검증될 수 있어야 한다&lt;br /&gt;- 실현가능성이 있다는 것을 증명할 수 있어야 한다&lt;br /&gt;- 비용이 얼마나 들지를 측정할 수 있어야 한다&lt;br /&gt;&lt;br /&gt;4.1 Requirements Classification (요구사항 분류)&lt;br /&gt;&lt;br /&gt;요구사항은 다음과 같은 여러 가지 관점에서 분류되어야 한다.&lt;br /&gt;&lt;br /&gt;* 요구사항이 기능요구사항(Functional Requirements)인가 비기능요구사항(Nonfunctional Requirements)인가? 이에 대한 설명은 앞 꼭지 1.3에서 설명되었다.&lt;br /&gt;&lt;br /&gt;* 요구사항이 상위 시스템에서 명시된 것인가? 혹은 출현되는 특성(Emergent Properties. Section1.4 참조)인가? 혹은 이해관계자가 직접 명시한 요구사항인가?&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 근본적으로 요구사항은 직접적으로 명시한 것 외에도 아무도 말하지 않았지만 암묵적으로 생겨나는 것들이 있다. 그런 것들을 놓치지 않고 찾아내어 명시하는 것이 중요하다. 만약 누가 말한 것만을 적어서 요구사항이 완성될 수 있다면 타이피스트의 역할에 불과할 것이다. 경험이 많으면 많을 수록 그런 암묵적인 요구사항을 되도록 많이 적을 수 있다. &lt;/div&gt;&lt;br /&gt;&lt;br /&gt;* 요구사항이 제품의 요구사항인가? 제품을 만들기 위한 프로세스에서 요구되는 사항인가? (Section 1.2 참조). 프로세스에서 요구되는 사항의 예에는 특정한 개발자가 개발하도록 계약에서 명시할 수도 있고 소프트웨어 공학 방법론을 명시할 수도 있고 특정한 표준기법을 준수하도록 결정할 수도 있다.&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 실제로 UML을 사용하기로 결정했더라도 EA를 사용할 지 랩소디를 사용할 지와 같이 도구의 선호도는 다를 수가 있고 생산성에 영향을 끼친다. 혹은 java를 사용할 지 C++을 사용할지도 마찬가지이다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;* 요구사항의 우선 순위(Priority)를 정한다. 소프트웨어를 만드는 목적에 가깝게 부합할수록 우선 순위가 높다. 우선 순위를 분류하는 방법의 한 예로는 필수 사항, 매우 중요, 중요, 선택사항 등으로 분류하는 방법도 있다. 우선순위는 제품의 기능으로서의 중요성 뿐 아니라 개발비용을 고려해서 균형 있게 평가되어야 한다.&lt;br /&gt;&lt;br /&gt;* 요구사항의 범위(Scope of requirements) - 어떤 요구사항이 영향을 미치는 범위를 의미한다. 어떤 비기능요구사항은 Global Scope로서 전체 소프트웨어에 영향을 미치고 모든 컴포넌트에서 그 사항을 고려하여야 한다. 반면에 어떤 요구사항은 일부 컴포넌트에만 영향을 미친다. Global Scope는 소프트웨어의 아키텍처에 지대한 영향을 미치고 그에 따라 모든 하위 컴포넌트의 설계가 결정된다. 반면에 부분적인 범위(Narrow Scope)의 요구사항은 소수의 컴포넌트 설계에만 영향을 미친다. &lt;br /&gt;&lt;br /&gt;* 요구사항의 변동성과 안정성 (Volatility/Stability) - 어떤 요구사항은 소프트웨어의 생명주기가 끝날때까지 계속 변해 간다. 심지어는 개발하는 중간에도 변하는 경우도 있다. 이런 요구사항이 미래에 변동할 가능성에  대한 예측을 어느 정도 할 수 있어야 한다. 예를 들어 금융권 전산 시스템에서 &quot;예금이자를 지급해야 한다&quot;는 요구사항은 &quot;어떤 금융상품이 면세상품이다&quot;를 결정하는 것보다는 훨씬 변할 확률이 적을 것이다. 이자는 금융권의 근원적인 기반이기 때문에 변하지 않는다고 가정해도 되지만 면세인 금융상품은 정부의 정책에 따라 수시로 변할 수 있다. 이런 가정에 따라 미래의 변화를 적용할 수 있도록 컴포넌트를 미리 인식하고 설계를 유연하게 해야 한다.  &lt;br /&gt;&lt;br /&gt;요구사항 지식영역(KA)의 마지만 부분인 Section 7.3 에서 Requirements Attributes(요구사항 특성)을 다루는데 요구사항 분류와 중복되는 부분이 있으니 참조하기 바란다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;4.2 Conceptual Modeling (개념모델)&lt;br /&gt;&lt;br /&gt;소프트웨어가 해결하려고 하는 실제 세상의 문제를 모델로 만드는 것이 요구사항 분석의 핵심이다. 개념모델의 목적은 해결하려는 문제가 무엇이고 해결책이 무엇인지를 이해하는데 도움을 주는데 있다. 이 꼭지는 Software Engineering Models and Methods 지식영역과 밀접한 관계가 있다.&lt;br /&gt;&lt;br /&gt;다음과 같은 여러 종류의 개념 모델 방식이 사용될 수 있다. &lt;br /&gt;- 유스케이스 다이어그램 (Use-case Diagram)&lt;br /&gt;- 데이터 흐름도 모델(Data Flow Model), &lt;br /&gt;- 상태모델(State  Model), &lt;br /&gt;- 목표지향 모델 (Goal-based Model), &lt;br /&gt;- 사용자관계 모델(User Interaction Model), &lt;br /&gt;- 객체지향 모델(Object Model), &lt;br /&gt;- 데이터 모델&lt;br /&gt;- 등등&lt;br /&gt;&lt;br /&gt;이 중에 많은 모델은 UML (Unified Modeling Language) 표기법 중의 일부분이기도 하다. 특히 유스케이스 다이어그램은 통상적으로 내부의 구조와는 상관 없이 행위자(Actor, 즉 사용자일 수도 있고 외부의 시스템일 수도 있다)의 유스케이스로 시스템의 기능을 외부의 관점에서 묘사하는 것이 가능할 때 흔히 사용된다. 이런 모델링 표기법의 선택은 다음과 같은 요소를 고려하여 결정된다.&lt;br /&gt;&lt;br /&gt;* 문제의 본질 - 어떤 소프트웨어는 엄청난 분석 작업을 요구하기도 한다. 예를 들어 SysML의 방식 중의 하나인 &quot;상태 파라미터 모델&quot;(State and Parametric Model)은 정보시스템(Information System) 관련 소프트웨어보다는 실시간 소프트웨어에 적합하다. 이와 정 반대되는 시스템에서는 객체(Object) 다이어그램이나 액티비티(Activity) 다이어그램이 통상적으로 사용된다. &lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 현실에서 가장 어려운 결정은 어떤 다이어그램을 사용할 것인가 하는 결정이다. 모든 다이어그램을 작성하는 것은 가장 나쁜 결정이다. 많은 중복이 생기고 시간 낭비이기 때문이다. 이 결정은 논리보다는 경험에 의한 통찰력이 우선인 인간 고유의 영역이다. 이런 영역에서 방법론에서 열거한 모든 다이어그램을 만든다는 것은 소프트웨어 공학의 목표와는 정 반대인 최악의 결정이다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;* 소프트웨어 개발자의 전문성 - 개발자가 익숙한 모델링 표기법을 사용하는 것이 개발 생산성이 높다는 것을 고려해야 한다.&lt;br /&gt;&lt;br /&gt;* 고객의 프로세스 요구사항 (1.2 Product and Process Requirements 참조) - 고객이 자기들이 이해하기 쉬운 표기법으로 개발하도록 요구할 수 있다. 이 요구사항은 당연히 바로 위의 개발자들이 익숙한 표기법과 상충될 수 있다. &lt;br /&gt;&lt;br /&gt;어떤 표기법을 사용하든 소프트웨어 전체를 이해할 수 있는 콘텍스트(Context)을 묘사하는 것이 중요하다. 소프트웨어 콘텍스트는 개발하려는 소프트웨어와 그 소프트웨어가 작동되는 외부환경과의 인터페이스를 보여주는 것이 핵심이다. 이 꼭지는 어떤 특정한 표기법을 가르쳐 주는 것인 목적이 아니고 모델링의 의도와 목적에 대한 가이드를 하는 데 있다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 모델링 표기법은 UML도 계속 버전이 바뀌면서 변경되어 왔고 SysML이 나오기도 하고 계속 변화하기 때문에 어떤 특정한 표기법이 최선이라고 할 수가 없다. 위의 상황에 따라 적절한 표기법을 사용하는 것이 최선이다. 국내에서는 UML이 거의 정답으로 생각할 정도로 편중되어 있지만 다른 표기법이 더 유용하다면 그럴 필요는 없다. UML도 만능이 아니고 표현 능력에 한계가 있다. 그냥 하나의 표기법일 뿐이니 생각의 폭을 넓히기 바란다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;4.3 Architectural Design and Requirements Allocation (아키텍처 설계와 요구사항 할당)&lt;br /&gt;&lt;br /&gt;개발의 어느 시점인가에 아키텍처가 만들어져야 한다. 요구사항 단계에서의 아키텍처 설계는 소프트웨어 설계 단계와 중복되는 부분인데 분석과 설계 단계를 깨끗하게 나눈다는 것은 현실적으로 불가능하다. 즉 아키텍처는 요구사항 분석 때 시작해서 설계 단계에서 마무리 한다. 이 꼭지는 당연히 소프트웨어 설계 지식영역과 밀접히 관련되어 있다. &lt;br /&gt;&lt;br /&gt;소프트웨어 분석가는 소프트웨어 설계자로서의 역할도 해야 한다. 요구사항을 분석하고 상세히 명시하는 과정에서 이 요구사항들을 구현할 수 있는 아키텍처가 만들어 져야 한다. 어떤 컴포넌트에 할당된 요구사항을 만족시키기 위해 설계를 하다 보면 다른 컴포넌트와의 인터페이스를 더 자세히 추가적으로 생각하게 되고 그런 과정을 계속 지나다 보면 분석 작업의 완성도가 높아지는 결과를 얻는다.&lt;br /&gt;&lt;br /&gt;대규모의 프로젝트에서는 이런 하나의 컴포넌트에 부과된 요구사항들에 따라 구조 설계를 하다 보면 모든 하위 시스템의 분석을 다시 되풀이하게 하는 상황을 만든다. 자동차 브레이크의 예를 들어보자. 브레이크의 요구사항에는 제동거리, 열악한 환경에서의 안전성, 부드러운 제동, 페달 압력 등이 있고 이런 요구사항들이 ABS(Antilock Braking System) 시스템에 요구된다고 하자. 이런 ABS에 대한 소프트웨어 기능과 요구사항이 정해진 다음에야 자동차의 무게와 브레이크에 사용될 하드웨어 등 파생되는 요구사항들이 결정될 수 있다. &lt;br /&gt;&lt;br /&gt;4.4 Requirements Negotiation (요구사항 협상)&lt;br /&gt;&lt;br /&gt;&quot;협상&quot;이라는 용어는 여기서는 &quot;상충점 해결(Conflict Resolution)&quot; 과 같다. 여러 이해관계자들 사이의 상충되는 문제를 해결하는 것을 의미한다. 상충되는 문제에는 기능요구사항, 비기능요구사항, 자원 등이 있다. 개발자가 일방적인 결정을 하는 것은 현명하지 않고 각 이해관계자들과 의논하여 동의를 구하거나 적절한 조율점을 찾아야 한다. 대부분의 경우 이런 결정들이 최종 고객이 원하는 것인지를 항상 확인하는 것이 계약상 문제를 일으키지 않기 위해 중요하다. 요구사항 분석이 진행됨에 따라 새로운 문제가 계속 발생하고 기존의 요구사항이 변하는 상황이 계속된다. 이런 변화에 따른 소프트웨어 검증에 대한 이슈도 계속 따라온다.&lt;br /&gt;&lt;br /&gt;요구사항 우선순위 결정은 단순히 중요한 사항이 무엇인지를 인지하는 것으로써가 아니라 단계적인 출시를 할 경우에 어떤 요구사항을 포함할지를 계획하고 상충되는 문제를 미리 해결하기 위해서 사용하는 것이 중요하다. 이를 위해서는 산업 도메인 지식, 정확한 개발기간 측정역량에 기반한 복잡한 결정 역량이 필요하다. 현실에서는 이를 위한 정확한 데이터를 얻기가 어려운 것이 문제이다.&lt;br /&gt;&lt;br /&gt;요구사항은 독립적인 것이 아니고 서로 영향을 주는 경우가 많다. 현실에서는 분석가가 모든 요구사항을 다 알지 못하는 상태에서 요구사항의 우선순위를 결정하는 잘못을 저지르기도 한다. 우선순위의 결정에는 &quot;비용과 가치&quot; 의 상대적인 분석을 해야 하는데 이는 모든 이해관계자에게 주는 혜택과 구현하지 않았을 때 발생하는 불이익에 대한 평가를 할 수 있어야 한다. 이는 모든 요구사항의 개발에 드는 비용을 다 분석하고 비교해야 한다는 것을 의미한다. &lt;br /&gt;&lt;br /&gt;또 다른 우선순위 결정 방법으로는 &quot;계층분석 프로세스&quot; 로서 모든 기능을 2개씩 비교해서 어느 것이 얼마나 더 중요한지를 선발해 내는 방식도 있다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 여기에서 글로 설명한 것 보다 현실에서 우선순위를 정하는 것은 무척이나 어렵다. 어떤 기능을 안 만들면 다른 기능이 자동적으로 의미가 없어지는 의존적인 경우와 같이 상관관계가 복잡하게 나타난다. 비용측정도 어렵고 안 했을 때의 피해측정도 어렵고 우선순위 결정은 결국 아무리 많은 데이터를 수집하더라도 대부분은 통찰력에 의한 결정이 된다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;4.5 Formal Analysis (형태적 분석)&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 이 부분은 정확한 의미로 번역하기가 어렵지만 이해를 돕기 위해 미리 설명을 하자면 프로그래밍 언어와 같이 정해진 공식을 이용해서 요구사항을 표현하는 방법을 말한다. 대부분의 소프트웨어 개발의 경우는 이런 방법을 사용하지 않지만 State Machine 과 같이 특수한 경우에는 이런 방식이 유용할 수도 있다. 일단 번역은 하지만 이 꼭지는 상대적으로 덜 중요한 주제이니 가볍게 넘어가는 것을 권장한다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;형태적 분석은 후반부 꼭지인 5.3과 6.3과도 관련되어 있다. 또 다른 지식영역인 Formal Method in Software Engineering Models and Methods Knowledge Area 와도 관련되어 있다.&lt;br /&gt;&lt;br /&gt;형태적 분석은 일체성이 높은 특수한 소프트웨어의 경우에 많은 영향을 끼쳤다. 요구사항의 형태적인 표현은 규칙을 가진 언어(Semantic Language)로 표현한다는 것을 의미한다. 그런 형태적인 표현은 두 가지 혜택이 있다. 첫째, 요구사항을 애매모호하지 않게 표현하여 잘못 이해하는 경우를 없앤다. 둘째, 논리적으로 검증하기가 쉽다. 형태적 표현은 그를 분석할 수 있는 도구를 필요로 하며 두 종류의 도구가 있다. &quot;정리 증명기(Theorem Provers)&quot;와 &quot;모델 검증기(Model Checker)&quot; 가 있다.  하지만 이런 도구조차도 100% 자동으로 검증할 수 있는 방법은 없다. 그래서 형태적 분석 방법을 유용하게 사용할 수 있는 소프트웨어는 매우 제한적이다. &lt;br /&gt;&lt;br /&gt;그래서 형태적 분석은 요구사항 분석의 후반부에 사용하는데 초점을 둔다. 분석 초기에는 아직 비즈니스 목표나 사용자 요구사항도 정해지지 않은 상태에서 형태적 분석을 사용한다는 것은 매우 비생산적이다. 그러나 일단 모든 요구사항이 안정적으로 정해지고 상세히 설명되어 있다면 일부분의 핵심 요구사항은 형태적 분석을 사용하는 것이 좋을 수도 있다. &lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: red;&quot;&gt;&lt;br /&gt;5. Requirements Specification (명시) - 다음 Post에서 다룬다&lt;/div&gt;&lt;br /&gt;6. Requirements Validation (검증)&lt;br /&gt;7. Practical Considerations (현실적인 고려사항)&lt;br /&gt;8. Software Requirements Tools (도구)</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/1958806036599119485/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=1958806036599119485' title='2개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/1958806036599119485'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/1958806036599119485'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2014/07/swebok-5.html' title='SWEBOK - 소프트웨어 요구사항 #5'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-5186523501743954962</id><published>2014-07-12T09:52:00.000-07:00</published><updated>2015-11-28T01:54:26.524-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="SWEBOK(소프트웨어 지식체계)"/><category scheme="http://www.blogger.com/atom/ns#" term="분석/요구사항"/><category scheme="http://www.blogger.com/atom/ns#" term="소프트웨어공학"/><title type='text'>SWEBOK - 소프트웨어 요구사항 #4</title><content type='html'>&lt;script type=&quot;text/javascript&quot;&gt;// &lt;![CDATA[&lt;br/&gt;(function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,&#39;script&#39;,&#39;//www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);   ga(&#39;create&#39;, &#39;UA-50709339-1&#39;, &#39;ikwisdom.com&#39;);   ga(&#39;send&#39;, &#39;pageview&#39;);&lt;br/&gt;// ]]&gt;&lt;/script&gt;&lt;br /&gt;&lt;br /&gt;SWEBOK 해설 Software Requirements #4&lt;br /&gt;&lt;br /&gt;1장 Software Requirements (소프트웨어 요구사항)&lt;br /&gt;&lt;br /&gt;1. Software Requirements Fundamentals (소프트웨어 요구사항의 본질)&lt;br /&gt;&lt;br /&gt;2. Requirement Process (요구사항 프로세스)&lt;br /&gt;&lt;br /&gt;3. Requirement Elicitation (요구사항 도출) &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 먼저 시작하기 전에 국내의 프로젝트 발주과정의 하나인 RFP(Request For Proposal, 제안요청서)와 비교해 보자. 지금 이 요구사항 도출 단계가 지나면 말 그대로 요구사항이 도출될 것이다. 그럼 이 요구사항이 도출된 다음에 RFP가 나가야 할까 아니면 그 전에 나가야 할까? 요구사항 도출단계 전에 나가야 한다면 추상적이고 큼직큼직한 희망사항 정도 적힐 수 밖에 없다. 국내의 RFP는 대부분 이 정도 수준에 속한다. 요구사항을 도출하는 것도 시간과 비용이 들기 때문에 계약을 하기 전에 그런 비용을 지불할 개발업체는 없다. 과거 유사한 프로젝트에 사용했던 문서를 하루 밤새거나 며칠 정도 걸려 수정해서 만들어 내는 경우가 대부분이다. 그러니까 결국 요구사항 도출의 행위도 계약이 끝난 다음에 하게 될 테고 그러다 보면 그 다음 단계인 Software Requirements Specification(SRS)는 계약도 이미 다 끝난 마당에 더욱 더 제대로 적을 이유도 없다. 결국 대부분의 프로젝트는 &quot;요구사항 도출&quot; 마저도 계약이 체결된 후이기 때문에 제대로 작성하려는 동기가 없다. 이런 상황에서 SRS가 제대로 적히길 바란다는 것은 어떻게 보면 망상이다. 그러나 전세계 개발방법론들은 기본적으로 SRS를 만드는 과정이 존재하고 계약상 제출해야 하는 의무가 있으니 제출용 문서를 작성하기는 한다. 대부분은 프로젝트가 종료되기 바로 전에 만든다. 개발에 도움이 되지 않는 문서를 제출용으로 만든다는 것은 시간낭비이고 불행한 일이다. 건물 다 지어 놓고 설계도를 만드는 것과 같다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;요구사항 도출은 요구사항의 출처가 무엇인가와 소프트웨어 엔지니어가 어떻게 요구사항을 수집하는가에 관한 주제를 다룬다. 요구사항 도출은 소프트웨어가 해결하려고 하는 문제에 대한 이해를 하기 시작하는 가장 최초 단계이다. 이것은 전적으로 인간이 하는 행위이다. 이해관계자(Stakeholder)가 인식되고 개발자와 고객과의 관계가 설정되는 단계이다. 요구사항 도출은 다른 용어로 &quot;Requirement capture(요구사항 포착)&quot; 혹은 &quot;Requirement Discovery(요구사항 발견)&quot; 혹은 &quot;Requirement Acquisition(요구사항 수집)&quot;이라는 용어를 사용하기도 한다. 요구사항 도출을 잘 하기 위한 가장 기본적이고 중요한 원칙은 다양한 이해관계자들 사이의 적절한 커뮤니케이션이다., 이 커뮤니케이션은 소프트웨어 개발 생명주기(Software Development Life Cycle, SDLC)동안 계속된다. SDLC의 여러 단계에서 다른 종류의 이해관계자들이 관련된다. 분석책임자(Requirement Specialist)는 개발이 시작되기 전에 이 이해관계자들 사이의 커뮤니케이션 채널을 위한 연결고리를 미리 만들어 두어야 한다. 크게 도메인 전문가들과 기술 전문가들 사이의 중재를 해야 하는 것은 필수이다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 요구사항 도출은 전적으로 인간이 하는 행위라고 적혀 있다. 물론 문서편집기등 도구는 사용하겠지만 근본적으로 인간의 결정이 수시로 필요한 창조적인 영역이다. 즉 Doors와 같은 요구사항 작성도구나 표준 템플릿에다 내용만 적기만 하겠다는 생각이 얼마나 한심한 생각인지를 알 수 있을 것이다. 개발자들이 스스로의 가치를 비하하는 잘못된 생각이다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;요구사항 도출의 가장 중요한 요소는 프로젝트의 범위를 모두에게 인식시키는 것이다. 이를 위해 개발하려고 하는 소프트웨어의 목적과 기능의 우선순위를 명시하여 고객이 원하는 중요한 기능이 먼저 만족되도록 항상 명심해야 한다. 그럼으로써 분석책임자가 낮은 우선순위의 기능에 쓸데없이 시간을 낭비하거나 필요도 없는 기능을 개발하지 않도록 해야 한다. 또 다른 한편으로는 초기 단계에서는 명시되지 않는 기능들을 나중에 수용할 수 있도록 확장성 있게 요구사항들을 표현해야 한다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 나중에 여러 템플릿을 보면 알겠지만 SRS의 초반부는 소프트웨어를 왜 개발하려는 가에 관한 목적과 비지니스 전략에 관한 내용들이다. 왜 개발하는지를 알아야 무엇을 개발할 내용이 결정되는 것이다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;3.1 Requirements Sources (요구사항 출처)&lt;br /&gt;&lt;br /&gt;요구사항은 많은 출처로부터 온다. 그런 모든 출처를 하나도 빠짐 없이 밝혀야 하고 정보를 받아야 한다. 다음과 같은 다양한 출처를 인식하고 그들을 관리해야 한다.&lt;br /&gt;&lt;br /&gt;* Goal(목적) - 목적은 &quot;Business Concern(사업의 관심)&quot; 혹은 &quot;Critical Success Factor(핵심성공요소)&quot; 라고 하기도 하는데 상위수준의 목표를 의미한다. 그러다 보니 개발을 위한 동기부여를 하기도 하지만 애매모호하게 적히기도 한다. 소프트웨어 개발자들은 이 애매모호함 속에서 개발할 가치가 있는 것을 알아 내고 개발비용의 산정을 할 수 있게 많은 노력을 기울여야 한다. Feasibility Study(실현성조사)가 이런 결정을 하기 위해 사용하는 저렴한 방법이다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 실현성조사가 아무리 저렴하다고 해도 시간적으로 모든 기능의 실현성을 조사해 볼 수는 없는 것이 현실이다. 되도록 해보지 않고 결정할 수 있는 역량이 중요하다. 리스크관리 중의 하나가 해보지 않은 기능을 관리하는 것이다. 그래서 경험자의 통찰력이 필수이다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;* Domain Knowledge(도메인 지식) - 소프트웨어 개발자는 제품 도메인에 대한 지식을 습득하거나 가지고 있어야 한다. 도메인 지식은 요구사항이 도출되면서 전체적으로 이해되기 쉽게 도와준다. &lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 필자의 저서에서 소프트웨어 개발자로서 도메인과 소프트웨어 기술의 비율에 대한 설명을 20:80 정도라고 했다. 도메인 전문가가 따로 있고 개발 전문가가 다르니 개발자가 도메인 전문가가 되기 위해 너무 많은 비중을 투입하는 것은 옳지 않다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;* Stakeholder(이해관계자) - 앞 꼭지에서 &quot;Process Actor((행위자)&quot; 라고 했었다. 많은 소프트웨어들이 불만족스럽게 만들어 진 이유가 한 그룹의 이해관계자들의 목소리를 다른 그룹을 희생하면서 들어주기 때문이었다. 그렇게 만들어진 제품은 사용하기 어렵거나 고객의 문화나 고객의 회사구조를 뒤엎어야 하는 경우가 생긴다. 그러므로 소프트웨어 개발자는 여러 이해관계자의 관점(Viewpoints)을 인식하고, 그들을 모두 대표할 수 있어야 하고, 관리해야 한다.&lt;br /&gt;&lt;br /&gt;* Business Rules (비지니스 규칙) - 비지니스가 운영되는 규칙에 대한 내용이다. 예를 들면 대학교의 학과등록 소프트웨어를 개발한다면 &quot;학생은 등록금을 내지 않으면 코스를 등록할 수 없다&quot; 와 같은 규칙을 말한다. &lt;br /&gt;&lt;br /&gt;* Operational Environment (운영환경) - 소프트웨어가 운영되는 환경으로부터도 요구사항이 도출된다. 예를 들어 실시간 시스템에서는 타이밍(Timing)에 관한 제약사항이 있을 수 있고 비지니스 영역에서는 정보처리량이나 대응시간과 같은 성능 문제가 있을 수 있다. 이 요구사항은 실현가능성의 문제가 있을 수도 있고 개발비용이나 설계 구조에 큰 영향을 미칠 수 있기 때문에 능동적으로 찾아내야 하는 중요한 정보이다.&lt;br /&gt;&lt;br /&gt;* The Organizational Environment (조직 환경) - 소프트웨어는 비지니스 프로세스를 구현하기도 한다. 비지니스 프로세스는 고객의 회사구조, 문화, 내부정책에 따라 달라진다. 개발자는 이런 점을 민감하게 인식하고 있어야 하고 새로운 소프트웨어가 이런 고객 환경을 강제로 변경해야지만 작동할 수 있도록 만들면 안 된다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;3.2 Elicitation Techniques (도출 기법)&lt;br /&gt;&lt;br /&gt;요구사항 출처가 모두 알려지면 소프트웨어 개발자는 요구사항 도출을 시작할 수 있다. 명심해야 할 것은 요구사항은 이미 만들어져 있어서 가서 주워오기만 하면 되는 완성품이 아니다. 대부분은 개발자가 여러 정보를 종합해서 요구사항을 조립해 내야 한다. 이 꼭지에서는 이해관계자인 인간이 요구사항에 관련된 정보를 표현하도록 유도하는 기법을 다룬다. 이것은 매우 어려운 작업이다. 개발자는 이해관계자들이 자신들이 원하는 것을 잘 표현하는 능력이 없다는 것을 잘 인지하고 있어야 한다. 그들은 중요한 사항들을 빼먹기도 하고 비협조적이기도 하고 협조할 능력 조차가 없을 수도 있다. &lt;br /&gt;&lt;br /&gt;요구사항 도출 행위는 수동적인 행위가 아니고 심지어는 매우 협조적인 이해관계자들에게서 조차 정확한 정보를 얻어내기 위해서도 매우 열심히 일해야 한다. 많은 비지니스 정보나 기술 정보들은 암묵적 정보라서 너무 당연해 보이기 때문에 얘기를 해주지 않는다. 혹은 고객으로부터 제품을 주고 피드백을 얻기 전까지는 알 수 없는 정보도 많다. 그러므로 요구사항 도출을 위한 사전계획, 확인과 검증은 매우 중요하다. 많은 도출 기법들이 존재하는데 다음과 같은 방법들이 있다.&lt;br /&gt;&lt;br /&gt;* 인터뷰 - 가장 전통적인 방법인 이해관계자들과의 인터뷰인데 장점과 단점이 있다는 것을 이해하고 인터뷰를 어떻게 진행할 지를 잘 계획하고 있어야 한다.&lt;br /&gt;&lt;br /&gt;* 시나리오 작성 - 시나리오는 요구사항에 대한 전후 사정과 전체 맥락을 이해하는데 좋은 방법이다. 이 방법은 개발자들이 &quot;혹시 이런 경우라면&quot; 이나 &quot;이렇게 되는 건가요&quot; 와 같은 질문을 던지고 확인할 수 있게 도와준다. 가장 통상적인 방법은 유스케이스(Use Case) 를 이용한 표현방식이다. 요즈음에는 이 방식이 가장 많이 사용되고 있다.&lt;br /&gt;&lt;br /&gt;* 프로토타입 - 이 방식은 애매모호함을 없애는 가장 좋은 방법이다. 여러가지 방법이 있는데 종이에다가 화면 시나리오를 그린 Paper Mockup(종이 모형)도 있고, 베타 버전을 사용할 수도 있고 여러가지 방법을 여러 단계에서 적절히 중복해서 사용할 수도 있다. 통상적으로 너무 자세하지 않게 대충 만든 모델 (Low Fidelity Model)을 사용하는 것이 좋다. 그 이유는 너무 자세하게 적어서 유연성을 없애고 설계에 제약이 가해지는 경우가 있다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) UI에서 너무 자세하게 명시함으로서 설계나 구현 방식을 몇 배 어렵게 만드는 경우를 자주 보았다. 중요한 것은 사용자가 편하고 목적을 성취하면 되는 것이지 구체적인 방법을 미리 명시할 필요는 없다. 구현방법은 개발자에게 자유롭게 맡겨놓음으로써 개발의 효율성을 높이고 비용과 일정을 절감할 수 있다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;* 그룹 회의(Facilitated Meeting) - 이 회의의 목적은 종합적인 내용을 정하는 것이다. 한 개인이 정할 수 없는 경우에 여러 명의 이해관계자들이 모여서 좋은 의견을 낼 수 있다. 또 중요한 것은 상충되는 요구사항들이 이 방법으로 모든 이해관계자들에게 초기에 노출되도록 하는 것이다. 이 방법이 잘 이용되면 일관성 있고 깊이 있는 여러 요구사항들의 집합이 도출되는 것도 장점이다. 하지만 그룹회의는 중재자의 지휘아래 매우 조심스럽게 진행되어야 한다. 목소리 큰 그룹이나 직위가 높은 이해관계자의 주장이 받아들여지고 다른 이해관계자는 무시될 수가 있는 것이 조심해야 할 사항이다.&lt;br /&gt;&lt;br /&gt;* 관찰 (Observation) - 실제 운영환경에서 소프트웨어를 어떻게 사용하고 주위의 어떤 자원과 교류하고 소통하는지를 개발자가 옆에서 구경하면서 관찰하는 기법이다. 이 방식은 비용이 많이 드는 반면에 말로 설명하기 어렵거나 보기 전에는 감지하기 어려운 비지니스 프로세스 등을 알아내는 데는 효과적이다.&lt;br /&gt;&lt;br /&gt;* 사용자 이야기 (User Stories) - 이 방식은 애자일 방법론과 같이 단계적인 개발 방법론에서 많이 사용된다. 주로 사용자 수준의 상위 요구사항을 간단하게 고객의 용어를 이용하여 설명한다. 통상적인 문장은 &quot;이런 &amp;lt;역할&amp;gt;로 이런 &amp;lt;혜택&amp;gt;을 얻기 위해 &amp;lt;무엇을&amp;gt; 하기 원한다.&quot; 와 같은 방식으로 적힌다. 사용자 이야기는 개발자가 개발하는 비용을 측정할 수 있을 만큼만 최소한의 정보만을 적는 것이 좋다. 잘못 사용되면 너무 많은 자세한 정보를 초기 단계에서 받고 나서 나중에 쓸모 없이 되거나 수정해야 하는 경우이다. 이 방법은 도출 초기 단계에 사용하는 것이고 구현단계에 가기 전에는 자세한 수준의 내용이 적혀져야 한다. &lt;br /&gt;&lt;br /&gt;* 나머지 기법들 - 다른 많은 기법들이 존재한다. 경쟁사 제품 분석도 있고 데이터 마이닝 기법도 있고 고객이 요청한 기능목록 등 다양한 출처가 있을 수 있다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 위에서 나열한 여러 방법들을 이용하여 요구사항을 도출했다고 하자. 이 시점에서 저지르는 가장 빈번하고 치명적인 실수는 이제 코딩을 시작할 만큼 내용을 안다 라고 착각하는 것이다. 실제로 여기서 도출한 내용을 버젓이 SRS라고 부르기도 한다는 것이다. 혹은 기능명세서 또는 요구사항 명세서라고 부리기도 한다. 큰 착각이다. 절대 SRS가 아니다. SRS를 작성하려면 지금까지 작성한 문서 양의 몇 배를 작성해야 한다. 아마 10배의 양을 작성해야 할지도 모른다. 이제 시작에 불과한데 마치 끝났다고 착각할 수 있는 것을 조심해야 한다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: red;&quot;&gt;&lt;br /&gt;4. Requirements Analysis (분석) - 다음 Post에서 다룬다&lt;br /&gt;5. Requirements Specification (명시)&lt;br /&gt;6. Requirements Validation (검증)&lt;br /&gt;7. Practical Considerations (현실적인 고려사항)&lt;br /&gt;8. Software Requirements Tools (도구)&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/5186523501743954962/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=5186523501743954962' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/5186523501743954962'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/5186523501743954962'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2014/07/swebok-4.html' title='SWEBOK - 소프트웨어 요구사항 #4'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-5256848299190514308</id><published>2014-07-06T12:32:00.000-07:00</published><updated>2015-11-28T01:54:41.312-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="SWEBOK(소프트웨어 지식체계)"/><category scheme="http://www.blogger.com/atom/ns#" term="분석/요구사항"/><category scheme="http://www.blogger.com/atom/ns#" term="소프트웨어공학"/><title type='text'>SWEBOK - 소프트웨어 요구사항 #3</title><content type='html'>&lt;script&gt;// &lt;![CDATA[&lt;br/&gt;(function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,&#39;script&#39;,&#39;//www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);   ga(&#39;create&#39;, &#39;UA-50709339-1&#39;, &#39;ikwisdom.com&#39;);   ga(&#39;send&#39;, &#39;pageview&#39;);&lt;br/&gt;// ]]&gt;&lt;/script&gt;&lt;br /&gt;SWEBOK 해설 - &amp;nbsp;Software Requirements #3&lt;br /&gt;&lt;br /&gt;1장 Software Requirements (소프트웨어 요구사항)&lt;br /&gt;&lt;br /&gt;1. Software Requirements Fundamentals (소프트웨어 요구사항의 본질)&lt;br /&gt;&lt;br /&gt;2. Requirement Process (요구사항 프로세스)&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;(***필자주석) 이 블로그를 가끔 가다 읽는 독자를 위해 이 쯤에서 다시 한번 Software Requirements Specification (SRS)라는 용어를 살펴보자. SRS는 Software Requirements를 Specify 한 문서이다. 즉 Requirements와 Specification이 다르다는 것을 의미한다. 달라도 엄청 다르다. 양적으로 10배 100배의 차이가 나기도 한다. 하여튼 일단은 Requirements를 잘 수집해야 Specification을 잘 적을 수 있다는 것은 상식적이다. 이 꼭지는 Requirements 프로세스에 대한 주제를 다룬다. 아직까지 Specification에 관한 내용은 전혀 다루지 않았다. Specification은 Requirements를 도출한 다음에 다른 꼭지에서 다루게 된다.&lt;br /&gt;&lt;br /&gt;독자들이 만약에 이 꼭지가 잘 이해가 안되거나 한다면 전혀 걱정하지 말고 그냥 넘어가라고 하고 싶다. 프로세스에 관련된 영역은 사실 꽤 높은 수준에 오른 사람들이 효율적으로 운영할 수 있는 영역이다. 이해를 하더라도 실행을 하기는 어려운 영역이다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;이 토픽에서는 &quot;1장 소프트웨어 요구사항&quot; 의 나머지 5개 토픽에 대한 소개와 요구사항 프로세스가 전체 소프트웨어 공학 프로세스와 어떻게 연관되어 돌아가는 지를 보여준다.&lt;br /&gt;&lt;br /&gt;2.1 Process Model (프로세스 모델)&lt;br /&gt;&lt;br /&gt;프로세스 모델은 요구사항 프로세스에 대한 다음 3가지 특성을 이해하도록 돕는다.&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;br /&gt;&lt;li&gt;1. 요구사항 프로세스는 소프트웨어 생명주기의 앞 쪽에만 존재하는 분리된 단계가 아니다. 대신 프로젝트의 출발과 함께 시작되어서 생명주기가 끝날 때까지 계속 수정되면서 정제되는 행위이다.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;2. 요구사항은 버전관리되어야 하는 형상의 하나로서 소프트웨어 생명주기의 모든 단계에서 나오는 다른 산출물(형상)과 마찬가지로 똑같은 방식으로 관리되어야 한다.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;3. 회사와 프로젝트의 종류에 따라 다르게 적용되어야 한다.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;(***필자주석) 여기에 매우 심오한 문장이 들어 있다. 1번에서 생명주기가 끝날 때까지 계속 수정된다는 얘기인데 이 말을 잘못 이해하면 그야말로 주먹구구식으로 개발하면서 SWEBOK을 따라 했다고 우겨댈 수 있는 위험한 문장이다. 이 말은 폭포수 모델(Waterfall Model)을 극단적으로 해석해서 한 번 적으면 절대로 변하지 않는다는 극단론자들에 대한 조언 정도로 받아들이면 될 것이다. 즉 한 번 적힌 요구사항은 변하지 않는다는 이상적인 폭포수 모델은 이 세상에 존재하지 않는다고 보는 것이 옳다. 그렇더라도 국내에서는 &quot;요구사항은 절대 변하면 안 된다&quot; 라고 해석하는 것이 옳다. 국내에서 그런 기준에서 수행해도 실리콘밸리에서 &quot;자주 변할 수 있다&quot; 라는 기준에서 작성할 때보다도 더 많은 양이 변하게 될 것이다. &quot;변한다&quot; 는 문장에서 국내와 실리콘밸리의 기준이 다르기 때문이다. &quot;SWEBOK에서 요구사항이 변경될 수 있다고 했다&quot; 라고 주장한다면 국내에서는 작성하다 만 문서가 난무할 것이고 소프트웨어공학과는 전혀 상관없는 행위가 될 것이다.&lt;br /&gt;&lt;br /&gt;2번은 형상관리라는 용어를 소스코드의 버전관리 정도의 좁은 의미로 잘못 사용하는 경우를 국내에서 많이 봤는데 형상은 이 세상의 모든 실체는 형상이다. 여기서는 요구사항 한개 한개가 형상이고 소스코드는 파일 하나 하나가 형상이고 테스트 케이스도 형상이고 SRS 문서 전체도 하나로서의 형상이다. 이런 모든 형상은 베이스라인이라고 하는 어떤 기준선에 따라서 독립된 세트로 관리를 하는 것이 형상관리이다. 나중에 형상관리 KA 꼭지에서 나오겠지만 형상관리도 다 한다고 하지만 진정으로 정교하게 형상관리를 하는 회사는 국내에서 대기업을 포함해서 거의 볼 수 없었다.&lt;br /&gt;&lt;br /&gt;3번은 필자에게 가장 많이 들어오는 요청인 &quot;샘플과 템플릿을 보여주세요&quot; 라는 말이 왜 별로 도움이 안 되는 지를 말해주는 문장이다. 어떤 사람이 시금치를 먹고 건강해 졌다고 내가 따라 하면 안 된다. 원칙에 따라 내 몸에 맞게 적용해야 하는 것이 소프트웨어 공학의 기본이고 모든 템플릿은 시작일 뿐이고 원칙을 이해 못한 상태에서는 피해만 준다. 샘플 역시 마찬가지이다. 건강의 원칙을 모르는 상태에서 시금치를 먹는 것은 득보다는 실이 많을 것이다. 더 이상 필자에게 템플릿이나 샘플을 달라는 요청이 없는 시대가 빨리 오기를 기대해 본다. 어차피 템플릿은 인터넷에 많고 다 동일한 내용을 포함하고 있다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;요구사항의 후반부 꼭지인 Elicitation(도출), Analysis (분석), Specification (명시), Validation (검증)에 있어서 프로젝트의 중요에 따라 모두 다른 모양으로 설정되고 수행된다. 또 마케팅 부서의 요구사항이나 구현가능성에 대한 정보를 요구사항 프로세스에 제공한다.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;&lt;br /&gt;(***필자주석) 필자가 가장 많이 받는 질문 중의 하나가 &quot;코딩을 해 보기 전에는 기능이 가능한 건지 알 수가 없다&quot; 이다 . 이럴 때는 먼저 프로토타입을 만들어 보는 것이다. 그렇다고 모든 것을 만들어 보면 절대 안 된다. 경영자가 빨리 결정하기 위해서는 일단 그럴 시간이 없다. 결국 심각한 기능의 경우에는 미리 검증해 볼 수도 있지만 프로젝트는 어느 정도의 리스크를 가지고 시작할 수 밖에 없는 것이 현실이다. 그래서 리스크관리가 프로젝트 관리에서 필수적인 행위이다. 사실이 이런데도 프로젝트를 수행하면서 리스크관리를 전혀 하지 않는 경우도 많이 보았다. 리스크는 어느 프로젝트이든 존재하는데 존재자체를 인지하지 못하고 있다는 것은 리스크가 매우 크다는 것을 의미한다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;2.2 Process Actors (프로세스 행위자)&lt;br /&gt;행위자는 요구사항 프로세스에 참여하는 모든 이해관계자들이다. 이 프로세스는 근본적으로 상호규제적인 특성을 가진 프로세스이기 때문에 이해관계자(Stakeholder)들과 소프트웨어 개발자들 사이에 조율을 필요로 한다. 요구사항 분석전문가(Requirements Specialist) 뿐만이 아니라 관련하는 많은 사람들이 소프트웨어에 대해 작건 크건 어떤 부분에 대해 주장할 권리가 있다. 이런 이해관계자들의 종류는 프로젝트에 따라 다르지만 사용자와 고객(사용자와 항상 같지 않음)은 항상 포함된다. 일반적으로 다음과 같은 이해관계자들이 있다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;br /&gt;&lt;li&gt;1. Users (사용자) - 소프트웨어를 직접 사용하는 그룹인데 그 중에서도 다양한 역할이 있다.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;2. Customers (고객) - 소프트웨어의 개발을 요청하거나 타겟 시장을 대표하는 사람들이다.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;3. Market Analysts (시장분석가) - 일반 다수 대중을 목표로 하는 시장에서는 요청하는 고객이 없고 회사의 마케팅 조직이 고객을 대신해서 시장의 요구를 만들어 낸다&lt;/li&gt;&lt;br /&gt;&lt;li&gt;4. Regulators (규제기관) - 금융이나 대중교통과 같은 분야의 소프트웨어는 규제의 대상이 되고 규제기관의 요구를 준수해야 한다.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;5. Software Engineers (개발자) - 개발자들은 당연히 소프트웨어를 효율적으로 개발하기 위해 과거의 컴포넌트를 재사용한다든지 하는 효율성의 이해관계가 있다. 어떤 프로젝트의 경우에는 개발자들의 재사용 요구사항이 다른 고객의 요구사항들보다 더 비중이 클 수도 있다. 또 어떤 특수한 요구사항의 경우에는 개발자들의 기술력에 따라 개발비용이나 출시일정에 큰 영향을 줄 수도 있다. 이런 모든 다양한 요구사항이 식별되어야 한다.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;모든 이해관계자들의 요구사항을 만족시키는 것은 불가능하다. 그렇기 때문에 이들 사이에서 조율을 해야 하는 것이 개발자의 역할이다. 예산, 기술력, 정부규제등 모든 제약조건 아래서 모든 핵심 이해관계자들 에게 수용 가능한 균형 잡힌 결론을 이끌어 내야 하는 것이다. 이를 위한 전제 조건은 모든 이해관계자가 식별되어야 하고 각 이해 관계자들의 &quot;관심이해사항&quot;이 분석되어야 하고 그에 따른 요구사항이 도출되어야 한다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;(***필자주석) SWEBOK 저자들은 &quot;모든 이해관계자들의 요구사항을 만족시키는 것은 불가능하다&quot; 라는 문장에서 &quot;will not be possible&quot; 이라고 했다. 가능한 경우가 있다면 &quot;may not be possible&quot; 이라고 해야 할 텐데 모든 이해관계자들이 모두 만족하는 경우는 없다는 것을 의미하고 필자의 경험으로 봐서도 100% 공감한다. 필자의 책에서도 말했듯이 &quot;모든 고객을 만족시키려고 하는 것은 100% 실패하는 방법이다&quot; 라고 빌 크로스비도 말했다. 상용제품의 경우에는 모든 사람들을 만족시키겠다는 그럴듯한 패러다임에 현혹되어 프로젝트가 진행이 안 되는 경우를 많이 보았다. 반대로 SI 프로젝트의 경우에는 절대 양보하지 않는 상충되는 두 이해관계자들 사이에서 조율에 어려움을 겪는 경우도 많이 보았다. 다 자기 욕심을 조금도 버리지 않으려고 하다가 모두가 손해 보는 시나리오로 가는 경우이다.&lt;br /&gt;&lt;br /&gt;하지만 말이 쉽지 조율이라는 것이 보통 어려운 일이 아니고 책으로 가르칠 수 있는 것도 아니고 경험이 필요한 진정한 소프트웨어 공학의 영역이다. 그래서 분석작업, 즉 Software Requirements Specification을 작성하는 일이 어려운 것이고 가장 최고의 개발자만이 할 수 있는 일이다.&lt;br /&gt;&lt;br /&gt;이런 어려운 일을 템플릿이나 채우면 된다고 생각한다면 망상에 불과하다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;2.3 Process Support and Management (프로세스 지원과 관리)&lt;br /&gt;이 토픽은 요구사항 프로세스에 필요한 자원의 관리에 대한 영역이다. 프로세스에서 벌어지는 활동과 비용, 인적자원, 교육, 도구와의 연결고리를 만드는 것이 목표이다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;(***필자주석) 역시 간략하게 표현했지만 관리영역인 만큼 행위와 자원을 적절히 연결하고 관리해야 한다. 관리가 어렵다기 보다는 무엇을 관리해야 할지를 도출하는 것이 훨씬 더 어려운 영역이다. 즉 무슨 도구를 사용해야 할 지, 누가 SRS를 작성할 지 등을 결정하는 것부터 시작해서 인간이 결정해야 하는 많은 사항들이 있다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;2.4 Process Quality and Improvement (프로세스 품질과 개선)&lt;br /&gt;&lt;br /&gt;이 토픽은 요구사항 프로세스의 품질과 개선에 대한 측정이다. 즉 소프트웨어 개발 비용과 기간 그리고 고객의 만족도의 관점에서 요구사항 프로세스가 해야 하는 핵심 역할을 강조하기 한다. 프로세스 품질과 개선에 도움이 되게 처음부터 방향을 정해준다. 프로세스 품질과 개선은 뒤에 나오는 Software Quality KA(소프트웨어 품질 지식영역)와 Software Engineering Process(소프트웨어 공학 프로세스)와 밀접하게 연관되어 있다. 다음과 같은 주제를 다룬다.&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;br /&gt;&lt;li&gt;- 프로세스 개선과 표준 모델에 제안하는 요구사항 프로세스 적용범위&lt;/li&gt;&lt;br /&gt;&lt;li&gt;- 요구사항 프로세스의 측정과 벤치마킹&lt;/li&gt;&lt;br /&gt;&lt;li&gt;- 개선 계획과 수행&lt;/li&gt;&lt;br /&gt;&lt;li&gt;- 보안관련 개선 계획과 수행&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;(***필자주석) 프로세스라는 용어가 기본적으로 매우 추상적인 용어라서 구체화 하기 전에는 경험자가 아니면 상상하기가 어렵다. 프로세스 개선이라고 하는 행위는 CMMI나 SPICE와 같이 한국 업체들이 한 때 열심히 적용하려고 했던 분야이다. 필자는 프로세스에 관한 수행은 먼저 프로세스의 각 단계에 해당되는 행위를 충분히 수행할 수 있는 수준이 되었을 때 전체적인 프로세스를 개선한다든지 하는 의미가 있다. 각 단계도 제대로 못하는 상황에서는 프로세스가 도움보다는 피해를 준다. SWEBOK의 저자들은 독자들이 어느 정도 수준에 있다고 가정하고 프로세스에 대한 토픽을 얘기할 지 모르나 필자가 보는 국내 소프트웨어 회사에서는 먼저 SRS를 어느 정도 작성할 수 있는 능력이 있고 나서 프로세스에 대한 고려를 해보는 것이 좋다.&lt;br /&gt;&lt;br /&gt;즉 내용이 중요한가 프로세스가 중요한가에 대한 이슈인데 예를 들면 음식을 만들지도 못하는데 담을 그릇을 걱정할 필요는 없다. 요리학원도 다니고 음식을 만들 수 있는 상태가 되면 음식에 맞는 그릇을 사면 된다. 그런 면에서 SWEBOK은 모든 수준의 사람들이 각 수준에서 이해할 수 있는 용어들이 있고 또 받아드려야 하는 행위들이 있다. 수준이 향상됨에 따라 다시 읽게 되면 공감하는 부분이 계속 있을 것이다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: red;&quot;&gt;3. Requirement Elicitation (요구사항 도출) - 다음 Post에서 다룬다&lt;/div&gt;&lt;br /&gt;4. Requirements Analysis (분석)&lt;br /&gt;5. Requirements Specification (명시)&lt;br /&gt;6. Requirements Validation (검증)&lt;br /&gt;7. Practical Considerations (현실적인 고려사항)&lt;br /&gt;8. Software Requirements Tools (도구)</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/5256848299190514308/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=5256848299190514308' title='1개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/5256848299190514308'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/5256848299190514308'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2014/07/swebok-3.html' title='SWEBOK - 소프트웨어 요구사항 #3'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-1365591944722180079.post-2355798284792713697</id><published>2014-06-22T11:19:00.000-07:00</published><updated>2015-11-28T01:54:52.193-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="SWEBOK(소프트웨어 지식체계)"/><category scheme="http://www.blogger.com/atom/ns#" term="분석/요구사항"/><category scheme="http://www.blogger.com/atom/ns#" term="소프트웨어공학"/><title type='text'>SWEBOK - 소프트웨어 요구사항 #2</title><content type='html'>&lt;script type=&quot;text/javascript&quot;&gt;// &lt;![CDATA[&lt;br/&gt;(function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,&#39;script&#39;,&#39;//www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);   ga(&#39;create&#39;, &#39;UA-50709339-1&#39;, &#39;ikwisdom.com&#39;);   ga(&#39;send&#39;, &#39;pageview&#39;);&lt;br/&gt;// ]]&gt;&lt;/script&gt;&lt;br /&gt;&lt;br /&gt;SWEBOK 해설 - &amp;nbsp;Software Requirements #2&lt;br /&gt;&lt;br /&gt;&lt;b&gt;1&lt;/b&gt;&lt;b&gt;장 Software Requirements (소프트웨어 요구사항)&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;1. Software Requirements Fundamentals (&lt;/b&gt;&lt;b&gt;소프트웨어 요구사항의 본질)&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;1.1 Definition of a Software Requirements (&lt;/b&gt;&lt;b&gt;소프트웨어 요구사항의 정의)&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;기본적으로 Software Requirements는 현실에서 어떤 문제를 해결하기 위해 묘사되는 특성(Property)이다. 해결하려고 하는 문제는 기업의 비지니스 프로세스일 수도 있고, 기존 제품의 개선일 수도 있고, 기구의 컨트롤 시스템일 수도 있고 수 많은 문제들이 있다. 인간 사용자나 비지니스 프로세스나 기구나 대체적으로 동작하는 방식은 복잡하다. 요구사항이라는 것은 소프트웨어가 동작하는 방식에 연관되어 있는 다양한 수준의 사람들이 요구하는 모든 기능들이 고려되는 복잡한 집합체이다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;(***필자주석) 모든 이해관계자들이 요구하는 기능을 다 집어넣는 다는 것은 가장 나쁜 요구사항 작성법이다. 바로 Kitchen Sink라고 말하는 쓰레기 통이다. 요구사항 작성이 어려운 것은 이 모든 이해 관계자들을 조율해서 가장 현실적인 제품을 만들어 내는 것이다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;Software Requirements의 필연적인 특성은 기능으로서나 혹은 시스템에 부과되는 비기능요구사항으로서나 각각 하나씩 독립적으로 검증될 수 있어야 한다는 것이다. 이런 검증은 매우 어렵거나 많은 비용이 들 가능성이 있다. 예를 들어 Call Center의 요구사항을 테스트하기 위해서는 시뮬레이션 프로그램을 개발해야 할지도 모른다. 소프트웨어 요구사항 작성자나 테스트계획이나 품질검증부서는 현실적으로 가능한 자원의 한도 내에서 모든 요구사항이 검증될 수 있다는 것을 보장해야 한다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;또 요구사항은 제한적인 자원과 프로젝트의 트레이드오프를 선택할 수 있도록 우선순위를 명시해야 하는 특성을 가지고 있다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;(***필자주석) 요구사항 작성시 우선순위의 명시는 필수이다. 보통 저지르는 실수는 전부 다 중요하다고 적은 것이다. 그렇게 하려면 적을 필요도 없다. 항상 일정과 자원과 기능의 상충되는 목표를 조율하기 위해서는 모든 기능의 우선순위를 적절히 배분해서 명시해야 한다. 그래서 여러 이해관계자들 사이에서 조율이 필요하다. Kitchen Sink는 최악의 요구사항이라는 것을 인식해 놓기 바란다. 버릴 고객은 과감히 버려야 한다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;1.2 Product and Process Requirements (&lt;/b&gt;&lt;b&gt;제품요구사항과 프로세스 요구사항)&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;제품요구사항은 개발하려고 하는 소프트웨어 제품의 기능이나 제약에 관한 것이다. 반면에 프로세스 요구사항은 소프트웨어를 개발하는 과정에서 부과되는 제약사항들이다. 예를 들어 &quot;이 소프트웨어는 RUP 프로세스 방식을 이용해서 개발할 것이다&quot; 와 같은 것들이다. 혹은 Java를 이용한다와 같은 것들이다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;어떤 소프트웨어는 암묵적인 프로세스 요구사항을 가지고 있다. 예를 들어 테스팅의 경우 특수한 테스팅 기계가 필요할 수도 있고 국방부 프로젝트와 같이 공식적인 문서작성 방식을 따라야 하는 경우도 있다. 프로세스 요구사항은 개발조직에서 자체적으로 설정할 수도 있고, 고객이 설정할 수도 있고 &amp;nbsp;안전검증기관과 같이 국가기관에서 설정할 수도 있듯이 다양한 요구자가 있다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;1.3 Functional and Nonfunctional Requirements (&lt;/b&gt;&lt;b&gt;기능요구사항과 비기능요구사항)&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;기능요구사항은 소프트웨어가 실행하는 기능(Function)을 묘사한다. 보통 기능(Capability) 혹은 특성(Feature) 이라고 알려져 있다. 테스팅 관점에서는 제품 동작을 검증하기 위해서 유한한 테스팅 단계에 의해 검증이 가능한 단위를 의미한다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;(***필자주석) 테스트 케이스의 설명으로 요구사항을 정의할 수 있다는 것이 바로 Agile 방법론 중의 하나이다. 어차피 요구사항과 테스트 케이스가 일대일 매핑이 가능하다면 같은 기능을 두 번 명시하는 것은 중복이라고 할 수 있다. 즉 테스트의 자세한 설명으로 내가 무엇을 개발할지 확실히 알 수 있는 제품이라면 당연히 요구사항을 추가로 적을 필요는 없다. 하지만 그런 제품은 많지 않다는 것이다. 예를 들어 사용자의 관점에서 테스트를 할 수 있는 홈페이지 같은 것들은 숨어있는 로직이 별로 없기 때문에 테스트 케이스를 작성하나 요구사항을 작성하나 큰 차이가 없다. 이럴 경우는 선택의 문제라고 할 수 있다. 정상적인 경우는 요구사항은 요구사항 방식으로 적는 것이 99%의 경우에 해당한다고 보면 된다. 또 요구사항 대신에 테스트 케이스를 적는다고 하더라도 요구사항 작성역량이 있는 상태에서 결정하는 것이 옳다. 기본도 되어 있지 않은 상태에서 테스트 케이스로 요구사항을 대신한다는 것은 매우 위험한 일이다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;비기능요구사항은 제품에 기능 외에 제약사항이 있다는 것을 의미한다. 용어로는 제약요구사항 (Constraint Requirements) 혹은 특성요구사항 (Quality Requirements)이라고 한다. 더 자세하게 나누면 성능요구사항 (Performance Requirements), 유지보수요구사항 (Maintainability Requirements), 안전요구사항(Safety Requirements), 상호운영성성요구사항 (Interoperability Requirements) 등 많은 비기능적인 요구사항들을 의미한다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;(***필자주석)&amp;nbsp; 현실적으로 이 비기능요구사항이 기능요구사항에 비해 작성하기 훨씬 어려운 부분이다. 난이도로 볼 때 10배 이상 어렵다고 볼 수 있다. 그만큼 기능요구사항을 적을 때 보다 훨씬 더 많은 경험이 필요한 분야이다. 템플릿에도 자세한 설명이 나와 있지도 않고 가르쳐 줄 수도 없다. 원칙을 이해하고 상상력을 동원해 적어야 하는 부분이다. 제품의 심각한 문제는 주로 이 비기능요구사항의 부족함에서 생긴다. 소프트웨어 개발에서의 큰 소송은 발주자와 개발자의 커뮤니케이션의 오해에서 생기는데 기능요구사항보다는 비기능요구사항에서 문제가 될 확률이 훨씬 높다. 이 문제는 교육이나 강의로 가르쳐 줄 수 있는 문제가 아니고 같이 일하면서 경험을 쌓으면서 커가는 역량이다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;1.4 Emergent Properties (&lt;/b&gt;&lt;b&gt;출현특성)&lt;/b&gt;&lt;br /&gt;이 특성은 어느 하나의 컴포넌트에서 나오는 요구사항이 아닌 여러 개의 컴포넌트의 상호작용에 의해 출현되는 요구사항이다. 예를 들어 Call Center에서 얼마나 많은 전화를 응대할 수 있는가 하는 것은 전화 중계기, 전산 시스템, 그리고 전화응대 직원이 현실 상황에서 어떻게 상호작용하는 것에 의해서 결정된다. 이 출현특성은 시스템 아키텍처에서 매우 중요하게 고려되는 요소이다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;(***필자주석) 순수 소프트웨어만을 개발하는 경우라면 소프트웨어 아키텍처만 걱정하면 되겠지만 많은 소프트웨어는 하드웨어 시스템과 같이 연관되어 있다. 그게 소프트웨어 역사에서의 최초 사용도이기도 했다. 바로 임베디드 시스템이다. 그러므로 소프트웨어 요구사항을 작성한다고 하면 많은 경우에 시스템 요구사항과 시스템 아키텍처가 상위수준에서 우선적으로 명시되게 되어 있다. 앞으로도 이 차이점에 대해 뒷부분 여기저기서 나오겠지만 일단은 생각하는 방식과 작성하는 방식은 하드웨어나 소프트웨어나 동일하다는 것을 인식해 놓기 바란다.&lt;/div&gt;&lt;br /&gt;&lt;b&gt;1.5 Quantifiable Requirements (&lt;/b&gt;&lt;b&gt;정량적인 요구사항)&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;소프트웨어 요구사항은 명확하게 (Clearly) 그리고 애매모호하지 않게(Unambiguously) 명시되어야 한다. 그리고 가능한 한 정량적으로 명시되어야 한다. &quot;대충&quot; 그리고 &quot;검증할 수 없게&quot; 적는 것은 피해야 한다. 사람마다 다르게 해석되는 대표적인 용어의 예가 &quot;신뢰할 만한&quot; 그리고 &quot;사용자에게 친숙한&quot; 과 같은 용어이다. 정량적인 요구사항은 특히 비기능요구사항의 경우에 중요하다. Call Center의 경우에 정량적으로 비기능요구사항을 &amp;nbsp;명시한 예를 보면 &quot;시간당 처리량(Throughput)이 현재보다 20% 증가해야 하고 치명적인 오류는 시간당 1 * 10**(-8) 보다 작게 발생해야 한다&quot;이다. 이 상위수준의 정량적 요구사항에 따라서 하위 컴포넌트에게 많은 자세한 요구사항이 생겨날테고 또 시스템 어키텍처에 많은 제약을 가하게 될 것이다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;(***필자주석) 정량적으로 적는다는 것이 생각보다는 훨씬 어렵다. 잘 적을 수 있다면 이미 글로벌 분석가 수준이다. 대부분의 초보자들의 핑계는 해보지 않고 어떻게 숫자를 얘기할 수 있느냐고 한다. 해보지 않고도 알 수 있는 방법은 과거의 경험으로 유추하거나 현재의 환경에서 미래를 시뮬레이션 해서 상상해야 하는 매우 어려운 지식산업의 영역이다. 그리고 통찰력도 필요하다. 이 부분을 잘 명시할 수 없다면 외국에서는 계약이 성립되지도 않거니와 운이 좋아 계약을 했다고 해도 100% 소송의 대상이다. 계약의 기쁨이 악몽으로 변하는 지름길이기도 하다. 국내 소프트웨어 SI 업체와의 &amp;nbsp;계약을 보면 이 부분이 매우 취약하다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;1.6 System Requirements and Software Requirements (&lt;/b&gt;&lt;b&gt;시스템요구사항과 소프트웨어요구사항)&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&quot;시스템&quot;은 International Council on Software and Systems Engineering(INCOSE)에서 다음과 같이 정의된다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;시스템은 원하는 목적을 위해 상호작용해야 하는 모든 요소들의 집합이다. 즉 하드웨어, 소프트웨어, 펌웨어, 사람, 데이터 정보, 조작기술, 시설, 서비스 등 모든 지원시설이다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;시스템요구사항은 시스템 전체에게 부과되는 요구사항이다. 소프트웨어를 포함하는 시스템에서는 당연히 시스템요구사항으로부터 소프트웨어요구사항이 파생되어 나오게 된다. 한편으로는 사용자요구사항(User Requirements)은 고객이나 최종 사용자의 입장에서 정의된다. 반면에 시스템요구사항은 사용자요구사항과 같이 사용자의 관점에서만 본 시스템이 아닌 정부의 규제 조항이나 안전요구사항과 같은 모든 요구사항을 의미한다.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;color: blue;&quot;&gt;(***필자주석) 시스템요구사항과 소프트웨어 요구사항은 앞으로도 계속 혼란을 가져오는 이슈이므로 조금이라도 빨리 확실한 이해를 해 두는 것이 중요하다. 근본적으로 생각하는 방식은 같지만 생각할 대상이 시스템에서는 광범위하므로 소프트웨어 만의 경험으로는 작성하기 어려운 것은 사실이다. 산업 도메인 지식도 있어야 하고 하드웨어나 경우에 따라 펌웨어에 대한 기본 이해는 하고 있어야 한다.&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;2. Requirement Process (&lt;/b&gt;&lt;b&gt;요구사항 프로세스) - 다음 Post에서 다룬다&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.ikwisdom.com/feeds/2355798284792713697/comments/default' title='댓글'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=1365591944722180079&amp;postID=2355798284792713697' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/2355798284792713697'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1365591944722180079/posts/default/2355798284792713697'/><link rel='alternate' type='text/html' href='http://www.ikwisdom.com/2014/06/swebok-2.html' title='SWEBOK - 소프트웨어 요구사항 #2'/><author><name>김익환(Ike Kim)</name><uri>http://www.blogger.com/profile/11340247295485319971</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//3.bp.blogspot.com/-x__od8uqpcc/Vyxog9hJalI/AAAAAAAAN9A/0W4t02UojOEtChtp6UQkq_cFYEp5ynM5gCK4B/s113/%25EA%25B9%2580%25EC%259D%25B5%25ED%2599%2598_20150722_%25EC%25A6%259D%25EB%25AA%2585%25EC%2582%25AC%25EC%25A7%2584.jpg'/></author><thr:total>0</thr:total></entry></feed>