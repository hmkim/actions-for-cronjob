<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>/usr/lib/libsora.so on /usr/lib/libsora.so</title>
    <link>https://libsora.so/</link>
    <description>Recent content in /usr/lib/libsora.so on /usr/lib/libsora.so</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Tue, 12 Feb 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>10년이면 강산도 변한다. 그리고 자바스크립트도</title>
      <link>https://libsora.so/posts/in-ten-years-strong-mountains-will-change-and-javascript/</link>
      <pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/in-ten-years-strong-mountains-will-change-and-javascript/</guid>
      <description>&lt;p&gt;얼마전에 구버전 IE에서만 돌아가는 코드를 밟아서 &lt;a href=&#34;https://libsora.so/posts/generous-code-breaks-easily&#34;&gt;글&lt;/a&gt;을 썼다.
글을 쓰다가가 옛날에 밟은 IE 구버전과 관련된 재밌는 코드가 생각났다.
그래서 옛날 이야기를 하나 더 써봤다.&lt;/p&gt;

&lt;p&gt;자바스크립트를 쓰다보면 다른 언어에서는 생각도 못한 코드를 가끔본다.
객체의 프로퍼티로 if, for, while 같은 키워드를 쓸 수 있다.
다른 언어였으면 문법에러로 처리했을지 모른다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;a = {if: 1}
&amp;gt; {if: 1}
a.if
&amp;gt; 1
a[&#39;if&#39;]
&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;재밌게도 위의 문법은 IE 구버전에서는 안돌아간다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://libsora.so/posts/in-ten-years-strong-mountains-will-change-and-javascript/ie-legacy-property.png&#34; alt=&#34;ie&#34; /&gt;&lt;/p&gt;

&lt;p&gt;IE 구버전에서는 키워드를 프로퍼티로 쓸 수 없다. 객체에 &lt;code&gt;a[&#39;if&#39;]&lt;/code&gt; 로 접근할순 있지만 &lt;code&gt;a.if&lt;/code&gt; 로 접근할 순 없다.
황당해서 찾아본 적이 있는데 자바스크립트 스펙이 변했더라.
옛날 표준 자바스크립트에서는 키워드를 프로퍼티로 쓸수 없었지만 요새 자바스크립트에서는 키워드를 프로퍼티로 쓸 수 있다.&lt;/p&gt;

&lt;p&gt;1997년 자바스크립트 스펙을 뒤져보자. &lt;a href=&#34;https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%201st%20edition,%20June%201997.pdf&#34;&gt;ECMA-262 1판&lt;/a&gt;이다.
11.2 Left-Hand-Side Expressions 에 프로퍼티 문법이 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MemberExpression :
    PrimaryExpression
    MemberExpression [ Expression ]
    MemberExpression . Identifier
    new MemberExpression Arguments
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;프로퍼티에 접근시 expression 또는 identifier를 쓸 수 있다.
그렇다면 identifier란 무엇인가? 7.5 Identifiers 에 나와있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Identifier ::
    IdentifierName but not ReservedWord
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1997년 스펙에 의해 IE 구버전에서는 reserved word는 프로퍼티에 쓸 수 없다.
그래서 &lt;code&gt;a[&#39;if&#39;]&lt;/code&gt; 는 가능하지만 &lt;code&gt;a.if&lt;/code&gt; 는 불가능하다.&lt;/p&gt;

&lt;p&gt;이번에는 2018년 자바스크립트 스펙을 뒤져보자. &lt;a href=&#34;https://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf&#34;&gt;ECMA-262 9판&lt;/a&gt;이다.
12.3.2 Property Accessors 에 프로퍼티 문법이 있다&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Properties are accessed by name, using either the dot notation:

MemberExpression . IdentifierName
CallExpression . IdentifierName

or the bracket notation:

MemberExpression [ Expression ]
CallExpression [ Expression ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;프로퍼티 접근시 expression 또는 identifier name을 쓸 수 있다.
1997년 스펙에서는 identifier 였지만 2018년에는 identifier name으로 바뀌었다.&lt;/p&gt;

&lt;p&gt;예약어과 관련된 내용도 찾아보자.  11.6.2 Reserved Words 에 예약어가 정의되어있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A reserved word is an IdentifierName that cannot be used as an Identifier.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;reservered word는 identifer로는 쓸 수 없지만 identifier name으로는 쓸 수 있다. 1997년 스펙과는 다르다.&lt;/p&gt;

&lt;p&gt;2018년 스펙에 의해 요새 자바스크립트에서는 reserved word는 프로퍼티에 쓸 수 있다.
그래서 &lt;code&gt;a[&#39;if&#39;]&lt;/code&gt; 도 가능하고 &lt;code&gt;a.if&lt;/code&gt; 도 가능하다.&lt;/p&gt;

&lt;p&gt;10년이면 강산도 변한다. 자바스크립트 표준도 변한다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>관대한 코드는 쉽게 망가진다</title>
      <link>https://libsora.so/posts/generous-code-breaks-easily/</link>
      <pubDate>Mon, 11 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/generous-code-breaks-easily/</guid>
      <description>

&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.kocw.net/home/index.do&#34;&gt;KOCW&lt;/a&gt;를 통해서 &lt;a href=&#34;http://www.kocw.net/home/search/kemView.do?kemId=332498&#34;&gt;집합론&lt;/a&gt;을 공부하기 시작했다.
동영상 강의 보기를 눌렀더니 크롬에서는 안돌아가더라.
액티브엑스 기반 강의라고 붙어있더니 역시나 크롬에서 안되는거같더라.
그래서 익스플로러를 켜고 인강을 들어갔다.
IE로도 동영상 강의가 나오지 않더라.
왜 안돌아가나 확인해가 위해서 크롬 개발자 도구를 켰더니 이런 코드가 있더라.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://libsora.so/posts/generous-code-breaks-easily/bug.png&#34; alt=&#34;bug&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function window.onload() {
    ....
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;잉? 함수 이름에 &lt;code&gt;.&lt;/code&gt; 들어가는게 가능했어?
이런 코드는 처음봤다.
처음보는 황당한 코드, 한때는 잘 돌아갔던 프로그램, 답은 뻔하다.
&lt;strong&gt;IE 구버전&lt;/strong&gt;.
IE 호환성 모드를 켜고 인강을 켜니까 잘 돌아갔다.&lt;/p&gt;

&lt;p&gt;IE 구버전에서만 해당되는 문제니까 이제와서는 아무짝에도 쓸모없지만 재밌는 현상이길래 글을 써봤다.&lt;/p&gt;

&lt;h2 id=&#34;문제가-발생하는-코드&#34;&gt;문제가 발생하는 코드&lt;/h2&gt;

&lt;p&gt;브라우저 개발자 도구를 켜고 아래의 코드를 넣으면 잘 돌아간다&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;a = {};
a.b = {};
a.b.foo = function() { console.log(1); };
a.b.foo();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;하지만 아래의 코드는 아마 안돌아갈거다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function a.b.bar() { console.log(2); }
a.b.bar();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;크롬의 경우 &lt;code&gt;Uncaught SyntaxError: Unexpected token .&lt;/code&gt; 라는 에러가 발생한다.
함수이름에 &lt;code&gt;.&lt;/code&gt;이 들어가는게 문법적으로 올바르지 않나보다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://libsora.so/posts/generous-code-breaks-easily/capture-chrome.png&#34; alt=&#34;chrome&#34; /&gt;&lt;/p&gt;

&lt;p&gt;하지만 IE 호환성 모드를 활성화하면 잘 돌아간다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://libsora.so/posts/generous-code-breaks-easily/capture-ie-legacy.png&#34; alt=&#34;ie legacy&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;원인&#34;&gt;원인&lt;/h2&gt;

&lt;p&gt;IE 구버전은 옛날 물건이다.
요새 자바스크립트 스펙으로 IE 구버전을 공격하는건 너무하잖아?
1997년에 작성된 &lt;a href=&#34;https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%201st%20edition,%20June%201997.pdf&#34;&gt;ECMA-262 1판&lt;/a&gt;을 보자.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;13. Function Definition&lt;/code&gt; 에 함수의 문법 정의가 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FunctionDeclaration :
    function Identifier ( FormalParameterListopt ) Block
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;함수 이름은 identifier만 가능하다.
그렇다면 identifier의 문법은 무엇인가?
&lt;code&gt;7.5 Identifiers&lt;/code&gt; 를 보면 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Identifier ::
    IdentifierName but not ReservedWord
IdentifierName ::
    IdentifierLetter
    IdentifierName IdentifierLetter
    IdentifierName DecimalDigit
IdentifierLetter :: one of
    a b c d e f g h i j k l m n o p q r s t u v w x y z
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z  
    $ _
DecimalDigit :: one of
    0 1 2 3 4 5 6 7 8 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;최초의 자바스크립트 문법을 보면 identifier에 &lt;code&gt;.&lt;/code&gt;가 들어가는걸 허용하지 않는다.
&lt;code&gt;.&lt;/code&gt;는 다른 목적으로 써야하니까 이걸 identifer로 허용하는건 제정신이 아닐거다.
IE 구버전이 ECMA-262 스펙을 지키지 않은게 원인이다.&lt;/p&gt;

&lt;h2 id=&#34;개발-의도&#34;&gt;개발 의도?&lt;/h2&gt;

&lt;p&gt;내가 익스플로러를 구현한게 아니니까 익스플로러 개발자가 무슨 생각으로 저런 결정을 했나 정확히 알지는 못한다.
하지만 상상은 할 수 있겠다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;a.b.c = function() { ... };
function a.b.c() { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 두 코드를 똑같이 취급하게 만들고 싶었나보다.
비슷한 느낌의 코드가 자바스크립트가 또 있다.
자바스크립트에서 &lt;code&gt;foo[&#39;bar&#39;]&lt;/code&gt;와 &lt;code&gt;foo.bar&lt;/code&gt;를 똑같이 취급한다.&lt;/p&gt;

&lt;p&gt;IE의 자바스크립트는 JavaScript 아니라 JScript이다.
그래서 표준을 적당히 무시하고 구현했을지 모른다.&lt;/p&gt;

&lt;p&gt;IE 구버전에서 허용한 의도는 이해하겠는데 좀 우주로 가는 코드같다.
표준을 지키지 않고 적당히 짠 코드는 세월이 지나면 무너진다.
세상에는 미개한 개발자가 많고 황당한 코드를 많이 짜니까.
표준은 미개한 개발자를 이상한 짓을 못하게 막을때 쓸 수 있는 좋은 도구다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>타입스크립트에서 절대경로 쓰기</title>
      <link>https://libsora.so/posts/use-absolute-path-in-typescript/</link>
      <pubDate>Sun, 10 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/use-absolute-path-in-typescript/</guid>
      <description>

&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;

&lt;p&gt;요새 타입스크립트를 쓰고있다.
100줄짜리 프로그램 짜는게 아니니 소스파일이 수십개로 나뉘어져있다.
파일에 접근하기 위해서는 디렉토리 구조도 몇단계로 내려가야 한다.
소스 파일간의 import하는 일이 많은데 타입스크립트에서는 기본적으로 상대경로 쓰더라.
그래서 import에 들어가는 경로가 깨끗하지 않다.
&lt;code&gt;../../..&lt;/code&gt;가 자주 등장하더라.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;import { bar } from &#39;../../../../bar&#39;;

export const foo = () =&amp;gt; {
  console.log(bar());
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;설계에 따라서는 상대경로로 밑에서 경로를 접근하는것보다 위에서 내려가는게 빠를 수 있다.
그리고 import 경로로 깔끔하게 만들 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;import { bar } from &#39;@src/bar&#39;;

export const foo = () =&amp;gt; {
  console.log(bar());
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;절대경로라고 표현하긴 했지만 &lt;code&gt;c:\repo\sample\src\bar\index.ts&lt;/code&gt;같은 진짜 절대경로는 쓰지 않을 것이다.
진짜 절대경로는 다른 컴퓨터에서 안돌아간다.
프로젝트 디렉토리를 루트 디렉토리로 취급하는 것을 절대경로라고 표현할거다.
유사-절대경로라고 부를 수 있다.&lt;/p&gt;

&lt;p&gt;이 글에서는 타입스크립트에서 절대경로를 쓰는 방법을 정리했다.
그리고 내가 자주 쓰는 도구인 webpack, ts-node, jest가 제대로 동작하게 설정하는 방법도 정리했다.&lt;/p&gt;

&lt;h2 id=&#34;샘플-프로젝트-구조&#34;&gt;샘플 프로젝트 구조&lt;/h2&gt;

&lt;p&gt;절대경로가 잘 돌아가는지 확인하기 위한 &lt;a href=&#34;https://github.com/if1live/libsora.so/tree/master/content/typescript/use-absolute-path-in-typescript&#34;&gt;샘플 프로젝트&lt;/a&gt;를 만들었다.
디렉토리 구조는 다음과 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── src
│   ├── index.ts
│   ├── foo
│   │   └── a
│   │       └── b
│   │           └── c
│   │               └── index.ts
│   └── bar
│       └── index.ts
└── test
    └── bar
        └── index.test.ts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;src/index.ts가 프로젝트의 진입점이다.
src/index.ts는 foo/a/b/c/index.ts를 갖다쓴다.
src/foo/a/b/c/index.ts에서 src/bar/index.ts를 갖다쓴다.
유닛테스트는 별도 디렉토리로 분리했다.
테스트는 jest를 사용해서 돌릴거다.&lt;/p&gt;

&lt;p&gt;해당 프로젝트에서는 상대경로를 쓰지 않는다.
절대경로만으로 돌아가게 만들 것이다.&lt;/p&gt;

&lt;h2 id=&#34;tsc&#34;&gt;tsc&lt;/h2&gt;

&lt;p&gt;src/foo/a/b/c/index.ts 내용은 다음과 같다.
상대경로를 썻으면 import가 얼마나 길어지는지 비교할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// import { bar } from &#39;../../../../bar&#39;;
import { bar } from &#39;@src/bar&#39;;

export const foo = () =&amp;gt; {
  console.log(bar());
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 코드는 컴파일 되지 않는다.
타입스크립트는 &lt;code&gt;@src&lt;/code&gt;가 어디인지 모르기 때문이다.
나는 &lt;code&gt;@src&lt;/code&gt;가 프로젝트 디렉토리의 &lt;code&gt;/src&lt;/code&gt;라고 알고있다.
타입스크립트 설정파일을 고치자.
타입스크립트 컴파일러가 &lt;code&gt;@src&lt;/code&gt;가 무엇인지 알면 제대로 컴파일할 수 있다.&lt;/p&gt;

&lt;p&gt;타입스크립트 문서에서 &lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/module-resolution.html&#34;&gt;Module Resolution&lt;/a&gt;를 찾아보자.
Path mapping 항목을 tsconfig.json에 적용하자.
paths와 baseUrl을 적절히 설정해주 컴파일러가 &lt;code&gt;@src&lt;/code&gt;를 이해할 수 있다.&lt;/p&gt;

&lt;p&gt;tsconfig.json&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;compilerOptions&amp;quot;: {
    ...
    &amp;quot;baseUrl&amp;quot;: &amp;quot;.&amp;quot;,
    &amp;quot;paths&amp;quot;: {
      &amp;quot;@src/*&amp;quot;: [
        &amp;quot;src/*&amp;quot;
      ]
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 컴파일이 된다.&lt;/p&gt;

&lt;h2 id=&#34;node&#34;&gt;node&lt;/h2&gt;

&lt;p&gt;컴파일된 코드를 node로 돌려보자.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ node .\dist\src\index.js
internal/modules/cjs/loader.js:582
    throw err;
    ^

Error: Cannot find module &#39;@src/bar&#39;
    .....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;안돌아간다.
컴파일만 되었을뿐이다.&lt;/p&gt;

&lt;p&gt;tsc에 의해서 생성된 파일을 열어보면 원인을 알 수 있다.
소스를 보면 &lt;code&gt;require(@src/bar)&lt;/code&gt;가 있다.
하지만 node는 &lt;code&gt;@src/bar&lt;/code&gt;가 어떤 경로인지 모른다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;quot;use strict&amp;quot;;
Object.defineProperty(exports, &amp;quot;__esModule&amp;quot;, { value: true });
// import { bar } from &#39;../../../../bar&#39;;
var bar_1 = require(&amp;quot;@src/bar&amp;quot;);
exports.foo = function () {
    console.log(bar_1.bar());
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;비슷한 문제는 다들 한번씩 겪었을것이다.
C, C++ 쓰다보면 컴파일은 성공했지만 링킹(linking)이 되지 않는 문제를 당했을 것이다.
비주얼 C++ 쓰다보면 보는 LNK???? 에러.&lt;/p&gt;

&lt;p&gt;C를 컴파일하면 object 파일이 생성된다.
여러 파일로 구성된 C 프로젝트면 object 파일도 여러개가 생성된다.
이것을 하나로 합쳐야 실행 가능한 파일이 만들어진다.&lt;/p&gt;

&lt;p&gt;타입스크립트 소스 파일들이 컴파일되어 자바스크립트 파일이 생성되었다.
하지만 자바스크립트 파일간에는 연결이 없다.
&lt;code&gt;@src&lt;/code&gt;를 node도 알아먹을수 있는 형태로 바꿔야한다.&lt;/p&gt;

&lt;h2 id=&#34;webpack&#34;&gt;webpack&lt;/h2&gt;

&lt;p&gt;webpack은 모듈 번들러이다.
webpack을 쓰면 분리되어있는 자바스크립트 소스 파일을 하나로 파일로 묶어줄 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://libsora.so/posts/use-absolute-path-in-typescript/toptal-blog-image-1476174229140-3890202f75d94c0692549af41f9d652a.png&#34; alt=&#34;webpack&#34; /&gt;&lt;/p&gt;

&lt;p&gt;생각해보면 linker와 하는 짓이 유사하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://libsora.so/posts/use-absolute-path-in-typescript/COMPILE.gif&#34; alt=&#34;linker&#34; /&gt;&lt;/p&gt;

&lt;p&gt;linking 하듯이 webpack을 이용해서 분리된 자바스크립트 파일을 합칠때 &lt;code&gt;@src&lt;/code&gt;를 멀쩡한 이름으로 바꿀 수 있으면 프로그램이 돌아갈거다.
webpack이 &lt;code&gt;@src&lt;/code&gt;를 알아듣게 만드는 방법은 남들이 간 길을 찾으니 나오더라.
&lt;a href=&#34;https://robferguson.org/blog/2017/11/22/working-with-typescript-webpack-and-ionic-3/&#34;&gt;Working with TypeScript, webpack and Ionic 3&lt;/a&gt; 를 참고했다.
webpack 설정파일에 alias 를 설정하면 된다더라.
나는 절대경로라고 불렀는데 webpack에서는 이것을 alias라고 부르나보다.&lt;/p&gt;

&lt;p&gt;webpack.config.js&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;...
module.exports = {
  ....
  resolve: {
    extensions: [
      &#39;.ts&#39;,
      &#39;.tsx&#39;,
      &#39;.js&#39;,
      &#39;.json&#39;,
    ],
    // -----
    &#39;alias&#39;: {
      &#39;@src&#39;: path.resolve(__dirname, &#39;src&#39;),
    },
    // ----
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 webpack으로 뽑은 파일은 잘 실행된다.&lt;/p&gt;

&lt;h2 id=&#34;ts-node&#34;&gt;ts-node&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/TypeStrong/ts-node&#34;&gt;ts-node&lt;/a&gt;는 내가 좋아하는 도구다.
프로젝트의 설명을 보면 TypeScript execution and REPL for node.js 라고 되어있다.
타입스크립트는 node에서 바로 돌릴 수 없다.
tsc로 컴파일한후 생성된 자바스크립트 파일을 node로 돌려야한다.
하지만 이짓을 하는건 너무 귀찮잖아?
ts-node를 설치하면 &lt;code&gt;node xxx.js&lt;/code&gt; 실행하는 느낌으로 &lt;code&gt;ts-node xxx.ts&lt;/code&gt;를 실행할 수 있다.&lt;/p&gt;

&lt;p&gt;절대경로가 들어간 타입스크립트를 ts-node로 실행하면 안돌아간다.
아래와 같은 에러가 튀어나온다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npx ts-node src/index.ts
Cannot find module &#39;@src/bar&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ts-node가 &lt;code&gt;@src&lt;/code&gt;를 못 알아먹는다.
tsconfig.json 에 &lt;code&gt;@src&lt;/code&gt;가 있지만 ts-node가 tsconfig.json의 내용을 전부 쓰지 않나보다.
ts-node의 문서를 뒤져보면 tsconfig-paths를 설치해서 문제를 해결할 수 있다고한다.
이제 절대경로 들어간 타입스크립트도 ts-node로 돌릴 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npx ts-node -r tsconfig-paths/register --files src/index.ts
bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ts-node를 쓸때마다 tsconfig-paths 관련 설정을 치는것은 매우 귀찮다.
package.json를 고치면 노가다가 조금 줄어든다.&lt;/p&gt;

&lt;p&gt;package.json&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  ...
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;ts-node&amp;quot;: &amp;quot;ts-node -r tsconfig-paths/register --files&amp;quot;
  },
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ npm run ts-node src/index.ts

&amp;gt; use-relative-path-in-typescript@1.0.0 ts-node ...
&amp;gt; ts-node -r tsconfig-paths/register --files &amp;quot;.\src\index.ts&amp;quot;

bar
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jest&#34;&gt;jest&lt;/h2&gt;

&lt;p&gt;나는 jest를 이용해서 유닛테스트를 돌린다.
jest는 기본적으로 자바스크립트만 지원한다.
하지만 ts-jest를 설치하면 타입스크립트도 지원한다.
ts-jest를 설치하고 jest돌릴때 타입스크립트 파일은 ts-jest를 거치도록 설정하면 된다.&lt;/p&gt;

&lt;p&gt;package.json&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  ...
  &amp;quot;jest&amp;quot;: {
    ...
    &amp;quot;transform&amp;quot;: {
      &amp;quot;^.+\\.tsx?$&amp;quot;: &amp;quot;ts-jest&amp;quot;
    },
    &amp;quot;testRegex&amp;quot;: &amp;quot;(/__tests__/.*|(\\.|/)(test|spec))\\.(tsx?)$&amp;quot;,
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;잘 설정하면 아래와 같은 유닛테스트를 돌릴 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;import { bar } from &#39;../../src/bar&#39;;

test(&#39;bar&#39;, () =&amp;gt; {
  expect(bar()).toEqual(&#39;bar&#39;);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그렇다면 절대경로를 사용한 유닛테스트도 돌아갈까?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;import { bar } from &#39;@src/bar&#39;;

test(&#39;bar&#39;, () =&amp;gt; {
  expect(bar()).toEqual(&#39;bar&#39;);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; FAIL  test/bar/index.test.ts
  ● Test suite failed to run

    Cannot find module &#39;@src/bar&#39; from &#39;index.test.ts&#39;

    &amp;gt; 1 | import { bar } from &#39;@src/bar&#39;;
        | ^
      2 |
      3 | test(&#39;bar&#39;, () =&amp;gt; {
      4 |   expect(bar()).toEqual(&#39;bar&#39;);

      at Resolver.resolveModule (node_modules/jest-resolve/build/index.js:221:17)
      at Object.&amp;lt;anonymous&amp;gt; (test/bar/index.test.ts:1:1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@src&lt;/code&gt;가 들어간 유닛테스트는 돌릴 수 없다.
jest가 타입스크립트를 위한 물건이 아니다보니 tsconfig.json을 못알아먹는다.
webpack과 마찬가지로 별도 설정이 필요하다.
webpack때와 마찬가지로 남들이 삽질한거 베끼자.
ts-jest의 &lt;a href=&#34;https://kulshekhar.github.io/ts-jest/user/config/&#34;&gt;Configuration&lt;/a&gt;을 참고하면 된다.
&lt;code&gt;moduleNameMapper&lt;/code&gt;를 설정하면 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  ...
  &amp;quot;jest&amp;quot;: {
    ...
    &amp;quot;moduleNameMapper&amp;quot;: {
      &amp;quot;@src/(.*)&amp;quot;: &amp;quot;&amp;lt;rootDir&amp;gt;/src/$1&amp;quot;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>HTTP 요청에 body를 붙여서 보내면 어떤 일이 벌어질까? part 2</title>
      <link>https://libsora.so/posts/http-request-with-body-and-java-httpurlconnection/</link>
      <pubDate>Sat, 09 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/http-request-with-body-and-java-httpurlconnection/</guid>
      <description>

&lt;h2 id=&#34;삽질의-시작&#34;&gt;삽질의 시작&lt;/h2&gt;

&lt;p&gt;이전에 &lt;a href=&#34;https://libsora.so/posts//http-get-request-with-body-and-http-library&#34;&gt;HTTP GET 요청에 body를 붙여서 보내면 어떤 일이 벌어질까?&lt;/a&gt;를 썼다.
나중에 자바의 HttpURLConnection의 동작이 안드로이드 버전의 UnityWebRequest와 똑같다는 소리를 들었다.
유니티 개발자들이 HTTP 라이브러리 만들기 귀찮아서 플랫폼별로 내장된 HTTP 라이브러리를 쓴거 아닐까? 하는 망상을 했다.
그래서 HttpURLConnection로 HTTP 요청을 보낼때 body 붙이는 짓을 해봤다.&lt;/p&gt;

&lt;h2 id=&#34;테스트&#34;&gt;테스트&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const express = require(&#39;express&#39;);

const app = express();
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.all(&#39;/&#39;, (req, res) =&amp;gt; {
  res.json({ method: req.method, body: req.body });
});

const port = 3100;
app.listen(port, () =&amp;gt; {
  console.log(`server listen - ${port}`);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래의 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods&#34;&gt;HTTP request methods&lt;/a&gt;는 표준에 정의되어 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GET&lt;/li&gt;
&lt;li&gt;HEAD : asks for a response identical to that of a GET request, but without the response body.&lt;/li&gt;
&lt;li&gt;POST&lt;/li&gt;
&lt;li&gt;PUT&lt;/li&gt;
&lt;li&gt;DELETE&lt;/li&gt;
&lt;li&gt;CONNECT : establishes a tunnel to the server identified by the target resource.&lt;/li&gt;
&lt;li&gt;OPTIONS&lt;/li&gt;
&lt;li&gt;TRACE&lt;/li&gt;
&lt;li&gt;PATCH&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HEAD와 CONNECT method는 다른 method와 동작이 달라서 보내지 않았다.
나머지 HTTP request method (GET, POST, PUT, DELETE, OPTIONS, TRACE, PATCH)만 테스트해봤다.
(curl로 HEAD, CONNECT 요청을 보내면 재밌는 결과를 볼수있다.)&lt;/p&gt;

&lt;h3 id=&#34;curl&#34;&gt;curl&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

function request_common {
    echo -e &amp;quot;$1 =&amp;gt; \c&amp;quot;
    curl -X $1 http://127.0.0.1:3100/ \
        -H &#39;Content-Type: application/json&#39; \
        -d &#39;{&amp;quot;foo&amp;quot;: 1}&#39; -s
    echo &amp;quot;&amp;quot;
}

request_common &amp;quot;GET&amp;quot;
# request_common &amp;quot;HEAD&amp;quot;
request_common &amp;quot;POST&amp;quot;
request_common &amp;quot;PUT&amp;quot;
request_common &amp;quot;DELETE&amp;quot;
# request_common &amp;quot;CONNECT&amp;quot;
request_common &amp;quot;OPTIONS&amp;quot;
request_common &amp;quot;TRACE&amp;quot;
request_common &amp;quot;PATCH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;$ bash curl-demo.sh
GET =&amp;gt; {&amp;quot;method&amp;quot;:&amp;quot;GET&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;foo&amp;quot;:1}}
POST =&amp;gt; {&amp;quot;method&amp;quot;:&amp;quot;POST&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;foo&amp;quot;:1}}
PUT =&amp;gt; {&amp;quot;method&amp;quot;:&amp;quot;PUT&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;foo&amp;quot;:1}}
DELETE =&amp;gt; {&amp;quot;method&amp;quot;:&amp;quot;DELETE&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;foo&amp;quot;:1}}
OPTIONS =&amp;gt; {&amp;quot;method&amp;quot;:&amp;quot;OPTIONS&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;foo&amp;quot;:1}}
TRACE =&amp;gt; {&amp;quot;method&amp;quot;:&amp;quot;TRACE&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;foo&amp;quot;:1}}
PATCH =&amp;gt; {&amp;quot;method&amp;quot;:&amp;quot;PATCH&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;foo&amp;quot;:1}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;curl을 이용해서 요청을 보낸 경우 서버에서 요청에 붙은 body를 받을 수 있다.
curl로 요청을 보낸 경우 응답이 원하는대로 나온다.
서버는 잘 돌아간다는걸 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;java-httpurlconnection&#34;&gt;java HttpURLConnection&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.net.URL;
import java.net.HttpURLConnection;
import java.io.*;
import java.nio.charset.Charset;
import java.util.stream.Collectors;

public class Demo {
    public static void requestCommon(String method) throws Exception {
        String query = &amp;quot;http://127.0.0.1:3100&amp;quot;;
        String json = &amp;quot;{\&amp;quot;key\&amp;quot;:1}&amp;quot;;

        URL url = new URL(query);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setConnectTimeout(5000);
        conn.setRequestProperty(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json; charset=UTF-8&amp;quot;);
        conn.setDoOutput(true);
        conn.setDoInput(true);
        conn.setRequestMethod(method);

        OutputStream os = conn.getOutputStream();
        os.write(json.getBytes(&amp;quot;UTF-8&amp;quot;));
        os.close();

        // read the response
        Charset charset = Charset.defaultCharset();
        InputStream in = new BufferedInputStream(conn.getInputStream());
        String resp = &amp;quot;&amp;quot;;
        try (BufferedReader br = new BufferedReader(new InputStreamReader(in, charset))) {
           resp = br.lines().collect(Collectors.joining(System.lineSeparator()));
        }

        System.out.println(resp);

        in.close();
        conn.disconnect();
    }

    public static void main(String[] args) throws Exception {
        String[] methods = {
            &amp;quot;GET&amp;quot;,
            // &amp;quot;HEAD&amp;quot;,
            &amp;quot;POST&amp;quot;,
            &amp;quot;PUT&amp;quot;,
            &amp;quot;DELETE&amp;quot;,
            // &amp;quot;CONNECT&amp;quot;,
            &amp;quot;OPTIONS&amp;quot;,
            &amp;quot;TRACE&amp;quot;,
            &amp;quot;PATCH&amp;quot;,
        };
        for(String method : methods) {
            System.out.print(method + &amp;quot; =&amp;gt; &amp;quot;);
            try {
                requestCommon(method);
            } catch(Exception e) {
                System.out.println(e.getMessage());
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;GET =&amp;gt; {&amp;quot;method&amp;quot;:&amp;quot;POST&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;key&amp;quot;:1}}
POST =&amp;gt; {&amp;quot;method&amp;quot;:&amp;quot;POST&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;key&amp;quot;:1}}
PUT =&amp;gt; {&amp;quot;method&amp;quot;:&amp;quot;PUT&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;key&amp;quot;:1}}
DELETE =&amp;gt; {&amp;quot;method&amp;quot;:&amp;quot;DELETE&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;key&amp;quot;:1}}
OPTIONS =&amp;gt; {&amp;quot;method&amp;quot;:&amp;quot;OPTIONS&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;key&amp;quot;:1}}
TRACE =&amp;gt; HTTP method TRACE doesn&#39;t support output
PATCH =&amp;gt; Invalid HTTP method: PATCH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자바의 HttpURLConnection를 사용한 경우의 출력이다.
body가 붙은 HTTP 요청을 보내니까 HTTP request method에 따라서 출력이 다르다.
비슷한거끼리 묶어서 보자.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;HTTP request method&lt;/th&gt;
&lt;th&gt;desc&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;POST로 보내진다.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;POST, PUT, DELETE, OPTION&lt;/td&gt;
&lt;td&gt;성공&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;TRACE&lt;/td&gt;
&lt;td&gt;HTTP method TRACE doesn&amp;rsquo;t support output&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PATCH&lt;/td&gt;
&lt;td&gt;Invalid HTTP method: PATCH&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;httpurlconnection&#34;&gt;HttpURLConnection?&lt;/h2&gt;

&lt;h3 id=&#34;get이-post로-바뀐-이유&#34;&gt;GET이 POST로 바뀐 이유&lt;/h3&gt;

&lt;p&gt;동작이 이상해보일때는 소스를 뜯어보자.
스펙을 뒤지는 사람도 있던데 나는 영어를 못해서 그런거 힘들어.
검색하다보니 스택오버플로우에서 &lt;a href=&#34;https://stackoverflow.com/a/27243207&#34;&gt;좋은 답변&lt;/a&gt;을 찾았다.&lt;/p&gt;

&lt;p&gt;답변에서는 SUN자바의 HttpURLConnection 구현을 찍어주더라.
하지만 접속이 안되더라.
그래서 OpenJDK에서 비슷한 코드를 찾았다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/tip/src/share/classes/sun/net/www/protocol/http/HttpURLConnection.java#l1072&#34;&gt;http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/tip/src/share/classes/sun/net/www/protocol/http/HttpURLConnection.java#l1072&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (method.equals(&amp;quot;GET&amp;quot;)) {
    method = &amp;quot;POST&amp;quot;; // Backward compatibility
}
if (!&amp;quot;POST&amp;quot;.equals(method) &amp;amp;&amp;amp; !&amp;quot;PUT&amp;quot;.equals(method) &amp;amp;&amp;amp;
    &amp;quot;http&amp;quot;.equals(url.getProtocol())) {
    throw new ProtocolException(&amp;quot;HTTP method &amp;quot; + method +
                                &amp;quot; doesn&#39;t support output&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Backward compatibility라니!
하위 호환성 문제로 request body가 붙은 GET 요청은 POST로 바꿔친댄다.
그렇다면 하위 호환성이 발생한 이유에 대해 망상해보자.
멍청한 결정을 분석할때는 역사적 배경도 고려해야된다.
지금보면 멍청해보이는 결정도 그때는 그럴싸했을지 모른다.
자바 만든 사람들이 나보다 멍청할리 없잖아?&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/net/HttpURLConnection.html&#34;&gt;HttpURLConnection&lt;/a&gt;은 오래된 클래스이다.
문서를 보면 JDK 1.1 시절부터 있었다고한다.
JDK 1.1은 1997년 2월 19일에 나왔다고하더라.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Representational_state_transfer&#34;&gt;REST&lt;/a&gt;은 Roy Fielding의 2000년 박사학위 논문에서 소개되었다고 하더라.&lt;/p&gt;

&lt;p&gt;HTTP/1.0은 1996년에 나왔다.
RFC1945 &lt;a href=&#34;https://tools.ietf.org/html/rfc1945&#34;&gt;Hypertext Transfer Protocol &amp;ndash; HTTP/1.0&lt;/a&gt;의 공개일이 1996년 5월이더라.
HTTP/1.0에서 제대로된 HTTP request method는 GET, HEAD, POST 뿐이었다.
RFC에서 PUT, DELETE, LINK, UNLINK라는 HTTP method도 언급하지만 Additional Request Methods라는 해서 부록에 붙어있다.&lt;/p&gt;

&lt;p&gt;HTTP/1.1은 1997년에 나왔다.
RFC2068 &lt;a href=&#34;https://tools.ietf.org/html/rfc2068&#34;&gt;Hypertext Transfer Protocol &amp;ndash; HTTP/1.1&lt;/a&gt;의 공개일은 1997년 1월이다.
HTTP request method는 OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE가 되었다. 지금이랑 크게 다르지 않다.&lt;/p&gt;

&lt;p&gt;시간순으로 적당히 나열하자.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;1996년 5월: HTTP/1.0&lt;/li&gt;
&lt;li&gt;1997년 1월: HTTP/1.1&lt;/li&gt;
&lt;li&gt;1997년 2월: JDK 1.1&lt;/li&gt;
&lt;li&gt;2000년 : REST&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;HttpURLConnection 만들던 시절에는 REST라는 개념이 없었다.
JDK 1.1의 생일과 HTTP/1.1의 생일은 1달 밖에 차이나지 않는다.
개발 기간을 생각하면 HttpURLConnection은 HTTP/1.1이 아니라 HTTP/1.0을 보고 만들었을것이다.
HTTP/1.0에는 HEAD, GET, POST뿐이니 request body가 붙은 요청을 POST로 바꾸는게 멍청한 구현이 아니다.
HTTP/1.1이었다면 request body가 붙는 요청이 POST말고도 PUT, PATCH도 있으니까 멋대로 GET을 POST로 바꾸면 안된다.&lt;/p&gt;

&lt;p&gt;HTTP 코드랑 구현체의 주석을 보니 초기에 만든 동작을 그대로 유지시켰나보다.&lt;/p&gt;

&lt;h3 id=&#34;http-method-trace-doesn-t-support-output&#34;&gt;HTTP method TRACE doesn&amp;rsquo;t support output&lt;/h3&gt;

&lt;p&gt;wikipedia의 &lt;a href=&#34;https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol&#34;&gt;Hypertext Transfer Protocol&lt;/a&gt;의 summary table을 보면 TRACE method은 body 안붙는게 표준이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://libsora.so/posts/http-request-with-body-and-java-httpurlconnection/http-summary-table.png&#34; alt=&#34;summary table&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;invalid-http-method-patch&#34;&gt;Invalid HTTP method: PATCH&lt;/h3&gt;

&lt;p&gt;HTTP request method중에서 PATCH는 특별하다. 스펙 문서부터 다르다.
PATCH는 RFC5789 &lt;a href=&#34;https://tools.ietf.org/html/rfc5789&#34;&gt;PATCH Method for HTTP&lt;/a&gt;에 정의되어있다.
게다가 PATCH는 request body 규격도 정의되어있다.
RFC6902 &lt;a href=&#34;https://tools.ietf.org/html/rfc6902&#34;&gt;JavaScript Object Notation (JSON) Patch&lt;/a&gt;를 보면 아래의 코드가 들어있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
  { &amp;quot;op&amp;quot;: &amp;quot;test&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;/a/b/c&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;foo&amp;quot; },
  { &amp;quot;op&amp;quot;: &amp;quot;remove&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;/a/b/c&amp;quot; },
  { &amp;quot;op&amp;quot;: &amp;quot;add&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;/a/b/c&amp;quot;, &amp;quot;value&amp;quot;: [ &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot; ] },
  { &amp;quot;op&amp;quot;: &amp;quot;replace&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;/a/b/c&amp;quot;, &amp;quot;value&amp;quot;: 42 },
  { &amp;quot;op&amp;quot;: &amp;quot;move&amp;quot;, &amp;quot;from&amp;quot;: &amp;quot;/a/b/c&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;/a/b/d&amp;quot; },
  { &amp;quot;op&amp;quot;: &amp;quot;copy&amp;quot;, &amp;quot;from&amp;quot;: &amp;quot;/a/b/d&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;/a/b/e&amp;quot; }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;POST, PUT 같은건 request body 규격으로 바가지 안긁는다. 상세 구현은 알아서 적당히 하면 된다.
PATCH는 리소스 변경을 목적으로 나왔느니 조금 더 신경쓴 느낌이다.&lt;/p&gt;

&lt;p&gt;HttpURLConnection에서 PATCH를 지원하지 않는걸보니 최신 스펙에 맞춰서 유지보수하는 클래스가 아닌가보다.
힙스터가 자바에서 HTTP 통신 사용할일 있으면 HttpURLConnection 쓰면 안되겠다.&lt;/p&gt;

&lt;h2 id=&#34;reference&#34;&gt;reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods&#34;&gt;MDN HTTP request methods&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc1945&#34;&gt;Hypertext Transfer Protocol &amp;ndash; HTTP/1.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc7231&#34;&gt;Hypertext Transfer Protocol &amp;ndash; HTTP/1.1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc5789&#34;&gt;PATCH Method for HTTP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6902&#34;&gt;JavaScript Object Notation (JSON) Patch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://libsora.so/posts/http-request-with-body-and-java-httpurlconnection/RFC2616.pdf&#34;&gt;Hypertext Transfer Protocol &amp;ndash; HTTP 1.1, 한국전자통신연구소 번역&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>사람 생각하는건 비슷하다</title>
      <link>https://libsora.so/posts/peoples-thoughts-are-similar/</link>
      <pubDate>Wed, 30 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/peoples-thoughts-are-similar/</guid>
      <description>&lt;p&gt;최근에 &lt;a href=&#34;http://www.yes24.com/24/goods/14914156?scode=032&amp;amp;OzSrank=1&#34;&gt;클라이언트-서버 웹 앱 만들기 - 자바와 자바스크립트로 배우는 모던 웹 앱 개발&lt;/a&gt;이라는 책을 읽었다.
도서관 돌아다니다보니 손에 잡혀서 읽어봤다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://libsora.so/posts/peoples-thoughts-are-similar/41548950.jpg&#34; alt=&#34;book cover&#34; /&gt;&lt;/p&gt;

&lt;p&gt;8장 API 디자인에 재밌는 내용이 나오더라.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;원래는 보기 좋은 URL도 요청 매개변수 때문에 &amp;lsquo;보기 흉한&amp;rsquo; URL이 되기도 한다.
어떤 상황에서는, HTTP GET에 해당하는 듯한 동작을 하면서도 계층적 데이터 구조로 정의하는 것이 더 쉬운 요청 객체를 사용해야 할 수도 있다.
한 예로, 많은 항목을 GET으로 조회해 가져오는데, 각 항목을 찾기 위해서는 여러 필드가 필요한 상황이 있겠다.
서버가 요청 내용을 파싱하는 공식적인 요건이 없으므로,
당장은 여러 사례에서 쓰이더라도 장기적인 솔루션으로 사용하면 안 되겠지만,
로이 필딩과 HTTP 명세 (&lt;a href=&#34;http://yhoo.it/1hfR4SD&#34;&gt;http://yhoo.it/1hfR4SD&lt;/a&gt;) 는 이를 허용하는 것 같다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;내가 밟은 삽질이 생각나더라.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://libsora.so/posts/http-get-request-with-body-and-http-library&#34;&gt;HTTP GET 요청에 body를 붙여서 보내면 어떤 일이 벌어질까?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;사람 생각하는건 다 거기서 거기인가보다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>yup로 입력 검증을 덜 귀찮게 처리하자</title>
      <link>https://libsora.so/posts/yup-declarative-input-validation/</link>
      <pubDate>Sat, 19 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/yup-declarative-input-validation/</guid>
      <description>

&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;

&lt;p&gt;프로그래머가 러스트, C#, 타입스크립트같은 타입 있는 언어로 코드를 짜면 컴파일러에 의해서 타입이 보장되니 런타임에서 문제가 생기지 않는다.
미개한 스크립트 언어들만이 런타임에서 타입으로 문제가 생긴다.
그러니까 우리는 정적 언어를 써야한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://libsora.so/posts/yup-declarative-input-validation/e0080266_51714c9299ca8.jpg&#34; alt=&#34;그렇게 생각했던 시기가&#34; /&gt;&lt;/p&gt;

&lt;p&gt;물론 세상은 그렇게 굴러가지 않는다.
프로그래머가 코드를 완벽하게 통제하고 있을수는 있어도 외부에서의 입력까지 완벽하게 통제할수는 없다.
특히 인터넷에 연결된 서버의 경우는 밖에서 어떤 입력이 들어올지 알 수 없다.
그렇기 때문에 입력 검증은 필요하다.&lt;/p&gt;

&lt;h2 id=&#34;선언형-입력-검증&#34;&gt;선언형 입력 검증&lt;/h2&gt;

&lt;p&gt;입력 검증은 뻔한 부분이 많다.
이런 패턴이 흔히 등장한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;비어있을 수 없다.&lt;/li&gt;
&lt;li&gt;들어갈 수 있는 값은 A/B/C 중 하나&lt;/li&gt;
&lt;li&gt;이메일 필드&lt;/li&gt;
&lt;li&gt;숫자 필드&lt;/li&gt;
&lt;li&gt;최대 255 글자&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;입력 검증을 직접 구현하는건 너무 귀찮고 선언적으로 때울 방법 어디 없나?
이런 식으로 돌아가는 느낌으로.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;validator를 생성한다. 이때 각각의 필드별로 어떤 속성이 가능한지 명시한다.

&lt;ul&gt;
&lt;li&gt;name: 문자열 타입, 최대 16글자&lt;/li&gt;
&lt;li&gt;age: 숫자 필드, 최소 18&lt;/li&gt;
&lt;li&gt;대충 이런 느낌으로 필드별로 정의&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;검증하고 싶은 값을 묶어서 객체로 만든다.&lt;/li&gt;
&lt;li&gt;생성된 객체를 validator에 통과시키면 성공/실패를 알 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;yup&#34;&gt;yup&lt;/h2&gt;

&lt;p&gt;이전에 GraphQL에 대해서 찾아보다가 &lt;a href=&#34;https://github.com/benawad/fullstack-graphql-airbnb-clone&#34;&gt;fullstack-graphql-airbnb-clone&lt;/a&gt; 라는 저장소를 뜯어본 적이 있다.
그때 &lt;a href=&#34;https://github.com/jquense/yup&#34;&gt;yup&lt;/a&gt; 라는 입력 검증 라이브러리를 알게 되었다.&lt;/p&gt;

&lt;p&gt;yup를 쓰면 아래와 같은 느낌으로 입력 검증이 가능하다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var yup = require(&#39;yup&#39;);

var schema = yup.object().shape({
  name: yup.string().required(),
  age: yup
    .number()
    .required()
    .positive()
    .integer(),
  email: yup.string().email(),
  website: yup.string().url(),
  createdOn: yup.date().default(function() {
    return new Date();
  }),
});

//check validity
schema
  .isValid({
    name: &#39;jimmy&#39;,
    age: 24,
  })
  .then(function(valid) {
    valid; // =&amp;gt; true
  });

//you can try and type cast objects to the defined schema
schema.cast({
  name: &#39;jimmy&#39;,
  age: &#39;24&#39;,
  createdOn: &#39;2014-09-23T19:25:25Z&#39;,
});
// =&amp;gt; { name: &#39;jimmy&#39;, age: 24, createdOn: Date }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;비슷한 컨셉의 라이브러리로 &lt;a href=&#34;https://github.com/hapijs/joi&#34;&gt;joi&lt;/a&gt; 라는것도 있더라.
github star 기준으로는 joi가 더 많더라.
하지만 joi랑 yup랑 선언형 스키마라는 개념은 비슷하길래 나는 쓰던거 쓴다.&lt;/p&gt;

&lt;h2 id=&#34;내가-적용한-코드&#34;&gt;내가 적용한 코드&lt;/h2&gt;

&lt;p&gt;요새 서버를 typescript + express로 구현하고 있다.
입력은 request body에 json을 붙여서 받고있다.
하지만 body로 들어온 json이 올바른 내용인지는 검증하지 않으면 믿을 수 없다.
여기에 yup를 붙였다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const allowedAuthTypes = [
	&#39;twitter&#39;,
	&#39;facebook&#39;,
];
export const connectAuthSchema = yup.object().shape({
	auth_type: yup.string().oneOf(allowedAuthTypes).required(),
	user_id: yup.string().required(),
});

const connectAuth = async (req: express.Request, res: express.Response) =&amp;gt; {
	await connectAuthSchema.validate(req.body, { abortEarly: true });
	const resp = await connectAuth(new MyRequest&amp;lt;M.ConnectAuthReq&amp;gt;(req));
	res.json(resp);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;직접-써보니까&#34;&gt;직접 써보니까&lt;/h2&gt;

&lt;p&gt;선언형 입력 검증 라이브러리를 쓰고 크게 2가지를 얻은거같다.&lt;/p&gt;

&lt;p&gt;입력 검증과 관련된 코드는 줄어들었고 신뢰도는 올라갔다.
입력 검증을 직접 구현했다면 입력 검증이 일종의 로직이 되니까 이를 위한 테스트가 필요하다.
(테스트가 없다면 내가 짠 검증이 제대로 검증하는지 어떻게 믿을 수 있나?)
그리고 직접 입력 검증을 구현했다면 yup schema보다는 코드가 길었을것이다.
yup 덕분에 직접 로직을 작성한 것은 거의 없으니 테스트를 덜 신경쓰게 되었다.&lt;/p&gt;

&lt;p&gt;클라이언트 개발자에 입력값이 무엇인지 알려주기 쉬워졌다.
입력 검증이 선언형 코드로 구성되니 무엇을 넣을수 있는지 한눈에 보인다.
그래서 API 문서를 안쓰기로 했다. (???)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTP GET 요청에 body를 붙여서 보내면 어떤 일이 벌어질까?</title>
      <link>https://libsora.so/posts/http-get-request-with-body-and-http-library/</link>
      <pubDate>Tue, 15 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/http-get-request-with-body-and-http-library/</guid>
      <description>

&lt;h2 id=&#34;삽질의-시작&#34;&gt;삽질의 시작&lt;/h2&gt;

&lt;p&gt;요새 유니티로 게임을 만들고 있다. 나는 서버쪽을 작업하고 있다.
서버는 HTTP 기반으로 구현하고 있다. 실시간 통신이 필요없으면 HTTP 쓰는게 편하잖아?
RESTful API 같은 통신 규격으로 구현하고 있다.
GET, POST, DELETE, PUT 으로 행동을 구분하고 인자는 모두 body에 json을 붙여서 넘겼다.
GET의 경우도 특별한 구분없이 POST랑 똑같은 인터페이스를 유지하도록 했다.
이 접근법은 &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-body.html&#34;&gt;elasticseach의 검색 API&lt;/a&gt;를 보고 배웠다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -X GET &amp;quot;localhost:9200/twitter/_search&amp;quot; -H &#39;Content-Type: application/json&#39; -d&#39;
{
    &amp;quot;query&amp;quot; : {
        &amp;quot;term&amp;quot; : { &amp;quot;user&amp;quot; : &amp;quot;kimchy&amp;quot; }
    }
}
&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;query string을 쓰면 인자의 타입이 문자열로 인식되니 숫자로 변환해서 처리하는게 귀찮다.
게다가 nested 구조는 query string으로 표현하면 깔끔하게 안나온다.
body에 json붙여서 넘기면 위의 두 문제는 간단하게 해결된다.
이 좋은걸 POST에서만 쓰고 GET에서 안쓸 이유가 있나 싶어서 GET에도 도입했다.
(HTTP 스펙상 GET에 body 안붙이는게 맞다는 소리는 알지만 일단 넘어가자. 이론과 현실은 다르다. elasticsearch같은 사례도 있으니)&lt;/p&gt;

&lt;p&gt;서버 API를 적당히 짜고 유니티에도 샘플 씬 만들어서 API 호출 잘 되는거 테스트하고 퇴근했더니&amp;hellip;&lt;/p&gt;

&lt;p&gt;안드로이드 빌드를 뽑은후 돌리면 404 Not Found가 뜬다고 하더라.&lt;/p&gt;

&lt;p&gt;왜죠?&lt;/p&gt;

&lt;p&gt;그래서 UnityWebRequest를 붙잡고 삽질을 시작하게 되는데&lt;/p&gt;

&lt;h2 id=&#34;테스트-순서&#34;&gt;테스트 순서&lt;/h2&gt;

&lt;p&gt;node.js로 GET, POST를 받을 수 있는 간단한 서버를 구현했다.
서버는 요청이 들어오면 HTTP method와 body를 응답으로 던진다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const express = require(&#39;express&#39;);

const app = express();
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.get(&#39;/&#39;, (req, res) =&amp;gt; {
  res.json({ method: &#39;GET&#39;, body: req.body });
});
app.post(&#39;/&#39;, (req, res) =&amp;gt; {
  res.json({ method: &#39;POST&#39;, body: req.body });
});

const port = 3100;
app.listen(port, () =&amp;gt; {
  console.log(`server listen - ${port}`);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;몇가지 HTTP 라이브러리 서버에 body가 붙은 POST, GET 요청을 보내본다.
그리고 POST와 GET으로 보냈을때의 차이가 있는지 확인한다.&lt;/p&gt;

&lt;h2 id=&#34;curl&#34;&gt;curl&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://curl.haxx.se/&#34;&gt;curl&lt;/a&gt;은 HTTP API 테스트하기 좋은 툴이다.
&lt;a href=&#34;https://www.getpostman.com/&#34;&gt;postman&lt;/a&gt;같이 더 이쁜 물건도 있지만 curl에 익숙해져서 자주쓰게 되더라.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

curl -X POST http://127.0.0.1:3100/ -H &#39;Content-Type: application/json&#39; -d &#39;{&amp;quot;foo&amp;quot;: 1}&#39; -s
echo &amp;quot;&amp;quot;

curl -X GET http://127.0.0.1:3100/ -H &#39;Content-Type: application/json&#39; -d &#39;{&amp;quot;foo&amp;quot;: 1}&#39; -s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;curl로는 GET 요청시 body를 붙여서 보낼 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;$ bash curl-demo.sh
{&amp;quot;method&amp;quot;:&amp;quot;POST&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;foo&amp;quot;:1}}
{&amp;quot;method&amp;quot;:&amp;quot;GET&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;foo&amp;quot;:1}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;python-requests&#34;&gt;python requests&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.python-requests.org/en/master/&#34;&gt;requests&lt;/a&gt;는 파이썬 쓸때 자주 쓰던 HTTP 라이브러리이다.
파이썬 내장 HTTP 라이브러리는 아무리봐도 사용법이 익숙해지질 않아서&amp;hellip;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import requests

uri = &#39;http://127.0.0.1:3100&#39;

r = requests.post(uri, json={&#39;foo&#39;: 1})
print(r.text)

r = requests.get(uri, json={&#39;foo&#39;: 1})
print(r.text)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;requests로는 GET 요청시 body를 붙여서 보낼 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;$ pipenv run python requests-demo.py
{&amp;quot;method&amp;quot;:&amp;quot;POST&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;foo&amp;quot;:1}}
{&amp;quot;method&amp;quot;:&amp;quot;GET&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;foo&amp;quot;:1}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;c-httpclient&#34;&gt;C# HttpClient&lt;/h2&gt;

&lt;p&gt;C#에는 &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient&#34;&gt;HttpClient&lt;/a&gt; 라는 HTTP 라이브러리가 내장되어있다.
의존성 늘어나는거 보기 싫을때 쓰면 좋을거다.&lt;/p&gt;

&lt;h3 id=&#34;net-core&#34;&gt;.NET Core&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;﻿using System;
using System.IO;
using System.Net;
using System.Net.Http;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Json;
using System.Text;
using System.Threading.Tasks;

[DataContract]
internal class SimpleReq
{
    [DataMember]
    public int foo;
}

class Program
{
    private static readonly HttpClient client = new HttpClient();
    private static readonly string host = &amp;quot;http://127.0.0.1:3100&amp;quot;;

    public static string ToJsonString&amp;lt;T&amp;gt;(T data)
    {
        var stream1 = new MemoryStream();
        var ser = new DataContractJsonSerializer(typeof(T));
        ser.WriteObject(stream1, data);

        stream1.Position = 0;
        StreamReader sr = new StreamReader(stream1);
        var jsonBody = sr.ReadToEnd();

        return jsonBody;
    }

    static async Task&amp;lt;bool&amp;gt; RequestCommon(HttpMethod method)
    {
        var body = ToJsonString(new SimpleReq() { foo = 1 });
        var request = new HttpRequestMessage(method, $&amp;quot;{host}/&amp;quot;)
        {
            Content = new StringContent(body, Encoding.UTF8, &amp;quot;application/json&amp;quot;),
        };
        var resp = await client.SendAsync(request);

        Console.WriteLine(await resp.Content.ReadAsStringAsync());
        return true;
    }

    static void Main(string[] args)
    {
        var taskPost = RequestCommon(HttpMethod.Post);
        taskPost.Wait();

        var taskGET = RequestCommon(HttpMethod.Get);
        taskGET.Wait();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.NET Core의 HttpClient를 쓰면 GET 요청시 body를 붙여서 보낼 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;$ cd httpclient-dotnet-core
$ dotnet run
{&amp;quot;method&amp;quot;:&amp;quot;POST&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;foo&amp;quot;:1}}
{&amp;quot;method&amp;quot;:&amp;quot;GET&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;foo&amp;quot;:1}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;unity&#34;&gt;Unity&lt;/h3&gt;

&lt;p&gt;내가 진짜로 하고 싶은 작업은 콘솔에서 http 통신하는게 아니다.
게임에서 http 통신 하는게 목적이다.
.NET Core에서 돌려본 코드를 Unity 2018.3.1f1 로 그대로 옮겨봤다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using UnityEngine;

using System;
using System.IO;
using System.Net;
using System.Net.Http;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Json;
using System.Text;
using System.Threading.Tasks;

[DataContract]
internal class SimpleReq
{
    [DataMember]
    public int foo;
}


public class Main : MonoBehaviour
{
    private static readonly HttpClient client = new HttpClient();
    private static readonly string host = &amp;quot;http://127.0.0.1:3100&amp;quot;;

    async void Start()
    {
        await RequestCommon(HttpMethod.Post);
        await RequestCommon(HttpMethod.Get);
    }

    public static string ToJsonString&amp;lt;T&amp;gt;(T data)
    {
        var stream1 = new MemoryStream();
        var ser = new DataContractJsonSerializer(typeof(T));
        ser.WriteObject(stream1, data);

        stream1.Position = 0;
        StreamReader sr = new StreamReader(stream1);
        var jsonBody = sr.ReadToEnd();

        return jsonBody;
    }

    static async Task&amp;lt;bool&amp;gt; RequestCommon(HttpMethod method)
    {
        var body = ToJsonString(new SimpleReq() { foo = 1 });
        var request = new HttpRequestMessage(method, $&amp;quot;{host}/&amp;quot;)
        {
            Content = new StringContent(body, Encoding.UTF8, &amp;quot;application/json&amp;quot;),
        };
        var resp = await client.SendAsync(request);

        Debug.Log(await resp.Content.ReadAsStringAsync());
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;유니티에서 HttpClient 쓸때 GET 요청에 body를 붙이면 예외가 발생한다.
.NET Core랑 Unity의 HttpClient는 이름만 같고 다른 물건인가보다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;{&amp;quot;method&amp;quot;:&amp;quot;POST&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;foo&amp;quot;:1}}
ProtocolViolationException: Cannot send data when method is: GET
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;c-restsharp&#34;&gt;C# RestSharp&lt;/h2&gt;

&lt;p&gt;C# 내장 라이브러리를 사용하니 .NET Core와 유니티에서의 동작이 달라졌다.
외부 라이브러리를 쓴다면 .NET 런타임에 따른 문제를 피할 수 있을 것이다.
대충 검색하니 &lt;a href=&#34;http://restsharp.org/&#34;&gt;RestSharp&lt;/a&gt;를 많이 쓰는거같더라.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;﻿using System;
using RestSharp;
using System.Threading.Tasks;

// RestSharp -Version 106.6.6

class SimpleReq
{
    public int foo;
}

class Program
{
    private static readonly string host = &amp;quot;http://127.0.0.1:3100&amp;quot;;

    static async Task&amp;lt;bool&amp;gt; RequestCommon(Method method)
    {
        var client = new RestClient(host);
        var request = new RestRequest(&amp;quot;/&amp;quot;, method);
        request.AddJsonBody(new SimpleReq() { foo = 1 });

        var resp = await client.ExecuteTaskAsync(request);
        Console.WriteLine(resp.Content);
        return true;
    }
    static void Main(string[] args)
    {
        var taskPOST = RequestCommon(Method.POST);
        taskPOST.Wait();

        var taskGET = RequestCommon(Method.GET);
        taskGET.Wait();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RestSharp를 쓰면 GET 요청시 body가 전달되지 않는다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;$ cd restsharp-demo
$ dotnet run
{&amp;quot;method&amp;quot;:&amp;quot;POST&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;foo&amp;quot;:1}}
{&amp;quot;method&amp;quot;:&amp;quot;GET&amp;quot;,&amp;quot;body&amp;quot;:{}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;unitywebrequest&#34;&gt;UnityWebRequest&lt;/h2&gt;

&lt;p&gt;Unity에는 &lt;a href=&#34;https://docs.unity3d.com/ScriptReference/Networking.UnityWebRequest.html&#34;&gt;UnityWebRequest&lt;/a&gt;라는 HTTP 라이브러리가 내장되어있다.
이 글을 쓰게 된 계기이다.
얼마나 재밌는 물건인지 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;﻿using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Json;
using System.IO;
using System.Text;
using UnityEngine;
using UnityEngine.Networking;

[DataContract]
internal class SimpleReq
{
    [DataMember]
    public int foo;
}


public class Main : MonoBehaviour
{
    private static readonly string host = &amp;quot;http://192.168.200.20:3100&amp;quot;;

    void Start()
    {
        StartCoroutine(BeginStart());
    }

    IEnumerator BeginStart()
    {
        yield return RequestCommon(UnityWebRequest.kHttpVerbPOST);
        yield return RequestCommon(UnityWebRequest.kHttpVerbGET);
    }


    IEnumerator RequestCommon(string method)
    {
        var body = ToJsonBinary(new SimpleReq() { foo = 1 });
        var www = new UnityWebRequest(host);
        www.method = method;
        www.uploadHandler = new UploadHandlerRaw(body);
        www.uploadHandler.contentType = &amp;quot;application/json&amp;quot;;
        www.downloadHandler = new DownloadHandlerBuffer();
        yield return www.SendWebRequest();

        Debug.Log(www.downloadHandler.text);
    }

    public static byte[] ToJsonBinary&amp;lt;T&amp;gt;(T data)
    {
        var stream1 = new MemoryStream();
        var ser = new DataContractJsonSerializer(typeof(T));
        ser.WriteObject(stream1, data);

        stream1.Position = 0;
        StreamReader sr = new StreamReader(stream1);
        var jsonBody = sr.ReadToEnd();

        byte[] byteArray = Encoding.UTF8.GetBytes(jsonBody);
        return byteArray;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;에디터에서 실행하면 GET 요청에 body를 붙일 수 없다.
C#의 RestSharp와 같은 식으로 굴러가나보다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;{&amp;quot;method&amp;quot;:&amp;quot;POST&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;foo&amp;quot;:1}}
{&amp;quot;method&amp;quot;:&amp;quot;GET&amp;quot;,&amp;quot;body&amp;quot;:{}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;하지만 안드로이드 빌드를 뽑은후 돌리면 에디터일때와 동작이 바뀐다.
GET 요청시 body를 붙이면 똑똑한 UnityWebRequest가 POST로 보낸다.
body가 붙으면 GET이 아니라 POST로 취급하게 구현했나보다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;{&amp;quot;method&amp;quot;:&amp;quot;POST&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;foo&amp;quot;:1}}
{&amp;quot;method&amp;quot;:&amp;quot;POST&amp;quot;,&amp;quot;body&amp;quot;:{&amp;quot;foo&amp;quot;:1}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;다양한-결정&#34;&gt;다양한 결정&lt;/h2&gt;

&lt;p&gt;여러가지 구현체에서 같은 기능이 다르게 동작하는 것을 봤다.
개발하는 애들이 돌대가리는 아닐테니 각각의 결정에는 이유가 있었을거다.&lt;/p&gt;

&lt;p&gt;클라이언트에서 GET 요청시 body를 붙일 수 있도록 한 경우를 보자.
curl, requests, .NET Core HttpClient가 이를 선택했다.
HTTP 라이브러리는 아무 생각없이 프로그래머가 시키는대로 돌아간다.
프로그래머가 인자를 잘못 입력해도 크게 신경쓰지 않는다.
GET 요청에 붙어서 날아간 body를 사용할지는 서버 구현에 달려있다.
서버한테 역할을 떠넘겨서 클라이언트가 간단해졌다고 볼 수 있지 않을까?&lt;/p&gt;

&lt;p&gt;HTTP 스펙만 따지고 잘못된 구현이라고 하는 사람도 있을 수 있다.
나는 스펙은 일을 편하게 하라고 있는거지 일을 귀찮게 만드려고 존재하는게 아니라고 생각한다.
스펙을 지키고 싶으면 서버에서만 지켜도 되지 클라와 서버 양쪽에서 검증할 필요가 있나 싶다.
HTTP 라이브러리에서 자유도를 보장해주면 elasticsearch같은 물건에서 편하게 쓸 수 있잖아?&lt;/p&gt;

&lt;p&gt;elasticsearch의 &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#_request_body_in_query_string&#34;&gt;문서&lt;/a&gt;에 재밌는게 있더라.
request body를 POST가 아닌 요청에 못붙이는 라이브러리에서는 query string을 대신 써도 되도록 했더라.
HTTP 라이브러리에서 요청 보내는 것을 허용하지 않아서 서버의 일이 귀찮아졌다고 볼 수 있지 않을까?&lt;/p&gt;

&lt;p&gt;GET 요청시 body가 있으면 무시하는 경우도 생각해보자.
RestSharp가 이것을 선택했다.
잘못된 입력이 들어왔을때 이를 무시하고 기본값을 사용했다고 볼 수 있다.
괜찮은 설계라고 생각한다.
이것을 선택하면 스펙대로 동작하면서 밖에서 봤을때의 인터페이스는 하나로 유지할 수 있다.
위의 샘플 코드를 보면 GET 요청 코드랑 POST 요청 코드를 똑같이 유지할 수 있다.
다만 이런 구현을 선택하는 경우 로그를 넣어야한다고 생각한다.
잘못된 인자를 사용했다는 경로 로그가 없으면 프로그래머는 API를 잘못 쓰고있다는걸 인식하기 어렵다.&lt;/p&gt;

&lt;p&gt;GET 요청시 body가 있으면 예외를 던지는 경우도 생각해보자.
Unity의 HttpClient 구현체가 이것을 선택했다.
잘못된 입력이 들어왔을때 예외를 던지는 방식이라고 볼 수 있다.
코드를 잘못 짰을때 개발자가 이를 즉시 알수 있다는 점에서 좋다고 생각한다.
예외를 처리하기 위한 코드가 추가되거나 GET 요청 함수와 POST 요청 함수를 분리해야된다는 단점이 있지만 그 정도는 감수할만하다.&lt;/p&gt;

&lt;p&gt;GET 요청시 body가 붙어있으면 POST로 보내는 경우도 생각해보자.
UnityWebRequest가 이것을 선택했다.
개인적으로 이것은 오답이라고 본다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://libsora.so/posts/http-get-request-with-body-and-http-library/programming-and-wrong-answer.jpg&#34; alt=&#34;하지만 오답은 있단다&#34; /&gt;&lt;/p&gt;

&lt;p&gt;HTTP GET 요청에 body를 붙이는 것을 다른 관점에서 보자.
HTTP 요청 함수에 HTTP Method와 body를 인자로 넣는다고 볼 수 있다.
각각의 인자 (HTTP Method, body)는 같은 중요도를 갖지 않는다고 생각하다.
body에 비해서 HTTP Method가 중요하다고 생각한다.&lt;/p&gt;

&lt;p&gt;body가 붙은 GET 요청을 스펙에 가깝게 처리하고 싶었다면
&amp;ldquo;body가 붙었으니 프로그래머가 POST를 GET으로 오타냈을 것이다&amp;rdquo; 보다
&amp;ldquo;프로그래머는 GET 요청을 보내고 싶었으나 실수로 body를 붙였다&amp;rdquo; 쪽으로 생각하는게 맞는거 아닐까?&lt;/p&gt;

&lt;p&gt;GET 요청에 body를 붙이면 동작이 이상해지는걸 뜯게된 원인은 UnityWebRequest였다.
&lt;strong&gt;GET /user/mydata&lt;/strong&gt; 에 body를 붙였더니 UnityWebRequest가 &lt;strong&gt;POST /user/mydata&lt;/strong&gt; 로 요청을 보냈다.
그래서 &lt;strong&gt;404 Not Found&lt;/strong&gt; 가 발생해서 삽질을 시작했다.
차라리 &lt;strong&gt;GET /user/mydata&lt;/strong&gt; 에 body 없이 요청을 보내서 &lt;strong&gt;400 Bad Request&lt;/strong&gt; 가 발생했으면 문제를 잡기 쉬웠을거같다.&lt;/p&gt;

&lt;h2 id=&#34;다양한-구현체&#34;&gt;다양한 구현체&lt;/h2&gt;

&lt;p&gt;C#의 HttpClient가 .NET Core와 유니티에서 동작이 다른 것을 위에서 봤다.
이것과 관련된 이슈가 있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/dotnet/corefx/issues/28135&#34;&gt;Why does HttpClient in Core allow GET requests with bodies, while Framework version does not?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;C# HttpClient의 동작이 바뀌는 버전을 누가 테스트해봤더라.
유니티는 Mono 기반이고 Mono는 근본이 .NET framework니까 .NET framework의 동작을 따라갔나보다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In .NET Core (tested with 1.0 and 2.0), the above executes successfully.&lt;/li&gt;
&lt;li&gt;In .NET framework (tested with 4.7.1, 4.6.1, 4.5), the above throws a ProtocolViolationException with the message Cannot send a content-body with this verb-type on the SendAsync call.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;똑같은 코드라고 해도 그것이 돌아가는 구현체는 다를수 있으니 동작이 달라지는건 어쩔수 없는 문제라고 생각한다.
같은 코드를 누가 어디서 어떻게 돌릴지 고정할 방법은 없으니까.&lt;/p&gt;

&lt;p&gt;하지만 유니티는 좀 까야한다.
UnityWebRequest는 이름처럼 유니티에서만 돌아가는 라이브러리이다.
유니티에서 직접 만들었을것이다.
그리고 유니티를 쓰는 시점에서 에디터 환경과 안드로이드 환경은 고정된다.
유니티로 빌드를 뽑은 다음에 프로그래머가 .NET 런타임을 갈아끼운다?
유니티 애들은 그딴거 신경 안써도 된다. 에디터, 안드로이드에서 돌아가는 .NET 런타임은 자신들이 통제할 수 있다.
그런데도 에디터랑 안드로이드 빌드에서의 동작이 다르니 뭔가 잘못 구현한 것으로 보인다.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;summary&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;API에서 예외 처리 구현할때는 생각하고 만들자.&lt;/li&gt;
&lt;li&gt;내 생각은 남 생각과 다르다. 생각이 다양하니까 구현도 다양하게 나올 수 있다.&lt;/li&gt;
&lt;li&gt;유니티는 까야한다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>django를 관리툴로 쓰자</title>
      <link>https://libsora.so/posts/use-django-as-admin-tool/</link>
      <pubDate>Sun, 13 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/use-django-as-admin-tool/</guid>
      <description>

&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;

&lt;p&gt;서비스를 개발하다보면 어떤 식으로든 어드민 툴이 필요해진다. 간단한 게시판을 만든다고 생각하자. 관리자의 업무중에는 게시판의 스팸글을 지우는게 있을 것이다. 스팸글 몇 개는 SQL query로 대응할수 있을 것이다. 그러던 어느날, 쿼리에 게시글 id를 잘못 넣어서 의도하지 않은 게시글을 지워버릴지도 모르는 일이다. 또는 게시판 관리하는 업무를 다른 사람한테 넘기고 싶은데 SQL을 아는 사람만 업무를 이어받을 수 있는 상황이 될지 모른다. 어드민 툴을 만들었으면 마우스 클릭 하나로 글을 지울 수 있었을것이다. 그렇다면 쿼리 입력하다 실수할 가능성도 낮아지고 다른 사람한테 일을 넘기도 쉽다.&lt;/p&gt;

&lt;p&gt;하지만 관리툴을 직접 짜는건 귀찮다. 시키면 못할건 아닌데 이런 뻔한 기능에 시간과 돈을 써야하나? 관리툴 짤 시간과 노력으로 기능을 추가하는게 돈이 더 되지 않을까? 귀찮다고 미루다보면 시간이 갈수록 문제가 커질수 있다.&lt;/p&gt;

&lt;p&gt;사용 가능한 자원도 제한되어있다. 시간도 자원이고 인력도 자원이고 예산도 자원이다. 어떻게 하면 관리툴 개발 기간을 줄일 수 있는가? 어떻게 하면 관리툴 개발에 사람을 덜 넣어도 될까? 이런 고민을 하고 효율적으로 일해야 프로젝트의 성공률을 올릴 수 있다.&lt;/p&gt;

&lt;p&gt;이런 고민의 결과, 이전에 작업한 프로젝트는 rust로 API 서버를 짜고 django로 관리툴을 짰다. 그때의 경험을 기반으로 글을 써본다.&lt;/p&gt;

&lt;h2 id=&#34;개념&#34;&gt;개념&lt;/h2&gt;

&lt;p&gt;테이블 구조를 API 서버와 관리툴에서 똑같이 맞춰둔다. 내 경우 API 서버는 rust였고 그냥 SQL query로 테이블을 만들어서 썼다. django로는 생성된 테이블과 똑같이 생긴 django model을 만들었다. 그리고 API 서버와 관리툴이 같은 DB를 바라보게 하면 된다. API 서버가 DB에 집어넣은 것인지 관리툴이 DB에 집어넣은 것인지 구분할 방법이 없으니 잘 굴러갈 것이다.&lt;/p&gt;

&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;

&lt;h3 id=&#34;숟가락-얹기&#34;&gt;숟가락 얹기&lt;/h3&gt;

&lt;p&gt;관리툴의 기능 중 SQL DB 서버를 다루는 부분은 매우 뻔하다. 테이블에서 적당히 검색할수 있고 테이블의 내용을 적당히 수정할 수 있으면 된다. 하지만 뻔한 부분이 쉬운 부분은 아니다. 직접 짜기 귀찮은 부분도 잘 만들기 어려운 부분도 있다. 간단해 보이지만 생각보다 거대한게 관리툴이라는 물건이다.&lt;/p&gt;

&lt;p&gt;다행히도 관리툴은 남들이 만들어둔게 많다. 적당히 묻어가면 된다. django admin은 잘 만들어져있고 기능도 강력한 물건이라서 나는 django를 좋아한다. django admin 말고도 비슷한 기능을 하는 프로그램은 많다. 적당히 줏어다 써도 직접 구현하는 것보다는 싸게 먹힌다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/syrusakbary/Flask-SuperAdmin&#34;&gt;Flask-SuperAdmin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/sferik/rails_admin&#34;&gt;RailsAdmin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;복잡도-낮추기-언어-선택의-자유&#34;&gt;복잡도 낮추기: 언어 선택의 자유&lt;/h3&gt;

&lt;p&gt;API 서버와 관리툴을 따로 구현한다면 둘의 언어, 프레임웍을 다르게 써도 된다. 둘은 DB만 공유하면 된다. API 서버는 API 만들때 최적화된 언어와 프레임웍을 선택할 수 있다. 관리툴은 관리툴 만들때 최적화된 언어와 프레임웍을 선택할수 있다.&lt;/p&gt;

&lt;p&gt;이전에 작업한 프로젝트는 성능이 중요해서 rust로 API 서버를 구현했다. 관리툴은 빨리 개발할수 있는 파이썬을 선택했다. 만약 rust로 API 서버부터 관리툴까지 개발했다고 개발 일정이 터졌을 것이다.&lt;/p&gt;

&lt;p&gt;요새는 서버 구현할 일이 있으면 typescript를 쓴다. IDE에서 자동완성도 잘 되고 리펙토링도 잘 되고 쓸만한 라이브러리도 많이 있고 좋더라. 근데 typescript, javascript 진영에서는 멀쩡한 ORM과 ORM에 붙는 관리툴을 찾기 못했다. 그래서 django로 관리툴만 붙여서 쓰고있다.&lt;/p&gt;

&lt;p&gt;API 서버와 관리툴을 합쳐서 만들어야한다는 생각에서 벗어나면 다른 길이 보인다.&lt;/p&gt;

&lt;h3 id=&#34;복잡도-낮추기-작은-프로젝트&#34;&gt;복잡도 낮추기: 작은 프로젝트&lt;/h3&gt;

&lt;p&gt;API서버와 관리툴은 테이블을 공유하지만 모든 테이블을 공유할 필요는 없다. 관리툴에서만 필요한 기능이 있다면 관리툴에서만 필요한 테이블도 있을 것이다. 거대한 하나의 프로젝트를 잘 나누면 작은 프로젝트 2개가 될 것이다.&lt;/p&gt;

&lt;p&gt;rust 컴파일 시간은 매우 느리다. 만약 API 서버안에 관리툴도 때려박았으면 컴파일 시간이 2배가 되지 않았을까? 그랬으면 하루종일 컴파일 돌아가는것만 보고있었을지도? 그리고 프로젝트가 망했겠지.&lt;/p&gt;

&lt;h3 id=&#34;커스텀-관리툴&#34;&gt;커스텀 관리툴&lt;/h3&gt;

&lt;p&gt;django admin은 좋지만 django admin만으로 모든 관리툴을 대응하는건 좋은 선택이 아니다. 일부 관리툴은 직접 짜는게 나을때가 있다. django는 웹 어플리케이션 만들라고 나온 물건이니까 django admin 만으로 대응하기 어려운 부분은 그냥 짜면 된다. 저번에 작업한 프로젝트 였으면 rust로 관리툴용 API 구현하고 react로 프론트엔드를 구현했을 것이다. 이렇게 하는것보다는 django로 로직 구현하고 jinja2로 템플릿 짜는게 빠르더라.&lt;/p&gt;

&lt;p&gt;모든 DB가 관계형 데이터베이스인건 아니다. elasticsearch나 redis에 저장된 데이터를 보여주는 관리툴이 필요할 수 도 있다. 내 경우 유저의 이벤트 로그를 보여주는 관리툴을 짜야했다. 그리고 이벤트 로그는 elasticsearch에 저장되어 있었다. 파이썬으로 elasticsearch에서 로그를 빼오는 것은 rust로 elasticsearch에서 로그를 빼오는 것보다 구현하기 쉽다. python 정도면 좋은 언어라서 관리툴을 직접 짜야하는 상황도 적당히 대응할 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;준비된-서버&#34;&gt;준비된 서버&lt;/h3&gt;

&lt;p&gt;rust로 짜면 안전하게 메모리를 사용할수 있고 좋은 성능을 얻을 수 있다. 하지만 rust의 컴파일 시간은 느리다. rust로 개발하면 개발 이터레이션도 늘어진다. rust로 모든 API를 구현하는건 비용이 비싸다.&lt;/p&gt;

&lt;p&gt;그래서 잔머리를 굴렸다. 성능이 중요하지 않은 일부 API는 rust로 말고 딴걸로 짜자! 프록시 서버로 사기치면 밖에서 볼때는 API 서버인지 따로 구현된 서버인지 구분할 방법도 없다.&lt;/p&gt;

&lt;p&gt;다른 팀 같았으면 rust가 아닌 다른 언어로 추가 API를 구현한 후 새로운 서버에 올리는게 가능했을지 모른다. 근데 나는 외주라서 갑님들 인프라에 접근할 수 없었다. 인프라에 접근할수 있어야 새로운 서버를 띄워서 올릴텐데 그건 안되겠더라.&lt;/p&gt;

&lt;p&gt;그래서 이미 돌아가고 있는 관리툴 서버를 이용하기로 했다. 관리툴 서버는 이미 돌아가고 있으니 인프라는 신경 안써도 된다. 관리툴 띄우느라 도커 이미지도 이미 만들었고 포트도 뚫었고 밖에서의 접속까지 확인된 상태였다. 나는 API만 구현하면 된다. 신경쓸게 없으니 편하더라.&lt;/p&gt;

&lt;p&gt;물론 야매에 가까운 것이다. 인프라 접근 권한이 있어서 새로운 서버를 직접 띄울 권한이 있다면 굳이 이렇게까지 쓸 이유가 없다.&lt;/p&gt;

&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;

&lt;h3 id=&#34;모델-유지보수&#34;&gt;모델 유지보수&lt;/h3&gt;

&lt;p&gt;API 서버 구현하면서 table schema를 고치면 django 에서도 model을 고쳐야한다. 안고치면 django admin에서 500을 보게 된다. 이것에 대해서 긴 이야기는 나중에 다른 글에서 취급할지 모르겠다. 또는 &lt;a href=&#34;https://lenditkr.github.io/django/approach-legacy-with-django-1/&#34;&gt;레거시 시스템에 django로 다가가기&lt;/a&gt;를 읽어보자.&lt;/p&gt;

&lt;p&gt;그래도 관리툴 서버 터졌다고 API 서버도 같이 터지지 않는다. 둘은 다른 서버니까. 같은 테이블을 바라볼 뿐이다. API 서버가 앞서가고 관리툴 서버가 뒤따라가면 서비스가 통째로 뒤지지 않을 것이다.&lt;/p&gt;

&lt;h3 id=&#34;고오급-개발자가-필요&#34;&gt;고오급 개발자가 필요&lt;/h3&gt;

&lt;p&gt;언어를 섞어 쓸수 있다는 것은 장점이 될수 있지만 단점이 될 수 도 있다. 저번 프로젝트의 경우 API 서버는 rust, 관리툴은 django를 썻다고 했다. 그렇다면 관리툴 유지보수를 위해서는 rust와 django를 동시에 쓸 줄 아는 사람이 필요하다. 관리툴을 django로 짠다고해도 모든 관리툴을 django만으로 대응하는건 어렵기 떄문이다.&lt;/p&gt;

&lt;p&gt;뷰어 기능은 django만으로 구현 가능하다. DB에서 값을 가져와서 이쁘게 보여주는게 전부니까 문제 없다. 하지만 테이블에 저장된 값을 이용해서 계산한 후에 보여줘야한다면? 계산 코드는 rust에만 있다면? django에도 똑같은 값을 보여주고 싶다면? rust 코드를 읽고 해당 부분을 파이썬으로 다시 짜야한다. 아니면 테이블에 계산된 값을 같이 때려박는 것도 방법이다.&lt;/p&gt;

&lt;p&gt;간단한 예를 생각해보자. DB에는 생일이 저장된다. API 서버는 나이를 계산해서 보여주는 기능이 이미 있다고치자. 그리고 관리툴에서도 나이를 보여주고 싶다. 이 경우 생일로부터 나이를 계산하는 로직이 django에도 필요하다. 똑같은 로직을 API서버, django에 구현하는 경우 로직이 바뀌면 유지보수가 귀찮다. 이를 피하는 가장 쉬운 방법은 테이블에 나이 정보도 때려박는거다.&lt;/p&gt;

&lt;p&gt;수정 기능이 들어간 관리툴은 django로만 구현하는게 어렵다. 테이블의 필드 하나만 고치는 간단한 수준이면 django 관리툴을 써도 된다. 하지만 수정할때 수행되어야하는 기능이 복잡하다면 어떨까? django로 똑같이 구현하는 것도 방법이지만 나중에 문제가 생길 가능성이 크다. API 서버 개발자가 로직을 바꿀 가능성이 있다. 뷰어 기능의 경우는 django에서 구현한 것이 깨져도 보이는 것이 깨질 뿐이다. 하지만 수정 기능은 django에서 구현한 것이 깨지면 저장되는 데이터가 깨지고 DB의 무결성을 보장할수 없게 된다. 내 생각에 수정 기능 만큼은 API 서버에 배치하는게 안전할거같더라.&lt;/p&gt;

&lt;p&gt;관리자가 유저의 포인트를 차감하는 기능을 만든 적이 있다. 포인트를 뺀 다음에 음수가 되지 않도록 금액 검증하는 기능이 필요했다. 포인트가 수정되면 유저의 현재 포인트를 저장하는 balance table의 내용도 바뀌어야 했다. 포인트 수정 기록은 balance log table에 저장하고 싶었다. 기능이 충분히 복잡해보여서 관리툴용 API를 rust로 구현해서 API 서버에 집어넣었다. 그리고 django에서는 http request를 호출했다.&lt;/p&gt;

&lt;h3 id=&#34;복잡도-상승-2개의-시스템&#34;&gt;복잡도 상승: 2개의 시스템&lt;/h3&gt;

&lt;p&gt;거대한 프로그램을 2개로 쪼개면 복잡도가 줄어든다. 하지만 하나인것을 2개로 쪼개면서 없던 복잡도도 생긴다.&lt;/p&gt;

&lt;p&gt;관리툴에서 이런 기능도 구현했었다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;관리툴에서 시작 버튼 누름&lt;/li&gt;
&lt;li&gt;관리툴 DB를 읽어서 적당한 JSON을 생성&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;API 서버의 시작 API를 호출. 아까 만든 JSON을 넘긴다&lt;/li&gt;
&lt;li&gt;API 서버에서 시작 ID를 얻을수 있다.&lt;/li&gt;
&lt;li&gt;관리툴에 시작 ID 저장하기&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;시스템을 통짜로 구성했으면 API 호출이 http request가 아니라 함수 호출이 있을 것이다. 하지만 시스템을 나눠쓰기 때문에 http request가 생겼다. (프로토콜을 바꾼다고 해도 로컬은 아니다) 서버간의 경계에서 문제가 생기는건 디버깅하는게 쉽지 않을수 있다.&lt;/p&gt;

&lt;p&gt;이 경우 서버의 경계를 넘는 API 호출때문에 복잡도가 상승한게 있다. 하지만 데이터를 구성하는 부분과 데이터를 처리하는 부분으로 쪼개면서 복잡도가 줄어든 지점도 있다. 복잡도가 늘어난 것과 줄어든 것을 합쳐봣을때 복잡도가 늘어났으면 그건 뻘짓이다.  프로젝트를 진행하는 동안 각을 잘 재야한다.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;summary&lt;/h2&gt;

&lt;p&gt;새로운 기법이 있을때 장점만 떠들면 사기꾼이다. 장점만 있는 기술이 세상에 어디에 있는가? 트레이드 오프(trade-off) 라는 말이 괜히 있는게 아니다. django를 관리툴로 쓰면 장단점이 있다. 현재 프로젝트에 적용했을때 쓸만한지 생각해보자.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>나는 글을 쓰는게 어렵다</title>
      <link>https://libsora.so/posts/writing-article-is-hard/</link>
      <pubDate>Sat, 12 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/writing-article-is-hard/</guid>
      <description>

&lt;p&gt;2018년 12월 말의 풍경이 생각난다.
트위터에서 많은 사람들이 &amp;ldquo;2018년 회고&amp;rdquo;라는 글을 쓰더라.
트위터만이 아니다.
2018년 회고를 쓰는 사람은 그냥 많았다.&lt;/p&gt;

&lt;p&gt;그래서 나도 2018년 회고를 써볼까 생각했지만 관뒀다.
언제부터였나? 글 쓰는게 힘들어졌다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2018년 : 18개 (20.3일/개)&lt;/li&gt;
&lt;li&gt;2017년 : 15개 (24.3일/개)&lt;/li&gt;
&lt;li&gt;2016년  : 21개 (17.4일/개)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위는 몇년간 블로그에 작성한 글의 갯수와 글과 글 사이의 평균 시간 간격이다. &lt;code&gt;365 / n&lt;/code&gt;
나는 1년에 16500원씩 도메인 유지비를 내면서 3주에 글을 한개씩 쓴다.
가끔 도메인 유지비가 비싸다는 생각을 한다.
그래서 글을 열심히 써야겠다는 생각을 하지만 오래 지속되진 않는다.&lt;/p&gt;

&lt;p&gt;어쩌다 글을 쓰기 힘들어졌는지 글로 한번 써보려고 한다. (???)&lt;/p&gt;

&lt;p&gt;읽기전에 주의할게 있다.
&amp;ldquo;글 쓰는게 어렵다&amp;rdquo;는 &amp;ldquo;생각을 글로 쓰는게 어렵다&amp;rdquo;고 해석할 수 도 있다.
하지만 나는 그런 의미로 쓰지 않았다.
&amp;ldquo;글을 쓸 필요성을 못 느껴서 글을 써기 어렵다&amp;rdquo;라는 뜻으로 사용했다.&lt;/p&gt;

&lt;h2 id=&#34;빠르고-많이-전달&#34;&gt;빠르고 많이 전달&lt;/h2&gt;

&lt;p&gt;글은 다양한 목적으로 작성될 것이다.
관련된 내용을 정리하는 목적으로 글을 쓸 수도 있다.
아마도 기술 문서가 여기에 해당될 것이다.
자신의 생각을 정리하기 위해서 글을 쓸 수 도 있을 것이다.
일기는 여기에 속할것이다.
사람들에게 자신의 생각을 보여주기 위해서 글을 쓸 수 도 있을 것이다.&lt;/p&gt;

&lt;p&gt;사람들에게 자신의 생각을 보여주기 위해서 쓰는 글에만 일단 집중하려고 한다.
이는 몇가지 요소로 나눠서 생각할수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;목표: 사람들에게 자신의 생각을 보여주고 싶다&lt;/li&gt;
&lt;li&gt;수단: 글을 쓴다&lt;/li&gt;
&lt;li&gt;평가 방법 : 많은 사람이 본다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;목표과 평가 방법은 바꿀 수 없다.
하지만 수단은 바꿀 수 있다.
더 좋은 목표를 달성할 수 있다면 수단은 언제든지 바꿀 수 있다.
수단을 고집할 이유는 없다.&lt;/p&gt;

&lt;p&gt;그 결과물이 유튜브가 지배하는 요즘 세상이다.
&amp;ldquo;안녕하세요 병신 TV입니다&amp;rdquo;, &amp;ldquo;구독과 좋아요 늘러주세요&amp;rdquo; 유튜브를 상징하는 말이 되어버렸다.
잘 생각해보면 유튜뷰는 수단이 바뀐 것뿐이다.&lt;/p&gt;

&lt;p&gt;하지만 나는 유튜브를 싫어하기때문에 유튜브를 수단으로 쓰진 않을 것이다.
대신 나한테는 더 나쁜 수단이 있다. 트위터이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://libsora.so/posts/writing-article-is-hard/analytics-google.png&#34; alt=&#34;google analytics&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://libsora.so/posts/writing-article-is-hard/analytics-twitter.png&#34; alt=&#34;twitter analytics&#34; /&gt;&lt;/p&gt;

&lt;p&gt;트위터를 쓸때 노출수가 더 많다.
짧은 생각을 글로 쓸 이유가 나한테는 별로 없다.&lt;/p&gt;

&lt;h2 id=&#34;작성-난이도&#34;&gt;작성 난이도&lt;/h2&gt;

&lt;p&gt;내용은 별거 없지만 일단은 개발 관련 내용이 많다.
별거아닌 글만 써도 몇시간이 걸린다.
게다가 내가 취급하는 주제는 개발이라서 글 이외에도 준비할게 많다.
샘플 코드가 필요하면 작성하고 이것을 돌려서 출력을 뽑고 출력물을 정리해야 한다.
GUI가 들어가는 경우 스크린샷도 찍어야한다.
잡다한 물건이 글에 많이 들어간다.
덕분에 내용은 별거 없는 글도 작성 시간은 오래 걸린다.&lt;/p&gt;

&lt;p&gt;이것에 비하면 트위터는 정말 편하다.
140자 제한 덕분에 대충 써도 된다.
자세한 내용? 그딴건 안써도 된다. &amp;ldquo;모르면 공부하세요&amp;rdquo;로 떠넘기면 된다.
틀린 내용? &amp;ldquo;틀릴수도 있지 너 어디 사냐&amp;rdquo;로 대응하면 된다.
글의 깊이? 140자 제한인데 뭘 바라는가?&lt;/p&gt;

&lt;p&gt;트위터는 아무말하기 너무 좋은 플랫폼이다.
트윗 쓰는 것은 글을 쓰는것에 비해서 너무 쉽다.
그렇다보니 글을 쓰기 점점 어려워진다.&lt;/p&gt;

&lt;h2 id=&#34;게임-vs-코딩-vs-vs-글&#34;&gt;게임 vs 코딩 vs … vs 글&lt;/h2&gt;

&lt;p&gt;나는 코딩으로 먹고사는 사람이다. 글을 쓰는건 내 주력이 아니다.
나는 글을 쓰는 사람이 아니다. 글을 잘 쓴다고 돈이 벌리는게 아니다. 심심풀이로 글을 쓰는 것에 가깝다.&lt;/p&gt;

&lt;p&gt;글은 언제쓰는가? 시간이 있어야 쓴다.
업무 시간이나 여가 시간이나 아무튼 시간이 있어야 쓴다.
근데 나는 글로 먹고 사는 사람이 아니라서 업무시간에는 글을 못쓴다.
여가 시간에 글을 쓸 수 밖에 없다.&lt;/p&gt;

&lt;p&gt;여가시간은 제한되어 있다. 그리고 여가 시간 동안 할건 많다.
일하느라 고통받았으니 게임을 하고 싶다.
재밌는 프로젝트가 생각나서 코딩을 하고 싶다.
공부를 너무 안해서 멍청해진거같으니 책도 읽고 싶다.
살찐거같으니 운동을 하고싶다.
게임, 코딩, 영화, 애니, 운동, 독서, 글쓰기 등은 서로 싸우고 이긴 것이 내 여가 시간을 차지할 수 있다.
근데 보통 글쓰기가 지더라.
글쓰기보다 재밌는게 세상에 너무 많다.&lt;/p&gt;

&lt;h2 id=&#34;2019년-대응&#34;&gt;2019년 대응&lt;/h2&gt;

&lt;p&gt;2019년에는 사는 방식을 좀 바꿔보려고 한다.&lt;/p&gt;

&lt;p&gt;개발 블로그에서 벗어나려고 한다.
지금까지는 개발 이야기만 썼는데 다른 이야기도 좀 써보려고 한다.
주제가 개발로 한정되니까 재밌는 떡밥을 생각해내는 것도 어렵고 글을 쓰기위해 준비할 내용도 너무 많더라.
SNS에서 떠들던 아무말도 넣어보려고 한다.&lt;/p&gt;

&lt;p&gt;1년 정도는 광고 넣고 돌려보려고 한다.
여가 시간에서 글쓰기의 승률을 올리려면 글쓰기에 좋은 파트너를 붙여야겠더라.
여기는 더러운 자본주의 세계니까.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>로그 파일은 좋다</title>
      <link>https://libsora.so/posts/log-file-is-good/</link>
      <pubDate>Sun, 06 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/log-file-is-good/</guid>
      <description>

&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;

&lt;p&gt;예전에 재밌는 버그를 밟은적 있다. 코드는 아래와 같이 굴러갔다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;요청이 들어오면&lt;/li&gt;
&lt;li&gt;transaction 시작. 요청이 들어오면 트랜잭션이 시작되도록 프레임웍이 구현되어 있었다.&lt;/li&gt;
&lt;li&gt;로그를 DB에 기록&lt;/li&gt;
&lt;li&gt;로직을 적절히 수행&lt;/li&gt;
&lt;li&gt;transaction 완료. 요청 끝날때 트랜잭션이 끝남&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;로그를 왜 DB에 기록했는가? 몇가지 이유가 있었다.&lt;/p&gt;

&lt;p&gt;하나는 검색이 쉬워서이다.
로그 테이블을 잘 만들고 로그를 잘 저장하면 검색이 쉽다.
아직도 터미널을 쓸 줄 모른느 컴맹이라서 grep 쓰는것보다 SQL이 쉽더라.&lt;/p&gt;

&lt;p&gt;웹서버가 여러대였기에 DB를 쓰는게 편했다.
로그를 웹서버 로컬에 각각 기록하면 나중에 로그 파일을 뒤지기 위해 여러대의 웹서버를 열버봐야할텐데 그건 귀찮더라.
DB서버같이 한곳에 모아두면 나중에 검색하는게 쉽다.&lt;/p&gt;

&lt;p&gt;또한 일을 너무 크게 만들고 싶지 않았다.
로그 저장용 서버를 만드는(또는 준비하는) 것도 방법이다.
하지만 이를 위한 작업 자체가 귀찮았다.
DB서버는 이미 있는거니까 할일이 별로 없어서 편했다.&lt;/p&gt;

&lt;p&gt;적당히 구현해두니 적당히 돌아가더라.
그러던 어느날, 문제가 발생했다.
문제는 피할수 없는 것이다.
이를 위해 로그를 기록해뒀으니 문제를 고치는건 쉬울 것이다.&lt;/p&gt;

&lt;p&gt;&amp;hellip;라고 생각하고 로그 테이블을 열어봤는데 문제가 발생한 로그는 하나도 없었다.
이유는 간단하다. 문제 발생시의 흐름을 보자.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;요청이 들어오면&lt;/li&gt;
&lt;li&gt;transaction 시작&lt;/li&gt;
&lt;li&gt;로그를 DB에 기록&lt;/li&gt;
&lt;li&gt;로직을 적절히 수행&amp;hellip;하다가 펑!&lt;/li&gt;
&lt;li&gt;transaction rollback. 아까 기록한 로그를 지움&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;로그가 롤백 당하다니!!! 멍청하게 구현한 것의 대가를 결국 치뤘다.&lt;/p&gt;

&lt;h2 id=&#34;대응-트랜잭션과-로그-분리&#34;&gt;대응: 트랜잭션과 로그 분리&lt;/h2&gt;

&lt;p&gt;트랜잭션 안에서 로그 남기는 것을 문제라고 생각한다.
로그 쓰는걸 트랜잭션 밖으로 뺀다.
그러면 트랜잭션이 롤백되어도 로그는 사라지지 않는다.&lt;/p&gt;

&lt;h2 id=&#34;대응-별개의-로그-시스템&#34;&gt;대응: 별개의 로그 시스템&lt;/h2&gt;

&lt;p&gt;DB에 로그를 남기는게 문제라고 생각한다.
로그를 DB와 관계 없는 곳에 기록했으면 트랜잭션이 롤백되어도 로그는 남을것이다.&lt;/p&gt;

&lt;h3 id=&#34;원격-로그-서버&#34;&gt;원격 로그 서버&lt;/h3&gt;

&lt;p&gt;원격 로그 서버도 좋은 방법이다.
웹서버가 여러대 있어도 로그 서버에 로그가 집중되니 검색이 편하다.
게다가 별개의 시스템이니 로그가 롤백되는 일도 없다. 하지만 항상 좋다고는 못하겠다.
로그 기능을 구현할때 몇가지 요소를 생각해야한다. 그리고 그것이 만들어내는 결과물도 확인해야한다.&lt;/p&gt;

&lt;p&gt;요즘 세상에 원격 로그 서버를 직접 구현하는 사람이 얼마나 있는지 모르겠다.
이미 구현된걸 갖다쓰는 사람이 많지 않을까? 로그 서버 구현체가 어떻게 동작하는지 확인해봐야한다.
저번에 작업한 프로젝트에서는 elasticsearch를 로그 서버로 사용했다.
그래서 elasticsearch에서 발생하는 사례를 주로 이야기할거다.&lt;/p&gt;

&lt;p&gt;로그를 네트워크로 보낸다면 로컬에 로그를 쓰는것보다 시간이 훨씬 오래 걸릴 것이다.
로컬에 로그를 쓴다면 동기 방식으로 로그를 작성해도 심각하게 느리진 않을 것이다.
하지만 네트워크로 로그를 쓸때 동기 방식을 쓰면 네트워크 상태, 로그 서버의 상태등의 영향을 받아서 로그가 기록될때까지 너무 오래 걸릴 수 있다. 그래서 나는 비동기로 로그를 쓰도록 만들었다.
로그 보내는 워커 쓰레드가 있고 워커 쓰레드가 접근하는 작업 큐에 로그를 넣고 로직은 계속 진행하는 식으로 말이다.&lt;/p&gt;

&lt;p&gt;원격 로그 서버를 쓴다는건 로그를 네트워크를 통해 보낸다는 소리이다.
네트워크를 통해 로그가 전달되니까 로그 작성 시간과 로그 도착 시간이 같을리 없다.
그래서 로그에 타임스탬프도 넣어서 보내주는게 올바른 방법이다.&lt;/p&gt;

&lt;p&gt;이런 것들을 고려하면서 원격 로그 서버로 로그 보내는 기능을 만들고 사용해보니 재밌는 문제가 생기더라.&lt;/p&gt;

&lt;p&gt;작업하다보니 짧은 시간동에 로그를 보내는 일이 있었다.
로그에는 timestamp가 붙어있으니까 elasticsearch에서 잘 보여줄거라고 믿었다.
근데 elasticsearch에서 로그를 검색해보니 순서가 뒤죽박죽이었다.
순서가 섞인 이유를 찾아보니 간단했다.
뒤섞인 로그의 timestamp가 전부 똑같았다.
나는 timestamp 잘 붙여서 보냈더니 로그 서버에 도착한 timestamp가 똑같다니 이게 무슨 소리야?&lt;/p&gt;

&lt;p&gt;이것은 elasticsearch에서 제공하는 timestamp의 시간 정밀도가 밀리세컨트(ms)라서 발생한 문제였다.
로그를 짧은 간격동안 너무 많이 보내서 나노세컨트(ns)단위에서 timestamp가 다르면 elasticsearch에서 이를 제대로 처리하지 않는다.
(추가 필드에다가 nanosecond 저장해두고 elasticsearch에서 제공하는 시간을 쓰지 말라는 소리도 있던데 이건 우회법이니까 일단 넘어가자)&lt;/p&gt;

&lt;p&gt;다른 재밌는 문제도 있었다.&lt;/p&gt;

&lt;p&gt;프로그램이 서버로 로그를 보냈다.
정확히는 로그를 작업큐에 넣었을 뿐이고 이것은 워커 쓰레드가 잘 처리해줄거다.
로그를 보내는것을 이런식으로 해서 비동기로 돌아가도록 만들었다.
그런데 로그를 보낸 직후에 프로그램이 죽어버리면 어떻게 될까?
워커 쓰레드가 작업 큐에서 로그를 꺼내기 전에 프로그램이 죽는다면?
네트워크로 로그를 보내는 도중에 프로그램이 죽는다면?
네트워크 서버의 상태가 하필이면 그때만 안좋아서 timeout 같은식의 에러가 발생했다면?
비동기로 로그를 쏘면 로그를 잃어버릴 가능성이 있다.
물론 로컬에 로그를 써도 비동기로 썼다면 잃어버릴 가능성이 있다.
기록되어야하는게 보장되는 로그는 동기로 쓰는게 좋은데 네트워크로 로그 보내는걸 동기로 대기 시간이 너무 오래 걸린다.&lt;/p&gt;

&lt;p&gt;이것과 비슷한 문제도 있었다.
API를 호출하면 로그를 네트워크로 제대로 쏘는지 확인하는 테스트를 작성했다.
테스트 코드의 흐름은 간단하다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;API를 호출한다.&lt;/li&gt;
&lt;li&gt;API에서 아마도 네트워크로 로그를 보냈을거다.&lt;/li&gt;
&lt;li&gt;로그 서버에서 로그를 꺼내본다.&lt;/li&gt;
&lt;li&gt;꺼낸 로그가 아까 작성된 로그로 보이면 테스트 성공&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;실제로 돌리면 잘 안돌아간다.
로그를 비동기로 쐇기때문에 비결정론적으로 돌아간다.
비동기에서의 순서는 상상하면 안된다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;API에서 로그를 쐈다.&lt;/li&gt;
&lt;li&gt;네트워크로 로그를 쏘는 요청이 작업큐에 들어갔다.&lt;/li&gt;
&lt;li&gt;로그 서버에서 로그를 꺼내본다.&lt;/li&gt;
&lt;li&gt;새로 들어온 로그가 없네?&lt;/li&gt;
&lt;li&gt;테스트 실패&lt;/li&gt;
&lt;li&gt;워커 쓰레드가 작업큐의 내용을 꺼내서 로그를 보낸다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이런식으로 돌아가는게 가능하다. 물론 이것만 있는건 아니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;API에서 로그를 쐈다.&lt;/li&gt;
&lt;li&gt;네트워크로 로그를 쏘는 요청이 작업큐에 들어갔다.&lt;/li&gt;
&lt;li&gt;로그 서버에서 로그를 꺼내본다.&lt;/li&gt;
&lt;li&gt;새로 들어온 로그가 없네?&lt;/li&gt;
&lt;li&gt;테스트 실패&lt;/li&gt;
&lt;li&gt;테스트 실패했으니 테스트 프로그램이 종료됨.&lt;/li&gt;
&lt;li&gt;로그 어디감?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;테스트 코드에서 로그 쏘는건 mock object로 대신하거나 테스트 코드에 sleep같은걸 쓴다면 테스트는 통과하긴 한다.
하지만 원격 로그 서버가 문제 터지는 상황을 이야기하는거니까 일단 넘어간다.&lt;/p&gt;

&lt;h3 id=&#34;로그-파일&#34;&gt;로그 파일&lt;/h3&gt;

&lt;p&gt;로그파일은 로그 쓰기가 성공한다는게 높은 확률로 보장된다.
(물론 실패할때도 있다. 디스크가 꽉차는 경우는 방법이 없다니)
반응도 빠르고 시간순으로 작성되도록 구현하는 것도 어렵지 않다.
다만 검색이 귀찮을뿐이다.&lt;/p&gt;

&lt;h3 id=&#34;섞어쓰기&#34;&gt;섞어쓰기&lt;/h3&gt;

&lt;p&gt;이번에 작업한 프로젝트에서는 원격 로그 서버와 로그 파일을 섞어썼다.
로그 서버는 elasticsearch를 사용했다. 로그는 로컬 파일에도 기록하지만 elasticsearch에도 기록했다.
둘의 장점을 얻을수 있다.&lt;/p&gt;

&lt;p&gt;elasticsearch에 이상이 생겨서 로그가 제대로 기록되지 않거나 elasticsearch 서버의 용량 부족으로 옛날 데이터가 날아가면 로그 파일에서 복구할 수 있다.
로그 검색은 elasticsearch에서 하니까 쉽고 편하더라.&lt;/p&gt;

&lt;p&gt;로그 파일을 원본 데이터로 쓰니까 로그 서버는 언제든지 바꿔도 된다.
새로운 로그 서버로 바꾸고 싶을때는 바꾸고 로그 파일의 데이터를 부어넣으면 잘 돌아갈거다.
로그 파일을 남겨두면 나중에 어떤식으로든지 가공해서 쓸 수 있다.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;summary&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;롤백 당하지 않는다. 로그는 롤백되면 안되는 정보니까.&lt;/li&gt;
&lt;li&gt;가공하기 쉽다. 원본 데이터로 쓸 수 있다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>로그는 무죄</title>
      <link>https://libsora.so/posts/log-file-is-not-guilty/</link>
      <pubDate>Sun, 06 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/log-file-is-not-guilty/</guid>
      <description>

&lt;h2 id=&#34;수정-내역&#34;&gt;수정 내역&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2019/01/06: 작성&lt;/li&gt;
&lt;li&gt;2019/01/07: 게시 중단&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>자바스크립트에서 expect(-3 % 3).toEqual(3 % 3)가 실패하는 이유</title>
      <link>https://libsora.so/posts/-3-mod-3-is-not-equal-to-3-mod-3-in-javascript/</link>
      <pubDate>Sun, 09 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/-3-mod-3-is-not-equal-to-3-mod-3-in-javascript/</guid>
      <description>

&lt;h2 id=&#34;3-3-과-3-3-은-같은가&#34;&gt;&lt;code&gt;-3%3&lt;/code&gt; 과 &lt;code&gt;3%3&lt;/code&gt;은 같은가?&lt;/h2&gt;

&lt;p&gt;얼마전에 코딩하다 밟은 버그에 대해서 이야기를 해본다.&lt;/p&gt;

&lt;p&gt;자바스크립트로 미디어 플레이어의 플레이리스트를 구현하고 있었다.
플레이리스트는 간단히 배열로 구현했다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const item = playlistItems[cursor];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 플레이리스트의 크기가 3이고, cursor가 2인 경우 다음곡을 누르는 경우를 생각하자.
2에 1을 더한 후 3을 cursor로 배열에 그대로 접근하면 out of index 에러가 발생할것이다.
(배열의 크기가 3이면 가능한 인덱스는 0~2이니까)&lt;/p&gt;

&lt;p&gt;cursor를 index로 바꿔주는 적절한 함수가 있다고 치자.
이것이 음수, 양수 범위에서 동작할거라고 가정하자.
cursor를 대충 건드려도 적당히 굴러갈것이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const item = playlistItems[convertToIndex(cursor)];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;convertToIndex()&lt;/code&gt;를 구현했는데 기능은 적당히 돌아가는데 테스트는 실패하더라.
이것이 테스트가 실패하는 jest 코드이다.
아래의 코드가 왜 실패하는지에 대해서 알아보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;expect(-3 % 3).toEqual(3 % 3);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-3-2-vs-1&#34;&gt;-4 % 3 = 2 vs -1&lt;/h2&gt;

&lt;p&gt;자바스크립트에서 &lt;code&gt;-4 % 3&lt;/code&gt;의 값은 2일까 -1일까?
만약 자바스크립트에서의 답이 2라면 % 연산의 결과를 배열 인덱스로 그대로 꽂아도 된다.
하지만 -1이 답이라면 %의 값을 그대로 쓸 수 없다.&lt;/p&gt;

&lt;p&gt;예전에 글을 쓴 적이 있으니 답만 공개한다.
자바스크립트에서 나눗셈의 결과는 Dividend(피제수)의 부호를 따라간다.
&lt;code&gt;-4 % 3&lt;/code&gt;의 답은 &lt;code&gt;-1&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://libsora.so/posts/-3-mod-3-is-not-equal-to-3-mod-3-in-javascript/divisor.jpg&#34; alt=&#34;divide&#34; /&gt;&lt;/p&gt;

&lt;p&gt;자세한 것은 이전에 작성한 &lt;a href=&#34;https://libsora.so/posts/sign-of-mod-operator/&#34;&gt;-4 % 3 = ?&lt;/a&gt;를 읽어보자.&lt;/p&gt;

&lt;h2 id=&#34;0&#34;&gt;-0&lt;/h2&gt;

&lt;p&gt;jest 로 아래의 유닛테스트를 작성하고 돌리면 아래와 같은 로그가 뜬다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;expect(-3 % 3).toEqual(3 % 3);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Expected value to equal:
    0
Received:
    -0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-0과 0이 다르기 때문이 실패한댄다.
왜 둘이 다른지는 나중에 생각하고 -0이 왜 튀어나왔는지를 먼저 생각해보자.&lt;/p&gt;

&lt;p&gt;자바스크립트는 흔한 언어와 다르게 정수 타입이 없다.
number type 하나로 숫자를 다룬다.
number type은 IEEE 754 부동소수점이다.
IEEE 754 부동소수점에는 -0, +0이 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://libsora.so/posts/-3-mod-3-is-not-equal-to-3-mod-3-in-javascript/618px-IEEE_754_Single_Negative_Zero.svg.png&#34; alt=&#34;ieee&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;자바스크립트에는 +0, -0이 있다.&lt;/li&gt;
&lt;li&gt;modulo 연산 결과는 Dividend(피제수)를 따라간다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;둘의 조합 덕분에 &lt;code&gt;-3 % 3&lt;/code&gt;은 &lt;code&gt;0&lt;/code&gt;이 아니라 &lt;code&gt;-0&lt;/code&gt;이다.&lt;/p&gt;

&lt;h2 id=&#34;jest-matcher&#34;&gt;jest matcher&lt;/h2&gt;

&lt;p&gt;+0과 -0을 비교하는 jest 테스트 코드를 간단히 짜봤다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const a = -3 % 3;
const b = 3 % 3;

test(&#39;==&#39;, () =&amp;gt; expect(a == b).toBeTruthy());
test(&#39;===&#39;, () =&amp;gt; expect(a === b).toBeTruthy());
test(&#39;toEqual&#39;, () =&amp;gt; expect(a).toEqual(b));
test(&#39;toBe&#39;, () =&amp;gt; expect(a).toBe(b));
test(&#39;Object.is&#39;, () =&amp;gt; expect(Object.is(a, b)).toBeTruthy());
test(&#39;toBeCloseTo&#39;, () =&amp;gt; expect(a).toBeCloseTo(b));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  √ == (3ms)
  √ ===
  × toEqual (11ms)
  × toBe (1ms)
  × Object.is
  √ toBeCloseTo (1ms)
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;===&lt;/code&gt;로는 성공하지만 &lt;code&gt;toEqual&lt;/code&gt;, &lt;code&gt;toBe&lt;/code&gt;는 실패한다.
jest의 &lt;a href=&#34;https://jestjs.io/docs/en/using-matchers&#34;&gt;Using Matchers&lt;/a&gt; 문서를 보면 이유를 알 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;toBe uses Object.is to test exact equality. If you want to check the value of an object, use toEqual instead:
toEqual recursively checks every field of an object or array.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;jest의 toEqual, toBe는 &lt;code&gt;Object.is&lt;/code&gt;를 사용하니까 테스트가 실패한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jest 22.0.0 이후부터는&lt;/strong&gt;
(22.0.0는 18 Dec 2017에 릴리즈 되었다)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/facebook/jest/blob/master/CHANGELOG&#34;&gt;jest CHANGELOG&lt;/a&gt;를 뒤지면 jest 22.0.0의 변경 사항으로 이런게 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;[expect] [BREAKING] Replace identity equality with Object.is in toBe matcher (#4917)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/facebook/jest/pull/4917&#34;&gt;https://github.com/facebook/jest/pull/4917&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;jest 22.0.0 직전 버전인 jest 21.2.1의 &lt;a href=&#34;https://github.com/facebook/jest/blob/v21.2.1/docs/en/UsingMatchers&#34;&gt;Usng Matchers&lt;/a&gt; 내용은 지금과 다르다.
옛날 옛적에는 toBe가 &lt;code&gt;===&lt;/code&gt;를 사용했다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;toBe uses === to test exact equality. If you want to check the value of an object, use toEqual instead:
toEqual recursively checks every field of an object or array.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;내 경우 jasmine을 쓰다가 jest로 넘어갔다.
jest는 jasmine과 비슷하게 생겼고 jest안에 &lt;a href=&#34;https://github.com/facebook/jest/blob/v23.6.0/packages/expect/src/jasmine_utils.js&#34;&gt;jasmine_utils.js&lt;/a&gt;라는 파일도 있길래 jasmine의 호환성을 유지하는줄 알았다.
게다가 인터넷에 굴러다니는 글 중에는 toBe가 &lt;code&gt;===&lt;/code&gt;라고 설명한게 꽤 있다.
&lt;a href=&#34;https://jasmine.github.io/api/2.7/matchers.html&#34;&gt;jasmine에서의 toBe&lt;/a&gt;가 &lt;code&gt;===&lt;/code&gt; 였고 남들도 &lt;code&gt;===&lt;/code&gt;라고 문서도 &lt;code&gt;===&lt;/code&gt;라고 하니 당연히 그런줄 알았다.&lt;/p&gt;

&lt;p&gt;설마 스펙이 바뀌었을줄이야&amp;hellip;&lt;/p&gt;

&lt;p&gt;jest의 toBe가 &lt;code&gt;===&lt;/code&gt;라고 한건 전부 옛날 글이니 걸러야한다.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;summary&lt;/h2&gt;

&lt;p&gt;별것도 아닌 코드 한 줄 때문에 jest 코드 뒤져보니 재밌더라.
이럴떄 아니면 jest 문서를 보지 코드를 뒤져볼 일이 언제 있겠냐.&lt;/p&gt;

&lt;p&gt;jest의 toBe의 동작이 &lt;code&gt;===&lt;/code&gt;에서 &lt;code&gt;Object.is&lt;/code&gt;로 바뀐건 글 쓰다 알게 되었다.
일반적인 경우에서는 둘의 값이 달라지지 않으니 생각도 안했는데&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OMR카드와 2진법</title>
      <link>https://libsora.so/posts/omr-and-binary-number-system/</link>
      <pubDate>Fri, 07 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/omr-and-binary-number-system/</guid>
      <description>

&lt;p&gt;다들 중, 고등학교때 OMR 카드를 봤을 것이다.
중, 고등학교때 중복답안이 존재하는 문제도 풀어봤을 것이다.
그리고 채점 결과를 받아봤을 것이다.
그것을 보면 자신이 어떤 답을 골랐고 맞췄나 틀렸나도 알 수 있다.
대부분의 문제는 답을 1개만 골랐을테니 숫자로 뜨지만 중복답안의 경우는 A~Z을 이용한다.&lt;/p&gt;

&lt;p&gt;이를 잘 이용하면 다음과 같은게 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://libsora.so/posts/omr-and-binary-number-system/i15537933717.jpg&#34; alt=&#34;dobby is free&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.inven.co.kr/board/webzine/2097/1103750?category=%EA%B8%B0%ED%83%80&#34;&gt;시험 오답코드로 만들어낸&lt;/a&gt;
(트위터 원본은 계정이 플텍이 되어서 링크를 걸 수 없었다)&lt;/p&gt;

&lt;p&gt;내가 중3 2학기 기말고사, 고3 2학기 기말고사때 했던짓을 지금도 누군가는 하고있더라.
(중3 2학기 기말고사, 고3 2학기 기말고사는 고입, 대입에 영향을 주지 않아서 마음껏 말아먹었다)
옛날 생각이 나서 오답 코드 관련 글을 써보기로 했다.
내가 고3 기말고사를 본게 2006년이라서 아직도 같은 코드를 쓰고있는지는 모르겠다.&lt;/p&gt;

&lt;h2 id=&#34;2-5-32&#34;&gt;2 ** 5 = 32&lt;/h2&gt;

&lt;p&gt;중고등학교때의 OMR 카드면 문제당 5개의 플래그가 붙어있다.
2 ** 5로 32가지 답이 가능하다.
1글자로 표현가능한 32가지 오답코드가 필요하다.&lt;/p&gt;

&lt;p&gt;1~5의 경우는 숫자를 그냥 쓰면 된다.
아무것도 고르지 않은 경우는 ? 를 쓴다. (짤을 보니 요새는 - 를 쓰는거같다)&lt;/p&gt;

&lt;p&gt;32-5-1 = 26개의 선택지를 1글자로 표현가능한게 뭐가 있을까?
알파벳이 여기에 적합하다. A~Z까지 전부 쓰면 26개이다.&lt;/p&gt;

&lt;p&gt;덕분에 에러 코드를 이용하면 대문자로 구성된 영어 문장을 쓸 수 있다.&lt;/p&gt;

&lt;h2 id=&#34;오답-코드-계산&#34;&gt;오답 코드 계산&lt;/h2&gt;

&lt;p&gt;중3때는 A~Z까지의 코드를 외웠다가 시험 시작하자마자 적어놓고 OMR 카드를 썻다.
멍청한건지 똑똑한건지 지금와서 생각하면 구분이 안된다.&lt;/p&gt;

&lt;p&gt;고3때는 오답 코드가 어떤식으로 할당되었는지 깨달아서 손쉽게 OMR 카드를 썻다.
2진법으로 풀어쓰니까 패턴이 보이더라.&lt;/p&gt;

&lt;h3 id=&#34;0-31-2진법&#34;&gt;0~31 -&amp;gt; 2진법&lt;/h3&gt;

&lt;p&gt;32가지 경우의 수를 2진법으로 풀어서 쓴다.
각각의 자리수는 OMR 카드의 1~5로 맵핑된다.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;number&lt;/th&gt;
&lt;th&gt;2^0&lt;/th&gt;
&lt;th&gt;2^1&lt;/th&gt;
&lt;th&gt;2^2&lt;/th&gt;
&lt;th&gt;2^3&lt;/th&gt;
&lt;th&gt;2^4&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;27&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;31&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;코드-할당&#34;&gt;코드 할당&lt;/h2&gt;

&lt;p&gt;코드를 넣는 규칙(?)은 간단한다&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;아무것도 선택하지 경우는 (-)&lt;/li&gt;
&lt;li&gt;2**N으로 표현 가능한 수의 경우 1~5 (숫자)&lt;/li&gt;
&lt;li&gt;작은거부터 큰 순서대로 A~Z (알파벳)&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;number&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;code&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;E&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;J&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;K&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;P&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;Q&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;27&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;W&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;31&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;summary&#34;&gt;summary&lt;/h2&gt;

&lt;p&gt;아직도 오답 코드가 똑같은지 모르겠다. 내가 마지막으로 본게 12년전이니까.
심각한 결함이 있는것도 아니니까 똑같을거같기도 하고.
아직도 똑같다면 내년 2학기 기말고사를 마음껏 말아먹어 보는건 어떨까?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>타입스크립트에서 if문 안에 promise가 들어가는 문제 피하기</title>
      <link>https://libsora.so/posts/prevent-bug-by-if-statement-with-promise/</link>
      <pubDate>Sat, 13 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/prevent-bug-by-if-statement-with-promise/</guid>
      <description>

&lt;h2 id=&#34;async-function-if&#34;&gt;async function + if&lt;/h2&gt;

&lt;p&gt;옛날 옛적 미개한 자바스크립트에는 콜백뿐이었다.
나중에 promise가 추가되서 좋아졌다.
더 나중에 async/await가 추가되서 더 좋아졌다.
async/await 좋다고 열심히 쓰다가 이번주에 아래와 같은 함정을 밟았다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export const isReady = async () =&amp;gt; {
  const timeout = new Promise((resolve) =&amp;gt; {
    setTimeout(resolve, 100)
  });
  await timeout;
  return false;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;common.ts&lt;/code&gt;에 있는 &lt;code&gt;isReady()&lt;/code&gt;는 async 함수이다.
예제 코드니까 적당한 시간 뒤에 false를 반환하도록 구현했다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { isReady } from &#39;./common&#39;;

const main = async () =&amp;gt; {
  if (isReady()) {
    console.log(&#39;ready&#39;);
  } else {
    console.log(&#39;not ready&#39;);
  }
};
main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;isReady()&lt;/code&gt;는 &lt;code&gt;common.ts&lt;/code&gt;의 외부에서 사용된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ npx ts-node bug.ts
ready
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;코드를 돌리면 &lt;code&gt;ready&lt;/code&gt;가 출력된다.
async/await의 리턴타입은 Promise이다.
그리고 Promise는 if문 안에서 true로 취급된다.&lt;/p&gt;

&lt;h2 id=&#34;fix-bug&#34;&gt;fix bug&lt;/h2&gt;

&lt;p&gt;버그를 고치는 방법은 간단하다.
&lt;code&gt;isReady()&lt;/code&gt;를 호출할때 await를 붙여주면된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { isReady } from &#39;./common&#39;;

const main = async () =&amp;gt; {
  const ready = await isReady();
  if (ready) {
    console.log(&#39;ready&#39;);
  } else {
    console.log(&#39;not ready&#39;);
  }
};
main();
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ npx ts-node fixed.ts
not ready
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 문제는 원인도 간단하고 해결하는 방법도 쉽다.
하지만 자주 밟을 가능성이 있다.
프로젝트의 규모가 커지면 함수의 리턴타입을 전부 기억하기 어려워진다.
&lt;code&gt;isXXX&lt;/code&gt;같은 함수를 보고 boolean 리턴한다고 생각하는게 보통이다.
&lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt;을 리턴한다고 생각하지 않을 수 있다.&lt;/p&gt;

&lt;h2 id=&#34;버그-방지&#34;&gt;버그 방지&lt;/h2&gt;

&lt;p&gt;버그를 고친다는건 이미 문제가 생겼다는 뜻이다.
더 좋은것은 처음부터 문제가 생기지 않도록 하는 것이다.&lt;/p&gt;

&lt;h3 id=&#34;lint&#34;&gt;lint&lt;/h3&gt;

&lt;p&gt;lint의 수준을 올려서 if문 안에 boolean만 들어갈수 있도록 하자.
그러면 if문 안에 Promise가 들어갈 경우 lint에서 경고할거다.&lt;/p&gt;

&lt;p&gt;tslint에는 &lt;a href=&#34;https://palantir.github.io/tslint/rules/strict-boolean-expressions/&#34;&gt;strict-boolean-expression&lt;/a&gt;라는 규칙이 있다.
tslint.json에 &lt;code&gt;&amp;quot;strict-boolean-expressions&amp;quot;: true&lt;/code&gt;를 추가해서 이를 활성화 시켜보자.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$ npx tslint &amp;ndash;project tsconfig.json -t verbose&lt;/p&gt;

&lt;p&gt;ERROR: (strict-boolean-expressions) D:/blog/libsora.so/src/libsora.so/content/development/prevent-bug-by-if-and-promise/bug.ts[4, 7]: This type is not allowed in the &amp;lsquo;if&amp;rsquo; condition because it is always truthy. Only booleans are allowed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;naming-convention&#34;&gt;naming convention&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://nodejs.org/api/fs.html&#34;&gt;Node.js File System&lt;/a&gt; 를 뒤져보면 아래같이 생긴 함수가 많이 보인다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fs.writeFile(file, data[, options], callback)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.writeFileSync(file, data[, options])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;nodejs에는 같은 기능을 동기로 구현한 함수도 있고 비동기로 구현한 함수도 있다.
동기로 구현된 경우 비동기 함수 이름 뒤에 &lt;code&gt;Sync&lt;/code&gt;가 붙는다.&lt;/p&gt;

&lt;p&gt;헝가리안 표기법의 연장선으로 생각해서 코딩을 하자.
함수 이름에 적당한 prefix/postfix를 붙여서 promise를 리턴한다고 명시하는 것이다.
그러면 함수의 선언을 보지 않고도 리턴 타입을 알 수 있을것이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;if(await isReadyAsync()) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;내가-선택한-길&#34;&gt;내가 선택한 길&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;tslint에서 strict-boolean-expression rule를 활성화&lt;/li&gt;
&lt;li&gt;CI 스크립트에 tslint 추가. lint를 통과하지 못하면 CI에서 빌드가 실패한다.&lt;/li&gt;
&lt;li&gt;함수 이름에 async붙이는건 이미 구현한게 많아서 귀찮다보니 생략&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>실제 사례로 보는 warning.or.kr part 2</title>
      <link>https://libsora.so/posts/warning-or-kr-in-real-case-2/</link>
      <pubDate>Tue, 09 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/warning-or-kr-in-real-case-2/</guid>
      <description>

&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;

&lt;p&gt;2018년 10월 9일, &lt;a href=&#34;https://twitter.com/kid1ng/status/1049509700608225281&#34;&gt;mobile.twitter.com 이 warning.or.kr 당했다&lt;/a&gt;.
그리고 몇시간 뒤에 &lt;a href=&#34;https://twitter.com/kid1ng/status/1049531824110690304&#34;&gt;차단이 해제되었다&lt;/a&gt;.
물 들어올때 노 저으라는 말이 있다.
현실 세계에 차단 이벤트가 발생했으니 귀찮아서 미루던 글을 써보려고 한다.&lt;/p&gt;

&lt;h2 id=&#34;정보-공개-청구&#34;&gt;정보 공개 청구&lt;/h2&gt;

&lt;p&gt;2018년 5월 3일에 trademyinfo.libsora.so의 차단과 관련된 자료를 방통위에 요청했다.
그리고 2018년 5월 16일에 대답을 받았다.&lt;/p&gt;

&lt;p&gt;요청한 정보는 아래와 같다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;2016년 제 80차 통신심의소위원회 (2016.11.8.)에서 &amp;lsquo;접속차단&amp;rsquo;으로 결정된 심의번호 &amp;lsquo;1736185&amp;rsquo; (불법-16-80-3228) 관련 차단 사유&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;위원회 홈페이지에 공개된 2016년 제 80차 통신심의소위원회 (2016.11.8.) 회의록 외 해당 회의 관련 자료 &amp;lt;관련: 심의번호 &amp;lsquo;1736185&amp;rsquo; (불법-16-80-3228)&amp;gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;심의번호 &amp;lsquo;1736185&amp;rsquo; (불법-16-80-3228)를 차단해제 결정한 시점과 차단해제 이유, 관련 기록 등&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그리고 몇가지 문서를 받았다.
(몇가지를 더 받긴했지만 중요하지 않은 문서는 생략했다)
나랏님답게 hwp를 던져줬는데 그걸 볼수 있는 사람은 별로 없을테니 pdf로 변환했다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://libsora.so/posts//warning-or-kr-in-real-case-2/첨부_정보공개내용.pdf&#34;&gt;첨부_정보공개내용.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://libsora.so/posts//warning-or-kr-in-real-case-2/[2016년 제80차 통신심의소위원회] 의결 가. 불법정보 심의에 관한 건_붙임.pdf&#34;&gt;[2016년 제80차 통신심의소위원회] 의결 가. 불법정보 심의에 관한 건_붙임.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://libsora.so/posts//warning-or-kr-in-real-case-2/[2016년 제80차 통신심의소위원회] 의결 가. 불법정보 심의에 관한 건_붙임.xlsx&#34;&gt;[2016년 제80차 통신심의소위원회] 의결 가. 불법정보 심의에 관한 건_붙임.xlsx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;첨부-정보공개내용-pdf&#34;&gt;첨부_정보공개내용.pdf&lt;/h2&gt;

&lt;p&gt;정보 공개 청구의 기본적인 내용은 이것으로 확인할 수 있었다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1: 2016년 제 80차 통신심의소위원회(2016.11.8.) 에서 &amp;lsquo;접속차단&amp;rsquo;으로 결정된 심의번호 &amp;lsquo;1736185&amp;rsquo; (불법-16-80-3228)  관련 차단 사유&lt;/p&gt;

&lt;p&gt;심의번호 &amp;lsquo;1736185&amp;rsquo; (불법-16-80-3228) 는 ｢정보통신망 이용촉진 및 정보보호 등에 관한 법률｣ 제44조의7제1항제9호 및 ｢정보통신에 관한 심의규정｣ 제7조제4호에 의거하여, ｢신용정보의 이용 및 보호에 관한 법률｣ 제33조 (개인신용정보의 이용) 및 제50조 (벌칙)에 저촉되는 내용으로 차단되었음을 양지하여 주시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;2: 위원회 홈페이지에 공개된 2016년 제 80차 통신심의소위원회 (2016.11.8.) 회의록 외 해당 회의 관련 자료 &amp;lt;관련: 심의번호 &amp;lsquo;1736185&amp;rsquo; (불법-16-80-3228)&amp;gt;&lt;/p&gt;

&lt;p&gt;2016년 제 80차 통신심의소위원회 (2016.11.8.) 안건자료 본문 및 붙임 각 1부를 송부하오니 참조하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;3: 2016년 제 80차 통신심의소위원회 (2016.11.8.)에서 &amp;lsquo;접속차단&amp;rsquo;으로 결정된 심의번호 &amp;lsquo;1736185&amp;rsquo; (불법-16-80-3228) 관련 차단 사유&lt;/p&gt;

&lt;p&gt;우리 위원회는 &amp;lsquo;1736185&amp;rsquo; (불법-16-80-3228)에 대해 &amp;lsquo;시정요구 철회&amp;rsquo; (차단해제) 결정을 한 바 없으며, 따라서 귀하께서 청구하신 정보 역시 보유하고 있지 않음을 알려드립니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;5월 3일에 정보 공개를 요청한 이유중 하나는 trademyinfo.libsora.so가 KT망에서 접속되어서이다.
내가 워닝을 풀어달라고 징징댄적도 없는데 갑자기 사이트가 접속되면 이상하지 않나?&lt;/p&gt;

&lt;p&gt;확인 결과 워닝은 풀린적 없다.
차단 해제가 풀린적이 없는데도 https도 아닌 http로 접속될때가 있더라.
(이 글을 쓰는 지금도 KT망에서 http로 접속할 수 있다)
방통위는 차단 목록을 관리하지만 그것을 실제로 적용하는건 통신사니까 안맞을때가 있나&amp;hellip;?
내가 워닝을 구현하지 않아서 잘 모르겠다.&lt;/p&gt;

&lt;p&gt;아무튼 나는 워닝 업적을 아직 갖고있느니 그거면 된거다.&lt;/p&gt;

&lt;p&gt;???&lt;/p&gt;

&lt;h2 id=&#34;2016년-제80차-통신심의소위원회-의결-가-불법정보-심의에-관한-건-붙임-pdf&#34;&gt;[2016년 제80차 통신심의소위원회] 의결 가. 불법정보 심의에 관한 건_붙임.pdf&lt;/h2&gt;

&lt;p&gt;5페이지 문서인데 첫장은 제목이다.
실제 내용이 4장인 문서이다.
수많은 사이트를 차단할 문서인데 이렇게 부실하다니!
의미있는 내용은 더 부실하다.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;심의번호&lt;/th&gt;
&lt;th&gt;정보내용&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;불법-16-80-3077~3254 (178건)&lt;/td&gt;
&lt;td&gt;개인정보 판매&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;불법-16-80-3255~3692 (438건)&lt;/td&gt;
&lt;td&gt;타인 명의거래 (대포통장 · 대포차 · 대포폰)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;616건이 차단될 예정인데 616건의 상세 내용은 없다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;차단된 사이트의 URL 정보는 관련 법령에 의해 차단된 불법 유해 정보로써 해당 목록과 구체적인 사유는 홈페이지 상에 공개되지 않습니다&lt;/strong&gt;
라는 철칙을 잘 지키고 계신다.&lt;/p&gt;

&lt;h2 id=&#34;2016년-제80차-통신심의소위원회-의결-가-불법정보-심의에-관한-건-붙임-xlsx&#34;&gt;[2016년 제80차 통신심의소위원회] 의결 가. 불법정보 심의에 관한 건_붙임.xlsx&lt;/h2&gt;

&lt;p&gt;엑셀파일에는 내가 요청한 사이트 하나의 정보만 적혀있다.
나와 동시에 차단될 616개의 사이트 목록이 같이 붙어있었으면 더 재밌었을텐데 나랏님답게 이런데서 꼼꼼하다.&lt;/p&gt;

&lt;p&gt;표를 웹에 그대로 때려박으면 어색하니 적당히 조작했다.&lt;/p&gt;

&lt;p&gt;[붙임] 심의대상 목록(1건)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;심의번호 : 불법-16-80-3228&lt;/li&gt;
&lt;li&gt;서비스 제공자 : 케이티 등 9개 망사업자&lt;/li&gt;
&lt;li&gt;URL : trademyinfo.libsora.so/&lt;/li&gt;
&lt;li&gt;문제내용 : 동 정보는 개인신용정보의 경우, 동 신용정보주체가 신청한 금융거래 등 상거래관계의 설정 및 유지 여부 등을 판단하기 위한 목적으로만 이용하여야 하는 등의 제한이 있음에도 불구하고, 이를 위반하여 이용하는 행위를 조장하는 내용임.&lt;/li&gt;
&lt;li&gt;적용법규 : 「정보통신망 이용촉진 및 정보보호 등에 관한 법률」 제44조의7제1항제9호, ｢정보통신에 관한 심의규정｣ 제7조제4호, ｢신용정보의 이용 및 보호에 관한 법률｣ 제33조(개인신용정보의 이용), 제50조(벌칙)&lt;/li&gt;
&lt;li&gt;검토의견

&lt;ul&gt;
&lt;li&gt;시정여부 : 시정요구&lt;/li&gt;
&lt;li&gt;조치사항 : 접속차단&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;신고인 : 일반인&lt;/li&gt;
&lt;li&gt;심의번호 : 1736185&lt;/li&gt;
&lt;li&gt;접수번호 : 2386736&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;정보를-합쳐보면&#34;&gt;정보를 합쳐보면&amp;hellip;&lt;/h2&gt;

&lt;p&gt;얻은 정보를 합쳐서 일이 어떻게 처리되었나 망상해봤다&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;내용이 불편하신 일반인이 방송통신심의위원회에 신고를 넣었다&lt;/li&gt;
&lt;li&gt;민원이 들어갔으니 방송통신심의위원회에서는 적당한 이유를 붙여서 차단하기로 결정했다.

&lt;ul&gt;
&lt;li&gt;사이트를 전부 살펴보는 노력같은건 하지 않았을것이다. 버튼이라고 해봐야 하나뿐인데 이걸 눌러봤으면 차단하지 않았을것이다.&lt;/li&gt;
&lt;li&gt;공무원이 일처리하는게 다 그렇지뭐. 민원인이 지랄지랄하는거 피곤하니까 차단 요청했으니 차단하기로 결정했을 것이다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;제 80차 통신심의소위원회 정기회의를 위한 문서를 준비한다. 사이트들을 차단하기로 이미 정해놨으니 사이트 목록을 문서에 적을 필요는 없다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;제 80차 통신심의소위원회 정기회의가 진행되고 사이트는 예정되로 차단된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;볼수록 기분 나쁜 지점이 있다.&lt;/p&gt;

&lt;p&gt;민원이 들어오면 민원인들이 지랄하는거 듣기 피곤하니 일단 차단한다.
그리고 차단 당한 사람이 이의신청 하면 풀어준다.
차단이라는 절대 권력을 가진 인간들이 일을 대충 처리한다는 느낌이다.&lt;/p&gt;

&lt;p&gt;나는 접속 차단이라는 절대 권련은 신중하게 쓰여야한다고 생각한다.
하지만 방통위는 그렇게 생각하지 않나보다.&lt;/p&gt;

&lt;p&gt;아니면 차단에 너무 익숙해져서 접속 차단의 무게를 잊어버렸거나.&lt;/p&gt;

&lt;h2 id=&#34;해보고-싶은-일&#34;&gt;해보고 싶은 일&lt;/h2&gt;

&lt;p&gt;접속 차단을 당하는 입장에서 일이 어떻게 진행되는지는 알거같다.
하지만 차단 신고하는 입장에서는 일이 어떻게 진행되나 모른다. 해본적이 없어서.&lt;/p&gt;

&lt;p&gt;그래서 간단한걸 생각해봤다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;가짜 도박/마약 사이트를 몇개 만든다.

&lt;ul&gt;
&lt;li&gt;대문 페이지만 그럴싸하지만 되는건 아무것도 없다.&lt;/li&gt;
&lt;li&gt;각각의 사이트별로 자극적인 소재를 다루는 정도를 약간씩 다르게 한다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;방통위에 차단 신고를 넣는다&lt;/li&gt;
&lt;li&gt;차단 신고가 처리될때까지의 소요시간, 처리 절차, 몇개가 차단되었는지를 정리한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;근데 귀찮아서 안할거같다.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
