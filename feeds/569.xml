<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>뒤태지존의 끄적거림</title>
  
  <subtitle>개발</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://homoefficio.github.io/"/>
  <updated>2019-05-09T11:30:32.488Z</updated>
  <id>http://homoefficio.github.io/</id>
  
  <author>
    <name>HomoEfficio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>재미로 보는 언어별 스트림 처리 비교</title>
    <link href="http://homoefficio.github.io/2019/05/08/%EC%9E%AC%EB%AF%B8%EB%A1%9C-%EB%B3%B4%EB%8A%94-%EC%96%B8%EC%96%B4%EB%B3%84-%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EC%B2%98%EB%A6%AC-%EB%B9%84%EA%B5%90/"/>
    <id>http://homoefficio.github.io/2019/05/08/재미로-보는-언어별-스트림-처리-비교/</id>
    <published>2019-05-08T13:32:35.000Z</published>
    <updated>2019-05-09T11:30:32.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="재미로-보는-언어별-스트림-처리-비교"><a href="#재미로-보는-언어별-스트림-처리-비교" class="headerlink" title="재미로 보는 언어별 스트림 처리 비교"></a>재미로 보는 언어별 스트림 처리 비교</h1><p>NBA를 즐겨보는데 갑자기 역대 MVP가 궁금해서 찾아보니 <a href="https://www.nba.com/history/awards/mvp" target="_blank" rel="noopener">https://www.nba.com/history/awards/mvp</a> 여기에서 볼 수 있었다. 연도별로 주욱 나열되어 있는데 <strong>수상횟수 기준으로 집계해서 내림차순</strong>으로 보고 싶었다.</p><p>그래서 연습도 할 겸 자바로 먼저 짜봤는데 다른 언어로 짜주신 분들도 계셔서 <strong>재미로 비교</strong>를 해보려 한다. 언어의 전반적인 우열을 가리는 목적이 전혀 아니므로 구경하는 재미로만 참고하면 좋겠다.</p><p>자바 외에 다른 언어에 대한 지식이 많지 않으므로 잘못된 정보가 포함될 수도 있으며 이 부분은 댓글로 바로잡아주시면 정말 감사드리며 바로 반영하겠다.</p><p>자 이제 시작해보자. 연도별 NBA MVP 명단 데이터는 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">String MVPS = <span class="string">""</span> +</span><br><span class="line">            <span class="string">"2017-18     James Harden, Houston Rockets (Voting)\n"</span> +</span><br><span class="line">            <span class="string">"2016-17     Russell Westbrook, Oklahoma City Thunder (Voting)\n"</span> +</span><br><span class="line">            <span class="string">"2015-16     Stephen Curry, Golden State Warriors (Voting)\n"</span> +</span><br><span class="line">            <span class="string">"2014-15     Stephen Curry, Golden State Warriors\n"</span> +</span><br><span class="line">            <span class="string">"2013-14     Kevin Durant, Oklahoma City Thunder\n"</span> +</span><br><span class="line">            <span class="string">"2012-13     LeBron James, Miami Heat\n"</span> +</span><br><span class="line">            <span class="string">"2011-12     LeBron James, Miami Heat\n"</span> +</span><br><span class="line">            <span class="string">"2010-11     Derrick Rose, Chicago Bulls\n"</span> +</span><br><span class="line">            <span class="string">"2009-10     LeBron James, Cleveland Cavaliers\n"</span> +</span><br><span class="line">            <span class="string">"2008-09     LeBron James, Cleveland Cavaliers\n"</span> +</span><br><span class="line">            <span class="string">"2007-08     Kobe Bryant, Los Angeles Lakers\n"</span> +</span><br><span class="line">            <span class="string">"2006-07     Dirk Nowitzki, Dallas Mavericks\n"</span> +</span><br><span class="line">            <span class="string">"2005-06     Steve Nash, Phoenix Suns\n"</span> +</span><br><span class="line">            <span class="string">"2004-05     Steve Nash, Phoenix Suns\n"</span> +</span><br><span class="line">            <span class="string">"2003-04     Kevin Garnett, Minnesota Timberwolves\n"</span> +</span><br><span class="line">            <span class="string">"2002-03     Tim Duncan, San Antonio Spurs\n"</span> +</span><br><span class="line">            <span class="string">"2001-02     Tim Duncan, San Antonio Spurs\n"</span> +</span><br><span class="line">            <span class="string">"2000-01     Allen Iverson, Philadelphia 76ers\n"</span> +</span><br><span class="line">            <span class="string">"1999-00     Shaquille O'Neal, Los Angeles Lakers\n"</span> +</span><br><span class="line">            <span class="string">"1998-99     Karl Malone, Utah Jazz\n"</span> +</span><br><span class="line">            <span class="string">"1997-98     Michael Jordan, Chicago Bulls\n"</span> +</span><br><span class="line">            <span class="string">"1996-97     Karl Malone, Utah Jazz\n"</span> +</span><br><span class="line">            <span class="string">"1995-96     Michael Jordan, Chicago Bulls\n"</span> +</span><br><span class="line">            <span class="string">"1994-95     David Robinson, San Antonio Spurs\n"</span> +</span><br><span class="line">            <span class="string">"1993-94     Hakeem Olajuwon, Houston Rockets\n"</span> +</span><br><span class="line">            <span class="string">"1992-93     Charles Barkley, Phoenix Suns\n"</span> +</span><br><span class="line">            <span class="string">"1991-92     Michael Jordan, Chicago Bulls\n"</span> +</span><br><span class="line">            <span class="string">"1990-91     Michael Jordan, Chicago Bulls\n"</span> +</span><br><span class="line">            <span class="string">"1989-90     Magic Johnson, Los Angeles Lakers\n"</span> +</span><br><span class="line">            <span class="string">"1988-89     Magic Johnson, Los Angeles Lakers\n"</span> +</span><br><span class="line">            <span class="string">"1987-88     Michael Jordan, Chicago Bulls\n"</span> +</span><br><span class="line">            <span class="string">"1986-87     Magic Johnson, Los Angeles Lakers\n"</span> +</span><br><span class="line">            <span class="string">"1985-86     Larry Bird, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1984-85     Larry Bird, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1983-84     Larry Bird, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1982-83     Moses Malone, Philadelphia 76ers\n"</span> +</span><br><span class="line">            <span class="string">"1981-82     Moses Malone, Houston Rockets\n"</span> +</span><br><span class="line">            <span class="string">"1980-81     Julius Erving, Philadelphia 76ers\n"</span> +</span><br><span class="line">            <span class="string">"1979-80     Kareem Abdul-Jabbar, Los Angeles Lakers\n"</span> +</span><br><span class="line">            <span class="string">"1978-79     Moses Malone, Houston Rockets\n"</span> +</span><br><span class="line">            <span class="string">"1977-78     Bill Walton, Portland Trail Blazers\n"</span> +</span><br><span class="line">            <span class="string">"1976-77     Kareem Abdul-Jabbar, Los Angeles Lakers\n"</span> +</span><br><span class="line">            <span class="string">"1975-76     Kareem Abdul-Jabbar, Los Angeles Lakers\n"</span> +</span><br><span class="line">            <span class="string">"1974-75     Bob McAdoo, Buffalo Braves\n"</span> +</span><br><span class="line">            <span class="string">"1973-74     Kareem Abdul-Jabbar, Milwaukee Bucks\n"</span> +</span><br><span class="line">            <span class="string">"1972-73     Dave Cowens, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1971-72     Kareem Abdul-Jabbar, Milwaukee Bucks\n"</span> +</span><br><span class="line">            <span class="string">"1970-71     Kareem Abdul-Jabbar, Milwaukee Bucks\n"</span> +</span><br><span class="line">            <span class="string">"1969-70     Willis Reed, New York Knicks\n"</span> +</span><br><span class="line">            <span class="string">"1968-69     Wes Unseld, Baltimore Bullets\n"</span> +</span><br><span class="line">            <span class="string">"1967-68     Wilt Chamberlain, Philadelphia 76ers\n"</span> +</span><br><span class="line">            <span class="string">"1966-67     Wilt Chamberlain, Philadelphia 76ers\n"</span> +</span><br><span class="line">            <span class="string">"1965-66     Wilt Chamberlain, Philadelphia 76ers\n"</span> +</span><br><span class="line">            <span class="string">"1964-65     Bill Russell, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1963-64     Oscar Robertson, Cincinnati Royals\n"</span> +</span><br><span class="line">            <span class="string">"1962-63     Bill Russell, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1961-62     Bill Russell, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1960-61     Bill Russell, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1959-60     Wilt Chamberlain, Philadelphia Warriors\n"</span> +</span><br><span class="line">            <span class="string">"1958-59     Bob Pettit, St. Louis Hawks\n"</span> +</span><br><span class="line">            <span class="string">"1957-58     Bill Russell, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1956-57     Bob Cousy, Boston Celtics\n"</span> +</span><br><span class="line">            <span class="string">"1955-56     Bob Pettit, St. Louis Hawks"</span>;</span><br></pre></td></tr></table></figure><h1 id="구현-비교"><a href="#구현-비교" class="headerlink" title="구현 비교"></a>구현 비교</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>Java 8의 Stream API를 활용해서 작성한 코드는 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String[] lines = MVPS.split(<span class="string">"\\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> mvpCount = Stream.of(lines)</span><br><span class="line">            .collect(groupingBy(line -&gt; line.substring(<span class="number">12</span>, line.indexOf(<span class="string">','</span>)), counting()))</span><br><span class="line">            .entrySet().stream()</span><br><span class="line">            .sorted(comparingByValue(reverseOrder()))</span><br><span class="line">            .peek(e -&gt; out.println(e.getKey() + <span class="string">": "</span> + e.getValue()))</span><br><span class="line">            .mapToLong(Map.Entry::getValue)</span><br><span class="line">            .sum();</span><br><span class="line"></span><br><span class="line">    out.println(lines.length == mvpCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>큰 흐름은 <code>키(선수 이름) 추출</code>, <code>groupBy</code>, <code>수상횟수 집계</code>, <code>정렬</code>, <code>출력</code>, <code>전체 합계</code>로 구성된다.</p><p><strong>자바에는 튜플이 없다.</strong> 그래서 <code>groupingBy()</code>의 결과는 Map으로 collect되고 이 과정에서 최초의 스트림이 종결된다. 그리고 Map에서 <code>entrySet().stream()</code>을 통해 새 스트림을 만들고 정렬, 출력, 합계 등을 처리해야 한다. 따라서 <code>수상횟수 집계</code>와 <code>정렬</code> 사이에 스트림 생성이 하나 추가된다고 볼 수 있다.</p><p>값(MVP 수상횟수) 기준 내림차순 정렬은 <code>.sorted(comparingByValue(reverseOrder()))</code>로 깔끔하게 처리할 수는 있지만 조금 장황해보이기도 하다. 앞으로 살펴볼 다른 언어 구현체와 비교하면 실제로도 좀 길긴 하다.</p><p><code>peek()</code>이 있어서 스트림의 데이터를 완전 소비(consume)하지 않으면서도 출력할 수 있어서, 출력과 합계를 하나의 스트림으로 처리할 수 있다.</p><blockquote><p>한 줄 평: Stream API 덕에 깔끔한 구조로 작성할 수 있음에도 불구하고 메서드 이름이 길어서 전반적으로 장황해보인다.</p></blockquote><h2 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h2><p>스칼라 버전은 <strong>Kevin Lee 님</strong>께서 작성해주신 걸 살짝 다듬었다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lines = <span class="type">MVPS</span>.split(<span class="string">"\n"</span>)</span><br><span class="line"><span class="keyword">val</span> mvpList = lines</span><br><span class="line">  .groupBy(_.drop(<span class="number">12</span>).takeWhile(_ != ','))  </span><br><span class="line">  .mapValues(_.size)</span><br><span class="line">  .toList</span><br><span class="line">  .sortBy(_._2)(<span class="type">Ordering</span>.<span class="type">Int</span>.reverse)</span><br><span class="line"></span><br><span class="line">println(mvpList.map &#123; <span class="keyword">case</span> (name, count) =&gt; <span class="string">s"<span class="subst">$name</span>: <span class="subst">$count</span>"</span> &#125;.mkString(<span class="string">"\n"</span>))</span><br><span class="line">println(lines.size == mvpList.map(_._2).sum)</span><br></pre></td></tr></table></figure><p>스칼라에서도 큰 흐름은 <code>키(선수 이름) 추출</code>, <code>groupBy</code>, <code>수상횟수 집계</code>, <code>정렬</code>, <code>출력</code>, <code>전체 합계</code>로 달라진 것은 없다. </p><p>키 추출이 자바와 조금 다르게 구현되었지만 장황한 점은 비슷해 보이고, 자바의 <code>groupingBy()</code>에서 키 별 분류와 수상횟수 집계를 함께 처리할 수 있었지만, 스칼라의 <code>groupBy()</code>는 키 별 분류만 가능하고 수상횟수의 집계는 <code>mapValues(_.size)</code>를 통해 따로 처리하는 점이 다르다.</p><p>정렬하기 전에 리스트로 만드는 과정(<code>toList</code>)이 하나 추가되는 것도 절차상으로는 <code>entrySet().stream()</code>으로 스트림을 새로 만드는 자바와 비슷하고, 정렬 과정도 자바와 비슷하다. </p><p><strong><code>(_.drop(12))</code>, <code>(_.size)</code>, <code>(_._2)</code> 같은 표현법으로 <code>-&gt;</code> 없이도 람다식을 표현할 수 있고, <code>getKey()</code>, <code>getValue()</code> 대신 <code>._1</code>, <code>._2</code>로 짧게 표현할 수 있어서 비슷한 구조임에도 자바보다 훨씬 간결해보인다.</strong> 하지만 <code>_</code>를 쓰지 않는다면 <code>map { case (name, count) =&gt; ... }</code>에서처럼 <code>=&gt;</code>뿐 아니라 <code>case</code>도 나오면서 조금 복잡해진다.</p><p>자바의 <code>peek()</code> 같은 메서드가 없어서인지 출력과 전체 합계를 하나의 스트림으로 처리하지 못하고 별도로 처리하는 것도 다르다.</p><blockquote><p>한 줄 평: <code>_</code>를 잘 쓰면 자바보다 훨씬 간결하게 짤 수 있다.</p></blockquote><h2 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h2><p>코틀린 버전은 <strong>부종민 님</strong>께서 짜주신 걸 살짝 개선해봤다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> lines = MVPS.split(<span class="string">"\n"</span>)</span><br><span class="line">    <span class="keyword">val</span> totalCount = lines</span><br><span class="line">        .groupingBy &#123; it.substring(<span class="number">12</span>, it.indexOf(<span class="string">','</span>)) &#125;</span><br><span class="line">        .eachCount()</span><br><span class="line">        .toList()</span><br><span class="line">        .sortedByDescending &#123; it.second &#125;</span><br><span class="line">        .onEach &#123; println(it) &#125;</span><br><span class="line">        .map &#123; it.second &#125;</span><br><span class="line">        .sum()</span><br><span class="line"></span><br><span class="line">    println(lines.size == totalCount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코틀린은 흐름이 스칼라와 거의 동일하다.</p><p><code>substring()</code>은 자바와 동일하고 원한다면 스칼라처럼 <code>drop()</code>, <code>takeWhile()</code>을 쓸 수도 있다.</p><p><code>groupingBy {}</code> 에서는 스칼라와 마찬가지로 키 기준 분류만 가능하고 집계는 <code>eachCount()</code>로 따로 해줘야 한다. 정렬하기 전에 <code>toList()</code>로 리스트를 만드는 것도 동일하다. </p><p>스칼라에 튜플이 있다면 <strong>코틀린에는 <code>Pair</code>가 있다. 그래서 자바처럼 <code>getKey()</code>, <code>getValue()</code> 같은 메서드를 쓰지 않고 <code>it.first</code>, <code>it.second</code>와 같은 형식으로 짧게 표현 가능하다.</strong> 그래도 <code>first</code>나 <code>second</code>보다는 <code>_1</code>, <code>_2</code>처럼 더 짧게 표현 가능한 스칼라 쪽이 더 나아 보인다.</p><p>람다식을 <code>{ }</code>를 써서 인자로 받는 것에서 약간의 이질감이 느껴지지만, <strong><code>it</code>라는 built-in 키워드를 써서 <code>-&gt;</code> 없이도 람다식을 짧게 표현할 수 있는 점</strong>도 스칼라와 비슷하다.</p><p>자바의 <code>peek()</code>과 동일한 역할을 하는 <code>onEach()</code>가 있어서 출력과 전체 합계를 하나의 스트림에서 모두 처리할 수 있다는 점은 스칼라와 다르다.</p><blockquote><p>한 줄 평: 스칼라와 거의 비슷한 작성 방식과 간결함을 보여주면서도, 스칼라에 없는 <code>onEach()</code>를 가지고 있어서 자바의 장점도 가지고 있다.</p></blockquote><h2 id="뽕-맞은-자바-feat-jooL"><a href="#뽕-맞은-자바-feat-jooL" class="headerlink" title="뽕 맞은 자바(feat. jooL)"></a>뽕 맞은 자바(feat. jooL)</h2><p><strong>박성철 님</strong>께서 바닐라 자바는 쓰는 게 아니라고 하시면서 <code>jooL 라이브러리</code>(<a href="https://github.com/jOOQ/jOOL" target="_blank" rel="noopener">https://github.com/jOOQ/jOOL</a>) 를 사용해서 작성해주신 버전을 보면 ‘오~~ 이게 정녕 자바란 말씀입니까?’란 소리가 나올 정도로 감동적이다. 스칼라나 코틀린보다 더 간결하다!!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String[] lines = MVPS.split(<span class="string">"\\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> mvpCount = Seq.of(lines)</span><br><span class="line">            .grouped(line -&gt; line.substring(<span class="number">12</span>, line.indexOf(<span class="string">','</span>)), counting()))</span><br><span class="line">            .sorted(t -&gt; - t.v2)</span><br><span class="line">            .peek(t -&gt; out.println(t.v1 + <span class="string">": "</span> + t.v2))</span><br><span class="line">            .sumLong(t -&gt; t.v2);</span><br><span class="line"></span><br><span class="line">    out.println(lines.length == mvpCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스칼라나 코틀린처럼 <strong>튜플이 있어서 <code>t.v2</code>같은 간략한 표현이 가능</strong>해졌고, 특히 <strong>값 기준 내림차순 정렬을 <code>sorted(t -&gt; - t.v2)</code>로 간단 명료하게 표현할 수 있는 점이 눈에 띈다.</strong> 그리고 groupBy 후에 <code>entrySet().stream()</code>이나 <code>toList</code> 없이도 클로저처럼 바로 정렬할 수 있다.</p><blockquote><p>한 줄 평: 바닐라 자바는 쓰는 게 아니다.</p></blockquote><h2 id="Clojure"><a href="#Clojure" class="headerlink" title="Clojure"></a>Clojure</h2><p>클로저는 버전이 두 개인데 <code>-&gt;&gt;</code> 매크로를 사용한 버전은 <strong>박상규 님</strong>께서 만들어주셨다.</p><p><strong>짧을 줄은 알았지만 생각보다 더 짧다..</strong></p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">run!</span> prn </span><br><span class="line">    (<span class="name"><span class="builtin-name">sort-by</span></span> val &gt; </span><br><span class="line">        (<span class="name">frequencies</span> (<span class="name"><span class="builtin-name">map</span></span> #(<span class="name">subs</span> % <span class="number">12</span> (<span class="name">index-of</span> % <span class="string">","</span>)) lines))))</span><br></pre></td></tr></table></figure><p>클로저는 앞에서 다룬 언어와는 좀 다르게 Lisp 계열의 언어이며, 함수의 chaining이 아니라 nesting을 사용하므로 <strong>코드의 흐름이 의식의 흐름에 역행하는 것으로 보여서 이질감이 매우 크다.</strong> 하지만 이를 보완할 수 있는 방법이 있으니 바로 <strong><code>-&gt;&gt;</code> 매크로</strong>다.</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">-&gt;&gt;</span></span> lines</span><br><span class="line">  (<span class="name"><span class="builtin-name">map</span></span> #(<span class="name">subs</span> % <span class="number">12</span> (<span class="name">index-of</span> % <span class="string">","</span>)))</span><br><span class="line">  frequencies </span><br><span class="line">  (<span class="name"><span class="builtin-name">sort-by</span></span> val &gt;)</span><br><span class="line">  (<span class="name">run!</span> prn))</span><br></pre></td></tr></table></figure><p>이렇게 <strong><code>-&gt;&gt;</code> 매크로를 사용하면 클로저 특유의 간결함을 유지하면서도 의식의 흐름과 코드 흐름의 불일치를 극복할 수도 있다.</strong></p><p><code>map</code>은 다른 언어와 다를 게 없다. <code>#()</code>를 써서 익명 함수를 만들 수 있고, <code>%</code>로 익명 함수의 인자를 표현할 수 있는데 <code>%1</code>, <code>%2</code>와 같이 두 개 이상의 인자도 표현 가능하다.</p><p><code>frequencies</code><br><code>groupingBy(key, counting())</code><br><code>groupBy(key).mapValues(_.size)</code><br><code>groupingBy { key }.eachCount()</code></p><p>위 네 가지는 모두 동일한 역할을 담당하는데, 코드의 양으로 보나 의미 전달력으로 보나 클로저의 <code>frequencies</code>에 가장 높은 점수를 줄 수 있겠다.</p><p>코드에 나타나지 않은 가장 큰 차이점이 하나 있다. 자바, 스칼라, 코틀린에서는 groupBy를 한 후 다시 리스트로 만들어줘야 정렬을 할 수가 있는데, 클로저에서는 <code>frequencies</code>가 반환하는 <strong>맵 자체를 대상으로 값 기준 정렬이 가능하다.</strong></p><p><code>sort-by val &gt;</code><br><code>sorted(comparingByValue(reverseOrder()))</code><br><code>sortBy(_._2)(Ordering.Int.reverse)</code><br><code>sortedByDescending { it.second }</code></p><p>위 네 가지도 모두 동일한 역할을 하는데, 이번에도 클로저의 <code>sort-by val &gt;</code>에 가장 높은 점수를 줄 수 있겠다. <strong>값(val) 기준 내림차순(&gt;)으로 정렬하라(sort-by)는 의미를 <code>sort-by val &gt;</code>로 정말 간단 명료하게 표현</strong>하고 있다.</p><p>다만 클로저도 스칼라와 마찬가지로 자바의 <code>peek()</code>이나 코틀린의 <code>onEach()</code> 같은 기능의 함수가 없어서 출력과 합계를 하나의 스트림에서 처리하지 못하는 것은 단점이다. 스칼라처럼 Lazy Sequence를 변수에 담아두고 출력에 사용하고, 합계 계산에 사용하면 될텐데 그 부분은 아예 작성을 못 했다. ㅋㅋ</p><blockquote><p>한 줄 평: 간결함으로는 타의 추종을 불허하지만, Lisp에 익숙해지기는 쉽지 않다.</p></blockquote><h2 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h2><p>스택오버플로우 기준 올해까지 4년 연속 가장 사랑받는 언어 러스트도 한 번 시도해봤다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> mvps_count = MVPS.lines()</span><br><span class="line">        .map(|line| &amp;line[<span class="number">12</span>..line.find(<span class="string">','</span>).unwrap_or(line.len())])</span><br><span class="line">        .into_iter()</span><br><span class="line">        .sorted()</span><br><span class="line">        .group_by(|name| *name)</span><br><span class="line">        .into_iter()</span><br><span class="line">        .map(|(key, group)| (key, group.count()))</span><br><span class="line">        .sorted_by(|a, b| (b.<span class="number">1</span>).cmp(&amp;a.<span class="number">1</span>))</span><br><span class="line">        .inspect(|(key, count)| <span class="built_in">println!</span>(<span class="string">"&#123;&#125;: &#123;&#125;"</span>, key, count))</span><br><span class="line">        .map(|(_key, count)| count)</span><br><span class="line">        .fold(<span class="number">0</span> <span class="keyword">as</span> <span class="built_in">usize</span>, |a, b| a + b);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, MVPS.lines().count() == mvps_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>러스트는.. 자세한 설명은 생략.. 하고 싶지만..</p><p>다른 언어와 가장 크게 다른 점은 <strong><code>group_by</code>전에 반드시 <code>sorted()</code>를 해줘야 제대로 키 기준 분류가 작동</strong>한다는 점이다. 예를 들어 <code>[a, a, b, a, c, a]</code>에 <code>group_by</code>와 <code>map</code>으로 키 별 분류와 집계를 적용하면 <code>[(a, 4), (b, 1), (c, 1)]</code>이 나올 것이 예상되고 다른 언어는 모두 예상대로 동작하지만, 러스트는 <code>[(a, 2), (b, 1), (a, 1), (c, 1), (a, 1)]</code>라는 결과를 반환한다. 따라서 키 기준으로 먼저 정렬을 해줘야 예상대로 동작하게 된다.</p><p>자바의 <code>peek()</code>, 코틀린의 <code>onEach()</code>처럼 러스트에도 <code>inspect()</code>가 있어서 출력과 전체 합계를 하나의 스트림에서 처리할 수 있다.</p><blockquote><p>한 줄 평: 러스트는 사랑스러울지언정 어렵고 어지럽다.</p></blockquote><h1 id="문서-비교"><a href="#문서-비교" class="headerlink" title="문서 비교"></a>문서 비교</h1><p>사실 다른 언어는 잘 모르는 채로 시도해봤던 거라 검색과 문서에 크게 의존할 수 밖에 없었다. 개인 취향에 따라 모두 다를테지만, 이왕 비교한 거 구현 말고 문서도 구경하기 수준으로 비교해보자. 그래도 공정한 비교를 위해 <code>groupBy</code>를 설명하는 문서로 비교한다.</p><h2 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h2><p><img src="https://i.imgur.com/NyfU0Gq.png" alt="Imgur"></p><p>무시무시한 저 메서드 시그너처로 시작해서 구구절절 설명을 이어간다. 그래도 이 <code>groupingBy</code>는 고맙게도 실제 사용 예제를 하나 던져주셨는데 모든 메서드에 대해 이런 예제가 제공되는 것은 아니다. 그래서 예제가 풍부하게 제공되는 <a href="http://www.baeldung.com" target="_blank" rel="noopener">www.baeldung.com</a> 같은 사이트를 많이 참고하게 된다.</p><h2 id="Scala-1"><a href="#Scala-1" class="headerlink" title="Scala"></a>Scala</h2><p><img src="https://i.imgur.com/iBoGbKT.png" alt="Imgur"></p><p>스칼라는 문서도 간결하다. 너무 간결해서 예제도 없다..</p><h2 id="Kotlin-1"><a href="#Kotlin-1" class="headerlink" title="Kotlin"></a>Kotlin</h2><p><img src="https://i.imgur.com/WVi56uS.png" alt="Imgur"></p><p>코틀린은 <strong>예제를 단순한 텍스트가 아니라 실행 가능한 환경과 함께 제공</strong>한다!! 그래서 요리조리 직접 바꿔가며 실행 결과를 바로 확인해 볼 수 있다!! 이런 참신함에는 높은 점수를 주고 싶다. 그런데 예제가 풍부하지는 않다.</p><p>위에 작성한 코드에는 <code>groupBy</code>가 키 분류만 가능하게 되어 있는데 문서를 보니 키 분류뿐 아니라 항목 집계도 가능한 걸로 보인다. 하지만 관련 예제가 없어서 어떻게 하면 원하는 대로 바꿀 수 있을지 바로 알 수는 없었다.</p><h2 id="Clojure-1"><a href="#Clojure-1" class="headerlink" title="Clojure"></a>Clojure</h2><p><img src="https://i.imgur.com/VWlC5NZ.png" alt="Imgur"></p><p>클로저는 문서도 가장 간결하다. </p><p>그런데 그보다 더 중요한 것은 <strong>다른 언어 문서들과 달리 공식 문서가 오픈 방식</strong>이라는 것이다. 로그인만 하면 사용자가 직접 다양한 예제를 추가할 수 있게 되어 있을뿐 아니라 화면에는 안 나왔지만 질의 응답도 가능하게 완전히 열려있다. </p><p>덕분에 클로저를 거의 모르는 나같은 문외한도 MVP 수상횟수 집계 예제 정도는 클로저 문서 사이트만으로도 그럭저럭 짤 수 있었다. 실용성 면에서는 가장 높은 점수를 줄 만하다.</p><h2 id="Rust-1"><a href="#Rust-1" class="headerlink" title="Rust"></a>Rust</h2><p><img src="https://i.imgur.com/W1rg6ZV.png" alt="Imgur"></p><p>일단 위 예제에서 사용한 <code>group_by</code>는 러스트 자체에 포함된 것은 아니고, <code>itertools</code>라는 크레이트(crate, 그냥 라이브러리 라고 이해해도 크게 틀리지 않음)에서 제공하는 것인데, 문서의 포맷은 러스트의 공식 문서 사이트와 동일하다.</p><p>적절한 설명과 함께 예제가 제공된다. 예제에 주석으로 고마운 설명이 달려있긴 하지만 클로저처럼 오픈 방식이 아니라서 예제가 다양하지는 않다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;재미로-보는-언어별-스트림-처리-비교&quot;&gt;&lt;a href=&quot;#재미로-보는-언어별-스트림-처리-비교&quot; class=&quot;headerlink&quot; title=&quot;재미로 보는 언어별 스트림 처리 비교&quot;&gt;&lt;/a&gt;재미로 보는 언어별 스트림 처리 비교&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="Language" scheme="http://homoefficio.github.io/categories/Language/"/>
    
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="자바" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94/"/>
    
      <category term="Stream" scheme="http://homoefficio.github.io/tags/Stream/"/>
    
      <category term="스트림" scheme="http://homoefficio.github.io/tags/%EC%8A%A4%ED%8A%B8%EB%A6%BC/"/>
    
      <category term="Scala" scheme="http://homoefficio.github.io/tags/Scala/"/>
    
      <category term="Kotlin" scheme="http://homoefficio.github.io/tags/Kotlin/"/>
    
      <category term="Clojure" scheme="http://homoefficio.github.io/tags/Clojure/"/>
    
      <category term="Rust" scheme="http://homoefficio.github.io/tags/Rust/"/>
    
      <category term="groupBy" scheme="http://homoefficio.github.io/tags/groupBy/"/>
    
      <category term="groupingBy" scheme="http://homoefficio.github.io/tags/groupingBy/"/>
    
      <category term="sort by value" scheme="http://homoefficio.github.io/tags/sort-by-value/"/>
    
      <category term="map" scheme="http://homoefficio.github.io/tags/map/"/>
    
      <category term="reduce" scheme="http://homoefficio.github.io/tags/reduce/"/>
    
      <category term="fold" scheme="http://homoefficio.github.io/tags/fold/"/>
    
      <category term="peek" scheme="http://homoefficio.github.io/tags/peek/"/>
    
      <category term="onEach" scheme="http://homoefficio.github.io/tags/onEach/"/>
    
      <category term="inspect" scheme="http://homoefficio.github.io/tags/inspect/"/>
    
      <category term="Tuple" scheme="http://homoefficio.github.io/tags/Tuple/"/>
    
      <category term="Pair" scheme="http://homoefficio.github.io/tags/Pair/"/>
    
      <category term="it" scheme="http://homoefficio.github.io/tags/it/"/>
    
      <category term="_" scheme="http://homoefficio.github.io/tags//"/>
    
      <category term="jooL" scheme="http://homoefficio.github.io/tags/jooL/"/>
    
      <category term="reference doc" scheme="http://homoefficio.github.io/tags/reference-doc/"/>
    
      <category term="스칼라" scheme="http://homoefficio.github.io/tags/%EC%8A%A4%EC%B9%BC%EB%9D%BC/"/>
    
      <category term="코틀린" scheme="http://homoefficio.github.io/tags/%EC%BD%94%ED%8B%80%EB%A6%B0/"/>
    
      <category term="클로저" scheme="http://homoefficio.github.io/tags/%ED%81%B4%EB%A1%9C%EC%A0%80/"/>
    
      <category term="러스트" scheme="http://homoefficio.github.io/tags/%EB%9F%AC%EC%8A%A4%ED%8A%B8/"/>
    
      <category term="변환" scheme="http://homoefficio.github.io/tags/%EB%B3%80%ED%99%98/"/>
    
      <category term="집계" scheme="http://homoefficio.github.io/tags/%EC%A7%91%EA%B3%84/"/>
    
      <category term="튜플" scheme="http://homoefficio.github.io/tags/%ED%8A%9C%ED%94%8C/"/>
    
      <category term="페어" scheme="http://homoefficio.github.io/tags/%ED%8E%98%EC%96%B4/"/>
    
      <category term="값으로 정렬" scheme="http://homoefficio.github.io/tags/%EA%B0%92%EC%9C%BC%EB%A1%9C-%EC%A0%95%EB%A0%AC/"/>
    
      <category term="값 기준 정렬" scheme="http://homoefficio.github.io/tags/%EA%B0%92-%EA%B8%B0%EC%A4%80-%EC%A0%95%EB%A0%AC/"/>
    
  </entry>
  
  <entry>
    <title>JPA 일대다 단방향 매핑 잘못 사용하면 벌어지는 일</title>
    <link href="http://homoefficio.github.io/2019/04/28/JPA-%EC%9D%BC%EB%8C%80%EB%8B%A4-%EB%8B%A8%EB%B0%A9%ED%96%A5-%EB%A7%A4%ED%95%91-%EC%9E%98%EB%AA%BB-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EB%B2%8C%EC%96%B4%EC%A7%80%EB%8A%94-%EC%9D%BC/"/>
    <id>http://homoefficio.github.io/2019/04/28/JPA-일대다-단방향-매핑-잘못-사용하면-벌어지는-일/</id>
    <published>2019-04-28T01:30:35.000Z</published>
    <updated>2019-05-09T13:03:14.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JPA-일대다-단방향-매핑-잘못-사용하면-벌어지는-일"><a href="#JPA-일대다-단방향-매핑-잘못-사용하면-벌어지는-일" class="headerlink" title="JPA 일대다 단방향 매핑 잘못 사용하면 벌어지는 일"></a>JPA 일대다 단방향 매핑 잘못 사용하면 벌어지는 일</h1><p><code>Parent : Child = 1 : N</code> 의 관계가 있으면 일대다 단방향으로 매핑하는 것보다 일대다 양방향으로 매핑하는 것이 좋다. 왜 그런지 구체적으로 살펴보자.</p><h1 id="조인테이블-방식의-일대다-단방향-매핑"><a href="#조인테이블-방식의-일대다-단방향-매핑" class="headerlink" title="조인테이블 방식의 일대다 단방향 매핑"></a>조인테이블 방식의 일대다 단방향 매핑</h1><p>그런데 어떤 특별한 이유가 있을 수도 있고, 그냥 별 생각없이 작성된 레거시 일 수도 있고, 아니면 JPA에 살짝 서툴러서도 있고, 여튼 다음과 같이 직관적으로 단순하게 <strong><code>@OneToMany</code>만 달랑 붙여서 매핑하면 조인테이블 방식의 일대다 단방향 방식으로 매핑된다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(cascade = CascadeType.ALL, orphanRemoval = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Child&gt; children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String name, List&lt;Child&gt; children)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.children.addAll(children);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 작성하면 조인테이블인 <code>parent_children</code>라는 테이블이 새로 생긴다. 뭐 테이블 하나 생기면 어때.. 큰일 나겠어? 라고 생각할 수도 있지만, <strong><code>children</code>이 많지 않을 때만 큰 일이 안 나고, 많으면 제법 큰 일이 난다.</strong></p><h1 id="시나리오"><a href="#시나리오" class="headerlink" title="시나리오"></a>시나리오</h1><p>위와 같이 매핑된 상태에서 다음과 같은 간단한 시나리오를 생각해보자.</p><ol><li><code>parent</code>가 10개의 Child를 포함하는 <code>children</code>을 가진다.</li><li><code>parent.children</code>에서 Child의 id가 1, 2인 것 2개만 삭제한다.</li></ol><p>1번은 뭐 처음 생성이니 <code>parent</code> 1개에 대해 <code>parent</code> 테이블에 insert 1회, <code>children</code> 10개에 대해 <code>child</code> 테이블에 insert 10회 실행된다. 그리고 조인테이블 방식으로 동작하므로 <code>parent_children</code> 테이블에도 insert 10회 실행된다.</p><p>2번에서 <code>children</code> 중에서 2개를 지우므로 <code>parent_children</code> 테이블에서 delete 2회 실행되고, <code>orphanRemoval = true</code>로 설정되어 있으므로 <code>child</code> 테이블에서 delete 2회 실행될 것이다.</p><p>하지만 직접 실행해보면 2번은 예상과 완전히 다르게 동작한다!!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>(onConstructor = @__(<span class="meta">@Autowired</span>))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneToManyRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> ParentRepository parentRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Parent parent1 = <span class="keyword">new</span> Parent(<span class="string">"parent 1"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            parent1.getChildren().add(</span><br><span class="line">                    <span class="keyword">new</span> Child(<span class="string">"child "</span> + i)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Parent dbParent = <span class="keyword">this</span>.parentRepository.saveAndFlush(parent1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*****************************"</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;Child&gt; children = dbParent.getChildren();</span><br><span class="line">        children.removeIf(child -&gt; </span><br><span class="line">                child.getId() == <span class="number">1L</span> || child.getId() == <span class="number">2L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="실행-결과"><a href="#실행-결과" class="headerlink" title="실행 결과"></a>실행 결과</h1><p><code>parent_children</code> 테이블에서 delete 2회, <code>orphanRemoval = true</code>로 설정되어 있으므로 <code>child</code> 테이블에서 delete 2회 실행될 것으로 예상했지만 실제로는,</p><ul><li><strong><code>parent.children</code> 10개 모두 delete 되면서 <code>parent_children</code> 테이블에서 <code>children_id</code>가 1, 2인 것을 제외한 8개의 레코드에 대해 모두 8회의 insert가 실행</strong>되고, </li><li>마지막에 <code>child</code> 테이블에서 2회의 delete가 실행된다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">parent</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">parent</span> <span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">2</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">3</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">4</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">5</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">6</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">7</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">8</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">9</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">10</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">2</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">3</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">4</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">5</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">6</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">7</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">8</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">9</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">10</span>]</span><br><span class="line">*****************************</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> parent_children <span class="keyword">where</span> parent_id=?  &lt;== 헉!! 형이 왜 여기서 나와!!</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">3</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">4</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">5</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">6</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">7</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">8</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">9</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> parent_children (parent_id, children_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">10</span>]</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>앞에서 <code>children</code>의 갯수가 많지 않을 때만 큰 일이 안 생긴다고 한 이유가 여기에 있다. 위의 사례에서는 <code>children</code>이 10개 밖에 되지 않으므로 insert를 10개 쯤 한다고 해도 사실 거의 티가 나지 않는다. 하지만 10개가 아니라 1000개, 10000개 그 이상이라면? <strong>고작 레코드 2개 삭제하려는 것 뿐인데 1000회, 10000회의 insert가 실행된다.</strong> ㄷㄷㄷ</p><p>그런데 왜 이렇게 동작하는 걸까?</p><h1 id="나름의-사연"><a href="#나름의-사연" class="headerlink" title="나름의 사연"></a>나름의 사연</h1><p>실행한 후 <code>parent_children</code> 테이블을 보면 다음과 같다.</p><table><thead><tr><th>parent_id</th><th>children_id</th></tr></thead><tbody><tr><td>1</td><td>3</td></tr><tr><td>1</td><td>4</td></tr><tr><td>1</td><td>5</td></tr><tr><td>1</td><td>6</td></tr><tr><td>1</td><td>7</td></tr><tr><td>1</td><td>8</td></tr><tr><td>1</td><td>9</td></tr><tr><td>1</td><td>10</td></tr></tbody></table><p>나: 뭐야, <code>1 | 1</code>인 행이랑 <code>1 | 2</code>인 행 2개만 지울 수 있었을 것 같은데, 왜 <code>parent_id</code>가 1인 걸 몽땅 지워?</p><p>Hibernate: 허허.. 그게 말이야.. 허허.. 테이블로 보기엔 저런데.. 허허.. <strong>일대다 단방향이잖아.. 허허.. 그래서.. 허허.. <code>parent_id</code>가 1이라는 것을 개별 행에 대한 조건으로 줄 수가 없어..</strong> 허허.. 그래서 <code>parent_id</code>가 1인 걸 몽땅 지우고 다시 채웠어.. 허허..</p><p>나: 뭐래냐..</p><p>이것도 말보다 코드가 더 쉽고 명확한 케이스다. id가 1, 2인 <code>child</code>를 삭제하는 코드는 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Child&gt; children = dbParent.getChildren();</span><br><span class="line">children.removeIf(child -&gt; </span><br><span class="line">        child.getId() == <span class="number">1L</span> || child.getId() == <span class="number">2L</span>);  <span class="comment">// &lt;-- 여기!!</span></span><br></pre></td></tr></table></figure><p>위에 <code>여기</code>로 표시한 부분에서 <code>parent_id</code>에 대한 조건을 줄 수가 없다. 왜냐고? 위에 Hibernate가 얘기해 준대로 <strong>일대일 단방향이라서 <code>child</code>는 <code>parent</code>를 모른다. 따라서 <code>parent_id</code>를 <code>children</code>의 개별 행에 대한 삭제 조건으로 지정할 수가 없다.</strong></p><p>대신에 <code>dbParent.getChildren()</code>의 <code>dbParent</code>에는 <code>parent_id</code>가 1이라는 정보가 있다. 그래서 <strong><code>children</code>를 개별 행 단위로 삭제할 수는 없지만 <code>parent_children</code> 테이블에서는 <code>parent_id</code>가 1인 행을 모두 삭제할 수는 있다.</strong> 그래서 <code>parent_id</code>가 1인 레코드를 모두 delete 한 후에 다시 insert를 반복하는 노가다를 한 것이다.</p><p>결국 Hibernate는 주어진 환경에서 최선을 다한 셈이고 아무 죄가 없다. 모두 delete 후 다시 모두 insert 반복으로만 해결할 수 있게 코드를 짠 사람이 잘못이다.</p><h1 id="해결"><a href="#해결" class="headerlink" title="해결"></a>해결</h1><p>이제 문제를 바로잡아보자. 조인테이블 방식의 일대다 단방향 매핑때문에 <code>children</code> 쪽에서 행 단위로 <code>parent_id</code>를 알 수 없다는 게 원인이었으므로, <strong>어떻게든 <code>children</code> 쪽에서 행 단위로 <code>parent_id</code>를 알 수 있게 해주면 된다. 즉 테이블 상에서 <code>children</code> 쪽에 <code>parent_id</code> 컬럼이 추가되도록 매핑하면 된다.</strong></p><p>방법은 두 가지가 있다. 조인테이블이 아닌 조인컬럼 방식의 일대다 단방향 매핑과 일대다 양방향 매핑이다.</p><p>먼저 조인컬럼 방식의 일대다 단방향 매핑부터 알아보자.</p><h2 id="조인컬럼-방식의-일대다-단방향-매핑"><a href="#조인컬럼-방식의-일대다-단방향-매핑" class="headerlink" title="조인컬럼 방식의 일대다 단방향 매핑"></a>조인컬럼 방식의 일대다 단방향 매핑</h2><p>이 방식은 Parent에 단 한 줄의 코드만 추가하면 된다. 물론 예제 코드에서만..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OneToMany</span>(cascade = CascadeType.ALL, orphanRemoval = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@JoinColumn</span>(name = <span class="string">"parent_id"</span>)  <span class="comment">// &lt;-- 여기!!</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Child&gt; children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>위와 같이 Parent 엔티티에 <code>@JoinColumn(name = &quot;parent_id&quot;)</code>만 추가해주면 된다.</p><p>이제 조인테이블 방식이 아니므로 <code>parent_children</code> 테이블은 필요 없고, <code>child</code> 테이블에 <code>parent_id</code> 컬럼이 추가되고, <code>child</code> 테이블의 행 단위로 <code>parent_id</code>를 알 수 있으므로 몽창 delete 후 몽창 insert 하는 노가다는 발생하지 않고 id가 1, 2인 <code>child</code>만 삭제할 수 있을 것이다.</p><p>실행해보면 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">parent</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">parent</span> <span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">2</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">3</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">4</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">5</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">6</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">7</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">8</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">9</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">10</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">2</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">3</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">4</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">5</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">6</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">7</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">8</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">9</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=? <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">10</span>]</span><br><span class="line">*****************************</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=<span class="literal">null</span> <span class="keyword">where</span> parent_id=? <span class="keyword">and</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> parent_id=<span class="literal">null</span> <span class="keyword">where</span> parent_id=? <span class="keyword">and</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">2</span>]</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>오 역시나 <code>*****</code> 아래에 10번의 불필요한 insert 가 모두 사라지고 맨 아래 delete 2회만 실행된 것을 확인할 수 있다.</p><p>그런데 <code>*****</code> 바로 위에 10번의 update는 또 왜 실행된거지?</p><p>이유는 이번에도 단방향이기 때문이다. <strong>조인컬럼 방식으로 변환하면서 <code>child</code> 테이블에 <code>parent_id</code> 컬럼이 추가되기는 했지만, 단방향이라서 <code>child</code>는 <code>parent</code>의 존재를 모르므로 <code>parent_id</code>의 값을 알 수는 없다.</strong> 뭐랄까 냉장고는 사놨는데 뭘로 채워야할지 모르는..</p><p>그래서 <strong>개별 행 단위로는 <code>parent_id</code> 컬럼에 값이 없는 채로 insert 되고, insert 된 10개의 행의 <code>parent_id</code> 컬럼에는 <code>dbParent.getChildren()</code>에서 알아낼 수 있는 <code>parent_id</code> 값을 update 를 통해 설정</strong>한다. 하지만 이건 최초에 데이터가 세팅될 때 1회만 그런거고, 이렇게 <code>parent_id</code> 값이 저장된 후에는 삭제를 원하는 레코드만 삭제할 수 있게 되므로 조인테이블 방식의 문제는 해결했다고 볼 수 있다.</p><p>이제 <code>*****</code> 아래에 실행된 쿼리를 살펴보자. update가 2회, delete가 2회 실행됐다. delete 2회만 실행되기를 예상했지만 update 2회가 먼저 실행됐다. 이 부분은 자세히 살펴볼 필요가 있다.</p><p><strong>신동민 님의 도움</strong>으로 정확히 알게 되었는데, 일대다 조인컬럼 방식에서 <code>children.remove(child)</code>를 실행해서 <code>children</code> 쪽의 레코드 삭제를 시도하면 실제 쿼리는 delete가 아니라 해당 레코드의 <code>parent_id</code>에 null을 저장하는 update가 실행된다. 의도와 다르게 동작한 것 같아서 이상해보이지만, 일대다 단방향 매핑에서 <strong><code>children.remove(child)</code>는 사실 <code>child</code> 자체를 삭제하라는 게 아니라 <code>child</code>가 <code>parent</code>의 <code>children</code>의 하나로 존재하는 관계를 remove 하라는 것이다. 따라서 <code>child</code> 자체를 delete 하는 게 아니라 <code>parent_id</code>에 null 값을 넣는 update를 실행하는 게 정확히 맞다.</strong> 이 부분의 코드도 신동민 님이 알려주셨는데 <a href="https://github.com/hibernate/hibernate-orm/blob/master/hibernate-core/src/main/java/org/hibernate/persister/collection/OneToManyPersister.java" target="_blank" rel="noopener">여기</a>에서 확인할 수 있다. </p><p>결국 이번에도 Hibernate는 정확히 동작한다. 관계의 remove를 레코드의 delete로 넘겨짚은 사람이 문제지..</p><p><strong>그럼 마지막에 실행된 2회의 delete는 뭘까? 이건 <code>orphanRemoval = true</code>로 설정되어 있기 때문에 2개의 <code>child</code> 자체를 delete 한 것</strong>이다.</p><p>그런데 사실 Hibernate가 어찌 동작하든 간에, 데이터 처리 관점에서 보자면 원했던 것은 2개의 레코드를 delete 하는 것이었는데, 2회의 update와 2회의 delete가 실행되는 것은 여전히 불필요한 작업이 추가된 것 같다. 하지만 <strong>이를 불필요한 오버헤드라고 부르는 것은 적합하지 않아 보인다.</strong> </p><p><strong>RDB 관점에서 보면 테이블 사이의 관계는 언제나 양방향이지만 JPA의 엔티티 사이의 관계는 단방향과 양방향이 분명히 다르다.</strong> 따라서 RDB 관점에서야 이걸 오버헤드라고 부를 수도 있겠지만, <strong>단방향으로 매핑된 JPA에서는 레코드의 delete가 아니라 관계의 remove로 동작하는 것이 정확하고 따라서 delete가 아니라 update로 실행되는 것이 맞으므로 불필요한 오버헤드라고 부르는 것은 적합하지 않다.</strong></p><p>그래도 여전히 2회의 delete만으로 끝날 일을 2회의 update와 <code>orphanRemoval</code>을 동원해서 2회의 delete로 실행하는 것이 마음에 안 든다면, <strong>RDB 처럼 양방향으로 만들어 주면 JPA도 RDB 처럼 2회의 delete만으로 끝낸다.</strong> 그럼 이제 일대다 양방향 매핑을 살펴보자.</p><p>그 전에, 앞에서 조인커럼 방식으로의 전환을 단 한 줄로 적용가능 한 것은 예제 코드라서 가능하다고 했는데, 구체적으로 말하면 <code>*****</code> 위에서 update로 값을 자동 세팅해주는 것도 예제 코드라서, <strong><code>spring.jpa.properties.hibernate.hbm2ddl.auto</code> 옵션을 <code>create</code> 등 마음대로 줄 수 있기 때문에 가능한 것이고, 실 운영 환경에서는 저렇게 수행할 수 없다.</strong></p><p>운영 환경에서는 <code>child</code> 테이블에 <code>parent_id</code> 컬럼도 직접 추가해줘야 하고 다음과 같이 update 쿼리를 만들어서 <strong>기존에 <code>parent_children</code> 테이블에 있던 값을 기준으로 <code>child</code> 테이블의 <code>parent_id</code> 컬럼에 수동으로 입력해줘야 한다.</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> a</span><br><span class="line"><span class="keyword">set</span> a.parent_id = (</span><br><span class="line">    <span class="keyword">select</span> b.parent_id </span><br><span class="line">    <span class="keyword">from</span> parent_children b</span><br><span class="line">    <span class="keyword">where</span> a.id = b.children_id</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="일대다-양방향-매핑"><a href="#일대다-양방향-매핑" class="headerlink" title="일대다 양방향 매핑"></a>일대다 양방향 매핑</h2><p>앞에서 살펴본 것처럼 RDB와 똑같이 동작하기를 원한다면 JPA에서도 양방향으로 매핑을 해줘야 한다. 조인컬럼 방식으로 전환할 때보다는 조금 손이 더 가지만 작업량은 그리 많지 않다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mappedBy 추가</span></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"parent"</span>, cascade = CascadeType.ALL, orphanRemoval = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Child&gt; children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String name, List&lt;Child&gt; children)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.children.addAll(children);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent 필드 추가</span></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"parent_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Parent parent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생성자에 Parent 추가</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String name, Parent parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>(onConstructor = @__(<span class="meta">@Autowired</span>))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneToManyRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> ParentRepository parentRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Parent parent1 = <span class="keyword">new</span> Parent(<span class="string">"parent 1"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            parent1.getChildren().add(</span><br><span class="line">                    <span class="keyword">new</span> Child(<span class="string">"child "</span> + i, parent1)  <span class="comment">// 생성 시 parent1 추가</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        Parent dbParent = <span class="keyword">this</span>.parentRepository.saveAndFlush(parent1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*****************************"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Child&gt; children = dbParent.getChildren();</span><br><span class="line">        children.removeIf(child -&gt; </span><br><span class="line">                child.getId() == <span class="number">1L</span> || child.getId() == <span class="number">2L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실행 결과는 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">parent</span> (<span class="keyword">name</span>) <span class="keyword">values</span> (?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">parent</span> <span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">1</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">2</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">3</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">4</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">5</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">6</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">7</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">8</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">9</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">child</span> (<span class="keyword">name</span>, parent_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">VARCHAR</span>] - [<span class="keyword">child</span> <span class="number">10</span>]</span><br><span class="line">binding parameter [<span class="number">2</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line">*****************************</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br><span class="line">binding parameter [<span class="number">1</span>] <span class="keyword">as</span> [<span class="built_in">BIGINT</span>] - [<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>오! 처음에 원했던 그대로 delete 만 2회 실행될 뿐 아무런 오버헤드도 발생하지 않는다!</p><p><strong>일대다 양방향 매핑과 일대다 단방향 조인컬럼 매핑의 결과로 나타나는 테이블 구조는 두 방식에서 모두 동일</strong>하다. <strong>두 방식 모두 <code>child</code>에 <code>parent_id</code> FK 컬럼</strong>을 두게 된다. </p><p>일대다 양방향 매핑과 일대다 단방향 조인컬럼 매핑의 차이점은 다음과 같다.</p><ul><li>조인컬럼 일대다 단방향 매핑은 <code>child</code>가 <code>parent</code>를 모르기 때문에, 앞에서 설명한 것처럼 1회성이긴 하지만 <code>parent_id</code> 값을 저장하기 위해 update 오버헤드가 발생한다.</li><li>일대다 양방향 매핑은 <code>child</code>가 <code>parent</code>를 알기 때문에 불필요한 오버헤드가 발생하지 않는다.</li></ul><p>다만 <strong>일대다 양방향 매핑은 도메인 로직 상에서 <code>parent</code>를 몰라도 되는 <code>child</code>에게 굳이 <code>parent</code>를 강제로 알게 만드는 것이 단점</strong>인데, 이 단점은 <strong><code>parent</code>에 대한 public getter 메서드를 만들지 않거나 또는 극단적으로 아예 <code>parent</code>에 대한 getter 메서드를 만들지 않는 방식으로 보완할 수 있다.</strong></p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><blockquote><p>일대다 단방향 매핑은 직관적으로는 단순해서 좋지만,<br>조인테이블 방식은 insert가, 조인컬럼 방식은 1회성이긴 하지만 update가 오버헤드로 작용한다.</p><p>따라서 1:N에서 N이 큰 상황에서는,</p><ul><li>오버헤드가 없는 일대다 양방향 매핑을 사용하는 것이 가장 좋고,  </li><li>그 다음은 일대다 단방향 조인컬럼 방식,  </li><li>그리고 parent 쪽에 <code>@OneToMany</code>만 달랑 붙이는 일대다 단방향 조인테이블 방식은 사용하지 않는 것이 좋다.</li></ul><p>더 축약하자면, <strong>1:N에서 N이 클 때는 웬만하면 일대다 양방향 매핑을 사용하자.</strong></p></blockquote><h1 id="부록-응용편"><a href="#부록-응용편" class="headerlink" title="부록 - 응용편"></a>부록 - 응용편</h1><p>다음과 같이 하나의 Parent에서 2개의 Child에 대해 1:1, 1:N 연관관계 매핑이 필요하면 어떻게 할까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 이게 추가된다면?</span></span><br><span class="line">    <span class="keyword">private</span> Child singleChild;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(cascade = CascadeType.ALL, orphanRemoval = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Child&gt; children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String name, Child singleChild)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.singleChild = singleChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String name, Child singleChild, List&lt;Child&gt; children)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.singleChild = singleChild;</span><br><span class="line">        <span class="keyword">this</span>.children.addAll(children);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 경우에는 일대일 단방향 매핑을 위해 다음과 같이 Parent 에 <code>@JoinColumn</code>을 지정해서 Child를 위한 FK 컬럼을 추가하면, 일대일 단방향 + 일대다 양방향을 함께 쓸 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이게 추가된다면?</span></span><br><span class="line"><span class="comment">//// 일대일 단방향을 쓰되 Child를 가리키는 FK 컬럼을 Parent에 둔다</span></span><br><span class="line"><span class="meta">@OneToOne</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name = <span class="string">"single_child_id"</span>)</span><br><span class="line"><span class="keyword">private</span> Child singleChild;</span><br></pre></td></tr></table></figure><p>그럼 <code>parent</code> 테이블은 다음과 같이 되고,</p><p><code>id | name | single_child_id</code></p><p><code>child</code> 테이블은 다음과 같이 되고, <code>single_child</code>와 <code>children</code>에 해당하는 데이터가 모두 <code>child</code> 테이블에 저장된다.</p><p><code>id | name | parent_id</code></p><p>그런데 이렇게 한 테이블에 저장되면 혼동이 될 수도 있을 것 같아 걱정이 된다.</p><p>하지만, <strong>일대일 단방향에 의해 저장된 레코드에만 <code>parent_id</code> 값이 <code>NULL</code>인 상태가 되고,</strong><br><strong>일대다 양방향에 의해 저장된 레코드에는 <code>parent_id</code>에 정상적인 값이 들어가므로 구분 가능</strong>하며 혼동 없이 사용할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JPA-일대다-단방향-매핑-잘못-사용하면-벌어지는-일&quot;&gt;&lt;a href=&quot;#JPA-일대다-단방향-매핑-잘못-사용하면-벌어지는-일&quot; class=&quot;headerlink&quot; title=&quot;JPA 일대다 단방향 매핑 잘못 사용하면 벌어지는 일&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="JPA" scheme="http://homoefficio.github.io/tags/JPA/"/>
    
      <category term="Spring Data JPA" scheme="http://homoefficio.github.io/tags/Spring-Data-JPA/"/>
    
      <category term="Java Persistence API" scheme="http://homoefficio.github.io/tags/Java-Persistence-API/"/>
    
      <category term="ORM" scheme="http://homoefficio.github.io/tags/ORM/"/>
    
      <category term="Object Relation Mapping" scheme="http://homoefficio.github.io/tags/Object-Relation-Mapping/"/>
    
      <category term="Hibernate" scheme="http://homoefficio.github.io/tags/Hibernate/"/>
    
      <category term="하이버네이트" scheme="http://homoefficio.github.io/tags/%ED%95%98%EC%9D%B4%EB%B2%84%EB%84%A4%EC%9D%B4%ED%8A%B8/"/>
    
      <category term="1:N" scheme="http://homoefficio.github.io/tags/1-N/"/>
    
      <category term="OneToMany" scheme="http://homoefficio.github.io/tags/OneToMany/"/>
    
      <category term="ManyToOne" scheme="http://homoefficio.github.io/tags/ManyToOne/"/>
    
      <category term="일대다" scheme="http://homoefficio.github.io/tags/%EC%9D%BC%EB%8C%80%EB%8B%A4/"/>
    
      <category term="unidirectional" scheme="http://homoefficio.github.io/tags/unidirectional/"/>
    
      <category term="단방향" scheme="http://homoefficio.github.io/tags/%EB%8B%A8%EB%B0%A9%ED%96%A5/"/>
    
      <category term="bidirectional" scheme="http://homoefficio.github.io/tags/bidirectional/"/>
    
      <category term="양방향" scheme="http://homoefficio.github.io/tags/%EC%96%91%EB%B0%A9%ED%96%A5/"/>
    
      <category term="association" scheme="http://homoefficio.github.io/tags/association/"/>
    
      <category term="연관관계" scheme="http://homoefficio.github.io/tags/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"/>
    
      <category term="매핑" scheme="http://homoefficio.github.io/tags/%EB%A7%A4%ED%95%91/"/>
    
      <category term="엔티티" scheme="http://homoefficio.github.io/tags/%EC%97%94%ED%8B%B0%ED%8B%B0/"/>
    
      <category term="Entity" scheme="http://homoefficio.github.io/tags/Entity/"/>
    
      <category term="JoinColumn" scheme="http://homoefficio.github.io/tags/JoinColumn/"/>
    
      <category term="JoinTable" scheme="http://homoefficio.github.io/tags/JoinTable/"/>
    
      <category term="mappedBy" scheme="http://homoefficio.github.io/tags/mappedBy/"/>
    
      <category term="cascade" scheme="http://homoefficio.github.io/tags/cascade/"/>
    
      <category term="orphanRemoval" scheme="http://homoefficio.github.io/tags/orphanRemoval/"/>
    
      <category term="스프링 데이터 JPA" scheme="http://homoefficio.github.io/tags/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-JPA/"/>
    
      <category term="Overhead" scheme="http://homoefficio.github.io/tags/Overhead/"/>
    
      <category term="오버헤드" scheme="http://homoefficio.github.io/tags/%EC%98%A4%EB%B2%84%ED%97%A4%EB%93%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO Direct Buffer를 이용해서 대용량 파일 행 기준으로 쪼개기</title>
    <link href="http://homoefficio.github.io/2019/02/27/Java-NIO-Direct-Buffer%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C-%EB%8C%80%EC%9A%A9%EB%9F%89-%ED%8C%8C%EC%9D%BC-%ED%96%89-%EA%B8%B0%EC%A4%80%EC%9C%BC%EB%A1%9C-%EC%AA%BC%EA%B0%9C%EA%B8%B0/"/>
    <id>http://homoefficio.github.io/2019/02/27/Java-NIO-Direct-Buffer를-이용해서-대용량-파일-행-기준으로-쪼개기/</id>
    <published>2019-02-26T15:23:43.000Z</published>
    <updated>2019-04-28T17:03:55.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-NIO-Direct-Buffer를-이용해서-대용량-파일-행-기준으로-쪼개기"><a href="#Java-NIO-Direct-Buffer를-이용해서-대용량-파일-행-기준으로-쪼개기" class="headerlink" title="Java NIO Direct Buffer를 이용해서 대용량 파일 행 기준으로 쪼개기"></a>Java NIO Direct Buffer를 이용해서 대용량 파일 행 기준으로 쪼개기</h1><p>기가 단위의 파일을 외부에 전송할 일이 생겼다. </p><p>한 방에 보내기엔 너무 커서 파일을 쪼개서(split) 보내려고 하는데, 그마저도 쉽지 않다. 쪼개기 위해 대용량 파일을 읽을 때 이미 수십분 동안 CPU를 너무 잡아 먹어서 이 쪼개는 배치 작업을 스케줄링하는 스케줄러(Quartz)에 문제를 일으킨다.</p><p>DMA(Direct Memory Access)를 사용하는 것이 좋겠다.</p><h1 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h1><p><img src="https://i.imgur.com/LNHHp8h.png" alt="Imgur"></p><p>(그림 출처: <a href="https://howtodoinjava.com/java/io/how-java-io-works-internally-at-lower-level/" target="_blank" rel="noopener">https://howtodoinjava.com/java/io/how-java-io-works-internally-at-lower-level/</a>)</p><p>디스크 컨트롤러는 DMA를 통해 CPU를 건드리지 않고 직접 운영체제 메모리에 접근할 수 있고, 응용 프로그램은 Direct Buffer를 활용해서 JVM 메모리가 아닌 운영체제 메모리에 직접 접근할 수 있다.</p><p>장점은 다음과 같다.</p><ol><li>디스크에 있는 파일을 운영체제 메모리로 읽어들일 때 CPU를 건드리지 않는다.</li><li>운영체제 메모리에 있는 파일 내용을 JVM 내 메모리로 다시 복사할 필요가 없다.</li><li>JVM 내 힙 메모리를 쓰지 않으므로 GC를 유발하지 않는다.(물론 일정 크기를 가진 버퍼가 운영체제 메모리에 생성되는 것이고, 이 버퍼에 대한 참조 자체는 JVM 메모리 내에 생성된다)</li></ol><p>단점은 다음과 같다.</p><ol><li>DMA에 사용할 버퍼 생성 시 시간이 더 소요될 수 있다.</li><li>바이트 단위로 데이터를 취급하므로, <strong>데이터를 행 단위로 취급하기 불편하다.</strong></li></ol><p>Aㅏ.. 파일 쪼개기 할 때 행 기준으로 쪼개야 하는데.. 일단 불편한 것일 뿐 아예 안 되는 것은 아니므로 시도해보자.</p><p>종합해보면 <strong>파일의 크기가 대단히 클 때 DMA의 장점을 누릴 수 있고 단점을 피할 수 있다.</strong></p><h1 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h1><p>Java 1.4 부터 도입된 NIO에 <code>FileChannel</code>이 포함되어 있는데, <code>ByteBuffer</code>를 통해 File I/O를 수행할 수 있다.</p><p>대략 다음과 같은 방식으로 사용할 수 있다.</p><h2 id="파일-읽기-용-FileChannel"><a href="#파일-읽기-용-FileChannel" class="headerlink" title="파일 읽기 용 FileChannel"></a>파일 읽기 용 FileChannel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileChannel srcFileChannel = Files.open(Paths.get(<span class="string">"/home/homo-efficio/tmp/LargeFile"</span>), StandardOpenOption.READ);</span><br></pre></td></tr></table></figure><h2 id="파일-쓰기-용-FileChannel"><a href="#파일-쓰기-용-FileChannel" class="headerlink" title="파일 쓰기 용 FileChannel"></a>파일 쓰기 용 FileChannel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileChannel destFileChannel = Files.open(Paths.get(<span class="string">"/home/homo-efficio/tmp/LargeFile"</span>), StandardOpenOption.WRITE);</span><br></pre></td></tr></table></figure><p><code>Path</code> 말고 <code>RandomAccessFile</code>을 활용하는 방법도 있고, 파일 열기 모드에도 <code>TRUNCATE_EXIST</code>, <code>CREATE</code>, <code>CREATE_NEW</code> 등 여러가지가 있고 혼합해서 사용할 수 있다.</p><h1 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h1><p>실제 데이터를 담는 바이트 버퍼 클래스로서 JVM 힙을 사용하는 일반(Non-Direct) 버퍼와 운영체제 메모리에 직접 접근할 수 있는 Direct Buffer를 생성할 수 있다. Direct Buffer는 다음과 같이 간단하게 생성할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">100</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>버퍼가 Direct 인지 아닌지 <code>buffer.isDirect()</code>를 통해 판별할 수도 있다.</p><h2 id="위치-관련-속성"><a href="#위치-관련-속성" class="headerlink" title="위치 관련 속성"></a>위치 관련 속성</h2><h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>버퍼 내에서 값을 읽거나 쓸 수 있는 <strong>시작 위치</strong>를 나타낸다. 버퍼 내로 1 바이트의 데이터가 추가될 때마다 <code>position</code> 값도 1 증가한다.</p><p><code>buffer.position()</code>, <code>buffer.position(int)</code></p><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>버퍼 내에서 값을 읽거나 쓸 수 있는 <strong>끝 위치</strong>를 나타낸다. <code>limit - 1</code> 위치까지의 데이터가 읽거나 써진다.</p><p><code>buffer.limit()</code>, <code>buffer.limit(int)</code></p><h3 id="mark"><a href="#mark" class="headerlink" title="mark"></a>mark</h3><p>현재 <code>position</code> 위치에 <strong>표시</strong>를 해두고, 나중에 <code>reset()</code>을 호출하면 표시해둔 위치로 <code>position</code>이 이동한다.</p><p><code>buffer.mark()</code></p><h3 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h3><p>버퍼의 용량(담을 수 있는 데이터의 크기)를 나타내며, 버퍼 생성 시 <code>ByteBuffer.allocate(capacity)</code> 나 <code>ByteBuffer.allocateDirect(capacity)</code> 로 지정할 수 있다.</p><p><code>buffer.capacity()</code></p><h2 id="위치-관련-메서드"><a href="#위치-관련-메서드" class="headerlink" title="위치 관련 메서드"></a>위치 관련 메서드</h2><h3 id="flip"><a href="#flip" class="headerlink" title="flip()"></a>flip()</h3><p><code>position</code>을 0으로, <code>limit</code>을 읽어들인 데이터의 마지막 바이트+1 위치로 세팅한다. </p><p>버퍼에 있는 데이터를 처음부터 모두 읽을 때 사용한다.</p><h3 id="rewind"><a href="#rewind" class="headerlink" title="rewind()"></a>rewind()</h3><p><code>position</code>을 0으로, <code>limit</code>은 현재 그대로 유지한다.</p><p>버퍼에 있는 데이터를 처음부터 현재 <code>limit</code> 위치 바로 앞까지 읽을 때 사용한다.</p><h3 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h3><p><code>position</code>을 <code>mark</code> 위치로 세팅한다.</p><h3 id="compact"><a href="#compact" class="headerlink" title="compact()"></a>compact()</h3><p>현재 <code>position</code>부터 <code>limit - 1</code> 까지의 데이터를 버퍼의 맨 앞으로 복사한 후에, <code>position</code>을 복사한 데이터 바로 다음 위치로 이동시키고, <code>limit</code>는 <code>capacity</code>로 이동한다. 행 기준으로 데이터를 다룰 때 핵심 역할을 담당한다. </p><h2 id="읽고-쓰는-값-관련-메서드"><a href="#읽고-쓰는-값-관련-메서드" class="headerlink" title="읽고 쓰는 값 관련 메서드"></a>읽고 쓰는 값 관련 메서드</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>position</code> 에 있는 값을 읽어서 반환한다.</p><h3 id="put-byte"><a href="#put-byte" class="headerlink" title="put(byte)"></a>put(byte)</h3><p><code>byte</code>를 <code>position</code> 위치에 쓴다.</p><h1 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h1><p>Direct Buffer를 생성하는 것 자체는 그저 전용 메서드 하나 호출하는 것밖에 없어 단순하다. 다만, 줄 바꿈 처리에 좀 신경을 써야 한다.</p><p>대용량 파일 대상이므로 행의 크기 보다 버퍼 크기가 크다고 가정했다. 버퍼가 작을 때도 적용되도록 구현할 수는 있겠지만 불필요하게 로직만 복잡해지므로 이 때는 그냥 예외를 던지게 했다.</p><p>쉽게 요약하면,</p><ol><li>파일에서 버퍼만큼 읽어들인 후,</li><li>버퍼에서 LF가 나올 때까지 1 바이트씩 뒤로 이동,</li><li>LF가 나오면(0 ~ position 내의 마지막 LF) 버퍼의 시작부터 position 위치 내의 마지막 LF까지를 target 파일에 쓰고,</li><li>마지막 LF 뒤에서 버퍼 끝까지의 내용을 <code>compact()</code> 메서드를 이용해서 버퍼의 시작 위치로 복사하고,</li><li>그 이후의 내용은 다시 1번으로 돌아가서 버퍼에 읽어들이면서 반복</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">splitFileIntoDir</span><span class="params">(String srcFilePath,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    String destDirPath,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    String splittedFileNameFormat,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    String header,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    ByteBuffer buffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span> LINE_FEED = <span class="number">0x0A</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span> CARRIAGE_RETURN = <span class="number">0x0D</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fileCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> totalReadBytes = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">long</span> totalWriteBytes = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">long</span> readBytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Path path = Paths.get(srcFilePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="keyword">final</span> FileChannel srcFileChannel = FileChannel.open(path, StandardOpenOption.READ)) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((readBytes = srcFileChannel.read(buffer)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            totalReadBytes += readBytes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> contentLength = buffer.position();</span><br><span class="line">            <span class="keyword">int</span> newLinePosition = buffer.position();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> (<span class="keyword">final</span> FileChannel splittedFileChannel =</span><br><span class="line">                         FileChannel.open(Paths.get(destDirPath, String.format(splittedFileNameFormat, ++fileCounter)),</span><br><span class="line">                                 StandardOpenOption.TRUNCATE_EXISTING,</span><br><span class="line">                                 StandardOpenOption.CREATE,</span><br><span class="line">                                 StandardOpenOption.WRITE)) &#123;</span><br><span class="line">                writeHeader(header, readBytes, splittedFileChannel);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> hasLineFeed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">boolean</span> needCompact = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">while</span> (newLinePosition &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (buffer.get(--newLinePosition) == LINE_FEED) &#123;  <span class="comment">// 1 byte 씩 뒤로 가면서 줄바꿈 탐색</span></span><br><span class="line">                        <span class="keyword">if</span> (newLinePosition + <span class="number">1</span> == buffer.capacity()) &#123;  <span class="comment">// 버퍼 끝에 줄바꿈이 있으면 compact 불필요</span></span><br><span class="line">                            needCompact = <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        buffer.position(<span class="number">0</span>);  <span class="comment">// buffer의 처음부터</span></span><br><span class="line">                        buffer.limit(++newLinePosition);  <span class="comment">// LINE_FEED 까지 포함해서 write 되도록 limit 조정</span></span><br><span class="line">                        <span class="comment">// 버퍼의 [0, limit)의 내용을 splittedFileChannel이 바인딩된 파일에 write</span></span><br><span class="line">                        totalWriteBytes += splittedFileChannel.write(buffer);</span><br><span class="line">                        splittedFileChannel.close();</span><br><span class="line">                        hasLineFeed = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!hasLineFeed) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"버퍼 안에 줄바꿈이 없습니다. 버퍼 크기는 한 행의 길이보다 커야 합니다."</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (needCompact) &#123;</span><br><span class="line">                    <span class="comment">// compact()를 위해 원래 읽었던 내용의 마지막 바이트 위치+1(==contentLength) 로 limit 설정</span></span><br><span class="line">                    buffer.limit(contentLength);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 버퍼의 [position, limit) 의 내용을 [0, limit - position) 으로 복사</span></span><br><span class="line">                    buffer.compact();</span><br><span class="line">                    <span class="comment">// 복사 후 position은 limit에 위치하며 다음에 파일에서 읽어오는 내용이 position 부터 이어짐</span></span><br><span class="line">                    <span class="comment">// limit는 capacity로 이동</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// compact()가 필요없다면 파일을 읽어서 버퍼의 처음 위치부터 저장하도록 초기화</span></span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"File Split 도중 예외 발생"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Total Read  Bytes: "</span> + totalReadBytes);</span><br><span class="line">    System.out.println(<span class="string">"Total Write Bytes: "</span> + totalWriteBytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeHeader</span><span class="params">(String header, <span class="keyword">long</span> readBytes, FileChannel splittedFileChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (readBytes &gt; <span class="number">0</span> &amp;&amp; !StringUtils.isEmpty(header)) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] headerBytes = (header + System.lineSeparator()).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        splittedFileChannel.write(ByteBuffer.wrap(headerBytes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="친절한-그림"><a href="#친절한-그림" class="headerlink" title="친절한 그림"></a>친절한 그림</h2><p>아무래도 그림으로 안 남겨놓으면 까먹은 후에 다시 봐도 이해가 안 될까봐..</p><p><img src="https://i.imgur.com/cYyw6I8.png" alt="Imgur"></p><p><img src="https://i.imgur.com/HNfdlTe.png" alt="Imgur"></p><p><img src="https://i.imgur.com/Nvllq5N.png" alt="Imgur"></p><p><img src="https://i.imgur.com/o8NvA8H.png" alt="Imgur"></p><p><img src="https://i.imgur.com/wSxPPi9.png" alt="Imgur"></p><p><img src="https://i.imgur.com/4VSL4vQ.png" alt="Imgur"></p><p><img src="https://i.imgur.com/nU1371g.png" alt="Imgur"></p><p><img src="https://i.imgur.com/8RSW7Me.png" alt="Imgur"></p><p><img src="https://i.imgur.com/QspJzSw.png" alt="Imgur"></p><p><img src="https://i.imgur.com/o8eFQ94.png" alt="Imgur"></p><p><img src="https://i.imgur.com/1oydbLu.png" alt="Imgur"></p><p><img src="https://i.imgur.com/i5LSNpn.png" alt="Imgur"></p><h1 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h1><p>한 행 당 70바이트 이내, 4,096,000행, 263MB 짜리 csv 파일을 1M, 10M, 50M, 100M 버퍼 크기 단위로 쪼개서 비교해 본 결과는 다음과 같다.</p><h2 id="수행-시간-비교"><a href="#수행-시간-비교" class="headerlink" title="수행 시간 비교"></a>수행 시간 비교</h2><p>버퍼 크기를 1M, 10M, 50M, 100M 를 한 사이클로 해서 2 사이클을 실행해서 수행 시간(초)을 비교해 본 결과,<br>전반적으로 Direct Buffer는 일반 Buffer보다 약 10% 정도 빠르고,<br>Direct Buffer는 readLine() 방식보다 적게는 약 2배, 많게는 약 5배 정도 빠르다.</p><table><thead><tr><th>버퍼 크기</th><th>회차</th><th>Direct Buffer</th><th>Buffer</th><th>readLine</th></tr></thead><tbody><tr><td>1M</td><td>1</td><td>1.62</td><td>1.87</td><td>3.85</td></tr><tr><td>1M</td><td>2</td><td>1.39</td><td>1.52</td><td>3.47</td></tr><tr><td>10M</td><td>1</td><td>0.46</td><td>0.52</td><td>2.41</td></tr><tr><td>10M</td><td>2</td><td>0.33</td><td>0.47</td><td>2.37</td></tr><tr><td>50M</td><td>1</td><td>1.23</td><td>2.65</td><td>2.33</td></tr><tr><td>50M</td><td>2</td><td>1.12</td><td>1.34</td><td>2.32</td></tr><tr><td>100M</td><td>1</td><td>1.37</td><td>1.51</td><td>2.42</td></tr><tr><td>100M</td><td>2</td><td>1.40</td><td>1.46</td><td>2.32</td></tr></tbody></table><p>FileChannel과 버퍼를 사용하는 방식은 버퍼 크기가 10M 일 때 다른 크기일 때에 비해 약 3 ~ 4배 정도 빨라지는 것이 특이하다.</p><h2 id="CPU-메모리-사용량-비교"><a href="#CPU-메모리-사용량-비교" class="headerlink" title="CPU, 메모리 사용량 비교"></a>CPU, 메모리 사용량 비교</h2><p>Direct Buffer, Buffer, readLine() 방식을 순서대로 실행해서 VisualVM으로 측정했다. 그래프에 표시된 것도 맨 왼쪽부터 Direct Buffer, Buffer, readLine() 방식이다.</p><p>예상대로 Direct Buffer는 JVM 메모리를 사용하지 않고 운영체제 메모리에 직접 접근하므로 JVM의 힙 메모리 사용량은 거의 없다. 물론 JVM 관점에서나 힙을 쓰지 않기 때문에 사용량이 적어 보이는 것이고, 운영체제 관점에서는 여전히 버퍼 크기 만큼의 메모리를 더 사용한다.<br>일반 Buffer는 버퍼 크기에 따라 JVM 힙 메모리 사용량도 비례해서 커지며,<br>readLine()은 1M, 10M, 50M 단위로 파일을 쪼개더라도 JVM 힙 메모리 사용량은 100M를 넘나든다.</p><p>CPU는 Direct Buffer와 Buffer는 아주 큰 차이는 없이 모두 10% 이내다. readLine()에 비해 약 1/3 정도에 불과할 정도로 절감 효과가 크지만, readLine() 방식도 30%에 미치지 않은 걸 보면 역시 263MB 짜리 파일은 Direct Buffer 효과가 두드러질 정도로 큰 파일은 아니라고 볼 수 있다.</p><h3 id="1M-버퍼-1M-단위로-자르기"><a href="#1M-버퍼-1M-단위로-자르기" class="headerlink" title="1M 버퍼, 1M 단위로 자르기"></a>1M 버퍼, 1M 단위로 자르기</h3><p><img src="https://i.imgur.com/6BET1z3.png" alt="Imgur"></p><p><img src="https://i.imgur.com/7dkgJCg.png" alt="Imgur"></p><h3 id="10M-버퍼-10M-단위로-자르기"><a href="#10M-버퍼-10M-단위로-자르기" class="headerlink" title="10M 버퍼, 10M 단위로 자르기"></a>10M 버퍼, 10M 단위로 자르기</h3><p><img src="https://i.imgur.com/wdWRADA.png" alt="Imgur"></p><p><img src="https://i.imgur.com/sdaNr3t.png" alt="Imgur"></p><h3 id="50M-버퍼-50M-단위로-자르기"><a href="#50M-버퍼-50M-단위로-자르기" class="headerlink" title="50M 버퍼, 50M 단위로 자르기"></a>50M 버퍼, 50M 단위로 자르기</h3><p><img src="https://i.imgur.com/G14IWFv.png" alt="Imgur"></p><p><img src="https://i.imgur.com/kEmfUja.png" alt="Imgur"></p><h3 id="100M-버퍼-100M-단위로-자르기"><a href="#100M-버퍼-100M-단위로-자르기" class="headerlink" title="100M 버퍼, 100M 단위로 자르기"></a>100M 버퍼, 100M 단위로 자르기</h3><p><img src="https://i.imgur.com/axhhB1Z.png" alt="Imgur"></p><p><img src="https://i.imgur.com/gJAbo3g.png" alt="Imgur"></p><h1 id="그런데-메모리-해제는"><a href="#그런데-메모리-해제는" class="headerlink" title="그런데 메모리 해제는?"></a>그런데 메모리 해제는?</h1><p>Direct Buffer는 JVM 힙이 아니라 운영체제 메모리를 사용하므로 GC를 유발하지 않는다고 했는데, GC를 유발하지 않는다고 마냥 좋아할 것이 아니다. GC가 안 되면 메모리 해제는 어떻게 이루어지는지 걱정해보는 센스가 필요하다.</p><p>아쉽게도 Java API 문서에는 Direct Buffer 로 사용한 메모리 해제 관련한 내용이 기술되어 있지 않다. 검색을 해보니 그나마 가장 있어보이는 질의응답은 <a href="https://stackoverflow.com/questions/36077641/java-when-does-direct-buffer-released" target="_blank" rel="noopener">https://stackoverflow.com/questions/36077641/java-when-does-direct-buffer-released</a> 여기에 있다. 공식 문서 내용은 아니므로 이게 정말 답인지는 알 수 없다.</p><p>요는 운영체제 메모리에 생성된 Direct Buffer 를 가리키는 참조는 JVM 메모리 내에 생성되는데, 이 참조가 GC가 되면 일반적인 GC 스레드가 아닌 다른 특정 스레드에 의해 버퍼 메모리가 해제된다고 한다.</p><p><code>DirectByteBuffer.Deallocator</code>에 대한 얘기가 나오는데 Java API 문서에는 없는 클래스지만, IntelliJ에서 클래스 검색을 해보면 나오긴 한다.</p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><blockquote><p>읽을 소스 파일이 기가 단위로 매우 크면 BufferedReader.readLine()은 CPU와 메모리를 엄청 잡아먹는다.</p><p>이 때 Java NIO의 FileChannel과 Direct Buffer를 활용하면 자원 사용량을 줄일 수 있다.</p><p>Buffer를 사용하면 자원 사용량과 속도 관점에서는 좋지만 행 기준으로 데이터를 처리하는데 불편함이 있다.</p><p>Buffer가 제공하는 메서드(position, mark, limit, flip, reset, rewind, compact)를 잘 활용하면 행 기준 처리도 가능하다.</p><p>Direct Buffer 를 가리키는 참조가 GC되면 운영체제 메모리에 생성된 Direct Buffer도 해제된다고 한다.(공식 API에 있는 내용은 아님)</p></blockquote><h2 id="읽을거리"><a href="#읽을거리" class="headerlink" title="읽을거리"></a>읽을거리</h2><ul><li><p>Java I/O를 Low Level에서 아주 잘 설명한 글: <a href="https://howtodoinjava.com/java/io/how-java-io-works-internally-at-lower-level/" target="_blank" rel="noopener">https://howtodoinjava.com/java/io/how-java-io-works-internally-at-lower-level/</a></p></li><li><p>Buffer의 사용법을 그림과 함께 아주 잘 설명한 글: <a href="https://palpit.tistory.com/641" target="_blank" rel="noopener">https://palpit.tistory.com/641</a></p></li><li><p>NIO2에 도입된 AsynchronousFileChannel 관련 글: <a href="https://homoefficio.github.io/2016/08/13/대용량-파일을-AsynchronousFileChannel로-다뤄보기/">https://homoefficio.github.io/2016/08/13/대용량-파일을-AsynchronousFileChannel로-다뤄보기/</a></p></li></ul><h2 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h2><p>Direct Buffer를 사용하더라도 channel의 read/write 메서드가 아니라 buffer의 get/put을 쓰면 DMA가 작동하지 않는다는 글을 봤는데 확인해보진 않았다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-NIO-Direct-Buffer를-이용해서-대용량-파일-행-기준으로-쪼개기&quot;&gt;&lt;a href=&quot;#Java-NIO-Direct-Buffer를-이용해서-대용량-파일-행-기준으로-쪼개기&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="Technique" scheme="http://homoefficio.github.io/categories/Technique/"/>
    
    
      <category term="Java" scheme="http://homoefficio.github.io/tags/Java/"/>
    
      <category term="자바" scheme="http://homoefficio.github.io/tags/%EC%9E%90%EB%B0%94/"/>
    
      <category term="NIO" scheme="http://homoefficio.github.io/tags/NIO/"/>
    
      <category term="DMA" scheme="http://homoefficio.github.io/tags/DMA/"/>
    
      <category term="Direct Memory Access" scheme="http://homoefficio.github.io/tags/Direct-Memory-Access/"/>
    
      <category term="Direct Buffer" scheme="http://homoefficio.github.io/tags/Direct-Buffer/"/>
    
      <category term="ByteBuffer" scheme="http://homoefficio.github.io/tags/ByteBuffer/"/>
    
      <category term="Buffer" scheme="http://homoefficio.github.io/tags/Buffer/"/>
    
      <category term="FileChannel" scheme="http://homoefficio.github.io/tags/FileChannel/"/>
    
      <category term="Large File" scheme="http://homoefficio.github.io/tags/Large-File/"/>
    
      <category term="Split" scheme="http://homoefficio.github.io/tags/Split/"/>
    
      <category term="New Line" scheme="http://homoefficio.github.io/tags/New-Line/"/>
    
      <category term="Carriage Return" scheme="http://homoefficio.github.io/tags/Carriage-Return/"/>
    
      <category term="CR" scheme="http://homoefficio.github.io/tags/CR/"/>
    
      <category term="Line Feed" scheme="http://homoefficio.github.io/tags/Line-Feed/"/>
    
      <category term="LF" scheme="http://homoefficio.github.io/tags/LF/"/>
    
      <category term="readLine" scheme="http://homoefficio.github.io/tags/readLine/"/>
    
      <category term="직접 메모리 접근" scheme="http://homoefficio.github.io/tags/%EC%A7%81%EC%A0%91-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%A0%91%EA%B7%BC/"/>
    
      <category term="다이렉트 버퍼" scheme="http://homoefficio.github.io/tags/%EB%8B%A4%EC%9D%B4%EB%A0%89%ED%8A%B8-%EB%B2%84%ED%8D%BC/"/>
    
      <category term="바이트버퍼" scheme="http://homoefficio.github.io/tags/%EB%B0%94%EC%9D%B4%ED%8A%B8%EB%B2%84%ED%8D%BC/"/>
    
      <category term="버퍼" scheme="http://homoefficio.github.io/tags/%EB%B2%84%ED%8D%BC/"/>
    
      <category term="파일 채널" scheme="http://homoefficio.github.io/tags/%ED%8C%8C%EC%9D%BC-%EC%B1%84%EB%84%90/"/>
    
      <category term="스플릿" scheme="http://homoefficio.github.io/tags/%EC%8A%A4%ED%94%8C%EB%A6%BF/"/>
    
      <category term="대용량" scheme="http://homoefficio.github.io/tags/%EB%8C%80%EC%9A%A9%EB%9F%89/"/>
    
      <category term="대용량 파일" scheme="http://homoefficio.github.io/tags/%EB%8C%80%EC%9A%A9%EB%9F%89-%ED%8C%8C%EC%9D%BC/"/>
    
      <category term="줄 바꿈" scheme="http://homoefficio.github.io/tags/%EC%A4%84-%EB%B0%94%EA%BF%88/"/>
    
  </entry>
  
  <entry>
    <title>Back to the Essence - Concurrency vs Parallelism</title>
    <link href="http://homoefficio.github.io/2019/02/02/Back-to-the-Essence-Concurrency-vs-Parallelism/"/>
    <id>http://homoefficio.github.io/2019/02/02/Back-to-the-Essence-Concurrency-vs-Parallelism/</id>
    <published>2019-02-02T14:29:47.000Z</published>
    <updated>2019-04-28T17:03:55.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Back-to-the-Essence-Concurrency-vs-Parallelism"><a href="#Back-to-the-Essence-Concurrency-vs-Parallelism" class="headerlink" title="Back to the Essence - Concurrency vs Parallelism"></a>Back to the Essence - Concurrency vs Parallelism</h1><blockquote><p>동시성이 뭐냐?<br>복수의 태스크를 동시에 실행하는 거 아니냐?</p><p>병렬성이 뭐냐?<br>복수의 태스크를 동시에 실행하는 거 아니냐?</p><p>그럼 동시성과 병렬성이 뭐가 다른 거냐?<br>…</p></blockquote><p>비슷하지만 다른 개념이라는 건 알겠는데, 설명하라면 또 명확하게 답하기가 쉽지 않다.</p><p>명확하게 답하기 쉽지 않은 이유는 몇 가지 관점에 따라 다르게 설명되어야 할 필요가 있는 것을 그냥 뭉뚱그려서 얘기해왔기 때문이다. 이제 관점에 따라 나눠서 살펴보자.</p><h2 id="시간-관점"><a href="#시간-관점" class="headerlink" title="시간 관점"></a>시간 관점</h2><h3 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h3><p>일단 <strong>동시성에서 말하는 동시는 물리적으로 완전히 동일한 한 시점만을 말하는 것이 아니라 사실 상 동시라고 간주할 수 있는 시점(virtually at the same time)도 포함</strong>한다. 물리적으로 미세하게 다른 시점일지라도 애플리케이션 관점에서 동시라고 간주할 수 있는 시간 간격에서 복수의 태스크가 수행된다면 동시성이 있다.</p><p>그래서 <strong>동시성은 CPU(또는 코어)가 1개인 상황에서도 가능</strong>하다. 시분할 시스템을 통해 사실 상 동시라고 간주해도 무방한 시간에 여러 개의 태스크를 진행시키고 있다면 동시성이 있다.</p><h3 id="Parallelism"><a href="#Parallelism" class="headerlink" title="Parallelism"></a>Parallelism</h3><p><strong>병렬성에서 말하는 동시는 물리적으로 완전히 동일한 시점(physically and literally at the same time)</strong> 이다.</p><p>그래서 <strong>CPU(또는 코어)가 1개인 상황에서는 병렬성을 가질 수 없다.</strong></p><h2 id="작업-독립성-관점"><a href="#작업-독립성-관점" class="headerlink" title="작업 독립성 관점"></a>작업 독립성 관점</h2><p>독립성은 관점에 따라 다르게 해석될 수 있지만, 그런 상대성을 용인하고 바라보면 다음과 같이 비교할 수도 있다.</p><h3 id="Concurrency-1"><a href="#Concurrency-1" class="headerlink" title="Concurrency"></a>Concurrency</h3><p><strong>동시성에서는 독립적인 복수 개의 태스크를 순서를 고려하지 않고 동시에 실행</strong>한다.</p><p>1에서 100까지 더하는 태스크와 1에서 100까지 곱하는 태스크를 동시(완전한 동시가 아니라 동시성에서 말하는 동시)에 실행한다면 이 두 태스크는 독립적이며, 이런 태스크를 동시(완전한 동시가 아니라 동시성에서 말하는 동시)에 처리한다면 동시성이 있다.</p><p>순서를 고려하지 않는다는 것은 순서를 지키는 경우와 지키지 않는 경우 모두를 포괄한다.</p><h3 id="Parallelism-1"><a href="#Parallelism-1" class="headerlink" title="Parallelism"></a>Parallelism</h3><p><strong>병렬성에서는 하나의 태스크를 여러 부분으로 쪼개서 동시에 실행</strong>한다.</p><p>1에서 100까지 더하는 하나의 태스크를 1-30, 31-50, 51-70, 71-100 이렇게 4개의 구간합으로 나누고, 이를 4개의 CPU(또는 코어)에서 각각 동시에 실행하면 병렬성이 있다.</p><h2 id="동시성과-병렬성의-조합"><a href="#동시성과-병렬성의-조합" class="headerlink" title="동시성과 병렬성의 조합"></a>동시성과 병렬성의 조합</h2><h3 id="동시성이-있으면서-병렬성은-없을-수-있다"><a href="#동시성이-있으면서-병렬성은-없을-수-있다" class="headerlink" title="동시성이 있으면서 병렬성은 없을 수 있다?"></a>동시성이 있으면서 병렬성은 없을 수 있다?</h3><p>어떤 관점에서든 CPU(또는 코어)가 1개인 상황에서는 병렬성이 있을 수 없으므로, 이건 자명하다.</p><h3 id="동시성은-없으면서-병렬성은-있을-수-있다"><a href="#동시성은-없으면서-병렬성은-있을-수-있다" class="headerlink" title="동시성은 없으면서 병렬성은 있을 수 있다?"></a>동시성은 없으면서 병렬성은 있을 수 있다?</h3><p>위에서 다룬 더하기 구간합은 병렬성이 분명히 있지만, 동시성이 있다고 보는 것은 관점에 따라 다르다. </p><p>구간합 자체를 별개의 태스크로 본다면 동시성이 있다고 볼 수 있고,<br>구간합을 별개의 태스크가 아니라 전체합이라는 하나의 태스크를 나눈 것으로만 본다면 동시성이 없다고 볼 수 있다.</p><h3 id="동시성과-병렬성-모두-있을-수-있다"><a href="#동시성과-병렬성-모두-있을-수-있다" class="headerlink" title="동시성과 병렬성 모두 있을 수 있다?"></a>동시성과 병렬성 모두 있을 수 있다?</h3><p>1에서 100까지 더하는 하나의 태스크를 1-50, 51-100 이렇게 2개의 구간합으로 나누고, 이를 1, 2번 CPU(또는 코어)에서 각각 동시에 실행하고, 동시에 1에서 100까지 곱하는 하나의 태스크를 1-50, 51-100 이렇게 2개의 구간곱으로 나누고, 이를 3, 4번 CPU(또는 코어)에서 각각 동시에 실행한다면 어떨까?</p><p>이럴 때는 더하기와 곱하기라는 독립적인 복수의 태스크를 동시에 실행하므로 동시성이 있고,<br>더하기라는 하나의 태스크를 구간합으로 나눠서 동시에 실행하고, 곱하기라는 하나의 태스크를 구간곱으로 나눠서 동시에 실행하므로 병렬성도 있다.</p><h2 id="concurrent-vs-simultaneous"><a href="#concurrent-vs-simultaneous" class="headerlink" title="concurrent vs simultaneous"></a>concurrent vs simultaneous</h2><p>참고로 전산 용어를 잠시 떠나서 concurrent와 simultaneous를 비교해보는 것도 concurrent의 의미를 이해하는 데 도움이 될 것 같다.</p><p>둘의 차이를 아래와 같이 해석하는 게 100% 맞는지는 원어민이 아닌 나는 알 수 없지만, 최소한 concurrency vs parallelism을 이해하는 데는 확실히 도움이 된다. 어설픈 번역 말고 그냥 원어 그대로 가져와본다. 출처는 <a href="https://www.quora.com/Is-there-any-major-difference-between-simultaneous-and-concurrent" target="_blank" rel="noopener">Quora</a>다.</p><p><img src="https://i.imgur.com/2KAJ16s.png" alt="Imgur"></p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>자 이렇게 시간 관점, 작업 독립성 관점, 조합 관점에서 구체적으로 살펴보고 나니, 예전에는 별로 와닿지 않았던 다음과 같은 조금 추상적인 단문 비교도 조금은 달라 보인다.</p><blockquote><p>동시성은 여러 가지 일을 한 번에 <strong>처리</strong>하는 것을 말하고,<br>병렬성은 여러 가지 일을 한 번에 <strong>수행</strong>하는 것을 말한다.</p><p><code>Concurrency is about **dealing with** lots of things at once.</code><br><code>Parallelism is about **doing** lots of things at once.</code></p></blockquote><p>간결해서 좋아보이기는 하는데 우리말로 옮겨보면 처리나 수행이나 비슷해져버려서.. 이건 원어민에게는 좋은 비교겠지만, 우리에겐 아쉽게도 그다지.. 게다가 ‘한 번에(at once)’도 ‘동시에’와 마찬가지로 우리말로 옮겨놓고 엄밀하게 보면 틀린 표현이고 부가적인 설명이 필요하므로 꼬리에 꼬리를 무는.. 그래서 흔히 볼 수 있기는 하지만 별로다!</p><blockquote><p>동시성은 <strong>구조</strong>에 관한 것이고,<br>병렬성은 <strong>실행</strong>에 관한 것이다.</p><p><code>Concurrency is about the **structure**.</code><br><code>Parallelism is about the **execution**.</code></p></blockquote><p>오호 이게 좋다. 영어든 국어든 글자수까지 똑같아서 아름답기까지 하다..<br>이렇게 보면 Parallelism을 병렬성보다는 병행성으로 옮기는 게 더 나은 것 같다.  </p><p>간단하게는 썸네일로 사용한 이 그림도 괜찮고,</p><p><img src="https://i.imgur.com/cDdWLKL.jpg" alt="Imgur"></p><p>(출처: <a href="https://www.codeproject.com/Articles/1267757/Concurrency-vs-Parallelism" target="_blank" rel="noopener">https://www.codeproject.com/Articles/1267757/Concurrency-vs-Parallelism</a>)</p><p>다음 그림도 괜찮은 것 같다.</p><p><img src="https://i.imgur.com/uIMnkj1.jpg" alt="Imgur"></p><p>(출처: <a href="https://twitter.com/ohidxy/status/946110898539659264" target="_blank" rel="noopener">https://twitter.com/ohidxy/status/946110898539659264</a>)</p><h3 id="참고-자료"><a href="#참고-자료" class="headerlink" title="참고 자료"></a>참고 자료</h3><ul><li><a href="https://howtodoinjava.com/java/multi-threading/concurrency-vs-parallelism/" target="_blank" rel="noopener">https://howtodoinjava.com/java/multi-threading/concurrency-vs-parallelism/</a></li><li><a href="https://www.slideshare.net/PramestiHattaK/golang-101-concurrency-vs-parallelism" target="_blank" rel="noopener">https://www.slideshare.net/PramestiHattaK/golang-101-concurrency-vs-parallelism</a></li><li><a href="http://tutorials.jenkov.com/java-concurrency/concurrency-vs-parallelism.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-concurrency/concurrency-vs-parallelism.html</a></li><li><a href="https://www.amazon.com/Reactive-Programming-RxJava-Asynchronous-Applications/dp/1491931655/" target="_blank" rel="noopener">https://www.amazon.com/Reactive-Programming-RxJava-Asynchronous-Applications/dp/1491931655/</a></li></ul><h2 id="추가"><a href="#추가" class="headerlink" title="추가"></a>추가</h2><p>페북에 공유하고 보니 이규원 님으로부터 다음과 같은 아주 쌈박한 의견을 얻을 수 있었다.</p><blockquote><p>Concurrency는 다수의 문제가 동시에 일어난 상황에 대한 것이고,<br>Parallelism은 다수의 문제를 동시에 해결하는 방법에 대한 것입니다.</p></blockquote><p>개인적으로는</p><blockquote><p>Concurrency는 해결해야 할 문제고,<br>Parallelisma은 해결하는 방법이다.</p></blockquote><p>라고 생각해왔는데, 몇 군데 조사해보니 이런 식으로 서술된 게 없어서 아닌가보다.. 하고 구조 vs 실행에 힘을 실어주고 끝맺었는데, 우군을 얻었으니 다시 다음과 같이 결론낸다.</p><blockquote><p><strong>Concurrency는 동시에 발생한 다수의 일을 처리해야하는 상황을 의미</strong>하고,<br><strong>Parallelism은 다수의 일을 동시에 실행하는 방식을 의미</strong>한다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Back-to-the-Essence-Concurrency-vs-Parallelism&quot;&gt;&lt;a href=&quot;#Back-to-the-Essence-Concurrency-vs-Parallelism&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="Concepts" scheme="http://homoefficio.github.io/categories/Concepts/"/>
    
    
      <category term="Concurrency" scheme="http://homoefficio.github.io/tags/Concurrency/"/>
    
      <category term="Parallelism" scheme="http://homoefficio.github.io/tags/Parallelism/"/>
    
      <category term="동시성" scheme="http://homoefficio.github.io/tags/%EB%8F%99%EC%8B%9C%EC%84%B1/"/>
    
      <category term="병렬성" scheme="http://homoefficio.github.io/tags/%EB%B3%91%EB%A0%AC%EC%84%B1/"/>
    
      <category term="병행성" scheme="http://homoefficio.github.io/tags/%EB%B3%91%ED%96%89%EC%84%B1/"/>
    
  </entry>
  
  <entry>
    <title>Back to the Essence - Java 컴파일에서 실행까지 - (2)</title>
    <link href="http://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EA%B9%8C%EC%A7%80-2/"/>
    <id>http://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-컴파일에서-실행까지-2/</id>
    <published>2019-01-30T15:20:05.000Z</published>
    <updated>2019-04-28T17:03:55.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Back-to-the-Essence-Java-컴파일에서-실행까지-2"><a href="#Back-to-the-Essence-Java-컴파일에서-실행까지-2" class="headerlink" title="Back to the Essence - Java 컴파일에서 실행까지 - (2)"></a>Back to the Essence - Java 컴파일에서 실행까지 - (2)</h1><p>Java 11 JVM 스펙을 기준으로 Java 소스 코드가 어떻게 컴파일되고 실행되는지 살짝 깊게 알아보자.</p><p>이번엔 2탄 실행 편이다. 1탄 컴파일 편은 <a href="https://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-컴파일에서-실행까지-1/">여기</a>에..</p><h1 id="실행"><a href="#실행" class="headerlink" title="실행"></a>실행</h1><p>자바 애플리케이션은 <code>java</code> 명령어로 실행할 수 있다. <a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE" target="_blank" rel="noopener">오라클의 Tools Reference 문서</a>에 나오는 <code>java</code>에 대한 설명은 다음과 같다.</p><blockquote><p><code>java</code> 명령어는 자바 애플리케이션을 시작한다.<br><code>java</code> 명령어는 먼저 JRE(Java Runtime Environment)를 시작하고,<br>인자로 지정된 클래스(<code>public static void main(String[] args)</code>를 포함하고 있는 클래스)를 로딩하고,<br><code>main()</code> 메서드를 호출한다.</p></blockquote><h2 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK, JRE, JVM"></a>JDK, JRE, JVM</h2><p><code>java</code>는 JRE를 시작한다고 하니, JDK, JRE, JVM의 관계를 그림 한 장으로 가볍게 훑고 지나가자.</p><p><img src="https://i.imgur.com/wChPQEV.png" alt="Imgur"></p><ul><li>JDK: 자바 개발 환경 - 컴파일러, 역어셈블러, 디버거, 의존관계분석 등 개발에 필요한 도구 제공</li><li>JRE: 자바 실행 환경 - 자바 실행 명령, 클래스로더와 바이트코드의 실행에 필요한 기본 라이브러리 제공</li><li>JVM: 자바 가상 머신 - 바이트코드 인터프리터, JIT 컴파일러, 링커, 명령어 세트, 가비지 컬렉터, 런타임 데이터 영역(메모리) 등 OS에 독립적으로 실행될 수 있는 추상층 제공</li></ul><p>대략 다음과 같이 정리할 수 있다.</p><blockquote><p>JDK를 사용해서 바이트코드(class 파일)를 만들고, </p><p>JRE를 사용해서 바이트코드를 실행하면,</p><p>JVM이 기동되면서 바이트코드의 실질적인 실행(실제 OS에 메모리 할당/회수, 시스템 명령 호출 등 요청)을 담당한다.</p></blockquote><h2 id="JRE-시작"><a href="#JRE-시작" class="headerlink" title="JRE 시작"></a>JRE 시작</h2><p><code>java</code> 명령 실행에 의해 JRE가 시작된다는 것은 결국 <code>java</code> 명령어의 인자로 지정된 클래스를 실행하기 위한 자바 실행 환경이 조성됨을 의미한다. </p><p><code>java</code> 명령어의 인자로 지정한 설정 옵션에 맞게 JVM이 실행되고, JVM이 클래스로더를 이용해서 <code>initial class</code>를 <code>create</code>하고, <code>initial class</code>를 <code>link</code>하고, <code>initialize</code>하고, main 메서드를 호출한다.(<a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.2" target="_blank" rel="noopener">JVM 스펙</a> 참고)</p><h3 id="용어-정리"><a href="#용어-정리" class="headerlink" title="용어 정리"></a>용어 정리</h3><p>몇 가지 용어를 일부러 스펙에 나온 원어 그대로 썼는데 스펙상의 의미는 다음과 같다.</p><ul><li>initial class: JVM 구현에 따라 다를 수 있지만 일반적으로 main 메서드를 포함하는 클래스로서 java 명령어의 인자로 지정되는 클래스 (<a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.2" target="_blank" rel="noopener">JVM 스펙</a> 참고)</li><li>create (a class or interface): 해당 클래스나 인터페이스의 바이트코드를 로딩해서 JVM이 할당한 메모리(Method Area, 메서드 영역)에 construction하는 것 (<a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.3" target="_blank" rel="noopener">JVM 스펙</a> 참고)</li><li>link (a class or interface): 해당 클래스나 인터페이스의 바로 위 수퍼클래스나 수퍼인터페이스, 또는 배열일 경우 배열의 원소인 클래스나 인터페이스를 확인(verify)/준비(prepare)하고, 심볼릭 참조를 해석(resolve)해서 JVM에서 실행될 수 있는 상태로 만드는 것 (<a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4" target="_blank" rel="noopener">JVM 스펙</a> 참고)</li><li>initialize (a class or interface): 해당 클래스나 인터페이스의 class or interface initialization method를 실행하는 것 (<a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.5" target="_blank" rel="noopener">JVM 스펙</a> 참고)</li></ul><p>위 설명에는 없지만 중요한 용어인 로딩의 스펙상의 의미는 다음과 같다.</p><ul><li>load (a class or interface): 해당 클래스나 인터페이스의 바이너리 표현을 찾아서 그 바이너리 표현으로부터 클래스나 인터페이스를 생성(create)하는 것 (<a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html" target="_blank" rel="noopener">JVM 스펙</a> 참고)</li></ul><p>앞으로 <strong>initial class는 시작 클래스</strong>, <strong>create은 생성</strong>, <strong>link는 링크</strong>, <strong>initialize는 초기화</strong>, <strong>load는 로딩</strong>이라고 쓴다. 한 가지 유의할 것은 여기서 말하는 <strong>생성(create)은 JVM의 힙(heap)에 객체를 생성하는 것만을 지칭하는 것이 아니라 JVM의 메모리 어딘가에 자료구조를 생성하는 것을 모두 지칭</strong>한다.</p><h2 id="런타임-데이터-영역"><a href="#런타임-데이터-영역" class="headerlink" title="런타임 데이터 영역"></a>런타임 데이터 영역</h2><p><code>java</code> 명령어로 자바 애플리케이션을 실행하면 JVM이 실행되면서 시작 클래스를 생성, 링크, 초기화하고 main 메서드를 호출한다고 했다. 시작 클래스를 생성한다는 것은 시작 클래스의 바이트코드를 읽어서 JVM의 메모리 어딘가에 쓰는 것을 의미한다. JVM의 메모리는 어떻게 생겼을까?</p><p>JVM은 프로그램의 실행에 사용되는 메모리를 런타임 데이터 영역(Runtime Data Area)이라고 부르는 몇 가지 영역으로 나눠서 관리한다. 스펙의 목차로 보면 밋밋하게 다음과 같이 나열되어 있다.</p><ol><li>PC 레지스터</li><li>JVM 스택</li><li>힙(Heap)</li><li>메서드 영역(Method Area)</li><li>런타임 상수 풀(Run-Time Constnat Pool)</li><li>네이티브 메서드 스택</li></ol><p>이렇게 보면 위 6가지가 동등한 최상위 수준에서 분류되는 것처럼 보인다. 하지만, 실제 스펙의 설명을 보면 다음과 같이 약간 입체적으로 구분하는 것이 더 적합하다.</p><p><img src="https://i.imgur.com/Mh4DuRB.png" alt="Imgur"></p><p>여기서 ‘단위’라는 구분 단계를 추가한 이유는 스펙에도 <code>per-class</code>, <code>per-thread</code> 라는 표현이 나오기 때문인데, 여기에서의 ‘단위’는 생명 주기와 생성 단위를 의미한다.</p><p>JVM 단위에 속하는 <strong>힙과 메서드 영역은 JVM이 시작될 때 생성되고, JVM이 종료될 때 소멸되며, JVM 하나에 힙 하나, 메서드 영역도 하나가 생성</strong> 된다.</p><p>마찬가지로 클래스 단위에 속하는 <strong>런타임 상수 풀은 클래스가 생성/소멸될 때 함께 생성/소멸되며, 클래스 하나에 런타임 상수 풀도 하나가 생성</strong> 된다.</p><p>스레드 단위에 속하는 <strong>PC 레지스터, JVM 스택, 네이티브 메서드 스택도 스레드가 생성/소멸될 때 함께 생성/소멸되며, 스레드 하나에 PC 레지스터, JVM 스택, 네이티브 메서드 스택도 각 하나씩 생성</strong> 된다.</p><p>자. 이제 6가지 영역을 좀 더 자세히 알아보자.</p><p>라고 진행하면 너무 뻔한 나열식이라 머리에 잘 안 남는다. 그러니 다음과 같이 간단한 예제 코드 실행 과정과 함께 살펴보자.</p><h2 id="예제-코드"><a href="#예제-코드" class="headerlink" title="예제 코드"></a>예제 코드</h2><h3 id="자바-소스-코드"><a href="#자바-소스-코드" class="headerlink" title="자바 소스 코드"></a>자바 소스 코드</h3><p>헬로 월드 수준의 단순한 소스 코드다. 힙에서 객체가 생성되는 것을 확인하기 위해 Hello 인스턴스를 만들고 무한루프로 프로그램의 종료를 일부러 막아둔 코드다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> homo.efficio.jvm.sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Hello hello = <span class="keyword">new</span> Hello();</span><br><span class="line">        System.out.println(hello.helloMessage());</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, JVM"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="컴파일된-바이트코드"><a href="#컴파일된-바이트코드" class="headerlink" title="컴파일된 바이트코드"></a>컴파일된 바이트코드</h3><p>컴파일된 바이트코드는 다음과 같다.</p><blockquote><p>javap -v -p -s homo/efficio/jvm/sample/Hello.class</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">$ /c/Program\ Files/Java/jdk-<span class="number">11.0</span>.2/bin/javap -v -p -s homo/efficio/jvm/sample/Hello</span><br><span class="line">Classfile /C:/gitrepo/scratchpad/java-jvm-scratchpad/out/production/java-jvm-scratchpad/homo/efficio/jvm/sample/Hello.class</span><br><span class="line">  Last modified <span class="number">2019</span>. <span class="number">1</span>. <span class="number">30</span>.; size <span class="number">741</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">675e63</span>b96993dc5e661d6566467d92d3</span><br><span class="line">  Compiled from <span class="string">"Hello.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">homo</span>.<span class="title">efficio</span>.<span class="title">jvm</span>.<span class="title">sample</span>.<span class="title">Hello</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">55</span></span><br><span class="line">  flags: (<span class="number">0x0021</span>) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #2                          // homo/efficio/jvm/sample/Hello</span><br><span class="line">  super_class: #8                         // java/lang/Object</span><br><span class="line">  interfaces: <span class="number">0</span>, fields: <span class="number">0</span>, methods: <span class="number">3</span>, attributes: <span class="number">1</span></span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #8.#26         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Class              #27            // homo/efficio/jvm/sample/Hello</span><br><span class="line">   #3 = Methodref          #2.#26         // homo/efficio/jvm/sample/Hello."&lt;init&gt;":()V</span><br><span class="line">   #4 = Fieldref           #28.#29        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #5 = Methodref          #2.#30         // homo/efficio/jvm/sample/Hello.helloMessage:()Ljava/lang/String;</span><br><span class="line">   #6 = Methodref          #31.#32        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #7 = String             #33            // Hello, JVM</span><br><span class="line">   #8 = Class              #34            // java/lang/Object</span><br><span class="line">   #9 = Utf8               &lt;init&gt;</span><br><span class="line">  #10 = Utf8               ()V</span><br><span class="line">  #11 = Utf8               Code</span><br><span class="line">  #12 = Utf8               LineNumberTable</span><br><span class="line">  #13 = Utf8               LocalVariableTable</span><br><span class="line">  #14 = Utf8               this</span><br><span class="line">  #15 = Utf8               Lhomo/efficio/jvm/sample/Hello;</span><br><span class="line">  #16 = Utf8               main</span><br><span class="line">  #17 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               args</span><br><span class="line">  #19 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #20 = Utf8               hello</span><br><span class="line">  #21 = Utf8               StackMapTable</span><br><span class="line">  #22 = Utf8               helloMessage</span><br><span class="line">  #23 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #24 = Utf8               SourceFile</span><br><span class="line">  #25 = Utf8               Hello.java</span><br><span class="line">  #26 = NameAndType        #9:#10         // "&lt;init&gt;":()V</span><br><span class="line">  #27 = Utf8               homo/efficio/jvm/sample/Hello</span><br><span class="line">  #28 = Class              #35            // java/lang/System</span><br><span class="line">  #29 = NameAndType        #36:#37        // out:Ljava/io/PrintStream;</span><br><span class="line">  #30 = NameAndType        #22:#23        // helloMessage:()Ljava/lang/String;</span><br><span class="line">  #31 = Class              #38            // java/io/PrintStream</span><br><span class="line">  #32 = NameAndType        #39:#40        // println:(Ljava/lang/String;)V</span><br><span class="line">  #33 = Utf8               Hello, JVM</span><br><span class="line">  #34 = Utf8               java/lang/Object</span><br><span class="line">  #35 = Utf8               java/lang/System</span><br><span class="line">  #36 = Utf8               out</span><br><span class="line">  #37 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #38 = Utf8               java/io/PrintStream</span><br><span class="line">  #39 = Utf8               println</span><br><span class="line">  #40 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> homo.efficio.jvm.sample.Hello();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lhomo/efficio/jvm/sample/Hello;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #2                  // class homo/efficio/jvm/sample/Hello</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #3                  // Method "&lt;init&gt;":()V</span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         8: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">11</span>: aload_1</span><br><span class="line">        12: invokevirtual #5                  // Method helloMessage:()Ljava/lang/String;</span><br><span class="line">        15: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">18</span>: goto          <span class="number">18</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">18</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">21</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>      <span class="number">13</span>     <span class="number">1</span> hello   Lhomo/efficio/jvm/sample/Hello;</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">1</span></span><br><span class="line">        frame_type = <span class="number">252</span> <span class="comment">/* append */</span></span><br><span class="line">          offset_delta = <span class="number">18</span></span><br><span class="line">          locals = [ class homo/efficio/jvm/sample/Hello ]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">helloMessage</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()Ljava/lang/String;</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: ldc           #7                  // String Hello, JVM</span><br><span class="line">         <span class="number">2</span>: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">3</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lhomo/efficio/jvm/sample/Hello;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"Hello.java"</span></span><br></pre></td></tr></table></figure><p>앞에서 JDK, JRE, JVM 관계로 설명했지만 위와 같은 바이트코드를 만드는 과정까지는 JDK에서 담당한다.</p><p>앞에서 자바 프로그램이 실행되면 다음과 같이 전개된다고 설명했다. </p><blockquote><p><strong>JVM이 실행</strong>되고, JVM이 클래스로더를 이용해서 <strong>시작 클래스를 생성</strong>하고, <strong>링크</strong>하고, <strong>초기화</strong>하고, <strong>main 메서드를 호출</strong>한다.</p></blockquote><p>이제 <code>java homo.efficio.jvm.sample.Hello</code> 명령을 실행하면 어떻게 진행되는지 차근차근 살펴보자.</p><h2 id="JVM-실행"><a href="#JVM-실행" class="headerlink" title="JVM 실행"></a>JVM 실행</h2><p><code>java</code> 명령이 실행되면 JRE가 조성되면서 JVM이 실행된다. JVM이 실행되면 JVM 단위로 생성되는 힙과 메서드 영역이 함께 생성된다.</p><h3 id="힙"><a href="#힙" class="headerlink" title="힙"></a>힙</h3><p><strong><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.5.3" target="_blank" rel="noopener">힙(Heap)</a>은 인스턴스화 된 모든 클래스 인스턴스와 배열을 저장하는 공간</strong>이며, <strong>모든 JVM 스레드에 공유</strong>된다.</p><p>힙에 저장된 객체에 할당된 메모리는 명시적인 방법으로는 절대 회수되지 못하며, 오직 가비지 컬렉터(garbage collector)에 의해서만 회수될 수 있다.</p><p>Hello는 이 시점에서는 아직 인스턴스화 되지 않았으므로 힙은 비어있다.</p><h3 id="메서드-영역"><a href="#메서드-영역" class="headerlink" title="메서드 영역"></a>메서드 영역</h3><p><strong><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.5.4" target="_blank" rel="noopener">메서드 영역(Method Area)</a>은 런타임 상수 풀, 필드와 메서드 데이터, 생성자 및 메서드의 코드 내용을 저장</strong>한다. 저장되는 내용은 위에서 살펴봤던 바이트코드의 내용과 거의 일치한다. 거의라고 얘기하는 이유는 바이트코드에는 런타임 상수 풀이 아니라 그냥 상수 풀(constanta pool)이 포함되어 있기 때문이다. 런타임 상수 풀은 이 상수 풀을 바탕으로 런타임에, 더 구체적으로는 메서드 영역에 저장될 때 만들어진다.</p><p>그래서 엄밀히 말하면 정확하지 않지만, <strong>바이트코드 내용이 메서드 영역에 저장된다</strong>라고 이해해도 크게 틀리지는 않다.</p><p>Hello는 이 시점에서는 아직 생성되지 않았으므로 메서드 영역도 비어있다.</p><p><img src="https://i.imgur.com/KXJsPgs.png" alt="Imgur"></p><p>JVM 스펙은 런타임 데이터 영역을 6가지로 나눠서 설명하고 있고, 그에따라 그림에도 힙과 메서드 영역을 분리해서 표현했지만, 스펙에는 메서드 영역이 논리적으로 힙의 일부지만(그래서 가비지 컬렉션 대상이 되지만), 단순하게는 가비지 컬렉션이나 압축을 하지 않게 구현할 수도 있으며, 스펙은 메서드의 영역의 위치에 대해 강제하지 않는다고 나와 있기도 하다. 결국 메서드 영역의 위치는 JVM 구현체에 따라 달라질 수 있다는 말이다.</p><p>참고로 Java 8 부터 Metaspace가 기존의 PermGen 영역을 대체한다는 자료들이 많이 있는데, JVM 스펙에는 Megaspace라는 용어는 전혀 나오지 않는다. Metaspace는 JVM 구현체인 HotSpot JVM에서 나오는 용어이며, Metaspace에 저장되는 데이터를 기준으로 보면 HotSpot JVM은 JVM 스펙의 메서드 영역을 Metaspace로 구현한 거라고 볼 수 있다.</p><h2 id="시작-클래스-생성"><a href="#시작-클래스-생성" class="headerlink" title="시작 클래스 생성"></a>시작 클래스 생성</h2><p>시작 클래스는 Hello를 지칭하며 시작 클래스를 생성하는 것은 파일시스템에 있는 Hello.class 파일을 JVM의 메서드 영역으로 읽어들이는 것을 의미한다고 했다. 따라서 <strong>이 시점에서 Hello의 바이트코드 내용이 메서드 영역에 저장</strong>된다.</p><p><img src="https://i.imgur.com/QBQyTab.png" alt="Imgur"></p><p>그런데 Hello 클래스는 누가 로딩하는 걸까? 당연하지만 클래스로더가 로딩한다. 그럼 클래스로더는 누가 로딩할까?</p><h3 id="클래스로더"><a href="#클래스로더" class="headerlink" title="클래스로더"></a>클래스로더</h3><p>자바 런타임은 네이티브 코드로 작성된 부트스트랩 클래스로더, 플랫폼 클래스로더, 시스템 클래스로더, 이렇게 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ClassLoader.html" target="_blank" rel="noopener">3가지 빌트인(built-in) 클래스로더를 제공</a>한다.</p><p>결론적으로 <strong>Hello 클래스는 시스템 클래스로더가 로딩</strong>하는데, <strong>시스템 클래스로더는 플랫폼 클래스로더가 로딩하고, 플랫폼 클래스로더는 부트스트랩 클래스로더가 로딩하고, 부트스트랩 클래스로더는 <code>java</code> 명령에 의해 JRE가 조성될 때 실행</strong>된다.</p><p>클래스로딩은 <a href="https://homoefficio.github.io/2018/10/13/Java-클래스로더-훑어보기/">Java 클래스로더 훑어보기</a>와 <a href="ttps://homoefficio.github.io/2018/10/14/Java-URLClassLoader로-알아보는-클래스로딩/">Java URLClassLoader로 알아보는 클래스로딩</a>을 참고하자.</p><h3 id="런타임-상수-풀"><a href="#런타임-상수-풀" class="headerlink" title="런타임 상수 풀"></a>런타임 상수 풀</h3><p>클래스가 생성되면 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.5.5" target="_blank" rel="noopener">런타임 상수 풀(Run-Time Constant Pool)</a>도 함께 생성된다고 했다. <strong>런타임 상수 풀에는 컴파일 타임에 이미 알 수 있는 숫자 리터럴 값부터 런타임에 해석되는 메서드와 필드의 참조까지를 포괄하는 여러 종류의 상수가 포함</strong>된다. 런타임 상수 풀은 다른 전통적인 언어에서 말하는 심볼 테이블과 비슷한 기능을 한다고 보면 된다.</p><p><img src="https://i.imgur.com/ZtsNYAv.png" alt="Imgur"></p><h2 id="링크"><a href="#링크" class="headerlink" title="링크"></a>링크</h2><p><strong><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4" target="_blank" rel="noopener">링크</a>는 클래스나 인터페이스의 바로 위 수퍼클래스나 수퍼인터페이스, 또는 배열일 경우 배열의 원소인 클래스나 인터페이스를 확인(verify)/준비(prepare)하고, 심볼릭 참조를 해석(resolve)하는 과정</strong>을 말한다.</p><p>그럼 확인, 준비, 해석은 뭘 의미하는 걸까?</p><h3 id="확인"><a href="#확인" class="headerlink" title="확인"></a>확인</h3><p><strong><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4.1" target="_blank" rel="noopener">확인(verification)</a>은 클래스나 인터페이스의 바이너리 표현이 구조적으로 올바른지를 보장해주는 과정</strong>이다. 확인 과정은 다른 클래스나 인터페이스의 로딩을 유발할 수도 있지만, 로딩된 다른 클래스나 인터페이스의 확인이나 준비를 필수적으로 유발하지는 않는다.</p><p>Hello.class 파일은 JDK에 포함된 공식 컴파일러인 <code>javac</code>에 의해 정상적으로 컴파일되었으므로 구조적으로 올바르다고 가정하면, <strong>확인 과정에서 Hello의 부모 클래스인 Object가 로딩</strong>된다.</p><p><img src="https://i.imgur.com/8f6zqKP.png" alt="Imgur"></p><h3 id="준비"><a href="#준비" class="headerlink" title="준비"></a>준비</h3><p><strong><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4.2" target="_blank" rel="noopener">준비(preperation)</a>는 클래스나 인터페이스의 정적(static) 필드를 생성하고 기본값으로 초기화하는 과정</strong>이다. 준비 과정에서는 JVM 코드의 실행을 필요로 하지 않으며, <strong>기본값이 아닌 특정값으로 정적 필드를 초기화하는 과정은 준비 과정이 아니라 초기화 과정에서 수행</strong>된다.</p><p>스펙에 정의된 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.3" target="_blank" rel="noopener">기본형 타입의 기본값</a>과 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.4" target="_blank" rel="noopener">참조형 타입의 기본값</a>은 다음과 같다.</p><table><thead><tr><th>타입</th><th>기본값</th></tr></thead><tbody><tr><td>byte, short, int, long</td><td>0</td></tr><tr><td>char</td><td>null(<code>&#39;\u0000&#39;</code>)</td></tr><tr><td>float, double</td><td>0(positive zero)</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>참조형</td><td>null</td></tr></tbody></table><p>Hello에는 정적 필드가 없으므로 이 과정에서 특별히 수행되는 것은 없다.</p><h3 id="해석"><a href="#해석" class="headerlink" title="해석"></a>해석</h3><p><strong><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4.3" target="_blank" rel="noopener">해석(resolution)</a>은 런타임 상수 풀에 있는 심볼릭 참조가 구체적인 값을 가리키도록 동적으로 결정하는 과정</strong>이다. 초기 상태의 런타임 상수 풀에 있는 심볼릭 참조는 해석되어져 있지 않다.</p><h3 id="링크의-조건"><a href="#링크의-조건" class="headerlink" title="링크의 조건"></a>링크의 조건</h3><p>JVM 스펙에서는 <strong>링크가 언제 수행되어야 하는지는 규정하지 않고 유연하게 구현될 수 있는 여지</strong>를 주고 있다. 단 다음과 같은 조건을 만족해야 한다.</p><ul><li>클래스나 인터페이스는 링크되기 전에 먼저 완전히 로딩되어야 한다.</li><li>클래스나 인스턴스는 초기화되기 전에 먼저 완전히 확인되고 준비되어야 한다.</li><li>링크 관련 에러는 해당 클래스나 인터페이스에 대한 링크를 필요로 하는 행위가 수행되는 시점에 throw 되어야 한다.</li><li>동적으로 계산되는(dynamically-computed) 상수 A에 대한 심볼릭 참조는, A를 참조하는 <code>ldc</code>, <code>ldc_w</code>, <code>ldc2_w</code> 명령어가 실행되거나 A를 정적 인자로 참조하는 부트스트랩 메서드가 호출되기 전까지는 해석되지 않는다.</li><li>동적으로 계산되는(dynamically-computed) call site B에 대한 심볼릭 참조는, B를 정적 인자로 참조하는 부트스트랩 메서드가 호출되기 전까지는 해석되지 않는다.</li></ul><p>일반적으로 만족되어야 하는 것은 1, 2, 3번째 조건이고 4, 5번째는 특수한 경우에 대한 조건이다.</p><p>해석 시점은 JVM 구현체에 따라 다를 수 있다. <strong>지연(lazy) 링크 전략을 사용하면 클래스나 인터페이스에 포함된 심볼릭 참조는 해당 참조가 실제 사용될 때 개별적으로 해석</strong>된다. 반면에 <strong>즉시(eager) 링크 전략을 사용하면 클래스나 인터페이스가 확인될 때 모든 심볼릭 참조가 한꺼번에 해석</strong>된다. 지연 링크를 사용하면 해석 과정은 클래스나 인터페이스가 초기화 된 후에 실행될 수도 있다.</p><p>링크 과정을 정리하면 다음과 같다.</p><blockquote><p>링크는 <strong>확인, 준비, 해석 단계로 구성된다.</strong></p><p><strong>클래스나 인터페이스는 완전히 로딩된 후에 확인과 준비가 수행돼야 하고, 완전히 확인되고 준비된 뒤에 초기화되어야 한다.</strong></p><p><strong>해석은 초기화 이후에 실행될 수도 있다.</strong></p></blockquote><p>스펙을 보면 해석은 다시 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4.3.1" target="_blank" rel="noopener">클래스/인터페이스 해석</a>, <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4.3.2" target="_blank" rel="noopener">필드 해석</a>, <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4.3.3" target="_blank" rel="noopener">메서드 해석</a>, <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4.3.4" target="_blank" rel="noopener">인터페이스 메서드 해석</a>, <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4.3.5" target="_blank" rel="noopener">메서드 타입/핸들 해석</a>, <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4.3.6" target="_blank" rel="noopener">동적 계산 상수/콜사이트 해석</a>, 이렇게 6가지로 나눠서 자세한 설명이 나와 있으니 관심있다면 찾아보기로 하고 다시 예제로 돌아와 보자. </p><p>Hello의 상수 풀은 다음과 같았다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #8.#26         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Class              #27            // homo/efficio/jvm/sample/Hello</span><br><span class="line">   #3 = Methodref          #2.#26         // homo/efficio/jvm/sample/Hello."&lt;init&gt;":()V</span><br><span class="line">   #4 = Fieldref           #28.#29        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #5 = Methodref          #2.#30         // homo/efficio/jvm/sample/Hello.helloMessage:()Ljava/lang/String;</span><br><span class="line">   #6 = Methodref          #31.#32        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #7 = String             #33            // Hello, JVM</span><br><span class="line">   #8 = Class              #34            // java/lang/Object</span><br><span class="line">   #9 = Utf8               &lt;init&gt;</span><br><span class="line">  #10 = Utf8               ()V</span><br><span class="line">  #11 = Utf8               Code</span><br><span class="line">  #12 = Utf8               LineNumberTable</span><br><span class="line">  #13 = Utf8               LocalVariableTable</span><br><span class="line">  #14 = Utf8               this</span><br><span class="line">  #15 = Utf8               Lhomo/efficio/jvm/sample/Hello;</span><br><span class="line">  #16 = Utf8               main</span><br><span class="line">  #17 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               args</span><br><span class="line">  #19 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #20 = Utf8               hello</span><br><span class="line">  #21 = Utf8               StackMapTable</span><br><span class="line">  #22 = Utf8               helloMessage</span><br><span class="line">  #23 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #24 = Utf8               SourceFile</span><br><span class="line">  #25 = Utf8               Hello.java</span><br><span class="line">  #26 = NameAndType        #9:#10         // "&lt;init&gt;":()V</span><br><span class="line">  #27 = Utf8               homo/efficio/jvm/sample/Hello</span><br><span class="line">  #28 = Class              #35            // java/lang/System</span><br><span class="line">  #29 = NameAndType        #36:#37        // out:Ljava/io/PrintStream;</span><br><span class="line">  #30 = NameAndType        #22:#23        // helloMessage:()Ljava/lang/String;</span><br><span class="line">  #31 = Class              #38            // java/io/PrintStream</span><br><span class="line">  #32 = NameAndType        #39:#40        // println:(Ljava/lang/String;)V</span><br><span class="line">  #33 = Utf8               Hello, JVM</span><br><span class="line">  #34 = Utf8               java/lang/Object</span><br><span class="line">  #35 = Utf8               java/lang/System</span><br><span class="line">  #36 = Utf8               out</span><br><span class="line">  #37 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #38 = Utf8               java/io/PrintStream</span><br><span class="line">  #39 = Utf8               println</span><br><span class="line">  #40 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>설명의 편의를 위해 즉시 링크 방식으로 해석이 진행된다고 가정하고, 위 상수 풀에서 유도되는 런타임 상수 풀에 있는 심볼릭 참조의 해석 과정을 몇 개만 예로 살펴보자.</p><p><code>#1 = Methodref          #8.#26         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</code></p><p>Object 클래스가 확인 과정에서 메서드 영역에 로딩되어 있으므로, 메서드 영역에 저장된 Object 클래스의 바이트코드 내용에서 생성자(<code>&lt;init&gt;</code>)의 위치를 알아낼 수 있고, 그 위치를 <code>Methodref java/lang/Object.&quot;&lt;init&gt;&quot;</code>의 값으로 해석할 수 있다.</p><p><img src="https://i.imgur.com/MAiWMYz.png" alt="Imgur"></p><p><code>#2 = Class              #27            // homo/efficio/jvm/sample/Hello</code></p><p>Hello 인스턴스를 만들 때 필요한 Hello 클래스 정보는 이미 메서드 영역에 로딩되어 있으므로, 메서드 영역 내에서 Hello 클래스의 위치를 <code>Class homo/efficio/jvm/sample/Hello</code>의 값으로 해석할 수 있다.</p><p><img src="https://i.imgur.com/y0qP8vW.png" alt="Imgur"></p><p><code>#3</code>은 Hello 생성자를 가리키는 Methodref 항목인데, Methodref의 해석 과정은 앞의 <code>#1</code>에서 이미 다뤘으므로 설명은 생략하고 그림만 보자.</p><p><img src="https://i.imgur.com/XBMPitk.png" alt="Imgur"></p><p><code>#4 = Fieldref           #28.#29        // java/lang/System.out:Ljava/io/PrintStream;</code></p><p>System 클래스는 아직 로딩되어 있지 않으므로 먼저 로딩하고, 확인 후 준비 과정을 거치면서 System 클래스의 정적 필드인 <code>out</code>의 타입인 PrintStream 클래스도 로딩되고 참조형 변수인 <code>out</code>은 기본값인 null 로 초기화 된다.</p><p><img src="https://i.imgur.com/RJ3ZLvX.png" alt="Imgur"></p><p>대략 이런 식으로 로딩-링크 과정이 연쇄적으로 수행되면서 메서드 영역이 채워지고, 메서드 영역 내에서 클래스 단위로 생성되는 런타임 상수 풀 안에 있는 심볼릭 참조가 가리키는 값들이 결정된다.</p><p>하지만 이것도 위에 썼듯이 즉시 링크 방식일 때의 얘기고, <strong>지연 링크를 사용한다면 각 클래스의 초기화가 수행된 이후에 해석 과정이 수행</strong>될 수도 있다.</p><p>그럼 이제 초기화를 알아볼 차례다.</p><h2 id="초기화"><a href="#초기화" class="headerlink" title="초기화"></a>초기화</h2><p>초기화(initialization)는 <code>클래스 또는 인터페이스 초기화 메서드(class or interface initialization method)</code>를 실행할 때 수행되는 과정이다. 쉽게 말하면 <strong>여기에서 말하는 초기화는 정적 초기화(static initialization)를 말한다</strong>고 볼 수 있다.</p><p>그럼 초기화 메서드는 무엇일까?</p><h3 id="초기화-메서드"><a href="#초기화-메서드" class="headerlink" title="초기화 메서드"></a>초기화 메서드</h3><p>초기화 메서드(initialization method)는 두 가지가 있다.</p><h4 id="인스턴스-초기화-메서드"><a href="#인스턴스-초기화-메서드" class="headerlink" title="인스턴스 초기화 메서드"></a>인스턴스 초기화 메서드</h4><p><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.9.1" target="_blank" rel="noopener">인스턴스 초기화 메서드</a>는 자바 언어로 작성되는 생성자에 해당하며, 클래스는 0개 이상의 인스턴스 초기화 메서드를 가진다. <code>인스턴스 초기화 메서드</code>는 다음의 조건을 모두 충족해야 한다.</p><ul><li>(인터페이스가 아니고) 클래스 안에 정의된다.</li><li>(바이트코드 상에서) <code>&lt;init&gt;</code>라는 특수한 이름으로 표현된다.</li><li>반환 타입은 void</li></ul><p><code>인스턴스 초기화 메서드</code>는 생성자로서 힙에 인스턴스를 생성하는 역할을 담당하며, 이름에 초기화라는 용어가 들어가지만 여기에서 말하는 초기화와는 좀 다른 개념이고, 실제 스펙에서도 초기화는 (인스턴스 초기화 메서드를 배제하고) <code>class or interface initialization method(클래스 또는 인터페이스 초기화 메서드)</code>를 호출한다고 명시되어 있다. (<a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.5" target="_blank" rel="noopener">JVM 스펙</a>에 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.9.2" target="_blank" rel="noopener">2.9.2</a> 라고 따로 명기)</p><h4 id="클래스-초기화-메서드-클래스-또는-인터페이스-초기화-메서드"><a href="#클래스-초기화-메서드-클래스-또는-인터페이스-초기화-메서드" class="headerlink" title="클래스 초기화 메서드(클래스 또는 인터페이스 초기화 메서드)"></a>클래스 초기화 메서드(클래스 또는 인터페이스 초기화 메서드)</h4><p>앞에서 링크 과정의 준비 단계 설명에 초기화가 잠시 언급된 적이 있다.<br><strong>정적 필드를 기본값으로 초기화 하는 것은 링크의 준비 단계에서 수행</strong>되고, <strong>정적 필드를 특정값으로 초기화 하는 것은 초기화 단계에서 수행</strong>된다고 했는데, 지금 설명하고 있는 이 <code>클래스 또는 인터페이스 초기화 메서드</code>가 실행되는 것이 초기화 단계다.</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.9.2" target="_blank" rel="noopener">클래스 또는 인터페이스 초기화 메서드</a>는 클래스나 인터페이스에(클래스나 인터페이스의 바이트코드에) 1개만 존재할 수 있으며, 다음의 조건을 모두 충족해야 한다.</p><ul><li>(바이트코드 상에서) <code>&lt;clinit&gt;</code>라는 특수한 이름으로 표현된다.</li><li>반환 타입은 void</li><li>class 파일 버전 51 이상에서는 <code>ACC_STATIC</code> 플래그가 붙는다.</li></ul><p>인스턴스 초기화 메서드는 생성자에 해당한다는 명확하고 직관적인 설명이 스펙에 있는데, <code>클래스 또는 인터페이스 초기화 메서드</code>는 아쉽게도 뭐에 해당하는지 스펙에는 구체적인 설명이 없다.</p><p>그래서 몇 가지 테스트를 해 본 결과 <strong>클래스 초기화 메서드는 쉽게 말해 static 블록(들)의 내용을 하나로 합친 것</strong>이라고 볼 수 있다. 이건 말보다 코드가 훨씬 쉬우니 코드로 살펴보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> homo.efficio.jvm.sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInitSample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        j = <span class="number">22</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컴파일한 후 <code>javap -v -p -s homo.efficio.jvm.sample.StaticInitSample</code> 명령으로 바이트코드를 살펴보면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line