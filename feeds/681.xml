<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>이상현 IN 베를린</title>
    <author>이상현</author>
    <link>https://iamsang.com/</link>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    
        <atom:link href="https://iamsang.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>구글문서 스타일 기능</title>
      <author>이상현</author>
      <link>https://iamsang.com/blog/2019/02/04/google-docs-style/</link>
      <pubDate>Mon, 04 Feb 2019 20:17:00 +0100</pubDate>
      
      <guid>https://iamsang.com/blog/2019/02/04/google-docs-style/</guid>
      <description>
        

&lt;blockquote&gt;
&lt;p&gt;Word를 쓰면서 스페이스를 이용해 정렬하는 지원자는 자동으로 불합격 처리한다. 사과할 생각은 없다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;스택오버플로 창업자 &lt;a href=&#34;https://twitter.com/spolsky/status/340151086440652801&#34;&gt;조엘 스폴스키가 트윗했던&lt;/a&gt; 내용이다.&lt;/p&gt;

&lt;p&gt;Word의 기본적인 기능도 모르고 문서의 스타일을 유지하기 위해 일일이 스페이스를 넣는 개발자는 뽑지 않겠다는 뜻이다.&lt;/p&gt;

&lt;p&gt;지금은 구글독스 사용률이 높아져 개인뿐 아니라 업무에도 사용되는 일이 많다. 구글독스에도 Word와 같이 스타일을 일관적으로 유지할 수 있는 기능을 제공한다.&lt;/p&gt;

&lt;p&gt;서식 기능 중 기본적이지만 유용한 단락스타일(Paragraph styles) 기능을 간단하게 소개한다.&lt;/p&gt;

&lt;p&gt;단락스타일은 문서에 CSS를 입히는 것과 같다. 제목을 꾸밀때 폰트 사이즈를 바꾸고 굵기 조절을 하는 대신 스타일을 입히는 것이다.&lt;/p&gt;

&lt;h3 id=&#34;스타일-적용&#34;&gt;스타일 적용&lt;/h3&gt;

&lt;p&gt;스타일 적용은 아래와 같이 할 수 있다.

&lt;figure &gt;
    
        &lt;img src=&#34;https://iamsang.com/img/google-docs/google-docs-style-0.png&#34;  /&gt;
    
    
    &lt;figcaption&gt;
        구글독스 단락스타일
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;단축키를 선호한다면 맥에서는 &lt;code&gt;Cmd&lt;/code&gt;+&lt;code&gt;Option&lt;/code&gt;+&lt;code&gt;숫자키&lt;/code&gt;를 이용할 수 있다.&lt;/p&gt;

&lt;p&gt;단락스타일 기능을 이용하면 스타일을 없애는 것도 쉽다. 예를 들어 다른 웹페이지에서 내용을 복사했는데 기존의 폰트색이나 사이즈가 그대로 남아 있을때 &lt;code&gt;Cmd&lt;/code&gt;+&lt;code&gt;Option&lt;/code&gt;+&lt;code&gt;0&lt;/code&gt;을 누르면 스타일이 사라지면서 일반 텍스트가 된다.&lt;/p&gt;

&lt;h3 id=&#34;목차-아웃라인&#34;&gt;목차 / 아웃라인&lt;/h3&gt;

&lt;p&gt;단락스타일 기능을 이용해 제목의 스타일을 설정하였을 경우 목차를 넣거나 아웃라인을 볼 수 있다는 장점이 있다.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://iamsang.com/img/google-docs/google-docs-outline.png&#34;  /&gt;
    
    
    &lt;figcaption&gt;
        구글독스 아웃라인
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;



&lt;h3 id=&#34;단락스타일-기능-사용의-장점&#34;&gt;단락스타일 기능 사용의 장점&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;쉬운 스타일 적용/제거가 가능하다.&lt;/li&gt;
&lt;li&gt;일관적인 스타일 변경이 가능하다.&lt;/li&gt;
&lt;li&gt;목차를 만들 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대학생 시절 확률통계 과목 교수님께서 과제를 제출할 때 서식기능을 사용하지 않으면 감점을 주겠다고 하신 덕분에 서식기능을 배울 수 있었다. 김종덕 교수님께 감사의 말씀 전한다.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>내가 받은 최고의 커리어 조언</title>
      <author>이상현</author>
      <link>https://iamsang.com/blog/2019/01/01/career-advice/</link>
      <pubDate>Tue, 01 Jan 2019 18:19:24 +0100</pubDate>
      
      <guid>https://iamsang.com/blog/2019/01/01/career-advice/</guid>
      <description>
        &lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;CEO님께서는 부사장(VP)이나 상무(SVP)가 될 사람을 어떻게 찾습니까?&amp;rdquo;&lt;br&gt;
&amp;ldquo;저는 본인의 영역 이상의 일을 이미 하는 직원을 찾아서 그들을 진급시킵니다.&amp;rdquo;&lt;br&gt;
그는 &amp;lsquo;가능성&amp;rsquo;이나 &amp;lsquo;미래&amp;rsquo; 대신에 &amp;lsquo;이미&amp;rsquo;라는 단어를 사용했다.&lt;br&gt;
이후 나는 매니저들은 그들의 가능성이 아니라 결과를 보고 진급시킨다는 사실을 알게 되었다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Fearless Salary Negotiation이라는 책의 내용 중 일부이다.&lt;/p&gt;

&lt;p&gt;독일로 이직해 온 후 연봉협상이 있었는데, 이곳에서는 이런 자리에서 어떤 말을 해야 하는지 어떤 식으로 진행되는지 등을 알 수 없어 도움이 될까 해서 보았던 책이다.&lt;/p&gt;

&lt;p&gt;연봉협상에는 도움이 되지 않았고 책에서 이야기하는 다른 내용들도 나에게는 그다지 필요하지 않은 부분이었지만 저 일화 하나만으로도 충분히 가치 있는 책이었다.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;나의 영역 밖의 일을 할 수 있지만, 회사에서 부여한 권한과 책임이 이 정도니 확실한 지시나 더 높은 자리를 주지 않으면 이런 것까지 하는 건 안 되지 않을까&amp;rdquo;라는 생각을 하며 선을 그었던 적이 있다. 지금은 그것이 잘못된 생각이었다는 것을 안다.&lt;/p&gt;

&lt;p&gt;구글의 디지털 마케팅 에반젤리스트이자 웹분석에 관한 베스트셀러북 저자인 &lt;a href=&#34;https://www.kaushik.net/avinash/about/&#34;&gt;아비나쉬&lt;/a&gt;는 소식지를 통해 다음과 같은 이야기를 소개한 적 있다 (내용을 축약해서 옮겼으니 전체 내용이 궁금하다면 &lt;a href=&#34;https://madmimi.com/p/66293c?fe=1&amp;amp;pact=2225092-145409887-10723592945-ef000a7800f81ff376162f1060577ecab8c39f80&#34;&gt;원문&lt;/a&gt;을 확인해보기 바란다.)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;홍콩의 한 다국적 기업에서 강연하던 중 다음과 같은 질문을 받은 적 있다.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;상사에게 그렇게 하도록 요청받는 경우가 거의 없는 상황에서 어떻게 강연자님께서 우리에게 이야기해 준 것처럼 변화를 이끌 수 있을까요?&lt;/p&gt;

&lt;p&gt;나는 그녀에게 노트를 보내주기로 약속했다.&lt;/p&gt;

&lt;p&gt;보내준 노트는 아래와 같다.&lt;/p&gt;

&lt;p&gt;당신이 어떤 것을 하도록 요청받거나 변화를 이끌거나 기여를 통해 인정받고 싶다면 손을 들어라.&lt;/p&gt;

&lt;p&gt;손을 들어라 실제로 손을 들어서&lt;br&gt;
손을 들어라 피드백을 공유하면서&lt;br&gt;
손을 들어라 일어서면서&lt;br&gt;
손을 들어라 문제를 해결하면서 (작은 것이라 하더라도)&lt;br&gt;
손을 들어라 영향력 있는 사람에게 이야기하면서&lt;br&gt;
손을 들어라 실험하면서&lt;br&gt;
손을 들어라 다른 사람을 인정하면서&lt;br&gt;
손을 들어라 더 많이 미소짓고 예의 있게 항의하고 겸손하게 도전하면서&lt;br&gt;
손을 들어라.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;그리고 누군가 그것을 볼 것이다.&lt;/p&gt;

&lt;p&gt;사이드라인에서 기다리지 마라.&lt;br&gt;
요청받기를 기다리지 마라.&lt;br&gt;
허락을 기다리지 마라.&lt;br&gt;
아무도 당신에게 신경 쓰지 않는다고 불평하지 마라.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;어떤 규모의 팀에서건 당신과 함께하겠다고 손드는 이, 당신의 도움 / 지혜 / 지지를 감사히 받는 이, 당신을 축하하는 이들을 발견하게 될 것이다.&lt;/p&gt;

&lt;p&gt;그냥 손을 들어라.&lt;/p&gt;

&lt;p&gt;당신의 회사는 당신을 필요로 한다. 당신은 당신을 필요로 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;사실 손을 드는 것만으로는 충분하지 않을 수 있다. 여러 베스트셀러 책의 저자이자 가장 영향력 있는 마케터 중 한 사람인 &lt;a href=&#34;https://seths.blog/&#34;&gt;세스 고딘&lt;/a&gt;의 블로그 글 중 하나인 &lt;a href=&#34;https://seths.blog/2018/04/after-you-raise-your-hand/&#34;&gt;&amp;ldquo;손을 들고 난 후에&amp;rdquo;&lt;/a&gt;를 추가한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;행동하라 (Show up).&lt;br&gt;
행동하고 계속 행동하라.&lt;br&gt;
행동하라 최소한 당신이 손을 들고 처음 자원했을 때처럼.&lt;br&gt;
자원하기는 쉽다. 약속하는 것은 다른 사람의 주목을 받기 좋은 방법이다.&lt;br&gt;
그 약속을 지키는 부분은 종종 인정받지 못하지만, 그것이 당신이 어떤 것을 만들어내는 방식이다.&lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;회사에 모든 열정을 바치거나 다른 이들보다 일을 더 많이 해서 인정받으라는 것은 아니다. 중요한 것은 내 한계의 선을 긋지 않을 때 더 주도적이고 자율적으로 즐기며 일할 수 있다는 것이다.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>다른 생각을 가진 이와 일하는 법</title>
      <author>이상현</author>
      <link>https://iamsang.com/blog/2018/12/27/how-to-work-with-others/</link>
      <pubDate>Thu, 27 Dec 2018 20:00:00 +0100</pubDate>
      
      <guid>https://iamsang.com/blog/2018/12/27/how-to-work-with-others/</guid>
      <description>
        &lt;p&gt;뒤돌아보면 가장 성장할 수 있었던 때는 다른 생각을 가진 이와 일하던 때였다.&lt;/p&gt;

&lt;p&gt;나와 다른 생각을 가지고 있는 사람과 일하게 되어 힘들었던 적이 있다. 비슷한 생각을 가진 사람을 만났더라면 진행도 빠르고 스트레스도 받지 않을 수 있을텐데 운이 좋지 않다고 생각했다.&lt;/p&gt;

&lt;p&gt;지나고 보니 상대방이 틀릴 가능성 만큼 내 생각이 틀렸을 가능성도 높다는 것을 알게 되었고 지금은 당시 가졌던 생각들 중 많은 부분이 잘못되었다고 생각한다.&lt;/p&gt;

&lt;p&gt;다른 생각을 가진 사람을 만나면 상식이 도전받게 되고 당연하다고 여겼던 것을 다시 돌아보게 된다. 이것이 왜 당연한지 조사하고 내가 옳음을 증명하기 위해 더 많은 정보를 찾게 된다. 그 와중에 당연하다고 생각하던 것이 실제로는 그렇지 않음을 종종 발견한다.&lt;/p&gt;

&lt;p&gt;업무환경에서의 다양성이 생산성을 높인다는 연구결과가 많이 있다. 아마 이와 같은 이유에서일 것이다.&lt;/p&gt;

&lt;p&gt;이제는 그러한 사람을 만나면 &amp;ldquo;이건 또 무슨 말도 안 되는 소리야&amp;rdquo;라며 스트레스를 받기보다는 &amp;ldquo;이거 흥미로운 생각인데&amp;rdquo;라며 발전할 기회가 될지 본다.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>면접에 떨어졌다고 좌절할 필요 없는 이유</title>
      <author>이상현</author>
      <link>https://iamsang.com/blog/2018/08/16/no-interview-frustration/</link>
      <pubDate>Thu, 16 Aug 2018 21:10:42 +0900</pubDate>
      
      <guid>https://iamsang.com/blog/2018/08/16/no-interview-frustration/</guid>
      <description>
        

&lt;blockquote&gt;
&lt;p&gt;Success is not final. Failure is not fatal. &lt;/br&gt;
It is the courage to continue that counts. &lt;/br&gt;
- Winston Churchill&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://youtu.be/hvebAGerh88?t=12m23s&#34;&gt;한 연구결과에 따르면 전문가가 수행한 면접 비디오를 보고 비전문가가 같은 수준으로 판단을 내리는데 걸리는 시간은 단지 10초&lt;/a&gt;였다고 한다.&lt;/p&gt;

&lt;p&gt;면접은 상당한 기술을 요하는 분야이지만 사실상 수준 높은 면접 기술을 가진 면접관은 흔치 않다. 대체로 직급이 올라가 면접을 할 수 있는 위치가 되어 면접을 진행하게 되는 경우가 흔하다.&lt;/p&gt;

&lt;p&gt;면접을 잘 보는 사람은 면접을 잘 보는 사람이다. 교사임용시험에서 가장 높은 성적은 받은 사람이 가장 좋은 선생님이 되지 않듯이 면접을 가장 잘 보는 사람이 가장 실력있는 사람은 아니다.&lt;/p&gt;

&lt;p&gt;이건 모든 시험이 가지고 있는 문제이지만 좋은 해결책이 있진 않다. 짧은 시간 안에 그 사람이 해당 포지션에 잘 맞는지를 알아볼 수 있는 딱히 더 좋은 방법이 없다. 그래서 기업은 면접을 실시한다.&lt;/p&gt;

&lt;p&gt;그러니 면접에서 떨어졌을 때 &amp;ldquo;내 실력이 부족하구나&amp;rdquo; 보다는 &amp;ldquo;그 면접관 사람보는 눈이 없구나&amp;rdquo;라고 생각하는 쪽이 맞을 가능성이 높다.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://iamsang.com/img/interview-question.jpg&#34;  /&gt;
    
    
    &lt;figcaption&gt;
        5년 후 내가 어디에 있을 것 같냐고? 한번만 더 멍청한 질문하면 아마 감옥.
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;



&lt;p&gt;첫 직장 후 두 번 이직을 하는 과정에서 열번 이상 면접을 봤다. 꼭 가고 싶었던 곳도 있었고 그냥 써본 곳도 있었지만 불합격 통보를 받는 것은 대체로 좌절스러운 경험이었다.&lt;/p&gt;

&lt;p&gt;지나서 보니 결국 면접에 실패했던 이유는 면접 경험이 부족했기 때문이었고 면접 경험을 쌓다보니 앞서 떨어졌던 여러 회사보다 더 좋은 회사에 합격하기도 했다.&lt;/p&gt;

&lt;p&gt;예전 레딧에 전 구글러라고 하는 한 개발자가 자격없는 개발자들을 면접보는 것에 질렸다고 하며 퀴즈와 함께 이 다섯 문제를 한시간 안에 풀지 못하면 자신을 개발자라고 부르지도 마라고 하는 블로그 글을 써 논란이 된 적이 있었다.&lt;/p&gt;

&lt;p&gt;해당 글이 유명해지자 문제에 대한 답이라며 이어지는 블로그 글을 올렸는데, 문제는 본인이 올린 퀴즈 중 하나에 틀린 답을 올린 것이다. 그 개발자는 레딧에서 &amp;ldquo;이 친구 자기 자신의 면접에 떨어졌다.&amp;rdquo;, &amp;ldquo;이녀석 앞으로는 자기 자신을 개발자라고 부르면 안되겠다.&amp;ldquo;라는 등의 비난과 조롱을 당해야했다. 나중에 다시 봤을 때 그의 블로그는 폐쇄되어 있었다.&lt;/p&gt;

&lt;p&gt;나도 가끔 면접관으로 면접을 진행하지만 짧은 시간 안에 지원자를 판단할 수 있을거라고 생각하지 않는다. 마찬가지로 누군가가 짧은 시간 안에 나를 알아줄 수 있을거라고 바라지 않는다. 면접에서 떨어졌다고 좌절할 필요없다. 물론 좌절하고 말고가 내 마음대로 쉽게 되지는 않는다.&lt;/p&gt;

&lt;h3 id=&#34;추가로-생각난-몇-가지-에피소드&#34;&gt;추가로 생각난 몇 가지 에피소드&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/brianacton/status/3109544383?lang=en&#34;&gt;2009년 브라이언 액톤이라는 친구는 페이스북 면접에 떨어졌다는 소식을 트위터에 올렸다.&lt;/a&gt; 이후 그는 와츠앱을 공동창업하였고 5년 후 와츠앱은 페이스북에 190억불에 인수되었다. 지금 환율로 계산해보면 대략 21.4조쯤이다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=bx2RWsUX-hI&#34;&gt;일론머스크는 당시 몇 안 되던 인터넷 기업에 취업하고 싶었지만 할 수 없었기 때문에 창업을 했다는 이야기를 한 적 있다.&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>포털 뉴스 보지 않기</title>
      <author>이상현</author>
      <link>https://iamsang.com/blog/2018/06/27/no-portal-news/</link>
      <pubDate>Wed, 27 Jun 2018 23:31:32 +0200</pubDate>
      
      <guid>https://iamsang.com/blog/2018/06/27/no-portal-news/</guid>
      <description>
        &lt;blockquote&gt;
&lt;p&gt;우리는 뉴스에 중독되었다. - 알랭 드 보통&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;미세먼지가 안개처럼 깔린 날이었다. 출근 중이었는데 아침부터 한 외국인이 조깅하고 있었다. 아마 &amp;ldquo;서울은 꽤 안개가 많은 도시구나.&amp;ldquo;라는 생각을 하며 뛰고 있었던 것 같다. 그 모습을 보고 &amp;ldquo;외국에 나가게 되면 꼭 그 나라 뉴스를 잘 챙겨봐야겠구나.&amp;ldquo;라는 생각을 했었다.&lt;/p&gt;

&lt;p&gt;한때 뉴스포털 서비스 개발을 담당했었던 나는 뉴스를 습관처럼 그리고 일처럼 보던 때가 있었다. 뉴스를 보면 시대에 뒤처지지 않는 것 같기도 했고 세상을 보는 눈을 키울 수 있다는 생각도 했던 것 같다. 그리고 무엇보다 뉴스는 재미있었다. 뉴스는 정보를 전달해주기도 하지만 종종 호기심을 자극하며 오락적이기도 하다.&lt;/p&gt;

&lt;p&gt;자극적인 제목이나 섬네일을 가진 뉴스는 인기를 끈다. 인기는 결국 돈으로 이어진다. 그렇기에 뉴스 편집자들은 자극적인 뉴스를 배제할 수 없다. 자극적인 뉴스는 호기심을 자극하고 또 충족시켜주기도 하지만 중요한 뉴스에서 눈을 돌리게 하고 실제보다 과하게 세상을 위험한 곳 혹은 이상한 사람이 넘쳐나는 곳으로 바라보게 만들기도 한다. 지금이 역사상 가장 인간적이며 살기 좋은 시대라는 증거들이 많음에도 불구하고 많은 사람이 세상이 예전보다 위험하고 살기 좋지 않다고 생각하는 이유이기도 하다.&lt;/p&gt;

&lt;p&gt;자극적이고 편파적인 별로 중요하지 않은 이야기들로 가득한 포털 뉴스는 보지 않은 지 오래되었다. 언론사 페이지는 광고로 도배되어 있어 들어가고 싶지 않다. 뉴스를 안 보고 살고 싶지는 않아서 한동안 &lt;a href=&#34;https://www.youtube.com/results?search_query=%EC%95%B5%EC%BB%A4%EB%B8%8C%EB%A6%AC%ED%95%91&amp;amp;page=&amp;amp;utm_source=opensearch&#34;&gt;앵커브리핑&lt;/a&gt;을 챙겨봤다. 하지만 앵커브리핑에 담긴 내용만으로는 뉴스를 이해하는데 어려움이 있었다.&lt;/p&gt;

&lt;p&gt;좋은 뉴스채널을 찾던 중 허핑턴포스트를 보게 되었다. 괜찮은 매체였지만 주제가 한쪽으로 기울어 있는 느낌이었다. 우리 사회에 균형이 맞지 않는 부분을 맞추기 위해 반대편으로 치우쳐져 있는 모습인데, 다양한 뉴스 보다는 중요한 뉴스를 보고 싶은 나에게는 맞지 않았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tantv.com/wp-content/uploads/2015/11/%EB%89%B4%EC%8A%A4%EB%A3%B8-%EC%BA%A1%EC%B3%90-1-900x444.jpg&#34; alt=&#34;JTBC 뉴스룸&#34; /&gt;&lt;/p&gt;

&lt;p&gt;지금 사용하고 있는 것은 JTBC 뉴스 앱이다. 앱의 퀄리티가 형편없어서 예전에 다운로드 받았다가 지웠었는데 선택의 여지가 없어서 다시 쓰고 있다. 콘텐츠는 매우 만족스럽다. JTBC 뉴스룸은 미국의 TV 시리즈 뉴스룸에서 가져온 이름이라고 생각하는데, 이상을 좇는 드라마 속의 저널리스트들처럼 흥행보다는 중요한 정보를 알리는 데 중점을 두려는 노력이 보인다.&lt;/p&gt;

&lt;p&gt;사람들의 관심은 돈이 되고 언론사들은 돈을 위한 뉴스를 만든다. 우리의 입맛이 고급스러워지면 언론사도 변할 수밖에 없다.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>스택오버플로와 해외취업</title>
      <author>이상현</author>
      <link>https://iamsang.com/blog/2018/06/17/stackoverflow-and-overseas-employment/</link>
      <pubDate>Sun, 17 Jun 2018 23:02:07 +0200</pubDate>
      
      <guid>https://iamsang.com/blog/2018/06/17/stackoverflow-and-overseas-employment/</guid>
      <description>
        &lt;blockquote&gt;
&lt;p&gt;질문/답변을 잘하여 좋은 점수를 가지게 되면 개인의 이력에 스택오버플로 활동 이력이 추가됩니다. 혹시 국외로 진출을 목표로 하고 있다면 더없이 좋은 이력 쌓기 방법이라고 볼 수 있습니다. 스택오버플로에서는 자체적으로 이력서 관리 시스템도 제공하고 있습니다(GitHub의 프로젝트도 추가할 수 있습니다)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;약 6년쯤 전에 썼던 &lt;a href=&#34;https://sangdol.github.io/blog/2012/05/30/using-stack-overflow-effectively/&#34;&gt;스택오버플로 활용하기&lt;/a&gt;라는 블로그 글에서 썼던 내용이다. 지금은 이력서 관리 뿐 아니라 구인구직 시스템까지 잘 개발되어 있어 회사를 검색하고 지원하는데도 활용할 수 있다.&lt;/p&gt;

&lt;p&gt;스택오버플로는 베를린에 오기까지 구직활동 중 가장 많이 활용한 사이트이다. 여러가지 장점이 있지만 가장 좋았던 점은 지원하려는 회사가 비자나 리로케이션 지원을 해주는지 등의 정보를 이용해 검색이 가능하다는 점이었다(일반적으로 리로케이션 지원은 이사비용, 비행기 값 그리고 정착에 필요한 도움을 주는 것들을 포함한다).&lt;/p&gt;

&lt;p&gt;이력서 양식도 스택오버플로의 툴을 이용해 만들었고, 지원도 스택오버플로를 통해 하였다. 무엇보다 스택오버플로 활동 이력이 서류통과에 커다란 도움이 되었다고 생각한다.&lt;/p&gt;

&lt;p&gt;지난 6년간 나의 스택오버플로 활동 방법은 조금 바뀌었다.&lt;/p&gt;

&lt;p&gt;초기에는 자바스크립트에 열을 올리고 있던 때라 자바스크립트 질문이 올라오면 빠르게 답을 다는 식이었다. 자바스크립트와 관련된 문제들은 대부분 문제를 상황과 격리하기 쉬웠기 때문에 답하기가 상대적으로 쉬웠다(지금은 리액트나 앵귤러 같은 프레임워크 사용이 일반화되어 그때보다는 까다로운 문제들이 많을 것으로 예상된다).&lt;/p&gt;

&lt;p&gt;답을 적고 채택이 되면 점수나 배지를 얻는 시스템이 매력적이어서 열심히 활동을 했는데, 문제는 나와 같이 활동하는 사람들이 워낙 많다보니 답변하기 좋은 질문이 올라오면 답변을 다는 속도가 중요하다는 것이었다. 그래서 요령있는 사람들은 짧게 답을 달고 조금씩 답을 개선해나가는 방향으로 빠르게 선점하기도 한다. 한 때는 이런 스피드 게임도 나름 재미있다고 생각했으나 어느 순간부터는 자괴감이 들기 시작했다. 다른 사람을 돕고 그 과정에 지식을 얻는 것이 목표였는데 점수를 쌓는데 혈안이 된 나를 발견한 것이다. 마치 게임을 처음 시작할 때는 재미로 했지만 나중에는 점수를 쌓고 레벨을 올리는 것이 목표가 되어 기계적으로 하게되는 것 처럼 말이다. 그래서 실시간으로 올라오는 질문에 대한 답은 달지 않게 되었다.&lt;/p&gt;

&lt;p&gt;지금은 개발 중 검색을 했는데 좋은 답변이 없으면 내가 찾아낸 답을 적는 식으로 활동한다. 예를 들어 개발 중 미스터리한 스프링 순환 참조 오류를 만난적이 있는데 내 상황에 딱 맞는 질문은 있는데 답은 일반적인 것들 뿐이어서 결국 &lt;a href=&#34;https://stackoverflow.com/questions/11348794/spring-circular-reference-example/27210715#27210715&#34;&gt;고민 끝에 알아낸 것을 답변&lt;/a&gt;으로 공유하였다.&lt;/p&gt;

&lt;p&gt;혹은 적당한 답이 있지만 추가적인 정보를 주고 싶어 답을 작성할 때도 있다. 레디스(Redis)에서 두 개 이상의 명령어를 커맨드라인에서 실행하고 싶을 때 파일을 만들어 실행할 수 있다는 답변이 있어서, &lt;a href=&#34;https://stackoverflow.com/questions/10822877/executing-batches-of-commands-using-redis-cli/28981654#28981654&#34;&gt;파일없이 할 수 있는 약간의 Bash 지식을 이용한 답변&lt;/a&gt;을 달았더니 어이없게도 여태까지 쓴 답변 중 가장 인기있는 답변이 되었다. 음악이든 영화든 스택오버플로 답변이든 인기가 퀄리티와 비례하진 않는다.&lt;/p&gt;

&lt;p&gt;스택오버플로 이력을 쌓고 싶다면 빨리 시작하는 것이 좋다. 지금은 새롭게 작성하는 글이 얼마 되지 않는데 점수는 꾸준히 올라가고 있다. 1,000점 대에 질문을 찾아다니며 답변다는 것은 멈췄었는데, 예전에 써놓은 글들이 뿌려놓은 씨처럼 쑥쑥 자라 이제는 8,000점이 넘게 되었고 활동을 거의 안하고 있는데도 기여도 상위 4%가 유지되고 있다. 물론 단순히 점수가 높은 것이 중요하다는 이야기는 아니다.&lt;/p&gt;

&lt;p&gt;엄격한 규칙 때문에 발생하는 폐쇄성에 대한 비난을 하는 사람들도 많다. 개선되어야 하는 부분도 있지만 그 규칙 덕분에 개발자들은 지식인들이 만들어 놓은 수 십 개의 어설픈 질답들을 일일이 클릭해봐야하는 대신 한 두 번의 간단한 검색만으로 수준 높은 답을 찾을 수 있게 되었고, 그런 의미에서 스택오버플로는 현재 인터넷 상에 존재하는 가장 중요한 웹사이트 중 하나이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pbs.twimg.com/media/BnvUvEiIgAAtMf4.png&#34; alt=&#34;StackOverflow is down&#34; /&gt;&lt;/p&gt;

&lt;p&gt;약 7년 전쯤 전 개발자로 일을 시작한지 얼마 안 되었을 때, 어디에 물어봐야할지 몰라 고민하던 중 &lt;a href=&#34;https://stackoverflow.com/questions/6184869/what-is-the-difference-between-memoization-and-dynamic-programming&#34;&gt;메모이제이션과 다이나믹프로그래밍의 차이에 대한 첫 질문&lt;/a&gt;을 올리게 되었다. 한 줄짜리 질문이 지속적인 인기를 얻어 지금은 추천 150개 이상을 받은 질문이 되었다. 아직 초급 개발자라, 혹은 영어에 자신이 없어 답변을 적을 역량이 되지 않는다고 느껴진다면 질문부터 시작하는 것도 좋은 방법이다.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>AI로 대체된 250명의 마케터</title>
      <author>이상현</author>
      <link>https://iamsang.com/blog/2018/05/27/ai-and-marketers/</link>
      <pubDate>Sun, 27 May 2018 20:14:32 +0200</pubDate>
      
      <guid>https://iamsang.com/blog/2018/05/27/ai-and-marketers/</guid>
      <description>
        &lt;p&gt;얼마 전 &lt;a href=&#34;https://www.drapersonline.com/news/zalando-replaces-250-marketing-jobs-with-ai/7029490.article&#34;&gt;마케팅부서에서 일하던 250여명이 정리해고되었다. 알고리즘으로 그들의 일을 대체할 수 있기 때문이라고 한다.&lt;/a&gt; 고용안정이 좋기로 유명한 독일이다.&lt;/p&gt;

&lt;p&gt;규모를 늘려가고 있던 우리 팀은 마케팅 팀이 사용하던 사무실로 이사왔다. 해당 층에 있던 대부분의 직원들이 정리해고되어 남은 자리에는 챙겨가지 않은 물건들이 널려있었다. 입사 5주년을 축하하는 듯한 숫자 5 모양의 풍선이 달려있는 의자가 있었고 생일에 동료들에게 받은듯한 롤링페이퍼 카드가 있었다. 지난 크리스마스 파티 때 동료들과 찍은 즉석 카메라 사진이 있었고, 화이트보드에는 아직 정리되지 않은 토론과 고민의 흔적들이 있었다. 나와 같은 방식으로 생각하고 일하던 동료들이었다.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://iamsang.com/img/bye-square.jpg&#34;  /&gt;
    
    
    &lt;figcaption&gt;
        Bye
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;



&lt;p&gt;얼마 전 있었던 CEO들과의 대화에서 곧 정리해고될 마케터가 질문했다. &amp;ldquo;6년 이상 회사에 헌신했는데 갑작스럽게 정리해고 소식을 들었다. 어떻게 해야하나.&amp;rdquo; CEO는 얼굴이 벌게져서 허둥대며 대답을 했는데 그렇게 좋은 대답은 아니었다. 어떤 대답을 한들 좋은 대답이 될 수 있었을까. 내 또래의 그 CEO는 그날 잠이나 제대로 잘수 있었을까.&lt;/p&gt;

&lt;p&gt;회사의 입장은 충분히 이해한다. 다만 일련의 과정들을 눈 앞에서 생생하게 보니 감정적이 된다. 이것이 앞으로 계속 일어나게 될 일이라고 생각하면 복잡해진다.&lt;/p&gt;

&lt;p&gt;얼마 전 마케팅 부서에서 일하던 사람들에게서 내가 개발했던 구글 어시스턴트 프로젝트에 대해 설명해 달라는 요청이 와 간단한 모임을 가졌었다. 마지막 질문 중 하나가 혹시 프로그래밍 없이 개발가능하냐하는 것이었고, 일반적으로는 불가능하다고 대답하였다. 그랬더니 웅성웅성 프로그래밍을 배워야하나라는 이야기가 오갔다. 뭔가 특별히 만들고 싶은것이 있냐고 물었을때는 이것이 미래인것 같아서 알아놔야겠다고 생각했다고 했다&lt;/p&gt;

&lt;p&gt;지나서보니 그들은 정리해고 대상이 아닌 마케팅팀의 일원이었고 주위 동료들이 알고리즘으로 대체되는 것을 보고는 내가 지금 하고 있는 것만으로 안주해서는 안 되겠다는 생각에 찾아왔었나 하는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;내가 하는 일은 AI로 대체될까? 그것을 알고 대비할 수 있다면 이미 그 사람은 대체 불가능한 사람일 수도 있겠다.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>실리콘밸리보다 베를린인 이유</title>
      <author>이상현</author>
      <link>https://iamsang.com/blog/2017/10/30/berlin-over-silicon-valley/</link>
      <pubDate>Mon, 30 Oct 2017 15:13:00 +0100</pubDate>
      
      <guid>https://iamsang.com/blog/2017/10/30/berlin-over-silicon-valley/</guid>
      <description>
        

&lt;p&gt;작년 9월 아내 그리고 고양이 두 마리와 함께 독일 베를린으로 와 이제 일을 시작한 지 일년쯤 되었다. 여기 오기 직전까지는 비록 근무지는 한국이긴 했으나 실리콘밸리 스타트업 회사에서 이년 반 정도 일을 하였다. 여기에서 짧은 경험과 이전 회사에서의 경험을 바탕으로 실리콘밸리에 비해 베를린이 가진 장점들을 소개해보려 한다.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://iamsang.com/img/brandenburg-gate.JPG&#34;  /&gt;
    
    
    &lt;figcaption&gt;
        베를린 브란덴부르크 문 (Brandenburg Gate) 빛 축제
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;



&lt;h3 id=&#34;비자-지원-기업의-수-베를린-실리콘밸리-124-13&#34;&gt;비자 지원 기업의 수 베를린:실리콘밸리 = 124:13&lt;/h3&gt;

&lt;p&gt;글을 쓰고 있는 2017년 10월 기준으로 스택오버플로에서 검색해보았을 때 구인 중인 기업 중 &lt;a href=&#34;https://stackoverflow.com/jobs?sort=i&amp;amp;q=visa&amp;amp;l=berlin&#34;&gt;베를린에서 비자를 지원해주는 곳은 수는 124&lt;/a&gt;, &lt;a href=&#34;https://stackoverflow.com/jobs?sort=i&amp;amp;q=visa&amp;amp;l=San+Francisco%2C+CA%2C+United+States&amp;amp;d=50&amp;amp;u=Km&#34;&gt;샌프란시스코 지역에서 비자를 지원해주는 곳의 수는 13&lt;/a&gt;. 대략 10배가량 그 수가 많다. 해외에서 채용을 하려는 만큼 독일어를 요구하는 곳은 없다. (왜인지 글을 준비하는 약 일주일정도의 기간동안 115군데에서 124군데로 늘었다.)&lt;/p&gt;

&lt;p&gt;비자를 지원해주는 기업 입사에 성공했다면 비자 문제는 걱정하지 않아도 된다. 나 같은 경우 한국에서 입사 결정 후 비자 없이 베를린에 들어와 회사의 도움을 받아 비자 문제를 해결하였고, &lt;a href=&#34;http://news.chosun.com/misaeng/site/data/html_dir/2017/05/18/2017051800894.html&#34;&gt;무비자 3개월 기간 동안 구직을 하여 비자를 얻는 경우&lt;/a&gt;도 있다. 게다가 4년제 학사 학위와 기본 수준 연봉 이상을 받으면 취득할 수 있는 블루카드라는 것이 있는데, 소지자는 일반적으로 5년이 걸리는 영주권 취득이 33개월 혹은 독일어 실력이 된다면 2년 안에도 가능하다. 블루카드를 소지할 경우 배우자도 일할 수 있는 등 여러 가지 특혜가 있다.&lt;/p&gt;

&lt;p&gt;반면 미국의 경우 비자지원 기업 입사에 성공하더라도 매년 4월에만 비자신청이 가능하고, 신청 후 진행되는 무작위 추첨을 통과하지 못하면 미국내 입국할 수 없다. 추첨에 통과하더라도 10월이 되어서야 입국이 가능하다.&lt;/p&gt;

&lt;h3 id=&#34;일과-삶의-균형-연간-노동시간이-가장-짧은-독일&#34;&gt;일과 삶의 균형, 연간 노동시간이 가장 짧은 독일&lt;/h3&gt;

&lt;p&gt;최근 구글 어시스턴트 프로젝트에 참여했다. 구글과 협업을 해서 구글 어시스턴트 독일 출시에 맞춰 앱을 개발해야 하는 업무였다. 일정이 빠듯하게 고정되어 있다보니 독일 온 이후로는 해본 적 없던 야근이나 주말 근무도 하였다. 입사 후 처음으로 리드하게된 프로젝트였기 때문에 몸은 조금 피곤했지만 즐겁게 일 할 수 있었다.&lt;/p&gt;

&lt;p&gt;프로젝트가 마무리 되었을 때 즈음에 팀 리드가 나에게 와서 이야기하였다. &amp;ldquo;초과 근무한 부분에 대해서는 시간 단위로 다 보상해줄 테니 근무한 내용을 적어서 이메일로 보내주세요. (보상을 받지 못하는) 초과근무를 해서는 안 됩니다.&amp;rdquo; 주말 근무가 예정되어 있었던 주 금요일에는 나에게 와서 &amp;ldquo;주말에 근무하는 것이 괜찮겠어요? 괜찮지 않다면 나에게 이야기해도 됩니다.&amp;ldquo;라고 나에게 물어봐 주었다.&lt;/p&gt;

&lt;p&gt;실리콘밸리에 있는 구글 본사에 다니고 있는 친구가 이런 이야기를 한 적이 있다. &amp;ldquo;여기 워커홀릭이 많아서 거기에 맞춰서 일할 수밖에 없게 된다. 주말 새벽에 이메일이 오는 경우도 많다.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;이곳에서는 일과 삶을 분리하는 것을 당연하게 여긴다. 업무시간 이외에 이메일이나 메신저를 확인하지 않는 것이 전혀 문제 되지 않는다.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://iamsang.com/img/berlin-park-hammock.JPG&#34;  /&gt;
    
    
    &lt;figcaption&gt;
        베를린 공원에서 책 읽는 청년
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;



&lt;h3 id=&#34;쉬운-커뮤니케이션&#34;&gt;쉬운 커뮤니케이션&lt;/h3&gt;

&lt;p&gt;해외 진출을 생각할 때 가장 어려운 부분이 언어이다. 독일은 영어가 모국어가 아닌 나라이므로 영어를 완벽하게 구사하는 사람은 드물다. 지금 내가 속해 있는 팀원 약 15명 중 영어가 모국어인 사람은 미국에서 온 단 한 명뿐이다. 다들 영어가 완벽하지 않으니 영어사용 중 단어가 잘 기억이 나지 않거나 문법적인 오류가 발생하는 부분에 대해 서로 당연하게 생각한다.&lt;/p&gt;

&lt;p&gt;다른 사람의 영어를 듣고 이해하기에도 더 쉽다. 영어를 잘하는 사람이 듣는다면 부족한 발음이나 문법 때문에 오히려 이해가 더 어려울 수 있겠지만 영어가 모국어가 아닌 사람의 입장에서는 발음도 더 쉽게 들리고 표현도 쉬우니 소통하기가 더 수월하다.&lt;/p&gt;

&lt;h3 id=&#34;다양한-문화에서-온-모험심과-포용력이-있는-동료들&#34;&gt;다양한 문화에서 온 모험심과 포용력이 있는 동료들&lt;/h3&gt;

&lt;p&gt;현재 13명인 나의 팀 구성원들의 출신을 보면 포르투갈, 이집트, 벨라루스, 이탈리아, 미국, 스페인, 프랑스, 아제르바이잔 그리고 독일이다. 이렇게 다양한 문화들이 공존하다 보니 모두들 다양성을 존중하고 중요하게 생각한다. 팀 행사 후 피자를 시켜먹은 적이 있는데 피자 주문을 맡은 팀원은 고기가 들어있지 않는 채식주의자를 위한 피자, 돼지고기가 들어있지 않은 무슬림을 위한 피자 그리고 다양한 고기토핑이 있는 피자 세 종류를 주문한 뒤 이야기했다. &amp;ldquo;피자 중에는 채식주의자 피자, 돼지고기가 없는 피자, 그리고 모든 것을 다 먹는 사람을 위한 피자들이 있어요. 가리지 않고 드시는 분들은 조금 더 늦게 가서 피자를 드시기 바랍니다.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;다양한 문화는 단순히 다양성을 존중한다는 의미뿐 아니라 대부분의 동료가 자기 자리에 만족하지 않고 새로운 경험이나 기회를 위해 기꺼이 해외 진출을 할 만큼 진취적이라는 뜻도 가진다. 새로운 것을 배우는 것을 즐기는 열정 있는 동료들과 일할 수 있는 것은 멋진 일이다.&lt;/p&gt;

&lt;p&gt;물론 실리콘밸리도 다양한 문화를 가지고 있다. 샌프란시스코 공항에 내렸을 때 유색인종이 백인들보다 더 많이 눈에 띄는 것을 보고 신기해했던 기억이 있다. &lt;a href=&#34;http://www.washingtonexaminer.com/37-percent-of-silicon-valley-foreign-born/article/2583195&#34;&gt;실리콘밸리에서는 기술산업의 37%가 외국 출신이라고 한다.&lt;/a&gt; 하지만 현재 대다수 개발자를 해외에서 수급하고 있는 독일만큼은 아닌 듯하다.&lt;/p&gt;

&lt;h3 id=&#34;빠르게-성장하고-있는-개발-생태계-feat-브렉시트&#34;&gt;빠르게 성장하고 있는 개발 생태계 feat. 브렉시트&lt;/h3&gt;

&lt;p&gt;불과 십 년 전까지만 해도 수십 개 수준이었던 스타트업의 수가 지금은 2,500개가량으로 늘어났다. 물론 16,000개에 달하는 실리콘밸리에 비할 수준은 아직 아니지만 상당한 속도로 생태계가 커지고 있으며 투자자금도 들어오고 있다. 얼마 전까지만 해도 스타트업에게 &amp;ldquo;가난하지만 매력적인&amp;rdquo; 도시였다면 이제는 &amp;ldquo;그냥 매력적인&amp;rdquo; 도시가 되었다(&lt;a href=&#34;http://www.dw.com/en/a-look-behind-and-beyond-berlins-startup-scene/a-40365808&#34;&gt;From &amp;ldquo;poor, but sexy&amp;rdquo; to &amp;ldquo;just sexy&amp;rdquo;&lt;/a&gt;). 유럽의 테크 허브인 런던이 브렉시트로 인해 불안정해진 것도 베를린의 성장에 도움을 주고 있다.&lt;/p&gt;

&lt;p&gt;덕분에 수많은 개발 관련 행사들이 베를린에서 열리며 Meetup 커뮤니티도 많고 다양하다. Meetup 행사에 가면 개발자들에게 회사를 홍보하고 싶어하는 후원사가 제공하는 다양한 음식과 맥주를 맛보며 자리를 즐길 수 있다. 최근 페이스북에서 주최한 Machine Learning, AI and Chatbot 행사에 방문했었는데 그곳에서는 다양한 음식들과 수제생맥주를 제공하고 있었고, 주최측에서는 예상보다 많은 사람이 오는 바람에 음식이 다 떨어져 미안하다며 급히 피자를 주문해주었다. 이와 같은 행사들이 대부분 무료이다.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://iamsang.com/img/facebook-event.jpg&#34;  /&gt;
    
    
    &lt;figcaption&gt;
        페이스북 이벤트
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;



&lt;h3 id=&#34;도시-내외로의-접근성-그리고-유럽여행&#34;&gt;도시 내외로의 접근성 그리고 유럽여행&lt;/h3&gt;

&lt;p&gt;베를린은 대중교통이 잘 발달해있는 도시이다. 전철, 트램, 버스가 자주 다니며 주말에는 24시간 운행을 하는 구간도 많다. 중심지가 집약되어 있어 출퇴근에 1시간 이상 들이는 사람이 많지않다. 상대적으로 낮은 집값도 접근성을 높여준다. 높은 임금을 고려하더라도 실리콘밸리라면 시내 중심에 집을 구하는 것이 매우 어렵지만, 베를린에서는 그렇게 어려운 일이 아니며 중심에서 30분 정도 거리만 나가도 집값이 많이 내려간다.&lt;/p&gt;

&lt;p&gt;베를린에서는 프라하까지 기차로 4시간이면 갈 수 있다. 프라하는 물가도 저렴한 편이라 서울에서 부산 여행하는 것보다 싸게 여행할 수 있다. 그 외 파리, 로마, 빈, 암스테르담 등 대부분의 유럽 도시도 비행기로 1~3시간 이내에 방문할 수 있다.&lt;/p&gt;

&lt;p&gt;실리콘밸리는 꽤 넓은 지역에 기업들이 분산되어 있고 기본적으로 차가 없으면 살기 어려운 곳이다. 주변에 좋은 관광지들이 있지만 다른 나라로 가서 다른 문화를 경험하고 싶을 땐 긴 시간을 비행해야 가능하다.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://iamsang.com/img/berlin-park-bench.JPG&#34;  /&gt;
    
    
    &lt;figcaption&gt;
        베를린의 한 공원
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;



&lt;h3 id=&#34;복지와-고용안정성&#34;&gt;복지와 고용안정성&lt;/h3&gt;

&lt;p&gt;독일에 온 후 몇 가지 검사를 받을 일이 있어 병원에 몇 번 갈일이 있었는데 한번도 돈을 낸 적이 없다. 마치 대학교에서 교수님을 만나 상담을 받고 나오는 느낌이었다. 아내도 감기나 비염 등의 문제로 병원을 몇 차례 갔었는데 한 번도 돈을 내지 않았다. 병원의 모든 서비스가 무료는 아니지만, 기본적으로 많은 부분이 무료이다. 미국의 의료비 문제는 굳이 설명하지 않아도 될 것이라고 생각한다.&lt;/p&gt;

&lt;p&gt;이곳에서는 입사 후 일반적으로 6개월간의 수습과정을 거치는데 수습 기간 후에는 정사원되고, 정사원이 된 근로자를 해고하기는 쉽지 않다. 노동유연성이 높은 미국과는 다른 모습이다.&lt;/p&gt;

&lt;p&gt;물론 베를린에 장점만 있는 것은 아니다. 흐린 날이 많아 일조량은 영국 런던과 맞먹고 겨울은 길고 추우며 습하다. 일상생활 속에서 기본적인 영어가 통하지만 독일어가 필요할 때도 많다. 열차가 서고 문제가 생겼다는 방송을 해도 알아들을 수가 없으니 누군가에게 물어보거나 눈치껏 행동할 수밖에 없다.&lt;/p&gt;

&lt;p&gt;하지만 맛있는 맥주, 다양한 클럽, 예술문화, 풍부한 녹지 등 앞서 소개하지 않은 많은 장점까지 생각해본다면 베를린은 실리콘밸리의 매력을 넘기에 충분히 멋진 도시임이 틀림없다.&lt;/p&gt;

&lt;p&gt;팀원 중 베를리너인 친구에게 &amp;ldquo;세계 어느 도시에 살아 보고싶어?&amp;ldquo;라고 물어본 적이 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;꼭 다른 도시에 살아야해? 나는 베를린에 계속 살고 싶어. 다른 곳에서 살고 싶지 않아.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;참고자료&#34;&gt;참고자료&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.99designs.de/blog/business/berlin-silicon-allee-vs-silicon-valley-infographic/&#34;&gt;Europe’s new Silicon Valley [infographic]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.washingtonexaminer.com/37-percent-of-silicon-valley-foreign-born/article/2583195&#34;&gt;37 percent of Silicon Valley foreign-born&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.dw.com/en/a-look-behind-and-beyond-berlins-startup-scene/a-40365808&#34;&gt;A look behind, and beyond, Berlin&amp;rsquo;s startup scene&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>카페 네트워크 트러블슈팅</title>
      <author>이상현</author>
      <link>https://iamsang.com/blog/2017/09/08/network-troubleshooting-in-a-cafe/</link>
      <pubDate>Fri, 08 Sep 2017 04:53:40 +0200</pubDate>
      
      <guid>https://iamsang.com/blog/2017/09/08/network-troubleshooting-in-a-cafe/</guid>
      <description>
        

&lt;p&gt;집 근처 카페에서 와이파이 연결 후 인터넷 접속을 하려는데 안 된다. 책이나 읽어야겠다고 생각하고 잠시 책을 보다가 지루해져서 왜 안 되는지 알아보기로 했다.&lt;/p&gt;

&lt;p&gt;아이피는 잘 할당되었나?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;en0: flags=8863&amp;lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&amp;gt; mtu 1500
  inet6 fe80::c88:d8dc:9818:3458%en0 prefixlen 64 secured scopeid 0x4
  inet 192.168.179.43 netmask 0xffffff00 broadcast 192.168.179.255
  nd6 options=201&amp;lt;PERFORMNUD,DAD&amp;gt;
  media: autoselect
  status: active
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아이피가 잘 할당된 것을 보니 공유기가 동작은 하는 듯하다.&lt;/p&gt;

&lt;p&gt;어디에서 막히는지를 볼까.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ traceroute google.com
traceroute: unknown host google.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;호스트를 못찾는다. DNS 검색 시도.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ dig google.com

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.8.3-P1 &amp;lt;&amp;lt;&amp;gt;&amp;gt; google.com
;; global options: +cmd
;; connection timed out; no servers could be reached
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DNS 서버로 접근 자체를 못하고 있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ko.wikipedia.org/wiki/%EA%B5%AC%EA%B8%80_%ED%8D%BC%EB%B8%94%EB%A6%AD_DNS&#34;&gt;구글 퍼블릭 DNS 서버&lt;/a&gt;로 연결이 잘 되는지 확인.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ping 8.8.8.8
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: icmp_seq=0 ttl=46 time=36.443 ms
64 bytes from 8.8.8.8: icmp_seq=1 ttl=46 time=34.619 ms
64 bytes from 8.8.8.8: icmp_seq=2 ttl=46 time=34.496 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DNS 서버로 연결은 되고 있다. 외부 인터넷으로 연결은 되고있다는 뜻이다. 문제는 DNS 검색. 네트워크 DNS 설정에 가보니 이전에 설정해놓은 구글 DNS 서버 IP들이 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://iamsang.com/img/network-dns-settings.png&#34; alt=&#34;네트워크 DNS 세팅&#34; /&gt;&lt;/p&gt;

&lt;p&gt;해당 목록을 제거하고 설정을 적용한 후 다시 인터넷에 접속하니 잘 된다.&lt;/p&gt;

&lt;h3 id=&#34;왜-dns-서버를-수동으로-설정했을땐-안-되었을까&#34;&gt;왜 DNS 서버를 수동으로 설정했을땐 안 되었을까?&lt;/h3&gt;

&lt;p&gt;일부 네트워크에서는 특정 도메인으로 접근을 막는 등의 통제를 위해 또는 &lt;a href=&#34;https://ko.wikipedia.org/wiki/DNS_%EC%8A%A4%ED%91%B8%ED%95%91&#34;&gt;DNS 스푸핑&lt;/a&gt;과 같은 공격으로부터 보호하기 위해 외부 DNS 서버로의 접근을 막는 경우가 있다.&lt;/p&gt;

&lt;h3 id=&#34;그렇다면-왜-특정-구글-dns-서버를-사용하나&#34;&gt;그렇다면 왜 특정(구글) DNS 서버를 사용하나?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.dnsimple.com/2015/03/why-and-how-to-use-googles-public-dns/&#34;&gt;구글 DNS 서버는 빠르고 안전하며 쿼리에 대한 정확한 결과를 내어준다&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;2014년 터키 시위 당시 정부에서 시민들의 트위터로의 접근을 막기 위해 ISP의 DNS를 조작하였는데, 시민들이 구글 DNS를 이용하여 접속을 하기도 하였다. 정부는 결국 구글 DNS로의 접근도 막았다.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://iamsang.com/img/dns-giraffiti.jpg&#34;  /&gt;
    
    
    &lt;figcaption&gt;
        구글 DNS 아이피를 적은 그라피티
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;



&lt;p&gt;DNS 서버를 수동으로 설정해 놓는 것은 좋은 생각일 수 있다. 하지만 일부 네트워크에서는 문제가 될 수 있으니 주의해야한다.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>프로젝트 출시 10일 후 새벽 4시에 발생한 장애의 원인</title>
      <author>이상현</author>
      <link>https://iamsang.com/blog/2017/05/27/server-failure-10-days-after-release/</link>
      <pubDate>Sat, 27 May 2017 21:03:08 +0200</pubDate>
      
      <guid>https://iamsang.com/blog/2017/05/27/server-failure-10-days-after-release/</guid>
      <description>
        &lt;p&gt;약 3년 반 전 2013년 겨울, 맡고 있던 모바일웹 프로젝트 출시 후 문제없이 돌아가던 서버에서 10일이 지난 새벽 4시 2분에 장애가 발생했다. 출근했을 때에는 이미 시스템엔지니어링팀에서 서버를 재시작하여 문제는 복구된 상태였다. 별다른 로그는 없었고 단서는 문제가 발생했을 때 스크린캡처한 404 페이지 화면 밖에 없었다.&lt;/p&gt;

&lt;p&gt;정확한 원인이 무엇인지 찾아내지 않으면 언제 다시 문제가 발생할지 모르는 상황.&lt;/p&gt;

&lt;p&gt;서버 구성은 다음과 같았다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;센트OS 서버 운영체제&lt;/li&gt;
&lt;li&gt;엔진엑스 웹서버&lt;/li&gt;
&lt;li&gt;스프링부트+제티 스탠드얼론 웹애플리케이션 서버 (이하 WAS)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;당시까지만 해도 스프링부트(Spring Boot)가 베타 버전이었기 때문에 프로덕션에서는 활발히 사용되고 있지 않았고 스탠드얼론(Standalone) WAS 서버도 흔치 않았다. 나에게는 톰캣이 익숙했지만, 당시 그래들(Gradle)에는 스탠드얼론 서버를 운용할 수 있는 임베디드 톰캣 플러그인이 없었기 때문에 제티를 선택했다.&lt;/p&gt;

&lt;p&gt;사내에서는 처음 시도된 방식이었고 서버구조나 운용방법도 새로웠다. 설정파일 관리, 배포방식, 스태이징(Staging) 서버 관리 등 기존 구조가 가지고 있던 많은 불편한 부분들을 해소할 수 있도록 설계하였기 때문에 위험할 수 있는 새로운 시도임에도 시스템엔지니어링팀에서도 지지해 주었다.&lt;/p&gt;

&lt;p&gt;유일한 단서인 404 페이지를 유심히 보았다. 레이아웃이 깨어져 있었다. CSS와 이미지 파일 로딩이 안 된 것이다. 404 페이지의 HTML은 엔진엑스에서 제공되고 있었고 CSS와 이미지 파일은 WAS와 함께 있었다. 서버에 단순히 에러가 생긴 것이 아니고 파일들이 사라진 것이다.&lt;/p&gt;

&lt;p&gt;파일들이 갑자기 왜 사라졌을까. 지금 WAS 관련 파일들이 어디에 저장되고 있지? 약간의 조사 후 &lt;a href=&#34;https://stackoverflow.com/questions/7011940/how-to-configure-a-webapps-deployment-directory-in-jetty&#34;&gt;명시적으로 WAR(Web application ARchive) 파일 압축을 풀 디렉터리를 설정하지 않으면 &lt;code&gt;/tmp/jetty&lt;/code&gt; 디렉토리에 압축이 풀린다는 사실을 알게되었다&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;그럼 센트OS에서 &lt;code&gt;/tmp&lt;/code&gt; 디렉토리는 어떻게 관리되지?&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://unix.stackexchange.com/a/118794/8610&#34;&gt;센트OS 6에서 &lt;code&gt;/tmp&lt;/code&gt; 디렉토리의 10일 이상 된 파일들은 &lt;code&gt;tmpwatch&lt;/code&gt; 명령어에 의해 삭제된다&lt;/a&gt;. &lt;a href=&#34;https://linux.die.net/man/8/tmpwatch&#34;&gt;&lt;code&gt;tmpwatch&lt;/code&gt;&lt;/a&gt;는 &lt;code&gt;cron.daily&lt;/code&gt;의 일부로 들어가 있고, &lt;a href=&#34;https://www.centos.org/docs/5/html/5.2/Deployment_Guide/s2-autotasks-cron-configuring.html&#34;&gt;&lt;code&gt;/etc/crontab&lt;/code&gt; 파일을 살펴보면&lt;/a&gt; 다음과 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;01 * * * * root run-parts /etc/cron.hourly
02 4 * * * root run-parts /etc/cron.daily
22 4 * * 0 root run-parts /etc/cron.weekly
42 4 1 * * root run-parts /etc/cron.monthly
&lt;/code&gt;&lt;/pre&gt;

      </description>
    </item>
    
    <item>
      <title>블로그 리브랜딩 &amp; 텀블러에서 깃헙페이지&#43;휴고(Hugo)로</title>
      <author>이상현</author>
      <link>https://iamsang.com/blog/2017/05/22/blog-rebranding-and-from-tumblr-to-github-page-and-hugo/</link>
      <pubDate>Mon, 22 May 2017 04:28:15 +0200</pubDate>
      
      <guid>https://iamsang.com/blog/2017/05/22/blog-rebranding-and-from-tumblr-to-github-page-and-hugo/</guid>
      <description>
        

&lt;p&gt;베를린으로 취업해 이사 온 지 약 여덟달쯤 되었다. 앞으로는 단순한 개발이야기 뿐만 아니라 베를린, 독일, 유럽, 해외취업 등과 관련된 주제로 글을 쓸 예정이다.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://iamsang.com/img/berlin-spring-2.jpg&#34;  /&gt;
    
    
    &lt;figcaption&gt;
        베를린의 봄
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;



&lt;p&gt;기존의 블로그명 Flow on Web은 없애고 나의 이름을 넣었다. Flow on Web은 Joel on Software를 따라한 것이었다. 당시에는 우리 문화에서 사람의 이름을 제목에 넣는 것이  어색하다고 느껴져서 미하이 칙센트미하이의 몰입(Flow)과 흐름이라는 이중적인 뜻으로 이름을 만들었다. 지금에 와서 보니 나와 가장 밀접하게 연결되어 있으면서 시간이 지나도 변하지 않을 나의 이름을 사용하는 것이 낫겠다는 생각이 들었다.&lt;/p&gt;

&lt;h3 id=&#34;텀블러에서-깃헙-정적생성툴로&#34;&gt;텀블러에서 깃헙+정적생성툴로&lt;/h3&gt;

&lt;p&gt;오랫동안 미루고 있던 블로그 이전을 시작하게 된 것은 flowonweb.com 도메인이 만료된다는 소식을 들었기 때문이었다. 비싸다고 할 수는 없는 비용이지만 도메인을 유지하는 것이 무의미해 보였다. 나 이외에는 아무도 블로그에 주소를 치고 들어오지 않을 것이고, 깃헙이라면 도메인 자체의 이미지도 좋아 보였다.&lt;/p&gt;

&lt;p&gt;텀블러를 떠나 정적사이트생성툴(Static Site Generator)을 선택한 이유는 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;자유로운 블로그 디자인: 구조를 바꾸거나 디자인을 하는 데에 제약이 없다.&lt;/li&gt;
&lt;li&gt;능률적인 글쓰기 및 개발환경: Vim을 이용해 글을 쓰거나 코딩을 한 후 매번 다시 복사해야 할 필요 없이 바로 수정된 사항을 확인하고 배포할 수 있다.&lt;/li&gt;
&lt;li&gt;No GUI: 관리나 설정을 웹브라우저가 아닌 터미널 환경에서 할 수 있어 효율적이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;지킬-jekyll-대신-휴고-hugo-로&#34;&gt;지킬(Jekyll) 대신 휴고(Hugo)로&lt;/h3&gt;

&lt;p&gt;일반적으로 깃헙페이지와 함께 사용하는 지킬 대신 &lt;a href=&#34;https://gohugo.io/&#34;&gt;휴고&lt;/a&gt;를 사용했다. 루비 기반으로 만들어진 지킬 보다는 Go 언어로 만들어진 휴고가 성능 면에서 뛰어나고 의존성 문제가 없기 때문이다.&lt;/p&gt;

&lt;p&gt;다양한 정적사이트생성툴들의 인기, 개발언어 등을 한눈에 비교해 보고 싶다면 &lt;a href=&#34;https://www.staticgen.com/&#34;&gt;StaticGen&lt;/a&gt;에서 볼 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;리디자인&#34;&gt;리디자인&lt;/h3&gt;

&lt;p&gt;디자인은 다양한 곳을 참고하였다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;기본 틀은 &lt;a href=&#34;https://github.com/nishanths/cocoa-hugo-theme&#34;&gt;Cocoa&lt;/a&gt;라는 테마를 활용했다.&lt;/li&gt;
&lt;li&gt;기존에는 하이퍼링크의 밑줄을 앵커태그의 스타일로 주었었는데, CSS의 &lt;code&gt;border&lt;/code&gt; 속성을 이용한 스타일이 깔끔해 보여서 부츠스트랩을 개발한 &lt;a href=&#34;http://markdotto.com&#34;&gt;Mark Otto의 블로그&lt;/a&gt;와 AWS 관련 내용을 잘 정리해 올려주는 &lt;a href=&#34;http://start.jcolemorrison.com/&#34;&gt;J Cole Morrison의 블로그&lt;/a&gt;를 참고하여 넣었다.&lt;/li&gt;
&lt;li&gt;지금 보고 있는 이 리스트 스타일은 &lt;a href=&#34;https://www.joelonsoftware.com/&#34;&gt;조엘온소프트웨어 블로그&lt;/a&gt;에서 CSS를 참고하였다. 불릿기호와 글자 간의 간격을 좁히는 방법을 스택오버플로를 검색해봐도 찾을 수 없었는데, 아이러니하게도 조엘의 블로그에서 찾을 수 있었다.&lt;/li&gt;
&lt;li&gt;파비콘은 &lt;a href=&#34;http://www.pixelmator.com/mac&#34;&gt;픽셀메이터&lt;/a&gt;를 이용해 직접 만들어보았다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다른 이의 블로그에 들어 갔을 때 한눈에 어떤 글들이 있는지 볼 수 있는 것을 좋아하기 때문에 첫 화면은 제목만 나열하는 방식을 유지했다.&lt;/p&gt;

&lt;h3 id=&#34;공백&#34;&gt;공백&lt;/h3&gt;

&lt;p&gt;약 5년 전 블로그를 시작하고 2년쯤 가끔이나마 글을 쓰다가 멈추었다. 근무지는 서울이었지만 실리콘밸리의 직원들과 함께 일할 수 있는 곳으로 이직을 하게 되면서 여가시간에는 영어학습에 집중하려고 했기 때문이다. 업무효율을 높이기 위해서이기도 했지만 해외진출을 하려는 이유가 컸다. 아직 영어공부는 계속하고 있지만 이제는 잠시 숨을 돌리고 가끔 블로그를 써도 되겠다는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;지금 관심 분야는 AWS, 마이크로서비스, 쿠버네티스, 도커, 클라우드 컴퓨팅 등 이전 회사에서는 거의 쓰지 않았지만 지금 회사에서는 활발하게 쓰고 있는 다양한 인프라스트럭처와 관련된 기술들이다. 외에 현재 진행하고 있는 프로젝트는 아마존의 음성인식 서비스 알렉사와 연동되는 애플리케이션인데 추후 관련된 내용도 다뤄볼 예정이다.&lt;/p&gt;

&lt;p&gt;기존에 쓴 글도 방문자도 얼마 되지 않는 개인블로그에서 리브랜딩이니 리디자인이니 하는 게 우스워 보이기도 하지만 어차피 자기만족이고 블로그를 이전하며 새롭게 만드는 과정은 꽤 즐거웠다.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>ack: 개발자용 grep</title>
      <author>이상현</author>
      <link>https://iamsang.com/blog/2014/11/22/ack/</link>
      <pubDate>Sat, 22 Nov 2014 17:10:42 +0900</pubDate>
      
      <guid>https://iamsang.com/blog/2014/11/22/ack/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;http://beyondgrep.com/&#34;&gt;ack&lt;/a&gt;는 beyond grep이라는 부재를 가지고 있는 툴로 grep의 발전된 버전이다. 패키지 매니저를 통해 &lt;a href=&#34;http://beyondgrep.com/install/&#34;&gt;다양한 OS에서 쉽게 설치 가능한데&lt;/a&gt;, OSX에서는 brew를 이용해 설치 가능하다.&lt;/p&gt;

&lt;pre class=&#34;prettyprint&#34;&gt;
$ brew install ack
&lt;/pre&gt;

&lt;p&gt;grep 대신 ack를 사용하는 이유는 여러가지가 있는데, 먼저 간편한 사용법이 있다. 프로젝트에서 grep을 이용해 &amp;lsquo;tooltip&amp;rsquo;이라는 단어를 검색하려면 아래와 같이 옵션과 디렉토리를 인자가 필요한데&lt;/p&gt;

&lt;pre class=&#34;prettyprint&#34;&gt;
$ grep -rn tooltip .
&lt;/pre&gt;

&lt;p&gt;ack를 이용하면 아래와 같이 간단히 할 수 있다.&lt;/p&gt;

&lt;pre class=&#34;prettyprint&#34;&gt;
$ ack tooltip
&lt;/pre&gt;

&lt;p&gt;여기서 ack는 기본적으로 &lt;code&gt;.git&lt;/code&gt;, &lt;code&gt;.svn&lt;/code&gt;과 같은 디렉토리 등을 무시하기 때문에 해당 폴더가 있는 경우에도 따로 처리해 줄 필요가 없다.&lt;/p&gt;

&lt;p&gt;ack도 다양한 옵션을 제공하고 있어 필요에 맞게 쓰려면 옵션 값을 넘겨줘야한다. 하지만 ack는 &lt;a href=&#34;http://stackoverflow.com/questions/11030552/what-does-rc-mean-in-dot-files&#34;&gt;rc 파일&lt;/a&gt;을 통한 환경변수 설정이 가능해 상시 쓰는 옵션들을 넣어둘 수 있다. 예를 들어 결과 내용에 색을 넣어주는 &lt;code&gt;--color&lt;/code&gt; 옵션, 결과를 페이징해서 볼 수 있게 해주는 &lt;code&gt;--pager&lt;/code&gt; 옵션, 특정 디렉토리를 무시하는 &lt;code&gt;--ignore-dir&lt;/code&gt; 옵션 등을 넣어둘 수 있다. rc 파일은 &lt;code&gt;~/.ackrc&lt;/code&gt; 위치에 두면 된다. rc 파일 설정이 귀찮다면 일단 &lt;a href=&#34;https://github.com/Sangdol/prezto/blob/master/runcoms/ackrc&#34;&gt;남의 ackrc 파일&lt;/a&gt;을 복붙하고 약간 손봐서 사용하는 것도 좋은 방법이다.&lt;/p&gt;

&lt;p&gt;ack를 사용하면 검색 결과를 한눈에 볼 수 있어 개발 중 가장 많이 사용하는 명령어 중 하나인데, &lt;code&gt;ABC&lt;/code&gt; 옵션을 사용하면 좀 더 유연한 활용이 가능하다. &lt;code&gt;A&lt;/code&gt;는 after, &lt;code&gt;B&lt;/code&gt;는 before는 &lt;code&gt;C&lt;/code&gt;는 after+before로, 검색된 단어의 위아래 줄들을 함께 보고 싶을 때 사용할 수 있다. 예를 들어 TODO가 어떤 코드에 붙어 있는지 보고 싶다면 아래와 같이 하면 된다.&lt;/p&gt;

&lt;pre class=&#34;prettyprint&#34;&gt;
$ ack -A3 TODO
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://31.media.tumblr.com/168894b87329005cb3f354a5facefa68/tumblr_inline_nfhwolJm0n1qimauz.png&#34; alt=&#34;bootstrap 프로젝트에서 TODO 검색&#34; /&gt;&lt;/p&gt;

&lt;p&gt;명령어와 옵션 사용에 익숙해지면 더 다양한 활용이 가능하다. 예를 들어 &amp;lsquo;console&amp;rsquo;이라는 문자열을 &amp;lsquo;TODO&amp;rsquo;를 포함한 파일들 중에서만 검색해보고 싶다면 아래와 같이 할 수 있다.&lt;/p&gt;

&lt;pre class=&#34;prettyprint&#34;&gt;
$ ack console $(ack -l TODO)
&lt;/pre&gt;

      </description>
    </item>
    
    <item>
      <title>Git bisect를 이용하여 버그발생시점 찾아내기</title>
      <author>이상현</author>
      <link>https://iamsang.com/blog/2014/03/02/git-bisect/</link>
      <pubDate>Sun, 02 Mar 2014 17:10:42 +0900</pubDate>
      
      <guid>https://iamsang.com/blog/2014/03/02/git-bisect/</guid>
      <description>
        &lt;p&gt;버그가 발생했는데 도저히 무엇이 원인인지, 언제 어떤 부분에서 이루어진 수정으로 인해 문제가 발생했는지 감을 잡을 수 없을 때가 있다.&lt;/p&gt;

&lt;p&gt;이런 상황에서 활용할 수 있는 것이 &lt;a href=&#34;http://git-scm.com/book/en/Git-Tools-Debugging-with-Git#Binary-Search&#34;&gt;git bisect&lt;/a&gt;이다. &lt;code&gt;git bisect&lt;/code&gt;는 이진검색을 이용해 버그 발생 시점을 찾아내는 방법이다. 원인을  예상할 수 없는 문제가 발생했을 때, 의심되는 파일의 코드를 반씩 잘라내가며 수동 이진검색 디버깅을 했던 적이 있는데, &lt;code&gt;git bisect&lt;/code&gt;를 잘 활용하면 이런 수고를 덜 수 있다.&lt;/p&gt;

&lt;p&gt;사용법은 간단하다. 아래와 같은 커밋이 있다고 하자. 문제 발생 시점은 커밋 4이고, 현재 위치는 커밋 6이다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.. - 0 - 1 - 2 - 3 - 4* - 5 - (6)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git bisect&lt;/code&gt;를 이용해 문제 위치를 찾아보자. 먼저 문제가 없던 지점을 대략적으로 찾는다. 커밋 0에서는 문제가 없다고 확인되었을 때 다음과 같이 명령을 날린다.&lt;/p&gt;

&lt;pre class=&#34;prettyprint&#34;&gt;
$ git bisect start
$ git bisect bad
$ git bisect good 0
Bisecting: 2 revisions left to test after this (roughly 2 steps)
[3] &lt;comment&gt;&lt;/comment&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;.. - 0 - 1 - 2 - (3) - 4* - 5 - HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git bisect&lt;/code&gt; 명령을 통해 현재 시점과 커밋 0의 중간 지점인 커밋 3 시점으로 이동되었다. 커밋 3에서는 문제가 재현되지 않을테니 다음과 같이 good 명령을 날린다.&lt;/p&gt;

&lt;pre class=&#34;prettyprint&#34;&gt;
$ git bisect good
Bisecting: 0 revisions left to test after this (roughly 1 step)
[5] &lt;comment&gt;&lt;/comment&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;.. - 0 - 1 - 2 - 3 - 4* - (5) - HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이번에는 커밋 5로 이동되었다. 여기서는 문제가 재현될테니 bad를 날린다.&lt;/p&gt;

&lt;pre class=&#34;prettyprint&#34;&gt;
$ git bisect bad
Bisecting: 0 revisions left to test after this (roughly 0 steps)
[4] &lt;comment&gt;&lt;/comment&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;.. - 0 - 1 - 2 - 3 - (4*) - 5 - HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여전히 문제가 재현되니 다시 bad.&lt;/p&gt;

&lt;pre class=&#34;prettyprint&#34;&gt;
$ git bisect bad
[4] is the first bad commit
&lt;/pre&gt;

&lt;p&gt;자, 이제 문제 발생 시점을 찾아냈다.&lt;/p&gt;

&lt;p&gt;작업이 완료된 후에는 다음과 같이 reset 명령어를 통해 HEAD가 원래 위치로 돌아갈 수 있게 해준다.&lt;/p&gt;

&lt;pre class=&#34;prettyprint&#34;&gt;
$ git bisect reset
&lt;/pre&gt;

&lt;p&gt;찾아야하는 커밋의 범위가 넓을 수록 해당 기능의 힘을 제대로 느낄 수 있다. N개의 커밋이 있을 때, &lt;code&gt;1 + log&lt;sub&gt;2&lt;/sub&gt;N&lt;/code&gt; 번 이하의 테스트만으로 문제 발생 커밋을 찾아내는 것이 가능하다.&lt;/p&gt;

&lt;p&gt;이 방법을 50개 정도의 커밋들 사이에서 여섯 스탭 정도만에 원인을 찾아낼 수 있었다. 쉘 스크립트를 활용하면 문제 발생 시점 찾는 것을 자동화하는 것도 가능하다.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>The Art of Computer Programming - 읽을 것인가?</title>
      <author>이상현</author>
      <link>https://iamsang.com/blog/2014/02/09/taocp-to-read-or-not/</link>
      <pubDate>Sun, 09 Feb 2014 17:10:42 +0900</pubDate>
      
      <guid>https://iamsang.com/blog/2014/02/09/taocp-to-read-or-not/</guid>
      <description>
        

&lt;blockquote&gt;
&lt;p&gt;There&amp;rsquo;s a (possibly apocryphal) story about Steve Jobs meeting Knuth. The first thing Jobs said to him was &amp;ldquo;It&amp;rsquo;s a pleasure to meet you Dr. Knuth. I&amp;rsquo;ve read all your works!&amp;rdquo;. Knuth&amp;rsquo;s response was &amp;ldquo;You&amp;rsquo;re full of shit&amp;rdquo;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;개발자라면 누구나 한 번쯤 &lt;a href=&#34;http://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read&#34;&gt;꼭 읽어야할 개발 서적 목록&lt;/a&gt;과 같은 것에 압도당한 적이 있을 것이다.&lt;/p&gt;

&lt;p&gt;그중 나를 가장 난감하게 했던 도서 중 하나가 바로 TAOCP(The Art of Computer Programming)였다. 단 한 권의 분량도 만만치 않은데 지금까지 나와 있는 것만으로 4권. 감히 엄두도 내기 힘든 분량의 책이었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/41gCSRxxVeL.jpg&#34; alt=&#34;The Art of Computer Programming (출처: Amazon)&#34; /&gt;&lt;/p&gt;

&lt;p&gt;워낙 유명한 책이다 보니 읽어보고 싶은 욕심은 나지만 분량에 압도되어 엄두는 나지 않고, 그래서 좀 더 검색을 해보았다.&lt;/p&gt;

&lt;p&gt;다행히 이런 게으른 고민을 한 사람이 나뿐만은 아니었다. &lt;a href=&#34;http://programmers.stackexchange.com/questions/17214/the-art-of-computer-programming-to-read-or-not-to-read&#34;&gt;TAOCP 읽을 것인가 말 것인가?&lt;/a&gt;라는 질문이 Stack Exchange에 올라있었다.&lt;/p&gt;

&lt;p&gt;질답의 내용이 인상적이어서 간단히 옮겨본다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;질문&#34;&gt;질문&lt;/h3&gt;

&lt;p&gt;수많은 개발 서적들이 나와 있고, 많은 사람의 꼭 읽어야 하는 개발서적 리스트 최상단에 올라와 있는 책이 Code Complete로 보이는데, Donald Knuth의 The Art of Computer Programming은 어떤가요? 저는 일과 가족 사이에서 바쁜 사람으로, 많은 시간을 가지고 있지 않기 때문에 시간을 어떻게 사용할지 신중하게 생각합니다.&lt;/p&gt;

&lt;p&gt;혹시 TAOCP를 읽어보신 분 계신가요? 다른 책을 읽거나 pet project 또는 오픈소스에 참여하는 것보다 TAOCP를 읽는 것이 저의 개발자로서의 전문성에 더 도움이 될까요?&lt;/p&gt;

&lt;p&gt;하략&lt;/p&gt;

&lt;h3 id=&#34;답변&#34;&gt;답변&lt;/h3&gt;

&lt;p&gt;TAOCP는 우리가 매일 사용하는 자료구조나 알고리즘이 어떻게 동작하는지 이해할 수 있게 해주는 매우 귀중한(utterly invaluable) 자료이지만, TAOCP를 처음부터 끝까지 읽기 위해서는 어마어마한 시간투자가 필요합니다.&lt;/p&gt;

&lt;p&gt;다른 한 가족의 일원으로서 말씀드리는데, 아이들과 시간을 보내십시오.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>개발일정 산정하기</title>
      <author>이상현</author>
      <link>https://iamsang.com/blog/2013/12/02/software-estimation/</link>
      <pubDate>Mon, 02 Dec 2013 17:10:42 +0900</pubDate>
      
      <guid>https://iamsang.com/blog/2013/12/02/software-estimation/</guid>
      <description>
        &lt;blockquote&gt;
&lt;p&gt;Hofstadter&amp;rsquo;s Law: It always takes longer than you expect, even when you take into account Hofstadter&amp;rsquo;s Law.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;얼마 전 &lt;a href=&#34;http://blog.angularjs.org/2013/11/angularjs-120-timely-delivery.html&#34;&gt;AngularJS 1.2.0이 릴리즈 되었다&lt;/a&gt;는 반가운 소식을 들었다. 버전 1.2.0의 코드명은 timely-delivery. 과연 AngularJS 1.2.0의 출시는 timely 했을까.&lt;/p&gt;

&lt;p&gt;AngularJS 팀은 2012년 6월 1.0.0 버전을 출시하고 7월 &lt;a href=&#34;http://blog.angularjs.org/2012/07/angularjs-10-12-roadmap.html&#34;&gt;1.2.0으로의 로드맵을 발표&lt;/a&gt;했다. 당시 예정된 1.2.0의 릴리즈 시점은 2012년 9월 초·중순. 개발기간을 3개월 정도로 잡았다. 실제 출시일은 2013년 11월로 약 17개월 정도 소요되었으니, 처음 예상했던 기간의 6배 정도가 걸린 셈이다. 코드명 timely-delivery는 이런 상황을 역설적으로 표현한 게 아닐까 생각된다. 부끄러움을 능청스러움으로 극복했달까.&lt;/p&gt;

&lt;p&gt;AngularJS 개발자들의 예측이 이렇게 심각하게 빗나간 이유는 뭘까. 분명 다들 개발을 해볼 만큼 해봤을 베테랑 개발자들일 텐데 말이다. 늦어진 정확한 이유야 알 수 없지만, 개발일정 산정의 어려움을 보여주는 좋은 예라고 볼 수 있겠다. (며칠 전 &lt;a href=&#34;http://blog.angularjs.org/2013/11/on-launching-angular-12-what-we-learned.html&#34;&gt;AngularJS 블로그에 1.2 버전이 늦어진데에 대한 회고&lt;/a&gt;가 올라왔다.)&lt;/p&gt;

&lt;p&gt;개발일정 산정은 왜 이렇게 어려운 것일까. Quora에 소프트웨어 개발은 왜 항상 예상보다 2~3배 이상의 시간이 걸리는가에 대한 질문이 있는데, 해당 스레드에는 &lt;a href=&#34;http://www.quora.com/Engineering-Management/Why-are-software-development-task-estimations-regularly-off-by-a-factor-of-2-3/answer/Michael-Wolfe?srid=24b&amp;amp;share=1&#34;&gt;압도적으로 많은 수의 추천을 받은 답변&lt;/a&gt;이 있다. 해당 글에서는 프로젝트 진행을 도보 여행에 비유하여 설명하는데, 전국지도와 같이 축적이 작은 지도를 보고 &amp;ldquo;단순거리 / 하루 걸을 수 있는 양&amp;rdquo;으로 계산한 예상 일정과 실제 걸으면서 만나는 예상치 못한 상황을 지나면서 걸리는 일정은 상당히 차이가 날 수밖에 없다는 것이 핵심 내용이다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.reddit.com/r/programming/comments/1i1vlc/an_absolutely_brilliant_analogy_as_to_why/&#34;&gt;Reddit Programming에도 Quora의 해당 글이 올라&lt;/a&gt; 큰 호응을 얻었었는데, 여기에 달린 댓글들을 보면 일정산정의 어려움에 대한 개발자들의 수많은 개드립을 감상할 수 있다.&lt;/p&gt;

&lt;p&gt;Programmers Stack Exchange에는 &lt;a href=&#34;http://programmers.stackexchange.com/questions/648/how-to-respond-when-you-are-asked-for-an-estimate&#34;&gt;&amp;ldquo;개발일정에 대해 질문받았을 때에 어떻게 답변해야 하는가?&amp;rdquo;&lt;/a&gt;에 대한 질답이 있다. 그에 대해 가장 많은 추천을 받은 답변은 실용주의 프로그래머의 추정(Estimating) 챕터를 그대로 요약한 글이다. 해당 답변을 번역하여 옮겨본다면 아래와 같다.&lt;/p&gt;

&lt;hr&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;일정산정 요청을 받으면 뭐라고 답해야 하나&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;나중에 다시 알려 드리겠습니다.&amp;ldquo;이라고 말하라.&lt;/p&gt;

&lt;p&gt;일정산정 과정을 느리게 하고 이 장에서 이야기한 일정산정 단계들에 많은 시간을 들일수록 더 정확한 결과를 얻을 수 있다. 커피 자판기 앞에서 산정된 일정은 (커피처럼) 너를 따라와 괴롭힐 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 장에서 저자는 다음의 과정들을 추천한다:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;필요한 정확도를 정하라. 기간에 따라 다른 정확도로 일정산정이 가능하다. &amp;ldquo;5~6개월&amp;rdquo;이라고 말하는 것과 &amp;ldquo;150일&amp;rdquo;이라고 말하는 것은 다르다. 일정이 6개월을 약간 넘기더라도 추정은 여전히 꽤 정확한 것이다. 하지만 180일이나 210일 정도가 걸렸다면 그다지 정확하지 않은 것이다.&lt;/li&gt;
&lt;li&gt;무엇을 질문 받은 것인지 확실히 하라. 문제의 범위를 정하라.&lt;/li&gt;
&lt;li&gt;시스템을 모델링하라. 모델은 멘탈 모델, 다이어그램 또는 존재하는 데이터가 될 수 있다. 이 모델들을 분해하여 구성요소들로부터 추정하라. 값과 오차범위(+/-)를 할당하라.&lt;/li&gt;
&lt;li&gt;당신의 추정을 추적하라. 추정하고 있는 문제, 추정 및 실제적이 값들에 대한 정보를 기록하라.&lt;/li&gt;
&lt;li&gt;그 외 추적할 것들에는 요구사항, 위험 및 유효성검사가 있다.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>해커뉴스 이펙트</title>
      <author>이상현</author>
      <link>https://iamsang.com/blog/2013/04/02/hacker-news-effect/</link>
      <pubDate>Tue, 02 Apr 2013 17:10:42 +0900</pubDate>
      
      <guid>https://iamsang.com/blog/2013/04/02/hacker-news-effect/</guid>
      <description>
        &lt;blockquote&gt;
&lt;p&gt;여러분이 무엇을 진정으로 사랑하지 않는다면 그것을 정말로 잘해낼 수 없다. 마찬가지로 해킹을 정말로 좋아한다면 뭔가 자기 자신의 프로젝트를 수행하지 않고는 견딜 수가 없는 것이다. - 폴 그레이엄&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;해커뉴스는 사용자가 게시물을 올리는 &lt;a href=&#34;http://en.wikipedia.org/wiki/Social_news&#34;&gt;소셜 뉴스&lt;/a&gt; 웹사이트로 폴 그레이엄이 운영하는 사이트이다. 폴 그레이엄은 2009년에 자신이 작성한 글 &lt;a href=&#34;http://www.paulgraham.com/hackernews.html&#34;&gt;What I&amp;rsquo;ve learned from hacker news&lt;/a&gt;에서, 해커뉴스가 2007년 &lt;a href=&#34;http://en.wikipedia.org/wiki/Arc_(programming_language)&#34;&gt;Arc&lt;/a&gt; 실력을 향상하기 위한 사이드 프로젝트로 시작한 사이트라고 소개한다. 개인적으로는 최신기술이나 뉴스를 쉽게 찾아볼 수 있고, 그에 대한 사람들의 의견을 볼 수 있어 자주 찾아보는 사이트이다.&lt;/p&gt;

&lt;p&gt;해커뉴스 이펙트라는 용어가 있다. 해커뉴스에 올린 블로그 글이나 오픈소스 프로젝트 등이 상위권에 머물게 되면서 얻는 효과를 말한다. &amp;ldquo;Hacker news effect&amp;rdquo;로 &lt;a href=&#34;https://www.google.com/search?q=hacker+news+effect&amp;aq=f&amp;oq=hacker+news+&amp;aqs=chrome.0.59j57j65j59j60j59.3321&amp;sourceid=chrome&amp;ie=UTF-8&#34;&gt;구글링&lt;/a&gt;을 해보면, 다양한 경험담을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;대표적인 것으로 &lt;a href=&#34;https://medium.com/open-source/7d4fa461a9&#34;&gt;List.js&lt;/a&gt;가 있다. 해커뉴스에 다섯 시간 동안 1위에 머물러 있었을 뿐이었는데도 45시간 이내에 아래와 같은 인기를 얻었다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;27,500명의 방문자&lt;/li&gt;
&lt;li&gt;269개의 트윗&lt;/li&gt;
&lt;li&gt;GitHub에서 439명의 Watcher와 21개의 fork&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;해커뉴스가 없었다면 이렇게 빠른 속도록 인기를 얻지는 못했을 것이다.&lt;/p&gt;

&lt;p&gt;이렇게 강력한 힘을 가지고 있는 해커뉴스지만, 생각보다 대단치 않은 콘텐츠들이 올라오는 경우도 종종 있다. &lt;a href=&#34;https://news.ycombinator.com/item?id=1781013&#34;&gt;해커뉴스의 알고리즘&lt;/a&gt;을 보면, 게시물의 점수는 시간에 따라 급격히 낮아지고 하루가 지나고 나면 아무리 추천을 많이 받았더라도 낮은 점수를 가지기 때문에 게시물이 빠르게 순환되는데, 이것이 그 이유가 될 수 있다. 게시물의 시간에 따른 점수의 변화는 &lt;a href=&#34;http://www.wolframalpha.com/input/?i=plot%28+++++%2830+-+1%29+%2F+%28t+%2B+2%29%5E1.8%2C++++++%2860+-+1%29+%2F+%28t+%2B+2%29%5E1.8%2C+++++%28200+-+1%29+%2F+%28t+%2B+2%29%5E1.8+%29+where+t%3D0..24&#34;&gt;Wolfram Alpha&lt;/a&gt;에서 그래프로 확인할 수 있다(여기서 점수는 해커뉴스 사이트에 나타나는 점수가 아닌 내부적으로 계산되는 점수를 말한다).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://media.tumblr.com/7fafef383f8da00374e8767b7613cb21/tumblr_inline_mktwcayTmc1qz4rgp.png&#34; alt=&#34;시간에 따른 게시물의 점수 변화&#34; title=&#34;시간에 따른 게시물의 점수 변화&#34; /&gt;&lt;/p&gt;

&lt;p&gt;번역 API가 필요한 사이드 프로젝트를 만들어 보려는데, 구글 번역 API가 유료라는 사실을 알게 되었다. 재미로 만드는 사이드 프로젝트를 위해 돈을 내고 싶지는 않았다. 다른 방법이 없나 찾던 중 구글 스프레드시트 API를 이용한 꼼수를 사용하면 구글 번역 API를 만들 수 있다는 사실을 알게 되었고, 루비로 간단히 구현해 &lt;a href=&#34;https://github.com/Sangdol/free-and-slow-google-translate-api&#34;&gt;GitHub에 올리고&lt;/a&gt;, &lt;a href=&#34;http://google-translate-api.herokuapp.com/translate?from=en&amp;to=ko&amp;text%5B%5D=hi,%20how%20are%20you?&amp;text%5B%5D=i&#39;m%20fine,%20thank%20you&amp;callback=test&#34;&gt;Heroku에 띄웠다&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;내 GitHub 계정에 방문하는 사람은 아무도 없었기 때문에, 해당 프로젝트에 관심 가지는 사람 역시 없었다. 그러던 중 해커뉴스에나 한번 올려볼까 하는 생각이 들어 Readme를 조금 다듬은 뒤 올려보았다. 그냥 묻혀버리지 않을까 생각했는데 결과는 의외였다. 한 시간쯤 지나니 4 points라는 낮은 점수로 첫 화면에 진입했고 2시간쯤 되었을 때에는 15위까지 올라갔다. 실시간으로 계속 보진 않았지만 아마 15위가 최고였던 듯하고, 그렇게 조금씩 오르락내리락하다 약 8시간쯤 후에는 첫 페이지에서 완전히 밀려났다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://media.tumblr.com/9f174d2ec96961621478586dcabdbdd2/tumblr_inline_mktwy6S5em1qz4rgp.png&#34; alt=&#34;해커뉴스에서의 순위&#34; title=&#34;해커뉴스에서의 순위&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그 결과 하루 동안 GitHub에서 20여 개의 Star를 받고 1개의 Full request를 받았다. 해커뉴스 이펙트라는 이름을 붙이기에는 초라한 결과지만, 오픈소스 프로젝트에 참여한 적도 없고, 별다른 인지도도 가지고 있지 않은 나에게는 만족스러운 성과이다.&lt;/p&gt;

&lt;p&gt;이 경험을 통해 두 가지 생각이 들었는데,&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;영어는 필요조건이며,&lt;/li&gt;
&lt;li&gt;실력만 있다면 세상에 인정받을 수 있다라는 것.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;만든 건 보잘것없는 간단한 프로젝트지만, 가능성을 볼 수 있게 해준 좋은 경험이었다. 흥미로운 토이 프로젝트를 만들었는데 아무도 관심가져주지 않는다면 해커뉴스에 한번 올려보는 것도 괜찮겠다.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>자바 바이트코드 소개</title>
      <author>이상현</author>
      <link>https://iamsang.com/blog/2012/08/19/introduction-to-java-bytecode/</link>
      <pubDate>Sun, 19 Aug 2012 17:10:42 +0900</pubDate>
      
      <guid>https://iamsang.com/blog/2012/08/19/introduction-to-java-bytecode/</guid>
      <description>
        

&lt;blockquote&gt;
&lt;p&gt;Understanding bytecode and what bytecode is likely to be generated by a Java compiler helps the Java programmer in the same way that knowledge of assembly helps the C or C++ programmer. - IBM developerWorks journal&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;개발을 하다 보면 때로는 로우 레벨에 대한 이해가 필요할 때가 있습니다. 하지만 이클립스나 인텔리J와 같은 IDE를 이용해 개발하는 개발자들에게는 javac나 javap와 같은 간단한 자바 명령어조차 낯선 것이 사실입니다.&lt;/p&gt;

&lt;p&gt;이 글에서는 자바 바이트코드(Bytecode)에 대해 살펴보며 자바 프로그램이 어떤 식으로 컴파일되고 실행되는지에 대해 설명하겠습니다.&lt;/p&gt;

&lt;h3 id=&#34;컴파일러&#34;&gt;컴파일러&lt;/h3&gt;

&lt;p&gt;자바 바이트코드는 JVM(Java virtual machine)이 실행하는 명령어 집합입니다. 컴파일하면 생성되는 &lt;a href=&#34;http://en.wikipedia.org/wiki/Java_class_file&#34;&gt;.class 파일&lt;/a&gt;이 바이트코드를 담고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/Java_virtual_machine_architecture.svg/400px-Java_virtual_machine_architecture.svg.png&#34; alt=&#34;JVM 아키텍처의 개요(출처: 위키피디아)&#34; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림과 같이 컴파일을 통해 생성된 바이트코드 파일들은 OS나 개발환경에 관계없이 같은 명령어 집합을 사용하며, 이것이 자바의 크로스 플랫폼 동작을 가능하게 해주는 부분입니다.&lt;/p&gt;

&lt;p&gt;위 JVM 아키텍처를 자세히 보면 (우측의 Python 관련 그림을 제외하고 보더라도) 두 종류의 컴파일러가 있다는 것을 알 수 있습니다. 첫 번째 컴파일러는 &lt;a href=&#34;http://en.wikipedia.org/wiki/Java_compiler&#34;&gt;자바 코드를 자바 클래스 파일로 만들어주는 컴파일러&lt;/a&gt;입니다. 위 그림에서는 &lt;a href=&#34;http://en.wikipedia.org/wiki/Javac&#34;&gt;javac&lt;/a&gt;로 표기된 부분으로 &lt;a href=&#34;http://en.wikipedia.org/wiki/Java_Development_Kit&#34;&gt;JDK(Java Development Kit)&lt;/a&gt;에 포함된 기본 컴파일러입니다. 일반적으로 자바 컴파일러를 말할 때에는 바이트코드를 생성하는 이 컴파일러를 말합니다. 이후에 JRE(Java Runtime Environment)에서 더 나은 최적화를 하기 위해서 이 단계에서는 &lt;a href=&#34;http://en.wikipedia.org/wiki/Loop_unwinding&#34;&gt;loop unrolling&lt;/a&gt;, algebraic simplification, &lt;a href=&#34;http://en.wikipedia.org/wiki/Strength_reduction&#34;&gt;strength reduction&lt;/a&gt;와 같은 기본적인 최적화도 하지 않습니다.&lt;/p&gt;

&lt;p&gt;참고로 이클립스는 독자적인 컴파일러를 사용합니다. 따라서 JDK를 설치하지 않고도 이클립스에서 컴파일이 가능합니다. 이클립스의 컴파일러는 다음과 같은 기능을 제공합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;프로젝트에서 수정된 부분만 컴파일하는 증분컴파일(Incremental compilation) 기능&lt;/li&gt;
&lt;li&gt;일부 코드에 에러가 있더라도 클래스 파일을 생성하는 기능(모든 파일이 정상 컴파일되지 않더라도 프로젝트가 동작할 수 있도록 하기 위함)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Abstract_syntax_tree&#34;&gt;AST&lt;/a&gt; 생성(Outline 보기, 리팩토링과 같은 기능을 가능하게 함)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 아키텍처에서 다음으로 볼 수 있는 컴파일러는 &lt;a href=&#34;http://en.wikipedia.org/wiki/Just-in-time_compilation&#34;&gt;JIT(Just In Time) 컴파일러&lt;/a&gt;입니다. JVM은 동적으로 바이트코드를 읽으며 인터프리팅을 하는데, 이 단계에서 JIT 컴파일러는 자바 애플리케이션의 성능향상을 위해 &lt;a href=&#34;http://en.wikipedia.org/wiki/Dynamic_compilation&#34;&gt;동적 컴파일&lt;/a&gt;을 통해 머신코드(Machine code)로 컴파일 가능한 코드들을 한 번 더 컴파일합니다. 이처럼 미리 컴파일하지 않고 실행 중 동적으로 컴파일하는데, 컴파일러의 이름이 Just In Time인 이유가 바로 여기에 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;바이트코드는-공부할-가치가-있을까&#34;&gt;바이트코드는 공부할 가치가 있을까?&lt;/h3&gt;

&lt;p&gt;바이트코드 학습을 통해 얻을 수 있는 것에는 어떤 것들이 있을까요? 바이트코드를 분석할 수 있게 되어 좀 더 성능이 좋은 코드를 작성할 수 있을까요? 별로 그렇지 않습니다. 앞서 이야기했듯이 성능 최적화는 JIT 컴파일러 단계에서 진행되며 이것은 JVM마다 다르게 구현되어 있어 사실상 바이트코드만으로는 해당 코드가 어떻게 머신코드로 변경되고 최적화될지 알 수 없습니다. 바이트코드 수준의 최적화란 거의 의미가 없다고 볼 수 있으며, 그것보다 중요한 것은 사람이 보기 좋은 코드를 작성하는 것입니다.&lt;/p&gt;

&lt;p&gt;그렇다면 바이트코드는 왜 배워야 할까요. &lt;a href=&#34;http://programmers.stackexchange.com/questions/156722/how-does-learning-assembly-aid-in-programming&#34;&gt;어셈블리어를 왜 배워야하냐&lt;/a&gt;는 질문에 대한 답변으로 나온 아래 문장이 바이트코드를 배워야 하는 이유를 잘 설명해줍니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Because you&amp;rsquo;ll understand how it really works.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;조금 더 덧붙이자면 바이트코드에 대한 이해는 더 훌륭한 자바 개발자가 되도록 도와줄 것이라는 점입니다.&lt;/p&gt;

&lt;h3 id=&#34;바이트코드-명령어-opcode&#34;&gt;바이트코드 명령어(opcode)&lt;/h3&gt;

&lt;p&gt;한 바이트에는 256개의 값이 있듯이 바이트코드에는 256개가량의 &lt;a href=&#34;http://en.wikipedia.org/wiki/Opcode&#34;&gt;opcode&lt;/a&gt;들이 존재합니다. 각각의 명령어들은 넓게 다음과 같이 분류할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;읽고 쓰기 (e.g. aload_0, istore)&lt;/li&gt;
&lt;li&gt;산술논리 연산 (e.g. ladd, fcmpl)&lt;/li&gt;
&lt;li&gt;타입변환 (e.g. i2b, d2i)&lt;/li&gt;
&lt;li&gt;객체생성 및 조작 (new, putfield)&lt;/li&gt;
&lt;li&gt;오퍼랜드 스택 관리 (e.g. swap, dup2)&lt;/li&gt;
&lt;li&gt;제어 (e.g. ifeq, goto)&lt;/li&gt;
&lt;li&gt;함수 호출 및 반환 (e.g. invokespecial, areturn)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;많은 명령어는 피연산자(operand)의 타입을 나타내는 접두사(prefix) 또는 접미사(suffix)를 가지고 있습니다. 아래는 각 접두사/접미사가 나타내는 피연산자 타입입니다.&lt;/p&gt;

&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;접두사/접미사&lt;/th&gt;
            &lt;th&gt;피연산자 타입&lt;/th&gt;
        &lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;i&lt;/code&gt;&lt;/td&gt;
            &lt;td&gt;integer&lt;/td&gt;
        &lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;l&lt;/code&gt;&lt;/td&gt;
            &lt;td&gt;long&lt;/td&gt;
        &lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;s&lt;/code&gt;&lt;/td&gt;
            &lt;td&gt;short&lt;/td&gt;
        &lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;b&lt;/code&gt;&lt;/td&gt;
            &lt;td&gt;byte&lt;/td&gt;
        &lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;c&lt;/code&gt;&lt;/td&gt;
            &lt;td&gt;character&lt;/td&gt;
        &lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;f&lt;/code&gt;&lt;/td&gt;
            &lt;td&gt;float&lt;/td&gt;
        &lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;d&lt;/code&gt;&lt;/td&gt;
            &lt;td&gt;double&lt;/td&gt;
        &lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;a&lt;/code&gt;&lt;/td&gt;
            &lt;td&gt;reference&lt;/td&gt;
        &lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;모든 명령어의 리스트는 위키피디아의 &lt;a href=&#34;http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings&#34;&gt;Java bytecode instruction listings&lt;/a&gt; 페이지에서 찾아볼 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;바이트코드-시작하기&#34;&gt;바이트코드 시작하기&lt;/h3&gt;

&lt;p&gt;코드를 컴파일하여 바이트코드를 직접 살펴보겠습니다. 바이트코드는 다음과 같은 형식을 가집니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;index&amp;gt;&amp;lt;opcode&amp;gt; [&amp;lt;operand1&amp;gt; [&amp;lt;operand2&amp;gt;...]] [&amp;lt;comment&amp;gt;]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;형식만 봐서는 와닿지 않으니 예제를 통해 살펴보겠습니다.&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/3370455.js?file=Person.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;위와 같은 클래스를 컴파일해보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;javac Person.java
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;컴파일되어 나온 &lt;code&gt;Person.class&lt;/code&gt; 파일을 통해 바이트코드를 확인해보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;javap -c Person
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같이 기본 자바 클래스 파일 Disassembler 프로그램인 &lt;a href=&#34;http://docs.oracle.com/javase/1.5.0/docs/tooldocs/windows/javap.html&#34;&gt;javap&lt;/a&gt;를 실행시키면 다음과 같은 코드가 나타납니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Compiled from &#34;Person.java&#34;
public class Person extends java.lang.Object{
int age;

public Person();
  Code:
   0: aload_0
   1: invokespecial #1; //Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
   4: aload_0
   5: bipush  10
   7: putfield  #2; //Field age:I
   10:  return

public int getAge();
  Code:
   0: aload_0
   1: getfield  #2; //Field age:I
   4: ireturn

public void setAge(int);
  Code:
   0: aload_0
   1: iload_1
   2: putfield  #2; //Field age:I
   5: return

}
&lt;/init&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 바이트코드 중 일부를 살펴보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;5:  bipush  10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 코드는 인덱스 5에서 &lt;code&gt;bipush&lt;/code&gt;라는 opcode가 &lt;code&gt;10&lt;/code&gt;이라는 피연산자를 가지고 있습니다. 한 줄 더 살펴보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;7:  putfield  #2; //Field age:I
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 코드는 해시(#)가 달린 피연산자를 가지고 있습니다. 이것은 상수풀(constant pool)에서의 인덱스를 나타냅니다. 그리고 해당 피연산자가 가리키는 아이템을 나타내는 주석이 뒤따라 옵니다. 해당 주석은 javap가 생성한 주석입니다.&lt;/p&gt;

&lt;p&gt;이제 다시 바이트코드의 형식을 보면 이해가 잘 될 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;index&amp;gt;&amp;lt;opcode&amp;gt; [&amp;lt;operand1&amp;gt; [&amp;lt;operand2&amp;gt;...]] [&amp;lt;comment&amp;gt;]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이번에는 Person 클래스의 바이트코드를 부분별로 나누어 분석해보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
public Person();
  Code:
   0: aload_0
   1: invokespecial #1; //Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
   4: aload_0
   5: bipush  10
   7: putfield  #2; //Field age:I
   10:  return
&lt;/init&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 코드는 Person 클래스의 생성자를 나타내는 부분입니다. 코드에는 생성자가 없지만, 컴파일러가 기본 생성자를 만들어냈습니다.&lt;/p&gt;

&lt;p&gt;생성자의 첫 줄에서는 &lt;code&gt;aload_0&lt;/code&gt; 명령어를 통해 지역변수배열(Array of local variables)의 0번째에 있는 값을 피연산자 스택(Operand Stack)으로 로드합니다.&lt;/p&gt;

&lt;p&gt;이것이 대체 무슨 말인지 이해하기 위해 잠시 JVM이 바이트코드를 어떤 방식으로 실행하는지에 대해 살펴볼 필요가 있습니다. JVM은 스택기반머신입니다. 각 스레드는 JVM 스택을 가지고 이 스택에는 &lt;a href=&#34;http://docs.oracle.com/javase/specs/jvms/se5.0/html/Overview.doc.html#17257&#34;&gt;프레임(frame)&lt;/a&gt;들이 저장됩니다. 프레임은 생성자 또는 함수가 실행될 때 생성되는 것으로 아래 그림과 같이 지역변수배열과 피연산자 스택 그리고 상수풀에 대한 참조로 구성되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.ibm.com/developerworks/ibm/library/it-haggar_bytecode/fig01.gif&#34; alt=&#34;프레임(출처: IBM 저널)&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그림의 상단에서 볼 수 있는 지역변수배열에는 객체에 대한 참조(&lt;code&gt;this&lt;/code&gt;), 메소드의 인자 그리고 지역변수들이 0번 위치부터 차례대로 들어갑니다. static 함수의 경우에는 파라미터가 0번 위치부터 들어갑니다(static 함수에서는 &lt;code&gt;this&lt;/code&gt;를 쓸 수 없습니다).&lt;/p&gt;

&lt;p&gt;이클립스를 통해 자바 프로그램을 디버깅해본 경험이 있다면 프레임을 알든 모르든 누구나 프레임을 본 적이 있을 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://media.tumblr.com/tumblr_m901glDZbG1qimauz.png&#34; alt=&#34;이클립스 디버그 뷰에서 볼 수 있는 프레임&#34; title=&#34;이클립스 디버그 뷰에서 볼 수 있는 프레임&#34; /&gt;&lt;/p&gt;

&lt;p&gt;자, 이제 다시 Person 클래스의 바이트코드로 돌아가 보겠습니다(코드가 너무 멀어졌으니 다시 복사해서 보겠습니다).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
public Person();
  Code:
   0: aload_0
   1: invokespecial #1; //Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
   4: aload_0
   5: bipush  10
   7: putfield  #2; //Field age:I
   10:  return
&lt;/init&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;aload_0&lt;/code&gt;이 무엇을 하는지 알 수 있게 되었습니다. 지역변수배열의 0번째 위치에 있던 &lt;code&gt;this&lt;/code&gt;를 피연산자 스택에 넣는 동작을 합니다. 앞서 이야기했듯이 &lt;code&gt;aload_0&lt;/code&gt;에서 &lt;code&gt;a&lt;/code&gt;는 피연산자의 타입을 나타내는 접두사로 참조를 로드한다는 것을 나타냅니다.&lt;/p&gt;

&lt;p&gt;다음 라인의 &lt;code&gt;invokespecial&lt;/code&gt; 명령어는 상위 클래스(Superclass)의 생성자를 호출합니다. 자바에서 명시적으로 상속을 받지 않는 클래스는 암시적으로 Object를 상속받기 때문에 컴파일러가 이러한 코드를 생성한 것입니다. 이 단계에서 피연산자 스택의 가장 상위에 있던 &lt;code&gt;this&lt;/code&gt;가 빠져나오게 됩니다.&lt;/p&gt;

&lt;p&gt;다음 인덱스 4~7의 코드들은 &lt;code&gt;age&lt;/code&gt; 필드에 &lt;code&gt;10&lt;/code&gt;을 할당하는 부분입니다. &lt;code&gt;aload_0&lt;/code&gt;을 통해 &lt;code&gt;this&lt;/code&gt;를 로드(피연산자 스택에 push)하고 &lt;code&gt;bipush 10&lt;/code&gt;을 통해 &lt;code&gt;10&lt;/code&gt;을 다시 스택에 넣습니다. 그리고 &lt;code&gt;putfield&lt;/code&gt; 명령어에서는 이 두 값과 필드 참조 값 &lt;code&gt;#2&lt;/code&gt;를 이용하여 &lt;code&gt;age&lt;/code&gt; 필드에 값을 할당합니다.&lt;/p&gt;

&lt;p&gt;마지막으로 &lt;code&gt;return&lt;/code&gt; 명령어를 통해 반환 값 없이 함수를 종료합니다. 함수가 반환 값을 가질 때에는 &lt;code&gt;areturn&lt;/code&gt; 또는 &lt;code&gt;ireturn&lt;/code&gt;과 같이 타입 접두사가 붙은 명령어를 실행합니다.&lt;/p&gt;

&lt;p&gt;이제 나머지 코드를 살펴보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
public int getAge();
  Code:
   0: aload_0
   1: getfield  #2; //Field age:I
   4: ireturn

public void setAge(int);
  Code:
   0: aload_0
   1: iload_1
   2: putfield  #2; //Field age:I
   5: return
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;생성자를 보고나니 getter/setter는 쉬워 보입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getAge&lt;/code&gt; 메소드에서는 참조를 로드한 후 &lt;code&gt;getfield&lt;/code&gt; 명령어에서 참조를 이용하여 &lt;code&gt;age&lt;/code&gt;의 값을 다시 스택에 넣습니다. 그리고 &lt;code&gt;ireturn&lt;/code&gt; 명령어를 통해 스택의 값을 반환합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;setAge&lt;/code&gt; 메소드의 명령어들은 생성자에서 사용된 명령어와 같아 다시 볼 필요가 없어보입니다.&lt;/p&gt;

&lt;h3 id=&#34;if-문과-switch-문-비교&#34;&gt;if 문과 switch 문 비교&lt;/h3&gt;

&lt;p&gt;얼마 전 직장동료와 &amp;ldquo;if 문과 switch 문에 성능차이가 있을까?&amp;ldquo;라는 것에 관해 이야기 나눈 적이 있습니다. &lt;a href=&#34;http://stackoverflow.com/questions/2086529/what-is-the-relative-performance-difference-of-if-else-versus-switch-statement-i&#34;&gt;if 문과 switch 문의 성능차이를 이용하여 최적화를 하려고 하는 것은 분명 어리석은 생각&lt;/a&gt;이지만 내부적으로 if 문과 switch 문이 어떻게 동작하는지에 대해 알아보는 것은 의미가 있습니다.&lt;/p&gt;

&lt;p&gt;같은 동작을 하는 if 문과 switch 문 함수를 준비하였습니다. 각 함수는 static으로 선언하였습니다.&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/3388251.js?file=IfAndSwitch.java&#34;&gt;&lt;/script&gt;

&lt;p&gt;위 클래스의 바이트코드를 확인해보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
public static void ifFunc(int);
  Code:
   0: iload_0
   1: iconst_1
   2: if_icmpne 15
   5: getstatic #2; //Field java/lang/System.out:Ljava/io/PrintStream;
   8: iconst_1
   9: invokevirtual #3; //Method java/io/PrintStream.println:(I)V
   12:  goto  27
   15:  iload_0
   16:  iconst_2
   17:  if_icmpne 27
   20:  getstatic #2; //Field java/lang/System.out:Ljava/io/PrintStream;
   23:  iconst_2
   24:  invokevirtual #3; //Method java/io/PrintStream.println:(I)V
   27:  return

public static void switchFunc(int);
  Code:
   0: iload_0
   1: lookupswitch{ //2
    1: 28;
    2: 38;
    default: 45 }
   28:  getstatic #2; //Field java/lang/System.out:Ljava/io/PrintStream;
   31:  iconst_1
   32:  invokevirtual #3; //Method java/io/PrintStream.println:(I)V
   35:  goto  45
   38:  getstatic #2; //Field java/lang/System.out:Ljava/io/PrintStream;
   41:  iconst_2
   42:  invokevirtual #3; //Method java/io/PrintStream.println:(I)V
   45:  return
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;switch 문의 코드가 조금 더 간결해 보입니다. 바이트코드를 살펴보면 if 문은 &lt;code&gt;if_icmpne&lt;/code&gt; 명령어를 통해 한 단계씩 비교하며 이동하는 반면 switch 문은 &lt;code&gt;lookupswitch&lt;/code&gt;라는 명령어를 통해 한 번에 목표지점으로 이동하는 것을 알 수 있습니다. switch문이 조금 더 효율적으로 동작할 것이라 예상할 수 있습니다.&lt;/p&gt;

&lt;p&gt;바이트코드를 좀 더 자세히 살펴보면 if 문의 인덱스 0에서 &lt;code&gt;iload_0&lt;/code&gt;을 통해 로컬변수 배열의 0번째 값을 로드하고 있습니다. 인스턴스 메소드일 경우 0번째 값은 객체참조이지만 여기서 사용된 것은 static 메소드이므로 0번째 값은 첫 번째 인자가 됩니다.&lt;/p&gt;

&lt;p&gt;다음 줄에서는 &lt;code&gt;iconst_1&lt;/code&gt; 명령어를 통해 int 값 &lt;code&gt;1&lt;/code&gt;을 스택에 넣습니다. 기억력이 좋은 분이라면 앞서 Person 클래스에서는 &lt;code&gt;10&lt;/code&gt;이라는 값을 &lt;code&gt;age&lt;/code&gt; 필드에 할당할 때 &lt;code&gt;bipush&lt;/code&gt; 명령어를 이용했었다는 것을 기억할 것입니다. 피연산자가 필요하지 않은 &lt;code&gt;iconst_1&lt;/code&gt; 명령어가 &lt;code&gt;bipush&lt;/code&gt; 보다 효율적으로 동작하기 때문에 이곳에서는 &lt;code&gt;iconst_1&lt;/code&gt; 명령어가 사용되었습니다. &lt;code&gt;iconst_&amp;lt;i&amp;gt;&lt;/code&gt; 명령어는 총 7개로 -1에서 5까지의 값만 로드할 수 있기 때문에 앞선 코드에서는 &lt;code&gt;10&lt;/code&gt;을 넣기 위해 &lt;code&gt;bipush&lt;/code&gt;가 사용되었던 것입니다.&lt;/p&gt;

&lt;p&gt;각 명령어에 대한 자세한 내용은 앞서 언급했던 &lt;a href=&#34;http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings&#34;&gt;위키피디아의 명령어 리스트&lt;/a&gt;를 보면 쉽게 찾아볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;여기까지 바이트코드에 대한 기본적인 내용을 알아보았습니다. 이제 어떤 코드의 동작방식이 궁금하다면 명령어 리스트를 참고해가며 직접 바이트코드를 분석해 볼 수 있을 것입니다. 좀 더 깊은 내용을 알고 싶다면 &lt;a href=&#34;http://docs.oracle.com/javase/specs/jvms/se7/html/index.html&#34;&gt;JVM 스팩&lt;/a&gt;을 살펴보는 것을 추천해 드립니다.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Java_bytecode#Support_for_dynamic_languages&#34;&gt;Java bytecode From Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/specs/jvms/se7/html/index.html&#34;&gt;The Java Virtual Machine Specification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ibm.com/developerworks/ibm/library/it-haggar_bytecode/&#34;&gt;Java bytecode: Understanding bytecode makes you a better programmer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://arhipov.blogspot.kr/2011/01/java-bytecode-fundamentals.html&#34;&gt;Java Bytecode Fundamentals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/1642338/java-eclipse-how-does-eclipse-compile-classes-with-only-a-jre&#34;&gt;Java / Eclipse : How does Eclipse compile classes with only a JRE?&lt;/a&gt; &lt;/i&gt;&lt;/comment&gt;&lt;/operand2&gt;&lt;/operand1&gt;&lt;/opcode&gt;&lt;/index&gt;&lt;/comment&gt;&lt;/operand2&gt;&lt;/operand1&gt;&lt;/opcode&gt;&lt;/index&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>스택오버플로 활용하기</title>
      <author>이상현</author>
      <link>https://iamsang.com/blog/2012/05/30/using-stack-overflow-effectively/</link>
      <pubDate>Wed, 30 May 2012 17:10:42 +0900</pubDate>
      
      <guid>https://iamsang.com/blog/2012/05/30/using-stack-overflow-effectively/</guid>
      <description>
        

&lt;blockquote&gt;
&lt;p&gt;Done is better than perfect&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;저의 첫 포스트는 제가 좋아하는 사이트 중 하나인 스택오버플로(Stack Overflow)에 대한 소개로 시작하려 합니다.&lt;/p&gt;

&lt;p&gt;스택오버플로는 개발자라면 누구나 잘 알고 있는 사이트이지만, 언어의 장벽 때문에 국내 개발자에게는 주로 읽기 활동만 하게 되는 사이트입니다. 저도 오랫동안 읽기만 하는 소극적 사용자였지만 &lt;a href=&#34;http://stackoverflow.com/questions/6184869/what-is-difference-between-memoization-and-dynamic-programming&#34;&gt;한 줄짜리 질문&lt;/a&gt;을 시작으로 자신감을 얻고 조금씩 활동하기 시작하여 지금은 어설픈 영어로 가끔 답변도 달고 질문도 올리며 어느정도 활용할 수 있게 되었습니다.&lt;/p&gt;

&lt;p&gt;이번 글에서는 적극적 사용자로서 스택오버플로를 사용하며 느꼈던 시스템의 훌륭함과 다양한 기능을 소개해 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm8.staticflickr.com/7100/7234478862_665a8f85b4_c.jpg&#34; alt=&#34;스택오버플로의 에러 페이지&#34; title=&#34;스택오버플로의 에러 페이지&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;들어가기&#34;&gt;들어가기&lt;/h3&gt;

&lt;p&gt;스택오버플로는 유명한 책 조엘 온 소프트웨어의 저자인 Joel Spolsky와 &lt;a href=&#34;http://www.codinghorror.com/blog/2012/02/farewell-stack-exchange.html&#34;&gt;지금은 스택오버플로를 떠난&lt;/a&gt; Jeff Atwood가 2008년 공동창업하여 만든 사이트입니다.&lt;/p&gt;

&lt;p&gt;여기서 잠깐 짚고 넘어가야 할 부분이 있습니다. 회사를 시작하던 당시에는 스택오버플로라는 이름으로 시작했지만 &lt;a href=&#34;http://blog.stackoverflow.com/2011/03/a-new-name-for-stack-overflow-with-surprise-ending/&#34;&gt;2011년 3월 회사 이름을 스택익스체인지(Stack Exchange)로 바꾸고&lt;/a&gt; 카테고리별로 &lt;a href=&#34;http://stackexchange.com/sites&#34;&gt;수많은 사이트&lt;/a&gt;을 만들어 지금은 수십 개 이상의 크고 작은 스택익스체인지 사이트가 있습니다. 이 글에서는 스택익스체인지 사이트 중 가장 규모가 크며 국내 사용자에게 많이 알려진 스택오버플로를 기준으로 소개하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://media.tumblr.com/tumblr_m4dn5z3Ob41qimauz.png&#34; alt=&#34;스택익스체인지의 수많은 사이트&#34; title=&#34;스택익스체인지의 수많은 사이트&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;점수-시스템&#34;&gt;점수 시스템&lt;/h3&gt;

&lt;p&gt;스택오버플로의 &lt;a href=&#34;http://stackoverflow.com/faq#reputation&#34;&gt;점수 시스템&lt;/a&gt;은 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;답변이 추천받았을 때 &lt;/td&gt;
      &lt;td&gt; +10&lt;/td&gt;
      &lt;td&gt;
      &lt;/td&gt;
    &lt;/tr&gt;&lt;tr&gt;&lt;td&gt;질문이 추천받았을 때&lt;/td&gt;
      &lt;td&gt; +5&lt;/td&gt;
      &lt;td&gt;
      &lt;/td&gt;
    &lt;/tr&gt;&lt;tr&gt;&lt;td&gt;답변이 채택되었을 때&lt;/td&gt;
      &lt;td&gt; +15&lt;/td&gt;
      &lt;td&gt; (채택자에게 +2)&lt;/td&gt;
    &lt;/tr&gt;&lt;tr&gt;&lt;td&gt;질문이 반대되었을 때&lt;/td&gt;
      &lt;td&gt; -2&lt;/td&gt;
      &lt;td&gt;
      &lt;/td&gt;
    &lt;/tr&gt;&lt;tr&gt;&lt;td&gt;답변이 반대되었을 때&lt;/td&gt;
      &lt;td&gt; -2&lt;/td&gt;
      &lt;td&gt; (반대자에게 -1)&lt;/td&gt;
    &lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;단순하면서도 훌륭한 시스템이라고 생각됩니다. 무분별한 반대를 줄이기 위해 반대를 한 사람에게도 작은 페널티를 줍니다. 1점밖에 되지 않는 페널티이지만 &lt;a href=&#34;http://en.wikipedia.org/wiki/Loss_aversion&#34;&gt;손실회피&lt;/a&gt; 경향을 생각해 본다면 큰 영향력을 미치는 부분으로 보입니다.&lt;/p&gt;

&lt;h3 id=&#34;동기부여&#34;&gt;동기부여&lt;/h3&gt;

&lt;p&gt;스택오버플로는 사용자의 활발한 활동을 유도하기 위해 다양한 방법으로 동기부여를 합니다. 그 중 대표적인 두 가지를 소개해 보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;a href=&#34;http://stackoverflow.com/badges&#34;&gt;배지 시스템&lt;/a&gt;입니다. 다양한 배지를 이용하여 점수로 보상되지 않는 부분을 매워 점수와 직결되지 않는 활동도 적극 참여하도록 유도합니다. 특히 처음 활동을 시작할 때는 글을 쓰거나 추천하는 등의 간단한 활동만 해도 Student, Teacher, Supporter와 같은 이름으로 다양한 배지들을 부여하여 흥미를 유발합니다.&lt;/p&gt;

&lt;p&gt;다음으로 점수에 따른 권한 부여입니다. 처음 가입 시 시작하는 1점 상태에서는 질문/답변을 쓰는 것 외에는 아무런 활동도 할 수 없습니다. 사이트의 &lt;a href=&#34;http://stackoverflow.com/faq#reputation&#34;&gt;FAQ&lt;/a&gt;에 &amp;ldquo;점수(reputation)란 커뮤니티가 얼마나 당신을 신뢰하고 있는 것인가에 대한 측정이다(how much the community trusts you)&amp;ldquo;라는 말이 있듯이 점수로써 신뢰를 얻기 전까지는 모든 활동이 제한됩니다. 15점이 되어서야 비로소 추천을 할 수 있고, 50점이 되어야 다른 사람의 글에 댓글을 달 수 있게 됩니다. 125점이 되기 전에는 반대를 할 수 없습니다. 1,000점이 되면 해당 글의 추천/반대의 수를 나누어서 볼 수 있게 되는 등 점수가 높아질 수록 강력한 권한을 얻게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://media.tumblr.com/tumblr_m4fgyaOYwg1qimauz.png&#34; alt=&#34;1,000점 이상이 되면 확인할 수 있는 추천/반대의 수&#34; title=&#34;1,000점 이상이 되면 확인할 수 있는 추천/반대의 수&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;자정작용&#34;&gt;자정작용&lt;/h3&gt;

&lt;p&gt;앞서 말한 배지나 점수 시스템은 사이트의 자정작용에도 큰 영향을 미칩니다. 스택오버플로를 사용하며 가장 훌륭하다고 생각했던 부분이 바로 놀라운 자정작용이었습니다.&lt;/p&gt;

&lt;p&gt;일정 이상 점수가 되지 않은 사용자에게는 권한을 제한하여 스팸을 막습니다. 질문이나 답변에 문법적인 오류나 잘못된 내용이 있을 때는 위키피디아와 같이 &lt;a href=&#34;http://stackoverflow.com/faq#editing&#34;&gt;다른 사람이 수정할 수 있습니다&lt;/a&gt;. 수정한 내용은 다른 사람의 리뷰를 통해 확정되고 확정되었을 때 수정한 사람에게 2점이 부여됩니다. 점수뿐만 아니라 Editor, Archaeologist, Copy Editor 등과 같은 다양한 배지로도 수정을 유도하여 글의 퀄리티를 유지합니다.&lt;/p&gt;

&lt;p&gt;스택오버플로의 &lt;a href=&#34;http://stackoverflow.com/faq#dontask&#34;&gt;엄격한 규칙&lt;/a&gt;도 글의 자정작용에 한몫하고 있습니다. 사이트에서는 오로지 실용적이며, 실제적인 문제를 기반으로 한 답변 가능한 문제(practical, answerable questions based on actual problems that you face)만 질문하라고 하고 있습니다. 질문이 사이트의 성격과 맞지 않다고 생각되면 해당 질문은 여러 사람의 동의를 통해 가차 없이 &lt;a href=&#34;http://stackoverflow.com/faq#close&#34;&gt;close&lt;/a&gt;됩니다. 이와 같은 엄격한 규칙 때문에 아래의 질문과 같이 실제적으로는 유용하고 좋은 정보를 주며 인기도 있는 질문이 닫히는 경우도 종종 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/194812/list-of-freely-available-programming-books&#34;&gt;List of freely available programming books&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read&#34;&gt;What is the single most influential book every programmer should read?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/1995113/strangest-language-feature&#34;&gt;Strangest language feature&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/118984/how-can-you-program-if-youre-blind&#34;&gt;How can you program if you’re blind?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이와 같은 엄격한 규칙을 가진 이유에 대해서는 스택익스체인지의 블로그 글인 &lt;a href=&#34;http://blog.stackoverflow.com/2010/01/stack-overflow-where-we-hate-fun/&#34;&gt;Where We Hate Fun&lt;/a&gt;이라는 글에서 잘 설명되어 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;퀄리티-유지&#34;&gt;퀄리티 유지&lt;/h3&gt;

&lt;p&gt;앞서 설명한 사용자에 의해 이루어지는 자정작용으로도 글의 퀄리티가 높게 유지되지만 기능적으로도 글의 퀄리티나 신뢰도를 높이고 있습니다.&lt;/p&gt;

&lt;p&gt;스택오버플로에서는 본인이 작성한 &lt;a href=&#34;http://meta.stackoverflow.com/questions/25088/how-can-i-delete-my-post-on-stack-overflow&#34;&gt;질문이나&lt;/a&gt; &lt;a href=&#34;http://meta.stackoverflow.com/questions/73765/how-can-i-delete-my-answer&#34;&gt;답변도&lt;/a&gt; 자유롭게 삭제하지 못합니다. 작성한 &lt;a href=&#34;http://meta.stackoverflow.com/questions/459/should-we-be-allowed-to-edit-comments&#34;&gt;댓글은 5분 이내에만 수정이 가능&lt;/a&gt;합니다. 추천/반대 후 15분이 지나면 해당 글이 수정되기 전까지는 취소할 수 없습니다. 이와 같은 기능들은 사용자에게 불편을 줄 수도 있는 부분이지만 사용자로 하여금 신중한 글쓰기와 선택을 유도하는 데에는 탁월한 방법입니다.&lt;/p&gt;

&lt;p&gt;본인 질문에 본인이 답변 다는 것이 가능하지만, 채택은 질문을 올린 지 이틀이 지나야 가능합니다. 본인이 답변하고 채택했을 때에는 채택점수는 받을 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm8.staticflickr.com/7228/7286605860_358e0d99cc_z.jpg&#34; alt=&#34;이틀 이내에는 본인 글을 채택할 수 없는 시스템&#34; title=&#34;이틀 이내에는 본인 글을 채택할 수 없는 시스템&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;그-외-스택익스체인지-사이트&#34;&gt;그 외 스택익스체인지 사이트&lt;/h3&gt;

&lt;p&gt;다음은 스택오버플로 외에 종종 활용하는 스택익스체인지 사이트입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://programmers.stackexchange.com&#34;&gt;Programmers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://english.stackexchange.com&#34;&gt;English&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ux.stackexchange.com/&#34;&gt;UX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://apple.stackexchange.com/&#34;&gt;Apple&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Programmers Stack Exchange는 개발자를 위한 곳이라는 점에서는 스택오버플로와 같지만, 그 용도에서 &lt;a href=&#34;http://blog.stackoverflow.com/2010/12/introducing-programmers-stackexchange-com/&#34;&gt;스택오버플로와는 다른 점&lt;/a&gt;을 가집니다. 그 외의 것들은 개발과 직결되어 있진 않지만, 개발자로서 종종 활용하게 되는 곳들입니다.&lt;/p&gt;

&lt;h3 id=&#34;적극적으로-스택오버플로를-활용해야-하는-이유&#34;&gt;적극적으로 스택오버플로를 활용해야 하는 이유&lt;/h3&gt;

&lt;p&gt;스택오버플로를 활용하기 시작한 것을 매우 잘한 일이었다고 생각합니다. 왜 조금 더 일찍 시작하지 못했나 하는 아쉬움이 들 정도입니다. 스택오버플로를 잘 활용하면 다음과 같은 세 가지 장점을 얻을 수 있습니다.&lt;/p&gt;

&lt;p&gt;먼저 영어학습 효과입니다. 개발과 관련된 정보 대부분이 영어로 되어 있는 인터넷에서 &lt;a href=&#34;http://stackoverflow.com/questions/461356/does-english-hinder-improvement-of-your-programming-skills&#34;&gt;영어를 잘 못한다는 것은 개발을 잘 못한다는 것과 직결된다고 할 수 있을 정도로 개발자에게 영어는 중요합니다&lt;/a&gt;. 프로그래밍 언어도 읽기만 하기보다는 쓰기도 함께해야 실력이 빨리 느는 것처럼 실제 언어도 읽기와 쓰기를 병행해야 빠른 실력향상을 기대할 수 있다고 생각합니다. 스택오버플로는 전공 분야의 영어 쓰기를 연습해볼 수 있는 좋은 장소입니다. 잘못 사용된 단어나 문법들은 다른 사용자들이 교정해주기도 하므로 무료로 첨삭지도까지 받는 효과도 누릴 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음으로 문제 해결 능력 향상입니다. 질문자로서 활동할 때 독특한 케이스의 문제가 아닐 때에는 대부분 답변이 잘 달리는 편이라 막혀있던 문제를 해결하는데 도움을 받을 수 있습니다. 정답이 올라오지 않더라도 단서가 될만한 내용을 알려주는 경우도 많으므로 대부분 기대 이상의 효과를 얻을 수 있습니다. 답변자로 활동할 때는 여러 사람이 겪는 다양한 문제를 살펴볼 수 있고 답변하기 위해 정보를 찾다가 새로운 내용을 알게 되는 때도 많습니다. 이것 역시 문제 해결 능력에 도움을 줍니다.&lt;/p&gt;

&lt;p&gt;마지막으로 이력입니다. 질문/답변을 잘하여 좋은 점수를 가지게 되면 개인의 이력에 스택오버플로 활동 이력이 추가됩니다. 혹시 국외로 진출을 목표로 하고 있다면 더없이 좋은 이력 쌓기 방법이라고 볼 수 있습니다. 스택오버플로에서는 자체적으로 &lt;a href=&#34;http://careers.stackoverflow.com/&#34;&gt;이력서 관리 시스템&lt;/a&gt;도 제공하고 있습니다(&lt;a href=&#34;http://blog.stackoverflow.com/2011/03/careers-2-0-now-does-github/&#34;&gt;GitHub의 프로젝트도 추가할 수 있습니다&lt;/a&gt;). 국내 IT 기업에서는 이것을 얼마나 고려할지 알 수 없지만, 개인의 영어실력과 개발실력을 입증할 수 있는 좋은 방법이라는 점에는 의심의 여지가 없습니다. 앞선 기업이라면 지원자를 판단하는데 GitHub이나 스택오버플로 같은 곳에서의 활동 이력을 고려할 것이며 앞으로 그와 같은 기업은 더욱 많아질 것으로 생각합니다.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>About</title>
      <author>이상현</author>
      <link>https://iamsang.com/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://iamsang.com/about/</guid>
      <description>
        &lt;p&gt;독일 베를린에 살며 유럽기반 이커머스 기업 &lt;a href=&#34;https://tech.zalando.com&#34;&gt;잘란도(Zalando)&lt;/a&gt;에서 개발자로 일하고 있습니다.&lt;/p&gt;

&lt;p&gt;지금은 데이터 사이언스를 이용한 마케팅 개선 프로젝트를 진행 중이며 이전에는 챗봇, 컨텐츠 플랫폼, 모바일 포털, 뉴스 플랫폼 등의 프로젝트에 참여했습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Mac&lt;/code&gt;, &lt;code&gt;Vim&lt;/code&gt;, &lt;code&gt;IntelliJ&lt;/code&gt;, &lt;code&gt;Python&lt;/code&gt;, &lt;code&gt;Java&lt;/code&gt;, &lt;code&gt;JavaScript&lt;/code&gt;, &lt;code&gt;Zsh&lt;/code&gt;, &lt;code&gt;Bash&lt;/code&gt;, &lt;code&gt;Spring Framework&lt;/code&gt;, &lt;code&gt;nodejs&lt;/code&gt;, &lt;code&gt;AWS&lt;/code&gt; 등을 주로 이용해 개발합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://techneedle.com/&#34;&gt;테크니들&lt;/a&gt;을 통해 가끔 &lt;a href=&#34;http://techneedle.com/archives/author/sanghyun&#34;&gt;글을 쓰고&lt;/a&gt; 있습니다.&lt;/p&gt;

&lt;p&gt;글에 대한 의견이나 궁금한 사항은 이메일(hammerha@gmail.com)을 통해 알려주시면 감사하겠습니다.&lt;/p&gt;

&lt;p&gt;블로그 새 글 소식을 받고 싶으신 분은 페이지 아래 양식을 통해 이메일 구독하거나 &lt;a href=&#34;https://twitter.com/sangdolha&#34;&gt;트위터&lt;/a&gt;를 이용해주시기 바랍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://iamsang.com/img/zalando-jungle.jpg&#34; alt=&#34;Zalando Jungle&#34; /&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Thank You</title>
      <author>이상현</author>
      <link>https://iamsang.com/thank-you/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://iamsang.com/thank-you/</guid>
      <description>
        &lt;p&gt;구독해주셔서 감사합니다!&lt;/p&gt;

&lt;p&gt;저는 현재 독일 베를린에 살며 이커머스 기업 &lt;a href=&#34;https://tech.zalando.com&#34;&gt;잘란도(Zalando)&lt;/a&gt;에서 개발자로 일하고 있습니다.&lt;/p&gt;

&lt;p&gt;블로그 이외에 &lt;a href=&#34;http://techneedle.com/archives/author/sanghyun&#34;&gt;테크니들&lt;/a&gt;을 통해 가끔 글을 쓰고 있습니다.&lt;/p&gt;

&lt;p&gt;글에 대한 의견이나 궁금한 사항은 이메일(hammerha@gmail.com)을 통해 알려주시면 감사하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://iamsang.com/img/thank-you.jpg&#34; alt=&#34;Thank you from Berlin&#34; /&gt;&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
