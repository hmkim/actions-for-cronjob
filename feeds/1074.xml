<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Dan Kim on Medium]]></title>
        <description><![CDATA[Stories by Dan Kim on Medium]]></description>
        <link>https://medium.com/@dan_kim?source=rss-153cbcd9a954------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*Gc5Xf2iGmSfksCWiaswDYw.png</url>
            <title>Stories by Dan Kim on Medium</title>
            <link>https://medium.com/@dan_kim?source=rss-153cbcd9a954------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 16:42:56 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@dan_kim" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[[번역] 디자인할때 실용적인 일곱가지 팁]]></title>
            <link>https://medium.com/@dan_kim/%EB%B2%88%EC%97%AD-%EB%94%94%EC%9E%90%EC%9D%B8%ED%95%A0%EB%95%8C-%EC%8B%A4%EC%9A%A9%EC%A0%81%EC%9D%B8-%EC%9D%BC%EA%B3%B1%EA%B0%80%EC%A7%80-%ED%8C%81-d60c61329e8b?source=rss-153cbcd9a954------2</link>
            <guid isPermaLink="false">https://medium.com/p/d60c61329e8b</guid>
            <category><![CDATA[디자인]]></category>
            <category><![CDATA[developer]]></category>
            <category><![CDATA[design]]></category>
            <category><![CDATA[프로그래머]]></category>
            <dc:creator><![CDATA[Dan Kim]]></dc:creator>
            <pubDate>Fri, 19 Oct 2018 08:25:17 GMT</pubDate>
            <atom:updated>2018-10-19T08:25:17.370Z</atom:updated>
            <content:encoded><![CDATA[<h4>감이 아닌 전략을 기반으로 좋은 디자인하기</h4><p><em>이 글은 </em><a href="https://medium.com/refactoring-ui/7-practical-tips-for-cheating-at-design-40c736799886"><em>7 Practical Tips for Cheating at Design</em></a><em>을 번역한 글입니다.</em></p><p>모든 개발자들은 좋든 싫든 <strong>스스로 디자인적인 결정을 내려야하는 순간</strong>을 반드시 마주하게 됩니다. 예를 들어, 회사에 풀타임 디자이너가 없거나 혹은 여력이 없어 새로운 기능을 위한 디자인을 직접 해야할 수 있습니다. 혹은, 사이드 프로젝트나 간단한 웹사이트를 개발하는 상황에서도 직접 디자인을 해야하는 상황에 마주합니다.</p><p>이런 상황에서 대부분 사람들은 디자인 개선을 조금 시도하다 <em>“이게 내가 할 수 있는 최선이야. 나는 미술전공자가 아니잖아!”</em> 라며 포기하곤 합니다.</p><p>하지만, 꼭 디자인 전공자가 아니라도 스스로 더 좋은 디자인을 만들 수 있는 다양한 전략 혹은 트릭이 존재합니다. 이 글은 <strong>오늘 바로 디자인에 적용할 수 있는 일곱가지 전략</strong>을 담고 있습니다.</p><h3>1. 글자 크기 대신 색상과 두께로 계층관계를 표현하세요</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*PO1SCA-J-wemOtuesO7NKA.png" /></figure><p>글자를 스타일링 할 때 가장 일반적으로 하는 실수는 계층관계를 위해 글자 크기만 의존한다는 것입니다.</p><blockquote>“여기가 중요하지? 그러면 글자 크기를 늘려야지”<br>“여기는 좀 덜 중요한 부분이니까 글자 크기를 작게하자”</blockquote><p>하지만, 글자 크기를 조정하는 것만으로는 계층구조를 충분히 표현하기 어렵습니다. 글자의 색상과 두께를 함께 사용해보세요.</p><blockquote>“이 부분이 중요하네? <strong>글자를 두껍게 만들자</strong>”<br>“이 부분은 조금 덜 중요하네? <strong>글자에 옅은 색상을 적용하자</strong>”</blockquote><p>이때 두가지 혹은 세가지 정도의 색상만 사용하도록 노력하세요.</p><ul><li><a href="https://ianstormtaylor.com/design-tip-never-use-black/">검정색</a>은 주요한 내용에 사용 (예: 뉴스 기사의 헤드라인)</li><li>회색은 조금 덜 중요한 내용에 사용 (예: 뉴스 기사의 출판일)</li><li>옅은 회색은 부가적인 내용에 사용 (예: 저작권 표시)</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*17mTQviuVOfWoWhz62WQkA.png" /></figure><p>글자 두께의 경우 두가지만을 사용해도 충분합니다. <strong>400 이하의 글자 두께는 가급적 피하는게 좋습니다.</strong> 글자 크기가 아주 크다면 400 이하의 두께를 사용할 수 도 있습니다. 하지만, 대부분의 글자 크기는 400이하로 글자 두께를 주면 읽기 매우 어려워집니다. 만약, 어떤 콘텐츠를 덜 강조하고 싶다면, 글자 두께를 얇게하는것 보다는 옅은 색상을 사용하거나 글자 크기를 작게 만드는 것을 추천합니다.</p><ul><li>대부분의 콘텐츠에는 일반적인 두께 사용 (400 또는 500)</li><li>강조하고 싶은 콘텐츠에는 두꺼운 두께 사용 (600 또는 700)</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*do49NOr9GprCTArpqpdlMQ.png" /></figure><h3>2. 색상이 있는 배경에 회색 글자를 사용하지 마세요</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*p8Lj_Kbqq9Ne0pYl7Kzpbw.png" /></figure><p>흰색 배경에서 텍스트를 덜 강조하기 위해서 밝은 회색을 사용하는 것은 좋은 방법입니다. 하지만, 색상이 있는 배경에서는 좋은 방법이 아닙니다. 흰색 배경에서 회색이 좋은 이유는 회색과 흰색이 조화를 이루는 색이기 때문입니다. <strong>배경색과 조화를 이루는 유사한 글자 색을 사용하는 것이 훨씬 보기에 좋습니다.</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*NbBwC7jhd6P92i_glTdWug.png" /></figure><p>흰색이 아닌 배경에서 조화로운 글자 색상을 선택하는 두가지 방법이 있습니다.</p><h4>흰색 글자에서 불투명함(opacity) 감소시키기</h4><p>한가지 방법은 흰색 글자를 선택하고 불투명도를 낮게 주는 방법입니다. 이렇게 하면 배경색이 흰색 글자에 자연스럽게 비치면서, 배경색과 조화를 이루는 색을 사용할 수 있게 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Yu6uUy8TNbA0yanJ2di8CA.png" /></figure><h4>배경색을 기반으로 수동으로 선택하기</h4><p>두번째 방법은 배경이 이미지거나 패턴일때 사용하면 좋습니다. 배경색과 동일한 색조를 가지는 색상을 선택한 다음, 여러분 눈에 괜찮다 싶을때까지 선명도와 밝기를 조정해보세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*mwsvV63v-iRKL1zc8rSKUw.png" /></figure><h3>3. 그림자 오프셋</h3><p>보통 박스 혹은 카드를 더 눈에 띄게 만들기 위해서 그림자에 흐림값(blur)과 퍼지는 정도(spread)를 늘리곤 합니다. 이렇게 그림자가 전체적으로 퍼지는것처럼 만들지 말고, 아래 쪽 그림자 오프셋을 크게 주는 방법을 사용하세요. 이 방법은 우리가 실제 세상에서 물체를 위에서 볼때처럼 그림자를 만들어주기 때문에 훨씬 더 자연스럽게 보입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*u2mqRv3YmbmQ8T6Wj2T5XA.png" /></figure><p>이 방법은 입력값을 받는 디자인에도 동일하게 적용 가능합니다. 그림자 디자인에 대해서 더 많은 부분에 관심이 있다면, <a href="https://material.io/guidelines/material-design/elevation-shadows.html">Material 디자인 가이드</a>를 참고하세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*xUsqf00Wikv2MxO4CVMzkA.png" /></figure><h3>4. 경계선은 최소화 하세요</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*xUsqf00Wikv2MxO4CVMzkA.png" /></figure><p>두 가지 아이템을 분리하고 싶을때, 곧바로 경계선을 사용하지는 마세요. 물론, 경계선은 두가지 아이템을 분리하는데 좋은 방법입니다. 하지만, 너무 경계선을 많이 사용하게되면 여러분이 한 디자인이 정신없어 보이게 됩니다. 만약 디자인을 하는 중에 경계선이 머릿속에 떠오른다면, 대신 다음 아이디어들을 고려해보세요.</p><h4>박스 그림자 사용하기</h4><p>박스 그림자는 경계선처럼 하나의 아이템의 윤곽을 표현하는데 좋은 방법입니다. 경계선보다 훨씬 더 작은 디자인이지만, 디자인을 산만하게 하지 않으면서 경계선과 동일한 효과를 얻을 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*-oG3h3aoDZdwjb2cYMx65Q.png" /></figure><h4>다른 배경색을 사용하기</h4><p>보통 붙어있는 두 가지 아이템에 약간 다른 배경색을 적용하는 것만으로도 두 가지 아이템을 분리하는데 충분합니다. 만약 여러분이 두가지 다른 배경색을 사용하고 있으면서도 경계선도 사용하고 있다면, 경계선은 지워도 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*myUOizMFaUKfsyMFw0Mczw.png" /></figure><h4>추가 여백주기</h4><p>분리하고 싶은 두 가지 아이템 사이에 간단하게 여백을 추가하는것 보다 좋은 방법이 있을까요? 추가로 여백을 주는것은 어떠한 새로운 디자인 아이템을 추가하지 않아도 아이템들의 그룹을 구분하는데 효과적인 방법입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*4yb90ggbDg3-6uRpJwNiFA.png" /></figure><h3>5. 작게 디자인된 아이콘을 너무 키우지 마세요</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*fkGuVwY-MevCfWdVVpBt8g.png" /></figure><p>큰 아이콘이 필요한 화면을 디자인하고 있다고 가정해봅시다. 예를 들어, 랜딩 페이지에서 기능을 소개하는 디자인이 있을 수 있습니다. 아마도 우리는 본능적으로 <a href="https://fontawesome.com/">Font Awesome</a>이나 <a href="http://www.zondicons.com/">Zondicons</a> 같은 사이트에서 무료 아이콘 셋을 받은 후에 여러분의 디자인에 맞도록 아이콘을 키울 것 입니다.</p><p>그 아이콘들은 모두 벡터 이미지이기 때문에 아이콘을 키워도 품질에 영향이 없지 않냐구요? 물론, 벡터 이미지는 사이즈를 키운다고 해서 품질이 떨어지는 것은 아닙니다. 하지만,<strong> 16–24px로 디자인된 아이콘들은 3배 혹은 4배로 커졌을때 전문적으로 보이지 않습니다.</strong> 보통 작은 아이콘들은 디테일을 그리지 않기 때문에, 커지면 커질수록 하나의 덩어리처럼 보일 뿐 입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ZbQNP8Dh3gpXVCs4aCP8-w.png" /></figure><p>만일 가지고 있는 재료가 조그마한 아이콘들 뿐이라면 사이즈를 키우는 대신 모양이 있는 배경색을 뒤에 붙여 보세요. 이 방법은 실제로 디자인된 사이즈와 비슷하게 아이콘을 유지 할 수 있을 뿐 아니라, 큰 화면을 채우는데 유용합니다. 만약, 돈이 있다면 <a href="http://www.heroicons.com/">Heroicons</a> 혹은 <a href="https://useiconic.com/">Iconic</a>과 같은 큰 화면을 위해 디자인된 아이콘을 사용하는것도 가능할 것 입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*WaCk0rXMmwhqqhiw4z81jQ.png" /></figure><h3>6. 브랜드 디자인에 색상을 추가하기 위해 색으로 강조된 경계선을 사용하세요</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*0epa3HkR6Me2q2okSYnw4Q.png" /></figure><p>여러분이 그래픽 디자이너가 아닌데도 디자인에 시각적인 감각을 어떻게 넣을 수 있을까요? 다른 디자인들은 아름다운 사진이나 칼라풀한 일러스트레이션으로 구성되어있는 상태에서 말이죠. 다른 디자인 아이템과 큰 차이를 낼 수 있는 간단한 트릭은 색상으로 강조된 경계선을 조금 단조롭게 느껴지는 아이템에 추가하는 것입니다.</p><p>예를 들어, 아래의 경고 메세지 옆…</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/700/1*StgJ9Cv9n48-RB8qd2md3A.png" /></figure><p>… 또는 활성화된 네비게이션 아이템 밑</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/700/1*CgC53xD1Wz1CrHBNN-vdQw.png" /></figure><p>… 또는 레이아웃 상단 전체에 색상이 있는 경계선을 넣을 수 있을 것 입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*IBA-bjUg4EY62bRq5XqF-A.png" /></figure><p>UI에 색상이 있는 사각형을 넣는 것은 어떠한 그래픽 디자인적 재능을 필요로 하지 않습니다. 그러면서도 여러분의 사이트를 보다 “디자인된” 사이트로 보일 수 있게 만들어 줍니다. 색을 고르는게 혹시 어렵나요? <a href="https://dribbble.com/colors">Dribble Color Search</a>와 같은 이미 파레트 형태로 제공하고 있는 색상표에서 색을 선택해보세요. 이런 도구들은 끝도없는 색의 세계에서 색을 선택해야하는 부담을 덜어 줍니다.</p><h3>7. 모든 버튼이 배경색을 가져야하는 것은 아닙니다</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*tPn5eREr14bTbJ6aU-ZcKA.png" /></figure><p>사용자가 하나의 페이지에서 여러개의 동작을 선택할 수 있을 때, 순수하게 각 버튼이 가지는 의미만을 기반으로 각 동작을 디자인하는 함정에 빠지기 쉽습니다. Bootstrap과 같은 프레임워크들은 아래와 같이 의미에 따라서 다른 버튼 색상을 제공함으로써, 대부분의 사람들이 위와 같은 실수를 하는것을 부추깁니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*xRFqDAdmVv38QvzlWSY2bA.png" /></figure><blockquote>“긍정적인 동작이네? 버튼을 초록색으로 만들자.”<br>“삭제 버튼이잖아? 빨간색으로 만들어야지.”</blockquote><p>버튼 디자인에 있어서 버튼이 가지는 의미는 매우 중요합니다. 하지만, 이보다 훨씬 더 중요한 요소를 우리는 흔히들 잊어버립니다. 바로, <strong>계층구조(hierarchy)</strong> 입니다.</p><p>하나의 페이지에 존재하는 모든 동작들은 중요도 기반의 피라미드 어딘가에 위치합니다. 대부분의 페이지는 단 하나의 가장 우선되는 동작을 가지고 있고, 조금 덜 중요한 동작들이 몇 가지 있으며, 몇개 안되는 중요하지 않은 동작들이 존재합니다.</p><p>이러한 동작들을 디자인할 때에는 이 계층구조안에서 그들이 어떤 위치에 있는지를 생각하는것이 굉장히 중요합니다.</p><ul><li><strong>가장 중요한 동작은 반드시 명백해야합니다.</strong> 단색이며 배경색과 대조를 이루는 색상이 여기에서 잘 동작합니다.</li><li><strong>두번째로 중요한 동작들은 명확해야하지만 너무 눈에 띄면 안됩니다. </strong>경계선만 주거나 배경색과 비슷한 색상을 사용하는것이 좋은 선택지입니다.</li><li><strong>가장 덜 중요한 동작들은 찾을 수는 있되 시선을 뺏어서는 안됩니다.</strong> 링크처럼 디자인하는것이 가장 좋은 접근입니다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*uojU5JuIT0qSKwkicDBf4A.png" /></figure><blockquote>“부정적인 의미를 담고 있는 동작들은 항상 빨간색일 필요는 없나요?”</blockquote><p>반드시 그럴 필요는 없습니다. 만약 부정적인 동작들이 해당 페이지에서 가장 중요한 동작이 아니라면, 두번째 혹은 세번째로 중요한 동작들로 취급하는것이 더 좋은 방법입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*s11HY_74arTsAzWC_Lhn2w.png" /></figure><p>부정적인 의미를 담고 있는 동작이 실제로 해당 페이지의 가장 주요한 동작이라면, 크고, 빨갛고, 두꺼운 글자를 사용해서 디자인 하세요. 아래 확인 다이얼로그처럼 말이죠.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*3YUan8HXkcSqVTfWTPT9Ig.png" /></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d60c61329e8b" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[스타트업은 언제 미션이 필요할까?]]></title>
            <link>https://medium.com/delightroom/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85%EC%9D%80-%EC%96%B8%EC%A0%9C-%EB%AF%B8%EC%85%98%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C-1dfb3d61c43d?source=rss-153cbcd9a954------2</link>
            <guid isPermaLink="false">https://medium.com/p/1dfb3d61c43d</guid>
            <category><![CDATA[product-market-fit]]></category>
            <category><![CDATA[startup]]></category>
            <category><![CDATA[mvp]]></category>
            <category><![CDATA[mission]]></category>
            <category><![CDATA[conflict]]></category>
            <dc:creator><![CDATA[Dan Kim]]></dc:creator>
            <pubDate>Thu, 02 Aug 2018 00:23:33 GMT</pubDate>
            <atom:updated>2018-08-09T07:35:36.178Z</atom:updated>
            <content:encoded><![CDATA[<p>스타트업에서 미션은 계륵같은 존재다. 미션 없이 가자니 핵심 가치도 없이 방황하는 회사같고, 막상 미션을 잡아도 사용되지 않아 없느니만 못하다. 딜라이트룸 역시 오랜시간 미션의 필요성과 효용성에 대해 많은 고민을 해왔다. 그리고 최근에 이르러 미션을 정하게 되었다. 이 글에서는 우리 팀이 미션의 필요성을 느껴온 과정과 이를 통해 배운 교훈을 공유하고자 한다.</p><h3>미션이 필요하지 않은 초기</h3><p>초기에는 어디로 갈지 고민하기 보다 빠르게 한 걸음 한 걸음 나아가는 것이 더 중요하다. 사용자가 원하는 제품을 만들기 위해 피드백을 반영하고 수익을 내기위해 최선을 다하다보면 자연스레 어딘가 도착하게 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/586/1*Z8EX_X4yzbG5Mn8amFH_aw.png" /></figure><p><strong>초기에는 사용자가 필요한 기능을 더 잘 알고 있다. </strong>알라미를 출시하고 가장 우선시 했던 것은 사용자들이 겪는 불편 사항을 해결하고 개선하는 것이었다. 사용자로부터 들어오는 피드백이 최고의 우선순위를 가지고 있었다. 한가지 예를 들자면, 몇명의 사용자가 수학 알람 해제 방법에서 쉬움 난이도도 너무 어렵다고 했다. 당시 쉬움 난이도는 두 자릿수 덧셈 (23 + 17)이 었는데, 더 쉬운 한 자릿수 덧셈(3 + 7)도 추가해달라고 한것이다. 한 자릿수 덧셈은 너무 쉬워서 잠을 깨우는데 아무런 도움이 될 것 같지 않았지만, 이런 사용자도 있겠구나하면서 기능을 추가했다. 이렇게 추가된 한 자릿수 덧셈은 현재 전체 난이도 사용률 중 25%를 차지하고 있다. 이처럼 초기에는 사용자의 목소리에 귀기울여 우선순위를 정하면 대부분 좋은 결과로 이어진다.</p><p><strong>초기에는 수익을 만들기 위해 최선을 다해야한다. </strong>미션이 있든 없든, 수익이 발생하지 않는다면 그 팀은 계속 함께하기 어렵다. 지금은 투자없이 자체 수익으로 회사가 운영되고 있지만, 초기에는 알람 앱으로 수익을 낼 수 있는지 매우 불확실했다. 수익을 만들어 낼 수 있다면 모든 방법을 시도했다. 이 당시 미션의 필요성에 대해서 우리팀이 한 이야기는 다음과 같다. 미션이 아침에 사람들을 깨우는 것으로 정해져있다고 가정해보자. 만약 아침에 사람들을 깨우는것과 관계가 없지만, 앱에 추가해서 많은 돈을 벌 수 있다면 하지 않을 것인가? 당연히 해야한다는 것이 그 당시 우리의 답이었다. 몇 번이고 미션과 관련된 논의가 진행될때마다 우리의 답은 “지금 미션에 대한 고민은 의미가 없다. 수익을 얻도록 최선을 다하자&quot; 였다.</p><h3>미션이 필요하다는 두가지 증상</h3><p>이러한 노력은 다행히도 좋은 결과로 이어졌다. 사용자수도, 수익도 엄청난 성장을 했다. 하지만, DAU가 100만이 넘어가고 팀원도 7명이 넘어가자 미션에 대한 필요성이 드러났다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/510/1*oD2rokEolQjY3IUoJJ95YA.jpeg" /></figure><p><strong>첫번째, 의사결정 시간이 너무 오래걸린다.</strong> 사용자가 늘어남에 따라 피드백 숫자가 기하급수적으로 늘어났다. 이제는 초기와 다르게 모든 피드백을 바로 바로 반영하는것은 불가능해졌다. 이미 백로그에 일들이 쌓여있어, 어떤 일을 먼저할지 우선 순위를 잘 결정해야했다. 소수 팀원으로 구성된 팀에서 잘 못된 우선순위 선택은 큰 타격으로 이어지기 때문이다. 하지만, 미션이 없는 상태에서 팀원들 각자가 자신의 기준으로 일의 우선순위를 정하다보니 합의를 이뤄내는데 시간이 너무 오래 걸렸다. 어떤 팀원은 수익과 관련된 기능을 중요시하고, 어떤 팀원은 리텐션 관련된 일을 중요시했다. 이때, 각 팀원들이 모두 타당한 이유를 가지고 주장을 하다보니 무엇이 더 중요한지 판단하는데 매우 어려웠다. 하나의 목표를 이루기위해 합심하기 보다는, 어쩌면 누가 더 똑똑한지 판단하는데 시간을 많이 허비했다.</p><p><strong>두번째, 팀 응집력이 감소한다.</strong> 초기에는 어떤 기능을 개발할지 이야기할때, 모든 팀원이 함께 미팅을 진행했다. 무슨 일을 하든지 함께했고, 회사 내부에서 어떤 일이 진행되고 있는지 그게 왜 중요한지 모든 팀원이 이해하고 있었다. 하지만, 팀원이 점점 늘어나자 모두 함께 미팅을 진행하는 것은 불가능했고, 또 비효율적이었다. 팀원이 늘어나면서 각자가 맡은 분야가 점점 명확해져갔다. 문제는 서로 모르는 부분들이 늘어나다보니, 업무 시간에 팀원들이 함께 이야기하는 시간이 점점 줄어든다는 것이었다. 스타트업은 인원이 적어 보통 각자가 독립된 분야를 맡다보니 그 영향이 더 극적으로 나타난다. 나의 경우도 어떤 날에는 회사에서 하루종일 팀원들과 이야기를 하지 않아도 큰 문제가 되지 않는다고 느끼기도 했다. 우리 팀이 하나의 목적을 가지고 함께 한다는 느낌이 줄어들었다.</p><h3>사람들의 아침을 깨우는 사람들</h3><p>위 문제를 해결하기 위해 다양한 방법론들이 언급되었다. 분기 목표가 명확하지 않다, 개인 마일스톤 관리가 되지 않는다 등. 수 시간의 긴 논의 끝에 모든 것들에 앞서 미션을 정해야한다는 결론에 이르렀다. 팀원들 모두가 공유하는 미션 아래 분기 목표가 세워지고, 그 아래에 팀의 목표가 세워지고, 그 아래 개인의 목표를 세우는 그림이다. 이를 통해 우리가 겪는 문제가 해결될 것으로 기대되었다. 그렇게 정해진 우리의 미션은 이것이다.</p><blockquote><strong>Help people wake up, Effectively</strong></blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*rc1qWz8K67OTc73X5-qTSg.png" /><figcaption>알라미가 깨우고 있는 사람들의 숫자 변화.</figcaption></figure><p><strong>우리는 사람들이 아침에 일어나도록 효과적으로 도와주는 일을 한다</strong>. 알람 서비스를 운영하면서 아침에 사람들을 깨우는 것이 그들의 삶에 얼마나 큰 영향을 주는지 느낄 수 있었다. 아침에 잘 일어나는 것은 단순히 게으름의 문제가 아니었다. 직장인들에게는 제 시간에 출근하도록 도와준다는 측면에서 생업의 문제이고, 재수생은 원하는 시간에 하루를 주도적으로 시작한다는 측면에서 자존감의 문제이기도 했다. 아침에 일어나고 싶지만 힘들어하는 사람들을 일어나도록 효과적으로 도와주는 알람 서비스를 만드는것이 우리의 미션이라는 결론이었다.</p><h3>마치며</h3><p>우리 경험을 기반으로 생각했을 때, 초기에는 미션의 필요성이 크지 않다. 이때는 사용자가 원하는 제품을 만들기 위해 열심히 피드백을 반영하고 수익을 만들기 위해 모든 방법을 시도해야하는 시기다. 나타나는 증상은 팀마다 다르겠지만 제품과 팀이 일정 수준 이상으로 성장하면 자연스럽게 미션에 대한 필요성이 드러나게 된다. 이때가 바로 미션이 필요할때라고 생각한다.</p><h3>We’re hiring</h3><p>우리팀은 분야에 상관없이 인재를 영입하고 있다. 팀원이 공유하는 미션 아래에서 딜라이트룸에 관심이 있다면 아래 링크를 클릭!!<br>&gt;&gt; <a href="http://bit.ly/2OysPlP">http://bit.ly/2OysPlP</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1dfb3d61c43d" width="1" height="1"><hr><p><a href="https://medium.com/delightroom/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85%EC%9D%80-%EC%96%B8%EC%A0%9C-%EB%AF%B8%EC%85%98%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C-1dfb3d61c43d">스타트업은 언제 미션이 필요할까?</a> was originally published in <a href="https://medium.com/delightroom">DelightRoom</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[파이썬 초심자를 위한 PIP 그리고 Virtualenv 소개]]></title>
            <link>https://medium.com/@dan_kim/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%B4%88%EC%8B%AC%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-pip-%EA%B7%B8%EB%A6%AC%EA%B3%A0-virtualenv-%EC%86%8C%EA%B0%9C-a53512fab3c2?source=rss-153cbcd9a954------2</link>
            <guid isPermaLink="false">https://medium.com/p/a53512fab3c2</guid>
            <category><![CDATA[beginner]]></category>
            <category><![CDATA[virtualenv]]></category>
            <category><![CDATA[python]]></category>
            <category><![CDATA[pip]]></category>
            <dc:creator><![CDATA[Dan Kim]]></dc:creator>
            <pubDate>Wed, 30 May 2018 00:32:49 GMT</pubDate>
            <atom:updated>2018-05-30T00:32:49.368Z</atom:updated>
            <content:encoded><![CDATA[<p>이 글은 <a href="https://www.dabapps.com/blog/introduction-to-pip-and-virtualenv-python/"><strong>A non-magical introduction to Pip and Virtualenv for Python beginners</strong></a>를 번역한 글입니다.</p><p>파이썬의 신규 개발자들이 반드시 넘어야할 산중 하나는 파이썬 패키징 생태계를 이해하는 것입니다. 이 글에서는 <a href="https://www.dabapps.com/what-we-do/python-for-programmers/"><strong>Python for Programming training course</strong></a>에서 다루었던 자료를 기반으로 파이썬 초심자들을 위해<a href="http://pip-installer.org/"><strong>pip</strong></a>와 <a href="http://www.virtualenv.org/"><strong>virtualenv</strong></a>를 설명하고자 합니다.</p><h3>전제 조건</h3><p>Python for Programmers 강의는 하나 이상의 개발 언어에 익숙한 개발자들을 대상으로 한 강의였기 때문에, 이 글은 여러분이 어느 정도 수준의 기술 지식을 가지고 있다고 가정하고 있습니다. 커맨드 라인 사용에 대해 편하게 느낀다면 이 글을 쉽게 이해하는데 도움이 될것입니다. 이 글에서 예제들은 맥과 리눅스 환경에서 기본으로 사용되는 shell인 <strong>bash</strong>를 사용할 예정입니다. 하지만, 사용할 명령어들이 매우 간단하기 때문에 윈도우의 PowerShell에서도 동일한 개념의 명령어를 쉽게 찾아서 사용하실 수 있을 겁니다.</p><h3>PIP</h3><p>이제 시작해봅시다. <a href="http://pip-installer.org/"><strong>pip</strong></a>는 <a href="http://pypi.python.org/"><strong>Python Package Index</strong></a> (PyPI) 저장소로부터 파이썬 패키지를 받아 설치하는 패키지 관리 도구입니다. PyPI (가끔 <a href="http://stackoverflow.com/questions/5393986/why-is-pypi-called-the-cheese-shop"><strong>The Cheeseshop</strong></a> 이라고도 불리는)는 third-party 파이썬 오픈소스 패키지들을 위한 저장소입니다. Ruby에서의 RubyGems 혹은 PHP의 Packagist, Perl의 CPAN 그리고 Node.js의 NPM와 비슷하다고 생각하시면 됩니다.</p><p>사실 Python은 훨씬 더 기초적인 패키지 매니저인 easy_install을 가지고 있습니다. 여러분이 처음 Python을 설치할때 easy_install은 자동으로 설치됩니다. 하지만, 여러 측면에서 easy_install 보다 훨씬 더 우월한 pip를 사용하는것이 일반적입니다. 먼저, easy_install을 통해 pip를 다음과 같이 설치할 수 있습니다:</p><pre>$ sudo easy_install pip</pre><p>이제 pip를 통해 패키지들을 설치할 수 있습니다. (아래 예제에서는 <a href="https://www.djangoproject.com/"><strong>Django</strong></a>를 설치해봅시다):</p><pre># DON&#39;T DO THIS<br>$ sudo pip install django</pre><p>여기서 우리는 Django를 시스템 전체에 (global) 설치하였습니다. 하지만, 대부분의 경우 패키지를 <strong>글로벌하게 설치하지 않아야합니다</strong>. 계속해서 읽어보면서 이유를 찾아보세요.</p><h3>Virtualenv</h3><p><a href="http://www.virtualenv.org/"><strong>virtualenv</strong></a>는 아주 구체적인 문제를 해결합니다: 보통 여러개의 파이썬 프로젝트가 하나의 컴퓨터에서 충동을 일으키지 않고 존재할 수 있도록 도와줍니다.</p><h3>어떤 문제를 해결하나요?</h3><p>virtualenv가 해결하는 문제를 설명하기 위해, 먼저 virtualenv가 존재하지 않는다고 가정해봅시다. 여러분은 외부 웹 서버에 HTTP 요청을 보내는 파이썬 프로그램을 작성해야하는 상황입니다. 이 일에 뛰어난 <a href="http://python-requests.org/"><strong>Requests</strong></a> 라이브러리를 사용할 예정입니다. 위에서 보여준것처럼 <strong>pip</strong>를 이용해 Requests 라이브러리를 설치해봅시다.</p><p>그런데, pip는 여러분의 컴퓨터 어느곳에 패키지를 설치할까요? 여러분이 pip install requests 명령어를 실행시키면 다음과 같은 일이 발생합니다.</p><pre>$ pip install requests<br> Downloading/unpacking requests<br>     Downloading requests-1.0.0.tar.gz (337Kb): 337Kb downloaded<br>     Running setup.py egg_info for package requests<br> <br> Installing collected packages: requests<br>     Running setup.py install for requests<br> <br>     error: could not create &#39;/Library/Python/2.7/site-packages/requests&#39;: Permission denied</pre><p>pip가 /Library/Python/2.7/site-packages/requests 안에 패키지를 설치하려고 했던 것으로 보입니다. 이 폴더는 파이썬이 알고있는 <strong>특별한 폴더</strong>입니다. site-packages 내부에 패키지가 설치되면, 파이썬 프로그램에서 이 패키지를 임포트해서 사용할 수 있게됩니다.</p><p>하지만, 위에서는 에러가 발생했습니다. 일반적으로 맥에서 <strong>“일반 사용자”</strong> 는 /Library 폴더에 쓰기 권한이 없기 때문에 위와 같은 에러가 발생한것입니다. 이 에러를 고치기 위해서는 sudo pip install requests 명령어를 실행하면 됩니다. 여기에서 sudo는 <strong>“슈퍼 유저”</strong>로 명령어를 실행하라는 의미입니다.</p><pre>$ sudo pip install requests<br> Password:<br> Downloading/unpacking requestss<br>     Running setup.py egg_info for package requests<br> <br> Installing collected packages: requests<br>     Running setup.py install for requests<br> <br> Successfully installed requests<br> Cleaning up ...</pre><p>이제 정상적으로 동작합니다. <strong>python </strong>명령어를 실행해서 Requests 라이브러리를 임포트해봅시다:</p><pre>&gt;&gt;&gt; import requests<br>&gt;&gt;&gt; requests.get(&#39;<a href="http://dabapps.com&#39;">http://dabapps.com&#39;</a>)<br>&lt;Response [200]&gt;</pre><p>지금까지 우리는 pip를 통해 라이브러리를 설치하고, 이 패키지를 import requests 구문을 통해 파이썬 프로그램 내에서 사용해보았습니다. 시간이 지나서, PyPI에서 다른 라이브러리들을 가져와서 우리의 앱을 계속 발전시켰다고 가정해봅시다. 시간이지나 우리가 발전시킨 앱은 뛰어난 성능을 보여주면서 많은 돈을 벌 수 있었고, 사용자들은 약간의 차이가 있는 새로운 프로그램을 작성해달라는 요청을 보내고 있습니다.</p><p>사용자들의 요청에 보답하여 새로운 앱을 만들어보고자 새로운 프로젝트를 시작했습니다. 이번 앱에도 requests 라이브러리가 필요한데, 첫번째 앱을 만들었던 이후로 requests 라이브러리에는 새로운 기능이 추가된것을 확인했습니다. 이 추가된 기능이 새로 앱에서 필수적인 상황입니다. 새로운 기능을 사용하기 위해 다음과 같은 pip 명령어로 requests 라이브러리를 업데이트했다고 가정합니다:</p><pre>sudo pip install --upgrade requests</pre><p>모든 것이 좋아보이지만, 우리가 알지 못하는 사이에 재앙은 발생하고 있습니다! 업데이트 이후, 우리에게 돈을 많이 벌어다주던 기존의 프로그램을 돌려보자 프로그램이 에러가 납니다. 왜일까요? 바로 <strong>requests 라이브러리가 변경</strong>되었기 때문입니다. 아주 작은 변화였지만, 우리의 코드가 더 이상 이 라이브러리를 못쓰는 상황이 벌어진 것입니다. 모든 것이 망가져 버렸습니다.</p><p>물론, 새로운 <strong>requests API</strong>를 사용하도록 기존의 프로그램을 변경해 문제를 해결할 수 있습니다. 하지만, 시간이 소요되고 새로운 프로젝트에서 집중도를 잃게 됩니다. 보통 숙련된 파이썬 개발자는 단지 2개의 프로젝트만 가지고 있지 않습니다. 수십가지 프로젝트를 동시에 진행하고, 각 프로젝트는 수십가지의 라이브러리에 대한 의존성을 가지고 있습니다! 이 라이브러리 전체를 최신버전으로 유지하고 모든 프로젝트에서 동일한 버전의 라이브러리를 사용하도록 만드는 것은 완전 악몽입니다.</p><h3>어떻게 virtualenv는 이 문제를 해결하나요?</h3><p>virtualenv는 각 프로그램별로 완전히 독립적인 가상의 환경을 만들어냄으로써 이 문제를 해결합니다. 여기서 환경이란 파이썬 프로그램을 실행시키는데 필요한 모든것의 복사본을 가지고 있는 단순한 폴더입니다. 전체 파이썬 스탠다드 라이브러리 복사본, pip 설치 프로그램 복사본, 그리고 위에서 언급한 site-packages 복사본 등을 포함합니다. 여러분이 virtualenv 도구를 이용해 생성된 pip 복사본을 이용해 PyPI로 부터 패키지를 설치하면, <strong>virtualenv 폴더 내부의 site-packages 폴더에 이를 설치</strong>합니다. 그리고 설치된 패키지는 이전과 동일한 방법으로 파이썬 프로그램 내부에서 사용할 수 있습니다.</p><h3>어떻게 virtualenv를 설치하나요?</h3><p>만약 여러분이 이미 pip를 설치하셨다면, virtualenv를 설치하는 가장 쉬운 방법은 sudo pip install virtualenv 명령어 입니다. pip와 virtualenv는 일반적으로 글로벌 설치가 되어야하는 유일한 패키지입니다. 이 두개를 설치하고 나면 나머지 패키지들은 가상 환경에 설치하면 되기 때문입니다.</p><p>사실, virtualenv는 pip의 복사본을 수반하고 있습니다. 그렇기에 여러분이 필요한것은 <strong>사실상 virtualenv 뿐</strong>입니다. virtualenv는 PyPi에서 설치하는 것이 아닌 독립적인 패키지로 설치가 가능합니다. 이런 방법은 윈도우 사용자들에게 더 쉬울 수 있습니다. <a href="http://www.virtualenv.org/"><strong>virtualenv.org</strong></a> 에 있는 설치 안내를 참고해주세요.</p><h3>어떻게 새로운 가상 환경을 생성할 수 있나요?</h3><p>새로운 환경을 만들기 위해서는 <strong>virtualenv</strong>만 있으면 됩니다. 아주 간단하죠. 여러분 프로젝트의 루트 폴더로 이동한 이후, 아래와 같이 <strong>virtualenv</strong> 명령어로 생성하면 됩니다.</p><pre>$ cd ~/code/myproject<br>$ virutalenv env<br> New python executable in /env/bin/python<br> Installing setuptools ..... done.<br> Installing pip .... done.</pre><p>여기에서, env는 여러분의 가상 환경을 생성할 폴더의 이름입니다. 아무런 이름을 붙여도 되지만, 보통 env라고 부르고 프로젝트 디렉토리 내부에 이를 만드는 것이 일반적인 관습입니다. 예를 들어, 여러분이 코드를 ~/code/projectname/ 에 보관한다고 하면, ~/code/projectname/env가 새롭게 만들어진 환경이라고 생각하시면 됩니다. 하지만, 여러분이 원하는 폴더 이름으로 지으셔도 상관없고, 프로젝트 폴더 외부에 위치시켜도 상관 없습니다.</p><blockquote>만약 여러분이 git과 같은 버전 컨트롤 시스템을 사용하고 계신다면, env 디렉토리를 커밋에 포함시키지않는 것을 추천합니다. 반드시 .gitignore 파일에 env 디렉토리를 추가하세요.</blockquote><h3>어떻게 새로운 가상 환경을 사용하나요?</h3><p>방금 새롭게 생성한 env 폴더 내부를 살펴보면, 아래와 같은 몇몇개의 폴더를 확인할 수 있습니다.</p><pre>$ ls env<br>bin include lib</pre><p>여러분이 가장 관심을 기울여야하는 폴더는 bin 입니다. 이 폴더는 파이썬 라이브러리의 로컬 복사본과 pip 설치 복사본이 있는 곳입니다. 이제 pip 복사본을 이용해서 vitrualenv 내부에 requests 라이브러리를 설치해봅시다.</p><pre>$ env/bin/pip install requests<br> Downloading/unpacking requests<br>     Downloading requests-1.1.0.tar.gz (337Kb): 337kB downloaded<br>     Running setup.py egg_info for package requests<br> <br> Installing collected packages: requests<br>     Running setup.py install for requests<br> <br> Successfully installed requests<br> Cleaning up...</pre><p>동작하는군요! 여기에서 여러분이 <strong>sudo를 사용하지 않았다는 점</strong>을 기억하세요. 이제 requests를 글로벌로 설치하지 않고 home 폴더내부에 설치하기 때문에, 더이상 sudo가 필요하지 않은것입니다.</p><p>이제, Python shell을 실행하기 위해 pytho 명령어를 실행하지 않고, env/bin/python 명령어를 실행하면 됩니다.</p><pre>&gt;&gt;&gt; import requests<br>&gt;&gt;&gt; requests.get(&#39;<a href="http://dabapps.com&#39;">http://dabapps.com&#39;</a>)<br>&lt;Response [200]&gt;</pre><h3>하지만, 너무 타이핑을 많이해야해요</h3><p>virtualenv는 숨겨진 다양한 트릭들을 가지고 있습니다. env/bin/python 그리고 env/bin/pip를 매번 입력하는 대신, 우리가 만든 가상 환경을 실행시킬 수 있습니다. source env/bin/activate 명령어를 통해서 활성화시키면 이 스크립트는 여러분의 shell의 몇몇 변수들을 일시적으로 조정합니다. 그래서, python을 타이핑하면 글로벌 python 대신 virtualenv 내부에 있는 Python 실행파일을 얻을 수 있게 됩니다:</p><pre>$  which python<br> /usr/bin/python<br>$ source env/bin/activate<br>$ which python<br> /Users/jamie/code/myproject/env/bin/python</pre><p>이제 여러분이 env/bin/pip install requests를 입력하는 대신에 pip install requests라고 입력하면 글로벌이 아닌 우리의 가상환경에 라이브러리를 설치하게 됩니다. 스크립트가 터미널에 준 이 변화는 터미널이 열려있는 동안만 유지가 됩니다. 때문에 여러분이 새로운 터미널을 실행시키면 다시 source env/bin/activate 스크립트를 실행시켜야합니다. 다른 프로젝트로 이동하고 싶다면 deactivate 명령어를 통해 현재 가상환경의 사용을 종료시킬 수 있습니다. 이후, 해당 프로젝트로 이동해 source /env/bin/activate 명령어를 실행시키면 됩니다.</p><p>Activating과 Deactivating은 여러분이 타이핑을 하는 것을 감소시켜줍니다. 하지만, 이것을 사용하면 조금은 혼란스러울 수 있습니다. 이를 사용할지 말지는 여러분에게 달려있습니다.</p><h3>Requirements 파일</h3><p>pip의 requrements 기능을 사용할때 virtualenv와 pip는 서로 아주 좋은 동료가 됩니다. 여러분의 각 작업 프로젝트는 각기 자기들만의 requirements.txt 파일을 가지고 있습니다. 이 파일을 가상환경에서 필요한 라이브러리들을 설치하는데 사용할 수 있습니다:</p><pre>env/bin/pip install -r requirements.txt</pre><p>더 자세한 정보는 pip 문서를 참고해주세요.</p><h3>정리</h3><ul><li>pip는 Python Package Index에서 패키지를 설치하는 도구입니다.</li><li>virtualenv는 <strong>python, pip, PyPI </strong>부터 설치된 라이브러리들의 복사본을 만듦으로써, 독립적인 파이썬 환경을 만들어주는 도구입니다.</li><li>이는 여러분이 동시에 하나의 기기에서 여러개의 프로젝트가 가지는 다른 의존성을 다룰 수 있도록 디자인되었습니다.</li><li>설치 관련 가이드는 <a href="http://www.virtualenv.org/"><strong>virtualeng.org</strong></a>에서 찾을 수 있습니다.</li><li>설치 후에, env라는 가상환경 폴더를 만들고 싶다면 virtualenv env 명령어를 실행시키면 됩니다.</li><li>여러분의 각 프로젝트 마다 이러한 환경이 하나씩 필요하게 됩니다. 이 폴더들을 버전 컨트롤 시스템에서 제외하는것을 잊지 마세요.</li><li>가상환경에서 python과 pip를 사용하고 싶다면, env/bin/python 그리고 env/bin/pip를 사용하면 됩니다.</li><li>가상환경을 source env/bin/activate 스크립트로 활성화 시킬 수 있고 deactivate 명령어를 통해 비활성화 시킬 수 있습니다. 선택적이지만 개발을 조금 더 편하게 도와줄 것입니다.</li></ul><p>만일 여러분이 일반적인 파이썬 사용자라면 pip와 virtualenv는 서로 떨어질 수 없는 도구들일것입니다. 둘다 상대적으로 이해하기 간단하기에 이들을 명확히 이해하는 것을 추천합니다.</p><p>만약 이 글이 파이썬을 배우고 싶도록 여러분을 자극했다면 <a href="https://www.dabapps.com/what-we-do/python-for-programmers/"><strong>Python for Programmers</strong></a><strong> </strong>강의를 확인해보세요.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a53512fab3c2" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[번역] Ready for Production Apps: Flutter Beta 3]]></title>
            <link>https://medium.com/@dan_kim/%EB%B2%88%EC%97%AD-ready-for-production-apps-flutter-beta-3-626fc408dda0?source=rss-153cbcd9a954------2</link>
            <guid isPermaLink="false">https://medium.com/p/626fc408dda0</guid>
            <category><![CDATA[flutter]]></category>
            <category><![CDATA[android-app-development]]></category>
            <category><![CDATA[dartlang]]></category>
            <category><![CDATA[ios-apps]]></category>
            <category><![CDATA[mobile-app-development]]></category>
            <dc:creator><![CDATA[Dan Kim]]></dc:creator>
            <pubDate>Sun, 27 May 2018 05:58:31 GMT</pubDate>
            <atom:updated>2018-05-27T05:58:31.600Z</atom:updated>
            <content:encoded><![CDATA[<p>이 글은 Google Developers 블로그에 올라온 <a href="https://developers.googleblog.com/2018/05/ready-for-production-apps-flutter-beta-3.html">Ready for Production Apps: Flutter Beta 3</a>를 번역한 글입니다.</p><p>이번 주에 있었던 Google I/O에서 높은 퀄리티로, 네이티브 사용자 경험을 iOS와 Android에서 줄 수 있는 <a href="https://flutter.io"><strong>Flutter</strong></a>의 세번째 베타 버전 릴리즈가 발표되었습니다. Flutter의 새로운 툴링 파트너들, 고객들의 Flutter 사용기, 그리고 Material team으로부터의 공식적인 지원 선언 등이 함께 발표되었습니다.</p><p>우리는 모바일 개발에 있어 업그레이드가 필요하다고 믿습니다. 개발자는 제품의 품질과 생산성 사이에서 줄다리기 하느라 너무 많은 신경을 쓰고 있습니다. 예를 들어, 똑같은 앱을 iOS와 Android에서 개발해야하거나 또는 사용자들이 요구하는 수준의 네이티브 경험을 제공하기 어려운 기존의 크로스 플랫폼 솔루션에 고착되어 있습니다. Flutter가 만들어진 이유가 바로 여기에 있습니다. 바로, 네이티브 수준의 성능, 발전된 비주얼, 엄청나게 증진된 개발 속도와 생산성을 가장 최우선으로하는 <a href="https://youtu.be/fq4N0hgOWzU"><strong>모바일 앱 개발의 새로운 길</strong></a>을 제공하고자 하는 것입니다.</p><p>불과 12개월 전 Google I/O 2017에서 Flutter를 발표하고 아주 초기 수준의 알파 툴킷을 제공했습니다. 우리는 작년 한해동안 수만 시간의 엔지니어링 시간을 상용 환경에서 사용할 수 있는 Flutter를 만들기 위해 노력해왔습니다. 성능을 위한 엔진의 주요 부분들을 다시 작성했고, Windows 개발 환경도 지원하고, <a href="https://plugins.jetbrains.com/plugin/9212-flutter"><strong>Android Studio</strong></a>, <a href="https://marketplace.visualstudio.com/items?itemName=Dart-Code.dart-code"><strong>Visual Studio Code</strong></a>, <a href="https://medium.com/dartlang/announcing-dart-2-80ba01f43b6"><strong>통합된 Dart 2</strong></a> 도구들도 발표했습니다. 이제 <a href="https://github.com/flutter/plugins/blob/master/FlutterFire.md"><strong>Firebase API</strong></a>, <a href="https://pub.dartlang.org/packages/video_player"><strong>inline 비디오</strong></a>, <a href="https://pub.dartlang.org/packages/firebase_admob"><strong>광고</strong></a>, <a href="https://pub.dartlang.org/packages/charts_flutter"><strong>차트</strong></a>, <a href="https://flutter.io/tutorials/internationalization/"><strong>internationalization</strong></a>, 그리고 <a href="https://flutter.io/accessibility/"><strong>접근성 기능</strong></a>도 추가 보강했습니다. 이러한 발전을 통해 수천개의 버그를 해결하고 몇백 페이지에 달하는 문서도 추가했습니다. 지난 한해가 굉장히 바빴지만, 드디어 여러분에게 이번 릴리즈를 공유할 수 있다는 것에 매우 흥분됩니다!</p><p>Flutter는 제공합니다:<br>1. <strong>높은 개발 속도</strong>: Flutter는 앱을 다시 처음부터 새롭게 빌드할 필요없이 빠르고 쉽게 여러분의 앱에 변화를 가할 수 있도록 도와주는 stateful hot reload 기능을 통해 속도 높은 개발 환경을 제공합니다.<br>2. <strong>명시적이고 유연한 디자인</strong>: Flutter는 디자이너들의 꿈을 현실화 시켜줄 수 있는 풍부하고, 블록처럼 구성할 수 있고, 커스터마이즈 가능한 UI 위젯들과 애니메이션 라이브러리를 통해 확장가능한 아키텍처를 제공합니다.<br>3. <strong>높은 수준의 경험</strong>: Flutter는 GPU 가속화를 사용하는 렌더러와 엄청나게 빠르게 머신 코드를 만들어내는 ahead-of-time 컴파일을 통해 어떤 기기와 플랫폼을 사용하든 사용자들에게 높은 수준의 앱 사용 경험을 제공합니다.</p><h3>개발자와 디자이너의 권한 향상</h3><p>Flutter가 앱에 줄수 있는 힘에 대한 하나의 증거로써, <a href="https://2dimensions.com/"><strong>2Dimensions</strong></a>는 이번주에 강력한 인터랙티브 애니메이션을 위한 새로운 도구를 발표했습니다. 이것이 이 소프트웨어를 통해 만들어진 예시입니다:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/1*o4Cv20umWrAH4Sgo_-UzeQ.gif" /></figure><p>여러분은 지금 Flutter가 실제 기기에서 실시간으로 2D skeletal mesh 애니메이션을 렌더링하는 것을 보고있습니다. 이정도 수준의 그래픽을 얻을 수 있는 것은 매 픽셀을 스크린에 그리는 Skia 엔진을 Flutter가 사용하기 때문입니다. Flutter가 사용하는 Dart 언어는 Ahead-of-time에 machine code로 변경되기 때문에 이정도의 성능을 가능하게 합니다. 위의 예제에서 데모 슬라이더 위젯과 뒤에 있는 애니메이션이 얼마나 자연스럽게 오버레이 되어있는지 주목해주세요. Flutter는 사용자 인터페이스 위젯과 실시간으로 생성되는 60fps의 애니메이션을 아주 부드럽게 합쳐냅니다. iOS와 Android에서 동작하는 하나의 코드로 말이죠.</p><p>2Dimensions의 공동 창업자 Luigi Rosso는 Flutter에 대해 다음과 같이 말합니다.</p><blockquote>저는 Flutter를 통해 마찰없이 개발을 반복할 수 있는 부분을 사랑합니다. Hot Reload는 저에게 작업에만 계속 집중할 수 있는 피드백 환경을 제공해주었습니다. 저의 가장 큰 생산성 방해 요소는 바로 개발자보다 느린 생산 도구들이었습니다. Flutter는 마침내 이 장애물을 없애주었습니다.</blockquote><p>모바일 앱 생산자의 가장 흔한 어려움 중 하나는 초기 스케치 디자인을 사용자들이 사용해 볼 수 있는 인터랙티브 프로토타입으로 만드는 일입니다. 개발자 도구와 컴포넌트의 가장 큰 서비스 제공사인 <a href="https://www.infragistics.com/"><strong>Infragistics</strong></a>는 이번주에 있었던 Google I/O에서 <a href="https://infragistics.com/design"><strong>Flutter에대한 공식 지원을 선언</strong></a>했습니다. 이들은 그들의 서비스를 통해 디자이너와 개발자 사이의 간극을 어떻게 줄일 수 있는지 보여줬습니다. Indigo Design to Code Studio는 디자이너들이 Sketch 파일에 상호작용을 넣을 수 있도록 해주고 pixel-perfect한 Flutter 앱을 생성해줍니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*JZfJ425xhMm8U8U0ClKqAA.png" /></figure><h3>고객들의 선택</h3><p>우리는 불과 10주 전 Mobile World Congress에서 Flutter Beta 1을 런칭했습니다. 그 날 이후 <a href="https://www.timqian.com/star-history/#flutter/flutter"><strong>Github</strong></a>과 스토어에서 Flutter 앱들은 흥분되는 발전을 보여주었습니다. Flutter는 여전히 만들어지고 있음에도 불구하고, 고객들이 보여준 Flutter SDK 에 대한 강력한 열정은 놀라웠습니다. 가장 유명한 앱중 하나는 <a href="https://goposse.com/"><strong>Posse Digital</strong></a>에서 만든 <a href="https://blog.goposse.com/rise-up-the-story-of-how-the-hamilton-app-uses-flutter-to-do-more-for-its-fans-1d9cd76f95f1"><strong>Hamilton Broadway musical 앱</strong></a>입니다. 이 앱은 매달 수백만명의 사용자들이 사용하고 있고, <a href="https://play.google.com/store/apps/details?id=com.hamilton.app"><strong>플레이 스토어에서 평균 평점 4.6</strong></a>을 기록하고 있습니다.</p><p>이번주에 <a href="http://www.alibabagroup.com/"><strong>Alibaba</strong></a>는 Flutter를 적용한 <a href="https://2.taobao.com/"><strong>Xianyu 앱</strong></a>을 발표했습니다. 이 앱은 MAU가 2천만이 넘는 그들의 주력 상품입니다. Alibaba는 Flutter가 여러 플랫폼에서 일관성있게 동작한다는 점, 디자이너들의 작업 결과물에서 쉽게 UI 코드를 작성할 수 있는점, 그리고 Native 개발자들이 쉽게 배울 수 있다는 점에서 Flutter를 칭찬했습니다. Alibaba는 현재 이 버전을 사용자들에게 배포하고 있는 중입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*_ABNob21cKUhpL1uX5u_mg.png" /></figure><p><a href="https://www.groupon.com/"><strong>Groupon</strong></a>은 Flutter를 사용하는 회사중 하나입니다. Groupon은 그들의 상품 앱을 위해 Flutter로 프로토타이핑을 하는 중입니다. 그들은 Flutter를 이용하는 것에 대해 다음과 같이 말했습니다:</p><blockquote>저는 우리의 기존앱을 통합할 수 있고 iOS와 Android 사용자들에게 하나의 Native 경험을 전달하는데 한번의 코드를 작성하면 된다는 점에서 Flutter를 좋아합니다. 이러한 장점은 앱을 사용자들에게 전달하는데까지의 시간을 엄청나게 줄여주고 있으며, 고객들에게 더 많은 기능을 제공할 수 있도록 도와주고 있습니다. — Varun Menghani, Head of Merchant Product Management, Groupon</blockquote><p>Beta 1 이후 짧은 시간동안 다양한 앱 카테고리에 걸쳐서 <a href="https://flutter.io/showcase"><strong>수백개의 Flutter 앱</strong></a>이 릴리즈 되었습니다. 아래는 Flutter를 이용해 만들어진 앱의 예시입니다.</p><ul><li><strong>Abbey Road Studios</strong>는 그들의 음악 생산 앱의 새로운 버전인 Topline의 프리뷰입니다.</li><li><strong>AppTree</strong>는 맥도날드, Stanford, Wayfair &amp; Fermilab과 같은 브랜드들을 위한 low-code 엔터프라이즈 앱 플랫폼을 제공합니다.</li><li><strong>Birch Finance</strong>는 기존의 신용 카드를 관리하고 최적화하는데 도움을 주는 앱입니다.</li><li><strong>Coach Yourself</strong>는 mindfulness, 인지 행동학적 트레이닝을 제공하고 있습니다.</li><li><strong>OfflinePal</strong>은 콘서트, 극장부터 하이킹, 여행가들의 관심까지 여러 액티비티를 수집해서 제공합니다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*EJGPYu5rMMAv_lQlpNNsLw.png" /></figure><p>Google은 계속해서 Flutter를 사용하고 있습니다. 이번 I/O에서 새롭게 발표한 예시는 Google Ads로 온라인 광고 캠페인들을 최적화 시키고 트래킹하도록 도와주는 AdWords 앱의 Flutter 버전을 보여줍니다. 광고와 커머스를 담당하고 있는 Sridhar Ramaswamy는 다음과 같이 말합니다:</p><blockquote>Flutter는 Android와 iOS 어플리케이션 개발을 위한 코드와 팀을 하나로 합치는것이 가능한 현대적인 리액티브 프레임워크를 제공합니다. 이를 통해, 기존과 같은 네이티브 어플리케이션 경험을 고객들에게 제공하면서 팀을 훨씬 더 생산적으로 만드는 것을 가능하게 합니다. 특히, Stateful hot reload는 생산성에 있어서 완전히 판을 뒤집는 기능입니다.</blockquote><h3>Flutter Beta 3 신기능</h3><p>오늘 I/O에서 발표한 Flutter Beta 3는 핵심 기능들이 모두 완성된 1.0 버전을 향한 여정을 지속하고 있습니다. 이제 Flutter에서 Dart 2의 더욱 간결해진 문법을 사용할 수 있습니다. 또한, RTL 언어들을 포함해서 전세계 언어들을 다룰 수 있는 <a href="https://flutter.io/tutorials/internationalization/"><strong>localization</strong></a><strong> </strong>기능을 지원합니다. 접근성 기능 역시 기존보다 훨씬 더 많이 지원하기 시작했습니다. 새로운 개발 도구로 위젯 인스펙터는 UI의 시각적인 트리를 쉽게 보여주며, 이를 통해 개발중에 어떻게 위젯이 보일지 확인할 수 있습니다. <a href="https://pub.dartlang.org/packages/firebase_admob"><strong>Firebase를 통한 광고 기능</strong></a>도 지원하고 있습니다. Visual Studio Code는 이제 완전히 first-class 개발도구로써, <a href="https://marketplace.visualstudio.com/items?itemName=Dart-Code.flutter"><strong>Flutter extension</strong></a>을 제공하고 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*fEqlZGa3MxQhaII92ePbyA.png" /></figure><p>Material 디자인 팀은 Flutter 팀의 시작부터 함께 작업하고 있습니다. 오늘 기쁜 마음으로 Flutter가 Material을 위한 first-class 툴킷이되었다는 것을 발표합니다. 이는 Material Design의 훨씬 더 많은 지원을 제공하기 위해 Material과 Flutter 팀이 함께 한다는 것을 의미합니다. 물론, 여러분의 브랜드를 보여주는 디자인을 구현하도록 지원하기 위한 Flutter의 노력은 계속될 것입니다.</p><p>Flutter Beta 3에 대한 더 많은 신규 기능에 대한 정보는 <a href="https://medium.com/flutter-io/flutter-beta-3-7d88125245dc"><strong>미디엄의 Flutter 블로그</strong></a>에서 찾을 수 있습니다. 여러분이 이미 Flutter를 설치하셨다면, flutter upgrade 명령어를 통해 최신 버전을 설치해보세요. 만약 아직 설치하지 않으셨다면, <a href="https://flutter.io/setup-macos/"><strong>macOS</strong></a>, <a href="https://flutter.io/setup-windows/"><strong>Windows</strong></a>, 또는 <a href="https://flutter.io/setup-linux/"><strong>Linux</strong></a>에서 Flutter를 설치하실 수 있습니다.</p><h3>릴리즈 로드맵</h3><p>Flutter 1.0 버전이 아직 릴리즈되지는 않았지만, Google과 대중들에 의해 실제 사용 앱으로 사용되고 있습니다. 우리는 “1.0” 수준의 품질에 점점 다가가고 있고 앞으로 다가올 몇달동안 아래와 같은 분야의 발전을 보실 수 있을 겁니다:</p><ol><li><strong>성능과 용량</strong>. Flutter 성능의 속도와 일관성 모두를 증진시키기 위해 노력하고 있으며, 잠재적인 이슈들 찾아내기위한 추가적인 도구들과 문서를 제공할 예정입니다. 이와 더불어, Flutter 앱의 최소 용량을 더 줄일 예정입니다;</li><li><strong>호환성</strong>. 32 비트 기기들을 포함해서 더 많은 기기 종류를 지원하기 위해 계속해서 노력할 것이며, iOS 위젯들 종류도 더 확장시킬 예정입니다. 추가로, 기존의 Android 또는 iOS 코드에 Flutter를 더 쉽게 적용시킬 수 있는 노력도 계속할 예정입니다.</li><li><strong>생태계</strong>. 넓은 커뮤니티들과의 파트너쉽을 통해 플랫폼 API들과 SDK들을 더 쉽게 통합시킬 수 있는 패키지들의 생태계를 계속해서 구축해 나가겠습니다.</li></ol><p>모든 소프트웨어 프로젝트들이 그러하듯이, 시간, 품질 그리고 기능에는 트레이드 오프가 있습니다. 우리는 1년 이내로 1.0 버전을 릴리즈 하고자 하지만, 필요에 따라서 일정을 조율하고자 합니다. Flutter는 오픈소스이기 때문에, Github에서 언제든지 다음으로 예정된 마일스톤들과 해결할 예정인 이슈들을 확인할 수 있습니다. 모바일 개발을 더 끝내주게 만들기 위한 이 여정에 여러분의 도움을 환영합니다.</p><p>여러분이 Google I/O에 참여하셨든 영상으로 보셨든지, 여러분이 Flutter를 실행해보는데 도움이 되는 여러 기술적인 컨텐츠를 가지고 있습니다. 특히, Flutter와 Material Design에 관련된 <a href="https://medium.com/flutter-io/how-to-watch-flutter-at-google-i-o-2018-c7e082fc836f"><strong>다양한 세션에 대한 영상</strong></a>들이 있으며, <a href="https://codelabs.developers.google.com/?cat=Flutter"><strong>Flutter 코드랩스의 새로운 시리즈</strong></a>들 그리고 <a href="https://www.udacity.com/course/build-native-mobile-apps-with-flutter--ud905"><strong>Udacity 코스</strong></a>도 열었습니다.</p><p>지난 한해동안, 우리의 위대한 여정을 초기 사용자들의 커뮤니티와 함께해 왔습니다. Flutter를 이용해 개발자들이 만든 다양한 범위에서의 앱, 실험들, 플러그인들, 지원 도구들을 보면 찌릿찌릿한 느낌을 받습니다. 우리의 여정은 이제 막 시작했습니다. 지금이 이 위대한 여정에 참여할 좋은 타이밍입니다. <a href="https://flutter.io/?utm_source=google&amp;utm_medium=developer_blog&amp;utm_campaign=beta3"><strong>공식 홈페이지</strong></a>, 트위터 (<a href="http://twitter.com/flutterio"><strong>flutterio</strong></a>), <a href="https://groups.google.com/d/forum/flutter-dev"><strong>구글 그룹</strong></a><strong> </strong>그리고 <a href="https://gitter.im/flutter/flutter"><strong>Gitter</strong></a> 채팅 룸을 통해 저희와 연락하세요. 여러분이 어떻게 앱을 만들지 너무도 기대됩니다!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=626fc408dda0" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[번역] Flutter 위젯 사용해보기]]></title>
            <link>https://medium.com/@dan_kim/%EB%B2%88%EC%97%AD-flutter-%EC%9C%84%EC%A0%AF-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0-1a22231d25c6?source=rss-153cbcd9a954------2</link>
            <guid isPermaLink="false">https://medium.com/p/1a22231d25c6</guid>
            <category><![CDATA[android-app-development]]></category>
            <category><![CDATA[flutter]]></category>
            <category><![CDATA[dartlang]]></category>
            <category><![CDATA[mobile-app-development]]></category>
            <dc:creator><![CDATA[Dan Kim]]></dc:creator>
            <pubDate>Mon, 21 May 2018 13:14:37 GMT</pubDate>
            <atom:updated>2018-05-21T13:14:37.245Z</atom:updated>
            <content:encoded><![CDATA[<p>이 글은 <a href="https://proandroiddev.com/flutter-from-zero-to-comfortable-6b1d6b2d20e">Flutter: From Zero To Comfortable</a> 을 번역한 글입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*2bRVEGI6ivIEdY88ngEK2Q.png" /></figure><p>Google에 의해 만들어진 <a href="http://flutter.io/"><strong>Flutter</strong></a>는 하나의 코드 베이스로 iOS와 Android 앱을 만들 수 있는 모바일 앱 SDK입니다. 크로스 플랫폼 앱 개발의 신참으로, <a href="http://facebook.github.io/react-native/"><strong>React Native</strong></a>와 다르게 JavaScript를 프로그래밍 언어로 사용하지 않습니다.</p><p>Flutter가 사용하는 언어는 <a href="https://www.dartlang.org/"><strong>Dart</strong></a>로 싱글 이벤트 큐를 기반으로 동작한다는 점에서 <strong>JavaScript</strong>와 유사합니다. Flutter의 가장 큰 이점은 ARM 바이너리를 직접 생성하기 때문에, Native 플랫폼에서 굉장히 빠르게 동작한다는 점입니다.</p><p>React Native와 같이 JavaScript를 기반으로 하는 프레임워크들은 JavaScript 코드를 Native Code로 변환하는 <strong>브릿지</strong>를 필요로 하기에 상대적으로 느립니다.</p><p>Flutter 설치 가이드는 <a href="https://flutter.io/setup/"><strong>여기</strong></a>에서 찾을 수 있습니다. “Android Studio” 그리고 “IntelliJ IDEA Community” 등 IDE에서 Flutter 앱을 개발할 수 있습니다.</p><h3>Flutter 앱 만들기 — 계층구조 위젯들</h3><p>Flutter 앱내의 모든 것들은 <strong>위젯</strong>입니다. 간단한 텍스트부터 버튼 그리고 스크린 레이아웃까지 모두 위젯이라고 생각하면 됩니다.</p><p>이러한 위젯들은 스크린에서 보여주기 위해 계층적인 순서를 가지고 배열되게 됩니다. 다른 위젯들을 그 내부에 가지고 있을 수 있는 위젯을 <strong>Container 위젯</strong>이라고 부릅니다. 대부분의 레이아웃 위젯들은 Container 위젯입니다. 다만, Text 위젯과 같이 아주 한정적인 작업을 수행하는 위젯들은 Container 위젯이 아닙니다.</p><p>가장 기본적인 최소한의 위젯 구성은 다음과 같습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/409/1*u8i4rbAoHrWX_4gyVUv1-w.png" /></figure><h3>Hello Flutter: 첫번째 Flutter 코드</h3><p>첫번째 예제로 “<strong>Hello Flutter</strong>”를 보여주는 모바일 앱을 만들어보고자 합니다. Container Widget의 일종인 Directionality와 Text Widget을 사용하고자 합니다. 아래와 같이 코드를 작성하면 됩니다.</p><pre>import &#39;package:flutter/material.dart&#39;;</pre><pre>void main() =&gt; runApp(new MyApp());</pre><pre>class MyApp extends StatelessWidget {<br>  <a href="http://twitter.com/override">@override</a><br>  Widget build(BuildContext ctxt) {<br>    return new Directionality(<br>        textDirection: TextDirection.ltr,<br>        child: new Text(&quot;Hello Flutter&quot;)<br>    );<br>  }<br>}</pre><p>앱 실행은 다른 프로그래밍 언어들 처럼 main()함수를 통해 시작합니다. 위 예제에서, MyApp은 직접 만든 위젯 클래스이며 스크린 레이아웃을 빌드하는 역할을 합니다.</p><blockquote>모든 커스텀 위젯은 Widget객체를 리턴하는 build함수를 가지고 있습니다.</blockquote><p>위 예제에서 “Directionality”라는 Container Widget을 만들었고, 이 위젯은 “Text”라는 “Hello Flutter” 글자를 화면에 보여주는 위젯을 하위 위젯으로 가지고 있습니다. 그림으로 표현해보자면 아래와 같습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/229/1*bcbk0fXjDMUOQnUsq_zg2g.png" /></figure><p>이렇게 코드를 돌리면 화면 상단에 텍스트가 보이게 됩니다. 이를 화면의 중간으로 가져오기 위해서는 Center 위젯을 아래와 같이 추가 구성하면 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/229/1*fEz2vUAM7vhL_w-77I4kWg.png" /></figure><p>코드로 표현하자면 아래와 같습니다.</p><pre>class MyApp extends StatelessWidget {<br>  <a href="http://twitter.com/override">@override</a><br>  Widget build(BuildContext ctxt) {<br>    return new Directionality(<br>        textDirection: TextDirection.ltr,<br>        child: new Center(                        // Changed Line<br>          child: new Text(&quot;Hello Flutter&quot;),       // Changed Line<br>        )<br>    );<br>  }<br>}</pre><h3>Material Design 앱 만들기</h3><p>실제 배포하는 어떠한 앱에서도 단지 텍스트만 간단히 보여주지는 않을 겁니다. 대신, 어플리케이션 바, Body, 네비게이션 등을 최소한 가지고 있을 겁니다.</p><p>Flutter가 제공하는 빌트인 위젯인MaterialApp을 사용하면 간단하게 이러한 앱을 만듭니다. MaterialApp 위젯은 Material Design의 기본 골격을 쉽게 추가할 수 있는 Scaffold라는 위젯을 child로 가질 수 있습니다. 아래 코드처럼, Scaffold 위젯 내부에 AppBar와 Body를 추가하는 방식으로 쉽게 Material Design 앱을 만들 수 있습니다.</p><pre>class MyApp extends StatelessWidget {<br>  <a href="http://twitter.com/override">@override</a><br>  Widget build(BuildContext ctxt) {<br>    return new MaterialApp(<br>      title: &quot;MySampleApplication&quot;,<br>      home: new Scaffold(<br>        appBar: new AppBar(<br>          title: new Text(&quot;Hello Flutter App&quot;),<br>        ),<br>        body: new Center(<br>          child: new Text(&quot;Hello Flutter&quot;),<br>        ),<br>      ),<br>    );<br>  }<br>}</pre><p>이렇게 구성된 위젯의 구조는 다음과 같습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/869/1*Q8M-9Gvwl28TfZJyVWrJwA.png" /></figure><h3>Material Design 확장하기</h3><p>Material Design에서 body는 오로지 하나의 위젯만을 가집니다. 예를 들어, 위의 코드에서는 텍스트 위젯만 보여주고 있습니다. 이것은 일반적으로 앱을 구성할때 원하는바가 아닐 것입니다.</p><p>여러가지 위젯을 내부에 포함시키기 위해서는, 위젯들의 배열을 내부에 가질 수 있는 타입의 위젯을 body의 child로 설정하는 것이 필요합니다. Flutter에서 위젯의 배열을 child로 가질 수 있는 여러가지 위젯들이 존재합니다. 여기서 사용하는 Row/Column 위젯도 이들 중 하나입니다. 위의 코드에 Row/Column 위젯을 추가해 아래와 같이 계층 구조를 만들어봅시다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/869/1*0jME4D2bR_iO5Y90_lnf8A.png" /></figure><p>코드로 표현해보자면 아래처럼 될 것입니다.</p><pre>class MyApp extends StatelessWidget {<br>  <a href="http://twitter.com/override">@override</a><br>  Widget build(BuildContext ctxt) {<br>    return new MaterialApp(<br>      title: &quot;MySampleApplication&quot;,<br>      home: new Scaffold(<br>        appBar: new AppBar(<br>          title: new Text(&quot;Hello Flutter App&quot;),<br>        ),<br>        body: new Center(<br>          child: new Row(<br>            children: &lt;Widget&gt;[<br>              new Text(&quot;Hello Flutter&quot;),<br>              new Text(&quot;Hello Flutter - &quot;),<br>            ],<br>          ),<br>        ), <br>      )<br>    );<br>  }<br>}</pre><h3>위젯에 커스텀 파라미터 전달하기</h3><p>우리가 만든 MyApp 클래스 또한 하나의 위젯입니다. 다른 빌트인 위젯들 처럼, MyApp 위젯에도 파라미터를 전달할 수 있습니다. 이를 MyApp 클래스의 생성자를 통해 할 수 있습니다.</p><blockquote>파라미터로 전달받은 값을 생성자 클래스 내부에서 <strong>final</strong> 변수로 지정하는 필수는 아니지만, Best practice라고 할 수 있습니다.</blockquote><p>아래 코드에서, MyApp 위젯은 TextInput 객체를 파라미터로 전달받도록 구성되어있습니다 (실제 코드에서는 이런식으로 구성하지는 않겠지만, 커스텀 위젯에 파라미터를 전달받는것의 예제라고 생각하시면 됩니다.).</p><pre>void main() =&gt; runApp(new MyApp(<br>  TextInput: new Text(&quot;Provided By Main&quot;),<br>));</pre><pre>class MyApp extends StatelessWidget {<br>  MyApp({this.TextInput});<br> final Widget TextInput;<br>  <a href="http://twitter.com/override">@override</a><br>  Widget build(BuildContext ctxt) {<br>    return new MaterialApp(<br>      title: &quot;MySampleApplication&quot;,<br>      home: new Scaffold(<br>        appBar: new AppBar(<br>          title: new Text(&quot;Hello Flutter App&quot;),<br>        ),<br>        body: new Center(<br>          child: new Column(<br>            children: &lt;Widget&gt;[<br>              TextInput<br>            ],<br>          ),<br>        )<br>      ),<br>    );<br>  }<br>}</pre><h3>Stateless 그리고 Stateful 위젯들</h3><p>Flutter에서 생성할 수 있는 위젯은 <strong>Stateless</strong> 그리고 <strong>Stateful</strong> 이렇게 2가지 타입이 존재합니다. 지금까지 예제에서 만들었던 위젯들은 전부다 <strong>Stateless</strong> 위젯들입니다.</p><h4>Stateless 위젯 그리고 그 한계점</h4><p>Stateless 위젯은 위젯이 로드될때 딱 한번 그려집니다. 이것은 어떠한 이벤트나 혹은 사용자 액션에 의해서 위젯이 다시 그려지지 않는다는 것을 의미합니다.</p><p>예를 들어, Checkbox 위젯의 행동을 보면서 이를 이해할 수 있습니다. Checkbox 위젯은 Flutter의 빌트인 위젯으로 Checkbox 클릭 리스너를 붙일 수 있습니다. 하지만, 웹에서 UI를 만들때와 다르게 사용자의 클릭 이벤트 후 체크가 박스 내부에 그려지기 위해서는 <strong>Hot reload</strong>를 해야지 가능합니다. 아래 코드를 돌려서 확인해보세요.</p><pre>class MyApp extends StatelessWidget {<br>  MyApp({this.TextInput});<br>  final Widget TextInput;<br>  bool checkBoxValue = false;<br>  <a href="http://twitter.com/override">@override</a><br>  Widget build(BuildContext ctxt) {<br>    return new MaterialApp(<br>      title: &quot;MySampleApplication&quot;,<br>      home: new Scaffold(<br>        appBar: new AppBar(<br>          title: new Text(&quot;Hello Flutter App&quot;),<br>        ),<br>        body: new Center(<br>          child: new Column(<br>            children: &lt;Widget&gt;[<br>              TextInput,<br>              new Checkbox(<br>                  value: checkBoxValue,<br>                  onChanged: (bool newValue){<br>                    checkBoxValue = newValue;<br>                  }<br>              )<br>            ],<br>          ),<br>        )<br>      ),<br>    );<br>  }<br>}</pre><p>확인해보신것처럼, 클릭을 해도 반영이 되지 않는것 처럼 보입니다. 하지만,클릭 후에 Hot reload를 해보시면 박스 안에 체크가 되는 것을 확인할 수 있습니다. 다시 말해서, 클릭 이벤트를 받아서 checkBoxValue 값은 변경했지만, Flutter가 위젯들을 다시 그리지 않은 것입니다.</p><p>이러한 특정을 가지고 있다고 Stateless 위젯이 쓸모없다는 것을 의미하지는 않습니다. Stateless 위젯은 변하지 않는 컨텐츠를 화면에 그릴때 Stateful 위젯보다 훨씬더 비용이 적게 들기 때문에 아주 유용합니다.</p><h4>Stateful 위젯</h4><p>Stateful 위젯은 Stateless 위젯과 다르게 수동으로 화면을 리로드할 필요가 없습니다. Stateful 위젯은 setState 함수가 불리면 자동으로 화면에 다시 ㄱㅡ려지기 때문입니다. setState 함수는build(BuildContext ctxt) 함수를 다시 불러서 build 함수 내부의 위젯들을 새로 인스턴스화하게 됩니다 (즉 다시 화면을 그리게 됩니다).</p><p>Stateful 위젯은 Stateless 위젯과 생성하는 방법부터 다릅니다. Stateful 위젯을 만들기 위해서, 기본적으로 두개의 클래스를 만들어야합니다. 하나는 Stateful 위젯 그자체, 또 다른 하나는 Generic타입의 State 클래스 입니다.</p><p>Stateful 위젯을 만들때, State 인스턴스를 생성하는 createState(…) 함수를 override하게 됩니다. 아래 예제를 통해 구체적인 코드를 살펴봅시다.</p><pre>class MyApp extends StatefulWidget {<br>  MyApp({this.TextInput});<br>  final Widget TextInput;<br>  MyAppState createState() =&gt; new MyAppState();<br>}</pre><pre>class MyAppState extends State&lt;MyApp&gt; {<br>  bool checkBoxValue = false;<br>  <a href="http://twitter.com/override">@override</a><br>  Widget build(BuildContext ctxt) {<br>    return new MaterialApp(<br>      title: &quot;MySampleApplication&quot;,<br>      home: new Scaffold(<br>        appBar: new AppBar(<br>          title: new Text(&quot;Hello Flutter App&quot;),<br>        ),<br>        body: new Center(<br>          child: new Column(<br>            children: &lt;Widget&gt;[<br>              widget.TextInput,<br>              new Checkbox(<br>                  value: checkBoxValue,<br>                  onChanged: (bool newValue){<br>                    setState(() {<br>                      checkBoxValue = newValue;<br>                    });<br>                  }<br>              )<br>            ],<br>          ),<br>        )<br>      ),<br>    );<br>  }<br>}</pre><p>전체 위젯 계층 구조는 아래와 같습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/869/1*N3Ret7YI54COXnU9l76s0Q.png" /></figure><h3>AppBar에 액션 버튼 추가하기</h3><p>화면 상단 우측에 세개의 점으로 구성된 더보기 버튼과 비슷한 형태의 액션 버튼들을 AppBar에 추가해봅시다.</p><p>AppBar 생성자는 실행가능한 아이템을 추가하기 위한 옵션을 제공하고 있습니다. Row / Column위젯과 비슷하게 위젯의 배열을 children의 값으로 받고 있습니다. 예를 들어, IconButton 몇개를 추가해봅시다.</p><pre>class MyApp extends StatefulWidget {<br>  MyApp({this.TextInput});<br>  final Widget TextInput;<br>  MyAppState createState() =&gt; new MyAppState();<br>}</pre><pre>class MyAppState extends State&lt;MyApp&gt; {<br>  bool checkBoxValue = false;<br>  String  actionText = &quot;Default&quot;;<br>  <a href="http://twitter.com/override">@override</a><br>  Widget build(BuildContext ctxt) {<br>    return new MaterialApp(<br>      title: &quot;MySampleApplication&quot;,<br>      home: new Scaffold(<br>        appBar: new AppBar(<br>          title: new Text(&quot;Hello Flutter App&quot;),<br>          actions: &lt;Widget&gt; [<br>              new IconButton (<br>                icon: new Icon(Icons.add_comment),<br>                onPressed: (){<br>                  setState(() {<br>                    actionText = &quot;New Text&quot;;<br>                  });<br>                }<br>              ),<br>              new IconButton (<br>                  icon: new Icon(Icons.remove),<br>                  onPressed: (){<br>                    setState(() {<br>                      actionText = &quot;Default&quot;;<br>                    });<br>                  }<br>              ),<br>            ]<br>        ),<br>        body: new Center(<br>          child: new Column(<br>            children: &lt;Widget&gt;[<br>              widget.TextInput,<br>              new Text(actionText),<br>              new Checkbox(<br>                  value: checkBoxValue,<br>                  onChanged: (bool newValue){<br>                    setState(() {<br>                      checkBoxValue = newValue;<br>                    });<br>                  }<br>              )<br>            ],<br>          ),<br>        )<br>      ),<br>    );<br>  }<br>}</pre><p>전제적인 위젯 트리의 구조는 아래와 그림과 같습니다.setState 함수는 MaterialApp 전체를 다시 그리게 만들기 때문에, AppBar의 IconButton을 클릭하면 Body의 텍스트가 업데이트 되는 것을 확인할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/869/1*dZDbr_NBh1YJpBRy4T9OMA.png" /></figure><h3>좀 친숙해지셨나요?</h3><p>이 글에서 우리는 Flutter 앱의 아주 기본적인 예제를 다뤄보았습니다. 더욱 고급의 기능들은 다른 블로그 글을 통해 살펴보도록하겠습니다.</p><p>읽어주셔서 감사합니다!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1a22231d25c6" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[번역] Flutter 설치 및 데모 앱 실행하기]]></title>
            <link>https://medium.com/@dan_kim/%EB%B2%88%EC%97%AD-flutter-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EB%8D%B0%EB%AA%A8-%EC%95%B1-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0-4a09ca206591?source=rss-153cbcd9a954------2</link>
            <guid isPermaLink="false">https://medium.com/p/4a09ca206591</guid>
            <category><![CDATA[android-app-development]]></category>
            <category><![CDATA[installation]]></category>
            <category><![CDATA[mobile-app-development]]></category>
            <category><![CDATA[flutter]]></category>
            <dc:creator><![CDATA[Dan Kim]]></dc:creator>
            <pubDate>Sun, 20 May 2018 07:00:01 GMT</pubDate>
            <atom:updated>2018-05-20T07:07:19.002Z</atom:updated>
            <content:encoded><![CDATA[<p>이 글은 <a href="https://medium.com/@sethladd/installing-flutter-on-a-mac-13a26340f80a">Installing Flutter on a Mac, and running your first Flutter app</a> 을 번역한 글입니다.</p><blockquote><strong>tldr</strong>: 10분안에 Mac에서 Flutter를 설치하고, 첫번째 Flutter 데모 앱을 돌려볼 수 있습니다 (지금부터 시간을 재보세요).</blockquote><p>Flutter는 높은 퀄리티의 iOS/Android 앱을 <strong>빠르게</strong> 만들수 있는 새로운 방법입니다. 만약 모바일 개발에 처음이거나, 앱을 기존보다 더 빠른 속도로 만드는 방법을 찾고 있다면, Flutter를 살펴보는 것을 추천드립니다.</p><p>이 글은 공식 설치 가이드가 아니며, 제가 Mac 환경에서 설치해본 경험을 공유하는 정도의 글입니다. 더 자세한 정보를 원하신다면 <a href="https://flutter.io/setup/">공식 홈페이지에 있는 Flutter 설치 가이드</a>를 살펴보시는 것을 추천드립니다. 이 글은 짧은 버전의 설치 가이드라고 생각하시면 됩니다. 이 글은 여러분이 이미 Mac을 사용하는데 어느정도 익숙하고 터미널을 이용해 명령어를 수행시킬 수 있다고 가정하고 있습니다.컴퓨터에 이미 git이 설치되어있다고 가정하겠습니다.</p><h3>Flutter SDK 설치</h3><ul><li>터미널을 켜세요.</li><li>git clone -b beta <a href="https://github.com/flutter/flutter.git`">https://github.com/flutter/flutter.git</a> 명령어를 통해 Flutter를 다운받으세요.</li><li>export PATH=$PWD/flutter/bin:$PATH 명령어를 통해, path에 다운 받은 Flutter를 추가해주세요.</li><li>flutter doctor 명령어를 통해 추가적인 라이브러리를 받으세요.</li></ul><p>이것만으로도 Flutter SDK가 컴퓨터에 설치되었습니다. 이제 플랫폼 SDK를 설치해봅시다. iOS도 물론 지원하지만, 이 글에서는 안드로이드만 대상으로 하겠습니다.</p><h3>Android SDK 설치</h3><p>쉽게 SDK를 설치하기 위해 Android SDK와 Android Emulator를 제공하는 Android Studio를 이용하도록 하겠습니다.</p><ul><li><a href="https://developer.android.com/studio/index.html">Android Studio를 다운 받고 설치</a>하세요.</li><li>Android Studio를 실행하고 모든 기본값을 수락하세요.</li><li>Android Studio가 Android SDK를 설치하는 것을 기다리세요.</li><li>“Start a new Android Studio project”를 시작하고 “Welcome to Android Studio” 다이얼로그를 확인하고 나면 Android Studio를 종료시키세요.</li><li>터미널로 이동해서 flutter doctor — android-licences를 실행시켜 최종적으로 모든 라이센스를 수락했는지 확인하세요.</li><li>이제 다시 터미널로 돌아와서 flutter doctor를 실행시켜보세요.</li></ul><p>만약 Android toolchain에서 [<em>✓ </em>]를 확인했다면 이제 다음 단계로 진행할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*UW56-9i55ETjUOUs5z1tfA.png" /></figure><p>만약 아직 체크 박스를 보지 못했다면, Flutter doctor가 제안하는 방식대로 따라해보세요.</p><h3>첫번째 데모 앱 만들기</h3><ul><li>터미널에서flutter create my_first_app 명령어를 실행시켜보세요. 여기에서 my_first_app은 우리가 만들 데모 앱의 이름이자 폴더명이기도 합니다.</li><li>명령어를 친 곳에 my_first_app 폴더가 생긴것을 확인해주세요.</li></ul><h3>안드로이드 에뮬레이터 만들기</h3><p>위의 데모 앱을 돌릴, 안드로이드 에뮬레이터를 만들어 봅시다.</p><ul><li>먼저, Android Studio를 실행시키세요.</li><li>open existing project를 누르고, 방금 생성한 my_first_app 폴더를 선택하세요.</li><li>Android Studio Tools &gt; Android &gt; AVD Manager 메뉴를 실행시키세요.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*rKNfbykrJpMOSTFjutdrPQ.png" /></figure><ul><li>Create Virtual Device를 클릭하고 기기는 Pixel 2 로 만들어보세요.</li><li>Download for Oreo를 클릭하고 라이센스를 수락하세요.</li><li>이미지와 SDK 다운로드가 완료되면, Oreo를 선택하고 다음을 누르세요.</li><li>기본값을 모두 수락하고 완료(Finish)를 누르세요.</li></ul><h3>에뮬레이터 실행시키기</h3><p>이제 에뮬레이터 (Virtual Device)를 얻었으니 실행을 시키면 됩니다. 아래 이미지와 같이 초록색 화살표 버튼을 클릭하세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*IDwTXfvX2KiNtc9yO4Px2A.png" /></figure><p>에뮬레이터의 부팅이 완료될때까지 기다려주세요. 부팅이 완료되면 터미널에서 my_first_app 폴더 안으로 이동하고 flutter doctor 명령어를 실행시켜 주세요. “Android SDK built for x86 기기가 디바이스 리스트에 보이면, 이제 앱을 실행시키는 일만 남았습니다.</p><h3>데모앱 실행시키기</h3><p>이제 앱을 실행시켜 봅시다.</p><ul><li>터미널에서 my_first_app 폴더로 이동한 후, flutter run 명령어를 실행시키세요.</li><li>초기값 설정 및 빌드가 완료되면, 짜잔! 이제 에뮬레이터에서 Flutter 앱을 볼 수 있습니다!</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*WB82GJJZMOOdqCf7kJAGfg.png" /></figure><p>Flutter는 기본앱으로 카운터 앱을 제공하고 있습니다. 우측 하단에 있는 FAB을 클릭해서 카운터를 높여보세요!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4a09ca206591" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[번역] Flutter는 왜 혁명적인가?]]></title>
            <link>https://medium.com/@dan_kim/%EB%B2%88%EC%97%AD-flutter%EB%8A%94-%EC%99%9C-%ED%98%81%EB%AA%85%EC%A0%81%EC%9D%B8%EA%B0%80-967c1dfcc5a9?source=rss-153cbcd9a954------2</link>
            <guid isPermaLink="false">https://medium.com/p/967c1dfcc5a9</guid>
            <category><![CDATA[mobile-app-development]]></category>
            <category><![CDATA[flutter]]></category>
            <category><![CDATA[android-app-development]]></category>
            <category><![CDATA[ios-app-development]]></category>
            <category><![CDATA[dart]]></category>
            <dc:creator><![CDATA[Dan Kim]]></dc:creator>
            <pubDate>Thu, 17 May 2018 10:05:29 GMT</pubDate>
            <atom:updated>2018-05-17T10:05:29.011Z</atom:updated>
            <content:encoded><![CDATA[<p>이 글은 <a href="https://hackernoon.com/whats-revolutionary-about-flutter-946915b09514">What’s Revolutionary about Flutter</a>를 번역한 글입니다. 조금 더 쉽게 읽히는 글을 위해 약간의 의역이 섞여 있습니다.</p><h3>Flutter란 무엇인가?</h3><p>Flutter 모바일 앱 SDK는 빠르고, 아름다운 모바일 앱을 만들 수 있는 새로운 방법입니다. Flutter는 과거 판에 박힌 앱만 찍어내던 시절로부터 개발자들을 탈출하도록 도와줍니다. Flutter를 사용해본 개발자들은 이 새로운 개발 방식을 정말로 좋아하고 있습니다; 예를 들어, <a href="https://medium.com/@aubykhan/how-i-built-a-cross-platform-connected-app-in-7-days-93728a987424">이 글</a>, <a href="https://hackernoon.com/flutter-first-steps-fffd906f093b">이 글</a>, 혹은 <a href="https://code.tutsplus.com/tutorials/developing-an-android-app-with-flutter--cms-28270">이 글</a>을 확인해보세요. 또한 <a href="https://github.com/Solido/awesome-flutter">Awesome-Flutter Git 저장소</a>도 확인해보세요.</p><p>모든 새로운 시스템을 만났을때 그렇지만, 사람들은 어떤점이 특별한지 그리고 “Flutter가 가지는 새롭고 흥미로운 점이 어떤것인지?” 궁금해합니다. 이는 당연한 질문이며, 저는 이 글에서 이에 대한 답을 기술적인 관점에서 해보고자 합니다 — 단순히 무엇이 흥미로운지 뿐아니라 왜 그런지도 포함해서요.</p><p>잠깐, 간략한 역사 공부 먼저.</p><h3>모바일 앱 개발의 간략한 역사</h3><p>모바일 앱 개발 분야는 상대적으로 최신 분야라고 할 수 있습니다. 개발자들이 모바일 앱을 개발한지 미처 10년이 되지 않았고, 이를 생각해보면 개발 도구들이 여전히 발전하고 있다는 것은 그다지 놀라운 사실은 아닙니다.</p><h4>OEM SDKs</h4><p>애플은 iOS SDK를 2008년에 릴리즈했고, 구글은 Android SDK를 2009년에 릴리즈 했습니다. 이 두 SDK들은 각기 다른 언어를 기반으로 하고 있죠: Objetive-C, JAVA.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/524/1*c4-dPk9FGweW7XawcLxYPQ.png" /></figure><p>여기서 앱은 위젯을 만들고 카메라와 같은 서비스에 접근하기 위해 플랫폼과 직접 대화를 합니다. 위젯들은 스크린 캔버스에 렌더가 되고, 화면에서 발생된 이벤트들은 다시 해당 위젯으로 보내지게 됩니다. 매우 간단한 구조이죠. 하지만, 각 플랫폼마다 위젯은 다르고 언어 또한 다르기 때문에, 위의 구조에서는 각 플랫폼마다 독립적인 앱을 만들어야합니다.</p><h4>WebViews</h4><p>하나의 코드로 여러개의 환경에서 동작하는 크로스 플랫폼 프레임워크를 향한 첫번째 시도는 JavaScript와 WebView를 기반으로 만들어졌습니다. PhoneGap, Apache Cordova, Ionic 등등이 여기에 속합니다. iOS SDK를 릴리즈하기 전, 애플이 아이폰 개발자들에게 웹앱을 만들라고 권장한 사실을 생각해보면, Web 기술을 이용한 크로스 플랫폼의 등장은 어쩌면 당연한 절차였는지 모르겠습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/631/1*XZ_0T5CVP74FFtn7j40qrw.png" /></figure><p>WebView 기반의 앱은 HTML을 만들고 이를 플랫폼 내부의 WebView를 통해 사용자에게 보여주는 방식입니다. 하지만, JavaScript와 같은 언어가 직접적으로 네이티브 코드(위의 서비스와 같은)와 소통하는것은 그리 쉬운 일이아닙니다. 이를 위해 JavaScript 영역과 Native 영역 사이에서 문맥 전환을 해주는 <strong>브릿지</strong>를 사용하게 됩니다. 플랫폼 내부의 서비스들은 일반적으로 자주 불리지는 않기 때문에, 이런 방식의 구현이 엄청난 퍼포먼스 문제로 이어지지는 않았습니다.</p><h4>리액티브 뷰</h4><p><a href="https://en.wikipedia.org/wiki/Reactive_programming">리액티브 프로그래밍</a> 패턴을 이용한 <a href="https://facebook.github.io/react/">ReactJS</a>와 같은 리액티브 웹 프레임워크는 이전보다 웹뷰 생성을 매우 쉽게 만들어주었다는 점에서 큰 인기를 얻게 되었습니다. 2015년에 공개된 React Native는 리액티브 스타일의 뷰들이 가지고 있는 다양한 장점들을 모바일 앱에 적용하기 위해 만들어졌습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/630/1*kIH_djrXMlSsoYra92_S0g.png" /></figure><p>React Native는 현재 엄청난 인기를 누리고 있지만, JavaScript 영역의 코드가 네이티브 영역에 있는 OEM 위젯에 접속을 하기위해서 <a href="https://medium.com/@talkol/performance-limitations-of-react-native-and-how-to-overcome-them-947630d7f440">결국 <strong>브릿지</strong>를 거치게 됩니다</a>. 리액티브 뷰에서는 OEM 위젯에 굉장히 자주 접근하게 되고 (사용자가 화면에서 스와이프 한번을 했을때 최대 초당 60번까지도 접근), 이는 결국 퍼포먼스 이슈를 야기하게 됩니다. React Native에 대한 <a href="https://medium.com/@talkol/performance-limitations-of-react-native-and-how-to-overcome-them-947630d7f440">한 글</a>에서는 이에 대해 다음과 같이 이야기하고 있습니다.</p><blockquote>React Native의 성능을 이해하는 주된 열쇠가 여기에 있다. 각 영역 그 자체는 엄청나게 빠르다. 성능의 병목은 주로 하나의 영역에서 다른 영역으로 넘어갈때 발생한다. 고성능의 React Native 앱을 구축하기 위해서는, 이 브릿지를 건너는 횟수를 최소화해야한다.</blockquote><h4>Flutter</h4><p>Flutter는 React Native와 마찬가지로 리액티브 스타일 뷰를 제공하고 있습니다. 하지만, Flutter는 <a href="https://www.dartlang.org/">Dart</a>라는 컴파일 프로그래밍 언어를 이용해 이 브릿지로 인해 발생하는 성능 문제를 피하고 있습니다. Dart는 Ahead of time (AOT)에 여러 플랫폼에 상응하는 네이티브 코드로 컴파일 됩니다. 다시말해, Flutter는 문맥 교환을 하는 JavaScript 브릿지를 거치지 않고 플랫폼과 직접적으로 커뮤니케이션하는 것입니다. 이처럼 네이티브 코드로 컴파일이 되면 앱의 스타트업 시간 또한 빨라지게 됩니다.</p><p>Flutter가 JavaScript 브릿지를 필요로 하지 않으면서, 리액티브 뷰를 제공하는 유일한 모바일 SDK라는 사실만으로도 Flutter는 이미 충분히 흥미롭고 시도해볼만한 가치를 가집니다. 하지만, 여기에 그치지 않고 Flutter는 훨씬 더 혁신적인 부분들을 제공하고 있습니다.</p><h3>위젯</h3><p>위젯은 앱의 뷰와 인터페이스를 컨트롤하는 엘리먼트라고 할 수 있습니다. 위젯은 모바일 앱에서 가장 중요한 요소라고 해도 과언이 아닐 겁니다. 사실상, 위젯만으로 앱의 성패가 갈릴 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/320/1*rVzsEsaplma41RqR6yCmag.gif" /></figure><ul><li>위젯에서 룩앤필은 다른 어떠한 것보다도 중요합니다. 위젯은 다양한 스크린 사이즈에서 보기 좋아야하고 또 자연스러워 보여야 합니다.</li><li>위젯은 반드시 빠르게 동작해야합니다: 위젯 트리를 만들때, 위젯들을 인플레이트할때, 화면에 배치시킬때, 렌더링할때, (특히) 애니메이션 효과를 줄때 등을 포함해서 말이죠.</li><li>요즘 앱에서 위젯은 확장가능해야하며 커스터마이징이 가능해야합니다. 개발자들은 마음에 드는 새로운 위젯들을 추가할 수 있기를 바라고, 앱의 브랜드와 매칭되도록 이들을 커스터마이징 하기를 바랍니다.</li></ul><p>Flutter는 위에서 언급한 요구사항들 즉, 좋은 룩앤필, 빠른 속도, 커스터마이즈, 확장가능성을 지원하는 위젯을 제공하는 새로운 아키텍쳐를 가지고 있습니다. 맞습니다! 바로 Flutter가 OEM 위젯들 (또는 DOM 웹뷰)을 사용하지 않고, 자체적인 위젯을 사용하고 있기 때문입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/628/1*1DiOFy8WN0dgoV16iK02BQ.png" /></figure><p>Flutter는 위젯들과 렌더러들을 플랫폼 영역에서 앱의 영역으로 옮겨왔습니다. 이것은 이제 위젯들이 커스터마이징 가능해졌고 확장가능해졌다는 것을 의미합니다. Flutter가 플랫폼으로부터 요구하는 것은 위젯을 렌더할 수 있는 캔버스뿐 입니다. 이 캔버스를 통해 디바이스 스크린에 위젯을 그리고, 이벤트들(터치, 타이머 등)과 서비스들(위치, 카메라 등)에 접근하게 됩니다.</p><p>Dart 프로그램 (초록색) 영역과 네이티브 플랫폼 코드 (파란색) 사이에는 인코딩과 디코딩을 담당하는 인터페이스가 여전히 존재하고 있습니다. 그러나, JavaScript 브릿지와 비교했을때, 비교할 수 없을 정도로 빠른 성능을 가지고 있습니다.</p><p>위젯들과 렌더러를 앱으로 옮겨온것은 앱 사이즈에도 영향을 미칩니다. Flutter 앱의 최소 사이즈는 약 6.7MB이며, 이것은 비슷한 개발 도구들을 이용해서 만든 최소 크기의 앱들과 비교했을 때 비슷한 사이즈입니다. Flutter의 장점들이 다른 개발 환경에 비해 가치가 있는지 없는지 판단하는 것은 여러분들의 몫입니다. 이 글의 남은 부분에서는 Flutter가 가지고 있는 더 많은 장점들에 대해서 다뤄보고자 합니다.</p><h3>레이아웃</h3><p>Flutter에서 가장 큰 개선점중 하나는 레이아웃을 하는 방식에 있습니다. 여기서 레이아웃이란 정해진 규칙(혹은 제한들)에 따라서 위젯의 크기와 위치를 정하는 것을 의미합니다.</p><p>전통적으로, 레이아웃은 어떠한 위젯에도 적용할 수 있는 규칙들의 거대한 집합을 사용해왔습니다. 여기서 규칙들은 다양한 레이아웃 함수들을 구현합니다. 가장 잘 알려져있는 CSS 레이아웃을 예로 들어 봅시다. CSS는 속성들(규칙들)을 가지고 있고, 이 속성들은 HTML 엘리먼트들 (위젯들)에 적용이 됩니다 (CSS3는 375개의 속성을 정의하고 있습니다).</p><p>CSS는 박스 모델, 플로팅 엘리먼트, 테이블, 텍스트 컬럼, 페이지 미디어 등등을 포함하는 수 많은 레이아웃 모델을 포함하고 있습니다. 시간이 지나서 개발자들과 디자이너들은 레이아웃에 대해 더 많은 부분을 컨트롤 하고 싶어했고, 이 필요에 따라서 Flex Box와 Grid Layout 모델들을 추가해야만 했습니다. 전통적인 레이아웃에서 새로운 모델들을 추가할때, 개발자들이 자체적으로 추가하는 것은 불가능합니다. 이 때문에, Flex Box와 Grid Layout은 우리가 알고 있듯이 CSS 형태로 추가되어야만했습니다. 다시 말해 모든 브라우저들은 이에 대한 구현을 다시 해야만 했습니다.</p><p>전통적인 레이아웃이 가지고 있는 또 다른 문제로는 규칙들이 서로 상호작용 할 수 있으며 (혹은 속성들간의 Conflict가 발생), 보통 하나의 엘리먼트에 수십개의 규칙들이 한꺼번에 적용된다는 것입니다. 이러한 환경은 레이아웃을 시간을 느리게 만듭니다. 레이아웃 성능은 일반적으로 N 제곱의 복잡도를 따릅니다. 다시 말해, 엘리먼트의 숫자가 증가함에따라, 레이아웃 속도는 훨씬 더 빠르게 느려지게 됩니다.</p><p>이를 극복하기 위해, 구글 크롬 브라우저 팀 멤버들은 새로운 실험을 시작했습니다. 그들은 만약 그들이 전통적인 레이아웃 모델을 머릿속에 완전히 지워버린다면, 훨씬 더 빠른 렌더러를 만들 수 있는지 궁금했습니다. 몇주가 지나고 그들은 눈에 띄눈 성능 향상을 얻을 수 있었습니다. 이들이 발견한것은:</p><ul><li>대부분의 레이아웃은 상대적으로 간단하다는 점. 스크롤 페이지에 있는 텍스트, 디스플레이 사이즈에 따라 위치와 크기가 변하는 직사각형, 그리고 테이블들, 플로팅 엘리먼트들 정도만 필요하다는 점.</li><li>대부분의 레이아웃은 위젯의 서브트리에 속해있으며, 이 서브트리는 보통 하나의 레이아웃 모델만을 사용한다는 점. 다시 말해, 하나의 특정 위젯을 지원하기 위해 아주 적은 숫자의 규칙들만이 필요하다는 점.</li></ul><p>그들은 관점을 완전히 바꾸면 레이아웃을 훨씬 더 간단하게 만들 수 있다는 것을 깨달았습니다.</p><ul><li>어떠한 위젯에도 적용될 수 있는 엄청나게 큰 규모의 레이아웃 규칙들 대신, 각 위젯이 본인만이 가지고 있는 고유의 간단한 레이아웃 모델을 가지면 된다.</li><li>이제 각 위젯은 고려해야하는 레이아웃 규칙이 굉장히 작아지기 때문에, 각 위젯을 위한 고도의 최적화를 할 수 있게 된다.</li><li>모든 것들을 위젯화 시키면, 더욱 간단한 레이아웃을 구조를 만들 수 있다.</li></ul><p>이제 Flutter를 이용해 간단한 위젯 트리를 만드는 코드를 살펴봅시다:</p><pre>new Center(<br>  child: new Column(<br>    children: [<br>      new Text(&#39;Hello, World!&#39;)),<br>      new Icon(Icons.star, color: Colors.green)<br>    ]<br>  )<br>)</pre><p>이 코드의 구문에 이미 어떤 결과물이 만들어질지 충분한 의미를 가지고 있습니다. 이 코드를 통해 얻어지는 결과는 아래와 같습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/195/1*mkbE24Y2lqkYU5b_h46b2g.png" /></figure><p>이 코드에서 레이아웃을 포함한 <a href="https://flutter.io/widgets/">모든것은 위젯입니다</a>. <strong>Center 위젯</strong>은 위젯의 부모(위의 예제에서는 스크린)의 중앙에 위젯의 자식 위젯들을 위치시킵니다. <strong>Column 위젯</strong>은 이 위젯의 자식 위젯들을 수직으로 나열 시킵니다. 이 Column은 <strong>Text 위젯</strong>과 <strong>Icon 위젯</strong>(색 속성을 가지는) 을 가지고 있습니다.</p><p>Flutter에서 가운데 정렬이나 패딩 역시도 위젯입니다. 심지어 테마들까지도 자식 위젯들에게 적용되는 또다른 위젯이며, 어플리케이션과 네비게이션까지도 위젯입니다.</p><p>Flutter는 Column뿐 아니라 Row, Grid, List 등 꽤나 많은 위젯을 포함하고 있습니다. 게다가, Flutter는 Silver Layout Model이라고 칭하는 스크롤링을 위해 사용되는 고유한 레이아웃 모델을 가지고 있습니다. 스크롤링은 반드시 즉각적이면서도 부드럽게 반응해야만 사용자들이 물리적인 화면을 드래그했을 때, 손끝에 이미지가 붙어있는 듯한 느낌을 줍니다. Flutter의 레이아웃은 굉장히 빨라서 바로 이것을 해낼 수 있습니다.</p><p>스크롤링을 위해 레이아웃을 사용함으로써 Flutter는 아래 이미지와 같은 발전된 형태의 스크롤링을 가능하게 합니다. 아래 이미지가 GIF 이미지라는 점을 잊지 마세요. Flutter는 이보다 더 부드럽습니다! 이 글의 마지막에 있는 리소스에서 해당 앱의 코드를 찾아 돌려볼 수 있습니다. 꼭 한번 돌려보세요!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/360/1*350ujaVYToF28-RAusHnbQ.gif" /><figcaption>Flutter Gallery app</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/360/1*RjXo7-O2F2op8vYQpgNl-g.gif" /><figcaption>Posse Gallery App</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/360/1*6OiHYey2fz0nUlztNUs9aA.gif" /><figcaption>Posse Gallery App</figcaption></figure><p>대부분의 경우 Flutter는 한번의 패스로 레이아웃을 구축 할 수 있습니다. 다시 말해, 리니어 타임안에 끝낼 수 있는거죠. 이 때문에 Flutter는 많은 수의 위젯들을 한꺼번에 다루는 것도 가능합니다. 여기에 추가로 Flutter는 매번 레이아웃 작업을 하지 않기위해, 캐쉬를 비롯한 다양한 작업들을 수행합니다.</p><h3>커스텀 디자인</h3><p>Flutter는 위젯을 앱의 일부로 옮겨왔기 때문에, 새로운 위젯을 추가하는 것 혹은 기존의 위젯들에 다른 룩앤필을 주거나 회사 브랜드에 맞도록 커스터마이징하는 것이 가능합니다. 현대의 모바일 디자인 트렌드는 판에 박힌 앱을 만드는 것에서 완전히 멀어져 있으며, 사용자에게 기쁨을 주는 커스텀 디자인을 향해 점점 더 발전해 나아가고 있습니다.</p><p>Flutter는 풍부하고, 커스터마이즈 가능한 Android, <a href="https://flutter.io/widgets/cupertino/">iOS </a>그리고 <a href="https://material.io/">Material 디자인</a>을 가지고 있습니다 (사실, Flutter가 가장 높은 수준의 Material 디자인을 제공하고 있다는 이야기가 종종 들립니다). Flutter는 커스터마이즈 능력을 활용해서 멀티 플랫폼에 있는 네이티브 위젯들의 룩앤필과 매칭되는 위젯들을 지원하고 있습니다. 앱 개발자들 역시 이 커스터마이즈 능력을 사용해서 자신들의 요구와 필요에 맞도록 Flutter에서 제공하는 위젯을 변형시키는 것이 가능합니다.</p><h3>리액티트 뷰에 관한 더 많은 이야기</h3><p>리액티브 웹 뷰를 위한 라이브러리들은 <strong>Virtual DOM</strong> 개념을 새롭게 소개했습니다. DOM은 HTML Document Object Model을 의미하며, DOM의 API는 JavaScript를 이용해 엘리먼트의 트리로 표현되는 HTML document들을 다루는데 사용됩니다. Virtual DOM은 DOM의 추상화된 버전으로 프로그래밍 언어 (여기에서는 JavaScript) 내부의 객체들을 이용해서 DOM을 생성하는 방식을 의미합니다.</p><p>리액티브 웹 뷰(ReatJS와 같은 시스템에 의해서 구축된)에서 이 Virtual DOM은 변경이 불가능(immutable)하며 어떤 변화를 위해서도 매번 처음부터 다시 구축이 됩니다. Virtual DOM은 실제 DOM과 비교를 통해, 최소한의 변경사항들을 찾아내고 이를 기반으로 실제 DOM을 업데이트합니다. 실제 DOM이 업데이트되고 나서야, 플랫폼은 실제 DOM을 다시 렌더링하고 캔버스에 그리게 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/661/1*SAwqJ_Zhc_rg6F6ZkK7xtg.png" /></figure><p>이러한 방식은 듣기에 과도한 추가 작업이 있는것처럼 들리지만, <a href="https://www.codecademy.com/articles/react-virtual-dom">HTML DOM을 수정하는것이 매우 비싸다는 것</a>을 생각한다면 충분한 가치를 지니고 있습니다.</p><p>React Native는 위와 비슷한 작업을 모바일 앱을 대상으로 수행합니다. DOM 대신 모바일 플랫폼에 있는 네이티브 위젯들을 조종하는겁니다. React Native는 Virtual DOM 대신 위젯들의 Virtual tree를 만들고 이를 네이티브 위젯과 비교해서 필요한 부분에 대해서만 네이티브 위젯에 변경을 가하는 방식을 사용합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/656/1*S9CIXMt4b2PA9-1SnLzoRA.png" /></figure><p>React Native가 네이티브 위젯과 소통하기 위해서는 반드시 브릿지를 거쳐야한다는 점을 기억해야합니다. 다시 말해, React Native가 만드는 Virtual tree는 네이티브 위젯의 사용을 가능하게함과 동시에, 브릿지를 건너는 횟수를 최소화하는 역할을 수행하는 것입니다. 최종적으로 네이티브 위젯이 업데이트 되고나면, 플랫폼은 캔버스에 변경된 위젯을 렌더링하게 됩니다.</p><p>모바일 개발에 있어서 React Native는 큰 성취를 이루어냈고 이는 Flutter에게 영감을 주었습니다. 하지만, Flutter는 여기에 그치지 않고 한 스텝 더 나아갑니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/342/1*h2mPio_A8kbfkiTRqxpYyQ.png" /></figure><p>Flutter에서는 위젯과 렌더러 모두가 플랫폼에서 사용자의 앱상으로 옮겨졌다는 점을 기억하세요. 이제 더 이상 변경 사항을 전달 해야하는 네이티브 위젯은 존재하지 않습니다. Virtual 위젯 트리였던 부분이 이제 진짜 위젯 트리가 되는거죠. Flutter가 위젯트리를 렌더하고 플랫폼의 캔버스에 페인팅을 합니다. 굉장히 좋고 간단하죠 (그리고 빠르고요). 추가로, 애니메이션이 사용자 영역에서 발생하기 때문에, 앱 (그러니까 개발자들)은 애니메이션에 대한 더 다양한 컨트롤을 가지고 있습니다.</p><p>Flutter 렌더러는 그 자체만으로도 흥미롭습니다: 이 렌더러는 스크린상에서 업데이트되어야하는 위젯들만을 렌더하기 위해서 내부적으로 몇개의 트리 구조들을 가지고 있습니다. 예를 들어, 렌더러는 “<a href="https://youtu.be/UUfXWzp0-DU">structural repainting using compositing</a>” 이라는 방법을 사용하고 있습니다 (여기에서 structural는 스크린상의 직사각형 영역을 사용하는 것보다 훨씬 더 효과적인 위젯을 의미합니다). 변경사항이 없는 위젯들에 대해서는, 심지어 위치가 이동했다고 하더라도, 캐쉬로부터 “<a href="https://en.wikipedia.org/wiki/Bit_blit">bit blit</a>”이 되기 때문에 굉장히 빠릅니다. 이것이 Flutter에서 스크롤링이 엄청난 퍼포먼스를 보이는 이유입니다.</p><p>Flutter 렌더러에 대해서 더 자세히 살펴보고 싶다면 <a href="https://youtu.be/UUfXWzp0-DU">이 비디오</a>를 추천합니다. 더불어, <a href="https://github.com/flutter">Flutter는 오픈소스</a>이기 때문에 코드를 직접 살펴보는 것도 가능합니다. 이는 렌더러, 컴포지터, 애니메이션, 제스처 인식 등 모든 위젯을 포함해서 전체 스택을 마음대로 커스터마이즈하는것이 가능하다는 의미입니다.</p><h3>Dart 프로그래밍 언어</h3><p>리액티브 뷰를 사용하는 다른 시스템들처럼 Flutter는 새로운 프레임마다 새로운 뷰 트리를 구축합니다. 다시말해, 하나의 프레임을 위해 많은 수의 객체들을 생성하게 됩니다. 다행히도, Dart는 이러한 시스템에서 굉장히 효율적인 “<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Generational_GC_.28ephemeral_GC.29">generational garbage collection</a>” 을 사용하고 있습니다. 이 정책에서는 객체들 (특히 짧은 시간동안 살아있는 객체들)의 비용이 매우 쌉니다. 추가적으로, 객체 할당이 빠르며 락을 요구하지도 않는 싱글 포인터 범프로 가능합니다. 이는 UI <a href="https://en.wiktionary.org/wiki/jank">jank</a>와 stutter을 피하는것을 도와줍니다.</p><p>또한 Dart는 앱에서 필요한 코드만을 포함시키는 “<a href="https://medium.com/@Rich_Harris/tree-shaking-versus-dead-code-elimination-d3765df85c80">tree shaking</a>”라는 컴파일러를 가지고 있습니다. 아주 큰 위젯 라이브러리에서 한개 혹은 두개만을 사용하더라도 부담없이 사용하면 됩니다.</p><p>Dart에 대한 더 많은 정보를 얻고 싶다면 “<a href="https://hackernoon.com/why-flutter-uses-dart-dd635a054ebf">Why Flutter uses Dart</a>”를 읽어보세요 (다음 번역글로 계획하고 있습니다).</p><h3>Hot reload</h3><p>Flutter에서 가장 유명한 특징은 빠르고, stateful한 Hot reload 기능입니다. 앱이 동작하고 있는 동안 Flutter 앱에 변경을 줄 수 있습니다. Flutter는 보통 일초안에 이전 코드 상태를 유지하면서 변경된 부분을 적용합니다. 만약 에러가 발생하면, 개발자는 해당 에러를 수정하고 Flutter는 마치 에러가 없었던것처럼 그 이전 상태를 유지하며 동작합니다. 심지어 앱 전체를 다시 로딩할 때조차도 굉장히 빠릅니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/864/1*qcEPMLgn5XeQb-6o2OFQ_w.gif" /><figcaption>Hot stateful reload</figcaption></figure><p>이 과정을 개발자들은 “앱을 페인팅한다”고 표현합니다. 한 시점에 하나의 변화를 만들고 앱을 재시작할 필요없이 그 결과를 바로 바로 확인하기 때문입니다.</p><h3>Compatibility</h3><p>위젯들과 렌더러들은 플랫폼의 일부가 아니고 앱의 일부이기 때문에 더 이상 “<a href="https://developer.android.com/topic/libraries/support-library/index.html">compat librar</a>y”들이 필요하지 않습니다. Flutter로 만든 앱은 오래된 OS 뿐만 아니라 최신 OS에서도 동일하게 동작합니다 (Android Jelly Bean부터 최신, iOS 8.0부터 최신). 이것은 예전 OS 버전을 테스트해야하는 공수를 엄청나게 줄여줍니다. 더불어, 미래의 OS 버전에서도 동일하게 동작할것입니다.</p><p>우리가 사람들로부터 자주 듣는 걱정이 하나 있습니다. Flutter가 OEM 네이티브 위젯들을 사용하지 않기 때문에, 새로운 종류의 위젯을 가지고 있거나 기존의 위젯의 모양과 행동의 변화를 포함하는 새로운 iOS 혹은 Android 버전이 나오면, 이를 서포트하는데까지 시간이 너무 오래걸리지 않겠느냐하는 걱정입니다.</p><ul><li>먼저, 구글은 Flutter의 큰 내부 사용자입니다. 그렇기에, 현재의 OEM 위젯들과 가능하면 가깝게 위젯의 셋들을 유지하는데 큰 이점을 가지고 있습니다.</li><li>위젯 업데이트가 너무 느린 경우에도 구글만이 Flutter의 위젯을 업데이트하는 권한을 가지고 있지 않다는 점을 기억하세요. Flutter의 위젯은 굉장히 확장가능하고 커스텀이 가능하기 때문에, 당신을 포함한 누구든지 업데이트를 할 수 있습니다. Pull Request를 쌓을 필요도 없으며, Flutter의 자체적인 업데이트를 기다릴 필요도 없습니다.</li><li>또한 위의 이야기들은 여러분의 앱에 새로운 변화를 주었을때에만 해당됩니다. 만약, 여러분의 앱의 디자인이나 행동에 아무런 변화도 주지 않았다면, 전혀 문제가 없습니다. 위젯은 앱의 일부이기 때문에, 플랫폼의 업데이트로 인해 앱이 갑자기 이상하게 보이거나 하는 문제가 절대 발생하지 않습니다.</li><li>추가적인 장점으로 여러분이 새롭게 만든 위젯 역시 예전 OS 버전에서도 잘 동작한다는 점이 있습니다.</li></ul><h3>또 다른 이점들</h3><p>Flutter의 간결성은 앱을 빠르게 만들지만, 앱 전반에 걸쳐 존재하는 커스터마이징 능력과 확장가능성은 Flutter를 더욱 강력하게 만듭니다.</p><p>Dart의 <a href="https://pub.dartlang.org/flutter/packages/">소프트웨어 패키지 저장소</a>를 이용해 여러분의 앱이 가지는 능력을 확장시킬 수 있습니다. 예를 들어, 다수 패키지들이<a href="https://github.com/flutter/plugins/blob/master/FlutterFire.md"> Firebase에 접근</a>하는 것을 쉽게 만들어주기 때문에 Flutter를 이용해 Serverless앱을 만드는 것은 매우 간단합니다. 또한 어떤 개발자는 <a href="https://pub.dartlang.org/packages/flutter_built_redux">Redux data store에 접근</a>할 수 있는 패키지도 만들어 두었습니다. <a href="https://flutter.io/developing-packages/">플러그인</a>이라고 불리는 패키지들이 존재하는데, 이들은 OS와 상관없이 앱에서 가속도센서 카메라등 플랫폼의 서비스와 하드웨어에 접근할 수 있는 방법을 제공하고 있습니다.</p><p>물론, Flutter 자체도 오픈소스입니다. Flutter의 렌더링 스택도 앱의 일부라는 의미이고, 각 앱에서 여러분이 원하는 거의 모든 부분을 커스터마이즈 할 수 있다는 것을 의미합니다. 아래 그림에서 초록색으로 표시된 모든 부분이 전부 커스터마이징 가능합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*AMb5JzTXKsR8_PKdEtDfLQ.png" /></figure><h3>그래서, Flutter는 무엇이 새롭고 흥미로운가?</h3><p>이제 누군가가 이런 질문을 여러분에게 한다면 어떻게 대답해야하는지 아실 겁니다.</p><ul><li>JavaScript 브릿지 없는 리액티브 뷰의 장점들</li><li>빠르고, 부드럽고, 예측가능한 AOT 에서 Native 코드로 컴파일되는 언어</li><li>위젯과 레이아웃에 모든 접근이 가능한 점</li><li>아름답고 커스터마이징이 가능한 위젯들</li><li>Hot reload를 포함한 최고의 개발 환경</li><li>성능이 좋고, 호환성이 뛰어나며, 재미있음!</li></ul><p>제가 위의 리스트에서 어떤것을 빼먹었는지 눈치채셨나요? 이 부분은 사람들이 Flutter에 대해서 이야기할때 가장 먼저 이야기하는 장점이지만, 저에게는 가장 덜 흥미로운 점입니다.</p><p>바로 Flutter가 하나의 코드로 멀티 플랫폼에서 동작하는 앱을 만들 수 있다는 점입니다. 물론, 이 부분도 응답에 포함시켜야겠죠! 하지만, 성능을 포기하지 않고 멀티 플랫폼에서 Flutter가 동작할 수 있도록 해준점은 강력한 커스터마이징 능력과 확장성이라는 점을 잊지 마세요.</p><h3>혁명적인</h3><p>저는 아직도 Flutter가 왜 혁명적인지에 대해서 완전히 설명하지는 못했습니다. <a href="https://blog.goposse.com/a-revolutionary-app-for-a-revolutionary-show-1b687f24023b">Flutter를 이용해 외부에서 개발된 첫번째 앱</a>이 미국 독립 전쟁 (American Revolutionary War)를 배경으로한 “<a href="http://www.hamiltonbroadway.com/">Hamilton: An American Musical</a>” 공식 앱이라는 점을 생각해보면, 어느 정도 맞아 떨어져가는것처럼 보입니다. Hamilton은 역사상 가장 유명한 브로드웨이 뮤지컬 중 하나입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/562/1*51ayq5t6n5Ea3bpPJS-XvA.png" /></figure><p>개발자 <a href="http://goposse.com/">Posse</a>는 앱을 단지 세달만에 만들어야했기 때문에 Flutter를 선택했다고 이야기합니다. 그들은 이를 두고 “혁명적인 쇼를 위한 혁명적인 앱”이라고 이야기하고 “Flutter는 아름답고, 높은 성능을 가지는, 브랜드 지향 모바일 경험을 제공하기 위한 최고의 선택이다”고 이야기합니다. 이들은 Google Developer Days 컨퍼런스에서 Flutter를 이용해 그들이 <a href="https://youtu.be/prlK_QL_qOA">앱을 만들었던 경험을 공유</a>했습니다. 이 앱은 <a href="https://play.google.com/store/apps/details?id=com.hamilton.app">Android</a>, <a href="https://itunes.apple.com/us/app/hamilton-the-official-app/id1255231054">iOS</a>에서 사용 가능하며 사용자들로부터 <a href="http://www.cnn.com/2017/08/14/entertainment/hamilton-app/index.html">좋은 리뷰들</a>을 받았습니다.</p><h3>혁명에 동참하세요!</h3><p>Flutter는 현재 베타 릴리즈 상태입니다. 우리는 계속해서 새로운 기능들을 추가하고 있고 더 많은 최적화 계획을 가지고 있습니다. 하지만, 구글의 내부와 외부에 존재하는 그룹들에서 이미 미션 크리티컬한 앱을 만드는데 Flutter를 사용하고 있습니다.</p><p>만약 여러분이 Flutter에 관심이 있다면, <a href="https://flutter.io/setup/">지금 바로 설치</a>해보시고 같이 설치된 <a href="https://flutter.io/getting-started/">앱을 가지고 즐겨보세요</a>. 특히 stateful hot reload를 확인하는것을 잊지 마세요.</p><p>만약 여러분이 개발자가 아니거나 단지 몇몇개의 앱을 찾고 있다면, Flutter를 이용해 개발된 앱들을 설치할 수도 있고 어떻게 그들이 생겼는지 그리고 동작하는지 확인할 수도 있습니다. 저는 Hamilton app을 추천하지만, 이 외에도 다른 앱이 많이 존재합니다. Google I/O에서 Flutter 앱을 <a href="https://goo.gl/csEr1f">라이브 코딩하는 이 영상</a>도 꼭 살펴보세요.</p><h3>이 글에서 참조한 자료들</h3><ul><li><a href="https://www.youtube.com/results?search_query=io2018+flutter">Google I/O 2018에서 발표된 Flutter 영상들</a></li><li><a href="https://www.youtube.com/results?search_query=DartConf+2018">LA에서 개최된 DartConf 2018의 영상들</a></li><li><a href="https://youtu.be/fq4N0hgOWzU">Flutter 소개 영상</a></li></ul><h4>웹사이트</h4><ul><li><a href="https://flutter.io/">Flutter 공식 홈페이지</a></li><li><a href="https://github.com/flutter/flutter">Flutter 오픈 소스 저장소 (Pull Request 환영!)</a></li><li><a href="https://github.com/Solido/awesome-flutter">더 많은 유용한 링크들</a></li><li><a href="https://gitter.im/flutter/flutter">Gitter 채널</a></li></ul><h4>영상들</h4><ul><li><a href="https://youtu.be/prlK_QL_qOA">GDD에서 발표된 Hamilton 앱 구축 경험</a></li><li><a href="https://goo.gl/csEr1f">Google I/O에서 발표된 Flutter 앱 라이브 코딩</a></li><li><a href="https://goo.gl/N29fiK">Google I/O에서 발표된 디자이너와 함께하는 라이브 코딩</a></li><li>이탈리아 Droidcon에서 발표된 “<a href="https://goo.gl/g1tDQR">Flutter, 새로운 희망</a>”</li><li><a href="https://goo.gl/RH3N4Y">Flutter 렌더링 파이프라인</a></li></ul><h4>앱들</h4><ul><li><a href="http://www.hamiltonbroadway.com/#newyork-app">Hamilton: An American Musical</a></li><li>Flutter 갤러리: <a href="https://play.google.com/store/apps/details?id=io.flutter.gallery">Android</a>, <a href="https://github.com/flutter/flutter/tree/master/examples/flutter_gallery">Github</a></li><li><a href="https://github.com/flutter/posse_gallery">Posse Gallery</a></li><li>Friendlychat: <a href="https://codelabs.developers.google.com/codelabs/flutter/index.html">first codelab</a>, <a href="https://codelabs.developers.google.com/codelabs/flutter-firebase/index.html">Firebase codelab</a>, <a href="https://github.com/flutter/friendlychat">on Github</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=967c1dfcc5a9" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[This article is very helpful to me :) Thanks!]]></title>
            <link>https://medium.com/@dan_kim/this-article-is-very-helpful-to-me-thanks-2972799b7420?source=rss-153cbcd9a954------2</link>
            <guid isPermaLink="false">https://medium.com/p/2972799b7420</guid>
            <dc:creator><![CDATA[Dan Kim]]></dc:creator>
            <pubDate>Sun, 03 Dec 2017 23:10:24 GMT</pubDate>
            <atom:updated>2017-12-03T23:10:24.724Z</atom:updated>
            <content:encoded><![CDATA[<p>This article is very helpful to me :) Thanks!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2972799b7420" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[From the API v0.12.0,]]></title>
            <link>https://medium.com/@dan_kim/from-the-api-v0-12-0-d42eafdf6c12?source=rss-153cbcd9a954------2</link>
            <guid isPermaLink="false">https://medium.com/p/d42eafdf6c12</guid>
            <category><![CDATA[puppeteer]]></category>
            <dc:creator><![CDATA[Dan Kim]]></dc:creator>
            <pubDate>Tue, 14 Nov 2017 23:36:38 GMT</pubDate>
            <atom:updated>2017-11-14T23:38:24.899Z</atom:updated>
            <content:encoded><![CDATA[<p>From the API v0.12.0, the arguments of page.type function has changed like page.type(selector, text[, options]) . This change allows us to select an element and type in texts with one function call.</p><p>The recent version of Puppeteer is v0.13.0 so developers who install Puppeteer after reading this article should change the example code like below.</p><pre>## before v0.12.0<br>page.click(&quot;#lst-ib&quot;);<br>page.type(&quot;Smashing magazine&quot;);</pre><pre>## after v0.12.0<br>page.type(&quot;#lst-ib&quot;,&quot;Smashing magazine&quot;);</pre><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d42eafdf6c12" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[That’s so true!]]></title>
            <link>https://medium.com/@dan_kim/thats-so-true-89a0651e7fa2?source=rss-153cbcd9a954------2</link>
            <guid isPermaLink="false">https://medium.com/p/89a0651e7fa2</guid>
            <dc:creator><![CDATA[Dan Kim]]></dc:creator>
            <pubDate>Tue, 14 Nov 2017 07:41:23 GMT</pubDate>
            <atom:updated>2017-11-14T07:41:23.298Z</atom:updated>
            <content:encoded><![CDATA[<p>That’s so true!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=89a0651e7fa2" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>