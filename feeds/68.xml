<?xml version='1.0' encoding='UTF-8'?><?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?><feed xmlns='http://www.w3.org/2005/Atom' xmlns:openSearch='http://a9.com/-/spec/opensearchrss/1.0/' xmlns:blogger='http://schemas.google.com/blogger/2008' xmlns:georss='http://www.georss.org/georss' xmlns:gd="http://schemas.google.com/g/2005" xmlns:thr='http://purl.org/syndication/thread/1.0'><id>tag:blogger.com,1999:blog-3196730103600443728</id><updated>2019-03-19T22:30:24.263+09:00</updated><category term="From Naver Blog"/><category term="C++"/><category term="Effective C++ Series"/><category term="Effective C++"/><category term="Effective Modern C++"/><category term="Book Review"/><category term="Windows"/><category term="System Programming"/><category term="Windows Programming"/><category term="Linux"/><category term="Trouble Shooting"/><category term="근황"/><category term="Optimization"/><category term="Software Design"/><category term="Windows Via C/C++"/><category term="산업기능요원"/><category term="Bash"/><category term="Bash Script"/><category term="Computer Architecture"/><category term="Concurrency"/><category term="Conditional Variable"/><category term="Cpu Architecture"/><category term="Deep Learning"/><category term="HPC"/><category term="Hacking"/><category term="Linux Programming"/><category term="Parallel"/><category term="Python"/><category term="Semaphore"/><category term="Smart Pointer"/><category term="Software Craftmanship"/><category term="Ubuntu"/><category term="Unit Test"/><category term="Visual Studio"/><category term="개발자"/><category term="공지"/><category term="병특"/><category term="여행"/><category term="일본여행"/><category term="2019년"/><category term="ASP"/><category term="Agile"/><category term="Android"/><category term="Android Framework"/><category term="Auto Program"/><category term="BeautifulSoup4"/><category term="C"/><category term="C++ API Design"/><category term="Cache"/><category term="Chrome Extension"/><category term="Cloud Service"/><category term="Compiler"/><category term="Constructor"/><category term="Container"/><category term="DNS"/><category term="Dash"/><category term="Data Alignment"/><category term="Destructor"/><category term="Development"/><category term="Distributed System"/><category term="Domain"/><category term="Embedded"/><category term="Epoll"/><category term="Factory Function"/><category term="Fork"/><category term="GSoC"/><category term="GSoC 2017"/><category term="Good Practice"/><category term="Google Summer Of Code"/><category term="Host Registration"/><category term="Hypervisor"/><category term="IaaS"/><category term="Intel"/><category term="Internet"/><category term="Interpreter"/><category term="JIT"/><category term="LLVM"/><category term="Lock"/><category term="Meltdown"/><category term="Message Queue"/><category term="Monitor"/><category term="Multi Core"/><category term="Mutex"/><category term="Name Server"/><category term="Network"/><category term="OOP"/><category term="Open Source"/><category term="OpenMP"/><category term="Operator Overloading"/><category term="Optimized C++"/><category term="PXE"/><category term="PaaS"/><category term="Pintos"/><category term="Private Key"/><category term="PyPy"/><category term="Pypi"/><category term="RAII"/><category term="RPython"/><category term="ReStructuredText"/><category term="Resource Management"/><category term="SaaS"/><category term="Security"/><category term="Software Craftman"/><category term="Sogang University"/><category term="Synchronization"/><category term="System Call"/><category term="TDD"/><category term="Testing"/><category term="VC++2015"/><category term="VM"/><category term="Virtual Machine"/><category term="Virtualization"/><category term="Windows Vista"/><category term="Windows XP"/><category term="XP"/><category term="ZeroMQ"/><category term="new"/><category term="std::make_shared"/><category term="std::shared_ptr"/><category term="vc140_xp"/><category term="개발"/><category term="개발다운개발"/><category term="개발문화"/><category term="개발프로세스"/><category term="고베"/><category term="교토"/><category term="구글블로거"/><category term="기초군사훈련"/><category term="네이버블로그"/><category term="논산훈련소"/><category term="리펙토링"/><category term="모락산"/><category term="문서화"/><category term="블로그"/><category term="삿포로"/><category term="새해"/><category term="소프트웨어품질"/><category term="오사카"/><category term="오타루"/><category term="오픈채팅방"/><category term="요구사항분석"/><category term="육군훈련소"/><category term="이스트시큐리티"/><category term="인사"/><category term="인턴"/><category term="일본"/><category term="직장인"/><category term="채용"/><category term="채용공고"/><category term="출퇴근"/><category term="카톡"/><category term="현역"/><category term="현역병특"/><title type='text'>Taeguk&#39;s Blog</title><subtitle type='html'>Makes the way!</subtitle><link rel='http://schemas.google.com/g/2005#feed' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/posts/default'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/'/><link rel='hub' href='http://pubsubhubbub.appspot.com/'/><link rel='next' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default?start-index=26&amp;max-results=25'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><generator version='7.00' uri='http://www.blogger.com'>Blogger</generator><openSearch:totalResults>76</openSearch:totalResults><openSearch:startIndex>1</openSearch:startIndex><openSearch:itemsPerPage>25</openSearch:itemsPerPage><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-7046694959030756945</id><published>2019-03-11T23:21:00.002+09:00</published><updated>2019-03-11T23:25:11.213+09:00</updated><title type='text'>HPX parallel partition 알고리즘</title><content type='html'>&lt;link href=&quot;https://stackedit.io/style.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/link&gt; &lt;div class=&quot;stackedit&quot;&gt;안녕하세요. 오늘은 제가 예전에 &lt;a href=&quot;https://github.com/STEllAR-GROUP/hpx&quot;&gt;HPX&lt;/a&gt; 라는 오픈소스에 구현했던 parallel partition 알고리즘에 대해 간단히 소개하고 설명하는 시간을 가져보도록 하겠습니다.&lt;br /&gt;&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;먼저 이 포스팅에서 다루는 알고리즘/코드의 출처는 다음과 같습니다.&lt;br /&gt;&lt;ul&gt;&lt;li&gt;HPX : &lt;a href=&quot;https://github.com/STEllAR-GROUP/hpx&quot;&gt;https://github.com/STEllAR-GROUP/hpx&lt;/a&gt;&lt;/li&gt;&lt;li&gt;관련 MR : &lt;a href=&quot;https://github.com/STEllAR-GROUP/hpx/pull/2778&quot;&gt;https://github.com/STEllAR-GROUP/hpx/pull/2778&lt;/a&gt;&lt;/li&gt;&lt;li&gt;소스코드 : &lt;a href=&quot;https://github.com/STEllAR-GROUP/hpx/blob/master/hpx/parallel/algorithms/partition.hpp&quot;&gt;https://github.com/STEllAR-GROUP/hpx/blob/master/hpx/parallel/algorithms/partition.hpp&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;소개&quot;&gt;소개&lt;/h2&gt;parallel partition 알고리즘은 여러 개의 연산 유닛 (쉽게 말하면 cpu) 들을 이용해서 partition 알고리즘을 수행하는 것을 말합니다.&lt;br /&gt;이 포스팅에서는 독자가 partition 알고리즘에 대해서 이미 알고있다고 가정합니다. partition 알고리즘에 대한 설명은 &lt;a href=&quot;https://en.cppreference.com/w/cpp/algorithm/partition&quot;&gt;cppreference&lt;/a&gt; 를 참고하시기 바랍니다.&lt;br /&gt;&lt;h2 id=&quot;알고리즘-설명&quot;&gt;알고리즘 설명&lt;/h2&gt;partition 알고리즘은 주어진 영역을 정해진 규칙을 만족하는지 아닌지에 따라 두 영역으로 분류하는 알고리즘입니다.&lt;br /&gt;예를 들어, 짝수인지 여부에 대해 partition 알고리즘을 수행한다고 하면 결과는 다음과 같습니다.&lt;br /&gt;적용 전 : &lt;code&gt;3 5 7 4 2 1 9 8 6&lt;/code&gt;&lt;br /&gt;적용 후 : &lt;code&gt;6 8 2 4 * 7 1 9 5 3&lt;/code&gt;&lt;br /&gt;즉, partition 알고리즘의 핵심은 다음과 같습니다.&lt;br /&gt;&lt;ul&gt;&lt;li&gt;두 영역을 구분할 수 있는 boundary 를 찾는다.&lt;/li&gt;&lt;li&gt;그 boundary 의 왼쪽에는 조건을 만족하는 원소들이, 오른쪽에는 조건을 만족하지 않는 원소들이 위치하게 된다.&lt;/li&gt;&lt;/ul&gt;자, 위의 핵심을 기억하면서 parallel partition 알고리즘을 살펴보도록 합시다.&lt;br /&gt;결론적으로 parallel partition 알고리즘은 크게 4단계로 이루어집니다.&lt;br /&gt;&lt;ol&gt;&lt;li&gt;주어진 영역을 여러 개의 block 으로 쪼개서 병렬로 sub-partitioning 을 수행한다.&lt;/li&gt;&lt;li&gt;남은 block 들에 대해서 순차적으로 sub-partitioning 을 수행한다.&lt;/li&gt;&lt;li&gt;남은 block 들을 boundary 근처로 모아서 하나로 합친다.&lt;/li&gt;&lt;li&gt;boundary 근처로 합쳐진 하나의 block 에 대해서 순차 partition 알고리즘을 적용한다.&lt;/li&gt;&lt;/ol&gt;1단계를 제외한 2~4 단계는 모두 순차적으로 수행됩니다.&lt;br /&gt;그러면 1단계부터 살펴보도록 하겠습니다.&lt;br /&gt;&lt;h3 id=&quot;단계.-병렬-sub-partitioning&quot;&gt;1단계. 병렬 sub-partitioning&lt;/h3&gt;처음에 들었던 예시를 다시 한번 봐봅시다.&lt;br /&gt;적용 전 : &lt;code&gt;3 5 7 4 2 1 9 8 6&lt;/code&gt;&lt;br /&gt;적용 후 : &lt;code&gt;6 8 2 4 * 7 1 9 5 3&lt;/code&gt;&lt;br /&gt;위 예시에서도 볼 수 있듯이 partition 알고리즘은 &lt;strong&gt;unstable&lt;/strong&gt; 한 특성이 있습니다. (stable partition 알고리즘도 물론 별도로 존재합니다.)&lt;br /&gt;즉, 기존 원소들간의 순서를 지킬 필요없이 영역만 나누면 장땡입니다. 따라서 병렬 알고리즘을 구현하는게 매우 수월해지는데요. 주어진 영역을 여러 개의 block 으로 나눈뒤에  두 개의 block 끼리 짝을 지어서 partition 알고리즘을 수행하는 방식을 사용하려고 합니다. 일단, 순차적으로 이러한 알고리즘을 수행하는 것을 살펴보겠습니다.&lt;br /&gt;&lt;code&gt;3 5 7 4 2 1 9 8 6&lt;/code&gt;&lt;br /&gt;위와 같이 원소들이 주어져있을 때, 3개의 원소씩 block 을 구성하여 partitioning 을 수행해보겠습니다.&lt;br /&gt;&lt;code&gt;^ 3 5 7 | 4 2 1 | ^ 9 8 6&lt;/code&gt;&lt;br /&gt;맨 왼쪽과 맨 오른쪽에서 block 을 한 개씩 구성하면 위와 같습니다.&lt;br /&gt;&lt;code&gt;8 6 ^ 7 | ^ 4 2 1 | 9 3 5&lt;/code&gt;&lt;br /&gt;자 이제 두 block 에 대해서 partition 알고리즘을 수행하면 위와 같이 변하게 되는데요.&lt;br /&gt;맨 오른쪽 block 은 홀수만 존재하게 되었지만, 맨 왼쪽 block 은 여전히 ‘7’ 하나가 홀수인채로 남아있습니다. 맨 왼쪽 block 에 대해서도 partition 이 완전히 수행되려면 다시 오른쪽에서 block 을 하나 뽑아서 partition 을 마저 수행해야합니다.&lt;br /&gt;그렇게 partition 을 마저 수행하고 나면 다음과 같이 변합니다.&lt;br /&gt;&lt;code&gt;8 6 4 | 7 ^ 2 1 | 9 3 5&lt;/code&gt;&lt;br /&gt;자 여전히 &lt;code&gt;2 1&lt;/code&gt; 이 partitioning 되지 못하고 남게 되었는데요. 이렇게 이러한 작업을 반복해서 수행하다 보면 하나의 block 이 남을 수가 있습니다. 이렇게 남은 block 을 앞으로 &lt;strong&gt;remaining block&lt;/strong&gt; 이라고 부르겠습니다.&lt;br /&gt;지금까지 간단하게 설명드린 알고리즘을 병렬로도 돌릴 수가 있습니다.&lt;br /&gt;여러 개의 코어가 계속 왼쪽/오른쪽에서 block 을 뽑아가면서 partitioning 을 수행하면 됩니다.&lt;br /&gt;HPX 에서의 코드를 살펴보면 다음과 같습니다.&lt;br /&gt;&lt;pre class=&quot; language-cpp&quot;&gt;&lt;code class=&quot;prism  language-cpp&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// The function which performs sub-partitioning.&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt; FwdIter&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt; Pred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;typename&lt;/span&gt; Proj&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; block&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;FwdIter&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token function&quot;&gt;partition_thread&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;block_manager&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;FwdIter&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; block_manager&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;    Pred pred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Proj proj&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;using&lt;/span&gt; hpx&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;util&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;invoke&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    block&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;FwdIter&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; left_block&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; right_block&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    left_block &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; block_manager&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get_left_block&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    right_block &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; block_manager&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get_right_block&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;left_block&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt;&lt;br /&gt;                &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;left_block &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; block_manager&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get_left_block&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token function&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;pred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;proj&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;left_block&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;first&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;left_block&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;first&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;right_block&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt;&lt;br /&gt;                &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;right_block &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; block_manager&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get_right_block&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;pred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;proj&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;right_block&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;first&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;right_block&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;first&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;left_block&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; right_block&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;right_block&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; left_block&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        std&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;iter_swap&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;left_block&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;first&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; right_block&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;first&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;그렇게 1단계를 완료하고 나면, 다음과 같은 상태가 됩니다. (주황색은 remaining block 을 의미합니다.)&lt;br /&gt;여기서 boundary 라는게 있는데 이게 매우 중요합니다. 왼쪽에서 뽑힌 block 을 “왼쪽 block”, 오른쪽에서 뽑힌 block 을 “오른쪽 block” 이라고 할 때, “왼쪽 block” 들과 “오른쪽 block” 들 사이의 경계가 생기게 됩니다. 이 경계를 &lt;strong&gt;boundary&lt;/strong&gt; 라고 부르도록 하겠습니다. 여기서 주목해야할 특징은, boundary 왼쪽의 파란색 영역은 모두 주어진 조건을 만족하도록 partitioning 되어있고, 오른쪽의 파란색 영역은 모두 주어진 조건을 만족하지 않도록 partitioning 되어있다는 것입니다.&lt;br /&gt;즉, 주황색영역 (remaining block) 을 제외하면 boundary 를 기준으로 partitioning 되어있는 상태가 됩니다. 결국 문제가 되는건 주황색 영역인데 이 영역들을 2~4 단계에서 partitioning 하게 됩니다.&lt;br /&gt;&lt;img alt=&quot;&quot; src=&quot;https://lh3.googleusercontent.com/O5M2EUKQrjHSfEjQwyNVELcK9-9sWGPwaRzyVujh2LTYBnNUAl7Cxs7Hyh1g98mAJIaMbsmzxgtJ&quot; /&gt;&lt;br /&gt;&lt;h3 id=&quot;단계.-remaining-block-들에-대한-순차-sub-partitioning&quot;&gt;2단계. remaining block 들에 대한 순차 sub-partitioning&lt;/h3&gt;1단계에서, 만약 N개의 코어로 병렬작업을 수행한다면 최대 N개의 remaining block 이 생길 수 있습니다. 이렇게 생긴 N개의 remaining block 들에 대해서 똑같이 sub partitioning 을 수행할 수 있는데 이게 바로 2단계입니다. 단, 2단계에서는 순차적으로 sub-partitioning 을 수행하는데요. boundary 왼쪽과 오른쪽에서 각각 block 을 한 개씩 뽑아나가며 알고리즘을 수행합니다. 결국 최후에는 boundary 를 기준으로 한쪽에만 block 이 남게되는데요. 그림으로 보면 다음과 같은 상태가 됩니다.&lt;br /&gt;&lt;img alt=&quot;&quot; src=&quot;https://lh3.googleusercontent.com/AUnDCvhQ-f6KAOs6l4mE-piF6-omucyJndC0sb51Z-WedLKIen6vgDqSY_uxcN-I00DL06fGJX_k&quot; /&gt;&lt;br /&gt;코드는 &lt;a href=&quot;https://github.com/STEllAR-GROUP/hpx/blob/6c061adfe5190728a8c3b3c179badc04d4afa220/hpx/parallel/algorithms/partition.hpp#L607-L679&quot;&gt;&lt;code&gt;collapse_remaining_blocks()&lt;/code&gt; 함수&lt;/a&gt;를 참고하시길 바랍니다.&lt;br /&gt;&lt;h3 id=&quot;단계.-남은-block-들을-boundary-근처로-모은다.&quot;&gt;3단계. 남은 block 들을 boundary 근처로 모은다.&lt;/h3&gt;자, 이제 boundary 를 기준으로 한쪽에만 소수의 block 들이 partitioning 되지 않은 상태로 남아있습니다. partitioning 을 마저 완료하기 위해, 저 remaining block 들을 boundary 에 인접하도록 모아서 하나의 block 으로 합치고, 그것에 대해서 순차적인 일반 partition 알고리즘을 수행하려고 합니다.&lt;br /&gt;일단, remaining block 들을 boundary 에 인접하도록 하나의 block 으로 합치면 다음과 같은 상태가 됩니다.&lt;br /&gt;&lt;img alt=&quot;&quot; src=&quot;https://lh3.googleusercontent.com/cVmKj6Y2NcludhJxe2KDSsOs9m-1swDmAfyn3GOwh3s1iNtBNEjSFGK28yUKjEtmSKqAft2HSlQA&quot; /&gt;&lt;br /&gt;코드는 &lt;a href=&quot;https://github.com/STEllAR-GROUP/hpx/blob/6c061adfe5190728a8c3b3c179badc04d4afa220/hpx/parallel/algorithms/partition.hpp#L796-L830&quot;&gt;&lt;code&gt;merge_remaining_blocks()&lt;/code&gt; 함수&lt;/a&gt;를 참고하시길 바랍니다.&lt;br /&gt;&lt;h3 id=&quot;단계.-모아진-하나의-block-에-대해서-순차-partitioning-을-수행한다.&quot;&gt;4단계. 모아진 하나의 block 에 대해서 순차 partitioning 을 수행한다.&lt;/h3&gt;모아진 하나의 block 에 대해서 순차 partition 알고리즘을 적용하면 새로운 boundary 를 구할 수 있고, 이 boundary 가 마침내 주어진 영역을 주어진 조건에 따라 분리하는 최종 boundary 가 됩니다.&lt;br /&gt;&lt;img alt=&quot;&quot; src=&quot;https://lh3.googleusercontent.com/ccFZDKlaCMFB2_uo0u6-hNEuwB0XZA-HrSQTSkeT5iM8Hl8mbCMktMeQcV1XMntrnhyN7c46MSUI&quot; /&gt;&lt;br /&gt;&lt;h2 id=&quot;block-size&quot;&gt;block size&lt;/h2&gt;parallel partition 알고리즘의 성능을 최적화하기 위해서는 적절한 block size 를 사용하는 것이 중요합니다.&lt;br /&gt;만약 block size 가 너무 작다면, 1단계에서 block 을 자주 뽑아야 하므로 여기에서 overhead 가 많이 발생할 수 있습니다. (특히 block 을 뽑을 때 동기화 연산이 들어가므로 더더욱 그렇습니다.) 또한, block 을 자주 뽑게되면 cache miss 의 비율이 늘어나 성능상으로 악영향을 주게 됩니다.&lt;br /&gt;그렇다고 block size 가 너무 크면, remaining block 의 사이즈가 커지게 되고 이에 따라 순차적으로 수행해야하는 알고리즘들이 오래걸리게 됩니다.&lt;br /&gt;제가 HPX 에 parallel partition 을 구현할 때는 block size 를 바꿔가면서 성능테스트를 수행해보고 다른 논문의 실험결과도 참고하여 default block size 로서 20000 을 채택하게 되었습니다.&lt;br /&gt;&lt;h2 id=&quot;벤치마크&quot;&gt;벤치마크&lt;/h2&gt;제가 parallel partition 을 구현하고나서 수행했던 벤치마크 결과입니다.&lt;br /&gt;16 코어 (8 physical core) 환경에서 테스트했을 때, sequential version 에 비해 약 12배정도 빠른 것을 확인할 수 있었습니다.&lt;br /&gt;&lt;img alt=&quot;&quot; src=&quot;https://lh3.googleusercontent.com/VuPbRbqhnqZF14FJMhnI7pl8Wxx0CcPfMKnvF2_SGJYcLUm2vVb2Zxpu5yVFN6qzmrdYqXlfUtAA&quot; /&gt;&lt;br /&gt;&lt;h2 id=&quot;마무리&quot;&gt;마무리&lt;/h2&gt;이번 포스팅을 하기위해 오랜만에 옛날 코드를 뒤적거렸는데요. HPX 오픈소스를 한창 하던때가 17년 여름인데 벌써 2년이 다되간다는게, 참 시간이 빠르네요. 그리고, 옛날 코드를 다시 보니 맘에 안드는 점들도 많이 보이고…ㅠㅠ&lt;br /&gt;아무튼, 코너 케이스 처리와 iterator category 마다의 다른 구현을 확인하고 싶으신 분은 &lt;a href=&quot;https://github.com/STEllAR-GROUP/hpx/blob/master/hpx/parallel/algorithms/partition.hpp&quot;&gt;여기&lt;/a&gt;에서 전체 코드를 참고하시면 될 것 같습니다.&lt;br /&gt;포스팅에 정성을 많이 못 쏟은거 같은데, 여기까지 읽어주셔서 감사합니다~&lt;br /&gt;다음에 만나요~~&lt;/div&gt;&lt;hr /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;이 포스팅은 &lt;a href=&quot;https://infossm.github.io/blog/2019/03/10/hpx-parallel-partition/&quot;&gt;삼성 소프트웨어 멤버십 기술 블로그에 동시에 포스팅&lt;/a&gt;됩니다.&lt;/span&gt;&lt;/b&gt;</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/7046694959030756945/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2019/03/hpx-parallel-partition.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/7046694959030756945'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/7046694959030756945'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2019/03/hpx-parallel-partition.html' title='HPX parallel partition 알고리즘'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-5358137638365974876</id><published>2019-02-11T19:32:00.001+09:00</published><updated>2019-02-11T19:56:59.611+09:00</updated><title type='text'>Rust Procedural Macros By Example</title><content type='html'>&lt;link href=&quot;https://stackedit.io/style.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/link&gt;&lt;div class=&quot;stackedit&quot;&gt;안녕하세요. 제가 최근에 Rust 공부를 시작했는데요~&lt;br /&gt;그래서 오늘은 Rust 1.29.0 부터 stable 이 된 Procedural Macros 에 대해서 포스팅해보도록 하겠습니다.&lt;br /&gt;포스팅은 구구절절한 설명보다는 예제 코드 위주가 될 예정입니다!&lt;br /&gt;&lt;h2 id=&quot;rust-의-매크로-시스템&quot;&gt;Rust 의 매크로 시스템&lt;/h2&gt;Rust 의 매크로 시스템은 매우 강력한데요. 크게 다음과 같이 분류 할 수 있습니다.&lt;br /&gt;&lt;ol&gt;&lt;li&gt;Declarative Macros&lt;/li&gt;&lt;li&gt;Procedural Macros &lt;ul&gt;&lt;li&gt;Function-like macros&lt;/li&gt;&lt;li&gt;Derive mode macros&lt;/li&gt;&lt;li&gt;Attribute macros&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;첫 번째는 Declarative Macros 는 일반적으로 개발자들이 흔히 알고 있는 “선언적” 형태의 매크로 방식인데요. C/C++ 등의 타언어들과의 차이점은 문자열 전처리기 방식이 아니라 Abstract Syntax Tree 를 직접 건드리는 방식이라는 점입니다.&lt;br /&gt;&lt;pre class=&quot; language-rust&quot;&gt;&lt;code class=&quot;prism  language-rust&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 출처 : https://doc.rust-lang.org/rust-by-example/macros/dsl.html&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token macro-rules function&quot;&gt;macro_rules!&lt;/span&gt; calculate &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;eval $e&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;expr&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; val&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; usize &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; $e&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Force types to be integers&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token function&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;{} = {}&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token macro-rules function&quot;&gt;stringify!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;$e&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; val&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token macro-rules function&quot;&gt;calculate!&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        eval &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// hehehe `eval` is _not_ a Rust keyword!&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token macro-rules function&quot;&gt;calculate!&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token function&quot;&gt;eval&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;Declarative Macros 는 이번 포스팅의 주제가 아니므로, 더 이상 언급하진 않겠습니다.&lt;br /&gt;두 번째는 이번 포스팅의 주제인 Procedural Macros 인데요. &lt;strong&gt;함수의 실행&lt;/strong&gt; 으로서 매크로를 정의하는 방식입니다.&lt;br /&gt;일단 큰 틀에서 쉽게 얘기하자면 아래와 같습니다.&lt;br /&gt;&lt;pre class=&quot; language-text&quot;&gt;&lt;code class=&quot;prism  language-text&quot;&gt;원래의 AST --input--&amp;gt; &quot;함수&quot; --output--&amp;gt; 수정된 AST&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;“함수” 는 인풋으로 원래 소스코드의 AST(Abstract Syntax Tree) 를 받고요. 함수 내부에서  AST 를 수정해서 아웃풋으로 반환합니다. 그러면 이제 실제로 컴파일되는건 수정된 AST 가 되는 것이죠.&lt;br /&gt;여기서 주목해야할 점은 저 “함수” 는 그냥 일반적인 Rust 코드로 작성된다는 점입니다. 즉, 일반적인 Rust 코드로서 Procedural Macro 를 정의할 수 있고, 이 &quot;함수&quot;는 &lt;strong&gt;컴파일 시점에 실행&lt;/strong&gt;되게 됩니다. (일종의 컴파일러 플러그인같은 느낌입니다.) 실제 코드로 확인하자면 아래와 같은 식으로 Procedural Macro 를 정의하게 됩니다.&lt;br /&gt;&lt;pre class=&quot; language-rust&quot;&gt;&lt;code class=&quot;prism  language-rust&quot;&gt;&lt;span class=&quot;token attribute attr-name&quot;&gt;#[proc_macro]&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;some_macro&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;input&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; TokenStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; TokenStream&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt; &lt;span class=&quot;token comment&quot;&gt;// Do something&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;실제 코드상에서는 AST 자료구조가 아닌 Token Stream 이 input, output 으로 사용되는데요. AST 자료구조보다는 Token Stream 을 사용하는게 인터페이스상으로 더 안정적이기 때문이라고 합니다. (아무래도 AST 자료구조 인터페이스는 변경될 가능성이 더 클테니까요.) 기초 컴파일러 이론을 잘 모르신다면 Token 이라는 개념을 모르실 수도 있는데요. &lt;a href=&quot;https://en.wikipedia.org/wiki/Lexical_analysis&quot;&gt;위키&lt;/a&gt;의 “Token” 부분을 읽어보시면 이해가 되실 겁니다.&lt;br /&gt;&lt;h2 id=&quot;cargo.toml-및-예제-환경&quot;&gt;Cargo.toml 및 예제 환경&lt;/h2&gt;Procedural Macros 를 정의하기 위해서는 Cargo.toml 에 반드시 다음과 같이 명시해줘야만 합니다.&lt;br /&gt;&lt;pre class=&quot; language-toml&quot;&gt;&lt;code class=&quot;prism  language-toml&quot;&gt;[lib]&lt;br /&gt;proc-macro = true&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;그리고 이 포스팅의 예제에서 사용된 crate dependency 는 다음과 같습니다.&lt;br /&gt;&lt;pre class=&quot; language-toml&quot;&gt;&lt;code class=&quot;prism  language-toml&quot;&gt;[dependencies]&lt;br /&gt;proc-macro2 = &quot;0.4&quot;&lt;br /&gt;syn = { version = &quot;0.15&quot;, features = [&quot;full&quot;, &quot;extra-traits&quot;] }&lt;br /&gt;quote = &quot;0.6&quot;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;또한 사용한 툴체인은 &lt;code&gt;beta-x86_64-pc-windows-msvc - rustc 1.33.0-beta.6 (b203178b6 2019-02-05)&lt;/code&gt; 이고 에디션은 2018 입니다.&lt;br /&gt;&lt;h2 id=&quot;function-like-macros&quot;&gt;Function-like macros&lt;/h2&gt;이제부터 &lt;code&gt;Procedural Macros&lt;/code&gt; 의 세부 분류중 하나인 &lt;code&gt;Function-like macros&lt;/code&gt; 에 대해서 알아보겠습니다. 거두절미하고 간단한 예제를 통해 확인해봅시다.&lt;br /&gt;&lt;pre class=&quot; language-rust&quot;&gt;&lt;code class=&quot;prism  language-rust&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// library user&#39;s code&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; my_example&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;make_function&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token function&quot;&gt;make_function!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// 생성된 함수를 호출합니다.&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;generated_function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// proc-macro crate&#39;s code&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;crate&lt;/span&gt; proc_macro&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; proc_macro&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;TokenStream&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token attribute attr-name&quot;&gt;#[proc_macro]&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;make_function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;_&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; TokenStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; TokenStream &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;make_function() called in compile time!&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// 함수의 정의를 담은 문자열을 파싱해서 TokenStream 으로 만들어 반환합니다.&lt;/span&gt;&lt;br /&gt;    &quot;&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;generated_function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token function&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;\&quot;I&#39;m the generated function by procedural macro&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;\&quot;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&quot;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;unwrap&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;img alt=&quot;&quot; src=&quot;https://lh3.googleusercontent.com/ymwVxYiHG34pEcGtOTtv_YjOyLCOly0XBuDAgF8uND8NkX_gg4VSRB_vErd21vg-Zv3HoCcGCQRF&quot; /&gt;&lt;br /&gt;아주 간단한 예제입니다. 사진에서 보시다시피 &lt;code&gt;make_function()&lt;/code&gt; 함수는 컴파일타임에 실행됩니다.&lt;br /&gt;그러면 이제부터 이 간단한 예제를 계속 발전시켜나가 볼텐데요.&lt;br /&gt;먼저, 저 매크로에 &lt;strong&gt;생성되는 함수의 이름을 사용자가 설정할 수 있도록 하는 기능&lt;/strong&gt;을 추가해보겠습니다~&lt;br /&gt;&lt;pre class=&quot; language-rust&quot;&gt;&lt;code class=&quot;prism  language-rust&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// library user&#39;s code&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; my_example&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;make_function&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// fn generated_function() { --snip-- }&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token function&quot;&gt;make_function!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// fn foobar() { --snip-- }&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token function&quot;&gt;make_function!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;foobar&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;generated_function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;foobar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// proc-macro crate&#39;s code&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;crate&lt;/span&gt; proc_macro&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; proc_macro&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;TokenStream&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; quote&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;quote&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token attribute attr-name&quot;&gt;#[proc_macro]&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;make_function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; TokenStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; TokenStream &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// syn crate 를 활용해 매크로 인자를 파싱합니다.&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// Identifier 로 파싱이 가능한 경우 인자를 함수명으로 사용하고,&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// 불가능한 경우, &quot;generated_function&quot; 을 함수명으로 사용합니다.&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; func_name&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Ident &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;match&lt;/span&gt; syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token function&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;func_name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; func_name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token function&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Ident&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;generated_function&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; proc_macro2&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Span&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call_site&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// quote! 를 활용하면 소스코드를 TokenStream 으로 변환할 수 있습니다.&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; tokens &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token macro-rules function&quot;&gt;quote!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; #&lt;span class=&quot;token function&quot;&gt;func_name&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token function&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;I&#39;m the generated function by procedural macro.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    tokens&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;into&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;새로운게 등장했죠? 주석을 통해 기본적으로 설명을 드리긴 했는데요. &lt;a href=&quot;https://docs.rs/syn/0.15.26/syn/struct.Ident.html&quot;&gt;syn::Ident&lt;/a&gt; 는 Identifier 의 약자로서 키워드나 변수명을 나타내는 구조체입니다.&lt;br /&gt;&lt;pre class=&quot; language-rust&quot;&gt;&lt;code class=&quot;prism  language-rust&quot;&gt;syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Ident&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;generated_function&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; proc_macro2&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Span&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call_site&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;를 보면, 첫 번째 인자로 Identifier 의 이름이 들어가고 두 번째 인자로 &lt;code&gt;proc_macro2::Span::call_site()&lt;/code&gt; 가 들어가는데, &lt;a href=&quot;https://docs.rs/proc-macro2/0.4.27/proc_macro2/struct.Span.html&quot;&gt;proc_macro2::Span&lt;/a&gt; 는 소스코드의 특정 영역을 의미하는 구조체입니다. 여기서 &lt;code&gt;call_site()&lt;/code&gt; 에 주목해야하는데 이 부분에 대한 설명은 &lt;a href=&quot;https://doc.rust-lang.org/beta/proc_macro/struct.Ident.html&quot;&gt;여기&lt;/a&gt;를 읽어보시면 됩니다. 읽다보면 &lt;strong&gt;&lt;code&gt;hygiene&lt;/code&gt;&lt;/strong&gt; 이라는 용어가 등장하는데요. 이 부분은 &lt;a href=&quot;https://rust-lang.github.io/rustc-guide/macro-expansion.html#hygiene&quot;&gt;요기&lt;/a&gt;를 읽어보시면 대략적인 개념을 잡으실 수 있으십니다. 아무튼 그래서 이 예제에서는 &lt;code&gt;make_function()&lt;/code&gt; 매크로가 생성한 함수를 매크로 외부에서 호출할 수 있어야하기 때문에 &lt;code&gt;call_site()&lt;/code&gt; 를 사용하였습니다.&lt;br /&gt;그 외에 부족한 설명은 &lt;a href=&quot;https://github.com/dtolnay/quote&quot;&gt;quote&lt;/a&gt;, &lt;a href=&quot;https://github.com/dtolnay/syn&quot;&gt;syn&lt;/a&gt; 을 참고하시면 될 것 같습니다~&lt;br /&gt;자, 그러면 다음으로 이제 &lt;strong&gt;생성되는 함수의 인자 타입을 사용자가 설정할 수 있도록 하는 기능&lt;/strong&gt;을 추가해보겠습니다.&lt;br /&gt;&lt;pre class=&quot; language-rust&quot;&gt;&lt;code class=&quot;prism  language-rust&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// library user&#39;s code&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; my_example&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;make_function&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token function&quot;&gt;make_function!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token function&quot;&gt;make_function!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;foo&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; u32&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; f64&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token function&quot;&gt;make_function!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;bar&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; String&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; u32&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; f64&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//make_function!(todo, &amp;amp;str); // 지원 안됨.&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;generated_function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1.23&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;String&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1.23&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// proc-macro crate&#39;s code&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;crate&lt;/span&gt; proc_macro&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; quote&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;quote&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; ParsedArguments &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    func_name&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; proc_macro2&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Ident&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;    arg_types&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Vec&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;proc_macro2&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Ident&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;parse_arguments&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;args&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; proc_macro2&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;TokenStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; ParsedArguments &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; parsed_arg &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; ParsedArguments &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        func_name&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; proc_macro2&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Ident&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;generated_function&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; proc_macro2&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Span&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call_site&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;        arg_types&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;vec!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; arg_vec &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;vec!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; arg &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;into_iter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        arg_vec&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; arg_vec&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token comment&quot;&gt;// 첫 번째 인자는 함수명을 의미하는 identifier 이여야만 한다.&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; func_name&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; proc_macro2&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Ident &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;arg_vec&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            proc_macro2&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;TokenTree&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Ident&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;ref&lt;/span&gt; func_name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; func_name&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;            _ &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;panic!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;The first token must be an identifier.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        parsed_arg&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;func_name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; func_name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token comment&quot;&gt;// 그 다음부터는 comma (,) 와 인자 타입을 의미하는 identifier 가 반복해서 와야한다.&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; arg_vec&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token comment&quot;&gt;// comma 인지 체크&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token keyword&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;arg_vec&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;                proc_macro2&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;TokenTree&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Punct&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;ref&lt;/span&gt; punct&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;                    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; punct&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;as_char&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;,&#39;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;                        &lt;span class=&quot;token function&quot;&gt;panic!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;The token {} must be a comma.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;                    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;                &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;                _ &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;panic!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;The token {} must be a comma.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;            &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;gt;=&lt;/span&gt; arg_vec&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;                &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;            &lt;span class=&quot;token comment&quot;&gt;// Identifier 인지 체크&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; type_name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;arg_vec&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;                proc_macro2&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;TokenTree&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Ident&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;ref&lt;/span&gt; type_name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; type_name&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;                _ &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;panic!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;The token {} must be an identifier.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;            parsed_arg&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;arg_types&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;type_name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;            i &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    parsed_arg&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token attribute attr-name&quot;&gt;#[proc_macro]&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;make_function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;args&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; proc_macro&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;TokenStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; proc_macro&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;TokenStream &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; args &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; proc_macro2&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;TokenStream&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; parsed_args &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;parse_arguments&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; func_name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; parsed_args&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;func_name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; arg_types &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; parsed_args&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;arg_types&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; tokens &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token macro-rules function&quot;&gt;quote!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; #&lt;span class=&quot;token function&quot;&gt;func_name&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;#&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;_&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; #arg_types&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token function&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;I&#39;m the generated function by procedural macro.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    tokens&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;into&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;다소 길어지긴 했지만, 차근차근 보시면 이해하실 수 있을 것 같습니다. 이전 예제에 비해 달라진 점은 &lt;code&gt;proc_macro2&lt;/code&gt; crate 를 많이 활용했다는 점인데요. &lt;code&gt;proc_macro2&lt;/code&gt; 에 대한 설명은 &lt;a href=&quot;https://github.com/alexcrichton/proc-macro2&quot;&gt;Github Repo&lt;/a&gt; 을 참고하시면 될 것 같습니다. 그리고 &lt;code&gt;quote!&lt;/code&gt; 쪽에 &lt;code&gt;#(_: #arg_types),*&lt;/code&gt; 가 보이실텐데요. &lt;code&gt;quote!&lt;/code&gt; 가 제공하는 기능중 하나인 &lt;a href=&quot;https://github.com/dtolnay/quote#repetition&quot;&gt;Repetition&lt;/a&gt; 을 활용한 것입니다.&lt;br /&gt;그러면 이번에는 위의 &lt;code&gt;parse_arguments()&lt;/code&gt; 함수를 &lt;a href=&quot;https://docs.rs/syn/0.15.26/syn/parse/index.html&quot;&gt;syn::parse&lt;/a&gt; 를 활용해서 리펙토링 해보도록 하겠습니다.&lt;br /&gt;&lt;pre class=&quot; language-rust&quot;&gt;&lt;code class=&quot;prism  language-rust&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// library user&#39;s code&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; my_example&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;make_function&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token function&quot;&gt;make_function!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token function&quot;&gt;make_function!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;foo&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; u32&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; f64&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token function&quot;&gt;make_function!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;bar&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; String&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; u32&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; f64&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token function&quot;&gt;make_function!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;error&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; String&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; u32&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; f64&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;// 컴파일 에러&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//make_function!(todo, &amp;amp;str); // 지원 안됨.&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;generated_function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1.23&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;String&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1.23&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// proc-macro crate&#39;s code&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;crate&lt;/span&gt; proc_macro&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; quote&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;quote&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; ParsedArguments &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    func_name&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Ident&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;    arg_types&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Vec&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Ident&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;impl&lt;/span&gt; syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;parse&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Parse &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; ParsedArguments &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;input&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;parse&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;ParseStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Result&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Self&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; parsed_args &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; ParsedArguments &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            func_name&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; proc_macro2&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Ident&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;generated_function&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; proc_macro2&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Span&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call_site&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;            arg_types&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;vec!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;input&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;is_empty&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token comment&quot;&gt;// 첫 번째 인자는 함수명을 의미하는 identifier 이여야만 한다.&lt;/span&gt;&lt;br /&gt;            parsed_args&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;func_name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;match&lt;/span&gt; input&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;                &lt;span class=&quot;token function&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;func_name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; func_name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;                &lt;span class=&quot;token function&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Error&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;span&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;format!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;br /&gt;                    &lt;span class=&quot;token string&quot;&gt;&quot;The first token must be an identifier.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;            &lt;span class=&quot;token comment&quot;&gt;// 그 다음부터는 comma (,) 와 인자 타입을 의미하는 identifier 가 반복해서 와야한다.&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;input&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;is_empty&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;                &lt;span class=&quot;token comment&quot;&gt;// comma 인지 체크&lt;/span&gt;&lt;br /&gt;                &lt;span class=&quot;token keyword&quot;&gt;match&lt;/span&gt; input&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;parse&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;token&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Comma&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;                    &lt;span class=&quot;token function&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;_&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;                    &lt;span class=&quot;token function&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Error&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;span&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;format!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;br /&gt;                        &lt;span class=&quot;token string&quot;&gt;&quot;The token {} must be a comma.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;                &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;                i &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; input&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;is_empty&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;                    &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;                &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                &lt;span class=&quot;token comment&quot;&gt;// Identifier 인지 체크&lt;/span&gt;&lt;br /&gt;                &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; type_name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;match&lt;/span&gt; input&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;parse&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Ident&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;                    &lt;span class=&quot;token function&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;type_name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; type_name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;                    &lt;span class=&quot;token function&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Error&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;span&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;format!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;br /&gt;                        &lt;span class=&quot;token string&quot;&gt;&quot;The token {} must be an identifier.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;                &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;                parsed_args&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;arg_types&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;type_name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;                i &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token function&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;parsed_args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token attribute attr-name&quot;&gt;#[proc_macro]&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;make_function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;input&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; proc_macro&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;TokenStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; proc_macro&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;TokenStream &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; parsed_args &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;parse_macro_input!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;input &lt;span class=&quot;token keyword&quot;&gt;as&lt;/span&gt; ParsedArguments&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; func_name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; parsed_args&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;func_name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; arg_types &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; parsed_args&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;arg_types&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; tokens &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token macro-rules function&quot;&gt;quote!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; #&lt;span class=&quot;token function&quot;&gt;func_name&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;#&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;_&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; #arg_types&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token function&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;I&#39;m the generated function by procedural macro.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    tokens&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;into&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;code&gt;syn&lt;/code&gt; crate 의 &lt;a href=&quot;https://docs.rs/syn/0.15.26/syn/parse/trait.Parse.html&quot;&gt;syn::parse::Parse&lt;/a&gt;, &lt;a href=&quot;https://docs.rs/syn/0.15.26/syn/macro.parse_macro_input.html&quot;&gt;syn::parse_macro_input&lt;/a&gt; 를 활용해서 리펙토링하고 나니 코드가 더 깔끔해졌습니다. (컴파일에러 메시지를 customize 하기 위해서 코드가 약간 복잡해진 것을 감안해주세요 ㅎㅎ) 뿐만아니라, 컴파일에러시 다음 사진과 같이 구체적으로 어디가 잘못됐는지 사용자에게 알려줄 수 있게 되었습니다.&lt;br /&gt;&lt;img alt=&quot;&quot; src=&quot;https://lh3.googleusercontent.com/c4rK4ZTAAhV3GqFbTn6ina4C-vyJtzLvITKa-SoYaZU8bJhXIOvqab26S2Y-yVR4Ji_Lw8xp7nAG&quot; /&gt;&lt;br /&gt;자, 지금까지 차근차근 예제를 발전시켜나가면서 여러가지 내용들을 익혀봤는데요. 여기서 다룬 내용들은 &lt;code&gt;Function-like Macros&lt;/code&gt; 에만 해당되는 내용은 아니고, &lt;code&gt;Attribute Macros&lt;/code&gt; 와 &lt;code&gt;Derive mode macros&lt;/code&gt; 에도 모두 적용가능한 내용들입니다~ 그러면 이제 다른 종류의 매크로들에 대해서도 간단하게 살펴보도록 하겠습니다.&lt;br /&gt;&lt;h2 id=&quot;attribute-macros&quot;&gt;Attribute Macros&lt;/h2&gt;이 것 역시 거두절미하고 바로 간단한 예제부터 보겠습니다.&lt;br /&gt;&lt;pre class=&quot; language-rust&quot;&gt;&lt;code class=&quot;prism  language-rust&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// library user&#39;s code&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; my_example&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;foobar&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// attr: &quot;&quot;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// item: &quot;fn func_1() { }&quot;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token attribute attr-name&quot;&gt;#[foobar]&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;func_1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// attr: &quot;a , b , c , 1 , 2&quot;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// item: &quot;fn func_2() { }&quot;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token attribute attr-name&quot;&gt;#[foobar(a, b, c, 1, 2)]&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;func_2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// attr: &quot;x , y&quot;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// item: &quot;struct Struct;&quot;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token attribute attr-name&quot;&gt;#[foobar(x, y)]&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; Struct&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// proc-macro crate&#39;s code&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;crate&lt;/span&gt; proc_macro&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; proc_macro&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;TokenStream&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token attribute attr-name&quot;&gt;#[proc_macro_attribute]&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;foobar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;attr&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; TokenStream&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; item&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; TokenStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; TokenStream &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;attr: \&quot;{}\&quot;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; attr&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;to_string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;item: \&quot;{}\&quot;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; item&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;to_string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    item&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;code&gt;Attribute Macros&lt;/code&gt; 의 경우에는 파라미터로 2개의 TokenStream 이 들어오는데요. 각각이 무엇을 의미하는지는 위 예제를 보면 알 수 있습니다.&lt;br /&gt;그러면, 이번에는 실제로 쓸만한 걸 만들어 볼까요?? Python 에서의 function decorator 와 비슷한 것을 만들어보도록 하겠습니다.&lt;br /&gt;&lt;pre class=&quot; language-rust&quot;&gt;&lt;code class=&quot;prism  language-rust&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// library user&#39;s code&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; my_example&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;decorated&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token attribute attr-name&quot;&gt;#[decorated(decorator)]&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;str&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; u32&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; u32&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; u32 &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;foo(\&quot;{}\&quot;, {}, {}) -&amp;gt; {}&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; s&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    x &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; y&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; decorator&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;F&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;f&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; F&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; s&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;str&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; u32&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; u32&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; u32 &lt;span class=&quot;token keyword&quot;&gt;where&lt;/span&gt; F&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;str&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; u32&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; u32&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; u32 &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; ret &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;twice!&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;decorator&amp;lt;F&amp;gt;(f, \&quot;{}\&quot;, {}, {}) -&amp;gt; {}&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; s&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ret&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    ret&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// Output:&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;//     foo(&quot;twice!&quot;, 2, 4) -&amp;gt; 6&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;//     decorator&amp;lt;F&amp;gt;(f, &quot;hello&quot;, 1, 2) -&amp;gt; 6&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// proc-macro crate&#39;s code&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// https://github.com/Manishearth/rust-adorn 를 참고하여 작성하였습니다.&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;crate&lt;/span&gt; proc_macro&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; proc_macro&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;TokenStream&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; quote&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;quote&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token attribute attr-name&quot;&gt;#[proc_macro_attribute]&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;decorated&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;attr&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; TokenStream&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; input&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; TokenStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&amp;gt;&lt;/span&gt; TokenStream &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; decorator_name&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Ident &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;attr&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;unwrap&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; original_func&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;ItemFn &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;input&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;unwrap&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// decorator 함수에 전달될 인자들의 이름이 저장되는 벡터&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; args_for_decorator &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Vec&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;with_capacity&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;original_func&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;decl&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;inputs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; renamed_func_name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Ident&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;_renamed_func&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; proc_macro2&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Span&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call_site&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    args_for_decorator&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;quote!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;#renamed_func_name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// 원본 함수의 이름을 변경한다.&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; original_func_name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;  std&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;mem&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; original_func&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;ident&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; renamed_func_name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// 새로 만들어질 함수의 인자들이 저장되는 벡터&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; new_args &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;vec!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; arg_no &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// 원본 함수의 인자들을 순회한다.&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; org_arg &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; original_func&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;decl&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;inputs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; arg_name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Ident&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;format!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;_arg_{}&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg_no&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;as_str&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;            proc_macro2&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;Span&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call_site&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;match&lt;/span&gt; org_arg &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token comment&quot;&gt;// See: https://docs.rs/syn/0.15.26/syn/enum.FnArg.html&lt;/span&gt;&lt;br /&gt;            syn&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;FnArg&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Captured&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;ref&lt;/span&gt; cap&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;                &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; type_name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;cap&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;ty&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;                new_args&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;quote!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;#arg_name&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; #type_name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;            _ &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;panic!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Unexpected argument {:?}&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; org_arg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;        args_for_decorator&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;quote!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;#arg_name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        arg_no &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; attrs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;original_func&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;attrs&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; vis &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;original_func&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;vis&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; constness &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;original_func&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;constness&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; unsafety &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;original_func&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;unsafety&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; abi &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;original_func&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;abi&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; generics &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;original_func&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;decl&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;generics&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; output &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;original_func&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;decl&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;output&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// 원본 함수의 이름을 가진 새로운 함수를 생성한다.&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// 새로운 함수는 기존 원본 함수와 똑같은 이름, 속성, constness 등을 가진다.&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// 원본 함수는 이름이 변경된 형태로 새로운 함수의 내부에 정의되게 된다.&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// 새로운 함수는 원본 함수를 첫 번째 인자로, 그리고 자신의 인자들을 그대로 나머지 인자로&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// 해서 decorator 함수를 호출한다.&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; tokens &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;quote!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;br /&gt;        #&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;#attrs&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;br /&gt;        #vis #constness #unsafety #abi &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; #original_func_name #&lt;span class=&quot;token function&quot;&gt;generics&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;#&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;#new_args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; #output &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            #original_func&lt;br /&gt;            #&lt;span class=&quot;token function&quot;&gt;decorator_name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;#&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;#args_for_decorator&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    tokens&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;into&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;어느정도 그럴듯한 python 스타일의 decorator 가 만들어졌습니다! (위 코드는 &lt;a href=&quot;https://github.com/Manishearth/rust-adorn&quot;&gt;adorn&lt;/a&gt; 의 코드를 참고하여 Rust 2018 에디션 기반으로 제가 새롭게 rewriting 하였습니다.)&lt;br /&gt;&lt;h2 id=&quot;derive-mode-macros&quot;&gt;Derive Mode Macros&lt;/h2&gt;위에 제가 작성한 &lt;code&gt;Function-like Macros&lt;/code&gt; 와 &lt;code&gt;Attribute Macros&lt;/code&gt; 의 예제들을 이해하셨다면 Derive Mode Macros 를 제가 굳히 설명드리는 건 불필요할 것 같습니다. 관심있으신 분들은 &lt;a href=&quot;https://doc.rust-lang.org/reference/procedural-macros.html#derive-mode-macros&quot;&gt;Rust 레퍼런스&lt;/a&gt;를 참고하여 직접 코드를 작성해보시면 될 것 같습니다!&lt;br /&gt;&lt;h2 id=&quot;마무리&quot;&gt;마무리&lt;/h2&gt;Rust 의 매크로 시스템은 정말 엄청 강력한 것 같습니다. 언어의 기능을 확장하고 meta programming 을 하는데 매우 수월한 것 같습니다. C++ 에서도 compile-time meta programming 은 매우 인기있는(?) 주제인데요. C++을 주로 했던 사람 입장에서 Rust 의 &lt;code&gt;Procedural Macros&lt;/code&gt; 는 그냥 일반 Rust 코드가 compile time 에 실행된다는 게 매우 충격적(?) 이고 부러웠습니다…ㅎㅎ&lt;br /&gt;아, 그리고 이번 포스팅을 하면서 제가 처음으로 20줄이상의 Rust 코드를 짜봤는데요… Rust 문법도 안 익숙한 상태에서 바로 매크로를 만들어보려니까 다소 힘들었었네요;; ㅎㅎ 아무튼 저의 러스트 hello world 코드라서 뭔가 이상한 부분이 있을 수도 있는데 양해부탁드립니다… (댓글로 잘못된 점을 지적해주시면 더더욱 감사하겠습니다!)&lt;br /&gt;앞으로 Rust 열심히 공부할께요…!&lt;br /&gt;&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/reference/procedural-macros.html&quot;&gt;https://doc.rust-lang.org/reference/procedural-macros.html&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html&quot;&gt;https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/54727&quot;&gt;https://github.com/rust-lang/rust/issues/54727&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://words.steveklabnik.com/an-overview-of-macros-in-rust&quot;&gt;https://words.steveklabnik.com/an-overview-of-macros-in-rust&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://tinkering.xyz/introduction-to-proc-macros/&quot;&gt;https://tinkering.xyz/introduction-to-proc-macros/&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Manishearth/rust-adorn&quot;&gt;https://github.com/Manishearth/rust-adorn&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/elichai/log-derive&quot;&gt;https://github.com/elichai/log-derive&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;이 포스팅은 &lt;a href=&quot;https://infossm.github.io/blog/2019/02/10/rust-procedural-macros-by-example/&quot;&gt;삼성 소프트웨어 멤버십 기술 블로그에 동시에 포스팅&lt;/a&gt;됩니다.&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/5358137638365974876/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2019/02/rust-procedural-macros-by-example.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/5358137638365974876'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/5358137638365974876'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2019/02/rust-procedural-macros-by-example.html' title='Rust Procedural Macros By Example'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-7749233622739518672</id><published>2019-02-09T23:46:00.001+09:00</published><updated>2019-02-11T19:49:42.146+09:00</updated><title type='text'>C++ Boost 라이브러리를 Windows XP 에서 동작하도록 빌드하기</title><content type='html'>&lt;link href=&quot;https://stackedit.io/style.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/link&gt; &lt;div class=&quot;stackedit&quot;&gt;안녕하세요~ 반갑습니다!&lt;br /&gt;C++ 개발자 여러분~ boost 많이 쓰시죠?? 저도 boost 참 좋아합니다 ㅎㅎ&lt;br /&gt;이렇게 좋은 boost 를 Windows XP/2003 환경에서 사용할 때는 그냥 일반적인 방법으로는 사용이 불가능한데요. 그래서 오늘은 Windows XP 환경에서 동작하도록 boost 를 빌드하는 방법에 대해서 알아보도록 하겠습니다!&lt;br /&gt;&lt;strong&gt;참고로 제가 설명할 방법은 100% 완벽하게 검증된 방법은 아니며, 제가 조사/연구를 통해 알아낸 방법입니다. 따라서 문제가 있을 수도 있으므로 참고자료정도로만 사용해주시면 감사하겠습니다. 그리고 이 포스팅에서는 Visual C++ 2015 Update 3 를 사용한다고 가정하고 설명하겠습니다. 또한, 이 포스팅에서 말하는 Windows XP 는 정확히 말하면 XP Service Pack 3 를 뜻합니다.&lt;/strong&gt;&lt;br /&gt;&lt;h1 id=&quot;단계-사용하려는-라이브러리가-xp-를-지원하는-지-확인한다.&quot;&gt;1단계) 사용하려는 라이브러리가 XP 를 지원하는 지 확인한다.&lt;/h1&gt;일단 첫 번째 단계는 사용하려는 라이브러리가 Windows XP 를 지원하는 지 확인하는 과정입니다. 다행히도 Boost 의 대부분 라이브러리는 XP 환경에서 잘 돌아갈텐데, 경우에 따라서 XP에서는 기능이 제한되거나 오동작을 일으킬 수 도 있으니, 라이브러리가 XP 를 지원하는 지 여부를 검토할 필요성이 있습니다.&lt;br /&gt;근데 아쉽게도 라이브러리들이 XP 를 지원하는 지 여부가 명백하게 정리된 글같은 건 없어 보입니다 ㅜㅜ 그리고, 각 라이브러리의 레퍼런스를 봐도 잘 안나오는 경우가 많죠. 결국, 부스트 커뮤니티 혹은 스택오버플로우의 글들을 뒤지거나 직접 질문을 해서 도움을 얻어야 합니다. 그리고 직접 라이브러리 내부 소스코드를 까서 XP 지원 여부를 파악해야 할 수도 있습니다. 그리고, 무엇보다 실제로 라이브러리를 사용하는 프로그램을 XP에서 동작시켜서 잘 동작하는지 직접 확인하는 과정도 꼭 필요합니다.&lt;br /&gt;&lt;a href=&quot;https://groups.google.com/forum/#!topic/boost-developers-archive/BH-unGadG7E&quot;&gt;이 글&lt;/a&gt;은 2015년도에 부스트 커뮤니티에 올라왔던 Windows XP 지원 관련 설문인데 한번 읽어보셔도 좋을 것 같습니다.&lt;br /&gt;&lt;h2 id=&quot;xp-호환-여부를-파악할-때-신경쓸-점&quot;&gt;XP 호환 여부를 파악할 때 신경쓸 점&lt;/h2&gt;그러면 이제 부터 XP 지원 여부를 파악할 때 신경쓸 점들에 대해 알아보겠습니다.&lt;br /&gt;&lt;ol&gt;&lt;li&gt;XP 에서 지원하는 windows API 만을 사용해야만 합니다.&lt;/li&gt;&lt;li&gt;암시적 TLS 사용 금지 &lt;ul&gt;&lt;li&gt;XP 에서는 암시적 TLS에 관련된 known bug 가 있습니다. 따라서, 암시적 TLS 에 관련된 기능을 사용하면 안되고, &lt;code&gt;__declspec(thread)&lt;/code&gt;, C++11 &lt;code&gt;thread_local&lt;/code&gt; 또한 사용하면 안됩니다.&lt;/li&gt;&lt;li&gt;좀 더 자세한 내용을 알고 싶으신 분은 &lt;a href=&quot;http://www.nynaeve.net/?p=187&quot;&gt;이 글&lt;/a&gt;을 참고하시면 좋을 것 같습니다.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;C++11 Magic Statics 에 의존하면 안됩니다. &lt;ul&gt;&lt;li&gt;VC++2015 의 Magic Statics 구현은 내부적으로 암시적 TLS 를 사용합니다. 따라서, Magic Statics 에 의존하는 코드가 존재해서는 안됩니다.&lt;/li&gt;&lt;li&gt;좀 더 자세한 내용을 알고 싶으신 분은 &lt;a href=&quot;http://www.jiniya.net/ng/2016/11/magic-statics/&quot;&gt;이 글&lt;/a&gt;을 읽어보시는 걸 추천드립니다.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;std::shared_mutex&lt;/code&gt; 를 사용하면 안됩니다. &lt;ul&gt;&lt;li&gt;VC++2015 표준라이브러리의 &lt;code&gt;std::shared_mutex&lt;/code&gt; 구현은 &lt;code&gt;SRWLOCK&lt;/code&gt; 에 관련된 WinAPI 를 사용합니다. 근데, &lt;code&gt;SRWLOCK&lt;/code&gt; 관련 WinAPI 는 Vista 이상에서 추가되었습니다. 따라서, XP 에서는 &lt;code&gt;std::shared_mutex&lt;/code&gt; 가 동작할 수 가 없습니다. 관련된 내용은 &lt;a href=&quot;https://blogs.msdn.microsoft.com/vcblog/2016/01/22/vs-2015-update-2s-stl-is-c17-so-far-feature-complete/&quot;&gt;이 글&lt;/a&gt;을 참고하면 좋을 것 같습니다.&lt;/li&gt;&lt;li&gt;뒤쪽에서 다룰 내용인데, 라이브러리를 빌드할 때, &lt;code&gt;_USING_V110_SDK71_&lt;/code&gt; 매크로를 정의하게 됩니다.  이 매크로를 정의하면 C++ 표준라이브러리에서 &lt;code&gt;std::shared_mutex&lt;/code&gt; 가 애초에 정의되지 않습니다.&lt;br /&gt;&lt;img alt=&quot;&quot; src=&quot;https://lh3.googleusercontent.com/RrmzRNYZE3lYKGh58y9oSnTzCwYl5eBdjut9ECyTuw0Rqfj6Nfd4mOOeLlj6fHF1dykcOzgUoG_H&quot; /&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 id=&quot;단계-boost-가-xp-를-지원하도록-빌드하자.&quot;&gt;2단계) Boost 가 XP 를 지원하도록 빌드하자.&lt;/h1&gt;일단, 이 포스팅에서는 빌드를 할 때 VC++2015 Update 3 를 사용할 것이므로, 이 것을 기반으로 설명을 드리도록 하겠습니다. 또한 기본적인 Boost 빌드 방법을 알고있다는 가정하에 설명을 진행하겠습니다.&lt;br /&gt;VC++2015 Update 3 에서는 플랫폼 도구 집합으로 &lt;code&gt;v140&lt;/code&gt; (default), &lt;code&gt;v140_xp&lt;/code&gt; 가 있습니다. XP 를 지원하는 소프트웨어를 개발할 때는 &lt;code&gt;v140_xp&lt;/code&gt; 를 사용해야만 합니다.&lt;br /&gt;&lt;img alt=&quot;&quot; src=&quot;https://lh3.googleusercontent.com/ibHxdEY1f_yboHWhN2lRPfyHLecoj1jJa8qgOYUodvfJaiTNF-qPnBMkAZM3gkqJpBpJ8ruO_EWN&quot; /&gt;&lt;br /&gt;Boost 를 빌드할 때는 &lt;code&gt;b2.exe&lt;/code&gt; 를 사용하여 빌드를 수행하게 되는데 이때 toolset 으로 비주얼스튜디오의 버전을 넣어주게 됩니다. 예를 들어, VC++2015 의 경우 &lt;code&gt;b2.exe --toolset=msvc-14.0 ...&lt;/code&gt; 와 같은 식이 되는데, 문제는 이것은 비주얼 스튜디오에서의 플랫폼 도구 집합으로 치면 &lt;code&gt;v140&lt;/code&gt; 을 의미하고, &lt;code&gt;v140_xp&lt;/code&gt; 를 의미하도록 명시하는 방법이 &lt;code&gt;b2.exe&lt;/code&gt; 에는 없다는 것입니다.&lt;br /&gt;따라서, &lt;code&gt;v140&lt;/code&gt; 과 &lt;code&gt;v140_xp&lt;/code&gt; 의 차이점을 일일히 알고서 &lt;code&gt;b2.exe&lt;/code&gt; 의 다른 파라미터를 통해서 그 차이점을 적용시켜야만 합니다. &lt;code&gt;v140&lt;/code&gt; 과 &lt;code&gt;v140_xp&lt;/code&gt; 의 차이점에 대해서는 &lt;a href=&quot;https://taeguk2.blogspot.com/2018/02/vc2015-vc140xp.html&quot;&gt;제가 과거에 작성했던 글&lt;/a&gt;을 참고하시길 바랍니다.&lt;br /&gt;또한, Boost 가 XP 를 지원하도록 빌드하기 위해서는 여러가지 매크로들과 C++ Flag 를 설정해야만 합니다. 이제부터 그 매크로와 C++ Flag 를 하나씩 알아보겠습니다.&lt;br /&gt;&lt;h2 id=&quot;win32_winnt0x0501-_ntddi_version0x05010300-매크로-정의&quot;&gt;&lt;code&gt;_WIN32_WINNT=0X0501&lt;/code&gt;, &lt;code&gt;_NTDDI_VERSION=0X05010300&lt;/code&gt; 매크로 정의&lt;/h2&gt;Windows 헤더 파일 (&lt;code&gt;windows.h&lt;/code&gt; 등) 은 내부적으로 타겟 윈도우 버전을 의미하는 &lt;code&gt;_WIN32_WINNT&lt;/code&gt;, &lt;code&gt;_NTDDI_VERSION&lt;/code&gt; 등 매크로들의 값을 바탕으로 조건부 선언을 하고있습니다.  예를 들면, Vista 에서 추가된 &lt;code&gt;InitializeSRWLock&lt;/code&gt; WinAPI 의 경우 &lt;code&gt;_WIN32_WINNT &amp;gt;= 0x0600&lt;/code&gt; 일 경우에만 선언되도록 되어있습니다.&lt;br /&gt;&lt;img alt=&quot;&quot; src=&quot;https://lh3.googleusercontent.com/OhVouh-aBX66YTaXBNBeNkef2J_RsICZdtwBXzGKCvkgeUDdTaRdBdyfpTOP1SYY7z8w6h1EOknh&quot; /&gt;&lt;br /&gt;타겟 윈도우 버전을 의미하는 매크로들이 어떤 게 있고 어떤 값들이 가능한 지는 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/winprog/using-the-windows-headers#macros-for-conditional-declarations&quot;&gt;이 링크&lt;/a&gt;를 보면 잘 나와있습니다.&lt;br /&gt;우리는 XP SP3 를 타겟으로 해야하므로, &lt;code&gt;_WIN32_WINNT&lt;/code&gt; 는 0x0501, &lt;code&gt;_NTDDI_VERSION&lt;/code&gt; 는 0x05010300 으로 정의해야합니다.&lt;br /&gt;&lt;h2 id=&quot;boost_use_winapi_version0x0501-boost_use_ntddi_version0x05010300-매크로-정의&quot;&gt;&lt;code&gt;BOOST_USE_WINAPI_VERSION=0X0501&lt;/code&gt;, &lt;code&gt;BOOST_USE_NTDDI_VERSION=0X05010300&lt;/code&gt; 매크로 정의&lt;/h2&gt;이 두 매크로가 어떤 역할을 하는 지에 대해서는 &lt;a href=&quot;https://www.boost.org/doc/libs/1_69_0/libs/winapi/doc/html/winapi/config.html&quot;&gt;이 링크&lt;/a&gt;를 참고하시길 바랍니다. 이 링크에 설명된 내용에 따르면, &lt;code&gt;BOOST_USE_WINAPI_VERSION&lt;/code&gt;, &lt;code&gt;BOOST_USE_NTDDI_VERSION&lt;/code&gt; 가 정의되어 있지 않으면 기본적으로 &lt;code&gt;_WIN32_WINNT&lt;/code&gt;, &lt;code&gt;_NTDDI_VERSION&lt;/code&gt; 의 값을 따라간다고 되어있긴합니다. 하지만 저는 그냥 명시적으로 정의를 해주었습니다.&lt;br /&gt;&lt;h2 id=&quot;boost_no_cxx11_thread_local-매크로-정의&quot;&gt;&lt;code&gt;BOOST_NO_CXX11_THREAD_LOCAL&lt;/code&gt; 매크로 정의&lt;/h2&gt;포스팅의 1단계에서 말했듯이 XP 에서는 C++11 thread_local 키워드를 사용하면 안되므로, thread_local 키워드를 쓰는걸 막기위해 이 매크로를 정의하였습니다.&lt;br /&gt;&lt;h2 id=&quot;using_v110_sdk71-매크로-정의&quot;&gt;&lt;code&gt;USING_V110_SDK71&lt;/code&gt; 매크로 정의&lt;/h2&gt;플랫폼 도구 집합 &lt;code&gt;v140&lt;/code&gt; 과 &lt;code&gt;v140_xp&lt;/code&gt; 의 차이점들중에 하나가 이 매크로의 유무입니다. &lt;code&gt;v140_xp&lt;/code&gt; 에서 이 매크로가 정의되므로 똑같이 정의해주도록 합니다.&lt;br /&gt;&lt;h2 id=&quot;zcthreadsafeinit--컴파일-플래그-설정&quot;&gt;&lt;code&gt;/Zc:threadSafeInit-&lt;/code&gt; 컴파일 플래그 설정&lt;/h2&gt;포스팅의 1단계에서 말했듯이 VC++2015 의 Magic Statics 구현은 XP 환경에서 문제가 있습니다. 따라서 Magic Statics 기능을 disable 해야만 하는데, &lt;code&gt;/Zc:threadSafeInit-&lt;/code&gt; 플래그가 그러한 역할을 수행합니다.&lt;br /&gt;&lt;hr /&gt;그러면, 이제부터 XP 를 지원하도록 Boost.FileSystem 를 빌드해보도록 하겠습니다. (부스트 1.69.0 기준으로 테스트되었습니다.)&lt;br /&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.boost.org/users/download/&quot;&gt;부스트 소스코드&lt;/a&gt;를 다운받아서 로컬에 압축을 풉니다.&lt;/li&gt;&lt;li&gt;&lt;code&gt;bootstrap.bat&lt;/code&gt; 을 실행시킵니다. 이러면 &lt;code&gt;b2.exe&lt;/code&gt; 가 생성됩니다.&lt;/li&gt;&lt;li&gt;아래 명령어를 통해 빌드를 수행하면 됩니다.&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;bit--64bit-빌드-시-공통으로-먼저-수행해야하는-명령어&quot;&gt;32bit / 64bit 빌드 시, 공통으로 먼저 수행해야하는 명령어&lt;/h2&gt;&lt;pre class=&quot; language-batch&quot;&gt;&lt;code class=&quot;prism  language-batch&quot;&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;ORG_PATH&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;%PATH%&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;INCLUDE&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;C:\Program Files &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Microsoft Visual Studio 14.0\VC\include;^&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;token label property&quot;&gt;:\Program&lt;/span&gt; Files (x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Microsoft Visual Studio 14.0\VC\atlmfc\include;^&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;token label property&quot;&gt;:\Program&lt;/span&gt; Files (x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Windows Kits\10\Include\10.0.10240.0\ucrt;^&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;token label property&quot;&gt;:\Program&lt;/span&gt; Files (x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Microsoft SDKs\Windows\v7.1A\include&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;BUILD_CMD_COMMON&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;b2 &lt;span class=&quot;token parameter attr-name&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;j4 &lt;span class=&quot;token parameter attr-name&quot;&gt;--stagedir&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;.&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;stage&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;boost&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;xp &lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token parameter attr-name&quot;&gt;--with-filesystem&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token parameter attr-name&quot;&gt;--reconfigure&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token variable&quot;&gt;toolset&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;msvc&lt;span class=&quot;token number&quot;&gt;-14&lt;/span&gt;.&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;variant&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;debug&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;release &lt;span class=&quot;token variable&quot;&gt;threading&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;multi runtime&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;link&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;static&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;shared &lt;span class=&quot;token variable&quot;&gt;link&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;static&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;shared &lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token variable&quot;&gt;define&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;_WIN32_WINNT=0x0501&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token variable&quot;&gt;define&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;NTDDI_VERSION=0x05010300&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token variable&quot;&gt;define&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;BOOST_USE_WINAPI_VERSION=0x0501&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token variable&quot;&gt;define&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;BOOST_USE_NTDDI_VERSION=0x05010300&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token variable&quot;&gt;define&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;BOOST_NO_CXX11_THREAD_LOCAL&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token variable&quot;&gt;define&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;USING_V110_SDK71&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token variable&quot;&gt;cxxflags&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/Zc:threadSafeInit- &quot;&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;bit-빌드-시-수행해야-하는-명령어&quot;&gt;32bit 빌드 시 수행해야 하는 명령어&lt;/h2&gt;&lt;pre class=&quot; language-batch&quot;&gt;&lt;code class=&quot;prism  language-batch&quot;&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;C:\Program Files &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Microsoft SDKs\Windows\v7.1A\bin;^&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;token label property&quot;&gt;:\Program&lt;/span&gt; Files (x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Microsoft Visual Studio 14.0\VC\bin;^&lt;br /&gt;%ORG_PATH%&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;LIBPATH&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;C:\Program Files &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Microsoft Visual Studio 14.0\VC\atlmfc\lib;^&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;token label property&quot;&gt;:\Program&lt;/span&gt; Files (x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Microsoft Visual Studio 14.0\VC\lib&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;LIB&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;C:\Program Files &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Microsoft Visual Studio 14.0\VC\lib;^&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;token label property&quot;&gt;:\Program&lt;/span&gt; Files (x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Microsoft Visual Studio 14.0\VC\atlmfc\lib;^&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;token label property&quot;&gt;:\Program&lt;/span&gt; Files (x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Windows Kits\10\lib\10.0.10240.0\ucrt\x86;^&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;token label property&quot;&gt;:\Program&lt;/span&gt; Files (x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Microsoft SDKs\Windows\v7.1A\lib&lt;br /&gt;&lt;br /&gt;%BUILD_CMD_COMMON% ^&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;address&lt;/span&gt;-model=&lt;span class=&quot;token number&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;linkflags=&lt;span class=&quot;token string&quot;&gt;&quot;/SUBSYSTEM:WINDOWS,5.01&quot;&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;bit-빌드-시-수행해야-하는-명령어-1&quot;&gt;64bit 빌드 시 수행해야 하는 명령어&lt;/h2&gt;&lt;pre class=&quot; language-batch&quot;&gt;&lt;code class=&quot;prism  language-batch&quot;&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;C:\Program Files &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Microsoft SDKs\Windows\v7.1A\bin;^&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;token label property&quot;&gt;:\Program&lt;/span&gt; Files (x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Microsoft Visual Studio 14.0\VC\bin\x86_amd64;^&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;token label property&quot;&gt;:\Program&lt;/span&gt; Files (x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Microsoft Visual Studio 14.0\VC\bin;^&lt;br /&gt;%ORG_PATH%&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;LIBPATH&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;C:\Program Files &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Microsoft Visual Studio 14.0\VC\atlmfc\lib\amd64;^&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;token label property&quot;&gt;:\Program&lt;/span&gt; Files (x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Microsoft Visual Studio 14.0\VC\lib\amd64&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;LIB&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;C:\Program Files &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Microsoft Visual Studio 14.0\VC\lib\amd64;^&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;token label property&quot;&gt;:\Program&lt;/span&gt; Files (x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Microsoft Visual Studio 14.0\VC\atlmfc\lib\amd64;^&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;token label property&quot;&gt;:\Program&lt;/span&gt; Files (x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Windows Kits\10\lib\10.0.10240.0\ucrt\x64;^&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;token label property&quot;&gt;:\Program&lt;/span&gt; Files (x86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;\Microsoft SDKs\Windows\v7.1A\lib\x64&lt;br /&gt;&lt;br /&gt;%BUILD_CMD_COMMON% ^&lt;br /&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;address&lt;/span&gt;-model=&lt;span class=&quot;token number&quot;&gt;64&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;^&lt;/span&gt;&lt;br /&gt;linkflags=&lt;span class=&quot;token string&quot;&gt;&quot;/SUBSYSTEM:WINDOWS,5.02&quot;&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;마무으리&quot;&gt;마무으리&lt;/h1&gt;Boost 를 XP 에서 사용하려면 상당히 까다롭죠?? ㅠㅠ 저도 작년 초에 XP 환경에서 boost 를 사용해야하는 상황에 처해서 많이 삽질을 했던 기억이 납니다. 이 포스팅은 그러한 저의 삽질/연구를 바탕으로 한 포스팅인데요. 완벽하게 검증된 방법은 아닙니다. (여러분이 보기에도 뭔가 꼼수같은 느낌이 많이 들죠??)&lt;br /&gt;따라서 이 방법대로만 하면 XP 환경에서 아무런 문제없이 boost 를 사용할 수 있다! 라고 제가 말씀드리기는 어려울 것 같고, 참고정도는 가능하지 않을까 싶습니다.&lt;br /&gt;잘못된 점 혹은 개선할 점 혹은 더 좋은 방법이 설명되어있는 자료링크 같은 것은 언제나 환영입니다!&lt;br /&gt;지금까지 읽어주셔서 감사합니다~ &lt;br /&gt;&lt;hr /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;이 포스팅은 &lt;a href=&quot;https://infossm.github.io/blog/2019/01/09/how-to-build-boost-for-windows-xp/&quot;&gt;삼성 소프트웨어 멤버십 기술 블로그에 동시에 포스팅&lt;/a&gt;됩니다.&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/7749233622739518672/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2019/02/c-boost-windows-xp_69.html#comment-form' title='1개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/7749233622739518672'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/7749233622739518672'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2019/02/c-boost-windows-xp_69.html' title='C++ Boost 라이브러리를 Windows XP 에서 동작하도록 빌드하기'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-3616178277119450557</id><published>2019-01-12T19:07:00.000+09:00</published><updated>2019-01-12T19:21:38.429+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="삿포로"/><category scheme="http://www.blogger.com/atom/ns#" term="여행"/><category scheme="http://www.blogger.com/atom/ns#" term="오타루"/><category scheme="http://www.blogger.com/atom/ns#" term="일본여행"/><title type='text'>일본 삿포로 여행 (1/2 ~ 1/6) </title><content type='html'>&lt;div style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;background-color: white; color: #201f20; font-family: &amp;quot;roboto&amp;quot; , sans-serif; font-size: 15px;&quot;&gt;2019년이 시작되자마자, 1/2 (수) ~ 1/6 (일) 4박 5일 간 일본 삿포로 지역으로 여행을 갔다왔다.&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;background-color: white; color: #201f20; font-family: &amp;quot;roboto&amp;quot; , sans-serif; font-size: 15px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-P84V6CkHq1I/XDmkiuYeuVI/AAAAAAAAAYw/u7S1Hj8L6H0JigziaY1SehIHL3aVp5vcgCLcBGAs/s1600/KakaoTalk_20190112_172519151.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1600&quot; data-original-width=&quot;1200&quot; height=&quot;640&quot; src=&quot;https://1.bp.blogspot.com/-P84V6CkHq1I/XDmkiuYeuVI/AAAAAAAAAYw/u7S1Hj8L6H0JigziaY1SehIHL3aVp5vcgCLcBGAs/s640/KakaoTalk_20190112_172519151.jpg&quot; width=&quot;480&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;삿포로가는 비행기 안, 구름이 예쁘다~&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://2.bp.blogspot.com/-6UA1oPJy2FI/XDmkMVN87TI/AAAAAAAAAYY/C4REyd691PguGiuGelRiQbpzrKvImDuRACLcBGAs/s1600/KakaoTalk_20190112_172245533.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;960&quot; data-original-width=&quot;960&quot; height=&quot;640&quot; src=&quot;https://2.bp.blogspot.com/-6UA1oPJy2FI/XDmkMVN87TI/AAAAAAAAAYY/C4REyd691PguGiuGelRiQbpzrKvImDuRACLcBGAs/s640/KakaoTalk_20190112_172245533.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;삿포로 신치토세 공항에 도착해서 먹은 부타동~ 사진보니 군침나오네..&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-eJONm8tKgOM/XDmkLDbLIpI/AAAAAAAAAYU/mOzTKK9u2sM7I40GMT0-ilEy9hjjMMGLACLcBGAs/s1600/KakaoTalk_20190112_172243976.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://3.bp.blogspot.com/-eJONm8tKgOM/XDmkLDbLIpI/AAAAAAAAAYU/mOzTKK9u2sM7I40GMT0-ilEy9hjjMMGLACLcBGAs/s640/KakaoTalk_20190112_172243976.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;여긴 삿포로역! 예쁘다!&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-nAdfpXevmcM/XDmkLI7rlPI/AAAAAAAAAYQ/_DCztO380boY9vUPv3quEpDW3OMQf2qOQCLcBGAs/s1600/KakaoTalk_20190112_172244620.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://4.bp.blogspot.com/-nAdfpXevmcM/XDmkLI7rlPI/AAAAAAAAAYQ/_DCztO380boY9vUPv3quEpDW3OMQf2qOQCLcBGAs/s640/KakaoTalk_20190112_172244620.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;숙소에 짐을 풀고 간 곳은, 스프카레 집! 이거 먹으려고 줄 진짜 오래 기다렸다,,&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-UAOTL9BFRmA/XDmkMVtN3wI/AAAAAAAAAYc/1XUFEiH7YKcTsL1HDeO2ZUPAUohAHM_uACLcBGAs/s1600/KakaoTalk_20190112_172245360.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://3.bp.blogspot.com/-UAOTL9BFRmA/XDmkMVtN3wI/AAAAAAAAAYc/1XUFEiH7YKcTsL1HDeO2ZUPAUohAHM_uACLcBGAs/s640/KakaoTalk_20190112_172245360.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;하지만, 줄 선 보람이 있어.. 너무 맛있다! 감동 ㅠㅠ&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-MzocHV4I-Dk/XDm40e1-vfI/AAAAAAAAAdI/y2R2Vm_nU5MmLGw761kEx3dkCsn3QmC4gCLcBGAs/s1600/KakaoTalk_20190112_184605964.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;720&quot; data-original-width=&quot;1280&quot; height=&quot;360&quot; src=&quot;https://1.bp.blogspot.com/-MzocHV4I-Dk/XDm40e1-vfI/AAAAAAAAAdI/y2R2Vm_nU5MmLGw761kEx3dkCsn3QmC4gCLcBGAs/s640/KakaoTalk_20190112_184605964.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;밤에는 숙소에서 닌텐도 저스트 댄스와 함께 광란의 댄스파티 ㅋㅋㅋ&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-Tpd5_vpwtIY/XDmsa1jwe2I/AAAAAAAAAZI/s4AH4jkOg_kNCdBiuJryHN_M-I4Wv2laACLcBGAs/s1600/KakaoTalk_20190112_174919641_01.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://1.bp.blogspot.com/-Tpd5_vpwtIY/XDmsa1jwe2I/AAAAAAAAAZI/s4AH4jkOg_kNCdBiuJryHN_M-I4Wv2laACLcBGAs/s640/KakaoTalk_20190112_174919641_01.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;&quot; style=&quot;clear: both; text-align: center;&quot;&gt;이틀 째에는 지하철을 타고 오타루로 갔다~&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-ajAEFHw4xxA/XDm9UjbvU4I/AAAAAAAAAdg/iDS8qkNas20xZcxVzE90FRhl8ZdVUgoiACLcBGAs/s1600/KakaoTalk_20190112_191058811.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://1.bp.blogspot.com/-ajAEFHw4xxA/XDm9UjbvU4I/AAAAAAAAAdg/iDS8qkNas20xZcxVzE90FRhl8ZdVUgoiACLcBGAs/s640/KakaoTalk_20190112_191058811.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;지하철 안에서 보이는 바깥 풍경&lt;/div&gt;&lt;div class=&quot;&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-K9XKtogA9M0/XDmsedacMuI/AAAAAAAAAZo/9undNcdL62AzcvGD6rsAFUUmz8k1c1s8QCLcBGAs/s1600/KakaoTalk_20190112_174919641_08.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1600&quot; data-original-width=&quot;1200&quot; height=&quot;640&quot; src=&quot;https://3.bp.blogspot.com/-K9XKtogA9M0/XDmsedacMuI/AAAAAAAAAZo/9undNcdL62AzcvGD6rsAFUUmz8k1c1s8QCLcBGAs/s640/KakaoTalk_20190112_174919641_08.jpg&quot; width=&quot;480&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;오타루에 도착하니 눈이 이렇게 많이 쌓여있다&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://2.bp.blogspot.com/-2Xps0Es5-nU/XDmtffKJmSI/AAAAAAAAAaM/KNIgAqxC6CIJlQxjuBdwYDzrVfxnPV99gCLcBGAs/s1600/KakaoTalk_20190112_180335731.gif&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;496&quot; data-original-width=&quot;368&quot; height=&quot;400&quot; src=&quot;https://2.bp.blogspot.com/-2Xps0Es5-nU/XDmtffKJmSI/AAAAAAAAAaM/KNIgAqxC6CIJlQxjuBdwYDzrVfxnPV99gCLcBGAs/s400/KakaoTalk_20190112_180335731.gif&quot; width=&quot;296&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;길가에 오르골 소리가 은은하게 울려퍼져서 너무 좋았다~&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-tX1qdyHKusU/XDmsbFpEh_I/AAAAAAAAAZQ/JQnXlCc4gDoLSR7DS0ZAtLwG_zomd5ArACLcBGAs/s1600/KakaoTalk_20190112_174919641_02.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1600&quot; data-original-width=&quot;1200&quot; height=&quot;400&quot; src=&quot;https://3.bp.blogspot.com/-tX1qdyHKusU/XDmsbFpEh_I/AAAAAAAAAZQ/JQnXlCc4gDoLSR7DS0ZAtLwG_zomd5ArACLcBGAs/s400/KakaoTalk_20190112_174919641_02.jpg&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;늦은 점심을 먹으러 초밥집에 들어왔다. 녹차가 따뜻해서 몸이 풀린다&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-GaenwWxEscM/XDmse5sPiUI/AAAAAAAAAZs/BzSBl1upMhoXdvEcdrGFhbIDi8_ijqPkACLcBGAs/s1600/KakaoTalk_20190112_174919641_10.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1600&quot; data-original-width=&quot;1600&quot; height=&quot;400&quot; src=&quot;https://3.bp.blogspot.com/-GaenwWxEscM/XDmse5sPiUI/AAAAAAAAAZs/BzSBl1upMhoXdvEcdrGFhbIDi8_ijqPkACLcBGAs/s400/KakaoTalk_20190112_174919641_10.jpg&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;&quot; style=&quot;clear: both; text-align: center;&quot;&gt;이름이 뭐였드라... 아무튼 고오급 회 도시락이였다&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-sarG9fF1pfQ/XDmsbH6FHlI/AAAAAAAAAZM/UP3euX_yGXs0cEqv-u-pkAhNYrBc_M63wCLcBGAs/s1600/KakaoTalk_20190112_174919641_03.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://4.bp.blogspot.com/-sarG9fF1pfQ/XDmsbH6FHlI/AAAAAAAAAZM/UP3euX_yGXs0cEqv-u-pkAhNYrBc_M63wCLcBGAs/s640/KakaoTalk_20190112_174919641_03.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;&quot; style=&quot;clear: both; text-align: center;&quot;&gt;여긴 오타루 운하~&lt;/div&gt;&lt;div class=&quot;&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-fA_IaL9Owq0/XDmseARufzI/AAAAAAAAAZk/fUWQqOtsAOYRl1H1i40gUJbVaoJby9rKQCLcBGAs/s1600/KakaoTalk_20190112_174919641_09.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://1.bp.blogspot.com/-fA_IaL9Owq0/XDmseARufzI/AAAAAAAAAZk/fUWQqOtsAOYRl1H1i40gUJbVaoJby9rKQCLcBGAs/s640/KakaoTalk_20190112_174919641_09.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;다섯명이서 토끼모자쓰고 돌아다녔다~ 시선강탈 ㅋㅋㅋㅋㅋ&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-oHptRR_tOqU/XDmscRYb51I/AAAAAAAAAZU/cZIVT3gvnEcfpl4ujyNTsomVqqhoXkKTACLcBGAs/s1600/KakaoTalk_20190112_174919641_04.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1600&quot; data-original-width=&quot;1200&quot; height=&quot;320&quot; src=&quot;https://3.bp.blogspot.com/-oHptRR_tOqU/XDmscRYb51I/AAAAAAAAAZU/cZIVT3gvnEcfpl4ujyNTsomVqqhoXkKTACLcBGAs/s320/KakaoTalk_20190112_174919641_04.jpg&quot; width=&quot;240&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;귀여운 눈 괴물(?)&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-ItJmKiF9FhA/XDmsfg88i3I/AAAAAAAAAZ0/blqvkVMUYtY6YFJ1Uxs4RyEPRQnn_ec2QCLcBGAs/s1600/KakaoTalk_20190112_174919641_12.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1600&quot; data-original-width=&quot;1200&quot; height=&quot;400&quot; src=&quot;https://3.bp.blogspot.com/-ItJmKiF9FhA/XDmsfg88i3I/AAAAAAAAAZ0/blqvkVMUYtY6YFJ1Uxs4RyEPRQnn_ec2QCLcBGAs/s400/KakaoTalk_20190112_174919641_12.jpg&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;귀여운 유리 공예품&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-tNjw0LFfYg8/XDmsc2yGFCI/AAAAAAAAAZY/fZdkDhDIp5AecQfs0_IqxE_YsDyLxKdngCLcBGAs/s1600/KakaoTalk_20190112_174919641_05.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://3.bp.blogspot.com/-tNjw0LFfYg8/XDmsc2yGFCI/AAAAAAAAAZY/fZdkDhDIp5AecQfs0_IqxE_YsDyLxKdngCLcBGAs/s640/KakaoTalk_20190112_174919641_05.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;여긴 오르골당~ 예쁘당~&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-Df7SrbViqTU/XDmsc8Xw4-I/AAAAAAAAAZc/gR1mi578zqoWMqioCs4NwdiMb_2EE3Q8wCLcBGAs/s1600/KakaoTalk_20190112_174919641_06.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://1.bp.blogspot.com/-Df7SrbViqTU/XDmsc8Xw4-I/AAAAAAAAAZc/gR1mi578zqoWMqioCs4NwdiMb_2EE3Q8wCLcBGAs/s640/KakaoTalk_20190112_174919641_06.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;오타루에서 삿포로로 돌아오는 길에 소엔온천을 들렸다~ 아 포근하니 너무 좋았다&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-JihT67jdcGM/XDmsdnObPlI/AAAAAAAAAZg/wPup_C6EWN8irhRshfLNg21H4khjA5jAgCLcBGAs/s1600/KakaoTalk_20190112_174919641_07.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1600&quot; data-original-width=&quot;1200&quot; height=&quot;640&quot; src=&quot;https://3.bp.blogspot.com/-JihT67jdcGM/XDmsdnObPlI/AAAAAAAAAZg/wPup_C6EWN8irhRshfLNg21H4khjA5jAgCLcBGAs/s640/KakaoTalk_20190112_174919641_07.jpg&quot; width=&quot;480&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;오도리공원에 있는 삿포로 TV 타워 앞에서 한 컷!&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-4MtoLY_QXeI/XDmwlP--0UI/AAAAAAAAAac/6bvZvtx4PhYPMieZTF2z0cP2lfWBHNBvwCLcBGAs/s1600/KakaoTalk_20190112_181624972_01.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://4.bp.blogspot.com/-4MtoLY_QXeI/XDmwlP--0UI/AAAAAAAAAac/6bvZvtx4PhYPMieZTF2z0cP2lfWBHNBvwCLcBGAs/s640/KakaoTalk_20190112_181624972_01.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;셋째 달은 아침 겸 점심으로 숙소 근처 라멘을 먹었다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;라멘 집 사장님들(?) 티셔츠에 &quot;No Ramen No Life&quot; 라고 적혀있었는데 너무 멋있었다.&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-WzcYhWtuPdA/XDmwk7aHUwI/AAAAAAAAAaY/3R4K2atrTDsGAlyq75otWuqTD1CmRRVfQCLcBGAs/s1600/KakaoTalk_20190112_181624972_02.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://3.bp.blogspot.com/-WzcYhWtuPdA/XDmwk7aHUwI/AAAAAAAAAaY/3R4K2atrTDsGAlyq75otWuqTD1CmRRVfQCLcBGAs/s640/KakaoTalk_20190112_181624972_02.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;삿포로 시내 구경~~&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-rWlkyEf-KKs/XDmwoH19iNI/AAAAAAAAAa4/e4PGewoNh5skFcB7oloZRgZ0g0Rtob5mgCLcBGAs/s1600/KakaoTalk_20190112_181624972_09.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1600&quot; data-original-width=&quot;1600&quot; height=&quot;320&quot; src=&quot;https://4.bp.blogspot.com/-rWlkyEf-KKs/XDmwoH19iNI/AAAAAAAAAa4/e4PGewoNh5skFcB7oloZRgZ0g0Rtob5mgCLcBGAs/s320/KakaoTalk_20190112_181624972_09.jpg&quot; width=&quot;320&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;맛있는 디저트&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-GM2JQgPvbJs/XDmwoVY3EZI/AAAAAAAAAa8/nc-qlrpYKeAhr3Puz6B9ruVVqBlH9tfZQCLcBGAs/s1600/KakaoTalk_20190112_181624972_10.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1600&quot; data-original-width=&quot;1200&quot; height=&quot;640&quot; src=&quot;https://1.bp.blogspot.com/-GM2JQgPvbJs/XDmwoVY3EZI/AAAAAAAAAa8/nc-qlrpYKeAhr3Puz6B9ruVVqBlH9tfZQCLcBGAs/s640/KakaoTalk_20190112_181624972_10.jpg&quot; width=&quot;480&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;어흥!&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-gzbpG7bRTzY/XDmwlI7_BwI/AAAAAAAAAag/eVc-EWCuw1E61kfBCmcDLLnjw9RwXLddgCLcBGAs/s1600/KakaoTalk_20190112_181624972_03.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://4.bp.blogspot.com/-gzbpG7bRTzY/XDmwlI7_BwI/AAAAAAAAAag/eVc-EWCuw1E61kfBCmcDLLnjw9RwXLddgCLcBGAs/s640/KakaoTalk_20190112_181624972_03.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;&quot; style=&quot;clear: both; text-align: center;&quot;&gt;삿포로 저녁 시내 모습&lt;/div&gt;&lt;div class=&quot;&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-IBTCg3FHrl0/XDmwmdSWuMI/AAAAAAAAAak/FR0TBpJMF5oFBAa2CzXJkuVd36j1UblugCLcBGAs/s1600/KakaoTalk_20190112_181624972_06.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1440&quot; data-original-width=&quot;1080&quot; height=&quot;400&quot; src=&quot;https://4.bp.blogspot.com/-IBTCg3FHrl0/XDmwmdSWuMI/AAAAAAAAAak/FR0TBpJMF5oFBAa2CzXJkuVd36j1UblugCLcBGAs/s400/KakaoTalk_20190112_181624972_06.jpg&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;NIKKA(?) 앞에서 한 컷!&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-zMXSVQV-hMM/XDmwmW23HMI/AAAAAAAAAas/jsmfOS7Kl9Ezir94LnPE4YkYxfgXVh22wCLcBGAs/s1600/KakaoTalk_20190112_181624972_05.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://3.bp.blogspot.com/-zMXSVQV-hMM/XDmwmW23HMI/AAAAAAAAAas/jsmfOS7Kl9Ezir94LnPE4YkYxfgXVh22wCLcBGAs/s640/KakaoTalk_20190112_181624972_05.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;징~ 징~ 징기스칸!!&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-O2Im_K_dlhQ/XDmzCL_EEYI/AAAAAAAAAbk/DhEdtIzfrvIlHBuoFU93pdf5Z3poOCFRACLcBGAs/s1600/KakaoTalk_20190112_182653982_01.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://3.bp.blogspot.com/-O2Im_K_dlhQ/XDmzCL_EEYI/AAAAAAAAAbk/DhEdtIzfrvIlHBuoFU93pdf5Z3poOCFRACLcBGAs/s640/KakaoTalk_20190112_182653982_01.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;넷째 날 아침. 호텔 밖에 눈보라가 엄청 휘날리고 있다&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-BShoOXih5IQ/XDmzE7_sVkI/AAAAAAAAAb0/NjTgTOgEnuAhictf2L_pNtzH7AQFzta9ACLcBGAs/s1600/KakaoTalk_20190112_182653982_07.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1600&quot; data-original-width=&quot;1600&quot; height=&quot;400&quot; src=&quot;https://3.bp.blogspot.com/-BShoOXih5IQ/XDmzE7_sVkI/AAAAAAAAAb0/NjTgTOgEnuAhictf2L_pNtzH7AQFzta9ACLcBGAs/s400/KakaoTalk_20190112_182653982_07.jpg&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;늦은 아침으로 다코야끼를 냠냠냠&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://2.bp.blogspot.com/-_Nd1M2g2YCE/XDmzCPkg4qI/AAAAAAAAAbc/Ik2phA66CQ8mItt5jlgYa-NTJnXXQdo2ACLcBGAs/s1600/KakaoTalk_20190112_182653982_02.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://2.bp.blogspot.com/-_Nd1M2g2YCE/XDmzCPkg4qI/AAAAAAAAAbc/Ik2phA66CQ8mItt5jlgYa-NTJnXXQdo2ACLcBGAs/s640/KakaoTalk_20190112_182653982_02.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;오늘 우리가 갈 곳은 조쟌케이 온천 마을!&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/--gfjpLzmWF0/XDmzCDHUs9I/AAAAAAAAAbg/WVSggdlFUdMqW9Pzp5a01pSyX5j7vKI7wCLcBGAs/s1600/KakaoTalk_20190112_182653982_03.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://1.bp.blogspot.com/--gfjpLzmWF0/XDmzCDHUs9I/AAAAAAAAAbg/WVSggdlFUdMqW9Pzp5a01pSyX5j7vKI7wCLcBGAs/s640/KakaoTalk_20190112_182653982_03.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;호헤이쿄 온천 앞 풍경&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-2GY2TBey7eI/XDmzD9MIxHI/AAAAAAAAAbs/vVQVJV_G398VsMnmD1-af1AFDgxAD6A_ACLcBGAs/s1600/KakaoTalk_20190112_182653982_06.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;300&quot; src=&quot;https://4.bp.blogspot.com/-2GY2TBey7eI/XDmzD9MIxHI/AAAAAAAAAbs/vVQVJV_G398VsMnmD1-af1AFDgxAD6A_ACLcBGAs/s400/KakaoTalk_20190112_182653982_06.jpg&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;온천에 들어가기전 한 컷!&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-NDcsSR7qNV0/XDmzDgJo4YI/AAAAAAAAAbo/4sAXu5xsaXYO_Wj3qe9lpVQL58L79_F9ACLcBGAs/s1600/KakaoTalk_20190112_182653982_04.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://3.bp.blogspot.com/-NDcsSR7qNV0/XDmzDgJo4YI/AAAAAAAAAbo/4sAXu5xsaXYO_Wj3qe9lpVQL58L79_F9ACLcBGAs/s640/KakaoTalk_20190112_182653982_04.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;온천은 너무 좋았다~&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;하늘에선 눈이 내려오고~ 옆에는 눈이 수북히 쌓여있고~ 몸은 뜨끈하고~&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;온천하면서 맥주도 같이 마셨는데 너무 좋았다 :)&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-9UbBgEeq9fM/XDm0WHt--WI/AAAAAAAAAcY/OJFwqUgRAaM1wnTkUpzxbS5KwW7gLWIkACLcBGAs/s1600/KakaoTalk_20190112_183056588.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;300&quot; src=&quot;https://3.bp.blogspot.com/-9UbBgEeq9fM/XDm0WHt--WI/AAAAAAAAAcY/OJFwqUgRAaM1wnTkUpzxbS5KwW7gLWIkACLcBGAs/s400/KakaoTalk_20190112_183056588.jpg&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;&quot; style=&quot;clear: both; text-align: center;&quot;&gt;온천 후에 인도카레를 냠냠냠&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-yg3LIxxtMlI/XDmzFQKXhCI/AAAAAAAAAb4/FDVLl-iKESgAX9dqCWr4hth87mHMCmO_wCLcBGAs/s1600/KakaoTalk_20190112_182653982_08.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1600&quot; data-original-width=&quot;1600&quot; height=&quot;320&quot; src=&quot;https://1.bp.blogspot.com/-yg3LIxxtMlI/XDmzFQKXhCI/AAAAAAAAAb4/FDVLl-iKESgAX9dqCWr4hth87mHMCmO_wCLcBGAs/s320/KakaoTalk_20190112_182653982_08.jpg&quot; width=&quot;320&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-yMrfnV-J5Z4/XDmzD-XGhkI/AAAAAAAAAbw/96Ycs_Q8C5gUrpWYY4irE_u-36qEJvajgCLcBGAs/s1600/KakaoTalk_20190112_182653982_05.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1600&quot; data-original-width=&quot;1200&quot; height=&quot;320&quot; src=&quot;https://1.bp.blogspot.com/-yMrfnV-J5Z4/XDmzD-XGhkI/AAAAAAAAAbw/96Ycs_Q8C5gUrpWYY4irE_u-36qEJvajgCLcBGAs/s320/KakaoTalk_20190112_182653982_05.jpg&quot; width=&quot;240&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;다시 삿포로로 돌아와서 저녁으로 오코노미야끼와 하이볼을 먹었다~&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-1fmRfsPzkyY/XDm4QTjLzdI/AAAAAAAAAco/RuU6amQiwtM6AlMbf2vlhoqU1w4Flrn6ACLcBGAs/s1600/KakaoTalk_20190112_184006701_02.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1600&quot; data-original-width=&quot;1200&quot; height=&quot;400&quot; src=&quot;https://3.bp.blogspot.com/-1fmRfsPzkyY/XDm4QTjLzdI/AAAAAAAAAco/RuU6amQiwtM6AlMbf2vlhoqU1w4Flrn6ACLcBGAs/s400/KakaoTalk_20190112_184006701_02.jpg&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;&quot; style=&quot;clear: both; text-align: center;&quot;&gt;여행 마지막 날. 삿포로 다이마루 백화점에 들렸다&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;위 사진은 C컵 푸딩&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-SlXUWakCASs/XDm4RfjHiRI/AAAAAAAAAc0/fTJLNuKiTVsl4TErW4NwSAacCE2O7yUFgCLcBGAs/s1600/KakaoTalk_20190112_184006701_05.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://4.bp.blogspot.com/-SlXUWakCASs/XDm4RfjHiRI/AAAAAAAAAc0/fTJLNuKiTVsl4TErW4NwSAacCE2O7yUFgCLcBGAs/s640/KakaoTalk_20190112_184006701_05.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;포켓몬 센터&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://2.bp.blogspot.com/-OmGoWKXChOQ/XDm4Qn8Sl9I/AAAAAAAAAcs/QUQysqePSWYVs6zDVS_kVjX-vGhKvU2DACLcBGAs/s1600/KakaoTalk_20190112_184006701_01.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;300&quot; src=&quot;https://2.bp.blogspot.com/-OmGoWKXChOQ/XDm4Qn8Sl9I/AAAAAAAAAcs/QUQysqePSWYVs6zDVS_kVjX-vGhKvU2DACLcBGAs/s400/KakaoTalk_20190112_184006701_01.jpg&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;&quot; style=&quot;clear: both; text-align: center;&quot;&gt;가지각색의 입욕제들~ 나도 하나 샀다&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://2.bp.blogspot.com/-vW2hGKpkX2g/XDm4QZY5qvI/AAAAAAAAAck/EP6KyJR4nt4xLmuo2yyQTXCa_8rsI6r7ACLcBGAs/s1600/KakaoTalk_20190112_184006701_03.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;960&quot; data-original-width=&quot;720&quot; height=&quot;400&quot; src=&quot;https://2.bp.blogspot.com/-vW2hGKpkX2g/XDm4QZY5qvI/AAAAAAAAAck/EP6KyJR4nt4xLmuo2yyQTXCa_8rsI6r7ACLcBGAs/s400/KakaoTalk_20190112_184006701_03.jpg&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;신치토세 공항으로 가는 지하철 안~ 4박 5일 간의 여행도 이렇게 끝나는구나&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://2.bp.blogspot.com/-wAMbBMPilxc/XDm6pdkpsII/AAAAAAAAAdU/-gmRl1cXN-U4LoXYjQ7_5IW9Bd5ksqhNACLcBGAs/s1600/KakaoTalk_20190112_185942673.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;960&quot; data-original-width=&quot;1280&quot; height=&quot;480&quot; src=&quot;https://2.bp.blogspot.com/-wAMbBMPilxc/XDm6pdkpsII/AAAAAAAAAdU/-gmRl1cXN-U4LoXYjQ7_5IW9Bd5ksqhNACLcBGAs/s640/KakaoTalk_20190112_185942673.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;인천공항으로 돌아와서 한 컷!&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;즐거운 여행이였다~&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/3616178277119450557/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2019/01/12-16.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/3616178277119450557'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/3616178277119450557'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2019/01/12-16.html' title='일본 삿포로 여행 (1/2 ~ 1/6) '/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://1.bp.blogspot.com/-P84V6CkHq1I/XDmkiuYeuVI/AAAAAAAAAYw/u7S1Hj8L6H0JigziaY1SehIHL3aVp5vcgCLcBGAs/s72-c/KakaoTalk_20190112_172519151.jpg" height="72" width="72"/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-5096059197191508009</id><published>2019-01-12T17:13:00.000+09:00</published><updated>2019-01-12T19:08:22.596+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="2019년"/><category scheme="http://www.blogger.com/atom/ns#" term="모락산"/><category scheme="http://www.blogger.com/atom/ns#" term="새해"/><title type='text'>2019년 시작~</title><content type='html'>&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: justify;&quot;&gt;2018년이 가고, 2019년이 왔다. 새해를 맞이하는 방법은 몇년 째 같은 방식이다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: justify;&quot;&gt;절에 가서 타종식 -&amp;gt; 모락산 신년행사 -&amp;gt; 떡국&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: justify;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: justify;&quot;&gt;군부대 절에 갔기 때문에, 보안상 타종식 사진은 첨부하지 않는다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://2.bp.blogspot.com/-lhgyNaESeJs/XDmeEpVoQxI/AAAAAAAAAXc/MItetYlL8ZQP2mgcKKOtblFzokU8QhCcgCLcBGAs/s1600/KakaoTalk_20190112_165532385_01.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://2.bp.blogspot.com/-lhgyNaESeJs/XDmeEpVoQxI/AAAAAAAAAXc/MItetYlL8ZQP2mgcKKOtblFzokU8QhCcgCLcBGAs/s640/KakaoTalk_20190112_165532385_01.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;아침 일찍 일어나서 모락산을 등산하는 중~~&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-Kp5h5SVo7Xg/XDmeE_F_xbI/AAAAAAAAAXg/n6XM0TDlKfcEQsWtEb_csdd6he95dGTngCLcBGAs/s1600/KakaoTalk_20190112_165532385_02.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://1.bp.blogspot.com/-Kp5h5SVo7Xg/XDmeE_F_xbI/AAAAAAAAAXg/n6XM0TDlKfcEQsWtEb_csdd6he95dGTngCLcBGAs/s640/KakaoTalk_20190112_165532385_02.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;구름이 멋있다.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-UqEYgz8o-9s/XDmeHZ1Mz4I/AAAAAAAAAX0/D93nk36yLnIV4ZXhkTKXUF_lykHQjVq1ACLcBGAs/s1600/KakaoTalk_20190112_165532385_08.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://1.bp.blogspot.com/-UqEYgz8o-9s/XDmeHZ1Mz4I/AAAAAAAAAX0/D93nk36yLnIV4ZXhkTKXUF_lykHQjVq1ACLcBGAs/s640/KakaoTalk_20190112_165532385_08.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;2019년의 첫 해가 뜨고 있는 모습 (필터도 없이 이렇게 멋있게 찍혔다~)&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-eHcLFg6R9ig/XDmeEyT6BjI/AAAAAAAAAXk/oXXKZFes7rsA8jypQK8pMsuioV9VZ-1OACLcBGAs/s1600/KakaoTalk_20190112_165532385_04.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://1.bp.blogspot.com/-eHcLFg6R9ig/XDmeEyT6BjI/AAAAAAAAAXk/oXXKZFes7rsA8jypQK8pMsuioV9VZ-1OACLcBGAs/s640/KakaoTalk_20190112_165532385_04.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;2019년의 바램을 담아 하늘로 날려보낸다.&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-lU4J9i6-sL8/XDmeFw_NhBI/AAAAAAAAAXo/xmuO1XBnMwAmHj_osksqxlLy7kmhOm6AACLcBGAs/s1600/KakaoTalk_20190112_165532385_05.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://3.bp.blogspot.com/-lU4J9i6-sL8/XDmeFw_NhBI/AAAAAAAAAXo/xmuO1XBnMwAmHj_osksqxlLy7kmhOm6AACLcBGAs/s640/KakaoTalk_20190112_165532385_05.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;2019년, 부지런하고 보람찬 한 해가 되었으면 좋겠다!&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://2.bp.blogspot.com/-5JdkaACk89E/XDmeGVEydsI/AAAAAAAAAXw/BAoOqQKDcuYGVuhkaJGR96POiahbjGfIgCLcBGAs/s1600/KakaoTalk_20190112_165532385_06.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://2.bp.blogspot.com/-5JdkaACk89E/XDmeGVEydsI/AAAAAAAAAXw/BAoOqQKDcuYGVuhkaJGR96POiahbjGfIgCLcBGAs/s640/KakaoTalk_20190112_165532385_06.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;사람들의 소원이 적힌 종이들. 올해는 종이가 바닥나서 나는 적지 못했다 아쉽 ㅎㅎ&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-DiosN0fxxII/XDmeGWxk8VI/AAAAAAAAAXs/-QVCe1lkWd0VV5I-IJYugNqNj8bFHWJVwCLcBGAs/s1600/KakaoTalk_20190112_165532385_07.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1200&quot; data-original-width=&quot;1600&quot; height=&quot;480&quot; src=&quot;https://3.bp.blogspot.com/-DiosN0fxxII/XDmeGWxk8VI/AAAAAAAAAXs/-QVCe1lkWd0VV5I-IJYugNqNj8bFHWJVwCLcBGAs/s640/KakaoTalk_20190112_165532385_07.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;2019년의 첫 식사는 엄마표 떡국 ★&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: justify;&quot;&gt;2018년은 정말 금방 지나간 것 같다. 회사 생활을 하니 시간이 훅훅 지나간다. 2019년은 좀 더 정신차리고 부지런하게 살아야겠다. 일도 더 열심히 하고, 공부도 더 열심히하고, 노는 것도 더 열심히 놀아야지. 쓸데없이 흘려보내는 시간들을 줄여서, 보람차고 부지런한 2019년이 되도록 해야겠다~ 화이팅!!&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/5096059197191508009/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2019/01/2019.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/5096059197191508009'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/5096059197191508009'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2019/01/2019.html' title='2019년 시작~'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://2.bp.blogspot.com/-lhgyNaESeJs/XDmeEpVoQxI/AAAAAAAAAXc/MItetYlL8ZQP2mgcKKOtblFzokU8QhCcgCLcBGAs/s72-c/KakaoTalk_20190112_165532385_01.jpg" height="72" width="72"/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-2971342483402724643</id><published>2018-11-02T23:48:00.001+09:00</published><updated>2018-11-02T23:52:31.072+09:00</updated><title type='text'>최근 근황</title><content type='html'>&lt;div&gt;오랜만에 글을 쓰는 거 같다..&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;최근 근황은 뭐 계속 회사 생활의 반복이다.. 눈깜짝하니 입사한지도 1년이 어느새 훌쩍넘었다. 뭔가 해보고 싶은게 많은데, 회사 다니면서 출퇴근 시간도 길고, 내가 체력도 안좋고 부지런한 편도 아니라서 진짜 회사만 다니기 벅찼던 것 같다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;그래도 나름 뭔가 해보려고 최근에 2가지 활동을 했었다.&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 그중에 하나는&amp;nbsp;&lt;a href=&quot;https://www.kosshackathon.kr/&quot;&gt;컨트리뷰톤&lt;/a&gt;이다. 작년이나 올해 초까지만해도 오픈소스 활동을 했었는데, 회사다니면서 자연스레 멈추게 되었다. 다시 한번 오픈소스 활동을 시작하기 위한 계기를 삼으려고 컨트리뷰톤이라는 프로그램에 참여하여&amp;nbsp;&lt;a href=&quot;https://github.com/namhyung/uftrace&quot;&gt;uftrace&lt;/a&gt;&amp;nbsp;라는 C/C++ function tracing 툴 프로젝트에서 활동을 했다. 현재는 컨트리뷰톤 활동은 끝났고, 이번 달 말에 폐회식?시상식? 이 있을 예정이다.&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 또 하나는 블록체인 스터디이다. 반년전쯤부터인가 블록체인쪽에 관심이 생겨서 한번 공부를 해보려고 스터디를 하게 되었다. 스터디는 현재 진행형이다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;회사를 다니면서 이렇게 2가지 활동을 동시에 했다. 이 활동들에 내가 투자하려고 했던 시간/에너지 양이 대략 있었는데, 막상 해보니 실제로 투자한 시간은 내 예상의 20% 도 안되는 것 같다. 신규 기능개발로 인해 회사 일이 최근에 바쁘기도 했고, 생각보다 내가 시간과 자기관리를 제대로 못했다. 시간투자를 많이 못한게 아쉽긴 한데, 일단 뭐라도 해본 것에 의의를...&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;아 그리고, 최근에&amp;nbsp;&lt;a href=&quot;https://estsoft.recruiter.co.kr/app/jobnotice/view?systemKindCode=MRS2&amp;amp;jobnoticeSn=4630&quot;&gt;우리 팀 우리 파트 채용공고&lt;/a&gt;를 새로 냈다. 기존의 채용 공고가 너무 모호하고 매력이 떨어진다고 생각해서 내가 건의를 해서 채용공고의 내용을 바꿔봤다.&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;button onclick=&quot;if(document.getElementById(&#39;spoiler&#39;) .style.display==&#39;none&#39;) {document.getElementById(&#39;spoiler&#39;) .style.display=&#39;&#39;}else{document.getElementById(&#39;spoiler&#39;) .style.display=&#39;none&#39;}&quot; title=&quot;Click to show/hide content&quot; type=&quot;button&quot;&gt;채용공고 보기/숨기기&lt;/button&gt;&lt;br /&gt;&lt;div id=&quot;spoiler&quot; style=&quot;display: none;&quot;&gt;&lt;pre&gt;모집부분&lt;br /&gt;- C++ 기반 공용 모듈 개선 및 개발&lt;br /&gt;- C++ 기반 엔진 모듈 개선 및 개발 &lt;br /&gt;&lt;br /&gt;담당업무&lt;br /&gt;- 사내 C++ 공용 라이브러리 개선 및 개발 &lt;br /&gt;- C++ 기반 악성코드 탐지/치료 엔진 개선 및 개발&lt;br /&gt;- 코드 품질 및 개발 프로세스 개선&lt;br /&gt;&lt;br /&gt;자격요건&lt;br /&gt;- C++ 활용에 자신 있는 분&lt;br /&gt;- 능동적이고 적극적으로 업무를 수행하시는 분 &lt;br /&gt;&lt;br /&gt;우대요건&lt;br /&gt;- 오픈소스 커미터로 활발히 활동하시는 분 (참여 오픈 소스 기재)&lt;br /&gt;- C++ 기반 라이브러리 및 모듈 설계에 자신 있으신 분 (디자인패턴, API, ABI)&lt;br /&gt;- Modern C++ 및 Best Practice를 잘 알고 활발히 적용하시는 분&lt;br /&gt;- 레거시 코드베이스를 효율적으로 다루고 리펙토링을 수행하는 데 의지가 있으신 분&lt;br /&gt;- 유닛 테스트 작성 및 테스트 자동화의 필요성을 이해하고 경험이 있으신 분&lt;br /&gt;- Windows API 를 활용한 시스템 프로그래밍에 대한 지식이 있으신 분&lt;br /&gt;- 해킹/보안 및 보안 솔루션 개발에 관심이 있으신 분&lt;br /&gt;- 서류접수 시 포트폴리오 제출한 분 가산점 부여&lt;br /&gt;&lt;br /&gt;* 포트폴리오 제출 시 자신이 만든 프로그램을 제출할 분은, 코드레벨까지 포함하는 것이 좋습니다.&lt;br /&gt;* 우대요건은 만족하지 않더라도 괜찮습니다.&lt;br /&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;잘하고 열정적인 분들이 많이 지원하셨으면 좋겠다.. C++ 개발자는 뽑기 너무 힘들다.. (요즘 C++ 하는 사람 진짜 없다..ㅠㅠ)&lt;br /&gt;&lt;br /&gt;아무튼 근황은 이러하다.. 요약하자면 정신없이 회사 다니고 있고,, 뭔가 자기계발하고 싶은데 시간과 체력이 안되는 상황??? &lt;strike&gt;사실 나의 게으름이 주된 원인..&lt;/strike&gt;&lt;br /&gt;운동도 안한지 오래됐고,, 영어공부도 해야하는데 시간이 없어서 큰일이다...ㅠㅠ&lt;br /&gt;&lt;br /&gt;프로그래밍 언어적으로는 지금 C++에 대한 회의감이 극에 달하고, Rust 에 대해 매우 긍정적인 상태이다. 도메인적으로는 블록체인 기술에 관심이 많이 가고 있고..&lt;br /&gt;그래서 Rust 랑 블록체인을 공부한 뒤, 블록체인과 관련된 rust 오픈소스에서 활동해볼까 생각중이다...&lt;br /&gt;중요한 건 시간이 없다는 건데... 이제라도 시간관리, 체력관리 잘해서 뭔가 으쌰으쌰 해봐야지...&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/2971342483402724643/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2018/11/blog-post_2.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/2971342483402724643'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/2971342483402724643'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2018/11/blog-post_2.html' title='최근 근황'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-3258286262850352372</id><published>2018-07-21T21:42:00.000+09:00</published><updated>2018-09-24T15:18:56.888+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Development"/><category scheme="http://www.blogger.com/atom/ns#" term="Good Practice"/><category scheme="http://www.blogger.com/atom/ns#" term="Software Craftmanship"/><category scheme="http://www.blogger.com/atom/ns#" term="Testing"/><category scheme="http://www.blogger.com/atom/ns#" term="Unit Test"/><category scheme="http://www.blogger.com/atom/ns#" term="개발"/><category scheme="http://www.blogger.com/atom/ns#" term="개발다운개발"/><category scheme="http://www.blogger.com/atom/ns#" term="개발문화"/><category scheme="http://www.blogger.com/atom/ns#" term="개발자"/><category scheme="http://www.blogger.com/atom/ns#" term="개발프로세스"/><category scheme="http://www.blogger.com/atom/ns#" term="리펙토링"/><category scheme="http://www.blogger.com/atom/ns#" term="문서화"/><category scheme="http://www.blogger.com/atom/ns#" term="소프트웨어품질"/><category scheme="http://www.blogger.com/atom/ns#" term="요구사항분석"/><title type='text'>개발다운 개발에 대해...</title><content type='html'>어쩌다가 2년 반 전에 내가 했던 프로젝트의 코드를 보게 되었다. 코드가 너무 구렸다.&lt;br /&gt;그때도 나는 나름 설계나 코드 품질에 신경을 많이 썼었는데, 지금 돌이켜보면 역량이 많이 부족했었던 것 같다.&lt;br /&gt;내가 개발다운 개발을 한 지가 얼마나 됐을지에 대해 생각해보았다. 길게봐도 반년이 채 안되는 것 같고, 깐깐하게 보면 아직도 많이 부족한 것 같다.&lt;br /&gt;이제서야 슬슬 뭘 좀 알아가고 개발다운 개발을 시작하는 단계라고 생각이 들었다.&lt;br /&gt;&lt;br /&gt;아무튼 그래서 내가 생각하는 &quot;개발다운 개발&quot; 의 기준에 대해 써보려고 한다.&lt;br /&gt;물론, 지극히 개인적인 생각이며 각자가 일하는 도메인과 상황에 따라 매우 다를 것임을 인정한다.&lt;br /&gt;&lt;h4&gt;1. 프로그래밍 언어와 Good Practice 들에 대한 깊은 이해.&lt;/h4&gt;&quot;언어는 도구에 불과하다&quot; 라는 말이 있다. 그냥 문장 자체적으로만 보면 물론 맞는 말이다.&lt;br /&gt;하지만, &quot;불과하다&quot; 라고 표현하기에는 언어는 너무나도 중요한 도구이다. 그리고 정말 공부를 많이 해야하는 도구이다.&lt;br /&gt;언어는 사고를 지배하고, 언어를 공부하고 이해한다는 것은 생각하는 법과 철학을 배우는 것이다.&lt;br /&gt;오랜 시간동안 전 세계적으로 여러 프로젝트들이 개발/연구되고 다양한 사람들이 토론/합의하면서 발전한 소프트웨어 기술과 패러다임들이 프로그래밍 언어에 그대로 녹아들어간다.&lt;br /&gt;즉, 언어를 깊게 공부함으로서 소프트웨어 개발에 대한 철학과 통찰, 패러다임, 트렌드를 알 수 있다.&lt;br /&gt;그리고 언어를 깊게 공부한다는 것은 그 언어에서의 Good Practice 들을 공부하고 숙달하는 것을 포함한다.&lt;br /&gt;언어의 feature spec 이 도구라고 한다면, Good Practice 는 도구를 사용하는 방법이다.&lt;br /&gt;단순히 언어의 문법을 익히고 라이브러리에서 어떤 기능을 제공하는 지 아는 것이 중요한게 아니라, 어떤 상황에서 어떻게 사용해야하는 지에 대한 Good Practice 를 제대로 아는게 핵심이다.&lt;br /&gt;&lt;br /&gt;내 개인적 기준에서, 이 부분에 대해서 개발다운 개발을 하기 위한 &#39;최소한의&#39; 조건은 아래와 같다.&lt;br /&gt;&lt;ul&gt;&lt;li&gt;자신이 주력으로 사용하는 언어에 대해 최신 버전(표준)과 커뮤니티 동향을 지속적으로 tracking 해야 한다.&lt;/li&gt;&lt;li&gt;자신이 하는 프로젝트에서 사용가능한 것들중 가장 효율적이고 합리적인 (가능한 최신의) 언어/컴파일러 버전을 사용해야 한다.&lt;/li&gt;&lt;li&gt;자신이 하는 프로젝트에서 사용하는 언어 버전과 거기에서의 Good Practice 들을 제대로 이해하고 있어야한다.&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;2. 자동화된 유닛테스트 및 테스트 고도화.&lt;/h4&gt;소프트웨어 개발에 있어서 가장 중요한 것중에 하나가 테스트라고 생각한다.&lt;br /&gt;좋은 테스트의 조건은 두가지라고 생각한다.&lt;br /&gt;&lt;ul&gt;&lt;li&gt;자동화된 테스트. 수동으로 테스트할 필요없이 언제든지 소프트웨어의 결함여부를 자동으로 테스트할 수 있어야한다.&lt;/li&gt;&lt;li&gt;가능한 많은 부분을 커버할 수 있어야한다. 즉, 테스트의 빈틈이 최대한 적어야한다.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;이 두가지를 만족하기 위한 최선의 방법이 &quot;자동화된 유닛테스트&quot; 이다. 클래스/모듈들 각각을 별개로 테스트할 수 있어야 테스트의 빈틈을 최소화할 수 있다. 그리고 테스트가 자동화되어야지만, 매번 테스트하기 위해 낭비되는 리소스를 막을 수 있고 테스트를 수시로 수행할 수 있다. 자동화된 유닛테스트가 잘 작성되어 있어야지만, 지속적인 리펙토링이 가능해지고 코드 품질을 높게 유지할 수 있다. 자동화된 유닛테스트는 CI와 연동하고 code coverage report 를 뽑음으로서 더욱 빛을 발할 수 있다.&lt;/div&gt;&lt;div&gt;그러나, 이것은 이상적인 이야기이고 현실적으로 힘든 경우들이 있다. 테스트를 자동화하는 것이 불가능하거나 너무 까다롭다던지, 테스트 단위를 너무 잘게 쪼개는 것이 현실적으로 비효율적인 경우들이 있다. 이런 경우들에 대해서는 물론 현실적인 타협이 필요하다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;자동화된 유닛테스트만으로 소프트웨어의 정상동작 여부를 완벽하게 파악할 순 없다. Integration Test 가 분명히 필요하고, Performance Test 나 블랙박스 테스트등 다양한 관점과 방법으로 테스트를 수행해야한다. 평소 개발 단계에서는 유닛테스트만 수행하고, 릴리즈 시에 블랙박스 테스트를 수행하는 등 시점에 따라 수행해야할 테스트가 달라져야할 수도 있다.&lt;/div&gt;&lt;div&gt;어찌됐든 테스트에 대해서 심도있게 고민하고 고도화하는 것이 소프트웨어 품질을 높이고 전반적인 개발/릴리즈 프로세스를 빠르게 하는데 핵심적인 역할을 한다고 생각한다.&lt;/div&gt;&lt;div&gt;따라서 개발다운 개발을 하기 위해선 테스트를 중요하게 여기고 심혈을 기울여야만 한다.&lt;br /&gt;&lt;h4&gt;3. 지속적인 리펙토링.&lt;/h4&gt;프로젝트가 진행되면서 요구사항은 끊임없이 변경되고 추가된다. 그러면서 코드베이스의 기존 설계는 점점 무너지고, 코드는 점점 읽기어렵고 유지보수하기 어려워진다. 그러면서 점점 버그가 많아지고, 새로운 기능을 추가하는 것이 어려워진다. 새로운 개발자가 합류했을 때에도 코드베이스를 파악하는데 시간이 오래걸리고, 점점 주인을 잃은 코드들이 많아진다. 코드가 스파게티처럼 꼬여있고 툭하면 사이드이펙트가 생기기때문에, 개발하기가 싫어진다.&lt;br /&gt;이러한 비극을 막기위해서는 지속적인 리펙토링이 필수적이다. 요구사항과 코드의 변경에 대해 항상 리펙토링을 수행해서 코드와 설계를 깔끔하게 유지해야한다. 그리고 이러한 리펙토링을 지속적이고 수시로 수행하기 위해서는 2번의 자동화된 유닛테스트와 테스트 고도화가 필수 전제조건이다.&lt;br /&gt;리펙토링과 테스트코드는 떼어놓을 수 없는 관계라고 생각한다. 리펙토링을 하기 위해서는 테스트코드가 필요하고, 테스트코드를 짜기 위해서는 코드가 testable 해지도록 리펙토링해야만 한다. 코드베이스가 리펙토링과 테스트코드 없이 오랜 기간동안 개발/유지보수 되는 경우, 나중에 가서는 리펙토링과 테스트코드 작성 두 가지 모두 너무 까다로워져서 어찌할 수 없는 상황이 되는 경우를 경험해봤다.&lt;br /&gt;&lt;h4&gt;4. 문서화.&lt;/h4&gt;문서화가 빈약한 경우, 무언가 개발/업무를 할 때 계속해서 동료 개발자들에게 물어보거나 직접 다시 조사해봐야한다. 그리고 새로운 개발자가 합류할 때, 불필요한 시행착오가 많아지고 일일히 구두로 알려줘야한다. 따라서 상당히 많은 리소스가 낭비되고, 여러 개발자가 합류하고 떠나는 과정에서 버려지는 지식들이 생기게 된다.&lt;br /&gt;따라서, 문서화에 신경을 쓰는 것은 매우 중요하다. 그러나, 그렇다고 해서 코드베이스와 분리된 별도의 문서가 많아지는 것은 좋지 않다. 별도로 문서화해야하는 것들을 최소화하는 것이 좋다. 최대한 많은 개발/업무 프로세스를 자동화해서 일일히 머릿속에 알고 있지 않아도 되도록 하고, 코드는 그 자체로 self-documenting 하도록 작성해야한다. 테스트코드 또한 일종의 요구사항 문서의 역할을 수행한다고 생각한다. 그리고 세계적으로 표준화되있거나 널리 알려진 것들을 채택하고 사용하는 것이 문서화 부담을 줄여준다고 생각한다.&lt;br /&gt;&lt;br /&gt;코드에 직접적으로 드러나지 않는 동기, 작성이유 등은 반드시 문서화해야한다. 특히, 클래스/함수의 thread-safety가 제대로 문서화 되어있지 않은 경우, 찾기 힘든 하이젠버그가 발생할 가능성이 높아지고, thread-safety를 파악하기 위해 코드를 상세하게 분석해야만 하는 경우가 생긴다.&lt;br /&gt;코드에 관련된 문서화는 별도의 문서를 만들기보다 코드 주석에 doxygen 같은 스타일로 문서화하는 것이 좋다.&lt;/div&gt;&lt;h4&gt;5. 코딩 컨벤션 확립. 정적분석 툴 도입. 코드 리뷰. 효율적인 개발 프로세스.&lt;/h4&gt;&lt;div&gt;여러 개발자가 같은 코드베이스에서 작업하기 때문에, 개발자들의 코딩하는 스타일이 최대한 일치하는 것이 좋고 개발자들이 생산해내는 코드 품질이 상향 평준화되는 것이 좋다.&lt;/div&gt;&lt;div&gt;이것을 위해 코딩 컨벤션이 필요하다. 코딩 컨벤션은 세계적으로 통용되는 Good Practice 들을 기반으로 해야하며, 프로젝트의 도메인과 상황, 개발자들의 기술수준을 고려해서 확립되어야 한다. 그리고 최대한 단순하고 분량이 적아야 좋다고 생각한다.&lt;/div&gt;&lt;div&gt;그러나 코딩 컨벤션이 있더라도 개발자들이 지키지 않으면 무용지물이다. 따라서 개발자들이 코딩 컨벤션을 지키도록 강제하기 위해, 정적 분석 툴을 사용하는 것이 좋다. 정적 분석 툴은 CI에 연동되어 사용함으로서, 개발자들의 실수를 미연에 방지하고 Good Practice 를 지키도록 강제할 수 있다.&lt;/div&gt;&lt;div&gt;그러나, 코딩 컨벤션과 정적분석 툴로는 코드 품질을 관리하는 데 한계가 있다. 결국에 개발자 상호간의 코드 리뷰가 필요하다고 생각한다. 코드 리뷰는 개발자들이 서로 각자의 코딩 스타일을 맞춰가고 코드 품질을 상향 평준화하는 데 큰 도움이 된다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;그리고 위에서 언급했던 것들을 포함해서 효율적이고 적합한 개발 프로세스와 관련 툴들을 갖추는 것이 중요하다. 애자일 패러다임, XP 실행관례들부터 해서 CI, 이슈트래킹, 협업, 외부와의 소통등을 어떻게 효율적으로 할 것 인지에 대해 고민하고 개선해야한다.&lt;/div&gt;&lt;h4&gt;6. 도메인과 비지니스에 대한 이해.&lt;/h4&gt;&lt;div&gt;아무도 필요로 하지 않는 기능을 아무리 잘 만들어봐야 의미가 없다.&lt;/div&gt;&lt;div&gt;현재 자기가 개발하고 있는 소프트웨어의 도메인에 대해 공부하고, 회사의 비지니스 목표와 가치를 이해해야한다.&lt;/div&gt;&lt;div&gt;전문 경영인들이 따로 있더라도, 결국 소프트웨어를 작성하는 실무자는 개발자이기 때문에 개발자가 비지니스에도 관심을 가져야 유의미한 소프트웨어가 나온다고 생각한다. 정말 회사와 비지니스에 도움이 되는 개발을 해야한다.&lt;/div&gt;&lt;div&gt;이렇게 하기위해서는 회사도 비지니스에 대한 의사결정과 정보를 투명하게 공개하고 접근성을 높여줘야한다.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;또한 주어진 요구사항을 잘 분석해야하며, 오버엔지니어링을 하지 않도록 조심해야한다.&lt;/div&gt;&lt;div&gt;1년 반전까지만 해도 나는 오버엔지니어링에 심취해 있었다. 오버엔지니어링은 기술적인 호기심을 채우고 실력을 쌓는 측면에서는 좋지만, 진정한 프로페셔널로서의 모습은 아니다. 주어진 요구사항을 만족하는 최소한의 코드를 작성하는 것이 좋은 개발이라고 생각한다.&lt;/div&gt;&lt;h4&gt;7. 좋은 개발 문화 만들기 및 뛰어난 인재들과 함께하기.&lt;/h4&gt;&lt;div&gt;마지막은 개발다운 개발의 기준이라기 보다, 개발다운 개발의 기준을 만족하기 위한 방법이다.&lt;br /&gt;결국에 개발다운 개발을 하기 위해서는 나 자신 뿐만 아니라 주변 개발자들도 개발다운 개발을 해야만 한다.&lt;br /&gt;그러기 위해서는 결국 뛰어난 인재들과 함께 일해야한다. 그리고 계속해서 공부하고 고민하고 토론하는 좋은 문화를 만들어야한다. 서로 의견을 개진하고 잘못된 점을 말하고 주도적으로 행동하는 데에 거리낌이 없어야한다.&lt;br /&gt;좋은 개발 문화안에서 좋은 인재들이 모이면, 개발다운 개발이 저절로 될 것이라고 생각한다.&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;hr /&gt;&lt;div&gt;&lt;br /&gt;개발다운 개발에 대한 나의 생각을 써보았다.&lt;br /&gt;나는 아직 도메인지식과 비지니스에 대한 이해가 부족한 것 같고, 시간이 지날수록 이게 얼마나 중요한지 더더욱 느끼는 것 같다. 요구사항에 대해 잘 파악하고 분석하는 것이 가장 중요한 과정이라고 생각한다.&lt;br /&gt;아무튼 계속해서 열심히 해야겠다~&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/3258286262850352372/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2018/07/blog-post_21.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/3258286262850352372'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/3258286262850352372'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2018/07/blog-post_21.html' title='개발다운 개발에 대해...'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-5449245123259282013</id><published>2018-07-20T23:56:00.000+09:00</published><updated>2018-07-21T00:21:21.381+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="고베"/><category scheme="http://www.blogger.com/atom/ns#" term="교토"/><category scheme="http://www.blogger.com/atom/ns#" term="여행"/><category scheme="http://www.blogger.com/atom/ns#" term="오사카"/><category scheme="http://www.blogger.com/atom/ns#" term="일본"/><category scheme="http://www.blogger.com/atom/ns#" term="일본여행"/><title type='text'>일본 오사카 여행 (7/13 ~ 7/16)</title><content type='html'>&lt;div style=&quot;text-align: left;&quot;&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-wpu5CubWmqM/W1H9u95B87I/AAAAAAAAAUw/8O01Lwuamv0vCwuw24L--cOAwouFocaxgCLcBGAs/s1600/KakaoTalk_Moim_3BQhCy792ScoNgsRB9iQLilsUvDN1D.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;720&quot; data-original-width=&quot;960&quot; height=&quot;150&quot; src=&quot;https://3.bp.blogspot.com/-wpu5CubWmqM/W1H9u95B87I/AAAAAAAAAUw/8O01Lwuamv0vCwuw24L--cOAwouFocaxgCLcBGAs/s200/KakaoTalk_Moim_3BQhCy792ScoNgsRB9iQLilsUvDN1D.jpg&quot; style=&quot;display: none;&quot; width=&quot;200&quot; /&gt;&lt;/a&gt;&lt;/div&gt;7/13 (금) ~ 7/16 (월) 3박 4일 간 일본 오사카 지역으로 여행을 갔다왔다.&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;내 생애 2번째 해외 여행이었다.&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;첫 해외 여행은 2년 전쯤 삼성에서 단체로 보내준 해외연수(?) 차원의 여행이였기 때문에, 이번이 내가 태어나서 처음으로 자의적으로 해외여행을 간 것이었다.&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-KHwqj9GNoj0/W1HvsAs91ZI/AAAAAAAAASY/sEuTktoiZ8knOUz-MV0ZS3vvykGEokZBQCLcBGAs/s1600/KakaoTalk_20180720_231954490.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;960&quot; data-original-width=&quot;540&quot; height=&quot;400&quot; src=&quot;https://1.bp.blogspot.com/-KHwqj9GNoj0/W1HvsAs91ZI/AAAAAAAAASY/sEuTktoiZ8knOUz-MV0ZS3vvykGEokZBQCLcBGAs/s400/KakaoTalk_20180720_231954490.jpg&quot; width=&quot;225&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;비행기 타기전. 인천공항.&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;비행기는 2년전에 처음탔을 때는 매우 신기했는데, 이번에는 하나도 신기하지 않았다.&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-NDglreuSUT0/W1Hwb1OLSWI/AAAAAAAAASg/HrndlMGClSEkLP230w7GOYOwLWV8Ga7mACLcBGAs/s1600/KakaoTalk_Moim_3BQhCy792ScofkHKHvdL1AoqjfGbcu.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;720&quot; data-original-width=&quot;960&quot; height=&quot;300&quot; src=&quot;https://3.bp.blogspot.com/-NDglreuSUT0/W1Hwb1OLSWI/AAAAAAAAASg/HrndlMGClSEkLP230w7GOYOwLWV8Ga7mACLcBGAs/s400/KakaoTalk_Moim_3BQhCy792ScofkHKHvdL1AoqjfGbcu.jpg&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;밤에 일본에 도착했다. 그리고 남바역으로 왔다. 일본에 왔구나 라는 느낌이 들었다.&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;직장인들이 회식을 한건지, 양복입고 서로 신나보이더라.&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;그리고 엄청 더웠다.&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://2.bp.blogspot.com/-1GnVVMXlHho/W1Hw8mzY2DI/AAAAAAAAASs/-paTcAu0_LMk3CS-vDXxYm9T2gPTiE8LACLcBGAs/s1600/KakaoTalk_Moim_3BQhCy792ScofkHKHvdL1AoqjfCBxw.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;720&quot; data-original-width=&quot;960&quot; height=&quot;300&quot; src=&quot;https://2.bp.blogspot.com/-1GnVVMXlHho/W1Hw8mzY2DI/AAAAAAAAASs/-paTcAu0_LMk3CS-vDXxYm9T2gPTiE8LACLcBGAs/s400/KakaoTalk_Moim_3BQhCy792ScofkHKHvdL1AoqjfCBxw.jpg&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;간단하게 다코야끼를 먹었다. 맛있었다.&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-s4OsAs7yiLU/W1Hxkq21Q1I/AAAAAAAAAS0/LUEb4LbnKVgmYuk3WcMtaX8DA6qjVw98wCLcBGAs/s1600/KakaoTalk_Moim_3BQhCy792ScoNiCJGEDUUakXcGMTdM.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;720&quot; data-original-width=&quot;960&quot; height=&quot;300&quot; src=&quot;https://1.bp.blogspot.com/-s4OsAs7yiLU/W1Hxkq21Q1I/AAAAAAAAAS0/LUEb4LbnKVgmYuk3WcMtaX8DA6qjVw98wCLcBGAs/s400/KakaoTalk_Moim_3BQhCy792ScoNiCJGEDUUakXcGMTdM.jpg&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;2일 째에는 교토로 갔다. 이 사진에 보이는 곳을 먼저 갔는데.. 여기가 이름이 뭐더라..&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-LUI-gyF72EA/W1HyCO0dnyI/AAAAAAAAAS8/Wv9Ygb2f4OEZt_G96z1MUAfn3W35xO4_gCLcBGAs/s1600/KakaoTalk_Moim_3BQhCy792ScoNiCJGEDUUakXcGWeUq.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;720&quot; data-original-width=&quot;960&quot; height=&quot;300&quot; src=&quot;https://1.bp.blogspot.com/-LUI-gyF72EA/W1HyCO0dnyI/AAAAAAAAAS8/Wv9Ygb2f4OEZt_G96z1MUAfn3W35xO4_gCLcBGAs/s400/KakaoTalk_Moim_3BQhCy792ScoNiCJGEDUUakXcGWeUq.jpg&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;디지몬 만화에서 맨날 보던 기찻길이다. 진짜 디지몬 만화에서 기차올때 나오는 소리가 그대로 난다~&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-pVRRecG9bz8/W1HyWmyI4II/AAAAAAAAATE/i9Fv7RHmv4IBVyT1eTrEOLZ6uMAT2YbvACLcBGAs/s1600/KakaoTalk_Moim_3BQhCy792ScoNgsRB9iQLilsUvDN1D.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;720&quot; data-original-width=&quot;960&quot; height=&quot;300&quot; src=&quot;https://1.bp.blogspot.com/-pVRRecG9bz8/W1HyWmyI4II/AAAAAAAAATE/i9Fv7RHmv4IBVyT1eTrEOLZ6uMAT2YbvACLcBGAs/s400/KakaoTalk_Moim_3BQhCy792ScoNgsRB9iQLilsUvDN1D.jpg&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;여기도 갔는데, 이름이 어딘지 까먹;; 암튼 좋았다~&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;날씨는 무지더웠다;; 이날 완전 땀 범벅이였다.&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-xbmTi4_ZCo0/W1HzDG91pgI/AAAAAAAAATU/q---GPHdv8shvBgtvxe4c-DM3dL37IO2gCLcBGAs/s1600/KakaoTalk_Moim_3BQhCy792ScoNdoTjzz1FzySSChcrf.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;720&quot; data-original-width=&quot;960&quot; height=&quot;300&quot; src=&quot;https://4.bp.blogspot.com/-xbmTi4_ZCo0/W1HzDG91pgI/AAAAAAAAATU/q---GPHdv8shvBgtvxe4c-DM3dL37IO2gCLcBGAs/s400/KakaoTalk_Moim_3BQhCy792ScoNdoTjzz1FzySSChcrf.jpg&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;대나무숲. 날씨가 화창하구만!&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://2.bp.blogspot.com/-uUGkwiQHCZ0/W1Hytu-z3-I/AAAAAAAAATM/pUr0lJUfgkQuyfyKXOXHEj50O1DM1di5QCLcBGAs/s1600/KakaoTalk_Moim_3BQhCy792ScoNgsRB9iQLilsUw50Wt.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;720&quot; data-original-width=&quot;960&quot; height=&quot;300&quot; src=&quot;https://2.bp.blogspot.com/-uUGkwiQHCZ0/W1Hytu-z3-I/AAAAAAAAATM/pUr0lJUfgkQuyfyKXOXHEj50O1DM1di5QCLcBGAs/s400/KakaoTalk_Moim_3BQhCy792ScoNgsRB9iQLilsUw50Wt.jpg&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;일본 편의점에 가면 이렇게 꼭 잡지가 모여져있는 곳이 있었다.&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-GA5d1S7PBLA/W1Hz6k_DuiI/AAAAAAAAATc/4NKCxNtWzqcRrDS8m-Xy3NFC4n5eimyvgCLcBGAs/s1600/asahi.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;960&quot; data-original-width=&quot;540&quot; height=&quot;320&quot; src=&quot;https://3.bp.blogspot.com/-GA5d1S7PBLA/W1Hz6k_DuiI/AAAAAAAAATc/4NKCxNtWzqcRrDS8m-Xy3NFC4n5eimyvgCLcBGAs/s320/asahi.jpg&quot; width=&quot;180&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;아~ 아사히 시원~하다~&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-nbNOxIzpheA/W1H0TYXuQoI/AAAAAAAAATo/EEruZfGKeM8tw5dgU03alHkUCubQXUVvgCLcBGAs/s1600/sky.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;720&quot; data-original-width=&quot;960&quot; height=&quot;300&quot; src=&quot;https://4.bp.blogspot.com/-nbNOxIzpheA/W1H0TYXuQoI/AAAAAAAAATo/EEruZfGKeM8tw5dgU03alHkUCubQXUVvgCLcBGAs/s400/sky.jpg&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;여기는 우메다 공중정원(?)&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-DAfJmCSs29s/W1H1IyOLevI/AAAAAAAAAT8/PJj8Kvo2hhk64l3kUn8VfSZ2AQmC1_vOwCLcBGAs/s1600/universal.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;720&quot; data-original-width=&quot;960&quot; height=&quot;240&quot; src=&quot;https://4.bp.blogspot.com/-DAfJmCSs29s/W1H1IyOLevI/AAAAAAAAAT8/PJj8Kvo2hhk64l3kUn8VfSZ2AQmC1_vOwCLcBGAs/s320/universal.jpg&quot; width=&quot;320&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;셋째날은 유니버셜 스튜디오에 갔다! 옛날에 LA에서 갔었는데 거기랑 느낌이 비슷했다!&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-27AIgqivpA4/W1H1Hv-EtaI/AAAAAAAAATw/agEVEJ-PTSU1ulevIkvWflDaIGF6liPpACLcBGAs/s1600/beef.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;720&quot; data-original-width=&quot;960&quot; height=&quot;300&quot; src=&quot;https://4.bp.blogspot.com/-27AIgqivpA4/W1H1Hv-EtaI/AAAAAAAAATw/agEVEJ-PTSU1ulevIkvWflDaIGF6liPpACLcBGAs/s400/beef.jpg&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;고베에 가서 먹은 고베규! 완전 맛있다!&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;세명이서 간단하게만 먹었는데 17000엔정도 나온듯?&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-HK8-tHaFaI4/W1H1H0XER4I/AAAAAAAAAT0/ZOcg62ijhB4QTQXLbOdZGVBSNiauQdaqQCLcBGAs/s1600/castle.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;960&quot; data-original-width=&quot;540&quot; height=&quot;400&quot; src=&quot;https://1.bp.blogspot.com/-HK8-tHaFaI4/W1H1H0XER4I/AAAAAAAAAT0/ZOcg62ijhB4QTQXLbOdZGVBSNiauQdaqQCLcBGAs/s400/castle.jpg&quot; width=&quot;225&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;야간에 보면 더 멋있는 오사카성! 반짝반짝하니 좋다~~&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-VkpbPpLPuow/W1H178C0YqI/AAAAAAAAAUQ/1MvRPqpHFfoFl3uckm3GOWv1ZUNx7FLXACLcBGAs/s1600/ramen.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;720&quot; data-original-width=&quot;960&quot; height=&quot;300&quot; src=&quot;https://1.bp.blogspot.com/-VkpbPpLPuow/W1H178C0YqI/AAAAAAAAAUQ/1MvRPqpHFfoFl3uckm3GOWv1ZUNx7FLXACLcBGAs/s400/ramen.jpg&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;이츠란 라멘~ 맛있다! 아사히도 넘나 짱짱~&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-h2-1sL6G7js/W1H2WdG1zeI/AAAAAAAAAUY/Fm_o66nWStY0QR73CV0-jjv-_OIhUo3GQCLcBGAs/s1600/beer.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;960&quot; data-original-width=&quot;720&quot; height=&quot;320&quot; src=&quot;https://4.bp.blogspot.com/-h2-1sL6G7js/W1H2WdG1zeI/AAAAAAAAAUY/Fm_o66nWStY0QR73CV0-jjv-_OIhUo3GQCLcBGAs/s320/beer.jpg&quot; width=&quot;240&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;나는 편의점에서 파는 빙결 맥주가 왜케 맛있던지... 일본이 제일 부러웠던 점 같다..&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;레몬/자몽 들어간 맥주 다 맛있다!&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-6HmWbnaBcJQ/W1H298n9aOI/AAAAAAAAAUk/U1OnGftEDSAaSyOn2q6dfpSe1_HdrsKzwCLcBGAs/s1600/city.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;960&quot; data-original-width=&quot;720&quot; height=&quot;400&quot; src=&quot;https://1.bp.blogspot.com/-6HmWbnaBcJQ/W1H298n9aOI/AAAAAAAAAUk/U1OnGftEDSAaSyOn2q6dfpSe1_HdrsKzwCLcBGAs/s400/city.jpg&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;마지막날 아침의 번화가 모습. 일본은 역시 번화가가 느낌이 좋다~&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left;&quot;&gt;아무튼 해외여행을 가면 역시 안목이 넓어지고, 뭔가 리프레시가 되는 것 같다! 앞으로는 해외여행 자주 다녀야지!&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/5449245123259282013/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2018/07/713-716.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/5449245123259282013'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/5449245123259282013'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2018/07/713-716.html' title='일본 오사카 여행 (7/13 ~ 7/16)'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://3.bp.blogspot.com/-wpu5CubWmqM/W1H9u95B87I/AAAAAAAAAUw/8O01Lwuamv0vCwuw24L--cOAwouFocaxgCLcBGAs/s72-c/KakaoTalk_Moim_3BQhCy792ScoNgsRB9iQLilsUvDN1D.jpg" height="72" width="72"/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-8932582959416646164</id><published>2018-07-02T00:45:00.000+09:00</published><updated>2018-07-02T00:49:35.888+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="채용"/><category scheme="http://www.blogger.com/atom/ns#" term="채용공고"/><title type='text'>채용공고는 구체적이고 투명해야한다.</title><content type='html'>얼마전 아는 후배가 C++ 개발자 채용공고라면서 링크를 하나보여줬다.&lt;br /&gt;&lt;a href=&quot;https://www.think-cell.com/en/career/jobs/development.shtml&quot;&gt;https://www.think-cell.com/en/career/jobs/development.shtml&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;독일에 있는 think-cell 이라는 회사의 개발자 채용공고인데, 내가 봤던 채용공고 중에 가장 멋있었다. &lt;strike&gt;(내가 봐봤던 채용공고가 몇개 안되긴 하지만..)&lt;/strike&gt;&lt;br /&gt;&lt;br /&gt;일단 회사 내에서 하는 일과 기술 스택 등에 대해 구체적으로 적어놓은 점이 맘에 들었다.&lt;br /&gt;그리고 그 내용은 더더욱 맘에 들었다. 적어놓은 항목 하나하나가 실력있고 열정있는 C++ 개발자라면 누구나 혹할 만한 내용과 키워드들이었다.&lt;br /&gt;정말 멋진 회사라고 생각되서 블로그에 포스팅을 하게되었다.&lt;br /&gt;&lt;br /&gt;반면에 우리나라에 저런 C++ 회사가 있는 지 생각해보면 아무 회사도 떠오르지 않는다. Java/Python 등을 주로 사용하는 서비스 분야 쪽에서 생각해보면&amp;nbsp;&#39;괜찮은 회사&#39; 들이 몇몇 떠오르지만, C++이나 시스템/로우레벨 쪽에는 그런 회사가 상대적으로 적다고 느껴진다. (여기서 &#39;괜찮은 회사&#39; 은 내 주관적인 기준에서, 기술적으로 트랜디하고, 오픈소스에 참여하고, 의사결정과 정보가 투명하고, 실력과 성과에 부합하는 보상을 지급하고, 열정있고 실력있는 사람들이 모여있는 회사를 의미한다.)&lt;br /&gt;&lt;br /&gt;아무튼 회사가 좋고나쁨을 떠나서, 채용공고를 저렇게 세부적으로 적는다는 점 자체가 많은 회사들이 본받아야할 점 같다. 저 채용공고를 보면, 어떤 언어,컴파일러,라이브러리를 사용하는지, 어떤 버전컨트롤을 쓰는지, 어떤 툴들을 쓰는지, 사내 코딩컨벤션이 있는지, 유닛테스트를 하는지 등에 대해서 많은 내용을 써놨다. 즉, 저 회사는 저런 점들에 대해서 중요하게 생각하고 신경을 쓰고 있기 때문에 채용 공고에 저런 점들을 적어놓은 것이고, 평소에 저런 점들을 중요시 여기는 개발자가 채용 공고를 본다면 자연스럽게 호감이 가고 회사에 지원하게 될 것이다.&lt;br /&gt;채용 공고에 적어놓은 내용들이 내가 관심있거나 하고싶은 내용들이 아니라면 그 회사는 나랑 맞지 않는 것이고, 채용 공고가 추상적이거나 모호하다면 그 회사는 원하는 인재의 기준이 뚜렷하지 않은 것이며, 그만큼 모호한 사람들이 모여있는 회사일 것이다.&lt;br /&gt;&lt;br /&gt;정말 능력있고 열정있는 개발자를 뽑고 싶다면, 채용 공고에 회사의 현재 상황과 나아가고자 하는 방향을 (비지니스적 측면과 기술적인 측면 모두에 대해) 최대한 상세하고 투명하게 공개해야한다.</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/8932582959416646164/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2018/07/blog-post.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/8932582959416646164'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/8932582959416646164'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2018/07/blog-post.html' title='채용공고는 구체적이고 투명해야한다.'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-5174431556771783259</id><published>2018-06-23T22:39:00.001+09:00</published><updated>2018-06-24T11:51:48.980+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="기초군사훈련"/><category scheme="http://www.blogger.com/atom/ns#" term="논산훈련소"/><category scheme="http://www.blogger.com/atom/ns#" term="산업기능요원"/><category scheme="http://www.blogger.com/atom/ns#" term="육군훈련소"/><title type='text'>기초군사훈련 (육군훈련소) 수료!</title><content type='html'>산업기능요원으로서 육군훈련소에서 4주간 (5/24 ~ 6/21) 기초군사훈련을 받았다!&lt;br /&gt;수료 후 사회로 다시 돌아왔는데, 수료 당일과 다음 날에는 모든 것이 어색했다.&lt;br /&gt;컴퓨터 마우스를 사용하는 것도 잘 못하겠어서 신기(?)하고 이상했다. 아무튼 2일이 지난 오늘은 사회에 대한 적응이 어느정도 됐다. 물론 아직도 군인말투(?) 가 종종 튀어나오긴 한다.&lt;br /&gt;&lt;br /&gt;4주간의 훈련 강도는 너무 낮았다. 훈련 자체는 진짜 별로 힘든거 없고,, 훈련 중간에 쉬는 시간도 지나치게 많고,, 개인 여건도 많이 보장해준다. 밥도 준수한 편이고, 간식(부식) 도 엄청 많이 나온다. 그리고 잠도 많이 자고, 주말에 하는 종교활동도 되게 재밌다. 또, 일 생각이나 복잡한 생각을 안하고 그냥 단순하게 지낼수 있어서 스트레스를 적게 받는다. 개인시간이 없고 24시간 단체생활을 한다는 점이 유일하게 힘들었던 점이었다. 개인적으로, 진짜 4주동안 받은 훈련이 별거 없다고 생각한다. 진짜 맛보기만 한 것 같은 기분이다. 아무리 산업기능요원/전문연구요원/의무소방을 위한 훈련이라지만.. 훈련의 퀄리티와 강도를 좀 더 높여야 되는 거 아닌가라는 생각이 들었다.&lt;br /&gt;&lt;br /&gt;훈련소 생활을 하니까 새삼 자유롭게 사는 것의 소중함을 깨달은 것 같다. 그리고 현역으로 군대를 갔다온 친구들이 대단하고 존경스러워졌다. 또, 조국을 위해 목숨바쳐 헌신하고 싸웠던 위인들이 참 대단하다는 생각이 들었고, 나도 그정도까진 못하더라도 살아가면서 조국과 세상을 위해 뭔가 좋은 일을 해야겠다는 생각이 들었다.&lt;br /&gt;&lt;br /&gt;아무튼 훈련소 수료하니까 좋다!&lt;br /&gt;근데, 목감기가 지독하게 걸려서 낫지가 않네....ㅠㅠ</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/5174431556771783259/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2018/06/blog-post.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/5174431556771783259'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/5174431556771783259'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2018/06/blog-post.html' title='기초군사훈련 (육군훈련소) 수료!'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-2007957770068065189</id><published>2018-05-23T01:18:00.002+09:00</published><updated>2018-05-23T01:18:58.002+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Agile"/><category scheme="http://www.blogger.com/atom/ns#" term="Book Review"/><category scheme="http://www.blogger.com/atom/ns#" term="Software Craftman"/><category scheme="http://www.blogger.com/atom/ns#" term="Software Craftmanship"/><category scheme="http://www.blogger.com/atom/ns#" term="Software Design"/><category scheme="http://www.blogger.com/atom/ns#" term="TDD"/><category scheme="http://www.blogger.com/atom/ns#" term="XP"/><title type='text'>소프트웨어 장인 (The Software Craftsman) 리뷰</title><content type='html'>별점 : ★★★★&lt;br /&gt;한줄평 : 더 나은 소프트웨어 개발자가 되고자 노력하는 모든 이들의 필독서. 소프트웨어 장인의 길로 안내하는 이념서.&lt;br /&gt;&lt;br /&gt;번역 :&amp;nbsp;&lt;a href=&quot;http://book.naver.com/bookdb/book_detail.nhn?bid=9585753&quot;&gt;http://book.naver.com/bookdb/book_detail.nhn?bid=9585753&lt;/a&gt;&lt;br /&gt;원서 :&amp;nbsp;&lt;a href=&quot;https://www.amazon.com/Software-Craftsman-Professionalism-Pragmatism-Robert/dp/0134052501&quot;&gt;https://www.amazon.com/Software-Craftsman-Professionalism-Pragmatism-Robert/dp/0134052501&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;이 책은&amp;nbsp;Robert C. Martin Series 5권 중에 하나로서, &quot;소프트웨어 장인정신&quot; 에 대한 책이다. (저자는 밥아저씨가 아니라 다른 분이지만, 마틴 시리즈로 분류되고 있다..)&lt;br /&gt;&lt;blockquote class=&quot;tr_bq&quot;&gt;소프트웨어 장인정신은 마스터가 되어가는 긴 여정이다. 소프트웨어 장인정신은 소프트웨어 개발자 스스로가 선택한 커리어에 책임감을 가지고, 지속적으로 새로운 도구와 기술을 익히며 발전하겠다는 마음가짐이다. 소프트웨어 장인정신은 책임감, 프로페셔널리즘, 실용주의 그리고 소프트웨어 개발자로서의 자부심을 의미한다.&lt;/blockquote&gt;위는 이 책의 저자가 말하는 소프트웨어 장인정신의 정의이다. 아래는 이 책을 읽고 생각하면서 내가 이해하고 받아들인 &quot;소프트웨어 장인정신&quot; 에 대한 내용이다. (개인적인 생각이 포함되어 있다.)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; 소프트웨어 장인정신이란, 다른 것은 무시하고 단순히 아름다운 코드만을 추구하는 것이 아니다. 철저히 프로페셔널리즘과 실용주의에 입각하고, 비지니스적인 가치를 첫째로 추구한다. 다만, 비지니스 가치를 극대화시키고 고객을 만족시키며 끊임없이 추가되고 변경되는 요구사항에 대응하기 위해서는, &lt;b&gt;결국에 높은 수준의 소프트웨어 품질을 성취해야한다&lt;/b&gt;.&lt;br /&gt;&amp;nbsp; &amp;nbsp; 소프트웨어 장인은 &lt;b&gt;비합리적인 것들과 잘못된 의사결정에 대항하며&lt;/b&gt;, 회사와 비지니스 가치를 위해 올바른 실행 관례를 배우고 실천하며 널리 퍼뜨린다. 그러한 실행 관례로서, 책의 저자는 애자일, XP, TDD 등을 들고 있다. 하지만, 이러한 것들은 상황과 시대가 바뀜으로서 달라질 수 있는 것으로서, 그 것이 소프트웨어 장인정신을 대표하는 건 아니다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; 소프트웨어 장인은 단순히 밥벌이로서 일을 대하는 게 아니라 &lt;b&gt;자신의 일에 대해 자부심, 열정, 그리고 철학을 가지고 있다&lt;/b&gt;. 주인의식과 책임감을 가지고 주어진 일을 가장 단순한 방법으로 해결한다. 현실과 경험에 안주하지 않고, &lt;b&gt;끊임없이 공부하고 발전하고 고민하며 소통한다&lt;/b&gt;.&lt;br /&gt;&lt;br /&gt;이 책에는 코드나 무거운 기술에 대한 내용이 등장하는 것이 아니기 때문에, 출퇴근 길에 버스, 지하철에서 가볍게 읽기 좋다. 그럼에도 불구하고 내용이 마냥 가벼운 것은 아니다.&amp;nbsp;&lt;b&gt;이 책은 매우 이념이 짙은 책이다.&amp;nbsp;&lt;/b&gt;분명히 이 책을 읽으면 누구든지 느끼는 바가 있을 것이고, 그 것이 분명 소프트웨어 개발자 커리어에 영감을 줄 것이라고 생각한다.&lt;br /&gt;&lt;br /&gt;번역서의 경우, 번역이 매우 잘됐다. 내가 태어나서 읽어본 번역서중에 가장 번역이 잘 된 책중에 하나이다.&lt;br /&gt;책의 단점에 대해 말하자면, 내용이 너무 반복적이고 장황한 측면이 있다. (비슷한 내용과 말이 반복되는 느낌이 있다.)&lt;br /&gt;&lt;br /&gt;아무튼 종합적으로 볼 때, 매우 괜찮은 책이였고 이 포스팅을 읽는 여러분들께 꼭 추천하고 싶다.&lt;br /&gt;&lt;br /&gt;마지막으로, 책의 구절 중 하나를 인용하면서 포스팅을 마무리하고자 한다.&lt;br /&gt;&lt;blockquote class=&quot;tr_bq&quot;&gt;일을 어떻게 했느냐는 일을 해낸 것 만큼이나 중요하다.&lt;/blockquote&gt;</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/2007957770068065189/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2018/05/software-craftsman.html#comment-form' title='1개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/2007957770068065189'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/2007957770068065189'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2018/05/software-craftsman.html' title='소프트웨어 장인 (The Software Craftsman) 리뷰'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-2044160252325915741</id><published>2018-05-21T23:34:00.002+09:00</published><updated>2018-05-22T01:59:59.568+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="공지"/><category scheme="http://www.blogger.com/atom/ns#" term="구글블로거"/><category scheme="http://www.blogger.com/atom/ns#" term="네이버블로그"/><category scheme="http://www.blogger.com/atom/ns#" term="블로그"/><category scheme="http://www.blogger.com/atom/ns#" term="인사"/><title type='text'>★★★ 네이버 블로그에서 왔습니다 ★★★</title><content type='html'>안녕하세요~ 새롭게 인사드립니다!&lt;br /&gt;&lt;br /&gt;&lt;a href=&quot;http://blog.naver.com/likeme96&quot;&gt;http://blog.naver.com/likeme96&lt;/a&gt; 에서 이사온 taeguk (전공체육) 입니다~&lt;br /&gt;&lt;br /&gt;이유는 4가지 입니다!&lt;br /&gt;&lt;ol&gt;&lt;li&gt;구글 검색에 노출되는 빈도를 높이기 위해&lt;/li&gt;&lt;li&gt;카테고리 기반이 아닌 태그 기반으로 포스팅을 하기 위해&lt;/li&gt;&lt;li&gt;변화를 도모하기 위해&lt;/li&gt;&lt;li&gt;포스팅 시간을 맘대로 바꿀 수 있음. (포스팅 마이그레이션 작업에 용이.)&lt;/li&gt;&lt;/ol&gt;기존 블로그에 있던 상당수 글들 (기술 포스팅 위주) 을 대부분 마이그레이션 해온 상태입니다! (100% 수동 작업... 한 5~6시간 걸렸어요... 너무 힘들었어요 ㅠㅜ)&lt;br /&gt;&lt;br /&gt;새 마음 새 뜻으로... 잘 부탁드립니다!</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/2044160252325915741/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2018/05/blog-post_21.html#comment-form' title='1개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/2044160252325915741'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/2044160252325915741'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2018/05/blog-post_21.html' title='★★★ 네이버 블로그에서 왔습니다 ★★★'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-8263525719391667081</id><published>2018-05-05T23:17:00.000+09:00</published><updated>2018-05-21T23:21:21.166+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="From Naver Blog"/><category scheme="http://www.blogger.com/atom/ns#" term="개발자"/><category scheme="http://www.blogger.com/atom/ns#" term="근황"/><category scheme="http://www.blogger.com/atom/ns#" term="병특"/><category scheme="http://www.blogger.com/atom/ns#" term="산업기능요원"/><category scheme="http://www.blogger.com/atom/ns#" term="직장인"/><category scheme="http://www.blogger.com/atom/ns#" term="출퇴근"/><title type='text'>이것이 직장인의 삶이구나</title><content type='html'>회사에 온지도 8개월이 넘었고, 병특을 시작한지도 반년이 넘었다.&lt;br /&gt;회사 입사 지원 서류를 쓴게 엊그제 같은데,, 시간이 진짜 빨리 흐르는게 느껴진다.&lt;br /&gt;&lt;br /&gt;아침에 일어나서 회사에 출근하면, 좀 만 지나면 점심시간이 되고, 또 눈 깜박하면 퇴근 시간이 된다.&lt;br /&gt;그리고 집에 와서 저녁먹고 그러면 또 자야할 시간이 된다.&lt;br /&gt;일주일에 이런 생활을 5일 반복한다.&lt;br /&gt;&lt;br /&gt;회사 일 자체는 즐겁게 하고 있다. 기존 레거시 코드베이스에서 요구사항을 추출/개선해서 새롭게 코드를 재작성하고 있다.&lt;br /&gt;아예 리포지토리부터 새롭게 파서, 프로젝트를 처음부터 정립해나가다보니 많은 것들을 도입하고 개선할 수 있다.&lt;br /&gt;설계, 자동화된 테스트, 문서화, CI, 정적분석툴, 예외처리 등 다양한 부분들을 고민하면서 진행하고 있다.&lt;br /&gt;나름 소프트웨어 장인 정신을 가지고 개발을 하기 위해 노력중이다..&lt;br /&gt;학생때부터 나는 리펙토링, 코드깍기를 좋아했는데 그냥 아무생각없이 병특으로 들어온 회사에서도 내 흥미/적성에 맞게 일을 하게 되서 신기하고 감사하다.&lt;br /&gt;무튼, 회사에 오고나서 실력은 많이 늘은 것 같고, 앞으로도 실력이 많이 늘꺼 같아서 좋다.&lt;br /&gt;&lt;br /&gt;물론 아쉬운 점도 있다.&lt;br /&gt;기존 레거시 코드베이스(프로젝트) 의 품질과 프로세스에 대해 실망감이 많았다.&lt;br /&gt;테스트코드의 부재... 구조화되지 않은 요구사항... 당장은 돌아가지만 &#39;찜찜한&#39; 코드들... 스파게티처럼 꼬여있는 의존성...&lt;br /&gt;이것들이 입사 후부터 지금까지 나에게 많은 스트레스를 안겨준다.&lt;br /&gt;지금 내가 하고 있는 작업이 결국 이러한 소프트웨어 품질과 개발프로세스를 개선하기 위한 작업이다.&lt;br /&gt;주인을 잃은 지 오래된 코드들에서 요구사항을 추출하는게 종종 지치고 의욕이 꺽기기도 하지만,,&lt;br /&gt;전반적으로는 재밌게 하고있다...ㅎㅎ (조급함을 버려야만 한다...ㅜㅜ)&lt;br /&gt;&lt;br /&gt;아무튼,, 이렇게 회사원의 삶을 살고 있다.. 슬슬 회사에 다니는 게 뻔하고 질린다..&lt;br /&gt;이런 회사 생활을 나보고 평생 계속 해야한다고 하면... 흠... 회의감이 들꺼 같다.....&lt;br /&gt;다행인것은 나는 지금 병특이고, 3년이 끝나면 다시 학교로 돌아간다는 사실이다.&lt;br /&gt;뭔가 돌아갈 곳이 있다는 것이 마음에 큰 도움이 된다..&lt;br /&gt;&lt;br /&gt;아무튼,,, 일단은 회사 일 열심히 하고,, 영어 공부 열심히 하고,, 바른생활하고,, 좋은 습관 만들고 실천하고,,&lt;br /&gt;지금의 시간이 아깝지 않도록 현재를 충실하게 사는데 집중해야겠다~&lt;br /&gt;끝!</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/8263525719391667081/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2018/05/blog-post.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/8263525719391667081'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/8263525719391667081'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2018/05/blog-post.html' title='이것이 직장인의 삶이구나'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-703812204530751206</id><published>2018-02-20T11:59:00.000+09:00</published><updated>2018-05-22T01:34:22.012+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="C++"/><category scheme="http://www.blogger.com/atom/ns#" term="From Naver Blog"/><category scheme="http://www.blogger.com/atom/ns#" term="VC++2015"/><category scheme="http://www.blogger.com/atom/ns#" term="vc140_xp"/><category scheme="http://www.blogger.com/atom/ns#" term="Visual Studio"/><category scheme="http://www.blogger.com/atom/ns#" term="Windows XP"/><title type='text'>VC++2015 에서 vc140_xp의 내부 원리</title><content type='html'>&lt;span style=&quot;font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;helvetica&amp;quot; , sans-serif;&quot;&gt;Visual Studio 2015에서 C++프로젝트 플랫폼 도구 집합으로&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;color: #985aff; font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;helvetica&amp;quot; , sans-serif;&quot;&gt;&lt;b&gt;vc140_xp&lt;/b&gt;&lt;/span&gt;&lt;span style=&quot;font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;helvetica&amp;quot; , sans-serif;&quot;&gt;을 사용했을 때, vc140에 비해 내부적으로 바뀌는 점들을 한번 분석(?) 해봤다. (완벽한 내용은 아닐 수 있다..)&lt;/span&gt;&lt;br /&gt;&lt;br style=&quot;margin: 0px; padding: 0px;&quot; /&gt;&lt;span style=&quot;color: #985aff; font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;helvetica&amp;quot; , sans-serif;&quot;&gt;&lt;b&gt;1. Windows SDK을 XP를 지원하는 옛날 버전으로 변경.&lt;/b&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;helvetica&amp;quot; , sans-serif;&quot;&gt;&amp;nbsp; * VC Directories에서 Windows SDK의 include, lib, bin 폴더 경로를 변경&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;helvetica&amp;quot; , sans-serif;&quot;&gt;&amp;nbsp; * 원래 vc140이 v8.1 버전을 사용했다고 하면, vc140_xp로 플랫폼도구집합 변경 시, v7.1A를 사용하는 식으로 바뀜.&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;helvetica&amp;quot; , sans-serif;&quot;&gt;&amp;nbsp; * v7.1A는 xp를 지원함.&amp;nbsp;&lt;/span&gt;&lt;a class=&quot;con_link&quot; href=&quot;http://%28https//en.wikipedia.org/wiki/Microsoft_Windows_SDK&quot; target=&quot;_blank&quot;&gt;(https://en.wikipedia.org/wiki/Microsoft_Windows_SDK&lt;/a&gt;&lt;span style=&quot;font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;helvetica&amp;quot; , sans-serif;&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;br style=&quot;margin: 0px; padding: 0px;&quot; /&gt;&lt;span style=&quot;color: #985aff; font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;helvetica&amp;quot; , sans-serif;&quot;&gt;&lt;b&gt;2. CL 컴파일시 _USING_V110_SDK71_ 매크로를 정의함.&lt;/b&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;helvetica&amp;quot; , sans-serif;&quot;&gt;&amp;nbsp; * VC++의 라이브러리들 (ATL/MFC 라이브러리, C++표준라이브러리의 헤더파일들이 이 매크로에 영향을 받음.)&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;helvetica&amp;quot; , sans-serif;&quot;&gt;&amp;nbsp; * _USING_V110_SDK71_ 매크로가 큰 영향을 주진 않는다. (하지만, 조금이더라도 분명 영향을 미친다.)&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;helvetica&amp;quot; , sans-serif;&quot;&gt;&amp;nbsp; * 예를 들면, 이 매크로가 정의되어 있는 경우, C++표준라이브러리에서 std::shared_mutex 가 정의되지 않는다.&lt;/span&gt;&lt;br /&gt;&lt;br style=&quot;margin: 0px; padding: 0px;&quot; /&gt;&lt;span style=&quot;color: #985aff; font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;helvetica&amp;quot; , sans-serif;&quot;&gt;&lt;b&gt;3. 링크시, /SUBSYSTEM:CONSOLE&quot;,5.01&quot; (or 5.02) 옵션을 사용. (구성 형식이 EXE 일 경우)&lt;/b&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;helvetica&amp;quot; , sans-serif;&quot;&gt;&amp;nbsp; * vc140의 경우에는 /SUBSYSTEM:CONSOLE 옵션이 링크시 사용되는데, vc140_xp의 경우 /SUBSYSTEM:CONSOLE&quot;,5.01&quot; 이 사용됨. (64bit에서는 5.01이 아니라 5.02)&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;helvetica&amp;quot; , sans-serif;&quot;&gt;&amp;nbsp; * 이 링크옵션은 완성된 PE파일의 서브시스템 버전에 영향을 줌.&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;helvetica&amp;quot; , sans-serif;&quot;&gt;&amp;nbsp; * 서브시스템 버전이 명시되지 않은 채로 링크되면, PE파일의 서브시스템이 6이상이 되고, 프로그램이 XP에서 실행되지 않음.&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;helvetica&amp;quot; , sans-serif;&quot;&gt;&amp;nbsp; * 구성 형식이 DLL일 경우도, /SUBSYSTEM:WINDOWS&quot;,5.01&quot; 이 명령줄에 추가되긴 하지만, 실질적으로 의미가 있을 것 같지는 않음.. (DLL은 다른 EXE에 의해 load되는 얘이기 때문에)&lt;/span&gt;&lt;br /&gt;&lt;br style=&quot;margin: 0px; padding: 0px;&quot; /&gt;&lt;span style=&quot;font-family: , &amp;quot;dotum&amp;quot; , &amp;quot;helvetica&amp;quot; , sans-serif;&quot;&gt;부가) 커맨드라인에서, XP target으로 빌드하는 법 :&amp;nbsp;&lt;/span&gt;&lt;a class=&quot;con_link&quot; href=&quot;https://blogs.msdn.microsoft.com/vcblog/2012/10/08/windows-xp-targeting-with-c-in-visual-studio-2012/&quot; target=&quot;_blank&quot;&gt;https://blogs.msdn.microsoft.com/vcblog/2012/10/08/windows-xp-targeting-with-c-in-visual-studio-2012/&lt;/a&gt;</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/703812204530751206/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2018/02/vc2015-vc140xp.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/703812204530751206'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/703812204530751206'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2018/02/vc2015-vc140xp.html' title='VC++2015 에서 vc140_xp의 내부 원리'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-7205316308807815821</id><published>2018-01-04T23:47:00.000+09:00</published><updated>2018-05-22T01:34:33.962+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Cpu Architecture"/><category scheme="http://www.blogger.com/atom/ns#" term="From Naver Blog"/><category scheme="http://www.blogger.com/atom/ns#" term="Hacking"/><category scheme="http://www.blogger.com/atom/ns#" term="Intel"/><category scheme="http://www.blogger.com/atom/ns#" term="Meltdown"/><category scheme="http://www.blogger.com/atom/ns#" term="Security"/><title type='text'>Intel CPU 보안 취약점 (Meltdown) </title><content type='html'>&lt;div&gt;이번에 인텔 CPU 보안취약점 (멜트다운) 관련해서 쉽고 잘 설명해놓은 좋은 글을 발견해서 공유합니다~&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;a href=&quot;http://blog.cyberus-technology.de/posts/2018-01-03-meltdown.html&quot;&gt;http://blog.cyberus-technology.de/posts/2018-01-03-meltdown.html&lt;/a&gt;&lt;/div&gt;&lt;div&gt;(Trying it all together 부분만 읽으시면 됩니다. 짧습니다.)&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;간단하게 한번 끄적여보자면,,,,&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;다음과 같은 연속된 instruction들을 실행합니다.&lt;/div&gt;&lt;div&gt;1. 값을 얻으려는 특정 커널메모리 주소에 접근하여 값을 1바이트 읽습니다.&lt;/div&gt;&lt;div&gt;2. 1번에서 얻은 값에 4096을 곱합니다.&lt;/div&gt;&lt;div&gt;3. (미리준비된 충분히 큰 버퍼의 주소 + 2번에서 얻은 값) 의 주소에 접근합니다. (여기서 &quot;충분히 큰&quot; 이란 4096 * 256 바이트를 의미합니다.)&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;실제 cpu는 이 instruction들을 동시에 실행하게 됩니다. 그러나 instruction들의 실행 결과가 실제로 반영이 되는건 차례대로 반영이 되게 되는데, 1번에서 접근권한이 없어서 예외가 발생하므로, 저 instruction들의 결과가 실제로 반영이 될 순 없습니다. (Exception Suppression을 위해서는 Intel TSX 를 사용한다고 합니다. 사용할 수 없는 환경에서는 그냥 Exception handling)&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;그러나, 3번에서 비록 실행결과가 반영이 되진 않더라도, 실행과정에서 (미리준비된 충분히 큰 버퍼의 주소 + 2번에서 얻은 값) 의 주소의 메모리가 cache 되게 됩니다.&lt;/div&gt;&lt;div&gt;그 후 (미리준비된 충분히 큰 버퍼의 주소 + 4096 * 0~255) 의 주소에 각각 접근하면서 시간을 잽니다. (엄밀히 말하자면 Flush-Reload 라는 기법을 사용합니다.)&lt;/div&gt;&lt;div&gt;만약 가장 시간이 적게 걸렸을 때가 0~255중 74라고 한다면, (미리준비된 충분히 큰 버퍼의 주소 + 4096 * 74) 의 주소가 cache 됐다는 뜻이고, 즉 따라서 처음에 읽으려했던 커널메모리 1바이트의 값이 74인것 입니다!&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;신박하네요 ㅎㅎ&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;* 더 자세히 알고싶으면, 공식 문서 (&lt;a href=&quot;https://meltdownattack.com/meltdown.pdf&quot;&gt;https://meltdownattack.com/meltdown.pdf&lt;/a&gt;) 참고!&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/7205316308807815821/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2018/01/intel-cpu-meltdown.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/7205316308807815821'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/7205316308807815821'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2018/01/intel-cpu-meltdown.html' title='Intel CPU 보안 취약점 (Meltdown) '/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-6601922539414359239</id><published>2017-12-05T00:14:00.000+09:00</published><updated>2018-05-21T23:21:21.030+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="From Naver Blog"/><category scheme="http://www.blogger.com/atom/ns#" term="근황"/><category scheme="http://www.blogger.com/atom/ns#" term="병특"/><category scheme="http://www.blogger.com/atom/ns#" term="산업기능요원"/><category scheme="http://www.blogger.com/atom/ns#" term="이스트시큐리티"/><category scheme="http://www.blogger.com/atom/ns#" term="현역"/><category scheme="http://www.blogger.com/atom/ns#" term="현역병특"/><title type='text'>산업기능요원 현역 시작.</title><content type='html'>&lt;img height=&quot;77&quot; src=&quot;https://postfiles.pstatic.net/MjAxNzEyMDRfNzkg/MDAxNTEyMzEzNDA1MTE5._244gNd49mlq3PZhFJyw8WEpPrEgZ8qGymTyq55bNUkg.vKPy2m3GtGDeBDEl8ORhIbTx4ORIsc7Cyhav4qznTkkg.PNG.likeme96/image.png?type=w966&quot; width=&quot;640&quot; /&gt;&lt;br /&gt;&lt;br /&gt;34개월간의 산업기능요원 현역을 시작하게 됐다.&lt;br /&gt;정당한 절차를 거친 것이긴 하지만, 다른 사람들에 비해 특혜를 누리는 것이기 때문에, 복무기간동안 사회를 위한 활동이나 기부같은 걸 해야겠다는 의무감이 든다.&lt;br /&gt;&#39;진짜 현역&#39;으로 군복무를 하신 분들에게 진심으로 존경과 감사를 표하며, 주변에 군복무를 당당하게 마친 친구들에게 식사나 술이라도 대접해야겠다고 생각하고 있다.&lt;br /&gt;아무튼, 기나긴 병특 기간동안 개인적으로도 의미있고, 주변사람들에게도 도움이 될 수 있는 시간들을 보내고 싶다.</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/6601922539414359239/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2017/12/blog-post.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/6601922539414359239'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/6601922539414359239'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2017/12/blog-post.html' title='산업기능요원 현역 시작.'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-7265904975245369223</id><published>2017-12-02T00:50:00.000+09:00</published><updated>2018-05-21T00:24:42.349+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Book Review"/><category scheme="http://www.blogger.com/atom/ns#" term="C++"/><category scheme="http://www.blogger.com/atom/ns#" term="C++ API Design"/><category scheme="http://www.blogger.com/atom/ns#" term="From Naver Blog"/><category scheme="http://www.blogger.com/atom/ns#" term="Software Design"/><title type='text'>C++ API 디자인 (API Design for C++) 서평</title><content type='html'>&lt;a href=&quot;http://book.naver.com/bookdb/book_detail.nhn?bid=7405945&quot;&gt;&lt;b&gt;http://book.naver.com/bookdb/book_detail.nhn?bid=7405945&lt;/b&gt;&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;https://www.amazon.com/API-Design-C-Martin-Reddy/dp/0123850037&quot;&gt;&lt;b&gt;https://www.amazon.com/API-Design-C-Martin-Reddy/dp/0123850037&lt;/b&gt;&lt;/a&gt;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;&lt;/b&gt;올해 9월 중순~말쯤에 내가 회사에 입사하고 나서, 팀장님께서 읽으라고 던져주신 책이다.&lt;br /&gt;C++언어를 이용해 API를 디자인하는 것에 대해 다루고 있다. 하지만, 비단 C++이나 API 디자인에 국한된 내용들은 아니다. 전반적인 소프트웨어 설계에 대해 영감을 얻을 수 있는 부분들이 많이 있다.&lt;br /&gt;&lt;br /&gt;결론부터 말하면, 책이 굉장히 좋다...&lt;br /&gt;&amp;nbsp; &amp;nbsp; 이 책은 C++언어 자체적으로 고급적인 문법이나 스킬적인 부분, 그리고 디자인패턴적으로 고급적인 내용들을 다루지는 않는다. 다만, 내가 느끼기에는 다른 책들과는 다르게 좀 더 &#39;현실적인&#39; 관점에서 어떻게 소프트웨어를 잘 설계하고 프로젝트를 진행할 수 있는지에 대해 다루고 있다는 생각이 들었다.&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;화려하고 기괴한, 마법같은&quot; 과 같은 단어들은 이 책과 어울리지 않는다. 내가 이 책을 읽으면서 머릿 속에 떠올랐던 건 &quot;투박하고 현실적인, 그렇지만 효과적인&quot; 이런 단어들이다. C++쪽은 언어의 특성 탓인지 사용자들의 특성 탓인지, 다른 언어들에 비해 각종 기괴하고 마법같은 &#39;언어적 기술&#39;들이 많이 존재하고, 극단적으로 overhead를 없애거나 설계를 완벽하게 하려는 그런 점들이 많이 존재한다. 그런 것들은 기술적인 호기심을 자극하긴 하지만, 실제 팀내의 모든 사람들이 그것에 열의가 있거나 그것을 받아들일 역량이 있는 것은 아니기 때문에, 현실적으로 프로젝트에 적용하는 것이 쉽지 않다. 반면에 이 책은 그런 것들과는 다르게, 책 내용을 이해하고 활용하는데 고급적인 C++지식들이 필요하지 않고, 내용들이 상당히 유용하기 때문에, 진짜 현업에서 당장 적용할 수 있고, 당장 회사의 프로젝트와 팀에게 큰 도움을 줄 수 있을 것 같다는 생각이 들었다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; 책이 2011년 2월에 출판된 책이긴 하지만, C++11을 기반으로 하고 있진 않다. 물론, C++0x의 내용들이 약간은 반영이 되있긴 하지만, 아무래도 과거 C++98 시절에 쓰이던 (지금은 C++11언어차원에서 깔끔한 방법을 제공하기 때문에 불필요한) 스킬들이 몇 가지 보이긴 한다. 하지만 이 부분들이 크게 결점이 되진 않는다. 책에서 다루는 근본적인 내용들은 결국 현재에도 적용되는 내용들이기 때문이다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; 그리고 책을 읽으면서 또 좋았던 점은, 각종 개발자들의 말들을 많이 인용했다는 것이다. 스캇마이어스, 허브서터등과 같은 개발자들의 명언(?)들이 많이 수록되어 있어서 은은한 감동을 준다.. 그리고 이 것을 통해, 이 책의 저자가 책을 쓸 때 얼마나 많은 자료를 참고했는지 알 수 있었다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; 그리고 책에 예제가 굉장히 많다. 개인적으로 좋은 책의 기준들중에 가장 중요한 것이 바로 예제라고 생각한다. 예제없는 설명은 마치 근거없는 주장과 같이 아무런 설득력을 지니지 못한다. 그런 측면에서, 이 책은 충분한 예제가 실려있기 때문에 저자가 전달하고자 하는 것을 이해하는 데 많은 도움이 된다.&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; C++을 사용하는 모든 개발자들에게 이 책을 추천하고 싶다. 특히 추천하고 싶은 독자층은 &quot;C++개발에 어느정도 경험이 있는 대학생&quot; 이다. 대학생때는 프로젝트를 진행하더라도, 그것이 상업적이거나 범용적으로 쓰이는 수준까지 가지 않는 경우가 많다. 따라서, 기능자체는 어떻게든 구현하겠지만, 프로젝트를 진행하고 설계하는 측면부터해서 특히나 테스트와 문서화 측면에 대해서는 많은 고민을 하지 않을 가능성이 크다. 그런 분들에게 이 책은 설계, 테스트, 문서화 측면에 대해서 좋은 입문서와 촉진제가 될 것이라고 생각한다. 사실 실제 회사들도 이런 측면들에 대해서 신경을 쓰는 회사는 많이 없어보이기 때문에 (특히나, C/C++쪽에서는 더욱), 이것이 비단 대학생에만 해당되는 말은 아니긴 하다.&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; 아무튼, 책을 읽으면서 내가 평소에 혼자 생각하거나 고민했던 것들을 시원하게 긁어주는 느낌을 많이 받았다. 그리고 책을 읽는다는 느낌보다, 책의 저자와 소프트웨어 품질을 향상시키는 방법에 대해 신나게 수다를 떨고 있는 것 같다는 느낌을 많이 받았다. 책을 읽으면서 많은 영감을 얻은 것 같고, 상당히 많은 도움이 됐다. 나는 번역서를 읽었는데, 번역도 개인적으로 만족스러웠다. 내가 가장 인상깊었던 챕터는 &quot;챕터 4. 설계&quot; 이다. 디자인패턴적인 부분이나 C++스킬적인 부분같이 디테일하고 좀 더 코드레벨에 가까운 내용들은 기존에 내가 공부했거나 알고있는 내용들이 많았다. 하지만, 챕터 4의 초반부분들 (유즈케이스 같은 부분)은 내가 거의 다뤄본 적 없던 부분들이여서, 나에게 많은 영감을 주었다. 챕터 4는 나중에 한번 더 읽어야겠다는 생각을 하고 있다.&lt;br /&gt;&lt;br /&gt;마지막으로 책의 내용중 일부를 인용하면서 서평을 마무리하고 싶다.&lt;br /&gt;&lt;blockquote class=&quot;tr_bq&quot;&gt;마이클 페더스는 레거시 코드를 단순히 오래된 코드가 아닌 테스트 코드가 없는 것으로 정의했는데, 우리는 여기에 주목할 필요가 있다. 이 정의에 따르면 여러분은 오늘날에도 레거시 코드를 작성하고 있을수도 있기 때문이다.&lt;/blockquote&gt;</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/7265904975245369223/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2017/12/c-api-api-design-for-c.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/7265904975245369223'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/7265904975245369223'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2017/12/c-api-api-design-for-c.html' title='C++ API 디자인 (API Design for C++) 서평'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-7676729453778436249</id><published>2017-11-28T00:48:00.000+09:00</published><updated>2018-05-21T00:24:42.357+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Book Review"/><category scheme="http://www.blogger.com/atom/ns#" term="C++"/><category scheme="http://www.blogger.com/atom/ns#" term="From Naver Blog"/><category scheme="http://www.blogger.com/atom/ns#" term="Optimization"/><category scheme="http://www.blogger.com/atom/ns#" term="Optimized C++"/><title type='text'>Optimized C++ 서평</title><content type='html'>&lt;a href=&quot;https://www.amazon.com/Optimized-Proven-Techniques-Heightened-Performance/dp/1491922060&quot;&gt;&lt;b&gt;https://www.amazon.com/Optimized-Proven-Techniques-Heightened-Performance/dp/1491922060&lt;/b&gt;&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;올 봄~여름쯤에 CppKorea에서 주최하는 스터디에 참가해서 읽었던 책이다.&lt;br /&gt;&#39;Optimized C++&#39; 이라는 &quot;자극적인&quot; 책 제목에 이끌려서 읽게 됐는데, 결과적으로 말하자면 상당히 실망이다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;1. 내용이 깊지 않다.&lt;/b&gt;&lt;br /&gt;책의 난이도를 의미하는 것이 아니다. 책의 난이도와 내용의 깊이는 엄밀히 말하면 별개이다. 아무튼, 책 내용의 깊이 측면에서 이 책은 매우 실망적이였다. Optimized C++ 이라는 책 이름에 걸맞는 내용들이 아니였다. 단순히, C++의 good practice들을 performance측면에서 서술한 것이 전부였다. 나는 뭔가 새롭고 고급스러운 스킬들이나 기술들을 원했는데, 내용은 단순히 겉핡기만 하고 있었다. custom memory allocator에 대한 부분으로 예를 들자면, 나는 그것을 활용한 실질적인 고급기술들이나 실제 응용들이 궁금한건데, 책은 단순히 custom memory allocator의 basic example만 가지고 그게 뭔지만 간단하게 설명하고 넘어간다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;2. 설명이 부실하다.&lt;/b&gt;&lt;br /&gt;위에서 내용이 깊지 않다고 했는데, 사실 깊지 않은 내용이더라도 그것을 잘 전달하면 그것은 초심자 혹은 특정 level의 독자들을 위한 상당히 좋은 서적이 된다. 근데 이 책의 문제는 내용이 깊지도 않은데 설명도 부실하다. custom memory allocator로 예를 들자면, 책에서는 basic example만 가지고 간단하게 설명하고 넘어가는데, 문제는 저걸 이미 아는 사람은 읽을 필요가 없고, 저걸 모르는 사람은 책만 읽고서는 이해하기가 어렵다는 것이다. 즉, 뭔가 책의 target 독자층이 애매하다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;3. 영어가 뭔가 이상하다?? (지극히 주관적 생각임에 주의!)&lt;/b&gt;&lt;br /&gt;이건 나의 문제일 수도 있는데.... 뭔가 영어가 너무 안읽힌다... 뭔가 문법이 잘 안맞는 느낌?? 진짜 너무 힘들었다... 내 주관적 생각을 말하자면, 저자분께서 글을 잘 못쓰는 게 아닐까..라고 감히 말해본다...&lt;br /&gt;&lt;br /&gt;&lt;b&gt;결론.&lt;/b&gt;&lt;br /&gt;즉, 이 책은 Optimization에 대한 고급적이고 응용적인 스킬들이나 사례에 대해서는 전혀 다루고 있지 않다. 다만, Optimization과 성능을 위한 C++에서의 good practice를 다룬다 정도로 말하는 것이 옳은 것 같다. 그러나 문제는, 그 내용들이 이미 알고 있는 사람들에게는 지루하며, 모르는 사람들에게는 설명이 부실하다. 결론적으로 나는 이 책을 읽으면서 뭔가 새롭거나 대단한걸 알게 된 건 거의 없었다. 그리고, 가끔 내가 잘 모르는 부분들은 책의 설명은 매우 부실해서 따로 인터넷을 통해 알아봐야 했었다. 결국에, 이 책은 그냥 나에게 영어공부용 서적밖에 되지 않았던 같고, 솔직히 책을 읽는 시간이 아까웠다..</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/7676729453778436249/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2017/11/optimized-c.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/7676729453778436249'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/7676729453778436249'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2017/11/optimized-c.html' title='Optimized C++ 서평'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-321500112809555172</id><published>2017-09-07T23:10:00.000+09:00</published><updated>2018-05-21T23:21:20.954+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="From Naver Blog"/><category scheme="http://www.blogger.com/atom/ns#" term="Google Summer Of Code"/><category scheme="http://www.blogger.com/atom/ns#" term="GSoC"/><category scheme="http://www.blogger.com/atom/ns#" term="GSoC 2017"/><category scheme="http://www.blogger.com/atom/ns#" term="Open Source"/><category scheme="http://www.blogger.com/atom/ns#" term="근황"/><title type='text'>GSoC 2017 끝!</title><content type='html'>&lt;img height=&quot;640&quot; src=&quot;https://postfiles.pstatic.net/MjAxNzA5MDdfMjMx/MDAxNTA0NzE3MDE1NTE4.sLdENkdIOK9BXcBFzi-Q2rKZMgvB7cfzbROxAXvAI4cg.6vgyYhbNgQrcDFqHjRZRmGy4qMf1bRRVwHWx7GddHWIg.PNG.likeme96/image.png?type=w966&quot; width=&quot;604&quot; /&gt;&lt;br /&gt;&lt;br /&gt;여름동안의 Google Summer Of Code 2017를 성공적으로 끝마쳤다. Final Evaluation를 통과하고, 멘토님에게도 칭찬을 들어서 기분이 좋다.&lt;br /&gt;아무튼 GSoC를 계기로 오픈소스에 직접 기여하면서 C++실력도 상당히 많이 늘게 되어서 뿌듯하다.&lt;br /&gt;역시 실력을 키우는데에는 오픈소스 코드를 보는 게 가장 빠르고 효율적인 것 같다.&lt;br /&gt;아래는 내가 GSoC에서 한 활동에 대한 Abstract이다.&lt;br /&gt;(자세한 건 &lt;a href=&quot;https://summerofcode.withgoogle.com/projects/#5151083935563776&quot;&gt;https://summerofcode.withgoogle.com/projects/#5151083935563776&lt;/a&gt; 참고)&lt;br /&gt;&lt;blockquote class=&quot;tr_bq&quot;&gt;HPX is “The C++ Standards Library for Concurrency and Parallelism”. So, implementing C++17 parallelism like N4409 is very important. Most of parallel algorithms are already implemented. But, still some algorithms have not been implemented. My main objective is implementing as many as possible of the remaining parallel algorithms and adapt them to Ranges TS and add container versions of them. And I add unit tests and benchmark codes for them. Associated with mainly parallel algorithms, I also catch and suggest many issues and resolve them.&lt;/blockquote&gt;&amp;nbsp;비록, GSoC는 끝났지만 계속에서 HPX 오픈소스에서 활동을 하며 contribution을 이어나갈 생각이다. 오픈소스 활동을 통해 얻을 수 있는게 많기 때문이다. C++ 차세대 표준을 공부하고 구현하면서 C++ 실력을 상당히 많이 키울 수 있고, 오랜 기간동안 이어온 프로젝트의 빌드시스템, 프로젝트관리, 코드베이스 분석등을 통해 배울 수 있는 게 많다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; 사실 GSoC가 나에게 도움을 준 건 사실상 금전적인 부분이 거의 다고, 사실 오픈소스 활동은 나 혼자 스스로 했다고 볼 수 있다. 그럼에도 불구하고, GSoC에 참여하기 이전에는 오픈소스 프로젝트에 선뜻 뛰어들기가 쉽지 않았다. 그 이유는 강제성이 전혀 부여되지 않고, 특별한 계기가 없었기 때문에 계속 참여를 미루게 되었기 때문이다. GSoC는 1차,2차,최종 평가를 통해 나에게 약간의 강제성을 부여했고, &#39;계기&#39;를 만들어 주었다. 이 것들이 나를 시작하게 만들었고, 앞으로도 계속 꾸준히 오픈소스 개발에 참여하면서 재미를 볼 수 있을 것 같다. 아무튼 여름동안의 GSoC는 정말 좋은 경험이었고, 이 글을 볼 대학생(대학원생)분들께 꼭 이 활동을 추천하고 싶다. (취업할 때도 도움이 많이 되는걸로 안다.)&lt;br /&gt;&lt;br /&gt;&lt;b&gt;* GSoC를 지원하고 싶은 사람들을 위한 TIP *&lt;/b&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; GSoC는 매년 3월쯤에 모집을 한다. 실력에 대해서는 생각보다 너무 걱정을 하지 않아도 된다. 왜냐면, 애초에 지원할 때 프로젝트를 자기가 할 수 있는 쉬운 걸로 제출하면 되기 때문이다. 합격여부에 있어서 중요한 건, 이 사람의 실력 자체가 아니라 &quot;자기가 제안한 프로젝트에 대해 얼마나 이해하고 있고 이 것을 성공적으로 수행할 수 있는가&quot;이다. 그래서, 실력이 부족하면 쉬운 프로젝트를 제안하면 되기 때문에 일단 도전해보는 것을 추천한다. 대신에, SW개발과 오픈소스에 대해 열정과 끈기가 없으면 제대로 된 proposal를 작성하지 못하고 포기하게 될 것이다. GSoC가 경쟁률이 굉장히 쌔긴하지만, 제대로 맘 먹고 proposal를 작성한다면, 상당히 높은 확률로 합격할 수 있을 것으로 생각한다. 총 5개 오픈소스에 대해 지원서를 제출할 수 있는데, 괜히 문어발을 뻗는 것보다 그냥 한 개라도 제대로 쓰는 것을 추천한다. GSoC는 회사 취직과는 달리 &#39;이전에 해온 것&#39; 보다 &#39;앞으로 할 것&#39;을 중요시 본다. 자신의 프로젝트 경험이나 이력사항보다는 자신이 지원할 오픈소스에 대해 공부하고 분석한 다음 그걸 바탕으로 자기가 할 수 있는 프로젝트를 상세하게 작성하여 proposal을 제출하는 것이 중요하다고 생각한다.</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/321500112809555172/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2017/09/2017-9-6-gsoc-2017.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/321500112809555172'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/321500112809555172'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2017/09/2017-9-6-gsoc-2017.html' title='GSoC 2017 끝!'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-6897066995013301245</id><published>2017-06-29T23:11:00.000+09:00</published><updated>2018-05-20T23:14:40.062+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Android"/><category scheme="http://www.blogger.com/atom/ns#" term="Android Framework"/><category scheme="http://www.blogger.com/atom/ns#" term="Embedded"/><category scheme="http://www.blogger.com/atom/ns#" term="From Naver Blog"/><title type='text'>처음으로 Android Framework 소스를 수정해보았다.</title><content type='html'>&amp;nbsp; &amp;nbsp; 이번 학기에 학교에서 &#39;임베디드 시스템 소프트웨어&#39;란 과목을 수강하였다. 학기의 마지막에 간단한 자유 프로젝트 과제가 주어졌다. 근데 기간이 빠듯해서 프로젝트를 진행할 수 있는 시간이 사실상 2일밖에 없었다. 그냥 평범하게 학교수업에서 배운 내용을 바탕으로 할까 하다가 이미 아는 내용을 반복하는 것은 의미가 없다는 생각이 들었다. 그래서 무작정 Android Framework 소스를 수정해서 뭔가 해보는 걸로 프로젝트의 방향을 잡았다.&lt;br /&gt;&lt;br /&gt;&lt;table align=&quot;center&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; class=&quot;tr-caption-container&quot; style=&quot;margin-left: auto; margin-right: auto; text-align: center;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-MdLjHTcVSug/WwGBNIEJzII/AAAAAAAAAMY/ykNZDYCVHJIUxMEdtctMtLCHkkqMoDI5ACLcBGAs/s1600/1.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: auto; margin-right: auto;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;337&quot; data-original-width=&quot;600&quot; height=&quot;358&quot; src=&quot;https://1.bp.blogspot.com/-MdLjHTcVSug/WwGBNIEJzII/AAAAAAAAAMY/ykNZDYCVHJIUxMEdtctMtLCHkkqMoDI5ACLcBGAs/s640/1.png&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;tr-caption&quot; style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;font-size: small;&quot;&gt;Android 기기의 Display 화면을 6x6으로 쪼개서 뒤섞은 모습&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;br /&gt;&lt;table align=&quot;center&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; class=&quot;tr-caption-container&quot; style=&quot;margin-left: auto; margin-right: auto; text-align: center;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-QhvfjPj_xdc/WwGBNcJXVZI/AAAAAAAAAMc/g6piJ2Ac2-IXaaPs3fDWp3ibxCTZX3EiACLcBGAs/s1600/2.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: auto; margin-right: auto;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;337&quot; data-original-width=&quot;600&quot; height=&quot;358&quot; src=&quot;https://3.bp.blogspot.com/-QhvfjPj_xdc/WwGBNcJXVZI/AAAAAAAAAMc/g6piJ2Ac2-IXaaPs3fDWp3ibxCTZX3EiACLcBGAs/s640/2.png&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;tr-caption&quot; style=&quot;text-align: center;&quot;&gt;ㄷㄷㄷ&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;&lt;span style=&quot;font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;;&quot;&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;&lt;span style=&quot;font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;;&quot;&gt;&amp;nbsp; &amp;nbsp; 위는 이번 미니 프로젝트에서 구현한 2가지 기능중에 한 가지인 Display Puzzle 기능이다. Android 기기의 Display 화면을 NxM 의 형태로 쪼개서 퍼즐처럼 뒤섞어 버린다. 이 것을 구현하기 위해 Hardware Abstraction Layer에서 gralloc 관련 부분을 수정했다. 프레임버퍼로 나가기 직전에 화면을 가로채서 뒤섞어버린다.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;&lt;span style=&quot;font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/div&gt;&lt;table align=&quot;center&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; class=&quot;tr-caption-container&quot; style=&quot;margin-left: auto; margin-right: auto; text-align: center;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;337&quot; data-original-width=&quot;600&quot; height=&quot;358&quot; src=&quot;https://3.bp.blogspot.com/--WdmWt9IQNM/WwGBNPxBsZI/AAAAAAAAAMg/Gx9soKe--FwLsOaRL-4AiTYOQ_ZwFPFMwCLcBGAs/s640/3.png&quot; style=&quot;margin-left: auto; margin-right: auto;&quot; width=&quot;640&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;tr-caption&quot; style=&quot;text-align: center;&quot;&gt;정상적인 화면&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/--WdmWt9IQNM/WwGBNPxBsZI/AAAAAAAAAMg/Gx9soKe--FwLsOaRL-4AiTYOQ_ZwFPFMwCLcBGAs/s1600/3.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;&lt;table align=&quot;center&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; class=&quot;tr-caption-container&quot; style=&quot;margin-left: auto; margin-right: auto; text-align: center;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-LFNg5qkjSE8/WwGBOvkWo3I/AAAAAAAAAMo/yfk4ZOxlATUxNKYjwJss_LoJobAXOpBmACLcBGAs/s1600/4.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: auto; margin-right: auto;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;337&quot; data-original-width=&quot;600&quot; height=&quot;358&quot; src=&quot;https://1.bp.blogspot.com/-LFNg5qkjSE8/WwGBOvkWo3I/AAAAAAAAAMo/yfk4ZOxlATUxNKYjwJss_LoJobAXOpBmACLcBGAs/s640/4.png&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;tr-caption&quot; style=&quot;text-align: center;&quot;&gt;캡처를 했을 때, 화면이 오른쪽으로 90도 돌아가고 왼쪽부분에 투명한 회색 선이 생긴 상태로 캡처가 되게 된다.&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&amp;nbsp; &amp;nbsp;&lt;br /&gt;&amp;nbsp; &amp;nbsp; 위는 2번째 기능을 보여준다. 사용자가 캡처를 하게되면, 화면이 오른쪽으로 90도 돌아가고 왼쪽부분에 투명한 회색 선이 생긴 상태로 캡처가 되게 된다. 물론 원래 화면을 그대로 두고 캡처만 저렇게 되게 된다.&lt;br /&gt;&lt;br /&gt;&lt;table align=&quot;center&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; class=&quot;tr-caption-container&quot; style=&quot;margin-left: auto; margin-right: auto; text-align: center;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-4ZuE0-SK3_4/WwGBOXERWKI/AAAAAAAAAMk/fw7lIulYt7A19kdN8kBthZfYE9MEGjZfwCLcBGAs/s1600/5.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: auto; margin-right: auto;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;378&quot; data-original-width=&quot;600&quot; height=&quot;401&quot; src=&quot;https://1.bp.blogspot.com/-4ZuE0-SK3_4/WwGBOXERWKI/AAAAAAAAAMk/fw7lIulYt7A19kdN8kBthZfYE9MEGjZfwCLcBGAs/s640/5.jpg&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;tr-caption&quot; style=&quot;text-align: center;&quot;&gt;출처 : http://cdn.edureka.co/blog/wp-content/uploads/2013/01/Android-Stack1.jpg&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&amp;nbsp; &amp;nbsp;&lt;br /&gt;&amp;nbsp; &amp;nbsp; 아무튼, 별 의미는 없지만 안드로이드 프레임워크를 수정해야 할 수 있는 기능 2가지를 구현해보았다. 쉽게 할 수 있을 줄 알았는데 생각보다 이상현상들이 많이 발생해서 힘들었다. 개발 기간이 2일 밖에 안되서 어쩔 수 없이 야매로 해결하긴 했다. 안드로이드 프레임워크를 한번 분석해보고 싶었는데, 이번 기회에 맛보기정도는 할 수 있던 것 같다. 하면서 힘들었던 점은 코드를 수정하고 나서 결과를 보려면 빌드 시간+안드로이드기기에 올리는 시간 해서 약 20분 가까히 소요됐다는 점이다. 그래서 시간을 많이 허비했던 것같다. 어쨌든, 좋은 경험이었다. 참고로 위의 android architecture 상에서 내가 분석/수정 했던 부분은 Libraries의 Surface Manager와 HAL의 Graphics 부분이다. (Kitkat API19를 바탕으로 했다.) 시간이 2일 밖에 없어서 제대로 분석도 못하고 그냥 마구잡이로 한 것 같은데, 나중에 기회가 되면 제대로 한번 분석해보고 싶다. 아래 링크는 이 mini project를 upload 해둔 github link이다.&lt;br /&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;https://github.com/taeguk/Embedded-System-Software-Assignment&quot;&gt;https://github.com/taeguk/Embedded-System-Software-Assignment&lt;/a&gt;&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/6897066995013301245/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2017/06/android-framework.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/6897066995013301245'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/6897066995013301245'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2017/06/android-framework.html' title='처음으로 Android Framework 소스를 수정해보았다.'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://1.bp.blogspot.com/-MdLjHTcVSug/WwGBNIEJzII/AAAAAAAAAMY/ykNZDYCVHJIUxMEdtctMtLCHkkqMoDI5ACLcBGAs/s72-c/1.png" height="72" width="72"/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-6979035986582602299</id><published>2017-05-02T22:57:00.000+09:00</published><updated>2018-05-21T23:21:21.078+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="C++"/><category scheme="http://www.blogger.com/atom/ns#" term="Effective C++ Series"/><category scheme="http://www.blogger.com/atom/ns#" term="Effective Modern C++"/><category scheme="http://www.blogger.com/atom/ns#" term="From Naver Blog"/><title type='text'>[Effective Modern C++] Chapter 8. 다듬기 [항목 41~42]</title><content type='html'>&lt;h2&gt;Chapter 8. 다듬기&lt;/h2&gt;&lt;h3&gt;항목 41. 이동이 저렴하고 항상 복사되는 복사 가능 매개변수에 대해서는 값 전달을 고려하라.&lt;/h3&gt;왼값 참조와 오른값 참조 버전 2개를 모두 만드는 것은 코드 중복, 유지보수 측면에서 단점이고, 보편 참조 전달 버전은 항목 26/27/30 에서 말했던 것들과 같은 문제들이 발생할 수 있다. 따라서 약간의 효율성을 포기하면 이러한 단점들을 피할 수 있는데, 그것이 바로 값 전달을 활용하는 것이다. (효율성 : 보편 참조 버전 &amp;gt;= 왼값 참조 버전 + 오른값 참조 버전 &amp;gt;= 값 전달 버전)&lt;br /&gt;그러나, 값 전달의 경우에도 주의해야 할 점들이 있다.&lt;br /&gt;1. 잘림 문제 (slicing problem)&lt;br /&gt;2. 값 전달 함수들이 꼬리를 물고 호출되면, 전체적인 성능이 급격히 하락할 수 있다.&lt;br /&gt;3. &quot;값 전달 (복사 생성) -&amp;gt; 이동 배정&quot; 의 경우 &quot;참조 전달 -&amp;gt; 복사 배정&quot; 보다 훨씬 비쌀 가능성이 있다. (예를 들면, std::string이나 std::vector등의 memory allocation 때문에)&lt;br /&gt;&lt;br /&gt;흠, 나는 값 전달 버전이 얼마나 유용할 지 의문이 든다. 일단 이동 연산 하나가 불필요하게 낭비된다. 사실 이동이 저렴한 경우에는 유지보수, 코드중복 해결의 장점을 봤을 때 이러한 사소한 낭비를 무시할 수 있다. 그러나 사실 큰 문제는 이동이 저렴하다고 생각했는데 저렴하지 않을 수 도 있다는 것이다. std::string이나 std::vector같은 경우, memory allocation 때문에 값 전달 후 이동 배정을 하는 것이 상당히 느려질 수 있는데, 코드를 짤 때 이러한 점을 간과하거나 실수 할 가능성이 크다. 또한, 잘림 문제도 주의해야 한다. 즉, 값 전달을 사용하는 것은 참조 버전보다 실수할 가능성이 더 크기 때문에 일단 기본적으로는 피해야 한다고 생각한다. 내 생각에는 일단 우선적으로 왼값/오른값 참조 버전을 사용하다가, 성능을 더 강화할 필요가 있을 경우에는 보편 참조 버전으로 바꾸는 것이 옳고, 그리고 왼값/오른값 참조 버전들 끼리의 코드 중복이 심해질 경우에 값 전달 버전 혹은 보편 참조 버전을 고려하는 것이 옳다고 생각한다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- 이동이 저렴하고 항상 복사되는 복사 가능 매개변수에 대해서는 값 전달이 참조 전달만큼이나 효율적이고, 구현하기가 더 쉽고, 산출되는 목적 코드의 크기도 더 작다.&lt;br /&gt;&amp;nbsp;- 왼값 인수의 경우 값 전달(즉, 복사 생성) 다음의 이동 배정은 참조 전달 다음의 복사 배정보다 훨씬 비쌀 가능성이 있다.&lt;br /&gt;&amp;nbsp;- 값 전달에서는 잘림 문제가 발생할 수 있으므로, 일반적으로 기반 클래스 매개변수 형식에 대해서는 값 전달이 적합하지 않다.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;항목 42. 삽입 대신 생성 삽입을 고려하라.&lt;/h3&gt;얼핏 생각하면 무조건 생성 삽입을 사용하는 것이 옳다고 생각할 수 있다. 나도 그래서 옛날에는 무조건 생성 삽입만을 사용하였다. 그러나 실제적으로 그냥 삽입이 생성 삽입보다 빠를 수도 있고, 삽입과 생성 삽입의 본질적인 차이를 생각해보면 &#39;무조건&#39;은 아니라는 생각이 들 것이다.&lt;br /&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;#include &amp;lt;set&amp;gt;&lt;br /&gt;#include &amp;lt;iostream&amp;gt;&lt;br /&gt;&lt;br /&gt;class Example&lt;br /&gt;{&lt;br /&gt;public:&lt;br /&gt;    explicit Example(int a, int b)&lt;br /&gt;        : m_a(a), m_b(b)&lt;br /&gt;    {&lt;br /&gt;        std::cout &amp;lt;&amp;lt; &quot;Example(int, int) called. \n&quot;;&lt;br /&gt;    }&lt;br /&gt;    ~Example()&lt;br /&gt;    {&lt;br /&gt;        std::cout &amp;lt;&amp;lt; &quot;~Example() called. \n&quot;;&lt;br /&gt;    }&lt;br /&gt;    Example(const Example&amp;amp; other)&lt;br /&gt;        : m_a(other.m_a), m_b(other.m_b)&lt;br /&gt;    {&lt;br /&gt;        std::cout &amp;lt;&amp;lt; &quot;Example(const Example&amp;amp;) called. \n&quot;;&lt;br /&gt;    }&lt;br /&gt;    Example(Example&amp;amp;&amp;amp; other)&lt;br /&gt;        : m_a(other.m_a), m_b(other.m_b)&lt;br /&gt;    {&lt;br /&gt;        std::cout &amp;lt;&amp;lt; &quot;Example(Example&amp;amp;&amp;amp;) called. \n&quot;;&lt;br /&gt;    }&lt;br /&gt;    Example&amp;amp; operator=(const Example&amp;amp; other)&lt;br /&gt;    {&lt;br /&gt;        std::cout &amp;lt;&amp;lt; &quot;operator=(const Example&amp;amp;) called. \n&quot;;&lt;br /&gt;        m_a = other.m_a;&lt;br /&gt;        m_b = other.m_b;&lt;br /&gt;        return *this;&lt;br /&gt;    }&lt;br /&gt;    Example&amp;amp; operator=(Example&amp;amp;&amp;amp; other)&lt;br /&gt;    {&lt;br /&gt;        std::cout &amp;lt;&amp;lt; &quot;operator=(Example&amp;amp;&amp;amp;) called. \n&quot;;&lt;br /&gt;        m_a = other.m_a;&lt;br /&gt;        m_b = other.m_b;&lt;br /&gt;        return *this;&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    bool operator&amp;lt;(const Example&amp;amp; other) const { return m_a + m_b &amp;lt; other.m_a + m_b; }&lt;br /&gt;&lt;br /&gt;private:&lt;br /&gt;    int m_a, m_b;&lt;br /&gt;};&lt;br /&gt;&lt;br /&gt;int main()&lt;br /&gt;{&lt;br /&gt;    std::set&amp;lt;Example&amp;gt; s;&lt;br /&gt;    Example ex(11, 22);&lt;br /&gt;    s.insert(ex);&lt;br /&gt;&lt;br /&gt;    Example ex1(33, 44), ex2(55, 66);&lt;br /&gt;    std::cout &amp;lt;&amp;lt; &quot;\n&quot;;&lt;br /&gt;    std::cout &amp;lt;&amp;lt; &quot;-- insert when not duplicated --\n&quot;;&lt;br /&gt;    s.insert(ex1);&lt;br /&gt;    std::cout &amp;lt;&amp;lt; &quot;--------------------------------\n\n&quot;;&lt;br /&gt;    std::cout &amp;lt;&amp;lt; &quot;-- emplace when not duplicated --\n&quot;;&lt;br /&gt;    s.emplace(ex2);&lt;br /&gt;    std::cout &amp;lt;&amp;lt; &quot;---------------------------------\n\n&quot;;&lt;br /&gt;&lt;br /&gt;    std::cout &amp;lt;&amp;lt; &quot;-- insert when duplicated --\n&quot;;&lt;br /&gt;    s.insert(ex);&lt;br /&gt;    std::cout &amp;lt;&amp;lt; &quot;----------------------------\n\n&quot;;&lt;br /&gt;    std::cout &amp;lt;&amp;lt; &quot;-- emplace when duplicated --\n&quot;;&lt;br /&gt;    s.emplace(ex);&lt;br /&gt;    std::cout &amp;lt;&amp;lt; &quot;-----------------------------\n\n&quot;;&lt;br /&gt;&lt;br /&gt;    /* Execution Result&lt;br /&gt;        Example(int, int) called.&lt;br /&gt;        Example(const Example&amp;amp;) called.&lt;br /&gt;        Example(int, int) called.&lt;br /&gt;        Example(int, int) called.&lt;br /&gt;&lt;br /&gt;        -- insert when not duplicated --&lt;br /&gt;        Example(const Example&amp;amp;) called.&lt;br /&gt;        --------------------------------&lt;br /&gt;&lt;br /&gt;        -- emplace when not duplicated --&lt;br /&gt;        Example(const Example&amp;amp;) called.&lt;br /&gt;        ---------------------------------&lt;br /&gt;&lt;br /&gt;        -- insert when duplicated --&lt;br /&gt;        ----------------------------&lt;br /&gt;&lt;br /&gt;        -- emplace when duplicated --&lt;br /&gt;        Example(const Example&amp;amp;) called.&lt;br /&gt;        ~Example() called.&lt;br /&gt;        -----------------------------&lt;br /&gt;&lt;br /&gt;        ~Example() called.&lt;br /&gt;        ~Example() called.&lt;br /&gt;        ~Example() called.&lt;br /&gt;        ~Example() called.&lt;br /&gt;        ~Example() called.&lt;br /&gt;        ~Example() called.&lt;br /&gt;    */&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; 위 코드를 보면 알 수 있듯이, std::set과 같이 값의 중복이 금지된 컨테이너의 경우, 생성 삽입이 그냥 삽입보다 더 느릴 수도 있다. 왜냐하면, 생성 삽입의 경우 내부적으로 중복 체크를 위해서 임시 객체를 생성하는 반면에, 그냥 삽입은 참조로서 넘어온 객체를 중복 체크를 위해 사용하기 때문이다. 따라서, 내부적으로 중복 체크를 하는 컨테이너의 경우, 무작정 생성 삽입을 사용하다가는 성능이 더 하락할 수 있음을 명심해야 한다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; 그리고 그냥 삽입과 생성 삽입 사이의 근본적인 차이에서 오는 유의점들이 있다. 첫째로, 그냥 삽입은 복사 초기화를 사용하므로 explicit 생성자를 사용 불가능한 반면, 생성 삽입은 내부적으로 직접 초기화를 사용해서 explicit 생성자를 호출할 수 있다. 따라서 그냥 삽입에서는 compiler error가 나는 것이, 생성 삽입에서는 정상적으로 컴파일될 수 있다. 두 번째로, 생성 삽입은 객체의 생성이 컨테이너 내부의 메모리까지 지연되므로, 예외 안정성 측면에서 문제가 생길 수 있다. 그냥 삽입의 경우, 객체가 바깥에서 생성이 된 뒤 컨테이너 내부에 복사되므로, 컨테이너 내부에 복사하는 과정에서 메모리 부족등의 예외가 발생해도 객체는 정상적으로 소멸된다. 그러나, 생성 삽입의 경우, 객체의 생성이 지연되므로, 컨테이너 내부에서 객체 생성 전에 예외가 발생하면, 객체 생성자의 인자들에 대한 참조를 잃게 된다. 즉, 만약 전달된 인자들 중에 new int 와 같은 것들이 있었다면, memory leak이 발생하는 것이다. 이러한 예외 안정성의 차이는 그냥 삽입은 컨테이너 외부에서 객체가 완전히 생성된 채로 들어오고, 생성 삽입은 컨테이너 내부에서 객체가 생성된다는 근본적인 차이에서 비롯되는 것이다. 따라서, 생성 삽입을 사용할 때는 예외 안정성에 대한 측면도 점검해야 할 필요가 있다. (물론, 사실 new int 와 같은 것들을 직접적으로 생성자의 인자로서 직접적으로 전달하려고 한 것 자체가 잘못이긴 하다.)&lt;br /&gt;&amp;nbsp; &amp;nbsp; 이렇듯, &#39;생성 삽입&#39; 이 &#39;삽입&#39; 보다 항상 우월한 것은 아니다. 그러나, 위에서 언급한 몇 가지 경우만 제외하면 &#39;생성 삽입&#39;이 &#39;삽입&#39;보다 나쁠 이유는 없다. 따라서 일단 기본적으로 &#39;생성 삽입&#39;을 사용하는 것을 원칙으로 하되, 내부적으로 중복 체크를 수행하는 컨테이너들에 대해서는 일반 &#39;삽입&#39;을 사용하는 것이 옳다. 그리고 explicit 생성자 관련 부분과 예외 안정성 부분의 문제는 근본적으로 생성 삽입보다 다른 곳에 근본적인 문제점이 존재하는 것이라고 생각한다. 따라서 생성 삽입을 사용하면서 다른 방법으로 해결 가능하기 때문에 이런 것들은 그냥 조심해서 사용하면 된다고 생각한다. &lt;strike&gt;(아..C++은 코드 한줄 한줄 신경쓸께 너무 많아서 짜증난다..)&lt;/strike&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- 이론적으로, 생성 삽입 함수들은 종종 해당 삽입 버전보다 더 효율적이어야 하며, 덜 효율적인 경우는 절대로 없어야 한다.&lt;br /&gt;&amp;nbsp;- 실질적으로, 만일 (1) 추가하는 값이 컨테이너로 배정되는 것이 아니라 생성되고, (2) 인수 형식(들)이 컨테이너가 담는 형식과 다르고, (3) 그 값이 중복된 값이어도 컨테이너가 거부하지 않는다면, 생성 삽입 함수가 삽입 함수보다 빠를 가능성이 아주 크다.&lt;br /&gt;&amp;nbsp;- 생성 삽입 함수는 삽입 함수라면 거부당했을 형식 변환들을 수행할 수 있다.&lt;br /&gt;&lt;br /&gt;&lt;hr /&gt;&lt;br /&gt;하... 드디어 Modern Effective C++ 포스팅이 끝났다!&lt;br /&gt;작년 이 맘쯤에 Effective C++을 포스팅했었는데, 일 년 후 Modern Effective C++을 포스팅하게 되니 감회가 새롭다.&lt;br /&gt;포스팅을 하면서 책을 다시 한번 더 읽고, 또 추가적인 자료도 찾아보고, 연구도 하고, 생각도 하고,,, 포스팅에 책 외의 내용과 통찰을 추가로 담으려고 하니 포스팅이 너무 오래 걸렸던 것 같다.. 그래도 포스팅을 하려면, 좀 더 완벽하게 modern c++의 내용들을 이해하고 의문점들을 해결해야만 했어서 C++을 좀 더 꼼꼼히 살펴볼 수 있던 계기가 된 것 같다. 그렇지만 이제 책 포스팅은 왠만하면 안 하려고 한다.. 시간이 너무 오래 걸려서...</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/6979035986582602299/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2017/05/effective-modern-c-chapter-8-4142.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/6979035986582602299'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/6979035986582602299'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2017/05/effective-modern-c-chapter-8-4142.html' title='[Effective Modern C++] Chapter 8. 다듬기 [항목 41~42]'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-8324957352893758835</id><published>2017-05-01T22:51:00.000+09:00</published><updated>2018-05-21T23:21:21.196+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="C++"/><category scheme="http://www.blogger.com/atom/ns#" term="Effective C++ Series"/><category scheme="http://www.blogger.com/atom/ns#" term="Effective Modern C++"/><category scheme="http://www.blogger.com/atom/ns#" term="From Naver Blog"/><title type='text'>[Effective Modern C++] Chapter 7. 동시성 API [항목 35~40]</title><content type='html'>&lt;h2&gt;Chapter 7. 동시성 API&lt;/h2&gt;&lt;h3&gt;항목 35. 스레드 기반 프로그래밍보다 과제 기반 프로그래밍을 선호하라.&lt;/h3&gt;확실히 과제 기반 프로그래밍은 스레드 기반 프로그래밍보다 더 쉽고 가독성이나 설계 측면에서 더 우월하다. 하지만, 과하게 마구잡이로 사용하는 것을 주의해야 한다고 느꼈다. 스레드를 쓰면 간단하게 되는 것을 과제 기반으로 하려고 억지로 짜 맞추는 것은 좋지 않다.&lt;br /&gt;그리고 과제 기반 프로그래밍은 스레드 기반 보다 더 높은 추상화로서, 내부적으로 스레드 고갈, over subscription, load balancing등의 문제를 해결해줄 수 도 있다. 실제로 현재에는 std::async가 visual studio에서는 PPL을 바탕으로 위와 같은 것을 어느 정도 해결해주고 있다. 그러나, libc++ (llvm의 std 구현)과 libstdc++ (gcc의 std구현)의 경우 비효율적인 방법으로 구현되어 있다. (관련 내용 : &lt;a href=&quot;http://rpgmakerxp.tistory.com/63&quot;&gt;http://rpgmakerxp.tistory.com/63&lt;/a&gt;)&lt;br /&gt;정말 비동기 작업을 효율적으로 진행해야 하고, 더 많은 부분들(thread priority, affinity, thread pool등)을 직접 컨트롤 해야하는 경우에는 std::async가 적합하지 않다. 이런 경우는 std::thread 혹은 Windows API / pthreads 등을 사용해야 한다.&lt;br /&gt;그리고, 아직 C++11/14의 과제 기반 프로그래밍은 빈약한 편이므로, 좀 더 본격적인 과제 기반 프로그래밍이 필요한 경우에는 TBB, PPL, HPX등을 사용하는 것이 좋아 보인다. (그러나, C++의 향후 표준들에서 점차 강력해질 것이다.)&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- std::thread API에서는 비동기적으로 실행된 함수의 반환값을 직접 얻을 수 없으며, 만일 그런 함수가 예외를 던지면 프로그램이 종료된다.&lt;br /&gt;&amp;nbsp;- 스레드 기반 프로그래밍에서는 스레드 고갈, 과다구독, 부하 균형화, 새 플랫폼으로의 적응을 독자가 직접 처리해야 한다.&lt;br /&gt;&amp;nbsp;- std::async와 기본 시동 방침을 이용한 과제 기반 프로그래밍은 그런 대부분의 문제를 알아서 처리해준다.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;항목 36. 비동기성이 필수일 때에는 std::launch::async를 지정하라.&lt;/h3&gt;그렇다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- std::async의 기본 시동 방침은 과제의 비동기적 실행과 동기적 실행을 모두 허용한다.&lt;br /&gt;&amp;nbsp;- 그러나 이러한 유연성 때문에 thread_local 접근의 불확실성이 발생하고, 과제가 절대로 실행되지 않을 수도 있고, 시간 만료 기반 wait 호출에 대한 프로그램 논리에도 영향이 미친다.&lt;br /&gt;&amp;nbsp;- 과제를 반드시 비동기적으로 실행해야 한다면 std::launch::async를 지정하라.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;항목 37. std::thread들을 모든 경로에서 합류 불가능하게 만들어라.&lt;/h3&gt;이 것은 되게 중요한 문제이다. 핵심은 단순하다. std::thread들을 모든 경로에서 합류 불가능 (unjoinable)하게 만들어야 한다. 만약 joinable한 상태에서 std::thread 객체의 소멸자가 호출되면 프로그램은 그냥 종료 되어버린다. 표준 위원회가 이런 선택을 한 것은 이유가 있다. 만약 그렇게 하지 않으려면, thread가 암묵적으로 join이 되거나 detach가 되는 방법을 채택해야 하는데, 이 것은 더 심각한 문제들을 가져올 수 있기 때문이다. 따라서 std::thread 객체는 항상 unjoinable한 상태에서 소멸되도록 표준을 제정한 것이 옳다.&lt;br /&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;#include &amp;lt;thread&amp;gt;&lt;br /&gt;#include &amp;lt;condition_variable&amp;gt;&lt;br /&gt;#include &amp;lt;iostream&amp;gt;&lt;br /&gt;#include &amp;lt;atomic&amp;gt;&lt;br /&gt;#include &amp;lt;vector&amp;gt;&lt;br /&gt;#include &amp;lt;chrono&amp;gt;&lt;br /&gt;#include &amp;lt;numeric&amp;gt;&lt;br /&gt;&lt;br /&gt;class BackgroundWorkerPool&lt;br /&gt;{&lt;br /&gt;public:&lt;br /&gt;    BackgroundWorkerPool()&lt;br /&gt;    {&lt;br /&gt;        std::cout &amp;lt;&amp;lt; &quot;[Main Thread] BackgroundWorkerPool() \n&quot;;&lt;br /&gt;        m_worker[0] = std::thread(&amp;amp;BackgroundWorkerPool::BackgroundWorkerMain, this, 1);&lt;br /&gt;        m_worker[1] = std::thread(&amp;amp;BackgroundWorkerPool::BackgroundWorkerMain, this, 2);&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    ~BackgroundWorkerPool()&lt;br /&gt;    {&lt;br /&gt;        std::cout &amp;lt;&amp;lt; &quot;[Main Thread] ~BackgroundWorkerPool() \n&quot;;&lt;br /&gt;        m_workerTerminated = true;&lt;br /&gt;        m_cvData.notify_all();&lt;br /&gt;        m_worker[0].join();&lt;br /&gt;        m_worker[1].join();&lt;br /&gt;        std::cout &amp;lt;&amp;lt; &quot;[Main Thread] After joining worker threads. \n&quot;;&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    void FeedData(const std::vector&amp;lt;int&amp;gt;&amp;amp; data)&lt;br /&gt;    {&lt;br /&gt;        {&lt;br /&gt;            std::lock_guard&amp;lt;decltype(m_mutex)&amp;gt; lk(m_mutex);&lt;br /&gt;            std::cout &amp;lt;&amp;lt; &quot;[Main Thread] Feed data. \n&quot;;&lt;br /&gt;            m_data.insert(std::end(m_data), std::begin(data), std::end(data));&lt;br /&gt;            m_dataExist = true;&lt;br /&gt;        }&lt;br /&gt;        m_cvData.notify_one();&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;private:&lt;br /&gt;    void BackgroundWorkerMain(int id)&lt;br /&gt;    {&lt;br /&gt;        while (true)&lt;br /&gt;        {&lt;br /&gt;            std::unique_lock&amp;lt;decltype(m_mutex)&amp;gt; lk(m_mutex);&lt;br /&gt;            m_cvData.wait_for(lk, std::chrono::milliseconds(3000), [this]() {&lt;br /&gt;                return m_dataExist || m_workerTerminated;&lt;br /&gt;            });&lt;br /&gt;&lt;br /&gt;            std::cout &amp;lt;&amp;lt; &quot;[Worker Thread &quot; &amp;lt;&amp;lt; id &amp;lt;&amp;lt; &quot;] Wake up! \n&quot;;&lt;br /&gt;&lt;br /&gt;            if (m_workerTerminated)&lt;br /&gt;                break;&lt;br /&gt;&lt;br /&gt;            std::cout &amp;lt;&amp;lt; &quot;[Worker Thread &quot; &amp;lt;&amp;lt; id &amp;lt;&amp;lt; &quot;] WORK! \n&quot;;&lt;br /&gt;            auto result = std::accumulate(std::begin(m_data), std::end(m_data), 0);&lt;br /&gt;            std::cout &amp;lt;&amp;lt; &quot;[Worker Thread &quot; &amp;lt;&amp;lt; id &amp;lt;&amp;lt; &quot;] Result = &quot; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; &quot; \n&quot;;&lt;br /&gt;            m_data.clear();&lt;br /&gt;            m_dataExist = false;&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        std::cout &amp;lt;&amp;lt; &quot;[Worker Thread &quot; &amp;lt;&amp;lt; id &amp;lt;&amp;lt; &quot;] I&#39;m terminated. \n&quot;;&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    std::mutex m_mutex;&lt;br /&gt;    std::atomic&amp;lt;bool&amp;gt; m_workerTerminated{ false };&lt;br /&gt;    std::vector&amp;lt;int&amp;gt; m_data;&lt;br /&gt;    bool m_dataExist{ false };&lt;br /&gt;    std::condition_variable m_cvData;&lt;br /&gt;    std::thread m_worker[2];&lt;br /&gt;};&lt;br /&gt;&lt;br /&gt;int main()&lt;br /&gt;{&lt;br /&gt;    BackgroundWorkerPool workerPool;&lt;br /&gt;    std::this_thread::sleep_for(std::chrono::milliseconds(500));&lt;br /&gt;    workerPool.FeedData({ 1,2,3,4,5,6,7,8 });&lt;br /&gt;    workerPool.FeedData({ 1 });&lt;br /&gt;    std::this_thread::sleep_for(std::chrono::milliseconds(500));&lt;br /&gt;    workerPool.FeedData({ 1,2,3,4,5 });&lt;br /&gt;    std::this_thread::sleep_for(std::chrono::milliseconds(500));&lt;br /&gt;    workerPool.FeedData({ 1,2 });&lt;br /&gt;    workerPool.FeedData({ 1,2,3,4,5,6,7,8,9 });&lt;br /&gt;    std::this_thread::sleep_for(std::chrono::milliseconds(500));&lt;br /&gt;    workerPool.FeedData({ 1,2,3,4,5,6,7,8,9,10,11,12 });&lt;br /&gt;    std::this_thread::sleep_for(std::chrono::milliseconds(500));&lt;br /&gt;&lt;br /&gt;    /* Execution Result&lt;br /&gt;        [Main Thread] BackgroundWorkerPool()&lt;br /&gt;        [Main Thread] Feed data.&lt;br /&gt;        [Main Thread] Feed data.&lt;br /&gt;        [Worker Thread 2] Wake up!&lt;br /&gt;        [Worker Thread 2] WORK!&lt;br /&gt;        [Worker Thread 2] Result = 37&lt;br /&gt;        [Main Thread] Feed data.&lt;br /&gt;        [Worker Thread 2] Wake up!&lt;br /&gt;        [Worker Thread 2] WORK!&lt;br /&gt;        [Worker Thread 2] Result = 15&lt;br /&gt;        [Main Thread] Feed data.&lt;br /&gt;        [Main Thread] Feed data.&lt;br /&gt;        [Worker Thread 1] Wake up!&lt;br /&gt;        [Worker Thread 1] WORK!&lt;br /&gt;        [Worker Thread 1] Result = 48&lt;br /&gt;        [Main Thread] Feed data.&lt;br /&gt;        [Worker Thread 1] Wake up!&lt;br /&gt;        [Worker Thread 1] WORK!&lt;br /&gt;        [Worker Thread 1] Result = 78&lt;br /&gt;        [Main Thread] ~BackgroundWorkerPool()&lt;br /&gt;        [Worker Thread 2] Wake up!&lt;br /&gt;        [Worker Thread 2] I&#39;m terminated.&lt;br /&gt;        [Worker Thread 1] Wake up!&lt;br /&gt;        [Worker Thread 1] I&#39;m terminated.&lt;br /&gt;        [Main Thread] After joining worker threads.&lt;br /&gt;    */&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; Thread를 합류 불가능하게 만들려면, thread를 detach하거나 join해야 한다. 근데, detach를 하는 것은 깔끔하지 못한 일종의 꼼수책이다. 따라서 join을 해서 끝내는 것이 깔끔하고 더 일반적인 방법인데 이 방법을 사용하려면, thread를 외부에서 종료 시킬 수 있어야 한다. Windows API의 TerminatedThread 같은 것을 이용해서 강제적으로 종료 시키면 각종 많은 문제들이 발생하기 때문에 graceful stop을 구현해야만 한다. 나는 보통 위 코드와 같이 구현해서 사용한다. 이 때 blocking I/O같이 infinite하게 blocking되는 함수 호출이나, 오랜 시간이 걸리는 연산을 수행하는 코드를 주의해야 한다. 즉, 수시로 termination 여부를 polling 할 수 있어야 하고, 이러한 polling의 간격이 곧 thread termination 요청을 하고 나서 실제 join이 될 때 까지의 응답 시간이 된다. 위 코드의 BackgroundWorkerPool의 소멸자에서 m_cvData.notify_all(); 를 한 것과 같이 thread 내의 blocking operation을 직접 깨울 수 있는 방법이 있을 때는 그러한 응답 시간을 더 줄일 수 있다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; 아무튼 나는 위 코드와 같은 방법을 사용하는 데, 더 좋은 방법이 있는 지는 잘 모르겠다. 혹시 이 글을 보는 분들 중 더 좋은 방법을 아는 분이 계시면 알려주시면 감사하겠다. (C++ Concurrency in action 책에 interruptible thread 라는 개념이 등장한다던데 결국 근본적으로는 내가 쓰는 방법과 같은 것으로 보인다.)&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- 모든 경로에서 std::thread를 합류 불가능으로 만들어라.&lt;br /&gt;&amp;nbsp;- 소멸 시 join 방식은 디버깅하기 어려운 성능 이상으로 이어질 수 있다.&lt;br /&gt;&amp;nbsp;- 소멸 시 detach 방식은 디버깅하기 어려운 미정의 행동으로 이어질 수 있다.&lt;br /&gt;&amp;nbsp;- 자료 멤버 목록에서 std::thread 객체를 마지막에 선언하라.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;항목 38. 스레드 핸들 소멸자들의 다양한 행동 방식을 주의하라.&lt;/h3&gt;std::thread와 비지연 과제에 대한 미래 객체는 시스템 스레드에 대응된다는 점에서 모두 &#39;시스템 스레드 핸들&#39; 이라고 말할 수 있다. 이러한 스레드 핸들의 소말자에 행동 방식에 대해 다루는 것이 이 항목이다. 일단 std::thread의 소멸자에 대한 부분은 항목 37에서 다루고 있다. 그러므로 이 항목에서는 미래 객체 소멸자의 행동 방식들에 대해 다룬다.&lt;br /&gt;행동 방식은 제각각인 것처럼 보일 수 있지만, 사실 핵심은 간단하다.&lt;br /&gt;&lt;b&gt;&quot;시스템 스레드과 대응되는 유일한 미래객체일 경우에만, 시스템 스레드에 대해 암묵적 join을 수행한다. 그 외의 경우에는 그냥 바로 객체가 소멸된다.&quot;&lt;/b&gt;&lt;br /&gt;즉, 어떤 미래 객체가 소멸자에서 암묵적 join을 수행할 지, 아니면 그냥 바로 객체가 소멸되고 끝날 지 판단하는 것은 이 미래 객체가 시스템 스레드와 대응되는 유일한 미래 객체인지만 생각해보면 된다.&lt;br /&gt;몇 가지 케이스를 통해 살펴보자.&lt;br /&gt;1. 지연된 과제에 대한 미래 객체&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 대응되는 시스템 스레드가 없으므로 바로 객체가 소멸된다.&lt;br /&gt;2. std::async (with std::launch::async) 호출에 의해 생성된 공유 상태를 참조하는 std::future&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 비동기적으로 실행된 과제의 공유 상태에 유일하게 대응되는 미래 객체이므로 암묵적 join이 수행된 뒤 객체가 소멸된다.&lt;br /&gt;3. std::async (with std::launch::async) 호출에 의해 생성된 공유 상태를 참조하는 std::shared_future&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 여러 개의 std::shared_future가 공유 상태를 참조하고 있을 것이다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 따라서 공유 상태를 참조하고 있는 마지막 std::shared_future 만 암묵적 join이 수행된다.&lt;br /&gt;4. std::packaged_task가 std::thread에 의해 실행되고 있을 때, std::packaged_task으로 부터 얻어진 std::future&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 시스템 스레드가 std::thread에 대응되므로, std::future는 시스템 스레드에 대한 책임이 없다. 따라서 바로 객체가 소멸된다.&lt;br /&gt;&lt;br /&gt;즉, 결과적으로만 보면 &quot;std::async를 통해서 시동된 비지연(지연되지 않은) 과제에 대한 공유 상태를 참조하는 마지막 미래 객체의 소멸자&quot;의 경우에만 과제가 완료될 때까지 차단 (즉, 암묵적 join) 되는 것이다.&lt;br /&gt;하지만, 이 것의 근본적인 이유는 위에서 말한 &#39;핵심&#39; 때문이다.&lt;br /&gt;그리고 더 나아가면 사실 std::thread 소멸자의 행동 방식과도 일맥상통하는 원리를 얻을 수 있다.&lt;br /&gt;&lt;b&gt;결국에는 시스템 스레드 (바탕 스레드)에 대응되는 마지막 핸들이 시스템 스레드를 책임져야하는 것인데, 시스템 스레드가 종료되기 전에 핸들(객체)가 소멸될 경우, 바로 객체가 소멸되지 않고 특별한 행동이 일어나는 것이다.&lt;/b&gt;&lt;br /&gt;그리고 그 특별한 행동은 std::thread의 경우에는 프로그램 종료, 미래 객체의 경우에는 암묵적 join인 것이다.&lt;br /&gt;다만, 표준위원회가 왜 std::thread와 미래 객체에 대해 특별한 행동으로서 서로 다른 것을 선택했는지는 잘 모르겠다.&lt;br /&gt;아무튼, 나는 그래서 std::thread는 항상 unjoinable한 상태에서만 소멸할 수 있도록 코드를 짜고, 미래 객체가 소멸하면서 암시적 join이 일어날 수 있는 곳에는 주석으로서 그 사실을 명시한다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- 미래 객체의 소멸자는 그냥 미래 객체의 자료 멤버들을 파괴할 뿐이다.&lt;br /&gt;&amp;nbsp;- std::async를 통해 시동된 비지연 과제에 대한 공유 상태를 참조하는 마지막 미래 객체의 소멸자는 그 과제가 완료될 때까지 차단된다.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;항목 39. 단발성 사건 통신에는 void 미래 객체를 고려하라.&lt;/h3&gt;일반적으로 thread 사이에서 어떤 사건(이벤트)를 통지하거나 흐름을 통제하고 싶을 경우, condition variable과 flag 변수가 조합되어 사용된다. 그러나 단발성 사건 통신의 경우에는 void 미래 객체를 활용하면 훨씬 간단하고 깔끔하게 설계가 가능하다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- 간단한 사건 통신을 수행할 때, 조건 변수 기반 설계에는 여분의 뮤텍스가 필요하고, 검출 과제와 반응 과제의 진행 순서에 제약이 있으며, 사건이 실제로 발생했는지를 반응 과제가 다시 확인해야 한다.&lt;br /&gt;&amp;nbsp;- 플래그 기반 설계를 사용하면 그런 단점들이 없지만, 대신 차단이 아니라 폴링이 일어난다는 단점이 있다.&lt;br /&gt;&amp;nbsp;- 조건 변수와 플래그를 조합할 수 도 있으나, 그런 조합을 이용한 통신 메커니즘은 필요 이상으로 복잡하다.&lt;br /&gt;&amp;nbsp;- std::promise와 미래 객체를 사용하면 이러한 문제점들을 피할 수 있지만, 그런 접근방식은 공유 상태에 힙 메모리를 사용하며, 단발성 통신만 가능하다.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;항목 40. 동시성에는 std::atomic을 사용하고, volatile은 특별한 메모리에 사용하라.&lt;/h3&gt;동시성에 있어서 그냥 일반적인 변수를 사용할 때 데이터 레이스등의 문제가 발생하는 이유는 다음과 같다.&lt;br /&gt;1. 변수가 레지스터에 할당(캐시) 될 수 있다.&lt;br /&gt;2. Compiler instruction reordering에 의해 memory access의 순서가 바뀔 수 있다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; - A; B; 와 같은 코드가 compiler에 의해 B; A; 와 같이 순서가 바뀔 수 있다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; - &lt;a href=&quot;http://preshing.com/20120625/memory-ordering-at-compile-time/&quot;&gt;http://preshing.com/20120625/memory-ordering-at-compile-time/&lt;/a&gt;&lt;br /&gt;3. Memory visibility가 보장되지 않을 수 있다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 프로세서의 out of order execution등에 의해 memory visibility가 보장되지 않을 수 있다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 프로세서마다 memory consistency model이 다르다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; - &lt;a href=&quot;http://preshing.com/20120930/weak-vs-strong-memory-models/&quot;&gt;http://preshing.com/20120930/weak-vs-strong-memory-models/&lt;/a&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; - &lt;a href=&quot;http://www.kandroid.org/board/board.php?board=AndroidBeginner&amp;amp;command=body&amp;amp;no=102&quot;&gt;http://www.kandroid.org/board/board.php?board=AndroidBeginner&amp;amp;command=body&amp;amp;no=102&lt;/a&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; - &lt;a href=&quot;http://egloos.zum.com/studyfoss/v/5141402&quot;&gt;http://egloos.zum.com/studyfoss/v/5141402&lt;/a&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; - &lt;a href=&quot;http://stackoverflow.com/questions/7346893/out-of-order-execution-and-memory-fences&quot;&gt;http://stackoverflow.com/questions/7346893/out-of-order-execution-and-memory-fences&lt;/a&gt; (x86)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; 이 3가지 이유중에 &#39;표준&#39; volatile&#39;은 오직 1번 밖에 해결하지 못한다. 그러나 몇몇 컴파일러들을 volatile keyword에 대해 추가적으로 다른 문제점들을 해결해주기도 한다. 하지만, 표준적으로는 volatile을 동시성에 사용하는 것은 매우 위험한 행위이고, 위의 3가지 문제를 모두 해결하려면 C++11이후의 memory fense, std::atomic 등의 기능을 사용해야만 한다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; 그렇다고 std::atomic이 volatile의 기능을 포함하고 있다는 식으로 착각하면 안된다. 예를 들면, x = 1; x = 2; 와 같은 코드의 경우, x가 volatile로 선언되있을 경우에는 최적화가 발생하지 않지만, x가 std::atomic인 경우 x = 2; 와 같은 식으로 최적화가 진행 될 수 있다. 따라서, volatile과 std::atomic은 포함 관계가 아닌 아예 서로 다른 역할과 기능을 가지고 있는 것으로 인식 하는 것이 옳다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; 또 특별히 우리가 많이 사용하는 x86 의 경우에는 강력한 memory consistency model을 가지고 있다. 따라서 read-after-write의 경우를 제외하면 sequentially consistency를 가지고 있다고 할 수 있다. (자세한 건 위 링크들 참조) 따라서, 그냥 동시성을 위해 volatile을 써도 평소에 큰 문제가 생기지 않았을 가능성이 크고, 이에 따라 많은 사람들이 동시성에 volatile을 사용하는 실수와 착각을 하고 있다고 생각한다. (나도 과거에 그런 착각을 하던 시절이 있었다.)&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- std::atomic은 뮤텍스 보호 없이 여러 스레드가 접근하는 자료를 위한 것으로, 동시적 소프트웨어의 작성을 위한 도구이다.&lt;br /&gt;&amp;nbsp;- volatile은 읽기와 기록을 최적화로 제거하지 말아야 하는 메모리를 위한 것으로, 특별한 메모리를 다룰 때 필요한 도구이다.&lt;br /&gt;&lt;br /&gt;&lt;hr /&gt;&lt;br /&gt;Concurrency 너무 좋아!</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/8324957352893758835/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2017/05/effective-modern-c-chapter-7-api-3540.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/8324957352893758835'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/8324957352893758835'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2017/05/effective-modern-c-chapter-7-api-3540.html' title='[Effective Modern C++] Chapter 7. 동시성 API [항목 35~40]'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-9180781047884068662</id><published>2017-04-22T22:47:00.000+09:00</published><updated>2018-05-21T23:21:21.277+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="C++"/><category scheme="http://www.blogger.com/atom/ns#" term="Effective C++ Series"/><category scheme="http://www.blogger.com/atom/ns#" term="Effective Modern C++"/><category scheme="http://www.blogger.com/atom/ns#" term="From Naver Blog"/><title type='text'>[Effective Modern C++] Chapter 6. 람다 표현식 [항목 31~34]</title><content type='html'>&lt;h2&gt;Chapter 6. 람다 표현식&lt;/h2&gt;&lt;h3&gt;항목 31. 기본 갈무리 모드를 피하라.&lt;/h3&gt;참고로, 갈무리는 &#39;capture&#39;를 의미한다. (첨엔 어색했으나 나도 이제 완전히 이 번역에 익숙해져버렸다.)&lt;br /&gt;기본 갈무리 모드 (default capture mode)는 &#39;참조 갈무리 모드&#39;와 &#39;값 갈무리 모드&#39;가 있다. 기본 갈무리 모드를 피해야 하는 이유는 크게 dangling reference 위험과 명시적이지 않다는 점(그래서 착각/실수 할 수 있다는 점) 때문이다.&lt;br /&gt;일단, 참조 갈무리 모드에서 dangling reference 문제가 발생할 수 있다는 것은 너무 당연하고, 값 갈무리 모드에서도 pointer가 capture되는 경우에 그러한 문제가 발생 할 수 있다는 것은 당연하다.&lt;br /&gt;사실 결정적인 문제는 명시적이지 않다는 점이다. 이로 인해 문제가 발생 할 수 있을 만한 상황을 정리하면 다음과 같다.&lt;br /&gt;1. this pointer의 캡처&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 숨겨져있던 this pointer가 캡처됨으로 인해 dangling pointer 등의 문제가 발생할 수 있다.&lt;br /&gt;2. 람다표현식을 복붙(Copy&amp;amp;Paste) 할 경우, 실수할 가능성이 커진다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 유용한 람다표현식을 그대로 다른 곳에서 쓸 경우가 있을 수 있다. 이 경우, capture list가 명시적이지 않아서 문제들이 발생할 소지가 있다.&lt;br /&gt;3. 전역 변수나 static 같이 global scope를 가진 변수들 (즉, non-automatic variable들)의 값이 복사로서 capture될 것이라는 착각을 할 수 있다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 오직 automatic variable들(즉, 지역변수들) 만 capture될 수 있는데, 기본 값 갈무리 모드를 사용하면, non-automatic variable들도 값 복사로서 capture될 것이라는 착각을 할 여지가 있다.&lt;br /&gt;&lt;br /&gt;즉, 기본 갈무리 모드의 문제는 결국 &#39;명시적이지 않다&#39;는 것이다. 필요한 것들만 명시적으로 capture해주는 게 더 좋은 코드라고 할 수 있겠다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- 기본 참조 갈무리는 참조가 대상을 잃을 위험이 있다.&lt;br /&gt;&amp;nbsp;- 기본 값 갈무리는 포인터(특히 this)가 대상을 잃을 수 있으며, 람다가 자기 완결적이라는 오해를 부를 수 있다.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;항목 32. 객체를 클로저 안으로 이동하려면 초기화 갈무리를 사용하라.&lt;/h3&gt;std::unique_ptr, std::future, std::future과 같이 이동 전용인 경우나 효율성 측면에서 이동이 필요할 경우, 클로저안으로 객체를 이동할 수 있어야 한다.&lt;br /&gt;일단 C++14에서는 초기화 갈무리 (init capture)를 사용하면 되므로 너무 쉽다.&lt;br /&gt;그러나 C++11에서는 초기화 갈무리가 없으므로 문제다. (C++11 얘기하기 너무 싫다... 맘편히 C++14이상만 생각하고 싶다!!!)&lt;br /&gt;이에 대한 해결책은 다음과 같다.&lt;br /&gt;1. Functor를 만들어서 해결한다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 당연히 이렇게 하면 가능하긴 하지만... 이건 람다가 아니잖아?! 빼애애액&lt;br /&gt;2. std::bind를 활용한다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; - std::bind를 통해 람다의 매개변수에 왼값 참조로서 이동된 객체를 묶는다. (아래 코드 참고)&lt;br /&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;#include &amp;lt;memory&amp;gt;&lt;br /&gt;#include &amp;lt;functional&amp;gt;&lt;br /&gt;#include &amp;lt;iostream&amp;gt;&lt;br /&gt;&lt;br /&gt;class Example {};&lt;br /&gt;&lt;br /&gt;int main()&lt;br /&gt;{&lt;br /&gt;    std::unique_ptr&amp;lt;Example&amp;gt; p;&lt;br /&gt;&lt;br /&gt;    auto func_in_cpp_11 = std::bind(&lt;br /&gt;        [](const std::unique_ptr&amp;lt;Example&amp;gt;&amp;amp; p) {&lt;br /&gt;            std::cout &amp;lt;&amp;lt; &quot;I&#39;m an example in C++11 :(&quot; &amp;lt;&amp;lt; std::endl;&lt;br /&gt;        },&lt;br /&gt;        std::move(p)&lt;br /&gt;    );&lt;br /&gt;&lt;br /&gt;    auto func_in_cpp_14 = [p = std::move(p)]() {&lt;br /&gt;        std::cout &amp;lt;&amp;lt; &quot;I&#39;m an example in C++14 :)&quot; &amp;lt;&amp;lt; std::endl;&lt;br /&gt;    };&lt;br /&gt;&lt;br /&gt;    func_in_cpp_11();&lt;br /&gt;    func_in_cpp_14();&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;void lambda_mutable_test()&lt;br /&gt;{&lt;br /&gt;    class Lambda&lt;br /&gt;    {&lt;br /&gt;        int&amp;amp; a;&lt;br /&gt;        int b;&lt;br /&gt;    public:&lt;br /&gt;        Lambda(int &amp;amp;a, int b) : a(a), b(b) {}&lt;br /&gt;        void operator()() const {&lt;br /&gt;            a = 1;&lt;br /&gt;            b = 2;  // Compiler Error&lt;br /&gt;        }&lt;br /&gt;    };&lt;br /&gt;&lt;br /&gt;    int a, b;&lt;br /&gt;    [&amp;amp;a, b]() {&lt;br /&gt;        a = 1;&lt;br /&gt;        b = 2;  // Compiler Error&lt;br /&gt;    };&lt;br /&gt;    Lambda lambda(a, b); lambda();&lt;br /&gt;&lt;br /&gt;    ////////////////////////////////////////////&lt;br /&gt;    // Think &quot;int &amp;amp;&quot; is similar to &quot;const int *&quot;.&lt;br /&gt;&lt;br /&gt;    class MutableLambda&lt;br /&gt;    {&lt;br /&gt;        int &amp;amp; a;&lt;br /&gt;        int b;&lt;br /&gt;    public:&lt;br /&gt;        MutableLambda(int &amp;amp;a, int b) : a(a), b(b) {}&lt;br /&gt;        void operator()() {&lt;br /&gt;            a = 1;&lt;br /&gt;            b = 2;&lt;br /&gt;        }&lt;br /&gt;    };&lt;br /&gt;&lt;br /&gt;    int a, b;&lt;br /&gt;    [&amp;amp;a, b]() mutable {&lt;br /&gt;        a = 1;&lt;br /&gt;        b = 2;&lt;br /&gt;    };&lt;br /&gt;    MutableLambda mutableLambda(a, b); mutableLambda();&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;br /&gt;이번 항목에 직접적인 연관은 없지만, Lambda mutable에 관한 간단한 실험 코드도 같이 첨부하였다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- 객체를 클로저 안으로 이동할 때에는 C++14의 초기화 갈무리를 사용하라.&lt;br /&gt;&amp;nbsp;- C++11에서는 직접 작성한 클래스나 std::bind로 초기화 갈무리를 흉내 낼 수 있다.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;항목 33. std::forward를 통해서 전달할 auto&amp;amp;&amp;amp; 매개변수에는 decltype을 사용하라.&lt;/h3&gt;이번 항목은 C++14에만 해당하는 내용이다. C++14에 generic lambdas가 추가되면서, 매개변수 명세에 auto를 사용할 수 있게 되었다. 만약 lambda 내에서 perfect forwarding을 하고 싶을 경우, std::forward&amp;lt;decltype(...)&amp;gt;(...) 처럼 하면 된다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- std::forward를 통해서 전달할 auto&amp;amp;&amp;amp; 매개변수에는 decltype을 사용하라.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;항목 34. std::bind보다 람다를 선호하라.&lt;/h3&gt;std::bind보다 람다를 선호해야 할 이유는 &#39;가독성&#39;과 &#39;성능&#39;이다.&lt;br /&gt;일단 가독성 측면에서, std::bind로 하려면 난해하고 복잡한 것을 람다로는 간단하고 명료하게 할 수 있다.&lt;br /&gt;그리고, 최적화 가능성이 람다가 더 많기 때문에 성능 측면에서도 std::bind보다 람다가 우월하다. (자세한 건 아래 참조)&lt;br /&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;/*&lt;br /&gt;    https://godbolt.org/g/25uYMS&lt;br /&gt;*/&lt;br /&gt;&lt;br /&gt;#include &amp;lt;vector&amp;gt;&lt;br /&gt;#include &amp;lt;functional&amp;gt;&lt;br /&gt;&lt;br /&gt;class Functor {&lt;br /&gt;private:&lt;br /&gt;    int a;&lt;br /&gt;    int b;&lt;br /&gt;public:&lt;br /&gt;    Functor(int a, int b) : a(a), b(b) {}&lt;br /&gt;    bool operator()(int n) const { return a &amp;lt; n &amp;amp;&amp;amp; n &amp;lt; b; }&lt;br /&gt;};&lt;br /&gt;&lt;br /&gt;bool comp(int a, int b, int n) { return a &amp;lt; n &amp;amp;&amp;amp; n &amp;lt; b; }&lt;br /&gt;&lt;br /&gt;bool test_bind_function_pointer(int a, int b, int c)&lt;br /&gt;{&lt;br /&gt;    auto bind_func = std::bind(comp, a, b, std::placeholders::_1);&lt;br /&gt;    std::vector&amp;lt;decltype(bind_func)&amp;gt; vec;&lt;br /&gt;    vec.emplace_back(bind_func);&lt;br /&gt;    return vec.back()(c);&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;bool test_bind_functor(int a, int b, int c)&lt;br /&gt;{&lt;br /&gt;    auto bind_func = std::bind(Functor(a, b), std::placeholders::_1);&lt;br /&gt;    std::vector&amp;lt;decltype(bind_func)&amp;gt; vec;&lt;br /&gt;    vec.emplace_back(bind_func);&lt;br /&gt;    return vec.back()(c);&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;bool test_functor(int a, int b, int c)&lt;br /&gt;{&lt;br /&gt;    std::vector&amp;lt;Functor&amp;gt; vec;&lt;br /&gt;    vec.emplace_back(a, b);&lt;br /&gt;    return vec.back()(c);&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;bool test_lambda(int a, int b, int c)&lt;br /&gt;{&lt;br /&gt;    auto lambda = [a, b](int n) { return a &amp;lt; n &amp;amp;&amp;amp; n &amp;lt; b; };&lt;br /&gt;    std::vector&amp;lt;decltype(lambda)&amp;gt; vec;&lt;br /&gt;    vec.emplace_back(lambda);&lt;br /&gt;    return vec.back()(c);&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;int main() &lt;br /&gt;{&lt;br /&gt;    test_bind_function_pointer(1, 2, 3);&lt;br /&gt;    test_bind_functor(1, 2, 3);&lt;br /&gt;    test_functor(1, 2, 3);&lt;br /&gt;    test_lambda(1, 2, 3);&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; 위 코드는 std::bind와 lambda의 최적화를 비교하기 위해 작성한 코드로서, &lt;a href=&quot;https://godbolt.org/g/25uYMS&quot;&gt;https://godbolt.org/g/25uYMS&lt;/a&gt; 에서 assemble된 결과를 볼 수 있다. gcc 6.3 -O3 -std=c++14 에서의 결과를 분석해보겠다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; 일단 test_bind_function_pointer의 경우를 보면, std::bind 에 function pointer를 넘겨주기 때문에 어셈블리 상에서 call [QWORD PTR [rax-16]] 와 같이 동작하는 것을 볼 수 있다. 이러한 동작은 std::bind의 반환형이 std::_Bind&amp;lt;bool (*(int, int, std::_Placeholder&amp;lt;1&amp;gt;))(int, int, int)&amp;gt; 라는 것에 기인한다. callable object 부분의 type이 function pointer이므로 이와 같이 동작할 수 밖에 없는 것이다. 그러나 사실 그냥 comp를 호출하거나 comp를 inlining 하도록 최적화되기를 바랄 것이다. 실제로 똑같은 코드를 clang으로 컴파일할 경우, 이러한 최적화를 수행해줌을 확인할 수 있다. 하지만, 이러한 최적화를 범용적으로 기대하는 것은 힘들다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; 두 번째로, test_bind_functor 같은 경우는 std::bind가 반환하는 타입이 std::_Bind&amp;lt;Functor (std::_Placeholder&amp;lt;1&amp;gt;) 이다. 즉, 호출될 functor object의 타입이 class로서 명확히 드러나므로, Functor::operator() 를 직접적으로 호출하거나 이 것이 inlining 될 것임을 기대할 수 있다. test_functor 도 마찬가지 이유에서 최적화를 기대할 수 있다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; 마지막으로, test_lambda 이다. 이 경우, 가장 많은 최적화가 된 것을 볼 수 있다. lambda는 내부적으로 functor 로서 구현된다. 그런데 유독 람다의 경우 최적화가 더 많이 되는 이유는 무엇일까? 그 것은 바로 람다의 경우는 컴파일러가 자동적으로 생성하는 functor 를 사용하기 때문이다. 즉, test_bind_functor 나 test_functor 에서는 사용자가 정의한 functor 를 사용하므로 컴파일러가 사용자 타입에 대해 자세히 알지 못하지만, 람다의 경우 functor 를 컴파일러가 만들기 때문에 더 많은 정보를 가질 수 있고, 이로 인해 더 많은 최적화를 수행할 수 있다.&lt;br /&gt;&lt;br /&gt;즉, 결론적으로 이러한 이유에서 std::bind보다 람다를 선호해야한다.&lt;br /&gt;그러나 C++11에서는 어쩔 수 없이 std::bind를 활용해야 하는 경우가 다음과 같이 2가지 있다.&lt;br /&gt;1. move semantics의 활용 (항목 32에서 다룸)&lt;br /&gt;2. polymorphic function object&lt;br /&gt;그러나, C++14에서는 각각 초기화 갈무리와 generic lambdas에 의해 해결되었으므로, C++14부터는 람다를 적극 사용해야 한다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- std::bind를 사용하는 것보다 람다가 더 읽기 쉽고 표현력이 좋다. 그리고 더 효율적일 수 있다.&lt;br /&gt;&amp;nbsp;- C++14가 아닌 C++11에서는 이동 갈무리를 구현하거나 객체를 템플릿화된 함수 호출 연산자에 묶으려 할 때 std::bind가 유용할 수 있다.&lt;br /&gt;&lt;br /&gt;&lt;hr /&gt;&lt;br /&gt;재밌는 4분짜리 영상으로 포스팅을 마치겠습니다~ 람다 만세!!!&lt;br /&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=3wm5QzdddYc&quot;&gt;https://www.youtube.com/watch?v=3wm5QzdddYc&lt;/a&gt;</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/9180781047884068662/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2017/04/effective-modern-c-chapter-6-3134.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/9180781047884068662'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/9180781047884068662'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2017/04/effective-modern-c-chapter-6-3134.html' title='[Effective Modern C++] Chapter 6. 람다 표현식 [항목 31~34]'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-8269385016145187612</id><published>2017-04-20T16:45:00.000+09:00</published><updated>2018-05-20T22:14:38.491+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Compiler"/><category scheme="http://www.blogger.com/atom/ns#" term="From Naver Blog"/><category scheme="http://www.blogger.com/atom/ns#" term="Interpreter"/><category scheme="http://www.blogger.com/atom/ns#" term="JIT"/><category scheme="http://www.blogger.com/atom/ns#" term="LLVM"/><category scheme="http://www.blogger.com/atom/ns#" term="PyPy"/><category scheme="http://www.blogger.com/atom/ns#" term="Python"/><category scheme="http://www.blogger.com/atom/ns#" term="RPython"/><category scheme="http://www.blogger.com/atom/ns#" term="VM"/><title type='text'>PyPy RPython Translation Toolchain</title><content type='html'>&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;그 동안 PyPy를 단순히 JIT을 지원하는 빠른 python implementation 이라고만 알고 있었다.&lt;/span&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;그런데 알고 보니 단순한 python implementation 이상의 의미를 갖는 상당히 멋있는 프로젝트였다.&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;&lt;/span&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;PyPy는 2가지 파트로 나뉜다.&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;1. RPython 문법으로 작성된 Python Interpreter&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;2. RPython Translation Toolchain&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;1번의 python interpreter를 2번의 toolchain에 넣으면, JIT, garbage collector 등의 기능이 첨가된 C언어로 된 interpreter가 결과로서 나온다.&lt;/span&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;???!!&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;매우 놀라울 것이다. 2번의 toolchain은 Python 소스 코드나 syntax&amp;nbsp;trees 에 대한 정보는 전혀 가지고 있지 않는다. 그런데 JIT과 garbage collector를 비롯한 기능들을 첨가해준다니?!&lt;/span&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;&lt;/span&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;그래서 내가 멋있다고 한 것이다...&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;img src=&quot;https://uploads.toptal.io/blog/image/129/toptal-blog-B.png&quot; /&gt;&lt;br /&gt;(출처 : https://www.toptal.com/python/why-are-there-so-many-pythons)&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;PyPy의 구조를 그림으로 보자면 위와 같다. (PyPy Interpreter가 1번, PyPy compiler가 2번에 해당한다.)&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;img src=&quot;https://rpython.readthedocs.io/en/latest/_images/translation-greyscale-small.png&quot; /&gt;&lt;br /&gt;(출처 : http://rpython.readthedocs.io/en/latest/translation.html)&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;RPython translation toolchain의 실제 플로우를 그림으로 보자면 위와 같다. 기본적으로 RPython으로 작성된 interpreter 코드가 필요하고 추가적으로 low level hint들을 통해 세부적인 과정에 참여할 수 있다. 그리고 translation toolchain의 backend는 현재 C언어만 가능하지만, 설계 상 더 추가가 가능한 구조이다.&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;그리고 이러한 RPython Translation Toolchain을 이용하면 Python 뿐만 아니라 모든 언어들의 &#39;JIT&#39;ed Interpreter를 얻을 수 있다.&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;&lt;a class=&quot;se_link&quot; href=&quot;https://bitbucket.org/brownan/pypy-tutorial/src/cbd43582d96947c4150109a21c7b2e828a92b64f/example2.py&quot; style=&quot;color: rgb(96, 140, 186) !important;&quot; target=&quot;_blank&quot;&gt;https://bitbucket.org/brownan/pypy-tutorial/src/cbd43582d96947c4150109a21c7b2e828a92b64f/example2.py&lt;/a&gt;&lt;/span&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;위 소스코드는 아주 아주 간단한 언어의 interpreter이다. 보면 그냥 python으로 작성된 interpreter처럼 보일 것이다.&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;그러나 사실은 rpython으로 작성된 interpreter이고, 이 interpreter를 translation toolchain에 의해 translate가능하다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;(관련 링크 :&amp;nbsp;&lt;a class=&quot;se_link&quot; href=&quot;https://morepypy.blogspot.kr/2011/04/tutorial-writing-interpreter-with-pypy.html&quot; style=&quot;color: rgb(96, 140, 186) !important;&quot; target=&quot;_blank&quot;&gt;https://morepypy.blogspot.kr/2011/04/tutorial-writing-interpreter-with-pypy.html&lt;/a&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;참 마법같다. 이러한 마법을 이용해서 만들어지는 다양한 interpreter들이 있다. (그 중에 하나가 PyPy인 것이다.)&lt;/span&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;(관련 링크 :&amp;nbsp;&lt;a class=&quot;se_link&quot; href=&quot;http://rpython.readthedocs.io/en/latest/examples.html&quot; style=&quot;color: rgb(96, 140, 186) !important;&quot; target=&quot;_blank&quot;&gt;http://rpython.readthedocs.io/en/latest/examples.html&lt;/a&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;background-color: white; font-size: 16px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&quot;background-color: white; font-size: 16px;&quot;&gt;RPython Translation Toolchain을 활용하면 interpreter 언어의 개발이 쉬워질 것으로 보인다.&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;background-color: white; font-family: , &amp;quot;nanumgothic&amp;quot; , &amp;quot;se_nanumgothic&amp;quot; , &amp;quot;applesdgothicneo&amp;quot; , sans-serif , &amp;quot;simhei&amp;quot;; font-size: 16px;&quot;&gt;LLVM도 그렇고, RPython도 그렇고, 점점 compiler/VM의 back-end 부분은 좋은 framework들을 활용하는 방향으로 가는 것 같다. 프로그래밍 언어에 대한 아이디어와 설계만 있다면 parsing과 중간언어 생성정도만 직접적으로 하고 세부적인 최적화등은 다른 framework들을 활용하면 되니.. 프로그래밍 언어를 만드는 꿈도 그렇게 어렵게 만은 느껴지지 않는다. 다양한 언어들을 깊게 판 뒤 문제점이랑 아이디어를 모아서 언젠가 나만의 언어를 만들어보고 싶다.&lt;/span&gt;</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/8269385016145187612/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2017/04/pypy-rpython-translation-toolchain.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/8269385016145187612'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/8269385016145187612'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2017/04/pypy-rpython-translation-toolchain.html' title='PyPy RPython Translation Toolchain'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-3196730103600443728.post-9002666296858181454</id><published>2017-04-15T22:37:00.000+09:00</published><updated>2018-05-21T23:21:21.243+09:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="C++"/><category scheme="http://www.blogger.com/atom/ns#" term="Effective C++ Series"/><category scheme="http://www.blogger.com/atom/ns#" term="Effective Modern C++"/><category scheme="http://www.blogger.com/atom/ns#" term="From Naver Blog"/><title type='text'>[Effective Modern C++] Chapter 5. 오른값 참조, 이동 의미론, 완벽 전달 [항목 23~30]</title><content type='html'>&lt;h2&gt;Chapter 5. 오른값 참조, 이동 의미론, 완벽 전달&lt;/h2&gt;&lt;h3&gt;항목 23. std::move와 std::forward를 숙지하라.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;br /&gt;&lt;br /&gt;class Example&lt;br /&gt;{&lt;br /&gt;public:&lt;br /&gt;    Example() = default;&lt;br /&gt;    Example(const Example &amp;amp;) { std::cout &amp;lt;&amp;lt; &quot;copy constructor&quot; &amp;lt;&amp;lt; std::endl; }&lt;br /&gt;    Example(Example &amp;amp;&amp;amp;) { std::cout &amp;lt;&amp;lt; &quot;move constructor&quot; &amp;lt;&amp;lt; std::endl; }&lt;br /&gt;    Example(const Example &amp;amp;&amp;amp;) { std::cout &amp;lt;&amp;lt; &quot;const move constructor&quot; &amp;lt;&amp;lt; std::endl; }&lt;br /&gt;};&lt;br /&gt;&lt;br /&gt;/* std::forward is meaningful only for universal reference in template. */&lt;br /&gt;&lt;br /&gt;void test1(Example ex)&lt;br /&gt;{&lt;br /&gt;    std::cout &amp;lt;&amp;lt; &quot;Test 1&quot; &amp;lt;&amp;lt; std::endl;&lt;br /&gt;    Example a(std::forward&amp;lt;Example&amp;gt;(ex));    // move constructor&lt;br /&gt;    Example b(std::forward&amp;lt;Example&amp;amp;&amp;gt;(ex));    // copy constructor&lt;br /&gt;    Example c(std::forward&amp;lt;Example&amp;amp;&amp;amp;&amp;gt;(ex));    // move constructor&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;void test2(Example&amp;amp; ex)&lt;br /&gt;{&lt;br /&gt;    std::cout &amp;lt;&amp;lt; &quot;Test 2&quot; &amp;lt;&amp;lt; std::endl;&lt;br /&gt;    Example a(std::forward&amp;lt;Example&amp;gt;(ex));    // move constructor&lt;br /&gt;    Example b(std::forward&amp;lt;Example&amp;amp;&amp;gt;(ex));    // copy constructor&lt;br /&gt;    Example c(std::forward&amp;lt;Example&amp;amp;&amp;amp;&amp;gt;(ex));    // move constructor&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;void test3(Example&amp;amp;&amp;amp; ex)&lt;br /&gt;{&lt;br /&gt;    std::cout &amp;lt;&amp;lt; &quot;Test 3&quot; &amp;lt;&amp;lt; std::endl;&lt;br /&gt;    Example a(std::forward&amp;lt;Example&amp;gt;(ex));    // move constructor&lt;br /&gt;    Example b(std::forward&amp;lt;Example&amp;amp;&amp;gt;(ex));    // copy constructor&lt;br /&gt;    Example c(std::forward&amp;lt;Example&amp;amp;&amp;amp;&amp;gt;(ex));    // move constructor&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;template &amp;lt;typename T&amp;gt;&lt;br /&gt;void test4(T&amp;amp;&amp;amp; a) /* universal reference(=forwarding reference) */&lt;br /&gt;{&lt;br /&gt;    std::cout &amp;lt;&amp;lt; &quot;Test 4&quot; &amp;lt;&amp;lt; std::endl;&lt;br /&gt;    Example aa(std::forward&amp;lt;T&amp;gt;(a));&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;template &amp;lt;typename T&amp;gt;&lt;br /&gt;void test5(const T&amp;amp;&amp;amp; a) /* Cannot be universal reference */&lt;br /&gt;{&lt;br /&gt;    std::cout &amp;lt;&amp;lt; &quot;Test 5&quot; &amp;lt;&amp;lt; std::endl;&lt;br /&gt;    Example aa(std::forward&amp;lt;T&amp;gt;(a));  // Compile Error &lt;br /&gt;                                     // because cannot remove &quot;const&quot; through static_cast in std::forward.&lt;br /&gt;&lt;br /&gt;    // Compile OK.&lt;br /&gt;    // Example aa(std::forward&amp;lt;T&amp;gt;(const_cast&amp;lt;T&amp;gt;(a)));&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;int main()&lt;br /&gt;{&lt;br /&gt;    test1(Example());&lt;br /&gt;    test2(Example());&lt;br /&gt;    test3(Example());&lt;br /&gt;&lt;br /&gt;    test4(Example());&lt;br /&gt;    // test5(Example());&lt;br /&gt;&lt;br /&gt;    const Example ex;&lt;br /&gt;    test4(std::move(ex));   // const move constructor&lt;br /&gt;    Example(std::move(ex));    // const move constructor&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;br /&gt;초심자가 착각할 수 있을 만한 점을 지적하고자 한다. std::forward는 템플릿과 함께 쓰여야만 한다.&lt;br /&gt;그냥 비템플릿 함수에서는 타입이 &amp;amp;&amp;amp;인지 아닌지를 알 수 있기 때문에 그냥 std::move를 쓰던가 말던가 하면된다. 괜히 std::forward를 사용하는 것은 관례도 아닐뿐더러, &quot;동작도 제대로 하지 않는다&quot;(std::forward는 단순히 T&amp;amp;&amp;amp; 로의 형변환만을 수행할 뿐이다. 여기서 reference collapsing이 일어난다.)&lt;br /&gt;그리고 T&amp;amp;&amp;amp; 만이 universal reference가 될 수 있다. test5같은 템플릿함수에서는 std::forward를 사용하지 못한다. 왜냐하면 std::forward내부에서 static_cast를 사용하는데, 여기에서 const를 제거할 수는 없기 때문이다. 대부분 const &amp;amp;&amp;amp; 타입을 본 적이 거의 없을 텐데, 이 것도 단순히 그냥 우리가 아는 &amp;amp;&amp;amp;와 const가 합쳐진 것이다. 예외 사항 같은 것은 없다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- std::move는 오른값으로서의 무조건 캐스팅을 수행한다. std::move 자체는 아무 것도 이동하지 않는다.&lt;br /&gt;&amp;nbsp;- std::forward는 주어진 인수가 오른값에 묶인 경우에만 그것을 오른값으로 캐스팅한다.&lt;br /&gt;&amp;nbsp;- std::move와 std::forward 둘 다, 실행시점에서는 아무 일도 하지 않는다.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;항목 24. 보편 참조와 오른값 참조를 구별하라.&lt;/h3&gt;universal reference 라는 이름이 내포할 수 있는 오류 때문에 이름을 forwarding reference로 바꾸자는 제안이 제출되었었다. C++17에 이게 정식 채택된건지는 모르겠다. 관심있는 사람은 아래 링크를 참고.&lt;br /&gt;&lt;a href=&quot;http://stackoverflow.com/questions/33904462/whats-the-standard-official-name-for-universal-references&quot;&gt;http://stackoverflow.com/questions/33904462/whats-the-standard-official-name-for-universal-references&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- 함수 템플릿 매개변수의 형식이 T&amp;amp;&amp;amp; 형태이고 T가 연역된다면, 또는 객체를 auto&amp;amp;&amp;amp;로 선언한다면, 그 매개변수나 객체는 보편 참조이다.&lt;br /&gt;&amp;nbsp;- 형식 선언의 형태가 정확히 형식&amp;amp;&amp;amp;가 아니면, 또는 형식 연역이 일어나지 않으면, 형식&amp;amp;&amp;amp;는 오른값 참조를 뜻한다.&lt;br /&gt;&amp;nbsp;- 오른값으로 초기화되는 보편 참조는 오른값 참조에 해당한다. 왼값으로 초기화되는 보편 참조는 왼값 참조에 해당한다.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;항목 25. 오른값 참조에는 std::move를, 보편 참조에는 std::forward를 사용하라.&lt;/h3&gt;특별히 논하고 싶은 내용은 없다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- 오른값 참조나 보편 참조가 마지막으로 쓰이는 지점에서, 오른값 참조에는 std::move를, 보편 참조에는 std::forward를 적용하라.&lt;br /&gt;&amp;nbsp;- 결과를 값 전달 방식으로 돌려주는 함수가 오른값 참조나 보편 참조를 돌려줄 때에도 각각 std::move나 std::forward를 적용하라.&lt;br /&gt;&amp;nbsp;- 반환값 최적화의 대상이 될 수 있는 지역 객체에는 절대로 std::move나 std::forward를 적용하지 말아야 한다.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;항목 26. 보편 참조에 대한 중복적재를 피하라.&lt;/h3&gt;아래의 중복 적재 해소 규칙에 따라 보편 참조에 대한 중복적재를 사용할 경우, 여러가지 문제들이 생길 수 있다. 중복 적재 해소 규칙을 따져보지 않은 채로 보편 참조에 대해 중복적재를 시도하면 의도치 않은 문제들이 생길 것이다. 그리고 만약 중복 적재 해소 규칙을 따져본다면 보편 참조에 대해 중복적재를 시도하지 않을 것이다. 즉, 결론은 보편 참조에 대해서는 중복적재(overloading)을 하지말라.&lt;br /&gt;(번외로.. 어느새 책에서 사용하는 중복 적재라는 단어가 익숙해져 버렸다... Effective Modern C++ 책의 번역에 대해 말이 많다... 나도 처음에는 처음 보는 번역들이 어색했지만... 이제는 말할 수 있다.. 좋은 번역 같다고.)&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[중복 적재 해소 규칙]&lt;/b&gt;&lt;br /&gt;- 정확한 부합이 암시적 타입 캐스팅을 통한 부합보다 우선 시 된다.&lt;br /&gt;- 어떤 함수 호출이 템플릿 인스턴스와 비템플릿 함수에 똑같이 부합한다면 비템플릿 함수를 우선시 한다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- 보편 참조에 대한 중복적재는 거의 항상 보편 참조 중복적재 버전이 예상보다 자주 호출되는 상황으로 이어진다.&lt;br /&gt;&amp;nbsp;- 완벽 전달 생성자들은 특히나 문제가 많다. 그런 생성자는 대체로 비const 왼값에 대한 복사 생성자보다 더 나은 부합이며, 기반 클래스 복사 및 이동 생성자들에 대한 파생 클래스의 호출들을 가로챌 수 있기 때문이다.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;항목 27. 보편 참조에 대한 중복적재 대신 사용할 수 있는 기법들을 알아 두라.&lt;/h3&gt;보편 참조에 대한 중복적재로 인한 문제가 생겼을 때 할 수 있는 대처는 아래 5가지가 있다.&lt;br /&gt;1. 중복적재를 포기한다.&lt;br /&gt;&amp;nbsp;- 생성자에는 적용할 수 없다.&lt;br /&gt;&amp;nbsp;- 해결책이라기 보단 &#39;회피책&#39;이다.&lt;br /&gt;2. const T&amp;amp; 매개변수를 사용한다.&lt;br /&gt;&amp;nbsp;- 보편 참조만큼 성능 측면에서 효율적이지 않다.&lt;br /&gt;&amp;nbsp;- 그러나, 그렇게 효율적일 필요가 없는 경우에는 가장 깔끔한 해결책이다.&lt;br /&gt;3. 값 전달 방식의 매개변수를 사용한다.&lt;br /&gt;&amp;nbsp;- 이 논의에서는 const T&amp;amp; 를 사용하는 것과 근본적으로 같은 아이디어이다. 단지, 추가로 항목 41의 조언을 채택했을 뿐이다.&lt;br /&gt;4. 꼬리표 배분(tag dispatch)를 사용한다.&lt;br /&gt;&amp;nbsp;- 결국 문제가 생긴 원인은 보편 참조에 대한 중복적재 해소 규칙 때문이다. 즉, 중복적재 해소가 명확하게 일어날 수 있게 하는 것이 아이디어이다.&lt;br /&gt;&amp;nbsp;- std::is_integral&amp;lt;T&amp;gt;, std::true_type 등을 활용해 tag dispatching을 해서 해결한다.&lt;br /&gt;&amp;nbsp;- tag dispatching은 &lt;a href=&quot;http://www.boost.org/community/generic_programming.html#tag_dispatching&quot;&gt;http://www.boost.org/community/generic_programming.html#tag_dispatching&lt;/a&gt; 을 참고.&lt;br /&gt;5. 보편 참조를 받는 템플릿을 제한한다. (std::enable_if)&lt;br /&gt;&amp;nbsp;- 위와 비슷한 아이디어로서, 중복적재 해소가 명확하게 일어날 수 있게끔 보편 참조를 받는 템플릿을 제한한다.&lt;br /&gt;&amp;nbsp;- std::enable_if를 활용한다.&lt;br /&gt;&amp;nbsp;- SFINAE (&lt;a href=&quot;https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/SFINAE&quot;&gt;https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/SFINAE&lt;/a&gt;)&lt;br /&gt;&amp;nbsp;- enable-if (&lt;a href=&quot;https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/enable-if&quot;&gt;https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/enable-if&lt;/a&gt;)&lt;br /&gt;&lt;br /&gt;자, 크게 세 가지 그룹으로 나눌 수 있다. 1 / 2,3 / 4,5&lt;br /&gt;1번은 중복적재를 포기함으로서, 즉, 함수이름을 변경함으로서 해결을 한다. 하지만 이것은 사실상 생성자에는 적용할 수 없고, 이 것은 사실상 회피책이기 때문에 별로 의미가 없다.&lt;br /&gt;2,3번은 &#39;보편 참조&#39;를 포기하는 방법이다. 보편 참조를 포기하므로서 성능측면에서 효율성은 떨어지지만, 간단하게 문제를 해결할 수 있다. 그리고 또한 사용자 측면에서 훨씬 편리한 장점이 있다.&lt;br /&gt;4,5번은 &#39;보편 참조&#39;를 유지하되 중복적재 해소 과정에서 보편 참조로 deduction되는 것에 제한을 두는 것이다. 보편 참조를 유지하므로 성능측면에서 효율적이나, template meta programming을 이용해야하므로 문제를 해결하는 과정이 복잡하다. 그리고 인자가 정확하지 않을 경우 무지막지한 에러메세지들을 뱉어내고 파라미터로서 가능한 값들이 명확히 한눈에 들어오지 않는 보편 참조의 문제점으로 인해 사용자 편리성이 떨어지는 단점이 있다. 만약 사용한다면 4,5번 중에서는 개인적으로 5번을 사용하는 것이 가독성과 구조 측면에서 더 좋다고 생각한다.&lt;br /&gt;결론적으로 아마 2,3 과 4,5중에 해결책을 도모해야 할텐데, 일단 기본적으로는 2,3 (그중에서도 2번) 을&amp;nbsp; 사용하고, 보편 참조를 사용해야 할만한 타당한 이유가 생겼을 때 바꾸는 것이 좋다고 생각된다. 물론 인터페이스 변경에 민감한 부분을 설계할 때는 초기에 충분한 고민이 선행되어야 할 것이다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- 보편 참조와 중복적재의 조합에 대한 대안으로는 구별되는 함수 이름 사용, 매개변수를 const에 대한 왼값 참조로 전달, 매개변수를 값으로 전달, 꼬리표 배분 사용 등이 있다.&lt;br /&gt;&amp;nbsp;- std::enable_if를 이용해서 템플릿의 인스턴스화를 제한함으로써 보편 참조와 중복적재를 함께 사용할 수 있다. std::enable_if는 컴파일러가 보편 참조 중복적재를 사용하는 조건을 프로그래머가 직접 제어하는 용도로 쓰인다.&lt;br /&gt;&amp;nbsp;- 보편 참조 매개변수는 효율성 면에서 장점인 경우가 많지만, 대체로 사용성 면에서는 단점이 된다.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;항목 28. 참조 축약을 숙지하라.&lt;/h3&gt;네, 숙지하세요.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- 참조 축약은 템플릿 인스턴스화, auto 형식 연역, typedef와 별칭 선언의 지정 및 사용, decltype의 지정 및 사용이라는 네 가지 문맥에서 일어난다.&lt;br /&gt;&amp;nbsp;- 컴파일러가 참조 축약 문맥에서 참조에 대한 참조를 만들어 내면, 그 결과는 하나의 참조가 된다. 원래의 두 참조 중 하나라도 왼값 참조이면 결과는 왼값 참조이고, 그렇지 않으면 오른값 참조이다.&lt;br /&gt;&amp;nbsp;- 형식 연역이 왼값과 오른값을 구분하는 문맥과 참조 축약이 일어나는 문맥에서 보편 참조는 오른값 참조이다.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;항목 29. 이동 연산이 존재하지 않고, 저렴하지 않고, 적용되지 않는다고 가정하라.&lt;/h3&gt;나는 이 항목의 이름에 대해 비판적인 시각을 가지고 있다. 책에서 말하는 move semantics가 도움이 되지 않는 시나리오는 다음과 같다.&lt;br /&gt;1. 이동 연산이 없다.&lt;br /&gt;2. 이동이 더 빠르지 않다.&lt;br /&gt;3. 이동을 사용할 수 없다.&lt;br /&gt;너무나 당연한 이야기이다.&lt;br /&gt;근데 코드를 짤 때 &quot;이동 연산이 존재하지 않고, 저렴하지 않고, 적용되지 않는다고 가정하라&quot; 는 것은 잘 이해가 안된다. 일단 이동 연산이 없는 경우에는 자동으로 복사연산이 선택된다. 그리고 이동연산이 더 빠르진 않을 순 있어도 이동이 복사보단 느릴 경우는 (적어도 내가 알기론) 없다. 또, 예외 안정성 때문에 이동을 사용할 수 없는 경우에 대해서는 std::move_if_noexcept 를 이용해서 조건부 move를 할 수 있다. 즉, 나는 저렇게 가정을 해야 할 구체적인 사례를 알 지 못한다. 그리고 책에서도 그러한 구체적인 사례를 예시를 들지는 않고 있다.&lt;br /&gt;엄밀하게 따졌을 때, &quot;이동 연산이 존재하지 않거나 저렴하지 않거나 적용되지 않을 수 있다는 것을 알아두라&quot; 가 항목 이름으로서 더 적합하다고 생각한다.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- 이동 연산들이 존재하지 않고, 저렴하지 않고, 적용되지 않을 것이라고 가정하라.&lt;br /&gt;&amp;nbsp;- 형식들과 이동 의미론 지원 여부를 미리 알 수 있는 경우에는 그런 가정을 둘 필요가 없다.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;항목 30. 완벽 전달이 실패하는 경우들을 잘 알아두라.&lt;/h3&gt;&lt;b&gt;[완벽 전달이 실패한다는 것의 정의]&lt;/b&gt;&lt;br /&gt;두 가지중에 하나라도 만족하면 완벽 전달이 실패한 것이다.&lt;br /&gt;1. 컴파일러가 형식을 연역하지 못한다. (즉, template type deduction이 불가능 경우)&lt;br /&gt;2. 컴파일러가 형식을 잘못 연역한다. (의도와는 다르게 type deduction이 일어난 경우를 말한다. 운이 좋으면 컴파일에러지만, 심각할 경우 다른 중복적재 버전이 선택되어 런타임에 잘못된 동작을 할 수도 있다.)&lt;br /&gt;&lt;br /&gt;&lt;b&gt;[완벽 전달이 실패하는 경우들]&lt;/b&gt;&lt;br /&gt;1. 중괄호 초기치&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 원인 : 항목 2에서 다루듯이, template type deduction에서는 중괄호 초기치가 실패한다. (반면, auto의 type deduction에서는 성공한다는 점을 다시 한번 기억하자.)&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 해결책 : &lt;a href=&quot;https://github.com/taeguk/Effective-Cpp-Series/blob/master/EffectiveModernCpp/ch4/21.cpp#L18-L20&quot;&gt;https://github.com/taeguk/Effective-Cpp-Series/blob/master/EffectiveModernCpp/ch4/21.cpp#L18-L20&lt;/a&gt;&lt;br /&gt;2. 널 포인터를 뜻하는 0 또는 NULL&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 원인 : 0이나 NULL은 정수 형식으로서 잘못 연역된다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 해결책 : nullptr을 사용한다.&lt;br /&gt;3. 선언만 된 정수 static const 및 constexpr 자료 멤버&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 원인 : 완벽전달은 기본적으로 &#39;참조&#39;이므로 정의가 되있어야 한다. (그러나, 사실상 완벽전달에서도 const propagation이 가능하면 좋으므로 컴파일러에서 요령껏 처리해줄 수 도 있다.)&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 해결책 : 정의도 제공한다.&lt;br /&gt;4. 중복적재된 함수 이름과 템플릿 이름&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 원인 : 완벽전달 함수 입장에서 구체적인 타입을 연역하지 못한다.&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 해결책 : static_cast를 활용하는 등의 방법을 써서 구체적인 타입을 연역할 수 있게 한다.&lt;br /&gt;5. 비 const 비트필드&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 원인 : 비트에 대해 &#39;참조&#39;할 수 있는 방법(자료형)이 없기 때문이다. (비트필드에 대한 const 참조는 임시변수가 bitfield의 값을 잡고있게 하고 그 임시변수를 const 참조함으로서 가능하다.)&lt;br /&gt;&amp;nbsp; &amp;nbsp; - 해결책 : 비트필드를 담을 수 있는 값으로 전달함으로서 해결한다. (아래 참고)&lt;br /&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;br /&gt;&lt;br /&gt;struct test&lt;br /&gt;{&lt;br /&gt;    std::uint8_t a : 4,&lt;br /&gt;                 b : 4;&lt;br /&gt;};&lt;br /&gt;&lt;br /&gt;template &amp;lt;typename T&amp;gt;&lt;br /&gt;void foo(T&amp;amp; a) {}&lt;br /&gt;template &amp;lt;typename T&amp;gt;&lt;br /&gt;void bar(const T&amp;amp; a) {}&lt;br /&gt;&lt;br /&gt;template &amp;lt;typename ...T&amp;gt;&lt;br /&gt;void fwd_foo(T&amp;amp;&amp;amp;... args)&lt;br /&gt;{&lt;br /&gt;    foo(std::forward&amp;lt;T...&amp;gt;(args...));&lt;br /&gt;}&lt;br /&gt;template &amp;lt;typename ...T&amp;gt;&lt;br /&gt;void fwd_bar(T&amp;amp;&amp;amp;... args)&lt;br /&gt;{&lt;br /&gt;    bar(std::forward&amp;lt;T...&amp;gt;(args...));&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;int main()&lt;br /&gt;{&lt;br /&gt;    struct test t = {};&lt;br /&gt;    const struct test ct = {};&lt;br /&gt;&lt;br /&gt;    // foo(t.b);  // Compile Error&lt;br /&gt;    foo(ct.b);&lt;br /&gt;    bar(t.b);&lt;br /&gt;    bar(ct.b);&lt;br /&gt;&lt;br /&gt;    // fwd_foo(t.b);  // Compile Error&lt;br /&gt;    fwd_foo(ct.b);&lt;br /&gt;    // fwd_bar(t.b);  // Compile Error&lt;br /&gt;    fwd_bar(static_cast&amp;lt;std::uint8_t&amp;gt;(t.b));&lt;br /&gt;    fwd_bar(ct.b);&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;br /&gt;&lt;b&gt;[기억해 둘 사항들]&lt;/b&gt;&lt;br /&gt;&amp;nbsp;- 완벽 전달은 템플릿 형식 연역이 실패하거나 틀린 형식을 연역했을 때 실패한다.&lt;br /&gt;&amp;nbsp;- 인수가 중괄호 초기치이거나 0 또는 NULL로 표현된 널 포인터, 선언만 된 정수 static const 및 constexpr 자료 멤버, 템플릿 및 중복적재된 함수 이름, 비트필드이면 완벽 전달이 실패한다.&lt;br /&gt;&lt;br /&gt;&lt;hr /&gt;&lt;br /&gt;move semantics를 처음 접했을 때가 생각난다. (뜬금없이 과거 회상)&lt;br /&gt;때는 대략 2년전, 2015년 봄쯤, 학교 랩실에서 move semantics에 관한 블로그 글들을 읽으며 어려워했던 기억이 난다. (이때는 내가 auto조차 잘 몰랐을 시절이다.. C++11/14에 대한 지식이 거의 전무했을 때..)&lt;br /&gt;물론 지금 다시 보면 그 내용은 너무나 쉽다. 하지만 그때는 r-value과 move의 필요성과 원리에 대해 이해하는 것 만으로도 벅찼고, forwarding는 손도 못 댔었다. 어찌어찌해서 이해는 했지만 그 뒤로 계속 까먹어서 move semantics를 수시로 다시 공부했었다. 그렇게 이해와 망각을 여러 번 반복하고, RVO등을 이해하기 위해 직접 disassemble해서 까보기도 하고, 실제 프로젝트에서 사용도 해보고, 동시에 다른 C++ 지식들이 많이 쌓이면서... 결국에는 내 머리 속에 완전히 확립이 되게 되었다.&lt;br /&gt;최근 들어 깨달은 점이 하나 있다. 아무리 어렵고 복잡한 것이더라도 계속 째려보다 보면 해결이 된다. 그 것은 어떤 개념이 될 수도 있고, 코드가 될 수 도 있고, bug를 고치는 것이 될 수 도 있다. 처음에는 너무 어려워 보이는 내용들일지라도, 계속 보다 보면 일단 그 내용들이 담겨있는 방법(예컨데, 폰트나 말투 등)이 익숙해지고.. 용어가 익숙해진다. 그러고 나면 두려움이 서서히 없어지기 시작하고, 뇌 입장에서도 순전히 &#39;이해&#39;에 100% 힘을 발휘할 수 있게 된다. 결국에는 이해를 하게 된다. 그리고 시간이 흐른 뒤에 다시 그 것을 바라보면 너무나 쉽고 단순하다.&lt;br /&gt;어쨌든, 몇 년 동안 학습과 회고의 반복을 통해 새로운 걸 배우고 도전하는 것은 겉으론 어려워 보여도 계속 살을 맞대다 보면 결국엔 할 수 있다는 자신감을 얻게 되었다. 이 글을 보는 소중한 분들께도 이 자신감을 나눠드리고 싶다. (훈훈)</content><link rel='replies' type='application/atom+xml' href='https://taeguk2.blogspot.com/feeds/9002666296858181454/comments/default' title='댓글'/><link rel='replies' type='text/html' href='https://taeguk2.blogspot.com/2017/04/effective-modern-c-chapter-5-2330.html#comment-form' title='0개의 덧글'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/9002666296858181454'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/3196730103600443728/posts/default/9002666296858181454'/><link rel='alternate' type='text/html' href='https://taeguk2.blogspot.com/2017/04/effective-modern-c-chapter-5-2330.html' title='[Effective Modern C++] Chapter 5. 오른값 참조, 이동 의미론, 완벽 전달 [항목 23~30]'/><author><name>Unknown</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry></feed>