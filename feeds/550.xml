<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Sang Hyun Yang on Medium]]></title>
        <description><![CDATA[Stories by Sang Hyun Yang on Medium]]></description>
        <link>https://medium.com/@tech.yangs?source=rss-6916934514b1------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/0*kvkC05wo1np21NmJ.</url>
            <title>Stories by Sang Hyun Yang on Medium</title>
            <link>https://medium.com/@tech.yangs?source=rss-6916934514b1------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Sun, 12 May 2019 13:41:54 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@tech.yangs" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[AWS EC2 VPC 피어링 하기]]></title>
            <link>https://medium.com/@tech.yangs/aws-ec2-vpc-%ED%94%BC%EC%96%B4%EB%A7%81-%ED%95%98%EA%B8%B0-d75dc58eb74f?source=rss-6916934514b1------2</link>
            <guid isPermaLink="false">https://medium.com/p/d75dc58eb74f</guid>
            <category><![CDATA[aws]]></category>
            <category><![CDATA[vpc]]></category>
            <category><![CDATA[vpc-peering]]></category>
            <dc:creator><![CDATA[Sang Hyun Yang]]></dc:creator>
            <pubDate>Wed, 05 Dec 2018 14:27:08 GMT</pubDate>
            <atom:updated>2018-12-06T03:57:29.622Z</atom:updated>
            <content:encoded><![CDATA[<p>회사에서 운영중인, AWS 서비스가 계속 커지다보니, VPC도 나눠지고 VPC 피어링도 필요한 상황이 되었다.</p><p>그래서 이번에 VPC 피어링을 하는 과정을 블로그에 적어보도록 하겠다.</p><h3><strong>AWS VPC 피어링이란?</strong></h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/451/1*R2w1FZbv16lGiEeyoxIw7w.png" /><figcaption>출처 : <a href="https://docs.aws.amazon.com/ko_kr/vpc/latest/peering/what-is-vpc-peering.html">https://docs.aws.amazon.com/ko_kr/vpc/latest/peering/what-is-vpc-peering.html</a></figcaption></figure><p>VPC 피어링 연결은 프라이빗 IPv4 주소 또는 IPv6 주소를 사용하여 두 VPC 간에 트래픽을 라우팅할 수 있도록 하기 위한 두 VPC 사이의 네트워킹 연결 하는것을 VPC 피어링 이라고 합니다.</p><p>한줄 정리 하면 A공유기와 B공유기를 연결하는 작업이라고 볼수있다.</p><h3>AWS VPC 피어링을시작을 하기 전에</h3><p>이 글에서는 여러분이 조금이라도 더 빠르고 깔끔하게 이해 하시라고 용어 정리를 한번 하고 가겠다.</p><ul><li><strong>VPC_A </strong>: 172.20.0.0/16 (요청자),</li><li><strong>VPC_B </strong>: 172.30.0.0/18 (수락자)</li></ul><h3>AWS VPC 요청하기</h3><p>먼저, VPC 대시보드로 이동한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*imFP01ozTgTkC4iAgacY1w.png" /></figure><ol><li>피어링 연결 선택</li><li>피어링 연결 생성 클릭</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*WZnrQ-QHgsl0IUfS9IvdJw.png" /></figure><p>4. 요청자 VPC와 수락자 VPC를 선택한다</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/644/1*CM5tDfbEzV7S6qn3qmU_Zw.png" /></figure><p>4–1. 만약 다른 리전에 있는 VPC와 연결 하려면, 하단에 리전에 있는 다른 리전을 선택해서 피어링을 할 VPC ID를 입력하면 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/638/1*s4Dnyl5em7C8Cs_XP5ps-Q.png" /></figure><p>4–2. 다른 계정에 있는 계정에 연결을 하기 위해서는 계정ID (billing -&gt; 계정 설정 -&gt; 계정ID에 있는 숫자)을 입력하고, VPC ID를 직접 입력하면 된다.</p><p>나의 경우는 내 계정의 같은 리전에 있는 VPC_B로 연결해보겠다.</p><p>5. 문제가 없이 잘 진행 되었다면 아래와 같이 요청이 완료되었다는 메세지를 확인 할 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/917/1*D7U0HBTvdJbRC0Q-vJG5aA.png" /><figcaption>&lt;그림2 VPC_A -&gt; VPC_B로 요청이 완료된 상태&gt;</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/805/1*rWQGtgdgU4EB5CH5MU-R-A.png" /><figcaption>&lt;그림3. VPC_A -&gt; VPC_B로 요청을 보낸 상태&gt;</figcaption></figure><p>자 그럼, 내가 VPC_A -&gt; VPC_B로 요청을 보냈으니 수락을 하자.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/385/1*UIGCvkCOk489yJ_VeQ2uMA.png" /></figure><p>요청 수락이 필요한 VPC에 오른쪽 마우스를 클릭 하고 “요청 수락”을 누르면 VPC_A와 VPC_B의 연결이 허용 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/931/1*089izhhWm0qh8oPyiWLjOw.png" /></figure><p>아무런 문제 없이 잘 진행 되었다면 위와 같은 내용으로 요청을 수락 했다는 안내를 받게 될 것이다.</p><h3>피어링 한 VPC간의 통신을 위해 라우팅 추가</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/297/1*CwYyndv57IiaxMqv9i7vkg.gif" /><figcaption>&lt;씨익&gt;</figcaption></figure><p>아니 피어링이 벌써 끝났다고? 라는 생각과 함께, 놀아야지! 라고 생각하면 큰 오산이다.</p><p>피어링된 VPC간에 송/수신이 될려면 VPC_A와 VPC_B의 라우팅 테이블에 피어링한 VPC의 라우팅을 등록 해줘야 한다.</p><p><em>(이 정도는 자동으로 넣어줬으면 하는데 좀 아쉽다)</em></p><p>먼저, VPC_A에서 VPC_B의 라우팅을 넣어보자.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*wGa2wBGKctR3Xe4IotAvQA.png" /></figure><p>Parring Connection을 클릭 하면 (pcx-)라는 접두사가 붙게된다.</p><p>자동완성을 통해 나오는 피어링 아이디를 선택 해주고 Save routes를 클릭합니다.</p><p>만약, 자동완성이 나오지 않는다면, 해당 라우팅에 추가 할 수 없는 경우다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dC4G_hPco2IzhiHsIH8lag.png" /></figure><p>위와 같은 방법으로 VPC_B에서도 똑같이 VPC_A에 대한 라우팅을 등록 해준다.</p><p>문제가 없었다면 라우팅 등록에 성공했다는 메세지가 뜰것이다.</p><p>그럼, 이제 80%정도는 한거다</p><h3>Security Group 추가</h3><p>여기서 조금 당황 했던건 시큐리티 그룹 설정시 Source에 대한 자동완성이 안된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/484/1*EsC05tqaOsVG4Uv8xSxIUw.png" /><figcaption>&lt;피어링간의 설정은 선택이 안됨&gt;</figcaption></figure><p>여기서 조금 많이 당황을 했다. 매우 잘 사용하던 자동완성이 안되서 내가 멀 잘못한건가 하고 문서를 엄청 찾아봤었다.</p><p>엄청난 구글 검색을 통해 알게 된 것은 자동 완성으로는 해당 VPC안에서의 Security Group만 나온다는 사실을 알게 되었다.</p><p>그럼 어떻게 Policy를 넣는냐? 라고 하면 해당 시큐리티 그룹의 실제 ID를 직접 입력 하면 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/767/1*T2NSclZqz-B6ENIuc3hjvA.png" /></figure><p>VPC_B_SG(sg-010ee05f791a9fec0)에서 VPC_A_SG(sg-081d0f4ba0f73d188)의 ICMP를 오픈하여 VPC_A에서 VPC_B로 통신 하도록 해보겠다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*WthucqD9UxrasgVE9tsnag.png" /></figure><p>이렇게 자동완성은 되지 않지만 Security Group ID를 직접 넣어주면 된다</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*E42YOmpOSXt7NbUNdWvDuA.png" /><figcaption>&lt;잘못된 Security Group ID를 입력하면, 이렇게 화면이 깨진다..?&gt;</figcaption></figure><blockquote>`보안 그룹 규칙을 업데이트 할 수 없습니다(변경 사항 없음).: The security group ‘~~’ does not exist`</blockquote><p>블로그 글을 적는 이 상황에 아마존의 이슈가 있는지 화면이 깨진다.</p><p>할튼 존재 하지 않는 Security Group ID라면 업데이트를 할 수 없다는 내용과 함께 오류가 나게 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/516/1*Xengp1loGPx9ivXL_COtFQ.png" /><figcaption>&lt;정상적으로 PING이 들어가는 모습&gt;</figcaption></figure><p>이렇게 되면 당신의 VPC 피어링은 완료 되었다.</p><h3>VPC 피어링 하고 나면, 내부 DNS 사용 못하나요?</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/480/1*wwOPL0h9iZIyxVtvrOIsfg.gif" /></figure><p>신나게 VPC 피어링이 완료되고 통신이 되는것까지 확인을 했는데, VPC_A와 VPC_B 구간에 통신이 안되는게 보인다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/518/1*B4yOE1o0s-6Ibf3f8hIhjw.png" /><figcaption>&lt;피어링 한거면 DNS도 사설으로 바뀌어야 하는거 아닌가.&gt;</figcaption></figure><p>피어링을 하고 나면 사설 대역 끼리 통신을 해야하는데, DNS 룩업 결과가 외부로 나간다.</p><p>그럼 피어링 구간은 DNS를 통해 Lookup을 못하나요? 라는 질문은 <strong>아니다! </strong>라고 답하겠다.</p><p>아까 VPC 피어링을 위해 갔던 탭으로 다시 이동을 하자</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/452/1*FCqVifYjQKWIqOGEALQV3w.png" /></figure><p>연결된 피어링 연결서 오른쪽 마우스를 클릭 하고 DNS 설정 편집을 누르자.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*5vfLnskniBjYTao3hhaUMg.png" /></figure><p><strong>‘요청자 VPC(VPC_A)가 프라이빗 IP에 대한 수락자 VPC (VPC_B) 호스트의 DNS 확인 허용’</strong> 을 클릭 하고 저장을 하고 서버에서 다시 DNS를 조회해보자</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/500/1*OtTeqmo51Njl4U4PrRtf5w.png" /></figure><p>정상적이게 공인 IP에서 사설 IP로 변경되고, 실제로 통신도 잘되는것을 확인 할 수 있었다.</p><h3>마치며</h3><p>VPC 피어링이필요한 상황이 있다면, 이 글을 보고 잘 해결 했기를 바란다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d75dc58eb74f" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[EC2에서 Windows 7/8/10 설치하기 (aka.AWS EC2에서 레거시 VM 운영하기)]]></title>
            <link>https://medium.com/@tech.yangs/ec2%EC%97%90%EC%84%9C-windows-7-8-10-%EC%9A%B4%EC%98%81%ED%95%98%EA%B8%B0-a5035a853c0d?source=rss-6916934514b1------2</link>
            <guid isPermaLink="false">https://medium.com/p/a5035a853c0d</guid>
            <category><![CDATA[cliento]]></category>
            <category><![CDATA[aws]]></category>
            <category><![CDATA[windows-7]]></category>
            <dc:creator><![CDATA[Sang Hyun Yang]]></dc:creator>
            <pubDate>Fri, 07 Sep 2018 13:54:36 GMT</pubDate>
            <atom:updated>2018-09-23T05:18:28.575Z</atom:updated>
            <content:encoded><![CDATA[<p>서비스를 운영 해본 사람들은 다 알겠지만, 가장 힘들고 짜증 나는것은 장애 입니다.<br>그 중에서도 제일 화가 나는것은 하드웨어적인 장애가 발생 할 경우 운영의 입장에서 정말 답이 안나오기 시작합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/326/0*liChlIhd5keS0oG0.gif" /><figcaption>&lt;서버를 고치는 엔지니어의 모습&gt;</figcaption></figure><p>요즘 기업들은 위에서 이야기한 고질적인 인프라적 문제를 해결 하고 더 효율적인 스케일링과 관리를 위하여, AWS와 같은 가상화 서비스로 넘어가는 경우가 많습니다.<br>자세한 내용이 궁금하시면 <a href="https://aws.amazon.com/ko/blogs/korea/category/korea-customers/">여기</a>를 클릭해보세요</p><p>제가 다니고 있는 회사도, 레거시 AWS로 서비스를 이전하고 있는데<br>이번 기회에 스케일링과 하드웨어적인 문제가 복합적으로 있지만 중요한 내부 시스템을 AWS 인프라로 옮겨서 운영하자라는 이야기가 나왔고, 당시 AWS 이전을 어느정도 담당하고있던 제가 진행하게 되었습니다.</p><p>해당 팀의 요구사항을 정리해보니 아래와 같았습니다.</p><ul><li>언제나 가상화 장비는 유연하게 늘어날수있는 인프라 구성 이어야한다.</li><li>시스템은 IOPS가 높기 떄문에 하드웨어 퍼포먼스가 어느정도 유지되어야 한다.</li><li>최소한 Windows Server 시리즈로 설치 할 수 없고, Windows 7으로 설치 되어야 한다.</li></ul><p>처음에 이 내용을 듣고, 1~2번 요구사항은 이미 AWS에서 잘 지원을 해주기 때문에 아무런 걱정이 없었으나, 3번이 가장 큰 문제였습니다.</p><h3>클라이언트 OS를 공식 지원하지 않는 AWS</h3><p>AWS에서는 현재 Server 계열의 OS이미지들에 대해서만 공식 이미지를 제공하고 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*VutH89AhYjW1PbG9.png" /><figcaption>&lt;서버 계열만 지원하는 AWS ㅠㅠ&gt;</figcaption></figure><p>즉, Windows 7/8/10등의 클라이언트 OS는 공식 이미지를 제공하지 않기때문에 EC2에 설치가 힘든게 현실입니다.</p><p>이렇게 AWS로 이전은 안되는것인가, 좌절을 하던중에 AWS 공식 글에서 재미있는 글을 하나 발견하였습니다.</p><p><a href="http://docs.aws.amazon.com/vm-import/latest/userguide/vmimport-image-import.html">Importing a VM as an Image Using VM Import/Export - VM Import/Export</a></p><p>AWS에서 기존에 사용하던 VM을 AMI(Amazone Machine Image)로 변환 할 수 있도록 지원을 하고 있는것입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/224/0*evpG-hUS91pWwPKo.gif" /><figcaption>&lt;하..AWS는 아직 우리를 버리지 않았습니다&gt;</figcaption></figure><h3>시작하기</h3><p>자신의 컴퓨터에 가상화 프로그램으로 기본 이미지를 셋팅해봅시다.<br>수많은 가상화 프로그램이 있지만, 그중에 저는 VirtualBox를 선택하여 셋팅해보도록 하겠습니다.</p><h3>VM셋팅 및 이미지 셋팅</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*I5yGIPY0rfDprbXV.png" /></figure><p>기존의 설정은 모두 여러분의 입맛에 맞게 설정을 해주시고, 디스크 생성시 VHD (가상 하드 디스크)만 선택해줍니다.<br>(어짜피, EC2로 가면 셋팅할때 설정으로 다 변경되니 여기서 굳이 고민하거나 하면서 힘은 안빼도 될 것 같습니다)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*A_dxiXsw4FqxInxj.png" /></figure><p>자 일단 기본적인 설정은 완료 되었습니다. 이 상태에서 그냥 윈도우 설치를 해보도록 합시다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*9plvbKVDashFtpHn.png" /></figure><p>이럴땐 역시 커피 한잔의 여유를 가지며 조용히 설치가 완료될때까지 기다려 줍니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*BJur0dcuWKROuNPt.png" /></figure><p>드디어, 기다리고 기다리던 OS 설치가 완료되었습니다.<br>여기서 한가지 주의 해주셔야 하는 부분은 해주셔도 무관하긴하지만, Virtual Box Tool은 설치하지 않는것을 추천합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*5dlXPnBdi8_6zOAP.png" /></figure><p>설정에서 원격 데스크톱 사용 설정도 해주시고, 절전 모드 해제까지 해주시면 이미지 셋팅은 완료 됩니다.</p><h3>VM 이미지 업로드</h3><p>이미지 준비가 완료되면 VBox 폴더 안에 우리가 생성했던 디스크 이미지를 Amazone S3 Storage에 업로드 해보겠습니다.</p><p>먼저, VM 이미지를 업로드 할 버킷을 생성합니다.<br>여기서 주의해야 할 점은 리전을 선택할 때 자신이 AMI 이미지를 생성하고자 하는 리전으로 설정 해주셔야 합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*8tbeqsjGqxJgoBei.png" /></figure><p>저의 경우에는 “windows-os-image” 라고 생성했습니다.</p><p>자 이제 VHD이미지를 S3에 업로드 해야하는데, 여러가지 방법이 있지만 저의 경우에는 AWS CLI Tool을 활용하여 업로드 해보겠습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*VJsTzJ35-e69fCqX.png" /></figure><h3>VM IMPORT 권한 설정</h3><p>업로드가 진행되는 동한 AMI 이미지 생성을 위한 권한을 설정해보도록 하겠습니다.</p><p>policy.json이라는 파일을 생성하고 아래의 json을 생성합니다.</p><pre>{<br>   &quot;Version&quot;: &quot;2012-10-17&quot;,<br>   &quot;Statement&quot;: [<br>      {<br>         &quot;Effect&quot;: &quot;Allow&quot;,<br>         &quot;Principal&quot;: { &quot;Service&quot;: &quot;vmie.amazonaws.com&quot; },<br>         &quot;Action&quot;: &quot;sts:AssumeRole&quot;,<br>         &quot;Condition&quot;: {<br>            &quot;StringEquals&quot;:{<br>               &quot;sts:Externalid&quot;: &quot;vmimport&quot;<br>            }<br>         }<br>      }<br>   ]<br>}</pre><p>그리고 AWS CLI를 통해 AWS에 VM import/export를 할수있는 정책을 생성하는 명령을 내려줍니다.</p><pre>aws iam create-role --role-name vmimport --assume-role-policy-document file://경로</pre><p>그리고 이제 S3와 EC2 시스템간의 권한을 생성 해보도록 하겠습니다.</p><p>먼저 아래의 정책 Json을 생성해줍니다.<br>저는 policy_import.json이라고 생성하였습니다.</p><pre>{<br>   &quot;Version&quot;: &quot;2012-10-17&quot;,<br>   &quot;Statement&quot;: [<br>      {<br>         &quot;Effect&quot;: &quot;Allow&quot;,<br>         &quot;Action&quot;: [<br>            &quot;s3:ListBucket&quot;,<br>            &quot;s3:GetBucketLocation&quot;<br>         ],<br>         &quot;Resource&quot;: [<br>            &quot;arn:aws:s3:::windows-os-image&quot;<br>         ]<br>      },<br>      {<br>         &quot;Effect&quot;: &quot;Allow&quot;,<br>         &quot;Action&quot;: [<br>            &quot;s3:GetObject&quot;<br>         ],<br>         &quot;Resource&quot;: [<br>            &quot;arn:aws:s3:::windows-os-image/*&quot;<br>         ]<br>      },<br>      {<br>         &quot;Effect&quot;: &quot;Allow&quot;,<br>         &quot;Action&quot;:[<br>            &quot;ec2:ModifySnapshotAttribute&quot;,<br>            &quot;ec2:CopySnapshot&quot;,<br>            &quot;ec2:RegisterImage&quot;,<br>            &quot;ec2:Describe*&quot;<br>         ],<br>         &quot;Resource&quot;: &quot;*&quot;<br>      }<br>   ]<br>}</pre><p>해당 룰 파일과 아까 생성한 vmimport 정책을 연결 해줍시다.</p><pre>aws iam put-role-policy --role-name vmimport --policy-name vmimport --policy-document file://경로</pre><p>자, 이제 VM을 Import 할 준비가 완료 되었습니다.</p><h3>IAM 이미지 생성</h3><p>제가 위에서 말씀드린 모든 절차를 성공하셨다면, 여러분들이 로컬에서 만든 VM을 EC2에서 Import 할 준비는 모두 완료되었습니다.</p><p>이제 AWS에게 “내가 만든 이미지를 기반으로 VM을 생성해!” 라는 명령을 내려보도록 하겠습니다.</p><p>먼저 명령을 정의한 json 파일을 생성하겠습니다.</p><pre>[<br>  {<br>    &quot;Description&quot;: &quot;Windows 7 Public Image &quot;,<br>    &quot;Format&quot;: &quot;vhd&quot;,<br>    &quot;UserBucket&quot;: {<br>        &quot;S3Bucket&quot;: &quot;windows-os-image&quot;,<br>        &quot;S3Key&quot;: &quot;win7.vhd&quot;<br>    }<br>  }<br>]</pre><p>AWS CLI를 통해 AWS서버에 명령을 내려보도록 하겠습니다.</p><pre>aws ec2 import-image --license-type BYOL --disk-containers file://파일경로</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*9pFDbMAnVWqrFUXx.png" /></figure><p>자 이렇게 작업에 대한 내용이 AWS에서 반환되어 돌아오면 AWS에서 자동적으로 여러분들이 만든 VM Image를 AMI로 생성합니다.</p><p>이제 완료가 될 때까지 기다리기만 하면 EC2에서 Windows 7을 실행할 수 있습니다.</p><h3>VM Import Task 상태 확인</h3><p>위에서 기다리기만 하면 된다고 이야기 했지만,<br>얼마나 기다려야 할지도 모르겠고 택배로 치면 옥천에 들어간 기분을 느낄 수 있습니다.<br>내가 넣은 Task가 완료되었는지 알아보도록 하겠습니다.</p><p>아까 import를 완료 하고나서 나온 Json을 보면</p><pre>{<br>    &quot;Status&quot;: &quot;active&quot;,<br>    &quot;LicenseType&quot;: &quot;BYOL&quot;,<br>    &quot;SnapshotDetails&quot;: [<br>        {<br>            &quot;UserBucket&quot;: {<br>                &quot;S3Bucket&quot;: &quot;windows-os-image&quot;,<br>                &quot;S3Key&quot;: &quot;win7.vhd&quot;<br>            },<br>            &quot;DiskImageSize&quot;: 0.0,<br>            &quot;Format&quot;: &quot;VHD&quot;<br>        }<br>    ],<br>    &quot;Progress&quot;: &quot;2&quot;,<br>    &quot;StatusMessage&quot;: &quot;pending&quot;,<br>    &quot;ImportTaskId&quot;: &quot;import-ami-fgok8m2q&quot;<br>}</pre><p>“ImportTaskId”라는 Key가 존재합니다.<br>이 Key는 Task에 대한 고유한 키이고, 이 키를 통해서 상태를 조회할 수 있습니다.</p><p>AWS CLI에 아래와 같은 명령을 내려봅시다.</p><pre>aws ec2 describe-import-image-tasks --import-task-ids [위에서 나온 ImportTaskId]</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*1krybvu6xuIxkw8n.png" /></figure><p>저의 작업은 아직 완료가 안되었네요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/500/0*GcEVYEkSVBZdyT8q.png" /></figure><p>이 글을 적기 전에 제가 테스트를 해본 결과로는 거의 30분 ~ 40분 정도 걸리는 작업 이더라구요.<br>제발 에러가 나지 말아달라고 기도하면서 잠시 기다리시면 될 것 같습니다.</p><h3>VM시작하기</h3><p>드디어 모든 작업이 완료되고 생성한 이미지를 통해 EC2 VM을 생성해보도록 하겠습니다.</p><p>일반적으로 VM 생성할때 처럼 Launch Instanse를 선택해주시고, 왼쪽 서브 메뉴에 My AMIs 메뉴를 선택해줍니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*fPYA-w_9Ec--uWmr.png" /></figure><p>우리가 힘들게 만든 IAM 이미지가 저기 보입니다. 해당 이미지를 선택 합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*fkSHKJY34UzDt53-.png" /></figure><p>그리고 자신의 자금 상황에 맞는 Instance를 선택해주시고 Review &amp; Launch를 눌러줍니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*KfZqUpzGaIL3DtTC.png" /></figure><p>방금 생성한 인스턴스가 Running 상태로 바뀌고 나면 원격 데스크탑을 통해 접속 해봅시다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*MyVNGZfgLfYUj2Fr.png" /></figure><p>짜잔 드디어 설치가 완료되었습니다.</p><h3>마치며</h3><p>이 방법이 가능한것은 AWS에 Xen 시스템을 기반으로 가상화 시스템이 동작하고 있기 때문에 가능한것이라고 생각됩니다.</p><p>레거시 VM을 AWS로 옮기는 작업 역시 제가 했던 방법 그대로 이전이 가능하기때문에,<br>레거시 VM을 그대로 운영하지만 하드웨어적인 관리를 줄이고, Auto Scaling로 서비스 운영이 필요 하다면 이 방법을 통해 추천하긴합니다만..</p><p>다만, 굳이 Windows Client OS를 쓰지 않는 경우라면 AWS에서 최적화된 Server OS Image를 사용하시는것을 추천합니다.</p><p>처음 적어보는 글이라, 두서가 없지만 끝까지 읽어주셔서 감사합니다.</p><h3><strong>부록. Amazon WorkSpaces</strong></h3><p>그리고 사실 AWS에는 <a href="https://aws.amazon.com/ko/workspaces/">Amazon WorkSpaces</a>라는 VDI같은 서비스를 제공합니다.<br>단순하게 Windows만 필요하다 라는 분은 <a href="https://aws.amazon.com/ko/workspaces/">Amazon WorkSpaces</a>가 조금 더 적합하지 않을까 싶습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a5035a853c0d" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[MSA 고군분투기 — (1) JAVA의 DNS Cache 이슈 해결기]]></title>
            <link>https://medium.com/@tech.yangs/msa-%EA%B3%A0%EA%B5%B0%EB%B6%84%ED%88%AC%EA%B8%B0-1-java%EC%9D%98-dns-cache-%EC%9D%B4%EC%8A%88-%ED%95%B4%EA%B2%B0%EA%B8%B0-3c92fd02d6cf?source=rss-6916934514b1------2</link>
            <guid isPermaLink="false">https://medium.com/p/3c92fd02d6cf</guid>
            <category><![CDATA[java]]></category>
            <category><![CDATA[dns]]></category>
            <category><![CDATA[java-dns-cache]]></category>
            <category><![CDATA[dns-cache]]></category>
            <dc:creator><![CDATA[Sang Hyun Yang]]></dc:creator>
            <pubDate>Fri, 07 Sep 2018 12:26:36 GMT</pubDate>
            <atom:updated>2018-09-07T12:26:36.437Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/900/1*piK3cdhgvh8EMYl_EEZAcQ.jpeg" /></figure><p>내가 만든 서비스는 기본적으로 DNS 기반으로 서비스를 다 하고 있다. account.yangs.internal , search.yangs.internal, mariadb.yangs.internal 등등..</p><p>서비스중에 문제가 생기거나 구성 변경으로 인하여 혹은 아마존 내부의 이슈가 생기면 DNS에 IP를 스위칭해서 HA하는 형태로 운영중이었다.</p><p>어느날은 DB에 장애가 발생하여, 자동으로 IP가 변경되었는데 Application 레벨에서 전환이 진행이 안되어서 재기동으로 해결 한 기억이 있다.</p><p>DNS 서버 설정 문제인가 봤는데, DNS서버의 문제가 아닌 JAVA 클라이언트 의 DNS Cache 정책으로 인하여 발생한 이슈였다.</p><p>오늘은 그 이야기를 해보려고 한다.</p><h3><strong>DNS 공격을 방지하기 위한 JAVA의 정책</strong></h3><p>JVM의 버전에 따라 다르긴 하지만 1.6 이전의 경우는 Default로 Forever 1.6 이후 버전에 대해서는 30초 DNS Cache 정책이 들어간다고 한다.</p><p>그 이유로는 DNS 공격을 막기 위해서 라고 이야기 한다.</p><p>사실 예전에는 IP가 잘 바뀌는일이 없었으니 별로 문제가 없었을것같지만 요즘 같은 상황에서는 조금 문제가 있는 정책이 아닌가 싶다.</p><p><a href="https://developers.google.com/recaptcha/old/docs/java">Using reCAPTCHA with Java/JSP | reCAPTCHA | Google Developers</a></p><p>Google의 reCAPTCH 문서에서도 JAVA Application을 통해 개발 할때 DNS Cache에 대한 문제를 언급하고 있다.</p><h3>JAVA의 DNS Cache 정책</h3><p>서론에서 간단하게 JAVA의 DNS Cache 정책에 대해서 이야기 했지만, 한번 더 짚고 가는 느낌으로 정리해본다.</p><p>SecurityManager의 존재 여부로 조금씩 달라지는데 SecurityManager가 존재 할 경우는 보안상의 이유로 Application이 켜진동안 Cache를 만료시키지 않고, SecurityManager가 존재하지 않을경우, 30초간 Cache하는게 기본값이다.</p><h3>이 Cache 정책 변경 할 수 없는가?</h3><p>당연히 방법은 있다. JAVA에서는 아래와 같이 2가지 방법을 제시한다</p><ol><li>Java 설정 파일에서 내용 변경</li></ol><p>$JAVA_HOME/jre/lib/security/java.security 에 파일을 열어 <strong>networkaddress.cache.ttl </strong>라는 키를 수정 해주면 된다.</p><p>변경을 원하는 경우 주석을 풀고 원하는 시간을 입력해주면 된다 기준 시간은 sec이다.</p><blockquote>networkaddress.cache.ttl=0</blockquote><p>2. SecurityManager를 통한 설정</p><p>사실 1번 정책으로 전체 변경을 해주면 되긴하지만, 여러가지 사정으로 인하여 특정어플리케이션만 수정해줘야 하는 경우가 있다.</p><p>그 경우에는 Application initialize 과정에 아래와 같이 설정 해주도록 하자</p><blockquote><em>java.security.Security.setProperty(“networkaddress.cache.ttl” , “60”);</em></blockquote><p>나의 경우는 우리 DNS 서버를 믿긴했지만.. 혹시 모르는 상황에 대비하여 60초로 지정하여 사용중이다.</p><h3>마치며</h3><p>Cloud 형태의 IP가 자주 변경되는 서버가 많아지고, MSA와 같은 상황에서 여러 서버로 쪼개지면서 IP가 아닌 DNS 기반 요청이 많아지면 한번쯤은 겪는 이슈 일 것 이다.</p><p>다른 사람들은 이런 이슈가 생겼을때 이글을 보고 덜 멘붕하기를 바라며 이 글을 마친다.</p><h3>부록1. Python에서는 어떻게 하고있지?</h3><p>이 이슈를 마무리 하던 시점에 과연 다른언어들은 어떤식으로 하고 있을까 생각이 들었고, 요즘 핫하다고 하는 Python은 어떻게 처리하는지 찾아보았다.</p><p><a href="https://charsyam.wordpress.com/2017/12/22/%EC%9E%85-%EA%B0%9C%EB%B0%9C-i-dont-know-dns-caching/">[입 개발] I don&#39;t know DNS Caching</a></p><p>살짝 충격이었다. 언어 Level에서 아예 DNS Cache를 아예 하지 않는다는 의미다. 물론 지금 JAVA DNS Cache이슈에 대해 이야기 하면서 급 태세전환을 해서 이런 이야기를 하면 안되긴하지만 그냥 조금 충격이다.</p><p>결론적으로 보면 요청 건 마다 DNS Lookup 하는 시간동안의 레이턴시는 깔고간다는 뜻이다. 이런건 리눅스 NSCD 같은 데몬을 깔아서 해결 할 수 있긴 하지만 조금 충격이긴했다.</p><h3><strong><em>참고 문헌</em></strong></h3><ul><li><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/net/properties.html#nct">https://docs.oracle.com/javase/7/docs/technotes/guides/net/properties.html#nct</a></li><li><a href="https://www.lesstif.com/pages/viewpage.action?pageId=17105897"><em>https://www.lesstif.com/pages/viewpage.action?pageId=17105897</em></a></li><li>타이틀 이미지 출처 : <a href="https://blogs.technet.microsoft.com/uktechnet/2017/01/17/how-to-boost-your-windows-server-2016-security/">https://blogs.technet.microsoft.com/uktechnet/2017/01/17/how-to-boost-your-windows-server-2016-security/</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3c92fd02d6cf" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[CloudFront, Error Cache 삽질기]]></title>
            <link>https://medium.com/@tech.yangs/cloudfront-error-cache-%EC%82%BD%EC%A7%88%EA%B8%B0-cd9b21affaa2?source=rss-6916934514b1------2</link>
            <guid isPermaLink="false">https://medium.com/p/cd9b21affaa2</guid>
            <category><![CDATA[cfs]]></category>
            <category><![CDATA[aws]]></category>
            <category><![CDATA[cloudfront]]></category>
            <dc:creator><![CDATA[Sang Hyun Yang]]></dc:creator>
            <pubDate>Sun, 02 Sep 2018 11:34:26 GMT</pubDate>
            <atom:updated>2019-04-18T01:29:25.250Z</atom:updated>
            <content:encoded><![CDATA[<p>최근에 나에게 있었던 삽질기를 다른 사람은 겪지 않기를 바라며 글을 적어본다.</p><p>내가 다니고 있는 회사에서 신규 API서버를 오픈하였는데, AWS CloudFront(이하CF)를 붙여서 서비스를 오픈하였다.</p><p>이 API 서버는 결과가 있다면 200 OKAY 없으면 404를 주는 매우 간단한 서버였다.</p><p>그리고 서비스를 배포하고 실서버에서 최종 테스트를 해보고 있는데, 테스트 서버에서 발생하지 않는 문제가 AWS CloudFront의 설정 미스로 인하여, 실 서버에서 발생하는것이었다.</p><p>이 글은 그 이슈를 해결 한 이야기이다.</p><h3>결과가 디비에 있는데 왜 실서버는 결과를 안주지?</h3><p>QA조직에서 데이터를 올렸으나, 결과가 나오지 않는다 라는 이야기를 듣고 확인을 해보았다.</p><p>분명 DB에는 있다.. 진짜 있다.. 정말 있는데, 실제 서버에서 응답이 안오는것이없다.</p><p>무슨 문제가 생겼는가 하고 로컬에 더미 데이터를 넣어서 테스트도 해보고 다 해보았지만.. 테스트 서버의 결과에서는 200 OKAY였지만, 실 서버에서만 404결과가 나오고 있는것이었다.</p><p>엄청난 멘탈붕괴가 발생하는 이 시점에 문득 머리속에서 Invalidation을 한번 해봐야겠다. 라는 생각이 들었다.</p><p>Invalidation을 날리고, 다시 확인을 해보니 놀랍게도 결과가 정상적으로 내려오는것이었다.</p><h3>AWS CloudFront가 Cache 하는 방법</h3><p>처음에 내가 생각했던 Cache 전략은 100 ~ 3xx (HTTP 성공)에 대한 결과만 Cache 할것이라고 무의식적으로 생각 하고 있었다.</p><p>하지만, 내가 생각했던 방식과 달랐던것이 이 문제의 시발점이었다.</p><p>일단 기본적으로 아마존은 Origin 서버에서 응답을 모두 Cache 하게 된다.</p><p>이뜻은 결론적으로 400 ~ 5xx (오류 or 실패) 역시 Cache 되어버린다는 뜻이다.</p><p>위에서 이야기 했던것처럼, 내가 만든 API서버는 처음에는 404의 결과가 나오다가 데이터가 들어오면 200으로 바뀌는 서버다.</p><p>당연히, 처음 요청했을때 404를 CloudFront가 Cache하기 때문에 MAX TTL 시간이 지날때까지 결과는 404로 Cache되게 되는것이다.</p><h3>AWS CloudFront에서 Error Status Code에 대한 Cache전략 변경 방법</h3><p><a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/HTTPStatusCodes.html">How CloudFront Processes and Caches HTTP 4xx and 5xx Status Codes from Your Origin - Amazon CloudFront</a></p><p>해당 이슈를 해결 하기 위하여, 구글을 통해 검색을 해본 결과 역시나 많은 사람들이 나와 비슷한 이슈로 삽질을 하고 있었다.</p><p>이제 이 문제를 해결 할 방법을 정리 해보면, 우선 CF설정으로 들어간다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/912/0*aCGyERxlmuwb0f-3.png" /></figure><p>그리고 상단 탭중 “Error Pages” 탭을 선택하고 Create Custom Error Response를 클릭한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/795/1*ggfYLAfWTMbHCPsXuHQcgQ.png" /></figure><p>그럼, 정책을 변경할 Error Status Code와 Cache TTL을 지정할수있게 된다.</p><p>이렇게 되면 Error를 Cache 하는 문제를 해결 할 수 있다.</p><h3>마치며</h3><p>사실 처음에 되게 당황스러운 이슈였다. 분명 디비에 결과가 있는데 결과가 없다고 하는 메세지가 나오고 있었기 때문이다.</p><p>하지만, 처음에 서버의 아키텍처를 설계 했을때, CF에 대해 조금만 더 깊게 알아봤으면 이런 이슈는 없었을것같은데, 이 부분에 대해서는 앞으로 조금 더 조심해야 할 부분이라고 생각된다.</p><p>어쨌든, 나와 같은 이슈를 겪는 사람이 이 글을 보고 명쾌하게 해결 했으면 하는 바램과 함께 이 글을 마치겠습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=cd9b21affaa2" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>