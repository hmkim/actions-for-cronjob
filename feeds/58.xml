<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kingbbode</title>
    <description>개발 블로그</description>
    <link>https://blog.kingbbode.com/</link>
    <atom:link href="https://blog.kingbbode.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 07 Feb 2019 04:25:33 +0000</pubDate>
    <lastBuildDate>Thu, 07 Feb 2019 04:25:33 +0000</lastBuildDate>
    <generator>Jekyll v3.7.4</generator>
    
      <item>
        <title>3년차 웹 개발자</title>
        <description>꼭 되짚어 보고 싶은 것들만 줄여 지난 3년차를 회고해본다.
(2달 동안 썼다 지웠다를 반복하며, 늦은 급마무리를 지었다.)

개발관



3년차에는 내가 어떤 개발자가 되고 싶은지 명확한 개발관이 생겼다.

나는 기술에 매몰되어 가는 개발자였다고 생각한다. 그동안의 나는 기술을 쫓았고, 트렌드를 따라가려 했으며, 깊이를 더하기 위해 노력을 해왔던 것 같다. 물론 이것은 개발자로서는 당연한 것들이다. 올해 많이 깨져버린 것은, 이것보다 중요한 것이 있다는 것이다.

3년차에서 가장 머리 속에 깊게 남는 말은 팀장님께 들었던 이 말이다. (정확하지는 않지만 이런 뉘앙스?)

“용근님이 처음 작성하신 코드가 더 효율적이고, 더 좋은 기술로 안정적일 수도 있다. 하지만 우리는 구성원 모두 함께 할 수 있는 개발을 해야한다.”

처음에는 많이 아이러니 했다. 왜냐하면 팀장님은 내가 알고 있는 실력 있는 개발자 중에서도 탑급이였기 때문이다. 기술력이 충분히 있음에도 이분의 기술 선택과, 프로젝트 설계에는 사람이 있었던 것 같다.

“나는 내가 잘하는 개발을 하고 있는가, 함께 할 수 있는 개발을 하고 있는가?”

내가 생각하게 된 “기술보다 더 중요한 것”은 개발과 유지보수에 대한 비용까지 생각하는 개발이다. 그리고 그것을 개인적인 차원이 아닌 협업을 한다는 차원으로 생각하는 것이다.

팀장님께 위 말을 들었을 때의 일이다. 나는 개편 중인 시스템에서 꽤나 중요한 부분에 대한 구현을 맡았다. 그리고 코드리뷰 과정에서 두번의 반려를 당했다.

첫번째 반려는 구조의 복잡도 이다. 조금은 먼 미래를 보고 성급한 모듈화를 하였다. 이 구조는 오히려 구조에 대한 파악과 가독을 어렵게 했다. 모듈화 자체가 잘못되었던 것은 아니다. 그러나 앞으로 생기지 않을지도 모를 확장성를 고려한 성급한 모듈화 가 지나치게 분리된 구조를 만들어낸 것이다. 그리고 이 구조 또한 내가 만들어낸 구조이므로 내가 생각하기엔 쉽다고 생각하겠지만 남들에게는 어려운 기능이 아님에도 구조를 파악하기 위한 학습비용 을 발생시켰다. 모듈화에 대한 성급함도 있었지만, 내가 아닌 다른 사람을 생각하지 않았던 것도 컸다.

두번째 반려는 기술의 선택 이다. 분명 검증이 되었고, 코드양 자체도 줄일 수 있지만 현재 시스템에서 사용하지 않는 학습비용이 필요한 기술을 사용했다. 이 때 팀장님께 위의 말을 들었다. 예전부터 자주 생각했던 말이 있다. 기술을 사용하려고 문제를 찾는 것이 아니고, 문제를 해결하기 위해 기술을 사용해야한다는 것이다. 이 피드백을 계기로 나는 여기에 한가지를 더 붙여 생각하게 되었다. 현재의 문제만 해결하기 위해 기술을 선택하는 것이 아니고, 서비스(시스템)을 (앞으로도) 더 잘 만들기 위해 현재의 문제를 해결할 수 있는 기술을 선택해야 한다

좋은 프로젝트나, 좋은 시스템은 한 명의 영웅 개발자가 만드는 것이 아니고 함께 협업하는 모두의 시너지로 만들어진다고 확신한다. 그래서 결론은 나는 기술로 발라버리는 영웅 개발자가 되기보다는, 기술을 바탕으로 주변에게 버프를 줄 수 있는 개발자가 되고 싶어졌다는 것이다.

그리고 그것을 실천하기 위해 어렵고 바쁜 3년차이기도 했다. 1년동안 ‘결제’, ‘주문’ 이라는 2개 프로젝트의 개편을 완료했고, 세번째 프로젝트의 개편을 진행 중이다. 개편 과정을 거치며 무엇이 좋은 프로젝트인지, 좋은 코드인지를 끊임없이 고민하고 있다. 객체지향적인 코드, 테스트 코드의 중요성, 스프링을 잘 사용항는 것 이 일단 내 기준의 좋은 프로젝트의 기본이다(회사에서). 그리고 거기에 분리와 통합, 올바른 기술 선택 등이 경험으로 달라붙고 있다. 정답이 없기때문에 참으로 어려우면서도 재밌다.

3년차에 받은 피드백 중 하나인 이 말이 현재의 내 4년차를 만들어가고 있다.

“단순히 개발을 잘한다를 넘어서 올바른 개발이 무엇인지 고민하고 노력하는 분이라 생각합니다”

이 말을 더 많은 사람들에게 듣고 싶다.



코덕 (https://co-duck.com)

3년차 목표 중 하나가 개인 서비스를 갖는 것이었다. 그리고 결국 만들어냈다. 그리고 이것이 단순히 개인 서비스를 갖고 운영해보는 경험을 갖고 싶어서 쥐어짜내 만들었던게 아니고, 내가 만들고 싶었던 서비스를 만들었다는 점에서 굉장히 만족스럽다.



코딩덕후 프로젝트인 코덕은 아래와 같은 생각으로 만들어졌다.


  개인적인 개발 공부에 대한 동기부여, 재미를 즐 수 있는 시스템을 만들고 싶었다
  꾸준한 공부에 대한 보상을 주고 싶었다
  자극을 받을 수 있는 시스템을 만들고 싶었다
  꾸준한 개발이 현실의 취업, 이직에 도움이 될 수 있도록 도와주는 시스템을 만들고 싶었다


이러한 모든 생각들은 전 회사에서 만난 사수로부터 시작되었다

나는 운이 좋았다. 웹개발을 시작하며 만난 사수가 엄청나게 자기계발을 잘 하시는 분이었다. 일일커밋은 물론, 꾸준한 블로깅, 자기 학습을 통해 스스로 성장하고 있는 모습을 나에게 적나라하게 보여주었고, 나는 그런 사수를 자연스럽게 따라하게 되었었다. 그리고 그러한 활동들은 자연스레 내 현실세계의 평가에도 좋은 영향을 미쳤다.

그렇게 열심히 하는 사수의 모든게 나에겐 자극 이었다. 그리고 나뿐만이 아닌 당시 회사의 내 주변의 많은 개발자들이 나와 같이 그분의 성실함을 따라가기 위해 노력했다. 우리는 그렇게 서로 선의의 경쟁을 했었다고 생각한다. 퇴근 후 술 한잔하고 집에 왔을 때도 사람들의 깃헙을 들어가보며

“아 다들 또 커밋했네”

하며 12시가 되기 전 부랴부랴 무엇이든 커밋을 하기도 했었다. 가끔 의미없는 커밋을 할 때면 스스로 자괴감이 많이 들었다. 그래서 “장난감 프로젝트” 들을 구상하게 되었다. 그러면서 정말 다양한 도전들을 하게 되었고 많은 유의미한 성과들을 얻을 수 있었다.

이런 과정들로 “장난감 프로젝트”, “샘플 프로젝트” 등을 만드는 것, 그리고 꾸준히 무엇이든 공부하는 것이 나에게 당연한 것들이 되었던 것 같다. 주변에서 좋은 소리를 들을 수 있는 개발자로 성장했고, 스스로 나의 개발관을 갖기 시작할 때쯔음부터는 더 이상 일일커밋을 집착하진 않았다. 이때부터가 정말 나만의 학습법으로 꾸준하게 무언가를 공부하게 되었다.

나는 나와같은 경험을 갖기를 내 주변의 시작, 도전하는 개발자들에게 많이 추천했다. 의미가 없더라도 일일커밋을 하고, 주변에게 자극을 받으며 좋은 습관들을 만들어내기를 기대했다. 그러나 생각처럼 되지 않았다. 자극을 받기도 쉽지 않았고, 경쟁의 대상은 거의 없다싶이였고, 여러가지 환경적인 상황이 동기부여를 일으키지 못했다. 그래서 무언가가 있었으면 좋겠다고 생각했고, 생각의 정리 끝에 코덕 을 만들게 되었다.

나는 운이 좋았다. 내가 운으로 얻게 된 것들을 시스템적으로 비슷하게라도 경험 시켜주고 싶다.

코덕은 진행 중

토이 프로젝트라는 개발적인 측면에서 얻게 된 것은 회사 블로그(http://woowabros.github.io/experience/2018/11/12/toy-project.html)에서 이미 한번 회고를 했어서 생략하겠다.

현재의 코덕은 아직 내가 이루고자 했던 것들을 많이 못 이루었다. 그래서 회사 블로그 글을 쓰며 등장했던 것을 제외하고는 특별한 홍보도 하지 않았다.

운영하며 내 생각 이하로 사람들의 무언가를 이끌어내지 못한 부분도 많고, 아직 기능적으로도 등장하지 못한 것들이 많다. 아래는 앞으로 진행될 과제들이다.


  소통할 수 있는 공간을 만들 것이다. 무엇이 되었든 소통을 통해 자극을 받을 것이라는 기대감이 있다.
  시즌 데이터 이상의 개인화된 레벨과 리그를 만들 것이다. 생각 이상으로 꾸준히 이미 잘하고 있던 사람들이 많았던 것 같다. 그래서 뉴비들이 등장하기 쉽지 않은 것 같다. 개발자가 점진적으로도 성장을 할 수 있는 구조가 필요했다.
  사용자의 개인 페이지가 하나의 이력서로서의 기능을 갖을 수 있도록 더 고도화하고, 현실 세계에 영향을 미칠 수 있도록 해야한다. 이것은 어떻게 풀어나갈지는 미지수다.


기능적으로도, 이상적으로도 풀어내야할 과제들이 있다. 4년차에도 기대가 된다.

코덕에서 재밌었던 것들

현재는 약 300명 정도의 회원만 있다. 그래서 유의미한 데이터일지는 모르겠지만 몇 가지 통계를 정리해본다.


  레벨 분포도




시즌들에서 비슷한 분포 현상이 보였다. 시작과 중간, 끝인 일덕, 사덕, 십덕 각 3개 계층이 가장 두꺼운 3개 계층이라는 것도 많은 것을 생각하게 했던 것 같다.


  일일커밋터




jojol**님 contributions chart..


  jojol**
  Integero**
  ahribo**
  johngr**
  betterfly**
  nekisse-l**
  nokch**
  reck1e**
  woooooo**
  ysm06**
  gyumin-k**
  geonwoo-jeo**
  SeonHyung**
  Kim-JunHyeo**
  hanmins**


일일커밋을 하고 계신 분들이 많아 많이 놀랬다. 존경합니다.


  언어 분포




현재 자바 개발자가 많긴 하다.


  PV




어떻게 알고 들어와주신 모두들 감사합니다.



다시 만남

지난 2년차 회고에서 사수와 동기를 모두 보냈었는데..





(2년차 웹개발자 - 회고 중)

이번에는 사수, 동기, 부사수 를 모두 현재 회사에서 (추천과 추천의 추천 등등으로) 다시 만나게 되었다. 지난 회고에서는 사수와 동기의 이직을 적었는데, 놀랍게도 둘 모두 다시 같이 있게 되었다.

나를 현재의 회사로 불러준 나의 사수는 내 3년차에도 역시 나의 많은 고민을 들어주고 조언해주며, 항상 커더란 자극제가 되어주고 있다.

내가 가장 힘들어 하던 시기에, (힘들게) 와준 내 동기에게도 너무 고맙다. 개편 중간의 바쁜 시기에 합류하여 미안하기도 했고 고맙기도 했다. 아무튼 덕분에 나도 흔들리지 않고 개편을 끝까지 잘 마칠 수 있었다.

동기가 이전 팀에서의 나를 지탱해줬다면, (전) 부사수는 현재 팀에서 든든한 동료가 되주었다. 오자마자 큰 프로젝트에 함께 합류하였는데 잘해주고 있어서 뿌듯하고 고맙다.

세분 모두에게 너무 감사하고, 다시 함께 일할 수 있어서 정말 든든하다.



4년차에는?

3년차에는 회사 적응과 코덕 을 핑계 로 많은 것들을 포기했었다.



대표적으로 개인 블로그, 오픈소스 기여 노력, 온라인 커뮤니티 활동 활동이다. 앞으로는 이 부분들에서 조금 더 신경을 써야겠다. (+ 코덕에서도 해야할 일들도 많다.)

블로그

1년 동안 고작 5개의 블로깅을 했다. 거의 신경을 쓰지 않은게 사실이다. 쓰고 싶은 글감도 많았지만, 글감만 올려두었다가 삭제하기를 반복했던 것 같다. 지난 날을 반성하며, 세미나 후기나 회고를 제외하고 2달에 한개씩은 기술 블로그를 작성해야겠다.

오픈소스 기여

오픈소스 기여는 방관이였던 것 같다. 문제가 생겼을 때 찾아보거나 들어가보지 않고 다른 방식으로 회피를 한 적이 많다. 무언가 문제가 있는 건 알고 있었지만 크게 신경쓰지 않았었다. 너무 나태하지 않았었나 반성하며 기여에 대해서도 조금 더 신중한 노력을 해야겠다고 생각했다. 앞으로도 회사에서 수많은 문제를 해결해야할 것이다. 그러다보면 아마 한개쯤은 발견하지 않을까 생각한다. 물론 기여를 하려고 코드를 찾는건 매우 싫어하므로 당연히 앞으로도 하지 않을 것이므로 목표는 운 좋으면 1개 정도로 잡아보아야겠다.

온라인 커뮤니티 활동

마찬가지로 아무것도 하지 않았다. 한국 젯브레인 사용자 그룹은 관리자로 임명되있음에도 아무 것도 안했다. 정말 죄송한 마음뿐이다. 모임에 기여할 수 있도록 신경써서 프로젝트를 진행할 예정이다.

코덕

코덕은 위에서 말한 것처럼 해야할 과제들도 많다. 이 과제들을 모두 해소하는 것이 4년차의 큰 목표 중 하나이다. 그리고 영상 시대이니만큼 앞으로 코덕에서 개발될 기능들은 영상으로 라이브코딩 기록을 남겨 유투브에 올려볼까도 생각 중이다. (코드를 공개하기 창피하니 그 전에 리펙토링을 해야할 것도 같고..)



마무리

이전 회고에서는 내 앞으로의 고민들을 어떻게 해결해갈까라고 마무리했다면, 이번 회고에서는 내가 뭘 어떻게 해야겠다라고 답을 내고 마무리를 할 수 있어졌다. 끊임없는 자기반성이 내 3년차의 요약인 듯 하다. 물론 틀렸을 수도 있지만, 계속하여 되돌아보며 반성하고 고쳐나가도록 하겠다.



최고의 동료들을 많이 만났다. (전)사수, 동기, 부사수와 그냥 최고라고 말할 수 밖에 없는 팀장님, 개발잘알 호돌맨, 알구몬, 일잘알 우수사원, 이상적인 시니어 개발자, 나와 개발 컨텍스트가 닮은 동료들, 어마무시한 신입사원들 등등등 앞으로가 정말 기대된다. 끗.
</description>
        <pubDate>Sun, 03 Feb 2019 00:00:00 +0000</pubDate>
        <link>https://blog.kingbbode.com/posts/who-am-i-3</link>
        <guid isPermaLink="true">https://blog.kingbbode.com/posts/who-am-i-3</guid>
        
        <category>think</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>프로젝트가 장난이야?!</title>
        <description>안녕하세요. 저는 배달의 민족 주문시스템을 개발하고 있는 권용근입니다.

개발자의 개인 장난감인 토이 프로젝트에 대해서 이야기해보려고 합니다. 저는 웹 개발 입문과 거의 동시에 토이 프로젝트를 시작했고 이 프로젝트들을 통해 많은 성장을 이루었다고 생각하고 있습니다. 그래서 토이 프로젝트를 통해 무엇을 얻을 수 있었는지에 대하여 말해보려고 합니다.

토이 프로젝트란?

토이 프로젝트가 무엇일까요? 크고 간단하게 2가지로 나눈다면 이렇습니다.

1. 여유시간만 투자한다.

본업과 건강에 영향을 미치지 않는 선에서 여유시간을 투자해야합니다.

2. 어떠한 목적을 달성한다.

기능, 스펙, 규모, 일정에 대한 제약은 있을 수도 있고 없을 수도 있습니다. 런칭 혹은 배포도 마찬가지입니다. 프로젝트가 반드시 런칭되거나 배포될 필요는 없습니다. 이것은 내가(혹은 우리가) 프로젝트의 목적을 무엇으로 정하냐 에 따라 달라지게 됩니다.

여유시간을 투자하여, 어떠한 목적을 달성하는 개발 프로젝트가 토이 프로젝트 인 것 입니다. 샘플 프로젝트, 기능을 제공하는 라이브러리 프로젝트, 서비스를 제공하는 웹,앱 프로젝트 등등 무엇이든지 나올 수 있지요!



나의 토이 프로젝트

많은 토이 프로젝트를 진행했었지만, 그 중 대표적으로 챗봇 프로젝트, 코딩덕후 프로젝트 라는 2가지 저의 토이 프로젝트를 중심으로 이야기해보려 합니다. 그래서 일단 간단히 2가지 프로젝트를 소개하겠습니다.

챗봇 프로젝트


저의 웹 개발 시작과 거의 거의 비슷한 시기에 시작했던 첫 토이프로젝트 입니다. 저의 첫 회사에서 꽤 많은 구성원들이 사용해주었던 대화형(ARS형) 챗봇이였습니다. 나중에는 핵심 코어 기능만 분리하여 프레임워크화 하여 Boot Starter Pack으로 제공하였고, 슬랙, 텔레그램, 라인 등과도 연동하였습니다. 회의실 현황, 예약, 사다리, 심심이, 섣다 기능 등 온갖 잡 기능을 하나씩 추가해나갔던 장난감이였습니다.

Github Link : kingbbode/spring-boot-chatbot

코딩덕후 프로젝트



개발자들의 Github 활동을 장려하고자 Github 활동을 시각화해주는 서비스 프로젝트 로 2018년 11월부터 정식 시즌을 오픈하여 진행 중인 프로젝트입니다. 3명의 구성원들과 함께 진행하고 있는 첫 팀 프로젝트이고, PM 역할을 맡아본 첫 프로젝트 입니다.

Site Link : co-duck.com



위 두 가지 프로젝트를 진행하며 경험할 수 있었던 것, 얻을 수 있었던 것에 대한 이야기를 시작해보겠습니다.

토이 프로젝트로 경험할 수 있었던 것 &amp;amp; 얻을 수 있었던 것

1. 기술에 대한 접근 기회

회사에서 만들게 되는 서비스는 안정성을 추구합니다. 그래서 직접 만들기보다는 잘 만들어진, 충분히 검증된 프레임워크, 라이브러리를 선택하고 조합하여 사용을 합니다. 때문에 본인이 직접 라이브러리와 프레임워크를 구현하는 경험을 가지기는 쉽지가 않습니다.

토이 프로젝트는 무엇이든 목적이 될 수 있고, 무엇이든 해도 되는 프로젝트이기 때문에 저 스스로에게 많은 기회를 만들어줄 수 있었습니다.

기회 #1 프레임워크 만들어보기

처음부터 프레임워크를 만들기로 했던 것은 아니였습니다. 챗봇 프로젝트를 진행하면서, 챗봇 개발에 대한 진입을 낮추어주자는 목적을 달성하기 위해 프레임워크 처럼 만들어보자는 결론이 나온 것이지요.

어떻게 하면 스프링과 같이 쉽게 기능을 작성하도록 할까에서 시작되어, 스프링의 어노테이션 기반의 메타 프로그래밍 방식을 사용하게 되었습니다.

@Brain
public class FirstBrain {

    @BrainCell(key = &quot;따라해봐&quot;, function = &quot;echo-start&quot;)
    public String echo(BrainRequest brainRequest) {
        return  &quot;말해봐&quot;;
    }

    @BrainCell(function = &quot;echo-end&quot;, parent = &quot;echo-start&quot;)
    public String echo2(BrainRequest brainRequest) {
        return  brainRequest.getContent();
    }
}


이런 식으로 말이죠. 이를 가능하게 하기 위해, Java Relfection API 를 알아야 했고, 동적으로 생성된 챗봇을 위한 Bean 을 관리하기 위해 Spring BeanFactory Container 와 닮은 BrainFactory도 만들게 되었습니다. (물론 완성된 구현물이 Spring Framework 에는 훨씬 못미치지만.. )

서비스를 개발할 때 사용하거나 경험해보지 못할 기술과 방법들을 직접 사용해볼 수 있었고, 이런 기술들을 사용하여 만들어진 스프링 프레임워크의 전체를 부지런하게 까보기 시작했고, 이해하기 위해 노력을 했습니다. 이를 통해 내가 사용하고 있는 프레임워크가 내부적으로 대략 어떻게 돌아가는지를 조금은 이해할 수 있게 된 큰 계기가 되었습니다.

기회 #2 Spring Boot Starter 만들어보기

마찬가지로 만들어진 기능을 쉽게 제공하기 위한 고민을 하다가, Spring Boot 의 Starter Pack 을 만들어보기로 했습니다.

이 때가 약 3년 전으로 국내에서 아직 스프링 부트의 대한 오해들이 만연하던 시기이기도 하였습니다. 물론 당시 신입이였던 저는 그런 것은 모르고, 제가 사용하는 프레임워크를 이해하기 위해 노력을 하고 있던 시기이기도 합니다.

한글 문서가 거의 없던 당시에 공식 문서를 나름 열심히 파고, 소스를 직접 하나씩 모두 들여다보았던 삽질의 기억들이 납니다.

그래서 단일 모듈의 프로젝트에서



이런 구조의(중간 버전의 레파지토리가 삭제되어 현재 구조로 대체) 멀티 모듈 프로젝트로 탄생되었죠!

이 때 부트에 대해서 정말 많은 이해를 할 수 있었고,



덕분에 2017 Spring Camp 에서 연사로 발표도 할 수 있었습니다.



2. 새로운 관심사

신기술이나 이전에 사용해본 적 없는 기술을 운영중인 서비스에 바로 적용할 수 있을까요?



기술이 이미 충분히 검증되었고, 스스로 문제가 발생했을 때 빠르게 해결할 수 있을만큼 기술에 대하여 내가 성숙되었다면 고민을 해보겠지만, 그 이전에는 절대 반대를 할 것 같습니다.

그럼 토이 프로젝트로 사용을 해본 후에 서비스에 적용을 하면 될까요?



내 토이 프로젝트가 회사 이상의 대규모 트래픽을 받고 있으며, 회사보다 복잡한 비즈니스적 요구사항을 가지고 있다면 고민을 해보겠지만, 그 이전에는 절대 반대를 할 것 같습니다.

&quot;새로운 기술, 새로운 모델을 쓰는건 현재 환경에선 더이상 문제를 해결할 수 없다고 느낄때만 엄청 엄청 부담감을 느끼면서 적용한다.&quot;
by jojoldu


그럼에도 저는 토이 프로젝트에서 꼭 새로운 관심사를 사용해보시길 강력하게 추천드립니다. 저는 호기심을 잃은 개발자는 성장할 수 없다고 강하게 믿고 있습니다. 현재 내 업무에서 사용하지 않는 것과 내가 가진 기술에 대한 호기심은 전혀 무관합니다. 어떠한 기술로 무언가를 해결해본 경험은 언젠가 반드시 도움이 될 것 입니다.

도움이 되었던 사례 #1 REDIS 활용

챗봇 프로젝트는 처음에 1 DEPTH 를 가지는 매우 단순한 챗봇이였습니다. 공백 split 을 사용하여 명령어 뒤의 기능을 수행하도록 하였습니다.

#투표 짬뽕 -&amp;gt; 짬뽕을 투표한다


챗봇으로 만드려는 기능이 점점 많아짐에 따라 명령어가 점점 난해지기 시작했습니다.

#연차 사용 반차 2018-11-04 오전 -&amp;gt; 2018년 11월 4일 오전반차를 사용한다.


그래서 Redis 를 활용하여 챗봇 대화의 짧은 Expire 의 세션을 만들었고, 그 세션의 존재에 따라 현재 해당 유저가 대화 중인 상태인지 아닌지를 판단하는 기능을 만들어 대화 방식의 채팅 방식을 만들었습니다.



이때 제가 하고 있는 서비스에는 Redis 비슷한 것도 사용하지 않았던 시기였습니다.

그러나 경험은 개인의 만족으로 끝나지 않았습니다. 현재 배달의 민족의 비동기 결제 시스템을 적용할 당시 주문시스템의 사용자 경험과 관련된 결제 완료를 확인하는 부분에서 이 방식을 제안했고, 이 기능은 현재도 잘 쓰고있는 기능이 되었습니다.



2년 뒤 다른 업무에서 이 기능을 사용하게 될거라곤 생각도 못했습니다. 그러나 이렇게 저의 본업에도 도움이 경험이 되었습니다.

도움이 되었던 사례 #2 ADMIN 뚝딱

현재는 서버개발자를 담당하고 있지만, 이전 회사에서는 프론트와 서버를 모두 개발하던 개발자였습니다. 서버는 서버대로 재미가 있고, 프론트는 프론트대로 재미가 있었지만 과감히 서버개발자의 길을 선택하였고 프론트엔드는 완전한 취미가 되었습니다.

담당 업무에서 프론트엔드가 완전히 없어진 후 VueJs 라는 기술이 화제가 되고 있었습니다. 개발자의 호기심은 무죄입니다. 그래서 당시 진행 중이던 토이 프로젝트 코딩덕후 프로젝트 의 프론트엔드를 VueJs로 만들기로 했고 VueJs를 신나게 공부했었습니다.

이 때도 마찬가지로 제 업무에 프론트엔드는 완전히 없을 줄 알았습니다.

백오피스 필요없는 시스템은 역시 없는 것이였을까요? 결국 백오피스에 대한 요구사항이 생기게 되었고, 프론트엔드 경험이 있는 제가 만들게 되었습니다.

총 2개의 어드민을 만들었는데, 기존 다른 프레임워크와 호환되는 css만 사용하여 템플릿 라이브러리를 사용하지 않고 만든 ADMIN은 2주 가 걸렸고, Vuejs 어드민 템플릿 라이브러리를 사용하여 만든 현재의 주문시스템 ADMIN은 2일 만에 만들 수 있었습니다.



(위 그래프는 실제 지표와 아무런 관련이 없음)

당시 바쁜 일정 중 주문시스템 ADMIN이 생각 이상으로 빨리 만들어져 저희 팀의 관리자(팀장님)가 신나했던 기억이 납니다.

결국 서비스와 상관없이 진행했던 토이 프로젝트가 또 다시 저의 본업에 도움이 되었습니다.

3. 풀사이클 개발(Design-Develop-Test-Deploy-Operate-Support)



요즘 많은 곳에서 업무의 세분화로 알지 않아도 괜찮은 것 같은 영역들이 생기고 있습니다. 그 대표적인 예가 서버 개발 직군과 인프라 직군이 아닐까 생각됩니다. 서버 개발자가 정말 인프라에 대해서 몰라도 되는 것일까요?

저는 우아한형제들에 입사한 후 나와 같은 서버 개발자이지만, 인프라 괴물들을 몇 명 만났습니다.



이분들을 보며 확실히 느낀 것은, 내가 인프라를 직접 하지 않게 되더라도, 반드시 알아야 한다는 것 입니다. 인프라를 알고 모르고에 따라서 설계부터 개발, 운영(문제 해결)에 대한 모든 것이 차이가 난다는 것을 알았기 때문입니다. 넷플릭스의 풀사이클 개발자 블로깅에서도 이런 말을 합니다.

Operating What You Build(당신이 구축한 것을 운영하라)!!


그러나 현재 국내 개발자들이 풀사이클 개발을 회사에서 경험하긴 쉽지 않습니다. 그렇다면 어디서 경험할 수 있을까요?! 바로 토이 프로젝트입니다!

코덕 프로젝트는 아키텍처부터 인프라까지 모두 직접 설계하고 구축하여 서비스되고 있는 저의 첫 토이프로젝트입니다. “나 혼자서 하나의 서비스를 처음부터 끝까지 만들 수 있을까?” 라는 궁금증이 항상 있었습니다. 그러던 중 정말 만들어보고 싶은 서비스가 생겼고, 망설임 없이 시작을 하였던 것 같습니다. 토이 프로젝트를 시작한다는 것은 저에게 너무 당연한 일이 되었고, 토이 프로젝트는 정말 토이 프로젝트일 뿐이였기 때문입니다.

코덕 프로젝트

사실 하나의 프로젝트로 만들 수 있었지만, 멀티 프로젝트로 쪼개어 설계를 해보았습니다. 당연히 이런 소규모의 서비스라면 하나의 프로젝트로 만드는 것이 좋은 결정이겠지만, 제가 경험하고 싶었던 것은 분산환경이였습니다. 토이 프로젝트에서 나의 목적을 달성하는데에는 전혀 오버스팩이 아닌 아주 적합한 스팩이 되는 것 입니다.

그래서 해보고 싶던 디자인, TDD, 개발 스타일, 브랜치 전략, 이슈 관리, 배포 방식 등을 모두 해볼 수 있었고, 많은 시행 착오를 통해 더 많은 경험치를 쌓을 수 있었습니다.

그래서 완성된 구조는 아래와 같습니다.



저만의 멋진 구조를 완성시키고 싶었는데, 이 모든 것이 돈 이라는 것을 알게 되었습니다. 회사에서 사용하고 있던 당연한 것들을 적용해보려 하였고, AWS 견적 계산기로 대충 계산을 해보았더니…



(우아한형제들은 빵빵한 AWS 스팩을 제공합니다!)

그래서 비용 최소화 모델로 집에서 잠자고 있던 라즈베리파이까지 동원되어 완성된 구조입니다. 서버에 대한 설정부터 데이터베이스 설치까지 모든 것을 직접 해볼 수 있었던 좋은 경험이 되었습니다. 그 과정에서 호돌맨님의 영상(서버 기본 설정, MariaDB 설치)과 알구몬의 경험을 담은 깨알팁이 정말 많은 도움이 되었습니다.



인프라 괴물님들 다시 한번 감사합니다.

아쉬운 점이 당연히 많습니다. 비용 문제로 AWS 에서 경험해보고 싶은 많은 것들을 아직 사용해보지 못한 것 때문입니다. 그렇지만! 저의 프로젝트는 진행형입니다! (정식 오픈한지 1달도 안된..) 앞으로 트래픽이 (제발) 늘어준다면 분명 더 좋은 경험들을 할 수 있으리라 확신합니다.



Site Link : co-duck.com

많이 이용해주세요 !!

4. 관리자를 이해

저같은 주니어가 어디가서 PM 역할을 해보겠나요? 토이 프로젝트이기에 가능합니다! 소제목으로 관리자를 이해 라고 해놓았지만 사실 관리자는 아직 저에게는 이해할 수 없는 영역입니다. 그럼에도 프로젝트를 진행하면서 느낄 수 있었던 관리자의 일부 모습의 이해 를 이야기 해보려고 합니다!

저는 코덕 프로젝트를 만들기 위해, 3명의 개발자를 합류시켰습니다. 저는 꼭 만들고 싶었던 뚜렷한 프로젝트의 방향과, 취지가 있었기에 프로젝트를 시작였고, 지인들은 개발 경험이 필요하여 합류한 것 입니다.

전체 설계가 끝나고 구현을 시작할 때까지는 모든 것이 순조로웠습니다. 구현해야할 내용을 작게 나누어 TODO 를 작성하였고, 그것을 구성원들에게 뿌리고 구현이 시작되면서 이상한 것들이 나타나기 시작했습니다!

내가 의도한 바와, 실제 구현이 미묘하게 다른 방향으로 흘러가고 있었습니다. 그러던 중 충격적인 말!

이런 기능을 만들어야하니까 만들고 있는데, 사실 이 기능을 왜 만드는지, 만들어서 뭘 하겠다는 건지 전혀 모르겠다.


그때서야 무엇이 잘못되었는지를 알았습니다. “내가 생각하는게 대충 이런거다” 라며 합류를 시켰고, “내가 생각하는게 있으니까, 일단 해놔봐”, “대충 이런건데, 나중에 설명해줄게” 같은 말들을 했던 순간이 스쳐갔습니다. 구성원들이 서비스를 전혀 이해하지 못하고 있던 것 입니다.



그 후 정밀한 PPT 를 만들어, 2시간에 걸쳐서 구성원들에게 프로젝트를 설명을 하였고 그제서야 많은 오해들이 풀리게 되었습니다.

(하지만 그래도 다 이해하진 못하더라는…)

그리고 우아한형제들 을 다시 생각하였습니다. 매월 진행되는 타운홀 행사, 그리고 최근 조직개편 이후에도 회사의 방향에 자세히 설명해주셨던 부문장님, 실장님, 팀장님을 떠올렸습니다.



(찍어둔게 없어서 합성을.. 실제론 꽉꽉 찹니다)

내가 현재 우리 회사의 방향을 알고 있고 이해하고 있다는 점, 고작 3명에게 설명하기도 벅찼었던 나의 모습을 떠올렸을 때야 관리자분들의 그런 모습들을 이해할 수 있었고, 감사하다고 생각이 들었습니다.

추가로..



그리고 구성원들을 쪼고 있는 내 모습에 팀장님을 사알짝 이해할 수 있었… (갈갈갈)

마무리

토이 프로젝트는 이렇 듯 저에게 정말 많은 경험을 선물해주고 있습니다. 개발자는 토이 프로젝트를 무조건 해야한다는 이야기가 아니며, 토이 프로젝트를 해야 좋은 개발자라는 이야기도 아닙니다. 그러나 토이 프로젝트를 하고 있는 개발자는 분명 더 많은 경험을 할 수 있는 개발자라는 것은 꼭 말하고 싶었습니다.

저에게 많은 토이 프로젝트들이 생겼고, 첫 서비스를 하는 프로젝트도 생겼습니다. 이 프로젝트들은 기꺼이 레거시가 되어주어, 레거시를 개선해보는 경험도 시켜줄 것이고, 트래픽이 늘어나 그에 따른 새로운 경험들을 시켜줄 것 입니다. 내가 만든 라이브러리를 사용하는 사람들도 생길 것이고, 그들이 제기하는 이슈도 맛보게 될 것 입니다. 그리고 저는 이 프로젝트들을 통해 더 성장하겠지요?

관심있는 기술, 하고싶은 개발이 있지는 않으신가요? 그렇다면 시작해보세요! 토이 프로젝트를!


</description>
        <pubDate>Mon, 12 Nov 2018 00:00:00 +0000</pubDate>
        <link>https://blog.kingbbode.com/posts/toy-project</link>
        <guid isPermaLink="true">https://blog.kingbbode.com/posts/toy-project</guid>
        
        <category>experience</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>SpringOne Tour Seoul - Spring Cloud Gateway</title>
        <description>2018년 11월 8일 스프링 원 투어 서울 컨퍼런스 중 정윤진님의 Spring Cloud Gateway 세션

Spring Cloud Gateway

SPEC


  Spring 5 +
  Spring Boot 2 +
  API Gateway Pattern


What is an API Gateway?

하나로 요청을 받아, 요청을 분리.


  Routing
  Canary-ing
  Security
  Monolith Strangling
  Monitoring
  Resiliency


Spring Cloud Gateway

Type


  Appliance
  SAAS (ex: ELB)
  Web Server
  Mesh
    
      Side Car Pattern + Proxy Pattern
    
  
  Developer Oriented


History


  
    초기 버전인 spring-cloud-zuul 에서는 Netflix Zuul 1 을 사용
  
  비동기를 지원하기 위해 Netflix 는 Zuul 2 로 업그레이드
    
      하위 호환성 없음
      Netflix 는 자신들의 문제만을 해결
    
  
  Zuul 은 Spring Eco 시스템의 취지에 맞지 않아, Spring Cloud Gateway 에서는 Zuul 2 를 사용하지 않고 새로 만들게 됨.


Spec

  Reactor + Netty
  Non-Blocking


inside Gateway

Handler -&amp;gt; Filter(pre, post, global) -&amp;gt; Service

vs Netflix


  어떤 서비스로 보낼 것인가 - (Netflix : Zuul, Spring : cloud-gateway)
  서비스 중 어디로 보낼 것인가( Netflix : Riborn, Spring : cloud-discovery )


Configuration


  과거 버전에서는 YAML방식을 사용
  과거 버전도 호환하되, Java Configuration 방식 지원


Eco


  Redis RateLimit
  discovery
  histrix
  security
  micrometer
  zipkin(request tracing)


TIP TOOL


  httpbin
  httppie
  wssocket (npm)


Design Idea

Embedded

Backend Service 가 깨지기 쉬운 형태

Facade


  Client 에서 특정 요청은 Backend 로 보내고 싶지 않을 때.
  Micro Service 로 전환.


Corss-Cutting + App-Specific


  Gateway to Gateway


END


  slides.com/spencer/spring-cloud-gateway
  github.com/ryanjbaxter/gateway-s1p-2018

</description>
        <pubDate>Thu, 08 Nov 2018 00:00:00 +0000</pubDate>
        <link>https://blog.kingbbode.com/posts/spring-one-tour-api-gateway</link>
        <guid isPermaLink="true">https://blog.kingbbode.com/posts/spring-one-tour-api-gateway</guid>
        
        <category>spring</category>
        
        <category>think</category>
        
        
        <category>seminar</category>
        
      </item>
    
      <item>
        <title>스프링캠프 2018-Consumer Driven Contract</title>
        <description>요즘 기존 프로젝트의 일부를 새로운 프로젝트로 떼어내는 작업을 하고 있다. 노후된 프로젝트인 점과 내가 알고있는 프로젝트가 아니라는 점이 지옥을 맛보게 해주고 있다. 정리를 하다보니 기능이 중복된, 프로젝트의 성격 이상으로 많은 정보를 제공하는, 불필요하게 많은 정보를 요구하는 등 이상한 End Point들이 발견되었다. 아마 오랜시간 요구사항이 점점 늘어나면서 불가피하게, 혹은 요구했었지만 이제는 다르게 사용하는 API가 되었지 않을까 생각한다.

정리를 위해 이 API들을 사용하는 서비스들에 대해서 전부 조사를 해야했고, 굉장히 많은 시간을 소비해야 했다. 정리를 하고난 후 보니 중복된 것, 사용되지 않는 것, 불필요한 요구, 제공 스펙, 그리고 그것들을 위한 테스트 코드들이 보였다. 현재와 미래의 모든 클라이언트의 필요를 충족하는 API 만들려고 시도했기 때문일 것이다.




  일부 서비스 개발자는 현재 및 미래의 모든 클라이언트 요구 사항을 해결하기 위해 시도하는 서비스 API를 작성하여이 문제를 해결하려고 노력 했습니다. 더 자주는 아니지만, 이러한 노력은 누락 된 요구 사항이 확인되고 예기치 않은 변경 사항이 요청되기 때문에 쓸데없는 것으로 판명 됩니다. 클라이언트가 API를 사용하는 방법을 이해하는 서비스 소유자는 큰 이점이 있습니다. 이들은 서비스 변경으로 인해 클라이언트가 중단되는시기를 식별하는 클라이언트 위주의 테스트를 작성할 수 있습니다. 그러나 서비스 소유자가 이러한 테스트를 작성하면 클라이언트가 서비스를 사용하는 방법에 대한 부정확 한 해석 이 될 수 있습니다. 고객 소유자는 서비스 소유자가 기대를 문서화하여 서비스 사용 방법을 이해하도록 도울 수 있지만 이러한 문서가 코드와 스키마에서 생성되어 변경 될 때마다 재생성되지 않으면 신속하게 구식이 될 수 있습니다. 당사자들이 정말로 필요로하는 것은 일련의 자동화 된 통합 테스트입니다.


출처 : servicedesignpatterns-Consumer-Driven Contracts

이런 상황에서 떠오른 것은 CDC(Consumer Driven Contract) 패턴을 소개하며, Spring Cloud Contract 라는 프로젝트를 소개해주었던 Spring Camp 2018 피포탈 김민석님의 세션이였다. 이 날 가장 재미있게 들었던 세션이였던 이 발표 후기가 보이지 않아 기억을 끄집어내어 정리해본다.



Consumer Driven Contract 기법을 활용한 마이크로서비스 API의 진화 ( Spring Cloud Contract )

2018-04-21 pivotal 김민석님

새로운 문제들

마이크로 서비스에서의 API 는 Bounded Context 로부터 생겨나고, 제공자(Producer) 와 소비자(Consumer)의 합의를 통해 스펙이 결정되는 라이프사이클을 갖고 있으며, Rest 기반의 Http 통신 혹은 PUB/SUB QUEUE 기반 Message 통신 기반의 통신을 하고 있습니다.

그리고 애자일, MSA 시대를 맞으면서 아래와 같은 변화가 있습니다.


  Service가 점점 작아지고 많아짐
  Api contract 개선이 더 잦아짐(Agile)
  다른 시간대(Timezone)의 팀간의 협업이 요구됨


점점 더 빠르게(자주) 변경되는 어플리케이션이 생기고 있고, 어플리케이션은 점점 더 작은 단위의 어플리케이션으로 분리되고 있습니다.

그리고 이로인해 생기고 있는 새로운 문제들은


  소비자(Consumer)에 영향없이 제공자(Producer) 서비스에 새로운 것을 추가하거나 삭제할 수 있을까?
  소비자(Consumer)가 서비스를 사용하고 있는지 제공자(Producer)가 알 수 있는가?
  소비자(Consumer)가 원하는 서비스를 제공하고 있는지 제공자(Producer)가 알 수 있는가?
  얼마나 자주 배포할 수 있는가?


그리하여 안전한 API를 위하여 아래와 같은 진화를 위한 패턴들이 등장하였습니다.


  Single Message Argument
  Dataset Amendment
  Tolerant Reader
  Schema Versioning
  Extension Points
  Consumer-Driven Contracts


(이 발표에서 다루는 것은 이 중 Consumer-Driven Contracts 입니다.)

소비자 주도 계약 패턴(Consumer-Driven Contracts)

CDC(Consumer-Driven Contracts)는 소비자(Consumer) 의 요구사항 중심으로 제공자(Producer) 서비스를 진화시키기 위한 협업 패턴으로 소비자(Consumer)와 제공자(Producer)의 협업이 많아지는 사상 입니다.


  제공자(Producer)는 불필요한 서비스 개발을 줄일 수 있음 (make the right thing)
  제공자(Producer)는 개선에 대한 통찰을 얻을 수 있음
  Agile 실현을 위한 자동화를 가속


CDC가 성공하려면 스펙 정의, 문서화, 테스트, 스펙과 일치하는 테스트코드 유지, 모니터링/제어, Gateway 등이 필요합니다. 즉 서로 간의 커뮤니케이션이 핵심이 됩니다. 그래서 우리는 apigee, aws api gateway, kong, swagger 등 다양한 도구들을 사용하고 있습니다. 하지만 아직 부족한 것이 있습니다.

내가 작성한 코드가 스펙과 일관성 있는가? 변화하는 API에 대해서 어떻게 대응할 수 있는가?

이러한 점을 만족 시키기 위해 우리는 테스트를 합니다.

E2E(End to End) 테스트전략은 확실하지만 실제 환경과 유사한 환경을 만들어 내야하며, 많은 시간과 테스트 자원을 소모하기 때문에 비효율적입니다.

그래서 Mock 을 활용하는 테스트 전략이 일반적입니다. 전체를 구성하지 않고 흉내를 내는 Mock 을 활용한 테스트는 작은 테스트 자원으로 빠른 피드백을 받을 수 있습니다. 그러나 테스트가 통과하더라도 실제 서비스에서 실패 할 수 있으며 소비자가 요구하는 스펙과 일관성을 유지하기 어려운 것 은 마찬가지 입니다. 테스트를 만들 때 임의의 케이스를 만들어 성공하게 하는데, 이 때 만들어진 케이스의 정합성이 맞는지 보장하는 메커니즘이 없으며, 스펙으로 정의해놓은 데이터 파일의 최신 관리가 어렵기 때문입니다.

결국 CDC를 성공시키기 위해서는 Contract 정합성 유지 와 스펙과 일치하는 테스트코드 가 필요합니다. 그리고 이를 해결할 수 있도록 도와주는 것이 Spring Cloud Contract 입니다.

Spring Cloud Contract

Spring Cloud Contract 목표


  
    Contract를 공유하는 메커니즘을 제공
  
  
    Contract를 적용할 때 자동화를 통해 확신을 주자
  


Spring Cloud Contract Workflow




  
    소비자(Consumer) 는 Contract 를 정의하여 제공자(Producer) 에게 요청합니다. (Pull Request)
  
  
    제공자(Producer) 는 Contract 를 구현합니다.
  
  
    제공자(Producer) 의 Contract 구현으로 생성된 stub.jar 를 업로드합니다. (Nexus or Spring Cloud Eureka 등)
  
  
    소비자(Consumer) 는 자신이 요청한 Contract 기반으로 구현된 stub.jar 를 다운로드 받아 테스트합니다.
  


Spring Cloud Contract 는 목표를 이루기 위해 아래와 같은 편의 기능들을 제공

API 스펙 지원

Rest 기반의 Http 통신 혹은 PUB/SUB QUEUE 기반 Message 통신을 모두 지원합니다.

Contract 작성 DSL 제공

정의하고 읽기 쉬운 형태로 Contract 작성이 가능하도록 DSl을 제공합니다. 이 DSL 은 groovy 이나 yml 로 작성 가능합니다.

Spring Cloud Contract Plugin

쉽게 사용할 수 있도록 Maven, Gradle Plugin 을 제공합니다.


  contract verifier : 제공자(Producer)용
  contract stub runner : 소비자(Consumer)용


컨트랙트 공유 메커니즘 제공:자동으로 Mock 환경 생성

제공자(Producer)는 Contract 기반으로 자동으로 Mock 테스트를 수행할 수 있습니다.

자동화된 최신화 유지:자동으로 Stub 생성

제공자(Producer) 가 Contract 기반으로 정의한 테스트 Mock을 제공하여, 소비자(Consumer)가 테스트에서 사용 가능합니다. application jar도 제공하기 때문에 쉽게 Mock 어플리케이션 서버를 띄울 수도 있습니다.

Spring Cloud 연동


  Spring cloud를 연동하는 프로젝트 지원
  Spring cloud eureka에 stub 자동등록 지원




데모를 제외한 발표는 여기까지였다.

더 자세한 내용은 제공 Slide 자료로! : https://www.slideshare.net/MinseokKim4/consumerdrivencontract-with-spring-cloud-contract-at-spring-camp-2018

데모샘플 : https://github.com/myminseok/spring-cloud-contract-beer-sample

아래는 발표 이후 추가로 궁금해져 찾아본 내용이다.



Document와 Spring Cloud Contract는 별게여야 하는가?

요즘 Swagger의 어노테이션 지옥을 맛본 후 Spring Rest Docs로 넘어오게 되었다. 문서 작업을 위해 조금의 번거로운 작업을 해줘야 하지만, 이러한 문서 자동화 도구를 통해 문서와 코드를 일치시킬 수 있다.

그렇다면 스펙과 코드를 일치시키는 Spring Cloud Contract는 Spring Rest Docs와 어떻게 사용하여야 할까?

역시나 Spring Cloud Contract에서 지원을 해주고 있다. Spring Cloud Contract with Rest Docs에 잘 설명하고 있다.

Rest Doccumentation 테스트 코드에 Contract 를 끼워넣어 검증을 수행한다.

.andDo(MockMvcRestDocumentation
    .document(&quot;shouldRejectABeerIfTooYoung&quot;, SpringCloudContractRestDocs.dslContract()));


이미 만들어진 RestDocs 에 Contract 를 끼워넣었는데, 역으로 Contract 기반으로 RestDocs를 생성할 순 없을까?

역시나 이미 진행 중이였다!

Spring Cloud Contract 이슈 에 등록이 되어있었다. 이 이슈는 받아들여져 2.0.0.RC2 버전에 들어갔다. 빠른 시일 내에 정식버전에서 사용할 수 있지 않을까 생각한다.

마무리

요즘 세미나들에서 자사 제품 끼워팔기를 많이 보았다. 이 세션 역시 그렇지 않을까 우려하면서도 듣게 되었다.

약팔이 당하진 않을꺼야!

그러나



넘어가버렸다. 요즘 같은 시대의 흐름에서 반드시 생기고 고민하게 되는 내용에 대한 솔루션이였기 때문이다.

모두가 소비자(Consumer) 이자 제공자(Producer) 가 되는 구조에서 도입은 쉽지 않을 것이다. 한쪽이 일방적으로 제공하는 것이 아닌, 서로 모두가 추구해야하기 때문이다. 쉽지 않지만 언젠가 반드시 필요한 기술이 아닐까 생각한다.
</description>
        <pubDate>Fri, 08 Jun 2018 00:00:00 +0000</pubDate>
        <link>https://blog.kingbbode.com/posts/cdc-srping-cloud-contract</link>
        <guid isPermaLink="true">https://blog.kingbbode.com/posts/cdc-srping-cloud-contract</guid>
        
        <category>spring</category>
        
        <category>think</category>
        
        
        <category>seminar</category>
        
      </item>
    
      <item>
        <title>결제 시스템 성능, 부하, 스트레스 테스트</title>
        <description>
  회사 블로그에 작성한 글 : 우아한형제들 기술블로그


안녕하세요. 우아한형제들에서 결제시스템을 개발하고 있는 권용근입니다. 입사한 지 4개월 만에, 드디어 우아한형제들 기술 블로그에 글을 남기게 되어 감회가 새롭습니다.

저는 최근 결제 시스템의 개비를 진행하며 경험한 성능, 부하, 스트레스 테스트 경험을 작성해보려고 합니다.

시스템 개비

입사하고 보니 저에게는 결제 API 단순화, 결제 시스템 데이터베이스 분리 및 파티션 도입, 비동기 결제 시스템 개발 이라는 굵직굵직한 작업들이 기다리고 있었습니다.

Java, Spring Framework, ORM 등의 기술 지식은 그간 해온 게 있기 때문에 (구글링이 있기 때문에) 파악하는데 어렵지 않았지만, 이미 구축되어 있는 시스템을 손대는 것은 쉬운 일이 아니었습니다.

“거대 규모 프로젝트에서 내가 수정한 코드가 어떤 사이드 이펙트를 발생시킬지..”

이래서 존재하는 것이 바로 테스트 코드 !! 다행히 테스트 코드를 지향하는 프로젝트였기에 작성된 테스트의 보호 아래 신나게 개발을 할 수 있었습니다.



결국 테스트를 모두 통과시키며, 개발이 완료되었습니다!

그리고 이때부터 본격적인 미지의 영역에 대한 공포가 시작되었습니다.

공포의 시작



내가 만든 이 시스템은 실제 장비에서


  어느 정도의 부하 를 견딜 수 있는가?
  시스템(데이터베이스, 서버), 자원(cpu, disk, memory 등)에서 병목 이 생기진 않는가?
  자원을 효율적 으로 사용하는가?
  메모리 누수, 오류, 오버플로우 는 발생하지 않는가?
  최악의 상황 에선 어떤 동작을 하는가? (예측하고 대비하기 위하여)
  장애 조치와 복구 가 잘 동작을 하는가?


전혀 감이 안 잡혔습니다. 이것은 흔히 말하는 localhost:8080 레벨에서는 확인할 수 없는 문제였습니다.

위의 수많은 공포에 대하여, ‘내가 예상하는 데로’, ‘내가 정의해놓은 데로, 작성해놓은 데로 잘 동작하겠지’ 라고 믿을 수는 없었습니다. 호되게 당한 적도 있기도 하고, 실제 사용자의 돈이 움직이는 결제 시스템에서 전혀 보이지 않는 불안요소를 가지고 가기에는 너무나 두렵고 무서웠습니다.

그래서 테스트 코드가 두려움을 해소해줬듯, 이번에도 두려움을 해소해줄 성능 테스트 환경을 만들게 되었습니다.



테스트 환경

1. 외부 인터페이스 Mock 처리

결제 시스템은 사용자의 주문 비용을 각종 결제수단(PG사, 포인트, 쿠폰) 등의 시스템과 통신하여 지불처리하는 시스템입니다. 많은 부분을 생략하고 간단하게만 표현하면, 하나의 결제는 결제수단 시스템이란 외부 인터페이스를 거치게 됩니다.



그래서 저는 결제수단 시스템을 Mock 처리해야 했습니다. 온전히 테스트 대상 시스템의 성능을 측정하기 위해서 외부 시스템은 항상 기대한 결과만을 반환하는 환경이 필요하기 때문입니다.

성능 테스트시 하지 말아야 할 Mocking 방식

1. 객체 Mocking

객체 Mocking은 테스트 코드를 작성할 때 가장 많이 사용하는 방식이라 친숙할 것 입니다. 그러나 로직에 대해 검증을 하는 테스트와 달리, 성능 테스트는 어플리케이션 동작과 자원의 사용을 모두 보아야만 하는 테스트입니다.

객체 Mocking 은 해당 객체의 행위 뒤로 들어가야 할 동작들을 무시해버리게 됩니다. 예를 들어 Spring Profile 을 사용하여 RestOpertation 을 객체를 Mock 처리하였을 때


  http connection Pool 미사용
  connection thread 미사용
  io가 발생하지 않음


등등 성능 테스트에서 중요한 관점인 Thread 사용, 리소스 사용을 전부 무시하게 됩니다.

외부 인터페이스를 Mocking 하는 것처럼 보이지만, 내부 인터페이스도 Mocking 해버리는 객체 Mocking 은 성능 테스트에서 피해야 합니다.

2. 같은 어플리케이션에 Dummy Controller 생성

이 방식도 아주 간혹 테스트 코드를 작성할 때 사용하는 방식입니다. 이 방식이 1번 방식과 다른 것은 실제로 요청을 보내고 받으며 자원을 사용한다는 것 입니다.

그러나 Dummy Controller 의 로직은 테스트 시스템의 자원과 리소스를 같이 사용해버리게 됩니다. 테스트 대상 시스템이 더 늘어나 버리는 신뢰성이 굉장히 떨어지는 의미없는 성능 테스트를 하게 됩니다. 테스트를 위한 요소는 대상 시스템에 절대로 영향을 미쳐서는 안 됩니다.

Mock Server 만들고 띄우기

그래서 우리는 테스트 대상 시스템과 완벽히 분리된 Mock Server 를 띄워야 합니다.

외부 인터페이스 Mock이 갖추어야 할 조건을 아래와 같이 정의했습니다.


  모든 요청에 기대한 결과만을 반환한다.
  모든 요청에 기대한 퍼포먼스만 낸다.
  병목이 되지 않아야 한다.


제가 만든 것은 가짜 PG사인 Gazua PAY 입니다. 요청 인터페이스는 기대한 결과와 퍼포먼스로 응답을 하도록 하는 값을 받도록 하였습니다.



(개발 당시에는 코인 시장이 엄청 핫할 때 였습니다. 승인 결과의 message는 차트의 상승을 표현했는데 아무도 눈치채지 못했습니다.)

저는 Spring 쟁이라 Spring Boot 로 아주 간단히 모든 요청에 기대한 결과, 퍼포먼스를 내는 Mock Application을 만들었습니다.

이제 Mock Application 을 배포해야 합니다. 이럴 때 정말 유용했던 것은 AWS Elastic Beanstalk 입니다. (우아한형제들은 AWS 사용을 적극 지원해주기 때문에 마음껏 쓸 수 있었습니다.)



(Elastic Beanstalk 홍보 영상 중..)

Elastic Beanstalk 은 애플리케이션을 업로드하기만 하면 용량 프로비저닝, 로드 밸런싱, Auto Scaling, 애플리케이션 상태 모니터링에 대한 배포 정보를 자동으로 처리해줍니다.

배포를 위한 스크립트를 작성하거나, 서버 설정을 해줄 필요 없이 클릭만으로 간단하게 하나의 환경을 만들 수 있고, Mock Server 에 병목이 생겨도 클릭만으로 Scale Out 하여 병목을 해소할 수 있습니다.

이로써 병목이 되지 않는, 기대한 결과와 퍼포먼스를 반환하는 Mock Server 가 완성되었습니다.

2. 사용한 도구들

nGrinder



nGrinder 는 성능 측정 목적으로 개발된 오픈소스 프로젝트로




  테스트 프로세스를 제공
  부하를 줄 수 있는 웹 인터페이스를 제공
  테스트 결과를 수집하여 통계로 제공


등의 기능을 제공합니다.

성능 측정 도구로 nGrinder 가 가장 좋았던 것은 groovy 스크립트로 테스트 시나리오를 작성할 수 있다는 것 입니다.



groovy는 gradle, jenkins file, spock 등에서 자주 다루었던 친숙한 언어였기에 내가 원하는 테스트 시나리오를 쉽고 자유롭게 작성할 수 있었습니다.

pinpoint



pinpoint 는 Java로 작성된 대규모 분산 시스템용 APM 도구입니다.

사내에서 사용하고 있는 모니터링툴이기도 하며, Transaction 의 추적을 제공하는 APM 중 하나입니다.



단일 Transaction의 Stack Trace 를 기록하여 직접적인 병목이나 문제를 빠르게 추적할 수 있고,



Transaction 이 DOT 로 그려지는 응답시간/요청시간 그래프 Transaction View 는 테스트의 상태를 실시간으로 확인하여, 가장 빠르게 이상을 감지하도록 도와줍니다.

Transaction View 는 패턴에 따른 어플리케이션 상태 예측에도 큰 몫을 하였습니다. A 구간의 병목을 보였을 때 보이는 패턴, 외부 인터페이스가 병목을 보였을 때 등등 예상 패턴을 통해 더 빠른 조치가 가능하기도 했습니다.

실제로 테스트를 하며 수많은 이상 패턴들이 탄생하기도 하였습니다.



(기영이 패턴)



(L타워 패턴)

그리고 노력 끝에 얻어진..



(백설기 패턴)

jstack

pinpoint 로 어플리케이션의 전반적인 상황을 파악할 수 있었지만, pinpoint 의 Trace 기능으로 모든 패키지와 클래스를 탐색 하는 것은 너무 과하며, Thread 간의 경합 으로 발생되는 예기치 않은 현상들을 탐지하기는 어렵습니다.

이럴 때 우리는 Thread Dump 를 분석해야 합니다.



저는 JVM 의 내장 명령 도구인 jstack 을 사용하여 쉽게 Thread Dump 를 획득할 수 있었습니다.

이제 Tread Dump 를 분석하여 병목의 원인을 파악할 수 있습니다.



(Tread Dump 를 보기 편하게 가공)

dstat

우리가 만드는 시스템은 결국 하드웨어 위에서 동작하게 되고, 시스템의 리소스 자원 사용은 Scale Up, Scale Out, Scale Down 의 중요한 지표가 됩니다.

그러므로 우리는 테스트를 통해 이 시스템은 리소스 자원을 최대한으로 사용하고 있다 라는 결론으로 도달해야 합니다.

리소스 자원을 실시간으로 모니터링하기 위해 dstat 을 사용하였습니다.

dstat 은 vmstat, iostat, ifstat, netstat 정보 등을 결합한 내용을 보여주고, 실시간성 통계를 제공해주어 성능 테스트 중 모니터링하기에 매우 적합했습니다.



dstat 하나의 명령어로 대부분의 리소스를 모니터링할 수 있었습니다.


  dstat으로 모니터링 가능한 자원 : aio, cpu, cpu24, disk, disk24, disk24old, epoch, fs, int, int24, io, ipc, load, lock,
        mem, net, page, page24, proc, raw, socket, swap, swapold, sys, tcp, time, udp, unix,
        vm


kingpoint

kingpoint 라는 도구를 아시나요? 제가 만든 것이라 당연히 모를 것 입니다. 비동기 어플리케이션의 완벽한 모니터링이 아직은 어렵기도 하며, 어플리케이션의 특성을 반영한 모니터링을 하기에도 쉽지 않았습니다.

정말 보아야 하는 것이 있는데 그것을 지원하는 도구가 없다면, 테스트를 위한 요소가 실제 어플리케이션의 성능에 절대 영향을 주지 않는다는 것을 꼭 지키는 선에서 만들어보는 것도 나쁘지 않을 것 같습니다.



비동기 대한 모니터링을 위해 요청과 완료 시점에 특정 key 값으로 통계를 전송하도록 하여, 분석한 지표를 chart.js 로 그려주는 간단한 모니터링 툴 입니다. 저는 이로인해 많은 두려움을 해소할 수 있었습니다.



테스트 진행



그래서 저는 아래와 같은 테스트들을 진행했습니다.

성능 테스트


  실제 트래픽 상황에서의 정상 동작
  기존 시스템 대비 BenchMarking


부하 테스트


  리소스 병목 탐색, 어플리케이션 버그 탐색
  이벤트 상황과 같은 순간 트래픽 최대치, 한계치를 탐색
  신규 스펙 장비에서 MYSQL 설정 최적화 탐색


스트레스 테스트


  장기간 부하 발생에 대한 한계치를 탐색, 예외 동작 상황 확인
  Graceful Shutdown 정상 동작 확인
  데이터베이스 failover 상황, 자동 복구, 예외 동작 상황 확인
  외부 요인(PG사)의 밀릴, 예외 상황 동작 확인


Mock Server 를 올리고, 위의 도구들을 사용하여 수백 번의 테스트를 해본 것 같습니다. 점차 원하는 패턴, 안정적인 수치와 지표를 찾을 수 있었습니다.


  어느 정도의 부하 를 견딜 수 있는지 알고 있다.
  한계치에서 병목 이 생기는 지점을 알고 있다.
  자원을 효율적 으로 사용한다.
  메모리 누수, 오류, 오버플로우 는 발생하지 않는다.
  최악의 상황 에서 어떤 동작을 하는지 직접 확인하였다.
  장애 조치와 복구 의 동작을 직접 확인하였다.


라는 미지의 영역을 개척할 수 있었습니다.



마무리

지금까지 결제 시스템 개비를 진행하며 경험했던 성능, 부하, 스트레스 테스트 환경 구축 및 진행에 대한 내용이습니다.

테스트를 했다고해서 이상적으로 동작하는 어플리케이션을 만든 것은 아닐 것 입니다. 많은 상황을 예방할 수 있겠지만, 언제나 전혀 예상치 못했던 상황들이 생깁니다.

그러나 적어도 확인한 것, 확보한 지표 를 기반으로 장래의 부하, 장애를 최소한의 비용과 시간으로 합리적으로 대응할 수 있을 것 입니다.

보았어야 했는데 보지 않았던 것, 더 쉽게 볼 수 있었는데 어렵게 보았던 것 등 많은 시행 착오가 있었지만, 환경을 만들고 테스트를 하면서 많은 자신감을 얻을 수 있었습니다.



그래도 배포할 땐..



긴 글 읽어주셔서 감사합니다.

참고


  성능, 부하, 스트레스 테스트
  Elastic Beanstalk 소개
  pinpoint 소개
  dstat 소개

</description>
        <pubDate>Tue, 08 May 2018 00:00:00 +0000</pubDate>
        <link>https://blog.kingbbode.com/posts/billing-performance-test-experience</link>
        <guid isPermaLink="true">https://blog.kingbbode.com/posts/billing-performance-test-experience</guid>
        
        <category>experience</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>바라던 모니터링 환경 (New Relic, PINPOINT, logentries)</title>
        <description>내가 바라던 모니터링 환경!

내가 이상적으로 바라던 그런 모니터링 환경을 만나게 되었다.



그러나 나는 이 툴들을 쓸 줄도, 어디까지 해주는지, 뭘 해주는지도 잘 모른다. 결국 이전에 하던 귀찬은 방법들을 찾게 된다.

비효율적이지만 익숙한 방법을 고수하는 것, 이게 바로 기술부채 구나!

그래서 내가 처음 접하게 된 모니터링 툴들을 정리해본다.



1. New Relic

New Relic은 SaaS 기반의 APM(Application Performance Management) 서비스를 제공하는 회사이다.

New Relic 의 다양한 서비스 중 내가 가장 잘 사용할 줄 알아야 할 서비스는 APM과 INFRASTRUCTURE다. APM은 어플리케이션에 대한 성능 모니터링을 제공한다. INFRASTRUCTURE는 서버에 대한 성능 모니터링을 제공한다.

예전에는 무료 버전이 있던 것 같지만, 홈페이지를 살펴보니 현재는 free tier(기간제)만 존재하는 것 같다. 전체적으로 New Relic이 비싸다는 글을 보았다. (사용할 수 있는 회사에 감사..)

UI



New Relic은 하나의 전용 페이지를 제공하며, 각각의 상품들은 상단 탭으로서 존재한다.

다양한 시각 자료를 통해 다양한 통계 모니터링을 보여준다.

(위 그림에서 INFRASTRUCTURE 는 빠져있다. 옛날 버전 캡쳐본인듯..?)



사용자 정의 DashBoard도 제공한다. 중점적으로 모니터링해야할 내용으로 DashBoard 를 구성하여 효율적으로 모니터링을 할 수 있도록 돕는다.

New Relic INFRASTRUCTURE

INFRASTRUCTURE는 16년 말에 오픈한 서비스로 이전에는 New Relic Server란 이름으로 APM에 내장된 서비스로 제공되었다가, 독립된 상품으로 전환되었다.

New Relic Servers is available for existing users, but not for New Relic accounts created after November 16, 2016. If a master account has access to Servers, any new sub-accounts created after November 16, 2016 will also have Servers access.





  Health
  DNS
  Process
  Traffic
  Disk
  CPU
  Memory


등의 모니터링을 지원한다.

New Relic APM



Ruby, Java, Node.js, PHP, .NET, Python, Go 기반의 어플리케이션 모니터링을 지원한다.


  응답 시간, 처리량 및 오류 비율
  종단 간 트랜잭션 추적
  어플리케이션 히스토그램
  JVM Performance Analyzer
  Service Map


등의 모니터링 기능을 지원한다.

Database 의 모니터링도 지원한다.


  호출 응답 시간 및 처리량
  호출에 소요 된 시간
  쿼리 분석
  Slow Query


등의 모니터링 기능을 지원한다.

알람

특정 환경에 대한 정책, 임계 값 설정 등으로 경고 알림을 받을 수 있다.



다양한 메신저들과의 쉬운 연동을 제공하면서, Web Hook을 제공하기 때문 다른 곳에 연동에도 크게 어려움이 없을 것이다.



빠른 알림 시스템을 제공하고, 해당 시간에 대한 통계 페이지를 제공해주어, 빠르게 대처할 수 있게 도와준다.

이미지, 자료 등 출처 : https://docs.newrelic.com



2. PINPOINT

PINPOINT는Java로 작성된 대규모 분산 시스템 용 오픈 소스 APM이다.



Naver에서 만든 자랑스런 국산 오픈소스로 작년 말 5000 스타를 돌파했고, 현재도 계속 상승 중인 네이버의 대표적인 오픈 소스 프로젝트이다.

UI



서비스의 흐름과 실시간 상태를 보기 굉장히 좋은 UI를 제공하고 있다.

APM

제공되는 대표적인 기능들은 아래와 같다.


  ServerMap
  Realtime Active Thread Chart
  Request/Response Scatter Chart
  CallStack
  Inspector


알람



핀포인트 역시 특정 임계치를 설정하여 알람을 받는 방식이 가능하다.

그러나 실제 알람을 받기 위해서는 AlarmMessageSender 인터페이스의 구현체를 작성하여야 한다.

public interface AlarmMessageSender {
    void sendSms(AlarmChecker checker, int sequenceCount);
    void sendEmail(AlarmChecker checker, int sequenceCount);
}


Github Source 에서 인터페이스를 보면, 현재 공식적으로는 sms와 email만을 지원하는 듯 하다. (위 안에 억지로 구현은 할 수 있겠지만..)

이미지, 자료 등 출처 : https://naver.github.io/pinpoint



3. logentries

logentries는 실시간 로그 관리, 분석 서비스이다. Saas 기반의 서비스로 Agent로부터 수집되는 로그에 대한 검색, 시각화, 분석을 제공한다.



즉 이 서비스를 이용하면, 더 이상 모든 서버에 들어가 로그를 확인해야하는 노가다를 안할 수 있다.


  실시간으로 수집되는 로그를 볼 수 있다.
  특정 패턴에 대한 시각화를 할 수 있다.
  수집된 로그에서 검색을 할 수 있다.


등의 아주 편리한 사용성을 제공한다. 이 편리한 사용성을 잘 사용하기 위해서는 효율적인 로그의 검색을 위해서 각 서비스에 맞게 로그의 구조에 대한 정책이 선행되는 것이 좋다고 한다. https://docs.logentries.com/docs/best-practices-logs

알람



특정 패턴에 대한 Tag를 만들 수 있는데, 이를 이용한 경고 알림이 가능하다.



logentries 역시 다양한 메신저들과의 쉬운 연동을 제공하면서, Web Hook을 제공하기 때문 다른 곳에 연동에도 크게 어려움이 없을 것이다.

이미지, 자료 등 출처 : https://docs.logentries.com



마무리

로그를 찾기 위해 모든 서버를 들어가지 않는다. 서버 모니터링을 위해 16분할의 터미널을 띄워놓지 않는다. 서버의 상황에 따라 그때그때 여러가지 시도를 해볼 수 있다. 등등 위 시스템들이 제공해주는 여러 편리함들이 있다. (상황에 따라 필요한 경우도 있지만)

아직도 무슨 상황이 되면 터미널 키는 것을 먼저 생각하는 것이.. 적응이 덜 되었지만, 이제는 이것들이 무엇을 해주고 있는지, 날 어떻게 더 편하게 해주는지, 내가 뭘 이것들을 통해 봐야하는지를 대략 알 것 같다.

이러한 시스템들의 보호는 나의 시간을 절약시켜주고, 내가 더 개발에 집중할 수 있게 해주고 있다.


</description>
        <pubDate>Sun, 11 Feb 2018 00:00:00 +0000</pubDate>
        <link>https://blog.kingbbode.com/posts/monitoring-tool</link>
        <guid isPermaLink="true">https://blog.kingbbode.com/posts/monitoring-tool</guid>
        
        <category>monitoring,</category>
        
        <category>devops</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>2년차 웹개발자</title>
        <description>2년차 웹개발자

1년차 웹개발자라는 회고를 쓴지 1년이 조금 더 지나, 이번에는 나의 2년차를 돌아보려고 합니다.

1년 동안 나를 성장시킨 것

2년차에 나를 성장시켰다고 생각하는 3가지 키워드는 도전, 자극, 기회(행운)이다.

도전

2년차를 시작하면서 몇가지 목표를 정했다. 다 이룰 수 있을까 했는데, 운이 좋게도 모두 이루고 말았다.

Spring Camp

작년 한 해 동안 수많은 세미나를 돌아다녔었다. 그리고 2년차가 되서는, 나도 어느 조그마한 세미나에서라도 발표를 해보자고 결심했다. 그런데 정말 운이 좋게도(?) 너무 큰 세미나에서 발표할 기회를 가지게 되었다. 바로 Spring Camp 2017 이다.

연사 모임에서는 정말 말도 안되게 어마어마하신 분들이 계셨다. 첫 모임이 치킨 집이였는데, 고수 개발자님들의 개발에 대한 고수준의 대화에 정신을 못차리고 멍때렸던 기억이 난다.

인생 첫 세미나 발표를, 이런 큰 세미나에서, 이런 엄청난 고수분들과 함께 한다는 것에 대한 부담은 말로 할 수 없었다. 그래도 내가 전하고 싶었던 메시지가 분명했기 때문에 발표에 대한 자신감은 있었던 것 같다.



주제는 Spring Boot 를 대하는 자세 였다. Spring Boot에 대한 오해를 풀고, 주의해야 할 점을 말하고 싶었다. 최근에도 Spring Boot를 선호하지 않는 이유는 Spring Boot에서 해주고 있는 일이 너무 많기때문이다라는 말을 들었다. 그렇기 때문에 Spring Boot에서 무엇을 해주고 있는지 알아야하고, 어떻게 볼 수 있는지 등이 내용에 들어갔다. 발표하길 잘 했다라고 간혹 생각한다.

Spring Boot의 기본 설정을 버리면서 Spring Boot에서 해주고 있는 것보다 못한(스펙에 대응하지 못한) 설정을 사용하는 코드를 본 적이 있다. 이런 코드를 보면서 개인이 아무리 노력한다고 하더라도 스프링 프레임워크를 개발하는 사람들과 수많은 컨트리뷰터들이 함께 하는 프로젝트보다 수많은 스펙에 대한 대응을 잘 할 수 있을까라고 생각했다. (스펙에 대한 변화로 인해 생기는 장애 포인트, 취약점 등)

이 발표는 내가 사용하는 프레임워크에 대해 깊게 들여다보고, 생각하고, 조금은 더 이해할 수 있었던 큰 계기가 되었다.

OpenSource Contribute

사내 메신저이자, 모회사의 제품이기도 한 TeamUp이라는 업무용 메신저가 있다. Open source APM Project인 Scouter로부터 알람을 받고 싶었으나, 당시 팀에서 Slack이나 다른 메신저를 쓰지않았고 메신저 사용을 제안하기도 힘든 상황이였다. 그래서 만들었다. TeamUp 챗봇을 만들어서 운영 중인 경험도 있었고, Slack Plugin이 이미 존재하여서, folk 기반으로 어렵지 않게 작성하여 만들 수 있었다.

이 때까지는 오픈소스 기여에 대한 마음은 없었다. 그러던 중 어느 세미나에서 Scouter 커미터이신 이건희님의 발표를 듣고 Scouter가 국산이란 것을 처음 알게 되었다. 혹시나 하는 마음으로 이 프로젝트가 scouter plugin에 올라갈 수 있는지 요청을 드렸는데, 흔쾌히(?) 수락을 해주셨다.(정말 감사합니다!)



이게 내 첫 오픈소스 기여였다. Scouter 덕분에 OpenSource에 대한 벽이 많이 없어질 수 있었다. 그래서 2017년에도 많이 사용되는 오픈소스에 기여를 해보자고 마음을 먹었다. 일부러 찾으려고 애쓰지는 않았다. 내가 정말 사용하면서 눈에 보이는 것을 하고 싶었다. 사용을 하면서 불편하거나 이상한 것이 생기면 항상 의심을 했다.

그러나 기여에 실패도 많이 했다.



내가 하려는 기여가 해당 오픈소스 프로젝트가 추구하는 방향과 맞아야하고, 전체적인 통일성 등과도 맞아야 하는 등 더 큰 모습을 볼 수 있어야 한다는 것도 알게 되었다.

그렇게 노력하여 결국 성공한 기여는 Spring Batch 이다!



동작에 대한 이상을 찾았다. 코드 한두줄 내가 좀 수정하면 그냥 쓸 수 있는 정도의 동작 이상이였지만, 이 동작이 Spring Framework에서 동작해야 하는 일반적인 동작이 아니며, 의도치 않았을 거라고 판단하여 바로 PR을 날렸고 결국 성공했다. 정말 사소하고 작은 내용이였지만, 내가 쓰고 있는 프레임워크에 기여했다는 것에 큰 희열과 감동을 느꼈다.

패스트캠퍼스 자바 웹 프로그래밍(by 자바지기)

박재성 교수님의 자바 웹 프로그래밍:Next Step(양파까기)의 책 내용으로 진행되었던 자바 웹 프로그래밍 강의이다. 이 강의를 듣고 난 후 내 개발에는 엄청나게 큰 변화가 있었다.

이것이 객체지향인가! 이것이 OOP인가!



그동안 내가 하고 있던 개발에 대한 모든 것이 이 강의를 전 후로 바뀌었던 것 같다. 나 역시 강추를 받아 수강하였고, 주변 사람들에게도 꼭 강추하고 싶다.

Study

2017년에 2개의 스터디가 생겼다.

첫번째는 패스트캠퍼스 자바 웹 프로그래밍을 같이 수료했던 인연으로 생기게 된 양파지기 스터디이다.



스프링, 챗봇, 블록체인 등등 여러가지 분야에 대해서 스터디를 하였다. 기술적인 스터디에도 목적이 있었지만, 다양한 직종의 사람들과 같이 기술에 대한 여러 이야기를 하면서 많은 것을 배웠던 좋은 스터디였다.

두번째는 내가 쓰는 언어에 대한 기본을 다시 다지고자 시작했던 강서구 자바 스터디이다.



자바부터 스프링까지를 목적으로 개발 입문자나, 나와 같이 자바를 다시 돌아보고자 하는 사람들을 대상으로 모집하였다. 어찌어찌 하다보니, 나보다 경험이 없는 사람들이 모였고, 어찌어찌 하다보니 스터디라기보단 내 무료 강의처럼 된 스터디였다. 이런 상황이다보니, 강제로 정말 초심자 마음으로 돌아가(이해시키기 위해) 자바를 다시 한번 볼 수 있었던.. 그리고 지금도 진행 중인 스터디이다.

비록 내 토요일이 사라졌지만, 정말 재미있고 좋은 경험들인 것 같다.

Blog

블로그를 꾸준히 관리하여 광고로 치킨 값이라도 벌어보자고 생각했었다. 이것도 이루어졌다.



(치킨)

내가 블로그를 쓰는 기준은 나의 생각 정리, 내가 겪은 남들이 겪을 만한 일을 정리, 내가 해본 남들도 간접 경험해보면 좋을 만한 일을 정리, 인터넷에 자료가 별로 없는 내가 해본 것을 정리이다. 전체적으로 내가 직접 했다는 것이 중요한 것 같다. 남이 쓴 것을 옮기는 것, 그대로 따라해놓고 내 블로그에도 카피하는 것은 의미가 없다.

블로그를 쓰면서 가장 제일 중요했던 것은 잘못된 정보를 제공하지 않는 것이다. 나 혼자 쓰는 글 일지라도 혹시라도 누가 볼 수도 있다고 생각한다. 내가 삽질하고 있는 중 잘못된 정보를 제공해놓은 링크를 찾는다면 굉장히 짜증이 날 것이라고 생각한다. 그렇기 때문에 글을 정리하는 것은 매우 어렵다. 그렇지만 그렇기때문에 주변 사람들에게 글을 쓸 것을 강추하고 있다.

내가 확실하게 알고 있다고 생각하는 것도, 글로 옮기다보면 다시 찾아보게 되는게 엄청나게 많았고, 그런 과정 중에 배운 것들이 굉장히 많았다. 학습의 깊이가 깊어질 수 밖에 없을 것이다.





(방문자 수가 지속적으로 늘고 있어 많이 뿌듯함을 느끼고 있다. 감사합니다!!)



자극

나는 자극을 즐기며, 자극이 나를 더 성장시켜준다고 믿고 있다.

지난 회고 때 나는 커뮤니티, 세미나, 동료 개발자들을 통해 많은 자극을 받고 있다고 말했었다. 지난 1년 간도 그랬지만, 그 중 가장 큰 자극을 꼽으면 동료 개발자의 이직이였다.

사수의 이직

2년차를 시작하자마자 나의 개발에 대한 정신적 지주이자, 멘토라고 해도 과언이 아닌 사수가 이직 을 하였다.



내 사수는 사람이 저렇게 성실할 수 있나라고 생각할만큼 성실한 사람이였고, 타인을 배려하는 태도, 학습에 대한 열정 등 여러가지로 내 기준 천상 개발자였다. 사수의 이런 모습은 나를 감동시켰고, 사수가 퇴사하고 나서는 나도 이런 사수가 되고 싶다고 많이 생각하였다.

사수는 최고의 모습으로 퇴사를 하였다. 나는 그 모습을 쫓아 더 좋은 사수, 개발자가 되기 위해 노력하였다!



(농담..)

동기의 이직

최종 면접을 같이 보고 같이 입사하여, 개발에 대한 모든 것을 나누던, 개발인생에서 가장 좋은 친구가 된 동기 가 이직을 하였다.



둘이서 아웅다웅하면서 공부하는 모습이 보기 좋다.라고 많이 들었었다. 정말 많은 것을 같이 나누고 공유했던 좋은 친구가 이직하고 꽤 씁쓸함을 느꼈던 것 같다.

그러나 개발에 대한 여러가지 이야기를 이직 이후에도 자주 나누며 우물 안에서만 있었던 시야가 동기의 이직으로 조금은 더 넓어질 수 있는 계기가 되기도 했다. 회사에만 같이 없을 뿐 지금도 같이 성장하고 있다고 생각한다.

동기는 가자마자 프로필을 바꾸어버렸다.. 노란 배경으로



아무튼 동기의 이직으로 인해, 굉장히 큰 자극을 받았다. 이것 또한 나에게 채찍질이 될 수 있었던 것 같다.







(‘ZUM’ 에서 만나 정말 좋은 친구가 된 전, 현 동료들)



기회(행운)

내가 기회를 찾아다니기도 했지만, ZumInternet은 나에게 정말 많은 기회와 행운을 주었던 것 같다.

큰 역할들을 맡게 되었다

사수가 이직하고 힘들었지만, 돌이켜보면 사수의 이직이 나에게 있어서 기회가 되었던 것 같다. 당시 사수가 가지고 있던 많은 롤들이 나에게로 넘어왔고, 쉽게 경험할 수 없는 환경에 대해서 다양한 경험들을 쌓을 수 있었다.

나에게 많은 롤들이 생기고 큰 업무들을 맡게 되면서 어깨가 무거워졌었다. 이때 당시 본부장님, 팀장님은 나를 믿고 많은 배려 를 해주셨다. 내 의견을 적극 반영해주셨고, 시간적인 배려도 아끼지 않으셨다. 힘들던 시기에 나를 지탱해주던 너무 감사한 분들이다.

이런 적극적인 지원 속에서 좋은 방향으로 나가기 위해 항상 ‘이렇게 하는게 좋다더라’, ‘다른데서 이렇게 하고 있더라’ 보다는 ‘이렇게 하는게 어떠한 이유때문에 좋다, 아니다’, ‘다른데서 이렇게 하고 있는데, 이러한 환경에서 이러한 방향으로 진행했기 때문에 좋았다’ 를 중요시하며 개발을 하였다. 불안함 속에서 내가 하고 있는 것에 대한 다양한 상황을 예측하기 위한 습관이 자리잡은 것 같다.

가끔 어디서 이렇게 했다더라, 이게 좋다더라를 주장하는 개발자에게 그거 말고 이렇게 하자라고 했을 때 이유없이 거부하거나 그냥 선임이 그렇게 하자니 동조하는 상황을 보곤 한다.

왜 를 생각하지 않는다면, 이 경험이 나중에 도움이 될까라는 생각을 했다. 그래서 나 스스로를 납득시키고 이해하려고 노력하였고, 이러한 자세가 생기면서 더 깊은 학습과 경험을 할 수 있었던 것 같다.

잘하는 후임 개발자들이 생겼다

팀 규모가 점점 커져, 지금은 내가 처음 입사했을 때에 비해 5배 이상이 커진 개발팀 규모가 되었다.

그리고 나에게도 후배 동료들이 생겼다. 즉 내가 누군가에게 무언가를 알려줄 수 있어야 되는 사람이어야 했다. 이 분들의 성장 속도는 무서웠다. 나도 어려워하는 그런 질문들을 받을 때면 굉장히 곤란했다. 그래서 더 열심히 할 수 밖에 없었는지도 모른다..; 그래도 이 때 평소 BLOG를 작성하는 것과, 왜를 생각하며 학습했던 것이 많은 도움이 되었다. 내가 아는 것과, 내가 아는 것을 남에게 알려준다는 것은 굉장히 큰 차이가 있고, 남을 알려주기 위해서는 깊은 학습이 필요했기 때문이다.

이분들을 만난 것이 행운이라고 생각하는 이유는, 이분들이 모두 다 잘하기 때문이다. 코딩 실력을 제외하고서도, 모두들 항상 노력하고 자신이 추구하는 개발의 방향이 있는 내가 생각하는 좋은 개발자들이였다. 그래서 나 또한 많이 배웠고, 내가 알고 있는 것을 공유해주려고 많이 노력하였다. 그렇게 함께 이야기를 할 수 있는 분들이였다는게 정말 큰 행운이였다고 생각한다.

BeyondJ2EE 를 만남

2017년 ZumInternet에 합류하신 팀장님은 내 2년차를 돌아보며 빼놓을 수 없는 분이다.



내가 목말라 있었던 경험을 토대로한 Real World를 정말 많이 알려주셨다. 실무에는 다양한 사례들이 있고, 다양한 상황이 있다. 팀장님은 아마 내가 가지고 있던 고정관념 을 가장 많이 깨주신 분일 듯 하다.

거기에 우리가 목말라 있던 것들에 대해 직접 지인들을 초빙하여 회사 세미나까지 열어주셨고, 숙제와 같이 우리에게 부족한 것들을 부담없이 던져주시며 스스로 성장할 수 있게 기회를 많이 주셨다. 지금까지 정말 많이 배울 수 있었다. (빙산의 일각이라고 하셨다)



발견한 안좋은 점들

1년동안 나를 성장시킨게 있었다면, 발견한 내 안좋은 점들이 있다! 꼭 고치고자 작성해보았다.

이 사람 답장이 없어..!

서서히 심해진 것 같은데.. 집중을 하기 시작하면 다른 것이 보이지가 않을 때가 많아졌다. 최근에는 누군가 말을 걸었을 때 무의식적으로 “잠시만요”하고 기억을 하지 못한 사태까지 생겼었다. 정말 꼭 고쳐야할 안좋은 버릇이다..!

건강을 챙기자!

최근에 걸렸던 대상포진도 그렇고, 건강관리를 잘 안했던 것 같다.


  밥을 잘 챙겨먹자! 개발하는 것을 끊기 싫어서 점심을 굶은 적이 많다. 속 버리겠다..
  운동을 하자..!


고정관념을 버리자!

개발에 정답은 없고, 많은 방법들이 있다. 내가 알고 있는 방법이 좋다는 고정관념이 있는 것 같다. 지나치게 왜를 생각했을 수도 있다. 때론 안정성보다 빠른 대응을 택해야하는 경우도 있을 것이고, 성능보다 가벼운 것을 택해야하는 경우도 있을 것이다.

열린 생각으로, 앞으로 더 경험을 쌓으면서 주장이 아닌 토론을 하며 좋은 사례를 만들어가는 개발자가 되고싶다!



2년차를 마치며, 이직

최고가 되기 위해 떠난다! 입사 2주년이 되면서 이직을 생각하게 되었고, 12월 21일부로 줌인터넷을 퇴사하고 새로운 곳으로 입사를 하게 되었다.

준비

회사를 다니면서 했던 이직을 위한 준비이다.

1. 커밋과 기록을 꾸준히 했다.(이직을 위한 것은 아니였지만, 도움이 되었다고 생각)


  커밋은 내가 꾸준하게 개발을 했다는 것을 보여줄 수 있는 가장 쉬운 방법
  기록은 내가 얼마나 이해했고 알고 있고 관심이 있는지 보여줄 수 있는 가장 쉬운 방법


2. 이력서를 만들었고, 첨삭받았다.


  진작 꾸준히 관리할 것을 후회했다! 경력 관리를 꾸준히 하자!


3. 나에 대해서 명확히 했다.


  이직을 왜 하고싶은지
  무엇을 추구하는지
  내가 어느정도 수준인지


부족했던 것


  
    과정에 있는 어떠한 툴이라도 사용법에 대해서 그냥 넘기지 말자! 알고리즘 사이트 툴이 다 거기서 거기지 하는 마음으로 했다가 절반의 시간이 지나서야 잘못된 것을 알아차리고 망한 곳이 있었다.
  
  
    용어에 대한 정리도 꼭 하자. 알고 있는 것이지만, 용어를 듣고 모르는 것 처럼 넘겨질 때도 있었다.
  


이직

그렇게 준비하여, 내가 정말 가고싶던 곳에만 이력서를 넣었고, 나에게 선택권이 돌아올 수 있었으며, 결국 나의 3년차를 우아한형제들에서 시작하게 되었다. 새로운 시작이 겁이나지만, 꼭 인정받을 수 있도록 열심히 할 것이다!



마무리

보내고, 만나고, 나도 가고, 정말 많은 도전이 있었던 일년이였다.

앞을 위해 뒤를 되돌아본다는 것이 참 재미있고, 좋은 것 같다. 정말로 많은 생각이 정리가 되고 있다. 몇 가지 고쳐야할 것들이 보인 것 말고는 썩 나쁘지 않은 1년이였던 것 같다. 이제 나의 3년차는 지금까지와는 전혀 다른 새로운 환경에서 시작하게 된다.

아마 가장 큰 목표가 우아한형제들에서 살아남기가 될 것 같다. 반드시 살아남아서 인정받고 말테다! 지금까지 그랬던 것 처럼, 노력해보겠다.



</description>
        <pubDate>Fri, 22 Dec 2017 00:00:00 +0000</pubDate>
        <link>https://blog.kingbbode.com/posts/who-am-i-2</link>
        <guid isPermaLink="true">https://blog.kingbbode.com/posts/who-am-i-2</guid>
        
        <category>think</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>마스터즈 오픈 세미나</title>
        <description>재미로 시작한 프로그래밍 공부 열달, 그리고 삽질기

왜 개발 공부를 시작했는가?

나의 성향 을 분석해보았다.


  호기심 많음
  규칙성을 찾는 눈이 좋음.
  문제를 일반화하는 것을 좋아함.
  컴퓨터로 하는, 트랜지스터 박힌 모든 것을 다루는 일이 즐거움.
  영어 잘함


그래서 그동안 잘해왔던 것


  전화번호 외우기, 고속도로 번호 외우기
  지리 익히기, 내비게이션 안 보고 운전하기
  중-고 6년간 교내 전자장비 전담 A/S


개발 공부에 도움이 되는 성향들인가? 아무튼 개발이 잘 맞는 것 같다.

결정적인 개기 는!

외대학식알리미 개발


  AWS Lambda 사용(이름이 멋있어서 사용)


아무 것도 모르는 상태에서 개발.. 그래서 코드는 개판이였지만, 정말 열심히 함.

학교 알림에 올라왔고 많이 유명해졌다. ( 엄청나게 뿌듯..)


  커뮤니티의 따뜻한 환영
  사용자들의 (긍정적) 피드백


너무나도 즐거운 경험이였고 재밌었기 때문에, 개발 공부 시작

시작


  외로움
  나의 수준에 맞는 도전이 뭔지?


이런 시기에 코드스쿼드를 알게 됨


  혼자 공부하는 시간은 유지
  마스터들의 고퀄 특강
  흥미를 돋우는 멘토의 연습과제


내가 부족했던 것들을 의식적으로 연습

지난 몇달 간 얻은 것


  무엇을 공부해야 하는가?
  혼자 공부하며 가졌던 궁금증 해결
  어떤 길을 걸어가야 개발자로 성장할 수 있는지
  좋은 사람들 : 개발자의 진로를 가는 친구들, 든든한 멘토.


경험을 바탕으로 말하고 싶은 것

live curious


  일정 수준의 호기심을 계속 유지하기
  가벼운 탐구에서 진지한 연구로
  학습이 아닌 호기심의 해결 (고시공부 하듯 개발공부 하지 말자)


자존감 유지하기

슬기로운 생활
</description>
        <pubDate>Tue, 12 Dec 2017 00:00:00 +0000</pubDate>
        <link>https://blog.kingbbode.com/posts/code-squed</link>
        <guid isPermaLink="true">https://blog.kingbbode.com/posts/code-squed</guid>
        
        <category>think</category>
        
        
        <category>seminar</category>
        
      </item>
    
      <item>
        <title>젠킨스 파이프라인 사용하여 자동 배포환경 만들어보기!</title>
        <description>지난 글(젠킨스 사용하여 자동 배포환경 만들어보기) 에서 Jenkins Build Pipeline 으로 자동 배포 시스템을 구축하는 것에 대해 공유를 했었습니다.



댓글을 통해 Jenkins Pipeline 이라는게 있다는 것을 처음 알고 되고..!!

그 때서야, 젠킨스 2.0 의 가장 큰 변화가 Jenkins Pipeline 이라는 것을 알게 되었습니다. 이 때부터 마음의 숙제로 가지고 있었지만, 최근 블로그 통계로 젠킨스 블로깅 글의 방문이 높다는 것을 알고 급하게(groovy를 제대로 숙지하지 못한 채..ㅜㅜ) 글을 작성하게 되었습니다.

 (최근 이 짤을 굉장히 많이 쓰게 됩니다..)

Jenkins Pipeline 이란 스크립트를 통해 파이프라인의 흐름을 정의하는 기능입니다. 이 스크립트는 groovy로 작성되며, Pipeline DSL을 통해 전달 파이프라인을 작성할 수 있습니다.

Jenkins Pipeline에 대한 자세한 설명은 생략!

그리하여, 저 또한 지난 Build Pipeline으로 작성했던 시스템을, Pipeline Script 기반으로 모두 전환하였습니다.

구축한 내용과 결과를 공유합니다.

구축하고자 하는 환경

구축하고자 하는 환경은 지난 Build Pipeline 으로 구축했을 당시의 조건을 그대로 구축하는 것 입니다.

Git 연동이나, Gradle, Maven 빌드 등 기본적인 조건을 제외하고 가장 원했던 조건은 아래와 같습니다.


  공통 내용을 모듈화하여 공용으로 사용할 수 있는 구조.
  각 단계에 대한 수동 실행이 가능한 구조.


구축

Jenkins File

젠킨스는 Pipeline Script를 Admin Web에서 직접 작성하여 저장하는 방법과, Git을 통해 JenkinsFile 을 읽는 방법을 제공합니다.

만들고자 하는 스크립트는, 배포 Flow가 지나치게 다르지 않은 프로젝트에 한하여, 모두 동일한 스크립트를 사용할 수 있도록 구성하여 파라미터 기반으로 실행될 수 있는 스크립트 입니다.

그렇기 때문에 저장소에 대한 수정만으로 모든 프로젝트에 적용할 수 있는 Git을 통해 JenkinsFile 을 읽는 방법을 사용합니다.

groovy 사용이 미숙하여, 코드가 더러운 점은 양해 부탁드립니다. groovy 사용성을 숙지하여 추후 리펙토링할 예정입니다.

Stage

젠킨스 Pipeline Script는 실행에 대한 단위인 node 와 파이프라인을 구성하는 stage가 있습니다. node 와 stage 간에는 먼저 선언되야 하는 것은 없이 작성할 수 있습니다.

node('', {
  stage('example1', {
    echo &quot;&quot;
  })
})

stage('example2', {
  node('', {
    echo &quot;&quot;
  })
})


Pipeline Script는 병렬 실행을 지원하기 때문에 실행 단위를 분리해야할 경우 node를 사용하여 실행 단위를 분리할 수 있고, Pipeline의 단계를 stage로 구성하게 됩니다.

자동 배포를 위해 만드려고 하는 Stage는 아래와 같습니다.


  Flow Check - Parameter Check - Git CheckOut - Test - Build - Deploy - Switch


파라미터 정의

Flow

각 잡 실행 Pipeline에서 진행할 Stage 를 정의하는 파라미터들입니다.

USE_TEST : Test 단계 사용 유무

USE_BUILD : Build 단계 사용 유무

USE_DEPLOY : Deploy 단계 사용 유무

USE_SWITCH : Switch 단계 사용 유무

Module

각 프로젝트 Pipeline Job에서 넘겨주어야 할 모듈 정보입니다.

GRADLE_VERSION : Gradle Version

JAVA_VERSION : Java Version

NODE_VERSION : Node Version (Optional)

SLACK_TOKEN : Slack Token (Optional)

Git

소스 Check Out 을 위한 정보입니다.

GIT_URL : Git Repository Url

BRANCH_SELECTOR : 대상 Branch

Deploy

그리고 각 배포 환경에 따라 정의되어야 하는 파라미터들이 있습니다. 아래 파라미터는 제가 배포해야할 환경에 필요한 파라미터로 각 배포 환경에 맞게 구성하시면 됩니다.

CONFIG_NAME, REMOTE_PATH, TARGET_USER, TARGET_SERVER

변수 정의

Flow

def useTest = true
def useBuild = true
def useDeploy = true
def useSwitch = true


각 단계에 대한 수동 실행이 가능한 구조 를 위해 사용되는 변수들입니다. 이 변수들은 Stage 내부에서 확인될 것 입니다.(Stage를 분기처리하면 전체 Flow가 망기지기 때문에) 기본 값은 모두 실행되는 것이며, 이후 아래에서 설명할 Pipeline Job을 만드는 과정에서 이 값들이 어떻게 쓰일지 다시 한번 설명하도록 하겠습니다.

Module

def useNode = true
def useSlack = true


해당 모듈을 사용할지 결정하는 변수입니다. 모든 프로젝트가 Gradle Build라는 가정하에 적성하여, useGradle, useMaven 는 작성하지 않았습니다. 필요하다면 작성하셔서 사용하면 좋을 것 같습니다.

1. Flow Check

이 과정은 해당 빌드가 어떤 스테이지를 실행하는지 확인할 수 있도록 작성한 Stage 입니다.

stage(&quot;Flow Check&quot;, {
    try {
        println &quot;  TEST FLOW = $USE_TEST&quot;
        useTest = &quot;$USE_TEST&quot; == &quot;true&quot;
    }
    catch (MissingPropertyException e) {
        println &quot;  TEST FLOW = true&quot;
    }

    try {
        println &quot;  BUILD FLOW = $USE_BUILD&quot;
        useBuild = &quot;$USE_BUILD&quot; == &quot;true&quot;
    }
    catch (MissingPropertyException e) {
        println &quot;  BUILD FLOW = true&quot;
    }

    try {
        println &quot;  DEPLOY FLOW = $USE_DEPLOY&quot;
        useBuild = &quot;$USE_DEPLOY&quot; == &quot;true&quot;
    }
    catch (MissingPropertyException e) {
        println &quot;  BUILD DEPLOY = true&quot;
    }

    try {
        println &quot;  SWITCH FLOW = $USE_SWITCH&quot;
        useBuild = &quot;$USE_SWITCH&quot; == &quot;true&quot;
    }
    catch (MissingPropertyException e) {
        println &quot;  SWITCH FLOW = true&quot;
    }
})


$로 시작하는 이름들은 파라미터로 넘겨받을 환경 변수들입니다. 해당 환경변수가 설정되지 않았을 때 MissingPropertyException이 발생하지만, 이 값들은 없으면 Default 값으로 동작하도록 예외처리를 하였습니다.

2. ParameterCheck

stage(&quot;Parameter Check&quot;, {
    println &quot; BUILD_USER = &quot; + BUILD_USER
    println &quot; CONFIG_NAME = $CONFIG_NAME&quot;
    println &quot;  REMOTE_PATH = $REMOTE_PATH&quot;
    println &quot;  TARGET_USER = $TARGET_USER&quot;
    println &quot;  TARGET_SERVER = $TARGET_SERVER&quot;
    println &quot;  GIT_URL = $GIT_URL&quot;
    println &quot;  BRANCH_SELECTOR = $BRANCH_SELECTOR&quot;
    println &quot;  GRADLE_VERSION = $GRADLE_VERSION&quot;
    println &quot;  JAVA_VERSION = $JAVA_VERSION&quot;

    env.JAVA_HOME=&quot;${tool name : JAVA_VERSION}&quot;
    env.PATH=&quot;${env.JAVA_HOME}/bin:${env.PATH}&quot;

    try {
        println &quot;  SLACK_TOKEN = $SLACK_TOKEN&quot;
    }
    catch (MissingPropertyException e) {
        useSlack = false
    }
    try {
        println &quot;  NODE_VERSION = $NODE_VERSION&quot;
    }
    catch (MissingPropertyException e) {
        useNode = false
    }
})


파라미터를 검증하는 Stage 입니다. 환경변수가 없을 때는 예외를 발생시키므로, 필수 사용 파라미터에 대해서는 예외처리를 하지 않습니다.

3. Git CheckOut

stage(&quot;Git CheckOut&quot;, {
    if (useTest || useBuild) {
        println &quot;Git CheckOut Started&quot;
        checkout(
                [
                        $class                           : 'GitSCM',
                        branches                         : [[name: '${BRANCH_SELECTOR}']],
                        doGenerateSubmoduleConfigurations: false,
                        extensions                       : [],
                        submoduleCfg                     : [],
                        userRemoteConfigs                : [[url: '${GIT_URL']]
                ]
        )
        println &quot;Git CheckOut End&quot;
    } else {
        println &quot;Git CheckOut Skip&quot;
    }
})


넘겨받은 GitUrl과 Branch를 사용하여 Git Check Out 을 실행하는 Stage 입니다. Test나 Build 중 하나라도 Flow에 포함되어 있다면 이 단계가 실행됩니다.

4. Test

stage('Test') {
    if (useTest) {
        println &quot;Test Started&quot;
        try {
            sh &quot;${tool name: GRADLE_VERSION, type: 'hudson.plugins.gradle.GradleInstallation'}/bin/gradle test -Dorg.gradle.daemon=true&quot;
        } finally {
            junit allowEmptyResults: true, keepLongStdio: true, testResults: 'build/test-results/*.xml'
        }
        println &quot;Test End&quot;
    } else {
        println &quot;Test Skip&quot;
    }
}


넘겨받은 Gradle Version을 사용하여, test Task 를 실행시킵니다. 테스트가 완료된 후에는 테스트 결과를 수집합니다. testResults는 각 프로젝트 환경에 맞는 Path를 작성합니다.

5. Deploy, Switch(Manual Flow)

두 Stage는 독립된 Stage 이지만 자세한 내용을 공개할 수 없으므로, 간단히 작성합니다.

stage(&quot;Deploy&quot;, {
    if(useDeploy) {
        println &quot;Deploy Started&quot;
        sh &quot;****&quot;
        println &quot;Deploy End&quot;
    } else {
        println &quot;Deploy Skip&quot;
    }
})

stage(&quot;Switch&quot;, {
    if(useSwitch) {
        try {
            input(&quot;스위칭 하시겠습니까?&quot;)
            println &quot;Switch Started&quot;
            sh &quot;****&quot;
            println &quot;Switch End&quot;
        } catch (Exception e) {
            println &quot;Switch Skip&quot;
        }
    } else {
        println &quot;Switch Skip&quot;
    }
})


Manual Flow를 위해 input을 사용합니다. flow는 input을 만나게되면, 사용자가 proceed 혹은 abort 를 선택하기 전까지는 대기 상태로 들어갑니다.

abort를 선택하면 예외가 발생하지만, 그렇다고 해당 Stage가 실패한 것은 아니라고 생각하여 예외처리를 작성하였습니다.

기타. Node 사용하기

gradle 빌드 과정에 node 를 사용해야 할 task가 구성되어 있을 때 Nvm Wrapper Plugin을 사용합니다.

if (useNode) {
    nvm('version' : &quot;${NODE_VERSION}&quot;) {
        stage('Test') {
            if (useTest) {
                println &quot;Test Started&quot;
                ~~
                println &quot;Test End&quot;
            } else {
                println &quot;Test Skip&quot;
            }
        }
        stage(&quot;Build&quot;, {
            if(useBuild) {
                println &quot;Build Started&quot;
                ~~
                println &quot;Build End&quot;
            } else {
                println &quot;Build Skip&quot;
            }
        })
    }
} else {
    stage('Test') {
        if (useTest) {
            println &quot;Test Started&quot;
            ~~
            println &quot;Test End&quot;
        } else {
            println &quot;Test Skip&quot;
        }
    }
    stage(&quot;Build&quot;, {
        if(useBuild) {
            println &quot;Build Started&quot;
            ~~
            println &quot;Build End&quot;
        } else {
            println &quot;Build Skip&quot;
        }
    })
}


nvm이 {} scope 안에서만 사용 가능하여 위와 같이 else문에 똑같은 중복 코드가 발생하는 로직을 일단 사용하였습니다…


  groovy 학습 후 리펙토링을..ㅜㅜ




Pipeline Template Job 만들기

위의 스크립트는 많은 파라미터를 필요로 합니다. 프로젝트를 추가해야할 때마다 매번 파라미터를 추가하는 노가다를 피하기 위하여, Template로 사용할 수 있는 Pipeline Template Job 을 만드려고 합니다.

생성



new Job에서 Pipeline을 선택합니다.

Jenkins File Git SCM 연동



Pipeline script from SCM 를 사용하여, 필요한 정보를 채워줍니다.



Script Path에 작성한 Jenkins File 경로를!

Parameter 설정

Flow



캡쳐본과 위에서 설명한 스크립트가 조금 다릅니다. SCP, DRONE, QUEEN이 DEPLOY, SWITCH 입니다. 해당 파라미터를 Boolean Parameter로 설정합니다.

Module

이 단계에서는 Extensible Choice Parameter plugin를 잠시 소개하겠습니다.

Extensible Choice Parameter plugin은 Global 로 등록해놓은 Choice Parameter 를 사용할 수 있도록 되어 있습니다. 즉 Choice Parameter 이지만, 중앙 관리가 가능하도록 제공하는 Plugin 입니다.



이 Plugin을 통해 Jenkins Global Tool Installation을 연동한 듯한(?) 효과를 주기 위함입니다. System Config 에서 Jenkins Global Tool Installation에 정의한 이름으로 매칭하여 Extensible Choice Parameter를 위와 같이 구성했습니다.



그리고 Extensible Choice로 설정한 Choice Parameter 를 정의하였습니다.


  Jenkins Global Tool Installation 관련 pipeline script 에서 사용 가능한 Choice Parameter Plugin이 있다면 공유 부탁드립니다..ㅜㅜ(JDK Parameter Plugin을 시도했으나 기대와 다르게 동작하여 적용하지 못했습니다.)


Git

String Parameter로 아래 정보를 구성합니다.





${BRANCH_TO_BUILD} 환경 변수는 Hook으로 인해 발생한 Branch를 읽는 환경 변수입니다. Template에 유일하게 이 부분만 디폴트 Value를 지정해줍니다. (캡처 본에서 Default Value가 채워진 곳이 몇 군데 있지만, 실제 계속 재사용되는 것은, Branch 뿐입니다.)

Template 사용하기

Git 계정 연동 및 Hook 설정은 생략합니다

Job 생성



new Job에서 제일 아래 Copy from을 통해 Template Job을 복사합니다.

기본 값 채워넣기

대부분의 설정은 기본 설정을 유지하고, 파라미터의 Default Value 만 각 프로젝트에 맞게 설정하여줍니다.









수동 실행

수동으로 Job을 빌드하려면 Build with Parameter를 사용합니다.



그러면 아래와 같이 기본 값들이 채워진 상태로 나오며 실행을 하면 끝!



다시 실행

이미 진행된 Job에 대해서 다시 실행하려면 Rebuild Plugin 을 사용합니다.

이 플러그인은 이미 종료된 실행 잡을 다시 빌드할 수 있도록 도와주는 플러그인입니다. Parameterized 를 지원하여, 해당 실행 잡이 가지고 있던 파라미터를 그대로 사용할 수 있으며, 수정도 가능합니다.

사용 방법은 매우 간단합니다. 플러그인을 설치하면, 아래와 같이 파이프 라인 뷰의 실행 잡에 Rebuild 탭이 보이게 됩니다.



클릭하게 되면 해당 잡 실행기록이 가지고 있던 파라이터가 그대로 기본 설정이 되어 동일한 조건으로 잡의 실행이 가능합니다.

Script 기능 확인!

Pipeline Job이 구성된 후 Job이 실행되면 Stage View에 아래와 같은 화면을 보여줍니다! 기존 Build Pipeline에서는 View 를 따로 만들어야해서 불편했었습니다.



Flow

수동 실행 시 단계를 Test 단계를 스킵하면, 설정한 스크립트대로 아래와 같이!







수동 파이프라인



위와 같이 수동 단계에서 대기하며, 버튼이 제공됩니다!

TIP

IntelliJ에서 GDSL 사용하기

https://gist.github.com/arehmandev/736daba40a3e1ef1fbe939c6674d7da8

gdsl 다운





Snippet Generator

Pipeline gdsl 로 코드를 작성하기 어렵다면, 제공해주는 Snippet Generator를 사용합니다.





Build Pipeline 사용성으로 groovy script 를 생성해주며, 다양한 snippet 이 있습니다! 저 같은 경우는 Docs와 Stack Overflow 을 찾아보면서 했을 때 생기던 오류들이, 정말 쉽게 해결..!



마무리

Jenkins Pipeline은 강력했습니다. Build Pipeline으로 만들었던 모든 기능을 그대로 옮길 수 있을 뿐더라, 제약으로 막혀있던 기능을 스크립트 기반이기에 해결할 수 있었습니다. 고로 Jenkins Pipeline은 뭐든지 가능하다!

그러나 단점도 존재하는 것 같습니다.

일단 groovy를 사용해야 한다는 점! snippet 생성기가 어느 정도 이 부분을 해소해주지만, groovy에 대한 거부감, 혹은 언어를 배우고 싶지 않다면 Build Pipeline으로 구성하는 것이 쉽습니다. 스크립트 작성없이 클릭만(?)으로 만들 수 있기 때문입니다.

또 한가지 단점은 아직도 지원하지 않는 Plugin이 많다는 점 입니다. 인기있는 플러그인 중에서도 Jenkins Pipeline 을 지원하지 않거나, 안정적이지 않은 플러그인들을 꽤 보았습니다. 이 부분은 분명히 시간이 해결해주리라! 믿습니다.

저는 개인적으로 Jenkins Pipeline이 굉장히 마음에 듭니다. maven보다 gradle을 선호하듯, 개발자 친화적 + CoC가 저는 좋습니다.
</description>
        <pubDate>Sat, 04 Nov 2017 00:00:00 +0000</pubDate>
        <link>https://blog.kingbbode.com/posts/jenkins-dsl-to-pipeline</link>
        <guid isPermaLink="true">https://blog.kingbbode.com/posts/jenkins-dsl-to-pipeline</guid>
        
        <category>think,</category>
        
        <category>ci</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>Java 9 Collections, Stream Improvements</title>
        <description>

2017년 9월 21일 Java 9 이 출시되었습니다. 크게 부각되고 있는 기능은 Jigsaw, Reactive Streams, REPL/JShell 가 있습니다.

출시 전부터 기대를 많이 받던 기능들이지만, 학습비용이 어마어마할 것 같습니다 ..!

그래서 저는 일단 제가 바로 쓸 수 있을만한, 코드 짜는 것을 더 편하게 만들어줄 수 있는 Java 9 의 새로운 기능들을 소개해보려고 합니다. 성능적인 부분과 좀 더 언어에 대한 깊은 이해가 있어야 하겠지만, 지극히 부족한 제 관점에서 편리한 기능을 소개해봅니다!

소개할 내용은


  Collections Improvements
  Stream Improvements


입니다.

예제는 이미 추석 전에 모두 작성했었는데…



어마어마한 게으름 추석이 지나고서야 글을 작성하게 되었습니다. 배그가 너무 재밌네요.ㅜㅜ



아래 사용한 예제들은 지극히 사용법을 소개하기 위한 예제이며, 응용에 대한 것은 고려하지 않았습니다.

Collections Improvements

첫 번째로 살펴 볼 것은 정말 많이 사용하고 있는 Collection Framework 에 제공되는 immutable collection을 만드는 팩토리 메서드입니다.

Java의 버전이 올라가면서 정말 많은 기능이 추가되었지만, 2%의 아쉬움을 채워줄 google의 guava library를 사용할 수 밖에 없었습니다.

하지만! 이번 업데이트는 guava를 이제 그만 보내줄 수 있을 것 같습니다!

List.of

Java 8

Collections.unmodifiableList(
  Arrays.asList(1,2,3,4,5,6,7,8,9,10,11)
);

//or

Stream.of(1,2,3,4,5,6,7,8,9,10,11)
  .collect(collectingAndThen(toList(),Collections::unmodifiableList));


IntStream.range(1, 100)
  .boxed()
  .collect(collectingAndThen(toList(),Collections::unmodifiableList))
);


Java 9

List.of(1,2,3,4,5,6,7,8,9,10,11);


List.of(
  IntStream.range(1, 100)
          .boxed()
          .toArray(Integer[]::new)
);


Set.of

Java 8

Collections.unmodifiableSet(
        new HashSet&amp;lt;&amp;gt;(
                Arrays.asList(1,2,3,4,5,6,7,8,9,10,11)
        )
);

//or

Stream.of(1,2,3,4,5,6,7,8,9,10,11)
  .collect(collectingAndThen(toSet(),Collections::unmodifiableSet));



IntStream.range(1, 100)
  .boxed()
  .collect(collectingAndThen(toSet(),Collections::unmodifiableSet))
);


Java 9

Set.of(1,2,3,4,5,6,7,8,9,10,11);


set = Set.of(
        IntStream.range(1, 100)
                .boxed()
                .toArray(Integer[]::new)
);


Map

Java 8

Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
map.put(&quot;key1&quot;, &quot;value1&quot;);
map.put(&quot;key2&quot;, &quot;value2&quot;);
map.put(&quot;key3&quot;, &quot;value3&quot;);
map.put(&quot;key4&quot;, &quot;value4&quot;);
map.put(&quot;key5&quot;, &quot;value5&quot;);
map.put(&quot;key6&quot;, &quot;value6&quot;);
map.put(&quot;key7&quot;, &quot;value7&quot;);
map.put(&quot;key8&quot;, &quot;value8&quot;);
map.put(&quot;key9&quot;, &quot;value9&quot;);
map.put(&quot;key10&quot;, &quot;value10&quot;);
map.put(&quot;key11&quot;, &quot;value11&quot;);
map.put(&quot;key12&quot;, &quot;value12&quot;);
map.put(&quot;key13&quot;, &quot;value13&quot;);
map.put(&quot;key14&quot;, &quot;value14&quot;);
Collections.unmodifiableMap(map);


Stream.of(
  new Pair&amp;lt;&amp;gt;(&quot;key1&quot;, &quot;value1&quot;),
  new Pair&amp;lt;&amp;gt;(&quot;key2&quot;, &quot;value2&quot;),
  new Pair&amp;lt;&amp;gt;(&quot;key3&quot;, &quot;value3&quot;),
  new Pair&amp;lt;&amp;gt;(&quot;key4&quot;, &quot;value4&quot;),
  new Pair&amp;lt;&amp;gt;(&quot;key5&quot;, &quot;value5&quot;),
  new Pair&amp;lt;&amp;gt;(&quot;key6&quot;, &quot;value6&quot;),
  new Pair&amp;lt;&amp;gt;(&quot;key7&quot;, &quot;value7&quot;),
  new Pair&amp;lt;&amp;gt;(&quot;key8&quot;, &quot;value8&quot;),
  new Pair&amp;lt;&amp;gt;(&quot;key9&quot;, &quot;value9&quot;),
  new Pair&amp;lt;&amp;gt;(&quot;key10&quot;, &quot;value10&quot;),
  new Pair&amp;lt;&amp;gt;(&quot;key11&quot;, &quot;value11&quot;),
  new Pair&amp;lt;&amp;gt;(&quot;key12&quot;, &quot;value12&quot;),
  new Pair&amp;lt;&amp;gt;(&quot;key13&quot;, &quot;value13&quot;),
  new Pair&amp;lt;&amp;gt;(&quot;key14&quot;, &quot;value14&quot;)
).collect(collectingAndThen(toMap(Pair::getKey, Pair::getValue),Collections::unmodifiableMap));


Java 9

Map.of(
  &quot;key1&quot;,&quot;value1&quot;,
  &quot;key2&quot;,&quot;value2&quot;,
  &quot;key3&quot;,&quot;value3&quot;,
  &quot;key4&quot;,&quot;value4&quot;,
  &quot;key5&quot;,&quot;value5&quot;,
  &quot;key6&quot;,&quot;value6&quot;,
  &quot;key7&quot;,&quot;value7&quot;,
  &quot;key8&quot;,&quot;value8&quot;,
  &quot;key9&quot;,&quot;value9&quot;,
  &quot;key10&quot;,&quot;value10&quot;
);


Map.ofEntries(
  Map.entry(&quot;key1&quot;, &quot;value1&quot;),
  Map.entry(&quot;key2&quot;, &quot;value2&quot;),
  Map.entry(&quot;key3&quot;, &quot;value3&quot;),
  Map.entry(&quot;key4&quot;, &quot;value4&quot;),
  Map.entry(&quot;key5&quot;, &quot;value5&quot;),
  Map.entry(&quot;key6&quot;, &quot;value6&quot;),
  Map.entry(&quot;key7&quot;, &quot;value7&quot;),
  Map.entry(&quot;key8&quot;, &quot;value8&quot;),
  Map.entry(&quot;key9&quot;, &quot;value9&quot;),
  Map.entry(&quot;key10&quot;, &quot;value10&quot;),
  Map.entry(&quot;key11&quot;, &quot;value11&quot;),
  Map.entry(&quot;key12&quot;, &quot;value12&quot;),
  Map.entry(&quot;key13&quot;, &quot;value13&quot;),
  Map.entry(&quot;key14&quot;, &quot;value14&quot;)
);


Map.ofEntries(
  IntStream.range(1, 100)
    .mapToObj(index -&amp;gt;
            Map.entry(&quot;key&quot; + index, &quot;value&quot; + index)
    )
    .toArray((IntFunction&amp;lt;Map.Entry&amp;lt;String, String&amp;gt;[]&amp;gt;) Map.Entry[]::new)
);


Collections Improvements 에는 편리한 Factory Method 가 정말 많이 생겼습니다. 제가 생각하는 몇 가지 포인트를 집어보았습니다.

1. 가독성

위의 예제들을 보면 알겠지만, 코드 라인 수가 그렇게 많이 절약되는 것이 아닌 경우도 분명히 있습니다.

위 예제 중 한가지를 예로 들자면,

Java 8


 IntStream.range(1, 100)
   .boxed()
   .collect(collectingAndThen(toSet(),Collections::unmodifiableSet))
 );


Java 9

 Set.of(
         IntStream.range(1, 100)
                 .boxed()
                 .toArray(Integer[]::new)
 );


위와 같은 상황입니다.

Java 8 로 작성된 코드를 보았을 때 저 코드가 Set을 반환할 것이라는 것이 한번에 보이지는 않습니다. 반면 Java 9 의 코드는 명시적으로 무슨 행위를 하는지가 먼저 나올 수 있는 형태입니다.

주체에 대한 역전도 보입니다. Java 8 에서 IntStream이 Set을 만든다라면 Java 9 은 Set이 IntStream을 인자로 사용한다로 읽혀질 수 있습니다.

저는 이것이 코드의 흐름을 읽을 수 있는 명시적 작성 효과로 가독이 더 좋아질 수 있다고 생각합니다.

2. 중복에 대한 원천 차단.

@Test(expected = IllegalArgumentException.class)
public void 중복을_허용하지_않는다() {
    set = Set.of(1, 2, 3, 1);
}


@Test(expected = IllegalArgumentException.class)
public void 키_중복을_허용하지_않는다() throws Exception {
    Map.of(
            &quot;key1&quot;, &quot;value1&quot;,
            &quot;key2&quot;, &quot;value1&quot;,
            &quot;key3&quot;, &quot;value1&quot;,
            &quot;key1&quot;, &quot;value1&quot;
    );
}


중복 값을 넣는 경우 예외를 발생시켜, 버그를 원천 차단합니다.



Stream Improvements

Stream 을 사용하면서 항상 Stream 에서 반복에 대한 제어를 못함에 어려운 부분이 많았는데, 이번 새로운 기능으로 어느 정도는 해소가 가능할 것으로 보입니다.

1. takeWhile

while문과 같은 사용성으로 조건이 false가 나올 때까지 Stream 을 생성합니다.

@Test
public void 조건까지의_데이터를_스트림으로_만드는_takeWhile() throws Exception {
   list = Stream.of(
           IntStream.range(1, 5)
                   .boxed()
                   .toArray(Integer[]::new)
   ).takeWhile(integer -&amp;gt; integer &amp;lt; 3)
           .collect(Collectors.toList());
   assertThat(list.size(), is(2));

   //list : [1,2]
}


기존에는 한번 시작된 Stream 을 멈출 수 없었지만, takeWhile 을 사용한다면 특정 조건까지만 돌고 멈추도록 할 수 있게 되었습니다.

@Test
public void takeWhile은_전체를_조건으로_filter하는_것이_아님() throws Exception {
   list = Stream.of(
           1,2,3,4,5,1,2,3,4,5
   ).takeWhile(integer -&amp;gt; integer &amp;lt; 5)
           .collect(Collectors.toList());
   assertThat(list.size(), is(4));
}


takeWhile 은 해당 조건을 만족하지 않는 경우가 처음 만날 때까지, 즉 처음으로 false 가 나올 때 까지만 이므로, Stream 의 filter 와는 전혀 다른 사용성을 갖습니다.

2. dropWhile

dropWhile 은 takeWhile의 정반대로 조건이 false가 나올 때부터 Stream 을 생성합니다.

@Test
public void 조건까지의_데이터를_버리고_스트림으로_만드는_dropWhile() throws Exception {
    list = Stream.of(
            IntStream.range(1, 5)
                    .boxed()
                    .toArray(Integer[]::new)
    ).dropWhile(integer -&amp;gt; integer &amp;lt; 3)
            .collect(Collectors.toList());
    assertThat(list.size(), is(2));
}

//list : [3,4]


정확히 이것이 언제 필요할지는 잘 모르겠지만, takeWhile의 반대 케이스로 분명히 유용히 쓰일 수 있을 것 입니다.

@Test
public void dropWhile은_전체를_조건으로_filter하는_것이_아님() throws Exception {
    list = Stream.of(
            1,2,3,4,5,1,2,3,4,5
    ).dropWhile(integer -&amp;gt; integer &amp;lt; 5)
            .collect(Collectors.toList());
    assertThat(list.size(), is(6));
}


dropWhile 역시 마찬가지로 해당 조건을 만족하지 않는 경우가 처음 만날 때부터이므로, Stream 의 filter 와는 전혀 다른 사용성을 갖습니다.

3. iterate

for문 의 Stream 버전이라고 생각하면 됩니다. 이전에는 IntStream 을 통해 불편하게 사용될 수 있던 부분이 아주 명시적으로 사용할 수 있게 되었습니다.

@Test
public void for문의_Stream_버전_iterate() throws Exception {
    list = Stream.iterate(1, x-&amp;gt; x &amp;lt; 11, x-&amp;gt;x+3).collect(Collectors.toList());
    assertThat(list.size(), is(4));

    //list : [1,4,7,10]
}


4. ofNullable

값이 null 인 경우 빈 Optionals를 반환하는 기능 입니다. 간혹은 Stream으로 전환을 위해 불필요한 NullPointerExceptions 확인이 필요했었습니다. null 검사를 회피할 수 있도록 도와주는 기능이라고 생각됩니다.

@Test
public void null을_허용하는_ofNullable() throws Exception {
    list = Stream.&amp;lt;Integer&amp;gt;ofNullable(null).collect(Collectors.toList());
    assertThat(list, notNullValue());
    assertThat(list.size(), is(0));
}




마무리

이상 자바 9의 핵심 기능 외에도 소소하게 유용하게 써먹을 수 있는 기능들을 정리해보았습니다.

이 글을 쓰려고 한참 전부터 미루다가 작성을 하게 되었는데, 그동안 고수님들이 언어와 성능을 생각하며 위 내용에 대한 대화를 나누시는 걸 보고, 앞으로도 더 열심히 자바 공부를 해야겠구나 느꼈습니다.ㅜㅜ
</description>
        <pubDate>Sun, 29 Oct 2017 00:00:00 +0000</pubDate>
        <link>https://blog.kingbbode.com/posts/java9-practice</link>
        <guid isPermaLink="true">https://blog.kingbbode.com/posts/java9-practice</guid>
        
        <category>java</category>
        
        
        <category>posts</category>
        
      </item>
    
  </channel>
</rss>
