<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by landvibe on Medium]]></title>
        <description><![CDATA[Stories by landvibe on Medium]]></description>
        <link>https://medium.com/@ljs0705?source=rss-11f5040686d4------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*a3B8yPmXf1-a3Vayx5kPnA.jpeg</url>
            <title>Stories by landvibe on Medium</title>
            <link>https://medium.com/@ljs0705?source=rss-11f5040686d4------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 12:13:44 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@ljs0705" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[JS 모듈 시스템과 순환 참조 문제]]></title>
            <link>https://medium.com/@ljs0705/js-%EB%AA%A8%EB%93%88-%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B3%BC-%EC%88%9C%ED%99%98-%EC%B0%B8%EC%A1%B0-%EB%AC%B8%EC%A0%9C-a9e0c90c07e5?source=rss-11f5040686d4------2</link>
            <guid isPermaLink="false">https://medium.com/p/a9e0c90c07e5</guid>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[esm]]></category>
            <category><![CDATA[순환참조]]></category>
            <category><![CDATA[circular-dependencies]]></category>
            <category><![CDATA[modules]]></category>
            <dc:creator><![CDATA[landvibe]]></dc:creator>
            <pubDate>Sat, 09 Feb 2019 14:40:05 GMT</pubDate>
            <atom:updated>2019-02-09T14:40:05.566Z</atom:updated>
            <content:encoded><![CDATA[<p>자바스크립트의 모듈 시스템이 동작하는 방식을 이해해보자. 그리고 순환 참조 시 발생할 수 있는 문제와 해결책을 알아보자.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*V_5YM7Zdbbfngivu5ZZTIw.png" /><figcaption>JS Module System and Circular Dependencies</figcaption></figure><p>노드를 포함한 자바스크립트 생태계에는 여러 가지 모듈 시스템이 있지만 ES6에 정식으로 포함된 ESM을 기준으로 알아보자. 여기서 설명하는 대부분의 내용은 commonJS와 같은 다른 모듈 시스템에도 해당되는 내용이다.</p><p>아래의 모든 코드는 <a href="https://github.com/landvibe/esm-tutorial">깃헙 저장소</a>에서 확인할 수 있다. 저장소에서 코드를 내려받고 아래 명령어를 실행하자.</p><pre>npm install<br>npm start</pre><p>이제 실습을 위한 준비가 끝났다.</p><h4>ESM이 동작하는 기본 방식</h4><p><a href="https://github.com/landvibe/esm-tutorial/tree/master/basic">basic 폴더</a>는 ESM이 동작하는 기본 방식을 설명한다. 폴더에는 5개의 파일이 있고, 그 내용은 아래와 같다.</p><pre>// index.html<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;script type=&quot;module&quot; src=&quot;/basic/index.js&quot;&gt;&lt;/script&gt;<br>  &lt;/head&gt;<br>&lt;/html&gt;</pre><pre>// index.js<br>import &#39;./a.js&#39;;</pre><pre>// a.js<br>import { sayHello } from &#39;./b.js&#39;;<br>import { sayHello2 } from &#39;./c.js&#39;;<br>console.log(&#39;module_a&#39;);<br>sayHello();<br>sayHello2();</pre><pre>// b.js<br>console.log(&#39;module_b&#39;);<br>export const sayHello = () =&gt; {<br>  console.log(&#39;hello~!&#39;);<br>}</pre><pre>// c.js<br>import { sayHello } from &#39;./b.js&#39;;<br>console.log(&#39;module_c&#39;);<br>export const sayHello2 = () =&gt; {<br>  sayHello();<br>  sayHello();<br>}</pre><p>브라우저가 index.html을 실행할 때 콘솔에 출력되는 로그를 생각해보자.</p><p>…</p><p>…</p><p>…</p><p>…</p><p>…</p><p><a href="http://localhost:5000/basic">http://localhost:5000/basic</a>에 접속하면 출력되는 로그를 확인할 수 있다.</p><pre>module_b<br>module_c<br>module_a<br>hello~!<br>hello~!<br>hello~!</pre><p>코드가 실행되는 순서는 다음과 같다. 참고로 모듈을 평가한다는 의미는 해당 파일의 코드를 위에서부터 순서대로 실행한다는 의미다.</p><ul><li>index.js 모듈이 실행될 때 a.js 모듈을 평가(evaluation)한다.</li><li>a.js에서 b.js 모듈을 평가한다.</li><li>b.js 모듈의 module_b 로그가 출력된다.</li><li>b.js 모듈은 sayHello 함수를 내보내고 평가를 종료한다.</li><li>a.js에서 c.js 모듈을 평가한다.</li><li>c.js에서 b.js 모듈을 가져올 때는 b.js 모듈이 다시 평가되지 않는다.</li><li>c.js 모듈의 module_c 로그가 출력된다.</li><li>c.js 모듈은 sayHello2 함수를 내보내고 평가를 종료한다.</li><li>a.js 모듈의 module_a 로그가 출력된다.</li><li>a.js 모듈에서 sayHello, sayHello2 함수를 호출하고 평가를 종료한다.</li></ul><p>여기서 주목할 점은 각 모듈은 최초 한 번만 평가된다는 점이다. b.js 모듈은 두 곳에서 import 하지만 한 번만 평가된다.</p><h4>순환 참조</h4><p>자바스크립트 모듈 시스템에서는 순환 참조를 허용한다. <a href="https://github.com/landvibe/esm-tutorial/tree/master/cd-pass">cd-pass 폴더</a>는 순환 참조를 설명한다.</p><pre>// index.js<br>import &#39;./a.js&#39;;</pre><pre>// a.js<br>import { sayHello } from &#39;./b.js&#39;;<br>export const NAME = &#39;mike&#39;;<br>console.log(&#39;module_a&#39;);<br>sayHello();</pre><pre>// b.js<br>import { NAME } from &#39;./a.js&#39;;<br>console.log(&#39;module_b&#39;);<br>export const sayHello = () =&gt; {<br>  console.log(&#39;hello~!&#39;, NAME);<br>};</pre><p>a.js 모듈과 b.js 모듈은 서로를 참조하지만 위 코드는 에러 없이 실행된다. <a href="http://localhost:5000/cd-pass">http://localhost:5000/cd-pass</a>에 접속하면 출력되는 로그를 확인할 수 있다.</p><pre>module_b<br>module_a<br>hello~! mike</pre><p>코드가 실행되는 순서는 다음과 같다.</p><ul><li>index.js 모듈이 실행될 때 a.js 모듈을 평가한다.</li><li>a.js 모듈에서 b.js 모듈을 평가한다.</li><li>b.js 모듈에서 a.js 모듈을 가져온다(a.js 모듈은 평가되지 않는다).</li><li>b.js 모듈의 module_b 로그가 출력된다.</li><li>b.js 모듈은 sayHello 함수를 내보내고 평가를 종료한다.</li><li>a.js 모듈은 NAME 변수를 내보낸다.</li><li>a.js 모듈의 module_a 로그가 출력된다.</li><li>a.js 모듈에서 sayHello 함수를 호출하고 평가를 종료한다.</li></ul><p>b.js 모듈에서 a.js 모듈을 가져온 시점에는 아직 a.js 모듈이 NAME 변수를 내보내지 않았다. 그런데 sayHello 함수는 `hello~! undefined`를 출력하지 않고 어떻게 `hello~! mike`를 출력한 것일까?</p><p>모든 모듈은 모듈 객체를 갖고 있다. 그리고 모듈이 내보내는 변수와 함수는 모듈 객체에 추가된다. sayHello 함수에서 mike를 출력할 수 있는 이유는 NAME 변수에 접근할 때 모듈 객체로부터 해당 값을 가져오기 때문이다. 즉, b.js 모듈의 sayHello 함수의 코드는 아래와 같다고 이해할 수 있다.</p><pre>export const sayHello = () =&gt; {<br>  console.log(&#39;hello~!&#39;, aModuleObject.NAME);<br>};</pre><p>위에서 코드가 실행되는 순서를 설명할 때 `내보낸다`라는 표현은 사실 `모듈 객체에 추가된다`라고 이해할 수 있다. 모듈 객체를 통해서 코드의 실행 순서를 다시 설명하면 아래와 같다.</p><ul><li>index.js 모듈이 실행될 때 a.js 모듈을 평가한다.</li><li>a.js 모듈에서 b.js 모듈을 평가한다.</li><li>b.js 모듈에서 a.js 모듈을 가져온다(a.js 모듈은 평가되지 않는다).</li><li>b.js 모듈의 module_b 로그가 출력된다.</li><li>b.js 모듈은 sayHello 함수를 bModuleObject에 추가하고 평가를 종료한다.</li><li>a.js 모듈은 NAME 변수를 aModuleObject에 추가한다.</li><li>a.js 모듈의 module_a 로그가 출력된다.</li><li>a.js 모듈에서 bModuleObject.sayHello 함수를 호출하고 평가를 종료한다.</li></ul><h4>순환 참조의 문제 1</h4><p>순환 참조가 허용되지만 잘못 사용하면 에러가 발생할 수 있다. <a href="https://github.com/landvibe/esm-tutorial/tree/master/cd-fail-1">cd-fail-1</a> 폴더는 순환 참조에서 에러가 발생하는 경우를 설명한다.</p><pre>// index.js<br>import &#39;./a.js&#39;;</pre><pre>// a.js<br>import { sayHello } from &#39;./b.js&#39;;<br>console.log(&#39;module_a&#39;);<br>sayHello();<br>export const NAME = &#39;mike&#39;; ❶</pre><pre>// b.js<br>import { NAME } from &#39;./a.js&#39;;<br>console.log(&#39;module_b&#39;);<br>export const sayHello = () =&gt; {<br>  console.log(&#39;hello~!&#39;, NAME);<br>};</pre><p>이전 코드와 다른 점은 NAME 변수를 내보내는 시점(❶)이 sayHello 함수 호출 이후라는 점이다. sayHello 함수를 호출할 때는 aModuleObject에 NAME 속성이 없으므로 에러가 발생한다.</p><p>이 문제는 단순히 NAME 변수를 내보내는 코드를 이전처럼 위로 올려주면 된다.</p><p>자바스크립트는 객체에서 존재하지 않는 속성을 가져올 때 에러가 발생하지 않고 undefined가 반환된다. 하지만 ESM에서는 모듈에서 없는 속성을 가져올 때 에러가 발생한다. 명시적으로 에러가 발생하기 때문에 순환 참조 문제를 빠르게 인식할 수 있다.</p><p>commonJS에서는 일반적인 객체처럼 undefined가 반환되고, 웹팩으로 번들링하면 마찬가지로 undefined가 반환된다. 명시적으로 에러가 발생하지 않기 때문에 순환 참조 문제를 쉽게 알아차리기 힘들다. 따라서 commonJS나 웹팩을 사용하는 프로젝트에서 순환 참조 문제를 만나면 ‘아~ 이게 순환 참조 때문이구나’라고 깨닫는 것이 중요하면서 힘든 일이다.</p><h4>순환 참조의 문제 2</h4><p><a href="https://github.com/landvibe/esm-tutorial/tree/master/cd-fail-2">cd-fail-2</a> 폴더는 순환 참조에서 에러가 발생하는 또 다른 경우를 설명한다.</p><pre>// index.js<br>import &#39;./b.js&#39;;</pre><pre>// a.js<br>import { sayHello } from &#39;./b.js&#39;;<br>export const NAME = &#39;mike&#39;;<br>console.log(&#39;module_a&#39;);<br>sayHello();</pre><pre>// b.js<br>import { NAME } from &#39;./a.js&#39;;<br>console.log(&#39;module_b&#39;);<br>export const sayHello = () =&gt; {<br>  console.log(&#39;hello~!&#39;, NAME);<br>};</pre><p>cd-pass 폴더의 코드와 다른 점은 index.js에서 a.js 모듈이 아니라 b.js 모듈을 가져온다는 점이다. 코드가 실행되는 순서는 다음과 같다.</p><ul><li>index.js 모듈이 실행될 때 b.js 모듈을 평가한다.</li><li>b.js 모듈에서 a.js 모듈을 평가한다.</li><li>a.js 모듈에서 b.js 모듈을 가져온다(b.js 모듈은 평가되지 않는다).</li><li>a.js 모듈은 NAME 변수를 aModuleObject에 추가한다.</li><li>a.js 모듈의 module_a 로그가 출력된다.</li><li>a.js 모듈에서 bModuleObject.sayHello 함수 호출을 시도하지만 해당 함수는 존재하지 않아서 에러가 발생한다.</li></ul><p>이 문제는 index.js 파일에서 a.js 모듈을 가져오도록 수정하면 해결된다. 즉, 순환 참조가 존재하는 경우 모듈의 평가 순서가 중요하다. 여기서 보여준 예제는 간단하기 때문에 쉽게 문제를 해결했지만, 실제 프로젝트에서 순환 참조 문제를 만나면 하루 종일 (혹은 며칠간) 시달릴 수 있다.</p><p>순환 참조 문제를 해결하기 위해 코드를 이리저리 움직이다 보면 운 좋게 에러가 사라질 수 있다. 코드를 이렇게 저렇게 변경하니까 에러가 사라졌다. 그런데 이게 왜 되는 건지 모르겠다… 이런 경험 한 번씩 있을 거다.</p><h4>순환 참조 문제 해결하기</h4><p>순환 참조 문제는 모듈의 평가 순서를 정해주면 대부분 해결된다. 여기서 설명하는 방법은 immer와 mobx를 만든 <a href="https://medium.com/visual-development/how-to-fix-nasty-circular-dependency-issues-once-and-for-all-in-javascript-typescript-a04c987cf0de">Michel Weststrate이 설명</a>한 방법이다.</p><p>그 방법은 다음과 같다. 모듈의 평가 순서를 정의하는 파일을 만든다. 그리고 모듈을 가져올 때는 항상 그 파일로부터 가져온다. <a href="https://github.com/landvibe/esm-tutorial/tree/master/cd-solution">cd-solution 폴더</a>에서 이 방법으로 구현된 코드를 확인할 수 있다.</p><pre>// index.js<br>import { NAME, sayHello } from &#39;./modules.js&#39;; ❶</pre><pre>// modules.js<br>export * from &#39;./b.js&#39;;<br>export * from &#39;./a.js&#39;;</pre><pre>// a.js<br>import { sayHello } from &#39;./modules.js&#39;; ❷<br>export const NAME = &#39;mike&#39;;<br>console.log(&#39;module_a&#39;);<br>sayHello();</pre><pre>// b.js<br>import { NAME } from &#39;./modules.js&#39;; ❸<br>console.log(&#39;module_b&#39;);<br>export const sayHello = () =&gt; {<br>  console.log(&#39;hello~!&#39;, NAME);<br>};</pre><p>modules.js 파일에서 모듈의 평가 순서를 결정한다. 모듈을 가져올 때(❶❷❸)는 항상 modules.js 파일을 통해서 가져온다. 이렇게 하면 순환 참조에서 모듈의 평가 순서 때문에 발생하는 에러를 방지할 수 있다.</p><p>규모가 큰 프로젝트에서 모든 모듈을 한 파일로 모은 다는 것은 말이 안 된다. 대부분의 프로젝트에서 common 등의 이름을 가진 폴더로 공통 모듈을 모아놓을 것이다. common 폴더에 있는 모듈의 평가 순서만 정해줘도 순환 참조 문제의 상당 부분을 해결할 수 있다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a9e0c90c07e5" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[eslint 룰 만들기]]></title>
            <link>https://medium.com/@ljs0705/eslint-%EB%A3%B0-%EB%A7%8C%EB%93%A4%EA%B8%B0-27113d4dc139?source=rss-11f5040686d4------2</link>
            <guid isPermaLink="false">https://medium.com/p/27113d4dc139</guid>
            <category><![CDATA[ast]]></category>
            <category><![CDATA[eslint]]></category>
            <category><![CDATA[tslint]]></category>
            <category><![CDATA[custom-rule]]></category>
            <dc:creator><![CDATA[landvibe]]></dc:creator>
            <pubDate>Mon, 24 Dec 2018 14:38:48 GMT</pubDate>
            <atom:updated>2018-12-24T14:40:58.898Z</atom:updated>
            <content:encoded><![CDATA[<p>eslint는 코딩 컨벤션을 일관되게 유지할 수 있도록 도와준다. 보통 다른 사람들이 많들어 놓은 여러 eslint 룰을 조합해서 사용한다. 구글과 에어비엔비는 해당 회사에서 사용하는 eslint 룰을 공개했다. 대개 구글과 에어비엔비의 eslint 룰을 사용하는 것으로도 충분하다.</p><p>가끔은 자신만의 룰을 만들고 싶을 때가 있다. 가령 아래 코드의 경우 크롬에서는 의도한 대로 동작하지만, 사파리에서는 동작하지 않는다.</p><pre>const date = new Date(&#39;2018–01–02 00:00:00&#39;);</pre><p>날짜 처리는 moment 또는 date-fns 패키지를 사용하는 게 정신 건강에 좋다. 프로젝트에서 사용할 공통 함수로 createDate를 만들고, createDate 내부에서 moment 또는 date-fns를 사용한다고 가정해보자. 프로젝트에 새로운 코딩 컨벤션이 생겼다.</p><pre>// 날짜 생성은 항상 createDate 함수를 이용한다.<br>// 단, 인수가 없는 new Date() 호출은 허용한다.<br>const date = createDate(&#39;2018–01–02 00:00:00&#39;);<br>const date = new Date();</pre><p>이 컨벤션을 팀에 전파하고 컨벤션 문서에 기록하면, 초반에는 조금씩 실수를 하더라도 점점 좋아진다. 문제는 팀에 새로 합류하는 사람이다. 컨벤션 문서는 문서일 뿐 적응하는 기간에는 실수할 수밖에 없다. 컨벤션의 개수가 많을수록 적응 기간은 길어진다. 기존 팀원도 사람이므로 가끔 실수할 수 있다.</p><p>위 컨벤션을 eslint 룰로 만들 수 있다면, 컨벤션 문서에 기록하는 것보다 상황은 훨씬 좋아진다. 지금부터 위 컨벤션을 위한 eslint 룰과 tslint 룰을 만들어보자.</p><h4>eslint 룰 만들기</h4><p>룰을 만들기 위해서는 자바스크립트의 AST(abstract syntax tree)를 이해해야 한다. AST는 코드의 구조를 이해하기 위한 구조체다. eslint는 우리의 코드가 룰을 따르는지 검사하기 위해 AST를 이용한다. 따라서 eslint 룰도 AST에 기반해서 작성한다. 특정 코드의 AST는 <a href="https://astexplorer.net/">astexplorer.net</a>에서 확인할 수 있다. <a href="https://astexplorer.net/">astexplorer.net</a>에서 아래 코드를 입력해보자.</p><pre>const date = new Date(&#39;2018–01–02 00:00:00&#39;);</pre><p>eslint는 espree라는 자체 파서를 사용하기 때문에 아래와 같이 설정해야 한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*cU7_fECYLtDMhNY9WV-iHw.png" /></figure><p>오른쪽에 우리가 입력한 코드의 AST가 보인다. 아래는 AST의 일부를 보여준다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/912/1*poNmno5Ugq5pYB9cJFc7Ug.png" /></figure><p>AST의 모든 노드는 타입(type) 속성을 갖는다. 우리는 NewExpression 타입에 관심이 있다. 그리고 callee.name === “Date”이면서 arguments.length &gt; 0 이면 에러를 보여주면 된다.</p><p>아래는 위 내용을 그대로 표현한 eslint 룰 파일이다.</p><pre>module.exports = {<br>  rules: {<br>    &#39;no-date-with-args&#39;: { ❶<br>      create(context) {<br>        return {<br>          NewExpression(node) { ❷<br>            if (node.callee.name === &#39;Date&#39; &amp;&amp; node.arguments.length &gt; 0) {<br>              context.report({ ❸<br>                node,<br>                message: &#39;Do not use `new Date` with arguments&#39;,<br>              });<br>            }<br>          },<br>        };<br>      },<br>    },<br>  },<br>};</pre><p>❶ 룰 이름이다. ❷ 관심 있는 노드의 타입 이름을 그대로 함수 이름으로 사용한다. 이렇게 하면 NewExpression 노드가 생성될 때마다 이 함수가 호출된다. ❸ 에러를 리포트한다.</p><p><a href="https://github.com/landvibe/eslint-custom-rule/tree/master/eslint-rule">여기</a>에서 동작하는 코드를 확인할 수 있다. 해당 저장소에서 아래 명령어를 입력해보자.</p><ul><li>npm install</li><li>npm run lint</li></ul><h4>tslint 룰 만들기</h4><p>이번에는 타입스크립트에서 사용하는 tslint의 룰을 만들어보자. 타입스크립트의 AST를 확인하기 위해 파서 목록에서 typescript를 선택하자.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*NsQwuObILT5phs2qJJ2iRA.png" /></figure><p>같은 코드라고 하더라도 타입스크립트의 AST는 이전에 확인했던 것과 조금 다르다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/896/1*aEBliGketxbBMXUCwZbDpw.png" /></figure><p>아래는 tslint 룰 파일의 내용이다.</p><pre>import * as ts from &#39;typescript&#39;;<br>import * as Lint from &#39;tslint&#39;;</pre><pre>export class Rule extends Lint.Rules.AbstractRule {<br>  public static FAILURE_STRING = &#39;Do not use `new Date` with arguments&#39;;<br>  public apply(sourceFile: ts.SourceFile): Lint.RuleFailure[] {<br>    return this.applyWithWalker(new MyWalker(sourceFile, this.getOptions()));<br>  }<br>}</pre><pre>class MyWalker extends Lint.RuleWalker {<br>  public visitNewExpression(node: ts.NewExpression) { ❶<br>    if (<br>      node.expression.kind === ts.SyntaxKind.Identifier &amp;&amp;<br>      node.expression.getText() === &#39;Date&#39; &amp;&amp;<br>      node.arguments &amp;&amp;<br>      node.arguments.length &gt; 0<br>    ) {<br>      this.addFailure( ❷<br>        this.createFailure(<br>          node.getStart(),<br>          node.getWidth(),<br>          Rule.FAILURE_STRING,<br>        ),<br>      );<br>    }<br>    super.visitNewExpression(node);<br>  }<br>}</pre><p>❶ NewExpression 노드가 생성될 때마다 이 메서드가 호출된다. ❷ 에러를 리포트한다.</p><p><a href="https://github.com/landvibe/eslint-custom-rule/tree/master/tslint-rule">여기</a>에서 동작하는 코드를 확인할 수 있다. 해당 저장소에서 아래 명령어를 입력해보자.</p><ul><li>npm install</li><li>npm run lint</li></ul><p>위 tslint 룰 파일은 타입스크립트로 작성됐다. 이 파일을 자바스크립트로 컴파일해야 tslint 룰로 제대로 인식된다. 따라서 ts 룰 파일을 수정하면 js 파일로 컴파일해야 한다.</p><ul><li>npm run build-rules</li></ul><h4>마치며</h4><p>AST를 이해하면 우리가 작성한 코드를 기반으로 다양한 일을 할 수 있다. 가령 바벨(babel)의 플러그인도 AST를 기반으로 작성된다. 따라서 AST를 이해하면 바벨 플러그인을 작성할 수 있고, 컴파일 과정에서 원하는 대로 코드를 변경할 수 있다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=27113d4dc139" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[다행히 지금은 2.3을 지원하지 않기로 결정했답니다^^]]></title>
            <link>https://medium.com/@ljs0705/%EB%8B%A4%ED%96%89%ED%9E%88-%EC%A7%80%EA%B8%88%EC%9D%80-2-3%EC%9D%84-%EC%A7%80%EC%9B%90%ED%95%98%EC%A7%80-%EC%95%8A%EA%B8%B0%EB%A1%9C-%EA%B2%B0%EC%A0%95%ED%96%88%EB%8B%B5%EB%8B%88%EB%8B%A4-cd204cfeb070?source=rss-11f5040686d4------2</link>
            <guid isPermaLink="false">https://medium.com/p/cd204cfeb070</guid>
            <dc:creator><![CDATA[landvibe]]></dc:creator>
            <pubDate>Sat, 10 Nov 2018 12:05:08 GMT</pubDate>
            <atom:updated>2018-11-10T12:05:08.266Z</atom:updated>
            <content:encoded><![CDATA[<p>다행히 지금은 2.3을 지원하지 않기로 결정했답니다^^</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=cd204cfeb070" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[지금은 채용이 완료된 상태입니다.]]></title>
            <link>https://medium.com/@ljs0705/%EC%A7%80%EA%B8%88%EC%9D%80-%EC%B1%84%EC%9A%A9%EC%9D%B4-%EC%99%84%EB%A3%8C%EB%90%9C-%EC%83%81%ED%83%9C%EC%9E%85%EB%8B%88%EB%8B%A4-5e314e055ac0?source=rss-11f5040686d4------2</link>
            <guid isPermaLink="false">https://medium.com/p/5e314e055ac0</guid>
            <dc:creator><![CDATA[landvibe]]></dc:creator>
            <pubDate>Sun, 23 Sep 2018 08:11:06 GMT</pubDate>
            <atom:updated>2018-09-23T08:11:06.242Z</atom:updated>
            <content:encoded><![CDATA[<p>지금은 채용이 완료된 상태입니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5e314e055ac0" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[네 상관없습니다.]]></title>
            <link>https://medium.com/@ljs0705/%EB%84%A4-%EC%83%81%EA%B4%80%EC%97%86%EC%8A%B5%EB%8B%88%EB%8B%A4-d1f78e989081?source=rss-11f5040686d4------2</link>
            <guid isPermaLink="false">https://medium.com/p/d1f78e989081</guid>
            <dc:creator><![CDATA[landvibe]]></dc:creator>
            <pubDate>Thu, 26 Jul 2018 23:10:09 GMT</pubDate>
            <atom:updated>2018-07-26T23:10:09.688Z</atom:updated>
            <content:encoded><![CDATA[<p>네 상관없습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d1f78e989081" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[함께 일할 동료를 찾습니다]]></title>
            <link>https://medium.com/@ljs0705/%ED%95%A8%EA%BB%98-%EC%9D%BC%ED%95%A0-%EB%8F%99%EB%A3%8C%EB%A5%BC-%EC%B0%BE%EC%8A%B5%EB%8B%88%EB%8B%A4-6628e68878d4?source=rss-11f5040686d4------2</link>
            <guid isPermaLink="false">https://medium.com/p/6628e68878d4</guid>
            <category><![CDATA[카카오페이지]]></category>
            <category><![CDATA[프런트엔드]]></category>
            <category><![CDATA[채용]]></category>
            <dc:creator><![CDATA[landvibe]]></dc:creator>
            <pubDate>Sat, 14 Jul 2018 15:08:21 GMT</pubDate>
            <atom:updated>2018-09-23T08:15:13.241Z</atom:updated>
            <content:encoded><![CDATA[<p>*********** 현재는 채용이 완료된 상태입니다 ***********</p><p>제 소개부터 해야겠네요.</p><p>카카오페이지에서 웹 프런트엔드 개발자로 일하고 있습니다. 게임도 만들어보고 데이터 관련된 일도 좀 해봤습니다. 그러다 1년 전에 웹 프런트엔드로 전향했어요. 요새 자바스크립트가 참 재밌네요. 한창 C++로 코딩하던 시절에 누가 자바스크립트 얘기하면 속으로 비웃었어요. ES6 이후로 자바스크립트 참 매력적으로 변했네요. 인정합니다.</p><p>react, vue, redux, mobx, babel, webpack, parcel, prepack, yarn, typescript, jest, enzyme, next.js, immutable.js, css-in-js, PWA, WebAssembly, prettier, storybook, …</p><p>요새 자바스크립트 생태계가 핫하죠. 지금 이 순간에도 새로운 것들이 쏟아져 나오고 있고요. 새로운 기술들을 보면서 저도 아직 많이 부족하다는 것을 느껴요. 같이 공부하면서 함께 성장할 동료를 찾습니다.</p><p><a href="https://page.kakao.com/main">카카오페이지 웹</a> 프로젝트가 현재 어떤 모습으로 바뀌고 있는지는 <a href="https://medium.com/@ljs0705/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%9B%B9-react-%ED%8F%AC%ED%8C%85-%ED%9B%84%EA%B8%B0-76402cc5e031">지난번 포스트</a>에서 확인하실 수 있어요.</p><p>카카오페이지는 흑자 회사고 성장하고 있는 회사에요. 상장할 것 같다고 기사도 몇 번 났었죠. 회사가 돈을 벌고 있고 계속 성장하고 있다는 사실은 중요해요. 월급이 안 나올 확률이 낮고, 복지도 좋아질 확률이 높죠. 그리고 다른 곳에서 경험하기 힘든, 기술적으로 도전적인 과제도 많고요.</p><p>아래 항목 중 하나라도 해당된다면 환영합니다.</p><ul><li>프로그래밍을 즐기시는 분</li><li>깃헙 별 5,000개 이상인 저장소에 커밋한 경험이 있으신 분</li><li>css 초고수</li></ul><p>관심 있는 분은 제 메일 주소(landvibe@podotree.com)로 연락 주세요.</p><p>아래는 제가 예전에 페이스북에 포스팅했던 회사 소개에요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*hm6ZMYBY7fMkZ-hJpQEKLQ.png" /></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6628e68878d4" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Thank you for sharing this wonderful article!]]></title>
            <link>https://medium.com/@ljs0705/thank-you-for-sharing-this-wonderful-article-ef64e325e016?source=rss-11f5040686d4------2</link>
            <guid isPermaLink="false">https://medium.com/p/ef64e325e016</guid>
            <dc:creator><![CDATA[landvibe]]></dc:creator>
            <pubDate>Sun, 06 May 2018 15:03:48 GMT</pubDate>
            <atom:updated>2018-05-06T15:03:48.404Z</atom:updated>
            <content:encoded><![CDATA[<p>Thank you for sharing this wonderful article!</p><p>I have a question on state type.</p><p>I think initialState is not enough to make the state type.</p><p>For example,</p><p>const initialState = {v1: 0, v2: undefined};</p><p>How can I make v1: number | string and v2: undefined | number ?</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ef64e325e016" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[그나마 안드로이드 4.4 부터 css flexbox의 새로운 스펙(2011년?)이 적용되서 괜찮은데 안드로이드 4.4 미만은 오래된 스펙(2009년)으로 돼있어서 골치아프네요]]></title>
            <link>https://medium.com/@ljs0705/%EA%B7%B8%EB%82%98%EB%A7%88-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-4-4-%EB%B6%80%ED%84%B0-css-flexbox%EC%9D%98-%EC%83%88%EB%A1%9C%EC%9A%B4-%EC%8A%A4%ED%8E%99-2011%EB%85%84-%EC%9D%B4-%EC%A0%81%EC%9A%A9%EB%90%98%EC%84%9C-%EA%B4%9C%EC%B0%AE%EC%9D%80%EB%8D%B0-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-4-4-%EB%AF%B8%EB%A7%8C%EC%9D%80-%EC%98%A4%EB%9E%98%EB%90%9C-%EC%8A%A4%ED%8E%99-2009%EB%85%84-%EC%9C%BC%EB%A1%9C-%EB%8F%BC%EC%9E%88%EC%96%B4%EC%84%9C-%EA%B3%A8%EC%B9%98%EC%95%84%ED%94%84%EB%84%A4%EC%9A%94-a2df2c53c348?source=rss-11f5040686d4------2</link>
            <guid isPermaLink="false">https://medium.com/p/a2df2c53c348</guid>
            <dc:creator><![CDATA[landvibe]]></dc:creator>
            <pubDate>Sat, 28 Apr 2018 07:53:34 GMT</pubDate>
            <atom:updated>2018-04-28T07:53:34.220Z</atom:updated>
            <content:encoded><![CDATA[<p>그나마 안드로이드 4.4 부터 css flexbox의 새로운 스펙(2011년?)이 적용되서 괜찮은데 안드로이드 4.4 미만은 오래된 스펙(2009년)으로 돼있어서 골치아프네요</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a2df2c53c348" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[윈드가 오셔서 하시는게 더 빠를걸요ㅎㅎ]]></title>
            <link>https://medium.com/@ljs0705/%EC%9C%88%EB%93%9C%EA%B0%80-%EC%98%A4%EC%85%94%EC%84%9C-%ED%95%98%EC%8B%9C%EB%8A%94%EA%B2%8C-%EB%8D%94-%EB%B9%A0%EB%A5%BC%EA%B1%B8%EC%9A%94%E3%85%8E%E3%85%8E-322bdab8cbb1?source=rss-11f5040686d4------2</link>
            <guid isPermaLink="false">https://medium.com/p/322bdab8cbb1</guid>
            <dc:creator><![CDATA[landvibe]]></dc:creator>
            <pubDate>Tue, 24 Apr 2018 14:47:47 GMT</pubDate>
            <atom:updated>2018-04-24T14:47:47.593Z</atom:updated>
            <content:encoded><![CDATA[<p>윈드가 오셔서 하시는게 더 빠를걸요ㅎㅎ</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=322bdab8cbb1" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[앱도 2.3 지원해요;;;]]></title>
            <link>https://medium.com/@ljs0705/%EC%95%B1%EB%8F%84-2-3-%EC%A7%80%EC%9B%90%ED%95%B4%EC%9A%94-6ed5d99f74ef?source=rss-11f5040686d4------2</link>
            <guid isPermaLink="false">https://medium.com/p/6ed5d99f74ef</guid>
            <dc:creator><![CDATA[landvibe]]></dc:creator>
            <pubDate>Tue, 24 Apr 2018 07:03:44 GMT</pubDate>
            <atom:updated>2018-04-24T07:03:44.989Z</atom:updated>
            <content:encoded><![CDATA[<p>앱도 2.3 지원해요;;;</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6ed5d99f74ef" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>