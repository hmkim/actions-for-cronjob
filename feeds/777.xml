<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by 홍구 on Medium]]></title>
        <description><![CDATA[Stories by 홍구 on Medium]]></description>
        <link>https://medium.com/@maxzidell?source=rss-ddef89cb38f6------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/0*9i09ewkK2mNitpSL.jpg</url>
            <title>Stories by 홍구 on Medium</title>
            <link>https://medium.com/@maxzidell?source=rss-ddef89cb38f6------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 20:53:30 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@maxzidell" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[리액트 네이티브에 대한 상세한 후기 감사드립니다. 많은 도움이 되었습니다.]]></title>
            <link>https://medium.com/@maxzidell/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C%EC%97%90-%EB%8C%80%ED%95%9C-%EC%83%81%EC%84%B8%ED%95%9C-%ED%9B%84%EA%B8%B0-%EA%B0%90%EC%82%AC%EB%93%9C%EB%A6%BD%EB%8B%88%EB%8B%A4-%EB%A7%8E%EC%9D%80-%EB%8F%84%EC%9B%80%EC%9D%B4-%EB%90%98%EC%97%88%EC%8A%B5%EB%8B%88%EB%8B%A4-666dc7f9f330?source=rss-ddef89cb38f6------2</link>
            <guid isPermaLink="false">https://medium.com/p/666dc7f9f330</guid>
            <dc:creator><![CDATA[홍구]]></dc:creator>
            <pubDate>Sun, 09 Dec 2018 09:25:58 GMT</pubDate>
            <atom:updated>2018-12-09T09:25:58.757Z</atom:updated>
            <content:encoded><![CDATA[<p>리액트 네이티브에 대한 상세한 후기 감사드립니다. 많은 도움이 되었습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=666dc7f9f330" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[간단하게 웹앱을 시험하고 싶을 때]]></title>
            <link>https://medium.com/@maxzidell/%EA%B0%84%EB%8B%A8%ED%95%98%EA%B2%8C-%EC%9B%B9%EC%95%B1%EC%9D%84-%EC%8B%9C%ED%97%98%ED%95%98%EA%B3%A0-%EC%8B%B6%EC%9D%84-%EB%95%8C-9f20e31ccba4?source=rss-ddef89cb38f6------2</link>
            <guid isPermaLink="false">https://medium.com/p/9f20e31ccba4</guid>
            <category><![CDATA[react]]></category>
            <category><![CDATA[deploy]]></category>
            <category><![CDATA[toyproject]]></category>
            <dc:creator><![CDATA[홍구]]></dc:creator>
            <pubDate>Fri, 12 Oct 2018 13:07:58 GMT</pubDate>
            <atom:updated>2018-10-12T13:10:52.689Z</atom:updated>
            <content:encoded><![CDATA[<h4>React + Github Page</h4><p>예전에 <a href="https://medium.com/@maxzidell/standalone-react-github-page-deploy-a83b43a6b5af">내가 좋아하는 웹에디터를 통해서 간단하게 리액트 페이지를 작성하고 배포하는 것</a>에 관한 포스팅을 한 적이 있다. 저 방법을 이용하면 익숙한 에디터를 통해서 간단하게 테스트하고 배포할 수 있어서 좋았는데, 최근에는 저 방법을 쓰지 않는다. 가장 치명적인 것은 단일 페이지로 빠른 시작은 가능하나 모듈 번들러를 적극 활용할 수 없다는 단점이 있었다.</p><p>최근에는 아래 두가지 방법 중 하나로 진행하는 것을 선호한다.</p><h3>1. creact-react-app + github page</h3><p>터미널에서 creact-react-app my-project 한 번만치면 사용가능하고 HMR까지 되는 리액트 프로젝트가 구동된다. 여기에서 쓰고 싶은 모듈들 다 설치하고 깃헙 페이지에 배포하는 것이 간편하다.</p><ol><li>프로젝트 생성 create-react-app my-project-name</li><li>필요한 모듈 설치 및 코드 작성 yarn add ...</li><li>package.json에 homepage: &quot;.&quot; 를 지정하여 정적파일을 상대경로로 지정(깃헙 페이지내 폴더별로 프로젝트 관리를 위함)</li><li>정적 파일 생성 yarn build</li><li>배포</li></ol><h3>2. codesandbox.io</h3><p>웹상에서 모듈 설치, 번들링 배포 가능한 주소까지 모두 한 번에 완성되므로, 아주 간단한 코드를 테스트하기 좋다. 다만 개인적으로 VS Code를 활용하는데, 이렇게 익숙한 툴을 쓰지 못한다는 것이 단점이다. 그냥 급하고 손하나 까딱하기 싫을 때 이용한다(타이핑은 어떻게 치지;)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9f20e31ccba4" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[멋진글입니다. 한 번 해보아야겠네요.]]></title>
            <link>https://medium.com/@maxzidell/%EB%A9%8B%EC%A7%84%EA%B8%80%EC%9E%85%EB%8B%88%EB%8B%A4-%ED%95%9C-%EB%B2%88-%ED%95%B4%EB%B3%B4%EC%95%84%EC%95%BC%EA%B2%A0%EB%84%A4%EC%9A%94-a94115d6e7d1?source=rss-ddef89cb38f6------2</link>
            <guid isPermaLink="false">https://medium.com/p/a94115d6e7d1</guid>
            <dc:creator><![CDATA[홍구]]></dc:creator>
            <pubDate>Fri, 19 Jan 2018 08:51:17 GMT</pubDate>
            <atom:updated>2018-01-19T08:51:17.673Z</atom:updated>
            <content:encoded><![CDATA[<p>멋진글입니다. 한 번 해보아야겠네요.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a94115d6e7d1" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[반응형을 위한 기준 정리]]></title>
            <link>https://medium.com/@maxzidell/%EB%B0%98%EC%9D%91%ED%98%95-%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8-ux-%ED%8C%81-f91805ad8be8?source=rss-ddef89cb38f6------2</link>
            <guid isPermaLink="false">https://medium.com/p/f91805ad8be8</guid>
            <category><![CDATA[responsive]]></category>
            <category><![CDATA[frontend]]></category>
            <dc:creator><![CDATA[홍구]]></dc:creator>
            <pubDate>Wed, 17 May 2017 09:38:55 GMT</pubDate>
            <atom:updated>2017-05-27T03:32:51.643Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*zSx_rNuvB60FSakJUpGdEw.png" /></figure><p>반응형 개발을 할 때에 일반적으로 스크린의 사이즈를 기반으로 한다. 하지만 실제로 개발을 하다보면 가로폭 사이즈 이외에도 고려해야할 점들이 많이 있다는 것을 깨닫게 된다. 반응형 사이트를 개발하면서 나름대로 사용하는 초보적인 수준의 팁들을 정리해볼까 한다.</p><h3>윈도우 폭</h3><p>반응형 사이트를 만들 때에 그리드디자인은 거의 필연적으로 취하게 된다. 따라서 그리드&amp;반응형 라이브러리를 찾게 되는데, 나는 몇 년 전부터 지금까지 꽂꽂하게 <a href="http://getbootstrap.com">부트스트랩</a>을 고수하고 있다. 다른 라이브러리들도 그렇겠지만 부트스트랩도 기본적으로 폰, 타블렛, 데스크탑을 제공하는데, 여기에서 폰의 범위가 지나치게 넓다. 따라서 한 손안에 쥐어지는 일반적인 폰의 크기를 위해서 eXtra eXtra Small 사이즈(480px)를 별도로 만드는 것이 좋다.</p><pre>.col-xxs-1,.col-xxs-10,.col-xxs-11,.col-xxs-12,.col-xxs-2,.col-xxs-3,.col-xxs-4,.col-xxs-5,.col-xxs-6,.col-xxs-7,.col-xxs-8,.col-xxs-9{min-height:1px;padding-left:15px;padding-right:15px;position:relative}.visible-xxs,.visible-xxs-block,.visible-xxs-inline,.visible-xxs-inline-block{display:none!important}@media (max-width:480px){.col-xxs-1,.col-xxs-10,.col-xxs-11,.col-xxs-2,.col-xxs-3,.col-xxs-4,.col-xxs-5,.col-xxs-6,.col-xxs-7,.col-xxs-8,.col-xxs-9{float:left}.col-xxs-1{width:8.333333333333332%}.col-xxs-2{width:16.666666666666664%}.col-xxs-3{width:25%}.col-xxs-4{width:33.33333333333333%}.col-xxs-5{width:41.66666666666667%}.col-xxs-6{width:50%}.col-xxs-7{width:58.333333333333336%}.col-xxs-8{width:66.66666666666666%}.col-xxs-9{width:75%}.col-xxs-10{width:83.33333333333334%}.col-xxs-11{width:91.66666666666666%}.col-xxs-12{width:100%}.col-xxs-push-1{left:8.333333333333332%}.col-xxs-push-2{left:16.666666666666664%}.col-xxs-push-3{left:25%}.col-xss-push-4{left:33.33333333333333%}.col-xxs-push-5{left:41.66666666666667%}.col-xxs-push-6{left:50%}.col-xxs-push-7{left:58.333333333333336%}.col-xxs-push-8{left:66.66666666666666%}.col-xxs-push-9{left:75%}.col-xxs-push-10{left:83.33333333333334%}.col-xxs-push-11{left:91.66666666666666%}.col-xxs-pull-1{right:8.333333333333332%}.col-xxs-pull-2{right:16.666666666666664%}.col-xxs-pull-3{right:25%}.col-xxs-pull-4{right:33.33333333333333%}.col-xxs-pull-5{right:41.66666666666667%}.col-xxs-pull-6{right:50%}.col-xxs-pull-7{right:58.333333333333336%}.col-xxs-pull-8{right:66.66666666666666%}.col-xxs-pull-9{right:75%}.col-xxs-pull-10{right:83.33333333333334%}.col-xxs-pull-11{right:91.66666666666666%}.col-xxs-offset-1{margin-left:8.333333333333332%}.col-xxs-offset-2{margin-left:16.666666666666664%}.col-xxs-offset-3{margin-left:25%}.col-xxs-offset-4{margin-left:33.33333333333333%}.col-xxs-offset-5{margin-left:41.66666666666667%}.col-xxs-offset-6{margin-left:50%}.col-xxs-offset-7{margin-left:58.333333333333336%}.col-xxs-offset-8{margin-left:66.66666666666666%}.col-xxs-offset-9{margin-left:75%}.col-xxs-offset-10{margin-left:83.33333333333334%}.col-xxs-offset-11{margin-left:91.66666666666666%}.visible-xxs{display:block!important}table.visible-xxs{display:table}tr.visible-xxs{display:table-row!important}td.visible-xxs,th.visible-xxs{display:table-cell!important}.visible-xxs-block{display:block!important}.visible-xxs-inline{display:inline!important}.visible-xxs-inline-block{display:inline-block!important}.hidden-xxs{display:none!important}}</pre><h3>윈도우 비율</h3><p>반응형에서 보통 높이값은 중요하지 않게 취급된다. 그리고 정말 그렇다. 왜냐하면 세로로는 컨텐츠가 길어지는 경우 자연스럽게 스크롤되는 영역으로 인식이 되고 스크롤은 터치디바이스에서 너무 자연스럽기 때문이다.</p><p>다만 윈도우의 폭과 높이의 비율은 나름 유용하게 사용될 때가 있다. 이를테면 웹앱의 형태로 하단에 탭바를 넣는 경우를 생각해 볼 수 있다. 문제는 폭을 기준으로만 해서 탭바를 넣으면, 가상키보드가 활성화 되었을 때 그 좁은 화면에도 계속 탭바가 유지되게 된다. 이럴 때 화면의 비율에 따라서 탭바가 나올 수 있는 상황을 제어할 수 있다.</p><pre><a href="http://twitter.com/media">@media</a> screen and (max-aspect-ratio: 1/1) {<br>  /* 높이가 폭보다 더 길때에만 해당된다. */<br>}</pre><h3>터치기준</h3><p>기본적으로 모바일은 터치기반, 데스크탑은 논터치(클릭) 기반으로 볼 수 있다. 하지만 MS서피스나 아이패드3처럼 큰스크린의 타블렛이 나오기 시작하면서 터치나 클릭만으로 모바일과 논터치를 구분하기는 힘들어졌다. 따라서 가로폭과 함께 터치기반의 여부도 반응형 웹사이트를 개발할 때 중요한 이슈가 되었다고 생각한다.</p><p>이것에 따라 굳이 최적화를 하지 않아도 큰 사용성에는 문제가 생기지 않는다. 하지만 웹앱의 형태같이 UI가 조금더 최적화 되기 시작하면 애매한 부분들이 생긴다. 이를테면 전통적인 웹에서는 마우스가 올라가 있느냐에 따라(mouseover, :hover) 동작되는 것들이 있었는데, 터치기반에서는 작동되지 않는다.</p><p>기능이 동작되지 않는 최악의 상황을 막기 위해서는 mousehover나 :hover등을 아예 사용하지 않고 무조건 클릭(탭) 기반으로 작동되도록 하면 될 것이다. 하지만 마우스는 데스크탑 기반에서는 엄청 유용하기 때문에, 모바일을 위해 지나치게 데스크탑을 희생할 필요는 없다. 단지 그에 따라 최적화를 하면 된다.</p><p><a href="https://modernizr.com/">Modernizer</a> 등의 툴을 이용하면 디바이스가 터치를 지원하는지 안하는지에 따라서 최상위 태그&lt;html&gt; 에 .touch 혹은 .no-touch 클래스를 붙여준다. CSS를 설계할 때에 이 최상위 클래스 여부에 따라 최적화를 진행할 수 있다.</p><pre>html.touch {<br>  ...<br>}<br>html.no-touch {<br>  ...<br>}</pre><p>가장 손쉽게 떠올릴 수 있는 예로 Bootstrap의 dropdown-menu 가 있을 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/190/1*YiUvCcVYheU1ypSsSI3VQg.png" /><figcaption>이렇게 생긴 요소입니다.</figcaption></figure><p>기본적으로 아래쪽 화살표가 있는 버튼을 누르면, 하위 메뉴가 나타난다. 모바일에서는 탭하여 하위 메뉴를 열기 때문에 그다지 불편하지 않다. 하지만 마우스 기반에서 이런 경우 수정하려는 컴포넌트에 마우스를 올리는 것만으로 우측 상단에 수정/삭제 등의 버튼이 나타나는 경우가 많다. 마우스를 위하여 아래와 같이 최적화 코드를 추가해줄 수 있다.</p><pre><br>html.no-touch .dropdown:hover .dropdown-menu {<br>  top: 0;<br>  display: block;<br>  margin-top: 0;<br>}</pre><p>또 다른 예로 버튼이나 리스팅의 기본 높이를 다르게 할 수 있다. 마우스 기반의 데스크탑은 일반적으로 포인팅이 정교하기 때문에 폭이 다소 좁아도 허용이 된다. 하지만 터치 기반의 폰에서는 마우스 기반보다는 폭을 조금 더 넉넉하게 잡아주여야할 필요성이 있다.</p><pre>a.btn, a.list-group-item {<br>  padding: 8px 12px;<br>}<br>html.no-touch a.btn, html.no-touch a.list-group-item {<br>  padding: 12px 12px;<br>}</pre><h3>디바이스 넓이</h3><p>반응형으로 했을 때 화면의 사이즈에 따라 CSS를 설정하는 것은 단순하다. 하지만 특정 요소에 이벤트를 걸어주는 경우, 반응형은 다소 골치가 아프다. 이를테면 폰사이즈에서는 버튼이 눌렸을 때 A라는 메서드를 실행하도록 하려고 하는데, 사이즈의 변화에 따라서 이미 바인딩한 이벤트를 넣었다 뺐다가 하는 것은 큰 비용같이 느껴진다. 이런 경우 메서드 자체가 실행되는 것은 당연히 처리하고, 그 코드 내에서 화면의 사이즈를 인식하여 폰이 아닌 경우에는 return false 처리를 할 수도 있다. 그런데 이런식으로 다양한 사이즈/디바이스에 대응하는 이벤트가 모두 바인딩되어 있다면 엄청난 낭비가 된다.</p><p>이런 경우 디바이스의 불변하는 스크린사이즈를 고려하여 리사이징이 되더라도 애초에 이 디바이스가 폰크기인지, 데스크탑 크기인지 인지를 할 수 있도록하면 될 것이다. window 객체에 있는 window.screen.width 와 window.screen.height 를 이용하면 디바이스의 본래 크기 자체를 얻어낼 수 있다. 여기에 한 발 더 나아가서 모바일에서 자주 변경되는 portrait 혹은 landscape 의 변화를 막기 위해서 면적을 기준으로 하는 것이 좋다.</p><pre>const isPhone = window.screen.width * window.screen.height &lt; 500000;</pre><p>50,000이라는 숫자는 제가 경험적으로 인식하는 일반적인 폰사이즈로 상황에 따라 다를 수 있다. 위와 같이 면적기반으로 폰 여부를 결정하고, 그 결과값에 따라 이벤트 바인딩을 결정하면 화면 사이즈 변경에 따른 불필요한 이벤트 바인딩을 막을 수 있을 것이다.</p><pre>html.is-phone {<br>  ...<br>}</pre><h3>디바이스 종류</h3><p>보다 더 세부적으로 경험을 설계하기 위해서는, 각 디바이스별로 아예 다른 변수들을 부여하면 된다. 이게 중요한 이유는 아이폰계와 안드로이드계가 모바일에서 다른 경험들을 제공하고 있기 때문이다(구현에 앞서 모바일웹상에서 네이티브 경험을 복원하는 것이 과연 옳은 것이가에 대해서도 고민을 해볼 필요는 있다).</p><p>가장 쉽게 생각해 볼 수 있는 것은, 안드로이드에서는 좌측 엣지 스와이프를 위해서 메인 네비게이션을 호출하는 것이 일반적이다. 이 습관은 너무 강력해서 웹상에서도 좌측네비게이션을 버거메뉴로 감춘 경우 습관적으로 스와이프를 하게 된다. 이 경우 안드로이드에 한정해서 엣지 스와이프 이벤트를 걸어주면 어색함은 누그러질 수 있다.</p><pre>const isAndroid = /android/i.test(navigator.userAgent);<br>const isIos = /ipad|iphone|ipod/i.test(navigator.userAgent);</pre><p>그리고 이러한 변수를 &lt;html&gt;에 클래스로 걸어주어 CSS에서도 활용할 수 있다.</p><pre>html.is-android {<br>  ...<br>}<br>html.is-ios {<br>  ...<br>}</pre><h3>Overriding</h3><p>일반적인 모바일퍼스트로 작업을 진행한다면, 윈도우폭이 커질수록 셀렉트를 재지정하여 속성을 override 하여 적용할 것이다. 혹은 그 외에도 어쨌든 기본 속성들에다가 상황에 따른 속성을 override 해야할 것이다.</p><p>하지만 개발을 계속 하다보면 생각보다 마크업 구조가 복잡해져서, 이맘때쯤이면 !important 를 이용하여 뗌빵을하게 된다(혹은 그러고 싶어진다). 하지만 !important 는 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity">너무 강력하게 우선순위를 조절해버리기 때문</a>에, 조금 더 부드러운 방법으로 셀렉터 앞에 body 를 붙여주어서 조정하는 것이 좋다. 이 방법이 좋은 이유는 한 번 더 우선순위를 붙여줄 때 html 까지 붙여줄 수도 있다.</p><p>본문에서 각각의 상황에 따라 html.is-phone 과 같이 최상위 태그에 클래스를 부여한 이유는 자연스럽게 override 에 대한 우선순위도 조정하게 되는 효과가 있기 때문이다.</p><h3>마무리</h3><p>실질적으로 하나의 웹앱(사이트)를 진행하는 경우에 윈도우 폭 이외에도 위의 구분들이 적용하고 있:다. 웹을 이용하는 디바이스 환경이 다양해짐에 따라 단순히 윈도우의 폭만으로 반응형 화면 설계를 하는 시기는 지난 듯이 보인다. 이러한 단순한 경우들을 조금만 신경쓰면 사용자의 경험은 훨씬 쾌적해질 것이라 생각한다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f91805ad8be8" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Standalone React + Github page deploy]]></title>
            <link>https://medium.com/@maxzidell/standalone-react-github-page-deploy-a83b43a6b5af?source=rss-ddef89cb38f6------2</link>
            <guid isPermaLink="false">https://medium.com/p/a83b43a6b5af</guid>
            <category><![CDATA[github-pages]]></category>
            <category><![CDATA[github]]></category>
            <category><![CDATA[toyproject]]></category>
            <dc:creator><![CDATA[홍구]]></dc:creator>
            <pubDate>Tue, 20 Dec 2016 16:38:29 GMT</pubDate>
            <atom:updated>2018-10-12T13:14:09.274Z</atom:updated>
            <content:encoded><![CDATA[<h4>혼자 갑작스러운 아이디어가 떠올랐을 때 바로 코드부터 시작해보고 싶을 때가 있다. 그럴 때를 위해 미리 준비해두면 좋다.</h4><blockquote>저는 이 방법을 더 이상 활용하지 않습니다. 새로운 방법은 <a href="https://medium.com/p/9f20e31ccba4">https://medium.com/p/9f20e31ccba4</a> 여기에 게시되어 있습니다.</blockquote><p>멍때리다가 보면 가끔 간단한 웹페이지를 만들고 싶을 때가 있다. 최근에는 프론트엔드 기술이 워낙 발달해서, 데이터 저장이 큰 의미가 없다면 순전히 HTML+CSS+JS 기술만으로도 그럭저럭 동작하는 프로토타입을 만들 수 있다. 이를테면 가위바위보나 사다리타기 게임, 혹은 직장 동료 놀리기 같은 것들이 괜히 만들고 싶어질 때가 있다.</p><p>요즘엔 툴바없이 output 페이지만 랜더링을 해주는 여러 online code editor 들(jsfiddle, codepen)이 있고 쉽게 시작할 수 있지만, 막상 스크립트를 막 작성하다보면 평소에 로컬에서 쓰던 IDE나 Sublime Text 등에 비해 편의기능들이 너무 구리고, 브라우저의 한계상 속도나 다른 탭과의 혼돈 등으로 인해서 코드가 빨리 작성되지가 않는다. 게다가 이미지 등의 추가 요소들을 연결하기가 엄청 까다롭거나 되지 않는다.</p><p>내가 원했던 조건은 많지는 않고 대략 아래와 같았다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*ptQ4uJzLYyv-m5cNVS-BHQ.png" /><figcaption>나의 바람…</figcaption></figure><ul><li>평소에 로컬에서 코딩하던 에디터들을 그대로 쓸 수 있고,</li><li>이미지나 다수의 리소스(js, css) 등을 분할해서 사용할 수 있고,</li><li>배포가 쉬워서 즉시 지인들에게 공유해서 사용하게 할 수 있어야 하고,</li><li>기왕이면 es6, scss 등의 편리한 기술들도 쓸 수 있고,</li><li>로컬에서 다수의 프로젝트를 관리할 때 귀찮은 작업이 없고,</li><li>프로젝트별 로컬 서버를 띄우거나하는 사전작업도 없고,</li><li>걸프나 웹팩 등 번들링 명령도 필요 없고,</li><li>무료로 할 수 있는 방법</li></ul><p>꼼수를 많이 굴린 결과 ‘<strong>본인의 에디터+크롬+Github Page</strong>’를 이용하는 방법이 가장 무난하다고 결론을 내렸다. 데헷!</p><h3>크롬 세팅</h3><p>폴더에 index.html 달랑 만들어놓고 크롬으로 불러들이면 잘 열린다. 그런데 같은 폴더에 base.js 등 리소스를 분리하고 호출하면 보안 문제상 거절이 된다.</p><p>물론 파이썬이나 php나 node로 localhost:8888 등을 띄우는 방법도 있는데,토이프로젝트 하나 만드는데 이것도 굉장히 귀찮다. 이럴려면 터미널로 들어가서 해당 폴더로 가야하고, 여러 토이프로젝트를 돌리기 위해서 토이프로젝트만큼 서버를 돌리든가 셋팅하든가 귀찮은 일들이 생긴다. 그러지 말고 크롬을 실행할 때 아래의 명령어로 실행하면 된다. 길고 외우기 어려우니까 애플 스크립트로 만들어놓고 실행시키면 된다. 자, 이렇게 했으면 이제 그냥 무식하게 file://... 로 열어도 상대경로로 정적 리소스들을 마음껏 불러올 수 있다.</p><pre>open /Applications/Google\ Chrome.app — args — allow-file-access-from-files</pre><p>윈도우에서는 아래와 같이 하면 된다고 한다. 윈도우를 써본지 오래되어서 기억은 잘 안나지만 단축 아이콘의 등록정보에 가면 실행시 옵션을 지정해 줄 수 있는 것으로 기억한다.</p><pre>&quot;C:\PathTo\Chrome.exe&quot; --allow-file-access-from-files</pre><h3>Github Page</h3><p><a href="https://pages.github.com/">깃헙페이지</a>를 이용하면 공개된 저장소에 올려놓은 Static Assets 들을 웹서버처럼 바로 엑세스할 수 있도록 해준다. 여러 토이 프로젝트들을 담고 있는 폴더를 깃헙페이지용 저장소로 만들어 두면, 수정사항 생길때마다 push 하여 배포할 수 있게 되는 것이다.</p><p>여러개의 토이 프로젝트를 서브 폴더로 두게되는 셈이지만 어차피 각 폴더별로 뭐 있는 것도 없고, 이거 만들고 셋팅하는 것도 일이니 다 구겨 넣는게 오히려 더 좋은 것 같다.</p><h3>토이프로젝트 시작</h3><p>최적화 이런거 신경쓰지말고, 일단 코드 치자마자 바로 동작할 수 있도록 index.html 을 만들어두었다. 걸프나 웹팩 이런거 없이 react.js + es6 + sass(scss) 가 런타임상에서 동작할 수 있도록 CDN 들을 연결해두었다. 아래 소스를 참고하여 토이프로젝트 저장소에 두고, commit &amp; push 하면 <a href="https://%7Bmyname%7D.github.io/%7Bfolder">https://{yourName}.github.io/{folder</a>Name} 으로 항상 공개되는 식이다. 이런식으로 마구마구 쓰잘데기 없는 토이 프로젝트들을 만들어보자.</p><h3>DB가 필요한 경우라면?</h3><p>일단 깃헙페이지를 통해서 공개하는 프로젝트들이므로 보안이 중요하거나 진지한 프로젝트는 아닐 것이다. 하지만 웹페이지를 껐다켜도 무언가 남아있어야한다면 내가 예전에 만들어놓은 또 다른 쓰잘데기 없는 프로젝트인 <a href="https://opendb.gitools.net">https://opendb.gitools.net</a>을 사용해보는 것도 좋다. 이 사이트는 인증 이런거 없이 그냥 아무도 안 쓸것 같은 board 값 지정해서 저장하고 불러오면 되는 사이트이다. jQuery 기준으로 소스도 생성되므로 쓰기 쉽다. 물론 자료가 날아가는 것에 대해서는 책임지지 않는다.</p><blockquote>저는 이 방법을 더 이상 활용하지 않습니다. 새로운 방법은 <a href="https://medium.com/p/9f20e31ccba4">https://medium.com/p/9f20e31ccba4</a> 여기에 게시되어 있습니다.</blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a83b43a6b5af" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Codeigniter deploy with forge & git push]]></title>
            <link>https://medium.com/@maxzidell/codeigniter-deploy-with-forge-git-push-ee0343489c2?source=rss-ddef89cb38f6------2</link>
            <guid isPermaLink="false">https://medium.com/p/ee0343489c2</guid>
            <category><![CDATA[codeigniter]]></category>
            <category><![CDATA[php]]></category>
            <category><![CDATA[deploy]]></category>
            <dc:creator><![CDATA[홍구]]></dc:creator>
            <pubDate>Sun, 18 Dec 2016 05:13:54 GMT</pubDate>
            <atom:updated>2016-12-19T08:40:52.195Z</atom:updated>
            <content:encoded><![CDATA[<h4>PHP 프로젝트를 위한 깔끔한 배포 방법이 생겼다! 라라벨팀에서 제공하는 forge.laravel.com이다!</h4><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FELRLUi76u70%3Ffeature%3Doembed&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DELRLUi76u70&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FELRLUi76u70%2Fhqdefault.jpg&amp;key=d04bfffea46d4aeda930ec88cc64b87c&amp;type=text%2Fhtml&amp;schema=youtube" width="640" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/b31dd21a209987d3f5c20e8dd3667869/href">https://medium.com/media/b31dd21a209987d3f5c20e8dd3667869/href</a></iframe><p>라라벨도 좋은 툴이지만, 처음 접했던 프레임웍이 코드이그나이터라서 그런지, 아직까지 많은 프로젝트를 코드이그나이터로 다루고 있다. 기존의 방법은 PHP에서 쉘스크립트 명령어를 써서, webhook과 git clone 명령어를 조합해서 하기에 먼가 굉장히 야매(?)의 냄새가 강하다.</p><p>forge는 라라벨이라는 최근 뜨고 있는(사실 뜬지 한참된) PHP 프레임웍을 개발한 팀에서 하는 배포서비스이다. 간단하게 소개하면 github과 연동하여 푸쉬가 일어났을 때 지정된 서버에서 clone 받는 동시에 npm, composer 등 몇 가지 작업을 자동으로 할 수 있고, 서버 설정 및 관리를 웹에서 할 수 있게 해주는 툴이다.</p><p>하여 코드이그나이터 프로젝트를 forge.laravel.com을 이용하여 배포해보기로 한다. 라라벨팀에서 만들었지만 CakePHP나 Symphony등 그냥 PHP 프로젝트는 다 되는 것 같다(관대한 라라벨). 월 만 얼마를 내면 무한대의 PHP 프로젝트 등록과 관리가 가능하다(라라벨은 망해도 forge는 안 망했으면 좋겠다).</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*O25KRGBO5JjhoCq1rvkxvg.png" /><figcaption>위풍당당한 forge 랜딩페이지. 맞아. PHP 서버 돌릴려면 설정할 것도 많고 짜증나지! 출처 : forge.laravel.com</figcaption></figure><h3>CI3 저장소 생성</h3><p>먼저 CI3를 로컬에 셋팅을 해보자. 다른건 건드릴 필요가 없고, www 폴더 생성후에 root의 index.php 를 www 에 옮겨주고, 해당 파일내의 application 과 system 경로에 ../ 만 붙여줘서 상대경로를 바로잡아주면 된다. public 폴더에 어플리케이션 코드를 넣는 것은 좋지 않으므로 기본적인 작업을 해주는 것이고, 또 forge에서도 public 폴더를 별도로 지정해줘야하기 때문이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/621/1*1FNbMMztJjdbwzckDvvNlw.png" /><figcaption>www폴더를 만들었고 index.php를 옮겨주었다. forge에서는 이 www만 접근 가능하도록 설정할 것이다.</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*OZ25dh9ZDKiRJRu7sa-Rfw.png" /><figcaption>반가운 CI3의 웰컴화면, 나중에 원격에서 이 화면이 뜨면 더욱 반가울 것이다.</figcaption></figure><p>그리고 private 저장소 생성이 가능한 bitbucket.com 에서 저장소를 생성하고, 이 소스들을 올려두도록 한다. 향후에 push를 할 때마다 forge에서 자동으로 새로 배포할 수 있으려면 원격 저장소가 있어야한다. 저장소 만드는 방법은 구글에 엄청 많으니 생략한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/985/1*cAqc-SoCwzIz6M9HU9PhMg.png" /><figcaption>만들어진 원격저장소, 이따가 forge랑 이거랑 연결할 것이다.</figcaption></figure><h3>AWS EC2 인스턴스 생성</h3><p>forge는 배포를 위한 툴이고 직접 스토리지 서비스를 운영하지는 않는다(난 그래서 더 좋다). 전세계 리전이 깔려있는 아마존 EC2를 이용해서 작업을 진행하면 된다. EC2+Forge에 관한 자세한 방법들은 <a href="https://mattstauffer.co/blog/laravel-forge-hosting-on-aws">Laravel Forge — Hosting on AWS</a>을 참고하면 된다. 인스턴스 생성에 관한 방법도 구글에 엄청 많이 있으니 자세한 것은 생략한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Mv2UTNicn-O96PGxo01fzg.png" /><figcaption>인스턴스 생성하기로 간 다음에 Ubuntu 16.04 LTS 버전을 선택한다.</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*DkVlZnAKNbTeoBR6rCu74A.png" /><figcaption>일단 기본 설정, 그리고 기본 설정, 그리고 기본 Serucity Group(All Traffics)로 생성이 완료되었다.</figcaption></figure><p>생성이 완료되었으면 좌측 사이드바에서 Elastic IP를 하나 할당해주자. forge에서는 IP기반으로 작업을 진행하기에 고정아이피를 하나 설정해주어야 한다.</p><h3>Forge 서버 생성과 연결</h3><p>정확히 말하면 서버 생성이라기보다 관리상 있는 개념에 가깝다. 특정 서버를 관리하는 레코드를 하나 생성하겠다는 말 같은 것이다. 알아볼 수 있게 이름을 지정두고 생성한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*BmsvfgVPeAxwy_OlVxuz3g.png" /><figcaption>서버 생성화면. PHP Version은 7.0으로해도 상관없을 것 같긴하지만, CI3가 그 버전에 최적화되어 있지는 않으니 안정적으로 5.6을 선택해본다.</figcaption></figure><p>Create Server를 누르면 스크립트를 내보낸다. SSH로 EC2에 로그인해서 실행하는 스크립트인데, php, hhvm, (선택한 경우) DB서버까지 다 알아서 설치를 해주는 스크립트이다. 그리고 웹상에서 forge에 명령을 내리면 그것을 받아다가 실행하고 상태보고를 해주는 에이전트도 깔아준다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*fR8kzowrWE-02t5ZNUueSA.png" /></figure><p>쉘스크립트 실행은 관리자 권한으로 하여야하므로 위 스크립트를 EC2 터미널에서 바로 복붙하지말고, bash forge.sh 앞에 sudo 를 붙여주고 실행하면 된다.</p><pre>wget -O forge.sh https://forge.laravel.com/servers/111156/vps?forge_token=ZHj6a9aICcx6...yP3rasUz016g; <strong>sudo</strong> bash forge.sh</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Hlsq40HFqBUAeZ6hCCjqtg.png" /><figcaption>대략 5분~10분 정도 지가 알아서 다운로드 &amp; 설치 &amp; 설정이 이루어진다.</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*RqzJAu-sPiDgjOahdhYNWw.png" /><figcaption>forge에서 해당 서버를 선택하면 이렇게 대기상태로 나오고 있다.</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*R3SBPYty6PkzY-7z3TTcYA.png" /><figcaption>가만히 기다리고 있으면, 연결이 완료되고 하위로 사이트를 생성할 수 있는 화면으로 전환된다. 거의 다 왔다!</figcaption></figure><h3>Bitbucket 연결</h3><p>forge에서 서버가 생성되면 기본적으로 default 라는 사이트가 하나 추가되어 있는데, 이를 수정해도 되고 무시하고 새로 생성해도 된다. SSL 연결을 고려하는 경우에는 실제 domain으로 사이트를 하나 추가해주는 것이 좋을 것이다. 여기에서는 그냥 default 를 바로 이용해보자. 하단 목록에서 manage 를 눌러도 되고 상단 네비에서 Sites 에서 선택을 해도 된다.</p><p>Apps탭에서 Git Repository를 선택하면 아래와 같이 접근할 수 있는 SSH Keys를 해당 사이트에서 먼저 등록하라고 나온다. github의 경우에는 자동으로 연동되어 있지만 bitbucket은 수동으로 해주어야한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*oHNd9rXfid2Nw3rGSzdAqw.png" /><figcaption>bitbucket 계정페이지에서 추가하여야할 SSH key.</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*0IMTnAIrYmR81ldzrRs2wQ.png" /><figcaption>계정페이지로 가서 SSH Keys 탭을 열고 Label은 대충 써주고, Key에 붙여넣어주면 된다.</figcaption></figure><p>다시 forge로 돌아와서 원격 저장소에 대한 정보들을 입력해주고 마무리를 한다. 서버상에서 composer를 돌리려는 경우에는 install Composer Dependencies 를 체크해주면 되는데, 나같은 경우에는 로컬에서 다 설치하고 넘길 것이라 해체를 했다. 체크한 경우 프로젝트 루트에 composer.json 이 없는 경우 에러가 난다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*sGxcZknMfgnA-PHpxSSzew.png" /><figcaption>원격저장소 연결 마무리 작업</figcaption></figure><p>Install Repository를 누르면 작업중 상태로 되고, 완료가 되면 아래와 같은 화면이 나온다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*snc6ZDTJougLgFink1sq9g.png" /><figcaption>나중에 저기에서 Deploy Now만 누르면 원격저장소의 소스가 배포된다.</figcaption></figure><p>여기까지하면 Deploy Now 를 눌렀을 때 bitbucket에서 가져와서 서버에 업데이트하는 것까지는 되지만, 저장소 업데이트가 되었을 때 자동으로 Deploy Now 가 되지는 않는다. webhook을 이용해서 업뎃과 동시에 저 버튼이 눌려지도록 하나 더 설정한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/933/1*Lg3v-E2CEFyH5V-r0LaxvA.png" /><figcaption>사이트 Apps탭에서 webhook용 토큰주소가 제공되어 있다.</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*QPdW1cyYOSnSRCh3ZTDiFg.png" /><figcaption>다시;; bitbucket으로 가서 webhook 설청해준다. 복사시 토큰 이외에 잡문자가 섞이므로 유의해서 붙여넣자.</figcaption></figure><p>이제 전체적인 연결은 모두 끝이났다.</p><p>실 서버에 접속하기 전에… 현재의 이 사이트 설정은 forge 서버생성시 자동으로 생성된 것이라 public 폴더가 /public 으로 되어 있다. 아까 CI3 생성시 www 로 했으므로 /www 로 변경을 해주어야 제대로 뜬다(처음부터 /public 으로 할 껄 그랬나;;)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*3v7rZPHOBB_97MgRyRF65w.png" /><figcaption>바꺼준다.</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ZmBhNFXC8am4FK3T_L2BPg.png" /><figcaption>뜬다. 끝난 것 같다.</figcaption></figure><h3>Envoyer와의 관계</h3><p>forge는 직접적인 서버관리와 배포를 관리한다면, 형제인 envoyer는 무중단 배포와 상태 모니터링에 무게를 둔 서비스다. 라라벨의 경우에 모든 템플릿을 캐싱하므로 forge만을 이용하는 경우 순간적으로 사이트 오류가 발생할 수 있지만, 코드이그나이터는 템플릿 따로 안 써서 forge만으로 거의 무중단에 가깝게 배포가 가능하다. 물론 그러기 위해서는 npm bundling이나 composer install를 서버가 아닌 개발서버측에서 미리 다 github쪽으로 보내두도록 해놔야한다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ee0343489c2" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[방문기록의 시각적 구분을 위한 localStorage]]></title>
            <link>https://medium.com/@maxzidell/%EB%B0%A9%EB%AC%B8%EA%B8%B0%EB%A1%9D%EC%9D%98-%EC%8B%9C%EA%B0%81%EC%A0%81-%ED%91%9C%ED%98%84%EC%9D%84-%EC%9C%84%ED%95%9C-localstorage-84efbc2db16a?source=rss-ddef89cb38f6------2</link>
            <guid isPermaLink="false">https://medium.com/p/84efbc2db16a</guid>
            <category><![CDATA[localstorage]]></category>
            <category><![CDATA[ux]]></category>
            <category><![CDATA[ui]]></category>
            <category><![CDATA[anchor]]></category>
            <dc:creator><![CDATA[홍구]]></dc:creator>
            <pubDate>Sun, 18 Dec 2016 02:07:02 GMT</pubDate>
            <atom:updated>2016-12-21T01:56:03.395Z</atom:updated>
            <content:encoded><![CDATA[<h4>예전에는 시각적으로 표현되었던 ‘방문했던 페이지&#39;가 이제는 우리의 뇌에 의존하여 골라내야한다.</h4><p>인터넷에서의 전통적으로 페이지 이동의 역할을 해주는 태그는 a 라는 앵커태그가 있다. 그리고 이 앵커태그는 아무런 스타일링을 하지 않으면 파란색으로 보여지고, 한 번 방문했던 기록이 있으면 보라색으로 표시를 해준다. 시각적으로는 엄청 올드해보이지만 어차피 내꺼도 아닌 사이트에서 대충 이용하기에는 엄청나게 편리하다. 내가 무엇을 봤고 안 봤는지 머리를 잠깐 빌리지 않아도 그냥 보면 알 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*FaHWGQNiuw59weO_WfIDHg.png" /><figcaption>올드한 모습 그대로 사용성만 증진되고 있는 크레이그리스트 <a href="https://sfbay.craigslist.org/search/roo">https://sfbay.craigslist.org/search/roo</a></figcaption></figure><p>색깔을 조금 바꾸어주는 것도 쉽다. 단지 css 에서 a:link 와 a:visited 라는 가상의 셀렉터에 color 속성만 바꾸어주면 된다.</p><pre>a:link {<br>  color : black;<br>}<br>a:visited {<br>  color : gray;<br>}</pre><p>그런데 왜 이런 기똥찬 기능을 최근의 웹디자이너들은 활용하지 않게 되었는가?(여기 미디엄 사이트도 안 되어 있다. 의외로 네이버는 되어 있다)조사 같은걸 하지 않았으니 자세히는 모르겠고 그냥 내 생각으로는 이렇다.</p><ul><li>한 요소를 두 가지 색상으로 구현하는게 까다롭고 귀찮다. 게다가 사용자마다 방문 여부에 따라 달라지므로 어떻게 보여질지 예측하기도 쉽지 않다.</li><li>사실 이게 정확하지가 않다. 즉, 페이징이 있는 리스트의 경우에는 같은 페이지로 이동을 하더라도 페이징이나 검색어에 관한 정보들을 같이 GET 파라미터로 넘겨주는 경우가 있는데, 이 정보가 미세하게 달라도 같은 페이지를 방문했어도 방문을 안했다고 나오는 경우가 많다(예를들면 domain.com/id와 domain.com/id?page=1은 다르게 취급된다). 만약 이 색을 정상적으로 표시할 수 있도록 URI 스키마를 짜려고하는 경우 이러한 부수정보를 전달하기 위하여 추가 작업들을 많이 해주어야 한다.</li><li>SPA가 유행하면서 전통적으로 a 태그를 이용한 Full Page Redirecting의 경우가 현저하게 줄었다. 버튼들이 페이지 이동의 링크라기보다 특정 이벤트를 발생시키는 UI 요소로써 기능하게 되었다(실제로 a[href] 를 안 쓰는 경우도 많다).</li><li>놀랍게도 아무도 신경쓰지 않는다. 즉, 의뢰한 클라이언트도, 이용하는 이용자들도.. 왜 색상이구분되지 않느냐고 따지는 사람이 없는데, 굳이 이것저것 고려해서 보강할 이유가 없는 것처럼 느껴진다.</li></ul><p>어쨌든 요즘 웹에서는 방문했던 페이지의 표식이 변경되는 경우는 찾기가 힘들어졌다고 봐도 무방할 것이다. 오히려 어디에선가 방문했던 페이지의 색이 무언가 좀 달라지면 더 어색할 수도 있을 법도 하다.</p><p>하지만 조금이라도 사용자 편의성을 고려하여야한다면, 우리는 요소가 a 가 아니더라도, 파라미터로 인해서 같은 페이지의 주소가 여러개일지라도, SPA 라서 고유주소가 없다 하더라도 어떻게든 이 표식을 넣어보려고 시도해볼 수 있다.</p><p>구현을 위해서 생각해낸 방법은 간단하다. localStorage 라고 요즘 웬만한 브라우저에서는 다 지원하는 HTML5의 스펙이 있는데, 이것을 이용해 저장하면 딱 현재의 브라우저에서만 작동되고 철저하게 클라이언트에서 작동되는 것이므로 방문기록을 기억하기에는 아주 적합한 스펙이라 할 수 있다.</p><p>사용자의 페이지 이동 액션이 일어나는 순간에 해당 페이지의 고유번호(이를테면 bbs_id 등)를 localStorage 에 기록하고, 해당 페이지의 버튼을 출력하는 페이지에서는 이 localStorage 의 값을 읽어와서 방문 여부를 체크해서 표식이 다른 클래스를 부여해주는 것이다.</p><p>당연히 이렇게 방문기록을 하여야할 페이지(UI뷰)가 여러개일 것이므로 우리는 일종의 스택으로 관리를 하여야한다. 당연히 가장 최근에 방문했던 기록들이 더 중요할 것이므로, 최대 100개 정도를 기억하도록하고 오래전에 기록되었던 고유번호는 밀려나도록 하는 First In First Out(발음이 귀여운 피포)의 자료구조형으로 하면 될 것이다.</p><p>아래는 간단한 스크립트의 예시이다. 값이 없는 경우 등의 예외처리가 빠져있어서 바로쓸 수는 없지만 간단하게 동작을 이해할 수 있다.</p><pre>// 페이지(UI뷰)의 이동이 발생했을 때<br>var visitedArray = localStorage.getItem(&#39;bbs_visited&#39;).split(&#39;,&#39;);<br>if(visitedArray.indexOf(bbs_id.toString()) === -1){<br>  visitedArray.push(bbs_id);<br>}<br>if(visitedArray.length &gt; 100){<br>  visitedArray.shift();<br>}<br>localStorage.setItem(&#39;bbs_visited&#39;, visitedArray.join(&#39;,&#39;));<br></pre><pre>// 페이지리스트를 보여줄 때<br>var visitedArray = localStorage.getItem(&#39;bbs_visited&#39;).split(&#39;,&#39;);<br>var isVisited;<br>...loop start<br>  isVisited = visitedArray.indexOf(bbs_id.toString()) &gt; -1 ? &#39;y&#39; : &#39;n&#39;;<br>  return &#39;&lt;a href=&quot;...&quot; class=&quot;visited-&#39;+isVisited+&#39;&quot;&gt;...&lt;/a&gt;&#39;;<br>...loop end</pre><p>위 스크립트를 조금 변형하여 실제로 SPA로 이루어진 서비스에 적용을 해보았다. 색깔로 구분되어 있기에 방문했던 페이지를 실수(?)로 또 클릭해서 힘빠질 일은 없다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*sjHNUSorLXtY6cvUBmbpng.png" /><figcaption>SPA로 만들어진 리스트이지만 클릭했던 게시물이 약간 비활성화처리된 것처럼 보여진다.</figcaption></figure><p>바로 가져다가 사용할 수 있는 스크립트는 아래 codepen 예시를 참고하면 된다. 이러한 구분이 없다고 불편하지는 않겠지만, 있으면 페이지 네비게이션이 훨씬 편리해질 것이다.</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fcodepen.io%2Fzidell%2Fembed%2Fpreview%2FyVGWzP%3Fheight%3D600%26amp%3Bslug-hash%3DyVGWzP%26amp%3Bdefault-tabs%3Djs%2Cresult%26amp%3Bhost%3Dhttp%253A%252F%252Fcodepen.io%26amp%3Bembed-version%3D2&amp;url=https%3A%2F%2Fcodepen.io%2Fzidell%2Fpen%2FyVGWzP&amp;image=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fi.cdpn.io%2F745056.yVGWzP.small.c4d110f6-e2a7-406a-bb4e-4a3c74d6c473.png&amp;key=d04bfffea46d4aeda930ec88cc64b87c&amp;type=text%2Fhtml&amp;schema=codepen" width="800" height="600" frameborder="0" scrolling="no"><a href="https://medium.com/media/7fc9e106d75a0f2b1e7ad3536e5b0955/href">https://medium.com/media/7fc9e106d75a0f2b1e7ad3536e5b0955/href</a></iframe><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=84efbc2db16a" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Redesign Pagination]]></title>
            <link>https://medium.com/@maxzidell/%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98-%EB%A6%AC%EB%94%94%EC%9E%90%EC%9D%B8-cb42badc6af4?source=rss-ddef89cb38f6------2</link>
            <guid isPermaLink="false">https://medium.com/p/cb42badc6af4</guid>
            <category><![CDATA[ux]]></category>
            <category><![CDATA[ui]]></category>
            <category><![CDATA[pagination]]></category>
            <dc:creator><![CDATA[홍구]]></dc:creator>
            <pubDate>Wed, 14 Dec 2016 13:28:15 GMT</pubDate>
            <atom:updated>2017-05-18T04:02:50.068Z</atom:updated>
            <content:encoded><![CDATA[<h4>너무도 흔하게 쓰이지만 표준이 없어 항상 헷갈리는 페이지네이션 UI를 리디자인 해보자. Pagination is heavily used, but there is no standard. Let’s redesign this.</h4><p>이 포스팅에서 제안하고 싶은 것은 바로 웹사이트의 페이지네이션에 관한 방법이다. 페이지네이션은 인터넷의 초창기부터 꾸준히 있어왔지만 아직까지 그 표준이라 할 만한 방식이 없는 것 같다. 그래서 맨날 모든 곳의 모든 페이지네이션이 쓸 때마다 헷갈린다.. 나는 매우 화가 나 있다.</p><p>What I would like to suggest in this posting is how to paginate your website. Pagination has been steadily since the early days of the Internet, but there seems to be no standard for it yet. So every time I use every pagination everywhere, I get confused. I am very upset.</p><h3>전통적인 방법의 문제</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/890/1*RjxY0q0g-CMsw90qHqsTXw.png" /><figcaption>가장 일반적인 구글의 페이지네이션</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/976/1*7_wE6ZSicZBTGh5qXh_QkQ.png" /><figcaption>킹왕짱 부트트랩의 페이지네이션 예시</figcaption></figure><p>위는 가장 기본적인 페이지네이션이다. 현재 1페이지에 머물러 있고, 전후 몇 개의 페이지로 바로 이동할 수도 있으며 이전`과 `다음`버튼이 있다. 어떤건 부트스트랩 예시처럼 `맨처음` 과 `맨끝` 버튼이 있을 때도 있다.</p><p>The above example is the most basic form. Currently I am on page one. There is a button that can move to the front and back several pages. Some have first and last buttons.</p><blockquote>과연 저기에서 ‘다음&#39;을 누르면 몇 페이지로 이동 될까?<br>Do you know where to go when you press the Next button from there?</blockquote><p>제일 짜증나는 포인트다. 저기에서 다음을 누르면 이후의 11페이지부터 20페이지의 리스트로 이동되는 것인지(이것을 페이지그룹이라고 하자), 아니면 현재가 1페이지니까 2페이지로 이동되는 것인지 애매하다. 이게 정말 이렇다할 관습도 없는게 정말로 어떠한 시각적 힌트도 없이 중구난방이다. 구글 페이지네이션에서의 답은 &#39;2페이지로의 이동’이다. 그냥 내 경험상 영어권에서는 다음이 주로 현재 페이지의 다음이고, 동양권에서는 다음 페이지그룹으로 이동이 관습인 것 같기는 한데 정말로 케바케로 그냥 개발자 마음이다.</p><p>This is the most annoying point. If I press the Next button, I may or may not be moved to the next page group. Or whether it will be moved to the next page of the current page. There is no visual clue and no experience here. In the example of Google, we move to the next page. In my opinion, this seems to be true in the alphabet culture. In the Orient, there are many cases that go to the next page group. In the end, it’s just the developer’s will.</p><p>한 가지 더 불편한 것은 만약에 저 ‘다음&#39;이 2페이지로 간다면, 내가 저 상태에서 15페이지로 가려면 다음페이지그룹으로 이동하기 위하여 10페이지를 누르고 ‘다음’을 누른 다음에 15페이지 숫자를 눌러야 할 것이다.</p><p>One more thing is annoying. To go to a page that is not yet exposed, I need to press the Next Page and Next Page Group buttons repeatedly. You will not know until you press something once.</p><p>여기에서는 ‘다음&#39;에 대해서만 논의했는데 거꾸로 ‘이전&#39; 버튼을 눌렀을 때도 내가 어디로 갈 지 전혀 예측할 수가 없다.</p><p>These apply to the previous button as well as the next button. Sometimes it is more annoying to go to the left than to the right.</p><h3>완전 뜯어고쳐보자</h3><p>다들 페이지네이션 디자인은 예쁘게 만들지 언정 사용성에 대해서는 개선의 의지가 없는 것 같으니 쪼랩인 나라도 나서본다. 한 눈에 리스트의 총량이 어느 정도이며 처음과 끝을 한 번에 워프처럼 이동할 수 있고, ‘다음’이 ‘다음페이지’인지 ‘다음 10개 페이지그룹’인지 헷갈리지 않게 이동할 수 있으며 보기에도 깔끔한 그런 개선이 가능할까?</p><p>Let’s make a pagination that is understandable without experience and custom. Of course this is my personal taste, so it may not be meaningful in fact.</p><p>아래는 여러가지 테스트를 하면서 만들어본 페이지네이션 결과물이다. 그냥 뭐 심플해진 것 이외에는 별로 달라진 것 없는 것 같지만 나름 엄청나게 고뇌한(?) 결과물이다.</p><p>Let’s start with the results. The pagination I want to suggest works as follows.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/417/1*yYOoWHRI1LvIzO5OYT8RUw.gif" /><figcaption>새롭게 디자인한(?) 페이지네이션 예시</figcaption></figure><h4>1. 첫페이지와 끝페이지</h4><p>기호로 표시하는 경우 사실상 ‘끝&#39;을 표시하는게 애매하다. 뭔가 그냥 화살표보다 조금 더 쎈 느낌의 더블 화살표(≪,≫)를 써도, 이게 정말 완전 좌우 끊으로 가는지 헷갈릴 수 있고, 화살표와 |문자를 결합해도 헷갈릴 수 있다. 그래서 기호가 아닌 그 위치로써 역할을 의미하도록 했다. 특히 끝페이지가 그냥 우측 가장자리에 마지막 페이지 숫자를 표기함으로써 딱 봐도 전체적으로 목록이 몇개나 있는지 직관적으로 알 수 있는 것은 덤이다.</p><p>I once removed the most confusing sign. You do not have to worry about whether it is next page or next page group! Cool! I just made the page numbers of the first and last pages recognizable by putting them at both ends.</p><h4>2. 이전/다음페이지</h4><p>다음 10개의 페이지 목록으로 이동하는 것인지 그냥 단순히 다음 페이지로 이동하는 것인지 헷갈리는 &lt;, &gt; 등의 기호는 더 이상 쓰지 않았다. 다음 페이지로 이동하려는 경우에는 그냥 현재 페이지의 좌우에 있는 버튼을 누르면 된다. 위의 예시에서 36을 누르고, 37을 누르고 그러면 한 페이지씩 우측으로 이동을하고, 현 상태에서의 마지막 42페이지를 누르게 되면…(아래)</p><p>Neither the next nor the previous page movements also used the symbol. Just click on the page number. It is important to remove the confusion here.</p><h4>3. 이전/다음 페이지그룹(내맘대로 명명)</h4><p>42페이지가 열림과 동시에 42~51페이지 그룹이 열릴 것이다!! 유레카!! 이 부분은 ‘다음페이지 기능’과 결합하여 가장 고민을 했던 부분이다. 계속 언급하듯이 &lt;, &gt;등의 버튼이 다음페이지인지 다음페이지그룹을 의미하는지 헷갈리는데, 이것을 없애면서 어떻게 기존의 기능을 다 흡수할 수 있을까 고민을 했다. 왼쪽과 오른쪽의 방향에 따라 말줄임표와 함께 페이지그룹이 시작되는 번호가 부여되어 있다. ... 표시를 보면 무언가 열릴 것이라는 기대를하게 되고, 그게 각 사이드에서 마지막으로 표시되는 페이지 번호와 연결되어 있기 때문에 <strong>해당 번호의 페이지가 열리면서 접혀있던 것이 펴질 것이다</strong>라고 자연스럽게 생각하게 만든다.</p><p>The page group was replaced by `…` If you stick one more, the page number is attached to the left or right according to the direction in which it opens. That is, if you click on a page that has `…`, it means that the page group that was hidden in that direction `…` is opened.</p><h3>Demo</h3><p>실제로 이렇게 만들어진 나만의 페이지네이션을 여기저기 적용을 했었다. 근데 페이지네이션을 시연해볼만큼 게시물이 많은 사이트가 없기에 JS Bin에다가 예제를 직접 올렸다. 의식의 흐름대로 코딩했기 때문에 코드는 더럽지만 그래도 잘 작동한다.</p><p>An example of this code is on the JS Bin page. It would be nice to experience the experience by actually tapping. The source code is dirty but works fine.</p><p><a href="http://jsbin.com/xoyideq/1/edit?html,js,output">JS Bin</a></p><h3>Source</h3><p>아래는 위 jsbin에 쓰인 코드 그대로이다. 동작하는 코드는 위의 링크를 참고하면 더욱 좋다.</p><p>Below is a specialty of dirty code.</p><pre>const zidellPagination = (baseUrl=&#39;#&#39;, pageNum=1, totalRecord=200, perPage=20, displayButtons=8) =&gt;<br>{<br>  let totalPage = Math.ceil(totalRecord/perPage);<br>  <br>  let s = &#39;&lt;ul class=&quot;pagination&quot;&gt;&#39;;<br>  let lis = [];<br>  <br>  // 맨 좌측의 페이지 번호를 구함<br>  let startPageNum = (Math.ceil(pageNum/displayButtons)-1) * displayButtons + 1;<br>  let endPageNum = startPageNum + displayButtons - 1;<br>  if(endPageNum &gt; totalPage){<br>    endPageNum = totalPage;<br>  }<br>  <br>  for(i=startPageNum; i&lt;=endPageNum; i++){<br>    lis.push(&#39;&lt;li &#39;+(i==pageNum?&#39;class=&quot;active&quot;&#39;:&#39;&#39;)+&#39;&gt;&lt;a href=&quot;&#39;+baseUrl+&#39;?p=&#39;+i+&#39;&quot;&gt;&#39;+i+&#39;&lt;/a&gt;&lt;/li&gt;&#39;);<br>  }<br>  pageNum = displayButtons;<br>  let targetPage;<br>  if(startPageNum &gt; 1){ // prev<br>   targetPage = startPageNum - 1;<br>   lis.unshift(&#39;&lt;li class=&quot;page-prev&quot;&gt;&lt;a href=&quot;&#39;+baseUrl+&#39;?p=&#39;+targetPage+&#39;&quot;&gt;&#39;+(pageNum&gt;1?&#39;...&#39;:&#39;&#39;)+&#39; &#39;+targetPage+&#39;&lt;/a&gt;&lt;/li&gt;&#39;);<br>   if(pageNum&gt;1){<br>    lis.unshift(&#39;&lt;li class=&quot;page-first&quot;&gt;&lt;a href=&quot;&#39;+baseUrl+&#39;?p=1&quot;&gt;1&lt;/a&gt;&lt;/li&gt;&#39;);<br>   }<br>  }<br>  if(totalPage &gt; endPageNum){ // next<br>   targetPage = endPageNum + 1;<br>   if(totalPage - targetPage + 1 &lt; displayButtons){<br>     pageNum = totalPage - targetPage +1;<br>   }<br>   lis.push(&#39;&lt;li class=&quot;page-next&quot;&gt;&lt;a href=&quot;&#39;+baseUrl+&#39;?p=&#39;+targetPage+&#39;&quot;&gt;&#39;+targetPage+&#39; &#39;+(pageNum&gt;1?&#39;...&#39;:&#39;&#39;)+&#39;&lt;/a&gt;&lt;/li&gt;&#39;);<br>   if(pageNum&gt;1){<br>     lis.push(&#39;&lt;li class=&quot;page-last&quot;&gt;&lt;a href=&quot;&#39;+baseUrl+&#39;?p=&#39;+totalPage+&#39;&quot;&gt;&#39;+totalPage+&#39;&lt;/a&gt;&lt;/li&gt;&#39;);<br>   }<br>  }<br>  <br>  s += lis.join(&#39;&#39;);<br>  s += &#39;&lt;/ul&gt;&#39;;<br>  return s;<br>}</pre><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=cb42badc6af4" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[가희 누나 감사합니다! 보고 싶어요!!]]></title>
            <link>https://medium.com/@maxzidell/%EA%B0%80%ED%9D%AC-%EB%88%84%EB%82%98-%EA%B0%90%EC%82%AC%ED%95%A9%EB%8B%88%EB%8B%A4-%EB%B3%B4%EA%B3%A0-%EC%8B%B6%EC%96%B4%EC%9A%94-9ef4f11ae227?source=rss-ddef89cb38f6------2</link>
            <guid isPermaLink="false">https://medium.com/p/9ef4f11ae227</guid>
            <dc:creator><![CDATA[홍구]]></dc:creator>
            <pubDate>Wed, 16 Nov 2016 08:47:33 GMT</pubDate>
            <atom:updated>2016-11-16T08:47:33.683Z</atom:updated>
            <content:encoded><![CDATA[<p>가희 누나 감사합니다! 보고 싶어요!!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9ef4f11ae227" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[프로토타입과 함께하는 서비스 개발]]></title>
            <link>https://medium.com/@maxzidell/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EA%B3%BC-%ED%95%A8%EA%BB%98%ED%95%98%EB%8A%94-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%9C%EB%B0%9C-e1c2c5d49f51?source=rss-ddef89cb38f6------2</link>
            <guid isPermaLink="false">https://medium.com/p/e1c2c5d49f51</guid>
            <category><![CDATA[desig]]></category>
            <category><![CDATA[tyle]]></category>
            <category><![CDATA[prototype]]></category>
            <dc:creator><![CDATA[홍구]]></dc:creator>
            <pubDate>Wed, 16 Nov 2016 06:21:14 GMT</pubDate>
            <atom:updated>2016-12-15T13:26:41.488Z</atom:updated>
            <content:encoded><![CDATA[<h4>타일을 위한 6번의 메이저/마이너 프로토타입</h4><p>타일이라는 자동디자인 툴을 만드는데에 있어서 가장 중요한 점은 <strong>자동으로 뽑아 낼 수 있는 디자인의 퀄리티</strong>와 <strong>이러한 사용자 경험이 과연 (돈 낼 만큼)가치가 있느냐</strong>였다. 그래서 최초의 와이어프레임이 구상되자마자 실제로 손으로 만져보기 위해서 프로토타입부터 시작하였다.</p><p>타일 서비스를 위해서 총 5개의 프로토타입을 만들었으며 정확히 말하면 현재의 타일(16년 11월)은 6번째 프로토타입이라 할 수 있다. 우리들은 항상 (성질이 급해서)동작하는 코드를 먼저 만들어내고 나중에 문서화를 한다. 문서화하기 전에 다치면 큰일남..!</p><h4>프로토타입 1</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/867/1*UHXqtlqtOzODQ5YKyLsmmQ.gif" /><figcaption>최초의 프로토타입, 좌측엔 결과물, 우측엔 데이터 조작을 위한 창이 있다.</figcaption></figure><p>먼저 타일의 큰 그림을 공유하기 위해서 방향을 설정할 수 있는 최초의 프로토타입이 필요하였다. 체계 없이 그냥 생각나는대로 만들었고, jQuery 떡칠을 통해서 일단 동작하는데에 주안점을 두었다. 각 디자인 요소들을 어떻게 결합할지에 대해서는 크게 생각하지 않았은 상태이다.</p><p>대충 디자인을 구성하는 요소를 단순하게 이미지, 박스, 텍스트로만 넣고 이것들을 무작정 조합을 해보았다. 여기에서 최초에 박스와 텍스트의 관계, 배경으로써의 이미지에 대해서 알아보았고, 점/선/면/여백을 통해서 구성할 수 있는 케이스에 대해서 연습을 해보았다. 가장 중요한 것은 좌측의 결과물이고 또한 데이터의 직접 조작을 통해 변화를 보아야하기 때문에 데이터 형태가 우측의 패널에 고스란히 노출되어 있다. 자기 할 일은 다 했으니 이 프로토타입은 버려졌다.</p><h4>프로토타입 2</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/737/1*GlotHk5kyqeSn5a0BYvVYg.gif" /><figcaption>두번째 프로토타입, 완전한 랜덤을 통해서 어떤 모양들이 나오는지 테스트했다.</figcaption></figure><p>두번째 프로토타입은 일종의 디자인 조합 실험이었다. 이미지위에 박스가 나타날 때와 이미지와 박스가 나란히 나타날 때의 관계와 경우의 수를 테스트해보기 위함이었다. 박스에 두께, 스타일, 투명도, 크기 등 여러가지 속성을 정의하고 정말로 무작위로 섞은 다음에 나오는 모양에 대해서 테스트를 해보았다. 생각보다 괜찮은 조합들이 나왔고 또 생각보다 별 거 없다는 것도 알았다. 무작정하면 망하겠다 생각이 들었다. 그리고 이 프로토타입은 당연히 바로 버렸다.</p><h4>프로토타입 3</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/769/1*jnolgTBFMYZ8ML3Cvljo1A.gif" /><figcaption>세번째 프로토타입으로, 데스크탑에 최적화된 UI 에 대한 테스트도 포함하였다.</figcaption></figure><p>기존까지 조합의 가능성만을 타진해왔으니 이제는 진정한 사용자 가치를 줄 수 있는지도 테스트하기 위하여 프로토타입을 새로 만들었다. 폰트빨을 세우기 시작하면서 뭔가 각이 잡히기 시작한 프로토타입이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*clhanZzDaozou32oeX7uIw.png" /><figcaption>이 때부터 타일의 마케터 ‘킴지’가 ‘우리가 나름 괜찮은 서비스를 만들고 있다’고 자각을 시작했다.</figcaption></figure><p>탐색(스토리)모드와 편집 모드를 결합하고, 별도의 모드 전환 없이 확대/축소에 따라 자동으로 모드가 전환되는 형태를 시도해보았다. 멀리서 보는 것은 숲을 보는 것이고 가까이서 보는 것은 나무를 보는 느낌이다. 또한 데스크탑 뷰의 특성에 따라 상하가 아닌 좌우의 배치를 시도했다. 일반적인 휠의 용도(스크롤)을 확대/축소로 전환하는 리스크를 넘어서서 효용을 가져야하는데, 사실 카드뉴스는 PPT처럼 수십장을 작업하는게 아니기 때문에 이 인터페이스는 아무래도 애매하다고 판단했다.</p><p>또 다른 시도로 결과물에서 바로 각 디자인의 세부 위치를 결정할 수 있는 기능도 넣어 봤는데, 이렇게 되는 경우 사용자가 왼쪽으로 요소를 밀었어도 디자인 최적화 알고리즘상 위치하기 힘든 경우에 굉장히 어정쩡한 반응이 나오는 경우가 생겼다. 사용자의 통제권을 완전히 Bottom-up 방식으로 적용하기는 힘들다고 판단되어 이것도 과감히 없앴다. 결과적으로 현재까지의 타일은 컨텐츠와 약간의 의도를 기반으로 자동생성하는 Top-Down 방식의 사용자 흐름을 고수하고 있다. 그리고 꽤 아쉽지만 그냥 통째로 버렸다.</p><h4>프로토타입 4</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*A9YVK8GuJW2dv0Cb738-fg.png" /><figcaption>네번째 프로토타입으로 현재의 모습과 꽤 가까워졌다.</figcaption></figure><p>탐색과 편집모드를 별도로 구분하지 않고, 대신 실제 결과물에 가까운 사이즈로 맞추면서(사용자가 편집이 쉽도록 크게 키우면 모바일 가독성을 무의식중에 놓칠까봐), 변환할 수 있는 요소들을 패널로 묶어서 분류를 해보았다. 카드뉴스 위에 Theme / Layout / Shuffle 등 이때까지 기능들이 제대로 분류되지 않은 상태로 ‘작동&#39;을 위주로 계속 테스트를 진행하였다. 그리고 버렸다.</p><h4>프로토타입 5</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Kn-7Ak4tbg01am-JvDxrwQ.png" /><figcaption>화면의 요소들이 정리되고 흐름이 다소 명확해졌다.</figcaption></figure><p>상용버전을 생각하고 사용성을 증진시키기 위하여 사용자 흐름을 명확하기하고 GUI를 가다듬고 있는 과정이다. 실제로 제작 자체에는 큰 문제가 없었으나 다수의 슬라이드를 하나의 톤앤매너로 묶을 수 있는 일종의 ‘테마&#39;를 각 슬라이드에 종속시킨 구조 때문에 계속 찜찜한 상태로 남아있었다. 또한 자동디자인이라는 것이 무색하게 우측 패널의 존재감이 상당했으며 정확히 화면을 양분하고 있는 상황이라 패널이 우선인지 슬라이드가 우선인지 구분이 불명확했으며 상호 연결성도 애매한 상태였다.</p><p>사실 이맘때에는 일단 제작자체가 가능한 상황이어서 사용성 문제는 조금 더 뒤로 미루고, 생성되는 디자인 알고리즘을 고도화하는 단계였다. 외부에서 도와주는 디자이너들의 피드백을 적극적으로 수용하여 ‘디자인 버그&#39;가 발생하지 않도록 발전시켰다.</p><h4>프로토타입 6</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*acNiwLgoAYv4P8pwUHNO9w.png" /><figcaption>현재(16년 11월)의 모습은 이렇게 변해있다.</figcaption></figure><p>정보구조를 명확히하고 사용자의 혼란을 막기 위하여, 불필요한 시각적 잡음은 모두 없애거나 하위로 숨겼다. 자동디자인이 100% 만족을 줄 수는 없지만 장기적으로 계속 보강할 예정이기 때문에 먼저 사용자 경험을 우리의 의도대로 고정시킬 필요가 있었다. <strong>테마(전체적인 공통 스타일) &gt; 각 슬라이드 편집 &gt; 각 슬라이드의 수동 편집</strong>의 정보구조를 확정하였다.</p><p>이제 남은 작업으로는 지속적으로 디자인 패턴의 다양화/고도화와 사용자의 사용 내역을 바탕으로한 의도접목, 우측 속성창에서의 사용자화를 더욱 디테일하게 넣는 작업들을 남겨놓은 상태이다.</p><h4>관련글</h4><ul><li><a href="https://medium.com/@maxzidell/%EC%B9%B4%EB%93%9C%EB%89%B4%EC%8A%A4-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A3%BC%EB%8A%94-%EC%84%9C%EB%B9%84%EC%8A%A4-12367859f665">우리는 타일이라는 서비스를 만들고 있다.</a></li><li><a href="https://medium.com/@maxzidell/%ED%83%80%EC%9D%BC%EC%9D%98-%EC%95%8C%ED%8C%8C%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EB%A7%88%EC%B9%98%EB%A9%B0-5d4d943bb5f2">타일의 알파테스트를 마치며..</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e1c2c5d49f51" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>