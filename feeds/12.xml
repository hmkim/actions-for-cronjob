<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Luavis' Dev Story</title>
    <description>생계코딩 이야기</description>
    <link>https://b.luavis.kr/</link>
    <atom:link href="https://b.luavis.kr/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 25 Apr 2019 13:35:23 +0900</pubDate>
    <lastBuildDate>Thu, 25 Apr 2019 13:35:23 +0900</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Athena를 Zeppelin과 함께 쓰기</title>
        <description>&lt;p&gt;회사 업무 중에 대용량의 데이터를 조회하고 분석할 일이 생겼다. 데이터는 DynamoDB에 쌓여있다. DynamoDB에서는 복잡한 조건을 갖고 쿼리를 할 수 있는 구조가 아니고, 가격과 성능 문제도 있기 때문에, 선택할 수 있는 도구에 대해서 수소문 해봤고, Google cloud platform에서 제공하는 &lt;a href=&quot;https://cloud.google.com/bigquery/&quot;&gt;BigQuery&lt;/a&gt;나 AWS에서 제공하는 &lt;a href=&quot;https://aws.amazon.com/ko/athena/&quot;&gt;Athena&lt;/a&gt;가 가장 편하고 흔하게 사용하는 듯 하다.&lt;/p&gt;

&lt;p&gt;하지만 모든 데이터가 AWS의 DynamoDB에 있고, 회사에서는 이미 AWS를 적극적으로 사용중임으로,  BigQuery보다는 Athena를 선택하게 되었다.&lt;/p&gt;

&lt;p&gt;DynamoDB에 있는 데이터를 S3에 쌓고 이를 Athena를 통해서 질의하는 방법에 대한 설명은 메가존에서 &lt;a href=&quot;https://cloud.hosting.kr/techblog_180612_your-amazon-dynamodb-data-by-using-amazon-athena/&quot;&gt;번역한 AWS의 기술 블로그 글&lt;/a&gt;이 있다.&lt;/p&gt;

&lt;p&gt;이 글 안에, Athena로 질의한 내용에 대해서 시각화 하는 방법으로 AWS의 &lt;a href=&quot;https://aws.amazon.com/ko/quicksight/&quot;&gt;QuickSight&lt;/a&gt;를 사용했다. QuickSight는 데이터를 시각화하여 대시보드를 만들고 회사 내에 데이터를 공유하는데에 초점이 맞춰져 있다. 하지만 내가 하고 싶은 일은 질의를 통해서 데이터를 분석하는데에 초점이 맞춰있기 때문에 Notebook형식의 &lt;a href=&quot;https://zeppelin.apache.org/&quot;&gt;Apache Zeppelin&lt;/a&gt;이 더 편해보였다. 따라서 로컬에 Docker를 통해서 Zeppelin을 설치하고, Zeppelin에서 Athena에 쿼리할 수 있는 방법에 대해 자료가 부족하여 정리해보고자 했다.&lt;/p&gt;

&lt;h2 id=&quot;docker-compose을-이용한-zeppelin-설치&quot;&gt;docker-compose을 이용한 Zeppelin 설치&lt;/h2&gt;

&lt;p&gt;Dockerhub에 이미 Apache에서 공식으로 제공하는 Zeppelin이 docker image가 있다. 관리를 위해서는 docker-compose를 이용해서 컨테이너를 만드는게 좋다. 우선 Zeppelin에서 작성한 노트북은 Host machine에서 접근할 수 있으면 좋겠고, Zeppelin의 기본 포트인 8080은 개발시에 자주 사용하는 포트인지라, 5000번 포트로 접근할 수 있도록 설정했다.&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;3'&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;zeppelin&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apache/zeppelin:0.8.1&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;container_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;zeppelin-notebook&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;5000:8080&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;./notebook:/notebook&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;environment&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ZEPPELIN_NOTEBOOK_DIR=/notebook&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ docker-compose up --build&lt;/code&gt;를 통해서 zeppelin을 실행하면 브라우저를 통해 http://localhost:5000 에서 쉽게 접근할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;zeppelin과-athena-연결&quot;&gt;Zeppelin과 Athena 연결&lt;/h2&gt;

&lt;p&gt;Zeppelin은 java를 이용해서 작성했고, 따라서 JDBC를 통해서 Athena에 접근한다. AWS에서는 JDBC 드라이버를 제공하고 있고 두 가지의 버전이 있는데 이 글에서는 최신 버전의 Athena JDBC 드라이버를 기준으로 설명한다. (이전 버전의 JDBC &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/athena/latest/ug/connect-with-previous-jdbc.html&quot;&gt;다운로드 링크&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;최신 Athena의 JDBC 드라이버는 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/athena/latest/ug/connect-with-jdbc.html&quot;&gt;이 페이지&lt;/a&gt;에서 다운로드 받을 수 있다. docker-compose.yml에서 사용하고 있는 0.8.1버전의 zeppelin 이미지는 java 8이 돌아가고 있기 때문에 &lt;a href=&quot;https://s3.amazonaws.com/athena-downloads/drivers/JDBC/SimbaAthenaJDBC_2.0.6/AthenaJDBC42_2.0.6.jar&quot;&gt;AthenaJDBC42_2.0.6.jar&lt;/a&gt;를 다운로드 받아서 docker-compose.yml의 디렉토리에 jar라는 서브 디렉토리를 만들어서 다운로드 받은 jar파일을 저장했다.&lt;/p&gt;

&lt;p&gt;이제 다운로드 받은 jar 파일과 AWS의 credential 디렉토리(AWS의 자격증명 만들기에 대한 설명은 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/dev/AuthUsingAcctOrUserCredentials.html&quot;&gt;여기에&lt;/a&gt;)를 docker-compose.yml을 통해서 zeppelin이 동작 중인 컨테이너와 연결시켜 준다.&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;3'&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;zeppelin&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apache/zeppelin:0.8.1&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;container_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;zeppelin-notebook&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;5000:8080&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;./notebook:/notebook&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;./jar:/usr/local/jar&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;~/.aws:/root/.aws&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;environment&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ZEPPELIN_NOTEBOOK_DIR=/notebook&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose up --build&lt;/code&gt;를 다시 실행해서 컨테이너를 재시작 시켜주고, zeppelin에 접속해서 athena interpreter를 설정해준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/zeppelin-home.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;zeppelin에 다시 접속하여 계정 이름을 클릭하면 zeppelin에 있는 모든 인터프리터를 볼 수 있는Interpreters 메뉴가 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/zeppelin-create-interpreter.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;새로운 인터프리터를 만들어야하는데 &lt;code class=&quot;highlighter-rouge&quot;&gt;Interpreter Name&lt;/code&gt;은 적당히 athena로 정하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;Interpreter group&lt;/code&gt;은 jdbc로 설정했다. jdbc로 설정하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Properties&lt;/code&gt;가 자동으로 채워지는데, 이 중에 몇 가지를 바꿔야한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;default.driver&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;com.simba.athena.jdbc.Driver&lt;/code&gt;로 설정하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;default.url&lt;/code&gt;은 굉장히 긴 텍스트를 설정해야한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jdbc:awsathena://athena.ap-northeast-2.amazonaws.com:443;S3OutputLocation=s3://aws-athena-query-results-...-ap-northeast-2;Schema=default;AwsCredentialsProviderClass=com.simba.athena.amazonaws.auth.profile.ProfileCredentialsProvider;AwsCredentialsProviderArguments=&quot;...&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하나씩 보면&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;jdbc:awsathena://athena.ap-northeast-2.amazonaws.com:443 리전코드만 athena에 따라 바꾸면 된다.&lt;/li&gt;
  &lt;li&gt;S3OutputLocation=s3://aws-athena-query-results-…-ap-northeast-2  쿼리 결과가 저장되는 S3 위치를 설정하면 된다. Athena의 AWS Console에 Settings를 살펴보면 기본 Query result locaiton을 알 수 있다.&lt;/li&gt;
  &lt;li&gt;Schema=default 사용할 스키마를 설정한다.&lt;/li&gt;
  &lt;li&gt;AwsCredentialsProviderClass=com.simba.athena.amazonaws.auth.profile.ProfileCredentialsProvider 건드릴 필요 없다.&lt;/li&gt;
  &lt;li&gt;AwsCredentialsProviderArguments=”…” Credential의 이름을 정하면 되는듯하다. 이름은 ~/.aws/credential 내용의 대괄호 안의 내용이다. 일반적으론 default로 설정되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;default.user&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;default.password&lt;/code&gt;를 비워두고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dependecies&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;artifact&lt;/code&gt;를 /usr/local/jar/AthenaJDBC42_2.0.6.jar로 설정하면 AWS에서 다운로드 받은 JAR 파일을 zeppelin이 사용하도록 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;Save하고 새로운 노트북을 만들면 athena로 쿼리를 보낼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/zeppelin-query.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 14 Mar 2019 19:16:00 +0900</pubDate>
        <link>https://b.luavis.kr/server/zeppelin-with-athena</link>
        <guid isPermaLink="true">https://b.luavis.kr/server/zeppelin-with-athena</guid>
        
        
        <category>server</category>
        
      </item>
    
      <item>
        <title>타원곡선 디피 헬만</title>
        <description>&lt;p&gt;AES나 DES와 같은 암호화 알고리즘을 이용해서 보안 통신을 하기 위해서는 암호키가 필요하다. 암호키를 통해서 제 3자가 이를 해독하기 어렵게 만드는것이다. 암호키를 제 3자가 알면 암호를 깨고 데이터를 복호화할 수 있기 때문에 안전하게 암호화 키를 공유할 필요가 있다. 디피 헬만은 위와 같은 암호화 통신에서 안전하게 키를 교환하는 방법 중 하나로 TLS에서 많이 사용해 왔다.&lt;/p&gt;

&lt;p&gt;최근에 TLS를 공부하면서 타원곡선 디피 헬만(Elliptic Curve Diffie Hellman)에 대해 알아보고 싶어서 공부를 시작했다. 일반적으로 타원곡선 디피 헬만은 적은 CPU와 메모리 자원과 더 작은 키 값으로도 일반 디피 헬만에 비해 안전한것으로 알려져 있다. 일반 디피 헬만의 키 사이즈가 2048bit면 ECDH에서는 224bit 사이즈의 키로 같은 안전성을 보장한다.&lt;/p&gt;

&lt;p&gt;ECDH의 원리 이해를 위해서는 정수론에 대한 이해가 필요했다. 따라서 글을 모듈러 연산과 군, 이산로그 그리고 타원곡선 디피 헬만 순으로 나눴다.&lt;/p&gt;

&lt;h2 id=&quot;modular-연산-나머지-연산&quot;&gt;Modular 연산 (나머지 연산)&lt;/h2&gt;

&lt;p&gt;정수를 정수와 나누면 나머지가 발생한다. 거의 모든 프로그래밍 언어에 항상 빠지지 않고 등장하는 흔한 이항연산자다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;a \mod N = b&lt;/script&gt;

&lt;p&gt;a는 피제수, N은 제수, b는 나머지다. Modular 연산의 예를 들면 아래와 같다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;40\mod17 = 6&lt;/script&gt;

&lt;p&gt;알지 못할 수 있지만 음수에 대한 나머지 연산도 가능하다. 음수의 나머지 연산을 계산할 경우, 피제수의 값을 양수라 생각하고, 제수의 차를 구한다. 예를 들어 &lt;script type=&quot;math/tex&quot;&gt;-40 \mod 17&lt;/script&gt;의 경우 40의 mod 17 값인 6과 17의 차인 11이 정답이다.&lt;/p&gt;

&lt;h3 id=&quot;합동&quot;&gt;합동&lt;/h3&gt;

&lt;p&gt;Modular 연산에서의 합동은 나머지가 같은 값들을 의미한다. 예를들어, 17에 대하여, 40과 합동인 수는 6, 23, 57, …등이다. 이를 식으로 나타내면 &lt;script type=&quot;math/tex&quot;&gt;40 \equiv 6 \mod 7&lt;/script&gt;이 된다. 이 개념을 갖고 식에 적용하면 합동식이 되는데 예를들면 &lt;script type=&quot;math/tex&quot;&gt;3x \equiv 7 \mod4&lt;/script&gt; 과 같이 적을 수 있다. 이를 풀이하면 3의 배수 중에서, 4와 나눴을때 나머지 값이 7과 4를 나눈 나머지와 같은 수를 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;modular-역수&quot;&gt;Modular 역수&lt;/h3&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;40 ^{-1} \equiv x \mod 17&lt;/script&gt;에서 &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;는 얼마일까? 곱샘 연산자에서는 연산을 진행해도 같은 수가 나오는 항등원은 1이다. (덧샘에서는 0) &lt;script type=&quot;math/tex&quot;&gt;40 ^{-1}&lt;/script&gt;과 &lt;script type=&quot;math/tex&quot;&gt;40&lt;/script&gt;은 서로 곱하면 항등원인 1이 나오는 곱샘에서의 역원 관계에 있다. 따라서 17에 대한 나머지 연산에서 40과 곱했을때 연산 결과가 1이 나오는 값이 40의 역원인 &lt;script type=&quot;math/tex&quot;&gt;40 ^{-1}&lt;/script&gt;과 같은 값입니다. 예를들어 40의 법 17에 대한 역수는 3이다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;40 \times 3 \equiv 1 \mod 17&lt;/script&gt;

&lt;p&gt;따라서 &lt;script type=&quot;math/tex&quot;&gt;40 ^{-1} \equiv 3 \mod 17&lt;/script&gt;이라 할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;군-group&quot;&gt;군 (Group)&lt;/h2&gt;

&lt;p&gt;군은 하나의 이항 연산자에 대해서 특수한 조건을 갖고 있는 수의 집합이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;군은 정의된 연산자에 대해서 닫혀있어야 한다.&lt;/li&gt;
  &lt;li&gt;연산자에 대해서 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EA%B2%B0%ED%95%A9%EB%B2%95%EC%B9%99&quot;&gt;결합법칙&lt;/a&gt;이 성립되어야 한다.&lt;/li&gt;
  &lt;li&gt;군 안에는 항등원과 역원이 있어야 합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위와 같은 조건을 충족하는 집합의 사례를 들어보자.
모든 정수는 덧셈에 대해서 군을 이룬다. 위 조건에 부합하는지 알아보자, 우선 정수를 정수와 더하면 정수가 나올것이다. 또한 덧샘은 결합법칙이 성립하는 연산이다. 그리고 정수 안에는 덧샘의 항등원인 0이 있고, 역원인 음수가 있다. 예를들면 42의 역원은 -42이고 항등원은 0이다. 증명하는 방법이야 있겠지만 모든 정수가 덧셈에 대해서 군을 이룬다는 것은 자명한 사실이다. 정수와 같이 덧셈에 대한 군을 &lt;strong&gt;덧셈군&lt;/strong&gt;이라 부른다. 이와 마찬가지로 곱샘에 대해서 군이 성립하면 &lt;strong&gt;곱샘군&lt;/strong&gt;이라 할 수 있다.&lt;/p&gt;

&lt;p&gt;그러면 정수는 곱셈군이라 부를 수 있을까? 아쉽게도 그렇지 않다. 우선 역원이 없다. 예를 들면 2의 곱셈에 대한 역원은 1/2인데 이는 정수가 아닌 유리수이다. 그렇다면 유리수는 곱셈군을 이룬다 볼 수 있는가? 이 또한 그렇지 못 한다. 유리수에는 0이 있는데, 0은 곱셈에 대한 역원이 존재하지 않는다. (1/0은 계산할 수 없다.) 따라서 0을 제외한 유리수가 곱셈군을 이룬다 볼 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;modular-n에-대한-정수--mathbbznmathbbz-&quot;&gt;Modular N에 대한 정수 ( &lt;script type=&quot;math/tex&quot;&gt;\mathbb{Z}/n\mathbb{Z}&lt;/script&gt; )&lt;/h3&gt;

&lt;p&gt;Modular N에 대해서 모든 정수의 나머지의 집합을 이야기한다. 예를 들면 8에 대한 나머지 집합인 &lt;script type=&quot;math/tex&quot;&gt;\mathbb{Z}/8\mathbb{Z}&lt;/script&gt; 이라 표기하고 0, 1, 2, … 7까지의 숫자들이다. Modular 연산을 한 정수 집합은 덧셈군이 될까? 덧셈군은 성립한다. 예를들면 &lt;script type=&quot;math/tex&quot;&gt;3 + 7 \mod 8&lt;/script&gt;의 값이 &lt;script type=&quot;math/tex&quot;&gt;\mathbb{Z}/8\mathbb{Z}&lt;/script&gt;안에 있어야하고, 역수와 항등원이 존재해야한다. 우선 정수를 정수끼리 더하면 정수가 나올것이다. 그리고 항등원은 0이 있고 계산하면 0이 나오는 역원 또한 존재한다. Modular 8에 대한 정수 집합에서 보면 7에게는 1이 역원이고, 5에게는 3이 역원이 될 것이다. 모든 Modular N에 대한 정수는 일반 정수와 마찬가지로 덧셈군이 성립된다. 그렇다면 곱셈군도 성립할 수 있을까?&lt;/p&gt;

&lt;p&gt;우선 정수와 마찬가지 이유로 0은 제외해야 한다. 하지만 Modular N에 대한 정수에서는 0을 제외해도 문제가 숫자가 있다. 2, 4, 6입니다. 이 수 들은 어떤 수와 곱했을때 8의 배수가 될 여지가 있다. 그러면 Modular 연산하면 제외된 0이 나온다. 6으로 예를 들면,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
&amp;6 \times 4 \equiv 0 \mod 8 \\
&amp;\because 6 \times 4 = 24
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;24는 8의 배수임으로, 나머지 값이 0이 나오고 0을 제외한 집합에 대해서 닫혀있지 않은 연산이 된다. 이렇듯 곱셈 연산에 닫혀 있기 위해서는 0, 2, 4, 6을 제외한 1, 3, 5, 7이 Modular N에 대한 곱셈군(&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiplicative_group_of_integers_modulo_n&quot;&gt;Multiplicative group of integers modulo n&lt;/a&gt;)이 된다. 기호로는 &lt;script type=&quot;math/tex&quot;&gt;(\mathbb{Z}/n\mathbb{Z})^\times&lt;/script&gt; 이렇게 표기한다.&lt;/p&gt;

&lt;h3 id=&quot;modular-n에-대한-곱셈군multiplicative-group-of-integers-modulo-n&quot;&gt;Modular N에 대한 곱셈군(Multiplicative group of integers modulo n)&lt;/h3&gt;

&lt;p&gt;위에서 확인한 곱셈군인 1, 3, 5, 7은 8과 어떤 관계에 있는가? 곱셈군에 포함되지 않았던 값들은 다른 수와 곱했을때 8의 배수가 될 여지가 있는 수였다. 따라서 어떤수와 곱해도 8이 될 여지가 없는 수가 된다는 의미고, 이 말은 8과 서로소(두 수의 최대공약수가 1) 관계에 있다는 의미가 된다.&lt;/p&gt;

&lt;p&gt;N이 서로소가 많고 큰 수 라면, Modular N에 대한 곱셈군의 크기(order)가 커진다. 서로소가 많은 수는 소수가 있다. 소수는 모든 정수와 서로소 관계에 있다. 예를 들면 소수 7은 &lt;script type=&quot;math/tex&quot;&gt;\mathbb{Z}/7\mathbb{Z}&lt;/script&gt;는 0, 1, 2, 3, 4, 5, 6이 있고 이 중 0을 제외하면 모두 서로소 관계에 있다. 따라서 0을 제외하면 모두 &lt;script type=&quot;math/tex&quot;&gt;\mathbb{Z}/7\mathbb{Z}^\times&lt;/script&gt;에 포함되어 있단 의미가 된다.&lt;/p&gt;

&lt;h2 id=&quot;이산로그-문제-discrete-logarithm-problem&quot;&gt;이산로그 문제 (discrete logarithm problem)&lt;/h2&gt;

&lt;p&gt;암호화 알고리즘에게 있어서 중요한 문제는, 암호화를 하는 과정은 굉장히 간단하고 빠르게 진행되어야하지만 이를 복호화하는 과정은 매우 어려워야한다. 이를 일방향 함수(One-way function)라 이야기하는데 이산 로그 문제는 아주 전형적인 One-way function이다.&lt;/p&gt;

&lt;p&gt;위에서 이야기한 &lt;script type=&quot;math/tex&quot;&gt;\mathbb{Z}/7\mathbb{Z}^\times&lt;/script&gt;를 생각해보자, 이 집합은 1, 2, 3, …6까지의 수를 포함하고 있고, 모듈로 곱셈에 대해서 닫혀 있다. 따라서 거듭제곱 연산에 대해서도 닫혀있다 할 수 있다. 이를 이산 거듭제곱이라 이야기하는데, 예를 들어, &lt;script type=&quot;math/tex&quot;&gt;3^6 \mod 7&lt;/script&gt;한 값은 729을 7로 나눈 나머지 1가 된다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
&amp;3^6 \equiv 1 \mod 7 \\
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;여기서 결과값이 1이 되는 최솟값인 지수가 이산로그 값이다. 지수를 알고 계산하면 결과값을 계산하는데에 일반적인 연산에 가깝지만, 결과와 지수 연산의 밑만 가지고선 지수를 추론하는 과정은 1부터 시작해서 하나하나 비교하는 방법 외에는 없다.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\mathbb{Z}/7\mathbb{Z}^\times&lt;/script&gt;의 경우 군의 크기가 6으로 작지만 7 대신 굉장히 큰 소수를 사용하면 군의 크기가 커지고, 이산 로그 문제를 해결하는 알고리즘은 군의 크기의 자릿수에 지수적인 복잡도를 갖고 있다. 이를 조금 효율적으로 찾는 방법은 있지만 의미있게 빠른 방법은 아직 없는것으로 알려져 있다. 또한 밑(위의 예제의 경우엔 3)을 정의하는 것이 중요한데, 밑 값을 제곱하여 modular 연산한 결과의 값이 &lt;script type=&quot;math/tex&quot;&gt;\mathbb{Z}/n\mathbb{Z}^\times&lt;/script&gt;의 모든 원소를 포함해야 추론이 어려워지기 때문이다. 위와 같은 밑을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Primitive_root_modulo_n&quot;&gt;Primitive root&lt;/a&gt;라 이야기한다. 따라서 많은 보안 통신을 하는 프로그램들이 &lt;script type=&quot;math/tex&quot;&gt;\mathbb{Z}/n\mathbb{Z}^\times&lt;/script&gt;의 소수 N과 Primitive root값인 g값에 대해선 사전에 정의해두고 사용한다.&lt;/p&gt;

&lt;p&gt;결론적으로 일반적인 이산 로그 문제는 Modular N에 대한 곱셈군에서 곱셈의 반복 연산인 제곱의 역연산 값 로그 값을 구하기 어려운 문제를 이야기한다. 이는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/RSA_%EC%95%94%ED%98%B8&quot;&gt;RSA&lt;/a&gt;, &lt;a href=&quot;https://tramamte.github.io/2018/07/20/diffie-hellman/&quot;&gt;디피 헬만&lt;/a&gt;에 유용하게 쓰인다.&lt;/p&gt;

&lt;h2 id=&quot;타원곡선&quot;&gt;타원곡선&lt;/h2&gt;

&lt;p&gt;타원곡선이란 &lt;script type=&quot;math/tex&quot;&gt;y^2 = x^3 + ax + b&lt;/script&gt; 꼴의 형태로 나타내지는 곡선을 의미한다. 그래프로 표현하면 아래와 같은 꼴이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/elliptic-curve.png&quot; style=&quot;width: 200px;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그래프의 모양이나 방정식의 형태나 둘다 타원과는 크게 상관 없고, 타원의 둘레를 구하기 위한 적분에서 이름이 유래되었다고 한다.&lt;/p&gt;

&lt;h3 id=&quot;타원-곡선의-연산&quot;&gt;타원 곡선의 연산&lt;/h3&gt;

&lt;p&gt;타원 곡선에서는 두 점에 대한 특이한 덧셈 연산이 존재한다. 점 P와 Q를 타원 곡선에서 더한 결과 R은 아래의 그림과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/elliptic-curve-sum.png&quot; style=&quot;width: 200px;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;P와 Q를 지나는 직선을 긋고 이 직선이 타원 곡선과 만나는 점에 대해서 X축 대칭점이 R의 결과다. P의 좌표를 &lt;script type=&quot;math/tex&quot;&gt;(x_P, y_P)&lt;/script&gt; Q의 좌표를 &lt;script type=&quot;math/tex&quot;&gt;(x_Q, y_Q)&lt;/script&gt;, R의 좌표를 &lt;script type=&quot;math/tex&quot;&gt;(x_R, y_R)&lt;/script&gt;로 두고 R의 좌표를 계산하는 방법은 아래와 같다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
&amp; P + Q = R\\
&amp; \\
&amp;s = \frac{y_P - y_Q}{x_P - x_Q} \\
&amp;x_R = s^2 - (x_P + x_Q) \\
&amp;y_R = s(x_P - x_R) - y_P
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;위 식을 보면 &lt;script type=&quot;math/tex&quot;&gt;y_P&lt;/script&gt; 와 &lt;script type=&quot;math/tex&quot;&gt;y_Q&lt;/script&gt;가 다른데, &lt;script type=&quot;math/tex&quot;&gt;x_P&lt;/script&gt; 와 &lt;script type=&quot;math/tex&quot;&gt;x_Q&lt;/script&gt;가 같으면 s의 값이 무한으로 발산한다는 것을 알 수 있다. 이 말은 P와 Q가 동일한 X 좌표를 갖고 있으면 R의 값을 구할 수 없다는 이야기다. 그림으로만 봐도 구할 수 없게 생겼다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/elliptic-curve-inf.png&quot; style=&quot;width: 200px;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같은 경우 R의 점을 무한점(∞)이라 정의한다. 무한점의 성질에 대해서 한 가지 더 정의하면 타원 곡선의 덧셈 연산 정의가 끝난다. P가 ∞인 경우에 P + Q에 대한 결과 문제다. 이 경우엔 Q를 지나고 X축과 직교하는 선을 그리고 이때 타원 곡선과 만나는 점을 -R로 두고 위와 같은 방식으로 X축과 대칭점인 R을 구한다. 이렇게 구한 값은 Q와 동일하다. 그림으로 보면 이해하기 쉽다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/elliptic-curve-inf-sum.png&quot; style=&quot;width: 200px;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 &lt;script type=&quot;math/tex&quot;&gt;y_P&lt;/script&gt; 와 &lt;script type=&quot;math/tex&quot;&gt;y_Q&lt;/script&gt;가 같고, &lt;script type=&quot;math/tex&quot;&gt;x_P&lt;/script&gt; 와 &lt;script type=&quot;math/tex&quot;&gt;x_Q&lt;/script&gt;도 같은 즉, P를 두번 더한 경우는 어떻게 계산할 수 있을까? 이때는 타원 곡선 위의 점 P와 접하는 직선과 교차하는 점이 R값이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/elliptic-curve-2-sum.png&quot; style=&quot;width: 200px;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이를 수식으로 표현하면 아래와 같다. 이 때 a는 &lt;script type=&quot;math/tex&quot;&gt;y^2 = x^3 + ax + b&lt;/script&gt;의 a값이다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
&amp; P + P = R\\
&amp; \\
&amp;s = \frac{3x_P^2 + a}{2y_P} \\
&amp;x_R = s^2 - 2x_P \\
&amp;y_R = s(x_P - x_R) - y_P
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;위에서 이야기 한 타원 곡선에 대한 연산을 정리하면&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;P와 Q를 지나는 직선과 만나는 점의 X축 대칭점을 R로 계산한다.&lt;/li&gt;
  &lt;li&gt;P와 Q를 지나는 직선이 X축과 직교하면 R은 무한점(∞)이다.&lt;/li&gt;
  &lt;li&gt;무한점(∞)과 점 P를 더하면 결과값 R은 P와 같다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;와 같이 정리할 수 있다. 위 정리를 보면 무한점은 위에서 이야기한 항등원이란 사실을 알 수 있다. 이 때의 역원은 X축의 대칭점일 것이다. 따라서 점 P의 X축 대칭점은 -P라 이야기할 수 있다. 무한점을 포함하면 &lt;script type=&quot;math/tex&quot;&gt;y^2 = x^3 + ax + b&lt;/script&gt;을 지나는 모든 점에 대해 해당 연산은 닫혀 있고, 결합법칙이 성립한다고 한다(이 부분은 증명이 어려움). 따라서 타원 곡선과 무한점을 포함한 집합은 이 연산에 대해서 군을 이룬다.&lt;/p&gt;

&lt;h3 id=&quot;타원곡선의-이산로그-문제&quot;&gt;타원곡선의 이산로그 문제&lt;/h3&gt;

&lt;p&gt;타원곡선의 연산을 사용해서 점 P를 P와 더하는 것을 2P라고 정의한다면 P를 세번 더한 값을 3P로 나타내면 k번 더한 결과 Q를 &lt;script type=&quot;math/tex&quot;&gt;kP&lt;/script&gt;라 나타낼 수 있다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Q = kP = P + P + P + .... + P&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;위에서 이야기 했던 이산로그 문제와 마찬가지로 Modular N에 대한 타원곡선 덧셈군에 대해서 반복 연산인 곱셈의 역연산 값을 추론하기 어렵다.&lt;/strong&gt; 따라서 P와 k를 갖고 Modular N연산을 한 Q를 계산하는 것은 쉽지만, Q와 P만 가지고는 k값을 찾는것은 굉장히 어렵단 이야기다. 예를 들면 타원곡선을 &lt;script type=&quot;math/tex&quot;&gt;y^2 = x^3 + 2x + 2 \mod 17&lt;/script&gt;로 두고 P를 (5, 1)로 정의하자, 이때 결과값 Q를 P를 4번 더한 값은 (3, 1)이 된다. 만약 Q값인 (3, 1)과 P값인 (5, 1)만 보고 몇 번 더한것인지 추론하려 한다면, 이는 굉장히 어렵다는 이야기다(이산로그 문제).&lt;/p&gt;

&lt;p&gt;따라서 일반적인 이산로그 문제와 마찬가지로 P값과 Modular N값을 잘 정의하면, 이를 일반적인 디피 헬만과 마찬가지 방법으로 암호키 교환 알고리즘에 사용할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;타원곡선-디피-헬만&quot;&gt;타원곡선 디피 헬만&lt;/h2&gt;

&lt;p&gt;일반 디피 헬만과 마찬가지로 Alice와 Bob 둘이 통신하고 이를 중간에서 Eve가 훔쳐보고 있다 가정하자. 우선 Alice와 Bob이 각자의 비밀키를 만든다. 이를 &lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\beta&lt;/script&gt;라 하자. 그리고 기준이 되는 타원곡선 함수를 &lt;script type=&quot;math/tex&quot;&gt;y^2 = x^3 + ax + b \mod N&lt;/script&gt;로 정의하고, 기준점을 G라 하자. 그러면 Alice와 Bob, 그리고 훔쳐보는 Eve는 모두 a, b, N, G 값을 알고 있다. 이 때  Alice와 Bob은 각자 공개키를 만들어서 나누어 갖는다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Alice \hspace{50 pt} Eve \hspace{50 pt} Bob \\
A = \alpha G \hspace{50 pt}  \hspace{50 pt} B = \beta G\\
B \hspace{50 pt} A, B  \hspace{50 pt} A\\
K = \alpha B  = \alpha\beta G \hspace{50 pt} K = ?  \hspace{50 pt} K = \beta A = \alpha\beta G\\&lt;/script&gt;

&lt;p&gt;Eve는 A나 B로 부터 &lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\beta&lt;/script&gt;를 추론할 수 없어 K를 구할 수 없지만 Alice와 Bob은 받은 공개키 값을 각자의 비밀키 값과 곱해서 이를 알아낼 수 있다.&lt;/p&gt;

&lt;p&gt;예를 들어보자, 타원곡선을 &lt;script type=&quot;math/tex&quot;&gt;y^2 = x^3 + 2x + 2 \mod 17&lt;/script&gt;로, G를 (5, 1)로 정의하자. 이 때 Alice와 Bob이 스스로 비밀키를 고르고 공개키를 나누는 과정을 보면 아래와 같다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Alice \hspace{50 pt} Eve \hspace{50 pt} Bob \\
\alpha = 3 \hspace{50 pt}  \hspace{50 pt} \beta=9 G\\
A = 3G = (10, 6) \hspace{50 pt}  \hspace{50 pt} B = 9G = (7, 6)\\
B \hspace{50 pt} A, B  \hspace{50 pt} A\\
K = 3B = (13, 7) \hspace{50 pt} K = ?  \hspace{50 pt} K = 9A = (13, 7)\\&lt;/script&gt;

&lt;p&gt;따라서 Eve가 키 값 K를 알아내기 위해선 &lt;script type=&quot;math/tex&quot;&gt;y^2 = x^3 + 2x + 2 \mod 17&lt;/script&gt;의 G에 대한 모든 경우의 수를 알아내 A나 B값을 통해 비밀키를 구할 수 있으면 된다.(이산로그 문제)&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.crocus.co.kr/1231&quot;&gt;모듈러 연산(Modular Arithmetic)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://leeconjecture.wordpress.com/2017/07/06/%EC%9B%90%EB%93%A4%EB%8C%80-1%ED%8E%B8-%EA%B5%B0%EC%9D%98-%EC%A0%95%EC%9D%98%EC%99%80-%EC%95%84%EB%B2%A8%EA%B5%B0%EC%9D%98-%EC%98%88%EC%A0%9C/&quot;&gt;원들대 01: 군의 정의와 아벨군의 예제&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%82%B0_%EB%A1%9C%EA%B7%B8&quot;&gt;이산로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=F3zzNa42-tQ&quot;&gt;Elliptic Curve Diffie Hellman&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 17 Feb 2019 19:10:00 +0900</pubDate>
        <link>https://b.luavis.kr/science/elliptic-curve</link>
        <guid isPermaLink="true">https://b.luavis.kr/science/elliptic-curve</guid>
        
        
        <category>science</category>
        
      </item>
    
      <item>
        <title>알아두면 쓸데없는 신비한 TLS 1.3</title>
        <description>&lt;p&gt;이 글은 계간 잡지 &lt;a href=&quot;https://ridibooks.com/v2/Detail?id=2979000016&quot;&gt;마이크로소프트웨어 394호&lt;/a&gt;에 기고된 글입니다.&lt;/p&gt;

&lt;h2 id=&quot;tls&quot;&gt;TLS&lt;/h2&gt;

&lt;p&gt;우리가 개발하는 서비스 중에서 인터넷에 연결이 필요 없는 서비스는 거의 없다고 봐야한다. 이런 서비스는 우리가 만든 앱 혹은 웹을 통해서 데이터를 받아 서버에 저장한다. 오프라인 모드로 즐기는 게임마저도 장애 로그 또는 통계 데이터를 인터넷 연결로 받는 사례가 늘고있다. 다만 이 데이터에는 굉장히 민감한 정보가 포함돼 있다는 것이 요점이다. 카드 번호나 주소는 기본이고, 심지어 우리 집 거실에 있는 공유기의 맥어드레스까지도 데이터화 돼 전송된다. 그래서 중간에 데이터가 조작되거나 변조되지 않도록 암호화해 데이터를 보내야한다.&lt;/p&gt;

&lt;p&gt;우리는 이런 민감한 정보를 보낼 때 HTTP보다는 HTTPS(‘Secure’를 의미하는 ‘S’)를 사용하라고 배웠다. HTTPS의 안전성은 TLS라는 프로토콜을 통해 보장된다. TLS는 과거 우리가 SSL이라 부르던 프로토콜에서 시작했다. SSL은 1990년대에 브라우저를 개발했던 넷스케이프(Netscape)에서 보안성이 높은 HTTP 통신을 지원하기 위해 만든 프로토콜이다. 넷스케이프가 SSL을 IETF(Internet Engineering Task Force, 국제 인터넷 표준화 기구)에게 양도하면서 바뀐 이름이 TLS 1.0이다. (TLS 1.0은 단순히 이름만 바뀐 것이기 때문에, SSL 3.0과 동일한 프로토콜로 본다.)&lt;/p&gt;

&lt;p&gt;우리가 사용하는 웹브라우저 대부분은 HTTP/2를 사용하기 위해 TLS 사용을 강제하고 있다. 특히 최고의 브라우저 점유율을 갖고 있는 구글 크롬(Google Chrome) 브라우저의 최신 버전에서는 HTTP로 접속하면 ‘안전하지 않은 사이트’라는 경고를 띄운다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/blue-house-tls.png&quot; alt=&quot;Blue House without TLS&quot; /&gt;&lt;/p&gt;

&lt;p&gt;[그림1] 안전하지 않은 청와대&lt;/p&gt;

&lt;p&gt;과거만 해도 TLS/SSL를 사용하기 위해서는 인증서를 구매 해야 했고, 이 구매 비용이 (생각보다) 부담스럽기 때문에 TLS를 사용하지 않는다는 사람들도 있었다. 하지만 이제는 인증서 마저도 렛츠인크립트(Let’s Encrypt) 같은 서비스를 이용하면 무료로 발급받을 수 있다. 이런 추세와 시도로 많은 사이트가 TLS를 사용해 조금 더 안전한 인터넷 세상을 만들 수 있게 변하고 있다.&lt;/p&gt;

&lt;h2 id=&quot;tls-12의-문제점&quot;&gt;TLS 1.2의 문제점&lt;/h2&gt;

&lt;p&gt;TLS의 전신인 SSL은 1990년대에 등장한 프로토콜이다. 초기 SSL을 디자인할 당시에는 설계상 허점으로 인해 구현체가 실제 구현 결과와 다른 부분(Heuristic)이 있었다. 또한 보안 프로토콜에서 발생하는 문제가 어떤 방식인지 자료나 학습이 부족했다. 허점이 발견된(Heuristric) 부분이나 문제가 되는 부분은 구현체가 만들어지는 과정에서 많이 고쳐지면서 현재의 TLS 1.2가 탄생했다. 하지만 TLS의 설계적인 허점과는 별개로 TLS와 관련된 직간접적인 보안 이슈가 많이 발생했다.&lt;/p&gt;

&lt;p&gt;가장 먼저 떠오르는 보안 관련 이슈로 하트블리드(Heartbleed, CVE-2014-0160)가 있다. 하트블리드는 많은 언어, 프레임워크, 서버 프로그램에서 TLS연결을 위해 사용하던 오픈소스 라이브러리인 OpenSSL에서 발생한 버퍼 오버플로우(BOF) 버그다. 엄밀하게는 TLS 구현체 자체에서 해결해야하는 문제점이므로 TLS와는 상관 없다고 할 수 있다. (OpenSSL은 ‘BERserk’, ‘goto fail;’ 등 구현체 수준의 다른 문제도 제기됐다.)&lt;/p&gt;

&lt;p&gt;하지만 TLS 프로토콜 자체에도 문제점이 있다. 이론적인 레벨도 있지만 ‘LogJam(CVE-2015-4000)’, ‘FREAK(CVE-2015-0204, CVE-2015-1637, CVE-2015-1067), ‘SWEET32(CVE-2016-2183)’ 같은 위협적인 문제도 있고, 실제 적용할 수 있는 ‘POODLE(CVE-2014-8730)’과 ‘ROBOT’과 같은 문제점들도 있다.&lt;/p&gt;

&lt;h2 id=&quot;tls-12는-느리다&quot;&gt;TLS 1.2는 느리다&lt;/h2&gt;

&lt;p&gt;TLS의 가장 최신 버전이었던 ‘1.2’는 2008년에 나왔다. 2008년 당시 네이버를 떠올려보자. 그 시절 네이버는 로그인 서비스 같은 보안이 중요한 부분을 제외하고는 평문(Plaintext)으로 서버와 클라이언트가 통신했다. 하지만 최근 추세는 조금 다르다. 지금은 모든 페이지를 TLS로 서비스하고 있다.&lt;/p&gt;

&lt;p&gt;당연히 이런 노력은 긍정적인 변화로 봐야 한다. 중간에서 통신을 도청당해도 안전하고, 인젝션(Injection)과 같은 공격도 걱정할 필요가 없다. 다만 단점은 새로운 연결을 맺기까지 조금 느려진다. TLS는 처음 커넥션을 핸드셰이크(Handshake)라 부르는 과정을 통해서 암호화 방식이나 암호화 키를 교환한다. 이를 위해 클라이언트와 서버 간 라운드 트립(Round Trip)이 2회 정도 추가된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      Client                                               Server

      ClientHello                  --------&amp;gt;
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   &amp;lt;--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     --------&amp;gt;
                                               [ChangeCipherSpec]
                                   &amp;lt;--------             Finished
      Application Data             &amp;lt;-------&amp;gt;     Application Data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;[그림2] TLS 1.2(RFC5246)의 전체 핸드셰이크 과정&lt;/p&gt;

&lt;p&gt;엄청난 차이라고 느끼지 않을 수도 있다. 하지만 서버와 클라이언트가 서로 지구 반대편에 있는 최악의 상황을 떠올려 보자. 데이터가 빛의 속도로 움직인다고 가정하면, 빛이 지구 반대편에 도달하고 다시 돌아오는데 걸리는 시간은 약 133ms다. 이를 2번 시행하면 매번 커넥션을 열 때마다 약 270ms가 지연(Delay)된다. 당연히 이 지연 현상은 비용으로 추가된다.&lt;/p&gt;

&lt;h2 id=&quot;tls-13은-다른가&quot;&gt;TLS 1.3은 다른가?&lt;/h2&gt;

&lt;p&gt;TLS 1.3 표준은 IETF의 RFC 8446에서 맡고 있다. 더 빠르고 안전한 인터넷을 만들기 위해 4년간 논의하고 28회의 초안을 거쳤다. 문제점이 제기된 암호화 방식을 버리고, 핸드셰이크 과정을 최소화해 암호화 통신하는 방법을 추가했다. TLS 1.3의 큰 차이점은 다음과 같다.&lt;/p&gt;

&lt;h3 id=&quot;tls-13의-특징&quot;&gt;TLS 1.3의 특징&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;핸드셰이크에 ‘0-RTT’ 모드 추가.&lt;/li&gt;
  &lt;li&gt;정적인 RSA와 디피-헬먼 암호화 스위트(Diffie-Hellman Cipher Suite) 제거.&lt;/li&gt;
  &lt;li&gt;핸드셰이크를 가능한 최대한 암호화.&lt;/li&gt;
  &lt;li&gt;타원 곡선 알고리즘을 기본으로 지원.&lt;/li&gt;
  &lt;li&gt;키 교환과 암호화 방식을 암호화 스위트(Cipher Suite)방식이 아니라, 개별적으로 결정.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;TLS 1.2와 1.3의 성능과 안전성 차이는 뒤에서 자세히 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;더-이상-묶음-판매-안-합니다&quot;&gt;더 이상 묶음 판매 안 합니다.&lt;/h2&gt;

&lt;p&gt;이전의 TLS에서는 핸드셰이크 과정에서 암호화 스위트(Cipher Suite)라는 묶음으로 인증과 키 교환 방법을 정했다. 핸드셰이크 과정에는 서로 합의해야 하는 알고리즘이 4가지가 있다. 대칭키 교환 방식, 인증서 서명 방식, 대칭키 알고리즘, HMAC 알고리즘이다. TLS에서는 서버와 클라이언트가 이 4가지 알고리즘을 묶음으로 합의하고, 합의된 알고리즘으로 애플리케이션 계층(Application Layer)의 내용을 암호화해서 전송한다.&lt;/p&gt;

&lt;p&gt;보통 암호화 스위트는 [그림3]의 ‘TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384’와 같이 대문자로 표기한다. [그림3] 예시는 다음과 같은 내용이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대칭키 교환 방식은 ECDHE(Elliptic Curve Diffie Hellman Ephemeral)을 사용.&lt;/li&gt;
  &lt;li&gt;인증서 서명 방식은 RSA로 서명된 인증서로 상호 간의 신원을 확인.&lt;/li&gt;
  &lt;li&gt;대칭키 암호화 알고리즘은 AES 256bit와 GCM을 사용.&lt;/li&gt;
  &lt;li&gt;HMAC 알고리즘으로는 SHA-384를 사용해서 메시지의 무결성을 확인.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/cipher-suite.png&quot; alt=&quot;Tranditional cipher suite&quot; /&gt;
[그림3] 암호화 스위트 표기 예시&lt;/p&gt;

&lt;p&gt;암호화 스위트는 여러 종류가 있다. 그 중에서 클라이언트(Client)가 지원하면서 취약하지 않은 암호화 스위트의 리스트를 서버에게 알려주면, 서버는 그 중에 지원하는 암호화 스위트를 선택해 합의한다. 실제 구현에서는 &lt;그림5&gt; 예시 같은 문자열이 아니라, 각 암호화 스위트마다 IANA(Internet Assigned Numbers Authority, 인터넷 할당 번호 관리기관)에서 지정한 2바이트(Bytes)를 사용한다. 문제는 키 교환, HMAC 알고리즘, 암호화 알고리즘 등 각 부분이 다양해지기 시작했다. HMAC 함수만 해도 SHA-1, SHA-128, SHA-384, SHA-256, MD5와 같은 방법이 있고 암호화 방식도 AES, DES, RC4와 같은 방법이 있다. 조합마다 코드를 만들기에는 너무 다양하고, 이미 존재하는 구성요소라 해도 새로운 조합법이 나올 때마다 업데이트해야 하므로 구현체에도 부담이 된다.&lt;/그림5&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/new-cipher-suite.png&quot; alt=&quot;New cipher suite&quot; /&gt;
[그림4] TLS 1.3의 암호화 스위트 합의 예시&lt;/p&gt;

&lt;p&gt;TLS 1.3에서는 이런 문제를 해결하기 위해, 암호화 스위트의 각 부분을 나눠서 합의한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;암호화 알고리즘&lt;/li&gt;
  &lt;li&gt;키 교환 방법&lt;/li&gt;
  &lt;li&gt;인증서 서명 알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;암호화 알고리즘, 키 교환 방법, 인증서 서명 알고리즘을 각각 합의함으로써 앞으로 등장할 수 있는 방식에 유연하게 대처할 수 있다. 게다가 핸드셰이크는 2번 발생하는 라운드 트립을 1번으로 줄일 수 있게 만들었다.&lt;/p&gt;

&lt;h2 id=&quot;1-rtt-handshake&quot;&gt;1-RTT Handshake&lt;/h2&gt;

&lt;p&gt;TLS 1.2는 커넥션을 하나 생성하면 라운드 트립을 2번 거쳐서 핸드셰이크해야 한다. TLS 1.3에서는 암호화 스위트 선택 방법을 최대한 단순화했다. 그리고 키 교환 방식으로 RSA를 배제해서 옵션 또한 최대한 줄였다. 그래서 클라이언트는 시작부터 키 교환 방식으로 DH를 사용한다고 가정할 수 있게 됐다. DH도 여러 가지 방식(X25519, P256 등)이 있지만, RSA나 그 외의 방식까지 고려해서 서버에게 여러 가지 키 교환 방식의 지원 여부를 물어봐야 했던 과거에 비해 훨씬 간단하게 추측할 수 있다.&lt;/p&gt;

&lt;p&gt;RFC 문서에 나와 있는 TLS 1.3의 전체 핸드셰이크를 1.2와 비교하면 쉽게 이해할 수 있다. TLS 1.2에서는 커넥션이 맺어지면, 클라이언트는 ‘ClientHello’를 보내서 클라이언트가 지원하는 암호화 스위트 목록을 보낸다. 서버는 그중 하나 선택해서 ‘ServerHello’ 메시지를 보낸다. 만약 디피-헬먼 방식을 이용해 키를 교환한다면 서버의 공개키(Public Key)도 동시에 보낸다.&lt;/p&gt;

&lt;p&gt;앞에서 이야기한 것처럼 TLS 1.3에서는 암호화 방식을 각각 합의한다. 그리고 키 교환 방식도 ECDHE 혹은 DH만을 지원한다. 따라서 클라이언트는 시작할 때부터 ‘ClientHello’를 보낼 때 지원하는 키 교환 방식에 해당하는 모든 방법을 TLS 핸드셰이크 확장기능(TLS Handshake extension)인 ‘key_share’와 함께 동시에 보낸다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        Client                                               Server

        ClientHello
        + key_share             --------&amp;gt;
                                                  HelloRetryRequest
                                &amp;lt;--------               + key_share
        ClientHello
        + key_share             --------&amp;gt;
                                                        ServerHello
                                                        + key_share
                                              {EncryptedExtensions}
                                              {CertificateRequest*}
                                                     {Certificate*}
                                               {CertificateVerify*}
                                                         {Finished}
                                &amp;lt;--------       [Application Data*]
        {Certificate*}
        {CertificateVerify*}
        {Finished}              --------&amp;gt;
        [Application Data]      &amp;lt;-------&amp;gt;        [Application Data]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;[그림5] TLS 1.3 (RFC8446) 전체 핸드셰이크 과정&lt;/p&gt;

&lt;p&gt;예를 들어, 크롬 브라우저에서 TLS 1.3을 사용한다면 ‘ECDHE X25519’ 키 교환 방식을 서버가 지원한다고 가정하고 보낸다.&lt;/p&gt;

&lt;h2 id=&quot;0-rtt-resumption&quot;&gt;0-RTT Resumption&lt;/h2&gt;

&lt;p&gt;HTTP/1.1만 지원하는 서버에 브라우저가 접속하면, 동시에 리소스를 받아오기 위해서 TCP 커넥션(TCP Connection)을 만든다. (크롬 브라우저의 경우 6개를 만든다.)만약 해당 서버가 TLS를 사용 중이라면, TCP 커넥션을 만들 때마다 TLS 핸드셰이크 과정을 거쳐야 해, 굉장히 많은 리소스를 소모해야 한다. 그래서 TLS 1.2에서는 처음 핸드셰이크 과정을 거칠 때 ‘Session id’를 받아둔 후, 다시 핸드셰이크할 때 ‘Session id’와 서로 교환했던 키를 이용해 핸드셰이크를 마무리한다. 하지만 ‘Session id’를 이용해 TLS 핸드셰이크를 다시 진행할 때는 라운드 트립이 1번 발생해야 한다. TLS 1.3에서는 이 부분을 개선해 라운드 트립이 발생하지 않도록 만들었다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      Client                                                Server

      ClientHello                   --------&amp;gt;
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    &amp;lt;--------             Finished
      [ChangeCipherSpec]
      Finished                      --------&amp;gt;
      Application Data              &amp;lt;-------&amp;gt;     Application Data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;TLS 1.2 (RFC5246) 약식 핸드셰이크&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;         Client                                               Server

         ClientHello
         + early_data
         + key_share*
         + psk_key_exchange_modes
         + pre_shared_key
         (Application Data*)     --------&amp;gt;
                                                         ServerHello
                                                    + pre_shared_key
                                                        + key_share*
                                               {EncryptedExtensions}
                                                       + early_data*
                                                          {Finished}
                                 &amp;lt;--------       [Application Data*]
         (EndOfEarlyData)
         {Finished}              --------&amp;gt;
         [Application Data]      &amp;lt;-------&amp;gt;        [Application Data]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;TLS 1.3(RFC8446) 0-RTT 핸드셰이크&lt;/p&gt;

&lt;p&gt;[그림6] TLS 1.2와 TLS 1.3 비교&lt;/p&gt;

&lt;p&gt;TLS 1.3의 핸드셰이크는 키 하나를 만들어서 공유한다. 이 키를 PSK(Pre-Shared Key)라 부른다. 이를 암호화된 통신으로 주고받으면, 다음 커넥션이 맺어질 때 진행하는 핸드셰이크에서는 클라이언트가 PSK와 애플리케이션 데이터(Application Data)를 포함 시켜서 보낸다. (애플리케이션 계층이 HTTP라면 HTTP로 요청한다.) TLS 1.3에서 0-RTT 재개(0-RTT Resumption) 방식으로 TLS 핸드셰이크 과정을 거친다면, 핸드셰이크를 위한 클라이언트-서버 간 통신 없이도 새로운 TCP 커넥션을 맺을 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;강력한-안전성-추구&quot;&gt;강력한 안전성 추구&lt;/h2&gt;

&lt;p&gt;RSA를 사용하면 클라이언트가 핸드셰이크 초반에 서버로 RSA 공개키를 요청해야 하고, 공개키를 받은 후 대칭키를 서로 공유하는 커넥션을 다시 한번 맺어야 한다. 즉, 앞에서 이야기한 방법처럼 라운드 트립 1번으로 핸드셰이크를 마칠 수 없게 된다. 그래서 TLS 1.3은 더는 RSA를 이용한 키 교환 방식을 지원하지 않는다.&lt;/p&gt;

&lt;p&gt;RSA를 더는 지원하지 않는 이유에는 보안 취약성도 있다. RSA 키 교환 방식은 서버가 본인의 인증서를 CA(Certificate Authority)로부터 받는 공개키-비밀키 쌍을 가지고 키를 교환한다. 이는 현재 서버 어딘가에 RSA의 고정 된 비밀키가 저장돼 있다는 이야기다. 만약 누군가가 모든 통신 과정을 감청하고 있고, 이를 저장해뒀다가 서버의 치명적인 취약점을 발견해서 비밀키가 탈취된다면, 감청한 데이터를 해독할 수 있다. 현실성이 떨어져 보이지만, 국가 단위에서는 충분히 가능한 방법이다. 이런 문제점을 RSA가 PFS(perfect forward secrecy)가 아니라고 이야기한다.&lt;/p&gt;

&lt;p&gt;TLS 1.3에서 사용하는 디피-헬먼(Diffie-Hellman)은 정적인 디피-헬먼은 지원하지 않고, 일시적인 디피-헬먼(Ephemeral Diffie-Hellman)만 지원한다. 이는 서버와 클라이언트가 키를 교환하기 위한 비밀키를 매번 바꿔서 사용한다는 의미다. 비밀키를 매번 바꾸기 때문에, 서버와 클라이언트가 감청당하더라도 서버가 나중에 해킹당했을 때 이전의 통신한 내용을 해독할 수 없다.&lt;/p&gt;

&lt;p&gt;TLS 1.2에서 문제가 됐던 많은 키 교환 방식이나 암호화 방식을 1.3에서는 없애버렸다. 그 중에는 오래된 RC4, DES, 3DES 같은 것이 있고, MD5나 SHA-1과 같이 취약한 MAC 함수도 더 이상은 지원하지 않는다. 1.2에서는 취약한 암호화 스위트를 지원하지 않도록 설정해야 했다. 그렇지 않으면 중간자가(Man in the Middle) 클라이언트에서 취약한 암호화 스위트만 지원하는 것처럼 행동해 공격하는 경우가 있다. 하지만 1.3에서는 이미 취약하다고 알려진 암호화를 삭제함으로써 서버 관리자의 관리 이슈가 줄어들었다.&lt;/p&gt;

&lt;h2 id=&quot;tls-13-지원&quot;&gt;TLS 1.3 지원&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/tls1.3-caniuse.png&quot; alt=&quot;TLS 1.3 Can I use&quot; /&gt;
[그림7] 브라우저별 TLS 1.3 지원 현황&lt;/p&gt;

&lt;p&gt;크롬 브라우저는 63버전부터 TLS 1.3을 지원한다. 그 외에도 안드로이드용 크롬 브라우저와 파이어폭스(Firefox)에서도 TLS 1.3을 지원한다. 현재까지 TLS 1.3을 지원하지 않는 브라우저는 MS 엣지(MS Edge)와 인터넷 익스플로러(Internet Explorer), 오페라(Opera) 등이 있다. (MS 엣지는 개발 중이다.)&lt;/p&gt;

&lt;p&gt;애플 사파리는 기본적으로 지원하지 않지만, macOS High Sierra의 Safari 11.1버전에서는 &lt;코드1&gt;의 명령어를 입력하면 TLS 1.3을 지원하도록 설정할 수 있다.&lt;/코드1&gt;&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;defaults write /Library/Preferences/com.apple.networkd tcp_connect_enable_tls13 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;[코드1] Safari 11.1에서 TLS 1.3을 활성화 하는 명령어&lt;/p&gt;

&lt;p&gt;서버 프로그램 중 엔진엑스(Nginx)는 1.13버전 부터 TLS 1.3을 지원하고 있으므로 ‘ssl_protocols’ 설정에 1.3만 추가해주면 된다. 아파치(Apache)에서는 TLS 1.3을 지원하는 OpenSSL이 이제 막 나온 단계라 아직 지원하지 않는다. 그리고 MS의 IIS도 아직 TLS 1.3을 지원하지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;그래서-지금-당장-써도-될까&quot;&gt;그래서 지금 당장 써도 될까?&lt;/h2&gt;

&lt;p&gt;TLS같이 인터넷 연결 과정에서 중추가 되는 프로토콜은 많은 장비가 관여하고 있어서 함부로 버전을 올리기에는 부담이 클 수 있다. TLS 1.3에서는 이런 부분을 고려해 완벽하게 하위 호환될 수 있도록 제작했다. TLS 1.3은 드래프트(Draft) 과정을 거치면서 많은 테스트 과정을 거쳤고, 점유율이 가장 높은 크롬 브라우저가 이를 지원하고 있다. CDN/DNS 제공 업체인 클라우드플레어(Cloudflare) 외 페이스북(Facebook)과 인스타그램(Instagram)도 TLS 1.3을 지원하고 있다.&lt;/p&gt;

&lt;p&gt;TLS 1.3은 이전 버전에서 가지고 있던 많은 레거시(Legacy)를 없애면서 더 안전하고 빠른 프로토콜이 됐다. TLS 1.2에서 노출된 취약점과 위협요소가 언제 우리를 위협할지 알 수 없다. TLS 1.3을 조금이라도 빨리 적용해서, 발생할 수 있는 보안사고를 미리 예방하는게 좋지 않을까?&lt;/p&gt;

&lt;iframe src=&quot;https://player.vimeo.com/video/177333631&quot; width=&quot;640&quot; height=&quot;360&quot; frameborder=&quot;0&quot; webkitallowfullscreen=&quot;&quot; mozallowfullscreen=&quot;&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;[참고1] &lt;a href=&quot;https://vimeo.com/177333631&quot;&gt;TLS 1.3 - CloudFlare London Tech Talk&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.cloudflare.com/rfc-8446-aka-tls-1-3&quot;&gt;blog.cloudflare.com/rfc-8446-aka-tls-1-3&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://kinsta.com/blog/tls-1-3&quot;&gt;kinsta.com/blog/tls-1-3&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc8446#section-2.2&quot;&gt;tools.ietf.org/html/rfc8446#section-2.2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc5246#section-7.4.1.2&quot;&gt;tools.ietf.org/html/rfc5246#section-7.4.1.2&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 15 Dec 2018 13:28:00 +0900</pubDate>
        <link>https://b.luavis.kr/server/tls-1.3</link>
        <guid isPermaLink="true">https://b.luavis.kr/server/tls-1.3</guid>
        
        
        <category>server</category>
        
      </item>
    
      <item>
        <title>Static type의 맹점</title>
        <description>&lt;p&gt;이 글은 “Programming JavaScript Applications” (O’Reilly)의 저자 &lt;a href=&quot;https://medium.com/@_ericelliott&quot;&gt;Eric Elliott&lt;/a&gt;의 &lt;a href=&quot;https://medium.com/javascript-scene/the-shocking-secret-about-static-types-514d39bf30a3&quot;&gt;The Shocking Secret About Static Types&lt;/a&gt;을 번역한 글 입니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TL;DR&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;정말 버그를 줄이고 싶다면 TDD를 사용하세요. 멋진 툴과 함께 하고 싶은것 이라면 static type을 사용해보세요.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;static-type은-만병통치약인가&quot;&gt;static type은 만병통치약인가?&lt;/h2&gt;

&lt;p&gt;Typescript의 인기는 폭발적으로 증가해왔습니다. 저는 Typescript와 static type을 좋아합니다.(사내 프로젝트를 Typescript로 진행했고 typing을 선호합니다.) 하지만 Typescript를 단순히 타입 시스템 때문에 사용하는 것이 아니라 다른 훌륭한 기능 때문에 사용합니다. Typescript는 명칭적 타이핑(Nominal)보다는 구조적 타이핑(Structural)에 가깝습니다.(&lt;a href=&quot;https://medium.com/@thejameskyle/type-systems-structural-vs-nominal-typing-explained-56511dd969f4&quot;&gt;Nominal typing과 Structural typing의 차이에 대해서&lt;/a&gt;) 이 말인즉슨 타입의 이름이나 식별자를 기반으로 한 타입 시스템이라기 보다는 duck typing이 자동화되어 동작하는것에 가깝다는 의미입니다. 이는 Javascript와 같은 동적인 언어의 장점을 잘 살린 부분입니다.&lt;/p&gt;

&lt;p&gt;사람들이 오해하는 것 중에 하나가 Typescript가 실제로 해결할 수 없는 문제를 해결해 줄 것이라 믿는 것 입니다.&lt;/p&gt;

&lt;p&gt;Typescript의 가장 강한 강점으로 소개하는 내용은 “대규모의 웹 애플리케이션은 static type 없이는 힘들다.” 입니다. Typesciprt를 통해 static type을 사용하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;jump to definition&lt;/code&gt;이나 &lt;code class=&quot;highlighter-rouge&quot;&gt;automatic refactoring&lt;/code&gt;과 같은 기능을 사용할 수 있도록 만들어줍니다. 그리고 이런 기능은 우리의 생산성이 높아진 것처럼 느끼게 해줍니다.(그리고 실제로도 더 생산적이게 만들어 줍니다.)&lt;/p&gt;

&lt;p&gt;하지만 많은 사람들은 static type을 사용하면 애플리케이션의 버그가 줄어드는데에 도움을 줄 것이라고 믿습니다. static type을 사용하면 중대한 버그는 잡을 수 있습니다. 이는 부정하기 힘든 사실입니다. 하지만 정말로 static type은 전반적으로 버그율을 낮추는데 도움이 될까요?&lt;/p&gt;

&lt;h2 id=&quot;static-type은-거짓된-안정감을-줍니다&quot;&gt;static type은 거짓된 안정감을 줍니다.&lt;/h2&gt;

&lt;p&gt;두 가지의 &lt;a href=&quot;https://labs.ig.com/static-typing-promise&quot;&gt;연구&lt;/a&gt; &lt;a href=&quot;http://macbeth.cs.ucdavis.edu/lang_study.pdf&quot;&gt;자료&lt;/a&gt;에서 Github의 데이터를 사용해 얼마나 많은 버그율을 갖고 있는지 조사했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/bug-density-100-stars.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;확실히 말하기는 힘들지만 위 차트에서는 강력한 타입언어가 우리가 버그를 덜 만들도록 만들어 준다고 확신하기는 어렵다. -  Daniel Lebrero, “The Broken Promise of Static Typing”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;좀 더 권위있는 연구에서는 Static type이 조금 더 도움이 된다고 이야기하고 있습니다: “A Large Scale Study of Programming Languages and Code Quality in Github” from Baishakhi Ray, Daryl Posnett, Vladimir Filkov, Premkumar T Devanbu, from UC Davis.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터를 통해서 절차지향 언어보다는 함수형 언어가, 약한 타이핑보다는 강한 타이핑이, 동적 타입보다는 정적 타입이 그리고 unmanaged memory보다는 managed memory가 더 버그를 적게 만든다는 것을 알 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;여기까지만 보면 Static type이 더 좋다는 이야기 같지만,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이 관계들은 통계적으로는 &lt;strong&gt;중요하지만 영향도는 좀 적었다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;제게도 static type이 버그를 줄이는데 중대한 역할을 한 경험적 증거가 없습니다. 개발자가 사용할 수 있는 멋진 개발툴과 static type은 실제로 전반적인 버그를 잡는데에 도움이 되지 않습니다.&lt;/p&gt;

&lt;h2 id=&quot;타입의-정확도는-프로그램의-정확도를-보장하지-않습니다&quot;&gt;타입의 정확도는 프로그램의 정확도를 보장하지 않습니다.&lt;/h2&gt;

&lt;p&gt;코드를 실제로 돌려보지 않고서는 이 코드가 진짜 동작할지 전혀 알 수가 없습니다. 물론 static type을 사용하면 변수가 선언되지 않았느지, object가 넘어가야할 함수 파라미터에 array가 넘어갔다던지 이런 문제는 해결할 수 있습니다. 하지만,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;타입 체크만으로는 잡을 수 없는 버그가 수없이 많습니다. 그리고 …&lt;/li&gt;
  &lt;li&gt;이걸 잡을 수 있는 다른 여러가지 방법이 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;그래서-정말로-버그를-잡을-수-있는-효과적인-방법은-뭔가요&quot;&gt;그래서 정말로 버그를 잡을 수 있는 효과적인 방법은 뭔가요?&lt;/h2&gt;

&lt;p&gt;테스트 주도 개발!(Test Driven Development, TDD) 특히 테스트 우선 방법론!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TDD만이 구원이다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;몇몇 좋은 연구에서 TDD의 효과에 대해서 이야기하고 있습니다. Microsoft, IBM, 그리고 Springer 같은 유명한 곳에서 나온 &lt;a href=&quot;https://link.springer.com/article/10.1007%2Fs10664-008-9062-z&quot;&gt;연구&lt;/a&gt;도 있습니다. Springer의 연구에서는 비슷한 두 프로젝트 중에서 테스트 우선적인 방법을 사용해서 개발한 프로젝트가 40%-90%의 버그가 줄어들었다고 합니다. 테스트를 우선해서 개발했을 때와 테스트를 개발 후에 했을때, 테스트를 전혀 안 했을때를 비교한 Springer 이외의 다른 &lt;a href=&quot;https://www.computer.org/csdl/mags/so/2007/03/s3024.pdf&quot;&gt;연구에서도&lt;/a&gt; 비슷한 결과를 보여줍니다. 특히 테스트 우선 개발시에는 탁월한 버그 감소율을 보여주는데 40%-80%의 버그가 줄어듭니다.&lt;/p&gt;

&lt;p&gt;TDD야 말로 버그를 반으로 줄여주는 가장 효과적인 방법입니다. 그리고 이 주장을 뒷받침해주는 많은 사례들이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;그래서-typescript를-쓰지-말라는-말인가&quot;&gt;그래서 Typescript를 쓰지 말라는 말인가?&lt;/h2&gt;

&lt;p&gt;그럼에도 우리는 static type을 사용하고 싶습니다. 그러나 이 선택지를 고르는 이유가 Typescript가 주는 굉장한 기능들 때문이여야하지 버그를 잡아줄 것이라 기대하면서 사용하면 안됩니다.&lt;/p&gt;

&lt;p&gt;standard javascript에 타입 표시 기능을 추가한 &lt;a href=&quot;https://github.com/ericelliott/rtype&quot;&gt;rtype&lt;/a&gt;에 영향을 받은 Typescript의 첫 인상은 굉장했습니다. 하지만 사용을 적극 권장하지 않는데에는 몇 가지 이유가 있습니다.&lt;/p&gt;

&lt;p&gt;코드를 Typescript로 작성하기에는 거부감이 드는것은 단지 ECMAScript 표준과 Typescript와 키워드, 타입 기능들이 충돌하는 것 때문이 아닙니다.(&lt;code class=&quot;highlighter-rouge&quot;&gt;interface&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;implements&lt;/code&gt;와 같은 키워드)&lt;/p&gt;

&lt;p&gt;Typescript의 장점 중 하나는 이런 충돌이 생긴다 하더라도, 컴파일러가 충분히 번역해서 ECMAScript에 맞는 표준으로 다르게 컴파일 할 수 있다는 점입니다. 하지만 단점으로는 Javascript 표준으로 더 이상 작성하지 않는다는 점입니다. 제 예상으로는 Typescript가 Javascript의 superset자리를 계속 유지한다기 보다는 다른 형태로 갈라져 나올것이라 생각합니다.&lt;/p&gt;

&lt;p&gt;그리고 제게는 이 부분이 굉장히 걱정하는 부분입니다. Javascript를 가르치는 입장에서 많은 개발자들이 사용하는 다양한 개발툴과 개발 프레임워크에 적용가능한 것을 가르치고 싶습니다. 여러분은 이런 점을 걱정하지 않겠지만, 여러분의 코드는 다른 개발자에게도 읽고 배우기 쉬워야하고 무엇보다 그 코드에 기여하기 쉬워야합니다. 당신 혼자는 Typescript에 적응했을지 모르지만 그 외의 다른 사람들은 Typescript에 적응하기 어려울 수 있습니다.&lt;/p&gt;

&lt;p&gt;지금 당장에는 엄청난 속도로 Typescript가 성장해나가고 있지만, 전체 Javascript의 환경에 비해서는 아직 작습니다. 심지어 jQuery보다도. 물론 성장해 나아가는 속도는 놀랍고, Javascript로 컴파일 가능한 대체제(Coffeescript, …) 중에서는 지배적인 위치에 다다랐습니다.&lt;/p&gt;

&lt;p&gt;어떤 도구는 단점을 알고도 사용하기에 가치있지만, Typescript는 제게는 지금 당장 사용하기엔 올바르지 않은것 같습니다. 하지만 MS의 Code와 Typescript의 궁합은 한 번쯤은 사용해봐도 좋습니다. 맘에 들것을 확신합니다.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;버그를 줄여주는 점을 강점으로 보기에는&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Static type는 과대평가되어 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;그러나 다른 기능들과 함께 보면 static type은 여전히 멋지고 사용하기에 가치가 있습니다.
결론을 내자면,&lt;/p&gt;

&lt;h3 id=&quot;정말-버그를-줄이고-싶다면-tdd를-사용하세요-멋진-툴과-함께-하고-싶은것-이라면-static-type을-사용해보세요&quot;&gt;정말 버그를 줄이고 싶다면 TDD를 사용하세요. 멋진 툴과 함께 하고 싶은것 이라면 static type을 사용해보세요.&lt;/h3&gt;
</description>
        <pubDate>Fri, 10 Aug 2018 11:07:00 +0900</pubDate>
        <link>https://b.luavis.kr/web/the-shocking-secret-about-static-types</link>
        <guid isPermaLink="true">https://b.luavis.kr/web/the-shocking-secret-about-static-types</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>알아두면 쓸데없는 신비한 TLS</title>
        <description>&lt;h2 id=&quot;tls란&quot;&gt;TLS란,&lt;/h2&gt;

&lt;p&gt;초기에 HTTP 통신은 암호화되지 않은 통신이었다. 당연히 문제가 되었고, 이 문제를 보완하고자 Netscape사는 browser에서 사용하기 위한 규격인 SSL을 제작했다. SSL은 널리 보급되었고, 나중엔 HTTP 외에 다른 Application layer protocol에서도 사용가능하도록 만든 protocol이 TLS(Transport Layer Security)다.&lt;/p&gt;

&lt;p&gt;TLS는 크게 2단계로 구분할 수 있는데, 서로 protocol 버전과 암호화할 키를 주고 받는 &lt;strong&gt;handshake 단계&lt;/strong&gt;와 실제 &lt;strong&gt;application이 동작하는 단계&lt;/strong&gt;다. application의 내용이 주고 받아지는 부분에서는 대칭키 암호화(symmetric cryptography)가 이루어지지만, handshake 단계에서는 모든 내용이 평문으로 주고 받게 된다 (TLS 1.3부터는 handshake 중에도 암호화가 됨).&lt;/p&gt;

&lt;p&gt;TLS의 동작 원리까지 깊이 알 필요는 없고, 오히려 handshake 과정에서 필요한 개념들이 응용이 가능하거나, SSL 인증서 발급할때 내가 무슨짓을 하고 있는건지 알 수 있을 것이다. 이 글에서는 TLS가 필요로 하는 다양한 표준, 암호화 방법에 대해서 이야기 하고, TLS 동작에 대해서는 간략하게 이야기할 것이다(자세한 내용이 궁금하면 구현체 소스를 보자).&lt;/p&gt;

&lt;h2 id=&quot;hmac&quot;&gt;HMAC&lt;/h2&gt;

&lt;p&gt;메시지를 두 peer간 통신을 할 때 메시지의 내용이 손상될 수 있다. 메시지의 손상 여부를 파악하기 위해서 사용하는 기술이 MAC(Message Authentication Code)이다. 그 중 TLS에서는 HMAC(Hash MAC)이라는 방법을 사용한다.
만약 A라는 메시지의 내용을 보낸다고 가정하고, 송신 peer는 A를 수신 peer와 합의한 Hash함수를 이용해서 hash 값을 만들고 메시지 A에 hash 덧붙인 A`을 보낸다. 이를 수신 측 peer에서는 A와 hash값을 분리하고 A의 hash 값을 구한 뒤 받은 값과 비교해, 제대로 메시지가 도착했는지 검증한다.&lt;/p&gt;

&lt;h2 id=&quot;디지털-서명digital-signature&quot;&gt;디지털 서명(Digital signature)&lt;/h2&gt;

&lt;p&gt;월세 계약과 같은 부동산 계약을 하고 나면 계약서에 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%99%95%EC%A0%95%EC%9D%BC%EC%9E%90&quot;&gt;확정일자&lt;/a&gt;란 것을 받는다. 확정일자는 공증인(여기서는 국가가 된다)이 해당 계약내용을 확인하고 증명해주는 것이다. 확정일자를 받으면 도장 혹은 공증서를 받게 되는데, 이 개념을 컴퓨터 파일에 적용한 것이 디지털 서명이다. 신뢰 받는 기관(Root CA와 같은)에서 내 문서가 사실임을 확인 받고 다른 사람들도 이 사실이 진짜임을 확인 가능하게 해주는 체계이다.&lt;/p&gt;

&lt;p&gt;일반적인 디지털 서명은 RSA 알고리즘을 이용한다. 모두에게 신뢰 받는 기관에서는 요청자의 문서의 hash 값을 구하고 RSA 개인키로 암호화한다. 그리고 암호화한 값(서명)을 해당 문서 뒤에 첨부한다.
이 문서를 받은 사람은 서명한 기관의 공개키로 서명을 복호화한다(여기서 모두가 신뢰 받는 기관의 공개키는 알고 있다). 그리고 서명을 제외한 나머지 부분을 같은 hash 함수로 hash 값을 구하고 복호화한 서명과 비교한다. 일치한다면 해당 문서는 위변조가 없고, 신뢰 받은 기관에서 서명 받은 문서라고 판단할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;chain-of-trust&quot;&gt;Chain of trust&lt;/h2&gt;

&lt;p&gt;모든 도메인을 한 두 곳의 신뢰받는 기관에서 인증해주면 좋겠지만, 현실적인 한계가 있다. 그래서 client가 알고 있는 수많은 신뢰받는 기관이 있고 이 기관을 대행할 중간 인증 기관들이 있다. 이 중간 인증 기관은 신뢰받고 있는 기관(Root CA)로 부터 인증서를 발급 받고, 중간 인증 기관은 그 하위의 중간 인증 기관을 인증해주는 과정을 거쳐서 최종적으로 내 사이트를 인증해 주는 chain 형태로 인증방식을 갖는다. 이를 그림으로 표현하면 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/d/d1/Chain_of_trust.svg&quot; alt=&quot;Chain of trust&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Root CA는 각 국가, OS, 브라우저에 따라서 정책이 다양하다. 이는 클라이언트가 갖고 있는 인증서이기에 변화가 어렵다. 그러나 chain형식으로 관리하면 SSL 인증서 발급의 유연성을 확보할 수 있다. 위 그림에서 보면 self-sign이란 표현이 있다. Root CA의 인증서는 self-sign하는데, 상위의 CA가 없으므로 자신의 개인키를 갖고 자신의 인증서를 디지털 서명해둔다. 이 서명은 Root CA의 공개키를 사용해서 인증서의 신뢰성을 판단한다.&lt;/p&gt;

&lt;h2 id=&quot;pkcs&quot;&gt;PKCS&lt;/h2&gt;

&lt;p&gt;PKCS(Public Key Cryptography Standard)는 RSA Security Inc.에서 발행하는 공개키 암호화 표준이다. RSA를 암호화하는 방법은 제곱 연산이나, 나머지 연산과 같은 수식으로 이루어져 있어서(&lt;i&gt;c&lt;/i&gt; = &lt;i&gt;m&lt;/i&gt;&lt;sup&gt;e&lt;/sup&gt; mod &lt;i&gt;N&lt;/i&gt;), 데이터를 어떻게 숫자로 나타낼 것인가에 대한 표준이 정해져야 한다. 여기에 보안성을 더 강화하기 위해서 데이터를 복잡하게 만들거나, 암호화 하고자 하는 데이터의 크기를 늘려서 암호화하는 방식을 정의한 것이 &lt;a href=&quot;https://en.wikipedia.org/wiki/PKCS&quot;&gt;PKCS&lt;/a&gt;다.&lt;/p&gt;

&lt;h2 id=&quot;x509&quot;&gt;X.509&lt;/h2&gt;

&lt;p&gt;SSL 인증서를 발급 받을때 &lt;code class=&quot;highlighter-rouge&quot;&gt;.der&lt;/code&gt; 혹은 &lt;code class=&quot;highlighter-rouge&quot;&gt;.pem&lt;/code&gt;으로 되어 있는 인증서 파일을 받는다. X.509는 이런 인증서의 표준이다. 사이트의 도메인과 CA의 이름, 유효기간, 사이트의 RSA 공개키가 들어간다. 그리고 마지막에는 CA에서 서명한 디지털 서명이 포함된다. X.509v3 인증서의 구조는 아래와 같이 생겼다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Certificate&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Version&lt;/code&gt; 인증서의 버전을 나타냄&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Serial Number&lt;/code&gt; CA가 할당한 정수로 된 고유 번호&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Signature&lt;/code&gt; 서명 알고리즘 식별자&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Issuer&lt;/code&gt; 발행자 (CA의 이름)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Validity&lt;/code&gt; 유효기간
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Not Before&lt;/code&gt; 유효기간 시작 날짜&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Not After&lt;/code&gt; 유효기간 만료 날짜&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Subject&lt;/code&gt; 소유자 (주로 사이트의 소유자의 도메인 혹은 하위 CA의 이름)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Subject Public Key Info&lt;/code&gt; 소유자 공개 키 정보
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Public Key Algorithm&lt;/code&gt; 공개 키 알고리즘의 종류 (RSA, …)&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Subject Public Key&lt;/code&gt; 공개 키&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Extensions&lt;/code&gt; 확장 필드
        &lt;ul&gt;
          &lt;li&gt;…&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Certificate Signature Algorithm&lt;/code&gt; 디지털 서명의 알고리즘 종류 (sha256WithRSA, sha1WithRSA, …)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Certificate Signature&lt;/code&gt; 디지털 서명 값&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CA는 해당 인증서의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Certificate&lt;/code&gt;부분을 &lt;code class=&quot;highlighter-rouge&quot;&gt;PKCS#1 v1.5 padding&lt;/code&gt; 방법을 이용해서 디지털 서명하고 hash방법에 대해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Certificate Signature algoritm&lt;/code&gt;에 명시한다.&lt;/p&gt;

&lt;p&gt;위 인증서 구조를 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Subject&lt;/code&gt;가 하나만 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Subject&lt;/code&gt;에는 도메인이 명시되는데, X.509 구조에서는 하나의 인증서는 하나의 도메인 밖에 인증해줄 수 밖에 없다. 만약 웹 사이트 관리자가 example.com과 www.example.com를 두 개의 도메인을 갖지만 같은 서비스를 운영한다면, 인증서를 두 개 만들어야한다. 이를 보완하고자, X.509 v3 인증서 표준에서는 확장 기능으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Subject_Alternative_Name&quot;&gt;SAN(Subject Alternative Name)&lt;/a&gt;이라는 기능을 제공한다. 여기에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Subject&lt;/code&gt;의 이름 외에도 다른 도메인들을 명시해서 하나의 인증서지만 복수의 도메인을 인증받을 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;cipher-suite&quot;&gt;Cipher Suite&lt;/h2&gt;

&lt;p&gt;TLS에서는 암호화하는 방법을 표준으로 특정하지 않고, server와 client가 합의해서 결정한다. 서로 합의해야 하는 알고리즘은 4가지인데, &lt;strong&gt;대칭키 전달 방식, 인증서 서명 방식, 대칭키 알고리즘, HMAC 알고리즘&lt;/strong&gt;이다. TLS에서는 서버와 클라이언트가 이 4가지 알고리즘을 세트로 합의하고, 합의된 알고리즘으로 application layer의 내용을 암호화해서 전송한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hincu.io/wp-content/uploads/2017/08/tls_cipher_suite.png&quot; alt=&quot;TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cipher suite&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384&lt;/code&gt;와 같이 표기한다. 이 &lt;code class=&quot;highlighter-rouge&quot;&gt;cipher suite&lt;/code&gt;를 읽어보면, 다음과 같이 해석할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;대칭키 전달 방식&lt;/strong&gt;은 ECDHE(Elliptic Curve Diffie Hellman Ephermeral)을 사용하며,&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인증서 서명 방식&lt;/strong&gt;은 RSA로 서명된 인증서로 상호간의 신원을 확인하고,&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;대칭키 암호화 알고리즘&lt;/strong&gt;은 AES 256bit와 GCM를 채택하고,&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HMAC 알고리즘&lt;/strong&gt;으로는 SHA 384를 사용해서 메시지의 무결성을 확인한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cipher suite&lt;/code&gt;는 여러가지 있다. 그중에서 client가 지원하면서 취약하지 않은 &lt;code class=&quot;highlighter-rouge&quot;&gt;cipher suite&lt;/code&gt;의 리스트를 서버에게 알려주면, 서버는 그중에 지원하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;cipher suite&lt;/code&gt;를 선택해서 보내 합의한다.&lt;/p&gt;

&lt;h2 id=&quot;tls의-동작&quot;&gt;TLS의 동작&lt;/h2&gt;

&lt;p&gt;TLS는 application protocol의 내용을 암호화하는데에 목적을 둔다. 암호화 전에, &lt;code class=&quot;highlighter-rouge&quot;&gt;TLS Handshake protocol&lt;/code&gt;은 TLS 버전과 &lt;code class=&quot;highlighter-rouge&quot;&gt;cipher suite&lt;/code&gt;를 합의하고, 인증서를 교환한다. 그리고 필요하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Diffie-Hellman&lt;/code&gt; 키도 공유한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Client                                               Server

  ClientHello                  --------&amp;gt;
                                                  ServerHello
                                                 Certificate*
                                           ServerKeyExchange*
                                          CertificateRequest*
                               &amp;lt;--------      ServerHelloDone
  Certificate*
  ClientKeyExchange
  CertificateVerify*
  [ChangeCipherSpec]
  Finished                     --------&amp;gt;
                                           [ChangeCipherSpec]
                               &amp;lt;--------             Finished
  Application Data             &amp;lt;-------&amp;gt;     Application Data

         Figure 1.  Message flow for a full handshake

* Indicates optional or situation-dependent messages that are not
always sent.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ClientHello&lt;/code&gt; 메시지에는 리스트로 된 &lt;code class=&quot;highlighter-rouge&quot;&gt;cipher_suites&lt;/code&gt; 필드가 있다. 클라이언트가 지원하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;cipher suite&lt;/code&gt;를 이곳에 모두 적어주면 서버는 이 중에서 자신이 지원하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;cipher suite&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;ServerHello&lt;/code&gt; 메시지에  넣어서 보낸다(만약 서로 지원하지 못하면 연결이 끊어진다). 정상적인 &lt;code class=&quot;highlighter-rouge&quot;&gt;ClientHello&lt;/code&gt;를 받은 서버는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ServerHello&lt;/code&gt;를 시작으로 다른 메시지를 보내기 시작하는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;ServerHello&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ClientHello&lt;/code&gt; 메시지의 답변에 해당하는 내용이 들어간다(구조도 비슷하게 생겼다).&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Certificate&lt;/code&gt; 메시지는 서버의 인증서와 그 인증서를 확인한 CA들의 모든 인증서인 certficate chain을 보낸다. 합의한 키 교환 방식이 DH(Diffie-Hellman)인 경우, &lt;code class=&quot;highlighter-rouge&quot;&gt;ServerKeyExchange&lt;/code&gt;메시지를 통해서 서버의 key를 보낸다. 모든 메시지를 보냈으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;ServerHelloDone&lt;/code&gt;을 보낸다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ServerHelloDone&lt;/code&gt;을 받은 client는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Certificate&lt;/code&gt; 메시지의 certificate chain 서명을 확인한다. 서버로부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;CertificateRequest&lt;/code&gt;를 받았다면, 클라이언트의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Certificate&lt;/code&gt;를 서버에게 전송한다. 여기서도 마찬가지로 키 교환 방식이 DH인 경우에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ClientKeyExchange&lt;/code&gt;메시지를 통해 클라이언트의 키를 교환한다(이 과정을 이해하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Diffie-Hellman&lt;/code&gt; 알고리즘을 찾아봐야 한다).&lt;/p&gt;

&lt;p&gt;이 과정이 끝나면 client와 server는 TLS의 버전, 사용할 &lt;code class=&quot;highlighter-rouge&quot;&gt;cipher suite&lt;/code&gt;를 결정하고, 상호간의 신원 확인이 끝난 상태가 된다. 이제부터는 본격적으로 암호화 통신이 가능하다. client는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ChangeCipherSpec&lt;/code&gt; 메시지를 보내고, 그 시점부터 모든 메시지는 암호화된 패킷인 &lt;code class=&quot;highlighter-rouge&quot;&gt;TLSCiphertext&lt;/code&gt;라는 구조로 보내진다(참고로 handshake의 과정은 &lt;code class=&quot;highlighter-rouge&quot;&gt;TLSPlaintext&lt;/code&gt; 구조로 메시지를 주고 받는다).&lt;/p&gt;

&lt;p&gt;client가 보내는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Finished&lt;/code&gt; 메시지는 서로 주고 받은 키가 정확한지에 대해서 검증하기 위한 과정이다. 여태까지 보낸 모든 Handshake 통신의 내용을 SHA-256을 통해서 hash한 값을 대칭키로 암호화해서 보내고 server에서는 교환한 대칭키로 복호화해서 client가 올바른 키를 갖고 있는지 검증한다. 그리고 server도 똑같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;Finished&lt;/code&gt; 메시지를 보내서 server가 제대로 키를 구했는지 client도 확인할 수 있도록 한다.&lt;/p&gt;

&lt;p&gt;server가 &lt;code class=&quot;highlighter-rouge&quot;&gt;Finished&lt;/code&gt; 메세지를 보냄으로서 handshake 과정은 끝난다. handshake가 끝나면 합의한 암호화 방법으로 application level 통신을 시작한다. 예를들어, HTTP라면 일반적인 HTTP의 내용(GET / HTTP/1.1\r\n…)을 &lt;code class=&quot;highlighter-rouge&quot;&gt;TLSCiphertext&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;content&lt;/code&gt; 필드에 담아서 보내게 된다.&lt;/p&gt;

&lt;h3 id=&quot;sni&quot;&gt;SNI&lt;/h3&gt;

&lt;p&gt;SNI(Server Name Indication)는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ClientHello&lt;/code&gt;의 확장 기능으로, client가 요청한 server의 도메인을 적어서 보내는 것이다. handshake 과정을 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;ClientHello&lt;/code&gt; 이후에 서버에서는 인증서를 보내준다. 하지만 하나의 서버에서 다양한 도메인을 처리할 수 있는 VirtualHost 기능 때문에, 서버에서는 어떤 도메인의 인증서를 보내줘야 할지 모른다. 과거에는 이런 문제로 SSL 인증서를 서버당 하나의 도메인에만 설정할 수 있었다. 이를 해결하기 위해 SNI라는 확장 기능을 도입했다. 이는 TLS의 extension을 다룬 &lt;a href=&quot;https://tools.ietf.org/html/rfc6066#section-3&quot;&gt;RFC 6066&lt;/a&gt;에 나와있다.&lt;/p&gt;

&lt;h3 id=&quot;alpn&quot;&gt;ALPN&lt;/h3&gt;

&lt;p&gt;ALPN(Application Layer Protocol Negotiation)은 &lt;code class=&quot;highlighter-rouge&quot;&gt;ClientHello&lt;/code&gt;의 확장 기능으로, TLS handshake 이후에 application layer의 프로토콜과 버전을 결정하기 위한 기능이다. 일례로 HTTP/2에서는 HTTP의 버전을 합의하기 위해서 ALPN을 사용한다. 먼저 client가 자신이 HTTP/1.1과 2를 지원한다는 사실을 ALPN으로 보낸다. 만약 서버가 ALPN과 HTTP/2를 지원한다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;ServerHello&lt;/code&gt;의 확장 필드에 &lt;code class=&quot;highlighter-rouge&quot;&gt;h2&lt;/code&gt;를 적으면 handhshake 이후 HTTP/2로 통신이 시작된다. ALPN을 지원하지 않으면, &lt;code class=&quot;highlighter-rouge&quot;&gt;ServerHello&lt;/code&gt;에 ALPN 필드가 없으므로 HTTP/1.1로 통신하게 된다. 자세한 내용은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7301&quot;&gt;RFC 7301&lt;/a&gt;에 정의되어 있다.&lt;/p&gt;

&lt;p&gt;TLS handshake 과정에 대한 자세한 예시는 &lt;a href=&quot;https://github.com/Luavis/tls-example&quot;&gt;구현체&lt;/a&gt;를 보자.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;https://tools.ietf.org/html/rfc5246&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://rsec.kr/?p=455&quot;&gt;https://rsec.kr/?p=455&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7301&quot;&gt;https://tools.ietf.org/html/rfc7301&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6066#section-3&quot;&gt;https://tools.ietf.org/html/rfc6066#section-3&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Server_Name_Indication&quot;&gt;https://en.wikipedia.org/wiki/Server_Name_Indication&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/PKCS_1&quot;&gt;https://en.wikipedia.org/wiki/PKCS_1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2104&quot;&gt;https://tools.ietf.org/html/rfc2104&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://security.stackexchange.com/questions/129490/why-are-there-leading-0x00-bytes-in-the-subjectpublickey-field-of-a-der-x-509-ce&quot;&gt;https://security.stackexchange.com/questions/129490/why-are-there-leading-0x00-bytes-in-the-subjectpublickey-field-of-a-der-x-509-ce&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Object_identifier&quot;&gt;https://en.wikipedia.org/wiki/Object_identifier&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/bb540809(v=vs.85).aspx&quot;&gt;https://msdn.microsoft.com/en-us/library/windows/desktop/bb540809(v=vs.85).aspx&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://homepages.dcc.ufmg.br/~coelho/nm/asn.1.intro.pdf&quot;&gt;http://homepages.dcc.ufmg.br/~coelho/nm/asn.1.intro.pdf&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/windows/desktop/bb648640(v=vs.85).aspx&quot;&gt;https://msdn.microsoft.com/ko-kr/library/windows/desktop/bb648640(v=vs.85).aspx&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://luca.ntop.org/Teaching/Appunti/asn1.html&quot;&gt;http://luca.ntop.org/Teaching/Appunti/asn1.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/windows/desktop/bb648642(v=vs.85).aspx&quot;&gt;https://msdn.microsoft.com/ko-kr/library/windows/desktop/bb648642(v=vs.85).aspx&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2104&quot;&gt;https://tools.ietf.org/html/rfc2104&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://hincu.io/exploring-the-anatomy-of-a-tls-cipher-suite/&quot;&gt;https://hincu.io/exploring-the-anatomy-of-a-tls-cipher-suite/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 22 Jun 2018 18:09:00 +0900</pubDate>
        <link>https://b.luavis.kr/server/tls-101</link>
        <guid isPermaLink="true">https://b.luavis.kr/server/tls-101</guid>
        
        
        <category>server</category>
        
      </item>
    
      <item>
        <title>COW(Copy-on-write)가 발생하는 Python garbage collection</title>
        <description>&lt;h2 id=&quot;tldr&quot;&gt;tl;dr&lt;/h2&gt;

&lt;p&gt;이 글은 &lt;a href=&quot;https://engineering.instagram.com/copy-on-write-friendly-python-garbage-collection-ad6ed5233ddf&quot;&gt;Instagram의 블로그 글&lt;/a&gt;을 번역하고, 저의 개인적인 생각을 담은 글입니다. 혹시 이전 시리즈에 대한 번역은 &lt;a href=&quot;/python/dismissing-python-garbage-collection-at-instagram&quot;&gt;이 문서&lt;/a&gt;에서 확인할 수 있습니다.
Instagram팀은 GC를 끔으로써 이슈를 해결했던 방법이 문제점이 있는 것을 파악하고 새로운 API를 추가해서 이를 해결했습니다. 해당 API는 Python 3.7에 새롭게 들어간 &lt;a href=&quot;https://docs.python.org/3.7/library/gc.html#gc.freeze&quot;&gt;gc.freeze&lt;/a&gt;입니다. 해당 API가 어떤 맥락에서 추가되었는지 어떤 상황에서 사용해야 하는지 설명하고 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;copy-on-write-friendly-python-garbage-collection&quot;&gt;Copy-on-write friendly Python garbage collection&lt;/h2&gt;

&lt;p&gt;Instagram은 모든 코드가 Python으로 작성된 Django 웹 프레임워크를 사용해서 세상에서 가장 큰 규모로 운영하고 있습니다. Instagram은 Python의 simple 함 때문에 초기부터 Python을 사용해 왔습니다, 그러나 전체 규모가 확장되는 것만큼 simple 함을 유지하고자 수년간 많은 튜닝을 진행했습니다. 작년에는 Python의 &lt;a href=&quot;https://engineering.instagram.com/dismissing-python-garbage-collection-at-instagram-4dca40b29172&quot;&gt;GC를 없애는 방법을&lt;/a&gt;(&lt;a href=&quot;/python/dismissing-python-garbage-collection-at-instagram&quot;&gt;번역&lt;/a&gt;) 시도해 봤고 10%의 memory 효율을 볼 수 있었습니다. 그러나 Instagram의 engineering 팀과 기능의 지속적인 추가에 따라서 메모리 사용률 또한 올라갔습니다. 결국엔 GC를 비활성화 함으로써 얻을 수 있는 이익을 잃게 되었습니다.&lt;/p&gt;

&lt;p&gt;밑에 그림은 요청의 수가 증가함에 따라서 메모리 사용량의 증가에 대해서 나타낸 그래프입니다. 요청이 3,000건이 넘으면서부터는 프로세스가 ~ 600MB 이상의 메모리를 사용했습니다. 더 중요한 것은 선형적으로 증가한다는 점입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/instagram-req-graph-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부하 테스트를 해보면 메모리 사용량이 병목의 지점이 되었습니다. GC를 활성화하면 이 문제가 조금은 완화되고 메모리 사용률 증가 폭이 작아집니다. 하지만 원하지 않는 Copy-on-write(COW)는 계속 발생해 메모리 사용량이 증가합니다. 그래서 Instagram팀은 COW 없이도 Python GC가 동작할 수 있게 되면 어떻게 메모리 오버헤드가 줄어들 수 있는지 확인해보자 결정했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/instagram-req-graph-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: center&quot;&gt;빨간색: GC가 없는 경우 / 파란색: GC를 명시적으로 호출해주는 경우 / 초록색: 일반적인 Python GC 경우&lt;/div&gt;

&lt;h2 id=&quot;첫-번째-시도-gc-head-data-구조체-변경&quot;&gt;첫 번째 시도: GC head data 구조체 변경&lt;/h2&gt;

&lt;p&gt;이 이전 GC 글을 잘 읽어보면 COW의 원흉은 Python object마다 앞에 붙어 있는 헤드 부분입니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;/*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GC&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;information&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stored&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BEFORE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;structure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_gc_head&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_gc_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gc_next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_gc_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gc_prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Py_ssize_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gc_refs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dummy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;force&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alignment&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*/&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PyGC_Head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;COW가 발생하는 이유는 GC가 발생할 때 마다 모든 track 되고 있는 object의 &lt;code class=&quot;highlighter-rouge&quot;&gt;gc_refs&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;ob_refcnt&lt;/code&gt;가 업데이트 되는 데에 있습니다. 그러나 불행히도 memory의 페이지에 COW를 발생하게 만듭니다. (이 부분은 이전 글에 자세히 나와있습니다) 이를 해결하기 위해서는 모든 Python object의 헤드 부분을 이를 한곳에 모아두는 것입니다. (역자주] 이렇게 되면 GC로 인한 refcount 업데이트 시에 COW 되는 page의 수를 줄일 수 있습니다)&lt;/p&gt;

&lt;p&gt;그래서 gc_head의 포인터를 만들어서 GC가 발생하는 동안 변동사항이 없게 만들었습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_gc_head_ptr&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_gc_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gc_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dummy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;force&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alignment&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*/&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PyGC_Head_Ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 방법이 성공했는지 평가해보기 위해서 밑에 있는 메모리를 할당받는 스크립트를 사용해 자식 프로세스를 fork 했다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;lists&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;strs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lists&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([])&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;strs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;' '&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;과거의 &lt;code class=&quot;highlighter-rouge&quot;&gt;gc_head&lt;/code&gt; 구조체는 자식 프로세스의 RSS(Resident set size) 메모리 사용률이 ~ 60MB까지 상승했다. 새롭게 작성한 구조체에서는 ~ 0.9MB밖에 증가하지 않아, 성공한 것으로 보입니다.&lt;/p&gt;

&lt;p&gt;그러나 위의 구조체에서 새롭게 추가된 포인터는 새로운 메모리 오버헤드로 작용할 수 있습니다. (2개의 포인터이기에 16byte 정도) 매우 작은 수 인듯 보이지만 Python의 모든 GC 가능한 객체에 적용된다는 점을 생각해보면 이는 매우 큰 오버헤드가 될 수 있습니다. (Instragram팀에서는 한 프로세스에 수백만 개의 객체를 사용하고 host 당 약 70개의 프로세스가 실행된다)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;16byte * 1,000,000 * 70 = ~ 1GB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;두-번째-시도-gc에게-공유-객체-숨기기&quot;&gt;두 번째 시도: GC에게 공유 객체 숨기기&lt;/h2&gt;

&lt;p&gt;새롭게 제안한 &lt;code class=&quot;highlighter-rouge&quot;&gt;gc_head&lt;/code&gt; 구조체는 메모리 효율에 이점이 있다고 한들, 오버헤드는 이상적인 방향이 아니다. 찾고자 하는 해결법은 눈에 띄는 성능에 지장이 없이 GC를 활성화하는 방법이다. COW가 발생하는 근본적인 문제는 자식 프로세스가 fork 되기 전에 부모 프로세스가 만든 객체를 공유하는 데에 있습니다. 그래서 Python GC가 공유되는 객체에 대해서만 다르게 취급하면 됩니다. 쉽게 이야기하면 GC의 동작 과정에서 공유 객체만 숨겨 GC 과정에 공유 객체가 포함되지 않는다면 문제는 해결됩니다.&lt;/p&gt;

&lt;p&gt;이런 해결법을 적용해서 simple 한 Python GC 모듈에 &lt;code class=&quot;highlighter-rouge&quot;&gt;gc.freeze&lt;/code&gt;라는 API를 추가했다. 이 API는 Python이 내부에서 GC 가능한 객체를 관리하고 추적하는 리스트인 Python GC generation 리스트에서 원하는 객체를 삭제하는 것이다. Instagram에서는 이 API를 CPython에 올렸고, Python 3.7 릴리즈에서 사용 수 있다.(&lt;a href=&quot;https://github.com/python/cpython/pull/3705&quot;&gt;https://github.com/python/cpython/pull/3705&lt;/a&gt;)&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gc_freeze_impl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NUM_GENERATIONS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;gc_list_merge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GEN_HEAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_PyRuntime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;permanent_generation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_PyRuntime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;generations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Py_RETURN_NONE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;성공-&quot;&gt;성공 !&lt;/h2&gt;

&lt;p&gt;Instagram팀에서는 이 성능 튜닝을 production에서 사용하고 있고 이번에는 우리가 원했고 예상했던 것과 같이 COW가 더 발생하지 않았고 공유 메모리는 일정했습니다. 반면에 평균 요청당 메모리 사용량 증가 폭은 ~ 50% 가까이 떨어졌습니다. 밑에 있는 그래프는 GC를 활성화로 메모리 증가 폭에 어떤 변화가 있는지 표시되어 있습니다. 처음에 봤던 메모리 사용의 선형적인 증가가 멈추었고 이는 각각의 process가 더 오래 동작할 수 있도록 해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/instagram-req-graph-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;credits&quot;&gt;Credits&lt;/h2&gt;

&lt;p&gt;Thanks to Jiahao Li, Matt Page, David Callahan, Carl S. Shapiro, and Chenyang Wu for their discussions and contributions to the COW-friendly Python garbage collection.&lt;/p&gt;

&lt;p&gt;Zekun Li is an infrastructure engineer at Instagram.&lt;/p&gt;
</description>
        <pubDate>Thu, 21 Dec 2017 13:27:00 +0900</pubDate>
        <link>https://b.luavis.kr/python/cow-friendly-python-gc</link>
        <guid isPermaLink="true">https://b.luavis.kr/python/cow-friendly-python-gc</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>리눅스 서버 60초안에 상황파악하기</title>
        <description>&lt;p&gt;넷플릭스의 &lt;a href=&quot;https://medium.com/netflix-techblog/linux-performance-analysis-in-60-000-milliseconds-accc10403c55&quot;&gt;Linux performance analysis in 60,000ms&lt;/a&gt;에 대해서 부분적으로 번역한 글입니다.&lt;/p&gt;

&lt;p&gt;리눅스 서버에 성능 이슈로 인해서 로그인했을 때 우리가 가장 먼저 체크해봐야할 사항은 어떤것들일까?&lt;/p&gt;

&lt;p&gt;넷플릭스는 많은 사람들이 알고 있는것 처럼 아마존 EC2 리눅스 서버를 사용하고 있다. 이런 대규모 서버를 모니터링하고 성능을 체크하는데에는 툴을 사용하는데 클라우드 전체의 모니터링에는 &lt;a href=&quot;https://medium.com/netflix-techblog/introducing-atlas-netflixs-primary-telemetry-platform-bd31f4d8ed9a&quot;&gt;Atlas&lt;/a&gt;, 하나의 EC2 instance의 성능체크에는 &lt;a href=&quot;https://medium.com/netflix-techblog/introducing-vector-netflixs-on-host-performance-monitoring-tool-c0d3058c3f6f&quot;&gt;Vector&lt;/a&gt;를 사용한다. 이 툴을 이용하면 대부분의 이슈는 해결 가능하지만, 가끔씩은 EC2 instance에 로그인해서 리눅스의 표준적인 성능 체크 툴을 사용할때가 있다.&lt;/p&gt;

&lt;h2 id=&quot;첫-60초&quot;&gt;첫 60초&lt;/h2&gt;

&lt;p&gt;이 글에서는 1분 안에 표준적인 리눅스 환경에서 CLI를 이용해 어떤 것들을 확인할지에 대해서 순서대로 알아볼것이다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;uptime
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;dmesg | tail
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vmstat 1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mpstat &lt;span class=&quot;nt&quot;&gt;-P&lt;/span&gt; ALL 1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pidstat 1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;iostat &lt;span class=&quot;nt&quot;&gt;-xz&lt;/span&gt; 1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;free &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;sar &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; DEV 1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;sar &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; TCP,ETCP 1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;top
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;일부 커맨드는 sysstat package를 설치해야만한다. 이 측정법은 &lt;a href=&quot;http://www.brendangregg.com/usemethod.html&quot;&gt;USE Method&lt;/a&gt;라고 불리는 병목현상이 생기는 위치를 찾는 방법의 일부분이다. USE는 CPU, memory, disk등의 모든 자원에 대해서 Utilization, saturation, error를 측정하는 방법이다.&lt;/p&gt;

&lt;p&gt;아래 각각의 커맨드에 대한 설명에 붙어 있는 예제는 넷플릭스가 production 상태의 서버에서 측정한 값이다. 각 커맨드에 대한 더 많은 설명은 man 페이지를 이용해서 찾으면 된다.&lt;/p&gt;

&lt;h2 id=&quot;1-uptime&quot;&gt;1. uptime&lt;/h2&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;uptime
23:51:26 up 21:31, 1 user, load average: 30.02, 26.43, 19.02

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;uptime은 현재 대기중인 프로세스가 얼마나 있는지를 나타내는 load average값을 확인하는 가장 쉬운 방법이다. 리눅스 시스템에서 이 값은 대기 중인 프로세스뿐만 아니라 disk I/O와 같은 I/O작업으로 block된 프로세스까지 포함되어 있다. 이를 통해서 얼마나 많은 리소스가 사용되고 있는지 확인할수 있지만, 정확하게 이해할 수는 없다.&lt;/p&gt;

&lt;p&gt;위에 있는 3개의 숫자는 각각 1분, 5분, 15분에 load average 값이다. 이를 통해서 시간의 변화를 알 수 있는데, 예를들어서 장애가 발생했다는 소식을 듣고 해당 instance에 로그인 했을때 1분 동안의 값이 15분 값에 비해서 작다면 이는 장애가 발생하고선 내가 너무 뒤늦게 로그인했음을 알 수 있다. 위 예제에서는 1분 값이 약 30이고 15분 값이 19정도 되는것으로 볼때 최근에 상승한것을 알 수 있다. 여기서 숫자가 이 만큼 높은 것은 많은 의미를 갖고 있다. 아마도 CPU 수요에 문제가 있을거라 추측되지만 이 의미를 확인하기 위해선 뒤에 나오는 vmstat이나 mpstat같은 커맨드를 이용해서 확인할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;2-dmesg--tail&quot;&gt;2. dmesg | tail&lt;/h2&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;dmesg | tail
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1880957.563150] perl invoked oom-killer: &lt;span class=&quot;nv&quot;&gt;gfp_mask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0x280da, &lt;span class=&quot;nv&quot;&gt;order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0, &lt;span class=&quot;nv&quot;&gt;oom_score_adj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;...]
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1880957.563400] Out of memory: Kill process 18694 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;perl&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; score 246 or sacrifice child
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1880957.563408] Killed process 18694 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;perl&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; total-vm:1972392kB, anon-rss:1953348kB, file-rss:0kB
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;2320864.954447] TCP: Possible SYN flooding on port 7001. Dropping request.  Check SNMP counters.

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;dmesg는 시스템 메세지를 확인할 수 있는 커맨드이다. 부팅시부터 시작해서 모든 커널메세지가 출력되기 때문에 tail을 이용해서 마지막 10줄만 출력한것이다. 이 메세지를 통해서 성능에 문제를 줄 수 있는 에러를 찾을 수 있는데 위의 예제에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;oom-killer(out of memory)&lt;/code&gt;와 TCP request가 드랍된것을 알 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;3-vmstat-1&quot;&gt;3. vmstat 1&lt;/h2&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vmstat 1
procs &lt;span class=&quot;nt&quot;&gt;---------memory----------&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;---swap--&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-----io----&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-system--&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;------cpu-----&lt;/span&gt;
 r  b swpd   free   buff  cache   si   so    bi    bo   &lt;span class=&quot;k&quot;&gt;in   &lt;/span&gt;cs us sy id wa st
34  0    0 200889792  73708 591828    0    0     0     5    6   10 96  1  3  0  0
32  0    0 200889920  73708 591860    0    0     0   592 13284 4282 98  1  1  0  0
32  0    0 200890112  73708 591860    0    0     0     0 9501 2154 99  1  0  0  0
32  0    0 200889568  73712 591856    0    0     0    48 11900 2459 99  0  0  0  0
32  0    0 200890208  73712 591860    0    0     0     0 15898 4840 98  1  1  0  0
^C
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;virtual memory stat의 약자인 vmstat은 왠만한 환경에서 사용 가능한 툴이다. 1을 인자로 준 vmstat은 1초마다 정보를 보여준다. 첫번째 라인은 부팅된 뒤에 평균적인 값을 나타낸다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;확인해봐야할 항목&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;r&lt;/strong&gt;: CPU에서 동작중인 프로세스의 숫자입니다. CPU 자원이 포화(saturation)가 발생하는지 확인할때에 좋은 값입니다. . &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 값이 CPU의 값보다 큰 경우에 포화되어 있다고 해석된다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;free&lt;/strong&gt;: free memory를 kb단위로 나타냅니다. free memory가 너무 자리수가 많은 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;free -m&lt;/code&gt;를 이용하면 조금더 편하게 확인할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;si, so&lt;/strong&gt;: swap-in과 swap-out에 대한 값입니다. 0이 아니라면 현재 시스템에 메모리가 부족한것이다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;us, sy, id, wa, st&lt;/strong&gt;: 모든 CPU의 평균적인 CPU time을 측정할 수 있다. 각각 user time, 커널에서 사용되는 system time, idle, wait I/O 그리고 stolen time순이다(stolen time은 hypervisor가 가상 CPU를 서비스 하는 동안 실제 CPU를 차지한 시간을 이야기한다.).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-mpstat--p-all-1&quot;&gt;4. mpstat -p ALL 1&lt;/h2&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mpstat &lt;span class=&quot;nt&quot;&gt;-P&lt;/span&gt; ALL 1
Linux 3.13.0-49-generic &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;titanclusters-xxxxx&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  07/14/2015  _x86_64_ &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;32 CPU&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

07:38:49 PM  CPU   %usr  %nice   %sys %iowait   %irq  %soft  %steal  %guest  %gnice  %idle
07:38:50 PM  all  98.47   0.00   0.75    0.00   0.00   0.00    0.00    0.00    0.00   0.78
07:38:50 PM    0  96.04   0.00   2.97    0.00   0.00   0.00    0.00    0.00    0.00   0.99
07:38:50 PM    1  97.00   0.00   1.00    0.00   0.00   0.00    0.00    0.00    0.00   2.00
07:38:50 PM    2  98.00   0.00   1.00    0.00   0.00   0.00    0.00    0.00    0.00   1.00
07:38:50 PM    3  96.97   0.00   0.00    0.00   0.00   0.00    0.00    0.00    0.00   3.03
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 커멘드는 CPU time을 CPU 별로 측정할 수 있다. 이 방법을 통하면 각 CPU별로 불균형한 상태를 확인할 수 있는데, 한 CPU만 일하고 있는것은 application이 single thread로 동작한다는 이야기다.&lt;/p&gt;

&lt;h2 id=&quot;5-pidstat-1&quot;&gt;5. pidstat 1&lt;/h2&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pidstat 1
Linux 3.13.0-49-generic &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;titanclusters-xxxxx&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  07/14/2015    _x86_64_    &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;32 CPU&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

07:41:02 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
07:41:03 PM     0         9    0.00    0.94    0.00    0.94     1  rcuos/0
07:41:03 PM     0      4214    5.66    5.66    0.00   11.32    15  mesos-slave
07:41:03 PM     0      4354    0.94    0.94    0.00    1.89     8  java
07:41:03 PM     0      6521 1596.23    1.89    0.00 1598.11    27  java
07:41:03 PM     0      6564 1571.70    7.55    0.00 1579.25    28  java
07:41:03 PM 60004     60154    0.94    4.72    0.00    5.66     9  pidstat

07:41:03 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
07:41:04 PM     0      4214    6.00    2.00    0.00    8.00    15  mesos-slave
07:41:04 PM     0      6521 1590.00    1.00    0.00 1591.00    27  java
07:41:04 PM     0      6564 1573.00   10.00    0.00 1583.00    28  java
07:41:04 PM   108      6718    1.00    0.00    0.00    1.00     0  snmp-pass
07:41:04 PM 60004     60154    1.00    4.00    0.00    5.00     9  pidstat
^C

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;pidstat은 process당 &lt;code class=&quot;highlighter-rouge&quot;&gt;top&lt;/code&gt;명령을 수행하는것과 비슷하다. 다만 차이점은 스크린 전체에 표시하는것이 아니라 지속적으로 변화하는 상황을 띄워주기 떄문에 상황변화를 기록하기 좋다.&lt;/p&gt;

&lt;p&gt;위 예제를 보면 두개의 java process의 CPU 사용량이 엄청나다. %CPU 항목은 모든 CPU의 전체 사용량을 이야기한다. 따라서 1591%를 사용중인 java process들은 16CPU 가까이 사용중임을 나타내는것이다.&lt;/p&gt;

&lt;h2 id=&quot;6-iostat--xz-1&quot;&gt;6. iostat -xz 1&lt;/h2&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;iostat &lt;span class=&quot;nt&quot;&gt;-xz&lt;/span&gt; 1
Linux 3.13.0-49-generic &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;titanclusters-xxxxx&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  07/14/2015  _x86_64_ &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;32 CPU&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
          73.96    0.00    3.73    0.03    0.06   22.21

Device:   rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
xvda        0.00     0.23    0.21    0.18     4.52     2.08    34.37     0.00    9.98   13.80    5.42   2.44   0.09
xvdb        0.01     0.00    1.02    8.94   127.97   598.53   145.79     0.00    0.43    1.78    0.28   0.25   0.25
xvdc        0.01     0.00    1.02    8.86   127.79   595.94   146.50     0.00    0.45    1.82    0.30   0.27   0.26
dm-0        0.00     0.00    0.69    2.32    10.47    31.69    28.01     0.01    3.23    0.71    3.98   0.13   0.04
dm-1        0.00     0.00    0.00    0.94     0.01     3.78     8.00     0.33  345.84    0.04  346.81   0.01   0.00
dm-2        0.00     0.00    0.09    0.07     1.35     0.36    22.50     0.00    2.55    0.23    5.62   1.78   0.03
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;block device(HDD, SSD, …)가 어떻게 동작하는지 이해하기 좋은 툴이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;확인해봐야할 항목&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;r/s, w/s rkB/s, wkB/s: read 요청과 write 요청, read kB/s, write kB/s를 나타낸다. 어떤 요청이 가장 많이 들어오는지 확인해볼 수 있는 중요한 지표다. 성능 문제는 생각보다 과도한 요청때문에 발생하는 경우도 있기 때문이다.&lt;/li&gt;
  &lt;li&gt;await: I/O처리 평균 시간을 밀리초로 표현한 값이다. application한테는 I/O요청을 queue하고 서비스를 받는데 걸리는 시간이기 때문에 application이 이 시간동안 대기하게 된다. 일반적인 장치의 요청 처리 시간보다 긴 경우에는 블럭장치 자체의 문제가 있거나 장치가 포화된 상태임을 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7-free--m&quot;&gt;7. free -m&lt;/h2&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;free &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt;
             total       used       free     shared    buffers     cached
Mem:        245998      24545     221453         83         59        541
-/+ buffers/cache:      23944     222053
Swap:            0          0          0

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;확인해봐야할 항목&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;buffers: Block 장치 I/O의 buffer 캐시, 사용량&lt;/li&gt;
  &lt;li&gt;cached: 파일 시스템에서 사용되는 &lt;a href=&quot;https://brunch.co.kr/@alden/25&quot;&gt;page cache&lt;/a&gt;의 양&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 값들이 0에 가까워 지면 안된다. 이는 곧 높은 Disk I/O가 발생하고 있음을 의미한다(iostat으로 확인 가능). 위 예제는 각각 59MB, 541MB로 괜찮은 정도에 속한다.&lt;/p&gt;

&lt;p&gt;““-/+ buffers/cache”는 사용중인 메모리와 여유 메모리의 양을 나타낸다. 리눅스는 빠르게 다시 애플리케이션에 메모리가 할당될 수 있도록 캐시메모리를 사용한다. 따라서 캐시 메모리도 여유 메모리에 포함되어 보여야한다. 캐시메모리 또한 여유메모리로 계산하지 않는 착각으로 인해서 &lt;a href=&quot;http://www.linuxatemyram.com/&quot;&gt;linuxatemyram&lt;/a&gt;란 사이트까지 있다.&lt;/p&gt;

&lt;h2 id=&quot;8-sar--n-dev-1&quot;&gt;8. sar -n DEV 1&lt;/h2&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;sar &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; DEV 1
Linux 3.13.0-49-generic &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;titanclusters-xxxxx&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  07/14/2015     _x86_64_    &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;32 CPU&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

12:16:48 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
12:16:49 AM      eth0  18763.00   5032.00  20686.42    478.30      0.00      0.00      0.00      0.00
12:16:49 AM        lo     14.00     14.00      1.36      1.36      0.00      0.00      0.00      0.00
12:16:49 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

12:16:49 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
12:16:50 AM      eth0  19763.00   5101.00  21999.10    482.56      0.00      0.00      0.00      0.00
12:16:50 AM        lo     20.00     20.00      3.25      3.25      0.00      0.00      0.00      0.00
12:16:50 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 툴을 사용하면 network throughput(Rx, Tx KB/s)을 측정할수 있다. 위 예제에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;eth0&lt;/code&gt;의 수신량이 약 22Mbytes/s(21999.10rxkB/s)이다. 이는 176Mbits/s인데 한계인 1Gbit/s에 아직 많이 못 미치는 값이다.&lt;/p&gt;

&lt;p&gt;위 값중 &lt;code class=&quot;highlighter-rouge&quot;&gt;%ifutil&lt;/code&gt;은 &lt;a href=&quot;https://github.com/scotte/nicstat&quot;&gt;nicstat&lt;/a&gt;로도 측정 가능한 네트워크 장치 사용률이다. 하지만 nicstat에서도 그렇듯 정확한 값을 가져오는게 어려워서 위 예제에서도 잘 작동하지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;9-sar--n-tcpetcp-1&quot;&gt;9. sar -n TCP,ETCP 1&lt;/h2&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;sar &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; TCP,ETCP 1
Linux 3.13.0-49-generic &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;titanclusters-xxxxx&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  07/14/2015    _x86_64_    &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;32 CPU&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

12:17:19 AM  active/s passive/s    iseg/s    oseg/s
12:17:20 AM      1.00      0.00  10233.00  18846.00

12:17:19 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s
12:17:20 AM      0.00      0.00      0.00      0.00      0.00

12:17:20 AM  active/s passive/s    iseg/s    oseg/s
12:17:21 AM      1.00      0.00   8359.00   6039.00

12:17:20 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s
12:17:21 AM      0.00      0.00      0.00      0.00      0.00
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 값은 TCP 통신량을 요약해서 보여준다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;active/s: 로컬에서부터 요청한 초당 TCP 커넥션 수를 보여준다 (예를들어, connect()를 통한 연결).&lt;/li&gt;
  &lt;li&gt;passive/s: 원격으로부터 요청된 초당 TCP 커넥션 수를 보여준다 (예를들어, accept()를 통한 연결).&lt;/li&gt;
  &lt;li&gt;retrans/s: 초당 TCP 재연결 수를 보여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;active와 passive 수를 보는것은 서버의 부하를 대략적으로 측정하는데에 편리하다. 위 설명을 보면 active를 outbound passive를 inbound 연결로 판단할 수 있는데, 꼭 그렇지만은 않다. (예를들면 localhost에서 localhost로 연결같은 connection)&lt;/p&gt;

&lt;p&gt;retransmits은 네트워크나 서버의 이슈가 있음을 이야기한다. 신뢰성이 떨어지는 네트워크 환경이나(공용인터넷), 서버가 처리할 수 있는 용량 이상의 커넥션이 붙어서 패킷이 드랍되는것을 이야기한다. 위 예제에서는 초당 하나의 TCP 서버가 들어오는것을 알 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;10-top&quot;&gt;10. top&lt;/h2&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;top
top - 00:15:40 up 21:56,  1 user,  load average: 31.09, 29.87, 29.92
Tasks: 871 total,   1 running, 868 sleeping,   0 stopped,   2 zombie
%Cpu&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: 96.8 us,  0.4 sy,  0.0 ni,  2.7 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem:  25190241+total, 24921688 used, 22698073+free,    60448 buffers
KiB Swap:        0 total,        0 used,        0 free.   554208 cached Mem

   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
 20248 root      20   0  0.227t 0.012t  18748 S  3090  5.2  29812:58 java
  4213 root      20   0 2722544  64640  44232 S  23.5  0.0 233:35.37 mesos-slave
 66128 titancl+  20   0   24344   2332   1172 R   1.0  0.0   0:00.07 top
  5235 root      20   0 38.227g 547004  49996 S   0.7  0.2   2:02.74 java
  4299 root      20   0 20.015g 2.682g  16836 S   0.3  1.1  33:14.42 java
     1 root      20   0   33620   2920   1496 S   0.0  0.0   0:03.82 init
     2 root      20   0       0      0      0 S   0.0  0.0   0:00.02 kthreadd
     3 root      20   0       0      0      0 S   0.0  0.0   0:05.35 ksoftirqd/0
     5 root       0 &lt;span class=&quot;nt&quot;&gt;-20&lt;/span&gt;       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H
     6 root      20   0       0      0      0 S   0.0  0.0   0:06.94 kworker/u256:0
     8 root      20   0       0      0      0 S   0.0  0.0   2:38.05 rcu_sched

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;top&lt;/code&gt; 명령어는 위에서 체크해본 다양한 측정치를 쉽게 체크할 수 있다. 시스템 전반적으로 값을 확인하기 쉽다는 장점이 있다. 화면이 지속적으로 바뀌는 점 떄문에 패턴을 찾는것이 어렵다. 일시적으로 멈추는 현상을 잡기 위해서도 화면을 주기적으로 빠르게 멈춰주지 않으면 찾기 힘들다(Ctrl+S는 업데이트를 중지시키고, Ctrl+Q는 다시 시작시킨다), 그리고 화면이 지워져버린다.&lt;/p&gt;
</description>
        <pubDate>Wed, 23 Aug 2017 02:01:00 +0900</pubDate>
        <link>https://b.luavis.kr/server/linux-performance-analysis</link>
        <guid isPermaLink="true">https://b.luavis.kr/server/linux-performance-analysis</guid>
        
        
        <category>server</category>
        
      </item>
    
      <item>
        <title>Python의 메모리 할당</title>
        <description>&lt;p&gt;&lt;strong&gt;tl;dr&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Python은 pymalloc이란 이름의 커스텀 메모리 관리법이 있습니다. 메모리를 &lt;code class=&quot;highlighter-rouge&quot;&gt;arena&lt;/code&gt;란 이름의 큰 블럭을 만들고 그 안에 풀을 다시 만들어서 512바이트 보다 작은 오브젝트에 대해서는 대부분 이곳에 생성합니다.&lt;/p&gt;

&lt;h2 id=&quot;문제의-서막&quot;&gt;문제의 서막&lt;/h2&gt;

&lt;p&gt;친구가 매우 흥미로운 &lt;a href=&quot;https://tech.ssut.me/2017/08/05/hack-the-virtual-memory-python-bytes/&quot;&gt;글&lt;/a&gt; 하나를 번역한 뒤에 포스팅하여 읽어보았다. 파이썬에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;로 객체를 하나 생성하고 이를 &lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/../mem&lt;/code&gt;을 이용해서 수정하는 이야기에 관한 글이다. 문제는 우리가 생성한 객체가 힙이 아닌 엉뚱한 segment에 할당되어 있다는 점이고 왜 이것이 heap에 없는지, &lt;code class=&quot;highlighter-rouge&quot;&gt;Holberton&lt;/code&gt;란 단어가 heap에 있는것들은 무엇인지에 대한 해답은 나와있지 않아 원문을 찾아봤고 원문에도 설명이 되어 있지 않았다. 그래서 한번 찾아나섰다. 이유가 무엇인지.&lt;/p&gt;

&lt;h2 id=&quot;문제를-해결해보자&quot;&gt;문제를 해결해보자&lt;/h2&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;julien@holberton:/usr/include/python3.4&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ps aux | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;main_id.py | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;grep
&lt;/span&gt;julien     4344  0.0  0.7  31412  7856 pts/0    S+   16:53   0:00 python3 ./main_id.py
julien@holberton:/usr/include/python3.4&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /proc/4344/maps
00400000-006fa000 r-xp 00000000 08:01 655561                             /usr/bin/python3.4
008f9000-008fa000 r--p 002f9000 08:01 655561                             /usr/bin/python3.4
008fa000-00986000 rw-p 002fa000 08:01 655561                             /usr/bin/python3.4
00986000-009a2000 rw-p 00000000 00:00 0 
021ba000-022a4000 rw-p 00000000 00:00 0                                  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;heap]
7f343d797000-7f343de79000 r--p 00000000 08:01 663747                     /usr/lib/locale/locale-archive
7f343de79000-7f343df7e000 r-xp 00000000 08:01 136303                     /lib/x86_64-linux-gnu/libm-2.19.so
7f343df7e000-7f343e17d000 &lt;span class=&quot;nt&quot;&gt;---p&lt;/span&gt; 00105000 08:01 136303                     /lib/x86_64-linux-gnu/libm-2.19.so
7f343e17d000-7f343e17e000 r--p 00104000 08:01 136303                     /lib/x86_64-linux-gnu/libm-2.19.so
7f343e17e000-7f343e17f000 rw-p 00105000 08:01 136303                     /lib/x86_64-linux-gnu/libm-2.19.so
7f343e17f000-7f343e197000 r-xp 00000000 08:01 136416                     /lib/x86_64-linux-gnu/libz.so.1.2.8
7f343e197000-7f343e396000 &lt;span class=&quot;nt&quot;&gt;---p&lt;/span&gt; 00018000 08:01 136416                     /lib/x86_64-linux-gnu/libz.so.1.2.8
7f343e396000-7f343e397000 r--p 00017000 08:01 136416                     /lib/x86_64-linux-gnu/libz.so.1.2.8
7f343e397000-7f343e398000 rw-p 00018000 08:01 136416                     /lib/x86_64-linux-gnu/libz.so.1.2.8
7f343e398000-7f343e3bf000 r-xp 00000000 08:01 136275                     /lib/x86_64-linux-gnu/libexpat.so.1.6.0
7f343e3bf000-7f343e5bf000 &lt;span class=&quot;nt&quot;&gt;---p&lt;/span&gt; 00027000 08:01 136275                     /lib/x86_64-linux-gnu/libexpat.so.1.6.0
7f343e5bf000-7f343e5c1000 r--p 00027000 08:01 136275                     /lib/x86_64-linux-gnu/libexpat.so.1.6.0
7f343e5c1000-7f343e5c2000 rw-p 00029000 08:01 136275                     /lib/x86_64-linux-gnu/libexpat.so.1.6.0
7f343e5c2000-7f343e5c4000 r-xp 00000000 08:01 136408                     /lib/x86_64-linux-gnu/libutil-2.19.so
7f343e5c4000-7f343e7c3000 &lt;span class=&quot;nt&quot;&gt;---p&lt;/span&gt; 00002000 08:01 136408                     /lib/x86_64-linux-gnu/libutil-2.19.so
7f343e7c3000-7f343e7c4000 r--p 00001000 08:01 136408                     /lib/x86_64-linux-gnu/libutil-2.19.so
7f343e7c4000-7f343e7c5000 rw-p 00002000 08:01 136408                     /lib/x86_64-linux-gnu/libutil-2.19.so
7f343e7c5000-7f343e7c8000 r-xp 00000000 08:01 136270                     /lib/x86_64-linux-gnu/libdl-2.19.so
7f343e7c8000-7f343e9c7000 &lt;span class=&quot;nt&quot;&gt;---p&lt;/span&gt; 00003000 08:01 136270                     /lib/x86_64-linux-gnu/libdl-2.19.so
7f343e9c7000-7f343e9c8000 r--p 00002000 08:01 136270                     /lib/x86_64-linux-gnu/libdl-2.19.so
7f343e9c8000-7f343e9c9000 rw-p 00003000 08:01 136270                     /lib/x86_64-linux-gnu/libdl-2.19.so
7f343e9c9000-7f343eb83000 r-xp 00000000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so
7f343eb83000-7f343ed83000 &lt;span class=&quot;nt&quot;&gt;---p&lt;/span&gt; 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so
7f343ed83000-7f343ed87000 r--p 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so
7f343ed87000-7f343ed89000 rw-p 001be000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so
7f343ed89000-7f343ed8e000 rw-p 00000000 00:00 0 
7f343ed8e000-7f343eda7000 r-xp 00000000 08:01 136373                     /lib/x86_64-linux-gnu/libpthread-2.19.so
7f343eda7000-7f343efa6000 &lt;span class=&quot;nt&quot;&gt;---p&lt;/span&gt; 00019000 08:01 136373                     /lib/x86_64-linux-gnu/libpthread-2.19.so
7f343efa6000-7f343efa7000 r--p 00018000 08:01 136373                     /lib/x86_64-linux-gnu/libpthread-2.19.so
7f343efa7000-7f343efa8000 rw-p 00019000 08:01 136373                     /lib/x86_64-linux-gnu/libpthread-2.19.so
7f343efa8000-7f343efac000 rw-p 00000000 00:00 0 
7f343efac000-7f343efcf000 r-xp 00000000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so
7f343f000000-7f343f1b6000 rw-p 00000000 00:00 0 
7f343f1c5000-7f343f1cc000 r--s 00000000 08:01 918462                     /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache
7f343f1cc000-7f343f1ce000 rw-p 00000000 00:00 0 
7f343f1ce000-7f343f1cf000 r--p 00022000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so
7f343f1cf000-7f343f1d0000 rw-p 00023000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so
7f343f1d0000-7f343f1d1000 rw-p 00000000 00:00 0 
7ffccf1fd000-7ffccf21e000 rw-p 00000000 00:00 0                          &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;stack]
7ffccf23c000-7ffccf23e000 r--p 00000000 00:00 0                          &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;vvar]
7ffccf23e000-7ffccf240000 r-xp 00000000 00:00 0                          &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;vsyscall]
julien@holberton:/usr/include/python3.4&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 글에서 bytes가 저장된 위치는 여기였다 &lt;code class=&quot;highlighter-rouge&quot;&gt;7f343f000000-7f343f1b6000 rw-p 00000000 00:00 0&lt;/code&gt;. 할당된 위치도 그러하고 이름도 없는것으로 보아 느낌상 mmap으로 할당된 메모리임을 알 수 있었다. 일단은 mmap이 언제부터 호출된것인지. 그리고 이걸 파이썬이 어떻게 관리하는지를 알기 위해서 코드를 쫓아가기 편하도록 Python C library를 이용해서 본 문에 나온 python bytes 출력 코드를 똑같이 작성하였다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;Python.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Py_Initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PyBytes_FromString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Holberton&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject_Print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;getchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject_Print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Py_DECREF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Py_Finalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;똑같이 동작하였고 메모리에 할당되는 부분 그리고 &lt;code class=&quot;highlighter-rouge&quot;&gt;rw_all.py&lt;/code&gt;를 이용해서 메모리가 수정되는 부분까지 완벽하게 동작하였다. 이제 이 코드를 기반으로 어떻게 파이썬이 메모리를 할당해 나가는지에 대해서 알아보았다.&lt;/p&gt;

&lt;p&gt;우선 &lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;를 할당해준 &lt;code class=&quot;highlighter-rouge&quot;&gt;PyBytes_FromString&lt;/code&gt;이란 함수에서 메모리가 할당될 것이기에 여기서 부터 출발했고 메모리가 할당되는 부분의 call stack을 그려보면 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PyBytes_FromString &amp;lt;Objects/bytesobject.c&amp;gt;
|_ PyObject_MALLOC &amp;lt;Objects/obmalloc.c&amp;gt;
	|_ _PyObject_Malloc &amp;lt;Objects/obmalloc.c&amp;gt;
		|_ _PyObject_Alloc&amp;lt;Objects/obmalloc.c&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_PyObject_Alloc&lt;/code&gt;란 함수가 필요로하는 부분만큼 메모리에서 할당해주는 부분이다. 이 함수에 대해서 찾아보았다.&lt;/p&gt;

&lt;h2 id=&quot;python의-메모리-관리&quot;&gt;Python의 메모리 관리&lt;/h2&gt;

&lt;p&gt;이번 파이콘 행사 이후에 커밋로그 찾으면서 역사 탐방하는 것에 취미가 생겨서 이런 관리법이 언제 생겼는지 알아봤는데 &lt;a href=&quot;https://github.com/python/cpython/tree/a35c688055c72e9442f6a82c3ec0e09654077975&quot;&gt;Python 2.1 버전&lt;/a&gt;부터 변화가 시작되어 시험사용하고, 2.3버전에서 정식 사용되기 시작했다. 이전의 PyObject_MALLOC은 macro를 이용해서 jemalloc과 같은 커스텀 memory allocation 라이브러리를 사용 가능 하도록 만들었고 특별한 설정이 없으면 glib의 malloc을 따르게 돼 있다.&lt;/p&gt;

&lt;p&gt;현재의 파이썬은 이때 만들어진 Vladimir Marangozov이 작성한 pymalloc 알고리즘을 아직까지 사용하고 있다. obmalloc.c에 주석으로 굉장히 자세하게 설명되어 있어 인용했다. Python에서 대부분의 Object가 생성되고 사라질때에는 PyObject_New/Del를 호출하게 된다. 물론 예외적인 경우도 있다. 예를들면 integer 타입같은 경우 일정한 작은 수들은 캐싱해서 따로 리스트를 만들어 관리한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    _____   ______   ______       ________
   [ int ] [ dict ] [ list ] ... [ string ]       Python core         |
+3 | &amp;lt;----- Object-specific memory -----&amp;gt; | &amp;lt;-- Non-object memory --&amp;gt; |
    _______________________________       |                           |
   [   Python's object allocator   ]      |                           |
+2 | ####### Object memory ####### | &amp;lt;------ Internal buffers ------&amp;gt; |
    ______________________________________________________________    |
   [          Python's raw memory allocator (PyMem_ API)          ]   |
+1 | &amp;lt;----- Python memory (under PyMem manager's control) ------&amp;gt; |   |
    __________________________________________________________________
   [    Underlying general-purpose allocator (ex: C library malloc)   ]
 0 | &amp;lt;------ Virtual memory allocated for the python process -------&amp;gt; |

   =========================================================================
    _______________________________________________________________________
   [                OS-specific Virtual Memory Manager (VMM)               ]
-1 | &amp;lt;--- Kernel dynamic storage allocation &amp;amp; management (page-based) ---&amp;gt; |
    __________________________________   __________________________________
   [                                  ] [                                  ]
-2 | &amp;lt;-- Physical memory: ROM/RAM --&amp;gt; | | &amp;lt;-- Secondary storage (swap) --&amp;gt; |

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;운영체제가 Virtual memory를 이용해서 page 단위로 메모리를 관리할때 이는 RAM혹은 스왑메모리에 저장됩니다. 하지만 Python은 객체가 생성될때 이를 이용하지 않고 Python object allocator를 거치게 됩니다.&lt;/p&gt;

&lt;p&gt;Python object allocator는 &lt;code class=&quot;highlighter-rouge&quot;&gt;SMALL_REQUEST_THRESHOLD&lt;/code&gt; 매크로를 기준으로 요청된 메모리가 작은 경우에는 allocator를 사용하지만 그렇지 않은 경우에는 raw memory allocator을 이용해서 관리합니다. 예전에는 이 값이 256이였지만 현재에는 512로 정의되어 있습니다. python object allocator요청이 들어오면 우선 큰 크기의 메모리 블럭을 하나 할당합니다. 이 메모리 블럭을 Python에서는 arena라고 이름지었다. 이 arena에는 4K 크기의(일반적인 페이지 사이즈) 풀들이 있고 이 메모리 풀에는 8byte크기의 여러개의 chunk로 관리됩니다. 여기서 굳이 8바이트를 선정한데에는, 많은 플랫폼에서 memory return alignment가 맞지 않는경우에 bus error를 가져옵니다. 그 중에서 8 byte가 가장 일반적인 메모리 정렬 기준이기 때문입니다. (&lt;a href=&quot;https://stackoverflow.com/questions/15422297/when-malloc-returns-what-does-8-byte-alignment-mean&quot;&gt;참고1&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;참고2&lt;/a&gt;)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; __________________________________________________________________________
|       |       |       |       |          |       |       |       |       |
| chunk | chunk |  ...  | chunk |    ...   | chunk | chunk | chunk |  ...  |
|_______|_______|_______|_______|__________|_______|_______|_______|_______|
|                       |                          |                       |
|          Pool         |  Pool          ...       |          Pool         |
|_______________________|__________________________|_______________________|
|                                                  |                       |
|                     Arena                        |         Arena ...     |
|__________________________________________________|_______________________|


Request in bytes     Size of allocated block      Size class idx
----------------------------------------------------------------
       1-8                     8                       0
       9-16                   16                       1
      17-24                   24                       2
      25-32                   32                       3
      33-40                   40                       4
      41-48                   48                       5
      49-56                   56                       6
      57-64                   64                       7
      65-72                   72                       8
       ...                   ...                     ...
     497-504                 504                      62
     505-512                 512                      63

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 구조하에서 파이썬이 메모리를 요청해오면 1-8바이트가 요청될 경우 chunk 한개, 9-16인 경우 chunk 2개를 주는 방식으로 되어있다. 당연하지만 이 chunk들은 연속적으로 되어있어야한다. 이런 공간을 최소한의 크기로 찾기 위해서 &lt;a href=&quot;http://perry.tistory.com/80&quot;&gt;simple segregated storage&lt;/a&gt;라는 전략을 사용한다. 그리고 이렇게 큰 메모리를 선언할때에는 힙 메모리의 파편화를 막기 위해서 mmap을 사용한다. 이는 arena영역을 생성하는 arena allocator에서 확인할수 있다. mmap을 지원하는 플랫폼에서는 mmap을 사용하고 windows환경에서는 &lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/windows/desktop/aa366887(v=vs.85).aspx&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VirtualAlloc&lt;/code&gt;함수&lt;/a&gt;를 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PyObjectArenaAllocator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_PyObject_Arena&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#ifdef MS_WINDOWS
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;_PyObject_ArenaVirtualAlloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_PyObject_ArenaVirtualFree&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#elif defined(ARENAS_USE_MMAP)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;_PyObject_ArenaMmap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_PyObject_ArenaMunmap&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#else
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;_PyObject_ArenaMalloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_PyObject_ArenaFree&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;결말&quot;&gt;결말&lt;/h2&gt;

&lt;p&gt;파이콘에서는 메모리가 어떻게 소멸되는지에 대해서 이야기 했는데 어쩌다 보니 파이썬이 메모리를 어떻게 만들고 관리해가는지에 대한 이야기까지 하게 되었다. 파이콘 발표자료를 블로그로 정리해서 어떻게 파이썬이 메모리를 소멸하는지에 대해서도 작성해보겠다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.evanjones.ca/memoryallocator/&quot;&gt;http://www.evanjones.ca/memoryallocator/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 21 Aug 2017 05:48:00 +0900</pubDate>
        <link>https://b.luavis.kr/python/python-malloc</link>
        <guid isPermaLink="true">https://b.luavis.kr/python/python-malloc</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>Pex를 이용한 배포</title>
        <description>&lt;h2 id=&quot;tldr&quot;&gt;tl;dr&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pex&lt;/code&gt;는 Python application을, 하나의 실행파일로 만들어주는 라이브러리입니다. 설치는 pip을 이용하거나 &lt;a href=&quot;https://github.com/pantsbuild/pex&quot;&gt;github.com&lt;/a&gt;에 있는 manual을 이용해서 빌드 설치도 가능합니다. 간단한 사용법을 살펴보면.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pex requests flask &lt;span class=&quot;s1&quot;&gt;'psutil&amp;gt;2,&amp;lt;3'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; flask-python
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같은 방법으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;requests&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;flask&lt;/code&gt; 특정 버전의 &lt;code class=&quot;highlighter-rouge&quot;&gt;psutil&lt;/code&gt;이 기본 설치된 &lt;code class=&quot;highlighter-rouge&quot;&gt;flask-python&lt;/code&gt;이라는 이름의 python 실행 바이너리를 얻을 수 있습니다. 아래와 같이 위에서 생성한 &lt;code class=&quot;highlighter-rouge&quot;&gt;flask-python&lt;/code&gt;을 실행하면 requests와 flask가 이미 탑재된 Python Interactive Console을 볼 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./flask-python
Python 2.7.13 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default, Dec 18 2016, 07:03:39&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;GCC 4.2.1 Compatible Apple LLVM 8.0.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;clang-800.0.42.1&lt;span class=&quot;o&quot;&gt;)]&lt;/span&gt; on darwin
Type &lt;span class=&quot;s2&quot;&gt;&quot;help&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;copyright&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;credits&quot;&lt;/span&gt; or &lt;span class=&quot;s2&quot;&gt;&quot;license&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;more information.
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;InteractiveConsole&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;pex&quot;&gt;PEX&lt;/h2&gt;

&lt;p&gt;최근에 &lt;a href=&quot;http://admission.dimigo.hs.kr&quot;&gt;admission.dimigo.hs.kr&lt;/a&gt; 사이트를 개발하면서, Python 개발 경험이 없는도 배포된 웹 애플리케이션을 쉽게 사용하는 방법에 대해서 고민하던중 &lt;code class=&quot;highlighter-rouge&quot;&gt;pex&lt;/code&gt; 프로그램을 알게되었습니다.&lt;/p&gt;

&lt;p&gt;Python은 zip 형식의 파일을 실행할 수 있는 기능을 &lt;a href=&quot;http://bugs.python.org/issue1739468&quot;&gt;Python 2.6&lt;/a&gt;부터 지원했습니다. zip 압축을 해제하고 내부에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;__main__.py&lt;/code&gt;파일을 찾아서 실행하는 기능입니다. 위 기능을 PEP 문서화하고, 추가 기능을 설명해둔 문서가 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0441&quot;&gt;PEP 441&lt;/a&gt;에 정리되어 있습니다.&lt;/p&gt;

&lt;p&gt;Pex는 zip application 기능과 셔뱅(#!)을 이용해서 조금 더 쉽게 파이선을 패키징해주는 기능을 합니다.&lt;/p&gt;

&lt;h2 id=&quot;install&quot;&gt;Install&lt;/h2&gt;

&lt;p&gt;우선 pex를 설치하는 법을 보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pip install wheel
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pip install pex
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;error: invalid command &lt;code class=&quot;highlighter-rouge&quot;&gt;'bdist_wheel'&lt;/code&gt; 에러가 발생하는 경우 pip을 이용해서 wheel을 설치하여
&lt;code class=&quot;highlighter-rouge&quot;&gt;bdist_wheel&lt;/code&gt; 커맨드가 동작할 수 있도록 만들면 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;deploy&quot;&gt;Deploy&lt;/h2&gt;

&lt;p&gt;우선 위에서 본 pex와 dependency 목록을 입력해주면 된다. 하지만 조금더 효율적인 방법으로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;requirements.txt&lt;/code&gt;를 사용하는 방법이 있다. -r 플래그를 이용하면 requirements를 읽어올 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pex &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; requirements.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 중요한건 현재 작업 중인 프로젝트를 패키지화하여 pex에 각종 dependecy pacakge와 함께 사용할 수 있다는 점입니다. 테스팅을 위해서 현재 간단한 flask 앱을 구현했습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;app.py&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;


&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@app.route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'/'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;h1&amp;gt;Hello world&amp;lt;/h1&amp;gt;&quot;&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 프로젝트를 패키징 가능하도록 하기 위해서 setup.py를 작성합니다. 테스트를 위한 프로젝트의 패키지 이름은 pexflask라 지정했습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;setup.py&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pexflask&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;setuptools&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find_packages&lt;/span&gt;


&lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'pexflask'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'0.0.1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'pex flask'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;packages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find_packages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;package_dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'.'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;install_requires&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;'Flask==0.12'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 위의 setup.py와 app.py를 아래 directory 구조에 넣습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── pexflask
│   ├── __init__.py
│   └── app.py
└── setup.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 상황에서 pex를 이용해서 deploy하기 위해서는 아래와 같은 설정으로 패키징이 가능합니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pex &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; pexflask &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; pexflask.app:main
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;pex는 현재 디렉토리(위의 .)에서 패키지를 불러오고 &lt;code class=&quot;highlighter-rouge&quot;&gt;install_requires&lt;/code&gt;를 분석해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;flask&lt;/code&gt; 0.12버전을 함께 패키징합니다. 그리고 &lt;code class=&quot;highlighter-rouge&quot;&gt;-e&lt;/code&gt; 플래그를 이용하면 entry point(시작 지점)가 설정 가능합니다(위의 경우 pexflask.app에 main함수를 호출합니다). 또 &lt;code class=&quot;highlighter-rouge&quot;&gt;-o&lt;/code&gt; 플래그를 이용하면 제작한 결과물이 저장됩니다.&lt;/p&gt;

&lt;p&gt;사용해보면서 몇 가지 중요한 플래그를 정리해보면.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt;: verbose 설정입니다. 진행과정을 상세하게 볼 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-f [path/url]&lt;/code&gt;: 해당 경로에서 패키지를 찾습니다.(zip, wheel, tar.gz)등 패키지를 찾는것으로 보입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--disable-cache&lt;/code&gt;: 이미 저장된 패키지의 캐시를 사용하지 않습니다. &lt;strong&gt;로컬패키지인 경우&lt;/strong&gt; 수정사항이 발생한 경우 캐싱된 데이터로 인해서 반영이 안됩니다. 이런 경우에 사용할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--python=[python]&lt;/code&gt;: shebang에 들어갈 python을 설정할 수 있습니다. (pypy, python3, python2, …)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;실제-사용&quot;&gt;실제 사용&lt;/h2&gt;

&lt;p&gt;위에서 언급한 &lt;a href=&quot;http://admission.dimigo.hs.kr&quot;&gt;admission.dimigo.hs.kr&lt;/a&gt;을 패키징해보고 사용해보면서 느낀점은, flask앱을 작성하다 보면 당연히 생길 수 밖에 없는 static, assets path나 template path의 관리가 따로 필요한 부분이 있어보인다는 점입니다.
또한 Twitter university의 &lt;a href=&quot;https://www.youtube.com/watch?v=NmpnGhRwsu0&quot;&gt;발표 자료&lt;/a&gt;에서는  손쉬운 빌드를 위해서는 &lt;a href=&quot;https://pantsbuild.github.io/&quot;&gt;pants&lt;/a&gt;를 사용하는 방법을 권장합니다. 하지만 개인적으로 빌드를 위해서 다른 패키지를 설치하는 점이 조금 거슬려서, Makefile 혹은 setup.py에 작성하는 방법 등을 생각해보고 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=NmpnGhRwsu0&quot;&gt;https://www.youtube.com/watch?v=NmpnGhRwsu0&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://d.hatena.ne.jp/heavenshell/20150907/1441645289&quot;&gt;http://d.hatena.ne.jp/heavenshell/20150907/1441645289&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 31 May 2017 01:39:00 +0900</pubDate>
        <link>https://b.luavis.kr/python/deploy-with-pex</link>
        <guid isPermaLink="true">https://b.luavis.kr/python/deploy-with-pex</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>CSS3 transfrom은 진짜 좋을까?</title>
        <description>&lt;p&gt;이번에 블로그 디자인을 리뉴얼하면서 스크롤 이벤트에 따른 애니메이션이 들어가게되었고, 이를 위해서는 JS를 이용한 애니메이션기법 외에는 답이 없다는 판단을 했습니다. 따라서 JS를 이용한 고전적인 event를 받고 이를 top값을 바꿔 움직이는 애니메이션을 구현했습니다. transform을 이용하면 조금 더 간단하고 성능도 우월한 개발이 가능하지 않을까 생각하여, 코드를 수정해서 퍼포먼스를 비교해봤습니다.
처음 웹을 공부할때만 해도 IE6, 7 버전의 지원이 현실적인 문제였고, 당시 웹은 지금에 비해서 애니메이션에 대한 요구가 적었습니다. 애니메이션을 구현한다 하더라도 jQuery의 animate함수를 이용하거나 css property에 직접 접근하는 방법이 대부분의 개발자가 사용하는 방법이었고, CSS3 animation이 지원이야 했지만 아직 개발에 직접 적용하기에는 구형 브라우저 지원이라는 큰 장벽이 있었습니다. 하지만 근 1-2년에는 대부분의 대형 웹사이트마저도 구형 브라우저의 지원을 차단하는 방식으로 돌아섰습니다. 그래서 생각보다 정말 성능이 좋다면  &lt;strong&gt;이제는 transform을 써도 괜찮지 않을까 생각해봅니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;크롬의-렌더링-순서&quot;&gt;크롬의 렌더링 순서&lt;/h2&gt;

&lt;p&gt;일반적인 브라우저에서 렌더링 순서를 다시 한번 살펴보았습니다. 우선 HTML DOM 파싱을 진행하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;Recalculate style&lt;/code&gt;(CSS 파싱)을 진행합니다. 이 과정을 크롬의 Devtools로 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Parse HTML&lt;/code&gt;이라는 과정으로 묶어서 나옵니다. 이 과정을 통해 얻은 DOM과 CSSDOM을 통해서 css 설정을 입힌 &lt;code class=&quot;highlighter-rouge&quot;&gt;Render Tree&lt;/code&gt;를 작성합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Render Tree&lt;/code&gt;를 얻으면 비로소 &lt;code class=&quot;highlighter-rouge&quot;&gt;Layout&lt;/code&gt;(레이아웃)을 계산할 수 있게 됩니다. 어떤 element(요소)를 어디에 배치할지 너비, 높이를 얼마를 갖을지 계산합니다. 이 과정은 각 요소를 배치하는 과정이고 레이아웃 과정이 끝나면 &lt;code class=&quot;highlighter-rouge&quot;&gt;paint&lt;/code&gt;가 시작됩니다. 페인팅 과정을 통해서야 우리가 의도한 디자인이 픽셀들을 갖고(Rasterize) 화면에 그려지게 됩니다.&lt;/p&gt;

&lt;p&gt;정리해보면, 아래와 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Parse HTML
    &lt;ol&gt;
      &lt;li&gt;HTML DOM parsing&lt;/li&gt;
      &lt;li&gt;CSS DOM parsing(Recalculate style)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Render Tree&lt;/li&gt;
  &lt;li&gt;Layout&lt;/li&gt;
  &lt;li&gt;Paint (Rasterize)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;js를-통한-애니메이션&quot;&gt;JS를 통한 애니메이션&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/js-html-pipline.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우선 CSS3에는 애니메이션이 있지만 JS를 이용해야만 하는 경우가 있습니다. (지금 블로그의 예가 그렇습니다.) js를 사용하는 경우 유저의 input혹은, timer와 같은 여러종류의 이벤트 핸들러의 js 코드를 통해서 css를 직접 수정하게되고 그러면 위의 크롬의 렌더링 순서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Recalculate style&lt;/code&gt;부터 다시 진행하게됩니다. 당연한 이야기지만 이 과정을 줄이면 줄일 수록 속도는 향상됩니다.&lt;/p&gt;

&lt;h2 id=&quot;개발자-도구를-이용한-퍼포먼스-비교&quot;&gt;개발자 도구를 이용한 퍼포먼스 비교&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;img src=&quot;/assets/position-animation-fps.jpg&quot; alt=&quot;&quot; /&gt;&lt;/th&gt;
      &lt;th&gt;&lt;img src=&quot;/assets/transform-animation-fps.jpg&quot; alt=&quot;&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;position을 이용한 애니메이션 렌더링 시간&lt;/td&gt;
      &lt;td&gt;transform을 이용한 애니메이션 렌더링 시간&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;현재 블로그의 타이틀 부분, ‘subscribe rss’ 버튼, ‘생계코딩 이야기’을 모두 transform을 이용해서 움직이도록 구현하고 이를 비교했습니다. 당연히 transform이 신기술이고, 빠를것이라 예상했고, 실제 적용하고 눈에 보기에도 더 부드러웠습니다, &lt;strong&gt;하지만 프레임 수가 낮게 나왔습니다.&lt;/strong&gt; position을 이용한 경우 1 프레임의 렌더링 시간이 약 18ms, transform을 이용한 경우에는 약 31ms라는 결과가 나왔습니다. &lt;strike&gt;(transform 절대 쓰지 마라.)&lt;/strike&gt;&lt;/p&gt;

&lt;p&gt;조금 더 자세한 조사가 필요했고, 원인을 규명해볼 필요가 있었습니다. 우선 여기서 렌더링 시간이란 존재가 굉장히 애매합니다. fps는 화면에 구성요소를 전부 그리고 완성하면 1 frame으로 계산합니다, 크롬에 GPU Rasterize 기술이 들어온건 오래된 일이고, 문제는 중간중간에 GPU rasterize 도중에 잘라먹는 경우가 부지기수 입니다. 그래서 과연 이게 정상적으로 프레임이 렌더링 된건가에 대한 의문이 남았고, 이를 확인하기 위해 프레임을 스크린샷으로 남겨서 다시 확인해봤습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/position-problem.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 이미지는 position을 이용한 애니메이션 구현 화면중에 일부 프레임을 캡쳐한 결과입니다. 여기서 문제를 찾을 수 있었습니다. 천천히 스크롤할 시에는 전혀 볼 수 없는 계산이 덜 끝난 화면도 일단은 넘어가고 다음 프레임을 렌더링합니다. 이에 비해 transform으로 구현한 경우에는 이런 비완성된 프레임을 거의 찾을 수 없었습니다. 이런 현상으로 인해 transform으로 구현할때 fps는 떨어지지만 전체적으로 애니메이션이 부드러운 느낌을 받을 수 있었던것이라 생각합니다.
개인적인 추론은  position같은 경우에는 기존에 cpu 기반에서 페인팅이 완료되어야하지만, 이를 chrome에서는 gpu레벨로에서 동작하도록 구현하고 있습니다. 하지만 transform은 원래부터 gpu를 통해서 레이어를 렌더링 한다고 알고 있습니다. 만약 position을 이용한 과정은 비동기적으로 동작하는 부분이 있고, transform을 이용한 과정은 동기적으로 동작하는 부분만 있다면 위와 같은 현상이 일어날 것 입니다.&lt;/p&gt;

&lt;p&gt;이유야 어떻게 되었던 FPS를 비교하는 과정은 약간 의미가 없어졌다 판단했고, GPU 사용은 기준을 정하고 측정하는게 불가능했기 때문에  CPU 사용률을 확인해보고자 했습니다. CPU 사용률에서는 압도적으로 transform 과정이 빨랐고 특히 타이틀 렌더링(Recalculate style &amp;amp; Layout)에서는 &lt;strong&gt;2배 이상 빠른 성능&lt;/strong&gt;을 확인할 수 있었습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;img src=&quot;/assets/position-animation-cpu.jpg&quot; alt=&quot;&quot; /&gt;&lt;/th&gt;
      &lt;th&gt;&lt;img src=&quot;/assets/transform-animation-cpu.jpg&quot; alt=&quot;&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;position을 이용한 애니메이션 cpu 사용시간&lt;/td&gt;
      &lt;td&gt;transform을 이용한 애니메이션 cpu 사용시간&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;결론적으로 transform을 사용하는것이 무조건 옳은가에 대한 고민을 했습니다. 일단 fps는 조금 떨어지덜도 완벽한 애니메이션 구현되어 전체적으로 애니메이션이 부드러운 &lt;strong&gt;transform 방식을 사용하는게 옳은 방법&lt;/strong&gt;일 것입니다. 하지만 position을 이용해서 개발할때 이런 효과가 있음을 알고 상황에 따라서 적용할 필요가 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;그래도-transform을-쓰기-꺼려진다&quot;&gt;그래도 transform을 쓰기 꺼려진다&lt;/h2&gt;

&lt;p&gt;저도 브라우저 지원 문제 떄문에 transform과 같은 CSS3의 기술을 쓰는걸 굉장히 꺼려왔습니다. 하지만 이 블로그는 개발자 블로그고 그 특성상 IE 유저가 거의 오지 않고 오더라도 10이상의 유저가 온다는 사실을 확인했습니다. 다른 자료로 &lt;a href=&quot;https://www.koreahtml5.kr/jsp/infoSquare/browserUseStatsKor.jsp?type_code_LIST=USST0001&amp;amp;os_code=all&amp;amp;search_type=B&amp;amp;search_date=201611&quot;&gt;KISA의 자료&lt;/a&gt;가 있습니다 2016년 11월 하반기 기준으로 &lt;strong&gt;70%의 사람들이 IE 10이상&lt;/strong&gt;의 버전을 사용하고 있습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;IE 브라우저&lt;/th&gt;
      &lt;th&gt;점유율&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;IE 10&lt;/td&gt;
      &lt;td&gt;42.1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IE 11&lt;/td&gt;
      &lt;td&gt;28.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IE 9&lt;/td&gt;
      &lt;td&gt;8.13&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IE 8&lt;/td&gt;
      &lt;td&gt;7.51&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IE 7&lt;/td&gt;
      &lt;td&gt;0.18&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IE 6&lt;/td&gt;
      &lt;td&gt;0.03&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;물론 유저의 성격에 따라 다르겠지만, 이제는 개인적으로 생각해둔 지원 브라우저의 기준과 운영체제의 기준을 높여도 괜찮은 시대가 왔지 않았나 생각합니다.&lt;/p&gt;
</description>
        <pubDate>Wed, 17 May 2017 02:25:00 +0900</pubDate>
        <link>https://b.luavis.kr/server/is-css3-transform-is-better-choice</link>
        <guid isPermaLink="true">https://b.luavis.kr/server/is-css3-transform-is-better-choice</guid>
        
        
        <category>server</category>
        
      </item>
    
  </channel>
</rss>
