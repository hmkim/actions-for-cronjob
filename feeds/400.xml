<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by ChangJoo Park on Medium]]></title>
        <description><![CDATA[Stories by ChangJoo Park on Medium]]></description>
        <link>https://medium.com/@changjoopark?source=rss-19fbce783538------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*RPVDsfkAQjB-kz9bIukm8Q.png</url>
            <title>Stories by ChangJoo Park on Medium</title>
            <link>https://medium.com/@changjoopark?source=rss-19fbce783538------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 01:12:14 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@changjoopark" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[Nuxt.js + Storybook 통합하기]]></title>
            <link>https://medium.com/@changjoopark/nuxt-js-storybook-%ED%86%B5%ED%95%A9%ED%95%98%EA%B8%B0-38b5cf571b7c?source=rss-19fbce783538------2</link>
            <guid isPermaLink="false">https://medium.com/p/38b5cf571b7c</guid>
            <category><![CDATA[storybook]]></category>
            <category><![CDATA[nuxtjs]]></category>
            <dc:creator><![CDATA[ChangJoo Park]]></dc:creator>
            <pubDate>Fri, 29 Mar 2019 13:52:08 GMT</pubDate>
            <atom:updated>2019-03-29T13:52:08.223Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*R8PT0NEczI4-NpdPN9mBwg.png" /></figure><p><a href="https://storybook.js.org/">Storybook 공식홈페이지</a>에는 Storybook에 <a href="https://storybook.js.org/docs/guides/guide-vue/">Vue를 통합을 위한 가이드</a>가 있습니다. 같은 Vue.js 기반의 Nuxt.js는 vue-cli 프로젝트와 다르게, 프로그램 시작점인 main.js를 사용자에게 제공하지 않기 때문에 Storybook을 설정하기가 쉽지 않습니다.</p><p>위 이유 때문에 다른 CSS프레임워크를 사용하고 있는 경우 .storybook 의 config.js 파일을 Vue 프로젝트의 main.js 라고 간주하여 설정을 하여야 합니다.</p><p>이번 글에서는 <a href="https://tailwindcss.com/docs/what-is-tailwind/">Tailwindcss</a>를 사용하는 Nuxt.js 프로젝트에 Storybook을 추가하는 방법을 안내합니다.</p><p>Tailwindcss는 <a href="https://postcss.org/">PostCSS</a>를 이용하는 라이브러리입니다. Nuxt.js는 webpack을 번들러로 사용하므로 postcss-loader를 이용해 tailwindcss를 번들링합니다.</p><pre>npx create-nuxt-app my-app</pre><p>터미널에서 위 명령어를 이용해 Nuxt.js 앱을 만듭니다. CSS 프레임워크 / 라이브러리를 고를 때 꼭 Tailwindcss를 선택해주세요</p><pre>npm install --save-dev @storybook/vue babel-core</pre><p>위 명령어를 입력하면 Vue를 위한 Storybook을 프로젝트 의존성 목록에 추가합니다. 다음 명령어로 Storybook에 필요한 파일들을 만듭니다.</p><pre>mkdir .storybook<br>touch config.js<br>touch webpack.config.js<br>cp postcss.config.js ./.storybook</pre><p>첫번째로 config.js 폴더에서 프로젝트를 구성합니다.</p><pre>// config.js<br>import { configure } from &#39;@storybook/vue&#39;;<br>import &#39;tailwindcss/dist/tailwind.min.css&#39;<br>import &#39;../assets/css/tailwind.css&#39;</pre><pre>import Vue from &#39;vue&#39;;<br>// import Vuex from &#39;vuex&#39;; // Vue plugins</pre><pre>const req = require.context(&#39;../components&#39;, true, /\.story\.js$/)</pre><pre>function loadStories() {<br>  req.keys().forEach((filename) =&gt; req(filename))<br>}</pre><pre>configure(loadStories, module);</pre><p>앞서 말한 것 처럼 Vue.js 프로젝트의 main.js 파일로 간주하여 유사하게 프로젝트를 셋팅하면됩니다.</p><pre>// postcss.config.js<br>const join = require(&#39;path&#39;).join<br>const tailwindJS = join(__dirname, &#39;..&#39;, &#39;tailwind.js&#39;)</pre><pre>console.log(&#39;tailwindJS =&gt; &#39;, tailwindJS)<br>module.exports = {<br>  plugins: [<br>    require(&#39;tailwindcss&#39;)(tailwindJS),<br>    require(&#39;autoprefixer&#39;)<br>  ]<br>}</pre><p>복사한 postcss.config.js 파일에서 TailwindJS 경로에 &#39;..&#39; 만 추가합니다. 이제 Storybook에서 webpack 설정을 하면 마무리됩니다.</p><pre>// webpack.config.js<br>const path = require(&#39;path&#39;);</pre><pre>module.exports = async ({ config, mode }) =&gt; {<br>  config.module.rules.push({<br>    test: /\.scss$/,<br>    loaders: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;, &#39;postcss-loader&#39;],<br>    include: path.resolve(__dirname, &#39;../&#39;),<br>  });<br>  return config;<br>};</pre><p>webpack 설정까지 마쳤습니다. 첫번째 Storybook의 story를 만들어봅니다. config.js 파일에서 각 컴포넌트와 같은 경로에 story를 위치하도록 하였습니다.</p><pre>touch ./components/Logo.story.js</pre><p>위 파일을 열고 아래의 내용으로 채워줍니다.</p><pre>import { storiesOf } from &#39;@storybook/vue&#39;;</pre><pre>import Logo from &#39;./Logo.vue&#39;</pre><pre>storiesOf(&#39;Logo&#39;, module)<br>  .add(&#39;Logo Component&#39;, () =&gt; ({<br>    components: { Logo },<br>    template: &#39;&lt;logo /&gt;&#39;,<br>  }));</pre><p>Logo.vue 컴포넌트를 열어 불러오는 것만으로 한개의 story를 만들었습니다. 자세한 내용은 Storybook의 문서를 보고 시도해보세요.</p><p>마지막으로 Storybook을 실행합니다. package.json 을 열어 아래 스크립트를 추가합니다.</p><pre>{<br>  &quot;scripts&quot;: {<br>    // ...<br>    &quot;storybook&quot;: &quot;start-storybook -p 6006 -c .storybook&quot;<br>    /...<br>}</pre><p>쉘을 열어 npm run storybook 명령어를 실행해 로고 컴포넌트가 Storybook에 정상적으로 등록되었는지 확인하세요.</p><p>Tailwindcss는 엘리먼트의 class 속성에 인라인 스타일을 넣는 것 과 유사한 방식으로 사용합니다.</p><pre>&lt;template&gt;<br>  &lt;div class=&quot;bg-white mx-auto max-w-sm shadow-lg rounded-lg overflow-hidden&quot;&gt;<br>    &lt;div class=&quot;sm:flex sm:items-center px-6 py-4&quot;&gt;<br>      &lt;img class=&quot;block h-16 sm:h-24 rounded-full mx-auto mb-4 sm:mb-0 sm:mr-4 sm:ml-0&quot; src=&quot;https://avatars2.githubusercontent.com/u/4323180?s=400&amp;u=4962a4441fae9fba5f0f86456c6c506a21ffca4f&amp;v=4&quot; alt=&quot;&quot;&gt;<br>      &lt;div class=&quot;text-center sm:text-left sm:flex-grow&quot;&gt;<br>        &lt;div class=&quot;mb-4&quot;&gt;<br>          &lt;p class=&quot;text-xl leading-tight&quot;&gt;Adam Wathan&lt;/p&gt;<br>          &lt;p class=&quot;text-sm leading-tight text-grey-dark&quot;&gt;Developer at NothingWorks Inc.&lt;/p&gt;<br>        &lt;/div&gt;<br>        &lt;div&gt;<br>          &lt;button class=&quot;text-xs font-semibold rounded-full px-4 py-1 leading-normal bg-white border border-purple text-purple hover:bg-purple hover:text-white&quot;&gt;Message&lt;/button&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;</pre><p>위 컴포넌트를 만들고 Storybook에서 확인해보세요. Tailwindcss에서 사용하는 class를 Storybook에서도 사용할 수 있습니다.</p><p>Bootstrap, Foundation등의 CSS프레임워크는 PostCSS를 사용하지 않기 때문에 webpack이나 PostCSS설정을 추가로 할 필요는 없을 것 입니다. 만약 추가적으로 jQuery등의 설정을 한다면 이 문서의 webpack 설정 부분에서 해주시면됩니다.</p><p>Storybook webpack 설정 : <a href="https://storybook.js.org/docs/configurations/custom-webpack-config/">https://storybook.js.org/docs/configurations/custom-webpack-config/</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=38b5cf571b7c" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[gr을 이용한 많은 git 저장소 관리하기]]></title>
            <link>https://medium.com/@changjoopark/gr%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A7%8E%EC%9D%80-git-%EC%A0%80%EC%9E%A5%EC%86%8C-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0-44c78ff667d2?source=rss-19fbce783538------2</link>
            <guid isPermaLink="false">https://medium.com/p/44c78ff667d2</guid>
            <category><![CDATA[git]]></category>
            <category><![CDATA[github]]></category>
            <category><![CDATA[gr]]></category>
            <dc:creator><![CDATA[ChangJoo Park]]></dc:creator>
            <pubDate>Thu, 28 Feb 2019 14:54:46 GMT</pubDate>
            <atom:updated>2019-02-28T15:04:58.399Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*7oRDjo6kBZBgHpZxA4Umgg.png" /><figcaption>git merge hell 이라는데..</figcaption></figure><p>이 글을 읽는 여러분은 하루에 얼마나 많은 저장소를 오가며 작업하시나요?<br>하루에 하나 정도의 저장소에서 일하고 있다면 매우 좋은 상황일 것입니다. 부럽습니다. 하지만 API 서버와 웹 프론트엔드를 동시에 개발하는 분이라면 적어도 두개의 저장소를 하루에도 몇번씩 왔다갔다 하면서 작업을 할 것입니다.</p><p>어쩌면 한번에 5개 이상의 프로젝트를 건드려야하는 상황도 있을 것 입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/212/1*RRz_ukcDqm2l3qOD8WujUQ.png" /><figcaption>사실은 실제상황입니다.</figcaption></figure><p>이를 조금 더 디테일하게(가학적인) 상황을 만들어봅시다. 위에서 말한 5개의 프로젝트를 동시에 작업하는 동료가 3명 더 있다고 가정합니다. 만약 Pull Request를 기반으로, 그리고 git-flow 등의 브랜치 전략을 이용하여 깐깐하게 저장소를 관리한다면 매우 좋은 상황일 것입니다.<br>가학적이라고 했으니 방금 말한 좋은 상황은 당연히 없고 모두가 master 브랜치에서 작업을 하고 Pull Request를 통한 리뷰 없이 코드를 던지는 상황입니다. 재수없으면 merge conflict도 발생하겠죠. 다행히도 동료 개발자들을 commit 메시지를 매우 자세하게 잘 입력해준다고 합니다.</p><p>한번에 한 프로젝트에서 기능 A를 개발하는 동안 다른 세명의 동료가 너무나도 열심히 기능을 구현합니다. 한 3시간 정도 업무에 몰두하고 나서 다른 프로젝트와 연동하려고 합니다. 모든 프로젝트는 각각 작업자의 로컬에서 테스트할 수 있습니다. 동료의 작업을 확인하기 위해 터미널을 열고 일일히 나머지 네개의 프로젝트로 옮겨가며 프로젝트를 최신으로 만들어야 합니다. 아래 작업을 말이죠.</p><pre>cd &lt;프로젝트 경로&gt;<br>git fetch upstream<br>git merge upstream/master</pre><p>이 작업을 5번이나 해야합니다. 다른 동료들이 오늘 어떤 작업을 했는지 확인해야하니 당연히 `git log` 명령어로 확인해야겠죠? 이것도 당연히…</p><pre>cd &lt;프로젝트 경로&gt;<br>git log — since &quot;9am&quot;</pre><p>아직 4번 더 해야겠네요. 이 일이 매일 반복됩니다. 말도 안되는 일이지만 충분히 일어나고 있을 것 입니다. 저는 이미… 😭 물론 이만큼 심각하게 안좋은건 과장입니다.</p><p>여기에 더 잔인하게 작은 단위의 라이브러리들도 있다면… 😭</p><p>gr은 JavaScript 기반의 git 저장소 관리 유틸리티입니다. 각 저장소에 태그를 지정하고 태그를 이용하여 태그가 지정된 저장소에 동일한 명령어를 실행할 수 있습니다.</p><p>첫번째 경우인 upstream 으로부터 코드를 최신화 한다면.</p><pre>gr <a href="http://twitter.com/work">@work</a> git fetch upstream<br>gr <a href="http://twitter.com/work">@work</a> git upstream/master</pre><p>위 두줄로 5번이나 반복했던 작업이 한번에 처리됩니다. 그 다음 작업인 커밋 로그를 볼까요?</p><pre>gr <a href="http://twitter.com/work">@work</a> git log — since &quot;9am&quot;</pre><p>물론 이 명령어도 4번 실행한 것 처럼 동작합니다.</p><p>이제 <strong>gr</strong> 의 필요성이 느껴지셨을테니 설치부터 해봅니다.</p><pre>npm install -g git-run</pre><blockquote>npm이 뭔지 잘 모르시면 <a href="https://docs.npmjs.com/about-npm/">npm에 대하여</a>를 참고하세요.</blockquote><p>gr을 입력해보세요. 아무일도 일어나지 않을 것입니다.<br>회사에서 하는 프로젝트이니 태그를 `<a href="http://twitter.com/work">@work</a>` 라고 정하겠습니다. 프로젝트 위치는 아래와 같다고 가정합니다</p><pre>- ~/projects/projectA<br>- ~/projects/projectB<br>- ~/projects/projectC<br>- ~/projects/projectD</pre><p>위 프로젝트 모두를 `<a href="http://twitter.com/work">@work</a>` 로 지정합니다.</p><pre>gr +<a href="http://twitter.com/work">@work</a> ~/projects/projectA ~/projects/projectB ~/projects/projectC ~/projects/projectD</pre><p>다시 gr 명령어를 입력하면 모든 저장소를 볼 수 있을 것 입니다. 그리고 `gr <a href="http://twitter.com/work">@work</a>` 를 입력하면 `<a href="http://twitter.com/work">@work</a>` 태그가 입력된 모든 저장소가 출력됩니다.</p><p>프로젝트를 해당 태그에서 제거하려면 `gr -<a href="http://twitter.com/work">@work</a> &lt;저장소경로&gt;` 를 입력하세요</p><p>gr이 중요한 이유는 꼭 git 명령어가 아니더라도 일반 명령어도 전체 저장소에 실행할 수 있다는 것입니다. 간단하게 `README.md`을 한번에 보려면,</p><pre>gr <a href="http://twitter.com/work">@work</a> cat README.md</pre><p>끝입니다.</p><p><a href="http://mixu.net/gr/#getting-started">공식 홈페이지</a>의 유용한 gr 명령어들을 정리하는 것으로 마치겠습니다. 여러 프로젝트를 한번에 살펴보고 유지하는데 많은 시간을 낭비하지 않길 응원합니다.<br><br>- `gr <a href="http://twitter.com/work">@work</a> git fetch`, 그리고 `gr <a href="http://twitter.com/work">@work</a> status` | 모든 저장소 업데이트 후 저장소 상태 출력<br>- `gr <a href="http://twitter.com/work">@work</a> git diff` 또는 `gr <a href="http://twitter.com/work">@work</a> git diff — cached` | diff<br>- `gr <a href="http://twitter.com/write">@write</a> make` | 모든 저장소에 `make` 명령어로 빌드 <br>- `gr <a href="http://twitter.com/work">@work</a> npm ls` | 모든 npm 모듈 목록 보기<br>- `gr <a href="http://twitter.com/work">@work</a> git — no-pager log — decorate — graph — oneline -n 3` | git 로그를 그래프와 함꼐 보기</p><p>첫번째 이미지의 출처 : <a href="http://www.tugberkugurlu.com/archive/resistance-against-london-tube-map-commit-history-a-k-a--git-merge-hell">http://www.tugberkugurlu.com/archive/resistance-against-london-tube-map-commit-history-a-k-a--git-merge-hell</a></p><p>저장소 이미지의 출처 : …</p><p>함께쓰면 좋을만한 유틸리티 : <a href="http://nodegh.io/">http://nodegh.io/</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=44c78ff667d2" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[댓글 감사합니다]]></title>
            <link>https://medium.com/@changjoopark/%EB%8C%93%EA%B8%80-%EA%B0%90%EC%82%AC%ED%95%A9%EB%8B%88%EB%8B%A4-fd9029348ad6?source=rss-19fbce783538------2</link>
            <guid isPermaLink="false">https://medium.com/p/fd9029348ad6</guid>
            <dc:creator><![CDATA[ChangJoo Park]]></dc:creator>
            <pubDate>Thu, 28 Feb 2019 12:43:28 GMT</pubDate>
            <atom:updated>2019-02-28T12:43:28.029Z</atom:updated>
            <content:encoded><![CDATA[<p>댓글 감사합니다</p><p>보편적인 주제라 비슷한 내용이 많을 것 같습니다</p><p>제가 express에서 async — await 를 쓰면서 적은 내용이라서요</p><p>더 좋은 방법이나 의견이있으시면 알려주셔서 이 내용에 대해 이야기하면 더 좋을 것 같습니다 혹시 위 방법 말고 다른 방법을 생각해보신적이 있으신가요?</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fd9029348ad6" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[software-properties-common 를 설치하도록 변경되었습니다 :)]]></title>
            <link>https://medium.com/@changjoopark/software-properties-common-%EB%A5%BC-%EC%84%A4%EC%B9%98%ED%95%98%EB%8F%84%EB%A1%9D-%EB%B3%80%EA%B2%BD%EB%90%98%EC%97%88%EC%8A%B5%EB%8B%88%EB%8B%A4-c291f01119c9?source=rss-19fbce783538------2</link>
            <guid isPermaLink="false">https://medium.com/p/c291f01119c9</guid>
            <dc:creator><![CDATA[ChangJoo Park]]></dc:creator>
            <pubDate>Wed, 09 Jan 2019 11:53:33 GMT</pubDate>
            <atom:updated>2019-01-09T11:53:33.445Z</atom:updated>
            <content:encoded><![CDATA[<p>software-properties-common 를 설치하도록 변경되었습니다 :)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c291f01119c9" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[내년에도 잘 부탁드립니다 (__ )]]></title>
            <link>https://medium.com/@changjoopark/%EB%82%B4%EB%85%84%EC%97%90%EB%8F%84-%EC%9E%98-%EB%B6%80%ED%83%81%EB%93%9C%EB%A6%BD%EB%8B%88%EB%8B%A4-a7e4be1035c7?source=rss-19fbce783538------2</link>
            <guid isPermaLink="false">https://medium.com/p/a7e4be1035c7</guid>
            <dc:creator><![CDATA[ChangJoo Park]]></dc:creator>
            <pubDate>Mon, 31 Dec 2018 09:11:42 GMT</pubDate>
            <atom:updated>2018-12-31T09:11:42.402Z</atom:updated>
            <content:encoded><![CDATA[<p>내년에도 잘 부탁드립니다 (__ )</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a7e4be1035c7" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[플러터(Flutter) 앱 만들기 : 블로그 글 상세]]></title>
            <link>https://medium.com/@changjoopark/%ED%94%8C%EB%9F%AC%ED%84%B0-flutter-%EC%95%B1-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B8%80-%EC%83%81%EC%84%B8-dc1ba68d4cef?source=rss-19fbce783538------2</link>
            <guid isPermaLink="false">https://medium.com/p/dc1ba68d4cef</guid>
            <category><![CDATA[flutter]]></category>
            <category><![CDATA[dart]]></category>
            <dc:creator><![CDATA[ChangJoo Park]]></dc:creator>
            <pubDate>Thu, 27 Sep 2018 22:58:16 GMT</pubDate>
            <atom:updated>2018-09-27T22:58:16.505Z</atom:updated>
            <content:encoded><![CDATA[<p>이번에는 플러터와 JSONPlaceholder 중 <a href="https://jsonplaceholder.typicode.com/posts/1">블로그 포스트 상세 API</a>를 이용해 한개 아이템을 HTTP 클라이언트로 요청하고 화면에 그리는 방법을 알아봅니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/300/1*WQnVU96l5UxFICFgQBKtLA.png" /><figcaption>완성된 예제 화면</figcaption></figure><p>완성된 프로젝트는 <a href="https://github.com/ChangJoo-Park/flutter_fetch_posts">Github</a>에 있습니다.</p><p>총 4단계로 만듭니다.</p><ol><li><a href="https://github.com/ChangJoo-Park/flutter_fetch_posts/tree/%231-remove-scaffold">프로젝트 만들기 및 기본 </a>코드 정리</li><li><a href="https://github.com/ChangJoo-Park/flutter_fetch_posts/tree/%232-add-http">http 외부 모듈 추가</a></li><li><a href="https://github.com/ChangJoo-Park/flutter_fetch_posts/tree/%233-add-post-model-and-service">Post 클래스와 fetchPost 서비스 추가</a></li><li><a href="https://github.com/ChangJoo-Park/flutter_fetch_posts/tree/%234-show-post-title">포스트 내용 출력</a></li></ol><h4>프로젝트 만들기 및 기본 코드 정리</h4><p>플러터 프로젝트는 VSCode의 Flutter: New Project를 이용해 만들었습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/763/1*f-i2F2PcuMrww8bzkhE0ug.png" /><figcaption>VSCode의 <a href="https://marketplace.visualstudio.com/items?itemName=Dart-Code.flutter">Flutter 패키지</a>를 설치하세요</figcaption></figure><p>처음 프로젝트를 만들면 나오는 샘플 앱인 카운터에는 불필요한 내용이 많습니다. <em>MyApp </em>클래스의 <em>home</em> 속성을 <em>PostDetailPage</em>로 바꾸고, 필요없는 주석을 모두 제거합니다. <em>Floating Action Button</em>을 포함한 기본 코드 대부분을 삭제합니다. 이 <a href="https://github.com/ChangJoo-Park/flutter_fetch_posts/commit/a04ecfd5261e9cfd2dd026fb26a14432ba4e358b">커밋</a>을 보시면 변경사항을 확인하실 수 있습니다.</p><h4>http 외부 모듈 추가</h4><p>이전에 다루었던 <a href="https://medium.com/@changjoopark/%ED%94%8C%EB%9F%AC%ED%84%B0-flutter-%EC%9D%98-pubspec-yaml-ffa40b26296a">패키지 매니저 사용방법</a>에는 외부 모듈을 사용하기 위한 안내가 있습니다. 나중에 확인해보세요. 여기서는 필요한 내용만 다룹니다.</p><p>pubspec.yaml 파일을 열어 <em>dependencies</em>의<em> flutter: </em>밑에 http 모듈을 추가합니다.</p><pre>http: ^0.11.3+17</pre><p>http 모듈의 최신 버전은 0.12이나 <em>flutter_test </em>에서 아직 0.12 버전의 http 모듈을 지원하지 않습니다. 여기서는 0.11 버전을 사용합니다. 이 <a href="https://github.com/ChangJoo-Park/flutter_fetch_posts/commit/96f0124e982ecead43bde9f63887c067006633c9">커밋</a>을 확인해보세요</p><p>http 모듈을 pubspec.yaml에 추가하면 VSCode는 자동으로 의존성을 설치합니다. 이제 main.dart 파일에 아래 코드를 추가하여 http 모듈을 사용할 수 있도록 합니다.</p><pre>import &#39;package:http/http.dart&#39; as http;</pre><p>이 <a href="https://github.com/ChangJoo-Park/flutter_fetch_posts/commit/feed3222f11f9ea5343d6c7c3aebfa8bbcd7de63">커밋</a>을 확인하세요.</p><h4>Post 클래스와 fetchPost 서비스 추가</h4><p>이제 사용할 <em>Post </em>모델과 <em>Post </em>모델을 외부 API에서 가져올 <em>fetchPost </em>메소드를 만듭니다.</p><p>Post 모델을 만들기 위해 HTTP 응답을 확인합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*3qEcCPk4LAjGA3t1MMoRvA.png" /><figcaption>Post id 1</figcaption></figure><p>위 응답을 바탕으로 <em>Post </em>클래스를 만듭니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*XojkxsLy1yQLQAWjuwjekA.png" /><figcaption>Class : Post</figcaption></figure><p>Dart의 생성자를 확인해보세요. <em>Post()</em> 안에 클래스 멤버 변수를 지정하면 자동으로 초기화합니다. 그리고 <em>factory </em>생성자를 이용해 JSON으로 객체를 초기화 할 수 있도록 <em>factory Post.fromJson</em> 메소드를 추가합니다. HTTP 요청 후 <em>Post.fromJson</em> 메소드를 이용해 생성자를 만듭니다.</p><p>이 <a href="https://github.com/ChangJoo-Park/flutter_fetch_posts/commit/6017d5c9170bbd6cc63dc06914c0316b920c33ce">커밋</a>을 확인하세요.</p><p>JSON 직렬화 소개: <a href="https://flutter.io/json/">https://flutter.io/json/</a></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*urnmoC1UxUL7Yqcu5BvaFw.png" /><figcaption>fetchPost</figcaption></figure><p><em>Future</em>와 <em>async, await </em>키워드는 비동기 프로그래밍을 위한 키워드입니다. JavaScript의 <em>async, await</em>와 사용법이 같습니다. <em>Future&lt;T&gt;</em>를 리턴 타입으로 설정하여 Future가 필요한 메소드 등에서 사용할 수 있습니다.</p><p>응답이 성공하면 <em>json.decode</em>로 응답의 <em>body</em>를 <em>JSON</em>으로 만들고 <em>Post</em> 클래스에서 만든 <em>fromJson </em>메소드로 초기화합니다.</p><p>이 <a href="https://github.com/ChangJoo-Park/flutter_fetch_posts/commit/399ff55aaecbd5d44c8e5bd725e50e3a61c29618">커밋</a>을 확인하세요.</p><p>Future 의 자세한 소개 : <a href="https://www.dartlang.org/tutorials/language/futures">https://www.dartlang.org/tutorials/language/futures</a></p><h4>포스트내용 출력</h4><p>이번 글에서는 화면에 출력하는 것이 목표이기 때문에 화려하게 꾸미지는 않습니다. 레이아웃 등 다른 글에서 다루겠습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*esKUitIV5R2fCGcYXEsAYg.png" /><figcaption>body의 전체</figcaption></figure><p><em>Scaffold</em> 클래스의 <em>body </em>속성 전체입니다. <em>FutureBuilder</em>를 이용해 <em>Future</em>를 실행하고, 응답 결과인 <em>snapshot</em>의 상태에 따라서 다른 화면을 표시합니다. 아직 <em>Future</em>가 종료되지 않았다면 <em>CircularProgressIndicator</em>를 출력합니다. <em>snapshot</em>을 사용하는 코드를 통해 비동기 응답을 처리하는 부분을 확인하시고, <em>Column</em>과 <em>Column</em>의 <em>children</em> 속성을 이용해 화면 레이아웃을 구성하고 있습니다. 변경사항은 이 <a href="https://github.com/ChangJoo-Park/flutter_fetch_posts/commit/9757f6b45e21c5d3189a52b48e78b639f2ffa3e8#diff-fe53fad46868a294b309fc85ed138997R69">커밋</a>을 확인하세요.</p><p>Widget 기반으로 화면을 구성하는 것이 아직 어색할 수 있습니다. 물론 Dart의 경우 더 심할 것으로 생각됩니다. 다음에는 JSONPlaceholder의 posts API를 이용해 포스트 목록과 상세를 만들어보겠습니다.</p><p>전체 코드는 Github <a href="https://github.com/ChangJoo-Park/flutter_fetch_posts">저장소</a>에 있습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=dc1ba68d4cef" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[플러터(Flutter)의 pubspec.yaml]]></title>
            <link>https://medium.com/@changjoopark/%ED%94%8C%EB%9F%AC%ED%84%B0-flutter-%EC%9D%98-pubspec-yaml-ffa40b26296a?source=rss-19fbce783538------2</link>
            <guid isPermaLink="false">https://medium.com/p/ffa40b26296a</guid>
            <category><![CDATA[dart]]></category>
            <category><![CDATA[flutter]]></category>
            <dc:creator><![CDATA[ChangJoo Park]]></dc:creator>
            <pubDate>Tue, 25 Sep 2018 16:01:46 GMT</pubDate>
            <atom:updated>2018-09-25T16:01:46.905Z</atom:updated>
            <content:encoded><![CDATA[<p>플러터 프로젝트를 새로 만들면 <em>pubspec.yaml</em> 파일을 볼 수 있습니다. Node.js의 <em>package.json</em>과 같은 패키지 의존성 관리 및 프로젝트 정의 등의 역할을 갖습니다.</p><p><em>pubspec.yaml </em>의 기본 정보입니다. 영어로 되어있는 주석을 한글로 번역했습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ad94a1696d5a2c8fdbadd45c307ae9a0/href">https://medium.com/media/ad94a1696d5a2c8fdbadd45c307ae9a0/href</a></iframe><h4>Pubspec 상세</h4><p><em>pubspec.yaml</em> 파일은 확장자와 같이 YAML 규격으로 되어있습니다. 지원하는 필드의 종류는 다음과 같습니다.</p><ul><li>name : 패키지의 이름. underscore _ 를 사용하세요.(필수)</li><li>version : 패키지의 버전을 의미합니다. (생략할 경우 0.0.0)</li><li>description : 패키지의 설명을 적습니다. <a href="https://pub.dartlang.org/packages">Pub</a>에서 어떻게 출력되는지 볼 수 있습니다.</li><li>author 또는 authors : 해당 패키지를 만든 사람을 표기합니다. 이름 &lt;이메일&gt; 형식으로 작성합니다.</li><li>homepage : 패키지의 홈페이지가 있는 경우 적습니다.</li><li>documentation : 문서가 있는 경우 적습니다.</li><li>dependencies : 패키지가 사용하는 의존성 목록입니다.</li><li>dev_dependencies : 패키지가 사용하는 개발용 의존성 목록입니다.</li><li>dependency_overrides : 임시로 의존성을 오버라이드 해야하는 경우 적습니다.</li><li>environment : Dart 2 프로젝트의 경우 적습니다.</li><li>executables : 실행가능한 패키지인 경우 스크립트를 적습니다.</li><li>publish_to : 기본 값은 <a href="https://pub.dartlang.org">https://pub.dartlang.org</a> 입니다. none 이면 배포하지 않습니다.</li></ul><h4>Pub</h4><p>플러터는 Pub이라는 패키지 매니저를 제공합니다. 같은 Pub 패키지매니저이지만 Dart는 기본적으로 pub 명령어를 그대로 사용하고, 플러터는 flutter package 명령어를 사용합니다.</p><p>pub 명령어의 종류입니다.</p><ul><li><a href="https://www.dartlang.org/tools/pub/cmd/pub-cache">pub cach</a>e : 추가한 의존성에 대한 캐시와 관련된 작업을 합니다.</li><li><a href="https://www.dartlang.org/tools/pub/cmd/pub-deps">pub deps</a> : 의존성 그래프를 트리구조로 보여줍니다.</li><li><a href="https://www.dartlang.org/tools/pub/cmd/pub-downgrade">pub downgrade</a> : 특정 패키지의 버전을 낮춥니다.</li><li><a href="https://www.dartlang.org/tools/pub/cmd/pub-get">pub get</a> : pubspec.yaml 에 있는 내용을 다운로드합니다.</li><li><a href="https://www.dartlang.org/tools/pub/cmd/pub-global">pub global</a> : 패키지를 전역으로 사용할 수 있도록 변경합니다.</li><li><a href="https://www.dartlang.org/tools/pub/cmd/pub-lish">pub publish</a> : 패키지를 배포합니다.</li><li><a href="https://www.dartlang.org/tools/pub/cmd/pub-run">pub run</a> : 스크립트를 실행합니다.</li><li><a href="https://www.dartlang.org/tools/pub/cmd/pub-upgrade">pub upgrade</a> : 패키지의 버전을 최신 버전으로 올립니다.</li><li><a href="https://www.dartlang.org/tools/pub/cmd/pub-uploader">pub uploader</a> : 패키지 업로더 정보를 수정(추가/제거)합니다.</li></ul><p>플러터 프로젝트를 진행하는 도중 pub 명령어를 직접 사용할 일이 많지는 않습니다. 각 IDE에서 pubspec.yaml 에서 의존성 정보를 수정하면 백그라운드에서 새로 의존성을 다운받는 작업을 자동으로 해줍니다.</p><h4>외부 의존성 추가 방법</h4><p>dependencies 에서 사용할 패키지 추가 방법은 세가지 입니다.</p><ul><li>path : 파일시스템인 경우 path 를 적어줍니다. 여기서는 plugin1이 패키지 이름입니다.</li></ul><pre>dependencies:<br>  plugin1:<br>    path: ../plugin1</pre><ul><li>git : Git 저장소를 이용하는 경우 url에 저장소 주소를 적어줍니다</li></ul><pre>dependencies: <br>  plugin1:<br>    url: git://github.com/flutter/plugin1.git</pre><ul><li>git + path : Git 저장소의 특정 경로를 이용하는 경우 path까지 지정합니다.</li></ul><pre>dependencies: <br>  plugin1:<br>    url: git://github.com/flutter/packages.git<br>    path: packages/package1</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/648/1*wk0uBrOiAb9Pu0ecSp0cOQ.png" /><figcaption>Dart Packages</figcaption></figure><p><a href="https://pub.dartlang.org">Dart Packages</a> 는 npmjs.com 같은 패키지 저장소입니다. 플러터 또는 웹 혹은 모든 Dart 프로젝트에서 사용할 수 있는 패키지들을 볼 수 있습니다.</p><p>플러터 예제로 사용하는 english_words 패키지를 설치하는 방법을 알아봅니다.</p><p>dependencies 속성에 <strong>english_words: ^3.1.3</strong>와 같이 추가합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/182/1*3sWdxIFTcFQROP7TBjPaCQ.png" /></figure><p>플러터 프로젝트에서는 flutter packages get 다트 프로젝트에서는 pub get 을 이용해 의존성을 설치합니다. 물론 VSCode 등을 사용하면 자동으로 설치합니다.</p><p>실제 프로젝트에서 사용하려면 <em>import </em>키워드를 사용합니다.</p><p>english_words를 이용하려면,</p><p>import &#39;package:english_words/english_words.dart&#39;;</p><p>를 사용하려는 Dart 코드에 적어주세요.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ffa40b26296a" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[플러터(Flutter) 라우터를 이용한 페이지 이동]]></title>
            <link>https://medium.com/@changjoopark/%ED%94%8C%EB%9F%AC%ED%84%B0-flutter-%EB%9D%BC%EC%9A%B0%ED%84%B0%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%9D%B4%EB%8F%99-c30a0402a9bd?source=rss-19fbce783538------2</link>
            <guid isPermaLink="false">https://medium.com/p/c30a0402a9bd</guid>
            <category><![CDATA[flutter]]></category>
            <dc:creator><![CDATA[ChangJoo Park]]></dc:creator>
            <pubDate>Mon, 24 Sep 2018 14:33:52 GMT</pubDate>
            <atom:updated>2018-09-24T14:33:52.723Z</atom:updated>
            <content:encoded><![CDATA[<p>웹 앱을 만들어본 경험이 있는 분이라면 URL을이용해서 페이지를 이동하는 방법이 익숙할 것입니다.</p><p>플러터에도 동일한 라우팅 시스템이 있습니다. 이번에는 두 화면을 만들고 <em>Navigator</em>의<em> push</em>와 <em>pop </em>메소드를이용해 화면을 이동하는 앱을 만듭니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Kj5wv-9wLf9JkAm0H9r9_Q.gif" /></figure><p>라우트를 이용할 것이기때문에 <em>main.dart</em> 파일을 수정합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*BeQMjTRN04wxN7lJG6ttvQ.png" /><figcaption>main.dart</figcaption></figure><p><em>main.dart</em> 파일의 전체 내용입니다. 처음 앱을 만들면 나오는 카운터 앱 전체 코드를 지우고 <em>routes.dart </em>파일의 routes를 <em>MaterialApp </em>의 routes 속성으로 지정합니다. routes의 내용은 아래에 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*gassaDoky3-fegCsZ5--tg.png" /><figcaption>routes.dart</figcaption></figure><p>routes는 <em>first.dart</em> 파일과 <em>second.dart</em> 파일 두개를 사용합니다. 각 파일은 <em>FirstPage</em>, <em>SecondPage </em>클래스입니다. 라우트는 /, /first, /second세개 입니다. 앱을 처음 시작하면 / 을 바라보기 때문에 / 라우트는 FirstPage 클래스를 지정합니다.</p><p>각 페이지의 내용입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*sLV0PmR5mTIreUxkhQOJpQ.png" /><figcaption>first.dart</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*yVk7BzplSF59zBi3fbfZag.png" /><figcaption>second.dart</figcaption></figure><p>첫번째, 두번째 페이지의 전체 내용입니다. FirstPage에서 SecondPage로 이동하는 Navigator 코드가 있습니다. 한 페이지에서 다음 페이지로 push 할 때는 pushNamed 메소드를, pop해서 돌아갈 때는 pop 메소드를 이용합니다.</p><p>이 방법을 사용하지 않으면, 매 페이지 이동시 <em>routes.dart</em>의<em> </em>구현처럼 새 페이지 인스턴스를 넘겨주어야합니다. 공식 홈페이지의 <a href="https://flutter.io/cookbook/navigation/navigation-basics/">화면 이동 안내</a>를 읽어보세요. 웹 개발에 익숙한 경우에 이번 글의 라우팅 시스템을 이용하면 좋을 것 같습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c30a0402a9bd" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[플러터(Flutter) VSCode 디버깅하기]]></title>
            <link>https://medium.com/@changjoopark/%ED%94%8C%EB%9F%AC%ED%84%B0-flutter-vscode-%EB%94%94%EB%B2%84%EA%B9%85%ED%95%98%EA%B8%B0-3249ba84e05?source=rss-19fbce783538------2</link>
            <guid isPermaLink="false">https://medium.com/p/3249ba84e05</guid>
            <dc:creator><![CDATA[ChangJoo Park]]></dc:creator>
            <pubDate>Sun, 23 Sep 2018 13:45:26 GMT</pubDate>
            <atom:updated>2018-09-23T13:45:26.628Z</atom:updated>
            <content:encoded><![CDATA[<p>이 글은 <a href="https://medium.com/@changjoopark/%ED%94%8C%EB%9F%AC%ED%84%B0-flutter-sample-%EC%95%B1-%EB%B6%84%EC%84%9D-ba6f9a9968f9">플러터 (Flutter) Sample 앱 분석</a>에서 이어집니다.</p><p>플러터의 기본 프로젝트인 카운터를 실행했다면, 이번에는 VSCode의 디버거를 사용합니다.</p><p>우선, VSCode의 디버그 탭을 실행합니다. 단축키는 컨트롤 + 쉬프트 + D 입니다</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/876/1*oQifvIWtgz1pEl2AeQ0DOw.png" /><figcaption>Flutter: Launch 만 선택하면 됩니다.</figcaption></figure><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/66e2ed7e644e15246e7d3c9058884202/href">https://medium.com/media/66e2ed7e644e15246e7d3c9058884202/href</a></iframe><p>VSCode의 디버거를 위한 설정이 끝났습니다. 이제 DEBUG 메뉴에서 Flutter를 선택하고 시작을 위한 초록색 버튼을 누르세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/278/1*ynEVXysAaZpocXUENpuLvQ.png" /><figcaption>디버거 메뉴 아이콘</figcaption></figure><p>정상적으로 시작했다면 위 아이콘들을 볼 수 있을 것 입니다. Gradle 설정 및 디버그 모드 앱 설치 등이 끝나면 에뮬레이터 혹은 실제 디바이스에 앱이 실행됩니다.</p><p>DEBUG CONSOLE에서 작업하는 과정을 볼 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*PUMJJILBTTninmGa5otTEw.png" /><figcaption><strong>DEBUG CONSOLE</strong></figcaption></figure><p><em>main.dart </em>파일에서 <em>_MyHomePageState</em>의 <em>_incrementCounter </em>메소드에<em> </em>print(&quot;counter를 증가합니다&quot;); 를 추가합니다. 아마 hot reload가 자동으로 실행되었을 것입니다. 아니라면 위 디버거 메뉴 아이콘의 재실행 버튼을 누르세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/667/1*-7w24Bh7mff0IngLjc1HhQ.png" /><figcaption>counter를 증가합니다</figcaption></figure><p>DEBUG CONSOLE에서 로그를 볼 수 있습니다. 이번에는 브레이크 포인트를 걸어 코드가 작동하는 곳까지만 실행하고 멈춰봅니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/958/1*sDk74cRB8zS8NN__yska-w.png" /><figcaption>브레이크포인트 추가</figcaption></figure><p>빨간 점이 있는 위치를 확인하세요. main.dart 파일의 53번째 줄에 브레이크포인트를 추가했습니다.</p><p>다시 Hot Reload가 되었다면, 카운터 숫자를 올리기 위해 FAB 버튼을 눌러봅니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/946/1*dqILcuroT-lDh9QKjgeKbw.png" /><figcaption>브레이크포인트에서 멈춘 앱</figcaption></figure><p>사이드바에 브레이크포인트로 멈춘 위치의 로컬 변수와 <em>_counter</em>의 현재 값 그리고 콜스택을 확인할 수 있습니다. 스크린샷 우측 상단에 Step Over, Step Into, Step Out 버튼을 눌러보세요.</p><p>기본적인 VSCode를 이용한 플러터 앱 디버깅을 알아보았습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3249ba84e05" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[플러터 (Flutter) Sample 앱 분석]]></title>
            <link>https://medium.com/@changjoopark/%ED%94%8C%EB%9F%AC%ED%84%B0-flutter-sample-%EC%95%B1-%EB%B6%84%EC%84%9D-ba6f9a9968f9?source=rss-19fbce783538------2</link>
            <guid isPermaLink="false">https://medium.com/p/ba6f9a9968f9</guid>
            <category><![CDATA[flutter]]></category>
            <dc:creator><![CDATA[ChangJoo Park]]></dc:creator>
            <pubDate>Sun, 23 Sep 2018 13:44:59 GMT</pubDate>
            <atom:updated>2018-09-24T14:35:20.703Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/637/1*sqD2tfbOjTmY0CJuaNGnGg.png" /><figcaption>Visual Studio Code의 flutter 확장프로그램을 이용한 플러터 앱 만들기</figcaption></figure><p>Visual Studio Code의 <a href="https://marketplace.visualstudio.com/items?itemName=Dart-Code.flutter">flutter 확장프로그램</a>은 기본적인 플러터 커맨드라인 명령어를 에디터에서 사용할 수 있게 만들어줍니다. IntelliJ 혹은 Android Studio의 경우에는플러터 확장프로그램을 설치한 후 플러터 용 프로젝트를 만들면 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/443/1*jNuHtb0_PGzMlw3AILCQ5w.png" /><figcaption>요즘 첫번째 앱은 카운터인 것 같습니다.</figcaption></figure><p>자동으로 만들어주는 앱의 시작 파일은 <em>main.dart </em>입니다.</p><p><em>main.dart</em>의 <em>main </em>메소드를 시작으로 루트 위젯 MyApp 부터 MyHomePage 위젯까지 만들면서 앱을 구성합니다.</p><p>처음 앱을 만들면 자세한 주석이 있습니다. 하나씩 살펴보세요. 새롭게 알 수 있는 내용은 다음과 같습니다.</p><ul><li>앱 테마</li><li>페이지</li><li>상태를 가지는 위젯(Stateful Widget)과 상태가 없는 위젯(Stateless Widget)</li><li>상태를 가지는 위젯의 State 클래스</li><li>setState 메소드를 이용한 화면 + 상태 업데이트</li><li>build 메소드로 화면 구성하기</li></ul><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9fdafdbf861266b1e346559847f798a8/href">https://medium.com/media/9fdafdbf861266b1e346559847f798a8/href</a></iframe><ul><li>앱을 실행해보셨다면 <a href="https://medium.com/@changjoopark/%ED%94%8C%EB%9F%AC%ED%84%B0-flutter-vscode-%EB%94%94%EB%B2%84%EA%B9%85%ED%95%98%EA%B8%B0-3249ba84e05">VSCode로 디버깅하기</a>를 읽어보세요</li><li>여러 페이지를 가지는 앱을 만드려면 <a href="https://medium.com/@changjoopark/%ED%94%8C%EB%9F%AC%ED%84%B0-flutter-%EB%9D%BC%EC%9A%B0%ED%84%B0%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%9D%B4%EB%8F%99-c30a0402a9bd">라우팅을 이용한 페이지이동</a>을 읽어보세요</li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ba6f9a9968f9" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>