<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by 전수열 on Medium]]></title>
        <description><![CDATA[Stories by 전수열 on Medium]]></description>
        <link>https://medium.com/@devxoul?source=rss-121680200d3a------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*38aCpH9pZslm699Q36EbkQ.png</url>
            <title>Stories by 전수열 on Medium</title>
            <link>https://medium.com/@devxoul?source=rss-121680200d3a------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 13:38:46 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@devxoul" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[But they did the exactly same Bastard Injection in WWDC 18 again ]]></title>
            <link>https://medium.com/@devxoul/but-they-did-the-exactly-same-bastard-injection-in-wwdc-18-again-7fbaa4e4c47a?source=rss-121680200d3a------2</link>
            <guid isPermaLink="false">https://medium.com/p/7fbaa4e4c47a</guid>
            <dc:creator><![CDATA[전수열]]></dc:creator>
            <pubDate>Sun, 09 Dec 2018 16:48:37 GMT</pubDate>
            <atom:updated>2018-12-09T16:48:37.692Z</atom:updated>
            <content:encoded><![CDATA[<p>But they did the exactly same Bastard Injection in WWDC 18 again 😂</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7fbaa4e4c47a" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Swift 4.1에서 딥링크로 앱을 여는 경우 크래시되는 문제 해결하기]]></title>
            <link>https://medium.com/styleshare/swift-4-1%EC%97%90%EC%84%9C-%EB%94%A5%EB%A7%81%ED%81%AC%EB%A1%9C-%EC%95%B1%EC%9D%84-%EC%97%AC%EB%8A%94-%EA%B2%BD%EC%9A%B0-%ED%81%AC%EB%9E%98%EC%8B%9C%EB%82%98%EB%8A%94-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0-ed495077c36?source=rss-121680200d3a------2</link>
            <guid isPermaLink="false">https://medium.com/p/ed495077c36</guid>
            <category><![CDATA[swift]]></category>
            <category><![CDATA[ios]]></category>
            <category><![CDATA[troubleshooting]]></category>
            <dc:creator><![CDATA[전수열]]></dc:creator>
            <pubDate>Fri, 06 Apr 2018 16:38:59 GMT</pubDate>
            <atom:updated>2018-04-11T09:42:39.916Z</atom:updated>
            <content:encoded><![CDATA[<p>최근 Xcode 9.3 버전이 배포되었습니다. 이 버전에는 가장 최신의 Swift 4.1 버전이 포함되어 있습니다. Swift 4.1에는 여러 흥미로운 개선사항들이 많지만, 치명적인 버그도 존재합니다. 바로 딥링크를 통해 앱을 여는 경우 크래시가 발생하는 문제입니다. StyleShare에서는 <a href="https://medium.com/styleshare/%EC%86%8C%EA%B7%9C%EB%AA%A8%ED%8C%80%EC%97%90-%EC%A0%81%ED%95%A9%ED%95%9C-qa-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B5%AC%EC%B6%95%EA%B8%B0-%EC%8A%A4%ED%83%80%EC%9D%BC%EC%89%90%EC%96%B4%ED%8C%80%EC%9D%98-qa%EB%B0%A9%EC%8B%9D-45d53c7c30db">QA 과정</a>을 통해 문제를 발견할 수 있었습니다.</p><p>만약 여러분의 애플리케이션이 아래 조건을 모두 충족할 경우 문제가 발생합니다:</p><ul><li>Swift 4.1 버전을 이용해서 빌드한 경우</li><li>Deployment Target이 iOS 11.0 미만인 경우</li><li>AppDelegate에서 application(_:open:sourceApplication:annotation:) 메서드를 구현한 경우</li></ul><p>문제를 재현하기에 가장 좋은 방법은 Safari 앱을 이용하는 것입니다.</p><p>1. iOS 기기 또는 사뮬레이터에서 Safari 앱을 구동합니다.<br>2. 주소 입력란에 앱이 지원하는 딥링크 URL을 입력한 뒤 이동합니다. (e.g. myapp://)<br>3. 앱이 구동됨과 동시에 강제 종료됩니다.</p><p>이 버그는 Swift 이슈 트래커에 <a href="https://bugs.swift.org/browse/SR-7240">SR-7240</a> 티켓으로 이미 등록되어 있습니다. Resolved 상태로 표시되지만 이번 Xcode 9.3 버전에는 포함되지 않은 것으로 보입니다. 다행히 댓글에 한 개발자가 문제를 해결할 수 있는 workaround를 공유해두었는데요. 이 방법을 이용하면 당장의 문제는 해결할 수 있습니다. AppDelegate 메서드의 annotation 파라미터의 타입을 Any에서 Any?로 변경하는 것입니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/0ce1fe8c63fca7a6c953233b94406d02/href">https://medium.com/media/0ce1fe8c63fca7a6c953233b94406d02/href</a></iframe><p>UIApplicationDelegate에 정의된 메서드 시그니쳐와 다르기 때문에 컴파일러가 경고를 표시하지만 무시하셔도 됩니다.</p><p>만약 새로운 버전의 앱을 릴리즈 할 계획을 가지고 계시다면 이 이슈를 꼭 확인하시길 바랍니다. 이 버그는 페이스북 로그인 등 다른 앱을 이용한 로그인이나, 카드 결제 후 주문서로 돌아오는 흐름에서 큰 문제를 일으킵니다. 이 글이 여러분들께 도움이 되길 바랍니다.</p><p>Swift Korea 그룹에서 Xcode Release Notes에도 같은 내용이 있다는 것을 제보해주셨습니다. Swift Compiler 섹션의 <a href="https://developer.apple.com/library/content/releasenotes/DeveloperTools/RN-Xcode/Chapters/Introduction.html#//apple_ref/doc/uid/TP40001051-CH1-DontLinkElementID_64">Known Issues</a> 4번째 항목입니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ed495077c36" width="1" height="1"><hr><p><a href="https://medium.com/styleshare/swift-4-1%EC%97%90%EC%84%9C-%EB%94%A5%EB%A7%81%ED%81%AC%EB%A1%9C-%EC%95%B1%EC%9D%84-%EC%97%AC%EB%8A%94-%EA%B2%BD%EC%9A%B0-%ED%81%AC%EB%9E%98%EC%8B%9C%EB%82%98%EB%8A%94-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0-ed495077c36">Swift 4.1에서 딥링크로 앱을 여는 경우 크래시되는 문제 해결하기</a> was originally published in <a href="https://medium.com/styleshare">StyleShare</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ReactorKit 시작하기]]></title>
            <link>https://medium.com/styleshare/reactorkit-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-c7b52fbb131a?source=rss-121680200d3a------2</link>
            <guid isPermaLink="false">https://medium.com/p/c7b52fbb131a</guid>
            <category><![CDATA[reactorkit]]></category>
            <category><![CDATA[swift]]></category>
            <category><![CDATA[rxswift]]></category>
            <dc:creator><![CDATA[전수열]]></dc:creator>
            <pubDate>Sat, 31 Mar 2018 14:38:57 GMT</pubDate>
            <atom:updated>2018-04-11T09:42:22.183Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*BlctKHSOIeQYkjY3.png" /></figure><p>오늘은 StyleShare에서 ReactorKit을 사용한지 딱 1년이 되는 날입니다. ReactorKit은 반응형 단방향 앱을 위한 프레임워크로, StyleShare와 Kakao를 비롯한 여러 기업에서 사용하고 있는 기술입니다.</p><p>StyleShare의 iOS 프로젝트 첫 커밋은 2011년 8월 23일입니다. 그 뒤로 약 7년간 크고 작은 기능을 추가하며 굉장히 큰 코드베이스를 가지게 되었습니다. 특히 2015년에는 스토어 기능을 런칭하면서 기존 서비스 만큼이나 많은 코드를 작성했습니다. 서비스 복잡도는 점점 높아졌고, 지속 가능한 코드베이스를 위해 많은 개선이 필요했습니다.</p><p>ReactorKit은 많은 부분에 있어서 StyleShare가 가진 고민을 해결해주었습니다. Flux와 Reactive Programming의 개념을 결합하여 만들어진 ReactorKit에서는 사용자 인터랙션과 뷰 상태가 관찰 가능한 스트림을 통해 단방향으로 전달됩니다. 뷰와 비즈니스 로직을 분리할 수 있게 되면서 모듈간 결합도가 낮아지고 테스트하기 쉬워졌습니다. 또한, 자칫 복잡해질 수 있는 비동기 코드를 일관되게 작성할 수 있게 되었습니다.</p><p>이 글에서는 ReactorKit의 기본 개념과 테스트를 위한 기법을 소개 합니다.</p><h3>데이터 흐름</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*DW3ErzVbhjd3LOIm4bkxLQ.png" /></figure><p>ReactorKit에는 뷰(View)와 리액터(Reactor)라는 개념이 존재합니다. 뷰는 상태를 표현합니다. 뷰 컨트롤러나 셀도 모두 뷰에 해당합니다. 뷰는 사용자 인터랙션을 추상화하여 리액터에 전달하고, 리액터에서 전달받은 상태를 각각의 뷰 컴포넌트에 바인드합니다. 뷰는 비즈니스 로직을 수행하지 않습니다.</p><p>반대로, 리액터는 뷰의 상태를 관리합니다. 뷰에서 액션을 전달받으면 비즈니스 로직을 수행한 뒤 상태를 변경하여 다시 뷰에 전달합니다. 리액터는 UI 레이어에서 독립적이기 때문에 비교적 테스트하기 쉽습니다.</p><h3>View</h3><p>View 프로토콜을 적용하면 뷰를 정의할 수 있습니다. DisposeBag 속성과 bind(reactor:) 메서드를 필수로 정의해야 합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/78a16e327ba4eb073cc5bdbb703c81f9/href">https://medium.com/media/78a16e327ba4eb073cc5bdbb703c81f9/href</a></iframe><p>이 프로토콜을 정의하면 reactor 속성이 자동으로 생성됩니다. 이 속성에 새로운 값이 지정되면 bind(reactor:) 메서드가 자동으로 호출됩니다. 이곳에는 사용자 인터랙션을 리액터에 바인드하거나, 리액터의 상태를 각각의 뷰 컴포넌트에 바인드하는 코드를 작성합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/6a6d5aa66b156cae7d4475f6ed13efb0/href">https://medium.com/media/6a6d5aa66b156cae7d4475f6ed13efb0/href</a></iframe><h3>Reactor</h3><p>리액터를 정의하기 위해서는 Reactor 프로토콜을 사용합니다. 사용자 인터랙션을 표현하는 Action과 뷰의 상태를 표현하는 State, 그리고 상태를 변경하는 가장 작은 단위인 Mutation을 클래스 내부에 필수로 정의해야 합니다. 또한 가장 첫 상태를 나타내는 initialState가 필요합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/572f53fb442c67060d2a69f90a42a07b/href">https://medium.com/media/572f53fb442c67060d2a69f90a42a07b/href</a></iframe><p>Action이나 State와 달리 Mutation은 리액터 클래스 밖으로 노출되지 않습니다. 대신, 클래스 내부에서 Action과 State를 연결하는 역할을 수행합니다. Action이 리액터에 전달되면 두 단계를 거쳐서 뷰의 상태를 변경합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*nonLLQ-fV1neShoWSn2BCQ.png" /></figure><p>mutate() 함수에서는 Action 스트림을 Mutation 스트림으로 변환하는 역할을 합니다. 이곳에서 네트워킹이나 비동기로직 등의 사이드 이펙트를 처리합니다. 그 결과로 Mutation을 방출하면 그 값이 reduce() 함수로 전달됩니다. reduce() 함수는 이전 상태와 Mutation을 받아서 다음 상태를 반환합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/dc8fbdce8314a7eba99be944241c5432/href">https://medium.com/media/dc8fbdce8314a7eba99be944241c5432/href</a></iframe><h3>테스팅</h3><p>테스트를 위해 가장 먼저 고민하게 되는 것은 ‘무엇을 테스트할 것인가’에 대한 것입니다. ReactorKit을 사용하면 뷰와 로직이 분리되어 상대적으로 쉽게 해답을 얻을 수 있습니다.</p><p><strong>View</strong></p><ul><li>사용자 인터랙션이 발생했을 때 Action이 리액터로 잘 전달되는지</li><li>리액터의 상태가 바뀌었을 때 뷰의 컴포넌트 속성이 잘 변경되는지</li></ul><p><strong>Reactor</strong></p><ul><li>Action을 받았을 때 원하는 State로 잘 변경되는지</li></ul><h4>뷰 테스팅</h4><p>리액터의 stub 기능을 이용하면 뷰를 쉽게 테스트할 수 있습니다. stub 기능을 활성화하면 리액터가 받은 Action을 모두 기록하고, mutate()와 reduce()를 실행하는 대신 외부에서 상태를 설정할 수 있게 됩니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9e5e0349766c69076a5081cbd680645b/href">https://medium.com/media/9e5e0349766c69076a5081cbd680645b/href</a></iframe><h4>리액터 테스팅</h4><p>리액터는 뷰에 비해서 상대적으로 테스트하기 쉽습니다. Action이 전달되었을 때 비즈니스 로직을 수행하여 State가 바뀌는지를 확인하면 됩니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/32af3eac8c1c9646bf95ea1442ad8ff4/href">https://medium.com/media/32af3eac8c1c9646bf95ea1442ad8ff4/href</a></iframe><h3>마치며</h3><p>ReactorKit은 지금까지 CocoaPods에서 약 3만 7천회 다운로드 되었고, 약 730개 앱에서 사용되고 있습니다. 최근에는 Wantedly에서 사용하며 일본에서도 많은 호응을 얻고 있습니다. 공개된지 1년밖에 되지 않았지만 굉장히 좋은 평을 받으며 성장하고 있는 프레임워크입니다. 만약 새로운 프로젝트를 시작하거나, StyleShare와 비슷한 고민을 하고 계신다면 ReactorKit을 강력하게 추천합니다.</p><ul><li><a href="https://github.com/ReactorKit/ReactorKit">ReactorKit GitHub</a></li><li><a href="https://youtu.be/ASwBnMJNUK4">let’Swift 2017 ReactorKit 발표 영상</a></li><li><a href="https://www.slideshare.net/devxoul/reactorkit">let’Swift 2017 ReactorKit 발표 자료</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c7b52fbb131a" width="1" height="1"><hr><p><a href="https://medium.com/styleshare/reactorkit-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-c7b52fbb131a">ReactorKit 시작하기</a> was originally published in <a href="https://medium.com/styleshare">StyleShare</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Note that `var delegate` can make a strong reference cycle. Do as following to avoid it:]]></title>
            <link>https://medium.com/@devxoul/note-that-var-delegate-can-make-a-strong-reference-cycle-do-as-following-to-avoid-it-65a80b2916d3?source=rss-121680200d3a------2</link>
            <guid isPermaLink="false">https://medium.com/p/65a80b2916d3</guid>
            <dc:creator><![CDATA[전수열]]></dc:creator>
            <pubDate>Sat, 24 Jun 2017 14:23:37 GMT</pubDate>
            <atom:updated>2017-06-24T14:23:37.552Z</atom:updated>
            <content:encoded><![CDATA[<p>Note that `var delegate` can make a strong reference cycle. Do as following to avoid it:</p><pre>protocol MyViewDelegate: class {<br>  func foo()<br>}</pre><pre>class MyView: UIView {<br>  weak var delegate: MyViewDelegate?<br>}</pre><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=65a80b2916d3" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[iOS 10 웹뷰에서 LSApplicationQueriesSchemes 에 등록되지 않은 URL scheme으로 앱 열기]]></title>
            <link>https://medium.com/styleshare/ios-10-%EC%9B%B9%EB%B7%B0%EC%97%90%EC%84%9C-lsapplicationqueriesschemes-%EC%97%90-%EB%93%B1%EB%A1%9D%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%80-url-scheme%EC%9C%BC%EB%A1%9C-%EC%95%B1-%EC%97%B4%EA%B8%B0-a9f76dae3fcb?source=rss-121680200d3a------2</link>
            <guid isPermaLink="false">https://medium.com/p/a9f76dae3fcb</guid>
            <category><![CDATA[troubleshooting]]></category>
            <category><![CDATA[ios]]></category>
            <category><![CDATA[swift]]></category>
            <dc:creator><![CDATA[전수열]]></dc:creator>
            <pubDate>Wed, 14 Sep 2016 00:00:00 GMT</pubDate>
            <atom:updated>2018-04-11T09:43:56.547Z</atom:updated>
            <content:encoded><![CDATA[<p>미국 현지 시각으로 9월 13일 런칭된 iOS 10 버전에서는 보안과 관련된 여러가지 정책의 변화가 생겼습니다. 그 중, 문서화가 잘 되어있지 않아 곤란했던 정책의 변화는 바로 웹뷰에서의 custom URL scheme을 통한 앱 열기에 관련된 것입니다.</p><h3>문제 발견</h3><p>StyleShare 앱 내 스토어에서는 웹뷰를 통한 결제 방식을 사용하고 있습니다. 결제 프로세스는 다음과 같습니다. 웹뷰로 개발된 KCP 결제 페이지에서 주문 정보를 모두 작성한 후, 카드 결제 버튼을 선택하면 웹뷰에서 각 은행의 결제 앱을 실행하게 됩니다. 실행된 앱에서 사용자가 결제 정보를 입력하여 결제를 완료한 뒤 StyleShare 앱으로 돌아오면 결제가 완료되는 방식입니다. 발견한 문제는 바로 은행 결제 앱이 실행되지 않는 치명적인 문제였습니다.</p><h3>문제 원인</h3><p>웹뷰로 작성된 KCP 주문서는 아마 window.location.replace(&#39;myapp://hello/world&#39;)와 같이 custom URL scheme을 사용해서 결제 앱을 실행하도록 개발되어 있을 것입니다. 웹뷰의 URL이 변경될 경우 iOS가 이를 먼저 알아채고 설치된 앱에 등록된 URL scheme을 확인해서 앱을 실행하도록 하는데요. iOS 10 에서 변화가 생긴 곳이 바로 이 부분이라고 판단됩니다.</p><p>iOS 9 버전에서 처음으로 <a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/LaunchServicesKeys.html#//apple_ref/doc/uid/TP40009250-SW14">LSApplicationQueriesSchemes</a> 라는 Info 항목이 소개되었습니다. URL scheme을 사용해서 외부 앱을 열 경우, 특별한 제한이 없던 기존 방식에서 화이트리스트에 등록된 scheme만 열 수 있도록 보안 정책이 강화된 것인데요. 이 정책이 처음 소개된 iOS 9 버전에서는 웹뷰에서 URL scheme을 사용해서 앱을 열 경우 경고창을 통해 사용자에게 확인하는 과정만 추가되었을 뿐 정상적으로 작동하였습니다. 하지만 iOS 10 버전에서는 화이트리스트에 등록되지 않은 경우, 웹뷰에서는 무조건 차단하는 정책으로 변경된 것으로 보입니다.</p><h3>해결 방법</h3><p>애플에서 권장하는 해결 방법은 아마도 <strong>Info.plist</strong>의 LSApplicationQueriesSchemes 항목에 사용하고자 하는 URL scheme들을 등록하는 방법일 것입니다. 하지만, StyleShare 스토어는 KCP라는 PG사를 통해 각 은행의 결제 앱에 연동하는 구조로 되어 있습니다. 즉, KCP에서 새로운 결제 수단을 추가하거나, 각 은행사에서 앱 URL scheme을 변경/추가/삭제할 경우 각각에 대응해서 새로운 릴리즈를 해야 하는 것입니다. 더 심각한 것은 각 은행사에서 사용하는 URL scheme들이 문서화가 제대로 이루어지지 않거나 파편화되어있다는 점입니다.</p><p>따라서, StyleShare에서는 웹뷰에서 custom URL scheme 요청이 발생하는 경우, 네이티브 코드에서 직접 앱을 실행하도록 하는 방법을 사용했습니다.</p><p><strong>UIWebViewDelegate를 사용하는 경우</strong></p><pre>func webView(_ webView: UIWebView, shouldStartLoadWith request: URLRequest, navigationType: UIWebViewNavigationType) -&gt; Bool {<br>  if let url = request.url, url.scheme != &quot;http&quot; &amp;&amp; url.scheme != &quot;https&quot; {<br>    UIApplication.shared.openURL(url)<br>    return false<br>  }<br>  return true<br>}</pre><p><strong>WKNavigationDelegate를 사용하는 경우</strong></p><pre>func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: <a href="http://twitter.com/escaping">@escaping</a> (WKNavigationActionPolicy) -&gt; Void) {<br>  if let url = navigationAction.request.url, url.scheme != &quot;http&quot; &amp;&amp; url.scheme != &quot;https&quot; {<br>    UIApplication.shared.openURL(url)<br>    decisionHandler(.cancel)<br>  } else {<br>    decisionHandler(.allow)<br>  }<br>}</pre><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a9f76dae3fcb" width="1" height="1"><hr><p><a href="https://medium.com/styleshare/ios-10-%EC%9B%B9%EB%B7%B0%EC%97%90%EC%84%9C-lsapplicationqueriesschemes-%EC%97%90-%EB%93%B1%EB%A1%9D%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%80-url-scheme%EC%9C%BC%EB%A1%9C-%EC%95%B1-%EC%97%B4%EA%B8%B0-a9f76dae3fcb">iOS 10 웹뷰에서 LSApplicationQueriesSchemes 에 등록되지 않은 URL scheme으로 앱 열기</a> was originally published in <a href="https://medium.com/styleshare">StyleShare</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Circle CI에서 rbenv를 이용해서 Ruby 2.2와 CocoaPods 0.39 버전 사용하기]]></title>
            <link>https://medium.com/styleshare/circle-ci%EC%97%90%EC%84%9C-rbenv%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C-ruby-2-2%EC%99%80-cocoapods-0-39-%EB%B2%84%EC%A0%84-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-d886cd3338c4?source=rss-121680200d3a------2</link>
            <guid isPermaLink="false">https://medium.com/p/d886cd3338c4</guid>
            <category><![CDATA[cocoapods]]></category>
            <category><![CDATA[rbenv]]></category>
            <category><![CDATA[circleci]]></category>
            <dc:creator><![CDATA[전수열]]></dc:creator>
            <pubDate>Tue, 02 Aug 2016 00:00:00 GMT</pubDate>
            <atom:updated>2018-04-11T09:44:36.093Z</atom:updated>
            <content:encoded><![CDATA[<p>최근 Circle CI에서 Ruby 버전을 2.3으로, CocoaPods 버전을 1.0으로 업그레이드함에 따라 발생하는 빌드 문제를 rbenv를 이용해서 해결한 경험을 공유합니다. 최종적으로 완성된 <strong>Gemfile</strong>과 <strong>circle.yml</strong> 파일은 <a href="https://styleshare.github.io/2016/08/02/circleci-ios-rbenv.html#conclusion">마지막 섹션</a>에서 확인하실 수 있습니다.</p><h3>1. CocoaPods 1.0</h3><p>지난 2015년 12월에 CocoaPods 1.0.0 베타 버전이 처음 공개되었습니다. CocoaPods이 1.0 버전으로 업그레이드되면서 <a href="http://blog.cocoapods.org/CocoaPods-1.0/">굉장히 많은 변화</a>가 있었는데요. 가장 큰 변화는 DSL입니다. 추상 타겟Abstract Target과 타겟 상속Target Inheritance이 새롭게 소개되면서, 0.39 버전까지 자주 사용되던 link_with 및 :exclusive =&gt; true와 같은 구문이 제거되었습니다.</p><p>이에 따라 기존에 사용하던 <strong>Podfile</strong>이 CocoaPods 1.0 버전과는 호환되지 않는 문제가 발생했습니다. 이를 해결하기 위한 가장 좋은 방법은 새로운 DSL을 사용하여 <strong>Podfile</strong>을 다시 작성하는 것이지만, 꽤 많은 서드파티 라이브러리를 사용하는 StyleShare의 경우 새로운 DSL을 적용하여 빌드하면 각종 문제로 인해 빌드가 정상적으로 이루어지지 않았습니다. 4년동안 유지되고 있는 프로젝트이다보니, 레거시 Objective-C 코드와 라이브러리, 그리고 새로운 Swift 코드와 라이브러리가 혼용되어 사용되는 것도 원인 중 하나일 것입니다.</p><p>따라서 StyleShare에서는 CocoaPods 0.39 버전을 사용하기로 결정을 했습니다. 하지만 최근 Circle CI에서 CocoaPods 버전을 공식적으로 1.0 버전으로 업그레이드하면서 빌드가 깨지기 시작했습니다. Circle CI 환경에서 CocoaPods 0.39 버전을 사용하려면 어떻게 해야 할까요?</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*m5zVqRzMHnpMsG2D.png" /></figure><h3>2. Bundler를 이용해서 Gem 관리하기</h3><p><a href="http://bundler.io/">Bundler</a>는 Ruby로 작성된 라이브러리들의 버전을 관리해주는 강력한 도구입니다. CocoaPods에서 <strong>Podfile</strong>에 의존성을 기재하듯, Bundler에서는 <strong>Gemfile</strong>에 의존성을 기재합니다.</p><pre>source &#39;https://rubygems.org&#39;</pre><pre>gem &#39;cocoapods&#39;, &#39;~&gt; 0.39&#39;</pre><p>$ gem install bundler 명령어를 사용하면 <strong>Gemfile</strong>에 기재된 의존성 라이브러리들을 설치해줍니다. 이렇게 설치된 CocoaPods을 사용할 때에는 $ pod COMMAND 대신 $ bundle exec pod COMMAND 명령어를 사용해야 합니다.</p><pre>$ gem install bundler<br>$ bundle install --path vendor/bundle<br>$ bundle exec pod --version<br>0.39.0</pre><h3>3. Ruby 2.3과 CocoaPods 0.39</h3><p>Bundler를 사용해서 CocoaPods 0.39 버전을 사용하기만 하면 모든 문제가 해결될 줄 알았습니다. 하지만 더 큰 삽질이 남아있었는데요. 바로 Ruby 2.3 버전이 CocoaPods 0.39 버전과 호환되지 않는 것이었습니다.</p><pre>$ bundle exec pod install<br>Updating local specs repositories<br>Analyzing dependencies</pre><p>신나게 $ bundle exec pod install 명령어를 실행하니, 의존성을 분석하는 듯 싶다가 갑자기 에러를 주르륵 뱉습니다. 에러 로그의 #### Error 항목을 보면 에러 메시지가 나와있습니다.</p><blockquote>NoMethodError — undefined method `to_ary’ for #&lt;Pod::Specification name=”…”&gt;</blockquote><p>이 에러 메시지로 CocoaPods GitHub 저장소의 <a href="https://github.com/CocoaPods/CocoaPods/issues?utf8=%E2%9C%93&amp;q=undefined%20method%20to_ary">이슈를 검색</a>해보면 꽤나 많은 이슈가 올라와 있습니다. 이 이슈들을 보면, 모두 Ruby 버전이 2.3이라는 공통점이 있습니다. Ruby 버전을 2.2로 내렸더니 문제가 해결됐다는 댓글들도 굉장히 많고요. Circle CI의 Ruby 버전을 2.2로 낮추면 문제가 해결될 것 같습니다.</p><p><a href="https://circleci.com/docs/configuration/#ruby-version">Circle CI 문서</a> 내용에 따라 <strong>circle.yml</strong>에 Ruby 버전을 기재해봅시다.</p><pre>machine:<br>  ruby:<br>    version: 2.2.5</pre><p>그러나 Circle CI의 OS X 컨테이너에서는 Ruby 버전 변경을 지원하지 않는다고 합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*o3C0GMIkorKCMcDx.png" /></figure><h3>4. rbenv를 이용해서 Ruby 2.2 사용하기</h3><p>그러다가 알게된 것이 바로 <a href="https://github.com/rbenv/rbenv">rbenv</a>입니다. rbenv를 사용하면 여러개의 Ruby 버전을 깔끔하게 관리할 수 있게 됩니다. rbenv는 <a href="http://brew.sh/">Homebrew</a>를 사용해서 쉽게 설치할 수 있습니다.</p><p>rbenv는 ~/.rbenv 디렉토리에 안에 여러 Ruby 버전을 설치하고 관리합니다. rbenv를 설치한 뒤 가장 먼저 할 일은 환경변수 $PATH를 설정해주는 것입니다. $PATH에는 $HOME/.rbenv/shims와 $HOME/.rbenv/bin 경로가 포함되어있어야 합니다.</p><h4>4.1 환경변수 설정하기</h4><p>Circle CI에서는 환경변수를 설정하는 <a href="https://circleci.com/docs/configuration/#environment">편리한 인터페이스</a>를 제공합니다. 하지만, Circle CI에서 실행되는 각 명령어는 별도의 쉘에서 실행됩니다. 그말인 즉슨, 각 명령어가 실행되기 직전에 새로운 쉘이 실행되고, $PATH 환경변수를 덮어쓰는 <strong>.bash_profile</strong>이 실행된 후 명령어가 실행된다는 뜻인데요. 이렇게 될 경우 $PATH 환경변수의 가장 우선순위는 항상 /usr/local/bin이 가지게 됩니다. 그리고 같은 이유로 $ export FOO=bar와 같은 명령어도 사용할 수 없게 됩니다.</p><p>고민을 하다가 생각해낸 방법은 바로 <strong>.bash_profile</strong>의 내용을 변경(!)하는 것입니다. 그렇게 되면 우리가 원하는 $PATH를 항상 우선순위로 둘 수 있게 됩니다. 아래와 같이 환경변수를 설정하는 명령어를 <strong>.bash_profile</strong>의 가장 아랫줄에 삽입하도록 설정했습니다.</p><pre>machine:<br>  pre:<br>    - echo &quot;export PATH=\$HOME/.rbenv/shims:\$HOME/.rbenv/bin:\$PATH&quot; &gt;&gt; .bash_profile<br>    - echo &quot;export RBENV_SHELL=bash&quot; &gt;&gt; .bash_profile</pre><h4>4.2 rbenv에 Ruby 2.2 설치하기</h4><p>그 다음으로 할 일은 원하는 Ruby 2.2 버전을 설치하는 것입니다. $ rbenv install -l을 사용해서 설치 가능한 모든 Ruby 버전을 조회할 수 있고, $ rbenv install 2.2.5 명령어를 사용해서 2.2.5 버전을 설치할 수 있습니다.</p><pre>$ rbenv install -l<br>Available versions:<br>  1.8.5-p113<br>  1.8.5-p114<br>  1.8.5-p115<br>  1.8.5-p231<br><em>  ...<br></em>$ rbenv install 2.2.5</pre><p>이렇게 설치된 버전은 두 가지 방법으로 사용될 수 있습니다. 한 가지 방법은 시스템 전체에서 사용하는 것이고, 다른 한 가지 방법은 프로젝트 단위로 사용하는 방법입니다. 시스템 전체에서 사용하려면 $ rbenv global 2.2.5 명령어를, 프로젝트 단위로 사용하려면 $ rbenv local 2.2.5 명령어를 사용합니다.</p><p>global 명령어를 사용해서 Ruby 버전을 선택하면 ~/.rbenv/version 파일에 선택된 버전이 기록됩니다.</p><pre>$ rbenv global 2.2.5<br>$ cat ~/.rbenv/version 2.2.5</pre><p>local 명령어를 사용하면 현재 디렉토리의 .ruby-version 파일에 선택된 버전이 기록됩니다.</p><pre>$ rbenv global 2.2.5<br>$ cat ~/.rbenv/version<br>2.2.5</pre><p>local 명령어로 선택된 Ruby 버전은 global 명령어로 선택된 Ruby 버전보다 우선순위가 높습니다. $ rbenv version 명령어를 사용하면 현재 선택된 버전을 확인할 수 있습니다.</p><pre>$ rbenv version<br>2.2.5 (set by /project/path/.ruby-version)</pre><p>Circle CI에서는 편의를 위해 global 명령어를 사용해서 Ruby 버전을 선택하도록 했습니다.</p><pre>dependencies:<br>  pre:<br>    - brew update<br>    - brew install rbenv<br>    - rbenv install 2.2.5<br>    - rbenv global 2.2.5</pre><h4>4.3 Bundler 다시 설치하기</h4><p>rbenv를 사용해서 새로운 Ruby 버전을 설치했기 때문에, Circle CI 시스템에서 제공하는 Gem도 다시 설치해야 합니다. 우리는 Bundler로 Gem 의존성을 관리하기로 했으므로, Bundler만 재설치합니다.</p><pre>$ gem install bundler --no-ri --no-rdoc<br>$ rbenv rehash</pre><p>$ gem install 명령어를 실행한 후에는 $ rbenv rehash 명령어를 실행해서 executable 경로들을 재설정해주어야 합니다.</p><h4>4.4 ~/.rbenv 경로 캐싱하기</h4><p>rbenv를 사용해서 Ruby를 설치하는 과정이 굉장히 오래 걸립니다. 이 경우, Circle CI에서 제공하는 캐싱 기능을 사용해서 이 과정을 한 번만 하고 건너뛸수 있게 됩니다.</p><pre>dependencies:<br>  cache_directories:<br>    - ~/.rbenv</pre><p>위와 같이 <strong>circle.yml</strong>를 설정해주면 컨테이너 실행시 <strong>~/.rbenv</strong> 디렉토리가 캐시로부터 설정됩니다. 캐싱된 디렉토리를 사용하는 경우 Ruby 버전이 미리 설치되어있기 때문에 $ rbenv install시에 --skip-existing 옵션을 추가해주어서 캐싱된 버전을 재설치하지 않도록 합니다.</p><h3>5. 마치며</h3><p>최종적으로 완성된 <strong>Gemfile</strong>과 <strong>circle.yml</strong> 파일은 다음과 같습니다.</p><p><strong>Gemfile</strong></p><pre>source &#39;https://rubygems.org&#39;</pre><pre>gem &#39;cocoapods&#39;, &#39;~&gt; 0.39&#39;</pre><p><strong>circle.yml</strong></p><pre>machine:<br>  pre:<br>    - echo &quot;export PATH=\$HOME/.rbenv/shims:\$HOME/.rbenv/bin:\$PATH&quot; &gt;&gt; .bash_profile<br>    - echo &quot;export RBENV_SHELL=bash&quot; &gt;&gt; .bash_profile<br>  xcode:<br>    version: 7.3<br><br>dependencies:<br>  cache_directories:<br>    - ~/.rbenv<br>  pre:<br>    - brew update<br>    - brew install rbenv<br>    - rbenv install 2.2.5 --skip-existing<br>    - rbenv global 2.2.5<br>    - gem install bundler --no-ri --no-rdoc<br>    - rbenv rehash<br>    - bundle install --path vendor/bundle<br>  override:<br>    - bundle exec pod --version<br>    - bundle exec pod install</pre><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d886cd3338c4" width="1" height="1"><hr><p><a href="https://medium.com/styleshare/circle-ci%EC%97%90%EC%84%9C-rbenv%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C-ruby-2-2%EC%99%80-cocoapods-0-39-%EB%B2%84%EC%A0%84-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-d886cd3338c4">Circle CI에서 rbenv를 이용해서 Ruby 2.2와 CocoaPods 0.39 버전 사용하기</a> was originally published in <a href="https://medium.com/styleshare">StyleShare</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Estimator: BLE를 사용한 Planning Poker 애플리케이션]]></title>
            <link>https://medium.com/styleshare/estimator-ble%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-planning-poker-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-fe1c3c4357fa?source=rss-121680200d3a------2</link>
            <guid isPermaLink="false">https://medium.com/p/fe1c3c4357fa</guid>
            <category><![CDATA[agile]]></category>
            <category><![CDATA[ios]]></category>
            <category><![CDATA[scrum]]></category>
            <category><![CDATA[swift]]></category>
            <category><![CDATA[ble]]></category>
            <dc:creator><![CDATA[전수열]]></dc:creator>
            <pubDate>Thu, 05 Nov 2015 00:00:00 GMT</pubDate>
            <atom:updated>2018-04-11T09:45:14.651Z</atom:updated>
            <content:encoded><![CDATA[<p>StyleShare 개발팀에서는 스크럼을 활용하여 일을 진행하고 있습니다. 스크럼에는 일감의 크기를 추정(estimate)하는 과정이 있는데요. 구성원들 모두가 일감에 대해 이해하고 일감의 크기가 어느정도인지 함께 논의하여 합의에 이르는 과정입니다. 스프린트 회의에서 일감을 등록한 사람(리포터)이 일감에 대해 설명하고 나서 전체 구성원들이 일감의 크기를 추정하는데, 이 때 사용하는 것이 바로 Planning Poker입니다.</p><p>Planning Poker는 0.5부터 시작해서 1, 3, 5, 8, 13, 20, … 100과 같이 피보나치 수열로 증가하는 숫자를 가진 카드 덱입니다. 리포터의 설명이 끝난 뒤 스크럼 마스터가 하나, 둘, 셋을 외치면 각자 생각한 일감의 크기에 맞는 카드를 꺼내고, 스크럼 마스터는 구성원들의 추정치가 최대한 가까워지도록 부가설명이나 질문을 유도합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/500/0*IDrz1ZfR4Pu2GKu5.jpg" /></figure><p>하지만 개발팀이 커지면서 불편함이 생기기 시작했습니다. 회의에 참여하는 인원이 7–8명씩 되다 보니, 각자가 어떤 카드를 들고있는지 한눈에 보기가 어려워진 것입니다. StyleShare에서 자칭 아이디어 뱅크 역할을 담당하고 있는 저는 획기적인 방법이 필요하다고 생각했고, 굳이 카드를 꺼내들지 않아도 각자가 무슨 카드를 선택했는지를 쉽게 볼 수 있는 애플리케이션을 만들기로 결심했습니다.</p><h3>2. BLE (Bluetooth Low Energy)</h3><p>불편함을 덜기 위한 애플리케이션이므로, 사용자 경험이 굉장히 직관적이고 단순해야 했습니다. N:N 통신이 가능해야하고, 사용자를 귀찮게 하는 페어링이나 네트워크 접속 과정이 없어야 했습니다. 한마디로, <strong>카드를 꺼내들고 눈으로 확인하는 것보다 더 편한 무언가</strong>를 만들어야 했습니다!</p><p>처음에는 근거리 무선 통신을 위한 기술로 스타벅스에서 사이렌 오더 개발에 사용한 고주파 인식 기술을 생각했습니다. 각자의 기기에서 선택한 카드에 맞는 소리를 내보내고, 다른 기기에서는 고주파를 읽겠다는 것이었는데요. <a href="http://www.soundl.ly/">Soundlly</a>(구 aircast.me)와 같은 상업용 SDK를 쓰지 않는 이상, 사운드 프로그래밍을 한 번도 해본 적 없는 저에게는 데이터가 실린 고주파를 만드는 것부터 소리를 인식해서 데이터를 읽어내는 과정이 마치 화성에서 감자 키우는 이야기처럼 들렸습니다.</p><p>그러다 문득 생각난 것이 바로 비콘(Beacon)입니다. 언젠가 소비자가 오프라인 매장에 방문하면 BLE를 이용해서 매장 위치를 파악하는 기술이 있다는 이야기를 들은 적이 있었습니다. 찾아보니 시중에 나와있는 대부분의 모바일 기기에서는 BLE를 위한 최소 조건인 블루투스 4.0을 지원했고, 페어링이나 네트워크 접속 과정도 불필요했습니다. 무엇보다, 화성에서 감자 키우는 것보다는 쉬워보였습니다.</p><h3>3. Swift로 BLE 개발하기</h3><p>그래서 BLE를 사용해서 개발하기로 했습니다. 컨셉은 간단했습니다. 내가 선택한 카드를 브로드캐스팅하고, 다른 사람들이 선택한 카드를 내 모바일 기기에 보여주면 되는 것이었습니다. BLE를 사용하면 정보를 브로드캐스팅할 수 있고, 다른 기기에서 브로드캐스팅하는 정보를 읽을 수 있습니다.</p><p>BLE에서 데이터를 브로드캐스팅하는 것을 <em>Advertising</em>이라고 합니다. 정보를 advertising하는 주체는 <em>Peripheral</em>이고, advertising되는 정보를 스캔하여 데이터를 읽어들이는 주체는 <em>Central</em>이라고 합니다. Peripheral에서 정보를 advertising할 때에는 특정한 정보를 실어나를 수 있는데요. 이를 <em>Advertising Data Payload</em>라고 합니다. 이 정보에 카드 숫자와 이름을 실어서 전송하면 될 것 같습니다.</p><p>BLE를 구현하기 위해서, iOS에서는 SDK에 기본적으로 포함돼있는 <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html">CoreBluetooth</a> 프레임워크를 사용하면 손쉽게 개발이 가능합니다. <a href="https://developer.apple.com/library/prerelease/ios/documentation/CoreBluetooth/Reference/CBPeripheralManager_Class/index.html">CBPeripheralManager</a> 클래스와 <a href="https://developer.apple.com/library/prerelease/ios/documentation/CoreBluetooth/Reference/CBCentralManager_Class/index.html">CBCentralManager</a> 클래스를 쓰면 되는데요. BLE를 이용하여 제 이름 석자를 advertising하는 코드는 다음과 같습니다.</p><p><strong>Peripheral</strong></p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/1fa936e052d7e42470037ed54a775d35/href">https://medium.com/media/1fa936e052d7e42470037ed54a775d35/href</a></iframe><p>마찬가지로, Peripheral에서 advertising하는 정보를 스캔하는 Central 코드는 다음과 같이 작성할 수 있습니다. UUID는 Peripheral에서 advertising에 사용한 UUID와 동일해야합니다.</p><p><strong>Central</strong></p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/a7a957319298afe45b4a5773289e26bb/href">https://medium.com/media/a7a957319298afe45b4a5773289e26bb/href</a></iframe><p>스캔을 시작할 때 CBCentralManagerScanOptionAllowDuplicatesKey 옵션을 true로 설정해서 한 번 스캔된 정보라도 중복으로 계속 스캔하도록 합니다.</p><h3>4. 원하는 정보를 실어나르기</h3><p>CBPeripheralManager을 사용하여 advertising을 할 때에는 Advertising Data Payload를 포함시킬 수 있는데, 이 정보 중 개발자가 원하는 값을 넣을 수 있는 곳은 CBAdvertisementDataLocalNameKey밖에 없습니다. 그마저도 길이가 제한돼있기 때문에, 패킷을 효율적으로 사용하기 위해서는 정보를 저장하는 프로토콜을 직접 정의해야 합니다.</p><p>우선, 카드에 대한 정의는 enum을 사용해서 작성했습니다. 0부터 0xFF까지의 숫자를 가지도록 정의했습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/6fceaf8a73ddc55fa996deb1b85a6cee/href">https://medium.com/media/6fceaf8a73ddc55fa996deb1b85a6cee/href</a></iframe><p>그리고 제가 정의한 패킷의 프로토콜은 다음과 같습니다.</p><p>영역 길이 예시 설명 Version 2 00 프로토콜 버전 (00~FF) Channel 2 01 BLE 커버리지 내에서 회의하는 팀이 여럿일 수 있으니, 채널로 구분합니다. (00~FF) Card 2 FE 카드의 16진수 값 (00~FF) Name 12 전수열 사용자 이름 (UTF-8 기준 한글 4글자)</p><p>이렇게 하면 총 18바이트 내에서 필요한 정보를 모두 전송할 수 있습니다. 이제 이 &quot;00&quot;, &quot;01&quot;, &quot;FE&quot;, &quot;전수열&quot; 값을 직렬화해서 CBAdvertisementDataLocalNameKey로 advertising하면 됩니다.</p><p><strong>Peripheral</strong></p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/af2455061c37111f34d50e8f59b8fca4/href">https://medium.com/media/af2455061c37111f34d50e8f59b8fca4/href</a></iframe><p>그리고, Central에서 정보를 스캔할 때에는 이 값을 각 영역의 길이에 맞게 끊어서 읽을 수 있습니다.</p><p><strong>Central</strong></p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/58bc82d68e88a747bd84df8effb5bc5f/href">https://medium.com/media/58bc82d68e88a747bd84df8effb5bc5f/href</a></iframe><h3>5. 마치며</h3><p>비록 적은 양의 정보지만, BLE를 사용해서 실시간으로 근거리 통신을 할 수 있게 되었습니다. 이제 남은 것은 카드를 선택할 수 있는 화면과, 다른 사용자가 선택한 카드를 화면에 보여주는 인터페이스입니다. UI 개발은 본 포스트에서 중점적으로 다루고자 하는 주제와는 조금 벗어난 이야기가 될 것 같아, 오픈소스로 공개된 코드로 대신하려고 합니다. 소스코드는 <a href="https://github.com/devxoul/Estimator">GitHub</a>에서 볼 수 있으며, Estimator는 <a href="https://itunes.apple.com/us/app/id1069044116?mt=8">앱스토어</a>에서 받아보실 수 있습니다.</p><h3>6. 참고 자료</h3><ul><li><a href="http://www.hardcopyworld.com/gnuboard5/bbs/board.php?bo_table=lecture_tip&amp;wr_id=20">BLE(BLUETOOTH LOW ENERGY) 이해하기 — Hard Copy World</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fe1c3c4357fa" width="1" height="1"><hr><p><a href="https://medium.com/styleshare/estimator-ble%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-planning-poker-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-fe1c3c4357fa">Estimator: BLE를 사용한 Planning Poker 애플리케이션</a> was originally published in <a href="https://medium.com/styleshare">StyleShare</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
    </channel>
</rss>