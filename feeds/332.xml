<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Engineering</title>
  
  <subtitle>To become a happy engineer</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://donghopark.github.io/"/>
  <updated>2019-03-10T12:53:08.199Z</updated>
  <id>https://donghopark.github.io/</id>
  
  <author>
    <name>Dongho Park</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Scratch] Scratch 기본 익히기 #7 - 코드의 이해(감지, 연산, 변수)</title>
    <link href="https://donghopark.github.io/2019/03/08/scratch-basic-7/"/>
    <id>https://donghopark.github.io/2019/03/08/scratch-basic-7/</id>
    <published>2019-03-07T21:44:41.000Z</published>
    <updated>2019-03-10T12:53:08.199Z</updated>
    
    <content type="html"><![CDATA[<p>자 이제 Scratch 기본 익히기의 마지막 시간입니다. 이번 시간에는 <code>감지</code>, <code>연산</code>, <code>변수</code> 카테고리를 배워봅시다. </p><h2 id="감지"><a href="#감지" class="headerlink" title="감지"></a>감지</h2><p>감지 카테고리의 블록은 스프라이트의 상태변화 혹은 이벤트의 발생여부등을 알아내기위해 사용합니다. (일부 블록의 경우, 이벤트 카테고리의 블록들과 혼용하여 사용할 수 있습니다. 이 부분은 중급에서 다시 다루도록 하겠습니다.)</p><p>많은 블록들이 있지만, 이번시간에는 가장 많이 사용되는 블록의 이동을 감지하는 아래의 블록들을 살펴보겠습니다.</p><img src="https://i.imgur.com/qHr3To4.png"><p>스프라이트가 특정위치로 이동했는지를 알아내려할때, 위의 블록들을 사용할 수 있습니다. (물론 더 많은 방법들이 있지만, 오늘은 이정도만 익히도록 합시다.)</p><h3 id="특정-스트라이프에-닿았는지를-확인하는-방법"><a href="#특정-스트라이프에-닿았는지를-확인하는-방법" class="headerlink" title="특정 스트라이프에 닿았는지를 확인하는 방법"></a>특정 스트라이프에 닿았는지를 확인하는 방법</h3><p>예제와 같이 개구리 스프라이트와 고양이 스프라이트가 있는 상황에서 개구리가 이동하여 고양이까지 이동했는지를 확인할때 사용합니다. 추격게임 혹은 아이템을 먹어야 하는 경우에 이용됩니다.</p><div class="video-container"><iframe src="//www.youtube.com/embed/son_1hBZS1s" frameborder="0" allowfullscreen></iframe></div><h3 id="배경의-특정-색갈에-닿았는지를-확인하는-방법"><a href="#배경의-특정-색갈에-닿았는지를-확인하는-방법" class="headerlink" title="배경의 특정 색갈에 닿았는지를 확인하는 방법"></a>배경의 특정 색갈에 닿았는지를 확인하는 방법</h3><p>미로탐색과 같이 배경을 따라 이동해야 하는 경우, 배경의 특정 색갈에 스프라이트가 닿았는지를 확인하기 위해 사용합니다.</p><div class="video-container"><iframe src="//www.youtube.com/embed/KOXw4T_Wuz0" frameborder="0" allowfullscreen></iframe></div><h2 id="연산"><a href="#연산" class="headerlink" title="연산"></a>연산</h2><img src="https://i.imgur.com/H6BQfmc.png"><p>연산 카테고리의 블록들은 더하기, 빼기 등의 산술연산과 그리고, 또는 등의 논리연산, 마지막으로 문자열을 결합하거나 추출하는등의 기능을 수행합니다.</p><h2 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h2><img src="https://i.imgur.com/lTVKWkn.png"><p>앱을 만드는 과정에서 전체 스트라이프가 함께 공유해야 하는 정보가 있을 경우, 변수를 만들어서 사용할 수 있습니다. <em>가장 흔하게 사용되는 경우는 게임의 <code>점수</code>를 저장하기 위해 변수를 사용하는 경우입니다.</em></p><blockquote><p><code>변수</code>란 <code>값이 변할 수 있는 수</code>를 말하는 것으로, <code>1</code>,<code>2</code>,<code>3</code> 과같이 값이 고정되어있는 <code>상수</code>와 구분되는 개념입니다. <code>나의 변수</code>라는 변수를 만들고 변수에 원하는 값으로 정하거나, 바꿀 수 있습니다.</p></blockquote><blockquote><p><code>리스트 만들기</code>는 중급에서 다루도록 하겠습니다.</p></blockquote><p>자 여기까지 오시느라 고생했습니다. Scratch 의 기본을 모두 익혔습니다. 다음에는 애니메이션 만들기 실습을 따라하며 조금더 고급 기술을 익혀보겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;자 이제 Scratch 기본 익히기의 마지막 시간입니다. 이번 시간에는 &lt;code&gt;감지&lt;/code&gt;, &lt;code&gt;연산&lt;/code&gt;, &lt;code&gt;변수&lt;/code&gt; 카테고리를 배워봅시다. &lt;/p&gt;
&lt;h2 id=&quot;감지&quot;&gt;&lt;a href=&quot;#감지&quot; cla
      
    
    </summary>
    
      <category term="tech" scheme="https://donghopark.github.io/categories/tech/"/>
    
      <category term="scratch" scheme="https://donghopark.github.io/categories/tech/scratch/"/>
    
    
      <category term="scratch" scheme="https://donghopark.github.io/tags/scratch/"/>
    
  </entry>
  
  <entry>
    <title>[Scratch] Scratch 기본 익히기 #6 - 코드의 이해(이벤트, 제어)</title>
    <link href="https://donghopark.github.io/2019/03/08/scratch-basic-6/"/>
    <id>https://donghopark.github.io/2019/03/08/scratch-basic-6/</id>
    <published>2019-03-07T21:44:38.000Z</published>
    <updated>2019-03-10T11:46:15.276Z</updated>
    
    <content type="html"><![CDATA[<p>이번 강의에서는 뭔가 <code>&#39;프로그램&#39;하면 떠오르는</code> 블록들을 배우게 됩니다. <em>그럼 조금더 프로그래머다워져 볼까요?</em></p><h2 id="이벤트"><a href="#이벤트" class="headerlink" title="이벤트"></a>이벤트</h2><p>이벤트 카테고리는 외부(혹은 내부)에서 발생할 수 있는 이벤트를 처리하는 블록들입니다.</p><blockquote><p>여기서 말하는 <code>이벤트</code>란 사용자가 마우스(혹은 키보드)를 눌렀거나, 앱 내부의 상태가 변화한 것을 말합니다. </p></blockquote><p>이벤트 카테고리의 블록들은 크게 이벤트가 발생했을때 이를 처리하는 처리블록과, 이벤트(메시지)를 발생시키는 생성블록으로 나누어집니다.</p><h3 id="생성블록"><a href="#생성블록" class="headerlink" title="생성블록"></a>생성블록</h3><img src="https://i.imgur.com/PHQcs2g.png"><p>사용자의 행동(마우스 클릭, 키보드 클릭)외에도 앱 내부의 상태 변화를 이벤트로 만들어 방송할 수 있습니다. 예를들어, <code>새로운 적 등장</code> 이라는 이벤트를 만들어서 방송할 수 있습니다. 앱 내의 다양한 스프라이트들은 이 새로운 이벤트를 자신에 맞게 처리할 수 있습니다. (물론 처리하지 않을 수도 있습니다.)</p><blockquote><p><code>메시지</code>란 쉽게 라디오를 방송하는것을 연상하면 됩니다. 라디오는 특정한 대상을 지정하지 않고 방송을 하고 누구나 그 방송을 들을 수 있습니다. 이와 마찬가지로, 누군가 메시지를 보내면, 앱 내에 존재하는 모든 스프라이트는 그 메시지를 받아서 처리할 수 있습니다. </p></blockquote><h3 id="처리블록"><a href="#처리블록" class="headerlink" title="처리블록"></a>처리블록</h3><img src="https://i.imgur.com/St0tVJD.png"><p>특정한 이벤트가 방송되었을때, 해당 이벤트를 처리하고자 하는 스프라이트는 이 <code>처리블록</code> 을 이용하여 이를 코딩할 수 있습니다. 예를들어, 위에서 생성한 <code>새로운 적 등장</code> 이라는 이벤트를 처리하고자 하면 <code>새로운 적 등장 신호를 받았을때</code> 라는 블록을 이용하여 코딩을 하면 됩니다. (해당 처리블록을 스프라이트가 가지고 있지 않으면, 해당 메시지는 무시됩니다.)</p><p>아래의 동영상을 통해서 <strong>메시지 신호를 보낸 후 받아서 처리하는 과정을 살펴보세요.</strong></p><div class="video-container"><iframe src="//www.youtube.com/embed/Cj6ymu4yamU" frameborder="0" allowfullscreen></iframe></div><h2 id="제어"><a href="#제어" class="headerlink" title="제어"></a>제어</h2><img src="https://i.imgur.com/EF704tk.png"><p>제어 카테고리의 블록들은 <code>기다리기</code>, <code>반복하기</code>, <code>조건에따라 실행하기</code> 등과같이 블록의 실행을 제어하는 블록입니다. 예를들어, <code>10 만큼 움직이기</code> 를 10번 반복해야 하는 상황이라면 <code>10번 반복하기</code> 블록을 이용할 수 있습니다. (물론 <code>10만큼 움직이기</code> 블록을 10개 연결하거나, <code>100 만큼 움직이기</code> 라는 블록을 사용해도 됩니다.)</p><img src="https://i.imgur.com/c4UUnKj.png"><blockquote><p>제어 카테고리의 <code>복제되었을 때</code>, <code>나 자신 복제하기</code>, <code>이 복제본 삭제하기</code> 블록은 차후 중급과정에서 다루겠습니다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번 강의에서는 뭔가 &lt;code&gt;&amp;#39;프로그램&amp;#39;하면 떠오르는&lt;/code&gt; 블록들을 배우게 됩니다. &lt;em&gt;그럼 조금더 프로그래머다워져 볼까요?&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;이벤트&quot;&gt;&lt;a href=&quot;#이벤트&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="tech" scheme="https://donghopark.github.io/categories/tech/"/>
    
      <category term="scratch" scheme="https://donghopark.github.io/categories/tech/scratch/"/>
    
    
      <category term="scratch" scheme="https://donghopark.github.io/tags/scratch/"/>
    
  </entry>
  
  <entry>
    <title>[Scratch] Scratch 기본 익히기 #5 - 코드의 이해(동작, 형태, 소리)</title>
    <link href="https://donghopark.github.io/2019/03/08/scratch-basic-5/"/>
    <id>https://donghopark.github.io/2019/03/08/scratch-basic-5/</id>
    <published>2019-03-07T21:44:36.000Z</published>
    <updated>2019-03-10T11:46:15.275Z</updated>
    
    <content type="html"><![CDATA[<p>인터페이스와 스트라이프에대해 공부를 마쳤으니, 이제 코딩에 대해서 배워보도록 하겠습니다.</p><p>스트라이프에서는 기본적으로 8가지의 코드 카테고리와, 추가적으로 제공하는 별도의 카테로리를 제공합니다. 이번 시간에는 그중에서 <code>동작</code>, <code>형태</code>, <code>소리</code> 카테고리에 대해서 배워보겠습니다.</p><h2 id="동작"><a href="#동작" class="headerlink" title="동작"></a>동작</h2><p>동작 카테고리의 블록들은 모두 스프라이트의 동작과 관련된 블록들입니다. </p><blockquote><p>이미 설명한바와 같이, 배경에는 동작과 관련된 블록들이 존재하지 않습니다. 배경을 이동시키는 방법은 나중에 배우도록 하겠습니다.</p></blockquote><h3 id="방향관련"><a href="#방향관련" class="headerlink" title="방향관련"></a>방향관련</h3><p>아래의 블록들은 모두 스프라이트가 바라보는 방향을 변경시키는 블록들입니다.</p><img src="https://i.imgur.com/FzufChk.png"><p>방향은 무대영역에서의 스프라이트가 표시되는 방법에 영향을 주는것과 함께, 아래에서 배울 이동에도 영향을 줍니다. </p><blockquote><p>스프라이트의 방향은 위를 바라보고 있을때를 <code>0</code> 으로 표시하고 시계방향으로 증가합니다.</p></blockquote><h3 id="이동관련"><a href="#이동관련" class="headerlink" title="이동관련"></a>이동관련</h3><p>무대영역에서 스프라이트가 이동할때 사용하는 블록들로, 방향을 따라 이동하는 블록들과 방향에 상관없이 이동하는 블록으로 나누어집니다.</p><h4 id="바라보고있는-방향으로-이동하기"><a href="#바라보고있는-방향으로-이동하기" class="headerlink" title="바라보고있는 방향으로 이동하기"></a>바라보고있는 방향으로 이동하기</h4><p>아래의 블록은 스프라이트가 바라보고 있는 방향으로 스프라이트를 이동시키는 블록들입니다. 따라서, 이 블록을 사용할 경우네는 위에서 배운 방향을 꼭 신경써야 합니다.</p><img src="https://i.imgur.com/yy0kT0l.png"><h4 id="X-Y-축을-기준으로-이동하기"><a href="#X-Y-축을-기준으로-이동하기" class="headerlink" title="X-Y 축을 기준으로 이동하기"></a>X-Y 축을 기준으로 이동하기</h4><p>아래의 블록들은 스프라이트가 바라보는 방향과 상관없이 스프라이트를 이동시키는 블록들입니다. 즉, 무대영역의 기준 좌표를 기준으로 스프라이트가 이동하게됩니다. </p><img src="https://i.imgur.com/yAdz1CV.png"><blockquote><p>무대영역의 기준 좌표란 무대의 정 가운데를 기준으로 오른쪽/왼쪽을 <code>x축</code>, 위/아래를 <code>y축</code> 으로 표현하는 방식을 말합니다. 스프라이트의 위치를 표시할때는 (x축의 값, y축의 값) 과 같이 표현하는데, 스프라이트가 (0,0) 에 존재한다는 소리는 무대의 정 중앙에 위치한다는 것을 의미합니다.<br>무대는 가로(x 축) 481, 세로(y 축) 361 입니다. 이에따라, 무대의 가장 왼쪽 아래는 (-240, -180), 무대의 가장 오른쪽 위는 (240,180) 의 x,y 좌표를 가지게 됩니다.<br><em>스프라이트의 크기에 따라 스프라이트가 위치할 수 있는 공간이 조금씩 축소되기도 합니다.</em></p></blockquote><p>아래의 동영상을 통해서 스프라이트가 오른쪽을 향할때 <code>10만큼 움직이기</code> 와 <code>x좌표를 10만큼 바꾸기</code> 의 동작을 살펴보고, 스프라이트가 위쪽을 향할때와 비교해봅시다.</p><div class="video-container"><iframe src="//www.youtube.com/embed/wLov5mtwEjI" frameborder="0" allowfullscreen></iframe></div><h2 id="형태"><a href="#형태" class="headerlink" title="형태"></a>형태</h2><p>형태 카테고리의 블록들은 모두 스프라이트(혹은 배경)가 무대에 표시되는 방식을 변경시키는 블록들입니다.</p><h3 id="말하기-생각하기-lt-스프라이트-gt"><a href="#말하기-생각하기-lt-스프라이트-gt" class="headerlink" title="말하기/생각하기 &lt;스프라이트&gt;"></a>말하기/생각하기 &lt;스프라이트&gt;</h3><p>스프라이트에 말풍선 혹은 생각풍선을 표시해서 마치 스프라이트가 이야기하는 듯한 표현을 하는 블록입니다. **’?초동안’이라는 제한을 하지않으면 다른 말풍선이 표시되는 시점까지 계속 말풍선이 표시됩니다. </p><img src="https://i.imgur.com/gDe1SD5.png"><h3 id="모양-배경-바꾸기-lt-스프라이트-배경-gt"><a href="#모양-배경-바꾸기-lt-스프라이트-배경-gt" class="headerlink" title="모양/배경 바꾸기 &lt;스프라이트, 배경&gt;"></a>모양/배경 바꾸기 &lt;스프라이트, 배경&gt;</h3><p>스프라이트에 포함된 모양을 변경하거나, 배경을 변경하는 블록입니다. 변경하고자 하는 모양을 지정하여 바꾸거나 순차적으로 바꿀 수 있습니다.</p><img src="https://i.imgur.com/NgI1hRH.png"><h3 id="크기-바꾸기-lt-스프라이트-gt"><a href="#크기-바꾸기-lt-스프라이트-gt" class="headerlink" title="크기 바꾸기 &lt;스프라이트&gt;"></a>크기 바꾸기 &lt;스프라이트&gt;</h3><p>스프라이트의 크기를 변경합니다.</p><img src="https://i.imgur.com/Ry47fVi.png"><h3 id="색갈-바꾸기-lt-스프라이트-배경-gt"><a href="#색갈-바꾸기-lt-스프라이트-배경-gt" class="headerlink" title="색갈 바꾸기 &lt;스프라이트, 배경&gt;"></a>색갈 바꾸기 &lt;스프라이트, 배경&gt;</h3><p>스프라이트 혹은 배경의 색갈을 변경합니다.</p><img src="https://i.imgur.com/H63MFQo.png"><h3 id="보이기-숨기기-lt-스프라이트-gt"><a href="#보이기-숨기기-lt-스프라이트-gt" class="headerlink" title="보이기/숨기기 &lt;스프라이트&gt;"></a>보이기/숨기기 &lt;스프라이트&gt;</h3><p>스프라이트를 화면에서 숨기거나 보이게 하는 블록입니다.</p><p><strong>앱 실행도중 숨겨진 스프라이트는 다시 <code>보이기</code>를 수행하기 전까지는 화면에 표시되지 않습니다. 따라서, 앱을 시작할때, 필요한 스프라이트들에 <code>보이기</code> 블록을 꼭 추가해주어야 합니다.</strong></p><img src="https://i.imgur.com/FmLOZOP.png"><h3 id="표시순서-바꾸기-lt-스프라이트-gt"><a href="#표시순서-바꾸기-lt-스프라이트-gt" class="headerlink" title="표시순서 바꾸기 &lt;스프라이트&gt;"></a>표시순서 바꾸기 &lt;스프라이트&gt;</h3><p>스프라이트들이 무대에 여러개 배치된 경우, 표시순서에따라 뒤에 가려지는 스프라이트가 생길 수 있습니다. 이때에 표시순서를 변경하여 원하는 스프라이트가 화면에 표시되도록 변경할 수 있습니다.</p><img src="https://i.imgur.com/5eTFks3.png"><h2 id="소리"><a href="#소리" class="headerlink" title="소리"></a>소리</h2><p>소리 카테고리는 소리를 표시하거나 소리에 효과를 주는 블록들입니다.</p><img src="https://i.imgur.com/cPQvcFc.png"><p><code>pop 끝까지 재생하기</code> 와 <code>pop 재생하기</code> 의 차이점은 선택한 소리를 끝까지 재생하고 다음 블록을 실행하는지의 여부입니다. 아래의 동영상을 통해서 꼭 그 차이점을 익히기 바랍니다. </p><div class="video-container"><iframe src="//www.youtube.com/embed/MAGiqj76ZFY" frameborder="0" allowfullscreen></iframe></div><blockquote><p><code>재생하기</code> 의 경우, 첫번째 블록이 실행되고, 음악이 재생되기 시작하면서 바로 마지막 블록이 실행되어, 마치 세 블록이 동시에 실행되는것 처럼 보입니다.<br>반면 <code>끝까지 재생하기</code> 의 경우, 음악의 재생이 마찬 후에 세번째 블록이 실행됩니다.</p></blockquote><p>다음시간에는 이벤트, 제어 카테고리에 대해 배워봅시다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;인터페이스와 스트라이프에대해 공부를 마쳤으니, 이제 코딩에 대해서 배워보도록 하겠습니다.&lt;/p&gt;
&lt;p&gt;스트라이프에서는 기본적으로 8가지의 코드 카테고리와, 추가적으로 제공하는 별도의 카테로리를 제공합니다. 이번 시간에는 그중에서 &lt;code&gt;동작&lt;
      
    
    </summary>
    
      <category term="tech" scheme="https://donghopark.github.io/categories/tech/"/>
    
      <category term="scratch" scheme="https://donghopark.github.io/categories/tech/scratch/"/>
    
    
      <category term="scratch" scheme="https://donghopark.github.io/tags/scratch/"/>
    
  </entry>
  
  <entry>
    <title>[Scratch] Scratch 기본 익히기 #4 - 스프라이트와 배경</title>
    <link href="https://donghopark.github.io/2019/03/08/scratch-basic-4/"/>
    <id>https://donghopark.github.io/2019/03/08/scratch-basic-4/</id>
    <published>2019-03-07T21:44:33.000Z</published>
    <updated>2019-03-10T11:46:15.274Z</updated>
    
    <content type="html"><![CDATA[<p>지금까지 Scratch 의 기본적인 인터페이스를 알아보았습니다.</p><blockquote><p>처음 이 글을 접하신 분은 <a href="/2019/03/07/scratch-basic-1/" title="[Scratch] Scratch 기본 익히기 #1 - 회원가입 및 인터페이스">[Scratch] Scratch 기본 익히기 #1 - 회원가입 및 인터페이스</a> ,<a href="/2019/03/08/scratch-basic-2/" title="[Scratch] Scratch 기본 익히기 #2 - 작업영역">[Scratch] Scratch 기본 익히기 #2 - 작업영역</a> ,<a href="/2019/03/08/scratch-basic-3/" title="[Scratch] Scratch 기본 익히기 #3 - 무대영역">[Scratch] Scratch 기본 익히기 #3 - 무대영역</a> 를 먼저 보고오시는것을 추천합니다.</p></blockquote><p>이번 시간에는 스프라이트와 배경에 대해서 알아보겠습니다.</p><h2 id="스프라이트"><a href="#스프라이트" class="headerlink" title="스프라이트"></a>스프라이트</h2><p>스프라이트는 Scratch 앱에서 화면을 구성하는 모든 요소들을 말합니다. 주인공이 되는 캐릭터와 보조 캐릭터, 장애물을 포함하는 모든 요소를 포함합니다.</p><p>스프라이트 세개가 포함된 무대영역의 모습은 아래와 같습니다.</p><img src="https://i.imgur.com/DkAEBle.png"><h3 id="스프라이트의-추가"><a href="#스프라이트의-추가" class="headerlink" title="스프라이트의 추가"></a>스프라이트의 추가</h3><p>우측 하단의 <code>스프라이트 아이콘</code>을 선택하면 스프라이트를 추가할 수 있는 4가지 옵션이 나타납니다.</p><img src="https://i.imgur.com/yBusE8r.png"><ul><li>고르기 : Scratch 에서 제공하는 기본 스트라이프중에서 선택하여 추가할 수 있습니다.</li><li>서프라이즈 : Scratch 에서 제공하는 기본 스트라이프중에서 무작위로 선택하여 추가할 수 있습니다.</li><li>그리기 : 자신이 원하는 스프라이트를 찾을 수 없을경우, 직접 그림을 그려서 추가할 수 있습니다.</li><li>업로드하기 : 이미 사용하고자 하는 스트라이프가 있을 경우 업로드할 수 있습니다.</li></ul><h3 id="스프라이트의-삭제"><a href="#스프라이트의-삭제" class="headerlink" title="스프라이트의 삭제"></a>스프라이트의 삭제</h3><p>우측 하단의 스트라이프 목록중 삭제하고자 하는 스트라이프를 선택하고, 아이콘 우측 상단의 <code>x</code>버튼을 눌러서 스트라이프를 삭제할 수 있습니다.</p><img src="https://i.imgur.com/39RQHqz.png"><h3 id="스프라이트의-변경"><a href="#스프라이트의-변경" class="headerlink" title="스프라이트의 변경"></a>스프라이트의 변경</h3><a href="/2019/03/08/scratch-basic-2/" title="[Scratch] Scratch 기본 익히기 #2 - 작업영역">[Scratch] Scratch 기본 익히기 #2 - 작업영역</a> 에서 살펴본것처럼, 스프라이트의 모양을 추가하거나 변경할 수 있습니다.<br><br>## 배경<br><br>배경은 스프라이트와는 구분되는 개념으로 출력영역의 뒷배경을 표시합니다. <strong>배경도 코드 탭을 통해서 프로그래밍을 할 수 있지만, 스프라이트와 달리 <code>동작</code>블록이 존재하지 않습니다.</strong> 우측 하단의 배경을 선택하면, 코드 탭의 동작 카테고리에서 블럭들이 모두 사라지는것을 확인 할 수 있습니다. <strong>다른 카테고리의 블록들도 배경의 기능에 맞게 변경됩니다.</strong><br><br><img src="https://i.imgur.com/FuNMLFn.png"><h3 id="배경의-추가"><a href="#배경의-추가" class="headerlink" title="배경의 추가"></a>배경의 추가</h3><p>스프라이트와 마찬가지로 배경을 추가하는 옵션도 4가지가 있습니다.</p><img src="https://i.imgur.com/1jXOCFD.png"><p>새롭게 배경을 추가하고나면, 이렇게 배경이 변경됩니다.</p><img src="https://i.imgur.com/iGRYfds.png"><h3 id="배경의-삭제"><a href="#배경의-삭제" class="headerlink" title="배경의 삭제"></a>배경의 삭제</h3><p>스트라이프와 마찬가지로 배경을 선택하고, 아이콘 우측 상단의 <code>x</code>버튼을 눌러서 배경을 삭제할 수 있습니다.</p><img src="https://i.imgur.com/agPIc6F.png"><h3 id="배경의-변경"><a href="#배경의-변경" class="headerlink" title="배경의 변경"></a>배경의 변경</h3><p>스트라이프와 마찬가지로 배경역시 수정이 가능합니다.</p><p>다음 강의에서는 드디어 블록코딩을 시작해봅시다!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;지금까지 Scratch 의 기본적인 인터페이스를 알아보았습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;처음 이 글을 접하신 분은 &lt;a href=&quot;/2019/03/07/scratch-basic-1/&quot; title=&quot;[Scratch] Scratch 기본
      
    
    </summary>
    
      <category term="tech" scheme="https://donghopark.github.io/categories/tech/"/>
    
      <category term="scratch" scheme="https://donghopark.github.io/categories/tech/scratch/"/>
    
    
      <category term="scratch" scheme="https://donghopark.github.io/tags/scratch/"/>
    
  </entry>
  
  <entry>
    <title>[Scratch] Scratch 기본 익히기 #3 - 무대영역</title>
    <link href="https://donghopark.github.io/2019/03/08/scratch-basic-3/"/>
    <id>https://donghopark.github.io/2019/03/08/scratch-basic-3/</id>
    <published>2019-03-07T21:44:31.000Z</published>
    <updated>2019-03-10T11:46:15.274Z</updated>
    
    <content type="html"><![CDATA[<p>이제는 실제로 결과물이 표시되는 무대영역을 살펴봅시다.</p><img src="https://i.imgur.com/9vnw48n.png"><p>무대영역은 크게 출력영역, 정보영역으로 구분됩니다.</p><h2 id="출력영역"><a href="#출력영역" class="headerlink" title="출력영역"></a>출력영역</h2><img src="https://i.imgur.com/etYGVqg.png"><p>출력영역은 작업영역에서 설정한 내용들이 표시되는 곳입니다. 실제로 다른 사용자가 보게되는 모습이 바로 이 곳에 표시됩니다. </p><p>상단의 메뉴는 아래와 같습니다.</p><ul><li>녹색 깃발 : Scratch 를 실행합니다. 대부분은 코드는 녹색 깃발이 눌러지는것을 기점으로 시작됩니다.</li><li>정지 버튼 : Scratch 를 종료합니다. 앱의 실행을 멈추고자할때 사용됩니다.</li><li>터보 모드 : 앱의 실행을 가속하는 모드입니다. 많은 연산을 필요로 하는 앱에서 사용됩니다.</li><li>모드 변경 : 에디터의 모드를 변경하는 기능입니다. 기본모드, 개발모드, 최대화모드 의 세가지 옵션이 있습니다.<ul><li>기본모드 : 가장 기본적인 화면구성으로 무대영역이 비교적 크게 표시됩니다.</li><li>개발모드 : 코드의 양이 늘어날 경우, 작업영역을 키우고 무대영역을 줄여서 작업의 편의를 키우는 모드입니다.</li><li>최대화모드 : 개발을 마무리 하는 시점이나, 동작을 확인하고싶을때 사용하는 모드입니다.</li></ul></li></ul><p>&lt;기본모드&gt;<br><img src="https://i.imgur.com/lJp3Szv.png"></p><p>&lt;개발모드&gt;<br><img src="https://i.imgur.com/dKmpbhR.png"></p><p>&lt;최대화모드&gt;<br><img src="https://i.imgur.com/R3cBAft.png"></p><blockquote><p>자신의 성향에 맞게 기본모드 혹은 개발모드로 설정하고 개발을 진행하세요.</p></blockquote><h2 id="정보영역"><a href="#정보영역" class="headerlink" title="정보영역"></a>정보영역</h2><img src="https://i.imgur.com/tb2J1Tg.png"><p>스프라이트가 출력영역에 표시될때, 위치와 크기/방향을 설정합니다. 스프라이트가 표시될지의 여부를 결정하기도 합니다.</p><p>스프라이트가의 위치를 변경시키는 과정을 살펴보세요. <em>출력영역에서 스프라이트를 이동하면 정보영역의 값이 변경되고, 반대로 정보영역의 값을 변경하면 출력영역의 스프라이트가 이동합니다.</em></p><div class="video-container"><iframe src="//www.youtube.com/embed/BtDCMqfTU78" frameborder="0" allowfullscreen></iframe></div><p>다음으로는 <a href="/2019/03/08/scratch-basic-4/" title="[Scratch] Scratch 기본 익히기 #4 - 스프라이트와 배경">[Scratch] Scratch 기본 익히기 #4 - 스프라이트와 배경</a> 에 대해 알아보겠습니다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이제는 실제로 결과물이 표시되는 무대영역을 살펴봅시다.&lt;/p&gt;
&lt;img src=&quot;https://i.imgur.com/9vnw48n.png&quot;&gt;
&lt;p&gt;무대영역은 크게 출력영역, 정보영역으로 구분됩니다.&lt;/p&gt;
&lt;h2 id=&quot;출력영역&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="tech" scheme="https://donghopark.github.io/categories/tech/"/>
    
      <category term="scratch" scheme="https://donghopark.github.io/categories/tech/scratch/"/>
    
    
      <category term="scratch" scheme="https://donghopark.github.io/tags/scratch/"/>
    
  </entry>
  
  <entry>
    <title>[Scratch] Scratch 기본 익히기 #2 - 작업영역</title>
    <link href="https://donghopark.github.io/2019/03/08/scratch-basic-2/"/>
    <id>https://donghopark.github.io/2019/03/08/scratch-basic-2/</id>
    <published>2019-03-07T21:44:28.000Z</published>
    <updated>2019-03-10T11:46:15.273Z</updated>
    
    <content type="html"><![CDATA[<p>자, 이제 에디터 화면의 좌측에 위치한 <code>작업영역</code>을 살펴봅니다.</p><img src="https://i.imgur.com/36cvUzG.png"><p>작업영역은 크게 코드, 모양, 소리 그리고 개인 저장소로 구분됩니다. 각각의 탭을 누르면 해당 탭이 활성화되고, 해당 탭에서 사용가능한 기능들이 표시됩니다.</p><h2 id="코드-탭"><a href="#코드-탭" class="headerlink" title="코드 탭"></a>코드 탭</h2><img src="https://i.imgur.com/h0B9Vnt.png"><p>코드 탭은 Scratch 의 기능중 핵심적인 기능으로, 블록을 드레그해서 스프라이트의 동작을 지정하거나, 여러가지 상태의 변화를 코딩할 수 있습니다. 뿐만 아니라, 배경의 변화역시 이곳에서 코딩할 수 있습니다.</p><p>좌측의 다양한 카테고리를 클릭하면, 해당 카테고리의 블록들이 표시되고, 원하는 블록을 오른쪽의 블록 창에 드레그하면 코딩이 완료됩니다. 블록의 입력값을 변경하여 블록의 동작을 변경할 수 있습니다. 예를들어, <code>10만큼 움직이기</code> 블록을 변경하여 <code>20만큼 움직이기</code> 와 같은 변경된 블록을 생성할 수 있습니다.</p><p>대부분의 블록은 위/아래 방향으로 연결지점이 있어서 블록을 연결할 수 있습니다. 이렇게 연결된 블록은 위에서 아래로 연결 순서대로 수행됩니다.</p><blockquote><p>일부 블록의 경우 수행절차의 시작을 의미하기때문에 위로 연결된 연결지점이 없거나, 해당 블록으로 수행절차가 종료됨을 의미하기때문에 아래로 연결된 연결지점이 없는 경우가 있습니다.</p></blockquote><p><code>10만큼 움직이기</code> 블록과 <code>20만큼 움직이기</code> 블록을 연결하여 실행하는 과정을 살펴보세요.</p><div class="video-container"><iframe src="//www.youtube.com/embed/NjPnl2Umf4M" frameborder="0" allowfullscreen></iframe></div><h2 id="모양-탭"><a href="#모양-탭" class="headerlink" title="모양 탭"></a>모양 탭</h2><img src="https://i.imgur.com/pAQ8eJK.png"><p>모양 탭은 스프라이트의 이미지를 변경하거나 수정할 수 있습니다.</p><p>각각의 스프라이트는 여러개의 모양을 가질 수 있고, 추가/삭제가 자유롭습니다. 하지만, 최소 1개 이상의 모양이 등록되어 있어야 합니다.</p><p>Scratch 에서 제공해주는 기본 모양뿐 아니라, 인터넷에서 다운받은 이미지를 사용할 수도 있습니다. 즉시 사진을 찍어서 모양으로 사용할 수도 있으며 그림을 그려서 만들어낼 수도 있습니다.</p><p>스트라이프에서 모양을 삭제하고 추가하는 과정을 살펴보세요.</p><div class="video-container"><iframe src="//www.youtube.com/embed/wYEfsgd8ibo" frameborder="0" allowfullscreen></iframe></div><p>모양 1을 일부 색갈을 변경하는 과정을 살펴보세요.</p><div class="video-container"><iframe src="//www.youtube.com/embed/5knwIz4RDbc" frameborder="0" allowfullscreen></iframe></div><blockquote><p>더 자세한 모양의 변경방법은 <a href="/2019/03/08/scratch-basic-4/" title="[Scratch] Scratch 기본 익히기 #4 - 스프라이트와 배경">[Scratch] Scratch 기본 익히기 #4 - 스프라이트와 배경</a> 를 참고하세요.</p></blockquote><h2 id="소리-탭"><a href="#소리-탭" class="headerlink" title="소리 탭"></a>소리 탭</h2><img src="https://i.imgur.com/GLAHmPx.png"><p>소리 탭은 Scratch 에 사용될 노래, 음악, 음원을 수정하고 편집할 수 있습니다.</p><p>Scratch 에서 제공하는 기본 소리뿐 아니라, 인터넷에서 다운받은 소리를 사용하거나, 녹음을 해서 사용할 수도 있습니다.</p><p>소리를 추가하고 변경하는 과정을 살펴보세요.</p><div class="video-container"><iframe src="//www.youtube.com/embed/746aS4s06Hg" frameborder="0" allowfullscreen></iframe></div><h2 id="개인-저장소"><a href="#개인-저장소" class="headerlink" title="개인 저장소"></a>개인 저장소</h2><img src="https://i.imgur.com/2FQrcUz.png"><p>작업영역의 가장 하단에 위치하는 개인 저장소는 여러 블록을 저장해둘 수 있는 공간입니다.</p><p>다음으로는 <a href="/2019/03/08/scratch-basic-3/" title="[Scratch] Scratch 기본 익히기 #3 - 무대영역">[Scratch] Scratch 기본 익히기 #3 - 무대영역</a> 에 대해 알아보겠습니다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;자, 이제 에디터 화면의 좌측에 위치한 &lt;code&gt;작업영역&lt;/code&gt;을 살펴봅니다.&lt;/p&gt;
&lt;img src=&quot;https://i.imgur.com/36cvUzG.png&quot;&gt;
&lt;p&gt;작업영역은 크게 코드, 모양, 소리 그리고 개인 저장소로 구분됩니다.
      
    
    </summary>
    
      <category term="tech" scheme="https://donghopark.github.io/categories/tech/"/>
    
      <category term="scratch" scheme="https://donghopark.github.io/categories/tech/scratch/"/>
    
    
      <category term="scratch" scheme="https://donghopark.github.io/tags/scratch/"/>
    
  </entry>
  
  <entry>
    <title>[Scratch] Scratch 기본 익히기 #1 - 회원가입 및 인터페이스</title>
    <link href="https://donghopark.github.io/2019/03/07/scratch-basic-1/"/>
    <id>https://donghopark.github.io/2019/03/07/scratch-basic-1/</id>
    <published>2019-03-07T00:14:25.000Z</published>
    <updated>2019-03-10T11:46:15.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="회원가입"><a href="#회원가입" class="headerlink" title="회원가입"></a>회원가입</h2><p>Scratch 를 이용하기 위해서는 우선 회원가입을 해야 합니다. <strong>Scratch 는 무료입니다.</strong></p><blockquote><p>Scratch 는 대부분 온라인 상에서 이루어지지만, 부득이한 경우에는 인터넷이 연결되지 않아도 실행가능한 <a href="https://scratch.mit.edu/download" target="_blank" rel="noopener">Scratch Desktop</a> 을 다운받아 사용할 수 있습니다. 본 강좌에서는 온라인을 위주로 진행합니다.</p></blockquote><ol><li><a href="https://scratch.mit.edu/" target="_blank" rel="noopener">Scratch 홈페이지</a>를 방문합니다.</li></ol><blockquote><p>인터넷 브라우저 주소창에 <code>https://scratch.mit.edu/</code> 를 입력하거나, <a href="https://scratch.mit.edu/" target="_blank" rel="noopener">링크</a> 를 클릭합니다.</p></blockquote><iframe src="https://scratch.mit.edu/" width="100%" height="300" frameborder="0" allowfullscreen></iframe><ol><li>우측 상단의 <code>회원가입</code> 을 클릭하고 회원가입을 진행합니다.</li></ol><blockquote><p>이미 회원가입을 했다면 <code>로그인</code> 을 클릭하여 로그인합니다.</p></blockquote><ul><li>아이디/비밀번호 입력</li><li>생년월일/성별 입력</li><li>이메일 주소(본인 혹은 보호자) 입력</li><li>이메일 확인</li></ul><p>모든 절차를 마무리 하면, Scratch 의 사용자 화면으로 전환됩니다.</p><h2 id="홈페이지-메뉴"><a href="#홈페이지-메뉴" class="headerlink" title="홈페이지 메뉴"></a>홈페이지 메뉴</h2><p>Scratch 의 사용자 화면입니다.</p><img src="https://i.imgur.com/GiIKwCB.png" title="Scratch 홈페이지 상당"><p>상단에 Scratch 의 기본 메뉴들이 있습니다.</p><ul><li>만들기 : Scratch 에디터로 연결됩니다. 창작 작업이 이루어지는 곳입니다.</li><li>탐험하기 : 전 세계의 다양한 사용자가 등록한 프로젝트들을 열람할 수 있습니다.</li><li>아이디어 : Scratch 의 다양한 튜토리얼들이 있는 곳입니다.</li><li>소개 : Scratch 소개페이지로 연결됩니다.</li><li>검색창 : 검색을 통해서 원하는 프로젝트를 바로 찾아볼 수 있습니다.</li><li>메시지 : 친구화 협업을 하거나, 내 포르젝트에 덧글이 달렸을때 알려줍니다.</li><li>내작업실 : 내 프로젝트들을 관리하는 곳입니다.</li><li>개인설정 : 계정의 설정을 바꾸거나 로그아웃 할 수 있습니다.</li></ul><p>그 아래로, 다양한 카테고리로 정렬된 프로젝트들을 볼 수 있습니다. 최근 가장 인기있는 프로젝트가 어떤 것인지, 어떤 프로젝트가 가장 많이 참조되는지등의 트렌드를 볼 수 있습니다.</p><p>이제 <code>만들기</code> 를 선택하고 에디터로 들어가봅시다.</p><blockquote><p><code>만들기</code> 로 들어가기에 앞서, <code>탐험하기</code> 에서 다양한 프로젝트들을 둘러보는것도 좋습니다.</p></blockquote><h2 id="에디터-메뉴"><a href="#에디터-메뉴" class="headerlink" title="에디터 메뉴"></a>에디터 메뉴</h2><p>에디터 화면입니다.</p><img src="https://i.imgur.com/lJp3Szv.png" title="Scratch 에디터 화면"><p>상단의 메뉴는 아래와 같습니다.</p><ul><li>언어설정(지구 아이콘) : 다양한 언어로 변경이 가능합니다.</li><li>파일 : 파일을 새로 만들거나, 저장 혹은 불러오는 기능입니다.</li><li>편집 : 직전의 편집을 취소하거나 터보모드를 켜고 끌 수 있습니다.</li><li>튜토리얼 : 다양한 튜토리얼들을 볼 수 있습니다.</li><li>프로젝트 이름 : 프로젝트의 이름을 변경할 수 있습니다.</li><li>공유 : 프로젝트를 전 세계의 다양한 사용자와 공유하세요.</li><li>프로젝트 페이지 보기 : 내 프로젝트가 다른 사용자에게 어떻게 보여지는지 확인할 수 있습니다.</li></ul><p>화면의 하단은 실제로 코딩이 이루어지는 <code>작업영역</code>과 결과물이 보여지는 <code>무대영역</code>으로 구분되어 있습니다. </p><p>다음으로는 <a href="/2019/03/08/scratch-basic-2/" title="[Scratch] Scratch 기본 익히기 #2 - 작업영역">[Scratch] Scratch 기본 익히기 #2 - 작업영역</a> 에 대해 알아보겠습니다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;회원가입&quot;&gt;&lt;a href=&quot;#회원가입&quot; class=&quot;headerlink&quot; title=&quot;회원가입&quot;&gt;&lt;/a&gt;회원가입&lt;/h2&gt;&lt;p&gt;Scratch 를 이용하기 위해서는 우선 회원가입을 해야 합니다. &lt;strong&gt;Scratch 는 무료입니다.&lt;
      
    
    </summary>
    
      <category term="tech" scheme="https://donghopark.github.io/categories/tech/"/>
    
      <category term="scratch" scheme="https://donghopark.github.io/categories/tech/scratch/"/>
    
    
      <category term="scratch" scheme="https://donghopark.github.io/tags/scratch/"/>
    
  </entry>
  
  <entry>
    <title>[Scratch] Scratch 기본 익히기에 들어가기 앞서</title>
    <link href="https://donghopark.github.io/2019/03/07/scratch-basic-0/"/>
    <id>https://donghopark.github.io/2019/03/07/scratch-basic-0/</id>
    <published>2019-03-07T00:14:18.000Z</published>
    <updated>2019-03-10T11:46:15.272Z</updated>
    
    <content type="html"><![CDATA[<p><em>이 글은 Scratch 를 사용하는 사용자가 아닌, 부모님들을 위한 글입니다.</em><br><em>만약 학생들이 이 글을 보고 있다면 부모님께 이 글을 보여드리고 다음글 (<a href="/2019/03/07/scratch-basic-1/" title="[Scratch] Scratch 기본 익히기 #1 - 회원가입 및 인터페이스">[Scratch] Scratch 기본 익히기 #1 - 회원가입 및 인터페이스</a>)로 넘어가주세요.</em></p><h2 id="Engineering"><a href="#Engineering" class="headerlink" title="Engineering"></a>Engineering</h2><p>코딩교육이 전 세계적으로 열풍이다. 시작은 뭔가 <code>직업훈련</code>적인 느낌을 띄었다면, 최근의 추세는 <code>논리적 사고 배양</code> 라던가 <code>문제해결능력 배양</code> 의 의미를 띄고 있는것처럼 보인다. 좀더 큰 의미로 보자면, <code>Engineering</code> 의 의미가 더 중요하게 두각되고 있다고 볼 수 있겠다.</p><p><code>Engineering</code> 이란 수학, 과학등의 지식을 바탕으로 현실의 문제를 해결(혹은 개선)하는 학문이라고 정의할 수 있다.</p><blockquote><p>Engineering is the application of knowledge in the form of science, mathematics, and empirical evidence, to the innovation, design, construction, operation and maintenance of structures, machines, materials, devices, systems, processes, and organizations.  <a href="https://en.wikipedia.org/wiki/Engineering" target="_blank" rel="noopener">Wikipedia</a></p></blockquote><p>어린이들이 <code>Engineering</code> 을 한다고 하면, 뭔가 어색하게 생각하는 느껴지는 분들이 있을 수도 있지만, 문제점을 인식하고, 해결 방법을 기안하고, 친구와 협업하는 일련의 과정이 <code>Engineering</code> 이라고 한다면, 이를 통해서 아이들은 아래와 같은 가치를 얻게 된다.</p><ul><li>창의적 사고</li><li>체계적인 추론</li><li>협동작업</li></ul><h2 id="Scratch"><a href="#Scratch" class="headerlink" title="Scratch"></a><a href="https://scratch.mit.edu/" target="_blank" rel="noopener">Scratch</a></h2><p><a href="https://scratch.mit.edu/" target="_blank" rel="noopener">Scratch</a> 는 2009년 <a href="https://www.media.mit.edu/" target="_blank" rel="noopener">MIT Media Lab</a> 의 학생들이 처음 만들어 발표한 이후, 2019년 전 세계에서 70개가 넘는 언어로 번역되어 사용되고 있는 블록코딩 프로그래밍 언어입니다.</p><p>블록코딩 프로그래밍 언어란 레고 블록을 조립하는 것처럼 프로그래밍을 할 수 있도록 고안된 프로그래밍 언어이다. 블록을 Drag&amp;Drop 하는 단순한 방식을 통해서 프로그래밍을 할 수 있어서 어린 학생들도 쉽게 프로그래밍을 할 수 있다. </p><p>추가 설명에 앞서, Scratch 의 소개영상을 보자.</p><div class="video-container"><iframe src="//www.youtube.com/embed/-SjuiawRMU4" frameborder="0" allowfullscreen></iframe></div><p>주 대상은 만8세 ~ 만16세이며 (그보다 어린 아이들(만 5세 ~만7세) 을 위한 <a href="https://www.scratchjr.org/" target="_blank" rel="noopener">Scratch Junior</a> 가 발표되었다.) <a href="https://scratch.mit.edu/statistics/" target="_blank" rel="noopener">통계적</a>으로 만 12세의 학생들이 가장 많이 사용하는것으로 나타났다.</p><p>Scratch 를 이용하여 할 수 있는 작업의 예시는 아래와 같다.</p><ul><li>애니메이션</li><li>게임</li><li>증강현실 어플리케이션</li><li>인터렉티브 어플리케이션</li></ul><h2 id="CS-First-by-Google"><a href="#CS-First-by-Google" class="headerlink" title="CS-First by Google"></a><a href="https://csfirst.withgoogle.com/s/en/home" target="_blank" rel="noopener">CS-First</a> by Google</h2><p>21세기에 가장 필요한 기술로 컴퓨터 과학(Computor Science)을 꼽는 사람들이 많습니다. 이런 흐름에 맞게 Google 에서도 <a href="https://csfirst.withgoogle.com/s/en/home" target="_blank" rel="noopener"><code>CS First</code></a> 라는 코스를 공개하였습니다. </p><p><code>Engineering</code> 이 문제를 해결하는 광범위한 개념이라면, 이를 <code>Computer</code> 로 한정한 것이 <code>CS(Computer Science)</code> 라고 할 수 있습니다. </p><p>CS First 에는 다양한 과제들이 제공되는데, 이에 사용되는 Programming 언어가 바로 Scratch 입니다. Scratch 의 범용성과 편리성을 Google 에서도 인정한 사례라고 볼 수 있습니다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;이 글은 Scratch 를 사용하는 사용자가 아닌, 부모님들을 위한 글입니다.&lt;/em&gt;&lt;br&gt;&lt;em&gt;만약 학생들이 이 글을 보고 있다면 부모님께 이 글을 보여드리고 다음글 (&lt;a href=&quot;/2019/03/07/scratch-basic-1
      
    
    </summary>
    
      <category term="tech" scheme="https://donghopark.github.io/categories/tech/"/>
    
      <category term="scratch" scheme="https://donghopark.github.io/categories/tech/scratch/"/>
    
    
      <category term="scratch" scheme="https://donghopark.github.io/tags/scratch/"/>
    
  </entry>
  
  <entry>
    <title>[삽질포함] Docker 따라하기 #4</title>
    <link href="https://donghopark.github.io/2019/03/02/docker-4/"/>
    <id>https://donghopark.github.io/2019/03/02/docker-4/</id>
    <published>2019-03-02T08:50:32.000Z</published>
    <updated>2019-03-10T11:46:15.271Z</updated>
    
    <content type="html"><![CDATA[<p>지금까지는 Docker 로 하나의 Container 를 돌리는 실습을 해 보았습니다.<br>이번에는 Docker Compese 라는 툴을 이용하여, 두개 이상의 Container 를 구동하여 서비스를 만드는 연습을 해 보겠습니다.</p><h2 id="최종-목표"><a href="#최종-목표" class="headerlink" title="최종 목표"></a>최종 목표</h2><p>Mysql Container 와 Node.js Container 를 각각 구동하고, Node.js 에서 Mysql Database 를 접근하는 서비스를 만들어봅니다.</p><p>간단하게 구조화하면 아래와 같습니다.</p><p><code>Browser (Host) -&gt; Node.js (Container #1) -&gt; Mysql(Container #2)</code></p><h2 id="Node-js-Image-만들기"><a href="#Node-js-Image-만들기" class="headerlink" title="Node.js Image 만들기"></a>Node.js Image 만들기</h2><a href="/2019/02/28/docker-3/" title="Docker 따라하기 #3">Docker 따라하기 #3</a> 에서는 단순하게 String 을 결과값으로 반환했으나, 이제는 MySql Database 에서 값을 로드하도록 변경해야 합니다.<br><br><figure class="highlight javascript"><figcaption><span>Server.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> connection = mysql.createConnection(&#123;</span><br><span class="line">  host: <span class="string">'0.0.0.0'</span>,</span><br><span class="line">  user: <span class="string">'root'</span>,</span><br><span class="line">  post: <span class="number">3306</span>,</span><br><span class="line">  password: <span class="string">'password'</span>,</span><br><span class="line">  database: <span class="string">'engineer'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  connection.connect();  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> sql = <span class="string">'show tables'</span>;</span><br><span class="line"></span><br><span class="line">  connection.query(sql, (err, rows) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      res.send(<span class="string">'Opps. Error happened\n'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.send(<span class="string">'Hello Engineers\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="string">'0.0.0.0'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Node Web App is Running on http://0.0.0.0:8080`</span>);</span><br></pre></td></tr></table></figure><p>Node.js 에서 MySql 을 사용할 수 있도록 package 에 mysql 을 dependency 를 추가하고, 이미지를 새로 만들어줍니다.</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install mysql --save</span><br></pre></td></tr></table></figure><p>결과적으로 package.json 은 아래와 같이 변경됩니다.</p><figure class="highlight json"><figcaption><span>package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"node_web_app"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"Node.js on Docker"</span>,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"server.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"node server.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"express"</span>: <span class="string">"^4.16.3"</span>,</span><br><span class="line">    <span class="attr">"mysql"</span>: <span class="string">"^2.16.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Docker-Compose-설정하기"><a href="#Docker-Compose-설정하기" class="headerlink" title="Docker Compose 설정하기"></a>Docker Compose 설정하기</h2><p>Docker Composer 는 하나 이상의 Docker Container 를 구동할 수 있게 도와주는 툴입니다. 이 어플리케이션처럼 두개 이상의 Container 를 구동할때, 각각을 구동하지 않고, Docker Composer 를 통해 한번에 구동할 수 있게 도와줍니다.</p><p>docker-compse.yml 은 node 와 mysql 이라는 두개의 container 를 어떻게 빌드하고 구동할지를 정의한 파일이라고 생각하시면 되겠네요.</p><figure class="highlight yml"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  node:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">"8080:8080"</span>    </span><br><span class="line"><span class="attr">    expose:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8080"</span>   </span><br><span class="line"><span class="attr">    links:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">mysql</span>    </span><br><span class="line"><span class="attr">  mysql:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">"mysql/mysql-server"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"3306:3306"</span>    </span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      MYSQL_ROOT_PASSWORD:</span> <span class="string">password</span></span><br><span class="line"><span class="attr">      MYSQL_DATABASE:</span> <span class="string">engineer</span></span><br><span class="line"><span class="attr">      MYSQL_USER:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">      MYSQL_PASSWORD:</span> <span class="string">password</span>    </span><br><span class="line"><span class="attr">    expose:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"3306"</span></span><br></pre></td></tr></table></figure><p>위와 같이 설정파일을 생성하고, 아래의 커맨드를 실행하면, 두개의 컨테이너가 동시에 구동됩니다.</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker-compose up</span><br><span class="line"><span class="meta">$</span> docker ps </span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                  CREATED             STATUS                            PORTS                               NAMES</span><br><span class="line">dfdeaeeac0e1        compose_node             "npm start"              6 minutes ago       Up 4 seconds                      0.0.0.0:8080-&gt;8080/tcp              compose_node_1</span><br><span class="line">45248769f312        mysql/mysql-server:5.7   "/entrypoint.sh mysq…"   6 minutes ago       Up 5 seconds (health: starting)   0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   compose_mysql_1</span><br></pre></td></tr></table></figure><h3 id="문제점-1"><a href="#문제점-1" class="headerlink" title="문제점 #1"></a>문제점 #1</h3><p>두개의 container 가 정상적으로 구동되긴 한데, node 에서 mysql 에 접속을 하지 못하는 현상이 발견됨.</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: connect ECONNREFUSED 0.0.0.0:3306</span><br></pre></td></tr></table></figure><h4 id="접근방법-1"><a href="#접근방법-1" class="headerlink" title="접근방법 #1"></a>접근방법 #1</h4><p>node 에서 mysql 을 접근할때, localhost 로 접근을 하는데, node 의 3306 포트가 mysql 의 3306 포트로 연결이 되지 않았으므로, localhost 로 접근을 하지 말고, mysql 의 ip 로 접근을 해야 한다.</p><blockquote><p><a href="http://blog.naver.com/alice_k106/220278762795" target="_blank" rel="noopener">alice_k106 님의 블로그</a> 를 참고하여 Host 와 Container 의 포트 연결에 대해 좀더 알아보자.</p></blockquote><p>container 의 ip 를 알려면, docker inspect 명령을 사용하면 된다.</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker inspect &lt;container_id&gt;</span><br></pre></td></tr></table></figure><p>Mysql 의 ip 로 접속하도록 Server.js 를 수정</p><figure class="highlight javascript"><figcaption><span>Server.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> connection = mysql.createConnection(&#123;</span><br><span class="line">  host: <span class="string">'172.19.0.2'</span>, <span class="comment">// 획득한 IP 로 수정</span></span><br><span class="line">  user: <span class="string">'root'</span>,</span><br><span class="line">  post: <span class="number">3306</span>,</span><br><span class="line">  password: <span class="string">'password'</span>,</span><br><span class="line">  database: <span class="string">'engineer'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="문제점-2"><a href="#문제점-2" class="headerlink" title="문제점 #2"></a>문제점 #2</h3><p>서버에서 에러를 리턴함.</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: ER_HOST_NOT_PRIVILEGED: Host '172.19.0.3' is not allowed to connect to this MySQL server</span><br></pre></td></tr></table></figure><h3 id="접근방법-1-1"><a href="#접근방법-1-1" class="headerlink" title="접근방법 #1"></a>접근방법 #1</h3><p>Mysql 의 root 사용자가 로컬에서 접근을 허용하도록 설정되어있는 문제이므로, 신규 사용자를 추가하고, node 에서의 접근을 허용하도록 함.</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker exec -it &lt;mysql_container_id&gt; bash</span><br><span class="line"><span class="meta">$</span> mysql -u root -p</span><br><span class="line"><span class="meta">$</span> CREATE USER 'engineer'@'172.19.0.3' IDENTIFIED BY 'password';</span><br><span class="line"><span class="meta">$</span> GRANT ALL ON *.* TO 'engineer'@'172.19.0.3';</span><br></pre></td></tr></table></figure><p>위와 같이 `engineer’ 라는 사용자를 추가하고, 접근을 허용해준다. node 의 mysql 접근코드도 함께 변경한다.</p><figure class="highlight javascript"><figcaption><span>Server.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> connection = mysql.createConnection(&#123;</span><br><span class="line">  host: <span class="string">'172.19.0.2'</span>,</span><br><span class="line">  user: <span class="string">'engineer'</span>, <span class="comment">// 사용자 변경</span></span><br><span class="line">  post: <span class="number">3306</span>,</span><br><span class="line">  password: <span class="string">'password'</span>,</span><br><span class="line">  database: <span class="string">'engineer'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="문제점-3"><a href="#문제점-3" class="headerlink" title="문제점 #3"></a>문제점 #3</h3><p>서버에 로그인을 할 수 없는 문제가 발생.</p><p>Error: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client</p><h3 id="접근방법-1-2"><a href="#접근방법-1-2" class="headerlink" title="접근방법 #1"></a>접근방법 #1</h3><p>Mysql 8 에서부터 사용자 인증방식이 변경되었다고 한다. docker-compose.yml 에서 버전을 지정해 주지 않아서, 최신버전인 8 을 사용하고 있었음. node 의 mysql 모듈이 아직 이를 지원하지 않으므로, mysql 버전을 5.7 로 변경하여 다시 시도함.</p><figure class="highlight yml"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mysql:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">"mysql/mysql-server:5.7"</span></span><br></pre></td></tr></table></figure><p>정상적으로 동작확인</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -i localhost:8080</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">X-Powered-By: Express</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 16</span><br><span class="line">ETag: W/"10-JhXyAELZ+v4AaWuE4SR9QoGav+4"</span><br><span class="line">Date: Sat, 02 Mar 2019 08:42:49 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">Hello Engineers</span><br></pre></td></tr></table></figure><p>일단 여기까지가 Docker 를 이용한 기본적인 사용방법을 익히는 <code>따라하기</code>가 될것 같습니다.<br>다음부터는 Docker 의 <code>꽃</code>. <code>Orchestration</code> 을 한번 익혀볼까 합니다.  (언제가 될지는 모르지만…쿨럭..)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;지금까지는 Docker 로 하나의 Container 를 돌리는 실습을 해 보았습니다.&lt;br&gt;이번에는 Docker Compese 라는 툴을 이용하여, 두개 이상의 Container 를 구동하여 서비스를 만드는 연습을 해 보겠습니다.&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
      <category term="tech" scheme="https://donghopark.github.io/categories/tech/"/>
    
      <category term="docker" scheme="https://donghopark.github.io/categories/tech/docker/"/>
    
    
      <category term="docker" scheme="https://donghopark.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 빌드에러 : The page build failed for the `master` branch with the following error</title>
    <link href="https://donghopark.github.io/2019/02/28/build-failed-jekyll/"/>
    <id>https://donghopark.github.io/2019/02/28/build-failed-jekyll/</id>
    <published>2019-02-28T09:18:06.000Z</published>
    <updated>2019-03-10T11:46:15.269Z</updated>
    
    <content type="html"><![CDATA[<p>열심히 블로깅을 하는 도중, 갑자기 Github 로부터 이런 메일이 도착하였다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Title: [donghopark/donghopark.github.io] Page build failure</span><br><span class="line"></span><br><span class="line">The page build failed for the `master` branch with the following error:</span><br><span class="line"></span><br><span class="line">Unable to build page. Please try again later.</span><br><span class="line"></span><br><span class="line">For information on troubleshooting Jekyll see:</span><br><span class="line"></span><br><span class="line"> https://help.github.com/articles/troubleshooting-jekyll-builds</span><br><span class="line"></span><br><span class="line">If you have any questions you can contact us by replying to this email.</span><br></pre></td></tr></table></figure><p>그리고, 그 이후부터 페이지의 업데이트가 이루어지지 않고, 변경사항을 Push 할때마다 동일한 메일이 반복해서 날아오는 상황이 계속되었다.</p><p>CI 를 설정하지도 않은 상태인데다가,<br>정적 페이지인 Repo 에서 갑자기 Build Error 라니???<br>게다가 사용하지도 않는 Jekyll build error 라니??</p><p><a href="https://help.github.com/en/articles/troubleshooting-github-pages-builds" target="_blank" rel="noopener">information on troubleshooting Jekyll</a> 에는 Jekyll 의 빌드과정에서 생기는 에러들만 나열되어 있으니, 나에게 해당되는 내용은 아니고, 아무리 Github Repo 를 살펴봐도 어떠한 힌트도 찾을 수가 없었다.</p><p>열심히 구글링을 하다가 다행히 <a href="https://github.community/t5/GitHub-Pages/Github-Pages-build-failed-although-it-passed-a-few-months-ago/td-p/2128" target="_blank" rel="noopener">관련 Thread</a> 를 발견!</p><p><strong>해결책은 <code>.nojekyll</code> 을 새로 생성해야 한다는것!</strong></p><p>곧바로, 정적 페이지 Repo 에서 <code>Create new file</code> 버튼을 눌러서 빈 <code>.nojekyll</code> 파일을 생성하자, 모든것이 정상으로 돌아왔다.</p><p>이렇게 또 한가지 배워갑니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;열심히 블로깅을 하는 도중, 갑자기 Github 로부터 이런 메일이 도착하였다.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
      <category term="tech" scheme="https://donghopark.github.io/categories/tech/"/>
    
      <category term="hexo" scheme="https://donghopark.github.io/categories/tech/hexo/"/>
    
    
      <category term="hexo" scheme="https://donghopark.github.io/tags/hexo/"/>
    
      <category term="build" scheme="https://donghopark.github.io/tags/build/"/>
    
      <category term="error" scheme="https://donghopark.github.io/tags/error/"/>
    
      <category term="jekyll" scheme="https://donghopark.github.io/tags/jekyll/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 에 Busuanzi 카운터 연동하기</title>
    <link href="https://donghopark.github.io/2019/02/28/counter/"/>
    <id>https://donghopark.github.io/2019/02/28/counter/</id>
    <published>2019-02-28T08:38:37.000Z</published>
    <updated>2019-03-10T11:46:15.269Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 는 정적 블로그를 위한 플랫폼입니다. 즉, 사용자가 방문할때마다 증가하는 카운터를 다는것은 Hexo 만의 기능으로는 불가능합니다.</p><p>하지만, 몇가지 플러그인의 도움을 받으면, Hexo 에 카운터를 다는것도 가능합니다.</p><h2 id="사용할-툴"><a href="#사용할-툴" class="headerlink" title="사용할 툴"></a>사용할 툴</h2><p>이번에 사용할 툴은 Busuanzi Counter 라는 툴입니다. 중국의 한 개발자가 사용하기 쉬운 툴을 만들어서 배포하고 있습니다.</p><p><a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">개발자 페이지</a> (모두 중국어로 되어 있어서 구글 번역기를 통해서만 대략의 내용을 확인할 수 있습니다.)</p><h2 id="구동방식"><a href="#구동방식" class="headerlink" title="구동방식"></a>구동방식</h2><ol><li>간단하게 스크립트를 로드하면</li><li>스크립트안에서 개발자의 서버로 사용자 정보를 전송하고</li><li>카운터 정보를 얻어와서</li><li>화면에 표시합니다.</li></ol><p>이때에 카운팅을 하는방법으로 두가지 메소드를 제공합니다.</p><ul><li>페이지 뷰 카운트<br>한 사용자가 여러번 접근했을 때, 이를 다중 접속으로 카운트 하는 방식</li><li>사용자 카운트<br>한 사용자가 여러번 접근했을 때, 이를 한번의 접속으로 카운트 하는 방식</li></ul><p>페이지 뷰를 카운트 할 것인지, 접속한 사용자의 수를 카운트 할 것인지는 필요에 따라 정의해서 사용하면 됩니다.</p><h2 id="사용방법"><a href="#사용방법" class="headerlink" title="사용방법"></a>사용방법</h2><h3 id="스크립트-추가"><a href="#스크립트-추가" class="headerlink" title="스크립트 추가"></a>스크립트 추가</h3><p>모든 페이지의 가장 하단에 표시되는 footer template 의 가장 하단에 해당 구문을 추가합니다.</p><figure class="highlight plain"><figcaption><span>footer.swig(|footer.ejs)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.busuanzi.enabled %&#125;</span><br><span class="line">&lt;script async src = &quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script &gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h3 id="표시영역-정의"><a href="#표시영역-정의" class="headerlink" title="표시영역 정의"></a>표시영역 정의</h3><p>카운터를 표시하고자 하는 영역에 아래의 구문을 추가합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.busuanzi.enabled %&#125;</span><br><span class="line">&lt;span id=&quot;busuanzi_container_site_&#123;&#123; theme.busuanzi.method &#125;&#125;&quot;&gt;</span><br><span class="line">    Total &lt;span id=&quot;busuanzi_value_site_&#123;&#123; theme.busuanzi.method &#125;&#125;&quot;&gt;&lt;/span&gt; views</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h3 id="카운터-설정"><a href="#카운터-설정" class="headerlink" title="카운터 설정"></a>카운터 설정</h3><p>사용하는 테마의 설정파일에 Busanzi Counter 설정값을 정의합니다. 카운트 방식에 따라 pv(페이지 뷰), uv(사용자) 를 설정해주시면 됩니다.</p><figure class="highlight yml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Busuanzi Counter</span></span><br><span class="line"><span class="attr">busuanzi:</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  method:</span> <span class="string">pv</span></span><br><span class="line">  <span class="comment"># method: uv</span></span><br></pre></td></tr></table></figure><p>저같은 경우는 카운터를 가장 하단에 표시하고 있습니다.</p><p>Hexo 생활에 도움이 되시길 바랍니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hexo 는 정적 블로그를 위한 플랫폼입니다. 즉, 사용자가 방문할때마다 증가하는 카운터를 다는것은 Hexo 만의 기능으로는 불가능합니다.&lt;/p&gt;
&lt;p&gt;하지만, 몇가지 플러그인의 도움을 받으면, Hexo 에 카운터를 다는것도 가능합니다.&lt;/p&gt;

      
    
    </summary>
    
      <category term="tech" scheme="https://donghopark.github.io/categories/tech/"/>
    
      <category term="hexo" scheme="https://donghopark.github.io/categories/tech/hexo/"/>
    
    
      <category term="hexo" scheme="https://donghopark.github.io/tags/hexo/"/>
    
      <category term="counter" scheme="https://donghopark.github.io/tags/counter/"/>
    
  </entry>
  
  <entry>
    <title>Docker 따라하기 #3</title>
    <link href="https://donghopark.github.io/2019/02/28/docker-3/"/>
    <id>https://donghopark.github.io/2019/02/28/docker-3/</id>
    <published>2019-02-28T03:24:38.000Z</published>
    <updated>2019-03-10T11:46:15.270Z</updated>
    
    <content type="html"><![CDATA[<p>지금까지 Docker 기본도 익혔고, 실제 Dockerfile 도 만져봤으니 이번에는 Nginx 가 아닌, Node.js 서버를 이용한 간단한 웹앱을 만들어보겠습니다. <em>웹앱이라고 해봐야, 역시 Hello World 수준이지만, 이글은 Node.js 나 Express 에 대한 글이 아니므로, 이정도면 충분하다고 생각합니다.</em></p><h2 id="개발환경-만들기"><a href="#개발환경-만들기" class="headerlink" title="개발환경 만들기"></a>개발환경 만들기</h2><p>Docker 를 이용하는 장점은 바로 작업환경을 만들기 편하다는 점이죠. 즉, 어떤 호스트를 사용중이건 Docker 만 정상적으로 설치되어있다면 바로 개발환경이 완료된 상태로 보면 됩니다.</p><p>Docker 설치는 이전글( <a href="/2019/02/27/docker-1/" title="Docker 따라하기 #1">Docker 따라하기 #1</a> )을 참고하세요.</p><h2 id="Node-js-웹앱-만들기"><a href="#Node-js-웹앱-만들기" class="headerlink" title="Node.js 웹앱 만들기"></a>Node.js 웹앱 만들기</h2><h3 id="원하는-작업-디텍토리를-만듭니다"><a href="#원하는-작업-디텍토리를-만듭니다" class="headerlink" title="원하는 작업 디텍토리를 만듭니다."></a>원하는 작업 디텍토리를 만듭니다.</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mkdir node-web-app</span><br><span class="line"><span class="meta">$</span> cd node-web-app</span><br></pre></td></tr></table></figure><h3 id="Node-web-app-의-package-json-파일을-아래와-같이-만들어줍니다"><a href="#Node-web-app-의-package-json-파일을-아래와-같이-만들어줍니다" class="headerlink" title="Node web app 의 package.json 파일을 아래와 같이 만들어줍니다."></a>Node web app 의 package.json 파일을 아래와 같이 만들어줍니다.</h3><figure class="highlight json"><figcaption><span>package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"node_web_app"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"Node.js on Docker"</span>,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"server.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"node server.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"express"</span>: <span class="string">"^4.16.3"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>package.json 을 만드는 방법은 두가지가 있습니다.</p><ol><li><code>npm init</code> 을 이용하는 방법</li><li>직접 파일을 만드는 방법</li></ol></blockquote><h3 id="Express-를-이용하여-Web-app-을-정의합니다"><a href="#Express-를-이용하여-Web-app-을-정의합니다" class="headerlink" title="Express 를 이용하여 Web app 을 정의합니다."></a>Express 를 이용하여 Web app 을 정의합니다.</h3><figure class="highlight js"><figcaption><span>server.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'Hello Engineers\n'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="string">'0.0.0.0'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Node Web App is Running on http://0.0.0.0:8080`</span>);</span><br></pre></td></tr></table></figure><p>이렇게 하여, ‘Hello Engineers’ 를 리턴하는 간단한 Web App 이 만들어졌습니다.</p><h2 id="Docker-Image-만들기"><a href="#Docker-Image-만들기" class="headerlink" title="Docker Image 만들기"></a>Docker Image 만들기</h2><h3 id="Dockerfile-만들기"><a href="#Dockerfile-만들기" class="headerlink" title="Dockerfile 만들기"></a>Dockerfile 만들기</h3><p>Nginx 를 이용한 Docker image 와 대부분 비슷한 방식으로 이루어집니다.</p><figure class="highlight dockerfile"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#node:8 을 베이스 이미지로 사용합니다.</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">8</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#이미지내에서의 작업 디렉토리를 설정해줍니다.</span></span><br><span class="line"><span class="keyword">WORKDIR</span> /usr/src/app </span><br><span class="line"></span><br><span class="line"><span class="comment">#package.json 파일을 내부로 복사합니다.</span></span><br><span class="line"><span class="keyword">COPY</span> package.json . </span><br><span class="line"></span><br><span class="line"><span class="comment">#웹앱의 Dependency 를 설치해줍니다.</span></span><br><span class="line"><span class="keyword">RUN</span> npm install </span><br><span class="line"></span><br><span class="line"><span class="comment">#앱의 구동파일을 복사합니다.</span></span><br><span class="line"><span class="keyword">COPY</span> server.js . </span><br><span class="line"></span><br><span class="line"><span class="comment">#앱을 구동합니다.</span></span><br><span class="line"><span class="keyword">CMD</span> [ "npm", "start" ]</span><br></pre></td></tr></table></figure><h3 id="Docker-image-만들기"><a href="#Docker-image-만들기" class="headerlink" title="Docker image 만들기"></a>Docker image 만들기</h3><p>아래의 커맨드를 통해서 Docker image 를 만들어줍니다.</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker build -t &lt;username&gt;/node-web-app .</span><br></pre></td></tr></table></figure><h2 id="Web-app-구동하기"><a href="#Web-app-구동하기" class="headerlink" title="Web app 구동하기"></a>Web app 구동하기</h2><h3 id="Docker-image-구동하기"><a href="#Docker-image-구동하기" class="headerlink" title="Docker image 구동하기"></a>Docker image 구동하기</h3><p>아래의 커맨드를 통해서 Docker image 를 구동합니다.</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker run -d -p 30000:8080 &lt;username&gt;/node-web-app</span><br></pre></td></tr></table></figure><h3 id="정상동작-확인"><a href="#정상동작-확인" class="headerlink" title="정상동작 확인"></a>정상동작 확인</h3><p>브라우저에서 http//localhost:30000 으로 접속해보거나, CURL 을 이용하여 확인합니다.</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -i localhost:30000</span><br></pre></td></tr></table></figure><p>자 이제 나만의 웹앱(웹 서비스)가 만들어졌습니다. 원하시는 기능이 있으면, Express 를 이용해서 간단하게 기능을 추가하면 되겠죠??</p><p>위의 모든 진행을 한번 살펴보시죠 ^^</p><script type="text/javascript" src="https://asciinema.org/a/ZfiliNmqoehDS5lNv7oFmkBup.js" id="asciicast-ZfiliNmqoehDS5lNv7oFmkBup" async></script><blockquote><p>node image 를 받아두지 않아서, 시간이 좀 길어졌네요;;<br>server.js 에 오타가 하나 있었네요;; 문제를 파악하고, 해결하는 과정도 살펴보세요~^^</p></blockquote><h3 id="참고한-글들"><a href="#참고한-글들" class="headerlink" title="참고한 글들"></a>참고한 글들</h3><p><a href="https://nodejs.org/en/docs/guides/nodejs-docker-webapp/" target="_blank" rel="noopener">Dockerizing a Node.js web app</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;지금까지 Docker 기본도 익혔고, 실제 Dockerfile 도 만져봤으니 이번에는 Nginx 가 아닌, Node.js 서버를 이용한 간단한 웹앱을 만들어보겠습니다. &lt;em&gt;웹앱이라고 해봐야, 역시 Hello World 수준이지만, 이글은 No
      
    
    </summary>
    
      <category term="tech" scheme="https://donghopark.github.io/categories/tech/"/>
    
      <category term="docker" scheme="https://donghopark.github.io/categories/tech/docker/"/>
    
    
      <category term="docker" scheme="https://donghopark.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Github X Hexo 로 블로그 운영하기</title>
    <link href="https://donghopark.github.io/2019/02/27/how-to-hexo-github/"/>
    <id>https://donghopark.github.io/2019/02/27/how-to-hexo-github/</id>
    <published>2019-02-27T07:44:54.000Z</published>
    <updated>2019-03-10T11:46:15.268Z</updated>
    
    <content type="html"><![CDATA[<p>Github X Hexo 를 이용하여 블로그를 만드는 방법이 이제는 그다지 새로운 방법도 아니고, 만드는 방법을 소개하는 블로그도 제법되는데, 굳이 또 이렇게 <code>Github X Hexo 로 블로그 운영하기</code> 라는 제목으로 글을 쓸 필요가 있을까? 하는 생각도 들지만, 이번 글의 주제는 그냥 따라할 수 있는 <code>만들기</code>가 아니고, <code>어떻게 운영하는것이 가장 좋을까</code>에 대한 글이라는 점을 알려둔다.</p><p>Github X Hexo 로 블로그 만들기는 <a href="https://futurecreator.github.io/2016/06/14/get-started-with-hexo/" target="_blank" rel="noopener">워드프레스보다 쉬운 Hexo 블로그 시작하기</a>를 참조하자.</p><h2 id="Repo-를-하나만-이용하는-방법"><a href="#Repo-를-하나만-이용하는-방법" class="headerlink" title="Repo 를 하나만 이용하는 방법"></a>Repo 를 하나만 이용하는 방법</h2><p><code>Github 의 username.github.io 라는 Repo 를 생성하고, 로컬에서 Hexo 를 통해서 Static Page 를 만들어서 Github 에 Push 하는 방법</code>이다.</p><p>블로그를 작성하는 장소가 한곳으로 고정되어있을 경우네는 이 방법을 이용하는것도 추천할만 하다.</p><h3 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h3><p>관리해야 할 Repo 가 하나뿐이니 간단하다. </p><h3 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h3><p>두곳 이상에서 블로그를 작성할 수 없다.<br>블로그 설정등의 변경내역을 알 수 없다.</p><h2 id="Repo-를-두개-이용하는-방법"><a href="#Repo-를-두개-이용하는-방법" class="headerlink" title="Repo 를 두개 이용하는 방법"></a>Repo 를 두개 이용하는 방법</h2><p><code>Static Page 를 위한 Repo 와 Blog Contents 를 위한 Repo 를 별도로 만드는 방법</code>이다.</p><p>많은 분들이 실제로 사용하고 있는 방법으로, 글을 작성하는 환경을 Repo 에 관리하기때문에, 어디서라도 다시 환경을 Pull 해서 연속적으로 글을 작성할 수 있다.</p><h3 id="장점-1"><a href="#장점-1" class="headerlink" title="장점"></a>장점</h3><p>여러 장소에서 블로그를 작성할 수 있다.<br>블로그 설정의 변경내역을 관리할 수 있다.</p><h3 id="단점-1"><a href="#단점-1" class="headerlink" title="단점"></a>단점</h3><p>공개된 Theme 을 사용할 경우, Theme 의 설정 변경내역을 관리할 수 없다.</p><h2 id="Repo-를-세개-이용하는-방법"><a href="#Repo-를-세개-이용하는-방법" class="headerlink" title="Repo 를 세개 이용하는 방법"></a>Repo 를 세개 이용하는 방법</h2><p><code>Static Page, Blog Contents 뿐 아니라, Theme 을 위한 별도의 Repo 를 만드는 방법</code>이다.</p><p>내가 사용하고 있는 방법으로, 사용하고자 하는 공개 Theme 을 Fork 해서 별도로 관리하게 된다. </p><h3 id="장점-2"><a href="#장점-2" class="headerlink" title="장점"></a>장점</h3><p>Theme 에 적용된 변경사항들을 관리할 수 있다.</p><h3 id="단점-2"><a href="#단점-2" class="headerlink" title="단점"></a>단점</h3><p>Fork 된 Theme 의 업데이트를 신경써주어야 한다.</p><h3 id="실사용-예"><a href="#실사용-예" class="headerlink" title="실사용 예"></a>실사용 예</h3><p>내 블로그의 경우 아래와 같이 세개의 Repo 를 이용하여 관리된다.</p><p><a href="https://github.com/donghopark/donghopark.github.io" target="_blank" rel="noopener">Static Page</a><br><a href="https://github.com/donghopark/hexo-page" target="_blank" rel="noopener">Blog Contents</a><br><a href="https://github.com/donghopark/hexo-theme-next" target="_blank" rel="noopener">Next Theme</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Github X Hexo 를 이용하여 블로그를 만드는 방법이 이제는 그다지 새로운 방법도 아니고, 만드는 방법을 소개하는 블로그도 제법되는데, 굳이 또 이렇게 &lt;code&gt;Github X Hexo 로 블로그 운영하기&lt;/code&gt; 라는 제목으로 글을
      
    
    </summary>
    
      <category term="tech" scheme="https://donghopark.github.io/categories/tech/"/>
    
      <category term="hexo" scheme="https://donghopark.github.io/categories/tech/hexo/"/>
    
    
      <category term="hexo" scheme="https://donghopark.github.io/tags/hexo/"/>
    
      <category term="github" scheme="https://donghopark.github.io/tags/github/"/>
    
      <category term="blog" scheme="https://donghopark.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Docker 따라하기 #2</title>
    <link href="https://donghopark.github.io/2019/02/27/docker-2/"/>
    <id>https://donghopark.github.io/2019/02/27/docker-2/</id>
    <published>2019-02-27T02:57:55.000Z</published>
    <updated>2019-03-10T11:46:15.267Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 가 정상적으로 설치( <a href="/2019/02/27/docker-1/" title="Docker 따라하기 #1">Docker 따라하기 #1</a> )되었으니, 기본예제부터 한번 따라해본다.</p><h3 id="Hello-World-출력하기"><a href="#Hello-World-출력하기" class="headerlink" title="Hello World 출력하기"></a>Hello World 출력하기</h3><script type="text/javascript" src="https://asciinema.org/a/DDAkDKvnzgNSISkpEZBDujA3v.js" id="asciicast-DDAkDKvnzgNSISkpEZBDujA3v" async></script><h3 id="Nginx-구동하기"><a href="#Nginx-구동하기" class="headerlink" title="Nginx 구동하기"></a>Nginx 구동하기</h3><script type="text/javascript" src="https://asciinema.org/a/tZXRfot0SjCscXCMAbS47njkN.js" id="asciicast-tZXRfot0SjCscXCMAbS47njkN" async></script><p>vagrant 에서 설정한 Guest Os 의 주소(<a href="http://192.168.33.10/" target="_blank" rel="noopener">http://192.168.33.10/</a>)로 접속해서, 아래와 같은 화면이 나오면 정상!</p><img src="https://i.imgur.com/aq1H6Lv.png" title="This is an nginx welcome screen"><h3 id="Dockerfile-을-이용하여-Docker-Imgage-를-만들고-실행하기"><a href="#Dockerfile-을-이용하여-Docker-Imgage-를-만들고-실행하기" class="headerlink" title="Dockerfile 을 이용하여 Docker Imgage 를 만들고 실행하기"></a>Dockerfile 을 이용하여 Docker Imgage 를 만들고 실행하기</h3><p>위에서 따라한 Nginx 구동하기에서 Nginx 의 기본 Welcome 화면이 나온것은 아직 우리가 아무런 index.html 을 이미지에 추가하지 않아서입니다. 이번에는 우리가 직접만든 index.html 을 이미지에 추가해서 구동하해 봅시다.</p><p>일단, 새롭게 폴더를 하나 만들고, Dockerfile 을 생성해줍니다. (Dockerfile 은 Docker image 를 만드는 방법을 열거한 파일입니다.)</p><p>그리고, 아래와 같이 입렵합니다.<br><figure class="highlight dockerfile"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:latest</span><br><span class="line"><span class="keyword">COPY</span> index.html /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure></p><p>1행은 새로 만드는 이미지를 nginx:latest 를 바탕으로 만들겠다고 선언합니다. 이렇게 하면, 우리가 별도로 작업을 하지 않아도, nginx:latest 의 모든 기능을 사용할 수 있습니다.<br>2행은 우리가 새롭게 생성할 index.html 을 이미지의 nginx default index.html 의 위치에 카피하는 명령입니다.</p><p>이미지에 포함된 index.html 을 생성하고, 간단하게 html 을 입력하고, 이미지를 생성합니다.</p><p>새로 생성된 이미지를 바탕으로 nginx 서버를 구동하고 확인합니다.</p><p>위의 모든 과정을 한번 따라가 보죠</p><script type="text/javascript" src="https://asciinema.org/a/CsO0m7iHaBr27ClhrWk3UYT5z.js" id="asciicast-CsO0m7iHaBr27ClhrWk3UYT5z" async></script><p>마찬가지로 vagrant 에서 설정한 Guest Os 의 주소(<a href="http://192.168.33.10/" target="_blank" rel="noopener">http://192.168.33.10/</a>)로 접속해서, 아래와 같은 화면이 나오면 정상!</p><img src="https://i.imgur.com/C4bxpD4.png" title="This is an mynginx welcome screen"><h3 id="참고한-글들"><a href="#참고한-글들" class="headerlink" title="참고한 글들"></a>참고한 글들</h3><p><a href="https://futurecreator.github.io/2018/11/16/docker-container-basics/" target="_blank" rel="noopener">도커 Docker 기초 확실히 다지기</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker 가 정상적으로 설치( &lt;a href=&quot;/2019/02/27/docker-1/&quot; title=&quot;Docker 따라하기 #1&quot;&gt;Docker 따라하기 #1&lt;/a&gt; )되었으니, 기본예제부터 한번 따라해본다.&lt;/p&gt;
&lt;h3 id=&quot;Hello-Wo
      
    
    </summary>
    
      <category term="tech" scheme="https://donghopark.github.io/categories/tech/"/>
    
      <category term="docker" scheme="https://donghopark.github.io/categories/tech/docker/"/>
    
    
      <category term="docker" scheme="https://donghopark.github.io/tags/docker/"/>
    
      <category term="nginx" scheme="https://donghopark.github.io/tags/nginx/"/>
    
      <category term="dockerfile" scheme="https://donghopark.github.io/tags/dockerfile/"/>
    
  </entry>
  
  <entry>
    <title>Docker 따라하기 #1</title>
    <link href="https://donghopark.github.io/2019/02/27/docker-1/"/>
    <id>https://donghopark.github.io/2019/02/27/docker-1/</id>
    <published>2019-02-27T00:21:29.000Z</published>
    <updated>2019-03-10T11:46:15.266Z</updated>
    
    <content type="html"><![CDATA[<p>1년전쯤 잠시 공부하며 실습해보다가 완전 잊고 지냈던 Docker.<br>여러 블로거 분들의 글을 보며 다시한번 공부하면서 정리해 보려 한다.</p><p>우선 알아두어야 할것은 Docker 를 Host Os 에 바로 설치할 수도 있지만, 실전에서 Docker 를 사용하게될 Host Os 와 개발/개인/실습 Host Os 가 다르므로, 실전에서 사용할 OS(주로 Linux)에서 실습을 진행하기 위해 Vagrant + VirtualBox 를 사용하는것이다.<br>즉, 실습 Os 가 Linux 라면 굳이 Vagrant + VirtualBox 를 이용하지 않고, 바로 Docker 를 설치하여도 된다. 다만, 같은 Linux 라 하더라도, 여러 종류와 버전이 있으니, 옵션정도로 생각하면 될것 같다.</p><h3 id="VirtualBox-및-Vagrant-설치"><a href="#VirtualBox-및-Vagrant-설치" class="headerlink" title="VirtualBox 및 Vagrant 설치"></a>VirtualBox 및 Vagrant 설치</h3><ul><li>VirtualBox 설치</li></ul><p><a href="https://download.virtualbox.org/virtualbox/6.0.4/VirtualBox-6.0.4-128413-OSX.dmg" target="_blank" rel="noopener">VirtualBox for OS X Host</a></p><ul><li>Vagrant 설치</li></ul><p><a href="https://releases.hashicorp.com/vagrant/2.2.3/vagrant_2.2.3_x86_64.dmg" target="_blank" rel="noopener">Vagrant for macOS</a></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> vagrant -v</span><br><span class="line">Vagrant 2.2.3</span><br></pre></td></tr></table></figure><h3 id="Guest-Os-설정-및-구동"><a href="#Guest-Os-설정-및-구동" class="headerlink" title="Guest Os 설정 및 구동"></a>Guest Os 설정 및 구동</h3><p>Vigrant.conf 파일의 아래 부분을 수정/언코멘트만 해주시면 됩니다.</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config.vm.box = "centos/7"</span><br><span class="line">config.vm.network "private_network", ip: "192.168.33.10"</span><br><span class="line">config.vm.network "forwarded_port", guest: 80, host: 8080</span><br></pre></td></tr></table></figure><p><em>구동 영상은 녹화했다가 시간이 너무 오래 걸려서, 결과로 대신합니다</em></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> vagrant up</span><br><span class="line">Bringing machine 'default' up with 'virtualbox' provider...</span><br><span class="line">==&gt; default: Box 'centos/7' could not be found. Attempting to find and install...</span><br><span class="line">    default: Box Provider: virtualbox</span><br><span class="line">    default: Box Version: &gt;= 0</span><br><span class="line">==&gt; default: Loading metadata for box 'centos/7'</span><br><span class="line">    default: URL: https://vagrantcloud.com/centos/7</span><br><span class="line">==&gt; default: Adding box 'centos/7' (v1901.01) for provider: virtualbox</span><br><span class="line">    default: Downloading: https://vagrantcloud.com/centos/boxes/7/versions/1901.01/providers/virtualbox.box</span><br><span class="line">    default: Download redirected to host: cloud.centos.org</span><br><span class="line">==&gt; default: Successfully added box 'centos/7' (v1901.01) for 'virtualbox'!</span><br><span class="line">==&gt; default: Importing base box 'centos/7'...</span><br><span class="line">==&gt; default: Matching MAC address for NAT networking...</span><br><span class="line">==&gt; default: Checking if box 'centos/7' version '1901.01' is up to date...</span><br><span class="line">==&gt; default: Setting the name of the VM: centos7_default_1551223782426_14500</span><br><span class="line">==&gt; default: Clearing any previously set network interfaces...</span><br><span class="line">==&gt; default: Preparing network interfaces based on configuration...</span><br><span class="line">    default: Adapter 1: nat</span><br><span class="line">    default: Adapter 2: hostonly</span><br><span class="line">==&gt; default: Forwarding ports...</span><br><span class="line">    default: 80 (guest) =&gt; 8080 (host) (adapter 1)</span><br><span class="line">    default: 22 (guest) =&gt; 2222 (host) (adapter 1)</span><br><span class="line">==&gt; default: Booting VM...</span><br><span class="line">==&gt; default: Waiting for machine to boot. This may take a few minutes...</span><br><span class="line">    default: SSH address: 127.0.0.1:2222</span><br><span class="line">    default: SSH username: vagrant</span><br><span class="line">    default: SSH auth method: private key</span><br><span class="line">    default: </span><br><span class="line">    default: Vagrant insecure key detected. Vagrant will automatically replace</span><br><span class="line">    default: this with a newly generated keypair for better security.</span><br><span class="line">    default: </span><br><span class="line">    default: Inserting generated public key within guest...</span><br><span class="line">    default: Removing insecure key from the guest if it's present...</span><br><span class="line">    default: Key inserted! Disconnecting and reconnecting using new SSH key...</span><br><span class="line">==&gt; default: Machine booted and ready!</span><br><span class="line">==&gt; default: Checking for guest additions in VM...</span><br><span class="line">    default: No guest additions were detected on the base box for this VM! Guest</span><br><span class="line">    default: additions are required for forwarded ports, shared folders, host only</span><br><span class="line">    default: networking, and more. If SSH fails on this machine, please install</span><br><span class="line">    default: the guest additions and repackage the box to continue.</span><br><span class="line">    default: </span><br><span class="line">    default: This is not an error message; everything may continue to work properly,</span><br><span class="line">    default: in which case you may ignore this message.</span><br><span class="line">==&gt; default: Configuring and enabling network interfaces...</span><br><span class="line">==&gt; default: Rsyncing folder: /Users/dongho/Dev/centos7/ =&gt; /vagrant</span><br></pre></td></tr></table></figure><p>구동이 정상적이라면, 아래와 같이 VM 에 접근할 수 있습니다.</p><script type="text/javascript" src="https://asciinema.org/a/uP4EVpqgDOsyJgB2LolAmBykl.js" id="asciicast-uP4EVpqgDOsyJgB2LolAmBykl" async></script><h3 id="Docker-설치"><a href="#Docker-설치" class="headerlink" title="Docker 설치"></a>Docker 설치</h3><p>여기서부터는 Host Os 가 아닌, Guest Os 에서 진행합니다. 즉, vagrang ssh 상에서 진행한다고 생각하시면 됩니다. 이렇게 하면, Guest Os 에 Docker 가 설치되어 문제가 발생했을때 처리가 쉬워지고, 실전에서 사용하는것처럼 Docker 를 사용해 볼 수 있습니다. ;)</p><p>Docker 설치는 아래의 두가지 방법중 한가지를 따라하시면 됩니다. </p><p><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-2.html#linux" target="_blank" rel="noopener">자동 설치</a></p><p><a href="https://futurecreator.github.io/2018/11/16/docker-container-basics/#%EB%8F%84%EC%BB%A4-%EC%84%A4%EC%B9%98" target="_blank" rel="noopener">직접 설치</a></p><p>설치가 정상적이라면, 아래와 같이 확인이 가능합니다.</p><script type="text/javascript" src="https://asciinema.org/a/5yLZm11iR4u3rIbPc3RntHj4q.js" id="asciicast-5yLZm11iR4u3rIbPc3RntHj4q" async></script><a href="/2019/02/27/docker-2/" title="Docker 따라하기 #2">Docker 따라하기 #2</a><h3 id="참고한-글들"><a href="#참고한-글들" class="headerlink" title="참고한 글들"></a>참고한 글들</h3><p><a href="https://futurecreator.github.io/2018/11/16/docker-container-basics/" target="_blank" rel="noopener">도커 Docker 기초 확실히 다지기</a></p><p><a href="https://futurecreator.github.io/2018/06/16/record-terminal-asciinema/" target="_blank" rel="noopener">터미널을 보기 쉽게 녹화하기</a></p><p><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-2.html" target="_blank" rel="noopener">초보를 위한 도커 안내서 - 설치하고 컨테이너 실행하기</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1년전쯤 잠시 공부하며 실습해보다가 완전 잊고 지냈던 Docker.&lt;br&gt;여러 블로거 분들의 글을 보며 다시한번 공부하면서 정리해 보려 한다.&lt;/p&gt;
&lt;p&gt;우선 알아두어야 할것은 Docker 를 Host Os 에 바로 설치할 수도 있지만, 실전에
      
    
    </summary>
    
      <category term="tech" scheme="https://donghopark.github.io/categories/tech/"/>
    
      <category term="docker" scheme="https://donghopark.github.io/categories/tech/docker/"/>
    
    
      <category term="docker" scheme="https://donghopark.github.io/tags/docker/"/>
    
      <category term="vagrant" scheme="https://donghopark.github.io/tags/vagrant/"/>
    
      <category term="virtualbox" scheme="https://donghopark.github.io/tags/virtualbox/"/>
    
  </entry>
  
  <entry>
    <title>블로그를 시작하며</title>
    <link href="https://donghopark.github.io/2019/02/27/init/"/>
    <id>https://donghopark.github.io/2019/02/27/init/</id>
    <published>2019-02-26T12:54:55.000Z</published>
    <updated>2019-03-10T11:36:38.396Z</updated>
    
    <content type="html"><![CDATA[<p>네이버 블로그는 너무 제한적이어서 싫었고,<br>티스토리 블로그는 개방된 부분이 있지만, 여러가지 버그들이 귀찮았고,<br>블로거나 워드프레스는 그냥 거부감이 들었다.  </p><p>뭐 글을 엄청 써대는 스타일은 아니지만,<br>개발자 블로그 하나 정도는 가지고 있고 싶어서<br>이렇게 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 와 <a href="https://pages.github.com/" target="_blank" rel="noopener">Github page</a> 를 조합하여 블로그를 다시 해보려 한다.</p><p>일단 가장 신선하고 재미있는것은<br>블로그를 하기위해 <strong>Visual Studio Code</strong> 를 연다는것이다.</p><p>개발자에게 이보다 더 멋진 블로깅 플랫폼이 있을까 싶다.</p><p>얼마나 자주,<br>그리고 또 어떤 내용이<br>블로그에 올라올지는 모르겠지만,</p><p>기분좋게 첫 블로깅을 마친다.</p><p>지금 시각 1:54AM.<br>끗!</p><p>ps. 블로그 개설에 큰 도움을 주신 <a href="https://futurecreator.github.io" target="_blank" rel="noopener">Eric Han</a> 님께 감사드립니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;네이버 블로그는 너무 제한적이어서 싫었고,&lt;br&gt;티스토리 블로그는 개방된 부분이 있지만, 여러가지 버그들이 귀찮았고,&lt;br&gt;블로거나 워드프레스는 그냥 거부감이 들었다.  &lt;/p&gt;
&lt;p&gt;뭐 글을 엄청 써대는 스타일은 아니지만,&lt;br&gt;개발자 블로그 
      
    
    </summary>
    
      <category term="diary" scheme="https://donghopark.github.io/categories/diary/"/>
    
    
      <category term="hexo" scheme="https://donghopark.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="https://donghopark.github.io/tags/blog/"/>
    
      <category term="init" scheme="https://donghopark.github.io/tags/init/"/>
    
  </entry>
  
</feed>
