<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Hwidong Bae on Medium]]></title>
        <description><![CDATA[Stories by Hwidong Bae on Medium]]></description>
        <link>https://medium.com/@steadyslow?source=rss-c84770a5cabe------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*23n1WRgMz8p72TJt60BV-Q.jpeg</url>
            <title>Stories by Hwidong Bae on Medium</title>
            <link>https://medium.com/@steadyslow?source=rss-c84770a5cabe------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 01:02:30 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@steadyslow" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[Thanks for the article, and I want to address some points:]]></title>
            <link>https://medium.com/@steadyslow/thanks-for-the-article-and-i-want-to-address-some-points-8ce9a94a5729?source=rss-c84770a5cabe------2</link>
            <guid isPermaLink="false">https://medium.com/p/8ce9a94a5729</guid>
            <dc:creator><![CDATA[Hwidong Bae]]></dc:creator>
            <pubDate>Fri, 18 Jan 2019 04:05:51 GMT</pubDate>
            <atom:updated>2019-01-18T04:05:51.624Z</atom:updated>
            <content:encoded><![CDATA[<p>Thanks for the article, and I want to address some points:</p><ul><li><a href="https://github.com/kzk/jemalloc-rb">jemalloc</a> ruby gem is not maintained, and it seems using an old, fixed jemalloc version <a href="https://github.com/kzk/jemalloc-rb/tree/master/ext/jemalloc">5 years ago</a>. Instead, for MacOS, using brew to install jemalloc seems better.</li><li>Be careful when using double dash for CLI commands, since it is automatically converted to a single long dash.</li></ul><p>rvm reinstall 2.4.1 -C —with-jemalloc , which is ignored by rvm (as I experienced without knowing why), should be replaced with</p><p>rvm reinstall 2.4.1 -C --with-jemalloc</p><ul><li>Your script for checking out whether jemalloc is installed has unnecessary dot in the end.</li></ul><pre>ruby -r rbconfig -e &quot;puts RbConfig::CONFIG[&#39;LIBS&#39;]&quot;.</pre><p>→</p><pre>ruby -r rbconfig -e &quot;puts RbConfig::CONFIG[&#39;LIBS&#39;]&quot;</pre><p>The article helped me was <a href="https://scalingo.com/articles/2017/05/02/improve-ruby-application-memory-jemalloc.html">https://scalingo.com/articles/2017/05/02/improve-ruby-application-memory-jemalloc.html</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8ce9a94a5729" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[루비 mixin: include, prepend, extend 그리고 Concern]]></title>
            <link>https://medium.com/steady-study/%EB%A3%A8%EB%B9%84-mixin-include-prepend-extend-%EA%B7%B8%EB%A6%AC%EA%B3%A0-concern-e691c92fb233?source=rss-c84770a5cabe------2</link>
            <guid isPermaLink="false">https://medium.com/p/e691c92fb233</guid>
            <category><![CDATA[rails]]></category>
            <category><![CDATA[ruby]]></category>
            <category><![CDATA[modules]]></category>
            <category><![CDATA[mixin]]></category>
            <dc:creator><![CDATA[Hwidong Bae]]></dc:creator>
            <pubDate>Thu, 17 Jan 2019 03:50:56 GMT</pubDate>
            <atom:updated>2019-01-17T03:52:42.604Z</atom:updated>
            <content:encoded><![CDATA[<p>루비는 다른 객체지향 언어와 달리 클래스가 여러 부모로부터 상속받을 수 없습니다. 하지만 module을 mixin하면 다중 상속과 비슷한, 또는 더 풍부한 효과를 낼 수 있죠. 어떤 언어에서든 mixin이 지나치면 코드를 이해하기 어려워지지만, 잘 사용하면 중복이 줄어들고 깔끔해집니다. 루비의 mixin, 그리고 레일즈에서 더 편리하게 mixin을 사용할 수 있게 해주는 ActiveSupport::Concern에 대해 알아봅시다.</p><p><em>(글의 주제에 집중하기 위해 디테일을 많이 생략했습니다. 이 글에서 다루지 않은 부분이 궁금하시다면 </em><strong><em>참고문헌</em></strong><em> 섹션의 링크들을 읽어보시길 바랍니다.)</em></p><h3>배경지식</h3><p>기본적으로 다음 두 개념을 알아야 루비의 mixin에 대해 이해할 수 있습니다.</p><h4><a href="https://ruby-doc.org/core-2.5.0/Module.html">Module</a></h4><p>루비에서 <strong>모듈</strong>은 “메서드와 상수의 집합”을 뜻합니다. 모듈은 클래스와 달리 instantiate될 수 없으며, 모듈의 주 목적은 그 안에 정의한 메서드를 다양한 클래스에 include, prepend, extend를 통해 mixin해서 재사용하는 것입니다. 이렇게 mixin해서 사용하는 메서드를 인스턴스 메서드라고 부르고, 객체 생성 없이 모듈 자체에서 호출하는 메서드를 모듈 메서드라고 부릅니다. 모듈 메서드는 mixin해도 사용할 수 없습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/3e2001fd0e58efdda70d396f78392353/href">https://medium.com/media/3e2001fd0e58efdda70d396f78392353/href</a></iframe><h4><a href="https://ruby-doc.org/core-2.5.1/Module.html#method-i-ancestors">Ancestors</a></h4><p>루비에서는 클래스가 생성될 때 <strong>ancestors</strong> 배열에 클래스 조상의 목록을 저장해둡니다. ancestors에는 이 클래스가 상속받는 모든 클래스, 자기 자신, 그리고 include와 prepend 를 통해 mixin된 모듈들이 포함됩니다.</p><p>클래스의 인스턴스 메서드를 호출하면 ancestors 배열의 앞에서부터 메서드 정의를 찾습니다. 상속 개념과 유사하게, 메서드 정의를 찾지 못하면 다음 조상에게서 찾는 식입니다. 즉 둘 이상의 선조들이 같은 이름의 메서드를 정의하고 있다면 더 가까운 선조에 정의된 메서드를 실행합니다. 참고로 BasicObject까지 거슬러 올라갔는데도 메서드를 찾지 못하면 <a href="https://ruby-doc.org/core-2.5.0/BasicObject.html#method-i-method_missing">BasicObject#method_missing</a>이 실행되는데, 몇몇 루비 gem들은 이를 이용해 이해하기 쉽지 않은 흑마술을 부리기도 하더군요.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f6a054837b8965cb48db0d2acb1ae5f8/href">https://medium.com/media/f6a054837b8965cb48db0d2acb1ae5f8/href</a></iframe><h3>루비에서의 mixin</h3><h4><a href="https://ruby-doc.org/core-2.5.0/Module.html#method-i-include">Include</a></h4><p>include는 모듈에 정의된 메서드를 클래스에서 재사용하는 가장 쉽고 널리 알려진 방법입니다. 클래스를 정의할 때 어떤 모듈을 include하면 그 모듈은 ancestors 배열상에서 부모 클래스(superclass) 앞에 위치하게 되죠. 따라서 메서드 이름이 같다면 include된 모듈이 부모 클래스보다 우선순위를 가집니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/4d59990efce34257b941889cda55ed77/href">https://medium.com/media/4d59990efce34257b941889cda55ed77/href</a></iframe><h4><a href="https://ruby-doc.org/core-2.5.0/Module.html#method-i-prepend">Prepend</a></h4><p>prepend는 루비 2.0부터 도입된 mixin으로, include와 동작은 유사하나 용도는 다릅니다. include가 모듈의 메서드를 그대로 사용하기 위함이라면, prepend는 클래스의 기존 메서드를 꾸며주는 역할을 합니다. 이게 가능한 이유는 prepend된 모듈이 ancestors 배열상에서 원 클래스의 앞에 위치하기 때문입니다. 앞서 말씀드렸듯 메서드 호출은 ancesotrs의 앞에서부터 정의를 찾아나가기 때문에, prepend된 모듈의 메서드는 원 클래스의 메서드보다 우선순위가 높습니다. 그리고 여기에 다음 ancestor에서 메서드를 찾는 super 키워드를 조합하면, 해당 메서드의 앞이나 뒤에 우리가 원하는 동작을 추가할 수 있죠.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/a8d0b4d306e8852a60085b7807fe137f/href">https://medium.com/media/a8d0b4d306e8852a60085b7807fe137f/href</a></iframe><h4><a href="https://ruby-doc.org/core-2.5.0/Module.html#method-i-extend_object">Extend</a></h4><p>extend는 다른 두 mixin과 동작방식이 다릅니다. include와 prepend가 클래스의 ancestors 배열에 관여하여 <strong>인스턴스 메서드를 확장</strong>하는 개념이었다면, extend는 클래스의 <strong>클래스 메서드를 확장</strong>합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/36001d73662587967213bbb4ccceb0d8/href">https://medium.com/media/36001d73662587967213bbb4ccceb0d8/href</a></iframe><p>그런데 위 스니펫에서 보듯이 extend해도 MyClass의 ancestors에는 변화가 없습니다. 그러면 extend는 어떻게 클래스가 모듈의 메서드에 접근할 수 있게 해주는 것일까요? 애초에 클래스 메서드는 어떻게 실행되는 걸까요?</p><p>사실 루비에서 진정한 의미의 클래스 메서드는 존재하지 않습니다. 루비에서는 모든 것이 오브젝트이고, <strong>클래스</strong>도 다른 무언가의 인스턴스이며, 클래스 메서드도 결국은 인스턴스 메서드이기 때문입니다. 이에 대해 확실하게 이해하려면 싱글톤 클래스와 오브젝트 모델에 대해 알아야 합니다만, 지금은 “클래스 메서드는 싱글톤 클래스 안에 정의되고, 모듈을 extend하면 싱글톤 클래스가 확장된다”는 것만 기억해 둡시다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/10ebba8d763c8d95089909297c197cb7/href">https://medium.com/media/10ebba8d763c8d95089909297c197cb7/href</a></iframe><p>MyClass가 extend한 MyModule은 MyClass.singleton_class 의 ancestors로 존재합니다. 위치는 include와 유사하게 클래스의 싱글톤 클래스 다음이며, 싱글톤 클래스도 클래스이기 때문에 ancestors의 동작 방식도 같습니다. MyClass.log는 먼저 #&lt;Class:MyClass&gt;에서 메서드 정의를 찾아보고, 찾을 수 없으면 다음 ancestor인 MyModule에서 찾습니다.</p><h3>레일즈에서의 mixin</h3><h4>include + extend?</h4><p>모듈을 사용하다 보면, 어떤 모듈은 하나의 클래스에 extend하면서 동시에 include하고 싶을 때가 생깁니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5a4963c6672a96e0f1a95e7b8d633a5d/href">https://medium.com/media/5a4963c6672a96e0f1a95e7b8d633a5d/href</a></iframe><p>보시다시피 한 모듈을 두 번 mixin하는 것은 문법적으로는 가능하지만, 모듈의 메서드들이 클래스 메서드가 되면서 동시에 인스턴스 메서드도 되어버리기 때문에 우리가 원했던 상황과는 다릅니다.</p><p>이 문제는 모듈을 mixin할 때 호출되는 hook(<a href="https://ruby-doc.org/core-2.5.0/Module.html#method-i-included">included</a>, <a href="https://ruby-doc.org/core-2.5.0/Module.html#method-i-prepended">prepended</a>, <a href="https://ruby-doc.org/core-2.5.0/Module.html#method-i-extended">extended</a>)을 이용하여 해결할 수 있습니다. hook의 파라미터로 모듈을 mixin한 클래스가 넘어오기 때문에, 해당 클래스의 메서드들을 실행할 수 있는 것이죠. 다음은 이를 활용한 레일즈 코드 스니펫입니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d0884e3feaaca87005b78431e3e361aa/href">https://medium.com/media/d0884e3feaaca87005b78431e3e361aa/href</a></iframe><p>Record 클래스가 DisabledModule을 include함으로써 다음 세 가지가 가능해집니다.</p><ul><li>Record.new.disabled?: 모듈이 include되어 인스턴스 메서드가 확장됩니다.</li><li>Record.available_list: Record 클래스가 DisabledModule::ClassMethods를 extend하여 클래스 메서드가 확장됩니다.</li><li>Record.disabled: <a href="https://ruby-doc.org/core-2.5.0/Module.html#method-i-class_eval">class_eval</a>을 통해 Record 클래스의 컨텍스트에서 블록이 실행되고, Record 모델에 disabled scope가 정의됩니다.</li></ul><h4>ActiveSupport::Concern</h4><p>루비 1.9.3에서 included hook이 도입되고부터 위와 같은 패턴을 사용하는 케이스가 많아졌는데, 레일즈 4.0부터 생긴 ActiveSupport::Concern 은 이 패턴을 간편하게 줄여줍니다. <em>(너무 기니까 이제부터 </em><em>Concern이라고 칭하겠습니다.)</em></p><p>Concern을 extend한 모듈에서는 다음 두 블록을 사용할 수 있습니다.</p><ul><li>included 블록: self.included(base)를 대체합니다. Concern에서 이 블록을 class_eval 해주기 때문에, before_action이나 has_many 등 레일즈의 여러 유용한 hook이나 association을 재사용하기 쉬워집니다.</li><li>class_methods 블록: base.extend ClassMethods를 대체합니다. 이 블록 안에서 정의된 메서드는 모듈을 include한 클래스의 클래스 메서드로 확장됩니다.</li></ul><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/35c0c6646e4080e7b17fb44b62e0e9b3/href">https://medium.com/media/35c0c6646e4080e7b17fb44b62e0e9b3/href</a></iframe><h4>모듈간 의존성 문제</h4><p>여기까지만 해도 훌륭하지만, Concern은 모듈간 의존성 문제도 잘 해결해줍니다. 다음 코드 스니펫은 기존에 있던 UsefulModule을 MyModule로 확장하려는 의도를 가지고 있는데요.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/08d31f5fb8c2d18f294623e53e1f3b27/href">https://medium.com/media/08d31f5fb8c2d18f294623e53e1f3b27/href</a></iframe><p>UsefulModule의 included hook에 들어온 base가 MyClass가 아닌 MyModule이기 때문에, 스니펫을 실행하면 에러가 뜹니다. 이제 Concern을 쓴 스니펫을 보시죠.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f3c4e90e8362362bdbaa649db208112e/href">https://medium.com/media/f3c4e90e8362362bdbaa649db208112e/href</a></iframe><p>이 스니펫은 문제없이 실행되고, 의도대로 MyClass의 has_many 메서드가 호출됩니다(레일즈에서는 association 정의를 실행하게 되겠죠). 이게 가능한 이유는 Concern을 extend한 모듈의 모든 included 블록이, extend하지 않은 최초의 모듈에서 include된 것처럼 (즉 UsefulModule이 MyClass에 직접 include된 것처럼) 지연 실행되기 때문입니다. 좀 어려운데, 아무튼 개발자 입장에서는 Concern을 extend한 모듈을 다른 모듈에서도 안심하고 include할 수 있다는 걸 기억하시면 될 것 같습니다. 더 자세하게 알고 싶으신 분은 <a href="https://github.com/rails/rails/blob/master/activesupport/lib/active_support/concern.rb">소스코드</a>를 보셔도 좋겠네요.</p><h3>끝내며: Metaprogramming 맛보기</h3><p>루비와 레일즈의 mixin에 대해 알아봤습니다. 되도록 간결하게 적고 싶었는데 그래도 상당히 길어졌네요. 사실 너무 길어질까봐 별다른 설명 없이 적어놓은 문장이 꽤 있는데요. 그중 이게 가장 중요한 것 같습니다.</p><blockquote><em>루비에서는 모든 것이 오브젝트이고, </em><strong><em>클래스</em></strong><em>도 다른 무언가의 인스턴스이며</em></blockquote><p>루비에서는 모든 클래스는 Class 클래스의 인스턴스이고, 심지어 Class와 Module도 Class 클래스의 인스턴스입니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f9f4fd68c6b8d7f816249649ca0f7e23/href">https://medium.com/media/f9f4fd68c6b8d7f816249649ca0f7e23/href</a></iframe><p>MyClass는 Class 클래스의 인스턴스이므로, Class에 정의된 인스턴스 메서드를 MyClass.xxx형태로 쓸 수 있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/fd546a7ee80a7ecbacbd90f4844c3253/href">https://medium.com/media/fd546a7ee80a7ecbacbd90f4844c3253/href</a></iframe><p>뭔가 복잡하죠? 사실 include와 prepend도 Module 클래스의 인스턴스 메서드인데, Class 클래스가 Module 클래스를 상속받기 때문에 우리가 일반적인 클래스 정의 내에서 사용할 수 있는 것입니다. extend 는 또 혼자 좀 다르게, Kernel 모듈에 정의되어 있습니다.</p><p>오브젝트 모델에 대해 파고들어가보면 이렇게 복잡하면서도 흥미롭습니다. 오브젝트 모델이나 싱글톤 클래스 등에 대한 개념을 묶어서 <strong>Metaprogramming</strong>이라고 부르기도 하던데, 이에 대해서는 다음 기회에 글을 써보려고 합니다.</p><h3>참고문헌</h3><p><strong>Mixin</strong></p><ul><li><a href="https://matt.aimonetti.net/posts/2012/07/30/ruby-class-module-mixins/">Ruby Constructs: Class, Module and Mixin</a> by <a href="https://twitter.com/mattetti">Matt Aimonetti</a></li><li><a href="http://leohetsch.com/include-vs-prepend-vs-extend/">Include vs Prepend vs Extend</a> by <a href="https://twitter.com/leo_hetsch">Leo Hetsch</a></li><li><a href="http://engineering.appfolio.com/2013/06/17/ruby-mixins-activesupportconcern/">Ruby Mixins &amp; ActiveSupport::Concern</a> by <a href="https://twitter.com/appfolioeng">appfolio</a></li><li><a href="http://vaidehijoshi.github.io/blog/2015/10/13/stop-worrying-and-start-being-concerned-activesupport-concerns/">Stop Worrying and Start Being Concerned: ActiveSupport Concerns</a> by <a href="http://www.twitter.com/vaidehijoshi">Vaidehi</a></li></ul><p><strong>Singleton classes</strong></p><ul><li><a href="http://leohetsch.com/demystifying-ruby-singleton-classes/">Demystifying Ruby Singleton Classes</a> by <a href="https://twitter.com/leo_hetsch">Leo Hetsch</a></li><li><a href="https://medium.com/@jeremy_96642/module-extend-understanding-ruby-singleton-classes-9dea718c80f2">Module#extend: Understanding Ruby Singleton Classes</a> by <a href="https://medium.com/@jeremy_96642">Jem Zornow</a></li></ul><p><strong>Super keyword</strong></p><ul><li><a href="https://medium.com/rubycademy/the-super-keyword-a75b67f46f05">The super keyword in Ruby</a> by <a href="https://medium.com/@farsi_mehdi">Mehdi Farsi</a></li><li><a href="https://ruby-doc.org/core-2.5.0/doc/keywords_rdoc.html">https://ruby-doc.org/core-2.5.0/doc/keywords_rdoc.html</a></li></ul><p><strong>Metaprogramming</strong></p><ul><li><a href="http://ruby-metaprogramming.rubylearning.com/html/seeingMetaclassesClearly.html">Seeing Metaclassess Cleary</a> by <a href="https://whytheluckystiff.net/about/">why the lucky stiff</a></li><li><a href="https://medium.com/@shubham7/understanding-the-ruby-object-model-685136dd64d9">Understanding Ruby Object Model</a> by <a href="https://medium.com/@shubham7">Shubham Saxena</a></li></ul><p><em>Originally published at </em><a href="https://spilist.github.io/2019/01/17/ruby-mixin-concern"><em>spilist.github.io</em></a><em>.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e691c92fb233" width="1" height="1"><hr><p><a href="https://medium.com/steady-study/%EB%A3%A8%EB%B9%84-mixin-include-prepend-extend-%EA%B7%B8%EB%A6%AC%EA%B3%A0-concern-e691c92fb233">루비 mixin: include, prepend, extend 그리고 Concern</a> was originally published in <a href="https://medium.com/steady-study">Steady Study</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[번역] 고비용 테스트, 고효용 테스트]]></title>
            <link>https://medium.com/steady-study/%EB%B2%88%EC%97%AD-%EA%B3%A0%EB%B9%84%EC%9A%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B3%A0%ED%9A%A8%EC%9A%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-2d8b53bf7379?source=rss-c84770a5cabe------2</link>
            <guid isPermaLink="false">https://medium.com/p/2d8b53bf7379</guid>
            <category><![CDATA[test-driven-development]]></category>
            <category><![CDATA[testing]]></category>
            <category><![CDATA[software-development]]></category>
            <dc:creator><![CDATA[Hwidong Bae]]></dc:creator>
            <pubDate>Wed, 26 Dec 2018 00:00:00 GMT</pubDate>
            <atom:updated>2018-12-26T10:00:12.588Z</atom:updated>
            <content:encoded><![CDATA[<p>원문: <a href="https://medium.com/table-xi/high-cost-tests-and-high-value-tests-a86e27a54df">High Cost Tests and High Value Tests</a> by <a href="https://medium.com/u/9cdb930e6fa0">Noel Rappin</a></p><figure><img alt="img" src="https://cdn-images-1.medium.com/proxy/1*8xT-hLqBv7jIbsAc227u-A.jpeg" /><figcaption><em>테스트의 비용과 효용 측정에 장표는 필요하지 않습니다.</em></figcaption></figure><p>(이 글은 이메일로 진행되는 <a href="https://www.rubytapas.com/testingjournal/">Noel Rappin의 Testing Journal</a> 수업의 추가 자료입니다. 이메일 수업의 내용과 관련은 있으나 완전히 들어맞지는 않아서 따로 작성합니다. 당신이 이 글을 괜찮게 여기신다면 제 수업에도 가치를 느끼실 겁니다. 제가 Justin Searls, Sam Phippen과 함께 진행하는 <a href="http://www.techdoneright.io/004-testing-with-sam-and-justin">Tech Done Right</a> 팟캐스트에서도 비슷한 주제로 논의했던 에피소드를 찾아보실 수 있습니다.)</p><p>저는 종종 테스트를 “고비용” 또는 “고효용”으로 묘사합니다. 물론 당신은 대체 무엇이 테스트의 효용을 높이는건지 궁금하실 겁니다. 테스트를 금이나 다른 물건으로 교환할 수 있는 시장 따위는 존재하지 않으니까요.</p><p>한번 파고들어가 보죠. 테스트에는 비용과 효용이 존재합니다.</p><p>하나의 테스트에 대한 비용은 다음 목록을 포함합니다:</p><ul><li>테스트 작성에 드는 시간</li><li>매 테스트 스위트마다 테스트 실행에 걸리는 시간</li><li>테스트를 이해하는 데 걸리는 시간</li><li>코드가 괜찮지만 테스트는 깨질 때 테스트 수정에 드는 시간</li><li>어쩌면, 테스트가 가능하도록 코드를 변경하는 시간</li></ul><p>여기서 비용의 단위는 시간입니다. 테스트에는 시간이 듭니다. 모든 프로그래밍의 의사결정은 결국 시간의 문제입니다. 코드 품질 때문에 변경이 쉬워지거나 어려워진다는 말도 사실 코드 변화에 드는 시간에 대한 이야기죠.</p><p>테스트에 시간이 든다면, 테스트로 시간을 벌 수도 있을까요?</p><ul><li>테스트 작성 행위가 코드 구조를 잡기 더 쉽게 해줍니다.</li><li>자동화 테스트는 수동으로 복잡한 통합 단계를 일일이 거치는 것보다 빠릅니다.</li><li>테스트는 코드가 의도한 대로 동작하고 있음을 효율적으로 증명해줍니다.</li><li>테스트는 코드 변화로 인해 동작 변화가 생겼음을 경고해줍니다.</li></ul><p>테스트의 비용과 효용은 코드의 전체 생애주기에 걸쳐 나타납니다. 처음 테스트가 작성됐을 때 비용이 생기고, 테스트가 읽히고 실행될 때마다 비용이 점차 누적되죠. 만약 테스트가 실패했는데 실제 코드에는 문제가 없을 때에는 큰 비용이 생깁니다. 어설픈 테스트가 시간을 크게 잡아먹을 수 있다는 겁니다.</p><p>테스트가 당신이 정확한 코드를 더 빠르게 작성할 수 있도록 (TDD 테스트처럼) 돕는다면, 그 테스트는 작성됐을 때부터 효용을 더해줍니다. 수동 테스트 대신 자동 테스트를 돌릴 때에도 효용이 생기고요. 새 코드를 만들었을 때 테스트가 실패함으로써 무언가 문제가 생겼음을 알려준다면 크게 시간이 절약됩니다.</p><p><a href="https://github.com/thoughtbot/shoulda">Shoulda gem</a>을 예로 들어보죠. 이 gem은 should belong_to :users 와 같은 여러 matcher를 제공하는데, 그게 테스트의 전부입니다. 이 테스트는 비용이 낮습니다. 순식간에 작성할 수 있고, 이해하기 쉽고, 빨리 실행되니까요. 하지만 동시에 효용도 낮습니다. 코드 로직이 아닌 데이터베이스에 종속되어 있어서 코드의 디자인에 대해 테스트가 설명해주는 것이 별로 없습니다. 이 테스트 혼자 실패할 일도 거의 없죠. users association이 없어진다면 아마 수많은 테스트가 실패할 테니, 이 테스트가 실패했다는 걸 앎으로써 당신이 새롭게 알게 되는 사실은 없을 겁니다.</p><p>반대로, 전체 결제 프로세스를 훑도록 <a href="https://github.com/teamcapybara/capybara">Capybara</a>로 만들어진 E2E 통합 테스트를 생각해봅시다. 이 테스트는 고비용일 겁니다. 수많은 데이터와 여러 테스트 단계를 거칠 것이고 결과 매칭도 복잡할 테니까요. 또한, 이 테스트는 고효용일 겁니다. 어쩌면 결제 과정에서 모든 다른 조각들이 제대로 통신하면서 동작하는지 확인할 수 있는, 즉 다른 테스트로는 찾아낼 수 없는 에러를 발견하는 유일한 테스트가 이녀석일지도 모르죠. 그리고 개발 후에 결제를 한단계씩 거치며 직접 해보는 것보다는 테스트 실행이 빠를 겁니다.</p><p>즉 오랜 시간동안 당신의 테스트 스위트를 행복하게 만들려면, 테스트의 비용은 최소화하고 효용은 극대화해야 합니다. 뻔한 말로 들리실 수 있겠지만, 명시적으로 비용과 효용의 측면에서 생각해보는 건 도움이 됩니다.</p><p>몇 가지 구체적인 조언을 드려보자면…</p><ul><li>테스트 통과보다는 실패에 집중하세요. 테스트를 실패시킬 방법이 없다면, 불필요한 테스트일지도 모릅니다.</li><li>통합 테스트를 염두에 두고 개발하면 자잘한 스텝들을 자동화하기 쉽습니다.</li><li>단위 테스트는 테스트가 실패하게 만들 최소한의 코드로만 작성하세요. 예를 들면, 에러 케이스들은 느리고 복잡한 통합 테스트보다는 테스트 대역과 함께 좁게 집중된 단위 테스트로 만드는 게 낫습니다.</li><li>단위 테스트가 실제 의존성을 사용(외부 라이브러리 호출, 데이터베이스에 많은 데이터 저장 등)하지 않도록 테스트 대역을 쓰세요.</li><li>버그 하나가 여러 테스트를 실패하게 만든다면 그 모든 테스트가 전부 필요한지 생각해 보세요. 실패가 셋업 단계에 있다면, 그 모든 테스트가 다 그 셋업을 필요로 하는지 생각해보시고요.</li><li>때로, 개발 단계에서 유용했던 한 테스트가 나중에 만든 다른 테스트에 완전히 포함될 수 있습니다. 리팩토링하세요.</li></ul><p>테스트를 작성할 때 단기적 / 장기적 비용을 고려하면 테스트가 더 좋아집니다. 그리고 테스트가 좋아지면 코드도 좋아지죠.</p><p>감사합니다.</p><p><em>Originally published at </em><a href="https://spilist.github.io/2018/12/26/high-cost-tests-high-value-tests"><em>spilist.github.io</em></a><em> on December 26, 2018.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2d8b53bf7379" width="1" height="1"><hr><p><a href="https://medium.com/steady-study/%EB%B2%88%EC%97%AD-%EA%B3%A0%EB%B9%84%EC%9A%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B3%A0%ED%9A%A8%EC%9A%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-2d8b53bf7379">[번역] 고비용 테스트, 고효용 테스트</a> was originally published in <a href="https://medium.com/steady-study">Steady Study</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[번역]당신이 반드시 배워야 할 바로 그 프로그래밍 언어]]></title>
            <link>https://medium.com/steady-study/%EB%B2%88%EC%97%AD-%EB%8B%B9%EC%8B%A0%EC%9D%B4-%EB%B0%98%EB%93%9C%EC%8B%9C-%EB%B0%B0%EC%9B%8C%EC%95%BC-%ED%95%A0-%EB%B0%94%EB%A1%9C-%EA%B7%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4-5f432b33ec1?source=rss-c84770a5cabe------2</link>
            <guid isPermaLink="false">https://medium.com/p/5f432b33ec1</guid>
            <category><![CDATA[software-development]]></category>
            <category><![CDATA[programming-languages]]></category>
            <dc:creator><![CDATA[Hwidong Bae]]></dc:creator>
            <pubDate>Tue, 23 Oct 2018 00:00:00 GMT</pubDate>
            <atom:updated>2018-10-26T00:05:56.922Z</atom:updated>
            <content:encoded><![CDATA[<p>원문: <a href="http://leohetsch.com/the-next-programming-language-you-should-learn/">The Next Programming Language You Should Learn</a> by <a href="https://twitter.com/leo_hetsch">Leonard Hetsch</a></p><p>프로그래머 여러분, 안녕하세요.</p><p>당신이 이 글을 읽으려고 클릭한 몇 가지 이유를 추측해보죠.</p><p>어쩌면 당신의 다음 커리어를 성공으로 이끌어줄, 6개월만 배워도 모두가 당신을 고용하고 싶어할 만한 그런 멋진 언어를 찾길 희망하며 이 글을 클릭했을지도 모르겠네요. 아니면 “최고의” 프로그래밍 언어를 논하는 또다른 낚시글에 그저 화가 나서, 글 맨 끝으로 스크롤하여 저를 비난할 준비를 마쳤을수도 있겠군요. 또는 그냥 당신의 뉴스피드에 나타난 이 글이 뭔지 궁금해서, 새로운 언어 하나 배워볼까 해서 클릭했으려나요.</p><p>음, 실망시켜드려 죄송합니다. 저는 모든 벤치마크에서 최고점을 받아 AWS에서 월 10달러로 사용자 10억을 감당하는 플랫폼을 만들 수 있는 그런 갓 나온 최고 성능의 어메이징한 프로그래밍 언어를 소개하려는 게, 아닙니다.</p><p>이미 인터넷에는 이 주제에 대한 <a href="https://www.quora.com/search?q=which+programming+language+should+I+learn">십수개의 Quora 쓰레드</a>와 <a href="https://medium.com/search?q=choose%20programming%20language">Medium 포스트</a>가 있고, <a href="https://www.google.co.uk/search?q=which+programming+language+should+i+learn&amp;oq=which+programm&amp;aqs=chrome.1.69i57j0l3j69i60j0.2230j0j7&amp;sourceid=chrome&amp;ie=UTF-8">구글</a>에는 말할 것도 없죠. 대신 저는, 더 나은 프로그래머가 되기 위해 배워야만 할 궁극의 언어(들)을 찾는 이 영원한 여정에 대한 제 의견을 말씀드리고자 합니다. 사실은 이 여정이 위험한 이유에 대해서도요.</p><p>새 집에서 쓸 침대를 하나 사서 설치한다고 가정해 봅시다. IKEA에서 수많은 침대를 본 당신은 혼란에 빠졌습니다. 이전에 한 번도 가구를 직접 설치해본 적이 없었기 때문이죠(아니면 저처럼 가구 설치에 젬병이거나요). 나무로 된 멋진 일제 킹사이즈 침대를 마침내 고르긴 했지만, 어떤 도구를 사용해서 설치할지는 전혀 감이 오지 않는군요.</p><p>그래서 당신은 가까운 판매원에게 가서, 침대 설치에 쓸 단 하나의 궁극 도구가 뭐냐고 물어봅니다.</p><p>잠깐, 뭐라고요? 당연히 이런 걸 물어보지 않겠죠. 확실히는 모르겠지만, 나사와 스크류드라이버, 렌치, 어쩌면 드릴 정도가 필요할 거라고 생각합니다. 하지만 확실히 알 수 있는 건, 단 하나의 도구만으로는 원하는 대로 설치를 할 수 없으리라는 사실이죠. 그리고 만약 판매원이 200달러짜리 마법의 올인원 도구를 팔려고 들지 않는 한, 그도 당신에게 같은 말을 해줄 겁니다.</p><p>소프트웨어에서도 마찬가지입니다. 모든 것보다 우월한 단 하나의 도구, 단 하나의 언어, 단 하나의 플랫폼 따위는 존재하지 않습니다. 어떤 제대로 된 언어로도 당신이 원하는 걸 만들 수 있고, 그거면 충분합니다. 그러고 나서 당신이 원하는 것이 속도냐, 확장성이냐, 성능이냐 등에 따라 더 나은 옵션을 선택할 수 있겠죠. 초기 단계 스타트업에게는 아주 좋은 기술 선택이, 수백만 사용자로 스케일해야 하는 회사에게는 끔찍한 선택이 될 수 있습니다.</p><p>네, 맞습니다. PHP로 Wordpress 웹사이트만 만들어서도 아무 걱정 없이 먹고살 수 있습니다. Java 하나만 평생 쓰더라도 일자리 걱정은 없을 겁니다. Ruby, Python, Javascript, 또는 당신이 원하는 다른 무언가를 사용할 수도 있습니다. 이 언어들로 무언가를 만들어서 당신이 원하는 바를 성취할 수 있다면 그 모두가 좋은 선택입니다.</p><p>사실 당신이 집중하기로 선택한 기술 하나 때문에 다음 일자리를 찾지 못하게 될 가능성은 매우 낮습니다. 유일한 예외는 당신이 고른 언어가 매우 좁은 사용처에서만 쓰이거나, 시대에 뒤떨어진 경우입니다(물론 이 경우에도, 여전히 <a href="https://www.indeed.com/q-Fortran-jobs.html">Fortran 프로그래머를 찾는 곳</a>이 있는 것 같군요).</p><p>물론 저는 이런 고민이 아주 일반적이며 우리 모두가 때로 이 고민에 빠져들게 된다는 걸 인정합니다. 저도, 최근까지도 이런 고민을 했습니다. 요즘 인기를 끄는 이 새로운 언어에 시간을 쏟아야 할까? 아니면 내가 좀 더 “진지한” 프로그래머로 보일 만한 이 언어를 선택해야 할까? 이런 고민은 다들 하는 겁니다. 고민은 인간의 것이니까요. 그리고, 우리의 일이 사실상 컴퓨터에게 속삭이는 것에 비슷한 만큼, 우리 모두는 아직 인간입니다. (<em>And, as close as our job is to whisper to the ears of computers, we are all still humans.</em> — 번역이 어려워서 원문을 포함)</p><p>인력시장에서 개발자 구인난은 실존합니다. 아마 앞으로 몇년간은 그대로겠죠. 소프트웨어 엔지니어를 찾고 고용하는 일은 무척 어렵습니다. 하지만 진짜 어려운 일은 아주 훌륭한 소프트웨어 엔지니어를 찾는 것이죠. 몇몇 플랫폼이 좀 더 거대한 커뮤니티를 갖고있긴 하나, 이 말은 프로그래밍 언어에 상관없이 사실입니다.</p><p>10여년 전, 저는 HTML, CSS, Javascript와 PHP로 첫번째 웹사이트를 만들었습니다. 웬걸, 그때는 이런 걸로 직업을 가질 수 있으리라고는 상상도 못했죠. 이후 저는 Ruby를 알게 되어 사랑에 빠졌고, Node.js도 배웠습니다. Objective-C로 iOS 앱 만드는 법도 배웠어요(사랑에 빠지진 않았지만 앱은 몇 개 만들었습니다). Go를 알게 되고는 다시 사랑에 빠졌습니다. 요즈음에는 Elixir와 Clojure로 놀고 있고요. 이 글을 쓰고 있는 지금은 온라인 Erlang 교육을 들으며, 제가 지금까지 개발하던 방식과는 완전히 다른 사고방식을 배우며 즐거워하고 있습니다. 아주 재미있어요.</p><p>이렇게 늘어놓자니 여드름 나던 시절 첫키스했던 여자아이로부터 시작해 모든 구여친들의 목록을 만들고있는 것 같네요. 당신이 디즈니랜드에 사는 게 아니라면, 내게 맞는 단 한 사람을 단번에 찾으리라 기대하지는 않을 겁니다. 제가 당신에게 어떤 완벽한 사람을 소개해줄테니 당장 가서 데이트하라고 하면 어떨까요? 저를 믿으시겠어요?</p><p>아마 아니겠죠.</p><p>연애와 프로그래밍이 다른 점은, 첫 PHP 코드를 짠지 수 년이 지난 지금도 저는 PHP 작업을 즐긴다는 것입니다. 물론 유일하며 신성한 index.php에 작성된 형편없는 코드를 좋아한다는 건 아닙니다. 저는 Symfony, Laravel과 Composer 같은 성숙한 프레임워크와 도구가 있는 생태계를 좋아합니다. 플랫폼이 진화해온 과정을 사랑합니다.</p><p>그리고 지나간 연애처럼, 이 언어에 쏟았던 시간들은 오늘날 프로그래머로서의 나를 구성하는 일부분입니다. 제 길에 거쳐간 다른 언어들도 조만간 그런 역할을 할 거고요.</p><p>최근 DHH(역자 주: <a href="https://twitter.com/dhh">David Heinemeir Hansson</a>, Rails 창시자)의 RailsConf 세션을 봤습니다. 무척 흥미로운 영상이었지만 몇 군데 동의하기 어려운 주장이 있었습니다.</p><p>저는 언어나 플랫폼의 선택이 항상 이성적이고 논리적인 사고에 의한 것이 아니며, 오히려 특정한 믿음과 가치판단에서 비롯된다는 주장에 동의합니다. 이는 스타트업 창업자들에게 더욱 그러한데, 이들은 수백만 사용자로 바로 스케일업할 수 있는 기술 스택을 골라야만 하는 처지가 아니기 때문입니다. 그래서, 살아오며 선택해온 다른 것들처럼, 그저 당신이 알고, 경험해봤고, 사랑하는 가치를 지닌 것들을 고르게 됩니다.</p><p>다만 저는 DHH와 달리, 누군가가 꼭 특정 커뮤니티 하나에만 속할 필요는 없다고 생각합니다. 제가 Ruby의 문법, 커뮤니티와 단순성을 좋아하는 건 맞지만, 메서드 수십 개와 서로 다른 책임 다섯 개를 가진 클래스를 만들고 싶지는 않습니다. 저는 Go의 단순함과 강력함을 좋아하지만, 특징적인 지침을 강요하여 사용자들에게 자유를 제한하는 방식은 별로 동조하지 않습니다. 최근에는 Erlang과 Elixir 패턴 매칭에 푹 빠졌지만 제 프로젝트 대부분에서 이 언어들을 쓰지는 않을 겁니다.</p><p>그러나 제가 배우거나 시도해온 이 모든 언어들은 제가 반영해볼 수 있는 무언가가 되었고, 제가 작업할 때 더 나은 의사결정을 하도록 도와주고 있습니다. 이는 제가 하나의 기술에서 비롯된 하나의 관점과 하나의 해답만을 가지고 있지 않은 덕분입니다. 저는 제가 알고 이해해온 여러가지 관점 중 가장 현재 상황에 맞는 것을 선택할 수 있습니다. 더 많이 알면 프로그래머로서 더 넓은 시야를 가지게 되며, 새로운 것도 더 쉽게 배울 수 있습니다.</p><p>그리고 이게 바로 당신이 성장하기 위해 찾아나서야 할 것입니다. 하나 배워서 평생 먹고살 기술을 찾는 게 아니라요.</p><p>물론 어느 순간에는 특정 언어나 플랫폼에 더 특화된 전문성을 원하게 될지도 모릅니다. 그것도 좋습니다. 당신이 사랑하고 편안하게 느끼는 기술을 연마하기로 선택했을 테고, 그동안의 경험에서 배워온 것들을 활용하여 그 기술의 전문가가 될 테니까요.</p><p>이는 모든 언어에 통용됩니다. 모든 언어에는 당신이 좋아할 만한 요소와 싫어할 만한 요소가 있을 거예요. 사람은 과거의 인간관계와 선택과 실수로부터 자기 자신을 더 알아가게 됩니다. 소프트웨어 엔지니어도 마찬가지로, 다른 기술을 발견하고 학습하는 과정에서 스스로에 대해 더 많이 알게 되고, 더 나은 엔지니어가 됩니다. 변화와 새 패러다임과 새 사고방식과 새 해결책에 열려있게 됩니다. 몇 달만에 세상이 바뀌어버리는, 그리고 직업의 다양성이 무척 큰 이 시대에서, 변화 수용성은 언제나 바람직합니다.</p><p>그러니, 당신이 성공한 프리랜서 워드프레스 개발자라도 스스로를 PHP에 한정짓지는 마세요. Java에 빠삭하더라도 Java만 파지는 마세요. 프론트엔드 엔지니어라도, WebGL 개발자라도 Javascript만 쓰지는 마세요. iOS나 Android 개발 하나만 하지는 마세요. 객체지향 프로그래밍이나 함수형 프로그래밍에 스스로를 한정짓지 마세요.</p><p>유일한 플랫폼, 유일한 관념, 유일한 사고방식에 갇히지 마세요.</p><p>열린 마음과 호기심을 가지고, 배우는 사람이 되면 언젠가 당신에게 큰 보상이 돌아올 겁니다.</p><p><em>이것이</em> 바로 당신이 반드시 배워야 할 무언가입니다.</p><p><em>Originally published at </em><a href="https://spilist.github.io/2018/10/23/the-next-programming-language"><em>spilist.github.io</em></a><em> on October 23, 2018.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5f432b33ec1" width="1" height="1"><hr><p><a href="https://medium.com/steady-study/%EB%B2%88%EC%97%AD-%EB%8B%B9%EC%8B%A0%EC%9D%B4-%EB%B0%98%EB%93%9C%EC%8B%9C-%EB%B0%B0%EC%9B%8C%EC%95%BC-%ED%95%A0-%EB%B0%94%EB%A1%9C-%EA%B7%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4-5f432b33ec1">[번역]당신이 반드시 배워야 할 바로 그 프로그래밍 언어</a> was originally published in <a href="https://medium.com/steady-study">Steady Study</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[전문성, 패턴, 재귀, 언행일치]]></title>
            <link>https://medium.com/steady-study/%EC%A0%84%EB%AC%B8%EC%84%B1-%ED%8C%A8%ED%84%B4-%EC%9E%AC%EA%B7%80-%EC%96%B8%ED%96%89%EC%9D%BC%EC%B9%98-f3991fd41ee4?source=rss-c84770a5cabe------2</link>
            <guid isPermaLink="false">https://medium.com/p/f3991fd41ee4</guid>
            <category><![CDATA[expertise]]></category>
            <category><![CDATA[recursion]]></category>
            <category><![CDATA[patterns]]></category>
            <dc:creator><![CDATA[Hwidong Bae]]></dc:creator>
            <pubDate>Thu, 19 Jul 2018 14:06:00 GMT</pubDate>
            <atom:updated>2018-07-19T14:06:00.667Z</atom:updated>
            <content:encoded><![CDATA[<h3>전문성과 패턴</h3><p>전문성은 현상에서 패턴을 찾는 것이다. 전문가는 패턴을 프로세스로 만들어 최적화하고, 다른 사람이 따를 수 있는 형태로 전달한다. 전문성이 깊어질수록 프로세스를 더 잘게 쪼개서 베이비 스텝을 밟을 수 있다. 패턴 찾기, 프로세스 만들기, 스텝 쪼개기를 잘 하는게 전문가의 특징이며, 거꾸로 이것들을 의도적으로 수련함으로써 전문성을 키울 수 있다.</p><p>‘전문가는 현상에서 패턴을 찾는다’는 패턴도 찾았고 ‘패턴 찾기 — 프로세스 만들기 — 스텝 쪼개기 — 전달하기’라는 프로세스도 만들었지만, 난 아직 프로세스를 잘게 쪼갤 만큼 전문성에 대한 전문성은 없다. 얼마 전에 읽은 책 <a href="https://www.amazon.com/Business-Expertise-Entrepreneurial-Experts-Convert/dp/1605440604">Business of Expertise</a> 에서 ‘패턴 찾기’를 더 잘게 쪼개는 힌트는 얻었다. 패턴을 찾으려면 1) 유사한 현상에 여러 번 노출되어야 하고, 2) 그렇게 노출될 수 있는 좋은 환경에 스스로를 위치시켜야 한다는 것.</p><h3>패턴과 재귀</h3><p>재귀recursion는 그 자체로 패턴이다. 재귀함수는 실행 결과를 다시 자신의 인풋으로 넣는다. 이는 스타트업에서는 개밥 먹기(스스로 자기 제품의 고객이 되기)이며, 일상생활에서는 언행일치다.</p><h3>재귀와 언행일치</h3><p>재귀적 주제는 항상 나의 눈길을 끌고 왠지모를 인사이트를 준다. 지주형님의 글 <a href="http://egloos.zum.com/moraz/v/1181189">이해를 이해하기</a>. 김창준님의, 애자일 코치를 키우는 코치가 될 수 있게 코칭해주는 <a href="http://www.ac2.kr/">AC2 과정</a>. 제랄드 와인버그의 <a href="http://www.acornpub.co.kr/book/weinberg-on-writing">글쓰기에 대한 글쓰기 책</a>. 스타트업을 고객으로 하는 스타트업들. (<a href="https://medium.com/steady-study/디버그를-디버깅하기-단계적-디버깅-프로세스-템플릿-d3d4a9882adb">디버그를 디버깅하기</a>.) 이러한 주제를 다루는 조직이나 사람은 자신의 주장이 자신의 행동으로 바로 검증된다. 따라서 언행일치하며 자기모순에 빠지지 않도록 치열하게 노력해야 한다.</p><h3>언행일치와 전문성</h3><p>언행일치를 실천하는 방법이 몇 가지 있다.</p><ul><li>안전한 방법: 말을 함부로 하지 않는다.</li><li>더 안전한 방법: 먼저 행동하고 나서 말한다.</li><li>도전적인 방법: 말한 바를 어떻게든 지키려고 노력한다.</li></ul><p>제랄드 와인버그는 자기가 공부하고 싶은 주제가 생기면, 그 주제에 대해 발표하는 세미나 일정을 먼저 잡는다고 한다. 이런 시도가 몇 번 성공하면 자신감과 전문성이 더불어 엄청나게 상승할 것이다.</p><p>진짜 전문가는 자신이 말하는대로 행동한다. 거꾸로, 언행일치를 실천함으로써 전문성을 기를 수 있다. 도전적으로 언행일치를 실천하는 사람은 전문성을 기를 수 있는 환경에 스스로를 위치시킨 것과 같다. 나는 언행일치에 대한 글을 썼으니 이제 이 글대로 행동하기 위해, 언행일치를 실천하도록 두 배로 노력해야 하는 상황이 되었다. 즐거운 도전이다.</p><p>덧. 전문가의 또다른 특징은 <a href="https://medium.com/@kpak/훌륭한-팀원의-조건-strong-views-weakly-held-17880611d962">반대 의견을 인정</a>하고 거기로부터 <a href="http://egloos.zum.com/agile/v/3111334">성장할 수 있다</a>는 것이다. 즉 전문가는 말과 행동이 일치함과 동시에 사고는 유연하다. 언행일치와 유연함은 모순되지 않으며 오히려 상호보완적이다. ‘유연함과 전문성’에 대해서는 다음에, 내 전문성이 더 길러지면 써보자.</p><p><em>Originally published at </em><a href="https://spilist.github.io/2018/07/19/expertise-pattern-recursion"><em>spilist.github.io</em></a><em> on July 19, 2018.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f3991fd41ee4" width="1" height="1"><hr><p><a href="https://medium.com/steady-study/%EC%A0%84%EB%AC%B8%EC%84%B1-%ED%8C%A8%ED%84%B4-%EC%9E%AC%EA%B7%80-%EC%96%B8%ED%96%89%EC%9D%BC%EC%B9%98-f3991fd41ee4">전문성, 패턴, 재귀, 언행일치</a> was originally published in <a href="https://medium.com/steady-study">Steady Study</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[정리] Debug it! 실용주의 디버깅]]></title>
            <link>https://medium.com/steady-study/%EC%A0%95%EB%A6%AC-debug-it-%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%EB%94%94%EB%B2%84%EA%B9%85-f807d16ad76f?source=rss-c84770a5cabe------2</link>
            <guid isPermaLink="false">https://medium.com/p/f807d16ad76f</guid>
            <category><![CDATA[debugging]]></category>
            <category><![CDATA[reading]]></category>
            <category><![CDATA[software-development]]></category>
            <dc:creator><![CDATA[Hwidong Bae]]></dc:creator>
            <pubDate>Tue, 26 Jun 2018 00:00:00 GMT</pubDate>
            <atom:updated>2018-07-13T21:48:21.812Z</atom:updated>
            <content:encoded><![CDATA[<p><a href="http://www.acornpub.co.kr/book/debug-it">Debug It! 실용주의 디버깅</a> (원제: <a href="https://www.amazon.com/Debug-Repair-Prevent-Pragmatic-Programmers/dp/193435628X">Debug It!: Find, Repair, and Prevent Bugs in Your Code</a>)을 읽고 주요한 부분을 발췌 요약한다.</p><p>다 하고나니 ‘주요한 부분 요약’이라고 하기엔 너무 많이 정리했다. 다음부턴 이런식으로 책 정리를 하지 않아야겠다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/253/0*xYfR-7AAWmeM4Hnd.png" /></figure><p>1부는 ‘문제의 핵심’이다.</p><h3>1장. 구조적인 접근법</h3><p><strong>20p.</strong> 디버깅은 단순히 ‘버그를 없애는 것’ 그 이상이다. 효과적인 디버깅의 단계는 다음과 같다.</p><ul><li>소프트웨어가 왜 이상하게 작동하는지 알아낸다.</li><li>문제를 수정한다.</li><li>다른 곳이 깨지지 않게 한다.</li><li>코드의 전반적 품질(가독성, 구조, 테스트 커버리지, 성능 등)을 유지하거나 향상시킨다.</li><li>같은 문제가 다른 부분에는 없는지 살펴보고, 재발 방지책을 마련한다.</li></ul><p>이중 첫번째 항목인 ‘문제의 근본 원인을 찾아내기’가 무엇보다 중요하고 다른 항목의 주춧돌이 된다.</p><p><strong>23p.</strong> 이걸 더 간단하게 만들면 재현reproduce -&gt; 진단dignose -&gt; 수정fix -&gt; 반영reflect 이다.</p><p><strong>25p.</strong> 핵심 가이드라인.</p><ul><li>무엇을 찾으려는지 정확히 알고 나서 진행하라. 버그 리포트가 있더라도 그게 100% 옳다는 보장은 없다.</li><li>한 번에 한 문제만 해결하라. 하나를 잡으려다 다른 것에 영향을 미칠 수 있다.</li><li>혼자 하지 마라. 다른 팀원에게 ‘혹시 전에 이런거 본 사람?’ 이라고 질문하는 건 거의 비용이 안 들지만 엄청난 삽질을 막아줄 수 있다.</li></ul><h3>2장. 재현</h3><p><strong>30p.</strong> 버그 리포트에 적혀 있거나 암시된 방법을 그대로 따라해봐라. 버그 리포트에 충분한 정보가 담겨있지 않다고 ‘재현 불가능’ 딱지를 붙여 되돌리지 말고 그냥 해봐라. 노력도 별로 안들고, 실제로 문제가 바로 생길 수도 있다.</p><p><strong>31p.</strong> 성공적 재현은 제어에 달려있다. 제어해야 할 것은 다음 세 부분이다.</p><ul><li>소프트웨어 자체: 버전을 확인하라.</li><li>실행 환경: 특정 하드웨어나 원격 서버 등 외부 시스템과의 상호작용.</li><li>입력 값: 버그가 발생한 사용자의 설정과 똑같이 만들어라.</li></ul><p><strong>35p.</strong> 입력 제어를 위해 필요한 정보가 부족하다면 두 가지 방법을 선택할 수 있다. 입력 추론과 입력 기록.</p><ul><li>입력 추론: 문제가 실제로 있다고 가정하고, 그 문제가 발생하기 위해 필요한 조건을 역으로 생각해본다. 입력 범위의 경계값이나, 분기를 다르게 만드는 입력값을 위주로 실험해본다.</li><li>입력 기록: 로그로 사용자의 입력을 미리 기록해둘 수 있다. 로그는 유용한 도구지만 과용될 수 있기 때문에, <strong>항상 로그가 최신 코드를 반영하도록 하고 로그를 위한 로그는 남기지 말자</strong>. 소프트웨어에 직접 로그를 추가하지 않아도 클라이언트와 서버 사이의 로깅 프록시를 둠으로써 트래픽을 기록하면 많은 걸 얻을 수 있다. 실제 사용 방식을 로깅해두면 현실적인 스트레트 테스트를 하는 것에도 도움이 된다.</li></ul><p><strong>45p.</strong> 재현 방법 다듬기.</p><ul><li>피드백 루프 최소화: 실험할 때는 실험 방법을 최대한 효과적으로 만들자. 가장 짧으면서도 에러가 없는 수정-컴파일-실행-재현 주기를 만들어야 한다.</li><li>최대한 단순하게: 처음 찾은 재현 방법은 최적이 아닐 것이다. 재현에 불필요한 부분을 찾아 제거해야 한다. 이 때 분할 정복법이 도움이 된다.</li><li>필요 시간 최소화: 재현하는데 시간이 걸리는 버그 중 많은 것이 자원 누수 때문이다. 자원 누수가 의심스럽다면 미리 자원을 잡아놔서 빠르게 자원 고갈 상태를 만들거나, 자원 할당이 실패했을 때 작동하는 다른 함수를 가짜로 호출하여 재현 상태를 만들 수 있다.</li><li>비결정성 제거: 밑에서 설명.</li><li>자동화: 자동 테스트 프레임워크를 사용하라. 유저의 로그를 기록해뒀다가 재생하는 것도 좋은 방법이다.</li></ul><p><strong>49p.</strong> 재현에서 문제되는 것이 비결정적 버그다. 하지만 소프트웨어에 비결정성을 일으키는 원인은 몇 개 없다.</p><ul><li>초기화되지 않은 내부 상태: 디버거로 메모리를 특정 값으로 초기화해보자.</li><li>외부 시스템과 상호작용: 외부 시스템을 직접 제어하는 건 어렵다. 외부 시스템을 디버깅용 다른 시스템이나 테스트 대역(test double)으로 바꿔보자.</li><li>임의성: 대부분의 난수는 실제로는 유사난수다. 테스트할 때는 시드값을 동일하게 주자.</li><li>다중 스레드: 어렵다. 가능하다면 싱글스레드에서 실행하자. 강제로 스레드를 멈추는 sleep() 따위를 이용해야 할 수도 있다.</li></ul><p><strong>55p.</strong> 진단 과정 최적화 예시.</p><ul><li>대용량의 입력 파일을 통해 문제를 재현했다.</li><li>어떤 모듈이 연관되어있는지를 알아낸다.</li><li>입력 파일 요소 중 어디서 버그가 생기는지 잡아내 파일 용량을 줄인다.</li><li>서드파티 서버와 통신하는 서브시스템을, 항상 정해놓은 응답만 리턴하는 스텁stub으로 바꾸면 문제를 100% 재현할 수 있음을 알게 됐다.</li><li>정확히 어떤 함수가 문제인지 찾았다. 특정 파라미터로 이 함수를 호출해 버그를 재현하는 단위 테스트를 만든다.</li></ul><p><strong>56p.</strong> 버그를 정말로 재현할 수 없을 때 할만한 일들.</p><ul><li>정말 버그가 있는가? 실제로는 버그가 없을 수도 있다. 하지만 대부분은 모든 가능성을 따져보지 않은 것이다. 만약 <strong>이 버그에 대해서는 ‘재현 안 됨’ 같은 딱지를 붙이게 되더라도, 확실한 건 사용자가 어떤 다른 문제를 겪었었다는 것이다</strong>. 시간을 내서 사용자와 직접 의사소통해보자.</li><li>같은 영역에서 재현 가능한 다른 버그가 있다면 그것부터 고쳐보자. 이렇게 하면 1) 해당 영역 코드를 리팩토링할 기회가 생긴다. 2) 이 문제를 제거하고 나면 원래 찾던 문제를 더 명확히 볼 수 있다. 3) 재현 가능한 문제를 작업하다보면 관련 코드를 더 잘 이해할 수 있다.</li><li>다른 사람에게 조언을 구하자. 다른 개발자도 좋고, 테스트 팀도 좋고, 버그를 리포트한 사용자도 좋다.</li><li>사용자 커뮤니티를 활용하자. 특히 오픈소스 커뮤니티는 디버깅에 일반 사용자보다 훨씬 적극적으로 참여한다.</li></ul><h3>3장. 진단</h3><p><strong>61p.</strong> 디버깅할 때 가져야 하는 마음가짐은 범죄 수사나 과학 실험에 필요한 마음가짐과 비슷하다.</p><p><strong>64p.</strong> 실험할 때의 자세.</p><ul><li>실험은 무엇인가를 밝혀내야 한다. 이 실험으로 알 수 있는 결과가 진단에 도움이 되는가? 버그에 대한 핵심 가설을 세우고 그것을 증명/반증하기 위한 실험을 하라.</li><li>한 번에 하나만 고쳐라. 조작변인 때문에 통제변인이 변했다는 인과관계가 확실해야 한다. 한 번에 여러 개를 고치면 시간을 절약할 수 있을 것 같지만 실제로는 실험 결과를 망칠 위험만 키운다. <strong>고친 것으로 작동이 변한 것을 확인했다면, 다시 고친 것을 원래대로 되돌려보고 작동도 원래대로 돌아가는지 검증하라.</strong></li><li>시도한 것을 기록하라. 뭘 했는지 까먹지 않을 정도로만. 가끔씩 지금까지 해봤던 것들돠 거기에서 배운 점들을 복습하자.</li><li>아무것도 무시하지 말라. 작동이 이상할 때는 무시하지 말고 멈춰라. 소프트웨어가 뭔가 이야기해주려고 하고 있다. 예상치 못한 일이 생겼다는 건 가설에 틀린 곳이 있다는 뜻이다. 틀린 곳을 찾아라.</li><li>뭐든지 우리가 이해하지 못한 부분은 잠재적 버그다. 현재 버그와 관련이 없음을 확인하고 나면, 그런 부분은 한쪽에 치워놓되 기록해놓고 까먹지 말자. 우연히 발견한 것들이 꼭 수정해야 할 문제일 때가 많다.</li></ul><p><strong>69p.</strong> 문제 원인을 찾는 기법들.</p><ul><li>진단 코드instrumentation: 소프트웨어 작동에는 영향을 끼치지 않으면서 왜 그렇게 작동하는지에 대한 통찰을 제공하는 코드. 가장 중요한 진단 코드는 로그다. 언어에서 제공하는 기능을 최대한 활용하여, 데이터를 분석하고, 조건을 테스트해보자. 진단 코드는 디버그 후에 제거하는 경우가 많은데, 때로는 진단 코드를 사용하여 ‘스스로를 디버깅하는 소프트웨어’로 만들 수도 있다. 이건 추후에 설명.</li><li>분할 정복: 소스코드 일부를 주석처리하거나, 한 부분에 검사 코드를 넣어놓거나 해서 탐색 범위를 줄인다. 소프트웨어가 모듈화되어있고 모듈을 껐다 켰다 할 수 있다면 그걸로도 탐색 가능하다. git 커밋을 옮겨다닌 것으로도 가능.</li><li>사람에게 배우기: 같은 팀원에게 물어보고, 검색하라.</li><li>오캄의 면도날: 여러 가능성 중 뭘 먼저 확인할지 선택해야 한다면 가장 간단한걸 먼저 확인하라.</li></ul><p><strong>77p.</strong> 실제 디버깅하면서 자주 하는 실수들.</p><ul><li>맞는 걸 고치고 있는가? 혹시 고친 파일이 아닌 다른 파일을 컴파일한 것 아닌가? 컴파일 제대로 해놓고 다른 바이너리를 실행한 것 아닌가? … 이런 함정은 의외로 흔하다. 무조건 프로그램이 죽게 되거나 그에 준하는 명백한 실패 코드를 추가하면 내가 맞는 걸 고치고 있는지 알 수 있다.</li><li>잘못된 가정이 있지 않은가? 뭔가에 가로막혀 있다면 내가 어떤 가정을 세우고 있는지 다시 비판적으로 점검하자.</li><li>원인이 여러 개는 아닌가? ‘이건 도저히 말이 안 되는데’ 라는 생각이 들면 이 가능성을 의심해봐야 한다. 원인이 여러 개이면 문제를 격리하여 하나의 원인에만 의존하는 버그를 재현하는 방법을 찾는다. 또는, 같은 영역에 있는 것으로 추측되는 다른 버그를 먼저 확인한다.</li></ul><p><strong>82p.</strong> 디버깅에 도움이 되는 기법들.</p><ul><li>다른 사람에게 도움 요청하기: 문제를 설명하다 보면 생각 정리에 도움이 된다.</li><li>역할극: 여러 독립 시스템끼리 상호작용하는 문제를 설명하고 검사하기 좋다.</li><li>문제 묵혀두기: 때론 잠재의식에게 맡긴 채 휴식하는 것도 필요하다. 쉬다가 뭔가가 떠올랐을 때는 잘 기록해둔다. 다만 너무 오래 쉬지는 말자.</li><li>아무거나 바꿔보기: 정말 감이 안 올 때는 아무거나 바꿔보고 예상 결과와 다르게 나오는 걸 찾아본다.</li><li>셜록 홈즈 법칙: 불가능한 것을 전부 제거하고 나면 아무리 불가능해 보이는 것이라고 남아있는 것이 진실이다.</li></ul><h3>4장. 수정</h3><p><strong>92p</strong>. 목표는 세 가지다. 문제 수정, 회귀 방지, 코드의 전반적 품질을 유지하거나 향상시키기.</p><p><strong>94p.</strong> 기본적인 프로세스.</p><ul><li>기존 테스트를 실행해서 모두 통과하는지 확인한다.</li><li>새 테스트를 추가하거나 기존 테스트를 수정해 버그를 보여준다(즉 실패시킨다).</li><li>버그를 수정한다.</li><li>제대로 수정했는지 확인한다(실패하던 테스트가 이제 실패하지 않는다).</li><li>회귀가 생기지 않음을 확인한다(이전에 성공하던 테스트가 모두 성공한다).</li></ul><p><strong>96p.</strong> 증상이 아닌 원인을 고친다.</p><ul><li>버그가 아키텍처 깊숙히 있거나, 제대로 고치려면 광범위하게 수정해야 하는데 위험할 때, 또는 하위 호환성이 깨질것 같을 때 등 ‘땜질 코딩’의 유혹에 빠지고 싶을 때가 많다. 하지만 근본 원인을 고치지 않을 때마다 코드의 전반적 품질이 확 떨어지며, 이는 깨진 유리창을 더 만들어내는 효과도 있다. 근본 원인을 고치지 않는 것이 적당할 때도 있지만 항상 최후의 수단으로만 생각해야 한다.</li><li>눈앞에 있는 문제를 고치는 것은 3가지 목표중 하나일 뿐이다. 회귀도 막아야 하고, 품질도 유지해야 한다. 근본 원인을 모른 채 수정하면 굉장히 무모한 일이다.</li></ul><p><strong>100p.</strong> 버그가 있는 코드를 작업하고 있다는 것 자체가 이 코드에는 좀 더 이해하기 쉽게 개선할 가능성이 높음을 의미한다. 리팩토링은 버그 수정만큼이나 중요하다. 하지만 버그 수정을 포함한 기능 변경은 리팩토링과 같이 하면 절대 안 된다. 그렇게 하면 리팩토링을 잘못한 것인지 기능이 변경되어 테스트 결과가 바뀌는 것인지 알 수 없기 때문이다.</p><h3>5장. 반영</h3><p><strong>109p.</strong> 근본 원인 분석: <strong>어떤 버그가 코드 안에 들어갈 수 있었다는 사실을 개발 프로세스의 어딘가에 무엇인가가 잘못됐다는 것을 보여준다.</strong> 정확히 언제? 왜?</p><ul><li>요구사항: 요구사항이 애매하거나, 이상하게 해석되거나, 잘못 이해되지는 않았는가?</li><li>설계: 아키텍처나 설계에서 놓친 점은 없는가? 고려하지 못한 점, 허용해야 했던 부분은 없는가? 설계는 괜찮은데 구현을 제대로 못한 것은 아닌가?</li><li>테스트: 해당 영역에 대한 테스트가 충분했는가? 테스트 자체에 문제는 없었나?</li><li>구현: 코드를 작성하는 데 실수가 있었는가? 기초 기술의 어떤 부분을 잘못 이해하고 있었나?</li></ul><p><strong>110p.</strong> 재발 방지하기</p><ul><li>문제가 많이 생기는 영역, 자주 실수하는 부분, 같은 문제의 다른 예 등을 주의깊게 살핀다. 실수가 여기 하나에만 있을까? 다음에 다시 실수하지 않게 강제하는 방법은 없을까?</li><li>문제가 반복해서 발생한다면 코드 구조나 인터페이스 때문일 수 있다.</li><li>프로세스를 개선해보자. 요구사항 문서의 품질을 살피는 단계나, 설계 검토 과정을 도입해야 할 수도 있다. 코드 리뷰를 할 때 ‘자주 하는 실수 목록’을 보고 하게 하는 것도 좋다.</li></ul><p>2부는 ‘큰 그림’에 대해 다룬다.</p><h3>6장. 문제 발견</h3><p><strong>121p.</strong> 좋은 버그 리포트에는 무엇이 들어있을까?</p><ul><li>상세하고, 분명하며, 구체적이어야 한다. 진단해보기 전에는 어떤 정보가 관련있는지 알 수 없기 때문에 좋은 버그 리포트에는 필요한 것 이상으로 많은 정보가 담겨 있다.</li><li>동시에 최대한 작고 유일해야 한다. 버그 재현에 꼭 필요한 정보만 담겨 있는 것이 좋다. 그리고 기존에 리포트된 버그라면 (새로 리포트를 만드는 게 아니라) 기존 리포트에 정보가 추가되어야 한다.</li><li>환경과 설정 정보를 자동으로 수집해야 한다.</li></ul><p><strong>126p.</strong> 대부분의 고객은 뭐가 잘못되더라도 아무 얘기도 안해줄 것이다. 자기가 잘못했다고 생각할 수도 있고, 그냥 속으로 욕하며 소프트웨어를 재시작할 수도 있다. 간단한 버그를 피해가는 꼼수를 찾는다고 몇 시간을 쓸 수도 있다. 한 명이 버그를 리포팅했다면 같은 문제를 겪고도 아무 말 안하는 사람이 10~100명은 있다고 봐야 한다.</p><p><strong>127p.</strong> 사용자의 멘탈 모델은 개발자의 멘탈 모델과 엄청나게 다르다. 사용자 입장에서 어떻게 보일지 생각해보자. 우리가 신뢰할 수 있는 ‘고객의 관찰’과, 고객의 멘탈 모델로부터 영향을 받은 ‘고객의 해석’을 분리할 수 있어야 한다.</p><p><strong>129p.</strong> 사용자가 버그 트래킹 시스템을 쓸 수 있게 하자. 이 방법의 장점은:</p><ul><li>다른 사람의 리포트를 진지하게 받고, 대응해주고, 결국 해결하는 모습을 보여주어 다른 사용자들도 버그 리포트 작성이 헛되지 않으리라는 확신을 받는다.</li><li>버그 리포트 전에 검색할 수 있게 하면 중복 리포트된 버그가 훨씬 줄어든다.</li><li>다른 사람의 버그 리포트를 읽은 사용자가 문제를 해결할 수 있는 중요한 기억이나 통찰을 떠올릴 수 있다.</li><li>버그 리포트 형식을 잘 모르는 사람이 다른 사람의 것을 보고 학습할 수 있다.</li></ul><p><strong>132p.</strong> QA와 고객지원 팀을 존중하고, 협력하라. 때론 그 안에서 일해보면서 고객의 소리를 직접 느껴봐라.</p><h3>7장. 실질적인 무관용</h3><p><strong>135p.</strong> 빠른 버그 수정은 늦은 버그 수정보다 훨씬 좋은 전략이다. 다음 2가지 원칙에 따른다.</p><ul><li>개발하는 동안 버그를 찾을 수 있는 과정(테스트, 코드 리뷰, 배포)을 계속 반복한다.</li><li>버그 수정의 우선순위가 가장 높다.</li></ul><p>이렇게 하는 목적은 소프트웨어에 있는 버그 갯수를 최대한 작게 유지하는 것이다. 이는 소프트웨어의 불확실성을 줄여준다. 버그를 찾아보기 전에는 발견 안 된 버그가 얼마나 남아있는지 알 수 없으며, 실제로 고쳐보기 전에는 얼마나 걸리는지도 알 수 없다. 따라서 일정 조정이 어렵다. <strong>버그를 나중에 고치다 보면 겉보기에는 진도가 잘 나가는 것처럼 보이겠지만 사실은 기술 부채만 늘어나게 된다.</strong></p><p><strong>137p.</strong> 버그를 고치는 데 걸리는 시간 추정하기.</p><ul><li>기본적으로는 불가능하다. 진단이 끝나고 나면 수정에 얼마나 걸릴지 추정할 수 잇겠지만, 대부분의 버그가 진단하는 데 가장 시간이 오래 걸리기 때문에 큰 의마가 없다.</li><li>하지만 지금까지 고친 버그에 대한 통계 자료를 만들 수는 있다. 지난 주에 평균 20개의 버그를 잡았다면 이번 주도 그러리라 예상하는 것. 실제 버그 수정이 얼마나 걸렸는지를 측정해두고 나중에 예측할 때 자료로 삼는다.</li></ul><p><strong>138p.</strong> 깨진 창문 없애기.</p><ul><li>소프트웨어를 작성하고 유지보수하는 것은 엔트로피와의 끝없는 전쟁이다.</li><li>낮은 품질은 전염되기 쉽다. 유일하면서 확실한 치료법은 버그를 발견하자마자 근절하는 것이다.</li><li>목표는 항상 버그의 갯수를 0에 가깝게 유지하는 것이다. 이런 접근법을 <strong>깨진 창문 없애기</strong>라고 한다.</li><li>스프린트로 지친 개발자에게 깨진 창문 없애기 정책을 따르기란 불가능하게 보일 수도 있다. 하지만 버그를 최대한 빨리, 개발 첫 날부터 찾는다면 절대 불가능하지 않다. 그렇게 하면 남아있는 버그(= 알고 있는 버그 + 잠재적 버그)의 갯수가 걷잡을 수 없이 늘어나는 일은 없을 것이다.</li></ul><p><strong>139p.</strong> 디버깅의 마음가짐.</p><ul><li>한쪽 극단에서는 버그를 피할 수 없는 것으로 받아들이고 두려워하지 말자고 한다. -&gt; 버그를 허용해버리게 된다.</li><li>반대쪽 극단에서는 버그를 완벽하게 없애기 위해 노력한다(무관용, Zero tolerance). -&gt; 사실상 불가능하다. 그리고 피할 수 없는 버그가 나올 때마다 실패한 것처럼 느끼게 될 수도 있고, 비난하는 문화가 생길 수도 있다.</li><li>가장 생산성이 좋은 마음가짐은 <strong>실질적 무관용</strong>이다. 굉장히 무관용에 가깝되 실용주의를 가미한 것이다.</li><li>버그 없는 소프트웨어를 <strong>달성할 수 있는 궁극적 목표</strong>로 두고, 목표에 다가갈 수 있게 최대한 노력한다. 버그가 생겼다면 교훈을 얻어 재발하지 않게 할 수 있는 행동을 다한다. 하지만 이 동안에도 얼마나 궁극적 목표에 가깝게 도달할 수 있는 것인지에 대한 현실적 견해를 유지해야 한다.</li><li>목표에 도달하지 못했다고 해서 자책하거나 책임 소재를 따지면 안된다. 어떤 버그는 피할 수 없다는 것을 알고, 버그가 있더라도 최대한 소프트웨어가 견고하게 실행될 수 있게 만들어야 한다.</li></ul><p><strong>141p.</strong> 품질 결함의 수렁에서 빠져나오기. 엄청나게 버그가 많은 코드에서, 어떻게 하면 빠져나올 수 있을까? 우선, 즉효약은 없다. 시간과 노력, 헌신이 필요하다. 가장 확실한 해결책은 모든 작업은 품질 문제가 해결된 다음에만 진행될 것이라고 선언하는 것이다. 하지만 이런 순간은 오지도 않을 뿐더러 어떤 조직도 좋아하지 않을 것이다. 그러면 어떻게 해야 할까.</p><ul><li>더 나빠지지 않게 하기: 기존의 모든 코드를 표준에 맞추진 못하더라도, 새로 작성하는 코드는 표준에 맞게 한다. 만약 시초가 서있지 않다면 기초부터 세운다. 기초란 소스 관리 시스템, 빌드 자동화, 테스트 자동화, 일일 빌드 및 통합/배포 시스템을 뜻한다.</li><li>더러운 코드로부터 깨끗한 코드 격리하기: 잘 작성되고 테스트가 잘 되어있는 코드와 ‘더러운’ 코드 사이의 경계를 분명하게 해준다. 그리고 기회가 날 때마다 이런 경계를 오래된 코드에까지 넓힌다. 오래된 코드를 작업할 때는 수정 중인 버그나 그 외 건드린 것에 대해 테스트를 작성한다.</li><li>버그 선별: 버그 목록을 검토하고, 버그가 미칠 수 있는 영향을 공유하고, 적당한 우선순위를 매긴다.</li><li>버그 대청소: 상대적으로 짧은 기간 동안 팀 전원이 다른 일은 다 제쳐두고 버그만 잡는다. 우선순위와 상관없이 최대한 버그를 많이 잡는 게 목적이다.</li></ul><p><strong>146p.</strong> 테스트가 없는 코드를 리팩토링하는 방법: 없다. 먼저 테스트를 작성하자.</p><p>3부는 ‘디버깅 비급’이다.</p><h3>8장. 특수한 경우</h3><p><strong>151p.</strong> 기존 릴리즈를 패치하는 핫픽스를 낼 때는, 근본 원인을 고치는 것보다는 리스크를 줄이는 데 집중한다. 이 때는 개발 버전에 있는 버그도 고쳐야 하는데, 개발 버전에서는 똑같이 버그를 픽스하는 게 아니라 근본적인 원인을 찾아 고쳐줘야 한다.</p><p>핫픽스가 일상처럼 벌어진다면 이런 문제가 있을 수 있다. 프로세스를 바꾸자.</p><ul><li>릴리즈 사이의 기간이 너무 긴 것 아닌가?</li><li>이전 릴리즈에서 ‘안 넘어오는’ 사용자가 있는 것 아닌가? 이 사용자들이 업그레이드하게 만드려면 무엇을 해야 할까?</li><li>버그가 너무 많아 대처하기 어려운 것이라면 품질 결함의 수렁에서 빠져나오기를 참고.</li></ul><p><strong>153p.</strong> 수정하려는 부분에서 호환성 문제가 생길 수 있을 때, 높은 품질로 문제를 고치는 것과 동시에 하위 호환성 문제로 발생하는 고통을 최소화해야 한다. 이는 동시에 충족하기는 어렵고, 결국은 타협해야 하는데 어떻게 타협하는 게 좋을까.</p><ul><li>마이그레이션 방법을 제공한다.</li><li>호환성 모드를 구현한다. 이건 유저와 개발자 모두에게 비용이 많이 드는 해결책이다.</li><li>곧 deprecate된다는 것을 사전에 경고한다.</li><li>버그를 고치지 않는다. 좋진 않지만 가끔은 이게 실용적일 때도 있다.</li></ul><p><strong>158p.</strong> 병렬 소프트웨어의 버그를 고치기.</p><ul><li>스레드 간의 상호 작용을 간단하게 유지한다. 스레드가 잘 정의된 몇 가지 방법으로 잘 정의된 위치에서만 상호작용한다면 디버깅할 때도 똑같이 보장하기가 쉽다.</li><li>병렬 소프트웨어의 버그 대부분은 아주 ‘일반적’이지만, 진단할 때 병렬성 때문에 진단이 어렵다. 따라서 어떻게든 스레드를 하나로 제한하든지 해서 소프트웨어가 병렬이 아니게 빌드할 수 있으면 좋다.</li><li>sleep() 으로 병렬 문제를 해결하려고 하지 말자. 이런 건 대부분 문제를 숨겨서 오히려 근본적 원인을 해결하기 어렵게 만든다.</li></ul><p><strong>161p.</strong> 하이젠버그 는 진단하려고만 하면 재현이 안되는 버그를 말한다. 소프트웨어의 작동을 검사하는 모든 기법은 어느 정도는 소프트웨어에 영향을 준다. 적용한 기법이 어떻게 영향을 주는지 알고 있다면 다른 방법을 써서 영향을 최소화하는 수밖에 없다.</p><p><strong>164p.</strong> 성능 버그. 성능 문제를 푸는 핵심은 다른 버그와 마찬가지로 근본 원인을 찾는 데 있고, 대부분의 근본 원인은 전체 성능을 제한하는 일부 병목에 있다. 따라서, 성능 버그를 찾는 데 가장 뛰어난 도구는 프로파일러다. 진단하기 전에 코드를 프로파일링하자.</p><p>프로파일러도 다른 도구와 마찬가지로 소프트웨어 동작에 영향을 미치기 때문에, 다음을 지켜야 한다.</p><ul><li>가능한 한 실제 제품과 비슷하게 빌드해 프로파일링한다. 최적화 수준도 같게 만들어야 한다.</li><li>소프트웨어 실행 환경을 실제 제품의 실행 환경과 비슷하게 만든다.</li><li>실제 데이터와 비슷한 데이터로 소프트웨어를 실행한다.</li></ul><p>병목이 안 보인다면 전체적으로 성능에 영향을 미치는 요인을 살펴봐야 한다.</p><ul><li>메모리 등의 자원 고갈</li><li>가비지 컬렉션</li><li>캐시 미스</li></ul><p><strong>170p.</strong> 서드파티 소프트웨어 버그.</p><ul><li>서드파티에도 버그가 있을 가능성은 충분히 있지만 너무 빨리 비난하진 말자. 서드파티 코드는 사용자도 훨씬 많고 훨씬 테스트도 잘 되어있을 것이다. 따라서 <strong>우리 코드를 먼저 의심하자.</strong></li><li>서드파티 코드에 버그를 찾았다면 1) 문제를 보고하거나 2) 직접 패치할 수 있을텐데, 직접 패치를 하면 그 뒤부터 해당 서드파티 코드의 업데이트를 따라가기 쉽지 않을 수 있다. 당장은 문제를 우회하고, 장기적으로 서드파티 코드의 정식 릴리즈에 수정 사항이 포함되도록 보고하는 게 좋다.</li></ul><h3>9장. 이상적인 디버깅 환경</h3><p>내용이 오래됐거나, 내가 잘 알고 있거나, 이미 자동으로 도와주는 소프트웨어를 쓰고 있기 때문에 패스.</p><h3>10장. 소프트웨어가 스스로를 디버깅하게 만들기</h3><p><strong>197p.</strong> 좋은 설계와 디버깅하기 좋은 구조는 서로 충돌하지 않는다. 관심의 분리, 중복 금지, 정보 은닉 같은 일반적으로 좋은 소프트웨어 개발 원칙을 따랐다면 소프트웨어의 구조가 잘 잡혀있고 이해하기 쉬우면서 디버깅하기도 쉬울 것이다.</p><p><strong>198p.</strong> 단언문 사용하기 (assert)</p><ul><li>단언문은 단위 테스트와 상호보완적이다. 단위 테스트는 테스트에서 호출하지 않는 버그는 찾을 수 없다. 단위 테스트는 정기적으로 모든 단언문을 실행시켜보는 방법이라고 생각할 수도 있다.</li><li>소프트웨어가 특정 조건이 되었을 때 제대로 동작하지 않는 게 확실하다면, 단언문을 사용해 그 조건에서 소프트웨어가 종료되게 만들고 적절한 에러 메시지를 띄울 수 있다. 즉 소프트웨어가 스스로를 디버깅하게 된다.</li></ul><p><strong>203p.</strong> 단언문으로 체크해야 하는 것들. -&gt; 사실 전부 테스트다.</p><ul><li>선행조건: 메소드가 기대하는 작동을 하기 위해 호출 전에 맞춰줘야 하는 것.</li><li>후행조건: 메소드가 호출된 후에 보장되어야 하는 것.</li><li>불변식: 어떤 상황에서도 참이어야 하는 것.</li></ul><p>이 3가지에 대해 단언문으로 작성한다면 광범위한 버그를 알아서 잡아내는 소프트웨어를 만들 수 있다.</p><p>단언문은 개발 환경에서만 사용되어야 한다. 단언문이 사용된 채 프로덕션에 나가면 간단한 오류에도 소프트웨어가 죽어버린다. 프로덕션 소프트웨어는 방어적 프로그래밍을 이용해 fault tolernt하게 작성되어야 한다.</p><p><strong>205p.</strong> 방어적 프로그래밍: 버그가 있을 때도 어느정도 올바르게 작동하게 하는 것.</p><ul><li>방어적 프로그래밍은 양날의 검이다. 방어적 프로그래밍을 하면 디버깅하기가 어려워진다.</li><li>프로덕션에서는 견고하고, 디버깅할 때는 잘 깨지는 코드가 좋은 코드다.</li><li>방어적 코드를 단언문으로 보호한다면, 그리고 단언문을 개발 모드에서만 켠다면, 디버깅할 때는 잘 깨지고 프로덕션에서는 견고한 코드를 만들 수 있다.</li></ul><p><strong>209p.</strong> 단언문을 사용할 때 피해야 할 두 가지.</p><ul><li>사이드 이펙트가 있는 단언문</li><li>버그 대신 에러를 찾고 처리하는 데 사용되는 단언문</li></ul><h3>11장. 안티 패턴</h3><p><strong>225p.</strong> 우선순위 인플레이션: 버그 우선순위를 정하고 나서, 버그가 너무 많다 보니 아무도 우선순위의 최고 레벨이 아니고서는 신경쓰지 않는다. 그래서 그보다 더 높은 우선순위를 만들어내게 된다.</p><ul><li>이럴 때는 주기적으로 버그를 제거하고, 검토하면서 버그의 우선순위가 상황을 반영하는지 확인해야 한다.</li><li>사용자가 버그 우선순위를 제어하는 게 아니라, 엄격한 과정을 통해 우선순위를 선별한다.</li><li>우선순위 숫자는 없애버리고, 버그가 우선순위별로 정렬되게 하자.</li></ul><p>결국에는, 품질 문제를 해결하는 것만이 유일하면서 진정한 해결책이다.</p><p><strong>227p.</strong> 프리마돈나: 누군가가 개발 프로세스를 무시하고 대충 코드만 짜서 던지고 있다면?</p><ul><li>‘확실하게 끝내야 끝’임을 분명히 한다. 즉, 모든 기능은 작동, 테스트, 검토, 문서화 등의 모든 과정을 통과해야 끝난 것이다.</li><li>큰 작업을 작고 구체적인 작업으로 나눈다.</li><li>누구든 버그를 만든 사람이 버그를 수정하는, 오염자 부담 원칙을 도입한다. 프리마돈나가 작업한 부분에 버그가 있다면 그가 어떤 중요한 작업을 하고 있었든지 그 버그를 잡도록 하고, 프리마돈나가 하던 일은 다른 사람에게 넘긴다.</li></ul><p><strong>232p.</strong> 화재 진압은 심각한 문제가 쌓여있어서, 불길이 다른 곳으로 번지기 전에 재빨리 끄는 상태를 얘기한다. 하지만 너무 자주, 또는 오랫동안 화재 진압이 지속된다면 문제가 된다. 화재 진압은 절대 품질 문제를 근본적으로 해결하지 못한다. 1주일간 화재 진압을 해도 품질 문제가 해결되지 않는다면 단기적 결과에 더이상 연연하지 않고 근본 문제를 고쳐야 할 수 있다.</p><p><strong>233p.</strong> 때로는 지저분한 코드를 다 버리고 완전히 새로 작성하고 싶은 유혹에 빠질 수도 있다. 그러나 지금 코드의 구조도 안 좋고, 테스트나 문서화가 제대로 작성되지 않았더라도, 꽤 오랫동안 시장에 나가 있었다면 대부분의 경우에는 제대로 실행될 것이다. 즉, 문제 도메인에 대한 엄청난 (코드가 실행되게 하는) 지식이 코드 안에 암묵적으로 들어있을 것이다. 소프트웨어를 재작성할 때 조심하지 않으면 과거에 겪었던 문제를 하나씩 다시 해결해야 할 수도 있다.</p><ul><li>비용 대비 효과를 꼼꼼히 따져보자.</li><li>효과가 있다고 판단했더라도, 빅뱅 식으로 한번에 고치려고 하지 말고 점진적으로 코드를 다시 작성할 방법을 찾아보자.</li><li>기존 코드에 대해 테스트하고, 새로 작성한 코드에서도 그 테스트가 통과하는지 검증하자.</li></ul><p><em>Originally published at </em><a href="https://spilist.github.io/2018/06/26/debug-it-excerpt"><em>spilist.github.io</em></a><em> on June 26, 2018.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f807d16ad76f" width="1" height="1"><hr><p><a href="https://medium.com/steady-study/%EC%A0%95%EB%A6%AC-debug-it-%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%EB%94%94%EB%B2%84%EA%B9%85-f807d16ad76f">[정리] Debug it! 실용주의 디버깅</a> was originally published in <a href="https://medium.com/steady-study">Steady Study</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[디버그를 디버깅하기: 단계적 디버깅 프로세스 템플릿]]></title>
            <link>https://medium.com/steady-study/%EB%94%94%EB%B2%84%EA%B7%B8%EB%A5%BC-%EB%94%94%EB%B2%84%EA%B9%85%ED%95%98%EA%B8%B0-%EB%8B%A8%EA%B3%84%EC%A0%81-%EB%94%94%EB%B2%84%EA%B9%85-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%ED%85%9C%ED%94%8C%EB%A6%BF-d3d4a9882adb?source=rss-c84770a5cabe------2</link>
            <guid isPermaLink="false">https://medium.com/p/d3d4a9882adb</guid>
            <category><![CDATA[debugging]]></category>
            <category><![CDATA[problem-solving]]></category>
            <category><![CDATA[software-development]]></category>
            <dc:creator><![CDATA[Hwidong Bae]]></dc:creator>
            <pubDate>Mon, 11 Jun 2018 00:00:00 GMT</pubDate>
            <atom:updated>2018-06-25T07:05:40.860Z</atom:updated>
            <content:encoded><![CDATA[<p>오래되고 기능이 많은 레거시 소프트웨어를 관리하는 조직에서, 신규 기능을 추가하기보다는 여기저기서 터져나오는 문제를 해결하는데 시간을 훨씬 많이 쓰게 되는 경우가 있다. 특히 프로젝트 초기에 좋은 시스템 구조가 설계되지 않았거나, 프로젝트 도중 적절한 리팩토링을 거치지 않았거나, 또는 테스트 코드가 마련되지 않은 상태에서 개발이 진행되다 보면 그리 오랜 시간이 지나지 않아 이런 상황에 빠지기 쉽다. 이런 조직이 다시 개발 생산성을 높이기 위해서는 문제가 생겼을 때 단순히 그 문제를 빠르게 해결하기보다는 좀더 체계적인 방법으로 디버깅을 해야 한다. 그러면 어떻게 디버깅을 체계적으로 할 수 있을까. 그 고민의 결과물을 공유한다.</p><h3>디버깅은 단순히 버그를 없애는 것이 아니다</h3><p><a href="https://en.m.wikipedia.org/wiki/Software_bug">위키피디아</a>에 따르면 ‘버그’는 1870년대부터 기계적 결함을 나타내는 용어로 쓰여왔다. 컴퓨터 영역에서는, 1940년대에 초창기의 컴퓨터 <a href="https://en.m.wikipedia.org/wiki/Harvard_Mark_II">하버드 마크 II</a>가 패널에 나방이 끼는 바람에 오작동한 사건을 기록한 것에서부터 ‘버그Bug’와 ‘디버깅Debugging’이라는 용어가 널리 쓰이기 시작했다고 한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/500/0*4a3BItTFM6HWrjr6.jpg" /><figcaption><em>최초로 기록된 컴퓨터 버그.</em></figcaption></figure><p>나는 이 <strong>디버깅</strong>이라는 단어 자체가 일종의 함정을 지니고 있다고 느낀다. 디버그라는 말을 들었을 때 가장 쉽게 연상되는 뜻은 de + bug, 즉 버그를 없앤다는 것이다(실제로 최초의 버그는 패널에 낀 나방을 제거함으로써 해결하긴 했을 것이다). 그래서인지 개발 경험이 적을수록 디버깅할 때 버그를 없애는 것에만 집중하는 경향을 보이는 듯하다. 존경하는 개발자인 <a href="https://wonderer80.github.io/">김정훈</a> 님으로부터 몇년 전 이런 얘기를 듣기 전까지 나도 그런 개발자였다.</p><blockquote><em>훌륭한 개발자는 버그를 대하는 태도가 다릅니다. 버그를 만났을 때 일반적인 개발자는 짜증내며 빠르게 고치려고만 합니다. 훌륭한 개발자는 버그를 만나면 버그가 생길 수밖에 없었던 근본적 원인을 생각해보고 리팩토링하는 기회로 삼습니다.</em></blockquote><p>당시 수많은 함수들이 들어있는 general.js 에서 이해할 수 없는 문제가 생겨서, console.log를 무작정 찍어가며 디버깅하던 나를 보며 말씀하셨던 걸로 기억한다. 결국 찾아낸 문제의 원인은 변수명의 오타였다. 정훈님은 오타를 고치는 게 아니라 파일명, 변수명을 비롯한 코드 구조 자체를 바꿔야 한다고 말씀하셨다. 이런 근본적인 문제가 해결되어야 나중에 비슷한 문제가 생길 가능성이 줄어든다면서.</p><p>‘버그가 생길 수밖에 없었던 근본적 원인을 찾아 개선한다’는 말은 내 머릿속에 깊이 새겨졌고, 이 말을 내 안에서 오랫동안 숙성시켜 나만의 디버깅 템플릿을 만들어봤다. 이 템플릿은 기본적으로는 유저가 리포트한 버그를 고치는 것을 가정하여 만들었지만, ‘버그’는 결국 ‘구현한 기능이 의도대로 동작하지 않는다’는 것이고, 따라서 일반적으로 개발할 때 겪는 문제에 대해서도 적용할 수 있다. 디버깅 과정을 <strong>현상</strong>, <strong>문제 원인</strong>, <strong>해결책</strong>, <strong>환경 개선</strong>의 네 단계로 나누는 것에서부터 시작한다.</p><h3>1. 현상</h3><p>유저 레벨에서 버그를 바라보며 명확한 재현 조건을 찾는다. 문제에 대해 실패하는 테스트 케이스를 만들어낸다고 생각하면 된다. “이런 조건에서(Given) 이런 액션을 했을 때(When) 이런 예상 결과가 나와야 하는데 실제 결과는 이랬다(Then).”와 같은 문장을 도출해낸다.</p><p><strong>1–1. 누가, 어디서, 어떤 문제 현상을 겪었는가?</strong></p><p>에러 리포트를 기반으로 최초의 테스트 케이스를 만들어내기 위한 질문이다. 웹 프론트엔드 영역에서는 아래와 같이 바꿀 수 있다. 실제로 문제를 겪은 사람의 리포트 링크, 문제 상황 스크린샷, 에러 로그 등의 데이터는 따로 기록해둔다.</p><ul><li>누가: 유저의 권한이 무엇인가?</li><li>어디서: OS 버전은? 브라우저 버전은? 배포된 앱 버전은? 네트워크 환경은? 어느 페이지에서?</li><li>문제 현상: 어떤 액션을 수행했는가? 이 때 예상 결과는 무엇이었는가? 실제 결과는?</li></ul><p><strong>1–2. 현상이 발생하는 조건은 무엇인가?</strong></p><p>테스트 케이스의 완성도를 높이는 질문이다. 문제 액션을 고정한 채 다른 조건들을 바꿔보면서, 문제가 어떨 때 생기고 어떨 때 생기지 않는지를 관찰하며 재현 조건을 찾는다. 명확한 재현 조건 없이는 해결책을 적용한 뒤에도 문제가 해결됐는지를 확신할 수 없다.</p><ul><li>‘누가’를 바꿔본다. 다른 권한의 유저에게도 발생하는가?</li><li>‘어디서’를 바꿔본다. 다른 OS, 다른 브라우저, 다른 앱 버전에서도 발생하는가? 네트워크 환경이 바뀌면 어떤가?</li><li>문제 액션을 실행하기까지의 플로우를 바꿔본다. 문제 액션 이전에 어떤 액션을 했느냐에 따라 달라지는 앱의 상태도 조건의 일부다.</li><li>비슷한 액션인데 문제가 발생하지 않는 상황, 그리고 비슷한 문제가 다른 조건에서 발생하는 상황은 없는지 탐색한다.</li></ul><h3>2. 문제 원인</h3><p>실패하는 테스트 케이스를 만들어냈으므로, 내 코드의 어디가 어떻게 문제라서 실패하는지를 찾아낸다.</p><p><strong>2–1. 코드상에서 문제를 일으키는 부분이 어디인가?</strong></p><p>문제를 일으키는 코드를 포착하려면 내 코드에서 어떤 부분이 문제에 영향을 주고 어떤 부분은 영향을 주지 않는지를 알아내야 한다. 문제 액션에 관련된 코드의 범위를 줄여나가면서 정확히 어디가 문제인지 찾는다.</p><p>재현 조건이 명확한데도 문제를 일으키는 코드의 위치를 쉽사리 알기 어렵다면 그 자체가 나쁜 코드의 징후다. 대개 적절한 테스트 코드가 없었거나, 에러 로깅이 잘 되어있지 않았거나, 버전 관리가 잘 안 되어있을 때 그렇다(<strong>환경 개선</strong> 단계에서 해결한다). 이럴 때 의외로 효과적인 방법이 코드 일부분을 주석처리하고 다시 실행해서 문제가 재현되는지 확인하는 것이다. 이런 분할 정복법으로 문제에 영향을 끼치는 부분을 절반 정도씩 줄여나가면 상당히 빠르게 문제 코드를 찾아낼 수 있다.</p><p><strong>2–2. 그 코드가, 그 조건에서, 왜 의도대로 동작하지 않았는가?</strong></p><p>테스트 케이스가 왜 실패했는가? 코드가 의도대로 동작하지 않은 이유를 이해해야 문제를 근본적으로 해결할 수 있다. 코드의 의도가 명확하지 않다면 이 질문에 답하기 어려울 수 있는데 이 또한 나쁜 코드의 징후다.</p><p><strong>2–3. 파악한 원인으로 인한 다른 문제는 없는가?</strong></p><p>유저가 리포트한 문제는 실제 문제의 한 사례에 불과하다. 문제의 원인에서부터 거꾸로 다른 문제를 탐색해나간다(다른 테스트 케이스를 만든다). 의도대로 동작하지 않은 코드가 사용된 다른 부분을 살펴보는 것은 물론이고, 정확히 그 코드는 아니더라도 비슷한 스타일로 작성된 코드가 다른 조건에서 문제를 일으키고 있지는 않은지 확인한다. 이 과정에서 현상 — 문제 해결 단계를 반복하게 될 수도 있다.</p><h3>3. 해결책</h3><p>현상을 유저의 눈으로 살펴 실패하는 테스트 케이스를 만들어냈고, 그 다음 개발자의 눈으로 테스트가 특정 조건에서 어떤 코드 조각 때문에 왜 실패하는지 알아냈다. 그러면 이제 테스트 케이스를 성공시켜야 하는데, 여기에는 기획자의 눈이 필요하다. ‘해결책 찾기’는 코딩이라기보단 의사결정의 과정이고, 기능의 구현 의도와 앱 사용자의 행태를 이해해야 좋은 결정을 내릴 수 있기 때문이다.</p><p><strong>3–1. 앱을 의도대로 동작시키기 위한 방법은 무엇이 있는가?</strong></p><p>언제나 해결책은 단수가 아니다. 해결책을 구현하는 방법도 여러가지일뿐 아니라, 그 층위도 여러 수준이 있다. 예를 들어 앱의 특정 버전에서, 함수의 파라미터로 null이 들어와서 null reference error 가 생기는 문제가 있다고 해보자.</p><blockquote><em>개발자 A: 파라미터가 </em><em>null 값이 아닐 때만 함수를 실행하도록 예외처리합시다.</em></blockquote><blockquote><em>개발자 B: 함수 실행부의 구조를 바꿔서 파라미터에 </em><em>null 이 들어오지 못하도록 강제합시다.</em></blockquote><blockquote><em>개발자 C: 현재 버전에는 해결된 문제니까 새로고침하면 해결됩니다. 앞으로 이런 문제를 방지할 수 있도록, 앱 실행시 버전 체크해서 오래된 버전이면 캐시를 비우고 새로고침하게 하는 모달을 띄웁시다.</em></blockquote><p>이 모두가 앱을 의도대로 동작시키는 방법이며, 분류하자면 A는 현상 수준, B는 원인 수준, C는 환경 수준의 해결책이다. 물론 세 가지 방법을 섞어서 쓸 수도 있겠지만, 뒤로 갈수록 더 근본적이고 더 바람직한 해결책이라고 할 수 있다. 그러나 항상 C와 같은 방법이 최선인 것은 아니다.</p><p><strong>3–2. 각 해결방법의 장단점은 무엇인가?</strong></p><p>더 근본적인 해결책이 언제나 더 <strong>좋은</strong> 해결책이라는 보장은 없다. 근본적인 해결책은 생각하고 구현하는 데 시간이 더 오래 걸리기 마련인데, 프로젝트의 진행 상황이나 가용 개발 리소스 등 앱을 둘러싼 환경은 가변적이기 때문이다. 물론 근본적인 해결책이라고 해서 꼭 오래 걸리는 것 또한 아니다. 어쩌면 D가 나타나서 “이거 기획자에게 확인해보니 이제 쓰이지 않는 기능이라는데, 그냥 함수를 삭제하죠?” 라고 해줄 수도 있는 것 아닌가.</p><p>어쨌든 확실한 것은, 프레드 브룩스로부터 몇십 년이 지났지만 여전히 소프트웨어 세계에 <a href="https://en.wikipedia.org/wiki/No_Silver_Bullet">만병통치약은 없다</a>는 사실이다. 현재 팀의 상황에 비추어 장단점을 비교해보고 가장 적절한 의사결정을 해야 한다. 다만 시간과 비용이 허락하는 한에서는 언제나 더 근본적인 해결책을 적용하도록 노력하자.</p><p>장단점을 분석할 때 간과하기 쉬운 부분을 하나 이야기하고 싶다. 어떤 해결방법은 다른 방법과 다르게 프로그래밍 모델, 즉 “팀이 디자인하고 개발하는 방식”에 영향을 줄 수 있으며 그로 인해 새로운 문제들이 생겨날 수 있다는 점이다. 예를 들어 페이지네이션을 적용한 게시판 앱에 문제가 생겨서 페이징 대신 무한스크롤을 적용하여, 스크롤을 페이지 끝으로 내릴 때마다 추가 컨텐츠가 로딩되도록 했다고 해보자.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/937/0*wkrAlr5_t73KwNN5.png" /><figcaption><em>푸터가 있는 게시판 앱. 페이지네이션에서 무한스크롤로 바뀌었다.</em></figcaption></figure><p>무한스크롤을 적용할 때 가장 처음 문제가 되는 부분은 푸터를 비롯해 페이지의 아래쪽에 위치한 요소들이다. 원래 고정되어있던 컨테이너의 크기가 가변적으로 변했기 때문이다. 페이지 하단에 푸터 영역도 잘 존재하고 각 링크도 작동하니까, 푸터 링크 클릭을 시뮬레이트하는 테스트는 여전히 잘 작동한다. 하지만 실제로는 사용자가 푸터 링크를 클릭하기 위해 스크롤을 내릴 때마다 새 컨텐츠가 로드되면서 푸터가 계속 멀어질 것이다. 따라서 푸터 영역을 고정하거나, 페이지 최하단의 요소들을 다른 곳으로 옮기거나... 하는 추가 작업이 필요해질 뿐더러, 좀 더 일반적으로는 이전과 달리 페이지 로드 후에 요소가 동적으로 생성될 수 있으므로, 더이상 고정된 페이지가 아님을 고려하여 페이지를 디자인해야 한다.</p><p>이러한 종류의 결정들(정적 -&gt; 동적, 클라이언트 -&gt; 서버, 코드 분할, 라이브러리 교체 등)은 기존에 팀이 일하던 방식에 큰 변화를 일으킬 수 있으므로, 결정을 내릴 때 팀원들과 충분한 의사소통이 필요하다.</p><p><strong>3–3. 선택한 방법이 문제를 잘 해결하는지, 부작용은 없는지 어떻게 확인할 수 있는가?</strong></p><p>해결 방법 하나를 선택해서 구현했다면 이제 테스트할 시간이다. 발견된 문제를 커버하는 테스트 코드가 없었다면 이 때가 추가할 좋은 타이밍이다. 테스트 코드가 있었다면 왜 그 테스트 코드로 문제를 발견하지 못했었는지 확인해야 하고, 또 구현이 변경됐으므로 테스트 코드 또한 변경해야 할 것이다.</p><p>테스트를 진행하면서, 앱에 생긴 변화가 기존에 작동하던 무언가를 깨뜨리지는 않는지 또한 확인한다. 문제를 해결하기 위한 코드가 새로운 문제를 일으키는 사례는 생각보다 흔하다. 통합 테스트가 잘 갖춰져있는 프로젝트라면 기능 수준에서는 확인이 되겠지만, 이런 프로젝트에서도 다른 문제가 얼마든지 생길 수 있다. 위에서 얘기한 프로그래밍 모델의 변화가 좋은 예다. 적절한 논의와 테스트를 거치지 않는다면 어떤 비극이 생길지 모른다. 멀리 갈 것도 없이, 우리 팀에서도 앱 패키징 용량을 줄이려고 동적 import를 도입했다가 끊임없이 생기는 버그 때문에 고생한 바 있다. (<em>큰 조직에서 만든 서비스도 상황이 크게 다르지는 않은 것 같다.</em>)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/738/0*fR_m9BYi9jZOKzBI.gif" /><figcaption>로그아웃과 고객센터 문의를 줄이는 대신 유저의 스트레스를 높이는데 성공한 디자인.</figcaption></figure><h3>4. 환경 개선</h3><p>기획자의 시선에서 테스트 케이스를 통과시켰으니, 이제는 팀 차원에서 리팩토링을 할 시간이다. 환경 개선은 다음에 비슷한 문제가 발생했을 때 더 쉽게 해결하기 위한 것이다. 이는 더 좋은 소프트웨어 개발 프로세스를 만드는 것과도 비슷하다.</p><p><strong>4–1. 현상의 재현조건을 더 쉽게 찾아내려면?</strong></p><p>현상 재현에 가장 많은 도움을 주는 도구는 로깅이다. 요즘에는 에러 로그를 수집하는 좋은 서비스가 많다. 우리 회사에서는 <a href="https://sentry.io/welcome/">Sentry</a>를 쓰고 있는데, 우리가 catch하지 못한 자바스크립트 에러가 발생했을 때 알려줄 뿐 아니라 에러 직전에 일어난 일들(어떤 링크가 눌렸나, 어떤 API가 호출됐나 등)을 <a href="https://sentry.io/features/breadcrumbs/">breadcrumb</a>이라는 기능으로 제공하고 있어 유용하다. 이렇게 자동으로 기록되는 정보들이 있으면 유저의 명시적인 버그 리포팅 없이도 에러의 재현 조건을 찾아내기 쉽다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*mr-sFrKly8gIOTE4WYiZAQ.png" /><figcaption><em>Sentry의 breadcrumb 예시.</em></figcaption></figure><p>좀 더 어려운 문제는 에러가 아닌 버그다. 위에서 버그를 ‘구현한 기능이 의도대로 동작하지 않는다’로 정의했고, 실제로 우리가 유지보수하는 문제는 정말로 에러가 나서라기보다는 의도대로 작동하지 않아서가 원인일 때가 더 많은 것 같다. 유저가 (그들 입장에서) 비정상적인 동작을 찾아내서 쉽게 피드백할 수 있게 해주는 좋은 서비스도 많다. 현재 우리 회사에서 쓰고 있는 서비스는 <a href="https://www.intercom.com/">Intercom</a>으로, 유저가 메시지를 보내면 그 유저의 OS/브라우저 등 환경 정보나 우리가 세팅한 UserId 등의 정보도 볼 수 있어서 재현에 도움이 된다. 추가로, 우리는 Intercom에서 제공하는 이벤트 로깅 API를 이용해서 Sentry breadcrumb 처럼 이 사람이 메시지를 보내기 전에 우리 앱에서 어떤 행동을 했는지 확인하고 있다.</p><p><strong>4–2. 문제 원인이 되는 코드를 더 쉽게 찾아내려면?</strong></p><p>이것도 우선은 로깅이다. 팀만의 로깅 시스템을 사용할 수도 있고, 단순한 console.error 도 상관없다. 특정 에러에 대해 적절한 에러 메시지를 쌓고 있다면 문제의 원인이 되는 코드를 찾아내기 훨씬 쉽다.</p><p>그 다음은 ‘의도 드러내기’다. 너무 기본적인 것이지만 변수명, 클래스명, 파일명 등이 너무 일반적이지는 않은지, 함수가 수행될 때 사이드 이펙트가 생기진 않는지 등을 확인하고 리팩토링한다. 만약 팀의 사정상 근본 원인 해결이 아닌 땜질식 해결책을 적용하기로 했다면, 해당 부분에는 이렇게 구현한 이유에 대한 적절한 주석을 작성해둬야 할 것이다. 이런 해결책은 다음번에 생긴 비슷한 문제를 가려버리는 효과가 있기 때문에 적용할 때 더욱 주의하고, 빠른 시일 내에 다시 제대로 구현해야 한다.</p><p><strong>4–3. 해결책을 더 쉽게 찾아내려면?</strong></p><p>안전하게 이것저것 실험해볼 수 있는 환경이 있다면 문제의 해결책을 찾아내기 쉽다. 안전한 실험 환경의 핵심은 크게 테스트 코드, 모듈화, 버전 관리 세 가지다. 테스트 코드는 적용된 해결책으로 인해 기존에 작동하던 기능들이 깨지지 않는지 확인해준다. 모듈화로 변경을 적용하고자 하는 기능이 다른 부분에 끼치는 영향이 적게 만들면 실험하기가 더 수월하다. 버전 관리가 잘 되어있다면 실험하다가 다시 잘 작동하던 버전으로 언제든지 돌아갈 수 있다. 물론 이 세 가지는 문제 원인을 찾는 것에도 큰 도움이 된다.</p><p>그리고 마지막으로, 어쩌면 가장 중요한 것이 팀 내의 의사소통 구조다. 버그가 대체 왜 생길 수밖에 없었는가를 계속 파고들다 보면 궁극적으로는 의사소통 문제로 수렴한다. 테스트 코드가 없어서 버그가 있었는지 몰랐는데, 개발자는 그 케이스를 테스트해야 하는지 몰랐고, 기획자는 그 케이스가 존재하는지 몰랐고.. 와 같이 말이다. 이상적으로는 기능을 설계하는 시점에서부터 기획자와 개발자가 활발하게 대화하면서, 요구사항을 테스트 가능한 수준으로 만들어내는 것이 좋다. 특히 앞서 얘기했듯 ‘프로그래밍 모델’에 영향을 끼치는 해결책은 팀 내 의사소통이 원활하게 이루어지지 않는다면 더 큰 문제를 일으킬 수 있다.</p><h3>0. 아직 재현 조건을 / 원인을 / 해결책을 찾지 못한 채 x시간이 지났다면…</h3><p>사실 모든 디버깅 과정이 스무-스하지는 않다. 오히려 교착상태에 빠질 때가 더 많다. 그럴 땐 잠시 디버깅을 멈추고, 한 발자국 물러서서 생각해보는 것도 좋다. 현재 나에게 이 문제가 얼마나 중요한지 다시 생각해보자. 이 문제에 영향을 받는 유저 또는 동료가 많은가? 정말 이 문제를 해결해야만 다음 문제를 해결할 수 있는가?</p><p>정확한 재현 조건을 파악할 때까지 (또는 새로운 버그 리포트가 올라올 때까지) 해결을 의도적으로 미루고 다음 일로 넘어갈 수도 있다. 또는, 지금까지 파악한 내용을 바탕으로 stackoverflow 등에 질문을 할 수도 있다. 다른 일을 하는 도중에, 또는 질문을 위해 내가 한 일을 정리하다가 불현듯 답이 떠오르는 경우도 많다.</p><p>내가 “ABC 문제”에 빠진 건 아닌지도 한번 점검해보자. ABC 문제는 임의로 붙인 이름인데, 이런 걸 말한다. “A 문제의 해결책이라고 알려진 B를 적용하는데 생기는 문제인 C를 해결하는 D를 적용하는데 에러가 난다.” 원인 분석 없이 구글링을 통해 복사 &amp; 붙여넣기만 하다 보면 어느새 원래 해결하고자 했던 문제에서 벗어나버리기 쉽다. D는 C하기 위한 것이고 C는 B하기 위한 것인데, A의 해결책이 정말 B밖에 없는가? 해결책은 언제나 단수가 아니라는 사실을 기억하면서, 내가 원래 풀고자 했던 문제는 무엇이었는지 다시 돌아가서 생각해보자. 의외로 다른 단순한 해결책이 나올 수도 있고, 문제 자체를 바꿀 수도 있다.</p><h3>예시: 리사이즈가 안돼요</h3><p>실제로 직장에서 내가 겪었던 문제에 이 템플릿을 간단하게 적용해보겠다. 아래와 같이 왼쪽에는 좌우 폭을 조절할 수 있는 컴포넌트, 오른쪽은 여러 종류의 컨텐츠가 들어갈 수 있는 컴포넌트가 있는 페이지가 있다. 평소에는 괜찮은데, 우측에 영상 플레이어가 있을 때는 좌측 컴포넌트 폭을 조절할 때 가끔씩 이상하게 마우스가 튀면서 리사이즈가 잘 안 된다는 리포트를 받았다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/683/0*vWNwR5hrD6rfZkoJ.png" /><figcaption><em>왼쪽은 좌우 폭을 조절할 수 있는 컴포넌트. 여러 종류의 컨텐츠가 들어갈 수 있는 오른쪽에는 Youtube 영상을 재생하는 플레이어가 렌더링된 상황.</em></figcaption></figure><p><strong>현상</strong></p><ul><li>윈도우즈 OS 크롬 브라우저에서, 좌우 분할해서 컴포넌트를 보는 페이지에서 리사이즈할 때 가끔씩 이상하게 마우스가 튀면서 리사이즈가 잘 안 된다.</li><li>유저의 권한과는 상관없었고, 앱 버전과도 상관없었다. 최근에 이쪽과 관련된 변경을 하지도 않았다.</li><li>관찰 결과, 1) 리사이즈를 왼쪽으로 할 때는 아무 문제 없이 빠르게 리사이즈가 됐다. 2) 오른쪽으로 할 때는 리사이즈를 천천히 하면 괜찮고 빨리 하면 마우스가 튀었다. 3) 유투브가 아닌 다른 컨텐츠가 우측에 있을 때는 리사이즈가 잘 됐다. 그런데… 4) PDF 파일이 우측에 있을 때는 유투브와 비슷하게 리사이즈 문제가 생겼다.</li></ul><p><strong>문제 원인</strong></p><ul><li><strong>‘마우스가 튄다’는 게 어떤 의미인가?</strong> 좌측의 Resizable 컴포넌트는, 리사이즈 핸들을 클릭한 채 드래그할 때마다 handleMouseMove 함수를 호출하게 구현되어 있다. 이 함수는 마우스의 X 위치가 바뀔 때마다 그 위치에 리사이즈 핸들이 따라가기 위한 것이다. 따라서 함수가 호출되지 않으면 마우스와 리사이즈 핸들 위치가 달라질 수 있다. 즉 ‘마우스가 튄다’.</li><li><strong>언제 함수가 호출되지 않을 수 있는가?</strong> handleMouseMove 는 window 오브젝트의 mousemove 이벤트에 바인드되어있다. 그러므로 window 에 mousemove 이벤트가 전달되지 않으면 함수가 호출되지 않는다.</li><li><strong>언제 전달되지 않을 수 있는가?</strong> 재현 조건을 찾으면서 어떤 컨텐츠가 우측에 있느냐에 영향을 받는다는 사실을 알았다. 유투브와 PDF를 렌더하는 코드에서 대신 빈 컨텐츠를 로드했더니 정상적으로 리사이즈가 된다는 것을 확인했다. 이 두 타입의 공통점은 다른 컨텐츠와 다르게 iframe 을 활용한다는 것이었다. 그런데 iframe은 Resizable을 호출한 window와 다른 window이므로 이벤트가 전달되지 않는다! 마우스를 빠르게 움직이면 포인터가 리사이즈 핸들을 벗어나 iframe 위로 올라가게 되고, 이 때 문제가 생기는 것이다.</li><li><strong>다른 곳에 비슷한 문제는 없는가?</strong> 꼭 이 페이지가 아니더라도, iframe 을 이용하는 곳이라면 window에 바인드된 이벤트가 전달되지 않을 위험이 있다는 것을 알았다. 찾아보니 당장은 그런 부분이 더 없지만 앞으로 이 문제가 생길 수 있다는 사실을 기억해야 한다.</li></ul><p><strong>해결책</strong></p><ul><li>이벤트가 전달되지 않는 이유는 iframe 위에 마우스가 있을 때는 이벤트가 부모 window 가 아닌 iframe 으로 가기 때문이다. 어떻게 해야 이벤트가 원하는대로 부모 window 로 전달될까?</li><li>가장 먼저 생각난 것은 부모 window 가 자식 iframe 에서 생긴 이벤트를 전달받을 수 있는가? 였다. 찾아보니 가능하긴 했지만 이렇게 하려면 자식 iframe 을 내가 통제할 수 있어야 했는데, iframe 은 대개 완전히 외부 URL을 불러오는 데 쓰기 때문에 부적절했다. 무엇보다 이 방법은 개별 iframe 마다 이벤트를 전달하는 코드를 삽입해야 할텐데 전혀 마음에 들지 않았다.</li><li>다음은, iframe 을 무시하는 방법을 생각해봤다. ‘리사이즈 핸들을 클릭한 상태’는 알 수 있었다. 이미 Resizable 컴포넌트에서 핸들을 클릭하면 body 에 grabbed--horizontal 따위의 클래스를 추가하게 되어있었기 때문이다. 그렇다면 이 상태에서 CSS를 뭔가 조절해서 iframe 을 무시할 수 있지 않을까.</li><li>드래그중일 때 iframe 의 z-index 를 낮춰봤다. 그랬더니 리사이즈는 잘 됐으나 iframe 이 아예 보이지 않았다. 뷰에 영향을 미치지 않으면서 iframe을 무시할 방법이 필요했다.</li><li>잠깐의 구글링 후 pointer-events: none 을 활용하는 방법이 떠올랐다. 이 속성이 정의되어있으면 해당 요소와 그 하위 요소에서 생기는 hover 와 click 마우스 이벤트는 무시되고 그 뒤에 있는 요소에서 실행된다. 따라서 iframe 안에서 mousemove 이벤트도 부모로 전달될 것이라는 가정이 있었고, 실험해보니 원하는 대로 동작했다.</li><li><a href="https://caniuse.com/#search=pointer-events">caniuse 에서 검색</a>해보니 Opera mini를 제외한 모든 브라우저에서 pointer-events 속성이 적용될 수 있었고, 알려진 이슈도 내 문제와는 관련이 없었다. 그래서 body가 grabbed--something 클래스를 가질 때 하위에 있는 모든 iframe이 pointer-events: none 을 가지도록 하는 해결책을 적용하기로 결정했다. 이렇게 하면 앞으로 iframe 을 사용하는 다른 컨텐츠가 생겨도 문제없다. 그리고 특수한 조건에서만 해당 속성이 추가되게 했기 때문에 다른 부작용은 없을 것이라고 생각했다.</li></ul><p><strong>환경 개선</strong></p><ul><li>이 해결책을 적용할 당시에는 우리 앱에 마우스 움직임에 대한 테스트를 만들기는 어려운 환경이었기 때문에 테스트코드를 따로 만들지는 않았다. 이런 문제를 인지하고, 원래 유닛 테스팅 프레임워크로 사용하던 jest + enzyme 에 더해서 testcafe 를 UI 테스팅 프레임워크로 사용하기로 했다.</li><li>보통은 윈도우에 이벤트가 전달되지 않을 수 있다는 생각은 전혀 하지 않았었는데 iframe 과 같이 그런 케이스가 있을 수 있다는 사실을 알게 됐다. 이런 지식은 개발팀 전체가 공유하면 좋겠다고 생각하여, Resizable 컴포넌트에 주석으로 해당 문제에 대한 설명을 추가하고 이 문제의 해결 과정을 자세하게 기록해뒀다. (당시 더 정리해서 회사 위키에 남겨놔야겠다고 생각했었는데 이 글을 쓰는 시점까지 까먹고 있었다.)</li></ul><h3>마치며</h3><p>정리하면, 디버깅을 체계적으로 하는 프로세스는 이렇다. 대부분 눈치채셨겠지만 레거시 코드에 TDD 스타일로 테스트를 추가하는 과정과 비슷하다.</p><ul><li>실패하는 테스트 케이스 만들기: 문제 현상에 대한 명확한 재현조건을 찾는다.</li><li>왜 실패하는지 살펴보기: 문제를 일으키는 코드를 찾는다.</li><li>테스트 케이스 통과시키기: 장단점을 고려하여 팀 상황에 맞는 해결책을 적용한다.</li><li>리팩토링: 다음에 비슷한 문제가 발생했을 때 더 쉽게 해결할 수 있도록 환경을 개선한다.</li></ul><p>결국 중요한 건 (정훈님이 말씀하신 것처럼) 근본적인 환경 개선이다. 버그가 전혀 없는 앱을 만들어내는 것은 불가능하다. ‘버그 리포팅이 적다’는 ‘앱에 결함이 적다’와 다르다. 유저가 버그를 겪어도 버그인 줄 모르거나, 버그를 찾아도 리포트하기 어렵거나, 또는 앱 유저 수가 너무 적어서일 수도 있다. 아니면 버그의 존재가 CS팀에서 개발팀으로 전달되지 않았을지도 모른다. 어쨌든 ‘앱을 완벽한 상태로 배포하기’보다는 ‘버그를 빠르게 인지하고 해결할 수 있는 환경 구축하기’가 좀 더 생산적인 접근이라고 본다.</p><p>이런 환경 구축 또한 처음부터 완벽하게 하기는 당연히 어렵다. 다만 버그를 만날 때마다 이걸 피드백 삼아 조금씩 더 나은 환경으로 만들겠다는 마음가짐이면 된다고 생각한다. 그러면 버그에 짜증이 아니라 감사하게 될 수도 있고, 개발이 훨씬 더 즐거워질 수 있다. 어차피 우리가 매일 수행하는 개발 시간의 상당 부분은 유지보수니까.</p><p>블로깅을 본격적으로 시작한지 얼마 되지 않았지만, 학습을 위한 정리 도구로서 블로그가 상당히 효과적이라고 느낀다. 이 템플릿도 글로 정리해보면서 더 명확해진 부분이 많다. 비록 지금의 나는 이렇게 문제해결 과정을 몇 단계로 나눠야 스스로 생각 점검이 되지만, 경험이 더 쌓이면 단계를 건너뛰거나 합치거나 하면서도 자연스럽게 문제해결이 가능할 것이다. 이 글을 씀으로써 내 템플릿이 내 몸에 좀 더 체화되었기를 바란다.</p><p>p.s. 글을 마무리해갈 때쯤 <a href="https://www.amazon.com/Debug-Repair-Prevent-Pragmatic-Programmers/dp/193435628X">Debug It!: Find, Repair, and Prevent Bugs in Your Code</a> (번역: <a href="http://www.acornpub.co.kr/book/debug-it">Debug It! 실용주의 디버깅</a>)이라는 짧고 재미있는 책을 읽었다. 약 9년 전에 나와서인지 내용이 살짝 오래되긴 했지만, 여전히 실용적인 조언으로 가득찬 좋은 책이었다. 내 생각과 비슷한 내용도 많아 더 공감하며 읽었다. 디버깅을 좀 더 즐겁게 하고 싶으신 분들께 추천한다.</p><p><em>Originally published at </em><a href="https://spilist.github.io/2018/06/11/debugging-debug"><em>spilist.github.io</em></a><em> on June 11, 2018.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d3d4a9882adb" width="1" height="1"><hr><p><a href="https://medium.com/steady-study/%EB%94%94%EB%B2%84%EA%B7%B8%EB%A5%BC-%EB%94%94%EB%B2%84%EA%B9%85%ED%95%98%EA%B8%B0-%EB%8B%A8%EA%B3%84%EC%A0%81-%EB%94%94%EB%B2%84%EA%B9%85-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%ED%85%9C%ED%94%8C%EB%A6%BF-d3d4a9882adb">디버그를 디버깅하기: 단계적 디버깅 프로세스 템플릿</a> was originally published in <a href="https://medium.com/steady-study">Steady Study</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[정리] 프로그래머에게 필요한 피드백, 그리고 QuickAndDirty]]></title>
            <link>https://medium.com/steady-study/%EC%A0%95%EB%A6%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%97%90%EA%B2%8C-%ED%95%84%EC%9A%94%ED%95%9C-%ED%94%BC%EB%93%9C%EB%B0%B1-%EA%B7%B8%EB%A6%AC%EA%B3%A0-quickanddirty-cada34da3646?source=rss-c84770a5cabe------2</link>
            <guid isPermaLink="false">https://medium.com/p/cada34da3646</guid>
            <category><![CDATA[software-development]]></category>
            <category><![CDATA[learning]]></category>
            <dc:creator><![CDATA[Hwidong Bae]]></dc:creator>
            <pubDate>Sun, 10 Jun 2018 00:00:00 GMT</pubDate>
            <atom:updated>2018-06-15T03:46:45.890Z</atom:updated>
            <content:encoded><![CDATA[<p><a href="http://youngrok.com/">박영록</a> 님의 홈페이지에는 소프트웨어 개발에 있어서 강렬한 인사이트를 주는 글이 많다. 그 중 최근에 다시 읽은 두 가지 글을 정리했다. (사실 이 정리는 내가 저 글들을 더 잘 흡수하기 위한 것에 불과하다. 원문이 훨씬 좋으니 관심이 생기신 분은 그냥 원문을 읽으시길 바란다.)</p><h3><a href="http://youngrok.com/프로그래머에게%20필요한%20피드백">프로그래머에게 필요한 피드백</a></h3><p>프로그래머는 어떤 피드백을 받아야 전문가로 발전하는 데 도움이 될까?</p><ul><li>성과에 대한 명확한 지표가 필요하다. 참여한 프로젝트가 얼마나 돈을 벌었는지, 얼마나 많은 사람에게 돈을 주었는지 등. 단, 그 안에서 내가 한 역할은 무엇이었는지도 함께 생각해야 한다.</li><li>이러한 최종 성과보다 더 직접적인 피드백은 <strong>clean code that works</strong>다. 우선 너무나 당연한 것이지만, 제대로 돌아가게 하는 게 첫번째다. 내가 이 프로젝트에서 필요한 기능을 제대로 만들어내고 있는가? 이게 전제다.</li><li>그다음은 clean code다. 여기서 clean code는 목표가 아니라 수단이다. 일단 잘 돌아간다는 전제 하에, clean code는 더 빨리 개발하기 위한 수단이다. 더 빨리 개발을 해낼 수 없다면 clean code는 무의미하다. 거꾸로, clean하지 않을수록 컨텍스트를 쉽게 잃어버리고 점점 개발속도가 느려지기 때문에, 스케일이 커질수록 clean code 없이 개발 속도를 낼 수는 없다. 즉 개발 속도가 빠르다는 것은 working하는 프로젝트를 clean하게 잘 개발한다는 것과 같다.</li><li>따라서, <strong>돌아가게 만든다는 전제 하에 얼마나 빨리 개발할 수 있느냐</strong>가 개발자 능력에 가장 중요한 척도다. 이걸 ‘정확’하진 않아도 ‘정량’적으로는 뽑아내야 한다. 예를 들면 비슷한 기능을 만들어내는데 얼마나 걸렸는가? 예전에는 3주, 그 다음은 3일, 최근에는 하루. 디테일, 언어, 프레임워크, 환경 등이 다 다르더라도 비슷한 부분은 뽑아내서 비교할 수 있다. 반복 효과를 감안하더라도 대략적인 측정이 가능하다. 이에 대한 피드백을 계속 받아야 전문가로 성장할 수 있다.</li><li>그런데 ‘돌아간다’, 즉 품질에 대한 기준은 사람마다 다르다. 어느 정도 품질을 기준으로 빨리 해야 할까?</li><li>영록님의 주장은 품질과 상관 없이 무조건 빨리 해야 한다는 것이다. 중요한 건 최종 배포 때 버그가 없는 것이지 매 순간 버그가 없는 게 아니다. 빨리 개발하면 빨리 버그를 찾아서 빨리 고칠 수 있다. 품질을 높이기 위해 신경쓰면 고객에게 기능이 전달되는 게 늦어진다. 차라리 버그가 있는 상태에서 고객과 소통하는 이득이 더 크다. 기능이 고객에게 맞는지 아닌지를 볼 수 있기 때문이다.</li><li>품질을 깎아 먹은 결과로 전체 프로젝트가 더 느려지는 건 당연히 안 된다. 개별 기능 구현 뿐 아니라 프로젝트 전체가 빨리 끝나야 한다. TDD, 리팩터링 등 각종 기법의 모든 목표는 생산성, 즉 더 빨리 프로젝트를 완료하는 것이다. clean code의 극한을 추구하느라 느리게 개발하는 건 용납될 수 없다.</li><li>정리하면, 프로그래머에게 필요한 피드백은 세 가지다. <strong>1) 내가 참여한 프로젝트가 성공했는가</strong>. <strong>2) 내가 개발한 기능은 제대로 동작하는가</strong>. <strong>3) 나의 개발 속도는 얼마나 빠른가</strong>. 성장을 위해 가장 중요한 건 세 번째다. 물론, 여기에 성장 의지, 피드백에서 알아낸 상관 관계에서 인과 관계를 뽑아낼 분석력 등도 필요하다. 피드백은 전문가로 가는 길의 첫걸음 정도로 생각하면 된다.</li></ul><h3><a href="http://youngrok.com/QuickAndDirty">Quick And Dirty</a></h3><p>위 글의 다음 시리즈 글. 스타트업은 어떻게 quick &amp; dirty를 해야 하는가?</p><ul><li>먼저, clean code에 도달하는 가장 훌륭한 방법인 TDD는 다음과 같다.</li></ul><ol><li>제대로 동작하는지 확인할 수 있는 테스트를 작성한다.</li><li>실행 가능하게 만든다. 다른 무엇보다도 중요한 것은 빨리 초록 막대를 보는 것이다. 빨리 초록 막대를 보는 것은 모든 죄를 사해준다. 하지만 아주 잠시동안만이다.</li><li>올바르게 만든다(리팩토링). 이제 시스템이 작동하므로 직전에 저질렀던 죄악을 수습하자.</li></ol><ul><li>린 스타트업은 TDD를 조금 더 큰 스케일로 하는 것이다.</li></ul><ol><li>가설을 수립하고, 가설을 확인할 수 있는 지표를 설정한다.</li><li>가설을 검증할 수 있는 MVP를 만든다. quick &amp; dirty!</li><li>가설이 검증되었다면 완성도를 높여간다.</li><li>가설 검증 결과가 틀린 것으로 나온다면 새로운 가설을 수립한다.</li></ol><ul><li>문제는 2와 3 사이에 있다. 가설을 검증하는 MVP를 빠르게 만들었으면 그 코드를 리팩토링해야 한다. 리팩토링을 하지 않으면 모범 답안을 보고 달리는 추격자에게 자리를 내주게 된다. MVP까지는 quick &amp; dirty로 빠르게 만들 수 있어도 완성품을 만드는 것은 clean code 없이 속도를 낼 수 없다. 윗 글에서도 말했듯, 스케일이 커지면 clean하지 않으면 속도가 점점 느려진다.</li><li>여기서 CEO가 엔지니어링 마인드를 가지고 있지 않다면 2.5에 있는 리팩토링의 필요성을 이해하지 못한다. CEO는 quick &amp; dirty로 가설을 검증해냈기 때문에 앞으로도 쭉 quick &amp; dirty로 해나가면 되고, 앞으로도 계속 같은 속도로 움직일 수 있을 거라고 생각한다. 설령 말로는 리팩토링이 필요하다는 개발자의 말에 동의하더라도 그걸 할 시간을 충분히 주지 않는다.</li><li>그런데 어차피 대부분의 스타트업은 3으로 넘어가지 못한다. 시장에서 proof of concept를 못하고 접는 스타트업이 얼마나 많은가. 즉 대부분의 스타트업에서 개발자가 고민해야 할 단계는 2단계다. “MVP를 어떻게 quick &amp; dirty로 개발할 것인가”이다.</li><li>MVP, Minumum Viable Product에서 중요한 건 <strong>Minimum</strong>이다. MVP는 충분히 작아야 한다. MVP가 충분히 작다면, quick &amp; dirty로 매우 빨리 만들어도 그 과정에서 기술 부채는 별로 쌓이지 않고, 가설 검증이 되면 바로 갚을 수 있다.</li><li>그러나 대부분의 스타트업은 Minimum을 못한다. 오히려 기능이 부족해서 고객이 안 온다고 생각하며 Maximum을 만드려고 한다. 그렇게 제품이 점점 비대해지면 quick &amp; dirty로 인한 기술 부채는 감당할 수 없을 만큼 쌓여간다. 이러다 보면 속도가 점점 느려져서 어느 순간 아무 것도 할 수 없는 상태가 된다. 그리고 어떻게 가설 검증이 되었더라도, 그 사이 quick &amp; dirty로 만든 제품이 이미 너무 비대하다면 아예 리팩토링에도 손을 못 대는 (즉 2.5단계로 넘어가지 못하는) 상황이 온다.</li><li>따라서 스타트업은 MVP를 극도로 절제하며 만들어야 한다. 가설의 성공/실패 여부가 가려지지 않았을 때 새로 기능을 추가하는 것이 결과적으로 성공 확률을 깎아먹는다. 기술 부채를 통제할 수 있는 선에서 MVP를 만들어야 한다.</li><li>그러면 Minumum을 잘 설정했다 치고, quick &amp; dirty로 어떻게 개발해야 할까? 여기서 제시하는 방법들은 clean code의 궁극을 추구하는 게 아니라, 기술 부채로 파산하는 위험을 아주 작은 노력으로 막는 것이다.</li><li><strong>추상화하지 말라.</strong> 잘못된 추상화는 코드를 재앙으로 이끈다. 초기에 좋은 추상을 발견할 시간이 부족하다면 추상화를 하지 말고 미루라.</li><li><strong>메소드를 추출하지 말라.</strong> 함수도 추상의 일부다. 추출함으로써 상태를 더 관리해야 한다거나 이해할 컨텍스트가 넓어진다거나 할 수 있다. 잘 추출되지 않은 함수가 있는 것보다 차라리 한 군데 모여있는 1000줄짜리 메서드가 리팩토링하기 더 좋다.</li><li><strong>상속 계층을 만들지 말라.</strong> 다형성에 대한 완벽한 이해가 없다면 좋은 상속 구조를 만들어내기 어렵다. 스스로 OOP를 잘한다고 생각하지 않는다면 상속을 차라리 전혀 쓰지 말라.</li><li><strong>중복을 한 파일에 몰아라.</strong> 리팩토링은 중복을 제거하고 의도를 드러내는 것이다. 그런데 중복을 제거하려면 추상화를 하게 되는데, 좋은 추상화를 하기 어렵다. 그러니 일단 한 군데 중복을 몰아넣어라. 여러 곳에 걸쳐 퍼진 중복은 나중에 리팩토링하기 어렵다.</li><li><strong>Cyclomatic Complexity를 줄여라.</strong> 한 마디로 말하면 분기의 depth를 늘리지 않는 것이다. 예를 들면 guard clause를 활용해서 if를 flatten하는 것. 그리고 중첩된 if는 중복이 있더라도 풀어두는 게 좋다. 이해하기 쉬운 중복은 리팩토링하기 쉽다.</li><li><strong>이름 규칙을 정해라.</strong> quick &amp; dirty는 리팩토링도 대충 하기 때문에 네이밍을 열심히 하진 않아도 되지만 규칙은 잘 정해둬야 한다. CSS class 이름, 태그 id 등 규칙을 잘 지켜놓으면 협업할 때 이해하기도 쉽고 나중에 리팩토링하기 쉽다.</li><li><strong>안 쓰는 코드와 파일을 삭제하라.</strong> quick &amp; dirty로 만들어진 코드는 어차피 나중에 레거시가 될 운명을 타고났다. 한 눈에 들어오는 파일 갯수도 유지보수에 큰 영향을 미친다. 쓰지 않는 코드는 주석처리하지 말고 삭제하라.</li><li><strong>주석은 되도록 쓰지 말라.</strong> 코드 분석에 도움될 정도의 주석을 쓸 시간에 리팩토링을 하든가 구현을 더 빨리 하라. 주석은 코드만큼 실시간으로 업데이트되지 않기도 하고, 좋은 주석을 쓰기도 어렵다. 비정상적인 방법으로 구현했거나, why를 남겨야 할 때만 주석을 남겨라.</li><li><strong>코드 외의 기술적 사항을 문서로 남겨라.</strong> 각종 설정 파일, 배포 방법 등의 정보가 실종되면 레거시를 더이상 업데이트할 수 없는 일이 생긴다. 이런 것도 모두 코드로 간주해서 버전관리 및 자동화를 하거나, 그 시간도 아깝다면 문서로라도 남겨놔야 한다.</li><li><strong>적정 기술을 사용하라.</strong> 최신 기술 일부러 쓰려 하지 말고, 생산성이 높고 검증된 프레임워크를 사용하라. 눈앞의 과제에 대한 최선의 해결책을 찾으려고 하다 보면 필요한 신기술은 자연스럽게 익히게 된다. 따라가려고 하지 말고, 나중에 찾을 수 있는 정도로만 변화의 흐름에 귀만 열어두라.</li><li><strong>동일 목적의 프레임워크/라이브러리를 여러 개 쓰지 말라.</strong> 지금 쓰는 것이 마음에 안 들어서 바꾸는 것도 좋고, 점차적으로 갈아엎는 것도 좋지만, 그 공존 상태는 일시적이어야 한다. 그렇지 않으면 나중에 변경하려고 할 때 작업량이 몇 배로 늘어난다.</li><li>어쨌든 스타트업은 quick &amp; dirty를 해야 한다. ‘아무도 쓰지 않는 훌륭한 제품’은 결국 쓰레기다. 기술 부채 만드는 것을 두려워하면 안 되지만, 그 부채는 감당할 수 있는 수준으로, 파산하지 않게 유지해야 한다. 너무 좋은 코드도 너무 나쁜 코드도 스타트업에게는 좋지 않다. 적정 기술, 적정 품질을 생각하며 일하는 엔지니어가 되자.</li></ul><p>언젠가 ‘어떤 개발자가 훌륭한 개발자인가?’라는 주제로 토론을 한 적이 있다. 그 때 내 의견은 대략 “고객에게 가치 있는 제품을 빨리 전달할 수 있는 사람”이었던 것 같다. 이 기준 자체는 영록님의 의견과 상당히 비슷하다. 그런데, 나는 ‘내가 더 좋은 개발자가 되어가고 있는가?’를 고민하고, 측정하며, 나 스스로에게 피드백을 주진 않았었다. <a href="http://agile.egloos.com/5749946">의도적 수련</a>이라는 키워드를 접한지는 오래 됐지만 별로 의도적 수련을 하지 않고 있었던 것이다… 거참.</p><p>크게 아파서 회사에 병가를 냈다가 복귀한 이후로 1) <strong>출퇴근 시간에 글 읽기</strong> 2) <strong>일과 중의 지루한 디버깅 업무를 기록하고 패턴화하는 훈련</strong> 3) <strong>퇴근 후 블로그 글쓰기 </strong>세 가지를 꾸준히 하고 있다. 이로부터 삶의 만족도도 높여주고 개발자로서도 성장하고 있다고 느꼈는데, 이제는 개발자로서의 나를 정량적으로 측정해보고 피드백을 해봐야겠다.</p><p><em>Originally published at </em><a href="https://spilist.github.io/2018/06/10/feedback-for-programming-expertise.html"><em>spilist.github.io</em></a><em> on June 10, 2018.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=cada34da3646" width="1" height="1"><hr><p><a href="https://medium.com/steady-study/%EC%A0%95%EB%A6%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%97%90%EA%B2%8C-%ED%95%84%EC%9A%94%ED%95%9C-%ED%94%BC%EB%93%9C%EB%B0%B1-%EA%B7%B8%EB%A6%AC%EA%B3%A0-quickanddirty-cada34da3646">[정리] 프로그래머에게 필요한 피드백, 그리고 QuickAndDirty</a> was originally published in <a href="https://medium.com/steady-study">Steady Study</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2018년 5월, 읽고 공부한 것들]]></title>
            <link>https://medium.com/steady-study/2018%EB%85%84-5%EC%9B%94-%EC%9D%BD%EA%B3%A0-%EA%B3%B5%EB%B6%80%ED%95%9C-%EA%B2%83%EB%93%A4-549e802dc3c7?source=rss-c84770a5cabe------2</link>
            <guid isPermaLink="false">https://medium.com/p/549e802dc3c7</guid>
            <category><![CDATA[readinglist]]></category>
            <dc:creator><![CDATA[Hwidong Bae]]></dc:creator>
            <pubDate>Tue, 29 May 2018 00:00:00 GMT</pubDate>
            <atom:updated>2018-06-10T14:56:46.947Z</atom:updated>
            <content:encoded><![CDATA[<p>회사 위치가 바뀌면서 출퇴근 시간이 80분 가량으로 늘었다. 원래 좀 멍하니 보냈던 이 시간동안 폰으로 글을 읽기 시작했더니 꽤 많은 글을 읽게 됐다. React와 자바스크립트에 대한 글도 상당히 많이 읽었지만 기술적인 내용들은 가능하면 개별적인 글로 정리하기로 하고, 나머지 중 기록해둘 만한 글들을 정리해본다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*1ItS7jzwrzPx9eNf.jpg" /></figure><h3>글이 내게 오는 과정</h3><p>우선, 그동안의 패턴을 보니 읽을 글은 대략 이런 경로를 통해 얻는다.</p><h4>Medium Weekly Digest</h4><ul><li>매주 금요일에 내가 팔로우한 사람이나 내가 관심 표명한 주제, 글 등에 기반하여 읽을 글들을 보내준다.</li><li>여기서 좋은 글을 읽으면 그 글을 쓴 사람이나 그룹의 글을 앞뒤로 더 찾아서 읽는다.</li><li>요즘 미디엄에서 가장 많은 글을 읽다 보니 점점 더 큐레이션이 잘 되는 느낌이다.</li></ul><h4><a href="https://blog.outsider.ne.kr/category/Newsletter">Outsider 님의 기술 뉴스</a></h4><ul><li>2주에 한 번씩, 웹개발이나 프로그래밍 전반에 관련된 글, 그밖에 읽을 만한 흥미로운 글들을 본인의 코멘트와 함께 올려주신다.</li><li>관심사가 비슷해서인지 올려주시는 글 중 재밌게, 유용하게 읽은 글이 많다.</li></ul><h4><a href="http://jhrogue.blogspot.com/search/label/B급%20프로그래머">jhrogue 님의 기술 뉴스</a></h4><ul><li>이 분도 1~2주에 한 번씩 읽을 만한 글들을 올려주신다.</li><li>별다른 설명 없이 딱 링크만 올리시는데다가 관심분야가 살짝 달라서 생각보다는 읽을 글을 많이 건지지는 못한다.</li></ul><h4>Facebook</h4><ul><li>개발자 페친이 많다 보니 각종 스타트업이나 기술 소식을 페북을 통해서도 알게 되는 경우가 종종 있다.</li></ul><h4>문제해결 과정에서의 구글링</h4><ul><li>회사에서 개발하면서 겪는 각종 문제를 해결하다 보면 공식 문서를 파고들거나 개념을 설명해주는 글도 많이 읽게 된다.</li></ul><h3>개발문화/철학</h3><ul><li><a href="https://blog.daftcode.pl/hype-driven-development-3469fc2e9b22">Hype driven development</a>: 새롭거나 유명한 기술이 현재 자신과 팀의 상황에 맞는지에 대한 고찰과 분석 없이 도입되는 것을 경고하는 재밌는 글이다. 읽고 나서 번역하려고 했더니 ‘설레발 주도 개발’이라는 아주 멋진 제목으로 <a href="https://lazygyu.net/blog/hype_driven_development">번역된 글</a>이 있었다.</li><li><a href="https://medium.com/@sybae/리모트-근무는-실화고-사무실은-먹는것-0편-65d9aa8dced1">리모트 근무는 실화고 사무실은 먹는 것</a>: <a href="https://medium.com/@blaswan/salesboost-recruit-2c1248aa394a">세일즈부스트</a>라는 기업에서 슬랙 봇 서비스인 <a href="https://standuply.com/">Standuply</a>를 이용해서 어떻게 원격 근무 환경에서 효과적으로 컨텍스트를 공유하는지에 대한 글이다. 자율적인 원격 근무는 직원 입장에서 아주 훌륭한 근무형태로 여겨지지만, 실제로 실행해 보면 암묵적 의사소통의 부재로 인한 문제가 작지 않다. 최근 우리 팀도 이런 문제를 느껴 해결책을 고심하고 있었는데 여기서 소개된 슬랙 봇을 테스트해볼 예정이다.</li><li><a href="https://medium.com/@cramforce/designing-very-large-javascript-applications-6e013a3291a3">Designing very large (JavaScript) applications</a>: 구글에서 오래 프론트엔드 개발자로 일했던 <a href="https://medium.com/@cramforce?source=post_header_lockup">Malte Ubi</a> 가 거대한 앱을 구축할 때 고려해야 할 점들에 대해 발표한 글이다. 원문은 컨퍼런스 발표 스크립트의 거의 무편집 버전이라, 구조화도 잘 안 되어있고 몇몇 부분은 이해하기 쉽지 않았지만 충분히 좋은 인사이트를 주는 좋은 글이었다. 고생해서 블로그에 <a href="https://medium.com/steady-study/번역-아주-거대한-자바스크립트-어플리케이션을-구축하기-3aa37fc45122">전문 번역</a>했다.</li><li><a href="https://www.slideshare.net/codetemplate/2018-01code-review-95601233">인간답게 코드 리뷰하기</a>: 코드리뷰가 어려운 이유, 그리고 코드리뷰를 효과적으로 하는 8가지 방법에 대한 글(<a href="https://mtlynch.io/human-code-reviews-1/">1부</a>, <a href="https://mtlynch.io/human-code-reviews-2/">2부</a>)이 정리된 슬라이드다. 개발팀에서 코드 리뷰가 잘 이뤄지지 않고 있다면 특히 추천.</li><li><a href="https://medium.com/@samerbuna/the-mistakes-i-made-as-a-beginner-programmer-ac8b3e54c312">The Mistakes I Made As a Beginner Programmer</a>: 필자가 초보 개발자 시절에 저질렀다고 하는 25가지 실수에 대한, 상당히 길지만 대충이라도 읽어볼 만한 글이다. 좋은 개발자가 되려면 어떤 태도를 가져야 하는가? 라는 질문에 대해 괜찮은 길을 제시해준다. 프로젝트 회고 등을 할 때 체크리스트로 써봐도 괜찮을 것 같다.</li></ul><h3>UI/UX 디자인, CSS</h3><ul><li><a href="https://uxdesign.cc/design-better-forms-96fadca0f49c">Design better forms</a>: 입력 폼을 디자인할 때 흔히 하는 실수들과, 그걸 어떻게 고칠 수 있는지 보여주는 글이다. 블로그에 <a href="https://medium.com/steady-study/번역-더-나은-폼-디자인을-위해-a47ad28dee12">요약 번역</a>했다.</li><li><a href="https://uxdesign.cc/design-better-data-tables-4ecc99d23356">Design better data tables</a>: 성공적인 데이터 테이블 UI의 요소들에 대해, 어떤 기능들이 어떨 때 필요한지 보여주는 글이다. 블로그에 <a href="https://medium.com/steady-study/번역-더-나은-데이터-테이블-디자인을-위해-8d6b518da5ae">요약 번역</a>했다.</li><li><a href="https://medium.com/startup-grind/i-got-rejected-by-apple-music-so-i-redesigned-it-b7e2e4dc64bf">I Got Rejected by Apple Music… So I Redesigned It</a>: Apple Music의 인턴십에 지원했다가 떨어진 사람이 Apple Music 앱을 자기 나름대로 분석하여 다시 디자인한 과정을 적은 글이다. 글 내용 자체보다도 입사 실패의 다음 액션을 ‘자신만의 앱 재설계’로 삼고, 그 과정을 기록하는 태도가 멋지다. 참고로 이 사람은 결국 <a href="http://jasonyuan.design/about">입사에 성공</a>했다.</li><li><a href="https://evilmartians.com/chronicles/scroll-to-the-future-modern-javascript-css-scrolling-implementations">Scroll to the future</a>: 스크롤과 관련된 여러가지 기능들은 대부분 ‘모든 브라우저에서 잘 작동’하게 하기 위해 자바스크립트로 작성되어 왔다. 이제 최신 CSS와 DOM API가 새 버전의 브라우저들에 지원되면서 자바스크립트로 만들어진 이런 기능들이 더 간편한 코드로, 더 좋은 성능으로 대체될 수 있는 가능성이 생겼다. 어떤 예시들이 있는지 블로그에 <a href="https://medium.com/steady-study/번역-미래를-향한-스크롤링-f093a4991477">요약 번역</a>했다.</li><li><a href="https://engineering.linkedin.com/blog/2018/04/css-at-scale--linkedins-new-open-source-projects-take-on-stylesh">CSS at Scale: LinkedIn’s New Open Source Projects Take on Stylesheet Performance</a>: CSS 셀렉터의 성능 문제는 크게 신경쓸 필요가 없다고는 하지만, 사이트가 아주 거대해지면 이야기가 다르다. 이 글은 링크드인에서 너무 비대해진 CSS의 문제를 인지하고, 불필요한 CSS 클래스 정의를 최적화하면서 코드 분할을 적용함으로써 CSS 파일 번들의 크기를 90% 이상 줄인(156KB -&gt; 9KB) 과정을 보여준다. 이정도로 최적화를 해낸 것도 놀랍지만, 자신들이 적용한 기술을 <a href="http://css-blocks.com/">CSS Blocks</a> 와 <a href="https://github.com/linkedin/opticss">OptiCSS</a> 라는 오픈소스 라이브러리로 공개한 것도 놀랍다.</li></ul><h3>React</h3><ul><li><a href="https://medium.com/@ljs0705/카카오페이지-웹-react-포팅-후기-76402cc5e031">카카오페이지 웹 React 포팅 후기</a>: 정성들인 개발 후기를 읽는 건 언제나 즐겁다. 많은 유저가 사용하는 거대한 서비스를 React로 옭기면서 다양한 기술적 결정을 어떤 이유로 어떻게 결정했는지를 자세히 설명해주는 좋은 글이다. 이 글을 읽고 몇 가지 유용한 키워드와 라이브러리를 알게 됐다.</li><li><a href="https://sujinlee.me/the-road-to-learn-react-korean/">리액트 도움닫기 한국어 번역서를 출간하며</a>: <a href="https://leanpub.com/the-road-to-learn-react">The Road to learn React</a>라는 리액트 튜토리얼 책을 번역한 과정에 대한 글이다. 번역에 참여하게 된 계기와 번역 자체 과정, 퇴고를 위해 어떻게 했는지 등 전체 과정이 잘 나와있어서 흥미롭게 읽었다. 참고로 책의 저자인 Robin Wieruch는 <a href="https://www.robinwieruch.de/giving-back-by-learning-react/">모두에게 리액트를 배울 수 있는 기회를 주고자 이 책을 오픈 소스로 출판했다.</a></li><li><a href="https://codeburst.io/performance-tuning-a-react-application-f480f46dc1a2">Performance-tuning a React application — A Case Study</a>: <a href="https://tello.tv/">Tello</a>라는 웹앱의 성능을 프로파일링하고, 압축, 캐싱, 동적 이미지 크롭, 레이지 로딩, 코드 분할 기법을 활용하여 최적화한 과정을 자세히 적은 글이다. 서버사이드 렌더링을 비롯한 어떤 기법들은 왜 사용하지 않았는지 등도 적혀 있어 유용했다. 읽으면서 정말 여러가지를 배울 수 있었다.</li></ul><h3>함수형 프로그래밍</h3><ul><li><a href="https://medium.com/@cscalfani/goodbye-object-oriented-programming-a59cda4c0e53">Goodbye, Object Oriented Programming</a>: 객체 지향 프로그래밍의 장점으로 꼽히는 상속(inheritance), 캡슐화(encapsulation), 다형성(polymorphism)이 복잡한 어플리케이션에서 어떤 문제를 가지고 있는지 보여주고, 결론적으로 함수형 프로그래밍 쓰라는 영업글이다. OOP 단점이 잘 드러난 글이긴 하나, 내용과는 별개로 이런 형식의 글을 그다지 좋아하진 않는다. 모든 도구는 상황에 맞는 쓰임새가 있는 건데 이런 글은 ‘무조건 OOP가 구리고 FP가 좋다’는 식으로 생각하게 유도하는 느낌이라서다. 모든 상황에 들어맞는 <a href="http://www.cs.nott.ac.uk/~pszcah/G51ISS/Documents/NoSilverBullet.html">만병통치약은 없다</a>.</li><li><a href="https://medium.com/javascript-scene/composing-software-an-introduction-27b72500d6ea">Learning functional programming and compositional software techniques in JavaScript ES6+ 시리즈</a>: 함수형 프로그래밍을 주로 하던 개발자가 ES6 이후의 자바스크립트에 입문하고자 할 때 필요한 지식을 여러 글에 걸쳐 설명해주는 시리즈다. 기초 지식과 고급 개념이 섞여있긴 하지만 자바스크립트 개발자라면 시간을 들여 읽을 만하다.</li></ul><h3>블록체인</h3><ul><li><a href="https://steemit.com/kr/@project7/dapp">문돌이도 이해하는 스팀 디앱 (DApp)의 세계</a>: 비트코인 붐 이후로 블록체인 기술이 여기저기서 많이 들린다. 디앱(DApp, Decentralized Application)은 블록체인을 이용해서 만들어진 탈중앙화된 앱을 지칭한다. 많은 디앱들이 (게임 플랫폼 <a href="https://store.steampowered.com/">스팀Steam</a>이 아닌) <a href="https://steem.io/">스팀Steem</a>에 올라오는데, 그 생태계에 대해 설명해준 글이다.</li><li><a href="https://hackernoon.com/why-everyone-missed-the-most-important-invention-in-the-last-500-years-c90b0151c169">Why Everyone Missed the Most Important Invention in the Last 500 Years</a>: 지난 500년간 있었던 발명 중 가장 중요한 발명이 <a href="https://blockinpress.com/archives/3330">삼식부기(Triple-entry accounting)</a>라고 주장하는, 좀 방정맞게 쓰여졌지만 재밌었던 글이다. 내맘대로 요약해보면 대강 이렇다. 1) 5000년 전 ‘누가 나에게 얼마를 빌렸다’고 기록하는 단식부기를 통해 ‘거래’, 즉 경제활동이 시작되었다. 2) 600년 전, 사람들은 점점 더 멀리 있는 사람들 — 때론 얼굴 한 번 못 본 사람과도 거래를 시작했고, 기록이 기록으로 옮겨가면서 생기는 오류를 복식부기를 통해 줄일 수 있었다. 3) 그리고 2005년, 암호학자 <a href="https://twitter.com/iang_fc?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor">Ian Grigg</a>이 거래의 정당성을 탈중앙화된 제 3자가 담보하는 삼식부기 시스템을 선보였고, 그로부터 몇 년 후 비트코인이 등장했다. 삼식부기 시스템은 정말 많은 것들을 바꿔나갈 것이다.</li></ul><h3>기타 읽을거리</h3><ul><li><a href="https://brunch.co.kr/@yoojs8512/81">이 세대의 공부</a>: 중국의 대표적인 유료 구독 지식 플랫폼인 논리사유에서, 대표인 뤄전위가 자신의 200회에 걸친 방송을 마무리하면서 논한 ‘이 세대의 공부’에 대한 훌륭한 글이다. 뤄전위가 ‘지적 초조함’을 해결하기 위해 제시한 다섯가지 방법은 다음과 같다. 1) 책이 아닌 뛰어난 사람을 쫓아 공부하라. 2) 신 개념을 장악해 스스로의 지식 창고를 만들라. 새로운 정보를 어디에 둬야할지를 알 수 있기 때문. 3) 봉합하라. 정보는 스쳐지나갈 뿐 기억할 방법이 없다. 이를 봉합하기 위해 한 문장이라도 표현해야 한다. 4)파편화된 시간 속에서 할 수 있는 공부법을 찾아야만 한다. 5) 목표가 가장 중요하다. 확실한 목표가 있어야만 나아갈 수 있고 성과를 거둘 수 있다.</li><li><a href="https://medium.com/swlh/stop-trying-to-memorize-a-good-book-will-change-you-2bebafb22203">Stop Trying To Memorize — A Good Book Will Change You</a>: 위에서 나온 ‘지적 초조함’을 해소하는 또다른 방법. 어쩌면 위 글과 반대되는 것 같지만, 실제로는 보완해주는 방법을 알려주는 글이다. 좋은 글을 읽고 좋은 경험을 하면 자연스럽게 세상을 보는 모델이 달라질 것이므로, 읽은 것을 모두 기록하고 기억하려고 강박적으로 행동할 필요가 없다는 것.</li><li><a href="https://mobile.nytimes.com/2018/04/20/your-money/experts-david-baker.html">Fake Experts Abound. Here’s How to Find (and Be) a Real One.</a>: 사실 이 링크는 요즘 읽고 있는 <a href="https://www.amazon.com/Business-Expertise-Entrepreneurial-Experts-Convert/dp/1605440604">The Business of Expertise</a>라는 책의 영업글이다. 책 서론 부분에 대강 이런 말이 나오는데, 사실상 여기에 꽂혀서 책을 샀다. “지식은 패턴 인식에 기반하고, 패턴을 인지하려면 유사한 시나리오에 여러 번 노출되어야 하며, 그러려면 좋은 포지션을 잡아야 한다. 이게 전문성을 기르는 핵심이다.” 기술서적이 아니라서인지 단어가 너무 어려워서 수월하게 읽지는 못하고 있지만, 좋은 인사이트를 주는 책이다. 이거 읽느라 다른 글을 못읽고 있어 좀 아쉬울 뿐.</li><li><a href="https://medium.com/the-mission/5-essential-investments-every-human-being-should-make-in-themselves-121771565384">5 Essential Investments Every Human Being Should Make In Themselves</a>: 몸의 건강, 마음의 건강, 새로운 지식에 대한 공부, 전문성 기르기, 집/옷/차 등 물리적 환경. 이 다섯 가지에 충분히 돈과 시간을 투자해야 장기적으로 행복한 삶을 살 수 있다는 글이다.</li><li><a href="https://medium.com/@jungil.han/사이드-프로젝트-10년의-기록-파트-1-63bc25f8dcfc">사이드 프로젝트, 10년간의 기록</a>: <a href="https://medium.com/@jungil.han?source=post_header_lockup">한로니 님</a>이 10년간 사이드 프로젝트 25개를 개발하신 경험을 공유한 첫 번째 글이다. (2012년까지가 1부고 아직 2부가 안나왔다.) 사이드 프로젝트를 개발한다는 건 나를 포함하여 개발자의 로망 같은 것이다. 로망을 실현하신 분들을 보면 예전엔 멋지다, 부럽다고 생각했는데 지금은 ‘나도 해야지’로 바뀌게 된 게 재밌다.</li><li><a href="http://m.hbrkorea.com/magazine/article/view/7_1/page/1/article_no/1047">우리는 왜 관리역량을 과소평가하는가?</a>: 기존의 MBA에서는 기업이 내부 관리역량을 높여서 경쟁에서 이기려 해서는 안된다고 가르친다. 관리 프로세스는 쉽게 모방할 수 있기 때문에, 운영을 탁월하게 하는 게 중요하다는 것. 그러나 실제로는 1) 탁월한 프로세스를 쉽게 모방하기 어렵기 때문에, 2) 프로세스의 질적 차이가 시간이 지나도 줄어들지 않으며, 3) 효과적 관리 프로세스가 전략적 성공과 높은 상관관계가 있다. 이 글은 관리역량의 중요성과 함께 네 가지 영역 — 운영 관리, 성과 모니터링, 목표 설정, 인재 관리 영역에서의 핵심 관리 측면이 무엇인지 보여준다.</li></ul><p><em>Originally published at </em><a href="https://spilist.github.io/2018/05/29/articles-on-may-2018.html"><em>spilist.github.io</em></a><em> on May 29, 2018.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=549e802dc3c7" width="1" height="1"><hr><p><a href="https://medium.com/steady-study/2018%EB%85%84-5%EC%9B%94-%EC%9D%BD%EA%B3%A0-%EA%B3%B5%EB%B6%80%ED%95%9C-%EA%B2%83%EB%93%A4-549e802dc3c7">2018년 5월, 읽고 공부한 것들</a> was originally published in <a href="https://medium.com/steady-study">Steady Study</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[(번역) 아주 거대한 (자바스크립트) 어플리케이션을 구축하기]]></title>
            <link>https://medium.com/steady-study/%EB%B2%88%EC%97%AD-%EC%95%84%EC%A3%BC-%EA%B1%B0%EB%8C%80%ED%95%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%84-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0-3aa37fc45122?source=rss-c84770a5cabe------2</link>
            <guid isPermaLink="false">https://medium.com/p/3aa37fc45122</guid>
            <category><![CDATA[software-design]]></category>
            <category><![CDATA[software-development]]></category>
            <category><![CDATA[javascript]]></category>
            <dc:creator><![CDATA[Hwidong Bae]]></dc:creator>
            <pubDate>Sun, 27 May 2018 10:36:10 GMT</pubDate>
            <atom:updated>2018-05-27T10:36:10.040Z</atom:updated>
            <content:encoded><![CDATA[<pre>이 글은 <a href="https://medium.com/@cramforce">Malte Ubl</a>의 &quot;<a href="https://medium.com/@cramforce/designing-very-large-javascript-applications-6e013a3291a3">Designing very large (JavaScript) applications</a>&quot;의 번역입니다. <br>이해를 돕기 위해 원문에는 없는 소제목을 붙였으며 가독성을 떨어뜨리던 원문의 이미지들 중 일부를 의도적으로 첨부하지 않았고, 수많은 의역이 들어갔습니다. <br>이 글의 모든 권리는 원 저작자에게 있습니다만 번역하는 데에도 아주 고생했습니다. All rights are reserved to the original author.</pre><p>이 글은 호주 JSConf에서의 제 발표 스크립트를 약간 편집한 것입니다. <a href="https://www.youtube.com/watch?v=ZZmUwXEiPm4">유투브에서 전체 발표를 볼 수 있습니다</a>.</p><h3>들어가며.</h3><p>안녕하십니까. 저는 아주 거대한 자바스크립트 앱을 구축해왔습니다. 이젠 이런 일을 더이상 하지 않기 때문에, 제가 해온 일을 돌아보면서 무엇을 배웠는지 공유할 좋은 타이밍이라고 생각합니다.</p><p>어제 학회 파티장에서 맥주를 마시며 질문을 하나 받았는데요. “Malte, 당신이 이 주제에 대해 이야기할 만한 자격이 있다고 왜 생각하시나요?” 이 질문에 대답하는 것이 실제로 제 발표에 연관이 있다고 생각하기 때문에, 저 자신에 대해 이야기하는 게 익숙하지는 않지만 해보겠습니다.</p><p>저는 구글에서 자바스크립트 프레임워크를 만들었습니다. 그 프레임워크는 Photos, Sites, Plus, Drive, Play, 검색엔진 등 구글이 제공하는 서비스들에 사용되고 있죠. 개중 몇몇 사이트는 꽤 크고, 당신도 아마 몇 개는 써본 경험이 있으실 겁니다.</p><p>이 프레임워크는 오픈소스는 아닙니다. 그 이유는, 이 프레임워크가 React랑 비슷한 때에 나왔고, 제가 “사람들이 선택할 만한 자바스크립트 프레임워크를 더 늘릴 필요가 있을까?”라고 생각했기 때문입니다. 구글은 이미 오픈소스 자바스크립트 프로젝트를 몇 개 내놓은 상태였고(Angular와 Polymer), 또 하나가 추가되면 사람들이 혼란을 겪으리라 생각했기에, 그냥 우리끼리만 가지고 있자고 결정했습니다. 하지만 오픈소스가 아니었더라도, 이걸 만든 경험에서 배울 점이 많을 뿐더러 우리가 배운 걸 공유할 가치가 충분히 있다고 생각합니다.</p><h3>거대한 앱들의 공통점은 혼자 만드는 게 아니라는 것이다.</h3><p>이제 아주 거대한 앱에 대해, 그리고 그런 앱들이 가지는 공통점에 대해 이야기해봅시다. 거대한 앱은 그걸 개발하는 사람도 많겠죠. 수십 명일 수도 있고 더 많을 수도 있습니다. 당신은 이들에게 감정도 있고, 다른 사람들과의 사이에 문제도 있을 수 있다는 점을 염두에 두어야 합니다.</p><p>팀이 그렇게 크지 않더라도 여러가지 문제가 생길 수 있습니다. 당신이 그 앱을 개발하는 데 꽤 오랜 시간을 투자해왔을 수도 있고, 그 앱을 유지보수하는 첫 번째 사람이 아닐 수도 있고, 모든 컨텍스트를 가지지 않았을 수도 있고, 당신이 완전히 이해하지 못한 무언가가 있을 수도 있고, 팀 내의 누군가는 앱 전반에 대해 이해하지 못하고 있을 수 있습니다. 이런 게 우리가 아주 커다란 앱을 구축할 때 생각해야 할 사항들입니다.</p><h3>시니어의 다음 단계로 나아가는 길은 ‘공감’에 있다.</h3><figure><img alt="img" src="https://cdn-images-1.medium.com/proxy/1*fzb42X35lNGmkQHhJLhEBQ.png" /><figcaption><em>트윗: 주니어 개발자 없는 시니어 개발자 팀은 그냥 개발자 팀과 같다.</em></figcaption></figure><p>이 자리에서 얘기하고 싶은 또 하나의 주제는 커리어입니다. 여기 계신 많은 분들은 스스로가 시니어 개발자라고 생각하고 계실 겁니다. 또는, 아직은 시니어가 안 됐지만 되기를 원하고 있겠죠.</p><p>저는 시니어가 된다는 것의 의미를, 제게 주어지는 거의 모든 문제를 해결할 수 있는 능력이 있는 것으로 생각합니다. 적절한 도구와, 적절한 도메인 지식을 알고 있으니까요. 그리고 또 하나의 중요한 의미는, 주니어 개발자가 언젠가 시니어가 될 수 있도록 돕는 것입니다.</p><p>하지만 어느 순간에 우리는 “그럼 그 다음 단계는 뭐지?” 하고 의문을 가지게 됩니다. 시니어가 되고 나면 그 다음은 어디로 가야 할까요? 누군가는 ‘관리자’라고 대답하겠지만 그게 모두에게 적절한 답은 아닙니다. 모든 사람이 관리자가 될 순 없으니까요. 어떤 사람들은 정말 훌륭한 개발자인데, 여생동안 개발자로서 일하는 게 안될 게 뭡니까?</p><figure><img alt="img" src="https://cdn-images-1.medium.com/proxy/1*wL5wiTWICj1keue9YZOAhQ.png" /><figcaption><em>‘나’는 ‘내’가 어떻게 문제를 풀어야 할지 안다.</em></figcaption></figure><p>저는 시니어의 다음 단계로 가는 길을 하나 제시하고자 합니다. 시니어 개발자로서, 저는 “나는 내가 어떻게 문제를 풀어야 할지 안다”고 당당히 말할 수 있습니다. 그리고 제가 어떻게 문제를 풀지 알기 때문에, 저는 다른 사람이 어떻게 문제를 풀지 가르쳐줄 수도 있습니다.</p><figure><img alt="img" src="https://cdn-images-1.medium.com/proxy/1*UyLoKH7y54JAYigVlwCJpQ.png" /><figcaption><em>‘나’는 ‘다른 사람’이 어떻게 문제를 풀어야 할지 안다.</em></figcaption></figure><p>따라서 제가 생각하는 시니어의 다음 단계는, 스스로 “나는 <em>다른 사람</em>이 어떻게 문제를 풀어야 할지 안다”고 당당히 말할 수 있는 것입니다.</p><p>조금 더 구체적으로 말해보면 이렇습니다. “나는 내가 선택하는 API 또는 내가 프로젝트에 도입한 추상화가, 다른 사람이 문제를 푸는 데 어떤 영향을 미칠지 예상할 수 있다.” 저는 이 문장이, 내 선택이 앱에 어떤 영향을 미칠 것인지 생각해보게 하는 강력한 도구가 된다고 생각합니다.</p><p>이걸 ‘공감하며 앱 만들기(An application of Empathy)’ 라고 부를 수도 있습니다. 당신의 행동 하나하나와 당신이 다른 개발자에게 주는 API 하나하나가, 그들이 소프트웨어를 개발하는 데 어떤 영향을 미칠 것인지 생각해보는 것입니다.</p><p>다행히 이런 공감은 쉬운 수준에 속합니다. 공감하는 건 일반적으로 어렵고, 공감하며 앱 만들기도 결코 쉽진 않습니다. 하지만 당신히 공감해야 할 사람들은 적어도 소프트웨어 개발자일 것입니다. 그들이 당신과 많은 점이 다르더라도 모두 소프트웨어를 개발한다는 공통점이 있습니다. 당신이 경험을 쌓으면 쌓을수록 이런 공감은 더 잘 할 수 있게 됩니다.</p><h3>생각하는 방식(=프로그래밍 모델)을 변화시키는 결정은 신중해야 한다.</h3><p>공감에 대해 생각할 때 제가 이야기하고 싶은 아주 중요한 주제는 ‘프로그래밍 모델’입니다. 프로그래밍 모델은 “API, 라이브러리, 프레임워크, 도구 등 주어진 조건 하에서 사람들이 어떻게 소프트웨어를 개발하는가”를 뜻합니다. 사실 이 발표는 API와 기타 등등에 준 조그마한 변화가 프로그래밍 모델에 어떤 영향을 끼치는지에 대한 이야기이기도 합니다.</p><figure><img alt="img" src="https://cdn-images-1.medium.com/proxy/1*zuLA-tH9b8k4i1yfKMScmA.png" /><figcaption><em>프로그래밍 모델에 영향을 미치는 예: React, Preact, Redux, NPM에서 가져온 날짜 선택 라이브러리, NPM</em></figcaption></figure><p>무엇이 프로그래밍 모델에 영향을 끼치는지 몇 가지 예를 들어보죠. 당신이 Angular로 만들어진 프로젝트를 진행 중이고, “이제 이걸 React로 바꿔야겠어”라는 결정을 한다면, 이는 분명 사람들이 소프트웨어를 어떻게 작성하는지에 영향을 줄 겁니다. 하지만 “겨우 가상 DOM 다루는 데 60KB를 쓴다고? Preact로 바꾸자”라는 결정은, (Preact는 API 호환이 되는 라이브러리이기 때문에) 사람들의 소프트웨어 작성 방식을 바꾸지는 않을 것입니다.</p><p>그러고 나서 “앱이 너무 복잡해. 앱 동작을 조절하는 뭔가 필요하니 Redux를 쓰자”라는 결정을 내린다면, 이건 영향을 미칩니다. 이제 날짜 선택(Date picker) 기능이 필요해서 npm에서 검색해보니 결과가 500개 나왔고, 그 중 하나를 골랐다고 칩시다. 무엇을 골랐는지가 정말 중요할까요? 이건 소프트웨어 작성 방식을 변화시키진 않을 겁니다. 그러나 npm이라는 거대한 모듈의 집합을 능숙하게 사용할 줄 안다는 것은 분명 소프트웨어 작성 방식에 지대한 영향을 미칩니다. 물론 이것들은 겨우 몇 가지 예시일 뿐입니다.</p><h3>좋은 프로그래밍 모델은 결정을 사람이 아닌 시스템에 맡긴다.</h3><p>주제를 약간 바꿔서, 거대한 자바스크립트 앱을 사용자에게 배포하려 할 때 공통적으로 가지게 되는 문제에 대해 이야기해봅시다. 그 문제란 앱의 크기가 일정 이상 커지고 나면, 앱을 사용자에게 한꺼번에 전달하고 싶지 않아한다는 것입니다. 그래서 코드 분할을 도입하게 됩니다.</p><p>코드 분할이란, 앱을 번들(bundle, 코드 뭉치)의 집합으로 정의함을 뜻합니다. 즉 “어떤 사용자는 내 앱의 이 부분만 사용하고, 다른 사용자는 요 부분만 사용한다”는 것을 파악하고, 사용자가 실제로 실행하는 부분만 다운로드될 수 있도록 특정 코드를 묶어놓는 것입니다. 여기까지는 우리 모두가 할 수 있습니다. (자바스크립트 세계의 많은 기능들처럼 코드 분할도 클로저 컴파일러를 통해 만들어졌지만, 코드 분할을 하는 가장 널리 알려진 방법은 웹팩을 이용하는 것입니다. 당신이 RollupJS를 쓰고 있다면, 여기에서도 얼마 전부터 코드 분할을 지원하기 시작했다는 걸 알아두시기 바랍니다.)</p><p>코드 분할이 분명 우리 모두가 써야 하는 기술이긴 하지만, 당신의 앱에 이걸 도입하고자 할 때는 몇 가지 고려할 사항이 있습니다. 코드 분할은 프로그래밍 모델에 영향을 미치기 때문입니다.</p><figure><img alt="img" src="https://cdn-images-1.medium.com/proxy/1*vAR8HCbwiwX8bVa0xIsk6g.png" /><figcaption><em>동기 -&gt; 비동기.</em></figcaption></figure><p>코드 분할을 하면, 원래는 동기적으로 작동했던 것들이 비동기화됩니다. 코드 분할을 하기 전까지 당신의 앱은 단순하고 멋졌습니다. 커다란 것 하나만 있었죠. 일단 로드되고 나면 안정적이고, 이해하기 쉽고, 기다릴 필요가 없었습니다. 그러나 코드 분할 이후에는 때때로 “저 번들이 필요해”라며 네트워크를 거쳐야 할 것이고, 이 사실을 염두에 두어야 하기 때문에 앱이 좀더 복잡해집니다.</p><p>또한, 우리는 사람을 고려하기 시작해야 합니다. 코드 분할을 위해선 번들을 정의해야 하고, 그러려면 언제 번들을 불러올지 생각해야 하죠. 따라서 사람들, 즉 당신 팀의 동료 개발자들이 이제 번들에 무엇이 들어가고 언제 그걸 불러올지 결정을 내려야 한다는 게 됩니다. 이러한 것들을 고려해야 하기 때문에, 사람을 연관시키는 결정은 언제나 프로그래밍 모델에 분명한 영향을 미칩니다.</p><figure><img alt="img" src="https://cdn-images-1.medium.com/proxy/1*0jNa8A5ciY6pCJCN65vLiA.png" /><figcaption><em>경로 기반 코드 분할.</em></figcaption></figure><p>코드 분할에 있어서 사람을 복잡한 고려사항에서 빼버리는 좋은 방법으로 ‘경로 기반 코드 분할’이 있습니다. 아직 당신이 코드 분할을 하지 않고 있다면 아마 이 방법이 첫 번째로 시도해보기에 적절할 겁니다.</p><p>경로란 앱에서의 기본적인 URL 구조를 뜻합니다. 예를 들어 당신 앱의 /product/라는 경로 아래에 상품 페이지들이 있고, 다른 경로에 카테고리 페이지들이 있다고 해봅시다. 이 때 그냥 각 경로를 하나의 번들로 만들면 앱의 라우터가 코드 분할을 책임지게 됩니다. 사용자가 한 경로에 들어가면 라우터가 관련 번들을 불러올 것이므로, 해당 경로 안에서는 더이상 코드 분할을 신경쓸 필요가 없습니다. 당신은 다시 전체를 번들 하나로 두었던 옛 프로그래밍 모델과 거의 같은 방식으로 생각할 수 있게 되죠. 이와 같이 경로 기반 분할은 코드 분할의 첫 번째 단계로 아주 좋습니다.</p><p>안타깝게도 이 발표의 제목은 <strong>아주</strong> 거대한 자바스크립트 앱을 구축하는 것이었습니다. 앱이 너무 커져서 경로 하나하나조차 너무 커지면, 경로별로 하나씩 번들을 두는 게 적절치 않게 됩니다. 충분히 커다란 앱의 적절한 예를 하나 보여드리죠.</p><figure><img alt="img" src="https://cdn-images-1.medium.com/proxy/1*ox94bGuhxWXE-OubL7St6w.png" /><figcaption><em>“public speaking 101”의 구글 검색 결과.</em></figcaption></figure><p>저는 이 발표가 다가오면서 어떻게 좋은 연사가 될 수 있을지 알고 싶었고, 이러한 멋진 푸른색 링크 목록을 얻었습니다. 여러분은 이 페이지가 경로 기반 번들에 아주 적절하다고 생각할 수도 있을텐데요.</p><figure><img alt="img" src="https://cdn-images-1.medium.com/proxy/1*P-XiIPnuzq9_KLA1nG-uRA.png" /><figcaption><em>“날씨”의 구글 검색 결과.</em></figcaption></figure><p>캘리포니아의 겨울이 상당히 추웠다는 걸 기억하고 날씨를 검색해보니, 갑자기 완전히 다른 모듈이 나타납니다. 그러니까 이 단순해 보였던 경로가 사실은 더 복잡했다는 것이죠.</p><figure><img alt="img" src="https://cdn-images-1.medium.com/proxy/1*Y7e5LoeBggY01aRkJAiwWA.png" /><figcaption><em>“20 미국 달러는 호주 달러로 얼마인가”의 구글 검색 결과.</em></figcaption></figure><p>그리고 저는 이 학회에 초청되어 미국 — 호주의 달러 환율이 궁금해졌고, 이제는 복잡한 환율 계산 화면이 나타났네요. 이런 식의 전문화된 모듈이 수천 개는 있기 때문에, 이를 번들 하나에 몰아넣으면 용량이 수 메가바이트는 될 것이고, 사용자는 아주 불만족스러울 것입니다.</p><p>따라서 경로 기반 코드 분할을 그냥 쓸 수는 없고 다른 방법이 필요합니다. 경로 기반 분할이 좋았던 이유는, 앱을 가장 바깥쪽 단위에서 분할함으로써 그 안쪽에서는 코드 분할을 신경쓸 필요가 없었기 때문입니다. 저는 단순함을 좋아하니까, 가장 바깥쪽 대신 가장 안쪽에서 분할을 해보면 어떨까요? 웹사이트에 존재하는 모든 컴포넌트 하나하나를 지연 로딩한다고 가정해봅시다. 만약 사용자의 네트워크 대역폭 하나만 생각한다면 아주 효율적인 방법이 되겠죠. 응답시간 측면에서 보면 아주 안 좋겠지만, 적어도 고려할 가치는 충분히 있는 방법입니다.</p><p>하지만 예를 들어 당신의 앱이 React를 쓴다면 어떻게 될까요. React에서 컴포넌트는 자신의 자식 컴포넌트에 정적으로 의존합니다. 이는 당신이 자식 컴포넌트를 지연 로딩하면 React의 작동 방식이 변하게 되고, 프로그래밍 모델이 바뀌게 되고, 상황이 안좋아지게 된다는 뜻입니다.</p><p>자, 검색 페이지에 환율 계산기를 넣고 싶어졌다고 칩시다. import 를 하겠죠? 다음은 ES6 모듈을 import 하는 일반적인 방법입니다.</p><pre>import CurrencyConverter from &#39;./CurrencyConverter&#39;;</pre><p>이걸 지연 로딩하고 싶다면 아래와 같이 import 방법을 바꿔서 동적인 import를 해야 합니다. 저는 React 전문가도 아니고, 동적 import를 하는 수많은 방법이 있겠지만, 확실한 건 이렇게 함으로써 당신의 코드를 작성하는 방식이 달라진다는 것입니다.</p><pre>const LoadableConverter = Loadable({<br> loader: () =&gt; import(&#39;./CurrencyConverter&#39;),<br> loading: Loading,<br>});</pre><p>상황은 이제 그다지 좋지 않습니다. 정적이었던 것이 동적으로 바뀌었고, 이는 프로그래밍 모델이 변한다는 또다른 신호입니다. 이제 갑자기 “무엇을 언제 지연 로딩할 것인지 누가 정하는지”가 궁금해지기 시작합니다. 이 문제가 앱의 응답속도에 영향을 미치기 때문이죠.</p><p>사람이 다시 끼어들어서, “정적 import도 있고 동적 import도 있는데 무엇을 언제 사용해야 하는가?”를 결정해야 합니다. 이 결정을 잘못하면, 동적으로 했어야 했던 걸 정적으로 import하면서 같은 번들에 들어가면 안 되는 것들이 들어갑니다. 오랜 기간동안 많은 개발자가 함께 일하다 보면 이런 잘못된 일들이 벌어지기 마련이죠.</p><h3>구글은 코드 분할 문제를 어떻게 풀었는가.</h3><p>이제 구글이 실제로 이 문제를 어떻게 풀었는지, 그리고 좋은 성능과 좋은 프로그래밍 모델을 동시에 가져가는 방법에 대해서 얘기해보겠습니다. 우리는 먼저 컴포넌트를 렌더링 방식에 따라 분할하고, 그 다음 앱 로직에 따라 분할했습니다. 여기서 앱 로직이란, 예를 들어 사용자가 환율을 의미하는 쿼리를 검색했을 때 환율 변환기가 나타나게 하는 등의 동작을 뜻합니다.</p><p>따라서 특정 컴포넌트에서 사용되는 앱 로직은 오직 그 컴포넌트가 렌더되었을 때에만 로드됩니다. 이 방식은 보기보다 매우 단순한데, 단순히 서버 측에서 페이지를 렌더해놓은 다음, 실제로 사용자에게 무언가가 렌더되면 관련된 앱 번들이 다운로드되도록 하면 되기 때문입니다. 즉 로딩이 렌더링에 의해 자동으로 이루어지기 때문에 사람이 생각할 필요가 없어집니다.</p><figure><img alt="img" src="https://cdn-images-1.medium.com/proxy/1*Doqt-GOkUp13Qgk5r7WR1g.png" /><figcaption><em>검색 결과 페이지의 환율 변환기.</em></figcaption></figure><p>서버측 렌더링이 이렇게 좋아보이긴 하지만 사실 반대급부도 있습니다. React나 Vue.js 같은 프레임워크에서 서버측 렌더링은 hydration이라는 과정을 통해 이루어집니다. hydration의 작동 방식은 서버측에서 무언가를 렌더한 다음 클라이언트에서 한번 더 렌더하는 것입니다. 즉 코드의 로딩과 실행 양쪽에서 낭비가 생기죠. 이렇게 하면 CPU와 네트워크 대역폭에서 손해가 있지만, 대신 서버에서 무언가 렌더링했다는 사실을 클라이언트에서 무시할 수 있다는 점이 아주 좋습니다.</p><p>이렇듯 거대한 앱을 구축할 때는, 더 복잡한 대신 로딩과 렌더링이 아주 빠른 방법을 쓸지, 아니면 덜 효율적이지만 좋은 프로그래밍 모델을 제공하는 hydration을 쓸지 결정해야 합니다. 구글에서는 hydration을 사용하지 않는 걸 선택했습니다.</p><p><em>(역자 주: </em><a href="https://reactjs.org/docs/react-dom.html#hydrate"><em>React에서의 hydration</em></a><em>은 단순히 클라이언트가 한번 더 렌더링하는 게 아니라, 서버가 렌더링한 마크업이 존재한다면 새로 클라이언트가 렌더하지 않고 이벤트 핸들러만 bind시켜서 첫번째 로딩이 빨라지게 만드는 방법입니다. 발표자의 말과 약간 차이가 있는 듯해 첨언합니다만, 제가 발표자의 의도를 정확히 이해하지 못했을 수 있습니다. 이 단락은 전체적으로 모호한 부분이 많아서 원본 유투브 영상을 보고 많은 부분을 의역했습니다. )</em></p><h3>코드를 지우기 쉬운 구조로 만드는 것은 아주 중요하다.</h3><figure><img alt="img" src="https://cdn-images-1.medium.com/proxy/1*uteTbmuKZF1wGvoysgsBYw.png" /></figure><p>제 다음 주제는 제가 컴퓨터과학 분야에서 가장 좋아하는 문제에 대한 것입니다. 아, 이름 짓기 문제는 아닙니다. 이미 이 문제를 안좋은 이름으로 지었을 수는 있겠습니다만… 문제의 이름은 “2017 특별 휴일 문제” 입니다. 여기 계신 분들 중 이제 더이상 쓰이지 않지만 여전히 코드베이스에 남아있는 코드를 작성해본 적 있으시다면 손을 들어보세요.</p><p>제 생각에 이런 일은 특히 CSS에서 많이 벌어지는 것 같습니다. 거대한 CSS 파일이 하나 있고, 셀렉터도 하나 있습니다. 당신의 앱 어디에 이 셀렉터가 여전히 쓰이고 있는지 대체 누가 제대로 알 수 있을까요? 그래서 결국 그 셀렉터를 그대로 놔두게 됩니다. 최근에는 이런 문제를 자바스크립트 안에 CSS를 작성하는 방법(CSS-in-JS)으로 해결하는 듯합니다. 이 방법을 쓰면, 2017HolidaySpecialComponent라는 컴포넌트를 이제 2017년이 아니라는 이유로 지우게 될 때 모든 게 함께 지워집니다. 코드를 지우기 아주 쉬워지는 거죠. 저는 이게 엄청나게 좋은 아이디어이고, CSS뿐만 아니라 다른 곳에도 적용되어야 한다고 생각합니다.</p><p>이와 같이 설정을 한 곳에 모아두면 코드를 삭제하기가 아주 어려워지기 때문에, ‘중앙 설정’이 만들어지는 것을 최대한 피하는 것이 좋습니다. 몇 가지 예를 들어보겠습니다.</p><p><strong>나쁜 예 1: routes.js</strong></p><p>앞에서 경로에 대한 얘기를 했었는데요. 많은 앱들이 routes.js같은 파일에 앱에서 사용하는 모든 경로를 정의해놓고, 거기서 다른 컴포넌트를 불러오는 식으로 만들어졌을 것입니다. 이게 바로 거대한 앱에서는 피해야 하는 중앙 설정의 예시입니다. 이 상황에서 어떤 개발자는 이렇게 생각할 것입니다. “이 컴포넌트가 아직 필요한 건가? 다른 파일로 교체하긴 해야 하는데, 이 컴포넌트는 다른 팀이 만든 거라서 내가 바꿔도 되는지 잘 모르겠네. 그냥 내일 작업해야겠다.” 이렇게, 중앙 설정 파일은 항상 무언가가 새로 추가되기만 하게 됩니다.</p><p><strong>나쁜 예 2: webpack.config.js</strong></p><p>다른 안좋은 예는 전체 앱을 빌드하는 데 필요한 모든 설정이 들어가있는 webpack.config.js 파일인데요. 개발 초기에는 이래도 괜찮지만, 언젠가부터 다른 팀에서 앱의 어디를 어떻게 고쳤는지를 다 알아야 하는 상황이 오게 됩니다. 앱 규모가 커질수록 알기가 어렵죠. 따라서 빌드 과정의 설정을 탈중앙화하기 위한 패턴이 필요합니다.</p><p><strong>좋은 예: package.json</strong></p><p>npm에서 사용하는 package.json이 탈중앙화의 좋은 예입니다. 각 패키지에는 “난 이런 패키지들에 의존하고, 실행 방법은 이거고, 빌드 방법은 이거야”라는 게 정의되어 있습니다. 모든 npm 패키지에 대한 설정을 파일 하나에 모아놓는 건 불가능합니다. 연관된 파일이 수천 수만 개에 달하기 때문입니다.</p><p>npm은 당신의 앱과 비교하기에 너무 거대한 예시일 순 있겠지만, 모든 앱은 어느정도 이상 커지면 중앙 설정의 문제점을 생각해야 하고, package.json과 비슷한 패턴을 적용할 필요가 있습니다. 모든 종류의 중앙 설정에 대해 제가 해결책을 가진 건 아니지만, ‘자바스크립트 안에 작성하는 CSS’의 아이디어가 여러 곳에 적용될 수 있을 것이라고 생각합니다.</p><p>이 문제를 조금 더 추상화해보면 <em>앱의 의존성 트리의 모양을 결정하기</em> 라고 부를 수 있겠습니다. 여기서 “의존성”은 넓은 의미로 보시면 되는데, 모듈 의존성 / 데이터 의존성 / 서비스 의존성 등 여러가지 의존성을 뜻할 수 있습니다.</p><h3>enhance 개념을 이용한 의존성 관리.</h3><figure><img alt="img" src="https://cdn-images-1.medium.com/proxy/1*Y9AgFj90bpFsKq6e7o7Jbw.png" /><figcaption><em>라우터와 루트 컴포넌트 3개가 있는 의존성 트리의 예시. 라우터가 루트 컴포넌트들을 import한다.</em></figcaption></figure><p>우리의 실제 앱들은 엄청나게 복잡하지만 제 예시는 아주 단순합니다. 이 예시는 컴포넌트가 4개뿐입니다. 한 경로에서 다른 경로로 어떻게 움직일지에 대한 정보가 모여있는 라우터 하나와, 루트 컴포넌트 A, B, C입니다.</p><p>앞서 말했듯 이 예시 앱은 중앙집중적 import 문제를 가질 수 있습니다. 라우터가 모든 루트 컴포넌트들을 import하기 때문에, 루트 컴포넌트 하나를 지우려면 라우터에 가야 하고, 거기서 import문을 지워야 하고, 경로 정의도 지워야 하고, 결국 “2017 특별 휴일 문제”를 겪게 됩니다.</p><p>구글에서는 이 문제의 해결책으로 지금까지 한번도 공개된 적 없는 컨셉을 만들었습니다. enhance라는 건데요. enhance는 import 대신 사용하여 역 의존성을 나타낼 수 있습니다. 한 컴포넌트가 모듈을 enhance하면, 그건 그 모듈이 컴포넌트에 대한 의존성이 있음을 뜻합니다.</p><figure><img alt="img" src="https://cdn-images-1.medium.com/proxy/1*bDH4yzG0mrrYlrs2C9twsA.png" /><figcaption><em>루트 컴포넌트들이 라우터를 enhance한다.</em></figcaption></figure><p>위 그림을 보시면 다른 건 같지만 화살표 방향이 거꾸로입니다. 라우터가 루트 컴포넌트를 import하는 대신, 루트 컴포넌트들이 enhance를 이용하여 자신의 존재를 라우터에게 알립니다. 즉 루트 컴포넌트 파일 하나만 지우면 관련된 정보를 다 지울 수 있다는 뜻입니다.</p><p>‘사람 문제’만 아니었다면 enhance는 아주 멋진 방법이었을 것입니다. 사람들은 이제 이런 걸 생각해야 합니다. “import와 enhance 중 뭘 써야 하지? 어떤 조건에서 무엇을 쓰는 게 좋을까?” 이건 사람 문제에서 특히 안좋은 케이스인데, enhance라는 개념이 무척 강력한 만큼 잘못 쓰이면 너무 위험하기 때문입니다.</p><p>따라서 구글에서는 오직 ‘생성된 코드’를 제외하고는 누구도 enhance를 하지 못하도록 정했습니다. 실제로 enhance를 사용하는 것은 생성된 코드와 아주 잘 어울리기도 하고, 생성된 코드의 본질적 문제 중 몇 가지를 해결해주기도 합니다. 생성된 코드는 눈에 보이지 않기 때문에, 이름을 추측해서 import해야 할 때가 가끔 생깁니다. 하지만 생성된 파일이 그저 뒤편에 있으면서 뭔가 필요할 때마다 enhance를 한다면 이런 문제는 사라집니다. 당신은 생성된 파일들에 대해 알 필요가 전혀 없어지고, 그 파일들은 모두 마법처럼 중앙 저장소(central registry)로 enhance합니다.</p><p>좀 더 구체적인 예시를 들어보죠. 파일 컴포넌트 하나가 있습니다. 여기에 코드 생성기를 돌려서 경로 정의가 담긴 작은 파일을 추출합니다. 그 경로 파일은 라우터에게 “나 여기 있어. import 해줘”라고 말합니다. 이 패턴은 여러 군데서 쓰일 수 있습니다. GraphQL을 사용하는 분은 라우터가 데이터 의존성에 대해 알고 있어야 할텐데, 이 때도 enhance와 비슷한 패턴을 사용할 수 있습니다.</p><p><em>(역자 주: 사실 저는 이 예제까지 봐도 enhance를 구체적으로 어떻게 사용한다는 것인지 정확히 이해하지 못했습니다. 원문의 댓글에서 많은 사람들이 더 자세한 예시를 달라고 하는 걸 보면 저만 그런 건 아닌 듯합니다. Malte는 </em><a href="https://medium.com/@pkursawe/could-you-post-a-concrete-source-example-of-enhance-i-think-its-a-kind-of-di-282218ed8378"><em>한 댓글</em></a><em>에서, enhance는 복잡한 어떤 개념이 아니고 import와 비슷한 수준의 추상화이며, </em><a href="http://wiki.c2.com/?RegistryPattern"><em>regstry pattern</em></a><em>을 생각하면 된다고 말했습니다.)</em></p><h3>기본 번들의 크기가 커지지 않도록 조심하라.</h3><p>제가 2017 특별 휴일 문제 다음으로 좋아하는 문제는 “쓰레기가 쌓인 기본 번들” 문제입니다. 기본 번들이란 사용자가 앱을 어떻게 사용하든 간에 언제나 로드되는 번들을 뜻합니다. 기본 번들이 특히 중요한 이유는 기본 번들이 커지면 그에 의존하는 모든 번들이 커질 것이기 때문입니다.</p><p>제가 구글 플러스 앱의 자바스크립트 인프라 팀에 들어갔을 때 앱의 기본 번들 크기는 800KB였습니다. 그러니까 당신이 구글 플러스보다 더 성공하는 앱을 만들고 싶다면, 적어도 800KB의 자바스크립트로 된 기본 번들은 가지지 않도록 하세요. 물론 안타깝게도, 그런 안좋은 상태가 되기란 매우 쉽습니다.</p><figure><img alt="img" src="https://cdn-images-1.medium.com/proxy/1*wW_u72nFdPiKjEINH4ubDg.png" /><figcaption><em>3가지 다른 의존성을 가진 기본 번들.</em></figcaption></figure><p>예시를 보죠. 기본 번들은 경로에 대해 알고 있어야 합니다. A 경로에서 B 경로로 가려면 이미 B에 대해 알고 있어야 하니까요. 그러나 기본 번들에 UI에 관련된 코드는 절대 포함되지 않아야 하는데, 사용자가 어떤 방법으로 앱에 접속하느냐에 따라 다른 UI를 보여줄 것이기 때문입니다. 즉 날짜 선택 폼이나 결제 플로우 같은 것들을 기본 번들에서 빼내야 하는 거죠.</p><p>그렇지만 이걸 어떻게 보장할 수 있을까요? import는 이런 점에서 아주 취약합니다. 당신이 무작위 숫자를 생성하는 기능이 필요해서 <em>util</em> 이라는 패키지를 기본 번들에서 import했다고 칩시다. 그러면 누군가가 “자동 주행하는 utility 기능이 필요한데?”라고 하는 순간 기본 번들에 자동 주행을 위한 기계학습 알고리즘이 포함되는 것입니다. import는 전이되기 때문에 (<em>역자 주: A가 B를 import하고 B가 C를 import하면 A가 C에도 의존하게 됩니다.</em>) 이런 일은 쉽게 일어날 수 있고, 시간이 지남에 따라 기본 번들이 커지게 됩니다.</p><p>구글에서 찾은 이 문제의 해결책은 <em>의존성 금지 테스트</em> 입니다. 이 테스트는, 예를 들어 기본 번들이 아무런 UI에도 의존하지 않도록 보장하기 위한 테스트입니다. React로 따지면, React의 모든 컴포넌트는 React.Component 를 상속해야 합니다. 따라서 React 앱의 기본 번들에 UI가 포함되지 않기를 원한다면 기본 번들이 React.Component 에 의존하지 않음을 보장하는 테스트를 추가하면 됩니다.</p><figure><img alt="img" src="https://cdn-images-1.medium.com/proxy/1*s5rDafWJi90dcrlEQSAepg.png" /><figcaption><em>금지된 의존성들은 배제되었다.</em></figcaption></figure><p>앞의 예시를 다시 들어보면, 이제 누군가가 날짜 선택 폼을 추가하려고 할 때 테스트가 실패할 것입니다. 그리고 이런 테스트 실패는 고치기 쉬운데, 사람들이 정말 그 의존성을 기본 번들에 추가하려고 했다기보다는 import의 전이 과정에서 기본 번들이 날짜 선택 폼에 의존하게 되는 경우가 많기 때문입니다. 이러한 테스트 없이 2년 정도가 지났다고 생각해 보세요. 그때 가서 기본 번들의 의존성 문제를 해결하기는 엄청나게 어려워질 것입니다.</p><h3>마치며.</h3><p><strong>1. 개발자가 옳은 방향으로 가도록 보장하는 테스트를 추가하라.</strong></p><p>당신은 팀의 개발자가 어떤 일을 하든 간에, 가장 직관적인 방법이 옳은 방법이 되는 상태가 되기를 원할 것입니다. 그들이 길을 잃지 않고 자연스럽게 옳은 행동을 할 수 있도록요.</p><p>현재 그런 상태가 아니라면, 그를 보장하는 테스트를 추가하세요. 많은 분들이 놓치는 것인데, <strong>당신의 앱 인프라에서 주요하게 지켜져야 하는 부분(major invariants of infrastructure)을 보장하는 테스트를 추가하는 걸 주저하지 마세요</strong>. 테스트는 수학 함수가 제대로 동작하는지만을 위한 것이 아닙니다. 앱의 인프라나 구조에 대해서도 테스트해야 합니다.</p><p><strong>2. 인간이 판단해야 할 상황을 되도록이면 피하라.</strong></p><p>앱을 구축하려면 비즈니스에 대해 이해할 필요가 있지만, 모든 개발자가 그럴 순 없습니다. 코드 분할도 마찬가지죠. 모든 개발자가 코드 분할이 어떻게 동작하는지 이해할 필요는 없습니다. 이런 것들 — 비즈니스 로직이나 코드 분할과 같은 것들을 도입할 때, 모든 개발자가 이해하지 않아도 그들이 잘 작업할 수 있도록 하는 방식으로 도입하도록 노력하세요.</p><p><strong>3. 코드를 삭제하기 쉬운 구조로 만들어라.</strong></p><p>코드를 지우기 쉽게 만드는 건 정말 중요합니다. 이 발표가 “아주 거대한 자바스크립트 앱을 구축”하는 것에 대해서인데요. 제가 해드릴 수 있는 최고의 조언은, “애초에 앱이 아주 거대해지지 않도록 하라”입니다. 그러기 위한 가장 좋은 방법은 너무 늦기 전에 코드를 지워나가는 것입니다.</p><p><strong>4. 공감과 경험을 통해 올바른 추상화를 도입하기 위해 노력하라.</strong></p><p>“잘못된 추상화를 도입할바에는 추상화를 하지 말라”는 말이 있는데요. 저는 이 말을 오해하는 분들을 종종 봅니다. 이 말이 뜻하는 바는 잘못된 추상화가 아주 커다란 비용을 야기하기 때문에 무척 조심해야 한다는 것입니다. 정말로 추상화를 하지 말라는 게 아닙니다. 아주 신중하게 하라는 뜻이죠.</p><p>발표 초반에 이야기했듯, 좋은 추상화로 가기 위한 방법은 팀의 개발자들에게 공감하고, 함께 생각하는 것입니다. 그들이 API와 추상화를 어떤 식으로 사용하게 될 것인지에 대해서요. 경험이 쌓이면 공감능력에 살을 붙여나갈 수 있습니다. 공감과 경험을 통해 당신은 당신의 앱에 적절한 추상화를 찾아낼 수 있을 것입니다.</p><p>이 발표가 흥미로웠다면 <a href="https://medium.com/@cramforce/design-docs-a-design-doc-a152f4484c6b">문서화에 대한 제 글</a>도 읽어보시길 권해드립니다. 감사합니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3aa37fc45122" width="1" height="1"><hr><p><a href="https://medium.com/steady-study/%EB%B2%88%EC%97%AD-%EC%95%84%EC%A3%BC-%EA%B1%B0%EB%8C%80%ED%95%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%84-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0-3aa37fc45122">(번역) 아주 거대한 (자바스크립트) 어플리케이션을 구축하기</a> was originally published in <a href="https://medium.com/steady-study">Steady Study</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
    </channel>
</rss>