<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by 최창원 on Medium]]></title>
        <description><![CDATA[Stories by 최창원 on Medium]]></description>
        <link>https://medium.com/@qwefgh90?source=rss-74ad5d76277f------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/2*LXMDXBAStDp3E1otY8wtbA.jpeg</url>
            <title>Stories by 최창원 on Medium</title>
            <link>https://medium.com/@qwefgh90?source=rss-74ad5d76277f------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Tue, 14 May 2019 00:07:51 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@qwefgh90" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[자바스크립트와 this 바인딩]]></title>
            <link>https://medium.com/@qwefgh90/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-this-%EB%B0%94%EC%9D%B8%EB%94%A9-9a0571f2e09?source=rss-74ad5d76277f------2</link>
            <guid isPermaLink="false">https://medium.com/p/9a0571f2e09</guid>
            <category><![CDATA[this-binding]]></category>
            <category><![CDATA[execution-context]]></category>
            <category><![CDATA[dom]]></category>
            <category><![CDATA[js]]></category>
            <category><![CDATA[javascript]]></category>
            <dc:creator><![CDATA[최창원]]></dc:creator>
            <pubDate>Wed, 16 Jan 2019 00:00:00 GMT</pubDate>
            <atom:updated>2019-04-16T06:05:49.109Z</atom:updated>
            <cc:license>http://creativecommons.org/licenses/by/4.0/</cc:license>
            <content:encoded><![CDATA[<p>다른 프로그래밍 언어와 마찬가지로 자바스크립트에서도 this를 잘사용하면 코딩이 쉬워집니다. 하지만 this가 동작하는 방식이 다양하여 초기에 개념을 잘못잡으면, 잘못된 코드를 작성하게 됩니다. this의 바인딩(binding)이 어떻게 일어나는지 알아보겠습니다.</p><p>간단하게 this의 동작을 요약하면 <strong>this를 사용하는 함수가 어떤 방식으로 호출되느냐에 따라 this에 다른 객체가 바인딩됩니다.</strong></p><h3>객체의 메서드(프로퍼티)로서 함수가 호출될때</h3><p>이는 어떤 객체나 멤버 <strong>메서드로서 호출되는 경우</strong> 객체가 this에 바인딩 됩니다.</p><p>아래 코드가 콘솔에 무엇을 출력할지 생각봅시다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/fc5f727ff2e500b948224fc79aecd0b7/href">https://medium.com/media/fc5f727ff2e500b948224fc79aecd0b7/href</a></iframe><h3>단순히 함수 이름으로 호출될때</h3><p>어떤 실행 문맥에 선언된 함수가 <strong>바로 호출될 경우</strong> this에 전역 객체(window, global)가 바인딩됩니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f06c923e409729fc06b017819bd8c6db/href">https://medium.com/media/f06c923e409729fc06b017819bd8c6db/href</a></iframe><h3>생성자로서 함수가 호출될때</h3><p>함수가 <strong>생성자로서 호출되면</strong> 생성될 객체 자기자신이 this에 바인딩됩니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ae18ee5005ee948bac3be02df451d36b/href">https://medium.com/media/ae18ee5005ee948bac3be02df451d36b/href</a></iframe><p><em>Originally published at </em><a href="http://qwefgh90.github.io/javascript/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-this-%EB%B0%94%EC%9D%B8%EB%94%A9/"><em>qwefgh90.github.io</em></a><em> on January 16, 2019.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9a0571f2e09" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Great article! You saved my time.]]></title>
            <link>https://medium.com/@qwefgh90/great-article-you-saved-my-time-fb717df85f6d?source=rss-74ad5d76277f------2</link>
            <guid isPermaLink="false">https://medium.com/p/fb717df85f6d</guid>
            <dc:creator><![CDATA[최창원]]></dc:creator>
            <pubDate>Fri, 01 Dec 2017 07:21:21 GMT</pubDate>
            <atom:updated>2017-12-01T07:21:21.891Z</atom:updated>
            <content:encoded><![CDATA[<p>Great article! You saved my time.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fb717df85f6d" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[함수형 프로그래밍의 예외처리]]></title>
            <link>https://medium.com/@qwefgh90/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC-c7e279e4d434?source=rss-74ad5d76277f------2</link>
            <guid isPermaLink="false">https://medium.com/p/c7e279e4d434</guid>
            <category><![CDATA[functional-programming]]></category>
            <category><![CDATA[fps]]></category>
            <category><![CDATA[scala]]></category>
            <category><![CDATA[exception]]></category>
            <category><![CDATA[java]]></category>
            <dc:creator><![CDATA[최창원]]></dc:creator>
            <pubDate>Sat, 21 Oct 2017 00:00:00 GMT</pubDate>
            <atom:updated>2019-04-16T05:23:39.698Z</atom:updated>
            <cc:license>http://creativecommons.org/licenses/by/4.0/</cc:license>
            <content:encoded><![CDATA[<p>함수형 프로그래밍 관점에서 예외(Exception)의 문제점을 알아보고, 함수형 프로그래밍에서 안전하게 예외를 다루는 방법을 알아보겠습니다</p><p>OOP의 점검 예외(Checked Exception)나 미점검 예외(Unchecked Exception, Runtime Exception)는 매번 적절하게 다뤄줘야합니다. 점검 예외는 try…catch 구문을 사용하여 다룰 수 있으며, 런타임 예외는 컴파일 시점에 검증되지 않기 때문에 프로그램을 실패하게 할 수 있습니다. 따라서 API 개발자는 런타임 예외가 발생하는 조건을 문서에 작성하여 개발자들이 올바르게 코딩할 수 있도록 도와주어야 합니다. <a href="http://qwefgh90.github.io/sphinx/java/java_basic.html#id6">링크에 점검 예외와 런타임 예외에 대한 설명이 있습니다.</a></p><p>함수형 프로그래밍에서 런타임 예외는 부수 효과를 발생 시키는 표현식일 뿐입니다. 참조 투명성을 해치게 될 경우 함수형 프로그래밍의 장점을 취할 수 없게됩니다.</p><h3>1. 참조 투명성 위반</h3><p><strong>검증하는 예제는 다음과 같습니다.</strong></p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/b53853bd7d397a1182446aacec600321/href">https://medium.com/media/b53853bd7d397a1182446aacec600321/href</a></iframe><p><strong>위와 같이 일부 표현식만 치환해보아도 concat 함수는 참조 투명하지 않다는 걸 확인할 수 있습니다.</strong> 이는 예외가 문맥 의존적이기(context dependent) 때문입니다.</p><p>예외는 크게 2가지 문제를 갖고 있습니다.</p><ol><li>위 예시처럼 참조투명성을 위반하고 문맥 의존성을 도입합니다.</li><li>형식에 안전하지 않습니다. <strong>concat</strong>의 <strong>메서드 시그니처만 봐서는 어떤 예외를 던질 지 알 수 없습니다.</strong></li></ol><p><strong>특히 일반적인 고차함수는 전부 람다식을 받는데 람다식은 점검예외를 발생시키지 않으므로 컴파일 타임에 점검되지 않습니다.</strong> (일반적인 자바의 function 패키지 클래스들은 점검 예외를 던지는 것은 허용하지 않습니다.)</p><p>점검 예외라서 해결되더라도 try…catch와 같은 판에 박힌 코드를 작성해야 합니다<strong>.</strong></p><p>자주 사용되는 해결방법은 예외를 던지는 대신 <strong>경계값이나 null을 반환해서 해결하는 것 입니다. 예를들어 0으로 나눌 수 없을 경우 null이나 -1을 반환하는 것 입니다.</strong></p><p>위의 방법은 몇가지 문제를 갖고 있습니다.</p><ul><li>먼저 함수에서 정상적으로 처리되었는지 확인할 수 없습니다.</li><li>오류가 소리소문 없이 전파됩니다.</li><li>경계값이나 null 둘다 적용 안되는 경우가 있습니다.</li><li>호출자에게 위와 같은 특별한 규약을 전달해야합니다.</li></ul><p><strong>경계값을 사용할 수 없는 대표적인 예시는 다음과 같습니다.</strong></p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/507fae36724272004a44d976de5be5a0/href">https://medium.com/media/507fae36724272004a44d976de5be5a0/href</a></iframe><h3>2. Option, Either을 이용한 해결방법</h3><p>실제로 함수형 언어(스칼라)에서는 프로그램이 처리할 수 없을때나 예외가 발생했을때 사용할 수 있는 특별한 타입을 제공합니다.</p><ul><li>Option[R]: 입력을 처리할 수 없을때 사용할 수 있는 타입(자바의 Optional)</li><li>Either[T,R]: 어떤 예외가 있는지 표현할 수 있는 타입</li></ul><p>이러한 타입은 map(), flatMap(), filter(), getOrElse() 등의 고차함수를 통해 예외 처리를 통합할 수 있습니다.</p><p><strong>장점은 다음과 같습니다.</strong></p><ul><li>타입에 안전합니다. 따라서 개발자는 이를 인지하게되고 오류가 줄어듭니다.</li><li>오류가 발생하지 않았다는 연속하여 가정하에 계산 로직을 합성할 수 있습니다. getOrElse()을 활용하여 필요한 경에만 오류에 대한 처리를 할 수 있습니다.</li></ul><p><strong>Optional을 사용하는 예시입니다.</strong></p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e5bc84c8350a215e9065f305f2d5e378/href">https://medium.com/media/e5bc84c8350a215e9065f305f2d5e378/href</a></iframe><h3>참조</h3><ul><li>함수형 프로그래밍 : 스칼라로 배우는 함수형 프로그래밍(서적)</li></ul><p><em>Originally published at </em><a href="http://qwefgh90.github.io/fp/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC/"><em>qwefgh90.github.io</em></a><em> on October 21, 2017.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c7e279e4d434" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[동시성 프로그래밍 모델의 필요성]]></title>
            <link>https://medium.com/@qwefgh90/%EC%83%88%EB%A1%9C%EC%9A%B4-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%AA%A8%EB%8D%B8%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1-5682f91ebe4a?source=rss-74ad5d76277f------2</link>
            <guid isPermaLink="false">https://medium.com/p/5682f91ebe4a</guid>
            <category><![CDATA[call-stack]]></category>
            <category><![CDATA[java]]></category>
            <category><![CDATA[concurrent-programming]]></category>
            <category><![CDATA[akka]]></category>
            <category><![CDATA[encapsulation]]></category>
            <dc:creator><![CDATA[최창원]]></dc:creator>
            <pubDate>Wed, 18 Oct 2017 00:00:00 GMT</pubDate>
            <atom:updated>2019-04-16T05:46:25.677Z</atom:updated>
            <cc:license>http://creativecommons.org/licenses/by/4.0/</cc:license>
            <content:encoded><![CDATA[<p>현대의 서비스들은 수요에 비례하여 많은 분산 시스템을 구축하고 있고, 그 과정에서 전통적인 객체지향 프로그래밍으로 해결되지 않는 여러가지 문제가 발견되고 있습니다. 특히, 여러개의 스레드(threads)를 효율적으로 사용하는 동시성 프로그래밍(Concurrent programming) 을 지원하지 못합니다.</p><p><em>기본적으로 공유자원 접근시 발생할 수 있는 문제는 레이스 컨디션, 메모리 가시성, 데드락 등이 있습니다.</em></p><h3>캡슐화의 문제</h3><p>첫번째 주제는 <strong>캡슐화(encapsulation)의 문제점 입니다.</strong> 객체 지향 프로그래밍의 핵심 객념중 하나로, 외부에서 직접적으로 내부 데이터에 접근하는 것을 막고, 잘 설계된 메서드를 통해 접근하게 하는 것 입니다. 객체(Object)는 안전한 연산을 제공하여 내부 데이터를 지킬 의무가 있습니다. 예를들어, 정렬된 이진 트리의 어떤 연산에 의해 임의로 순서가 변경되어서는 안됩니다. 보통 호출자는 이러한 정렬 불변성을 믿고 트리를 사용합니다.</p><p>다음과 같이 동작하는 프로그램이 있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/7ebddd2b5eec6c56c9fb52f53128c472/href">https://medium.com/media/7ebddd2b5eec6c56c9fb52f53128c472/href</a></iframe><p>첫번째 스레드와 두번째 스레드의 a.call() 호출이 거의 겹친다고 가정했을때, <strong>캡슐화 모델은 이런 상황에서 아무것도 보장할 수 없습니다.</strong></p><p>두개의 호출의 명령어는 서로 교차로 실행 되고 자료구조의 불변성을 유지하기 어렵게 만듭니다. 스레드가 3개 이상이라면 상황은 더욱 더 복잡해집니다. <strong>일반적인 해결책은 메서드에 잠금을 추가하여 해결하는 것 입니다.</strong> 스레드가 순서대로 1개씩 메서드에 진입할 수 있습니다. 이 해결책에는 크게 2가지의 문제점이 있습니다.</p><ul><li>잠금은 동시성을 제한하고 멀티 CPU를 제대로 활용하지 못합니다. 컨텍스트 스위칭 비용도 발생하게 됩니다.</li><li>호출자 스레드는 블로킹이 되며 다른 의미있는 작업을 할 수 없습니다. 예를들면, UI 스레드는 UI 관련 작업만 수행해야 합니다.</li><li><strong>데드락 문제를 발생시킬 수 있습니다.</strong></li><li>일반적인 잠금은 분산환경을 잘 지원할 수 없습니다. 일반적으로 분산 잠금은 스케일 아웃을 제한하고 여러대의 머신을 왕복하면서 네트워크 지연이 높아지게 됩니다.</li></ul><p><strong>잠금 사용이 최선은 아닙니다.</strong></p><ul><li>잠금을 사용하면, 성능 문제와 데드락 문제가 발생</li><li>잠금을 사용하지 않으면 상태가 오염되는 문제가 발생</li></ul><h3>공유 메모리에 대한 환상(illusion)</h3><p>80~90년대의 프로그래밍 모델에서 변수에 값을 쓰고 메모리에 바로 반영되는것이 개념화되었습니다. 하지만 <strong>현대 아키텍처에서는 CPU는 메모리 대신 캐시(cache)에 값을 씁니다.</strong> 각 캐시들은 각 CPU 코어에 연결되어 있고, 캐시에 쓰인 값은 다른 코어에 보이지 않습니다.</p><p>JVM 에서는 스레드간에 같은 값을 볼 수 있도록 volatile이나 Atomic을 사용할 수 있습니다. 그렇지 않으면 잠금을 얻는 구간에서만 같은 값을 볼 수 있습니다. 모든 변수를 volatile로 선언하면 값을 매번 다른 메모리에 값을 기록해야 하므로, 매우 많은 비용이 발생합니다. (병목구간 발생이 발생한다고 볼 수 있습니다.)</p><p><strong>공유 메모리에는 환상이 있습니다.</strong></p><ul><li>멀티 CPU 환경에서 캐시에 대한 가시성은 보장되지 않습니다.</li></ul><h3>콜 스택에 대한 환상(illusion)</h3><p>개발자들은 콜스택을 아무런 의심없이 사용하고 있습니다. 하지만 콜스택은 멀티 CPU가 없던 시절에 개념화 되었고, 다른 스레드의 스택을 넘나들 수 없으며, 비동기 콜 체인을 사용할 수 없습니다. 특히, 현재 하는 작업을 다른 스레드에 위임 할때 문제가 발생합니다. 간단히 메서드나 함수 호출로 다른 스레드에 위임할 수 없습니다.</p><p><strong>일반적으로 위임할 작업을 공유 자료구조에 넣고 이벤트 루프에서 읽어가서 처리하도록 구현해야 합니다.</strong> 호출자 스레드는 작업을 워커 스레드에 위임한 뒤 다른 작업을 이어갈 수 있습니다.</p><p>이 방식의 관심 중 하나는 작업의 완료, 예외를 호출자 스레드에 전달하는 방식 입니다. 다른 스레드의 스택을 조작하거나 할 수 없으니, <strong>이는 오직 부채널을 통해서만 가능할 것 같습니다.</strong> 예를들면 에러 코드를 호출자 스레드가 기대하는 위치에 넣어주는 것 입니다. 만약 어떤 버그로 인해 알림이 오지 않는다면 호출자는 실패 알림을 받지 못하고, 작업의 결과는 손실되게 됩니다.</p><p>재시도 역시 쉽지 않은데 예외의 전파로 인해 스택이 풀려서, 메시지가 완전히 유실될 수 있기 때문입니다. 이것은 네트워크로 연결된 시스템간에 메시지가 손실됐을때의 상항과 유사합니다.</p><ul><li>현대의 시스템에 알맞는 동시성과 성능을 갖추기 위해, 블로킹없이 효율적인 방식으로 작업을 위임하여야 합니다.</li><li>이러한 동시성 시스템에서는 예외를 해결할 수 있는 잘 정립된 방식이 있어야 합니다. 작업이 매우 오래걸릴 수 있고, 재시작 이후에 메시지가 손실될 수 있다는 사실 역시 깨달아야 합니다.</li></ul><h3>참조</h3><ul><li>traditional object-oriented programming: <a href="https://doc.akka.io/docs/akka/current/scala/guide/actors-motivation.html#The-illusion-of-shared-memory-on-modern-computer-architectures">https://doc.akka.io/docs/akka/current/scala/guide/actors-motivation.html#The-illusion-of-shared-memory-on-modern-computer-architectures</a></li></ul><p><em>Originally published at </em><a href="http://qwefgh90.github.io/actor/%EC%83%88%EB%A1%9C%EC%9A%B4-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%AA%A8%EB%8D%B8%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1/"><em>qwefgh90.github.io</em></a><em> on October 18, 2017.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5682f91ebe4a" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[함수형 프로그래밍 소개]]></title>
            <link>https://medium.com/@qwefgh90/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EC%9E%A5%EC%A0%90-7b6d43363220?source=rss-74ad5d76277f------2</link>
            <guid isPermaLink="false">https://medium.com/p/7b6d43363220</guid>
            <category><![CDATA[imperative-programming]]></category>
            <category><![CDATA[side-effects]]></category>
            <category><![CDATA[functional-programming]]></category>
            <category><![CDATA[scala]]></category>
            <category><![CDATA[oop]]></category>
            <dc:creator><![CDATA[최창원]]></dc:creator>
            <pubDate>Wed, 20 Sep 2017 00:00:00 GMT</pubDate>
            <atom:updated>2019-04-16T05:44:52.671Z</atom:updated>
            <cc:license>http://creativecommons.org/licenses/by/4.0/</cc:license>
            <content:encoded><![CDATA[<p>산업에서 주로 사용되는 <strong>명령형 프로그래밍</strong>(Imperative programming)<strong>은 객체의 상태를 변경하면서 동작하는</strong> 것을 강조합니다. 객체지향 패턴이 잘 적용된 프로그램 역시 기본적으로 Setter를 통해 필드를 캡슐화하고 상태를 변경하도록하여 동작합니다.</p><p>반면 <strong>함수형 프로그래밍</strong>(Functional programming)<strong>이란 부수효과</strong>(side effect)<strong>가 없는 순수 함수만으로 프로그램을 작성하는</strong> 방식을 말합니다. 예를들어, 객체의 상태를 캡슐화 하고 제자리에서 상태를 변경하기 보다 <strong>새로운 상태를 반환하므로써 동작합니다.</strong></p><p>부수효과가 없는 함수는 참조투명성을 갖는 함수를 뜻합니다. 참조 투명성이란 표현식의 성질중 하나입니다. 프로그램내의 특정 표현식의 모든 출현을 평가 결과로 치환해도 프로그램에 아무런 영향을 미치지 않는다면 그 표현식을 <strong>참조 투명하다고(referentially transparent)</strong> 할 수 있습니다.</p><p><strong>부수효과가 없다고 하여 표현할 수 있는 프로그램의 종류가 줄어든다는 의미는 아닙니다. 프로그램을 작성하는 방식에 제약을 주는 것 입니다.</strong></p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/8edaa31398d1efb632405c074de88b37/href">https://medium.com/media/8edaa31398d1efb632405c074de88b37/href</a></iframe><p><a href="https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">대표적인 함수형 언어</a>로 하스켈, 스칼라, 리스프 등이 있습니다. 모든 함수형 언어가 참조투명한 표현식만 갖는 것은 아닙니다. 스칼라같은 함수형 언어는 상태 변경 코드를 허용하면서도 그런 코드를 지양하고 있습니다.</p><p><strong>함수형 프로그래밍은 개발 생산성에 좋은 영향을 미치며 기존에 알려진 좋은 실천방법을 자연스럽게 사용할 수 있습니다. 대표적인 장점은 다음과 같습니다.</strong></p><p><strong>함수적 프로그램은 코드의 동작을 추론하기 쉽습니다.</strong> 함수를 호출하는 코드를 함수 본문으로 치환할 수 있으며, 이는 개발자가 치환모형을 통해 코드를 분석할 수 있도록 도와줍니다. 즉, 국소 추론만으로 프로그램의 동작을 빠르게 분석할 수 있습니다.</p><p><strong>두번째로 느슨히 결합된 모듈이나 쓰레드간 객체를 안전하게 공유할 수 있습니다.</strong> 자료구조나 객체가 불변이므로 모듈간 객체 전달시 변이를 막기 위해 방어적 복사본을 만들 필요가 없습니다. 또한 항상 객체가 스레드 안전(thread-safe)합니다. 즉, 개발자가 암묵적이나 명시적인 뮤택스나 락을 고려하며 코딩할 필요가 없습니다. (공유자원을 접근하는 코드를 작성할때 레이스 컨디션, 메모리 가시성, 데드락 문제가 발생할 수 있으므로 언어나 라이브러리를 통해 해결해야 합니다.)</p><p><strong>세번째로 함수형 프로그래밍은 모듈성과 재사용성을 높입니다.</strong> 프로그램은 재사용 가능하고, 합성 가능한 컴포넌트로 구성됩니다. 즉 컴포넌트는 인자로 입력을 받아 출력을 반환할 뿐 어떤 부수효과도 일으키지 않습니다. 부수효과를 제거한 덕분에 컴포넌트를 블랙박스 처럼 사용될 수 있으며, 별도의 검증 없이도 쉽게 재사용이 가능합니다. 국소적으로는 Future, Option의 고차함수를 이용해 여러가지 로직을 합성할 수 있습니다.</p><p><strong>마지막으로 함수적 코드는 테스트 하기 쉽습니다.</strong> 함수에 부수효과나 상태가 없어 버그를 <strong>재현(reproducibility)하기</strong> 쉬우며, 함수가 부수효과와 분리되어 존재하므로 테스트를 작성하기 쉽습니다. 반면 부수효과가 있는 코드는 버그를 재현하기 어려우며 테스트하기 까다롭습니다.</p><h3>참조</h3><ul><li>함수형 프로그래밍 : 스칼라로 배우는 함수형 프로그래밍(서적)</li></ul><p><em>Originally published at </em><a href="http://qwefgh90.github.io/fp/Function-Programming-Pros/"><em>qwefgh90.github.io</em></a><em> on September 20, 2017.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7b6d43363220" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[자바스크립트 실행 문맥(Execution Context)의 기본동작]]></title>
            <link>https://medium.com/@qwefgh90/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8B%A4%ED%96%89-%EB%AC%B8%EB%A7%A5-execution-context-%EC%9D%98-%EA%B8%B0%EB%B3%B8%EB%8F%99%EC%9E%91-8863e0a628ca?source=rss-74ad5d76277f------2</link>
            <guid isPermaLink="false">https://medium.com/p/8863e0a628ca</guid>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[dom]]></category>
            <category><![CDATA[web]]></category>
            <category><![CDATA[execution-context]]></category>
            <category><![CDATA[scope-chains]]></category>
            <dc:creator><![CDATA[최창원]]></dc:creator>
            <pubDate>Tue, 25 Apr 2017 00:00:00 GMT</pubDate>
            <atom:updated>2019-04-16T05:50:01.555Z</atom:updated>
            <cc:license>http://creativecommons.org/licenses/by/4.0/</cc:license>
            <content:encoded><![CDATA[<p>비교적 최근에 <strong>“인사이드 자바스크립트”</strong>를 읽고 <strong>this 변수, 클로저, 실행 문맥을</strong> 이해하게 되었습니다. 자바스크립트를 즐겨 사용하지 않았지만 웹 개발을 하면서 해당 부분에 대한 이해가 필요했습니다. 이 3가지 개념은 서로 얽혀 있으며 스크립트가 실행에 필요한 중요한 요소입니다. 다른 사람의 코드를 볼일이 있거나 직접 로직을 작성할 일이 있다면 이에 대한 이해가 필요합니다. <strong>이 글은 실행 문맥(Execution Context)의 기본 동작에 대한 설명입니다.</strong></p><p>기본적으로 브라우저는 서버로부터 스크립트를 다운로드하여 파싱되고 실행합니다. 로딩 이벤트와 같은 HTML 이벤트에 따라 이벤트 핸들러를 등록할 수 있으며 자바스크립트 언어로 프로그래밍 할 수 있습니다.</p><p><strong>실행 문맥(Execution Context)은 이러한 자바스크립트를 실행하는 과정을 추적하는 하나의 내부적인 장치를 뜻합니다.</strong> 실행 문맥은 내부에는 실제 블록안에서 사용되는 변수들을 저장하고 관리합니다. 이때 실행 문맥 내부에서 이러한 변수를 저장하는 객체를 <strong>활성 객체(Activation Object) 또는 변수 객체(Variable Object)라</strong> 부릅니다.</p><p>실행 문맥의 기본 동작을 이해하게 되면 일반적인 함수나 클로저(Clousure)에서 현재 스코프(Scope) 밖의 변수를 참조하려고 할때 어떤 변수가 어떻게 참조되는지 정확하게 알 수 있습니다. 이를 식별자 해석(Identifier Resolution)이라 합니다.</p><p>실행 문맥은 <strong>eval(…) 호출, 함수 호출, 전역 코드 실행시</strong> 새롭게 생성됩니다.</p><p>아래의 예시는 변수 객체(Variable Object)가 무엇을 저장하는지 보여줍니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/58e21f3141515719cab3d49bb037ffdb/href">https://medium.com/media/58e21f3141515719cab3d49bb037ffdb/href</a></iframe><p><strong>실행 문맥은</strong> 전통적인 언어에서 사용되는 콜 스택과 역할이 유사하다고 할 수 있습니다. 하지만 콜 스택과 자바스크립트의 실행 문맥은 동작하는 방식 자체가 미묘하게 다릅니다.</p><p>전통적으로 함수를 호출할때 필요한 정보는 콜 스택에 쌓이게 되며 그 정보는 매개변수(Parameter), 종료 후 복귀 주소(Pointer), 지역 변수등 입니다. <strong>실행 문맥도</strong> 비슷한 구조를 갖고 있습니다. 하지만 추가적으로 리스트 형태의 <strong>스코프 체인(Scope Chain)을</strong> 저장하고 있습니다. <strong>스코프 체인은</strong> 실행 문맥들이 연결된 리스트이며 현재 실행 문맥에서 쉽게 다른 문맥의 변수를 접근하도록 도와줍니다.</p><p><strong>함수가 정의될때 함수는 [[scope]] 프로퍼티로 현재 실행 문맥의 스코프 체인을 저장하게 됩니다. 이 스코프 체인은 추후 이 함수가 실행될때 생성되는 실행 문맥의 변수 객체와 결합되어 새로운 스코프 체인을 생성합니다. 함수가 호출된 이후 스코프 체인의 생성 과정은 다음과 같습니다.</strong></p><ul><li><strong>새로운 실행 문맥의 스코프 체인 = 함수 객체의 스코프 프로퍼티([[scope]] 프로퍼티) + 새로운 실행 문맥의 변수객체</strong></li></ul><p>이후 다른 문맥의 식별자를 찾을때 스코프 체인의 변수객체를 순차적으로 방문하면서 [[HasProperty]]을 이용해 식별자가 존재하는지 확인하게 됩니다.</p><p><strong>실행 문맥 중 전역코드에서 최초로 생성되는 문맥은 전역 실행 문맥입니다.</strong> 스크립트의 가장 바깥쪽에 위치한 코드가 실행될때의 실행 문맥입니다. HTML DOM 모델에서는 window 프로퍼티가 전역 객체(Global Object)이면서 전역 실행 문맥의 변수 객체(Variable Object)가 됩니다. 이때 전역 실행 문맥의 스코프 체인은 자신의 변수 객체만 갖습니다.</p><p>당연하게도 어떤 함수든 생성될때 스코프 체인에 <strong>전역 실행 문맥의 변수 객체(window로 참조 가능)를</strong> 저장하게 됩니다. 따라서 어디서든 전역 변수를 사용할 수 있습니다.</p><h3>참조</h3><ul><li>스코프 체인 : <a href="https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">ECMAScript 3</a></li><li>ECMAScript : <a href="https://www.ecma-international.org/ecma-262/7.0/">ECMAScript Language Specification</a></li></ul><p><em>Originally published at </em><a href="http://qwefgh90.github.io/javascript/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8B%A4%ED%96%89-%EB%AC%B8%EB%A7%A5/"><em>qwefgh90.github.io</em></a><em> on April 25, 2017.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8863e0a628ca" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[람다 표현식(Lambda expression)의 장점]]></title>
            <link>https://medium.com/@qwefgh90/%EB%9E%8C%EB%8B%A4-%ED%91%9C%ED%98%84%EC%8B%9D%EC%9D%98-%EC%9E%A5%EC%A0%90-35bc591b948f?source=rss-74ad5d76277f------2</link>
            <guid isPermaLink="false">https://medium.com/p/35bc591b948f</guid>
            <category><![CDATA[first-class-function]]></category>
            <category><![CDATA[functional-programming]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[lambda]]></category>
            <category><![CDATA[java]]></category>
            <dc:creator><![CDATA[최창원]]></dc:creator>
            <pubDate>Fri, 31 Mar 2017 00:00:00 GMT</pubDate>
            <atom:updated>2019-04-16T05:51:47.605Z</atom:updated>
            <cc:license>http://creativecommons.org/licenses/by/4.0/</cc:license>
            <content:encoded><![CDATA[<p><strong>최근들어 Scala, Javascript와 같은 함수형 프로그래밍 언어들이 많은 주목을 받고 있습니다.</strong> 이러한 최신의 함수형 언어들은 람다표현식, 보일러 플레이트, 객체 지향 문법, 모듈화를 지원합니다. 이러한 문법들은 대부분 프로그래머가 더 쉽게 객체 지향 프로그래밍, 함수형 프로그래밍을 할 수 있게 합니다.</p><p>그중 람다 표현식은 이름없는 함수를 표현하는 방법입니다. 람다 표현식은 객체지향 언어의 인스턴스 메서드나 클래스 메서드 처럼 파라미터, 반환값, 본문(Body)를 갖고 있습니다. 람다 표현식이 공식적으로 지원된다면 함수를 값으로 사용할 수 있으며 파라미터로 전달할 수 있고 반환값으로 받을 수 있습니다. 이러한 함수는 일급 계층 객체(First-class Object)입니다. (일급 함수, 일급 시민으로도 불립니다.)</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/c662485a6e7c85cf54a6f29927225e31/href">https://medium.com/media/c662485a6e7c85cf54a6f29927225e31/href</a></iframe><p>개인적으로 자주 사용하는 C#, Java, Javascript에서도 이와 비슷한 문법으로 람다식을 작성할 수 있습니다.</p><p>람다 표현식의 등장으로 언어의 표현이 더 풍부해지게 됩니다. 여기서 표현이 풍부해졌다는 것은 다른 방식의 프로그래밍을 할 수 있다는 것이고, 어쩌면 기존보다 더 간결한 프로그래밍을 할 수 있다는 뜻입니다.</p><p>그중 가장 큰 장점은 고차함수를 통해 비공통 알고리즘을 파라미터로 받을 수 있는것 입니다. 고차 함수란 함수를 파라미터로 받는 함수를 뜻합니다. 기존에는 객체나 값을 메서드의 파라미터로 전달하여 객체를 이용할 수 있었습니다. 하지만 프로그램의 기능이 많아지면 많아질 수록 길고 복잡하고 인자가 많은 메서드를 작성해야 합니다. 또한 객체가 지원하지 않는 기능들은 외부에서 제어코드를 작성하여야 합니다.</p><p>예를들면 프로그램에서 SQL Select 구문처럼 필터링 한 결과값을 가져오는 기능을 개발한다면 필터링을 위해 많은 메서드를 포함시켜야 합니다. 또한 필터링 조건이 복잡하다면 반복자를 이용하여 객체의 외부에서 필터링을 수행해야 할지도 모릅니다.</p><p>하지만 람다표현식을 파라미터로 받는 메서드를 만든다면 모든 기능을 고려하여 복잡하게 설계할 필요가 없습니다. 메서드를 사용하는쪽에서 직접 알고리즘을 작성하여 전달할 수 있기 때문입니다. 이러한 방식에는 크게 2가지의 장점이 있다고 생각합니다.</p><ul><li>첫째로 모든 기능을 지원하기 위해 하나의 길고 방대한 클래스를 작성할 필요가 없습니다. 변경된 요구사항을 적용한 람다 표현식을 작성하는 것으로 충분합니다.</li><li>둘째로 클라이언트가 반복자를 통해 명령형 프로그래밍 스타일로 직접 작성한 코드보다 고차 함수가 버그가 적다는 것 입니다.</li></ul><p>람다를 지원하지 않는다면 직접 반복자 코드, 알고리즘, 결과를 받는 콜렉션을 모두 다뤄야 합니다. 미숙한 프로그래머의 경우 실수할 확률이 더 높다고 할 수 있습니다.</p><p>그외에도 람다식은 <strong>단위 테스트 하기 쉬우며 재사용하기</strong> 좋습니다. 이러한 장점은 곧 함수형 프로그래밍 언어들의 장점과 같습니다.</p><p><strong>람다표현식은 개발자의 생산성을 높여주는 문법이라고 할 수 있습니다.</strong></p><p><em>Originally published at </em><a href="http://qwefgh90.github.io/java/Lambda-Expression/"><em>qwefgh90.github.io</em></a><em> on March 31, 2017.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=35bc591b948f" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[JSR 133 (Java Memory Model) FAQ 번역]]></title>
            <link>https://medium.com/@qwefgh90/jsr-133-java-memory-model-faq-%EB%B2%88%EC%97%AD-128487aebc1e?source=rss-74ad5d76277f------2</link>
            <guid isPermaLink="false">https://medium.com/p/128487aebc1e</guid>
            <category><![CDATA[java]]></category>
            <category><![CDATA[jsr-133]]></category>
            <category><![CDATA[memory-model]]></category>
            <category><![CDATA[jsr]]></category>
            <category><![CDATA[synchronized]]></category>
            <dc:creator><![CDATA[최창원]]></dc:creator>
            <pubDate>Tue, 29 Nov 2016 00:00:00 GMT</pubDate>
            <atom:updated>2019-04-16T05:54:22.763Z</atom:updated>
            <cc:license>http://creativecommons.org/licenses/by/4.0/</cc:license>
            <content:encoded><![CDATA[<p><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html">JSR 133 (Java Memory Model) FAQ </a>를 번역한 글입니다.</p><p>JSR 133 (Java Memory Model) FAQ Jeremy Manson and Brian Goetz, February 2004</p><h3>메모리 모델이란 무엇입니까?</h3><p>멀티프로세서 환경에서 프로세서들은 1개 이상의 메모리 캐시를 갖게됩니다. 메모리 캐시는 데이터에 빠르게 접근함으로써 성능을 향상시키며 (프로세서에 가까이 위치하기 때문에) 메모리 버스안에서 발생하는 트래픽을 감소시켜줍니다. (많은 메모리 연산은 로컬 캐시에 의해 감소될 수 있기 때문에) 메모리 캐시는 성능을 크게 향상시킬 수 있으나 새로운 문제점들을 갖고 있습니다. 두개의 프로세서가 동시에 같은 메모리 주소에 접근한다면 어떤 문제가 발생할까? 어떤 조건에서 같은 값을 볼 수 있을까? 와 같은 질문이 있습니다.</p><p>프로세서 수준에서의 메모리 모델에서는 다른 프로세서의 메모리 기록을 현재 프로세서가 볼 수 있도록 필요 충분한 상태를 정의하고 있습니다. 그 역도 마찬가지입니다. 몇몇 프로세서는 강한 메모리 모델(strong memory model)을 갖고 있고 다른 몇몇 프로세서는 약한 메모리 모델(weaker memory model)을 갖고 있습니다. 먼저 강한 메모리 모델은 언제나 모든 프로세서가 같은 메모리 주소에서 정확히 같은 값을 볼 수 있습니다. 약한 메모리 모델에서는 다른 프로세서의 쓰기(writes) 연산을 현재 프로세서에 보여주거나 현재 프로세서의 쓰기 연산을 다른 프로세서에 보여주기 위해 로컬 프로세서의 캐시를 무효화하는(invalidate or flush) 메모리 장벽(Memory barriers) 이라는 특별한 명령어 집합을 갖고 있습니다. 이러한 메모리 장벽은 일반적으로 잠금(lock), 잠금 해제(unlock) 명령어를 실행할때 동작하며 고수준의 언어를 다루는 프로그래머에게 노출되지 않습니다.</p><p>강한 메모리 모델에서는 메모리 장벽을 많이 요구되지 않기 때문에 프로그램을 작성하는 것이 쉬운 편입니다. 하지만 몇몇 강한 메모리 모델은 메모리 장벽을 필요로 하며 이는 직관에 반하게 됩니다. 최근에는 프로세서 설계에 약한 메모리 모델을 사용하는 것이 권장되고 있는데, 이 모델이 캐시 일관성을 위해 느슨함을 갖고, 많은 수의 프로세서와 메모리에서 규모 확장성에 도움을 주기 때문입니다.</p><p>쓰레드간의 쓰기 연산의 가시성 문제는 컴파일러의 코드 재배열(reordering)에 의해 더 악화됩니다. 예를들어 쓰기 연산을 나중에 실행하는 것이 더 효율적일 수 있기 때문에 컴파일러는 프로그램의 의미(semantics)를 바꾸지 않는 선에서 코드를 재정렬 할 수 있습니다. 컴파일러가 연산을 뒤로 미루기로 결정한다면 다른 쓰레드는 그것이 수행될 때 까지 값을 볼 수 없습니다. 이것은 캐시의 효과를 보여줍니다.</p><p>게다가 메모리 쓰기 연산은 앞쪽으로 배치될 수 도 있으며, 이 경우에는 다른 스레드는 프로그램에서 실제로 쓰기가 발생하기 전에 쓰기 연산의 결과값을 확인할 수 있습니다. 이러한 모든 유연성은 설계에 의해 이루어 집니다. 컴파일러, 런타임, 하드웨어에 최적의 순서로 연산을 재정렬(reordering)하는 유연성을 부여함으로써 메모리 모델의 경계 안에서 더 높은 성능을 달성할 수 있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/a0f93125f9f96efe98e032210b0e6523/href">https://medium.com/media/a0f93125f9f96efe98e032210b0e6523/href</a></iframe><p>위 코드에서 두개의 쓰레드로 writer(), reader() 동시에 실행시킨다고 가정해봅시다. 먼저 변수 y에 2를 쓰는 연산은 x에 1을 쓰는 연산 다음에 실행되기 때문에 프로그래머는 y가 2로 읽힌 이후에 x가 1로 읽힌다고 가정할 것입니다. 하지만 x와 y에 값을 쓰는 연산은 재정렬(reordering)될 수 있습니다. 그리고 재정렬(reordering)이 발생한다면 y의 쓰기 연산이 발생하고 x,y를 읽는 연산이 발생한 뒤 x의 쓰기 연산이 발생할 수 있습니다. 그 결과 reader()에서 r1는 2, r2는 0이 될 것입니다.</p><p>자바 메모리 모델은 멀티스레드 프로그램에서 코드가 어떤식으로 동작할지 그리고 멀티 스레드가 어떤식으로 메모리와 상호작용하는지 정의합니다. 또한 프로그램에서 저수준의 레지스터와 메모리에 프로그램 변수를 읽고 쓰는 것에 대한 상세한 내용을 정의합니다. 다양한 하드웨어와 컴파일러 최적화를 사용하여 정확하게 이것을 구현할 수 있습니다.</p><p>자바 언어는 volatile, final, synchronized를 포함하고 있으며 이를 이용하여 프로그래머가 컴파일러에게 동시성 요구사항을 설명하도록 도와줍니다. 자바 메모리 모델은 volatile, synchronized 등의 행동을 정의하고 있고 정확하게 동기화된 자바 프로그램이 모든 프로세서 아키텍처에서 정확하게 동작하도록 보장합니다.</p><h3>C++ 과 같은 다른 언어도 메모리 모델을 가지고 있습니까?</h3><p>예를들어 C와 C++ 은 멀티스레딩을 직접적으로 지원하지 않습니다. 이러한 언어들이 컴파일러와 아키텍처에서 발생하는 코드 재정렬(reordering)을 지원하기 위해 스레딩 라이브러리들에 의존합니다. 예를들어 쓰레딩 라이브러리(pthread)나 컴파일러, 플랫폼에 의해 멀티스레딩이 보장됩니다. (C++ 11은 언어 수준에서 멀티 쓰레딩을 지원합니다.)</p><h3>JSR 133은 어떤 것을 다룹니까?</h3><p>1997년 이후, 자바 언어 스펙(챕터 17)에 정의되어 있는 자바 메모리 모델에서 많은 결함이 발견되었습니다. 이러한 결함은 프로그램을 불확실하게 만들었으며 (예를들어 final 필드에서 값이 변하는 것이 관찰되는 등) 최적화를 수행하는 컴파일러에 악영향을 끼쳤습니다.</p><p>자바 메모리 모델은 최초로 프로그래밍 언어 수준에서 메모리 모델을 통합하는 것을 시도하였으며 다양한 아키텍처에서 동시성을 제공하기 위해 일관성있는 문맥을 제공하였습니다. 하지만 일관적이고 직관적인 메모리 모델을 정의하는 것은 예상했던 것보다 어려웠습니다. JSR 133은 이전의 메모리 모델의 문제를 해결하는 새로운 메모리 모델을 정의하였습니다. 이를 위해 final과 volatile의 의미가 변경될 필요가 있었습니다.</p><p>상세한 기능은 <a href="http://www.cs.umd.edu/users/pugh/java/memoryModel">http://www.cs.umd.edu/users/pugh/java/memoryModel</a> 에서 확인할 수 있습니다. 복잡하면서도 겉으로 보기엔 단순해 보이는 동기화의 개념을 확인하면서 놀라움을 느낄 수 있습니다. 운이 좋게도 당신은 구체적인 부분까지 이해할 필요가 없습니다. JSR 133의 목표 자체가 volatile과 synchronized 그리고 final이 어떻게 동작하는지에 대한 직관적인 틀을 제공하는 공식적인 의미 집합을 보여주는 것이기 때문입니다.</p><p>JSR 133의 목표</p><ul><li>기존의 타입 안정성과 기존의 안정성을 보장하면서 다른 것들을 강화합니다. 예를들어 이유없이 변수의 값들이 생성되지 않을것 입니다. 몇몇 쓰레드에 의해 관찰되는 값은 일부 쓰레드 합리적으로 배치될 수 있는 값이여야 합니다.</li><li>정확하게 동기화된 프로그램은 가능한 직관적이고 간단한 의미를 가져야 한다.</li><li>불완전하게 동기화된 프로그램의 의미는 잠재적인 보안 위험을 최소화 하도록 정의되어야 한다.</li><li>프로그래머들가 멀티스레드 프로그램이 어떻게 메모리와 상호작용 하는지 추론할 수 있어야한다.</li><li>다양한 아키텍처에서 정확하고 고성능 JVM을 구현하는 것이 가능해야한다.</li><li>초기화 안정성이 보장되어야 한다. 만약에 객체가 잘 생성되었다면 (생성되는 도중 참조값이 노출될 수 없음을 의미) 그 참조값을 갖고 있는 모든 스레드들이 동기화 없이 값들을 볼 수 있을 것이다. (생성자에서 세팅된 final 필드를 위한 값들)</li><li>기존의 코드에는 최소한의 영향만 끼쳐야한다.</li></ul><h3>코드 재정렬은 무엇을 의미하나요?</h3><p>프로그램 변수에 접근하는 명령어들은 프로그램에 명시된 것과 달리 다른 순서로 실행되는 경우는 많다. 컴파일러는 최적화를 위해 명령어의 순서를 자유롭게 할 수 있다. 프로세서는 특정상황에서 순서에 맞지 않게 명령어를 실행할 수 있다. 데이터는 레지스터, 캐시, 메인메모리 사이를 프로그램에 명시된 것과 다른 순서로 이동할 수 있다.</p><p>예를들어 만약에 쓰레드가 필드 a에 값을 쓴뒤 필드 b에 값을 쓰고 b는 a에 의존하지 않는 값이라면 컴파일러는 이 연산의 순서를 재정렬 할 수 있다. 또한 필드 b를 a보다 먼저 캐시에서 메모리로 플러시(flush) 할 수 있다. 많은 재정렬(reordering) 케이스가 존재한다. (예를들면 CPU, 컴파일러, JIT)</p><p>컴파일러, 런타임, 하드웨어는 싱글 스레드 프로그램에서 프로그램 스스로 명령어 재정렬의 영향을 확인할 수 없도록 해야한다. 그러나 올바르지 않게 동기화된 멀티스레드 프로그램에서 프로그램에서 명시된 것과 다른 순서로 변수에 접근하는 것을 확인할 수 있다.</p><p>대부분의 경우 하나의 스레드는 다른 스레드가 무엇을 하는지 알 수 없다. 이것을 위해 동기화(synchronization)이 존재한다.</p><h3>이전의 메모리 모델은 무엇이 잘못되었습니까?</h3><p>오래된 메모리 모델은 몇가지 심각한 문제를 갖고 있었다. 이해하기 어려운 문제였고 덕분에 광범위하게 문제가 퍼지게 되었다. 예를들면 오래된 모델은 모든 JVM에서 발생하는 메모리 재정렬(reordering) 지원하지 않는다. 이러한 혼란때문에 JSR-133이 만들어지게 되었다.</p><p>예를들면 final 필드가 사용되었을때 쓰레드 간의 동기화가 필요없다는 것은 널리 알려진 사실이다. 이것은 합리적인 가정이며 우리가 당연하게 생각하는 것이지만 오래된 메모리 모델에서는 그렇지 않다. 오래된 메모리 모델은 final 필드를 다른 필드와 다르게 다루지 않는다. 즉 동기화는 모든 쓰레드가 final 필드의 값을 볼 수 있게하는 유일한 방법이었다. 그 결과 모든 쓰레드는 final 필드의 기본값을 보는 것이 가능해졌고 시간이 지난뒤 생성자에서 초기화된 값을 볼 수 있었다. 즉 String과 값은 불변객체의 값이 변화하는 것을 관측할 수 있었다는 것이다.</p><p>오래된 메모리 모델에서는 volatile 변수의 쓰기가 nonvolatile 변수의 읽기 쓰기와 함께 재정렬(reordering) 되는것이 가능했다. 많은 개발자들은 volatile의 이러한 부분 때문에 많은 혼동을 갖게되었다.</p><p>결론적으로 멀티쓰레드 프로그램이 올바르게 동기화 되지않았을때 프로그래머들은 더 많은 혼란에 빠지게되고 더 착각하게 되었다.</p><h3>올바르게 동기화 되지 않은것은 무엇을 의미하나요?</h3><p>사람마다 올바르지 않게 동기화된 코드를 다르게 생각할 수 있습니다. 하지만 자바 메모리 모델의 관점에서 올바르지 않게 동기화된 코드는 다음을 의미합니다.</p><ol><li>하나의 쓰레드에서 하나의 변수에 값을 쓴다.</li><li>다른 하나의 쓰레드에서 같은 변수에 값을 읽어 들인다.</li><li>읽고 쓰는 코드에 순서가 없다.</li></ol><p>이러한 것을 데이터 레이스(<em>data race</em>)라고 합니다. 데이터 레이스를 갖고 있는 프로그램은 올바르지 동기화된 프로그램이라고 할 수 없습니다.</p><h3>동기화는 어떤것을 해줍니까?</h3><p>동기화의 다양한 의미가 존재합니다. 가장 잘 알려진 상호배제(mutual exclusion) 입니다. 상호배제란 한번에 하나의 쓰레드가 모니터(monitor)를 보유하는 것입니다. 이는 하나의 쓰레드가 모니터에 의해 보호되는 동기화 블록에 진입한다는 의미입니다. 이 쓰레드가 블록에서 나오기 전까지 다른 쓰레드는 이 동기화 블록에 진입할 수 없습니다.</p><p>그러나 상호배제보다는 동기화보다 더 많은 요소를 갖고있습니다. 동기화(synchronization)는 한 쓰레드가 동기화 블록안에 있거나 진입하기 직전의 메모리 쓰기(writes)를 같은 모니터에 의해 동기화된 다른 쓰레드에게 예측가능한 방식으로 보여지게 됩니다. 동기화 블록에서 빠져나온뒤 우리는 모니터를 <strong>해제(release)</strong>합니다. 이때 캐시 메모리의 데이터를 메인 메모리로 이동시키며 쓰레드의 메모리 쓰기(writes) 연산들은 다른 쓰레드에게 보여지게 됩니다. 쓰레드는 동기화 블록에 들어가기전에 모니터를 <strong>획득(acquire)</strong>합니다. 이 모니터는 메인 로컬 캐시를 무효화 시키며 메인 메모리로부터 다시 데이터를 불러옵니다. 결국 이전에 수행된 모든 쓰기 연산을 볼 수 있게 됩니다.</p><p>다시 캐시의 관점에서 본다면 이 이슈는 다중 처리기(multi processor)에만 관련있는 것 처럼 보입니다. 그러나 단일 처리기(single processor)에서도 명령 재배열(reordering)은 쉽게 관찰됩니다. 예를들면 컴파일러는 코드를 동기화 블록에 진입하기 전이나 후로 이동 시키는 것은 불가능합니다. 캐시에서 모니터 획득, 해제하는 것은 많은 영향을 끼친다고 할 수 있습니다. (위의 Reordering 클래스를 확인해보면 알 수 있습니다. 단일 프로세서라 하더라도 동기화 블록을 사용하지 않는다면 예상하지 못한 결과가 발생할 수 있습니다.)</p><p>새로운 메모리 모델은 메모리 연산들과 쓰레드 연산에 부분 순서를 정의했습니다. (read field, write field, lock, unlock, start, join) 이를 연산들은 다른 연산들 이전에 실행(happen before) 된다고 한다. 하나의 연산이 다른 연산이 실행되기 이전에 실행될때 이는 각 연산이 순차적인 순서로 실행됨을 뜻하며 첫번째 연산의 결과는 두번째에 보이게 됩니다. 규칙은 아래와 같습니다.</p><ul><li>각 연산은 프로그램 순서상 나중에 오는 <strong>같은 쓰레드의</strong> 모든 연산들 보다 먼저 실행된다.</li><li>모니터의 해제(unlock)는 뒤이어 실행되는 <strong>같은 모니터에</strong> 대한 획득(lock) 이전에 실행된다.</li><li>volatile 변수 쓰기 연산은 뒤이어 실행되는 <strong>같은 volatile 변수</strong> 읽기 연산 이전에 실행된다.</li><li>start() 메소드는 시작된 쓰레드안에 어떤 연산보다 먼저 호출된다.</li><li>시작된 쓰레드안의 모든 연산은 그것을 기다리는 다른 쓰레드의 join() 메서드의 반환보다 먼저 실행된다.</li></ul><p>동기화 블록에서 나오려는 쓰레드의 모든 메모리 연산들은 곧 같은 동기화 블록으로 들어가려는 쓰레드에 가시성을 띄는것을 의미합니다. 모든 메모리 연산은 반드시 모니터를 해제하기 전에 실행되고 모니터 해제는 모니터 획득 이전에 발생하기 때문입니다.</p><p>메모리 장벽을 만들기 위해 사용하는 다음 코드는 동작하지 않습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/8f746f293b66baa20c13bbf4403e7f75/href">https://medium.com/media/8f746f293b66baa20c13bbf4403e7f75/href</a></iframe><p>위 코드는 어떤 연산도 아니며 컴파일러는 이 코드를 삭제할 것 입니다. 왜냐면 컴파일러는 이 블록에 진입할때 어떤 쓰레드도 같은 모니터를 사용하지 않는다는 사실을 알기 때문입니다. happen-before 관계를 명확하게 사용하여 다른 쓰레드의 연산 결과를 볼 수 있게하는 것은 반드시 필요합니다.</p><p><strong>중요한 사항:</strong> happen-before 관계를 명확하게 하기 위해 쓰레드들을 같은 모니터로 동기화하는 것은 중요합니다. 객체 X에 의해 동기화되어 쓰레드 A에 보이는 모든 것은 Y로 동기화된 쓰레드 B에 보이지 않습니다. 해제(release)와 획득(acquire)은 같은 모니터에서 실행되어야 합니다. 그렇지 않으면 데이터 레이스(data race)가 발생합니다.</p><h3>final 필드의 값이 바뀌는 것을 어떻게 볼 수 있습니까?</h3><p>final 필드의 값이 바뀌는 것처럼 보이는 예들 중 하나는 String 클래스의 특정 구현과 관련 있습니다.</p><p>String은 3개의 필드로 구현되어 있습니다. char[], offset, length 입니다. 오직 char[]만 가지는 대신 이러한 필드를 사용하여 구현하는 근본적인 이유는 다른 String 객체들과 String Buffer 객체들이 같은 char[]을 공부하게하고 추가적인 객체 복사를 막기 위해서 입니다. 예를들면 substring 메서드는 새로운 String 객체를 만들고 원본 객체와 같은 char[]를 갖고 offset과 length만 다른 값을 갖습니다. String 메서드를 위해 이 3가지 필드는 final로 선언되어 있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/44d7e90d2a8ed550df00c75d7f09c1a7/href">https://medium.com/media/44d7e90d2a8ed550df00c75d7f09c1a7/href</a></iframe><p>문자열 s2는 offset은 4, length 4를 갖습니다. 그러나 오래된 메모리 모델에서는 다른 쓰레드에서 offset이 0을 갖는 것을 관찰할 수 있으며 나중에 4로 변하는 것을 볼 수 있습니다. 이것은 마치 문자열이 “/usr”에서 “/tmp”로 바뀌는 것 처럼 보입니다.</p><p>오래된 메모리 모델에서는 이런 상황이 발생할 수 있습니다. 여러개의 JVM은 이러한 문제를 보여주었습니다. 새로운 메모리 모델에서는 이것을 불가능하게 하였습니다.</p><h3>새로운 JMM에서 final 필드는 어떻게 동작합니까?</h3><p>final 필드의 값은 생성자 안에서 세팅됩니다. 객체가 한번에 “정확하게(correctly)” 생성된다고 가정해봅시다. 일단 객체가 생성되면 final 필드에 할당된 값들은 동기화 없이 다른 모든 쓰레드에게 가시성을 띄게됩니다. 게다가, final 필드에 의해 참조되는 객체나 배열의 값 또한 최신일 것 입니다.</p><p>정확하게(correctly) 생성된 객체는 어떤 객체를 의미를 지닐까요? 간단하게 말하면 객체가 생성되는 동안 그 참조값을 외부로 내보내지 말아야 하는 것을 뜻합니다. [Safe Construction Techniques]<a href="http://www.ibm.com/developerworks/library/j-jtp0618/">http://www.ibm.com/developerworks/library/j-jtp0618/</a> 의 예제를 확인해보세요. 즉, 생성중인 객체의 참조값을 다른 스레드가 볼 수 있는 다른 어느 곳에도 두지 말라는 뜻 입니다. static 필드에 할당하지 마십시오. 다른 객체의 리스너로 등록하지 마십시오. 이러한 작업은 생성자가 호출중이 아닌 호출된 이후에 수행되어야 합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/1970b66bfb974002600dc4b6f80a90b5/href">https://medium.com/media/1970b66bfb974002600dc4b6f80a90b5/href</a></iframe><p>위 예제는 final 필드가 어떤식으로 사용되는지 보여주고 있습니다. reader를 실행하는 쓰레드 입장에서는 f.x는 final이기 때문에 3으로 보이게 됩니다. 그러나 y는 final이 아니기 때문에 4로 보이지 않을 수 있습니다. 만약 FinalFieldExample의 생성자가 다음과 같다면</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/1e288de50dedf1b2d0e750535c1ce650/href">https://medium.com/media/1e288de50dedf1b2d0e750535c1ce650/href</a></iframe><p>쓰레드 입장에서 global.obj로 부터 this를 참조값을 읽을 수 있게되고 이는 x의 값은 3으로 보장되지 않습니다.</p><p>정확하게 생성된 값을 보는 능력은 멋지다고 할 수 있습니다. 그러나 만약 필드가 참조값을 갖는다면 당신의 코드가 가르키는 객체(배열)가 최신값일 원할 것 입니다. 만약 그 필드가 final 이라면 이것이 보장됩니다. 그럴경우 다른 쓰레드가 정확한 참조값을 보는 것에 대한 걱정을 하지 않아도 되지만 배열의 내용은 정확하지 않을 수 있습니다. 다시말해서 여기서 “정확한(correct)” 값은, “최종적으로 이용 가능한 값”을 뜻하는 것이 아닌 “객체의 생성자가 끝날 때의 최신”을 뜻합니다.</p><p>이 모든 것들을 설명한 뒤에도, 쓰레드가 불변 객체(final 필드만 포함하는 객체)를 생성한 뒤에 다른 모든 쓰레드에게 그 객체가 정확하게 관찰되길 원한다면 늘 그렇듯이 <strong>여전히</strong> 동기화를 사용할 필요가 있습니다. 예를들면 불변 객체의 참조값이 다른 쓰레드에게 보이도록 하는 다른 방법은 없습니다. 프로그램이 final 필드에서 얻게되는 이점은 어떻게 동시성이 다뤄져야 하는지에 대한 깊은 이해와 함께 고려되어야 합니다.</p><p>만약 당신이 final 필드를 변경하기 위해 JNI를 사용한다면 어떠한 정의된 동작도 사용할 수 없습니다.</p><h3>volatile은 어떤것을 합니까?</h3><p>Volatile 필드는 쓰레드간에 상태를 공유하기 위해 사용되는 필드입니다. 각각의 읽기 연산은 마지막으로 어떤 쓰레드에서 수행된 쓰기 연산의 결과를 볼 수 있습니다. 사실상 캐싱이나 명령 재배열(reordering)의 결과로 보이는 “오래된(stale)” 값이 보이는 것을 무효하기 위해 고안된 필드입니다. 컴파일러와 런타임(runtime)은 레지스터에 이러한 값을 할당하는 것을 금지합니다. 이 필드는 한번 쓰기연산이 일어난 이후에 캐시에서 메모리로 바로 플러시(flush)됩니다. 그래서 이 필드는 즉시 다른 쓰레드에게 가시성을 갖게됩니다. 비슷하게 volatile 필드에 대한 읽기 연산이 수행되기 전에 메인 메모리에 저장된 값을 보기 위해 로컬 프로세서의 캐시는 무효화됩니다. volatile 변수들에 대한 연산을 재배열(reordering)에는 추가적인 제약(restictions)이 존재합니다.</p><p>오래된 메모리 모델에서는 volatile 변수에 대한 연산은 서로 재배열될 수 없었고 nonvolatile 변수에 대한 연산은 재배열 될 수 있었습니다. 이것은 volatile 필드의 한 쓰레드에서 다른 쓰레드로 상태를 전달하는 유용성을 약화시켰습니다.</p><p>새로운 메모리 모델에서는 volatile 변수에 대한 연산은 여전히 재배열되지 않습니다. 단, 차이점은 그 코드 주변의 일반적인 필드들에 대한 연산을 재배열하는 것이 어려워진 점입니다. volatile에 쓰기 연산은 모니터 해제와 같은 메모리 수준의 효과를 갖고 읽기 연산은 모니터 획득과 같은 효과를 갖습니다. 사실상, 새로운 메모리 모델은 volatile 필드 연산과 그 주변의 필드 연산을 재배열(reordering)하는데 더 엄격한 제약조건을 갖고있기 때문에 쓰레드 A에서 volatile 필드에 쓰기연산을 하고 쓰레드 B는 volatile 필드를 읽었을 때 그 순간 쓰레드 A가 볼 수 있는 모든 것(volatile이든 nonvolatile이든)은 쓰레드 B에서 보이게 됩니다.</p><p>volatile 필드의 간단한 사용 예제입니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/c881e23ce6ede9a6428ff7fe892cae6b/href">https://medium.com/media/c881e23ce6ede9a6428ff7fe892cae6b/href</a></iframe><p>하나의 쓰레드가 writer를 호출하고 다른 쓰레드가 reader를 호출한다고 가정해봅시다. 변수 v에 쓰기연산은 x의 값을 메모리로 내보내고 v를 읽을 경우 그 값을 메모리에서 불러옵니다. A reader에서 v의 값을 true로 본다면 v값이 바뀌기 전에 수행된 x=42는 가시성을 띄게됩니다. 오래된 메모리 모델에서는 적용되지 않을 수 있습니다. 만약 v가 volatile이 아니라면 컴파일러는 writer를 재배열(reorder)하고 reader에서 x를 읽었을때 값이 0일 수 있습니다.</p><p>volatile이 동기화 수준에 갖는 의미는 상당히 강화되었습니다. volatile 필드에 대한 읽기, 쓰기연산은 가시성을 목적으로 절반 수수준으로 동기화 하는 것처럼 동작합니다.</p><p><strong>중요 사항</strong>: 정확하게 happen-before 관계를 만들기 위해 두개의 쓰레드가 동일한 volatile 변수에 접근하는 것은 중요합니다. volatile 변수 f에 값을 쓴뒤 쓰레드 A에 보이는 모든 값들은 volatile 변수 g를 읽은 쓰레드 B에 보이지 않습니다. 해제(release), 획득(acquire)을 반드시 동일한 volatile 필드에서 수행되어야 올바르게 동작합니다.</p><h3>새로운 메모리 모델은 DCL(Double-checked locking) 문제를 해결했습니까?</h3><p>악명높은 DCL(double-checked locking, 멀티 쓰레드 싱글톤 패턴)은 동기화의 오버헤드를 피하면서 지연 초기화(lazy initialization)을 지원하기 위해 고안된 트릭입니다. 아주 초기의 JVM에서 동기화는 매우 느렸었고 개발자들은 동기화를 없애려고 많은 애를 썼습니다. DCL은 다음과 같습니다.:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/c29b0830e2a7cf2091d50f651882ceb4/href">https://medium.com/media/c29b0830e2a7cf2091d50f651882ceb4/href</a></iframe><p>이것은 끔찍하게 영리해보입니다. — 공통 코드에서 동기화를 피할 수 있습니다. 이 코드는 한가지 문제를 갖고 있습니다. — <strong>동작하지 않는 코드입니다</strong>. 가장 확실한 이유는 instance를 초기화하는 것과 instance 필드에 쓰는 것은 컴파일러나 캐시에 의해 재배열(reordering)된다는 것 입니다. 그래서 부분적으로 생성된 Something을 반환하게 됩니다. 그 결과 초기화되지 않은 객체를 읽게됩니다. 왜 이것이 틀린지와 왜 알고리즘상의 보정이 잘못된지에 대한 많은 다른 이유가 있습니다. 오래된 자바 메모리 모델에서는 이런 문제를 해결할 수 없습니다. 더 자세한 사항은 <a href="http://www.javaworld.com/article/2074979/java-concurrency/double-checked-locking--clever--but-broken.html">Double-checked locking: Clever, but broken</a> 와 <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html">The “Double Checked Locking is broken” declaration</a>에서 확인할 수 있습니다.</p><p>많은 사람들은 volatile 키워드가 DCL을 사용할때 발생하는 이 문제를 해결할 수 있다고 생각할 것입니다. JVM 1.5버전 이전에는 volatile은 이러한 동작을 보장하지 않았습니다. 새로운 메모리 모델에서는 instance 필드를 volatile로 만듬으로써 이러한 문제는 해결될 것입니다. volatile은 Somthing 초기화와 이것을 읽는 쓰레드의 값의 반환 사이에 happens-before 관계를 만들기 때문입니다.</p><p>대신에, 이해하기 쉽고 쓰레드 안전한 On Demand Holder 초기화를 사용해보세요.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/2d4c3a03c285af6d1f5206e829b70295/href">https://medium.com/media/2d4c3a03c285af6d1f5206e829b70295/href</a></iframe><p>이 코드는 정적(static) 필드에 대한 초기화 보장 때문에 정확성이 보장됩니다. 만약 필드가 정적 초기화(initializer)에 의해 초기화 된다면 이 클래스에 접근하는 모든 쓰레드에게 정확하게 보이는 것을 보장합니다.</p><h3>VM을 만드는 중이라면 무엇을 볼까요?</h3><p><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html">http://gee.cs.oswego.edu/dl/jmm/cookbook.html</a> 을 확인해 보세요.</p><h3>제가 왜 관심을 가져야 할까요?</h3><p>제가 왜 관심을 가져야 할까요? 동시성 버그는 디버그하기 매우 어렵습니다. 그들은 테스트중에 잘 나타나지 않으며 작업량이 많아질때까지 기다렸다가 나타납니다. 또한 그런 버그를 다시 만들기 어렵습니다. 사전에 프로그램이 정확하게 동기화 되도록 하는 것에 많은 노력을 기울이는 편이 낫습니다. 쉬운일은 아니지만 적절하게 동기화 되지 않은 어플리케이션을 디버깅하는것 보다 훨씬 쉽습니다.</p><p><em>Originally published at </em><a href="http://qwefgh90.github.io/java/JSR-133-%28Java-Memory-Model%29-FAQ%28%EB%B2%88%EC%97%AD%29/"><em>qwefgh90.github.io</em></a><em> on November 29, 2016.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=128487aebc1e" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[윈도우 커버로스 (Kerberos Explained ) 번역]]></title>
            <link>https://medium.com/@qwefgh90/%EC%9C%88%EB%8F%84%EC%9A%B0-%EC%BB%A4%EB%B2%84%EB%A1%9C%EC%8A%A4-kerberos-explained-%EB%B2%88%EC%97%AD-3cb99e63affe?source=rss-74ad5d76277f------2</link>
            <guid isPermaLink="false">https://medium.com/p/3cb99e63affe</guid>
            <category><![CDATA[domain-controller]]></category>
            <category><![CDATA[service-ticket]]></category>
            <category><![CDATA[kerberos]]></category>
            <category><![CDATA[windows]]></category>
            <category><![CDATA[windows-server]]></category>
            <dc:creator><![CDATA[최창원]]></dc:creator>
            <pubDate>Mon, 15 Aug 2016 00:00:00 GMT</pubDate>
            <atom:updated>2019-04-16T05:55:52.809Z</atom:updated>
            <cc:license>http://creativecommons.org/licenses/by/4.0/</cc:license>
            <content:encoded><![CDATA[<p>Mark Walla의 <a href="https://msdn.microsoft.com/en-us/library/bb742516.aspx">“Kerberos Explained”</a> 를 번역한 글입니다.</p><h3>커버로스</h3><p>본 2000년 5월에 발행된 Windows 2000 Advantage magazine에 기고된 글임</p><p>이 글은 커버로스 인증의 입문용으로 알려졌지만 높은 수준의 테크니컬 리뷰입니다. 커버로스는 Windows 2000 Active Directory 구현의 필수적인 부분입니다. 그리고 Windows 2000 엔터프라이즈를 사용하려는 사람들은 보안과 관련된 관리상의 이슈 및 기초에 대해 반드시 알고 있어야 합니다.</p><p>많은 운영체제 벤더들은 MIT에서 고안된 인증 프로토콜을 사용하고 있습니다. 커버로스 버전5는 시간이 갈수록 엔터프라이즈 수준의 운영 환경에서 더욱 중심적인 역할을 할 것입니다. 커버로스는 안전한 사용자 인증을 위한 산업 표준을 제공하고 있습니다. Active Directory 도메인 컨트롤러는 사용자 계정 및 로그인 정보를 유지하고 있으며 커버로스 서비스를 뒷받침하고 있습니다.</p><p>시스템에 접근할때 사용자의 신원을 확인하는 과정은 가장 처음에 위치합니다. 도메인에 가입하지 않는 로컬 머신의 경우에는 시스템에 접근하기전에 Windows NT LAN Manager protocol은 여전이 사용자의 이름과 비밀번호를 확인하고 있습니다. 반면 도메인에 가입한 머신의 경우에는 Active Directory와 커버로스 인증을 사용하고 있습니다. 일단 접근이 허가되면 다른 시스템 자원에 접근을 허락하는 일련의 티켓들이 교환되게됩니다.</p><p>목차는 다음과 같습니다.</p><h3>Kerberos 101</h3><p>Windows 2000 보안의 핵심은 사용자 인증입니다. Active Directory Services는 네트워크상에서 로그인을 구현하기 위해 인증 프로토콜이 필요하게 되었습니다. RFC 1510에 기반을 둔 커버로스 버전5 프로토콜은 분산된 환경과 이기종 운영체제의 상호운영을 위해 진보된 인증을 제공하고 있습니다.</p><p><strong>Defaulting to Kerberos</strong></p><p>NT LAN Manager는 Windows NT와 Windows 2000 워크 그룹 환경에서 사용된 인증 프로토콜입니다. 또한 Windows 2000 Active Directory 도메인 환경에서 Windows NT 시스템을 인증하기 위해 사용되고 있습니다. 더 하위 수준의 Windows NT 도메인 컨트롤러가 존재하지 않는 상태에서는 NT LAN Manager는 비활성화됩니다. 그리고 커버로스는 기본적인 인증으로 엔터프라이즈 환경에서 사용되게됩니다.</p><h3>Understanding Kerberos concepts</h3><p>커버로스 버전5는 모든 버전의 Windows 2000의 표준이며 높은 보안수준을 보장합니다. 커버로스 프로토콜에서 커버로스라는 이름은 그리스 신화에서 3개의 머리를 갖는개로 알려져있습니다. 실제로 커버로스에서 3개의 머리는 키 분배 센터(Key Distribution Center, KDC), 클라이언트, 접근하려는 서비스를 운영하는 서버로 구성되어 있습니다. KDC는 도메인 컨트롤러의 일부분이며 2가지 서비스를 제공합니다. 첫번째는 인증 서비스(Authentication Service, AS), 두번째는 티켓 승인 서비스(Ticket Granting Service, TGS)입니다. 그림 1은 클라이언트가 서버에 접근하는 것과 관련 있습니다.</p><ol><li>AS Exchange</li><li>TGS Exchange</li><li>Client/Server (CS) Exchange</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/335/0*SybZ_GE6SjtnwdYQ.gif" /></figure><h4>AS Exchange</h4><p>처음 네트워크를 통해 로그인을 하였을때 사용자는 KDC의 AS에 로그인 이름과 비밀번호를 제공함으로써 교섭을 시도합니다. 그리고 KDC는 Active Directory 사용자 계정 정보에 접근하게됩니다. 인증이 성공할 경우 사용자는 TGT(Ticket to Get Tickets)를 부여받게 됩니다. TGT는 기본적으로 10시간동안 유효하며 TGT는 비밀번호를 다시 입력받지 않고 세션을 통해 갱신될 수 있습니다. TGT는 로컬 머신의 메모리에 저장되며 또한 네트워크 상으로 서비스에 세션을 요청하는데 사용됩니다. 다음은 TGT 검색 과정에 대해 논의하고 있습니다.</p><h4>Example AS Administration</h4><p>AS(Authentication Service) 는 텍스트에서 클라이언트를 확인하게됩니다. 만약 사전인증(preauthentication)이 허용되어 있다면 사용자의 암호 해시값을 암호키로서 타임스탬프를 암호화하게 됩니다. Active Directory에 저장된 사용자 암호 해시를 이요하여 유효한 시간을 암호화하여 읽어들이고 KDC는 요청이 이전 요청의 replay이지 아닌지 확인할 수 있습니다. 몇몇 어플리케이션을 지원하기 위해 특정 사용자에 대한 사전인증은 해제될 수 있습니다. Active Directory 사용자의 계정 탭에 접근한 다음 “Do not require Kerberos” 옵션을 체크할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/335/0*aHEvKe3Fd72uXLS1.gif" /></figure><p>만약 KDC가 클라이언트의 요청을 승인하게 된다면 2가지의 응답(AS 응답)을 보내게됩니다. 첫번째는 KDC의 비밀키로 암호화된 TGT와 사용자의 암호 해시로 암호화된 세션키 입니다. (이 세션키는 뒤에서 KDC와 통신할때 필요한 것) 클라이언트 시스템은 TGT 티켓의 내용을 읽지 못하기 때문에 TGS에 TGT를 제공하여 서비스 티켓을 요구합니다. TGT는 TTL(time to live), 인증 데이터, 세션키를 포함합니다.</p><h4>TGS Exchange</h4><p>사용자는 TGT(Ticket to Get Tickets)를 KDC안에 있는 TGS(Ticket Granting Service)에 전달하게 됩니다. TGS는 사용자의 TGT를 인증한 뒤 티켓과 세션키를 생성합니다. 이는 클라이언트와 서버 서비스를 위한 것입니다. 이 정보는 서비스 티켓으로 알려져 있으며 클라이언트 머신에 저장되게 됩니다.</p><p>TGS는 클라이언트의 TGT를 자신의 키를 이용해 읽게됩니다. 만약 TGS가 클라이언트의 요구를 승인한다면 클라이언트와 타켓 서버를 양쪽을 위해 서비스 티켓을 생성합니다. 클라이언트는 TGS 세션키(AS 응답으로 받았던)를 사용하여 서비스 티켓의 일부분을 읽을 수 있습니다. 클라이언트는 접속하려는 서버에 TGS의 서버 부분을 전달하게됩니다.</p><h4>Client/Server Exchange</h4><p>일단 사용자가 클라이언트/서버 서비스 티켓을 갖게되면 서버 서비스와 세션을 맺을 수 있습니다. 서버는 KDC로 부터 받은 자신의 키를 이용해 클라이언트로 부터 전송된 TGS 정보를 복호화할 수 있습니다. 그리고 서비스 티켓은 사용자를 인증하게되고 서버와 클라이언트는 세션을 맺게 됩니다. 티켓의 수명이 다하게 되면 서비스 티켓은 반드시 갱신되어야 합니다.</p><h4>Client/Server Exchange Detail</h4><p>클라이언트는 세션을 맺기위해 서비스 티켓의 서버 부분을 서버에 전달하게 됩니다. 만약 상호 인증이 활성화 되어있다면 타겟 서버는 서비스 티켓의 세션키로 암호화된 타임스탬프를 반환합니다. 만약 타임 스탬프가 정상적으로 복호화 된다면 클라이언트는 스스로 서버에게 인증받았을 뿐 아니라 서버 또한 클라이언트에게 인증받은 것 입니다. 타겟 서버는 절대로 KDC와 직접 통신할 수 없으며 이것은 KDC의 다운타임과 압박을 줄일 수 있습니다.</p><p><em>Originally published at </em><a href="http://qwefgh90.github.io/kerberos/%EC%9C%88%EB%8F%84%EC%9A%B0-%EC%BB%A4%EB%B2%84%EB%A1%9C%EC%8A%A4%28Kerberos-Explained%29-%EB%B2%88%EC%97%AD/"><em>qwefgh90.github.io</em></a><em> on August 15, 2016.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3cb99e63affe" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>